{
  "metadata": {
    "timestamp": 1736709882951,
    "page": 367,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "the-tcpdump-group/libpcap",
      "stars": 2757,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 6.18359375,
          "content": "version: '{build}'\n\nclone_depth: 5\n\nbranches:\n  except:\n    - coverity_scan\n\nmatrix:\n  fast_finish: true\n\ninstall:\n  - choco install winflexbison\n  - win_flex --version\n  - win_bison --version\n  - appveyor DownloadFile https://github.com/the-tcpdump-group/tcpdump-htdocs/raw/master/depends/WpdPack_4_1_2.zip\n  - 7z x .\\WpdPack_4_1_2.zip -oc:\\projects\\libpcap\\Win32\n  - appveyor DownloadFile https://npcap.com/dist/npcap-sdk-1.13.zip\n  - 7z x .\\npcap-sdk-1.13.zip -oc:\\projects\\libpcap\\Win32\\npcap-sdk\n\nenvironment:\n  #\n  # The OpenSSL library on the current AppVeyor Visual Studio 2019\n  # images has a weird opensslv.h that claims its 1.0.2, even though\n  # it's 3.0.  This causes... problems.\n  #\n  # For now, we disable the remote capture build there.\n  #\n  matrix:\n      # VS 2017, WinPcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      GENERATOR: \"Visual Studio 15 2017\"\n      PLATFORM: Win32\n      SDK: WpdPack\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      GENERATOR: \"Visual Studio 15 2017\"\n      PLATFORM: x64\n      SDK: WpdPack\n      # VS 2017, Npcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      GENERATOR: \"Visual Studio 15 2017\"\n      PLATFORM: Win32\n      SDK: npcap-sdk\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      GENERATOR: \"Visual Studio 15 2017\"\n      PLATFORM: x64\n      SDK: npcap-sdk\n      # VS 2019, WinPcap, 32-bit and 64-bit x86, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: Win32\n      SDK: WpdPack\n      REMOTE: -DENABLE_REMOTE=NO\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: x64\n      SDK: WpdPack\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2019, Winpcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: Win32\n      SDK: WpdPack\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win32\\bin\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: x64\n      SDK: WpdPack\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n      # VS 2019, Npcap, 32-bit and 64-bit x86, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: Win32\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: x64\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2019, Npcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: Win32\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win32\\bin\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: x64\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n      # VS 2019, Npcap, 64-bit ARM, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: ARM64\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2019, Npcap, 64-bit ARM, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      GENERATOR: \"Visual Studio 16 2019\"\n      PLATFORM: ARM64\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n      # VS 2022, WinPcap, 32-bit and 64-bit x86, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: Win32\n      SDK: WpdPack\n      REMOTE: -DENABLE_REMOTE=NO\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: x64\n      SDK: WpdPack\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2022, WinPcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: Win32\n      SDK: WpdPack\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win32\\bin\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: x64\n      SDK: WpdPack\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n      # VS 2022, Npcap, 32-bit and 64-bit x86, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: Win32\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: x64\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2022, Npcap, 32-bit and 64-bit x86, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: Win32\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win32\\bin\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: x64\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n      # VS 2022, Npcap, 64-bit ARM, without remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: ARM64\n      SDK: npcap-sdk\n      REMOTE: -DENABLE_REMOTE=NO\n      # VS 2022, Npcap, 64-bit ARM, with remote\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      GENERATOR: \"Visual Studio 17 2022\"\n      PLATFORM: ARM64\n      SDK: npcap-sdk\n      OPENSSL_ROOT_DIR: -DOPENSSL_ROOT_DIR=C:\\OpenSSL-v33-Win64\\bin\n\nbuild_script:\n  #\n  # Appveyor defaults to cmd.exe, so use cmd.exe syntax.\n  #\n  - git show --oneline -s\n  - type NUL >.devel\n  - md build\n  - cd build\n  - cmake --version\n  - cmake %REMOTE% %OPENSSL_ROOT_DIR% -DPacket_ROOT=c:\\projects\\libpcap\\Win32\\%SDK% -G\"%GENERATOR%\" -DPacket_ROOT=c:\\projects\\libpcap\\Win32\\%SDK% -DPacket_ROOT=c:\\projects\\libpcap\\Win32\\%SDK% -G\"%GENERATOR%\" -G\"%GENERATOR%\" -A %PLATFORM% ..\n  - msbuild /m /nologo /p:Configuration=Release pcap.sln\n"
        },
        {
          "name": ".ci-coverity-scan-build.sh",
          "type": "blob",
          "size": 3.7685546875,
          "content": "#!/bin/sh\n\nset -e\n\n# Environment check\nprintf \"\\033[33;1mNote: COVERITY_SCAN_PROJECT_NAME and COVERITY_SCAN_TOKEN are available on Project Settings page on scan.coverity.com\\033[0m\\n\"\n[ -z \"$COVERITY_SCAN_PROJECT_NAME\" ] && echo \"ERROR: COVERITY_SCAN_PROJECT_NAME must be set\" && exit 1\n#[ -z \"$COVERITY_SCAN_NOTIFICATION_EMAIL\" ] && echo \"ERROR: COVERITY_SCAN_NOTIFICATION_EMAIL must be set\" && exit 1\n[ -z \"$COVERITY_SCAN_BUILD_COMMAND\" ] && echo \"ERROR: COVERITY_SCAN_BUILD_COMMAND must be set\" && exit 1\n[ -z \"$COVERITY_SCAN_TOKEN\" ] && echo \"ERROR: COVERITY_SCAN_TOKEN must be set\" && exit 1\n\nPLATFORM=$(uname)\nTOOL_ARCHIVE=/tmp/cov-analysis-${PLATFORM}.tgz\nTOOL_URL=https://scan.coverity.com/download/cxx/${PLATFORM}\nTOOL_BASE=/tmp/coverity-scan-analysis\nUPLOAD_URL=\"https://scan.coverity.com/builds\"\nSCAN_URL=\"https://scan.coverity.com\"\n\n# Verify upload is permitted\nAUTH_RES=$(curl -s --form project=\"$COVERITY_SCAN_PROJECT_NAME\" --form token=\"$COVERITY_SCAN_TOKEN\" $SCAN_URL/api/upload_permitted)\nif [ \"$AUTH_RES\" = \"Access denied\" ]; then\n  printf \"\\033[33;1mCoverity Scan API access denied. Check COVERITY_SCAN_PROJECT_NAME and COVERITY_SCAN_TOKEN.\\033[0m\\n\"\n  exit 1\nelse\n  AUTH=$(echo \"$AUTH_RES\" | ruby -e \"require 'rubygems'; require 'json'; puts JSON[STDIN.read]['upload_permitted']\")\n  if [ \"$AUTH\" = \"true\" ]; then\n    printf \"\\033[33;1mCoverity Scan analysis authorized per quota.\\033[0m\\n\"\n  else\n    WHEN=$(echo \"$AUTH_RES\" | ruby -e \"require 'rubygems'; require 'json'; puts JSON[STDIN.read]['next_upload_permitted_at']\")\n    printf \"\\033[33;1mCoverity Scan analysis NOT authorized until %s.\\033[0m\\n\" \"$WHEN\"\n    exit 0\n  fi\nfi\n\nif [ ! -d $TOOL_BASE ]; then\n  # Download Coverity Scan Analysis Tool\n  if [ ! -e \"$TOOL_ARCHIVE\" ]; then\n    printf \"\\033[33;1mDownloading Coverity Scan Analysis Tool...\\033[0m\\n\"\n    wget -nv -O \"$TOOL_ARCHIVE\" \"$TOOL_URL\" --post-data \"project=$COVERITY_SCAN_PROJECT_NAME&token=$COVERITY_SCAN_TOKEN\"\n  fi\n\n  # Extract Coverity Scan Analysis Tool\n  printf \"\\033[33;1mExtracting Coverity Scan Analysis Tool...\\033[0m\\n\"\n  mkdir -p $TOOL_BASE\n  tar xzf \"$TOOL_ARCHIVE\" -C \"$TOOL_BASE\"\nfi\n\nTOOL_DIR=$(find $TOOL_BASE -type d -name 'cov-analysis*')\nexport PATH=\"$TOOL_DIR/bin:$PATH\"\n\n# Build\nprintf \"\\033[33;1mRunning Coverity Scan Analysis Tool...\\033[0m\\n\"\nCOV_BUILD_OPTIONS=\"\"\n#COV_BUILD_OPTIONS=\"--return-emit-failures 8 --parse-error-threshold 85\"\nRESULTS_DIR=\"cov-int\"\neval \"${COVERITY_SCAN_BUILD_COMMAND_PREPEND}\"\n# Do not quote COV_BUILD_OPTIONS so it collapses when it is empty and expands\n# when it is not.\n# shellcheck disable=SC2086\nCOVERITY_UNSUPPORTED=1 cov-build --dir \"$RESULTS_DIR\" $COV_BUILD_OPTIONS \"$COVERITY_SCAN_BUILD_COMMAND\"\ncov-import-scm --dir $RESULTS_DIR --scm git --log $RESULTS_DIR/scm_log.txt 2>&1\n\n# Upload results\nprintf \"\\033[33;1mTarring Coverity Scan Analysis results...\\033[0m\\n\"\nRESULTS_ARCHIVE=analysis-results.tgz\ntar czf $RESULTS_ARCHIVE $RESULTS_DIR\nSHA=$(git rev-parse --short HEAD)\nVERSION_SHA=$(cat VERSION)#$SHA\n\n# Verify Coverity Scan script test mode\nif [ \"${coverity_scan_script_test_mode:-false}\" = true ]; then\n  printf \"\\033[33;1mCoverity Scan configured in script test mode. Exit.\\033[0m\\n\"\n  exit 0\nfi\n\nprintf \"\\033[33;1mUploading Coverity Scan Analysis results...\\033[0m\\n\"\nresponse=$(curl \\\n  --silent --write-out \"\\n%{http_code}\\n\" \\\n  --form project=\"$COVERITY_SCAN_PROJECT_NAME\" \\\n  --form token=\"$COVERITY_SCAN_TOKEN\" \\\n  --form email=blackhole@blackhole.io \\\n  --form file=@$RESULTS_ARCHIVE \\\n  --form version=\"$SHA\" \\\n  --form description=\"$VERSION_SHA\" \\\n  $UPLOAD_URL)\nstatus_code=$(echo \"$response\" | sed -n '$p')\nif [ \"$status_code\" != \"200\" ] && [ \"$status_code\" != \"201\" ]; then\n  TEXT=$(echo \"$response\" | sed '$d')\n  printf \"\\033[33;1mCoverity Scan upload failed with HTTP status code '%s': %s.\\033[0m\\n\" \"$status_code\" \"$TEXT\"\n  exit 1\nfi\n"
        },
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 2.2978515625,
          "content": "# The internal git client reads CIRRUS_CLONE_DEPTH.\nenv:\n  CIRRUS_CLONE_DEPTH: 3\n  AUTOCONF_WARNINGS: no-obsolete\n\nfreebsd_task:\n  name: freebsd-amd64\n  only_if: $CIRRUS_BRANCH != 'coverity_scan'\n  freebsd_instance:\n    cpu: 1\n    memory: 2G\n    image_family: freebsd-13-4\n  env:\n    IGNORE_OSVERSION: yes\n    MATRIX_CC: clang17 gcc13\n  script:\n    - pkg install -qy autoconf gcc13 llvm17\n    - pkg install -qy cmake-core git-tiny # for build_matrix.sh and build.sh\n    - ./build_matrix.sh\n\nlinux_task:\n  name: linux-amd64\n  only_if: $CIRRUS_BRANCH != 'coverity_scan'\n  container:\n    image: ubuntu:24.04\n    cpu: 1\n    memory: 1G\n  env:\n    DEBIAN_FRONTEND: noninteractive\n    LANG: C\n  script:\n    - apt-get -qy update >/dev/null\n    - apt-get -qy install flex bison autoconf make gcc >/dev/null # for \"./configure\"\n    - apt-get -qy install cmake git >/dev/null # for \"make releasecheck\"\n    - apt-get -qy install shellcheck >/dev/null\n    - ./autogen.sh\n    - ./configure --quiet # build the Makefile\n    - make releasecheck\n    - make whitespacecheck\n    - make shellcheck\n\nmacos_task:\n  name: macos-aarch64\n  only_if: $CIRRUS_BRANCH != 'coverity_scan'\n  macos_instance:\n    image: ghcr.io/cirruslabs/macos-runner:sonoma # last 3 versions of Xcode\n  env:\n    MAKEFLAGS: '-j 4' # macOS VMs run on 4 cores\n  script:\n    - brew update >/dev/null\n    - brew install openssl@3\n    - ./build_matrix.sh\n\ncoverity_task:\n  name: Coverity Scan\n  only_if: $CIRRUS_BRANCH == 'coverity_scan'\n  container:\n    image: ubuntu:24.04\n    cpu: 1\n    memory: 2G\n  env:\n    DEBIAN_FRONTEND: noninteractive\n    COVERITY_SCAN_PROJECT_NAME: $CIRRUS_REPO_FULL_NAME\n    COVERITY_SCAN_TOKEN: ENCRYPTED[58bfbfcf624e5b7b85fb9df95dd0b3f9f93642824e6ae94616e4d345af4848580932a6ece02337fee112194b29ce6593]\n    COVERITY_SCAN_BUILD_COMMAND_PREPEND: ./configure --enable-remote --enable-optimizer-dbg --enable-yydebug\n    COVERITY_SCAN_BUILD_COMMAND: make\n    LANG: C\n  script:\n    - apt-get -qy update >/dev/null\n    - apt-get -qy install libdbus-1-dev libbluetooth-dev libnl-genl-3-dev libibverbs-dev libssl-dev >/dev/null\n    - apt-get -qy install flex bison autoconf make gcc >/dev/null\n    - apt-get -qy install git curl wget ruby rubygems ruby-json >/dev/null # for the coverity script\n    - apt list --installed 'lib*-dev'\n    - ./autogen.sh\n    - ./.ci-coverity-scan-build.sh\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1298828125,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# things that only make sense on github.com\n.github export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.9228515625,
          "content": ".DS_Store\n*.orig\n*.rej\n/Makefile\n*~\n.*.swo\n.*.swp\n/*.o\nCMakeCache.txt\ncmake_install.cmake\nCMakeFiles/\n/config.h\n/config.h.in\n/config.log\n/config.cache\n/config.status\n/configure\n/stamp-h\n/stamp-h.in\n/autom4te.cache/\n/.devel\n/grammar.c\n/grammar.h\n/grammar.y\n/libpcap.a\n/libpcap.*.dylib\n/libpcap.pc\n/libpcap.sl\n/libpcap.so\n/libpcap.so.*\n/libpcap.shareda\n/libpcap-*.tar.gz\n/os-proto.h\n/pcap-config\n/pcap-filter.manmisc\n/pcap-linktype.manmisc\n/cbpf-savefile.manfile\n/pcap-savefile.manfile\n/pcap-tstamp.manmisc\n/pcap.3pcap\n/pcap_compile.3pcap\n/pcap_datalink.3pcap\n/pcap_dump_open.3pcap\n/pcap_get_tstamp_precision.3pcap\n/pcap_list_datalinks.3pcap\n/pcap_list_tstamp_types.3pcap\n/pcap_open_dead.3pcap\n/pcap_open_offline.3pcap\n/pcap_set_immediate_mode.3pcap\n/pcap_set_tstamp_precision.3pcap\n/pcap_set_tstamp_type.3pcap\n/scanner.c\n/scanner.c.bottom\n/scanner.h\n*.log\n*.tlog\n*.obj\n*.sdf\n*.opensdf\n*.suo\n*.pdb\n*.lib\n*.dll\n*.exp\n*.vcxproj.user\nDebug/\nRelease/\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 1.6591796875,
          "content": "Assar Westerlund <assar@sics.se> assar <assar>\nBill Fenner <fenner@gmail.com> fenner <fenner>\nDenis Ovsienko <denis@ovsienko.info> <infrastation@yandex.ru>\nFrancois-Xavier Le Bail <devel.fx.lebail@orange.fr> fxlb <fx.lebail@yahoo.com>\nFrancois-Xavier Le Bail <devel.fx.lebail@orange.fr> <fx.lebail@yahoo.com>\nFulvio Risso <risso@polito.it> risso <risso>\nGianluca Varenni <gianluca.varenni@gmail.com> gianluca <gianluca>\nGuy Harris <gharris@sonic.net> <gharris@localhost.localdomain>\nGuy Harris <gharris@sonic.net> <gharris@steve.local>\nGuy Harris <gharris@sonic.net> <gharris@ubu9-10.(none)>\nGuy Harris <gharris@sonic.net> <guy@alum.mit.edu>\nGuy Harris <gharris@sonic.net> Guy (Core OS) Harris <gharris@gharris.apple.com>\nGuy Harris <gharris@sonic.net> guy <guy>\nHannes Gredler <hannes@gredler.at> hannes <hannes>\nHannes Gredler <hannes@gredler.at> <hannes@juniper.net>\nJun-ichiro itojun Hagino <itojun@iijlab.net> itojun <itojun>\nKen Hornstein <kenh@cmf.nrl.navy.mil> kenh <kenh>\nLoris Degioanni <loris@netgroup-serv.polito.it> loris <loris>\nMichael Richardson <mcr@sandelman.ca> <mcr@credil.org>\nMichael Richardson <mcr@sandelman.ca> <mcr@finepoint.com>\nMichael Richardson <mcr@sandelman.ca> mcr <mcr>\nMichael Richardson <mcr@sandelman.ca> <mcr@sandelman.ottawa.on.ca>\nMichael Richardson <mcr@sandelman.ca> <mcr@tcpdump.org>\nStephen Donnelly <stephen.donnelly@emulex.com> <sfd@nzhmlwks0033.(none)>\nStephen Donnelly <stephen.donnelly@emulex.com> sfd <stephen.donnelly@emulex.com>\nStephen Donnelly <stephen.donnelly@emulex.com> sfd <stephen.donnelly@endace.com>\nStephen Donnelly <stephen.donnelly@emulex.com> <stephen.donnelly@endace.com>\nTorsten Landschoff <t.landschoff@gmx.net> torsten <torsten>\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 77.9638671875,
          "content": "DayOfTheWeek, Month DD, YYYY / The Tcpdump Group\n  Summary for 1.11.0 libpcap release (so far!)\n    Source code:\n      Use C99 fixed-width integer types, rather than self-defined\n        fixed-width integer types, in rpcap code.\n      Remove an always-false pointer test from snf_read().\n      Clean up DECnet address handling.\n      struct pcap: Update buffer type from \"void *\" to \"u_char *\".\n      Remove dead code that supported SITA ACN devices.\n      Remove the TODO file.\n      Merge four header files into gencode.c.\n      Remove DAG card support on Windows as Linux is the only\n        platform currently supported.\n      Remove code related to Riverbed TurboCap card.\n        Riverbed TurboCap hardware has reached EOA as of Jun 30 2014.\n      Remove dead code that supported Septel devices.\n      Remove outdated code related to AirPcap HW.\n        The Riverbed AirPcap Product has reached End of Availability\n        (EOA) as of December 31, 2017\n      Mind netmap support in pcap_lib_version().\n    Link-layer types:\n      Add LINKTYPE_ETW/DLT_ETW.\n      Add LINKTYPE_NETANALYZER_NG/DLT_NETANALYZER_NG (pull request\n        #1008).\n      Add LINKTYPE_ZBOSS_NCP/DLT_ZBOSS_NCP.\n      Add LINKTYPE_USB_2_0_LOW_SPEED/DLT_USB_2_0_LOW_SPEED,\n        LINKTYPE_USB_2_0_FULL_SPEED/DLT_USB_2_0_FULL_SPEED,\n        LINKTYPE_USB_2_0_HIGH_SPEED/DLT_USB_2_0_HIGH_SPEED\n      Add LINKTYPE_AUERSWALD_LOG/DLT_AUERSWALD_LOG.\n      Add LINKTYPE_ZWAVE_TAP/DLT_ZWAVE_TAP.\n      Add LINKTYPE_SILABS_DEBUG_CHANNEL/DLT_SILABS_DEBUG_CHANNEL.\n      Add LINKTYPE_FIRA_UCI/DLT_FIRA_UCI.\n      Rename LINKTYPE_IPMB_LINUX/DLT_IPMB_LINUX to\n        LINKTYPE_I2C_LINUX/DLT_I2C_LINUX, as it's really just an\n        encapsulation of I2C, and is also being used for HDMI DDC.\n        Keep DLT_IPMB_LINUX around as a #define for backwards\n        compatibility.\n    Packet filtering:\n      Add support for Block Ack Req and Block Ack frame types (pull\n        request #1039).\n      Deprecate pcap_compile_nopcap().\n      Add support for filtering packets encapsulated with VXLAN (pull\n        request #1273).\n      Eliminate trailing space in bpf_image() result.\n      Fix DECnet packet filtering on big-endian hosts.\n      Require \"vpi\" and \"vci\" values to be within valid ranges.\n      Initialize the scratch memory store to 0.\n      Require \"[wlan] dir\" integer value to be within range.\n      Fix the != comparison for ATM and MTP field values.\n    rpcap:\n      Support user names and passwords in rpcap:// and rpcaps:// URLs.\n      Add a -t flag to rpcapd to specify the data channel port; from\n        another incorporate-remote-capture project. (issue #1120)\n      rpcapd: Refine SSL options in printusage().\n      Fix a possible buffer overflow (Coverity CID 1619148).\n    Documentation:\n      Document a standard format for writing out BPF filter programs.\n      Add a README.hurd.md file.\n      Explain \"any\" device better in pcap_create(3PCAP).\n      Cross-reference some man pages better.\n      Actualize README.dag and make it Markdown.\n      Add a README.snf.md file.\n      pcap-filter(7): Clarify Ethernet, IPv4 and IPv6.\n      pcap_lib_version(3PCAP): Add details and examples.\n    Building and testing:\n      Apply GNU Hurd support patch from the Debian package.\n      CI: Introduce and use LIBPCAP_CMAKE_TAINTED.\n      Remove all remaining support for AOS (4.3BSD Unix), BSD/OS, DOS,\n        HP-UX before 10.20, IRIX, {OSF/1, Digital Unix, Tru64 Unix}, SINIX,\n        SunOS 3.x, 4.x and 5.x before 5.3.2, and Ultrix.\n      Add a new test program for pcap_activate().\n      Make NetBSD build warning-free.\n      Make Sun C build warning-free.\n      Make FreeBSD, Linux and macOS builds warning-free.\n      Print MAC addresses in findalldevstest.\n      Parameterize the interface name in reactivatetest.\n      When necessary, trust the OS to implement ffs().\n      At build time require a proof of suitable snprintf(3) implementation in\n        libc (and document Solaris 9 and MinGW as unsupported because of that).\n      Makefile.in: Update the .c.o build rule (Remove hacks for old SunOS 4).\n      CMake: Skip snprintf(3) tests when cross-compiling; test whether\n        check_c_source_runs() with a trivial program and, if it doesn't\n        work, don't run tests that use it.\n      autogen.sh: Allow to configure Autoconf warnings.\n      autogen.sh: Delete all trailing blank lines at end of configure.\n      Autoconf: Add support for libnl-tiny with pkg-config.\n      Autoconf: Fix building of something-only libpcap.\n      CI: Implement \"make check\".\n      Fix autotools and CMake issues with snprintf test and sanitizers.\n        Fixes issue #1396.\n    Hurd:\n      Support network capture devices too.\n      Fix a few device activation bugs.\n      Count and timestamp packets better.\n      Add kernel filtering, fix userland filtering.\n    OpenBSD:\n      Use getprotobyname_r() correctly on OpenBSD.\n    DAG:\n      Always set PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE.\n      In dag_findalldevs() handle known errors better.\n      Trust dag_get_stream_erf_types() to be available.\n      Require the API to have 64-bit streams support.\n      Make device descriptions more useful, make dagN conditional.\n      Use PCAP_ERROR_NO_SUCH_DEVICE more in dag_activate().\n      Validate capture device names better.\n      Enumerate streams without trying to lock them.\n      If the environment variable ERF_FCS_BITS is set, require it to be either\n        0 or 16 or 32.  Likewise for ERF_DONT_STRIP_FCS (either 0 or 1).\n      Remove FCS quirks specific to 4.2S and 4.23S.\n      Fix packet filtering with low snaplen.\n      Fix ps_drop for stream drop counters.\n      Add experimental packet transmit support.\n    SNF:\n      Fix packet filtering with low snaplen.\n      Require SNF_VERSION_API >= 0x0003.\n      Improve device descriptions and flags.\n      Fill pcap_if_t in more consistently.\n\nDayOfTheWeek, Month DD, YYYY / The Tcpdump Group\n  Summary for 1.10.6 libpcap release (so far!)\n    Source code:\n      Fix \"tcpdump -i <n>\" for something-only libpcap builds.\n      Remove some unneeded includes.\n      pcapint_find_function() changed to return \"void *\" to avoid\n        warnings.\n      gencode: Fix an undefined behavior in gen_mcode().\n    Packet filtering:\n      Make the chunk allocator's alignment more general and\n        platform-independent.\n    Linux:\n      Fix check for mac80211 phydev.\n      Don't create monitor-mode interface if we're capturing on one.\n    FreeBSD:\n      Fix detection and enablng of zero-copy supporrt.\n      Fix errors in the zero-copy code.\n    Solaris:\n      Fix not to ignore logical interfaces in fad-gifc.c and\n        fad-glifc.c.\n    D-Bus:\n      Fix message leak.\n    Capture file writing:\n      Don't close the output stream if it's stdout, just flush it.\n    Documentation:\n      Explicitly document that closing a pcap_t for a savefile opened\n        with pcap_fopen_offline() will close the standard I/O stream.\n    Building and testing:\n      Makefile.in: Include instrument-functions.c in the release tarball.\n      CMake: Fix libnl usage with pkg-config.\n      CMake: Fix build with CMake 3.31.\n      CI: Report CMake version in builds.\n      CI: Visual Studio 2022 builds added, including ARM64 builds;\n        Visual Studio 2015 builds dropped.\n      Don't build with sslutils.c if we don't have a TLS library.\n      Build on Windows with a newer version of OpenSSL.\n      CMake: generalize handling of non-x86 Windows architectures.\n      CI: use the -A flag for all Visual Studio generators.\n\nFriday, August 30, 2024 / The Tcpdump Group\n  Summary for 1.10.5 libpcap release\n    Source code:\n      Spell WirelessHART details properly.\n      Mark pcap_vasprintf() as printf-like.\n      Finalize moving of bpf_filter.c. (GH #1166)\n      Remove an unneeded argument from gen_mcode6().\n      Don't do some Berkeley YACC workarounds with YACC releases not\n        requiring them.\n      Use correct data types rather than int in some cases.\n      Squelch compiler warning in grammar.c.\n      Fix findalldevtest compilation if IPv6 isn't enabled.\n      Rename helper routines for pcap modules to have names beginning with\n        pcapint_, to avoid namespace collisions for code linking statically\n        with libpcap.\n      Avoid casting hack for the Windows cleanup-on-exit routine.\n      Use %zu format for one case of printing a size_t.\n      Fix some Coverity errors.\n      Fix availabilities of some functions to match reality.\n      pcap: make the seconds and microseconds/nanoseconds fields unsigned.\n      Remove the unused pcap-rpcap-int.h header file.\n    Thread safety:\n      Make some static variables thread-local; fixes issue #1174.\n    Packet filtering:\n      Improve reporting of some invalid filter expressions.\n      Return an error from pcap_compile() if the scanner fails to initialize.\n      Optimizer fix from Archit Shah to recompute dominators after\n        moving code (#976); fixes #945 (although the resulting filter\n        isn't empty).\n      Optimizer fix from Archit Shah to mark value as unknown when store\n        of that value is deleted (#972); fixes #143, #434, #436, #437,\n        and #1076.\n    Linux:\n      Properly return warnings.\n      Don't use DLT_LINUX_SLL2 for anything other than the \"any\" device.\n      Avoid 32-bit unsigned integer overflow in USB captures.  Fixes\n        issues #1134 and #1205.\n      Fix a file descriptor leak.\n      Properly report warnings about unknown ARPHRD_ types.\n      Fix DLT_CAN_SOCKETCAN handling of CAN FD.\n      Add CAN XL support to DLT_CAN_SOCKETCAN.\n      Clean up the code that sets the \"real\" (\"original\") length for\n        isochronous USB transfers.\n      Avoid unnecessary blocking on recvmsg() in the Bluetooth monitor and\n        Bluetoth modules.\n    Solaris:\n      Handle BPF returning ESRCH for unknown devices.\n      List the \"any\" device if it's supported.\n      Report {non-existent zone}/{interface} errors appropriately.\n      Allow attaching to links owned by a non-global zone.  (Based on\n        pull request #1202.)\n      Fix AF_LINK handling on illumos.\n    macOS:\n      Redid the availability macros to be closer to what Apple's doing\n        in recent SDKs, including tagging pcap-namedb.h routines.\n      Fix the install name of the installed shared library to have a\n        full path when building with CMake.\n      Fix universal builds.\n    Haiku:\n      Convert the module to C.  Fixes issue #1114.\n      Address a few compiler warnings.  Fixes issue #1114.\n      Fix various build problems.  Fixes issue #1114.\n      Report non-existent devices correctly.\n      Fix handling of packet statistics.\n      Fix packet timestamping.\n      Fix packet filtering with low snaplen.\n      Improve connection status reporting.\n      Add support for promiscuous mode.\n      Detect DLTs and loopback capture support at run time.\n      Report IEEE 802.11 as PCAP_IF_WIRELESS.\n    Windows:\n      Fix internal handling of \"not supported\" error codes from NPF.\n      Work around a bug in Npcap 1.00 in case of driver version mismatch.\n      Don't call WSACleanup() when handling a failed WSAStartup().\n    BSD, macOS, AIX, Solaris 11, Linux:\n      Add a new error PCAP_ERROR_CAPTURE_NOTSUP, for use if a capture\n        mechanism is not present, in the hopes that, for example,\n        attempts to capture on Windows Services for Linux 1, in which\n        the NT kernel attempts to simulate Linux system calls but does\n        not support packet sockets, can get an error that better\n        indicates the underlying problem.\n    AirPcap:\n      Format an error message if we run out of memory.\n    nflog:\n      Fix count of dropped packets.\n      Make sure we don't overflow when rounding up the TLV length.\n    rpcap:\n      Handle routines removed in at least some OpenSSL libraries.\n      CVE-2023-7256: Clean up sock_initaddress() and its callers to avoid\n        double frees in some cases.\n      Don't define SOCKET ourselves; instead, define PCAP_SOCKET as int\n        on UN*Xes and as SOCKET on Windows.\n      CVE-2024-8006: Fix pcap_findalldevs_ex() not to crash if passed a\n        file:// URL with a path to a directory that cannot be opened.\n    Savefiles:\n      Handle DLT_/LINKTYPE_ mapping better, to handle some\n        OpenBSD-specific link types better.\n      Treat if_tsoffset as signed in pcapng files, as the spec says.\n      Don't try to fix the \"real\" length for isochronous USB\n        transfers if the number of USB descriptors is too large.\n      Reject pcap files where one of the reserved fields in the\n        \"link-layer type plus other stuff\" is non-zero.\n    Building and testing:\n      Add a configure option to help debugging (--enable-instrument-functions).\n      Improved tests and error reporting for uses of pkg-config, and\n        improve help message.\n      Fix Haiku build.\n      With CMake, install headers in CMAKE_INSTALL_INCLUDEDIR rather\n        than just include.\n      Build libpcap.a before building test programs.\n      Print address family numerically, as well as symbolically,\n        in findalldevstest.\n      Fail with suggestions, rather than failing over to no capture\n        support, if no capture mechanism was found.  Fixes issue #1016.\n      Don't indent comments in Make, as that may cause them not to be\n        recognized as comments.\n      Don't check for libssl if we aren't going to use it.\n      Better handle enabling and disabling of sanitizers.  Fixes issue\n        #1171.\n      CMakeLists.txt: Print \"Symlinking: /some/path to ...\" conditionally.\n      Evaluate CMAKE_INSTALL_PREFIX at install time.\n      cmake: Update the minimum required version to 2.8.12 (except Windows).\n      cmake: suppress CMP0042 OLD deprecated warning.\n      Makefile.in: Add the releasecheck target.\n      Cirrus CI: Add the \"make releasecheck\" command in the Linux task.\n      Makefile.in: Add the whitespacecheck target.\n      Cirrus CI: Run the \"make whitespacecheck\" command in the Linux task.\n      Autoconf: Update config.{guess,sub}, timestamps 2024-01-01.\n      Autoconf: Update the install-sh script to the 2020-11-14.01 version.\n      Compile with '-Wnull-pointer-subtraction',\n        '-Wunused-but-set-parameter', and '-Wunused-but-set-variable' in\n        devel mode if supported.\n      Don't ignore spaces between CMAKE_C_FLAGS and DPDK_C_FLAGS with\n        CMake.\n      Use noreturn and __format__ with XL C 7.0 and later.\n      Check for the same -W flags in autotools and CMake.\n      Autoconf: Add autogen.sh, remove configure and config.h.in and put\n        these generated files in the release tarball.\n      Autoconf: Get the size of a time_t.\n      Fix propagation of cc_werr_cflags() output.\n      Makefile.in(s): Fix the depend target.\n      mkdep: Exit with a non-zero status if a command fails.\n      Fix HCI_CHANNEL_MONITOR detection with musl libc.\n      Extend \"make shellcheck\" onto mkdep too.\n      Add initial support for building with TinyCC.\n      Address all known compiler warnings specific to illumos, Linux, NetBSD,\n        Solaris and Sun C; in CI expect warnings specific to TinyCC only.\n    Documentation:\n      Update and fix pcap-filter man page.\n      Add a README.haiku.md file.\n      Document pcap-config better.\n      Man page formatting and prose fixes.\n      Rename doc/README.Win32.md to doc/README.windows.md.\n      Update pcap-savefile man page to match the Internet-Draft for\n        pcap.\n      Fix CMake issues for target used by other projects.\n      Explain \"any\" device better in pcap_open_live(3PCAP).\n      Update INSTALL.md.\n      Note in man pages that errbuf arguments must point to an error\n        buffer.\n      Note that if pcap_findalldevs() fails it sets *alldevsp to NULL;\n        there's no devices list to free.\n      Explain \"other addresses\" in pcap_findalldevs(3PCAP).\n      Document pcap_lookupnet(3PCAP) a bit better.\n\nFriday, April 7, 2023 / The Tcpdump Group\n  Summary for 1.10.4 libpcap release\n    Source code:\n      Fix spaces before tabs in indentation.\n    rpcap:\n      Fix name of launchd service.\n    Documentation:\n      Document use of rpcapd with systemd, launchd, inetd, and xinetd.\n    Building and testing:\n      Require at least pkg-config 0.17.0, as we use --static.\n      Get rid of the remains of gnuc.h.\n      Require at least autoconf 2.69.\n      Update config.{guess,sub}, timestamps 2023-01-01,2023-01-21.\n\nThursday, January 12, 2023 / The Tcpdump Group\n  Summary for 1.10.3 libpcap release\n    Source code:\n      Sort the PUBHDR variable in Makefile.in in \"ls\" order.\n      Fix typo in comment in pflog.h.\n      Remove two no-longer-present files from .gitignore.\n      Update code and comments for handling failure to set promiscuous\n        mode based on new information.\n    Building and testing:\n      install: Fixed not to install the non-public pcap-util.h header.\n      pcap-config: add a --version flag.\n      Makefile.in: Add some missing files in the distclean target.\n\nSaturday, December 31, 2022 / The Tcpdump Group\n  Summary for 1.10.2 libpcap release\n    Source code:\n      Use __builtin_unreachable() in PCAP_UNREACHABLE.\n      Use AS_HELP_STRING macro instead of AC_HELP_STRING in the\n        configure scripts, to avoid deprecation warnings.\n      Change availability tags in pcap.h to make it easier to\n        arrange for it to be used in Darwin releases.\n      Use AS_HELP_STRING for --enable-remote.\n      Fix some formatting string issues found by cppcheck.\n      Various small code and comment cleanups.\n      Use PCAP_ERROR (defined as -1) rather than explicit -1 for\n        functions the documentation says return PCAP_ERROR.\n      Remove unused code from the filter compiler.\n      Use _declspec(deprecated(msg)) rather than __pragma(deprecated)\n        for Windows deprecation warnings, so the message that was\n        specified shows up.\n      diag-control.h: define PCAP_DO_PRAGMA() iff we're going to use it.\n      Use \"%d\" to print some signed ints.\n      Use the Wayback Machine for a removed document in a comment.\n      Add some const qualifiers.\n      RDMA: Use PRIu64 to print a uint64_t.\n    \"Dead\" pcap_ts from pcap_open_dead() and ..._with_tstamp_precision():\n        Don't crash if pcap_breakloop() is called.\n    Savefiles:\n      Fix pcap_dispatch() to return number of packets processed, rather\n        than 0, even at EOF.\n      If we get an error writing the packet header, don't write the\n        packet data.\n      Put PFLOG UID and PID values in the header into host byte order\n        when reading a LINKTYPE_PFLOG file.\n      Put CAN ID field in CAN pseudo-headers for LINUX_SLL2, as we do\n        for LINUX_SLL.\n      Fix incorrectly-computed \"real\" length for isochronous USB\n        transfers when reading savefiles.\n      Don't crash if pcap_can_set_rfmon() is called.\n      Fix pcap_offline_read() loop.\n    Capture:\n      Never process more than INT_MAX packets in a pcap_dispatch() call,\n        to avoid integer overflow (issue #1087).\n      Improve error messages for \"no such device\" and \"permission\n        denied\" errors.\n      SITA: Fix a typo in a variable name.\n    Packet filtering:\n      Get PFLOG header length from the length value in the header.\n      Support all the direction, reason, and action types supported by\n        all systems that support PFLOG.\n      Don't require PFLOG support on the target machine in order to\n        support PFLOG filtering (also fixes issue #1076).\n      Expand abbreviations into \"proto X\" properly.\n      gencode.c: Update a comment about the VLAN TPID test.\n      Add the minimum and maximum matching DLTs to an error message.\n    Linux:\n      Fix memory leak in capture device open (pull request #1038).\n      Fix detection of CAN/CAN FD packets in direction check (issue\n        #1051).\n      Fix double-free crashes on errors such as running on a kernel with\n        CONFIG_PACKET_MMAP not configured (issue #1054).\n      Use DLT_CAN_SOCKETCAN for CANbus interfaces (issue #1052; includes\n        changes from pull request #1035).\n      Make sure the CANFD_FDF can be relied on to indicate whether a\n        CANbus packet is a CAN frame or a CAN FD frame\n      Improve error message for \"out of memory\" errors for kernel\n        filters (see issue #1089).\n      Fix pcap_findalldevs() to find usbmon devices.\n      Fix handling of VLAN tagged packets if the link-layer type is\n        changed from DLT_LINUX_SLL to DLT_LINUX_SLL2 (see issue #1105).\n      Always turn on PACKET_AUXDATA (see issue #1105).\n      We require 2.6.27 or later, so PACKET_RESERVE is available.\n      Make sure there's reserved space for a DLT_LINUX_SLL2 header\n        when capturing.\n      Correctly compute the \"real\" length for isochronous USB transfers.\n      Don't have an eventfd descriptor open in non-blocking mode, so as\n        not to waste descriptors.\n      netfilter: Squelch a narrowing warning (To be look at before 2038).\n    BPF capture (*BSD, macOS, AIX, Solaris 11):\n      Fix case where a device open might fail, rather than falling back\n        to a smaller buffer size, when the initial buffer size is too\n        big.\n      Use an unsigned device number to iterate over BPF devices, to\n        squelch a compiler warning.\n    NetBSD:\n      Fix handling of LINKTYPE_HDLC/DLT_HDLC.\n    rpcap:\n      Fix unaligned accesses in rpcapd (pull request #1037).\n      Fix code to process port number.\n      Clean up findalldevs code in rpcapd.\n      Clean up bufferizing code.\n      Fix a file descriptor/handle leak in pcap_findalldevs_ex()\n        (Coverity CID 1507240).\n      Improve error messages for host and port resolution errors.\n      Fix connect code not to fail if both IPv4 and IPv6 addresses are\n        tried.\n      Improve connect failure error message.\n      Provide an error message for a bad authentication reply size.\n      For link-layer types with host-endian fields in the header, fix\n        those fields if capturing from a server with a different byte\n        order.\n      Suppress temporarily the warnings with \"enable remote packet capture\".\n    Windows:\n      Add support for NdisMediumIP (pull request #1027).\n      Don't require applications using pcap to be built with VS 2015 or\n        later.\n      Use the correct string for the DLL VersionInfo.\n      Remove unnecessary DllMain() function.\n      Correctly handle ERROR_INVALID_FUNCTION from\n        PacketGetTimestampModes() (indicate that WinPcap or an older\n        version of Npcap is probably installed).\n      Fix use-after-free in some cases when a pcap_t is closed.\n      Make sure an error is returned by pcap_create_interface() if\n        PacketOpenAdapter() fails.\n      Return an error if the driver reports 0 timestamp modes supported.\n      Close the ADAPTER handle for some errors in\n        pcap_create_interface().\n      Get rid of old unmaintained VS project files.\n      Fix deprecation warning for pcap_handle().\n      Npcap is now at npcap.com, not npcap.org.\n      Make sure \"no such device\" and \"no permission to open device\"\n        errors show up in pcap_activate(), not pcap_create() (fixes,\n        among other things, tcpdump -i <interface-number>).\n      npcap: squelch deprecation warnings for kernel dump mode.\n    Haiku:\n      Implement pcap_lib_version(), as now required.\n      Handle negative or too-large snaplen values.\n      Fix various build issues and warnings.\n    Building and testing:\n      Update configure-time universal build checks for macOS.\n      Update config.guess and config.sub.\n      If we look for an SSL library with pkg-config in configure script,\n        try pkg-config first.\n      If we have pkg-config and Homebrew, try to set pkg-config up to\n        find Homebrew packages.\n      Handle some Autoconf/make errors better.\n      Use \"git archive\" for the \"make releasetar\" process.\n      Remove the release candidate rcX targets.\n      Fix compiling on Solaris 9/SPARC and 11/AMD64.\n      Address assorted compiler warnings.\n      Fix cross-building on Linux for Windows with mingw32 for Win64\n        (pull request #1031).\n      Properly set installation directory on Windows when not compiling\n        with MSVC.\n      Fix configure script checks for compiler flags.\n      Give more details if check for usable (F)Lex fails.\n      Fix compiling with GCC 4.6.4.\n      Don't use add_compile_options() with CMake, as we currently don't\n        require 2.8.12, where it first appeared.\n      Don't provide -L/usr/lib for pkg-config --libs in pkg-config.\n      Fix error message for inadequate Bison/Berkeley YACC.\n      configure: correctly do some DPDK checks.\n      Only use pkg-config when checking for DPDK.\n      Allow the path in which DPDK is installed to be specified.\n      Use pkg-config first when checking for libibverbs.\n      CMake: fix check for libibverbs with Sun's C compiler.\n      Have CMake warn if no capture mechanism can be found.\n      Don't do stuff requiring 3.19 or later on earlier CMakes.\n      Squelch some CMake warnings.\n      Fix diag-control.h to handle compiling with clang-cl (issues\n        #1101 and #1115).\n      Cleanup various leftover cruft in the configure script.\n      Fix building without protochain support. (GH #852)\n      Check for a usable YACC (or Bison) and {F}lex in CMake, as we do\n        in autotools.\n      Only check for a C++ compiler on Haiku, as that's the only\n        platform with C++ code, and make sure they generate code for\n        the same instruction set bit-width (both 32-bit or both 64-bit)\n        (issue #1112).\n      On Solaris, check the target bit-width and set PKG_CONFIG_PATH\n        appropriately, to handle the mess that is the D-Bus library\n        package (issue #1112).\n      Fix generation of pcap-config and libpcap.pc files (issue #1062).\n      pcap-config: don't assume the system library directory is /usr/lib.\n      pcap-config: add a --static-pcap-only flag.\n      Cirrus CI: Use the same configuration as for the main branch.\n      Add four libpcap test files.\n      Update Npcap SDK to 1.13.\n      Makefile.in: Use TEST_DIST, like for tcpdump.\n      Remove awk code from mkdep.\n      Cirrus CI: Add the libssl-dev package in the Linux task.\n      Cirrus CI: Add the openssl@3 brew package in the macOS task.\n      Get \"make shellcheck\" to pass again.\n      CMake: Build valgrindtest only if Autoconf would.\n      CMake: use ${CMAKE_INSTALL_SBINDIR} rather than just sbin.\n      CMake: use NUL: as the null device on Windows.\n      autoconf: fix typo in test of macOS version.\n      Makefile.in: Add two missing files in EXTRA_DIST.\n      autotools, cmake: provide an rpath option if necessary.\n      configure: get rid of the attempt to auto-run PKG_PROG_PKG_CONFIG.\n      configure: use PKG_CHECK_MODULES to run pkg-config.\n    Documentation:\n      Add README.solaris.md.\n      Add SCTP to pcap-filter(7).\n      Note that = and == are the same operator in filters (issue #1044).\n      Update INSTALL.md, README.md, and README.solaris.md.\n      Update and clean up CONTRIBUTING.md.\n      Trim documentation of support for now-dead UN*Xe and older\n        versions of other UN*Xes.\n      Move the \"how to allocate a LINKTYPE_/DLT_ value\" documentation to\n        the web site.\n      Clean up man pages.\n      Move README.capture-module to the web site.\n      Improve some protocol details in pcap-filter(7).\n      Refine \"relop\" notes in pcap-filter(7).\n      In pcap-filter(7) \"domain\" is an id.\n      Discuss backward compatibility in pcap-filter(7).\n      Other improvements to pcap-filter(7).\n      Document pcap_breakloop(3PCAP) interaction with threads better.\n      Document PCAP_ERROR_NOT_ACTIVATED for more routines.\n\nWednesday, June 9, 2021:\n  Summary for 1.10.1 libpcap release:\n    Packet filtering:\n      Fix \"type XXX subtype YYY\" giving a parse error\n    Source code:\n      Add PCAP_AVAILABLE_1_11.\n    Building and testing:\n      Rename struct bpf_aux_data to avoid NetBSD compile errors\n      Squelch some compiler warnings\n      Squelch some Bison warnings\n      Fix cross-builds with older kernels lacking BPF_MOD and BPF_XOR\n      Fix Bison detection for minor version 0.\n      Fix parallel build with FreeBSD make.\n      Get DLT_MATCHING_MAX right in gencode.c on NetBSD.\n      Define timeradd() and timersub() if necessary.\n      Fix Cygwin/MSYS target directories.\n      Fix symlinking with DESTDIR.\n      Fix generation of libpcap.pc with CMake when not building a shared\n          library.\n      Check for Arm64 as well as x86-64 when looking for packet.lib on\n          Windows.\n    Documentation:\n      Refine Markdown in README.md.\n      Improve the description of portrange in filters.\n      README.linux.md isn't Markdown, rename it just README.linux.\n    pcapng:\n      Support reading version 1.2, which some writers produce, and which\n          is the same as 1.0 (some new block types were added, but\n          that's not sufficient reason to bump the minor version number,\n          as code that understands those new block types can handle them\n          in a 1.0 file)\n    Linux:\n      Drop support for text-mode USB captures, as we require a 2.6.27\n          or later kernel (credit to Chaoyuan Peng for noting the\n          sscanf vulnerabilities in the text-mode code that got me to\n          realize that we didn't need this code any more)\n      Bluetooth: fix non-blocking mode.\n      Don't assume that all compilers used to build for Linux support\n          the __atomic builtins\n    Windows:\n      Add more information in \"interface disappeared\" error messages, in\n        the hopes of trying to figure out the cause.\n      Treat ERROR_DEVICE_REMOVED as \"device was removed\".\n      Indicate in the error message which \"device was removed\" error\n          occurred.\n      Report the Windows error status if PacketSendPacket() fails.\n      Use %lu for ULONGs in error message formats.\n      Don't treat the inability to find airpcap.dll as an error.\n      Ignore spurious error reports by Microsoft Surface mobile\n          telephony modem driver\n    rpcap:\n      Clean up error checking and error messages for server address\n          lookup.\n\nTuesday, December 29, 2020\n  Summary for 1.10.0 libpcap release\n    Add support for capturing on DPDK devices\n    Label most APIs by the first release in which they're available\n    Fix some memory leaks, including in pcap_compile()\n    Add pcap_datalink_val_to_description_or_dlt()\n    Handle the pcap private data in a fashion that makes fewer\n       assumptions about memory layouts (might fix GitHub issue #940\n       on ARM)\n    Fix some thread safety issues\n    pcap_findalldevs(): don't sort interfaces by unit number\n    Always return a list of supported time-stamp types, even if only\n        host time stamps are supported\n    Increase the maximum snaplen for LINKTYPE_USBPCAP/DLT_USBPCAP\n    Report the DLT description in error messages\n    Add pcap_init() for first-time initialization and global option\n        setting; it's not required, but may be used\n    Remove (unused) SITA support\n    Capture file reading:\n        Correctly handle pcapng captures with more than one IDB with a\n            snapshot length greater than the supported maximum\n    Capture file writing:\n        Create the file in pcap_dump_open_append() if it doesn't exist\n    Packet filtering:\n        Fix \"unknown ether proto 'aarp'\"\n        Add a new filter \"ifindex\" for DLT_LINUX_SLL2 files on all\n            platforms and live Linux captures\n        Add a hack to the optimizer to try to catch certain optimizer\n            loops (should prevent GitHub issue #112)\n        Show special Linux BPF offsets symbolically in bpf_image() and\n            bpf_dump()\n        Added support for ICMPv6 types 1-4 as tokens with names\n        Remove undocumented and rather old \"ether proto\" protocols\n        Catch invalid IPv4 addresses in filters\n        Don't assume ARM supports unaligned accesses\n    Security and other issues found by analysis:\n        Fix various security issues reported by Charles Smith at Tangible\n            Security\n        Fix various security issues reported by Include Security\n        Fix some issues found by cppcheck.\n        Add some overflow checks in the optimizer\n    rpcap:\n        Support rpcap-over-TLS\n        Redo protocol version negotiation to avoid problems with old\n            servers (it still works with servers using the old negotiation,\n            as well as servers not supporting negotiation)\n        Error handling cleanups\n        Add some new authentication libpcap error codes for specific\n            errors\n        Fix some inetd issues in rpcapd\n        Fix rpcapd core dumps with invalid configuration file\n        On UN*X, don't have rpcapd tell the client why authentication\n            failed, so a brute-force attacker can't distinguish between\n            \"unknown user name\" and \"known user name, wrong password\"\n        Allow rpcapd to rebind more rapidly (GitHub issue #765)\n    Documentation:\n        Improve man pages, including adding backward compatibility notes\n    Building and testing:\n        Require, and assume, some level of C99 support in the C compiler\n        Require Visual Studio 2015 or later if using Visual Studio\n        Fix configure script issues, including with libnl on Linux\n        Fix CMake issues\n        Squelch complaints from Bison about \"%define api.pure\" being\n            deprecated\n        Fix compilation of pcap-tc.c\n    Linux:\n        Require PF_PACKET support, and kernel 2.6.27 or later\n        Handle systems without AF_INET or AF_UNIX socket support\n        Get rid of Wireless Extensions for turning monitor mode on\n        Proper memory sync for PACKET_MMAP (may prevent GitHub issue\n            #898)\n        Drop support for libnl 1 and 2.\n        Return error on interface going away, but not if it just went\n            down but is still present\n        Set socket protocol only after packet ring configured,\n            reducing bogus packet drop reports\n        Get ifdrop stats from sysfs.\n        When adjusting BPF programs, do not subtract the\n            SLL[2]_HDR_LEN if the location is negative (special metadata\n            offset), to preserve references to metadata; see\n            https://github.com/the-tcpdump-group/tcpdump/issues/480#issuecomment-486827278\n        Report a warning for unknown ARPHRD types\n        Have pcap_breakloop() forcibly break out of a sleeping\n            capture loop\n        Add support for DSA data link types\n        For raw USB bus capture, use the snapshot length to set the\n            buffer size, and set the len field to reflect the length\n            in the URB (GitHub issue #808)\n        With a timeout of zero, wait indefinitely\n        Clean up support for some non-GNU libc C libraries\n        Add DLT_LINUX_SLL2 for cooked-mode captures\n        Probe CONFIGURATION descriptor of connected USB devices\n        Treat EPERM on ethtool ioctls as meaning \"not supported\", as\n            permissions checks are done before checking whether the\n            ioctl is supported at all\n    macOS:\n        Cope with getting EPWROFF from SIOCGIFMEDIA\n        Treat EPERM on SIOCGIFMEDIA as meaning \"not supported\", as\n            permissions checks are done before checking whether the\n            ioctl is supported at all\n        Treat ENXIO when reading packets as meaning \"the interface\n            was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    FreeBSD:\n        Treat ENXIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    NetBSD:\n        Treat ENXIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    OpenBSD:\n        Treat EIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    DragonFly BSD:\n        Treat ENXIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    Solaris:\n        Treat ENXIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    AIX:\n        Fix loading of BPF kernel extension\n        Treat ENXIO as meaning \"the interface was removed\"\n        Report \"the interface disappeared\", not \"the interface went\n            down\", if the interface was removed during a capture\n    Windows:\n        Make the snapshot length work even if pcap_setfilter()\n            isn't called\n        Fix compilation on Cygwin/MSYS\n        Add pcap_handle(), and deprecate pcap_fileno()\n        Report PCAP_ERROR_NO_SUCH_DEVICE for a nonexistent device\n        Return an appropriate error message for device removed or\n            device unusable due to a suspend/resume\n        Report a warning for unknown NdisMedium types\n        Have pcap_breakloop() forcibly break out of a sleeping\n            capture loop\n        Clean up building DLL\n        Handle CRT mismatch for pcap_dump_fopen()\n        Map NdisMediumWirelessWan to DLT_RAW\n        Add AirPcap support in a module, rather than using\n            WinPcap/Npcap's support for it\n        Report the system error for PacketSetHwFilter() failures\n        Add support for getting and setting packet time stamp types\n            with Npcap\n        Have pcap_init() allow selecting whether the API should use\n            local code page strings or UTF-8 strings (including error\n            messages)\n    Haiku:\n        Add capture support\n\nSunday, July 22, 2018\n  Summary for 1.9.1 libpcap release\n    Mention pcap_get_required_select_timeout() in the main pcap man page\n    Fix pcap-usb-linux.c build on systems with musl\n    Fix assorted man page and other documentation issues\n    Plug assorted memory leaks\n    Documentation changes to use https:\n    Changes to how time stamp calculations are done\n    Lots of tweaks to make newer compilers happier and warning-free and\n        to fix instances of C undefined behavior\n    Warn if AC_PROG_CC_C99 can't enable C99 support\n    Rename pcap_set_protocol() to  pcap_set_protocol_linux().\n    Align pcap_t private data on an 8-byte boundary.\n    Fix various error messages\n    Use 64-bit clean API in dag_findalldevs()\n    Fix cleaning up after some errors\n    Work around some ethtool ioctl bugs in newer Linux kernels (GitHub\n        issue #689)\n    Add backwards compatibility sections to some man pages (GitHub issue\n        #745)\n    Fix autotool configuration on AIX and macOS\n    Don't export bpf_filter_with_aux_data() or struct bpf_aux_data;\n        they're internal-only and subject to change\n    Fix pcapng block size checking\n    On macOS, don't build rpcapd or test programs any fatter than they\n        need to be\n    Fix reading of capture statistics for Linux USB\n    Fix packet size values for Linux USB packets (GitHub issue #808)\n    Check only VID in VLAN test in filters (GitHub issue #461)\n    Fix pcap_list_datalinks on 802.11 devices on macOS\n    Fix overflows with very large snapshot length in pcap file\n    Improve parsing of rpcapd configuration file (GitHub issue #767)\n    Handle systems without strlcpy() or strlcat() better\n    Fix crashes and other errors with invalid filter expressions\n    Fix use of uninitialized file descriptor in remote capture\n    Fix some CMake issues\n    Fix some divide-by-zero issues with the filter compiler\n    Work around a GNU libc bug in pcap_nametonetaddr()\n    Add support for DLT_LINUX_SLL2\n    Fix handling of the packet-count argument for Myricom SNF devices\n    Fix --disable-rdma in configure script (GitHub issue #782)\n    Fix compilation of TurboCap support (GitHub issue #764)\n    Constify first argument to pcap_findalldevs_ex()\n    Fix a number of issues when running rpcapd as an inetd-style daemon\n    Fix CMake issues with D-Bus libraries\n    In rpcapd, clean up termination of a capture session\n    Redo remote capture protocol negotiation\n    In rpcapd, report the same error for \"invalid user name\" and\n        \"invalid password\", to make brute-forcing harder\n    For remote captures, add an error code for \"the server requires TLS\"\n    Fix pcap_dump_fopen() on Windows to avoid clashes between\n        {Win,N}Pcap and application C runtimes\n    Fix exporting of functions from Windows DLLs (GitHub issue #810)\n    Fix building as part of Npcap\n    Allow rpcapd to rebind more rapidly\n    Fix building shared libpcap library on midipix (midipix.org)\n    Fix hack to detect UTF-16LE adapter names on Windows not to go past\n        the end of the string\n    Fix handling of \"wireless WAN\" (mobile phone network modems) on\n        Windows with WinPcap/Npcap (GitHub issue #824)\n    Have pcap_dump_open_append() create the dump file if it doesn't\n        exists (GitHub issue #247)\n    Fix the maximum snapshot length for DLT_USBPCAP\n    Use -fPIC when building for 64-bit SPARC on Linux (GitHub issue #837)\n    Fix CMake 64-bit library installation directory on some Linux\n        distributions\n    Boost the TPACKET_V3 timeout to the maximum if a timeout of 0 was\n        specified\n    Five CVE-2019-15161, CVE-2019-15162, CVE-2019-15163, CVE-2019-15164, CVE-2019-15165\n    PCAPNG reader applies some sanity checks before doing malloc().\n\nSunday, June 24, 2018, by mcr@sandelman.ca\n  Summary for 1.9.0 libpcap release\n    Added testing system to libpcap, independent of tcpdump\n    Changes to how pcap_t is activated\n    Adding support for Large stream buffers on Endace DAG cards\n    Changes to BSD 3-clause license to 2-clause license\n    Additions to TCP header parsing, per RFC3168\n    Add CMake build process (extensive number of changes)\n    Assign a value for OpenBSD DLT_OPENFLOW.\n    Support setting non-blocking mode before activating.\n    Extensive build support for Windows VS2010 and MINGW (many many changes, over many months)\n    Added RPCAPD support when --enable-remote (default no)\n    Add the rpcap daemon source and build instructions.\n    Put back the greasy \"save the capture filter string so we can tweak it\"\n        hack, that keeps libpcap from capturing rpcap traffic.\n    Fixes for captures on MacOS, utun0\n    fixes so that non-AF_INET addresses, are not ==AF_INET6 addresses.\n    Add a linktype for IBM SDLC frames containing SNA PDUs.\n    pcap_compile() in 1.8.0 and later is newly thread-safe.\n    bound snaplen for linux tpacket_v2 to ~64k\n    Make VLAN filter handle both metadata and inline tags\n    D-Bus captures can now be up to 128MB in size\n    Added LORATAP DLT value\n    Added DLT_VSOCK for https://qemu-project.org/Features/VirtioVsock\n    probe_devices() fixes not to overrun buffer for name of device\n    Add linux-specific pcap_set_protocol_linux() to allow specifying a specific capture protocol.\n    RDMA sniffing support for pcap\n    Add Nordic Semiconductor Bluetooth LE sniffer link-layer header type.\n    fixes for reading /etc/ethers\n    Make it possible to build on Windows without packet.dll.\n    Add tests for large file support on UN*X.\n    Solaris fixes to work with 2.8.6\n    configuration test now looks for header files, not capture devices present\n    Fix to work with Berkeley YACC.\n    fixes for DragonBSD compilation of pcap-netmap.c\n    Clean up the ether_hostton() stuff.\n    Add an option to disable Linux memory-mapped capture support.\n    Add DAG API support checks.\n    Add Septel, Myricom SNF, and Riverbed TurboCap checks.\n    Add checks for Linux USB, Linux Bluetooth, D-Bus, and RDMA sniffing support.\n    Add a check for hardware time stamping on Linux.\n    Don't bother supporting pre-2005 Visual Studio.\n    Increased minimum autoconf version requirement to 2.64\n    Add DLT value 273 for XRA-31 sniffer\n    Clean up handing of signal interrupts in pcap_read_nocb_remote().\n    Use the XPG 4.2 versions of the networking APIs in Solaris.\n    Fix, and better explain, the \"IPv6 means IPv6, not IPv4\" option setting.\n    Explicitly warn that negative packet buffer timeouts should not be used.\n    rpcapd: Add support inetd-likes, including xinetd.conf, and systemd units\n    Rename DLT_IEEE802_15_4 to DLT_IEEE802_15_4_WITHFCS.\n    Add DISPLAYPORT AUX link type\n    Remove the sunos4 kernel modules and all references to them.\n    Add more interface flags to pcap_findalldevs().\n  Summary for 1.9.0 libpcap release (to 2017-01-25 by guy@alum.mit.edu)\n    Man page improvements\n    Fix Linux cooked mode userspace filtering (GitHub pull request #429)\n    Fix compilation if IPv6 support not enabled\n    Fix some Linux memory-mapped capture buffer size issues\n    Don't fail if kernel filter can't be set on Linux (GitHub issue\n      #549)\n    Improve sorting of interfaces for pcap_findalldevs()\n    Don't list Linux usbmon devices if usbmon module isn't loaded\n    Report PCAP_ERROR_PERM_DENIED if no permission to open Linux usbmon\n      devices\n    Fix DLT_ type for Solaris IPNET devices\n    Always return an error message for errors finding DAG or Myricom\n      devices\n    If possible, don't require that a device be openable when\n      enumerating them for pcap_findalldevs()\n    Don't put incompletely-initialized addresses in the address list for\n    When finding Myricom devices, update description for regular\n      interfaces that are Myricom devices and handle SNF_FLAGS=0x2(port\n      aggregation enabled)\n    Fix compilation error in DAG support\n    Fix issues with CMake configuration\n    Add support for stream buffers larger than 2GB on newer DAG cards\n    Remove support for building against DAG versions without STREAMS\n      support (before dag-3.0.0 2007)\n\nTuesday, Oct. 25, 2016 mcr@sandelman.ca\n  Summary for 1.8.1 libpcap release\n    Add a target in Makefile.in for Exuberant Ctags use: 'extags'.\n    Rename configure.in to configure.ac: autoconf 2.59\n    Clean up the name-to-DLT mapping table.\n    Add some newer DLT_ values: IPMI_HPM_2,ZWAVE_R1_R2,ZWAVE_R3,WATTSTOPPER_DLM,ISO_14443,RDS\n    Clarify what the return values are for both success and failure.\n    Many changes to build on windows\n    Check for the \"break the loop\" condition in the inner loop for TPACKET_V3.\n    Fix handling of packet count in the TPACKET_V3 inner loop: GitHub issue #493.\n    Filter out duplicate looped back CAN frames.\n    Fix the handling of loopback filters for IPv6 packets.\n    Add a link-layer header type for RDS (IEC 62106) groups.\n    Use different intermediate folders for x86 and x64 builds on Windows.\n    On Linux, handle all CAN captures with pcap-linux.c, in cooked mode.\n    Removes the need for the \"host-endian\" link-layer header type.\n    Compile with '-Wused-but-marked-unused' in devel mode if supported\n    Have separate DLTs for big-endian and host-endian SocketCAN headers.\n    Reflect version.h being renamed to pcap_version.h.\n    Require that version.h be generated: all build procedures we support generate version.h (autoconf, CMake, MSVC)!\n    Properly check for sock_recv() errors.\n    Re-impose some of Winsock's limitations on sock_recv().\n    Replace sprintf() with pcap_snprintf().\n    Fix signature of pcap_stats_ex_remote().\n    Initial cmake support for remote packet capture.\n    Have rpcap_remoteact_getsock() return a SOCKET and supply an \"is active\" flag.\n    Clean up {DAG, Septel, Myricom SNF}-only builds.\n    Do UTF-16-to-ASCII conversion into the right place.\n    pcap_create_interface() needs the interface name on Linux.\n    Clean up hardware time stamp support: the \"any\" device does not support any time stamp types.\n    Add support for capturing on FreeBSD usbusN interfaces.\n    Add a LINKTYPE/DLT_ value for FreeBSD USB.\n    Go back to using PCAP_API on Windows.\n    CMake support\n    Add TurboCap support from WinPcap.\n    Recognize 802.1ad nested VLAN tag in vlan filter.\n\nThursday Sep. 3, 2015 guy@alum.mit.edu\n  Summary for 1.7.5 libpcap release\n\tMan page cleanups.\n\tAdd some allocation failure checks.\n\tFix a number of Linux/ucLinux configure/build issues.\n\tFix some memory leaks.\n\tRecognize 802.1ad nested VLAN tag in vlan filter.\n\tFix building Bluetooth Linux Monitor support with BlueZ 5.1+\n\nSaturday Jun. 27, 2015 mcr@sandelman.ca\n  Summary for 1.7.4 libpcap release\n\tInclude fix for GitHub issue #424 -- out of tree builds.\n\nFriday Apr. 10, 2015 guy@alum.mit.edu\n  Summary for 1.7.3 libpcap release\n\tWork around a Linux bonding driver bug.\n\nThursday Feb. 12, 2015 guy@alum.mit.edu/mcr@sandelman.ca\n  Summary for 1.7.2 libpcap release\n\tSupport for filtering Geneve encapsulated packets.\n\tGeneralize encapsulation handling, fixing some bugs.\n\tDon't add null addresses to address lists.\n\tAdd pcap_dump_open_append() to open for appending.\n\tFix the swapping of isochronous descriptors in Linux USB.\n\tAttempt to handle TPACKET_V1 with 32-bit userland and 64-bit kernel.\n\nWednesday Nov. 12, 2014 guy@alum.mit.edu/mcr@sandelman.ca\n  Summary for 1.7.0 libpcap release\n\tFix handling of zones for BPF on Solaris\n\tnew DLT for ZWAVE\n\tclarifications for read timeouts.\n\tUse BPF extensions in compiled filters, fixing VLAN filters\n\tsome fixes to compilation without stdint.h\n\tEBUSY can now be returned by SNFv3 code.\n\tFix the range checks in BPF loads\n\tVarious DAG fixes.\n\tVarious Linux fixes.\n\nMonday Aug. 12, 2014 guy@alum.mit.edu\n  Summary for 1.6.2 libpcap release\n\tDon't crash on filters testing a nonexistent link-layer type\n\t    field.\n\tFix sending in non-blocking mode on Linux with memory-mapped\n\t    capture.\n\tFix timestamps when reading pcap-ng files on big-endian\n\t    machines.\n\nSaturday  Jul. 19, 2014 mcr@sandelman.ca\n  Summary for 1.6.1 libpcap release\n\tsome fixes for the any device\n\tchanges for how --enable-XXX (--enable-sniffing, --enable-can) works\n\nWednesday Jul. 2, 2014 mcr@sandelman.ca\n  Summary for 1.6.0 libpcap release\n        Don't support D-Bus sniffing on OS X\n        fixes for byte order issues with NFLOG captures\n        Handle using cooked mode for DLT_NETLINK in activate_new().\n        on platforms where you can not capture on down interfaces, do not list them\n        but: do list interfaces which are down, if you can capture on them!\n\nWednesday December 18, 2013 guy@alum.mit.edu\nSummary for 1.5.3 libpcap release\n\tDon't let packets that don't match the current filter get to the\n\t    application when TPACKET_V3 is used. (GitHub issue #331)\n\tFix handling of pcap_loop()/pcap_dispatch() with a packet count\n\t    of 0 on some platforms (including Linux with TPACKET_V3).\n\t    (GitHub issue #333)\n\tWork around TPACKET_V3 deficiency that causes packets to be lost\n\t    when a timeout of 0 is specified. (GitHub issue #335)\n\tMan page formatting fixes.\n\nWednesday December 4, 2013 guy@alum.mit.edu\nSummary for 1.5.2 libpcap release\n\tFix libpcap to work when compiled with TPACKET_V3 support and\n\t    running on a kernel without TPACKET_V3 support. (GitHub\n\t    issue #329)\n\nWednesday November 20, 2013 guy@alum.mit.edu\nSummary for 1.5.1 libpcap release\n\tReport an error, rather than crashing, if an IPv6 address is\n\t    used for link-layer filtering.  (Wireshark bug 9376)\n\nWednesday October 30, 2013 guy@alum.mit.edu\nSummary for 1.5.0 libpcap release\n\tTPACKET_V3 support added for Linux\n\tPoint users to the the-tcpdump-group repository on GitHub rather\n\t    than the mcr repository\n\tChecks added for malloc()/realloc()/etc. failures\n\tFixed build on Solaris 11\n\tSupport filtering E1 SS7 traffic on MTP2 layer Annex A\n\tUse \"ln -s\" to link man pages by default\n        Add support for getting nanosecond-resolution time stamps when\n\t    capturing and reading capture files\n        Many changes to autoconf to deal better with non-GCC compilers\n        added many new DLT types\n\nSaturday April 6, 2013 guy@alum.mit.edu\nSummary for 1.4.0 libpcap release\n\tAdd netfilter/nfqueue interface.\n\tIf we don't have support for IPv6 address resolution, support,\n\t    in filter expressions, what IPv6 stuff we can.\n\tFix pcap-config to include -lpthread if canusb support is\n\t    present\n\tTry to fix \"pcap_parse not defined\" problems when --without-flex\n\t    and --without-bison are used when you have Flex and Bison\n\tFix some issues with the pcap_loop man page.\n\tFix pcap_getnonblock() and pcap_setnonblock() to fill in the\n\t    supplied error message buffer\n\tFix typo that, it appeared, would cause pcap-libdlpi.c not to\n\t    compile (perhaps systems with libdlpi also have BPF and use\n\t    that instead)\n\tCatch attempts to call pcap_compile() on a non-activated pcap_t\n\tFix crash on Linux with CAN-USB support without usbfs\n\tFix addition of VLAN tags for Linux cooked captures\n\tCheck for both EOPNOTSUPP and EINVAL after SIOCETHTOOL ioctl, so\n\t    that the driver can report either one if it doesn't support\n\t    SIOCETHTOOL\n\tAdd DLT_INFINIBAND and DLT_SCTP\n\tDescribe \"proto XXX\" and \"protochain XXX\" in the pcap-filter man\n\t    page\n\tHandle either directories, or symlinks to directories, that\n\t    correspond to interfaces in /sys/class/net\n\tFix handling of VLAN tag insertion to check, on Linux 3.x\n\t    kernels, for VLAN tag valid flag\n\tClean up some man pages\n\tSupport libnl3 as well as libnl1 and libnl2 on Linux\n\tFix handling of Bluetooth devices on 3.x Linux kernels\n\nFriday  March 30, 2012.  mcr@sandelman.ca\nSummary for 1.3.0 libpcap release\n        Handle DLT_PFSYNC in {FreeBSD, other *BSD+Mac OS X, other}.\n        Linux: Don't fail if netfilter isn't enabled in the kernel.\n        Add new link-layer type for NFC Forum LLCP.\n        Put the CANUSB stuff into EXTRA_DIST, so it shows up in the release tarball.\n        Add LINKTYPE_NG40/DLT_NG40.\n        Add DLT_MPEG_2_TS/LINKTYPE_MPEG_2_TS for MPEG-2 transport streams.\n        [PATCH] Fix AIX-3.5 crash with read failure during stress\n        AIX fixes.\n        Introduce --disable-shared configure option.\n        Added initial support for canusb devices.\n        Include the pcap(3PCAP) additions as 1.2.1 changes.\n        many updates to documentation: pcap.3pcap.in\n        Improve 'inbound'/'outbound' capture filters under Linux.\n        Note the cleanup of handling of new DLT_/LINKTYPE_ values.\n        On Lion, don't build for PPC.\n        For mac80211 devices we need to clean up monitor mode on exit.\n\nFriday  December 9, 2011.  guy@alum.mit.edu.\nSummary for 1.2.1 libpcap release\n\tUpdate README file.\n\tFix typos in README.linux file.\n\tClean up some compiler warnings.\n\tFix Linux compile problems and tests for ethtool.h.\n\tTreat Debian/kFreeBSD and GNU/Hurd as systems with GNU\n\t toolchains.\n\tSupport 802.1 QinQ as a form of VLAN in filters.\n\tTreat \"carp\" as equivalent to \"vrrp\" in filters.\n\tFix code generated for \"ip6 protochain\".\n\tAdd some new link-layer header types.\n\tSupport capturing NetFilter log messages on Linux.\n\tClean up some error messages.\n\tTurn off monitor mode on exit for mac80211 interfaces on Linux.\n\tFix problems turning monitor mode on for non-mac80211 interfaces\n\t on Linux.\n\tProperly fail if /sys/class/net or /proc/net/dev exist but can't\n\t be opened.\n\tFail if pcap_activate() is called on an already-activated\n\t pcap_t, and add a test program for that.\n\tFix filtering in pcap-ng files.\n\tDon't build for PowerPC on Mac OS X Lion.\n\tSimplify handling of new DLT_/LINKTYPE_ values.\n\tExpand pcap(3PCAP) man page.\n\nSunday  July 24, 2011.  mcr@sandelman.ca.\nSummary for 1.2 libpcap release\n        All of the changes listed below for 1.1.1 and 1.1.2.\n        Changes to error handling for pcap_findalldevs().\n        Fix the calculation of the frame size in memory-mapped captures.\n        Add a link-layer header type for STANAG 5066 D_PDUs.\n        Add a link-layer type for a variant of 3GPP TS 27.010.\n        Noted real nature of LINKTYPE_ARCNET.\n        Add a link-layer type for DVB-CI.\n        Fix configure-script discovery of VLAN acceleration support.\n         see https://netoptimizer.blogspot.com/2010/09/tcpdump-vs-vlan-tags.html\n        Linux, HP-UX, AIX, NetBSD and OpenBSD compilation/conflict fixes.\n        Protect against including AIX 5.x's <net/bpf.h> having been included.\n        Add DLT_DBUS, for raw D-Bus messages.\n        Treat either EPERM or EACCES as \"no soup for you\".\n        Changes to permissions on DLPI systems.\n        Add DLT_IEEE802_15_4_NOFCS for 802.15.4 interfaces.\n\nFri.    August 6, 2010.  guy@alum.mit.edu.\nSummary for 1.1.2 libpcap release\n\tReturn DLT_ values, not raw LINKTYPE_ values from\n\t  pcap_datalink() when reading pcap-ng files\n\tAdd support for \"wlan ra\" and \"wlan ta\", to check the RA and TA\n\t  of WLAN frames that have them\n\tDon't crash if \"wlan addr{1,2,3,4}\" are used without 802.11\n\t  headers\n\tDo filtering on USB and Bluetooth capturing\n\tOn FreeBSD/SPARC64, use -fPIC - it's apparently necessary\n\tCheck for valid port numbers (fit in a 16-bit unsigned field) in\n\t  \"port\" filters\n\tReject attempts to put savefiles into non-blocking mode\n\tCheck for \"no such device\" for the \"get the media types\" ioctl\n\t  in *BSD\n\tImprove error messages from bpf_open(), and let it do the error\n\t  handling\n\tReturn more specific errors from pcap_can_set_rfmon(); fix\n\t  documentation\n\tUpdate description fetching code for FreeBSD, fix code for\n\t  OpenBSD\n\tIgnore /sys/net/dev files if we get ENODEV for them, not just\n\t  ENXIO; fixes handling of bonding devices on Linux\n\tFix check for a constant 0 argument to BPF_DIV\n\tUse the right version of ar when cross-building\n\tFree any filter set on a savefile when the savefile is closed\n\tInclude the CFLAGS setting when configure was run in the\n\t  compiler flags\n\tAdd support for 802.15.4 interfaces on Linux\n\nThu.    April 1, 2010.  guy@alum.mit.edu.\nSummary for 1.1.1 libpcap release\n\tUpdate CHANGES to reflect more of the changes in 1.1.0.\n\tFix build on RHEL5.\n\tFix shared library build on AIX.\n\nThu.\tMarch 11, 2010.  ken@netfunctional.ca/guy@alum.mit.edu.\nSummary for 1.1.0 libpcap release\n\tAdd SocketCAN capture support\n\tAdd Myricom SNF API support\n\tUpdate Endace DAG and ERF support\n\tAdd support for shared libraries on Solaris, HP-UX, and AIX\n\tBuild, install, and un-install shared libraries by default;\n\t  don't build/install shared libraries on platforms we don't support\n\tFix building from a directory other than the source directory\n\tFix compiler warnings and builds on some platforms\n\tUpdate config.guess and config.sub\n\tSupport monitor mode on mac80211 devices on Linux\n\tFix USB memory-mapped capturing on Linux; it requires a new DLT_\n\t  value\n\tOn Linux, scan /sys/class/net for devices if we have it; scan\n\t  it, or /proc/net/dev if we don't have /sys/class/net, even if\n\t  we have getifaddrs(), as it'll find interfaces with no\n\t  addresses\n\tAdd limited support for reading pcap-ng files\n\tFix BPF driver-loading error handling on AIX\n\tSupport getting the full-length interface description on FreeBSD\n\tIn the lexical analyzer, free up any addrinfo structure we got back\n\t  from getaddrinfo().\n\tAdd support for BPF and libdlpi in OpenSolaris (and SXCE)\n\tHyphenate \"link-layer\" everywhere\n\tAdd /sys/kernel/debug/usb/usbmon to the list of usbmon locations\n\tIn pcap_read_linux_mmap(), if there are no frames available, call\n\t  poll() even if we're in non-blocking mode, so we pick up\n\t  errors, and check for the errors in question.\n\tNote that poll() works on BPF devices is Snow Leopard\n\tIf an ENXIO or ENETDOWN is received, it may mean the device has\n\t  gone away.  Deal with it.\n\tFor BPF, raise the default capture buffer size to from 32k to 512k\n\tSupport ps_ifdrop on Linux\n\tAdded a bunch of #ifdef directives to make wpcap.dll (WinPcap) compile\n\t under cygwin.\n\tChanges to Linux mmapped captures.\n\tFix bug where create_ring would fail for particular snaplen and\n\t  buffer size combinations\n\tUpdate pcap-config so that it handles libpcap requiring\n\t  additional libraries\n\tAdd workaround for threadsafeness on Windows\n\tAdd missing mapping for DLT_ENC <-> LINKTYPE_ENC\n\tDLT: Add DLT_CAN_SOCKETCAN\n\tDLT: Add Solaris ipnet\n\tDon't check for DLT_IPNET if it's not defined\n\tAdd link-layer types for Fibre Channel FC-2\n\tAdd link-layer types for Wireless HART\n\tAdd link-layer types for AOS\n\tAdd link-layer types for DECT\n\tAutoconf fixes (AIX, HP-UX, OSF/1, Tru64 cleanups)\n\tInstall headers unconditionally, and include vlan.h/bluetooth.h if\n\t  enabled\n\tAutoconf fixes+cleanup\n\tSupport enabling/disabling bluetooth (--{en,dis}able-bluetooth)\n\tSupport disabling SITA support (--without-sita)\n\tReturn -1 on failure to create packet ring (if supported but\n\t  creation failed)\n\tFix handling of 'any' device, so that it can be opened, and no longer\n\t  attempt to open it in Monitor mode\n\tAdd support for snapshot length for USB Memory-Mapped Interface\n\tFix configure and build on recent Linux kernels\n\tFix memory-mapped Linux capture to support pcap_next() and\n\t  pcap_next_ex()\n\tFixes for Linux USB capture\n\tDLT: Add DLT_LINUX_EVDEV\n\tDLT: Add DLT_GSMTAP_UM\n\tDLT: Add DLT_GSMTAP_ABIS\n\nMon.    October 27, 2008.  ken@netfunctional.ca.  Summary for 1.0.0 libpcap release\n\tCompile with IPv6 support by default\n\tCompile with large file support on by default\n\tAdd pcap-config script, which deals with -I/-L flags for compiling\n\tDLT: Add IPMB\n\tDLT: Add LAPD\n\tDLT: Add AX25 (AX.25 w/KISS header)\n\tDLT: Add JUNIPER_ST\n\t802.15.4 support\n\tVariable length 802.11 header support\n\tX2E data type support\n\tSITA ACN Interface support - see README.sita\n\tSupport for memory-mapped capture on Linux\n\tSupport for zerocopy BPF on platforms that support it\n\tSupport for setting buffer size when opening devices\n\tSupport for setting monitor mode when opening 802.11 devices\n\tBetter support for dealing with VLAN tagging/stripping on Linux\n\tFix dynamic library support on OSX\n\tReturn PCAP_ERROR_IFACE_NOT_UP if the interface isn't 'UP', so applications\n\t can print better diagnostic information\n\tReturn PCAP_ERROR_PERM_DENIED if we don't have permission to open a device, so\n\t applications can tell the user they need to go play with permissions\n\tOn Linux, ignore ENETDOWN so we can continue to capture packets if the\n\t interface goes down and comes back up again.\n\tOn Linux, support new tpacket frame headers (2.6.27+)\n\tOn Mac OS X, add scripts for changing permissions on /dev/bpf* and launchd plist\n\tOn Solaris, support 'passive mode' on systems that support it\n\tFixes to autoconf and general build environment\n\tMan page reorganization + cleanup\n\tAutogenerate VERSION numbers better\n\nMon.    September 10, 2007.  ken@xelerance.com.  Summary for 0.9.8 libpcap release\n        Change build process to put public libpcap headers into pcap subdir\n        DLT: Add value for IPMI IPMB packets\n        DLT: Add value for u10 Networks boards\n        Require <net/pfvar.h> for pf definitions - allows reading of pflog formatted\n         libpcap files on an OS other than where the file was generated\n\nWed.\tApril 25, 2007.  ken@xelerance.com.  Summary for 0.9.6 libpcap release\n\n\tPut the public libpcap headers into a pcap subdirectory in both the\n\t source directory and the target include directory, and have include\n\t files at the top-level directory to include those headers, for\n\t backwards compatibility.\n\tAdd Bluetooth support\n\tAdd USB capturing support on Linux\n\tAdd support for the binary USB sniffing interface in Linux\n\tAdd support for new FreeBSD BIOCSDIRECTION ioctl\n\tAdd additional filter operations for 802.11 frame types\n\tAdd support for filtering on MTP2 frame types\n\tPropagate some changes from the main branch, so the x.9 branch has\n\t all the DLT_ and LINKTYPE_ values that the main branch does\n\tReserved a DLT_ and SAVEFILE_ value for PPI (Per Packet Info)\n\t encapsulated packets\n\tAdd LINKTYPE_ for IEEE 802.15.4, with address fields padded as done\n\t by Linux drivers\n\tAdd LINKTYPE_ value corresponding to DLT_IEEE802_16_MAC_CPS.\n\tAdd DLT for IEEE 802.16 (WiMAX) MAC Common Part Sublayer\n\tAdd DLT for Bluetooth HCI UART transport layer\n\tWhen building a shared library, build with \"-fPIC\" on Linux to support x86_64\n\tLink with \"$(CC) -shared\" rather than \"ld -shared\" when building a\n\t \".so\" shared library\n\tAdd support for autoconf 2.60\n\tFixes to discard unread packets when changing filters\n\tChanges to handle name changes in the DAG library resulting from\n\t switching to libtool.\n\tAdd support for new DAG ERF types.\n        Add an explicit \"-ldag\" when building the shared library, so the DAG\n\t library dependency is explicit.\n\tMac OSX fixes for dealing with \"wlt\" devices\n\tFixes in add_or_find_if() & pcap_findalldevs() to optimize generating\n\t device lists\n\tFixed a bug in pcap_open_live(). The return value of PacketSetHwFilter\n\t was not checked.\n\nTue.\tSeptember 19, 2006. ken@xelerance.com. Summary for 0.9.5 libpcap release\n\n\tSupport for LAPD frames with vISDN\n\tSupport for ERF on channelized T1/E1 cards via DAG API\n\tFix capitalization that caused issues crossc compiling on Linux\n\tBetter failure detection on PacketGetAdapterNames()\n\tFixes for MPLS packet generation (link layer)\n\tOP_PACKET now matches the beginning of the packet, instead of\n\t beginning+link-layer\n\tAdd DLT/LINKTYPE for carrying FRF.16 Multi-link Frame Relay\n\tFix allocation of buffer for list of link-layer types\n\tAdded a new DLT and LINKTYPE value for ARINC 653 Interpartition Communication Messages\n\tFixed a typo in a DLT value: it should start with DLT_ and not LINKTYPE_\n\tRedefined DLT_CAN20B and LINKTYPE_CAN20B as #190 (as this is the right value for CAN).\n\tAdded definition for DLT_A429 and LINKTYPE_A429 as #184.\n\tAdded a new DLT and LINKTYPE value for CAN v2.0B frames.\n\tAdd support for DLT_JUNIPER_VP.\n\tDon't double-count received packets on Linux systems that\n\t support the PACKET_STATISTICS getsockopt() argument on\n\t PF_PACKET sockets.\n\tAdd support for DLT_IEEE802_11 and DLT_IEEE802_11_RADIO link\n\t layers in Windows\n\tAdd support to build libpcap.lib and wpcap.dll under Cygnus and\n\t MingW32.\n\nMon.\tSeptember 5, 2005.  ken@xelerance.com. Summary for 0.9.4 libpcap release\n\n\tSupport for radiotap on Linux (Mike Kershaw)\n\tFixes for HP-UX\n\tSupport for additional Juniper link-layer types\n\tFixes for filters on MPLS-encapsulated packets\n\t\"vlan\" filter fixed\n\t\"pppoed\" and \"pppoes\" filters added; the latter modifies later\n\tparts of the filter expression to look at the PPP headers and\n\theaders in the PPP payload\n\nTue.\tJuly 5, 2005.  ken@xelerance.com. Summary for 0.9.3 libpcap release\n\n\tFixes for compiling on nearly every platform,\n\t\tincluding improved 64bit support\n\tMSDOS Support\n\tAdd support for sending packets\n\tOpenBSD pf format support\n\tIrDA capture (Linux only)\n\nTue.   March 30, 2004. mcr@sandelman.ottawa.on.ca. Summary for 3.8.3 release\n\n\tFixed minor problem in gencode.c that would appear on 64-bit\n\tplatforms.\n\tVersion number is now sane.\n\nMon.   March 29, 2004. mcr@sandelman.ottawa.on.ca. Summary for 3.8.2 release\n\n\tupdates for autoconf 2.5\n\tfixes for ppp interfaces for freebsd 4.1\n\tpcap gencode can generate code for 802.11, IEEE1394, and pflog.\n\nWed.   November 12, 2003. mcr@sandelman.ottawa.on.ca. Summary for 0.8 release\n\n\tadded pcap_findalldevs()\n\tWin32 patches from NetGroup, Politecnico di Torino (Italy)\n\tOpenBSD pf, DLT_PFLOG added\n\tMany changes to ATM support.\n\tlookup pcap_lookupnet()\n\tAdded DLT_ARCNET_LINUX, DLT_ENC, DLT_IEEE802_11_RADIO, DLT_SUNATM,\n\t\tDLT_IP_OVER_FC, DLT_FRELAY, others.\n\tSigh.  More AIX wonderfulness.\n\tDocument updates.\n\tChanges to API: pcap_next_ex(), pcap_breakloop(), pcap_dump_flush(),\n\t\t\tpcap_list_datalinks(), pcap_set_datalink(),\n\t\t\tpcap_lib_version(), pcap_datalink_val_to_name(),\n\t\t\tpcap_datalink_name_to_val(), new error returns.\n\nTuesday, February 25, 2003. fenner@research.att.com.  0.7.2 release\n\n\tSupport link types that use 802.2 always, never, and sometimes.\n\tDon't decrease the size of the BPF buffer from the default.\n\tSupport frame relay.\n\tHandle 32-bit timestamps in DLPI, and pass the right buffer size.\n\tHandle Linux systems with modern kernel but without\n\t SOL_PACKET in the userland headers.\n\tLinux support for ARPHRD_RAWHDLC.\n\tHandle 32-bit timestamps in snoop.\n\tSupport eg (Octane/O2xxx/O3xxx Gigabit) devices.\n\tAdd new reserved DLT types.\n\nMonday October 23, 2001. mcr@sandelman.ottawa.on.ca. Summary for 0.7 release\n\n\tAdded pcap_findalldevs() call to get list of interfaces in a MI way.\n\n\tpcap_stats() has been documented as to what its counters mean on\n\teach platform.\n\nTuesday January 9, 2001. guy@alum.mit.edu. Summary for 0.6 release\n\n\tNew Linux libpcap implementation, which, in 2.2 and later\n\tkernels, uses PF_PACKET sockets and supports kernel packet\n\tfiltering (if compiled into the kernel), and supports the \"any\"\n\tdevice for capturing on all interfaces.  Cleans up promiscuous\n\tmode better on pre-2.2 kernels, and has various other fixes\n\t(handles 2.4 ARPHRD_IEEE802_TR, handles ISDN devices better,\n\tdoesn't show duplicate packets on loopback interface, etc.).\n\n\tFixed HP-UX libpcap implementation to correctly get the PPA for\n\tan interface, to allow interfaces to be opened by interface name.\n\n\tlibpcap savefiles have system-independent link-layer type values\n\tin the header, rather than sometimes platform-dependent DLT_\n\tvalues, to make it easier to exchange capture files between\n\tdifferent OSes.\n\n\tNon-standard capture files produced by some Linux tcpdumps, e.g.\n\tthe one from Red Hat Linux 6.2 and later, can now be read.\n\n\tUpdated autoconf stock files.\n\n\tFilter expressions can filter on VLAN IDs and various OSI\n\tprotocols, and work on Token Ring (with non-source-routed\n\tpackets).\n\n\t\"pcap_open_dead()\" added to allow compiling filter expressions\n\tto pcap code without opening a capture device or capture file.\n\n\tHeader files fixed to allow use in C++ programs.\n\n\tRemoved dependency on native headers for packet layout.\n\tRemoved Linux specific headers that were shipped.\n\n\tSecurity fixes: Strcpy replaced with strlcpy, sprintf replaced\n\twith snprintf.\n\n\tFixed bug that could cause subsequent \"pcap_compile()\"s to fail\n\terroneously after one compile failed.\n\n\tAssorted other bug fixes.\n\n\tREADME.aix and README.linux files added to describe\n\tplatform-specific issues.\n\n\t\"getifaddrs()\" rather than SIOCGIFCONF used, if available.\n\nv0.5 Sat Jun 10 11:09:15 PDT 2000\n\nitojun@iijlab.net\n- Brought in KAME IPv6/IPsec bpf compiler.\n- Fixes for NetBSD.\n- Support added for OpenBSD DLT_LOOP and BSD/OS DLT_C_HDLC (Cisco HDLC),\n  and changes to work around different BSDs having different DLT_ types\n  with the same numeric value.\n\nAssar Westerlund  <assar@sics.se>\n- Building outside the source code tree fixed.\n- Changed to write out time stamps with 32-bit seconds and microseconds\n  fields, regardless of whether those fields are 32 bits or 64 bits in\n  the OS's native \"struct timeval\".\n- Changed \"pcap_lookupdev()\" to dynamically grow the buffer into which\n  the list of interfaces is read as necessary in order to hold the\n  entire list.\n\nGreg Troxel <gdt@ir.bbn.com>\n- Added a new \"pcap_compile_nopcap()\", which lets you compile a filter\n  expression into a BPF program without having an open live capture or\n  capture file.\n\nv0.4 Sat Jul 25 12:40:09 PDT 1998\n\n- Fix endian problem with DLT_NULL devices. From FreeBSD via Bill\n  Fenner (fenner@parc.xerox.com)\n\n- Fix alignment problem with FDDI under DLPI. This was causing core\n  dumps under Solaris.\n\n- Added configure options to disable flex and bison. Resulted from a\n  bug report by barnett@grymoire.crd.ge.com (Bruce Barnett). Also added\n  options to disable gcc and to force a particular packet capture type.\n\n- Added support for Fore ATM interfaces (qaa and fa) under IRIX. Thanks\n  to John Hawkinson (jhawk@mit.edu)\n\n- Change Linux PPP and SLIP to use DLT_RAW since the kernel does not\n  supply any \"link layer\" data.\n\n- Change Linux to use SIOCGIFHWADDR ioctl to determine link layer type.\n  Thanks to Thomas Sailer (sailer@ife.ee.ethz.ch)\n\n- Change IRIX PPP to use DLT_RAW since the kernel does not supply any\n  \"link layer\" data.\n\n- Modified to support the new BSD/OS 2.1 PPP and SLIP link layer header\n  formats.\n\n- Added some new SGI snoop interface types. Thanks to Steve Alexander\n  (sca@refugee.engr.sgi.com)\n\n- Fixes for HP-UX 10.20 (which is similar to HP-UX 9). Thanks to\n  Richard Allen (ra@hp.is) and Steinar Haug (sthaug@nethelp.no)\n\n- Fddi supports broadcast as reported by Jeff Macdonald\n  (jeff@iacnet.com). Also correct ieee802 and arcnet.\n\n- Determine Linux pcap buffer size at run time or else it might not be\n  big enough for some interface types (e.g. FDDI). Thanks to Jes\n  Sorensen (Jes.Sorensen@cern.ch)\n\n- Fix some linux alignment problems.\n\n- Document promisc argument to pcap_open_live(). Reported by Ian Marsh\n  (ianm@sics.se)\n\n- Support Metricom radio packets under Linux. Thanks to Kevin Lai\n  (laik@gunpowder.stanford.edu)\n\n- Bind to interface name under Linux to avoid packets from multiple\n  interfaces on multi-homed hosts. Thanks to Kevin Lai\n  (laik@gunpowder.stanford.edu)\n\n- Change L_SET to SEEK_SET for HP-UX. Thanks to Roland Roberts\n  (rroberts@muller.com)\n\n- Fixed an uninitialized memory reference found by Kent Vander Velden\n  (graphix@iastate.edu)\n\n- Fixed lex pattern for IDs to allow leading digits. As reported by\n  Theo de Raadt (deraadt@cvs.openbsd.org)\n\n- Fixed Linux include file problems when using GNU libc.\n\n- Ifdef ARPHRD_FDDI since not all versions of the Linux kernel have it.\n  Reported reported by Eric Jacksch (jacksch@tenebris.ca)\n\n- Fixed bug in pcap_dispatch() that kept it from returning on packet\n  timeouts.\n\n- Changed ISLOOPBACK() macro when IFF_LOOPBACK isn't available to check\n  for \"lo\" followed by an eos or digit (newer versions of Linux\n  apparently call the loopback \"lo\" instead of \"lo0\").\n\n- Fixed Linux networking include files to use ints instead of longs to\n  avoid problems with 64 bit longs on the alpha. Thanks to Cristian\n  Gafton (gafton@redhat.com)\n\nv0.3 Sat Nov 30 20:56:27 PST 1996\n\n- Added Linux support.\n\n- Fixed savefile bugs.\n\n- Solaris x86 fix from Tim Rylance (t.rylance@elsevier.nl)\n\n- Add support for bpf kernel port filters.\n\n- Remove duplicate atalk protocol table entry. Thanks to Christian\n  Hopps (chopps@water.emich.edu)\n\n- Fixed pcap_lookupdev() to ignore nonexistent devices. This was\n  reported to happen under BSD/OS by David Vincenzetti\n  (vince@cryptonet.it)\n\n- Avoid solaris compiler warnings. Thanks to Bruce Barnett\n  (barnett@grymoire.crd.ge.com)\n\nv0.2.1 Sun Jul 14 03:02:26 PDT 1996\n\n- Fixes for HP-UX 10. Thanks in part to Thomas Wolfram\n  (wolf@prz.tu-berlin.de) and Rick Jones (raj@hpisrdq.cup.hp.com)\n\n- Added support for SINIX. Thanks to Andrej Borsenkow\n  (borsenkow.msk@sni.de)\n\n- Fixes for AIX (although this system is not yet supported). Thanks to\n  John Hawkinson (jhawk@mit.edu)\n\n- Use autoconf's idea of the top level directory in install targets.\n  Thanks to John Hawkinson.\n\n- Add missing autoconf packet capture result message. Thanks to Bill\n  Fenner (fenner@parc.xerox.com)\n\n- Fixed padding problems in the pf module.\n\n- Fixed some more alignment problems on the alpha.\n\n- Added explicit netmask support. Thanks to Steve Nuchia\n  (steve@research.oknet.com)\n\n- Fixed to handle raw ip addresses such as 0.0.0.1 without \"left\n  justifying\"\n\n- Add \"sca\" keyword (for DEC cluster services) as suggested by Terry\n  Kennedy (terry@spcvxa.spc.edu)\n\n- Add \"atalk\" keyword as suggested by John Hawkinson.\n\n- Add \"igrp\" keyword.\n\n- Fixed HID definition in grammar.y to be a string, not a value.\n\n- Use $CC when checking gcc version. Thanks to Carl Lindberg\n  (carl_lindberg@blacksmith.com)\n\n- Removed obsolete reference to pcap_immediate() from the man page.\n  Michael Stolarchuk (mts@terminator.rs.itd.umich.edu)\n\n- DLT_NULL has a 4 byte family header. Thanks to Jeffrey Honig\n  (jch@bsdi.com)\n\nv0.2 Sun Jun 23 02:28:42 PDT 1996\n\n- Add support for HP-UX. Resulted from code contributed by Tom Murray\n  (tmurray@hpindck.cup.hp.com) and Philippe-Andri Prindeville\n  (philipp@res.enst.fr)\n\n- Update INSTALL with a reminder to install include files. Thanks to\n  Mark Andrews (mandrews@aw.sgi.com)\n\n- Fix bpf compiler alignment bug on the alpha.\n\n- Use autoconf to detect architectures that can't handle misaligned\n  accesses.\n\n- Added loopback support for snoop. Resulted from report Steve\n  Alexander (sca@engr.sgi.com)\n\nv0.1 Fri Apr 28 18:11:03 PDT 1995\n\n- Fixed compiler and optimizer bugs.  The BPF filter engine uses unsigned\n  comparison operators, while the code generator and optimizer assumed\n  signed semantics in several places.  Thanks to Charlie Slater\n  (cslater@imatek.com) for pointing this out.\n\n- Removed FDDI ifdef's, they aren't really needed. Resulted from report\n  by Gary Veum (veum@boa.gsfc.nasa.gov).\n\n- Add pcap-null.c which allows offline use of libpcap on systems that\n  don't support live package capture. This feature resulting from a\n  request from Jan van Oorschot (j.p.m.voorschot@et.tudelft.nl).\n\n- Make bpf_compile() reentrant. Fix thanks to Pascal Hennequin\n  (Pascal.Hennequin@hugo.int-evry.fr).\n\n- Port to GNU autoconf.\n\n- Fix pcap-dlpi.c to work with isdn. Resulted from report by Flemming\n  Johansen (fsj@csd.cri.dk).\n\n- Handle multi-digit interface unit numbers (aka ppa's) under dlpi.\n  Resulted from report by Daniel Ehrlich (ehrlich@cse.psu.edu).\n\n- Fix pcap-dlpi.c to work in non-promiscuous mode. Resulted from report\n  by Jeff Murphy (jcmurphy@acsu.buffalo.edu).\n\n- Add support for \"long jumps\". Thanks to Jeffrey Mogul\n  (mogul@pa.dec.com).\n\n- Fix minor problems when compiling with BDEBUG as noticed by Scott\n  Bertilson (scott@unet.umn.edu).\n\n- Declare sys_errlist \"const char *const\" to avoid problems under\n  FreeBSD. Resulted from report by jher@eden.com.\n\nv0.0.6 Fri Apr 28 04:07:13 PDT 1995\n\n- Add missing variable declaration missing from 0.0.6\n\nv0.0.5 Fri Apr 28 00:22:21 PDT 1995\n\n- Workaround for problems when pcap_read() returns 0 due to the timeout\n  expiring.\n\nv0.0.4 Thu Apr 20 20:41:48 PDT 1995\n\n- Change configuration to not use gcc v2 flags with gcc v1.\n\n- Fixed a bug in pcap_next(); if pcap_dispatch() returns 0, pcap_next()\n  should also return 0. Thanks to Richard Stevens (rstevens@noao.edu).\n\n- Fixed configure to test for snoop before dlpi to avoid problems under\n  IRIX 5. Thanks to J. Eric Townsend (jet@abulafia.genmagic.com).\n\n- Hack around deficiency in Ultrix's make.\n\n- Fix two bugs related to the Solaris pre-5.3.2 bufmod bug; handle\n  savefiles that have more than snapshot bytes of data in them (so we\n  can read old savefiles) and avoid writing such files.\n\n- Added checkioctl which is used with gcc to check that the\n  \"fixincludes\" script has been run.\n\nv0.0.3 Tue Oct 18 18:13:46 PDT 1994\n\n- Fixed configure to test for snoop before dlpi to avoid problems under\n  IRIX 5. Thanks to J. Eric Townsend (jet@abulafia.genmagic.com).\n\nv0.0.2 Wed Oct 12 20:56:37 PDT 1994\n\n- Implement timeout in the dlpi pcap_open_live(). Thanks to Richard\n  Stevens.\n\n- Determine pcap link type from dlpi media type. Resulted from report\n  by Mahesh Jethanandani (mahesh@npix.com).\n\nv0.0.1 Fri Jun 24 14:50:57 PDT 1994\n\n- Fixed bug in nit_setflags() in pcap-snit.c. The streams ioctl timeout\n  wasn't being initialized sometimes resulting in an \"NIOCSFLAGS:\n  Invalid argument\" error under OSF/1. Reported by Matt Day\n  (mday@artisoft.com) and Danny Mitzel (dmitzel@whitney.hitc.com).\n\n- Turn on FDDI support by default.\n\nv0.0 Mon Jun 20 19:20:16 PDT 1994\n\n- Initial release.\n\n- Fixed bug with greater/less keywords, reported by Mark Andrews\n  (mandrews@alias.com).\n\n- Fix bug where '|' was defined as BPF_AND instead of BPF_OR, reported\n  by Elan Amir (elan@leeb.cs.berkeley.edu).\n\n- Machines with little-endian byte ordering are supported thanks to\n  Jeff Mogul.\n\n- Add hack for version 2.3 savefiles which don't have caplen and len\n  swapped thanks to Vern Paxson.\n\n- Added \"&&\" and \"||\" aliases for \"and\" and \"or\" thanks to Vern Paxson.\n\n- Added length, inbound and outbound keywords.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 127.4775390625,
          "content": "if(WIN32)\n    #\n    # We need 3.12 or later, so that we can set policy CMP0074; see\n    # below.\n    #\n    cmake_minimum_required(VERSION 3.12)\nelse(WIN32)\n    #\n    # For now:\n    #\n    #  if this is a version of CMake less than 3.5, require only\n    #  2.8.12, just in case somebody is configuring with CMake\n    #  on a \"long-term support\" version # of some OS and that\n    #  version supplies an older version of CMake;\n    #\n    #  otherwise, if it's a version less than 3.10, require only\n    #  3.5, just in case somebody is configuring with CMake\n    #  on a \"long-term support\" version # of some OS and that\n    #  version supplies an older version of CMake;\n    #\n    #  otherwise, require 3.10, so we don't get messages warning\n    #  that support for versions of CMake lower than 3.10 is\n    #  deprecated.\n    #\n    if(CMAKE_VERSION VERSION_LESS \"3.5\")\n        cmake_minimum_required(VERSION 2.8.12)\n    elseif(CMAKE_VERSION VERSION_LESS \"3.10\")\n        cmake_minimum_required(VERSION 3.5)\n    else()\n        cmake_minimum_required(VERSION 3.10)\n    endif()\nendif(WIN32)\n\n#\n# Apple doesn't build with an install_name starting with @rpath, and\n# neither do we with autotools; don't do so with CMake, either, and\n# suppress warnings about that.\n#\n# Setting CMAKE_MACOSX_RPATH to FALSE uses the old behavior,\n# but removes the POLICY CMP0042 OLD deprecated warning.\n# See https://cmake.org/cmake/help/latest/policy/CMP0042.html\n#\nif (NOT DEFINED CMAKE_MACOSX_RPATH)\n    set(CMAKE_MACOSX_RPATH FALSE)\nendif()\nif(POLICY CMP0042)\n    cmake_policy(SET CMP0042 NEW)\nendif()\n\n#\n# Squelch noise about quoted strings in if() statements.\n# WE KNOW WHAT WE'RE DOING, WE'RE DOING EVERYTHING THE WAY THAT NEWER\n# VERSIONS OF CMAKE EXPECT BY DEFAULT, DON'T WASTE OUR TIME WITH NOISE.\n#\nif(POLICY CMP0054)\n    cmake_policy(SET CMP0054 NEW)\nendif()\n\n#\n# We want find_file() and find_library() to honor {packagename}_ROOT,\n# as that appears to be the only way, with the Visual Studio 2019 IDE\n# and its CMake support, to tell CMake where to look for the Npcap\n# or WinPcap SDK.\n#\nif(POLICY CMP0074)\n    cmake_policy(SET CMP0074 NEW)\nendif()\n\n#\n# We want check_include_file() to honor CMAKE_REQUIRED_LIBRARIES; see\n# the big comment before the check_include_file() test for\n# infiniband/verbs.h for the reason.\n#\nif(POLICY CMP0075)\n    cmake_policy(SET CMP0075 NEW)\nendif()\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules)\n\n#\n# We explicitly indicate what languages are used in libpcap to avoid\n# checking for a C++ compiler.\n#\n# One reason to avoid that check is that there's no need to waste\n# configuration time performing it.\n#\n# Another reason is that:\n#\n# CMake will try to determine the sizes of some data types, including\n# void *, early in the process of configuration; apparently, it's done\n# as part of processing the project() command.\n#\n# At least as of CMake 2.8.6, it does so by checking the size of\n# \"void *\" in C, setting CMAKE_C_SIZEOF_DATA_PTR based on that,\n# setting CMAKE_SIZEOF_VOID_P to that, and then checking the size\n# of \"void *\" in C++, setting CMAKE_CXX_SIZEOF_DATA_PTR based on\n# that, and then setting CMAKE_SIZEOF_VOID_P to *that*.\n#\n# The compile tests include whatever C flags may have been provided\n# to CMake in the CFLAGS and CXXFLAGS environment variables.\n#\n# If you set an architecture flag such as -m32 or -m64 in CFLAGS\n# but *not* in CXXFLAGS, the size for C++ will win, and hilarity\n# will ensue.\n#\n# Or if, at least on Solaris, you have a newer version of GCC\n# installed, but *not* a newer version of G++, and you have Oracle\n# Studio installed, it will find GCC, which will default to building\n# 64-bit, and Oracle Studio's C++ compiler, which will default to\n# building 32-bit, the size for C++ will win, and, again, hilarity\n# will ensue.\n#\nproject(pcap C)\n\n#\n# Export the size of void * as SIZEOF_VOID_P so that it can be\n# tested with #if.\n#\nset(SIZEOF_VOID_P \"${CMAKE_SIZEOF_VOID_P}\")\n\n#\n# Setting CMAKE_MACOSX_RPATH to FALSE causes the installed\n# libpcap.A.dylib to have just libpcap.A.dylib as the install\n# name;  Apple built libpcap with an install_name of /usr/lib/libpcap.A.dylib\n# (back when they still shipped individual system dylibs rather than\n# shipping a pre-built shared library cache, at least), and we do the\n# same with autotools; do the same with CMake.\n#\nif (NOT DEFINED CMAKE_INSTALL_NAME_DIR)\n    set(CMAKE_INSTALL_NAME_DIR ${CMAKE_INSTALL_PREFIX}/lib)\nendif()\n\n#\n# For getting raw lists of --libs and --libs --static information from a\n# pkg-config module.\n#\n# In CMake up to 2.8.12, pkg_check_modules() sets:\n#\n#    <XPREFIX>_LIBRARIES, which is a list of library names to which, on\n#      a UN*X, -l can be prefixed - i.e., names, without extensions,\n#      rather than full paths to the file.\n#    <XPREFIX>_LIBRARY_DIRS, which is a list of paths to directories\n#      containing the libraries, to which, on a UN*X, -L can be\n#      prefixed.\n#    <XPREFIX>_LDFLAGS, which is a list of *all* required linker flags\n#    <XPREFIX>_LDFLAGS_OTHER, which is a list of all linker flags other\n#      than -l and -L flags\n#\n# In 3.0 (at least as of 3.0.2), it also sets:\n#\n#    <XPREFIX>_LINK_LIBRARIES, which is a list of full paths to the\n#      library files.\n#\n# but if <XPREFIX> is <PREFIX>_STATIC, <XPREFIX>_LINK_LIBRARIES is\n# currently not set by CMake.\n#\n# Unfortunately, pkg_check_modules() sets the\n# PKG_CONFIG_ALLOW_SYSTEM_LIBS environment variable when running\n# pkg-config, so the output of --libs, etc. may include a -L for the\n# system library, which we do *NOT* want to put in our libpcap.pc and\n# pcap-config files.\n#\n# So we just run pkg-config ourselves, so that we get its output\n# directly without any processing by CMake.\n#\nmacro(pkg_get_link_info _prefix _package)\n  if (PKG_CONFIG_EXECUTABLE)\n    #\n    # Get the --libs information.\n    #\n    # We force PKG_CONFIG_ALLOW_SYSTEM_LIBS to be undefined, as\n    # at least some versions of CMake appear to define it in\n    # pkg_check_modules() before running pkg-config and *not* undefine\n    # it after running it.\n    #\n    unset(ENV{PKG_CONFIG_ALLOW_SYSTEM_LIBS})\n    set(_pkg_config_result \"\")\n    execute_process(\n      COMMAND ${PKG_CONFIG_EXECUTABLE} \"--libs\" ${_package}\n      OUTPUT_VARIABLE _pkg_config_result\n      RESULT_VARIABLE _pkg_config_failed\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n    if (_pkg_config_failed)\n      #\n      # pkg-config failed; assume that means that there is no such\n      # package for it to find.  XXX - what do we do here?\n      #\n      set(${_prefix}_FOUND_WITH_PKG_CONFIG FALSE)\n    else()\n      #\n      # pkg-config succeeded; replace CR and LF with spaces.\n      #\n      string(REGEX REPLACE \"[\\r\\n]\" \" \" ${_prefix}_LIBS \"${_pkg_config_result}\")\n\n      #\n      # Now get the --libs --static information.\n      #\n      set(_pkg_config_result \"\")\n      execute_process(\n        COMMAND ${PKG_CONFIG_EXECUTABLE} \"--libs\" \"--static\" ${_package}\n        OUTPUT_VARIABLE _pkg_config_result\n        RESULT_VARIABLE _pkg_config_failed\n        OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n      if (_pkg_config_failed)\n        #\n        # pkg-config failed; assume that means that there is no such\n        # package for it to find.  XXX - what do we do here?\n        #\n        set(${_prefix}_FOUND_WITH_PKG_CONFIG FALSE)\n      else()\n        #\n        # pkg-config succeeded; replace CR and LF with spaces.\n        #\n        string(REGEX REPLACE \"[\\r\\n]\" \" \" ${_prefix}_LIBS_STATIC \"${_pkg_config_result}\")\n\n        #\n        # List this package in its PACKAGE_NAME variable.\n        #\n        set(${_prefix}_PACKAGE_NAME \"${_package}\")\n\n        #\n        # It worked.\n        #\n        set(${_prefix}_FOUND_WITH_PKG_CONFIG TRUE)\n      endif()\n    endif()\n  endif()\nendmacro()\n\nmacro(get_link_info_from_library_path  _library_prefix _library_name)\n  if(NOT ${_library_prefix}_LIBRARY STREQUAL \"${_library_prefix}_LIBRARY-NOTFOUND\")\n    get_filename_component(_lib_directory \"${${_library_prefix}_LIBRARY}}\" DIRECTORY)\n\n    #\n    # The closest thing to a list of \"system library directories\" in\n    # which the linker will, by default, search for libraries appears to\n    # be CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES, so that's what we use\n    # when we're trying to construct a -L argument, for insertion into\n    # pcap-config and libpcap.pc, for a library upon which we depend.\n    #\n    # In some versions of CMake it appears to have duplicate entries,\n    # but that shouldn't affect a search for a directory in that list.\n    #\n    list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES \"${_lib_directory}\" _lib_index)\n    if(_lib_index EQUAL -1)\n      #\n      # No, so add a -L flag to get the linker to search in that\n      # directory.\n      #\n      set(${_library_prefix}_LIBS \"-L${_lib_directory}\")\n      set(${_library_prefix}_LIBS_STATIC \"-L${_lib_directory}\")\n      set(${_libraryprefix}_LIBS_PRIVATE \"-L${_lib_directory}\")\n    endif()\n    set(${_library_prefix}_LIBS \"${${_library_prefix}_LIBS} -l${_library_name}\")\n    set(${_library_prefix}_LIBS_STATIC \"${${_library_prefix}_LIBS} -l${_library_name}\")\n    set(${_library_prefix}_LIBS_PRIVATE \"${${_library_prefix}_LIBS} -l${_library_name}\")\n  endif()\nendmacro()\n\n#\n# Show the bit width for which we're compiling.\n# This can help debug problems if you're dealing with a compiler that\n# defaults to generating 32-bit code even when running on a 64-bit\n# platform, and where that platform may provide only 64-bit versions of\n# libraries that we might use (looking at *you*, Oracle Studio!).\n#\nif(CMAKE_SIZEOF_VOID_P EQUAL 4)\n  message(STATUS \"Building 32-bit\")\nelseif(CMAKE_SIZEOF_VOID_P EQUAL 8)\n  message(STATUS \"Building 64-bit\")\nendif()\n\n#\n# Solaris pkg-config is annoying.  For at least one package (D-Bus, I'm\n# looking at *you*!), there are separate include files for 32-bit and\n# 64-bit builds (I guess using \"unsigned long long\" as a 64-bit integer\n# type on a 64-bit build is like crossing the beams or something), and\n# there are two separate .pc files, so if we're doing a 32-bit build we\n# should make sure we look in /usr/lib/pkgconfig for .pc files and if\n# we're doing a 64-bit build we should make sure we look in\n# /usr/lib/amd64/pkgconfig for .pc files.\n#\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND CMAKE_SYSTEM_VERSION MATCHES \"5[.][0-9.]*\")\n    #\n    # Note: string(REPLACE) does not appear to support using ENV{...}\n    # as an argument, so we set a variable and then use set() to set\n    # the environment variable.\n    #\n    if(CMAKE_SIZEOF_VOID_P EQUAL 8)\n        #\n        # 64-bit build.  If /usr/lib/pkgconfig appears in the path,\n        # prepend /usr/lib/amd64/pkgconfig to it; otherwise,\n        # put /usr/lib/amd64 at the end.\n        #\n        if((NOT DEFINED ENV{PKG_CONFIG_PATH}) OR \"$ENV{PKG_CONFIG_PATH}\" EQUAL \"\")\n            #\n            # Not set, or empty.  Set it to /usr/lib/amd64/pkgconfig.\n            #\n            set(fixed_path \"/usr/lib/amd64/pkgconfig\")\n        elseif(\"$ENV{PKG_CONFIG_PATH}\" MATCHES \"/usr/lib/pkgconfig\")\n            #\n            # It contains /usr/lib/pkgconfig.  Prepend\n            # /usr/lib/amd64/pkgconfig to /usr/lib/pkgconfig.\n            #\n            string(REPLACE \"/usr/lib/pkgconfig\"\n                \"/usr/lib/amd64/pkgconfig:/usr/lib/pkgconfig\"\n                fixed_path \"$ENV{PKG_CONFIG_PATH}\")\n        else()\n            #\n            # Not empty, but doesn't contain /usr/lib/pkgconfig.\n            # Append /usr/lib/amd64/pkgconfig to it.\n            #\n            set(fixed_path \"$ENV{PKG_CONFIG_PATH}:/usr/lib/amd64/pkgconfig\")\n        endif()\n        set(ENV{PKG_CONFIG_PATH} \"${fixed_path}\")\n    elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)\n        #\n        # 32-bit build.  If /usr/amd64/lib/pkgconfig appears in the path,\n        # prepend /usr/lib/pkgconfig to it.\n        #\n        if(\"$ENV{PKG_CONFIG_PATH}\" MATCHES \"/usr/lib/amd64/pkgconfig\")\n            #\n            # It contains /usr/lib/amd64/pkgconfig.  Prepend\n            # /usr/lib/pkgconfig to /usr/lib/amd64/pkgconfig.\n            #\n            string(REPLACE \"/usr/lib/amd64/pkgconfig\"\n                \"/usr/lib/pkgconfig:/usr/lib/amd64/pkgconfig\"\n                fixed_path \"$ENV{PKG_CONFIG_PATH}\")\n            set(ENV{PKG_CONFIG_PATH} \"${fixed_path}\")\n        endif()\n    endif()\nendif()\n\ninclude(CheckCCompilerFlag)\n\n#\n# For checking if a compiler flag works and adding it if it does.\n#\nmacro(check_and_add_compiler_option _option)\n    message(STATUS \"Checking C compiler flag ${_option}\")\n    string(REPLACE \"=\" \"-\" _temp_option_variable ${_option})\n    string(REGEX REPLACE \"^-\" \"\" _option_variable ${_temp_option_variable})\n    check_c_compiler_flag(\"${_option}\" ${_option_variable})\n    if(${${_option_variable}})\n        set(C_ADDITIONAL_FLAGS \"${C_ADDITIONAL_FLAGS} ${_option}\")\n    endif()\nendmacro()\n\n#\n# If we're building with Visual Studio, we require Visual Studio 2015,\n# in order to get sufficient C99 compatibility.  Check for that.\n#\n# If not, try the appropriate flag for the compiler to enable C99\n# features.\n#\nset(C_ADDITIONAL_FLAGS \"\")\nif(MSVC)\n    if(MSVC_VERSION LESS 1900)\n        message(FATAL_ERROR \"Visual Studio 2015 or later is required\")\n    endif()\n\n    #\n    # Treat source files as being in UTF-8 with MSVC if it's not using\n    # the Clang front end.\n    # We assume that UTF-8 source is OK with other compilers and with\n    # MSVC if it's using the Clang front end.\n    #\n    if(NOT ${CMAKE_C_COMPILER} MATCHES \"clang*\")\n        set(C_ADDITIONAL_FLAGS \"${C_ADDITIONAL_FLAGS} /utf-8\")\n    endif(NOT ${CMAKE_C_COMPILER} MATCHES \"clang*\")\nelse(MSVC)\n    #\n    # For checking if a compiler flag works, failing if it doesn't,\n    # and adding it otherwise.\n    #\n    macro(require_and_add_compiler_option _option)\n        message(STATUS \"Checking C compiler flag ${_option}\")\n        string(REPLACE \"=\" \"-\" _temp_option_variable ${_option})\n        string(REGEX REPLACE \"^-\" \"\" _option_variable ${_temp_option_variable})\n        check_c_compiler_flag(\"${_option}\" ${_option_variable})\n        if(${${_option_variable}})\n            set(C_ADDITIONAL_FLAGS \"${C_ADDITIONAL_FLAGS} ${_option}\")\n        else()\n            message(FATAL_ERROR \"C99 support is required, but the compiler doesn't support a compiler flag to enable it\")\n        endif()\n    endmacro()\n\n    #\n    # Try to enable as many C99 features as we can.\n    # At minimum, we want C++/C99-style // comments.\n    #\n    # Newer versions of compilers might default to supporting C99, but\n    # older versions may require a special flag.\n    #\n    # Prior to CMake 3.1, setting CMAKE_C_STANDARD will not have any effect,\n    # so, unless and until we require CMake 3.1 or later, we have to do it\n    # ourselves on pre-3.1 CMake, so we just do it ourselves on all versions\n    # of CMake.\n    #\n    # Note: with CMake 3.1 through 3.5, the only compilers for which CMake\n    # handles CMAKE_C_STANDARD are GCC and Clang.  3.6 adds support only\n    # for Intel C; 3.9 adds support for PGI C, Sun C, and IBM XL C, and\n    # 3.10 adds support for Cray C and IAR C, but no version of CMake has\n    # support for HP C.  Therefore, even if we use CMAKE_C_STANDARD with\n    # compilers for which CMake supports it, we may still have to do it\n    # ourselves on other compilers.\n    #\n    # See the CMake documentation for the CMAKE_<LANG>_COMPILER_ID variables\n    # for a list of compiler IDs.\n    #\n    # XXX - this just tests whether the option works, fails if it doesn't,\n    # and adds it if it does.  We don't test whether it's necessary in order\n    # to get the C99 features that we use, or whether, if it's used, it\n    # enables all the features that we require.\n    #\n    if(CMAKE_C_COMPILER_ID MATCHES \"GNU\" OR\n       CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        require_and_add_compiler_option(\"-std=gnu99\")\n    elseif(CMAKE_C_COMPILER_ID MATCHES \"XL\")\n        #\n        # We want support for extensions picked up for GNU C compatibility,\n        # so we use -qlanglvl=extc99.\n        #\n        require_and_add_compiler_option(\"-qlanglvl=extc99\")\n    elseif(CMAKE_C_COMPILER_ID MATCHES \"HP\")\n        require_and_add_compiler_option(\"-AC99\")\n    elseif(CMAKE_C_COMPILER_ID MATCHES \"Sun\")\n        require_and_add_compiler_option(\"-xc99\")\n    elseif(CMAKE_C_COMPILER_ID MATCHES \"Intel\")\n        require_and_add_compiler_option(\"-c99\")\n    endif()\nendif(MSVC)\n\n#\n# If we're building with MinGW, we need to specify _WIN32_WINNT as\n# 0x0600 (\"NT 6.0\", a/k/a Vista/Windows Server 2008) or higher\n# in order to get the full IPv6 API, including inet_ntop(), and we\n# need to specify it as 0x0601 (\"NT 6.1\", a/k/a Windows 7) or higher\n# in order to get NdisMediumIP.\n#\n# NOTE: pcap does *NOT* work with msvcrt.dll; it must link with\n# a newer version of the C library, i.e. Visual Studio 2015 or\n# later, as it depends on C99 features introduced in VS 2015.\n#\nif(MINGW)\n    add_definitions(-D_WIN32_WINNT=0x0601)\nendif(MINGW)\n\n#\n# Build all runtimes in the top-level binary directory; that way,\n# on Windows, the executables will be in the same directory as\n# the DLLs, so the system will find pcap.dll when any of the\n# executables are run.\n#\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run)\n\n###################################################################\n#   Parameters\n###################################################################\n\nif(WIN32)\n    #\n    # On Windows, allow the library name to be overridden, for the\n    # benefit of projects that combine libpcap with their own\n    # kernel-mode code to support capturing.\n    #\n    set(LIBRARY_NAME pcap CACHE STRING \"Library name\")\nelse()\n    #\n    # On UN*X, it's always been libpcap.\n    #\n    set(LIBRARY_NAME pcap)\nendif()\n\noption(INET6 \"Enable IPv6\" ON)\nif(WIN32)\n    option(USE_STATIC_RT \"Use static Runtime\" ON)\nendif(WIN32)\noption(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\nset(dpdk_ROOT \"\" CACHE PATH \"Path to directory with include and lib subdirectories for DPDK\")\nif(WIN32)\n    set(Packet_ROOT \"\" CACHE PATH \"Path to directory with include and lib subdirectories for packet.dll\")\nendif(WIN32)\n\noption(ENABLE_PROFILING \"Enable code profiling\" OFF)\n\n# To pacify those who hate the protochain instruction\noption(NO_PROTOCHAIN \"Disable protochain instruction\" OFF)\n\n#\n# Start out with the capture mechanism type unspecified; the user\n# can explicitly specify it and, if they don't, we'll pick an\n# appropriate one.\n#\nset(PCAP_TYPE \"\" CACHE STRING \"Packet capture type\")\n\n#\n# Default to having remote capture support on Windows and, for now, to\n# not having it on UN*X.\n#\nif(WIN32)\n    option(ENABLE_REMOTE \"Enable remote capture\" ON)\nelse()\n    option(ENABLE_REMOTE \"Enable remote capture\" OFF)\nendif(WIN32)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n    option(BUILD_WITH_LIBNL \"Build with libnl\" ON)\nendif()\n\n#\n# Additional capture modules.\n#\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n    option(DISABLE_LINUX_USBMON \"Disable Linux usbmon USB sniffing support\" OFF)\nendif()\noption(DISABLE_BLUETOOTH \"Disable Bluetooth sniffing support\" OFF)\noption(DISABLE_NETMAP \"Disable netmap support\" OFF)\noption(DISABLE_DPDK \"Disable DPDK support\" OFF)\n\n#\n# We don't support D-Bus sniffing on macOS; see\n#\n# https://bugs.freedesktop.org/show_bug.cgi?id=74029\n#\nif(APPLE)\n    option(DISABLE_DBUS \"Disable D-Bus sniffing support\" ON)\nelse(APPLE)\n    option(DISABLE_DBUS \"Disable D-Bus sniffing support\" OFF)\nendif(APPLE)\noption(DISABLE_RDMA \"Disable RDMA sniffing support\" OFF)\n\noption(DISABLE_DAG \"Disable Endace DAG card support\" OFF)\noption(ENABLE_DAG_TX \"Enable Endace DAG transmit support\" OFF)\n\noption(DISABLE_SNF \"Disable Myricom SNF support\" OFF)\n\n#\n# Debugging options.\n#\noption(BDEBUG \"Build optimizer debugging code\" OFF)\noption(YYDEBUG \"Build parser debugging code\" OFF)\n\n###################################################################\n#   Versioning\n###################################################################\n\n# Get, parse, format and set pcap's version string from [pcap_root]/VERSION\n# for later use.\n\n# Get MAJOR, MINOR, PATCH & SUFFIX\nfile(STRINGS ${pcap_SOURCE_DIR}/VERSION\n    PACKAGE_VERSION\n    LIMIT_COUNT 1 # Read only the first line\n)\n\n# Get \"just\" MAJOR\nstring(REGEX MATCH \"^([0-9]+)\" PACKAGE_VERSION_MAJOR \"${PACKAGE_VERSION}\")\n\n# Get MAJOR, MINOR & PATCH\nstring(REGEX MATCH \"^([0-9]+.)?([0-9]+.)?([0-9]+)\" PACKAGE_VERSION_NOSUFFIX \"${PACKAGE_VERSION}\")\n\nif(WIN32)\n    # Convert PCAP_VERSION_NOSUFFIX to Windows preferred version format\n    string(REPLACE \".\" \",\" PACKAGE_VERSION_PREDLL ${PACKAGE_VERSION_NOSUFFIX})\n\n    # Append NANO (used for Windows internal versioning) to PCAP_VERSION_PREDLL\n    # 0 means unused.\n    set(PACKAGE_VERSION_DLL ${PACKAGE_VERSION_PREDLL},0)\nendif(WIN32)\n\nset(PACKAGE_NAME \"${LIBRARY_NAME}\")\nset(PACKAGE_STRING \"${LIBRARY_NAME} ${PACKAGE_VERSION}\")\n\n######################################\n# Project settings\n######################################\n\ninclude_directories(\n    ${CMAKE_CURRENT_BINARY_DIR}\n    ${pcap_SOURCE_DIR}\n)\n\ninclude(CheckFunctionExists)\ninclude(CMakePushCheckState)\ninclude(CheckSymbolExists)\n\nif(WIN32)\n\n    if(IS_DIRECTORY ${CMAKE_HOME_DIRECTORY}/../../Common)\n        include_directories(${CMAKE_HOME_DIRECTORY}/../../Common)\n    endif(IS_DIRECTORY ${CMAKE_HOME_DIRECTORY}/../../Common)\n\n    find_package(Packet)\n    if(Packet_FOUND)\n        set(HAVE_PACKET32 TRUE)\n        include_directories(${Packet_INCLUDE_DIRS})\n        #\n        # Check whether we have the NPcap PacketIsLoopbackAdapter()\n        # function.\n        #\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_LIBRARIES ${Packet_LIBRARIES})\n        check_function_exists(PacketIsLoopbackAdapter HAVE_PACKET_IS_LOOPBACK_ADAPTER)\n        check_function_exists(PacketGetTimestampModes HAVE_PACKET_GET_TIMESTAMP_MODES)\n        cmake_pop_check_state()\n    endif(Packet_FOUND)\n\n    message(STATUS \"checking for Npcap's version.h\")\n    check_symbol_exists(WINPCAP_PRODUCT_NAME \"${CMAKE_SOURCE_DIR}/../../version.h\" HAVE_VERSION_H)\n    if(HAVE_VERSION_H)\n        message(STATUS \"HAVE version.h\")\n    else(HAVE_VERSION_H)\n        message(STATUS \"MISSING version.h\")\n    endif(HAVE_VERSION_H)\n\nendif(WIN32)\n\nif(MSVC)\n    add_definitions(-D__STDC__)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS)\nendif(MSVC)\n\nif(USE_STATIC_RT)\n    message(STATUS \"Use STATIC runtime\")\n        if(MSVC)\n            foreach(RT_FLAG\n                CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n                CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO)\n                string(REGEX REPLACE \"/MD\" \"/MT\" ${RT_FLAG} \"${${RT_FLAG}}\")\n            endforeach(RT_FLAG)\n        elseif(MINGW)\n            set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -static-libgcc\")\n        endif()\nelse (USE_STATIC_RT)\n    message(STATUS \"Use DYNAMIC runtime\")\nendif(USE_STATIC_RT)\n\n#\n# CMake's definition of \"cross-compiling\" appears to be \"compiling\n# for an *operating system* other than the one on which the build\n# is being done*.\n#\n# This is an inadequate definition, as people build for the same\n# operating system but a different instruction set, e.g. building\n# on an IA-32 or x86-64 Linux box for an Arm embedded Linux box,\n# or building Arm code on an IA-32 or x86-64 Windows box.\n#\n# So just test whether check_c_source_runs() on a trivial program\n# works; if not, it's probably because the generated code won't\n# run on the platform on which we're running.\n#\ninclude(CheckCSourceRuns)\nif (NOT CMAKE_CROSSCOMPILING)\n    check_c_source_runs(\"\n    int main()\n    {\n        return 0;\n    }\n    \"\n        CHECK_C_SOURCE_RUNS_WORKS\n    )\n    if (NOT CHECK_C_SOURCE_RUNS_WORKS)\n        set(CMAKE_CROSSCOMPILING TRUE)\n    endif()\nendif()\n\n###################################################################\n#   Detect available platform features\n###################################################################\n\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ninclude(CheckStructHasMember)\ninclude(CheckTypeSize)\n\n#\n# Tests are a bit expensive with Visual Studio on Windows, so, on\n# Windows, we skip tests for UN*X-only headers and functions.\n#\n\n#\n# Header files.\n#\ncheck_include_file(unistd.h HAVE_UNISTD_H)\nif(NOT HAVE_UNISTD_H)\n    add_definitions(-DYY_NO_UNISTD_H)\nendif(NOT HAVE_UNISTD_H)\nif(NOT WIN32)\n    check_include_file(sys/ioccom.h HAVE_SYS_IOCCOM_H)\n    check_include_file(sys/sockio.h HAVE_SYS_SOCKIO_H)\n    check_include_file(sys/select.h HAVE_SYS_SELECT_H)\n\n    check_include_file(netpacket/packet.h HAVE_NETPACKET_PACKET_H)\n    check_include_file(netinet/if_ether.h HAVE_NETINET_IF_ETHER_H)\nendif(NOT WIN32)\n\n#\n# Functions.\n#\n# First, check for the __atomic_load_n() and __atomic_store_n()\n# builtins.\n#\n# We can't use check_function_exists(), as it tries to declare\n# the function, and attempting to declare a compiler builtin\n# can produce an error.\n#\n# We don't use check_symbol_exists(), as it expects a header\n# file to be specified to declare the function, but there isn't\n# such a header file.\n#\n# So we use check_c_source_compiles().\n#\ncheck_c_source_compiles(\n\"int\nmain(void)\n{\n\tint i = 17;\n\treturn __atomic_load_n(&i, __ATOMIC_RELAXED);\n}\n\"\n            HAVE___ATOMIC_LOAD_N)\ncheck_c_source_compiles(\n\"int\nmain(void)\n{\n\tint i;\n\t__atomic_store_n(&i, 17, __ATOMIC_RELAXED);\n\treturn 0;\n}\n\"\n            HAVE___ATOMIC_STORE_N)\n\n#\n# Now check for various system functions.\n#\ncheck_function_exists(strerror_r HAVE_STRERROR_R)\nif(HAVE_STRERROR_R)\n    #\n    # We have strerror_r; if we define _GNU_SOURCE, is it a\n    # POSIX-compliant strerror_r() or a GNU strerror_r()?\n    #\n    check_c_source_compiles(\n\"#define _GNU_SOURCE\n#include <string.h>\n\n/* Define it GNU-style; that will cause an error if it's not GNU-style */\nextern char *strerror_r(int, char *, size_t);\n\nint\nmain(void)\n{\n\treturn 0;\n}\n\"\n            HAVE_GNU_STRERROR_R)\n    if(NOT HAVE_GNU_STRERROR_R)\n        set(HAVE_POSIX_STRERROR_R YES)\n    endif(NOT HAVE_GNU_STRERROR_R)\nelse(HAVE_STRERROR_R)\n    #\n    # We don't have strerror_r; do we have _wcserror_s?\n    #\n    check_function_exists(_wcserror_s HAVE__WCSERROR_S)\nendif(HAVE_STRERROR_R)\n\nif (NOT CMAKE_CROSSCOMPILING)\n    #\n    # Require a proof of suitable snprintf(3), same as in Autoconf.\n    #\n    check_c_source_runs(\"\n    #include <stdio.h>\n    #include <string.h>\n    #include <inttypes.h>\n    #include <sys/types.h>\n\n    #if defined(_WIN32) && !defined(_SSIZE_T_DEFINED)\n    /*\n     * On UN*Xes, this is a signed integer type of the same size as size_t.\n     *\n     * It's not defined by Visual Studio; we assume that ptrdiff_t will\n     * be a type that is a signed integer type of the same size as size_t.\n     */\n    typedef ptrdiff_t ssize_t;\n    #endif\n\n    /*\n     * Avoid trying to cast negative values to unsigned types, or doing\n     * shifts of signed types, in order not to have the test program fail\n     * if we're building with undefined-behavior sanitizers enabled.\n     */\n    int main()\n    {\n      char buf[100];\n      unsigned int ui = sizeof(buf);\n      int i = sizeof(buf);\n      int64_t i64 = INT64_C(0x100000000);\n      uint64_t ui64 = UINT64_C(0x100000000);\n\n      snprintf(buf, sizeof(buf), \\\"%zu\\\", (size_t)ui);\n      if (strncmp(buf, \\\"100\\\", sizeof(buf)))\n        return 1;\n\n      snprintf(buf, sizeof(buf), \\\"%zd\\\", (ssize_t)(-i));\n      if (strncmp(buf, \\\"-100\\\", sizeof(buf)))\n        return 2;\n\n      snprintf(buf, sizeof(buf), \\\"%\\\" PRId64, -i64);\n      if (strncmp(buf, \\\"-4294967296\\\", sizeof(buf)))\n        return 3;\n\n      snprintf(buf, sizeof(buf), \\\"0o%\\\" PRIo64, ui64);\n      if (strncmp(buf, \\\"0o40000000000\\\", sizeof(buf)))\n        return 4;\n\n      snprintf(buf, sizeof(buf), \\\"0x%\\\" PRIx64, ui64);\n      if (strncmp(buf, \\\"0x100000000\\\", sizeof(buf)))\n        return 5;\n\n      snprintf(buf, sizeof(buf), \\\"%\\\" PRIu64, ui64);\n      if (strncmp(buf, \\\"4294967296\\\", sizeof(buf)))\n        return 6;\n\n      return 0;\n    }\n\n    \"\n        SUITABLE_SNPRINTF\n    )\n    if(NOT SUITABLE_SNPRINTF)\n        message(FATAL_ERROR\n    \"The snprintf(3) implementation in this libc is not suitable,\n    libpcap would not work correctly even if it managed to compile.\"\n        )\n    endif()\nelse()\n    message(STATUS \"Skipped SUITABLE_SNPRINTF because cross-compiling.\")\nendif()\n\ncheck_function_exists(strlcpy HAVE_STRLCPY)\ncheck_function_exists(strlcat HAVE_STRLCAT)\ncheck_function_exists(asprintf HAVE_ASPRINTF)\ncheck_function_exists(vasprintf HAVE_VASPRINTF)\ncheck_function_exists(strtok_r HAVE_STRTOK_R)\nif(NOT WIN32)\n    check_function_exists(vsyslog HAVE_VSYSLOG)\nendif()\n\n#\n# Look for various networking-related libraries that we may need.\n#\n# We need getaddrinfo() to translate host names in filters to IP\n# addresses. We use getaddrinfo() because we want a portable\n# thread-safe way of getting information for a host name or port;\n# there exist _r versions of gethostbyname() and getservbyname() on\n# some platforms, but not on all platforms.\n#\n# We may also need socket() and other socket functions to support:\n#\n#   Local packet capture with capture mechanisms that use sockets.\n#\n#   Local capture device enumeration if a socket call is needed to\n#   enumerate devices or get device attributes.\n#\n#   Packet capture from services that put captured packets on the\n#   network, such as rpcap servers.\n#\n# We may also need getnameinfo() for packet capture from services\n# that put packets on the network.\n#\nset(PCAP_LINK_LIBRARIES \"\")\nset(LIBS \"\")\nset(LIBS_STATIC \"\")\nset(REQUIRES_PRIVATE \"\")\nset(LIBS_PRIVATE \"\")\ninclude(CheckLibraryExists)\nif(WIN32)\n    #\n    # Windows.\n    #\n    # We need winsock2.h and ws2tcpip.h.\n    #\n    # On Windows, getaddrinfo() is in the ws2_32 library.\n    #\n    cmake_push_check_state()\n    set(CMAKE_REQUIRED_LIBRARIES ws2_32)\n    check_symbol_exists(getaddrinfo \"winsock2.h;ws2tcpip.h\" LIBWS2_32_HAS_GETADDRINFO)\n    cmake_pop_check_state()\n    if(LIBWS2_32_HAS_GETADDRINFO)\n        set(PCAP_LINK_LIBRARIES ws2_32 ${PCAP_LINK_LIBRARIES})\n    else(LIBWS2_32_HAS_GETADDRINFO)\n        message(FATAL_ERROR \"getaddrinfo is required, but wasn't found\")\n    endif(LIBWS2_32_HAS_GETADDRINFO)\nelse(WIN32)\n    #\n    # UN*X.\n    #\n    # Most UN*Xes have getaddrinfo(), and the other routines we may\n    # need, in the default searched libraries (e.g., libc).\n    # Check there first.\n    #\n    # NOTE: if you hand check_library_exists as its last argument a\n    # variable that's been set, it skips the test, so we need different\n    # variables for different libraries.\n    #\n    check_function_exists(getaddrinfo STDLIBS_HAVE_GETADDRINFO)\n    if(NOT STDLIBS_HAVE_GETADDRINFO)\n\t#\n\t# Not found in the standard system libraries.\n\t#\n\t# In some versions of Solaris, we need to link with libsocket\n\t# and libnsl, so check in libsocket and also link with liblnsl\n\t# when doing this test.\n\t#\n\t# Linking with libsocket and libnsl will find all the routines\n\t# we need.\n\t#\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_LIBRARIES nsl)\n        check_library_exists(socket getaddrinfo \"\" LIBSOCKET_HAS_GETADDRINFO)\n        cmake_pop_check_state()\n        if(LIBSOCKET_HAS_GETADDRINFO)\n            #\n            # OK, we found it in libsocket.\n            #\n            set(PCAP_LINK_LIBRARIES socket nsl ${PCAP_LINK_LIBRARIES})\n            set(LIBS \"-lsocket -lnsl ${LIBS}\")\n            set(LIBS_STATIC \"-lsocket -lnsl ${LIBS_STATIC}\")\n            set(LIBS_PRIVATE \"-lsocket -lnsl ${LIBS_PRIVATE}\")\n        else(LIBSOCKET_HAS_GETADDRINFO)\n\t    #\n\t    # Not found in libsocket; test for it in libnetwork, which\n\t    # is where it is in Haiku.\n\t    #\n\t    # Linking with libnetwork will find all the routines we\n\t    # need.\n\t    #\n            check_library_exists(network getaddrinfo \"\" LIBNETWORK_HAS_GETADDRINFO)\n            if(LIBNETWORK_HAS_GETADDRINFO)\n                #\n\t\t# OK, we found it in libnetwork.\n                #\n                set(PCAP_LINK_LIBRARIES network ${PCAP_LINK_LIBRARIES})\n                set(LIBS \"-lnetwork ${LIBS}\")\n                set(LIBS_STATIC \"-lnetwork ${LIBS_STATIC}\")\n                set(LIBS_PRIVATE \"-lnetwork ${LIBS_PRIVATE}\")\n            else(LIBNETWORK_HAS_GETADDRINFO)\n                #\n                # We didn't find it.\n                #\n                message(FATAL_ERROR \"getaddrinfo is required, but wasn't found\")\n            endif(LIBNETWORK_HAS_GETADDRINFO)\n        endif(LIBSOCKET_HAS_GETADDRINFO)\n\n\t#\n\t# We require a version of recvmsg() that conforms to the Single\n\t# UNIX Specification, so that we can check whether a datagram\n\t# received with recvmsg() was truncated when received due to the\n\t# buffer being too small.\n\t#\n\t# On most systems, the version of recvmsg() in the libraries\n\t# found above conforms to the SUS.\n\t#\n\t# On at least some versions of Solaris, it does not conform to\n\t# the SUS, and we need the version in libxnet, which does\n\t# conform.\n\t#\n\t# Check whether libxnet exists and has a version of recvmsg();\n\t# if it does, link with libxnet before we link with libsocket,\n\t# to get that version.\n\t#\n\t# This test also links with libsocket and libnsl.\n\t#\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_LIBRARIES socket nsl)\n        check_library_exists(xnet recvmsg \"\" LIBXNET_HAS_RECVMSG)\n        cmake_pop_check_state()\n        if(LIBXNET_HAS_RECVMSG)\n            #\n\t    # libxnet has recvmsg(); link with it as well.\n            #\n            set(PCAP_LINK_LIBRARIES xnet ${PCAP_LINK_LIBRARIES})\n            set(LIBSC \"-lxnet ${LIBS_LIBS}\")\n            set(LIBS_STATIC \"-lxnet ${LIBS_STATIC}\")\n            set(LIBS_PRIVATE \"-lxnet ${LIBS_PRIVATE}\")\n        endif(LIBXNET_HAS_RECVMSG)\n    endif(NOT STDLIBS_HAVE_GETADDRINFO)\n\n    #\n    # DLPI needs putmsg under HP-UX, so test for -lstr while we're at it.\n    #\n    check_function_exists(putmsg STDLIBS_HAVE_PUTMSG)\n    if(NOT STDLIBS_HAVE_PUTMSG)\n        check_library_exists(str putmsg \"\" LIBSTR_HAS_PUTMSG)\n        if(LIBSTR_HAS_PUTMSG)\n            set(PCAP_LINK_LIBRARIES str ${PCAP_LINK_LIBRARIES})\n            set(LIBS \"-lstr ${LIBS}\")\n            set(LIBS_STATIC \"-lstr ${LIBS_STATIC}\")\n            set(LIBS_PRIVATE \"-lstr ${LIBS_PRIVATE}\")\n        endif(LIBSTR_HAS_PUTMSG)\n    endif(NOT STDLIBS_HAVE_PUTMSG)\n\n    # Haiku has getpass in libbsd\n    check_function_exists(getpass STDLIBS_HAVE_GETPASS)\n    if(NOT STDLIBS_HAVE_GETPASS)\n        check_library_exists(bsd getpass \"\" LIBBSD_HAS_GETPASS)\n        if(LIBBSD_HAS_GETPASS)\n            set(PCAP_LINK_LIBRARIES bsd ${PCAP_LINK_LIBRARIES})\n        endif(LIBBSD_HAS_GETPASS)\n    endif(NOT STDLIBS_HAVE_GETPASS)\nendif(WIN32)\n\n#\n# Check for reentrant versions of getnetbyname_r(), as provided by\n# Linux (glibc), Solaris, and AIX (with three different APIs!).\n# If we don't find one, we just use getnetbyname(), which uses\n# thread-specific data on many platforms, but doesn't use it on\n# NetBSD or OpenBSD, and may not use it on older versions of other\n# platforms.\n#\n# Only do the check if we have a declaration of getnetbyname_r();\n# without it, we can't check which API it has.  (We assume that\n# if there's a declaration, it has a prototype, so that the API\n# can be checked.)\n#\ncmake_push_check_state()\nset(CMAKE_REQUIRED_LIBRARIES ${PCAP_LINK_LIBRARIES})\ncheck_symbol_exists(getnetbyname_r netdb.h NETDB_H_DECLARES_GETNETBYNAME_R)\nif(NETDB_H_DECLARES_GETNETBYNAME_R)\n    check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct netent netent_buf;\n    char buf[1024];\n    struct netent *resultp;\n    int h_errnoval;\n\n    return getnetbyname_r((const char *)0, &netent_buf, buf, sizeof buf, &resultp, &h_errnoval);\n}\n\"\n        HAVE_LINUX_GETNETBYNAME_R)\n    if(NOT HAVE_LINUX_GETNETBYNAME_R)\n        check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct netent netent_buf;\n    char buf[1024];\n\n    return getnetbyname_r((const char *)0, &netent_buf, buf, (int)sizeof buf) != NULL;\n}\n\"\n            HAVE_SOLARIS_GETNETBYNAME_R)\n        if(NOT HAVE_SOLARIS_GETNETBYNAME_R)\n            check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct netent netent_buf;\n    struct netent_data net_data;\n\n    return getnetbyname_r((const char *)0, &netent_buf, &net_data);\n}\n\"\n                HAVE_AIX_GETNETBYNAME_R)\n        endif(NOT HAVE_SOLARIS_GETNETBYNAME_R)\n    endif(NOT HAVE_LINUX_GETNETBYNAME_R)\nendif(NETDB_H_DECLARES_GETNETBYNAME_R)\ncmake_pop_check_state()\n\n#\n# Check for reentrant versions of getprotobyname_r(), as provided by\n# Linux (glibc), Solaris, and AIX (with three different APIs!).\n# If we don't find one, we just use getprotobyname(), which uses\n# thread-specific data on many platforms, but doesn't use it on\n# NetBSD or OpenBSD, and may not use it on older versions of other\n# platforms.\n#\n# Only do the check if we have a declaration of getprotobyname_r();\n# without it, we can't check which API it has.  (We assume that\n# if there's a declaration, it has a prototype, so that the API\n# can be checked.)\n#\ncmake_push_check_state()\nset(CMAKE_REQUIRED_LIBRARIES ${PCAP_LINK_LIBRARIES})\ncheck_symbol_exists(getprotobyname_r netdb.h NETDB_H_DECLARES_GETPROTOBYNAME_R)\nif(NETDB_H_DECLARES_GETPROTOBYNAME_R)\n    check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct protoent protoent_buf;\n    char buf[1024];\n    struct protoent *resultp;\n\n    return getprotobyname_r((const char *)0, &protoent_buf, buf, sizeof buf, &resultp);\n}\n\"\n        HAVE_LINUX_GETPROTOBYNAME_R)\n    if(NOT HAVE_LINUX_GETPROTOBYNAME_R)\n        check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct protoent protoent_buf;\n    char buf[1024];\n\n    return getprotobyname_r((const char *)0, &protoent_buf, buf, (int)sizeof buf) != NULL;\n}\n\"\n            HAVE_SOLARIS_GETPROTOBYNAME_R)\n        if(NOT HAVE_SOLARIS_GETPROTOBYNAME_R)\n            check_c_source_compiles(\n\"#include <netdb.h>\n\nint\nmain(void)\n{\n    struct protoent protoent_buf;\n    struct protoent_data proto_data;\n\n    return getprotobyname_r((const char *)0, &protoent_buf, &proto_data);\n}\n\"\n                HAVE_AIX_GETPROTOBYNAME_R)\n        endif(NOT HAVE_SOLARIS_GETPROTOBYNAME_R)\n    endif(NOT HAVE_LINUX_GETPROTOBYNAME_R)\nendif(NETDB_H_DECLARES_GETPROTOBYNAME_R)\ncmake_pop_check_state()\n\n#\n# Data types.\n#\n# XXX - there's no check_type() macro that's like check_type_size()\n# except that it only checks for the existence of the structure type,\n# so we use check_type_size() and ignore the size.\n#\ncmake_push_check_state()\nif(WIN32)\n    set(CMAKE_EXTRA_INCLUDE_FILES winsock2.h)\nelse(WIN32)\n    set(CMAKE_EXTRA_INCLUDE_FILES unistd.h sys/socket.h)\nendif(WIN32)\ncheck_type_size(\"socklen_t\" SOCKLEN_T)\ncmake_pop_check_state()\n\n#\n# Structure fields.\n#\nif(WIN32)\n    check_struct_has_member(\"struct sockaddr\" sa_len winsock2.h HAVE_STRUCT_SOCKADDR_SA_LEN)\nelse(WIN32)\n    check_struct_has_member(\"struct sockaddr\" sa_len sys/socket.h HAVE_STRUCT_SOCKADDR_SA_LEN)\nendif(WIN32)\n\n#\n# This requires the libraries that we require, as ether_hostton might be\n# in one of those libraries.  That means we have to do this after\n# we check for those libraries.\n#\n# You are in a twisty little maze of UN*Xes, all different.\n# Some might not have ether_hostton().\n# Some might have it and declare it in <net/ethernet.h>.\n# Some might have it and declare it in <netinet/ether.h>\n# Some might have it and declare it in <sys/ethernet.h>.\n# Some might have it and declare it in <arpa/inet.h>.\n# Some might have it and declare it in <netinet/if_ether.h>.\n# Some might have it and not declare it in any header file.\n#\n# Before you is a C compiler.\n#\ncmake_push_check_state()\nset(CMAKE_REQUIRED_LIBRARIES ${PCAP_LINK_LIBRARIES})\ncheck_function_exists(ether_hostton HAVE_ETHER_HOSTTON)\nif(HAVE_ETHER_HOSTTON)\n    #\n    # OK, we have ether_hostton().  Is it declared in <net/ethernet.h>?\n    #\n    # This test fails if we don't have <net/ethernet.h> or if we do\n    # but it doesn't declare ether_hostton().\n    #\n    check_symbol_exists(ether_hostton net/ethernet.h NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n    if(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n        #\n        # Yes - we have it declared.\n        #\n        set(HAVE_DECL_ETHER_HOSTTON TRUE)\n    endif()\n    #\n    # Did that succeed?\n    #\n    if(NOT HAVE_DECL_ETHER_HOSTTON)\n        #\n        # No - how about <netinet/ether.h>, as on Linux?\n        #\n        # This test fails if we don't have <netinet/ether.h>\n        # or if we do but it doesn't declare ether_hostton().\n        #\n        check_symbol_exists(ether_hostton netinet/ether.h NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)\n        if(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)\n            #\n            # Yes - we have it declared.\n            #\n            set(HAVE_DECL_ETHER_HOSTTON TRUE)\n        endif()\n    endif()\n    #\n    # Did that succeed?\n    #\n    if(NOT HAVE_DECL_ETHER_HOSTTON)\n        #\n        # No - how about <sys/ethernet.h>, as on Solaris 10 and later?\n        #\n        # This test fails if we don't have <sys/ethernet.h>\n        # or if we do but it doesn't declare ether_hostton().\n        #\n        check_symbol_exists(ether_hostton sys/ethernet.h SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n        if(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n            #\n            # Yes - we have it declared.\n            #\n            set(HAVE_DECL_ETHER_HOSTTON TRUE)\n        endif()\n    endif()\n    #\n    # Did that succeed?\n    #\n    if(NOT HAVE_DECL_ETHER_HOSTTON)\n        #\n        # No, how about <arpa/inet.h>, as on AIX?\n        #\n        # This test fails if we don't have <arpa/inet.h>\n        # or if we do but it doesn't declare ether_hostton().\n        #\n        check_symbol_exists(ether_hostton arpa/inet.h ARPA_INET_H_DECLARES_ETHER_HOSTTON)\n        if(ARPA_INET_H_DECLARES_ETHER_HOSTTON)\n            #\n            # Yes - we have it declared.\n            #\n            set(HAVE_DECL_ETHER_HOSTTON TRUE)\n        endif()\n    endif()\n    #\n    # Did that succeed?\n    #\n    if(NOT HAVE_DECL_ETHER_HOSTTON)\n        #\n        # No, how about <netinet/if_ether.h>?\n        # On some platforms, it requires <net/if.h> and\n        # <netinet/in.h>, and we always include it with\n        # both of them, so test it with both of them.\n        #\n        # This test fails if we don't have <netinet/if_ether.h>\n        # and the headers we include before it, or if we do but\n        # <netinet/if_ether.h> doesn't declare ether_hostton().\n        #\n        check_symbol_exists(ether_hostton \"sys/types.h;sys/socket.h;net/if.h;netinet/in.h;netinet/if_ether.h\" NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)\n        if(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)\n            #\n            # Yes - we have it declared.\n            #\n            set(HAVE_DECL_ETHER_HOSTTON TRUE)\n        endif()\n    endif()\n    #\n    # After all that, is ether_hostton() declared?\n    #\n    if(NOT HAVE_DECL_ETHER_HOSTTON)\n        #\n        # No, we'll have to declare it ourselves.\n        # Do we have \"struct ether_addr\" if we include <netinet/if_ether.h>?\n        #\n        # XXX - there's no check_type() macro that's like check_type_size()\n        # except that it only checks for the existence of the structure type,\n        # so we use check_type_size() and ignore the size.\n        #\n        cmake_push_check_state()\n        set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h sys/socket.h net/if.h netinet/in.h netinet/if_ether.h)\n        check_type_size(\"struct ether_addr\" STRUCT_ETHER_ADDR)\n        cmake_pop_check_state()\n    endif()\nendif()\ncmake_pop_check_state()\n\n#\n# Large file support on UN*X, a/k/a LFS.\n#\nif(NOT WIN32)\n  include(FindLFS)\n  if(LFS_FOUND)\n    #\n    # Add the required #defines.\n    #\n    add_definitions(${LFS_DEFINITIONS})\n  endif()\n\n  #\n  # Check for fseeko as well.\n  #\n  include(FindFseeko)\n  if(FSEEKO_FOUND)\n    set(HAVE_FSEEKO ON)\n\n    #\n    # Add the required #defines.\n    #\n    add_definitions(${FSEEKO_DEFINITIONS})\n  endif()\nendif()\n\n#\n# Find the size of time_t.\n#\ncmake_push_check_state()\nset(CMAKE_EXTRA_INCLUDE_FILES time.h)\ncheck_type_size(\"time_t\" SIZEOF_TIME_T)\ncmake_pop_check_state()\n\nif(INET6)\n    message(STATUS \"Support IPv6\")\nendif(INET6)\n\n#\n# Pthreads.\n# We might need them, because some libraries we use might use them,\n# but we don't necessarily need them.\n# That's only on UN*X; on Windows, if they use threads, we assume\n# they're native Windows threads.\n#\nif(NOT WIN32)\n  set(CMAKE_THREAD_PREFER_PTHREAD ON)\n  find_package(Threads)\n  if(NOT CMAKE_USE_PTHREADS_INIT)\n    #\n    # If it's not pthreads, we won't use it; we use it for libraries\n    # that require it.\n    #\n    set(CMAKE_THREAD_LIBS_INIT \"\")\n  endif(NOT CMAKE_USE_PTHREADS_INIT)\nendif(NOT WIN32)\n\nif(ENABLE_PROFILING)\n    if(NOT MSVC)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -pg\")\n    endif()\nendif()\n\n#\n# Based on\n#\n#    https://github.com/commonmark/cmark/blob/master/FindAsan.cmake\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2013 Matthew Arsenault\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# Test if the each of the sanitizers in the ENABLE_SANITIZERS list are\n# supported by the compiler, and, if so, adds the appropriate flags to\n# CMAKE_C_FLAGS, and SANITIZER_FLAGS.  If not, it fails.\n#\n# Do this last, in the hope that it will prevent configuration on Linux\n# from somehow deciding it doesn't need -lpthread when building rpcapd\n# (it does require it, but somehow, in some mysterious fashion that no\n# obvious CMake debugging flag reveals, it doesn't realize that if we\n# turn sanitizer stuff on).\n#\n# Note: apparently, some projects have decided that ENABLE_SANITIZERS\n# is a Boolean, with OFF meaning \"no sanitizers\" and ON meaning \"all\n# sanitizers\".  Whoever decided that didn't put it up as a common\n# CMake idiom, as far as I can tell; we only discovered this because\n# JetBrains' CLion \"helpfully\" appears to pass -DENABLE_SANITIZERS=OFF\n# to CMake by default, which causes CMake to fail on libpcap.  Thanks!\n#\n# We thus also allow a setting of OFF to mean \"no sanitizers\" and ON to\n# mean \"all supported sanitizers that we know about and that can all\n# be used together\".\n#\nmacro(test_sanitizer _sanitizer _sanitizer_flag)\n    message(STATUS \"Checking sanitizer ${_sanitizer}\")\n    set(sanitizer_variable \"sanitize_${_sanitizer}\")\n    # Set -Werror to catch \"argument unused during compilation\" warnings\n    set(CMAKE_REQUIRED_FLAGS \"-Werror -fsanitize=${_sanitizer}\")\n    check_c_compiler_flag(\"-fsanitize=${_sanitizer}\" ${sanitizer_variable})\n    if(${${sanitizer_variable}})\n        set(${_sanitizer_flag} \"-fsanitize=${_sanitizer}\")\n    else()\n        #\n        # Try the versions supported prior to Clang 3.2.\n        # If the sanitizer is \"address\", try -fsanitize-address.\n        # If it's \"undefined\", try -fcatch-undefined-behavior.\n        # Otherwise, give up.\n        #\n        set(sanitizer_variable \"OLD_${sanitizer_variable}\")\n        if (\"${_sanitizer}\" STREQUAL \"address\")\n            set(CMAKE_REQUIRED_FLAGS \"-Werror -fsanitize-address\")\n            check_c_compiler_flag(\"-fsanitize-address\" ${sanitizer_variable})\n            if(${${sanitizer_variable}})\n                set(${_sanitizer_flag} \"-fsanitize-address\")\n            endif()\n        elseif(\"${_sanitizer}\" STREQUAL \"undefined\")\n            set(CMAKE_REQUIRED_FLAGS \"-Werror -fcatch-undefined-behavior\")\n            check_c_compiler_flag(\"-fcatch-undefined-behavior\" ${sanitizer_variable})\n            if(${${sanitizer_variable}})\n                set(${_sanitizer_flag} \"-fcatch-undefined-behavior\")\n            endif()\n        endif()\n    endif()\n    unset(CMAKE_REQUIRED_FLAGS)\nendmacro(test_sanitizer)\n\nset(SANITIZER_FLAGS \"\")\nif(\"${ENABLE_SANITIZERS}\")\n    #\n    # This appears to indicate that ENABLE_SANITIZERS was set to a\n    # string value that is \"one of the true constants\", meaning\n    # \"1, ON, YES, TRUE, Y, or a non-zero number\".\n    #\n    # It does not appear to happen for other settings, including\n    # setting it to a list of one or more sanitizers.\n    #\n    # This setting means \"enable all sanitizers that the compiler\n    # supports\".\n    #\n    foreach(sanitizer \"address\" \"undefined\")\n        unset(SANITIZER_FLAG)\n        test_sanitizer(${sanitizer} SANITIZER_FLAG)\n        if(SANITIZER_FLAG)\n            message(STATUS \"${sanitizer} sanitizer supported using ${SANITIZER_FLAG}\")\n            set(SANITIZER_FLAGS \"${SANITIZER_FLAGS} ${SANITIZER_FLAG}\")\n        else()\n            message(STATUS \"${sanitizer} isn't a supported sanitizer\")\n        endif()\n    endforeach()\n    if(\"${SANITIZER_FLAGS}\" STREQUAL \"\")\n        message(FATAL_ERROR \"No supported sanitizers found\")\n    endif()\nelse()\n    #\n    # This appears to indicate that ENABLE_SANITIZERS was either:\n    #\n    #   not set;\n    #   set to a set to a string value that is not \"one of the true\n    #   constants\", meaning \"1, ON, YES, TRUE, Y, or a non-zero number\".\n    #\n    # The latter includes setting it to \"one of the false constants\",\n    # meaning the string \"is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND,\n    # the empty string, or ends in the suffix -NOTFOUND.\"\n    #\n    # It also includes setting it to a list of one or more sanitizers.\n    #\n    # We want to treat \"not set\" and \"set to one of the false constants\"\n    # as meaning \"do not enable any sanitizers\".\n    #\n    # We want to treat \"set to a list of one or more sanitizers\" as\n    # meaning \"enable all the sanitizers in the list\".\n    #\n    # This requires that we distinguish between those two cases.\n    #\n    if(ENABLE_SANITIZERS)\n        #\n        # This appears to indicate that ENABLE_SANITIZERS was set to\n        # a string value that is \"not one of the false constants\".\n        #\n        # We already know it's \"not one of the true constants\", so\n        # we treat it as a list of sanitizers.\n        #\n        foreach(sanitizer IN LISTS ENABLE_SANITIZERS)\n            unset(SANITIZER_FLAG)\n            test_sanitizer(${sanitizer} SANITIZER_FLAG)\n            if(SANITIZER_FLAG)\n                message(STATUS \"${sanitizer} sanitizer supported using ${SANITIZER_FLAG}\")\n                set(SANITIZER_FLAGS \"${SANITIZER_FLAGS} ${SANITIZER_FLAG}\")\n            else()\n                message(FATAL_ERROR \"${sanitizer} isn't a supported sanitizer\")\n            endif()\n        endforeach()\n    else()\n        #\n        # This appears to indicate that ENABLE_SANITIZERS was either:\n        #\n        #   not set;\n        #   set to a value that's \"one of the false constants\";\n        #\n        # so we don't enable any sanitizers.\n        #\n        message(STATUS \"Not enabling sanitizers\")\n    endif()\nendif()\n\nif(NOT \"${SANITIZER_FLAGS}\" STREQUAL \"\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -O1 -g ${SANITIZER_FLAGS} -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\nendif()\n\nif(ENABLE_REMOTE)\n  #\n  # OpenSSL/libressl.\n  #\n  find_package(OpenSSL)\n  if(OPENSSL_FOUND)\n    #\n    # We have OpenSSL.\n    #\n    include_directories(SYSTEM ${OPENSSL_INCLUDE_DIR})\n    set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${OPENSSL_LIBRARIES})\n\n    #\n    # The find_package() module CMake provides for OpenSSL uses does not\n    # give us a defined indication of whether it found OpenSSL with\n    # pkg-config or not.  We need to know that as, if it was found with\n    # pkg-config, we should set the Requires.private value in libpcap.pc\n    # to include its package name, openssl, otherwise we should add the\n    # names for the static libraries to Libs.private.\n    #\n    # On UN*X, FindOpenSSL happens to use pkg-config to find OpenSSL, but\n    # it doesn't appear to be documented as doing so; therefore, we don't\n    # assume that, if we got here, we have pkg-config.\n    #\n    # So we use pkg_get_link_info() to run pkg-config ourselves, both\n    # because FindOpenSSL doesn't set the OPENSSL_LDFLAGS or\n    # OPENSSL_STATIC_LDFLAGS variables and because, for reasons explained\n    # in the comment before the pkg_get_link_info() macro, even if it did,\n    # it wouldn't be what we want anyway.\n    #\n    if (PKG_CONFIG_EXECUTABLE)\n      pkg_get_link_info(OPENSSL openssl)\n      if (OPENSSL_FOUND_WITH_PKG_CONFIG)\n        #\n        # pkg-config failed; assume that means that there is no openssl\n        # package for it to find.  Just add OPENSSL_LIBRARIES to\n        # LIBS_PRIVATE AND LIBS_STATIC, as that's the\n        # best we can do. XXX - need list of -l and -L flags to add....\n        #\n        set(LIBS \"${LIBS} ${OPENSSL_LIBS}\")\n        set(LIBS_STATIC \"${LIBS_STATIC} ${OPENSSL_LIBS_STATIC}\")\n        set(REQUIRES_PRIVATE \"${REQUIRES_PRIVATE} ${OPENSSL_PACKAGE_NAME}\")\n      endif()\n    else()\n      # Get it from OPENSSL_LIBRARIES\n      foreach(_lib IN LISTS OPENSSL_LIBRARIES)\n        #\n        # Get the directory in which the library resides.\n        #\n        get_filename_component(_lib_directory \"${_lib}\" DIRECTORY)\n\n        #\n        # Is the library directory in CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES?\n        # (See comment above on why we use that.)\n        #\n        list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES \"${_lib_directory}\" _lib_index)\n        if(_lib_index EQUAL -1)\n          #\n          # No, so add a -L flag to get the linker to search in that\n          # directory.\n          #\n          set(LIBS \"${LIBS} -L${_lib_directory}\")\n          set(LIBS_STATIC \"${LIBS_STATIC} -L${_lib_directory}\")\n          set(LIBS_PRIVATE \"${LIBS_PRIVATE} -L${_lib_directory}\")\n        endif()\n\n        #\n        # Get the file name of the library, without the extension.\n        #\n        get_filename_component(_lib_filename \"${_lib}\" NAME_WE)\n\n        #\n        # Strip off the \"lib\" prefix to get the library name, and\n        # add a -l flag based on that.\n        #\n        string(REGEX REPLACE \"^lib\" \"\" _library_name \"${_lib_filename}\")\n        set(LIBS \"${LIBS} -l${_library_name}\")\n        set(LIBS_STATIC \"${LIBS_STATIC} -l${_library_name}\")\n        set(LIBS_PRIVATE \"${LIBS_PRIVATE} -l${_library_name}\")\n      endforeach()\n    endif()\n    set(HAVE_OPENSSL YES)\n  endif(OPENSSL_FOUND)\nendif(ENABLE_REMOTE)\n\n#\n# On macOS, build libpcap for the appropriate architectures, if\n# CMAKE_OSX_ARCHITECTURES isn't set (if it is, let that control\n# the architectures for which to build it).\n#\nif(APPLE AND \"${CMAKE_OSX_ARCHITECTURES}\" STREQUAL \"\")\n    #\n    # Get the major version of Darwin.\n    #\n    string(REGEX MATCH \"^([0-9]+)\" SYSTEM_VERSION_MAJOR \"${CMAKE_SYSTEM_VERSION}\")\n\n    if(SYSTEM_VERSION_MAJOR LESS 8)\n        #\n        # Pre-Tiger.\n        #\n        # Build libraries and executables only for 32-bit PowerPC, as\n        # that's all that is supported.\n        #\n        set(OSX_LIBRARY_ARCHITECTURES \"ppc\")\n        set(OSX_EXECUTABLE_ARCHITECTURES \"ppc\")\n    elseif(SYSTEM_VERSION_MAJOR EQUAL 8)\n        #\n        # Tiger.  Is this prior to, or with, Intel support?\n        #\n        # Get the minor version of Darwin.\n        #\n        string(REPLACE \"${SYSTEM_VERSION_MAJOR}.\" \"\" SYSTEM_MINOR_AND_PATCH_VERSION ${CMAKE_SYSTEM_VERSION})\n        string(REGEX MATCH \"^([0-9]+)\" SYSTEM_VERSION_MINOR \"${SYSTEM_MINOR_AND_PATCH_VERSION}\")\n        if(SYSTEM_VERSION_MINOR LESS 4)\n            #\n            # Prior to Intel support.\n            #\n            # Build libraries and executables for 32-bit PowerPC and\n            # 64-bit PowerPC, with 32-bit PowerPC first, as those\n            # are both supported.  (I'm guessing that's what Apple\n            # does.)\n            #\n            set(OSX_LIBRARY_ARCHITECTURES \"ppc;ppc64\")\n            set(OSX_EXECUTABLE_ARCHITECTURES \"ppc;ppc64\")\n        elseif(SYSTEM_VERSION_MINOR LESS 7)\n            #\n            # With Intel support but prior to x86-64 support.\n            #\n            # Build for 32-bit PowerPC, 64-bit PowerPC, and 32-bit x86,\n            # with 32-bit PowerPC first, as those are all supported.\n            # (I'm guessing that's what Apple does.)\n            #\n            set(OSX_LIBRARY_ARCHITECTURES \"ppc;ppc64;i386\")\n            set(OSX_EXECUTABLE_ARCHITECTURES \"ppc;ppc64;i386\")\n        else()\n            #\n            # With Intel support including x86-64 support.\n            #\n            # Build for 32-bit PowerPC, 64-bit PowerPC, 32-bit x86,\n            # and x86-64, with 32-bit PowerPC first, as those are\n            # all supported.  (I'm guessing that's what Apple does.)\n            #\n            set(OSX_LIBRARY_ARCHITECTURES \"ppc;ppc64;i386;x86_64\")\n            set(OSX_EXECUTABLE_ARCHITECTURES \"ppc;ppc64;i386;x86_64\")\n        endif()\n    elseif(SYSTEM_VERSION_MAJOR EQUAL 9)\n        #\n        # Leopard.\n        #\n        # Build libraries and executables for 32-bit PowerPC, 64-bit\n        # PowerPC, 32-bit x86, and x86-64, with 32-bit PowerPC\n        # first, as those are all supported.  (That's what Apple\n        # does.)\n        #\n        set(OSX_LIBRARY_ARCHITECTURES \"ppc;ppc64;i386;x86_64\")\n        set(OSX_EXECUTABLE_ARCHITECTURES \"ppc;ppc64;i386;x86_64\")\n    elseif(SYSTEM_VERSION_MAJOR EQUAL 10)\n        #\n        # Snow Leopard.\n        #\n        # Build libraries for x86-64, 32-bit x86, and 32-bit PowerPC,\n        # with x86-64 first, because 32-bit PowerPC executables are\n        # supported with Rosetta.  (That's what Apple does, even though\n        # Snow Leopard doesn't run on PPC, so PPC libpcap runs under\n        # Rosetta, and Rosetta doesn't support BPF ioctls, so PPC\n        # executables can't do live captures.)\n        #\n        set(OSX_LIBRARY_ARCHITECTURES \"x86_64;i386;ppc\")\n\n        #\n        # Build executables only for 32-bit x86 and 64-bit x86, as PPC\n        # machines are no longer supported.\n        #\n        set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64;i386\")\n    elseif(SYSTEM_VERSION_MAJOR GREATER 10 AND SYSTEM_VERSION_MAJOR LESS 19)\n        #\n        # Post-Snow Leopard, pre-Catalina.\n        #\n        # Build libraries for 64-bit x86 and 32-bit x86, with 64-bit x86\n        # first, as PPC machines are no longer supported, but 32-bit\n        # x86 executables are.  (That's what Apple does.)\n        #\n        # First, check whether we're building with OpenSSL.\n        # If so, don't bother trying to build fat.\n        #\n        if(HAVE_OPENSSL)\n          set(X86_32_BIT_SUPPORTED NO)\n          set(OSX_LIBRARY_ARCHITECTURES \"x86_64\")\n          set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64\")\n          message(WARNING \"We're assuming the OpenSSL libraries are 64-bit only, so we're not compiling for 32-bit x86\")\n        else()\n          #\n          # Now, check whether we *can* build for i386.\n          #\n          cmake_push_check_state()\n          set(CMAKE_REQUIRED_FLAGS \"-arch i386\")\n          check_c_source_compiles(\n\"int\nmain(void)\n{\n    return 0;\n}\n\"\n                   X86_32_BIT_SUPPORTED)\n          cmake_pop_check_state()\n          if(X86_32_BIT_SUPPORTED)\n              set(OSX_LIBRARY_ARCHITECTURES \"x86_64;i386\")\n          else()\n              set(OSX_LIBRARY_ARCHITECTURES \"x86_64\")\n              #\n              # We can't build fat; suggest that the user install the\n              # /usr/include headers if they want to build fat.\n              #\n              if(SYSTEM_VERSION_MAJOR LESS 18)\n                  #\n                  # Pre-Mojave; the command-line tools should be sufficient to\n                  # enable 32-bit x86 builds.\n                  #\n                  message(WARNING \"Compiling for 32-bit x86 gives an error; try installing the command-line tools\")\n              else()\n                  message(WARNING \"Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package\")\n              endif()\n          endif()\n        endif()\n\n        #\n        # Build executables only for 64-bit x86, as 32-bit x86 machines\n        # are no longer supported.\n        #\n        set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64\")\n    elseif(SYSTEM_VERSION_MAJOR EQUAL 19)\n        #\n        # Catalina.\n        #\n        # Build libraries and executables only for x86-64, as 32-bit\n        # executables are no longer supported.  (That's what Apple\n        # does.)\n        #\n        set(OSX_LIBRARY_ARCHITECTURES \"x86_64\")\n        set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64\")\n    else()\n        #\n        # Post-Catalina.  Build libraries and\n        # executables for x86-64 and ARM64.\n        # (That's what Apple does, except they\n        # build for arm64e, which may include\n        # some of the pointer-checking extensions.)\n        #\n        # If we're building with libssl, make sure\n        # we can build fat with it (i.e., that it\n        # was built fat); if we can't, don't set\n        # the target architectures, and just\n        # build for the host we're on.\n        #\n        # Otherwise, just add both of them.\n        #\n        if(HAVE_OPENSSL)\n          cmake_push_check_state()\n          set(CMAKE_REQUIRED_FLAGS \"-arch x86_64 -arch arm64\")\n          set(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})\n          set(CMAKE_REQUIRED_LIBRARIES ${OPENSSL_LIBRARIES})\n          #\n          # We must test whether this compiles and links, so\n          # check_symbol_exists() isn't sufficient.\n          #\n          # SSL_library_init() may be a macro that's #defined\n          # to be the real function to call, so we have to\n          # include <openssl/ssl.h>, and check_function_exists()\n          # isn't sufficient.\n          #\n          check_c_source_compiles(\n\"#include <openssl/ssl.h>\nint\nmain(void)\n{\n    SSL_library_init();\n    return 0;\n}\n\"\n              FAT_SSL_BUILDS_SUPPORTED)\n          cmake_pop_check_state()\n          if(FAT_SSL_BUILDS_SUPPORTED)\n            set(OSX_LIBRARY_ARCHITECTURES \"x86_64;arm64\")\n            set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64;arm64\")\n          endif()\n        else()\n          set(OSX_LIBRARY_ARCHITECTURES \"x86_64;arm64\")\n          set(OSX_EXECUTABLE_ARCHITECTURES \"x86_64;arm64\")\n        endif()\n    endif()\nendif()\n\n#\n# Additional linker flags.\n#\nset(LINKER_FLAGS \"${SANITIZER_FLAGS}\")\nif(ENABLE_PROFILING)\n    if(MSVC)\n        set(LINKER_FLAGS \" /PROFILE\")\n    else()\n        set(LINKER_FLAGS \" -pg\")\n    endif()\nendif()\n\n######################################\n# Input files\n######################################\n\nset(PROJECT_SOURCE_LIST_C\n    bpf_dump.c\n    bpf_filter.c\n    bpf_image.c\n    etherent.c\n    fmtutils.c\n    gencode.c\n    nametoaddr.c\n    optimize.c\n    pcap-common.c\n    pcap-util.c\n    pcap.c\n    savefile.c\n    sf-pcapng.c\n    sf-pcap.c\n)\n\nif(WIN32)\n    #\n    # We add the character set conversion routines; they're Windows-only\n    # for now.\n    #\n    # We assume we don't have asprintf(), and provide an implementation\n    # that uses _vscprintf() to determine how big the string needs to be.\n    #\n    set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C}\n        charconv.c missing/win_asprintf.c)\nelse()\n    if(NOT HAVE_ASPRINTF)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} missing/asprintf.c)\n    endif()\n    if(NOT HAVE_STRLCAT)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} missing/strlcat.c)\n    endif(NOT HAVE_STRLCAT)\n    if(NOT HAVE_STRLCPY)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} missing/strlcpy.c)\n    endif(NOT HAVE_STRLCPY)\n    if(NOT HAVE_STRTOK_R)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} missing/strtok_r.c)\n    endif(NOT HAVE_STRTOK_R)\nendif(WIN32)\n\n#\n# Determine the main pcap-XXX.c file to use, and the libraries with\n# which we need to link libpcap, if any.\n#\nif(WIN32)\n    #\n    # Windows.\n    #\n    # Has the user explicitly specified a capture type?\n    #\n    if(PCAP_TYPE STREQUAL \"\")\n        #\n        # The user didn't explicitly specify a capture mechanism.\n        # Check whether we have packet.dll.\n        #\n        if(HAVE_PACKET32)\n            #\n            # We have packet.dll.\n            # Set the capture type to NPF.\n            #\n            set(PCAP_TYPE npf)\n        else()\n            #\n            # We don't have any capture type we know about.\n            # Report an error, and tell the user to configure with\n            # -DPCAP_TYPE=null if they want a libpcap that can't\n            # capture but that can read capture files.  That way,\n            # nobody gets surprised by getting a no-capture\n            # libpcap without asking for that.\n            #\n            message(FATAL_ERROR \"No supported packet capture interface was found.\nIn order to build a version of libpcap that supports packet capture\non Windows, you will need to install Npcap and the Npcap SDK, or\nWinPcap and the WinPcap SDK, and run cmake with -DPacket_ROOT={path of SDK},\nwhere {path of SDK} is the path name of the top-level directory of the SDK.\nThat argument may have to be quoted if the path contains blanks.\nIf you want a libpcap that cannot capture packets but that can read\npcap and pcapng files, run cmake with -DPCAP_TYPE=null.\")\n        endif()\n    endif()\nelse()\n    #\n    # UN*X.\n    #\n    # Figure out what type of packet capture mechanism we have, and\n    # what libraries we'd need to link libpcap with, if any.\n    #\n\n    #\n    # Has the user explicitly specified a capture type?\n    #\n    if(PCAP_TYPE STREQUAL \"\")\n        #\n        # Check for a bunch of headers for various packet capture mechanisms.\n        #\n        check_include_files(\"sys/types.h;net/bpf.h\" HAVE_NET_BPF_H)\n        if(HAVE_NET_BPF_H)\n            #\n            # Does it define BIOCSETIF?\n            # I.e., is it a header for an LBL/BSD-style capture\n            # mechanism, or is it just a header for a BPF filter\n            # engine?  Some versions of Arch Linux, for example,\n            # have a net/bpf.h that doesn't define BIOCSETIF;\n            # as it's a Linux, it should use packet sockets,\n            # instead.\n            #\n            # We need:\n            #\n            #  sys/types.h, because FreeBSD 10's net/bpf.h\n            #  requires that various BSD-style integer types\n            #  be defined;\n            #\n            #  sys/time.h, because AIX 5.2 and 5.3's net/bpf.h\n            #  doesn't include it but does use struct timeval\n            #  in ioctl definitions;\n            #\n            #  sys/ioctl.h and, if we have it, sys/ioccom.h,\n            #  because net/bpf.h defines ioctls;\n            #\n            #  net/if.h, because it defines some structures\n            #  used in ioctls defined by net/bpf.h;\n            #\n            #  sys/socket.h, because OpenBSD 5.9's net/bpf.h\n            #  defines some structure fields as being\n            #  struct sockaddrs;\n            #\n            # and net/bpf.h doesn't necessarily include all\n            # of those headers itself.\n            #\n            if(HAVE_SYS_IOCCOM_H)\n                check_symbol_exists(BIOCSETIF \"sys/types.h;sys/time.h;sys/ioctl.h;sys/socket.h;sys/ioccom.h;net/bpf.h;net/if.h\" BPF_H_DEFINES_BIOCSETIF)\n            else(HAVE_SYS_IOCCOM_H)\n                check_symbol_exists(BIOCSETIF \"sys/types.h;sys/time.h;sys/ioctl.h;sys/socket.h;net/bpf.h;net/if.h\" BPF_H_DEFINES_BIOCSETIF)\n            endif(HAVE_SYS_IOCCOM_H)\n        endif(HAVE_NET_BPF_H)\n        check_include_file(linux/socket.h HAVE_LINUX_SOCKET_H)\n        check_include_file(sys/dlpi.h HAVE_SYS_DLPI_H)\n        check_include_file(config/HaikuConfig.h HAVE_CONFIG_HAIKUCONFIG_H)\n        check_include_file(hurd.h HAVE_HURD_H)\n\n        if(BPF_H_DEFINES_BIOCSETIF)\n            #\n            # BPF.\n            # Check this before DLPI, so that we pick BPF on\n            # Solaris 11 and later.\n            #\n            set(PCAP_TYPE bpf)\n        elseif(HAVE_LINUX_SOCKET_H)\n            #\n            # No prizes for guessing this one.\n            #\n            set(PCAP_TYPE linux)\n        elseif(HAVE_SYS_DLPI_H)\n            #\n            # DLPI on pre-Solaris 11 SunOS 5, HP-UX, possibly others.\n            #\n            set(PCAP_TYPE dlpi)\n        elseif(HAVE_CONFIG_HAIKUCONFIG_H)\n            #\n            # Haiku.\n            #\n            set(PCAP_TYPE haiku)\n        elseif(HAVE_HURD_H)\n            #\n            # Hurd.\n            #\n            set(PCAP_TYPE hurd)\n        else()\n            #\n            # We don't have any capture type we know about.\n            # Report an error, and tell the user to configure with\n            # -DPCAP_TYPE=null if they want a libpcap that can't\n            # capture but that can read capture files.  That way,\n            # nobody gets surprised by getting a no-capture\n            # libpcap without asking for that.\n            #\n            message(FATAL_ERROR \"No supported packet capture interface was found.\nSee the INSTALL.md file for information on packet capture support in\nvarious operating systems.\nIf you want a libpcap that cannot capture packets but that can read\npcap and pcapng files, run cmake with -DPCAP_TYPE=null.\")\n        endif()\n    endif()\nendif(WIN32)\nmessage(STATUS \"Packet capture mechanism type: ${PCAP_TYPE}\")\n\nfind_package(PkgConfig QUIET)\n\n#\n# Do capture-mechanism-dependent tests.\n#\nif(WIN32)\n    if(PCAP_TYPE STREQUAL \"npf\")\n        #\n        # Link with packet.dll before Winsock2.\n        #\n        set(PCAP_LINK_LIBRARIES ${Packet_LIBRARIES} ${PCAP_LINK_LIBRARIES})\n    elseif(PCAP_TYPE STREQUAL \"null\")\n    else()\n        message(FATAL_ERROR \"${PCAP_TYPE} is not a valid pcap type\")\n    endif()\nelse(WIN32)\n    if(PCAP_TYPE STREQUAL \"dlpi\")\n        #\n        # Needed for common functions used by pcap-[dlpi,libdlpi].c\n        #\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} dlpisubs.c)\n\n        #\n        # Checks for some header files.\n        #\n        check_include_file(sys/bufmod.h HAVE_SYS_BUFMOD_H)\n        check_include_file(sys/dlpi_ext.h HAVE_SYS_DLPI_EXT_H)\n\n        #\n        # Checks to see if Solaris has the public libdlpi(3LIB) library.\n        # Note: The existence of /usr/include/libdlpi.h does not mean it is the\n        # public libdlpi(3LIB) version. Before libdlpi was made public, a\n        # private version also existed, which did not have the same APIs.\n        # Due to a gcc bug, the default search path for 32-bit libraries does\n        # not include /lib, we add it explicitly here.\n        # [http://bugs.opensolaris.org/view_bug.do?bug_id=6619485].\n        # Also, due to the bug above applications that link to libpcap with\n        # libdlpi will have to add \"-L/lib\" option to \"configure\".\n        #\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_FLAGS \"-L/lib\")\n        set(CMAKE_REQUIRED_LIBRARIES dlpi)\n        check_function_exists(dlpi_walk HAVE_LIBDLPI)\n        cmake_pop_check_state()\n        if(HAVE_LIBDLPI)\n            #\n            # XXX - add -L/lib\n            #\n            set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} dlpi)\n            set(LIBS \"${LIBS} -ldlpi\")\n            set(LIBS_STATIC \"${LIBS_STATIC} -ldlpi\")\n            set(LIBS_PRIVATE \"${LIBS_PRIVATE} -ldlpi\")\n            set(PCAP_TYPE libdlpi)\n        endif()\n\n        #\n        # This check is for Solaris with DLPI support for passive modes.\n        # See dlpi(7P) for more details.\n        #\n        # XXX - there's no check_type() macro that's like check_type_size()\n        # except that it only checks for the existence of the structure type,\n        # so we use check_type_size() and ignore the size.\n        #\n        cmake_push_check_state()\n        set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h sys/dlpi.h)\n        check_type_size(dl_passive_req_t DL_PASSIVE_REQ_T)\n        cmake_pop_check_state()\n    elseif(PCAP_TYPE STREQUAL \"linux\")\n        #\n        # Do we have libnl?\n        # We only want version 3.  Version 2 was, apparently,\n        # short-lived, and version 1 is source and binary\n        # incompatible with version 3, and it appears that,\n        # these days, everybody's using version 3.  We're\n        # not supporting older versions of the Linux kernel;\n        # let's drop support for older versions of libnl, too.\n        #\n        # Due to lack of testing facilities this block does not\n        # include a branch for libnl-tiny with pkg-config, which\n        # is not consistent with Autoconf.\n        #\n        if(BUILD_WITH_LIBNL)\n            pkg_check_modules(LIBNL libnl-genl-3.0)\n            if(LIBNL_FOUND)\n                set(HAVE_LIBNL TRUE)\n                include_directories(${LIBNL_INCLUDE_DIRS})\n                set(PCAP_LINK_LIBRARIES ${LIBNL_LIBRARIES} ${PCAP_LINK_LIBRARIES})\n\n                #\n                # Get raw link flags from pkg-config.\n                #\n                pkg_get_link_info(LIBNL libnl-genl-3.0)\n                set(LIBS \"${LIBNL_LIBS} ${LIBS}\")\n                set(LIBS_STATIC \"${LIBNL_LIBS_STATIC} ${LIBS_STATIC}\")\n                set(REQUIRES_PRIVATE \"${LIBNL_PACKAGE_NAME} ${REQUIRES_PRIVATE}\")\n            else()\n                cmake_push_check_state()\n                set(CMAKE_REQUIRED_LIBRARIES nl-3)\n                check_function_exists(nl_socket_alloc HAVE_LIBNL)\n                cmake_pop_check_state()\n                if(HAVE_LIBNL)\n                    #\n                    # Yes, we have libnl 3.x.\n                    #\n                    set(PCAP_LINK_LIBRARIES nl-genl-3 nl-3 ${PCAP_LINK_LIBRARIES})\n                    include_directories(\"/usr/include/libnl3\")\n                    set(LIBS \"-lnl-genl-3 -lnl-3 ${LIBS}\")\n                    set(LIBS_STATIC \"-lnl-genl-3 -lnl-3 ${LIBS_STATIC}\")\n                    set(LIBS_PRIVATE \"-lnl-genl-3 -lnl-3 ${LIBS_PRIVATE}\")\n                endif()\n            endif()\n        else()\n            unset(HAVE_LIBNL CACHE) # check_function_exists stores results in cache\n        endif()\n\n        check_struct_has_member(\"struct tpacket_auxdata\" tp_vlan_tci linux/if_packet.h HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI)\n    elseif(PCAP_TYPE STREQUAL \"bpf\")\n        #\n        # Check whether we have the *BSD-style ioctls.\n        #\n        check_include_files(\"sys/types.h;net/if_media.h\" HAVE_NET_IF_MEDIA_H)\n\n        #\n        # Check whether we have struct BPF_TIMEVAL.\n        #\n        # XXX - there's no check_type() macro that's like check_type_size()\n        # except that it only checks for the existence of the structure type,\n        # so we use check_type_size() and ignore the size.\n        #\n        cmake_push_check_state()\n        if(HAVE_SYS_IOCCOM_H)\n            set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h sys/ioccom.h net/bpf.h)\n            check_type_size(\"struct BPF_TIMEVAL\" STRUCT_BPF_TIMEVAL)\n        else()\n            set(CMAKE_EXTRA_INCLUDE_FILES  sys/types.h net/bpf.h)\n            check_type_size(\"struct BPF_TIMEVAL\" STRUCT_BPF_TIMEVAL)\n        endif()\n        cmake_pop_check_state()\n\n        #\n        # Check whether there's a inet/ipnet.h header and,\n        # if so, whether it defines IPNET_ANY_LINK - if so,\n        # we assume we have the \"any\" device (that's a\n        # Solaris header, and later versions of Solaris\n        # have an \"any\" device).\n        #\n        # Attempting to include it at compile time could\n        # be a pain, as it's a kernel header.\n        #\n        message(STATUS \"Checking whether the Solaris \\\"any\\\" device is supported\")\n        if(EXISTS /usr/include/inet/ipnet.h)\n            file(STRINGS /usr/include/inet/ipnet.h IPNET_ANY_LINK_LINES REGEX IPNET_ANY_LINK)\n            if(NOT IPNET_ANY_LINK_LINES STREQUAL \"\")\n                set(HAVE_SOLARIS_ANY_DEVICE TRUE)\n            endif()\n        endif()\n        if(HAVE_SOLARIS_ANY_DEVICE)\n            message(STATUS \"Checking whether the Solaris \\\"any\\\" device is supported - supported\")\n        else()\n            message(STATUS \"Checking whether the Solaris \\\"any\\\" device is supported - not supported\")\n        endif()\n    elseif(PCAP_TYPE STREQUAL \"haiku\")\n        set(PCAP_SRC pcap-${PCAP_TYPE}.c)\n    elseif(PCAP_TYPE STREQUAL \"hurd\")\n        #\n        # Check for some headers just in case.\n        #\n        set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} rt)\n        set(LIBS \"${LIBS} -lrt\")\n        set(LIBS_STATIC \"${LIBS_STATIC} -lrt\")\n        set(LIBS_PRIVATE \"${LIBS_PRIVATE} -lrt\")\n        set(PCAP_SRC pcap-${PCAP_TYPE}.c)\n    elseif(PCAP_TYPE STREQUAL \"null\")\n    else()\n        message(FATAL_ERROR \"${PCAP_TYPE} is not a valid pcap type\")\n    endif()\nendif(WIN32)\n\nif(NOT DEFINED PCAP_SRC)\nset(PCAP_SRC pcap-${PCAP_TYPE}.c)\nendif()\n\nset(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} ${PCAP_SRC})\n\n#\n# Now figure out how we get a list of interfaces and addresses,\n# if we support capturing.  Don't bother if we don't support\n# capturing.\n#\nif(NOT WIN32)\n    #\n    # UN*X - figure out what type of interface list mechanism we\n    # have.\n    #\n    # If the capture type is null, that means we can't capture,\n    # so we can't open any capture devices, so we won't return\n    # any interfaces.\n    #\n    if(NOT PCAP_TYPE STREQUAL \"null\")\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LINK_LIBRARIES})\n        check_function_exists(getifaddrs HAVE_GETIFADDRS)\n        cmake_pop_check_state()\n        if(NOT HAVE_GETIFADDRS)\n            #\n            # It's not in the libraries that, at this point, we've\n            # found we need to link libpcap with.\n            #\n            # It's in libsocket on Solaris and possibly other OSes;\n            # as long as we're not linking with libxnet, check there.\n            #\n            # NOTE: if you hand check_library_exists as its last\n            # argument a variable that's been set, it skips the test,\n            # so we need different variables.\n            #\n            if(NOT LIBXNET_HAS_GETHOSTBYNAME)\n                check_library_exists(socket getifaddrs \"\" SOCKET_HAS_GETIFADDRS)\n                if(SOCKET_HAS_GETIFADDRS)\n                    set(PCAP_LINK_LIBRARIES socket ${PCAP_LINK_LIBRARIES})\n                    set(LIBS \"-lsocket ${LIBS}\")\n                    set(LIBS_STATIC \"-lsocket ${LIBS_STATIC}\")\n                    set(LIBS_PRIVATE \"-lsocket ${LIBS_PRIVATE}\")\n                    set(HAVE_GETIFADDRS TRUE)\n                endif()\n            endif()\n        endif()\n        if(HAVE_GETIFADDRS)\n            #\n            # We have \"getifaddrs()\"; make sure we have <ifaddrs.h>\n            # as well, just in case some platform is really weird.\n            # It may require that sys/types.h be included first,\n            # so include it first.\n            #\n            check_include_files(\"sys/types.h;ifaddrs.h\" HAVE_IFADDRS_H)\n            if(HAVE_IFADDRS_H)\n                #\n                # We have the header, so we use \"getifaddrs()\" to\n                # get the list of interfaces.\n                #\n                set(FINDALLDEVS_TYPE getad)\n            else()\n                #\n                # We don't have the header - give up.\n                # XXX - we could also fall back on some other\n                # mechanism, but, for now, this'll catch this\n                # problem so that we can at least try to figure\n                # out something to do on systems with \"getifaddrs()\"\n                # but without \"ifaddrs.h\", if there is something\n                # we can do on those systems.\n                #\n                message(FATAL_ERROR \"Your system has getifaddrs() but doesn't have a usable <ifaddrs.h>.\")\n            endif()\n        else()\n            #\n            # Well, we don't have \"getifaddrs()\", at least not with the\n            # libraries with which we've decided we need to link\n            # libpcap with, so we have to use some other mechanism.\n            #\n            # Note that this may happen on Solaris, which has\n            # getifaddrs(), but in -lsocket, not in -lxnet, so we\n            # won't find it if we link with -lxnet, which we want\n            # to do for other reasons.\n            #\n            # For now, we use either the SIOCGIFCONF ioctl or the\n            # SIOCGLIFCONF ioctl, preferring the latter if we have\n            # it; the latter is a Solarisism that first appeared\n            # in Solaris 8.  (Solaris's getifaddrs() appears to\n            # be built atop SIOCGLIFCONF; using it directly\n            # avoids a not-all-that-useful middleman.)\n            #\n            try_compile(HAVE_SIOCGLIFCONF ${CMAKE_CURRENT_BINARY_DIR} \"${pcap_SOURCE_DIR}/cmake/have_siocglifconf.c\" )\n            if(HAVE_SIOCGLIFCONF)\n                set(FINDALLDEVS_TYPE glifc)\n            else()\n                set(FINDALLDEVS_TYPE gifc)\n            endif()\n        endif()\n        message(STATUS \"Find-interfaces mechanism type: ${FINDALLDEVS_TYPE}\")\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} fad-${FINDALLDEVS_TYPE}.c)\n    endif()\nendif()\n\n# Check for hardware timestamp support.\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n    check_include_file(linux/net_tstamp.h HAVE_LINUX_NET_TSTAMP_H)\nendif()\n\n#\n# Check for additional native sniffing capabilities.\n#\n\n#\n# Various Linux-specific mechanisms.\n#\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n    # Check for usbmon USB sniffing support.\n    if(NOT DISABLE_LINUX_USBMON)\n        set(PCAP_SUPPORT_LINUX_USBMON TRUE)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-usb-linux.c)\n        #\n        # Do we have a version of <linux/compiler.h> available?\n        # If so, we might need it for <linux/usbdevice_fs.h>.\n        #\n        check_include_files(\"linux/compiler.h\" HAVE_LINUX_COMPILER_H)\n        if(HAVE_LINUX_COMPILER_H)\n            #\n            # Yes - include it when testing for <linux/usbdevice_fs.h>.\n            #\n            check_include_files(\"linux/compiler.h;linux/usbdevice_fs.h\" HAVE_LINUX_USBDEVICE_FS_H)\n        else(HAVE_LINUX_COMPILER_H)\n            check_include_files(\"linux/usbdevice_fs.h\" HAVE_LINUX_USBDEVICE_FS_H)\n        endif(HAVE_LINUX_COMPILER_H)\n        if(HAVE_LINUX_USBDEVICE_FS_H)\n            #\n            # OK, does it define bRequestType?  Older versions of the kernel\n            # define fields with names like \"requesttype, \"request\", and\n            # \"value\", rather than \"bRequestType\", \"bRequest\", and\n            # \"wValue\".\n            #\n            if(HAVE_LINUX_COMPILER_H)\n                check_struct_has_member(\"struct usbdevfs_ctrltransfer\" bRequestType \"linux/compiler.h;linux/usbdevice_fs.h\" HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE)\n            else(HAVE_LINUX_COMPILER_H)\n                check_struct_has_member(\"struct usbdevfs_ctrltransfer\" bRequestType \"linux/usbdevice_fs.h\" HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE)\n            endif(HAVE_LINUX_COMPILER_H)\n        endif()\n    endif()\n\n    #\n    # Check for netfilter sniffing support.\n    #\n    # Life's too short to deal with trying to get this to compile\n    # if you don't get the right types defined with\n    # __KERNEL_STRICT_NAMES getting defined by some other include.\n    #\n    # Check whether the includes Just Work.  If not, don't turn on\n    # netfilter support.\n    #\n    check_c_source_compiles(\n\"#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/types.h>\n\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_log.h>\n#include <linux/netfilter/nfnetlink_queue.h>\n\nint\nmain(void)\n{\n    return 0;\n}\n\"\n        PCAP_SUPPORT_NETFILTER)\n    if(PCAP_SUPPORT_NETFILTER)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-netfilter-linux.c)\n    endif(PCAP_SUPPORT_NETFILTER)\nendif()\n\n# Check for netmap sniffing support.\nif(NOT DISABLE_NETMAP)\n    #\n    # Check whether net/netmap_user.h is usable if NETMAP_WITH_LIBS is\n    # defined; it's not usable on DragonFly BSD 4.6 if NETMAP_WITH_LIBS\n    # is defined, for example, as it includes a nonexistent malloc.h\n    # header.\n    #\n    check_c_source_compiles(\n\"#define NETMAP_WITH_LIBS\n#include <net/netmap_user.h>\n\nint\nmain(void)\n{\n    return 0;\n}\n\"\n        PCAP_SUPPORT_NETMAP)\n    if(PCAP_SUPPORT_NETMAP)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-netmap.c)\n    endif(PCAP_SUPPORT_NETMAP)\nendif()\n\n# Check for DPDK sniffing support\nif(NOT DISABLE_DPDK)\n    find_package(dpdk)\n    if(dpdk_FOUND)\n        #\n        # We call rte_eth_dev_count_avail(), and older versions of DPDK\n        # didn't have it, so check for it.\n        #\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_INCLUDES ${dpdk_INCLUDE_DIRS})\n        set(CMAKE_REQUIRED_LIBRARIES ${dpdk_LIBRARIES})\n        check_function_exists(rte_eth_dev_count_avail HAVE_RTE_ETH_DEV_COUNT_AVAIL)\n        cmake_pop_check_state()\n        if(HAVE_RTE_ETH_DEV_COUNT_AVAIL)\n            set(DPDK_C_FLAGS \"-march=native\")\n            set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${DPDK_C_FLAGS}\")\n            include_directories(AFTER ${dpdk_INCLUDE_DIRS})\n            link_directories(AFTER ${dpdk_LIBRARIES})\n            set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${dpdk_LIBRARIES})\n            set(LIBS \"${LIBS} ${dpdk_LIBS}\")\n            set(LIBS_STATIC \"${LIBS_STATIC} ${dpdk_LIBS_STATIC}\")\n            set(REQUIRES_PRIVATE \"${REQUIRES_PRIVATE} ${dpdk_PACKAGE_NAME}\")\n            set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-dpdk.c)\n            set(PCAP_SUPPORT_DPDK TRUE)\n\n            #\n            # Check whether the rte_ether.h file defines\n            # struct ether_addr or struct rte_ether_addr.\n            #\n            # (\"API compatibility?  That's for losers!\")\n            #\n            cmake_push_check_state()\n            set(CMAKE_REQUIRED_INCLUDES ${dpdk_INCLUDE_DIRS})\n            set(CMAKE_EXTRA_INCLUDE_FILES rte_ether.h)\n            check_type_size(\"struct rte_ether_addr\" STRUCT_RTE_ETHER_ADDR)\n            cmake_pop_check_state()\n        endif()\n    else()\n      message(WARNING,\n\"We couldn't find DPDK with pkg-config.  If you want DPDK support,\nmake sure that pkg-config is installed, that DPDK 18.02.2 or later is\ninstalled, and that DPDK provides a .pc file.\")\n    endif()\nendif()\n\n# Check for Bluetooth sniffing support\nif(NOT DISABLE_BLUETOOTH)\n    if(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n        check_include_file(bluetooth/bluetooth.h HAVE_BLUETOOTH_BLUETOOTH_H)\n        if(HAVE_BLUETOOTH_BLUETOOTH_H)\n            set(PCAP_SUPPORT_BT TRUE)\n            set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-bt-linux.c)\n            #\n            # OK, does struct sockaddr_hci have an hci_channel\n            # member?\n            #\n            check_struct_has_member(\"struct sockaddr_hci\" hci_channel \"bluetooth/bluetooth.h;bluetooth/hci.h\" HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL)\n            if(HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL)\n                #\n                # OK, is HCI_CHANNEL_MONITOR defined?\n                #\n               check_c_source_compiles(\n\"#include <bluetooth/bluetooth.h>\n#include <bluetooth/hci.h>\n\nint\nmain(void)\n{\n    int i = HCI_CHANNEL_MONITOR;\n    return 0;\n}\n\"\n                   PCAP_SUPPORT_BT_MONITOR)\n               if(PCAP_SUPPORT_BT_MONITOR)\n                   #\n                   # Yes, so we can also support Bluetooth monitor\n                   # sniffing.\n                   #\n                   set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-bt-monitor-linux.c)\n               endif(PCAP_SUPPORT_BT_MONITOR)\n            endif(HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL)\n        endif(HAVE_BLUETOOTH_BLUETOOTH_H)\n    endif()\nelse()\n    unset(PCAP_SUPPORT_BT_MONITOR CACHE)\nendif()\n\n# Check for D-Bus sniffing support\nif(NOT DISABLE_DBUS)\n    #\n    # We don't support D-Bus sniffing on macOS; see\n    #\n    # https://bugs.freedesktop.org/show_bug.cgi?id=74029\n    #\n    if(APPLE)\n        message(FATAL_ERROR \"Due to freedesktop.org bug 74029, D-Bus capture support is not available on macOS\")\n    endif(APPLE)\n    pkg_check_modules(DBUS dbus-1)\n    if(DBUS_FOUND)\n        set(PCAP_SUPPORT_DBUS TRUE)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-dbus.c)\n        include_directories(${DBUS_INCLUDE_DIRS})\n\n        #\n        # This \"helpfully\" supplies DBUS_LIBRARIES as a bunch of\n        # library names - not paths - and DBUS_LIBRARY_DIRS as\n        # a bunch of directories.\n        #\n        # CMake *really* doesn't like the notion of specifying \"here are\n        # the directories in which to look for libraries\" except in\n        # find_library() calls; it *really* prefers using full paths to\n        # library files, rather than library names.\n        #\n        # Find the libraries and add their full paths.\n        #\n        set(DBUS_LIBRARY_FULLPATHS)\n        foreach(_lib IN LISTS DBUS_LIBRARIES)\n            #\n            # Try to find this library, so we get its full path.\n            #\n            find_library(_libfullpath ${_lib} HINTS ${DBUS_LIBRARY_DIRS})\n            list(APPEND DBUS_LIBRARY_FULLPATHS ${_libfullpath})\n        endforeach()\n        set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${DBUS_LIBRARY_FULLPATHS})\n\n        #\n        # Get library information for DPDK.\n        #\n        pkg_get_link_info(DBUS dbus-1)\n        set(LIBS \"${LIBS} ${DBUS_LIBS}\")\n        set(LIBS_STATIC \"${LIBS_STATIC} ${DBUS_LIBS_STATIC}\")\n        set(REQUIRES_PRIVATE \"${REQUIRES_PRIVATE} ${DBUS_PACKAGE_NAME}\")\n    endif(DBUS_FOUND)\nendif(NOT DISABLE_DBUS)\n\n# Check for RDMA sniffing support\nif(NOT DISABLE_RDMA)\n    pkg_check_modules(LIBIBVERBS libibverbs)\n    if(LIBIBVERBS_FOUND)\n        #\n        # pkg-config found it; remember its pkg-config name.\n        #\n        set(LIBIBVERBS_REQUIRES_PRIVATE ${LIBIBVERBS_PACKAGE_NAME})\n\n        #\n        # Get static linking information for it.\n        #\n        pkg_get_link_info(LIBIBVERBS libibverbs)\n    else()\n        #\n        # pkg-config didn't find it; try to look for it ourselves\n        #\n        check_library_exists(ibverbs ibv_get_device_list \"\" LIBIBVERBS_HAS_IBV_GET_DEVICE_LIST)\n        if(LIBIBVERBS_HAS_IBV_GET_DEVICE_LIST)\n            set(LIBIBVERBS_FOUND TRUE)\n            set(LIBIBVERBS_LIBRARIES ibverbs)\n            # XXX - at least on Ubuntu 20.04, there are many more\n            # libraries needed; is there any platform where\n            # libibverbs is available but where pkg-config\n            # isn't available or libibverbs doesn't use it?\n            # If not, we should only use pkg-config for it.\n            set(LIBIBVERBS_STATIC_LIBRARIES ibverbs)\n            set(LIBIBVERBS_LIBS -libverbs)\n            set(LIBIBVERBS_LIBS_STATIC -libverbs)\n            set(LIBIBVERBS_LIBS_PRIVATE -libverbs)\n        endif()\n    endif()\n    if(LIBIBVERBS_FOUND)\n        #\n        # For unknown reasons, check_include_file() doesn't just attempt\n        # to compile a test program that includes the header in\n        # question, it also attempts to link it.\n        #\n        # For unknown reasons, at least some of the static inline\n        # functions defined in infiniband/verbs.h are not inlined by the\n        # Sun^WOracle Studio C compiler, so the compiler generates code\n        # for them as part of the object code resulting from compiling\n        # the test program. At lest some of those functions call\n        # routines in -libverbs, so, in order to keep the compile and\n        # link from failing, even though the header file exists and is\n        # usable, we need to link with -libverbs.\n        #\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_LIBRARIES ${LIBIBVERBS_LIBRARIES})\n        check_include_file(infiniband/verbs.h HAVE_INFINIBAND_VERBS_H)\n        if(HAVE_INFINIBAND_VERBS_H)\n            check_symbol_exists(ibv_create_flow infiniband/verbs.h PCAP_SUPPORT_RDMASNIFF)\n            if(PCAP_SUPPORT_RDMASNIFF)\n                set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-rdmasniff.c)\n                set(PCAP_LINK_LIBRARIES ${LIBIBVERBS_LIBRARIES} ${PCAP_LINK_LIBRARIES})\n                set(LIBS \"${LIBIBVERBS_LIBS} ${LIBS}\")\n                set(LIBS_STATIC \"${LIBIBVERBS_LIBS_STATIC} ${LIBS_STATIC}\")\n                set(LIBS_PRIVATE \"${LIBIBVERBS_LIBS_PRIVATE} ${LIBS_PRIVATE}\")\n                set(REQUIRES_PRIVATE \"${REQUIRES_PRIVATE} ${LIBIBVERBS_PACKAGE_NAME}\")\n            endif(PCAP_SUPPORT_RDMASNIFF)\n        endif(HAVE_INFINIBAND_VERBS_H)\n        cmake_pop_check_state()\n    endif(LIBIBVERBS_FOUND)\nendif(NOT DISABLE_RDMA)\n\n#\n# Check for sniffing capabilities using third-party APIs.\n#\n\n# Check for Endace DAG card support.\nif(NOT DISABLE_DAG)\n    #\n    # Try to find the DAG header file and library.\n    #\n    find_package(DAG)\n\n    #\n    # Did we succeed?\n    #\n    if(DAG_FOUND)\n        #\n        # Yes.\n        # Check for various DAG API functions.\n        #\n        cmake_push_check_state()\n        set(CMAKE_REQUIRED_INCLUDES ${DAG_INCLUDE_DIRS})\n        set(CMAKE_REQUIRED_LIBRARIES ${DAG_LIBRARIES})\n        check_function_exists(dag_attach_stream64 HAVE_DAG_STREAMS_API)\n        if(NOT HAVE_DAG_STREAMS_API)\n            message(FATAL_ERROR \"DAG library lacks 64-bit streams support\")\n        endif()\n        cmake_pop_check_state()\n\n        include_directories(AFTER ${DAG_INCLUDE_DIRS})\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-dag.c)\n        set(HAVE_DAG_API TRUE)\n        set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${DAG_LIBRARIES})\n        set(LIBS \"${LIBS} ${DAG_LIBS}\")\n        set(LIBS_STATIC \"${LIBS_STATIC} ${DAG_LIBS_STATIC}\")\n        set(LIBS_PRIVATE \"${LIBS_PRIVATE} ${DAG_LIBS_PRIVATE}\")\n\n        get_filename_component(DAG_LIBRARY_DIR ${DAG_LIBRARY} PATH)\n        check_library_exists(vdag vdag_set_device_info ${DAG_LIBRARY_DIR} HAVE_DAG_VDAG)\n        if(HAVE_DAG_VDAG)\n            set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})\n            set(LIBS \"${LIBS} ${CMAKE_THREAD_LIBS_INIT}\")\n            set(LIBS_STATIC \"${LIBS_STATIC} ${CMAKE_THREAD_LIBS_INIT}\")\n            set(LIBS_PRIVATE \"${LIBS_PRIVATE} ${CMAKE_THREAD_LIBS_INIT}\")\n        endif()\n\n        if(ENABLE_DAG_TX)\n            set(ENABLE_DAG_TX TRUE)\n        endif()\n        message(STATUS \"Endace DAG transmit support (EXPERIMENTAL): ${ENABLE_DAG_TX}\")\n    endif()\nendif()\n\n# Check for Myricom SNF support.\nif(NOT DISABLE_SNF)\n    #\n    # Try to find the SNF header file and library.\n    #\n    find_package(SNF)\n\n    #\n    # Did we succeed?\n    #\n    if(SNF_FOUND)\n        #\n        # Yes.\n        #\n        include_directories(AFTER ${SNF_INCLUDE_DIRS})\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} pcap-snf.c)\n        set(HAVE_SNF_API TRUE)\n        set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${SNF_LIBRARIES})\n        set(LIBS \"${LIBS_STATIC} ${SNF_LIBS}\")\n        set(LIBS_STATIC \"${LIBS_STATIC} ${SNF_LIBS_STATIC}\")\n        set(LIBS_PRIVATE \"${LIBS_PRIVATE} ${SNF_LIBS_PRIVATE}\")\n    endif()\nendif()\n\n#\n# Remote capture support.\n#\n\nif(ENABLE_REMOTE)\n    #\n    # Check for various members of struct msghdr.\n    # We need to include ftmacros.h on some platforms, to make sure we\n    # get the POSIX/Single USER Specification version of struct msghdr,\n    # which has those members, rather than the backwards-compatible\n    # version, which doesn't.  That's not a system header file, and\n    # at least some versions of CMake include it as <ftmacros.h>, which\n    # won't check the current directory, so we add the top-level\n    # source directory to the list of include directories when we do\n    # the check.\n    #\n    cmake_push_check_state()\n    set(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR})\n    check_struct_has_member(\"struct msghdr\" msg_control \"ftmacros.h;sys/socket.h\" HAVE_STRUCT_MSGHDR_MSG_CONTROL)\n    check_struct_has_member(\"struct msghdr\" msg_flags \"ftmacros.h;sys/socket.h\" HAVE_STRUCT_MSGHDR_MSG_FLAGS)\n    cmake_pop_check_state()\n    set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C}\n        pcap-rpcap.c rpcap-protocol.c sockutils.c)\n    if(OPENSSL_FOUND)\n        set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} sslutils.c)\n    endif()\nendif(ENABLE_REMOTE)\n\n###################################################################\n#   Warning options\n###################################################################\n\n#\n# Check and add warning options if we have a .devel file.\n#\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/.devel OR EXISTS ${CMAKE_BINARY_DIR}/.devel)\n    #\n    # Warning options.\n    #\n    if(MSVC AND NOT ${CMAKE_C_COMPILER} MATCHES \"clang*\")\n        #\n        # MSVC, with Microsoft's front end and code generator.\n        # \"MSVC\" is also set for Microsoft's compiler with a Clang\n        # front end and their code generator (\"Clang/C2\"), so we\n        # check for clang.exe and treat that differently.\n        #\n        check_and_add_compiler_option(-Wall)\n        #\n        # Disable some pointless warnings that /Wall turns on.\n        #\n        # Unfortunately, MSVC does not appear to have an equivalent\n        # to \"__attribute__((unused))\" to mark a particular function\n        # parameter as being known to be unused, so that the compiler\n        # won't warn about it (for example, the function might have\n        # that parameter because a pointer to it is being used, and\n        # the signature of that function includes that parameter).\n        # C++ lets you give a parameter a type but no name, but C\n        # doesn't have that.\n        #\n        check_and_add_compiler_option(-wd4100)\n        #\n        # In theory, we care whether somebody uses f() rather than\n        # f(void) to declare a function with no arguments, but, in\n        # practice, there are places in the Windows header files\n        # that appear to do that, so we squelch that warning.\n        #\n        check_and_add_compiler_option(-wd4255)\n        #\n        # Windows FD_SET() generates this, so we suppress it.\n        #\n        check_and_add_compiler_option(-wd4548)\n        #\n        # Perhaps testing something #defined to be 0 with #ifdef is an\n        # error, and it should be tested with #if, but perhaps it's\n        # not, and Microsoft does that in its headers, so we squelch\n        # that warning.\n        #\n        check_and_add_compiler_option(-wd4574)\n        #\n        # The Windows headers also test not-defined values in #if, so\n        # we don't want warnings about that, either.\n        #\n        check_and_add_compiler_option(-wd4668)\n        #\n        # We do *not* care whether some function is, or isn't, going to be\n        # expanded inline.\n        #\n        check_and_add_compiler_option(-wd4710)\n        check_and_add_compiler_option(-wd4711)\n        #\n        # We do *not* care whether we're adding padding bytes after\n        # structure members.\n        #\n        check_and_add_compiler_option(-wd4820)\n        #\n        # We do *not* care about every single place the compiler would\n        # have inserted Spectre mitigation if only we had told it to\n        # do so with /Qspectre.  Maybe it's worth it, as that's in\n        # Bison-generated code that we don't control.\n        #\n        # XXX - add /Qspectre if that is really worth doing.\n        #\n        check_and_add_compiler_option(-wd5045)\n\n        #\n        # Treat all (remaining) warnings as errors.\n        #\n        check_and_add_compiler_option(-WX)\n    else()\n        #\n        # Other compilers, including MSVC with a Clang front end and\n        # Microsoft's code generator.  We currently treat them as if\n        # they might support GCC-style -W options.\n        #\n        check_and_add_compiler_option(-W)\n        check_and_add_compiler_option(-Wall)\n        check_and_add_compiler_option(-Wcomma)\n        # Warns about safeguards added in case the enums are extended\n        # check_and_add_compiler_option(-Wcovered-switch-default)\n        check_and_add_compiler_option(-Wdocumentation)\n        check_and_add_compiler_option(-Wformat-nonliteral)\n        check_and_add_compiler_option(-Wmissing-noreturn)\n        check_and_add_compiler_option(-Wmissing-prototypes)\n        check_and_add_compiler_option(-Wmissing-variable-declarations)\n        check_and_add_compiler_option(-Wnull-pointer-subtraction)\n        check_and_add_compiler_option(-Wpointer-arith)\n        check_and_add_compiler_option(-Wpointer-sign)\n        check_and_add_compiler_option(-Wshadow)\n        check_and_add_compiler_option(-Wshorten-64-to-32)\n        check_and_add_compiler_option(-Wsign-compare)\n        check_and_add_compiler_option(-Wstrict-prototypes)\n        check_and_add_compiler_option(-Wundef)\n        check_and_add_compiler_option(-Wunreachable-code)\n        check_and_add_compiler_option(-Wunused-but-set-parameter)\n        check_and_add_compiler_option(-Wunused-but-set-variable)\n        check_and_add_compiler_option(-Wunused-parameter)\n        check_and_add_compiler_option(-Wused-but-marked-unused)\n    endif()\nendif()\n\n#\n# Suppress some warnings we get with MSVC even without /Wall.\n#\nif(MSVC AND NOT ${CMAKE_C_COMPILER} MATCHES \"clang*\")\n    #\n    # Yes, we have some functions that never return but that\n    # have a non-void return type.  That's because, on some\n    # platforms, they *do* return values but, on other\n    # platforms, including Windows, they just fail and\n    # longjmp out by calling bpf_error().\n    #\n    check_and_add_compiler_option(-wd4646)\nendif()\n\nfile(GLOB PROJECT_SOURCE_LIST_H\n    *.h\n    pcap/*.h\n)\n\n#\n# Try to have the compiler default to hiding symbols, so that only\n# symbols explicitly exported with PCAP_API will be visible outside\n# (shared) libraries.\n#\n# Not necessary with MSVC, as that's the default.\n#\n# XXX - we don't use ADD_COMPILER_EXPORT_FLAGS, because, as of CMake\n# 2.8.12.2, it doesn't know about Sun C/Oracle Studio, and, as of\n# CMake 2.8.6, it only sets the C++ compiler flags, rather than\n# allowing an arbitrary variable to be set with the \"hide symbols\n# not explicitly exported\" flag.\n#\nif(NOT MSVC)\n    if(CMAKE_C_COMPILER_ID MATCHES \"SunPro\")\n        #\n        # Sun C/Oracle Studio.\n        #\n        check_and_add_compiler_option(-xldscope=hidden)\n    else()\n        #\n        # Try this for all other compilers; it's what GCC uses,\n        # and a number of other compilers, such as Clang and Intel C,\n        # use it as well.\n        #\n        check_and_add_compiler_option(-fvisibility=hidden)\n    endif()\nendif(NOT MSVC)\n\n#\n# Extra compiler options for the build matrix scripts to request -Werror or\n# its equivalent if required.  The CMake variable name cannot be CFLAGS\n# because that is already used for a different purpose in CMake.  Example\n# usage: cmake -DEXTRA_CFLAGS='-Wall -Wextra -Werror' ...\n#\nif(NOT \"${EXTRA_CFLAGS}\" STREQUAL \"\")\n    # The meaning of EXTRA_CFLAGS is \"use the exact specified options, or the\n    # build risks failing to fail\", not \"try every specified option, omit those\n    # that do not work and use the rest\".  Thus use add_compile_options(), not\n    # foreach()/check_and_add_compiler_option().  Another reason to do that is\n    # that the effect lasts in testprogs/ and testprogs/fuzz/.\n    string(REPLACE \" \" \";\" _extra_cflags_list ${EXTRA_CFLAGS})\n    add_compile_options(${_extra_cflags_list})\n    message(STATUS \"Added extra compile options (${EXTRA_CFLAGS})\")\nendif()\n\n#\n# Flex/Lex and YACC/Berkeley YACC/Bison.\n# From a mail message to the CMake mailing list by Andy Cedilnik of\n# Kitware.\n#\n\n#\n# Try to find Flex, a Windows version of Flex, or Lex.\n#\nfind_program(LEX_EXECUTABLE NAMES flex win_flex lex)\nif(LEX_EXECUTABLE STREQUAL \"LEX_EXECUTABLE-NOTFOUND\")\n    message(FATAL_ERROR \"Neither flex nor win_flex nor lex was found.\")\nendif()\nmessage(STATUS \"Lexical analyzer generator: ${LEX_EXECUTABLE}\")\n\n#\n# Make sure {f}lex supports the -P, --header-file, and --nounput flags\n# and supports processing our scanner.l.\n#\nif(WIN32)\n    set(NULL_DEVICE \"NUL:\")\nelse()\n    set(NULL_DEVICE \"/dev/null\")\nendif()\nexecute_process(COMMAND ${LEX_EXECUTABLE} -P pcap_ --header-file=${NULL_DEVICE} --nounput -t ${pcap_SOURCE_DIR}/scanner.l\n    OUTPUT_QUIET RESULT_VARIABLE EXIT_STATUS)\nif(NOT EXIT_STATUS EQUAL 0)\n    message(FATAL_ERROR \"${LEX_EXECUTABLE} is insufficient to compile libpcap.\nlibpcap requires Flex 2.5.31 or later, or a compatible version of lex.\nIf a suitable version of Lex/Flex is available as a non-standard command\nand/or not in the PATH, you can specify it using the LEX environment\nvariable. That said, on some systems the error can mean that Flex/Lex is\nactually acceptable, but m4 is not. Likewise, if a suitable version of\nm4 (such as GNU M4) is available but has not been detected, you can\nspecify it using the M4 environment variable.\")\nendif()\n\nadd_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/scanner.c ${CMAKE_CURRENT_BINARY_DIR}/scanner.h\n    COMMAND ${LEX_EXECUTABLE} -P pcap_ --header-file=scanner.h --nounput -o${CMAKE_CURRENT_BINARY_DIR}/scanner.c ${pcap_SOURCE_DIR}/scanner.l\n    DEPENDS ${pcap_SOURCE_DIR}/scanner.l\n)\n\n#\n# Since scanner.c does not exist yet when cmake is run, mark\n# it as generated.\n#\n# Since scanner.c includes grammar.h, mark that as a dependency.\n#\nset_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/scanner.c PROPERTIES\n    GENERATED TRUE\n    OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/grammar.h\n)\n\n#\n# Add scanner.c to the list of sources.\n#\n#set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} ${CMAKE_CURRENT_BINARY_DIR}/scanner.c)\n\n#\n# Try to find YACC or Bison.\n#\nfind_program(YACC_EXECUTABLE NAMES bison win_bison byacc yacc)\nif(YACC_EXECUTABLE STREQUAL \"YACC_EXECUTABLE-NOTFOUND\")\n    message(FATAL_ERROR \"Neither bison nor win_bison nor byacc nor yacc was found.\")\nendif()\n\nif(YACC_EXECUTABLE MATCHES \"byacc\" OR YACC_EXECUTABLE MATCHES \"yacc\")\n    #\n    # Make sure this is Berkeley YACC, not AT&T YACC;\n    # the latter doesn't support reentrant parsers.\n    # Run it with \"-V\"; that succeeds and reports the\n    # version number with Berkeley YACC, but will\n    # (probably) fail with various vendor flavors\n    # of AT&T YACC.\n    #\n    # Hopefully this also eliminates any versions\n    # of Berkeley YACC that don't support reentrant\n    # parsers, if there are any.\n    #\n    execute_process(COMMAND ${YACC_EXECUTABLE} -V OUTPUT_QUIET\n        RESULT_VARIABLE EXIT_STATUS)\n    if(NOT EXIT_STATUS EQUAL 0)\n        message(FATAL_ERROR \"${YACC_EXECUTABLE} is insufficient to compile libpcap.\nlibpcap requires Bison, a newer version of Berkeley YACC with support\nfor reentrant parsers, or another YACC compatible with them.\")\n    endif()\n    #\n    # Berkeley YACC doesn't support \"%define api.pure\", so use\n    # \"%pure-parser\".\n    #\n    set(REENTRANT_PARSER \"%pure-parser\")\nelse()\n    #\n    # Bison prior to 2.4(.1) doesn't support \"%define api.pure\", so use\n    # \"%pure-parser\".\n    #\n    execute_process(COMMAND ${YACC_EXECUTABLE} -V OUTPUT_VARIABLE bison_full_version)\n    string(REGEX MATCH \"[1-9][0-9]*[.][0-9]+\" bison_major_minor ${bison_full_version})\n    if (bison_major_minor VERSION_LESS \"2.4\")\n        set(REENTRANT_PARSER \"%pure-parser\")\n    else()\n        set(REENTRANT_PARSER \"%define api.pure\")\n    endif()\nendif()\n\nmessage(STATUS \"Parser generator: ${YACC_EXECUTABLE}\")\n\n#\n# Create custom command for the scanner.\n#\nadd_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/grammar.c ${CMAKE_CURRENT_BINARY_DIR}/grammar.h\n    COMMAND ${YACC_EXECUTABLE} -p pcap_ -o ${CMAKE_CURRENT_BINARY_DIR}/grammar.c -d ${pcap_BINARY_DIR}/grammar.y\n    DEPENDS ${pcap_BINARY_DIR}/grammar.y\n)\n\n#\n# Since grammar.c does not exists yet when cmake is run, mark\n# it as generated.\n#\nset_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/grammar.c PROPERTIES\n    GENERATED TRUE\n    OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/scanner.h\n)\n\n#\n# Add grammar.c to the list of sources.\n#\n#set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} ${CMAKE_CURRENT_BINARY_DIR}/grammar.c)\n\n#\n# Assume, by default, no support for shared libraries and V7/BSD\n# convention for man pages (devices in section 4, file formats in\n# section 5, miscellaneous info in section 7, administrative commands\n# and daemons in section 8).  Individual cases can override this.\n# Individual cases can override this.\n#\nset(MAN_DEVICES 4)\nset(MAN_FILE_FORMATS 5)\nset(MAN_MISC_INFO 7)\nset(MAN_ADMIN_COMMANDS 8)\nif(CMAKE_SYSTEM_NAME STREQUAL \"AIX\")\n    if(PCAP_TYPE STREQUAL \"bpf\")\n        #\n        # If we're using BPF, we need libodm and libcfg, as\n        # we use them to load the BPF module.\n        #\n        set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} odm cfg)\n        set(LIBS \"${LIBS} -lodm -lcfg\")\n        set(LIBS_STATIC \"${LIBS_STATIC} -lodm -lcfg\")\n        set(LIBS_PRIVATE \"${LIBS_PRIVATE} -lodm -lcfg\")\n    endif()\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"HP-UX\")\n    if(\n       CMAKE_SYSTEM_VERSION MATCHES \"[A-Z.]*9\\.[0-9]*\"\n       OR CMAKE_SYSTEM_VERSION MATCHES \"[A-Z.]*10\\.[01]\"\n    )\n        #\n        # HP-UX 9.x.\n        # HP-UX 10.0.\n        # HP-UX 10.1.\n        #\n        message(FATAL_ERROR \\\"HP-UX version must be 10.20 or later, not \\${CMAKE_SYSTEM_VERSION}\\\")\n    else()\n        #\n        # HP-UX 10.20 and later.\n        #\n        set(HAVE_HPUX10_20_OR_LATER TRUE)\n    endif()\n\n    #\n    # Use System V conventions for man pages.\n    #\n    set(MAN_ADMIN_COMMANDS 1m)\n    set(MAN_FILE_FORMATS 4)\n    set(MAN_MISC_INFO 5)\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND CMAKE_SYSTEM_VERSION MATCHES \"5[.][0-9.]*\")\n    #\n    # SunOS 5.x.\n    #\n    set(HAVE_SOLARIS TRUE)\n    #\n    # Make sure errno is thread-safe, in case we're called in\n    # a multithreaded program.  We don't guarantee that two\n    # threads can use the *same* pcap_t safely, but the\n    # current version does guarantee that you can use different\n    # pcap_t's in different threads, and even that pcap_compile()\n    # is thread-safe (it wasn't thread-safe in some older versions).\n    #\n    add_definitions(-D_TS_ERRNO)\n\n    if(CMAKE_SYSTEM_VERSION STREQUAL \"5.12\")\n    else()\n        #\n        # Use System V conventions for man pages.\n        #\n        set(MAN_ADMIN_COMMANDS 1m)\n        set(MAN_FILE_FORMATS 4)\n        set(MAN_MISC_INFO 5)\n        set(MAN_DEVICES 7D)\n    endif()\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Haiku\")\n    #\n    # Haiku needs _BSD_SOURCE for the _IO* macros because it doesn't use them.\n    #\n    add_definitions(-D_BSD_SOURCE)\nendif()\n\nsource_group(\"Source Files\" FILES ${PROJECT_SOURCE_LIST_C})\nsource_group(\"Header Files\" FILES ${PROJECT_SOURCE_LIST_H})\n\nif(WIN32)\n    #\n    # Add pcap-dll.rc to the list of sources.\n    #\n    set(PROJECT_SOURCE_LIST_C ${PROJECT_SOURCE_LIST_C} ${pcap_SOURCE_DIR}/pcap-dll.rc)\nendif(WIN32)\n\n#\n# Add subdirectories after we've set various variables, so they pick up\n# pick up those variables.\n#\nif(ENABLE_REMOTE)\n    add_subdirectory(rpcapd)\nendif(ENABLE_REMOTE)\nadd_subdirectory(testprogs)\n\n######################################\n# Register targets\n######################################\n\n#\n# Special target to serialize the building of the generated source.\n#\n# See\n#\n#  https://public.kitware.com/pipermail/cmake/2013-August/055510.html\n#\nadd_custom_target(SerializeTarget\n    DEPENDS\n    ${CMAKE_CURRENT_BINARY_DIR}/grammar.c\n    ${CMAKE_CURRENT_BINARY_DIR}/scanner.c\n)\n\nset_source_files_properties(${PROJECT_EXTERNAL_OBJECT_LIST} PROPERTIES\n    EXTERNAL_OBJECT TRUE)\n\nif(BUILD_SHARED_LIBS)\n    add_library(${LIBRARY_NAME} SHARED\n        ${PROJECT_SOURCE_LIST_C}\n        ${CMAKE_CURRENT_BINARY_DIR}/grammar.c\n        ${CMAKE_CURRENT_BINARY_DIR}/scanner.c\n        ${PROJECT_EXTERNAL_OBJECT_LIST}\n    )\n    target_include_directories(${LIBRARY_NAME} PUBLIC\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n        $<INSTALL_INTERFACE:include>\n    )\n    add_dependencies(${LIBRARY_NAME} SerializeTarget)\n    set_target_properties(${LIBRARY_NAME} PROPERTIES\n        COMPILE_DEFINITIONS BUILDING_PCAP)\n    #\n    # No matter what the library is called - it might be called \"wpcap\"\n    # in a Windows build - the symbol to define to indicate that we're\n    # building the library, rather than a program using the library,\n    # and thus that we're exporting functions defined in our public\n    # header files, rather than importing those functions, is\n    # pcap_EXPORTS.\n    #\n    set_target_properties(${LIBRARY_NAME} PROPERTIES\n        DEFINE_SYMBOL pcap_EXPORTS)\n    if(NOT \"${LINKER_FLAGS}\" STREQUAL \"\")\n        set_target_properties(${LIBRARY_NAME} PROPERTIES\n            LINK_FLAGS \"${LINKER_FLAGS}\")\n    endif()\nendif(BUILD_SHARED_LIBS)\n\nadd_library(${LIBRARY_NAME}_static STATIC\n    ${PROJECT_SOURCE_LIST_C}\n    ${CMAKE_CURRENT_BINARY_DIR}/grammar.c\n    ${CMAKE_CURRENT_BINARY_DIR}/scanner.c\n    ${PROJECT_EXTERNAL_OBJECT_LIST}\n)\ntarget_include_directories(${LIBRARY_NAME}_static PUBLIC\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n    $<INSTALL_INTERFACE:include>\n)\nadd_dependencies(${LIBRARY_NAME}_static SerializeTarget)\nset_target_properties(${LIBRARY_NAME}_static PROPERTIES\n    COMPILE_DEFINITIONS BUILDING_PCAP)\n\nif(WIN32)\n    if(BUILD_SHARED_LIBS)\n        set_target_properties(${LIBRARY_NAME} PROPERTIES\n            VERSION ${PACKAGE_VERSION_NOSUFFIX} # only MAJOR and MINOR are needed\n        )\n    endif(BUILD_SHARED_LIBS)\n    if(MSVC)\n        # XXX For DLLs, the TARGET_PDB_FILE generator expression can be used to locate\n        # its PDB file's output directory for installation.\n        # cmake doesn't offer a generator expression for PDB files generated by the\n        # compiler (static libraries).\n        # So instead of considering any possible output there is (there are many),\n        # this will search for the PDB file in the compiler's initial output directory,\n        # which is always ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles\\wpcap_static.dir\n        # regardless of architecture, build generator etc.\n        # Quite hackish indeed.\n        set(CMAKE_COMPILE_PDB_OUTPUT_DIRECTORY $<TARGET_FILE_DIR:${LIBRARY_NAME}_static>)\n        set_target_properties(${LIBRARY_NAME}_static PROPERTIES\n            COMPILE_PDB_NAME ${LIBRARY_NAME}_static\n            OUTPUT_NAME \"${LIBRARY_NAME}_static\"\n        )\n    elseif(MINGW)\n        #\n        # For compatibility, build the shared library without the \"lib\" prefix on\n        # MinGW as well.\n        #\n        set_target_properties(${LIBRARY_NAME} PROPERTIES\n            PREFIX \"\"\n            OUTPUT_NAME \"${LIBRARY_NAME}\"\n        )\n        set_target_properties(${LIBRARY_NAME}_static PROPERTIES\n            OUTPUT_NAME \"${LIBRARY_NAME}\"\n        )\n    endif()\nelse(WIN32) # UN*X\n    if(BUILD_SHARED_LIBS)\n        if(APPLE)\n            set_target_properties(${LIBRARY_NAME} PROPERTIES\n                VERSION ${PACKAGE_VERSION}\n                SOVERSION A\n            )\n        else(APPLE)\n            set_target_properties(${LIBRARY_NAME} PROPERTIES\n                VERSION ${PACKAGE_VERSION}\n                SOVERSION ${PACKAGE_VERSION_MAJOR}\n            )\n        endif(APPLE)\n    endif(BUILD_SHARED_LIBS)\n    set_target_properties(${LIBRARY_NAME}_static PROPERTIES\n        OUTPUT_NAME \"${LIBRARY_NAME}\"\n    )\nendif(WIN32)\n\nif(BUILD_SHARED_LIBS)\n    if(NOT C_ADDITIONAL_FLAGS STREQUAL \"\")\n        set_target_properties(${LIBRARY_NAME} PROPERTIES COMPILE_FLAGS ${C_ADDITIONAL_FLAGS})\n    endif()\n\n    #\n    # If this is macOS and we've picked the default architectures on\n    # which to build, build the library on them.\n    #\n    if(APPLE AND \"${CMAKE_OSX_ARCHITECTURES}\" STREQUAL \"\")\n        set_target_properties(${LIBRARY_NAME} PROPERTIES\n            OSX_ARCHITECTURES \"${OSX_LIBRARY_ARCHITECTURES}\")\n    endif()\n    target_link_libraries(${LIBRARY_NAME} ${PCAP_LINK_LIBRARIES})\nendif(BUILD_SHARED_LIBS)\n\nif(NOT C_ADDITIONAL_FLAGS STREQUAL \"\")\n    set_target_properties(${LIBRARY_NAME}_static PROPERTIES COMPILE_FLAGS ${C_ADDITIONAL_FLAGS})\nendif()\n\n#\n# If this is macOS and we've picked the default architectures on\n# which to build, build the library on them.\n#\nif(APPLE AND \"${CMAKE_OSX_ARCHITECTURES}\" STREQUAL \"\")\n    set_target_properties(${LIBRARY_NAME}_static PROPERTIES\n        OSX_ARCHITECTURES \"${OSX_LIBRARY_ARCHITECTURES}\")\nendif()\n\n######################################\n# Write out the config.h file\n######################################\n\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmakeconfig.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)\n\n######################################\n# Write out the grammar.y file\n######################################\n\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/grammar.y.in ${CMAKE_CURRENT_BINARY_DIR}/grammar.y @ONLY)\n\n######################################\n# Install pcap library, include files, and man pages\n######################################\n\n#\n# \"Define GNU standard installation directories\", which actually\n# are also defined, to some degree, by autotools, and at least\n# some of which are general UN*X conventions.\n#\ninclude(GNUInstallDirs)\n\nset(LIBRARY_NAME_STATIC ${LIBRARY_NAME}_static)\n\nfunction(install_manpage_symlink SOURCE TARGET MANDIR)\n    if(MINGW)\n        #\n        # If we haven't found an ln executable with MinGW, we don't try\n        # generating and installing the man pages, so if we get here,\n        # we've found that executable.\n        set(LINK_COMMAND \"\\\"${LINK_EXECUTABLE}\\\" \\\"-s\\\" \\\"${SOURCE}\\\" \\\"${TARGET}\\\"\")\n    else(MINGW)\n        set(LINK_COMMAND \"\\\"${CMAKE_COMMAND}\\\" \\\"-E\\\" \\\"create_symlink\\\" \\\"${SOURCE}\\\" \\\"${TARGET}\\\"\")\n    endif(MINGW)\n\n    install(CODE \"\n         if(NOT ${CMAKE_INSTALL_MESSAGE} STREQUAL \\\"NEVER\\\")\n             message(STATUS \\\"Symlinking: \\$ENV{DESTDIR}\\${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\\\")\n         endif()\n         execute_process(\n            COMMAND \\\"${CMAKE_COMMAND}\\\" \\\"-E\\\" \\\"remove\\\" \\\"${TARGET}\\\"\n            WORKING_DIRECTORY \\$ENV{DESTDIR}\\${CMAKE_INSTALL_PREFIX}/${MANDIR}\n          )\n         execute_process(\n            COMMAND ${LINK_COMMAND}\n            WORKING_DIRECTORY \\$ENV{DESTDIR}\\${CMAKE_INSTALL_PREFIX}/${MANDIR}\n            RESULT_VARIABLE EXIT_STATUS\n          )\n          if(NOT EXIT_STATUS EQUAL 0)\n              message(FATAL_ERROR \\\"Could not create symbolic link from \\${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\\\")\n          endif()\n          set(CMAKE_INSTALL_MANIFEST_FILES \\${CMAKE_INSTALL_MANIFEST_FILES} \\${CMAKE_INSTALL_PREFIX}/${MANDIR}/${TARGET})\")\nendfunction(install_manpage_symlink)\n\nset(MAN1_NOEXPAND pcap-config.1)\nset(MAN3PCAP_EXPAND\n    pcap.3pcap.in\n    pcap_compile.3pcap.in\n    pcap_datalink.3pcap.in\n    pcap_dump_open.3pcap.in\n    pcap_get_tstamp_precision.3pcap.in\n    pcap_list_datalinks.3pcap.in\n    pcap_list_tstamp_types.3pcap.in\n    pcap_open_dead.3pcap.in\n    pcap_open_offline.3pcap.in\n    pcap_set_immediate_mode.3pcap.in\n    pcap_set_tstamp_precision.3pcap.in\n    pcap_set_tstamp_type.3pcap.in\n)\nset(MAN3PCAP_NOEXPAND\n    pcap_activate.3pcap\n    pcap_breakloop.3pcap\n    pcap_can_set_rfmon.3pcap\n    pcap_close.3pcap\n    pcap_create.3pcap\n    pcap_datalink_name_to_val.3pcap\n    pcap_datalink_val_to_name.3pcap\n    pcap_dump.3pcap\n    pcap_dump_close.3pcap\n    pcap_dump_file.3pcap\n    pcap_dump_flush.3pcap\n    pcap_dump_ftell.3pcap\n    pcap_file.3pcap\n    pcap_fileno.3pcap\n    pcap_findalldevs.3pcap\n    pcap_freecode.3pcap\n    pcap_get_required_select_timeout.3pcap\n    pcap_get_selectable_fd.3pcap\n    pcap_geterr.3pcap\n    pcap_init.3pcap\n    pcap_inject.3pcap\n    pcap_is_swapped.3pcap\n    pcap_lib_version.3pcap\n    pcap_lookupdev.3pcap\n    pcap_lookupnet.3pcap\n    pcap_loop.3pcap\n    pcap_major_version.3pcap\n    pcap_next_ex.3pcap\n    pcap_offline_filter.3pcap\n    pcap_open_live.3pcap\n    pcap_set_buffer_size.3pcap\n    pcap_set_datalink.3pcap\n    pcap_set_promisc.3pcap\n    pcap_set_protocol_linux.3pcap\n    pcap_set_rfmon.3pcap\n    pcap_set_snaplen.3pcap\n    pcap_set_timeout.3pcap\n    pcap_setdirection.3pcap\n    pcap_setfilter.3pcap\n    pcap_setnonblock.3pcap\n    pcap_snapshot.3pcap\n    pcap_stats.3pcap\n    pcap_statustostr.3pcap\n    pcap_strerror.3pcap\n    pcap_tstamp_type_name_to_val.3pcap\n    pcap_tstamp_type_val_to_name.3pcap\n)\nset(MANFILE_EXPAND\n    cbpf-savefile.manfile.in\n    pcap-savefile.manfile.in\n)\nset(MANMISC_EXPAND\n    pcap-filter.manmisc.in\n    pcap-linktype.manmisc.in\n    pcap-tstamp.manmisc.in\n)\n\nif(BUILD_SHARED_LIBS)\n    set(LIBRARIES_TO_INSTALL \"${LIBRARY_NAME}\" \"${LIBRARY_NAME_STATIC}\")\nelse(BUILD_SHARED_LIBS)\n    set(LIBRARIES_TO_INSTALL \"${LIBRARY_NAME_STATIC}\")\nendif(BUILD_SHARED_LIBS)\n\nif(WIN32 OR CYGWIN OR MSYS)\n    #\n    # XXX - according to the CMake documentation, WIN32 is set if\n    # the target is Windows; would there ever be a case where\n    # CYGWIN or MSYS are set but WIN32 *isn't* set?\n    #\n    if(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 8)\n        #\n        # Install 64-bit code built with MSVC in the x64 subdirectories,\n        # as that's where it expects it to be.\n        #\n        install(TARGETS ${LIBRARIES_TO_INSTALL}\n                RUNTIME DESTINATION bin/x64\n                LIBRARY DESTINATION lib/x64\n                ARCHIVE DESTINATION lib/x64)\n        if(NOT MINGW)\n            install(FILES $<TARGET_FILE_DIR:${LIBRARY_NAME_STATIC}>/${LIBRARY_NAME_STATIC}.pdb\n                    DESTINATION bin/x64 OPTIONAL)\n            if(BUILD_SHARED_LIBS)\n                install(FILES $<TARGET_PDB_FILE:${LIBRARY_NAME}>\n                        DESTINATION bin/x64 OPTIONAL)\n            endif(BUILD_SHARED_LIBS)\n        endif(NOT MINGW)\n    else(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 8)\n        #\n        # Install 32-bit code, and 64-bit code not built with MSVC\n        # in the top-level directories, as those are where they\n        # expect it to be.\n        #\n        install(TARGETS ${LIBRARIES_TO_INSTALL}\n                RUNTIME DESTINATION bin\n                LIBRARY DESTINATION lib\n                ARCHIVE DESTINATION lib)\n        if(MSVC)\n            install(FILES $<TARGET_FILE_DIR:${LIBRARY_NAME_STATIC}>/${LIBRARY_NAME_STATIC}.pdb\n                    DESTINATION bin OPTIONAL)\n            if(BUILD_SHARED_LIBS)\n                install(FILES $<TARGET_PDB_FILE:${LIBRARY_NAME}>\n                        DESTINATION bin OPTIONAL)\n            endif(BUILD_SHARED_LIBS)\n        endif(MSVC)\n    endif(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 8)\nelse(WIN32 OR CYGWIN OR MSYS)\n    install(TARGETS ${LIBRARIES_TO_INSTALL} DESTINATION ${CMAKE_INSTALL_LIBDIR})\nendif(WIN32 OR CYGWIN OR MSYS)\n\ninstall(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcap/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/pcap)\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-bpf.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-namedb.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n# On UN*X, and on Windows when not using MSVC, generate libpcap.pc and\n# pcap-config and process man pages and arrange that they be installed.\nif(NOT MSVC)\n    set(prefix ${CMAKE_INSTALL_PREFIX})\n    set(exec_prefix \"\\${prefix}\")\n    set(includedir \"\\${prefix}/include\")\n    set(libdir \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n\n    #\n    # If this is a platform where we need to have the .pc file and\n    # pcap-config script supply an rpath option to specify the directory\n    # in which the libpcap shared library is installed, and the install\n    # prefix /usr (meaning we're not installing a system library),\n    # provide the rpath option.\n    #\n    # (We must check CMAKE_INSTALL_PREFIX, as the library directory\n    # isn't  necessarily /usr/lib in this case - for example, Linux\n    # distributions for 64-bit platforms that also provide support for\n    # binaries for a 32-bit version of the platform may put the 64-bit\n    # libraries, the 32-bit libraries, or both in directories other than\n    # /usr/lib.)\n    #\n    # In AIX, do we have to do this?\n    #\n    # In Darwin-based OSes, the full paths of the shared libraries with\n    # which the program was linked are stored in the executable, so we\n    # don't need to provide an rpath option.\n    #\n    # With the HP-UX linker, directories specified with -L are, by\n    # default, added to the run-time search path, so we don't need to\n    # supply them.\n    #\n    # This must *not* depend on the compiler, as, on platforms where\n    # there's a GCC-compatible compiler and a vendor compiler, we need\n    # to work with both.\n    #\n    if(NOT CMAKE_INSTALL_PREFIX STREQUAL \"/usr\")\n        if(CMAKE_SYSTEM_NAME STREQUAL \"FreeBSD\" OR\n           CMAKE_SYSTEM_NAME STREQUAL \"NetBSD\" OR\n           CMAKE_SYSTEM_NAME STREQUAL \"OpenBSD\" OR\n           CMAKE_SYSTEM_NAME STREQUAL \"DragonFly BSD\" OR\n           CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n            #\n            # Platforms where the \"native\" C compiler is GCC or accepts\n            # compatible command-line arguments, and the \"native\" linker\n            # is the GNU linker or accepts compatible command-line\n            # arguments.\n            #\n            set(RPATH \"-Wl,-rpath,\\${libdir}\")\n        elseif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND CMAKE_SYSTEM_VERSION MATCHES \"5[.][0-9.]*\")\n            #\n            # SunOS 5.x.\n            #\n            # Sun/Oracle's linker, the GNU linker, and GNU-compatible\n            # linkers all support -R.\n            #\n            set(RPATH \"-Wl,-R,\\${libdir}\")\n        else()\n            #\n            # No option needed to set the RPATH.\n            #\n            set(RPATH \"\")\n        endif()\n    endif()\n    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/pcap-config.in ${CMAKE_CURRENT_BINARY_DIR}/pcap-config @ONLY)\n    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/libpcap.pc.in ${CMAKE_CURRENT_BINARY_DIR}/libpcap.pc @ONLY)\n    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/pcap-config DESTINATION bin)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libpcap.pc DESTINATION lib/pkgconfig)\n\n    #\n    # Man pages.\n    #\n    # For each section of the manual for which we have man pages\n    # that require macro expansion, do the expansion.\n    #\n    # If this is MinGW, maybe we have a UN*X-style ln command and\n    # maybe we don't.  (No, we do *NOT* require MSYS!)  If we don't\n    # have it, don't do the man pages.\n    #\n    if(MINGW)\n        find_program(LINK_EXECUTABLE ln)\n    endif(MINGW)\n    if(UNIX OR (MINGW AND LINK_EXECUTABLE))\n        set(MAN1 \"\")\n        foreach(MANPAGE ${MAN1_NOEXPAND})\n            set(MAN1 ${MAN1} ${CMAKE_CURRENT_SOURCE_DIR}/${MANPAGE})\n        endforeach(MANPAGE)\n        install(FILES ${MAN1} DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\n\n        set(MAN3PCAP \"\")\n        foreach(MANPAGE ${MAN3PCAP_NOEXPAND})\n            set(MAN3PCAP ${MAN3PCAP} ${CMAKE_CURRENT_SOURCE_DIR}/${MANPAGE})\n        endforeach(MANPAGE)\n        foreach(TEMPLATE_MANPAGE ${MAN3PCAP_EXPAND})\n            string(REPLACE \".in\" \"\" MANPAGE ${TEMPLATE_MANPAGE})\n            configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${TEMPLATE_MANPAGE} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE} @ONLY)\n            set(MAN3PCAP ${MAN3PCAP} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE})\n        endforeach(TEMPLATE_MANPAGE)\n        install(FILES ${MAN3PCAP} DESTINATION ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_datalink_val_to_name.3pcap pcap_datalink_val_to_description.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_datalink_val_to_name.3pcap pcap_datalink_val_to_description_or_dlt.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_dump_open.3pcap pcap_dump_fopen.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_findalldevs.3pcap pcap_freealldevs.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_geterr.3pcap pcap_perror.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_inject.3pcap pcap_sendpacket.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_list_datalinks.3pcap pcap_free_datalinks.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_list_tstamp_types.3pcap pcap_free_tstamp_types.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_loop.3pcap pcap_dispatch.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_major_version.3pcap pcap_minor_version.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_next_ex.3pcap pcap_next.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_open_dead.3pcap pcap_open_dead_with_tstamp_precision.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_open_offline.3pcap pcap_open_offline_with_tstamp_precision.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_open_offline.3pcap pcap_fopen_offline.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_open_offline.3pcap pcap_fopen_offline_with_tstamp_precision.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_tstamp_type_val_to_name.3pcap pcap_tstamp_type_val_to_description.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n        install_manpage_symlink(pcap_setnonblock.3pcap pcap_getnonblock.3pcap ${CMAKE_INSTALL_MANDIR}/man3)\n\n        set(MANFILE \"\")\n        foreach(TEMPLATE_MANPAGE ${MANFILE_EXPAND})\n            string(REPLACE \".manfile.in\" \".${MAN_FILE_FORMATS}\" MANPAGE ${TEMPLATE_MANPAGE})\n            configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${TEMPLATE_MANPAGE} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE} @ONLY)\n            set(MANFILE ${MANFILE} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE})\n        endforeach(TEMPLATE_MANPAGE)\n        install(FILES ${MANFILE} DESTINATION ${CMAKE_INSTALL_MANDIR}/man${MAN_FILE_FORMATS})\n\n        set(MANMISC \"\")\n        foreach(TEMPLATE_MANPAGE ${MANMISC_EXPAND})\n            string(REPLACE \".manmisc.in\" \".${MAN_MISC_INFO}\" MANPAGE ${TEMPLATE_MANPAGE})\n            configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${TEMPLATE_MANPAGE} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE} @ONLY)\n            set(MANMISC ${MANMISC} ${CMAKE_CURRENT_BINARY_DIR}/${MANPAGE})\n        endforeach(TEMPLATE_MANPAGE)\n        install(FILES ${MANMISC} DESTINATION ${CMAKE_INSTALL_MANDIR}/man${MAN_MISC_INFO})\n    endif(UNIX OR (MINGW AND LINK_EXECUTABLE))\nendif(NOT MSVC)\n\n# uninstall target\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n    IMMEDIATE @ONLY)\n\nadd_custom_target(uninstall\n    COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.4931640625,
          "content": "Guidelines for contributing\n===========================\n\nTo report a security issue (segfault, buffer overflow, infinite loop, arbitrary\ncode execution etc), please send an e-mail to security@tcpdump.org, do not use\nthe bug tracker!\n\nTo report a non-security problem (failure to compile, failure to capture packets\nproperly, missing support for a network interface type or DLT), please check\nfirst that it reproduces with the latest stable release of libpcap. If it does,\nplease check that the problem reproduces with the current git master branch of\nlibpcap. If it does (and it is not a security-related problem, otherwise see\nabove), please navigate to the\n[bug tracker](https://github.com/the-tcpdump-group/libpcap/issues)\nand check if the problem has already been reported. If it has not, please open\na new issue and provide the following details:\n\n* libpcap version (e.g. from `tcpdump --version`, `pcap-config --version` or\n  `git describe`)\n* operating system name and version and any other details that may be relevant\n  (`uname -a`, compiler name and version, CPU type etc.)\n* `configure` or `cmake` flags if any were used\n* statement of the problem\n* steps to reproduce\n\nPlease note that if you know exactly how to solve the problem and the solution\nwould not be too intrusive, it would be best to contribute some development time\nand open a pull request instead.\n\nStill not sure how to do? Feel free to [subscribe](https://www.tcpdump.org/#mailing-lists)\nto the mailing list tcpdump-workers@lists.tcpdump.org and ask!\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 18.7685546875,
          "content": "This file lists people who have contributed to libpcap.\n\nThe current maintainers (in alphabetical order):\n    Denis Ovsienko                <denis at ovsienko dot info>\n    Francois-Xavier Le Bail       <devel dot fx dot lebail at orange dot fr>\n    Guy Harris                    <gharris at sonic dot net>\n    Michael Richardson            <mcr at sandelman dot ottawa dot on dot ca>\n\nAdditional people who have contributed patches (in alphabetical order):\n    Adrian Budau                  <adbudau at bitdefender dot com>\n    Akos Vandra                   <axos88 at gmail dot com>\n    Alan Bawden                   <Alan at LCS dot MIT dot EDU>\n    Albert Chin                   <china at thewrittenword dot com>\n    Alexander Galanin             <al at galanin dot nnov dot ru>\n    Alexander 'Leo' Bergolth      <Leo dot Bergolth at wu-wien dot ac dot at>\n    Alexey Kuznetsov              <kuznet at ms2 dot inr dot ac dot ru>\n    Alexey Vishnyakov             <vishnya at ispras dot ru>\n    Alex Smith                    <44322503+MadAlexUK at users dot noreply dot github dot com>\n    Alfredo Alvarez Fernandez     <alfredoalvarezernandez at gmail dot com>\n    Ali Abdulkadir                <autostart dot ini at gmail dot com>\n    Alois Klink                   <alois at aloisklink dot com>\n    Alon Bar-Lev                  <alonbl at sourceforge dot net>\n    Anders Broman                 <anders dot broman at ericsson dot com>\n    Andres Perera                 <andres dot p at zoho dot com>\n    Andrew Brown                  <atatat at atatdot dot net>\n                                  <andy-1 at sourceforge dot net>\n    Ani Sinha                     <ani at aristanetworks dot com>\n    Anthony Kirby                 <Anthony dot Kirby at nominet dot uk>\n    Antonio Vázquez Blanco        <antonio dot vazquez at tarlogic dot com>\n    Antti Kantee                  <pooka at netbsd dot org>\n    Archit Shah                   <archit at cave32 dot com>\n    Arien Vijn                    <arienvijn at sourceforge dot net>\n    Arkadiusz Miskiewicz          <misiek at pld dot org dot pl>\n    Armando L. Caro Jr.           <acaro at mail dot eecis dot udel dot edu>\n    Assar Westerlund              <assar at sics dot se>\n    Atsushi Yasumoto              <30277794+atusy at users dot noreply dot github dot com>\n    Atzm Watanabe                 <atzm at atzm dot org>\n    Baptiste Peugnez              <baptiste dot peugnez at cea dot fr>\n    Baruch Siach                  <baruch at tkos dot co dot il>\n    Bill Parker                   <wp02855 at gmail dot com>\n    Biswapriyo Nath               <nathbappai at gmail dot com>\n    blazeable                     <blazeable at blazeable dot eu>\n    bleader                       <bleader at ratonland dot org>\n    Brent Cook                    <brent at boundary dot com>\n    Brian Ginsbach                <ginsbach at cray dot com>\n    B. Scott Michel               <scooter dot phd at gmail dot com>\n    Cedric Cellier                <rixed at happyleptic dot org>\n    Charles M. Hannum             <mycroft at netbsd dot org>\n    Chris G. Demetriou            <cgd at netbsd dot org>\n    Chris Lightfoot               <cwrl at users dot sourceforge dot net>\n    Chris Maynard                 <Chris dot Maynard at gtech dot com>\n    Chris Pepper                  <pepper at mail dot reppep dot com>\n    Christian Bell                <csbell at myri dot com>\n    Christian Peron               <csjp at freebsd dot org>\n    Christian Svensson            <blue at cmd dot nu>\n    Christopher K Lee             <christopher dot lee at cspi dot com>\n    Clément Péron                 <peron dot clem at gmail dot com>\n    Daniel Borkmann               <dborkman at redhat dot com>\n    Daniele Orlandi               <daniele at orlandi dot com>\n    Daniel Lublin                 <daniel at lublin dot se>\n    Daniel Miller                 <dmiller at nmap dot org>\n    Dario Lombardo                <lomato at gmail dot com>\n    Darren Lim                    <darren dot lim at endace dot com>\n    Darren Reed                   <darrenr at sun dot com>\n    Dave Barach                   <dave at barachs dot net>\n    David Clark                   <david dot clark at datasoft dot com>\n    David Kaelbling               <drk at sgi dot com>\n    David Karoly                  <david dot karoly at outlook dot com>\n    David Ward                    <david dot ward at ll dot mit dot edu>\n    David Young                   <dyoung at ojctech dot com>\n    Dean Gaudet                   <dean at arctic dot org>\n    dhruv                         <rsrivat at sourceforge dot net>\n    Dmytro Ovdiienko              <dmitriy dot ovdienko at gmail dot com>\n    Don Ebright                   <Don dot Ebright at compuware dot com>\n    Dug Song                      <dugsong at monkey dot org>\n    Dustin Spicuzza               <dustin at virtualroadside dot com>\n    dzejarczech                   <dzejarczech at sourceforge dot net>\n    Ed Maste                      <emaste at FreeBSD dot org>\n    Edward Sheldrake              <ejs1920 at sourceforge dot net>\n    Ege Çetin                     <egecetin at hotmail dot com dot tr>\n    Eli Schwartz                  <eschwartz93 at gmail dot com>\n    Eric Anderson                 <anderse at hpl dot hp dot com>\n    Erik de Castro Lopo           <erik dot de dot castro dot lopo at sensorynetworks dot com>\n    Eugene Exarevsky              <eugene dot exarevsky at dsr-corporation dot com>\n    Fedor Sakharov                <fedor dot sakharov at gmail dot com>\n    Felix Janda                   <felix dot janda at posteo dot de>\n    Felix Obenhuber               <felix at obenhuber dot de>\n    fghzxm                        <fghzxm at outlook dot com>\n    Florent Drouin                <Florent dot Drouin at alcatel-lucent dot fr>\n    Florian Fainelli              <f dot fainelli at gmail dot com>\n    François Revol                <revol at free dot fr>\n    Frank Gorgas-Waller           <frank dot gorgas-waller at auerswald dot de>\n    Franz Schaefer                <schaefer at mond dot at>\n    frederich                     <frederich at sourceforge dot net>\n    Fulko Hew                     <fulko dot hew at gmail dot com>\n    Fumiyuki Shimizu              <fumifumi at abacustech dot jp>\n    Gabor Tatarka                 <gabor dot tatarka at ericsson dot com>\n    Gabriel Ganne                 <gabriel dot ganne at gmail dot com>\n    Garrett Cooper                <yaberauneya at sourceforge dot net>\n    George Neville-Neil           <gnn at freebsd dot org>\n    Gerald Combs                  <gerald at zing dot org>\n    Gerard Garcia                 <nouboh at gmail dot com>\n    Gianluca Varenni              <gianluca dot varenni at gmail dot com>\n    Gilbert Hoyek                 <gil_hoyek at hotmail dot com>\n    Gisle Vanem                   <gvanem at yahoo dot no>\n    Gokul Sivakumar               <gokulkumar792 at gmail dot com>\n    Graeme Hewson                 <ghewson at cix dot compulink dot co dot uk>\n    Gregor Maier                  <gregor at net dot in dot tum dot de>\n    Greg Stark                    <gsstark at mit dot edu>\n    Greg Troxel                   <gdt at ir dot bbn dot com>\n    Guillaume Pelat               <endymion_ at users dot sourceforge dot net>\n    Gustavo Zacarias              <gustavo at zacarias dot com dot ar>\n    Hagen Paul Pfeifer            <hagen at jauu dot net>\n    Hans Leidekker                <hans at meelstraat dot net>\n    headshog                      <craaaaaachind at gmail dot com>\n    Henri Chataing                <henrichataing at google dot com>\n    Henri Doreau                  <hdoreau at sourceforge dot net>\n    Hiroaki KAWAI                 <kawai at stratosphere dot co dot jp>\n    hopper-vul                    <hopper dot vul at gmail dot com>\n    Hyung Sik Yoon                <hsyn at kr dot ibm dot com>\n    Igor Khristophorov            <igor at atdot dot org>\n    Jakub Sitnicki                <jsitnicki at gmail dot com>\n    Jakub Zawadzki                <darkjames at darkjames dot pl>\n    James Ko                      <jck at exegin dot com>\n    Jan Adam                      <jadam at hilscher dot com>\n    Jan-Philip Velders            <jpv at veldersjes dot net>\n    Jason R. Thorpe               <thorpej at netbsd dot org>\n    Javier Achirica               <achirica at ttd dot net>\n    Jean-Louis Charton            <Jean-Louis dot CHARTON at oikialog dot com>\n    Jean Tourrilhes               <jt at hpl dot hp dot com>\n    Jefferson Ogata               <jogata at nodc dot noaa dot gov>\n    Jerome Duval                  <jerome dot duval at gmail dot com>\n    Jesper Dangaard Brouer        <hawk at comx dot dk>\n    Jesper Peterson               <jesper at endace dot com>\n    Jesse Gross                   <jesse at nicira dot com>\n    Jessica Clarke                <jrtc27 at jrtc27 dot com>\n    JHA                           <jon dot anderson at oracle dot com>\n    jingyu yang                   <jingleyang at users dot noreply dot github dot com>\n    Jiri Slaby                    <jirislaby at gmail dot com>\n    João Valverde                 <joao dot valverde at tecnico dot ulisboa dot pt>\n    Joel                          <82591719+joelg989 at users dot noreply dot github dot com>\n    Joerg Mayer                   <jmayer at loplof dot de>\n    John Bankier                  <jbankier at rainfinity dot com>\n    Jon Lindgren                  <jonl at yubyub dot net>\n    Jon Smirl                     <jonsmirl at gmail dot com>\n    Jorge Boncompte [DTI2]        <jorge at dti2 dot net>\n    Josh Soref                    <2119212+jsoref at users dot noreply dot github dot com>\n    jromanr                       <jromanr at hotmail dot com>\n    Juergen Schoenwaelder         <schoenw at ibr dot cs dot tu-bs dot de>\n    Julien Moutinho               <julm at savines dot alpes dot fr dot eu dot org>\n    Jung-uk Kim                   <jkim at FreeBSD dot org>\n    Kazushi Sugyo                 <sugyo at pb dot jp dot nec dot com>\n    Kenny Luong                   <kluong at cloudflare dot com>\n    Kevin Boulain                 <kevin dot boulain at securactive dot net>\n    Klaus Klein                   <kleink at netbsd dot org>\n    Koryn Grant                   <koryn at endace dot com>\n    Kris Katterjohn               <katterjohn at gmail dot com>\n    Krzysztof Halasa              <khc at pm dot waw dot pl>\n    Lennert Buytenhek             <buytenh at wantstofly dot org>\n    Li kunyu                      <kunyu at nfschina dot com>\n    lixiaoyan                     <lixiaoyan at google dot com>\n    Lorenzo Cavallaro             <sullivan at sikurezza dot org>\n    Loris Degioanni               <loris at netgroup-serv dot polito dot it>\n    Love Hörnquist-Åstrand        <lha at stacken dot kth dot se>\n    Lubomir Varga                 <lubomir dot varga at qpp dot sk>\n    Luis MartinGarcia             <luis dot mgarc at gmail dot com>\n    Luiz Angelo Daros de Luca     <luizluca at gmail dot com>\n    lxy                           <391861737 at qq dot com>\n    Maciej W. Rozycki             <macro at ds2 dot pg dot gda dot pl>\n    Mansour Behabadi              <mansour at oxplot dot com>\n    Marcus Felipe Pereira         <marcus at task dot com dot br>\n    Mario J. Rugiero              <mrugiero at gmail dot com>\n    Mark C. Brown                 <mbrown at hp dot com>\n    Mark Johnston                 <markjdb at gmail dot com>\n    Mark Marshall                 <mark dot marshall at omicronenergy dot com>\n    Mark Pizzolato                <List-tcpdump-workers at subscriptions dot pizzolato dot net>\n    Markus Mayer                  <markus_mayer at sourceforge dot net>\n    Martin Husemann               <martin at netbsd dot org>\n    Martin Kaiser                 <martin at kaiser dot cx>\n    Márton Németh                 <nm127 at freemail dot hu>\n    Matias Karhumaa               <matias dot karhumaa at gmail dot com>\n    Matt Eaton                    <agnosticdev at gmail dot com>\n    Matthew Luckie                <mjl at luckie dot org dot nz>\n    Matthias Hannig               <matthias at hannig dot cc>\n    Matwey V. Kornilov            <matwey dot kornilov at gmail dot com>\n    maxice8                       <thinkabit dot ukim at gmail dot com>\n    Max Laier                     <max at love2party dot net>\n    Michal Kubecek                <mkubecek at suse dot cz>\n    Michal Labedzki               <michal dot labedzki at tieto dot com>\n    Michal Ruprich                <michalruprich at gmail dot com>\n    Michal Sekletar               <msekleta at redhat dot com>\n    Mike Frysinger                <vapier at gmail dot com>\n    Mike Kershaw                  <dragorn at kismetwireless dot net>\n    Mike Wiacek                   <mike at iroot dot net>\n    Milosz Kaniewski              <milosz dot kaniewski at gmail dot com>\n    Miroslav Lichvar              <mlichvar at redhat dot com>\n    Monroe Williams               <monroe at pobox dot com>\n    Myricom Help                  <myri at users dot noreply dot github dot com>\n    Nan Xiao                      <nan at chinadtrace dot org>\n    nic-kaczinsky                 <68271784+nic-kaczinsky at users dot noreply dot github dot com>\n    Nick Kelsey                   <nickk at silicondust dot com>\n    Nicolas Dade                  <ndade at nsd dot dyndns dot org>\n    Niko Delarich                 <niko dot delarich at gmail dot com>\n    Nikolay Edigaryev             <edigaryev at gmail dot com>\n    N. Leiten                     <nleiten at sourceforge dot net>\n    nnposter                      <nnposter at users dot noreply dot github dot com>\n                                  <nvercamm at sourceforge dot net>\n    Octavian Cerna                <tavy at ylabs dot com>\n    Olaf Kirch                    <okir at caldera dot de>\n    Ollie Wild                    <aaw at users dot sourceforge dot net>\n    Ondřej Hošek                  <ondra dot hosek at gmail dot com>\n    Onno van der Linden           <onno at simplex dot nl>\n    Orgad Shaneh                  <orgad dot shaneh at audiocodes dot com>\n    Ørjan Malde                   <red at foxi dot me>\n    Paolo Abeni                   <pabeni at redhat dot com>\n    Patrick Marie                 <mycroft at virgaria dot org>\n    Patrick McHardy               <kaber at trash dot net>\n    Paul Mundt                    <lethal at linux-sh dot org>\n    Pavel Kankovsky               <kan at dcit dot cz>\n    Pawel Brzezinski              <pawel dot brzezinski at harman dot com>\n    Pawel Pokrywka                <publicpp at gmail dot com>\n    Peter Fales                   <peter at fales-lorenz dot net>\n    Peter Jeremy                  <peter dot jeremy at alcatel dot com dot au>\n    Peter Volkov                  <pva at gentoo dot org>\n    Petr Vorel                    <pvorel at suse dot cz>\n    Philippe Antoine              <contact at catenacyber dot fr>\n    Phil Wood                     <cpw at lanl dot gov>\n    Rafal Maszkowski              <rzm at icm dot edu dot pl>\n    ramin                         <lordrasmus at gmail dot com>\n                                  <rcb-isis at users dot sourceforge dot net>\n    Richard Braun                 <rbraun at sceen dot net>\n    Richard Stearn                <richard at rns-stearn dot demon dot co dot uk>\n    Rick Jones                    <raj at cup dot hp dot com>\n    Robert Edmonds                <edmonds at debian dot org>\n    Roberto Mariani               <jelot-tcpdump at jelot dot it>\n    Roland Dreier                 <roland at purestorage dot com>\n    Romain Francoise              <rfrancoise at debian dot org>\n    Rongxi Li                     <rongxi dot li at chaitin dot com>\n    Rose                          <83477269+AtariDreams at users dot noreply dot github dot com>\n    Ryan Castellucci              <github-1b66+210325 at ryanc dot org>\n    Sagun Shakya                  <sagun dot shakya at sun dot com>\n    Samuel Thibault               <samuel dot thibault at ens-lyon dot org>\n    Scott Barron                  <sb125499 at ohiou dot edu>\n    Scott Gifford                 <sgifford at tir dot com>\n    Scott Mcmillan                <scott dot a dot mcmillan at intel dot com>\n    Sebastian Krahmer             <krahmer at cs dot uni-potsdam dot de>\n    Sebastien Roy                 <Sebastien dot Roy at Sun dot COM>\n    Sepherosa Ziehau              <sepherosa at gmail dot com>\n    Shane Kerr                    <shane at time-travellers dot org>\n    Shaun Clowes                  <delius at progsoc dot uts dot edu dot au>\n    solofox                       <wensg100 at sina dot com>\n    Solomon Peachy                <pizza at shaftnet dot org>\n    Stefan Hudson                 <hudson at mbay dot net>\n    Stephen Donnelly              <stephen at endace dot com>\n    Steve Karg                    <skarg at users dot sourceforge dot net>\n    Stig Bjørlykke                <stig at bjorlykke dot org>\n    stubbfel                      <stubbfel at gmail dot com>\n    Takashi Yamamoto              <yamt at mwd dot biglobe dot ne dot jp>\n    Tanaka Shin-ya                <zstanaka at archer dot livedoor dot com>\n    Thomas Habets                 <habets at google dot com>\n    Thomas Petazzoni              <thomas dot petazzoni at free-electrons dot com>\n    Tobias Poschwatta             <posch at sourceforge dot net>\n    Tomasz Moń                    <desowin at gmail dot com>\n    Tommy Beadle                  <tbeadle at arbor dot net>\n    Tony Li                       <tli at procket dot com>\n    Torsten Landschoff            <torsten at debian dot org>\n    Tymoteusz Blazejczyk          <tymoteusz dot blazejczyk at intel dot com>\n    Uns Lider                     <unslider at miranda dot org>\n    Uwe Girlich                   <Uwe dot Girlich at philosys dot de>\n    Vitaly Lavrov                 <vel21ripn at gmail dot com>\n    Vivien Didelot                <vivien dot didelot at gmail dot com>\n    Vladimir Gladkov              <vovkos at gmail dot com>\n    Vladimir Marek                <vlmarek at volny dot cz>\n    Walter Schell                 <walterschell at users dot noreply dot github dot com>\n    Wesley Shields                <wxs at FreeBSD dot org>\n    Xianjie Zhang                 <xzhang at cup dot hp dot com>\n    Xin Li                        <delphij at FreeBSD dot org>\n    Xue Jiang Qing                <xuejianqing at star-net dot cn>\n    Yang Luo                      <hsluoyz at qq dot com>\n    Yen Yen Lim\n    Yoann Vandoorselaere          <yoann at prelude-ids dot org>\n    Yogesh Prasad                 <yogesh dot prasad at rockwellcollins dot com>\n    Yvan Vanhullebus              <vanhu at sourceforge dot net>\n\nThe original LBL crew:\n    Steve McCanne\n    Craig Leres\n    Van Jacobson\n\nPast maintainers (in alphabetical order):\n    Bill Fenner                   <fenner at research dot att dot com>\n    Fulvio Risso                  <risso at polito dot it>\n    Hannes Gredler                <hannes at gredler dot at>\n    Jun-ichiro itojun Hagino      <itojun at iijlab dot net>\t\tAlso see: http://www.wide.ad.jp/itojun-award/\n"
        },
        {
          "name": "ChmodBPF",
          "type": "tree",
          "content": null
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 12.1767578125,
          "content": "# libpcap installation notes\n\nPlatform-specific notes:\n* [AIX](doc/README.aix)\n* [Haiku](doc/README.haiku.md)\n* [HP-UX](doc/README.hpux)\n* [GNU/Hurd](doc/README.hurd.md)\n* [GNU/Linux](doc/README.linux)\n* [macOS](doc/README.macos)\n* [Solaris and related OSes](doc/README.solaris.md)\n* [Windows](doc/README.windows.md)\n\nHardware-specific notes:\n* [Endace DAG](doc/README.dag.md)\n* [Myricom SNF](doc/README.snf.md)\n\nLibpcap can be built either with the configure script and `make`, or\nwith CMake and any build system supported by CMake.\n\nTo build libpcap with the configure script and `make`:\n\n* If you build from a git clone rather than from a release archive,\nrun `./autogen.sh` (a shell script). The autogen.sh script will\nbuild the `configure` and `config.h.in` files.\n\nOn some system, you may need to set the `AUTORECONF` variable, like:\n`AUTORECONF=autoreconf-2.69 ./autogen.sh`\nto select the `autoreconf` version you want to use.\n\n* Run `./configure` (a shell script).  The configure script will\ndetermine your system attributes and generate an appropriate `Makefile`\nfrom `Makefile.in`.  The configure script has a number of options to\ncontrol the configuration of libpcap; `./configure --help` will show\nthem.\n\n* Next, run `make`.  If everything goes well, you can\n`su` to root and run `make install`.  However, you need not install\nlibpcap if you just want to build tcpdump; just make sure the tcpdump\nand libpcap directory trees have the same parent directory.\n\nOn OpenBSD, you may need to set, before the `make`, the `AUTOCONF_VERSION`\nvariable like:\n`AUTOCONF_VERSION=2.69 make`\n\nTo build libpcap with CMake and the build system of your choice, from\nthe command line:\n\n* Create a build directory into which CMake will put the build files it\ngenerates; CMake does not work as well with builds done in the source\ncode directory as does the configure script.  The build directory may be\ncreated as a subdirectory of the source directory or as a directory\noutside the source directory.\n\n* Change to the build directory and run CMake with the path from the\nbuild directory to the source directory as an argument.  The `-G` flag\ncan be used to select the CMake \"generator\" appropriate for the build\nsystem you're using; various `-D` flags can be used to control the\nconfiguration of libpcap.\n\n* Run the build tool.  If everything goes well, you can `su` to root and\nrun the build tool with the `install` target.  Building tcpdump from a\nlibpcap in a build directory is not supported.\n\nAn `uninstall` target is supported with both `./configure` and CMake.\n\n***DO NOT*** run the build as root; there is no need to do so, running\nanything as root that doesn't need to be run as root increases the risk\nof damaging your system, and running the build as root will put files in\nthe build directory that are owned by root and that probably cannot be\noverwritten, removed, or replaced except by root, which could cause\npermission errors in subsequent builds.\n\nIf configure says:\n\n    configure: warning: cannot determine packet capture interface\n    configure: warning: (see INSTALL.md file for more info)\n\nor CMake says:\n\n    cannot determine packet capture interface\n\n    (see the INSTALL.md file for more info)\n\nthen your system either does not support packet capture or your system\ndoes support packet capture but libpcap does not support that\nparticular type.  If your system uses a\npacket capture not supported by libpcap, please send us patches; don't\nforget to include an autoconf fragment suitable for use in\n`configure.ac`.\n\nIt is possible to override the default packet capture type with the\n`--with-pcap` option to `./configure` or the `-DPCAP_TYPE` option to\nCMake, although the circumstances where this works are limited.  One\npossible reason to do that would be to force a supported packet capture\ntype in the case where the configure or CMake scripts fails to detect\nit.\n\nYou will need a C99 compiler to build libpcap. The configure script\nwill abort if your compiler is not C99 compliant. If this happens, use\nthe generally available GNU C compiler (GCC) or Clang.\n\nYou will need either Flex 2.5.31 or later, or a version of Lex\ncompatible with it (if any exist), to build libpcap.  The configure\nscript will abort if there isn't any such program; CMake fails if Flex\nor Lex cannot be found, but doesn't ensure that it's compatible with\nFlex 2.5.31 or later.  If you have an older version of Flex, or don't\nhave a compatible version of Lex, the current version of Flex is\navailable [here](https://github.com/westes/flex).\n\nYou will need either Bison, Berkeley YACC, or a version of YACC\ncompatible with them (if any exist), to build libpcap.  The configure\nscript will abort if there isn't any such program; CMake fails if Bison\nor some form of YACC cannot be found, but doesn't ensure that it's\ncompatible with Bison or Berkeley YACC.  If you don't have any such\nprogram, the current version of Bison can be found\n[here](https://ftp.gnu.org/gnu/bison/) and the current version of\nBerkeley YACC can be found [here](https://invisible-island.net/byacc/).\n\nSometimes the stock C compiler does not interact well with Flex and\nBison. The list of problems includes undefined references for alloca(3).\nYou can get around this by installing GCC.\n\n## Description of files\n\tCHANGES\t\t    - description of differences between releases\n\tChmodBPF/*\t    - macOS startup item to set ownership and permissions on /dev/bpf*\n\tCMakeLists.txt\t    - CMake file\n\tCONTRIBUTING.md\t    - guidelines for contributing\n\tCREDITS\t\t    - people that have helped libpcap along\n\tINSTALL.md\t    - this file\n\tLICENSE\t\t    - the license under which libpcap is distributed\n\tMakefile.in\t    - compilation rules (input to the configure script)\n\tREADME.md\t    - description of distribution\n\tdoc/README.aix\t    - notes on using libpcap on AIX\n\tdoc/README.dag.md   - notes on using libpcap to capture on Endace DAG devices\n\tdoc/README.haiku.md - notes on using libpcap on Haiku\n\tdoc/README.hpux\t    - notes on using libpcap on HP-UX\n\tdoc/README.hurd.md  - notes on using libpcap on GNU/Hurd\n\tdoc/README.linux    - notes on using libpcap on Linux\n\tdoc/README.macos    - notes on using libpcap on macOS\n\tdoc/README.snf.md   - notes on using libpcap to capture on Myricom SNF devices\n\tdoc/README.solaris.md - notes on using libpcap on Solaris\n\tdoc/README.windows.md - notes on using libpcap on Windows systems (with Npcap)\n\tVERSION\t\t    - version of this release\n\taclocal.m4\t    - autoconf macros\n\tautogen.sh\t    - build configure and config.h.in (run this first)\n\tbpf_dump.c\t    - BPF program printing routines\n\tbpf_filter.c\t    - BPF filtering routines\n\tbpf_image.c\t    - BPF disassembly routine\n\tcharconv.c\t    - Windows Unicode routines\n\tcharconv.h\t    - Windows Unicode prototypes\n\tconfig.guess\t    - autoconf support\n\tconfig.sub\t    - autoconf support\n\tconfigure.ac\t    - configure script source\n\tdiag-control.h\t    - compiler diagnostics control macros\n\tdlpisubs.c\t    - DLPI-related functions for pcap-dlpi.c and pcap-libdlpi.c\n\tdlpisubs.h\t    - DLPI-related function declarations\n\tetherent.c\t    - /etc/ethers support routines\n\textract.h\t    - Alignment definitions\n\tethertype.h\t    - Ethernet protocol types and names definitions\n\tfad-getad.c\t    - pcap_findalldevs() for systems with getifaddrs()\n\tfad-gifc.c\t    - pcap_findalldevs() for systems with only SIOCGIFLIST\n\tfad-glifc.c\t    - pcap_findalldevs() for systems with SIOCGLIFCONF\n\tfmtutils.c\t    - error message formatting routines\n\tfmtutils.h\t    - error message formatting prototypes\n\tftmacros.h\t    - feature test macros\n\ttestprogs/filtertest.c      - test program for BPF compiler\n\ttestprogs/findalldevstest.c - test program for pcap_findalldevs()\n\tgencode.c\t    - BPF code generation routines\n\tgencode.h\t    - BPF code generation definitions\n\tgrammar.y\t    - filter string grammar\n\tieee80211.h\t    - 802.11 definitions\n\tinstall-sh\t    - BSD style install script\n\tinstrument-functions.c - functions instrumentation calls for entry/exit\n\tlbl/os-*.h\t    - OS-dependent defines and prototypes (if any)\n\tllc.h\t\t    - 802.2 LLC SAP definitions\n\tmissing/*\t    - replacements for missing library functions\n\tmkdep\t\t    - construct Makefile dependency list\n\tnametoaddr.c\t    - hostname to address routines\n\tnametoaddr.h\t    - hostname to address prototypes\n\toptimize.c\t    - BPF optimization routines\n\toptimize.h\t    - BPF optimization prototypes\n\tpcap/bluetooth.h    - public definition of DLT_BLUETOOTH_HCI_H4_WITH_PHDR header\n\tpcap/bpf.h\t    - BPF definitions\n\tpcap/can_socketcan.h - SocketCAN header\n\tpcap/compiler-tests.h - compiler version comparison and other macros\n\tpcap/dlt.h\t    - Link-layer header type codes.\n\tpcap/funcattrs.h    - function attribute macros\n\tpcap/ipnet.h\t    - Solaris IPnet definitions\n\tpcap/namedb.h\t    - public libpcap name database definitions\n\tpcap/nflog.h\t    - NFLOG-related definitions\n\tpcap/pcap.h\t    - public libpcap definitions\n\tpcap/pcap-inttypes.h - header for OS-specific integer type includes\n\tpcap/sll.h\t    - public definitions of DLT_LINUX_SLL and DLT_LINUX_SLL2 headers\n\tpcap/socket.h\t    - IP sockets support for various OSes\n\tpcap/usb.h\t    - public definition of DLT_USB header\n\tpcap/vlan.h\t    - VLAN-specific definitions\n\tpcap-bpf.c\t    - BSD Packet Filter support\n\tpcap-bpf.h\t    - header for backwards compatibility\n\tpcap-bt-linux.c\t    - Bluetooth capture support for Linux\n\tpcap-bt-linux.h\t    - Bluetooth capture support for Linux\n\tpcap-bt-monitor-linux.c - Bluetooth monitor capture support for Linux\n\tpcap-bt-monitor-linux.h - Bluetooth monitor capture support for Linux\n\tpcap-common.c\t    - common code for pcap and pcapng files\n\tpcap-common.h\t    - common code for pcap and pcapng files\n\tpcap-dag.c\t    - Endace DAG device capture support\n\tpcap-dag.h\t    - Endace DAG device capture support\n\tpcap-dbus.c\t    - D-Bus capture support\n\tpcap-dbus.h\t    - D-Bus capture support\n\tpcap-dlpi.c\t    - Data Link Provider Interface support\n\tpcap-dpdk.c\t    - DPDK device support\n\tpcap-dpdk.h\t    - DPDK device support\n\tpcap-haiku.c\t    - Haiku capture support\n\tpcap-hurd.c\t    - GNU Hurd support\n\tpcap-int.h\t    - internal libpcap definitions\n\tpcap-libdlpi.c\t    - Data Link Provider Interface support for systems with libdlpi\n\tpcap-linux.c\t    - Linux packet socket support\n\tpcap-namedb.h\t    - header for backwards compatibility\n\tpcap-netfilter-linux.c - Linux netfilter support\n\tpcap-netfilter-linux.h - Linux netfilter support\n\tpcap-netmap.c\t    - netmap support\n\tpcap-netmap.h\t    - netmap support\n\tpcap-npf.c\t    - Npcap capture support\n\tpcap-null.c\t    - dummy monitor support (allows offline use of libpcap)\n\tpcap-rdmasniff.c    - RDMA/InfiniBand capture support\n\tpcap-rdmasniff.h    - RDMA/InfiniBand capture support\n\tpcap-rpcap.c\t    - RPCAP protocol capture support\n\tpcap-rpcap.h\t    - RPCAP protocol capture support\n\tpcap-snf.c\t    - Myricom SNF device capture support\n\tpcap-snf.h\t    - Myricom SNF device capture support\n\tpcap-types.h\t    - header for OS-specific type includes\n\tpcap-usb-linux.c    - USB capture support for Linux\n\tpcap-usb-linux.h    - USB capture support for Linux\n\tpcap-usb-linux-common.c - Linux USB common routines\n\tpcap-usb-linux-common.h - Linux USB common prototypes\n\tpcap-util.c\t    - common code for various files\n\tpcap-util.h\t    - common code for various files\n\tpcap.3pcap\t    - manual entry for the library\n\tpcap.c\t\t    - pcap utility routines\n\tpcap.h\t\t    - header for backwards compatibility\n\tpcap_*.3pcap\t    - manual entries for library functions\n\tpcap-filter.manmisc.in   - manual entry for filter syntax\n\tpcap-linktype.manmisc.in - manual entry for link-layer header types\n\tpflog.h\t\t    - header for DLT_PFLOG handling in filter code\n\tportability.h\t    - Portability declarations/definitions\n\tppp.h\t\t    - Point to Point Protocol definitions\n\trpcap-protocol.c    - RPCAP client/server common routines\n\trpcap-protocol.h    - RPCAP client/server common prototypes\n\tsavefile.c\t    - offline support\n\tscanner.l\t    - filter string scanner\n\tsf-pcap.c\t    - routines for .pcap savefiles\n\tsf-pcap.h\t    - prototypes for .pcap savefiles\n\tsf-pcapng.c\t    - routines for .pcapng savefiles\n\tsf-pcapng.h\t    - prototypes for .pcapng savefiles\n\tsockutils.c\t    - socket and name lookup API routines\n\tsockutils.h\t    - socket and name lookup API prototypes\n\tsslutils.c\t    - OpenSSL interface routines\n\tsslutils.h\t    - OpenSSL interface prototypes\n\tthread-local.h\t    - header for some thread-safe support\n\tvarattrs.h\t    - variable attribute macros\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.84765625,
          "content": "License: BSD\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n  3. The names of the authors may not be used to endorse or promote\n     products derived from this software without specific prior\n     written permission.\n\nTHIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n"
        },
        {
          "name": "Makefile-devel-adds",
          "type": "blob",
          "size": 0.603515625,
          "content": "#\n# Auto-regenerate configure script or Makefile when things change.\n# From autoconf.info .  Works best with GNU Make.\n#\n${srcdir}/configure: configure.ac aclocal.m4\n\t(cd ${srcdir} && autoconf)\n\n# autoheader might not change config.h.in, so touch a stamp file.\n${srcdir}/config.h.in: ${srcdir}/stamp-h.in\n${srcdir}/stamp-h.in: configure.ac aclocal.m4\n\t(cd ${srcdir} && autoheader)\n\techo timestamp > ${srcdir}/stamp-h.in\n\nconfig.h: stamp-h\nstamp-h: ${srcdir}/config.h.in config.status\n\t./config.status\n\nMakefile: Makefile.in config.status\n\t./config.status\n\nconfig.status: ${srcdir}/configure\n\t./config.status --recheck\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 27.8330078125,
          "content": "#  Copyright (c) 1993, 1994, 1995, 1996\n#\tThe Regents of the University of California.  All rights reserved.\n#\n#  Redistribution and use in source and binary forms, with or without\n#  modification, are permitted provided that: (1) source code distributions\n#  retain the above copyright notice and this paragraph in its entirety, (2)\n#  distributions including binary code include the above copyright notice and\n#  this paragraph in its entirety in the documentation or other materials\n#  provided with the distribution, and (3) all advertising materials mentioning\n#  features or use of this software display the following acknowledgement:\n#  ``This product includes software developed by the University of California,\n#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n#  the University nor the names of its contributors may be used to endorse\n#  or promote products derived from this software without specific prior\n#  written permission.\n#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n\n#\n# Various configurable paths (remember to edit Makefile.in, not Makefile)\n#\n\n# Top level hierarchy\nprefix = @prefix@\nexec_prefix = @exec_prefix@\ndatarootdir = @datarootdir@\n# Pathname of directory to install the configure program\nbindir = @bindir@\n# Pathname of directory to install the rpcapd daemon\nsbindir = @sbindir@\n# Pathname of directory to install the include files\nincludedir = @includedir@\n# Pathname of directory to install the library\nlibdir =  @libdir@\n# Pathname of directory to install the man pages\nmandir = @mandir@\n\n# VPATH\nsrcdir = @srcdir@\ntop_srcdir = @top_srcdir@\nVPATH = @srcdir@\n\n#\n# You shouldn't need to edit anything below.\n#\n\nLD = /usr/bin/ld\nCC = @CC@\nAR = @AR@\nLN_S = @LN_S@\nMKDEP = @MKDEP@\nCCOPT = @V_CCOPT@\nSHLIB_CCOPT = @V_SHLIB_CCOPT@\nINCLS = -I. @V_INCLS@\nDEFS = -DBUILDING_PCAP -Dpcap_EXPORTS @DEFS@ @V_DEFS@\nADDLOBJS = @ADDLOBJS@\nADDLARCHIVEOBJS = @ADDLARCHIVEOBJS@\nLIBS = @LIBS@\nCROSSFLAGS=\nCFLAGS = @CFLAGS@   ${CROSSFLAGS}\nLDFLAGS = @LDFLAGS@ ${CROSSFLAGS}\nDYEXT = @DYEXT@\nRPATH = @RPATH@\nDEPENDENCY_CFLAG = @DEPENDENCY_CFLAG@\nPROG=libpcap\nPTHREAD_LIBS=@PTHREAD_LIBS@\nBUILD_RPCAPD=@BUILD_RPCAPD@\nINSTALL_RPCAPD=@INSTALL_RPCAPD@\n\n# Standard CFLAGS for building members of a shared library\nFULL_CFLAGS = $(CCOPT) @V_LIB_CCOPT_FAT@ $(SHLIB_CCOPT) $(INCLS) $(DEFS) $(CFLAGS)\n\nINSTALL = @INSTALL@\nINSTALL_PROGRAM = @INSTALL_PROGRAM@\nINSTALL_DATA = @INSTALL_DATA@\nRANLIB = @RANLIB@\n\nLEX = @LEX@\nBISON_BYACC = @BISON_BYACC@\n\n.c.o:\n\t$(CC) $(FULL_CFLAGS) -c -o $@ $<\n\nPLATFORM_C_SRC =\t@PLATFORM_C_SRC@\nMODULE_C_SRC =\t\t@MODULE_C_SRC@\nREMOTE_C_SRC =\t\t@REMOTE_C_SRC@\nCOMMON_C_SRC =\tpcap.c gencode.c optimize.c nametoaddr.c etherent.c \\\n\t\tfmtutils.c pcap-util.c \\\n\t\tsavefile.c sf-pcap.c sf-pcapng.c pcap-common.c \\\n\t\tbpf_image.c bpf_filter.c bpf_dump.c\nGENERATED_C_SRC = scanner.c grammar.c\nLIBOBJS = @LIBOBJS@\n\nSRC =\t$(PLATFORM_C_SRC) \\\n\t$(MODULE_C_SRC) $(REMOTE_C_SRC) $(COMMON_C_SRC) \\\n\t$(GENERATED_C_SRC)\n\nOBJ =\t$(SRC:.c=.o) $(LIBOBJS)\n\nPUBHDR = \\\n\tpcap.h \\\n\tpcap-bpf.h \\\n\tpcap-namedb.h \\\n\tpcap/bluetooth.h \\\n\tpcap/bpf.h \\\n\tpcap/can_socketcan.h \\\n\tpcap/compiler-tests.h \\\n\tpcap/dlt.h \\\n\tpcap/funcattrs.h \\\n\tpcap/ipnet.h \\\n\tpcap/namedb.h \\\n\tpcap/nflog.h \\\n\tpcap/pcap-inttypes.h \\\n\tpcap/pcap.h \\\n\tpcap/sll.h \\\n\tpcap/socket.h \\\n\tpcap/usb.h \\\n\tpcap/vlan.h\n\nHDR = $(PUBHDR) \\\n\tdiag-control.h \\\n\tethertype.h \\\n\textract.h \\\n\tfmtutils.h \\\n\tftmacros.h \\\n\tgencode.h \\\n\tieee80211.h \\\n\tllc.h \\\n\tnametoaddr.h \\\n\toptimize.h \\\n\tpcap-common.h \\\n\tpcap-int.h \\\n\tpcap-rpcap.h \\\n\tpcap-types.h \\\n\tpcap-usb-linux-common.h \\\n\tpcap-util.h \\\n\tpflog.h \\\n\tportability.h \\\n\tppp.h \\\n\trpcap-protocol.h \\\n\tsf-pcap.h \\\n\tsf-pcapng.h \\\n\tthread-local.h \\\n\tvarattrs.h\n\nGENHDR = \\\n\tscanner.h grammar.h\n\nTAGFILES = \\\n\t$(SRC) $(HDR)\n\nCLEANFILES = $(OBJ) libpcap.a libpcap.so.`cat $(srcdir)/VERSION` \\\n\t$(PROG)-`cat $(srcdir)/VERSION`.tar.gz $(GENERATED_C_SRC) $(GENHDR) \\\n\tlex.yy.c pcap-config libpcap.pc libpcap.$(DYEXT)\n\nMAN1 = pcap-config.1\n\nMAN3PCAP_EXPAND = \\\n\tpcap.3pcap.in \\\n\tpcap_compile.3pcap.in \\\n\tpcap_datalink.3pcap.in \\\n\tpcap_dump_open.3pcap.in \\\n\tpcap_get_tstamp_precision.3pcap.in \\\n\tpcap_list_datalinks.3pcap.in \\\n\tpcap_list_tstamp_types.3pcap.in \\\n\tpcap_open_dead.3pcap.in \\\n\tpcap_open_offline.3pcap.in \\\n\tpcap_set_immediate_mode.3pcap.in \\\n\tpcap_set_tstamp_precision.3pcap.in \\\n\tpcap_set_tstamp_type.3pcap.in\n\nMAN3PCAP_NOEXPAND = \\\n\tpcap_activate.3pcap \\\n\tpcap_breakloop.3pcap \\\n\tpcap_can_set_rfmon.3pcap \\\n\tpcap_close.3pcap \\\n\tpcap_create.3pcap \\\n\tpcap_datalink_name_to_val.3pcap \\\n\tpcap_datalink_val_to_name.3pcap \\\n\tpcap_dump.3pcap \\\n\tpcap_dump_close.3pcap \\\n\tpcap_dump_file.3pcap \\\n\tpcap_dump_flush.3pcap \\\n\tpcap_dump_ftell.3pcap \\\n\tpcap_file.3pcap \\\n\tpcap_fileno.3pcap \\\n\tpcap_findalldevs.3pcap \\\n\tpcap_freecode.3pcap \\\n\tpcap_get_required_select_timeout.3pcap \\\n\tpcap_get_selectable_fd.3pcap \\\n\tpcap_geterr.3pcap \\\n\tpcap_init.3pcap \\\n\tpcap_inject.3pcap \\\n\tpcap_is_swapped.3pcap \\\n\tpcap_lib_version.3pcap \\\n\tpcap_lookupdev.3pcap \\\n\tpcap_lookupnet.3pcap \\\n\tpcap_loop.3pcap \\\n\tpcap_major_version.3pcap \\\n\tpcap_next_ex.3pcap \\\n\tpcap_offline_filter.3pcap \\\n\tpcap_open_live.3pcap \\\n\tpcap_set_buffer_size.3pcap \\\n\tpcap_set_datalink.3pcap \\\n\tpcap_set_promisc.3pcap \\\n\tpcap_set_protocol_linux.3pcap \\\n\tpcap_set_rfmon.3pcap \\\n\tpcap_set_snaplen.3pcap \\\n\tpcap_set_timeout.3pcap \\\n\tpcap_setdirection.3pcap \\\n\tpcap_setfilter.3pcap \\\n\tpcap_setnonblock.3pcap \\\n\tpcap_snapshot.3pcap \\\n\tpcap_stats.3pcap \\\n\tpcap_statustostr.3pcap \\\n\tpcap_strerror.3pcap \\\n\tpcap_tstamp_type_name_to_val.3pcap \\\n\tpcap_tstamp_type_val_to_name.3pcap\n\nMAN3PCAP = $(MAN3PCAP_NOEXPAND) $(MAN3PCAP_EXPAND:.in=)\n\nMANFILE = \\\n\tcbpf-savefile.manfile.in \\\n\tpcap-savefile.manfile.in\n\nMANMISC = \\\n\tpcap-filter.manmisc.in \\\n\tpcap-linktype.manmisc.in \\\n\tpcap-tstamp.manmisc.in\n\nEXTRA_DIST = \\\n\tCHANGES \\\n\tChmodBPF/ChmodBPF \\\n\tChmodBPF/StartupParameters.plist \\\n\tCREDITS \\\n\tCMakeLists.txt \\\n\tINSTALL.md \\\n\tLICENSE \\\n\tMakefile.in \\\n\tMakefile-devel-adds \\\n\tREADME.md \\\n\tdoc/README.aix \\\n\tdoc/README.dag.md \\\n\tdoc/README.haiku.md \\\n\tdoc/README.hpux \\\n\tdoc/README.hurd.md \\\n\tdoc/README.linux \\\n\tdoc/README.macos \\\n\tdoc/README.snf.md \\\n\tdoc/README.solaris.md \\\n\tdoc/README.windows.md \\\n\tCONTRIBUTING.md \\\n\tVERSION \\\n\taclocal.m4 \\\n\tautogen.sh \\\n\tcharconv.c \\\n\tcharconv.h \\\n\tchmod_bpf \\\n\tcmake_uninstall.cmake.in \\\n\tcmakeconfig.h.in \\\n\tcmake/Modules/FindDAG.cmake \\\n\tcmake/Modules/Finddpdk.cmake \\\n\tcmake/Modules/FindFseeko.cmake \\\n\tcmake/Modules/FindLFS.cmake \\\n\tcmake/Modules/FindPacket.cmake \\\n\tcmake/Modules/FindSNF.cmake \\\n\tcmake/have_siocglifconf.c \\\n\tconfig.guess \\\n\tconfig.sub \\\n\tconfigure.ac \\\n\tdlpisubs.c \\\n\tdlpisubs.h \\\n\tfad-getad.c \\\n\tfad-gifc.c \\\n\tfad-glifc.c \\\n\tgrammar.y.in \\\n\tinstall-sh \\\n\tinstrument-functions.c \\\n\tlibpcap.pc.in \\\n\tmissing/asprintf.c \\\n\tmissing/getopt.c \\\n\tmissing/getopt.h \\\n\tmissing/strlcat.c \\\n\tmissing/strlcpy.c \\\n\tmissing/strtok_r.c \\\n\tmissing/win_asprintf.c \\\n\tmkdep \\\n\tnomkdep \\\n\torg.tcpdump.chmod_bpf.plist \\\n\tpcap-bpf.c \\\n\tpcap-bt-linux.c \\\n\tpcap-bt-linux.h \\\n\tpcap-bt-monitor-linux.c \\\n\tpcap-bt-monitor-linux.h \\\n\tpcap-config.in \\\n\tpcap-dag.c \\\n\tpcap-dag.h \\\n\tpcap-dbus.c \\\n\tpcap-dbus.h \\\n\tpcap-dll.rc \\\n\tpcap-dlpi.c \\\n\tpcap-dpdk.c \\\n\tpcap-dpdk.h \\\n\tpcap-haiku.c \\\n\tpcap-hurd.c \\\n\tpcap-int.h \\\n\tpcap-libdlpi.c \\\n\tpcap-linux.c \\\n\tpcap-namedb.h \\\n\tpcap-netfilter-linux.c \\\n\tpcap-netfilter-linux.h \\\n\tpcap-netmap.c \\\n\tpcap-netmap.h \\\n\tpcap-npf.c \\\n\tpcap-null.c \\\n\tpcap-rdmasniff.c \\\n\tpcap-rdmasniff.h \\\n\tpcap-rpcap.c \\\n\tpcap-snf.c \\\n\tpcap-snf.h \\\n\tpcap-usb-linux.c \\\n\tpcap-usb-linux.h \\\n\trpcap-protocol.c \\\n\trpcapd/CMakeLists.txt \\\n\trpcapd/Makefile.in \\\n\trpcapd/config_params.h \\\n\trpcapd/daemon.h \\\n\trpcapd/daemon.c \\\n\trpcapd/fileconf.c \\\n\trpcapd/fileconf.h \\\n\trpcapd/log.h \\\n\trpcapd/log.c \\\n\trpcapd/org.tcpdump.rpcapd.plist \\\n\trpcapd/rpcapd.c \\\n\trpcapd/rpcapd.h \\\n\trpcapd/rpcapd.inetd.conf \\\n\trpcapd/rpcapd.manadmin.in \\\n\trpcapd/rpcapd-config.manfile.in \\\n\trpcapd/rpcapd.rc \\\n\trpcapd/rpcapd.socket \\\n\trpcapd/rpcapd.xinetd.conf \\\n\trpcapd/rpcapd@.service \\\n\trpcapd/win32-svc.c \\\n\trpcapd/win32-svc.h \\\n\tsockutils.c \\\n\tsockutils.h \\\n\tsslutils.c \\\n\tsslutils.h \\\n\tscanner.l \\\n\ttestprogs/CMakeLists.txt \\\n\ttestprogs/Makefile.in \\\n\ttestprogs/activatetest.c \\\n\ttestprogs/can_set_rfmon_test.c \\\n\ttestprogs/capturetest.c \\\n\ttestprogs/filtertest.c \\\n\ttestprogs/findalldevstest.c \\\n\ttestprogs/findalldevstest-perf.c \\\n\ttestprogs/fuzz/CMakeLists.txt \\\n\ttestprogs/fuzz/fuzz_both.c \\\n\ttestprogs/fuzz/fuzz_both.options \\\n\ttestprogs/fuzz/fuzz_filter.c \\\n\ttestprogs/fuzz/fuzz_filter.options \\\n\ttestprogs/fuzz/fuzz_pcap.c \\\n\ttestprogs/fuzz/fuzz_pcap.options \\\n\ttestprogs/fuzz/onefile.c \\\n\ttestprogs/nonblocktest.c \\\n\ttestprogs/opentest.c \\\n\ttestprogs/reactivatetest.c \\\n\ttestprogs/selpolltest.c \\\n\ttestprogs/threadsignaltest.c \\\n\ttestprogs/unix.h \\\n\ttestprogs/valgrindtest.c \\\n\ttestprogs/visopts.py \\\n\ttestprogs/writecaptest.c\n\nTEST_DIST = `git -C \"$$DIR\" ls-files tests | grep -v 'tests/\\..*'`\n\nRELEASE_FILES = $(COMMON_C_SRC) $(HDR) $(MAN1) $(MAN3PCAP_EXPAND) \\\n\t$(MAN3PCAP_NOEXPAND) $(MANFILE) $(MANMISC) $(EXTRA_DIST) \\\n\t$(TEST_DIST)\n\nall: libpcap.a shared $(BUILD_RPCAPD) libpcap.pc pcap-config\n\nlibpcap.a: $(OBJ)\n\t@rm -f $@\n\t$(AR) rc $@ $(OBJ) $(ADDLARCHIVEOBJS)\n\t$(RANLIB) $@\n\nshared: libpcap.$(DYEXT)\n\nlibpcap.so: $(OBJ)\n\t@rm -f $@\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\t@V_SHLIB_CMD@ $(LDFLAGS) @V_SHLIB_OPT@ @V_SONAME_OPT@$@.$$MAJOR_VER \\\n\t    -o $@.$$VER $(OBJ) $(ADDLOBJS) $(LIBS)\n\n#\n# The following rule succeeds, but the result is untested.\n#\n# In macOS, the libpcap dylib has the name \"libpcap.A.dylib\", with its\n# full path as the install_name, and with the compatibility and current\n# version both set to 1.  The compatibility version is set to 1 so that\n# programs built with a newer version of the library will run against\n# older versions if they don't use APIs available in the newer version\n# but not in the older version.\n#\n# We also use \"A\" as the major version, and 1 as the compatibility version,\n# but set the current version to the value in VERSION, with any non-numeric\n# stuff stripped off (the compatibility and current version must be of the\n# form X[.Y[.Z]], with Y and Z possibly absent, and with all components\n# numeric).\n#\nlibpcap.dylib: $(OBJ)\n\trm -f libpcap*.dylib\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=A; \\\n\tCOMPAT_VER=1; \\\n\tCURRENT_VER=`sed 's/[^0-9.].*$$//' $(srcdir)/VERSION`; \\\n\t$(CC) -dynamiclib -undefined error $(LDFLAGS) @V_LIB_LDFLAGS_FAT@ \\\n\t    -o libpcap.$$VER.dylib $(OBJ) $(ADDLOBJS) $(LIBS) \\\n\t    -install_name $(libdir)/libpcap.$$MAJOR_VER.dylib \\\n\t    -compatibility_version $$COMPAT_VER \\\n\t    -current_version $$CURRENT_VER\n\n#\n# The HP-UX linker manual says that the convention for a versioned library\n# is libXXX.{number}, not libXXX.sl.{number}.  That appears to be the case\n# on at least one HP-UX 11.00 system; libXXX.sl is a symlink to\n# libXXX.{number}.\n#\n# The manual also says \"library-level versioning\" (think \"sonames\") was\n# added in HP-UX 10.0.\n#\n# XXX - this assumes we're using the HP linker, rather than the GNU\n# linker, even with GCC.\n#\nlibpcap.sl: $(OBJ)\n\t@MAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\trm -f libpcap.$$MAJOR_VER\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\tld -b $(LDFLAGS) -o libpcap.$$MAJOR_VER +h libpcap.$$MAJOR_VER \\\n\t    $(OBJ) $(ADDLOBJS) $(LIBS)\n\n#\n# AIX is different from everybody else.  A shared library is an archive\n# library with one or more shared-object components.  We still build a\n# normal static archive library on AIX, for the benefit of the traditional\n# scheme of building libpcap and tcpdump in subdirectories of the\n# same directory, with tcpdump statically linked with the libpcap\n# in question, but we also build a shared library as \"libpcap.shareda\"\n# and install *it*, rather than the static library, as \"libpcap.a\".\n#\nlibpcap.shareda: $(OBJ)\n\t@rm -f $@ shr.o\n\t$(CC) $(LDFLAGS) @V_SHLIB_OPT@ -o shr.o $(OBJ) $(ADDLOBJS) $(LIBS)\n\t$(AR) rc $@ shr.o\n\n#\n# For platforms that don't support shared libraries (or on which we\n# don't support shared libraries).\n#\nlibpcap.none:\n\nscanner.c: $(srcdir)/scanner.l\n\t$(LEX) -P pcap_ --header-file=scanner.h --nounput -o scanner.c $<\nscanner.h: scanner.c\n## Recover from the removal of $@\n\t@if test -f $@; then :; else \\\n\t\trm -f scanner.c; \\\n\t\t$(MAKE) $(MAKEFLAGS) scanner.c; \\\n\tfi\n\nscanner.o: scanner.c grammar.h\n\t$(CC) $(FULL_CFLAGS) -c scanner.c\n\n#\n# Generate the grammar.y file.\n#\n# Some Makes, e.g. AIX Make and Solaris Make, can't handle \"--file=$@.tmp:$<\";\n# for example, the Solaris 9 make man page says\n#\n#\tBecause make assigns $< and $* as it would for implicit rules\n#\t(according to the suffixes list and the directory contents),\n#\tthey may be unreliable when used within explicit target entries.\n#\n# and this is an explicit target entry.\n#\n# Therefore, instead of using $<, we explicitly put in $(srcdir)/grammar.y.in.\n#\ngrammar.y: $(srcdir)/grammar.y.in ./config.status\n\t@rm -f $@ $@.tmp\n\t./config.status --file=$@.tmp:$(srcdir)/grammar.y.in\n\tmv $@.tmp $@\n\ngrammar.c: grammar.y\n\t$(BISON_BYACC) -p pcap_ -o grammar.c -d $<\ngrammar.h: grammar.c\n## Recover from the removal of $@\n\t@if test -f $@; then :; else \\\n\t\trm -f grammar.c; \\\n\t\t$(MAKE) $(MAKEFLAGS) grammar.c; \\\n\tfi\n\ngrammar.o: grammar.c scanner.h\n\t$(CC) $(FULL_CFLAGS) -c grammar.c\n\ngencode.o: $(srcdir)/gencode.c grammar.h scanner.h\n\t$(CC) $(FULL_CFLAGS) -c $(srcdir)/gencode.c\n\nasprintf.o: $(srcdir)/missing/asprintf.c\n\t$(CC) $(FULL_CFLAGS) -o $@ -c $(srcdir)/missing/asprintf.c\n\nstrlcat.o: $(srcdir)/missing/strlcat.c\n\t$(CC) $(FULL_CFLAGS) -o $@ -c $(srcdir)/missing/strlcat.c\n\nstrlcpy.o: $(srcdir)/missing/strlcpy.c\n\t$(CC) $(FULL_CFLAGS) -o $@ -c $(srcdir)/missing/strlcpy.c\n\nstrtok_r.o: $(srcdir)/missing/strtok_r.c\n\t$(CC) $(FULL_CFLAGS) -o $@ -c $(srcdir)/missing/strtok_r.c\n\n#\n# Generate the libpcap.pc file.\n#\n# Some Makes, e.g. AIX Make and Solaris Make, can't handle \"--file=$@.tmp:$<\";\n# for example, the Solaris 9 make man page says\n#\n#\tBecause make assigns $< and $* as it would for implicit rules\n#\t(according to the suffixes list and the directory contents),\n#\tthey may be unreliable when used within explicit target entries.\n#\n# and this is an explicit target entry.\n#\n# Therefore, instead of using $<, we explicitly put in $(srcdir)/libpcap.pc.in.\n#\nlibpcap.pc: $(srcdir)/libpcap.pc.in ./config.status\n\t@rm -f $@ $@.tmp\n\t./config.status --file=$@.tmp:$(srcdir)/libpcap.pc.in\n\tmv $@.tmp $@\n\n#\n# Generate the pcap-config script.  See above.\n#\npcap-config: $(srcdir)/pcap-config.in ./config.status\n\t@rm -f $@ $@.tmp\n\t./config.status --file=$@.tmp:$(srcdir)/pcap-config.in\n\tmv $@.tmp $@\n\tchmod a+x $@\n\n#\n# Remote pcap daemon.\n#\nbuild-rpcapd: libpcap.a\n\t(cd rpcapd; $(MAKE))\n\n#\n# Test programs - not built by default, and not installed.\n#\ntestprogs: FORCE libpcap.a\n\t(cd testprogs; $(MAKE) CFLAGS=\"$(CFLAGS)\")\n\nFORCE:\n\ninstall: install-shared install-archive libpcap.pc pcap-config @INSTALL_RPCAPD@\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\t[ -d $(DESTDIR)$(includedir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(includedir); chmod 755 $(DESTDIR)$(includedir))\n\t[ -d $(DESTDIR)$(includedir)/pcap ] || \\\n\t    (mkdir -p $(DESTDIR)$(includedir)/pcap; chmod 755 $(DESTDIR)$(includedir)/pcap)\n\t[ -d $(DESTDIR)$(mandir)/man1 ] || \\\n\t    (mkdir -p $(DESTDIR)$(mandir)/man1; chmod 755 $(DESTDIR)$(mandir)/man1)\n\t[ -d $(DESTDIR)$(mandir)/man3 ] || \\\n\t    (mkdir -p $(DESTDIR)$(mandir)/man3; chmod 755 $(DESTDIR)$(mandir)/man3)\n\t[ -d $(DESTDIR)$(mandir)/man@MAN_FILE_FORMATS@ ] || \\\n\t    (mkdir -p $(DESTDIR)$(mandir)/man@MAN_FILE_FORMATS@; chmod 755 $(DESTDIR)$(mandir)/man@MAN_FILE_FORMATS@)\n\t[ -d $(DESTDIR)$(mandir)/man@MAN_MISC_INFO@ ] || \\\n\t    (mkdir -p $(DESTDIR)$(mandir)/man@MAN_MISC_INFO@; chmod 755 $(DESTDIR)$(mandir)/man@MAN_MISC_INFO@)\n\tfor i in $(PUBHDR); do \\\n\t\t$(INSTALL_DATA) $(srcdir)/$$i \\\n\t\t    $(DESTDIR)$(includedir)/$$i; done\n\t[ -d $(DESTDIR)$(bindir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(bindir); chmod 755 $(DESTDIR)$(bindir))\n\t$(INSTALL_PROGRAM) pcap-config $(DESTDIR)$(bindir)/pcap-config\n\t[ -d $(DESTDIR)$(libdir)/pkgconfig ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir)/pkgconfig; chmod 755 $(DESTDIR)$(libdir)/pkgconfig)\n\t$(INSTALL_DATA) libpcap.pc $(DESTDIR)$(libdir)/pkgconfig/libpcap.pc\n\tfor i in $(MAN1); do \\\n\t\t$(INSTALL_DATA) $(srcdir)/$$i \\\n\t\t    $(DESTDIR)$(mandir)/man1/$$i; done\n\tfor i in $(MAN3PCAP_NOEXPAND); do \\\n\t\t$(INSTALL_DATA) $(srcdir)/$$i \\\n\t\t    $(DESTDIR)$(mandir)/man3/$$i; done\n\tfor i in $(MAN3PCAP_EXPAND:.in=); do \\\n\t\t$(INSTALL_DATA) $$i \\\n\t\t    $(DESTDIR)$(mandir)/man3/$$i; done\n\t(cd $(DESTDIR)$(mandir)/man3 && \\\n\trm -f pcap_datalink_val_to_description.3pcap && \\\n\t$(LN_S) pcap_datalink_val_to_name.3pcap \\\n\t\t pcap_datalink_val_to_description.3pcap && \\\n\trm -f pcap_datalink_val_to_description_or_dlt.3pcap && \\\n\t$(LN_S) pcap_datalink_val_to_name.3pcap \\\n\t\t pcap_datalink_val_to_description_or_dlt.3pcap && \\\n\trm -f pcap_dump_fopen.3pcap && \\\n\t$(LN_S) pcap_dump_open.3pcap pcap_dump_fopen.3pcap && \\\n\trm -f pcap_freealldevs.3pcap && \\\n\t$(LN_S) pcap_findalldevs.3pcap pcap_freealldevs.3pcap && \\\n\trm -f pcap_perror.3pcap && \\\n\t$(LN_S) pcap_geterr.3pcap pcap_perror.3pcap && \\\n\trm -f pcap_sendpacket.3pcap && \\\n\t$(LN_S) pcap_inject.3pcap pcap_sendpacket.3pcap && \\\n\trm -f pcap_free_datalinks.3pcap && \\\n\t$(LN_S) pcap_list_datalinks.3pcap pcap_free_datalinks.3pcap && \\\n\trm -f pcap_free_tstamp_types.3pcap && \\\n\t$(LN_S) pcap_list_tstamp_types.3pcap pcap_free_tstamp_types.3pcap && \\\n\trm -f pcap_dispatch.3pcap && \\\n\t$(LN_S) pcap_loop.3pcap pcap_dispatch.3pcap && \\\n\trm -f pcap_minor_version.3pcap && \\\n\t$(LN_S) pcap_major_version.3pcap pcap_minor_version.3pcap && \\\n\trm -f pcap_next.3pcap && \\\n\t$(LN_S) pcap_next_ex.3pcap pcap_next.3pcap && \\\n\trm -f pcap_open_dead_with_tstamp_precision.3pcap && \\\n\t$(LN_S) pcap_open_dead.3pcap \\\n\t\t pcap_open_dead_with_tstamp_precision.3pcap && \\\n\trm -f pcap_open_offline_with_tstamp_precision.3pcap && \\\n\t$(LN_S) pcap_open_offline.3pcap pcap_open_offline_with_tstamp_precision.3pcap && \\\n\trm -f pcap_fopen_offline.3pcap && \\\n\t$(LN_S) pcap_open_offline.3pcap pcap_fopen_offline.3pcap && \\\n\trm -f pcap_fopen_offline_with_tstamp_precision.3pcap && \\\n\t$(LN_S) pcap_open_offline.3pcap pcap_fopen_offline_with_tstamp_precision.3pcap && \\\n\trm -f pcap_tstamp_type_val_to_description.3pcap && \\\n\t$(LN_S) pcap_tstamp_type_val_to_name.3pcap pcap_tstamp_type_val_to_description.3pcap && \\\n\trm -f pcap_getnonblock.3pcap && \\\n\t$(LN_S) pcap_setnonblock.3pcap pcap_getnonblock.3pcap)\n\tfor i in $(MANFILE); do \\\n\t\t$(INSTALL_DATA) `echo $$i | sed 's/.manfile.in/.manfile/'` \\\n\t\t    $(DESTDIR)$(mandir)/man@MAN_FILE_FORMATS@/`echo $$i | sed 's/.manfile.in/.@MAN_FILE_FORMATS@/'`; done\n\tfor i in $(MANMISC); do \\\n\t\t$(INSTALL_DATA) `echo $$i | sed 's/.manmisc.in/.manmisc/'` \\\n\t\t    $(DESTDIR)$(mandir)/man@MAN_MISC_INFO@/`echo $$i | sed 's/.manmisc.in/.@MAN_MISC_INFO@/'`; done\n\ninstall-shared: install-shared-$(DYEXT)\ninstall-shared-so: libpcap.so\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\t$(INSTALL_PROGRAM) libpcap.so.$$VER $(DESTDIR)$(libdir)/libpcap.so.$$VER; \\\n\tln -sf libpcap.so.$$VER $(DESTDIR)$(libdir)/libpcap.so.$$MAJOR_VER; \\\n\tln -sf libpcap.so.$$MAJOR_VER $(DESTDIR)$(libdir)/libpcap.so\ninstall-shared-dylib: libpcap.dylib\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=A; \\\n\t$(INSTALL_PROGRAM) libpcap.$$VER.dylib $(DESTDIR)$(libdir)/libpcap.$$VER.dylib; \\\n\tln -sf libpcap.$$VER.dylib $(DESTDIR)$(libdir)/libpcap.$$MAJOR_VER.dylib; \\\n\tln -sf libpcap.$$MAJOR_VER.dylib $(DESTDIR)$(libdir)/libpcap.dylib\ninstall-shared-sl: libpcap.sl\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\t$(INSTALL_PROGRAM) libpcap.$$MAJOR_VER $(DESTDIR)$(libdir)\n\tln -sf libpcap.$$MAJOR_VER $(DESTDIR)$(libdir)/libpcap.sl\n#\n# AIX shared libraries are weird.  They're archive libraries\n# with one or more shared object components.\n#\ninstall-shared-shareda: libpcap.shareda\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\t$(INSTALL_PROGRAM) libpcap.shareda $(DESTDIR)$(libdir)/libpcap.a\ninstall-shared-none:\n\ninstall-archive: install-archive-$(DYEXT)\n#\n# Most platforms have separate suffixes for shared and\n# archive libraries, so we install both.\n#\ninstall-archive-so install-archive-dylib install-archive-sl install-archive-none: libpcap.a\n\t[ -d $(DESTDIR)$(libdir) ] || \\\n\t    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))\n\t$(INSTALL_DATA) libpcap.a $(DESTDIR)$(libdir)/libpcap.a\n\t$(RANLIB) $(DESTDIR)$(libdir)/libpcap.a\n#\n# AIX, however, doesn't, so we don't install the archive\n# library on AIX.\n#\ninstall-archive-shareda:\n\ninstall-rpcapd:\n\t(cd rpcapd; $(MAKE) DESTDIR=$(DESTDIR) install)\n\nuninstall: uninstall-shared uninstall-rpcapd\n\trm -f $(DESTDIR)$(libdir)/libpcap.a\n\tfor i in $(PUBHDR); do \\\n\t\trm -f $(DESTDIR)$(includedir)/$$i; done\n\t-rmdir $(DESTDIR)$(includedir)/pcap\n\trm -f $(DESTDIR)/$(libdir)/pkgconfig/libpcap.pc\n\trm -f $(DESTDIR)/$(bindir)/pcap-config\n\tfor i in $(MAN1); do \\\n\t\trm -f $(DESTDIR)$(mandir)/man1/$$i; done\n\tfor i in $(MAN3PCAP); do \\\n\t\trm -f $(DESTDIR)$(mandir)/man3/$$i; done\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_datalink_val_to_description.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_datalink_val_to_description_or_dlt.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_dump_fopen.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_freealldevs.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_perror.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_sendpacket.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_free_datalinks.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_free_tstamp_types.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_dispatch.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_minor_version.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_next.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_open_dead_with_tstamp_precision.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_open_offline_with_tstamp_precision.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_fopen_offline.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_fopen_offline_with_tstamp_precision.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_getnonblock.3pcap\n\trm -f $(DESTDIR)$(mandir)/man3/pcap_tstamp_type_val_to_description.3pcap\n\tfor i in $(MANFILE); do \\\n\t\trm -f $(DESTDIR)$(mandir)/man@MAN_FILE_FORMATS@/`echo $$i | sed 's/.manfile.in/.@MAN_FILE_FORMATS@/'`; done\n\tfor i in $(MANMISC); do \\\n\t\trm -f $(DESTDIR)$(mandir)/man@MAN_MISC_INFO@/`echo $$i | sed 's/.manmisc.in/.@MAN_MISC_INFO@/'`; done\n\nuninstall-shared: uninstall-shared-$(DYEXT)\nuninstall-shared-so:\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.so.$$VER; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.so.$$MAJOR_VER; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.so\nuninstall-shared-dylib:\n\tVER=`cat $(srcdir)/VERSION`; \\\n\tMAJOR_VER=A; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.$$VER.dylib; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.$$MAJOR_VER.dylib; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.dylib\nuninstall-shared-sl:\n\tMAJOR_VER=`sed 's/\\([0-9][0-9]*\\)\\..*/\\1/' $(srcdir)/VERSION`; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.$$MAJOR_VER; \\\n\trm -f $(DESTDIR)$(libdir)/libpcap.sl\nuninstall-shared-shareda:\n\trm -f $(DESTDIR)$(libdir)/libpcap.a\nuninstall-shared-none:\n\nuninstall-rpcapd:\n\t(cd rpcapd; $(MAKE) DESTDIR=$(DESTDIR) uninstall)\n\nclean:\n\trm -f $(CLEANFILES) config.h.in~ configure~ configure.ac~\n\t(cd rpcapd; $(MAKE) clean)\n\t(cd testprogs; $(MAKE) clean)\n\ndistclean: clean\n\trm -f Makefile grammar.y config.cache config.log config.status \\\n\t    config.h os-proto.h libpcap.pc pcap-config stamp-h stamp-h.in\n\trm -f $(MAN3PCAP_EXPAND:.in=) $(MANFILE:.in=) $(MANMISC:.in=)\n\trm -rf autom4te.cache\n\t(cd rpcapd; $(MAKE) distclean)\n\t(cd testprogs; $(MAKE) distclean)\n\ncheck: testprogs\n\t$(srcdir)/testprogs/TESTrun\n\nextags: $(TAGFILES)\n\tctags $(TAGFILES)\n\ntags: $(TAGFILES)\n\tctags -wtd $(TAGFILES)\n\n#\n# Use git archive piped to tar to construct a subdirectory whose name\n# is libpcap-{release}, containing all the checked-in source files,\n# and then run autoreconf in that directory to generate the configure\n# script and other files from that source. Then remove autom4te.cache,\n# construct the release tarball from that subdirectory, and remove\n# the subdirectory.\n#\n# The --format=tar is to force git archive to write a non-compressed\n# archive, in case the platform's tar command doesn't have built-in\n# decompression.\n#\n# The ^{tree} is there to force git archive not to write out the\n# \"helpful\" global extended pax header with a commit ID, as not all\n# versions of tar can handle that (Solaris tar can't, for example).\n# (It turns HEAD, or a tag, both of which are apparently \"tree-ish\"es,\n# into a tree; apparently, unlike HEAD, or a tag, which have a commit\n# ID associated with them, the tree associated with them doesn't have\n# a commit ID, so no commit ID is available to write, and thus\n# git archive doesn't write one.)\n#\nreleasetar:\n\t@TAG=$(PROG)-`cat VERSION` && \\\n\tif [ ! -d .git ]; then echo 'Not in a git clone, stop.'; exit 1; fi && \\\n\tTMPTESTFILE=`mktemp -t tmptestfile_XXXXXXXX` && \\\n\trm -f \"$$TMPTESTFILE\" && \\\n\tAUTORECONF_DIR=`dirname \"$$TMPTESTFILE\"`/\"$(PROG)\"_build_autoreconf_$$$$ && \\\n\tDIR=`pwd` && \\\n\trm -rf \"$$AUTORECONF_DIR\" && \\\n\tmkdir \"$$AUTORECONF_DIR\" && \\\n\tcd \"$$AUTORECONF_DIR\" && \\\n\tif git -C \"$$DIR\" show-ref --tags --quiet --verify -- \"refs/tags/$$TAG\"; then \\\n\t    (git -C \"$$DIR\" archive --format=tar --prefix=\"$$TAG\"/ \"$$TAG^{tree}\" $(RELEASE_FILES) | \\\n\t     tar xf -) && \\\n\t    echo \"Archive build from tag $$TAG.\"; \\\n\telse \\\n\t    (git -C \"$$DIR\" archive --format=tar --prefix=\"$$TAG\"/ \"HEAD^{tree}\" $(RELEASE_FILES) | \\\n\t     tar xf -) && \\\n\t    echo \"No $$TAG tag. Archive build from HEAD.\"; \\\n\tfi && \\\n\t(cd \"$$TAG\" && ./autogen.sh && rm -rf autom4te.cache) && \\\n\ttar cf \"$$DIR/$$TAG\".tar \"$$TAG\" && \\\n\trm -f \"$$DIR/$$TAG\".tar.gz && \\\n\tgzip --best \"$$DIR/$$TAG\".tar && \\\n\tcd \"$$DIR\" && \\\n\trm -rf \"$$AUTORECONF_DIR\"\n\nreleasecheck: releasetar\n\t@TAG=$(PROG)-`cat VERSION` && \\\n\tINSTALL_DIR=/tmp/install_\"$$TAG\"_$$$$ && \\\n\tDIR=`pwd` && \\\n\tcd /tmp && \\\n\trm -rf \"$$TAG\" && \\\n\trm -rf \"$$INSTALL_DIR\" && \\\n\ttar xf \"$$DIR\"/\"$$TAG\".tar.gz && \\\n\tcd \"$$TAG\" && \\\n\techo \"[$@] $$ touch .devel\" && \\\n\ttouch .devel && \\\n\techo \"[$@] $$ ./configure --enable-remote --quiet --prefix=$$INSTALL_DIR\" && \\\n\t./configure --enable-remote --quiet --prefix=\"$$INSTALL_DIR\" && \\\n\techo '[$@] $$ $(MAKE) -s all testprogs' && \\\n\t$(MAKE) -s all testprogs && \\\n\techo '[$@] $$ $(MAKE) -s install' && \\\n\t$(MAKE) -s install && \\\n\tcd .. && \\\n\trm -rf \"$$TAG\" && \\\n\trm -rf \"$$INSTALL_DIR\" && \\\n\ttar xf \"$$DIR\"/\"$$TAG\".tar.gz && \\\n\tcd \"$$TAG\" && \\\n\techo \"[$@] $$ touch .devel\" && \\\n\ttouch .devel && \\\n\tmkdir build && \\\n\tcd build && \\\n\techo '[$@] $$ cmake -DENABLE_REMOTE=yes [...] ..' && \\\n\tcmake -DENABLE_REMOTE=yes \\\n\t    -DCMAKE_INSTALL_PREFIX=\"$$INSTALL_DIR\" \\\n\t    -DCMAKE_MESSAGE_LOG_LEVEL=NOTICE \\\n\t    -DCMAKE_RULE_MESSAGES=OFF \\\n\t    -DCMAKE_INSTALL_MESSAGE=NEVER \\\n\t    .. && \\\n\techo '[$@] $$ $(MAKE) -s all testprogs' && \\\n\t$(MAKE) -s all testprogs && \\\n\techo '[$@] $$ $(MAKE) -s install' && \\\n\t$(MAKE) -s install && \\\n\tcd ../.. && \\\n\trm -rf \"$$TAG\" && \\\n\trm -rf \"$$INSTALL_DIR\" && \\\n\techo '[$@] Done.'\n\nwhitespacecheck:\n\t@# trailing space(s)?\n\t@if git grep -I -n ' $$' $$(git ls-files|grep -v '^tests/'); then \\\n\t    echo 'Error: Trailing space(s).'; \\\n\t    exit 1; \\\n\tfi\n\t@# trailing tab(s)?\n\t@if git grep -I -n '\t$$' $$(git ls-files|grep -v '^tests/'); then \\\n\t    echo 'Error: Trailing tabs(s).'; \\\n\t    exit 1; \\\n\tfi\n\t@# space(s) before tab(s)?\n\t@if git grep -I -n '[ ][\t]' $$(git ls-files|grep -v '^tests/'); then \\\n\t    echo 'Error: space(s) before tab(s).'; \\\n\t    exit 1; \\\n\tfi\n\ndepend:\t$(GENERATED_C_SRC) $(GENHDR)\n\t$(MKDEP) -c $(CC) -m \"$(DEPENDENCY_CFLAG)\" -s \"$(srcdir)\" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)\n\t(cd rpcapd; $(MAKE) depend)\n\t(cd testprogs; $(MAKE) depend)\n\nshellcheck:\n\tshellcheck -f gcc -e SC2006 autogen.sh build.sh build_matrix.sh build_common.sh mkdep .ci-coverity-scan-build.sh\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.275390625,
          "content": "# LIBPCAP 1.x.y by [The Tcpdump Group](https://www.tcpdump.org)\n\n**To report a security issue please send an e-mail to security@tcpdump.org.**\n\nTo report bugs and other problems, contribute patches, request a\nfeature, provide generic feedback etc please see the\n[guidelines for contributing](CONTRIBUTING.md).\n\nThe [documentation directory](doc/) has README files about specific\noperating systems and options.\n\nAnonymous Git is available via:\n\n  https://github.com/the-tcpdump-group/libpcap.git\n\nThis directory contains source code for libpcap, a system-independent\ninterface for user-level packet capture.  libpcap provides a portable\nframework for low-level network monitoring.  Applications include\nnetwork statistics collection, security monitoring, network debugging,\netc.  Since almost every system vendor provides a different interface\nfor packet capture, and since we've developed several tools that\nrequire this functionality, we've created this system-independent API\nto ease in porting and to alleviate the need for several\nsystem-dependent packet capture modules in each application.\n\n```text\nformerly from\tLawrence Berkeley National Laboratory\n\t\tNetwork Research Group <libpcap@ee.lbl.gov>\n\t\tftp://ftp.ee.lbl.gov/old/libpcap-0.4a7.tar.Z\n```\n\n### Support for particular platforms and BPF\nFor some platforms there are `README.{system}` files that discuss issues\nwith the OS's interface for packet capture on those platforms, such as\nhow to enable support for that interface in the OS, if it's not built in\nby default.\n\nThe libpcap interface supports a filtering mechanism based on the\narchitecture in the BSD packet filter.  BPF is described in the 1993\nWinter Usenix paper ``The BSD Packet Filter: A New Architecture for\nUser-level Packet Capture''\n([compressed PostScript](https://www.tcpdump.org/papers/bpf-usenix93.ps.Z),\n[gzipped PostScript](https://www.tcpdump.org/papers/bpf-usenix93.ps.gz),\n[PDF](https://www.tcpdump.org/papers/bpf-usenix93.pdf)).\n\nAlthough most packet capture interfaces support in-kernel filtering,\nlibpcap utilizes in-kernel filtering only for the BPF interface.\nOn systems that don't have BPF, all packets are read into user-space\nand the BPF filters are evaluated in the libpcap library, incurring\nadded overhead (especially, for selective filters).  Ideally, libpcap\nwould translate BPF filters into a filter program that is compatible\nwith the underlying kernel subsystem, but this is not yet implemented.\n\nBPF is standard in NetBSD, FreeBSD, OpenBSD, DragonFly BSD, macOS, and\nSolaris 11; an older, modified and undocumented version is standard\nin AIX.\n\nLinux has a number of BPF based systems, and libpcap does not support\nany of the eBPF mechanisms as yet, although it supports many of the\nmemory mapped receive mechanisms.\nSee the [Linux-specific README](doc/README.linux) for more information.\n\n### Note to Linux distributions and *BSD systems that include libpcap:\n\nThere's now a rule to make a shared library, which should work on Linux\nand *BSD, among other platforms.\n\nIt sets the soname of the library to `libpcap.so.1`; this is what it\nshould be, **NOT** `libpcap.so.1.x` or `libpcap.so.1.x.y` or something such as\nthat.\n\nWe've been maintaining binary compatibility between libpcap releases for\nquite a while; there's no reason to tie a binary linked with libpcap to\na particular release of libpcap.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0146484375,
          "content": "1.11.0-PRE-GIT\n"
        },
        {
          "name": "aclocal.m4",
          "type": "blob",
          "size": 32.9013671875,
          "content": "dnl Copyright (c) 1995, 1996, 1997, 1998\ndnl\tThe Regents of the University of California.  All rights reserved.\ndnl\ndnl Redistribution and use in source and binary forms, with or without\ndnl modification, are permitted provided that: (1) source code distributions\ndnl retain the above copyright notice and this paragraph in its entirety, (2)\ndnl distributions including binary code include the above copyright notice and\ndnl this paragraph in its entirety in the documentation or other materials\ndnl provided with the distribution, and (3) all advertising materials mentioning\ndnl features or use of this software display the following acknowledgement:\ndnl ``This product includes software developed by the University of California,\ndnl Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\ndnl the University nor the names of its contributors may be used to endorse\ndnl or promote products derived from this software without specific prior\ndnl written permission.\ndnl THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\ndnl WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\ndnl MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\ndnl\ndnl LBL autoconf macros\ndnl\n\ndnl\ndnl Do whatever AC_LBL_C_INIT work is necessary before using AC_PROG_CC.\ndnl\ndnl It appears that newer versions of autoconf (2.64 and later) will,\ndnl if you use AC_TRY_COMPILE in a macro, stick AC_PROG_CC at the\ndnl beginning of the macro, even if the macro itself calls AC_PROG_CC.\ndnl See the \"Prerequisite Macros\" and \"Expanded Before Required\" sections\ndnl in the Autoconf documentation.\ndnl\ndnl This causes a steaming heap of fail in our case, as we were, in\ndnl AC_LBL_C_INIT, doing the tests we now do in AC_LBL_C_INIT_BEFORE_CC,\ndnl calling AC_PROG_CC, and then doing the tests we now do in\ndnl AC_LBL_C_INIT.  Now, we run AC_LBL_C_INIT_BEFORE_CC, AC_PROG_CC,\ndnl and AC_LBL_C_INIT at the top level.\ndnl\nAC_DEFUN(AC_LBL_C_INIT_BEFORE_CC,\n[\n    AC_BEFORE([$0], [AC_LBL_C_INIT])\n    AC_BEFORE([$0], [AC_PROG_CC])\n    AC_BEFORE([$0], [AC_LBL_DEVEL])\n    AC_ARG_WITH(gcc, [  --without-gcc           don't use gcc])\n    $1=\"\"\n    if test \"${srcdir}\" != \".\" ; then\n\t    $1=\"-I\\$(srcdir)\"\n    fi\n    if test \"${CFLAGS+set}\" = set; then\n\t    LBL_CFLAGS=\"$CFLAGS\"\n    fi\n    if test -z \"$CC\" -a \"$with_gcc\" = no ; then\n\t    CC=cc\n\t    export CC\n    fi\n])\n\ndnl\ndnl Determine which compiler we're using (cc or gcc)\ndnl If using gcc, determine the version number\ndnl If using cc:\ndnl     require that it support ansi prototypes\ndnl     use -O (AC_PROG_CC will use -g -O2 on gcc, so we don't need to\ndnl     do that ourselves for gcc)\ndnl     add -g flags, as appropriate\ndnl     explicitly specify /usr/local/include\ndnl\ndnl NOTE WELL: with newer versions of autoconf, \"gcc\" means any compiler\ndnl that defines __GNUC__, which means clang, for example, counts as \"gcc\".\ndnl\ndnl usage:\ndnl\ndnl\tAC_LBL_C_INIT(copt, incls)\ndnl\ndnl results:\ndnl\ndnl\t$1 (copt set)\ndnl\t$2 (incls set)\ndnl\tCC\ndnl\tLDFLAGS\ndnl\tLBL_CFLAGS\ndnl\nAC_DEFUN(AC_LBL_C_INIT,\n[\n    AC_BEFORE([$0], [AC_LBL_DEVEL])\n    AC_BEFORE([$0], [AC_LBL_SHLIBS_INIT])\n    if test \"$GCC\" = yes ; then\n\t    #\n\t    # -Werror forces warnings to be errors.\n\t    #\n\t    ac_lbl_cc_force_warning_errors=-Werror\n\n\t    #\n\t    # Try to have the compiler default to hiding symbols,\n\t    # so that only symbols explicitly exported with\n\t    # PCAP_API will be visible outside (shared) libraries.\n\t    #\n\t    AC_LBL_CHECK_COMPILER_OPT($1, -fvisibility=hidden)\n    else\n\t    $2=\"$$2 -I/usr/local/include\"\n\t    LDFLAGS=\"$LDFLAGS -L/usr/local/lib\"\n\n\t    case \"$host_os\" in\n\n\t    darwin*)\n\t\t    #\n\t\t    # This is assumed either to be GCC or clang, both\n\t\t    # of which use -Werror to force warnings to be errors.\n\t\t    #\n\t\t    ac_lbl_cc_force_warning_errors=-Werror\n\n\t\t    #\n\t\t    # Try to have the compiler default to hiding symbols,\n\t\t    # so that only symbols explicitly exported with\n\t\t    # PCAP_API will be visible outside (shared) libraries.\n\t\t    #\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -fvisibility=hidden)\n\t\t    ;;\n\n\t    hpux*)\n\t\t    #\n\t\t    # HP C, which is what we presume we're using, doesn't\n\t\t    # exit with a non-zero exit status if we hand it an\n\t\t    # invalid -W flag, can't be forced to do so even with\n\t\t    # +We, and doesn't handle GCC-style -W flags, so we\n\t\t    # don't want to try using GCC-style -W flags.\n\t\t    #\n\t\t    ac_lbl_cc_dont_try_gcc_dashW=yes\n\t\t    ;;\n\n\t    solaris*)\n\t\t    #\n\t\t    # Assumed to be Sun C, which requires -errwarn to force\n\t\t    # warnings to be treated as errors.\n\t\t    #\n\t\t    ac_lbl_cc_force_warning_errors=-errwarn\n\n\t\t    #\n\t\t    # Try to have the compiler default to hiding symbols,\n\t\t    # so that only symbols explicitly exported with\n\t\t    # PCAP_API will be visible outside (shared) libraries.\n\t\t    #\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -xldscope=hidden)\n\t\t    ;;\n\t    esac\n\t    $1=\"$$1 -O\"\n    fi\n])\n\ndnl\ndnl Save the values of various variables that affect compilation and\ndnl linking, and that we don't ourselves modify persistently; done\ndnl before a test involving compiling or linking is done, so that we\ndnl can restore those variables after the test is done.\ndnl\nAC_DEFUN(AC_LBL_SAVE_CHECK_STATE,\n[\n\tsave_CFLAGS=\"$CFLAGS\"\n\tsave_LIBS=\"$LIBS\"\n\tsave_LDFLAGS=\"$LDFLAGS\"\n])\n\ndnl\ndnl Restore the values of variables saved by AC_LBL_SAVE_CHECK_STATE.\ndnl\nAC_DEFUN(AC_LBL_RESTORE_CHECK_STATE,\n[\n\tCFLAGS=\"$save_CFLAGS\"\n\tLIBS=\"$save_LIBS\"\n\tLDFLAGS=\"$save_LDFLAGS\"\n])\n\ndnl\ndnl Check whether the compiler option specified as the second argument\ndnl is supported by the compiler and, if so, add it to the macro\ndnl specified as the first argument\ndnl\ndnl If a third argument is supplied, treat it as C code to be compiled\ndnl with the flag in question, and the \"treat warnings as errors\" flag\ndnl set, and don't add the flag to the first argument if the compile\ndnl fails; this is for warning options cause problems that can't be\ndnl worked around.  If a third argument is supplied, a fourth argument\ndnl should also be supplied; it's a message describing what the test\ndnl program is checking.\ndnl\nAC_DEFUN(AC_LBL_CHECK_COMPILER_OPT,\n    [\n\tAC_MSG_CHECKING([whether the compiler supports the $2 option])\n\tsave_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS $2\"\n\t#\n\t# XXX - yes, this depends on the way AC_LANG_WERROR works,\n\t# but no mechanism is provided to turn AC_LANG_WERROR on\n\t# *and then turn it back off*, so that we *only* do it when\n\t# testing compiler options - 15 years after somebody asked\n\t# for it:\n\t#\n\t#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror\n\t#\n\tsave_ac_c_werror_flag=\"$ac_c_werror_flag\"\n\tac_c_werror_flag=yes\n\t#\n\t# We use AC_LANG_SOURCE() so that we can control the complete\n\t# content of the program being compiled.  We do not, for example,\n\t# want the default \"int main()\" that AC_LANG_PROGRAM() generates,\n\t# as it will generate a warning with -Wold-style-definition, meaning\n\t# that we would treat it as not working, as the test will fail if\n\t# *any* error output, including a warning due to the flag we're\n\t# testing, is generated; see\n\t#\n\t#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us\n\t#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us\n\t#\n\t# This may, as per those two messages, be fixed in autoconf 2.70,\n\t# but we only require 2.69 or newer for now.\n\t#\n\tAC_COMPILE_IFELSE(\n\t    [AC_LANG_SOURCE([[int main(void) { return 0; }]])],\n\t    [\n\t\tAC_MSG_RESULT([yes])\n\t\tcan_add_to_cflags=yes\n\t\t#\n\t\t# The compile supports this; do we have some C code for\n\t\t# which the warning should *not* appear?\n\t\t# We test the fourth argument because the third argument\n\t\t# could contain quotes, breaking the test.\n\t\t#\n\t\tif test \"x$4\" != \"x\"\n\t\tthen\n\t\t    CFLAGS=\"$CFLAGS $ac_lbl_cc_force_warning_errors\"\n\t\t    AC_MSG_CHECKING(whether $2 $4)\n\t\t    AC_COMPILE_IFELSE(\n\t\t      [AC_LANG_SOURCE($3)],\n\t\t      [\n\t\t\t#\n\t\t\t# Not a problem.\n\t\t\t#\n\t\t\tAC_MSG_RESULT(no)\n\t\t      ],\n\t\t      [\n\t\t\t#\n\t\t\t# A problem.\n\t\t\t#\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tcan_add_to_cflags=no\n\t\t      ])\n\t\tfi\n\t\tCFLAGS=\"$save_CFLAGS\"\n\t\tif test x\"$can_add_to_cflags\" = \"xyes\"\n\t\tthen\n\t\t    $1=\"$$1 $2\"\n\t\tfi\n\t    ],\n\t    [\n\t\tAC_MSG_RESULT([no])\n\t\tCFLAGS=\"$save_CFLAGS\"\n\t    ])\n\tac_c_werror_flag=\"$save_ac_c_werror_flag\"\n    ])\n\ndnl\ndnl Check whether the compiler supports an option to generate\ndnl Makefile-style dependency lines\ndnl\ndnl GCC uses -M for this.  Non-GCC compilers that support this\ndnl use a variety of flags, including but not limited to -M.\ndnl\ndnl We test whether the flag in question is supported, as older\ndnl versions of compilers might not support it.\ndnl\ndnl We don't try all the possible flags, just in case some flag means\ndnl \"generate dependencies\" on one compiler but means something else\ndnl on another compiler.\ndnl\ndnl Most compilers that support this send the output to the standard\ndnl output by default.  IBM's XLC, however, supports -M but sends\ndnl the output to {sourcefile-basename}.u, and AIX has no /dev/stdout\ndnl to work around that, so we don't bother with XLC.\ndnl\nAC_DEFUN(AC_LBL_CHECK_DEPENDENCY_GENERATION_OPT,\n    [\n\tAC_MSG_CHECKING([whether the compiler supports generating dependencies])\n\tif test \"$GCC\" = yes ; then\n\t\t#\n\t\t# GCC, or a compiler deemed to be GCC by AC_PROG_CC (even\n\t\t# though it's not); we assume that, in this case, the flag\n\t\t# would be -M.\n\t\t#\n\t\tac_lbl_dependency_flag=\"-M\"\n\telse\n\t\t#\n\t\t# Not GCC or a compiler deemed to be GCC; what platform is\n\t\t# this?  (We're assuming that if the compiler isn't GCC\n\t\t# it's the compiler from the vendor of the OS; that won't\n\t\t# necessarily be true for x86 platforms, where it might be\n\t\t# the Intel C compiler.)\n\t\t#\n\t\tcase \"$host_os\" in\n\n\t\tdarwin*)\n\t\t\t#\n\t\t\t# Clang uses -M.\n\t\t\t#\n\t\t\tac_lbl_dependency_flag=\"-M\"\n\t\t\t;;\n\n\t\tsolaris*)\n\t\t\t#\n\t\t\t# Sun C uses -xM.\n\t\t\t#\n\t\t\tac_lbl_dependency_flag=\"-xM\"\n\t\t\t;;\n\n\t\thpux*)\n\t\t\t#\n\t\t\t# HP's older C compilers don't support this.\n\t\t\t# HP's newer C compilers support this with\n\t\t\t# either +M or +Make; the older compilers\n\t\t\t# interpret +M as something completely\n\t\t\t# different, so we use +Make so we don't\n\t\t\t# think it works with the older compilers.\n\t\t\t#\n\t\t\tac_lbl_dependency_flag=\"+Make\"\n\t\t\t;;\n\n\t\t*)\n\t\t\t#\n\t\t\t# Not one of the above; assume no support for\n\t\t\t# generating dependencies.\n\t\t\t#\n\t\t\tac_lbl_dependency_flag=\"\"\n\t\t\t;;\n\t\tesac\n\tfi\n\n\t#\n\t# Is ac_lbl_dependency_flag defined and, if so, does the compiler\n\t# complain about it?\n\t#\n\t# Note: clang doesn't seem to exit with an error status when handed\n\t# an unknown non-warning error, even if you pass it\n\t# -Werror=unknown-warning-option.  However, it always supports\n\t# -M, so the fact that this test always succeeds with clang\n\t# isn't an issue.\n\t#\n\tif test ! -z \"$ac_lbl_dependency_flag\"; then\n\t\tAC_LANG_CONFTEST(\n\t\t    [AC_LANG_SOURCE([[int main(void) { return 0; }]])])\n\t\tif AC_RUN_LOG([eval \"$CC $ac_lbl_dependency_flag conftest.c >/dev/null 2>&1\"]); then\n\t\t\tAC_MSG_RESULT([yes, with $ac_lbl_dependency_flag])\n\t\t\tDEPENDENCY_CFLAG=\"$ac_lbl_dependency_flag\"\n\t\t\tMKDEP='${top_srcdir}/mkdep'\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\t\t#\n\t\t\t# We can't run mkdep, so have \"make depend\" do\n\t\t\t# nothing.\n\t\t\t#\n\t\t\tMKDEP='${top_srcdir}/nomkdep'\n\t\tfi\n\t\trm -rf conftest*\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\t#\n\t\t# We can't run mkdep, so have \"make depend\" do\n\t\t# nothing.\n\t\t#\n\t\tMKDEP='${top_srcdir}/nomkdep'\n\tfi\n\tAC_SUBST(DEPENDENCY_CFLAG)\n\tAC_SUBST(MKDEP)\n    ])\n\ndnl\ndnl Determine what options are needed to build a shared library\ndnl\ndnl usage:\ndnl\ndnl\tAC_LBL_SHLIBS_INIT\ndnl\ndnl results:\ndnl\ndnl\tV_SHLIB_CCOPT (modified to build position-independent code)\ndnl\tV_SHLIB_CMD\ndnl\tV_SHLIB_OPT\ndnl\tV_SONAME_OPT\ndnl\nAC_DEFUN(AC_LBL_SHLIBS_INIT,\n    [AC_PREREQ(2.50)\n    if test \"$GCC\" = yes ; then\n\t    #\n\t    # On platforms where we build a shared library:\n\t    #\n\t    #\tadd options to generate position-independent code,\n\t    #\tif necessary (it's the default in AIX and Darwin/macOS);\n\t    #\n\t    #\tdefine option to set the soname of the shared library,\n\t    #\tif the OS supports that;\n\t    #\n\t    #\tadd options to specify, at link time, a directory to\n\t    #\tadd to the run-time search path, if that's necessary.\n\t    #\n\t    V_SHLIB_CMD=\"\\$(CC)\"\n\t    V_SHLIB_OPT=\"-shared\"\n\t    case \"$host_os\" in\n\n\t    aix*)\n\t\t    ;;\n\n\t    freebsd*|netbsd*|openbsd*|dragonfly*|linux*|haiku*|midipix*|gnu*)\n\t\t    #\n\t\t    # Platforms where the C compiler is GCC or accepts\n\t\t    # compatible command-line arguments, and the linker\n\t\t    # is the GNU linker or accepts compatible command-line\n\t\t    # arguments.\n\t\t    #\n\t\t    # Some instruction sets require -fPIC on some\n\t\t    # operating systems.  Check for them.  If you\n\t\t    # have a combination that requires it, add it\n\t\t    # here.\n\t\t    #\n\t\t    PIC_OPT=-fpic\n\t\t    case \"$host_cpu\" in\n\n\t\t    sparc64*)\n\t\t\tcase \"$host_os\" in\n\n\t\t\tfreebsd*|openbsd*|linux*)\n\t\t\t    PIC_OPT=-fPIC\n\t\t\t    ;;\n\t\t\tesac\n\t\t\t;;\n\t\t    esac\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT $PIC_OPT\"\n\t\t    V_SONAME_OPT=\"-Wl,-soname,\"\n\t\t    ;;\n\n\t    hpux*)\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT -fpic\"\n\t\t    #\n\t\t    # XXX - this assumes GCC is using the HP linker,\n\t\t    # rather than the GNU linker, and that the \"+h\"\n\t\t    # option is used on all HP-UX platforms, both .sl\n\t\t    # and .so.\n\t\t    #\n\t\t    V_SONAME_OPT=\"-Wl,+h,\"\n\t\t    #\n\t\t    # By default, directories specified with -L\n\t\t    # are added to the run-time search path, so\n\t\t    # we don't add them in pcap-config.\n\t\t    #\n\t\t    ;;\n\n\t    solaris*)\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT -fpic\"\n\t\t    #\n\t\t    # Sun/Oracle's C compiler, GCC, and GCC-compatible\n\t\t    # compilers support -Wl,{comma-separated list of options},\n\t\t    # and we use the C compiler, not ld, for all linking,\n\t\t    # including linking to produce a shared library.\n\t\t    #\n\t\t    V_SONAME_OPT=\"-Wl,-h,\"\n\t\t    ;;\n\t    esac\n    else\n\t    #\n\t    # Set the appropriate compiler flags and, on platforms\n\t    # where we build a shared library:\n\t    #\n\t    #\tadd options to generate position-independent code,\n\t    #\tif necessary (it's the default in Darwin/macOS);\n\t    #\n\t    #\tif we generate \".so\" shared libraries, define the\n\t    #\tappropriate options for building the shared library;\n\t    #\n\t    #\tadd options to specify, at link time, a directory to\n\t    #\tadd to the run-time search path, if that's necessary.\n\t    #\n\t    # Note: spaces after V_SONAME_OPT are significant; on\n\t    # some platforms the soname is passed with a GCC-like\n\t    # \"-Wl,-soname,{soname}\" option, with the soname part\n\t    # of the option, while on other platforms the C compiler\n\t    # driver takes it as a regular option with the soname\n\t    # following the option.\n\t    #\n\t    case \"$host_os\" in\n\n\t    aix*)\n\t\t    V_SHLIB_CMD=\"\\$(CC)\"\n\t\t    V_SHLIB_OPT=\"-G -bnoentry -bexpall\"\n\t\t    ;;\n\n\t    freebsd*|netbsd*|openbsd*|dragonfly*|linux*)\n\t\t    #\n\t\t    # Platforms where the C compiler is GCC or accepts\n\t\t    # compatible command-line arguments, and the linker\n\t\t    # is the GNU linker or accepts compatible command-line\n\t\t    # arguments.\n\t\t    #\n\t\t    # XXX - does 64-bit SPARC require -fPIC?\n\t\t    #\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT -fpic\"\n\t\t    V_SHLIB_CMD=\"\\$(CC)\"\n\t\t    V_SHLIB_OPT=\"-shared\"\n\t\t    V_SONAME_OPT=\"-Wl,-soname,\"\n\t\t    ;;\n\n\t    hpux*)\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT +z\"\n\t\t    V_SHLIB_CMD=\"\\$(LD)\"\n\t\t    V_SHLIB_OPT=\"-b\"\n\t\t    V_SONAME_OPT=\"+h \"\n\t\t    #\n\t\t    # By default, directories specified with -L\n\t\t    # are added to the run-time search path, so\n\t\t    # we don't add them in pcap-config.\n\t\t    #\n\t\t    ;;\n\n\t    solaris*)\n\t\t    V_SHLIB_CCOPT=\"$V_SHLIB_CCOPT -Kpic\"\n\t\t    V_SHLIB_CMD=\"\\$(CC)\"\n\t\t    V_SHLIB_OPT=\"-G\"\n\t\t    #\n\t\t    # Sun/Oracle's C compiler, GCC, and GCC-compatible\n\t\t    # compilers support -Wl,{comma-separated list of options},\n\t\t    # and we use the C compiler, not ld, for all linking,\n\t\t    # including linking to produce a shared library.\n\t\t    #\n\t\t    V_SONAME_OPT=\"-Wl,-h,\"\n\t\t    ;;\n\t    esac\n    fi\n])\n\n#\n# Test whether we have __atomic_load_n() and __atomic_store_n().\n#\n# We use AC_LINK_IFELSE because AC_TRY_COMPILE will succeed, as the\n# compiler will just think that those functions are undefined,\n# and perhaps warn about that, but not fail to compile.\n#\nAC_DEFUN(AC_PCAP_C___ATOMICS,\n    [\n\tAC_MSG_CHECKING(for __atomic_load_n)\n\tAC_CACHE_VAL(ac_cv_have___atomic_load_n,\n\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],\n\t\t[[\n\t\t    int i = 17;\n\t\t    int j;\n\t\t    j = __atomic_load_n(&i, __ATOMIC_RELAXED);\n\t\t]])],\n\t\t[ac_have___atomic_load_n=yes],\n\t\t[ac_have___atomic_load_n=no]))\n\tAC_MSG_RESULT($ac_have___atomic_load_n)\n\tif test $ac_have___atomic_load_n = yes ; then\n\t    AC_DEFINE(HAVE___ATOMIC_LOAD_N, 1,\n\t\t[define if __atomic_load_n is supported by the compiler])\n\tfi\n\n\tAC_MSG_CHECKING(for __atomic_store_n)\n\tAC_CACHE_VAL(ac_cv_have___atomic_store_n,\n\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],\n\t\t[[\n\t\t    int i;\n\t\t    __atomic_store_n(&i, 17, __ATOMIC_RELAXED);\n\t\t]])],\n\t\t[ac_have___atomic_store_n=yes],\n\t\t[ac_have___atomic_store_n=no]))\n\tAC_MSG_RESULT($ac_have___atomic_store_n)\n\tif test $ac_have___atomic_store_n = yes ; then\n\t    AC_DEFINE(HAVE___ATOMIC_STORE_N, 1,\n\t\t[define if __atomic_store_n is supported by the compiler])\n\tfi])\n\ndnl\ndnl If the file .devel exists:\ndnl\tAdd some warning flags if the compiler supports them\ndnl\tIf an os prototype include exists, symlink os-proto.h to it\ndnl\ndnl usage:\ndnl\ndnl\tAC_LBL_DEVEL(copt)\ndnl\ndnl results:\ndnl\ndnl\t$1 (copt appended)\ndnl\tHAVE_OS_PROTO_H (defined)\ndnl\tos-proto.h (symlinked)\ndnl\nAC_DEFUN(AC_LBL_DEVEL,\n    [rm -f os-proto.h\n    if test \"${LBL_CFLAGS+set}\" = set; then\n\t    $1=\"$$1 ${LBL_CFLAGS}\"\n    fi\n    if test -f .devel ; then\n\t    #\n\t    # Skip all the warning option stuff on some compilers.\n\t    #\n\t    if test \"$ac_lbl_cc_dont_try_gcc_dashW\" != yes; then\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -W)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wall)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wcomma)\n\t\t    # Warns about safeguards added in case the enums are\n\t\t    # extended\n\t\t    # AC_LBL_CHECK_COMPILER_OPT($1, -Wcovered-switch-default)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wdocumentation)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wformat-nonliteral)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-noreturn)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-prototypes)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-variable-declarations)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wnull-pointer-subtraction)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wpointer-arith)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wpointer-sign)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wshadow)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wshorten-64-to-32)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wsign-compare)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wstrict-prototypes)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wundef)\n\t\t    #\n\t\t    # This can cause problems with ntohs(), ntohl(),\n\t\t    # htons(), and htonl() on some platforms, such\n\t\t    # as OpenBSD 6.3 with Clang 5.0.1.  I guess the\n\t\t    # problem is that the macro that ultimately does\n\t\t    # the byte-swapping involves a conditional\n\t\t    # expression that tests whether the value being\n\t\t    # swapped is a compile-time constant or not,\n\t\t    # using __builtin_constant_p(), and, depending\n\t\t    # on whether it is, does a compile-time swap or\n\t\t    # a run-time swap; perhaps the compiler always\n\t\t    # considers one of the two results of the\n\t\t    # conditional expression is never evaluated,\n\t\t    # because the conditional check is done at\n\t\t    # compile time, and thus always says \"that\n\t\t    # expression is never executed\".\n\t\t    #\n\t\t    # (Perhaps there should be a way of flagging\n\t\t    # an expression that you *want* evaluated at\n\t\t    # compile time, so that the compiler 1) warns\n\t\t    # if it *can't* be evaluated at compile time\n\t\t    # and 2) *doesn't* warn that the true or false\n\t\t    # branch will never be reached.)\n\t\t    #\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wunreachable-code,\n\t\t      [\n#include <arpa/inet.h>\n\nunsigned short\ntestme(unsigned short a)\n{\n\treturn ntohs(a);\n}\n\t\t      ],\n\t\t      [generates warnings from ntohs()])\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-but-set-parameter)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-but-set-variable)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-parameter)\n\t\t    AC_LBL_CHECK_COMPILER_OPT($1, -Wused-but-marked-unused)\n\t    fi\n\t    AC_LBL_CHECK_DEPENDENCY_GENERATION_OPT()\n\t    AC_MSG_CHECKING([whether to use an os-proto.h header])\n\t    os=`echo $host_os | sed -e 's/\\([[0-9]][[0-9]]*\\)[[^0-9]].*$/\\1/'`\n\t    name=\"lbl/os-$os.h\"\n\t    if test -f $name ; then\n\t\t    AC_MSG_RESULT([yes, at \"$name\"])\n\t\t    ln -s $name os-proto.h\n\t\t    AC_DEFINE(HAVE_OS_PROTO_H, 1,\n\t\t\t[if there's an os-proto.h for this platform, to use additional prototypes])\n\t    else\n\t\t    AC_MSG_RESULT([no])\n\t    fi\n    fi])\n\ndnl\ndnl AC_LBL_LIBRARY_NET\ndnl\ndnl Look for various networking-related libraries that we may need.\ndnl\ndnl We need getaddrinfo() to translate host names in filters to IP\ndnl addresses. We use getaddrinfo() because we want a portable\ndnl thread-safe way of getting information for a host name or port;\ndnl there exist _r versions of gethostbyname() and getservbyname() on\ndnl some platforms, but not on all platforms.\ndnl\ndnl We may also need socket() and other socket functions to support:\ndnl\ndnl   Local packet capture with capture mechanisms that use sockets.\ndnl\ndnl   Local capture device enumeration if a socket call is needed to\ndnl   enumerate devices or get device attributes.\ndnl\ndnl   Packet capture from services that put captured packets on the\ndnl   network, such as rpcap servers.\ndnl\ndnl We may also need getnameinfo() for packet capture from services\ndnl that put packets on the network.\ndnl\nAC_DEFUN(AC_LBL_LIBRARY_NET, [\n    #\n    # Most operating systems have getaddrinfo(), and the other routines\n    # we may need, in the default searched libraries (e.g., libc).\n    #\n    # These are: AIX, FreeBSD, Linux, macOS, NetBSD, OpenBSD, Solaris\n    # since 11.4.\n    #\n    # Check there first.\n    #\n    AC_CHECK_FUNC(getaddrinfo,,\n    [\n\t#\n\t# Not found in the standard system libraries.\n\t#\n\t# In some versions of Solaris, we need to link with libsocket\n\t# and libnsl, so check in libsocket and also link with libnsl\n\t# when doing this test.\n\t#\n\t# These are: illumos, Solaris 9.x, 10.x, 11.x before 11.4.\n\t#\n\t# Linking with libsocket and libnsl will find all the routines\n\t# we need.\n\t#\n\tAC_CHECK_LIB(socket, getaddrinfo,\n\t[\n\t    #\n\t    # OK, we found it in libsocket.\n\t    #\n\t    LIBS=\"-lsocket -lnsl $LIBS\"\n\t],\n\t[\n\t    #\n\t    # Not found in libsocket; test for it in libnetwork, which\n\t    # is where it is in Haiku.\n\t    #\n\t    # Linking with libnetwork will find all the routines we\n\t    # need.\n\t    #\n\t    AC_CHECK_LIB(network, getaddrinfo,\n\t    [\n\t\t#\n\t\t# OK, we found it in libnetwork.\n\t\t#\n\t\tLIBS=\"-lnetwork $LIBS\"\n\t    ],\n\t    [\n\t\t#\n\t\t# We didn't find it.\n\t\t#\n\t\tAC_MSG_ERROR([getaddrinfo is required, but wasn't found])\n\t    ])\n\t], -lnsl)\n\n\t#\n\t# We require a version of recvmsg() that conforms to the Single\n\t# UNIX Specification, so that we can check whether a datagram\n\t# received with recvmsg() was truncated when received due to the\n\t# buffer being too small.\n\t#\n\t# On most systems, the version of recvmsg() in the libraries\n\t# found above conforms to the SUS.\n\t#\n\t# On at least some versions of Solaris, it does not conform to\n\t# the SUS, and we need the version in libxnet, which does\n\t# conform.\n\t#\n\t# Check whether libxnet exists and has a version of recvmsg();\n\t# if it does, link with libxnet before we link with libsocket,\n\t# to get that version.\n\t#\n\t# This test also links with libsocket and libnsl.\n\t#\n\tAC_CHECK_LIB(xnet, recvmsg,\n\t[\n\t    #\n\t    # libxnet has recvmsg(); link with it as well.\n\t    #\n\t    LIBS=\"-lxnet $LIBS\"\n\t], , -lsocket -lnsl)\n    ])\n\n    #\n    # DLPI needs putmsg under HP-UX, so test for -lstr while we're at it.\n    #\n    AC_SEARCH_LIBS(putmsg, str)\n])\n\nm4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\ndnl pkg.m4 - Macros to locate and utilise pkg-config.   -*- Autoconf -*-\ndnl serial 11 (pkg-config-0.29)\ndnl\ndnl Copyright © 2004 Scott James Remnant <scott@netsplit.com>.\ndnl Copyright © 2012-2015 Dan Nicholson <dbn.lists@gmail.com>\ndnl\ndnl This program is free software; you can redistribute it and/or modify\ndnl it under the terms of the GNU General Public License as published by\ndnl the Free Software Foundation; either version 2 of the License, or\ndnl (at your option) any later version.\ndnl\ndnl This program is distributed in the hope that it will be useful, but\ndnl WITHOUT ANY WARRANTY; without even the implied warranty of\ndnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\ndnl General Public License for more details.\ndnl\ndnl You should have received a copy of the GNU General Public License\ndnl along with this program; if not, write to the Free Software\ndnl Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\ndnl 02111-1307, USA.\ndnl\ndnl As a special exception to the GNU General Public License, if you\ndnl distribute this file as part of a program that contains a\ndnl configuration script generated by Autoconf, you may include it under\ndnl the same distribution terms that you use for the rest of that\ndnl program.\n\ndnl PKG_PREREQ(MIN-VERSION)\ndnl -----------------------\ndnl Since: 0.29\ndnl\ndnl Verify that the version of the pkg-config macros are at least\ndnl MIN-VERSION. Unlike PKG_PROG_PKG_CONFIG, which checks the user's\ndnl installed version of pkg-config, this checks the developer's version\ndnl of pkg.m4 when generating configure.\ndnl\ndnl To ensure that this macro is defined, also add:\ndnl m4_ifndef([PKG_PREREQ],\ndnl     [m4_fatal([must install pkg-config 0.29 or later before running autoconf/autogen])])\ndnl\ndnl See the \"Since\" comment for each macro you use to see what version\ndnl of the macros you require.\nm4_defun([PKG_PREREQ],\n[m4_define([PKG_MACROS_VERSION], [0.29])\nm4_if(m4_version_compare(PKG_MACROS_VERSION, [$1]), -1,\n    [m4_fatal([pkg.m4 version $1 or higher is required but ]PKG_MACROS_VERSION[ found])])\n])dnl PKG_PREREQ\n\ndnl PKG_PROG_PKG_CONFIG([MIN-VERSION])\ndnl ----------------------------------\ndnl Since: 0.16\ndnl\ndnl Search for the pkg-config tool and set the PKG_CONFIG variable to\ndnl first found in the path. Checks that the version of pkg-config found\ndnl is at least MIN-VERSION. If MIN-VERSION is not specified, 0.17.0 is\ndnl used since that's the first version where --static was supported.\nAC_DEFUN([PKG_PROG_PKG_CONFIG],\n[m4_pattern_forbid([^_?PKG_[A-Z_]+$])\nm4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])\nm4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])\nAC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])\nAC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])\nAC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])\n\nif test \"x$ac_cv_env_PKG_CONFIG_set\" != \"xset\"; then\n\tAC_PATH_TOOL([PKG_CONFIG], [pkg-config])\nfi\nif test -n \"$PKG_CONFIG\"; then\n\t_pkg_min_version=m4_default([$1], [0.17.0])\n\tAC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])\n\tif $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tPKG_CONFIG=\"\"\n\tfi\nfi[]dnl\n])dnl PKG_PROG_PKG_CONFIG\n\ndnl PKG_CHECK_EXISTS(MODULE, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl -------------------------------------------------------------------\ndnl Since: 0.18\ndnl\ndnl Check to see whether a particular module exists. Similar to\ndnl PKG_CHECK_MODULE(), but does not set variables or print errors.\nAC_DEFUN([PKG_CHECK_EXISTS],\n[\nif test -n \"$PKG_CONFIG\" && \\\n    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors \"$1\"]); then\n  m4_default([$2], [:])\nm4_ifvaln([$3], [else\n  $3])dnl\nfi])\n\ndnl _PKG_CONFIG_WITH_FLAGS([VARIABLE], [FLAGS], [MODULE])\ndnl ---------------------------------------------\ndnl Internal wrapper calling pkg-config via PKG_CONFIG and, if\ndnl pkg-config fails, reporting the error and quitting.\nm4_define([_PKG_CONFIG_WITH_FLAGS],\n[if test ! -n \"$$1\"; then\n    $1=`$PKG_CONFIG $2 \"$3\" 2>/dev/null`\n    if test \"x$?\" != \"x0\"; then\n        #\n        # That failed - report an error.\n        # Re-run the command, telling pkg-config to print an error\n        # message, capture the error message, and report it.\n        # This causes the configuration script to fail, as it means\n        # the script is almost certainly doing something wrong.\n        #\n        _PKG_SHORT_ERRORS_SUPPORTED\n\tif test $_pkg_short_errors_supported = yes; then\n\t    _pkg_error_string=`$PKG_CONFIG --short-errors --print-errors $2 \"$3\" 2>&1`\n\telse\n\t    _pkg_error_string=`$PKG_CONFIG --print-errors $2 \"$3\" 2>&1`\n\tfi\n        AC_MSG_ERROR([$PKG_CONFIG $2 \"$3\" failed: $_pkg_error_string])\n    fi\n fi[]dnl\n])dnl _PKG_CONFIG_WITH_FLAGS\n\n\ndnl _PKG_CONFIG([VARIABLE], [FLAGS], [MODULE])\ndnl ---------------------------------------------\ndnl Internal wrapper calling pkg-config via PKG_CONFIG and setting\ndnl pkg_failed based on the result.\nm4_define([_PKG_CONFIG],\n[if test -n \"$$1\"; then\n    pkg_cv_[]$1=\"$$1\"\n elif test -n \"$PKG_CONFIG\"; then\n    PKG_CHECK_EXISTS([$3],\n                     [pkg_cv_[]$1=`$PKG_CONFIG $2 \"$3\" 2>/dev/null`\n\t\t      test \"x$?\" != \"x0\" && pkg_failed=yes ],\n\t\t     [pkg_failed=yes])\n else\n    pkg_failed=untried\nfi[]dnl\n])dnl _PKG_CONFIG\n\ndnl _PKG_SHORT_ERRORS_SUPPORTED\ndnl ---------------------------\ndnl Internal check to see if pkg-config supports short errors.\nAC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],\n[\nif $PKG_CONFIG --atleast-pkgconfig-version 0.20; then\n        _pkg_short_errors_supported=yes\nelse\n        _pkg_short_errors_supported=no\nfi[]dnl\n])dnl _PKG_SHORT_ERRORS_SUPPORTED\n\n\ndnl PKG_CHECK_MODULE(VARIABLE-PREFIX, MODULE, [ACTION-IF-FOUND],\ndnl   [ACTION-IF-NOT-FOUND])\ndnl --------------------------------------------------------------\ndnl Since: 0.4.0\nAC_DEFUN([PKG_CHECK_MODULE],\n[\nAC_MSG_CHECKING([for $2 with pkg-config])\nif test -n \"$PKG_CONFIG\"; then\n    AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $2, overriding pkg-config])dnl\n    AC_ARG_VAR([$1][_LIBS], [linker flags for $2, overriding pkg-config])dnl\n    AC_ARG_VAR([$1][_LIBS_STATIC], [static-link linker flags for $2, overriding pkg-config])dnl\n\n    if AC_RUN_LOG([$PKG_CONFIG --exists --print-errors \"$2\"]); then\n\t#\n\t# The package was found, so try to get its C flags and\n\t# libraries.\n\t#\n        AC_MSG_RESULT([found])\n\t_PKG_CONFIG_WITH_FLAGS([$1][_CFLAGS], [--cflags], [$2])\n\t_PKG_CONFIG_WITH_FLAGS([$1][_LIBS], [--libs], [$2])\n\t_PKG_CONFIG_WITH_FLAGS([$1][_LIBS_STATIC], [--libs --static], [$2])\n        m4_default([$3], [:])\n    else\n        AC_MSG_RESULT([not found])\n        m4_default([$4], [:])\n    fi\nelse\n    # No pkg-config, so obviously not found with pkg-config.\n    AC_MSG_RESULT([pkg-config not found])\n    m4_default([$4], [:])\nfi\n])dnl PKG_CHECK_MODULE\n\n\ndnl PKG_CHECK_MODULE_STATIC(VARIABLE-PREFIX, MODULE, [ACTION-IF-FOUND],\ndnl   [ACTION-IF-NOT-FOUND])\ndnl ---------------------------------------------------------------------\ndnl Since: 0.29\ndnl\ndnl Checks for existence of MODULE and gathers its build flags with\ndnl static libraries enabled. Sets VARIABLE-PREFIX_CFLAGS from --cflags\ndnl and VARIABLE-PREFIX_LIBS from --libs.\nAC_DEFUN([PKG_CHECK_MODULE_STATIC],\n[\n_save_PKG_CONFIG=$PKG_CONFIG\nPKG_CONFIG=\"$PKG_CONFIG --static\"\nPKG_CHECK_MODULE($@)\nPKG_CONFIG=$_save_PKG_CONFIG[]dnl\n])dnl PKG_CHECK_MODULE_STATIC\n\n\ndnl PKG_INSTALLDIR([DIRECTORY])\ndnl -------------------------\ndnl Since: 0.27\ndnl\ndnl Substitutes the variable pkgconfigdir as the location where a module\ndnl should install pkg-config .pc files. By default the directory is\ndnl $libdir/pkgconfig, but the default can be changed by passing\ndnl DIRECTORY. The user can override through the --with-pkgconfigdir\ndnl parameter.\nAC_DEFUN([PKG_INSTALLDIR],\n[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])\nm4_pushdef([pkg_description],\n    [pkg-config installation directory @<:@]pkg_default[@:>@])\nAC_ARG_WITH([pkgconfigdir],\n    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,\n    [with_pkgconfigdir=]pkg_default)\nAC_SUBST([pkgconfigdir], [$with_pkgconfigdir])\nm4_popdef([pkg_default])\nm4_popdef([pkg_description])\n])dnl PKG_INSTALLDIR\n\n\ndnl PKG_NOARCH_INSTALLDIR([DIRECTORY])\ndnl --------------------------------\ndnl Since: 0.27\ndnl\ndnl Substitutes the variable noarch_pkgconfigdir as the location where a\ndnl module should install arch-independent pkg-config .pc files. By\ndnl default the directory is $datadir/pkgconfig, but the default can be\ndnl changed by passing DIRECTORY. The user can override through the\ndnl --with-noarch-pkgconfigdir parameter.\nAC_DEFUN([PKG_NOARCH_INSTALLDIR],\n[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])\nm4_pushdef([pkg_description],\n    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])\nAC_ARG_WITH([noarch-pkgconfigdir],\n    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,\n    [with_noarch_pkgconfigdir=]pkg_default)\nAC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])\nm4_popdef([pkg_default])\nm4_popdef([pkg_description])\n])dnl PKG_NOARCH_INSTALLDIR\n\n\ndnl PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,\ndnl [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl -------------------------------------------\ndnl Since: 0.28\ndnl\ndnl Retrieves the value of the pkg-config variable for the given module.\nAC_DEFUN([PKG_CHECK_VAR],\n[\nAC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl\n\n_PKG_CONFIG([$1], [--variable=\"][$3][\"], [$2])\nAS_VAR_COPY([$1], [pkg_cv_][$1])\n\nAS_VAR_IF([$1], [\"\"], [$5], [$4])dnl\n])dnl PKG_CHECK_VAR\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 1.7138671875,
          "content": "#!/bin/sh -e\n\n: \"${AUTORECONF:=autoreconf}\"\n\nAUTORECONFVERSION=`$AUTORECONF --version 2>&1 | grep \"^autoreconf\" | sed 's/.*) *//'`\n\nmaj=`echo \"$AUTORECONFVERSION\" | cut -d. -f1`\nmin=`echo \"$AUTORECONFVERSION\" | cut -d. -f2`\n# The minimum required version of autoconf is currently 2.69.\nif [ \"$maj\" = \"\" ] || [ \"$min\" = \"\" ] || \\\n   [ \"$maj\" -lt 2 ] || { [ \"$maj\" -eq 2 ] && [ \"$min\" -lt 69 ]; }; then\n\tcat >&2 <<-EOF\n\tPlease install the 'autoconf' package version 2.69 or later.\n\tIf version 2.69 or later is already installed and there is no\n\tautoconf default, it may be necessary to set the AUTORECONF\n\tenvironment variable to enable the one to use, like:\n\tAUTORECONF=autoreconf-2.69 ./autogen.sh\n\tor\n\tAUTORECONF=autoreconf-2.71 ./autogen.sh\n\tEOF\n\texit 1\nfi\n\necho \"$AUTORECONF identification: $AUTORECONFVERSION\"\n\n# configure.ac is an Autoconf 2.69 file, but it works as expected even with\n# Autoconf 2.72.  However, in Autoconf versions 2.70 and later obsolete\n# construct warnings are enabled by default, which adds varying (depending on\n# the branch) amount of noise to the build matrix output, so provide a means\n# to silence that.\nenv ${AUTOCONF_WARNINGS:+WARNINGS=\"$AUTOCONF_WARNINGS\"} \"$AUTORECONF\" -f\n\n# Autoconf 2.71 adds a blank line after the final \"exit 0\" on Linux, but not\n# on OpenBSD.  Remove this difference to make it easier to compare the result\n# of \"make releasetar\" across different platforms.  From sed one-liners:\n# \"delete all trailing blank lines at end of file (works on all seds)\".  Don't\n# use mktemp(1) because AIX does not have it.\nCONFIGURE_NEW=\"configure.new$$\"\nsed -e :a -e '/^\\n*$/{$d;N;ba' -e '}' <configure >\"$CONFIGURE_NEW\"\ncmp -s configure \"$CONFIGURE_NEW\" || cat \"$CONFIGURE_NEW\" >configure\nrm -f \"$CONFIGURE_NEW\"\n"
        },
        {
          "name": "bpf_dump.c",
          "type": "blob",
          "size": 1.873046875,
          "content": "/*\n * Copyright (c) 1992, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <pcap.h>\n#include <stdio.h>\n\n#include \"optimize.h\"\n\nvoid\nbpf_dump(const struct bpf_program *p, int option)\n{\n\tconst struct bpf_insn *insn;\n\tint i;\n\tint n = p->bf_len;\n\n\tinsn = p->bf_insns;\n\tif (option > 2) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (i = 0; i < n; ++insn, ++i) {\n\t\t\tprintf(\"%u %u %u %u\\n\", insn->code,\n\t\t\t       insn->jt, insn->jf, insn->k);\n\t\t}\n\t\treturn ;\n\t}\n\tif (option > 1) {\n\t\tfor (i = 0; i < n; ++insn, ++i)\n\t\t\tprintf(\"{ 0x%x, %d, %d, 0x%08x },\\n\",\n\t\t\t       insn->code, insn->jt, insn->jf, insn->k);\n\t\treturn;\n\t}\n\tfor (i = 0; i < n; ++insn, ++i) {\n#ifdef BDEBUG\n\t\tif (i < NBIDS && bids[i] > 0)\n\t\t\tprintf(\"[%02d]\", bids[i] - 1);\n\t\telse\n\t\t\tprintf(\" -- \");\n#endif\n\t\tputs(bpf_image(insn, i));\n\t}\n}\n"
        },
        {
          "name": "bpf_filter.c",
          "type": "blob",
          "size": 12.1328125,
          "content": "/*-\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * This code is derived from the Stanford/CMU enet packet filter,\n * (net/enet.c) distributed as part of 4.3BSD, and code contributed\n * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence\n * Berkeley Laboratory.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n *\t@(#)bpf.c\t7.5 (Berkeley) 7/15/91\n */\n\n#include <config.h>\n\n#include <pcap/pcap-inttypes.h>\n#include \"pcap-types.h\"\n#include \"extract.h\"\n#include \"diag-control.h\"\n\n#define EXTRACT_SHORT\tEXTRACT_BE_U_2\n#define EXTRACT_LONG\tEXTRACT_BE_U_4\n\n#ifndef _WIN32\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#endif /* _WIN32 */\n\n#include <pcap-int.h>\n\n#include <stdlib.h>\n\n#ifdef __linux__\n#include <linux/types.h>\n#include <linux/if_packet.h>\n#include <linux/filter.h>\n#endif\n\nenum {\n        BPF_S_ANC_NONE,\n        BPF_S_ANC_VLAN_TAG,\n        BPF_S_ANC_VLAN_TAG_PRESENT,\n};\n\n/*\n * Execute the filter program starting at pc on the packet p\n * wirelen is the length of the original packet\n * buflen is the amount of data present\n * aux_data is auxiliary data, currently used only when interpreting\n * filters intended for the Linux kernel in cases where the kernel\n * rejects the filter; it contains VLAN tag information\n * For the kernel, p is assumed to be a pointer to an mbuf if buflen is 0,\n * in all other cases, p is a pointer to a buffer and buflen is its size.\n *\n * Thanks to Ani Sinha <ani@arista.com> for providing initial implementation\n */\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\nu_int\npcapint_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,\n    u_int wirelen, u_int buflen, const struct pcap_bpf_aux_data *aux_data)\n#else\nu_int\npcapint_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,\n    u_int wirelen, u_int buflen, const struct pcap_bpf_aux_data *aux_data _U_)\n#endif\n{\n\tregister uint32_t A, X;\n\tregister bpf_u_int32 k;\n\n\tif (pc == 0)\n\t\t/*\n\t\t * No filter means accept all.\n\t\t */\n\t\treturn (u_int)-1;\n\tA = 0;\n\tX = 0;\n\tuint32_t mem[BPF_MEMWORDS] = {0};\n\t--pc;\n\tfor (;;) {\n\t\t++pc;\n\t\tswitch (pc->code) {\n\n\t\tdefault:\n\t\t\tabort();\n\t\tcase BPF_RET|BPF_K:\n\t\t\treturn (u_int)pc->k;\n\n\t\tcase BPF_RET|BPF_A:\n\t\t\treturn (u_int)A;\n\n\t\tcase BPF_LD|BPF_W|BPF_ABS:\n\t\t\tk = pc->k;\n\t\t\tif (k > buflen || sizeof(int32_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_LONG(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_H|BPF_ABS:\n\t\t\tk = pc->k;\n\t\t\tif (k > buflen || sizeof(int16_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_SHORT(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_B|BPF_ABS:\n\t\t\t/*\n\t\t\t * Yes, we know, this switch doesn't do\n\t\t\t * anything unless we're building for\n\t\t\t * a Linux kernel with removed VLAN\n\t\t\t * tags available as meta-data.\n\t\t\t */\nDIAG_OFF_DEFAULT_ONLY_SWITCH\n\t\t\tswitch (pc->k) {\n\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n\t\t\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\t\t\t\tif (!aux_data)\n\t\t\t\t\treturn 0;\n\t\t\t\tA = aux_data->vlan_tag;\n\t\t\t\tbreak;\n\n\t\t\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\t\t\tif (!aux_data)\n\t\t\t\t\treturn 0;\n\t\t\t\tA = aux_data->vlan_tag_present;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tk = pc->k;\n\t\t\t\tif (k >= buflen) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tA = p[k];\n\t\t\t\tbreak;\n\t\t\t}\nDIAG_ON_DEFAULT_ONLY_SWITCH\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_W|BPF_LEN:\n\t\t\tA = wirelen;\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_W|BPF_LEN:\n\t\t\tX = wirelen;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_W|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (pc->k > buflen || X > buflen - pc->k ||\n\t\t\t    sizeof(int32_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_LONG(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_H|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (X > buflen || pc->k > buflen - X ||\n\t\t\t    sizeof(int16_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_SHORT(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_B|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (pc->k >= buflen || X >= buflen - pc->k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = p[k];\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\t\tk = pc->k;\n\t\t\tif (k >= buflen) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tX = (p[pc->k] & 0xf) << 2;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_IMM:\n\t\t\tA = pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_IMM:\n\t\t\tX = pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_MEM:\n\t\t\tA = mem[pc->k];\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_MEM:\n\t\t\tX = mem[pc->k];\n\t\t\tcontinue;\n\n\t\tcase BPF_ST:\n\t\t\tmem[pc->k] = A;\n\t\t\tcontinue;\n\n\t\tcase BPF_STX:\n\t\t\tmem[pc->k] = X;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JA:\n\t\t\t/*\n\t\t\t * XXX - we currently implement \"ip6 protochain\"\n\t\t\t * with backward jumps, so sign-extend pc->k.\n\t\t\t */\n\t\t\tpc += (bpf_int32)pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGT|BPF_K:\n\t\t\tpc += (A > pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGE|BPF_K:\n\t\t\tpc += (A >= pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JEQ|BPF_K:\n\t\t\tpc += (A == pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JSET|BPF_K:\n\t\t\tpc += (A & pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGT|BPF_X:\n\t\t\tpc += (A > X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGE|BPF_X:\n\t\t\tpc += (A >= X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JEQ|BPF_X:\n\t\t\tpc += (A == X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JSET|BPF_X:\n\t\t\tpc += (A & X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_ADD|BPF_X:\n\t\t\tA += X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_SUB|BPF_X:\n\t\t\tA -= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MUL|BPF_X:\n\t\t\tA *= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_DIV|BPF_X:\n\t\t\tif (X == 0)\n\t\t\t\treturn 0;\n\t\t\tA /= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MOD|BPF_X:\n\t\t\tif (X == 0)\n\t\t\t\treturn 0;\n\t\t\tA %= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_AND|BPF_X:\n\t\t\tA &= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_OR|BPF_X:\n\t\t\tA |= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_XOR|BPF_X:\n\t\t\tA ^= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_LSH|BPF_X:\n\t\t\tif (X < 32)\n\t\t\t\tA <<= X;\n\t\t\telse\n\t\t\t\tA = 0;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\t\tif (X < 32)\n\t\t\t\tA >>= X;\n\t\t\telse\n\t\t\t\tA = 0;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_ADD|BPF_K:\n\t\t\tA += pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_SUB|BPF_K:\n\t\t\tA -= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MUL|BPF_K:\n\t\t\tA *= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_DIV|BPF_K:\n\t\t\tA /= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MOD|BPF_K:\n\t\t\tA %= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_AND|BPF_K:\n\t\t\tA &= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_OR|BPF_K:\n\t\t\tA |= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_XOR|BPF_K:\n\t\t\tA ^= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_LSH|BPF_K:\n\t\t\tA <<= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\t\tA >>= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_NEG:\n\t\t\t/*\n\t\t\t * Most BPF arithmetic is unsigned, but negation\n\t\t\t * can't be unsigned; respecify it as subtracting\n\t\t\t * the accumulator from 0U, so that 1) we don't\n\t\t\t * get compiler warnings about negating an unsigned\n\t\t\t * value and 2) don't get UBSan warnings about\n\t\t\t * the result of negating 0x80000000 being undefined.\n\t\t\t */\n\t\t\tA = (0U - A);\n\t\t\tcontinue;\n\n\t\tcase BPF_MISC|BPF_TAX:\n\t\t\tX = A;\n\t\t\tcontinue;\n\n\t\tcase BPF_MISC|BPF_TXA:\n\t\t\tA = X;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nu_int\npcapint_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,\n    u_int buflen)\n{\n\treturn pcapint_filter_with_aux_data(pc, p, wirelen, buflen, NULL);\n}\n\n/*\n * Return true if the 'fcode' is a valid filter program.\n * The constraints are that each jump be forward and to a valid\n * code, that memory accesses are within valid ranges (to the\n * extent that this can be checked statically; loads of packet\n * data have to be, and are, also checked at run time), and that\n * the code terminates with either an accept or reject.\n *\n * The kernel needs to be able to verify an application's filter code.\n * Otherwise, a bogus program could easily crash the system.\n */\nint\npcapint_validate_filter(const struct bpf_insn *f, int len)\n{\n\tu_int i, from;\n\tconst struct bpf_insn *p;\n\n\tif (len < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < (u_int)len; ++i) {\n\t\tp = &f[i];\n\t\tswitch (BPF_CLASS(p->code)) {\n\t\t/*\n\t\t * Check that memory operations use valid addresses.\n\t\t */\n\t\tcase BPF_LD:\n\t\tcase BPF_LDX:\n\t\t\tswitch (BPF_MODE(p->code)) {\n\t\t\tcase BPF_IMM:\n\t\t\t\tbreak;\n\t\t\tcase BPF_ABS:\n\t\t\tcase BPF_IND:\n\t\t\tcase BPF_MSH:\n\t\t\t\t/*\n\t\t\t\t * There's no maximum packet data size\n\t\t\t\t * in userland.  The runtime packet length\n\t\t\t\t * check suffices.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tcase BPF_MEM:\n\t\t\t\tif (p->k >= BPF_MEMWORDS)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_LEN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\t\tif (p->k >= BPF_MEMWORDS)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase BPF_ALU:\n\t\t\tswitch (BPF_OP(p->code)) {\n\t\t\tcase BPF_ADD:\n\t\t\tcase BPF_SUB:\n\t\t\tcase BPF_MUL:\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\tcase BPF_XOR:\n\t\t\tcase BPF_LSH:\n\t\t\tcase BPF_RSH:\n\t\t\tcase BPF_NEG:\n\t\t\t\tbreak;\n\t\t\tcase BPF_DIV:\n\t\t\tcase BPF_MOD:\n\t\t\t\t/*\n\t\t\t\t * Check for constant division or modulus\n\t\t\t\t * by 0.\n\t\t\t\t */\n\t\t\t\tif (BPF_SRC(p->code) == BPF_K && p->k == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_JMP:\n\t\t\t/*\n\t\t\t * Check that jumps are within the code block,\n\t\t\t * and that unconditional branches don't go\n\t\t\t * backwards as a result of an overflow.\n\t\t\t * Unconditional branches have a 32-bit offset,\n\t\t\t * so they could overflow; we check to make\n\t\t\t * sure they don't.  Conditional branches have\n\t\t\t * an 8-bit offset, and the from address is <=\n\t\t\t * BPF_MAXINSNS, and we assume that BPF_MAXINSNS\n\t\t\t * is sufficiently small that adding 255 to it\n\t\t\t * won't overflow.\n\t\t\t *\n\t\t\t * We know that len is <= BPF_MAXINSNS, and we\n\t\t\t * assume that BPF_MAXINSNS is < the maximum size\n\t\t\t * of a u_int, so that i + 1 doesn't overflow.\n\t\t\t *\n\t\t\t * For userland, we don't know that the from\n\t\t\t * or len are <= BPF_MAXINSNS, but we know that\n\t\t\t * from <= len, and, except on a 64-bit system,\n\t\t\t * it's unlikely that len, if it truly reflects\n\t\t\t * the size of the program we've been handed,\n\t\t\t * will be anywhere near the maximum size of\n\t\t\t * a u_int.  We also don't check for backward\n\t\t\t * branches, as we currently support them in\n\t\t\t * userland for the protochain operation.\n\t\t\t */\n\t\t\tfrom = i + 1;\n\t\t\tswitch (BPF_OP(p->code)) {\n\t\t\tcase BPF_JA:\n\t\t\t\tif (from + p->k >= (u_int)len)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JEQ:\n\t\t\tcase BPF_JGT:\n\t\t\tcase BPF_JGE:\n\t\t\tcase BPF_JSET:\n\t\t\t\tif (from + p->jt >= (u_int)len || from + p->jf >= (u_int)len)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET:\n\t\t\tbreak;\n\t\tcase BPF_MISC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn BPF_CLASS(f[len - 1].code) == BPF_RET;\n}\n\n/*\n * Exported because older versions of libpcap exported them.\n */\nu_int\nbpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,\n    u_int buflen)\n{\n\treturn pcapint_filter(pc, p, wirelen, buflen);\n}\n\nint\nbpf_validate(const struct bpf_insn *f, int len)\n{\n\treturn pcapint_validate_filter(f, len);\n}\n"
        },
        {
          "name": "bpf_image.c",
          "type": "blob",
          "size": 9.2939453125,
          "content": "/*\n * Copyright (c) 1990, 1991, 1992, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n\n#include <stdio.h>\n#include <string.h>\n\n#ifdef __linux__\n#include <linux/types.h>\n#include <linux/if_packet.h>\n#include <linux/filter.h>\n\n/*\n * We want our versions of these #defines, not Linux's version.\n * (The two should be the same; if not, we have a problem; all BPF\n * implementations *should* be source-compatible supersets of ours.)\n */\n#undef BPF_STMT\n#undef BPF_JUMP\n#endif\n\n#include \"pcap-int.h\"\n\n#include \"thread-local.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#ifdef SKF_AD_OFF\n/*\n * Symbolic names for offsets that refer to the special Linux BPF locations.\n */\nstatic const char *offsets[SKF_AD_MAX] = {\n#ifdef SKF_AD_PROTOCOL\n\t[SKF_AD_PROTOCOL] = \"proto\",\n#endif\n#ifdef SKF_AD_PKTTYPE\n\t[SKF_AD_PKTTYPE] = \"type\",\n#endif\n#ifdef SKF_AD_IFINDEX\n\t[SKF_AD_IFINDEX] = \"ifidx\",\n#endif\n#ifdef SKF_AD_NLATTR\n\t[SKF_AD_NLATTR] = \"nla\",\n#endif\n#ifdef SKF_AD_NLATTR_NEST\n\t[SKF_AD_NLATTR_NEST] = \"nlan\",\n#endif\n#ifdef SKF_AD_MARK\n\t[SKF_AD_MARK] = \"mark\",\n#endif\n#ifdef SKF_AD_QUEUE\n\t[SKF_AD_QUEUE] = \"queue\",\n#endif\n#ifdef SKF_AD_HATYPE\n\t[SKF_AD_HATYPE] = \"hatype\",\n#endif\n#ifdef SKF_AD_RXHASH\n\t[SKF_AD_RXHASH] = \"rxhash\",\n#endif\n#ifdef SKF_AD_CPU\n\t[SKF_AD_CPU] = \"cpu\",\n#endif\n#ifdef SKF_AD_ALU_XOR_X\n\t[SKF_AD_ALU_XOR_X] = \"xor_x\",\n#endif\n#ifdef SKF_AD_VLAN_TAG\n\t[SKF_AD_VLAN_TAG] = \"vlan_tci\",\n#endif\n#ifdef SKF_AD_VLAN_TAG_PRESENT\n\t[SKF_AD_VLAN_TAG_PRESENT] = \"vlanp\",\n#endif\n#ifdef SKF_AD_PAY_OFFSET\n\t[SKF_AD_PAY_OFFSET] = \"poff\",\n#endif\n#ifdef SKF_AD_RANDOM\n\t[SKF_AD_RANDOM] = \"random\",\n#endif\n#ifdef SKF_AD_VLAN_TPID\n\t[SKF_AD_VLAN_TPID] = \"vlan_tpid\"\n#endif\n};\n#endif\n\nstatic void\nbpf_print_abs_load_operand(char *buf, size_t bufsize, const struct bpf_insn *p)\n{\n#ifdef SKF_AD_OFF\n\tconst char *sym;\n\n\t/*\n\t * It's an absolute load.\n\t * Is the offset a special Linux offset that we know about?\n\t */\n\tif (p->k >= (bpf_u_int32)SKF_AD_OFF &&\n\t    p->k < (bpf_u_int32)(SKF_AD_OFF + SKF_AD_MAX) &&\n\t    (sym = offsets[p->k - (bpf_u_int32)SKF_AD_OFF]) != NULL) {\n\t\t/*\n\t\t * Yes.  Print the offset symbolically.\n\t\t */\n\t\t(void)snprintf(buf, bufsize, \"[%s]\", sym);\n\t} else\n#endif\n\t\t(void)snprintf(buf, bufsize, \"[%d]\", p->k);\n}\n\nchar *\nbpf_image(const struct bpf_insn *p, int n)\n{\n\tconst char *op;\n\tstatic thread_local char image[256];\n\tchar operand_buf[64];\n\tconst char *operand;\n\n\tswitch (p->code) {\n\n\tdefault:\n\t\top = \"unimp\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"0x%x\", p->code);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_RET|BPF_K:\n\t\top = \"ret\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_RET|BPF_A:\n\t\top = \"ret\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_ABS:\n\t\top = \"ld\";\n\t\tbpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_H|BPF_ABS:\n\t\top = \"ldh\";\n\t\tbpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_B|BPF_ABS:\n\t\top = \"ldb\";\n\t\tbpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_LEN:\n\t\top = \"ld\";\n\t\toperand = \"#pktlen\";\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_IND:\n\t\top = \"ld\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_H|BPF_IND:\n\t\top = \"ldh\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_B|BPF_IND:\n\t\top = \"ldb\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IMM:\n\t\top = \"ld\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_IMM:\n\t\top = \"ldx\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\top = \"ldxb\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"4*([%d]&0xf)\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_MEM:\n\t\top = \"ld\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MEM:\n\t\top = \"ldx\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ST:\n\t\top = \"st\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_STX:\n\t\top = \"stx\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JA:\n\t\top = \"ja\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"%d\", n + 1 + p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGT|BPF_K:\n\t\top = \"jgt\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGE|BPF_K:\n\t\top = \"jge\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JEQ|BPF_K:\n\t\top = \"jeq\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JSET|BPF_K:\n\t\top = \"jset\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGT|BPF_X:\n\t\top = \"jgt\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGE|BPF_X:\n\t\top = \"jge\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JEQ|BPF_X:\n\t\top = \"jeq\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JSET|BPF_X:\n\t\top = \"jset\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_X:\n\t\top = \"add\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_SUB|BPF_X:\n\t\top = \"sub\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MUL|BPF_X:\n\t\top = \"mul\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_DIV|BPF_X:\n\t\top = \"div\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MOD|BPF_X:\n\t\top = \"mod\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_AND|BPF_X:\n\t\top = \"and\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_OR|BPF_X:\n\t\top = \"or\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_XOR|BPF_X:\n\t\top = \"xor\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_LSH|BPF_X:\n\t\top = \"lsh\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\top = \"rsh\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_K:\n\t\top = \"add\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_SUB|BPF_K:\n\t\top = \"sub\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MUL|BPF_K:\n\t\top = \"mul\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_DIV|BPF_K:\n\t\top = \"div\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MOD|BPF_K:\n\t\top = \"mod\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_AND|BPF_K:\n\t\top = \"and\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_OR|BPF_K:\n\t\top = \"or\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_XOR|BPF_K:\n\t\top = \"xor\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_LSH|BPF_K:\n\t\top = \"lsh\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\top = \"rsh\";\n\t\t(void)snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_NEG:\n\t\top = \"neg\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TAX:\n\t\top = \"tax\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TXA:\n\t\top = \"txa\";\n\t\toperand = \"\";\n\t\tbreak;\n\t}\n\tif (BPF_CLASS(p->code) == BPF_JMP && BPF_OP(p->code) != BPF_JA) {\n\t\t(void)snprintf(image, sizeof image,\n\t\t\t      \"(%03d) %-8s %-16s jt %d\\tjf %d\",\n\t\t\t      n, op, operand, n + 1 + p->jt, n + 1 + p->jf);\n\t} else if (! *operand) {\n\t\t(void)snprintf(image, sizeof image,\n\t\t\t      \"(%03d) %-s\",\n\t\t\t      n, op);\n\t} else {\n\t\t(void)snprintf(image, sizeof image,\n\t\t\t      \"(%03d) %-8s %s\",\n\t\t\t      n, op, operand);\n\t}\n\treturn image;\n}\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 4.2412109375,
          "content": "#!/bin/sh -e\n\n# This script runs one build with setup environment variables: CC, CMAKE, IPV6\n# and REMOTE.\n: \"${CC:=gcc}\"\n: \"${CMAKE:=no}\"\n: \"${IPV6:=no}\"\n: \"${REMOTE:=no}\"\n: \"${LIBPCAP_TAINTED:=no}\"\n: \"${LIBPCAP_CMAKE_TAINTED:=no}\"\n: \"${MAKE_BIN:=make}\"\n# At least one OS (AIX 7) where this software can build does not have at least\n# one command (mktemp) required for a successful run of \"make releasetar\".\n: \"${TEST_RELEASETAR:=yes}\"\n\n. ./build_common.sh\n# Install directory prefix\nif [ -z \"$PREFIX\" ]; then\n    PREFIX=`mktempdir libpcap_build`\n    echo \"PREFIX set to '$PREFIX'\"\n    DELETE_PREFIX=yes\nfi\n\nprint_cc_version\n\n# The norm is to compile without any warnings, but libpcap builds on some OSes\n# are not warning-free for one or another reason.  If you manage to fix one of\n# these cases, please remember to remove respective exemption below to help any\n# later warnings in the same matrix subset trigger an error.\n# shellcheck disable=SC2221,SC2222\ncase `cc_id`/`os_id` in\ntcc-*/*)\n    # At least one warning is expected because TCC does not implement\n    # thread-local storage.\n    LIBPCAP_TAINTED=yes\n    ;;\n*)\n    ;;\nesac\n[ \"$LIBPCAP_TAINTED\" != yes ] && CFLAGS=`cc_werr_cflags`\n\ncase `cc_id`/`os_id` in\nclang-*/SunOS-5.11)\n    # Work around https://www.illumos.org/issues/16369\n    [ \"`uname -o`\" = illumos ] && grep -Fq OpenIndiana /etc/release && CFLAGS=\"-Wno-fuse-ld-path${CFLAGS:+ $CFLAGS}\"\n    ;;\nesac\n\n# If necessary, set LIBPCAP_CMAKE_TAINTED here to exempt particular cmake from\n# warnings. Use as specific terms as possible (e.g. some specific version and\n# some specific OS).\n\n[ \"$LIBPCAP_CMAKE_TAINTED\" != yes ] && CMAKE_OPTIONS='-Werror=dev'\n\nif [ \"$CMAKE\" = no ]; then\n    run_after_echo ./autogen.sh\n    run_after_echo ./configure --prefix=\"$PREFIX\" --enable-ipv6=\"$IPV6\" --enable-remote=\"$REMOTE\"\nelse\n    # Remove the leftovers from any earlier in-source builds, so this\n    # out-of-source build does not break because of that.\n    # https://gitlab.kitware.com/cmake/community/-/wikis/FAQ#what-is-an-out-of-source-build\n    # (The contents of build/ remaining after an earlier unsuccessful attempt\n    # can fail subsequent build attempts too, sometimes in non-obvious ways,\n    # so remove that directory as well.)\n    run_after_echo rm -rf CMakeFiles/ CMakeCache.txt build/\n    run_after_echo mkdir build\n    run_after_echo cd build\n    run_after_echo cmake --version\n    run_after_echo cmake ${CFLAGS:+-DEXTRA_CFLAGS=\"$CFLAGS\"} \\\n        ${CMAKE_OPTIONS:+\"$CMAKE_OPTIONS\"} \\\n        -DCMAKE_INSTALL_PREFIX=\"$PREFIX\" -DINET6=\"$IPV6\" -DENABLE_REMOTE=\"$REMOTE\" ..\nfi\nrun_after_echo \"$MAKE_BIN\" -s clean\nif [ \"$CMAKE\" = no ]; then\n    run_after_echo \"$MAKE_BIN\" -s ${CFLAGS:+CFLAGS=\"$CFLAGS\"}\n    run_after_echo \"$MAKE_BIN\" -s testprogs ${CFLAGS:+CFLAGS=\"$CFLAGS\"}\nelse\n    # The \"-s\" flag is a no-op and CFLAGS is set using -DEXTRA_CFLAGS above.\n    run_after_echo \"$MAKE_BIN\"\n    run_after_echo \"$MAKE_BIN\" testprogs\nfi\nrun_after_echo \"$MAKE_BIN\" install\n\nrun_after_echo \"$PREFIX/bin/pcap-config\" --help\nrun_after_echo \"$PREFIX/bin/pcap-config\" --version\nrun_after_echo \"$PREFIX/bin/pcap-config\" --cflags\nrun_after_echo \"$PREFIX/bin/pcap-config\" --libs\nrun_after_echo \"$PREFIX/bin/pcap-config\" --additional-libs\nrun_after_echo \"$PREFIX/bin/pcap-config\" --libs --static\nrun_after_echo \"$PREFIX/bin/pcap-config\" --additional-libs --static\nrun_after_echo \"$PREFIX/bin/pcap-config\" --libs --static-pcap-only\nrun_after_echo \"$PREFIX/bin/pcap-config\" --additional-libs --static-pcap-only\n\n[ \"$REMOTE\" = yes ] && run_after_echo \"$PREFIX/sbin/rpcapd\" -h\n\n# VALGRIND_CMD is meant either to collapse or to expand.\n# shellcheck disable=SC2086\nif [ \"$CMAKE\" = no ]; then\n    FILTERTEST_BIN=\"$VALGRIND_CMD testprogs/filtertest\"\n    export FILTERTEST_BIN\n    run_after_echo testprogs/TESTrun\n    run_after_echo $VALGRIND_CMD testprogs/findalldevstest\n    [ \"$TEST_RELEASETAR\" = yes ] && run_after_echo \"$MAKE_BIN\" releasetar\nelse\n    FILTERTEST_BIN=\"$VALGRIND_CMD run/filtertest\"\n    export FILTERTEST_BIN\n    CONFIG_H='./config.h'\n    export CONFIG_H\n    run_after_echo ../testprogs/TESTrun\n    run_after_echo $VALGRIND_CMD run/findalldevstest\nfi\nhandle_matrix_debug\nif [ \"$DELETE_PREFIX\" = yes ]; then\n    run_after_echo rm -rf \"$PREFIX\"\nfi\n# vi: set tabstop=4 softtabstop=0 expandtab shiftwidth=4 smarttab autoindent :\n"
        },
        {
          "name": "build_common.sh",
          "type": "blob",
          "size": 10.8076171875,
          "content": "#!/bin/sh -e\n\n# The only purpose of the above shebang is to orient shellcheck right.\n# To make CI scripts maintenance simpler, copies of this file in the\n# libpcap, tcpdump and tcpslice git repositories should be identical.\n# Please mind that Solaris /bin/sh before 11 does not support the $()\n# command substitution syntax, hence the \"-e SC2006\" flag in Makefile.\n\n# A poor man's mktemp(1) for OSes that don't have one (e.g. AIX 7, Solaris 9).\nmktempdir_diy() {\n    while true; do\n        # /bin/sh implements $RANDOM in AIX 7, but not in Solaris before 11,\n        # thus use dd and od instead.\n        mktempdir_diy_suffix=`dd if=/dev/urandom bs=4 count=1 2>/dev/null | od -t x -A n | head -1 | tr -d '\\t '`\n        [ -z \"$mktempdir_diy_suffix\" ] && return 1\n        mktempdir_diy_path=\"${TMPDIR:-/tmp}/${1:?}.${mktempdir_diy_suffix}\"\n        # \"test -e\" would be more appropriate, but it is not available in\n        # Solaris /bin/sh before 11.\n        if [ ! -d \"$mktempdir_diy_path\" ]; then\n            mkdir \"$mktempdir_diy_path\"\n            chmod go= \"$mktempdir_diy_path\"\n            echo \"$mktempdir_diy_path\"\n            break\n        fi\n        # Try again (very unlikely, just in case).\n    done\n}\n\nmktempdir() {\n    mktempdir_prefix=${1:-tmp}\n    case `os_id` in\n    Darwin-*|FreeBSD-*|NetBSD-*)\n        # In these operating systems mktemp(1) always appends an implicit\n        # \".XXXXXXXX\" suffix to the requested template when creating a\n        # temporary directory.\n        mktemp -d -t \"$mktempdir_prefix\"\n        ;;\n    SunOS-5.10|SunOS-5.11)\n        # Although the suffix is optional, specify it for consistent results.\n        mktemp -d -t \"${mktempdir_prefix}.XXXXXXXX\"\n        ;;\n    SunOS-*|AIX-*)\n        mktempdir_diy \"$mktempdir_prefix\"\n        ;;\n    *)\n        # At least Haiku, Linux and OpenBSD implementations require explicit\n        # trailing X'es in the template, so make it the same suffix as above.\n        # XXX - is MSYS2 GNU-based, so that it would be like Linux?\n        mktemp -d -t \"${mktempdir_prefix}.XXXXXXXX\"\n        ;;\n    esac\n}\n\nprint_sysinfo() {\n    uname -a\n    printf 'OS identification: '\n    os_id\n    date\n}\n\n# Try to make the current C compiler print its version information (usually\n# multi-line) to stdout.\ncc_version_nocache() {\n    : \"${CC:?}\"\n    case `basename \"$CC\"` in\n    gcc*|egcc*|clang*|tcc*)\n        # GCC and Clang recognize --version, print to stdout and exit with 0.\n        \"$CC\" --version\n        ;;\n    xl*)\n        # XL C 12.1 and 13.1 recognize \"-qversion\", print to stdout and exit\n        # with 0. XL C 12.1 on an unknown command-line flag displays its man\n        # page and waits.\n        # XL C 16.1 recognizes \"-qversion\" and \"--version\", prints to stdout\n        # and exits with 0. Community Edition also prints a banner to stderr.\n        \"$CC\" -qversion 2>/dev/null\n        ;;\n    sun*)\n        # Sun compilers recognize -V, print to stderr and exit with an error.\n        \"$CC\" -V 2>&1 || :\n        ;;\n    cc)\n        case `os_id` in\n        SunOS-*)\n            # Most likely Sun C.\n            \"$CC\" -V 2>&1 || :\n            ;;\n        Darwin-*)\n            # Most likely Clang.\n            \"$CC\" --version\n            ;;\n        Linux-*|FreeBSD-*|NetBSD-*|OpenBSD-*)\n            # Most likely Clang or GCC.\n            \"$CC\" --version\n            ;;\n        esac\n        ;;\n    cl)\n        # Visual Studio's compiler doesn't have a \"print the compiler\n        # version\" option, but we can get version information by\n        # running it with no options, sending its standard error to\n        # the standard output, and throwing out the usage message;\n        # as we have MSYS2, we can just \"head\" it out.\n        #\n        # XXX - does it exit with an error?\n        \"$CC\" 2>&1 | head -2\n        ;;\n    *)\n        \"$CC\" --version || \"$CC\" -V || :\n        ;;\n    esac\n}\n\ncc_version() {\n    echo \"${cc_version_cached:=`cc_version_nocache`}\"\n}\n\nprint_cc_version() {\n    cc_version\n    printf 'Compiler identification: '\n    cc_id\n}\n\n# For the current C compiler try to print a short and uniform identification\n# string (such as \"gcc-9.3.0\") that is convenient to use in a case statement.\ncc_id_nocache() {\n    cc_id_firstline=`cc_version | head -1`\n    : \"${cc_id_firstline:?}\"\n\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^.*clang version \\([0-9\\.]*\\).*$/clang-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^IBM XL C.*, V\\([0-9\\.]*\\).*$/xlc-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^.* Sun C \\([0-9\\.]*\\) .*$/suncc-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^Microsoft (R) C\\/C++ Optimizing Compiler Version \\([0-9\\.]*\\) .*$/msvc-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n\n    # Examples of installed packages:\n    # \"tcc version 0.9.27 (x86_64 Linux)\"\n    # \"tcc version 0.9.27 2023-07-05 mob@5b28165 (x86_64 OpenBSD)\"\n    # Example of a development version:\n    # \"tcc version 0.9.28rc 2024-04-28 mob@0aca8611 (x86_64 Linux)\"\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^.*tcc version \\([0-9\\.rc]*\\).*$/tcc-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n\n    # OpenBSD default GCC:\n    # \"gcc (GCC) 4.2.1 20070719\"\n    # RedHat GCC:\n    # \"gcc (GCC) 8.3.1 20190223 (Red Hat 8.3.1-2)\"\n    # \"gcc (GCC) 10.3.1 20210422 (Red Hat 10.3.1-1)\"\n    # other GCC packages:\n    # \"sparc-sun-solaris2.9-gcc (GCC) 4.2.0 (gccfss)\"\n    # \"gcc (GCC) 5.5.0\"\n    # \"gcc (nb4 20200810) 7.5.0\"\n    # \"gcc (OpenIndiana 7.5.0-il-0) 7.5.0\"\n    # \"gcc (Debian 8.3.0-6) 8.3.0\"\n    # \"gcc (Raspbian 8.3.0-6+rpi1) 8.3.0\"\n    # \"egcc (GCC) 8.4.0\"\n    # \"gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0\"\n    # \"gcc (FreeBSD Ports Collection) 10.3.0\"\n    cc_id_guessed=`echo \"$cc_id_firstline\" | sed 's/^.* (.*) \\([0-9\\.]*\\).*$/gcc-\\1/'`\n    if [ \"$cc_id_firstline\" != \"$cc_id_guessed\" ]; then\n        echo \"$cc_id_guessed\"\n        return\n    fi\n}\n\ncc_id() {\n    echo \"${cc_id_cached:=`cc_id_nocache`}\"\n}\n\n# Call this function each time CC has changed.\ndiscard_cc_cache() {\n    cc_version_cached=\n    cc_id_cached=\n}\n\n# For the current C compiler try to print CFLAGS value that tells to treat\n# warnings as errors.\ncc_werr_cflags() {\n    case `cc_id` in\n    gcc-*|clang-*|tcc-*)\n        echo '-Werror'\n        ;;\n    xlc-*)\n        # XL C 12.1 and 13.1 recognize \"-qhalt=w\". XL C 16.1 recognizes that\n        # and \"-Werror\".\n        echo '-qhalt=w'\n        ;;\n    suncc-*)\n        # GCC and Clang print an identification for every warning, which is\n        # useful for root cause analysis and bug fixing.  Sun C does not do it\n        # by default, but an additional option makes the style more consistent.\n        echo '-errwarn=%all -errtags=yes'\n        ;;\n    msvc-*)\n        # XXX - what?\n        echo ''\n        ;;\n    esac\n}\n\n# Tell whether \"gcc\" is a symlink to Clang (this is the case on macOS).\ngcc_is_clang_in_disguise() {\n    case `cc_id`/`basename \"${CC:?}\"` in\n    clang-*/gcc)\n        return 0\n        ;;\n    esac\n    return 1\n}\n\nos_id() {\n    # OS does not change between builds or in the middle of a build, so it is\n    # fine to cache uname output.\n    : \"${os_id_sysname:=`uname -s`}\"\n    printf '%s-' \"$os_id_sysname\"\n    : \"${os_id_release:=`uname -r`}\"\n    case \"$os_id_sysname\" in\n    AIX)\n        : \"${os_id_version:=`uname -v`}\"\n        echo \"${os_id_version}.${os_id_release}\"\n        ;;\n    Darwin|GNU|OpenBSD|SunOS)\n        echo \"$os_id_release\"\n        ;;\n    FreeBSD|NetBSD|Linux)\n        # Meaningful version is usually the substring before the first dash.\n        # Or the first underscore.\n        echo \"$os_id_release\" | sed 's/^\\([0-9\\.]*\\).*$/\\1/'\n        ;;\n    Haiku)\n        # The complete version is a substring before the first space, e.g.:\n        # * \"hrevNNNNN\" for a release without updates, e.g. hrev56578 for\n        #   R1/beta4, also for a clean build of master branch;\n        # * \"hrevNNNNN+MM\" for a release with updates;\n        # * \"hrevNNNNN-MM\" for a build of a branch that is ahead of the master\n        #   branch;\n        # * \"hrevNNNNN_MMMM_KK\" for a CI build of a Gerrit review;\n        # * something else for a build of a working copy with the changes not\n        #   yet committed.\n        # With this system it is not clear which version components would be\n        # meaningful to relate with the build result, so let's return the\n        # complete version and leave any interpretation to the user.\n        : \"${os_id_version:=`uname -v`}\"\n        echo \"$os_id_version\" | sed -E 's/^(hrev[^ ]+).+$/\\1/'\n        ;;\n    MSYS*)\n        # uname -s produces \"MSYS_NT-{NT version?}-{build?}\n        # uname -r produces MSYS2 version?\n        echo \"$os_id_version\", MSYS \"$os_id_release\"\n        ;;\n    *)\n        echo 'UNKNOWN'\n        ;;\n    esac\n}\n\nincrement() {\n    # No arithmetic expansion in Solaris /bin/sh before 11.\n    # shellcheck disable=SC2003\n    expr \"${1:?}\" + 1\n}\n\n# Display text in magenta.\necho_magenta() {\n    # ANSI magenta, the imploded text, ANSI reset, newline.\n    printf '\\033[35;1m%s\\033[0m\\n' \"$*\"\n}\n\n# Run a command after displaying it.\nrun_after_echo() {\n    : \"${1:?}\" # Require at least one argument.\n    printf '$ %s\\n' \"$*\"\n    \"$@\"\n}\n\nprint_so_deps() {\n    case `os_id` in\n    Darwin-*)\n        run_after_echo otool -L \"${1:?}\"\n        ;;\n    Haiku-*)\n        run_after_echo objdump -p \"${1:?}\"\n        ;;\n    MSYS*)\n        run_after_echo dumpbin /dependents \"${1:?}\"\n        ;;\n    *)\n        run_after_echo ldd \"${1:?}\"\n        ;;\n    esac\n}\n\n# Beware that setting MATRIX_DEBUG for tcpdump or tcpslice will produce A LOT\n# of additional output there and in any nested libpcap builds. Multiplied by\n# the matrix size, the full output log size might exceed limits of some CI\n# systems (as it had previously happened with Travis CI). Use with caution on\n# a reduced matrix.\nhandle_matrix_debug() {\n    [ \"$MATRIX_DEBUG\" != yes ] && return\n    echo '$ cat Makefile [...]'\n    sed '/^# DO NOT DELETE THIS LINE -- mkdep uses it.$/q' <Makefile\n    run_after_echo cat config.h\n    [ \"$CMAKE\" = yes ] || run_after_echo cat config.log\n}\n\npurge_directory() {\n    if [ \"`os_id`\" = SunOS-5.11 ]; then\n        # In Solaris 11 /bin/sh the pathname expansion of \"*\" always includes\n        # \".\" and \"..\", so the straightforward rm would always fail.\n        (\n            cd \"${1:?}\"\n            for pd_each in *; do\n                if [ \"$pd_each\" != . ] && [ \"$pd_each\" != .. ]; then\n                    rm -rf \"$pd_each\"\n                fi\n            done\n        )\n    else\n        rm -rf \"${1:?}\"/*\n    fi\n}\n\n# vi: set tabstop=4 softtabstop=0 expandtab shiftwidth=4 smarttab autoindent :\n"
        },
        {
          "name": "build_matrix.sh",
          "type": "blob",
          "size": 2.9443359375,
          "content": "#!/bin/sh -e\n\n# This script executes the matrix loops, exclude tests and cleaning.\n# The matrix can be configured with the following environment variables:\n# MATRIX_CC, MATRIX_CMAKE, MATRIX_IPV6 and MATRIX_REMOTE.\n: \"${MATRIX_CC:=gcc clang}\"\n: \"${MATRIX_CMAKE:=no yes}\"\n: \"${MATRIX_IPV6:=no yes}\"\n: \"${MATRIX_REMOTE:=no yes}\"\n# Set this variable to \"yes\" before calling this script to disregard all cmake\n# warnings in a particular environment (CI or a local working copy).  Set it\n# to \"yes\" in this script or in build.sh when a matrix subset is known to be\n# not cmake warning-free because of the version or whatever other factor\n# that the scripts can detect both in and out of CI.\n: \"${LIBPCAP_CMAKE_TAINTED:=no}\"\n# Set this variable to \"yes\" before calling this script to disregard all\n# warnings in a particular environment (CI or a local working copy).  Set it\n# to \"yes\" in this script or in build.sh when a matrix subset is known to be\n# not warning-free because of the OS, the compiler or whatever other factor\n# that the scripts can detect both in and out of CI.\n: \"${LIBPCAP_TAINTED:=no}\"\n# Some OSes have native make without parallel jobs support and sometimes have\n# GNU Make available as \"gmake\".\n: \"${MAKE_BIN:=make}\"\n# It calls the build.sh script which runs one build with setup environment\n# variables: CC, CMAKE, IPV6 and REMOTE.\n\n. ./build_common.sh\nprint_sysinfo\n# Install directory prefix\nif [ -z \"$PREFIX\" ]; then\n    PREFIX=`mktempdir libpcap_build_matrix`\n    echo \"PREFIX set to '$PREFIX'\"\n    export PREFIX\nfi\nCOUNT=0\nexport LIBPCAP_TAINTED\nexport LIBPCAP_CMAKE_TAINTED\nif command -v valgrind >/dev/null 2>&1; then\n    valgrind --version\n    VALGRIND_CMD=\"valgrind --leak-check=full --error-exitcode=1 --quiet\"\n    export VALGRIND_CMD\n    # With Valgrind filtertest takes significantly longer to complete.\n    : \"${FILTERTEST_TIMEOUT:=5}\"\n    export FILTERTEST_TIMEOUT\nfi\n\nrun_after_echo git show --oneline -s | cat\ntouch .devel\nfor CC in $MATRIX_CC; do\n    export CC\n    discard_cc_cache\n    if gcc_is_clang_in_disguise; then\n        echo '(skipped)'\n        continue\n    fi\n    for CMAKE in $MATRIX_CMAKE; do\n        export CMAKE\n        for IPV6 in $MATRIX_IPV6; do\n            export IPV6\n            for REMOTE in $MATRIX_REMOTE; do\n                export REMOTE\n                COUNT=`increment \"$COUNT\"`\n                echo_magenta \"===== SETUP $COUNT: CC=$CC CMAKE=$CMAKE IPV6=$IPV6 REMOTE=$REMOTE =====\" >&2\n                # Run one build with setup environment variables: CC, CMAKE,\n                # IPV6 and REMOTE\n                run_after_echo ./build.sh\n                echo 'Cleaning...'\n                if [ \"$CMAKE\" = yes ]; then rm -rf build; else \"$MAKE_BIN\" distclean; fi\n                purge_directory \"$PREFIX\"\n                run_after_echo git status -suall\n            done\n        done\n    done\ndone\nrun_after_echo rm -rf \"$PREFIX\"\necho_magenta \"Tested setup count: $COUNT\" >&2\n# vi: set tabstop=4 softtabstop=0 expandtab shiftwidth=4 smarttab autoindent :\n"
        },
        {
          "name": "cbpf-savefile.manfile.in",
          "type": "blob",
          "size": 9.9423828125,
          "content": ".\\\" Copyright (c) 2022\n.\\\"\tThe TCPDUMP project.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH CBPF-SAVEFILE @MAN_FILE_FORMATS@ \"17 July 2022\"\n.SH NAME\ncbpf-savefile \\- cBPF savefile format (work in progress, DRAFT revision 6)\n.SH DESCRIPTION\nThis man page discusses a file format for cBPF, which is the \"classic\" (and\nfor a long time the only) Berkeley Packet Filter.  It does\n.B NOT\napply to the newer \"extended\" variety of BPF (eBPF).\n.LP\nThe main purpose of this file format is to store BPF bytecode, most commonly\ncompiled from a BPF filter expression (see\n.BR \\%pcap-filter (7)\nfor the filter syntax description) using libpcap.  Besides that, the format\nallows to encode some information about the context in which the compilation\nwas done.  This meta-data can make it easier to reproduce the compilation\nlater if required.  cBPF savefile design is based on the file format proposed\nby C.S. Peron in 2005.\n.LP\nUnless stated otherwise, in the following specification integer fields are\nbig-endian unsigned, string fields do not use NUL character for termination\nor padding.\n\n.SH FILE FORMAT\nA savefile consists of a fixed-size header and a variable-size body as\nfollows:\n.LP\n.nf\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0xA1     |      0xB2     |     0xC3      |     0xCB      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      'c'      |      'B'      |     'P'       |     'F'       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   MajorVer=1  |    MinorVer   |             Flags             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            SnapLen                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         LinkTypeValue         |       InstructionCount=n      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         instruction 1                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         instruction 2                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                                                               ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         instruction n                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                   optional trailing TLV space                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.fi\n.LP\nThe first four octets contain a fixed signature, also known as\na magic number, to make it easy to identify the file type automatically.\nThe next four octets contain the ASCII string \"cBPF\" to provide a hint for\nmanual identification.\n\n.SS MajorVer and MinorVer\nContain the major and the minor version numbers of this format respectively.\nThe current major version is 1 and the current minor version is 0.  Format\nchanges that do not impact compatibility (e.g., new TLV types or flags)\nincrement the minor version only.  Other format changes increment the major\nversion and reset the minor version to 0.  All format versions have the first\npart of the header up to and including MinorVer identical.\n\n.SS Flags\n.nf\n b15 b14 b13 b12 b11 b10 b09 b08 b07 b06 b05 b04 b03 b02 b01 b00\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|                       reserved                |CPX|COP|XOR|MOD|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n.fi\n\nMOD, XOR, COP and CPX: if set to 1, in this BPF dialect\n.BR BPF_MOD ,\n.BR BPF_XOR ,\n.B BPF_COP\nand\n.B BPF_COPX\nrespectively are valid instructions.  For the current list of OSes that\nsupport\n.B BPF_MOD\nand\n.B BPF_XOR\nin the kernel see the\n.B %\nand\n.B ^\nbinary operators in\n.BR \\%pcap-filter (7).\n.B BPF_COP\nand\n.B BPF_COPX\nare implemented in NetBSD kernel.\n.LP\nNote that the fact an instruction is valid in a BPF dialect does not always\nmean the compiled bytecode in the savefile contains the instruction.  In other\nwords, the purpose of the flags above is not to provide a digest of the file\ncontents, but to enable conclusive automatic verification of the bytecode if\nrequired by the use case.\n\n\n.SS SnapLen\nContains the snapshot length used for the compilation, usually this is the\n.I snaplen\ninput argument to\n.BR pcap_open_dead (3PCAP)\nor\n.BR pcap_set_snaplen (3PCAP).\n\n.SS LinkTypeValue\nContains the link-layer header type value used for the compilation, usually\nthis is either the\n.I linktype\ninput argument to\n.BR pcap_open_dead ()\nor the\n.I dlt\ninput argument to\n.BR pcap_set_datalink (3PCAP)\nor the value(s) returned by\n.BR pcap_datalink (3PCAP)\nand\n.BR pcap_list_datalinks (3PCAP).\nAlthough these functions take and return link-layer header type values via the\n.B int\nC type, by convention only the low 16 bits are in use.\n\n.SS InstructionCount\nThis is the last field of the fixed header in major version 1, it contains the\nnumber of bytecode instructions following the header.  By convention, valid\nBPF bytecode always ends with a\n.B ret\ninstruction, so in a valid savefile this field value is at least 1.\n\n.PP\nThe file format thus far minimizes the overhead for software that uses the BPF\nbytecode.  If there is any data after the last instruction, it is the trailing\nTLV space, which mostly contains meta-data for human interpretation.  It\ncontains TLVs in the format specified below.\n\n.SH INSTRUCTION FORMAT\n.LP\n.nf\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             opcode            |       jt      |       jf      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               k                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.fi\n.LP\nThis is the traditional encoding of a BPF instruction (a 4-tuple of\nintegers).  Note that usually the endianness depends on the machine, but in\nthis format it is fixed.  Some opcodes interpret k as a signed integer.\n\n.SH TLV FORMAT\n.LP\n.nf\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Type             |            Length=m           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                        Value (m octets)                       ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.fi\n.LP\nAll TLVs are optional.  Every TLV may appear in the same savefile at most\nonce.  Length value does not include Type and Length.  Code points for Type\nand the associated Length constraints are defined below.\n\n.SS EOF TLV\nAllows to mark the end of TLV space (hence of the savefile) explicitly to make it\nclear that the file is not truncated.  If this TLV is present in the TLV\nspace, it may appear the last only.\n.LP\nType is 0, Length is 0, Value is empty.\n\n.SS LinkTypeName TLV\nAllows to record the input argument to\n.BR pcap_datalink_name_to_val (3PCAP)\nif the latter was used to translate a DLT name into LinkTypeValue (the same\nname can sometimes produce different values in different contexts).\n.LP\nType is 1, Length is variable, Value contains an ASCII string.\n\n.SS Filter TLV\nAllows to record the filter expression that was compiled into the\nbytecode, usually this is the\n.I str\ninput argument to\n.BR pcap_compile (3PCAP).\n.LP\nType is 2, Length is variable, Value contains an ASCII string.\n\n.SS OptReq TLV\nAllows to record whether optimization was requested for the compilation or\nnot, usually this is the\n.I optimize\ninput argument to\n.BR pcap_compile ().\nNote that some link-layer header types and filter keywords disable the\noptimization automatically in libpcap.\n.LP\nType is 3, Length is 1, Value contains 1 or 0.\n\n.SS Netmask TLV\nAllows to record the value of\n.I netmask\ninput argument to\n.BR pcap_compile ().\n.LP\nType is 4, Length is 4, Value contains a 32-bit IPv4 netmask.\n\n.SS Comment TLV\nAllows to record a free-form text, for example, the name and version of the\nprogram that generated the file.\n.LP\nType is 5, Length is variable, Value contains a UTF-8 string.\n\n.SS Timestamp TLV\nAllows to record when the compilation was performed.\n.LP\nType is 6, Length is 8, Value contains a 64-bit Unix timestamp.\n\n.SH SOFTWARE SUPPORT\nBPF Exam at\n.I \\%https://www.tcpdump.org/bpfexam/\ncan produce a cBPF savefile from user input.\n\n.SH SEE ALSO\n.BR \\%pcap-savefile (@MAN_FILE_FORMATS@)\n"
        },
        {
          "name": "charconv.c",
          "type": "blob",
          "size": 6.3505859375,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifdef _WIN32\n#include <stdio.h>\n#include <errno.h>\n\n#include <pcap/pcap.h>\t/* Needed for PCAP_ERRBUF_SIZE */\n\n#include \"charconv.h\"\n\nwchar_t *\ncp_to_utf_16le(UINT codepage, const char *cp_string, DWORD flags)\n{\n\tint utf16le_len;\n\twchar_t *utf16le_string;\n\n\t/*\n\t * Map from the specified code page to UTF-16LE.\n\t * First, find out how big a buffer we'll need.\n\t */\n\tutf16le_len = MultiByteToWideChar(codepage, flags, cp_string, -1,\n\t    NULL, 0);\n\tif (utf16le_len == 0) {\n\t\t/*\n\t\t * Error.  Fail with EINVAL.\n\t\t */\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now attempt to allocate a buffer for that.\n\t */\n\tutf16le_string = malloc(utf16le_len * sizeof (wchar_t));\n\tif (utf16le_string == NULL) {\n\t\t/*\n\t\t * Not enough memory; assume errno has been\n\t\t * set, and fail.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now convert.\n\t */\n\tutf16le_len = MultiByteToWideChar(codepage, flags, cp_string, -1,\n\t    utf16le_string, utf16le_len);\n\tif (utf16le_len == 0) {\n\t\t/*\n\t\t * Error.  Fail with EINVAL.\n\t\t * XXX - should this ever happen, given that\n\t\t * we already ran the string through\n\t\t * MultiByteToWideChar() to find out how big\n\t\t * a buffer we needed?\n\t\t */\n\t\tfree(utf16le_string);\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\treturn (utf16le_string);\n}\n\nchar *\nutf_16le_to_cp(UINT codepage, const wchar_t *utf16le_string)\n{\n\tint cp_len;\n\tchar *cp_string;\n\n\t/*\n\t * Map from UTF-16LE to the specified code page.\n\t * First, find out how big a buffer we'll need.\n\t * We convert composite characters to precomposed characters,\n\t * as that's what Windows expects.\n\t */\n\tcp_len = WideCharToMultiByte(codepage, WC_COMPOSITECHECK,\n\t    utf16le_string, -1, NULL, 0, NULL, NULL);\n\tif (cp_len == 0) {\n\t\t/*\n\t\t * Error.  Fail with EINVAL.\n\t\t */\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now attempt to allocate a buffer for that.\n\t */\n\tcp_string = malloc(cp_len * sizeof (char));\n\tif (cp_string == NULL) {\n\t\t/*\n\t\t * Not enough memory; assume errno has been\n\t\t * set, and fail.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now convert.\n\t */\n\tcp_len = WideCharToMultiByte(codepage, WC_COMPOSITECHECK,\n\t    utf16le_string, -1, cp_string, cp_len, NULL, NULL);\n\tif (cp_len == 0) {\n\t\t/*\n\t\t * Error.  Fail with EINVAL.\n\t\t * XXX - should this ever happen, given that\n\t\t * we already ran the string through\n\t\t * WideCharToMultiByte() to find out how big\n\t\t * a buffer we needed?\n\t\t */\n\t\tfree(cp_string);\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\treturn (cp_string);\n}\n\n/*\n * Convert an error message string from UTF-8 to the local code page, as\n * best we can.\n *\n * The buffer is assumed to be PCAP_ERRBUF_SIZE bytes long; we truncate\n * if it doesn't fit.\n */\nvoid\nutf_8_to_acp_truncated(char *errbuf)\n{\n\twchar_t *utf_16_errbuf;\n\tint retval;\n\tDWORD err;\n\n\t/*\n\t * Do this by converting to UTF-16LE and then to the local\n\t * code page.  That means we get to use Microsoft's\n\t * conversion routines, rather than having to understand\n\t * all the code pages ourselves, *and* that this routine\n\t * can convert in place.\n\t */\n\n\t/*\n\t * Map from UTF-8 to UTF-16LE.\n\t * First, find out how big a buffer we'll need.\n\t * Convert any invalid characters to REPLACEMENT CHARACTER.\n\t */\n\tutf_16_errbuf = cp_to_utf_16le(CP_UTF8, errbuf, 0);\n\tif (utf_16_errbuf == NULL) {\n\t\t/*\n\t\t * Error.  Give up.\n\t\t */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Can't convert error string to the local code page\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Now, convert that to the local code page.\n\t * Use the current thread's code page.  For unconvertible\n\t * characters, let it pick the \"best fit\" character.\n\t *\n\t * XXX - we'd like some way to do what utf_16le_to_utf_8_truncated()\n\t * does if the buffer isn't big enough, but we don't want to have\n\t * to handle all local code pages ourselves; doing so requires\n\t * knowledge of all those code pages, including knowledge of how\n\t * characters are formed in those code pages so that we can avoid\n\t * cutting a multi-byte character into pieces.\n\t *\n\t * Converting to an un-truncated string using Windows APIs, and\n\t * then copying to the buffer, still requires knowledge of how\n\t * characters are formed in the target code page.\n\t */\n\tretval = WideCharToMultiByte(CP_THREAD_ACP, 0, utf_16_errbuf, -1,\n\t    errbuf, PCAP_ERRBUF_SIZE, NULL, NULL);\n\tif (retval == 0) {\n\t\terr = GetLastError();\n\t\tfree(utf_16_errbuf);\n\t\tif (err == ERROR_INSUFFICIENT_BUFFER)\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The error string, in the local code page, didn't fit in the buffer\");\n\t\telse\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't convert error string to the local code page\");\n\t\treturn;\n\t}\n\tfree(utf_16_errbuf);\n}\n#endif\n"
        },
        {
          "name": "charconv.h",
          "type": "blob",
          "size": 2.1611328125,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef charconv_h\n#define charconv_h\n\n#ifdef _WIN32\nextern wchar_t *cp_to_utf_16le(UINT codepage, const char *cp_string, DWORD flags);\nextern char *utf_16le_to_cp(UINT codepage, const wchar_t *utf16le_string);\nextern void utf_8_to_acp_truncated(char *);\n#endif\n\n#endif /* charconv_h */\n"
        },
        {
          "name": "chmod_bpf",
          "type": "blob",
          "size": 0.7392578125,
          "content": "#! /bin/sh\n\n#\n# Unfortunately, macOS's devfs is based on the old FreeBSD\n# one, not the current one, so there's no way to configure it\n# to create BPF devices with particular owners or groups.\n# This startup item will make it owned by the admin group,\n# with permissions rw-rw----, so that anybody in the admin\n# group can use programs that capture or send raw packets.\n#\n# Change this as appropriate for your site, e.g. to make\n# it owned by a particular user without changing the permissions,\n# so only that user and the super-user can capture or send raw\n# packets, or give it the permissions rw-r-----, so that\n# only the super-user can send raw packets but anybody in the\n# admin group can capture packets.\n#\nchgrp admin /dev/bpf*\nchmod g+rw /dev/bpf*\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 1.0107421875,
          "content": "if(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n  message(FATAL_ERROR \"Cannot find install manifest: @CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\nendif(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n\nfile(READ \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n  message(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n  if(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    exec_program(\n      \"@CMAKE_COMMAND@\" ARGS \"-E remove \\\"$ENV{DESTDIR}${file}\\\"\"\n      OUTPUT_VARIABLE rm_out\n      RETURN_VALUE rm_retval\n      )\n    if(NOT \"${rm_retval}\" STREQUAL 0)\n      message(FATAL_ERROR \"Problem when removing $ENV{DESTDIR}${file}\")\n    endif(NOT \"${rm_retval}\" STREQUAL 0)\n  else(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    message(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n  endif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\nendforeach(file)\n"
        },
        {
          "name": "cmakeconfig.h.in",
          "type": "blob",
          "size": 8.7919921875,
          "content": "/* cmakeconfig.h.in */\n\n/* Define to 1 if arpa/inet.h declares `ether_hostton' */\n#cmakedefine ARPA_INET_H_DECLARES_ETHER_HOSTTON 1\n\n/* Enable optimizer debugging */\n#cmakedefine BDEBUG 1\n\n/* Define to 1 if remote packet capture is to be supported */\n#cmakedefine ENABLE_REMOTE 1\n\n/* define if we have the AIX getnetbyname_r() */\n#cmakedefine HAVE_AIX_GETNETBYNAME_R 1\n\n/* define if we have the AIX getprotobyname_r() */\n#cmakedefine HAVE_AIX_GETPROTOBYNAME_R 1\n\n/* Define to 1 if you have the `asprintf' function. */\n#cmakedefine HAVE_ASPRINTF 1\n\n/* Define to 1 if you have the <config/HaikuConfig.h> header file. */\n#cmakedefine HAVE_CONFIG_HAIKUCONFIG_H 1\n\n/* define if you have the DAG API */\n#cmakedefine HAVE_DAG_API 1\n\n/* define if you have vdag_set_device_info() */\n#cmakedefine HAVE_DAG_VDAG 1\n\n/* Define to 1 if DAG transmit support is enabled */\n#cmakedefine ENABLE_DAG_TX 1\n\n/* Define to 1 if you have the declaration of `ether_hostton' */\n#cmakedefine HAVE_DECL_ETHER_HOSTTON 1\n\n/* Define to 1 if `dl_module_id_1' is a member of `dl_hp_ppa_info_t'. */\n#cmakedefine HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1 1\n\n/* Define to 1 if the system has the type `dl_passive_req_t'. */\n#cmakedefine HAVE_DL_PASSIVE_REQ_T 1\n\n/* Define to 1 if you have the `ether_hostton' function. */\n#cmakedefine HAVE_ETHER_HOSTTON 1\n\n/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */\n#cmakedefine HAVE_FSEEKO 1\n\n/* Define to 1 if you have the `getspnam' function. */\n#cmakedefine HAVE_GETSPNAM 1\n\n/* Define to 1 if you have a GNU-style `strerror_r' function. */\n#cmakedefine HAVE_GNU_STRERROR_R 1\n\n/* on HP-UX 10.20 or later */\n#cmakedefine HAVE_HPUX10_20_OR_LATER 1\n\n/* Define to 1 if you have the <hurd.h> header file. */\n#cmakedefine HAVE_HURD_H 1\n\n/* if libdlpi exists */\n#cmakedefine HAVE_LIBDLPI 1\n\n/* if libnl exists */\n#cmakedefine HAVE_LIBNL 1\n\n/* Define to 1 if you have the <linux/compiler.h> header file. */\n#cmakedefine HAVE_LINUX_COMPILER_H 1\n\n/* define if we have the Linux getnetbyname_r() */\n#cmakedefine HAVE_LINUX_GETNETBYNAME_R 1\n\n/* define if we have the Linux getprotobyname_r() */\n#cmakedefine HAVE_LINUX_GETPROTOBYNAME_R 1\n\n/* Define to 1 if you have the <linux/net_tstamp.h> header file. */\n#cmakedefine HAVE_LINUX_NET_TSTAMP_H 1\n\n/* Define to 1 if you have the <linux/socket.h> header file. */\n#cmakedefine HAVE_LINUX_SOCKET_H 1\n\n/* Define to 1 if you have the <linux/usbdevice_fs.h> header file. */\n#cmakedefine HAVE_LINUX_USBDEVICE_FS_H 1\n\n/* Define to 1 if you have the <netpacket/packet.h> header file. */\n#cmakedefine HAVE_NETPACKET_PACKET_H 1\n\n/* Define to 1 if you have the <net/bpf.h> header file. */\n#cmakedefine HAVE_NET_BPF_H 1\n\n/* Define to 1 if you have the <net/if_media.h> header file. */\n#cmakedefine HAVE_NET_IF_MEDIA_H 1\n\n/* Use OpenSSL */\n#cmakedefine HAVE_OPENSSL 1\n\n/* if there's an os-proto.h for this platform, to use additional prototypes */\n#cmakedefine HAVE_OS_PROTO_H 1\n\n/* Define to 1 if Packet32 API (Npcap driver) is available */\n#cmakedefine HAVE_PACKET32 1\n\n/* Define to 1 if Npcap's version.h is available */\n#cmakedefine HAVE_VERSION_H 1\n\n/* Define to 1 if you have a POSIX-style `strerror_r' function. */\n#cmakedefine HAVE_POSIX_STRERROR_R 1\n\n/* define if you have the Myricom SNF API */\n#cmakedefine HAVE_SNF_API 1\n\n/* Define to 1 if you have the `snprintf' function. */\n#cmakedefine HAVE_SNPRINTF 1\n\n/* Define to 1 if the system has the type `socklen_t'. */\n#cmakedefine HAVE_SOCKLEN_T 1\n\n/* On solaris */\n#cmakedefine HAVE_SOLARIS 1\n\n/* target host supports Solaris \"any\" device */\n#cmakedefine HAVE_SOLARIS_ANY_DEVICE 1\n\n/* define if we have the Solaris getnetbyname_r() */\n#cmakedefine HAVE_SOLARIS_GETNETBYNAME_R 1\n\n/* define if we have the Solaris getprotobyname_r() */\n#cmakedefine HAVE_SOLARIS_GETPROTOBYNAME_R 1\n\n/* Define to 1 if you have the `strlcat' function. */\n#cmakedefine HAVE_STRLCAT 1\n\n/* Define to 1 if you have the `strlcpy' function. */\n#cmakedefine HAVE_STRLCPY 1\n\n/* Define to 1 if you have the `strtok_r' function. */\n#cmakedefine HAVE_STRTOK_R 1\n\n/* Define to 1 if the system has the type `struct BPF_TIMEVAL'. */\n#cmakedefine HAVE_STRUCT_BPF_TIMEVAL 1\n\n/* Define to 1 if the system has the type `struct ether_addr'. */\n#cmakedefine HAVE_STRUCT_ETHER_ADDR 1\n\n/* Define to 1 if `msg_control' is a member of `struct msghdr'. */\n#cmakedefine HAVE_STRUCT_MSGHDR_MSG_CONTROL 1\n\n/* Define to 1 if `msg_flags' is a member of `struct msghdr'. */\n#cmakedefine HAVE_STRUCT_MSGHDR_MSG_FLAGS 1\n\n/* Define to 1 if the system has the type `struct rte_ether_addr'. */\n#cmakedefine HAVE_STRUCT_RTE_ETHER_ADDR 1\n\n/* Define to 1 if `hci_channel' is a member of `struct sockaddr_hci'. */\n#cmakedefine HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL 1\n\n/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */\n#cmakedefine HAVE_STRUCT_SOCKADDR_SA_LEN 1\n\n/* Define to 1 if `tp_vlan_tci' is a member of `struct tpacket_auxdata'. */\n#cmakedefine HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI 1\n\n/* Define to 1 if `bRequestType' is a member of `struct\n   usbdevfs_ctrltransfer'. */\n#cmakedefine HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE 1\n\n/* Define to 1 if you have the <sys/bufmod.h> header file. */\n#cmakedefine HAVE_SYS_BUFMOD_H 1\n\n/* Define to 1 if you have the <sys/dlpi_ext.h> header file. */\n#cmakedefine HAVE_SYS_DLPI_EXT_H 1\n\n/* Define to 1 if you have the <sys/dlpi.h> header file. */\n#cmakedefine HAVE_SYS_DLPI_H 1\n\n/* Define to 1 if you have the <sys/ioccom.h> header file. */\n#cmakedefine HAVE_SYS_IOCCOM_H 1\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#cmakedefine HAVE_SYS_SOCKIO_H 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#cmakedefine HAVE_UNISTD_H 1\n\n/* Define to 1 if you have the `vasprintf' function. */\n#cmakedefine HAVE_VASPRINTF 1\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#cmakedefine HAVE_VSNPRINTF 1\n\n/* Define to 1 if you have the `vsyslog' function. */\n#cmakedefine HAVE_VSYSLOG 1\n\n/* Define to 1 if you have the `_wcserror_s' function. */\n#cmakedefine HAVE__WCSERROR_S 1\n\n/* define if __atomic_load_n is supported by the compiler */\n#cmakedefine HAVE___ATOMIC_LOAD_N 1\n\n/* define if __atomic_store_n is supported by the compiler */\n#cmakedefine HAVE___ATOMIC_STORE_N 1\n\n/* Define to 1 if you have the `PacketGetTimestampModes' function. */\n#cmakedefine HAVE_PACKET_GET_TIMESTAMP_MODES 1\n\n/* Define to 1 if you have the `PacketIsLoopbackAdapter' function. */\n#cmakedefine HAVE_PACKET_IS_LOOPBACK_ADAPTER 1\n\n/* IPv6 */\n#cmakedefine INET6 1\n\n/* Define to 1 if netinet/ether.h declares `ether_hostton' */\n#cmakedefine NETINET_ETHER_H_DECLARES_ETHER_HOSTTON 1\n\n/* Define to 1 if netinet/if_ether.h declares `ether_hostton' */\n#cmakedefine NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON 1\n\n/* Define to 1 if net/ethernet.h declares `ether_hostton' */\n#cmakedefine NET_ETHERNET_H_DECLARES_ETHER_HOSTTON 1\n\n/* do not use protochain */\n#cmakedefine NO_PROTOCHAIN 1\n\n/* Define to the address where bug reports for this package should be sent. */\n#cmakedefine PACKAGE_BUGREPORT 1\n\n/* Define to the DLL-preferred version string of this package. */\n#cmakedefine PACKAGE_VERSION_DLL @PACKAGE_VERSION_DLL@\n\n/* Define to the full name of this package. */\n#cmakedefine PACKAGE_NAME \"@PACKAGE_NAME@\"\n\n/* Define to the full name and version of this package. */\n#cmakedefine PACKAGE_STRING \"@PACKAGE_STRING@\"\n\n/* Define to the one symbol short name of this package. */\n#cmakedefine PACKAGE_TARNAME 1\n\n/* Define to the home page for this package. */\n#cmakedefine PACKAGE_URL 1\n\n/* Define to the version of this package. */\n#cmakedefine PACKAGE_VERSION \"@PACKAGE_VERSION@\"\n\n/* target host supports Bluetooth sniffing */\n#cmakedefine PCAP_SUPPORT_BT 1\n\n/* target host supports Bluetooth Monitor */\n#cmakedefine PCAP_SUPPORT_BT_MONITOR 1\n\n/* support D-Bus sniffing */\n#cmakedefine PCAP_SUPPORT_DBUS 1\n\n/* target host supports DPDK */\n#cmakedefine PCAP_SUPPORT_DPDK 1\n\n/* target host supports Linux usbmon for USB sniffing */\n#cmakedefine PCAP_SUPPORT_LINUX_USBMON 1\n\n/* target host supports netfilter sniffing */\n#cmakedefine PCAP_SUPPORT_NETFILTER 1\n\n/* target host supports netmap */\n#cmakedefine PCAP_SUPPORT_NETMAP 1\n\n/* target host supports RDMA sniffing */\n#cmakedefine PCAP_SUPPORT_RDMASNIFF 1\n\n/* The size of `time_t', as computed by sizeof. */\n#cmakedefine SIZEOF_TIME_T @SIZEOF_TIME_T@\n\n/* The size of `void *', as computed by sizeof. */\n#cmakedefine SIZEOF_VOID_P @SIZEOF_VOID_P@\n\n/* Define to 1 if sys/ethernet.h declares `ether_hostton' */\n#cmakedefine SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON 1\n\n/* Enable parser debugging */\n#cmakedefine YYDEBUG 1\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#cmakedefine _FILE_OFFSET_BITS 1\n\n/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n#cmakedefine _LARGEFILE_SOURCE 1\n\n/* Define for large files, on AIX-style hosts. */\n#cmakedefine _LARGE_FILES 1\n"
        },
        {
          "name": "config.guess",
          "type": "blob",
          "size": 49.537109375,
          "content": "#! /bin/sh\n# Attempt to guess a canonical system name.\n#   Copyright 1992-2024 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268 # see below for rationale\n\ntimestamp='2024-01-01'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n#\n# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.\n#\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\n#\n# Please send patches to <config-patches@gnu.org>.\n\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION]\n\nOutput the configuration name of the system '$me' is run on.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.guess ($timestamp)\n\nOriginally written by Per Bothner.\nCopyright 1992-2024 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry '$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n    * )\n       break ;;\n  esac\ndone\n\nif test $# != 0; then\n  echo \"$me: too many arguments$help\" >&2\n  exit 1\nfi\n\n# Just in case it came from the environment.\nGUESS=\n\n# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n# compiler to aid in system detection is discouraged as it requires\n# temporary files to be created and, as you can see below, it is a\n# headache to deal with in a portable fashion.\n\n# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still\n# use 'HOST_CC' if defined, but it is deprecated.\n\n# Portable tmp directory creation inspired by the Autoconf team.\n\ntmp=\n# shellcheck disable=SC2172\ntrap 'test -z \"$tmp\" || rm -fr \"$tmp\"' 0 1 2 13 15\n\nset_cc_for_build() {\n    # prevent multiple calls if $tmp is already set\n    test \"$tmp\" && return 0\n    : \"${TMPDIR=/tmp}\"\n    # shellcheck disable=SC2039,SC3028\n    { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n\t{ test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir \"$tmp\" 2>/dev/null) ; } ||\n\t{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir \"$tmp\" 2>/dev/null) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n\t{ echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; }\n    dummy=$tmp/dummy\n    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in\n\t,,)    echo \"int x;\" > \"$dummy.c\"\n\t       for driver in cc gcc c89 c99 ; do\n\t\t   if ($driver -c -o \"$dummy.o\" \"$dummy.c\") >/dev/null 2>&1 ; then\n\t\t       CC_FOR_BUILD=$driver\n\t\t       break\n\t\t   fi\n\t       done\n\t       if test x\"$CC_FOR_BUILD\" = x ; then\n\t\t   CC_FOR_BUILD=no_compiler_found\n\t       fi\n\t       ;;\n\t,,*)   CC_FOR_BUILD=$CC ;;\n\t,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n    esac\n}\n\n# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n# (ghazi@noc.rutgers.edu 1994-08-24)\nif test -f /.attbin/uname ; then\n\tPATH=$PATH:/.attbin ; export PATH\nfi\n\nUNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\nUNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\nUNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown\nUNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n\ncase $UNAME_SYSTEM in\nLinux|GNU|GNU/*)\n\tLIBC=unknown\n\n\tset_cc_for_build\n\tcat <<-EOF > \"$dummy.c\"\n\t#if defined(__ANDROID__)\n\tLIBC=android\n\t#else\n\t#include <features.h>\n\t#if defined(__UCLIBC__)\n\tLIBC=uclibc\n\t#elif defined(__dietlibc__)\n\tLIBC=dietlibc\n\t#elif defined(__GLIBC__)\n\tLIBC=gnu\n\t#elif defined(__LLVM_LIBC__)\n\tLIBC=llvm\n\t#else\n\t#include <stdarg.h>\n\t/* First heuristic to detect musl libc.  */\n\t#ifdef __DEFINED_va_list\n\tLIBC=musl\n\t#endif\n\t#endif\n\t#endif\n\tEOF\n\tcc_set_libc=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`\n\teval \"$cc_set_libc\"\n\n\t# Second heuristic to detect musl libc.\n\tif [ \"$LIBC\" = unknown ] &&\n\t   command -v ldd >/dev/null &&\n\t   ldd --version 2>&1 | grep -q ^musl; then\n\t\tLIBC=musl\n\tfi\n\n\t# If the system lacks a compiler, then just pick glibc.\n\t# We could probably try harder.\n\tif [ \"$LIBC\" = unknown ]; then\n\t\tLIBC=gnu\n\tfi\n\t;;\nesac\n\n# Note: order is significant - the case branches are not exclusive.\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in\n    *:NetBSD:*:*)\n\t# NetBSD (nbsd) targets should (where applicable) match one or\n\t# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,\n\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n\t# switched to ELF, *-*-netbsd* would select the old\n\t# object file format.  This provides both forward\n\t# compatibility and a consistent mechanism for selecting the\n\t# object file format.\n\t#\n\t# Note: NetBSD doesn't particularly care about the vendor\n\t# portion of the name.  We always set it to \"unknown\".\n\tUNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \\\n\t    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    echo unknown)`\n\tcase $UNAME_MACHINE_ARCH in\n\t    aarch64eb) machine=aarch64_be-unknown ;;\n\t    armeb) machine=armeb-unknown ;;\n\t    arm*) machine=arm-unknown ;;\n\t    sh3el) machine=shl-unknown ;;\n\t    sh3eb) machine=sh-unknown ;;\n\t    sh5el) machine=sh5le-unknown ;;\n\t    earmv*)\n\t\tarch=`echo \"$UNAME_MACHINE_ARCH\" | sed -e 's,^e\\(armv[0-9]\\).*$,\\1,'`\n\t\tendian=`echo \"$UNAME_MACHINE_ARCH\" | sed -ne 's,^.*\\(eb\\)$,\\1,p'`\n\t\tmachine=${arch}${endian}-unknown\n\t\t;;\n\t    *) machine=$UNAME_MACHINE_ARCH-unknown ;;\n\tesac\n\t# The Operating System including object format, if it has switched\n\t# to ELF recently (or will in the future) and ABI.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\tos=netbsdelf\n\t\t;;\n\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n\t\tset_cc_for_build\n\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t\t| grep -q __ELF__\n\t\tthen\n\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n\t\t    # Return netbsd for either.  FIX?\n\t\t    os=netbsd\n\t\telse\n\t\t    os=netbsdelf\n\t\tfi\n\t\t;;\n\t    *)\n\t\tos=netbsd\n\t\t;;\n\tesac\n\t# Determine ABI tags.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\texpr='s/^earmv[0-9]/-eabi/;s/eb$//'\n\t\tabi=`echo \"$UNAME_MACHINE_ARCH\" | sed -e \"$expr\"`\n\t\t;;\n\tesac\n\t# The OS release\n\t# Debian GNU/NetBSD machines have a different userland, and\n\t# thus, need a distinct triplet. However, they do not need\n\t# kernel version information, so it can be replaced with a\n\t# suitable tag, in the style of linux-gnu.\n\tcase $UNAME_VERSION in\n\t    Debian*)\n\t\trelease='-gnu'\n\t\t;;\n\t    *)\n\t\trelease=`echo \"$UNAME_RELEASE\" | sed -e 's/[-_].*//' | cut -d. -f1,2`\n\t\t;;\n\tesac\n\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n\t# contains redundant information, the shorter form:\n\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n\tGUESS=$machine-${os}${release}${abi-}\n\t;;\n    *:Bitrig:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE\n\t;;\n    *:OpenBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE\n\t;;\n    *:SecBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE\n\t;;\n    *:LibertyBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\\.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE\n\t;;\n    *:MidnightBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE\n\t;;\n    *:ekkoBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE\n\t;;\n    *:SolidBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE\n\t;;\n    *:OS108:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE\n\t;;\n    macppc:MirBSD:*:*)\n\tGUESS=powerpc-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:MirBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:Sortix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-sortix\n\t;;\n    *:Twizzler:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-twizzler\n\t;;\n    *:Redox:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-redox\n\t;;\n    mips:OSF1:*.*)\n\tGUESS=mips-dec-osf1\n\t;;\n    alpha:OSF1:*:*)\n\t# Reset EXIT trap before exiting to avoid spurious non-zero exit code.\n\ttrap '' 0\n\tcase $UNAME_RELEASE in\n\t*4.0)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n\t\t;;\n\t*5.*)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n\t\t;;\n\tesac\n\t# According to Compaq, /usr/sbin/psrinfo has been available on\n\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n\t# covers most systems running today.  This code pipes the CPU\n\t# types through head -n 1, so we only detect the type of CPU 0.\n\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n\tcase $ALPHA_CPU_TYPE in\n\t    \"EV4 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV4.5 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"LCA4 (21066/21068)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV5 (21164)\")\n\t\tUNAME_MACHINE=alphaev5 ;;\n\t    \"EV5.6 (21164A)\")\n\t\tUNAME_MACHINE=alphaev56 ;;\n\t    \"EV5.6 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca56 ;;\n\t    \"EV5.7 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca57 ;;\n\t    \"EV6 (21264)\")\n\t\tUNAME_MACHINE=alphaev6 ;;\n\t    \"EV6.7 (21264A)\")\n\t\tUNAME_MACHINE=alphaev67 ;;\n\t    \"EV6.8CB (21264C)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8AL (21264B)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8CX (21264D)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.9A (21264/EV69A)\")\n\t\tUNAME_MACHINE=alphaev69 ;;\n\t    \"EV7 (21364)\")\n\t\tUNAME_MACHINE=alphaev7 ;;\n\t    \"EV7.9 (21364A)\")\n\t\tUNAME_MACHINE=alphaev79 ;;\n\tesac\n\t# A Pn.n version is a patched version.\n\t# A Vn.n version is a released version.\n\t# A Tn.n version is a released field test version.\n\t# A Xn.n version is an unreleased experimental baselevel.\n\t# 1.2 uses \"1.2\" for uname -r.\n\tOSF_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tGUESS=$UNAME_MACHINE-dec-osf$OSF_REL\n\t;;\n    Amiga*:UNIX_System_V:4.0:*)\n\tGUESS=m68k-unknown-sysv4\n\t;;\n    *:[Aa]miga[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-amigaos\n\t;;\n    *:[Mm]orph[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-morphos\n\t;;\n    *:OS/390:*:*)\n\tGUESS=i370-ibm-openedition\n\t;;\n    *:z/VM:*:*)\n\tGUESS=s390-ibm-zvmoe\n\t;;\n    *:OS400:*:*)\n\tGUESS=powerpc-ibm-os400\n\t;;\n    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n\tGUESS=arm-acorn-riscix$UNAME_RELEASE\n\t;;\n    arm*:riscos:*:*|arm*:RISCOS:*:*)\n\tGUESS=arm-unknown-riscos\n\t;;\n    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n\tGUESS=hppa1.1-hitachi-hiuxmpp\n\t;;\n    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n\tcase `(/bin/universe) 2>/dev/null` in\n\t    att) GUESS=pyramid-pyramid-sysv3 ;;\n\t    *)   GUESS=pyramid-pyramid-bsd   ;;\n\tesac\n\t;;\n    NILE*:*:*:dcosx)\n\tGUESS=pyramid-pyramid-svr4\n\t;;\n    DRS?6000:unix:4.0:6*)\n\tGUESS=sparc-icl-nx6\n\t;;\n    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n\tcase `/usr/bin/uname -p` in\n\t    sparc) GUESS=sparc-icl-nx7 ;;\n\tesac\n\t;;\n    s390x:SunOS:*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL\n\t;;\n    sun4H:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-hal-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris2$SUN_REL\n\t;;\n    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n\tGUESS=i386-pc-auroraux$UNAME_RELEASE\n\t;;\n    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n\tset_cc_for_build\n\tSUN_ARCH=i386\n\t# If there is a compiler, see if it is configured for 64-bit objects.\n\t# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.\n\t# This test works for both compilers.\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t(CCOPTS=\"\" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \\\n\t\tgrep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tSUN_ARCH=x86_64\n\t    fi\n\tfi\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$SUN_ARCH-pc-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:6*:*)\n\t# According to config.sub, this is the proper way to canonicalize\n\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n\t# it's likely to be more like Solaris than SunOS4.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris3$SUN_REL\n\t;;\n    sun4*:SunOS:*:*)\n\tcase `/usr/bin/arch -k` in\n\t    Series*|S4*)\n\t\tUNAME_RELEASE=`uname -v`\n\t\t;;\n\tesac\n\t# Japanese Language versions have a version number like '4.1.3-JL'.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/'`\n\tGUESS=sparc-sun-sunos$SUN_REL\n\t;;\n    sun3*:SunOS:*:*)\n\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t;;\n    sun*:*:4.2BSD:*)\n\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n\ttest \"x$UNAME_RELEASE\" = x && UNAME_RELEASE=3\n\tcase `/bin/arch` in\n\t    sun3)\n\t\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t\t;;\n\t    sun4)\n\t\tGUESS=sparc-sun-sunos$UNAME_RELEASE\n\t\t;;\n\tesac\n\t;;\n    aushp:SunOS:*:*)\n\tGUESS=sparc-auspex-sunos$UNAME_RELEASE\n\t;;\n    # The situation for MiNT is a little confusing.  The machine name\n    # can be virtually everything (everything which is not\n    # \"atarist\" or \"atariste\" at least should have a processor\n    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n    # the system name \"TOS\" denotes a system which is actually not\n    # MiNT.  But MiNT is downward compatible to TOS, so this should\n    # be no problem.\n    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n\tGUESS=m68k-milan-mint$UNAME_RELEASE\n\t;;\n    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n\tGUESS=m68k-hades-mint$UNAME_RELEASE\n\t;;\n    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n\tGUESS=m68k-unknown-mint$UNAME_RELEASE\n\t;;\n    m68k:machten:*:*)\n\tGUESS=m68k-apple-machten$UNAME_RELEASE\n\t;;\n    powerpc:machten:*:*)\n\tGUESS=powerpc-apple-machten$UNAME_RELEASE\n\t;;\n    RISC*:Mach:*:*)\n\tGUESS=mips-dec-mach_bsd4.3\n\t;;\n    RISC*:ULTRIX:*:*)\n\tGUESS=mips-dec-ultrix$UNAME_RELEASE\n\t;;\n    VAX*:ULTRIX*:*:*)\n\tGUESS=vax-dec-ultrix$UNAME_RELEASE\n\t;;\n    2020:CLIX:*:* | 2430:CLIX:*:*)\n\tGUESS=clipper-intergraph-clix$UNAME_RELEASE\n\t;;\n    mips:*:*:UMIPS | mips:*:*:RISCos)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n#ifdef __cplusplus\n#include <stdio.h>  /* for printf() prototype */\n\tint main (int argc, char *argv[]) {\n#else\n\tint main (argc, argv) int argc; char *argv[]; {\n#endif\n\t#if defined (host_mips) && defined (MIPSEB)\n\t#if defined (SYSTYPE_SYSV)\n\t  printf (\"mips-mips-riscos%ssysv\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_SVR4)\n\t  printf (\"mips-mips-riscos%ssvr4\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n\t  printf (\"mips-mips-riscos%sbsd\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#endif\n\t  exit (-1);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" &&\n\t  dummyarg=`echo \"$UNAME_RELEASE\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n\t  SYSTEM_NAME=`\"$dummy\" \"$dummyarg\"` &&\n\t    { echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=mips-mips-riscos$UNAME_RELEASE\n\t;;\n    Motorola:PowerMAX_OS:*:*)\n\tGUESS=powerpc-motorola-powermax\n\t;;\n    Motorola:*:4.3:PL8-*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:Power_UNIX:*:*)\n\tGUESS=powerpc-harris-powerunix\n\t;;\n    m88k:CX/UX:7*:*)\n\tGUESS=m88k-harris-cxux7\n\t;;\n    m88k:*:4*:R4*)\n\tGUESS=m88k-motorola-sysv4\n\t;;\n    m88k:*:3*:R3*)\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    AViiON:dgux:*:*)\n\t# DG/UX returns AViiON for all architectures\n\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n\tif test \"$UNAME_PROCESSOR\" = mc88100 || test \"$UNAME_PROCESSOR\" = mc88110\n\tthen\n\t    if test \"$TARGET_BINARY_INTERFACE\"x = m88kdguxelfx || \\\n\t       test \"$TARGET_BINARY_INTERFACE\"x = x\n\t    then\n\t\tGUESS=m88k-dg-dgux$UNAME_RELEASE\n\t    else\n\t\tGUESS=m88k-dg-dguxbcs$UNAME_RELEASE\n\t    fi\n\telse\n\t    GUESS=i586-dg-dgux$UNAME_RELEASE\n\tfi\n\t;;\n    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n\tGUESS=m88k-dolphin-sysv3\n\t;;\n    M88*:*:R3*:*)\n\t# Delta 88k system running SVR3\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n\tGUESS=m88k-tektronix-sysv3\n\t;;\n    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n\tGUESS=m68k-tektronix-bsd\n\t;;\n    *:IRIX*:*:*)\n\tIRIX_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/g'`\n\tGUESS=mips-sgi-irix$IRIX_REL\n\t;;\n    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n\tGUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id\n\t;;                    # Note that: echo \"'`uname -s`'\" gives 'AIX '\n    i*86:AIX:*:*)\n\tGUESS=i386-ibm-aix\n\t;;\n    ia64:AIX:*:*)\n\tif test -x /usr/bin/oslevel ; then\n\t\tIBM_REV=`/usr/bin/oslevel`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$UNAME_MACHINE-ibm-aix$IBM_REV\n\t;;\n    *:AIX:2:3)\n\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tset_cc_for_build\n\t\tsed 's/^\t\t//' << EOF > \"$dummy.c\"\n\t\t#include <sys/systemcfg.h>\n\n\t\tmain()\n\t\t\t{\n\t\t\tif (!__power_pc())\n\t\t\t\texit(1);\n\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n\t\t\texit(0);\n\t\t\t}\nEOF\n\t\tif $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"`\n\t\tthen\n\t\t\tGUESS=$SYSTEM_NAME\n\t\telse\n\t\t\tGUESS=rs6000-ibm-aix3.2.5\n\t\tfi\n\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tGUESS=rs6000-ibm-aix3.2.4\n\telse\n\t\tGUESS=rs6000-ibm-aix3.2\n\tfi\n\t;;\n    *:AIX:*:[4567])\n\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n\tif /usr/sbin/lsattr -El \"$IBM_CPU_ID\" | grep ' POWER' >/dev/null 2>&1; then\n\t\tIBM_ARCH=rs6000\n\telse\n\t\tIBM_ARCH=powerpc\n\tfi\n\tif test -x /usr/bin/lslpp ; then\n\t\tIBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \\\n\t\t\t   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$IBM_ARCH-ibm-aix$IBM_REV\n\t;;\n    *:AIX:*:*)\n\tGUESS=rs6000-ibm-aix\n\t;;\n    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)\n\tGUESS=romp-ibm-bsd4.4\n\t;;\n    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n\tGUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to\n\t;;                                  # report: romp-ibm BSD 4.3\n    *:BOSX:*:*)\n\tGUESS=rs6000-bull-bosx\n\t;;\n    DPX/2?00:B.O.S.:*:*)\n\tGUESS=m68k-bull-sysv3\n\t;;\n    9000/[34]??:4.3bsd:1.*:*)\n\tGUESS=m68k-hp-bsd\n\t;;\n    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n\tGUESS=m68k-hp-bsd4.4\n\t;;\n    9000/[34678]??:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tcase $UNAME_MACHINE in\n\t    9000/31?)            HP_ARCH=m68000 ;;\n\t    9000/[34]??)         HP_ARCH=m68k ;;\n\t    9000/[678][0-9][0-9])\n\t\tif test -x /usr/bin/getconf; then\n\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n\t\t    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n\t\t    case $sc_cpu_version in\n\t\t      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0\n\t\t      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1\n\t\t      532)                      # CPU_PA_RISC2_0\n\t\t\tcase $sc_kernel_bits in\n\t\t\t  32) HP_ARCH=hppa2.0n ;;\n\t\t\t  64) HP_ARCH=hppa2.0w ;;\n\t\t\t  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20\n\t\t\tesac ;;\n\t\t    esac\n\t\tfi\n\t\tif test \"$HP_ARCH\" = \"\"; then\n\t\t    set_cc_for_build\n\t\t    sed 's/^\t\t//' << EOF > \"$dummy.c\"\n\n\t\t#define _HPUX_SOURCE\n\t\t#include <stdlib.h>\n\t\t#include <unistd.h>\n\n\t\tint main ()\n\t\t{\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t    long bits = sysconf(_SC_KERNEL_BITS);\n\t\t#endif\n\t\t    long cpu  = sysconf (_SC_CPU_VERSION);\n\n\t\t    switch (cpu)\n\t\t\t{\n\t\t\tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n\t\t\tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n\t\t\tcase CPU_PA_RISC2_0:\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t\t    switch (bits)\n\t\t\t\t{\n\t\t\t\tcase 64: puts (\"hppa2.0w\"); break;\n\t\t\t\tcase 32: puts (\"hppa2.0n\"); break;\n\t\t\t\tdefault: puts (\"hppa2.0\"); break;\n\t\t\t\t} break;\n\t\t#else  /* !defined(_SC_KERNEL_BITS) */\n\t\t\t    puts (\"hppa2.0\"); break;\n\t\t#endif\n\t\t\tdefault: puts (\"hppa1.0\"); break;\n\t\t\t}\n\t\t    exit (0);\n\t\t}\nEOF\n\t\t    (CCOPTS=\"\" $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null) && HP_ARCH=`\"$dummy\"`\n\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n\t\tfi ;;\n\tesac\n\tif test \"$HP_ARCH\" = hppa2.0w\n\tthen\n\t    set_cc_for_build\n\n\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n\t    #\n\t    # $ CC_FOR_BUILD=cc ./config.guess\n\t    # => hppa2.0w-hp-hpux11.23\n\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n\t    # => hppa64-hp-hpux11.23\n\n\t    if echo __LP64__ | (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) |\n\t\tgrep -q __LP64__\n\t    then\n\t\tHP_ARCH=hppa2.0w\n\t    else\n\t\tHP_ARCH=hppa64\n\t    fi\n\tfi\n\tGUESS=$HP_ARCH-hp-hpux$HPUX_REV\n\t;;\n    ia64:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tGUESS=ia64-hp-hpux$HPUX_REV\n\t;;\n    3050*:HI-UX:*:*)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#include <unistd.h>\n\tint\n\tmain ()\n\t{\n\t  long cpu = sysconf (_SC_CPU_VERSION);\n\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n\t     results, however.  */\n\t  if (CPU_IS_PA_RISC (cpu))\n\t    {\n\t      switch (cpu)\n\t\t{\n\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n\t\t}\n\t    }\n\t  else if (CPU_IS_HP_MC68K (cpu))\n\t    puts (\"m68k-hitachi-hiuxwe2\");\n\t  else puts (\"unknown-hitachi-hiuxwe2\");\n\t  exit (0);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"` &&\n\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=unknown-hitachi-hiuxwe2\n\t;;\n    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)\n\tGUESS=hppa1.1-hp-bsd\n\t;;\n    9000/8??:4.3bsd:*:*)\n\tGUESS=hppa1.0-hp-bsd\n\t;;\n    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n\tGUESS=hppa1.0-hp-mpeix\n\t;;\n    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)\n\tGUESS=hppa1.1-hp-osf\n\t;;\n    hp8??:OSF1:*:*)\n\tGUESS=hppa1.0-hp-osf\n\t;;\n    i*86:OSF1:*:*)\n\tif test -x /usr/sbin/sysversion ; then\n\t    GUESS=$UNAME_MACHINE-unknown-osf1mk\n\telse\n\t    GUESS=$UNAME_MACHINE-unknown-osf1\n\tfi\n\t;;\n    parisc*:Lites*:*:*)\n\tGUESS=hppa1.1-hp-lites\n\t;;\n    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n\tGUESS=c1-convex-bsd\n\t;;\n    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n\tif getsysinfo -f scalar_acc\n\tthen echo c32-convex-bsd\n\telse echo c2-convex-bsd\n\tfi\n\texit ;;\n    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n\tGUESS=c34-convex-bsd\n\t;;\n    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n\tGUESS=c38-convex-bsd\n\t;;\n    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n\tGUESS=c4-convex-bsd\n\t;;\n    CRAY*Y-MP:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=ymp-cray-unicos$CRAY_REL\n\t;;\n    CRAY*[A-Z]90:*:*:*)\n\techo \"$UNAME_MACHINE\"-cray-unicos\"$UNAME_RELEASE\" \\\n\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n\t      -e 's/\\.[^.]*$/.X/'\n\texit ;;\n    CRAY*TS:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=t90-cray-unicos$CRAY_REL\n\t;;\n    CRAY*T3E:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=alphaev5-cray-unicosmk$CRAY_REL\n\t;;\n    CRAY*SV1:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=sv1-cray-unicos$CRAY_REL\n\t;;\n    *:UNICOS/mp:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=craynv-cray-unicosmp$CRAY_REL\n\t;;\n    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n\tFUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ /_/'`\n\tGUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    5000:UNIX_System_V:4.*:*)\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`\n\tGUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE\n\t;;\n    sparc*:BSD/OS:*:*)\n\tGUESS=sparc-unknown-bsdi$UNAME_RELEASE\n\t;;\n    *:BSD/OS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE\n\t;;\n    arm:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tset_cc_for_build\n\tif echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_PCS_VFP\n\tthen\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi\n\telse\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf\n\tfi\n\t;;\n    *:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    amd64)\n\t\tUNAME_PROCESSOR=x86_64 ;;\n\t    i386)\n\t\tUNAME_PROCESSOR=i586 ;;\n\tesac\n\tFREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL\n\t;;\n    i*:CYGWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-cygwin\n\t;;\n    *:MINGW64*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw64\n\t;;\n    *:MINGW*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw32\n\t;;\n    *:MSYS*:*)\n\tGUESS=$UNAME_MACHINE-pc-msys\n\t;;\n    i*:PW*:*)\n\tGUESS=$UNAME_MACHINE-pc-pw32\n\t;;\n    *:SerenityOS:*:*)\n        GUESS=$UNAME_MACHINE-pc-serenity\n        ;;\n    *:Interix*:*)\n\tcase $UNAME_MACHINE in\n\t    x86)\n\t\tGUESS=i586-pc-interix$UNAME_RELEASE\n\t\t;;\n\t    authenticamd | genuineintel | EM64T)\n\t\tGUESS=x86_64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\t    IA64)\n\t\tGUESS=ia64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\tesac ;;\n    i*:UWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-uwin\n\t;;\n    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n\tGUESS=x86_64-pc-cygwin\n\t;;\n    prep*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=powerpcle-unknown-solaris2$SUN_REL\n\t;;\n    *:GNU:*:*)\n\t# the GNU system\n\tGNU_ARCH=`echo \"$UNAME_MACHINE\" | sed -e 's,[-/].*$,,'`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's,/.*$,,'`\n\tGUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL\n\t;;\n    *:GNU/*:*:*)\n\t# other systems with GNU libc and userland\n\tGNU_SYS=`echo \"$UNAME_SYSTEM\" | sed 's,^[^/]*/,,' | tr \"[:upper:]\" \"[:lower:]\"`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC\n\t;;\n    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-pc-managarm-mlibc\"\n\t;;\n    *:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-unknown-managarm-mlibc\"\n\t;;\n    *:Minix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-minix\n\t;;\n    aarch64:Linux:*:*)\n\tset_cc_for_build\n\tCPU=$UNAME_MACHINE\n\tLIBCABI=$LIBC\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    ABI=64\n\t    sed 's/^\t    //' << EOF > \"$dummy.c\"\n\t    #ifdef __ARM_EABI__\n\t    #ifdef __ARM_PCS_VFP\n\t    ABI=eabihf\n\t    #else\n\t    ABI=eabi\n\t    #endif\n\t    #endif\nEOF\n\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`\n\t    eval \"$cc_set_abi\"\n\t    case $ABI in\n\t\teabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;\n\t    esac\n\tfi\n\tGUESS=$CPU-unknown-linux-$LIBCABI\n\t;;\n    aarch64_be:Linux:*:*)\n\tUNAME_MACHINE=aarch64_be\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    alpha:Linux:*:*)\n\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' /proc/cpuinfo 2>/dev/null` in\n\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n\tesac\n\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n\tif test \"$?\" = 0 ; then LIBC=gnulibc1 ; fi\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arm*:Linux:*:*)\n\tset_cc_for_build\n\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_EABI__\n\tthen\n\t    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\telse\n\t    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t| grep -q __ARM_PCS_VFP\n\t    then\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi\n\t    else\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf\n\t    fi\n\tfi\n\t;;\n    avr32*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    cris:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    crisv32:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    e2k:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    frv:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    hexagon:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-pc-linux-$LIBC\n\t;;\n    ia64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    k1om:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    kvx:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    kvx:cos:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-cos\n\t;;\n    kvx:mbr:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-mbr\n\t;;\n    loongarch32:Linux:*:* | loongarch64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m32r*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m68*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    mips:Linux:*:* | mips64:Linux:*:*)\n\tset_cc_for_build\n\tIS_GLIBC=0\n\ttest x\"${LIBC}\" = xgnu && IS_GLIBC=1\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#undef CPU\n\t#undef mips\n\t#undef mipsel\n\t#undef mips64\n\t#undef mips64el\n\t#if ${IS_GLIBC} && defined(_ABI64)\n\tLIBCABI=gnuabi64\n\t#else\n\t#if ${IS_GLIBC} && defined(_ABIN32)\n\tLIBCABI=gnuabin32\n\t#else\n\tLIBCABI=${LIBC}\n\t#endif\n\t#endif\n\n\t#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa64r6\n\t#else\n\t#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa32r6\n\t#else\n\t#if defined(__mips64)\n\tCPU=mips64\n\t#else\n\tCPU=mips\n\t#endif\n\t#endif\n\t#endif\n\n\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n\tMIPS_ENDIAN=el\n\t#else\n\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n\tMIPS_ENDIAN=\n\t#else\n\tMIPS_ENDIAN=\n\t#endif\n\t#endif\nEOF\n\tcc_set_vars=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^CPU\\|^MIPS_ENDIAN\\|^LIBCABI'`\n\teval \"$cc_set_vars\"\n\ttest \"x$CPU\" != x && { echo \"$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI\"; exit; }\n\t;;\n    mips64el:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    openrisc*:Linux:*:*)\n\tGUESS=or1k-unknown-linux-$LIBC\n\t;;\n    or32:Linux:*:* | or1k*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    padre:Linux:*:*)\n\tGUESS=sparc-unknown-linux-$LIBC\n\t;;\n    parisc64:Linux:*:* | hppa64:Linux:*:*)\n\tGUESS=hppa64-unknown-linux-$LIBC\n\t;;\n    parisc:Linux:*:* | hppa:Linux:*:*)\n\t# Look for CPU level\n\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n\t  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;\n\t  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;\n\t  *)    GUESS=hppa-unknown-linux-$LIBC ;;\n\tesac\n\t;;\n    ppc64:Linux:*:*)\n\tGUESS=powerpc64-unknown-linux-$LIBC\n\t;;\n    ppc:Linux:*:*)\n\tGUESS=powerpc-unknown-linux-$LIBC\n\t;;\n    ppc64le:Linux:*:*)\n\tGUESS=powerpc64le-unknown-linux-$LIBC\n\t;;\n    ppcle:Linux:*:*)\n\tGUESS=powerpcle-unknown-linux-$LIBC\n\t;;\n    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    s390:Linux:*:* | s390x:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-ibm-linux-$LIBC\n\t;;\n    sh64*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sh*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sparc:Linux:*:* | sparc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    tile*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    vax:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-dec-linux-$LIBC\n\t;;\n    x86_64:Linux:*:*)\n\tset_cc_for_build\n\tCPU=$UNAME_MACHINE\n\tLIBCABI=$LIBC\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    ABI=64\n\t    sed 's/^\t    //' << EOF > \"$dummy.c\"\n\t    #ifdef __i386__\n\t    ABI=x86\n\t    #else\n\t    #ifdef __ILP32__\n\t    ABI=x32\n\t    #endif\n\t    #endif\nEOF\n\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`\n\t    eval \"$cc_set_abi\"\n\t    case $ABI in\n\t\tx86) CPU=i686 ;;\n\t\tx32) LIBCABI=${LIBC}x32 ;;\n\t    esac\n\tfi\n\tGUESS=$CPU-pc-linux-$LIBCABI\n\t;;\n    xtensa*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:DYNIX/ptx:4*:*)\n\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n\t# earlier versions are messed up and put the nodename in both\n\t# sysname and nodename.\n\tGUESS=i386-sequent-sysv4\n\t;;\n    i*86:UNIX_SV:4.2MP:2.*)\n\t# Unixware is an offshoot of SVR4, but it has its own version\n\t# number series starting with 2...\n\t# I am not positive that other SVR4 systems won't match this,\n\t# I just have to hope.  -- rms.\n\t# Use sysv4.2uw... so that sysv4* matches it.\n\tGUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION\n\t;;\n    i*86:OS/2:*:*)\n\t# If we were able to find 'uname', then EMX Unix compatibility\n\t# is probably installed.\n\tGUESS=$UNAME_MACHINE-pc-os2-emx\n\t;;\n    i*86:XTS-300:*:STOP)\n\tGUESS=$UNAME_MACHINE-unknown-stop\n\t;;\n    i*86:atheos:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-atheos\n\t;;\n    i*86:syllable:*:*)\n\tGUESS=$UNAME_MACHINE-pc-syllable\n\t;;\n    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)\n\tGUESS=i386-unknown-lynxos$UNAME_RELEASE\n\t;;\n    i*86:*DOS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-msdosdjgpp\n\t;;\n    i*86:*:4.*:*)\n\tUNAME_REL=`echo \"$UNAME_RELEASE\" | sed 's/\\/MP$//'`\n\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n\t\tGUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL\n\tfi\n\t;;\n    i*86:*:5:[678]*)\n\t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n\tcase `/bin/uname -X | grep \"^Machine\"` in\n\t    *486*)\t     UNAME_MACHINE=i486 ;;\n\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n\tesac\n\tGUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n\t;;\n    i*86:*:3.2:*)\n\tif test -f /usr/options/cb.name; then\n\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n\t\tGUESS=$UNAME_MACHINE-pc-isc$UNAME_REL\n\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i586\n\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\tGUESS=$UNAME_MACHINE-pc-sco$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv32\n\tfi\n\t;;\n    pc:*:*:*)\n\t# Left here for compatibility:\n\t# uname -m prints for DJGPP always 'pc', but it prints nothing about\n\t# the processor, so we play safe by assuming i586.\n\t# Note: whatever this is, it MUST be the same as what config.sub\n\t# prints for the \"djgpp\" host, or else GDB configure will decide that\n\t# this is a cross-build.\n\tGUESS=i586-pc-msdosdjgpp\n\t;;\n    Intel:Mach:3*:*)\n\tGUESS=i386-pc-mach3\n\t;;\n    paragon:*:*:*)\n\tGUESS=i860-intel-osf1\n\t;;\n    i860:*:4.*:*) # i860-SVR4\n\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n\t  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4\n\telse # Add other i860-SVR4 vendors below as they are discovered.\n\t  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4\n\tfi\n\t;;\n    mini*:CTIX:SYS*5:*)\n\t# \"miniframe\"\n\tGUESS=m68010-convergent-sysv\n\t;;\n    mc68k:UNIX:SYSTEM5:3.51m)\n\tGUESS=m68k-convergent-sysv\n\t;;\n    M680?0:D-NIX:5.3:*)\n\tGUESS=m68k-diab-dnix\n\t;;\n    M68*:*:R3V[5678]*:*)\n\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n\tOS_REL=''\n\ttest -r /etc/.relid \\\n\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t  && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4; exit; } ;;\n    NCR*:*:4.2:* | MPRAS*:*:4.2:*)\n\tOS_REL='.3'\n\ttest -r /etc/.relid \\\n\t    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t    && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n\tGUESS=m68k-unknown-lynxos$UNAME_RELEASE\n\t;;\n    mc68030:UNIX_System_V:4.*:*)\n\tGUESS=m68k-atari-sysv4\n\t;;\n    TSUNAMI:LynxOS:2.*:*)\n\tGUESS=sparc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    rs6000:LynxOS:2.*:*)\n\tGUESS=rs6000-unknown-lynxos$UNAME_RELEASE\n\t;;\n    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)\n\tGUESS=powerpc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    SM[BE]S:UNIX_SV:*:*)\n\tGUESS=mips-dde-sysv$UNAME_RELEASE\n\t;;\n    RM*:ReliantUNIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    RM*:SINIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    *:SINIX-*:*:*)\n\tif uname -p 2>/dev/null >/dev/null ; then\n\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\t\tGUESS=$UNAME_MACHINE-sni-sysv4\n\telse\n\t\tGUESS=ns32k-sni-sysv\n\tfi\n\t;;\n    PENTIUM:*:4.0*:*)\t# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort\n\t\t\t# says <Richard.M.Bartel@ccMail.Census.GOV>\n\tGUESS=i586-unisys-sysv4\n\t;;\n    *:UNIX_System_V:4*:FTX*)\n\t# From Gerald Hewes <hewes@openmarket.com>.\n\t# How about differentiating between stratus architectures? -djm\n\tGUESS=hppa1.1-stratus-sysv4\n\t;;\n    *:*:*:FTX*)\n\t# From seanf@swdc.stratus.com.\n\tGUESS=i860-stratus-sysv4\n\t;;\n    i*86:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=$UNAME_MACHINE-stratus-vos\n\t;;\n    *:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=hppa1.1-stratus-vos\n\t;;\n    mc68*:A/UX:*:*)\n\tGUESS=m68k-apple-aux$UNAME_RELEASE\n\t;;\n    news*:NEWS-OS:6*:*)\n\tGUESS=mips-sony-newsos6\n\t;;\n    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n\tif test -d /usr/nec; then\n\t\tGUESS=mips-nec-sysv$UNAME_RELEASE\n\telse\n\t\tGUESS=mips-unknown-sysv$UNAME_RELEASE\n\tfi\n\t;;\n    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n\tGUESS=powerpc-be-beos\n\t;;\n    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n\tGUESS=powerpc-apple-beos\n\t;;\n    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n\tGUESS=i586-pc-beos\n\t;;\n    BePC:Haiku:*:*)\t# Haiku running on Intel PC compatible.\n\tGUESS=i586-pc-haiku\n\t;;\n    ppc:Haiku:*:*)\t# Haiku running on Apple PowerPC\n\tGUESS=powerpc-apple-haiku\n\t;;\n    *:Haiku:*:*)\t# Haiku modern gcc (not bound by BeOS compat)\n\tGUESS=$UNAME_MACHINE-unknown-haiku\n\t;;\n    SX-4:SUPER-UX:*:*)\n\tGUESS=sx4-nec-superux$UNAME_RELEASE\n\t;;\n    SX-5:SUPER-UX:*:*)\n\tGUESS=sx5-nec-superux$UNAME_RELEASE\n\t;;\n    SX-6:SUPER-UX:*:*)\n\tGUESS=sx6-nec-superux$UNAME_RELEASE\n\t;;\n    SX-7:SUPER-UX:*:*)\n\tGUESS=sx7-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8:SUPER-UX:*:*)\n\tGUESS=sx8-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8R:SUPER-UX:*:*)\n\tGUESS=sx8r-nec-superux$UNAME_RELEASE\n\t;;\n    SX-ACE:SUPER-UX:*:*)\n\tGUESS=sxace-nec-superux$UNAME_RELEASE\n\t;;\n    Power*:Rhapsody:*:*)\n\tGUESS=powerpc-apple-rhapsody$UNAME_RELEASE\n\t;;\n    *:Rhapsody:*:*)\n\tGUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE\n\t;;\n    arm64:Darwin:*:*)\n\tGUESS=aarch64-apple-darwin$UNAME_RELEASE\n\t;;\n    *:Darwin:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    unknown) UNAME_PROCESSOR=powerpc ;;\n\tesac\n\tif command -v xcode-select > /dev/null 2> /dev/null && \\\n\t\t! xcode-select --print-path > /dev/null 2> /dev/null ; then\n\t    # Avoid executing cc if there is no toolchain installed as\n\t    # cc will be a stub that puts up a graphical alert\n\t    # prompting the user to install developer tools.\n\t    CC_FOR_BUILD=no_compiler_found\n\telse\n\t    set_cc_for_build\n\tfi\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tcase $UNAME_PROCESSOR in\n\t\t    i386) UNAME_PROCESSOR=x86_64 ;;\n\t\t    powerpc) UNAME_PROCESSOR=powerpc64 ;;\n\t\tesac\n\t    fi\n\t    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc\n\t    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_PPC >/dev/null\n\t    then\n\t\tUNAME_PROCESSOR=powerpc\n\t    fi\n\telif test \"$UNAME_PROCESSOR\" = i386 ; then\n\t    # uname -m returns i386 or x86_64\n\t    UNAME_PROCESSOR=$UNAME_MACHINE\n\tfi\n\tGUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE\n\t;;\n    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tif test \"$UNAME_PROCESSOR\" = x86; then\n\t\tUNAME_PROCESSOR=i386\n\t\tUNAME_MACHINE=pc\n\tfi\n\tGUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE\n\t;;\n    *:QNX:*:4*)\n\tGUESS=i386-pc-qnx\n\t;;\n    NEO-*:NONSTOP_KERNEL:*:*)\n\tGUESS=neo-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSE-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nse-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSR-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsr-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSV-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsv-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSX-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsx-tandem-nsk$UNAME_RELEASE\n\t;;\n    *:NonStop-UX:*:*)\n\tGUESS=mips-compaq-nonstopux\n\t;;\n    BS2000:POSIX*:*:*)\n\tGUESS=bs2000-siemens-sysv\n\t;;\n    DS/*:UNIX_System_V:*:*)\n\tGUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE\n\t;;\n    *:Plan9:*:*)\n\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n\t# is converted to i386 for consistency with other x86\n\t# operating systems.\n\tif test \"${cputype-}\" = 386; then\n\t    UNAME_MACHINE=i386\n\telif test \"x${cputype-}\" != x; then\n\t    UNAME_MACHINE=$cputype\n\tfi\n\tGUESS=$UNAME_MACHINE-unknown-plan9\n\t;;\n    *:TOPS-10:*:*)\n\tGUESS=pdp10-unknown-tops10\n\t;;\n    *:TENEX:*:*)\n\tGUESS=pdp10-unknown-tenex\n\t;;\n    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n\tGUESS=pdp10-dec-tops20\n\t;;\n    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n\tGUESS=pdp10-xkl-tops20\n\t;;\n    *:TOPS-20:*:*)\n\tGUESS=pdp10-unknown-tops20\n\t;;\n    *:ITS:*:*)\n\tGUESS=pdp10-unknown-its\n\t;;\n    SEI:*:*:SEIUX)\n\tGUESS=mips-sei-seiux$UNAME_RELEASE\n\t;;\n    *:DragonFly:*:*)\n\tDRAGONFLY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL\n\t;;\n    *:*VMS:*:*)\n\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\tcase $UNAME_MACHINE in\n\t    A*) GUESS=alpha-dec-vms ;;\n\t    I*) GUESS=ia64-dec-vms ;;\n\t    V*) GUESS=vax-dec-vms ;;\n\tesac ;;\n    *:XENIX:*:SysV)\n\tGUESS=i386-pc-xenix\n\t;;\n    i*86:skyos:*:*)\n\tSKYOS_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ .*$//'`\n\tGUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL\n\t;;\n    i*86:rdos:*:*)\n\tGUESS=$UNAME_MACHINE-pc-rdos\n\t;;\n    i*86:Fiwix:*:*)\n\tGUESS=$UNAME_MACHINE-pc-fiwix\n\t;;\n    *:AROS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-aros\n\t;;\n    x86_64:VMkernel:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-esx\n\t;;\n    amd64:Isilon\\ OneFS:*:*)\n\tGUESS=x86_64-unknown-onefs\n\t;;\n    *:Unleashed:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE\n\t;;\n    *:Ironclad:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-ironclad\n\t;;\nesac\n\n# Do we have a guess based on uname results?\nif test \"x$GUESS\" != x; then\n    echo \"$GUESS\"\n    exit\nfi\n\n# No uname command or uname output not recognized.\nset_cc_for_build\ncat > \"$dummy.c\" <<EOF\n#ifdef _SEQUENT_\n#include <sys/types.h>\n#include <sys/utsname.h>\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#include <signal.h>\n#if defined(_SIZE_T_) || defined(SIGLOST)\n#include <sys/utsname.h>\n#endif\n#endif\n#endif\nmain ()\n{\n#if defined (sony)\n#if defined (MIPSEB)\n  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n     I don't know....  */\n  printf (\"mips-sony-bsd\\n\"); exit (0);\n#else\n#include <sys/param.h>\n  printf (\"m68k-sony-newsos%s\\n\",\n#ifdef NEWSOS4\n  \"4\"\n#else\n  \"\"\n#endif\n  ); exit (0);\n#endif\n#endif\n\n#if defined (NeXT)\n#if !defined (__ARCHITECTURE__)\n#define __ARCHITECTURE__ \"m68k\"\n#endif\n  int version;\n  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n  if (version < 4)\n    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n  else\n    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n  exit (0);\n#endif\n\n#if defined (MULTIMAX) || defined (n16)\n#if defined (UMAXV)\n  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n#else\n#if defined (CMU)\n  printf (\"ns32k-encore-mach\\n\"); exit (0);\n#else\n  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (__386BSD__)\n  printf (\"i386-pc-bsd\\n\"); exit (0);\n#endif\n\n#if defined (sequent)\n#if defined (i386)\n  printf (\"i386-sequent-dynix\\n\"); exit (0);\n#endif\n#if defined (ns32000)\n  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n#endif\n#endif\n\n#if defined (_SEQUENT_)\n  struct utsname un;\n\n  uname(&un);\n  if (strncmp(un.version, \"V2\", 2) == 0) {\n    printf (\"i386-sequent-ptx2\\n\"); exit (0);\n  }\n  if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n    printf (\"i386-sequent-ptx1\\n\"); exit (0);\n  }\n  printf (\"i386-sequent-ptx\\n\"); exit (0);\n#endif\n\n#if defined (vax)\n#if !defined (ultrix)\n#include <sys/param.h>\n#if defined (BSD)\n#if BSD == 43\n  printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n#else\n#if BSD == 199006\n  printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#endif\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#else\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname un;\n  uname (&un);\n  printf (\"vax-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"vax-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname *un;\n  uname (&un);\n  printf (\"mips-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"mips-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (alliant) && defined (i860)\n  printf (\"i860-alliant-bsd\\n\"); exit (0);\n#endif\n\n  exit (1);\n}\nEOF\n\n$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null && SYSTEM_NAME=`\"$dummy\"` &&\n\t{ echo \"$SYSTEM_NAME\"; exit; }\n\n# Apollos put the system type in the environment.\ntest -d /usr/apollo && { echo \"$ISP-apollo-$SYSTYPE\"; exit; }\n\necho \"$0: unable to guess system type\" >&2\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM in\n    mips:Linux | mips64:Linux)\n\t# If we got here on MIPS GNU/Linux, output extra information.\n\tcat >&2 <<EOF\n\nNOTE: MIPS GNU/Linux systems require a C compiler to fully recognize\nthe system type. Please install a C compiler and try again.\nEOF\n\t;;\nesac\n\ncat >&2 <<EOF\n\nThis script (version $timestamp), has failed to recognize the\noperating system you are using. If your script is old, overwrite *all*\ncopies of config.guess and config.sub with the latest versions from:\n\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\nand\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\nEOF\n\nour_year=`echo $timestamp | sed 's,-.*,,'`\nthisyear=`date +%Y`\n# shellcheck disable=SC2003\nscript_age=`expr \"$thisyear\" - \"$our_year\"`\nif test \"$script_age\" -lt 3 ; then\n   cat >&2 <<EOF\n\nIf $0 has already been updated, send the following data and any\ninformation you think might be pertinent to config-patches@gnu.org to\nprovide the necessary information to handle your system.\n\nconfig.guess timestamp = $timestamp\n\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n\nhostinfo               = `(hostinfo) 2>/dev/null`\n/bin/universe          = `(/bin/universe) 2>/dev/null`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n/bin/arch              = `(/bin/arch) 2>/dev/null`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n\nUNAME_MACHINE = \"$UNAME_MACHINE\"\nUNAME_RELEASE = \"$UNAME_RELEASE\"\nUNAME_SYSTEM  = \"$UNAME_SYSTEM\"\nUNAME_VERSION = \"$UNAME_VERSION\"\nEOF\nfi\n\nexit 1\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "config.sub",
          "type": "blob",
          "size": 35.982421875,
          "content": "#! /bin/sh\n# Configuration validation subroutine script.\n#   Copyright 1992-2024 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268 # see below for rationale\n\ntimestamp='2024-01-01'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n\n\n# Please send patches to <config-patches@gnu.org>.\n#\n# Configuration subroutine to validate and canonicalize a configuration type.\n# Supply the specified configuration type as an argument.\n# If it is invalid, we print an error message on stderr and exit with code 1.\n# Otherwise, we print the canonical config type on stdout and succeed.\n\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\n\n# This file is supposed to be the same for all GNU packages\n# and recognize all the CPU types, system types and aliases\n# that are meaningful with *any* GNU software.\n# Each package is responsible for reporting which valid configurations\n# it does not support.  The user should be able to distinguish\n# a failure to support a valid configuration from a meaningless\n# configuration.\n\n# The goal of this file is to map all the various variations of a given\n# machine specification into a single specification in the form:\n#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n# or in some cases, the newer four-part form:\n#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n# It is wrong to echo any other type of specification.\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS\n\nCanonicalize a configuration name.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.sub ($timestamp)\n\nCopyright 1992-2024 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry '$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n\n    *local*)\n       # First pass through any local machine types.\n       echo \"$1\"\n       exit ;;\n\n    * )\n       break ;;\n  esac\ndone\n\ncase $# in\n 0) echo \"$me: missing argument$help\" >&2\n    exit 1;;\n 1) ;;\n *) echo \"$me: too many arguments$help\" >&2\n    exit 1;;\nesac\n\n# Split fields of configuration type\n# shellcheck disable=SC2162\nsaved_IFS=$IFS\nIFS=\"-\" read field1 field2 field3 field4 <<EOF\n$1\nEOF\nIFS=$saved_IFS\n\n# Separate into logical components for further validation\ncase $1 in\n\t*-*-*-*-*)\n\t\techo \"Invalid configuration '$1': more than four components\" >&2\n\t\texit 1\n\t\t;;\n\t*-*-*-*)\n\t\tbasic_machine=$field1-$field2\n\t\tbasic_os=$field3-$field4\n\t\t;;\n\t*-*-*)\n\t\t# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two\n\t\t# parts\n\t\tmaybe_os=$field2-$field3\n\t\tcase $maybe_os in\n\t\t\tnto-qnx* | linux-* | uclinux-uclibc* \\\n\t\t\t| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \\\n\t\t\t| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \\\n\t\t\t| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* \\\n\t\t\t| windows-* )\n\t\t\t\tbasic_machine=$field1\n\t\t\t\tbasic_os=$maybe_os\n\t\t\t\t;;\n\t\t\tandroid-linux)\n\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\tbasic_os=linux-android\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\tbasic_os=$field3\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*)\n\t\t# A lone config we happen to match not fitting any pattern\n\t\tcase $field1-$field2 in\n\t\t\tdecstation-3100)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\t*-*)\n\t\t\t\t# Second component is usually, but not always the OS\n\t\t\t\tcase $field2 in\n\t\t\t\t\t# Prevent following clause from handling this valid os\n\t\t\t\t\tsun*os*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\tzephyr*)\n\t\t\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\t# Manufacturers\n\t\t\t\t\tdec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \\\n\t\t\t\t\t| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \\\n\t\t\t\t\t| unicom* | ibm* | next | hp | isi* | apollo | altos* \\\n\t\t\t\t\t| convergent* | ncr* | news | 32* | 3600* | 3100* \\\n\t\t\t\t\t| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \\\n\t\t\t\t\t| ultra | tti* | harris | dolphin | highlevel | gould \\\n\t\t\t\t\t| cbm | ns | masscomp | apple | axis | knuth | cray \\\n\t\t\t\t\t| microblaze* | sim | cisco \\\n\t\t\t\t\t| oki | wec | wrs | winbond)\n\t\t\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\t\t\tbasic_os=\n\t\t\t\t\t\t;;\n\t\t\t\t\t*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\t# Convert single-component short-hands not valid as part of\n\t\t# multi-component configurations.\n\t\tcase $field1 in\n\t\t\t386bsd)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\ta29khif)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tadobe68k)\n\t\t\t\tbasic_machine=m68010-adobe\n\t\t\t\tbasic_os=scout\n\t\t\t\t;;\n\t\t\talliant)\n\t\t\t\tbasic_machine=fx80-alliant\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\taltos | altos3068)\n\t\t\t\tbasic_machine=m68k-altos\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tam29k)\n\t\t\t\tbasic_machine=a29k-none\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tamdahl)\n\t\t\t\tbasic_machine=580-amdahl\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tamiga)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tamigaos | amigados)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=amigaos\n\t\t\t\t;;\n\t\t\tamigaunix | amix)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tapollo68)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tapollo68bsd)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\taros)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=aros\n\t\t\t\t;;\n\t\t\taux)\n\t\t\t\tbasic_machine=m68k-apple\n\t\t\t\tbasic_os=aux\n\t\t\t\t;;\n\t\t\tbalance)\n\t\t\t\tbasic_machine=ns32k-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tblackfin)\n\t\t\t\tbasic_machine=bfin-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tcegcc)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=cegcc\n\t\t\t\t;;\n\t\t\tconvex-c1)\n\t\t\t\tbasic_machine=c1-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c2)\n\t\t\t\tbasic_machine=c2-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c32)\n\t\t\t\tbasic_machine=c32-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c34)\n\t\t\t\tbasic_machine=c34-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c38)\n\t\t\t\tbasic_machine=c38-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tcray)\n\t\t\t\tbasic_machine=j90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tcrds | unos)\n\t\t\t\tbasic_machine=m68k-crds\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tda30)\n\t\t\t\tbasic_machine=m68k-da30\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdecstation | pmax | pmin | dec3100 | decstatn)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdelta88)\n\t\t\t\tbasic_machine=m88k-motorola\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\tdicos)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=dicos\n\t\t\t\t;;\n\t\t\tdjgpp)\n\t\t\t\tbasic_machine=i586-pc\n\t\t\t\tbasic_os=msdosdjgpp\n\t\t\t\t;;\n\t\t\tebmon29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=ebmon\n\t\t\t\t;;\n\t\t\tes1800 | OSE68k | ose68k | ose | OSE)\n\t\t\t\tbasic_machine=m68k-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tgmicro)\n\t\t\t\tbasic_machine=tron-gmicro\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tgo32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=go32\n\t\t\t\t;;\n\t\t\th8300hms)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\th8300xray)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=xray\n\t\t\t\t;;\n\t\t\th8500hms)\n\t\t\t\tbasic_machine=h8500-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\tharris)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\thp300 | hp300hpux)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=hpux\n\t\t\t\t;;\n\t\t\thp300bsd)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\thppaosf)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\thppro)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=proelf\n\t\t\t\t;;\n\t\t\ti386mach)\n\t\t\t\tbasic_machine=i386-mach\n\t\t\t\tbasic_os=mach\n\t\t\t\t;;\n\t\t\tisi68 | isi)\n\t\t\t\tbasic_machine=m68k-isi\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tm68knommu)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tmagnum | m3230)\n\t\t\t\tbasic_machine=mips-mips\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmerlin)\n\t\t\t\tbasic_machine=ns32k-utek\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmingw64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=mingw64\n\t\t\t\t;;\n\t\t\tmingw32)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tmingw32ce)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=mingw32ce\n\t\t\t\t;;\n\t\t\tmonitor)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tmorphos)\n\t\t\t\tbasic_machine=powerpc-unknown\n\t\t\t\tbasic_os=morphos\n\t\t\t\t;;\n\t\t\tmoxiebox)\n\t\t\t\tbasic_machine=moxie-unknown\n\t\t\t\tbasic_os=moxiebox\n\t\t\t\t;;\n\t\t\tmsdos)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=msdos\n\t\t\t\t;;\n\t\t\tmsys)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=msys\n\t\t\t\t;;\n\t\t\tmvs)\n\t\t\t\tbasic_machine=i370-ibm\n\t\t\t\tbasic_os=mvs\n\t\t\t\t;;\n\t\t\tnacl)\n\t\t\t\tbasic_machine=le32-unknown\n\t\t\t\tbasic_os=nacl\n\t\t\t\t;;\n\t\t\tncr3000)\n\t\t\t\tbasic_machine=i486-ncr\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tnetbsd386)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=netbsd\n\t\t\t\t;;\n\t\t\tnetwinder)\n\t\t\t\tbasic_machine=armv4l-rebel\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tnews | news700 | news800 | news900)\n\t\t\t\tbasic_machine=m68k-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnews1000)\n\t\t\t\tbasic_machine=m68030-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnecv70)\n\t\t\t\tbasic_machine=v70-nec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tnh3000)\n\t\t\t\tbasic_machine=m68k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnh[45]000)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnindy960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=nindy\n\t\t\t\t;;\n\t\t\tmon960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=mon960\n\t\t\t\t;;\n\t\t\tnonstopux)\n\t\t\t\tbasic_machine=mips-compaq\n\t\t\t\tbasic_os=nonstopux\n\t\t\t\t;;\n\t\t\tos400)\n\t\t\t\tbasic_machine=powerpc-ibm\n\t\t\t\tbasic_os=os400\n\t\t\t\t;;\n\t\t\tOSE68000 | ose68000)\n\t\t\t\tbasic_machine=m68000-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tos68k)\n\t\t\t\tbasic_machine=m68k-none\n\t\t\t\tbasic_os=os68k\n\t\t\t\t;;\n\t\t\tparagon)\n\t\t\t\tbasic_machine=i860-intel\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\tparisc)\n\t\t\t\tbasic_machine=hppa-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tpsp)\n\t\t\t\tbasic_machine=mipsallegrexel-sony\n\t\t\t\tbasic_os=psp\n\t\t\t\t;;\n\t\t\tpw32)\n\t\t\t\tbasic_machine=i586-unknown\n\t\t\t\tbasic_os=pw32\n\t\t\t\t;;\n\t\t\trdos | rdos64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trdos32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trom68k)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tsa29200)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tsei)\n\t\t\t\tbasic_machine=mips-sei\n\t\t\t\tbasic_os=seiux\n\t\t\t\t;;\n\t\t\tsequent)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsps7)\n\t\t\t\tbasic_machine=m68k-bull\n\t\t\t\tbasic_os=sysv2\n\t\t\t\t;;\n\t\t\tst2000)\n\t\t\t\tbasic_machine=m68k-tandem\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tstratus)\n\t\t\t\tbasic_machine=i860-stratus\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tsun2)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun2os3)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun2os4)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun3os3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun3os4)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun4os3)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun4os4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4sol2)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=solaris2\n\t\t\t\t;;\n\t\t\tsun386 | sun386i | roadrunner)\n\t\t\t\tbasic_machine=i386-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsv1)\n\t\t\t\tbasic_machine=sv1-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tsymmetry)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tt3e)\n\t\t\t\tbasic_machine=alphaev5-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tt90)\n\t\t\t\tbasic_machine=t90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\ttoad1)\n\t\t\t\tbasic_machine=pdp10-xkl\n\t\t\t\tbasic_os=tops20\n\t\t\t\t;;\n\t\t\ttpf)\n\t\t\t\tbasic_machine=s390x-ibm\n\t\t\t\tbasic_os=tpf\n\t\t\t\t;;\n\t\t\tudi29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tultra3)\n\t\t\t\tbasic_machine=a29k-nyu\n\t\t\t\tbasic_os=sym1\n\t\t\t\t;;\n\t\t\tv810 | necv810)\n\t\t\t\tbasic_machine=v810-nec\n\t\t\t\tbasic_os=none\n\t\t\t\t;;\n\t\t\tvaxv)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tvms)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=vms\n\t\t\t\t;;\n\t\t\tvsta)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=vsta\n\t\t\t\t;;\n\t\t\tvxworks960)\n\t\t\t\tbasic_machine=i960-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks68)\n\t\t\t\tbasic_machine=m68k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks29k)\n\t\t\t\tbasic_machine=a29k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\txbox)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tymp)\n\t\t\t\tbasic_machine=ymp-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$1\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Decode 1-component or ad-hoc basic machines\ncase $basic_machine in\n\t# Here we handle the default manufacturer of certain CPU types.  It is in\n\t# some cases the only manufacturer, in others, it is the most popular.\n\tw89k)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\t;;\n\top50n)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\top60c)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\tibm*)\n\t\tcpu=i370\n\t\tvendor=ibm\n\t\t;;\n\torion105)\n\t\tcpu=clipper\n\t\tvendor=highlevel\n\t\t;;\n\tmac | mpw | mac-mpw)\n\t\tcpu=m68k\n\t\tvendor=apple\n\t\t;;\n\tpmac | pmac-mpw)\n\t\tcpu=powerpc\n\t\tvendor=apple\n\t\t;;\n\n\t# Recognize the various machine names and aliases which stand\n\t# for a CPU type and a company and sometimes even an OS.\n\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n\t\tcpu=m68000\n\t\tvendor=att\n\t\t;;\n\t3b*)\n\t\tcpu=we32k\n\t\tvendor=att\n\t\t;;\n\tbluegene*)\n\t\tcpu=powerpc\n\t\tvendor=ibm\n\t\tbasic_os=cnk\n\t\t;;\n\tdecsystem10* | dec10*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops10\n\t\t;;\n\tdecsystem20* | dec20*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops20\n\t\t;;\n\tdelta | 3300 | motorola-3300 | motorola-delta \\\n\t      | 3300-motorola | delta-motorola)\n\t\tcpu=m68k\n\t\tvendor=motorola\n\t\t;;\n\tdpx2*)\n\t\tcpu=m68k\n\t\tvendor=bull\n\t\tbasic_os=sysv3\n\t\t;;\n\tencore | umax | mmax)\n\t\tcpu=ns32k\n\t\tvendor=encore\n\t\t;;\n\telxsi)\n\t\tcpu=elxsi\n\t\tvendor=elxsi\n\t\tbasic_os=${basic_os:-bsd}\n\t\t;;\n\tfx2800)\n\t\tcpu=i860\n\t\tvendor=alliant\n\t\t;;\n\tgenix)\n\t\tcpu=ns32k\n\t\tvendor=ns\n\t\t;;\n\th3050r* | hiux*)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k2[0-9][0-9] | hp9k31[0-9])\n\t\tcpu=m68000\n\t\tvendor=hp\n\t\t;;\n\thp9k3[2-9][0-9])\n\t\tcpu=m68k\n\t\tvendor=hp\n\t\t;;\n\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k78[0-9] | hp78[0-9])\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][13679] | hp8[0-9][13679])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\ti*86v32)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv32\n\t\t;;\n\ti*86v4*)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv4\n\t\t;;\n\ti*86v)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv\n\t\t;;\n\ti*86sol2)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=solaris2\n\t\t;;\n\tj90 | j90-cray)\n\t\tcpu=j90\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicos}\n\t\t;;\n\tiris | iris4d)\n\t\tcpu=mips\n\t\tvendor=sgi\n\t\tcase $basic_os in\n\t\t    irix*)\n\t\t\t;;\n\t\t    *)\n\t\t\tbasic_os=irix4\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tminiframe)\n\t\tcpu=m68000\n\t\tvendor=convergent\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)\n\t\tcpu=m68k\n\t\tvendor=atari\n\t\tbasic_os=mint\n\t\t;;\n\tnews-3600 | risc-news)\n\t\tcpu=mips\n\t\tvendor=sony\n\t\tbasic_os=newsos\n\t\t;;\n\tnext | m*-next)\n\t\tcpu=m68k\n\t\tvendor=next\n\t\tcase $basic_os in\n\t\t    openstep*)\n\t\t        ;;\n\t\t    nextstep*)\n\t\t\t;;\n\t\t    ns2*)\n\t\t      basic_os=nextstep2\n\t\t\t;;\n\t\t    *)\n\t\t      basic_os=nextstep3\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tnp1)\n\t\tcpu=np1\n\t\tvendor=gould\n\t\t;;\n\top50n-* | op60c-*)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\tbasic_os=proelf\n\t\t;;\n\tpa-hitachi)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\tpbd)\n\t\tcpu=sparc\n\t\tvendor=tti\n\t\t;;\n\tpbb)\n\t\tcpu=m68k\n\t\tvendor=tti\n\t\t;;\n\tpc532)\n\t\tcpu=ns32k\n\t\tvendor=pc532\n\t\t;;\n\tpn)\n\t\tcpu=pn\n\t\tvendor=gould\n\t\t;;\n\tpower)\n\t\tcpu=power\n\t\tvendor=ibm\n\t\t;;\n\tps2)\n\t\tcpu=i386\n\t\tvendor=ibm\n\t\t;;\n\trm[46]00)\n\t\tcpu=mips\n\t\tvendor=siemens\n\t\t;;\n\trtpc | rtpc-*)\n\t\tcpu=romp\n\t\tvendor=ibm\n\t\t;;\n\tsde)\n\t\tcpu=mipsisa32\n\t\tvendor=sde\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tsimso-wrs)\n\t\tcpu=sparclite\n\t\tvendor=wrs\n\t\tbasic_os=vxworks\n\t\t;;\n\ttower | tower-32)\n\t\tcpu=m68k\n\t\tvendor=ncr\n\t\t;;\n\tvpp*|vx|vx-*)\n\t\tcpu=f301\n\t\tvendor=fujitsu\n\t\t;;\n\tw65)\n\t\tcpu=w65\n\t\tvendor=wdc\n\t\t;;\n\tw89k-*)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\tbasic_os=proelf\n\t\t;;\n\tnone)\n\t\tcpu=none\n\t\tvendor=none\n\t\t;;\n\tleon|leon[3-9])\n\t\tcpu=sparc\n\t\tvendor=$basic_machine\n\t\t;;\n\tleon-*|leon[3-9]-*)\n\t\tcpu=sparc\n\t\tvendor=`echo \"$basic_machine\" | sed 's/-.*//'`\n\t\t;;\n\n\t*-*)\n\t\t# shellcheck disable=SC2162\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read cpu vendor <<EOF\n$basic_machine\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# We use 'pc' rather than 'unknown'\n\t# because (1) that's what they normally are, and\n\t# (2) the word \"unknown\" tends to confuse beginning users.\n\ti*86 | x86_64)\n\t\tcpu=$basic_machine\n\t\tvendor=pc\n\t\t;;\n\t# These rules are duplicated from below for sake of the special case above;\n\t# i.e. things that normalized to x86 arches should also default to \"pc\"\n\tpc98)\n\t\tcpu=i386\n\t\tvendor=pc\n\t\t;;\n\tx64 | amd64)\n\t\tcpu=x86_64\n\t\tvendor=pc\n\t\t;;\n\t# Recognize the basic CPU types without company name.\n\t*)\n\t\tcpu=$basic_machine\n\t\tvendor=unknown\n\t\t;;\nesac\n\nunset -v basic_machine\n\n# Decode basic machines in the full and proper CPU-Company form.\ncase $cpu-$vendor in\n\t# Here we handle the default manufacturer of certain CPU types in canonical form. It is in\n\t# some cases the only manufacturer, in others, it is the most popular.\n\tcraynv-unknown)\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicosmp}\n\t\t;;\n\tc90-unknown | c90-cray)\n\t\tvendor=cray\n\t\tbasic_os=${Basic_os:-unicos}\n\t\t;;\n\tfx80-unknown)\n\t\tvendor=alliant\n\t\t;;\n\tromp-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tmmix-unknown)\n\t\tvendor=knuth\n\t\t;;\n\tmicroblaze-unknown | microblazeel-unknown)\n\t\tvendor=xilinx\n\t\t;;\n\trs6000-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tvax-unknown)\n\t\tvendor=dec\n\t\t;;\n\tpdp11-unknown)\n\t\tvendor=dec\n\t\t;;\n\twe32k-unknown)\n\t\tvendor=att\n\t\t;;\n\tcydra-unknown)\n\t\tvendor=cydrome\n\t\t;;\n\ti370-ibm*)\n\t\tvendor=ibm\n\t\t;;\n\torion-unknown)\n\t\tvendor=highlevel\n\t\t;;\n\txps-unknown | xps100-unknown)\n\t\tcpu=xps100\n\t\tvendor=honeywell\n\t\t;;\n\n\t# Here we normalize CPU types with a missing or matching vendor\n\tarmh-unknown | armh-alt)\n\t\tcpu=armv7l\n\t\tvendor=alt\n\t\tbasic_os=${basic_os:-linux-gnueabihf}\n\t\t;;\n\tdpx20-unknown | dpx20-bull)\n\t\tcpu=rs6000\n\t\tvendor=bull\n\t\tbasic_os=${basic_os:-bosx}\n\t\t;;\n\n\t# Here we normalize CPU types irrespective of the vendor\n\tamd64-*)\n\t\tcpu=x86_64\n\t\t;;\n\tblackfin-*)\n\t\tcpu=bfin\n\t\tbasic_os=linux\n\t\t;;\n\tc54x-*)\n\t\tcpu=tic54x\n\t\t;;\n\tc55x-*)\n\t\tcpu=tic55x\n\t\t;;\n\tc6x-*)\n\t\tcpu=tic6x\n\t\t;;\n\te500v[12]-*)\n\t\tcpu=powerpc\n\t\tbasic_os=${basic_os}\"spe\"\n\t\t;;\n\tmips3*-*)\n\t\tcpu=mips64\n\t\t;;\n\tms1-*)\n\t\tcpu=mt\n\t\t;;\n\tm68knommu-*)\n\t\tcpu=m68k\n\t\tbasic_os=linux\n\t\t;;\n\tm9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)\n\t\tcpu=s12z\n\t\t;;\n\topenrisc-*)\n\t\tcpu=or32\n\t\t;;\n\tparisc-*)\n\t\tcpu=hppa\n\t\tbasic_os=linux\n\t\t;;\n\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n\t\tcpu=i586\n\t\t;;\n\tpentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)\n\t\tcpu=i686\n\t\t;;\n\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n\t\tcpu=i686\n\t\t;;\n\tpentium4-*)\n\t\tcpu=i786\n\t\t;;\n\tpc98-*)\n\t\tcpu=i386\n\t\t;;\n\tppc-* | ppcbe-*)\n\t\tcpu=powerpc\n\t\t;;\n\tppcle-* | powerpclittle-*)\n\t\tcpu=powerpcle\n\t\t;;\n\tppc64-*)\n\t\tcpu=powerpc64\n\t\t;;\n\tppc64le-* | powerpc64little-*)\n\t\tcpu=powerpc64le\n\t\t;;\n\tsb1-*)\n\t\tcpu=mipsisa64sb1\n\t\t;;\n\tsb1el-*)\n\t\tcpu=mipsisa64sb1el\n\t\t;;\n\tsh5e[lb]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^\\(sh.\\)e\\(.\\)$/\\1\\2e/'`\n\t\t;;\n\tspur-*)\n\t\tcpu=spur\n\t\t;;\n\tstrongarm-* | thumb-*)\n\t\tcpu=arm\n\t\t;;\n\ttx39-*)\n\t\tcpu=mipstx39\n\t\t;;\n\ttx39el-*)\n\t\tcpu=mipstx39el\n\t\t;;\n\tx64-*)\n\t\tcpu=x86_64\n\t\t;;\n\txscale-* | xscalee[bl]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^xscale/arm/'`\n\t\t;;\n\tarm64-* | aarch64le-*)\n\t\tcpu=aarch64\n\t\t;;\n\n\t# Recognize the canonical CPU Types that limit and/or modify the\n\t# company names they are paired with.\n\tcr16-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tcrisv32-* | etraxfs*-*)\n\t\tcpu=crisv32\n\t\tvendor=axis\n\t\t;;\n\tcris-* | etrax*-*)\n\t\tcpu=cris\n\t\tvendor=axis\n\t\t;;\n\tcrx-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tneo-tandem)\n\t\tcpu=neo\n\t\tvendor=tandem\n\t\t;;\n\tnse-tandem)\n\t\tcpu=nse\n\t\tvendor=tandem\n\t\t;;\n\tnsr-tandem)\n\t\tcpu=nsr\n\t\tvendor=tandem\n\t\t;;\n\tnsv-tandem)\n\t\tcpu=nsv\n\t\tvendor=tandem\n\t\t;;\n\tnsx-tandem)\n\t\tcpu=nsx\n\t\tvendor=tandem\n\t\t;;\n\tmipsallegrexel-sony)\n\t\tcpu=mipsallegrexel\n\t\tvendor=sony\n\t\t;;\n\ttile*-*)\n\t\tbasic_os=${basic_os:-linux-gnu}\n\t\t;;\n\n\t*)\n\t\t# Recognize the canonical CPU types that are allowed with any\n\t\t# company name.\n\t\tcase $cpu in\n\t\t\t1750a | 580 \\\n\t\t\t| a29k \\\n\t\t\t| aarch64 | aarch64_be | aarch64c | arm64ec \\\n\t\t\t| abacus \\\n\t\t\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \\\n\t\t\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \\\n\t\t\t| alphapca5[67] | alpha64pca5[67] \\\n\t\t\t| am33_2.0 \\\n\t\t\t| amdgcn \\\n\t\t\t| arc | arceb | arc32 | arc64 \\\n\t\t\t| arm | arm[lb]e | arme[lb] | armv* \\\n\t\t\t| avr | avr32 \\\n\t\t\t| asmjs \\\n\t\t\t| ba \\\n\t\t\t| be32 | be64 \\\n\t\t\t| bfin | bpf | bs2000 \\\n\t\t\t| c[123]* | c30 | [cjt]90 | c4x \\\n\t\t\t| c8051 | clipper | craynv | csky | cydra \\\n\t\t\t| d10v | d30v | dlx | dsp16xx \\\n\t\t\t| e2k | elxsi | epiphany \\\n\t\t\t| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \\\n\t\t\t| javascript \\\n\t\t\t| h8300 | h8500 \\\n\t\t\t| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n\t\t\t| hexagon \\\n\t\t\t| i370 | i*86 | i860 | i960 | ia16 | ia64 \\\n\t\t\t| ip2k | iq2000 \\\n\t\t\t| k1om \\\n\t\t\t| kvx \\\n\t\t\t| le32 | le64 \\\n\t\t\t| lm32 \\\n\t\t\t| loongarch32 | loongarch64 \\\n\t\t\t| m32c | m32r | m32rle \\\n\t\t\t| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \\\n\t\t\t| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \\\n\t\t\t| m88110 | m88k | maxq | mb | mcore | mep | metag \\\n\t\t\t| microblaze | microblazeel \\\n\t\t\t| mips* \\\n\t\t\t| mmix \\\n\t\t\t| mn10200 | mn10300 \\\n\t\t\t| moxie \\\n\t\t\t| mt \\\n\t\t\t| msp430 \\\n\t\t\t| nanomips* \\\n\t\t\t| nds32 | nds32le | nds32be \\\n\t\t\t| nfp \\\n\t\t\t| nios | nios2 | nios2eb | nios2el \\\n\t\t\t| none | np1 | ns16k | ns32k | nvptx \\\n\t\t\t| open8 \\\n\t\t\t| or1k* \\\n\t\t\t| or32 \\\n\t\t\t| orion \\\n\t\t\t| picochip \\\n\t\t\t| pdp10 | pdp11 | pj | pjl | pn | power \\\n\t\t\t| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \\\n\t\t\t| pru \\\n\t\t\t| pyramid \\\n\t\t\t| riscv | riscv32 | riscv32be | riscv64 | riscv64be \\\n\t\t\t| rl78 | romp | rs6000 | rx \\\n\t\t\t| s390 | s390x \\\n\t\t\t| score \\\n\t\t\t| sh | shl \\\n\t\t\t| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \\\n\t\t\t| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \\\n\t\t\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \\\n\t\t\t| sparclite \\\n\t\t\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \\\n\t\t\t| spu \\\n\t\t\t| tahoe \\\n\t\t\t| thumbv7* \\\n\t\t\t| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \\\n\t\t\t| tron \\\n\t\t\t| ubicom32 \\\n\t\t\t| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \\\n\t\t\t| vax \\\n\t\t\t| vc4 \\\n\t\t\t| visium \\\n\t\t\t| w65 \\\n\t\t\t| wasm32 | wasm64 \\\n\t\t\t| we32k \\\n\t\t\t| x86 | x86_64 | xc16x | xgate | xps100 \\\n\t\t\t| xstormy16 | xtensa* \\\n\t\t\t| ymp \\\n\t\t\t| z8k | z80)\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\techo \"Invalid configuration '$1': machine '$cpu-$vendor' not recognized\" 1>&2\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Here we canonicalize certain aliases for manufacturers.\ncase $vendor in\n\tdigital*)\n\t\tvendor=dec\n\t\t;;\n\tcommodore*)\n\t\tvendor=cbm\n\t\t;;\n\t*)\n\t\t;;\nesac\n\n# Decode manufacturer-specific aliases for certain operating systems.\n\nif test x\"$basic_os\" != x\nthen\n\n# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just\n# set os.\nobj=\ncase $basic_os in\n\tgnu/linux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|gnu/linux|gnu|'`\n\t\t;;\n\tos2-emx)\n\t\tkernel=os2\n\t\tos=`echo \"$basic_os\" | sed -e 's|os2-emx|emx|'`\n\t\t;;\n\tnto-qnx*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto-qnx|qnx|'`\n\t\t;;\n\t*-*)\n\t\t# shellcheck disable=SC2162\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read kernel os <<EOF\n$basic_os\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# Default OS when just kernel was specified\n\tnto*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto|qnx|'`\n\t\t;;\n\tlinux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|linux|gnu|'`\n\t\t;;\n\tmanagarm*)\n\t\tkernel=managarm\n\t\tos=`echo \"$basic_os\" | sed -e 's|managarm|mlibc|'`\n\t\t;;\n\t*)\n\t\tkernel=\n\t\tos=$basic_os\n\t\t;;\nesac\n\n# Now, normalize the OS (knowing we just have one component, it's not a kernel,\n# etc.)\ncase $os in\n\t# First match some system type aliases that might get confused\n\t# with valid system types.\n\t# solaris* is a basic system type, with this one exception.\n\tauroraux)\n\t\tos=auroraux\n\t\t;;\n\tbluegene*)\n\t\tos=cnk\n\t\t;;\n\tsolaris1 | solaris1.*)\n\t\tos=`echo \"$os\" | sed -e 's|solaris1|sunos4|'`\n\t\t;;\n\tsolaris)\n\t\tos=solaris2\n\t\t;;\n\tunixware*)\n\t\tos=sysv4.2uw\n\t\t;;\n\t# es1800 is here to avoid being matched by es* (a different OS)\n\tes1800*)\n\t\tos=ose\n\t\t;;\n\t# Some version numbers need modification\n\tchorusos*)\n\t\tos=chorusos\n\t\t;;\n\tisc)\n\t\tos=isc2.2\n\t\t;;\n\tsco6)\n\t\tos=sco5v6\n\t\t;;\n\tsco5)\n\t\tos=sco3.2v5\n\t\t;;\n\tsco4)\n\t\tos=sco3.2v4\n\t\t;;\n\tsco3.2.[4-9]*)\n\t\tos=`echo \"$os\" | sed -e 's/sco3.2./sco3.2v/'`\n\t\t;;\n\tsco*v* | scout)\n\t\t# Don't match below\n\t\t;;\n\tsco*)\n\t\tos=sco3.2v2\n\t\t;;\n\tpsos*)\n\t\tos=psos\n\t\t;;\n\tqnx*)\n\t\tos=qnx\n\t\t;;\n\thiux*)\n\t\tos=hiuxwe2\n\t\t;;\n\tlynx*178)\n\t\tos=lynxos178\n\t\t;;\n\tlynx*5)\n\t\tos=lynxos5\n\t\t;;\n\tlynxos*)\n\t\t# don't get caught up in next wildcard\n\t\t;;\n\tlynx*)\n\t\tos=lynxos\n\t\t;;\n\tmac[0-9]*)\n\t\tos=`echo \"$os\" | sed -e 's|mac|macos|'`\n\t\t;;\n\topened*)\n\t\tos=openedition\n\t\t;;\n\tos400*)\n\t\tos=os400\n\t\t;;\n\tsunos5*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos5|solaris2|'`\n\t\t;;\n\tsunos6*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos6|solaris3|'`\n\t\t;;\n\twince*)\n\t\tos=wince\n\t\t;;\n\tutek*)\n\t\tos=bsd\n\t\t;;\n\tdynix*)\n\t\tos=bsd\n\t\t;;\n\tacis*)\n\t\tos=aos\n\t\t;;\n\tatheos*)\n\t\tos=atheos\n\t\t;;\n\tsyllable*)\n\t\tos=syllable\n\t\t;;\n\t386bsd)\n\t\tos=bsd\n\t\t;;\n\tctix* | uts*)\n\t\tos=sysv\n\t\t;;\n\tnova*)\n\t\tos=rtmk-nova\n\t\t;;\n\tns2)\n\t\tos=nextstep2\n\t\t;;\n\t# Preserve the version number of sinix5.\n\tsinix5.*)\n\t\tos=`echo \"$os\" | sed -e 's|sinix|sysv|'`\n\t\t;;\n\tsinix*)\n\t\tos=sysv4\n\t\t;;\n\ttpf*)\n\t\tos=tpf\n\t\t;;\n\ttriton*)\n\t\tos=sysv3\n\t\t;;\n\toss*)\n\t\tos=sysv3\n\t\t;;\n\tsvr4*)\n\t\tos=sysv4\n\t\t;;\n\tsvr3)\n\t\tos=sysv3\n\t\t;;\n\tsysvr4)\n\t\tos=sysv4\n\t\t;;\n\tose*)\n\t\tos=ose\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)\n\t\tos=mint\n\t\t;;\n\tdicos*)\n\t\tos=dicos\n\t\t;;\n\tpikeos*)\n\t\t# Until real need of OS specific support for\n\t\t# particular features comes up, bare metal\n\t\t# configurations are quite functional.\n\t\tcase $cpu in\n\t\t    arm*)\n\t\t\tos=eabi\n\t\t\t;;\n\t\t    *)\n\t\t\tos=\n\t\t\tobj=elf\n\t\t\t;;\n\t\tesac\n\t\t;;\n\taout* | coff* | elf* | pe*)\n\t\t# These are machine code file formats, not OSes\n\t\tobj=$os\n\t\tos=\n\t\t;;\n\t*)\n\t\t# No normalization, but not necessarily accepted, that comes below.\n\t\t;;\nesac\n\nelse\n\n# Here we handle the default operating systems that come with various machines.\n# The value should be what the vendor currently ships out the door with their\n# machine or put another way, the most popular os provided with the machine.\n\n# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n# \"-sun\"), then you have to tell the case statement up towards the top\n# that MANUFACTURER isn't an operating system.  Otherwise, code above\n# will signal an error saying that MANUFACTURER isn't an operating\n# system, and we'll never get to this point.\n\nkernel=\nobj=\ncase $cpu-$vendor in\n\tscore-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tspu-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\t*-acorn)\n\t\tos=riscix1.2\n\t\t;;\n\tarm*-rebel)\n\t\tkernel=linux\n\t\tos=gnu\n\t\t;;\n\tarm*-semi)\n\t\tos=\n\t\tobj=aout\n\t\t;;\n\tc4x-* | tic4x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\tc8051-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tclipper-intergraph)\n\t\tos=clix\n\t\t;;\n\thexagon-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\ttic54x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\ttic55x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\ttic6x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t# This must come before the *-dec entry.\n\tpdp10-*)\n\t\tos=tops20\n\t\t;;\n\tpdp11-*)\n\t\tos=none\n\t\t;;\n\t*-dec | vax-*)\n\t\tos=ultrix4.2\n\t\t;;\n\tm68*-apollo)\n\t\tos=domain\n\t\t;;\n\ti386-sun)\n\t\tos=sunos4.0.2\n\t\t;;\n\tm68000-sun)\n\t\tos=sunos3\n\t\t;;\n\tm68*-cisco)\n\t\tos=\n\t\tobj=aout\n\t\t;;\n\tmep-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tmips*-cisco)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tmips*-*|nanomips*-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tor32-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t*-tti)\t# must be before sparc entry or we get the wrong os.\n\t\tos=sysv3\n\t\t;;\n\tsparc-* | *-sun)\n\t\tos=sunos4.1.1\n\t\t;;\n\tpru-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\t*-be)\n\t\tos=beos\n\t\t;;\n\t*-ibm)\n\t\tos=aix\n\t\t;;\n\t*-knuth)\n\t\tos=mmixware\n\t\t;;\n\t*-wec)\n\t\tos=proelf\n\t\t;;\n\t*-winbond)\n\t\tos=proelf\n\t\t;;\n\t*-oki)\n\t\tos=proelf\n\t\t;;\n\t*-hp)\n\t\tos=hpux\n\t\t;;\n\t*-hitachi)\n\t\tos=hiux\n\t\t;;\n\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n\t\tos=sysv\n\t\t;;\n\t*-cbm)\n\t\tos=amigaos\n\t\t;;\n\t*-dg)\n\t\tos=dgux\n\t\t;;\n\t*-dolphin)\n\t\tos=sysv3\n\t\t;;\n\tm68k-ccur)\n\t\tos=rtu\n\t\t;;\n\tm88k-omron*)\n\t\tos=luna\n\t\t;;\n\t*-next)\n\t\tos=nextstep\n\t\t;;\n\t*-sequent)\n\t\tos=ptx\n\t\t;;\n\t*-crds)\n\t\tos=unos\n\t\t;;\n\t*-ns)\n\t\tos=genix\n\t\t;;\n\ti370-*)\n\t\tos=mvs\n\t\t;;\n\t*-gould)\n\t\tos=sysv\n\t\t;;\n\t*-highlevel)\n\t\tos=bsd\n\t\t;;\n\t*-encore)\n\t\tos=bsd\n\t\t;;\n\t*-sgi)\n\t\tos=irix\n\t\t;;\n\t*-siemens)\n\t\tos=sysv4\n\t\t;;\n\t*-masscomp)\n\t\tos=rtu\n\t\t;;\n\tf30[01]-fujitsu | f700-fujitsu)\n\t\tos=uxpv\n\t\t;;\n\t*-rom68k)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t*-*bug)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t*-apple)\n\t\tos=macos\n\t\t;;\n\t*-atari*)\n\t\tos=mint\n\t\t;;\n\t*-wrs)\n\t\tos=vxworks\n\t\t;;\n\t*)\n\t\tos=none\n\t\t;;\nesac\n\nfi\n\n# Now, validate our (potentially fixed-up) individual pieces (OS, OBJ).\n\ncase $os in\n\t# Sometimes we do \"kernel-libc\", so those need to count as OSes.\n\tllvm* | musl* | newlib* | relibc* | uclibc*)\n\t\t;;\n\t# Likewise for \"kernel-abi\"\n\teabi* | gnueabi*)\n\t\t;;\n\t# VxWorks passes extra cpu info in the 4th filed.\n\tsimlinux | simwindows | spe)\n\t\t;;\n\t# See `case $cpu-$os` validation below\n\tghcjs)\n\t\t;;\n\t# Now accept the basic system types.\n\t# The portable systems comes first.\n\t# Each alternative MUST end in a * to match a version number.\n\tgnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \\\n\t     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \\\n\t     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \\\n\t     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \\\n\t     | hiux* | abug | nacl* | netware* | windows* \\\n\t     | os9* | macos* | osx* | ios* | tvos* | watchos* \\\n\t     | mpw* | magic* | mmixware* | mon960* | lnews* \\\n\t     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \\\n\t     | aos* | aros* | cloudabi* | sortix* | twizzler* \\\n\t     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \\\n\t     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \\\n\t     | mirbsd* | netbsd* | dicos* | openedition* | ose* \\\n\t     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \\\n\t     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \\\n\t     | bosx* | nextstep* | cxux* | oabi* \\\n\t     | ptx* | ecoff* | winnt* | domain* | vsta* \\\n\t     | udi* | lites* | ieee* | go32* | aux* | hcos* \\\n\t     | chorusrdb* | cegcc* | glidix* | serenity* \\\n\t     | cygwin* | msys* | moss* | proelf* | rtems* \\\n\t     | midipix* | mingw32* | mingw64* | mint* \\\n\t     | uxpv* | beos* | mpeix* | udk* | moxiebox* \\\n\t     | interix* | uwin* | mks* | rhapsody* | darwin* \\\n\t     | openstep* | oskit* | conix* | pw32* | nonstopux* \\\n\t     | storm-chaos* | tops10* | tenex* | tops20* | its* \\\n\t     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \\\n\t     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \\\n\t     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \\\n\t     | skyos* | haiku* | rdos* | toppers* | drops* | es* \\\n\t     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \\\n\t     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \\\n\t     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \\\n\t     | fiwix* | mlibc* | cos* | mbr* | ironclad* )\n\t\t;;\n\t# This one is extra strict with allowed versions\n\tsco3.2v2 | sco3.2v[4-9]* | sco5v6*)\n\t\t# Don't forget version if it is 3.2v4 or newer.\n\t\t;;\n\t# This refers to builds using the UEFI calling convention\n\t# (which depends on the architecture) and PE file format.\n\t# Note that this is both a different calling convention and\n\t# different file format than that of GNU-EFI\n\t# (x86_64-w64-mingw32).\n\tuefi)\n\t\t;;\n\tnone)\n\t\t;;\n\tkernel* | msvc* )\n\t\t# Restricted further below\n\t\t;;\n\t'')\n\t\tif test x\"$obj\" = x\n\t\tthen\n\t\t\techo \"Invalid configuration '$1': Blank OS only allowed with explicit machine code file format\" 1>&2\n\t\tfi\n\t\t;;\n\t*)\n\t\techo \"Invalid configuration '$1': OS '$os' not recognized\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\ncase $obj in\n\taout* | coff* | elf* | pe*)\n\t\t;;\n\t'')\n\t\t# empty is fine\n\t\t;;\n\t*)\n\t\techo \"Invalid configuration '$1': Machine code format '$obj' not recognized\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# Here we handle the constraint that a (synthetic) cpu and os are\n# valid only in combination with each other and nowhere else.\ncase $cpu-$os in\n\t# The \"javascript-unknown-ghcjs\" triple is used by GHC; we\n\t# accept it here in order to tolerate that, but reject any\n\t# variations.\n\tjavascript-ghcjs)\n\t\t;;\n\tjavascript-* | *-ghcjs)\n\t\techo \"Invalid configuration '$1': cpu '$cpu' is not valid with os '$os$obj'\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# As a final step for OS-related things, validate the OS-kernel combination\n# (given a valid OS), if there is a kernel.\ncase $kernel-$os-$obj in\n\tlinux-gnu*- | linux-android*- | linux-dietlibc*- | linux-llvm*- \\\n\t\t    | linux-mlibc*- | linux-musl*- | linux-newlib*- \\\n\t\t    | linux-relibc*- | linux-uclibc*- )\n\t\t;;\n\tuclinux-uclibc*- )\n\t\t;;\n\tmanagarm-mlibc*- | managarm-kernel*- )\n\t\t;;\n\twindows*-msvc*-)\n\t\t;;\n\t-dietlibc*- | -llvm*- | -mlibc*- | -musl*- | -newlib*- | -relibc*- \\\n\t\t    | -uclibc*- )\n\t\t# These are just libc implementations, not actual OSes, and thus\n\t\t# require a kernel.\n\t\techo \"Invalid configuration '$1': libc '$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t-kernel*- )\n\t\techo \"Invalid configuration '$1': '$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t*-kernel*- )\n\t\techo \"Invalid configuration '$1': '$kernel' does not support '$os'.\" 1>&2\n\t\texit 1\n\t\t;;\n\t*-msvc*- )\n\t\techo \"Invalid configuration '$1': '$os' needs 'windows'.\" 1>&2\n\t\texit 1\n\t\t;;\n\tkfreebsd*-gnu*- | kopensolaris*-gnu*-)\n\t\t;;\n\tvxworks-simlinux- | vxworks-simwindows- | vxworks-spe-)\n\t\t;;\n\tnto-qnx*-)\n\t\t;;\n\tos2-emx-)\n\t\t;;\n\t*-eabi*- | *-gnueabi*-)\n\t\t;;\n\tnone--*)\n\t\t# None (no kernel, i.e. freestanding / bare metal),\n\t\t# can be paired with an machine code file format\n\t\t;;\n\t-*-)\n\t\t# Blank kernel with real OS is always fine.\n\t\t;;\n\t--*)\n\t\t# Blank kernel and OS with real machine code file format is always fine.\n\t\t;;\n\t*-*-*)\n\t\techo \"Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'.\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# Here we handle the case where we know the os, and the CPU type, but not the\n# manufacturer.  We pick the logical manufacturer.\ncase $vendor in\n\tunknown)\n\t\tcase $cpu-$os in\n\t\t\t*-riscix*)\n\t\t\t\tvendor=acorn\n\t\t\t\t;;\n\t\t\t*-sunos*)\n\t\t\t\tvendor=sun\n\t\t\t\t;;\n\t\t\t*-cnk* | *-aix*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-beos*)\n\t\t\t\tvendor=be\n\t\t\t\t;;\n\t\t\t*-hpux*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-mpeix*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-hiux*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-unos*)\n\t\t\t\tvendor=crds\n\t\t\t\t;;\n\t\t\t*-dgux*)\n\t\t\t\tvendor=dg\n\t\t\t\t;;\n\t\t\t*-luna*)\n\t\t\t\tvendor=omron\n\t\t\t\t;;\n\t\t\t*-genix*)\n\t\t\t\tvendor=ns\n\t\t\t\t;;\n\t\t\t*-clix*)\n\t\t\t\tvendor=intergraph\n\t\t\t\t;;\n\t\t\t*-mvs* | *-opened*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-os400*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\ts390-* | s390x-*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-ptx*)\n\t\t\t\tvendor=sequent\n\t\t\t\t;;\n\t\t\t*-tpf*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-vxsim* | *-vxworks* | *-windiss*)\n\t\t\t\tvendor=wrs\n\t\t\t\t;;\n\t\t\t*-aux*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-hms*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-mpw* | *-macos*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)\n\t\t\t\tvendor=atari\n\t\t\t\t;;\n\t\t\t*-vos*)\n\t\t\t\tvendor=stratus\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\necho \"$cpu-$vendor${kernel:+-$kernel}${os:+-$os}${obj:+-$obj}\"\nexit\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 84.1474609375,
          "content": "dnl\ndnl Copyright (c) 1994, 1995, 1996, 1997\ndnl\tThe Regents of the University of California.  All rights reserved.\ndnl\ndnl Process this file with autoconf to produce a configure script.\ndnl\n\n#\n# See\n#\n#\thttps://ftp.gnu.org/gnu/config/README\n#\n# for the URLs to use to fetch new versions of config.guess and\n# config.sub.\n#\n\nAC_PREREQ([2.69])\n\nAC_INIT([pcap],[m4_esyscmd_s(cat VERSION)],[https://github.com/the-tcpdump-group/libpcap/issues])\nAC_CONFIG_SRCDIR(pcap.c)\nAC_SUBST(PACKAGE_NAME)\n\n#\n# These are the variables that are used in Makefile, pcap-config, and\n# libpcap.pc.\n#\n# CFLAGS: inherited from the environment, not modified by us except\n# for flags required for the platform for which we're building (and\n# except temporarily during tests that involve compilation).  Used only\n# when compiling C source.\n#\n# LDFLAGS: inherited from the environment, not modified by us.\n#\n# LIBS: inherited from the environment; we add libraries required by\n# libpcap.  Libraries that the core libpcap code requires are added\n# first; libraries required by additional pcap modules are first\n# added to ADDITIONAL_LIBS, and only added to LIBS at the end, after\n# we're finished doing configuration tests for the modules.\n#\n# LIBS_STATIC: libraries with which a program using the libpcap *static*\n# library needs to be linked.  This is a superset of LIBS, used in\n# pcap-config, so that \"pcap-config --libs --static\" will report them.\n# Initialized to LIBS.\n#\n# REQUIRES_PRIVATE: pkg-config package names for additional libraries\n# with which a program using the libpcap *static* library needs to be\n# linked and for which a .pc file exists.  This is used in libpcap.pc,\n# so that \"pkg-config --libs --static\" will report them, and so that\n# those libraries will be determined using the library's .pc file, not\n# from our .pc file.  Initialized to an empty string.\n#\n# V_CCOPT: additional compiler flags other than -I and -D flags\n# needed when compiling libpcap.  Used in Makefile for both C and\n# C++ source.\n#\n# V_DEFS: additional -D compiler flags needed when compiling\n# libpcap.  Used in Makefile for both C and C++ source.\n#\n# V_INCLS: additional -I compiler flags needed when compiling\n# libpcap.  Used in Makefile for both C and C++ source.\n#\n# ADDITIONAL_LIBS: additional libraries with which the libpcap dynamic\n# library needs to be linked.  Used in Makefile; not used in pcap-config\n# or libpcap.pc, as, in all platforms on which we run, if a dynamic\n# library is linked with other dynamic libraries, a program using\n# that dynamic library doesn't have to link with those libraries -\n# they will be automatically loaded at run time.  Initialized to an\n# empty string.\n#\n# ADDITIONAL_LIBS_STATIC: additional libraries with which a program\n# using the libpcap *static* library needs to be linked.  This is used\n# in pcap-config, so that \"pcap-config --libs --static\" will report\n# them.  Initialized to an empty string.\n#\n# REQUIRES_PRIVATE: pkg-config package names for additional libraries\n# with which a program using the libpcap *static* library needs to be\n# linked and for which a .pc file exists.  This is used in libpcap.pc,\n# so that \"pkg-config --libs --static\" will report them, and so that\n# those libraries will be determined using the library's .pc file, not\n# from our .pc file.  Initialized to an empty string.\n#\n# LIBS_PRIVATE: pkg-config package names for additional libraries with\n# which a program using the libpcap *static* library needs to be linked\n# and for which a .pc file does not exist.  This is used in libpcap.pc,\n# so that \"pkg-config --libs --static\" will report them (those libraries\n# cannot be determined using the library's .pc file, as there is no such\n# file, so it has to come from our .pc file.  Initialized to an empty\n# string.\n#\nLIBS_STATIC=\"\"\nREQUIRES_PRIVATE=\"\"\nLIBS_PRIVATE=\"\"\n\nAC_SUBST(V_CCOPT)\nAC_SUBST(V_DEFS)\nAC_SUBST(V_INCLS)\nAC_SUBST(LIBS_STATIC)\nAC_SUBST(REQUIRES_PRIVATE)\nAC_SUBST(LIBS_PRIVATE)\n\nAC_CANONICAL_HOST\n\nAC_LBL_C_INIT_BEFORE_CC(V_CCOPT, V_INCLS)\n#\n# We require C99 or later.\n# Try to get it, which may involve adding compiler flags;\n# if that fails, give up.\n#\nAC_PROG_CC_C99\nif test \"$ac_cv_prog_cc_c99\" = \"no\"; then\n\tAC_MSG_WARN([The C compiler does not support C99; there may be compiler errors])\nfi\n\n#\n# Try to arrange for large file support.\n#\nAC_SYS_LARGEFILE\nAC_FUNC_FSEEKO\n\n#\n# Get the size of a void *, to determine whether this is a 32-bit\n# or 64-bit build.\n#\nAC_CHECK_SIZEOF([void *])\nac_lbl_c_sizeof_void_p=\"$ac_cv_sizeof_void_p\"\n\n#\n# Get the size of a time_t, to know whether it's 32-bit or 64-bit.\n#\nAC_CHECK_SIZEOF([time_t],,[#include <time.h>])\n\nAC_LBL_C_INIT(V_CCOPT, V_INCLS)\nAC_LBL_SHLIBS_INIT\nAC_PCAP_C___ATOMICS\n\ndnl\ndnl HAVE_SYS_IOCCOM_H will be required for a few workarounds until all\ndnl supported OSes that use BPF have <net/bpf.h> that includes <sys/ioccom.h>\ndnl (this might have already happened).\ndnl\nAC_CHECK_HEADERS(sys/ioccom.h sys/sockio.h)\nAC_CHECK_HEADERS(netpacket/packet.h)\n\n#\n# Check whether the platform for which we're compiling requires extra\n# defines and libraries.  If so, add them to CFLAGS and LIBS, as we want\n# all subsequent tests to be done with those defines and libraries.\n#\ncase \"$host_os\" in\nhaiku*)\n\t#\n\t# Haiku needs _BSD_SOURCE for the _IO* macros because it doesn't\n\t# use them.\n\t#\n\tCFLAGS=\"$CFLAGS -D_BSD_SOURCE\"\n\t#\n\t# Haiku has getpass in libbsd.\n\t#\n\tAC_CHECK_LIB(bsd, getpass)\n\t;;\nesac\n\nAC_CHECK_FUNC(strerror_r,\n    [\n\t#\n\t# We have strerror_r; if we define _GNU_SOURCE, is it a\n\t# POSIX-compliant strerror_r() or a GNU strerror_r()?\n\t#\n\tAC_MSG_CHECKING(whether strerror_r is GNU-style)\n\tAC_COMPILE_IFELSE(\n\t    [\n\t\tAC_LANG_SOURCE(\n#define _GNU_SOURCE\n#include <string.h>\n\n/* Define it GNU-style; that will cause an error if it's not GNU-style */\nextern char *strerror_r(int, char *, size_t);\n\nint\nmain(void)\n{\n\treturn 0;\n}\n)\n\t    ],\n\t    [\n\t\t# GNU-style\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GNU_STRERROR_R, 1,\n\t\t    [Define to 1 if you have a GNU-style `strerror_r' function.])\n\t    ],\n\t    [\n\t\tAC_MSG_RESULT(no)\n\t\tAC_DEFINE(HAVE_POSIX_STRERROR_R, 1,\n\t\t    [Define to 1 if you have a POSIX-style `strerror_r' function.])\n\t    ])\n    ],\n    [\n\t#\n\t# We don't have strerror_r; do we have _wcserror_s?\n\t#\n\tAC_CHECK_FUNCS(_wcserror_s)\n    ])\n\n#\n# Thanks, IBM, for not providing vsyslog() in AIX!\n#\nAC_CHECK_FUNCS(vsyslog)\n\n#\n# Require a proof of suitable snprintf(3), same as in tcpdump.\n#\nAC_MSG_CHECKING([whether snprintf is suitable])\nAC_RUN_IFELSE(\n    [\n        AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/types.h>\n\n#if defined(_WIN32) && !defined(_SSIZE_T_DEFINED)\n/*\n * On UN*Xes, this is a signed integer type of the same size as size_t.\n *\n * It's not defined by Visual Studio; we assume that ptrdiff_t will\n * be a type that is a signed integer type of the same size as size_t.\n */\ntypedef ptrdiff_t ssize_t;\n#endif\n\n/*\n * Avoid trying to cast negative values to unsigned types, or doing\n * shifts of signed types, in order not to have the test program fail\n * if we're building with undefined-behavior sanitizers enabled.\n */\nint main()\n{\n  char buf[100];\n  unsigned int ui = sizeof(buf);\n  int i = sizeof(buf);\n  int64_t i64 = INT64_C(0x100000000);\n  uint64_t ui64 = UINT64_C(0x100000000);\n\n  snprintf(buf, sizeof(buf), \"%zu\", (size_t)ui);\n  if (strncmp(buf, \"100\", sizeof(buf)))\n    return 1;\n\n  snprintf(buf, sizeof(buf), \"%zd\", (ssize_t)(-i));\n  if (strncmp(buf, \"-100\", sizeof(buf)))\n    return 2;\n\n  snprintf(buf, sizeof(buf), \"%\" PRId64, -i64);\n  if (strncmp(buf, \"-4294967296\", sizeof(buf)))\n    return 3;\n\n  snprintf(buf, sizeof(buf), \"0o%\" PRIo64, ui64);\n  if (strncmp(buf, \"0o40000000000\", sizeof(buf)))\n    return 4;\n\n  snprintf(buf, sizeof(buf), \"0x%\" PRIx64, ui64);\n  if (strncmp(buf, \"0x100000000\", sizeof(buf)))\n    return 5;\n\n  snprintf(buf, sizeof(buf), \"%\" PRIu64, ui64);\n  if (strncmp(buf, \"4294967296\", sizeof(buf)))\n    return 6;\n\n  return 0;\n}\n        ]])\n    ],\n    [\n        AC_MSG_RESULT(yes)\n    ],\n    [\n        AC_MSG_RESULT(no)\n        AC_MSG_ERROR(\n[The snprintf(3) implementation in this libc is not suitable,\nlibpcap would not work correctly even if it managed to compile.])\n    ],\n    [\n        AC_MSG_RESULT(not while cross-compiling)\n    ]\n)\n\nneedasprintf=no\nAC_CHECK_FUNCS(vasprintf asprintf,,\n\t[needasprintf=yes])\nif test $needasprintf = yes; then\n\tAC_LIBOBJ([asprintf])\nfi\n\nneedstrlcat=no\nAC_CHECK_FUNCS(strlcat,,\n\t[needstrlcat=yes])\nif test $needstrlcat = yes; then\n\tAC_LIBOBJ([strlcat])\nfi\n\nneedstrlcpy=no\nAC_CHECK_FUNCS(strlcpy,,\n\t[needstrlcpy=yes])\nif test $needstrlcpy = yes; then\n\tAC_LIBOBJ([strlcpy])\nfi\n\nneedstrtok_r=no\nAC_CHECK_FUNCS(strtok_r,,\n\t[needstrtok_r=yes])\nif test $needstrtok_r = yes; then\n\tAC_LIBOBJ([strtok_r])\nfi\n\n#\n# Do this before checking for ether_hostton(), as it's a\n# \"getaddrinfo()-ish function\".\n#\nAC_LBL_LIBRARY_NET\n\n#\n# Check for reentrant versions of getnetbyname_r(), as provided by\n# Linux (glibc), Solaris, and AIX (with three different APIs!).\n# If we don't find one, we just use getnetbyname(), which uses\n# thread-specific data on many platforms, but doesn't use it on\n# NetBSD or OpenBSD, and may not use it on older versions of other\n# platforms.\n#\n# Only do the check if we have a declaration of getnetbyname_r();\n# without it, we can't check which API it has.  (We assume that\n# if there's a declaration, it has a prototype, so that the API\n# can be checked.)\n#\nAC_CHECK_DECL(getnetbyname_r,\n    [\n\tAC_MSG_CHECKING([for the Linux getnetbyname_r()])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t    [[#include <netdb.h>]],\n\t    [[\n\t\tstruct netent netent_buf;\n\t\tchar buf[1024];\n\t\tstruct netent *resultp;\n\t\tint h_errnoval;\n\n\t\treturn getnetbyname_r((const char *)0, &netent_buf, buf, sizeof buf, &resultp, &h_errnoval);\n\t    ]])],\n\t    [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_LINUX_GETNETBYNAME_R, 1,\n\t\t    [define if we have the Linux getnetbyname_r()])\n\t    ],\n\t    [\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([for Solaris getnetbyname_r()])\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[#include <netdb.h>]],\n\t\t    [[\n\t\t\tstruct netent netent_buf;\n\t\t\tchar buf[1024];\n\n\t\t\treturn getnetbyname_r((const char *)0, &netent_buf, buf, (int)sizeof buf) != NULL;\n\t\t    ]])],\n\t\t    [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOLARIS_GETNETBYNAME_R, 1,\n\t\t\t    [define if we have the Solaris getnetbyname_r()])\n\t\t    ],\n\t\t    [\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tAC_MSG_CHECKING([for AIX getnetbyname_r()])\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t\t    [[#include <netdb.h>]],\n\t\t\t    [[\n\t\t\t\tstruct netent netent_buf;\n\t\t\t\tstruct netent_data net_data;\n\n\t\t\t\treturn getnetbyname_r((const char *)0, &netent_buf, &net_data);\n\t\t\t    ]])],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_AIX_GETNETBYNAME_R, 1,\n\t\t\t\t    [define if we have the AIX getnetbyname_r()])\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t    ])\n\t\t    ])\n\t    ])\n    ],,[#include <netdb.h>])\n\n#\n# Check for reentrant versions of getprotobyname_r(), as provided by\n# Linux (glibc), Solaris, and AIX (with three different APIs!).\n# If we don't find one, we just use getprotobyname(), which uses\n# thread-specific data on many platforms, but doesn't use it on\n# NetBSD or OpenBSD, and may not use it on older versions of other\n# platforms.\n#\n# Only do the check if we have a declaration of getprotobyname_r();\n# without it, we can't check which API it has.  (We assume that\n# if there's a declaration, it has a prototype, so that the API\n# can be checked.)\n#\nAC_CHECK_DECL(getprotobyname_r,\n    [\n\tAC_MSG_CHECKING([for the Linux getprotobyname_r()])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t    [[#include <netdb.h>]],\n\t    [[\n\t\tstruct protoent protoent_buf;\n\t\tchar buf[1024];\n\t\tstruct protoent *resultp;\n\n\t\treturn getprotobyname_r((const char *)0, &protoent_buf, buf, sizeof buf, &resultp);\n\t    ]])],\n\t    [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_LINUX_GETPROTOBYNAME_R, 1,\n\t\t    [define if we have the Linux getprotobyname_r()])\n\t    ],\n\t    [\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([for Solaris getprotobyname_r()])\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[#include <netdb.h>]],\n\t\t    [[\n\t\t\tstruct protoent protoent_buf;\n\t\t\tchar buf[1024];\n\n\t\t\treturn getprotobyname_r((const char *)0, &protoent_buf, buf, (int)sizeof buf) != NULL;\n\t\t    ]])],\n\t\t    [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOLARIS_GETPROTOBYNAME_R, 1,\n\t\t\t    [define if we have the Solaris getprotobyname_r()])\n\t\t    ],\n\t\t    [\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tAC_MSG_CHECKING([for AIX getprotobyname_r()])\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t\t    [[#include <netdb.h>]],\n\t\t\t    [[\n\t\t\t\tstruct protoent protoent_buf;\n\t\t\t\tstruct protoent_data proto_data;\n\n\t\t\t\treturn getprotobyname_r((const char *)0, &protoent_buf, &proto_data);\n\t\t\t    ]])],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_AIX_GETPROTOBYNAME_R, 1,\n\t\t\t\t    [define if we have the AIX getprotobyname_r()])\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t    ])\n\t\t    ])\n\t    ])\n    ],,[#include <netdb.h>])\n\n#\n# You are in a twisty little maze of UN*Xes, all different.\n# Some might not have ether_hostton().\n# Some might have it and declare it in <net/ethernet.h>.\n# Some might have it and declare it in <netinet/ether.h>\n# Some might have it and declare it in <sys/ethernet.h>.\n# Some might have it and declare it in <arpa/inet.h>.\n# Some might have it and declare it in <netinet/if_ether.h>.\n# Some might have it and not declare it in any header file.\n#\n# Before you is a C compiler.\n#\nAC_CHECK_FUNCS(ether_hostton)\nif test \"$ac_cv_func_ether_hostton\" = yes; then\n\t#\n\t# OK, we have ether_hostton().  Is it declared in <net/ethernet.h>?\n\t#\n\t# This test fails if we don't have <net/ethernet.h> or if we do\n\t# but it doesn't declare ether_hostton().\n\t#\n\tAC_CHECK_DECL(ether_hostton,\n\t    [\n\t\tAC_DEFINE(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON, 1,\n\t\t    [Define to 1 if net/ethernet.h declares `ether_hostton'])\n\t    ],,\n\t    [\n#include <net/ethernet.h>\n\t    ])\n\t#\n\t# Did that succeed?\n\t#\n\tif test \"$ac_cv_have_decl_ether_hostton\" != yes; then\n\t\t#\n\t\t# No, how about <netinet/ether.h>, as on Linux?\n\t\t#\n\t\t# This test fails if we don't have <netinet/ether.h>\n\t\t# or if we do but it doesn't declare ether_hostton().\n\t\t#\n\t\t# Unset ac_cv_have_decl_ether_hostton so we don't\n\t\t# treat the previous failure as a cached value and\n\t\t# suppress the next test.\n\t\t#\n\t\tunset ac_cv_have_decl_ether_hostton\n\t\tAC_CHECK_DECL(ether_hostton,\n\t\t    [\n\t\t\tAC_DEFINE(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON, 1,\n\t\t\t    [Define to 1 if netinet/ether.h declares `ether_hostton'])\n\t\t    ],,\n\t\t    [\n#include <netinet/ether.h>\n\t\t    ])\n\tfi\n\t#\n\t# Did that succeed?\n\t#\n\tif test \"$ac_cv_have_decl_ether_hostton\" != yes; then\n\t\t#\n\t\t# No, how about <sys/ethernet.h>, as on Solaris 10\n\t\t# and later?\n\t\t#\n\t\t# This test fails if we don't have <sys/ethernet.h>\n\t\t# or if we do but it doesn't declare ether_hostton().\n\t\t#\n\t\t# Unset ac_cv_have_decl_ether_hostton so we don't\n\t\t# treat the previous failure as a cached value and\n\t\t# suppress the next test.\n\t\t#\n\t\tunset ac_cv_have_decl_ether_hostton\n\t\tAC_CHECK_DECL(ether_hostton,\n\t\t    [\n\t\t\tAC_DEFINE(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON, 1,\n\t\t\t    [Define to 1 if sys/ethernet.h declares `ether_hostton'])\n\t\t    ],,\n\t\t    [\n#include <sys/ethernet.h>\n\t\t    ])\n\tfi\n\t#\n\t# Did that succeed?\n\t#\n\tif test \"$ac_cv_have_decl_ether_hostton\" != yes; then\n\t\t#\n\t\t# No, how about <arpa/inet.h>, as in AIX?\n\t\t#\n\t\t# This test fails if we don't have <arpa/inet.h>\n\t\t# (if we have ether_hostton(), we should have\n\t\t# networking, and if we have networking, we should\n\t\t# have <arpa/inet.h>) or if we do but it doesn't\n\t\t# declare ether_hostton().\n\t\t#\n\t\t# Unset ac_cv_have_decl_ether_hostton so we don't\n\t\t# treat the previous failure as a cached value and\n\t\t# suppress the next test.\n\t\t#\n\t\tunset ac_cv_have_decl_ether_hostton\n\t\tAC_CHECK_DECL(ether_hostton,\n\t\t    [\n\t\t\tAC_DEFINE(ARPA_INET_H_DECLARES_ETHER_HOSTTON, 1,\n\t\t\t    [Define to 1 if arpa/inet.h declares `ether_hostton'])\n\t\t    ],,\n\t\t    [\n#include <arpa/inet.h>\n\t\t    ])\n\tfi\n\t#\n\t# Did that succeed?\n\t#\n\tif test \"$ac_cv_have_decl_ether_hostton\" != yes; then\n\t\t#\n\t\t# No, how about <netinet/if_ether.h>?\n\t\t# On some platforms, it requires <net/if.h> and\n\t\t# <netinet/in.h>, and we always include it with\n\t\t# both of them, so test it with both of them.\n\t\t#\n\t\t# This test fails if we don't have <netinet/if_ether.h>\n\t\t# and the headers we include before it, or if we do but\n\t\t# <netinet/if_ether.h> doesn't declare ether_hostton().\n\t\t#\n\t\t# Unset ac_cv_have_decl_ether_hostton so we don't\n\t\t# treat the previous failure as a cached value and\n\t\t# suppress the next test.\n\t\t#\n\t\tunset ac_cv_have_decl_ether_hostton\n\t\tAC_CHECK_DECL(ether_hostton,\n\t\t    [\n\t\t\tAC_DEFINE(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON, 1,\n\t\t\t    [Define to 1 if netinet/if_ether.h declares `ether_hostton'])\n\t\t    ],,\n\t\t    [\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/if_ether.h>\n\t\t    ])\n\tfi\n\t#\n\t# After all that, is ether_hostton() declared?\n\t#\n\tif test \"$ac_cv_have_decl_ether_hostton\" = yes; then\n\t\t#\n\t\t# Yes.\n\t\t#\n\t\tAC_DEFINE(HAVE_DECL_ETHER_HOSTTON, 1,\n\t\t    [Define to 1 if you have the declaration of `ether_hostton'])\n        else\n\t\t#\n\t\t# No, we'll have to declare it ourselves.\n\t\t# Do we have \"struct ether_addr\" if we include\n\t\t# <netinet/if_ether.h>?\n\t\t#\n\t\tAC_CHECK_TYPES(struct ether_addr,,,\n\t\t    [\n\t\t\t#include <sys/types.h>\n\t\t\t#include <sys/socket.h>\n\t\t\t#include <net/if.h>\n\t\t\t#include <netinet/in.h>\n\t\t\t#include <netinet/if_ether.h>\n\t\t    ])\n\tfi\nfi\n\n#\n# For various things that might use pthreads.\n#\nAC_CHECK_HEADER(pthread.h,\n    [\n\t#\n\t# OK, we have pthread.h.  Do we have pthread_create in the\n\t# system libraries?\n\t#\n\tAC_CHECK_FUNC(pthread_create,\n\t    [\n\t\t#\n\t\t# Yes.\n\t\t#\n\t\tac_lbl_have_pthreads=\"found\"\n\t    ],\n\t    [\n\t\t#\n\t\t# No - do we have it in -lpthreads?\n\t\t#\n\t\tAC_CHECK_LIB(pthreads, pthread_create,\n\t\t    [\n\t\t\t#\n\t\t\t# Yes - add -lpthreads.\n\t\t\t#\n\t\t\tac_lbl_have_pthreads=\"found\"\n\t\t\tPTHREAD_LIBS=\"$PTHREAD_LIBS -lpthreads\"\n\t\t    ],\n\t\t    [\n\t\t\t#\n\t\t\t# No - do we have it in -lpthread?\n\t\t\t#\n\t\t\tAC_CHECK_LIB(pthread, pthread_create,\n\t\t\t    [\n\t\t\t\t#\n\t\t\t\t# Yes - add -lpthread.\n\t\t\t\t#\n                                ac_lbl_have_pthreads=\"found\"\n\t\t\t\tPTHREAD_LIBS=\"$PTHREAD_LIBS -lpthread\"\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\t#\n\t\t\t\t# No.\n\t\t\t\t#\n\t\t\t\tac_lbl_have_pthreads=\"not found\"\n\t\t\t    ])\n\t\t    ])\n\t    ])\n    ],\n    [\n\t#\n\t# We didn't find pthread.h.\n\t#\n\tac_lbl_have_pthreads=\"not found\"\n    ]\n)\n\nAC_MSG_CHECKING([whether to enable the instrument functions code])\nAC_ARG_ENABLE([instrument-functions],\n   [AS_HELP_STRING([--enable-instrument-functions],\n     [enable instrument functions code [default=no]])],\n   [],\n   [enableval=no])\ncase \"$enableval\" in\nyes)\tAC_MSG_RESULT(yes)\n\tAC_DEFINE(ENABLE_INSTRUMENT_FUNCTIONS, 1,\n\t    [define if you want to build the instrument functions code])\n\t# Add '-finstrument-functions' instrumentation option to generate\n\t# instrumentation calls for entry and exit to functions.\n\t# Use '--enable-instrument-functions' also with tcpdump (or tcpslice)\n\t# to see the output. See also https://www.tcpdump.org/faq.html#q17.\n\tCFLAGS=\"$CFLAGS -O0 -ggdb -finstrument-functions\"\n\t;;\n*)\tAC_MSG_RESULT(no)\n\t;;\nesac\n\ndnl to pacify those who hate protochain insn\nAC_MSG_CHECKING(if --disable-protochain option is specified)\nAC_ARG_ENABLE(protochain,\nAS_HELP_STRING([--disable-protochain],[disable \\\"protochain\\\" insn]))\ncase \"x$enable_protochain\" in\nxyes)\tenable_protochain=enabled\t;;\nxno)\tenable_protochain=disabled\t;;\nx)\tenable_protochain=enabled\t;;\nesac\n\nif test \"$enable_protochain\" = \"disabled\"; then\n\tAC_DEFINE(NO_PROTOCHAIN,1,[do not use protochain])\nfi\nAC_MSG_RESULT(${enable_protochain})\n\n#\n# valgrindtest directly uses the native capture mechanism, but\n# only tests with BPF and PF_PACKET sockets; only enable it if\n# we have BPF or PF_PACKET sockets.\n#\nVALGRINDTEST_SRC=\n\nAC_ARG_WITH(pcap,\nAS_HELP_STRING([--with-pcap=TYPE],[use packet capture TYPE]))\nif test ! -z \"$with_pcap\" ; then\n\tV_PCAP=\"$withval\"\nelse\n\t#\n\t# Check for a bunch of headers for various packet\n\t# capture mechanisms.\n\t#\n\tAC_CHECK_HEADERS(net/bpf.h)\n\tif test \"$ac_cv_header_net_bpf_h\" = yes; then\n\t\t#\n\t\t# Does it define BIOCSETIF?\n\t\t# I.e., is it a header for an LBL/BSD-style capture\n\t\t# mechanism, or is it just a header for a BPF filter\n\t\t# engine?  Some versions of Arch Linux, for example,\n\t\t# have a net/bpf.h that doesn't define BIOCSETIF;\n\t\t# as it's a Linux, it should use packet sockets,\n\t\t# instead.\n\t\t#\n\t\t# We need:\n\t\t#\n\t\t#  sys/types.h, because FreeBSD 10's net/bpf.h\n\t\t#  requires that various BSD-style integer types\n\t\t#  be defined;\n\t\t#\n\t\t#  sys/time.h, because AIX 5.2 and 5.3's net/bpf.h\n\t\t#  doesn't include it but does use struct timeval\n\t\t#  in ioctl definitions;\n\t\t#\n\t\t#  sys/ioctl.h and, if we have it, sys/ioccom.h,\n\t\t#  because net/bpf.h defines ioctls;\n\t\t#\n\t\t#  net/if.h, because it defines some structures\n\t\t#  used in ioctls defined by net/bpf.h;\n\t\t#\n\t\t#  sys/socket.h, because OpenBSD 5.9's net/bpf.h\n\t\t#  defines some structure fields as being\n\t\t#  struct sockaddrs;\n\t\t#\n\t\t# and net/bpf.h doesn't necessarily include all\n\t\t# of those headers itself.\n\t\t#\n\t\tAC_MSG_CHECKING(if net/bpf.h defines BIOCSETIF)\n\t\tAC_CACHE_VAL(ac_cv_lbl_bpf_h_defines_biocsetif,\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_IOCCOM_H\n#include <sys/ioccom.h>\n#endif\n#include <net/bpf.h>\n#include <net/if.h>\n]],\n\t\t\t[[u_int i = BIOCSETIF;]])],\n\t\t\t[ac_cv_lbl_bpf_h_defines_biocsetif=yes],\n\t\t\t[ac_cv_lbl_bpf_h_defines_biocsetif=no]))\n\t\tAC_MSG_RESULT($ac_cv_lbl_bpf_h_defines_biocsetif)\n\tfi\n\tAC_CHECK_HEADERS(linux/socket.h sys/dlpi.h)\n\tAC_CHECK_HEADERS(config/HaikuConfig.h)\n\tAC_CHECK_HEADERS(hurd.h)\n\n\tif test \"$ac_cv_lbl_bpf_h_defines_biocsetif\" = yes; then\n\t\t#\n\t\t# BPF.\n\t\t# Check this before DLPI, so that we pick BPF on\n\t\t# Solaris 11 and later.\n\t\t#\n\t\tV_PCAP=bpf\n\n\t\t#\n\t\t# We have BPF, so build valgrindtest with \"make test\"\n\t\t# on macOS and FreeBSD (add your OS once there's a\n\t\t# valgrind for it).\n\t\t#\n\t\tcase \"$host_os\" in\n\n\t\tfreebsd*|darwin*|linux*)\n\t\t\tVALGRINDTEST_SRC=valgrindtest.c\n\t\t\t;;\n\t\tesac\n\telif test \"$ac_cv_header_linux_socket_h\" = yes; then\n\t\t#\n\t\t# No prizes for guessing this one.\n\t\t#\n\t\tV_PCAP=linux\n\t\tVALGRINDTEST_SRC=valgrindtest.c\n\telif test \"$ac_cv_header_sys_dlpi_h\" = yes; then\n\t\t#\n\t\t# DLPI on pre-Solaris 11 SunOS 5, HP-UX, possibly others.\n\t\t#\n\t\tV_PCAP=dlpi\n\telif test \"$ac_cv_header_config_HaikuConfig_h\" = yes; then\n\t\t#\n\t\t# Haiku.\n\t\t#\n\t\tV_PCAP=haiku\n\telif test \"$ac_cv_header_hurd_h\" = yes; then\n\t\t#\n\t\t# Hurd.\n\t\t#\n\t\tV_PCAP=hurd\n\telse\n\t\t#\n\t\t# We don't have any capture type we know about.\n\t\t# Report an error, and tell the user to configure with\n\t\t# --with-pcap=null if they want a libpcap that can't\n\t\t# capture but that can read capture files.  That way,\n\t\t# nobody gets surprised by getting a no-capture\n\t\t# libpcap without asking for that.\n\t\t#\n\t\tAC_MSG_ERROR([No supported packet capture interface was found.\n See the INSTALL.md file for information on packet capture support in\n various operating systems.\n If you want a libpcap that cannot capture packets but that can read\n pcap and pcapng files, run configure with --with-pcap=null.])\n\tfi\nfi\nAC_MSG_CHECKING(packet capture type)\nAC_MSG_RESULT($V_PCAP)\nAC_SUBST(VALGRINDTEST_SRC)\n\n#\n# Do we have pkg-config?\n#\nPKG_PROG_PKG_CONFIG\n\n#\n# Do we have the brew command from Homebrew?\n#\nAC_PATH_PROG([BREW], [brew])\n\n#\n# Solaris pkg-config is annoying.  For at least one package (D-Bus, I'm\n# looking at *you*!), there are separate include files for 32-bit and\n# 64-bit builds (I guess using \"unsigned long long\" as a 64-bit integer\n# type on a 64-bit build is like crossing the beams or something), and\n# there are two separate .pc files, so if we're doing a 32-bit build we\n# should make sure we look in /usr/lib/pkgconfig for .pc files and if\n# we're doing a 64-bit build we should make sure we look in\n# /usr/lib/amd64/pkgconfig for .pc files.\n#\ncase \"$host_os\" in\n\nsolaris*)\n\tif test \"$ac_cv_sizeof_void_p\" -eq 8; then\n\t\t#\n\t\t# 64-bit build.  If the path is empty, set it to\n                # /usr/lib/amd64/pkgconfig; otherwise, if\n                # /usr/lib/pkgconfig appears in the path, prepend\n\t\t# /usr/lib/amd64/pkgconfig to it; otherwise, put\n\t\t# /usr/lib/amd64/pkgconfig at the end.\n\t\t#\n\t\tif test -z \"$PKG_CONFIG_PATH\"; then\n\t\t\t#\n\t\t\t# Not set, or empty.  Set it to\n\t\t\t# /usr/lib/amd64/pkgconfig.\n\t\t\t#\n\t\t\tPKG_CONFIG_PATH=/usr/lib/amd64/pkgconfig\n\t\telif test ! -z `echo \"$PKG_CONFIG_PATH\" | grep \"/usr/lib/pkgconfig\"`; then\n\t\t\t#\n\t\t\t# It contains /usr/lib/pkgconfig.  Prepend\n\t\t\t# /usr/lib/amd64/pkgconfig to /usr/lib/pkgconfig.\n\t\t\t#\n\t\t\tPKG_CONFIG_PATH=`echo \"$PKG_CONFIG_PATH\" | sed \"s;/usr/lib/pkgconfig;/usr/lib/amd64/pkgconfig:/usr/lib/pkgconfig;\"`\n\t\telse\n\t\t\t#\n\t\t\t# Not empty, but doesn't contain /usr/lib/pkgconfig.\n\t\t\t# Append /usr/lib/amd64/pkgconfig to it.\n\t\t\t#\n\t\t\tPKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/lib/amd64/pkgconfig\"\n\t\tfi\n\t\texport PKG_CONFIG_PATH\n\telif test \"$ac_cv_sizeof_void_p\" -eq 4; then\n\t\t#\n\t\t# 32-bit build.  If /usr/amd64/lib/pkgconfig appears\n\t\t# in the path, prepend /usr/lib/pkgconfig to it.\n\t\t#\n\t\tif test ! -z `echo \"$PKG_CONFIG_PATH\" | grep \"/usr/lib/amd64/pkgconfig\"`; then\n\t\t\t#\n\t\t\t# It contains /usr/lib/amd64/pkgconfig.  Prepend\n\t\t\t# /usr/lib/pkgconfig to /usr/lib/amd64/pkgconfig.\n\t\t\t#\n\t\t\tPKG_CONFIG_PATH=`echo \"$PKG_CONFIG_PATH\" | sed \"s;/usr/lib/amd64/pkgconfig;/usr/lib/pkgconfig:/usr/lib/amd64/pkgconfig;\"`\n\t\t\texport PKG_CONFIG_PATH\n\t\tfi\n\tfi\nesac\n\n#\n# Handle each capture type.\n#\ncase \"$V_PCAP\" in\ndlpi)\n\t#\n\t# Checks for some header files.\n\t#\n\tAC_CHECK_HEADERS(sys/bufmod.h sys/dlpi_ext.h)\n\n\t#\n\t# Checks to see if Solaris has the public libdlpi(3LIB) library.\n\t# Note: The existence of /usr/include/libdlpi.h does not mean it is the\n\t# public libdlpi(3LIB) version. Before libdlpi was made public, a\n\t# private version also existed, which did not have the same APIs.\n\t# Due to a gcc bug, the default search path for 32-bit libraries does\n\t# not include /lib, we add it explicitly here.\n\t# [http://bugs.opensolaris.org/view_bug.do?bug_id=6619485].\n\t# Also, due to the bug above applications that link to libpcap with\n\t# libdlpi will have to add \"-L/lib\" option to \"configure\".\n\t#\n\tsave_LDFLAGS=\"$LDFLAGS\"\n\tLDFLAGS=\"$LIBS -L/lib\"\n\tAC_CHECK_LIB(dlpi, dlpi_walk,\n\t\t[\n\t\t\tLIBS=\"-ldlpi $LIBS\"\n\t\t\tLIBS_STATIC=\"-ldlpi $LIBS_STATIC\"\n\t\t\tLIBS_PRIVATE=\"-ldlpi $LIBS_PRIVATE\"\n\t\t\tV_PCAP=libdlpi\n\n\t\t\t#\n\t\t\t# Capture module plus common code needed for\n\t\t\t# common functions used by pcap-[dlpi,libdlpi].c\n\t\t\t#\n\t\t\tPLATFORM_C_SRC=\"pcap-libdlpi.c dlpisubs.c\"\n\t\t\tAC_DEFINE(HAVE_LIBDLPI,1,[if libdlpi exists])\n\t\t],\n\t\t[\n\t\t\tV_PCAP=dlpi\n\n\t\t\t#\n\t\t\t# Capture module plus common code needed for\n\t\t\t# common functions used by pcap-[dlpi,libdlpi].c\n\t\t\t#\n\t\t\tPLATFORM_C_SRC=\"pcap-dlpi.c dlpisubs.c\"\n\t\t])\n\tLDFLAGS=\"$save_LDFLAGS\"\n\n\t#\n\t# Checks whether <sys/dlpi.h> is usable, to catch weird SCO\n\t# versions of DLPI.\n\t#\n\tAC_MSG_CHECKING(whether <sys/dlpi.h> is usable)\n\tAC_CACHE_VAL(ac_cv_sys_dlpi_usable,\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <sys/time.h>\n\t\t\t#include <sys/dlpi.h>\n\t\t    ]],\n\t\t    [[int i = DL_PROMISC_PHYS;]])],\n\t\t    [ac_cv_sys_dlpi_usable=yes],\n\t\t    [ac_cv_sys_dlpi_usable=no]))\n\tAC_MSG_RESULT($ac_cv_sys_dlpi_usable)\n\tif test $ac_cv_sys_dlpi_usable = no ; then\n\t\tAC_MSG_ERROR(<sys/dlpi.h> is not usable on this system; it probably has a non-standard DLPI)\n\tfi\n\n\t#\n\t# Check to see if Solaris has the dl_passive_req_t struct defined\n\t# in <sys/dlpi.h>.\n\t# This check is for DLPI support for passive modes.\n\t# See dlpi(7P) for more details.\n\t#\n\tAC_CHECK_TYPES(dl_passive_req_t,,,\n\t    [\n\t\t#include <sys/types.h>\n\t\t#include <sys/dlpi.h>\n\t    ])\n\t;;\n\nhaiku)\n\t#\n\t# Capture module\n\t#\n\tPLATFORM_C_SRC=\"pcap-haiku.c\"\n\t;;\n\nlinux)\n\t#\n\t# Capture module\n\t#\n\tPLATFORM_C_SRC=\"pcap-linux.c\"\n\n\t#\n\t# Do we have libnl?\n\t# We only want version 3.  Version 2 was, apparently,\n\t# short-lived, and version 1 is source and binary\n\t# incompatible with version 3, and it appears that,\n\t# these days, everybody's using version 3.  We're\n\t# not supporting older versions of the Linux kernel;\n\t# let's drop support for older versions of libnl, too.\n\t#\n\tAC_ARG_WITH(libnl,\n\tAS_HELP_STRING([--without-libnl],[disable libnl support @<:@default=yes, on Linux, if present@:>@]),\n\t\twith_libnl=$withval,with_libnl=if_available)\n\n\tif test x$with_libnl != xno ; then\n\t\t#\n\t\t# Check for libnl-genl-3.0 with pkg-config.\n\t\t#\n\t\tPKG_CHECK_MODULE(LIBNL, libnl-genl-3.0,\n\t\t    [\n\t\t\tpkg_config_found_libnl=yes\n\t\t\tV_INCLS=\"$V_INCLS $LIBNL_CFLAGS\"\n\t\t\tADDITIONAL_LIBS=\"$LIBNL_LIBS $ADDITIONAL_LIBS\"\n\t\t\tADDITIONAL_LIBS_STATIC=\"$LIBNL_LIBS_STATIC $ADDITIONAL_LIBS_STATIC\"\n\t\t\tREQUIRES_PRIVATE=\"libnl-genl-3.0 $REQUIRES_PRIVATE\"\n\t\t\tAC_DEFINE(HAVE_LIBNL,1,[if libnl exists])\n\t\t    ])\n\n\t\tif test x$pkg_config_found_libnl != xyes; then\n\t\t\t#\n\t\t\t# Check for libnl-tiny with pkg-config.\n\t\t\t#\n\t\t\tPKG_CHECK_MODULE(LIBNL, libnl-tiny,\n\t\t\t    [\n\t\t\t\tpkg_config_found_libnl=yes\n\t\t\t\tV_INCLS=\"$V_INCLS $LIBNL_CFLAGS\"\n\t\t\t\tADDITIONAL_LIBS=\"$LIBNL_LIBS $ADDITIONAL_LIBS\"\n\t\t\t\tADDITIONAL_LIBS_STATIC=\"$LIBNL_LIBS_STATIC $ADDITIONAL_LIBS_STATIC\"\n\t\t\t\tREQUIRES_PRIVATE=\"libnl-tiny $REQUIRES_PRIVATE\"\n\t\t\t\tAC_DEFINE(HAVE_LIBNL,1,[if libnl exists])\n\t\t\t    ])\n\t\tfi\n\n\t\tif test x$pkg_config_found_libnl != xyes; then\n\t\t\t#\n\t\t\t# OK, either we don't have pkg-config or there\n\t\t\t# wasn't a .pc file for it; Check for it directly.\n\t\t\t#\n\t\t\tcase \"$with_libnl\" in\n\n\t\t\tyes|if_available)\n\t\t\t\tincdir=-I/usr/include/libnl3\n\t\t\t\tlibnldir=\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\tif test -d $withval; then\n\t\t\t\t\tlibnldir=-L${withval}/lib\n\t\t\t\t\tincdir=-I${withval}/include\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\tesac\n\n\t\t\tAC_CHECK_LIB(nl-3, nl_socket_alloc,\n\t\t\t[\n\t\t\t\t#\n\t\t\t\t# Yes, we have libnl 3.x.\n\t\t\t\t#\n\t\t\t\tADDITIONAL_LIBS=\"${libnldir} -lnl-genl-3 -lnl-3 $ADDITIONAL_LIBS\"\n\t\t\t\tADDITIONAL_LIBS_STATIC=\"${libnldir} -lnl-genl-3 -lnl-3 $ADDITIONAL_LIBS_STATIC\"\n\t\t\t\tLIBS_PRIVATE=\"${libnldir} -lnl-genl-3 -lnl-3 $LIBS_PRIVATE\"\n\t\t\t\tAC_DEFINE(HAVE_LIBNL,1,[if libnl exists])\n\t\t\t\tV_INCLS=\"$V_INCLS ${incdir}\"\n\t\t\t],[\n\t\t\t\t#\n\t\t\t\t# No, we don't have libnl at all.\n\t\t\t\t# Fail if the user explicitly requested\n\t\t\t\t# it.\n\t\t\t\t#\n\t\t\t\tif test x$with_libnl = xyes ; then\n\t\t\t\t\tAC_MSG_ERROR([libnl support requested but libnl not found])\n\t\t\t\tfi\n\t\t\t], ${incdir} ${libnldir} -lnl-genl-3 -lnl-3 )\n\t\tfi\n\tfi\n\n\t#\n\t# Check to see if the tpacket_auxdata struct has a tp_vlan_tci member.\n\t#\n\t# NOTE: any failure means we conclude that it doesn't have that\n\t# member, so if we don't have tpacket_auxdata, we conclude it\n\t# doesn't have that member (which is OK, as either we won't be\n\t# using code that would use that member, or we wouldn't compile\n\t# in any case).\n\tAC_CHECK_MEMBERS([struct tpacket_auxdata.tp_vlan_tci],,,\n\t    [\n\t\t#include <sys/types.h>\n\t\t#include <linux/if_packet.h>\n\t    ])\n\t;;\n\nbpf)\n\t#\n\t# Capture module\n\t#\n\tPLATFORM_C_SRC=\"pcap-bpf.c\"\n\n\t#\n\t# Check whether we have the *BSD-style ioctls.\n\t#\n\tAC_CHECK_HEADERS(net/if_media.h)\n\n\t#\n\t# Check whether we have struct BPF_TIMEVAL.\n\t#\n\tAC_CHECK_TYPES(struct BPF_TIMEVAL,,,\n\t    [\n\t\t#include <sys/types.h>\n\t\t#include <sys/ioctl.h>\n\t\t#ifdef HAVE_SYS_IOCCOM_H\n\t\t#include <sys/ioccom.h>\n\t\t#endif\n\t\t#include <net/bpf.h>\n\t    ])\n\n\t#\n\t# Check whether there's a net/ipnet.h header and,\n\t# if so, whether it defines IPNET_ANY_LINK - if so,\n\t# we assume we have the \"any\" device (that's a\n\t# Solaris header, and later versions of Solaris\n\t# have an \"any\" device).\n\t#\n\t# Attempting to include it at compile time could\n\t# be a pain, as it's a kernel header.\n\t#\n\tAC_MSG_CHECKING(whether the Solaris \"any\" device is supported)\n\tif test -e /usr/include/inet/ipnet.h &&\n\t    grep -q IPNET_ANY_LINK /usr/include/inet/ipnet.h; then\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOLARIS_ANY_DEVICE, 1, [target host supports Solaris \"any\" device])\n\telse\n\t\tAC_MSG_RESULT(no)\n\tfi\n\t;;\n\nhurd)\n\tPLATFORM_C_SRC=\"pcap-hurd.c\"\n\tLIBS=\"$LIBS -lrt\"\n\t;;\n\ndag)\n\t#\n\t# --with-pcap=dag is the only way to get here, and it means\n\t# \"DAG support but nothing else\"\n\t#\n\tV_DEFS=\"$V_DEFS -DDAG_ONLY\"\n\tPLATFORM_C_SRC=\"pcap-dag.c\"\n\txxx_only=yes\n\t;;\n\ndpdk)\n\t#\n\t# --with-pcap=dpdk is the only way to get here, and it means\n\t# \"DPDK support but nothing else\"\n\t#\n\tV_DEFS=\"$V_DEFS -DDPDK_ONLY\"\n\tPLATFORM_C_SRC=\"pcap-dpdk.c\"\n\txxx_only=yes\n\t;;\n\nsnf)\n\t#\n\t# --with-pcap=snf is the only way to get here, and it means\n\t# \"SNF support but nothing else\"\n\t#\n\tV_DEFS=\"$V_DEFS -DSNF_ONLY\"\n\tPLATFORM_C_SRC=\"pcap-snf.c\"\n\txxx_only=yes\n\t;;\n\nnull)\n\t#\n\t# Capture module\n\t#\n\tPLATFORM_C_SRC=\"pcap-null.c\"\n\t;;\n\n*)\n\tAC_MSG_ERROR($V_PCAP is not a valid pcap type)\n\t;;\nesac\n\ndnl\ndnl Now figure out how we get a list of interfaces and addresses,\ndnl if we support capturing.  Don't bother if we don't support\ndnl capturing.\ndnl\nif test \"$V_PCAP\" != null\nthen\n\tAC_CHECK_FUNC(getifaddrs,[\n\t\t#\n\t\t# We have \"getifaddrs()\"; make sure we have <ifaddrs.h>\n\t\t# as well, just in case some platform is really weird.\n\t\t#\n\t\tAC_CHECK_HEADER(ifaddrs.h,[\n\t\t    #\n\t\t    # We have the header, so we use \"getifaddrs()\" to\n\t\t    # get the list of interfaces.\n\t\t    #\n\t\t    PLATFORM_C_SRC=\"$PLATFORM_C_SRC fad-getad.c\"\n\t\t],[\n\t\t    #\n\t\t    # We don't have the header - give up.\n\t\t    # XXX - we could also fall back on some other\n\t\t    # mechanism, but, for now, this'll catch this\n\t\t    # problem so that we can at least try to figure\n\t\t    # out something to do on systems with \"getifaddrs()\"\n\t\t    # but without \"ifaddrs.h\", if there is something\n\t\t    # we can do on those systems.\n\t\t    #\n\t\t    AC_MSG_ERROR([Your system has getifaddrs() but doesn't have a usable <ifaddrs.h>.])\n\t\t])\n\t],[\n\t\t#\n\t\t# Well, we don't have \"getifaddrs()\", at least not with the\n\t\t# libraries with which we've decided we need to link\n\t\t# libpcap with, so we have to use some other mechanism.\n\t\t#\n\t\t# Note that this may happen on Solaris, which has\n\t\t# getifaddrs(), but in -lsocket, not in -lxnet, so we\n\t\t# won't find it if we link with -lxnet, which we want\n\t\t# to do for other reasons.\n\t\t#\n\t\t# For now, we use either the SIOCGIFCONF ioctl or the\n\t\t# SIOCGLIFCONF ioctl, preferring the latter if we have\n\t\t# it; the latter is a Solarisism that first appeared\n\t\t# in Solaris 8.  (Solaris's getifaddrs() appears to\n\t\t# be built atop SIOCGLIFCONF; using it directly\n\t\t# avoids a not-all-that-useful middleman.)\n\t\t#\n\t\tAC_MSG_CHECKING(whether we have SIOCGLIFCONF)\n\t\tAC_CACHE_VAL(ac_cv_lbl_have_siocglifconf,\n\t\t    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n\t\t\t[[#include <sys/param.h>\n\t\t\t#include <sys/file.h>\n\t\t\t#include <sys/ioctl.h>\n\t\t\t#include <sys/socket.h>\n\t\t\t#include <sys/sockio.h>]],\n\t\t\t[[ioctl(0, SIOCGLIFCONF, (char *)0);]])],\n\t\t\t[ac_cv_lbl_have_siocglifconf=yes],\n\t\t\t[ac_cv_lbl_have_siocglifconf=no]))\n\t\tAC_MSG_RESULT($ac_cv_lbl_have_siocglifconf)\n\t\tif test $ac_cv_lbl_have_siocglifconf = yes ; then\n\t\t\tPLATFORM_C_SRC=\"$PLATFORM_C_SRC fad-glifc.c\"\n\t\telse\n\t\t\tPLATFORM_C_SRC=\"$PLATFORM_C_SRC fad-gifc.c\"\n\t\tfi\n\t])\nfi\n\ndnl check for hardware timestamp support\ncase \"$host_os\" in\nlinux*)\n\tAC_CHECK_HEADERS([linux/net_tstamp.h])\n\t;;\n*)\n\tAC_MSG_NOTICE(no hardware timestamp support implemented for $host_os)\n\t;;\nesac\n\n#\n# Check for socklen_t.\n#\nAC_CHECK_TYPES(socklen_t,,,\n    [\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n    ])\n\nAC_ARG_ENABLE(ipv6,\nAS_HELP_STRING([--enable-ipv6],[build IPv6-capable version @<:@default=yes@:>@]),\n    [],\n    [enable_ipv6=yes])\nif test \"$enable_ipv6\" != \"no\"; then\n\t#\n\t# We've already made sure we have getaddrinfo above in\n\t# AC_LBL_LIBRARY_NET.\n\t#\n\tAC_DEFINE(INET6,1,[IPv6])\nfi\n\n# Check for Endace DAG card support.\nAC_ARG_WITH([dag],\nAS_HELP_STRING([--with-dag@<:@=DIR@:>@],[include Endace DAG support (located in directory DIR, if supplied).  @<:@default=yes, if present@:>@]),\n[\n\tif test \"$withval\" = no\n\tthen\n\t\t# User doesn't want DAG support.\n\t\twant_dag=no\n\telif test \"$withval\" = yes\n\tthen\n\t\t# User wants DAG support but hasn't specified a directory.\n\t\twant_dag=yes\n\telse\n\t\t# User wants DAG support and has specified a directory, so use the provided value.\n\t\twant_dag=yes\n\t\tdag_root=$withval\n\tfi\n],[\n\tif test \"$V_PCAP\" = dag; then\n\t\t# User requested DAG-only libpcap, so we'd better have\n\t\t# the DAG API.\n\t\twant_dag=yes\n\telif test \"$xxx_only\" = yes; then\n\t\t# User requested something-else-only pcap, so they don't\n\t\t# want DAG support.\n\t\twant_dag=no\n\telse\n\t\t#\n\t\t# Use DAG API if present, otherwise don't\n\t\t#\n\t\twant_dag=ifpresent\n\tfi\n])\n\nAC_ARG_WITH([dag-includes],\nAS_HELP_STRING([--with-dag-includes=IDIR],[Endace DAG include directory, if not DIR/include]),\n[\n\t# User wants DAG support and has specified a header directory, so use the provided value.\n\twant_dag=yes\n\tdag_include_dir=$withval\n],[])\n\nAC_ARG_WITH([dag-libraries],\nAS_HELP_STRING([--with-dag-libraries=LDIR],[Endace DAG library directory, if not DIR/lib]),\n[\n\t# User wants DAG support and has specified a library directory, so use the provided value.\n\twant_dag=yes\n\tdag_lib_dir=$withval\n],[])\n\nif test \"$want_dag\" != no; then\n\n\t# If necessary, set default paths for DAG API headers and libraries.\n\tif test -z \"$dag_root\"; then\n\t\tdag_root=/usr\n\tfi\n\n\tif test -z \"$dag_include_dir\"; then\n\t\tdag_include_dir=\"$dag_root/include\"\n\tfi\n\n\tif test -z \"$dag_lib_dir\"; then\n\t\tdag_lib_dir=\"$dag_root/lib\"\n\t\t#\n\t\t# Handle multiarch systems.\n\t\t#\n\t\tif test -d \"$dag_lib_dir/$host\"\n\t\tthen\n\t\t\tdag_lib_dir=\"$dag_lib_dir/$host\"\n\t\tfi\n\tfi\n\n\tAC_LBL_SAVE_CHECK_STATE\n\tCFLAGS=\"$CFLAGS -I$dag_include_dir\"\n\tAC_CHECK_HEADERS([dagapi.h])\n\tAC_LBL_RESTORE_CHECK_STATE\n\n\tif test \"$ac_cv_header_dagapi_h\" = yes; then\n\n\t\tV_INCLS=\"$V_INCLS -I$dag_include_dir\"\n\n\t\tif test $V_PCAP != dag ; then\n\t\t\t MODULE_C_SRC=\"$MODULE_C_SRC pcap-dag.c\"\n\t\tfi\n\n\t\t# Check for various DAG API functions.\n\t\t# Don't need to save and restore LIBS to prevent -ldag being\n\t\t# included if there's a found-action (arg 3).\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tLDFLAGS=\"-L$dag_lib_dir\"\n\t\tAC_CHECK_LIB([dag], [dag_attach_stream64],\n\t\t    [\n\t\t\t#\n\t\t\t# We assume that if we have libdag we have\n\t\t\t# libdagconf, as they're installed at the\n\t\t\t# same time from the same package.\n\t\t\t#\n\t\t\tADDITIONAL_LIBS=\"-L$dag_lib_dir $ADDITIONAL_LIBS -ldag -ldagconf\"\n\t\t\tADDITIONAL_LIBS_STATIC=\"-L$dag_lib_dir $ADDITIONAL_LIBS_STATIC -ldag -ldagconf\"\n\t\t\tLIBS_PRIVATE=\"-L$dag_lib_dir $LIBS_PRIVATE -ldag -ldagconf\"\n\t\t    ],\n\t\t    [AC_MSG_ERROR(DAG library lacks 64-bit streams support)])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\n\t\t#\n\t\t# We assume that if we have libdag we have libdagconf,\n\t\t# as they're installed at the same time from the same\n\t\t# package.\n\t\t#\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tLIBS=\"$LIBS -ldag -ldagconf\"\n\t\tLDFLAGS=\"$LDFLAGS -L$dag_lib_dir\"\n\t\tAC_CHECK_LIB([vdag],[vdag_set_device_info], [ac_dag_have_vdag=\"1\"], [ac_dag_have_vdag=\"0\"])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\t\tif test \"$ac_dag_have_vdag\" = 1; then\n\t\t\tAC_DEFINE(HAVE_DAG_VDAG, 1, [define if you have vdag_set_device_info()])\n\t\t\tif test \"$ac_lbl_have_pthreads\" != \"found\"; then\n\t\t\t\tAC_MSG_ERROR([DAG requires pthreads, but we didn't find them])\n\t\t\tfi\n\t\t\tADDITIONAL_LIBS=\"$ADDITIONAL_LIBS $PTHREAD_LIBS\"\n\t\t\tADDITIONAL_LIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC $PTHREAD_LIBS\"\n\t\t\tLIBS_PRIVATE=\"$LIBS_PRIVATE $PTHREAD_LIBS\"\n\t\tfi\n\n\t\tAC_MSG_NOTICE([using Endace DAG API headers from $dag_include_dir])\n\t\tAC_MSG_NOTICE([using Endace DAG API libraries from $dag_lib_dir])\n\t\tAC_DEFINE(HAVE_DAG_API, 1, [define if you have the DAG API])\n\n\t\tAC_MSG_CHECKING([whether to enable Endace DAG transmit support (EXPERIMENTAL)])\n\t\tAC_ARG_ENABLE(dag-tx,\n\t\t\tAS_HELP_STRING([--enable-dag-tx],\n\t\t\t\t[enable Endace DAG transmit support (EXPERIMENTAL) @<:@default=no@:>@]\n\t\t\t)\n\t\t)\n\t\tif test \"$enable_dag_tx\" = \"yes\"; then\n\t\t\tAC_DEFINE(ENABLE_DAG_TX, 1, [Define to 1 if DAG transmit support is enabled])\n\t\tfi\n\t\tAC_MSG_RESULT(${enable_dag_tx-no})\n\telse\n\t\tif test \"$V_PCAP\" = dag; then\n\t\t\t# User requested \"dag\" capture type but we couldn't\n\t\t\t# find the DAG API support.\n\t\t\tAC_MSG_ERROR([DAG support requested with --with-pcap=dag, but the DAG headers weren't found at $dag_include_dir: make sure the DAG support is installed, specify a different path or paths if necessary, or don't request DAG support])\n\t\tfi\n\n\t\tif test \"$want_dag\" = yes; then\n\t\t\t# User wanted DAG support but we couldn't find it.\n\t\t\tAC_MSG_ERROR([DAG support requested with --with-dag, but the DAG headers weren't found at $dag_include_dir: make sure the DAG support is installed, specify a different path or paths if necessary, or don't request DAG support])\n\t\tfi\n\tfi\nfi\n\n# Check for Myricom SNF support.\nAC_ARG_WITH([snf],\nAS_HELP_STRING([--with-snf@<:@=DIR@:>@],[include Myricom SNF support (located in directory DIR, if supplied).  @<:@default=yes, if present@:>@]),\n[\n\tif test \"$withval\" = no\n\tthen\n\t\t# User explicitly doesn't want SNF\n\t\twant_snf=no\n\telif test \"$withval\" = yes\n\tthen\n\t\t# User wants SNF support but hasn't specified a directory.\n\t\twant_snf=yes\n\telse\n\t\t# User wants SNF support with a specified directory.\n\t\twant_snf=yes\n\t\tsnf_root=$withval\n\tfi\n],[\n\tif test \"$V_PCAP\" = snf; then\n\t\t# User requested Sniffer-only libpcap, so we'd better have\n\t\t# the Sniffer API.\n\t\twant_snf=yes\n\telif test \"$xxx_only\" = yes; then\n\t\t# User requested something-else-only pcap, so they don't\n\t\t# want SNF support.\n\t\twant_snf=no\n\telse\n\t\t#\n\t\t# Use Sniffer API if present, otherwise don't\n\t\t#\n\t\twant_snf=ifpresent\n\tfi\n])\n\nAC_ARG_WITH([snf-includes],\nAS_HELP_STRING([--with-snf-includes=IDIR],[Myricom SNF include directory, if not DIR/include]),\n[\n\t# User wants SNF with specific header directory\n\twant_snf=yes\n\tsnf_include_dir=$withval\n],[])\n\nAC_ARG_WITH([snf-libraries],\nAS_HELP_STRING([--with-snf-libraries=LDIR],[Myricom SNF library directory, if not DIR/lib]),\n[\n\t# User wants SNF with specific lib directory\n\twant_snf=yes\n\tsnf_lib_dir=$withval\n],[])\n\nif test \"$want_snf\" != no; then\n\t# If necessary, set default paths for Sniffer headers and libraries.\n\tif test -z \"$snf_root\"; then\n\t\tsnf_root=/opt/snf\n\tfi\n\n\tif test -z \"$snf_include_dir\"; then\n\t\tsnf_include_dir=\"$snf_root/include\"\n\tfi\n\n\tif test -z \"$snf_lib_dir\"; then\n\t\tsnf_lib_dir=\"$snf_root/lib\"\n\t\t#\n\t\t# Handle multiarch systems.\n\t\t#\n\t\tif test -d \"$snf_lib_dir/$host\"\n\t\tthen\n\t\t\tsnf_lib_dir=\"$snf_lib_dir/$host\"\n\t\tfi\n\tfi\n\n\tAC_LBL_SAVE_CHECK_STATE\n\tCFLAGS=\"$CFLAGS -I$snf_include_dir\"\n\t# Do not define a symbol.\n\tAC_CHECK_HEADER(snf.h)\n\tAC_LBL_RESTORE_CHECK_STATE\n\n\tif test \"$ac_cv_header_snf_h\" = yes; then\n\t\t# We found a header; make sure we can link with the library\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tLDFLAGS=\"$LDFLAGS -L$snf_lib_dir\"\n\t\t# Do not define a symbol.\n\t\tAC_CHECK_LIB([snf], [snf_init], [ac_cv_lbl_snf_api=\"yes\"])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\tfi\n\n\tif test \"$ac_cv_lbl_snf_api\" = yes; then\n\t\tAC_MSG_NOTICE([using Myricom SNF API headers from $snf_include_dir])\n\t\tAC_MSG_NOTICE([using Myricom SNF API libraries from $snf_lib_dir])\n\n\t\tV_INCLS=\"$V_INCLS -I$snf_include_dir\"\n\t\tADDITIONAL_LIBS=\"$ADDITIONAL_LIBS -L$snf_lib_dir -lsnf\"\n\t\tADDITIONAL_LIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC -L$snf_lib_dir -lsnf\"\n\t\tLIBS_PRIVATE=\"$LIBS_PRIVATE -L$snf_lib_dir -lsnf\"\n\n\t\tif test \"$V_PCAP\" != snf ; then\n\t\t\tMODULE_C_SRC=\"$MODULE_C_SRC pcap-snf.c\"\n\t\tfi\n\n\t\tAC_DEFINE(HAVE_SNF_API, 1, [define if you have the Myricom SNF API])\n\telse\n\t\tif test \"$V_PCAP\" = snf; then\n\t\t\t# User requested \"snf\" capture type but\n\t\t\t# we couldn't find the Sniffer API support.\n\t\t\tAC_MSG_ERROR([Myricom Sniffer support requested with --with-pcap=snf, but the Sniffer headers weren't found at $snf_include_dir: make sure the Sniffer support is installed, specify a different path or paths if necessary, or don't request Sniffer support])\n\t\tfi\n\n\t\tif test \"$want_snf\" = yes; then\n\t\t\tAC_MSG_ERROR([Myricom Sniffer support requested with --with-snf, but the Sniffer headers weren't found at $snf_include_dir: make sure the Sniffer support is installed, specify a different path or paths if necessary, or don't request Sniffer support])\n\t\tfi\n\tfi\nfi\n\ndnl\ndnl Allow the user to enable remote capture.\ndnl It's off by default, as that increases the attack surface of\ndnl libpcap, exposing it to malicious servers.\ndnl\nAC_MSG_CHECKING([whether to enable remote packet capture])\nAC_ARG_ENABLE([remote],\n   [AS_HELP_STRING([--enable-remote],\n     [enable remote packet capture @<:@default=no@:>@])],\n   [],\n   [enableval=no])\ncase \"$enableval\" in\nyes)\tAC_MSG_RESULT(yes)\n\tAC_MSG_WARN(Remote packet capture may expose libpcap-based applications)\n\tAC_MSG_WARN(to attacks by malicious remote capture servers!)\n\t#\n\t# rpcapd requires pthreads on UN*X.\n\t#\n\tif test \"$ac_lbl_have_pthreads\" != \"found\"; then\n\t\tAC_MSG_ERROR([rpcapd requires pthreads, but we didn't find them])\n\tfi\n\t#\n\t# It also requires crypt().\n\t# Do we have it in the system libraries?\n\t#\n\tAC_CHECK_FUNC(crypt,,\n\t    [\n\t\t#\n\t\t# No.  Do we have it in -lcrypt?\n\t\t#\n\t\tAC_CHECK_LIB(crypt, crypt,\n\t\t    [\n\t\t\t#\n\t\t\t# Yes; add -lcrypt to the libraries for rpcapd.\n\t\t\t#\n\t\t\tRPCAPD_LIBS=\"$RPCAPD_LIBS -lcrypt\"\n\t\t    ],\n\t\t    [\n\t\t\tAC_MSG_ERROR([rpcapd requires crypt(), but we didn't find it])\n\t\t    ])\n\t    ])\n\n\t#\n\t# OK, we have crypt().  Do we have getspnam()?\n\t#\n\tAC_CHECK_FUNCS(getspnam)\n\n\t#\n\t# Check for various members of struct msghdr.\n\t#\n\tAC_CHECK_MEMBERS([struct msghdr.msg_control],,,\n\t    [\n\t\t#include \"ftmacros.h\"\n\t\t#include <sys/socket.h>\n\t    ])\n\tAC_CHECK_MEMBERS([struct msghdr.msg_flags],,,\n\t    [\n\t\t#include \"ftmacros.h\"\n\t\t#include <sys/socket.h>\n\t    ])\n\n\t#\n\t# Optionally, we may want to support SSL.\n\t# Check for OpenSSL/libressl.\n\t#\n\t# First, try looking for it with pkg-config, if we have it.\n\t#\n\t# Homebrew's pkg-config does not, by default, look for\n\t# pkg-config files for packages it has installed.\n\t# Furthermore, at least for OpenSSL, they appear to be\n\t# dumped in package-specific directories whose paths are\n\t# not only package-specific but package-version-specific.\n\t#\n\t# So the only way to find openssl is to get the value of\n\t# PKG_CONFIG_PATH from \"brew --env openssl\" and add that\n\t# to PKG_CONFIG_PATH.  (No, we can't just assume it's under\n\t# /usr/local; Homebrew have conveniently chosen to put it\n\t# under /opt/homebrew on ARM.)\n\t#\n\t# That's the nice thing about Homebrew - it makes things easier!\n\t# Thanks!\n\t#\n\tsave_PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH\"\n\tif test -n \"$BREW\"; then\n\t\topenssl_pkgconfig_dir=`$BREW --env --plain openssl | sed -n 's/PKG_CONFIG_PATH: //p'`\n\t\tPKG_CONFIG_PATH=\"$openssl_pkgconfig_dir:$PKG_CONFIG_PATH\"\n\tfi\n\tPKG_CHECK_MODULE(OPENSSL, openssl,\n\t    [\n\t\t#\n\t\t# We found OpenSSL/libressl.\n\t\t#\n\t\tHAVE_OPENSSL=yes\n\t\tREQUIRES_PRIVATE=\"$REQUIRES_PRIVATE openssl\"\n\t    ])\n\tPKG_CONFIG_PATH=\"$save_PKG_CONFIG_PATH\"\n\n\t#\n\t# If it wasn't found, and we have Homebrew installed, see\n\t# if it's in Homebrew.\n\t#\n\tif test \"x$HAVE_OPENSSL\" != \"xyes\" -a -n \"$BREW\"; then\n\t\tAC_MSG_CHECKING(for openssl in Homebrew)\n\t\t#\n\t\t# The brew man page lies when it speaks of\n\t\t# $BREW --prefix --installed <formula>\n\t\t# outputting nothing.  In Homebrew 3.3.16,\n\t\t# it produces output regardless of whether\n\t\t# the formula is installed or not, so we\n\t\t# send the standard output and error to\n\t\t# the bit bucket.\n\t\t#\n\t\tif $BREW --prefix --installed openssl >/dev/null 2>&1; then\n\t\t\t#\n\t\t\t# Yes.  Get the include directory and library\n\t\t\t# directory.  (No, we can't just assume it's\n\t\t\t# under /usr/local; Homebrew have conveniently\n\t\t\t# chosen to put it under /opt/homebrew on ARM.)\n\t\t\t#\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tHAVE_OPENSSL=yes\n\t\t\topenssl_path=`$BREW --prefix openssl`\n\t\t\tOPENSSL_CFLAGS=\"-I$openssl_path/include\"\n\t\t\tOPENSSL_LIBS=\"-L$openssl_path/lib -lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_STATIC=\"-L$openssl_path/lib -lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_PRIVATE=\"-L$openssl_path/lib -lssl -lcrypto\"\n\t\telse\n\t\t\tAC_MSG_RESULT(no)\n\t\tfi\n\tfi\n\n\t#\n\t# If it wasn't found, and /usr/local/include and /usr/local/lib\n\t# exist, check if it's in /usr/local.  (We check whether they\n\t# exist because, if they don't exist, the compiler will warn\n\t# about that and then ignore the argument, so they test\n\t# using just the system header files and libraries.)\n\t#\n\t# We include the standard include file to 1) make sure that\n\t# it's installed (if it's just a shared library for the\n\t# benefit of existing programs, that's not useful) and 2)\n\t# because SSL_library_init() is a library routine in some\n\t# versions and a #defined wrapper around OPENSSL_init_ssl()\n\t# in others.\n\t#\n\tif test \"x$HAVE_OPENSSL\" != \"xyes\" -a -d \"/usr/local/include\" -a -d \"/usr/local/lib\"; then\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tCFLAGS=\"$CFLAGS -I/usr/local/include\"\n\t\tLIBS=\"$LIBS -L/usr/local/lib -lssl -lcrypto\"\n\t\tAC_MSG_CHECKING(whether we have OpenSSL/libressl in /usr/local that we can use)\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[\n#include <openssl/ssl.h>\n\t\t    ]],\n\t\t    [[\nSSL_library_init();\nreturn 0;\n\t\t    ]])],\n\t\t    [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tHAVE_OPENSSL=yes\n\t\t\tOPENSSL_CFLAGS=\"-I/usr/local/include\"\n\t\t\tOPENSSL_LIBS=\"-L/usr/local/lib -lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_STATIC=\"-L/usr/local/lib -lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_PRIVATE=\"-L/usr/local/lib -lssl -lcrypto\"\n\t\t    ],\n\t\t    AC_MSG_RESULT(no))\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\tfi\n\n\t#\n\t# If it wasn't found, check if it's a system library.\n\t#\n\t# We include the standard include file to 1) make sure that\n\t# it's installed (if it's just a shared library for the\n\t# benefit of existing programs, that's not useful) and 2)\n\t# because SSL_library_init() is a library routine in some\n\t# versions and a #defined wrapper around OPENSSL_init_ssl()\n\t# in others.\n\t#\n\tif test \"x$HAVE_OPENSSL\" != \"xyes\"; then\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tLIBS=\"$LIBS -lssl -lcrypto\"\n\t\tAC_MSG_CHECKING(whether we have a system OpenSSL/libressl that we can use)\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[\n#include <openssl/ssl.h>\n\t\t    ]],\n\t\t    [[\nSSL_library_init();\nreturn 0;\n\t\t    ]])],\n\t\t    [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tHAVE_OPENSSL=yes\n\t\t\tOPENSSL_LIBS=\"-lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_STATIC=\"-lssl -lcrypto\"\n\t\t\tOPENSSL_LIBS_PRIVATE=\"-lssl -lcrypto\"\n\t\t    ],\n\t\t    AC_MSG_RESULT(no))\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\tfi\n\n\t#\n\t# OK, did we find it?\n\t#\n\tif test \"x$HAVE_OPENSSL\" = \"xyes\"; then\n\t\tAC_DEFINE([HAVE_OPENSSL], [1], [Use OpenSSL])\n\t\tV_INCLS=\"$V_INCLS $OPENSSL_CFLAGS\"\n\t\tADDITIONAL_LIBS=\"$ADDITIONAL_LIBS $OPENSSL_LIBS\"\n\t\tADDITIONAL_LIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC $OPENSSL_LIBS_STATIC\"\n\t\tLIBS_PRIVATE=\"$LIBS_PRIVATE $OPENSSL_LIBS_PRIVATE\"\n\t\tREQUIRES_PRIVATE=\"$REQUIRES_PRIVATE $OPENSSL_REQUIRES_PRIVATE\"\n\t\tREMOTE_C_SRC=\"$REMOTE_C_SRC sslutils.c\"\n\telse\n\t\tAC_MSG_NOTICE(OpenSSL not found)\n\tfi\n\n\tAC_DEFINE(ENABLE_REMOTE, 1,\n\t    [Define to 1 if remote packet capture is to be supported])\n\tREMOTE_C_SRC=\"$REMOTE_C_SRC pcap-rpcap.c rpcap-protocol.c sockutils.c\"\n\tBUILD_RPCAPD=build-rpcapd\n\tINSTALL_RPCAPD=install-rpcapd\n\t;;\n*)\tAC_MSG_RESULT(no)\n\t;;\nesac\n\nAC_MSG_CHECKING(whether to build optimizer debugging code)\nAC_ARG_ENABLE(optimizer-dbg,\nAS_HELP_STRING([--enable-optimizer-dbg],[build optimizer debugging code]))\nif test \"$enable_optimizer_dbg\" = \"yes\"; then\n\tAC_DEFINE(BDEBUG,1,[Enable optimizer debugging])\nfi\nAC_MSG_RESULT(${enable_optimizer_dbg-no})\n\nAC_MSG_CHECKING(whether to build parser debugging code)\nAC_ARG_ENABLE(yydebug,\nAS_HELP_STRING([--enable-yydebug],[build parser debugging code]))\nif test \"$enable_yydebug\" = \"yes\"; then\n\tAC_DEFINE(YYDEBUG,1,[Enable parser debugging])\nfi\nAC_MSG_RESULT(${enable_yydebug-no})\n\n#\n# Look for {f}lex.\n#\nAC_PROG_LEX(noyywrap)\nif test \"$LEX\" = \":\"; then\n\tAC_MSG_ERROR([Neither flex nor lex was found.])\nfi\n\n#\n# Make sure {f}lex supports the -P, --header-file, and --nounput flags\n# and supports processing our scanner.l.\n#\nAC_CACHE_CHECK([for capable lex], tcpdump_cv_capable_lex,\n\tif $LEX -P pcap_ --header-file=/dev/null --nounput -t $srcdir/scanner.l > /dev/null 2>&1; then\n\t    tcpdump_cv_capable_lex=yes\n\telse\n\t    tcpdump_cv_capable_lex=insufficient\n\tfi)\nif test $tcpdump_cv_capable_lex = insufficient ; then\n\tAC_MSG_ERROR([$LEX is insufficient to compile libpcap.\n libpcap requires Flex 2.5.31 or later, or a compatible version of lex.\n If a suitable version of Lex/Flex is available as a non-standard command\n and/or not in the PATH, you can specify it using the LEX environment\n variable. That said, on some systems the error can mean that Flex/Lex is\n actually acceptable, but m4 is not. Likewise, if a suitable version of\n m4 (such as GNU M4) is available but has not been detected, you can\n specify it using the M4 environment variable.])\nfi\n\n#\n# Look for yacc/bison/byacc.\n# If it's Bison, we do not want -y, as 1) we will be using -o to cause\n# the output for XXX.y to be written to XXX.c and 2) we don't want\n# it to issue warnings about stuff not supported by POSIX YACC - we\n# want to use that stuff, and don't care whether plain YACC supports\n# it or not, we require either Bison or Berkeley YACC.\n#\nBISON_BYACC=\"\"\n#\n# Look for Bison.\n#\nAC_CHECK_PROGS(BISON_BYACC, bison)\nif test x\"$BISON_BYACC\" != x; then\n\t#\n\t# We found Bison.\n\t#\n\t# Bison prior to 2.4(.1) doesn't support \"%define api.pure\", so use\n\t# \"%pure-parser\".\n\t#\n\tbison_major_version=`$BISON_BYACC -V | sed -n 's/.* \\(@<:@1-9@:>@@<:@0-9@:>@*\\)\\.@<:@0-9@:>@@<:@0-9.@:>@*/\\1/p'`\n\tbison_minor_version=`$BISON_BYACC -V | sed -n 's/.* @<:@1-9@:>@@<:@0-9@:>@*\\.\\(@<:@0-9@:>@+\\).*/\\1/p'`\n\tif test \"$bison_major_version\" -lt 2 -o \\\n\t    \\( \"$bison_major_version\" -eq 2 -a \"$bison_major_version\" -lt 4 \\)\n\tthen\n\t\tREENTRANT_PARSER=\"%pure-parser\"\n\telse\n\t\tREENTRANT_PARSER=\"%define api.pure\"\n\tfi\nelse\n\t#\n\t# We didn't find Bison; check for Berkeley YACC, under the\n\t# names byacc and yacc.\n\t#\n\tAC_CHECK_PROGS(BISON_BYACC, byacc yacc)\n\tif test x\"$BISON_BYACC\" != x; then\n\t\t#\n\t\t# Make sure this is Berkeley YACC, not AT&T YACC;\n\t\t# the latter doesn't support reentrant parsers.\n\t\t# Run it with \"-V\"; that succeeds and reports the\n\t\t# version number with Berkeley YACC, but will\n\t\t# (probably) fail with various vendor flavors\n\t\t# of AT&T YACC.\n\t\t#\n\t\t# Hopefully this also eliminates any versions\n\t\t# of Berkeley YACC that don't support reentrant\n\t\t# parsers, if there are any.\n\t\t#\n\t\tAC_CACHE_CHECK([for capable yacc], tcpdump_cv_capable_yacc,\n\t\t    if $BISON_BYACC -V >/dev/null 2>&1; then\n\t\t\ttcpdump_cv_capable_yacc=yes\n\t\t    else\n\t\t\ttcpdump_cv_capable_yacc=insufficient\n\t\t    fi)\n\t\tif test $tcpdump_cv_capable_yacc = insufficient ; then\n\t\t    AC_MSG_ERROR([$BISON_BYACC is insufficient to compile libpcap.\n libpcap requires Bison, a newer version of Berkeley YACC with support\n for reentrant parsers, or another YACC compatible with them.])\n\t\tfi\n\telse\n\t\t#\n\t\t# OK, we found neither byacc nor yacc.\n\t\t#\n\t\tAC_MSG_ERROR([Neither bison, byacc, nor yacc was found.\n libpcap requires Bison, a newer version of Berkeley YACC with support\n for reentrant parsers, or another YACC compatible with them.])\n\tfi\n\n\t#\n\t# Berkeley YACC doesn't support \"%define api.pure\", so use\n\t# \"%pure-parser\".\n\t#\n\tREENTRANT_PARSER=\"%pure-parser\"\nfi\nAC_SUBST(BISON_BYACC)\nAC_SUBST(REENTRANT_PARSER)\n\n#\n# Do various checks for various OSes and versions of those OSes.\n#\n# Assume, by default, no support for shared libraries and V7/BSD\n# convention for man pages (devices in section 4, file formats in\n# section 5, miscellaneous info in section 7, administrative commands\n# and daemons in section 8).  Individual cases can override this.\n#\nDYEXT=\"none\"\nMAN_DEVICES=4\nMAN_FILE_FORMATS=5\nMAN_MISC_INFO=7\nMAN_ADMIN_COMMANDS=8\ncase \"$host_os\" in\n\naix*)\n\t#\n\t# AIX makes it fun to build shared and static libraries,\n\t# because they're *both* \".a\" archive libraries.  We\n\t# build the static library for the benefit of the traditional\n\t# scheme of building libpcap and tcpdump in subdirectories of\n\t# the same directory, with tcpdump statically linked with the\n\t# libpcap in question, but we also build a shared library as\n\t# \"libpcap.shareda\" and install *it*, rather than the static\n\t# library, as \"libpcap.a\".\n\t#\n\tDYEXT=\"shareda\"\n\n\tcase \"$V_PCAP\" in\n\n\tdlpi)\n\t\t#\n\t\t# If we're using DLPI, applications will need to\n\t\t# use /lib/pse.exp if present, as we use the\n\t\t# STREAMS routines.\n\t\t#\n\t\tpseexe=\"/lib/pse.exp\"\n\t\tAC_MSG_CHECKING(for $pseexe)\n\t\tif test -f $pseexe ; then\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tLIBS=\"-I:$pseexe\"\n\t\tfi\n\t\t;;\n\n\tbpf)\n\t\t#\n\t\t# If we're using BPF, we need \"-lodm\" and \"-lcfg\", as\n\t\t# we use them to load the BPF module.\n\t\t#\n\t\tLIBS=\"-lodm -lcfg\"\n\t\t;;\n\tesac\n\t;;\n\ndarwin*)\n\tDYEXT=\"dylib\"\n\tV_CCOPT=\"$V_CCOPT -fno-common\"\n\tAC_ARG_ENABLE(universal,\n\tAS_HELP_STRING([--disable-universal],[don't build universal on macOS]))\n\tif test \"$enable_universal\" != \"no\"; then\n\t\tcase \"$host_os\" in\n\n\t\tdarwin[[0-7]].*)\n\t\t\t#\n\t\t\t# Pre-Tiger.  Build only for 32-bit PowerPC; no\n\t\t\t# need for any special compiler or linker flags.\n\t\t\t#\n\t\t\t;;\n\n\t\tdarwin8.[[0123]]|darwin8.[[0123]].*)\n\t\t\t#\n\t\t\t# Tiger, prior to Intel support.  Build\n\t\t\t# libraries and executables for 32-bit PowerPC\n\t\t\t# and 64-bit PowerPC, with 32-bit PowerPC first.\n\t\t\t# (I'm guessing that's what Apple does.)\n\t\t\t#\n\t\t\t# (The double brackets are needed because\n\t\t\t# autotools/m4 use brackets as a quoting\n\t\t\t# character; the double brackets turn into\n\t\t\t# single brackets in the generated configure\n\t\t\t# file.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch ppc -arch ppc64\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch ppc -arch ppc64\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch ppc -arch ppc64\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch ppc -arch ppc64\"\n\t\t\t;;\n\n\t\tdarwin8.[[456]]|darwin8.[[456]].*)\n\t\t\t#\n\t\t\t# Tiger, subsequent to Intel support but prior\n\t\t\t# to x86-64 support.  Build libraries and\n\t\t\t# executables for 32-bit PowerPC, 64-bit\n\t\t\t# PowerPC, and 32-bit x86, with 32-bit PowerPC\n\t\t\t# first.  (I'm guessing that's what Apple does.)\n\t\t\t#\n\t\t\t# (The double brackets are needed because\n\t\t\t# autotools/m4 use brackets as a quoting\n\t\t\t# character; the double brackets turn into\n\t\t\t# single brackets in the generated configure\n\t\t\t# file.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch ppc -arch ppc64 -arch i386\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch ppc -arch ppc64 -arch i386\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch ppc -arch ppc64 -arch i386\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch ppc -arch ppc64 -arch i386\"\n\t\t\t;;\n\n\t\tdarwin8.*)\n\t\t\t#\n\t\t\t# All other Tiger, so subsequent to x86-64\n\t\t\t# support.  Build libraries and executables for\n\t\t\t# 32-bit PowerPC, 64-bit PowerPC, 32-bit x86,\n\t\t\t# and x86-64, with 32-bit PowerPC first.  (I'm\n\t\t\t# guessing that's what Apple does.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\t;;\n\n\t\tdarwin9.*)\n\t\t\t#\n\t\t\t# Leopard.  Build libraries for 32-bit PowerPC,\n\t\t\t# 64-bit PowerPC, 32-bit x86, and x86-64, with\n\t\t\t# 32-bit PowerPC first, and build executables\n\t\t\t# for 32-bit x86 and 32-bit PowerPC, with 32-bit\n\t\t\t# x86 first.  (That's what Apple does.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch ppc -arch ppc64 -arch i386 -arch x86_64\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch i386 -arch ppc\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch i386 -arch ppc\"\n\t\t\t;;\n\n\t\tdarwin10.*)\n\t\t\t#\n\t\t\t# Snow Leopard.  Build libraries for x86-64,\n\t\t\t# 32-bit x86, and 32-bit PowerPC, with x86-64\n\t\t\t# first, and build executables for x86-64 and\n\t\t\t# 32-bit x86, with x86-64 first.  (That's what\n\t\t\t# Apple does, even though Snow Leopard doesn't\n\t\t\t# run on PPC, so PPC libpcap runs under Rosetta,\n\t\t\t# and Rosetta doesn't support BPF ioctls, so PPC\n\t\t\t# programs can't do live captures.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64 -arch i386 -arch ppc\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64 -arch i386 -arch ppc\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch x86_64 -arch i386\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch x86_64 -arch i386\"\n\t\t\t;;\n\n\t\tdarwin1[[1-8]]*)\n\t\t\t#\n\t\t\t# Post-Snow Leopard, pre-Catalina.  Build\n\t\t\t# libraries for x86-64 and 32-bit x86, with\n\t\t\t# x86-64 first, and build executables only for\n\t\t\t# x86-64.  (That's what Apple does.)  This\n\t\t\t# requires no special flags for programs.\n\t\t\t#\n\t\t\t# We check whether we *can* build for i386 and,\n\t\t\t# if not, suggest that the user install the\n\t\t\t# /usr/include headers if they want to build\n\t\t\t# fat.\n\t\t\t#\n\t\t\tAC_MSG_CHECKING(whether building for 32-bit x86 is supported)\n\t\t\tAC_LBL_SAVE_CHECK_STATE\n\t\t\tCFLAGS=\"$CFLAGS -arch i386\"\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t\t    [[]],\n\t\t\t    [[return 0;]])],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64\"\n\t\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64\"\n\n\t\t\t\t#\n\t\t\t\t# OpenSSL installation on macOS seems\n\t\t\t\t# to install only the libs for 64-bit\n\t\t\t\t# x86 - at least that's what Brew does:\n\t\t\t\t# only configure 32-bit builds if we\n\t\t\t\t# don't have OpenSSL.\n\t\t\t\t#\n\t\t\t\tif test \"$HAVE_OPENSSL\" != yes; then\n\t\t\t\t\tV_LIB_CCOPT_FAT=\"$V_LIB_CCOPT_FAT -arch i386\"\n\t\t\t\t\tV_LIB_LDFLAGS_FAT=\"$V_LIB_LDFLAGS_FAT -arch i386\"\n\t\t\t\tfi\n\t\t\t    ],\n\t\t\t    [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64\"\n\t\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64\"\n\t\t\t\tcase \"$host_os\" in\n\n\t\t\t\tdarwin18.*)\n\t\t\t\t\t#\n\t\t\t\t\t# Mojave; you need to install the\n\t\t\t\t\t# /usr/include headers to get\n\t\t\t\t\t# 32-bit x86 builds to work.\n\t\t\t\t\t#\n\t\t\t\t\tAC_MSG_WARN([Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package])\n\t\t\t\t\t;;\n\n\t\t\t\t*)\n\t\t\t\t\t#\n\t\t\t\t\t# Pre-Mojave; the command-line\n\t\t\t\t\t# tools should be sufficient to\n\t\t\t\t\t# enable 32-bit x86 builds.\n\t\t\t\t\t#\n\t\t\t\t\tAC_MSG_WARN([Compiling for 32-bit x86 gives an error; try installing the command-line tools])\n\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t    ])\n\t\t\tAC_LBL_RESTORE_CHECK_STATE\n\t\t\t;;\n\n\t\tdarwin19*)\n\t\t\t#\n\t\t\t# Catalina.  Build libraries and executables\n\t\t\t# only for x86-64.  (That's what Apple does;\n\t\t\t# 32-bit x86 binaries are not supported on\n\t\t\t# Catalina.)\n\t\t\t#\n\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64\"\n\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64\"\n\t\t\tV_PROG_CCOPT_FAT=\"-arch x86_64\"\n\t\t\tV_PROG_LDFLAGS_FAT=\"-arch x86_64\"\n\t\t\t;;\n\n\t\tdarwin*)\n\t\t\t#\n\t\t\t# Post-Catalina.  Build libraries and\n\t\t\t# executables for x86-64 and ARM64.\n\t\t\t# (That's what Apple does, except they\n\t\t\t# build for arm64e, which may include\n\t\t\t# some of the pointer-checking extensions.)\n\t\t\t#\n\t\t\t# If we're building with libssl, make sure\n\t\t\t# we can build fat with it (i.e., that it\n\t\t\t# was built fat); if we can't, don't set\n\t\t\t# the target architectures, and just\n\t\t\t# build for the host we're on.\n\t\t\t#\n\t\t\t# Otherwise, just add both of them.\n\t\t\t#\n\t\t\tif test \"$HAVE_OPENSSL\" = yes; then\n\t\t\t\tAC_MSG_CHECKING(whether building fat with libssl is supported)\n\t\t\t\tAC_LBL_SAVE_CHECK_STATE\n\t\t\t\tCFLAGS=\"$CFLAGS -arch x86_64 -arch arm64\"\n\t\t\t\tLDFLAGS=\"$LDFLAGS $OPENSSL_LIBS\"\n\t\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t\t\t    [[\n\t\t\t\t\t#include <openssl/ssl.h>\n\t\t\t\t    ]],\n\t\t\t\t    [[\n\t\t\t\t\tSSL_library_init();\n\t\t\t\t\treturn 0;\n\t\t\t\t    ]])],\n\t\t\t\t    [\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\t\tV_PROG_CCOPT_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\t\tV_PROG_LDFLAGS_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\t    ],\n\t\t\t\t    [AC_MSG_RESULT(no)]\n\t\t\t\t)\n\t\t\t\tAC_LBL_RESTORE_CHECK_STATE\n\t\t\telse\n\t\t\t\tV_LIB_CCOPT_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\tV_LIB_LDFLAGS_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\tV_PROG_CCOPT_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\t\tV_PROG_LDFLAGS_FAT=\"-arch x86_64 -arch arm64\"\n\t\t\tfi\n\t\t\t;;\n\t\tesac\n\tfi\n\t;;\n\nhpux9*|hpux10.[01]*)\n\tAC_MSG_ERROR([HP-UX version must be 10.20 or later, not $host_os])\n\t;;\n\nhpux*)\n\tdnl HPUX 10.20 and above is similar to HPUX 9, but\n\tdnl not the same....\n\tdnl\n\tdnl XXX - DYEXT should be set to \"sl\" if this is building\n\tdnl for 32-bit PA-RISC, but should be left as \"so\" for\n\tdnl 64-bit PA-RISC or, I suspect, IA-64.\n\tAC_DEFINE(HAVE_HPUX10_20_OR_LATER,1,[on HP-UX 10.20 or later])\n\tif test \"`uname -m`\" = \"ia64\"; then\n\t\tDYEXT=\"so\"\n\telse\n\t\tDYEXT=\"sl\"\n\tfi\n\n\t#\n\t# \"-b\" builds a shared library; \"+h\" sets the soname.\n\t#\n\tSHLIB_OPT=\"-b\"\n\tSONAME_OPT=\"+h\"\n\n\t#\n\t# Use System V conventions for man pages.\n\t#\n\tMAN_FILE_FORMATS=4\n\tMAN_MISC_INFO=5\n\t;;\n\nlinux*|freebsd*|netbsd*|openbsd*|dragonfly*|kfreebsd*|gnu*|haiku*|midipix*)\n\tDYEXT=\"so\"\n\t;;\n\nsolaris*)\n\tAC_DEFINE(HAVE_SOLARIS,1,[On solaris])\n\n\tDYEXT=\"so\"\n\n\t#\n\t# Make sure errno is thread-safe, in case we're called in\n\t# a multithreaded program.  We don't guarantee that two\n\t# threads can use the *same* pcap_t safely, but the\n\t# current version does guarantee that you can use different\n\t# pcap_t's in different threads, and even that pcap_compile()\n\t# is thread-safe (it wasn't thread-safe in some older versions).\n\t#\n\tV_CCOPT=\"$V_CCOPT -D_TS_ERRNO\"\n\n\tcase \"`uname -r`\" in\n\n\t5.12)\n\t\t;;\n\n\t*)\n\t\t#\n\t\t# Use System V conventions for man pages.\n\t\t#\n\t\tMAN_ADMIN_COMMANDS=1m\n\t\tMAN_FILE_FORMATS=4\n\t\tMAN_MISC_INFO=5\n\t\tMAN_DEVICES=7D\n\tesac\n\t;;\nesac\nAC_SUBST(V_LIB_CCOPT_FAT)\nAC_SUBST(V_LIB_LDFLAGS_FAT)\nAC_SUBST(V_PROG_CCOPT_FAT)\nAC_SUBST(V_PROG_LDFLAGS_FAT)\nAC_SUBST(DYEXT)\nAC_SUBST(MAN_DEVICES)\nAC_SUBST(MAN_FILE_FORMATS)\nAC_SUBST(MAN_MISC_INFO)\nAC_SUBST(MAN_ADMIN_COMMANDS)\n\nAC_ARG_ENABLE(shared,\nAS_HELP_STRING([--enable-shared],[build shared libraries @<:@default=yes, if support available@:>@]))\ntest \"x$enable_shared\" = \"xno\" && DYEXT=\"none\"\n\nAC_PROG_RANLIB\nAC_CHECK_TOOL([AR], [ar])\n\nAC_PROG_LN_S\nAC_SUBST(LN_S)\n\nAC_LBL_DEVEL(V_CCOPT)\n\n#\n# Check to see if the sockaddr struct has the 4.4 BSD sa_len member.\n#\nAC_CHECK_MEMBERS([struct sockaddr.sa_len],,,\n    [\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n    ])\n\n#\n# Check to see if the dl_hp_ppa_info_t struct has the HP-UX 11.00\n# dl_module_id_1 member.\n#\n# NOTE: any failure means we conclude that it doesn't have that member,\n# so if we don't have DLPI, don't have a <sys/dlpi_ext.h> header, or\n# have one that doesn't declare a dl_hp_ppa_info_t type, we conclude\n# it doesn't have that member (which is OK, as either we won't be\n# using code that would use that member, or we wouldn't compile in\n# any case).\n#\nAC_CHECK_MEMBERS([dl_hp_ppa_info_t.dl_module_id_1],,,\n    [\n\t#include <sys/types.h>\n\t#include <sys/dlpi.h>\n\t#include <sys/dlpi_ext.h>\n    ])\n\n#\n# Various Linux-specific mechanisms.\n#\nAC_ARG_ENABLE([usb],\n[AS_HELP_STRING([--enable-usb],[enable Linux usbmon USB capture support @<:@default=yes, if support available@:>@])],\n    [],\n    [enable_usb=yes])\n\n#\n# If somebody requested an XXX-only pcap, that doesn't include\n# additional mechanisms.\n#\nif test \"$xxx_only\" != yes; then\n  case \"$host_os\" in\n  linux*)\n    dnl check for USB sniffing support\n    AC_MSG_CHECKING(for Linux usbmon USB sniffing support)\n    if test \"x$enable_usb\" != \"xno\" ; then\n      AC_DEFINE(PCAP_SUPPORT_LINUX_USBMON, 1, [target host supports Linux usbmon for USB sniffing])\n      MODULE_C_SRC=\"$MODULE_C_SRC pcap-usb-linux.c\"\n      AC_MSG_RESULT(yes)\n      #\n      # Note: if the directory for special files is *EVER* somewhere\n      # other than the UN*X standard of /dev (which will break any\n      # software that looks for /dev/null or /dev/tty, for example,\n      # so doing that is *REALLY* not a good idea), please provide\n      # some mechanism to determine that directory at *run time*,\n      # rather than *configure time*, so that it works when doing\n      # a cross-build, and that works with *multiple* distributions,\n      # with our without udev, and with multiple versions of udev,\n      # with udevinfo or udevadm or any other mechanism to get the\n      # special files directory.\n      #\n      # Do we have a version of <linux/compiler.h> available?\n      # If so, we might need it for <linux/usbdevice_fs.h>.\n      #\n      AC_CHECK_HEADERS(linux/compiler.h)\n      if test \"$ac_cv_header_linux_compiler_h\" = yes; then\n        #\n        # Yes - include it when testing for <linux/usbdevice_fs.h>.\n        #\n        AC_CHECK_HEADERS(linux/usbdevice_fs.h,,,[#include <linux/compiler.h>])\n      else\n        AC_CHECK_HEADERS(linux/usbdevice_fs.h)\n      fi\n      if test \"$ac_cv_header_linux_usbdevice_fs_h\" = yes; then\n        #\n        # OK, does it define bRequestType?  Older versions of the kernel\n        # define fields with names like \"requesttype, \"request\", and\n        # \"value\", rather than \"bRequestType\", \"bRequest\", and\n        # \"wValue\".\n        #\n        AC_CHECK_MEMBERS([struct usbdevfs_ctrltransfer.bRequestType],,,\n          [\n            AC_INCLUDES_DEFAULT\n            #ifdef HAVE_LINUX_COMPILER_H\n            #include <linux/compiler.h>\n            #endif\n            #include <linux/usbdevice_fs.h>\n          ])\n      fi\n    else\n      AC_MSG_RESULT(no)\n    fi\n\n    #\n    # Life's too short to deal with trying to get this to compile\n    # if you don't get the right types defined with\n    # __KERNEL_STRICT_NAMES getting defined by some other include.\n    #\n    # Check whether the includes Just Work.  If not, don't turn on\n    # netfilter support.\n    #\n    AC_MSG_CHECKING(whether we can compile the netfilter support)\n    AC_CACHE_VAL(ac_cv_netfilter_can_compile,\n      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\nAC_INCLUDES_DEFAULT\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/types.h>\n\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_log.h>\n#include <linux/netfilter/nfnetlink_queue.h>]],\n        [[]])],\n        [ac_cv_netfilter_can_compile=yes],\n        [ac_cv_netfilter_can_compile=no]))\n    AC_MSG_RESULT($ac_cv_netfilter_can_compile)\n    if test $ac_cv_netfilter_can_compile = yes ; then\n      AC_DEFINE(PCAP_SUPPORT_NETFILTER, 1,\n        [target host supports netfilter sniffing])\n      MODULE_C_SRC=\"$MODULE_C_SRC pcap-netfilter-linux.c\"\n    fi\n    ;;\n  esac\nfi\nAC_SUBST(PCAP_SUPPORT_LINUX_USBMON)\nAC_SUBST(PCAP_SUPPORT_NETFILTER)\n\nAC_ARG_ENABLE([netmap],\n[AS_HELP_STRING([--enable-netmap],[enable netmap support @<:@default=yes, if support available@:>@])],\n    [],\n    [enable_netmap=yes])\n\nif test \"x$enable_netmap\" != \"xno\" ; then\n\t#\n\t# Check whether net/netmap_user.h is usable if NETMAP_WITH_LIBS is\n\t# defined; it's not usable on DragonFly BSD 4.6 if NETMAP_WITH_LIBS\n\t# is defined, for example, as it includes a nonexistent malloc.h\n\t# header.\n\t#\n\tAC_MSG_CHECKING(whether we can compile the netmap support)\n\tAC_CACHE_VAL(ac_cv_net_netmap_user_can_compile,\n\t  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\nAC_INCLUDES_DEFAULT\n#define NETMAP_WITH_LIBS\n#include <net/netmap_user.h>]],\n\t    [[]])],\n\t    [ac_cv_net_netmap_user_can_compile=yes],\n\t    [ac_cv_net_netmap_user_can_compile=no]))\n\tAC_MSG_RESULT($ac_cv_net_netmap_user_can_compile)\n\tif test $ac_cv_net_netmap_user_can_compile = yes ; then\n\t  AC_DEFINE(PCAP_SUPPORT_NETMAP, 1,\n\t    [target host supports netmap])\n\t    MODULE_C_SRC=\"$MODULE_C_SRC pcap-netmap.c\"\n\tfi\n\tAC_SUBST(PCAP_SUPPORT_NETMAP)\nfi\n\n# Check for DPDK support.\nAC_ARG_WITH([dpdk],\nAS_HELP_STRING([--with-dpdk@<:@=DIR@:>@],[include DPDK support (located in directory DIR, if supplied).  @<:@default=yes, if present@:>@]),\n[\n\tif test \"$withval\" = no\n\tthen\n\t\t# User doesn't want DPDK support.\n\t\twant_dpdk=no\n\telif test \"$withval\" = yes\n\tthen\n\t\t# User wants DPDK support but hasn't specified a directory.\n\t\twant_dpdk=yes\n\telse\n\t\t# User wants DPDK support and has specified a directory,\n\t\t# so use the provided value.\n\t\twant_dpdk=yes\n\t\tdpdk_dir=$withval\n\tfi\n],[\n\tif test \"$V_PCAP\" = dpdk; then\n\t\t# User requested DPDK-only libpcap, so we'd better have\n\t\t# the DPDK API.\n\t\twant_dpdk=yes\n\telif test \"$xxx_only\" = yes; then\n\t\t# User requested something-else-only pcap, so they don't\n\t\t# want DPDK support.\n\t\twant_dpdk=no\n\telse\n\t\t#\n\t\t# Use DPDK API if present, otherwise don't\n\t\t#\n\t\twant_dpdk=ifpresent\n\tfi\n])\n\nif test \"$want_dpdk\" != no; then\n\t#\n\t# The user didn't explicitly say they don't want DPDK,\n\t# so see if we have it.\n\t#\n\t# We only try to find it using pkg-config; DPDK is *SO*\n\t# complicated - DPDK 19.02, for example, has about 117(!)\n\t# libraries, and the precise set of libraries required has\n\t# changed over time - so attempting to guess which libraries\n\t# you need, and hardcoding that in an attempt to find the\n\t# libraries without DPDK, rather than relying on DPDK to\n\t# tell you, with a .pc file, what libraries are needed,\n\t# is *EXTREMELY* fragile and has caused some bug reports,\n\t# so we're just not going to do it.\n\t#\n\t# If that causes a problem, the only thing we will do is\n\t# accept an alternative way of finding the appropriate\n\t# library set for the installed version of DPDK that is\n\t# as robust as pkg-config (i.e., it had better work as well\n\t# as pkg-config with *ALL* versions of DPDK that provide a\n\t# libdpdk.pc file).\n\t#\n\t# If --with-dpdk={path} was specified, add {path}/pkgconfig\n\t# to PKG_CONFIG_PATH, so we look for the .pc file there,\n\t# first.\n\t#\n\tsave_PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH\"\n\tif test -n \"$dpdk_dir\"; then\n\t\tPKG_CONFIG_PATH=\"$dpdk_dir:$PKG_CONFIG_PATH\"\n\tfi\n\tPKG_CHECK_MODULE(DPDK, libdpdk,\n\t    [\n\t\tfound_dpdk=yes\n\t    ])\n\tPKG_CONFIG_PATH=\"$save_PKG_CONFIG_PATH\"\n\n\t#\n\t# Did we find DPDK?\n\t#\n\tif test \"$found_dpdk\" = yes; then\n\t\t#\n\t\t# Found it.\n\t\t#\n\t\t# We call rte_eth_dev_count_avail(), and older versions\n\t\t# of DPDK didn't have it, so check for it.\n\t\t#\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tCFLAGS=\"$CFLAGS $DPDK_CFLAGS\"\n\t\tLIBS=\"$LIBS $DPDK_LIBS\"\n\t\tAC_CHECK_FUNC(rte_eth_dev_count_avail)\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\tfi\n\n\tif test \"$ac_cv_func_rte_eth_dev_count_avail\" = yes; then\n\t\t#\n\t\t# We found a usable DPDK.\n\t\t#\n\t\t# Check whether the rte_ether.h file defines\n\t\t# struct ether_addr or struct rte_ether_addr.\n\t\t#\n\t\t# (\"API compatibility?  That's for losers!\")\n\t\t#\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tCFLAGS=\"$CFLAGS $DPDK_CFLAGS\"\n\t\tLIBS=\"$LIBS $DPDK_LIBS\"\n\t\tAC_CHECK_TYPES(struct rte_ether_addr,,,\n\t\t    [\n\t\t\t#include <rte_ether.h>\n\t\t    ])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\n\t\t#\n\t\t# We can build with DPDK.\n\t\t#\n\t\tV_INCLS=\"$V_INCLS $DPDK_CFLAGS\"\n\t\tADDITIONAL_LIBS=\"$ADDITIONAL_LIBS $DPDK_LIBS\"\n\t\tADDITIONAL_LIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC $DPDK_LIBS_STATIC\"\n\t\tREQUIRES_PRIVATE=\"$REQUIRES_PRIVATE libdpdk\"\n\t\tAC_DEFINE(PCAP_SUPPORT_DPDK, 1, [target host supports DPDK])\n\t\tif test $V_PCAP != dpdk ; then\n\t\t\tMODULE_C_SRC=\"$MODULE_C_SRC pcap-dpdk.c\"\n\t\tfi\n\telse\n\t\t#\n\t\t# We didn't find a usable DPDK.\n\t\t# If we required it (with --with-dpdk or --with-pcap=dpdk),\n\t\t# fail with an appropriate message telling the user what\n\t\t# the problem was, otherwise note the problem with a\n\t\t# warning.\n\t\t#\n\t\tif test \"$found_dpdk\" != yes; then\n\t\t\t#\n\t\t\t# Not found with pkg-config.  Note that we\n\t\t\t# require that DPDK must be findable with\n\t\t\t# pkg-config.\n\t\t\t#\n\t\t\tif test \"$V_PCAP\" = dpdk; then\n\t\t\t\t#\n\t\t\t\t# User requested DPDK-only capture support.\n\t\t\t\t#\n\t\t\t\tAC_MSG_ERROR(\n[DPDK support requested with --with-pcap=dpdk, but\nwe couldn't find DPDK with pkg-config.  Make sure that pkg-config is\ninstalled, that DPDK 18.02.2 or later is installed, and that DPDK\nprovides a .pc file.])\n\t\t\tfi\n\n\t\t\tif test \"$want_dpdk\" = yes; then\n\t\t\t\t#\n\t\t\t\t# User requested that libpcap include\n\t\t\t\t# DPDK capture support.\n\t\t\t\t#\n\t\t\t\tAC_MSG_ERROR(\n[DPDK support requested with --with-dpdk, but we\ncouldn't find DPDK with pkg-config.  Make sure that pkg-config\nis installed, that DPDK 18.02.2 or later is installed, and that\nDPDK provides .pc file.])\n\t\t\tfi\n\n\t\t\t#\n\t\t\t# User didn't indicate whether they wanted DPDK\n\t\t\t# or not; just warn why we didn't find it.\n\t\t\t#\n\t\t\tAC_MSG_WARN(\n[We couldn't find DPDK with pkg-config.  If\nyou want DPDK support, make sure that pkg-config is installed,\nthat DPDK 18.02.2 or later is installed, and that DPDK provides a\n.pc file.])\n\t\telif test \"$ac_cv_func_rte_eth_dev_count_avail\" != yes; then\n\t\t\t#\n\t\t\t# Found with pkg-config, but we couldn't compile\n\t\t\t# a program that calls rte_eth_dev_count(); we\n\t\t\t# probably have the developer package installed,\n\t\t\t# but don't have a sufficiently recent version\n\t\t\t# of DPDK.  Note that we need a sufficiently\n\t\t\t# recent version of DPDK.\n\t\t\t#\n\t\t\tif test \"$V_PCAP\" = dpdk; then\n\t\t\t\t#\n\t\t\t\t# User requested DPDK-only capture support.\n\t\t\t\t#\n\t\t\t\tAC_MSG_ERROR(\n[DPDK support requested with --with-pcap=dpdk, but we\ncan't compile libpcap with DPDK.  Make sure that DPDK 18.02.2 or later\nis installed.])\n\t\t\tfi\n\n\t\t\tif test \"$want_dpdk\" = yes; then\n\t\t\t\t#\n\t\t\t\t# User requested that libpcap include\n\t\t\t\t# DPDK capture support.\n\t\t\t\t#\n\t\t\t\tAC_MSG_ERROR(\n[DPDK support requested with --with-dpdk, but\nwe can't compile libpcap with DPDK.  Make sure that DPDK 18.02.2\nor later is DPDK is installed.])\n\t\t\tfi\n\n\t\t\t#\n\t\t\t# User didn't indicate whether they wanted DPDK\n\t\t\t# or not; just warn why we didn't find it.\n\t\t\t#\n\t\t\tAC_MSG_WARN(\n[DPDK was found, but we can't compile libpcap with it.\nMake sure that DPDK 18.02.2 or later is installed.])\n\t\tfi\n\tfi\nfi\nAC_SUBST(PCAP_SUPPORT_DPDK)\n\nAC_ARG_ENABLE([bluetooth],\n[AS_HELP_STRING([--enable-bluetooth],[enable Bluetooth support @<:@default=yes, if support available@:>@])],\n    [],\n    [enable_bluetooth=ifsupportavailable])\n\nif test \"$xxx_only\" = yes; then\n\t# User requested something-else-only pcap, so they don't\n\t# want Bluetooth support.\n\tenable_bluetooth=no\nfi\n\nif test \"x$enable_bluetooth\" != \"xno\" ; then\n\tdnl check for Bluetooth sniffing support\n\tcase \"$host_os\" in\n\tlinux*)\n\t\tAC_CHECK_HEADER(bluetooth/bluetooth.h,\n\t\t    [\n\t\t\t#\n\t\t\t# We have bluetooth.h, so we support Bluetooth\n\t\t\t# sniffing.\n\t\t\t#\n\t\t\tAC_DEFINE(PCAP_SUPPORT_BT, 1, [target host supports Bluetooth sniffing])\n\t\t\tMODULE_C_SRC=\"$MODULE_C_SRC pcap-bt-linux.c\"\n\t\t\tAC_MSG_NOTICE(Bluetooth sniffing is supported)\n\t\t\tac_lbl_bluetooth_available=yes\n\n\t\t\t#\n\t\t\t# OK, does struct sockaddr_hci have an hci_channel\n\t\t\t# member?\n\t\t\t#\n\t\t\tAC_CHECK_MEMBERS([struct sockaddr_hci.hci_channel],\n\t\t\t    [\n\t\t\t\t#\n\t\t\t\t# Yes; is HCI_CHANNEL_MONITOR defined?\n\t\t\t\t#\n\t\t\t\tAC_MSG_CHECKING(if HCI_CHANNEL_MONITOR is defined)\n\t\t\t\tAC_CACHE_VAL(ac_cv_lbl_hci_channel_monitor_is_defined,\n\t\t\t\t    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n\t\t\t\t\t[[\n\t\t\t\t\t    #include <bluetooth/bluetooth.h>\n\t\t\t\t\t    #include <bluetooth/hci.h>\n\t\t\t\t\t]],\n\t\t\t\t\t[[\n\t\t\t\t\t    int i = HCI_CHANNEL_MONITOR;\n\t\t\t\t\t]])],\n\t\t\t\t\t[\n\t\t\t\t\t    AC_MSG_RESULT(yes)\n\t\t\t\t\t    AC_DEFINE(PCAP_SUPPORT_BT_MONITOR, 1,\n\t\t\t\t\t      [target host supports Bluetooth Monitor])\n\t\t\t\t\t    MODULE_C_SRC=\"$MODULE_C_SRC pcap-bt-monitor-linux.c\"\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t    AC_MSG_RESULT(no)\n\t\t\t\t\t]))\n\t\t\t    ],,\n\t\t\t    [\n\t\t\t\t#include <bluetooth/bluetooth.h>\n\t\t\t\t#include <bluetooth/hci.h>\n\t\t\t    ])\n\t\t    ],\n\t\t    [\n\t\t\t#\n\t\t\t# We don't have bluetooth.h, so we don't support\n\t\t\t# Bluetooth sniffing.\n\t\t\t#\n\t\t\tif test \"x$enable_bluetooth\" = \"xyes\" ; then\n\t\t\t\tAC_MSG_ERROR(Bluetooth sniffing is not supported; install a Bluetooth devel library (libbluetooth-dev|bluez-libs-devel|bluez-dev|libbluetooth-devel|...) to enable it)\n\t\t\telse\n\t\t\t\tAC_MSG_NOTICE(Bluetooth sniffing is not supported; install a Bluetooth devel library (libbluetooth-dev|bluez-libs-devel|bluez-dev|libbluetooth-devel|...) to enable it)\n\t\t\tfi\n\t\t    ])\n\t\t;;\n\t*)\n\t\tif test \"x$enable_bluetooth\" = \"xyes\" ; then\n\t\t\tAC_MSG_ERROR(no Bluetooth sniffing support implemented for $host_os)\n\t\telse\n\t\t\tAC_MSG_NOTICE(no Bluetooth sniffing support implemented for $host_os)\n\t\tfi\n\t\t;;\n\tesac\n\tAC_SUBST(PCAP_SUPPORT_BT)\nfi\n\nAC_ARG_ENABLE([dbus],\n[AS_HELP_STRING([--enable-dbus],[enable D-Bus capture support @<:@default=yes, if support available@:>@])],\n    [],\n    [enable_dbus=ifavailable])\n\nif test \"$xxx_only\" = yes; then\n\t# User requested something-else-only pcap, so they don't\n\t# want D-Bus support.\n\tenable_dbus=no\nfi\n\nif test \"x$enable_dbus\" != \"xno\"; then\n\tif test \"x$enable_dbus\" = \"xyes\"; then\n\t\tcase \"$host_os\" in\n\n\t\tdarwin*)\n\t\t\t#\n\t\t\t# We don't support D-Bus sniffing on macOS; see\n\t\t\t#\n\t\t\t# https://bugs.freedesktop.org/show_bug.cgi?id=74029\n\t\t\t#\n\t\t\t# The user requested it, so fail.\n\t\t\t#\n\t\t\tAC_MSG_ERROR([Due to freedesktop.org bug 74029, D-Bus capture support is not available on macOS])\n\t\tesac\n\telse\n\t\tcase \"$host_os\" in\n\n\t\tdarwin*)\n\t\t\t#\n\t\t\t# We don't support D-Bus sniffing on macOS; see\n\t\t\t#\n\t\t\t# https://bugs.freedesktop.org/show_bug.cgi?id=74029\n\t\t\t#\n\t\t\t# The user didn't explicitly request it, so just\n\t\t\t# silently refuse to enable it.\n\t\t\t#\n\t\t\tenable_dbus=\"no\"\n\t\t\t;;\n\t\tesac\n\tfi\nfi\n\nif test \"x$enable_dbus\" != \"xno\"; then\n\tPKG_CHECK_MODULE(DBUS, dbus-1,\n\t    [\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tCFLAGS=\"$CFLAGS $DBUS_CFLAGS\"\n\t\tLIBS=\"$LIBS $DBUS_LIBS\"\n\t\tAC_MSG_CHECKING(whether the D-Bus library defines dbus_connection_read_write)\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t    [[#include <string.h>\n\n\t\t     #include <time.h>\n\t\t     #include <sys/time.h>\n\n\t\t     #include <dbus/dbus.h>]],\n\t\t    [[return dbus_connection_read_write(NULL, 0);]])],\n\t\t    [\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE(PCAP_SUPPORT_DBUS, 1, [support D-Bus sniffing])\n\t\t\tMODULE_C_SRC=\"$MODULE_C_SRC pcap-dbus.c\"\n\t\t\tV_INCLS=\"$V_INCLS $DBUS_CFLAGS\"\n\t\t\tADDITIONAL_LIBS=\"$ADDITIONAL_LIBS $DBUS_LIBS\"\n\t\t\tADDITIONAL_LIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC $DBUS_LIBS_STATIC\"\n\t\t\tREQUIRES_PRIVATE=\"$REQUIRES_PRIVATE dbus-1\"\n\t\t    ],\n\t\t    [\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tif test \"x$enable_dbus\" = \"xyes\"; then\n\t\t\t    AC_MSG_ERROR([--enable-dbus was given, but the D-Bus library doesn't define dbus_connection_read_write()])\n\t\t\tfi\n\t\t     ])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\t    ],\n\t    [\n\t\tif test \"x$enable_dbus\" = \"xyes\"; then\n\t\t\tAC_MSG_ERROR([--enable-dbus was given, but the dbus-1 package is not installed])\n\t\tfi\n\t    ])\n\tAC_SUBST(PCAP_SUPPORT_DBUS)\nfi\n\nAC_ARG_ENABLE([rdma],\n[AS_HELP_STRING([--enable-rdma],[enable RDMA capture support @<:@default=yes, if support available@:>@])],\n    [],\n    [enable_rdma=ifavailable])\n\nif test \"$xxx_only\" = yes; then\n\t# User requested something-else-only pcap, so they don't\n\t# want RDMA support.\n\tenable_rdma=no\nfi\n\nif test \"x$enable_rdma\" != \"xno\"; then\n\tPKG_CHECK_MODULE(LIBIBVERBS, libibverbs,\n\t    [\n\t\tfound_libibverbs=yes\n\t\tLIBIBVERBS_REQUIRES_PRIVATE=\"libibverbs\"\n\t    ])\n\n\tif test \"x$found_libibverbs\" != \"xyes\"; then\n\t\tAC_CHECK_LIB(ibverbs, ibv_get_device_list,\n\t\t    [\n\t\t\tfound_libibverbs=yes\n\t\t\tLIBIBVERBS_CFLAGS=\"\"\n\t\t\tLIBIBVERBS_LIBS=\"-libverbs\"\n\t\t\t# XXX - at least on Ubuntu 20.04, there are many more\n\t\t\t# libraries needed; is there any platform where\n\t\t\t# libibverbs is available but where pkg-config isn't\n\t\t\t# available or libibverbs doesn't use it?  If not,\n\t\t\t# we should only use pkg-config for it.\n\t\t\tLIBIBVERBS_LIBS_STATIC=\"-libverbs\"\n\t\t\tLIBIBVERBS_LIBS_PRIVATE=\"-libverbs\"\n\t\t    ]\n\t\t)\n\tfi\n\n\tif test \"x$found_libibverbs\" = \"xyes\"; then\n\t\tAC_LBL_SAVE_CHECK_STATE\n\t\tCFLAGS=\"$CFLAGS $LIBIBVERBS_CFLAGS\"\n\t\tLIBS=\"$LIBS $LIBIBVERBS_LIBS\"\n\t\tAC_CHECK_HEADER(infiniband/verbs.h, [\n\t\t\t#\n\t\t\t# ibv_create_flow may be defined as a static inline\n\t\t\t# function in infiniband/verbs.h, so we can't\n\t\t\t# use AC_CHECK_LIB.\n\t\t\t#\n\t\t\t# Too bad autoconf has no AC_SYMBOL_EXISTS()\n\t\t\t# macro that works like CMake's check_symbol_exists()\n\t\t\t# function, to check do a compile check like\n\t\t\t# this (they do a clever trick to avoid having\n\t\t\t# to know the function's signature).\n\t\t\t#\n\t\t\tAC_MSG_CHECKING(whether libibverbs defines ibv_create_flow)\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t\t\t[[\n\t\t\t\t\t#include <infiniband/verbs.h>\n\t\t\t\t]],\n\t\t\t\t[[\n\t\t\t\t\t(void) ibv_create_flow((struct ibv_qp *) NULL,\n\t\t\t\t\t\t\t       (struct ibv_flow_attr *) NULL);\n\t\t\t\t]])],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\t\tfound_usable_libibverbs=yes\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([no])\n\t\t\t\t]\n\t\t\t)\n\t\t])\n\t\tAC_LBL_RESTORE_CHECK_STATE\n\tfi\n\n\tif test \"x$found_usable_libibverbs\" = \"xyes\"\n\tthen\n\t\tAC_DEFINE(PCAP_SUPPORT_RDMASNIFF, 1, [target host supports RDMA sniffing])\n\t\tMODULE_C_SRC=\"$MODULE_C_SRC pcap-rdmasniff.c\"\n\t\tCFLAGS=\"$LIBIBVERBS_CFLAGS $CFLAGS\"\n\t\tADDITIONAL_LIBS=\"$LIBIBVERBS_LIBS $ADDITIONAL_LIBS\"\n\t\tADDITIONAL_LIBS_STATIC=\"$LIBIBVERBS_LIBS_STATIC $ADDITIONAL_LIBS_STATIC\"\n\t\tLIBS_PRIVATE=\"$LIBIBVERBS_LIBS_PRIVATE $LIBS_PRIVATE\"\n\t\tREQUIRES_PRIVATE=\"$REQUIRES_PRIVATE $LIBIBVERBS_REQUIRES_PRIVATE\"\n\tfi\n\tAC_SUBST(PCAP_SUPPORT_RDMASNIFF)\nfi\n\n#\n# If this is a platform where we need to have the .pc file and\n# pcap-config script supply an rpath option to specify the directory\n# in which the libpcap shared library is installed, and the install\n# prefix /usr (meaning we're not installing a system library), provide\n# the rpath option.\n#\n# (We must check $prefix, as $libdir isn't necessarily /usr/lib in this\n# case - for example, Linux distributions for 64-bit platforms that\n# also provide support for binaries for a 32-bit version of the\n# platform may put the 64-bit libraries, the 32-bit libraries, or both\n# in directories other than /usr/lib.)\n#\n# In AIX, do we have to do this?\n#\n# In Darwin-based OSes, the full paths of the shared libraries with\n# which the program was linked are stored in the executable, so we don't\n# need to provide an rpath option.\n#\n# With the HP-UX linker, directories specified with -L are, by default,\n# added to the run-time search path, so we don't need to supply them.\n#\n# This must *not* depend on the compiler, as, on platforms where there's\n# a GCC-compatible compiler and a vendor compiler, we need to work with\n# both.\n#\nif test \"$prefix\" != \"/usr\"; then\n\tcase \"$host_os\" in\n\n\tfreebsd*|netbsd*|openbsd*|dragonfly*|linux*|haiku*|midipix*|gnu*)\n\t\t#\n\t\t# Platforms where the \"native\" C compiler is GCC or\n\t\t# accepts compatible command-line arguments, and the\n\t\t# \"native\" linker is the GNU linker or accepts\n\t\t# compatible command-line arguments.\n\t\t#\n\t\tRPATH=\"-Wl,-rpath,\\${libdir}\"\n\t\t;;\n\n\tsolaris*)\n\t\t#\n\t\t# Sun/Oracle's linker, the GNU linker, and\n\t\t# GNU-compatible linkers all support -R.\n\t\t#\n\t\tRPATH=\"-Wl,-R,\\${libdir}\"\n\t\t;;\n\tesac\nfi\n\nAC_PROG_INSTALL\n\nAC_CONFIG_HEADERS([config.h])\n\nAC_SUBST(V_SHLIB_CCOPT)\nAC_SUBST(V_SHLIB_CMD)\nAC_SUBST(V_SHLIB_OPT)\nAC_SUBST(V_SONAME_OPT)\nAC_SUBST(RPATH)\nAC_SUBST(ADDLOBJS)\nAC_SUBST(ADDLARCHIVEOBJS)\nAC_SUBST(PLATFORM_C_SRC)\nAC_SUBST(MODULE_C_SRC)\nAC_SUBST(REMOTE_C_SRC)\nAC_SUBST(PTHREAD_LIBS)\nAC_SUBST(BUILD_RPCAPD)\nAC_SUBST(INSTALL_RPCAPD)\nAC_SUBST(RPCAPD_LIBS)\n\n#\n# We're done with configuration operations; add ADDITIONAL_LIBS and\n# ADDITIONAL_LIBS_STATIC to LIBS and LIBS_STATIC, respectively.\n#\nLIBS=\"$ADDITIONAL_LIBS $LIBS\"\nLIBS_STATIC=\"$ADDITIONAL_LIBS_STATIC $LIBS_STATIC\"\n\nAC_CONFIG_COMMANDS([.devel],[[if test -f .devel; then\n\techo timestamp > stamp-h\n\tcat $srcdir/Makefile-devel-adds >> Makefile\n\tmake depend || exit 1\nfi]])\nAC_CONFIG_FILES([Makefile grammar.y pcap-filter.manmisc pcap-linktype.manmisc\n\tpcap-tstamp.manmisc cbpf-savefile.manfile pcap-savefile.manfile pcap.3pcap\n\tpcap_compile.3pcap pcap_datalink.3pcap pcap_dump_open.3pcap\n\tpcap_get_tstamp_precision.3pcap pcap_list_datalinks.3pcap\n\tpcap_list_tstamp_types.3pcap pcap_open_dead.3pcap\n\tpcap_open_offline.3pcap pcap_set_immediate_mode.3pcap\n\tpcap_set_tstamp_precision.3pcap pcap_set_tstamp_type.3pcap\n\trpcapd/Makefile rpcapd/rpcapd.manadmin rpcapd/rpcapd-config.manfile\n\ttestprogs/Makefile])\nAC_OUTPUT\nexit 0\n"
        },
        {
          "name": "diag-control.h",
          "type": "blob",
          "size": 14.259765625,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef _diag_control_h\n#define _diag_control_h\n\n#include \"pcap/compiler-tests.h\"\n\n#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8) || \\\n    PCAP_IS_AT_LEAST_GNUC_VERSION(4,6) || \\\n    PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)\n  /*\n   * All these compilers support this way of putting pragmas into #defines.\n   * We use it only if we have a compiler that supports it; see below\n   * for the code that uses it and the #defines that control whether\n   * that code is used.\n   */\n  #define PCAP_DO_PRAGMA(x) _Pragma (#x)\n#endif\n\n/*\n * Suppress \"enum value not explicitly handled in switch\" warnings.\n * We may have to build on multiple different Windows SDKs, so we\n * may not be able to include all enum values in a switch, as they\n * won't necessarily be defined on all the SDKs, and, unlike\n * #defines, there's no easy way to test whether a given enum has\n * a given value.  It *could* be done by the configure script or\n * CMake tests.\n */\n#if defined(_MSC_VER)\n  #define DIAG_OFF_ENUM_SWITCH \\\n    __pragma(warning(push)) \\\n    __pragma(warning(disable:4061))\n  #define DIAG_ON_ENUM_SWITCH \\\n    __pragma(warning(pop))\n#endif\n\n/*\n * Suppress \"switch statement has only a default case\" warnings.\n * There's a switch in bpf_filter.c that only has additional\n * cases on Linux.\n */\n#if defined(_MSC_VER)\n  #define DIAG_OFF_DEFAULT_ONLY_SWITCH \\\n    __pragma(warning(push)) \\\n    __pragma(warning(disable:4065))\n  #define DIAG_ON_DEFAULT_ONLY_SWITCH \\\n    __pragma(warning(pop))\n#endif\n\n/*\n * Suppress Flex, narrowing, and deprecation warnings.\n */\n#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8)\n  /*\n   * This is Clang 2.8 or later; we can use \"clang diagnostic\n   * ignored -Wxxx\" and \"clang diagnostic push/pop\".\n   *\n   * Suppress -Wdocumentation warnings; GCC doesn't support -Wdocumentation,\n   * at least according to the GCC 7.3 documentation.  Apparently, Flex\n   * generates code that upsets at least some versions of Clang's\n   * -Wdocumentation.\n   *\n   * (This could be clang-cl, which defines _MSC_VER, so test this\n   * before testing _MSC_VER.)\n   */\n  #define DIAG_OFF_FLEX \\\n    PCAP_DO_PRAGMA(clang diagnostic push) \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wsign-compare\") \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wdocumentation\") \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wshorten-64-to-32\") \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wmissing-noreturn\") \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wunused-parameter\") \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wunreachable-code\")\n  #define DIAG_ON_FLEX \\\n    PCAP_DO_PRAGMA(clang diagnostic pop)\n\n  /*\n   * Suppress the only narrowing warnings you get from Clang.\n   */\n  #define DIAG_OFF_NARROWING \\\n    PCAP_DO_PRAGMA(clang diagnostic push) \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wshorten-64-to-32\")\n\n  #define DIAG_ON_NARROWING \\\n    PCAP_DO_PRAGMA(clang diagnostic pop)\n\n  /*\n   * Suppress deprecation warnings.\n   */\n  #define DIAG_OFF_DEPRECATION \\\n    PCAP_DO_PRAGMA(clang diagnostic push) \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wdeprecated-declarations\")\n  #define DIAG_ON_DEPRECATION \\\n    PCAP_DO_PRAGMA(clang diagnostic pop)\n\n  /*\n   * When Clang correctly detects an old-style function prototype after\n   * preprocessing, the warning can be irrelevant to this source tree because\n   * the prototype comes from a system header macro.\n   */\n  #if PCAP_IS_AT_LEAST_CLANG_VERSION(5,0)\n    #define DIAG_OFF_STRICT_PROTOTYPES \\\n      PCAP_DO_PRAGMA(clang diagnostic push) \\\n      PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wstrict-prototypes\")\n    #define DIAG_ON_STRICT_PROTOTYPES \\\n      PCAP_DO_PRAGMA(clang diagnostic pop)\n  #endif\n\n  #define DIAG_OFF_DOCUMENTATION \\\n    PCAP_DO_PRAGMA(clang diagnostic push) \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wdocumentation\")\n  #define DIAG_ON_DOCUMENTATION \\\n    PCAP_DO_PRAGMA(clang diagnostic pop)\n\n  #define DIAG_OFF_SIGN_COMPARE \\\n    PCAP_DO_PRAGMA(clang diagnostic push) \\\n    PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wsign-compare\")\n  #define DIAG_ON_SIGN_COMPARE \\\n    PCAP_DO_PRAGMA(clang diagnostic pop)\n#elif defined(_MSC_VER)\n  /*\n   * This is Microsoft Visual Studio; we can use __pragma(warning(disable:XXXX))\n   * and __pragma(warning(push/pop)).\n   *\n   * Suppress signed-vs-unsigned comparison, narrowing, and unreachable\n   * code warnings.\n   */\n  #define DIAG_OFF_FLEX \\\n    __pragma(warning(push)) \\\n    __pragma(warning(disable:4127)) \\\n    __pragma(warning(disable:4242)) \\\n    __pragma(warning(disable:4244)) \\\n    __pragma(warning(disable:4702))\n  #define DIAG_ON_FLEX \\\n    __pragma(warning(pop))\n\n  /*\n   * Suppress narrowing warnings.\n   */\n  #define DIAG_OFF_NARROWING \\\n    __pragma(warning(push)) \\\n    __pragma(warning(disable:4242)) \\\n    __pragma(warning(disable:4311))\n  #define DIAG_ON_NARROWING \\\n    __pragma(warning(pop))\n\n  /*\n   * Suppress deprecation warnings.\n   */\n  #define DIAG_OFF_DEPRECATION \\\n    __pragma(warning(push)) \\\n    __pragma(warning(disable:4996))\n  #define DIAG_ON_DEPRECATION \\\n    __pragma(warning(pop))\n#elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,6)\n  /*\n   * This is GCC 4.6 or later, or a compiler claiming to be that.\n   * We can use \"GCC diagnostic ignored -Wxxx\" (introduced in 4.2)\n   * and \"GCC diagnostic push/pop\" (introduced in 4.6).\n   */\n  #define DIAG_OFF_FLEX \\\n    PCAP_DO_PRAGMA(GCC diagnostic push) \\\n    PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wsign-compare\") \\\n    PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wunused-parameter\") \\\n    PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wunreachable-code\")\n  #define DIAG_ON_FLEX \\\n    PCAP_DO_PRAGMA(GCC diagnostic pop)\n\n  /*\n   * GCC currently doesn't issue any narrowing warnings.\n   */\n\n  /*\n   * Suppress deprecation warnings.\n   */\n  #define DIAG_OFF_DEPRECATION \\\n    PCAP_DO_PRAGMA(GCC diagnostic push) \\\n    PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wdeprecated-declarations\")\n  #define DIAG_ON_DEPRECATION \\\n    PCAP_DO_PRAGMA(GCC diagnostic pop)\n\n  /*\n   * Suppress format-truncation= warnings.\n   * GCC 7.1 had introduced this warning option. Earlier versions (at least\n   * one particular copy of GCC 4.6.4) treat the request as a warning.\n   */\n  #if PCAP_IS_AT_LEAST_GNUC_VERSION(7,1)\n    #define DIAG_OFF_FORMAT_TRUNCATION \\\n      PCAP_DO_PRAGMA(GCC diagnostic push) \\\n      PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wformat-truncation=\")\n    #define DIAG_ON_FORMAT_TRUNCATION \\\n      PCAP_DO_PRAGMA(GCC diagnostic pop)\n  #endif\n#elif PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)\n  /*\n   * Sun C compiler version 5.5 (Studio version 8) and later supports \"#pragma\n   * error_messages()\".\n   */\n  #define DIAG_OFF_FLEX \\\n    PCAP_DO_PRAGMA(error_messages(off,E_STATEMENT_NOT_REACHED))\n  #define DIAG_ON_FLEX \\\n    PCAP_DO_PRAGMA(error_messages(default,E_STATEMENT_NOT_REACHED))\n#endif\n\n#ifdef YYBYACC\n  /*\n   * Berkeley YACC.\n   *\n   * It generates a global declaration of yylval, or the appropriately\n   * prefixed version of yylval, in grammar.h, *even though it's been\n   * told to generate a pure parser, meaning it doesn't have any global\n   * variables*.  Bison doesn't do this.\n   *\n   * That causes a warning due to the local declaration in the parser\n   * shadowing the global declaration.\n   *\n   * So, if the compiler warns about that, we turn off -Wshadow warnings.\n   *\n   * In addition, the generated code may have functions with unreachable\n   * code, so suppress warnings about those.\n   */\n  #if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8)\n    /*\n     * This is Clang 2.8 or later (including clang-cl, so test this\n     * before _MSC_VER); we can use \"clang diagnostic ignored -Wxxx\".\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wshadow\") \\\n      PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wunreachable-code\")\n  #elif defined(_MSC_VER)\n    /*\n     * This is Microsoft Visual Studio; we can use\n     * __pragma(warning(disable:XXXX)).\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      __pragma(warning(disable:4702))\n  #elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,6)\n    /*\n     * This is GCC 4.6 or later, or a compiler claiming to be that.\n     * We can use \"GCC diagnostic ignored -Wxxx\" (introduced in 4.2,\n     * but it may not actually work very well prior to 4.6).\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wshadow\") \\\n      PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wunreachable-code\")\n  #endif\n#else\n  /*\n   * Bison.\n   *\n   * The generated code may have functions with unreachable code and\n   * switches with only a default case, so suppress warnings about those.\n   */\n  #if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8)\n    /*\n     * This is Clang 2.8 or later (including clang-cl, so test this\n     * before _MSC_VER); we can use \"clang diagnostic ignored -Wxxx\".\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      PCAP_DO_PRAGMA(clang diagnostic ignored \"-Wunreachable-code\")\n  #elif defined(_MSC_VER)\n    /*\n     * This is Microsoft Visual Studio; we can use\n     * __pragma(warning(disable:XXXX)).\n     *\n     * Suppress some /Wall warnings.\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      __pragma(warning(disable:4065)) \\\n      __pragma(warning(disable:4127)) \\\n      __pragma(warning(disable:4242)) \\\n      __pragma(warning(disable:4244)) \\\n      __pragma(warning(disable:4702))\n  #elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,6)\n    /*\n     * This is GCC 4.6 or later, or a compiler claiming to be that.\n     * We can use \"GCC diagnostic ignored -Wxxx\" (introduced in 4.2,\n     * but it may not actually work very well prior to 4.6).\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wunreachable-code\")\n  #elif PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)\n    /*\n     * Same as for DIAG_OFF_FLEX above.\n     */\n    #define DIAG_OFF_BISON_BYACC \\\n      PCAP_DO_PRAGMA(error_messages(off,E_STATEMENT_NOT_REACHED))\n  #endif\n#endif\n\n#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8)\n  /*\n   * Clang appears to let you ignore a result without a warning by\n   * casting the function result to void, so we don't appear to\n   * need this for Clang.\n   */\n#elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,5)\n  /*\n   * GCC warns about unused return values if a function is marked as\n   * \"warn about ignoring this function's return value\".\n   */\n  #define DIAG_OFF_WARN_UNUSED_RESULT \\\n    PCAP_DO_PRAGMA(GCC diagnostic push) \\\n    PCAP_DO_PRAGMA(GCC diagnostic ignored \"-Wunused-result\")\n  #define DIAG_ON_WARN_UNUSED_RESULT \\\n    PCAP_DO_PRAGMA(GCC diagnostic pop)\n\n  /*\n   * GCC does not currently generate any -Wstrict-prototypes warnings that\n   * would need silencing as is done for Clang above.\n   */\n#endif\n\n/*\n * GCC needs this on AIX for longjmp().\n */\n#if PCAP_IS_AT_LEAST_GNUC_VERSION(5,1)\n  /*\n   * Beware that the effect of this builtin is more than just squelching the\n   * warning! GCC trusts it enough for the process to segfault if the control\n   * flow reaches the builtin (an infinite empty loop in the same context would\n   * squelch the warning and ruin the process too, albeit in a different way).\n   * So please remember to use this very carefully.\n   */\n  #define PCAP_UNREACHABLE __builtin_unreachable();\n#endif\n\n#ifndef DIAG_OFF_ENUM_SWITCH\n#define DIAG_OFF_ENUM_SWITCH\n#endif\n#ifndef DIAG_ON_ENUM_SWITCH\n#define DIAG_ON_ENUM_SWITCH\n#endif\n#ifndef DIAG_OFF_DEFAULT_ONLY_SWITCH\n#define DIAG_OFF_DEFAULT_ONLY_SWITCH\n#endif\n#ifndef DIAG_ON_DEFAULT_ONLY_SWITCH\n#define DIAG_ON_DEFAULT_ONLY_SWITCH\n#endif\n#ifndef DIAG_OFF_FLEX\n#define DIAG_OFF_FLEX\n#endif\n#ifndef DIAG_ON_FLEX\n#define DIAG_ON_FLEX\n#endif\n#ifndef DIAG_OFF_NARROWING\n#define DIAG_OFF_NARROWING\n#endif\n#ifndef DIAG_ON_NARROWING\n#define DIAG_ON_NARROWING\n#endif\n#ifndef DIAG_OFF_DEPRECATION\n#define DIAG_OFF_DEPRECATION\n#endif\n#ifndef DIAG_ON_DEPRECATION\n#define DIAG_ON_DEPRECATION\n#endif\n#ifndef DIAG_OFF_FORMAT_TRUNCATION\n#define DIAG_OFF_FORMAT_TRUNCATION\n#endif\n#ifndef DIAG_ON_FORMAT_TRUNCATION\n#define DIAG_ON_FORMAT_TRUNCATION\n#endif\n#ifndef DIAG_OFF_BISON_BYACC\n#define DIAG_OFF_BISON_BYACC\n#endif\n//\n// DIAG_ON_BISON_BYACC does not need to be defined.\n//\n#ifndef DIAG_OFF_WARN_UNUSED_RESULT\n#define DIAG_OFF_WARN_UNUSED_RESULT\n#endif\n#ifndef DIAG_ON_WARN_UNUSED_RESULT\n#define DIAG_ON_WARN_UNUSED_RESULT\n#endif\n#ifndef DIAG_OFF_STRICT_PROTOTYPES\n#define DIAG_OFF_STRICT_PROTOTYPES\n#endif\n#ifndef DIAG_ON_STRICT_PROTOTYPES\n#define DIAG_ON_STRICT_PROTOTYPES\n#endif\n#ifndef DIAG_OFF_DOCUMENTATION\n#define DIAG_OFF_DOCUMENTATION\n#endif\n#ifndef DIAG_ON_DOCUMENTATION\n#define DIAG_ON_DOCUMENTATION\n#endif\n#ifndef DIAG_OFF_SIGN_COMPARE\n#define DIAG_OFF_SIGN_COMPARE\n#endif\n#ifndef DIAG_ON_SIGN_COMPARE\n#define DIAG_ON_SIGN_COMPARE\n#endif\n#ifndef PCAP_UNREACHABLE\n#define PCAP_UNREACHABLE\n#endif\n\n#endif /* _diag_control_h */\n"
        },
        {
          "name": "dlpisubs.c",
          "type": "blob",
          "size": 10.1826171875,
          "content": "/*\n * This code is derived from code formerly in pcap-dlpi.c, originally\n * contributed by Atanu Ghosh (atanu@cs.ucl.ac.uk), University College\n * London, and subsequently modified by Guy Harris (guy@alum.mit.edu),\n * Mark Pizzolato <List-tcpdump-workers@subscriptions.pizzolato.net>,\n * Mark C. Brown (mbrown@hp.com), and Sagun Shakya <Sagun.Shakya@Sun.COM>.\n */\n\n/*\n * This file contains dlpi/libdlpi related common functions used\n * by pcap-[dlpi,libdlpi].c.\n */\n\n#include <config.h>\n\n#ifndef DL_IPATM\n#define DL_IPATM\t0x12\t/* ATM Classical IP interface */\n#endif\n\n#ifdef HAVE_SYS_BUFMOD_H\n\t/*\n\t * Size of a bufmod chunk to pass upstream; that appears to be the\n\t * biggest value to which you can set it, and setting it to that value\n\t * (which is bigger than what appears to be the Solaris default of 8192)\n\t * reduces the number of packet drops.\n\t */\n#define\tCHUNKSIZE\t65536\n\n\t/*\n\t * Size of the buffer to allocate for packet data we read; it must be\n\t * large enough to hold a chunk.\n\t */\n#define\tPKTBUFSIZE\tCHUNKSIZE\n\n#else /* HAVE_SYS_BUFMOD_H */\n\n\t/*\n\t * Size of the buffer to allocate for packet data we read; this is\n\t * what the value used to be - there's no particular reason why it\n\t * should be tied to MAXDLBUF, but we'll leave it as this for now.\n\t */\n#define\tMAXDLBUF\t8192\n#define\tPKTBUFSIZE\t(MAXDLBUF * sizeof(bpf_u_int32))\n\n#endif\n\n#include <sys/types.h>\n#include <sys/time.h>\n#ifdef HAVE_SYS_BUFMOD_H\n#include <sys/bufmod.h>\n#endif\n#include <sys/dlpi.h>\n#include <sys/stream.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stropts.h>\n#include <unistd.h>\n\n#ifdef HAVE_LIBDLPI\n#include <libdlpi.h>\n#endif\n\n#include \"pcap-int.h\"\n#include \"dlpisubs.h\"\n\n#ifdef HAVE_SYS_BUFMOD_H\nstatic void pcap_stream_err(const char *, int, char *);\n#endif\n\n/*\n * Get the packet statistics.\n */\nint\npcap_stats_dlpi(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  As filtering is done in userland,\n\t * this would not include packets dropped because we ran out\n\t * of buffer space; in order to make this more like other\n\t * platforms (Linux 2.4 and later, BSDs with BPF), where the\n\t * \"packets received\" count includes packets received but dropped\n\t * due to running out of buffer space, and to keep from confusing\n\t * applications that, for example, compute packet drop percentages,\n\t * we also make it count packets dropped by \"bufmod\" (otherwise we\n\t * might run the risk of the packet drop count being bigger than\n\t * the received-packet count).\n\t *\n\t * \"ps_drop\" counts packets dropped by \"bufmod\" because of\n\t * flow control requirements or resource exhaustion; it doesn't\n\t * count packets dropped by the interface driver, or packets\n\t * dropped upstream.  As filtering is done in userland, it counts\n\t * packets regardless of whether they would've passed the filter.\n\t *\n\t * These statistics don't include packets not yet read from\n\t * the kernel by libpcap, but they may include packets not\n\t * yet read from libpcap by the application.\n\t */\n\t*ps = pd->stat;\n\n\t/*\n\t * Add in the drop count, as per the above comment.\n\t */\n\tps->ps_recv += ps->ps_drop;\n\treturn (0);\n}\n\n/*\n * Does the processor for which we're compiling this support aligned loads?\n */\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__arm__) || defined(_M_ARM) || defined(__aarch64__)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__))\n    /* Yes, it does. */\n#else\n    /* No, it doesn't. */\n    #define REQUIRE_ALIGNMENT\n#endif\n\n/*\n * Loop through the packets and call the callback for each packet.\n * Return the number of packets read.\n */\nint\npcap_process_pkts(pcap_t *p, pcap_handler callback, u_char *user,\n\tint count, u_char *bufp, int len)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint n, caplen, origlen;\n\tu_char *ep, *pk;\n\tstruct pcap_pkthdr pkthdr;\n#ifdef HAVE_SYS_BUFMOD_H\n\tstruct sb_hdr *sbp;\n#ifdef REQUIRE_ALIGNMENT\n\tstruct sb_hdr sbhdr;\n#endif\n#endif\n\n\t/*\n\t * Loop through packets.\n\t *\n\t * This assumes that a single buffer of packets will have\n\t * <= INT_MAX packets, so the packet count doesn't overflow.\n\t */\n\tep = bufp + len;\n\tn = 0;\n\n#ifdef HAVE_SYS_BUFMOD_H\n\twhile (bufp < ep) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else {\n\t\t\t\tp->bp = bufp;\n\t\t\t\tp->cc = ep - bufp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n#ifdef REQUIRE_ALIGNMENT\n\t\tif ((long)bufp & 3) {\n\t\t\tsbp = &sbhdr;\n\t\t\tmemcpy(sbp, bufp, sizeof(*sbp));\n\t\t} else\n#endif\n\t\t\tsbp = (struct sb_hdr *)bufp;\n\t\tpd->stat.ps_drop = sbp->sbh_drops;\n\t\tpk = bufp + sizeof(*sbp);\n\t\tbufp += sbp->sbh_totlen;\n\t\toriglen = sbp->sbh_origlen;\n\t\tcaplen = sbp->sbh_msglen;\n#else\n\t\toriglen = len;\n\t\tcaplen = min(p->snapshot, len);\n\t\tpk = bufp;\n\t\tbufp += caplen;\n#endif\n\t\t++pd->stat.ps_recv;\n\t\tif (pcapint_filter(p->fcode.bf_insns, pk, origlen, caplen)) {\n#ifdef HAVE_SYS_BUFMOD_H\n\t\t\tpkthdr.ts.tv_sec = sbp->sbh_timestamp.tv_sec;\n\t\t\tpkthdr.ts.tv_usec = sbp->sbh_timestamp.tv_usec;\n#else\n\t\t\t(void) gettimeofday(&pkthdr.ts, NULL);\n#endif\n\t\t\tpkthdr.len = origlen;\n\t\t\tpkthdr.caplen = caplen;\n\t\t\t/* Insure caplen does not exceed snapshot */\n\t\t\tif (pkthdr.caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\tpkthdr.caplen = (bpf_u_int32)p->snapshot;\n\t\t\t(*callback)(user, &pkthdr, pk);\n\t\t\tif (++n >= count && !PACKET_COUNT_IS_UNLIMITED(count)) {\n\t\t\t\tp->cc = ep - bufp;\n\t\t\t\tp->bp = bufp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n#ifdef HAVE_SYS_BUFMOD_H\n\t}\n#endif\n\tp->cc = 0;\n\treturn (n);\n}\n\n/*\n * Process the mac type. Returns -1 if no matching mac type found, otherwise 0.\n */\nint\npcap_process_mactype(pcap_t *p, u_int mactype)\n{\n\tint retv = 0;\n\n\tswitch (mactype) {\n\n\tcase DL_CSMACD:\n\tcase DL_ETHER:\n\t\tp->linktype = DLT_EN10MB;\n\t\tp->offset = 2;\n\t\t/*\n\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t */\n\t\tp->dlt_list = (u_int *)malloc(sizeof(u_int) * 2);\n\t\tif (p->dlt_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\tp->dlt_count = 2;\n\t\tbreak;\n\n\tcase DL_FDDI:\n\t\tp->linktype = DLT_FDDI;\n\t\tp->offset = 3;\n\t\tbreak;\n\n\tcase DL_TPR:\n\t\t/* XXX - what about DL_TPB?  Is that Token Bus?  */\n\t\tp->linktype = DLT_IEEE802;\n\t\tp->offset = 2;\n\t\tbreak;\n\n#ifdef HAVE_SOLARIS\n\tcase DL_IPATM:\n\t\tp->linktype = DLT_SUNATM;\n\t\tp->offset = 0;  /* works for LANE and LLC encapsulation */\n\t\tbreak;\n#endif\n\n#ifdef DL_IPV4\n\tcase DL_IPV4:\n\t\tp->linktype = DLT_IPV4;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n#ifdef DL_IPV6\n\tcase DL_IPV6:\n\t\tp->linktype = DLT_IPV6;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n#ifdef DL_IPNET\n\tcase DL_IPNET:\n\t\t/*\n\t\t * XXX - DL_IPNET devices default to \"raw IP\" rather than\n\t\t * \"IPNET header\"; see\n\t\t *\n\t\t *    https://seclists.org/tcpdump/2009/q1/202\n\t\t *\n\t\t * We'd have to do DL_IOC_IPNET_INFO to enable getting\n\t\t * the IPNET header.\n\t\t */\n\t\tp->linktype = DLT_RAW;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"unknown mactype 0x%x\",\n\t\t    mactype);\n\t\tretv = -1;\n\t}\n\n\treturn (retv);\n}\n\n#ifdef HAVE_SYS_BUFMOD_H\n/*\n * Push and configure the buffer module. Returns -1 for error, otherwise 0.\n */\nint\npcap_conf_bufmod(pcap_t *p, int snaplen)\n{\n\tstruct timeval to;\n\tbpf_u_int32 ss, chunksize;\n\n\t/* Non-standard call to get the data nicely buffered. */\n\tif (ioctl(p->fd, I_PUSH, \"bufmod\") != 0) {\n\t\tpcap_stream_err(\"I_PUSH bufmod\", errno, p->errbuf);\n\t\treturn (-1);\n\t}\n\n\tss = snaplen;\n\tif (ss > 0 &&\n\t    strioctl(p->fd, SBIOCSSNAP, sizeof(ss), (char *)&ss) != 0) {\n\t\tpcap_stream_err(\"SBIOCSSNAP\", errno, p->errbuf);\n\t\treturn (-1);\n\t}\n\n\tif (p->opt.immediate) {\n\t\t/* Set the timeout to zero, for immediate delivery. */\n\t\tto.tv_sec = 0;\n\t\tto.tv_usec = 0;\n\t\tif (strioctl(p->fd, SBIOCSTIME, sizeof(to), (char *)&to) != 0) {\n\t\t\tpcap_stream_err(\"SBIOCSTIME\", errno, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/* Set up the bufmod timeout. */\n\t\tif (p->opt.timeout != 0) {\n\t\t\tto.tv_sec = p->opt.timeout / 1000;\n\t\t\tto.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\t\tif (strioctl(p->fd, SBIOCSTIME, sizeof(to), (char *)&to) != 0) {\n\t\t\t\tpcap_stream_err(\"SBIOCSTIME\", errno, p->errbuf);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\n\t\t/* Set the chunk length. */\n\t\tchunksize = CHUNKSIZE;\n\t\tif (strioctl(p->fd, SBIOCSCHUNK, sizeof(chunksize), (char *)&chunksize)\n\t\t    != 0) {\n\t\t\tpcap_stream_err(\"SBIOCSCHUNKP\", errno, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n#endif /* HAVE_SYS_BUFMOD_H */\n\n/*\n * Allocate data buffer. Returns -1 if memory allocation fails, else 0.\n */\nint\npcap_alloc_databuf(pcap_t *p)\n{\n\tp->bufsize = PKTBUFSIZE;\n\tp->buffer = malloc(p->bufsize + p->offset);\n\tif (p->buffer == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n/*\n * Issue a STREAMS I_STR ioctl. Returns -1 on error, otherwise\n * length of returned data on success.\n */\nint\nstrioctl(int fd, int cmd, int len, char *dp)\n{\n\tstruct strioctl str;\n\tint retv;\n\n\tstr.ic_cmd = cmd;\n\tstr.ic_timout = -1;\n\tstr.ic_len = len;\n\tstr.ic_dp = dp;\n\tif ((retv = ioctl(fd, I_STR, &str)) < 0)\n\t\treturn (retv);\n\n\treturn (str.ic_len);\n}\n\n#ifdef HAVE_SYS_BUFMOD_H\n/*\n * Write stream error message to errbuf.\n */\nstatic void\npcap_stream_err(const char *func, int err, char *errbuf)\n{\n\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, err, \"%s\", func);\n}\n#endif\n"
        },
        {
          "name": "dlpisubs.h",
          "type": "blob",
          "size": 0.685546875,
          "content": "#ifndef dlpisubs_h\n#define\tdlpisubs_h\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Private data for capturing on DLPI devices.\n */\nstruct pcap_dlpi {\n#ifdef HAVE_LIBDLPI\n\tdlpi_handle_t dlpi_hd;\n#endif /* HAVE_LIBDLPI */\n#ifdef DL_HP_RAWDLS\n\tint send_fd;\n#endif /* DL_HP_RAWDLS */\n\n\tstruct pcap_stat stat;\n};\n\n/*\n * Functions defined by dlpisubs.c.\n */\nint pcap_stats_dlpi(pcap_t *, struct pcap_stat *);\nint pcap_process_pkts(pcap_t *, pcap_handler, u_char *, int, u_char *, int);\nint pcap_process_mactype(pcap_t *, u_int);\n#ifdef HAVE_SYS_BUFMOD_H\nint pcap_conf_bufmod(pcap_t *, int);\n#endif\nint pcap_alloc_databuf(pcap_t *);\nint strioctl(int, int, int, char *);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "etherent.c",
          "type": "blob",
          "size": 3.6806640625,
          "content": "/*\n * Copyright (c) 1990, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n\n#include <memory.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n\n#include <pcap/namedb.h>\n\n#include \"thread-local.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\nstatic inline int skip_space(FILE *);\nstatic inline int skip_line(FILE *);\n\n/* Hex digit to integer. */\nstatic inline u_char\nxdtoi(u_char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn (u_char)(c - '0');\n\telse if (c >= 'a' && c <= 'f')\n\t\treturn (u_char)(c - 'a' + 10);\n\telse\n\t\treturn (u_char)(c - 'A' + 10);\n}\n\n/*\n * Skip linear white space (space and tab) and any CRs before LF.\n * Stop when we hit a non-white-space character or an end-of-line LF.\n */\nstatic inline int\nskip_space(FILE *f)\n{\n\tint c;\n\n\tdo {\n\t\tc = getc(f);\n\t} while (c == ' ' || c == '\\t' || c == '\\r');\n\n\treturn c;\n}\n\nstatic inline int\nskip_line(FILE *f)\n{\n\tint c;\n\n\tdo\n\t\tc = getc(f);\n\twhile (c != '\\n' && c != EOF);\n\n\treturn c;\n}\n\nstruct pcap_etherent *\npcap_next_etherent(FILE *fp)\n{\n\tregister int c, i;\n\tu_char d;\n\tchar *bp;\n\tsize_t namesize;\n\tstatic thread_local struct pcap_etherent e;\n\n\tmemset((char *)&e, 0, sizeof(e));\n\tfor (;;) {\n\t\t/* Find addr */\n\t\tc = skip_space(fp);\n\t\tif (c == EOF)\n\t\t\treturn (NULL);\n\t\tif (c == '\\n')\n\t\t\tcontinue;\n\n\t\t/* If this is a comment, or first thing on line\n\t\t   cannot be Ethernet address, skip the line. */\n\t\tif (!PCAP_ISXDIGIT(c)) {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be the start of an address */\n\t\tfor (i = 0; i < 6; i += 1) {\n\t\t\td = xdtoi((u_char)c);\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tif (PCAP_ISXDIGIT(c)) {\n\t\t\t\td <<= 4;\n\t\t\t\td |= xdtoi((u_char)c);\n\t\t\t\tc = getc(fp);\n\t\t\t\tif (c == EOF)\n\t\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\te.addr[i] = d;\n\t\t\tif (c != ':')\n\t\t\t\tbreak;\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t}\n\n\t\t/* Must be whitespace */\n\t\tif (c != ' ' && c != '\\t' && c != '\\r' && c != '\\n') {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tc = skip_space(fp);\n\t\tif (c == EOF)\n\t\t\treturn (NULL);\n\n\t\t/* hit end of line... */\n\t\tif (c == '\\n')\n\t\t\tcontinue;\n\n\t\tif (c == '#') {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* pick up name */\n\t\tbp = e.name;\n\t\t/* Use 'namesize' to prevent buffer overflow. */\n\t\tnamesize = sizeof(e.name) - 1;\n\t\tdo {\n\t\t\t*bp++ = (u_char)c;\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t} while (c != ' ' && c != '\\t' && c != '\\r' && c != '\\n'\n\t\t    && --namesize != 0);\n\t\t*bp = '\\0';\n\n\t\t/* Eat trailing junk */\n\t\tif (c != '\\n')\n\t\t\t(void)skip_line(fp);\n\n\t\treturn &e;\n\t}\n}\n"
        },
        {
          "name": "ethertype.h",
          "type": "blob",
          "size": 3.455078125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/*\n * Ethernet types.\n *\n * We wrap the declarations with #ifdef, so that if a file includes\n * <netinet/if_ether.h>, which may declare some of these, we don't\n * get a bunch of complaints from the C compiler about redefinitions\n * of these values.\n *\n * We declare all of them here so that no file has to include\n * <netinet/if_ether.h> if all it needs are ETHERTYPE_ values.\n */\n\n#ifndef ETHERTYPE_PUP\n#define ETHERTYPE_PUP\t\t0x0200\t/* PUP protocol */\n#endif\n#ifndef ETHERTYPE_IP\n#define ETHERTYPE_IP\t\t0x0800\t/* IP protocol */\n#endif\n#ifndef ETHERTYPE_ARP\n#define ETHERTYPE_ARP\t\t0x0806\t/* Addr. resolution protocol */\n#endif\n#ifndef ETHERTYPE_NS\n#define ETHERTYPE_NS\t\t0x0600\n#endif\n#ifndef\tETHERTYPE_SPRITE\n#define ETHERTYPE_SPRITE\t0x0500\n#endif\n#ifndef ETHERTYPE_TRAIL\n#define ETHERTYPE_TRAIL\t\t0x1000\n#endif\n#ifndef\tETHERTYPE_MOPDL\n#define ETHERTYPE_MOPDL\t\t0x6001\n#endif\n#ifndef\tETHERTYPE_MOPRC\n#define ETHERTYPE_MOPRC\t\t0x6002\n#endif\n#ifndef\tETHERTYPE_DN\n#define ETHERTYPE_DN\t\t0x6003\n#endif\n#ifndef\tETHERTYPE_LAT\n#define ETHERTYPE_LAT\t\t0x6004\n#endif\n#ifndef ETHERTYPE_SCA\n#define ETHERTYPE_SCA\t\t0x6007\n#endif\n#ifndef ETHERTYPE_TEB\n#define ETHERTYPE_TEB\t\t0x6558\n#endif\n#ifndef ETHERTYPE_REVARP\n#define ETHERTYPE_REVARP\t0x8035\t/* reverse Addr. resolution protocol */\n#endif\n#ifndef\tETHERTYPE_LANBRIDGE\n#define ETHERTYPE_LANBRIDGE\t0x8038\n#endif\n#ifndef\tETHERTYPE_DECDNS\n#define ETHERTYPE_DECDNS\t0x803c\n#endif\n#ifndef\tETHERTYPE_DECDTS\n#define ETHERTYPE_DECDTS\t0x803e\n#endif\n#ifndef\tETHERTYPE_VEXP\n#define ETHERTYPE_VEXP\t\t0x805b\n#endif\n#ifndef\tETHERTYPE_VPROD\n#define ETHERTYPE_VPROD\t\t0x805c\n#endif\n#ifndef ETHERTYPE_ATALK\n#define ETHERTYPE_ATALK\t\t0x809b\n#endif\n#ifndef ETHERTYPE_AARP\n#define ETHERTYPE_AARP\t\t0x80f3\n#endif\n#ifndef ETHERTYPE_8021Q\n#define ETHERTYPE_8021Q\t\t0x8100\n#endif\n#ifndef ETHERTYPE_IPX\n#define ETHERTYPE_IPX\t\t0x8137\n#endif\n#ifndef ETHERTYPE_IPV6\n#define ETHERTYPE_IPV6\t\t0x86dd\n#endif\n#ifndef ETHERTYPE_MPLS\n#define ETHERTYPE_MPLS\t\t0x8847\n#endif\n#ifndef ETHERTYPE_MPLS_MULTI\n#define ETHERTYPE_MPLS_MULTI\t0x8848\n#endif\n#ifndef ETHERTYPE_PPPOED\n#define ETHERTYPE_PPPOED\t0x8863\n#endif\n#ifndef ETHERTYPE_PPPOES\n#define ETHERTYPE_PPPOES\t0x8864\n#endif\n#ifndef ETHERTYPE_8021AD\n#define ETHERTYPE_8021AD\t0x88a8\n#endif\n#ifndef\tETHERTYPE_LOOPBACK\n#define ETHERTYPE_LOOPBACK\t0x9000\n#endif\n#ifndef ETHERTYPE_8021QINQ\n#define ETHERTYPE_8021QINQ\t0x9100\n#endif\n"
        },
        {
          "name": "extract.h",
          "type": "blob",
          "size": 18.4853515625,
          "content": "/*\n * Copyright (c) 1992, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifndef _WIN32\n#include <arpa/inet.h>\n#endif\n\n#include <pcap/pcap-inttypes.h>\n#include <pcap/compiler-tests.h>\n#include \"portability.h\"\n\n/*\n * If we have versions of GCC or Clang that support an __attribute__\n * to say \"if we're building with unsigned behavior sanitization,\n * don't complain about undefined behavior in this function\", we\n * label these functions with that attribute - we *know* it's undefined\n * in the C standard, but we *also* know it does what we want with\n * the ISA we're targeting and the compiler we're using.\n *\n * For GCC 4.9.0 and later, we use __attribute__((no_sanitize_undefined));\n * pre-5.0 GCC doesn't have __has_attribute, and I'm not sure whether\n * GCC or Clang first had __attribute__((no_sanitize(XXX)).\n *\n * For Clang, we check for __attribute__((no_sanitize(XXX)) with\n * __has_attribute, as there are versions of Clang that support\n * __attribute__((no_sanitize(\"undefined\")) but don't support\n * __attribute__((no_sanitize_undefined)).\n *\n * We define this here, rather than in funcattrs.h, because we\n * only want it used here, we don't want it to be broadly used.\n * (Any printer will get this defined, but this should at least\n * make it harder for people to find.)\n */\n#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 409)\n#define UNALIGNED_OK\t__attribute__((no_sanitize_undefined))\n#elif __has_attribute(no_sanitize)\n#define UNALIGNED_OK\t__attribute__((no_sanitize(\"undefined\")))\n#else\n#define UNALIGNED_OK\n#endif\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__))\n/*\n * The processor natively handles unaligned loads, so we can just\n * cast the pointer and fetch through it.\n *\n * XXX - are those all the x86 tests we need?\n * XXX - are those the only 68k tests we need not to generated\n * unaligned accesses if the target is the 68000 or 68010?\n * XXX - are there any tests we don't need, because some definitions are for\n * compilers that also predefine the GCC symbols?\n * XXX - do we need to test for both 32-bit and 64-bit versions of those\n * architectures in all cases?\n */\nUNALIGNED_OK static inline uint16_t\nEXTRACT_BE_U_2(const void *p)\n{\n\treturn ((uint16_t)ntohs(*(const uint16_t *)(p)));\n}\n\nUNALIGNED_OK static inline int16_t\nEXTRACT_BE_S_2(const void *p)\n{\n\treturn ((int16_t)ntohs(*(const int16_t *)(p)));\n}\n\nUNALIGNED_OK static inline uint32_t\nEXTRACT_BE_U_4(const void *p)\n{\n\treturn ((uint32_t)ntohl(*(const uint32_t *)(p)));\n}\n\nUNALIGNED_OK static inline int32_t\nEXTRACT_BE_S_4(const void *p)\n{\n\treturn ((int32_t)ntohl(*(const int32_t *)(p)));\n}\n\nUNALIGNED_OK static inline uint64_t\nEXTRACT_BE_U_8(const void *p)\n{\n\treturn ((uint64_t)(((uint64_t)ntohl(*((const uint32_t *)(p) + 0))) << 32 |\n\t\t((uint64_t)ntohl(*((const uint32_t *)(p) + 1))) << 0));\n\n}\n\nUNALIGNED_OK static inline int64_t\nEXTRACT_BE_S_8(const void *p)\n{\n\treturn ((int64_t)(((int64_t)ntohl(*((const uint32_t *)(p) + 0))) << 32 |\n\t\t((uint64_t)ntohl(*((const uint32_t *)(p) + 1))) << 0));\n\n}\n#elif PCAP_IS_AT_LEAST_GNUC_VERSION(2,0) && \\\n    (defined(__alpha) || defined(__alpha__) || \\\n     defined(__mips) || defined(__mips__))\n/*\n * This is MIPS or Alpha, which don't natively handle unaligned loads,\n * but which have instructions that can help when doing unaligned\n * loads, and this is GCC 2.0 or later or a compiler that claims to\n * be GCC 2.0 or later, which we assume that mean we have\n * __attribute__((packed)), which we can use to convince the compiler\n * to generate those instructions.\n *\n * Declare packed structures containing a uint16_t and a uint32_t,\n * cast the pointer to point to one of those, and fetch through it;\n * the GCC manual doesn't appear to explicitly say that\n * __attribute__((packed)) causes the compiler to generate unaligned-safe\n * code, but it appears to do so.\n *\n * We do this in case the compiler can generate code using those\n * instructions to do an unaligned load and pass stuff to \"ntohs()\" or\n * \"ntohl()\", which might be better than the code to fetch the\n * bytes one at a time and assemble them.  (That might not be the\n * case on a little-endian platform, such as DEC's MIPS machines and\n * Alpha machines, where \"ntohs()\" and \"ntohl()\" might not be done\n * inline.)\n *\n * We do this only for specific architectures because, for example,\n * at least some versions of GCC, when compiling for 64-bit SPARC,\n * generate code that assumes alignment if we do this.\n *\n * XXX - add other architectures and compilers as possible and\n * appropriate.\n *\n * HP's C compiler, indicated by __HP_cc being defined, supports\n * \"#pragma unaligned N\" in version A.05.50 and later, where \"N\"\n * specifies a number of bytes at which the typedef on the next\n * line is aligned, e.g.\n *\n *\t#pragma unalign 1\n *\ttypedef uint16_t unaligned_uint16_t;\n *\n * to define unaligned_uint16_t as a 16-bit unaligned data type.\n * This could be presumably used, in sufficiently recent versions of\n * the compiler, with macros similar to those below.  This would be\n * useful only if that compiler could generate better code for PA-RISC\n * or Itanium than would be generated by a bunch of shifts-and-ORs.\n *\n * DEC C, indicated by __DECC being defined, has, at least on Alpha,\n * an __unaligned qualifier that can be applied to pointers to get the\n * compiler to generate code that does unaligned loads and stores when\n * dereferencing the pointer in question.\n *\n * XXX - what if the native C compiler doesn't support\n * __attribute__((packed))?  How can we get it to generate unaligned\n * accesses for *specific* items?\n */\ntypedef struct {\n\tuint16_t\tval;\n} __attribute__((packed)) unaligned_uint16_t;\n\ntypedef struct {\n\tint16_t\t\tval;\n} __attribute__((packed)) unaligned_int16_t;\n\ntypedef struct {\n\tuint32_t\tval;\n} __attribute__((packed)) unaligned_uint32_t;\n\ntypedef struct {\n\tint32_t\t\tval;\n} __attribute__((packed)) unaligned_int32_t;\n\nUNALIGNED_OK static inline uint16_t\nEXTRACT_BE_U_2(const void *p)\n{\n\treturn ((uint16_t)ntohs(((const unaligned_uint16_t *)(p))->val));\n}\n\nUNALIGNED_OK static inline int16_t\nEXTRACT_BE_S_2(const void *p)\n{\n\treturn ((int16_t)ntohs(((const unaligned_int16_t *)(p))->val));\n}\n\nUNALIGNED_OK static inline uint32_t\nEXTRACT_BE_U_4(const void *p)\n{\n\treturn ((uint32_t)ntohl(((const unaligned_uint32_t *)(p))->val));\n}\n\nUNALIGNED_OK static inline int32_t\nEXTRACT_BE_S_4(const void *p)\n{\n\treturn ((int32_t)ntohl(((const unaligned_int32_t *)(p))->val));\n}\n\nUNALIGNED_OK static inline uint64_t\nEXTRACT_BE_U_8(const void *p)\n{\n\treturn ((uint64_t)(((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 0)->val)) << 32 |\n\t\t((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 1)->val)) << 0));\n}\n\nUNALIGNED_OK static inline int64_t\nEXTRACT_BE_S_8(const void *p)\n{\n\treturn ((int64_t)(((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 0)->val)) << 32 |\n\t\t((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 1)->val)) << 0));\n}\n#else\n/*\n * This architecture doesn't natively support unaligned loads, and either\n * this isn't a GCC-compatible compiler, we don't have __attribute__,\n * or we do but we don't know of any better way with this instruction\n * set to do unaligned loads, so do unaligned loads of big-endian\n * quantities the hard way - fetch the bytes one at a time and\n * assemble them.\n *\n * XXX - ARM is a special case.  ARMv1 through ARMv5 didn't support\n * unaligned loads; ARMv6 and later support it *but* have a bit in\n * the system control register that the OS can set and that causes\n * unaligned loads to fault rather than succeeding.\n *\n * At least some OSes may set that flag, so we do *not* treat ARM\n * as supporting unaligned loads.  If your OS supports them on ARM,\n * and you want to use them, please update the tests in the #if above\n * to check for ARM *and* for your OS.\n */\n#define EXTRACT_BE_U_2(p) \\\n\t((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 0)) << 8) | \\\n\t            ((uint16_t)(*((const uint8_t *)(p) + 1)) << 0)))\n#define EXTRACT_BE_S_2(p) \\\n\t((int16_t)(((uint16_t)(*((const uint8_t *)(p) + 0)) << 8) | \\\n\t           ((uint16_t)(*((const uint8_t *)(p) + 1)) << 0)))\n#define EXTRACT_BE_U_4(p) \\\n\t((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0)))\n#define EXTRACT_BE_S_4(p) \\\n\t((int32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0)))\n#define EXTRACT_BE_U_8(p) \\\n\t((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 56) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 1)) << 48) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 2)) << 40) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 3)) << 32) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 4)) << 24) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 5)) << 16) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 6)) << 8) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 7)) << 0)))\n#define EXTRACT_BE_S_8(p) \\\n\t((int64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 56) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 1)) << 48) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 2)) << 40) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 3)) << 32) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 4)) << 24) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 5)) << 16) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 6)) << 8) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 7)) << 0)))\n\n/*\n * Extract an IPv4 address, which is in network byte order, and not\n * necessarily aligned, and provide the result in host byte order.\n */\n#define EXTRACT_IPV4_TO_HOST_ORDER(p) \\\n\t((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0)))\n#endif /* unaligned access checks */\n\n/*\n * Non-power-of-2 sizes.\n */\n#define EXTRACT_BE_U_3(p) \\\n\t((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 16) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 2)) << 0)))\n\n#define EXTRACT_BE_S_3(p) \\\n\t(((*((const uint8_t *)(p) + 0)) & 0x80) ? \\\n\t  ((int32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 16) | \\\n\t             ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t             ((uint32_t)(*((const uint8_t *)(p) + 2)) << 0))) : \\\n\t  ((int32_t)(0xFF000000U | \\\n\t             ((uint32_t)(*((const uint8_t *)(p) + 0)) << 16) | \\\n\t             ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t             ((uint32_t)(*((const uint8_t *)(p) + 2)) << 0))))\n\n#define EXTRACT_BE_U_5(p) \\\n\t((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 32) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 1)) << 24) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 3)) << 8) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 4)) << 0)))\n\n#define EXTRACT_BE_S_5(p) \\\n\t(((*((const uint8_t *)(p) + 0)) & 0x80) ? \\\n\t  ((int64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 32) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 1)) << 24) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 3)) << 8) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 4)) << 0))) : \\\n\t  ((int64_t)(INT64_T_CONSTANT(0xFFFFFF0000000000U) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 0)) << 32) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 1)) << 24) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 3)) << 8) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 4)) << 0))))\n\n#define EXTRACT_BE_U_6(p) \\\n\t((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 40) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 1)) << 32) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 2)) << 24) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 3)) << 16) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 4)) << 8) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 5)) << 0)))\n\n#define EXTRACT_BE_S_6(p) \\\n\t(((*((const uint8_t *)(p) + 0)) & 0x80) ? \\\n\t   ((int64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 40) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 1)) << 32) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 2)) << 24) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 3)) << 16) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 4)) << 8) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 5)) << 0))) : \\\n\t  ((int64_t)(INT64_T_CONSTANT(0xFFFFFFFF00000000U) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 0)) << 40) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 1)) << 32) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 2)) << 24) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 3)) << 16) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 4)) << 8) | \\\n\t              ((uint64_t)(*((const uint8_t *)(p) + 5)) << 0))))\n\n#define EXTRACT_BE_U_7(p) \\\n\t((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 48) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 1)) << 40) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 2)) << 32) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 4)) << 16) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 5)) << 8) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 6)) << 0)))\n\n#define EXTRACT_BE_S_7(p) \\\n\t(((*((const uint8_t *)(p) + 0)) & 0x80) ? \\\n\t  ((int64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 48) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 1)) << 40) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 2)) << 32) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 4)) << 16) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 5)) << 8) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 6)) << 0))) : \\\n\t    ((int64_t)(INT64_T_CONSTANT(0xFFFFFFFFFF000000U) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 0)) << 48) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 1)) << 40) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 2)) << 32) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 4)) << 16) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 5)) << 8) | \\\n\t             ((uint64_t)(*((const uint8_t *)(p) + 6)) << 0))))\n\n/*\n * Macros to extract possibly-unaligned little-endian integral values.\n * XXX - do loads on little-endian machines that support unaligned loads?\n */\n#define EXTRACT_LE_U_2(p) \\\n\t((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t            ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_S_2(p) \\\n\t((int16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t           ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_U_4(p) \\\n\t((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_S_4(p) \\\n\t((int32_t)(((uint32_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_U_3(p) \\\n\t((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t            ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_S_3(p) \\\n\t((int32_t)(((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t           ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_U_8(p) \\\n\t((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 7)) << 56) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 6)) << 48) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 5)) << 40) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 4)) << 32) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t            ((uint64_t)(*((const uint8_t *)(p) + 0)) << 0)))\n#define EXTRACT_LE_S_8(p) \\\n\t((int64_t)(((uint64_t)(*((const uint8_t *)(p) + 7)) << 56) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 6)) << 48) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 5)) << 40) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 4)) << 32) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n\t           ((uint64_t)(*((const uint8_t *)(p) + 0)) << 0)))\n"
        },
        {
          "name": "fad-getad.c",
          "type": "blob",
          "size": 8.798828125,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#include <net/if.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ifaddrs.h>\n\n#include \"pcap-int.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n/*\n * We don't do this on Solaris 11 and later, as it appears there aren't\n * any AF_PACKET addresses on interfaces, so we don't need this, and\n * we end up including both the OS's <net/bpf.h> and our <pcap/bpf.h>,\n * and their definitions of some data structures collide.\n */\n#if defined(__linux__) && defined(AF_PACKET)\n# ifdef HAVE_NETPACKET_PACKET_H\n/* Linux distributions with newer glibc */\n#  include <netpacket/packet.h>\n# else /* HAVE_NETPACKET_PACKET_H */\n/* Linux distributions with older glibc */\n#  include <linux/types.h>\n#  include <linux/if_packet.h>\n# endif /* HAVE_NETPACKET_PACKET_H */\n#endif /* defined(__linux__) && defined(AF_PACKET) */\n\n/*\n * This is fun.\n *\n * In older BSD systems, socket addresses were fixed-length, and\n * \"sizeof (struct sockaddr)\" gave the size of the structure.\n * All addresses fit within a \"struct sockaddr\".\n *\n * In newer BSD systems, the socket address is variable-length, and\n * there's an \"sa_len\" field giving the length of the structure;\n * this allows socket addresses to be longer than 2 bytes of family\n * and 14 bytes of data.\n *\n * Some commercial UNIXes use the old BSD scheme, some use the RFC 2553\n * variant of the old BSD scheme (with \"struct sockaddr_storage\" rather\n * than \"struct sockaddr\"), and some use the new BSD scheme.\n *\n * Some versions of GNU libc use neither scheme, but has an \"SA_LEN()\"\n * macro that determines the size based on the address family.  Other\n * versions don't have \"SA_LEN()\" (as it was in drafts of RFC 2553\n * but not in the final version).  On the latter systems, we explicitly\n * check the AF_ type to determine the length; we assume that on\n * all those systems we have \"struct sockaddr_storage\".\n *\n * OSes that use this file are:\n * - FreeBSD (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - Haiku (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - Hurd (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - illumos (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)\n * - Linux (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)\n * - macOS (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - NetBSD (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - OpenBSD (SA_LEN() is defined)\n * - Solaris 11 (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)\n */\n#ifndef SA_LEN\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n#define SA_LEN(addr)\t((addr)->sa_len)\n#else /* HAVE_STRUCT_SOCKADDR_SA_LEN */\nstatic size_t\nget_sa_len(struct sockaddr *addr)\n{\n\tswitch (addr->sa_family) {\n\n#ifdef AF_INET\n\tcase AF_INET:\n\t\treturn (sizeof (struct sockaddr_in));\n#endif\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\treturn (sizeof (struct sockaddr_in6));\n#endif\n\n#if defined(__linux__) && defined(AF_PACKET)\n\tcase AF_PACKET:\n\t\treturn (sizeof (struct sockaddr_ll));\n#endif\n\n#ifdef AF_LINK\n\tcase AF_LINK:\n\t\treturn (sizeof (struct sockaddr_dl));\n#endif\n\n\tdefault:\n\t\treturn (sizeof (struct sockaddr));\n\t}\n}\n#define SA_LEN(addr)\t(get_sa_len(addr))\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* SA_LEN */\n\n/*\n * Get a list of all interfaces that are up and that we can open.\n * Returns -1 on error, 0 otherwise.\n * The list, as returned through \"alldevsp\", may be null if no interfaces\n * could be opened.\n */\nint\npcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct sockaddr *addr, *netmask, *broadaddr, *dstaddr;\n\tsize_t addr_size, broadaddr_size, dstaddr_size;\n\tint ret = 0;\n\tchar *p, *q;\n\n\t/*\n\t * Get the list of interface addresses.\n\t *\n\t * Note: this won't return information about interfaces\n\t * with no addresses, so, if a platform has interfaces\n\t * with no interfaces on which traffic can be captured,\n\t * we must check for those interfaces as well (see, for\n\t * example, what's done on Linux).\n\t *\n\t * LAN interfaces will probably have link-layer\n\t * addresses; I don't know whether all implementations\n\t * of \"getifaddrs()\" now, or in the future, will return\n\t * those.\n\t */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getifaddrs\");\n\t\treturn (-1);\n\t}\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, we assume it's a logical interface.  Those\n\t\t * are just the way you assign multiple IP addresses to\n\t\t * a real interface on Linux, so an entry for a logical\n\t\t * interface should be treated like the entry for the\n\t\t * real interface; we do that by stripping off the \":\"\n\t\t * and the number.\n\t\t *\n\t\t * XXX - should we do this only on Linux?\n\t\t */\n\t\tp = strchr(ifa->ifa_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (PCAP_ISDIGIT(*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t       *p = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifa->ifa_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * \"ifa_addr\" was apparently null on at least one\n\t\t * interface on some system.  Therefore, we supply\n\t\t * the address and netmask only if \"ifa_addr\" is\n\t\t * non-null (if there's no address, there's obviously\n\t\t * no netmask).\n\t\t */\n\t\tif (ifa->ifa_addr != NULL) {\n\t\t\taddr = ifa->ifa_addr;\n\t\t\taddr_size = SA_LEN(addr);\n\t\t\tnetmask = ifa->ifa_netmask;\n\t\t} else {\n\t\t\taddr = NULL;\n\t\t\taddr_size = 0;\n\t\t\tnetmask = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Note that, on some platforms, ifa_broadaddr and\n\t\t * ifa_dstaddr could be the same field (true on at\n\t\t * least some versions of *BSD and macOS), so we\n\t\t * can't just check whether the broadcast address\n\t\t * is null and add it if so and check whether the\n\t\t * destination address is null and add it if so.\n\t\t *\n\t\t * Therefore, we must also check the IFF_BROADCAST\n\t\t * flag, and only add a broadcast address if it's\n\t\t * set, and check the IFF_POINTTOPOINT flag, and\n\t\t * only add a destination address if it's set (as\n\t\t * per man page recommendations on some of those\n\t\t * platforms).\n\t\t */\n\t\tif (ifa->ifa_flags & IFF_BROADCAST &&\n\t\t    ifa->ifa_broadaddr != NULL) {\n\t\t\tbroadaddr = ifa->ifa_broadaddr;\n\t\t\tbroadaddr_size = SA_LEN(broadaddr);\n\t\t} else {\n\t\t\tbroadaddr = NULL;\n\t\t\tbroadaddr_size = 0;\n\t\t}\n\t\tif (ifa->ifa_flags & IFF_POINTOPOINT &&\n\t\t    ifa->ifa_dstaddr != NULL) {\n\t\t\tdstaddr = ifa->ifa_dstaddr;\n\t\t\tdstaddr_size = SA_LEN(ifa->ifa_dstaddr);\n\t\t} else {\n\t\t\tdstaddr = NULL;\n\t\t\tdstaddr_size = 0;\n\t\t}\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (pcapint_add_addr_to_if(devlistp, ifa->ifa_name, ifa->ifa_flags,\n\t\t    get_flags_func,\n\t\t    addr, addr_size, netmask, addr_size,\n\t\t    broadaddr, broadaddr_size, dstaddr, dstaddr_size,\n\t\t    errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifap);\n\n\treturn (ret);\n}\n"
        },
        {
          "name": "fad-gifc.c",
          "type": "blob",
          "size": 12.5634765625,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_SOCKIO_H\n#include <sys/sockio.h>\n#endif\n\n#include <net/if.h>\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"pcap-int.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n/*\n * This is fun.\n *\n * In older BSD systems, socket addresses were fixed-length, and\n * \"sizeof (struct sockaddr)\" gave the size of the structure.\n * All addresses fit within a \"struct sockaddr\".\n *\n * In newer BSD systems, the socket address is variable-length, and\n * there's an \"sa_len\" field giving the length of the structure;\n * this allows socket addresses to be longer than 2 bytes of family\n * and 14 bytes of data.\n *\n * Some commercial UNIXes use the old BSD scheme, some use the RFC 2553\n * variant of the old BSD scheme (with \"struct sockaddr_storage\" rather\n * than \"struct sockaddr\"), and some use the new BSD scheme.\n *\n * Some versions of GNU libc use neither scheme, but has an \"SA_LEN()\"\n * macro that determines the size based on the address family.  Other\n * versions don't have \"SA_LEN()\" (as it was in drafts of RFC 2553\n * but not in the final version).\n *\n * We assume that a UNIX that doesn't have \"getifaddrs()\" and doesn't have\n * SIOCGLIFCONF, but has SIOCGIFCONF, uses \"struct sockaddr\" for the\n * address in an entry returned by SIOCGIFCONF.\n *\n * OSes that use this file are:\n * - AIX 7 (SA_LEN() is not defined, HAVE_STRUCT_SOCKADDR_SA_LEN is defined)\n * - HP-UX 11 (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)\n */\n#ifndef SA_LEN\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n#define SA_LEN(addr)\t((addr)->sa_len)\n#else /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#define SA_LEN(addr)\t(sizeof (struct sockaddr))\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* SA_LEN */\n\n/*\n * This is also fun.\n *\n * There is no ioctl that returns the amount of space required for all\n * the data that SIOCGIFCONF could return, and if a buffer is supplied\n * that's not large enough for all the data SIOCGIFCONF could return,\n * on at least some platforms it just returns the data that'd fit with\n * no indication that there wasn't enough room for all the data, much\n * less an indication of how much more room is required.\n *\n * The only way to ensure that we got all the data is to pass a buffer\n * large enough that the amount of space in the buffer *not* filled in\n * is greater than the largest possible entry.\n *\n * We assume that's \"sizeof(ifreq.ifr_name)\" plus 255, under the assumption\n * that no address is more than 255 bytes (on systems where the \"sa_len\"\n * field in a \"struct sockaddr\" is 1 byte, e.g. newer BSDs, that's the\n * case, and addresses are unlikely to be bigger than that in any case).\n */\n#define MAX_SA_LEN\t255\n\n/*\n * Get a list of all interfaces that are up and that we can open.\n * Returns -1 on error, 0 otherwise.\n * The list, as returned through \"alldevsp\", may be null if no interfaces\n * were up and could be opened.\n *\n * This is the implementation used on platforms that have SIOCGIFCONF but\n * don't have any other mechanism for getting a list of interfaces.\n *\n * XXX - or platforms that have other, better mechanisms but for which\n * we don't yet have code to use that mechanism; I think there's a better\n * way on Linux, for example, but if that better way is \"getifaddrs()\",\n * we already have that.\n */\nint\npcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tregister int fd;\n\tregister struct ifreq *ifrp, *ifend, *ifnext;\n\tsize_t n;\n\tstruct ifconf ifc;\n\tchar *buf = NULL;\n\tunsigned buf_size;\n#if defined (HAVE_SOLARIS) || defined (HAVE_HPUX10_20_OR_LATER)\n\tchar *p, *q;\n#endif\n\tstruct ifreq ifrflags, ifrnetmask, ifrbroadaddr, ifrdstaddr;\n\tstruct sockaddr *netmask, *broadaddr, *dstaddr;\n\tsize_t netmask_size, broadaddr_size, dstaddr_size;\n\tint ret = 0;\n\n\t/*\n\t * Create a socket from which to fetch the list of interfaces.\n\t */\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Start with an 8K buffer, and keep growing the buffer until\n\t * we have more than \"sizeof(ifrp->ifr_name) + MAX_SA_LEN\"\n\t * bytes left over in the buffer or we fail to get the\n\t * interface list for some reason other than EINVAL (which is\n\t * presumed here to mean \"buffer is too small\").\n\t */\n\tbuf_size = 8192;\n\tfor (;;) {\n\t\t/*\n\t\t * Don't let the buffer size get bigger than INT_MAX.\n\t\t */\n\t\tif (buf_size > INT_MAX) {\n\t\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"interface information requires more than %u bytes\",\n\t\t\t    INT_MAX);\n\t\t\t(void)close(fd);\n\t\t\treturn (-1);\n\t\t}\n\t\tbuf = malloc(buf_size);\n\t\tif (buf == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\t(void)close(fd);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tifc.ifc_len = buf_size;\n\t\tifc.ifc_buf = buf;\n\t\tmemset(buf, 0, buf_size);\n\t\tif (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0\n\t\t    && errno != EINVAL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFCONF\");\n\t\t\t(void)close(fd);\n\t\t\tfree(buf);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (ifc.ifc_len < (int)buf_size &&\n\t\t    (buf_size - ifc.ifc_len) > sizeof(ifrp->ifr_name) + MAX_SA_LEN)\n\t\t\tbreak;\n\t\tfree(buf);\n\t\tbuf_size *= 2;\n\t}\n\n\tifrp = (struct ifreq *)buf;\n\tifend = (struct ifreq *)(buf + ifc.ifc_len);\n\n\tfor (; ifrp < ifend; ifrp = ifnext) {\n\t\t/*\n\t\t * XXX - what if this isn't an IPv4 address?  Can\n\t\t * we still get the netmask, etc. with ioctls on\n\t\t * an IPv4 socket?\n\t\t *\n\t\t * The answer is probably platform-dependent, and\n\t\t * if the answer is \"no\" on more than one platform,\n\t\t * the way you work around it is probably platform-\n\t\t * dependent as well.\n\t\t */\n\t\tn = SA_LEN(&ifrp->ifr_addr) + sizeof(ifrp->ifr_name);\n\t\tif (n < sizeof(*ifrp))\n\t\t\tifnext = ifrp + 1;\n\t\telse\n\t\t\tifnext = (struct ifreq *)((char *)ifrp + n);\n\n\t\t/*\n\t\t * XXX - The 32-bit compatibility layer for Linux on IA-64\n\t\t * is slightly broken. It correctly converts the structures\n\t\t * to and from kernel land from 64 bit to 32 bit but\n\t\t * doesn't update ifc.ifc_len, leaving it larger than the\n\t\t * amount really used. This means we read off the end\n\t\t * of the buffer and encounter an interface with an\n\t\t * \"empty\" name. Since this is highly unlikely to ever\n\t\t * occur in a valid case we can just finish looking for\n\t\t * interfaces if we see an empty name.\n\t\t */\n\t\tif (!(*ifrp->ifr_name))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifrp->ifr_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get the flags for this interface.\n\t\t */\n\t\tpcapint_strlcpy(ifrflags.ifr_name, ifrp->ifr_name,\n\t\t    sizeof(ifrflags.ifr_name));\n\t\tif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {\n\t\t\tif (errno == ENXIO)\n\t\t\t\tcontinue;\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFFLAGS: %.*s\",\n\t\t\t    (int)sizeof(ifrflags.ifr_name),\n\t\t\t    ifrflags.ifr_name);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the netmask for this address on this interface.\n\t\t */\n\t\tpcapint_strlcpy(ifrnetmask.ifr_name, ifrp->ifr_name,\n\t\t    sizeof(ifrnetmask.ifr_name));\n\t\tmemcpy(&ifrnetmask.ifr_addr, &ifrp->ifr_addr,\n\t\t    sizeof(ifrnetmask.ifr_addr));\n\t\tif (ioctl(fd, SIOCGIFNETMASK, (char *)&ifrnetmask) < 0) {\n\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t/*\n\t\t\t\t * Not available.\n\t\t\t\t */\n\t\t\t\tnetmask = NULL;\n\t\t\t\tnetmask_size = 0;\n\t\t\t} else {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCGIFNETMASK: %.*s\",\n\t\t\t\t    (int)sizeof(ifrnetmask.ifr_name),\n\t\t\t\t    ifrnetmask.ifr_name);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tnetmask = &ifrnetmask.ifr_addr;\n\t\t\tnetmask_size = SA_LEN(netmask);\n\t\t}\n\n\t\t/*\n\t\t * Get the broadcast address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.ifr_flags & IFF_BROADCAST) {\n\t\t\tpcapint_strlcpy(ifrbroadaddr.ifr_name, ifrp->ifr_name,\n\t\t\t    sizeof(ifrbroadaddr.ifr_name));\n\t\t\tmemcpy(&ifrbroadaddr.ifr_addr, &ifrp->ifr_addr,\n\t\t\t    sizeof(ifrbroadaddr.ifr_addr));\n\t\t\tif (ioctl(fd, SIOCGIFBRDADDR,\n\t\t\t    (char *)&ifrbroadaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tbroadaddr = NULL;\n\t\t\t\t\tbroadaddr_size = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGIFBRDADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrbroadaddr.ifr_name),\n\t\t\t\t\t    ifrbroadaddr.ifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbroadaddr = &ifrbroadaddr.ifr_broadaddr;\n\t\t\t\tbroadaddr_size = SA_LEN(broadaddr);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a broadcast interface, so no broadcast\n\t\t\t * address.\n\t\t\t */\n\t\t\tbroadaddr = NULL;\n\t\t\tbroadaddr_size = 0;\n\t\t}\n\n\t\t/*\n\t\t * Get the destination address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.ifr_flags & IFF_POINTOPOINT) {\n\t\t\tpcapint_strlcpy(ifrdstaddr.ifr_name, ifrp->ifr_name,\n\t\t\t    sizeof(ifrdstaddr.ifr_name));\n\t\t\tmemcpy(&ifrdstaddr.ifr_addr, &ifrp->ifr_addr,\n\t\t\t    sizeof(ifrdstaddr.ifr_addr));\n\t\t\tif (ioctl(fd, SIOCGIFDSTADDR,\n\t\t\t    (char *)&ifrdstaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tdstaddr = NULL;\n\t\t\t\t\tdstaddr_size = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGIFDSTADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrdstaddr.ifr_name),\n\t\t\t\t\t    ifrdstaddr.ifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdstaddr = &ifrdstaddr.ifr_dstaddr;\n\t\t\t\tdstaddr_size = SA_LEN(dstaddr);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a point-to-point interface, so no destination\n\t\t\t * address.\n\t\t\t */\n\t\t\tdstaddr = NULL;\n\t\t\tdstaddr_size = 0;\n\t\t}\n\n#if defined (HAVE_SOLARIS) || defined (HAVE_HPUX10_20_OR_LATER)\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, it's a logical interface.  Those are just\n\t\t * the way you assign multiple IP addresses to a real\n\t\t * interface, so an entry for a logical interface should\n\t\t * be treated like the entry for the real interface;\n\t\t * we do that by stripping off the \":\" and the number.\n\t\t */\n\t\tp = strchr(ifrp->ifr_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (PCAP_ISDIGIT(*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (pcapint_add_addr_to_if(devlistp, ifrp->ifr_name,\n\t\t    ifrflags.ifr_flags, get_flags_func,\n\t\t    &ifrp->ifr_addr, SA_LEN(&ifrp->ifr_addr),\n\t\t    netmask, netmask_size, broadaddr, broadaddr_size,\n\t\t    dstaddr, dstaddr_size, errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(buf);\n\t(void)close(fd);\n\n\treturn (ret);\n}\n"
        },
        {
          "name": "fad-glifc.c",
          "type": "blob",
          "size": 8.9619140625,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <sys/param.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/sockio.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"pcap-int.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n/*\n * Only Solaris 10 uses this file.\n */\n\n/*\n * Get a list of all interfaces that are up and that we can open.\n * Returns -1 on error, 0 otherwise.\n * The list, as returned through \"alldevsp\", may be null if no interfaces\n * were up and could be opened.\n *\n * This is the implementation used on platforms that have SIOCGLIFCONF\n * but don't have \"getifaddrs()\".  (Solaris 8 and later; we use\n * SIOCGLIFCONF rather than SIOCGIFCONF in order to get IPv6 addresses.)\n */\nint\npcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tregister int fd4, fd6, fd;\n\tregister struct lifreq *ifrp, *ifend;\n\tstruct lifnum ifn;\n\tstruct lifconf ifc;\n\tchar *buf = NULL;\n\tunsigned buf_size;\n\tchar *p, *q;\n\tstruct lifreq ifrflags, ifrnetmask, ifrbroadaddr, ifrdstaddr;\n\tstruct sockaddr *netmask, *broadaddr, *dstaddr;\n\tint ret = 0;\n\n\t/*\n\t * Create a socket from which to fetch the list of interfaces,\n\t * and from which to fetch IPv4 information.\n\t */\n\tfd4 = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd4 < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket: AF_INET\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Create a socket from which to fetch IPv6 information.\n\t */\n\tfd6 = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (fd6 < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket: AF_INET6\");\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * How many entries will SIOCGLIFCONF return?\n\t */\n\tifn.lifn_family = AF_UNSPEC;\n\tifn.lifn_flags = 0;\n\tifn.lifn_count = 0;\n\tif (ioctl(fd4, SIOCGLIFNUM, (char *)&ifn) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGLIFNUM\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Allocate a buffer for those entries.\n\t */\n\tbuf_size = ifn.lifn_count * sizeof (struct lifreq);\n\tbuf = malloc(buf_size);\n\tif (buf == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the entries.\n\t */\n\tifc.lifc_len = buf_size;\n\tifc.lifc_buf = buf;\n\tifc.lifc_family = AF_UNSPEC;\n\tifc.lifc_flags = 0;\n\tmemset(buf, 0, buf_size);\n\tif (ioctl(fd4, SIOCGLIFCONF, (char *)&ifc) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGLIFCONF\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\tfree(buf);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Loop over the entries.\n\t */\n\tifrp = (struct lifreq *)buf;\n\tifend = (struct lifreq *)(buf + ifc.lifc_len);\n\n\tfor (; ifrp < ifend; ifrp++) {\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifrp->lifr_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * IPv6 or not?\n\t\t */\n\t\tif (((struct sockaddr *)&ifrp->lifr_addr)->sa_family == AF_INET6)\n\t\t\tfd = fd6;\n\t\telse\n\t\t\tfd = fd4;\n\n\t\t/*\n\t\t * Get the flags for this interface.\n\t\t */\n\t\tpcapint_strlcpy(ifrflags.lifr_name, ifrp->lifr_name,\n\t\t    sizeof(ifrflags.lifr_name));\n\t\tif (ioctl(fd, SIOCGLIFFLAGS, (char *)&ifrflags) < 0) {\n\t\t\tif (errno == ENXIO)\n\t\t\t\tcontinue;\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGLIFFLAGS: %.*s\",\n\t\t\t    (int)sizeof(ifrflags.lifr_name),\n\t\t\t    ifrflags.lifr_name);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the netmask for this address on this interface.\n\t\t */\n\t\tpcapint_strlcpy(ifrnetmask.lifr_name, ifrp->lifr_name,\n\t\t    sizeof(ifrnetmask.lifr_name));\n\t\tmemcpy(&ifrnetmask.lifr_addr, &ifrp->lifr_addr,\n\t\t    sizeof(ifrnetmask.lifr_addr));\n\t\tif (ioctl(fd, SIOCGLIFNETMASK, (char *)&ifrnetmask) < 0) {\n\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t/*\n\t\t\t\t * Not available.\n\t\t\t\t */\n\t\t\t\tnetmask = NULL;\n\t\t\t} else {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCGLIFNETMASK: %.*s\",\n\t\t\t\t    (int)sizeof(ifrnetmask.lifr_name),\n\t\t\t\t    ifrnetmask.lifr_name);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tnetmask = (struct sockaddr *)&ifrnetmask.lifr_addr;\n\n\t\t/*\n\t\t * Get the broadcast address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.lifr_flags & IFF_BROADCAST) {\n\t\t\tpcapint_strlcpy(ifrbroadaddr.lifr_name, ifrp->lifr_name,\n\t\t\t    sizeof(ifrbroadaddr.lifr_name));\n\t\t\tmemcpy(&ifrbroadaddr.lifr_addr, &ifrp->lifr_addr,\n\t\t\t    sizeof(ifrbroadaddr.lifr_addr));\n\t\t\tif (ioctl(fd, SIOCGLIFBRDADDR,\n\t\t\t    (char *)&ifrbroadaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tbroadaddr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGLIFBRDADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrbroadaddr.lifr_name),\n\t\t\t\t\t    ifrbroadaddr.lifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbroadaddr = (struct sockaddr *)&ifrbroadaddr.lifr_broadaddr;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a broadcast interface, so no broadcast\n\t\t\t * address.\n\t\t\t */\n\t\t\tbroadaddr = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Get the destination address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.lifr_flags & IFF_POINTOPOINT) {\n\t\t\tpcapint_strlcpy(ifrdstaddr.lifr_name, ifrp->lifr_name,\n\t\t\t    sizeof(ifrdstaddr.lifr_name));\n\t\t\tmemcpy(&ifrdstaddr.lifr_addr, &ifrp->lifr_addr,\n\t\t\t    sizeof(ifrdstaddr.lifr_addr));\n\t\t\tif (ioctl(fd, SIOCGLIFDSTADDR,\n\t\t\t    (char *)&ifrdstaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tdstaddr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGLIFDSTADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrdstaddr.lifr_name),\n\t\t\t\t\t    ifrdstaddr.lifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tdstaddr = (struct sockaddr *)&ifrdstaddr.lifr_dstaddr;\n\t\t} else\n\t\t\tdstaddr = NULL;\n\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, it's a logical interface.  Those are just\n\t\t * the way you assign multiple IP addresses to a real\n\t\t * interface, so an entry for a logical interface should\n\t\t * be treated like the entry for the real interface;\n\t\t * we do that by stripping off the \":\" and the number.\n\t\t */\n\t\tp = strchr(ifrp->lifr_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (PCAP_ISDIGIT(*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (pcapint_add_addr_to_if(devlistp, ifrp->lifr_name,\n\t\t    ifrflags.lifr_flags, get_flags_func,\n\t\t    (struct sockaddr *)&ifrp->lifr_addr,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    netmask, sizeof (struct sockaddr_storage),\n\t\t    broadaddr, sizeof (struct sockaddr_storage),\n\t\t    dstaddr, sizeof (struct sockaddr_storage), errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(buf);\n\t(void)close(fd6);\n\t(void)close(fd4);\n\n\treturn (ret);\n}\n"
        },
        {
          "name": "fmtutils.c",
          "type": "blob",
          "size": 11.123046875,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * Utilities for message formatting used both by libpcap and rpcapd.\n */\n\n#include <config.h>\n\n#include \"ftmacros.h\"\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"pcap-int.h\"\n\n#include \"portability.h\"\n\n#include \"fmtutils.h\"\n\n#ifdef _WIN32\n#include \"charconv.h\"\n#endif\n\n/*\n * Set the encoding.\n */\n#ifdef _WIN32\n/*\n * True if we should use UTF-8.\n */\nstatic int use_utf_8;\n\nvoid\npcapint_fmt_set_encoding(unsigned int opts)\n{\n\tif (opts == PCAP_CHAR_ENC_UTF_8)\n\t\tuse_utf_8 = 1;\n}\n#else\nvoid\npcapint_fmt_set_encoding(unsigned int opts _U_)\n{\n\t/*\n\t * Nothing to do here.\n\t */\n}\n#endif\n\n#ifdef _WIN32\n/*\n * Convert a null-terminated UTF-16LE string to UTF-8, putting it into\n * a buffer starting at the specified location and stopping if we go\n * past the specified size.  This will only put out complete UTF-8\n * sequences.\n *\n * We do this ourselves because Microsoft doesn't offer a \"convert and\n * stop at a UTF-8 character boundary if we run out of space\" routine.\n */\n#define IS_LEADING_SURROGATE(c) \\\n\t((c) >= 0xd800 && (c) < 0xdc00)\n#define IS_TRAILING_SURROGATE(c) \\\n\t((c) >= 0xdc00 && (c) < 0xe000)\n#define SURROGATE_VALUE(leading, trailing) \\\n\t(((((leading) - 0xd800) << 10) | ((trailing) - 0xdc00)) + 0x10000)\n#define REPLACEMENT_CHARACTER\t0x0FFFD\n\nstatic char *\nutf_16le_to_utf_8_truncated(const wchar_t *utf_16, char *utf_8,\n    size_t utf_8_len)\n{\n\twchar_t c, c2;\n\tuint32_t uc;\n\n\tif (utf_8_len == 0) {\n\t\t/*\n\t\t * Not even enough room for a trailing '\\0'.\n\t\t * Don't put anything into the buffer.\n\t\t */\n\t\treturn (utf_8);\n\t}\n\n\twhile ((c = *utf_16++) != '\\0') {\n\t\tif (IS_LEADING_SURROGATE(c)) {\n\t\t\t/*\n\t\t\t * Leading surrogate.  Must be followed by\n\t\t\t * a trailing surrogate.\n\t\t\t */\n\t\t\tc2 = *utf_16;\n\t\t\tif (c2 == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * Oops, string ends with a lead\n\t\t\t\t * surrogate.  Try to drop in\n\t\t\t\t * a REPLACEMENT CHARACTER, and\n\t\t\t\t * don't move the string pointer,\n\t\t\t\t * so on the next trip through\n\t\t\t\t * the loop we grab the terminating\n\t\t\t\t * '\\0' and quit.\n\t\t\t\t */\n\t\t\t\tuc = REPLACEMENT_CHARACTER;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * OK, we can consume this 2-octet\n\t\t\t\t * value.\n\t\t\t\t */\n\t\t\t\tutf_16++;\n\t\t\t\tif (IS_TRAILING_SURROGATE(c2)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Trailing surrogate.\n\t\t\t\t\t * This calculation will,\n\t\t\t\t\t * for c being a leading\n\t\t\t\t\t * surrogate and c2 being\n\t\t\t\t\t * a trailing surrogate,\n\t\t\t\t\t * produce a value between\n\t\t\t\t\t * 0x100000 and 0x10ffff,\n\t\t\t\t\t * so it's always going to be\n\t\t\t\t\t * a valid Unicode code point.\n\t\t\t\t\t */\n\t\t\t\t\tuc = SURROGATE_VALUE(c, c2);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not a trailing surrogate;\n\t\t\t\t\t * try to drop in a\n\t\t\t\t\t * REPLACEMENT CHARACTER.\n\t\t\t\t\t */\n\t\t\t\t\tuc = REPLACEMENT_CHARACTER;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a leading surrogate.\n\t\t\t */\n\t\t\tif (IS_TRAILING_SURROGATE(c)) {\n\t\t\t\t/*\n\t\t\t\t * Trailing surrogate without\n\t\t\t\t * a preceding leading surrogate.\n\t\t\t\t * Try to drop in a REPLACEMENT\n\t\t\t\t * CHARACTER.\n\t\t\t\t */\n\t\t\t\tuc = REPLACEMENT_CHARACTER;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is a valid BMP character;\n\t\t\t\t * drop it in.\n\t\t\t\t */\n\t\t\t\tuc = c;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * OK, uc is a valid Unicode character; how\n\t\t * many bytes worth of UTF-8 does it require?\n\t\t */\n\t\tif (uc < 0x0080) {\n\t\t\t/* 1 byte. */\n\t\t\tif (utf_8_len < 2) {\n\t\t\t\t/*\n\t\t\t\t * Not enough room for that byte\n\t\t\t\t * plus a trailing '\\0'.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*utf_8++ = (char)uc;\n\t\t\tutf_8_len--;\n\t\t} else if (uc < 0x0800) {\n\t\t\t/* 2 bytes. */\n\t\t\tif (utf_8_len < 3) {\n\t\t\t\t/*\n\t\t\t\t * Not enough room for those bytes\n\t\t\t\t * plus a trailing '\\0'.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*utf_8++ = ((uc >> 6) & 0x3F) | 0xC0;\n\t\t\t*utf_8++ = ((uc >> 0) & 0x3F) | 0x80;\n\t\t\tutf_8_len -= 2;\n\t\t} else if (uc < 0x010000) {\n\t\t\t/* 3 bytes. */\n\t\t\tif (utf_8_len < 4) {\n\t\t\t\t/*\n\t\t\t\t * Not enough room for those bytes\n\t\t\t\t * plus a trailing '\\0'.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*utf_8++ = ((uc >> 12) & 0x0F) | 0xE0;\n\t\t\t*utf_8++ = ((uc >> 6) & 0x3F) | 0x80;\n\t\t\t*utf_8++ = ((uc >> 0) & 0x3F) | 0x80;\n\t\t\tutf_8_len -= 3;\n\t\t} else {\n\t\t\t/* 4 bytes. */\n\t\t\tif (utf_8_len < 5) {\n\t\t\t\t/*\n\t\t\t\t * Not enough room for those bytes\n\t\t\t\t * plus a trailing '\\0'.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*utf_8++ = ((uc >> 18) & 0x03) | 0xF0;\n\t\t\t*utf_8++ = ((uc >> 12) & 0x3F) | 0x80;\n\t\t\t*utf_8++ = ((uc >> 6) & 0x3F) | 0x80;\n\t\t\t*utf_8++ = ((uc >> 0) & 0x3F) | 0x80;\n\t\t\tutf_8_len -= 3;\n\t\t}\n\t}\n\n\t/*\n\t * OK, we have enough room for (at least) a trailing '\\0'.\n\t * (We started out with enough room, thanks to the test\n\t * for a zero-length buffer at the beginning, and if\n\t * there wasn't enough room for any character we wanted\n\t * to put into the buffer *plus* a trailing '\\0',\n\t * we'd have quit before putting it into the buffer,\n\t * and thus would have left enough room for the trailing\n\t * '\\0'.)\n\t *\n\t * Drop it in.\n\t */\n\t*utf_8 = '\\0';\n\n\t/*\n\t * Return a pointer to the terminating '\\0', in case we\n\t * want to drop something in after that.\n\t */\n\treturn (utf_8);\n}\n#endif /* _WIN32 */\n\n/*\n * Generate an error message based on a format, arguments, and an\n * errno, with a message for the errno after the formatted output.\n */\nvoid\npcapint_fmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tpcapint_vfmt_errmsg_for_errno(errbuf, errbuflen, errnum, fmt, ap);\n\tva_end(ap);\n}\n\nvoid\npcapint_vfmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,\n    const char *fmt, va_list ap)\n{\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n\n\t(void)vsnprintf(errbuf, errbuflen, fmt, ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t */\n#if defined(HAVE__WCSERROR_S)\n\t/*\n\t * We have a Windows-style _wcserror_s().\n\t * Generate a UTF-16LE error message.\n\t */\n\twchar_t utf_16_errbuf[PCAP_ERRBUF_SIZE];\n\terrno_t err = _wcserror_s(utf_16_errbuf, PCAP_ERRBUF_SIZE, errnum);\n\tif (err != 0) {\n\t\t/*\n\t\t * It doesn't appear to be documented anywhere obvious\n\t\t * what the error returns from _wcserror_s().\n\t\t */\n\t\tsnprintf(p, errbuflen_remaining, \"Error %d\", errnum);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now convert it from UTF-16LE to UTF-8, dropping it in the\n\t * remaining space in the buffer, and truncating it - cleanly,\n\t * on a UTF-8 character boundary - if it doesn't fit.\n\t */\n\tutf_16le_to_utf_8_truncated(utf_16_errbuf, p, errbuflen_remaining);\n\n\t/*\n\t * Now, if we're not in UTF-8 mode, convert errbuf to the\n\t * local code page.\n\t */\n\tif (!use_utf_8)\n\t\tutf_8_to_acp_truncated(errbuf);\n#else\n\t/*\n\t * Either Windows without _wcserror_s() or not Windows.  Let pcap_strerror()\n\t * solve the non-UTF-16 part of this problem space.\n\t */\n\tsnprintf(p, errbuflen_remaining, \"%s\", pcap_strerror(errnum));\n#endif\n}\n\n#ifdef _WIN32\n/*\n * Generate an error message based on a format, arguments, and a\n * Win32 error, with a message for the Win32 error after the formatted output.\n */\nvoid\npcapint_fmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tpcapint_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errnum, fmt, ap);\n\tva_end(ap);\n}\n\nvoid\npcapint_vfmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,\n    const char *fmt, va_list ap)\n{\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n\tDWORD retval;\n\twchar_t utf_16_errbuf[PCAP_ERRBUF_SIZE];\n\tsize_t utf_8_len;\n\n\tvsnprintf(errbuf, errbuflen, fmt, ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\tmsglen += 2;\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t *\n\t * XXX - what language ID to use?\n\t *\n\t * For UN*Xes, pcap_strerror() may or may not return localized\n\t * strings.\n\t *\n\t * We currently don't have localized messages for libpcap, but\n\t * we might want to do so.  On the other hand, if most of these\n\t * messages are going to be read by libpcap developers and\n\t * perhaps by developers of libpcap-based applications, English\n\t * might be a better choice, so the developer doesn't have to\n\t * get the message translated if it's in a language they don't\n\t * happen to understand.\n\t */\n\tretval = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_MAX_WIDTH_MASK,\n\t    NULL, errnum, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t    utf_16_errbuf, PCAP_ERRBUF_SIZE, NULL);\n\tif (retval == 0) {\n\t\t/*\n\t\t * Failed.\n\t\t */\n\t\tsnprintf(p, errbuflen_remaining,\n\t\t    \"Couldn't get error message for error (%lu)\", errnum);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now convert it from UTF-16LE to UTF-8.\n\t */\n\tp = utf_16le_to_utf_8_truncated(utf_16_errbuf, p, errbuflen_remaining);\n\n\t/*\n\t * Now append the error number, if it fits.\n\t */\n\tutf_8_len = p - errbuf;\n\terrbuflen_remaining -= utf_8_len;\n\tif (utf_8_len == 0) {\n\t\t/* The message was empty. */\n\t\tsnprintf(p, errbuflen_remaining, \"(%lu)\", errnum);\n\t} else\n\t\tsnprintf(p, errbuflen_remaining, \" (%lu)\", errnum);\n\n\t/*\n\t * Now, if we're not in UTF-8 mode, convert errbuf to the\n\t * local code page.\n\t */\n\tif (!use_utf_8)\n\t\tutf_8_to_acp_truncated(errbuf);\n}\n#endif\n"
        },
        {
          "name": "fmtutils.h",
          "type": "blob",
          "size": 2.55078125,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef fmtutils_h\n#define\tfmtutils_h\n\n#include <stdarg.h>\t/* we declare varargs functions */\n\n#include \"pcap/funcattrs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid\tpcapint_fmt_set_encoding(unsigned int);\n\nvoid\tpcapint_fmt_errmsg_for_errno(char *, size_t, int,\n    PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);\nvoid\tpcapint_vfmt_errmsg_for_errno(char *, size_t, int,\n    PCAP_FORMAT_STRING(const char *), va_list) PCAP_PRINTFLIKE(4, 0);\n\n#ifdef _WIN32\nvoid\tpcapint_fmt_errmsg_for_win32_err(char *, size_t, DWORD,\n    PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);\nvoid\tpcapint_vfmt_errmsg_for_win32_err(char *, size_t, DWORD,\n    PCAP_FORMAT_STRING(const char *), va_list) PCAP_PRINTFLIKE(4, 0);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "ftmacros.h",
          "type": "blob",
          "size": 4.8330078125,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef ftmacros_h\n#define\tftmacros_h\n\n/*\n * Define some feature test macros to make sure that everything we want\n * to be declared gets declared.\n *\n * On some UN*Xes we need to force strtok_r() to be declared.\n * We do *NOT* want to define _POSIX_C_SOURCE, as that tends\n * to make non-POSIX APIs that we use unavailable.\n * XXX - is there no portable way to say \"please pollute the\n * namespace to the maximum extent possible\"?\n */\n#if defined(sun) || defined(__sun)\n  /*\n   * On Solaris Clang defines __EXTENSIONS__ automatically.\n   */\n  #ifndef __EXTENSIONS__\n    #define __EXTENSIONS__\n  #endif\n\n  /*\n   * We also need to define _XPG4_2 in order to get\n   * the Single UNIX Specification version of\n   * recvmsg().\n   */\n  #define _XPG4_2\n#elif defined(_hpux) || defined(hpux) || defined(__hpux)\n  #define _REENTRANT\n\n  /*\n   * We need this to get the versions of socket functions that\n   * use socklen_t.  Define it only if it's not already defined,\n   * so we don't get redefinition warnings.\n   */\n  #ifndef _XOPEN_SOURCE_EXTENDED\n    #define _XOPEN_SOURCE_EXTENDED\n  #endif\n\n  /*\n   * XXX - the list of PA-RISC options for GCC makes it sound as if\n   * building code that uses a particular vintage of UNIX API/ABI\n   * is complicated:\n   *\n   *    https://gcc.gnu.org/onlinedocs/gcc/HPPA-Options.html\n   *\n   * See the description of the -munix flag.\n   *\n   * We probably want libpcap to work with programs built for any\n   * UN*X standard.  I'm not sure whether that's possible and, if\n   * it is, what sort of stuff it'd have to do.\n   *\n   * It might also be a requirement that we build with a special\n   * flag to allow the library to be used with threaded code, at\n   * least with HP's C compiler; hopefully doing so won't make it\n   * *not* work with *un*-threaded code.\n   */\n#else\n  /*\n   * Turn on _GNU_SOURCE to get everything GNU libc has to offer,\n   * including asprintf(), if we're using GNU libc.\n   *\n   * Unfortunately, one thing it has to offer is a strerror_r()\n   * that's not POSIX-compliant, but we deal with that in\n   * pcapint_fmt_errmsg_for_errno().\n   *\n   * We don't limit this to, for example, Linux and Cygwin, because\n   * this might, for example, be GNU/HURD or one of Debian's kFreeBSD\n   * OSes (\"GNU/FreeBSD\").\n   *\n   * Avoid redefining, same as below.\n   */\n  #ifndef _GNU_SOURCE\n    #define _GNU_SOURCE\n  #endif\n\n  /*\n   * We turn on both _DEFAULT_SOURCE and _BSD_SOURCE to try to get\n   * the BSD u_XXX types, such as u_int and u_short, defined.  We\n   * define _DEFAULT_SOURCE first, so that newer versions of GNU libc\n   * don't whine about _BSD_SOURCE being deprecated; we still have\n   * to define _BSD_SOURCE to handle older versions of GNU libc that\n   * don't support _DEFAULT_SOURCE.\n   *\n   * But, if it's already defined, don't define it, so that we don't\n   * get a warning of it being redefined if it's defined as, for\n   * example, 1.\n   */\n  #ifndef _DEFAULT_SOURCE\n    #define _DEFAULT_SOURCE\n  #endif\n  /* Avoid redefining _BSD_SOURCE if it's already defined as for ex. 1 */\n  #ifndef _BSD_SOURCE\n    #define _BSD_SOURCE\n  #endif\n#endif\n\n#endif\n"
        },
        {
          "name": "gencode.c",
          "type": "blob",
          "size": 274.53125,
          "content": "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#ifdef _WIN32\n  #include <ws2tcpip.h>\n#else\n  #include <netinet/in.h>\n#endif /* _WIN32 */\n\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <setjmp.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdint.h>\n\n#include \"pcap-int.h\"\n\n#include \"extract.h\"\n\n#include \"ethertype.h\"\n#include \"llc.h\"\n#include \"gencode.h\"\n#include \"ieee80211.h\"\n#include \"pflog.h\"\n#include \"ppp.h\"\n#include \"pcap/sll.h\"\n#include \"pcap/ipnet.h\"\n#include \"diag-control.h\"\n#include \"pcap-util.h\"\n\n#include \"scanner.h\"\n\n#if defined(__linux__)\n#include <linux/types.h>\n#include <linux/if_packet.h>\n#include <linux/filter.h>\n#endif\n\n#ifndef offsetof\n#define offsetof(s, e) ((size_t)&((s *)0)->e)\n#endif\n\n#ifdef _WIN32\n  #ifdef INET6\n    #if defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF)\n/* IPv6 address */\nstruct in6_addr\n  {\n    union\n      {\n\tuint8_t\t\tu6_addr8[16];\n\tuint16_t\tu6_addr16[8];\n\tuint32_t\tu6_addr32[4];\n      } in6_u;\n#define s6_addr\t\t\tin6_u.u6_addr8\n#define s6_addr16\t\tin6_u.u6_addr16\n#define s6_addr32\t\tin6_u.u6_addr32\n#define s6_addr64\t\tin6_u.u6_addr64\n  };\n\ntypedef unsigned short\tsa_family_t;\n\n#define\t__SOCKADDR_COMMON(sa_prefix) \\\n  sa_family_t sa_prefix##family\n\n/* Ditto, for IPv6.  */\nstruct sockaddr_in6\n  {\n    __SOCKADDR_COMMON (sin6_);\n    uint16_t sin6_port;\t\t/* Transport layer port # */\n    uint32_t sin6_flowinfo;\t/* IPv6 flow information */\n    struct in6_addr sin6_addr;\t/* IPv6 address */\n  };\n\n      #ifndef EAI_ADDRFAMILY\nstruct addrinfo {\n\tint\tai_flags;\t/* AI_PASSIVE, AI_CANONNAME */\n\tint\tai_family;\t/* PF_xxx */\n\tint\tai_socktype;\t/* SOCK_xxx */\n\tint\tai_protocol;\t/* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n\tsize_t\tai_addrlen;\t/* length of ai_addr */\n\tchar\t*ai_canonname;\t/* canonical name for hostname */\n\tstruct sockaddr *ai_addr;\t/* binary address */\n\tstruct addrinfo *ai_next;\t/* next structure in linked list */\n};\n      #endif /* EAI_ADDRFAMILY */\n    #endif /* defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF) */\n  #endif /* INET6 */\n#else /* _WIN32 */\n  #include <netdb.h>\t/* for \"struct addrinfo\" */\n#endif /* _WIN32 */\n#include <pcap/namedb.h>\n\n#include \"nametoaddr.h\"\n\n#define ETHERMTU\t1500\n\n#ifndef IPPROTO_HOPOPTS\n#define IPPROTO_HOPOPTS 0\n#endif\n#ifndef IPPROTO_ROUTING\n#define IPPROTO_ROUTING 43\n#endif\n#ifndef IPPROTO_FRAGMENT\n#define IPPROTO_FRAGMENT 44\n#endif\n#ifndef IPPROTO_DSTOPTS\n#define IPPROTO_DSTOPTS 60\n#endif\n#ifndef IPPROTO_SCTP\n#define IPPROTO_SCTP 132\n#endif\n\n#define GENEVE_PORT 6081\n#define VXLAN_PORT  4789\n\n\n/*\n * from: NetBSD: if_arc.h,v 1.13 1999/11/19 20:41:19 thorpej Exp\n */\n\n/* RFC 1051 */\n#define\tARCTYPE_IP_OLD\t\t240\t/* IP protocol */\n#define\tARCTYPE_ARP_OLD\t\t241\t/* address resolution protocol */\n\n/* RFC 1201 */\n#define\tARCTYPE_IP\t\t212\t/* IP protocol */\n#define\tARCTYPE_ARP\t\t213\t/* address resolution protocol */\n#define\tARCTYPE_REVARP\t\t214\t/* reverse addr resolution protocol */\n\n#define\tARCTYPE_ATALK\t\t221\t/* Appletalk */\n#define\tARCTYPE_BANIAN\t\t247\t/* Banyan Vines */\n#define\tARCTYPE_IPX\t\t250\t/* Novell IPX */\n\n#define ARCTYPE_INET6\t\t0xc4\t/* IPng */\n#define ARCTYPE_DIAGNOSE\t0x80\t/* as per ANSI/ATA 878.1 */\n\n\n/* Based on UNI3.1 standard by ATM Forum */\n\n/* ATM traffic types based on VPI=0 and (the following VCI */\n#define VCI_PPC\t\t\t0x05\t/* Point-to-point signal msg */\n#define VCI_BCC\t\t\t0x02\t/* Broadcast signal msg */\n#define VCI_OAMF4SC\t\t0x03\t/* Segment OAM F4 flow cell */\n#define VCI_OAMF4EC\t\t0x04\t/* End-to-end OAM F4 flow cell */\n#define VCI_METAC\t\t0x01\t/* Meta signal msg */\n#define VCI_ILMIC\t\t0x10\t/* ILMI msg */\n\n/* Q.2931 signalling messages */\n#define CALL_PROCEED\t\t0x02\t/* call proceeding */\n#define CONNECT\t\t\t0x07\t/* connect */\n#define CONNECT_ACK\t\t0x0f\t/* connect_ack */\n#define SETUP\t\t\t0x05\t/* setup */\n#define RELEASE\t\t\t0x4d\t/* release */\n#define RELEASE_DONE\t\t0x5a\t/* release_done */\n#define RESTART\t\t\t0x46\t/* restart */\n#define RESTART_ACK\t\t0x4e\t/* restart ack */\n#define STATUS\t\t\t0x7d\t/* status */\n#define STATUS_ENQ\t\t0x75\t/* status ack */\n#define ADD_PARTY\t\t0x80\t/* add party */\n#define ADD_PARTY_ACK\t\t0x81\t/* add party ack */\n#define ADD_PARTY_REJ\t\t0x82\t/* add party rej */\n#define DROP_PARTY\t\t0x83\t/* drop party */\n#define DROP_PARTY_ACK\t\t0x84\t/* drop party ack */\n\n/* Information Element Parameters in the signalling messages */\n#define CAUSE\t\t\t0x08\t/* cause */\n#define ENDPT_REF\t\t0x54\t/* endpoint reference */\n#define AAL_PARA\t\t0x58\t/* ATM adaptation layer parameters */\n#define TRAFF_DESCRIP\t\t0x59\t/* atm traffic descriptors */\n#define CONNECT_ID\t\t0x5a\t/* connection identifier */\n#define QOS_PARA\t\t0x5c\t/* quality of service parameters */\n#define B_HIGHER\t\t0x5d\t/* broadband higher layer information */\n#define B_BEARER\t\t0x5e\t/* broadband bearer capability */\n#define B_LOWER\t\t\t0x5f\t/* broadband lower information */\n#define CALLING_PARTY\t\t0x6c\t/* calling party number */\n#define CALLED_PARTY\t\t0x70\t/* called party number */\n\n#define Q2931\t\t\t0x09\n\n/* Q.2931 signalling general messages format */\n#define PROTO_POS       0\t/* offset of protocol discriminator */\n#define CALL_REF_POS    2\t/* offset of call reference value */\n#define MSG_TYPE_POS    5\t/* offset of message type */\n#define MSG_LEN_POS     7\t/* offset of message length */\n#define IE_BEGIN_POS    9\t/* offset of first information element */\n\n/* format of signalling messages */\n#define TYPE_POS\t0\n#define LEN_POS\t\t2\n#define FIELD_BEGIN_POS 4\n\n\n/* SunATM header for ATM packet */\n#define SUNATM_DIR_POS\t\t0\n#define SUNATM_VPI_POS\t\t1\n#define SUNATM_VCI_POS\t\t2\n#define SUNATM_PKT_BEGIN_POS\t4\t/* Start of ATM packet */\n\n/* Protocol type values in the bottom for bits of the byte at SUNATM_DIR_POS. */\n#define PT_LANE\t\t0x01\t/* LANE */\n#define PT_LLC\t\t0x02\t/* LLC encapsulation */\n#define PT_ILMI\t\t0x05\t/* ILMI */\n#define PT_QSAAL\t0x06\t/* Q.SAAL */\n\n\n/* Types missing from some systems */\n\n/*\n * Network layer protocol identifiers\n */\n#ifndef ISO8473_CLNP\n#define ISO8473_CLNP\t\t0x81\n#endif\n#ifndef\tISO9542_ESIS\n#define\tISO9542_ESIS\t\t0x82\n#endif\n#ifndef ISO9542X25_ESIS\n#define ISO9542X25_ESIS\t\t0x8a\n#endif\n#ifndef\tISO10589_ISIS\n#define\tISO10589_ISIS\t\t0x83\n#endif\n\n#define ISIS_L1_LAN_IIH      15\n#define ISIS_L2_LAN_IIH      16\n#define ISIS_PTP_IIH         17\n#define ISIS_L1_LSP          18\n#define ISIS_L2_LSP          20\n#define ISIS_L1_CSNP         24\n#define ISIS_L2_CSNP         25\n#define ISIS_L1_PSNP         26\n#define ISIS_L2_PSNP         27\n\n#ifndef ISO8878A_CONS\n#define\tISO8878A_CONS\t\t0x84\n#endif\n#ifndef\tISO10747_IDRP\n#define\tISO10747_IDRP\t\t0x85\n#endif\n\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#define JMP(c) ((c)|BPF_JMP|BPF_K)\n\n/*\n * \"Push\" the current value of the link-layer header type and link-layer\n * header offset onto a \"stack\", and set a new value.  (It's not a\n * full-blown stack; we keep only the top two items.)\n */\n#define PUSH_LINKHDR(cs, new_linktype, new_is_variable, new_constant_part, new_reg) \\\n{ \\\n\t(cs)->prevlinktype = (cs)->linktype; \\\n\t(cs)->off_prevlinkhdr = (cs)->off_linkhdr; \\\n\t(cs)->linktype = (new_linktype); \\\n\t(cs)->off_linkhdr.is_variable = (new_is_variable); \\\n\t(cs)->off_linkhdr.constant_part = (new_constant_part); \\\n\t(cs)->off_linkhdr.reg = (new_reg); \\\n\t(cs)->is_encap = 0; \\\n}\n\n/*\n * Offset \"not set\" value.\n */\n#define OFFSET_NOT_SET\t0xffffffffU\n\n/*\n * Absolute offsets, which are offsets from the beginning of the raw\n * packet data, are, in the general case, the sum of a variable value\n * and a constant value; the variable value may be absent, in which\n * case the offset is only the constant value, and the constant value\n * may be zero, in which case the offset is only the variable value.\n *\n * bpf_abs_offset is a structure containing all that information:\n *\n *   is_variable is 1 if there's a variable part.\n *\n *   constant_part is the constant part of the value, possibly zero;\n *\n *   if is_variable is 1, reg is the register number for a register\n *   containing the variable value if the register has been assigned,\n *   and -1 otherwise.\n */\ntypedef struct {\n\tint\tis_variable;\n\tu_int\tconstant_part;\n\tint\treg;\n} bpf_abs_offset;\n\n/*\n * Value passed to gen_load_a() to indicate what the offset argument\n * is relative to the beginning of.\n */\nenum e_offrel {\n\tOR_PACKET,\t\t/* full packet data */\n\tOR_LINKHDR,\t\t/* link-layer header */\n\tOR_PREVLINKHDR,\t\t/* previous link-layer header */\n\tOR_LLC,\t\t\t/* 802.2 LLC header */\n\tOR_PREVMPLSHDR,\t\t/* previous MPLS header */\n\tOR_LINKTYPE,\t\t/* link-layer type */\n\tOR_LINKPL,\t\t/* link-layer payload */\n\tOR_LINKPL_NOSNAP,\t/* link-layer payload, with no SNAP header at the link layer */\n\tOR_TRAN_IPV4,\t\t/* transport-layer header, with IPv4 network layer */\n\tOR_TRAN_IPV6\t\t/* transport-layer header, with IPv6 network layer */\n};\n\n/*\n * We divvy out chunks of memory rather than call malloc each time so\n * we don't have to worry about leaking memory.  It's probably\n * not a big deal if all this memory was wasted but if this ever\n * goes into a library that would probably not be a good idea.\n *\n * XXX - this *is* in a library....\n */\n#define NCHUNKS 16\n#define CHUNK0SIZE 1024\nstruct chunk {\n\tsize_t n_left;\n\tvoid *m;\n};\n\n/*\n * A chunk can store any of:\n *  - a string (guaranteed alignment 1 but present for completeness)\n *  - a block\n *  - an slist\n *  - an arth\n * For this simple allocator every allocated chunk gets rounded up to the\n * alignment needed for any chunk.\n */\nstruct chunk_align {\n\tchar dummy;\n\tunion {\n\t\tchar c;\n\t\tstruct block b;\n\t\tstruct slist s;\n\t\tstruct arth a;\n\t} u;\n};\n#define CHUNK_ALIGN (offsetof(struct chunk_align, u))\n\n/* Code generator state */\n\nstruct _compiler_state {\n\tjmp_buf top_ctx;\n\tpcap_t *bpf_pcap;\n\tint error_set;\n\n\tstruct icode ic;\n\n\tint snaplen;\n\n\tint linktype;\n\tint prevlinktype;\n\tint outermostlinktype;\n\n\tbpf_u_int32 netmask;\n\tint no_optimize;\n\n\t/* Hack for handling VLAN and MPLS stacks. */\n\tu_int label_stack_depth;\n\tu_int vlan_stack_depth;\n\n\t/* XXX */\n\tu_int pcap_fddipad;\n\n\t/*\n\t * As errors are handled by a longjmp, anything allocated must\n\t * be freed in the longjmp handler, so it must be reachable\n\t * from that handler.\n\t *\n\t * One thing that's allocated is the result of pcap_nametoaddrinfo();\n\t * it must be freed with freeaddrinfo().  This variable points to\n\t * any addrinfo structure that would need to be freed.\n\t */\n\tstruct addrinfo *ai;\n\n\t/*\n\t * Another thing that's allocated is the result of pcap_ether_aton();\n\t * it must be freed with free().  This variable points to any\n\t * address that would need to be freed.\n\t */\n\tu_char *e;\n\n\t/*\n\t * Various code constructs need to know the layout of the packet.\n\t * These values give the necessary offsets from the beginning\n\t * of the packet data.\n\t */\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer header.\n\t */\n\tbpf_abs_offset off_linkhdr;\n\n\t/*\n\t * If we're checking a link-layer header for a packet encapsulated\n\t * in another protocol layer, this is the equivalent information\n\t * for the previous layers' link-layer header from the beginning\n\t * of the raw packet data.\n\t */\n\tbpf_abs_offset off_prevlinkhdr;\n\n\t/*\n\t * This is the equivalent information for the outermost layers'\n\t * link-layer header.\n\t */\n\tbpf_abs_offset off_outermostlinkhdr;\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer payload.\n\t */\n\tbpf_abs_offset off_linkpl;\n\n\t/*\n\t * \"off_linktype\" is the offset to information in the link-layer\n\t * header giving the packet type. This is an absolute offset\n\t * from the beginning of the packet.\n\t *\n\t * For Ethernet, it's the offset of the Ethernet type field; this\n\t * means that it must have a value that skips VLAN tags.\n\t *\n\t * For link-layer types that always use 802.2 headers, it's the\n\t * offset of the LLC header; this means that it must have a value\n\t * that skips VLAN tags.\n\t *\n\t * For PPP, it's the offset of the PPP type field.\n\t *\n\t * For Cisco HDLC, it's the offset of the CHDLC type field.\n\t *\n\t * For BSD loopback, it's the offset of the AF_ value.\n\t *\n\t * For Linux cooked sockets, it's the offset of the type field.\n\t *\n\t * off_linktype.constant_part is set to OFFSET_NOT_SET for no\n\t * encapsulation, in which case, IP is assumed.\n\t */\n\tbpf_abs_offset off_linktype;\n\n\t/*\n\t * TRUE if the link layer includes an ATM pseudo-header.\n\t */\n\tint is_atm;\n\n\t/* TRUE if \"geneve\" or \"vxlan\" appeared in the filter; it\n\t * causes us to generate code that checks for a Geneve or\n\t * VXLAN header respectively and assume that later filters\n\t * apply to the encapsulated payload.\n\t */\n\tint is_encap;\n\n\t/*\n\t * TRUE if we need variable length part of VLAN offset\n\t */\n\tint is_vlan_vloffset;\n\n\t/*\n\t * These are offsets for the ATM pseudo-header.\n\t */\n\tu_int off_vpi;\n\tu_int off_vci;\n\tu_int off_proto;\n\n\t/*\n\t * These are offsets for the MTP2 fields.\n\t */\n\tu_int off_li;\n\tu_int off_li_hsl;\n\n\t/*\n\t * These are offsets for the MTP3 fields.\n\t */\n\tu_int off_sio;\n\tu_int off_opc;\n\tu_int off_dpc;\n\tu_int off_sls;\n\n\t/*\n\t * This is the offset of the first byte after the ATM pseudo_header,\n\t * or -1 if there is no ATM pseudo-header.\n\t */\n\tu_int off_payload;\n\n\t/*\n\t * These are offsets to the beginning of the network-layer header.\n\t * They are relative to the beginning of the link-layer payload\n\t * (i.e., they don't include off_linkhdr.constant_part or\n\t * off_linkpl.constant_part).\n\t *\n\t * If the link layer never uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" and \"off_nl_nosnap\" are the same.\n\t *\n\t * If the link layer always uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" is the offset if there's a SNAP header following\n\t *\tthe 802.2 header;\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if there's no SNAP header.\n\t *\n\t * If the link layer is Ethernet:\n\t *\n\t *\t\"off_nl\" is the offset if the packet is an Ethernet II packet\n\t *\t(we assume no 802.3+802.2+SNAP);\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if the packet is an 802.3 packet\n\t *\twith an 802.2 header following it.\n\t */\n\tu_int off_nl;\n\tu_int off_nl_nosnap;\n\n\t/*\n\t * Here we handle simple allocation of the scratch registers.\n\t * If too many registers are alloc'd, the allocator punts.\n\t */\n\tint regused[BPF_MEMWORDS];\n\tint curreg;\n\n\t/*\n\t * Memory chunks.\n\t */\n\tstruct chunk chunks[NCHUNKS];\n\tint cur_chunk;\n};\n\n/*\n * For use by routines outside this file.\n */\n/* VARARGS */\nvoid\nbpf_set_error(compiler_state_t *cstate, const char *fmt, ...)\n{\n\tva_list ap;\n\n\t/*\n\t * If we've already set an error, don't override it.\n\t * The lexical analyzer reports some errors by setting\n\t * the error and then returning a LEX_ERROR token, which\n\t * is not recognized by any grammar rule, and thus forces\n\t * the parse to stop.  We don't want the error reported\n\t * by the lexical analyzer to be overwritten by the syntax\n\t * error.\n\t */\n\tif (!cstate->error_set) {\n\t\tva_start(ap, fmt);\n\t\t(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    fmt, ap);\n\t\tva_end(ap);\n\t\tcstate->error_set = 1;\n\t}\n}\n\n/*\n * For use *ONLY* in routines in this file.\n */\nstatic void PCAP_NORETURN bpf_error(compiler_state_t *, const char *, ...)\n    PCAP_PRINTFLIKE(2, 3);\n\n/* VARARGS */\nstatic void PCAP_NORETURN\nbpf_error(compiler_state_t *cstate, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,\n\t    fmt, ap);\n\tva_end(ap);\n\tlongjmp(cstate->top_ctx, 1);\n\t/*NOTREACHED*/\n#ifdef _AIX\n\tPCAP_UNREACHABLE\n#endif /* _AIX */\n}\n\nstatic int init_linktype(compiler_state_t *, pcap_t *);\n\nstatic void init_regs(compiler_state_t *);\nstatic int alloc_reg(compiler_state_t *);\nstatic void free_reg(compiler_state_t *, int);\n\nstatic void initchunks(compiler_state_t *cstate);\nstatic void *newchunk_nolongjmp(compiler_state_t *cstate, size_t);\nstatic void *newchunk(compiler_state_t *cstate, size_t);\nstatic void freechunks(compiler_state_t *cstate);\nstatic inline struct block *new_block(compiler_state_t *cstate, int);\nstatic inline struct slist *new_stmt(compiler_state_t *cstate, int);\nstatic struct block *gen_retblk(compiler_state_t *cstate, int);\nstatic inline void syntax(compiler_state_t *cstate);\n\nstatic void backpatch(struct block *, struct block *);\nstatic void merge(struct block *, struct block *);\nstatic struct block *gen_cmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32);\nstatic struct block *gen_cmp_gt(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32);\nstatic struct block *gen_cmp_ge(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32);\nstatic struct block *gen_cmp_lt(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32);\nstatic struct block *gen_cmp_le(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32);\nstatic struct block *gen_mcmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32, bpf_u_int32);\nstatic struct block *gen_bcmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, const u_char *);\nstatic struct block *gen_ncmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32, int, int, bpf_u_int32);\nstatic struct slist *gen_load_absoffsetrel(compiler_state_t *, bpf_abs_offset *,\n    u_int, u_int);\nstatic struct slist *gen_load_a(compiler_state_t *, enum e_offrel, u_int,\n    u_int);\nstatic struct slist *gen_loadx_iphdrlen(compiler_state_t *);\nstatic struct block *gen_uncond(compiler_state_t *, int);\nstatic inline struct block *gen_true(compiler_state_t *);\nstatic inline struct block *gen_false(compiler_state_t *);\nstatic struct block *gen_ether_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct block *gen_ipnet_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct block *gen_linux_sll_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct slist *gen_load_pflog_llprefixlen(compiler_state_t *);\nstatic struct slist *gen_load_prism_llprefixlen(compiler_state_t *);\nstatic struct slist *gen_load_avs_llprefixlen(compiler_state_t *);\nstatic struct slist *gen_load_radiotap_llprefixlen(compiler_state_t *);\nstatic struct slist *gen_load_ppi_llprefixlen(compiler_state_t *);\nstatic void insert_compute_vloffsets(compiler_state_t *, struct block *);\nstatic struct slist *gen_abs_offset_varpart(compiler_state_t *,\n    bpf_abs_offset *);\nstatic bpf_u_int32 ethertype_to_ppptype(bpf_u_int32);\nstatic struct block *gen_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct block *gen_snap(compiler_state_t *, bpf_u_int32, bpf_u_int32);\nstatic struct block *gen_llc_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct block *gen_hostop(compiler_state_t *, bpf_u_int32, bpf_u_int32,\n    int, bpf_u_int32, u_int, u_int);\n#ifdef INET6\nstatic struct block *gen_hostop6(compiler_state_t *, struct in6_addr *,\n    struct in6_addr *, int, bpf_u_int32, u_int, u_int);\n#endif\nstatic struct block *gen_ahostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_ehostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_fhostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_thostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_wlanhostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_ipfchostop(compiler_state_t *, const u_char *, int);\nstatic struct block *gen_dnhostop(compiler_state_t *, bpf_u_int32, int);\nstatic struct block *gen_mpls_linktype(compiler_state_t *, bpf_u_int32);\nstatic struct block *gen_host(compiler_state_t *, bpf_u_int32, bpf_u_int32,\n    int, int, int);\n#ifdef INET6\nstatic struct block *gen_host6(compiler_state_t *, struct in6_addr *,\n    struct in6_addr *, int, int, int);\n#endif\n#ifndef INET6\nstatic struct block *gen_gateway(compiler_state_t *, const u_char *,\n    struct addrinfo *, int, int);\n#endif\nstatic struct block *gen_ipfrag(compiler_state_t *);\nstatic struct block *gen_portatom(compiler_state_t *, int, bpf_u_int32);\nstatic struct block *gen_portrangeatom(compiler_state_t *, u_int, bpf_u_int32,\n    bpf_u_int32);\nstatic struct block *gen_portatom6(compiler_state_t *, int, bpf_u_int32);\nstatic struct block *gen_portrangeatom6(compiler_state_t *, u_int, bpf_u_int32,\n    bpf_u_int32);\nstatic struct block *gen_portop(compiler_state_t *, u_int, u_int, int);\nstatic struct block *gen_port(compiler_state_t *, u_int, int, int);\nstatic struct block *gen_portrangeop(compiler_state_t *, u_int, u_int,\n    bpf_u_int32, int);\nstatic struct block *gen_portrange(compiler_state_t *, u_int, u_int, int, int);\nstruct block *gen_portop6(compiler_state_t *, u_int, u_int, int);\nstatic struct block *gen_port6(compiler_state_t *, u_int, int, int);\nstatic struct block *gen_portrangeop6(compiler_state_t *, u_int, u_int,\n    bpf_u_int32, int);\nstatic struct block *gen_portrange6(compiler_state_t *, u_int, u_int, int, int);\nstatic int lookup_proto(compiler_state_t *, const char *, int);\n#if !defined(NO_PROTOCHAIN)\nstatic struct block *gen_protochain(compiler_state_t *, bpf_u_int32, int);\n#endif /* !defined(NO_PROTOCHAIN) */\nstatic struct block *gen_proto(compiler_state_t *, bpf_u_int32, int, int);\nstatic struct slist *xfer_to_x(compiler_state_t *, struct arth *);\nstatic struct slist *xfer_to_a(compiler_state_t *, struct arth *);\nstatic struct block *gen_mac_multicast(compiler_state_t *, int);\nstatic struct block *gen_len(compiler_state_t *, int, int);\nstatic struct block *gen_check_802_11_data_frame(compiler_state_t *);\nstatic struct block *gen_encap_ll_check(compiler_state_t *cstate);\n\nstatic struct block *gen_ppi_dlt_check(compiler_state_t *);\nstatic struct block *gen_atmfield_code_internal(compiler_state_t *, int,\n    bpf_u_int32, int, int);\nstatic struct block *gen_atmtype_llc(compiler_state_t *);\nstatic struct block *gen_msg_abbrev(compiler_state_t *, int type);\n\nstatic void\ninitchunks(compiler_state_t *cstate)\n{\n\tint i;\n\n\tfor (i = 0; i < NCHUNKS; i++) {\n\t\tcstate->chunks[i].n_left = 0;\n\t\tcstate->chunks[i].m = NULL;\n\t}\n\tcstate->cur_chunk = 0;\n}\n\nstatic void *\nnewchunk_nolongjmp(compiler_state_t *cstate, size_t n)\n{\n\tstruct chunk *cp;\n\tint k;\n\tsize_t size;\n\n\t/* Round up to chunk alignment. */\n\tn = (n + CHUNK_ALIGN - 1) & ~(CHUNK_ALIGN - 1);\n\n\tcp = &cstate->chunks[cstate->cur_chunk];\n\tif (n > cp->n_left) {\n\t\t++cp;\n\t\tk = ++cstate->cur_chunk;\n\t\tif (k >= NCHUNKS) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t\tsize = CHUNK0SIZE << k;\n\t\tcp->m = (void *)malloc(size);\n\t\tif (cp->m == NULL) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemset((char *)cp->m, 0, size);\n\t\tcp->n_left = size;\n\t\tif (n > size) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tcp->n_left -= n;\n\treturn (void *)((char *)cp->m + cp->n_left);\n}\n\nstatic void *\nnewchunk(compiler_state_t *cstate, size_t n)\n{\n\tvoid *p;\n\n\tp = newchunk_nolongjmp(cstate, n);\n\tif (p == NULL) {\n\t\tlongjmp(cstate->top_ctx, 1);\n\t\t/*NOTREACHED*/\n\t}\n\treturn (p);\n}\n\nstatic void\nfreechunks(compiler_state_t *cstate)\n{\n\tint i;\n\n\tfor (i = 0; i < NCHUNKS; ++i)\n\t\tif (cstate->chunks[i].m != NULL)\n\t\t\tfree(cstate->chunks[i].m);\n}\n\n/*\n * A strdup whose allocations are freed after code generation is over.\n * This is used by the lexical analyzer, so it can't longjmp; it just\n * returns NULL on an allocation error, and the callers must check\n * for it.\n */\nchar *\nsdup(compiler_state_t *cstate, const char *s)\n{\n\tsize_t n = strlen(s) + 1;\n\tchar *cp = newchunk_nolongjmp(cstate, n);\n\n\tif (cp == NULL)\n\t\treturn (NULL);\n\tpcapint_strlcpy(cp, s, n);\n\treturn (cp);\n}\n\nstatic inline struct block *\nnew_block(compiler_state_t *cstate, int code)\n{\n\tstruct block *p;\n\n\tp = (struct block *)newchunk(cstate, sizeof(*p));\n\tp->s.code = code;\n\tp->head = p;\n\n\treturn p;\n}\n\nstatic inline struct slist *\nnew_stmt(compiler_state_t *cstate, int code)\n{\n\tstruct slist *p;\n\n\tp = (struct slist *)newchunk(cstate, sizeof(*p));\n\tp->s.code = code;\n\n\treturn p;\n}\n\nstatic struct block *\ngen_retblk_internal(compiler_state_t *cstate, int v)\n{\n\tstruct block *b = new_block(cstate, BPF_RET|BPF_K);\n\n\tb->s.k = v;\n\treturn b;\n}\n\nstatic struct block *\ngen_retblk(compiler_state_t *cstate, int v)\n{\n\tif (setjmp(cstate->top_ctx)) {\n\t\t/*\n\t\t * gen_retblk() only fails because a memory\n\t\t * allocation failed in newchunk(), meaning\n\t\t * that it can't return a pointer.\n\t\t *\n\t\t * Return NULL.\n\t\t */\n\t\treturn NULL;\n\t}\n\treturn gen_retblk_internal(cstate, v);\n}\n\nstatic inline PCAP_NORETURN_DEF void\nsyntax(compiler_state_t *cstate)\n{\n\tbpf_error(cstate, \"syntax error in filter expression\");\n}\n\nint\npcap_compile(pcap_t *p, struct bpf_program *program,\n\t     const char *buf, int optimize, bpf_u_int32 mask)\n{\n#ifdef _WIN32\n\tint err;\n\tWSADATA wsaData;\n#endif\n\tcompiler_state_t cstate;\n\tyyscan_t scanner = NULL;\n\tYY_BUFFER_STATE in_buffer = NULL;\n\tu_int len;\n\tint rc;\n\n\t/*\n\t * If this pcap_t hasn't been activated, it doesn't have a\n\t * link-layer type, so we can't use it.\n\t */\n\tif (!p->activated) {\n\t\t(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"not-yet-activated pcap_t passed to pcap_compile\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n#ifdef _WIN32\n\t/*\n\t * Initialize Winsock, asking for the latest version (2.2),\n\t * as we may be calling Winsock routines to translate\n\t * host names to addresses.\n\t */\n\terr = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (err != 0) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"Error calling WSAStartup()\");\n\t\treturn (PCAP_ERROR);\n\t}\n#endif\n\n#ifdef ENABLE_REMOTE\n\t/*\n\t * If the device on which we're capturing need to be notified\n\t * that a new filter is being compiled, do so.\n\t *\n\t * This allows them to save a copy of it, in case, for example,\n\t * they're implementing a form of remote packet capture, and\n\t * want the remote machine to filter out the packets in which\n\t * it's sending the packets it's captured.\n\t *\n\t * XXX - the fact that we happen to be compiling a filter\n\t * doesn't necessarily mean we'll be installing it as the\n\t * filter for this pcap_t; we might be running it from userland\n\t * on captured packets to do packet classification.  We really\n\t * need a better way of handling this, but this is all that\n\t * the WinPcap remote capture code did.\n\t */\n\tif (p->save_current_filter_op != NULL)\n\t\t(p->save_current_filter_op)(p, buf);\n#endif\n\n\tinitchunks(&cstate);\n\tcstate.no_optimize = 0;\n#ifdef INET6\n\tcstate.ai = NULL;\n#endif\n\tcstate.e = NULL;\n\tcstate.ic.root = NULL;\n\tcstate.ic.cur_mark = 0;\n\tcstate.bpf_pcap = p;\n\tcstate.error_set = 0;\n\tinit_regs(&cstate);\n\n\tcstate.netmask = mask;\n\n\tcstate.snaplen = pcap_snapshot(p);\n\tif (cstate.snaplen == 0) {\n\t\t(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"snaplen of 0 rejects all packets\");\n\t\trc = PCAP_ERROR;\n\t\tgoto quit;\n\t}\n\n\tif (pcap_lex_init(&scanner) != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't initialize scanner\");\n\t\trc = PCAP_ERROR;\n\t\tgoto quit;\n\t}\n\tin_buffer = pcap__scan_string(buf ? buf : \"\", scanner);\n\n\t/*\n\t * Associate the compiler state with the lexical analyzer\n\t * state.\n\t */\n\tpcap_set_extra(&cstate, scanner);\n\n\tif (init_linktype(&cstate, p) == -1) {\n\t\trc = PCAP_ERROR;\n\t\tgoto quit;\n\t}\n\tif (pcap_parse(scanner, &cstate) != 0) {\n#ifdef INET6\n\t\tif (cstate.ai != NULL)\n\t\t\tfreeaddrinfo(cstate.ai);\n#endif\n\t\tif (cstate.e != NULL)\n\t\t\tfree(cstate.e);\n\t\trc = PCAP_ERROR;\n\t\tgoto quit;\n\t}\n\n\tif (cstate.ic.root == NULL) {\n\t\tcstate.ic.root = gen_retblk(&cstate, cstate.snaplen);\n\n\t\t/*\n\t\t * Catch errors reported by gen_retblk().\n\t\t */\n\t\tif (cstate.ic.root== NULL) {\n\t\t\trc = PCAP_ERROR;\n\t\t\tgoto quit;\n\t\t}\n\t}\n\n\tif (optimize && !cstate.no_optimize) {\n\t\tif (bpf_optimize(&cstate.ic, p->errbuf) == -1) {\n\t\t\t/* Failure */\n\t\t\trc = PCAP_ERROR;\n\t\t\tgoto quit;\n\t\t}\n\t\tif (cstate.ic.root == NULL ||\n\t\t    (cstate.ic.root->s.code == (BPF_RET|BPF_K) && cstate.ic.root->s.k == 0)) {\n\t\t\t(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"expression rejects all packets\");\n\t\t\trc = PCAP_ERROR;\n\t\t\tgoto quit;\n\t\t}\n\t}\n\tprogram->bf_insns = icode_to_fcode(&cstate.ic,\n\t    cstate.ic.root, &len, p->errbuf);\n\tif (program->bf_insns == NULL) {\n\t\t/* Failure */\n\t\trc = PCAP_ERROR;\n\t\tgoto quit;\n\t}\n\tprogram->bf_len = len;\n\n\trc = 0;  /* We're all okay */\n\nquit:\n\t/*\n\t * Clean up everything for the lexical analyzer.\n\t */\n\tif (in_buffer != NULL)\n\t\tpcap__delete_buffer(in_buffer, scanner);\n\tif (scanner != NULL)\n\t\tpcap_lex_destroy(scanner);\n\n\t/*\n\t * Clean up our own allocated memory.\n\t */\n\tfreechunks(&cstate);\n\n#ifdef _WIN32\n\tWSACleanup();\n#endif\n\n\treturn (rc);\n}\n\n/*\n * entry point for using the compiler with no pcap open\n * pass in all the stuff that is needed explicitly instead.\n */\nint\npcap_compile_nopcap(int snaplen_arg, int linktype_arg,\n\t\t    struct bpf_program *program,\n\t\t    const char *buf, int optimize, bpf_u_int32 mask)\n{\n\tpcap_t *p;\n\tint ret;\n\n\tp = pcap_open_dead(linktype_arg, snaplen_arg);\n\tif (p == NULL)\n\t\treturn (PCAP_ERROR);\n\tret = pcap_compile(p, program, buf, optimize, mask);\n\tpcap_close(p);\n\treturn (ret);\n}\n\n/*\n * Clean up a \"struct bpf_program\" by freeing all the memory allocated\n * in it.\n */\nvoid\npcap_freecode(struct bpf_program *program)\n{\n\tprogram->bf_len = 0;\n\tif (program->bf_insns != NULL) {\n\t\tfree((char *)program->bf_insns);\n\t\tprogram->bf_insns = NULL;\n\t}\n}\n\n/*\n * Backpatch the blocks in 'list' to 'target'.  The 'sense' field indicates\n * which of the jt and jf fields has been resolved and which is a pointer\n * back to another unresolved block (or nil).  At least one of the fields\n * in each block is already resolved.\n */\nstatic void\nbackpatch(struct block *list, struct block *target)\n{\n\tstruct block *next;\n\n\twhile (list) {\n\t\tif (!list->sense) {\n\t\t\tnext = JT(list);\n\t\t\tJT(list) = target;\n\t\t} else {\n\t\t\tnext = JF(list);\n\t\t\tJF(list) = target;\n\t\t}\n\t\tlist = next;\n\t}\n}\n\n/*\n * Merge the lists in b0 and b1, using the 'sense' field to indicate\n * which of jt and jf is the link.\n */\nstatic void\nmerge(struct block *b0, struct block *b1)\n{\n\tregister struct block **p = &b0;\n\n\t/* Find end of list. */\n\twhile (*p)\n\t\tp = !((*p)->sense) ? &JT(*p) : &JF(*p);\n\n\t/* Concatenate the lists. */\n\t*p = b1;\n}\n\nint\nfinish_parse(compiler_state_t *cstate, struct block *p)\n{\n\tstruct block *ppi_dlt_check;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return -1\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (-1);\n\n\t/*\n\t * Insert before the statements of the first (root) block any\n\t * statements needed to load the lengths of any variable-length\n\t * headers into registers.\n\t *\n\t * XXX - a fancier strategy would be to insert those before the\n\t * statements of all blocks that use those lengths and that\n\t * have no predecessors that use them, so that we only compute\n\t * the lengths if we need them.  There might be even better\n\t * approaches than that.\n\t *\n\t * However, those strategies would be more complicated, and\n\t * as we don't generate code to compute a length if the\n\t * program has no tests that use the length, and as most\n\t * tests will probably use those lengths, we would just\n\t * postpone computing the lengths so that it's not done\n\t * for tests that fail early, and it's not clear that's\n\t * worth the effort.\n\t */\n\tinsert_compute_vloffsets(cstate, p->head);\n\n\t/*\n\t * For DLT_PPI captures, generate a check of the per-packet\n\t * DLT value to make sure it's DLT_IEEE802_11.\n\t *\n\t * XXX - TurboCap cards use DLT_PPI for Ethernet.\n\t * Can we just define some DLT_ETHERNET_WITH_PHDR pseudo-header\n\t * with appropriate Ethernet information and use that rather\n\t * than using something such as DLT_PPI where you don't know\n\t * the link-layer header type until runtime, which, in the\n\t * general case, would force us to generate both Ethernet *and*\n\t * 802.11 code (*and* anything else for which PPI is used)\n\t * and choose between them early in the BPF program?\n\t */\n\tppi_dlt_check = gen_ppi_dlt_check(cstate);\n\tif (ppi_dlt_check != NULL)\n\t\tgen_and(ppi_dlt_check, p);\n\n\tbackpatch(p, gen_retblk_internal(cstate, cstate->snaplen));\n\tp->sense = !p->sense;\n\tbackpatch(p, gen_retblk_internal(cstate, 0));\n\tcstate->ic.root = p->head;\n\treturn (0);\n}\n\nvoid\ngen_and(struct block *b0, struct block *b1)\n{\n\tbackpatch(b0, b1->head);\n\tb0->sense = !b0->sense;\n\tb1->sense = !b1->sense;\n\tmerge(b1, b0);\n\tb1->sense = !b1->sense;\n\tb1->head = b0->head;\n}\n\nvoid\ngen_or(struct block *b0, struct block *b1)\n{\n\tb0->sense = !b0->sense;\n\tbackpatch(b0, b1->head);\n\tb0->sense = !b0->sense;\n\tmerge(b1, b0);\n\tb1->head = b0->head;\n}\n\nvoid\ngen_not(struct block *b)\n{\n\tb->sense = !b->sense;\n}\n\nstatic struct block *\ngen_cmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JEQ, 0, v);\n}\n\nstatic struct block *\ngen_cmp_gt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 0, v);\n}\n\nstatic struct block *\ngen_cmp_ge(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 0, v);\n}\n\nstatic struct block *\ngen_cmp_lt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 1, v);\n}\n\nstatic struct block *\ngen_cmp_le(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 1, v);\n}\n\nstatic struct block *\ngen_mcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v, bpf_u_int32 mask)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, mask, BPF_JEQ, 0, v);\n}\n\nstatic struct block *\ngen_bcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, const u_char *v)\n{\n\tregister struct block *b, *tmp;\n\n\tb = NULL;\n\twhile (size >= 4) {\n\t\tregister const u_char *p = &v[size - 4];\n\n\t\ttmp = gen_cmp(cstate, offrel, offset + size - 4, BPF_W,\n\t\t    EXTRACT_BE_U_4(p));\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t\tsize -= 4;\n\t}\n\twhile (size >= 2) {\n\t\tregister const u_char *p = &v[size - 2];\n\n\t\ttmp = gen_cmp(cstate, offrel, offset + size - 2, BPF_H,\n\t\t    EXTRACT_BE_U_2(p));\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t\tsize -= 2;\n\t}\n\tif (size > 0) {\n\t\ttmp = gen_cmp(cstate, offrel, offset, BPF_B, v[0]);\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t}\n\treturn b;\n}\n\n/*\n * AND the field of size \"size\" at offset \"offset\" relative to the header\n * specified by \"offrel\" with \"mask\", and compare it with the value \"v\"\n * with the test specified by \"jtype\"; if \"reverse\" is true, the test\n * should test the opposite of \"jtype\".\n */\nstatic struct block *\ngen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 mask, int jtype, int reverse,\n    bpf_u_int32 v)\n{\n\tstruct slist *s, *s2;\n\tstruct block *b;\n\n\ts = gen_load_a(cstate, offrel, offset, size);\n\n\tif (mask != 0xffffffff) {\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = mask;\n\t\tsappend(s, s2);\n\t}\n\n\tb = new_block(cstate, JMP(jtype));\n\tb->stmts = s;\n\tb->s.k = v;\n\tif (reverse)\n\t\tgen_not(b);\n\treturn b;\n}\n\nstatic int\ninit_linktype(compiler_state_t *cstate, pcap_t *p)\n{\n\tcstate->pcap_fddipad = p->fddipad;\n\n\t/*\n\t * We start out with only one link-layer header.\n\t */\n\tcstate->outermostlinktype = pcap_datalink(p);\n\tcstate->off_outermostlinkhdr.constant_part = 0;\n\tcstate->off_outermostlinkhdr.is_variable = 0;\n\tcstate->off_outermostlinkhdr.reg = -1;\n\n\tcstate->prevlinktype = cstate->outermostlinktype;\n\tcstate->off_prevlinkhdr.constant_part = 0;\n\tcstate->off_prevlinkhdr.is_variable = 0;\n\tcstate->off_prevlinkhdr.reg = -1;\n\n\tcstate->linktype = cstate->outermostlinktype;\n\tcstate->off_linkhdr.constant_part = 0;\n\tcstate->off_linkhdr.is_variable = 0;\n\tcstate->off_linkhdr.reg = -1;\n\n\t/*\n\t * XXX\n\t */\n\tcstate->off_linkpl.constant_part = 0;\n\tcstate->off_linkpl.is_variable = 0;\n\tcstate->off_linkpl.reg = -1;\n\n\tcstate->off_linktype.constant_part = 0;\n\tcstate->off_linktype.is_variable = 0;\n\tcstate->off_linktype.reg = -1;\n\n\t/*\n\t * Assume it's not raw ATM with a pseudo-header, for now.\n\t */\n\tcstate->is_atm = 0;\n\tcstate->off_vpi = OFFSET_NOT_SET;\n\tcstate->off_vci = OFFSET_NOT_SET;\n\tcstate->off_proto = OFFSET_NOT_SET;\n\tcstate->off_payload = OFFSET_NOT_SET;\n\n\t/*\n\t * And not encapsulated with either Geneve or VXLAN.\n\t */\n\tcstate->is_encap = 0;\n\n\t/*\n\t * No variable length VLAN offset by default\n\t */\n\tcstate->is_vlan_vloffset = 0;\n\n\t/*\n\t * And assume we're not doing SS7.\n\t */\n\tcstate->off_li = OFFSET_NOT_SET;\n\tcstate->off_li_hsl = OFFSET_NOT_SET;\n\tcstate->off_sio = OFFSET_NOT_SET;\n\tcstate->off_opc = OFFSET_NOT_SET;\n\tcstate->off_dpc = OFFSET_NOT_SET;\n\tcstate->off_sls = OFFSET_NOT_SET;\n\n\tcstate->label_stack_depth = 0;\n\tcstate->vlan_stack_depth = 0;\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_ARCNET:\n\t\tcstate->off_linktype.constant_part = 2;\n\t\tcstate->off_linkpl.constant_part = 6;\n\t\tcstate->off_nl = 0;\t\t/* XXX in reality, variable! */\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_ARCNET_LINUX:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 8;\n\t\tcstate->off_nl = 0;\t\t/* XXX in reality, variable! */\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_EN10MB:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = 14;\t/* Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_SLIP:\n\t\t/*\n\t\t * SLIP doesn't have a link level type.  The 16 byte\n\t\t * header is hacked into our SLIP driver.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_SLIP_BSDOS:\n\t\t/* XXX this may be the same as the DLT_PPP_BSDOS case */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\t/* XXX end */\n\t\tcstate->off_linkpl.constant_part = 24;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_NULL:\n\tcase DLT_LOOP:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_ENC:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP:\n\tcase DLT_PPP_PPPD:\n\tcase DLT_C_HDLC:\t\t/* BSD/OS Cisco HDLC */\n\tcase DLT_HDLC:\t\t\t/* NetBSD (Cisco) HDLC */\n\tcase DLT_PPP_SERIAL:\t\t/* NetBSD sync/async serial PPP */\n\t\tcstate->off_linktype.constant_part = 2;\t/* skip HDLC-like framing */\n\t\tcstate->off_linkpl.constant_part = 4;\t/* skip HDLC-like framing and protocol field */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP_ETHER:\n\t\t/*\n\t\t * This does no include the Ethernet header, and\n\t\t * only covers session state.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 8;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP_BSDOS:\n\t\tcstate->off_linktype.constant_part = 5;\n\t\tcstate->off_linkpl.constant_part = 24;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * FDDI doesn't really have a link-level type field.\n\t\t * We set \"off_linktype\" to the offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t */\n\t\tcstate->off_linktype.constant_part = 13;\n\t\tcstate->off_linktype.constant_part += cstate->pcap_fddipad;\n\t\tcstate->off_linkpl.constant_part = 13;\t/* FDDI MAC header length */\n\t\tcstate->off_linkpl.constant_part += cstate->pcap_fddipad;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_IEEE802:\n\t\t/*\n\t\t * Token Ring doesn't really have a link-level type field.\n\t\t * We set \"off_linktype\" to the offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t *\n\t\t * XXX - the header is actually variable-length.\n\t\t * Some various Linux patched versions gave 38\n\t\t * as \"off_linktype\" and 40 as \"off_nl\"; however,\n\t\t * if a token ring packet has *no* routing\n\t\t * information, i.e. is not source-routed, the correct\n\t\t * values are 20 and 22, as they are in the vanilla code.\n\t\t *\n\t\t * A packet is source-routed iff the uppermost bit\n\t\t * of the first byte of the source address, at an\n\t\t * offset of 8, has the uppermost bit set.  If the\n\t\t * packet is source-routed, the total number of bytes\n\t\t * of routing information is 2 plus bits 0x1F00 of\n\t\t * the 16-bit value at an offset of 14 (shifted right\n\t\t * 8 - figure out which byte that is).\n\t\t */\n\t\tcstate->off_linktype.constant_part = 14;\n\t\tcstate->off_linkpl.constant_part = 14;\t/* Token Ring MAC header length */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tcstate->off_linkhdr.is_variable = 1;\n\t\t/* Fall through, 802.11 doesn't have a variable link\n\t\t * prefix but is otherwise the same. */\n\t\t/* FALLTHROUGH */\n\n\tcase DLT_IEEE802_11:\n\t\t/*\n\t\t * 802.11 doesn't really have a link-level type field.\n\t\t * We set \"off_linktype.constant_part\" to the offset of\n\t\t * the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t *\n\t\t * We also handle variable-length radio headers here.\n\t\t * The Prism header is in theory variable-length, but in\n\t\t * practice it's always 144 bytes long.  However, some\n\t\t * drivers on Linux use ARPHRD_IEEE80211_PRISM, but\n\t\t * sometimes or always supply an AVS header, so we\n\t\t * have to check whether the radio header is a Prism\n\t\t * header or an AVS header, so, in practice, it's\n\t\t * variable-length.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 24;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* link-layer header is variable-length */\n\t\tcstate->off_linkpl.is_variable = 1;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_PPI:\n\t\t/*\n\t\t * At the moment we treat PPI the same way that we treat\n\t\t * normal Radiotap encoded packets. The difference is in\n\t\t * the function that generates the code at the beginning\n\t\t * to compute the header length.  Since this code generator\n\t\t * of PPI supports bare 802.11 encapsulation only (i.e.\n\t\t * the encapsulated DLT should be DLT_IEEE802_11) we\n\t\t * generate code to check for this too.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 24;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* link-layer header is variable-length */\n\t\tcstate->off_linkpl.is_variable = 1;\n\t\tcstate->off_linkhdr.is_variable = 1;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_ATM_RFC1483:\n\tcase DLT_ATM_CLIP:\t/* Linux ATM defines this */\n\t\t/*\n\t\t * assume routed, non-ISO PDUs\n\t\t * (i.e., LLC = 0xAA-AA-03, OUT = 0x00-00-00)\n\t\t *\n\t\t * XXX - what about ISO PDUs, e.g. CLNP, ISIS, ESIS,\n\t\t * or PPP with the PPP NLPID (e.g., PPPoA)?  The\n\t\t * latter would presumably be treated the way PPPoE\n\t\t * should be, so you can do \"pppoe and udp port 2049\"\n\t\t * or \"pppoa and tcp port 80\" and have it check for\n\t\t * PPPo{A,E} and a PPP protocol of IP and....\n\t\t */\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* packet begins with LLC header */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * Full Frontal ATM; you get AALn PDUs with an ATM\n\t\t * pseudo-header.\n\t\t */\n\t\tcstate->is_atm = 1;\n\t\tcstate->off_vpi = SUNATM_VPI_POS;\n\t\tcstate->off_vci = SUNATM_VCI_POS;\n\t\tcstate->off_proto = PROTO_POS;\n\t\tcstate->off_payload = SUNATM_PKT_BEGIN_POS;\n\t\tcstate->off_linktype.constant_part = cstate->off_payload;\n\t\tcstate->off_linkpl.constant_part = cstate->off_payload;\t/* if LLC-encapsulated */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_RAW:\n\tcase DLT_IPV4:\n\tcase DLT_IPV6:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\t/* fake header for Linux cooked socket v1 */\n\t\tcstate->off_linktype.constant_part = 14;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\t/* fake header for Linux cooked socket v2 */\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 20;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LTALK:\n\t\t/*\n\t\t * LocalTalk does have a 1-byte type field in the LLAP header,\n\t\t * but really it just indicates whether there is a \"short\" or\n\t\t * \"long\" DDP packet following.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_IP_OVER_FC:\n\t\t/*\n\t\t * RFC 2625 IP-over-Fibre-Channel doesn't really have a\n\t\t * link-level type field.  We set \"off_linktype\" to the\n\t\t * offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP? RFC\n\t\t * 2625 says SNAP should be used.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_FRELAY:\n\t\t/*\n\t\t * XXX - we should set this to handle SNAP-encapsulated\n\t\t * frames (NLPID of 0x80).\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\t\t/*\n\t\t * the only BPF-interesting FRF.16 frames are non-control frames;\n\t\t * Frame Relay has a variable length link-layer\n\t\t * so lets start with offset 4 for now and increments later on (FIXME);\n\t\t */\n\tcase DLT_MFR:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 4;\n\t\tcstate->off_nl_nosnap = 0;\t/* XXX - for now -> no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_APPLE_IP_OVER_IEEE1394:\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_linkpl.constant_part = 18;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_SYMANTEC_FIREWALL:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 44;\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 0;\t/* XXX - what does it do with 802.3 packets? */\n\t\tbreak;\n\n\tcase DLT_PFLOG:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* link-layer header is variable-length */\n\t\tcstate->off_linkpl.is_variable = 1;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_MFR:\n\tcase DLT_JUNIPER_MLFR:\n\tcase DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_PPP:\n\tcase DLT_JUNIPER_CHDLC:\n\tcase DLT_JUNIPER_FRELAY:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ATM1:\n\t\tcstate->off_linktype.constant_part = 4;\t\t/* in reality variable between 4-8 */\n\t\tcstate->off_linkpl.constant_part = 4;\t/* in reality variable between 4-8 */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 10;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ATM2:\n\t\tcstate->off_linktype.constant_part = 8;\t\t/* in reality variable between 8-12 */\n\t\tcstate->off_linkpl.constant_part = 8;\t/* in reality variable between 8-12 */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 10;\n\t\tbreak;\n\n\t\t/* frames captured on a Juniper PPPoE service PIC\n\t\t * contain raw ethernet frames */\n\tcase DLT_JUNIPER_PPPOE:\n        case DLT_JUNIPER_ETHER:\n\t\tcstate->off_linkpl.constant_part = 14;\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_nl = 18;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 21;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_PPPOE_ATM:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 6;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_GGSN:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ES:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\t/* not really a network layer but raw IP addresses */\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* not really a network layer but raw IP addresses */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_MONITOR:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\t\t\t/* raw IP/IP6 header */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_BACNET_MS_TP:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_SERVICES:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\t/* L3 proto location dep. on cookie type */\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* L3 proto location dep. on cookie type */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_VP:\n\t\tcstate->off_linktype.constant_part = 18;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ST:\n\t\tcstate->off_linktype.constant_part = 18;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ISM:\n\t\tcstate->off_linktype.constant_part = 8;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_VS:\n\tcase DLT_JUNIPER_SRX_E2E:\n\tcase DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\t\tcstate->off_linktype.constant_part = 8;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_MTP2:\n\t\tcstate->off_li = 2;\n\t\tcstate->off_li_hsl = 4;\n\t\tcstate->off_sio = 3;\n\t\tcstate->off_opc = 4;\n\t\tcstate->off_dpc = 4;\n\t\tcstate->off_sls = 7;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_MTP2_WITH_PHDR:\n\t\tcstate->off_li = 6;\n\t\tcstate->off_li_hsl = 8;\n\t\tcstate->off_sio = 7;\n\t\tcstate->off_opc = 8;\n\t\tcstate->off_dpc = 8;\n\t\tcstate->off_sls = 11;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_ERF:\n\t\tcstate->off_li = 22;\n\t\tcstate->off_li_hsl = 24;\n\t\tcstate->off_sio = 23;\n\t\tcstate->off_opc = 24;\n\t\tcstate->off_dpc = 24;\n\t\tcstate->off_sls = 27;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_PFSYNC:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\n\t\tbreak;\n\n\tcase DLT_AX25_KISS:\n\t\t/*\n\t\t * Currently, only raw \"link[N:M]\" filtering is supported.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\t/* variable, min 15, max 71 steps of 7 */\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* variable, min 16, max 71 steps of 7 */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_IPNET:\n\t\tcstate->off_linktype.constant_part = 1;\n\t\tcstate->off_linkpl.constant_part = 24;\t/* ipnet header length */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_NETANALYZER:\n\t\tcstate->off_linkhdr.constant_part = 4;\t/* Ethernet header is past 4-byte pseudo-header */\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* pseudo-header+Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\tcstate->off_linkhdr.constant_part = 12;\t/* MAC header is past 4-byte pseudo-header, preamble, and SFD */\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* pseudo-header+preamble+SFD+Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * For values in the range in which we've assigned new\n\t\t * DLT_ values, only raw \"link[N:M]\" filtering is supported.\n\t\t */\n\t\tif (cstate->linktype >= DLT_HIGH_MATCHING_MIN &&\n\t\t    cstate->linktype <= DLT_HIGH_MATCHING_MAX) {\n\t\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\t} else {\n\t\t\tbpf_set_error(cstate, \"unknown data link type %d (min %d, max %d)\",\n\t\t\t    cstate->linktype, DLT_HIGH_MATCHING_MIN, DLT_HIGH_MATCHING_MAX);\n\t\t\treturn (-1);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcstate->off_outermostlinkhdr = cstate->off_prevlinkhdr = cstate->off_linkhdr;\n\treturn (0);\n}\n\n/*\n * Load a value relative to the specified absolute offset.\n */\nstatic struct slist *\ngen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,\n    u_int offset, u_int size)\n{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, abs_offset);\n\n\t/*\n\t * If \"s\" is non-null, it has code to arrange that the X register\n\t * contains the variable part of the absolute offset, so we\n\t * generate a load relative to that, with an offset of\n\t * abs_offset->constant_part + offset.\n\t *\n\t * Otherwise, we can do an absolute load with an offset of\n\t * abs_offset->constant_part + offset.\n\t */\n\tif (s != NULL) {\n\t\t/*\n\t\t * \"s\" points to a list of statements that puts the\n\t\t * variable part of the absolute offset into the X register.\n\t\t * Do an indirect load, to use the X register as an offset.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|size);\n\t\ts2->s.k = abs_offset->constant_part + offset;\n\t\tsappend(s, s2);\n\t} else {\n\t\t/*\n\t\t * There is no variable part of the absolute offset, so\n\t\t * just do an absolute load.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LD|BPF_ABS|size);\n\t\ts->s.k = abs_offset->constant_part + offset;\n\t}\n\treturn s;\n}\n\n/*\n * Load a value relative to the beginning of the specified header.\n */\nstatic struct slist *\ngen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size)\n{\n\tstruct slist *s, *s2;\n\n\t/*\n\t * Squelch warnings from compilers that *don't* assume that\n\t * offrel always has a valid enum value and therefore don't\n\t * assume that we'll always go through one of the case arms.\n\t *\n\t * If we have a default case, compilers that *do* assume that\n\t * will then complain about the default case code being\n\t * unreachable.\n\t *\n\t * Damned if you do, damned if you don't.\n\t */\n\ts = NULL;\n\n\tswitch (offrel) {\n\n\tcase OR_PACKET:\n                s = new_stmt(cstate, BPF_LD|BPF_ABS|size);\n                s->s.k = offset;\n\t\tbreak;\n\n\tcase OR_LINKHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkhdr, offset, size);\n\t\tbreak;\n\n\tcase OR_PREVLINKHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_prevlinkhdr, offset, size);\n\t\tbreak;\n\n\tcase OR_LLC:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, offset, size);\n\t\tbreak;\n\n\tcase OR_PREVMPLSHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl - 4 + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKPL:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKPL_NOSNAP:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl_nosnap + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKTYPE:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linktype, offset, size);\n\t\tbreak;\n\n\tcase OR_TRAN_IPV4:\n\t\t/*\n\t\t * Load the X register with the length of the IPv4 header\n\t\t * (plus the offset of the link-layer header, if it's\n\t\t * preceded by a variable-length header such as a radio\n\t\t * header), in bytes.\n\t\t */\n\t\ts = gen_loadx_iphdrlen(cstate);\n\n\t\t/*\n\t\t * Load the item at {offset of the link-layer payload} +\n\t\t * {offset, relative to the start of the link-layer\n\t\t * payload, of the IPv4 header} + {length of the IPv4 header} +\n\t\t * {specified offset}.\n\t\t *\n\t\t * If the offset of the link-layer payload is variable,\n\t\t * the variable part of that offset is included in the\n\t\t * value in the X register, and we include the constant\n\t\t * part in the offset of the load.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|size);\n\t\ts2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + offset;\n\t\tsappend(s, s2);\n\t\tbreak;\n\n\tcase OR_TRAN_IPV6:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + 40 + offset, size);\n\t\tbreak;\n\t}\n\treturn s;\n}\n\n/*\n * Generate code to load into the X register the sum of the length of\n * the IPv4 header and the variable part of the offset of the link-layer\n * payload.\n */\nstatic struct slist *\ngen_loadx_iphdrlen(compiler_state_t *cstate)\n{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s != NULL) {\n\t\t/*\n\t\t * The offset of the link-layer payload has a variable\n\t\t * part.  \"s\" points to a list of statements that put\n\t\t * the variable part of that offset into the X register.\n\t\t *\n\t\t * The 4*([k]&0xf) addressing mode can't be used, as we\n\t\t * don't have a constant offset, so we have to load the\n\t\t * value in question into the A register and add to it\n\t\t * the value from the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xf;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\ts2->s.k = 2;\n\t\tsappend(s, s2);\n\n\t\t/*\n\t\t * The A register now contains the length of the IP header.\n\t\t * We need to add to it the variable part of the offset of\n\t\t * the link-layer payload, which is still in the X\n\t\t * register, and move the result into the X register.\n\t\t */\n\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t} else {\n\t\t/*\n\t\t * The offset of the link-layer payload is a constant,\n\t\t * so no code was generated to load the (nonexistent)\n\t\t * variable part of that offset.\n\t\t *\n\t\t * This means we can use the 4*([k]&0xf) addressing\n\t\t * mode.  Load the length of the IPv4 header, which\n\t\t * is at an offset of cstate->off_nl from the beginning of\n\t\t * the link-layer payload, and thus at an offset of\n\t\t * cstate->off_linkpl.constant_part + cstate->off_nl from the beginning\n\t\t * of the raw packet data, using that addressing mode.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);\n\t\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t}\n\treturn s;\n}\n\n\nstatic struct block *\ngen_uncond(compiler_state_t *cstate, int rsense)\n{\n\tstruct block *b;\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\ts->s.k = !rsense;\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s;\n\n\treturn b;\n}\n\nstatic inline struct block *\ngen_true(compiler_state_t *cstate)\n{\n\treturn gen_uncond(cstate, 1);\n}\n\nstatic inline struct block *\ngen_false(compiler_state_t *cstate)\n{\n\treturn gen_uncond(cstate, 0);\n}\n\n/*\n * Generate code to match a particular packet type.\n *\n * \"proto\" is an Ethernet type value, if > ETHERMTU, or an LLC SAP\n * value, if <= ETHERMTU.  We use that to determine whether to\n * match the type/length field or to check the type/length field for\n * a value <= ETHERMTU to see whether it's a type field and then do\n * the appropriate test.\n */\nstatic struct block *\ngen_ether_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_IP:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * OSI protocols and NetBEUI always use 802.2 encapsulation,\n\t\t * so we check the DSAP and SSAP.\n\t\t *\n\t\t * LLCSAP_IP checks for IP-over-802.2, rather\n\t\t * than IP-over-Ethernet or IP-over-SNAP.\n\t\t *\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other types <= ETHERMTU\n\t\t * (i.e., other SAP values)?\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t * Check for;\n\t\t *\n\t\t *\tEthernet_II frames, which are Ethernet\n\t\t *\tframes with a frame type of ETHERTYPE_IPX;\n\t\t *\n\t\t *\tEthernet_802.3 frames, which are 802.3\n\t\t *\tframes (i.e., the type/length field is\n\t\t *\ta length field, <= ETHERMTU, rather than\n\t\t *\ta type field) with the first two bytes\n\t\t *\tafter the Ethernet/802.3 header being\n\t\t *\t0xFFFF;\n\t\t *\n\t\t *\tEthernet_802.2 frames, which are 802.3\n\t\t *\tframes with an 802.2 LLC header and\n\t\t *\twith the IPX LSAP as the DSAP in the LLC\n\t\t *\theader;\n\t\t *\n\t\t *\tEthernet_SNAP frames, which are 802.3\n\t\t *\tframes with an LLC header and a SNAP\n\t\t *\theader and with an OUI of 0x000000\n\t\t *\t(encapsulated Ethernet) and a protocol\n\t\t *\tID of ETHERTYPE_IPX in the SNAP header.\n\t\t *\n\t\t * XXX - should we generate the same code both\n\t\t * for tests for LLCSAP_IPX and for ETHERTYPE_IPX?\n\t\t */\n\n\t\t/*\n\t\t * This generates code to check both for the\n\t\t * IPX LSAP (Ethernet_802.2) and for Ethernet_802.3.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now we add code to check for SNAP frames with\n\t\t * ETHERTYPE_IPX, i.e. Ethernet_SNAP.\n\t\t */\n\t\tb0 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now we generate code to check for 802.3\n\t\t * frames in general.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * Now add the check for 802.3 frames before the\n\t\t * check for Ethernet_802.2 and Ethernet_802.3,\n\t\t * as those checks should only be done on 802.3\n\t\t * frames, not on Ethernet frames.\n\t\t */\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Now add the check for Ethernet_II frames, and\n\t\t * do that before checking for the other frame\n\t\t * types.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase ETHERTYPE_ATALK:\n\tcase ETHERTYPE_AARP:\n\t\t/*\n\t\t * EtherTalk (AppleTalk protocols on Ethernet link\n\t\t * layer) may use 802.2 encapsulation.\n\t\t */\n\n\t\t/*\n\t\t * Check for 802.2 encapsulation (EtherTalk phase 2?);\n\t\t * we check for an Ethernet type field less than\n\t\t * 1500, which means it's an 802.3 length field.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * 802.2-encapsulated ETHERTYPE_AARP packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x000000 (encapsulated Ethernet) and a protocol\n\t\t * type of ETHERTYPE_AARP (Appletalk ARP).\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_ATALK)\n\t\t\tb1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\t\telse\t/* ll_proto == ETHERTYPE_AARP */\n\t\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Check for Ethernet encapsulation (Ethertalk\n\t\t * phase 1?); we just check for the Ethernet\n\t\t * protocol type.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tdefault:\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so the frames\n\t\t\t * that match would be 802.2 frames.\n\t\t\t * Check that the frame is an 802.2 frame\n\t\t\t * (i.e., that the length/type field is\n\t\t\t * a length field, <= ETHERMTU) and\n\t\t\t * then check the DSAP.\n\t\t\t */\n\t\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\t\tgen_not(b0);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 2, BPF_B, ll_proto);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type, so compare\n\t\t\t * the length/type field with it (if\n\t\t\t * the frame is an 802.2 frame, the length\n\t\t\t * field will be <= ETHERMTU, and, as\n\t\t\t * \"ll_proto\" is > ETHERMTU, this test\n\t\t\t * will fail and the frame won't match,\n\t\t\t * which is what we want).\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t}\n\t}\n}\n\nstatic struct block *\ngen_loopback_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\t/*\n\t * For DLT_NULL, the link-layer header is a 32-bit word\n\t * containing an AF_ value in *host* byte order, and for\n\t * DLT_ENC, the link-layer header begins with a 32-bit\n\t * word containing an AF_ value in host byte order.\n\t *\n\t * In addition, if we're reading a saved capture file,\n\t * the host byte order in the capture may not be the\n\t * same as the host byte order on this machine.\n\t *\n\t * For DLT_LOOP, the link-layer header is a 32-bit\n\t * word containing an AF_ value in *network* byte order.\n\t */\n\tif (cstate->linktype == DLT_NULL || cstate->linktype == DLT_ENC) {\n\t\t/*\n\t\t * The AF_ value is in host byte order, but the BPF\n\t\t * interpreter will convert it to network byte order.\n\t\t *\n\t\t * If this is a save file, and it's from a machine\n\t\t * with the opposite byte order to ours, we byte-swap\n\t\t * the AF_ value.\n\t\t *\n\t\t * Then we run it through \"htonl()\", and generate\n\t\t * code to compare against the result.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL && cstate->bpf_pcap->swapped)\n\t\t\tll_proto = SWAPLONG(ll_proto);\n\t\tll_proto = htonl(ll_proto);\n\t}\n\treturn (gen_cmp(cstate, OR_LINKHDR, 0, BPF_W, ll_proto));\n}\n\n/*\n * \"proto\" is an Ethernet type value and for IPNET, if it is not IPv4\n * or IPv6 then we have an error.\n */\nstatic struct block *\ngen_ipnet_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tswitch (ll_proto) {\n\n\tcase ETHERTYPE_IP:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET);\n\t\t/*NOTREACHED*/\n\n\tcase ETHERTYPE_IPV6:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET6);\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn gen_false(cstate);\n}\n\n/*\n * Generate code to match a particular packet type.\n *\n * \"ll_proto\" is an Ethernet type value, if > ETHERMTU, or an LLC SAP\n * value, if <= ETHERMTU.  We use that to determine whether to\n * match the type field or to check the type field for the special\n * LINUX_SLL_P_802_2 value and then do the appropriate test.\n */\nstatic struct block *\ngen_linux_sll_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_IP:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * OSI protocols and NetBEUI always use 802.2 encapsulation,\n\t\t * so we check the DSAP and SSAP.\n\t\t *\n\t\t * LLCSAP_IP checks for IP-over-802.2, rather\n\t\t * than IP-over-Ethernet or IP-over-SNAP.\n\t\t *\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other types <= ETHERMTU\n\t\t * (i.e., other SAP values)?\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t *\tEthernet_II frames, which are Ethernet\n\t\t *\tframes with a frame type of ETHERTYPE_IPX;\n\t\t *\n\t\t *\tEthernet_802.3 frames, which have a frame\n\t\t *\ttype of LINUX_SLL_P_802_3;\n\t\t *\n\t\t *\tEthernet_802.2 frames, which are 802.3\n\t\t *\tframes with an 802.2 LLC header (i.e, have\n\t\t *\ta frame type of LINUX_SLL_P_802_2) and\n\t\t *\twith the IPX LSAP as the DSAP in the LLC\n\t\t *\theader;\n\t\t *\n\t\t *\tEthernet_SNAP frames, which are 802.3\n\t\t *\tframes with an LLC header and a SNAP\n\t\t *\theader and with an OUI of 0x000000\n\t\t *\t(encapsulated Ethernet) and a protocol\n\t\t *\tID of ETHERTYPE_IPX in the SNAP header.\n\t\t *\n\t\t * First, do the checks on LINUX_SLL_P_802_2\n\t\t * frames; generate the check for either\n\t\t * Ethernet_802.2 or Ethernet_SNAP frames, and\n\t\t * then put a check for LINUX_SLL_P_802_2 frames\n\t\t * before it.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Now check for 802.3 frames and OR that with\n\t\t * the previous test.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_3);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now add the check for Ethernet_II frames, and\n\t\t * do that before checking for the other frame\n\t\t * types.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase ETHERTYPE_ATALK:\n\tcase ETHERTYPE_AARP:\n\t\t/*\n\t\t * EtherTalk (AppleTalk protocols on Ethernet link\n\t\t * layer) may use 802.2 encapsulation.\n\t\t */\n\n\t\t/*\n\t\t * Check for 802.2 encapsulation (EtherTalk phase 2?);\n\t\t * we check for the 802.2 protocol type in the\n\t\t * \"Ethernet type\" field.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * 802.2-encapsulated ETHERTYPE_AARP packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x000000 (encapsulated Ethernet) and a protocol\n\t\t * type of ETHERTYPE_AARP (Appletalk ARP).\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_ATALK)\n\t\t\tb1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\t\telse\t/* ll_proto == ETHERTYPE_AARP */\n\t\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Check for Ethernet encapsulation (Ethertalk\n\t\t * phase 1?); we just check for the Ethernet\n\t\t * protocol type.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tdefault:\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so the frames\n\t\t\t * that match would be 802.2 frames.\n\t\t\t * Check for the 802.2 protocol type\n\t\t\t * in the \"Ethernet type\" field, and\n\t\t\t * then check the DSAP.\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKHDR, cstate->off_linkpl.constant_part, BPF_B,\n\t\t\t     ll_proto);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type, so compare\n\t\t\t * the length/type field with it (if\n\t\t\t * the frame is an 802.2 frame, the length\n\t\t\t * field will be <= ETHERMTU, and, as\n\t\t\t * \"ll_proto\" is > ETHERMTU, this test\n\t\t\t * will fail and the frame won't match,\n\t\t\t * which is what we want).\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t}\n\t}\n}\n\n/*\n * Load a value relative to the beginning of the link-layer header after the\n * pflog header.\n */\nstatic struct slist *\ngen_load_pflog_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the pflog header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t */\n\tif (cstate->off_linkpl.reg != -1) {\n\t\t/*\n\t\t * The length is in the first byte of the header.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\ts1->s.k = 0;\n\n\t\t/*\n\t\t * Round it up to a multiple of 4.\n\t\t * Add 3, and clear the lower 2 bits.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\t\ts2->s.k = 3;\n\t\tsappend(s1, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xfffffffc;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}\n\nstatic struct slist *\ngen_load_prism_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\tstruct slist *sjeq_avs_cookie;\n\tstruct slist *sjcommon;\n\n\t/*\n\t * This code is not compatible with the optimizer, as\n\t * we are generating jmp instructions within a normal\n\t * slist of instructions\n\t */\n\tcstate->no_optimize = 1;\n\n\t/*\n\t * Generate code to load the length of the radio header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t *\n\t * Some Linux drivers use ARPHRD_IEEE80211_PRISM but sometimes\n\t * or always use the AVS header rather than the Prism header.\n\t * We load a 4-byte big-endian value at the beginning of the\n\t * raw packet data, and see whether, when masked with 0xFFFFF000,\n\t * it's equal to 0x80211000.  If so, that indicates that it's\n\t * an AVS header (the masked-out bits are the version number).\n\t * Otherwise, it's a Prism header.\n\t *\n\t * XXX - the Prism header is also, in theory, variable-length,\n\t * but no known software generates headers that aren't 144\n\t * bytes long.\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * Load the cookie.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts1->s.k = 0;\n\n\t\t/*\n\t\t * AND it with 0xFFFFF000.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xFFFFF000;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Compare with 0x80211000.\n\t\t */\n\t\tsjeq_avs_cookie = new_stmt(cstate, JMP(BPF_JEQ));\n\t\tsjeq_avs_cookie->s.k = 0x80211000;\n\t\tsappend(s1, sjeq_avs_cookie);\n\n\t\t/*\n\t\t * If it's AVS:\n\t\t *\n\t\t * The 4 bytes at an offset of 4 from the beginning of\n\t\t * the AVS header are the length of the AVS header.\n\t\t * That field is big-endian.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts2->s.k = 4;\n\t\tsappend(s1, s2);\n\t\tsjeq_avs_cookie->s.jt = s2;\n\n\t\t/*\n\t\t * Now jump to the code to allocate a register\n\t\t * into which to save the header length and\n\t\t * store the length there.  (The \"jump always\"\n\t\t * instruction needs to have the k field set;\n\t\t * it's added to the PC, so, as we're jumping\n\t\t * over a single instruction, it should be 1.)\n\t\t */\n\t\tsjcommon = new_stmt(cstate, JMP(BPF_JA));\n\t\tsjcommon->s.k = 1;\n\t\tsappend(s1, sjcommon);\n\n\t\t/*\n\t\t * Now for the code that handles the Prism header.\n\t\t * Just load the length of the Prism header (144)\n\t\t * into the A register.  Have the test for an AVS\n\t\t * header branch here if we don't have an AVS header.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);\n\t\ts2->s.k = 144;\n\t\tsappend(s1, s2);\n\t\tsjeq_avs_cookie->s.jf = s2;\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.  The code for the AVS header will jump here after\n\t\t * loading the length of the AVS header.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\t\tsjcommon->s.jf = s2;\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}\n\nstatic struct slist *\ngen_load_avs_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the AVS header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 4 bytes at an offset of 4 from the beginning of\n\t\t * the AVS header are the length of the AVS header.\n\t\t * That field is big-endian.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts1->s.k = 4;\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}\n\nstatic struct slist *\ngen_load_radiotap_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the radiotap header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 2 bytes at offsets of 2 and 3 from the beginning\n\t\t * of the radiotap header are the length of the radiotap\n\t\t * header; unfortunately, it's little-endian, so we have\n\t\t * to load it a byte at a time and construct the value.\n\t\t */\n\n\t\t/*\n\t\t * Load the high-order byte, at an offset of 3, shift it\n\t\t * left a byte, and put the result in the X register.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\ts1->s.k = 3;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 8;\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Load the next byte, at an offset of 2, and OR the\n\t\t * value from the X register into it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 2;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}\n\n/*\n * At the moment we treat PPI as normal Radiotap encoded\n * packets. The difference is in the function that generates\n * the code at the beginning to compute the header length.\n * Since this code generator of PPI supports bare 802.11\n * encapsulation only (i.e. the encapsulated DLT should be\n * DLT_IEEE802_11) we generate code to check for this too;\n * that's done in finish_parse().\n */\nstatic struct slist *\ngen_load_ppi_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the radiotap header\n\t * into the register assigned to hold that length, if one has\n\t * been assigned.\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 2 bytes at offsets of 2 and 3 from the beginning\n\t\t * of the radiotap header are the length of the radiotap\n\t\t * header; unfortunately, it's little-endian, so we have\n\t\t * to load it a byte at a time and construct the value.\n\t\t */\n\n\t\t/*\n\t\t * Load the high-order byte, at an offset of 3, shift it\n\t\t * left a byte, and put the result in the X register.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\ts1->s.k = 3;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 8;\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Load the next byte, at an offset of 2, and OR the\n\t\t * value from the X register into it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 2;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}\n\n/*\n * Load a value relative to the beginning of the link-layer header after the 802.11\n * header, i.e. LLC_SNAP.\n * The link-layer header doesn't necessarily begin at the beginning\n * of the packet data; there might be a variable-length prefix containing\n * radio information.\n */\nstatic struct slist *\ngen_load_802_11_header_len(compiler_state_t *cstate, struct slist *s, struct slist *snext)\n{\n\tstruct slist *s2;\n\tstruct slist *sjset_data_frame_1;\n\tstruct slist *sjset_data_frame_2;\n\tstruct slist *sjset_qos;\n\tstruct slist *sjset_radiotap_flags_present;\n\tstruct slist *sjset_radiotap_ext_present;\n\tstruct slist *sjset_radiotap_tsft_present;\n\tstruct slist *sjset_tsft_datapad, *sjset_notsft_datapad;\n\tstruct slist *s_roundup;\n\n\tif (cstate->off_linkpl.reg == -1) {\n\t\t/*\n\t\t * No register has been assigned to the offset of\n\t\t * the link-layer payload, which means nobody needs\n\t\t * it; don't bother computing it - just return\n\t\t * what we already have.\n\t\t */\n\t\treturn (s);\n\t}\n\n\t/*\n\t * This code is not compatible with the optimizer, as\n\t * we are generating jmp instructions within a normal\n\t * slist of instructions\n\t */\n\tcstate->no_optimize = 1;\n\n\t/*\n\t * If \"s\" is non-null, it has code to arrange that the X register\n\t * contains the length of the prefix preceding the link-layer\n\t * header.\n\t *\n\t * Otherwise, the length of the prefix preceding the link-layer\n\t * header is \"off_outermostlinkhdr.constant_part\".\n\t */\n\tif (s == NULL) {\n\t\t/*\n\t\t * There is no variable-length header preceding the\n\t\t * link-layer header.\n\t\t *\n\t\t * Load the length of the fixed-length prefix preceding\n\t\t * the link-layer header (if any) into the X register,\n\t\t * and store it in the cstate->off_linkpl.reg register.\n\t\t * That length is off_outermostlinkhdr.constant_part.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_IMM);\n\t\ts->s.k = cstate->off_outermostlinkhdr.constant_part;\n\t}\n\n\t/*\n\t * The X register contains the offset of the beginning of the\n\t * link-layer header; add 24, which is the minimum length\n\t * of the MAC header for a data frame, to that, and store it\n\t * in cstate->off_linkpl.reg, and then load the Frame Control field,\n\t * which is at the offset in the X register, with an indexed load.\n\t */\n\ts2 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts2->s.k = 24;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts2->s.k = 0;\n\tsappend(s, s2);\n\n\t/*\n\t * Check the Frame Control field to see if this is a data frame;\n\t * a data frame has the 0x08 bit (b3) in that field set and the\n\t * 0x04 bit (b2) clear.\n\t */\n\tsjset_data_frame_1 = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_data_frame_1->s.k = 0x08;\n\tsappend(s, sjset_data_frame_1);\n\n\t/*\n\t * If b3 is set, test b2, otherwise go to the first statement of\n\t * the rest of the program.\n\t */\n\tsjset_data_frame_1->s.jt = sjset_data_frame_2 = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_data_frame_2->s.k = 0x04;\n\tsappend(s, sjset_data_frame_2);\n\tsjset_data_frame_1->s.jf = snext;\n\n\t/*\n\t * If b2 is not set, this is a data frame; test the QoS bit.\n\t * Otherwise, go to the first statement of the rest of the\n\t * program.\n\t */\n\tsjset_data_frame_2->s.jt = snext;\n\tsjset_data_frame_2->s.jf = sjset_qos = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_qos->s.k = 0x80;\t/* QoS bit */\n\tsappend(s, sjset_qos);\n\n\t/*\n\t * If it's set, add 2 to cstate->off_linkpl.reg, to skip the QoS\n\t * field.\n\t * Otherwise, go to the first statement of the rest of the\n\t * program.\n\t */\n\tsjset_qos->s.jt = s2 = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\ts2->s.k = 2;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\n\t/*\n\t * If we have a radiotap header, look at it to see whether\n\t * there's Atheros padding between the MAC-layer header\n\t * and the payload.\n\t *\n\t * Note: all of the fields in the radiotap header are\n\t * little-endian, so we byte-swap all of the values\n\t * we test against, as they will be loaded as big-endian\n\t * values.\n\t *\n\t * XXX - in the general case, we would have to scan through\n\t * *all* the presence bits, if there's more than one word of\n\t * presence bits.  That would require a loop, meaning that\n\t * we wouldn't be able to run the filter in the kernel.\n\t *\n\t * We assume here that the Atheros adapters that insert the\n\t * annoying padding don't have multiple antennae and therefore\n\t * do not generate radiotap headers with multiple presence words.\n\t */\n\tif (cstate->linktype == DLT_IEEE802_11_RADIO) {\n\t\t/*\n\t\t * Is the IEEE80211_RADIOTAP_FLAGS bit (0x0000002) set\n\t\t * in the first presence flag word?\n\t\t */\n\t\tsjset_qos->s.jf = s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_W);\n\t\ts2->s.k = 4;\n\t\tsappend(s, s2);\n\n\t\tsjset_radiotap_flags_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_flags_present->s.k = SWAPLONG(0x00000002);\n\t\tsappend(s, sjset_radiotap_flags_present);\n\n\t\t/*\n\t\t * If not, skip all of this.\n\t\t */\n\t\tsjset_radiotap_flags_present->s.jf = snext;\n\n\t\t/*\n\t\t * Otherwise, is the \"extension\" bit set in that word?\n\t\t */\n\t\tsjset_radiotap_ext_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_ext_present->s.k = SWAPLONG(0x80000000);\n\t\tsappend(s, sjset_radiotap_ext_present);\n\t\tsjset_radiotap_flags_present->s.jt = sjset_radiotap_ext_present;\n\n\t\t/*\n\t\t * If so, skip all of this.\n\t\t */\n\t\tsjset_radiotap_ext_present->s.jt = snext;\n\n\t\t/*\n\t\t * Otherwise, is the IEEE80211_RADIOTAP_TSFT bit set?\n\t\t */\n\t\tsjset_radiotap_tsft_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_tsft_present->s.k = SWAPLONG(0x00000001);\n\t\tsappend(s, sjset_radiotap_tsft_present);\n\t\tsjset_radiotap_ext_present->s.jf = sjset_radiotap_tsft_present;\n\n\t\t/*\n\t\t * If IEEE80211_RADIOTAP_TSFT is set, the flags field is\n\t\t * at an offset of 16 from the beginning of the raw packet\n\t\t * data (8 bytes for the radiotap header and 8 bytes for\n\t\t * the TSFT field).\n\t\t *\n\t\t * Test whether the IEEE80211_RADIOTAP_F_DATAPAD bit (0x20)\n\t\t * is set.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts2->s.k = 16;\n\t\tsappend(s, s2);\n\t\tsjset_radiotap_tsft_present->s.jt = s2;\n\n\t\tsjset_tsft_datapad = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_tsft_datapad->s.k = 0x20;\n\t\tsappend(s, sjset_tsft_datapad);\n\n\t\t/*\n\t\t * If IEEE80211_RADIOTAP_TSFT is not set, the flags field is\n\t\t * at an offset of 8 from the beginning of the raw packet\n\t\t * data (8 bytes for the radiotap header).\n\t\t *\n\t\t * Test whether the IEEE80211_RADIOTAP_F_DATAPAD bit (0x20)\n\t\t * is set.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts2->s.k = 8;\n\t\tsappend(s, s2);\n\t\tsjset_radiotap_tsft_present->s.jf = s2;\n\n\t\tsjset_notsft_datapad = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_notsft_datapad->s.k = 0x20;\n\t\tsappend(s, sjset_notsft_datapad);\n\n\t\t/*\n\t\t * In either case, if IEEE80211_RADIOTAP_F_DATAPAD is\n\t\t * set, round the length of the 802.11 header to\n\t\t * a multiple of 4.  Do that by adding 3 and then\n\t\t * dividing by and multiplying by 4, which we do by\n\t\t * ANDing with ~3.\n\t\t */\n\t\ts_roundup = new_stmt(cstate, BPF_LD|BPF_MEM);\n\t\ts_roundup->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s_roundup);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\t\ts2->s.k = 3;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_IMM);\n\t\ts2->s.k = (bpf_u_int32)~3;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s2);\n\n\t\tsjset_tsft_datapad->s.jt = s_roundup;\n\t\tsjset_tsft_datapad->s.jf = snext;\n\t\tsjset_notsft_datapad->s.jt = s_roundup;\n\t\tsjset_notsft_datapad->s.jf = snext;\n\t} else\n\t\tsjset_qos->s.jf = snext;\n\n\treturn s;\n}\n\nstatic void\ninsert_compute_vloffsets(compiler_state_t *cstate, struct block *b)\n{\n\tstruct slist *s;\n\n\t/* There is an implicit dependency between the link\n\t * payload and link header since the payload computation\n\t * includes the variable part of the header. Therefore,\n\t * if nobody else has allocated a register for the link\n\t * header and we need it, do it now. */\n\tif (cstate->off_linkpl.reg != -1 && cstate->off_linkhdr.is_variable &&\n\t    cstate->off_linkhdr.reg == -1)\n\t\tcstate->off_linkhdr.reg = alloc_reg(cstate);\n\n\t/*\n\t * For link-layer types that have a variable-length header\n\t * preceding the link-layer header, generate code to load\n\t * the offset of the link-layer header into the register\n\t * assigned to that offset, if any.\n\t *\n\t * XXX - this, and the next switch statement, won't handle\n\t * encapsulation of 802.11 or 802.11+radio information in\n\t * some other protocol stack.  That's significantly more\n\t * complicated.\n\t */\n\tswitch (cstate->outermostlinktype) {\n\n\tcase DLT_PRISM_HEADER:\n\t\ts = gen_load_prism_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\ts = gen_load_avs_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_IEEE802_11_RADIO:\n\t\ts = gen_load_radiotap_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_PPI:\n\t\ts = gen_load_ppi_llprefixlen(cstate);\n\t\tbreak;\n\n\tdefault:\n\t\ts = NULL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * For link-layer types that have a variable-length link-layer\n\t * header, generate code to load the offset of the link-layer\n\t * payload into the register assigned to that offset, if any.\n\t */\n\tswitch (cstate->outermostlinktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_PPI:\n\t\ts = gen_load_802_11_header_len(cstate, s, b->stmts);\n\t\tbreak;\n\n\tcase DLT_PFLOG:\n\t\ts = gen_load_pflog_llprefixlen(cstate);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If there is no initialization yet and we need variable\n\t * length offsets for VLAN, initialize them to zero\n\t */\n\tif (s == NULL && cstate->is_vlan_vloffset) {\n\t\tstruct slist *s2;\n\n\t\tif (cstate->off_linkpl.reg == -1)\n\t\t\tcstate->off_linkpl.reg = alloc_reg(cstate);\n\t\tif (cstate->off_linktype.reg == -1)\n\t\t\tcstate->off_linktype.reg = alloc_reg(cstate);\n\n\t\ts = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);\n\t\ts->s.k = 0;\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linktype.reg;\n\t\tsappend(s, s2);\n\t}\n\n\t/*\n\t * If we have any offset-loading code, append all the\n\t * existing statements in the block to those statements,\n\t * and make the resulting list the list of statements\n\t * for the block.\n\t */\n\tif (s != NULL) {\n\t\tsappend(s, b->stmts);\n\t\tb->stmts = s;\n\t}\n}\n\nstatic struct block *\ngen_ppi_dlt_check(compiler_state_t *cstate)\n{\n\tstruct slist *s_load_dlt;\n\tstruct block *b;\n\n\tif (cstate->linktype == DLT_PPI)\n\t{\n\t\t/* Create the statements that check for the DLT\n\t\t */\n\t\ts_load_dlt = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts_load_dlt->s.k = 4;\n\n\t\tb = new_block(cstate, JMP(BPF_JEQ));\n\n\t\tb->stmts = s_load_dlt;\n\t\tb->s.k = SWAPLONG(DLT_IEEE802_11);\n\t}\n\telse\n\t{\n\t\tb = NULL;\n\t}\n\n\treturn b;\n}\n\n/*\n * Take an absolute offset, and:\n *\n *    if it has no variable part, return NULL;\n *\n *    if it has a variable part, generate code to load the register\n *    containing that variable part into the X register, returning\n *    a pointer to that code - if no register for that offset has\n *    been allocated, allocate it first.\n *\n * (The code to set that register will be generated later, but will\n * be placed earlier in the code sequence.)\n */\nstatic struct slist *\ngen_abs_offset_varpart(compiler_state_t *cstate, bpf_abs_offset *off)\n{\n\tstruct slist *s;\n\n\tif (off->is_variable) {\n\t\tif (off->reg == -1) {\n\t\t\t/*\n\t\t\t * We haven't yet assigned a register for the\n\t\t\t * variable part of the offset of the link-layer\n\t\t\t * header; allocate one.\n\t\t\t */\n\t\t\toff->reg = alloc_reg(cstate);\n\t\t}\n\n\t\t/*\n\t\t * Load the register containing the variable part of the\n\t\t * offset of the link-layer header into the X register.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\t\ts->s.k = off->reg;\n\t\treturn s;\n\t} else {\n\t\t/*\n\t\t * That offset isn't variable, there's no variable part,\n\t\t * so we don't need to generate any code.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\n/*\n * Map an Ethernet type to the equivalent PPP type.\n */\nstatic bpf_u_int32\nethertype_to_ppptype(bpf_u_int32 ll_proto)\n{\n\tswitch (ll_proto) {\n\n\tcase ETHERTYPE_IP:\n\t\tll_proto = PPP_IP;\n\t\tbreak;\n\n\tcase ETHERTYPE_IPV6:\n\t\tll_proto = PPP_IPV6;\n\t\tbreak;\n\n\tcase ETHERTYPE_DN:\n\t\tll_proto = PPP_DECNET;\n\t\tbreak;\n\n\tcase ETHERTYPE_ATALK:\n\t\tll_proto = PPP_APPLE;\n\t\tbreak;\n\n\tcase ETHERTYPE_NS:\n\t\tll_proto = PPP_NS;\n\t\tbreak;\n\n\tcase LLCSAP_ISONS:\n\t\tll_proto = PPP_OSI;\n\t\tbreak;\n\n\tcase LLCSAP_8021D:\n\t\t/*\n\t\t * I'm assuming the \"Bridging PDU\"s that go\n\t\t * over PPP are Spanning Tree Protocol\n\t\t * Bridging PDUs.\n\t\t */\n\t\tll_proto = PPP_BRPDU;\n\t\tbreak;\n\n\tcase LLCSAP_IPX:\n\t\tll_proto = PPP_IPX;\n\t\tbreak;\n\t}\n\treturn (ll_proto);\n}\n\n/*\n * Generate any tests that, for encapsulation of a link-layer packet\n * inside another protocol stack, need to be done to check for those\n * link-layer packets (and that haven't already been done by a check\n * for that encapsulation).\n */\nstatic struct block *\ngen_prevlinkhdr_check(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\n\tif (cstate->is_encap)\n\t\treturn gen_encap_ll_check(cstate);\n\n\tswitch (cstate->prevlinktype) {\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * This is LANE-encapsulated Ethernet; check that the LANE\n\t\t * packet doesn't begin with an LE Control marker, i.e.\n\t\t * that it's data, not a control message.\n\t\t *\n\t\t * (We've already generated a test for LANE.)\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_PREVLINKHDR, SUNATM_PKT_BEGIN_POS, BPF_H, 0xFF00);\n\t\tgen_not(b0);\n\t\treturn b0;\n\n\tdefault:\n\t\t/*\n\t\t * No such tests are necessary.\n\t\t */\n\t\treturn NULL;\n\t}\n\t/*NOTREACHED*/\n}\n\n/*\n * The three different values we should check for when checking for an\n * IPv6 packet with DLT_NULL.\n */\n#define BSD_AFNUM_INET6_BSD\t24\t/* NetBSD, OpenBSD, BSD/OS, Npcap */\n#define BSD_AFNUM_INET6_FREEBSD\t28\t/* FreeBSD */\n#define BSD_AFNUM_INET6_DARWIN\t30\t/* macOS, iOS, other Darwin-based OSes */\n\n/*\n * Generate code to match a particular packet type by matching the\n * link-layer type field or fields in the 802.2 LLC header.\n *\n * \"proto\" is an Ethernet type value, if > ETHERMTU, or an LLC SAP\n * value, if <= ETHERMTU.\n */\nstatic struct block *\ngen_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1, *b2;\n\tconst char *description;\n\n\t/* are we checking MPLS-encapsulated packets? */\n\tif (cstate->label_stack_depth > 0)\n\t\treturn gen_mpls_linktype(cstate, ll_proto);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t/* Geneve has an EtherType regardless of whether there is an\n\t\t * L2 header. VXLAN always has an EtherType. */\n\t\tif (!cstate->is_encap)\n\t\t\tb0 = gen_prevlinkhdr_check(cstate);\n\t\telse\n\t\t\tb0 = NULL;\n\n\t\tb1 = gen_ether_linktype(cstate, ll_proto);\n\t\tif (b0 != NULL)\n\t\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_C_HDLC:\n\tcase DLT_HDLC:\n\t\tswitch (ll_proto) {\n\n\t\tcase LLCSAP_ISONS:\n\t\t\tll_proto = (ll_proto << 8 | LLCSAP_ISONS);\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_PPI:\n\t\t/*\n\t\t * Check that we have a data frame.\n\t\t */\n\t\tb0 = gen_check_802_11_data_frame(cstate);\n\n\t\t/*\n\t\t * Now check for the specified link-layer type.\n\t\t */\n\t\tb1 = gen_llc_linktype(cstate, ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IEEE802:\n\t\t/*\n\t\t * XXX - check for LLC PDUs, as per IEEE 802.5.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_ATM_RFC1483:\n\tcase DLT_ATM_CLIP:\n\tcase DLT_IP_OVER_FC:\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * Check for an LLC-encapsulated version of this protocol;\n\t\t * if we were checking for LANE, linktype would no longer\n\t\t * be DLT_SUNATM.\n\t\t *\n\t\t * Check for LLC encapsulation and then check the protocol.\n\t\t */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);\n\t\tb1 = gen_llc_linktype(cstate, ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LINUX_SLL:\n\t\treturn gen_linux_sll_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SLIP:\n\tcase DLT_SLIP_BSDOS:\n\tcase DLT_RAW:\n\t\t/*\n\t\t * These types don't provide any type field; packets\n\t\t * are always IPv4 or IPv6.\n\t\t *\n\t\t * XXX - for IPv4, check for a version number of 4, and,\n\t\t * for IPv6, check for a version number of 6?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/* Check for a version number of 4. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x40, 0xF0);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/* Check for a version number of 6. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x60, 0xF0);\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\t/* always false */\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV4:\n\t\t/*\n\t\t * Raw IPv4, so no type field.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IP)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv4; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV6:\n\t\t/*\n\t\t * Raw IPv6, so no type field.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IPV6)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv6; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP:\n\tcase DLT_PPP_PPPD:\n\tcase DLT_PPP_SERIAL:\n\tcase DLT_PPP_ETHER:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,\n\t\t    ethertype_to_ppptype(ll_proto));\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP_BSDOS:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Also check for Van Jacobson-compressed IP.\n\t\t\t * XXX - do this for other forms of PPP?\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJC);\n\t\t\tgen_or(b0, b1);\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJNC);\n\t\t\tgen_or(b1, b0);\n\t\t\treturn b0;\n\n\t\tdefault:\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,\n\t\t\t    ethertype_to_ppptype(ll_proto));\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_NULL:\n\tcase DLT_LOOP:\n\tcase DLT_ENC:\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\treturn (gen_loopback_linktype(cstate, AF_INET));\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * AF_ values may, unfortunately, be platform-\n\t\t\t * dependent; AF_INET isn't, because everybody\n\t\t\t * used 4.2BSD's value, but AF_INET6 is, because\n\t\t\t * 4.2BSD didn't have a value for it (given that\n\t\t\t * IPv6 didn't exist back in the early 1980's),\n\t\t\t * and they all picked their own values.\n\t\t\t *\n\t\t\t * This means that, if we're reading from a\n\t\t\t * savefile, we need to check for all the\n\t\t\t * possible values.\n\t\t\t *\n\t\t\t * If we're doing a live capture, we only need\n\t\t\t * to check for this platform's value; however,\n\t\t\t * Npcap uses 24, which isn't Windows's AF_INET6\n\t\t\t * value.  (Given the multiple different values,\n\t\t\t * programs that read pcap files shouldn't be\n\t\t\t * checking for their platform's AF_INET6 value\n\t\t\t * anyway, they should check for all of the\n\t\t\t * possible values. and they might as well do\n\t\t\t * that even for live captures.)\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Savefile - check for all three\n\t\t\t\t * possible IPv6 values.\n\t\t\t\t */\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_BSD);\n\t\t\t\tb1 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_FREEBSD);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_DARWIN);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\treturn (b1);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Live capture, so we only need to\n\t\t\t\t * check for the value used on this\n\t\t\t\t * platform.\n\t\t\t\t */\n#ifdef _WIN32\n\t\t\t\t/*\n\t\t\t\t * Npcap doesn't use Windows's AF_INET6,\n\t\t\t\t * as that collides with AF_IPX on\n\t\t\t\t * some BSDs (both have the value 23).\n\t\t\t\t * Instead, it uses 24.\n\t\t\t\t */\n\t\t\t\treturn (gen_loopback_linktype(cstate, 24));\n#else /* _WIN32 */\n#ifdef AF_INET6\n\t\t\t\treturn (gen_loopback_linktype(cstate, AF_INET6));\n#else /* AF_INET6 */\n\t\t\t\t/*\n\t\t\t\t * I guess this platform doesn't support\n\t\t\t\t * IPv6, so we just reject all packets.\n\t\t\t\t */\n\t\t\t\treturn gen_false(cstate);\n#endif /* AF_INET6 */\n#endif /* _WIN32 */\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a type on which we support filtering.\n\t\t\t * XXX - support those that have AF_ values\n\t\t\t * #defined on this platform, at least?\n\t\t\t */\n\t\t\treturn gen_false(cstate);\n\t\t}\n\n\tcase DLT_PFLOG:\n\t\t/*\n\t\t * af field is host byte order in contrast to the rest of\n\t\t * the packet.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IP)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, AF_INET));\n\t\telse if (ll_proto == ETHERTYPE_IPV6)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, AF_INET6));\n\t\telse\n\t\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_ARCNET:\n\tcase DLT_ARCNET_LINUX:\n\t\t/*\n\t\t * XXX should we check for first fragment if the protocol\n\t\t * uses PHDS?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\tARCTYPE_INET6));\n\n\t\tcase ETHERTYPE_IP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_IP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_ARP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ARP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ARP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_REVARP:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_REVARP));\n\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ATALK));\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LTALK:\n\t\tswitch (ll_proto) {\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn gen_true(cstate);\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FRELAY:\n\t\t/*\n\t\t * XXX - assumes a 2-byte Frame Relay header with\n\t\t * DLCI and flags.  What if the address is longer?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IP.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0xcc);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IPv6.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0x8e);\n\n\t\tcase LLCSAP_ISONS:\n\t\t\t/*\n\t\t\t * Check for several OSI protocols.\n\t\t\t *\n\t\t\t * Frame Relay packets typically have an OSI\n\t\t\t * NLPID at the beginning; we check for each\n\t\t\t * of them.\n\t\t\t *\n\t\t\t * What we check for is the NLPID and a frame\n\t\t\t * control field of UI, i.e. 0x03 followed\n\t\t\t * by the NLPID.\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO8473_CLNP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO9542_ESIS);\n\t\t\tb2 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO10589_ISIS);\n\t\t\tgen_or(b1, b2);\n\t\t\tgen_or(b0, b2);\n\t\t\treturn b2;\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_MFR:\n\t\tbpf_error(cstate, \"Multi-link Frame Relay link-layer type filtering not implemented\");\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* just lets verify the magic number for now -\n\t\t * on ATM we may have up to 6 different encapsulations on the wire\n\t\t * and need a lot of heuristics to figure out that the payload\n\t\t * might be;\n\t\t *\n\t\t * FIXME encapsulation specific BPF_ filters\n\t\t */\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x4d474300, 0xffffff00); /* compare the magic number */\n\n\tcase DLT_BACNET_MS_TP:\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x55FF0000, 0xffff0000);\n\n\tcase DLT_IPNET:\n\t\treturn gen_ipnet_linktype(cstate, ll_proto);\n\n\tcase DLT_LINUX_IRDA:\n\t\tbpf_error(cstate, \"IrDA link-layer type filtering not implemented\");\n\n\tcase DLT_DOCSIS:\n\t\tbpf_error(cstate, \"DOCSIS link-layer type filtering not implemented\");\n\n\tcase DLT_MTP2:\n\tcase DLT_MTP2_WITH_PHDR:\n\t\tbpf_error(cstate, \"MTP2 link-layer type filtering not implemented\");\n\n\tcase DLT_ERF:\n\t\tbpf_error(cstate, \"ERF link-layer type filtering not implemented\");\n\n\tcase DLT_PFSYNC:\n\t\tbpf_error(cstate, \"PFSYNC link-layer type filtering not implemented\");\n\n\tcase DLT_LINUX_LAPD:\n\t\tbpf_error(cstate, \"LAPD link-layer type filtering not implemented\");\n\n\tcase DLT_USB_FREEBSD:\n\tcase DLT_USB_LINUX:\n\tcase DLT_USB_LINUX_MMAPPED:\n\tcase DLT_USBPCAP:\n\t\tbpf_error(cstate, \"USB link-layer type filtering not implemented\");\n\n\tcase DLT_BLUETOOTH_HCI_H4:\n\tcase DLT_BLUETOOTH_HCI_H4_WITH_PHDR:\n\t\tbpf_error(cstate, \"Bluetooth link-layer type filtering not implemented\");\n\n\tcase DLT_CAN20B:\n\tcase DLT_CAN_SOCKETCAN:\n\t\tbpf_error(cstate, \"CAN link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_15_4:\n\tcase DLT_IEEE802_15_4_LINUX:\n\tcase DLT_IEEE802_15_4_NONASK_PHY:\n\tcase DLT_IEEE802_15_4_NOFCS:\n\tcase DLT_IEEE802_15_4_TAP:\n\t\tbpf_error(cstate, \"IEEE 802.15.4 link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_16_MAC_CPS_RADIO:\n\t\tbpf_error(cstate, \"IEEE 802.16 link-layer type filtering not implemented\");\n\n\tcase DLT_SITA:\n\t\tbpf_error(cstate, \"SITA link-layer type filtering not implemented\");\n\n\tcase DLT_RAIF1:\n\t\tbpf_error(cstate, \"RAIF1 link-layer type filtering not implemented\");\n\n\tcase DLT_IPMB_KONTRON:\n\t\tbpf_error(cstate, \"IPMB link-layer type filtering not implemented\");\n\n\tcase DLT_I2C_LINUX:\n\t\tbpf_error(cstate, \"I2C link-layer type filtering not implemented\");\n\n\tcase DLT_AX25_KISS:\n\t\tbpf_error(cstate, \"AX.25 link-layer type filtering not implemented\");\n\n\tcase DLT_NFLOG:\n\t\t/* Using the fixed-size NFLOG header it is possible to tell only\n\t\t * the address family of the packet, other meaningful data is\n\t\t * either missing or behind TLVs.\n\t\t */\n\t\tbpf_error(cstate, \"NFLOG link-layer type filtering not implemented\");\n\n\tdefault:\n\t\t/*\n\t\t * Does this link-layer header type have a field\n\t\t * indicating the type of the next protocol?  If\n\t\t * so, off_linktype.constant_part will be the offset of that\n\t\t * field in the packet; if not, it will be OFFSET_NOT_SET.\n\t\t */\n\t\tif (cstate->off_linktype.constant_part != OFFSET_NOT_SET) {\n\t\t\t/*\n\t\t\t * Yes; assume it's an Ethernet type.  (If\n\t\t\t * it's not, it needs to be handled specially\n\t\t\t * above.)\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t\t/*NOTREACHED */\n\t\t} else {\n\t\t\t/*\n\t\t\t * No; report an error.\n\t\t\t */\n\t\t\tdescription = pcap_datalink_val_to_description_or_dlt(cstate->linktype);\n\t\t\tbpf_error(cstate, \"%s link-layer type filtering not implemented\",\n\t\t\t    description);\n\t\t\t/*NOTREACHED */\n\t\t}\n\t}\n}\n\n/*\n * Check for an LLC SNAP packet with a given organization code and\n * protocol type; we check the entire contents of the 802.2 LLC and\n * snap headers, checking for DSAP and SSAP of SNAP and a control\n * field of 0x03 in the LLC header, and for the specified organization\n * code and protocol type in the SNAP header.\n */\nstatic struct block *\ngen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)\n{\n\tu_char snapblock[8];\n\n\tsnapblock[0] = LLCSAP_SNAP;\t\t/* DSAP = SNAP */\n\tsnapblock[1] = LLCSAP_SNAP;\t\t/* SSAP = SNAP */\n\tsnapblock[2] = 0x03;\t\t\t/* control = UI */\n\tsnapblock[3] = (u_char)(orgcode >> 16);\t/* upper 8 bits of organization code */\n\tsnapblock[4] = (u_char)(orgcode >> 8);\t/* middle 8 bits of organization code */\n\tsnapblock[5] = (u_char)(orgcode >> 0);\t/* lower 8 bits of organization code */\n\tsnapblock[6] = (u_char)(ptype >> 8);\t/* upper 8 bits of protocol type */\n\tsnapblock[7] = (u_char)(ptype >> 0);\t/* lower 8 bits of protocol type */\n\treturn gen_bcmp(cstate, OR_LLC, 0, 8, snapblock);\n}\n\n/*\n * Generate code to match frames with an LLC header.\n */\nstatic struct block *\ngen_llc_internal(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\t\t/*\n\t\t * We check for an Ethernet type field less than\n\t\t * 1500, which means it's an 802.3 length field.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * Now check for the purported DSAP and SSAP not being\n\t\t * 0xFF, to rule out NetWare-over-802.3.\n\t\t */\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);\n\t\tgen_not(b1);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * We check for LLC traffic.\n\t\t */\n\t\tb0 = gen_atmtype_llc(cstate);\n\t\treturn b0;\n\n\tcase DLT_IEEE802:\t/* Token Ring */\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_ATM_RFC1483:\n\t\t/*\n\t\t * For LLC encapsulation, these are defined to have an\n\t\t * 802.2 LLC header.\n\t\t *\n\t\t * For VC encapsulation, they don't, but there's no\n\t\t * way to check for that; the protocol used on the VC\n\t\t * is negotiated out of band.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_PPI:\n\t\t/*\n\t\t * Check that we have a data frame.\n\t\t */\n\t\tb0 = gen_check_802_11_data_frame(cstate);\n\t\treturn b0;\n\n\tdefault:\n\t\tbpf_error(cstate, \"'llc' not supported for %s\",\n\t\t\t  pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n\t}\n}\n\nstruct block *\ngen_llc(compiler_state_t *cstate)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_llc_internal(cstate);\n}\n\nstruct block *\ngen_llc_i(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Load the control byte and test the low-order bit; it must\n\t * be clear for I frames.\n\t */\n\ts = gen_load_a(cstate, OR_LLC, 2, BPF_B);\n\tb1 = new_block(cstate, JMP(BPF_JSET));\n\tb1->s.k = 0x01;\n\tb1->stmts = s;\n\tgen_not(b1);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstruct block *\ngen_llc_s(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now compare the low-order 2 bit of the control byte against\n\t * the appropriate value for S frames.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_S_FMT, 0x03);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstruct block *\ngen_llc_u(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now compare the low-order 2 bit of the control byte against\n\t * the appropriate value for U frames.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_U_FMT, 0x03);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstruct block *\ngen_llc_s_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now check for an S frame with the appropriate type.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_S_CMD_MASK);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstruct block *\ngen_llc_u_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now check for a U frame with the appropriate type.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_U_CMD_MASK);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\n/*\n * Generate code to match a particular packet type, for link-layer types\n * using 802.2 LLC headers.\n *\n * This is *NOT* used for Ethernet; \"gen_ether_linktype()\" is used\n * for that - it handles the D/I/X Ethernet vs. 802.3+802.2 issues.\n *\n * \"proto\" is an Ethernet type value, if > ETHERMTU, or an LLC SAP\n * value, if <= ETHERMTU.  We use that to determine whether to\n * match the DSAP or both DSAP and LSAP or to check the OUI and\n * protocol ID in a SNAP header.\n */\nstatic struct block *\ngen_llc_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\t/*\n\t * XXX - handle token-ring variable-length header.\n\t */\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_IP:\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other SAP values?\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_H, (bpf_u_int32)\n\t\t\t     ((ll_proto << 8) | ll_proto));\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t * XXX - are there ever SNAP frames for IPX on\n\t\t * non-Ethernet 802.x networks?\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\n\tcase ETHERTYPE_ATALK:\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * XXX - check for an organization code of\n\t\t * encapsulated Ethernet as well?\n\t\t */\n\t\treturn gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\n\tdefault:\n\t\t/*\n\t\t * XXX - we don't have to check for IPX 802.3\n\t\t * here, but should we check for the IPX Ethertype?\n\t\t */\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so check\n\t\t\t * the DSAP.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_B, ll_proto);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type; we assume that it's\n\t\t\t * unlikely that it'll appear in the right place\n\t\t\t * at random, and therefore check only the\n\t\t\t * location that would hold the Ethernet type\n\t\t\t * in a SNAP frame with an organization code of\n\t\t\t * 0x000000 (encapsulated Ethernet).\n\t\t\t *\n\t\t\t * XXX - if we were to check for the SNAP DSAP and\n\t\t\t * LSAP, as per XXX, and were also to check for an\n\t\t\t * organization code of 0x000000 (encapsulated\n\t\t\t * Ethernet), we'd do\n\t\t\t *\n\t\t\t *\treturn gen_snap(cstate, 0x000000, ll_proto);\n\t\t\t *\n\t\t\t * here; for now, we don't, as per the above.\n\t\t\t * I don't know whether it's worth the extra CPU\n\t\t\t * time to do the right check or not.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LLC, 6, BPF_H, ll_proto);\n\t\t}\n\t}\n}\n\nstatic struct block *\ngen_hostop(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int dir, bpf_u_int32 ll_proto, u_int src_off, u_int dst_off)\n{\n\tstruct block *b0, *b1;\n\tu_int offset;\n\n\tswitch (dir) {\n\n\tcase Q_SRC:\n\t\toffset = src_off;\n\t\tbreak;\n\n\tcase Q_DST:\n\t\toffset = dst_off;\n\t\tbreak;\n\n\tcase Q_AND:\n\t\tb0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_linktype(cstate, ll_proto);\n\tb1 = gen_mcmp(cstate, OR_LINKPL, offset, BPF_W, addr, mask);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\n#ifdef INET6\nstatic struct block *\ngen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int dir, bpf_u_int32 ll_proto, u_int src_off,\n    u_int dst_off)\n{\n\tstruct block *b0, *b1;\n\tu_int offset;\n\t/*\n\t * Code below needs to access four separate 32-bit parts of the 128-bit\n\t * IPv6 address and mask.  In some OSes this is as simple as using the\n\t * s6_addr32 pseudo-member of struct in6_addr, which contains a union of\n\t * 8-, 16- and 32-bit arrays.  In other OSes this is not the case, as\n\t * far as libpcap sees it.  Hence copy the data before use to avoid\n\t * potential unaligned memory access and the associated compiler\n\t * warnings (whether genuine or not).\n\t */\n\tbpf_u_int32 a[4], m[4];\n\n\tswitch (dir) {\n\n\tcase Q_SRC:\n\t\toffset = src_off;\n\t\tbreak;\n\n\tcase Q_DST:\n\t\toffset = dst_off;\n\t\tbreak;\n\n\tcase Q_AND:\n\t\tb0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/* this order is important */\n\tmemcpy(a, addr, sizeof(a));\n\tmemcpy(m, mask, sizeof(m));\n\tb1 = gen_mcmp(cstate, OR_LINKPL, offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));\n\tgen_and(b0, b1);\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));\n\tgen_and(b0, b1);\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));\n\tgen_and(b0, b1);\n\tb0 = gen_linktype(cstate, ll_proto);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n#endif\n\nstatic struct block *\ngen_ehostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 6, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ehostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ehostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ehostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ehostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\n/*\n * Like gen_ehostop, but for DLT_FDDI\n */\nstatic struct block *\ngen_fhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 6 + 1 + cstate->pcap_fddipad, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0 + 1 + cstate->pcap_fddipad, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_fhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_fhostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_fhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_fhostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\n/*\n * Like gen_ehostop, but for DLT_IEEE802 (Token Ring)\n */\nstatic struct block *\ngen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 8, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\n/*\n * Like gen_ehostop, but for DLT_IEEE802_11 (802.11 wireless LAN) and\n * various 802.11 + radio headers.\n */\nstatic struct block *\ngen_wlanhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1, *b2;\n\tregister struct slist *s;\n\n#ifdef ENABLE_WLAN_FILTERING_PATCH\n\t/*\n\t * TODO GV 20070613\n\t * We need to disable the optimizer because the optimizer is buggy\n\t * and wipes out some LD instructions generated by the below\n\t * code to validate the Frame Control bits\n\t */\n\tcstate->no_optimize = 1;\n#endif /* ENABLE_WLAN_FILTERING_PATCH */\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\t/*\n\t\t * Oh, yuk.\n\t\t *\n\t\t *\tFor control frames, there is no SA.\n\t\t *\n\t\t *\tFor management frames, SA is at an\n\t\t *\toffset of 10 from the beginning of\n\t\t *\tthe packet.\n\t\t *\n\t\t *\tFor data frames, SA is at an offset\n\t\t *\tof 10 from the beginning of the packet\n\t\t *\tif From DS is clear, at an offset of\n\t\t *\t16 from the beginning of the packet\n\t\t *\tif From DS is set and To DS is clear,\n\t\t *\tand an offset of 24 from the beginning\n\t\t *\tof the packet if From DS is set and To DS\n\t\t *\tis set.\n\t\t */\n\n\t\t/*\n\t\t * Generate the tests to be done for data frames\n\t\t * with From DS set.\n\t\t *\n\t\t * First, check for To DS set, i.e. check \"link[1] & 0x01\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x01;\t/* To DS */\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * If To DS is set, the SA is at 24.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now, check for To DS not set, i.e. check\n\t\t * \"!(link[1] & 0x01)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x01;\t/* To DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If To DS is not set, the SA is at 16.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the last two checks.  That gives\n\t\t * the complete set of checks for data frames with\n\t\t * From DS set.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for From DS being set, and AND that with\n\t\t * the ORed-together checks.\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x02;\t/* From DS */\n\t\tb1->stmts = s;\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now check for data frames with From DS not set.\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x02;\t/* From DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If From DS isn't set, the SA is at 10.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the checks for data frames with\n\t\t * From DS not set and for data frames with From DS\n\t\t * set; that gives the checks done for data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for a data frame.\n\t\t * I.e, check \"link[0] & 0x08\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the checks done for data frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x08;\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * For management frames, the SA is at 10.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * OR that with the checks done for data frames.\n\t\t * That gives the checks done for management and\n\t\t * data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * If the low-order bit of the type value is 1,\n\t\t * this is either a control frame or a frame\n\t\t * with a reserved type, and thus not a\n\t\t * frame with an SA.\n\t\t *\n\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x04;\n\t\tb1->stmts = s;\n\t\tgen_not(b1);\n\n\t\t/*\n\t\t * AND that with the checks for data and management\n\t\t * frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn b0;\n\n\tcase Q_DST:\n\t\t/*\n\t\t * Oh, yuk.\n\t\t *\n\t\t *\tFor control frames, there is no DA.\n\t\t *\n\t\t *\tFor management frames, DA is at an\n\t\t *\toffset of 4 from the beginning of\n\t\t *\tthe packet.\n\t\t *\n\t\t *\tFor data frames, DA is at an offset\n\t\t *\tof 4 from the beginning of the packet\n\t\t *\tif To DS is clear and at an offset of\n\t\t *\t16 from the beginning of the packet\n\t\t *\tif To DS is set.\n\t\t */\n\n\t\t/*\n\t\t * Generate the tests to be done for data frames.\n\t\t *\n\t\t * First, check for To DS set, i.e. \"link[1] & 0x01\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x01;\t/* To DS */\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * If To DS is set, the DA is at 16.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now, check for To DS not set, i.e. check\n\t\t * \"!(link[1] & 0x01)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x01;\t/* To DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If To DS is not set, the DA is at 4.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the last two checks.  That gives\n\t\t * the complete set of checks for data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for a data frame.\n\t\t * I.e, check \"link[0] & 0x08\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the checks done for data frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x08;\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * For management frames, the DA is at 4.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * OR that with the checks done for data frames.\n\t\t * That gives the checks done for management and\n\t\t * data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * If the low-order bit of the type value is 1,\n\t\t * this is either a control frame or a frame\n\t\t * with a reserved type, and thus not a\n\t\t * frame with an SA.\n\t\t *\n\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x04;\n\t\tb1->stmts = s;\n\t\tgen_not(b1);\n\n\t\t/*\n\t\t * AND that with the checks for data and management\n\t\t * frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn b0;\n\n\tcase Q_AND:\n\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_wlanhostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_wlanhostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\t/*\n\t * XXX - add BSSID keyword?\n\t */\n\tcase Q_ADDR1:\n\t\treturn (gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr));\n\n\tcase Q_ADDR2:\n\t\t/*\n\t\t * Not present in CTS or ACK control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b1);\n\t\tb2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b2);\n\t\tgen_and(b1, b2);\n\t\tgen_or(b0, b2);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR3:\n\t\t/*\n\t\t * Not present in control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR4:\n\t\t/*\n\t\t * Present only if the direction mask has both \"From DS\"\n\t\t * and \"To DS\" set.  Neither control frames nor management\n\t\t * frames should have both of those set, so we don't\n\t\t * check the frame type.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B,\n\t\t\tIEEE80211_FC1_DIR_DSTODS, IEEE80211_FC1_DIR_MASK);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_RA:\n\t\t/*\n\t\t * Not present in management frames; addr1 in other\n\t\t * frames.\n\t\t */\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * Check addr1.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\n\t\t/*\n\t\t * AND that with the check of addr1.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn (b0);\n\n\tcase Q_TA:\n\t\t/*\n\t\t * Not present in management frames; addr2, if present,\n\t\t * in other frames.\n\t\t */\n\n\t\t/*\n\t\t * Not present in CTS or ACK control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b1);\n\t\tb2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b2);\n\t\tgen_and(b1, b2);\n\t\tgen_or(b0, b2);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the check for frames other than\n\t\t * CTS and ACK frames.\n\t\t */\n\t\tgen_and(b1, b2);\n\n\t\t/*\n\t\t * Check addr2.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\t\treturn b1;\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\n/*\n * Like gen_ehostop, but for RFC 2625 IP-over-Fibre-Channel.\n * (We assume that the addresses are IEEE 48-bit MAC addresses,\n * as the RFC states.)\n */\nstatic struct block *\ngen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\n/*\n * This is quite tricky because there may be pad bytes in front of the\n * DECNET header, and then there are two possible data packet formats that\n * carry both src and dst addresses, plus 5 packet types in a format that\n * carries only the src node, plus 2 types that use a different format and\n * also carry just the src node.\n *\n * Yuck.\n *\n * Instead of doing those all right, we just look for data packets with\n * 0 or 1 bytes of padding.  If you want to look at other packets, that\n * will require a lot more hacking.\n *\n * To add support for filtering on DECNET \"areas\" (network numbers)\n * one would want to add a \"mask\" argument to this routine.  That would\n * make the filter even more inefficient, although one could be clever\n * and not generate masking instructions if the mask is 0xFFFF.\n */\nstatic struct block *\ngen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)\n{\n\tstruct block *b0, *b1, *b2, *tmp;\n\tu_int offset_lh;\t/* offset if long header is received */\n\tu_int offset_sh;\t/* offset if short header is received */\n\n\tswitch (dir) {\n\n\tcase Q_DST:\n\t\toffset_sh = 1;\t/* follows flags */\n\t\toffset_lh = 7;\t/* flgs,darea,dsubarea,HIORD */\n\t\tbreak;\n\n\tcase Q_SRC:\n\t\toffset_sh = 3;\t/* follows flags, dstnode */\n\t\toffset_lh = 15;\t/* flgs,darea,dsubarea,did,sarea,ssub,HIORD */\n\t\tbreak;\n\n\tcase Q_AND:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/*\n\t * In a DECnet message inside an Ethernet frame the first two bytes\n\t * immediately after EtherType are the [litle-endian] DECnet message\n\t * length, which is irrelevant in this context.\n\t *\n\t * \"pad = 1\" means the third byte equals 0x81, thus it is the PLENGTH\n\t * 8-bit bitmap of the optional padding before the packet route header.\n\t * The bitmap always has bit 7 set to 1 and in this case has bits 0-6\n\t * (TOTAL-PAD-SEQUENCE-LENGTH) set to integer value 1.  The latter\n\t * means there aren't any PAD bytes after the bitmap, so the header\n\t * begins at the fourth byte.  \"pad = 0\" means bit 7 of the third byte\n\t * is set to 0, thus the header begins at the third byte.\n\t *\n\t * The header can be in several (as mentioned above) formats, all of\n\t * which begin with the FLAGS 8-bit bitmap, which always has bit 7\n\t * (PF, \"pad field\") set to 0 regardless of any padding present before\n\t * the header.  \"Short header\" means bits 0-2 of the bitmap encode the\n\t * integer value 2 (SFDP), and \"long header\" means value 6 (LFDP).\n\t *\n\t * For the DECnet address use SWAPSHORT(), which always swaps bytes,\n\t * because the wire encoding is little-endian and this function always\n\t * receives a big-endian address value.\n\t */\n\tb0 = gen_linktype(cstate, ETHERTYPE_DN);\n\t/* Check for pad = 1, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H, 0x8106U, 0xFF07U);\n\tb1 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_lh,\n\t    BPF_H, SWAPSHORT(addr));\n\tgen_and(tmp, b1);\n\t/* Check for pad = 0, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, 0x06U, 0x07U);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_lh, BPF_H,\n\t    SWAPSHORT(addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 1, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H, 0x8102U, 0xFF07U);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_sh, BPF_H,\n\t    SWAPSHORT(addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 0, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, 0x02U, 0x07U);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_sh, BPF_H,\n\t    SWAPSHORT(addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\n\t/* Combine with test for cstate->linktype */\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\n/*\n * Generate a check for IPv4 or IPv6 for MPLS-encapsulated packets;\n * test the bottom-of-stack bit, and then check the version number\n * field in the IP header.\n */\nstatic struct block *\ngen_mpls_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n        switch (ll_proto) {\n\n        case ETHERTYPE_IP:\n                /* match the bottom-of-stack bit */\n                b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);\n                /* match the IPv4 version number */\n                b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x40, 0xf0);\n                gen_and(b0, b1);\n                return b1;\n\n        case ETHERTYPE_IPV6:\n                /* match the bottom-of-stack bit */\n                b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);\n                /* match the IPv4 version number */\n                b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x60, 0xf0);\n                gen_and(b0, b1);\n                return b1;\n\n        default:\n               /* FIXME add other L3 proto IDs */\n               bpf_error(cstate, \"unsupported protocol over mpls\");\n               /*NOTREACHED*/\n        }\n}\n\nstatic struct block *\ngen_host(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int proto, int dir, int type)\n{\n\tstruct block *b0, *b1;\n\tconst char *typestr;\n\n\tif (type == Q_NET)\n\t\ttypestr = \"net\";\n\telse\n\t\ttypestr = \"host\";\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\t\tb0 = gen_host(cstate, addr, mask, Q_IP, dir, type);\n\t\t/*\n\t\t * Only check for non-IPv4 addresses if we're not\n\t\t * checking MPLS-encapsulated packets.\n\t\t */\n\t\tif (cstate->label_stack_depth == 0) {\n\t\t\tb1 = gen_host(cstate, addr, mask, Q_ARP, dir, type);\n\t\t\tgen_or(b0, b1);\n\t\t\tb0 = gen_host(cstate, addr, mask, Q_RARP, dir, type);\n\t\t\tgen_or(b1, b0);\n\t\t}\n\t\treturn b0;\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link-layer modifier applied to %s\", typestr);\n\n\tcase Q_IP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_IP, 12, 16);\n\n\tcase Q_RARP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_REVARP, 14, 24);\n\n\tcase Q_ARP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_ARP, 14, 24);\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp' modifier applied to %s\", typestr);\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp' modifier applied to %s\", typestr);\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp' modifier applied to %s\", typestr);\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp' modifier applied to %s\", typestr);\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp' modifier applied to %s\", typestr);\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp' modifier applied to %s\", typestr);\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk host filtering not implemented\");\n\n\tcase Q_DECNET:\n\t\treturn gen_dnhostop(cstate, addr, dir);\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"LAT host filtering not implemented\");\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"SCA host filtering not implemented\");\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"MOPRC host filtering not implemented\");\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"MOPDL host filtering not implemented\");\n\n\tcase Q_IPV6:\n\t\tbpf_error(cstate, \"'ip6' modifier applied to ip host\");\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6' modifier applied to %s\", typestr);\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah' modifier applied to %s\", typestr);\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'esp' modifier applied to %s\", typestr);\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim' modifier applied to %s\", typestr);\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp' modifier applied to %s\", typestr);\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"AARP host filtering not implemented\");\n\n\tcase Q_ISO:\n\t\tbpf_error(cstate, \"ISO host filtering not implemented\");\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS:\n\t\tbpf_error(cstate, \"'isis' modifier applied to %s\", typestr);\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp' modifier applied to %s\", typestr);\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp' modifier applied to %s\", typestr);\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"IPX host filtering not implemented\");\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp' modifier applied to %s\", typestr);\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' modifier applied to %s\", typestr);\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp' modifier applied to %s\", typestr);\n\n\tdefault:\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n}\n\n#ifdef INET6\nstatic struct block *\ngen_host6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int proto, int dir, int type)\n{\n\tconst char *typestr;\n\n\tif (type == Q_NET)\n\t\ttypestr = \"net\";\n\telse\n\t\ttypestr = \"host\";\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\t\treturn gen_host6(cstate, addr, mask, Q_IPV6, dir, type);\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link-layer modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IP:\n\t\tbpf_error(cstate, \"'ip' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_RARP:\n\t\tbpf_error(cstate, \"'rarp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ARP:\n\t\tbpf_error(cstate, \"'arp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk modifier applied to ip6 %s\", typestr);\n\n\tcase Q_DECNET:\n\t\tbpf_error(cstate, \"'decnet' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"'lat' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"'sca' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"'moprc' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"'mopdl' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IPV6:\n\t\treturn gen_hostop6(cstate, addr, mask, dir, ETHERTYPE_IPV6, 8, 24);\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'esp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"'aarp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISO:\n\t\tbpf_error(cstate, \"'iso' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS:\n\t\tbpf_error(cstate, \"'isis' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"'ipx' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp' modifier applied to ip6 %s\", typestr);\n\n\tdefault:\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n}\n#endif\n\n#ifndef INET6\nstatic struct block *\ngen_gateway(compiler_state_t *cstate, const u_char *eaddr,\n    struct addrinfo *alist, int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\tstruct addrinfo *ai;\n\tstruct sockaddr_in *sin;\n\n\tif (dir != 0)\n\t\tbpf_error(cstate, \"direction applied to 'gateway'\");\n\n\tswitch (proto) {\n\tcase Q_DEFAULT:\n\tcase Q_IP:\n\tcase Q_ARP:\n\tcase Q_RARP:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\tb0 = gen_ehostop(cstate, eaddr, Q_OR);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\tbreak;\n\t\tcase DLT_FDDI:\n\t\t\tb0 = gen_fhostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802:\n\t\t\tb0 = gen_thostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_SUNATM:\n\t\t\t/*\n\t\t\t * This is LLC-multiplexed traffic; if it were\n\t\t\t * LANE, cstate->linktype would have been set to\n\t\t\t * DLT_EN10MB.\n\t\t\t */\n\t\t\tbpf_error(cstate,\n\t\t\t    \"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_error(cstate,\n\t\t\t    \"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\t}\n\t\tb1 = NULL;\n\t\tfor (ai = alist; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Is it an IPv4 address?\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Generate an entry for it.\n\t\t\t\t\t */\n\t\t\t\t\tsin = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\ttmp = gen_host(cstate,\n\t\t\t\t\t    ntohl(sin->sin_addr.s_addr),\n\t\t\t\t\t    0xffffffff, proto, Q_OR, Q_HOST);\n\t\t\t\t\t/*\n\t\t\t\t\t * Is it the *first* IPv4 address?\n\t\t\t\t\t */\n\t\t\t\t\tif (b1 == NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Yes, so start with it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tb1 = tmp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * No, so OR it into the\n\t\t\t\t\t\t * existing set of\n\t\t\t\t\t\t * addresses.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgen_or(b1, tmp);\n\t\t\t\t\t\tb1 = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (b1 == NULL) {\n\t\t\t/*\n\t\t\t * No IPv4 addresses found.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tgen_not(b1);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t}\n\tbpf_error(cstate, \"illegal modifier of 'gateway'\");\n\t/*NOTREACHED*/\n}\n#endif\n\nstatic struct block *\ngen_proto_abbrev_internal(compiler_state_t *cstate, int proto)\n{\n\tstruct block *b0;\n\tstruct block *b1;\n\n\tswitch (proto) {\n\n\tcase Q_SCTP:\n\t\tb1 = gen_proto(cstate, IPPROTO_SCTP, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_TCP:\n\t\tb1 = gen_proto(cstate, IPPROTO_TCP, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_UDP:\n\t\tb1 = gen_proto(cstate, IPPROTO_UDP, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ICMP:\n\t\tb1 = gen_proto(cstate, IPPROTO_ICMP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef\tIPPROTO_IGMP\n#define\tIPPROTO_IGMP\t2\n#endif\n\n\tcase Q_IGMP:\n\t\tb1 = gen_proto(cstate, IPPROTO_IGMP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef\tIPPROTO_IGRP\n#define\tIPPROTO_IGRP\t9\n#endif\n\tcase Q_IGRP:\n\t\tb1 = gen_proto(cstate, IPPROTO_IGRP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_PIM\n#define IPPROTO_PIM\t103\n#endif\n\n\tcase Q_PIM:\n\t\tb1 = gen_proto(cstate, IPPROTO_PIM, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_VRRP\n#define IPPROTO_VRRP\t112\n#endif\n\n\tcase Q_VRRP:\n\t\tb1 = gen_proto(cstate, IPPROTO_VRRP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_CARP\n#define IPPROTO_CARP\t112\n#endif\n\n\tcase Q_CARP:\n\t\tb1 = gen_proto(cstate, IPPROTO_CARP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_IP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\tbreak;\n\n\tcase Q_ARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_ARP);\n\t\tbreak;\n\n\tcase Q_RARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_REVARP);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link layer applied in wrong context\");\n\n\tcase Q_ATALK:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_ATALK);\n\t\tbreak;\n\n\tcase Q_AARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_AARP);\n\t\tbreak;\n\n\tcase Q_DECNET:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_DN);\n\t\tbreak;\n\n\tcase Q_SCA:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_SCA);\n\t\tbreak;\n\n\tcase Q_LAT:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_LAT);\n\t\tbreak;\n\n\tcase Q_MOPDL:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_MOPDL);\n\t\tbreak;\n\n\tcase Q_MOPRC:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_MOPRC);\n\t\tbreak;\n\n\tcase Q_IPV6:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\t\tbreak;\n\n#ifndef IPPROTO_ICMPV6\n#define IPPROTO_ICMPV6\t58\n#endif\n\tcase Q_ICMPV6:\n\t\tb1 = gen_proto(cstate, IPPROTO_ICMPV6, Q_IPV6, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_AH\n#define IPPROTO_AH\t51\n#endif\n\tcase Q_AH:\n\t\tb1 = gen_proto(cstate, IPPROTO_AH, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_ESP\n#define IPPROTO_ESP\t50\n#endif\n\tcase Q_ESP:\n\t\tb1 = gen_proto(cstate, IPPROTO_ESP, Q_DEFAULT, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ISO:\n\t\tb1 = gen_linktype(cstate, LLCSAP_ISONS);\n\t\tbreak;\n\n\tcase Q_ESIS:\n\t\tb1 = gen_proto(cstate, ISO9542_ESIS, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ISIS:\n\t\tb1 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ISIS_L1: /* all IS-IS Level1 PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); /* FIXME extract the circuit-type bits */\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_L2: /* all IS-IS Level2 PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); /* FIXME extract the circuit-type bits */\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_IIH: /* all IS-IS Hello PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_LSP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_SNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_CSNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_PSNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_CLNP:\n\t\tb1 = gen_proto(cstate, ISO8473_CLNP, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_STP:\n\t\tb1 = gen_linktype(cstate, LLCSAP_8021D);\n\t\tbreak;\n\n\tcase Q_IPX:\n\t\tb1 = gen_linktype(cstate, LLCSAP_IPX);\n\t\tbreak;\n\n\tcase Q_NETBEUI:\n\t\tb1 = gen_linktype(cstate, LLCSAP_NETBEUI);\n\t\tbreak;\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' is not a valid protocol type\");\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}\n\nstruct block *\ngen_proto_abbrev(compiler_state_t *cstate, int proto)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_proto_abbrev_internal(cstate, proto);\n}\n\nstatic struct block *\ngen_ipfrag(compiler_state_t *cstate)\n{\n\tstruct slist *s;\n\tstruct block *b;\n\n\t/* not IPv4 frag other than the first frag */\n\ts = gen_load_a(cstate, OR_LINKPL, 6, BPF_H);\n\tb = new_block(cstate, JMP(BPF_JSET));\n\tb->s.k = 0x1fff;\n\tb->stmts = s;\n\tgen_not(b);\n\n\treturn b;\n}\n\n/*\n * Generate a comparison to a port value in the transport-layer header\n * at the specified offset from the beginning of that header.\n *\n * XXX - this handles a variable-length prefix preceding the link-layer\n * header, such as the radiotap or AVS radio prefix, but doesn't handle\n * variable-length link-layer headers (such as Token Ring or 802.11\n * headers).\n */\nstatic struct block *\ngen_portatom(compiler_state_t *cstate, int off, bpf_u_int32 v)\n{\n\treturn gen_cmp(cstate, OR_TRAN_IPV4, off, BPF_H, v);\n}\n\nstatic struct block *\ngen_portatom6(compiler_state_t *cstate, int off, bpf_u_int32 v)\n{\n\treturn gen_cmp(cstate, OR_TRAN_IPV6, off, BPF_H, v);\n}\n\nstatic struct block *\ngen_portop(compiler_state_t *cstate, u_int port, u_int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip proto 'proto' and not a fragment other than the first fragment */\n\ttmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);\n\tb0 = gen_ipfrag(cstate);\n\tgen_and(tmp, b0);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portatom(cstate, 0, port);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portatom(cstate, 0, port);\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portatom(cstate, 0, port);\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for ports\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_port(compiler_state_t *cstate, u_int port, int ip_proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/*\n\t * ether proto ip\n\t *\n\t * For FDDI, RFC 1188 says that SNAP encapsulation is used,\n\t * not LLC encapsulation with LLCSAP_IP.\n\t *\n\t * For IEEE 802 networks - which includes 802.5 token ring\n\t * (which is what DLT_IEEE802 means) and 802.11 - RFC 1042\n\t * says that SNAP encapsulation is used, not LLC encapsulation\n\t * with LLCSAP_IP.\n\t *\n\t * For LLC-encapsulated ATM/\"Classical IP\", RFC 1483 and\n\t * RFC 2225 say that SNAP encapsulation is used, not LLC\n\t * encapsulation with LLCSAP_IP.\n\t *\n\t * So we always check for ETHERTYPE_IP.\n\t */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portop(cstate, port, (u_int)ip_proto, dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portop(cstate, port, IPPROTO_TCP, dir);\n\t\tb1 = gen_portop(cstate, port, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portop(cstate, port, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstruct block *\ngen_portop6(compiler_state_t *cstate, u_int port, u_int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip6 proto 'proto' */\n\t/* XXX - catch the first fragment of a fragmented packet? */\n\tb0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portatom6(cstate, 0, port);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portatom6(cstate, 0, port);\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portatom6(cstate, 0, port);\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_port6(compiler_state_t *cstate, u_int port, int ip_proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip6 */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portop6(cstate, port, (u_int)ip_proto, dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portop6(cstate, port, IPPROTO_TCP, dir);\n\t\tb1 = gen_portop6(cstate, port, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portop6(cstate, port, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\n/* gen_portrange code */\nstatic struct block *\ngen_portrangeatom(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)\n{\n\tstruct block *b1, *b2;\n\n\tif (v1 > v2) {\n\t\t/*\n\t\t * Reverse the order of the ports, so v1 is the lower one.\n\t\t */\n\t\tbpf_u_int32 vtemp;\n\n\t\tvtemp = v1;\n\t\tv1 = v2;\n\t\tv2 = vtemp;\n\t}\n\n\tb1 = gen_cmp_ge(cstate, OR_TRAN_IPV4, off, BPF_H, v1);\n\tb2 = gen_cmp_le(cstate, OR_TRAN_IPV4, off, BPF_H, v2);\n\n\tgen_and(b1, b2);\n\n\treturn b2;\n}\n\nstatic struct block *\ngen_portrangeop(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip proto 'proto' and not a fragment other than the first fragment */\n\ttmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);\n\tb0 = gen_ipfrag(cstate);\n\tgen_and(tmp, b0);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_portrange(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portrangeop(cstate, port1, port2, (bpf_u_int32)ip_proto,\n\t\t    dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portrangeop(cstate, port1, port2, IPPROTO_TCP, dir);\n\t\tb1 = gen_portrangeop(cstate, port1, port2, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portrangeop(cstate, port1, port2, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstatic struct block *\ngen_portrangeatom6(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)\n{\n\tstruct block *b1, *b2;\n\n\tif (v1 > v2) {\n\t\t/*\n\t\t * Reverse the order of the ports, so v1 is the lower one.\n\t\t */\n\t\tbpf_u_int32 vtemp;\n\n\t\tvtemp = v1;\n\t\tv1 = v2;\n\t\tv2 = vtemp;\n\t}\n\n\tb1 = gen_cmp_ge(cstate, OR_TRAN_IPV6, off, BPF_H, v1);\n\tb2 = gen_cmp_le(cstate, OR_TRAN_IPV6, off, BPF_H, v2);\n\n\tgen_and(b1, b2);\n\n\treturn b2;\n}\n\nstatic struct block *\ngen_portrangeop6(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip6 proto 'proto' */\n\t/* XXX - catch the first fragment of a fragmented packet? */\n\tb0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_portrange6(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip6 */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portrangeop6(cstate, port1, port2, (bpf_u_int32)ip_proto,\n\t\t    dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_TCP, dir);\n\t\tb1 = gen_portrangeop6(cstate, port1, port2, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstatic int\nlookup_proto(compiler_state_t *cstate, const char *name, int proto)\n{\n\tregister int v;\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_IP:\n\tcase Q_IPV6:\n\t\tv = pcap_nametoproto(name);\n\t\tif (v == PROTO_UNDEF)\n\t\t\tbpf_error(cstate, \"unknown ip proto '%s'\", name);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\t/* XXX should look up h/w protocol type based on cstate->linktype */\n\t\tv = pcap_nametoeproto(name);\n\t\tif (v == PROTO_UNDEF) {\n\t\t\tv = pcap_nametollc(name);\n\t\t\tif (v == PROTO_UNDEF)\n\t\t\t\tbpf_error(cstate, \"unknown ether proto '%s'\", name);\n\t\t}\n\t\tbreak;\n\n\tcase Q_ISO:\n\t\tif (strcmp(name, \"esis\") == 0)\n\t\t\tv = ISO9542_ESIS;\n\t\telse if (strcmp(name, \"isis\") == 0)\n\t\t\tv = ISO10589_ISIS;\n\t\telse if (strcmp(name, \"clnp\") == 0)\n\t\t\tv = ISO8473_CLNP;\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown osi proto '%s'\", name);\n\t\tbreak;\n\n\tdefault:\n\t\tv = PROTO_UNDEF;\n\t\tbreak;\n\t}\n\treturn v;\n}\n\n#if !defined(NO_PROTOCHAIN)\nstatic struct block *\ngen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)\n{\n\tstruct block *b0, *b;\n\tstruct slist *s[100];\n\tint fix2, fix3, fix4, fix5;\n\tint ahcheck, again, end;\n\tint i, max;\n\tint reg2 = alloc_reg(cstate);\n\n\tmemset(s, 0, sizeof(s));\n\tfix3 = fix4 = fix5 = 0;\n\n\tswitch (proto) {\n\tcase Q_IP:\n\tcase Q_IPV6:\n\t\tbreak;\n\tcase Q_DEFAULT:\n\t\tb0 = gen_protochain(cstate, v, Q_IP);\n\t\tb = gen_protochain(cstate, v, Q_IPV6);\n\t\tgen_or(b0, b);\n\t\treturn b;\n\tdefault:\n\t\tbpf_error(cstate, \"bad protocol applied for 'protochain'\");\n\t\t/*NOTREACHED*/\n\t}\n\n\t/*\n\t * We don't handle variable-length prefixes before the link-layer\n\t * header, or variable-length link-layer headers, here yet.\n\t * We might want to add BPF instructions to do the protochain\n\t * work, to simplify that and, on platforms that have a BPF\n\t * interpreter with the new instructions, let the filtering\n\t * be done in the kernel.  (We already require a modified BPF\n\t * engine to do the protochain stuff, to support backward\n\t * branches, and backward branch support is unlikely to appear\n\t * in kernel BPF engines.)\n\t */\n\tif (cstate->off_linkpl.is_variable)\n\t\tbpf_error(cstate, \"'protochain' not supported with variable length headers\");\n\n\t/*\n\t * To quote a comment in optimize.c:\n\t *\n\t * \"These data structures are used in a Cocke and Schwartz style\n\t * value numbering scheme.  Since the flowgraph is acyclic,\n\t * exit values can be propagated from a node's predecessors\n\t * provided it is uniquely defined.\"\n\t *\n\t * \"Acyclic\" means \"no backward branches\", which means \"no\n\t * loops\", so we have to turn the optimizer off.\n\t */\n\tcstate->no_optimize = 1;\n\n\t/*\n\t * s[0] is a dummy entry to protect other BPF insn from damage\n\t * by s[fix] = foo with uninitialized variable \"fix\".  It is somewhat\n\t * hard to find interdependency made by jump table fixup.\n\t */\n\ti = 0;\n\ts[i] = new_stmt(cstate, 0);\t/*dummy*/\n\ti++;\n\n\tswitch (proto) {\n\tcase Q_IP:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\t\t/* A = ip->ip_p */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 9;\n\t\ti++;\n\t\t/* X = ip->ip_hl << 2 */\n\t\ts[i] = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\ti++;\n\t\tbreak;\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\t\t/* A = ip6->ip_nxt */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 6;\n\t\ti++;\n\t\t/* X = sizeof(struct ip6_hdr) */\n\t\ts[i] = new_stmt(cstate, BPF_LDX|BPF_IMM);\n\t\ts[i]->s.k = 40;\n\t\ti++;\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"unsupported proto to gen_protochain\");\n\t\t/*NOTREACHED*/\n\t}\n\n\t/* again: if (A == v) goto end; else fall through; */\n\tagain = i;\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.k = v;\n\ts[i]->s.jt = NULL;\t\t/*later*/\n\ts[i]->s.jf = NULL;\t\t/*update in next stmt*/\n\tfix5 = i;\n\ti++;\n\n#ifndef IPPROTO_NONE\n#define IPPROTO_NONE\t59\n#endif\n\t/* if (A == IPPROTO_NONE) goto end */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.jt = NULL;\t/*later*/\n\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\ts[i]->s.k = IPPROTO_NONE;\n\ts[fix5]->s.jf = s[i];\n\tfix2 = i;\n\ti++;\n\n\tif (proto == Q_IPV6) {\n\t\tint v6start, v6end, v6advance, j;\n\n\t\tv6start = i;\n\t\t/* if (A == IPPROTO_HOPOPTS) goto v6advance */\n\t\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_HOPOPTS;\n\t\ts[fix2]->s.jf = s[i];\n\t\ti++;\n\t\t/* if (A == IPPROTO_DSTOPTS) goto v6advance */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_DSTOPTS;\n\t\ti++;\n\t\t/* if (A == IPPROTO_ROUTING) goto v6advance */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_ROUTING;\n\t\ti++;\n\t\t/* if (A == IPPROTO_FRAGMENT) goto v6advance; else goto ahcheck; */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*later*/\n\t\ts[i]->s.k = IPPROTO_FRAGMENT;\n\t\tfix3 = i;\n\t\tv6end = i;\n\t\ti++;\n\n\t\t/* v6advance: */\n\t\tv6advance = i;\n\n\t\t/*\n\t\t * in short,\n\t\t * A = P[X + packet head];\n\t\t * X = X + (P[X + packet head + 1] + 1) * 8;\n\t\t */\n\t\t/* A = P[X + packet head] */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\ti++;\n\t\t/* MEM[reg2] = A */\n\t\ts[i] = new_stmt(cstate, BPF_ST);\n\t\ts[i]->s.k = reg2;\n\t\ti++;\n\t\t/* A = P[X + packet head + 1]; */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 1;\n\t\ti++;\n\t\t/* A += 1 */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\t\ts[i]->s.k = 1;\n\t\ti++;\n\t\t/* A *= 8 */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\t\ts[i]->s.k = 8;\n\t\ti++;\n\t\t/* A += X */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\t\ts[i]->s.k = 0;\n\t\ti++;\n\t\t/* X = A; */\n\t\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\ti++;\n\t\t/* A = MEM[reg2] */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_MEM);\n\t\ts[i]->s.k = reg2;\n\t\ti++;\n\n\t\t/* goto again; (must use BPF_JA for backward jump) */\n\t\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JA);\n\t\ts[i]->s.k = again - i - 1;\n\t\ts[i - 1]->s.jf = s[i];\n\t\ti++;\n\n\t\t/* fixup */\n\t\tfor (j = v6start; j <= v6end; j++)\n\t\t\ts[j]->s.jt = s[v6advance];\n\t} else {\n\t\t/* nop */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\t\ts[i]->s.k = 0;\n\t\ts[fix2]->s.jf = s[i];\n\t\ti++;\n\t}\n\n\t/* ahcheck: */\n\tahcheck = i;\n\t/* if (A == IPPROTO_AH) then fall through; else goto end; */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.jt = NULL;\t/*later*/\n\ts[i]->s.jf = NULL;\t/*later*/\n\ts[i]->s.k = IPPROTO_AH;\n\tif (fix3)\n\t\ts[fix3]->s.jf = s[ahcheck];\n\tfix4 = i;\n\ti++;\n\n\t/*\n\t * in short,\n\t * A = P[X];\n\t * X = X + (P[X + 1] + 2) * 4;\n\t */\n\t/* A = X */\n\ts[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\ti++;\n\t/* A = P[X + packet head]; */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\ti++;\n\t/* MEM[reg2] = A */\n\ts[i] = new_stmt(cstate, BPF_ST);\n\ts[i]->s.k = reg2;\n\ti++;\n\t/* A = X */\n\ts[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\ti++;\n\t/* A += 1 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 1;\n\ti++;\n\t/* X = A */\n\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\ti++;\n\t/* A = P[X + packet head] */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\ti++;\n\t/* A += 2 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 2;\n\ti++;\n\t/* A *= 4 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\ts[i]->s.k = 4;\n\ti++;\n\t/* X = A; */\n\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\ti++;\n\t/* A = MEM[reg2] */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts[i]->s.k = reg2;\n\ti++;\n\n\t/* goto again; (must use BPF_JA for backward jump) */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JA);\n\ts[i]->s.k = again - i - 1;\n\ti++;\n\n\t/* end: nop */\n\tend = i;\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 0;\n\ts[fix2]->s.jt = s[end];\n\ts[fix4]->s.jf = s[end];\n\ts[fix5]->s.jt = s[end];\n\ti++;\n\n\t/*\n\t * make slist chain\n\t */\n\tmax = i;\n\tfor (i = 0; i < max - 1; i++)\n\t\ts[i]->next = s[i + 1];\n\ts[max - 1]->next = NULL;\n\n\t/*\n\t * emit final check\n\t */\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s[1];\t/*remember, s[0] is dummy*/\n\tb->s.k = v;\n\n\tfree_reg(cstate, reg2);\n\n\tgen_and(b0, b);\n\treturn b;\n}\n#endif /* !defined(NO_PROTOCHAIN) */\n\nstatic struct block *\ngen_check_802_11_data_frame(compiler_state_t *cstate)\n{\n\tstruct slist *s;\n\tstruct block *b0, *b1;\n\n\t/*\n\t * A data frame has the 0x08 bit (b3) in the frame control field set\n\t * and the 0x04 bit (b2) clear.\n\t */\n\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\tb0 = new_block(cstate, JMP(BPF_JSET));\n\tb0->s.k = 0x08;\n\tb0->stmts = s;\n\n\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\tb1 = new_block(cstate, JMP(BPF_JSET));\n\tb1->s.k = 0x04;\n\tb1->stmts = s;\n\tgen_not(b1);\n\n\tgen_and(b1, b0);\n\n\treturn b0;\n}\n\n/*\n * Generate code that checks whether the packet is a packet for protocol\n * <proto> and whether the type field in that protocol's header has\n * the value <v>, e.g. if <proto> is Q_IP, it checks whether it's an\n * IP packet and checks the protocol number in the IP header against <v>.\n *\n * If <proto> is Q_DEFAULT, i.e. just \"proto\" was specified, it checks\n * against Q_IP and Q_IPV6.\n */\nstatic struct block *\ngen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)\n{\n\tstruct block *b0, *b1;\n\tstruct block *b2;\n\n\tif (dir != Q_DEFAULT)\n\t\tbpf_error(cstate, \"direction applied to 'proto'\");\n\n\tswitch (proto) {\n\tcase Q_DEFAULT:\n\t\tb0 = gen_proto(cstate, v, Q_IP, dir);\n\t\tb1 = gen_proto(cstate, v, Q_IPV6, dir);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_LINK:\n\t\treturn gen_linktype(cstate, v);\n\n\tcase Q_IP:\n\t\t/*\n\t\t * For FDDI, RFC 1188 says that SNAP encapsulation is used,\n\t\t * not LLC encapsulation with LLCSAP_IP.\n\t\t *\n\t\t * For IEEE 802 networks - which includes 802.5 token ring\n\t\t * (which is what DLT_IEEE802 means) and 802.11 - RFC 1042\n\t\t * says that SNAP encapsulation is used, not LLC encapsulation\n\t\t * with LLCSAP_IP.\n\t\t *\n\t\t * For LLC-encapsulated ATM/\"Classical IP\", RFC 1483 and\n\t\t * RFC 2225 say that SNAP encapsulation is used, not LLC\n\t\t * encapsulation with LLCSAP_IP.\n\t\t *\n\t\t * So we always check for ETHERTYPE_IP.\n\t\t */\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, v);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ARP:\n\t\tbpf_error(cstate, \"arp does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RARP:\n\t\tbpf_error(cstate, \"rarp does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk encapsulation is not specifiable\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_DECNET:\n\t\tbpf_error(cstate, \"DECNET encapsulation is not specifiable\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"LAT does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"SCA does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"MOPRC does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"MOPDL does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\t\t/*\n\t\t * Also check for a fragment header before the final\n\t\t * header.\n\t\t */\n\t\tb2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, IPPROTO_FRAGMENT);\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 40, BPF_B, v);\n\t\tgen_and(b2, b1);\n\t\tb2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, v);\n\t\tgen_or(b2, b1);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'esp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"'aarp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISO:\n\t\tswitch (cstate->linktype) {\n\n\t\tcase DLT_FRELAY:\n\t\t\t/*\n\t\t\t * Frame Relay packets typically have an OSI\n\t\t\t * NLPID at the beginning; \"gen_linktype(cstate, LLCSAP_ISONS)\"\n\t\t\t * generates code to check for all the OSI\n\t\t\t * NLPIDs, so calling it and then adding a check\n\t\t\t * for the particular NLPID for which we're\n\t\t\t * looking is bogus, as we can just check for\n\t\t\t * the NLPID.\n\t\t\t *\n\t\t\t * What we check for is the NLPID and a frame\n\t\t\t * control field value of UI, i.e. 0x03 followed\n\t\t\t * by the NLPID.\n\t\t\t *\n\t\t\t * XXX - assumes a 2-byte Frame Relay header with\n\t\t\t * DLCI and flags.  What if the address is longer?\n\t\t\t *\n\t\t\t * XXX - what about SNAP-encapsulated frames?\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | v);\n\t\t\t/*NOTREACHED*/\n\n\t\tcase DLT_C_HDLC:\n\t\tcase DLT_HDLC:\n\t\t\t/*\n\t\t\t * Cisco uses an Ethertype lookalike - for OSI,\n\t\t\t * it's 0xfefe.\n\t\t\t */\n\t\t\tb0 = gen_linktype(cstate, LLCSAP_ISONS<<8 | LLCSAP_ISONS);\n\t\t\t/* OSI in C-HDLC is stuffed with a fudge byte */\n\t\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 1, BPF_B, v);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\n\t\tdefault:\n\t\t\tb0 = gen_linktype(cstate, LLCSAP_ISONS);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 0, BPF_B, v);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t}\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS:\n\t\tb0 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);\n\t\t/*\n\t\t * 4 is the offset of the PDU type relative to the IS-IS\n\t\t * header.\n\t\t */\n\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 4, BPF_B, v);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp proto' is not supported\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"'ipx proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}\n\n/*\n * Convert a non-numeric name to a port number.\n */\nstatic int\nnametoport(compiler_state_t *cstate, const char *name, int ipproto)\n{\n\tstruct addrinfo hints, *res, *ai;\n\tint error;\n\tstruct sockaddr_in *in4;\n#ifdef INET6\n\tstruct sockaddr_in6 *in6;\n#endif\n\tint port = -1;\n\n\t/*\n\t * We check for both TCP and UDP in case there are\n\t * ambiguous entries.\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = (ipproto == IPPROTO_TCP) ? SOCK_STREAM : SOCK_DGRAM;\n\thints.ai_protocol = ipproto;\n\terror = getaddrinfo(NULL, name, &hints, &res);\n\tif (error != 0) {\n\t\tswitch (error) {\n\n\t\tcase EAI_NONAME:\n\t\tcase EAI_SERVICE:\n\t\t\t/*\n\t\t\t * No such port.  Just return -1.\n\t\t\t */\n\t\t\tbreak;\n\n#ifdef EAI_SYSTEM\n\t\tcase EAI_SYSTEM:\n\t\t\t/*\n\t\t\t * We don't use strerror() because it's not\n\t\t\t * guaranteed to be thread-safe on all platforms\n\t\t\t * (probably because it might use a non-thread-local\n\t\t\t * buffer into which to format an error message\n\t\t\t * if the error code isn't one for which it has\n\t\t\t * a canned string; three cheers for C string\n\t\t\t * handling).\n\t\t\t */\n\t\t\tbpf_set_error(cstate, \"getaddrinfo(\\\"%s\\\" fails with system error: %d\",\n\t\t\t    name, errno);\n\t\t\tport = -2;\t/* a real error */\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * This is a real error, not just \"there's\n\t\t\t * no such service name\".\n\t\t\t *\n\t\t\t * We don't use gai_strerror() because it's not\n\t\t\t * guaranteed to be thread-safe on all platforms\n\t\t\t * (probably because it might use a non-thread-local\n\t\t\t * buffer into which to format an error message\n\t\t\t * if the error code isn't one for which it has\n\t\t\t * a canned string; three cheers for C string\n\t\t\t * handling).\n\t\t\t */\n\t\t\tbpf_set_error(cstate, \"getaddrinfo(\\\"%s\\\") fails with error: %d\",\n\t\t\t    name, error);\n\t\t\tport = -2;\t/* a real error */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * OK, we found it.  Did it find anything?\n\t\t */\n\t\tfor (ai = res; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Get a port number; we're done.\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\tport = ntohs(in4->sin_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef INET6\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET6) {\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\t\t\tport = ntohs(in6->sin6_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(res);\n\t}\n\treturn port;\n}\n\n/*\n * Convert a string to a port number.\n */\nstatic bpf_u_int32\nstringtoport(compiler_state_t *cstate, const char *string, size_t string_size,\n    int *proto)\n{\n\tstoulen_ret ret;\n\tchar *cpy;\n\tbpf_u_int32 val;\n\tint tcp_port = -1;\n\tint udp_port = -1;\n\n\t/*\n\t * See if it's a number.\n\t */\n\tret = stoulen(string, string_size, &val, cstate);\n\tswitch (ret) {\n\n\tcase STOULEN_OK:\n\t\t/* Unknown port type - it's just a number. */\n\t\t*proto = PROTO_UNDEF;\n\t\tbreak;\n\n\tcase STOULEN_NOT_OCTAL_NUMBER:\n\tcase STOULEN_NOT_HEX_NUMBER:\n\tcase STOULEN_NOT_DECIMAL_NUMBER:\n\t\t/*\n\t\t * Not a valid number; try looking it up as a port.\n\t\t */\n\t\tcpy = malloc(string_size + 1);\t/* +1 for terminating '\\0' */\n\t\tmemcpy(cpy, string, string_size);\n\t\tcpy[string_size] = '\\0';\n\t\ttcp_port = nametoport(cstate, cpy, IPPROTO_TCP);\n\t\tif (tcp_port == -2) {\n\t\t\t/*\n\t\t\t * We got a hard error; the error string has\n\t\t\t * already been set.\n\t\t\t */\n\t\t\tfree(cpy);\n\t\t\tlongjmp(cstate->top_ctx, 1);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\tudp_port = nametoport(cstate, cpy, IPPROTO_UDP);\n\t\tif (udp_port == -2) {\n\t\t\t/*\n\t\t\t * We got a hard error; the error string has\n\t\t\t * already been set.\n\t\t\t */\n\t\t\tfree(cpy);\n\t\t\tlongjmp(cstate->top_ctx, 1);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\t\t/*\n\t\t * We need to check /etc/services for ambiguous entries.\n\t\t * If we find an ambiguous entry, and it has the\n\t\t * same port number, change the proto to PROTO_UNDEF\n\t\t * so both TCP and UDP will be checked.\n\t\t */\n\t\tif (tcp_port >= 0) {\n\t\t\tval = (bpf_u_int32)tcp_port;\n\t\t\t*proto = IPPROTO_TCP;\n\t\t\tif (udp_port >= 0) {\n\t\t\t\tif (udp_port == tcp_port)\n\t\t\t\t\t*proto = PROTO_UNDEF;\n#ifdef notdef\n\t\t\t\telse\n\t\t\t\t\t/* Can't handle ambiguous names that refer\n\t\t\t\t\t   to different port numbers. */\n\t\t\t\t\twarning(\"ambiguous port %s in /etc/services\",\n\t\t\t\t\t\tcpy);\n#endif\n\t\t\t}\n\t\t\tfree(cpy);\n\t\t\tbreak;\n\t\t}\n\t\tif (udp_port >= 0) {\n\t\t\tval = (bpf_u_int32)udp_port;\n\t\t\t*proto = IPPROTO_UDP;\n\t\t\tfree(cpy);\n\t\t\tbreak;\n\t\t}\n\t\tbpf_set_error(cstate, \"'%s' is not a valid port\", cpy);\n\t\tfree(cpy);\n\t\tlongjmp(cstate->top_ctx, 1);\n\t\t/*NOTREACHED*/\n#ifdef _AIX\n\t\tPCAP_UNREACHABLE\n#endif /* _AIX */\n\n\tcase STOULEN_ERROR:\n\t\t/* Error already set. */\n\t\tlongjmp(cstate->top_ctx, 1);\n\t\t/*NOTREACHED*/\n#ifdef _AIX\n\t\tPCAP_UNREACHABLE\n#endif /* _AIX */\n\n\tdefault:\n\t\t/* Should not happen */\n\t\tbpf_set_error(cstate, \"stoulen returned %d - this should not happen\", ret);\n\t\tlongjmp(cstate->top_ctx, 1);\n\t\t/*NOTREACHED*/\n\t}\n\treturn (val);\n}\n\n/*\n * Convert a string in the form PPP-PPP, which correspond to ports, to\n * a starting and ending port in a port range.\n */\nstatic void\nstringtoportrange(compiler_state_t *cstate, const char *string,\n    bpf_u_int32 *port1, bpf_u_int32 *port2, int *proto)\n{\n\tchar *hyphen_off;\n\tconst char *first, *second;\n\tsize_t first_size, second_size;\n\tint save_proto;\n\n\tif ((hyphen_off = strchr(string, '-')) == NULL)\n\t\tbpf_error(cstate, \"port range '%s' contains no hyphen\", string);\n\n\t/*\n\t * Make sure there are no other hyphens.\n\t *\n\t * XXX - we support named ports, but there are some port names\n\t * in /etc/services that include hyphens, so this would rule\n\t * that out.\n\t */\n\tif (strchr(hyphen_off + 1, '-') != NULL)\n\t\tbpf_error(cstate, \"port range '%s' contains more than one hyphen\",\n\t\t    string);\n\n\t/*\n\t * Get the length of the first port.\n\t */\n\tfirst = string;\n\tfirst_size = hyphen_off - string;\n\tif (first_size == 0) {\n\t\t/* Range of \"-port\", which we don't support. */\n\t\tbpf_error(cstate, \"port range '%s' has no starting port\", string);\n\t}\n\n\t/*\n\t * Try to convert it to a port.\n\t */\n\t*port1 = stringtoport(cstate, first, first_size, proto);\n\tsave_proto = *proto;\n\n\t/*\n\t * Get the length of the second port.\n\t */\n\tsecond = hyphen_off + 1;\n\tsecond_size = strlen(second);\n\tif (second_size == 0) {\n\t\t/* Range of \"port-\", which we don't support. */\n\t\tbpf_error(cstate, \"port range '%s' has no ending port\", string);\n\t}\n\n\t/*\n\t * Try to convert it to a port.\n\t */\n\t*port2 = stringtoport(cstate, second, second_size, proto);\n\tif (*proto != save_proto)\n\t\t*proto = PROTO_UNDEF;\n}\n\nstruct block *\ngen_scode(compiler_state_t *cstate, const char *name, struct qual q)\n{\n\tint proto = q.proto;\n\tint dir = q.dir;\n\tint tproto;\n\tu_char *eaddr;\n\tbpf_u_int32 mask, addr;\n\tstruct addrinfo *res, *res0;\n\tstruct sockaddr_in *sin4;\n#ifdef INET6\n\tint tproto6;\n\tstruct sockaddr_in6 *sin6;\n\tstruct in6_addr mask128;\n#endif /*INET6*/\n\tstruct block *b, *tmp;\n\tint port, real_proto;\n\tbpf_u_int32 port1, port2;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (q.addr) {\n\n\tcase Q_NET:\n\t\taddr = pcap_nametonetaddr(name);\n\t\tif (addr == 0)\n\t\t\tbpf_error(cstate, \"unknown network '%s'\", name);\n\t\t/* Left justify network addr and calculate its network mask */\n\t\tmask = 0xffffffff;\n\t\twhile (addr && (addr & 0xff000000) == 0) {\n\t\t\taddr <<= 8;\n\t\t\tmask <<= 8;\n\t\t}\n\t\treturn gen_host(cstate, addr, mask, proto, dir, q.addr);\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\t\tif (proto == Q_LINK) {\n\t\t\tswitch (cstate->linktype) {\n\n\t\t\tcase DLT_EN10MB:\n\t\t\tcase DLT_NETANALYZER:\n\t\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown ether host '%s'\", name);\n\t\t\t\ttmp = gen_prevlinkhdr_check(cstate);\n\t\t\t\tb = gen_ehostop(cstate, eaddr, dir);\n\t\t\t\tif (tmp != NULL)\n\t\t\t\t\tgen_and(tmp, b);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_FDDI:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown FDDI host '%s'\", name);\n\t\t\t\tb = gen_fhostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IEEE802:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown token ring host '%s'\", name);\n\t\t\t\tb = gen_thostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IEEE802_11:\n\t\t\tcase DLT_PRISM_HEADER:\n\t\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\tcase DLT_PPI:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown 802.11 host '%s'\", name);\n\t\t\t\tb = gen_wlanhostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IP_OVER_FC:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown Fibre Channel host '%s'\", name);\n\t\t\t\tb = gen_ipfchostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\tbpf_error(cstate, \"only ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel supports link-level host name\");\n\t\t} else if (proto == Q_DECNET) {\n\t\t\t/*\n\t\t\t * A long time ago on Ultrix libpcap supported\n\t\t\t * translation of DECnet host names into DECnet\n\t\t\t * addresses, but this feature is history now.\n\t\t\t */\n\t\t\tbpf_error(cstate, \"invalid DECnet address '%s'\", name);\n\t\t} else {\n#ifdef INET6\n\t\t\tmemset(&mask128, 0xff, sizeof(mask128));\n#endif\n\t\t\tres0 = res = pcap_nametoaddrinfo(name);\n\t\t\tif (res == NULL)\n\t\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\t\tcstate->ai = res;\n\t\t\tb = tmp = NULL;\n\t\t\ttproto = proto;\n#ifdef INET6\n\t\t\ttproto6 = proto;\n#endif\n\t\t\tif (cstate->off_linktype.constant_part == OFFSET_NOT_SET &&\n\t\t\t    tproto == Q_DEFAULT) {\n\t\t\t\ttproto = Q_IP;\n#ifdef INET6\n\t\t\t\ttproto6 = Q_IPV6;\n#endif\n\t\t\t}\n\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\tswitch (res->ai_family) {\n\t\t\t\tcase AF_INET:\n#ifdef INET6\n\t\t\t\t\tif (tproto == Q_IPV6)\n\t\t\t\t\t\tcontinue;\n#endif\n\n\t\t\t\t\tsin4 = (struct sockaddr_in *)\n\t\t\t\t\t\tres->ai_addr;\n\t\t\t\t\ttmp = gen_host(cstate, ntohl(sin4->sin_addr.s_addr),\n\t\t\t\t\t\t0xffffffff, tproto, dir, q.addr);\n\t\t\t\t\tbreak;\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tif (tproto6 == Q_IP)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t\tres->ai_addr;\n\t\t\t\t\ttmp = gen_host6(cstate, &sin6->sin6_addr,\n\t\t\t\t\t\t&mask128, tproto6, dir, q.addr);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (b)\n\t\t\t\t\tgen_or(b, tmp);\n\t\t\t\tb = tmp;\n\t\t\t}\n\t\t\tcstate->ai = NULL;\n\t\t\tfreeaddrinfo(res0);\n\t\t\tif (b == NULL) {\n\t\t\t\tbpf_error(cstate, \"unknown host '%s'%s\", name,\n\t\t\t\t    (proto == Q_DEFAULT)\n\t\t\t\t\t? \"\"\n\t\t\t\t\t: \" for specified address family\");\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\tcase Q_PORT:\n\t\tif (proto != Q_DEFAULT &&\n\t\t    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'port'\");\n\t\tif (pcap_nametoport(name, &port, &real_proto) == 0)\n\t\t\tbpf_error(cstate, \"unknown port '%s'\", name);\n\t\tif (proto == Q_UDP) {\n\t\t\tif (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is tcp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_UDP;\n\t\t}\n\t\tif (proto == Q_TCP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is udp\", name);\n\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_TCP;\n\t\t}\n\t\tif (proto == Q_SCTP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is udp\", name);\n\n\t\t\telse if (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is tcp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_SCTP;\n\t\t}\n\t\tif (port < 0)\n\t\t\tbpf_error(cstate, \"illegal port number %d < 0\", port);\n\t\tif (port > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port);\n\t\tb = gen_port(cstate, port, real_proto, dir);\n\t\tgen_or(gen_port6(cstate, port, real_proto, dir), b);\n\t\treturn b;\n\n\tcase Q_PORTRANGE:\n\t\tif (proto != Q_DEFAULT &&\n\t\t    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'portrange'\");\n\t\tstringtoportrange(cstate, name, &port1, &port2, &real_proto);\n\t\tif (proto == Q_UDP) {\n\t\t\tif (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is tcp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_UDP;\n\t\t}\n\t\tif (proto == Q_TCP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is udp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_TCP;\n\t\t}\n\t\tif (proto == Q_SCTP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is udp\", name);\n\t\t\telse if (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is tcp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_SCTP;\n\t\t}\n\t\tif (port1 > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port1);\n\t\tif (port2 > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port2);\n\n\t\tb = gen_portrange(cstate, port1, port2, real_proto, dir);\n\t\tgen_or(gen_portrange6(cstate, port1, port2, real_proto, dir), b);\n\t\treturn b;\n\n\tcase Q_GATEWAY:\n#ifndef INET6\n\t\teaddr = pcap_ether_hostton(name);\n\t\tif (eaddr == NULL)\n\t\t\tbpf_error(cstate, \"unknown ether host: %s\", name);\n\n\t\tres = pcap_nametoaddrinfo(name);\n\t\tcstate->ai = res;\n\t\tif (res == NULL)\n\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\tb = gen_gateway(cstate, eaddr, res, proto, dir);\n\t\tcstate->ai = NULL;\n\t\tfreeaddrinfo(res);\n\t\tif (b == NULL)\n\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\treturn b;\n#else\n\t\tbpf_error(cstate, \"'gateway' not supported in this configuration\");\n#endif /*INET6*/\n\n\tcase Q_PROTO:\n\t\treal_proto = lookup_proto(cstate, name, proto);\n\t\tif (real_proto >= 0)\n\t\t\treturn gen_proto(cstate, real_proto, proto, dir);\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown protocol: %s\", name);\n\n#if !defined(NO_PROTOCHAIN)\n\tcase Q_PROTOCHAIN:\n\t\treal_proto = lookup_proto(cstate, name, proto);\n\t\tif (real_proto >= 0)\n\t\t\treturn gen_protochain(cstate, real_proto, proto);\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown protocol: %s\", name);\n#endif /* !defined(NO_PROTOCHAIN) */\n\n\tcase Q_UNDEF:\n\t\tsyntax(cstate);\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\nstruct block *\ngen_mcode(compiler_state_t *cstate, const char *s1, const char *s2,\n    bpf_u_int32 masklen, struct qual q)\n{\n\tregister int nlen, mlen;\n\tbpf_u_int32 n, m;\n\tuint64_t m64;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tnlen = __pcap_atoin(s1, &n);\n\tif (nlen < 0)\n\t\tbpf_error(cstate, \"invalid IPv4 address '%s'\", s1);\n\t/* Promote short ipaddr */\n\tn <<= 32 - nlen;\n\n\tif (s2 != NULL) {\n\t\tmlen = __pcap_atoin(s2, &m);\n\t\tif (mlen < 0)\n\t\t\tbpf_error(cstate, \"invalid IPv4 address '%s'\", s2);\n\t\t/* Promote short ipaddr */\n\t\tm <<= 32 - mlen;\n\t\tif ((n & ~m) != 0)\n\t\t\tbpf_error(cstate, \"non-network bits set in \\\"%s mask %s\\\"\",\n\t\t\t    s1, s2);\n\t} else {\n\t\t/* Convert mask len to mask */\n\t\tif (masklen > 32)\n\t\t\tbpf_error(cstate, \"mask length must be <= 32\");\n\t\tm64 = UINT64_C(0xffffffff) << (32 - masklen);\n\t\tm = (bpf_u_int32)m64;\n\t\tif ((n & ~m) != 0)\n\t\t\tbpf_error(cstate, \"non-network bits set in \\\"%s/%d\\\"\",\n\t\t\t    s1, masklen);\n\t}\n\n\tswitch (q.addr) {\n\n\tcase Q_NET:\n\t\treturn gen_host(cstate, n, m, q.proto, q.dir, q.addr);\n\n\tdefault:\n\t\tbpf_error(cstate, \"Mask syntax for networks only\");\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}\n\nstruct block *\ngen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)\n{\n\tbpf_u_int32 mask;\n\tint proto;\n\tint dir;\n\tregister int vlen;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tproto = q.proto;\n\tdir = q.dir;\n\tif (s == NULL) {\n\t\t/*\n\t\t * v contains a 32-bit unsigned parsed from a string of the\n\t\t * form {N}, which could be decimal, hexadecimal or octal.\n\t\t * Although it would be possible to use the value as a raw\n\t\t * 16-bit DECnet address when the value fits into 16 bits, this\n\t\t * would be a questionable feature: DECnet address wire\n\t\t * encoding is little-endian, so this would not work as\n\t\t * intuitively as the same works for [big-endian] IPv4\n\t\t * addresses (0x01020304 means 1.2.3.4).\n\t\t */\n\t\tif (proto == Q_DECNET)\n\t\t\tbpf_error(cstate, \"invalid DECnet address '%u'\", v);\n\t\tvlen = 32;\n\t} else if (proto == Q_DECNET) {\n\t\t/*\n\t\t * s points to a string of the form {N}.{N}, {N}.{N}.{N} or\n\t\t * {N}.{N}.{N}.{N}, of which only the first potentially stands\n\t\t * for a valid DECnet address.\n\t\t */\n\t\tvlen = __pcap_atodn(s, &v);\n\t\tif (vlen == 0)\n\t\t\tbpf_error(cstate, \"invalid DECnet address '%s'\", s);\n\t} else {\n\t\t/*\n\t\t * s points to a string of the form {N}.{N}, {N}.{N}.{N} or\n\t\t * {N}.{N}.{N}.{N}, all of which potentially stand for a valid\n\t\t * IPv4 address.\n\t\t */\n\t\tvlen = __pcap_atoin(s, &v);\n\t\tif (vlen < 0)\n\t\t\tbpf_error(cstate, \"invalid IPv4 address '%s'\", s);\n\t}\n\n\tswitch (q.addr) {\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\tcase Q_NET:\n\t\tif (proto == Q_DECNET)\n\t\t\treturn gen_host(cstate, v, 0, proto, dir, q.addr);\n\t\telse if (proto == Q_LINK) {\n\t\t\tbpf_error(cstate, \"illegal link layer address\");\n\t\t} else {\n\t\t\tmask = 0xffffffff;\n\t\t\tif (s == NULL && q.addr == Q_NET) {\n\t\t\t\t/* Promote short net number */\n\t\t\t\twhile (v && (v & 0xff000000) == 0) {\n\t\t\t\t\tv <<= 8;\n\t\t\t\t\tmask <<= 8;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Promote short ipaddr */\n\t\t\t\tv <<= 32 - vlen;\n\t\t\t\tmask <<= 32 - vlen ;\n\t\t\t}\n\t\t\treturn gen_host(cstate, v, mask, proto, dir, q.addr);\n\t\t}\n\n\tcase Q_PORT:\n\t\tif (proto == Q_UDP)\n\t\t\tproto = IPPROTO_UDP;\n\t\telse if (proto == Q_TCP)\n\t\t\tproto = IPPROTO_TCP;\n\t\telse if (proto == Q_SCTP)\n\t\t\tproto = IPPROTO_SCTP;\n\t\telse if (proto == Q_DEFAULT)\n\t\t\tproto = PROTO_UNDEF;\n\t\telse\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'port'\");\n\n\t\tif (v > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %u > 65535\", v);\n\n\t    {\n\t\tstruct block *b;\n\t\tb = gen_port(cstate, v, proto, dir);\n\t\tgen_or(gen_port6(cstate, v, proto, dir), b);\n\t\treturn b;\n\t    }\n\n\tcase Q_PORTRANGE:\n\t\tif (proto == Q_UDP)\n\t\t\tproto = IPPROTO_UDP;\n\t\telse if (proto == Q_TCP)\n\t\t\tproto = IPPROTO_TCP;\n\t\telse if (proto == Q_SCTP)\n\t\t\tproto = IPPROTO_SCTP;\n\t\telse if (proto == Q_DEFAULT)\n\t\t\tproto = PROTO_UNDEF;\n\t\telse\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'portrange'\");\n\n\t\tif (v > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %u > 65535\", v);\n\n\t    {\n\t\tstruct block *b;\n\t\tb = gen_portrange(cstate, v, v, proto, dir);\n\t\tgen_or(gen_portrange6(cstate, v, v, proto, dir), b);\n\t\treturn b;\n\t    }\n\n\tcase Q_GATEWAY:\n\t\tbpf_error(cstate, \"'gateway' requires a name\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_PROTO:\n\t\treturn gen_proto(cstate, v, proto, dir);\n\n#if !defined(NO_PROTOCHAIN)\n\tcase Q_PROTOCHAIN:\n\t\treturn gen_protochain(cstate, v, proto);\n#endif\n\n\tcase Q_UNDEF:\n\t\tsyntax(cstate);\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}\n\n#ifdef INET6\nstruct block *\ngen_mcode6(compiler_state_t *cstate, const char *s, bpf_u_int32 masklen,\n    struct qual q)\n{\n\tstruct addrinfo *res;\n\tstruct in6_addr *addr;\n\tstruct in6_addr mask;\n\tstruct block *b;\n\tbpf_u_int32 a[4], m[4]; /* Same as in gen_hostop6(). */\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tres = pcap_nametoaddrinfo(s);\n\tif (!res)\n\t\tbpf_error(cstate, \"invalid ip6 address %s\", s);\n\tcstate->ai = res;\n\tif (res->ai_next)\n\t\tbpf_error(cstate, \"%s resolved to multiple address\", s);\n\taddr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;\n\n\tif (masklen > sizeof(mask.s6_addr) * 8)\n\t\tbpf_error(cstate, \"mask length must be <= %zu\", sizeof(mask.s6_addr) * 8);\n\tmemset(&mask, 0, sizeof(mask));\n\tmemset(&mask.s6_addr, 0xff, masklen / 8);\n\tif (masklen % 8) {\n\t\tmask.s6_addr[masklen / 8] =\n\t\t\t(0xff << (8 - masklen % 8)) & 0xff;\n\t}\n\n\tmemcpy(a, addr, sizeof(a));\n\tmemcpy(m, &mask, sizeof(m));\n\tif ((a[0] & ~m[0]) || (a[1] & ~m[1])\n\t || (a[2] & ~m[2]) || (a[3] & ~m[3])) {\n\t\tbpf_error(cstate, \"non-network bits set in \\\"%s/%d\\\"\", s, masklen);\n\t}\n\n\tswitch (q.addr) {\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\t\tif (masklen != 128)\n\t\t\tbpf_error(cstate, \"Mask syntax for networks only\");\n\t\t/* FALLTHROUGH */\n\n\tcase Q_NET:\n\t\tb = gen_host6(cstate, addr, &mask, q.proto, q.dir, q.addr);\n\t\tcstate->ai = NULL;\n\t\tfreeaddrinfo(res);\n\t\treturn b;\n\n\tdefault:\n\t\tbpf_error(cstate, \"invalid qualifier against IPv6 address\");\n\t\t/*NOTREACHED*/\n\t}\n}\n#endif /*INET6*/\n\nstruct block *\ngen_ecode(compiler_state_t *cstate, const char *s, struct qual q)\n{\n\tstruct block *b, *tmp;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {\n\t\tcstate->e = pcap_ether_aton(s);\n\t\tif (cstate->e == NULL)\n\t\t\tbpf_error(cstate, \"malloc\");\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\ttmp = gen_prevlinkhdr_check(cstate);\n\t\t\tb = gen_ehostop(cstate, cstate->e, (int)q.dir);\n\t\t\tif (tmp != NULL)\n\t\t\t\tgen_and(tmp, b);\n\t\t\tbreak;\n\t\tcase DLT_FDDI:\n\t\t\tb = gen_fhostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802:\n\t\t\tb = gen_thostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\tb = gen_wlanhostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb = gen_ipfchostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree(cstate->e);\n\t\t\tcstate->e = NULL;\n\t\t\tbpf_error(cstate, \"ethernet addresses supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\tfree(cstate->e);\n\t\tcstate->e = NULL;\n\t\treturn (b);\n\t}\n\tbpf_error(cstate, \"ethernet address used in non-ether expression\");\n\t/*NOTREACHED*/\n}\n\nvoid\nsappend(struct slist *s0, struct slist *s1)\n{\n\t/*\n\t * This is definitely not the best way to do this, but the\n\t * lists will rarely get long.\n\t */\n\twhile (s0->next)\n\t\ts0 = s0->next;\n\ts0->next = s1;\n}\n\nstatic struct slist *\nxfer_to_x(compiler_state_t *cstate, struct arth *a)\n{\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts->s.k = a->regno;\n\treturn s;\n}\n\nstatic struct slist *\nxfer_to_a(compiler_state_t *cstate, struct arth *a)\n{\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts->s.k = a->regno;\n\treturn s;\n}\n\n/*\n * Modify \"index\" to use the value stored into its register as an\n * offset relative to the beginning of the header for the protocol\n * \"proto\", and allocate a register and put an item \"size\" bytes long\n * (1, 2, or 4) at that offset into that register, making it the register\n * for \"index\".\n */\nstatic struct arth *\ngen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)\n{\n\tint size_code;\n\tstruct slist *s, *tmp;\n\tstruct block *b;\n\tint regno = alloc_reg(cstate);\n\n\tfree_reg(cstate, inst->regno);\n\tswitch (size) {\n\n\tdefault:\n\t\tbpf_error(cstate, \"data size must be 1, 2, or 4\");\n\t\t/*NOTREACHED*/\n\n\tcase 1:\n\t\tsize_code = BPF_B;\n\t\tbreak;\n\n\tcase 2:\n\t\tsize_code = BPF_H;\n\t\tbreak;\n\n\tcase 4:\n\t\tsize_code = BPF_W;\n\t\tbreak;\n\t}\n\tswitch (proto) {\n\tdefault:\n\t\tbpf_error(cstate, \"unsupported index operation\");\n\n\tcase Q_RADIO:\n\t\t/*\n\t\t * The offset is relative to the beginning of the packet\n\t\t * data, if we have a radio header.  (If we don't, this\n\t\t * is an error.)\n\t\t */\n\t\tif (cstate->linktype != DLT_IEEE802_11_RADIO_AVS &&\n\t\t    cstate->linktype != DLT_IEEE802_11_RADIO &&\n\t\t    cstate->linktype != DLT_PRISM_HEADER)\n\t\t\tbpf_error(cstate, \"radio information not present in capture\");\n\n\t\t/*\n\t\t * Load into the X register the offset computed into the\n\t\t * register specified by \"index\".\n\t\t */\n\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at that offset.\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the link-layer header.\n\t\t *\n\t\t * XXX - what about ATM LANE?  Should the index be\n\t\t * relative to the beginning of the AAL5 frame, so\n\t\t * that 0 refers to the beginning of the LE Control\n\t\t * field, or relative to the beginning of the LAN\n\t\t * frame, so that 0 refers, for Ethernet LANE, to\n\t\t * the beginning of the destination address?\n\t\t */\n\t\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkhdr);\n\n\t\t/*\n\t\t * If \"s\" is non-null, it has code to arrange that the\n\t\t * X register contains the length of the prefix preceding\n\t\t * the link-layer header.  Add to it the offset computed\n\t\t * into the register specified by \"index\", and move that\n\t\t * into the X register.  Otherwise, just load into the X\n\t\t * register the offset computed into the register specified\n\t\t * by \"index\".\n\t\t */\n\t\tif (s != NULL) {\n\t\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\t} else\n\t\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at the sum of the offset we've put in the\n\t\t * X register and the offset of the start of the link\n\t\t * layer header (which is 0 if the radio header is\n\t\t * variable-length; that header length is what we put\n\t\t * into the X register and then added to the index).\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\ttmp->s.k = cstate->off_linkhdr.constant_part;\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\t\tbreak;\n\n\tcase Q_IP:\n\tcase Q_ARP:\n\tcase Q_RARP:\n\tcase Q_ATALK:\n\tcase Q_DECNET:\n\tcase Q_SCA:\n\tcase Q_LAT:\n\tcase Q_MOPRC:\n\tcase Q_MOPDL:\n\tcase Q_IPV6:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the network-layer header.\n\t\t * XXX - are there any cases where we want\n\t\t * cstate->off_nl_nosnap?\n\t\t */\n\t\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\n\t\t/*\n\t\t * If \"s\" is non-null, it has code to arrange that the\n\t\t * X register contains the variable part of the offset\n\t\t * of the link-layer payload.  Add to it the offset\n\t\t * computed into the register specified by \"index\",\n\t\t * and move that into the X register.  Otherwise, just\n\t\t * load into the X register the offset computed into\n\t\t * the register specified by \"index\".\n\t\t */\n\t\tif (s != NULL) {\n\t\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\t} else\n\t\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at the sum of the offset we've put in the\n\t\t * X register, the offset of the start of the network\n\t\t * layer header from the beginning of the link-layer\n\t\t * payload, and the constant part of the offset of the\n\t\t * start of the link-layer payload.\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\ttmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\n\t\t/*\n\t\t * Do the computation only if the packet contains\n\t\t * the protocol in question.\n\t\t */\n\t\tb = gen_proto_abbrev_internal(cstate, proto);\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tinst->b = b;\n\t\tbreak;\n\n\tcase Q_SCTP:\n\tcase Q_TCP:\n\tcase Q_UDP:\n\tcase Q_ICMP:\n\tcase Q_IGMP:\n\tcase Q_IGRP:\n\tcase Q_PIM:\n\tcase Q_VRRP:\n\tcase Q_CARP:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the transport-layer header.\n\t\t *\n\t\t * Load the X register with the length of the IPv4 header\n\t\t * (plus the offset of the link-layer header, if it's\n\t\t * a variable-length header), in bytes.\n\t\t *\n\t\t * XXX - are there any cases where we want\n\t\t * cstate->off_nl_nosnap?\n\t\t * XXX - we should, if we're built with\n\t\t * IPv6 support, generate code to load either\n\t\t * IPv4, IPv6, or both, as appropriate.\n\t\t */\n\t\ts = gen_loadx_iphdrlen(cstate);\n\n\t\t/*\n\t\t * The X register now contains the sum of the variable\n\t\t * part of the offset of the link-layer payload and the\n\t\t * length of the network-layer header.\n\t\t *\n\t\t * Load into the A register the offset relative to\n\t\t * the beginning of the transport layer header,\n\t\t * add the X register to that, move that to the\n\t\t * X register, and load with an offset from the\n\t\t * X register equal to the sum of the constant part of\n\t\t * the offset of the link-layer payload and the offset,\n\t\t * relative to the beginning of the link-layer payload,\n\t\t * of the network-layer header.\n\t\t */\n\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\tsappend(s, tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code));\n\t\ttmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(inst->s, s);\n\n\t\t/*\n\t\t * Do the computation only if the packet contains\n\t\t * the protocol in question - which is true only\n\t\t * if this is an IP datagram and is the first or\n\t\t * only fragment of that datagram.\n\t\t */\n\t\tgen_and(gen_proto_abbrev_internal(cstate, proto), b = gen_ipfrag(cstate));\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tgen_and(gen_proto_abbrev_internal(cstate, Q_IP), b);\n\t\tinst->b = b;\n\t\tbreak;\n\tcase Q_ICMPV6:\n\t\t/*\n\t\t * Do the computation only if the packet contains\n\t\t * the protocol in question.\n\t\t */\n\t\tb = gen_proto_abbrev_internal(cstate, Q_IPV6);\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tinst->b = b;\n\n\t\t/*\n\t\t * Check if we have an icmp6 next header\n\t\t */\n\t\tb = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tinst->b = b;\n\n\t\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\t\t/*\n\t\t * If \"s\" is non-null, it has code to arrange that the\n\t\t * X register contains the variable part of the offset\n\t\t * of the link-layer payload.  Add to it the offset\n\t\t * computed into the register specified by \"index\",\n\t\t * and move that into the X register.  Otherwise, just\n\t\t * load into the X register the offset computed into\n\t\t * the register specified by \"index\".\n\t\t */\n\t\tif (s != NULL) {\n\t\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\t} else\n\t\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at the sum of the offset we've put in the\n\t\t * X register, the offset of the start of the network\n\t\t * layer header from the beginning of the link-layer\n\t\t * payload, and the constant part of the offset of the\n\t\t * start of the link-layer payload.\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\ttmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;\n\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\n\t\tbreak;\n\t}\n\tinst->regno = regno;\n\ts = new_stmt(cstate, BPF_ST);\n\ts->s.k = regno;\n\tsappend(inst->s, s);\n\n\treturn inst;\n}\n\nstruct arth *\ngen_load(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_load_internal(cstate, proto, inst, size);\n}\n\nstatic struct block *\ngen_relation_internal(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)\n{\n\tstruct slist *s0, *s1, *s2;\n\tstruct block *b, *tmp;\n\n\ts0 = xfer_to_x(cstate, a1);\n\ts1 = xfer_to_a(cstate, a0);\n\tif (code == BPF_JEQ) {\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_SUB|BPF_X);\n\t\tb = new_block(cstate, JMP(code));\n\t\tsappend(s1, s2);\n\t}\n\telse\n\t\tb = new_block(cstate, BPF_JMP|code|BPF_X);\n\tif (reversed)\n\t\tgen_not(b);\n\n\tsappend(s0, s1);\n\tsappend(a1->s, s0);\n\tsappend(a0->s, a1->s);\n\n\tb->stmts = a0->s;\n\n\tfree_reg(cstate, a0->regno);\n\tfree_reg(cstate, a1->regno);\n\n\t/* 'and' together protocol checks */\n\tif (a0->b) {\n\t\tif (a1->b) {\n\t\t\tgen_and(a0->b, tmp = a1->b);\n\t\t}\n\t\telse\n\t\t\ttmp = a0->b;\n\t} else\n\t\ttmp = a1->b;\n\n\tif (tmp)\n\t\tgen_and(tmp, b);\n\n\treturn b;\n}\n\nstruct block *\ngen_relation(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_relation_internal(cstate, code, a0, a1, reversed);\n}\n\nstruct arth *\ngen_loadlen(compiler_state_t *cstate)\n{\n\tint regno;\n\tstruct arth *a;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tregno = alloc_reg(cstate);\n\ta = (struct arth *)newchunk(cstate, sizeof(*a));\n\ts = new_stmt(cstate, BPF_LD|BPF_LEN);\n\ts->next = new_stmt(cstate, BPF_ST);\n\ts->next->s.k = regno;\n\ta->s = s;\n\ta->regno = regno;\n\n\treturn a;\n}\n\nstatic struct arth *\ngen_loadi_internal(compiler_state_t *cstate, bpf_u_int32 val)\n{\n\tstruct arth *a;\n\tstruct slist *s;\n\tint reg;\n\n\ta = (struct arth *)newchunk(cstate, sizeof(*a));\n\n\treg = alloc_reg(cstate);\n\n\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\ts->s.k = val;\n\ts->next = new_stmt(cstate, BPF_ST);\n\ts->next->s.k = reg;\n\ta->s = s;\n\ta->regno = reg;\n\n\treturn a;\n}\n\nstruct arth *\ngen_loadi(compiler_state_t *cstate, bpf_u_int32 val)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_loadi_internal(cstate, val);\n}\n\n/*\n * The a_arg dance is to avoid annoying whining by compilers that\n * a might be clobbered by longjmp - yeah, it might, but *WHO CARES*?\n * It's not *used* after setjmp returns.\n */\nstruct arth *\ngen_neg(compiler_state_t *cstate, struct arth *a_arg)\n{\n\tstruct arth *a = a_arg;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\ts = xfer_to_a(cstate, a);\n\tsappend(a->s, s);\n\ts = new_stmt(cstate, BPF_ALU|BPF_NEG);\n\ts->s.k = 0;\n\tsappend(a->s, s);\n\ts = new_stmt(cstate, BPF_ST);\n\ts->s.k = a->regno;\n\tsappend(a->s, s);\n\n\treturn a;\n}\n\n/*\n * The a0_arg dance is to avoid annoying whining by compilers that\n * a0 might be clobbered by longjmp - yeah, it might, but *WHO CARES*?\n * It's not *used* after setjmp returns.\n */\nstruct arth *\ngen_arth(compiler_state_t *cstate, int code, struct arth *a0_arg,\n    struct arth *a1)\n{\n\tstruct arth *a0 = a0_arg;\n\tstruct slist *s0, *s1, *s2;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Disallow division by, or modulus by, zero; we do this here\n\t * so that it gets done even if the optimizer is disabled.\n\t *\n\t * Also disallow shifts by a value greater than 31; we do this\n\t * here, for the same reason.\n\t */\n\tif (code == BPF_DIV) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)\n\t\t\tbpf_error(cstate, \"division by zero\");\n\t} else if (code == BPF_MOD) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)\n\t\t\tbpf_error(cstate, \"modulus by zero\");\n\t} else if (code == BPF_LSH || code == BPF_RSH) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k > 31)\n\t\t\tbpf_error(cstate, \"shift by more than 31 bits\");\n\t}\n\ts0 = xfer_to_x(cstate, a1);\n\ts1 = xfer_to_a(cstate, a0);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_X|code);\n\n\tsappend(s1, s2);\n\tsappend(s0, s1);\n\tsappend(a1->s, s0);\n\tsappend(a0->s, a1->s);\n\n\tfree_reg(cstate, a0->regno);\n\tfree_reg(cstate, a1->regno);\n\n\ts0 = new_stmt(cstate, BPF_ST);\n\ta0->regno = s0->s.k = alloc_reg(cstate);\n\tsappend(a0->s, s0);\n\n\treturn a0;\n}\n\n/*\n * Initialize the table of used registers and the current register.\n */\nstatic void\ninit_regs(compiler_state_t *cstate)\n{\n\tcstate->curreg = 0;\n\tmemset(cstate->regused, 0, sizeof cstate->regused);\n}\n\n/*\n * Return the next free register.\n */\nstatic int\nalloc_reg(compiler_state_t *cstate)\n{\n\tint n = BPF_MEMWORDS;\n\n\twhile (--n >= 0) {\n\t\tif (cstate->regused[cstate->curreg])\n\t\t\tcstate->curreg = (cstate->curreg + 1) % BPF_MEMWORDS;\n\t\telse {\n\t\t\tcstate->regused[cstate->curreg] = 1;\n\t\t\treturn cstate->curreg;\n\t\t}\n\t}\n\tbpf_error(cstate, \"too many registers needed to evaluate expression\");\n\t/*NOTREACHED*/\n}\n\n/*\n * Return a register to the table so it can\n * be used later.\n */\nstatic void\nfree_reg(compiler_state_t *cstate, int n)\n{\n\tcstate->regused[n] = 0;\n}\n\nstatic struct block *\ngen_len(compiler_state_t *cstate, int jmp, int n)\n{\n\tstruct slist *s;\n\tstruct block *b;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_LEN);\n\tb = new_block(cstate, JMP(jmp));\n\tb->stmts = s;\n\tb->s.k = n;\n\n\treturn b;\n}\n\nstruct block *\ngen_greater(compiler_state_t *cstate, int n)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_len(cstate, BPF_JGE, n);\n}\n\n/*\n * Actually, this is less than or equal.\n */\nstruct block *\ngen_less(compiler_state_t *cstate, int n)\n{\n\tstruct block *b;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tb = gen_len(cstate, BPF_JGT, n);\n\tgen_not(b);\n\n\treturn b;\n}\n\n/*\n * This is for \"byte {idx} {op} {val}\"; \"idx\" is treated as relative to\n * the beginning of the link-layer header.\n * XXX - that means you can't test values in the radiotap header, but\n * as that header is difficult if not impossible to parse generally\n * without a loop, that might not be a severe problem.  A new keyword\n * \"radio\" could be added for that, although what you'd really want\n * would be a way of testing particular radio header values, which\n * would generate code appropriate to the radio header in question.\n */\nstruct block *\ngen_byteop(compiler_state_t *cstate, int op, int idx, bpf_u_int32 val)\n{\n\tstruct block *b;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (op) {\n\tdefault:\n\t\tabort();\n\n\tcase '=':\n\t\treturn gen_cmp(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\n\tcase '<':\n\t\tb = gen_cmp_lt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\t\treturn b;\n\n\tcase '>':\n\t\tb = gen_cmp_gt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\t\treturn b;\n\n\tcase '|':\n\t\ts = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_K);\n\t\tbreak;\n\n\tcase '&':\n\t\ts = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\tbreak;\n\t}\n\ts->s.k = val;\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s;\n\tgen_not(b);\n\n\treturn b;\n}\n\nstatic const u_char abroadcast[] = { 0x0 };\n\nstruct block *\ngen_broadcast(compiler_state_t *cstate, int proto)\n{\n\tbpf_u_int32 hostmask;\n\tstruct block *b0, *b1, *b2;\n\tstatic const u_char ebroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_LINK:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_ARCNET:\n\t\tcase DLT_ARCNET_LINUX:\n\t\t\treturn gen_ahostop(cstate, abroadcast, Q_DST);\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\tb0 = gen_ehostop(cstate, ebroadcast, Q_DST);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_FDDI:\n\t\t\treturn gen_fhostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IEEE802:\n\t\t\treturn gen_thostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\treturn gen_wlanhostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IP_OVER_FC:\n\t\t\treturn gen_ipfchostop(cstate, ebroadcast, Q_DST);\n\t\tdefault:\n\t\t\tbpf_error(cstate, \"not a broadcast link\");\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase Q_IP:\n\t\t/*\n\t\t * We treat a netmask of PCAP_NETMASK_UNKNOWN (0xffffffff)\n\t\t * as an indication that we don't know the netmask, and fail\n\t\t * in that case.\n\t\t */\n\t\tif (cstate->netmask == PCAP_NETMASK_UNKNOWN)\n\t\t\tbpf_error(cstate, \"netmask not known, so 'ip broadcast' not supported\");\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\thostmask = ~cstate->netmask;\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W, 0, hostmask);\n\t\tb2 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W,\n\t\t\t      ~0 & hostmask, hostmask);\n\t\tgen_or(b1, b2);\n\t\tgen_and(b0, b2);\n\t\treturn b2;\n\t}\n\tbpf_error(cstate, \"only link-layer/IP broadcast filters supported\");\n\t/*NOTREACHED*/\n}\n\n/*\n * Generate code to test the low-order bit of a MAC address (that's\n * the bottom bit of the *first* byte).\n */\nstatic struct block *\ngen_mac_multicast(compiler_state_t *cstate, int offset)\n{\n\tregister struct block *b0;\n\tregister struct slist *s;\n\n\t/* link[offset] & 1 != 0 */\n\ts = gen_load_a(cstate, OR_LINKHDR, offset, BPF_B);\n\tb0 = new_block(cstate, JMP(BPF_JSET));\n\tb0->s.k = 1;\n\tb0->stmts = s;\n\treturn b0;\n}\n\nstruct block *\ngen_multicast(compiler_state_t *cstate, int proto)\n{\n\tregister struct block *b0, *b1, *b2;\n\tregister struct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_LINK:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_ARCNET:\n\t\tcase DLT_ARCNET_LINUX:\n\t\t\t/* all ARCnet multicasts use the same address */\n\t\t\treturn gen_ahostop(cstate, abroadcast, Q_DST);\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\t/* ether[0] & 1 != 0 */\n\t\t\tb0 = gen_mac_multicast(cstate, 0);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_FDDI:\n\t\t\t/*\n\t\t\t * XXX TEST THIS: MIGHT NOT PORT PROPERLY XXX\n\t\t\t *\n\t\t\t * XXX - was that referring to bit-order issues?\n\t\t\t */\n\t\t\t/* fddi[1] & 1 != 0 */\n\t\t\treturn gen_mac_multicast(cstate, 1);\n\t\tcase DLT_IEEE802:\n\t\t\t/* tr[2] & 1 != 0 */\n\t\t\treturn gen_mac_multicast(cstate, 2);\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\t/*\n\t\t\t * Oh, yuk.\n\t\t\t *\n\t\t\t *\tFor control frames, there is no DA.\n\t\t\t *\n\t\t\t *\tFor management frames, DA is at an\n\t\t\t *\toffset of 4 from the beginning of\n\t\t\t *\tthe packet.\n\t\t\t *\n\t\t\t *\tFor data frames, DA is at an offset\n\t\t\t *\tof 4 from the beginning of the packet\n\t\t\t *\tif To DS is clear and at an offset of\n\t\t\t *\t16 from the beginning of the packet\n\t\t\t *\tif To DS is set.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Generate the tests to be done for data frames.\n\t\t\t *\n\t\t\t * First, check for To DS set, i.e. \"link[1] & 0x01\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x01;\t/* To DS */\n\t\t\tb1->stmts = s;\n\n\t\t\t/*\n\t\t\t * If To DS is set, the DA is at 16.\n\t\t\t */\n\t\t\tb0 = gen_mac_multicast(cstate, 16);\n\t\t\tgen_and(b1, b0);\n\n\t\t\t/*\n\t\t\t * Now, check for To DS not set, i.e. check\n\t\t\t * \"!(link[1] & 0x01)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb2->s.k = 0x01;\t/* To DS */\n\t\t\tb2->stmts = s;\n\t\t\tgen_not(b2);\n\n\t\t\t/*\n\t\t\t * If To DS is not set, the DA is at 4.\n\t\t\t */\n\t\t\tb1 = gen_mac_multicast(cstate, 4);\n\t\t\tgen_and(b2, b1);\n\n\t\t\t/*\n\t\t\t * Now OR together the last two checks.  That gives\n\t\t\t * the complete set of checks for data frames.\n\t\t\t */\n\t\t\tgen_or(b1, b0);\n\n\t\t\t/*\n\t\t\t * Now check for a data frame.\n\t\t\t * I.e, check \"link[0] & 0x08\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x08;\n\t\t\tb1->stmts = s;\n\n\t\t\t/*\n\t\t\t * AND that with the checks done for data frames.\n\t\t\t */\n\t\t\tgen_and(b1, b0);\n\n\t\t\t/*\n\t\t\t * If the high-order bit of the type value is 0, this\n\t\t\t * is a management frame.\n\t\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb2->s.k = 0x08;\n\t\t\tb2->stmts = s;\n\t\t\tgen_not(b2);\n\n\t\t\t/*\n\t\t\t * For management frames, the DA is at 4.\n\t\t\t */\n\t\t\tb1 = gen_mac_multicast(cstate, 4);\n\t\t\tgen_and(b2, b1);\n\n\t\t\t/*\n\t\t\t * OR that with the checks done for data frames.\n\t\t\t * That gives the checks done for management and\n\t\t\t * data frames.\n\t\t\t */\n\t\t\tgen_or(b1, b0);\n\n\t\t\t/*\n\t\t\t * If the low-order bit of the type value is 1,\n\t\t\t * this is either a control frame or a frame\n\t\t\t * with a reserved type, and thus not a\n\t\t\t * frame with an SA.\n\t\t\t *\n\t\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x04;\n\t\t\tb1->stmts = s;\n\t\t\tgen_not(b1);\n\n\t\t\t/*\n\t\t\t * AND that with the checks for data and management\n\t\t\t * frames.\n\t\t\t */\n\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb0 = gen_mac_multicast(cstate, 2);\n\t\t\treturn b0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t/* Link not known to support multicasts */\n\t\tbreak;\n\n\tcase Q_IP:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\tb1 = gen_cmp_ge(cstate, OR_LINKPL, 16, BPF_B, 224);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 24, BPF_B, 255);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t}\n\tbpf_error(cstate, \"link-layer multicast filters supported only on ethernet/FDDI/token ring/ARCNET/802.11/ATM LANE/Fibre Channel\");\n\t/*NOTREACHED*/\n}\n\nstruct block *\ngen_ifindex(compiler_state_t *cstate, int ifindex)\n{\n\tregister struct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Only some data link types support ifindex qualifiers.\n\t */\n\tswitch (cstate->linktype) {\n\tcase DLT_LINUX_SLL2:\n\t\t/* match packets on this interface */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 4, BPF_W, ifindex);\n\t\tbreak;\n\tdefault:\n#if defined(__linux__)\n\t\t/*\n\t\t * This is Linux; we require PF_PACKET support.\n\t\t * If this is a *live* capture, we can look at\n\t\t * special meta-data in the filter expression;\n\t\t * if it's a savefile, we can't.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t/* We have a FILE *, so this is a savefile */\n\t\t\tbpf_error(cstate, \"ifindex not supported on %s when reading savefiles\",\n\t\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\t/* match ifindex */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_IFINDEX, BPF_W,\n\t\t             ifindex);\n#else /* defined(__linux__) */\n\t\tbpf_error(cstate, \"ifindex not supported on %s\",\n\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n#endif /* defined(__linux__) */\n\t}\n\treturn (b0);\n}\n\n/*\n * Filter on inbound (dir == 0) or outbound (dir == 1) traffic.\n * Outbound traffic is sent by this machine, while inbound traffic is\n * sent by a remote machine (and may include packets destined for a\n * unicast or multicast link-layer address we are not subscribing to).\n * These are the same definitions implemented by pcap_setdirection().\n * Capturing only unicast traffic destined for this host is probably\n * better accomplished using a higher-layer filter.\n */\nstruct block *\ngen_inbound(compiler_state_t *cstate, int dir)\n{\n\tregister struct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Only some data link types support inbound/outbound qualifiers.\n\t */\n\tswitch (cstate->linktype) {\n\tcase DLT_SLIP:\n\t\tb0 = gen_relation_internal(cstate, BPF_JEQ,\n\t\t\t  gen_load_internal(cstate, Q_LINK, gen_loadi_internal(cstate, 0), 1),\n\t\t\t  gen_loadi_internal(cstate, 0),\n\t\t\t  dir);\n\t\tbreak;\n\n\tcase DLT_IPNET:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_OUTBOUND);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_INBOUND);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_H, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 10, BPF_B, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_PFLOG:\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, dir), BPF_B,\n\t\t    ((dir == 0) ? PF_IN : PF_OUT));\n\t\tbreak;\n\n\tcase DLT_PPP_PPPD:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_OUT);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_IN);\n\t\t}\n\t\tbreak;\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* juniper flags (including direction) are stored\n\t\t * the byte after the 3-byte magic number */\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 0, 0x01);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 1, 0x01);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * If we have packet meta-data indicating a direction,\n\t\t * and that metadata can be checked by BPF code, check\n\t\t * it.  Otherwise, give up, as this link-layer type has\n\t\t * nothing in the packet data.\n\t\t *\n\t\t * Currently, the only platform where a BPF filter can\n\t\t * check that metadata is Linux with the in-kernel\n\t\t * BPF interpreter.  If other packet capture mechanisms\n\t\t * and BPF filters also supported this, it would be\n\t\t * nice.  It would be even better if they made that\n\t\t * metadata available so that we could provide it\n\t\t * with newer capture APIs, allowing it to be saved\n\t\t * in pcapng files.\n\t\t */\n#if defined(__linux__)\n\t\t/*\n\t\t * This is Linux; we require PF_PACKET support.\n\t\t * If this is a *live* capture, we can look at\n\t\t * special meta-data in the filter expression;\n\t\t * if it's a savefile, we can't.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t/* We have a FILE *, so this is a savefile */\n\t\t\tbpf_error(cstate, \"inbound/outbound not supported on %s when reading savefiles\",\n\t\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_PKTTYPE, BPF_H,\n\t\t             PACKET_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n#else /* defined(__linux__) */\n\t\tbpf_error(cstate, \"inbound/outbound not supported on %s\",\n\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n#endif /* defined(__linux__) */\n\t}\n\treturn (b0);\n}\n\n/* PF firewall log matched interface */\nstruct block *\ngen_pf_ifname(compiler_state_t *cstate, const char *ifname)\n{\n\tstruct block *b0;\n\tu_int len, off;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"ifname supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\tlen = sizeof(((struct pfloghdr *)0)->ifname);\n\toff = offsetof(struct pfloghdr, ifname);\n\tif (strlen(ifname) >= len) {\n\t\tbpf_error(cstate, \"ifname interface names can only be %d characters\",\n\t\t    len-1);\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_bcmp(cstate, OR_LINKHDR, off, (u_int)strlen(ifname),\n\t    (const u_char *)ifname);\n\treturn (b0);\n}\n\n/* PF firewall log ruleset name */\nstruct block *\ngen_pf_ruleset(compiler_state_t *cstate, char *ruleset)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"ruleset supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tif (strlen(ruleset) >= sizeof(((struct pfloghdr *)0)->ruleset)) {\n\t\tbpf_error(cstate, \"ruleset names can only be %ld characters\",\n\t\t    (long)(sizeof(((struct pfloghdr *)0)->ruleset) - 1));\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_bcmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, ruleset),\n\t    (u_int)strlen(ruleset), (const u_char *)ruleset);\n\treturn (b0);\n}\n\n/* PF firewall log rule number */\nstruct block *\ngen_pf_rnr(compiler_state_t *cstate, int rnr)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"rnr supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, rulenr), BPF_W,\n\t\t (bpf_u_int32)rnr);\n\treturn (b0);\n}\n\n/* PF firewall log sub-rule number */\nstruct block *\ngen_pf_srnr(compiler_state_t *cstate, int srnr)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"srnr supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, subrulenr), BPF_W,\n\t    (bpf_u_int32)srnr);\n\treturn (b0);\n}\n\n/* PF firewall log reason code */\nstruct block *\ngen_pf_reason(compiler_state_t *cstate, int reason)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"reason supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, reason), BPF_B,\n\t    (bpf_u_int32)reason);\n\treturn (b0);\n}\n\n/* PF firewall log action */\nstruct block *\ngen_pf_action(compiler_state_t *cstate, int action)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"action supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, action), BPF_B,\n\t    (bpf_u_int32)action);\n\treturn (b0);\n}\n\n/* IEEE 802.11 wireless header */\nstruct block *\ngen_p80211_type(compiler_state_t *cstate, bpf_u_int32 type, bpf_u_int32 mask)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, type, mask);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"802.11 link-layer types supported only on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\n\treturn (b0);\n}\n\nstruct block *\ngen_p80211_fcdir(compiler_state_t *cstate, bpf_u_int32 fcdir)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"frame direction supported only with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B, fcdir,\n\t    IEEE80211_FC1_DIR_MASK);\n\n\treturn (b0);\n}\n\nstruct block *\ngen_acode(compiler_state_t *cstate, const char *s, struct qual q)\n{\n\tstruct block *b;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_ARCNET:\n\tcase DLT_ARCNET_LINUX:\n\t\tif ((q.addr == Q_HOST || q.addr == Q_DEFAULT) &&\n\t\t    q.proto == Q_LINK) {\n\t\t\tcstate->e = pcap_ether_aton(s);\n\t\t\tif (cstate->e == NULL)\n\t\t\t\tbpf_error(cstate, \"malloc\");\n\t\t\tb = gen_ahostop(cstate, cstate->e, (int)q.dir);\n\t\t\tfree(cstate->e);\n\t\t\tcstate->e = NULL;\n\t\t\treturn (b);\n\t\t} else\n\t\t\tbpf_error(cstate, \"ARCnet address used in non-arc expression\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tbpf_error(cstate, \"aid supported only on ARCnet\");\n\t\t/*NOTREACHED*/\n\t}\n}\n\nstatic struct block *\ngen_ahostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\t/* src comes first, different from Ethernet */\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0, 1, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 1, 1, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ahostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ahostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ahostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ahostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}\n\nstatic struct block *\ngen_vlan_tpid_test(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/* check for VLAN, including 802.1ad and QinQ */\n\tb0 = gen_linktype(cstate, ETHERTYPE_8021Q);\n\tb1 = gen_linktype(cstate, ETHERTYPE_8021AD);\n\tgen_or(b0,b1);\n\tb0 = b1;\n\tb1 = gen_linktype(cstate, ETHERTYPE_8021QINQ);\n\tgen_or(b0,b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_vlan_vid_test(compiler_state_t *cstate, bpf_u_int32 vlan_num)\n{\n\tif (vlan_num > 0x0fff) {\n\t\tbpf_error(cstate, \"VLAN tag %u greater than maximum %u\",\n\t\t    vlan_num, 0x0fff);\n\t}\n\treturn gen_mcmp(cstate, OR_LINKPL, 0, BPF_H, vlan_num, 0x0fff);\n}\n\nstatic struct block *\ngen_vlan_no_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_vlan_tpid_test(cstate);\n\n\tif (has_vlan_tag) {\n\t\tb1 = gen_vlan_vid_test(cstate, vlan_num);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\t/*\n\t * Both payload and link header type follow the VLAN tags so that\n\t * both need to be updated.\n\t */\n\tcstate->off_linkpl.constant_part += 4;\n\tcstate->off_linktype.constant_part += 4;\n\n\treturn b0;\n}\n\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n/* add v to variable part of off */\nstatic void\ngen_vlan_vloffset_add(compiler_state_t *cstate, bpf_abs_offset *off,\n    bpf_u_int32 v, struct slist *s)\n{\n\tstruct slist *s2;\n\n\tif (!off->is_variable)\n\t\toff->is_variable = 1;\n\tif (off->reg == -1)\n\t\toff->reg = alloc_reg(cstate);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\ts2->s.k = v;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n}\n\n/*\n * patch block b_tpid (VLAN TPID test) to update variable parts of link payload\n * and link type offsets first\n */\nstatic void\ngen_vlan_patch_tpid_test(compiler_state_t *cstate, struct block *b_tpid)\n{\n\tstruct slist s;\n\n\t/* offset determined at run time, shift variable part */\n\ts.next = NULL;\n\tcstate->is_vlan_vloffset = 1;\n\tgen_vlan_vloffset_add(cstate, &cstate->off_linkpl, 4, &s);\n\tgen_vlan_vloffset_add(cstate, &cstate->off_linktype, 4, &s);\n\n\t/* we get a pointer to a chain of or-ed blocks, patch first of them */\n\tsappend(s.next, b_tpid->head->stmts);\n\tb_tpid->head->stmts = s.next;\n}\n\n/*\n * patch block b_vid (VLAN id test) to load VID value either from packet\n * metadata (using BPF extensions) if SKF_AD_VLAN_TAG_PRESENT is true\n */\nstatic void\ngen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)\n{\n\tstruct slist *s, *s2, *sjeq;\n\tunsigned cnt;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n\t/* true -> next instructions, false -> beginning of b_vid */\n\tsjeq = new_stmt(cstate, JMP(BPF_JEQ));\n\tsjeq->s.k = 1;\n\tsjeq->s.jf = b_vid->stmts;\n\tsappend(s, sjeq);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts2->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG;\n\tsappend(s, s2);\n\tsjeq->s.jt = s2;\n\n\t/* Jump to the test in b_vid. We need to jump one instruction before\n\t * the end of the b_vid block so that we only skip loading the TCI\n\t * from packet data and not the 'and' instruction extracting VID.\n\t */\n\tcnt = 0;\n\tfor (s2 = b_vid->stmts; s2; s2 = s2->next)\n\t\tcnt++;\n\ts2 = new_stmt(cstate, JMP(BPF_JA));\n\ts2->s.k = cnt - 1;\n\tsappend(s, s2);\n\n\t/* insert our statements at the beginning of b_vid */\n\tsappend(s, b_vid->stmts);\n\tb_vid->stmts = s;\n}\n\n/*\n * Generate check for \"vlan\" or \"vlan <id>\" on systems with support for BPF\n * extensions.  Even if kernel supports VLAN BPF extensions, (outermost) VLAN\n * tag can be either in metadata or in packet data; therefore if the\n * SKF_AD_VLAN_TAG_PRESENT test is negative, we need to check link\n * header for VLAN tag. As the decision is done at run time, we need\n * update variable part of the offsets\n */\nstatic struct block *\ngen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)\n{\n        struct block *b0, *b_tpid, *b_vid = NULL;\n        struct slist *s;\n\n        /* generate new filter code based on extracting packet\n         * metadata */\n        s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n        s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n        b0 = new_block(cstate, JMP(BPF_JEQ));\n        b0->stmts = s;\n        b0->s.k = 1;\n\n\t/*\n\t * This is tricky. We need to insert the statements updating variable\n\t * parts of offsets before the traditional TPID and VID tests so\n\t * that they are called whenever SKF_AD_VLAN_TAG_PRESENT fails but\n\t * we do not want this update to affect those checks. That's why we\n\t * generate both test blocks first and insert the statements updating\n\t * variable parts of both offsets after that. This wouldn't work if\n\t * there already were variable length link header when entering this\n\t * function but gen_vlan_bpf_extensions() isn't called in that case.\n\t */\n\tb_tpid = gen_vlan_tpid_test(cstate);\n\tif (has_vlan_tag)\n\t\tb_vid = gen_vlan_vid_test(cstate, vlan_num);\n\n\tgen_vlan_patch_tpid_test(cstate, b_tpid);\n\tgen_or(b0, b_tpid);\n\tb0 = b_tpid;\n\n\tif (has_vlan_tag) {\n\t\tgen_vlan_patch_vid_test(cstate, b_vid);\n\t\tgen_and(b0, b_vid);\n\t\tb0 = b_vid;\n\t}\n\n        return b0;\n}\n#endif\n\n/*\n * support IEEE 802.1Q VLAN trunk over ethernet\n */\nstruct block *\ngen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)\n{\n\tstruct\tblock\t*b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/* can't check for VLAN-encapsulated packets inside MPLS */\n\tif (cstate->label_stack_depth > 0)\n\t\tbpf_error(cstate, \"no VLAN match after MPLS\");\n\n\t/*\n\t * Check for a VLAN packet, and then change the offsets to point\n\t * to the type and data fields within the VLAN packet.  Just\n\t * increment the offsets, so that we can support a hierarchy, e.g.\n\t * \"vlan 300 && vlan 200\" to capture VLAN 200 encapsulated within\n\t * VLAN 100.\n\t *\n\t * XXX - this is a bit of a kludge.  If we were to split the\n\t * compiler into a parser that parses an expression and\n\t * generates an expression tree, and a code generator that\n\t * takes an expression tree (which could come from our\n\t * parser or from some other parser) and generates BPF code,\n\t * we could perhaps make the offsets parameters of routines\n\t * and, in the handler for an \"AND\" node, pass to subnodes\n\t * other than the VLAN node the adjusted offsets.\n\t *\n\t * This would mean that \"vlan\" would, instead of changing the\n\t * behavior of *all* tests after it, change only the behavior\n\t * of tests ANDed with it.  That would change the documented\n\t * semantics of \"vlan\", which might break some expressions.\n\t * However, it would mean that \"(vlan and ip) or ip\" would check\n\t * both for VLAN-encapsulated IP and IP-over-Ethernet, rather than\n\t * checking only for VLAN-encapsulated IP, so that could still\n\t * be considered worth doing; it wouldn't break expressions\n\t * that are of the form \"vlan and ...\" or \"vlan N and ...\",\n\t * which I suspect are the most common expressions involving\n\t * \"vlan\".  \"vlan or ...\" doesn't necessarily do what the user\n\t * would really want, now, as all the \"or ...\" tests would\n\t * be done assuming a VLAN, even though the \"or\" could be viewed\n\t * as meaning \"or, if this isn't a VLAN packet...\".\n\t */\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\t\t/*\n\t\t * Newer version of the Linux kernel pass around\n\t\t * packets in which the VLAN tag has been removed\n\t\t * from the packet data and put into metadata.\n\t\t *\n\t\t * This requires special treatment.\n\t\t */\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n\t\t/* Verify that this is the outer part of the packet and\n\t\t * not encapsulated somehow. */\n\t\tif (cstate->vlan_stack_depth == 0 && !cstate->off_linkhdr.is_variable &&\n\t\t    cstate->off_linkhdr.constant_part ==\n\t\t    cstate->off_outermostlinkhdr.constant_part) {\n\t\t\t/*\n\t\t\t * Do we need special VLAN handling?\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->bpf_codegen_flags & BPF_SPECIAL_VLAN_HANDLING)\n\t\t\t\tb0 = gen_vlan_bpf_extensions(cstate, vlan_num,\n\t\t\t\t    has_vlan_tag);\n\t\t\telse\n\t\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate,\n\t\t\t\t    vlan_num, has_vlan_tag);\n\t\t} else\n#endif\n\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,\n\t\t\t    has_vlan_tag);\n\t\tbreak;\n\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\t/*\n\t\t * These are either Ethernet packets with an additional\n\t\t * metadata header (the NetAnalyzer types), or 802.11\n\t\t * packets, possibly with an additional metadata header.\n\t\t *\n\t\t * For the first of those, the VLAN tag is in the normal\n\t\t * place, so the special-case handling above isn't\n\t\t * necessary.\n\t\t *\n\t\t * For the second of those, we don't do the special-case\n\t\t * handling for now.\n\t\t */\n\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num, has_vlan_tag);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"no VLAN support for %s\",\n\t\t      pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n\t}\n\n\tcstate->vlan_stack_depth++;\n\n\treturn (b0);\n}\n\n/*\n * support for MPLS\n *\n * The label_num_arg dance is to avoid annoying whining by compilers that\n * label_num might be clobbered by longjmp - yeah, it might, but *WHO CARES*?\n * It's not *used* after setjmp returns.\n */\nstatic struct block *\ngen_mpls_internal(compiler_state_t *cstate, bpf_u_int32 label_num,\n    int has_label_num)\n{\n\tstruct\tblock\t*b0, *b1;\n\n\tif (cstate->label_stack_depth > 0) {\n\t\t/* just match the bottom-of-stack bit clear */\n\t\tb0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);\n\t} else {\n\t\t/*\n\t\t * We're not in an MPLS stack yet, so check the link-layer\n\t\t * type against MPLS.\n\t\t */\n\t\tswitch (cstate->linktype) {\n\n\t\tcase DLT_C_HDLC: /* fall through */\n\t\tcase DLT_HDLC:\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb0 = gen_linktype(cstate, ETHERTYPE_MPLS);\n\t\t\tbreak;\n\n\t\tcase DLT_PPP:\n\t\t\tb0 = gen_linktype(cstate, PPP_MPLS_UCAST);\n\t\t\tbreak;\n\n\t\t\t/* FIXME add other DLT_s ...\n\t\t\t * for Frame-Relay/and ATM this may get messy due to SNAP headers\n\t\t\t * leave it for now */\n\n\t\tdefault:\n\t\t\tbpf_error(cstate, \"no MPLS support for %s\",\n\t\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\n\t/* If a specific MPLS label is requested, check it */\n\tif (has_label_num) {\n\t\tif (label_num > 0xFFFFF) {\n\t\t\tbpf_error(cstate, \"MPLS label %u greater than maximum %u\",\n\t\t\t    label_num, 0xFFFFF);\n\t\t}\n\t\tlabel_num = label_num << 12; /* label is shifted 12 bits on the wire */\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, label_num,\n\t\t    0xfffff000); /* only compare the first 20 bits */\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\t/*\n\t * Change the offsets to point to the type and data fields within\n\t * the MPLS packet.  Just increment the offsets, so that we\n\t * can support a hierarchy, e.g. \"mpls 100000 && mpls 1024\" to\n\t * capture packets with an outer label of 100000 and an inner\n\t * label of 1024.\n\t *\n\t * Increment the MPLS stack depth as well; this indicates that\n\t * we're checking MPLS-encapsulated headers, to make sure higher\n\t * level code generators don't try to match against IP-related\n\t * protocols such as Q_ARP, Q_RARP etc.\n\t *\n\t * XXX - this is a bit of a kludge.  See comments in gen_vlan().\n\t */\n\tcstate->off_nl_nosnap += 4;\n\tcstate->off_nl += 4;\n\tcstate->label_stack_depth++;\n\treturn (b0);\n}\n\nstruct block *\ngen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num, int has_label_num)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_mpls_internal(cstate, label_num, has_label_num);\n}\n\n/*\n * Support PPPOE discovery and session.\n */\nstruct block *\ngen_pppoed(compiler_state_t *cstate)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/* check for PPPoE discovery */\n\treturn gen_linktype(cstate, ETHERTYPE_PPPOED);\n}\n\nstruct block *\ngen_pppoes(compiler_state_t *cstate, bpf_u_int32 sess_num, int has_sess_num)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Test against the PPPoE session link-layer type.\n\t */\n\tb0 = gen_linktype(cstate, ETHERTYPE_PPPOES);\n\n\t/* If a specific session is requested, check PPPoE session id */\n\tif (has_sess_num) {\n\t\tif (sess_num > 0x0000ffff) {\n\t\t\tbpf_error(cstate, \"PPPoE session number %u greater than maximum %u\",\n\t\t\t    sess_num, 0x0000ffff);\n\t\t}\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, sess_num, 0x0000ffff);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\t/*\n\t * Change the offsets to point to the type and data fields within\n\t * the PPP packet, and note that this is PPPoE rather than\n\t * raw PPP.\n\t *\n\t * XXX - this is a bit of a kludge.  See the comments in\n\t * gen_vlan().\n\t *\n\t * The \"network-layer\" protocol is PPPoE, which has a 6-byte\n\t * PPPoE header, followed by a PPP packet.\n\t *\n\t * There is no HDLC encapsulation for the PPP packet (it's\n\t * encapsulated in PPPoES instead), so the link-layer type\n\t * starts at the first byte of the PPP packet.  For PPPoE,\n\t * that offset is relative to the beginning of the total\n\t * link-layer payload, including any 802.2 LLC header, so\n\t * it's 6 bytes past cstate->off_nl.\n\t */\n\tPUSH_LINKHDR(cstate, DLT_PPP, cstate->off_linkpl.is_variable,\n\t    cstate->off_linkpl.constant_part + cstate->off_nl + 6, /* 6 bytes past the PPPoE header */\n\t    cstate->off_linkpl.reg);\n\n\tcstate->off_linktype = cstate->off_linkhdr;\n\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 2;\n\n\tcstate->off_nl = 0;\n\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\n\treturn b0;\n}\n\n/* Check that this is Geneve and the VNI is correct if\n * specified. Parameterized to handle both IPv4 and IPv6. */\nstatic struct block *\ngen_geneve_check(compiler_state_t *cstate,\n    struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),\n    enum e_offrel offrel, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_portfn(cstate, GENEVE_PORT, IPPROTO_UDP, Q_DST);\n\n\t/* Check that we are operating on version 0. Otherwise, we\n\t * can't decode the rest of the fields. The version is 2 bits\n\t * in the first byte of the Geneve header. */\n\tb1 = gen_mcmp(cstate, offrel, 8, BPF_B, 0, 0xc0);\n\tgen_and(b0, b1);\n\tb0 = b1;\n\n\tif (has_vni) {\n\t\tif (vni > 0xffffff) {\n\t\t\tbpf_error(cstate, \"Geneve VNI %u greater than maximum %u\",\n\t\t\t    vni, 0xffffff);\n\t\t}\n\t\tvni <<= 8; /* VNI is in the upper 3 bytes */\n\t\tb1 = gen_mcmp(cstate, offrel, 12, BPF_W, vni, 0xffffff00);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\treturn b0;\n}\n\n/* The IPv4 and IPv6 Geneve checks need to do two things:\n * - Verify that this actually is Geneve with the right VNI.\n * - Place the IP header length (plus variable link prefix if\n *   needed) into register A to be used later to compute\n *   the inner packet offsets. */\nstatic struct block *\ngen_geneve4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_geneve_check(cstate, gen_port, OR_TRAN_IPV4, vni, has_vni);\n\n\t/* Load the IP header length into A. */\n\ts = gen_loadx_iphdrlen(cstate);\n\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s1);\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_geneve6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_geneve_check(cstate, gen_port6, OR_TRAN_IPV6, vni, has_vni);\n\n\t/* Load the IP header length. We need to account for a\n\t * variable length link prefix if there is one. */\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s) {\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts1->s.k = 40;\n\t\tsappend(s, s1);\n\n\t\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\t\ts1->s.k = 0;\n\t\tsappend(s, s1);\n\t} else {\n\t\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts->s.k = 40;\n\t}\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\n/* We need to store three values based on the Geneve header::\n * - The offset of the linktype.\n * - The offset of the end of the Geneve header.\n * - The offset of the end of the encapsulated MAC header. */\nstatic struct slist *\ngen_geneve_offsets(compiler_state_t *cstate)\n{\n\tstruct slist *s, *s1, *s_proto;\n\n\t/* First we need to calculate the offset of the Geneve header\n\t * itself. This is composed of the IP header previously calculated\n\t * (include any variable link prefix) and stored in A plus the\n\t * fixed sized headers (fixed link prefix, MAC length, and UDP\n\t * header). */\n\ts = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 8;\n\n\t/* Stash this in X since we'll need it later. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\t/* The EtherType in Geneve is 2 bytes in. Calculate this and\n\t * store it. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\tcstate->off_linktype.reg = alloc_reg(cstate);\n\tcstate->off_linktype.is_variable = 1;\n\tcstate->off_linktype.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linktype.reg;\n\tsappend(s, s1);\n\n\t/* Load the Geneve option length and mask and shift to get the\n\t * number of bytes. It is stored in the first byte of the Geneve\n\t * header. */\n\ts1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts1->s.k = 0;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\ts1->s.k = 0x3f;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\ts1->s.k = 4;\n\tsappend(s, s1);\n\n\t/* Add in the rest of the Geneve base header. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 8;\n\tsappend(s, s1);\n\n\t/* Add the Geneve header length to its offset and store. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\ts1->s.k = 0;\n\tsappend(s, s1);\n\n\t/* Set the encapsulated type as Ethernet. Even though we may\n\t * not actually have Ethernet inside there are two reasons this\n\t * is useful:\n\t * - The linktype field is always in EtherType format regardless\n\t *   of whether it is in Geneve or an inner Ethernet frame.\n\t * - The only link layer that we have specific support for is\n\t *   Ethernet. We will confirm that the packet actually is\n\t *   Ethernet at runtime before executing these checks. */\n\tPUSH_LINKHDR(cstate, DLT_EN10MB, 1, 0, alloc_reg(cstate));\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linkhdr.reg;\n\tsappend(s, s1);\n\n\t/* Calculate whether we have an Ethernet header or just raw IP/\n\t * MPLS/etc. If we have Ethernet, advance the end of the MAC offset\n\t * and linktype by 14 bytes so that the network header can be found\n\t * seamlessly. Otherwise, keep what we've calculated already. */\n\n\t/* We have a bare jmp so we can't use the optimizer. */\n\tcstate->no_optimize = 1;\n\n\t/* Load the EtherType in the Geneve header, 2 bytes in. */\n\ts1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_H);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\t/* Load X with the end of the Geneve header. */\n\ts1 = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts1->s.k = cstate->off_linkhdr.reg;\n\tsappend(s, s1);\n\n\t/* Check if the EtherType is Transparent Ethernet Bridging. At the\n\t * end of this check, we should have the total length in X. In\n\t * the non-Ethernet case, it's already there. */\n\ts_proto = new_stmt(cstate, JMP(BPF_JEQ));\n\ts_proto->s.k = ETHERTYPE_TEB;\n\tsappend(s, s_proto);\n\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s1);\n\ts_proto->s.jt = s1;\n\n\t/* Since this is Ethernet, use the EtherType of the payload\n\t * directly as the linktype. Overwrite what we already have. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 12;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linktype.reg;\n\tsappend(s, s1);\n\n\t/* Advance two bytes further to get the end of the Ethernet\n\t * header. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\t/* Move the result to X. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\t/* Store the final result of our linkpl calculation. */\n\tcstate->off_linkpl.reg = alloc_reg(cstate);\n\tcstate->off_linkpl.is_variable = 1;\n\tcstate->off_linkpl.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_STX);\n\ts1->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s1);\n\ts_proto->s.jf = s1;\n\n\tcstate->off_nl = 0;\n\n\treturn s;\n}\n\n/* Check to see if this is a Geneve packet. */\nstruct block *\ngen_geneve(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tb0 = gen_geneve4(cstate, vni, has_vni);\n\tb1 = gen_geneve6(cstate, vni, has_vni);\n\n\tgen_or(b0, b1);\n\tb0 = b1;\n\n\t/* Later filters should act on the payload of the Geneve frame,\n\t * update all of the header pointers. Attach this code so that\n\t * it gets executed in the event that the Geneve filter matches. */\n\ts = gen_geneve_offsets(cstate);\n\n\tb1 = gen_true(cstate);\n\tsappend(s, b1->stmts);\n\tb1->stmts = s;\n\n\tgen_and(b0, b1);\n\n\tcstate->is_encap = 1;\n\n\treturn b1;\n}\n\n/* Check that this is VXLAN and the VNI is correct if\n * specified. Parameterized to handle both IPv4 and IPv6. */\nstatic struct block *\ngen_vxlan_check(compiler_state_t *cstate,\n    struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),\n    enum e_offrel offrel, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_portfn(cstate, VXLAN_PORT, IPPROTO_UDP, Q_DST);\n\n\t/* Check that the VXLAN header has the flag bits set\n\t * correctly. */\n\tb1 = gen_cmp(cstate, offrel, 8, BPF_B, 0x08);\n\tgen_and(b0, b1);\n\tb0 = b1;\n\n\tif (has_vni) {\n\t\tif (vni > 0xffffff) {\n\t\t\tbpf_error(cstate, \"VXLAN VNI %u greater than maximum %u\",\n\t\t\t    vni, 0xffffff);\n\t\t}\n\t\tvni <<= 8; /* VNI is in the upper 3 bytes */\n\t\tb1 = gen_mcmp(cstate, offrel, 12, BPF_W, vni, 0xffffff00);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\treturn b0;\n}\n\n/* The IPv4 and IPv6 VXLAN checks need to do two things:\n * - Verify that this actually is VXLAN with the right VNI.\n * - Place the IP header length (plus variable link prefix if\n *   needed) into register A to be used later to compute\n *   the inner packet offsets. */\nstatic struct block *\ngen_vxlan4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_vxlan_check(cstate, gen_port, OR_TRAN_IPV4, vni, has_vni);\n\n\t/* Load the IP header length into A. */\n\ts = gen_loadx_iphdrlen(cstate);\n\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s1);\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\nstatic struct block *\ngen_vxlan6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_vxlan_check(cstate, gen_port6, OR_TRAN_IPV6, vni, has_vni);\n\n\t/* Load the IP header length. We need to account for a\n\t * variable length link prefix if there is one. */\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s) {\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts1->s.k = 40;\n\t\tsappend(s, s1);\n\n\t\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\t\ts1->s.k = 0;\n\t\tsappend(s, s1);\n\t} else {\n\t\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts->s.k = 40;\n\t}\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}\n\n/* We need to store three values based on the VXLAN header:\n * - The offset of the linktype.\n * - The offset of the end of the VXLAN header.\n * - The offset of the end of the encapsulated MAC header. */\nstatic struct slist *\ngen_vxlan_offsets(compiler_state_t *cstate)\n{\n\tstruct slist *s, *s1;\n\n\t/* Calculate the offset of the VXLAN header itself. This\n\t * includes the IP header computed previously (including any\n\t * variable link prefix) and stored in A plus the fixed size\n\t * headers (fixed link prefix, MAC length, UDP header). */\n\ts = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 8;\n\n\t/* Add the VXLAN header length to its offset and store */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 8;\n\tsappend(s, s1);\n\n\t/* Push the link header. VXLAN packets always contain Ethernet\n\t * frames. */\n\tPUSH_LINKHDR(cstate, DLT_EN10MB, 1, 0, alloc_reg(cstate));\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linkhdr.reg;\n\tsappend(s, s1);\n\n\t/* As the payload is an Ethernet packet, we can use the\n\t * EtherType of the payload directly as the linktype. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 12;\n\tsappend(s, s1);\n\n\tcstate->off_linktype.reg = alloc_reg(cstate);\n\tcstate->off_linktype.is_variable = 1;\n\tcstate->off_linktype.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linktype.reg;\n\tsappend(s, s1);\n\n\t/* Two bytes further is the end of the Ethernet header and the\n\t * start of the payload. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\t/* Move the result to X. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\t/* Store the final result of our linkpl calculation. */\n\tcstate->off_linkpl.reg = alloc_reg(cstate);\n\tcstate->off_linkpl.is_variable = 1;\n\tcstate->off_linkpl.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_STX);\n\ts1->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s1);\n\n\tcstate->off_nl = 0;\n\n\treturn s;\n}\n\n/* Check to see if this is a VXLAN packet. */\nstruct block *\ngen_vxlan(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tb0 = gen_vxlan4(cstate, vni, has_vni);\n\tb1 = gen_vxlan6(cstate, vni, has_vni);\n\n\tgen_or(b0, b1);\n\tb0 = b1;\n\n\t/* Later filters should act on the payload of the VXLAN frame,\n\t * update all of the header pointers. Attach this code so that\n\t * it gets executed in the event that the VXLAN filter matches. */\n\ts = gen_vxlan_offsets(cstate);\n\n\tb1 = gen_true(cstate);\n\tsappend(s, b1->stmts);\n\tb1->stmts = s;\n\n\tgen_and(b0, b1);\n\n\tcstate->is_encap = 1;\n\n\treturn b1;\n}\n\n/* Check that the encapsulated frame has a link layer header\n * for Ethernet filters. */\nstatic struct block *\ngen_encap_ll_check(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\tstruct slist *s, *s1;\n\n\t/* The easiest way to see if there is a link layer present\n\t * is to check if the link layer header and payload are not\n\t * the same. */\n\n\t/* Geneve always generates pure variable offsets so we can\n\t * compare only the registers. */\n\ts = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts->s.k = cstate->off_linkhdr.reg;\n\n\ts1 = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts1->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s1);\n\n\tb0 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb0->stmts = s;\n\tb0->s.k = 0;\n\tgen_not(b0);\n\n\treturn b0;\n}\n\nstatic struct block *\ngen_atmfield_code_internal(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\tstruct block *b0;\n\n\tswitch (atmfield) {\n\n\tcase A_VPI:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'vpi' supported only on raw ATM\");\n\t\tif (cstate->off_vpi == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tif (jvalue > UINT8_MAX)\n\t\t\tbpf_error(cstate, \"VPI value %u > %u\", jvalue, UINT8_MAX);\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vpi, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_VCI:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'vci' supported only on raw ATM\");\n\t\tif (cstate->off_vci == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tif (jvalue > UINT16_MAX)\n\t\t\tbpf_error(cstate, \"VCI value %u > %u\", jvalue, UINT16_MAX);\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vci, BPF_H,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_PROTOTYPE:\n\t\tif (cstate->off_proto == OFFSET_NOT_SET)\n\t\t\tabort();\t/* XXX - this isn't on FreeBSD */\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,\n\t\t    0x0fU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_MSGTYPE:\n\t\tif (cstate->off_payload == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_payload + MSG_TYPE_POS, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_CALLREFTYPE:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'callref' supported only on raw ATM\");\n\t\tif (cstate->off_proto == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}\n\nstatic struct block *\ngen_atmtype_metac(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 1, BPF_JEQ, 0);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstatic struct block *\ngen_atmtype_sc(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 5, BPF_JEQ, 0);\n\tgen_and(b0, b1);\n\treturn b1;\n}\n\nstatic struct block *\ngen_atmtype_llc(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);\n\tcstate->linktype = cstate->prevlinktype;\n\treturn b0;\n}\n\nstruct block *\ngen_atmfield_code(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_atmfield_code_internal(cstate, atmfield, jvalue, jtype,\n\t    reverse);\n}\n\nstruct block *\ngen_atmtype_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase A_METAC:\n\t\t/* Get all packets in Meta signalling Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'metac' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_metac(cstate);\n\t\tbreak;\n\n\tcase A_BCC:\n\t\t/* Get all packets in Broadcast Circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'bcc' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 2, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4SC:\n\t\t/* Get all cells in Segment OAM F4 circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam4sc' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4EC:\n\t\t/* Get all cells in End-to-End OAM F4 Circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam4ec' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_SC:\n\t\t/*  Get all packets in connection Signalling Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'sc' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_sc(cstate);\n\t\tbreak;\n\n\tcase A_ILMIC:\n\t\t/* Get all packets in ILMI Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'ilmic' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 16, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_LANE:\n\t\t/* Get all LANE packets */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'lane' supported only on raw ATM\");\n\t\tb1 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LANE, BPF_JEQ, 0);\n\n\t\t/*\n\t\t * Arrange that all subsequent tests assume LANE\n\t\t * rather than LLC-encapsulated packets, and set\n\t\t * the offsets appropriately for LANE-encapsulated\n\t\t * Ethernet.\n\t\t *\n\t\t * We assume LANE means Ethernet, not Token Ring.\n\t\t */\n\t\tPUSH_LINKHDR(cstate, DLT_EN10MB, 0,\n\t\t    cstate->off_payload + 2,\t/* Ethernet header */\n\t\t    -1);\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* Ethernet */\n\t\tcstate->off_nl = 0;\t\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase A_LLC:\n\t\t/* Get all LLC-encapsulated packets */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'llc' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_llc(cstate);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}\n\n/*\n * Filtering for MTP2 messages based on li value\n * FISU, length is null\n * LSSU, length is 1 or 2\n * MSU, length is 3 or more\n * For MTP2_HSL, sequences are on 2 bytes, and length on 9 bits\n */\nstruct block *\ngen_mtp2type_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase M_FISU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'fisu' supported only on MTP2\");\n\t\t/* gen_ncmp(cstate, offrel, offset, size, mask, jtype, reverse, value) */\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JEQ, 0, 0U);\n\t\tbreak;\n\n\tcase M_LSSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'lssu' supported only on MTP2\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 1, 2U);\n\t\tb1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 0, 0U);\n\t\tgen_and(b1, b0);\n\t\tbreak;\n\n\tcase M_MSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'msu' supported only on MTP2\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 0, 2U);\n\t\tbreak;\n\n\tcase MH_FISU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hfisu' supported only on MTP2_HSL\");\n\t\t/* gen_ncmp(cstate, offrel, offset, size, mask, jtype, reverse, value) */\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JEQ, 0, 0U);\n\t\tbreak;\n\n\tcase MH_LSSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hlssu' supported only on MTP2_HSL\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 1, 0x0100U);\n\t\tb1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 0, 0U);\n\t\tgen_and(b1, b0);\n\t\tbreak;\n\n\tcase MH_MSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hmsu' supported only on MTP2_HSL\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 0, 0x0100U);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}\n\nstatic struct block *\ngen_mtp3field_code_internal(compiler_state_t *cstate, int mtp3field,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\tstruct block *b0;\n\tbpf_u_int32 val1 , val2 , val3;\n\tu_int newoff_sio;\n\tu_int newoff_opc;\n\tu_int newoff_dpc;\n\tu_int newoff_sls;\n\n\tnewoff_sio = cstate->off_sio;\n\tnewoff_opc = cstate->off_opc;\n\tnewoff_dpc = cstate->off_dpc;\n\tnewoff_sls = cstate->off_sls;\n\tswitch (mtp3field) {\n\n\tcase MH_SIO:\n\t\tnewoff_sio += 3; /* offset for MTP2_HSL */\n\t\t/* FALLTHROUGH */\n\n\tcase M_SIO:\n\t\tif (cstate->off_sio == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sio' supported only on SS7\");\n\t\t/* sio coded on 1 byte so max value 255 */\n\t\tif(jvalue > 255)\n\t\t\tbpf_error(cstate, \"sio value %u too big; max value = 255\",\n\t\t\t    jvalue);\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffffU,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_OPC:\n\t\tnewoff_opc += 3;\n\n\t\t/* FALLTHROUGH */\n\tcase M_OPC:\n\t\tif (cstate->off_opc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'opc' supported only on SS7\");\n\t\t/* opc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t\tbpf_error(cstate, \"opc value %u too big; max value = 16383\",\n\t\t\t    jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the form used to write opc in an ss7 message*/\n\t\tval1 = jvalue & 0x00003c00;\n\t\tval1 = val1 >>10;\n\t\tval2 = jvalue & 0x000003fc;\n\t\tval2 = val2 <<6;\n\t\tval3 = jvalue & 0x00000003;\n\t\tval3 = val3 <<22;\n\t\tjvalue = val1 + val2 + val3;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_opc, BPF_W, 0x00c0ff0fU,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_DPC:\n\t\tnewoff_dpc += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_DPC:\n\t\tif (cstate->off_dpc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'dpc' supported only on SS7\");\n\t\t/* dpc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t\tbpf_error(cstate, \"dpc value %u too big; max value = 16383\",\n\t\t\t    jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the forme used to write dpc in an ss7 message*/\n\t\tval1 = jvalue & 0x000000ff;\n\t\tval1 = val1 << 24;\n\t\tval2 = jvalue & 0x00003f00;\n\t\tval2 = val2 << 8;\n\t\tjvalue = val1 + val2;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_dpc, BPF_W, 0xff3f0000U,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_SLS:\n\t\tnewoff_sls += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_SLS:\n\t\tif (cstate->off_sls == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sls' supported only on SS7\");\n\t\t/* sls coded on 4 bits so max value 15 */\n\t\tif (jvalue > 15)\n\t\t\t bpf_error(cstate, \"sls value %u too big; max value = 15\",\n\t\t\t     jvalue);\n\t\t/* the following instruction is made to convert jvalue\n\t\t * to the forme used to write sls in an ss7 message*/\n\t\tjvalue = jvalue << 4;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sls, BPF_B, 0xf0U,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}\n\nstruct block *\ngen_mtp3field_code(compiler_state_t *cstate, int mtp3field,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_mtp3field_code_internal(cstate, mtp3field, jvalue, jtype,\n\t    reverse);\n}\n\nstatic struct block *\ngen_msg_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b1;\n\n\t/*\n\t * Q.2931 signalling protocol messages for handling virtual circuits\n\t * establishment and teardown\n\t */\n\tswitch (type) {\n\n\tcase A_SETUP:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, SETUP, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CALLPROCEED:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CALL_PROCEED, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CONNECT:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CONNECTACK:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT_ACK, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_RELEASE:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_RELEASE_DONE:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE_DONE, BPF_JEQ, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}\n\nstruct block *\ngen_atmmulti_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase A_OAM:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam' supported only on raw ATM\");\n\t\t/* OAM F4 type */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oamf4' supported only on raw ATM\");\n\t\t/* OAM F4 type */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_CONNECTMSG:\n\t\t/*\n\t\t * Get Q.2931 signalling messages for switched\n\t\t * virtual connection\n\t\t */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'connectmsg' supported only on raw ATM\");\n\t\tb0 = gen_msg_abbrev(cstate, A_SETUP);\n\t\tb1 = gen_msg_abbrev(cstate, A_CALLPROCEED);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECTACK);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmtype_sc(cstate);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_METACONNECT:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'metaconnect' supported only on raw ATM\");\n\t\tb0 = gen_msg_abbrev(cstate, A_SETUP);\n\t\tb1 = gen_msg_abbrev(cstate, A_CALLPROCEED);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmtype_metac(cstate);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}\n"
        },
        {
          "name": "gencode.h",
          "type": "blob",
          "size": 12.755859375,
          "content": "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifndef gencode_h\n#define gencode_h\n\n#include \"pcap/funcattrs.h\"\n/*\n * pcap/bpf.h (a public header) needs u_char, u_short and u_int, which can be\n * made available via either pcap-types.h (a private header) or pcap/pcap.h\n * (a public header), none of which pcap/bpf.h includes.  Include the private\n * header to keep things simple, this way this private header should compile\n * even if included early from another file.\n */\n#include \"pcap-types.h\"\n#include \"pcap/bpf.h\" /* bpf_u_int32 and BPF_MEMWORDS */\n\n/*\n * ATM support:\n *\n * Copyright (c) 1997 Yen Yen Lim and North Dakota State University\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *      This product includes software developed by Yen Yen Lim and\n *      North Dakota State University\n * 4. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Address qualifiers. */\n\n#define Q_HOST\t\t1\n#define Q_NET\t\t2\n#define Q_PORT\t\t3\n#define Q_GATEWAY\t4\n#define Q_PROTO\t\t5\n#define Q_PROTOCHAIN\t6\n#define Q_PORTRANGE\t7\n\n/* Protocol qualifiers. */\n\n#define Q_LINK\t\t1\n#define Q_IP\t\t2\n#define Q_ARP\t\t3\n#define Q_RARP\t\t4\n#define Q_SCTP\t\t5\n#define Q_TCP\t\t6\n#define Q_UDP\t\t7\n#define Q_ICMP\t\t8\n#define Q_IGMP\t\t9\n#define Q_IGRP\t\t10\n\n\n#define\tQ_ATALK\t\t11\n#define\tQ_DECNET\t12\n#define\tQ_LAT\t\t13\n#define Q_SCA\t\t14\n#define\tQ_MOPRC\t\t15\n#define\tQ_MOPDL\t\t16\n\n\n#define Q_IPV6\t\t17\n#define Q_ICMPV6\t18\n#define Q_AH\t\t19\n#define Q_ESP\t\t20\n\n#define Q_PIM\t\t21\n#define Q_VRRP\t\t22\n\n#define Q_AARP\t\t23\n\n#define Q_ISO\t\t24\n#define Q_ESIS\t\t25\n#define Q_ISIS\t\t26\n#define Q_CLNP\t\t27\n\n#define Q_STP\t\t28\n\n#define Q_IPX\t\t29\n\n#define Q_NETBEUI\t30\n\n/* IS-IS Levels */\n#define Q_ISIS_L1       31\n#define Q_ISIS_L2       32\n/* PDU types */\n#define Q_ISIS_IIH      33\n#define Q_ISIS_SNP      34\n#define Q_ISIS_CSNP     35\n#define Q_ISIS_PSNP     36\n#define Q_ISIS_LSP      37\n\n#define Q_RADIO\t\t38\n\n#define Q_CARP\t\t39\n\n/* Directional qualifiers. */\n\n#define Q_SRC\t\t1\n#define Q_DST\t\t2\n#define Q_OR\t\t3\n#define Q_AND\t\t4\n#define Q_ADDR1\t\t5\n#define Q_ADDR2\t\t6\n#define Q_ADDR3\t\t7\n#define Q_ADDR4\t\t8\n#define Q_RA\t\t9\n#define Q_TA\t\t10\n\n#define Q_DEFAULT\t0\n#define Q_UNDEF\t\t255\n\n/* ATM types */\n#define A_METAC\t\t22\t/* Meta signalling Circuit */\n#define A_BCC\t\t23\t/* Broadcast Circuit */\n#define A_OAMF4SC\t24\t/* Segment OAM F4 Circuit */\n#define A_OAMF4EC\t25\t/* End-to-End OAM F4 Circuit */\n#define A_SC\t\t26\t/* Signalling Circuit*/\n#define A_ILMIC\t\t27\t/* ILMI Circuit */\n#define A_OAM\t\t28\t/* OAM cells : F4 only */\n#define A_OAMF4\t\t29\t/* OAM F4 cells: Segment + End-to-end */\n#define A_LANE\t\t30\t/* LANE traffic */\n#define A_LLC\t\t31\t/* LLC-encapsulated traffic */\n\n/* Based on Q.2931 signalling protocol */\n#define A_SETUP\t\t41\t/* Setup message */\n#define A_CALLPROCEED\t42\t/* Call proceeding message */\n#define A_CONNECT\t43\t/* Connect message */\n#define A_CONNECTACK\t44\t/* Connect Ack message */\n#define A_RELEASE\t45\t/* Release message */\n#define A_RELEASE_DONE\t46\t/* Release message */\n\n/* ATM field types */\n#define A_VPI\t\t51\n#define A_VCI\t\t52\n#define A_PROTOTYPE\t53\n#define A_MSGTYPE\t54\n#define A_CALLREFTYPE\t55\n\n#define A_CONNECTMSG\t70\t/* returns Q.2931 signalling messages for\n\t\t\t\t   establishing and destroying switched\n\t\t\t\t   virtual connection */\n#define A_METACONNECT\t71\t/* returns Q.2931 signalling messages for\n\t\t\t\t   establishing and destroying predefined\n\t\t\t\t   virtual circuits, such as broadcast\n\t\t\t\t   circuit, oamf4 segment circuit, oamf4\n\t\t\t\t   end-to-end circuits, ILMI circuits or\n\t\t\t\t   connection signalling circuit. */\n\n/* MTP2 types */\n#define M_FISU\t\t22\t/* FISU */\n#define M_LSSU\t\t23\t/* LSSU */\n#define M_MSU\t\t24\t/* MSU */\n\n/* MTP2 HSL types */\n#define MH_FISU\t\t25\t/* FISU for HSL */\n#define MH_LSSU\t\t26\t/* LSSU */\n#define MH_MSU\t\t27\t/* MSU */\n\n/* MTP3 field types */\n#define M_SIO\t\t1\n#define M_OPC\t\t2\n#define M_DPC\t\t3\n#define M_SLS\t\t4\n\n/* MTP3 field types in case of MTP2 HSL */\n#define MH_SIO\t\t5\n#define MH_OPC\t\t6\n#define MH_DPC\t\t7\n#define MH_SLS\t\t8\n\n\nstruct slist;\n\n/*\n * A single statement, corresponding to an instruction in a block.\n */\nstruct stmt {\n\tint code;\t\t/* opcode */\n\tstruct slist *jt;\t/* only for relative jump in block */\n\tstruct slist *jf;\t/* only for relative jump in block */\n\tbpf_u_int32 k;\t\t/* k field */\n};\n\nstruct slist {\n\tstruct stmt s;\n\tstruct slist *next;\n};\n\n/*\n * A bit vector to represent definition sets.  We assume TOT_REGISTERS\n * is smaller than 8*sizeof(atomset).\n */\ntypedef bpf_u_int32 atomset;\n#define ATOMMASK(n) (1 << (n))\n#define ATOMELEM(d, n) (d & ATOMMASK(n))\n\n/*\n * An unbounded set.\n */\ntypedef bpf_u_int32 *uset;\n\n/*\n * Total number of atomic entities, including accumulator (A) and index (X).\n * We treat all these guys similarly during flow analysis.\n */\n#define N_ATOMS (BPF_MEMWORDS+2)\n\n/*\n * Control flow graph of a program.\n * This corresponds to an edge in the CFG.\n * It's a directed graph, so an edge has a predecessor and a successor.\n */\nstruct edge {\n\tu_int id;\n\tint code;\t\t/* opcode for branch corresponding to this edge */\n\tuset edom;\n\tstruct block *succ;\t/* successor vertex */\n\tstruct block *pred;\t/* predecessor vertex */\n\tstruct edge *next;\t/* link list of incoming edges for a node */\n};\n\n/*\n * A block is a vertex in the CFG.\n * It has a list of statements, with the final statement being a\n * branch to successor blocks.\n */\nstruct block {\n\tu_int id;\n\tstruct slist *stmts;\t/* side effect stmts */\n\tstruct stmt s;\t\t/* branch stmt */\n\tint mark;\n\tu_int longjt;\t\t/* jt branch requires long jump */\n\tu_int longjf;\t\t/* jf branch requires long jump */\n\tint level;\n\tint offset;\n\tint sense;\n\tstruct edge et;\t\t/* edge corresponding to the jt branch */\n\tstruct edge ef;\t\t/* edge corresponding to the jf branch */\n\tstruct block *head;\n\tstruct block *link;\t/* link field used by optimizer */\n\tuset dom;\n\tuset closure;\n\tstruct edge *in_edges;\t/* first edge in the set (linked list) of edges with this as a successor */\n\tatomset def, kill;\n\tatomset in_use;\n\tatomset out_use;\n\tint oval;\t\t/* value ID for value tested in branch stmt */\n\tbpf_u_int32 val[N_ATOMS];\n};\n\n/*\n * A value of 0 for val[i] means the value is unknown.\n */\n#define VAL_UNKNOWN\t0\n\nstruct arth {\n\tstruct block *b;\t/* protocol checks */\n\tstruct slist *s;\t/* stmt list */\n\tint regno;\t\t/* virtual register number of result */\n};\n\nstruct qual {\n\tunsigned char addr;\n\tunsigned char proto;\n\tunsigned char dir;\n\tunsigned char pad;\n};\n\nstruct _compiler_state;\n\ntypedef struct _compiler_state compiler_state_t;\n\nstruct arth *gen_loadi(compiler_state_t *, bpf_u_int32);\nstruct arth *gen_load(compiler_state_t *, int, struct arth *, bpf_u_int32);\nstruct arth *gen_loadlen(compiler_state_t *);\nstruct arth *gen_neg(compiler_state_t *, struct arth *);\nstruct arth *gen_arth(compiler_state_t *, int, struct arth *, struct arth *);\n\nvoid gen_and(struct block *, struct block *);\nvoid gen_or(struct block *, struct block *);\nvoid gen_not(struct block *);\n\nstruct block *gen_scode(compiler_state_t *, const char *, struct qual);\nstruct block *gen_ecode(compiler_state_t *, const char *, struct qual);\nstruct block *gen_acode(compiler_state_t *, const char *, struct qual);\nstruct block *gen_mcode(compiler_state_t *, const char *, const char *,\n    bpf_u_int32, struct qual);\n#ifdef INET6\nstruct block *gen_mcode6(compiler_state_t *, const char *, bpf_u_int32,\n    struct qual);\n#endif\nstruct block *gen_ncode(compiler_state_t *, const char *, bpf_u_int32,\n    struct qual);\nstruct block *gen_proto_abbrev(compiler_state_t *, int);\nstruct block *gen_relation(compiler_state_t *, int, struct arth *,\n    struct arth *, int);\nstruct block *gen_less(compiler_state_t *, int);\nstruct block *gen_greater(compiler_state_t *, int);\nstruct block *gen_byteop(compiler_state_t *, int, int, bpf_u_int32);\nstruct block *gen_broadcast(compiler_state_t *, int);\nstruct block *gen_multicast(compiler_state_t *, int);\nstruct block *gen_ifindex(compiler_state_t *, int);\nstruct block *gen_inbound(compiler_state_t *, int);\n\nstruct block *gen_llc(compiler_state_t *);\nstruct block *gen_llc_i(compiler_state_t *);\nstruct block *gen_llc_s(compiler_state_t *);\nstruct block *gen_llc_u(compiler_state_t *);\nstruct block *gen_llc_s_subtype(compiler_state_t *, bpf_u_int32);\nstruct block *gen_llc_u_subtype(compiler_state_t *, bpf_u_int32);\n\nstruct block *gen_vlan(compiler_state_t *, bpf_u_int32, int);\nstruct block *gen_mpls(compiler_state_t *, bpf_u_int32, int);\n\nstruct block *gen_pppoed(compiler_state_t *);\nstruct block *gen_pppoes(compiler_state_t *, bpf_u_int32, int);\n\nstruct block *gen_geneve(compiler_state_t *, bpf_u_int32, int);\nstruct block *gen_vxlan(compiler_state_t *, bpf_u_int32, int);\n\nstruct block *gen_atmfield_code(compiler_state_t *, int, bpf_u_int32,\n    int, int);\nstruct block *gen_atmtype_abbrev(compiler_state_t *, int);\nstruct block *gen_atmmulti_abbrev(compiler_state_t *, int);\n\nstruct block *gen_mtp2type_abbrev(compiler_state_t *, int);\nstruct block *gen_mtp3field_code(compiler_state_t *, int, bpf_u_int32,\n    int, int);\n\nstruct block *gen_pf_ifname(compiler_state_t *, const char *);\nstruct block *gen_pf_rnr(compiler_state_t *, int);\nstruct block *gen_pf_srnr(compiler_state_t *, int);\nstruct block *gen_pf_ruleset(compiler_state_t *, char *);\nstruct block *gen_pf_reason(compiler_state_t *, int);\nstruct block *gen_pf_action(compiler_state_t *, int);\n\nstruct block *gen_p80211_type(compiler_state_t *, bpf_u_int32, bpf_u_int32);\nstruct block *gen_p80211_fcdir(compiler_state_t *, bpf_u_int32);\n\n/*\n * Representation of a program as a tree of blocks, plus current mark.\n * A block is marked if only if its mark equals the current mark.\n * Rather than traverse the code array, marking each item, 'cur_mark'\n * is incremented.  This automatically makes each element unmarked.\n */\n#define isMarked(icp, p) ((p)->mark == (icp)->cur_mark)\n#define unMarkAll(icp) (icp)->cur_mark += 1\n#define Mark(icp, p) ((p)->mark = (icp)->cur_mark)\n\nstruct icode {\n\tstruct block *root;\n\tint cur_mark;\n};\n\nint bpf_optimize(struct icode *, char *);\nvoid bpf_set_error(compiler_state_t *, const char *, ...)\n    PCAP_PRINTFLIKE(2, 3);\n\nint finish_parse(compiler_state_t *, struct block *);\nchar *sdup(compiler_state_t *, const char *);\n\nstruct bpf_insn *icode_to_fcode(struct icode *, struct block *, u_int *,\n    char *);\nvoid sappend(struct slist *, struct slist *);\n\n/*\n * Older versions of Bison don't put this declaration in\n * grammar.h.\n */\nint pcap_parse(void *, compiler_state_t *);\n\n/* XXX */\n#define JT(b)  ((b)->et.succ)\n#define JF(b)  ((b)->ef.succ)\n\n#endif /* gencode_h */\n"
        },
        {
          "name": "grammar.y.in",
          "type": "blob",
          "size": 30.099609375,
          "content": "/*\n * We want a reentrant parser.\n */\n@REENTRANT_PARSER@\n\n/*\n * We also want a reentrant scanner, so we have to pass the\n * handle for the reentrant scanner to the parser, and the\n * parser has to pass it to the lexical analyzer.\n *\n * We use void * rather than yyscan_t because, at least with some\n * versions of Flex and Bison, if you use yyscan_t in %parse-param and\n * %lex-param, you have to include scanner.h before grammar.h to get\n * yyscan_t declared, and you have to include grammar.h before scanner.h\n * to get YYSTYPE declared.  Using void * breaks the cycle; the Flex\n * documentation says yyscan_t is just a void *.\n */\n%parse-param   {void *yyscanner}\n%lex-param   {void *yyscanner}\n\n/*\n * According to bison documentation, shift/reduce conflicts are not an issue\n * in most parsers as long as the number does not evolve over time:\n * https://www.gnu.org/software/bison/manual/html_node/Expect-Decl.html\n * So, following the advice use %expect to check the amount of shift/reduce\n * warnings.\n *\n * This doesn't appear to work in Berkeley YACC - 1.9 20170709; it still\n * warns of 38 shift/reduce conflicts.\n *\n * The Berkeley YACC documentation:\n *\n *    https://invisible-island.net/byacc/manpage/yacc.html\n *\n * claims that \"Bison's support for \"%expect\" is broken in more than one\n * release.\", but doesn't give details.  Hopefully, that only means that\n * you get warnings even if you have the expected number of shift/reduce\n * conflicts, not that anything else fails.\n */\n%expect 38\n\n/*\n * And we need to pass the compiler state to the scanner.\n */\n%parse-param { compiler_state_t *cstate }\n\n%{\n/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n */\n\n#include <config.h>\n\n/*\n * grammar.h requires gencode.h and sometimes breaks in a polluted namespace\n * (see ftmacros.h), so include it early.\n */\n#include \"gencode.h\"\n#include \"grammar.h\"\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include \"diag-control.h\"\n\n#include \"pcap-int.h\"\n\n#include \"scanner.h\"\n\n#include \"llc.h\"\n#include \"ieee80211.h\"\n#include \"pflog.h\"\n#include <pcap/namedb.h>\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n/*\n * Work around some bugs in Berkeley YACC prior to the 2017-07-09\n * release.\n *\n * The 2005-05-05 release was the first one to define YYPATCH, so\n * we treat any release that either 1) doesn't define YYPATCH or\n * 2) defines it to a value < 20170709 as being buggy.\n */\n#if defined(YYBYACC) && (!defined(YYPATCH) || YYPATCH < 20170709)\n/*\n * Both Berkeley YACC and Bison define yydebug (under whatever name\n * it has) as a global, but Bison does so only if YYDEBUG is defined.\n * Berkeley YACC, prior to the 2017-07-09 release, defines it even if\n * YYDEBUG isn't defined; declare it here to suppress a warning.  The\n * 2017-07-09 release fixes that.\n */\n#if !defined(YYDEBUG)\nextern int yydebug;\n#endif\n\n/*\n * In Berkeley YACC, prior to the 2017-07-09 release, yynerrs (under\n * whatever name it has) is global, even if it's building a reentrant\n * parser.  In Bison, and in the Berkeley YACC 2017-07-09 release and\n * later, it's local in reentrant parsers.\n *\n * Declare it to squelch a warning.\n */\nextern int yynerrs;\n#endif\n\n#define QSET(q, p, d, a) (q).proto = (unsigned char)(p),\\\n\t\t\t (q).dir = (unsigned char)(d),\\\n\t\t\t (q).addr = (unsigned char)(a)\n\nstruct tok {\n\tint v;\t\t\t/* value */\n\tconst char *s;\t\t/* string */\n};\n\nstatic const struct tok ieee80211_types[] = {\n\t{ IEEE80211_FC0_TYPE_DATA, \"data\" },\n\t{ IEEE80211_FC0_TYPE_MGT, \"mgt\" },\n\t{ IEEE80211_FC0_TYPE_MGT, \"management\" },\n\t{ IEEE80211_FC0_TYPE_CTL, \"ctl\" },\n\t{ IEEE80211_FC0_TYPE_CTL, \"control\" },\n\t{ 0, NULL }\n};\nstatic const struct tok ieee80211_mgt_subtypes[] = {\n\t{ IEEE80211_FC0_SUBTYPE_ASSOC_REQ, \"assocreq\" },\n\t{ IEEE80211_FC0_SUBTYPE_ASSOC_REQ, \"assoc-req\" },\n\t{ IEEE80211_FC0_SUBTYPE_ASSOC_RESP, \"assocresp\" },\n\t{ IEEE80211_FC0_SUBTYPE_ASSOC_RESP, \"assoc-resp\" },\n\t{ IEEE80211_FC0_SUBTYPE_REASSOC_REQ, \"reassocreq\" },\n\t{ IEEE80211_FC0_SUBTYPE_REASSOC_REQ, \"reassoc-req\" },\n\t{ IEEE80211_FC0_SUBTYPE_REASSOC_RESP, \"reassocresp\" },\n\t{ IEEE80211_FC0_SUBTYPE_REASSOC_RESP, \"reassoc-resp\" },\n\t{ IEEE80211_FC0_SUBTYPE_PROBE_REQ, \"probereq\" },\n\t{ IEEE80211_FC0_SUBTYPE_PROBE_REQ, \"probe-req\" },\n\t{ IEEE80211_FC0_SUBTYPE_PROBE_RESP, \"proberesp\" },\n\t{ IEEE80211_FC0_SUBTYPE_PROBE_RESP, \"probe-resp\" },\n\t{ IEEE80211_FC0_SUBTYPE_BEACON, \"beacon\" },\n\t{ IEEE80211_FC0_SUBTYPE_ATIM, \"atim\" },\n\t{ IEEE80211_FC0_SUBTYPE_DISASSOC, \"disassoc\" },\n\t{ IEEE80211_FC0_SUBTYPE_DISASSOC, \"disassociation\" },\n\t{ IEEE80211_FC0_SUBTYPE_AUTH, \"auth\" },\n\t{ IEEE80211_FC0_SUBTYPE_AUTH, \"authentication\" },\n\t{ IEEE80211_FC0_SUBTYPE_DEAUTH, \"deauth\" },\n\t{ IEEE80211_FC0_SUBTYPE_DEAUTH, \"deauthentication\" },\n\t{ 0, NULL }\n};\nstatic const struct tok ieee80211_ctl_subtypes[] = {\n\t{ IEEE80211_FC0_SUBTYPE_BAR, \"bar\" },\n\t{ IEEE80211_FC0_SUBTYPE_BA, \"ba\" },\n\t{ IEEE80211_FC0_SUBTYPE_PS_POLL, \"ps-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_RTS, \"rts\" },\n\t{ IEEE80211_FC0_SUBTYPE_CTS, \"cts\" },\n\t{ IEEE80211_FC0_SUBTYPE_ACK, \"ack\" },\n\t{ IEEE80211_FC0_SUBTYPE_CF_END, \"cf-end\" },\n\t{ IEEE80211_FC0_SUBTYPE_CF_END_ACK, \"cf-end-ack\" },\n\t{ 0, NULL }\n};\nstatic const struct tok ieee80211_data_subtypes[] = {\n\t{ IEEE80211_FC0_SUBTYPE_DATA, \"data\" },\n\t{ IEEE80211_FC0_SUBTYPE_CF_ACK, \"data-cf-ack\" },\n\t{ IEEE80211_FC0_SUBTYPE_CF_POLL, \"data-cf-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_CF_ACPL, \"data-cf-ack-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_NODATA, \"null\" },\n\t{ IEEE80211_FC0_SUBTYPE_NODATA_CF_ACK, \"cf-ack\" },\n\t{ IEEE80211_FC0_SUBTYPE_NODATA_CF_POLL, \"cf-poll\"  },\n\t{ IEEE80211_FC0_SUBTYPE_NODATA_CF_ACPL, \"cf-ack-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_DATA, \"qos-data\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_ACK, \"qos-data-cf-ack\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_POLL, \"qos-data-cf-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_ACPL, \"qos-data-cf-ack-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA, \"qos\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA_CF_POLL, \"qos-cf-poll\" },\n\t{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA_CF_ACPL, \"qos-cf-ack-poll\" },\n\t{ 0, NULL }\n};\nstatic const struct tok llc_s_subtypes[] = {\n\t{ LLC_RR, \"rr\" },\n\t{ LLC_RNR, \"rnr\" },\n\t{ LLC_REJ, \"rej\" },\n\t{ 0, NULL }\n};\nstatic const struct tok llc_u_subtypes[] = {\n\t{ LLC_UI, \"ui\" },\n\t{ LLC_UA, \"ua\" },\n\t{ LLC_DISC, \"disc\" },\n\t{ LLC_DM, \"dm\" },\n\t{ LLC_SABME, \"sabme\" },\n\t{ LLC_TEST, \"test\" },\n\t{ LLC_XID, \"xid\" },\n\t{ LLC_FRMR, \"frmr\" },\n\t{ 0, NULL }\n};\nstruct type2tok {\n\tint type;\n\tconst struct tok *tok;\n};\nstatic const struct type2tok ieee80211_type_subtypes[] = {\n\t{ IEEE80211_FC0_TYPE_MGT, ieee80211_mgt_subtypes },\n\t{ IEEE80211_FC0_TYPE_CTL, ieee80211_ctl_subtypes },\n\t{ IEEE80211_FC0_TYPE_DATA, ieee80211_data_subtypes },\n\t{ 0, NULL }\n};\n\nstatic int\nstr2tok(const char *str, const struct tok *toks)\n{\n\tint i;\n\n\tfor (i = 0; toks[i].s != NULL; i++) {\n\t\tif (pcapint_strcasecmp(toks[i].s, str) == 0) {\n\t\t\t/*\n\t\t\t * Just in case somebody is using this to\n\t\t\t * generate values of -1/0xFFFFFFFF.\n\t\t\t * That won't work, as it's indistinguishable\n\t\t\t * from an error.\n\t\t\t */\n\t\t\tif (toks[i].v == -1)\n\t\t\t\tabort();\n\t\t\treturn (toks[i].v);\n\t\t}\n\t}\n\treturn (-1);\n}\n\nstatic const struct qual qerr = { Q_UNDEF, Q_UNDEF, Q_UNDEF, Q_UNDEF };\n\nstatic void\nyyerror(void *yyscanner _U_, compiler_state_t *cstate, const char *msg)\n{\n\tbpf_set_error(cstate, \"can't parse filter expression: %s\", msg);\n}\n\nstatic const struct tok pflog_reasons[] = {\n\t{ PFRES_MATCH,\t\t\"match\" },\n\t{ PFRES_BADOFF,\t\t\"bad-offset\" },\n\t{ PFRES_FRAG,\t\t\"fragment\" },\n\t{ PFRES_SHORT,\t\t\"short\" },\n\t{ PFRES_NORM,\t\t\"normalize\" },\n\t{ PFRES_MEMORY,\t\t\"memory\" },\n\t{ PFRES_TS,\t\t\"bad-timestamp\" },\n\t{ PFRES_CONGEST,\t\"congestion\" },\n\t{ PFRES_IPOPTIONS,\t\"ip-option\" },\n\t{ PFRES_PROTCKSUM,\t\"proto-cksum\" },\n\t{ PFRES_BADSTATE,\t\"state-mismatch\" },\n\t{ PFRES_STATEINS,\t\"state-insert\" },\n\t{ PFRES_MAXSTATES,\t\"state-limit\" },\n\t{ PFRES_SRCLIMIT,\t\"src-limit\" },\n\t{ PFRES_SYNPROXY,\t\"synproxy\" },\n#if defined(__FreeBSD__)\n\t{ PFRES_MAPFAILED,\t\"map-failed\" },\n#elif defined(__NetBSD__)\n\t{ PFRES_STATELOCKED,\t\"state-locked\" },\n#elif defined(__OpenBSD__)\n\t{ PFRES_TRANSLATE,\t\"translate\" },\n\t{ PFRES_NOROUTE,\t\"no-route\" },\n#elif defined(__APPLE__)\n\t{ PFRES_DUMMYNET,\t\"dummynet\" },\n#endif\n\t{ 0, NULL }\n};\n\nstatic int\npfreason_to_num(compiler_state_t *cstate, const char *reason)\n{\n\tint i;\n\n\ti = str2tok(reason, pflog_reasons);\n\tif (i == -1)\n\t\tbpf_set_error(cstate, \"unknown PF reason \\\"%s\\\"\", reason);\n\treturn (i);\n}\n\nstatic const struct tok pflog_actions[] = {\n\t{ PF_PASS,\t\t\"pass\" },\n\t{ PF_PASS,\t\t\"accept\" },\t/* alias for \"pass\" */\n\t{ PF_DROP,\t\t\"drop\" },\n\t{ PF_DROP,\t\t\"block\" },\t/* alias for \"drop\" */\n\t{ PF_SCRUB,\t\t\"scrub\" },\n\t{ PF_NOSCRUB,\t\t\"noscrub\" },\n\t{ PF_NAT,\t\t\"nat\" },\n\t{ PF_NONAT,\t\t\"nonat\" },\n\t{ PF_BINAT,\t\t\"binat\" },\n\t{ PF_NOBINAT,\t\t\"nobinat\" },\n\t{ PF_RDR,\t\t\"rdr\" },\n\t{ PF_NORDR,\t\t\"nordr\" },\n\t{ PF_SYNPROXY_DROP,\t\"synproxy-drop\" },\n#if defined(__FreeBSD__)\n\t{ PF_DEFER,\t\t\"defer\" },\n#elif defined(__OpenBSD__)\n\t{ PF_DEFER,\t\t\"defer\" },\n\t{ PF_MATCH,\t\t\"match\" },\n\t{ PF_DIVERT,\t\t\"divert\" },\n\t{ PF_RT,\t\t\"rt\" },\n\t{ PF_AFRT,\t\t\"afrt\" },\n#elif defined(__APPLE__)\n\t{ PF_DUMMYNET,\t\t\"dummynet\" },\n\t{ PF_NODUMMYNET,\t\"nodummynet\" },\n\t{ PF_NAT64,\t\t\"nat64\" },\n\t{ PF_NONAT64,\t\t\"nonat64\" },\n#endif\n\t{ 0, NULL },\n};\n\nstatic int\npfaction_to_num(compiler_state_t *cstate, const char *action)\n{\n\tint i;\n\n\ti = str2tok(action, pflog_actions);\n\tif (i == -1)\n\t\tbpf_set_error(cstate, \"unknown PF action \\\"%s\\\"\", action);\n\treturn (i);\n}\n\n/*\n * For calls that might return an \"an error occurred\" value.\n */\n#define CHECK_INT_VAL(val)\tif (val == -1) YYABORT\n#define CHECK_PTR_VAL(val)\tif (val == NULL) YYABORT\n\nDIAG_OFF_BISON_BYACC\n%}\n\n%union {\n\tint i;\n\tbpf_u_int32 h;\n\tchar *s;\n\tstruct stmt *stmt;\n\tstruct arth *a;\n\tstruct {\n\t\tstruct qual q;\n\t\tint atmfieldtype;\n\t\tint mtp3fieldtype;\n\t\tstruct block *b;\n\t} blk;\n\tstruct block *rblk;\n}\n\n%type\t<blk>\texpr id nid pid term rterm qid\n%type\t<blk>\thead\n%type\t<i>\tpqual dqual aqual ndaqual\n%type\t<a>\tarth narth\n%type\t<i>\tbyteop pname relop irelop\n%type\t<h>\tpnum\n%type\t<blk>\tand or paren not null prog\n%type\t<rblk>\tother pfvar p80211 pllc\n%type\t<i>\tatmtype atmmultitype\n%type\t<blk>\tatmfield\n%type\t<blk>\tatmfieldvalue atmvalue atmlistvalue\n%type\t<i>\tmtp2type\n%type\t<blk>\tmtp3field\n%type\t<blk>\tmtp3fieldvalue mtp3value mtp3listvalue\n\n\n%token  DST SRC HOST GATEWAY\n%token  NET NETMASK PORT PORTRANGE LESS GREATER PROTO PROTOCHAIN CBYTE\n%token  ARP RARP IP SCTP TCP UDP ICMP IGMP IGRP PIM VRRP CARP\n%token  ATALK AARP DECNET LAT SCA MOPRC MOPDL\n%token  TK_BROADCAST TK_MULTICAST\n%token  NUM INBOUND OUTBOUND\n%token  IFINDEX\n%token  PF_IFNAME PF_RSET PF_RNR PF_SRNR PF_REASON PF_ACTION\n%token\tTYPE SUBTYPE DIR ADDR1 ADDR2 ADDR3 ADDR4 RA TA\n%token  LINK\n%token\tGEQ LEQ NEQ\n%token\tID EID HID HID6 AID\n%token\tLSH RSH\n%token  LEN\n%token  IPV6 ICMPV6 AH ESP\n%token\tVLAN MPLS\n%token\tPPPOED PPPOES GENEVE VXLAN\n%token  ISO ESIS CLNP ISIS L1 L2 IIH LSP SNP CSNP PSNP\n%token  STP\n%token  IPX\n%token  NETBEUI\n%token\tLANE LLC METAC BCC SC ILMIC OAMF4EC OAMF4SC\n%token\tOAM OAMF4 CONNECTMSG METACONNECT\n%token\tVPI VCI\n%token\tRADIO\n%token\tFISU LSSU MSU HFISU HLSSU HMSU\n%token\tSIO OPC DPC SLS HSIO HOPC HDPC HSLS\n%token\tLEX_ERROR\n\n%type\t<s> ID EID AID\n%type\t<s> HID HID6\n%type\t<h> NUM\n%type\t<i> action reason type subtype type_subtype dir\n\n%left OR AND\n%nonassoc  '!'\n%left '|'\n%left '&'\n%left LSH RSH\n%left '+' '-'\n%left '*' '/'\n%nonassoc UMINUS\n%%\nprog:\t  null expr\n{\n\t/*\n\t * I'm not sure we have a reason to use yynerrs, but it's\n\t * declared, and incremented, whether we need it or not,\n\t * which means that Clang 15 will give a \"set but not\n\t * used\" warning.  This should suppress the warning for\n\t * yynerrs without suppressing it for other variables.\n\t */\n\t(void) yynerrs;\n\tCHECK_INT_VAL(finish_parse(cstate, $2.b));\n}\n\t| null\n\t;\nnull:\t  /* null */\t\t{ $$.q = qerr; }\n\t;\nexpr:\t  term\n\t| expr and term\t\t{ gen_and($1.b, $3.b); $$ = $3; }\n\t| expr and id\t\t{ gen_and($1.b, $3.b); $$ = $3; }\n\t| expr or term\t\t{ gen_or($1.b, $3.b); $$ = $3; }\n\t| expr or id\t\t{ gen_or($1.b, $3.b); $$ = $3; }\n\t;\nand:\t  AND\t\t\t{ $$ = $<blk>0; }\n\t;\nor:\t  OR\t\t\t{ $$ = $<blk>0; }\n\t;\nid:\t  nid\n\t| pnum\t\t\t{ CHECK_PTR_VAL(($$.b = gen_ncode(cstate, NULL, $1,\n\t\t\t\t\t\t   $$.q = $<blk>0.q))); }\n\t| paren pid ')'\t\t{ $$ = $2; }\n\t;\nnid:\t  ID\t\t\t{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_scode(cstate, $1, $$.q = $<blk>0.q))); }\n\t| HID '/' NUM\t\t{\n\t\t\t\t  CHECK_PTR_VAL($1);\n\t\t\t\t  /* Check whether HID/NUM is being used when appropriate */\n\t\t\t\t  $$.q = $<blk>0.q;\n\t\t\t\t  if ($$.q.addr == Q_PORT) {\n\t\t\t\t\tbpf_set_error(cstate, \"'port' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PORTRANGE) {\n\t\t\t\t\tbpf_set_error(cstate, \"'portrange' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTO) {\n\t\t\t\t\tbpf_set_error(cstate, \"'proto' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTOCHAIN) {\n\t\t\t\t\tbpf_set_error(cstate, \"'protochain' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, NULL, $3, $$.q)));\n\t\t\t\t}\n\t| HID NETMASK HID\t{\n\t\t\t\t  CHECK_PTR_VAL($1);\n\t\t\t\t  /* Check whether HID mask HID is being used when appropriate */\n\t\t\t\t  $$.q = $<blk>0.q;\n\t\t\t\t  if ($$.q.addr == Q_PORT) {\n\t\t\t\t\tbpf_set_error(cstate, \"'port' modifier applied to IP address and netmask\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PORTRANGE) {\n\t\t\t\t\tbpf_set_error(cstate, \"'portrange' modifier applied to IP address and netmask\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTO) {\n\t\t\t\t\tbpf_set_error(cstate, \"'proto' modifier applied to IP address and netmask\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTOCHAIN) {\n\t\t\t\t\tbpf_set_error(cstate, \"'protochain' modifier applied to IP address and netmask\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, $3, 0, $$.q)));\n\t\t\t\t}\n\t| HID\t\t\t{\n\t\t\t\t  CHECK_PTR_VAL($1);\n\t\t\t\t  /* Check whether HID is being used when appropriate */\n\t\t\t\t  $$.q = $<blk>0.q;\n\t\t\t\t  if ($$.q.addr == Q_PORT) {\n\t\t\t\t\tbpf_set_error(cstate, \"'port' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PORTRANGE) {\n\t\t\t\t\tbpf_set_error(cstate, \"'portrange' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTO) {\n\t\t\t\t\tbpf_set_error(cstate, \"'proto' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTOCHAIN) {\n\t\t\t\t\tbpf_set_error(cstate, \"'protochain' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  CHECK_PTR_VAL(($$.b = gen_ncode(cstate, $1, 0, $$.q)));\n\t\t\t\t}\n\t| HID6 '/' NUM\t\t{\n\t\t\t\t  CHECK_PTR_VAL($1);\n#ifdef INET6\n\t\t\t\t  /* Check whether HID6/NUM is being used when appropriate */\n\t\t\t\t  $$.q = $<blk>0.q;\n\t\t\t\t  if ($$.q.addr == Q_PORT) {\n\t\t\t\t\tbpf_set_error(cstate, \"'port' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PORTRANGE) {\n\t\t\t\t\tbpf_set_error(cstate, \"'portrange' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTO) {\n\t\t\t\t\tbpf_set_error(cstate, \"'proto' modifier applied to IP address and prefix length \");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTOCHAIN) {\n\t\t\t\t\tbpf_set_error(cstate, \"'protochain' modifier applied to IP address and prefix length\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, $3, $$.q)));\n#else\n\t\t\t\t  bpf_set_error(cstate, \"IPv6 addresses not supported \"\n\t\t\t\t\t\"in this configuration\");\n\t\t\t\t  YYABORT;\n#endif /*INET6*/\n\t\t\t\t}\n\t| HID6\t\t\t{\n\t\t\t\t  CHECK_PTR_VAL($1);\n#ifdef INET6\n\t\t\t\t  /* Check whether HID6 is being used when appropriate */\n\t\t\t\t  $$.q = $<blk>0.q;\n\t\t\t\t  if ($$.q.addr == Q_PORT) {\n\t\t\t\t\tbpf_set_error(cstate, \"'port' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PORTRANGE) {\n\t\t\t\t\tbpf_set_error(cstate, \"'portrange' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTO) {\n\t\t\t\t\tbpf_set_error(cstate, \"'proto' modifier applied to 'ip6addr/prefixlen\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  } else if ($$.q.addr == Q_PROTOCHAIN) {\n\t\t\t\t\tbpf_set_error(cstate, \"'protochain' modifier applied to IP address\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, 128, $$.q)));\n#else\n\t\t\t\t  bpf_set_error(cstate, \"IPv6 addresses not supported \"\n\t\t\t\t\t\"in this configuration\");\n\t\t\t\t  YYABORT;\n#endif /*INET6*/\n\t\t\t\t}\n\t| EID\t\t\t{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_ecode(cstate, $1, $$.q = $<blk>0.q))); }\n\t| AID\t\t\t{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_acode(cstate, $1, $$.q = $<blk>0.q))); }\n\t| not id\t\t{ gen_not($2.b); $$ = $2; }\n\t;\nnot:\t  '!'\t\t\t{ $$ = $<blk>0; }\n\t;\nparen:\t  '('\t\t\t{ $$ = $<blk>0; }\n\t;\npid:\t  nid\n\t| qid and id\t\t{ gen_and($1.b, $3.b); $$ = $3; }\n\t| qid or id\t\t{ gen_or($1.b, $3.b); $$ = $3; }\n\t;\nqid:\t  pnum\t\t\t{ CHECK_PTR_VAL(($$.b = gen_ncode(cstate, NULL, $1,\n\t\t\t\t\t\t   $$.q = $<blk>0.q))); }\n\t| pid\n\t;\nterm:\t  rterm\n\t| not term\t\t{ gen_not($2.b); $$ = $2; }\n\t;\nhead:\t  pqual dqual aqual\t{ QSET($$.q, $1, $2, $3); }\n\t| pqual dqual\t\t{ QSET($$.q, $1, $2, Q_DEFAULT); }\n\t| pqual aqual\t\t{ QSET($$.q, $1, Q_DEFAULT, $2); }\n\t| pqual PROTO\t\t{ QSET($$.q, $1, Q_DEFAULT, Q_PROTO); }\n\t| pqual PROTOCHAIN\t{\n#ifdef NO_PROTOCHAIN\n\t\t\t\t  bpf_set_error(cstate, \"protochain not supported\");\n\t\t\t\t  YYABORT;\n#else\n\t\t\t\t  QSET($$.q, $1, Q_DEFAULT, Q_PROTOCHAIN);\n#endif\n\t\t\t\t}\n\t| pqual ndaqual\t\t{ QSET($$.q, $1, Q_DEFAULT, $2); }\n\t;\nrterm:\t  head id\t\t{ $$ = $2; }\n\t| paren expr ')'\t{ $$.b = $2.b; $$.q = $1.q; }\n\t| pname\t\t\t{ CHECK_PTR_VAL(($$.b = gen_proto_abbrev(cstate, $1))); $$.q = qerr; }\n\t| arth relop arth\t{ CHECK_PTR_VAL(($$.b = gen_relation(cstate, $2, $1, $3, 0)));\n\t\t\t\t  $$.q = qerr; }\n\t| arth irelop arth\t{ CHECK_PTR_VAL(($$.b = gen_relation(cstate, $2, $1, $3, 1)));\n\t\t\t\t  $$.q = qerr; }\n\t| other\t\t\t{ $$.b = $1; $$.q = qerr; }\n\t| atmtype\t\t{ CHECK_PTR_VAL(($$.b = gen_atmtype_abbrev(cstate, $1))); $$.q = qerr; }\n\t| atmmultitype\t\t{ CHECK_PTR_VAL(($$.b = gen_atmmulti_abbrev(cstate, $1))); $$.q = qerr; }\n\t| atmfield atmvalue\t{ $$.b = $2.b; $$.q = qerr; }\n\t| mtp2type\t\t{ CHECK_PTR_VAL(($$.b = gen_mtp2type_abbrev(cstate, $1))); $$.q = qerr; }\n\t| mtp3field mtp3value\t{ $$.b = $2.b; $$.q = qerr; }\n\t;\n/* protocol level qualifiers */\npqual:\t  pname\n\t|\t\t\t{ $$ = Q_DEFAULT; }\n\t;\n/* 'direction' qualifiers */\ndqual:\t  SRC\t\t\t{ $$ = Q_SRC; }\n\t| DST\t\t\t{ $$ = Q_DST; }\n\t| SRC OR DST\t\t{ $$ = Q_OR; }\n\t| DST OR SRC\t\t{ $$ = Q_OR; }\n\t| SRC AND DST\t\t{ $$ = Q_AND; }\n\t| DST AND SRC\t\t{ $$ = Q_AND; }\n\t| ADDR1\t\t\t{ $$ = Q_ADDR1; }\n\t| ADDR2\t\t\t{ $$ = Q_ADDR2; }\n\t| ADDR3\t\t\t{ $$ = Q_ADDR3; }\n\t| ADDR4\t\t\t{ $$ = Q_ADDR4; }\n\t| RA\t\t\t{ $$ = Q_RA; }\n\t| TA\t\t\t{ $$ = Q_TA; }\n\t;\n/* address type qualifiers */\naqual:\t  HOST\t\t\t{ $$ = Q_HOST; }\n\t| NET\t\t\t{ $$ = Q_NET; }\n\t| PORT\t\t\t{ $$ = Q_PORT; }\n\t| PORTRANGE\t\t{ $$ = Q_PORTRANGE; }\n\t;\n/* non-directional address type qualifiers */\nndaqual:  GATEWAY\t\t{ $$ = Q_GATEWAY; }\n\t;\npname:\t  LINK\t\t\t{ $$ = Q_LINK; }\n\t| IP\t\t\t{ $$ = Q_IP; }\n\t| ARP\t\t\t{ $$ = Q_ARP; }\n\t| RARP\t\t\t{ $$ = Q_RARP; }\n\t| SCTP\t\t\t{ $$ = Q_SCTP; }\n\t| TCP\t\t\t{ $$ = Q_TCP; }\n\t| UDP\t\t\t{ $$ = Q_UDP; }\n\t| ICMP\t\t\t{ $$ = Q_ICMP; }\n\t| IGMP\t\t\t{ $$ = Q_IGMP; }\n\t| IGRP\t\t\t{ $$ = Q_IGRP; }\n\t| PIM\t\t\t{ $$ = Q_PIM; }\n\t| VRRP\t\t\t{ $$ = Q_VRRP; }\n\t| CARP\t\t\t{ $$ = Q_CARP; }\n\t| ATALK\t\t\t{ $$ = Q_ATALK; }\n\t| AARP\t\t\t{ $$ = Q_AARP; }\n\t| DECNET\t\t{ $$ = Q_DECNET; }\n\t| LAT\t\t\t{ $$ = Q_LAT; }\n\t| SCA\t\t\t{ $$ = Q_SCA; }\n\t| MOPDL\t\t\t{ $$ = Q_MOPDL; }\n\t| MOPRC\t\t\t{ $$ = Q_MOPRC; }\n\t| IPV6\t\t\t{ $$ = Q_IPV6; }\n\t| ICMPV6\t\t{ $$ = Q_ICMPV6; }\n\t| AH\t\t\t{ $$ = Q_AH; }\n\t| ESP\t\t\t{ $$ = Q_ESP; }\n\t| ISO\t\t\t{ $$ = Q_ISO; }\n\t| ESIS\t\t\t{ $$ = Q_ESIS; }\n\t| ISIS\t\t\t{ $$ = Q_ISIS; }\n\t| L1\t\t\t{ $$ = Q_ISIS_L1; }\n\t| L2\t\t\t{ $$ = Q_ISIS_L2; }\n\t| IIH\t\t\t{ $$ = Q_ISIS_IIH; }\n\t| LSP\t\t\t{ $$ = Q_ISIS_LSP; }\n\t| SNP\t\t\t{ $$ = Q_ISIS_SNP; }\n\t| PSNP\t\t\t{ $$ = Q_ISIS_PSNP; }\n\t| CSNP\t\t\t{ $$ = Q_ISIS_CSNP; }\n\t| CLNP\t\t\t{ $$ = Q_CLNP; }\n\t| STP\t\t\t{ $$ = Q_STP; }\n\t| IPX\t\t\t{ $$ = Q_IPX; }\n\t| NETBEUI\t\t{ $$ = Q_NETBEUI; }\n\t| RADIO\t\t\t{ $$ = Q_RADIO; }\n\t;\nother:\t  pqual TK_BROADCAST\t{ CHECK_PTR_VAL(($$ = gen_broadcast(cstate, $1))); }\n\t| pqual TK_MULTICAST\t{ CHECK_PTR_VAL(($$ = gen_multicast(cstate, $1))); }\n\t| LESS NUM\t\t{ CHECK_PTR_VAL(($$ = gen_less(cstate, $2))); }\n\t| GREATER NUM\t\t{ CHECK_PTR_VAL(($$ = gen_greater(cstate, $2))); }\n\t| CBYTE NUM byteop NUM\t{ CHECK_PTR_VAL(($$ = gen_byteop(cstate, $3, $2, $4))); }\n\t| INBOUND\t\t{ CHECK_PTR_VAL(($$ = gen_inbound(cstate, 0))); }\n\t| OUTBOUND\t\t{ CHECK_PTR_VAL(($$ = gen_inbound(cstate, 1))); }\n\t| IFINDEX NUM\t\t{ CHECK_PTR_VAL(($$ = gen_ifindex(cstate, $2))); }\n\t| VLAN pnum\t\t{ CHECK_PTR_VAL(($$ = gen_vlan(cstate, $2, 1))); }\n\t| VLAN\t\t\t{ CHECK_PTR_VAL(($$ = gen_vlan(cstate, 0, 0))); }\n\t| MPLS pnum\t\t{ CHECK_PTR_VAL(($$ = gen_mpls(cstate, $2, 1))); }\n\t| MPLS\t\t\t{ CHECK_PTR_VAL(($$ = gen_mpls(cstate, 0, 0))); }\n\t| PPPOED\t\t{ CHECK_PTR_VAL(($$ = gen_pppoed(cstate))); }\n\t| PPPOES pnum\t\t{ CHECK_PTR_VAL(($$ = gen_pppoes(cstate, $2, 1))); }\n\t| PPPOES\t\t{ CHECK_PTR_VAL(($$ = gen_pppoes(cstate, 0, 0))); }\n\t| GENEVE pnum\t\t{ CHECK_PTR_VAL(($$ = gen_geneve(cstate, $2, 1))); }\n\t| GENEVE\t\t{ CHECK_PTR_VAL(($$ = gen_geneve(cstate, 0, 0))); }\n\t| VXLAN pnum\t\t{ CHECK_PTR_VAL(($$ = gen_vxlan(cstate, $2, 1))); }\n\t| VXLAN\t\t\t{ CHECK_PTR_VAL(($$ = gen_vxlan(cstate, 0, 0))); }\n\t| pfvar\t\t\t{ $$ = $1; }\n\t| pqual p80211\t\t{ $$ = $2; }\n\t| pllc\t\t\t{ $$ = $1; }\n\t;\n\npfvar:\t  PF_IFNAME ID\t\t{ CHECK_PTR_VAL($2); CHECK_PTR_VAL(($$ = gen_pf_ifname(cstate, $2))); }\n\t| PF_RSET ID\t\t{ CHECK_PTR_VAL($2); CHECK_PTR_VAL(($$ = gen_pf_ruleset(cstate, $2))); }\n\t| PF_RNR NUM\t\t{ CHECK_PTR_VAL(($$ = gen_pf_rnr(cstate, $2))); }\n\t| PF_SRNR NUM\t\t{ CHECK_PTR_VAL(($$ = gen_pf_srnr(cstate, $2))); }\n\t| PF_REASON reason\t{ CHECK_PTR_VAL(($$ = gen_pf_reason(cstate, $2))); }\n\t| PF_ACTION action\t{ CHECK_PTR_VAL(($$ = gen_pf_action(cstate, $2))); }\n\t;\n\np80211:   TYPE type SUBTYPE subtype\n\t\t\t\t{ CHECK_PTR_VAL(($$ = gen_p80211_type(cstate, $2 | $4,\n\t\t\t\t\tIEEE80211_FC0_TYPE_MASK |\n\t\t\t\t\tIEEE80211_FC0_SUBTYPE_MASK)));\n\t\t\t\t}\n\t| TYPE type\t\t{ CHECK_PTR_VAL(($$ = gen_p80211_type(cstate, $2,\n\t\t\t\t\tIEEE80211_FC0_TYPE_MASK)));\n\t\t\t\t}\n\t| SUBTYPE type_subtype\t{ CHECK_PTR_VAL(($$ = gen_p80211_type(cstate, $2,\n\t\t\t\t\tIEEE80211_FC0_TYPE_MASK |\n\t\t\t\t\tIEEE80211_FC0_SUBTYPE_MASK)));\n\t\t\t\t}\n\t| DIR dir\t\t{ CHECK_PTR_VAL(($$ = gen_p80211_fcdir(cstate, $2))); }\n\t;\n\ntype:\t  NUM\t\t\t{ if (($1 & (~IEEE80211_FC0_TYPE_MASK)) != 0) {\n\t\t\t\t\tbpf_set_error(cstate, \"invalid 802.11 type value 0x%02x\", $1);\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  $$ = (int)$1;\n\t\t\t\t}\n\t| ID\t\t\t{ CHECK_PTR_VAL($1);\n\t\t\t\t  $$ = str2tok($1, ieee80211_types);\n\t\t\t\t  if ($$ == -1) {\n\t\t\t\t\tbpf_set_error(cstate, \"unknown 802.11 type name \\\"%s\\\"\", $1);\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t}\n\t;\n\nsubtype:  NUM\t\t\t{ if (($1 & (~IEEE80211_FC0_SUBTYPE_MASK)) != 0) {\n\t\t\t\t\tbpf_set_error(cstate, \"invalid 802.11 subtype value 0x%02x\", $1);\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  $$ = (int)$1;\n\t\t\t\t}\n\t| ID\t\t\t{ const struct tok *types = NULL;\n\t\t\t\t  int i;\n\t\t\t\t  CHECK_PTR_VAL($1);\n\t\t\t\t  for (i = 0;; i++) {\n\t\t\t\t\tif (ieee80211_type_subtypes[i].tok == NULL) {\n\t\t\t\t\t\t/* Ran out of types */\n\t\t\t\t\t\tbpf_set_error(cstate, \"unknown 802.11 type\");\n\t\t\t\t\t\tYYABORT;\n\t\t\t\t\t}\n\t\t\t\t\tif ($<i>-1 == ieee80211_type_subtypes[i].type) {\n\t\t\t\t\t\ttypes = ieee80211_type_subtypes[i].tok;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t  }\n\n\t\t\t\t  $$ = str2tok($1, types);\n\t\t\t\t  if ($$ == -1) {\n\t\t\t\t\tbpf_set_error(cstate, \"unknown 802.11 subtype name \\\"%s\\\"\", $1);\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t}\n\t;\n\ntype_subtype:\tID\t\t{ int i;\n\t\t\t\t  CHECK_PTR_VAL($1);\n\t\t\t\t  for (i = 0;; i++) {\n\t\t\t\t\tif (ieee80211_type_subtypes[i].tok == NULL) {\n\t\t\t\t\t\t/* Ran out of types */\n\t\t\t\t\t\tbpf_set_error(cstate, \"unknown 802.11 type name\");\n\t\t\t\t\t\tYYABORT;\n\t\t\t\t\t}\n\t\t\t\t\t$$ = str2tok($1, ieee80211_type_subtypes[i].tok);\n\t\t\t\t\tif ($$ != -1) {\n\t\t\t\t\t\t$$ |= ieee80211_type_subtypes[i].type;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t;\n\npllc:\tLLC\t\t\t{ CHECK_PTR_VAL(($$ = gen_llc(cstate))); }\n\t| LLC ID\t\t{ CHECK_PTR_VAL($2);\n\t\t\t\t  if (pcapint_strcasecmp($2, \"i\") == 0) {\n\t\t\t\t\tCHECK_PTR_VAL(($$ = gen_llc_i(cstate)));\n\t\t\t\t  } else if (pcapint_strcasecmp($2, \"s\") == 0) {\n\t\t\t\t\tCHECK_PTR_VAL(($$ = gen_llc_s(cstate)));\n\t\t\t\t  } else if (pcapint_strcasecmp($2, \"u\") == 0) {\n\t\t\t\t\tCHECK_PTR_VAL(($$ = gen_llc_u(cstate)));\n\t\t\t\t  } else {\n\t\t\t\t\tint subtype;\n\n\t\t\t\t\tsubtype = str2tok($2, llc_s_subtypes);\n\t\t\t\t\tif (subtype != -1) {\n\t\t\t\t\t\tCHECK_PTR_VAL(($$ = gen_llc_s_subtype(cstate, subtype)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubtype = str2tok($2, llc_u_subtypes);\n\t\t\t\t\t\tif (subtype == -1) {\n\t\t\t\t\t\t\tbpf_set_error(cstate, \"unknown LLC type name \\\"%s\\\"\", $2);\n\t\t\t\t\t\t\tYYABORT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCHECK_PTR_VAL(($$ = gen_llc_u_subtype(cstate, subtype)));\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\t/* sigh, \"rnr\" is already a keyword for PF */\n\t| LLC PF_RNR\t\t{ CHECK_PTR_VAL(($$ = gen_llc_s_subtype(cstate, LLC_RNR))); }\n\t;\n\ndir:\t  NUM\t\t\t{ if (($1 & (~IEEE80211_FC1_DIR_MASK)) != 0) {\n\t\t\t\t\tbpf_set_error(cstate, \"invalid 802.11 direction value 0x%x\", $1);\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t  $$ = (int)$1;\n\t\t\t\t}\n\t| ID\t\t\t{ CHECK_PTR_VAL($1);\n\t\t\t\t  if (pcapint_strcasecmp($1, \"nods\") == 0)\n\t\t\t\t\t$$ = IEEE80211_FC1_DIR_NODS;\n\t\t\t\t  else if (pcapint_strcasecmp($1, \"tods\") == 0)\n\t\t\t\t\t$$ = IEEE80211_FC1_DIR_TODS;\n\t\t\t\t  else if (pcapint_strcasecmp($1, \"fromds\") == 0)\n\t\t\t\t\t$$ = IEEE80211_FC1_DIR_FROMDS;\n\t\t\t\t  else if (pcapint_strcasecmp($1, \"dstods\") == 0)\n\t\t\t\t\t$$ = IEEE80211_FC1_DIR_DSTODS;\n\t\t\t\t  else {\n\t\t\t\t\tbpf_set_error(cstate, \"unknown 802.11 direction\");\n\t\t\t\t\tYYABORT;\n\t\t\t\t  }\n\t\t\t\t}\n\t;\n\nreason:\t  NUM\t\t\t{ $$ = $1; }\n\t| ID\t\t\t{ CHECK_PTR_VAL($1); CHECK_INT_VAL(($$ = pfreason_to_num(cstate, $1))); }\n\t;\n\naction:\t  ID\t\t\t{ CHECK_PTR_VAL($1); CHECK_INT_VAL(($$ = pfaction_to_num(cstate, $1))); }\n\t;\n\nrelop:\t  '>'\t\t\t{ $$ = BPF_JGT; }\n\t| GEQ\t\t\t{ $$ = BPF_JGE; }\n\t| '='\t\t\t{ $$ = BPF_JEQ; }\n\t;\nirelop:\t  LEQ\t\t\t{ $$ = BPF_JGT; }\n\t| '<'\t\t\t{ $$ = BPF_JGE; }\n\t| NEQ\t\t\t{ $$ = BPF_JEQ; }\n\t;\narth:\t  pnum\t\t\t{ CHECK_PTR_VAL(($$ = gen_loadi(cstate, $1))); }\n\t| narth\n\t;\nnarth:\t  pname '[' arth ']'\t\t{ CHECK_PTR_VAL(($$ = gen_load(cstate, $1, $3, 1))); }\n\t| pname '[' arth ':' NUM ']'\t{ CHECK_PTR_VAL(($$ = gen_load(cstate, $1, $3, $5))); }\n\t| arth '+' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_ADD, $1, $3))); }\n\t| arth '-' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_SUB, $1, $3))); }\n\t| arth '*' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_MUL, $1, $3))); }\n\t| arth '/' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_DIV, $1, $3))); }\n\t| arth '%' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_MOD, $1, $3))); }\n\t| arth '&' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_AND, $1, $3))); }\n\t| arth '|' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_OR, $1, $3))); }\n\t| arth '^' arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_XOR, $1, $3))); }\n\t| arth LSH arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_LSH, $1, $3))); }\n\t| arth RSH arth\t\t\t{ CHECK_PTR_VAL(($$ = gen_arth(cstate, BPF_RSH, $1, $3))); }\n\t| '-' arth %prec UMINUS\t\t{ CHECK_PTR_VAL(($$ = gen_neg(cstate, $2))); }\n\t| paren narth ')'\t\t{ $$ = $2; }\n\t| LEN\t\t\t\t{ CHECK_PTR_VAL(($$ = gen_loadlen(cstate))); }\n\t;\nbyteop:\t  '&'\t\t\t{ $$ = '&'; }\n\t| '|'\t\t\t{ $$ = '|'; }\n\t| '<'\t\t\t{ $$ = '<'; }\n\t| '>'\t\t\t{ $$ = '>'; }\n\t| '='\t\t\t{ $$ = '='; }\n\t;\npnum:\t  NUM\n\t| paren pnum ')'\t{ $$ = $2; }\n\t;\natmtype: LANE\t\t\t{ $$ = A_LANE; }\n\t| METAC\t\t\t{ $$ = A_METAC;\t}\n\t| BCC\t\t\t{ $$ = A_BCC; }\n\t| OAMF4EC\t\t{ $$ = A_OAMF4EC; }\n\t| OAMF4SC\t\t{ $$ = A_OAMF4SC; }\n\t| SC\t\t\t{ $$ = A_SC; }\n\t| ILMIC\t\t\t{ $$ = A_ILMIC; }\n\t;\natmmultitype: OAM\t\t{ $$ = A_OAM; }\n\t| OAMF4\t\t\t{ $$ = A_OAMF4; }\n\t| CONNECTMSG\t\t{ $$ = A_CONNECTMSG; }\n\t| METACONNECT\t\t{ $$ = A_METACONNECT; }\n\t;\n\t/* ATM field types quantifier */\natmfield: VPI\t\t\t{ $$.atmfieldtype = A_VPI; }\n\t| VCI\t\t\t{ $$.atmfieldtype = A_VCI; }\n\t;\natmvalue: atmfieldvalue\n\t| relop NUM\t\t{ CHECK_PTR_VAL(($$.b = gen_atmfield_code(cstate, $<blk>0.atmfieldtype, $2, $1, 0))); }\n\t| irelop NUM\t\t{ CHECK_PTR_VAL(($$.b = gen_atmfield_code(cstate, $<blk>0.atmfieldtype, $2, $1, 1))); }\n\t| paren atmlistvalue ')' { $$.b = $2.b; $$.q = qerr; }\n\t;\natmfieldvalue: NUM {\n\t$$.atmfieldtype = $<blk>0.atmfieldtype;\n\tif ($$.atmfieldtype == A_VPI ||\n\t    $$.atmfieldtype == A_VCI)\n\t\tCHECK_PTR_VAL(($$.b = gen_atmfield_code(cstate, $$.atmfieldtype, $1, BPF_JEQ, 0)));\n\t}\n\t;\natmlistvalue: atmfieldvalue\n\t| atmlistvalue or atmfieldvalue { gen_or($1.b, $3.b); $$ = $3; }\n\t;\n\t/* MTP2 types quantifier */\nmtp2type: FISU\t\t\t{ $$ = M_FISU; }\n\t| LSSU\t\t\t{ $$ = M_LSSU; }\n\t| MSU\t\t\t{ $$ = M_MSU; }\n\t| HFISU\t\t\t{ $$ = MH_FISU; }\n\t| HLSSU\t\t\t{ $$ = MH_LSSU; }\n\t| HMSU\t\t\t{ $$ = MH_MSU; }\n\t;\n\t/* MTP3 field types quantifier */\nmtp3field: SIO\t\t\t{ $$.mtp3fieldtype = M_SIO; }\n\t| OPC\t\t\t{ $$.mtp3fieldtype = M_OPC; }\n\t| DPC\t\t\t{ $$.mtp3fieldtype = M_DPC; }\n\t| SLS                   { $$.mtp3fieldtype = M_SLS; }\n\t| HSIO\t\t\t{ $$.mtp3fieldtype = MH_SIO; }\n\t| HOPC\t\t\t{ $$.mtp3fieldtype = MH_OPC; }\n\t| HDPC\t\t\t{ $$.mtp3fieldtype = MH_DPC; }\n\t| HSLS                  { $$.mtp3fieldtype = MH_SLS; }\n\t;\nmtp3value: mtp3fieldvalue\n\t| relop NUM\t\t{ CHECK_PTR_VAL(($$.b = gen_mtp3field_code(cstate, $<blk>0.mtp3fieldtype, $2, $1, 0))); }\n\t| irelop NUM\t\t{ CHECK_PTR_VAL(($$.b = gen_mtp3field_code(cstate, $<blk>0.mtp3fieldtype, $2, $1, 1))); }\n\t| paren mtp3listvalue ')' { $$.b = $2.b; $$.q = qerr; }\n\t;\nmtp3fieldvalue: NUM {\n\t$$.mtp3fieldtype = $<blk>0.mtp3fieldtype;\n\tif ($$.mtp3fieldtype == M_SIO ||\n\t    $$.mtp3fieldtype == M_OPC ||\n\t    $$.mtp3fieldtype == M_DPC ||\n\t    $$.mtp3fieldtype == M_SLS ||\n\t    $$.mtp3fieldtype == MH_SIO ||\n\t    $$.mtp3fieldtype == MH_OPC ||\n\t    $$.mtp3fieldtype == MH_DPC ||\n\t    $$.mtp3fieldtype == MH_SLS)\n\t\tCHECK_PTR_VAL(($$.b = gen_mtp3field_code(cstate, $$.mtp3fieldtype, $1, BPF_JEQ, 0)));\n\t}\n\t;\nmtp3listvalue: mtp3fieldvalue\n\t| mtp3listvalue or mtp3fieldvalue { gen_or($1.b, $3.b); $$ = $3; }\n\t;\n%%\n"
        },
        {
          "name": "ieee80211.h",
          "type": "blob",
          "size": 5.3759765625,
          "content": "/*-\n * Copyright (c) 2001 Atsushi Onoe\n * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * $FreeBSD: src/sys/net80211/ieee80211.h,v 1.10 2005/07/22 16:55:27 sam Exp $\n */\n#ifndef _NET80211_IEEE80211_H_\n#define _NET80211_IEEE80211_H_\n\n/*\n * 802.11 protocol definitions.\n */\n\n#define\tIEEE80211_FC0_VERSION_MASK\t\t0x03\n#define\tIEEE80211_FC0_VERSION_SHIFT\t\t0\n#define\tIEEE80211_FC0_VERSION_0\t\t\t0x00\n#define\tIEEE80211_FC0_TYPE_MASK\t\t\t0x0c\n#define\tIEEE80211_FC0_TYPE_SHIFT\t\t2\n#define\tIEEE80211_FC0_TYPE_MGT\t\t\t0x00\n#define\tIEEE80211_FC0_TYPE_CTL\t\t\t0x04\n#define\tIEEE80211_FC0_TYPE_DATA\t\t\t0x08\n\n#define\tIEEE80211_FC0_SUBTYPE_MASK\t\t0xf0\n#define\tIEEE80211_FC0_SUBTYPE_SHIFT\t\t4\n/* for TYPE_MGT */\n#define\tIEEE80211_FC0_SUBTYPE_ASSOC_REQ\t\t0x00\n#define\tIEEE80211_FC0_SUBTYPE_ASSOC_RESP\t0x10\n#define\tIEEE80211_FC0_SUBTYPE_REASSOC_REQ\t0x20\n#define\tIEEE80211_FC0_SUBTYPE_REASSOC_RESP\t0x30\n#define\tIEEE80211_FC0_SUBTYPE_PROBE_REQ\t\t0x40\n#define\tIEEE80211_FC0_SUBTYPE_PROBE_RESP\t0x50\n#define\tIEEE80211_FC0_SUBTYPE_BEACON\t\t0x80\n#define\tIEEE80211_FC0_SUBTYPE_ATIM\t\t0x90\n#define\tIEEE80211_FC0_SUBTYPE_DISASSOC\t\t0xa0\n#define\tIEEE80211_FC0_SUBTYPE_AUTH\t\t0xb0\n#define\tIEEE80211_FC0_SUBTYPE_DEAUTH\t\t0xc0\n/* for TYPE_CTL */\n#define\tIEEE80211_FC0_SUBTYPE_BAR\t\t0x80\n#define\tIEEE80211_FC0_SUBTYPE_BA\t\t0x90\n#define\tIEEE80211_FC0_SUBTYPE_PS_POLL\t\t0xa0\n#define\tIEEE80211_FC0_SUBTYPE_RTS\t\t0xb0\n#define\tIEEE80211_FC0_SUBTYPE_CTS\t\t0xc0\n#define\tIEEE80211_FC0_SUBTYPE_ACK\t\t0xd0\n#define\tIEEE80211_FC0_SUBTYPE_CF_END\t\t0xe0\n#define\tIEEE80211_FC0_SUBTYPE_CF_END_ACK\t0xf0\n/* for TYPE_DATA (bit combination) */\n#define\tIEEE80211_FC0_SUBTYPE_DATA\t\t0x00\n#define\tIEEE80211_FC0_SUBTYPE_CF_ACK\t\t0x10\n#define\tIEEE80211_FC0_SUBTYPE_CF_POLL\t\t0x20\n#define\tIEEE80211_FC0_SUBTYPE_CF_ACPL\t\t0x30\n#define\tIEEE80211_FC0_SUBTYPE_NODATA\t\t0x40\n#define\tIEEE80211_FC0_SUBTYPE_NODATA_CF_ACK\t0x50\n#define\tIEEE80211_FC0_SUBTYPE_NODATA_CF_POLL\t0x60\n#define\tIEEE80211_FC0_SUBTYPE_NODATA_CF_ACPL\t0x70\n#define\tIEEE80211_FC0_SUBTYPE_QOS\t\t0x80\n#define\tIEEE80211_FC0_SUBTYPE_QOS_NULL\t\t0xc0\n\n#define\tIEEE80211_FC1_DIR_MASK\t\t\t0x03\n#define\tIEEE80211_FC1_DIR_NODS\t\t\t0x00\t/* STA->STA */\n#define\tIEEE80211_FC1_DIR_TODS\t\t\t0x01\t/* STA->AP  */\n#define\tIEEE80211_FC1_DIR_FROMDS\t\t0x02\t/* AP ->STA */\n#define\tIEEE80211_FC1_DIR_DSTODS\t\t0x03\t/* AP ->AP  */\n\n#define\tIEEE80211_FC1_MORE_FRAG\t\t\t0x04\n#define\tIEEE80211_FC1_RETRY\t\t\t0x08\n#define\tIEEE80211_FC1_PWR_MGT\t\t\t0x10\n#define\tIEEE80211_FC1_MORE_DATA\t\t\t0x20\n#define\tIEEE80211_FC1_WEP\t\t\t0x40\n#define\tIEEE80211_FC1_ORDER\t\t\t0x80\n\n#define\tIEEE80211_SEQ_FRAG_MASK\t\t\t0x000f\n#define\tIEEE80211_SEQ_FRAG_SHIFT\t\t0\n#define\tIEEE80211_SEQ_SEQ_MASK\t\t\t0xfff0\n#define\tIEEE80211_SEQ_SEQ_SHIFT\t\t\t4\n\n#define\tIEEE80211_NWID_LEN\t\t\t32\n\n#define\tIEEE80211_QOS_TXOP\t\t\t0x00ff\n/* bit 8 is reserved */\n#define\tIEEE80211_QOS_ACKPOLICY\t\t\t0x60\n#define\tIEEE80211_QOS_ACKPOLICY_S\t\t5\n#define\tIEEE80211_QOS_ESOP\t\t\t0x10\n#define\tIEEE80211_QOS_ESOP_S\t\t\t4\n#define\tIEEE80211_QOS_TID\t\t\t0x0f\n\n#define IEEE80211_MGT_SUBTYPE_NAMES {\t\t\t\\\n\t\"assoc-req\",\t\t\"assoc-resp\",\t\t\\\n\t\"reassoc-req\",\t\t\"reassoc-resp\",\t\t\\\n\t\"probe-req\",\t\t\"probe-resp\",\t\t\\\n\t\"reserved#6\",\t\t\"reserved#7\",\t\t\\\n\t\"beacon\",\t\t\"atim\",\t\t\t\\\n\t\"disassoc\",\t\t\"auth\",\t\t\t\\\n\t\"deauth\",\t\t\"reserved#13\",\t\t\\\n\t\"reserved#14\",\t\t\"reserved#15\"\t\t\\\n}\n\n#define IEEE80211_CTL_SUBTYPE_NAMES {\t\t\t\\\n\t\"reserved#0\",\t\t\"reserved#1\",\t\t\\\n\t\"reserved#2\",\t\t\"reserved#3\",\t\t\\\n\t\"reserved#3\",\t\t\"reserved#5\",\t\t\\\n\t\"reserved#6\",\t\t\"reserved#7\",\t\t\\\n\t\"bar\",\t\t\t\"ba\",\t\t\t\\\n\t\"ps-poll\",\t\t\"rts\",\t\t\t\\\n\t\"cts\",\t\t\t\"ack\",\t\t\t\\\n\t\"cf-end\",\t\t\"cf-end-ack\"\t\t\\\n}\n\n#define IEEE80211_DATA_SUBTYPE_NAMES {\t\t\t\\\n\t\"data\",\t\t\t\"data-cf-ack\",\t\t\\\n\t\"data-cf-poll\",\t\t\"data-cf-ack-poll\",\t\\\n\t\"null\",\t\t\t\"cf-ack\",\t\t\\\n\t\"cf-poll\",\t\t\"cf-ack-poll\",\t\t\\\n\t\"qos-data\",\t\t\"qos-data-cf-ack\",\t\\\n\t\"qos-data-cf-poll\",\t\"qos-data-cf-ack-poll\",\t\\\n\t\"qos\",\t\t\t\"reserved#13\",\t\t\\\n\t\"qos-cf-poll\",\t\t\"qos-cf-ack-poll\"\t\\\n}\n\n#define IEEE80211_TYPE_NAMES\t{ \"mgt\", \"ctl\", \"data\", \"reserved#4\" }\n\n#endif /* _NET80211_IEEE80211_H_ */\n"
        },
        {
          "name": "install-sh",
          "type": "blob",
          "size": 14.998046875,
          "content": "#!/bin/sh\n# install - install a program, script, or datafile\n\nscriptversion=2020-11-14.01; # UTC\n\n# This originates from X11R5 (mit/util/scripts/install.sh), which was\n# later released in X11R6 (xc/config/util/install.sh) with the\n# following copyright and license.\n#\n# Copyright (C) 1994 X Consortium\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to\n# deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n# sell copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n# Except as contained in this notice, the name of the X Consortium shall not\n# be used in advertising or otherwise to promote the sale, use or other deal-\n# ings in this Software without prior written authorization from the X Consor-\n# tium.\n#\n#\n# FSF changes to this file are in the public domain.\n#\n# Calling this script install-sh is preferred over install.sh, to prevent\n# 'make' implicit rules from creating a file called install from it\n# when there is no Makefile.\n#\n# This script is compatible with the BSD install script, but was written\n# from scratch.\n\ntab='\t'\nnl='\n'\nIFS=\" $tab$nl\"\n\n# Set DOITPROG to \"echo\" to test this script.\n\ndoit=${DOITPROG-}\ndoit_exec=${doit:-exec}\n\n# Put in absolute file names if you don't have them in your path;\n# or use environment vars.\n\nchgrpprog=${CHGRPPROG-chgrp}\nchmodprog=${CHMODPROG-chmod}\nchownprog=${CHOWNPROG-chown}\ncmpprog=${CMPPROG-cmp}\ncpprog=${CPPROG-cp}\nmkdirprog=${MKDIRPROG-mkdir}\nmvprog=${MVPROG-mv}\nrmprog=${RMPROG-rm}\nstripprog=${STRIPPROG-strip}\n\nposix_mkdir=\n\n# Desired mode of installed file.\nmode=0755\n\n# Create dirs (including intermediate dirs) using mode 755.\n# This is like GNU 'install' as of coreutils 8.32 (2020).\nmkdir_umask=22\n\nbackupsuffix=\nchgrpcmd=\nchmodcmd=$chmodprog\nchowncmd=\nmvcmd=$mvprog\nrmcmd=\"$rmprog -f\"\nstripcmd=\n\nsrc=\ndst=\ndir_arg=\ndst_arg=\n\ncopy_on_change=false\nis_target_a_directory=possibly\n\nusage=\"\\\nUsage: $0 [OPTION]... [-T] SRCFILE DSTFILE\n   or: $0 [OPTION]... SRCFILES... DIRECTORY\n   or: $0 [OPTION]... -t DIRECTORY SRCFILES...\n   or: $0 [OPTION]... -d DIRECTORIES...\n\nIn the 1st form, copy SRCFILE to DSTFILE.\nIn the 2nd and 3rd, copy all SRCFILES to DIRECTORY.\nIn the 4th, create DIRECTORIES.\n\nOptions:\n     --help     display this help and exit.\n     --version  display version info and exit.\n\n  -c            (ignored)\n  -C            install only if different (preserve data modification time)\n  -d            create directories instead of installing files.\n  -g GROUP      $chgrpprog installed files to GROUP.\n  -m MODE       $chmodprog installed files to MODE.\n  -o USER       $chownprog installed files to USER.\n  -p            pass -p to $cpprog.\n  -s            $stripprog installed files.\n  -S SUFFIX     attempt to back up existing files, with suffix SUFFIX.\n  -t DIRECTORY  install into DIRECTORY.\n  -T            report an error if DSTFILE is a directory.\n\nEnvironment variables override the default commands:\n  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG\n  RMPROG STRIPPROG\n\nBy default, rm is invoked with -f; when overridden with RMPROG,\nit's up to you to specify -f if you want it.\n\nIf -S is not specified, no backups are attempted.\n\nEmail bug reports to bug-automake@gnu.org.\nAutomake home page: https://www.gnu.org/software/automake/\n\"\n\nwhile test $# -ne 0; do\n  case $1 in\n    -c) ;;\n\n    -C) copy_on_change=true;;\n\n    -d) dir_arg=true;;\n\n    -g) chgrpcmd=\"$chgrpprog $2\"\n        shift;;\n\n    --help) echo \"$usage\"; exit $?;;\n\n    -m) mode=$2\n        case $mode in\n          *' '* | *\"$tab\"* | *\"$nl\"* | *'*'* | *'?'* | *'['*)\n            echo \"$0: invalid mode: $mode\" >&2\n            exit 1;;\n        esac\n        shift;;\n\n    -o) chowncmd=\"$chownprog $2\"\n        shift;;\n\n    -p) cpprog=\"$cpprog -p\";;\n\n    -s) stripcmd=$stripprog;;\n\n    -S) backupsuffix=\"$2\"\n        shift;;\n\n    -t)\n        is_target_a_directory=always\n        dst_arg=$2\n        # Protect names problematic for 'test' and other utilities.\n        case $dst_arg in\n          -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n        esac\n        shift;;\n\n    -T) is_target_a_directory=never;;\n\n    --version) echo \"$0 $scriptversion\"; exit $?;;\n\n    --) shift\n        break;;\n\n    -*) echo \"$0: invalid option: $1\" >&2\n        exit 1;;\n\n    *)  break;;\n  esac\n  shift\ndone\n\n# We allow the use of options -d and -T together, by making -d\n# take the precedence; this is for compatibility with GNU install.\n\nif test -n \"$dir_arg\"; then\n  if test -n \"$dst_arg\"; then\n    echo \"$0: target directory not allowed when installing a directory.\" >&2\n    exit 1\n  fi\nfi\n\nif test $# -ne 0 && test -z \"$dir_arg$dst_arg\"; then\n  # When -d is used, all remaining arguments are directories to create.\n  # When -t is used, the destination is already specified.\n  # Otherwise, the last argument is the destination.  Remove it from $@.\n  for arg\n  do\n    if test -n \"$dst_arg\"; then\n      # $@ is not empty: it contains at least $arg.\n      set fnord \"$@\" \"$dst_arg\"\n      shift # fnord\n    fi\n    shift # arg\n    dst_arg=$arg\n    # Protect names problematic for 'test' and other utilities.\n    case $dst_arg in\n      -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n    esac\n  done\nfi\n\nif test $# -eq 0; then\n  if test -z \"$dir_arg\"; then\n    echo \"$0: no input file specified.\" >&2\n    exit 1\n  fi\n  # It's OK to call 'install-sh -d' without argument.\n  # This can happen when creating conditional directories.\n  exit 0\nfi\n\nif test -z \"$dir_arg\"; then\n  if test $# -gt 1 || test \"$is_target_a_directory\" = always; then\n    if test ! -d \"$dst_arg\"; then\n      echo \"$0: $dst_arg: Is not a directory.\" >&2\n      exit 1\n    fi\n  fi\nfi\n\nif test -z \"$dir_arg\"; then\n  do_exit='(exit $ret); exit $ret'\n  trap \"ret=129; $do_exit\" 1\n  trap \"ret=130; $do_exit\" 2\n  trap \"ret=141; $do_exit\" 13\n  trap \"ret=143; $do_exit\" 15\n\n  # Set umask so as not to create temps with too-generous modes.\n  # However, 'strip' requires both read and write access to temps.\n  case $mode in\n    # Optimize common cases.\n    *644) cp_umask=133;;\n    *755) cp_umask=22;;\n\n    *[0-7])\n      if test -z \"$stripcmd\"; then\n        u_plus_rw=\n      else\n        u_plus_rw='% 200'\n      fi\n      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;\n    *)\n      if test -z \"$stripcmd\"; then\n        u_plus_rw=\n      else\n        u_plus_rw=,u+rw\n      fi\n      cp_umask=$mode$u_plus_rw;;\n  esac\nfi\n\nfor src\ndo\n  # Protect names problematic for 'test' and other utilities.\n  case $src in\n    -* | [=\\(\\)!]) src=./$src;;\n  esac\n\n  if test -n \"$dir_arg\"; then\n    dst=$src\n    dstdir=$dst\n    test -d \"$dstdir\"\n    dstdir_status=$?\n    # Don't chown directories that already exist.\n    if test $dstdir_status = 0; then\n      chowncmd=\"\"\n    fi\n  else\n\n    # Waiting for this to be detected by the \"$cpprog $src $dsttmp\" command\n    # might cause directories to be created, which would be especially bad\n    # if $src (and thus $dsttmp) contains '*'.\n    if test ! -f \"$src\" && test ! -d \"$src\"; then\n      echo \"$0: $src does not exist.\" >&2\n      exit 1\n    fi\n\n    if test -z \"$dst_arg\"; then\n      echo \"$0: no destination specified.\" >&2\n      exit 1\n    fi\n    dst=$dst_arg\n\n    # If destination is a directory, append the input filename.\n    if test -d \"$dst\"; then\n      if test \"$is_target_a_directory\" = never; then\n        echo \"$0: $dst_arg: Is a directory\" >&2\n        exit 1\n      fi\n      dstdir=$dst\n      dstbase=`basename \"$src\"`\n      case $dst in\n\t*/) dst=$dst$dstbase;;\n\t*)  dst=$dst/$dstbase;;\n      esac\n      dstdir_status=0\n    else\n      dstdir=`dirname \"$dst\"`\n      test -d \"$dstdir\"\n      dstdir_status=$?\n    fi\n  fi\n\n  case $dstdir in\n    */) dstdirslash=$dstdir;;\n    *)  dstdirslash=$dstdir/;;\n  esac\n\n  obsolete_mkdir_used=false\n\n  if test $dstdir_status != 0; then\n    case $posix_mkdir in\n      '')\n        # With -d, create the new directory with the user-specified mode.\n        # Otherwise, rely on $mkdir_umask.\n        if test -n \"$dir_arg\"; then\n          mkdir_mode=-m$mode\n        else\n          mkdir_mode=\n        fi\n\n        posix_mkdir=false\n\t# The $RANDOM variable is not portable (e.g., dash).  Use it\n\t# here however when possible just to lower collision chance.\n\ttmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$\n\n\ttrap '\n\t  ret=$?\n\t  rmdir \"$tmpdir/a/b\" \"$tmpdir/a\" \"$tmpdir\" 2>/dev/null\n\t  exit $ret\n\t' 0\n\n\t# Because \"mkdir -p\" follows existing symlinks and we likely work\n\t# directly in world-writeable /tmp, make sure that the '$tmpdir'\n\t# directory is successfully created first before we actually test\n\t# 'mkdir -p'.\n\tif (umask $mkdir_umask &&\n\t    $mkdirprog $mkdir_mode \"$tmpdir\" &&\n\t    exec $mkdirprog $mkdir_mode -p -- \"$tmpdir/a/b\") >/dev/null 2>&1\n\tthen\n\t  if test -z \"$dir_arg\" || {\n\t       # Check for POSIX incompatibilities with -m.\n\t       # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or\n\t       # other-writable bit of parent directory when it shouldn't.\n\t       # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.\n\t       test_tmpdir=\"$tmpdir/a\"\n\t       ls_ld_tmpdir=`ls -ld \"$test_tmpdir\"`\n\t       case $ls_ld_tmpdir in\n\t\t d????-?r-*) different_mode=700;;\n\t\t d????-?--*) different_mode=755;;\n\t\t *) false;;\n\t       esac &&\n\t       $mkdirprog -m$different_mode -p -- \"$test_tmpdir\" && {\n\t\t ls_ld_tmpdir_1=`ls -ld \"$test_tmpdir\"`\n\t\t test \"$ls_ld_tmpdir\" = \"$ls_ld_tmpdir_1\"\n\t       }\n\t     }\n\t  then posix_mkdir=:\n\t  fi\n\t  rmdir \"$tmpdir/a/b\" \"$tmpdir/a\" \"$tmpdir\"\n\telse\n\t  # Remove any dirs left behind by ancient mkdir implementations.\n\t  rmdir ./$mkdir_mode ./-p ./-- \"$tmpdir\" 2>/dev/null\n\tfi\n\ttrap '' 0;;\n    esac\n\n    if\n      $posix_mkdir && (\n        umask $mkdir_umask &&\n        $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\"\n      )\n    then :\n    else\n\n      # mkdir does not conform to POSIX,\n      # or it failed possibly due to a race condition.  Create the\n      # directory the slow way, step by step, checking for races as we go.\n\n      case $dstdir in\n        /*) prefix='/';;\n        [-=\\(\\)!]*) prefix='./';;\n        *)  prefix='';;\n      esac\n\n      oIFS=$IFS\n      IFS=/\n      set -f\n      set fnord $dstdir\n      shift\n      set +f\n      IFS=$oIFS\n\n      prefixes=\n\n      for d\n      do\n        test X\"$d\" = X && continue\n\n        prefix=$prefix$d\n        if test -d \"$prefix\"; then\n          prefixes=\n        else\n          if $posix_mkdir; then\n            (umask $mkdir_umask &&\n             $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\") && break\n            # Don't fail if two instances are running concurrently.\n            test -d \"$prefix\" || exit 1\n          else\n            case $prefix in\n              *\\'*) qprefix=`echo \"$prefix\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;;\n              *) qprefix=$prefix;;\n            esac\n            prefixes=\"$prefixes '$qprefix'\"\n          fi\n        fi\n        prefix=$prefix/\n      done\n\n      if test -n \"$prefixes\"; then\n        # Don't fail if two instances are running concurrently.\n        (umask $mkdir_umask &&\n         eval \"\\$doit_exec \\$mkdirprog $prefixes\") ||\n          test -d \"$dstdir\" || exit 1\n        obsolete_mkdir_used=true\n      fi\n    fi\n  fi\n\n  if test -n \"$dir_arg\"; then\n    { test -z \"$chowncmd\" || $doit $chowncmd \"$dst\"; } &&\n    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dst\"; } &&\n    { test \"$obsolete_mkdir_used$chowncmd$chgrpcmd\" = false ||\n      test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dst\"; } || exit 1\n  else\n\n    # Make a couple of temp file names in the proper directory.\n    dsttmp=${dstdirslash}_inst.$$_\n    rmtmp=${dstdirslash}_rm.$$_\n\n    # Trap to clean up those temp files at exit.\n    trap 'ret=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $ret' 0\n\n    # Copy the file name to the temp name.\n    (umask $cp_umask &&\n     { test -z \"$stripcmd\" || {\n\t # Create $dsttmp read-write so that cp doesn't create it read-only,\n\t # which would cause strip to fail.\n\t if test -z \"$doit\"; then\n\t   : >\"$dsttmp\" # No need to fork-exec 'touch'.\n\t else\n\t   $doit touch \"$dsttmp\"\n\t fi\n       }\n     } &&\n     $doit_exec $cpprog \"$src\" \"$dsttmp\") &&\n\n    # and set any options; do chmod last to preserve setuid bits.\n    #\n    # If any of these fail, we abort the whole thing.  If we want to\n    # ignore errors from any of these, just make sure not to ignore\n    # errors from the above \"$doit $cpprog $src $dsttmp\" command.\n    #\n    { test -z \"$chowncmd\" || $doit $chowncmd \"$dsttmp\"; } &&\n    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dsttmp\"; } &&\n    { test -z \"$stripcmd\" || $doit $stripcmd \"$dsttmp\"; } &&\n    { test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dsttmp\"; } &&\n\n    # If -C, don't bother to copy if it wouldn't change the file.\n    if $copy_on_change &&\n       old=`LC_ALL=C ls -dlL \"$dst\"     2>/dev/null` &&\n       new=`LC_ALL=C ls -dlL \"$dsttmp\"  2>/dev/null` &&\n       set -f &&\n       set X $old && old=:$2:$4:$5:$6 &&\n       set X $new && new=:$2:$4:$5:$6 &&\n       set +f &&\n       test \"$old\" = \"$new\" &&\n       $cmpprog \"$dst\" \"$dsttmp\" >/dev/null 2>&1\n    then\n      rm -f \"$dsttmp\"\n    else\n      # If $backupsuffix is set, and the file being installed\n      # already exists, attempt a backup.  Don't worry if it fails,\n      # e.g., if mv doesn't support -f.\n      if test -n \"$backupsuffix\" && test -f \"$dst\"; then\n        $doit $mvcmd -f \"$dst\" \"$dst$backupsuffix\" 2>/dev/null\n      fi\n\n      # Rename the file to the real destination.\n      $doit $mvcmd -f \"$dsttmp\" \"$dst\" 2>/dev/null ||\n\n      # The rename failed, perhaps because mv can't rename something else\n      # to itself, or perhaps because mv is so ancient that it does not\n      # support -f.\n      {\n        # Now remove or move aside any old file at destination location.\n        # We try this two ways since rm can't unlink itself on some\n        # systems and the destination file might be busy for other\n        # reasons.  In this case, the final cleanup might fail but the new\n        # file should still install successfully.\n        {\n          test ! -f \"$dst\" ||\n          $doit $rmcmd \"$dst\" 2>/dev/null ||\n          { $doit $mvcmd -f \"$dst\" \"$rmtmp\" 2>/dev/null &&\n            { $doit $rmcmd \"$rmtmp\" 2>/dev/null; :; }\n          } ||\n          { echo \"$0: cannot unlink or rename $dst\" >&2\n            (exit 1); exit 1\n          }\n        } &&\n\n        # Now rename the file to the real destination.\n        $doit $mvcmd \"$dsttmp\" \"$dst\"\n      }\n    fi || exit 1\n\n    trap '' 0\n  fi\ndone\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"scriptversion=\"\n# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n# time-stamp-time-zone: \"UTC0\"\n# time-stamp-end: \"; # UTC\"\n# End:\n"
        },
        {
          "name": "instrument-functions.c",
          "type": "blob",
          "size": 6.5048828125,
          "content": "/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code\n * distributions retain the above copyright notice and this paragraph\n * in its entirety, and (2) distributions including binary code include\n * the above copyright notice and this paragraph in its entirety in\n * the documentation or other materials provided with the distribution.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND\n * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <bfd.h>\n\n/*\n * Generate instrumentation calls for entry and exit to functions.\n * Just after function entry and just before function exit, the\n * following profiling functions are called with the address of the\n * current function and its call site (currently not use).\n *\n * The attribute 'no_instrument_function' causes this instrumentation is\n * not done.\n *\n * These profiling functions call print_debug(). This function prints the\n * current function name with indentation and call level.\n * If entering in a function it prints also the calling function name with\n * file name and line number.\n *\n * If the environment variable INSTRUMENT is\n * unset or set to an empty string, print nothing, like with no instrumentation\n * set to \"all\" or \"a\", print all the functions names\n * set to \"global\" or \"g\", print only the global functions names\n */\n\n#define ND_NO_INSTRUMENT __attribute__((no_instrument_function))\n\n/* Store the function call level, used also in pretty_print_packet() */\nextern int profile_func_level;\nint profile_func_level = -1;\n\ntypedef enum {\n\tENTER,\n\tEXIT\n} action_type;\n\nvoid __cyg_profile_func_enter(void *this_fn, void *call_site) ND_NO_INSTRUMENT;\n\nvoid __cyg_profile_func_exit(void *this_fn, void *call_site) ND_NO_INSTRUMENT;\n\nstatic void print_debug(void *this_fn, void *call_site, action_type action)\n\tND_NO_INSTRUMENT;\n\nvoid\n__cyg_profile_func_enter(void *this_fn, void *call_site)\n{\n\tprint_debug(this_fn, call_site, ENTER);\n}\n\nvoid\n__cyg_profile_func_exit(void *this_fn, void *call_site)\n{\n\tprint_debug(this_fn, call_site, EXIT);\n}\n\nstatic void print_debug(void *this_fn, void *call_site, action_type action)\n{\n\tstatic bfd* abfd;\n\tstatic asymbol **symtab;\n\tstatic long symcount;\n\tstatic asection *text;\n\tstatic bfd_vma vma;\n\tstatic int instrument_set;\n\tstatic int instrument_off;\n\tstatic int instrument_global;\n\n\tif (!instrument_set) {\n\t\tstatic char *instrument_type;\n\n\t\t/* Get the configuration environment variable INSTRUMENT value if any */\n\t\tinstrument_type = getenv(\"INSTRUMENT\");\n\t\t/* unset or set to an empty string ? */\n\t\tif (instrument_type == NULL ||\n\t\t\t!strncmp(instrument_type, \"\", sizeof(\"\"))) {\n\t\t\tinstrument_off = 1;\n\t\t} else {\n\t\t\t/* set to \"global\" or \"g\" ? */\n\t\t\tif (!strncmp(instrument_type, \"global\", sizeof(\"global\")) ||\n\t\t\t\t!strncmp(instrument_type, \"g\", sizeof(\"g\")))\n\t\t\t\tinstrument_global = 1;\n\t\t\telse if (strncmp(instrument_type, \"all\", sizeof(\"all\")) &&\n\t\t\t\t\t strncmp(instrument_type, \"a\", sizeof(\"a\"))) {\n\t\t\t\tfprintf(stderr, \"INSTRUMENT can be only \\\"\\\", \\\"all\\\", \\\"a\\\", \"\n\t\t\t\t\t\t\"\\\"global\\\" or \\\"g\\\".\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tinstrument_set = 1;\n\t}\n\n\tif (instrument_off)\n\t\t\treturn;\n\n\t/* If no errors, this block should be executed one time */\n\tif (!abfd) {\n\t\tchar pgm_name[1024];\n\t\tlong symsize;\n\n\t\tssize_t ret = readlink(\"/proc/self/exe\", pgm_name, sizeof(pgm_name));\n\t\tif (ret == -1) {\n\t\t\tperror(\"failed to find executable\");\n\t\t\treturn;\n\t\t}\n\t\tif (ret == sizeof(pgm_name)) {\n\t\t\t/* no space for the '\\0' */\n\t\t\tprintf(\"truncation may have occurred\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpgm_name[ret] = '\\0';\n\n\t\tbfd_init();\n\n\t\tabfd = bfd_openr(pgm_name, NULL);\n\t\tif (!abfd) {\n\t\t\tbfd_perror(\"bfd_openr\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!bfd_check_format(abfd, bfd_object)) {\n\t\t\tbfd_perror(\"bfd_check_format\");\n\t\t\treturn;\n\t\t}\n\n\t\tif((symsize = bfd_get_symtab_upper_bound(abfd)) == -1) {\n\t\t\tbfd_perror(\"bfd_get_symtab_upper_bound\");\n\t\t\treturn;\n\t\t}\n\n\t\tsymtab = (asymbol **)malloc((size_t)symsize);\n\t\tsymcount = bfd_canonicalize_symtab(abfd, symtab);\n\t\tif (symcount < 0) {\n\t\t\tfree(symtab);\n\t\t\tbfd_perror(\"bfd_canonicalize_symtab\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((text = bfd_get_section_by_name(abfd, \".text\")) == NULL) {\n\t\t\tbfd_perror(\"bfd_get_section_by_name\");\n\t\t\treturn;\n\t\t}\n\t\tvma = text->vma;\n\t}\n\n\tif (instrument_global) {\n\t\tsymbol_info syminfo;\n\t\tint found;\n\t\tlong i;\n\n\t\ti = 0;\n\t\tfound = 0;\n\t\twhile (i < symcount && !found) {\n\t\t\tbfd_get_symbol_info(abfd, symtab[i], &syminfo);\n\t\t\tif ((void *)syminfo.value == this_fn) {\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\t/* type == 'T' for a global function */\n\t\tif (found == 1 && syminfo.type != 'T')\n\t\t\treturn;\n\t}\n\n\t/* Current function */\n\tif ((bfd_vma)this_fn < vma) {\n\t\tprintf(\"[ERROR address this_fn]\");\n\t} else {\n\t\tconst char *file;\n\t\tconst char *func;\n\t\tunsigned int line;\n\n\t\tif (!bfd_find_nearest_line(abfd, text, symtab, (bfd_vma)this_fn - vma,\n\t\t\t\t\t\t\t\t   &file, &func, &line)) {\n\t\t\tprintf(\"[ERROR bfd_find_nearest_line this_fn]\");\n\t\t} else {\n\t\t\tint i;\n\n\t\t\tif (action == ENTER)\n\t\t\t\tprofile_func_level += 1;\n\t\t\t/* Indentation */\n\t\t\tfor (i = 0 ; i < profile_func_level ; i++)\n\t\t\t\tputchar(' ');\n\t\t\tif (action == ENTER)\n\t\t\t\tprintf(\"[>> \");\n\t\t\telse\n\t\t\t\tprintf(\"[<< \");\n\t\t\t/* Function name */\n\t\t\tif (func == NULL || *func == '\\0')\n\t\t\t\tprintf(\"???\");\n\t\t\telse\n\t\t\t\tprintf(\"%s\", func);\n\t\t\tprintf(\" (%d)\", profile_func_level);\n\t\t\t/* Print the \"from\" part except for the main function) */\n\t\t\tif (action == ENTER && func != NULL &&\n\t\t\t\tstrncmp(func, \"main\", sizeof(\"main\"))) {\n\t\t\t\t/* Calling function */\n\t\t\t\tif ((bfd_vma)call_site < vma) {\n\t\t\t\t\tprintf(\"[ERROR address call_site]\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!bfd_find_nearest_line(abfd, text, symtab,\n\t\t\t\t\t\t\t\t\t\t\t   (bfd_vma)call_site - vma, &file,\n\t\t\t\t\t\t\t\t\t\t\t   &func, &line)) {\n\t\t\t\t\t\tprintf(\"[ERROR bfd_find_nearest_line call_site]\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\" from \");\n\t\t\t\t\t\t/* Function name */\n\t\t\t\t\t\tif (func == NULL || *func == '\\0')\n\t\t\t\t\t\t\tprintf(\"???\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"%s\", func);\n\t\t\t\t\t\t/* File name */\n\t\t\t\t\t\tif (file == NULL || *file == '\\0')\n\t\t\t\t\t\t\tprintf(\" ??:\");\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchar *slashp = strrchr(file, '/');\n\t\t\t\t\t\t\tif (slashp != NULL)\n\t\t\t\t\t\t\t\tfile = slashp + 1;\n\t\t\t\t\t\t\tprintf(\" %s:\", file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Line number */\n\t\t\t\t\t\tif (line == 0)\n\t\t\t\t\t\t\tprintf(\"?\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"%u\", line);\n\t\t\t\t\t\tprintf(\"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t\tif (action == EXIT)\n\t\t\t\tprofile_func_level -= 1;\n\t\t}\n\t}\n\tfflush(stdout);\n}\n\n/* vi: set tabstop=4 softtabstop=0 shiftwidth=4 smarttab autoindent : */\n"
        },
        {
          "name": "libpcap.pc.in",
          "type": "blob",
          "size": 0.5244140625,
          "content": "#\n# pkg-config file for libpcap.\n#\n# These variables come from the configure script, so includedir and\n# libdir may be defined in terms of prefix and exec_prefix, so the\n# latter must be defined as well.\n#\nprefix=\"@prefix@\"\nexec_prefix=\"@exec_prefix@\"\nincludedir=\"@includedir@\"\nlibdir=\"@libdir@\"\n\nName: libpcap\nDescription: Platform-independent network traffic capture library\nVersion: @PACKAGE_VERSION@\nRequires.private: @REQUIRES_PRIVATE@\nLibs: -L${libdir} @RPATH@ -l@PACKAGE_NAME@\nLibs.private: @LIBS_PRIVATE@\nCflags: -I${includedir}\n"
        },
        {
          "name": "llc.h",
          "type": "blob",
          "size": 2.560546875,
          "content": "/*\n * Copyright (c) 1993, 1994, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/*\n * Definitions for information in the LLC header.\n */\n\n#define\tLLC_U_FMT\t3\n#define\tLLC_GSAP\t1\n#define\tLLC_IG\t        1 /* Individual / Group */\n#define LLC_S_FMT\t1\n\n#define\tLLC_U_POLL\t0x10\n#define\tLLC_IS_POLL\t0x0100\n#define\tLLC_XID_FI\t0x81\n\n#define LLC_U_CMD_MASK\t0xef\n#define\tLLC_UI\t\t0x03\n#define\tLLC_UA\t\t0x63\n#define\tLLC_DISC\t0x43\n#define\tLLC_DM\t\t0x0f\n#define\tLLC_SABME\t0x6f\n#define\tLLC_TEST\t0xe3\n#define\tLLC_XID\t\t0xaf\n#define\tLLC_FRMR\t0x87\n\n#define LLC_S_CMD_MASK\t0x0f\n#define\tLLC_RR\t\t0x0001\n#define\tLLC_RNR\t\t0x0005\n#define\tLLC_REJ\t\t0x0009\n\n#define LLC_IS_NR(is)\t(((is) >> 9) & 0x7f)\n#define LLC_I_NS(is)\t(((is) >> 1) & 0x7f)\n\n/*\n * 802.2 LLC SAP values.\n */\n\n#ifndef LLCSAP_NULL\n#define\tLLCSAP_NULL\t\t0x00\n#endif\n#ifndef LLCSAP_GLOBAL\n#define\tLLCSAP_GLOBAL\t\t0xff\n#endif\n#ifndef LLCSAP_8021B_I\n#define\tLLCSAP_8021B_I\t\t0x02\n#endif\n#ifndef LLCSAP_8021B_G\n#define\tLLCSAP_8021B_G\t\t0x03\n#endif\n#ifndef LLCSAP_IP\n#define\tLLCSAP_IP\t\t0x06\n#endif\n#ifndef LLCSAP_PROWAYNM\n#define\tLLCSAP_PROWAYNM\t\t0x0e\n#endif\n#ifndef LLCSAP_8021D\n#define\tLLCSAP_8021D\t\t0x42\n#endif\n#ifndef LLCSAP_RS511\n#define\tLLCSAP_RS511\t\t0x4e\n#endif\n#ifndef LLCSAP_ISO8208\n#define\tLLCSAP_ISO8208\t\t0x7e\n#endif\n#ifndef LLCSAP_PROWAY\n#define\tLLCSAP_PROWAY\t\t0x8e\n#endif\n#ifndef LLCSAP_SNAP\n#define\tLLCSAP_SNAP\t\t0xaa\n#endif\n#ifndef LLCSAP_IPX\n#define LLCSAP_IPX\t\t0xe0\n#endif\n#ifndef LLCSAP_NETBEUI\n#define LLCSAP_NETBEUI\t\t0xf0\n#endif\n#ifndef LLCSAP_ISONS\n#define\tLLCSAP_ISONS\t\t0xfe\n#endif\n"
        },
        {
          "name": "missing",
          "type": "tree",
          "content": null
        },
        {
          "name": "mkdep",
          "type": "blob",
          "size": 2.923828125,
          "content": "#!/bin/sh -e\n#\n# Copyright (c) 1994, 1996\n#\tThe Regents of the University of California.  All rights reserved.\n#\n# Redistribution and use in source and binary forms are permitted\n# provided that this notice is preserved and that due credit is given\n# to the University of California at Berkeley. The name of the University\n# may not be used to endorse or promote products derived from this\n# software without specific prior written permission. This software\n# is provided ``as is'' without express or implied warranty.\n#\n#\t@(#)mkdep.sh\t5.11 (Berkeley) 5/5/88\n#\n\nMAKE=Makefile\t\t\t# default makefile name is \"Makefile\"\nCC=cc\t\t\t\t# default C compiler is \"cc\"\nDEPENDENCY_CFLAG=-M\t\t# default dependency-generation flag is -M\nSOURCE_DIRECTORY=.\t\t# default source directory is the current directory\n\n# No command-line flags seen yet.\nflags=\"\"\nwhile :\n\tdo case \"$1\" in\n\t\t# -c allows you to specify the C compiler\n\t\t-c)\n\t\t\tCC=$2\n\t\t\tshift; shift ;;\n\n\t\t# -f allows you to select a makefile name\n\t\t-f)\n\t\t\tMAKE=$2\n\t\t\tshift; shift ;;\n\n\t\t# -m allows you to specify the dependency-generation flag\n\t\t-m)\n\t\t\tDEPENDENCY_CFLAG=$2\n\t\t\tshift; shift ;;\n\n\t\t# the -p flag produces \"program: program.c\" style dependencies\n\t\t# so .o's don't get produced\n\t\t-p)\n\t\t\tSED='s;\\.o;;'\n\t\t\tshift ;;\n\n\t\t# -s allows you to specify the source directory\n\t\t-s)\n\t\t\tSOURCE_DIRECTORY=$2\n\t\t\tshift; shift ;;\n\n\t\t# -include takes an argument\n\t\t-include)\n\t\t\tflags=\"$flags $1 $2\"\n\t\t\tshift; shift ;;\n\n\t\t# other command-line flag\n\t\t-*)\n\t\t\tflags=\"$flags $1\"\n\t\t\tshift ;;\n\n\t\t*)\n\t\t\tbreak ;;\n\tesac\ndone\n\nif [ $# = 0 ] ; then\n\techo 'usage: mkdep [-p] [-c cc] [-f makefile] [-m dependency-cflag] [-s source-directory] [flags] file ...'\n\texit 1\nfi\n\nif [ ! -w \"$MAKE\" ]; then\n\techo \"mkdep: no writeable file \\\"$MAKE\\\"\"\n\texit 1\nfi\n\nTMP=${TMPDIR:-/tmp}/mkdep$$\n\ntrap 'rm -f \"$TMP\" ; exit 1' HUP INT QUIT PIPE TERM\n\ncp \"$MAKE\" \"${MAKE}.bak\"\n\nsed -e '/DO NOT DELETE THIS LINE/,$d' < \"$MAKE\" > \"$TMP\"\n\ncat << _EOF_ >> \"$TMP\"\n# DO NOT DELETE THIS LINE -- mkdep uses it.\n# DO NOT PUT ANYTHING AFTER THIS LINE, IT WILL GO AWAY.\n\n_EOF_\n\n# If your compiler doesn't have -M, add it.  If you can't, the next two\n# lines will try and replace the \"cc -M\".  The real problem is that this\n# hack can't deal with anything that requires a search path, and doesn't\n# even try for anything using bracket (<>) syntax.\n#\n# grep -E '^#include[[:blank:]]*\".*\"' /dev/null $* |\n# sed -e 's/:[^\"]*\"\\([^\"]*\\)\".*/: \\1/' -e 's/\\.c/.o/' |\n\n#\n# Construct a list of source files with paths relative to the source directory.\n#\nsources=\"\"\nfor srcfile in \"$@\"\ndo\n\tsources=\"$sources $SOURCE_DIRECTORY/$srcfile\"\ndone\n\n# XXX this doesn't work with things like \"-DDECLWAITSTATUS=union\\ wait\"\n# $flags and $sources are meant to expand\n# shellcheck disable=SC2086\n\"$CC\" \"$DEPENDENCY_CFLAG\" $flags $sources |\nsed \"\n\ts; \\./; ;g\n\t$SED\" >> \"$TMP\"\n\ncat << _EOF_ >> \"$TMP\"\n\n# IF YOU PUT ANYTHING HERE IT WILL GO AWAY\n_EOF_\n\n# copy to preserve permissions\ncp \"$TMP\" \"$MAKE\"\nrm -f \"${MAKE}.bak\" \"$TMP\"\nexit 0\n"
        },
        {
          "name": "nametoaddr.c",
          "type": "blob",
          "size": 19.0029296875,
          "content": "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Name to id translation routines used by the scanner.\n * These functions are not time critical.\n */\n\n#include <config.h>\n\n#ifdef _WIN32\n  #include <winsock2.h>\n  #include <ws2tcpip.h>\n#else /* _WIN32 */\n  #include <sys/param.h>\n  #include <sys/types.h>\n  #include <sys/socket.h>\n  #include <sys/time.h>\n\n  #include <netinet/in.h>\n\n  #ifdef HAVE_ETHER_HOSTTON\n    #if defined(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n      /*\n       * OK, just include <net/ethernet.h>.\n       */\n      #include <net/ethernet.h>\n    #elif defined(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)\n      /*\n       * OK, just include <netinet/ether.h>\n       */\n      #include <netinet/ether.h>\n    #elif defined(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)\n      /*\n       * OK, just include <sys/ethernet.h>\n       */\n      #include <sys/ethernet.h>\n    #elif defined(ARPA_INET_H_DECLARES_ETHER_HOSTTON)\n      /*\n       * OK, just include <arpa/inet.h>\n       */\n      #include <arpa/inet.h>\n    #elif defined(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)\n      /*\n       * OK, include <netinet/if_ether.h>, after all the other stuff we\n       * need to include or define for its benefit.\n       */\n      #define NEED_NETINET_IF_ETHER_H\n    #else\n      /*\n       * We'll have to declare it ourselves.\n       * If <netinet/if_ether.h> defines struct ether_addr, include\n       * it.  Otherwise, define it ourselves.\n       */\n      #ifdef HAVE_STRUCT_ETHER_ADDR\n        #define NEED_NETINET_IF_ETHER_H\n      #else /* HAVE_STRUCT_ETHER_ADDR */\n\tstruct ether_addr {\n\t\tunsigned char ether_addr_octet[6];\n\t};\n      #endif /* HAVE_STRUCT_ETHER_ADDR */\n    #endif /* what declares ether_hostton() */\n\n    #ifdef NEED_NETINET_IF_ETHER_H\n      #include <net/if.h>\t/* Needed on some platforms */\n      #include <netinet/in.h>\t/* Needed on some platforms */\n      #include <netinet/if_ether.h>\n    #endif /* NEED_NETINET_IF_ETHER_H */\n\n    #ifndef HAVE_DECL_ETHER_HOSTTON\n      /*\n       * No header declares it, so declare it ourselves.\n       */\n      extern int ether_hostton(const char *, struct ether_addr *);\n    #endif /* !defined(HAVE_DECL_ETHER_HOSTTON) */\n  #endif /* HAVE_ETHER_HOSTTON */\n\n  #include <arpa/inet.h>\n  #include <netdb.h>\n#endif /* _WIN32 */\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"pcap-int.h\"\n\n#include \"diag-control.h\"\n\n#include \"gencode.h\"\n#include <pcap/namedb.h>\n#include \"nametoaddr.h\"\n\n#include \"thread-local.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#ifndef NTOHL\n#define NTOHL(x) (x) = ntohl(x)\n#define NTOHS(x) (x) = ntohs(x)\n#endif\n\n/*\n *  Convert host name to internet address.\n *  Return 0 upon failure.\n *  XXX - not thread-safe; don't use it inside libpcap.\n */\nbpf_u_int32 **\npcap_nametoaddr(const char *name)\n{\n#ifndef h_addr\n\tstatic bpf_u_int32 *hlist[2];\n#endif\n\tbpf_u_int32 **p;\n\tstruct hostent *hp;\n\n\t/*\n\t * gethostbyname() is deprecated on Windows, perhaps because\n\t * it's not thread-safe, or because it doesn't support IPv6,\n\t * or both.\n\t *\n\t * We deprecate pcap_nametoaddr() on all platforms because\n\t * it's not thread-safe; we supply it for backwards compatibility,\n\t * so suppress the deprecation warning.  We could, I guess,\n\t * use getaddrinfo() and construct the array ourselves, but\n\t * that's probably not worth the effort, as that wouldn't make\n\t * this thread-safe - we can't change the API to require that\n\t * our caller free the address array, so we still have to reuse\n\t * a local array.\n\t */\nDIAG_OFF_DEPRECATION\n\tif ((hp = gethostbyname(name)) != NULL) {\nDIAG_ON_DEPRECATION\n#ifndef h_addr\n\t\thlist[0] = (bpf_u_int32 *)hp->h_addr;\n\t\tNTOHL(hp->h_addr);\n\t\treturn hlist;\n#else\n\t\tfor (p = (bpf_u_int32 **)hp->h_addr_list; *p; ++p)\n\t\t\tNTOHL(**p);\n\t\treturn (bpf_u_int32 **)hp->h_addr_list;\n#endif\n\t}\n\telse\n\t\treturn 0;\n}\n\nstruct addrinfo *\npcap_nametoaddrinfo(const char *name)\n{\n\tstruct addrinfo hints, *res;\n\tint error;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\t/*not really*/\n\thints.ai_protocol = IPPROTO_TCP;\t/*not really*/\n\terror = getaddrinfo(name, NULL, &hints, &res);\n\tif (error)\n\t\treturn NULL;\n\telse\n\t\treturn res;\n}\n\n/*\n *  Convert net name to internet address.\n *  Return 0 upon failure.\n *  XXX - not guaranteed to be thread-safe!  See below for platforms\n *  on which it is thread-safe and on which it isn't.\n */\n#if defined(_WIN32) || defined(__CYGWIN__)\nbpf_u_int32\npcap_nametonetaddr(const char *name _U_)\n{\n\t/*\n\t * There's no \"getnetbyname()\" on Windows.\n\t *\n\t * XXX - I guess we could use the BSD code to read\n\t * C:\\Windows\\System32\\drivers\\etc/networks, assuming\n\t * that's its home on all the versions of Windows\n\t * we use, but that file probably just has the loopback\n\t * network on 127/24 on 99 44/100% of Windows machines.\n\t *\n\t * (Heck, these days it probably just has that on 99 44/100%\n\t * of *UN*X* machines.)\n\t */\n\treturn 0;\n}\n#else /* _WIN32 */\nbpf_u_int32\npcap_nametonetaddr(const char *name)\n{\n\t/*\n\t * UN*X.\n\t */\n\tstruct netent *np;\n  #if defined(HAVE_LINUX_GETNETBYNAME_R)\n\t/*\n\t * We have Linux's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\tint h_errnoval;\n\tint err;\n\n\t/*\n\t * Apparently, the man page at\n\t *\n\t *    http://man7.org/linux/man-pages/man3/getnetbyname_r.3.html\n\t *\n\t * lies when it says\n\t *\n\t *    If the function call successfully obtains a network record,\n\t *    then *result is set pointing to result_buf; otherwise, *result\n\t *    is set to NULL.\n\t *\n\t * and, in fact, at least in some versions of GNU libc, it does\n\t * *not* always get set if getnetbyname_r() succeeds.\n\t */\n\tnp = NULL;\n\terr = getnetbyname_r(name, &result_buf, buf, sizeof buf, &np,\n\t    &h_errnoval);\n\tif (err != 0) {\n\t\t/*\n\t\t * XXX - dynamically allocate the buffer, and make it\n\t\t * bigger if we get ERANGE back?\n\t\t */\n\t\treturn 0;\n\t}\n  #elif defined(HAVE_SOLARIS_GETNETBYNAME_R)\n\t/*\n\t * We have Solaris's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\n\tnp = getnetbyname_r(name, &result_buf, buf, (int)sizeof buf);\n  #elif defined(HAVE_AIX_GETNETBYNAME_R)\n\t/*\n\t * We have AIX's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tstruct netent_data net_data;\n\n\tif (getnetbyname_r(name, &result_buf, &net_data) == -1)\n\t\tnp = NULL;\n\telse\n\t\tnp = &result_buf;\n  #else\n\t/*\n\t * We don't have any getnetbyname_r(); either we have a\n\t * getnetbyname() that uses thread-specific data, in which\n\t * case we're thread-safe (sufficiently recent FreeBSD,\n\t * sufficiently recent Darwin-based OS, sufficiently recent\n\t * HP-UX, or we have the\n\t * traditional getnetbyname() (everything else, including\n\t * current NetBSD and OpenBSD), in which case we're not\n\t * thread-safe.\n\t */\n\tnp = getnetbyname(name);\n  #endif\n\tif (np != NULL)\n\t\treturn np->n_net;\n\telse\n\t\treturn 0;\n}\n#endif /* _WIN32 */\n\n/*\n * Convert a port name to its port and protocol numbers.\n * We assume only TCP or UDP.\n * Return 0 upon failure.\n */\nint\npcap_nametoport(const char *name, int *port, int *proto)\n{\n\tstruct addrinfo hints, *res, *ai;\n\tint error;\n\tstruct sockaddr_in *in4;\n#ifdef INET6\n\tstruct sockaddr_in6 *in6;\n#endif\n\tint tcp_port = -1;\n\tint udp_port = -1;\n\n\t/*\n\t * We check for both TCP and UDP in case there are\n\t * ambiguous entries.\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\terror = getaddrinfo(NULL, name, &hints, &res);\n\tif (error != 0) {\n\t\tif (error != EAI_NONAME &&\n\t\t    error != EAI_SERVICE) {\n\t\t\t/*\n\t\t\t * This is a real error, not just \"there's\n\t\t\t * no such service name\".\n\t\t\t * XXX - this doesn't return an error string.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * OK, we found it.  Did it find anything?\n\t\t */\n\t\tfor (ai = res; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Get a port number; we're done.\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\ttcp_port = ntohs(in4->sin_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef INET6\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET6) {\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\t\t\ttcp_port = ntohs(in6->sin6_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(res);\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_protocol = IPPROTO_UDP;\n\terror = getaddrinfo(NULL, name, &hints, &res);\n\tif (error != 0) {\n\t\tif (error != EAI_NONAME &&\n\t\t    error != EAI_SERVICE) {\n\t\t\t/*\n\t\t\t * This is a real error, not just \"there's\n\t\t\t * no such service name\".\n\t\t\t * XXX - this doesn't return an error string.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * OK, we found it.  Did it find anything?\n\t\t */\n\t\tfor (ai = res; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Get a port number; we're done.\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\tudp_port = ntohs(in4->sin_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef INET6\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET6) {\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\t\t\tudp_port = ntohs(in6->sin6_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(res);\n\t}\n\n\t/*\n\t * We need to check /etc/services for ambiguous entries.\n\t * If we find an ambiguous entry, and it has the\n\t * same port number, change the proto to PROTO_UNDEF\n\t * so both TCP and UDP will be checked.\n\t */\n\tif (tcp_port >= 0) {\n\t\t*port = tcp_port;\n\t\t*proto = IPPROTO_TCP;\n\t\tif (udp_port >= 0) {\n\t\t\tif (udp_port == tcp_port)\n\t\t\t\t*proto = PROTO_UNDEF;\n#ifdef notdef\n\t\t\telse\n\t\t\t\t/* Can't handle ambiguous names that refer\n\t\t\t\t   to different port numbers. */\n\t\t\t\twarning(\"ambiguous port %s in /etc/services\",\n\t\t\t\t\tname);\n#endif\n\t\t}\n\t\treturn 1;\n\t}\n\tif (udp_port >= 0) {\n\t\t*port = udp_port;\n\t\t*proto = IPPROTO_UDP;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Convert a string in the form PPP-PPP, where correspond to ports, to\n * a starting and ending port in a port range.\n * Return 0 on failure.\n */\nint\npcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)\n{\n\tchar *off, *cpy;\n\tint save_proto;\n\n\tif ((cpy = strdup(name)) == NULL)\n\t\treturn 0;\n\n\tif ((off = strchr(cpy, '-')) == NULL) {\n\t\tfree(cpy);\n\t\treturn 0;\n\t}\n\n\t*off = '\\0';\n\n\tif (pcap_nametoport(cpy, port1, proto) == 0) {\n\t\tfree(cpy);\n\t\treturn 0;\n\t}\n\tsave_proto = *proto;\n\n\tif (pcap_nametoport(off + 1, port2, proto) == 0) {\n\t\tfree(cpy);\n\t\treturn 0;\n\t}\n\tfree(cpy);\n\n\tif (*proto != save_proto)\n\t\t*proto = PROTO_UNDEF;\n\n\treturn 1;\n}\n\n/*\n * XXX - not guaranteed to be thread-safe!  See below for platforms\n * on which it is thread-safe and on which it isn't.\n */\nint\npcap_nametoproto(const char *str)\n{\n\tstruct protoent *p;\n  #if defined(HAVE_LINUX_GETPROTOBYNAME_R)\n\t/*\n\t * We have Linux's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\tint err;\n\n\terr = getprotobyname_r(str, &result_buf, buf, sizeof buf, &p);\n\tif (err != 0) {\n\t\t/*\n\t\t * XXX - dynamically allocate the buffer, and make it\n\t\t * bigger if we get ERANGE back?\n\t\t */\n\t\treturn 0;\n\t}\n  #elif defined(HAVE_SOLARIS_GETPROTOBYNAME_R)\n\t/*\n\t * We have Solaris's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\n\tp = getprotobyname_r(str, &result_buf, buf, (int)sizeof buf);\n  #elif defined(HAVE_AIX_GETPROTOBYNAME_R)\n\t/*\n\t * We have AIX's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\t// \"The structure must be zero-filled before it is used...\" (OpenBSD).\n\tstruct protoent_data proto_data = {0};\n\n\tif (getprotobyname_r(str, &result_buf, &proto_data) == -1)\n\t\tp = NULL;\n\telse\n\t\tp = &result_buf;\n  #else\n\t/*\n\t * We don't have any getprotobyname_r(); either we have a\n\t * getprotobyname() that uses thread-specific data, in which\n\t * case we're thread-safe (sufficiently recent FreeBSD,\n\t * sufficiently recent Darwin-based OS, sufficiently recent\n\t * HP-UX, Windows), or we have\n\t * the traditional getprotobyname() (everything else, including\n\t * current NetBSD and OpenBSD), in which case we're not\n\t * thread-safe.\n\t */\n\tp = getprotobyname(str);\n  #endif\n\tif (p != 0)\n\t\treturn p->p_proto;\n\telse\n\t\treturn PROTO_UNDEF;\n}\n\n#include \"ethertype.h\"\n\nstruct eproto {\n\tconst char *s;\n\tu_short p;\n};\n\n/*\n * Static data base of ether protocol types.\n * tcpdump used to import this, and it's declared as an export on\n * Debian, at least, so make it a public symbol, even though we\n * don't officially export it by declaring it in a header file.\n * (Programs *should* do this themselves, as tcpdump now does.)\n *\n * We declare it here, right before defining it, to squelch any\n * warnings we might get from compilers about the lack of a\n * declaration.\n */\nPCAP_API struct eproto eproto_db[];\nPCAP_API_DEF struct eproto eproto_db[] = {\n\t{ \"aarp\", ETHERTYPE_AARP },\n\t{ \"arp\", ETHERTYPE_ARP },\n\t{ \"atalk\", ETHERTYPE_ATALK },\n\t{ \"decnet\", ETHERTYPE_DN },\n\t{ \"ip\", ETHERTYPE_IP },\n#ifdef INET6\n\t{ \"ip6\", ETHERTYPE_IPV6 },\n#endif\n\t{ \"lat\", ETHERTYPE_LAT },\n\t{ \"loopback\", ETHERTYPE_LOOPBACK },\n\t{ \"mopdl\", ETHERTYPE_MOPDL },\n\t{ \"moprc\", ETHERTYPE_MOPRC },\n\t{ \"rarp\", ETHERTYPE_REVARP },\n\t{ \"sca\", ETHERTYPE_SCA },\n\t{ (char *)0, 0 }\n};\n\nint\npcap_nametoeproto(const char *s)\n{\n\tstruct eproto *p = eproto_db;\n\n\twhile (p->s != 0) {\n\t\tif (strcmp(p->s, s) == 0)\n\t\t\treturn p->p;\n\t\tp += 1;\n\t}\n\treturn PROTO_UNDEF;\n}\n\n#include \"llc.h\"\n\n/* Static data base of LLC values. */\nstatic struct eproto llc_db[] = {\n\t{ \"iso\", LLCSAP_ISONS },\n\t{ \"stp\", LLCSAP_8021D },\n\t{ \"ipx\", LLCSAP_IPX },\n\t{ \"netbeui\", LLCSAP_NETBEUI },\n\t{ (char *)0, 0 }\n};\n\nint\npcap_nametollc(const char *s)\n{\n\tstruct eproto *p = llc_db;\n\n\twhile (p->s != 0) {\n\t\tif (strcmp(p->s, s) == 0)\n\t\t\treturn p->p;\n\t\tp += 1;\n\t}\n\treturn PROTO_UNDEF;\n}\n\n/* Hex digit to 8-bit unsigned integer. */\nstatic inline u_char\nxdtoi(u_char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn (u_char)(c - '0');\n\telse if (c >= 'a' && c <= 'f')\n\t\treturn (u_char)(c - 'a' + 10);\n\telse\n\t\treturn (u_char)(c - 'A' + 10);\n}\n\nint\n__pcap_atoin(const char *s, bpf_u_int32 *addr)\n{\n\tu_int n;\n\tint len;\n\n\t*addr = 0;\n\tlen = 0;\n\tfor (;;) {\n\t\tn = 0;\n\t\twhile (*s && *s != '.') {\n\t\t\tif (n > 25) {\n\t\t\t\t/* The result will be > 255 */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = n * 10 + *s++ - '0';\n\t\t}\n\t\tif (n > 255)\n\t\t\treturn -1;\n\t\t*addr <<= 8;\n\t\t*addr |= n & 0xff;\n\t\tlen += 8;\n\t\tif (*s == '\\0')\n\t\t\treturn len;\n\t\t++s;\n\t}\n\t/* NOTREACHED */\n}\n\n/*\n * If 's' is not a string that is a well-formed DECnet address (aa.nnnn),\n * return zero.  Otherwise parse the address into the low 16 bits of 'addr'\n * and return a non-zero.  The binary DECnet address consists of a 6-bit area\n * number and a 10-bit node number; neither area 0 nor node 0 are valid for\n * normal addressing purposes, but either can appear on the wire.\n */\nint\n__pcap_atodn(const char *s, bpf_u_int32 *addr)\n{\n#define AREASHIFT 10\n#define AREAMASK 0176000\n#define NODEMASK 01777\n\n\t/* Initialize to squelch a compiler warning only. */\n\tu_int node = 0, area = 0;\n\t/*\n\t *               +--+             +--+\n\t *               |  |             |  |\n\t *               v  |             v  |\n\t * --> START --> AREA --> DOT --> NODE -->\n\t *       |          |     |        |\n\t *       |          v     v        |\n\t *       +--------> INVALID <------+\n\t */\n\tenum {\n\t\tSTART,\n\t\tAREA,\n\t\tDOT,\n\t\tNODE,\n\t\tINVALID\n\t} fsm_state = START;\n\n\twhile (*s) {\n\t\tswitch (fsm_state) {\n\t\tcase START:\n\t\t\tif (PCAP_ISDIGIT(*s)) {\n\t\t\t\tarea = *s - '0';\n\t\t\t\tfsm_state = AREA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfsm_state = INVALID;\n\t\t\tbreak;\n\t\tcase AREA:\n\t\t\tif (*s == '.') {\n\t\t\t\tfsm_state = DOT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (PCAP_ISDIGIT(*s)) {\n\t\t\t\tarea = area * 10 + *s - '0';\n\t\t\t\tif (area <= AREAMASK >> AREASHIFT)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfsm_state = INVALID;\n\t\t\tbreak;\n\t\tcase DOT:\n\t\t\tif (PCAP_ISDIGIT(*s)) {\n\t\t\t\tnode = *s - '0';\n\t\t\t\tfsm_state = NODE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfsm_state = INVALID;\n\t\t\tbreak;\n\t\tcase NODE:\n\t\t\tif (PCAP_ISDIGIT(*s)) {\n\t\t\t\tnode = node * 10 + *s - '0';\n\t\t\t\tif (node <= NODEMASK)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfsm_state = INVALID;\n\t\t\tbreak;\n\t\tcase INVALID:\n\t\t\treturn 0;\n\t\t} /* switch */\n\t\ts++;\n\t} /* while */\n\t/*\n\t * This condition is false if the string comes from the lexer, but\n\t * let's not depend on that.\n\t */\n\tif (fsm_state != NODE)\n\t\treturn 0;\n\n\t*addr = area << AREASHIFT | node;\n\treturn(32);\n}\n\n/*\n * Convert 's', which can have the one of the forms:\n *\n *\t\"xx:xx:xx:xx:xx:xx\"\n *\t\"xx.xx.xx.xx.xx.xx\"\n *\t\"xx-xx-xx-xx-xx-xx\"\n *\t\"xxxx.xxxx.xxxx\"\n *\t\"xxxxxxxxxxxx\"\n *\n * (or various mixes of ':', '.', and '-') into a new\n * ethernet address.  Assumes 's' is well formed.\n */\nu_char *\npcap_ether_aton(const char *s)\n{\n\tregister u_char *ep, *e;\n\tregister u_char d;\n\n\te = ep = (u_char *)malloc(6);\n\tif (e == NULL)\n\t\treturn (NULL);\n\n\twhile (*s) {\n\t\tif (*s == ':' || *s == '.' || *s == '-')\n\t\t\ts += 1;\n\t\td = xdtoi(*s++);\n\t\tif (PCAP_ISXDIGIT(*s)) {\n\t\t\td <<= 4;\n\t\t\td |= xdtoi(*s++);\n\t\t}\n\t\t*ep++ = d;\n\t}\n\n\treturn (e);\n}\n\n#ifndef HAVE_ETHER_HOSTTON\n/*\n * Roll our own.\n *\n * This should be thread-safe, as we define the static variables\n * we use to be thread-local, and as pcap_next_etherent() does so\n * as well.\n */\nu_char *\npcap_ether_hostton(const char *name)\n{\n\tregister struct pcap_etherent *ep;\n\tregister u_char *ap;\n\tstatic thread_local FILE *fp = NULL;\n\tstatic thread_local int init = 0;\n\n\tif (!init) {\n\t\tfp = fopen(PCAP_ETHERS_FILE, \"r\");\n\t\t++init;\n\t\tif (fp == NULL)\n\t\t\treturn (NULL);\n\t} else if (fp == NULL)\n\t\treturn (NULL);\n\telse\n\t\trewind(fp);\n\n\twhile ((ep = pcap_next_etherent(fp)) != NULL) {\n\t\tif (strcmp(ep->name, name) == 0) {\n\t\t\tap = (u_char *)malloc(6);\n\t\t\tif (ap != NULL) {\n\t\t\t\tmemcpy(ap, ep->addr, 6);\n\t\t\t\treturn (ap);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (NULL);\n}\n#else\n/*\n * Use the OS-supplied routine.\n * This *should* be thread-safe; the API doesn't have a static buffer.\n */\nu_char *\npcap_ether_hostton(const char *name)\n{\n\tregister u_char *ap;\n\tu_char a[6];\n\tchar namebuf[1024];\n\n\t/*\n\t * In AIX 7.1 and 7.2: int ether_hostton(char *, struct ether_addr *);\n\t */\n\tpcapint_strlcpy(namebuf, name, sizeof(namebuf));\n\tap = NULL;\n\tif (ether_hostton(namebuf, (struct ether_addr *)a) == 0) {\n\t\tap = (u_char *)malloc(6);\n\t\tif (ap != NULL)\n\t\t\tmemcpy((char *)ap, (char *)a, 6);\n\t}\n\treturn (ap);\n}\n#endif\n"
        },
        {
          "name": "nametoaddr.h",
          "type": "blob",
          "size": 2.0673828125,
          "content": "/*\n * Copyright (c) 1994, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Routines used for name-or-address-string-to-address resolution\n * that are *not* exported to code using libpcap.\n */\nint __pcap_atodn(const char *, bpf_u_int32 *);\nint __pcap_atoin(const char *, bpf_u_int32 *);\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "nomkdep",
          "type": "blob",
          "size": 0.1318359375,
          "content": "#!/bin/sh -\n#\n# Does nothing; used if we don't have a command-line flag to the compiler\n# to get it to generate dependencies.\n#\nexit 0\n"
        },
        {
          "name": "optimize.c",
          "type": "blob",
          "size": 74.2177734375,
          "content": "/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n *  Optimization module for BPF code intermediate representation.\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <setjmp.h>\n#include <string.h>\n#include <limits.h> /* for SIZE_MAX */\n#include <errno.h>\n\n#include \"pcap-int.h\"\n\n#include \"gencode.h\"\n#include \"optimize.h\"\n#include \"diag-control.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#ifdef BDEBUG\n/*\n * The internal \"debug printout\" flag for the filter expression optimizer.\n * The code to print that stuff is present only if BDEBUG is defined, so\n * the flag, and the routine to set it, are defined only if BDEBUG is\n * defined.\n */\nstatic int pcap_optimizer_debug;\n\n/*\n * Routine to set that flag.\n *\n * This is intended for libpcap developers, not for general use.\n * If you want to set these in a program, you'll have to declare this\n * routine yourself, with the appropriate DLL import attribute on Windows;\n * it's not declared in any header file, and won't be declared in any\n * header file provided by libpcap.\n */\nPCAP_API void pcap_set_optimizer_debug(int value);\n\nPCAP_API_DEF void\npcap_set_optimizer_debug(int value)\n{\n\tpcap_optimizer_debug = value;\n}\n\n/*\n * The internal \"print dot graph\" flag for the filter expression optimizer.\n * The code to print that stuff is present only if BDEBUG is defined, so\n * the flag, and the routine to set it, are defined only if BDEBUG is\n * defined.\n */\nstatic int pcap_print_dot_graph;\n\n/*\n * Routine to set that flag.\n *\n * This is intended for libpcap developers, not for general use.\n * If you want to set these in a program, you'll have to declare this\n * routine yourself, with the appropriate DLL import attribute on Windows;\n * it's not declared in any header file, and won't be declared in any\n * header file provided by libpcap.\n */\nPCAP_API void pcap_set_print_dot_graph(int value);\n\nPCAP_API_DEF void\npcap_set_print_dot_graph(int value)\n{\n\tpcap_print_dot_graph = value;\n}\n\n#endif\n\n/*\n * lowest_set_bit().\n *\n * Takes a 32-bit integer as an argument.\n *\n * If handed a non-zero value, returns the index of the lowest set bit,\n * counting upwards from zero.\n *\n * If handed zero, the results are platform- and compiler-dependent.\n * Keep it out of the light, don't give it any water, don't feed it\n * after midnight, and don't pass zero to it.\n *\n * This is the same as the count of trailing zeroes in the word.\n */\n#if PCAP_IS_AT_LEAST_GNUC_VERSION(3,4)\n  /*\n   * GCC 3.4 and later; we have __builtin_ctz().\n   */\n  #define lowest_set_bit(mask) ((u_int)__builtin_ctz(mask))\n#elif defined(_MSC_VER)\n  /*\n   * Visual Studio; we support only 2015 and later, so use\n   * _BitScanForward().\n   */\n#include <intrin.h>\n\n#ifndef __clang__\n#pragma intrinsic(_BitScanForward)\n#endif\n\nstatic __forceinline u_int\nlowest_set_bit(int mask)\n{\n\tunsigned long bit;\n\n\t/*\n\t * Don't sign-extend mask if long is longer than int.\n\t * (It's currently not, in MSVC, even on 64-bit platforms, but....)\n\t */\n\tif (_BitScanForward(&bit, (unsigned int)mask) == 0)\n\t\tabort();\t/* mask is zero */\n\treturn (u_int)bit;\n}\n#else\n  /*\n   * POSIX.1-2001 says ffs() is in <strings.h>.  Every supported non-Windows OS\n   * (including Linux with musl libc and uclibc-ng) has the header and (except\n   * HP-UX) declares the function there.  HP-UX declares the function in\n   * <string.h>, which has already been included.\n   */\n  #include <strings.h>\n  #define lowest_set_bit(mask)\t((u_int)(ffs((mask)) - 1))\n#endif\n\n/*\n * Represents a deleted instruction.\n */\n#define NOP -1\n\n/*\n * Register numbers for use-def values.\n * 0 through BPF_MEMWORDS-1 represent the corresponding scratch memory\n * location.  A_ATOM is the accumulator and X_ATOM is the index\n * register.\n */\n#define A_ATOM BPF_MEMWORDS\n#define X_ATOM (BPF_MEMWORDS+1)\n\n/*\n * This define is used to represent *both* the accumulator and\n * x register in use-def computations.\n * Currently, the use-def code assumes only one definition per instruction.\n */\n#define AX_ATOM N_ATOMS\n\n/*\n * These data structures are used in a Cocke and Schwartz style\n * value numbering scheme.  Since the flowgraph is acyclic,\n * exit values can be propagated from a node's predecessors\n * provided it is uniquely defined.\n */\nstruct valnode {\n\tint code;\n\tbpf_u_int32 v0, v1;\n\tint val;\t\t/* the value number */\n\tstruct valnode *next;\n};\n\n/* Integer constants mapped with the load immediate opcode. */\n#define K(i) F(opt_state, BPF_LD|BPF_IMM|BPF_W, i, 0U)\n\nstruct vmapinfo {\n\tint is_const;\n\tbpf_u_int32 const_val;\n};\n\ntypedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * A flag to indicate that further optimization is needed.\n\t * Iterative passes are continued until a given pass yields no\n\t * code simplification or branch movement.\n\t */\n\tint done;\n\n\t/*\n\t * XXX - detect loops that do nothing but repeated AND/OR pullups\n\t * and edge moves.\n\t * If 100 passes in a row do nothing but that, treat that as a\n\t * sign that we're in a loop that just shuffles in a cycle in\n\t * which each pass just shuffles the code and we eventually\n\t * get back to the original configuration.\n\t *\n\t * XXX - we need a non-heuristic way of detecting, or preventing,\n\t * such a cycle.\n\t */\n\tint non_branch_movement_performed;\n\n\tu_int n_blocks;\t\t/* number of blocks in the CFG; guaranteed to be > 0, as it's a RET instruction at a minimum */\n\tstruct block **blocks;\n\tu_int n_edges;\t\t/* twice n_blocks, so guaranteed to be > 0 */\n\tstruct edge **edges;\n\n\t/*\n\t * A bit vector set representation of the dominators.\n\t * We round up the set size to the next power of two.\n\t */\n\tu_int nodewords;\t/* number of 32-bit words for a bit vector of \"number of nodes\" bits; guaranteed to be > 0 */\n\tu_int edgewords;\t/* number of 32-bit words for a bit vector of \"number of edges\" bits; guaranteed to be > 0 */\n\tstruct block **levels;\n\tbpf_u_int32 *space;\n\n#define BITS_PER_WORD (8*sizeof(bpf_u_int32))\n/*\n * True if a is in uset {p}\n */\n#define SET_MEMBER(p, a) \\\n((p)[(unsigned)(a) / BITS_PER_WORD] & ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD)))\n\n/*\n * Add 'a' to uset p.\n */\n#define SET_INSERT(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] |= ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * Delete 'a' from uset p.\n */\n#define SET_DELETE(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] &= ~((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * a := a intersect b\n * n must be guaranteed to be > 0\n */\n#define SET_INTERSECT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister u_int _n = n;\\\n\tdo *_x++ &= *_y++; while (--_n != 0);\\\n}\n\n/*\n * a := a - b\n * n must be guaranteed to be > 0\n */\n#define SET_SUBTRACT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister u_int _n = n;\\\n\tdo *_x++ &=~ *_y++; while (--_n != 0);\\\n}\n\n/*\n * a := a union b\n * n must be guaranteed to be > 0\n */\n#define SET_UNION(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister u_int _n = n;\\\n\tdo *_x++ |= *_y++; while (--_n != 0);\\\n}\n\n\tuset all_dom_sets;\n\tuset all_closure_sets;\n\tuset all_edge_sets;\n\n#define MODULUS 213\n\tstruct valnode *hashtbl[MODULUS];\n\tbpf_u_int32 curval;\n\tbpf_u_int32 maxval;\n\n\tstruct vmapinfo *vmap;\n\tstruct valnode *vnode_base;\n\tstruct valnode *next_vnode;\n} opt_state_t;\n\ntypedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * Some pointers used to convert the basic block form of the code,\n\t * into the array form that BPF requires.  'fstart' will point to\n\t * the malloc'd array while 'ftail' is used during the recursive\n\t * traversal.\n\t */\n\tstruct bpf_insn *fstart;\n\tstruct bpf_insn *ftail;\n} conv_state_t;\n\nstatic void opt_init(opt_state_t *, struct icode *);\nstatic void opt_cleanup(opt_state_t *);\nstatic void PCAP_NORETURN opt_error(opt_state_t *, const char *, ...)\n    PCAP_PRINTFLIKE(2, 3);\n\nstatic void intern_blocks(opt_state_t *, struct icode *);\n\nstatic void find_inedges(opt_state_t *, struct block *);\n#ifdef BDEBUG\nstatic void opt_dump(opt_state_t *, struct icode *);\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\nstatic void\nfind_levels_r(opt_state_t *opt_state, struct icode *ic, struct block *b)\n{\n\tint level;\n\n\tif (isMarked(ic, b))\n\t\treturn;\n\n\tMark(ic, b);\n\tb->link = 0;\n\n\tif (JT(b)) {\n\t\tfind_levels_r(opt_state, ic, JT(b));\n\t\tfind_levels_r(opt_state, ic, JF(b));\n\t\tlevel = MAX(JT(b)->level, JF(b)->level) + 1;\n\t} else\n\t\tlevel = 0;\n\tb->level = level;\n\tb->link = opt_state->levels[level];\n\topt_state->levels[level] = b;\n}\n\n/*\n * Level graph.  The levels go from 0 at the leaves to\n * N_LEVELS at the root.  The opt_state->levels[] array points to the\n * first node of the level list, whose elements are linked\n * with the 'link' field of the struct block.\n */\nstatic void\nfind_levels(opt_state_t *opt_state, struct icode *ic)\n{\n\tmemset((char *)opt_state->levels, 0, opt_state->n_blocks * sizeof(*opt_state->levels));\n\tunMarkAll(ic);\n\tfind_levels_r(opt_state, ic, ic->root);\n}\n\n/*\n * Find dominator relationships.\n * Assumes graph has been leveled.\n */\nstatic void\nfind_dom(opt_state_t *opt_state, struct block *root)\n{\n\tu_int i;\n\tint level;\n\tstruct block *b;\n\tbpf_u_int32 *x;\n\n\t/*\n\t * Initialize sets to contain all nodes.\n\t */\n\tx = opt_state->all_dom_sets;\n\t/*\n\t * In opt_init(), we've made sure the product doesn't overflow.\n\t */\n\ti = opt_state->n_blocks * opt_state->nodewords;\n\twhile (i != 0) {\n\t\t--i;\n\t\t*x++ = 0xFFFFFFFFU;\n\t}\n\t/* Root starts off empty. */\n\tfor (i = opt_state->nodewords; i != 0;) {\n\t\t--i;\n\t\troot->dom[i] = 0;\n\t}\n\n\t/* root->level is the highest level no found. */\n\tfor (level = root->level; level >= 0; --level) {\n\t\tfor (b = opt_state->levels[level]; b; b = b->link) {\n\t\t\tSET_INSERT(b->dom, b->id);\n\t\t\tif (JT(b) == 0)\n\t\t\t\tcontinue;\n\t\t\tSET_INTERSECT(JT(b)->dom, b->dom, opt_state->nodewords);\n\t\t\tSET_INTERSECT(JF(b)->dom, b->dom, opt_state->nodewords);\n\t\t}\n\t}\n}\n\nstatic void\npropedom(opt_state_t *opt_state, struct edge *ep)\n{\n\tSET_INSERT(ep->edom, ep->id);\n\tif (ep->succ) {\n\t\tSET_INTERSECT(ep->succ->et.edom, ep->edom, opt_state->edgewords);\n\t\tSET_INTERSECT(ep->succ->ef.edom, ep->edom, opt_state->edgewords);\n\t}\n}\n\n/*\n * Compute edge dominators.\n * Assumes graph has been leveled and predecessors established.\n */\nstatic void\nfind_edom(opt_state_t *opt_state, struct block *root)\n{\n\tu_int i;\n\tuset x;\n\tint level;\n\tstruct block *b;\n\n\tx = opt_state->all_edge_sets;\n\t/*\n\t * In opt_init(), we've made sure the product doesn't overflow.\n\t */\n\tfor (i = opt_state->n_edges * opt_state->edgewords; i != 0; ) {\n\t\t--i;\n\t\tx[i] = 0xFFFFFFFFU;\n\t}\n\n\t/* root->level is the highest level no found. */\n\tmemset(root->et.edom, 0, opt_state->edgewords * sizeof(*(uset)0));\n\tmemset(root->ef.edom, 0, opt_state->edgewords * sizeof(*(uset)0));\n\tfor (level = root->level; level >= 0; --level) {\n\t\tfor (b = opt_state->levels[level]; b != 0; b = b->link) {\n\t\t\tpropedom(opt_state, &b->et);\n\t\t\tpropedom(opt_state, &b->ef);\n\t\t}\n\t}\n}\n\n/*\n * Find the backwards transitive closure of the flow graph.  These sets\n * are backwards in the sense that we find the set of nodes that reach\n * a given node, not the set of nodes that can be reached by a node.\n *\n * Assumes graph has been leveled.\n */\nstatic void\nfind_closure(opt_state_t *opt_state, struct block *root)\n{\n\tint level;\n\tstruct block *b;\n\n\t/*\n\t * Initialize sets to contain no nodes.\n\t */\n\tmemset((char *)opt_state->all_closure_sets, 0,\n\t      opt_state->n_blocks * opt_state->nodewords * sizeof(*opt_state->all_closure_sets));\n\n\t/* root->level is the highest level no found. */\n\tfor (level = root->level; level >= 0; --level) {\n\t\tfor (b = opt_state->levels[level]; b; b = b->link) {\n\t\t\tSET_INSERT(b->closure, b->id);\n\t\t\tif (JT(b) == 0)\n\t\t\t\tcontinue;\n\t\t\tSET_UNION(JT(b)->closure, b->closure, opt_state->nodewords);\n\t\t\tSET_UNION(JF(b)->closure, b->closure, opt_state->nodewords);\n\t\t}\n\t}\n}\n\n/*\n * Return the register number that is used by s.\n *\n * Returns ATOM_A if A is used, ATOM_X if X is used, AX_ATOM if both A and X\n * are used, the scratch memory location's number if a scratch memory\n * location is used (e.g., 0 for M[0]), or -1 if none of those are used.\n *\n * The implementation should probably change to an array access.\n */\nstatic int\natomuse(struct stmt *s)\n{\n\tregister int c = s->code;\n\n\tif (c == NOP)\n\t\treturn -1;\n\n\tswitch (BPF_CLASS(c)) {\n\n\tcase BPF_RET:\n\t\treturn (BPF_RVAL(c) == BPF_A) ? A_ATOM :\n\t\t\t(BPF_RVAL(c) == BPF_X) ? X_ATOM : -1;\n\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\t/*\n\t\t * As there are fewer than 2^31 memory locations,\n\t\t * s->k should be convertible to int without problems.\n\t\t */\n\t\treturn (BPF_MODE(c) == BPF_IND) ? X_ATOM :\n\t\t\t(BPF_MODE(c) == BPF_MEM) ? (int)s->k : -1;\n\n\tcase BPF_ST:\n\t\treturn A_ATOM;\n\n\tcase BPF_STX:\n\t\treturn X_ATOM;\n\n\tcase BPF_JMP:\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(c) == BPF_X)\n\t\t\treturn AX_ATOM;\n\t\treturn A_ATOM;\n\n\tcase BPF_MISC:\n\t\treturn BPF_MISCOP(c) == BPF_TXA ? X_ATOM : A_ATOM;\n\t}\n\tabort();\n\t/* NOTREACHED */\n}\n\n/*\n * Return the register number that is defined by 's'.  We assume that\n * a single stmt cannot define more than one register.  If no register\n * is defined, return -1.\n *\n * The implementation should probably change to an array access.\n */\nstatic int\natomdef(struct stmt *s)\n{\n\tif (s->code == NOP)\n\t\treturn -1;\n\n\tswitch (BPF_CLASS(s->code)) {\n\n\tcase BPF_LD:\n\tcase BPF_ALU:\n\t\treturn A_ATOM;\n\n\tcase BPF_LDX:\n\t\treturn X_ATOM;\n\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\treturn s->k;\n\n\tcase BPF_MISC:\n\t\treturn BPF_MISCOP(s->code) == BPF_TAX ? X_ATOM : A_ATOM;\n\t}\n\treturn -1;\n}\n\n/*\n * Compute the sets of registers used, defined, and killed by 'b'.\n *\n * \"Used\" means that a statement in 'b' uses the register before any\n * statement in 'b' defines it, i.e. it uses the value left in\n * that register by a predecessor block of this block.\n * \"Defined\" means that a statement in 'b' defines it.\n * \"Killed\" means that a statement in 'b' defines it before any\n * statement in 'b' uses it, i.e. it kills the value left in that\n * register by a predecessor block of this block.\n */\nstatic void\ncompute_local_ud(struct block *b)\n{\n\tstruct slist *s;\n\tatomset def = 0, use = 0, killed = 0;\n\tint atom;\n\n\tfor (s = b->stmts; s; s = s->next) {\n\t\tif (s->s.code == NOP)\n\t\t\tcontinue;\n\t\tatom = atomuse(&s->s);\n\t\tif (atom >= 0) {\n\t\t\tif (atom == AX_ATOM) {\n\t\t\t\tif (!ATOMELEM(def, X_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(X_ATOM);\n\t\t\t\tif (!ATOMELEM(def, A_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(A_ATOM);\n\t\t\t}\n\t\t\telse if (atom < N_ATOMS) {\n\t\t\t\tif (!ATOMELEM(def, atom))\n\t\t\t\t\tuse |= ATOMMASK(atom);\n\t\t\t}\n\t\t\telse\n\t\t\t\tabort();\n\t\t}\n\t\tatom = atomdef(&s->s);\n\t\tif (atom >= 0) {\n\t\t\tif (!ATOMELEM(use, atom))\n\t\t\t\tkilled |= ATOMMASK(atom);\n\t\t\tdef |= ATOMMASK(atom);\n\t\t}\n\t}\n\tif (BPF_CLASS(b->s.code) == BPF_JMP) {\n\t\t/*\n\t\t * XXX - what about RET?\n\t\t */\n\t\tatom = atomuse(&b->s);\n\t\tif (atom >= 0) {\n\t\t\tif (atom == AX_ATOM) {\n\t\t\t\tif (!ATOMELEM(def, X_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(X_ATOM);\n\t\t\t\tif (!ATOMELEM(def, A_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(A_ATOM);\n\t\t\t}\n\t\t\telse if (atom < N_ATOMS) {\n\t\t\t\tif (!ATOMELEM(def, atom))\n\t\t\t\t\tuse |= ATOMMASK(atom);\n\t\t\t}\n\t\t\telse\n\t\t\t\tabort();\n\t\t}\n\t}\n\n\tb->def = def;\n\tb->kill = killed;\n\tb->in_use = use;\n}\n\n/*\n * Assume graph is already leveled.\n */\nstatic void\nfind_ud(opt_state_t *opt_state, struct block *root)\n{\n\tint i, maxlevel;\n\tstruct block *p;\n\n\t/*\n\t * root->level is the highest level no found;\n\t * count down from there.\n\t */\n\tmaxlevel = root->level;\n\tfor (i = maxlevel; i >= 0; --i)\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tcompute_local_ud(p);\n\t\t\tp->out_use = 0;\n\t\t}\n\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tp->out_use |= JT(p)->in_use | JF(p)->in_use;\n\t\t\tp->in_use |= p->out_use &~ p->kill;\n\t\t}\n\t}\n}\nstatic void\ninit_val(opt_state_t *opt_state)\n{\n\topt_state->curval = 0;\n\topt_state->next_vnode = opt_state->vnode_base;\n\tmemset((char *)opt_state->vmap, 0, opt_state->maxval * sizeof(*opt_state->vmap));\n\tmemset((char *)opt_state->hashtbl, 0, sizeof opt_state->hashtbl);\n}\n\n/*\n * Because we really don't have an IR, this stuff is a little messy.\n *\n * This routine looks in the table of existing value number for a value\n * with generated from an operation with the specified opcode and\n * the specified values.  If it finds it, it returns its value number,\n * otherwise it makes a new entry in the table and returns the\n * value number of that entry.\n */\nstatic bpf_u_int32\nF(opt_state_t *opt_state, int code, bpf_u_int32 v0, bpf_u_int32 v1)\n{\n\tu_int hash;\n\tbpf_u_int32 val;\n\tstruct valnode *p;\n\n\thash = (u_int)code ^ (v0 << 4) ^ (v1 << 8);\n\thash %= MODULUS;\n\n\tfor (p = opt_state->hashtbl[hash]; p; p = p->next)\n\t\tif (p->code == code && p->v0 == v0 && p->v1 == v1)\n\t\t\treturn p->val;\n\n\t/*\n\t * Not found.  Allocate a new value, and assign it a new\n\t * value number.\n\t *\n\t * opt_state->curval starts out as 0, which means VAL_UNKNOWN; we\n\t * increment it before using it as the new value number, which\n\t * means we never assign VAL_UNKNOWN.\n\t *\n\t * XXX - unless we overflow, but we probably won't have 2^32-1\n\t * values; we treat 32 bits as effectively infinite.\n\t */\n\tval = ++opt_state->curval;\n\tif (BPF_MODE(code) == BPF_IMM &&\n\t    (BPF_CLASS(code) == BPF_LD || BPF_CLASS(code) == BPF_LDX)) {\n\t\topt_state->vmap[val].const_val = v0;\n\t\topt_state->vmap[val].is_const = 1;\n\t}\n\tp = opt_state->next_vnode++;\n\tp->val = val;\n\tp->code = code;\n\tp->v0 = v0;\n\tp->v1 = v1;\n\tp->next = opt_state->hashtbl[hash];\n\topt_state->hashtbl[hash] = p;\n\n\treturn val;\n}\n\nstatic inline void\nvstore(struct stmt *s, bpf_u_int32 *valp, bpf_u_int32 newval, int alter)\n{\n\tif (alter && newval != VAL_UNKNOWN && *valp == newval)\n\t\ts->code = NOP;\n\telse\n\t\t*valp = newval;\n}\n\n/*\n * Do constant-folding on binary operators.\n * (Unary operators are handled elsewhere.)\n */\nstatic void\nfold_op(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 v0, bpf_u_int32 v1)\n{\n\tbpf_u_int32 a, b;\n\n\ta = opt_state->vmap[v0].const_val;\n\tb = opt_state->vmap[v1].const_val;\n\n\tswitch (BPF_OP(s->code)) {\n\tcase BPF_ADD:\n\t\ta += b;\n\t\tbreak;\n\n\tcase BPF_SUB:\n\t\ta -= b;\n\t\tbreak;\n\n\tcase BPF_MUL:\n\t\ta *= b;\n\t\tbreak;\n\n\tcase BPF_DIV:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"division by zero\");\n\t\ta /= b;\n\t\tbreak;\n\n\tcase BPF_MOD:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"modulus by zero\");\n\t\ta %= b;\n\t\tbreak;\n\n\tcase BPF_AND:\n\t\ta &= b;\n\t\tbreak;\n\n\tcase BPF_OR:\n\t\ta |= b;\n\t\tbreak;\n\n\tcase BPF_XOR:\n\t\ta ^= b;\n\t\tbreak;\n\n\tcase BPF_LSH:\n\t\t/*\n\t\t * A left shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta <<= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tcase BPF_RSH:\n\t\t/*\n\t\t * A right shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta >>= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\ts->k = a;\n\ts->code = BPF_LD|BPF_IMM;\n\topt_state->done = 0;\n\t/*\n\t * XXX - optimizer loop detection.\n\t */\n\topt_state->non_branch_movement_performed = 1;\n}\n\nstatic inline struct slist *\nthis_op(struct slist *s)\n{\n\twhile (s != 0 && s->s.code == NOP)\n\t\ts = s->next;\n\treturn s;\n}\n\nstatic void\nopt_not(struct block *b)\n{\n\tstruct block *tmp = JT(b);\n\n\tJT(b) = JF(b);\n\tJF(b) = tmp;\n}\n\nstatic void\nopt_peep(opt_state_t *opt_state, struct block *b)\n{\n\tstruct slist *s;\n\tstruct slist *next, *last;\n\tbpf_u_int32 val;\n\n\ts = b->stmts;\n\tif (s == 0)\n\t\treturn;\n\n\tlast = s;\n\tfor (/*empty*/; /*empty*/; s = next) {\n\t\t/*\n\t\t * Skip over nops.\n\t\t */\n\t\ts = this_op(s);\n\t\tif (s == 0)\n\t\t\tbreak;\t/* nothing left in the block */\n\n\t\t/*\n\t\t * Find the next real instruction after that one\n\t\t * (skipping nops).\n\t\t */\n\t\tnext = this_op(s->next);\n\t\tif (next == 0)\n\t\t\tbreak;\t/* no next instruction */\n\t\tlast = next;\n\n\t\t/*\n\t\t * st  M[k]\t-->\tst  M[k]\n\t\t * ldx M[k]\t\ttax\n\t\t */\n\t\tif (s->s.code == BPF_ST &&\n\t\t    next->s.code == (BPF_LDX|BPF_MEM) &&\n\t\t    s->s.k == next->s.k) {\n\t\t\topt_state->done = 0;\n\t\t\tnext->s.code = BPF_MISC|BPF_TAX;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\t/*\n\t\t * ld  #k\t-->\tldx  #k\n\t\t * tax\t\t\ttxa\n\t\t */\n\t\tif (s->s.code == (BPF_LD|BPF_IMM) &&\n\t\t    next->s.code == (BPF_MISC|BPF_TAX)) {\n\t\t\ts->s.code = BPF_LDX|BPF_IMM;\n\t\t\tnext->s.code = BPF_MISC|BPF_TXA;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\t/*\n\t\t * This is an ugly special case, but it happens\n\t\t * when you say tcp[k] or udp[k] where k is a constant.\n\t\t */\n\t\tif (s->s.code == (BPF_LD|BPF_IMM)) {\n\t\t\tstruct slist *add, *tax, *ild;\n\n\t\t\t/*\n\t\t\t * Check that X isn't used on exit from this\n\t\t\t * block (which the optimizer might cause).\n\t\t\t * We know the code generator won't generate\n\t\t\t * any local dependencies.\n\t\t\t */\n\t\t\tif (ATOMELEM(b->out_use, X_ATOM))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that the instruction following the ldi\n\t\t\t * is an addx, or it's an ldxms with an addx\n\t\t\t * following it (with 0 or more nops between the\n\t\t\t * ldxms and addx).\n\t\t\t */\n\t\t\tif (next->s.code != (BPF_LDX|BPF_MSH|BPF_B))\n\t\t\t\tadd = next;\n\t\t\telse\n\t\t\t\tadd = this_op(next->next);\n\t\t\tif (add == 0 || add->s.code != (BPF_ALU|BPF_ADD|BPF_X))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that a tax follows that (with 0 or more\n\t\t\t * nops between them).\n\t\t\t */\n\t\t\ttax = this_op(add->next);\n\t\t\tif (tax == 0 || tax->s.code != (BPF_MISC|BPF_TAX))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that an ild follows that (with 0 or more\n\t\t\t * nops between them).\n\t\t\t */\n\t\t\tild = this_op(tax->next);\n\t\t\tif (ild == 0 || BPF_CLASS(ild->s.code) != BPF_LD ||\n\t\t\t    BPF_MODE(ild->s.code) != BPF_IND)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We want to turn this sequence:\n\t\t\t *\n\t\t\t * (004) ldi     #0x2\t\t{s}\n\t\t\t * (005) ldxms   [14]\t\t{next}  -- optional\n\t\t\t * (006) addx\t\t\t{add}\n\t\t\t * (007) tax\t\t\t{tax}\n\t\t\t * (008) ild     [x+0]\t\t{ild}\n\t\t\t *\n\t\t\t * into this sequence:\n\t\t\t *\n\t\t\t * (004) nop\n\t\t\t * (005) ldxms   [14]\n\t\t\t * (006) nop\n\t\t\t * (007) nop\n\t\t\t * (008) ild     [x+2]\n\t\t\t *\n\t\t\t * XXX We need to check that X is not\n\t\t\t * subsequently used, because we want to change\n\t\t\t * what'll be in it after this sequence.\n\t\t\t *\n\t\t\t * We know we can eliminate the accumulator\n\t\t\t * modifications earlier in the sequence since\n\t\t\t * it is defined by the last stmt of this sequence\n\t\t\t * (i.e., the last statement of the sequence loads\n\t\t\t * a value into the accumulator, so we can eliminate\n\t\t\t * earlier operations on the accumulator).\n\t\t\t */\n\t\t\tild->s.k += s->s.k;\n\t\t\ts->s.code = NOP;\n\t\t\tadd->s.code = NOP;\n\t\t\ttax->s.code = NOP;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t}\n\t/*\n\t * If the comparison at the end of a block is an equality\n\t * comparison against a constant, and nobody uses the value\n\t * we leave in the A register at the end of a block, and\n\t * the operation preceding the comparison is an arithmetic\n\t * operation, we can sometime optimize it away.\n\t */\n\tif (b->s.code == (BPF_JMP|BPF_JEQ|BPF_K) &&\n\t    !ATOMELEM(b->out_use, A_ATOM)) {\n\t\t/*\n\t\t * We can optimize away certain subtractions of the\n\t\t * X register.\n\t\t */\n\t\tif (last->s.code == (BPF_ALU|BPF_SUB|BPF_X)) {\n\t\t\tval = b->val[X_ATOM];\n\t\t\tif (opt_state->vmap[val].is_const) {\n\t\t\t\t/*\n\t\t\t\t * If we have a subtract to do a comparison,\n\t\t\t\t * and the X register is a known constant,\n\t\t\t\t * we can merge this value into the\n\t\t\t\t * comparison:\n\t\t\t\t *\n\t\t\t\t * sub x  ->\tnop\n\t\t\t\t * jeq #y\tjeq #(x+y)\n\t\t\t\t */\n\t\t\t\tb->s.k += opt_state->vmap[val].const_val;\n\t\t\t\tlast->s.code = NOP;\n\t\t\t\topt_state->done = 0;\n\t\t\t\t/*\n\t\t\t\t * XXX - optimizer loop detection.\n\t\t\t\t */\n\t\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\t} else if (b->s.k == 0) {\n\t\t\t\t/*\n\t\t\t\t * If the X register isn't a constant,\n\t\t\t\t * and the comparison in the test is\n\t\t\t\t * against 0, we can compare with the\n\t\t\t\t * X register, instead:\n\t\t\t\t *\n\t\t\t\t * sub x  ->\tnop\n\t\t\t\t * jeq #0\tjeq x\n\t\t\t\t */\n\t\t\t\tlast->s.code = NOP;\n\t\t\t\tb->s.code = BPF_JMP|BPF_JEQ|BPF_X;\n\t\t\t\topt_state->done = 0;\n\t\t\t\t/*\n\t\t\t\t * XXX - optimizer loop detection.\n\t\t\t\t */\n\t\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Likewise, a constant subtract can be simplified:\n\t\t *\n\t\t * sub #x ->\tnop\n\t\t * jeq #y ->\tjeq #(x+y)\n\t\t */\n\t\telse if (last->s.code == (BPF_ALU|BPF_SUB|BPF_K)) {\n\t\t\tlast->s.code = NOP;\n\t\t\tb->s.k += last->s.k;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\t/*\n\t\t * And, similarly, a constant AND can be simplified\n\t\t * if we're testing against 0, i.e.:\n\t\t *\n\t\t * and #k\tnop\n\t\t * jeq #0  ->\tjset #k\n\t\t */\n\t\telse if (last->s.code == (BPF_ALU|BPF_AND|BPF_K) &&\n\t\t    b->s.k == 0) {\n\t\t\tb->s.k = last->s.k;\n\t\t\tb->s.code = BPF_JMP|BPF_K|BPF_JSET;\n\t\t\tlast->s.code = NOP;\n\t\t\topt_state->done = 0;\n\t\t\topt_not(b);\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t}\n\t/*\n\t * jset #0        ->   never\n\t * jset #ffffffff ->   always\n\t */\n\tif (b->s.code == (BPF_JMP|BPF_K|BPF_JSET)) {\n\t\tif (b->s.k == 0)\n\t\t\tJT(b) = JF(b);\n\t\tif (b->s.k == 0xffffffffU)\n\t\t\tJF(b) = JT(b);\n\t}\n\t/*\n\t * If we're comparing against the index register, and the index\n\t * register is a known constant, we can just compare against that\n\t * constant.\n\t */\n\tval = b->val[X_ATOM];\n\tif (opt_state->vmap[val].is_const && BPF_SRC(b->s.code) == BPF_X) {\n\t\tbpf_u_int32 v = opt_state->vmap[val].const_val;\n\t\tb->s.code &= ~BPF_X;\n\t\tb->s.k = v;\n\t}\n\t/*\n\t * If the accumulator is a known constant, we can compute the\n\t * comparison result.\n\t */\n\tval = b->val[A_ATOM];\n\tif (opt_state->vmap[val].is_const && BPF_SRC(b->s.code) == BPF_K) {\n\t\tbpf_u_int32 v = opt_state->vmap[val].const_val;\n\t\tswitch (BPF_OP(b->s.code)) {\n\n\t\tcase BPF_JEQ:\n\t\t\tv = v == b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JGT:\n\t\t\tv = v > b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JGE:\n\t\t\tv = v >= b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JSET:\n\t\t\tv &= b->s.k;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t\tif (JF(b) != JT(b)) {\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\tif (v)\n\t\t\tJF(b) = JT(b);\n\t\telse\n\t\t\tJT(b) = JF(b);\n\t}\n}\n\n/*\n * Compute the symbolic value of expression of 's', and update\n * anything it defines in the value table 'val'.  If 'alter' is true,\n * do various optimizations.  This code would be cleaner if symbolic\n * evaluation and code transformations weren't folded together.\n */\nstatic void\nopt_stmt(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 val[], int alter)\n{\n\tint op;\n\tbpf_u_int32 v;\n\n\tswitch (s->code) {\n\n\tcase BPF_LD|BPF_ABS|BPF_W:\n\tcase BPF_LD|BPF_ABS|BPF_H:\n\tcase BPF_LD|BPF_ABS|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IND|BPF_W:\n\tcase BPF_LD|BPF_IND|BPF_H:\n\tcase BPF_LD|BPF_IND|BPF_B:\n\t\tv = val[X_ATOM];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_ABS|BPF_SIZE(s->code);\n\t\t\ts->k += opt_state->vmap[v].const_val;\n\t\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\telse\n\t\t\tv = F(opt_state, s->code, s->k, v);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_LEN:\n\t\tv = F(opt_state, s->code, 0L, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_NEG:\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t/*\n\t\t\t * Do this negation as unsigned arithmetic; that's\n\t\t\t * what modern BPF engines do, and it guarantees\n\t\t\t * that all possible values can be negated.  (Yeah,\n\t\t\t * negating 0x80000000, the minimum signed 32-bit\n\t\t\t * two's-complement value, results in 0x80000000,\n\t\t\t * so it's still negative, but we *should* be doing\n\t\t\t * all unsigned arithmetic here, to match what\n\t\t\t * modern BPF engines do.)\n\t\t\t *\n\t\t\t * Express it as 0U - (unsigned value) so that we\n\t\t\t * don't get compiler warnings about negating an\n\t\t\t * unsigned value and don't get UBSan warnings\n\t\t\t * about the result of negating 0x80000000 being\n\t\t\t * undefined.\n\t\t\t */\n\t\t\ts->k = 0U - opt_state->vmap[val[A_ATOM]].const_val;\n\t\t\tval[A_ATOM] = K(s->k);\n\t\t}\n\t\telse\n\t\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], 0L);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_K:\n\tcase BPF_ALU|BPF_SUB|BPF_K:\n\tcase BPF_ALU|BPF_MUL|BPF_K:\n\tcase BPF_ALU|BPF_DIV|BPF_K:\n\tcase BPF_ALU|BPF_MOD|BPF_K:\n\tcase BPF_ALU|BPF_AND|BPF_K:\n\tcase BPF_ALU|BPF_OR|BPF_K:\n\tcase BPF_ALU|BPF_XOR|BPF_K:\n\tcase BPF_ALU|BPF_LSH|BPF_K:\n\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\top = BPF_OP(s->code);\n\t\tif (alter) {\n\t\t\tif (s->k == 0) {\n\t\t\t\t/*\n\t\t\t\t * Optimize operations where the constant\n\t\t\t\t * is zero.\n\t\t\t\t *\n\t\t\t\t * Don't optimize away \"sub #0\"\n\t\t\t\t * as it may be needed later to\n\t\t\t\t * fixup the generated math code.\n\t\t\t\t *\n\t\t\t\t * Fail if we're dividing by zero or taking\n\t\t\t\t * a modulus by zero.\n\t\t\t\t */\n\t\t\t\tif (op == BPF_ADD ||\n\t\t\t\t    op == BPF_LSH || op == BPF_RSH ||\n\t\t\t\t    op == BPF_OR || op == BPF_XOR) {\n\t\t\t\t\ts->code = NOP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_MUL || op == BPF_AND) {\n\t\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_DIV)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"division by zero\");\n\t\t\t\tif (op == BPF_MOD)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"modulus by zero\");\n\t\t\t}\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], K(s->k));\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_X:\n\tcase BPF_ALU|BPF_SUB|BPF_X:\n\tcase BPF_ALU|BPF_MUL|BPF_X:\n\tcase BPF_ALU|BPF_DIV|BPF_X:\n\tcase BPF_ALU|BPF_MOD|BPF_X:\n\tcase BPF_ALU|BPF_AND|BPF_X:\n\tcase BPF_ALU|BPF_OR|BPF_X:\n\tcase BPF_ALU|BPF_XOR|BPF_X:\n\tcase BPF_ALU|BPF_LSH|BPF_X:\n\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\top = BPF_OP(s->code);\n\t\tif (alter && opt_state->vmap[val[X_ATOM]].is_const) {\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], val[X_ATOM]);\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts->code = BPF_ALU|BPF_K|op;\n\t\t\t\ts->k = opt_state->vmap[val[X_ATOM]].const_val;\n\t\t\t\tif ((op == BPF_LSH || op == BPF_RSH) &&\n\t\t\t\t    s->k > 31)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"shift by more than 31 bits\");\n\t\t\t\topt_state->done = 0;\n\t\t\t\tval[A_ATOM] =\n\t\t\t\t\tF(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\t\t\t/*\n\t\t\t\t * XXX - optimizer loop detection.\n\t\t\t\t */\n\t\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Check if we're doing something to an accumulator\n\t\t * that is 0, and simplify.  This may not seem like\n\t\t * much of a simplification but it could open up further\n\t\t * optimizations.\n\t\t * XXX We could also check for mul by 1, etc.\n\t\t */\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const\n\t\t    && opt_state->vmap[val[A_ATOM]].const_val == 0) {\n\t\t\tif (op == BPF_ADD || op == BPF_OR || op == BPF_XOR) {\n\t\t\t\ts->code = BPF_MISC|BPF_TXA;\n\t\t\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_MUL || op == BPF_DIV || op == BPF_MOD ||\n\t\t\t\t op == BPF_AND || op == BPF_LSH || op == BPF_RSH) {\n\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\ts->k = 0;\n\t\t\t\tvstore(s, &val[A_ATOM], K(s->k), alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_NEG) {\n\t\t\t\ts->code = NOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], val[X_ATOM]);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TXA:\n\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TAX:\n\t\tvstore(s, &val[X_ATOM], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LDX|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ST:\n\t\tvstore(s, &val[s->k], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_STX:\n\t\tvstore(s, &val[s->k], val[X_ATOM], alter);\n\t\tbreak;\n\t}\n}\n\nstatic void\ndeadstmt(opt_state_t *opt_state, register struct stmt *s, register struct stmt *last[])\n{\n\tregister int atom;\n\n\tatom = atomuse(s);\n\tif (atom >= 0) {\n\t\tif (atom == AX_ATOM) {\n\t\t\tlast[X_ATOM] = 0;\n\t\t\tlast[A_ATOM] = 0;\n\t\t}\n\t\telse\n\t\t\tlast[atom] = 0;\n\t}\n\tatom = atomdef(s);\n\tif (atom >= 0) {\n\t\tif (last[atom]) {\n\t\t\topt_state->done = 0;\n\t\t\tlast[atom]->code = NOP;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t\tlast[atom] = s;\n\t}\n}\n\nstatic void\nopt_deadstores(opt_state_t *opt_state, register struct block *b)\n{\n\tregister struct slist *s;\n\tregister int atom;\n\tstruct stmt *last[N_ATOMS];\n\n\tmemset((char *)last, 0, sizeof last);\n\n\tfor (s = b->stmts; s != 0; s = s->next)\n\t\tdeadstmt(opt_state, &s->s, last);\n\tdeadstmt(opt_state, &b->s, last);\n\n\tfor (atom = 0; atom < N_ATOMS; ++atom)\n\t\tif (last[atom] && !ATOMELEM(b->out_use, atom)) {\n\t\t\tlast[atom]->code = NOP;\n\t\t\t/*\n\t\t\t * The store was removed as it's dead,\n\t\t\t * so the value stored into now has\n\t\t\t * an unknown value.\n\t\t\t */\n\t\t\tvstore(0, &b->val[atom], VAL_UNKNOWN, 0);\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n}\n\nstatic void\nopt_blk(opt_state_t *opt_state, struct block *b, int do_stmts)\n{\n\tstruct slist *s;\n\tstruct edge *p;\n\tint i;\n\tbpf_u_int32 aval, xval;\n\n#if 0\n\tfor (s = b->stmts; s && s->next; s = s->next)\n\t\tif (BPF_CLASS(s->s.code) == BPF_JMP) {\n\t\t\tdo_stmts = 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t/*\n\t * Initialize the atom values.\n\t */\n\tp = b->in_edges;\n\tif (p == 0) {\n\t\t/*\n\t\t * We have no predecessors, so everything is undefined\n\t\t * upon entry to this block.\n\t\t */\n\t\tmemset((char *)b->val, 0, sizeof(b->val));\n\t} else {\n\t\t/*\n\t\t * Inherit values from our predecessors.\n\t\t *\n\t\t * First, get the values from the predecessor along the\n\t\t * first edge leading to this node.\n\t\t */\n\t\tmemcpy((char *)b->val, (char *)p->pred->val, sizeof(b->val));\n\t\t/*\n\t\t * Now look at all the other nodes leading to this node.\n\t\t * If, for the predecessor along that edge, a register\n\t\t * has a different value from the one we have (i.e.,\n\t\t * control paths are merging, and the merging paths\n\t\t * assign different values to that register), give the\n\t\t * register the undefined value of 0.\n\t\t */\n\t\twhile ((p = p->next) != NULL) {\n\t\t\tfor (i = 0; i < N_ATOMS; ++i)\n\t\t\t\tif (b->val[i] != p->pred->val[i])\n\t\t\t\t\tb->val[i] = 0;\n\t\t}\n\t}\n\taval = b->val[A_ATOM];\n\txval = b->val[X_ATOM];\n\tfor (s = b->stmts; s; s = s->next)\n\t\topt_stmt(opt_state, &s->s, b->val, do_stmts);\n\n\t/*\n\t * This is a special case: if we don't use anything from this\n\t * block, and we load the accumulator or index register with a\n\t * value that is already there, or if this block is a return,\n\t * eliminate all the statements.\n\t *\n\t * XXX - what if it does a store?  Presumably that falls under\n\t * the heading of \"if we don't use anything from this block\",\n\t * i.e., if we use any memory location set to a different\n\t * value by this block, then we use something from this block.\n\t *\n\t * XXX - why does it matter whether we use anything from this\n\t * block?  If the accumulator or index register doesn't change\n\t * its value, isn't that OK even if we use that value?\n\t *\n\t * XXX - if we load the accumulator with a different value,\n\t * and the block ends with a conditional branch, we obviously\n\t * can't eliminate it, as the branch depends on that value.\n\t * For the index register, the conditional branch only depends\n\t * on the index register value if the test is against the index\n\t * register value rather than a constant; if nothing uses the\n\t * value we put into the index register, and we're not testing\n\t * against the index register's value, and there aren't any\n\t * other problems that would keep us from eliminating this\n\t * block, can we eliminate it?\n\t */\n\tif (do_stmts &&\n\t    ((b->out_use == 0 &&\n\t      aval != VAL_UNKNOWN && b->val[A_ATOM] == aval &&\n\t      xval != VAL_UNKNOWN && b->val[X_ATOM] == xval) ||\n\t     BPF_CLASS(b->s.code) == BPF_RET)) {\n\t\tif (b->stmts != 0) {\n\t\t\tb->stmts = 0;\n\t\t\topt_state->done = 0;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t} else {\n\t\topt_peep(opt_state, b);\n\t\topt_deadstores(opt_state, b);\n\t}\n\t/*\n\t * Set up values for branch optimizer.\n\t */\n\tif (BPF_SRC(b->s.code) == BPF_K)\n\t\tb->oval = K(b->s.k);\n\telse\n\t\tb->oval = b->val[X_ATOM];\n\tb->et.code = b->s.code;\n\tb->ef.code = -b->s.code;\n}\n\n/*\n * Return true if any register that is used on exit from 'succ', has\n * an exit value that is different from the corresponding exit value\n * from 'b'.\n */\nstatic int\nuse_conflict(struct block *b, struct block *succ)\n{\n\tint atom;\n\tatomset use = succ->out_use;\n\n\tif (use == 0)\n\t\treturn 0;\n\n\tfor (atom = 0; atom < N_ATOMS; ++atom)\n\t\tif (ATOMELEM(use, atom))\n\t\t\tif (b->val[atom] != succ->val[atom])\n\t\t\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Given a block that is the successor of an edge, and an edge that\n * dominates that edge, return either a pointer to a child of that\n * block (a block to which that block jumps) if that block is a\n * candidate to replace the successor of the latter edge or NULL\n * if neither of the children of the first block are candidates.\n */\nstatic struct block *\nfold_edge(struct block *child, struct edge *ep)\n{\n\tint sense;\n\tbpf_u_int32 aval0, aval1, oval0, oval1;\n\tint code = ep->code;\n\n\tif (code < 0) {\n\t\t/*\n\t\t * This edge is a \"branch if false\" edge.\n\t\t */\n\t\tcode = -code;\n\t\tsense = 0;\n\t} else {\n\t\t/*\n\t\t * This edge is a \"branch if true\" edge.\n\t\t */\n\t\tsense = 1;\n\t}\n\n\t/*\n\t * If the opcode for the branch at the end of the block we\n\t * were handed isn't the same as the opcode for the branch\n\t * to which the edge we were handed corresponds, the tests\n\t * for those branches aren't testing the same conditions,\n\t * so the blocks to which the first block branches aren't\n\t * candidates to replace the successor of the edge.\n\t */\n\tif (child->s.code != code)\n\t\treturn 0;\n\n\taval0 = child->val[A_ATOM];\n\toval0 = child->oval;\n\taval1 = ep->pred->val[A_ATOM];\n\toval1 = ep->pred->oval;\n\n\t/*\n\t * If the A register value on exit from the successor block\n\t * isn't the same as the A register value on exit from the\n\t * predecessor of the edge, the blocks to which the first\n\t * block branches aren't candidates to replace the successor\n\t * of the edge.\n\t */\n\tif (aval0 != aval1)\n\t\treturn 0;\n\n\tif (oval0 == oval1)\n\t\t/*\n\t\t * The operands of the branch instructions are\n\t\t * identical, so the branches are testing the\n\t\t * same condition, and the result is true if a true\n\t\t * branch was taken to get here, otherwise false.\n\t\t */\n\t\treturn sense ? JT(child) : JF(child);\n\n\tif (sense && code == (BPF_JMP|BPF_JEQ|BPF_K))\n\t\t/*\n\t\t * At this point, we only know the comparison if we\n\t\t * came down the true branch, and it was an equality\n\t\t * comparison with a constant.\n\t\t *\n\t\t * I.e., if we came down the true branch, and the branch\n\t\t * was an equality comparison with a constant, we know the\n\t\t * accumulator contains that constant.  If we came down\n\t\t * the false branch, or the comparison wasn't with a\n\t\t * constant, we don't know what was in the accumulator.\n\t\t *\n\t\t * We rely on the fact that distinct constants have distinct\n\t\t * value numbers.\n\t\t */\n\t\treturn JF(child);\n\n\treturn 0;\n}\n\n/*\n * If we can make this edge go directly to a child of the edge's current\n * successor, do so.\n */\nstatic void\nopt_j(opt_state_t *opt_state, struct edge *ep)\n{\n\tregister u_int i, k;\n\tregister struct block *target;\n\n\t/*\n\t * Does this edge go to a block where, if the test\n\t * at the end of it succeeds, it goes to a block\n\t * that's a leaf node of the DAG, i.e. a return\n\t * statement?\n\t * If so, there's nothing to optimize.\n\t */\n\tif (JT(ep->succ) == 0)\n\t\treturn;\n\n\t/*\n\t * Does this edge go to a block that goes, in turn, to\n\t * the same block regardless of whether the test at the\n\t * end succeeds or fails?\n\t */\n\tif (JT(ep->succ) == JF(ep->succ)) {\n\t\t/*\n\t\t * Common branch targets can be eliminated, provided\n\t\t * there is no data dependency.\n\t\t *\n\t\t * Check whether any register used on exit from the\n\t\t * block to which the successor of this edge goes\n\t\t * has a value at that point that's different from\n\t\t * the value it has on exit from the predecessor of\n\t\t * this edge.  If not, the predecessor of this edge\n\t\t * can just go to the block to which the successor\n\t\t * of this edge goes, bypassing the successor of this\n\t\t * edge, as the successor of this edge isn't doing\n\t\t * any calculations whose results are different\n\t\t * from what the blocks before it did and isn't\n\t\t * doing any tests the results of which matter.\n\t\t */\n\t\tif (!use_conflict(ep->pred, JT(ep->succ))) {\n\t\t\t/*\n\t\t\t * No, there isn't.\n\t\t\t * Make this edge go to the block to\n\t\t\t * which the successor of that edge\n\t\t\t * goes.\n\t\t\t */\n\t\t\topt_state->done = 0;\n\t\t\tep->succ = JT(ep->succ);\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t}\n\t}\n\t/*\n\t * For each edge dominator that matches the successor of this\n\t * edge, promote the edge successor to the its grandchild.\n\t *\n\t * XXX We violate the set abstraction here in favor a reasonably\n\t * efficient loop.\n\t */\n top:\n\tfor (i = 0; i < opt_state->edgewords; ++i) {\n\t\t/* i'th word in the bitset of dominators */\n\t\tregister bpf_u_int32 x = ep->edom[i];\n\n\t\twhile (x != 0) {\n\t\t\t/* Find the next dominator in that word and mark it as found */\n\t\t\tk = lowest_set_bit(x);\n\t\t\tx &=~ ((bpf_u_int32)1 << k);\n\t\t\tk += i * BITS_PER_WORD;\n\n\t\t\ttarget = fold_edge(ep->succ, opt_state->edges[k]);\n\t\t\t/*\n\t\t\t * We have a candidate to replace the successor\n\t\t\t * of ep.\n\t\t\t *\n\t\t\t * Check that there is no data dependency between\n\t\t\t * nodes that will be violated if we move the edge;\n\t\t\t * i.e., if any register used on exit from the\n\t\t\t * candidate has a value at that point different\n\t\t\t * from the value it has when we exit the\n\t\t\t * predecessor of that edge, there's a data\n\t\t\t * dependency that will be violated.\n\t\t\t */\n\t\t\tif (target != 0 && !use_conflict(ep->pred, target)) {\n\t\t\t\t/*\n\t\t\t\t * It's safe to replace the successor of\n\t\t\t\t * ep; do so, and note that we've made\n\t\t\t\t * at least one change.\n\t\t\t\t *\n\t\t\t\t * XXX - this is one of the operations that\n\t\t\t\t * happens when the optimizer gets into\n\t\t\t\t * one of those infinite loops.\n\t\t\t\t */\n\t\t\t\topt_state->done = 0;\n\t\t\t\tep->succ = target;\n\t\t\t\tif (JT(target) != 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Start over unless we hit a leaf.\n\t\t\t\t\t */\n\t\t\t\t\tgoto top;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * XXX - is this, and and_pullup(), what's described in section 6.1.2\n * \"Predicate Assertion Propagation\" in the BPF+ paper?\n *\n * Note that this looks at block dominators, not edge dominators.\n * Don't think so.\n *\n * \"A or B\" compiles into\n *\n *          A\n *       t / \\ f\n *        /   B\n *       / t / \\ f\n *      \\   /\n *       \\ /\n *        X\n *\n *\n */\nstatic void\nor_pullup(opt_state_t *opt_state, struct block *b, struct block *root)\n{\n\tbpf_u_int32 val;\n\tint at_top;\n\tstruct block *pull;\n\tstruct block **diffp, **samep;\n\tstruct edge *ep;\n\n\tep = b->in_edges;\n\tif (ep == 0)\n\t\treturn;\n\n\t/*\n\t * Make sure each predecessor loads the same value.\n\t * XXX why?\n\t */\n\tval = ep->pred->val[A_ATOM];\n\tfor (ep = ep->next; ep != 0; ep = ep->next)\n\t\tif (val != ep->pred->val[A_ATOM])\n\t\t\treturn;\n\n\t/*\n\t * For the first edge in the list of edges coming into this block,\n\t * see whether the predecessor of that edge comes here via a true\n\t * branch or a false branch.\n\t */\n\tif (JT(b->in_edges->pred) == b)\n\t\tdiffp = &JT(b->in_edges->pred);\t/* jt */\n\telse\n\t\tdiffp = &JF(b->in_edges->pred);\t/* jf */\n\n\t/*\n\t * diffp is a pointer to a pointer to the block.\n\t *\n\t * Go down the false chain looking as far as you can,\n\t * making sure that each jump-compare is doing the\n\t * same as the original block.\n\t *\n\t * If you reach the bottom before you reach a\n\t * different jump-compare, just exit.  There's nothing\n\t * to do here.  XXX - no, this version is checking for\n\t * the value leaving the block; that's from the BPF+\n\t * pullup routine.\n\t */\n\tat_top = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * Done if that's not going anywhere XXX\n\t\t */\n\t\tif (*diffp == 0)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if that predecessor blah blah blah isn't\n\t\t * going the same place we're going XXX\n\t\t *\n\t\t * Does the true edge of this block point to the same\n\t\t * location as the true edge of b?\n\t\t */\n\t\tif (JT(*diffp) != JT(b))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if this node isn't a dominator of that\n\t\t * node blah blah blah XXX\n\t\t *\n\t\t * Does b dominate diffp?\n\t\t */\n\t\tif (!SET_MEMBER((*diffp)->dom, b->id))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Break out of the loop if that node's value of A\n\t\t * isn't the value of A above XXX\n\t\t */\n\t\tif ((*diffp)->val[A_ATOM] != val)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get the JF for that node XXX\n\t\t * Go down the false path.\n\t\t */\n\t\tdiffp = &JF(*diffp);\n\t\tat_top = 0;\n\t}\n\n\t/*\n\t * Now that we've found a different jump-compare in a chain\n\t * below b, search further down until we find another\n\t * jump-compare that looks at the original value.  This\n\t * jump-compare should get pulled up.  XXX again we're\n\t * comparing values not jump-compares.\n\t */\n\tsamep = &JF(*diffp);\n\tfor (;;) {\n\t\t/*\n\t\t * Done if that's not going anywhere XXX\n\t\t */\n\t\tif (*samep == 0)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if that predecessor blah blah blah isn't\n\t\t * going the same place we're going XXX\n\t\t */\n\t\tif (JT(*samep) != JT(b))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if this node isn't a dominator of that\n\t\t * node blah blah blah XXX\n\t\t *\n\t\t * Does b dominate samep?\n\t\t */\n\t\tif (!SET_MEMBER((*samep)->dom, b->id))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Break out of the loop if that node's value of A\n\t\t * is the value of A above XXX\n\t\t */\n\t\tif ((*samep)->val[A_ATOM] == val)\n\t\t\tbreak;\n\n\t\t/* XXX Need to check that there are no data dependencies\n\t\t   between dp0 and dp1.  Currently, the code generator\n\t\t   will not produce such dependencies. */\n\t\tsamep = &JF(*samep);\n\t}\n#ifdef notdef\n\t/* XXX This doesn't cover everything. */\n\tfor (i = 0; i < N_ATOMS; ++i)\n\t\tif ((*samep)->val[i] != pred->val[i])\n\t\t\treturn;\n#endif\n\t/* Pull up the node. */\n\tpull = *samep;\n\t*samep = JF(pull);\n\tJF(pull) = *diffp;\n\n\t/*\n\t * At the top of the chain, each predecessor needs to point at the\n\t * pulled up node.  Inside the chain, there is only one predecessor\n\t * to worry about.\n\t */\n\tif (at_top) {\n\t\tfor (ep = b->in_edges; ep != 0; ep = ep->next) {\n\t\t\tif (JT(ep->pred) == b)\n\t\t\t\tJT(ep->pred) = pull;\n\t\t\telse\n\t\t\t\tJF(ep->pred) = pull;\n\t\t}\n\t}\n\telse\n\t\t*diffp = pull;\n\n\t/*\n\t * XXX - this is one of the operations that happens when the\n\t * optimizer gets into one of those infinite loops.\n\t */\n\topt_state->done = 0;\n\n\t/*\n\t * Recompute dominator sets as control flow graph has changed.\n\t */\n\tfind_dom(opt_state, root);\n}\n\nstatic void\nand_pullup(opt_state_t *opt_state, struct block *b, struct block *root)\n{\n\tbpf_u_int32 val;\n\tint at_top;\n\tstruct block *pull;\n\tstruct block **diffp, **samep;\n\tstruct edge *ep;\n\n\tep = b->in_edges;\n\tif (ep == 0)\n\t\treturn;\n\n\t/*\n\t * Make sure each predecessor loads the same value.\n\t */\n\tval = ep->pred->val[A_ATOM];\n\tfor (ep = ep->next; ep != 0; ep = ep->next)\n\t\tif (val != ep->pred->val[A_ATOM])\n\t\t\treturn;\n\n\tif (JT(b->in_edges->pred) == b)\n\t\tdiffp = &JT(b->in_edges->pred);\n\telse\n\t\tdiffp = &JF(b->in_edges->pred);\n\n\tat_top = 1;\n\tfor (;;) {\n\t\tif (*diffp == 0)\n\t\t\treturn;\n\n\t\tif (JF(*diffp) != JF(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*diffp)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*diffp)->val[A_ATOM] != val)\n\t\t\tbreak;\n\n\t\tdiffp = &JT(*diffp);\n\t\tat_top = 0;\n\t}\n\tsamep = &JT(*diffp);\n\tfor (;;) {\n\t\tif (*samep == 0)\n\t\t\treturn;\n\n\t\tif (JF(*samep) != JF(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*samep)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*samep)->val[A_ATOM] == val)\n\t\t\tbreak;\n\n\t\t/* XXX Need to check that there are no data dependencies\n\t\t   between diffp and samep.  Currently, the code generator\n\t\t   will not produce such dependencies. */\n\t\tsamep = &JT(*samep);\n\t}\n#ifdef notdef\n\t/* XXX This doesn't cover everything. */\n\tfor (i = 0; i < N_ATOMS; ++i)\n\t\tif ((*samep)->val[i] != pred->val[i])\n\t\t\treturn;\n#endif\n\t/* Pull up the node. */\n\tpull = *samep;\n\t*samep = JT(pull);\n\tJT(pull) = *diffp;\n\n\t/*\n\t * At the top of the chain, each predecessor needs to point at the\n\t * pulled up node.  Inside the chain, there is only one predecessor\n\t * to worry about.\n\t */\n\tif (at_top) {\n\t\tfor (ep = b->in_edges; ep != 0; ep = ep->next) {\n\t\t\tif (JT(ep->pred) == b)\n\t\t\t\tJT(ep->pred) = pull;\n\t\t\telse\n\t\t\t\tJF(ep->pred) = pull;\n\t\t}\n\t}\n\telse\n\t\t*diffp = pull;\n\n\t/*\n\t * XXX - this is one of the operations that happens when the\n\t * optimizer gets into one of those infinite loops.\n\t */\n\topt_state->done = 0;\n\n\t/*\n\t * Recompute dominator sets as control flow graph has changed.\n\t */\n\tfind_dom(opt_state, root);\n}\n\nstatic void\nopt_blks(opt_state_t *opt_state, struct icode *ic, int do_stmts)\n{\n\tint i, maxlevel;\n\tstruct block *p;\n\n\tinit_val(opt_state);\n\tmaxlevel = ic->root->level;\n\n\tfind_inedges(opt_state, ic->root);\n\tfor (i = maxlevel; i >= 0; --i)\n\t\tfor (p = opt_state->levels[i]; p; p = p->link)\n\t\t\topt_blk(opt_state, p, do_stmts);\n\n\tif (do_stmts)\n\t\t/*\n\t\t * No point trying to move branches; it can't possibly\n\t\t * make a difference at this point.\n\t\t *\n\t\t * XXX - this might be after we detect a loop where\n\t\t * we were just looping infinitely moving branches\n\t\t * in such a fashion that we went through two or more\n\t\t * versions of the machine code, eventually returning\n\t\t * to the first version.  (We're really not doing a\n\t\t * full loop detection, we're just testing for two\n\t\t * passes in a row where we do nothing but\n\t\t * move branches.)\n\t\t */\n\t\treturn;\n\n\t/*\n\t * Is this what the BPF+ paper describes in sections 6.1.1,\n\t * 6.1.2, and 6.1.3?\n\t */\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\topt_j(opt_state, &p->et);\n\t\t\topt_j(opt_state, &p->ef);\n\t\t}\n\t}\n\n\tfind_inedges(opt_state, ic->root);\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tor_pullup(opt_state, p, ic->root);\n\t\t\tand_pullup(opt_state, p, ic->root);\n\t\t}\n\t}\n}\n\nstatic inline void\nlink_inedge(struct edge *parent, struct block *child)\n{\n\tparent->next = child->in_edges;\n\tchild->in_edges = parent;\n}\n\nstatic void\nfind_inedges(opt_state_t *opt_state, struct block *root)\n{\n\tu_int i;\n\tint level;\n\tstruct block *b;\n\n\tfor (i = 0; i < opt_state->n_blocks; ++i)\n\t\topt_state->blocks[i]->in_edges = 0;\n\n\t/*\n\t * Traverse the graph, adding each edge to the predecessor\n\t * list of its successors.  Skip the leaves (i.e. level 0).\n\t */\n\tfor (level = root->level; level > 0; --level) {\n\t\tfor (b = opt_state->levels[level]; b != 0; b = b->link) {\n\t\t\tlink_inedge(&b->et, JT(b));\n\t\t\tlink_inedge(&b->ef, JF(b));\n\t\t}\n\t}\n}\n\nstatic void\nopt_root(struct block **b)\n{\n\tstruct slist *tmp, *s;\n\n\ts = (*b)->stmts;\n\t(*b)->stmts = 0;\n\twhile (BPF_CLASS((*b)->s.code) == BPF_JMP && JT(*b) == JF(*b))\n\t\t*b = JT(*b);\n\n\ttmp = (*b)->stmts;\n\tif (tmp != 0)\n\t\tsappend(s, tmp);\n\t(*b)->stmts = s;\n\n\t/*\n\t * If the root node is a return, then there is no\n\t * point executing any statements (since the bpf machine\n\t * has no side effects).\n\t */\n\tif (BPF_CLASS((*b)->s.code) == BPF_RET)\n\t\t(*b)->stmts = 0;\n}\n\nstatic void\nopt_loop(opt_state_t *opt_state, struct icode *ic, int do_stmts)\n{\n\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"opt_loop(root, %d) begin\\n\", do_stmts);\n\t\topt_dump(opt_state, ic);\n\t}\n#endif\n\n\t/*\n\t * XXX - optimizer loop detection.\n\t */\n\tint loop_count = 0;\n\tfor (;;) {\n\t\t/*\n\t\t * XXX - optimizer loop detection.\n\t\t */\n\t\topt_state->non_branch_movement_performed = 0;\n\t\topt_state->done = 1;\n\t\tfind_levels(opt_state, ic);\n\t\tfind_dom(opt_state, ic->root);\n\t\tfind_closure(opt_state, ic->root);\n\t\tfind_ud(opt_state, ic->root);\n\t\tfind_edom(opt_state, ic->root);\n\t\topt_blks(opt_state, ic, do_stmts);\n#ifdef BDEBUG\n\t\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\t\tprintf(\"opt_loop(root, %d) bottom, done=%d\\n\", do_stmts, opt_state->done);\n\t\t\topt_dump(opt_state, ic);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Was anything done in this optimizer pass?\n\t\t */\n\t\tif (opt_state->done) {\n\t\t\t/*\n\t\t\t * No, so we've reached a fixed point.\n\t\t\t * We're done.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * XXX - was anything done other than branch movement\n\t\t * in this pass?\n\t\t */\n\t\tif (opt_state->non_branch_movement_performed) {\n\t\t\t/*\n\t\t\t * Yes.  Clear any loop-detection counter;\n\t\t\t * we're making some form of progress (assuming\n\t\t\t * we can't get into a cycle doing *other*\n\t\t\t * optimizations...).\n\t\t\t */\n\t\t\tloop_count = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No - increment the counter, and quit if\n\t\t\t * it's up to 100.\n\t\t\t */\n\t\t\tloop_count++;\n\t\t\tif (loop_count >= 100) {\n\t\t\t\t/*\n\t\t\t\t * We've done nothing but branch movement\n\t\t\t\t * for 100 passes; we're probably\n\t\t\t\t * in a cycle and will never reach a\n\t\t\t\t * fixed point.\n\t\t\t\t *\n\t\t\t\t * XXX - yes, we really need a non-\n\t\t\t\t * heuristic way of detecting a cycle.\n\t\t\t\t */\n\t\t\t\topt_state->done = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Optimize the filter code in its dag representation.\n * Return 0 on success, -1 on error.\n */\nint\nbpf_optimize(struct icode *ic, char *errbuf)\n{\n\topt_state_t opt_state;\n\n\tmemset(&opt_state, 0, sizeof(opt_state));\n\topt_state.errbuf = errbuf;\n\tif (setjmp(opt_state.top_ctx)) {\n\t\topt_cleanup(&opt_state);\n\t\treturn -1;\n\t}\n\topt_init(&opt_state, ic);\n\topt_loop(&opt_state, ic, 0);\n\topt_loop(&opt_state, ic, 1);\n\tintern_blocks(&opt_state, ic);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after intern_blocks()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_root(&ic->root);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after opt_root()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_cleanup(&opt_state);\n\treturn 0;\n}\n\nstatic void\nmake_marks(struct icode *ic, struct block *p)\n{\n\tif (!isMarked(ic, p)) {\n\t\tMark(ic, p);\n\t\tif (BPF_CLASS(p->s.code) != BPF_RET) {\n\t\t\tmake_marks(ic, JT(p));\n\t\t\tmake_marks(ic, JF(p));\n\t\t}\n\t}\n}\n\n/*\n * Mark code array such that isMarked(ic->cur_mark, i) is true\n * only for nodes that are alive.\n */\nstatic void\nmark_code(struct icode *ic)\n{\n\tic->cur_mark += 1;\n\tmake_marks(ic, ic->root);\n}\n\n/*\n * True iff the two stmt lists load the same value from the packet into\n * the accumulator.\n */\nstatic int\neq_slist(struct slist *x, struct slist *y)\n{\n\tfor (;;) {\n\t\twhile (x && x->s.code == NOP)\n\t\t\tx = x->next;\n\t\twhile (y && y->s.code == NOP)\n\t\t\ty = y->next;\n\t\tif (x == 0)\n\t\t\treturn y == 0;\n\t\tif (y == 0)\n\t\t\treturn x == 0;\n\t\tif (x->s.code != y->s.code || x->s.k != y->s.k)\n\t\t\treturn 0;\n\t\tx = x->next;\n\t\ty = y->next;\n\t}\n}\n\nstatic inline int\neq_blk(struct block *b0, struct block *b1)\n{\n\tif (b0->s.code == b1->s.code &&\n\t    b0->s.k == b1->s.k &&\n\t    b0->et.succ == b1->et.succ &&\n\t    b0->ef.succ == b1->ef.succ)\n\t\treturn eq_slist(b0->stmts, b1->stmts);\n\treturn 0;\n}\n\nstatic void\nintern_blocks(opt_state_t *opt_state, struct icode *ic)\n{\n\tstruct block *p;\n\tu_int i, j;\n\tint done1; /* don't shadow global */\n top:\n\tdone1 = 1;\n\tfor (i = 0; i < opt_state->n_blocks; ++i)\n\t\topt_state->blocks[i]->link = 0;\n\n\tmark_code(ic);\n\n\tfor (i = opt_state->n_blocks - 1; i != 0; ) {\n\t\t--i;\n\t\tif (!isMarked(ic, opt_state->blocks[i]))\n\t\t\tcontinue;\n\t\tfor (j = i + 1; j < opt_state->n_blocks; ++j) {\n\t\t\tif (!isMarked(ic, opt_state->blocks[j]))\n\t\t\t\tcontinue;\n\t\t\tif (eq_blk(opt_state->blocks[i], opt_state->blocks[j])) {\n\t\t\t\topt_state->blocks[i]->link = opt_state->blocks[j]->link ?\n\t\t\t\t\topt_state->blocks[j]->link : opt_state->blocks[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < opt_state->n_blocks; ++i) {\n\t\tp = opt_state->blocks[i];\n\t\tif (JT(p) == 0)\n\t\t\tcontinue;\n\t\tif (JT(p)->link) {\n\t\t\tdone1 = 0;\n\t\t\tJT(p) = JT(p)->link;\n\t\t}\n\t\tif (JF(p)->link) {\n\t\t\tdone1 = 0;\n\t\t\tJF(p) = JF(p)->link;\n\t\t}\n\t}\n\tif (!done1)\n\t\tgoto top;\n}\n\nstatic void\nopt_cleanup(opt_state_t *opt_state)\n{\n\tfree((void *)opt_state->vnode_base);\n\tfree((void *)opt_state->vmap);\n\tfree((void *)opt_state->edges);\n\tfree((void *)opt_state->space);\n\tfree((void *)opt_state->levels);\n\tfree((void *)opt_state->blocks);\n}\n\n/*\n * For optimizer errors.\n */\nstatic void PCAP_NORETURN\nopt_error(opt_state_t *opt_state, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (opt_state->errbuf != NULL) {\n\t\tva_start(ap, fmt);\n\t\t(void)vsnprintf(opt_state->errbuf,\n\t\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tlongjmp(opt_state->top_ctx, 1);\n\t/* NOTREACHED */\n#ifdef _AIX\n\tPCAP_UNREACHABLE\n#endif /* _AIX */\n}\n\n/*\n * Return the number of stmts in 's'.\n */\nstatic u_int\nslength(struct slist *s)\n{\n\tu_int n = 0;\n\n\tfor (; s; s = s->next)\n\t\tif (s->s.code != NOP)\n\t\t\t++n;\n\treturn n;\n}\n\n/*\n * Return the number of nodes reachable by 'p'.\n * All nodes should be initially unmarked.\n */\nstatic int\ncount_blocks(struct icode *ic, struct block *p)\n{\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\treturn count_blocks(ic, JT(p)) + count_blocks(ic, JF(p)) + 1;\n}\n\n/*\n * Do a depth first search on the flow graph, numbering the\n * the basic blocks, and entering them into the 'blocks' array.`\n */\nstatic void\nnumber_blks_r(opt_state_t *opt_state, struct icode *ic, struct block *p)\n{\n\tu_int n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn;\n\n\tMark(ic, p);\n\tn = opt_state->n_blocks++;\n\tif (opt_state->n_blocks == 0) {\n\t\t/*\n\t\t * Overflow.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\tp->id = n;\n\topt_state->blocks[n] = p;\n\n\tnumber_blks_r(opt_state, ic, JT(p));\n\tnumber_blks_r(opt_state, ic, JF(p));\n}\n\n/*\n * Return the number of stmts in the flowgraph reachable by 'p'.\n * The nodes should be unmarked before calling.\n *\n * Note that \"stmts\" means \"instructions\", and that this includes\n *\n *\tside-effect statements in 'p' (slength(p->stmts));\n *\n *\tstatements in the true branch from 'p' (count_stmts(JT(p)));\n *\n *\tstatements in the false branch from 'p' (count_stmts(JF(p)));\n *\n *\tthe conditional jump itself (1);\n *\n *\tan extra long jump if the true branch requires it (p->longjt);\n *\n *\tan extra long jump if the false branch requires it (p->longjf).\n */\nstatic u_int\ncount_stmts(struct icode *ic, struct block *p)\n{\n\tu_int n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\tn = count_stmts(ic, JT(p)) + count_stmts(ic, JF(p));\n\treturn slength(p->stmts) + n + 1 + p->longjt + p->longjf;\n}\n\n/*\n * Allocate memory.  All allocation is done before optimization\n * is begun.  A linear bound on the size of all data structures is computed\n * from the total number of blocks and/or statements.\n */\nstatic void\nopt_init(opt_state_t *opt_state, struct icode *ic)\n{\n\tbpf_u_int32 *p;\n\tint i, n, max_stmts;\n\tu_int product;\n\tsize_t block_memsize, edge_memsize;\n\n\t/*\n\t * First, count the blocks, so we can malloc an array to map\n\t * block number to block.  Then, put the blocks into the array.\n\t */\n\tunMarkAll(ic);\n\tn = count_blocks(ic, ic->root);\n\topt_state->blocks = (struct block **)calloc(n, sizeof(*opt_state->blocks));\n\tif (opt_state->blocks == NULL)\n\t\topt_error(opt_state, \"malloc\");\n\tunMarkAll(ic);\n\topt_state->n_blocks = 0;\n\tnumber_blks_r(opt_state, ic, ic->root);\n\n\t/*\n\t * This \"should not happen\".\n\t */\n\tif (opt_state->n_blocks == 0)\n\t\topt_error(opt_state, \"filter has no instructions; please report this as a libpcap issue\");\n\n\topt_state->n_edges = 2 * opt_state->n_blocks;\n\tif ((opt_state->n_edges / 2) != opt_state->n_blocks) {\n\t\t/*\n\t\t * Overflow.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\topt_state->edges = (struct edge **)calloc(opt_state->n_edges, sizeof(*opt_state->edges));\n\tif (opt_state->edges == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\t/*\n\t * The number of levels is bounded by the number of nodes.\n\t */\n\topt_state->levels = (struct block **)calloc(opt_state->n_blocks, sizeof(*opt_state->levels));\n\tif (opt_state->levels == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\topt_state->edgewords = opt_state->n_edges / BITS_PER_WORD + 1;\n\topt_state->nodewords = opt_state->n_blocks / BITS_PER_WORD + 1;\n\n\t/*\n\t * Make sure opt_state->n_blocks * opt_state->nodewords fits\n\t * in a u_int; we use it as a u_int number-of-iterations\n\t * value.\n\t */\n\tproduct = opt_state->n_blocks * opt_state->nodewords;\n\tif ((product / opt_state->n_blocks) != opt_state->nodewords) {\n\t\t/*\n\t\t * XXX - just punt and don't try to optimize?\n\t\t * In practice, this is unlikely to happen with\n\t\t * a normal filter.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for that doesn't\n\t * overflow.\n\t */\n\tblock_memsize = (size_t)2 * product * sizeof(*opt_state->space);\n\tif ((block_memsize / product) != 2 * sizeof(*opt_state->space)) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure opt_state->n_edges * opt_state->edgewords fits\n\t * in a u_int; we use it as a u_int number-of-iterations\n\t * value.\n\t */\n\tproduct = opt_state->n_edges * opt_state->edgewords;\n\tif ((product / opt_state->n_edges) != opt_state->edgewords) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for that doesn't\n\t * overflow.\n\t */\n\tedge_memsize = (size_t)product * sizeof(*opt_state->space);\n\tif (edge_memsize / product != sizeof(*opt_state->space)) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for both of them doesn't\n\t * overflow.\n\t */\n\tif (block_memsize > SIZE_MAX - edge_memsize) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/* XXX */\n\topt_state->space = (bpf_u_int32 *)malloc(block_memsize + edge_memsize);\n\tif (opt_state->space == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\tp = opt_state->space;\n\topt_state->all_dom_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->dom = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_closure_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->closure = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_edge_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\tregister struct block *b = opt_state->blocks[i];\n\n\t\tb->et.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->ef.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->et.id = i;\n\t\topt_state->edges[i] = &b->et;\n\t\tb->ef.id = opt_state->n_blocks + i;\n\t\topt_state->edges[opt_state->n_blocks + i] = &b->ef;\n\t\tb->et.pred = b;\n\t\tb->ef.pred = b;\n\t}\n\tmax_stmts = 0;\n\tfor (i = 0; i < n; ++i)\n\t\tmax_stmts += slength(opt_state->blocks[i]->stmts) + 1;\n\t/*\n\t * We allocate at most 3 value numbers per statement,\n\t * so this is an upper bound on the number of valnodes\n\t * we'll need.\n\t */\n\topt_state->maxval = 3 * max_stmts;\n\topt_state->vmap = (struct vmapinfo *)calloc(opt_state->maxval, sizeof(*opt_state->vmap));\n\tif (opt_state->vmap == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\topt_state->vnode_base = (struct valnode *)calloc(opt_state->maxval, sizeof(*opt_state->vnode_base));\n\tif (opt_state->vnode_base == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n}\n\n/*\n * This is only used when supporting optimizer debugging.  It is\n * global state, so do *not* do more than one compile in parallel\n * and expect it to provide meaningful information.\n */\n#ifdef BDEBUG\nint bids[NBIDS];\n#endif\n\nstatic void PCAP_NORETURN conv_error(conv_state_t *, const char *, ...)\n    PCAP_PRINTFLIKE(2, 3);\n\n/*\n * Returns true if successful.  Returns false if a branch has\n * an offset that is too large.  If so, we have marked that\n * branch so that on a subsequent iteration, it will be treated\n * properly.\n */\nstatic int\nconvert_code_r(conv_state_t *conv_state, struct icode *ic, struct block *p)\n{\n\tstruct bpf_insn *dst;\n\tstruct slist *src;\n\tu_int slen;\n\tu_int off;\n\tstruct slist **offset = NULL;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn (1);\n\tMark(ic, p);\n\n\tif (convert_code_r(conv_state, ic, JF(p)) == 0)\n\t\treturn (0);\n\tif (convert_code_r(conv_state, ic, JT(p)) == 0)\n\t\treturn (0);\n\n\tslen = slength(p->stmts);\n\tdst = conv_state->ftail -= (slen + 1 + p->longjt + p->longjf);\n\t\t/* inflate length by any extra jumps */\n\n\tp->offset = (int)(dst - conv_state->fstart);\n\n\t/* generate offset[] for convenience  */\n\tif (slen) {\n\t\toffset = (struct slist **)calloc(slen, sizeof(struct slist *));\n\t\tif (!offset) {\n\t\t\tconv_error(conv_state, \"not enough core\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\tsrc = p->stmts;\n\tfor (off = 0; off < slen && src; off++) {\n#if 0\n\t\tprintf(\"off=%d src=%x\\n\", off, src);\n#endif\n\t\toffset[off] = src;\n\t\tsrc = src->next;\n\t}\n\n\toff = 0;\n\tfor (src = p->stmts; src; src = src->next) {\n\t\tif (src->s.code == NOP)\n\t\t\tcontinue;\n\t\tdst->code = (u_short)src->s.code;\n\t\tdst->k = src->s.k;\n\n\t\t/* fill block-local relative jump */\n\t\tif (BPF_CLASS(src->s.code) != BPF_JMP || src->s.code == (BPF_JMP|BPF_JA)) {\n#if 0\n\t\t\tif (src->s.jt || src->s.jf) {\n\t\t\t\tfree(offset);\n\t\t\t\tconv_error(conv_state, \"illegal jmp destination\");\n\t\t\t\t/*NOTREACHED*/\n\t\t\t}\n#endif\n\t\t\tgoto filled;\n\t\t}\n\t\tif (off == slen - 2)\t/*???*/\n\t\t\tgoto filled;\n\n\t    {\n\t\tu_int i;\n\t\tint jt, jf;\n\t\tconst char ljerr[] = \"%s for block-local relative jump: off=%d\";\n\n#if 0\n\t\tprintf(\"code=%x off=%d %x %x\\n\", src->s.code,\n\t\t\toff, src->s.jt, src->s.jf);\n#endif\n\n\t\tif (!src->s.jt || !src->s.jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no jmp destination\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\t\tjt = jf = 0;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (offset[i] == src->s.jt) {\n\t\t\t\tif (jt) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jt = (u_char)(i - off - 1);\n\t\t\t\tjt++;\n\t\t\t}\n\t\t\tif (offset[i] == src->s.jf) {\n\t\t\t\tif (jf) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jf = (u_char)(i - off - 1);\n\t\t\t\tjf++;\n\t\t\t}\n\t\t}\n\t\tif (!jt || !jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no destination found\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t    }\nfilled:\n\t\t++dst;\n\t\t++off;\n\t}\n\tif (offset)\n\t\tfree(offset);\n\n#ifdef BDEBUG\n\tif (dst - conv_state->fstart < NBIDS)\n\t\tbids[dst - conv_state->fstart] = p->id + 1;\n#endif\n\tdst->code = (u_short)p->s.code;\n\tdst->k = p->s.k;\n\tif (JT(p)) {\n\t\t/* number of extra jumps inserted */\n\t\tu_char extrajmps = 0;\n\t\toff = JT(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjt == 0) {\n\t\t\t/* mark this instruction and retry */\n\t\t\tp->longjt++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    dst->jt = extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jt = (u_char)off;\n\t\toff = JF(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjf == 0) {\n\t\t\t/* mark this instruction and retry */\n\t\t\tp->longjf++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    /* branch if F to following jump */\n\t\t    /* if two jumps are inserted, F goes to second one */\n\t\t    dst->jf = extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jf = (u_char)off;\n\t}\n\treturn (1);\n}\n\n\n/*\n * Convert flowgraph intermediate representation to the\n * BPF array representation.  Set *lenp to the number of instructions.\n *\n * This routine does *NOT* leak the memory pointed to by fp.  It *must\n * not* do free(fp) before returning fp; doing so would make no sense,\n * as the BPF array pointed to by the return value of icode_to_fcode()\n * must be valid - it's being returned for use in a bpf_program structure.\n *\n * If it appears that icode_to_fcode() is leaking, the problem is that\n * the program using pcap_compile() is failing to free the memory in\n * the BPF program when it's done - the leak is in the program, not in\n * the routine that happens to be allocating the memory.  (By analogy, if\n * a program calls fopen() without ever calling fclose() on the FILE *,\n * it will leak the FILE structure; the leak is not in fopen(), it's in\n * the program.)  Change the program to use pcap_freecode() when it's\n * done with the filter program.  See the pcap man page.\n */\nstruct bpf_insn *\nicode_to_fcode(struct icode *ic, struct block *root, u_int *lenp,\n    char *errbuf)\n{\n\tu_int n;\n\tstruct bpf_insn *fp;\n\tconv_state_t conv_state;\n\n\tconv_state.fstart = NULL;\n\tconv_state.errbuf = errbuf;\n\tif (setjmp(conv_state.top_ctx) != 0) {\n\t\tfree(conv_state.fstart);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Loop doing convert_code_r() until no branches remain\n\t * with too-large offsets.\n\t */\n\tfor (;;) {\n\t    unMarkAll(ic);\n\t    n = *lenp = count_stmts(ic, root);\n\n\t    fp = (struct bpf_insn *)malloc(sizeof(*fp) * n);\n\t    if (fp == NULL) {\n\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"malloc\");\n\t\treturn NULL;\n\t    }\n\t    memset((char *)fp, 0, sizeof(*fp) * n);\n\t    conv_state.fstart = fp;\n\t    conv_state.ftail = fp + n;\n\n\t    unMarkAll(ic);\n\t    if (convert_code_r(&conv_state, ic, root))\n\t\tbreak;\n\t    free(fp);\n\t}\n\n\treturn fp;\n}\n\n/*\n * For iconv_to_fconv() errors.\n */\nstatic void PCAP_NORETURN\nconv_error(conv_state_t *conv_state, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void)vsnprintf(conv_state->errbuf,\n\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\tva_end(ap);\n\tlongjmp(conv_state->top_ctx, 1);\n\t/* NOTREACHED */\n#ifdef _AIX\n\tPCAP_UNREACHABLE\n#endif /* _AIX */\n}\n\n/*\n * Make a copy of a BPF program and put it in the \"fcode\" member of\n * a \"pcap_t\".\n *\n * If we fail to allocate memory for the copy, fill in the \"errbuf\"\n * member of the \"pcap_t\" with an error message, and return -1;\n * otherwise, return 0.\n */\nint\npcapint_install_bpf_program(pcap_t *p, struct bpf_program *fp)\n{\n\tsize_t prog_size;\n\n\t/*\n\t * Validate the program.\n\t */\n\tif (!pcapint_validate_filter(fp->bf_insns, fp->bf_len)) {\n\t\tsnprintf(p->errbuf, sizeof(p->errbuf),\n\t\t\t\"BPF program is not valid\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Free up any already installed program.\n\t */\n\tpcap_freecode(&p->fcode);\n\n\tprog_size = sizeof(*fp->bf_insns) * fp->bf_len;\n\tp->fcode.bf_len = fp->bf_len;\n\tp->fcode.bf_insns = (struct bpf_insn *)malloc(prog_size);\n\tif (p->fcode.bf_insns == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\tmemcpy(p->fcode.bf_insns, fp->bf_insns, prog_size);\n\treturn (0);\n}\n\n#ifdef BDEBUG\nstatic void\ndot_dump_node(struct icode *ic, struct block *block, struct bpf_program *prog,\n    FILE *out)\n{\n\tint icount, noffset;\n\tint i;\n\n\tif (block == NULL || isMarked(ic, block))\n\t\treturn;\n\tMark(ic, block);\n\n\ticount = slength(block->stmts) + 1 + block->longjt + block->longjf;\n\tnoffset = min(block->offset + icount, (int)prog->bf_len);\n\n\tfprintf(out, \"\\tblock%u [shape=ellipse, id=\\\"block-%u\\\" label=\\\"BLOCK%u\\\\n\", block->id, block->id, block->id);\n\tfor (i = block->offset; i < noffset; i++) {\n\t\tfprintf(out, \"\\\\n%s\", bpf_image(prog->bf_insns + i, i));\n\t}\n\tfprintf(out, \"\\\" tooltip=\\\"\");\n\tfor (i = 0; i < BPF_MEMWORDS; i++)\n\t\tif (block->val[i] != VAL_UNKNOWN)\n\t\t\tfprintf(out, \"val[%d]=%d \", i, block->val[i]);\n\tfprintf(out, \"val[A]=%d \", block->val[A_ATOM]);\n\tfprintf(out, \"val[X]=%d\", block->val[X_ATOM]);\n\tfprintf(out, \"\\\"\");\n\tif (JT(block) == NULL)\n\t\tfprintf(out, \", peripheries=2\");\n\tfprintf(out, \"];\\n\");\n\n\tdot_dump_node(ic, JT(block), prog, out);\n\tdot_dump_node(ic, JF(block), prog, out);\n}\n\nstatic void\ndot_dump_edge(struct icode *ic, struct block *block, FILE *out)\n{\n\tif (block == NULL || isMarked(ic, block))\n\t\treturn;\n\tMark(ic, block);\n\n\tif (JT(block)) {\n\t\tfprintf(out, \"\\t\\\"block%u\\\":se -> \\\"block%u\\\":n [label=\\\"T\\\"]; \\n\",\n\t\t\t\tblock->id, JT(block)->id);\n\t\tfprintf(out, \"\\t\\\"block%u\\\":sw -> \\\"block%u\\\":n [label=\\\"F\\\"]; \\n\",\n\t\t\t   block->id, JF(block)->id);\n\t}\n\tdot_dump_edge(ic, JT(block), out);\n\tdot_dump_edge(ic, JF(block), out);\n}\n\n/* Output the block CFG using graphviz/DOT language\n * In the CFG, block's code, value index for each registers at EXIT,\n * and the jump relationship is show.\n *\n * example DOT for BPF `ip src host 1.1.1.1' is:\n    digraph BPF {\n\tblock0 [shape=ellipse, id=\"block-0\" label=\"BLOCK0\\n\\n(000) ldh      [12]\\n(001) jeq      #0x800           jt 2\tjf 5\" tooltip=\"val[A]=0 val[X]=0\"];\n\tblock1 [shape=ellipse, id=\"block-1\" label=\"BLOCK1\\n\\n(002) ld       [26]\\n(003) jeq      #0x1010101       jt 4\tjf 5\" tooltip=\"val[A]=0 val[X]=0\"];\n\tblock2 [shape=ellipse, id=\"block-2\" label=\"BLOCK2\\n\\n(004) ret      #68\" tooltip=\"val[A]=0 val[X]=0\", peripheries=2];\n\tblock3 [shape=ellipse, id=\"block-3\" label=\"BLOCK3\\n\\n(005) ret      #0\" tooltip=\"val[A]=0 val[X]=0\", peripheries=2];\n\t\"block0\":se -> \"block1\":n [label=\"T\"];\n\t\"block0\":sw -> \"block3\":n [label=\"F\"];\n\t\"block1\":se -> \"block2\":n [label=\"T\"];\n\t\"block1\":sw -> \"block3\":n [label=\"F\"];\n    }\n *\n *  After install graphviz on https://www.graphviz.org/, save it as bpf.dot\n *  and run `dot -Tpng -O bpf.dot' to draw the graph.\n */\nstatic int\ndot_dump(struct icode *ic, char *errbuf)\n{\n\tstruct bpf_program f;\n\tFILE *out = stdout;\n\n\tmemset(bids, 0, sizeof bids);\n\tf.bf_insns = icode_to_fcode(ic, ic->root, &f.bf_len, errbuf);\n\tif (f.bf_insns == NULL)\n\t\treturn -1;\n\n\tfprintf(out, \"digraph BPF {\\n\");\n\tunMarkAll(ic);\n\tdot_dump_node(ic, ic->root, &f, out);\n\tunMarkAll(ic);\n\tdot_dump_edge(ic, ic->root, out);\n\tfprintf(out, \"}\\n\");\n\n\tfree((char *)f.bf_insns);\n\treturn 0;\n}\n\nstatic int\nplain_dump(struct icode *ic, char *errbuf)\n{\n\tstruct bpf_program f;\n\n\tmemset(bids, 0, sizeof bids);\n\tf.bf_insns = icode_to_fcode(ic, ic->root, &f.bf_len, errbuf);\n\tif (f.bf_insns == NULL)\n\t\treturn -1;\n\tbpf_dump(&f, 1);\n\tputchar('\\n');\n\tfree((char *)f.bf_insns);\n\treturn 0;\n}\n\nstatic void\nopt_dump(opt_state_t *opt_state, struct icode *ic)\n{\n\tint status;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\t/*\n\t * If the CFG, in DOT format, is requested, output it rather than\n\t * the code that would be generated from that graph.\n\t */\n\tif (pcap_print_dot_graph)\n\t\tstatus = dot_dump(ic, errbuf);\n\telse\n\t\tstatus = plain_dump(ic, errbuf);\n\tif (status == -1)\n\t\topt_error(opt_state, \"opt_dump: icode_to_fcode failed: %s\", errbuf);\n}\n#endif\n"
        },
        {
          "name": "optimize.h",
          "type": "blob",
          "size": 1.2900390625,
          "content": "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/*\n * Some stuff for use when debugging the optimizer.\n */\n#ifdef BDEBUG\n#define NBIDS\t1000\nextern int bids[NBIDS];\n#endif\n"
        },
        {
          "name": "org.tcpdump.chmod_bpf.plist",
          "type": "blob",
          "size": 0.431640625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"https://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>org.tcpdump.chmod_bpf</string>\n\t<key>RunAtLoad</key>\n\t<true/>\n\t<key>Program</key>\n\t<string>/usr/local/bin/chmod_bpf</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/usr/local/bin/chmod_bpf</string>\n\t</array>\n</dict>\n</plist>\n"
        },
        {
          "name": "pcap-bpf.c",
          "type": "blob",
          "size": 92.978515625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <sys/param.h>\t\t\t/* optionally get BSD define */\n#include <sys/socket.h>\n#include <time.h>\n/*\n * <net/bpf.h> defines ioctls, but doesn't include <sys/ioccom.h>.\n *\n * We include <sys/ioctl.h> as it might be necessary to declare ioctl();\n * at least on *BSD and macOS, it also defines various SIOC ioctls -\n * we could include <sys/sockio.h>, but if we're already including\n * <sys/ioctl.h>, which includes <sys/sockio.h> on those platforms,\n * there's not much point in doing so.\n *\n * If we have <sys/ioccom.h>, we include it as well, to handle systems\n * such as Solaris which don't arrange to include <sys/ioccom.h> if you\n * include <sys/ioctl.h>\n */\n#include <sys/ioctl.h>\n#ifdef HAVE_SYS_IOCCOM_H\n#include <sys/ioccom.h>\n#endif\n#include <sys/utsname.h>\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n/*\n * Add support for capturing on FreeBSD usbusN interfaces.\n */\nstatic const char usbus_prefix[] = \"usbus\";\n#define USBUS_PREFIX_LEN\t(sizeof(usbus_prefix) - 1)\n#include <dirent.h>\n#endif\n\n#include <net/if.h>\n\n#ifdef _AIX\n\n/*\n * Make \"pcap.h\" not include \"pcap/bpf.h\"; we are going to include the\n * native OS version, as we need \"struct bpf_config\" from it.\n */\n#define PCAP_DONT_INCLUDE_PCAP_BPF_H\n\n#include <sys/types.h>\n\n/*\n * Prevent bpf.h from redefining the DLT_ values to their\n * IFT_ values, as we're going to return the standard libpcap\n * values, not IBM's non-standard IFT_ values.\n */\n#undef _AIX\n#include <net/bpf.h>\n#define _AIX\n\n#include <net/if_types.h>\t\t/* for IFT_ values */\n#include <sys/sysconfig.h>\n#include <sys/device.h>\n#include <sys/cfgodm.h>\n#include <cf.h>\n\n#ifdef __64BIT__\n#define domakedev makedev64\n#define getmajor major64\n#define bpf_hdr bpf_hdr32\n#else /* __64BIT__ */\n#define domakedev makedev\n#define getmajor major\n#endif /* __64BIT__ */\n\n#define BPF_NAME \"bpf\"\n#define BPF_MINORS 4\n#define DRIVER_PATH \"/usr/lib/drivers\"\n#define BPF_NODE \"/dev/bpf\"\nstatic int bpfloadedflag = 0;\nstatic int odmlockid = 0;\n\nstatic int bpf_load(char *errbuf);\n\n#else /* _AIX */\n\n#include <net/bpf.h>\n\n#endif /* _AIX */\n\n#include <fcntl.h>\n#include <errno.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stddef.h>\n\n#ifdef SIOCGIFMEDIA\n# include <net/if_media.h>\n#endif\n\n/*\n * If both BIOCROTZBUF and BPF_BUFMODE_ZBUF are defined, we have\n * zero-copy BPF.\n */\n#if defined(BIOCROTZBUF) && defined(BPF_BUFMODE_ZBUF)\n  #define HAVE_ZEROCOPY_BPF\n  #include <sys/mman.h>\n  #include <machine/atomic.h>\n#endif\n\n#include \"pcap-int.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n/*\n * Later versions of NetBSD stick padding in front of FDDI frames\n * to align the IP header on a 4-byte boundary.\n */\n#if defined(__NetBSD__) && __NetBSD_Version__ > 106000000\n#define       PCAP_FDDIPAD 3\n#endif\n\n/*\n * Private data for capturing on BPF devices.\n */\nstruct pcap_bpf {\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will\n\t * alternative between these two actual mmap'd buffers as required.\n\t * As there is a header on the front size of the mmap'd buffer, only\n\t * some of the buffer is exposed to libpcap as a whole via bufsize;\n\t * zbufsize is the true size.  zbuffer tracks the current zbuf\n\t * associated with buffer so that it can be used to decide which the\n\t * next buffer to read will be.\n\t */\n\tu_char *zbuf1, *zbuf2, *zbuffer;\n\tu_int zbufsize;\n\tu_int zerocopy;\n\tu_int interrupted;\n\tstruct timespec firstsel;\n\t/*\n\t * If there's currently a buffer being actively processed, then it is\n\t * referenced here; 'buffer' is also pointed at it, but offset by the\n\t * size of the header.\n\t */\n\tstruct bpf_zbuf_header *bzh;\n\tint nonblock;\t\t/* true if in nonblocking mode */\n#endif /* HAVE_ZEROCOPY_BPF */\n\n\tchar *device;\t\t/* device name */\n\tint filtering_in_kernel; /* using kernel filter */\n\tint must_do_on_close;\t/* stuff we must do when we close */\n};\n\n/*\n * Stuff to do when we close.\n */\n#define MUST_CLEAR_RFMON\t0x00000001\t/* clear rfmon (monitor) mode */\n#define MUST_DESTROY_USBUS\t0x00000002\t/* destroy usbusN interface */\n\n#ifdef BIOCGDLTLIST\n# if (defined(HAVE_NET_IF_MEDIA_H) && defined(IFM_IEEE80211)) && !defined(__APPLE__)\n#define HAVE_BSD_IEEE80211\n\n/*\n * The ifm_ulist member of a struct ifmediareq is an int * on most systems,\n * but it's a uint64_t on newer versions of OpenBSD.\n *\n * We check this by checking whether IFM_GMASK is defined and > 2^32-1.\n */\n#  if defined(IFM_GMASK) && IFM_GMASK > 0xFFFFFFFF\n#    define IFM_ULIST_TYPE\tuint64_t\n#  else\n#    define IFM_ULIST_TYPE\tint\n#  endif\n# endif\n\n# if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)\nstatic int find_802_11(struct bpf_dltlist *);\n\n#  ifdef HAVE_BSD_IEEE80211\nstatic int monitor_mode(pcap_t *, int);\n#  endif\n\n#  if defined(__APPLE__)\nstatic void remove_non_802_11(pcap_t *);\nstatic void remove_802_11(pcap_t *);\n#  endif\n\n# endif /* defined(__APPLE__) || defined(HAVE_BSD_IEEE80211) */\n\n#endif /* BIOCGDLTLIST */\n\n#if defined(sun) && defined(LIFNAMSIZ) && defined(lifr_zoneid)\n#include <zone.h>\n#endif\n\n/*\n * We include the OS's <net/bpf.h>, not our \"pcap/bpf.h\", so we probably\n * don't get DLT_DOCSIS defined.\n */\n#ifndef DLT_DOCSIS\n#define DLT_DOCSIS\t143\n#endif\n\n/*\n * In some versions of macOS, we might not even get any of the\n * 802.11-plus-radio-header DLT_'s defined, even though some\n * of them are used by various Airport drivers in those versions.\n */\n#ifndef DLT_PRISM_HEADER\n#define DLT_PRISM_HEADER\t119\n#endif\n#ifndef DLT_AIRONET_HEADER\n#define DLT_AIRONET_HEADER\t120\n#endif\n#ifndef DLT_IEEE802_11_RADIO\n#define DLT_IEEE802_11_RADIO\t127\n#endif\n#ifndef DLT_IEEE802_11_RADIO_AVS\n#define DLT_IEEE802_11_RADIO_AVS 163\n#endif\n\nstatic int pcap_can_set_rfmon_bpf(pcap_t *p);\nstatic int pcap_activate_bpf(pcap_t *p);\nstatic int pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp);\nstatic int pcap_setdirection_bpf(pcap_t *, pcap_direction_t);\nstatic int pcap_set_datalink_bpf(pcap_t *p, int dlt);\n\n/*\n * For zerocopy bpf, the setnonblock/getnonblock routines need to modify\n * pb->nonblock so we don't call select(2) if the pcap handle is in non-\n * blocking mode.\n */\nstatic int\npcap_getnonblock_bpf(pcap_t *p)\n{\n#ifdef HAVE_ZEROCOPY_BPF\n\tstruct pcap_bpf *pb = p->priv;\n\n\tif (pb->zerocopy)\n\t\treturn (pb->nonblock);\n#endif\n\treturn (pcapint_getnonblock_fd(p));\n}\n\nstatic int\npcap_setnonblock_bpf(pcap_t *p, int nonblock)\n{\n#ifdef HAVE_ZEROCOPY_BPF\n\tstruct pcap_bpf *pb = p->priv;\n\n\tif (pb->zerocopy) {\n\t\tpb->nonblock = nonblock;\n\t\treturn (0);\n\t}\n#endif\n\treturn (pcapint_setnonblock_fd(p, nonblock));\n}\n\n#ifdef HAVE_ZEROCOPY_BPF\n/*\n * Zero-copy BPF buffer routines to check for and acknowledge BPF data in\n * shared memory buffers.\n *\n * pcap_next_zbuf_shm(): Check for a newly available shared memory buffer,\n * and set up p->buffer and cc to reflect one if available.  Notice that if\n * there was no prior buffer, we select zbuf1 as this will be the first\n * buffer filled for a fresh BPF session.\n */\nstatic int\npcap_next_zbuf_shm(pcap_t *p, u_int *cc)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tstruct bpf_zbuf_header *bzh;\n\n\tif (pb->zbuffer == pb->zbuf2 || pb->zbuffer == NULL) {\n\t\tbzh = (struct bpf_zbuf_header *)pb->zbuf1;\n\t\tif (bzh->bzh_user_gen !=\n\t\t    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {\n\t\t\tpb->bzh = bzh;\n\t\t\tpb->zbuffer = (u_char *)pb->zbuf1;\n\t\t\tp->buffer = pb->zbuffer + sizeof(*bzh);\n\t\t\t*cc = bzh->bzh_kernel_len;\n\t\t\treturn (1);\n\t\t}\n\t} else if (pb->zbuffer == pb->zbuf1) {\n\t\tbzh = (struct bpf_zbuf_header *)pb->zbuf2;\n\t\tif (bzh->bzh_user_gen !=\n\t\t    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {\n\t\t\tpb->bzh = bzh;\n\t\t\tpb->zbuffer = (u_char *)pb->zbuf2;\n\t\t\tp->buffer = pb->zbuffer + sizeof(*bzh);\n\t\t\t*cc = bzh->bzh_kernel_len;\n\t\t\treturn (1);\n\t\t}\n\t}\n\t*cc = 0;\n\treturn (0);\n}\n\n/*\n * pcap_next_zbuf() -- Similar to pcap_next_zbuf_shm(), except wait using\n * select() for data or a timeout, and possibly force rotation of the buffer\n * in the event we time out or are in immediate mode.  Invoke the shared\n * memory check before doing system calls in order to avoid doing avoidable\n * work.\n */\nstatic int\npcap_next_zbuf(pcap_t *p, u_int *cc)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tstruct bpf_zbuf bz;\n\tstruct timeval tv;\n\tstruct timespec cur;\n\tfd_set r_set;\n\tint data, r;\n\tlong expire, tmout;\n\n#define TSTOMILLI(ts) (((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))\n\t/*\n\t * Start out by seeing whether anything is waiting by checking the\n\t * next shared memory buffer for data.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * If a previous sleep was interrupted due to signal delivery, make\n\t * sure that the timeout gets adjusted accordingly.  This requires\n\t * that we analyze when the timeout should be been expired, and\n\t * subtract the current time from that.  If after this operation,\n\t * our timeout is less than or equal to zero, handle it like a\n\t * regular timeout.\n\t */\n\ttmout = p->opt.timeout;\n\tif (tmout)\n\t\t(void) clock_gettime(CLOCK_MONOTONIC, &cur);\n\tif (pb->interrupted && p->opt.timeout) {\n\t\texpire = TSTOMILLI(&pb->firstsel) + p->opt.timeout;\n\t\ttmout = expire - TSTOMILLI(&cur);\n#undef TSTOMILLI\n\t\tif (tmout <= 0) {\n\t\t\tpb->interrupted = 0;\n\t\t\tdata = pcap_next_zbuf_shm(p, cc);\n\t\t\tif (data)\n\t\t\t\treturn (data);\n\t\t\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"BIOCROTZBUF\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\treturn (pcap_next_zbuf_shm(p, cc));\n\t\t}\n\t}\n\t/*\n\t * No data in the buffer, so must use select() to wait for data or\n\t * the next timeout.  Note that we only call select if the handle\n\t * is in blocking mode.\n\t */\n\tif (!pb->nonblock) {\n\t\tFD_ZERO(&r_set);\n\t\tFD_SET(p->fd, &r_set);\n\t\tif (tmout != 0) {\n\t\t\ttv.tv_sec = tmout / 1000;\n\t\t\ttv.tv_usec = (tmout * 1000) % 1000000;\n\t\t}\n\t\tr = select(p->fd + 1, &r_set, NULL, NULL,\n\t\t    p->opt.timeout != 0 ? &tv : NULL);\n\t\tif (r < 0 && errno == EINTR) {\n\t\t\tif (!pb->interrupted && p->opt.timeout) {\n\t\t\t\tpb->interrupted = 1;\n\t\t\t\tpb->firstsel = cur;\n\t\t\t}\n\t\t\treturn (0);\n\t\t} else if (r < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"select\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tpb->interrupted = 0;\n\t/*\n\t * Check again for data, which may exist now that we've either been\n\t * woken up as a result of data or timed out.  Try the \"there's data\"\n\t * case first since it doesn't require a system call.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * Try forcing a buffer rotation to dislodge timed out or immediate\n\t * data.\n\t */\n\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCROTZBUF\");\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (pcap_next_zbuf_shm(p, cc));\n}\n\n/*\n * Notify kernel that we are done with the buffer.  We don't reset zbuffer so\n * that we know which buffer to use next time around.\n */\nstatic int\npcap_ack_zbuf(pcap_t *p)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\n\tatomic_store_rel_int(&pb->bzh->bzh_user_gen,\n\t    pb->bzh->bzh_kernel_gen);\n\tpb->bzh = NULL;\n\tp->buffer = NULL;\n\treturn (0);\n}\n#endif /* HAVE_ZEROCOPY_BPF */\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_bpf);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_bpf;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_bpf;\n#ifdef BIOCSTSTAMP\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t */\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"malloc\");\n\t\tfree(p);\n\t\treturn (NULL);\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\tp->tstamp_precision_count = 2;\n#endif /* BIOCSTSTAMP */\n\treturn (p);\n}\n\n/*\n * On success, returns a file descriptor for a BPF device.\n * On failure, returns a PCAP_ERROR_ value, and sets p->errbuf.\n */\nstatic int\nbpf_open(char *errbuf)\n{\n\tint fd = -1;\n\tstatic const char cloning_device[] = \"/dev/bpf\";\n\tu_int n = 0;\n\tchar device[sizeof \"/dev/bpf0000000000\"];\n\tstatic int no_cloning_bpf = 0;\n\n#ifdef _AIX\n\t/*\n\t * Load the bpf driver, if it isn't already loaded,\n\t * and create the BPF device entries, if they don't\n\t * already exist.\n\t */\n\tif (bpf_load(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n#endif\n\n\t/*\n\t * First, unless we've already tried opening /dev/bpf and\n\t * gotten ENOENT, try opening /dev/bpf.\n\t * If it fails with ENOENT, remember that, so we don't try\n\t * again, and try /dev/bpfN.\n\t */\n\tif (!no_cloning_bpf &&\n\t    (fd = open(cloning_device, O_RDWR)) == -1 &&\n\t    ((errno != EACCES && errno != ENOENT) ||\n\t     (fd = open(cloning_device, O_RDONLY)) == -1)) {\n\t\tif (errno != ENOENT) {\n\t\t\tif (errno == EACCES) {\n\t\t\t\tfd = PCAP_ERROR_PERM_DENIED;\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Attempt to open %s failed - root privileges may be required\",\n\t\t\t\t    cloning_device);\n\t\t\t} else {\n\t\t\t\tfd = PCAP_ERROR;\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"(cannot open device) %s\", cloning_device);\n\t\t\t}\n\t\t\treturn (fd);\n\t\t}\n\t\tno_cloning_bpf = 1;\n\t}\n\n\tif (no_cloning_bpf) {\n\t\t/*\n\t\t * We don't have /dev/bpf.\n\t\t * Go through all the /dev/bpfN minors and find one\n\t\t * that isn't in use.\n\t\t */\n\t\tdo {\n\t\t\t(void)snprintf(device, sizeof(device), \"/dev/bpf%u\", n++);\n\t\t\t/*\n\t\t\t * Initially try a read/write open (to allow the inject\n\t\t\t * method to work).  If that fails due to permission\n\t\t\t * issues, fall back to read-only.  This allows a\n\t\t\t * non-root user to be granted specific access to pcap\n\t\t\t * capabilities via file permissions.\n\t\t\t *\n\t\t\t * XXX - we should have an API that has a flag that\n\t\t\t * controls whether to open read-only or read-write,\n\t\t\t * so that denial of permission to send (or inability\n\t\t\t * to send, if sending packets isn't supported on\n\t\t\t * the device in question) can be indicated at open\n\t\t\t * time.\n\t\t\t */\n\t\t\tfd = open(device, O_RDWR);\n\t\t\tif (fd == -1 && errno == EACCES)\n\t\t\t\tfd = open(device, O_RDONLY);\n\t\t} while (fd < 0 && errno == EBUSY);\n\t}\n\n\t/*\n\t * XXX better message for all minors used\n\t */\n\tif (fd < 0) {\n\t\tswitch (errno) {\n\n\t\tcase ENOENT:\n\t\t\tif (n == 1) {\n\t\t\t\t/*\n\t\t\t\t * /dev/bpf0 doesn't exist, which\n\t\t\t\t * means we probably have no BPF\n\t\t\t\t * devices.\n\t\t\t\t */\n\t\t\t\tfd = PCAP_ERROR_CAPTURE_NOTSUP;\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"(there are no BPF devices)\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We got EBUSY on at least one\n\t\t\t\t * BPF device, so we have BPF\n\t\t\t\t * devices, but all the ones\n\t\t\t\t * that exist are busy.\n\t\t\t\t */\n\t\t\t\tfd = PCAP_ERROR;\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"(all BPF devices are busy)\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EACCES:\n\t\t\t/*\n\t\t\t * Got EACCES on the last device we tried,\n\t\t\t * and EBUSY on all devices before that,\n\t\t\t * if any.\n\t\t\t */\n\t\t\tfd = PCAP_ERROR_PERM_DENIED;\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to open %s failed - root privileges may be required\",\n\t\t\t    device);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Some other problem.\n\t\t\t */\n\t\t\tfd = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"(cannot open BPF device) %s\", device);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (fd);\n}\n\n/*\n * Bind a network adapter to a BPF device, given a descriptor for the\n * BPF device and the name of the network adapter.\n *\n * Use BIOCSETLIF if available (meaning \"on Solaris\"), as it supports\n * longer device names and binding to devices in other zones.\n *\n * If the name is longer than will fit, return PCAP_ERROR_NO_SUCH_DEVICE\n * before trying to bind the interface, as there cannot be such a device.\n *\n * If the attempt succeeds, return BPF_BIND_SUCCEEDED.\n *\n * If the attempt fails:\n *\n *    if it fails with ENOBUFS, return BPF_BIND_BUFFER_TOO_BIG, and\n *    fill in an error message, as the buffer being requested is too\n *    large - our caller may try a smaller buffer if no buffer size\n *    was explicitly specified.\n *\n *    otherwise, return the appropriate PCAP_ERROR_ code and\n *    fill in an error message.\n */\n#define BPF_BIND_SUCCEEDED\t0\n#define BPF_BIND_BUFFER_TOO_BIG\t1\n\nstatic int\nbpf_bind(int fd, const char *name, char *errbuf)\n{\n\tint status;\n#ifdef LIFNAMSIZ\n\tstruct lifreq ifr;\n\tconst char *ifname = name;\n\n  #if defined(ZONENAME_MAX) && defined(lifr_zoneid)\n\tchar *zonesep;\n\n\t/*\n\t * We have support for zones.\n\t * Retrieve the zoneid of the zone we are currently executing in.\n\t */\n\tif ((ifr.lifr_zoneid = getzoneid()) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getzoneid()\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Check if the given source datalink name has a '/' separated\n\t * zonename prefix string.  The zonename prefixed source datalink can\n\t * be used by pcap consumers in the Solaris global zone to capture\n\t * traffic on datalinks in non-global zones.  Non-global zones\n\t * do not have access to datalinks outside of their own namespace.\n\t */\n\tif ((zonesep = strchr(name, '/')) != NULL) {\n\t\tchar *zname;\n\t\tptrdiff_t znamelen;\n\n\t\tif (ifr.lifr_zoneid != GLOBAL_ZONEID) {\n\t\t\t/*\n\t\t\t * We treat this as a generic error rather\n\t\t\t * than as \"permission denied\" because\n\t\t\t * this isn't a case of \"you don't have\n\t\t\t * enough permission to capture on this\n\t\t\t * device, so you'll have to do something\n\t\t\t * to get that permission\" (such as\n\t\t\t * configuring the system to allow non-root\n\t\t\t * users to capture traffic), it's a case\n\t\t\t * of \"nobody has permission to do this,\n\t\t\t * so there's nothing to do to fix it\n\t\t\t * other than running the capture program\n\t\t\t * in the global zone or the zone containing\n\t\t\t * the adapter\".\n\t\t\t *\n\t\t\t * (And, yes, this is a real issue; for example,\n\t\t\t * Wireshark might make platform-specific suggestions\n\t\t\t * on how to fix a PCAP_ERROR_PERM_DENIED problem,\n\t\t\t * none of which will help here.)\n\t\t\t */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"zonename/linkname only valid in global zone.\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tznamelen = zonesep - name;\n\t\tzname = malloc(znamelen + 1);\n\t\tif (zname == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tmemcpy(zname, name, znamelen + 1);\n\t\tzname[znamelen] = '\\0';\n\t\tifr.lifr_zoneid = getzoneidbyname(zname);\n\t\tif (ifr.lifr_zoneid == -1) {\n\t\t\tswitch (errno) {\n\n\t\t\tcase EINVAL:\n\t\t\tcase ENAMETOOLONG:\n\t\t\t\t/*\n\t\t\t\t * If the name's length exceeds\n\t\t\t\t * ZONENAMEMAX, clearly there cannot\n\t\t\t\t * be such a zone; it's not clear that\n\t\t\t\t * \"that name's too long for a zone\"\n\t\t\t\t * is more informative than \"there's\n\t\t\t\t * no such zone\".\n\t\t\t\t */\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"There is no zone named \\\"%s\\\"\",\n\t\t\t\t    zname);\n\n\t\t\t\t/*\n\t\t\t\t * No such zone means the name\n\t\t\t\t * refers to a non-existent interface.\n\t\t\t\t */\n\t\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"getzoneidbyname(%s)\", zname);\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(zname);\n\t\t\treturn (status);\n\t\t}\n\t\tfree(zname);\n\n\t\t/*\n\t\t * To bind to this interface, we set the ifr.lifr_zoneid\n\t\t * to the zone ID of its zone (done above), and we set\n\t\t * ifr.lifr_name to the name of the interface within that\n\t\t * zone (done below, using ifname).\n\t\t */\n\t\tifname = zonesep + 1;\n\t}\n  #endif\n\n\tif (strlen(ifname) >= sizeof(ifr.lifr_name)) {\n\t\t/* The name is too long, so it can't possibly exist. */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\t(void)pcapint_strlcpy(ifr.lifr_name, ifname, sizeof(ifr.lifr_name));\n\tstatus = ioctl(fd, BIOCSETLIF, (caddr_t)&ifr);\n#else\n\tstruct ifreq ifr;\n\n\tif (strlen(name) >= sizeof(ifr.ifr_name)) {\n\t\t/* The name is too long, so it can't possibly exist. */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\t(void)pcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\tstatus = ioctl(fd, BIOCSETIF, (caddr_t)&ifr);\n#endif\n\n\tif (status < 0) {\n\t\tswitch (errno) {\n\n#if defined(HAVE_SOLARIS)\n\t\t/*\n\t\t * For some reason, Solaris 11 appears to return ESRCH\n\t\t * for unknown devices.\n\t\t */\n\t\tcase ESRCH:\n#else\n\t\t/*\n\t\t * The *BSDs (including CupertinoBSD a/k/a Darwin)\n\t\t * return ENXIO for unknown devices.\n\t\t */\n\t\tcase ENXIO:\n#endif\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t *\n\t\t\t * There's nothing more to say, so clear out the\n\t\t\t * error message.\n\t\t\t */\n\t\t\terrbuf[0] = '\\0';\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase ENETDOWN:\n\t\t\t/*\n\t\t\t * Return a \"network down\" indication, so that\n\t\t\t * the application can report that rather than\n\t\t\t * saying we had a mysterious failure and\n\t\t\t * suggest that they report a problem to the\n\t\t\t * libpcap developers.\n\t\t\t */\n\t\t\treturn (PCAP_ERROR_IFACE_NOT_UP);\n\n\t\tcase ENOBUFS:\n\t\t\t/*\n\t\t\t * The buffer size is too big.\n\t\t\t * Return a special indication so that, if we're\n\t\t\t * trying to crank the buffer size down, we know\n\t\t\t * we have to continue; add an error message that\n\t\t\t * tells the user what needs to be fixed.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"The requested buffer size for %s is too large\",\n\t\t\t    name);\n\t\t\treturn (BPF_BIND_BUFFER_TOO_BIG);\n\n\t\tdefault:\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Binding interface %s to BPF device failed\",\n\t\t\t    name);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\treturn (BPF_BIND_SUCCEEDED);\n}\n\n/*\n * Open and bind to a device; used if we're not actually going to use\n * the device, but are just testing whether it can be opened, or opening\n * it to get information about it.\n *\n * Returns an error code on failure (always negative), and an FD for\n * the now-bound BPF device on success (always non-negative).\n */\nstatic int\nbpf_open_and_bind(const char *name, char *errbuf)\n{\n\tint fd;\n\tint status;\n\n\t/*\n\t * First, open a BPF device.\n\t */\n\tfd = bpf_open(errbuf);\n\tif (fd < 0)\n\t\treturn (fd);\t/* fd is the appropriate error code */\n\n\t/*\n\t * Now bind to the device.\n\t */\n\tstatus = bpf_bind(fd, name, errbuf);\n\tif (status != BPF_BIND_SUCCEEDED) {\n\t\tclose(fd);\n\t\tif (status == BPF_BIND_BUFFER_TOO_BIG) {\n\t\t\t/*\n\t\t\t * We didn't specify a buffer size, so\n\t\t\t * this *really* shouldn't fail because\n\t\t\t * there's no buffer space.  Fail.\n\t\t\t */\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\treturn (status);\n\t}\n\n\t/*\n\t * Success.\n\t */\n\treturn (fd);\n}\n\n#ifdef __APPLE__\nstatic int\ndevice_exists(int fd, const char *name, char *errbuf)\n{\n\tint status;\n\tstruct ifreq ifr;\n\n\tif (strlen(name) >= sizeof(ifr.ifr_name)) {\n\t\t/* The name is too long, so it can't possibly exist. */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\t(void)pcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\tstatus = ioctl(fd, SIOCGIFFLAGS, (caddr_t)&ifr);\n\n\tif (status < 0) {\n\t\tif (errno == ENXIO || errno == EINVAL) {\n\t\t\t/*\n\t\t\t * macOS and *BSD return one of those two\n\t\t\t * errors if the device doesn't exist.\n\t\t\t * Don't fill in an error, as this is\n\t\t\t * an \"expected\" condition.\n\t\t\t */\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t\t}\n\n\t\t/*\n\t\t * Some other error - provide a message for it, as\n\t\t * it's \"unexpected\".\n\t\t */\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"Can't get interface flags on %s\", name);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * The device exists.\n\t */\n\treturn (0);\n}\n#endif\n\n#ifdef BIOCGDLTLIST\nstatic int\nget_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)\n{\n\tmemset(bdlp, 0, sizeof(*bdlp));\n\tif (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) == 0) {\n\t\tu_int i;\n\t\tint is_ethernet;\n\n\t\tbdlp->bfl_list = (u_int *) malloc(sizeof(u_int) * (bdlp->bfl_len + 1));\n\t\tif (bdlp->bfl_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\tif (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCGDLTLIST\");\n\t\t\tfree(bdlp->bfl_list);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/*\n\t\t * OK, for real Ethernet devices, add DLT_DOCSIS to the\n\t\t * list, so that an application can let you choose it,\n\t\t * in case you're capturing DOCSIS traffic that a Cisco\n\t\t * Cable Modem Termination System is putting out onto\n\t\t * an Ethernet (it doesn't put an Ethernet header onto\n\t\t * the wire, it puts raw DOCSIS frames out on the wire\n\t\t * inside the low-level Ethernet framing).\n\t\t *\n\t\t * A \"real Ethernet device\" is defined here as a device\n\t\t * that has a link-layer type of DLT_EN10MB and that has\n\t\t * no alternate link-layer types; that's done to exclude\n\t\t * 802.11 interfaces (which might or might not be the\n\t\t * right thing to do, but I suspect it is - Ethernet <->\n\t\t * 802.11 bridges would probably badly mishandle frames\n\t\t * that don't have Ethernet headers).\n\t\t *\n\t\t * On Solaris with BPF, Ethernet devices also offer\n\t\t * DLT_IPNET, so we, if DLT_IPNET is defined, we don't\n\t\t * treat it as an indication that the device isn't an\n\t\t * Ethernet.\n\t\t */\n\t\tif (v == DLT_EN10MB) {\n\t\t\tis_ethernet = 1;\n\t\t\tfor (i = 0; i < bdlp->bfl_len; i++) {\n\t\t\t\tif (bdlp->bfl_list[i] != DLT_EN10MB\n#ifdef DLT_IPNET\n\t\t\t\t    && bdlp->bfl_list[i] != DLT_IPNET\n#endif\n\t\t\t\t    ) {\n\t\t\t\t\tis_ethernet = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_ethernet) {\n\t\t\t\t/*\n\t\t\t\t * We reserved one more slot at the end of\n\t\t\t\t * the list.\n\t\t\t\t */\n\t\t\t\tbdlp->bfl_list[bdlp->bfl_len] = DLT_DOCSIS;\n\t\t\t\tbdlp->bfl_len++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * EINVAL just means \"we don't support this ioctl on\n\t\t * this device\"; don't treat it as an error.\n\t\t */\n\t\tif (errno != EINVAL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCGDLTLIST\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\treturn (0);\n}\n#endif\n\n#if defined(__APPLE__)\nstatic int\npcap_can_set_rfmon_bpf(pcap_t *p)\n{\n\tstruct utsname osinfo;\n\tint fd;\n#ifdef BIOCGDLTLIST\n\tstruct bpf_dltlist bdl;\n\tint err;\n#endif\n\n\t/*\n\t * The joys of monitor mode on Mac OS X/OS X/macOS.\n\t *\n\t * Prior to 10.4, it's not supported at all.\n\t *\n\t * In 10.4, if adapter enN supports monitor mode, there's a\n\t * wltN adapter corresponding to it; you open it, instead of\n\t * enN, to get monitor mode.  You get whatever link-layer\n\t * headers it supplies.\n\t *\n\t * In 10.5, and, we assume, later releases, if adapter enN\n\t * supports monitor mode, it offers, among its selectable\n\t * DLT_ values, values that let you get the 802.11 header;\n\t * selecting one of those values puts the adapter into monitor\n\t * mode (i.e., you can't get 802.11 headers except in monitor\n\t * mode, and you can't get Ethernet headers in monitor mode).\n\t */\n\tif (uname(&osinfo) == -1) {\n\t\t/*\n\t\t * Can't get the OS version; just say \"no\".\n\t\t */\n\t\treturn (0);\n\t}\n\t/*\n\t * We assume osinfo.sysname is \"Darwin\", because\n\t * __APPLE__ is defined.  We just check the version.\n\t */\n\tif (osinfo.release[0] < '8' && osinfo.release[1] == '.') {\n\t\t/*\n\t\t * 10.3 (Darwin 7.x) or earlier.\n\t\t * Monitor mode not supported.\n\t\t */\n\t\treturn (0);\n\t}\n\tif (osinfo.release[0] == '8' && osinfo.release[1] == '.') {\n\t\tchar *wlt_name;\n\t\tint status;\n\n\t\t/*\n\t\t * 10.4 (Darwin 8.x).  s/en/wlt/, and check\n\t\t * whether the device exists.\n\t\t */\n\t\tif (strncmp(p->opt.device, \"en\", 2) != 0) {\n\t\t\t/*\n\t\t\t * Not an enN device; no monitor mode.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\tif (fd == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"socket\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tif (pcapint_asprintf(&wlt_name, \"wlt%s\", p->opt.device + 2) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tstatus = device_exists(fd, wlt_name, p->errbuf);\n\t\tfree(wlt_name);\n\t\tclose(fd);\n\t\tif (status != 0) {\n\t\t\tif (status == PCAP_ERROR_NO_SUCH_DEVICE)\n\t\t\t\treturn (0);\n\n\t\t\t/*\n\t\t\t * Error.\n\t\t\t */\n\t\t\treturn (status);\n\t\t}\n\t\treturn (1);\n\t}\n\n#ifdef BIOCGDLTLIST\n\t/*\n\t * Everything else is 10.5 or later; for those,\n\t * we just open the enN device, and check whether\n\t * we have any 802.11 devices.\n\t *\n\t * First, open a BPF device.\n\t */\n\tfd = bpf_open(p->errbuf);\n\tif (fd < 0)\n\t\treturn (fd);\t/* fd is the appropriate error code */\n\n\t/*\n\t * Now bind to the device.\n\t */\n\terr = bpf_bind(fd, p->opt.device, p->errbuf);\n\tif (err != BPF_BIND_SUCCEEDED) {\n\t\tclose(fd);\n\t\tif (err == BPF_BIND_BUFFER_TOO_BIG) {\n\t\t\t/*\n\t\t\t * We didn't specify a buffer size, so\n\t\t\t * this *really* shouldn't fail because\n\t\t\t * there's no buffer space.  Fail.\n\t\t\t */\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\treturn (err);\n\t}\n\n\t/*\n\t * We know the default link type -- now determine all the DLTs\n\t * this interface supports.  If this fails with EINVAL, it's\n\t * not fatal; we just don't get to use the feature later.\n\t * (We don't care about DLT_DOCSIS, so we pass DLT_NULL\n\t * as the default DLT for this adapter.)\n\t */\n\tif (get_dlt_list(fd, DLT_NULL, &bdl, p->errbuf) == PCAP_ERROR) {\n\t\tclose(fd);\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (find_802_11(&bdl) != -1) {\n\t\t/*\n\t\t * We have an 802.11 DLT, so we can set monitor mode.\n\t\t */\n\t\tfree(bdl.bfl_list);\n\t\tclose(fd);\n\t\treturn (1);\n\t}\n\tfree(bdl.bfl_list);\n\tclose(fd);\n#endif /* BIOCGDLTLIST */\n\treturn (0);\n}\n#elif defined(HAVE_BSD_IEEE80211)\nstatic int\npcap_can_set_rfmon_bpf(pcap_t *p)\n{\n\tint ret;\n\n\tret = monitor_mode(p, 0);\n\tif (ret == PCAP_ERROR_RFMON_NOTSUP)\n\t\treturn (0);\t/* not an error, just a \"can't do\" */\n\tif (ret == 0)\n\t\treturn (1);\t/* success */\n\treturn (ret);\n}\n#else\nstatic int\npcap_can_set_rfmon_bpf(pcap_t *p _U_)\n{\n\treturn (0);\n}\n#endif\n\nstatic int\npcap_stats_bpf(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct bpf_stat s;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  This includes packets later dropped\n\t * because we ran out of buffer space.\n\t *\n\t * \"ps_drop\" counts packets dropped inside the BPF device\n\t * because we ran out of buffer space.  It doesn't count\n\t * packets dropped by the interface driver.  It counts\n\t * only packets that passed the filter.\n\t *\n\t * Both statistics include packets not yet read from the kernel\n\t * by libpcap, and thus not yet seen by the application.\n\t */\n\tif (ioctl(p->fd, BIOCGSTATS, (caddr_t)&s) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCGSTATS\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * On illumos, NetBSD and Solaris these values are 64-bit, but struct\n\t * pcap_stat is what it is, so the integer precision loss is expected.\n\t */\n\tps->ps_recv = (u_int)s.bs_recv;\n\tps->ps_drop = (u_int)s.bs_drop;\n\tps->ps_ifdrop = 0;\n\treturn (0);\n}\n\nstatic int\npcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tu_int cc;\n\tint n = 0;\n\tregister u_char *bp, *ep;\n\tu_char *datap;\n#ifdef PCAP_FDDIPAD\n\tregister u_int pad;\n#endif\n\n again:\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (p->break_loop) {\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t * that we were told to break out of the loop.\n\t\t */\n\t\tp->break_loop = 0;\n\t\treturn (PCAP_ERROR_BREAK);\n\t}\n\tcc = p->cc;\n\tif (p->cc == 0) {\n\t\t/*\n\t\t * When reading without zero-copy from a file descriptor, we\n\t\t * use a single buffer and return a length of data in the\n\t\t * buffer.  With zero-copy, we update the p->buffer pointer\n\t\t * to point at whatever underlying buffer contains the next\n\t\t * data and update cc to reflect the data found in the\n\t\t * buffer.\n\t\t */\n#ifdef HAVE_ZEROCOPY_BPF\n\t\tif (pb->zerocopy) {\n\t\t\tint next_zbuf_ret;\n\n\t\t\tif (p->buffer != NULL)\n\t\t\t\tpcap_ack_zbuf(p);\n\t\t\tnext_zbuf_ret = pcap_next_zbuf(p, &cc);\n\t\t\tif (next_zbuf_ret == 0)\n\t\t\t\tgoto again;\n\t\t\tif (next_zbuf_ret < 0)\n\t\t\t\treturn (next_zbuf_ret);\n\t\t} else\n#endif\n\t\t{\n\t\t\tssize_t read_ret;\n\n\t\t\tread_ret = read(p->fd, p->buffer, p->bufsize);\n\t\t\tif (read_ret < 0) {\n\t\t\t\t/* Don't choke when we get ptraced */\n\t\t\t\tswitch (errno) {\n\n\t\t\t\tcase EINTR:\n\t\t\t\t\tgoto again;\n\n#ifdef _AIX\n\t\t\t\tcase EFAULT:\n\t\t\t\t\t/*\n\t\t\t\t\t * Sigh.  More AIX wonderfulness.\n\t\t\t\t\t *\n\t\t\t\t\t * For some unknown reason the\n\t\t\t\t\t * uiomove() operation in the bpf\n\t\t\t\t\t * kernel extension used to copy\n\t\t\t\t\t * the buffer into user space\n\t\t\t\t\t * sometimes returns EFAULT. I have\n\t\t\t\t\t * no idea why this is the case given\n\t\t\t\t\t * that a kernel debugger shows the\n\t\t\t\t\t * user buffer is correct. This\n\t\t\t\t\t * problem appears to be mostly\n\t\t\t\t\t * mitigated by the memset of\n\t\t\t\t\t * the buffer before it is first used.\n\t\t\t\t\t * Very strange.... Shaun Clowes\n\t\t\t\t\t *\n\t\t\t\t\t * In any case this means that we\n\t\t\t\t\t * shouldn't treat EFAULT as a fatal\n\t\t\t\t\t * error; as we don't have an API for\n\t\t\t\t\t * returning a \"some packets were\n\t\t\t\t\t * dropped since the last packet you\n\t\t\t\t\t * saw\" indication, we just ignore\n\t\t\t\t\t * EFAULT and keep reading.\n\t\t\t\t\t */\n\t\t\t\t\tgoto again;\n#endif\n\n\t\t\t\tcase EWOULDBLOCK:\n\t\t\t\t\treturn (0);\n\n\t\t\t\tcase ENXIO:\t/* FreeBSD, DragonFly BSD, and Darwin */\n\t\t\t\tcase EIO:\t/* OpenBSD */\n\t\t\t\t\t\t/* NetBSD appears not to return an error in this case */\n\t\t\t\t\t/*\n\t\t\t\t\t * The device on which we're capturing\n\t\t\t\t\t * went away.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - we should really return\n\t\t\t\t\t * an appropriate error for that,\n\t\t\t\t\t * but pcap_dispatch() etc. aren't\n\t\t\t\t\t * documented as having error returns\n\t\t\t\t\t * other than PCAP_ERROR or\n\t\t\t\t\t * PCAP_ERROR_BREAK.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"The interface disappeared\");\n\t\t\t\t\treturn (PCAP_ERROR);\n\n#if defined(sun) && !defined(BSD) && !defined(__svr4__) && !defined(__SVR4)\n\t\t\t\t/*\n\t\t\t\t * Due to a SunOS bug, after 2^31 bytes, the\n\t\t\t\t * kernel file offset overflows and read\n\t\t\t\t * fails with EINVAL.\n\t\t\t\t * The lseek() to 0 will fix things.\n\t\t\t\t */\n\t\t\t\tcase EINVAL:\n\t\t\t\t\tif (lseek(p->fd, 0L, SEEK_CUR) +\n\t\t\t\t\t    p->bufsize < 0) {\n\t\t\t\t\t\t(void)lseek(p->fd, 0L, SEEK_SET);\n\t\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through */\n#endif\n\t\t\t\t}\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    errno, \"read\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At this point, read_ret is guaranteed to be\n\t\t\t * >= 0 and < p->bufsize; p->bufsize is a u_int,\n\t\t\t * so its value is guaranteed to fit in cc, which\n\t\t\t * is also a u_int.\n\t\t\t */\n\t\t\tcc = (u_int)read_ret;\n\t\t}\n\t\tbp = p->buffer;\n\t} else\n\t\tbp = p->bp;\n\n\t/*\n\t * Loop through each packet.\n\t *\n\t * This assumes that a single buffer of packets will have\n\t * <= INT_MAX packets, so the packet count doesn't overflow.\n\t */\n#ifdef BIOCSTSTAMP\n#define bhp ((struct bpf_xhdr *)bp)\n#else\n#define bhp ((struct bpf_hdr *)bp)\n#endif\n\tep = bp + cc;\n#ifdef PCAP_FDDIPAD\n\tpad = p->fddipad;\n#endif\n\twhile (bp < ep) {\n\t\tregister u_int caplen, hdrlen;\n\t\tsize_t packet_bytes;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return PCAP_ERROR_BREAK\n\t\t * to indicate that we were told to break out of the loop,\n\t\t * otherwise leave the flag set, so that the *next* call\n\t\t * will break out of the loop without having read any\n\t\t * packets, and return the number of packets we've\n\t\t * processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tp->bp = bp;\n\t\t\tp->cc = (u_int)(ep - bp);\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t\t} else\n\t\t\t\treturn (n);\n\t\t}\n\n\t\tcaplen = bhp->bh_caplen;\n\t\thdrlen = bhp->bh_hdrlen;\n\t\tdatap = bp + hdrlen;\n\n\t\t/*\n\t\t * Compute the number of bytes for this packet in\n\t\t * the buffer.\n\t\t *\n\t\t * That's the sum of the header length and the packet\n\t\t * data length plus, if this is not the last packet,\n\t\t * the padding required to align the next packet on\n\t\t * the appropriate boundary.\n\t\t *\n\t\t * That means that it should be the minimum of the\n\t\t * number of bytes left in the buffer (ep - bp) and the\n\t\t * rounded-up sum of the header and packet data lengths.\n\t\t */\n\t\tpacket_bytes = min((u_int)(ep - bp), BPF_WORDALIGN(caplen + hdrlen));\n\n\t\t/*\n\t\t * Short-circuit evaluation: if using BPF filter\n\t\t * in kernel, no need to do it now - we already know\n\t\t * the packet passed the filter.\n\t\t *\n#ifdef PCAP_FDDIPAD\n\t\t * Note: the filter code was generated assuming\n\t\t * that p->fddipad was the amount of padding\n\t\t * before the header, as that's what's required\n\t\t * in the kernel, so we run the filter before\n\t\t * skipping that padding.\n#endif\n\t\t */\n\t\tif (pb->filtering_in_kernel ||\n\t\t    pcapint_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {\n\t\t\tstruct pcap_pkthdr pkthdr;\n#ifdef BIOCSTSTAMP\n\t\t\tstruct bintime bt;\n\n\t\t\tbt.sec = bhp->bh_tstamp.bt_sec;\n\t\t\tbt.frac = bhp->bh_tstamp.bt_frac;\n\t\t\tif (p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {\n\t\t\t\tstruct timespec ts;\n\n\t\t\t\tbintime2timespec(&bt, &ts);\n\t\t\t\tpkthdr.ts.tv_sec = ts.tv_sec;\n\t\t\t\tpkthdr.ts.tv_usec = ts.tv_nsec;\n\t\t\t} else {\n\t\t\t\tstruct timeval tv;\n\n\t\t\t\tbintime2timeval(&bt, &tv);\n\t\t\t\tpkthdr.ts.tv_sec = tv.tv_sec;\n\t\t\t\tpkthdr.ts.tv_usec = tv.tv_usec;\n\t\t\t}\n#else\n\t\t\tpkthdr.ts.tv_sec = bhp->bh_tstamp.tv_sec;\n#ifdef _AIX\n\t\t\t/*\n\t\t\t * AIX's BPF returns seconds/nanoseconds time\n\t\t\t * stamps, not seconds/microseconds time stamps.\n\t\t\t */\n\t\t\tpkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec/1000;\n#else\n\t\t\t/*\n\t\t\t * On NetBSD the former (timeval.tv_usec) is an int via\n\t\t\t * suseconds_t and the latter (bpf_timeval.tv_usec) is\n\t\t\t * a long.  In any case, the value is supposed to be\n\t\t\t * within the [0 .. 999999] interval.\n\t\t\t */\n\t\t\tpkthdr.ts.tv_usec = (suseconds_t)bhp->bh_tstamp.tv_usec;\n#endif\n#endif /* BIOCSTSTAMP */\n#ifdef PCAP_FDDIPAD\n\t\t\tif (caplen > pad)\n\t\t\t\tpkthdr.caplen = caplen - pad;\n\t\t\telse\n\t\t\t\tpkthdr.caplen = 0;\n\t\t\tif (bhp->bh_datalen > pad)\n\t\t\t\tpkthdr.len = bhp->bh_datalen - pad;\n\t\t\telse\n\t\t\t\tpkthdr.len = 0;\n\t\t\tdatap += pad;\n#else\n\t\t\tpkthdr.caplen = caplen;\n\t\t\tpkthdr.len = bhp->bh_datalen;\n#endif\n\t\t\t(*callback)(user, &pkthdr, datap);\n\t\t\tbp += packet_bytes;\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tp->bp = bp;\n\t\t\t\tp->cc = (u_int)(ep - bp);\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Skip this packet.\n\t\t\t */\n\t\t\tbp += packet_bytes;\n\t\t}\n\t}\n#undef bhp\n\tp->cc = 0;\n\treturn (n);\n}\n\nstatic int\npcap_inject_bpf(pcap_t *p, const void *buf, int size)\n{\n\tint ret;\n\n\tret = (int)write(p->fd, buf, size);\n#ifdef __APPLE__\n\tif (ret == -1 && errno == EAFNOSUPPORT) {\n\t\t/*\n\t\t * In some versions of macOS, there's a bug wherein setting\n\t\t * the BIOCSHDRCMPLT flag causes writes to fail; see, for\n\t\t * example:\n\t\t *\n\t\t *\thttp://cerberus.sourcefire.com/~jeff/archives/patches/macosx/BIOCSHDRCMPLT-10.3.3.patch\n\t\t *\n\t\t * So, if, on macOS, we get EAFNOSUPPORT from the write, we\n\t\t * assume it's due to that bug, and turn off that flag\n\t\t * and try again.  If we succeed, it either means that\n\t\t * somebody applied the fix from that URL, or other patches\n\t\t * for that bug from\n\t\t *\n\t\t *\thttp://cerberus.sourcefire.com/~jeff/archives/patches/macosx/\n\t\t *\n\t\t * and are running a Darwin kernel with those fixes, or\n\t\t * that Apple fixed the problem in some macOS release.\n\t\t */\n\t\tu_int spoof_eth_src = 0;\n\n\t\tif (ioctl(p->fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"send: can't turn off BIOCSHDRCMPLT\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/*\n\t\t * Now try the write again.\n\t\t */\n\t\tret = (int)write(p->fd, buf, size);\n\t}\n#endif /* __APPLE__ */\n\tif (ret == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (ret);\n}\n\n#ifdef _AIX\nstatic int\nbpf_odminit(char *errbuf)\n{\n\tchar *errstr;\n\n\tif (odm_initialize() == -1) {\n\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\terrstr = \"Unknown error\";\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: odm_initialize failed: %s\",\n\t\t    __func__,\n\t\t    errstr);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif ((odmlockid = odm_lock(\"/etc/objrepos/config_lock\", ODM_WAIT)) == -1) {\n\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\terrstr = \"Unknown error\";\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: odm_lock of /etc/objrepos/config_lock failed: %s\",\n\t\t    __func__,\n\t\t    errstr);\n\t\t(void)odm_terminate();\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nbpf_odmcleanup(char *errbuf)\n{\n\tchar *errstr;\n\n\tif (odm_unlock(odmlockid) == -1) {\n\t\tif (errbuf != NULL) {\n\t\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\t\terrstr = \"Unknown error\";\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: odm_unlock failed: %s\",\n\t\t\t    __func__,\n\t\t\t    errstr);\n\t\t}\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (odm_terminate() == -1) {\n\t\tif (errbuf != NULL) {\n\t\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\t\terrstr = \"Unknown error\";\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: odm_terminate failed: %s\",\n\t\t\t    __func__,\n\t\t\t    errstr);\n\t\t}\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nbpf_load(char *errbuf)\n{\n\tlong major;\n\tint *minors;\n\tint numminors, i, rc;\n\tchar buf[1024];\n\tstruct stat sbuf;\n\tstruct bpf_config cfg_bpf;\n\tstruct cfg_load cfg_ld;\n\tstruct cfg_kmod cfg_km;\n\n\t/*\n\t * This is very very close to what happens in the real implementation\n\t * but I've fixed some (unlikely) bug situations.\n\t */\n\tif (bpfloadedflag)\n\t\treturn (0);\n\n\tif (bpf_odminit(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n\n\tmajor = genmajor(BPF_NAME);\n\tif (major == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: genmajor failed\", __func__);\n\t\t(void)bpf_odmcleanup(NULL);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tminors = getminor(major, &numminors, BPF_NAME);\n\tif (!minors) {\n\t\tminors = genminor(\"bpf\", major, 0, BPF_MINORS, 1, 1);\n\t\tif (!minors) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s: genminor failed\", __func__);\n\t\t\t(void)bpf_odmcleanup(NULL);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\tif (bpf_odmcleanup(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n\n\trc = stat(BPF_NODE \"0\", &sbuf);\n\tif (rc == -1 && errno != ENOENT) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: can't stat %s\", __func__, BPF_NODE \"0\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (rc == -1 || getmajor(sbuf.st_rdev) != major) {\n\t\tfor (i = 0; i < BPF_MINORS; i++) {\n\t\t\tsnprintf(buf, sizeof(buf), \"%s%d\", BPF_NODE, i);\n\t\t\tunlink(buf);\n\t\t\tif (mknod(buf, S_IRUSR | S_IFCHR, domakedev(major, i)) == -1) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"%s: can't mknod %s\", __func__, buf);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the driver is loaded */\n\tmemset(&cfg_ld, 0x0, sizeof(cfg_ld));\n\tsnprintf(buf, sizeof(buf), \"%s/%s\", DRIVER_PATH, BPF_NAME);\n\tcfg_ld.path = buf;\n\tif ((sysconfig(SYS_QUERYLOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) ||\n\t    (cfg_ld.kmid == 0)) {\n\t\t/* Driver isn't loaded, load it now */\n\t\tif (sysconfig(SYS_SINGLELOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s: could not load driver\", __func__);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\t/* Configure the driver */\n\tcfg_km.cmd = CFG_INIT;\n\tcfg_km.kmid = cfg_ld.kmid;\n\tcfg_km.mdilen = sizeof(cfg_bpf);\n\tcfg_km.mdiptr = (void *)&cfg_bpf;\n\tfor (i = 0; i < BPF_MINORS; i++) {\n\t\tcfg_bpf.devno = domakedev(major, i);\n\t\tif (sysconfig(SYS_CFGKMOD, (void *)&cfg_km, sizeof(cfg_km)) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s: could not configure driver\", __func__);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\tbpfloadedflag = 1;\n\n\treturn (0);\n}\n#endif\n\n/*\n * Undo any operations done when opening the device when necessary.\n */\nstatic void\npcap_cleanup_bpf(pcap_t *p)\n{\n\tstruct pcap_bpf *pb = p->priv;\n#ifdef HAVE_BSD_IEEE80211\n\tint sock;\n\tstruct ifmediareq req;\n\tstruct ifreq ifr;\n#endif\n\n\tif (pb->must_do_on_close != 0) {\n\t\t/*\n\t\t * There's something we have to do when closing this\n\t\t * pcap_t.\n\t\t */\n#ifdef HAVE_BSD_IEEE80211\n\t\tif (pb->must_do_on_close & MUST_CLEAR_RFMON) {\n\t\t\t/*\n\t\t\t * We put the interface into rfmon mode;\n\t\t\t * take it out of rfmon mode.\n\t\t\t *\n\t\t\t * XXX - if somebody else wants it in rfmon\n\t\t\t * mode, this code cannot know that, so it'll take\n\t\t\t * it out of rfmon mode.\n\t\t\t */\n\t\t\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (sock == -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface flags (socket() failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t} else {\n\t\t\t\tmemset(&req, 0, sizeof(req));\n\t\t\t\tpcapint_strlcpy(req.ifm_name, pb->device,\n\t\t\t\t    sizeof(req.ifm_name));\n\t\t\t\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"Can't restore interface flags (SIOCGIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif (req.ifm_current & IFM_IEEE80211_MONITOR) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Rfmon mode is currently on;\n\t\t\t\t\t\t * turn it off.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\t\t(void)pcapint_strlcpy(ifr.ifr_name,\n\t\t\t\t\t\t    pb->device,\n\t\t\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\t\t\tifr.ifr_media =\n\t\t\t\t\t\t    req.ifm_current & ~IFM_IEEE80211_MONITOR;\n\t\t\t\t\t\tif (ioctl(sock, SIOCSIFMEDIA,\n\t\t\t\t\t\t    &ifr) == -1) {\n\t\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t    \"Can't restore interface flags (SIOCSIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n#endif /* HAVE_BSD_IEEE80211 */\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n\t\t/*\n\t\t * Attempt to destroy the usbusN interface that we created.\n\t\t */\n\t\tif (pb->must_do_on_close & MUST_DESTROY_USBUS) {\n\t\t\tif (if_nametoindex(pb->device) > 0) {\n\t\t\t\tint s;\n\n\t\t\t\ts = socket(AF_LOCAL, SOCK_DGRAM, 0);\n\t\t\t\tif (s >= 0) {\n\t\t\t\t\tpcapint_strlcpy(ifr.ifr_name, pb->device,\n\t\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\t\tioctl(s, SIOCIFDESTROY, &ifr);\n\t\t\t\t\tclose(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */\n\t\t/*\n\t\t * Take this pcap out of the list of pcaps for which we\n\t\t * have to take the interface out of some mode.\n\t\t */\n\t\tpcapint_remove_from_pcaps_to_close(p);\n\t\tpb->must_do_on_close = 0;\n\t}\n\n#ifdef HAVE_ZEROCOPY_BPF\n\tif (pb->zerocopy) {\n\t\t/*\n\t\t * Delete the mappings.  Note that p->buffer gets\n\t\t * initialized to one of the mmapped regions in\n\t\t * this case, so do not try and free it directly;\n\t\t * null it out so that pcapint_cleanup_live_common()\n\t\t * doesn't try to free it.\n\t\t */\n\t\tif (pb->zbuf1 != MAP_FAILED && pb->zbuf1 != NULL)\n\t\t\t(void) munmap(pb->zbuf1, pb->zbufsize);\n\t\tif (pb->zbuf2 != MAP_FAILED && pb->zbuf2 != NULL)\n\t\t\t(void) munmap(pb->zbuf2, pb->zbufsize);\n\t\tp->buffer = NULL;\n\t}\n#endif\n\tif (pb->device != NULL) {\n\t\tfree(pb->device);\n\t\tpb->device = NULL;\n\t}\n\tpcapint_cleanup_live_common(p);\n}\n\n#ifdef __APPLE__\nstatic int\ncheck_setif_failure(pcap_t *p, int error)\n{\n\tint fd;\n\tint err;\n\n\tif (error == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t/*\n\t\t * No such device exists.\n\t\t */\n\t\tif (p->opt.rfmon && strncmp(p->opt.device, \"wlt\", 3) == 0) {\n\t\t\t/*\n\t\t\t * Monitor mode was requested, and we're trying\n\t\t\t * to open a \"wltN\" device.  Assume that this\n\t\t\t * is 10.4 and that we were asked to open an\n\t\t\t * \"enN\" device; if that device exists, return\n\t\t\t * \"monitor mode not supported on the device\".\n\t\t\t */\n\t\t\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tchar *en_name;\n\n\t\t\t\tif (pcapint_asprintf(&en_name, \"en%s\",\n\t\t\t\t    p->opt.device + 3) == -1) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We can't find out whether there's\n\t\t\t\t\t * an underlying \"enN\" device, so\n\t\t\t\t\t * just report \"no such device\".\n\t\t\t\t\t */\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc\");\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t\t\t\t}\n\t\t\t\terr = device_exists(fd, en_name, p->errbuf);\n\t\t\t\tfree(en_name);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tif (err == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The underlying \"enN\" device\n\t\t\t\t\t\t * exists, but there's no\n\t\t\t\t\t\t * corresponding \"wltN\" device;\n\t\t\t\t\t\t * that means that the \"enN\"\n\t\t\t\t\t\t * device doesn't support\n\t\t\t\t\t\t * monitor mode, probably\n\t\t\t\t\t\t * because it's an Ethernet\n\t\t\t\t\t\t * device rather than a\n\t\t\t\t\t\t * wireless device.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terr = PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We can't find out whether there's\n\t\t\t\t * an underlying \"enN\" device, so\n\t\t\t\t * just report \"no such device\".\n\t\t\t\t */\n\t\t\t\terr = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    errno, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"socket() failed\");\n\t\t\t}\n\t\t\treturn (err);\n\t\t}\n\n\t\t/*\n\t\t * No such device.\n\t\t */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\n\t/*\n\t * Just return the error status; it's what we want, and, if it's\n\t * PCAP_ERROR, the error string has been filled in.\n\t */\n\treturn (error);\n}\n#else\nstatic int\ncheck_setif_failure(pcap_t *p _U_, int error)\n{\n\t/*\n\t * Just return the error status; it's what we want, and, if it's\n\t * PCAP_ERROR, the error string has been filled in.\n\t */\n\treturn (error);\n}\n#endif\n\n/*\n * We pick .5M, as that's the maximum on at least some systems with BPF.\n * For reference, at the time of this writing sysctl(8) reports the following\n * maximum buffer sizes.\n * - FreeBSD 14.1: net.bpf.maxbufsize = 524288\n * - macOS 12.6 (Darwin 21.6.0): debug.bpf_maxbufsize = 524288\n * - NetBSD 10.0: net.bpf.maxbufsize = 1048576\n * - OpenBSD 7.5: net.bpf.maxbufsize = 2097152\n */\n#define DEFAULT_BUFSIZE\t524288\n\nstatic int\npcap_activate_bpf(pcap_t *p)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tint status = 0;\n#ifdef HAVE_BSD_IEEE80211\n\tint retv;\n#endif\n\tint fd;\n\tstruct bpf_version bv;\n#ifdef __APPLE__\n\tint sockfd;\n\tchar *wltdev = NULL;\n#endif\n#ifdef BIOCGDLTLIST\n\tstruct bpf_dltlist bdl;\n#if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)\n\tint new_dlt;\n#endif\n#endif /* BIOCGDLTLIST */\n#if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)\n\tu_int spoof_eth_src = 1;\n#endif\n\tu_int v;\n\tstruct bpf_insn total_insn;\n\tstruct bpf_program total_prog;\n\tstruct utsname osinfo;\n\tint have_osinfo = 0;\n#ifdef HAVE_ZEROCOPY_BPF\n\tstruct bpf_zbuf bz;\n\tu_int bufmode, zbufmax;\n\tint flags = MAP_ANON;\n#endif\n\n\tfd = bpf_open(p->errbuf);\n\tif (fd < 0) {\n\t\tstatus = fd;\n\t\tgoto bad;\n\t}\n\n\tp->fd = fd;\n\n\tif (ioctl(fd, BIOCVERSION, (caddr_t)&bv) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCVERSION\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tif (bv.bv_major != BPF_MAJOR_VERSION ||\n\t    bv.bv_minor < BPF_MINOR_VERSION) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"kernel bpf filter out of date\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tpb->device = strdup(p->opt.device);\n\tif (pb->device == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"strdup\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Attempt to find out the version of the OS on which we're running.\n\t */\n\tif (uname(&osinfo) == 0)\n\t\thave_osinfo = 1;\n\n#ifdef __APPLE__\n\t/*\n\t * See comment in pcap_can_set_rfmon_bpf() for an explanation\n\t * of why we check the version number.\n\t */\n\tif (p->opt.rfmon) {\n\t\tif (have_osinfo) {\n\t\t\t/*\n\t\t\t * We assume osinfo.sysname is \"Darwin\", because\n\t\t\t * __APPLE__ is defined.  We just check the version.\n\t\t\t */\n\t\t\tif (osinfo.release[0] < '8' &&\n\t\t\t    osinfo.release[1] == '.') {\n\t\t\t\t/*\n\t\t\t\t * 10.3 (Darwin 7.x) or earlier.\n\t\t\t\t */\n\t\t\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (osinfo.release[0] == '8' &&\n\t\t\t    osinfo.release[1] == '.') {\n\t\t\t\t/*\n\t\t\t\t * 10.4 (Darwin 8.x).  s/en/wlt/\n\t\t\t\t */\n\t\t\t\tif (strncmp(p->opt.device, \"en\", 2) != 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not an enN device; check\n\t\t\t\t\t * whether the device even exists.\n\t\t\t\t\t */\n\t\t\t\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\t\t\tif (sockfd != -1) {\n\t\t\t\t\t\tstatus = device_exists(sockfd,\n\t\t\t\t\t\t    p->opt.device, p->errbuf);\n\t\t\t\t\t\tif (status == 0) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The device exists,\n\t\t\t\t\t\t\t * but it's not an\n\t\t\t\t\t\t\t * enN device; that\n\t\t\t\t\t\t\t * means it doesn't\n\t\t\t\t\t\t\t * support monitor\n\t\t\t\t\t\t\t * mode.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclose(sockfd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We can't find out whether\n\t\t\t\t\t\t * the device exists, so just\n\t\t\t\t\t\t * report \"no such device\".\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t\t    \"socket() failed\");\n\t\t\t\t\t}\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\twltdev = malloc(strlen(p->opt.device) + 2);\n\t\t\t\tif (wltdev == NULL) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc\");\n\t\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tstrcpy(wltdev, \"wlt\");\n\t\t\t\tstrcat(wltdev, p->opt.device + 2);\n\t\t\t\tfree(p->opt.device);\n\t\t\t\tp->opt.device = wltdev;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Everything else is 10.5 or later; for those,\n\t\t\t * we just open the enN device, and set the DLT.\n\t\t\t */\n\t\t}\n\t}\n#endif /* __APPLE__ */\n\n\t/*\n\t * If this is FreeBSD, and the device name begins with \"usbus\",\n\t * try to create the interface if it's not available.\n\t */\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n\tif (strncmp(p->opt.device, usbus_prefix, USBUS_PREFIX_LEN) == 0) {\n\t\t/*\n\t\t * Do we already have an interface with that name?\n\t\t */\n\t\tif (if_nametoindex(p->opt.device) == 0) {\n\t\t\t/*\n\t\t\t * No.  We need to create it, and, if we\n\t\t\t * succeed, remember that we should destroy\n\t\t\t * it when the pcap_t is closed.\n\t\t\t */\n\t\t\tint s;\n\t\t\tstruct ifreq ifr;\n\n\t\t\t/*\n\t\t\t * Open a socket to use for ioctls to\n\t\t\t * create the interface.\n\t\t\t */\n\t\t\ts = socket(AF_LOCAL, SOCK_DGRAM, 0);\n\t\t\tif (s < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't open socket\");\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we haven't already done so, arrange to have\n\t\t\t * \"pcap_close_all()\" called when we exit.\n\t\t\t */\n\t\t\tif (!pcapint_do_addexit(p)) {\n\t\t\t\t/*\n\t\t\t\t * \"atexit()\" failed; don't create the\n\t\t\t\t * interface, just give up.\n\t\t\t\t * p->errbuf has already been filled.\n\t\t\t\t */\n\t\t\t\tclose(s);\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create the interface.\n\t\t\t */\n\t\t\tpcapint_strlcpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));\n\t\t\tif (ioctl(s, SIOCIFCREATE2, &ifr) < 0) {\n\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Invalid USB bus interface %s\",\n\t\t\t\t\t    p->opt.device);\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"Can't create interface for %s\",\n\t\t\t\t\t    p->opt.device);\n\t\t\t\t}\n\t\t\t\tclose(s);\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure we clean this up when we close.\n\t\t\t */\n\t\t\tpb->must_do_on_close |= MUST_DESTROY_USBUS;\n\n\t\t\t/*\n\t\t\t * Add this to the list of pcaps to close when we exit.\n\t\t\t */\n\t\t\tpcapint_add_to_pcaps_to_close(p);\n\t\t}\n\t}\n#endif /* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */\n\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * If the BPF extension to set buffer mode is present, try setting\n\t * the mode to zero-copy.  If that fails, use regular buffering.  If\n\t * it succeeds but other setup fails, return an error to the user.\n\t */\n\tbufmode = BPF_BUFMODE_ZBUF;\n\tif (ioctl(fd, BIOCSETBUFMODE, (caddr_t)&bufmode) == 0) {\n\t\t/*\n\t\t * We have zerocopy BPF; use it.\n\t\t */\n\t\tpb->zerocopy = 1;\n\n\t\t/*\n\t\t * How to pick a buffer size: first, query the maximum buffer\n\t\t * size supported by zero-copy.  This also lets us quickly\n\t\t * determine whether the kernel generally supports zero-copy.\n\t\t * Then, if a buffer size was specified, use that, otherwise\n\t\t * query the default buffer size, which reflects kernel\n\t\t * policy for a desired default.  Round to the nearest page\n\t\t * size.\n\t\t */\n\t\tif (ioctl(fd, BIOCGETZMAX, (caddr_t)&zbufmax) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCGETZMAX\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (p->opt.buffer_size != 0) {\n\t\t\t/*\n\t\t\t * A buffer size was explicitly specified; use it.\n\t\t\t */\n\t\t\tv = p->opt.buffer_size;\n\t\t} else {\n\t\t\tif ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||\n\t\t\t    v < DEFAULT_BUFSIZE)\n\t\t\t\tv = DEFAULT_BUFSIZE;\n\t\t}\n#ifndef roundup\n#define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))  /* to any y */\n#endif\n\t\tpb->zbufsize = roundup(v, getpagesize());\n\t\tif (pb->zbufsize > zbufmax)\n\t\t\tpb->zbufsize = zbufmax;\n#ifdef MAP_32BIT\n\t\tif (pcapint_mmap_32bit) flags |= MAP_32BIT;\n#endif\n\t\tpb->zbuf1 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,\n\t\t    flags, -1, 0);\n\t\tpb->zbuf2 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,\n\t\t    flags, -1, 0);\n\t\tif (pb->zbuf1 == MAP_FAILED || pb->zbuf2 == MAP_FAILED) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"mmap\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\t\tmemset(&bz, 0, sizeof(bz)); /* bzero() deprecated, replaced with memset() */\n\t\tbz.bz_bufa = pb->zbuf1;\n\t\tbz.bz_bufb = pb->zbuf2;\n\t\tbz.bz_buflen = pb->zbufsize;\n\t\tif (ioctl(fd, BIOCSETZBUF, (caddr_t)&bz) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCSETZBUF\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\t\tstatus = bpf_bind(fd, p->opt.device, p->errbuf);\n\t\tif (status != BPF_BIND_SUCCEEDED) {\n\t\t\tif (status == BPF_BIND_BUFFER_TOO_BIG) {\n\t\t\t\t/*\n\t\t\t\t * The requested buffer size\n\t\t\t\t * is too big.  Fail.\n\t\t\t\t *\n\t\t\t\t * XXX - should we do the \"keep cutting\n\t\t\t\t * the buffer size in half\" loop here if\n\t\t\t\t * we're using the default buffer size?\n\t\t\t\t */\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t}\n\t\t\tgoto bad;\n\t\t}\n\t\tv = pb->zbufsize - sizeof(struct bpf_zbuf_header);\n\t} else\n#endif\n\t{\n\t\t/*\n\t\t * We don't have zerocopy BPF.\n\t\t * Set the buffer size.\n\t\t */\n\t\tif (p->opt.buffer_size != 0) {\n\t\t\t/*\n\t\t\t * A buffer size was explicitly specified; use it.\n\t\t\t */\n\t\t\tif (ioctl(fd, BIOCSBLEN,\n\t\t\t    (caddr_t)&p->opt.buffer_size) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"BIOCSBLEN: %s\", p->opt.device);\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now bind to the device.\n\t\t\t */\n\t\t\tstatus = bpf_bind(fd, p->opt.device, p->errbuf);\n\t\t\tif (status != BPF_BIND_SUCCEEDED) {\n\t\t\t\tif (status == BPF_BIND_BUFFER_TOO_BIG) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The requested buffer size\n\t\t\t\t\t * is too big.  Fail.\n\t\t\t\t\t */\n\t\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Special checks on macOS to deal with\n\t\t\t\t * the way monitor mode was done on\n\t\t\t\t * 10.4 Tiger.\n\t\t\t\t */\n\t\t\t\tstatus = check_setif_failure(p, status);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No buffer size was explicitly specified.\n\t\t\t *\n\t\t\t * Try finding a good size for the buffer;\n\t\t\t * DEFAULT_BUFSIZE may be too big, so keep\n\t\t\t * cutting it in half until we find a size\n\t\t\t * that works, or run out of sizes to try.\n\t\t\t * If the default is larger, don't make it smaller.\n\t\t\t */\n\t\t\tif ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||\n\t\t\t    v < DEFAULT_BUFSIZE)\n\t\t\t\tv = DEFAULT_BUFSIZE;\n\t\t\tfor ( ; v != 0; v >>= 1) {\n\t\t\t\t/*\n\t\t\t\t * Ignore the return value - this is because the\n\t\t\t\t * call fails on BPF systems that don't have\n\t\t\t\t * kernel malloc.  And if the call fails, it's\n\t\t\t\t * no big deal, we just continue to use the\n\t\t\t\t * standard buffer size.\n\t\t\t\t */\n\t\t\t\t(void) ioctl(fd, BIOCSBLEN, (caddr_t)&v);\n\n\t\t\t\tstatus = bpf_bind(fd, p->opt.device, p->errbuf);\n\t\t\t\tif (status == BPF_BIND_SUCCEEDED)\n\t\t\t\t\tbreak;\t/* that size worked; we're done */\n\n\t\t\t\t/*\n\t\t\t\t * If the attempt failed because the\n\t\t\t\t * buffer was too big, cut the buffer\n\t\t\t\t * size in half and try again.\n\t\t\t\t *\n\t\t\t\t * Otherwise, fail.\n\t\t\t\t */\n\t\t\t\tif (status != BPF_BIND_BUFFER_TOO_BIG) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special checks on macOS to deal\n\t\t\t\t\t * with the way monitor mode was\n\t\t\t\t\t * done on 10.4 Tiger.\n\t\t\t\t\t */\n\t\t\t\t\tstatus = check_setif_failure(p, status);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v == 0) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"BIOCSBLEN: %s: No buffer size worked\",\n\t\t\t\t    p->opt.device);\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Get the data link layer type. */\n\tif (ioctl(fd, BIOCGDLT, (caddr_t)&v) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCGDLT\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n#ifdef _AIX\n\t/*\n\t * AIX's BPF returns IFF_ types, not DLT_ types, in BIOCGDLT.\n\t */\n\tswitch (v) {\n\n\tcase IFT_ETHER:\n\tcase IFT_ISO88023:\n\t\tv = DLT_EN10MB;\n\t\tbreak;\n\n\tcase IFT_FDDI:\n\t\tv = DLT_FDDI;\n\t\tbreak;\n\n\tcase IFT_ISO88025:\n\t\tv = DLT_IEEE802;\n\t\tbreak;\n\n\tcase IFT_LOOP:\n\t\tv = DLT_NULL;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * We don't know what to map this to yet.\n\t\t */\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"unknown interface type %u\",\n\t\t    v);\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif\n\n#ifdef BIOCGDLTLIST\n\t/*\n\t * We know the default link type -- now determine all the DLTs\n\t * this interface supports.  If this fails with EINVAL, it's\n\t * not fatal; we just don't get to use the feature later.\n\t */\n\tif (get_dlt_list(fd, v, &bdl, p->errbuf) == -1) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tp->dlt_count = bdl.bfl_len;\n\tp->dlt_list = bdl.bfl_list;\n\n#ifdef __APPLE__\n\t/*\n\t * Monitor mode fun, continued.\n\t *\n\t * For 10.5 and, we're assuming, later releases, as noted above,\n\t * 802.1 adapters that support monitor mode offer both DLT_EN10MB,\n\t * DLT_IEEE802_11, and possibly some 802.11-plus-radio-information\n\t * DLT_ value.  Choosing one of the 802.11 DLT_ values will turn\n\t * monitor mode on.\n\t *\n\t * Therefore, if the user asked for monitor mode, we filter out\n\t * the DLT_EN10MB value, as you can't get that in monitor mode,\n\t * and, if the user didn't ask for monitor mode, we filter out\n\t * the 802.11 DLT_ values, because selecting those will turn\n\t * monitor mode on.  Then, for monitor mode, if an 802.11-plus-\n\t * radio DLT_ value is offered, we try to select that, otherwise\n\t * we try to select DLT_IEEE802_11.\n\t */\n\tif (have_osinfo) {\n\t\tif (PCAP_ISDIGIT((unsigned)osinfo.release[0]) &&\n\t\t     (osinfo.release[0] == '9' ||\n\t\t     PCAP_ISDIGIT((unsigned)osinfo.release[1]))) {\n\t\t\t/*\n\t\t\t * 10.5 (Darwin 9.x), or later.\n\t\t\t */\n\t\t\tnew_dlt = find_802_11(&bdl);\n\t\t\tif (new_dlt != -1) {\n\t\t\t\t/*\n\t\t\t\t * We have at least one 802.11 DLT_ value,\n\t\t\t\t * so this is an 802.11 interface.\n\t\t\t\t * new_dlt is the best of the 802.11\n\t\t\t\t * DLT_ values in the list.\n\t\t\t\t */\n\t\t\t\tif (p->opt.rfmon) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Our caller wants monitor mode.\n\t\t\t\t\t * Purge DLT_EN10MB from the list\n\t\t\t\t\t * of link-layer types, as selecting\n\t\t\t\t\t * it will keep monitor mode off.\n\t\t\t\t\t */\n\t\t\t\t\tremove_non_802_11(p);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the new mode we want isn't\n\t\t\t\t\t * the default mode, attempt to\n\t\t\t\t\t * select the new mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ((u_int)new_dlt != v) {\n\t\t\t\t\t\tif (ioctl(p->fd, BIOCSDLT,\n\t\t\t\t\t\t    &new_dlt) != -1) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We succeeded;\n\t\t\t\t\t\t\t * make this the\n\t\t\t\t\t\t\t * new DLT_ value.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tv = new_dlt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Our caller doesn't want\n\t\t\t\t\t * monitor mode.  Unless this\n\t\t\t\t\t * is being done by pcap_open_live(),\n\t\t\t\t\t * purge the 802.11 link-layer types\n\t\t\t\t\t * from the list, as selecting\n\t\t\t\t\t * one of them will turn monitor\n\t\t\t\t\t * mode on.\n\t\t\t\t\t */\n\t\t\t\t\tif (!p->oldstyle)\n\t\t\t\t\t\tremove_802_11(p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (p->opt.rfmon) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The caller requested monitor\n\t\t\t\t\t * mode, but we have no 802.11\n\t\t\t\t\t * link-layer types, so they\n\t\t\t\t\t * can't have it.\n\t\t\t\t\t */\n\t\t\t\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#elif defined(HAVE_BSD_IEEE80211)\n\t/*\n\t * *BSD with the new 802.11 ioctls.\n\t * Do we want monitor mode?\n\t */\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * Try to put the interface into monitor mode.\n\t\t */\n\t\tretv = monitor_mode(p, 1);\n\t\tif (retv != 0) {\n\t\t\t/*\n\t\t\t * We failed.\n\t\t\t */\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\n\t\t/*\n\t\t * We're in monitor mode.\n\t\t * Try to find the best 802.11 DLT_ value and, if we\n\t\t * succeed, try to switch to that mode if we're not\n\t\t * already in that mode.\n\t\t */\n\t\tnew_dlt = find_802_11(&bdl);\n\t\tif (new_dlt != -1) {\n\t\t\t/*\n\t\t\t * We have at least one 802.11 DLT_ value.\n\t\t\t * new_dlt is the best of the 802.11\n\t\t\t * DLT_ values in the list.\n\t\t\t *\n\t\t\t * If the new mode we want isn't the default mode,\n\t\t\t * attempt to select the new mode.\n\t\t\t */\n\t\t\tif ((u_int)new_dlt != v) {\n\t\t\t\tif (ioctl(p->fd, BIOCSDLT, &new_dlt) != -1) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We succeeded; make this the\n\t\t\t\t\t * new DLT_ value.\n\t\t\t\t\t */\n\t\t\t\t\tv = new_dlt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif /* various platforms */\n#endif /* BIOCGDLTLIST */\n\n\t/*\n\t * If this is an Ethernet device, and we don't have a DLT_ list,\n\t * give it a list with DLT_EN10MB and DLT_DOCSIS.  (That'd give\n\t * 802.11 interfaces DLT_DOCSIS, which isn't the right thing to\n\t * do, but there's not much we can do about that without finding\n\t * some other way of determining whether it's an Ethernet or 802.11\n\t * device.)\n\t */\n\tif (v == DLT_EN10MB && p->dlt_count == 0) {\n\t\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\tif (p->dlt_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\tp->dlt_count = 2;\n\t}\n#ifdef PCAP_FDDIPAD\n\tif (v == DLT_FDDI)\n\t\tp->fddipad = PCAP_FDDIPAD;\n\telse\n#endif\n\t\tp->fddipad = 0;\n\tp->linktype = v;\n\n#if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)\n\t/*\n\t * Do a BIOCSHDRCMPLT, if defined, to turn that flag on, so\n\t * the link-layer source address isn't forcibly overwritten.\n\t * (Should we ignore errors?  Should we do this only if\n\t * we're open for writing?)\n\t *\n\t * XXX - I seem to remember some packet-sending bug in some\n\t * BSDs - check CVS log for \"bpf.c\"?\n\t */\n\tif (ioctl(fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSHDRCMPLT\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif\n\t/* set timeout */\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * In zero-copy mode, we just use the timeout in select().\n\t * XXX - what if we're in non-blocking mode and the *application*\n\t * is using select() or poll() or kqueues or....?\n\t */\n\tif (p->opt.timeout && !pb->zerocopy) {\n#else\n\tif (p->opt.timeout) {\n#endif\n\t\t/*\n\t\t * XXX - is this seconds/nanoseconds in AIX?\n\t\t * (Treating it as such doesn't fix the timeout\n\t\t * problem described below.)\n\t\t *\n\t\t * XXX - Mac OS X 10.6 mishandles BIOCSRTIMEOUT in\n\t\t * 64-bit userland - it takes, as an argument, a\n\t\t * \"struct BPF_TIMEVAL\", which has 32-bit tv_sec\n\t\t * and tv_usec, rather than a \"struct timeval\".\n\t\t *\n\t\t * If this platform defines \"struct BPF_TIMEVAL\",\n\t\t * we check whether the structure size in BIOCSRTIMEOUT\n\t\t * is that of a \"struct timeval\" and, if not, we use\n\t\t * a \"struct BPF_TIMEVAL\" rather than a \"struct timeval\".\n\t\t * (That way, if the bug is fixed in a future release,\n\t\t * we will still do the right thing.)\n\t\t */\n\t\tstruct timeval to;\n#ifdef HAVE_STRUCT_BPF_TIMEVAL\n\t\tstruct BPF_TIMEVAL bpf_to;\n\n\t\tif (IOCPARM_LEN(BIOCSRTIMEOUT) != sizeof(struct timeval)) {\n\t\t\tbpf_to.tv_sec = p->opt.timeout / 1000;\n\t\t\tbpf_to.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\t\tif (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&bpf_to) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    errno, PCAP_ERRBUF_SIZE, \"BIOCSRTIMEOUT\");\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else {\n#endif\n\t\t\tto.tv_sec = p->opt.timeout / 1000;\n\t\t\tto.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\t\tif (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    errno, PCAP_ERRBUF_SIZE, \"BIOCSRTIMEOUT\");\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tgoto bad;\n\t\t\t}\n#ifdef HAVE_STRUCT_BPF_TIMEVAL\n\t\t}\n#endif\n\t}\n\n#ifdef\tBIOCIMMEDIATE\n\t/*\n\t * Darren Reed notes that\n\t *\n\t *\tOn AIX (4.2 at least), if BIOCIMMEDIATE is not set, the\n\t *\ttimeout appears to be ignored and it waits until the buffer\n\t *\tis filled before returning.  The result of not having it\n\t *\tset is almost worse than useless if your BPF filter\n\t *\tis reducing things to only a few packets (i.e. one every\n\t *\tsecond or so).\n\t *\n\t * so we always turn BIOCIMMEDIATE mode on if this is AIX.\n\t *\n\t * For other platforms, we don't turn immediate mode on by default,\n\t * as that would mean we get woken up for every packet, which\n\t * probably isn't what you want for a packet sniffer.\n\t *\n\t * We set immediate mode if the caller requested it by calling\n\t * pcap_set_immediate() before calling pcap_activate().\n\t */\n#ifndef _AIX\n\tif (p->opt.immediate) {\n#endif /* _AIX */\n\t\tv = 1;\n\t\tif (ioctl(p->fd, BIOCIMMEDIATE, &v) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCIMMEDIATE\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n#ifndef _AIX\n\t}\n#endif /* _AIX */\n#else /* BIOCIMMEDIATE */\n\tif (p->opt.immediate) {\n\t\t/*\n\t\t * We don't support immediate mode.  Fail.\n\t\t */\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Immediate mode not supported\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif /* BIOCIMMEDIATE */\n\n\tif (p->opt.promisc) {\n\t\t/* set promiscuous mode, just warn if it fails */\n\t\tif (ioctl(p->fd, BIOCPROMISC, NULL) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCPROMISC\");\n\t\t\tstatus = PCAP_WARNING_PROMISC_NOTSUP;\n\t\t}\n\t}\n\n#ifdef BIOCSTSTAMP\n\tv = BPF_T_BINTIME;\n\tif (ioctl(p->fd, BIOCSTSTAMP, &v) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSTSTAMP\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif /* BIOCSTSTAMP */\n\n\tif (ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCGBLEN\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tp->bufsize = v;\n#ifdef HAVE_ZEROCOPY_BPF\n\tif (!pb->zerocopy) {\n#endif\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#ifdef _AIX\n\t/* For some strange reason this seems to prevent the EFAULT\n\t * problems we have experienced from AIX BPF. */\n\tmemset(p->buffer, 0x0, p->bufsize);\n#endif\n#ifdef HAVE_ZEROCOPY_BPF\n\t}\n#endif\n\n\t/*\n\t * If there's no filter program installed, there's\n\t * no indication to the kernel of what the snapshot\n\t * length should be, so no snapshotting is done.\n\t *\n\t * Therefore, when we open the device, we install\n\t * an \"accept everything\" filter with the specified\n\t * snapshot length.\n\t */\n\ttotal_insn.code = (u_short)(BPF_RET | BPF_K);\n\ttotal_insn.jt = 0;\n\ttotal_insn.jf = 0;\n\ttotal_insn.k = p->snapshot;\n\n\ttotal_prog.bf_len = 1;\n\ttotal_prog.bf_insns = &total_insn;\n\tif (ioctl(p->fd, BIOCSETF, (caddr_t)&total_prog) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSETF\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * On most BPF platforms, either you can do a \"select()\" or\n\t * \"poll()\" on a BPF file descriptor and it works correctly,\n\t * or you can do it and it will return \"readable\" if the\n\t * hold buffer is full but not if the timeout expires *and*\n\t * a non-blocking read will, if the hold buffer is empty\n\t * but the store buffer isn't empty, rotate the buffers\n\t * and return what packets are available.\n\t *\n\t * In the latter case, the fact that a non-blocking read\n\t * will give you the available packets means you can work\n\t * around the failure of \"select()\" and \"poll()\" to wake up\n\t * and return \"readable\" when the timeout expires by using\n\t * the timeout as the \"select()\" or \"poll()\" timeout, putting\n\t * the BPF descriptor into non-blocking mode, and read from\n\t * it regardless of whether \"select()\" reports it as readable\n\t * or not.\n\t *\n\t * However, in FreeBSD 4.3 and 4.4, \"select()\" and \"poll()\"\n\t * won't wake up and return \"readable\" if the timer expires\n\t * and non-blocking reads return EWOULDBLOCK if the hold\n\t * buffer is empty, even if the store buffer is non-empty.\n\t *\n\t * This means the workaround in question won't work.\n\t *\n\t * Therefore, on FreeBSD 4.3 and 4.4, we set \"p->selectable_fd\"\n\t * to -1, which means \"sorry, you can't use 'select()' or 'poll()'\n\t * here\".  On all other BPF platforms, we set it to the FD for\n\t * the BPF device; in NetBSD, OpenBSD, and Darwin, a non-blocking\n\t * read will, if the hold buffer is empty and the store buffer\n\t * isn't empty, rotate the buffers and return what packets are\n\t * there (and in sufficiently recent versions of OpenBSD\n\t * \"select()\" and \"poll()\" should work correctly).\n\t *\n\t * XXX - what about AIX?\n\t */\n\tp->selectable_fd = p->fd;\t/* assume select() works until we know otherwise */\n\tif (have_osinfo) {\n\t\t/*\n\t\t * We can check what OS this is.\n\t\t */\n\t\tif (strcmp(osinfo.sysname, \"FreeBSD\") == 0) {\n\t\t\tif (strncmp(osinfo.release, \"4.3-\", 4) == 0 ||\n\t\t\t     strncmp(osinfo.release, \"4.4-\", 4) == 0)\n\t\t\t\tp->selectable_fd = -1;\n\t\t}\n\t}\n\n\tp->read_op = pcap_read_bpf;\n\tp->inject_op = pcap_inject_bpf;\n\tp->setfilter_op = pcap_setfilter_bpf;\n\tp->setdirection_op = pcap_setdirection_bpf;\n\tp->set_datalink_op = pcap_set_datalink_bpf;\n\tp->getnonblock_op = pcap_getnonblock_bpf;\n\tp->setnonblock_op = pcap_setnonblock_bpf;\n\tp->stats_op = pcap_stats_bpf;\n\tp->cleanup_op = pcap_cleanup_bpf;\n\n\treturn (status);\n bad:\n\tpcap_cleanup_bpf(p);\n\treturn (status);\n}\n\n/*\n * Not all interfaces can be bound to by BPF, so try to bind to\n * the specified interface; return 0 if we fail with\n * PCAP_ERROR_NO_SUCH_DEVICE (which means we got an ENXIO when we tried\n * to bind, which means this interface isn't in the list of interfaces\n * attached to BPF) and 1 otherwise.\n */\nstatic int\ncheck_bpf_bindable(const char *name)\n{\n\tint fd;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\t/*\n\t * On macOS, we don't do this check if the device name begins\n\t * with \"wlt\"; at least some versions of macOS (actually, it\n\t * was called \"Mac OS X\" then...) offer monitor mode capturing\n\t * by having a separate \"monitor mode\" device for each wireless\n\t * adapter, rather than by implementing the ioctls that\n\t * {Free,Net,Open,DragonFly}BSD provide. Opening that device\n\t * puts the adapter into monitor mode, which, at least for\n\t * some adapters, causes them to disassociate from the network\n\t * with which they're associated.\n\t *\n\t * Instead, we try to open the corresponding \"en\" device (so\n\t * that we don't end up with, for users without sufficient\n\t * privilege to open capture devices, a list of adapters that\n\t * only includes the wlt devices).\n\t */\n#ifdef __APPLE__\n\tif (strncmp(name, \"wlt\", 3) == 0) {\n\t\tchar *en_name;\n\t\tsize_t en_name_len;\n\n\t\t/*\n\t\t * Try to allocate a buffer for the \"en\"\n\t\t * device's name.\n\t\t */\n\t\ten_name_len = strlen(name) - 1;\n\t\ten_name = malloc(en_name_len + 1);\n\t\tif (en_name == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\tstrcpy(en_name, \"en\");\n\t\tstrcat(en_name, name + 3);\n\t\tfd = bpf_open_and_bind(en_name, errbuf);\n\t\tfree(en_name);\n\t} else\n#endif /* __APPLE */\n\tfd = bpf_open_and_bind(name, errbuf);\n\tif (fd < 0) {\n\t\t/*\n\t\t * Error - was it PCAP_ERROR_NO_SUCH_DEVICE?\n\t\t */\n\t\tif (fd == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Yes, so we can't bind to this because it's\n\t\t\t * not something supported by BPF.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * No, so we don't know whether it's supported or not;\n\t\t * say it is, so that the user can at least try to\n\t\t * open it and report the error (which is probably\n\t\t * \"you don't have permission to open BPF devices\";\n\t\t * reporting those interfaces means users will ask\n\t\t * \"why am I getting a permissions error when I try\n\t\t * to capture\" rather than \"why am I not seeing any\n\t\t * interfaces\", making the underlying problem clearer).\n\t\t */\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tclose(fd);\n\treturn (1);\n}\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\nstatic int\nget_usb_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * XXX - if there's a way to determine whether there's something\n\t * plugged into a given USB bus, use that to determine whether\n\t * this device is \"connected\" or not.\n\t */\n\treturn (0);\n}\n\nstatic int\nfinddevs_usb(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tDIR *usbdir;\n\tstruct dirent *usbitem;\n\tsize_t name_max;\n\tchar *name;\n\n\t/*\n\t * We might have USB sniffing support, so try looking for USB\n\t * interfaces.\n\t *\n\t * We want to report a usbusN device for each USB bus, but\n\t * usbusN interfaces might, or might not, exist for them -\n\t * we create one if there isn't already one.\n\t *\n\t * So, instead, we look in /dev/usb for all buses and create\n\t * a \"usbusN\" device for each one.\n\t */\n\tusbdir = opendir(\"/dev/usb\");\n\tif (usbdir == NULL) {\n\t\t/*\n\t\t * Just punt.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Leave enough room for a 32-bit (10-digit) bus number.\n\t * Yes, that's overkill, but we won't be using\n\t * the buffer very long.\n\t */\n\tname_max = USBUS_PREFIX_LEN + 10 + 1;\n\tname = malloc(name_max);\n\tif (name == NULL) {\n\t\tclosedir(usbdir);\n\t\treturn (0);\n\t}\n\twhile ((usbitem = readdir(usbdir)) != NULL) {\n\t\tchar *p;\n\t\tsize_t busnumlen;\n\n\t\tif (strcmp(usbitem->d_name, \".\") == 0 ||\n\t\t    strcmp(usbitem->d_name, \"..\") == 0) {\n\t\t\t/*\n\t\t\t * Ignore these.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tp = strchr(usbitem->d_name, '.');\n\t\tif (p == NULL)\n\t\t\tcontinue;\n\t\tbusnumlen = p - usbitem->d_name;\n\t\tmemcpy(name, usbus_prefix, USBUS_PREFIX_LEN);\n\t\tmemcpy(name + USBUS_PREFIX_LEN, usbitem->d_name, busnumlen);\n\t\t*(name + USBUS_PREFIX_LEN + busnumlen) = '\\0';\n\t\t/*\n\t\t * There's an entry in this directory for every USB device,\n\t\t * not for every bus; if there's more than one device on\n\t\t * the bus, there'll be more than one entry for that bus,\n\t\t * so we need to avoid adding multiple capture devices\n\t\t * for each bus.\n\t\t */\n\t\tif (pcapint_find_or_add_dev(devlistp, name, PCAP_IF_UP,\n\t\t    get_usb_if_flags, NULL, errbuf) == NULL) {\n\t\t\tfree(name);\n\t\t\tclosedir(usbdir);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tfree(name);\n\tclosedir(usbdir);\n\treturn (0);\n}\n#endif\n\n/*\n * Get additional flags for a device, using SIOCGIFMEDIA.\n */\n#ifdef SIOCGIFMEDIA\nstatic int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tint sock;\n\tstruct ifmediareq req;\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"Can't create socket to get media information for %s\",\n\t\t    name);\n\t\treturn (-1);\n\t}\n\tmemset(&req, 0, sizeof(req));\n\tpcapint_strlcpy(req.ifm_name, name, sizeof(req.ifm_name));\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\tif (errno == EOPNOTSUPP || errno == EINVAL || errno == ENOTTY ||\n\t\t    errno == ENODEV || errno == EPERM\n#ifdef EPWROFF\n\t\t    || errno == EPWROFF\n#endif\n\t\t    ) {\n\t\t\t/*\n\t\t\t * Not supported, so we can't provide any\n\t\t\t * additional information.  Assume that\n\t\t\t * this means that \"connected\" vs.\n\t\t\t * \"disconnected\" doesn't apply.\n\t\t\t *\n\t\t\t * The ioctl routine for Apple's pktap devices,\n\t\t\t * annoyingly, checks for \"are you root?\" before\n\t\t\t * checking whether the ioctl is valid, so it\n\t\t\t * returns EPERM, rather than ENOTSUP, for the\n\t\t\t * invalid SIOCGIFMEDIA, unless you're root.\n\t\t\t * So, just as we do for some ethtool ioctls\n\t\t\t * on Linux, which makes the same mistake, we\n\t\t\t * also treat EPERM as meaning \"not supported\".\n\t\t\t *\n\t\t\t * And it appears that Apple's llw0 device, which\n\t\t\t * appears to be part of the Skywalk subsystem:\n\t\t\t *\n\t\t\t *    http://newosxbook.com/bonus/vol1ch16.html\n\t\t\t *\n\t\t\t * can sometimes return EPWROFF (\"Device power\n\t\t\t * is off\") for that ioctl, so we treat *that*\n\t\t\t * as another indication that we can't get a\n\t\t\t * connection status.  (If it *isn't* \"powered\n\t\t\t * off\", it's reported as a wireless device,\n\t\t\t * complete with an active/inactive state.)\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\t\tclose(sock);\n\t\t\treturn (0);\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"SIOCGIFMEDIA on %s failed\", name);\n\t\tclose(sock);\n\t\treturn (-1);\n\t}\n\tclose(sock);\n\n\t/*\n\t * OK, what type of network is this?\n\t */\n\tswitch (IFM_TYPE(req.ifm_active)) {\n\n\tcase IFM_IEEE80211:\n\t\t/*\n\t\t * Wireless.\n\t\t */\n\t\t*flags |= PCAP_IF_WIRELESS;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Do we know whether it's connected?\n\t */\n\tif (req.ifm_status & IFM_AVALID) {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tif (req.ifm_status & IFM_ACTIVE) {\n\t\t\t/*\n\t\t\t * It's connected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's disconnected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\t}\n\t}\n\treturn (0);\n}\n#else\nstatic int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}\n#endif\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcapint_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n#if defined(HAVE_SOLARIS_ANY_DEVICE)\n\t/*\n\t * Add the \"any\" device.\n\t */\n\tif (pcapint_add_any_dev(devlistp, errbuf) == NULL)\n\t\treturn (-1);\n#endif\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n\tif (finddevs_usb(devlistp, errbuf) == -1)\n\t\treturn (-1);\n#endif\n\n\treturn (0);\n}\n\n#ifdef HAVE_BSD_IEEE80211\nstatic int\nmonitor_mode(pcap_t *p, int set)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tint sock;\n\tstruct ifmediareq req;\n\tIFM_ULIST_TYPE *media_list;\n\tint i;\n\tint can_do;\n\tstruct ifreq ifr;\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't open socket\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tmemset(&req, 0, sizeof req);\n\tpcapint_strlcpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);\n\n\t/*\n\t * Find out how many media types we have.\n\t */\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\t/*\n\t\t * Can't get the media types.\n\t\t */\n\t\tswitch (errno) {\n\n\t\tcase ENXIO:\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t *\n\t\t\t * There's nothing more to say, so clear the\n\t\t\t * error message.\n\t\t\t */\n\t\t\tp->errbuf[0] = '\\0';\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * Interface doesn't support SIOC{G,S}IFMEDIA.\n\t\t\t */\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\n\t\tdefault:\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFMEDIA\");\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tif (req.ifm_count == 0) {\n\t\t/*\n\t\t * No media types.\n\t\t */\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\t/*\n\t * Allocate a buffer to hold all the media types, and\n\t * get the media types.\n\t */\n\tmedia_list = malloc(req.ifm_count * sizeof(*media_list));\n\tif (media_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR);\n\t}\n\treq.ifm_ulist = media_list;\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFMEDIA\");\n\t\tfree(media_list);\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Look for an 802.11 \"automatic\" media type.\n\t * We assume that all 802.11 adapters have that media type,\n\t * and that it will carry the monitor mode supported flag.\n\t */\n\tcan_do = 0;\n\tfor (i = 0; i < req.ifm_count; i++) {\n\t\tif (IFM_TYPE(media_list[i]) == IFM_IEEE80211\n\t\t    && IFM_SUBTYPE(media_list[i]) == IFM_AUTO) {\n\t\t\t/* OK, does it do monitor mode? */\n\t\t\tif (media_list[i] & IFM_IEEE80211_MONITOR) {\n\t\t\t\tcan_do = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(media_list);\n\tif (!can_do) {\n\t\t/*\n\t\t * This adapter doesn't support monitor mode.\n\t\t */\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\tif (set) {\n\t\t/*\n\t\t * Don't just check whether we can enable monitor mode,\n\t\t * do so, if it's not already enabled.\n\t\t */\n\t\tif ((req.ifm_current & IFM_IEEE80211_MONITOR) == 0) {\n\t\t\t/*\n\t\t\t * Monitor mode isn't currently on, so turn it on,\n\t\t\t * and remember that we should turn it off when the\n\t\t\t * pcap_t is closed.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * If we haven't already done so, arrange to have\n\t\t\t * \"pcap_close_all()\" called when we exit.\n\t\t\t */\n\t\t\tif (!pcapint_do_addexit(p)) {\n\t\t\t\t/*\n\t\t\t\t * \"atexit()\" failed; don't put the interface\n\t\t\t\t * in monitor mode, just give up.\n\t\t\t\t * p->errbuf has already been filled.\n\t\t\t\t */\n\t\t\t\tclose(sock);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t(void)pcapint_strlcpy(ifr.ifr_name, p->opt.device,\n\t\t\t    sizeof(ifr.ifr_name));\n\t\t\tifr.ifr_media = req.ifm_current | IFM_IEEE80211_MONITOR;\n\t\t\tif (ioctl(sock, SIOCSIFMEDIA, &ifr) == -1) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCSIFMEDIA\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\n\t\t\tpb->must_do_on_close |= MUST_CLEAR_RFMON;\n\n\t\t\t/*\n\t\t\t * Add this to the list of pcaps to close when we exit.\n\t\t\t */\n\t\t\tpcapint_add_to_pcaps_to_close(p);\n\t\t}\n\t}\n\treturn (0);\n}\n#endif /* HAVE_BSD_IEEE80211 */\n\n#if defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211))\n/*\n * Check whether we have any 802.11 link-layer types; return the best\n * of the 802.11 link-layer types if we find one, and return -1\n * otherwise.\n *\n * DLT_IEEE802_11_RADIO, with the radiotap header, is considered the\n * best 802.11 link-layer type; any of the other 802.11-plus-radio\n * headers are second-best; 802.11 with no radio information is\n * the least good.\n */\nstatic int\nfind_802_11(struct bpf_dltlist *bdlp)\n{\n\tint new_dlt;\n\tu_int i;\n\n\t/*\n\t * Scan the list of DLT_ values, looking for 802.11 values,\n\t * and, if we find any, choose the best of them.\n\t */\n\tnew_dlt = -1;\n\tfor (i = 0; i < bdlp->bfl_len; i++) {\n\t\tswitch (bdlp->bfl_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n\t\t\t/*\n\t\t\t * 802.11, but no radio.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found an 802.11\n\t\t\t * header with radio information.\n\t\t\t */\n\t\t\tif (new_dlt == -1)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n#ifdef DLT_PRISM_HEADER\n\t\tcase DLT_PRISM_HEADER:\n#endif\n#ifdef DLT_AIRONET_HEADER\n\t\tcase DLT_AIRONET_HEADER:\n#endif\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\t/*\n\t\t\t * 802.11 with radio, but not radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found the radiotap DLT_.\n\t\t\t */\n\t\t\tif (new_dlt != DLT_IEEE802_11_RADIO)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\t/*\n\t\t\t * 802.11 with radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode.\n\t\t\t */\n\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not 802.11.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (new_dlt);\n}\n#endif /* defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)) */\n\n#if defined(__APPLE__) && defined(BIOCGDLTLIST)\n/*\n * Remove non-802.11 header types from the list of DLT_ values, as we're in\n * monitor mode, and those header types aren't supported in monitor mode.\n */\nstatic void\nremove_non_802_11(pcap_t *p)\n{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard non-802.11 ones.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_RAW:\n\t\t\t/*\n\t\t\t * Not 802.11.  Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}\n\n/*\n * Remove 802.11 link-layer types from the list of DLT_ values, as\n * we're not in monitor mode, and those DLT_ values will switch us\n * to monitor mode.\n */\nstatic void\nremove_802_11(pcap_t *p)\n{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard 802.11 values.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n#ifdef DLT_PRISM_HEADER\n\t\tcase DLT_PRISM_HEADER:\n#endif\n#ifdef DLT_AIRONET_HEADER\n\t\tcase DLT_AIRONET_HEADER:\n#endif\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n#ifdef DLT_PPI\n\t\tcase DLT_PPI:\n#endif\n\t\t\t/*\n\t\t\t * 802.11.  Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}\n#endif /* defined(__APPLE__) && defined(BIOCGDLTLIST) */\n\nstatic int\npcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\n\t/*\n\t * Free any user-mode filter we might happen to have installed.\n\t */\n\tpcap_freecode(&p->fcode);\n\n\t/*\n\t * Try to install the kernel filter.\n\t */\n\tif (ioctl(p->fd, BIOCSETF, (caddr_t)fp) == 0) {\n\t\t/*\n\t\t * It worked.\n\t\t */\n\t\tpb->filtering_in_kernel = 1;\t/* filtering in the kernel */\n\n\t\t/*\n\t\t * Discard any previously-received packets, as they might\n\t\t * have passed whatever filter was formerly in effect, but\n\t\t * might not pass this filter (BIOCSETF discards packets\n\t\t * buffered in the kernel, so you can lose packets in any\n\t\t * case).\n\t\t */\n\t\tp->cc = 0;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * We failed.\n\t *\n\t * If it failed with EINVAL, that's probably because the program\n\t * is invalid or too big.  Validate it ourselves; if we like it\n\t * (we currently allow backward branches, to support protochain),\n\t * run it in userland.  (There's no notion of \"too big\" for\n\t * userland.)\n\t *\n\t * Otherwise, just give up.\n\t * XXX - if the copy of the program into the kernel failed,\n\t * we will get EINVAL rather than, say, EFAULT on at least\n\t * some kernels.\n\t */\n\tif (errno != EINVAL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSETF\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * pcapint_install_bpf_program() validates the program.\n\t *\n\t * XXX - what if we already have a filter in the kernel?\n\t */\n\tif (pcapint_install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\tpb->filtering_in_kernel = 0;\t/* filtering in userland */\n\treturn (0);\n}\n\n/*\n * Set direction flag: Which packets do we accept on a forwarding\n * single device? IN, OUT or both?\n */\n#if defined(BIOCSDIRECTION)\nstatic int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)\n{\n\tu_int direction;\n\tconst char *direction_name;\n\n\t/*\n\t * FreeBSD and NetBSD.\n\t */\n\tswitch (d) {\n\n\tcase PCAP_D_IN:\n\t\t/*\n\t\t * Incoming, but not outgoing, so accept only\n\t\t * incoming packets.\n\t\t */\n\t\tdirection = BPF_D_IN;\n\t\tdirection_name = \"\\\"incoming only\\\"\";\n\t\tbreak;\n\n\tcase PCAP_D_OUT:\n\t\t/*\n\t\t * Outgoing, but not incoming, so accept only\n\t\t * outgoing packets.\n\t\t */\n\t\tdirection = BPF_D_OUT;\n\t\tdirection_name = \"\\\"outgoing only\\\"\";\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * Incoming and outgoing, so accept both\n\t\t * incoming and outgoing packets.\n\t\t *\n\t\t * It's guaranteed, at this point, that d is a valid\n\t\t * direction value, so we know that this is PCAP_D_INOUT\n\t\t * if it's not PCAP_D_IN or PCAP_D_OUT.\n\t\t */\n\t\tdirection = BPF_D_INOUT;\n\t\tdirection_name = \"\\\"incoming and outgoing\\\"\";\n\t\tbreak;\n\t}\n\n\tif (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set direction to %s\", direction_name);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n#elif defined(BIOCSDIRFILT)\nstatic int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)\n{\n\tu_int dirfilt;\n\tconst char *direction_name;\n\n\t/*\n\t * OpenBSD; same functionality, different names, different\n\t * semantics (the flags mean \"*don't* capture packets in\n\t * that direction\", not \"*capture only* packets in that\n\t * direction\").\n\t */\n\tswitch (d) {\n\n\tcase PCAP_D_IN:\n\t\t/*\n\t\t * Incoming, but not outgoing, so filter out\n\t\t * outgoing packets.\n\t\t */\n\t\tdirfilt = BPF_DIRECTION_OUT;\n\t\tdirection_name = \"\\\"incoming only\\\"\";\n\t\tbreak;\n\n\tcase PCAP_D_OUT:\n\t\t/*\n\t\t * Outgoing, but not incoming, so filter out\n\t\t * incoming packets.\n\t\t */\n\t\tdirfilt = BPF_DIRECTION_IN;\n\t\tdirection_name = \"\\\"outgoing only\\\"\";\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * Incoming and outgoing, so don't filter out\n\t\t * any packets based on direction.\n\t\t *\n\t\t * It's guaranteed, at this point, that d is a valid\n\t\t * direction value, so we know that this is PCAP_D_INOUT\n\t\t * if it's not PCAP_D_IN or PCAP_D_OUT.\n\t\t */\n\t\tdirfilt = 0;\n\t\tdirection_name = \"\\\"incoming and outgoing\\\"\";\n\t\tbreak;\n\t}\n\tif (ioctl(p->fd, BIOCSDIRFILT, &dirfilt) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set direction to %s\", direction_name);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n#elif defined(BIOCSSEESENT)\nstatic int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)\n{\n\tu_int seesent;\n\tconst char *direction_name;\n\n\t/*\n\t * OS with just BIOCSSEESENT.\n\t */\n\tswitch (d) {\n\n\tcase PCAP_D_IN:\n\t\t/*\n\t\t * Incoming, but not outgoing, so we don't want to\n\t\t * see transmitted packets.\n\t\t */\n\t\tseesent = 0;\n\t\tdirection_name = \"\\\"incoming only\\\"\";\n\t\tbreak;\n\n\tcase PCAP_D_OUT:\n\t\t/*\n\t\t * Outgoing, but not incoming; we can't specify that.\n\t\t */\n\t\tsnprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"Setting direction to \\\"outgoing only\\\" is not supported on this device\");\n\t\treturn (-1);\n\n\tdefault:\n\t\t/*\n\t\t * Incoming and outgoing, so we want to see transmitted\n\t\t * packets.\n\t\t *\n\t\t * It's guaranteed, at this point, that d is a valid\n\t\t * direction value, so we know that this is PCAP_D_INOUT\n\t\t * if it's not PCAP_D_IN or PCAP_D_OUT.\n\t\t */\n\t\tseesent = 1;\n\t\tdirection_name = \"\\\"incoming and outgoing\\\"\";\n\t\tbreak;\n\t}\n\n\tif (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set direction to %s\", direction_name);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n#else\nstatic int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d _U_)\n{\n\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t    \"Setting direction is not supported on this device\");\n\treturn (-1);\n}\n#endif\n\n#ifdef BIOCSDLT\nstatic int\npcap_set_datalink_bpf(pcap_t *p, int dlt)\n{\n\tif (ioctl(p->fd, BIOCSDLT, &dlt) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set DLT %d\", dlt);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n#else\nstatic int\npcap_set_datalink_bpf(pcap_t *p _U_, int dlt _U_)\n{\n\treturn (0);\n}\n#endif\n\n/*\n * Platform-specific information.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING\n#if defined(HAVE_ZEROCOPY_BPF) && defined(PCAP_SUPPORT_NETMAP)\n\t\t\" (with zerocopy and netmap support)\"\n#elif defined(HAVE_ZEROCOPY_BPF)\n\t\t\" (with zerocopy support)\"\n#elif defined(PCAP_SUPPORT_NETMAP)\n\t\t\" (with netmap support)\"\n#else\n\t\t\"\"\n#endif\n\t);\n}\n"
        },
        {
          "name": "pcap-bpf.h",
          "type": "blob",
          "size": 2.240234375,
          "content": "/*-\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * This code is derived from the Stanford/CMU enet packet filter,\n * (net/enet.c) distributed as part of 4.3BSD, and code contributed\n * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence\n * Berkeley Laboratory.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *      This product includes software developed by the University of\n *      California, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * For backwards compatibility.\n *\n * Note to OS vendors: do NOT get rid of this file!  Some applications\n * might expect to be able to include <pcap-bpf.h>.\n */\n#include <pcap/bpf.h>\n"
        },
        {
          "name": "pcap-bt-linux.c",
          "type": "blob",
          "size": 12.0087890625,
          "content": "/*\n * Copyright (c) 2006 Paolo Abeni (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Bluetooth sniffing API implementation for Linux platform\n * By Paolo Abeni <paolo.abeni@email.it>\n *\n */\n\n#include <config.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-bt-linux.h\"\n#include \"pcap/bluetooth.h\"\n#include \"diag-control.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/hci.h>\n\n#define BT_IFACE \"bluetooth\"\n#define BT_CTRL_SIZE 128\n\n/* forward declaration */\nstatic int bt_activate(pcap_t *);\nstatic int bt_read_linux(pcap_t *, int , pcap_handler , u_char *);\nstatic int bt_inject_linux(pcap_t *, const void *, int);\nstatic int bt_setdirection_linux(pcap_t *, pcap_direction_t);\nstatic int bt_stats_linux(pcap_t *, struct pcap_stat *);\n\n/*\n * Private data for capturing on Linux Bluetooth devices.\n */\nstruct pcap_bt {\n\tint dev_id;\t\t/* device ID of device we're bound to */\n};\n\nint\nbt_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tstruct hci_dev_list_req *dev_list;\n\tstruct hci_dev_req *dev_req;\n\tint sock;\n\tunsigned i;\n\tint ret = 0;\n\n\tsock  = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (sock < 0)\n\t{\n\t\t/* if bluetooth is not supported this is not fatal*/\n\t\tif (errno == EAFNOSUPPORT)\n\t\t\treturn 0;\n\t\tpcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open raw Bluetooth socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tdev_list = malloc(HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));\n\tif (!dev_list)\n\t{\n\t\tsnprintf(err_str, PCAP_ERRBUF_SIZE, \"Can't allocate %zu bytes for Bluetooth device list\",\n\t\t\tHCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));\n\t\tret = PCAP_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Zero the complete header, which is larger than dev_num because of tail\n\t * padding, to silence Valgrind, which overshoots validating that dev_num\n\t * has been set.\n\t * https://github.com/the-tcpdump-group/libpcap/issues/1083\n\t * https://bugs.kde.org/show_bug.cgi?id=448464\n\t */\n\tmemset(dev_list, 0, sizeof(*dev_list));\n\tdev_list->dev_num = HCI_MAX_DEV;\n\n\tif (ioctl(sock, HCIGETDEVLIST, (void *) dev_list) < 0)\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't get Bluetooth device list via ioctl\");\n\t\tret = PCAP_ERROR;\n\t\tgoto free;\n\t}\n\n\tdev_req = dev_list->dev_req;\n\tfor (i = 0; i < dev_list->dev_num; i++, dev_req++) {\n\t\tchar dev_name[20], dev_descr[40];\n\n\t\tsnprintf(dev_name, sizeof(dev_name), BT_IFACE\"%u\", dev_req->dev_id);\n\t\tsnprintf(dev_descr, sizeof(dev_descr), \"Bluetooth adapter number %u\", i);\n\n\t\t/*\n\t\t * Bluetooth is a wireless technology.\n\t\t * XXX - if there's the notion of associating with a\n\t\t * network, and we can determine whether the interface\n\t\t * is associated with a network, check that and set\n\t\t * the status to PCAP_IF_CONNECTION_STATUS_CONNECTED\n\t\t * or PCAP_IF_CONNECTION_STATUS_DISCONNECTED.\n\t\t */\n\t\tif (pcapint_add_dev(devlistp, dev_name, PCAP_IF_WIRELESS, dev_descr, err_str)  == NULL)\n\t\t{\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfree:\n\tfree(dev_list);\n\ndone:\n\tclose(sock);\n\treturn ret;\n}\n\npcap_t *\nbt_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\n\t/* Does this look like a Bluetooth device? */\n\tcp = device;\n\t/* Does it begin with BT_IFACE? */\n\tif (strncmp(cp, BT_IFACE, sizeof BT_IFACE - 1) != 0) {\n\t\t/* Nope, doesn't begin with BT_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\t/* Yes - is BT_IFACE followed by a number? */\n\tcp += sizeof BT_IFACE - 1;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\tif (devnum < 0) {\n\t\t/* Followed by a non-valid number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_bt);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = bt_activate;\n\treturn (p);\n}\n\nstatic int\nbt_activate(pcap_t* handle)\n{\n\tstruct pcap_bt *handlep = handle->priv;\n\tstruct sockaddr_hci addr;\n\tint opt;\n\tint\t\tdev_id;\n\tstruct hci_filter\tflt;\n\tint err = PCAP_ERROR;\n\n\t/* get bt interface id */\n\tif (sscanf(handle->opt.device, BT_IFACE\"%d\", &dev_id) != 1)\n\t{\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't get Bluetooth device index from %s\",\n\t\t\t handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = BT_CTRL_SIZE+sizeof(pcap_bluetooth_h4_header)+handle->snapshot;\n\thandle->linktype = DLT_BLUETOOTH_HCI_H4_WITH_PHDR;\n\n\thandle->read_op = bt_read_linux;\n\thandle->inject_op = bt_inject_linux;\n\thandle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = bt_setdirection_linux;\n\thandle->set_datalink_op = NULL;\t/* can't change data link type */\n\thandle->getnonblock_op = pcapint_getnonblock_fd;\n\thandle->setnonblock_op = pcapint_setnonblock_fd;\n\thandle->stats_op = bt_stats_linux;\n\thandlep->dev_id = dev_id;\n\n\t/* Create HCI socket */\n\thandle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (handle->fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't create raw socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't allocate dump buffer\");\n\t\tgoto close_fail;\n\t}\n\n\topt = 1;\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't enable data direction info\");\n\t\tgoto close_fail;\n\t}\n\n\topt = 1;\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_TIME_STAMP, &opt, sizeof(opt)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't enable time stamp\");\n\t\tgoto close_fail;\n\t}\n\n\t/* Setup filter, do not call hci function to avoid dependence on\n\t * external libs\t*/\n\tmemset(&flt, 0, sizeof(flt));\n\tmemset((void *) &flt.type_mask, 0xff, sizeof(flt.type_mask));\n\tmemset((void *) &flt.event_mask, 0xff, sizeof(flt.event_mask));\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_FILTER, &flt, sizeof(flt)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't set filter\");\n\t\tgoto close_fail;\n\t}\n\n\n\t/* Bind socket to the HCI device */\n\taddr.hci_family = AF_BLUETOOTH;\n\taddr.hci_dev = handlep->dev_id;\n#ifdef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL\n\taddr.hci_channel = HCI_CHANNEL_RAW;\n#endif\n\tif (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't attach to device %d\", handlep->dev_id);\n\t\tgoto close_fail;\n\t}\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to Bluetooth devices.\n\t\t */\n\t\terr = PCAP_ERROR_RFMON_NOTSUP;\n\t\tgoto close_fail;\n\t}\n\n\tif (handle->opt.buffer_size != 0) {\n\t\t/*\n\t\t * Set the socket buffer size to the specified value.\n\t\t */\n\t\tif (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,\n\t\t    &handle->opt.buffer_size,\n\t\t    sizeof(handle->opt.buffer_size)) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    errno, PCAP_ERRBUF_SIZE, \"SO_RCVBUF\");\n\t\t\tgoto close_fail;\n\t\t}\n\t}\n\n\thandle->selectable_fd = handle->fd;\n\treturn 0;\n\nclose_fail:\n\tpcapint_cleanup_live_common(handle);\n\treturn err;\n}\n\nstatic int\nbt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec  iv;\n\tssize_t ret;\n\tstruct pcap_pkthdr pkth;\n\tpcap_bluetooth_h4_header* bthdr;\n\tu_char *pktd;\n\tint in = 0;\n\n\tpktd = handle->buffer + BT_CTRL_SIZE;\n\tbthdr = (pcap_bluetooth_h4_header*)(void *)pktd;\n\tiv.iov_base = pktd + sizeof(pcap_bluetooth_h4_header);\n\tiv.iov_len  = handle->snapshot;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_iov = &iv;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = handle->buffer;\n\tmsg.msg_controllen = BT_CTRL_SIZE;\n\n\t/* ignore interrupt system call error */\n\tdo {\n\t\tif (handle->break_loop)\n\t\t{\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\tret = recvmsg(handle->fd, &msg, 0);\n\t} while ((ret == -1) && (errno == EINTR));\n\n\tif (ret < 0) {\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\t/* Nonblocking mode, no data */\n\t\t\treturn 0;\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't receive packet\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tpkth.caplen = (bpf_u_int32)ret;\n\n\t/* get direction and timestamp*/\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\twhile (cmsg) {\n\t\tswitch (cmsg->cmsg_type) {\n\t\t\tcase HCI_CMSG_DIR:\n\t\t\t\tmemcpy(&in, CMSG_DATA(cmsg), sizeof in);\n\t\t\t\tbreak;\n\t\t\tcase HCI_CMSG_TSTAMP:\n\t\t\t\tmemcpy(&pkth.ts, CMSG_DATA(cmsg),\n\t\t\t\t\tsizeof pkth.ts);\n\t\t\t\tbreak;\n\t\t}\n\t\t// for musl libc CMSG_NXTHDR()\nDIAG_OFF_SIGN_COMPARE\n\t\tcmsg = CMSG_NXTHDR(&msg, cmsg);\nDIAG_ON_SIGN_COMPARE\n\t}\n\tswitch (handle->direction) {\n\n\tcase PCAP_D_IN:\n\t\tif (!in)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase PCAP_D_OUT:\n\t\tif (in)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbthdr->direction = htonl(in != 0);\n\tpkth.caplen+=sizeof(pcap_bluetooth_h4_header);\n\tpkth.len = pkth.caplen;\n\tif (handle->fcode.bf_insns == NULL ||\n\t    pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n\t\tcallback(user, &pkth, pktd);\n\t\treturn 1;\n\t}\n\treturn 0;\t/* didn't pass filter */\n}\n\nstatic int\nbt_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on Bluetooth devices\");\n\treturn (-1);\n}\n\n\nstatic int\nbt_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_bt *handlep = handle->priv;\n\tint ret;\n\tstruct hci_dev_info dev_info;\n\tstruct hci_dev_stats * s = &dev_info.stat;\n\tdev_info.dev_id = handlep->dev_id;\n\n\t/* ignore eintr */\n\tdo {\n\t\tret = ioctl(handle->fd, HCIGETDEVINFO, (void *)&dev_info);\n\t} while ((ret == -1) && (errno == EINTR));\n\n\tif (ret < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't get stats via ioctl\");\n\t\treturn (-1);\n\n\t}\n\n\t/* we receive both rx and tx frames, so cumulate all stats */\n\tstats->ps_recv = s->evt_rx + s->acl_rx + s->sco_rx + s->cmd_tx +\n\t\ts->acl_tx +s->sco_tx;\n\tstats->ps_drop = s->err_rx + s->err_tx;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}\n\nstatic int\nbt_setdirection_linux(pcap_t *p, pcap_direction_t d)\n{\n\t/*\n\t * It's guaranteed, at this point, that d is a valid\n\t * direction value.\n\t */\n\tp->direction = d;\n\treturn 0;\n}\n"
        },
        {
          "name": "pcap-bt-linux.h",
          "type": "blob",
          "size": 1.7646484375,
          "content": "/*\n * Copyright (c) 2006 Paolo Abeni (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Bluetooth sniffing API implementation for Linux platform\n * By Paolo Abeni <paolo.abeni@email.it>\n */\n\n/*\n * Prototypes for Bluetooth-related functions\n */\nint bt_findalldevs(pcap_if_list_t *devlistp, char *err_str);\npcap_t *bt_create(const char *device, char *ebuf, int *is_ours);\n"
        },
        {
          "name": "pcap-bt-monitor-linux.c",
          "type": "blob",
          "size": 8.0458984375,
          "content": "/*\n * Copyright (c) 2014 Michal Labedzki for Tieto Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/hci.h>\n\n#include \"pcap/bluetooth.h\"\n#include \"pcap-int.h\"\n#include \"diag-control.h\"\n\n#include \"pcap-bt-monitor-linux.h\"\n\n#define BT_CONTROL_SIZE 32\n#define INTERFACE_NAME \"bluetooth-monitor\"\n\n/*\n * Private data.\n * Currently contains nothing.\n */\nstruct pcap_bt_monitor {\n\tint\tdummy;\n};\n\n/*\n * Fields and alignment must match the declaration in the Linux kernel 3.4+.\n * See struct hci_mon_hdr in include/net/bluetooth/hci_mon.h.\n */\nstruct hci_mon_hdr {\n    uint16_t opcode;\n    uint16_t index;\n    uint16_t len;\n} __attribute__((packed));\n\nint\nbt_monitor_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n    int         ret = 0;\n\n    /*\n     * Bluetooth is a wireless technology.\n     *\n     * This is a device to monitor all Bluetooth interfaces, so\n     * there's no notion of \"connected\" or \"disconnected\", any\n     * more than there's a notion of \"connected\" or \"disconnected\"\n     * for the \"any\" device.\n     */\n    if (pcapint_add_dev(devlistp, INTERFACE_NAME,\n                PCAP_IF_WIRELESS|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n                \"Bluetooth Linux Monitor\", err_str) == NULL)\n    {\n        ret = PCAP_ERROR;\n    }\n\n    return ret;\n}\n\nstatic int\nbt_monitor_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n    struct cmsghdr *cmsg;\n    struct msghdr msg;\n    struct iovec  iv[2];\n    ssize_t ret;\n    struct pcap_pkthdr pkth;\n    pcap_bluetooth_linux_monitor_header *bthdr;\n    u_char *pktd;\n    struct hci_mon_hdr hdr;\n\n    pktd = handle->buffer + BT_CONTROL_SIZE;\n    bthdr = (pcap_bluetooth_linux_monitor_header*)(void *)pktd;\n\n    iv[0].iov_base = &hdr;\n    iv[0].iov_len = sizeof(hdr);\n    iv[1].iov_base = pktd + sizeof(pcap_bluetooth_linux_monitor_header);\n    iv[1].iov_len = handle->snapshot;\n\n    memset(&pkth.ts, 0, sizeof(pkth.ts));\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_iov = iv;\n    msg.msg_iovlen = 2;\n    msg.msg_control = handle->buffer;\n    msg.msg_controllen = BT_CONTROL_SIZE;\n\n    do {\n        if (handle->break_loop)\n        {\n            handle->break_loop = 0;\n            return PCAP_ERROR_BREAK;\n        }\n        ret = recvmsg(handle->fd, &msg, 0);\n    } while ((ret == -1) && (errno == EINTR));\n\n    if (ret < 0) {\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            /* Nonblocking mode, no data */\n            return 0;\n        }\n        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't receive packet\");\n        return PCAP_ERROR;\n    }\n\n    pkth.caplen = (bpf_u_int32)(ret - sizeof(hdr) + sizeof(pcap_bluetooth_linux_monitor_header));\n    pkth.len = pkth.caplen;\n\n    // for musl libc CMSG_NXTHDR()\nDIAG_OFF_SIGN_COMPARE\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\nDIAG_ON_SIGN_COMPARE\n        if (cmsg->cmsg_level != SOL_SOCKET) continue;\n\n        if (cmsg->cmsg_type == SCM_TIMESTAMP) {\n            memcpy(&pkth.ts, CMSG_DATA(cmsg), sizeof(pkth.ts));\n        }\n    }\n\n    bthdr->adapter_id = htons(hdr.index);\n    bthdr->opcode = htons(hdr.opcode);\n\n    if (handle->fcode.bf_insns == NULL ||\n        pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n        callback(user, &pkth, pktd);\n        return 1;\n    }\n    return 0;   /* didn't pass filter */\n}\n\nstatic int\nbt_monitor_inject(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n    snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n        \"Packet injection is not supported yet on Bluetooth monitor devices\");\n    return PCAP_ERROR;\n}\n\nstatic int\nbt_monitor_stats(pcap_t *handle _U_, struct pcap_stat *stats)\n{\n    stats->ps_recv = 0;\n    stats->ps_drop = 0;\n    stats->ps_ifdrop = 0;\n\n    return 0;\n}\n\nstatic int\nbt_monitor_activate(pcap_t* handle)\n{\n    struct sockaddr_hci addr;\n    int err = PCAP_ERROR;\n    int opt;\n\n    if (handle->opt.rfmon) {\n        /* monitor mode doesn't apply here */\n        return PCAP_ERROR_RFMON_NOTSUP;\n    }\n\n    /*\n     * Turn a negative snapshot value (invalid), a snapshot value of\n     * 0 (unspecified), or a value bigger than the normal maximum\n     * value, into the maximum allowed value.\n     *\n     * If some application really *needs* a bigger snapshot\n     * length, we should just increase MAXIMUM_SNAPLEN.\n     */\n    if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n        handle->snapshot = MAXIMUM_SNAPLEN;\n\n    handle->bufsize = BT_CONTROL_SIZE + sizeof(pcap_bluetooth_linux_monitor_header) + handle->snapshot;\n    handle->linktype = DLT_BLUETOOTH_LINUX_MONITOR;\n\n    handle->read_op = bt_monitor_read;\n    handle->inject_op = bt_monitor_inject;\n    handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */\n    handle->setdirection_op = NULL; /* Not implemented */\n    handle->set_datalink_op = NULL; /* can't change data link type */\n    handle->getnonblock_op = pcapint_getnonblock_fd;\n    handle->setnonblock_op = pcapint_setnonblock_fd;\n    handle->stats_op = bt_monitor_stats;\n\n    handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n    if (handle->fd < 0) {\n        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't create raw socket\");\n        return PCAP_ERROR;\n    }\n\n    handle->buffer = malloc(handle->bufsize);\n    if (!handle->buffer) {\n        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't allocate dump buffer\");\n        goto close_fail;\n    }\n\n    /* Bind socket to the HCI device */\n    addr.hci_family = AF_BLUETOOTH;\n    addr.hci_dev = HCI_DEV_NONE;\n    addr.hci_channel = HCI_CHANNEL_MONITOR;\n\n    if (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't attach to interface\");\n        goto close_fail;\n    }\n\n    opt = 1;\n    if (setsockopt(handle->fd, SOL_SOCKET, SO_TIMESTAMP, &opt, sizeof(opt)) < 0) {\n        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't enable time stamp\");\n        goto close_fail;\n    }\n\n    handle->selectable_fd = handle->fd;\n\n    return 0;\n\nclose_fail:\n    pcapint_cleanup_live_common(handle);\n    return err;\n}\n\npcap_t *\nbt_monitor_create(const char *device, char *ebuf, int *is_ours)\n{\n    pcap_t      *p;\n\n    if (strcmp(device, INTERFACE_NAME) != 0) {\n        *is_ours = 0;\n        return NULL;\n    }\n\n    *is_ours = 1;\n    p = PCAP_CREATE_COMMON(ebuf, struct pcap_bt_monitor);\n    if (p == NULL)\n        return NULL;\n\n    p->activate_op = bt_monitor_activate;\n\n    return p;\n}\n"
        },
        {
          "name": "pcap-bt-monitor-linux.h",
          "type": "blob",
          "size": 1.64453125,
          "content": "/*\n * Copyright (c) 2014 Michal Labedzki for Tieto Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nint bt_monitor_findalldevs(pcap_if_list_t *devlistp, char *err_str);\npcap_t *bt_monitor_create(const char *device, char *ebuf, int *is_ours);\n"
        },
        {
          "name": "pcap-common.c",
          "type": "blob",
          "size": 52.4453125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * pcap-common.c - common code for pcap and pcapng files\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n\n#include \"pcap-int.h\"\n\n#include \"pcap-common.h\"\n\n/*\n * We don't write DLT_* values to capture files, because they're not the\n * same on all platforms.\n *\n * Unfortunately, the various flavors of BSD have not always used the same\n * numerical values for the same data types, and various patches to\n * libpcap for non-BSD OSes have added their own DLT_* codes for link\n * layer encapsulation types seen on those OSes, and those codes have had,\n * in some cases, values that were also used, on other platforms, for other\n * link layer encapsulation types.\n *\n * This means that capture files of a type whose numerical DLT_* code\n * means different things on different BSDs, or with different versions\n * of libpcap, can't always be read on systems other than those like\n * the one running on the machine on which the capture was made.\n *\n * Instead, we define here a set of LINKTYPE_* codes, and map DLT_* codes\n * to LINKTYPE_* codes when writing a savefile header, and map LINKTYPE_*\n * codes to DLT_* codes when reading a savefile header.\n *\n * For those DLT_* codes that have, as far as we know, the same values on\n * all platforms (DLT_NULL through DLT_FDDI), we define LINKTYPE_xxx as\n * DLT_xxx; that way, captures of those types can still be read by\n * versions of libpcap that map LINKTYPE_* values to DLT_* values, and\n * captures of those types written by versions of libpcap that map DLT_\n * values to LINKTYPE_ values can still be read by older versions\n * of libpcap.\n *\n * The other LINKTYPE_* codes are given values starting at 100, in the\n * hopes that no DLT_* code will be given one of those values.\n *\n * In order to ensure that a given LINKTYPE_* code's value will refer to\n * the same encapsulation type on all platforms, you should not allocate\n * a new LINKTYPE_* value without consulting\n * \"tcpdump-workers@lists.tcpdump.org\".  The tcpdump developers will\n * allocate a value for you, and will not subsequently allocate it to\n * anybody else; that value will be added to the \"pcap.h\" in the\n * tcpdump.org Git repository, so that a future libpcap release will\n * include it.\n *\n * You should, if possible, also contribute patches to libpcap and tcpdump\n * to handle the new encapsulation type, so that they can also be checked\n * into the tcpdump.org Git repository and so that they will appear in\n * future libpcap and tcpdump releases.\n *\n * Do *NOT* assume that any values after the largest value in this file\n * are available; you might not have the most up-to-date version of this\n * file, and new values after that one might have been assigned.  Also,\n * do *NOT* use any values below 100 - those might already have been\n * taken by one (or more!) organizations.\n *\n * Any platform that defines additional DLT_* codes should:\n *\n *\trequest a LINKTYPE_* code and value from tcpdump.org,\n *\tas per the above;\n *\n *\tadd, in their version of libpcap, an entry to map\n *\tthose DLT_* codes to the corresponding LINKTYPE_*\n *\tcode;\n *\n *\tredefine, in their \"net/bpf.h\", any DLT_* values\n *\tthat collide with the values used by their additional\n *\tDLT_* codes, to remove those collisions (but without\n *\tmaking them collide with any of the LINKTYPE_*\n *\tvalues equal to 50 or above; they should also avoid\n *\tdefining DLT_* values that collide with those\n *\tLINKTYPE_* values, either).\n */\n\n/*\n * These values the DLT_ values for which are the same on all platforms,\n * and that have been defined by <net/bpf.h> for ages.\n *\n * For those, the LINKTYPE_ values are equal to the DLT_ values.\n *\n * LINKTYPE_LOW_MATCHING_MIN is the lowest such value;\n * LINKTYPE_LOW_MATCHING_MAX is the highest such value.\n */\n#define LINKTYPE_LOW_MATCHING_MIN\t0\t\t/* lowest value in this \"matching\" range */\n#define LINKTYPE_NULL\t\tDLT_NULL\n#define LINKTYPE_ETHERNET\tDLT_EN10MB\t/* also for 100Mb and up */\n#define LINKTYPE_EXP_ETHERNET\tDLT_EN3MB\t/* 3Mb experimental Ethernet */\n#define LINKTYPE_AX25\t\tDLT_AX25\n#define LINKTYPE_PRONET\t\tDLT_PRONET\n#define LINKTYPE_CHAOS\t\tDLT_CHAOS\n#define LINKTYPE_IEEE802_5\tDLT_IEEE802\t/* DLT_IEEE802 is used for 802.5 Token Ring */\n#define LINKTYPE_ARCNET_BSD\tDLT_ARCNET\t/* BSD-style headers */\n#define LINKTYPE_SLIP\t\tDLT_SLIP\n#define LINKTYPE_PPP\t\tDLT_PPP\n#define LINKTYPE_FDDI\t\tDLT_FDDI\n\n#define LINKTYPE_LOW_MATCHING_MAX\tLINKTYPE_FDDI\t/* highest value in this \"matching\" range */\n\n/*\n * LINKTYPE_PPP is for use when there might, or might not, be an RFC 1662\n * PPP in HDLC-like framing header (with 0xff 0x03 before the PPP protocol\n * field) at the beginning of the packet.\n *\n * This is for use when there is always such a header; the address field\n * might be 0xff, for regular PPP, or it might be an address field for Cisco\n * point-to-point with HDLC framing as per section 4.3.1 of RFC 1547 (\"Cisco\n * HDLC\").  This is, for example, what you get with NetBSD's DLT_PPP_SERIAL.\n *\n * We give it the same value as NetBSD's DLT_PPP_SERIAL, in the hopes that\n * nobody else will choose a DLT_ value of 50, and so that DLT_PPP_SERIAL\n * captures will be written out with a link type that NetBSD's tcpdump\n * can read.\n */\n#define LINKTYPE_PPP_HDLC\t50\t\t/* PPP in HDLC-like framing */\n\n#define LINKTYPE_PPP_ETHER\t51\t\t/* NetBSD PPP-over-Ethernet */\n\n#define LINKTYPE_SYMANTEC_FIREWALL 99\t\t/* Symantec Enterprise Firewall */\n\n/*\n * These correspond to DLT_s that have different values on different\n * platforms; we map between these values in capture files and\n * the DLT_ values as returned by pcap_datalink() and passed to\n * pcap_open_dead().\n */\n#define LINKTYPE_ATM_RFC1483\t100\t\t/* LLC/SNAP-encapsulated ATM */\n#define LINKTYPE_RAW\t\t101\t\t/* raw IP */\n#define LINKTYPE_SLIP_BSDOS\t102\t\t/* BSD/OS SLIP BPF header */\n#define LINKTYPE_PPP_BSDOS\t103\t\t/* BSD/OS PPP BPF header */\n\n/*\n * Values starting with 104 are used for newly-assigned link-layer\n * header type values; for those link-layer header types, the DLT_\n * value returned by pcap_datalink() and passed to pcap_open_dead(),\n * and the LINKTYPE_ value that appears in capture files, are the\n * same.\n *\n * LINKTYPE_HIGH_MATCHING_MIN is the lowest such value;\n * LINKTYPE_HIGH_MATCHING_MAX is the highest such value.\n */\n#define LINKTYPE_HIGH_MATCHING_MIN\t104\t\t/* lowest value in the \"matching\" range */\n\n#define LINKTYPE_C_HDLC\t\t104\t\t/* Cisco HDLC */\n#define LINKTYPE_IEEE802_11\t105\t\t/* IEEE 802.11 (wireless) */\n#define LINKTYPE_ATM_CLIP\t106\t\t/* Linux Classical IP over ATM */\n#define LINKTYPE_FRELAY\t\t107\t\t/* Frame Relay */\n#define LINKTYPE_LOOP\t\t108\t\t/* OpenBSD loopback */\n#define LINKTYPE_ENC\t\t109\t\t/* OpenBSD IPSEC enc */\n\n/*\n * These two types are reserved for future use.\n */\n#define LINKTYPE_LANE8023\t110\t\t/* ATM LANE + 802.3 */\n#define LINKTYPE_HIPPI\t\t111\t\t/* NetBSD HIPPI */\n\n/*\n * Used for NetBSD DLT_HDLC; from looking at the one driver in NetBSD\n * that uses it, it's Cisco HDLC, so it's the same as DLT_C_HDLC/\n * LINKTYPE_C_HDLC, but we define a separate value to avoid some\n * compatibility issues with programs on NetBSD.\n *\n * All code should treat LINKTYPE_NETBSD_HDLC and LINKTYPE_C_HDLC the same.\n */\n#define LINKTYPE_NETBSD_HDLC\t112\t\t/* NetBSD HDLC framing */\n\n#define LINKTYPE_LINUX_SLL\t113\t\t/* Linux cooked socket capture */\n#define LINKTYPE_LTALK\t\t114\t\t/* Apple LocalTalk hardware */\n#define LINKTYPE_ECONET\t\t115\t\t/* Acorn Econet */\n\n/*\n * Reserved for use with OpenBSD ipfilter.\n */\n#define LINKTYPE_IPFILTER\t116\n\n#define LINKTYPE_PFLOG\t\t117\t\t/* OpenBSD DLT_PFLOG */\n#define LINKTYPE_CISCO_IOS\t118\t\t/* For Cisco-internal use */\n#define LINKTYPE_IEEE802_11_PRISM 119\t\t/* 802.11 plus Prism II monitor mode radio metadata header */\n#define LINKTYPE_IEEE802_11_AIRONET 120\t\t/* 802.11 plus FreeBSD Aironet driver radio metadata header */\n\n/*\n * Reserved for Siemens HiPath HDLC.\n */\n#define LINKTYPE_HHDLC\t\t121\n\n#define LINKTYPE_IP_OVER_FC\t122\t\t/* RFC 2625 IP-over-Fibre Channel */\n#define LINKTYPE_SUNATM\t\t123\t\t/* Solaris+SunATM */\n\n/*\n * Reserved as per request from Kent Dahlgren <kent@praesum.com>\n * for private use.\n */\n#define LINKTYPE_RIO\t\t124\t\t/* RapidIO */\n#define LINKTYPE_PCI_EXP\t125\t\t/* PCI Express */\n#define LINKTYPE_AURORA\t\t126\t\t/* Xilinx Aurora link layer */\n\n#define LINKTYPE_IEEE802_11_RADIOTAP 127\t/* 802.11 plus radiotap radio metadata header */\n\n/*\n * Reserved for the TZSP encapsulation, as per request from\n * Chris Waters <chris.waters@networkchemistry.com>\n * TZSP is a generic encapsulation for any other link type,\n * which includes a means to include meta-information\n * with the packet, e.g. signal strength and channel\n * for 802.11 packets.\n */\n#define LINKTYPE_TZSP\t\t128\t\t/* Tazmen Sniffer Protocol */\n\n#define LINKTYPE_ARCNET_LINUX\t129\t\t/* Linux-style headers */\n\n/*\n * Juniper-private data link types, as per request from\n * Hannes Gredler <hannes@juniper.net>.  The corresponding\n * DLT_s are used for passing on chassis-internal\n * metainformation such as QOS profiles, etc..\n */\n#define LINKTYPE_JUNIPER_MLPPP  130\n#define LINKTYPE_JUNIPER_MLFR   131\n#define LINKTYPE_JUNIPER_ES     132\n#define LINKTYPE_JUNIPER_GGSN   133\n#define LINKTYPE_JUNIPER_MFR    134\n#define LINKTYPE_JUNIPER_ATM2   135\n#define LINKTYPE_JUNIPER_SERVICES 136\n#define LINKTYPE_JUNIPER_ATM1   137\n\n#define LINKTYPE_APPLE_IP_OVER_IEEE1394 138\t/* Apple IP-over-IEEE 1394 cooked header */\n\n#define LINKTYPE_MTP2_WITH_PHDR\t139\n#define LINKTYPE_MTP2\t\t140\n#define LINKTYPE_MTP3\t\t141\n#define LINKTYPE_SCCP\t\t142\n\n#define LINKTYPE_DOCSIS\t\t143\t\t/* DOCSIS MAC frames */\n\n#define LINKTYPE_LINUX_IRDA\t144\t\t/* Linux-IrDA */\n\n/*\n * Reserved for IBM SP switch and IBM Next Federation switch.\n */\n#define LINKTYPE_IBM_SP\t\t145\n#define LINKTYPE_IBM_SN\t\t146\n\n/*\n * Reserved for private use.  If you have some link-layer header type\n * that you want to use within your organization, with the capture files\n * using that link-layer header type not ever be sent outside your\n * organization, you can use these values.\n *\n * No libpcap release will use these for any purpose, nor will any\n * tcpdump release use them, either.\n *\n * Do *NOT* use these in capture files that you expect anybody not using\n * your private versions of capture-file-reading tools to read; in\n * particular, do *NOT* use them in products, otherwise you may find that\n * people won't be able to use tcpdump, or snort, or Ethereal, or... to\n * read capture files from your firewall/intrusion detection/traffic\n * monitoring/etc. appliance, or whatever product uses that LINKTYPE_ value,\n * and you may also find that the developers of those applications will\n * not accept patches to let them read those files.\n *\n * Also, do not use them if somebody might send you a capture using them\n * for *their* private type and tools using them for *your* private type\n * would have to read them.\n *\n * Instead, in those cases, ask \"tcpdump-workers@lists.tcpdump.org\" for a\n * new DLT_ and LINKTYPE_ value, as per the comment in pcap/bpf.h, and use\n * the type you're given.\n */\n#define LINKTYPE_USER0\t\t147\n#define LINKTYPE_USER1\t\t148\n#define LINKTYPE_USER2\t\t149\n#define LINKTYPE_USER3\t\t150\n#define LINKTYPE_USER4\t\t151\n#define LINKTYPE_USER5\t\t152\n#define LINKTYPE_USER6\t\t153\n#define LINKTYPE_USER7\t\t154\n#define LINKTYPE_USER8\t\t155\n#define LINKTYPE_USER9\t\t156\n#define LINKTYPE_USER10\t\t157\n#define LINKTYPE_USER11\t\t158\n#define LINKTYPE_USER12\t\t159\n#define LINKTYPE_USER13\t\t160\n#define LINKTYPE_USER14\t\t161\n#define LINKTYPE_USER15\t\t162\n\n/*\n * For future use with 802.11 captures - defined by AbsoluteValue\n * Systems to store a number of bits of link-layer information\n * including radio information:\n *\n *\thttp://www.shaftnet.org/~pizza/software/capturefrm.txt\n */\n#define LINKTYPE_IEEE802_11_AVS\t163\t/* 802.11 plus AVS radio metadata header */\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.  The corresponding\n * DLT_s are used for passing on chassis-internal\n * metainformation such as QOS profiles, etc..\n */\n#define LINKTYPE_JUNIPER_MONITOR 164\n\n/*\n * BACnet MS/TP frames.\n */\n#define LINKTYPE_BACNET_MS_TP\t165\n\n/*\n * Another PPP variant as per request from Karsten Keil <kkeil@suse.de>.\n *\n * This is used in some OSes to allow a kernel socket filter to distinguish\n * between incoming and outgoing packets, on a socket intended to\n * supply pppd with outgoing packets so it can do dial-on-demand and\n * hangup-on-lack-of-demand; incoming packets are filtered out so they\n * don't cause pppd to hold the connection up (you don't want random\n * input packets such as port scans, packets from old lost connections,\n * etc. to force the connection to stay up).\n *\n * The first byte of the PPP header (0xff03) is modified to accommodate\n * the direction - 0x00 = IN, 0x01 = OUT.\n */\n#define LINKTYPE_PPP_PPPD\t166\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.  The DLT_s are used\n * for passing on chassis-internal metainformation such as\n * QOS profiles, cookies, etc..\n */\n#define LINKTYPE_JUNIPER_PPPOE     167\n#define LINKTYPE_JUNIPER_PPPOE_ATM 168\n\n#define LINKTYPE_GPRS_LLC\t169\t\t/* GPRS LLC */\n#define LINKTYPE_GPF_T\t\t170\t\t/* GPF-T (ITU-T G.7041/Y.1303) */\n#define LINKTYPE_GPF_F\t\t171\t\t/* GPF-F (ITU-T G.7041/Y.1303) */\n\n/*\n * Requested by Oolan Zimmer <oz@gcom.com> for use in Gcom's T1/E1 line\n * monitoring equipment.\n */\n#define LINKTYPE_GCOM_T1E1\t172\n#define LINKTYPE_GCOM_SERIAL\t173\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.  The DLT_ is used\n * for internal communication to Physical Interface Cards (PIC)\n */\n#define LINKTYPE_JUNIPER_PIC_PEER    174\n\n/*\n * Link types requested by Gregor Maier <gregor@endace.com> of Endace\n * Measurement Systems.  They add an ERF header (see\n * https://www.endace.com/support/EndaceRecordFormat.pdf) in front of\n * the link-layer header.\n */\n#define LINKTYPE_ERF_ETH\t175\t/* Ethernet */\n#define LINKTYPE_ERF_POS\t176\t/* Packet-over-SONET */\n\n/*\n * Requested by Daniele Orlandi <daniele@orlandi.com> for raw LAPD\n * for vISDN (http://www.orlandi.com/visdn/).  Its link-layer header\n * includes additional information before the LAPD header, so it's\n * not necessarily a generic LAPD header.\n */\n#define LINKTYPE_LINUX_LAPD\t177\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n * The Link Types are used for prepending meta-information\n * like interface index, interface name\n * before standard Ethernet, PPP, Frelay & C-HDLC Frames\n */\n#define LINKTYPE_JUNIPER_ETHER  178\n#define LINKTYPE_JUNIPER_PPP    179\n#define LINKTYPE_JUNIPER_FRELAY 180\n#define LINKTYPE_JUNIPER_CHDLC  181\n\n/*\n * Multi Link Frame Relay (FRF.16)\n */\n#define LINKTYPE_MFR            182\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n * The DLT_ is used for internal communication with a\n * voice Adapter Card (PIC)\n */\n#define LINKTYPE_JUNIPER_VP     183\n\n/*\n * Arinc 429 frames.\n * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.\n * Every frame contains a 32bit A429 label.\n * More documentation on Arinc 429 can be found at\n * https://web.archive.org/web/20040616233302/https://www.condoreng.com/support/downloads/tutorials/ARINCTutorial.pdf\n */\n#define LINKTYPE_A429           184\n\n/*\n * Arinc 653 Interpartition Communication messages.\n * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.\n * Please refer to the A653-1 standard for more information.\n */\n#define LINKTYPE_A653_ICM       185\n\n/*\n * This used to be \"USB packets, beginning with a USB setup header;\n * requested by Paolo Abeni <paolo.abeni@email.it>.\"\n *\n * However, that header didn't work all that well - it left out some\n * useful information - and was abandoned in favor of the DLT_USB_LINUX\n * header.\n *\n * This is now used by FreeBSD for its BPF taps for USB; that has its\n * own headers.  So it is written, so it is done.\n */\n#define LINKTYPE_USB_FREEBSD\t186\n\n/*\n * Bluetooth HCI UART transport layer (part H:4); requested by\n * Paolo Abeni.\n */\n#define LINKTYPE_BLUETOOTH_HCI_H4\t187\n\n/*\n * IEEE 802.16 MAC Common Part Sublayer; requested by Maria Cruz\n * <cruz_petagay@bah.com>.\n */\n#define LINKTYPE_IEEE802_16_MAC_CPS\t188\n\n/*\n * USB packets, beginning with a Linux USB header; requested by\n * Paolo Abeni <paolo.abeni@email.it>.\n */\n#define LINKTYPE_USB_LINUX\t\t189\n\n/*\n * Controller Area Network (CAN) v. 2.0B packets.\n * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.\n * Used to dump CAN packets coming from a CAN Vector board.\n * More documentation on the CAN v2.0B frames can be found at\n * http://www.can-cia.org/downloads/?269\n */\n#define LINKTYPE_CAN20B         190\n\n/*\n * IEEE 802.15.4, with address fields padded, as is done by Linux\n * drivers; requested by Juergen Schimmer.\n */\n#define LINKTYPE_IEEE802_15_4_LINUX\t191\n\n/*\n * Per Packet Information encapsulated packets.\n * LINKTYPE_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.\n */\n#define LINKTYPE_PPI\t\t\t192\n\n/*\n * Header for 802.16 MAC Common Part Sublayer plus a radiotap radio header;\n * requested by Charles Clancy.\n */\n#define LINKTYPE_IEEE802_16_MAC_CPS_RADIO\t193\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n * The DLT_ is used for internal communication with a\n * integrated service module (ISM).\n */\n#define LINKTYPE_JUNIPER_ISM    194\n\n/*\n * IEEE 802.15.4, exactly as it appears in the spec (no padding, no\n * nothing), and with the FCS at the end of the frame; requested by\n * Mikko Saarnivala <mikko.saarnivala@sensinode.com>.\n *\n * This should only be used if the FCS is present at the end of the\n * frame; if the frame has no FCS, DLT_IEEE802_15_4_NOFCS should be\n * used.\n */\n#define LINKTYPE_IEEE802_15_4_WITHFCS\t195\n\n/*\n * Various link-layer types, with a pseudo-header, for SITA\n * (https://www.sita.aero/); requested by Fulko Hew (fulko.hew@gmail.com).\n */\n#define LINKTYPE_SITA\t\t196\n\n/*\n * Various link-layer types, with a pseudo-header, for Endace DAG cards;\n * encapsulates Endace ERF records.  Requested by Stephen Donnelly\n * <stephen@endace.com>.\n */\n#define LINKTYPE_ERF\t\t197\n\n/*\n * Special header prepended to Ethernet packets when capturing from a\n * u10 Networks board.  Requested by Phil Mulholland\n * <phil@u10networks.com>.\n */\n#define LINKTYPE_RAIF1\t\t198\n\n/*\n * IPMB packet for IPMI, beginning with a 2-byte header, followed by\n * the I2C slave address, followed by the netFn and LUN, etc..\n * Requested by Chanthy Toeung <chanthy.toeung@ca.kontron.com>.\n *\n * XXX - its DLT_ value used to be called DLT_IPMB, back when we got the\n * impression from the email thread requesting it that the packet\n * had no extra 2-byte header.  We've renamed it; if anybody used\n * DLT_IPMB and assumed no 2-byte header, this will cause the compile\n * to fail, at which point we'll have to figure out what to do about\n * the two header types using the same DLT_/LINKTYPE_ value.  If that\n * doesn't happen, we'll assume nobody used it and that the redefinition\n * is safe.\n */\n#define LINKTYPE_IPMB_KONTRON\t199\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n * The DLT_ is used for capturing data on a secure tunnel interface.\n */\n#define LINKTYPE_JUNIPER_ST     200\n\n/*\n * Bluetooth HCI UART transport layer (part H:4), with pseudo-header\n * that includes direction information; requested by Paolo Abeni.\n */\n#define LINKTYPE_BLUETOOTH_HCI_H4_WITH_PHDR\t201\n\n/*\n * AX.25 packet with a 1-byte KISS header; see\n *\n *\thttp://www.ax25.net/kiss.htm\n *\n * as per Richard Stearn <richard@rns-stearn.demon.co.uk>.\n */\n#define LINKTYPE_AX25_KISS\t202\n\n/*\n * LAPD packets from an ISDN channel, starting with the address field,\n * with no pseudo-header.\n * Requested by Varuna De Silva <varunax@gmail.com>.\n */\n#define LINKTYPE_LAPD\t\t203\n\n/*\n * PPP, with a one-byte direction pseudo-header prepended - zero means\n * \"received by this host\", non-zero (any non-zero value) means \"sent by\n * this host\" - as per Will Barker <w.barker@zen.co.uk>.\n */\n#define LINKTYPE_PPP_WITH_DIR\t204\t/* Don't confuse with LINKTYPE_PPP_PPPD */\n\n/*\n * Cisco HDLC, with a one-byte direction pseudo-header prepended - zero\n * means \"received by this host\", non-zero (any non-zero value) means\n * \"sent by this host\" - as per Will Barker <w.barker@zen.co.uk>.\n */\n#define LINKTYPE_C_HDLC_WITH_DIR 205\t/* Cisco HDLC */\n\n/*\n * Frame Relay, with a one-byte direction pseudo-header prepended - zero\n * means \"received by this host\" (DCE -> DTE), non-zero (any non-zero\n * value) means \"sent by this host\" (DTE -> DCE) - as per Will Barker\n * <w.barker@zen.co.uk>.\n */\n#define LINKTYPE_FRELAY_WITH_DIR 206\t/* Frame Relay */\n\n/*\n * LAPB, with a one-byte direction pseudo-header prepended - zero means\n * \"received by this host\" (DCE -> DTE), non-zero (any non-zero value)\n * means \"sent by this host\" (DTE -> DCE)- as per Will Barker\n * <w.barker@zen.co.uk>.\n */\n#define LINKTYPE_LAPB_WITH_DIR\t207\t/* LAPB */\n\n/*\n * 208 is reserved for an as-yet-unspecified proprietary link-layer\n * type, as requested by Will Barker.\n */\n\n/*\n * I2C with a Linux-specific pseudo-header; as requested by Alexey Neyman\n * <avn@pigeonpoint.com>.\n *\n * In the discussion, starting at\n *\n *\thttps://seclists.org/tcpdump/2007/q4/127\n *\n * the original idea that it was a link-layer type for I2C, but,\n * as it was proposed as a way to capture IPMB-over-I2C, and\n * the conclusion was that reserving it for IPMB-over-I2C meant\n * that analyzers could just assume the traffic was IPMB.\n *\n * However, it was later used for HDMI DDC traffic, so there's\n * no point in pretending that it's IPMB-only any more, so we\n * renamed it to a name suggested earlier in the discussion,\n * namely LINKTYPE_I2C_LINUX/DLT_I2C_LINUX, as the header was,\n * at least originally, Linux-specific.\n */\n#define LINKTYPE_I2C_LINUX\t209\n\n/*\n * FlexRay automotive bus - http://www.flexray.com/ - as requested\n * by Hannes Kaelber <hannes.kaelber@x2e.de>.\n */\n#define LINKTYPE_FLEXRAY\t210\n\n/*\n * Media Oriented Systems Transport (MOST) bus for multimedia\n * transport - https://www.mostcooperation.com/ - as requested\n * by Hannes Kaelber <hannes.kaelber@x2e.de>.\n */\n#define LINKTYPE_MOST\t\t211\n\n/*\n * Local Interconnect Network (LIN) bus for vehicle networks -\n * http://www.lin-subbus.org/ - as requested by Hannes Kaelber\n * <hannes.kaelber@x2e.de>.\n */\n#define LINKTYPE_LIN\t\t212\n\n/*\n * X2E-private data link type used for serial line capture,\n * as requested by Hannes Kaelber <hannes.kaelber@x2e.de>.\n */\n#define LINKTYPE_X2E_SERIAL\t213\n\n/*\n * X2E-private data link type used for the Xoraya data logger\n * family, as requested by Hannes Kaelber <hannes.kaelber@x2e.de>.\n */\n#define LINKTYPE_X2E_XORAYA\t214\n\n/*\n * IEEE 802.15.4, exactly as it appears in the spec (no padding, no\n * nothing), but with the PHY-level data for non-ASK PHYs (4 octets\n * of 0 as preamble, one octet of SFD, one octet of frame length+\n * reserved bit, and then the MAC-layer data, starting with the\n * frame control field).\n *\n * Requested by Max Filippov <jcmvbkbc@gmail.com>.\n */\n#define LINKTYPE_IEEE802_15_4_NONASK_PHY\t215\n\n/*\n * David Gibson <david@gibson.dropbear.id.au> requested this for\n * captures from the Linux kernel /dev/input/eventN devices. This\n * is used to communicate keystrokes and mouse movements from the\n * Linux kernel to display systems, such as Xorg.\n */\n#define LINKTYPE_LINUX_EVDEV\t216\n\n/*\n * GSM Um and Abis interfaces, preceded by a \"gsmtap\" header.\n *\n * Requested by Harald Welte <laforge@gnumonks.org>.\n */\n#define LINKTYPE_GSMTAP_UM\t217\n#define LINKTYPE_GSMTAP_ABIS\t218\n\n/*\n * MPLS, with an MPLS label as the link-layer header.\n * Requested by Michele Marchetto <michele@openbsd.org> on behalf\n * of OpenBSD.\n */\n#define LINKTYPE_MPLS\t\t219\n\n/*\n * USB packets, beginning with a Linux USB header, with the USB header\n * padded to 64 bytes; required for memory-mapped access.\n */\n#define LINKTYPE_USB_LINUX_MMAPPED\t\t220\n\n/*\n * DECT packets, with a pseudo-header; requested by\n * Matthias Wenzel <tcpdump@mazzoo.de>.\n */\n#define LINKTYPE_DECT\t\t221\n\n/*\n * From: \"Lidwa, Eric (GSFC-582.0)[SGT INC]\" <eric.lidwa-1@nasa.gov>\n * Date: Mon, 11 May 2009 11:18:30 -0500\n *\n * DLT_AOS. We need it for AOS Space Data Link Protocol.\n *   I have already written dissectors for but need an OK from\n *   legal before I can submit a patch.\n *\n */\n#define LINKTYPE_AOS\t\t222\n\n/*\n * WirelessHART (Highway Addressable Remote Transducer)\n * From the HART Communication Foundation\n * IEC/PAS 62591\n *\n * Requested by Sam Roberts <vieuxtech@gmail.com>.\n */\n#define LINKTYPE_WIHART\t\t223\n\n/*\n * Fibre Channel FC-2 frames, beginning with a Frame_Header.\n * Requested by Kahou Lei <kahou82@gmail.com>.\n */\n#define LINKTYPE_FC_2\t\t224\n\n/*\n * Fibre Channel FC-2 frames, beginning with an encoding of the\n * SOF, and ending with an encoding of the EOF.\n *\n * The encodings represent the frame delimiters as 4-byte sequences\n * representing the corresponding ordered sets, with K28.5\n * represented as 0xBC, and the D symbols as the corresponding\n * byte values; for example, SOFi2, which is K28.5 - D21.5 - D1.2 - D21.2,\n * is represented as 0xBC 0xB5 0x55 0x55.\n *\n * Requested by Kahou Lei <kahou82@gmail.com>.\n */\n#define LINKTYPE_FC_2_WITH_FRAME_DELIMS\t\t225\n\n/*\n * Solaris ipnet pseudo-header; requested by Darren Reed <Darren.Reed@Sun.COM>.\n *\n * The pseudo-header starts with a one-byte version number; for version 2,\n * the pseudo-header is:\n *\n * struct dl_ipnetinfo {\n *     uint8_t   dli_version;\n *     uint8_t   dli_family;\n *     uint16_t  dli_htype;\n *     uint32_t  dli_pktlen;\n *     uint32_t  dli_ifindex;\n *     uint32_t  dli_grifindex;\n *     uint32_t  dli_zsrc;\n *     uint32_t  dli_zdst;\n * };\n *\n * dli_version is 2 for the current version of the pseudo-header.\n *\n * dli_family is a Solaris address family value, so it's 2 for IPv4\n * and 26 for IPv6.\n *\n * dli_htype is a \"hook type\" - 0 for incoming packets, 1 for outgoing\n * packets, and 2 for packets arriving from another zone on the same\n * machine.\n *\n * dli_pktlen is the length of the packet data following the pseudo-header\n * (so the captured length minus dli_pktlen is the length of the\n * pseudo-header, assuming the entire pseudo-header was captured).\n *\n * dli_ifindex is the interface index of the interface on which the\n * packet arrived.\n *\n * dli_grifindex is the group interface index number (for IPMP interfaces).\n *\n * dli_zsrc is the zone identifier for the source of the packet.\n *\n * dli_zdst is the zone identifier for the destination of the packet.\n *\n * A zone number of 0 is the global zone; a zone number of 0xffffffff\n * means that the packet arrived from another host on the network, not\n * from another zone on the same machine.\n *\n * An IPv4 or IPv6 datagram follows the pseudo-header; dli_family indicates\n * which of those it is.\n */\n#define LINKTYPE_IPNET\t\t226\n\n/*\n * CAN (Controller Area Network) frames, with a pseudo-header as supplied\n * by Linux SocketCAN, and with multi-byte numerical fields in that header\n * in big-endian byte order.\n *\n * See Documentation/networking/can.txt in the Linux source.\n *\n * Requested by Felix Obenhuber <felix@obenhuber.de>.\n */\n#define LINKTYPE_CAN_SOCKETCAN\t227\n\n/*\n * Raw IPv4/IPv6; different from DLT_RAW in that the DLT_ value specifies\n * whether it's v4 or v6.  Requested by Darren Reed <Darren.Reed@Sun.COM>.\n */\n#define LINKTYPE_IPV4\t\t228\n#define LINKTYPE_IPV6\t\t229\n\n/*\n * IEEE 802.15.4, exactly as it appears in the spec (no padding, no\n * nothing), and with no FCS at the end of the frame; requested by\n * Jon Smirl <jonsmirl@gmail.com>.\n */\n#define LINKTYPE_IEEE802_15_4_NOFCS\t\t230\n\n/*\n * Raw D-Bus:\n *\n *\thttps://www.freedesktop.org/wiki/Software/dbus\n *\n * messages:\n *\n *\thttps://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-messages\n *\n * starting with the endianness flag, followed by the message type, etc.,\n * but without the authentication handshake before the message sequence:\n *\n *\thttps://dbus.freedesktop.org/doc/dbus-specification.html#auth-protocol\n *\n * Requested by Martin Vidner <martin@vidner.net>.\n */\n#define LINKTYPE_DBUS\t\t231\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n */\n#define LINKTYPE_JUNIPER_VS\t\t\t232\n#define LINKTYPE_JUNIPER_SRX_E2E\t\t233\n#define LINKTYPE_JUNIPER_FIBRECHANNEL\t\t234\n\n/*\n * DVB-CI (DVB Common Interface for communication between a PC Card\n * module and a DVB receiver).  See\n *\n *\thttps://www.kaiser.cx/pcap-dvbci.html\n *\n * for the specification.\n *\n * Requested by Martin Kaiser <martin@kaiser.cx>.\n */\n#define LINKTYPE_DVB_CI\t\t235\n\n/*\n * Variant of 3GPP TS 27.010 multiplexing protocol.  Requested\n * by Hans-Christoph Schemmel <hans-christoph.schemmel@cinterion.com>.\n */\n#define LINKTYPE_MUX27010\t236\n\n/*\n * STANAG 5066 D_PDUs.  Requested by M. Baris Demiray\n * <barisdemiray@gmail.com>.\n */\n#define LINKTYPE_STANAG_5066_D_PDU\t\t237\n\n/*\n * Juniper-private data link type, as per request from\n * Hannes Gredler <hannes@juniper.net>.\n */\n#define LINKTYPE_JUNIPER_ATM_CEMIC\t\t238\n\n/*\n * NetFilter LOG messages\n * (payload of netlink NFNL_SUBSYS_ULOG/NFULNL_MSG_PACKET packets)\n *\n * Requested by Jakub Zawadzki <darkjames-ws@darkjames.pl>\n */\n#define LINKTYPE_NFLOG\t\t239\n\n/*\n * Hilscher Gesellschaft fuer Systemautomation mbH link-layer type\n * for Ethernet packets with a 4-byte pseudo-header and always\n * with the payload including the FCS, as supplied by their\n * netANALYZER hardware and software.\n *\n * Requested by Holger P. Frommer <HPfrommer@hilscher.com>\n */\n#define LINKTYPE_NETANALYZER\t240\n\n/*\n * Hilscher Gesellschaft fuer Systemautomation mbH link-layer type\n * for Ethernet packets with a 4-byte pseudo-header and FCS and\n * 1 byte of SFD, as supplied by their netANALYZER hardware and\n * software.\n *\n * Requested by Holger P. Frommer <HPfrommer@hilscher.com>\n */\n#define LINKTYPE_NETANALYZER_TRANSPARENT\t241\n\n/*\n * IP-over-InfiniBand, as specified by RFC 4391.\n *\n * Requested by Petr Sumbera <petr.sumbera@oracle.com>.\n */\n#define LINKTYPE_IPOIB\t\t242\n\n/*\n * MPEG-2 transport stream (ISO 13818-1/ITU-T H.222.0).\n *\n * Requested by Guy Martin <gmsoft@tuxicoman.be>.\n */\n#define LINKTYPE_MPEG_2_TS\t243\n\n/*\n * ng4T GmbH's UMTS Iub/Iur-over-ATM and Iub/Iur-over-IP format as\n * used by their ng40 protocol tester.\n *\n * Requested by Jens Grimmer <jens.grimmer@ng4t.com>.\n */\n#define LINKTYPE_NG40\t\t244\n\n/*\n * Pseudo-header giving adapter number and flags, followed by an NFC\n * (Near-Field Communications) Logical Link Control Protocol (LLCP) PDU,\n * as specified by NFC Forum Logical Link Control Protocol Technical\n * Specification LLCP 1.1.\n *\n * Requested by Mike Wakerly <mikey@google.com>.\n */\n#define LINKTYPE_NFC_LLCP\t245\n\n/*\n * pfsync output; DLT_PFSYNC is 18, which collides with DLT_CIP in\n * SuSE 6.3, on OpenBSD, NetBSD, DragonFly BSD, and macOS, and\n * is 121, which collides with DLT_HHDLC, in FreeBSD.  We pick a\n * shiny new link-layer header type value that doesn't collide with\n * anything, in the hopes that future pfsync savefiles, if any,\n * won't require special hacks to distinguish from other savefiles.\n */\n#define LINKTYPE_PFSYNC\t\t246\n\n/*\n * Raw InfiniBand packets, starting with the Local Routing Header.\n *\n * Requested by Oren Kladnitsky <orenk@mellanox.com>.\n */\n#define LINKTYPE_INFINIBAND\t247\n\n/*\n * SCTP, with no lower-level protocols (i.e., no IPv4 or IPv6).\n *\n * Requested by Michael Tuexen <Michael.Tuexen@lurchi.franken.de>.\n */\n#define LINKTYPE_SCTP\t\t248\n\n/*\n * USB packets, beginning with a USBPcap header.\n *\n * Requested by Tomasz Mon <desowin@gmail.com>\n */\n#define LINKTYPE_USBPCAP\t249\n\n/*\n * Schweitzer Engineering Laboratories \"RTAC\" product serial-line\n * packets.\n *\n * Requested by Chris Bontje <chris_bontje@selinc.com>.\n */\n#define LINKTYPE_RTAC_SERIAL\t\t250\n\n/*\n * Bluetooth Low Energy air interface link-layer packets.\n *\n * Requested by Mike Kershaw <dragorn@kismetwireless.net>.\n */\n#define LINKTYPE_BLUETOOTH_LE_LL\t251\n\n/*\n * Link-layer header type for upper-protocol layer PDU saves from wireshark.\n *\n * the actual contents are determined by two TAGs, one or more of\n * which is stored with each packet:\n *\n *   EXP_PDU_TAG_DISSECTOR_NAME      the name of the Wireshark dissector\n *\t\t\t\t     that can make sense of the data stored.\n *\n *   EXP_PDU_TAG_HEUR_DISSECTOR_NAME the name of the Wireshark heuristic\n *\t\t\t\t     dissector that can make sense of the\n *\t\t\t\t     data stored.\n */\n#define LINKTYPE_WIRESHARK_UPPER_PDU\t252\n\n/*\n * Link-layer header type for the netlink protocol (nlmon devices).\n */\n#define LINKTYPE_NETLINK\t\t253\n\n/*\n * Bluetooth Linux Monitor headers for the BlueZ stack.\n */\n#define LINKTYPE_BLUETOOTH_LINUX_MONITOR\t254\n\n/*\n * Bluetooth Basic Rate/Enhanced Data Rate baseband packets, as\n * captured by Ubertooth.\n */\n#define LINKTYPE_BLUETOOTH_BREDR_BB\t255\n\n/*\n * Bluetooth Low Energy link layer packets, as captured by Ubertooth.\n */\n#define LINKTYPE_BLUETOOTH_LE_LL_WITH_PHDR\t256\n\n/*\n * PROFIBUS data link layer.\n */\n#define LINKTYPE_PROFIBUS_DL\t\t257\n\n/*\n * Apple's DLT_PKTAP headers.\n *\n * Sadly, the folks at Apple either had no clue that the DLT_USERn values\n * are for internal use within an organization and partners only, and\n * didn't know that the right way to get a link-layer header type is to\n * ask tcpdump.org for one, or knew and didn't care, so they just\n * used DLT_USER2, which causes problems for everything except for\n * their version of tcpdump.\n *\n * So I'll just give them one; hopefully this will show up in a\n * libpcap release in time for them to get this into 10.10 Big Sur\n * or whatever Mavericks' successor is called.  LINKTYPE_PKTAP\n * will be 258 *even on macOS*; that is *intentional*, so that\n * PKTAP files look the same on *all* OSes (different OSes can have\n * different numerical values for a given DLT_, but *MUST NOT* have\n * different values for what goes in a file, as files can be moved\n * between OSes!).\n */\n#define LINKTYPE_PKTAP\t\t258\n\n/*\n * Ethernet packets preceded by a header giving the last 6 octets\n * of the preamble specified by 802.3-2012 Clause 65, section\n * 65.1.3.2 \"Transmit\".\n */\n#define LINKTYPE_EPON\t\t259\n\n/*\n * IPMI trace packets, as specified by Table 3-20 \"Trace Data Block Format\"\n * in the PICMG HPM.2 specification.\n */\n#define LINKTYPE_IPMI_HPM_2\t260\n\n/*\n * per  Joshua Wright <jwright@hasborg.com>, formats for Zwave captures.\n */\n#define LINKTYPE_ZWAVE_R1_R2\t261\n#define LINKTYPE_ZWAVE_R3\t262\n\n/*\n * per Steve Karg <skarg@users.sourceforge.net>, formats for Wattstopper\n * Digital Lighting Management room bus serial protocol captures.\n */\n#define LINKTYPE_WATTSTOPPER_DLM 263\n\n/*\n * ISO 14443 contactless smart card messages.\n */\n#define LINKTYPE_ISO_14443      264\n\n/*\n * Radio data system (RDS) groups.  IEC 62106.\n * Per Jonathan Brucker <jonathan.brucke@gmail.com>.\n */\n#define LINKTYPE_RDS\t\t265\n\n/*\n * USB packets, beginning with a Darwin (macOS, etc.) header.\n */\n#define LINKTYPE_USB_DARWIN\t266\n\n/*\n * OpenBSD DLT_OPENFLOW.\n */\n#define LINKTYPE_OPENFLOW\t267\n\n/*\n * SDLC frames containing SNA PDUs.\n */\n#define LINKTYPE_SDLC\t\t268\n\n/*\n * per \"Selvig, Bjorn\" <b.selvig@ti.com> used for\n * TI protocol sniffer.\n */\n#define LINKTYPE_TI_LLN_SNIFFER\t269\n\n/*\n * per: Erik de Jong <erikdejong at gmail.com> for\n *   https://github.com/eriknl/LoRaTap/releases/tag/v0.1\n */\n#define LINKTYPE_LORATAP        270\n\n/*\n * per: Stefanha at gmail.com for\n *   https://lists.sandelman.ca/pipermail/tcpdump-workers/2017-May/000772.html\n * and: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/vsockmon.h\n * for: https://qemu-project.org/Features/VirtioVsock\n */\n#define LINKTYPE_VSOCK          271\n\n/*\n * Nordic Semiconductor Bluetooth LE sniffer.\n */\n#define LINKTYPE_NORDIC_BLE\t272\n\n/*\n * Excentis DOCSIS 3.1 RF sniffer (XRA-31)\n *   per: bruno.verstuyft at excentis.com\n *        https://www.xra31.com/xra-header\n */\n#define LINKTYPE_DOCSIS31_XRA31\t273\n\n/*\n * mPackets, as specified by IEEE 802.3br Figure 99-4, starting\n * with the preamble and always ending with a CRC field.\n */\n#define LINKTYPE_ETHERNET_MPACKET\t274\n\n/*\n * DisplayPort AUX channel monitoring data as specified by VESA\n * DisplayPort(DP) Standard preceded by a pseudo-header.\n *    per dirk.eibach at gdsys.cc\n */\n#define LINKTYPE_DISPLAYPORT_AUX\t275\n\n/*\n * Linux cooked sockets v2.\n */\n#define LINKTYPE_LINUX_SLL2\t276\n\n/*\n * Sercos Monitor, per Manuel Jacob <manuel.jacob at steinbeis-stg.de>\n */\n#define LINKTYPE_SERCOS_MONITOR 277\n\n/*\n * OpenVizsla http://openvizsla.org is open source USB analyzer hardware.\n * It consists of FPGA with attached USB phy and FTDI chip for streaming\n * the data to the host PC.\n *\n * Current OpenVizsla data encapsulation format is described here:\n * https://github.com/matwey/libopenvizsla/wiki/OpenVizsla-protocol-description\n *\n */\n#define LINKTYPE_OPENVIZSLA     278\n\n/*\n * The Elektrobit High Speed Capture and Replay (EBHSCR) protocol is produced\n * by a PCIe Card for interfacing high speed automotive interfaces.\n *\n * The specification for this frame format can be found at:\n *   https://www.elektrobit.com/ebhscr\n *\n * for Guenter.Ebermann at elektrobit.com\n *\n */\n#define LINKTYPE_EBHSCR\t        279\n\n/*\n * The https://fd.io vpp graph dispatch tracer produces pcap trace files\n * in the format documented here:\n * https://fdio-vpp.readthedocs.io/en/latest/gettingstarted/developers/vnet.html#graph-dispatcher-pcap-tracing\n */\n#define LINKTYPE_VPP_DISPATCH\t280\n\n/*\n * Broadcom Ethernet switches (ROBO switch) 4 bytes proprietary tagging format.\n */\n#define LINKTYPE_DSA_TAG_BRCM\t281\n#define LINKTYPE_DSA_TAG_BRCM_PREPEND\t282\n\n/*\n * IEEE 802.15.4 with pseudo-header and optional meta-data TLVs, PHY payload\n * exactly as it appears in the spec (no padding, no nothing), and FCS if\n * specified by FCS Type TLV;  requested by James Ko <jck@exegin.com>.\n * Specification at https://github.com/jkcko/ieee802.15.4-tap\n */\n#define LINKTYPE_IEEE802_15_4_TAP       283\n\n/*\n * Marvell (Ethertype) Distributed Switch Architecture proprietary tagging format.\n */\n#define LINKTYPE_DSA_TAG_DSA\t284\n#define LINKTYPE_DSA_TAG_EDSA\t285\n\n/*\n * Payload of lawful intercept packets using the ELEE protocol;\n * https://socket.hr/draft-dfranusic-opsawg-elee-00.xml\n * https://xml2rfc.tools.ietf.org/cgi-bin/xml2rfc.cgi?url=https://socket.hr/draft-dfranusic-opsawg-elee-00.xml&modeAsFormat=html/ascii\n */\n#define LINKTYPE_ELEE\t\t286\n\n/*\n * Serial frames transmitted between a host and a Z-Wave chip.\n */\n#define LINKTYPE_Z_WAVE_SERIAL\t287\n\n/*\n * USB 2.0, 1.1, and 1.0 packets as transmitted over the cable.\n * Deprecated in favor of speed specific LINKTYPEs: LINKTYPE_USB_2_0_LOW_SPEED,\n * LINKTYPE_USB_2_0_FULL_SPEED and LINKTYPE_USB_2_0_HIGH_SPEED.\n */\n#define LINKTYPE_USB_2_0\t288\n\n/*\n * ATSC Link-Layer Protocol (A/330) packets.\n */\n#define LINKTYPE_ATSC_ALP\t289\n\n/*\n * Event Tracing for Windows messages.\n */\n#define LINKTYPE_ETW\t\t290\n\n/*\n * Hilscher Gesellschaft fuer Systemautomation mbH\n * netANALYZER NG hardware and software.\n *\n * The specification for this footer can be found at:\n * https://kb.hilscher.com/x/brDJBw\n *\n * Requested by Jan Adam <jadam@hilscher.com>\n */\n#define LINKTYPE_NETANALYZER_NG\t291\n\n/*\n * Serial NCP (Network Co-Processor) protocol for Zigbee stack ZBOSS\n * by DSR.\n * ZBOSS NCP protocol description: https://cloud.dsr-corporation.com/index.php/s/3isHzaNTTgtJebn\n * Header in pcap file: https://cloud.dsr-corporation.com/index.php/s/fiqSDorAAAZrsYB\n *\n * Requested by Eugene Exarevsky <eugene.exarevsky@dsr-corporation.com>\n */\n#define LINKTYPE_ZBOSS_NCP\t292\n\n/*\n * USB 2.0, 1.1, and 1.0 packets as transmitted over the cable.\n */\n#define LINKTYPE_USB_2_0_LOW_SPEED\t293\n#define LINKTYPE_USB_2_0_FULL_SPEED\t294\n#define LINKTYPE_USB_2_0_HIGH_SPEED\t295\n\n/*\n * Auerswald Logger Protocol\n * description is provided on\n * https://github.com/Auerswald-GmbH/auerlog/blob/master/auerlog.txt\n * requested by Auerswald Developer Team <developer(at)auerswald.de>\n */\n#define LINKTYPE_AUERSWALD_LOG\t296\n\n/*\n * Z-Wave packets with a TAP meta-data header\n * https://gitlab.com/exegin/zwave-g9959-tap\n * requested on tcpdump-workers@\n */\n#define LINKTYPE_ZWAVE_TAP\t297\n\n/*\n * Silicon Labs debug channel protocol:\n */\n#define LINKTYPE_SILABS_DEBUG_CHANNEL 298\n\n/*\n * Ultra-wideband (UWB) controller interface protocol (UCI).\n */\n#define LINKTYPE_FIRA_UCI\t299\n\n/*\n * MDB (Multi-Drop Bus) protocol between a vending machine controller and\n * peripherals inside the vending machine. See\n *\n *\thttps://www.kaiser.cx/pcap-mdb.html\n *\n * for the specification.\n *\n * Requested by Martin Kaiser <martin@kaiser.cx>.\n */\n#define LINKTYPE_MDB\t\t300\n\n/*\n * DECT-2020 New Radio (NR) - ETSI TS 103 636.\n * Requested by Stig Bjorlykke <stig@bjorlykke.org>.\n */\n#define LINKTYPE_DECT_NR\t301\n\n#define LINKTYPE_HIGH_MATCHING_MAX\t301\t\t/* highest value in the \"matching\" range */\n\n/*\n * The DLT_ and LINKTYPE_ values in the \"matching\" range should be the\n * same, so DLT_HIGH_MATCHING_MAX and LINKTYPE_HIGH_MATCHING_MAX should be the\n * same.\n */\n#if LINKTYPE_HIGH_MATCHING_MAX != DLT_HIGH_MATCHING_MAX\n#error The LINKTYPE_ high matching range does not match the DLT_ matching range\n#endif\n\n/*\n * Map a DLT_* code to the corresponding LINKTYPE_* code.\n * Used to generate link-layer types written to savefiles.\n */\nint\ndlt_to_linktype(int dlt)\n{\n\t/*\n\t * All values in the low matching range were handed out before\n\t * assigning DLT_* codes became a free-for-all, so they're the\n\t * same on all platforms, and thus are given LINKTYPE_* codes\n\t * with the same numerical values as the corresponding DLT_*\n\t * code.\n\t */\n\tif (dlt >= DLT_LOW_MATCHING_MIN && dlt <= DLT_LOW_MATCHING_MAX)\n\t\treturn (dlt);\n\n#if DLT_PFSYNC != LINKTYPE_PFSYNC\n\t/*\n\t * DLT_PFSYNC has a code on several platforms that's in the\n\t * non-matching range, a code on FreeBSD that's in the high\n\t * matching range and that's *not* equal to LINKTYPE_PFSYNC,\n\t * and has a code on the rmaining platforms that's equal\n\t * to LINKTYPE_PFSYNC, which is in the high matching range.\n\t *\n\t * Map it to LINKTYPE_PFSYNC if it's not equal to LINKTYPE_PFSYNC.\n\t */\n\tif (dlt == DLT_PFSYNC)\n\t\treturn (LINKTYPE_PFSYNC);\n#endif\n\n\t/*\n\t * DLT_PKTAP is defined as DLT_USER2 - which is in the high\n\t * matching range - on Darwin because Apple used DLT_USER2\n\t * on systems that users ran, not just as an internal thing.\n\t *\n\t * We map it to LINKTYPE_PKTAP if it's not equal to LINKTYPE_PKTAP\n\t * so that DLT_PKTAP captures from Apple machines can be read by\n\t * software that either doesn't handle DLT_USER2 or that handles it\n\t * as something other than Apple PKTAP.\n\t */\n#if DLT_PKTAP != LINKTYPE_PKTAP\n\tif (dlt == DLT_PKTAP)\n\t\treturn (LINKTYPE_PKTAP);\n#endif\n\n\t/*\n\t * For all other DLT_* codes in the high matching range, the DLT\n\t * code value is the same as the LINKTYPE_* code value.\n\t */\n\tif (dlt >= DLT_HIGH_MATCHING_MIN && dlt <= DLT_HIGH_MATCHING_MAX)\n\t\treturn (dlt);\n\n\t/*\n\t * These DLT_* codes have different values on different\n\t * platforms, so we assigned them LINKTYPE_* codes just\n\t * below the lower bound of the high matching range;\n\t * those values should never be equal to any DLT_*\n\t * code, so that should avoid collisions.\n\t *\n\t * That way, for example, \"raw IP\" packets will have\n\t * LINKTYPE_RAW as the code in all savefiles for\n\t * which the code that writes them maps to that\n\t * value, regardless of the platform on which they\n\t * were written, so they should be readable on all\n\t * platforms without having to determine on which\n\t * platform they were written.\n\t *\n\t * We map the DLT_* codes on this platform, whatever\n\t * it might be, to the corresponding LINKTYPE_* codes.\n\t */\n\tif (dlt == DLT_ATM_RFC1483)\n\t\treturn (LINKTYPE_ATM_RFC1483);\n\tif (dlt == DLT_RAW)\n\t\treturn (LINKTYPE_RAW);\n\tif (dlt == DLT_SLIP_BSDOS)\n\t\treturn (LINKTYPE_SLIP_BSDOS);\n\tif (dlt == DLT_PPP_BSDOS)\n\t\treturn (LINKTYPE_PPP_BSDOS);\n\n\t/*\n\t * These DLT_* codes were originally defined on some platform,\n\t * and weren't defined on other platforms.\n\t *\n\t * At least some of them have values, on at least one platform,\n\t * that collide with other DLT_* codes on other platforms, e.g.\n\t * DLT_LOOP, so we don't just define them, on all platforms,\n\t * as having the same value as on the original platform.\n\t *\n\t * Therefore, we assigned new LINKTYPE_* codes to them, and,\n\t * on the platforms where they weren't originally defined,\n\t * define the DLT_* codes to have the same value as the\n\t * corresponding LINKTYPE_* codes.\n\t *\n\t * This means that, for capture files with the original\n\t * platform's DLT_* code rather than the LINKTYPE_* code\n\t * as a link-layer type, we will recognize those types\n\t * on that platform, but not on other platforms.\n\t */\n#ifdef DLT_FR\n\t/* BSD/OS Frame Relay */\n\tif (dlt == DLT_FR)\n\t\treturn (LINKTYPE_FRELAY);\n#endif\n#if DLT_HDLC != LINKTYPE_NETBSD_HDLC\n\t/* NetBSD HDLC */\n\tif (dlt == DLT_HDLC)\n\t\treturn (LINKTYPE_NETBSD_HDLC);\n#endif\n#if DLT_C_HDLC != LINKTYPE_C_HDLC\n\t/* BSD/OS Cisco HDLC */\n\tif (dlt == DLT_C_HDLC)\n\t\treturn (LINKTYPE_C_HDLC);\n#endif\n#if DLT_LOOP != LINKTYPE_LOOP\n\t/* OpenBSD DLT_LOOP */\n\tif (dlt == DLT_LOOP)\n\t\treturn (LINKTYPE_LOOP);\n#endif\n#if DLT_ENC != LINKTYPE_ENC\n\t/* OpenBSD DLT_ENC */\n\tif (dlt == DLT_ENC)\n\t\treturn (LINKTYPE_ENC);\n#endif\n\n\t/*\n\t * These DLT_* codes are not on all platforms, but, so far,\n\t * there don't appear to be any platforms that define\n\t * other codes with those values; we map them to\n\t * different LINKTYPE_* codes anyway, just in case.\n\t */\n\t/* Linux ATM Classical IP */\n\tif (dlt == DLT_ATM_CLIP)\n\t\treturn (LINKTYPE_ATM_CLIP);\n\n\t/*\n\t * A few other values, defined on some platforms, not in\n\t * either matching range, but not colliding with anything\n\t * else, so they're given the same LINKTYPE_* code as\n\t * their DLT_* code.\n\t */\n\tif (dlt == DLT_REDBACK_SMARTEDGE || dlt == DLT_PPP_SERIAL ||\n\t    dlt == DLT_PPP_ETHER || dlt == DLT_SYMANTEC_FIREWALL)\n\t\treturn (dlt);\n\n\t/*\n\t * If we don't have a mapping for this DLT_* code, return an\n\t * error; that means that this is a DLT_* value with no\n\t * corresponding LINKTYPE_ value, and we need to assign one.\n\t */\n\treturn (-1);\n}\n\n/*\n * Map a LINKTYPE_* code to the corresponding DLT_* code.\n * Used to translate link-layer types in savefiles to the\n * DLT_* codes to provide to callers of libpcap.\n */\nint\nlinktype_to_dlt(int linktype)\n{\n\t/*\n\t * All values in the low matching range were handed out before\n\t * assigning DLT_* codes became a free-for-all, so they're the\n\t * same on all platforms, and are thus used as the LINKTYPE_*\n\t * codes in capture files.\n\t */\n\tif (linktype >= LINKTYPE_LOW_MATCHING_MIN &&\n\t    linktype <= LINKTYPE_LOW_MATCHING_MAX)\n\t\treturn (linktype);\n\n#if LINKTYPE_PFSYNC != DLT_PFSYNC\n\t/*\n\t * DLT_PFSYNC has a code on several platforms that's in the\n\t * non-matching range, a code on FreeBSD that's in the high\n\t * matching range and that's *not* equal to LINKTYPE_PFSYNC,\n\t * and has a code on the rmaining platforms that's equal\n\t * to LINKTYPE_PFSYNC, which is in the high matching range.\n\t *\n\t * Map LINKTYPE_PFSYNC to whatever DLT_PFSYNC is on this\n\t * platform, if the two aren't equal.\n\t */\n\tif (linktype == LINKTYPE_PFSYNC)\n\t\treturn (DLT_PFSYNC);\n#endif\n\n\t/*\n\t * DLT_PKTAP is defined as DLT_USER2 - which is in the high\n\t * matching range - on Darwin because Apple used DLT_USER2\n\t * on systems that users ran, not just as an internal thing.\n\t *\n\t * We map LINKTYPE_PKTAP to the platform's DLT_PKTAP for\n\t * the benefit of software that's expecting DLT_PKTAP\n\t * (even if that's DLT_USER2) for an Apple PKTAP capture.\n\t *\n\t * (Yes, this is an annoyance if you want to read a\n\t * LINKTYPE_USER2 packet as something other than DLT_PKTAP\n\t * on a Darwin-based OS, as, on that OS, DLT_PKTAP and DLT_USER2\n\t * are the same.  Feel free to complain to Apple about this.)\n\t */\n#if LINKTYPE_PKTAP != DLT_PKTAP\n\tif (linktype == LINKTYPE_PKTAP)\n\t\treturn (DLT_PKTAP);\n#endif\n\n\t/*\n\t * These DLT_* codes have different values on different\n\t * platforms, so we assigned them LINKTYPE_* codes just\n\t * below the lower bound of the high matching range;\n\t * those values should never be equal to any DLT_*\n\t * code, so that should avoid collisions.\n\t *\n\t * That way, for example, \"raw IP\" packets will have\n\t * LINKTYPE_RAW as the code in all savefiles for\n\t * which the code that writes them maps to that\n\t * value, regardless of the platform on which they\n\t * were written, so they should be readable on all\n\t * platforms without having to determine on which\n\t * platform they were written.\n\t *\n\t * We map the LINKTYPE_* codes to the corresponding\n\t * DLT_* code on this platform.\n\t */\n\tif (linktype == LINKTYPE_ATM_RFC1483)\n\t\treturn (DLT_ATM_RFC1483);\n\tif (linktype == LINKTYPE_RAW)\n\t\treturn (DLT_RAW);\n\tif (linktype == LINKTYPE_SLIP_BSDOS)\n\t\treturn (DLT_SLIP_BSDOS);\n\tif (linktype == LINKTYPE_PPP_BSDOS)\n\t\treturn (DLT_PPP_BSDOS);\n\n\t/*\n\t * These DLT_* codes were originally defined on some platform,\n\t * and weren't defined on other platforms.\n\t *\n\t * At least some of them have values, on at least one platform,\n\t * that collide with other DLT_* codes on other platforms, e.g.\n\t * DLT_LOOP, so we don't just define them, on all platforms,\n\t * as having the same value as on the original platform.\n\t *\n\t * Therefore, we assigned new LINKTYPE_* codes to them, and,\n\t * on the platforms where they weren't originally defined,\n\t * define the DLT_* codes to have the same value as the\n\t * corresponding LINKTYPE_* codes.\n\t *\n\t * This means that, for capture files with the original\n\t * platform's DLT_* code rather than the LINKTYPE_* code\n\t * as a link-layer type, we will recognize those types\n\t * on that platform, but not on other platforms.\n\t *\n\t * We map the LINKTYPE_* codes to the corresponding\n\t * DLT_* code on platforms where the two codes differ..\n\t */\n#ifdef DLT_FR\n\t/* BSD/OS Frame Relay */\n\tif (linktype == LINKTYPE_FRELAY)\n\t\treturn (DLT_FR);\n#endif\n#if LINKTYPE_NETBSD_HDLC != DLT_HDLC\n\t/* NetBSD HDLC */\n\tif (linktype == LINKTYPE_NETBSD_HDLC)\n\t\treturn (DLT_HDLC);\n#endif\n#if LINKTYPE_C_HDLC != DLT_C_HDLC\n\t/* BSD/OS Cisco HDLC */\n\tif (linktype == LINKTYPE_C_HDLC)\n\t\treturn (DLT_C_HDLC);\n#endif\n#if LINKTYPE_LOOP != DLT_LOOP\n\t/* OpenBSD DLT_LOOP */\n\tif (linktype == LINKTYPE_LOOP)\n\t\treturn (DLT_LOOP);\n#endif\n#if LINKTYPE_ENC != DLT_ENC\n\t/* OpenBSD DLT_ENC */\n\tif (linktype == LINKTYPE_ENC)\n\t\treturn (DLT_ENC);\n#endif\n\n\t/*\n\t * These DLT_* codes are not on all platforms, but, so far,\n\t * there don't appear to be any platforms that define\n\t * other codes with those values; we map them to\n\t * different LINKTYPE_* values anyway, just in case.\n\t *\n\t * LINKTYPE_ATM_CLIP is a special case.  DLT_ATM_CLIP is\n\t * not on all platforms, but, so far, there don't appear\n\t * to be any platforms that define it as anything other\n\t * than 19; we define LINKTYPE_ATM_CLIP as something\n\t * other than 19, just in case.  That value is in the\n\t * high matching range, so we have to check for it.\n\t */\n\t/* Linux ATM Classical IP */\n\tif (linktype == LINKTYPE_ATM_CLIP)\n\t\treturn (DLT_ATM_CLIP);\n\n\t/*\n\t * For all other values, return the linktype code as the\n\t * DLT_* code.\n\t *\n\t * If the code is in the high matching range, the\n\t * DLT_* code is the same as the LINKTYPE_* code.\n\t *\n\t * If the code is greater than the maximum value in\n\t * the high matching range, it may be a value from\n\t * a newer version of libpcap; we provide it in case\n\t * the program' capable of handling it.\n\t *\n\t * If the code is less than the minimum value in the\n\t * high matching range, it might be from a capture\n\t * written by code that doesn't map non-matching range\n\t * DLT_* codes to the appropriate LINKTYPE_* code, so\n\t * we'll just pass it through, so that *if it was written\n\t * on this platform* it will be interpreted correctly.\n\t * (We don't know whether it was written on this platform,\n\t * but at least this way there's *some* chance that it\n\t * can be read.)\n\t */\n\treturn linktype;\n}\n\n/*\n * Return the maximum snapshot length for a given DLT_ value.\n *\n * For most link-layer types, we use MAXIMUM_SNAPLEN.\n *\n * For DLT_DBUS, the maximum is 128MiB, as per\n *\n *    https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-messages\n *\n * For DLT_EBHSCR, the maximum is 8MiB, as per\n *\n *    https://www.elektrobit.com/ebhscr\n *\n * For DLT_USBPCAP, the maximum is 1MiB, as per\n *\n *    https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=15985\n */\nu_int\nmax_snaplen_for_dlt(int dlt)\n{\n\tswitch (dlt) {\n\n\tcase DLT_DBUS:\n\t\treturn 128*1024*1024;\n\n\tcase DLT_EBHSCR:\n\t\treturn 8*1024*1024;\n\n\tcase DLT_USBPCAP:\n\t\treturn 1024*1024;\n\n\tdefault:\n\t\treturn MAXIMUM_SNAPLEN;\n\t}\n}\n"
        },
        {
          "name": "pcap-common.h",
          "type": "blob",
          "size": 1.337890625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * pcap-common.h - common code for pcap and pcapng files\n */\n\nextern int dlt_to_linktype(int dlt);\n\nextern int linktype_to_dlt(int linktype);\n\nextern u_int max_snaplen_for_dlt(int dlt);\n"
        },
        {
          "name": "pcap-config.1",
          "type": "blob",
          "size": 3.48828125,
          "content": ".\\\" Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP\\-CONFIG 1 \"22 December 2024\"\n.SH NAME\npcap-config \\- write libpcap compiler and linker flags to standard output\n.SH SYNOPSIS\n.na\n.B pcap-config\n[\n.B \\-\\-help\n]\n[\n.B \\-\\-version\n]\n[\n.B \\-\\-cflags\n]\n.ti +12\n[\n.B \\-\\-libs\n|\n.B \\-\\-additional\\-libs\n]\n.ti +12\n[\n.B \\-\\-static\n|\n.B \\-\\-static\\-pcap\\-only\n]\n.ad\n\n.SH DESCRIPTION\n.LP\n.I pcap\\-config\nwrites to the standard output various compiler and linker flags required to\nbuild a user program with libpcap.  By default, it writes flags appropriate\nfor building with a dynamically\\-linked version of libpcap; see below\nfor static linking.  Depending on the manner of libpcap installation, some\noptions or their combinations may produce empty output \\- this is by design.\n\n.SH OPTIONS\n.TP\n.B \\-\\-help\nProduce a help message and exit.\n\n.TP\n.B \\-\\-version\nProduce libpcap version and exit.  The version is the contents of\n.I VERSION\nfile in libpcap source tree rather than the result of\n.BR \\%pcap_lib_version (3PCAP).\n\n.TP\n.B \\-\\-cflags\nProduce the\n.B \\-I\ncompiler flag required to include libpcap's header files.\n\n.TP\n.B \\-\\-libs\nProduce the\n.B \\-L\nand\n.B \\-l\nlinker flags required to link with libpcap, including\n.B \\-l\nflags for libraries required by libpcap.\n\n.TP\n.B \\-\\-additional\\-libs\nProduce the\n.B \\-L\nand\n.B \\-l\nlinker flags for libraries required by libpcap, but not the\n.B \\-l\nflag to link with libpcap itself.\n\n.TP\n.B \\-\\-static\nThis option causes\n.B \\-\\-libs\nand\n.B \\-\\-additional\\-libs\nto produce linker flags appropriate for static linking with libpcap.\n\n.TP\n.B \\-\\-static\\-pcap\\-only\nThis option causes\n.B \\-\\-libs\nand\n.B \\-\\-additional\\-libs\nto produce linker flags appropriate for static linking with libpcap and\ndynamic linking with all other libraries, including libraries required by\nlibpcap.\n\n.SH EXIT STATUS\n.I pcap\\-config\nexits with a non-zero status when invoked with an invalid command\\-line\noption, and with status 0 otherwise.\n\n.SH BACKWARD COMPATIBILITY\n.PP\nThe\n.B \\-\\-version\nflag became available in libpcap release 1.10.3.\n.PP\nBefore libpcap release 1.10.2\n.I pcap\\-config\ndid not treat invalid command\\-line options as an error. The\n.B \\-\\-static\\-pcap\\-only\nflag became available in libpcap release 1.10.2.\n.PP\nThe\n.B \\-\\-static\nflag became available in libpcap release 1.1.0.\n\n.SH SEE ALSO\n.BR pkg\\-config (1),\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap-config.in",
          "type": "blob",
          "size": 3.837890625,
          "content": "#! /bin/sh\n\n#\n# Script to give the appropriate compiler flags and linker flags\n# to use when building code that uses libpcap.\n#\n# These variables come from the configure script, so includedir and\n# libdir may be defined in terms of prefix and exec_prefix, so the\n# latter must be defined as well.\n#\nprefix=\"@prefix@\"\nexec_prefix=\"@exec_prefix@\"\nincludedir=\"@includedir@\"\nlibdir=\"@libdir@\"\nLIBS=\"@LIBS@\"\nLIBS_STATIC=\"@LIBS_STATIC@\"\nVERSION=\"@PACKAGE_VERSION@\"\n\nusage()\n{\n\techo \"Usage: pcap-config [ --help ] [ --version ] [ --cflags ]\"\n\techo \"                   [ --libs | --additional-libs ]\"\n\techo \"                   [ --static | --static-pcap-only ]\"\n}\n\nstatic=0\nstatic_pcap_only=0\nshow_cflags=0\nshow_libs=0\nshow_additional_libs=0\nwhile [ \"$#\" != 0 ]\ndo\n\tcase \"$1\" in\n\n\t--static)\n\t\tstatic=1\n\t\t;;\n\n\t--static-pcap-only)\n\t\tstatic_pcap_only=1\n\t\t;;\n\n\t--cflags)\n\t\tshow_cflags=1\n\t\t;;\n\n\t--libs)\n\t\tshow_libs=1\n\t\t;;\n\n\t--additional-libs)\n\t\tshow_additional_libs=1\n\t\t;;\n\n\t-h|--help)\n\t\tusage\n\t\texit 0\n\t\t;;\n\n\t--version)\n\t\techo \"$VERSION\"\n\t\texit 0\n\t\t;;\n\n\t*)\n\t\techo \"pcap-config: Invalid command-line option $1 specified\" 1>&2\n\t\tusage 1>&2\n\t\texit 1\n\t\t;;\n\tesac\n\tshift\ndone\n\n#\n# If we aren't installing in /usr, then provide a -L flag to let build\n# processes find our library.\n#\n# (We must check $prefix, as $libdir isn't necessarily /usr/lib in this\n# case - for example, Linux distributions for 64-bit platforms that\n# also provide support for binaries for a 32-bit version of the\n# platform may put the 64-bit libraries, the 32-bit libraries, or both\n# in directories other than /usr/lib.)\n#\nif [ \"$prefix\" != \"/usr\" ]\nthen\n\tLPATH=-L$libdir\nfi\nif [ \"$static\" = 1 ]\nthen\n\t#\n\t# Include LIBS_STATIC so that the flags include libraries\n\t# containing routines that libpcap uses, and libraries\n\t# containing routines those libraries use, etc., so that a\n\t# completely statically linked program - i.e., linked only with\n\t# static libraries - will be linked with all necessary\n\t# libraries.\n\t#\n\tif [ \"$show_cflags\" = 1 -a \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir $LPATH -l@PACKAGE_NAME@ $LIBS_STATIC\"\n\telif [ \"$show_cflags\" = 1 -a \"$show_additional_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir $LPATH $LIBS_STATIC\"\n\telif [ \"$show_cflags\" = 1 ]\n\tthen\n\t\techo \"-I$includedir\"\n\telif [ \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"$LPATH -l@PACKAGE_NAME@ $LIBS_STATIC\"\n\telif [ \"$show_additional_libs\" = 1 ]\n\tthen\n\t\techo \"$LIBS_STATIC\"\n\tfi\nelif [ \"$static_pcap_only\" = 1 ]\nthen\n\t#\n\t# Include LIBS so that the flags include libraries\n\t# containing routines that libpcap uses, but not the libraries\n\t# on which libpcap depends, so that an otherwise\n\t# dynamically-linked program, linked statically only with\n\t# libpcap - i.e., linked with a static libpcap and dynamic\n\t# versions of other libraries - will be linked with all\n\t# necessary libraries.\n\t#\n\tif [ \"$show_cflags\" = 1 -a \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir $LPATH -l@PACKAGE_NAME@ $LIBS\"\n\telif [ \"$show_cflags\" = 1 -a \"$show_additional_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir $LPATH $LIBS\"\n\telif [ \"$show_cflags\" = 1 ]\n\tthen\n\t\techo \"-I$includedir\"\n\telif [ \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"$LPATH -l@PACKAGE_NAME@ $LIBS\"\n\telif [ \"$show_additional_libs\" = 1 ]\n\tthen\n\t\techo \"$LIBS\"\n\tfi\nelse\n\t#\n\t# Don't included LIBS or LIBS_STATIC, for building a program\n\t# with a dynamic libpcap; libpcap, being a dynamic library, will\n\t# cause all of its dynamic-library dependencies to be pulled in\n\t# at run time.\n\t#\n\t# Do, however, include RPATH, to make sure that, on platforms\n\t# that require this, programs built with this version of\n\t# libpcap can find it at run time.\n\t#\n\tif [ \"$show_cflags\" = 1 -a \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir $LPATH @RPATH@ -l@PACKAGE_NAME@\"\n\telif [ \"$show_cflags\" = 1 -a \"$show_additional_libs\" = 1 ]\n\tthen\n\t\techo \"-I$includedir\"\n\telif [ \"$show_cflags\" = 1 ]\n\tthen\n\t\techo \"-I$includedir\"\n\telif [ \"$show_libs\" = 1 ]\n\tthen\n\t\techo \"$LPATH @RPATH@ -l@PACKAGE_NAME@\"\n\tfi\nfi\n"
        },
        {
          "name": "pcap-dag.c",
          "type": "blob",
          "size": 48.7373046875,
          "content": "/*\n * pcap-dag.c: Packet capture interface for Endace DAG cards.\n *\n * Authors: Richard Littin, Sean Irvine ({richard,sean}@reeltwo.com)\n * Modifications: Jesper Peterson\n *                Koryn Grant\n *                Stephen Donnelly <stephen.donnelly@endace.com>\n */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <endian.h>\n#include <limits.h>\n#include <unistd.h>\n\n#include \"pcap-int.h\"\n\n#include \"dagapi.h\"\n#include \"dagpci.h\"\n#include \"dag_config_api.h\"\n\n#include \"pcap-dag.h\"\n\n/*\n * DAG devices have names beginning with \"dag\", followed by a number\n * from 0 to DAG_MAX_BOARDS, then optionally a colon and a stream number\n * from 0 to DAG_STREAM_MAX.\n */\n#ifndef DAG_MAX_BOARDS\n#define DAG_MAX_BOARDS 32\n#endif\n\n#define ATM_CELL_SIZE\t\t52\n#define ATM_HDR_SIZE\t\t4\n\n/*\n * A header containing additional MTP information.\n */\n#define MTP2_SENT_OFFSET\t\t0\t/* 1 byte */\n#define MTP2_ANNEX_A_USED_OFFSET\t1\t/* 1 byte */\n#define MTP2_LINK_NUMBER_OFFSET\t\t2\t/* 2 bytes */\n#define MTP2_HDR_LEN\t\t\t4\t/* length of the header */\n\n#define MTP2_ANNEX_A_NOT_USED      0\n#define MTP2_ANNEX_A_USED          1\n#define MTP2_ANNEX_A_USED_UNKNOWN  2\n\n/* SunATM pseudo header */\nstruct sunatm_hdr {\n\tunsigned char\tflags;\t\t/* destination and traffic type */\n\tunsigned char\tvpi;\t\t/* VPI */\n\tunsigned short\tvci;\t\t/* VCI */\n};\n\n/*\n * Private data for capturing on DAG devices.\n */\nstruct pcap_dag {\n\tstruct pcap_stat stat;\n\tu_char\t*dag_mem_bottom;\t/* DAG card current memory bottom pointer */\n\tu_char\t*dag_mem_top;\t/* DAG card current memory top pointer */\n\tint\tdag_fcs_bits;\t/* Number of checksum bits from link layer */\n\tint\tdag_flags;\t/* Flags */\n\tint\tdag_devnum;\t/* This is the N in \"dagN\" or \"dagN:M\". */\n\tint\tdag_stream;\t/* And this is the M. */\n\tint\tdag_timeout;\t/* timeout specified to pcap_open_live.\n\t\t\t\t * Same as in linux above, introduce\n\t\t\t\t * generally? */\n\tdag_card_ref_t dag_ref; /* DAG Configuration/Status API card reference */\n\tdag_component_t dag_root;\t/* DAG CSAPI Root component */\n\tattr_uuid_t drop_attr;  /* DAG Stream Drop Attribute handle, if available */\n\tuint64_t drop_base;\t// Rx stream drop counter initial value.\n\tstruct timeval required_select_timeout;\n\t\t\t\t/* Timeout caller must use in event loops */\n\tuint8_t\ttx_iface;\t// Tx interface number\n\tuint8_t tx_align_bytes;\t/* If necessary, add trailing padding to an\n\t\t\t\t * ERF record to make it a multiple of this\n\t\t\t\t * many bytes long.  DAG API calls this \"ERF\n\t\t\t\t * record alignment\". */\n\tuint8_t terf_fcs_bytes;\t// How many FCS bytes TERF is expecting.\n};\n\n#define ALIGN_BYTES_DEFAULT 8\n#define ALIGN_BYTES_9_2 16\n#define ALIGN_BYTES_MAX ALIGN_BYTES_9_2\n\ntypedef struct pcap_dag_node {\n\tstruct pcap_dag_node *next;\n\tpcap_t *p;\n\tpid_t pid;\n} pcap_dag_node_t;\n\nstatic pcap_dag_node_t *pcap_dags = NULL;\nstatic int atexit_handler_installed = 0;\n\n#define MAX_DAG_PACKET 65536\n\nstatic unsigned char TempPkt[MAX_DAG_PACKET];\n\n#define TX_ONLY(stream) ((stream) % 2)\n#define RX_ONLY(stream) (! TX_ONLY(stream))\n#define RXTX_STR(stream) (TX_ONLY(stream) ? \"Tx\" : \"Rx\")\n\nstatic int dag_stats(pcap_t *p, struct pcap_stat *ps);\nstatic int dag_set_datalink(pcap_t *p, int dlt);\nstatic int dag_get_datalink(pcap_t *p);\nstatic int dag_setnonblock(pcap_t *p, int nonblock);\n\n// Environment variables that can control behaviour of this libpcap module.\n#define ENV_RX_FCS_BITS \"ERF_FCS_BITS\"\n#define ENV_RX_FCS_NOSTRIP \"ERF_DONT_STRIP_FCS\"\n#define ENV_TX_IFACE \"ERF_TX_INTERFACE\"\n\n/*\n * Convert the return value of getenv() to an integer using matching stricter\n * than atoi().  If the environment variable is not set, return the default\n * value.  Otherwise return an integer in the interval [0, INT32_MAX] or -1 on\n * error.\n */\nstatic int32_t\nstrtouint31(const char *str, const int32_t defaultval) {\n\tif (! str)\n\t\treturn defaultval;\n\tif (! str[0])\n\t\treturn -1;\n\n\tchar * endp;\n\tunsigned long val = strtoul(str, &endp, 10);\n\tif (*endp || val > INT32_MAX)\n\t\treturn -1;\n\treturn (int32_t)val;\n}\n\nstatic void\ndelete_pcap_dag(const pcap_t *p)\n{\n\tpcap_dag_node_t *curr = NULL, *prev = NULL;\n\n\tfor (prev = NULL, curr = pcap_dags; curr != NULL && curr->p != p; prev = curr, curr = curr->next) {\n\t\t/* empty */\n\t}\n\n\tif (curr != NULL && curr->p == p) {\n\t\tif (prev != NULL) {\n\t\t\tprev->next = curr->next;\n\t\t} else {\n\t\t\tpcap_dags = curr->next;\n\t\t}\n\t}\n}\n\n/*\n * Performs a graceful shutdown of the DAG card, frees dynamic memory held\n * in the pcap_t structure, and closes the file descriptor for the DAG card.\n */\n\nstatic void\ndag_platform_cleanup(pcap_t *p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\n\t/*\n\t * Before stopping a Tx stream wait until the stream buffer has been\n\t * drained, otherwise packets that have been buffered but have not yet\n\t * been transmitted will be lost.\n\t */\n\tif (TX_ONLY(pd->dag_stream))\n\t\twhile (dag_get_stream_buffer_level64(p->fd, pd->dag_stream) > 0)\n\t\t\tusleep (10000);\n\n\tif(dag_stop_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_stop_stream: %s\\n\", strerror(errno));\n\n\tif(dag_detach_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_detach_stream: %s\\n\", strerror(errno));\n\n\tif(pd->dag_ref != NULL) {\n\t\tdag_config_dispose(pd->dag_ref);\n\t\t/*\n\t\t * Note: we don't need to call close(p->fd) or\n\t\t * dag_close(p->fd), as dag_config_dispose(pd->dag_ref)\n\t\t * does this.\n\t\t *\n\t\t * Set p->fd to -1 to make sure that's not done.\n\t\t */\n\t\tp->fd = -1;\n\t\tpd->dag_ref = NULL;\n\t}\n\tdelete_pcap_dag(p);\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic void\natexit_handler(void)\n{\n\twhile (pcap_dags != NULL) {\n\t\tif (pcap_dags->pid == getpid()) {\n\t\t\tif (pcap_dags->p != NULL)\n\t\t\t\tdag_platform_cleanup(pcap_dags->p);\n\t\t} else {\n\t\t\tdelete_pcap_dag(pcap_dags->p);\n\t\t}\n\t}\n}\n\nstatic int\nnew_pcap_dag(pcap_t *p)\n{\n\tpcap_dag_node_t *node = NULL;\n\n\tif ((node = malloc(sizeof(pcap_dag_node_t))) == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (!atexit_handler_installed) {\n\t\tatexit(atexit_handler);\n\t\tatexit_handler_installed = 1;\n\t}\n\n\tnode->next = pcap_dags;\n\tnode->p = p;\n\tnode->pid = getpid();\n\n\tpcap_dags = node;\n\n\treturn 0;\n}\n\nstatic unsigned int\ndag_erf_ext_header_count(const uint8_t *erf, size_t len)\n{\n\tuint32_t hdr_num = 0;\n\tuint8_t  hdr_type;\n\n\t/* basic sanity checks */\n\tif ( erf == NULL )\n\t\treturn 0;\n\tif ( len < 16 )\n\t\treturn 0;\n\n\t/* check if we have any extension headers */\n\tif (! (erf[8] & ERF_TYPE_MORE_EXT))\n\t\treturn 0;\n\n\t/* loop over the extension headers */\n\tdo {\n\n\t\t/* sanity check we have enough bytes */\n\t\tif ( len < (24 + (hdr_num * 8)) )\n\t\t\treturn hdr_num;\n\n\t\t/* get the header type */\n\t\thdr_type = erf[(16 + (hdr_num * 8))];\n\t\thdr_num++;\n\n\t} while (hdr_type & ERF_TYPE_MORE_EXT);\n\n\treturn hdr_num;\n}\n\nstatic int\ndag_rxtx_mismatch(const char *func, pcap_t *p)\n{\n\tconst struct pcap_dag *pd = p->priv;\n\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"%s: device %s is %s-only\",\n\t    func,\n\t    p->opt.device,\n\t    RXTX_STR(pd->dag_stream));\n\treturn PCAP_ERROR;\n}\n\nstatic int\ndag_read_notimpl(pcap_t *p, int cnt _U_, pcap_handler callback _U_, u_char *user _U_)\n{\n\treturn dag_rxtx_mismatch(__func__, p);\n}\n\nstatic int\ndag_getnonblock_fd_notimpl(pcap_t *p)\n{\n\treturn dag_rxtx_mismatch(__func__, p);\n}\n\nstatic int\ndag_stats_notimpl(pcap_t *p, struct pcap_stat *ps _U_)\n{\n\treturn dag_rxtx_mismatch(__func__, p);\n}\n\nstatic int\ndag_setnonblock_notimpl(pcap_t *p, int nonblock _U_)\n{\n\treturn dag_rxtx_mismatch( __func__, p);\n}\n\nstatic int\ndag_inject_notimpl(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\treturn dag_rxtx_mismatch(__func__, p);\n}\n\nstatic int\ndag_install_bpf_program_notimpl(pcap_t *p, struct bpf_program *fp _U_)\n{\n\treturn dag_rxtx_mismatch(__func__, p);\n}\n\n/*\n *  Read at most max_packets from the capture stream and call the callback\n *  for each of them. Returns the number of packets handled, PCAP_ERROR if an\n *  error occurred, or PCAP_ERROR_BREAK if we were told to break out of the loop.\n */\nstatic int\ndag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tint processed = 0;\n\tunsigned int nonblocking = pd->dag_flags & DAGF_NONBLOCK;\n\tunsigned int num_ext_hdr = 0;\n\tunsigned int ticks_per_second;\n\n\t/* Get the next bufferful of packets (if necessary). */\n\twhile (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size) {\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that\n\t\t\t * it has, and return PCAP_ERROR_BREAK to indicate that\n\t\t\t * we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\n\t\t/* dag_advance_stream() will block (unless nonblock is called)\n\t\t * until 64kB of data has accumulated.\n\t\t * If to_ms is set, it will timeout before 64kB has accumulated.\n\t\t * We wait for 64kB because processing a few packets at a time\n\t\t * can cause problems at high packet rates (>200kpps) due\n\t\t * to inefficiencies.\n\t\t * This does mean if to_ms is not specified the capture may 'hang'\n\t\t * for long periods if the data rate is extremely slow (<64kB/sec)\n\t\t * If non-block is specified it will return immediately. The user\n\t\t * is then responsible for efficiency.\n\t\t */\n\t\tif ( NULL == (pd->dag_mem_top = dag_advance_stream(p->fd, pd->dag_stream, &(pd->dag_mem_bottom))) ) {\n\t\t     return PCAP_ERROR;\n\t\t}\n\n\t\tif (nonblocking && (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))\n\t\t{\n\t\t\t/* Pcap is configured to process only available packets, and there aren't any, return immediately. */\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(!nonblocking &&\n\t\t   pd->dag_timeout &&\n\t\t   (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))\n\t\t{\n\t\t\t/* Blocking mode, but timeout set and no data has arrived, return anyway.*/\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\t/*\n\t * Process the packets.\n\t *\n\t * This assumes that a single buffer of packets will have\n\t * <= INT_MAX packets, so the packet count doesn't overflow.\n\t */\n\twhile (pd->dag_mem_top - pd->dag_mem_bottom >= dag_record_size) {\n\n\t\tunsigned short packet_len = 0;\n\t\tint caplen = 0;\n\t\tstruct pcap_pkthdr\tpcap_header;\n\n\t\tdag_record_t *header = (dag_record_t *)(pd->dag_mem_bottom);\n\n\t\tu_char *dp = ((u_char *)header); /* + dag_record_size; */\n\t\tunsigned short rlen;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that\n\t\t\t * it has, and return PCAP_ERROR_BREAK to indicate that\n\t\t\t * we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\n\t\trlen = ntohs(header->rlen);\n\t\tif (rlen < dag_record_size)\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: record too small\", __func__);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tpd->dag_mem_bottom += rlen;\n\n\t\tuint8_t erf_type = header->type & ERF_TYPE_MASK;\n\n\t\t/* Count lost packets. */\n\t\tswitch(erf_type) {\n\t\t\t/* in these types the color value overwrites the lctr */\n\t\tcase ERF_TYPE_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_ETH:\n\t\tcase ERF_TYPE_DSM_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\tcase ERF_TYPE_COLOR_HASH_POS:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ( (pd->drop_attr == kNullAttributeUuid) && (header->lctr) ) {\n\t\t\t\tpd->stat.ps_drop += ntohs(header->lctr);\n\t\t\t}\n\t\t}\n\n\t\tif (erf_type == ERF_TYPE_PAD) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_ext_hdr = dag_erf_ext_header_count(dp, rlen);\n\n\t\t/* ERF encapsulation */\n\t\t/* The Extensible Record Format is not dropped for this kind of encapsulation,\n\t\t * and will be handled as a pseudo header by the decoding application.\n\t\t * The information carried in the ERF header and in the optional subheader (if present)\n\t\t * could be merged with the libpcap information, to offer a better decoding.\n\t\t * The packet length is\n\t\t * o the length of the packet on the link (header->wlen),\n\t\t * o plus the length of the ERF header (dag_record_size), as the length of the\n\t\t *   pseudo header will be adjusted during the decoding,\n\t\t * o plus the length of the optional subheader (if present).\n\t\t *\n\t\t * The capture length is header.rlen and the byte stuffing for alignment will be dropped\n\t\t * if the capture length is greater than the packet length.\n\t\t */\n\t\tif (p->linktype == DLT_ERF) {\n\t\t\tpacket_len = ntohs(header->wlen) + dag_record_size;\n\t\t\tcaplen = rlen;\n\t\t\tswitch (erf_type) {\n\t\t\tcase ERF_TYPE_MC_AAL5:\n\t\t\tcase ERF_TYPE_MC_ATM:\n\t\t\tcase ERF_TYPE_MC_HDLC:\n\t\t\tcase ERF_TYPE_MC_RAW_CHANNEL:\n\t\t\tcase ERF_TYPE_MC_RAW:\n\t\t\tcase ERF_TYPE_MC_AAL2:\n\t\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\t\t\tpacket_len += 4; /* MC header */\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\t\tcase ERF_TYPE_COLOR_ETH:\n\t\t\tcase ERF_TYPE_ETH:\n\t\t\t\tpacket_len += 2; /* ETH header */\n\t\t\t\tbreak;\n\t\t\t} /* switch type */\n\n\t\t\t/* Include ERF extension headers */\n\t\t\tpacket_len += (8 * num_ext_hdr);\n\n\t\t\tif (caplen > packet_len) {\n\t\t\t\tcaplen = packet_len;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Other kind of encapsulation according to the header Type */\n\n\t\t\t/* Skip over generic ERF header */\n\t\t\tdp += dag_record_size;\n\t\t\t/* Skip over extension headers */\n\t\t\tdp += 8 * num_ext_hdr;\n\n\t\t\tswitch(erf_type) {\n\t\t\tcase ERF_TYPE_ATM:\n\t\t\tcase ERF_TYPE_AAL5:\n\t\t\t\tif (erf_type == ERF_TYPE_AAL5) {\n\t\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ERF_TYPE_MC_ATM:\n\t\t\t\tif (erf_type == ERF_TYPE_MC_ATM) {\n\t\t\t\t\tcaplen = packet_len = ATM_CELL_SIZE;\n\t\t\t\t\tdp+=4;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ERF_TYPE_MC_AAL5:\n\t\t\t\tif (erf_type == ERF_TYPE_MC_AAL5) {\n\t\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\t\tcaplen = rlen - dag_record_size - 4;\n\t\t\t\t\tdp+=4;\n\t\t\t\t}\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\n\t\t\t\tif (erf_type == ERF_TYPE_ATM) {\n\t\t\t\t\tcaplen = packet_len = ATM_CELL_SIZE;\n\t\t\t\t}\n\t\t\t\tif (p->linktype == DLT_SUNATM) {\n\t\t\t\t\tstruct sunatm_hdr *sunatm = (struct sunatm_hdr *)dp;\n\t\t\t\t\tunsigned long rawatm;\n\n\t\t\t\t\trawatm = ntohl(*((uint32_t *)dp));\n\t\t\t\t\tsunatm->vci = htons((rawatm >>  4) & 0xffff);\n\t\t\t\t\tsunatm->vpi = (rawatm >> 20) & 0x00ff;\n\t\t\t\t\tsunatm->flags = ((header->flags.iface & 1) ? 0x80 : 0x00) |\n\t\t\t\t\t\t((sunatm->vpi == 0 && sunatm->vci == htons(5)) ? 6 :\n\t\t\t\t\t\t ((sunatm->vpi == 0 && sunatm->vci == htons(16)) ? 5 :\n\t\t\t\t\t\t  ((dp[ATM_HDR_SIZE] == 0xaa &&\n\t\t\t\t\t\t    dp[ATM_HDR_SIZE+1] == 0xaa &&\n\t\t\t\t\t\t    dp[ATM_HDR_SIZE+2] == 0x03) ? 2 : 1)));\n\n\t\t\t\t} else if (p->linktype == DLT_ATM_RFC1483) {\n\t\t\t\t\tpacket_len -= ATM_HDR_SIZE;\n\t\t\t\t\tcaplen -= ATM_HDR_SIZE;\n\t\t\t\t\tdp += ATM_HDR_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\t\tcase ERF_TYPE_COLOR_ETH:\n\t\t\tcase ERF_TYPE_ETH:\n\t\t\t\tif ((p->linktype != DLT_EN10MB) &&\n\t\t\t\t    (p->linktype != DLT_DOCSIS))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size - 2;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tdp += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_POS:\n\t\t\tcase ERF_TYPE_DSM_COLOR_HDLC_POS:\n\t\t\tcase ERF_TYPE_COLOR_HDLC_POS:\n\t\t\tcase ERF_TYPE_HDLC_POS:\n\t\t\t\tif ((p->linktype != DLT_CHDLC) &&\n\t\t\t\t    (p->linktype != DLT_PPP_SERIAL) &&\n\t\t\t\t    (p->linktype != DLT_FRELAY))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\t\tcase ERF_TYPE_MC_HDLC:\n\t\t\t\tif ((p->linktype != DLT_CHDLC) &&\n\t\t\t\t    (p->linktype != DLT_PPP_SERIAL) &&\n\t\t\t\t    (p->linktype != DLT_FRELAY) &&\n\t\t\t\t    (p->linktype != DLT_MTP2) &&\n\t\t\t\t    (p->linktype != DLT_MTP2_WITH_PHDR) &&\n\t\t\t\t    (p->linktype != DLT_LAPD))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size - 4;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\t/* jump the MC_HDLC_HEADER */\n\t\t\t\tdp += 4;\n\t\t\t\tif (p->linktype == DLT_MTP2_WITH_PHDR) {\n\t\t\t\t\t/* Add the MTP2 Pseudo Header */\n\t\t\t\t\tcaplen += MTP2_HDR_LEN;\n\t\t\t\t\tpacket_len += MTP2_HDR_LEN;\n\n\t\t\t\t\tTempPkt[MTP2_SENT_OFFSET] = 0;\n\t\t\t\t\tTempPkt[MTP2_ANNEX_A_USED_OFFSET] = MTP2_ANNEX_A_USED_UNKNOWN;\n\t\t\t\t\t*(TempPkt+MTP2_LINK_NUMBER_OFFSET) = ((header->rec.mc_hdlc.mc_header>>16)&0x01);\n\t\t\t\t\t*(TempPkt+MTP2_LINK_NUMBER_OFFSET+1) = ((header->rec.mc_hdlc.mc_header>>24)&0xff);\n\t\t\t\t\tmemcpy(TempPkt+MTP2_HDR_LEN, dp, caplen);\n\t\t\t\t\tdp = TempPkt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_IPV4:\n\t\t\t\tif ((p->linktype != DLT_RAW) &&\n\t\t\t\t    (p->linktype != DLT_IPV4))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_IPV6:\n\t\t\t\tif ((p->linktype != DLT_RAW) &&\n\t\t\t\t    (p->linktype != DLT_IPV6))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* These types have no matching 'native' DLT, but can be used with DLT_ERF above */\n\t\t\tcase ERF_TYPE_MC_RAW:\n\t\t\tcase ERF_TYPE_MC_RAW_CHANNEL:\n\t\t\tcase ERF_TYPE_IP_COUNTER:\n\t\t\tcase ERF_TYPE_TCP_FLOW_COUNTER:\n\t\t\tcase ERF_TYPE_INFINIBAND:\n\t\t\tcase ERF_TYPE_RAW_LINK:\n\t\t\tcase ERF_TYPE_INFINIBAND_LINK:\n\t\t\tdefault:\n\t\t\t\t/* Unhandled ERF type.\n\t\t\t\t * Ignore rather than generating error\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t} /* switch type */\n\n\t\t} /* ERF encapsulation */\n\n\t\t/*\n\t\t * In this libpcap module the two length arguments of\n\t\t * pcapint_filter() (the wire length and the captured length)\n\t\t * can have different values.\n\t\t *\n\t\t * The wire length of this packet is packet_len, which is\n\t\t * derived from ERF wlen; the captured length of this packet\n\t\t * is caplen, which is derived from ERF rlen, which in turn\n\t\t * depends on the card/stream slen; the snapshot length\n\t\t * configured for this pcap handle is p->snapshot.\n\t\t */\n\t\tif ((p->fcode.bf_insns == NULL) || pcapint_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {\n\n\t\t\t/* convert between timestamp formats */\n\t\t\tregister unsigned long long ts;\n\n#if __BYTE_ORDER == __BIG_ENDIAN\n\t\t\tts = SWAPLL(header->ts);\n#else\n\t\t\tts = header->ts;\n#endif // __BYTE_ORDER\n\n\t\t\tswitch (p->opt.tstamp_precision) {\n\t\t\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\t\t\tticks_per_second = 1000000000;\n\t\t\t\tbreak;\n\t\t\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\t\tdefault:\n\t\t\t\tticks_per_second = 1000000;\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tpcap_header.ts.tv_sec = ts >> 32;\n\t\t\tts = (ts & 0xffffffffULL) * ticks_per_second;\n\t\t\tts += 0x80000000; /* rounding */\n\t\t\tpcap_header.ts.tv_usec = ts >> 32;\n\t\t\tif (pcap_header.ts.tv_usec >= ticks_per_second) {\n\t\t\t\tpcap_header.ts.tv_usec -= ticks_per_second;\n\t\t\t\tpcap_header.ts.tv_sec++;\n\t\t\t}\n\n\t\t\t/* Fill in our own header data */\n\t\t\tpcap_header.caplen = min(caplen, p->snapshot);\n\t\t\tpcap_header.len = packet_len;\n\n\t\t\t/* Count the packet. */\n\t\t\tpd->stat.ps_recv++;\n\n\t\t\t/* Call the user supplied callback function */\n\t\t\tcallback(user, &pcap_header, dp);\n\n\t\t\t/* Only count packets that pass the filter, for consistency with standard Linux behaviour. */\n\t\t\tprocessed++;\n\t\t\tif (processed == cnt && !PACKET_COUNT_IS_UNLIMITED(cnt))\n\t\t\t{\n\t\t\t\t/* Reached the user-specified limit. */\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn processed;\n}\n\n/*\n * The minimum number of bytes in a valid Ethernet packet from the beginning\n * of the destination MAC address to the end of the payload, as far as DAG\n * TERF and IEEE 802.3 are concerned.\n */\n#define ETH_MINLEN_NOFCS 60\n\n// ...and the maximum, as far as DAG TERF is concerned.\n#define ETH_MAXLEN_NOFCS 9596\n\n/*\n * The minimum number of bytes in a valid Ethernet header: the destination and\n * the source MAC addresses, the EtherType.  (This does not take 802.1Q or\n * Q-in-Q into account.)\n */\n#define ETH_MINLEN_HDRONLY 14\n\n// Zero padding source (a bit oversized for ERF_TYPE_ETH purposes).\nstatic const uint8_t tx_pad[ETH_MINLEN_NOFCS + 4 + ALIGN_BYTES_MAX];\n\n/*\n * Take an Ethernet frame, build an ERF record around it and feed the record\n * into the [Tx-only] DAG stream.  The frame must not include FCS, which is\n * usually the case for DLT_EN10MB in libpcap.\n */\nstatic int\ndag_inject(pcap_t *p, const void *packet, const int plen)\n{\n\tstruct pcap_dag *pd = p->priv;\n\n\tif (plen <= ETH_MINLEN_HDRONLY || plen > ETH_MAXLEN_NOFCS) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet size %d\", plen);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * sizeof(struct dag_record_t) cannot be used because it is much\n\t * greater than the specific ERF header in this buffer.\n\t */\n\tconst dag_size_t hlen = dag_record_size + 2;\n\t/*\n\t * Some DAG hardware (e.g. 7.5G2) automatically pads outgoing Ethernet\n\t * frames that are shorter than the minimum length to make them long\n\t * enough.  Other DAG hardware (e.g. 9.2X2) rejects such frames.  Pad\n\t * the frame here if necessary and remove this difference from the\n\t * problem space.\n\t *\n\t * If the TERF is expecting Ethernet frames to have a non-zero number\n\t * of FCS bytes (typically in order to strip the FCS correctly before\n\t * further processing), append a dummy zero FCS of the expected size.\n\t */\n\tconst unsigned eth_pad_len = ETH_MINLEN_NOFCS\n\t    - min(plen, ETH_MINLEN_NOFCS) + pd->terf_fcs_bytes;\n\tconst unsigned rlen = hlen + plen + eth_pad_len;\n\tconst unsigned erf_pad_len = rlen % pd->tx_align_bytes ?\n\t    pd->tx_align_bytes - rlen % pd->tx_align_bytes :\n\t    0;\n\tdag_record_t header = {\n\t\t.type = ERF_TYPE_ETH,\n\t\t.flags.vlen = 1,\n\t\t.rlen = htons(rlen + erf_pad_len),\n\t\t.wlen = htons(plen + eth_pad_len),\n\t\t// Silence a -Wmissing-field-initializers from old GCC.\n\t\t.rec.eth = {0},\n\t};\n\tDAG_ERF_SET_IFACE(&header, pd->tx_iface);\n\n\t/*\n\t * It is fine to feed less data than a complete ERF record at a time so\n\t * long as a complete and well-formed ERF record eventually makes it\n\t * into the buffer.  This simplifies the process when different parts\n\t * of the ERF record come from different memory locations.\n\t */\n\tif (dag_tx_stream_copy_bytes64(p->fd, pd->dag_stream, (uint8_t *)&header, hlen) < 0 ||\n\t    dag_tx_stream_copy_bytes64(p->fd, pd->dag_stream, (uint8_t *)packet, plen) < 0)\n\t\tgoto fail;\n\t/*\n\t * Possibly pad to the minimum packet length and/or append a dummy FCS\n\t * and/or pad to the next multiple of the detected alignment unit.\n\t */\n\tconst unsigned pad_len = eth_pad_len + erf_pad_len;\n\tif (pad_len &&\n\t    dag_tx_stream_copy_bytes64(p->fd, pd->dag_stream, (uint8_t *)tx_pad, pad_len) < 0)\n\t\tgoto fail;\n\treturn plen;\n\nfail:\n\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    errno, \"dag_tx_stream_copy_bytes64 %s\", p->opt.device);\n\treturn PCAP_ERROR;\n}\n\nstatic int\ndag_activate_tx(pcap_t *p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\n\tconst char * env = getenv(ENV_TX_IFACE);\n\tint32_t iface = strtouint31(env, 0);\n\tif (iface < 0) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed parsing %s value \\\"%s\\\"\",\n\t\t    __func__, ENV_TX_IFACE, env);\n\t\treturn PCAP_ERROR;\n\t}\n\tuint32_t ifcount = dag_config_get_interface_count(pd->dag_ref);\n\tif ((uint32_t)iface >= ifcount) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: invalid %s value %u: this card has %u interface(s)\",\n\t\t    __func__, ENV_TX_IFACE, iface, ifcount);\n\t\treturn PCAP_ERROR;\n\t}\n\tpd->tx_iface = (uint8_t)iface;\n\n\tconst dag_card_inf_t *inf = dag_pciinfo(p->fd);\n\tif (! inf) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_pciinfo\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (inf->device_code == PCI_DEVICE_ID_VDAG) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"vDAG Tx streams are not supported\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t// Determine the correct alignment/padding size for the card.\n\tswitch(inf->device_code) {\n\tcase PCI_DEVICE_ID_DAG9_2X2:\n\tcase PCI_DEVICE_ID_DAG9_2SX2:\n\t\tpd->tx_align_bytes = ALIGN_BYTES_9_2;\n\t\tbreak;\n\tdefault:\n\t\tpd->tx_align_bytes = ALIGN_BYTES_DEFAULT;\n\t}\n\n\t// Read the TERF FCS size for later use by dag_inject().\n\tdag_component_t cfg_comp = dag_component_get_subcomponent(\n\t    pd->dag_root, kComponentTerf, 0);\n\tif (! cfg_comp) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: dag_component_get_subcomponent\",\n\t\t    __func__);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tattr_uuid_t cfg_uuid = dag_component_get_config_attribute_uuid(\n\t    cfg_comp, kUint32AttributeTerfStripCrc);\n\tif (cfg_uuid == kNullAttributeUuid) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: dag_component_get_config_attribute_uuid\",\n\t\t    __func__);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tuint32_t cfg_uint32;\n\tdag_err_t cfg_err = dag_config_get_uint32_attribute_ex(pd->dag_ref,\n\t    cfg_uuid, &cfg_uint32);\n\tif (cfg_err != kDagErrNone) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: dag_config_get_uint32_attribute_ex\",\n\t\t    __func__);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tswitch (cfg_uint32) {\n\tcase kTerfNoStrip:\n\t\tpd->terf_fcs_bytes = 0;\n\t\tbreak;\n\tcase kTerfStrip16:\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"TERF FCS is configured to 16 bits, is this Ethernet?\");\n\t\treturn PCAP_ERROR;\n\tcase kTerfStrip32:\n\t\tpd->terf_fcs_bytes = 4;\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"failed reading TERF FCS configuration\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * TODO: It would be nice to verify that the Tx port is\n\t * configured for 32-bit Tx FCS, but it is not trivial to\n\t * tell the exact subcomponent that has the attribute.\n\t */\n\n\treturn 0;\n}\n\n/*\n *  Get a handle for a live capture from the given DAG device.  The promisc\n *  flag is ignored because DAG cards are always promiscuous.  The to_ms\n *  parameter is used in setting the API polling parameters.\n *\n *  See also pcap(3).\n */\nstatic int dag_activate(pcap_t* p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tchar *s;\n\tint n;\n\tchar * device = p->opt.device;\n\tint ret;\n\tdag_size_t mindata;\n\tstruct timeval maxwait;\n\tstruct timeval poll;\n\n\t/*\n\t * dag_create() has validated the device name syntax and stored the\n\t * parsed device and stream numbers to p->priv.  Validate these values\n\t * semantically.\n\t */\n\tif (pd->dag_devnum >= DAG_MAX_BOARDS) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"DAG device number %d is too large\", pd->dag_devnum);\n\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto fail;\n\t}\n\tif (pd->dag_stream >= DAG_STREAM_MAX) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"DAG stream number %d is too large\", pd->dag_stream);\n\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto fail;\n\t}\n#ifndef ENABLE_DAG_TX\n\tif (TX_ONLY(pd->dag_stream)) {\n\t\t/*\n\t\t * dag_findalldevs() does not return any Tx streams, so\n\t\t * PCAP_ERROR_NO_SUCH_DEVICE is more consistent than\n\t\t * PCAP_ERROR_CAPTURE_NOTSUP.\n\t\t */\n\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"%s: tx (odd numbered) streams not supported for capture\", __func__);\n\t\tgoto fail;\n\t}\n#endif // ENABLE_DAG_TX\n\n\t/* setup device parameters */\n\tif((pd->dag_ref = dag_config_init(device)) == NULL) {\n\t\t/*\n\t\t * XXX - does this reliably set errno?\n\t\t */\n\t\tif (errno == ENOENT) {\n\t\t\t/*\n\t\t\t * There's nothing more to say, so clear\n\t\t\t * the error message.\n\t\t\t */\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tp->errbuf[0] = '\\0';\n\t\t} else if (errno == EPERM || errno == EACCES) {\n\t\t\tret = PCAP_ERROR_PERM_DENIED;\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to open %s failed with %s - additional privileges may be required\",\n\t\t\t    device, (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t} else {\n\t\t\tret = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"dag_config_init %s\", device);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tif((p->fd = dag_config_get_card_fd(pd->dag_ref)) < 0) {\n\t\t/*\n\t\t * XXX - does this reliably set errno?\n\t\t */\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_config_get_card_fd %s\", device);\n\t\tgoto failclose;\n\t}\n\n\t/* Open requested stream. Can fail if already locked or on error */\n\tif (dag_attach_stream64(p->fd, pd->dag_stream, 0, 0) < 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dag%u has no memory allocated to %s stream %u\",\n\t\t\t    pd->dag_devnum, RXTX_STR(pd->dag_stream), pd->dag_stream);\n\t\t\t/*\n\t\t\t * dag_findalldevs() does not return streams that do\n\t\t\t * not have buffer memory, so PCAP_ERROR_NO_SUCH_DEVICE\n\t\t\t * is more consistent than PCAP_ERROR_CAPTURE_NOTSUP.\n\t\t\t */\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tgoto failclose;\n\t\t} else if (errno == EINVAL) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dag%u has no %s stream %u\",\n\t\t\t    pd->dag_devnum, RXTX_STR(pd->dag_stream), pd->dag_stream);\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tgoto failclose;\n\t\t}\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_attach_stream64\");\n\t\tgoto failclose;\n\t}\n\n\t/* Try to find Stream Drop attribute */\n\tpd->drop_attr = kNullAttributeUuid;\n\tpd->dag_root = dag_config_get_root_component(pd->dag_ref);\n\tif ( dag_component_get_subcomponent(pd->dag_root, kComponentStreamFeatures, 0) )\n\t{\n\t\tpd->drop_attr = dag_config_get_indexed_attribute_uuid(pd->dag_ref, kUint32AttributeStreamDropCount, pd->dag_stream);\n\t\tif (pd->drop_attr != kNullAttributeUuid)\n\t\t\tpd->drop_base = dag_config_get_uint64_attribute(\n\t\t\t    pd->dag_ref, pd->drop_attr);\n\t}\n\n\t/* Set up default poll parameters for stream\n\t * Can be overridden by pcap_set_nonblock()\n\t */\n\tif (dag_get_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\t&mindata, &maxwait, &poll) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_get_stream_poll64\");\n\t\tgoto faildetach;\n\t}\n\n\t/* Use the poll time as the required select timeout for callers\n\t * who are using select()/etc. in an event loop waiting for\n\t * packets to arrive.\n\t */\n\tpd->required_select_timeout = poll;\n\tp->required_select_timeout = &pd->required_select_timeout;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.immediate) {\n\t\t/* Call callback immediately.\n\t\t * XXX - is this the right way to p this?\n\t\t */\n\t\tmindata = 0;\n\t} else {\n\t\t/* Amount of data to collect in Bytes before calling callbacks.\n\t\t * Important for efficiency, but can introduce latency\n\t\t * at low packet rates if to_ms not set!\n\t\t */\n\t\tmindata = 65536;\n\t}\n\n\t/* Obey opt.timeout (was to_ms) if supplied. This is a good idea!\n\t * Recommend 10-100ms. Calls will time out even if no data arrived.\n\t */\n\tmaxwait.tv_sec = p->opt.timeout/1000;\n\tmaxwait.tv_usec = (p->opt.timeout%1000) * 1000;\n\n\tif (dag_set_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\tmindata, &maxwait, &poll) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_set_stream_poll64\");\n\t\tgoto faildetach;\n\t}\n\n\tif(dag_start_stream(p->fd, pd->dag_stream) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_start_stream %s\", device);\n\t\tgoto faildetach;\n\t}\n\n\t/*\n\t * Important! You have to ensure bottom is properly\n\t * initialized to zero on startup, it won't give you\n\t * a compiler warning if you make this mistake!\n\t */\n\tpd->dag_mem_bottom = 0;\n\tpd->dag_mem_top = 0;\n\n\t/*\n\t * Find out how many FCS bits we should strip.\n\t * Assume Rx FCS length to be 32 bits unless the user has\n\t * requested a different value, in which case validate it well.\n\t */\n\ts = getenv(ENV_RX_FCS_BITS);\n\tswitch ((n = strtouint31(s, 32))) {\n\tcase 0:\n\tcase 16:\n\tcase 32:\n\t\tpd->dag_fcs_bits = n;\n\t\tbreak;\n\tdefault:\n\t\tret = PCAP_ERROR;\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s %s: invalid %s value (%s) in environment\",\n\t\t    __func__, device, ENV_RX_FCS_BITS, s);\n\t\tgoto failstop;\n\t}\n\n\t/*\n\t * Did the user request that they not be stripped?\n\t */\n\ts = getenv(ENV_RX_FCS_NOSTRIP);\n\tswitch ((n = strtouint31(s, 0))) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\t/* Yes.  Note the number of 16-bit words that will be\n\t\t   supplied. */\n\t\tp->linktype_ext = LT_FCS_DATALINK_EXT(pd->dag_fcs_bits/16);\n\n\t\t/* And don't strip them. */\n\t\tpd->dag_fcs_bits = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = PCAP_ERROR;\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s %s: invalid %s value (%s) in environment\",\n\t\t    __func__, device, ENV_RX_FCS_NOSTRIP, s);\n\t\tgoto failstop;\n\t}\n\n\tif (TX_ONLY(pd->dag_stream) && dag_activate_tx(p) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tgoto failstop;\n\t}\n\n\tpd->dag_timeout\t= p->opt.timeout;\n\n\tif (dag_get_datalink(p) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tgoto failstop;\n\t}\n\n\tp->bufsize = 0;\n\n\tif (new_pcap_dag(p) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"new_pcap_dag %s\", device);\n\t\tgoto failstop;\n\t}\n\n\t/*\n\t * \"select()\" and \"poll()\" don't work on DAG device descriptors.\n\t */\n\tp->selectable_fd = -1;\n\n\tp->read_op = RX_ONLY(pd->dag_stream) ?\n\t    dag_read :\n\t    dag_read_notimpl;\n\tp->inject_op = TX_ONLY(pd->dag_stream) ?\n\t    dag_inject :\n\t    dag_inject_notimpl;\n\tp->setfilter_op = RX_ONLY(pd->dag_stream) ?\n\t    pcapint_install_bpf_program :\n\t    dag_install_bpf_program_notimpl;\n\tp->setdirection_op = NULL; /* Not implemented.*/\n\tp->set_datalink_op = dag_set_datalink;\n\tp->getnonblock_op = RX_ONLY(pd->dag_stream) ?\n\t    pcapint_getnonblock_fd :\n\t    dag_getnonblock_fd_notimpl;\n\tp->setnonblock_op = RX_ONLY(pd->dag_stream) ?\n\t    dag_setnonblock :\n\t    dag_setnonblock_notimpl;\n\tp->stats_op = RX_ONLY(pd->dag_stream) ?\n\t    dag_stats :\n\t    dag_stats_notimpl;\n\tp->cleanup_op = dag_platform_cleanup;\n\tpd->stat.ps_drop = 0;\n\tpd->stat.ps_recv = 0;\n\tpd->stat.ps_ifdrop = 0;\n\treturn 0;\n\nfailstop:\n\tif (dag_stop_stream(p->fd, pd->dag_stream) < 0) {\n\t\tfprintf(stderr,\"dag_stop_stream: %s\\n\", strerror(errno));\n\t}\n\nfaildetach:\n\tif (dag_detach_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_detach_stream: %s\\n\", strerror(errno));\n\nfailclose:\n\tdag_config_dispose(pd->dag_ref);\n\t/*\n\t * Note: we don't need to call close(p->fd) or dag_close(p->fd),\n\t * as dag_config_dispose(pd->dag_ref) does this.\n\t *\n\t * Set p->fd to -1 to make sure that's not done.\n\t */\n\tp->fd = -1;\n\tpd->dag_ref = NULL;\n\tdelete_pcap_dag(p);\n\nfail:\n\tpcapint_cleanup_live_common(p);\n\n\treturn ret;\n}\n\npcap_t *dag_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\tlong stream = 0;\n\n\t/*\n\t * The nominal libpcap DAG device name format is either \"dagN\" or\n\t * \"dagN:M\", as returned from dag_findalldevs().\n\t *\n\t * First attempt the most basic syntax validation.  If the device string\n\t * does not look like a potentially valid DAG device name, reject it\n\t * silently to have pcap_create() try another capture source type.\n\t */\n\t*is_ours = 0;\n\n\t/* Does this look like a DAG device? */\n\tcp = device;\n\t/* Does it begin with \"dag\"? */\n\tif (strncmp(cp, \"dag\", 3) != 0) {\n\t\t/* Nope, doesn't begin with \"dag\" */\n\t\treturn NULL;\n\t}\n\t/* Yes - is \"dag\" followed by a number from 0 to DAG_MAX_BOARDS-1 */\n\tcp += 3;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (*cpend == ':') {\n\t\t/* Followed by a stream number. */\n\t\tstream = strtol(++cpend, &cpend, 10);\n\t}\n\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * OK, it's probably ours, validate the syntax further.  From now on\n\t * reject the device string authoritatively with an error message to\n\t * have pcap_create() propagate the failure.  Validate the device and\n\t * stream number ranges loosely only.\n\t */\n\t*is_ours = 1;\n\tsnprintf (ebuf, PCAP_ERRBUF_SIZE,\n\t    \"DAG device name \\\"%s\\\" is invalid\", device);\n\n\tif (devnum < 0 || devnum > INT_MAX) {\n\t\t/* Followed by a non-valid number. */\n\t\treturn NULL;\n\t}\n\n\tif (stream < 0 || stream > INT_MAX) {\n\t\t/* Followed by a non-valid stream number. */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * The syntax validation done so far is lax enough to accept some\n\t * device strings that are not actually acceptable in libpcap as\n\t * defined above.  The device strings that are acceptable in libpcap\n\t * are a strict subset of the device strings that are acceptable in\n\t * dag_parse_name(), thus using the latter for validation in libpcap\n\t * would not work reliably.  Instead from the detected device and\n\t * stream numbers produce the acceptable device string(s) and require\n\t * the input device string to match an acceptable string exactly.\n\t */\n\tchar buf[DAGNAME_BUFSIZE];\n\tsnprintf(buf, sizeof(buf), \"dag%ld:%ld\", devnum, stream);\n\tchar acceptable = ! strcmp(device, buf);\n\tif (! acceptable && stream == 0) {\n\t\tsnprintf(buf, sizeof(buf), \"dag%ld\", devnum);\n\t\tacceptable = ! strcmp(device, buf);\n\t}\n\tif (! acceptable)\n\t\treturn NULL;\n\n\t/*\n\t * The device string syntax is acceptable, save the device and stream\n\t * numbers for dag_activate(), which will do semantic and run-time\n\t * validation and possibly reject the pcap_t using more specific error\n\t * codes.\n\t */\n\tebuf[0] = '\\0';\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_dag);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->activate_op = dag_activate;\n\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t *\n\t * XXX Our native precision is 2^-32s, but libpcap doesn't support\n\t * power of two precisions yet. We can convert to either MICRO or NANO.\n\t */\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tpcap_close(p);\n\t\treturn NULL;\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\tp->tstamp_precision_count = 2;\n\tstruct pcap_dag *pd = p->priv;\n\tpd->dag_devnum = (int)devnum;\n\tpd->dag_stream = (int)stream;\n\treturn p;\n}\n\nstatic int\ndag_stats(pcap_t *p, struct pcap_stat *ps) {\n\tstruct pcap_dag *pd = p->priv;\n\tuint64_t stream_drop;\n\tdag_err_t dag_error;\n\n\t/*\n\t * Packet records received (ps_recv) are counted in dag_read().\n\t * Packet records dropped (ps_drop) are read from Stream Drop attribute if present,\n\t * otherwise integrate the ERF Header lctr counts (if available) in dag_read().\n\t * We are reporting that no records are dropped by the card/driver (ps_ifdrop).\n\t */\n\n\tif(pd->drop_attr != kNullAttributeUuid) {\n\t\t/* Note this counter is cleared at start of capture and will wrap at UINT_MAX.\n\t\t * The application is responsible for polling ps_drop frequently enough\n\t\t * to detect each wrap and integrate total drop with a wider counter */\n\t\tif ((dag_error = dag_config_get_uint64_attribute_ex(pd->dag_ref, pd->drop_attr, &stream_drop)) == kDagErrNone) {\n\t\t\tpd->stat.ps_drop = (u_int)(stream_drop - pd->drop_base);\n\t\t} else {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"reading stream drop attribute: %s\",\n\t\t\t\t dag_config_strerror(dag_error));\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t*ps = pd->stat;\n\n\treturn 0;\n}\n\nstatic const char *\ndag_device_description(const unsigned dagid)\n{\n\tstatic char buf[128];\n\tsnprintf(buf, sizeof(buf), \"alias for dag%u:0\", dagid);\n\treturn buf;\n}\n\nstatic const char *\ndag_stream_short_description(const unsigned stream)\n{\n\tstatic char buf[128];\n\tsnprintf(buf, sizeof(buf), \"%s stream %u\", RXTX_STR(stream), stream);\n\treturn buf;\n}\n\nstatic const char *\ndag_stream_long_description(const unsigned stream, const dag_size_t bufsize,\n    const dag_card_inf_t * inf)\n{\n\tstatic char buf[256];\n\tint done = snprintf(buf, sizeof(buf),\n\t    \"%s stream %u, %\" PRIu64 \" MiB, %s\",\n\t    RXTX_STR(stream),\n\t    stream,\n\t    bufsize / 1024 / 1024,\n\t    inf ? dag_device_name(inf->device_code, 1) : \"N/A\");\n\tif (inf->device_code != PCI_DEVICE_ID_VDAG)\n\t\tsnprintf(buf + done, sizeof(buf) - done,\n\t\t    \" rev %c at %s\",\n\t\t    (inf && inf->brd_rev < 26) ? ('A' + inf->brd_rev) : '?',\n\t\t    inf ? inf->bus_id : \"N/A\");\n\treturn buf;\n}\n\n/*\n * Add all DAG devices.\n */\nint\ndag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint c;\n\tint dagfd;\n\tconst char * description;\n\tint stream, rxstreams;\n\t// A DAG card associates a link status with each physical port, but not\n\t// with the data streams.  The number of ports is a matter of hardware,\n\t// the number of streams and how each stream associates with zero or\n\t// more ports is a matter of how the user configures the card.  In this\n\t// context libpcap uses the streams only (i.e. \"dag0\" is a shorthand\n\t// for \"dag0:0\"), thus the notion of link status does not apply to the\n\t// resulting libpcap DAG capture devices.\n\tconst bpf_u_int32 flags = PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\tFILE * sysfsinfo = NULL;\n\n\t/* Try all the DAGs 0-DAG_MAX_BOARDS */\n\tfor (c = 0; c < DAG_MAX_BOARDS; c++) {\n\t\tchar name[DAGNAME_BUFSIZE]; // libpcap device\n\t\tsnprintf(name, sizeof(name), \"dag%d\", c);\n\t\tchar dagname[DAGNAME_BUFSIZE]; // DAG API device\n\t\tsnprintf(dagname, sizeof(dagname), \"/dev/dag%d\", c);\n\t\tif ( (dagfd = dag_open(dagname)) >= 0 ) {\n\t\t\t// Do not add a shorthand device for stream 0 (dagN) yet -- the\n\t\t\t// user can disable any stream in the card configuration.\n\t\t\tconst dag_card_inf_t * inf = dag_pciinfo(dagfd); // NULL is fine\n\t\t\t// The count includes existing streams that have no buffer memory.\n\t\t\trxstreams = dag_rx_get_stream_count(dagfd);\n\t\t\tif (rxstreams < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    errno, \"dag_rx_get_stream_count\");\n\t\t\t\tgoto failclose;\n\t\t\t}\n\t\t\tint txstreams = 0;\n#ifdef ENABLE_DAG_TX\n\t\t\ttxstreams = dag_tx_get_stream_count(dagfd);\n\t\t\tif (txstreams < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    errno, \"dag_tx_get_stream_count\");\n\t\t\t\tgoto failclose;\n\t\t\t}\n#endif // ENABLE_DAG_TX\n\t\t\tfor(stream = 0;\n\t\t\t    stream < DAG_STREAM_MAX && (rxstreams > 0 || txstreams > 0);\n\t\t\t    stream++) {\n#ifndef ENABLE_DAG_TX\n\t\t\t\tif (TX_ONLY(stream))\n\t\t\t\t\tcontinue;\n#endif // ENABLE_DAG_TX\n\t\t\t\t/*\n\t\t\t\t * dag_attach_stream64() was used before to test if the\n\t\t\t\t * stream exists, but it is not the best tool for the\n\t\t\t\t * job because it tries to lock the stream exclusively.\n\t\t\t\t * If the stream is already locked by another process,\n\t\t\t\t * it fails with EBUSY, otherwise it creates a race\n\t\t\t\t * condition for other processes that may be trying to\n\t\t\t\t * lock the same stream at the same time.  Therefore\n\t\t\t\t * dag_get_stream_buffer_size64() seems to be a better\n\t\t\t\t * fit.\n\t\t\t\t */\n\t\t\t\tdag_ssize_t bufsize = dag_get_stream_buffer_size64(dagfd, stream);\n\t\t\t\tif (bufsize < 0)\n\t\t\t\t\tcontinue; // Does not exist.\n\t\t\t\t// Only streams with buffer memory are usable.\n\t\t\t\tif (bufsize > 0 &&\n\t\t\t\t    (RX_ONLY(stream) || inf->device_code != PCI_DEVICE_ID_VDAG)) {\n\t\t\t\t\tdescription = dag_device_description (c);\n\t\t\t\t\t// a conditional shorthand device\n\t\t\t\t\tif (stream == 0 &&\n\t\t\t\t\t    pcapint_add_dev(devlistp, name, flags, description, errbuf) == NULL)\n\t\t\t\t\t\tgoto failclose;\n\t\t\t\t\t// and the stream device\n\t\t\t\t\tsnprintf(name,  sizeof(name), \"dag%d:%d\", c, stream);\n\t\t\t\t\tdescription = dag_stream_long_description(stream,\n\t\t\t\t\t    dag_get_stream_buffer_size64(dagfd, stream), inf);\n\t\t\t\t\tif (pcapint_add_dev(devlistp, name, flags, description, errbuf) == NULL) {\n\t\t\t\t\t\tgoto failclose;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (RX_ONLY(stream))\n\t\t\t\t\trxstreams--;\n\t\t\t\telse\n\t\t\t\t\ttxstreams--;\n\t\t\t}\n\t\t\tdag_close(dagfd);\n\t\t\tdagfd = -1;\n\t\t} else if (errno == EACCES) {\n\t\t\t// The device exists, but the current user privileges are not\n\t\t\t// sufficient for dag_open().\n\t\t\t// Do not add a shorthand device for stream 0 yet -- same as above.\n\t\t\t// Try enumerating the streams using sysfs.  The file lists\n\t\t\t// all streams (Rx and Tx) that have non-zero amount of buffer\n\t\t\t// memory.\n\t\t\tchar sysfspath[PATH_MAX];\n\t\t\tsnprintf(sysfspath, sizeof(sysfspath), \"/sys/devices/virtual/dag/%s/info\", name);\n\t\t\tif ((sysfsinfo = fopen(sysfspath, \"r\"))) {\n\t\t\t\tchar linebuf[1024];\n\t\t\t\twhile (fgets(linebuf, sizeof(linebuf), sysfsinfo))\n\t\t\t\t\tif (1 == sscanf(linebuf, \"Stream %u:\", &stream)) {\n#ifndef ENABLE_DAG_TX\n\t\t\t\t\t\tif (TX_ONLY(stream))\n\t\t\t\t\t\t\tcontinue;\n#endif // ENABLE_DAG_TX\n\t\t\t\t\t\t// a conditional shorthand device\n\t\t\t\t\t\tdescription = dag_device_description(c);\n\t\t\t\t\t\tif (stream == 0 &&\n\t\t\t\t\t\t    pcapint_add_dev(devlistp, name, flags, description, errbuf) == NULL)\n\t\t\t\t\t\t\tgoto failclose;\n\t\t\t\t\t\t// and the stream device\n\t\t\t\t\t\tsnprintf(name,  sizeof(name), \"dag%u:%u\", c, stream);\n\t\t\t\t\t\t// TODO: Parse and describe the buffer size too.\n\t\t\t\t\t\tdescription = dag_stream_short_description(stream);\n\t\t\t\t\t\tif (pcapint_add_dev(devlistp, name, flags, description, errbuf) == NULL)\n\t\t\t\t\t\t\tgoto failclose;\n\t\t\t\t\t}\n\t\t\t\tfclose(sysfsinfo);\n\t\t\t\tsysfsinfo = NULL;\n\t\t\t}\n\t\t} // errno == EACCES\n\n\t}\n\treturn (0);\n\nfailclose:\n\tif (dagfd >= 0)\n\t\tdag_close(dagfd);\n\tif (sysfsinfo)\n\t\tfclose(sysfsinfo);\n\treturn PCAP_ERROR;\n}\n\nstatic int\ndag_set_datalink(pcap_t *p, int dlt)\n{\n\tp->linktype = dlt;\n\n\treturn (0);\n}\n\nstatic int\ndag_setnonblock(pcap_t *p, int nonblock)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tdag_size_t mindata;\n\tstruct timeval maxwait;\n\tstruct timeval poll;\n\n\t/*\n\t * Set non-blocking mode on the FD.\n\t * XXX - is that necessary?  If not, don't bother calling it,\n\t * and have a \"dag_getnonblock()\" function that looks at\n\t * \"pd->dag_flags\".\n\t */\n\tif (pcapint_setnonblock_fd(p, nonblock) < 0)\n\t\treturn PCAP_ERROR;\n\n\tif (dag_get_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\t&mindata, &maxwait, &poll) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_get_stream_poll64\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Amount of data to collect in Bytes before calling callbacks.\n\t * Important for efficiency, but can introduce latency\n\t * at low packet rates if to_ms not set!\n\t */\n\tif(nonblock)\n\t\tmindata = 0;\n\telse\n\t\tmindata = 65536;\n\n\tif (dag_set_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\tmindata, &maxwait, &poll) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_set_stream_poll64\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (nonblock) {\n\t\tpd->dag_flags |= DAGF_NONBLOCK;\n\t} else {\n\t\tpd->dag_flags &= ~DAGF_NONBLOCK;\n\t}\n\treturn (0);\n}\n\nstatic int\ndag_get_datalink(pcap_t *p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\n\t/*\n\t * There seems to be no trivial way to tell which ERF type(s) a Tx\n\t * stream would accept.  Let's assume ERF_TYPE_ETH would work, which\n\t * in libpcap terms means using DLT_EN10MB.\n\t */\n\tif (TX_ONLY(pd->dag_stream))\n\t\treturn (p->linktype = DLT_EN10MB);\n\n\tint index=0, dlt_index=0;\n\tuint8_t types[255];\n\n\tmemset(types, 0, 255);\n\n\tif (p->dlt_list == NULL && (p->dlt_list = malloc(255*sizeof(*(p->dlt_list)))) == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"malloc\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tp->linktype = 0;\n\n\t/* Get list of possible ERF types for this card */\n\tif (dag_get_stream_erf_types(p->fd, pd->dag_stream, types, 255) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"dag_get_stream_erf_types\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\twhile (types[index]) {\n\n\t\tswitch((types[index] & ERF_TYPE_MASK)) {\n\n\t\tcase ERF_TYPE_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_DSM_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_HASH_POS:\n\t\t\tp->dlt_list[dlt_index++] = DLT_CHDLC;\n\t\t\tp->dlt_list[dlt_index++] = DLT_PPP_SERIAL;\n\t\t\tp->dlt_list[dlt_index++] = DLT_FRELAY;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_CHDLC;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_ETH:\n\t\tcase ERF_TYPE_COLOR_ETH:\n\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\t\t/*\n\t\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t\t * that an application can let you choose it, in case you're\n\t\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t\t * Termination System is putting out onto an Ethernet (it\n\t\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t\t * Ethernet framing).\n\t\t\t */\n\t\t\tp->dlt_list[dlt_index++] = DLT_EN10MB;\n\t\t\tp->dlt_list[dlt_index++] = DLT_DOCSIS;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_EN10MB;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_ATM:\n\t\tcase ERF_TYPE_AAL5:\n\t\tcase ERF_TYPE_MC_ATM:\n\t\tcase ERF_TYPE_MC_AAL5:\n\t\t\tp->dlt_list[dlt_index++] = DLT_ATM_RFC1483;\n\t\t\tp->dlt_list[dlt_index++] = DLT_SUNATM;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_ATM_RFC1483;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\tcase ERF_TYPE_MC_HDLC:\n\t\t\tp->dlt_list[dlt_index++] = DLT_CHDLC;\n\t\t\tp->dlt_list[dlt_index++] = DLT_PPP_SERIAL;\n\t\t\tp->dlt_list[dlt_index++] = DLT_FRELAY;\n\t\t\tp->dlt_list[dlt_index++] = DLT_MTP2;\n\t\t\tp->dlt_list[dlt_index++] = DLT_MTP2_WITH_PHDR;\n\t\t\tp->dlt_list[dlt_index++] = DLT_LAPD;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_CHDLC;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_IPV4:\n\t\t\tp->dlt_list[dlt_index++] = DLT_RAW;\n\t\t\tp->dlt_list[dlt_index++] = DLT_IPV4;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_RAW;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_IPV6:\n\t\t\tp->dlt_list[dlt_index++] = DLT_RAW;\n\t\t\tp->dlt_list[dlt_index++] = DLT_IPV6;\n\t\t\tif(!p->linktype)\n\t\t\t\tp->linktype = DLT_RAW;\n\t\t\tbreak;\n\n\t\tcase ERF_TYPE_LEGACY:\n\t\tcase ERF_TYPE_MC_RAW:\n\t\tcase ERF_TYPE_MC_RAW_CHANNEL:\n\t\tcase ERF_TYPE_IP_COUNTER:\n\t\tcase ERF_TYPE_TCP_FLOW_COUNTER:\n\t\tcase ERF_TYPE_INFINIBAND:\n\t\tcase ERF_TYPE_RAW_LINK:\n\t\tcase ERF_TYPE_INFINIBAND_LINK:\n\t\tcase ERF_TYPE_META:\n\t\tdefault:\n\t\t\t/* Libpcap cannot deal with these types yet */\n\t\t\t/* Add no 'native' DLTs, but still covered by DLT_ERF */\n\t\t\tbreak;\n\n\t\t} /* switch */\n\t\tindex++;\n\t}\n\n\tp->dlt_list[dlt_index++] = DLT_ERF;\n\n\tp->dlt_count = dlt_index;\n\n\tif(!p->linktype)\n\t\tp->linktype = DLT_ERF;\n\n\treturn p->linktype;\n}\n\n#ifdef DAG_ONLY\n/*\n * This libpcap build supports only DAG cards, not regular network\n * interfaces.\n */\n\n/*\n * There are no regular interfaces, just DAG interfaces.\n */\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf _U_)\n{\n\treturn (0);\n}\n\n/*\n * Attempts to open a regular interface fail.\n */\npcap_t *\npcapint_create_interface(const char *device _U_, char *errbuf)\n{\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, PCAP_ENODEV_MESSAGE, \"DAG\");\n\treturn NULL;\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (DAG-only)\");\n}\n#endif\n"
        },
        {
          "name": "pcap-dag.h",
          "type": "blob",
          "size": 0.4462890625,
          "content": "/*\n * pcap-dag.h: Packet capture interface for Endace DAG card.\n *\n * The functionality of this code attempts to mimic that of pcap-linux as much\n * as possible.  This code is only needed when compiling in the DAG card code\n * at the same time as another type of device.\n *\n * Author: Richard Littin, Sean Irvine ({richard,sean}@reeltwo.com)\n */\n\npcap_t *dag_create(const char *, char *, int *);\nint dag_findalldevs(pcap_if_list_t *devlistp, char *errbuf);\n"
        },
        {
          "name": "pcap-dbus.c",
          "type": "blob",
          "size": 10.0283203125,
          "content": "/*\n * Copyright (c) 2012 Jakub Zawadzki\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <string.h>\n\n#include <time.h>\n#include <sys/time.h>\n\n#include <dbus/dbus.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-dbus.h\"\n\n/*\n * Private data for capturing on D-Bus.\n */\nstruct pcap_dbus {\n\tDBusConnection *conn;\n\tu_int\tpackets_read;\t/* count of packets read */\n};\n\nstatic int\ndbus_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tstruct pcap_pkthdr pkth;\n\tDBusMessage *message;\n\n\tchar *raw_msg;\n\tint raw_msg_len;\n\n\tint count = 0;\n\n\tmessage = dbus_connection_pop_message(handlep->conn);\n\n\twhile (!message) {\n\t\t/* XXX handle->opt.timeout = timeout_ms; */\n\t\tif (!dbus_connection_read_write(handlep->conn, 100)) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Connection closed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\n\t\tmessage = dbus_connection_pop_message(handlep->conn);\n\t}\n\n\tif (dbus_message_is_signal(message, DBUS_INTERFACE_LOCAL, \"Disconnected\")) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Disconnected\");\n\t\tdbus_message_unref(message);\n\t\treturn -1;\n\t}\n\n\tif (dbus_message_marshal(message, &raw_msg, &raw_msg_len)) {\n\t\tpkth.caplen = pkth.len = raw_msg_len;\n\t\t/* pkth.caplen = min (payload_len, handle->snapshot); */\n\n\t\tgettimeofday(&pkth.ts, NULL);\n\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t    pcapint_filter(handle->fcode.bf_insns, (u_char *)raw_msg, pkth.len, pkth.caplen)) {\n\t\t\thandlep->packets_read++;\n\t\t\tcallback(user, &pkth, (u_char *)raw_msg);\n\t\t\tcount++;\n\t\t}\n\n\t\tdbus_free(raw_msg);\n\t}\n\n\tdbus_message_unref(message);\n\n\treturn count;\n}\n\nstatic int\ndbus_write(pcap_t *handle, const void *buf, int size)\n{\n\t/* XXX, not tested */\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tDBusError error = DBUS_ERROR_INIT;\n\tDBusMessage *msg;\n\n\tif (!(msg = dbus_message_demarshal(buf, size, &error))) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"dbus_message_demarshal() failed: %s\", error.message);\n\t\tdbus_error_free(&error);\n\t\treturn -1;\n\t}\n\n\tdbus_connection_send(handlep->conn, msg, NULL);\n\tdbus_connection_flush(handlep->conn);\n\n\tdbus_message_unref(msg);\n\treturn 0;\n}\n\nstatic int\ndbus_stats(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = 0;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}\n\nstatic void\ndbus_cleanup(pcap_t *handle)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tdbus_connection_unref(handlep->conn);\n\n\tpcapint_cleanup_live_common(handle);\n}\n\n/*\n * We don't support non-blocking mode.  I'm not sure what we'd\n * do to support it and, given that we don't support select()/\n * poll()/epoll_wait()/kevent() etc., it probably doesn't\n * matter.\n */\nstatic int\ndbus_getnonblock(pcap_t *p)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing on D-Bus\");\n\treturn (-1);\n}\n\nstatic int\ndbus_setnonblock(pcap_t *p, int nonblock _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing on D-Bus\");\n\treturn (-1);\n}\n\nstatic int\ndbus_activate(pcap_t *handle)\n{\n#define EAVESDROPPING_RULE \"eavesdrop=true,\"\n\n\tstatic const char *rules[] = {\n\t\tEAVESDROPPING_RULE \"type='signal'\",\n\t\tEAVESDROPPING_RULE \"type='method_call'\",\n\t\tEAVESDROPPING_RULE \"type='method_return'\",\n\t\tEAVESDROPPING_RULE \"type='error'\",\n\t};\n\n\t#define N_RULES sizeof(rules)/sizeof(rules[0])\n\n\tstruct pcap_dbus *handlep = handle->priv;\n\tconst char *dev = handle->opt.device;\n\n\tDBusError error = DBUS_ERROR_INIT;\n\tu_int i;\n\n\tif (strcmp(dev, \"dbus-system\") == 0) {\n\t\tif (!(handlep->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &error))) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to get system bus: %s\", error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else if (strcmp(dev, \"dbus-session\") == 0) {\n\t\tif (!(handlep->conn = dbus_bus_get(DBUS_BUS_SESSION, &error))) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to get session bus: %s\", error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else if (strncmp(dev, \"dbus://\", 7) == 0) {\n\t\tconst char *addr = dev + 7;\n\n\t\tif (!(handlep->conn = dbus_connection_open(addr, &error))) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to open connection to: %s: %s\", addr, error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\tif (!dbus_bus_register(handlep->conn, &error)) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to register bus %s: %s\\n\", addr, error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Can't get bus address from %s\", handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = 0;\n\thandle->offset = 0;\n\thandle->linktype = DLT_DBUS;\n\thandle->read_op = dbus_read;\n\thandle->inject_op = dbus_write;\n\thandle->setfilter_op = pcapint_install_bpf_program; /* XXX, later add support for dbus_bus_add_match() */\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = NULL;      /* can't change data link type */\n\thandle->getnonblock_op = dbus_getnonblock;\n\thandle->setnonblock_op = dbus_setnonblock;\n\thandle->stats_op = dbus_stats;\n\thandle->cleanup_op = dbus_cleanup;\n\n#ifndef _WIN32\n\t/*\n\t * Unfortunately, trying to do a select()/poll()/epoll_wait()/\n\t * kevent()/etc. on a D-Bus connection isn't a simple\n\t * case of \"give me an FD on which to wait\".\n\t *\n\t * Apparently, you have to register \"add watch\", \"remove watch\",\n\t * and \"toggle watch\" functions with\n\t * dbus_connection_set_watch_functions(),\n\t * keep a *set* of FDs, add to that set in the \"add watch\"\n\t * function, subtract from it in the \"remove watch\" function,\n\t * and either add to or subtract from that set in the \"toggle\n\t * watch\" function, and do the wait on *all* of the FDs in the\n\t * set.  (Yes, you need the \"toggle watch\" function, so that\n\t * the main loop doesn't itself need to check for whether\n\t * a given watch is enabled or disabled - most libpcap programs\n\t * know nothing about D-Bus and shouldn't *have* to know anything\n\t * about D-Bus other than how to decode D-Bus messages.)\n\t *\n\t * Implementing that would require considerable changes in\n\t * the way libpcap exports \"selectable FDs\" to its client.\n\t * Until that's done, we just say \"you can't do that\".\n\t */\n\thandle->selectable_fd = handle->fd = -1;\n#endif\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to dbus connections.\n\t\t */\n\t\tdbus_cleanup(handle);\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum message length for D-Bus (128MB).\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > 134217728)\n\t\thandle->snapshot = 134217728;\n\n\t/* dbus_connection_set_max_message_size(handlep->conn, handle->snapshot); */\n\tif (handle->opt.buffer_size != 0)\n\t\tdbus_connection_set_max_received_size(handlep->conn, handle->opt.buffer_size);\n\n\tfor (i = 0; i < N_RULES; i++) {\n\t\tdbus_bus_add_match(handlep->conn, rules[i], &error);\n\t\tif (dbus_error_is_set(&error)) {\n\t\t\tdbus_error_free(&error);\n\n\t\t\t/* try without eavesdrop */\n\t\t\tdbus_bus_add_match(handlep->conn, rules[i] + strlen(EAVESDROPPING_RULE), &error);\n\t\t\tif (dbus_error_is_set(&error)) {\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to add bus match: %s\\n\", error.message);\n\t\t\t\tdbus_error_free(&error);\n\t\t\t\tdbus_cleanup(handle);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\npcap_t *\ndbus_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\n\tif (strcmp(device, \"dbus-system\") &&\n\t\tstrcmp(device, \"dbus-session\") &&\n\t\tstrncmp(device, \"dbus://\", 7))\n\t{\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t*is_ours = 1;\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_dbus);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = dbus_activate;\n\t/*\n\t * Set these up front, so that, even if our client tries\n\t * to set non-blocking mode before we're activated, or\n\t * query the state of non-blocking mode, they get an error,\n\t * rather than having the non-blocking mode option set\n\t * for use later.\n\t */\n\tp->getnonblock_op = dbus_getnonblock;\n\tp->setnonblock_op = dbus_setnonblock;\n\treturn (p);\n}\n\nint\ndbus_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\t/*\n\t * The notion of \"connected\" vs. \"disconnected\" doesn't apply.\n\t * XXX - what about the notions of \"up\" and \"running\"?\n\t */\n\tif (pcapint_add_dev(devlistp, \"dbus-system\",\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, \"D-Bus system bus\",\n\t    err_str) == NULL)\n\t\treturn -1;\n\tif (pcapint_add_dev(devlistp, \"dbus-session\",\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, \"D-Bus session bus\",\n\t    err_str) == NULL)\n\t\treturn -1;\n\treturn 0;\n}\n\n"
        },
        {
          "name": "pcap-dbus.h",
          "type": "blob",
          "size": 0.109375,
          "content": "pcap_t *dbus_create(const char *, char *, int *);\nint dbus_findalldevs(pcap_if_list_t *devlistp, char *errbuf);\n"
        },
        {
          "name": "pcap-dll.rc",
          "type": "blob",
          "size": 1.03125,
          "content": "#include \"config.h\"\n#include <winver.h>\n\n  VS_VERSION_INFO VERSIONINFO\n    FILEVERSION    PACKAGE_VERSION_DLL\n    PRODUCTVERSION PACKAGE_VERSION_DLL\n    FILEFLAGSMASK  0x3fL\n    FILEOS         VOS__WINDOWS32\n    FILETYPE       VFT_DLL\n#ifdef _DEBUG\n    FILEFLAGS 0x1L\n#else\n    FILEFLAGS 0x0L\n#endif\n  BEGIN\n    BLOCK \"StringFileInfo\"\n    BEGIN\n      BLOCK \"040904b0\"\n      BEGIN\n        VALUE \"Comments\",         \"https://github.com/the-tcpdump-group/libpcap/\"\n        VALUE \"CompanyName\",      \"The TCPdump Group\"\n        VALUE \"FileDescription\",  \"System-Independent Interface for User-Level Packet Capture\"\n        VALUE \"FileVersion\",      PACKAGE_VERSION\n        VALUE \"InternalName\",     PACKAGE_NAME\n        VALUE \"LegalCopyright\",   \"Copyright (c) The TCPdump Group\"\n        VALUE \"LegalTrademarks\",  \"\"\n        VALUE \"OriginalFilename\", PACKAGE_NAME \".dll\"\n        VALUE \"ProductName\",      \"libpcap\"\n        VALUE \"ProductVersion\",   PACKAGE_VERSION\n      END\n    END\n  BLOCK \"VarFileInfo\"\n  BEGIN\n    VALUE \"Translation\", 0x0, 1200\n  END\n  END\n"
        },
        {
          "name": "pcap-dlpi.c",
          "type": "blob",
          "size": 45.1708984375,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * This code contributed by Atanu Ghosh (atanu@cs.ucl.ac.uk),\n * University College London, and subsequently modified by\n * Guy Harris (guy@alum.mit.edu), Mark Pizzolato\n * <List-tcpdump-workers@subscriptions.pizzolato.net>,\n * Mark C. Brown (mbrown@hp.com), and Sagun Shakya <Sagun.Shakya@Sun.COM>.\n */\n\n/*\n * Packet capture routine for DLPI under SunOS 5, HP-UX 10/11, and AIX.\n *\n * Notes:\n *\n *    - The DLIOCRAW ioctl() is specific to SunOS.\n *\n *    - It might be desirable to use pfmod(7) to filter packets in the\n *      kernel when possible.\n *\n *    - An older version of the HP-UX DLPI Programmer's Guide, which\n *      I think was advertised as the 10.20 version, used to be available\n *      at\n *\n *            http://docs.hp.com/hpux/onlinedocs/B2355-90093/B2355-90093.html\n *\n *      but is no longer available; it can still be found at\n *\n *            http://h21007.www2.hp.com/dspp/files/unprotected/Drivers/Docs/Refs/B2355-90093.pdf\n *\n *      in PDF form.\n *\n *    - The HP-UX 10.x, 11.0, and 11i v1.6 version of the HP-UX DLPI\n *      Programmer's Guide, which I think was once advertised as the\n *      11.00 version is available at\n *\n *            http://docs.hp.com/en/B2355-90139/index.html\n *\n *    - The HP-UX 11i v2 version of the HP-UX DLPI Programmer's Guide\n *      is available at\n *\n *            http://docs.hp.com/en/B2355-90871/index.html\n *\n *    - All of the HP documents describe raw-mode services, which are\n *      what we use if DL_HP_RAWDLS is defined.  XXX - we use __hpux\n *      in some places to test for HP-UX, but use DL_HP_RAWDLS in\n *      other places; do we support any versions of HP-UX without\n *      DL_HP_RAWDLS?\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/time.h>\n#ifdef HAVE_SYS_BUFMOD_H\n#include <sys/bufmod.h>\n#endif\n#include <sys/dlpi.h>\n#ifdef HAVE_SYS_DLPI_EXT_H\n#include <sys/dlpi_ext.h>\n#endif\n#ifdef DL_HP_PPA_REQ\n#include <sys/stat.h>\n#endif\n#include <sys/stream.h>\n#if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)\n#include <sys/systeminfo.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stropts.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"pcap-int.h\"\n#include \"dlpisubs.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#if defined(__hpux)\n  /*\n   * HP-UX has a /dev/dlpi device; you open it and set the PPA of the actual\n   * network device you want.\n   */\n  #define HAVE_DEV_DLPI\n#elif defined(_AIX)\n  /*\n   * AIX has a /dev/dlpi directory, with devices named after the interfaces\n   * underneath it.\n   */\n  #define PCAP_DEV_PREFIX \"/dev/dlpi\"\n#elif defined(HAVE_SOLARIS)\n  /*\n   * Solaris has devices named after the interfaces underneath /dev.\n   */\n  #define PCAP_DEV_PREFIX \"/dev\"\n#endif\n\n#define\tMAXDLBUF\t8192\n\n/* Forwards */\nstatic char *split_dname(char *, u_int *, char *);\nstatic int dl_doattach(int, int, char *);\n#ifdef DL_HP_RAWDLS\nstatic int dl_dohpuxbind(int, char *);\n#endif\nstatic int dlpromiscon(pcap_t *, bpf_u_int32);\nstatic int dlbindreq(int, bpf_u_int32, char *);\nstatic int dlbindack(int, char *, char *, int *);\nstatic int dlokack(int, const char *, char *, char *, int *);\nstatic int dlinforeq(int, char *);\nstatic int dlinfoack(int, char *, char *);\n\n#ifdef HAVE_DL_PASSIVE_REQ_T\nstatic void dlpassive(int, char *);\n#endif\n\n#ifdef DL_HP_RAWDLS\nstatic int dlrawdatareq(int, const u_char *, int);\n#endif\nstatic int recv_ack(int, int, const char *, char *, char *, int *);\nstatic char *dlstrerror(char *, size_t, bpf_u_int32);\nstatic char *dlprim(char *, size_t, bpf_u_int32);\nstatic int send_request(int, char *, int, char *, char *);\n#ifdef HAVE_DEV_DLPI\nstatic int get_dlpi_ppa(int, const char *, u_int, u_int *, char *);\n#endif\n\n/*\n * Cast a buffer to \"union DL_primitives\" without provoking warnings\n * from the compiler.\n */\n#define MAKE_DL_PRIMITIVES(ptr)\t((union DL_primitives *)(void *)(ptr))\n\nstatic int\npcap_read_dlpi(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tint cc;\n\tu_char *bp;\n\tint flags;\n\tbpf_u_int32 ctlbuf[MAXDLBUF];\n\tstruct strbuf ctl = {\n\t\tMAXDLBUF,\n\t\t0,\n\t\t(char *)ctlbuf\n\t};\n\tstruct strbuf data;\n\n\tflags = 0;\n\tcc = p->cc;\n\tif (cc == 0) {\n\t\tdata.buf = (char *)p->buffer + p->offset;\n\t\tdata.maxlen = p->bufsize;\n\t\tdata.len = 0;\n\t\tdo {\n\t\t\t/*\n\t\t\t * Has \"pcap_breakloop()\" been called?\n\t\t\t */\n\t\t\tif (p->break_loop) {\n\t\t\t\t/*\n\t\t\t\t * Yes - clear the flag that indicates\n\t\t\t\t * that it has, and return -2 to\n\t\t\t\t * indicate that we were told to\n\t\t\t\t * break out of the loop.\n\t\t\t\t */\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX - check for the DLPI primitive, which\n\t\t\t * would be DL_HP_RAWDATA_IND on HP-UX\n\t\t\t * if we're in raw mode?\n\t\t\t */\n\t\t\tctl.buf = (char *)ctlbuf;\n\t\t\tctl.maxlen = MAXDLBUF;\n\t\t\tctl.len = 0;\n\t\t\tif (getmsg(p->fd, &ctl, &data, &flags) < 0) {\n\t\t\t\t/* Don't choke when we get ptraced */\n\t\t\t\tswitch (errno) {\n\n\t\t\t\tcase EINTR:\n\t\t\t\t\tcc = 0;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase EAGAIN:\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    sizeof(p->errbuf), errno, \"getmsg\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tcc = data.len;\n\t\t} while (cc == 0);\n\t\tbp = p->buffer + p->offset;\n\t} else\n\t\tbp = p->bp;\n\n\treturn (pcap_process_pkts(p, callback, user, cnt, bp, cc));\n}\n\nstatic int\npcap_inject_dlpi(pcap_t *p, const void *buf, int size)\n{\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd = p->priv;\n#endif\n\tint ret;\n\n#if defined(DLIOCRAW)\n\tret = write(p->fd, buf, size);\n\tif (ret == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n#elif defined(DL_HP_RAWDLS)\n\tif (pd->send_fd < 0) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"send: Output FD couldn't be opened\");\n\t\treturn (-1);\n\t}\n\tret = dlrawdatareq(pd->send_fd, buf, size);\n\tif (ret == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\t/*\n\t * putmsg() returns either 0 or -1; it doesn't indicate how\n\t * many bytes were written (presumably they were all written\n\t * or none of them were written).  OpenBSD's pcap_inject()\n\t * returns the number of bytes written, so, for API compatibility,\n\t * we return the number of bytes we were told to write.\n\t */\n\tret = size;\n#else /* no raw mode */\n\t/*\n\t * XXX - this is a pain, because you might have to extract\n\t * the address from the packet and use it in a DL_UNITDATA_REQ\n\t * request.  That would be dependent on the link-layer type.\n\t *\n\t * I also don't know what SAP you'd have to bind the descriptor\n\t * to, or whether you'd need separate \"receive\" and \"send\" FDs,\n\t * nor do I know whether you'd need different bindings for\n\t * D/I/X Ethernet and 802.3, or for {FDDI,Token Ring} plus\n\t * 802.2 and {FDDI,Token Ring} plus 802.2 plus SNAP.\n\t *\n\t * So, for now, we just return a \"you can't send\" indication,\n\t * and leave it up to somebody with a DLPI-based system lacking\n\t * both DLIOCRAW and DL_HP_RAWDLS to supply code to implement\n\t * packet transmission on that system.  If they do, they should\n\t * send it to us - but should not send us code that assumes\n\t * Ethernet; if the code doesn't work on non-Ethernet interfaces,\n\t * it should check \"p->linktype\" and reject the send request if\n\t * it's anything other than DLT_EN10MB.\n\t */\n\tpcapint_strlcpy(p->errbuf, \"send: Not supported on this version of this OS\",\n\t    PCAP_ERRBUF_SIZE);\n\tret = -1;\n#endif /* raw mode */\n\treturn (ret);\n}\n\n#ifndef DL_IPATM\n#define DL_IPATM\t0x12\t/* ATM Classical IP interface */\n#endif\n\n#ifdef HAVE_SOLARIS\n/*\n * For SunATM.\n */\n#ifndef A_GET_UNITS\n#define A_GET_UNITS\t(('A'<<8)|118)\n#endif /* A_GET_UNITS */\n#ifndef A_PROMISCON_REQ\n#define A_PROMISCON_REQ\t(('A'<<8)|121)\n#endif /* A_PROMISCON_REQ */\n#endif /* HAVE_SOLARIS */\n\nstatic void\npcap_cleanup_dlpi(pcap_t *p)\n{\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd = p->priv;\n\n\tif (pd->send_fd >= 0) {\n\t\tclose(pd->send_fd);\n\t\tpd->send_fd = -1;\n\t}\n#endif\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic int\nopen_dlpi_device(const char *name, u_int *ppa, char *errbuf)\n{\n\tint status;\n\tchar dname[100];\n\tchar *cp, *cq;\n\tint fd;\n#ifdef HAVE_DEV_DLPI\n\tu_int unit;\n#else\n\tchar dname2[100];\n#endif\n\n#ifdef HAVE_DEV_DLPI\n\t/*\n\t** Remove any \"/dev/\" on the front of the device.\n\t*/\n\tcp = strrchr(name, '/');\n\tif (cp == NULL)\n\t\tpcapint_strlcpy(dname, name, sizeof(dname));\n\telse\n\t\tpcapint_strlcpy(dname, cp + 1, sizeof(dname));\n\n\t/*\n\t * If this name has a colon followed by a number at\n\t * the end, it's a logical interface.  Those are just\n\t * the way you assign multiple IP addresses to a real\n\t * interface, so an entry for a logical interface should\n\t * be treated like the entry for the real interface;\n\t * we do that by stripping off the \":\" and the number.\n\t */\n\tcp = strchr(dname, ':');\n\tif (cp != NULL) {\n\t\t/*\n\t\t * We have a \":\"; is it followed by a number?\n\t\t */\n\t\tcq = cp + 1;\n\t\twhile (PCAP_ISDIGIT(*cq))\n\t\t\tcq++;\n\t\tif (*cq == '\\0') {\n\t\t\t/*\n\t\t\t * All digits after the \":\" until the end.\n\t\t\t * Strip off the \":\" and everything after\n\t\t\t * it.\n\t\t\t */\n\t\t\t*cp = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Split the device name into a device type name and a unit number;\n\t * chop off the unit number, so \"dname\" is just a device type name.\n\t */\n\tcp = split_dname(dname, &unit, errbuf);\n\tif (cp == NULL) {\n\t\t/*\n\t\t * split_dname() has filled in the error message.\n\t\t */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\t*cp = '\\0';\n\n\t/*\n\t * Use \"/dev/dlpi\" as the device.\n\t *\n\t * XXX - HP's DLPI Programmer's Guide for HP-UX 11.00 says that\n\t * the \"dl_mjr_num\" field is for the \"major number of interface\n\t * driver\"; that's the major of \"/dev/dlpi\" on the system on\n\t * which I tried this, but there may be DLPI devices that\n\t * use a different driver, in which case we may need to\n\t * search \"/dev\" for the appropriate device with that major\n\t * device number, rather than hardwiring \"/dev/dlpi\".\n\t */\n\tcp = \"/dev/dlpi\";\n\tif ((fd = open(cp, O_RDWR)) < 0) {\n\t\tif (errno == EPERM || errno == EACCES) {\n\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to open %s failed with %s - root privilege may be required\",\n\t\t\t    cp, (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t} else {\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Attempt to open %s failed\", cp);\n\t\t}\n\t\treturn (status);\n\t}\n\n\t/*\n\t * Get a table of all PPAs for that device, and search that\n\t * table for the specified device type name and unit number.\n\t */\n\tstatus = get_dlpi_ppa(fd, dname, unit, ppa, errbuf);\n\tif (status < 0) {\n\t\tclose(fd);\n\t\treturn (status);\n\t}\n#else\n\t/*\n\t * If the device name begins with \"/\", assume it begins with\n\t * the pathname of the directory containing the device to open;\n\t * otherwise, concatenate the device directory name and the\n\t * device name.\n\t */\n\tif (*name == '/')\n\t\tpcapint_strlcpy(dname, name, sizeof(dname));\n\telse\n\t\tsnprintf(dname, sizeof(dname), \"%s/%s\", PCAP_DEV_PREFIX,\n\t\t    name);\n\n\t/*\n\t * If this name has a colon followed by a number at\n\t * the end, it's a logical interface.  Those are just\n\t * the way you assign multiple IP addresses to a real\n\t * interface, so an entry for a logical interface should\n\t * be treated like the entry for the real interface;\n\t * we do that by stripping off the \":\" and the number.\n\t */\n\tcp = strchr(dname, ':');\n\tif (cp != NULL) {\n\t\t/*\n\t\t * We have a \":\"; is it followed by a number?\n\t\t */\n\t\tcq = cp + 1;\n\t\twhile (PCAP_ISDIGIT(*cq))\n\t\t\tcq++;\n\t\tif (*cq == '\\0') {\n\t\t\t/*\n\t\t\t * All digits after the \":\" until the end.\n\t\t\t * Strip off the \":\" and everything after\n\t\t\t * it.\n\t\t\t */\n\t\t\t*cp = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Get the unit number, and a pointer to the end of the device\n\t * type name.\n\t */\n\tcp = split_dname(dname, ppa, errbuf);\n\tif (cp == NULL) {\n\t\t/*\n\t\t * split_dname() has filled in the error message.\n\t\t */\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\n\t/*\n\t * Make a copy of the device pathname, and then remove the unit\n\t * number from the device pathname.\n\t */\n\tpcapint_strlcpy(dname2, dname, sizeof(dname));\n\t*cp = '\\0';\n\n\t/* Try device without unit number */\n\tif ((fd = open(dname, O_RDWR)) < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tif (errno == EPERM || errno == EACCES) {\n\t\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Attempt to open %s failed with %s - root privilege may be required\",\n\t\t\t\t    dname,\n\t\t\t\t    (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t\t} else {\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Attempt to open %s failed\", dname);\n\t\t\t}\n\t\t\treturn (status);\n\t\t}\n\n\t\t/* Try again with unit number */\n\t\tif ((fd = open(dname2, O_RDWR)) < 0) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\n\t\t\t\t/*\n\t\t\t\t * We provide an error message even\n\t\t\t\t * for this error, for diagnostic\n\t\t\t\t * purposes (so that, for example,\n\t\t\t\t * the app can show the message if the\n\t\t\t\t * user requests it).\n\t\t\t\t *\n\t\t\t\t * In it, we just report \"No DLPI device\n\t\t\t\t * found\" with the device name, so people\n\t\t\t\t * don't get confused and think, for example,\n\t\t\t\t * that if they can't capture on \"lo0\"\n\t\t\t\t * on Solaris prior to Solaris 11 the fix\n\t\t\t\t * is to change libpcap (or the application\n\t\t\t\t * that uses it) to look for something other\n\t\t\t\t * than \"/dev/lo0\", as the fix is to use\n\t\t\t\t * Solaris 11 or some operating system\n\t\t\t\t * other than Solaris - you just *can't*\n\t\t\t\t * capture on a loopback interface\n\t\t\t\t * on Solaris prior to Solaris 11, the lack\n\t\t\t\t * of a DLPI device for the loopback\n\t\t\t\t * interface is just a symptom of that\n\t\t\t\t * inability.\n\t\t\t\t */\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: No DLPI device found\", name);\n\t\t\t} else {\n\t\t\t\tif (errno == EPERM || errno == EACCES) {\n\t\t\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Attempt to open %s failed with %s - root privilege may be required\",\n\t\t\t\t\t    dname2,\n\t\t\t\t\t    (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t\t\t} else {\n\t\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"Attempt to open %s failed\",\n\t\t\t\t\t    dname2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (status);\n\t\t}\n\t\t/* XXX Assume unit zero */\n\t\t*ppa = 0;\n\t}\n#endif\n\treturn (fd);\n}\n\nstatic int\npcap_activate_dlpi(pcap_t *p)\n{\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd = p->priv;\n#endif\n\tint status = 0;\n\tint retv;\n\tu_int ppa;\n#ifdef HAVE_SOLARIS\n\tint isatm = 0;\n#endif\n\tregister dl_info_ack_t *infop;\n#ifdef HAVE_SYS_BUFMOD_H\n\tbpf_u_int32 ss;\n#endif\n\tbpf_u_int32 buf[MAXDLBUF];\n\n\tp->fd = open_dlpi_device(p->opt.device, &ppa, p->errbuf);\n\tif (p->fd < 0) {\n\t\tstatus = p->fd;\n\t\tgoto bad;\n\t}\n\n#ifdef DL_HP_RAWDLS\n\t/*\n\t * XXX - HP-UX 10.20 and 11.xx don't appear to support sending and\n\t * receiving packets on the same descriptor - you need separate\n\t * descriptors for sending and receiving, bound to different SAPs.\n\t *\n\t * If the open fails, we just leave -1 in \"pd->send_fd\" and reject\n\t * attempts to send packets, just as if, in pcap-bpf.c, we fail\n\t * to open the BPF device for reading and writing, we just try\n\t * to open it for reading only and, if that succeeds, just let\n\t * the send attempts fail.\n\t */\n\tpd->send_fd = open(\"/dev/dlpi\", O_RDWR);\n#endif\n\n\t/*\n\t** Attach if \"style 2\" provider\n\t*/\n\tif (dlinforeq(p->fd, p->errbuf) < 0 ||\n\t    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tinfop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;\n#ifdef HAVE_SOLARIS\n\tif (infop->dl_mac_type == DL_IPATM)\n\t\tisatm = 1;\n#endif\n\tif (infop->dl_provider_style == DL_STYLE2) {\n\t\tretv = dl_doattach(p->fd, ppa, p->errbuf);\n\t\tif (retv < 0) {\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n#ifdef DL_HP_RAWDLS\n\t\tif (pd->send_fd >= 0) {\n\t\t\tretv = dl_doattach(pd->send_fd, ppa, p->errbuf);\n\t\t\tif (retv < 0) {\n\t\t\t\tstatus = retv;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * This device exists, but we don't support monitor mode\n\t\t * any platforms that support DLPI.\n\t\t */\n\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\tgoto bad;\n\t}\n\n#ifdef HAVE_DL_PASSIVE_REQ_T\n\t/*\n\t * Enable Passive mode to be able to capture on aggregated link.\n\t * Not supported in all Solaris versions.\n\t */\n\tdlpassive(p->fd, p->errbuf);\n#endif\n\t/*\n\t** Bind.\n\t*/\n#ifdef _AIX\n\t/*\n\t** AIX.\n\t** According to IBM's AIX Support Line, the dl_sap value\n\t** should not be less than 0x600 (1536) for standard Ethernet.\n\t** However, we seem to get DL_BADADDR - \"DLSAP addr in improper\n\t** format or invalid\" - errors if we use 1537 on the \"tr0\"\n\t** device, which, given that its name starts with \"tr\" and that\n\t** it's IBM, probably means a Token Ring device.  (Perhaps we\n\t** need to use 1537 on \"/dev/dlpi/en\" because that device is for\n\t** D/I/X Ethernet, the \"SAP\" is actually an Ethernet type, and\n\t** it rejects invalid Ethernet types.)\n\t**\n\t** So if 1537 fails, we try 2, as Hyung Sik Yoon of IBM Korea\n\t** says that works on Token Ring (he says that 0 does *not*\n\t** work; perhaps that's considered an invalid LLC SAP value - I\n\t** assume the SAP value in a DLPI bind is an LLC SAP for network\n\t** types that use 802.2 LLC).\n\t*/\n\tif ((dlbindreq(p->fd, 1537, p->errbuf) < 0 &&\n\t     dlbindreq(p->fd, 2, p->errbuf) < 0) ||\n\t     dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#elif defined(HAVE_HPUX10_20_OR_LATER)\n\t/*\n\t** Defer.\n\t*/\n#else /* neither AIX nor HP-UX */\n\t/*\n\t** Neither AIX nor HP-UX - Solaris, and any other\n\t** OS using DLPI.\n\t**/\n\tif (dlbindreq(p->fd, 0, p->errbuf) < 0 ||\n\t    dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif /* AIX vs. HP-UX vs. other */\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n#ifdef HAVE_SOLARIS\n\tif (isatm) {\n\t\t/*\n\t\t** Have to turn on some special ATM promiscuous mode\n\t\t** for SunATM.\n\t\t** Do *NOT* turn regular promiscuous mode on; it doesn't\n\t\t** help, and may break things.\n\t\t*/\n\t\tif (strioctl(p->fd, A_PROMISCON_REQ, 0, NULL) < 0) {\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"A_PROMISCON_REQ\");\n\t\t\tgoto bad;\n\t\t}\n\t} else\n#endif\n\tif (p->opt.promisc) {\n\t\t/*\n\t\t** Enable promiscuous (not necessary on send FD)\n\t\t*/\n\t\tretv = dlpromiscon(p, DL_PROMISC_PHYS);\n\t\tif (retv < 0) {\n\t\t\tif (retv == PCAP_ERROR_PERM_DENIED)\n\t\t\t\tstatus = PCAP_ERROR_PROMISC_PERM_DENIED;\n\t\t\telse\n\t\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\n\t\t/*\n\t\t** Try to enable multicast (you would have thought\n\t\t** promiscuous would be sufficient). (Skip if using\n\t\t** HP-UX) (Not necessary on send FD)\n\t\t*/\n#if !defined(__hpux)\n\t\tretv = dlpromiscon(p, DL_PROMISC_MULTI);\n\t\tif (retv < 0)\n\t\t\tstatus = PCAP_WARNING;\n#endif\n\t}\n\t/*\n\t** Try to enable SAP promiscuity (when not in promiscuous mode\n\t** when using HP-UX, when not doing SunATM on Solaris)\n\t** (Not necessary on send FD)\n\t*/\n#if defined(__hpux)\n\t/* HP-UX - only do this when not in promiscuous mode */\n\tif (!p->opt.promisc) {\n#elif defined(HAVE_SOLARIS)\n\t/* Solaris - don't do this on SunATM devices */\n\tif (!isatm) {\n#else\n\t/* Everything else - always do this. */\n\t{\n#endif\n\t\tretv = dlpromiscon(p, DL_PROMISC_SAP);\n\t\tif (retv < 0) {\n\t\t\tif (p->opt.promisc) {\n\t\t\t\t/*\n\t\t\t\t * Not fatal, since the DL_PROMISC_PHYS mode\n\t\t\t\t * worked.\n\t\t\t\t *\n\t\t\t\t * Report it as a warning, however.\n\t\t\t\t */\n\t\t\t\tstatus = PCAP_WARNING;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Fatal.\n\t\t\t\t */\n\t\t\t\tstatus = retv;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t** HP-UX 10.20 or later must bind after setting\n\t** promiscuous options.\n\t*/\n#if defined(HAVE_HPUX10_20_OR_LATER)\n\tif (dl_dohpuxbind(p->fd, p->errbuf) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/*\n\t** We don't set promiscuous mode on the send FD, but we'll defer\n\t** binding it anyway, just to keep the HP-UX 10.20 or later\n\t** code together.\n\t*/\n\tif (pd->send_fd >= 0) {\n\t\t/*\n\t\t** XXX - if this fails, just close send_fd and\n\t\t** set it to -1, so that you can't send but can\n\t\t** still receive?\n\t\t*/\n\t\tif (dl_dohpuxbind(pd->send_fd, p->errbuf) < 0) {\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t** Determine link type\n\t** XXX - get SAP length and address length as well, for use\n\t** when sending packets.\n\t*/\n\tif (dlinforeq(p->fd, p->errbuf) < 0 ||\n\t    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\tinfop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;\n\tif (pcap_process_mactype(p, infop->dl_mac_type) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n#ifdef\tDLIOCRAW\n\t/*\n\t** This is a non standard SunOS hack to get the full raw link-layer\n\t** header.\n\t*/\n\tif (strioctl(p->fd, DLIOCRAW, 0, NULL) < 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"DLIOCRAW\");\n\t\tgoto bad;\n\t}\n#endif\n\n#ifdef HAVE_SYS_BUFMOD_H\n\tss = p->snapshot;\n\t/* Push and configure bufmod. */\n\tif (pcap_conf_bufmod(p, ss) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#endif\n\n\t/*\n\t** As the last operation flush the read side.\n\t*/\n\tif (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"FLUSHR\");\n\t\tgoto bad;\n\t}\n\n\t/* Allocate data buffer. */\n\tif (pcap_alloc_databuf(p) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Success.\n\t *\n\t * \"p->fd\" is an FD for a STREAMS device, so \"select()\" and\n\t * \"poll()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\tp->read_op = pcap_read_dlpi;\n\tp->inject_op = pcap_inject_dlpi;\n\tp->setfilter_op = pcapint_install_bpf_program;\t/* no kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented.*/\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcapint_getnonblock_fd;\n\tp->setnonblock_op = pcapint_setnonblock_fd;\n\tp->stats_op = pcap_stats_dlpi;\n\tp->cleanup_op = pcap_cleanup_dlpi;\n\n\treturn (status);\nbad:\n\tpcap_cleanup_dlpi(p);\n\treturn (status);\n}\n\n/*\n * Split a device name into a device type name and a unit number;\n * return the a pointer to the beginning of the unit number, which\n * is the end of the device type name, and set \"*unitp\" to the unit\n * number.\n *\n * Returns NULL on error, and fills \"ebuf\" with an error message.\n */\nstatic char *\nsplit_dname(char *device, u_int *unitp, char *ebuf)\n{\n\tchar *cp;\n\tchar *eos;\n\tlong unit;\n\n\t/*\n\t * Look for a number at the end of the device name string.\n\t */\n\tcp = device + strlen(device) - 1;\n\tif (*cp < '0' || *cp > '9') {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s missing unit number\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\n\t/* Digits at end of string are unit number */\n\twhile (cp-1 >= device && *(cp-1) >= '0' && *(cp-1) <= '9')\n\t\tcp--;\n\n\terrno = 0;\n\tunit = strtol(cp, &eos, 10);\n\tif (*eos != '\\0') {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s bad unit number\", device);\n\t\treturn (NULL);\n\t}\n\tif (errno == ERANGE || unit > INT_MAX) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s unit number too large\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\tif (unit < 0) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s unit number is negative\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\t*unitp = (u_int)unit;\n\treturn (cp);\n}\n\nstatic int\ndl_doattach(int fd, int ppa, char *ebuf)\n{\n\tdl_attach_req_t\treq;\n\tbpf_u_int32 buf[MAXDLBUF];\n\tint err;\n\n\treq.dl_primitive = DL_ATTACH_REQ;\n\treq.dl_ppa = ppa;\n\tif (send_request(fd, (char *)&req, sizeof(req), \"attach\", ebuf) < 0)\n\t\treturn (PCAP_ERROR);\n\n\terr = dlokack(fd, \"attach\", (char *)buf, ebuf, NULL);\n\tif (err < 0)\n\t\treturn (err);\n\treturn (0);\n}\n\n#ifdef DL_HP_RAWDLS\nstatic int\ndl_dohpuxbind(int fd, char *ebuf)\n{\n\tint hpsap;\n\tint uerror;\n\tbpf_u_int32 buf[MAXDLBUF];\n\n\t/*\n\t * XXX - we start at 22 because we used to use only 22, but\n\t * that was just because that was the value used in some\n\t * sample code from HP.  With what value *should* we start?\n\t * Does it matter, given that we're enabling SAP promiscuity\n\t * on the input FD?\n\t */\n\thpsap = 22;\n\tfor (;;) {\n\t\tif (dlbindreq(fd, hpsap, ebuf) < 0)\n\t\t\treturn (-1);\n\t\tif (dlbindack(fd, (char *)buf, ebuf, &uerror) >= 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * For any error other than a UNIX EBUSY, give up.\n\t\t */\n\t\tif (uerror != EBUSY) {\n\t\t\t/*\n\t\t\t * dlbindack() has already filled in ebuf for\n\t\t\t * this error.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * For EBUSY, try the next SAP value; that means that\n\t\t * somebody else is using that SAP.  Clear ebuf so\n\t\t * that application doesn't report the \"Device busy\"\n\t\t * error as a warning.\n\t\t */\n\t\t*ebuf = '\\0';\n\t\thpsap++;\n\t\tif (hpsap > 100) {\n\t\t\tpcapint_strlcpy(ebuf,\n\t\t\t    \"All SAPs from 22 through 100 are in use\",\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (0);\n}\n#endif\n\n#define STRINGIFY(n)\t#n\n\nstatic int\ndlpromiscon(pcap_t *p, bpf_u_int32 level)\n{\n\tdl_promiscon_req_t req;\n\tbpf_u_int32 buf[MAXDLBUF];\n\tint err;\n\tint uerror;\n\n\treq.dl_primitive = DL_PROMISCON_REQ;\n\treq.dl_level = level;\n\tif (send_request(p->fd, (char *)&req, sizeof(req), \"promiscon\",\n\t    p->errbuf) < 0)\n\t\treturn (PCAP_ERROR);\n\terr = dlokack(p->fd, \"promiscon\" STRINGIFY(level), (char *)buf,\n\t    p->errbuf, &uerror);\n\tif (err < 0) {\n\t\tif (err == PCAP_ERROR_PERM_DENIED) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to set promiscuous mode failed with %s - root privilege may be required\",\n\t\t\t    (uerror == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t\terr = PCAP_ERROR_PROMISC_PERM_DENIED;\n\t\t}\n\t\treturn (err);\n\t}\n\treturn (0);\n}\n\n/*\n * Not all interfaces are DLPI interfaces, and thus not all interfaces\n * can be opened with DLPI (for example, the loopback interface is not\n * a DLPI interface on Solaris prior to Solaris 11), so try to open\n * the specified interface; return 0 if we fail with PCAP_ERROR_NO_SUCH_DEVICE\n * and 1 otherwise.\n */\nstatic int\nis_dlpi_interface(const char *name)\n{\n\tint fd;\n\tu_int ppa;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\tfd = open_dlpi_device(name, &ppa, errbuf);\n\tif (fd < 0) {\n\t\t/*\n\t\t * Error - was it PCAP_ERROR_NO_SUCH_DEVICE?\n\t\t */\n\t\tif (fd == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Yes, so we can't open this because it's\n\t\t\t * not a DLPI interface.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * No, so, in the case where there's a single DLPI\n\t\t * device for all interfaces of this type (\"style\n\t\t * 2\" providers?), we don't know whether it's a DLPI\n\t\t * interface or not, as we didn't try an attach.\n\t\t * Say it is a DLPI device, so that the user can at\n\t\t * least try to open it and report the error (which\n\t\t * is probably \"you don't have permission to open that\n\t\t * DLPI device\"; reporting those interfaces means\n\t\t * users will ask \"why am I getting a permissions error\n\t\t * when I try to capture\" rather than \"why am I not\n\t\t * seeing any interfaces\", making the underlying problem\n\t\t * clearer).\n\t\t */\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tclose(fd);\n\treturn (1);\n}\n\nstatic int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n#ifdef HAVE_SOLARIS\n\tint fd;\n\tunion {\n\t\tu_int nunits;\n\t\tchar pad[516];\t/* XXX - must be at least 513; is 516\n\t\t\t\t   in \"atmgetunits\" */\n\t} buf;\n\tchar baname[2+1+1];\n\tu_int i;\n#endif\n\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcapint_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n#ifdef HAVE_SOLARIS\n\t/*\n\t * We may have to do special magic to get ATM devices.\n\t */\n\tif ((fd = open(\"/dev/ba\", O_RDWR)) < 0) {\n\t\t/*\n\t\t * We couldn't open the \"ba\" device.\n\t\t * For now, just give up; perhaps we should\n\t\t * return an error if the problem is neither\n\t\t * a \"that device doesn't exist\" error (ENOENT,\n\t\t * ENXIO, etc.) or a \"you're not allowed to do\n\t\t * that\" error (EPERM, EACCES).\n\t\t */\n\t\treturn (0);\n\t}\n\n\tif (strioctl(fd, A_GET_UNITS, sizeof(buf), (char *)&buf) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"A_GET_UNITS\");\n\t\treturn (-1);\n\t}\n\tfor (i = 0; i < buf.nunits; i++) {\n\t\tsnprintf(baname, sizeof baname, \"ba%u\", i);\n\t\t/*\n\t\t * XXX - is there a notion of \"up\" and \"running\"?\n\t\t * And is there a way to determine whether the\n\t\t * interface is plugged into a network?\n\t\t */\n\t\tif (pcapint_add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)\n\t\t\treturn (-1);\n\t}\n#endif\n\n\treturn (0);\n}\n\nstatic int\nsend_request(int fd, char *ptr, int len, char *what, char *ebuf)\n{\n\tstruct\tstrbuf\tctl;\n\tint\tflags;\n\n\tctl.maxlen = 0;\n\tctl.len = len;\n\tctl.buf = ptr;\n\n\tflags = 0;\n\tif (putmsg(fd, &ctl, (struct strbuf *) NULL, flags) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send_request: putmsg \\\"%s\\\"\", what);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic int\nrecv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror)\n{\n\tunion\tDL_primitives\t*dlp;\n\tstruct\tstrbuf\tctl;\n\tint\tflags;\n\tchar\terrmsgbuf[PCAP_ERRBUF_SIZE];\n\tchar\tdlprimbuf[64];\n\n\t/*\n\t * Clear out \"*uerror\", so it's only set for DL_ERROR_ACK/DL_SYSERR,\n\t * making that the only place where EBUSY is treated specially.\n\t */\n\tif (uerror != NULL)\n\t\t*uerror = 0;\n\n\tctl.maxlen = MAXDLBUF;\n\tctl.len = 0;\n\tctl.buf = bufp;\n\n\tflags = 0;\n\tif (getmsg(fd, &ctl, (struct strbuf*)NULL, &flags) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"recv_ack: %s getmsg\", what);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tdlp = MAKE_DL_PRIMITIVES(ctl.buf);\n\tswitch (dlp->dl_primitive) {\n\n\tcase DL_INFO_ACK:\n\tcase DL_BIND_ACK:\n\tcase DL_OK_ACK:\n#ifdef DL_HP_PPA_ACK\n\tcase DL_HP_PPA_ACK:\n#endif\n\t\t/* These are OK */\n\t\tbreak;\n\n\tcase DL_ERROR_ACK:\n\t\tswitch (dlp->error_ack.dl_errno) {\n\n\t\tcase DL_SYSERR:\n\t\t\tif (uerror != NULL)\n\t\t\t\t*uerror = dlp->error_ack.dl_unix_errno;\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    dlp->error_ack.dl_unix_errno,\n\t\t\t    \"recv_ack: %s: UNIX error\", what);\n\t\t\tif (dlp->error_ack.dl_unix_errno == EPERM ||\n\t\t\t    dlp->error_ack.dl_unix_errno == EACCES)\n\t\t\t\treturn (PCAP_ERROR_PERM_DENIED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Neither EPERM nor EACCES.\n\t\t\t */\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"recv_ack: %s: %s\", what,\n\t\t\t    dlstrerror(errmsgbuf, sizeof (errmsgbuf), dlp->error_ack.dl_errno));\n\t\t\tif (dlp->error_ack.dl_errno == DL_BADPPA)\n\t\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t\t\telse if (dlp->error_ack.dl_errno == DL_ACCESS)\n\t\t\t\treturn (PCAP_ERROR_PERM_DENIED);\n\t\t\tbreak;\n\t\t}\n\t\treturn (PCAP_ERROR);\n\n\tdefault:\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"recv_ack: %s: Unexpected primitive ack %s\",\n\t\t    what, dlprim(dlprimbuf, sizeof (dlprimbuf), dlp->dl_primitive));\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (ctl.len < size) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"recv_ack: %s: Ack too small (%d < %d)\",\n\t\t    what, ctl.len, size);\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (ctl.len);\n}\n\nstatic char *\ndlstrerror(char *errbuf, size_t errbufsize, bpf_u_int32 dl_errno)\n{\n\tswitch (dl_errno) {\n\n\tcase DL_ACCESS:\n\t\treturn (\"Improper permissions for request\");\n\n\tcase DL_BADADDR:\n\t\treturn (\"DLSAP addr in improper format or invalid\");\n\n\tcase DL_BADCORR:\n\t\treturn (\"Seq number not from outstand DL_CONN_IND\");\n\n\tcase DL_BADDATA:\n\t\treturn (\"User data exceeded provider limit\");\n\n\tcase DL_BADPPA:\n#ifdef HAVE_DEV_DLPI\n\t\t/*\n\t\t * With a single \"/dev/dlpi\" device used for all\n\t\t * DLPI providers, PPAs have nothing to do with\n\t\t * unit numbers.\n\t\t */\n\t\treturn (\"Specified PPA was invalid\");\n#else\n\t\t/*\n\t\t * We have separate devices for separate devices;\n\t\t * the PPA is just the unit number.\n\t\t */\n\t\treturn (\"Specified PPA (device unit) was invalid\");\n#endif\n\n\tcase DL_BADPRIM:\n\t\treturn (\"Primitive received not known by provider\");\n\n\tcase DL_BADQOSPARAM:\n\t\treturn (\"QOS parameters contained invalid values\");\n\n\tcase DL_BADQOSTYPE:\n\t\treturn (\"QOS structure type is unknown/unsupported\");\n\n\tcase DL_BADSAP:\n\t\treturn (\"Bad LSAP selector\");\n\n\tcase DL_BADTOKEN:\n\t\treturn (\"Token used not an active stream\");\n\n\tcase DL_BOUND:\n\t\treturn (\"Attempted second bind with dl_max_conind\");\n\n\tcase DL_INITFAILED:\n\t\treturn (\"Physical link initialization failed\");\n\n\tcase DL_NOADDR:\n\t\treturn (\"Provider couldn't allocate alternate address\");\n\n\tcase DL_NOTINIT:\n\t\treturn (\"Physical link not initialized\");\n\n\tcase DL_OUTSTATE:\n\t\treturn (\"Primitive issued in improper state\");\n\n\tcase DL_SYSERR:\n\t\treturn (\"UNIX system error occurred\");\n\n\tcase DL_UNSUPPORTED:\n\t\treturn (\"Requested service not supplied by provider\");\n\n\tcase DL_UNDELIVERABLE:\n\t\treturn (\"Previous data unit could not be delivered\");\n\n\tcase DL_NOTSUPPORTED:\n\t\treturn (\"Primitive is known but not supported\");\n\n\tcase DL_TOOMANY:\n\t\treturn (\"Limit exceeded\");\n\n\tcase DL_NOTENAB:\n\t\treturn (\"Promiscuous mode not enabled\");\n\n\tcase DL_BUSY:\n\t\treturn (\"Other streams for PPA in post-attached\");\n\n\tcase DL_NOAUTO:\n\t\treturn (\"Automatic handling XID&TEST not supported\");\n\n\tcase DL_NOXIDAUTO:\n\t\treturn (\"Automatic handling of XID not supported\");\n\n\tcase DL_NOTESTAUTO:\n\t\treturn (\"Automatic handling of TEST not supported\");\n\n\tcase DL_XIDAUTO:\n\t\treturn (\"Automatic handling of XID response\");\n\n\tcase DL_TESTAUTO:\n\t\treturn (\"Automatic handling of TEST response\");\n\n\tcase DL_PENDING:\n\t\treturn (\"Pending outstanding connect indications\");\n\n\tdefault:\n\t\tsnprintf(errbuf, errbufsize, \"Error %02x\", dl_errno);\n\t\treturn (errbuf);\n\t}\n}\n\nstatic char *\ndlprim(char *primbuf, size_t primbufsize, bpf_u_int32 prim)\n{\n\tswitch (prim) {\n\n\tcase DL_INFO_REQ:\n\t\treturn (\"DL_INFO_REQ\");\n\n\tcase DL_INFO_ACK:\n\t\treturn (\"DL_INFO_ACK\");\n\n\tcase DL_ATTACH_REQ:\n\t\treturn (\"DL_ATTACH_REQ\");\n\n\tcase DL_DETACH_REQ:\n\t\treturn (\"DL_DETACH_REQ\");\n\n\tcase DL_BIND_REQ:\n\t\treturn (\"DL_BIND_REQ\");\n\n\tcase DL_BIND_ACK:\n\t\treturn (\"DL_BIND_ACK\");\n\n\tcase DL_UNBIND_REQ:\n\t\treturn (\"DL_UNBIND_REQ\");\n\n\tcase DL_OK_ACK:\n\t\treturn (\"DL_OK_ACK\");\n\n\tcase DL_ERROR_ACK:\n\t\treturn (\"DL_ERROR_ACK\");\n\n\tcase DL_SUBS_BIND_REQ:\n\t\treturn (\"DL_SUBS_BIND_REQ\");\n\n\tcase DL_SUBS_BIND_ACK:\n\t\treturn (\"DL_SUBS_BIND_ACK\");\n\n\tcase DL_UNITDATA_REQ:\n\t\treturn (\"DL_UNITDATA_REQ\");\n\n\tcase DL_UNITDATA_IND:\n\t\treturn (\"DL_UNITDATA_IND\");\n\n\tcase DL_UDERROR_IND:\n\t\treturn (\"DL_UDERROR_IND\");\n\n\tcase DL_UDQOS_REQ:\n\t\treturn (\"DL_UDQOS_REQ\");\n\n\tcase DL_CONNECT_REQ:\n\t\treturn (\"DL_CONNECT_REQ\");\n\n\tcase DL_CONNECT_IND:\n\t\treturn (\"DL_CONNECT_IND\");\n\n\tcase DL_CONNECT_RES:\n\t\treturn (\"DL_CONNECT_RES\");\n\n\tcase DL_CONNECT_CON:\n\t\treturn (\"DL_CONNECT_CON\");\n\n\tcase DL_TOKEN_REQ:\n\t\treturn (\"DL_TOKEN_REQ\");\n\n\tcase DL_TOKEN_ACK:\n\t\treturn (\"DL_TOKEN_ACK\");\n\n\tcase DL_DISCONNECT_REQ:\n\t\treturn (\"DL_DISCONNECT_REQ\");\n\n\tcase DL_DISCONNECT_IND:\n\t\treturn (\"DL_DISCONNECT_IND\");\n\n\tcase DL_RESET_REQ:\n\t\treturn (\"DL_RESET_REQ\");\n\n\tcase DL_RESET_IND:\n\t\treturn (\"DL_RESET_IND\");\n\n\tcase DL_RESET_RES:\n\t\treturn (\"DL_RESET_RES\");\n\n\tcase DL_RESET_CON:\n\t\treturn (\"DL_RESET_CON\");\n\n\tdefault:\n\t\tsnprintf(primbuf, primbufsize, \"unknown primitive 0x%x\",\n\t\t    prim);\n\t\treturn (primbuf);\n\t}\n}\n\nstatic int\ndlbindreq(int fd, bpf_u_int32 sap, char *ebuf)\n{\n\n\tdl_bind_req_t\treq;\n\n\tmemset((char *)&req, 0, sizeof(req));\n\treq.dl_primitive = DL_BIND_REQ;\n\t/* XXX - what if neither of these are defined? */\n#if defined(DL_HP_RAWDLS)\n\treq.dl_max_conind = 1;\t\t\t/* XXX magic number */\n\treq.dl_service_mode = DL_HP_RAWDLS;\n#elif defined(DL_CLDLS)\n\treq.dl_service_mode = DL_CLDLS;\n#endif\n\treq.dl_sap = sap;\n\n\treturn (send_request(fd, (char *)&req, sizeof(req), \"bind\", ebuf));\n}\n\nstatic int\ndlbindack(int fd, char *bufp, char *ebuf, int *uerror)\n{\n\n\treturn (recv_ack(fd, DL_BIND_ACK_SIZE, \"bind\", bufp, ebuf, uerror));\n}\n\nstatic int\ndlokack(int fd, const char *what, char *bufp, char *ebuf, int *uerror)\n{\n\n\treturn (recv_ack(fd, DL_OK_ACK_SIZE, what, bufp, ebuf, uerror));\n}\n\n\nstatic int\ndlinforeq(int fd, char *ebuf)\n{\n\tdl_info_req_t req;\n\n\treq.dl_primitive = DL_INFO_REQ;\n\n\treturn (send_request(fd, (char *)&req, sizeof(req), \"info\", ebuf));\n}\n\nstatic int\ndlinfoack(int fd, char *bufp, char *ebuf)\n{\n\n\treturn (recv_ack(fd, DL_INFO_ACK_SIZE, \"info\", bufp, ebuf, NULL));\n}\n\n#ifdef HAVE_DL_PASSIVE_REQ_T\n/*\n * Enable DLPI passive mode. We do not care if this request fails, as this\n * indicates the underlying DLPI device does not support link aggregation.\n */\nstatic void\ndlpassive(int fd, char *ebuf)\n{\n\tdl_passive_req_t req;\n\tbpf_u_int32 buf[MAXDLBUF];\n\n\treq.dl_primitive = DL_PASSIVE_REQ;\n\n\tif (send_request(fd, (char *)&req, sizeof(req), \"dlpassive\", ebuf) == 0)\n\t    (void) dlokack(fd, \"dlpassive\", (char *)buf, ebuf, NULL);\n}\n#endif\n\n#ifdef DL_HP_RAWDLS\n/*\n * There's an ack *if* there's an error.\n */\nstatic int\ndlrawdatareq(int fd, const u_char *datap, int datalen)\n{\n\tstruct strbuf ctl, data;\n\tlong buf[MAXDLBUF];\t/* XXX - char? */\n\tunion DL_primitives *dlp;\n\tint dlen;\n\n\tdlp = MAKE_DL_PRIMITIVES(buf);\n\n\tdlp->dl_primitive = DL_HP_RAWDATA_REQ;\n\tdlen = DL_HP_RAWDATA_REQ_SIZE;\n\n\t/*\n\t * HP's documentation doesn't appear to show us supplying any\n\t * address pointed to by the control part of the message.\n\t * I think that's what raw mode means - you just send the raw\n\t * packet, you don't specify where to send it to, as that's\n\t * implied by the destination address.\n\t */\n\tctl.maxlen = 0;\n\tctl.len = dlen;\n\tctl.buf = (void *)buf;\n\n\tdata.maxlen = 0;\n\tdata.len = datalen;\n\tdata.buf = (void *)datap;\n\n\treturn (putmsg(fd, &ctl, &data, 0));\n}\n#endif /* DL_HP_RAWDLS */\n\n#ifdef DL_HP_PPA_REQ\n/*\n * Under HP-UX 10 and HP-UX 11, we can ask for the ppa\n */\n\n\n/*\n * Determine ppa number that specifies ifname.\n *\n * If the \"dl_hp_ppa_info_t\" doesn't have a \"dl_module_id_1\" member,\n * the code that's used here is the old code for HP-UX 10.x.\n *\n * However, HP-UX 10.20, at least, appears to have such a member\n * in its \"dl_hp_ppa_info_t\" structure, so the new code is used.\n * The new code didn't work on an old 10.20 system on which Rick\n * Jones of HP tried it, but with later patches installed, it\n * worked - it appears that the older system had those members but\n * didn't put anything in them, so, if the search by name fails, we\n * do the old search.\n *\n * Rick suggests that making sure your system is \"up on the latest\n * lancommon/DLPI/driver patches\" is probably a good idea; it'd fix\n * that problem, as well as allowing libpcap to see packets sent\n * from the system on which the libpcap application is being run.\n * (On 10.20, in addition to getting the latest patches, you need\n * to turn the kernel \"lanc_outbound_promisc_flag\" flag on with ADB;\n * a posting to \"comp.sys.hp.hpux\" at\n *\n *\thttp://www.deja.com/[ST_rn=ps]/getdoc.xp?AN=558092266\n *\n * says that, to see the machine's outgoing traffic, you'd need to\n * apply the right patches to your system, and also set that variable\n * with:\n\necho 'lanc_outbound_promisc_flag/W1' | /usr/bin/adb -w /stand/vmunix /dev/kmem\n\n * which could be put in, for example, \"/sbin/init.d/lan\".\n *\n * Setting the variable is not necessary on HP-UX 11.x.\n */\nstatic int\nget_dlpi_ppa(register int fd, register const char *device, register u_int unit,\n    u_int *ppa, register char *ebuf)\n{\n\tregister dl_hp_ppa_ack_t *ap;\n\tregister dl_hp_ppa_info_t *ipstart, *ip;\n\tregister u_int i;\n\tchar dname[100];\n\tregister u_long majdev;\n\tstruct stat statbuf;\n\tdl_hp_ppa_req_t\treq;\n\tchar buf[MAXDLBUF];\n\tchar *ppa_data_buf;\n\tdl_hp_ppa_ack_t\t*dlp;\n\tstruct strbuf ctl;\n\tint flags;\n\n\tmemset((char *)&req, 0, sizeof(req));\n\treq.dl_primitive = DL_HP_PPA_REQ;\n\n\tmemset((char *)buf, 0, sizeof(buf));\n\tif (send_request(fd, (char *)&req, sizeof(req), \"hpppa\", ebuf) < 0)\n\t\treturn (PCAP_ERROR);\n\n\tctl.maxlen = DL_HP_PPA_ACK_SIZE;\n\tctl.len = 0;\n\tctl.buf = (char *)buf;\n\n\tflags = 0;\n\t/*\n\t * DLPI may return a big chunk of data for a DL_HP_PPA_REQ. The normal\n\t * recv_ack will fail because it set the maxlen to MAXDLBUF (8192)\n\t * which is NOT big enough for a DL_HP_PPA_REQ.\n\t *\n\t * This causes libpcap applications to fail on a system with HP-APA\n\t * installed.\n\t *\n\t * To figure out how big the returned data is, we first call getmsg\n\t * to get the small head and peek at the head to get the actual data\n\t * length, and  then issue another getmsg to get the actual PPA data.\n\t */\n\t/* get the head first */\n\tif (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa getmsg\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (ctl.len == -1) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa getmsg: control buffer has no data\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tdlp = (dl_hp_ppa_ack_t *)ctl.buf;\n\tif (dlp->dl_primitive != DL_HP_PPA_ACK) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa unexpected primitive ack 0x%x\",\n\t\t    (bpf_u_int32)dlp->dl_primitive);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif ((size_t)ctl.len < DL_HP_PPA_ACK_SIZE) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa ack too small (%d < %lu)\",\n\t\t     ctl.len, (unsigned long)DL_HP_PPA_ACK_SIZE);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/* allocate buffer */\n\tif ((ppa_data_buf = (char *)malloc(dlp->dl_length)) == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa malloc\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tctl.maxlen = dlp->dl_length;\n\tctl.len = 0;\n\tctl.buf = (char *)ppa_data_buf;\n\t/* get the data */\n\tif (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa getmsg\");\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (ctl.len == -1) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa getmsg: control buffer has no data\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tif ((u_int)ctl.len < dlp->dl_length) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa ack too small (%d < %lu)\",\n\t\t    ctl.len, (unsigned long)dlp->dl_length);\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tap = (dl_hp_ppa_ack_t *)buf;\n\tipstart = (dl_hp_ppa_info_t *)ppa_data_buf;\n\tip = ipstart;\n\n#ifdef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1\n\t/*\n\t * The \"dl_hp_ppa_info_t\" structure has a \"dl_module_id_1\"\n\t * member that should, in theory, contain the part of the\n\t * name for the device that comes before the unit number,\n\t * and should also have a \"dl_module_id_2\" member that may\n\t * contain an alternate name (e.g., I think Ethernet devices\n\t * have both \"lan\", for \"lanN\", and \"snap\", for \"snapN\", with\n\t * the former being for Ethernet packets and the latter being\n\t * for 802.3/802.2 packets).\n\t *\n\t * Search for the device that has the specified name and\n\t * instance number.\n\t */\n\tfor (i = 0; i < ap->dl_count; i++) {\n\t\tif ((strcmp((const char *)ip->dl_module_id_1, device) == 0 ||\n\t\t     strcmp((const char *)ip->dl_module_id_2, device) == 0) &&\n\t\t    ip->dl_instance_num == unit)\n\t\t\tbreak;\n\n\t\tip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);\n\t}\n#else\n\t/*\n\t * We don't have that member, so the search is impossible; make it\n\t * look as if the search failed.\n\t */\n\ti = ap->dl_count;\n#endif\n\n\tif (i == ap->dl_count) {\n\t\t/*\n\t\t * Well, we didn't, or can't, find the device by name.\n\t\t *\n\t\t * HP-UX 10.20, whilst it has \"dl_module_id_1\" and\n\t\t * \"dl_module_id_2\" fields in the \"dl_hp_ppa_info_t\",\n\t\t * doesn't seem to fill them in unless the system is\n\t\t * at a reasonably up-to-date patch level.\n\t\t *\n\t\t * Older HP-UX 10.x systems might not have those fields\n\t\t * at all.\n\t\t *\n\t\t * Therefore, we'll search for the entry with the major\n\t\t * device number of a device with the name \"/dev/<dev><unit>\",\n\t\t * if such a device exists, as the old code did.\n\t\t */\n\t\tsnprintf(dname, sizeof(dname), \"/dev/%s%u\", device, unit);\n\t\tif (stat(dname, &statbuf) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"stat: %s\", dname);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tmajdev = major(statbuf.st_rdev);\n\n\t\tip = ipstart;\n\n\t\tfor (i = 0; i < ap->dl_count; i++) {\n\t\t\tif (ip->dl_mjr_num == majdev &&\n\t\t\t    ip->dl_instance_num == unit)\n\t\t\t\tbreak;\n\n\t\t\tip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);\n\t\t}\n\t}\n\tif (i == ap->dl_count) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"can't find /dev/dlpi PPA for %s%u\", device, unit);\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\tif (ip->dl_hdw_state == HDW_DEAD) {\n\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s%d: hardware state: DOWN\\n\", device, unit);\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\t*ppa = ip->dl_ppa;\n\tfree(ppa_data_buf);\n\treturn (0);\n}\n#endif\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd;\n#endif\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_dlpi);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n#ifdef DL_HP_RAWDLS\n\tpd = p->priv;\n\tpd->send_fd = -1;\t/* it hasn't been opened yet */\n#endif\n\n\tp->activate_op = pcap_activate_dlpi;\n\treturn (p);\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}\n"
        },
        {
          "name": "pcap-dpdk.c",
          "type": "blob",
          "size": 31.5908203125,
          "content": "/*\n * Copyright (C) 2018 jingle YANG. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   1. Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in the\n *      documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\nDate: Dec 16, 2018\n\nDescription:\n1. Pcap-dpdk provides libpcap the ability to use DPDK with the device name as dpdk:{portid}, such as dpdk:0.\n2. DPDK is a set of libraries and drivers for fast packet processing. (https://www.dpdk.org/)\n3. The testprogs/capturetest provides 6.4Gbps/800,000 pps on Intel 10-Gigabit X540-AT2 with DPDK 18.11.\n\nLimitations:\n1. DPDK support will be on if DPDK is available. Please set DIR for --with-dpdk[=DIR] with ./configure or -DDPDK_DIR[=DIR] with cmake if DPDK is installed manually.\n2. Only support link libdpdk.so dynamically, because the libdpdk.a will not work correctly.\n3. Only support read operation, and packet injection has not been supported yet.\n\nUsage:\n1. Compile DPDK as shared library and install.(https://github.com/DPDK/dpdk.git)\n\nYou shall modify the file $RTE_SDK/$RTE_TARGET/.config and set:\nCONFIG_RTE_BUILD_SHARED_LIB=y\nBy the following command:\nsed -i 's/CONFIG_RTE_BUILD_SHARED_LIB=n/CONFIG_RTE_BUILD_SHARED_LIB=y/' $RTE_SDK/$RTE_TARGET/.config\n\n2. Launch l2fwd that is one of DPDK examples correctly, and get device information.\n\nYou shall learn how to bind nic with DPDK-compatible driver by $RTE_SDK/usertools/dpdk-devbind.py, such as igb_uio.\nAnd enable hugepages by dpdk-setup.sh\n\nThen launch the l2fwd with dynamic driver support. For example:\n$RTE_SDK/examples/l2fwd/$RTE_TARGET/l2fwd -dlibrte_pmd_e1000.so -dlibrte_pmd_ixgbe.so -dlibrte_mempool_ring.so -- -p 0x1\n\n3. Compile libpcap with dpdk options.\n\nIf DPDK has not been found automatically, you shall export DPDK environment variable which are used for compiling DPDK. And then pass $RTE_SDK/$RTE_TARGET to --with-dpdk or -DDPDK_DIR\n\nexport RTE_SDK={your DPDK base directory}\nexport RTE_TARGET={your target name}\n\n3.1 With configure\n\n./configure --with-dpdk=$RTE_SDK/$RTE_TARGET && make -s all && make -s testprogs && make install\n\n3.2 With cmake\n\nmkdir -p build && cd build && cmake -DDPDK_DIR=$RTE_SDK/$RTE_TARGET ../ && make -s all && make -s testprogs && make install\n\n4. Link your own program with libpcap, and use DPDK with the device name as dpdk:{portid}, such as dpdk:0.\nAnd you shall set DPDK configure options by environment variable DPDK_CFG\nFor example, the testprogs/capturetest could be launched by:\n\nenv DPDK_CFG=\"--log-level=debug -l0 -dlibrte_pmd_e1000.so -dlibrte_pmd_ixgbe.so -dlibrte_mempool_ring.so\" ./capturetest -i dpdk:0\n*/\n\n#include <config.h>\n\n#include <errno.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h> /* for INT_MAX */\n#include <time.h>\n\n#include <sys/time.h>\n\n//header for calling dpdk\n#include <rte_config.h>\n#include <rte_common.h>\n#include <rte_errno.h>\n#include <rte_log.h>\n#include <rte_malloc.h>\n#include <rte_memory.h>\n#include <rte_eal.h>\n#include <rte_launch.h>\n#include <rte_atomic.h>\n#include <rte_cycles.h>\n#include <rte_lcore.h>\n#include <rte_per_lcore.h>\n#include <rte_branch_prediction.h>\n#include <rte_interrupts.h>\n#include <rte_random.h>\n#include <rte_debug.h>\n#include <rte_ether.h>\n#include <rte_ethdev.h>\n#include <rte_mempool.h>\n#include <rte_mbuf.h>\n#include <rte_bus.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-dpdk.h\"\n\n/*\n * Deal with API changes that break source compatibility.\n */\n\n#ifdef HAVE_STRUCT_RTE_ETHER_ADDR\n#define ETHER_ADDR_TYPE\tstruct rte_ether_addr\n#else\n#define ETHER_ADDR_TYPE\tstruct ether_addr\n#endif\n\n#define DPDK_DEF_LOG_LEV RTE_LOG_ERR\n//\n// This is set to 0 if we haven't initialized DPDK yet, 1 if we've\n// successfully initialized it, a negative value, which is the negative\n// of the rte_errno from rte_eal_init(), if we tried to initialize it\n// and got an error.\n//\nstatic int is_dpdk_pre_inited=0;\n#define DPDK_LIB_NAME \"libpcap_dpdk\"\n#define DPDK_DESC \"Data Plane Development Kit (DPDK) Interface\"\n#define DPDK_ERR_PERM_MSG \"permission denied, DPDK needs root permission\"\n#define DPDK_ARGC_MAX 64\n#define DPDK_CFG_MAX_LEN 1024\n#define DPDK_DEV_NAME_MAX 32\n#define DPDK_DEV_DESC_MAX 512\n#define DPDK_CFG_ENV_NAME \"DPDK_CFG\"\n#define DPDK_DEF_MIN_SLEEP_MS 1\nstatic char dpdk_cfg_buf[DPDK_CFG_MAX_LEN];\n#define DPDK_MAC_ADDR_SIZE 32\n#define DPDK_DEF_MAC_ADDR \"00:00:00:00:00:00\"\n#define DPDK_PCI_ADDR_SIZE 16\n#define DPDK_DEF_CFG \"--log-level=error -l0 -dlibrte_pmd_e1000.so -dlibrte_pmd_ixgbe.so -dlibrte_mempool_ring.so\"\n#define DPDK_PREFIX \"dpdk:\"\n#define DPDK_PORTID_MAX 65535U\n#define MBUF_POOL_NAME \"mbuf_pool\"\n#define DPDK_TX_BUF_NAME \"tx_buffer\"\n//The number of elements in the mbuf pool.\n#define DPDK_NB_MBUFS 8192U\n#define MEMPOOL_CACHE_SIZE 256\n#define MAX_PKT_BURST 32\n// Configurable number of RX/TX ring descriptors\n#define RTE_TEST_RX_DESC_DEFAULT 1024\n#define RTE_TEST_TX_DESC_DEFAULT 1024\n\nstatic uint16_t nb_rxd = RTE_TEST_RX_DESC_DEFAULT;\nstatic uint16_t nb_txd = RTE_TEST_TX_DESC_DEFAULT;\n\n#ifdef RTE_ETHER_MAX_JUMBO_FRAME_LEN\n#define RTE_ETH_PCAP_SNAPLEN RTE_ETHER_MAX_JUMBO_FRAME_LEN\n#else\n#define RTE_ETH_PCAP_SNAPLEN ETHER_MAX_JUMBO_FRAME_LEN\n#endif\n\nstatic struct rte_eth_dev_tx_buffer *tx_buffer;\n\nstruct dpdk_ts_helper{\n\tstruct timeval start_time;\n\tuint64_t start_cycles;\n\tuint64_t hz;\n};\nstruct pcap_dpdk{\n\tpcap_t * orig;\n\tuint16_t portid; // portid of DPDK\n\tint must_clear_promisc;\n\tuint64_t bpf_drop;\n\tint nonblock;\n\tstruct timeval required_select_timeout;\n\tstruct timeval prev_ts;\n\tstruct rte_eth_stats prev_stats;\n\tstruct timeval curr_ts;\n\tstruct rte_eth_stats curr_stats;\n\tuint64_t pps;\n\tuint64_t bps;\n\tstruct rte_mempool * pktmbuf_pool;\n\tstruct dpdk_ts_helper ts_helper;\n\tETHER_ADDR_TYPE eth_addr;\n\tchar mac_addr[DPDK_MAC_ADDR_SIZE];\n\tchar pci_addr[DPDK_PCI_ADDR_SIZE];\n\tunsigned char pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN];\n};\n\nstatic struct rte_eth_conf port_conf = {\n\t.rxmode = {\n\t\t.split_hdr_size = 0,\n\t},\n\t.txmode = {\n\t\t.mq_mode = ETH_MQ_TX_NONE,\n\t},\n};\n\nstatic void\tdpdk_fmt_errmsg_for_rte_errno(char *, size_t, int,\n    PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);\n\n/*\n * Generate an error message based on a format, arguments, and an\n * rte_errno, with a message for the rte_errno after the formatted output.\n */\nstatic void dpdk_fmt_errmsg_for_rte_errno(char *errbuf, size_t errbuflen,\n    int errnum, const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n\n\tva_start(ap, fmt);\n\tvsnprintf(errbuf, errbuflen, fmt, ap);\n\tva_end(ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\tmsglen += 2;\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t * rte_strerror() is thread-safe, at least as of dpdk 18.11,\n\t * unlike strerror() - it uses strerror_r() rather than strerror()\n\t * for UN*X errno values, and prints to what I assume is a per-thread\n\t * buffer (based on the \"PER_LCORE\" in \"RTE_DEFINE_PER_LCORE\" used\n\t * to declare the buffers statically) for DPDK errors.\n\t */\n\tsnprintf(p, errbuflen_remaining, \"%s\", rte_strerror(errnum));\n}\n\nstatic int dpdk_init_timer(struct pcap_dpdk *pd){\n\tgettimeofday(&(pd->ts_helper.start_time),NULL);\n\tpd->ts_helper.start_cycles = rte_get_timer_cycles();\n\tpd->ts_helper.hz = rte_get_timer_hz();\n\tif (pd->ts_helper.hz == 0){\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic inline void calculate_timestamp(struct dpdk_ts_helper *helper,struct timeval *ts)\n{\n\tuint64_t cycles;\n\t// delta\n\tstruct timeval cur_time;\n\tcycles = rte_get_timer_cycles() - helper->start_cycles;\n\tcur_time.tv_sec = (time_t)(cycles/helper->hz);\n\tcur_time.tv_usec = (suseconds_t)((cycles%helper->hz)*1e6/helper->hz);\n\ttimeradd(&(helper->start_time), &cur_time, ts);\n}\n\nstatic uint32_t dpdk_gather_data(unsigned char *data, uint32_t len, struct rte_mbuf *mbuf)\n{\n\tuint32_t total_len = 0;\n\twhile (mbuf && (total_len+mbuf->data_len) < len ){\n\t\trte_memcpy(data+total_len, rte_pktmbuf_mtod(mbuf,void *),mbuf->data_len);\n\t\ttotal_len+=mbuf->data_len;\n\t\tmbuf=mbuf->next;\n\t}\n\treturn total_len;\n}\n\n\nstatic int dpdk_read_with_timeout(pcap_t *p, struct rte_mbuf **pkts_burst, const uint16_t burst_cnt){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tint nb_rx = 0;\n\tint timeout_ms = p->opt.timeout;\n\tint sleep_ms = 0;\n\tif (pd->nonblock){\n\t\t// In non-blocking mode, just read once, no matter how many packets are captured.\n\t\tnb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);\n\t}else{\n\t\t// In blocking mode, read many times until packets are captured or timeout or break_loop is set.\n\t\t// if timeout_ms == 0, it may be blocked forever.\n\t\twhile (timeout_ms == 0 || sleep_ms < timeout_ms){\n\t\t\tnb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);\n\t\t\tif (nb_rx){ // got packets within timeout_ms\n\t\t\t\tbreak;\n\t\t\t}else{ // no packet arrives at this round.\n\t\t\t\tif (p->break_loop){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// sleep for a very short while.\n\t\t\t\t// block sleep is the only choice, since usleep() will impact performance dramatically.\n\t\t\t\trte_delay_us_block(DPDK_DEF_MIN_SLEEP_MS*1000);\n\t\t\t\tsleep_ms += DPDK_DEF_MIN_SLEEP_MS;\n\t\t\t}\n\t\t}\n\t}\n\treturn nb_rx;\n}\n\nstatic int pcap_dpdk_dispatch(pcap_t *p, int max_cnt, pcap_handler cb, u_char *cb_arg)\n{\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tint burst_cnt = 0;\n\tint nb_rx = 0;\n\tstruct rte_mbuf *pkts_burst[MAX_PKT_BURST];\n\tstruct rte_mbuf *m;\n\tstruct pcap_pkthdr pcap_header;\n\t// In DPDK, pkt_len is sum of lengths for all segments. And data_len is for one segment\n\tuint32_t pkt_len = 0;\n\tuint32_t caplen = 0;\n\tu_char *bp = NULL;\n\tint i=0;\n\tunsigned int gather_len =0;\n\tint pkt_cnt = 0;\n\tu_char *large_buffer=NULL;\n\tint timeout_ms = p->opt.timeout;\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(max_cnt))\n\t\tmax_cnt = INT_MAX;\n\n\tif (max_cnt < MAX_PKT_BURST){\n\t\tburst_cnt = max_cnt;\n\t}else{\n\t\tburst_cnt = MAX_PKT_BURST;\n\t}\n\n\twhile( pkt_cnt < max_cnt){\n\t\tif (p->break_loop){\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\t// read once in non-blocking mode, or try many times waiting for timeout_ms.\n\t\t// if timeout_ms == 0, it will be blocked until one packet arrives or break_loop is set.\n\t\tnb_rx = dpdk_read_with_timeout(p, pkts_burst, burst_cnt);\n\t\tif (nb_rx == 0){\n\t\t\tif (pd->nonblock){\n\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available in non-blocking mode.\\n\");\n\t\t\t}else{\n\t\t\t\tif (p->break_loop){\n\t\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available and break_loop is set in blocking mode.\\n\");\n\t\t\t\t\tp->break_loop = 0;\n\t\t\t\t\treturn PCAP_ERROR_BREAK;\n\n\t\t\t\t}\n\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available for timeout %d ms in blocking mode.\\n\", timeout_ms);\n\t\t\t}\n\t\t\t// break if dpdk reads 0 packet, no matter in blocking(timeout) or non-blocking mode.\n\t\t\tbreak;\n\t\t}\n\t\tpkt_cnt += nb_rx;\n\t\tfor ( i = 0; i < nb_rx; i++) {\n\t\t\tm = pkts_burst[i];\n\t\t\tcalculate_timestamp(&(pd->ts_helper),&(pcap_header.ts));\n\t\t\tpkt_len = rte_pktmbuf_pkt_len(m);\n\t\t\t// caplen = min(pkt_len, p->snapshot);\n\t\t\t// caplen will not be changed, no matter how long the rte_pktmbuf\n\t\t\tcaplen = pkt_len < (uint32_t)p->snapshot ? pkt_len: (uint32_t)p->snapshot;\n\t\t\tpcap_header.caplen = caplen;\n\t\t\tpcap_header.len = pkt_len;\n\t\t\t// volatile prefetch\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\tbp = NULL;\n\t\t\tif (m->nb_segs == 1)\n\t\t\t{\n\t\t\t\tbp = rte_pktmbuf_mtod(m, u_char *);\n\t\t\t}else{\n\t\t\t\t// use fast buffer pcap_tmp_buf if pkt_len is small, no need to call malloc and free\n\t\t\t\tif ( pkt_len <= RTE_ETH_PCAP_SNAPLEN)\n\t\t\t\t{\n\t\t\t\t\tgather_len = dpdk_gather_data(pd->pcap_tmp_buf, RTE_ETH_PCAP_SNAPLEN, m);\n\t\t\t\t\tbp = pd->pcap_tmp_buf;\n\t\t\t\t}else{\n\t\t\t\t\t// need call free later\n\t\t\t\t\tlarge_buffer = (u_char *)malloc(caplen*sizeof(u_char));\n\t\t\t\t\tgather_len = dpdk_gather_data(large_buffer, caplen, m);\n\t\t\t\t\tbp = large_buffer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (bp){\n\t\t\t\tif (p->fcode.bf_insns==NULL || pcapint_filter(p->fcode.bf_insns, bp, pcap_header.len, pcap_header.caplen)){\n\t\t\t\t\tcb(cb_arg, &pcap_header, bp);\n\t\t\t\t}else{\n\t\t\t\t\tpd->bpf_drop++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//free all pktmbuf\n\t\t\trte_pktmbuf_free(m);\n\t\t\tif (large_buffer){\n\t\t\t\tfree(large_buffer);\n\t\t\t\tlarge_buffer=NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn pkt_cnt;\n}\n\nstatic int pcap_dpdk_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\t//not implemented yet\n\tpcapint_strlcpy(p->errbuf,\n\t    \"dpdk error: Inject function has not been implemented yet\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn PCAP_ERROR;\n}\n\nstatic void pcap_dpdk_close(pcap_t *p)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tif (pd==NULL)\n\t{\n\t\treturn;\n\t}\n\tif (pd->must_clear_promisc)\n\t{\n\t\trte_eth_promiscuous_disable(pd->portid);\n\t}\n\trte_eth_dev_stop(pd->portid);\n\trte_eth_dev_close(pd->portid);\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic void nic_stats_display(struct pcap_dpdk *pd)\n{\n\tuint16_t portid = pd->portid;\n\tstruct rte_eth_stats stats;\n\trte_eth_stats_get(portid, &stats);\n\tRTE_LOG(INFO,USER1, \"portid:%d, RX-packets: %-10\"PRIu64\"  RX-errors:  %-10\"PRIu64\n\t       \"  RX-bytes:  %-10\"PRIu64\"  RX-Imissed:  %-10\"PRIu64\"\\n\", portid, stats.ipackets, stats.ierrors,\n\t       stats.ibytes,stats.imissed);\n\tRTE_LOG(INFO,USER1, \"portid:%d, RX-PPS: %-10\"PRIu64\" RX-Mbps: %.2lf\\n\", portid, pd->pps, pd->bps/1e6f );\n}\n\nstatic int pcap_dpdk_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tcalculate_timestamp(&(pd->ts_helper), &(pd->curr_ts));\n\trte_eth_stats_get(pd->portid,&(pd->curr_stats));\n\tif (ps){\n\t\tps->ps_recv = pd->curr_stats.ipackets;\n\t\tps->ps_drop = pd->curr_stats.ierrors;\n\t\tps->ps_drop += pd->bpf_drop;\n\t\tps->ps_ifdrop = pd->curr_stats.imissed;\n\t}\n\tuint64_t delta_pkt = pd->curr_stats.ipackets - pd->prev_stats.ipackets;\n\tstruct timeval delta_tm;\n\ttimersub(&(pd->curr_ts),&(pd->prev_ts), &delta_tm);\n\tuint64_t delta_usec = delta_tm.tv_sec*1e6+delta_tm.tv_usec;\n\tuint64_t delta_bit = (pd->curr_stats.ibytes-pd->prev_stats.ibytes)*8;\n\tRTE_LOG(DEBUG, USER1, \"delta_usec: %-10\"PRIu64\" delta_pkt: %-10\"PRIu64\" delta_bit: %-10\"PRIu64\"\\n\", delta_usec, delta_pkt, delta_bit);\n\tpd->pps = (uint64_t)(delta_pkt*1e6f/delta_usec);\n\tpd->bps = (uint64_t)(delta_bit*1e6f/delta_usec);\n\tnic_stats_display(pd);\n\tpd->prev_stats = pd->curr_stats;\n\tpd->prev_ts = pd->curr_ts;\n\treturn 0;\n}\n\nstatic int pcap_dpdk_setnonblock(pcap_t *p, int nonblock){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tpd->nonblock = nonblock;\n\treturn 0;\n}\n\nstatic int pcap_dpdk_getnonblock(pcap_t *p){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\treturn pd->nonblock;\n}\nstatic int check_link_status(uint16_t portid, struct rte_eth_link *plink)\n{\n\t// wait up to 9 seconds to get link status\n\trte_eth_link_get(portid, plink);\n\treturn plink->link_status == ETH_LINK_UP;\n}\nstatic void eth_addr_str(ETHER_ADDR_TYPE *addrp, char* mac_str, int len)\n{\n\tint offset=0;\n\tif (addrp == NULL){\n\t\tsnprintf(mac_str, len-1, DPDK_DEF_MAC_ADDR);\n\t\treturn;\n\t}\n\tfor (int i=0; i<6; i++)\n\t{\n\t\tif (offset >= len)\n\t\t{ // buffer overflow\n\t\t\treturn;\n\t\t}\n\t\tif (i==0)\n\t\t{\n\t\t\tsnprintf(mac_str+offset, len-1-offset, \"%02X\",addrp->addr_bytes[i]);\n\t\t\toffset+=2; // FF\n\t\t}else{\n\t\t\tsnprintf(mac_str+offset, len-1-offset, \":%02X\", addrp->addr_bytes[i]);\n\t\t\toffset+=3; // :FF\n\t\t}\n\t}\n\treturn;\n}\n// return portid by device name, otherwise return -1\nstatic uint16_t portid_by_device(char * device)\n{\n\tuint16_t ret = DPDK_PORTID_MAX;\n\tsize_t len = strlen(device);\n\tsize_t prefix_len = strlen(DPDK_PREFIX);\n\tunsigned long ret_ul = 0L;\n\tchar *pEnd;\n\tif (len<=prefix_len || strncmp(device, DPDK_PREFIX, prefix_len)) // check prefix dpdk:\n\t{\n\t\treturn ret;\n\t}\n\t//check all chars are digital\n\tfor (int i=prefix_len; device[i]; i++){\n\t\tif (device[i]<'0' || device[i]>'9'){\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret_ul = strtoul(&(device[prefix_len]), &pEnd, 10);\n\tif (pEnd == &(device[prefix_len]) || *pEnd != '\\0'){\n\t\treturn ret;\n\t}\n\t// too large for portid\n\tif (ret_ul >= DPDK_PORTID_MAX){\n\t\treturn ret;\n\t}\n\tret = (uint16_t)ret_ul;\n\treturn ret;\n}\n\nstatic int parse_dpdk_cfg(char* dpdk_cfg,char** dargv)\n{\n\tint cnt=0;\n\tmemset(dargv,0,sizeof(dargv[0])*DPDK_ARGC_MAX);\n\t//current process name\n\tint skip_space = 1;\n\tint i=0;\n\tRTE_LOG(INFO, USER1,\"dpdk cfg: %s\\n\",dpdk_cfg);\n\t// find first non space char\n\t// The last opt is NULL\n\tfor (i=0;dpdk_cfg[i] && cnt<DPDK_ARGC_MAX-1;i++){\n\t\tif (skip_space && dpdk_cfg[i]!=' '){ // not space\n\t\t\tskip_space=!skip_space; // skip normal char\n\t\t\tdargv[cnt++] = dpdk_cfg+i;\n\t\t}\n\t\tif (!skip_space && dpdk_cfg[i]==' '){ // find a space\n\t\t\tdpdk_cfg[i]=0x00; // end of this opt\n\t\t\tskip_space=!skip_space; // skip space char\n\t\t}\n\t}\n\tdargv[cnt]=NULL;\n\treturn cnt;\n}\n\n// only called once\n// Returns:\n//\n//    1 on success;\n//\n//    0 if \"the EAL cannot initialize on this system\", which we treat as\n//    meaning \"DPDK isn't available\";\n//\n//    a PCAP_ERROR_ code for other errors.\n//\n// If eaccess_not_fatal is non-zero, treat \"a permissions issue\" the way\n// we treat \"the EAL cannot initialize on this system\".  We use that\n// when trying to find DPDK devices, as we don't want to fail to return\n// *any* devices just because we can't support DPDK; when we're trying\n// to open a device, we need to return a permissions error in that case.\nstatic int dpdk_pre_init(char * ebuf, int eaccess_not_fatal)\n{\n\tint dargv_cnt=0;\n\tchar *dargv[DPDK_ARGC_MAX];\n\tchar *ptr_dpdk_cfg = NULL;\n\tint ret;\n\t// global var\n\tif (is_dpdk_pre_inited != 0)\n\t{\n\t\t// already inited; did that succeed?\n\t\tif (is_dpdk_pre_inited < 0)\n\t\t{\n\t\t\t// failed\n\t\t\tgoto error;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// succeeded\n\t\t\treturn 1;\n\t\t}\n\t}\n\t// init EAL\n\tptr_dpdk_cfg = getenv(DPDK_CFG_ENV_NAME);\n\t// set default log level to debug\n\trte_log_set_global_level(DPDK_DEF_LOG_LEV);\n\tif (ptr_dpdk_cfg == NULL)\n\t{\n\t\tRTE_LOG(INFO,USER1,\"env $DPDK_CFG is unset, so using default: %s\\n\",DPDK_DEF_CFG);\n\t\tptr_dpdk_cfg = DPDK_DEF_CFG;\n\t}\n\tmemset(dpdk_cfg_buf,0,sizeof(dpdk_cfg_buf));\n\tsnprintf(dpdk_cfg_buf,DPDK_CFG_MAX_LEN-1,\"%s %s\",DPDK_LIB_NAME,ptr_dpdk_cfg);\n\tdargv_cnt = parse_dpdk_cfg(dpdk_cfg_buf,dargv);\n\tret = rte_eal_init(dargv_cnt,dargv);\n\tif (ret == -1)\n\t{\n\t\t// Indicate that we've called rte_eal_init() by setting\n\t\t// is_dpdk_pre_inited to the negative of the error code,\n\t\t// and process the error.\n\t\tis_dpdk_pre_inited = -rte_errno;\n\t\tgoto error;\n\t}\n\t// init succeeded, so we do not need to do it again later.\n\tis_dpdk_pre_inited = 1;\n\treturn 1;\n\nerror:\n\tswitch (-is_dpdk_pre_inited)\n\t{\n\t\tcase EACCES:\n\t\t\t// This \"indicates a permissions issue.\".\n\t\t\tRTE_LOG(ERR, USER1, \"%s\\n\", DPDK_ERR_PERM_MSG);\n\t\t\t// If we were told to treat this as just meaning\n\t\t\t// DPDK isn't available, do so.\n\t\t\tif (eaccess_not_fatal)\n\t\t\t\treturn 0;\n\t\t\t// Otherwise report a fatal error.\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"DPDK requires that it run as root\");\n\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\n\t\tcase EAGAIN:\n\t\t\t// This \"indicates either a bus or system\n\t\t\t// resource was not available, setup may\n\t\t\t// be attempted again.\"\n\t\t\t// There's no such error in pcap, so I'm\n\t\t\t// not sure what we should do here.\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Bus or system resource was not available\");\n\t\t\tbreak;\n\n\t\tcase EALREADY:\n\t\t\t// This \"indicates that the rte_eal_init\n\t\t\t// function has already been called, and\n\t\t\t// cannot be called again.\"\n\t\t\t// That's not an error; set the \"we've\n\t\t\t// been here before\" flag and return\n\t\t\t// success.\n\t\t\tis_dpdk_pre_inited = 1;\n\t\t\treturn 1;\n\n\t\tcase EFAULT:\n\t\t\t// This \"indicates the tailq configuration\n\t\t\t// name was not found in memory configuration.\"\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The tailq configuration name was not found in the memory configuration\");\n\t\t\treturn PCAP_ERROR;\n\n\t\tcase EINVAL:\n\t\t\t// This \"indicates invalid parameters were\n\t\t\t// passed as argv/argc.\"  Those came from\n\t\t\t// the configuration file.\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The configuration file has invalid parameters\");\n\t\t\tbreak;\n\n\t\tcase ENOMEM:\n\t\t\t// This \"indicates failure likely caused by\n\t\t\t// an out-of-memory condition.\"\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Out of memory\");\n\t\t\tbreak;\n\n\t\tcase ENODEV:\n\t\t\t// This \"indicates memory setup issues.\"\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"An error occurred setting up memory\");\n\t\t\tbreak;\n\n\t\tcase ENOTSUP:\n\t\t\t// This \"indicates that the EAL cannot\n\t\t\t// initialize on this system.\"  We treat\n\t\t\t// that as meaning DPDK isn't available\n\t\t\t// on this machine, rather than as a\n\t\t\t// fatal error, and let our caller decide\n\t\t\t// whether that's a fatal error (if trying\n\t\t\t// to activate a DPDK device) or not (if\n\t\t\t// trying to enumerate devices).\n\t\t\treturn 0;\n\n\t\tcase EPROTO:\n\t\t\t// This \"indicates that the PCI bus is\n\t\t\t// either not present, or is not readable\n\t\t\t// by the eal.\"  Does \"the PCI bus is not\n\t\t\t// present\" mean \"this machine has no PCI\n\t\t\t// bus\", which strikes me as a \"not available\"\n\t\t\t// case?  If so, should \"is not readable by\n\t\t\t// the EAL\" also something we should treat\n\t\t\t// as a \"not available\" case?  If not, we\n\t\t\t// can't distinguish between the two, so\n\t\t\t// we're stuck.\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PCI bus is not present or not readable by the EAL\");\n\t\t\tbreak;\n\n\t\tcase ENOEXEC:\n\t\t\t// This \"indicates that a service core\n\t\t\t// failed to launch successfully.\"\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"A service core failed to launch successfully\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//\n\t\t\t// That's not in the list of errors in\n\t\t\t// the documentation; let it be reported\n\t\t\t// as an error.\n\t\t\t//\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(ebuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -is_dpdk_pre_inited,\n\t\t\t    \"dpdk error: dpdk_pre_init failed\");\n\t\t\tbreak;\n\t}\n\t// Error.\n\treturn PCAP_ERROR;\n}\n\nstatic int pcap_dpdk_activate(pcap_t *p)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tpd->orig = p;\n\tint ret = PCAP_ERROR;\n\tuint16_t nb_ports=0;\n\tuint16_t portid= DPDK_PORTID_MAX;\n\tunsigned nb_mbufs = DPDK_NB_MBUFS;\n\tstruct rte_eth_rxconf rxq_conf;\n\tstruct rte_eth_txconf txq_conf;\n\tstruct rte_eth_conf local_port_conf = port_conf;\n\tstruct rte_eth_dev_info dev_info;\n\tint is_port_up = 0;\n\tstruct rte_eth_link link;\n\tdo{\n\t\t//init EAL; fail if we have insufficient permission\n\t\tchar dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];\n\t\tret = dpdk_pre_init(dpdk_pre_init_errbuf, 0);\n\t\tif (ret < 0)\n\t\t{\n\t\t\t// This returns a negative value on an error.\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't open device %s: %s\",\n\t\t\t    p->opt.device, dpdk_pre_init_errbuf);\n\t\t\t// ret is set to the correct error\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0)\n\t\t{\n\t\t\t// This means DPDK isn't available on this machine.\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't open device %s: DPDK is not available on this machine\",\n\t\t\t    p->opt.device);\n\t\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t}\n\n\t\tret = dpdk_init_timer(pd);\n\t\tif (ret<0)\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"dpdk error: Init timer is zero with device %s\",\n\t\t\t\tp->opt.device);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tnb_ports = rte_eth_dev_count_avail();\n\t\tif (nb_ports == 0)\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: No Ethernet ports\");\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tportid = portid_by_device(p->opt.device);\n\t\tif (portid == DPDK_PORTID_MAX){\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: portid is invalid. device %s\",\n\t\t\t    p->opt.device);\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\t\t}\n\n\t\tpd->portid = portid;\n\n\t\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\t{\n\t\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\t\t}\n\t\t// create the mbuf pool\n\t\tpd->pktmbuf_pool = rte_pktmbuf_pool_create(MBUF_POOL_NAME, nb_mbufs,\n\t\t\tMEMPOOL_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE,\n\t\t\trte_socket_id());\n\t\tif (pd->pktmbuf_pool == NULL)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, rte_errno,\n\t\t\t    \"dpdk error: Cannot init mbuf pool\");\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// config dev\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t\tif (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MBUF_FAST_FREE)\n\t\t{\n\t\t\tlocal_port_conf.txmode.offloads |=DEV_TX_OFFLOAD_MBUF_FAST_FREE;\n\t\t}\n\t\t// only support 1 queue\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &local_port_conf);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: Cannot configure device: port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// adjust rx tx\n\t\tret = rte_eth_dev_adjust_nb_rx_tx_desc(portid, &nb_rxd, &nb_txd);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: Cannot adjust number of descriptors: port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// get MAC addr\n\t\trte_eth_macaddr_get(portid, &(pd->eth_addr));\n\t\teth_addr_str(&(pd->eth_addr), pd->mac_addr, DPDK_MAC_ADDR_SIZE-1);\n\n\t\t// init one RX queue\n\t\trxq_conf = dev_info.default_rxconf;\n\t\trxq_conf.offloads = local_port_conf.rxmode.offloads;\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     &rxq_conf,\n\t\t\t\t\t     pd->pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_rx_queue_setup:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\t// init one TX queue\n\t\ttxq_conf = dev_info.default_txconf;\n\t\ttxq_conf.offloads = local_port_conf.txmode.offloads;\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\t&txq_conf);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_tx_queue_setup:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// Initialize TX buffers\n\t\ttx_buffer = rte_zmalloc_socket(DPDK_TX_BUF_NAME,\n\t\t\t\tRTE_ETH_TX_BUFFER_SIZE(MAX_PKT_BURST), 0,\n\t\t\t\trte_eth_dev_socket_id(portid));\n\t\tif (tx_buffer == NULL)\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: Cannot allocate buffer for tx on port %u\", portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\trte_eth_tx_buffer_init(tx_buffer, MAX_PKT_BURST);\n\t\t// Start device\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_dev_start:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// set promiscuous mode\n\t\tif (p->opt.promisc){\n\t\t\tpd->must_clear_promisc=1;\n\t\t\trte_eth_promiscuous_enable(portid);\n\t\t}\n\t\t// check link status\n\t\tis_port_up = check_link_status(portid, &link);\n\t\tif (!is_port_up){\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: link is down, port=%u\",portid);\n\t\t\tret = PCAP_ERROR_IFACE_NOT_UP;\n\t\t\tbreak;\n\t\t}\n\t\t// reset statistics\n\t\trte_eth_stats_reset(pd->portid);\n\t\tcalculate_timestamp(&(pd->ts_helper), &(pd->prev_ts));\n\t\trte_eth_stats_get(pd->portid,&(pd->prev_stats));\n\t\t// format pcap_t\n\t\tpd->portid = portid;\n\t\tp->fd = pd->portid;\n\t\tif (p->snapshot <=0 || p->snapshot> MAXIMUM_SNAPLEN)\n\t\t{\n\t\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\t\t}\n\t\tp->linktype = DLT_EN10MB; // Ethernet, the 10MB is historical.\n\t\tp->selectable_fd = p->fd;\n\t\tp->read_op = pcap_dpdk_dispatch;\n\t\tp->inject_op = pcap_dpdk_inject;\n\t\t// using pcapint_filter currently, though DPDK provides their own BPF function. Because DPDK BPF needs load a ELF file as a filter.\n\t\tp->setfilter_op = pcapint_install_bpf_program;\n\t\tp->setdirection_op = NULL;\n\t\tp->set_datalink_op = NULL;\n\t\tp->getnonblock_op = pcap_dpdk_getnonblock;\n\t\tp->setnonblock_op = pcap_dpdk_setnonblock;\n\t\tp->stats_op = pcap_dpdk_stats;\n\t\tp->cleanup_op = pcap_dpdk_close;\n\t\tp->breakloop_op = pcapint_breakloop_common;\n\t\t// set default timeout\n\t\tpd->required_select_timeout.tv_sec = 0;\n\t\tpd->required_select_timeout.tv_usec = DPDK_DEF_MIN_SLEEP_MS*1000;\n\t\tp->required_select_timeout = &pd->required_select_timeout;\n\t\tret = 0; // OK\n\t}while(0);\n\n\tif (ret <= PCAP_ERROR) // all kinds of error code\n\t{\n\t\tpcapint_cleanup_live_common(p);\n\t}else{\n\t\trte_eth_dev_get_name_by_port(portid,pd->pci_addr);\n\t\tRTE_LOG(INFO, USER1,\"Port %d device: %s, MAC:%s, PCI:%s\\n\", portid, p->opt.device, pd->mac_addr, pd->pci_addr);\n\t\tRTE_LOG(INFO, USER1,\"Port %d Link Up. Speed %u Mbps - %s\\n\",\n\t\t\t\t\t\t\tportid, link.link_speed,\n\t\t\t\t\t(link.link_duplex == ETH_LINK_FULL_DUPLEX) ?\n\t\t\t\t\t\t(\"full-duplex\") : (\"half-duplex\\n\"));\n\t}\n\treturn ret;\n}\n\n// device name for dpdk should be in the form as dpdk:number, such as dpdk:0\npcap_t * pcap_dpdk_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p=NULL;\n\t*is_ours = 0;\n\n\t*is_ours = !strncmp(device, \"dpdk:\", 5);\n\tif (! *is_ours)\n\t\treturn NULL;\n\t//memset will happen\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_dpdk);\n\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->activate_op = pcap_dpdk_activate;\n\treturn p;\n}\n\nint pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *ebuf)\n{\n\tint ret=0;\n\tunsigned int nb_ports = 0;\n\tchar dpdk_name[DPDK_DEV_NAME_MAX];\n\tchar dpdk_desc[DPDK_DEV_DESC_MAX];\n\tETHER_ADDR_TYPE eth_addr;\n\tchar mac_addr[DPDK_MAC_ADDR_SIZE];\n\tchar pci_addr[DPDK_PCI_ADDR_SIZE];\n\tdo{\n\t\t// init EAL; return \"DPDK not available\" if we\n\t\t// have insufficient permission\n\t\tchar dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];\n\t\tret = dpdk_pre_init(dpdk_pre_init_errbuf, 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\t// This returns a negative value on an error.\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't look for DPDK devices: %s\",\n\t\t\t    dpdk_pre_init_errbuf);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0)\n\t\t{\n\t\t\t// This means DPDK isn't available on this machine.\n\t\t\t// That just means \"don't return any devices\".\n\t\t\tbreak;\n\t\t}\n\t\tnb_ports = rte_eth_dev_count_avail();\n\t\tif (nb_ports == 0)\n\t\t{\n\t\t\t// That just means \"don't return any devices\".\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfor (unsigned int i=0; i<nb_ports; i++){\n\t\t\tsnprintf(dpdk_name, DPDK_DEV_NAME_MAX-1,\n\t\t\t    \"%s%u\", DPDK_PREFIX, i);\n\t\t\t// mac addr\n\t\t\trte_eth_macaddr_get(i, &eth_addr);\n\t\t\teth_addr_str(&eth_addr,mac_addr,DPDK_MAC_ADDR_SIZE);\n\t\t\t// PCI addr\n\t\t\trte_eth_dev_get_name_by_port(i,pci_addr);\n\t\t\tsnprintf(dpdk_desc,DPDK_DEV_DESC_MAX-1,\"%s %s, MAC:%s, PCI:%s\", DPDK_DESC, dpdk_name, mac_addr, pci_addr);\n\t\t\tif (pcapint_add_dev(devlistp, dpdk_name, 0, dpdk_desc, ebuf)==NULL){\n\t\t\t\tret = PCAP_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while(0);\n\treturn ret;\n}\n\n#ifdef DPDK_ONLY\n/*\n * This libpcap build supports only DPDK, not regular network interfaces.\n */\n\n/*\n * There are no regular interfaces, just DPDK interfaces.\n */\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)\n{\n\treturn (0);\n}\n\n/*\n * Attempts to open a regular interface fail.\n */\npcap_t *\npcapint_create_interface(const char *device, char *errbuf)\n{\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, PCAP_ENODEV_MESSAGE, \"DPDK\");\n\treturn NULL;\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (DPDK-only)\");\n}\n#endif\n"
        },
        {
          "name": "pcap-dpdk.h",
          "type": "blob",
          "size": 1.44921875,
          "content": "/*\n * Copyright (C) 2018 jingle YANG. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   1. Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in the\n *      documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\npcap_t *pcap_dpdk_create(const char *, char *, int *);\nint pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *errbuf);\n"
        },
        {
          "name": "pcap-filter.manmisc.in",
          "type": "blob",
          "size": 40.3955078125,
          "content": ".\\\" Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP-FILTER @MAN_MISC_INFO@ \"8 January 2025\"\n.SH NAME\npcap-filter \\- packet filter syntax\n.br\n.ad\n.SH DESCRIPTION\n.LP\n.BR pcap_compile (3PCAP)\nis used to compile a string into a filter program.\nThe resulting filter program can then be applied to\nsome stream of packets to determine which packets will be supplied to\n.BR pcap_loop (3PCAP),\n.BR pcap_dispatch (3PCAP),\n.BR pcap_next (3PCAP),\nor\n.BR pcap_next_ex (3PCAP).\n.LP\nThe \\fIfilter expression\\fP consists of one or more\n.IR primitives .\nPrimitives usually consist of an\n.I id\n(name or number) preceded by one or more qualifiers.\nThere are three\ndifferent kinds of qualifier:\n.IP \\fItype\\fP\n.I type\nqualifiers say what kind of thing the id name or number refers to.\nPossible types are\n.BR host ,\n.BR net ,\n.B port\nand\n.BR portrange .\nE.g., `\\fBhost\\fP foo', `\\fBnet\\fP 128.3', `\\fBport\\fP 20', `\\fBportrange\\fP 6000-6008'.\nIf there is no type\nqualifier,\n.B host\nis assumed.\n.IP \\fIdir\\fP\n.I dir\nqualifiers specify a particular transfer direction to and/or from\n.IR id .\nPossible directions are\n.BR src ,\n.BR dst ,\n.BR \"src or dst\" ,\n.BR \"src and dst\" ,\n.BR ra ,\n.BR ta ,\n.BR addr1 ,\n.BR addr2 ,\n.BR addr3 ,\nand\n.BR addr4 .\nE.g., `\\fBsrc\\fP foo', `\\fBdst net\\fP 128.3', `\\fBsrc or dst port\\fP ftp-data'.\nIf\nthere is no dir qualifier, `\\fBsrc or dst\\fP' is assumed.\nThe\n.BR ra ,\n.BR ta ,\n.BR addr1 ,\n.BR addr2 ,\n.BR addr3 ,\nand\n.B addr4\nqualifiers are only valid for IEEE 802.11 Wireless LAN link layers.\n.IP \\fIproto\\fP\n.I proto\nqualifiers restrict the match to a particular protocol.\nPossible\nprotocols are:\n.BR ether ,\n.BR fddi ,\n.BR tr ,\n.BR wlan ,\n.BR ip ,\n.BR ip6 ,\n.BR arp ,\n.BR rarp ,\n.BR decnet ,\n.BR sctp ,\n.B tcp\nand\n.BR udp .\nE.g., `\\fBether src\\fP foo', `\\fBarp net\\fP 128.3', `\\fBtcp port\\fP 21',\n`\\fBudp portrange\\fP 7000-7009', `\\fBwlan addr2\\fP 0:2:3:4:5:6'.\nIf there is no\n.I proto\nqualifier, all protocols consistent with the type are assumed.\nE.g., `\\fBsrc\\fP foo' means `\\fB(ip6 or ip or arp or rarp) src\\fP foo',\n`\\fBnet\\fP bar' means `\\fB(ip or arp or rarp) net\\fP bar' and\n`\\fBport\\fP 53' means `\\fB(tcp or udp or sctp) port\\fP 53'\n(note that these examples use invalid syntax to illustrate the principle).\n.LP\n[\\fBfddi\\fP is actually an alias for \\fBether\\fP; the parser treats them\nidentically as meaning ``the data link level used on the specified\nnetwork interface''.  FDDI headers contain Ethernet-like source\nand destination addresses, and often contain Ethernet-like packet\ntypes, so you can filter on these FDDI fields just as with the\nanalogous Ethernet fields.\nFDDI headers also contain other fields,\nbut you cannot name them explicitly in a filter expression.\n.LP\nSimilarly, \\fBtr\\fP and \\fBwlan\\fP are aliases for \\fBether\\fP; the previous\nparagraph's statements about FDDI headers also apply to Token Ring\nand 802.11 wireless LAN headers.  For 802.11 headers, the destination\naddress is the DA field and the source address is the SA field; the\nBSSID, RA, and TA fields aren't tested.]\n.LP\nIn addition to the above, there are some special `primitive' keywords\nthat don't follow the pattern:\n.BR gateway ,\n.BR broadcast ,\n.BR less ,\n.B greater\nand arithmetic expressions.\nAll of these are described below.\n.LP\nMore complex filter expressions are built up by using the words\n.BR and ,\n.B or\nand\n.B not\n(or equivalently: `\\fB&&\\fP', `\\fB||\\fP' and `\\fB!\\fP' respectively)\nto combine primitives.\nE.g., `\\fBhost\\fP foo \\fBand not port\\fP ftp \\fBand not port\\fP ftp-data'.\nTo save typing, identical qualifier lists can be omitted.\nE.g.,\n`\\fBtcp dst port\\fP ftp \\fBor\\fP ftp-data \\fBor\\fP domain' is exactly the same as\n`\\fBtcp dst port\\fP ftp \\fBor tcp dst port\\fP ftp-data \\fBor tcp dst port\\fP domain'.\n.LP\nAllowable primitives are:\n.IP \"\\fBdst host \\fIhostnameaddr\\fR\"\nTrue if the IPv4/v6 destination field of the packet is \\fIhostnameaddr\\fP,\nwhich may be either an address or a name.\n.IP \"\\fBsrc host \\fIhostnameaddr\\fR\"\nTrue if the IPv4/v6 source field of the packet is \\fIhostnameaddr\\fP.\n.IP \"\\fBhost \\fIhostnameaddr\\fP\"\nTrue if either the IPv4/v6 source or destination of the packet is \\fIhostnameaddr\\fP.\n.IP\nAny of the above host expressions can be prepended with the keywords,\n\\fBip\\fP, \\fBarp\\fP, \\fBrarp\\fP, or \\fBip6\\fP as in:\n.in +.5i\n.nf\n\\fBip host \\fIhostnameaddr\\fR\n.fi\n.in -.5i\nwhich is equivalent to:\n.in +.5i\n.nf\n\\fBether proto \\\\\\fRip \\fBand host \\fIhostnameaddr\\fR\n.fi\n.in -.5i\nIf \\fIhostnameaddr\\fR is a name with multiple IPv4/v6 addresses, each address will\nbe checked for a match.\n.IP \"\\fBether dst \\fIethernameaddr\\fP\"\nTrue if the Ethernet destination address is \\fIethernameaddr\\fP.\n\\fIethernameaddr\\fP\nmay be either a name from /etc/ethers or a numerical MAC address of the\nform \"xx:xx:xx:xx:xx:xx\", \"xx.xx.xx.xx.xx.xx\", \"xx-xx-xx-xx-xx-xx\",\n\"xxxx.xxxx.xxxx\" or \"xxxxxxxxxxxx\",\nwhere each \"x\" is a hex digit (0-9, a-f, or A-F).\n.IP \"\\fBether src \\fIethernameaddr\\fP\"\nTrue if the Ethernet source address is \\fIethernameaddr\\fP.\n.IP \"\\fBether host \\fIethernameaddr\\fP\"\nTrue if either the Ethernet source or destination address is \\fIethernameaddr\\fP.\n.IP \"\\fBgateway\\fP \\fIhost\\fP\"\nTrue if the packet used \\fIhost\\fP as a gateway.\nI.e., the Ethernet\nsource or destination address was \\fIhost\\fP but neither the IP source\nnor the IP destination was \\fIhost\\fP.\n\\fIHost\\fP must be a name and\nmust be found both by the machine's host-name-to-IP-address resolution\nmechanisms (host name file, DNS, NIS, etc.) and by the machine's\nhost-name-to-Ethernet-address resolution mechanism (/etc/ethers, etc.).\n(An equivalent expression is\n.in +.5i\n.nf\n\\fBether host \\fIethernameaddr \\fBand not host \\fIhostnameaddr\\fR\n.fi\n.in -.5i\nwhich can be used with either names or numbers for \\fIhostnameaddr / ethernameaddr\\fP.)\nThis syntax does not work in IPv6-enabled configuration at this moment.\n.IP \"\\fBdst net \\fInetnameaddr\\fR\"\nTrue if the IPv4/v6 destination address of the packet has a network\nnumber of \\fInetnameaddr\\fP.\n\\fINet\\fP may be either a name from the networks database\n(/etc/networks, etc.) or a network number.\nAn IPv4 network number can be written as a dotted quad (e.g., 192.168.1.0),\ndotted triple (e.g., 192.168.1), dotted pair (e.g, 172.16), or single\nnumber (e.g., 10); the netmask is 255.255.255.255 for a dotted quad\n(which means that it's really a host match), 255.255.255.0 for a dotted\ntriple, 255.255.0.0 for a dotted pair, or 255.0.0.0 for a single number.\nAn IPv6 network number must be written out fully; the netmask is\nffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff, so IPv6 \"network\" matches are really always\nhost matches, and a network match requires a netmask length.\n.IP \"\\fBsrc net \\fInetnameaddr\\fR\"\nTrue if the IPv4/v6 source address of the packet has a network\nnumber of \\fInetnameaddr\\fP.\n.IP \"\\fBnet \\fInetnameaddr\\fR\"\nTrue if either the IPv4/v6 source or destination address of the packet has a network\nnumber of \\fInetnameaddr\\fP.\n.IP \"\\fBnet \\fInetaddr\\fR \\fBmask \\fInetmask\\fR\"\nTrue if the IPv4 address matches \\fInetaddr\\fR with the specific \\fInetmask\\fR.\nMay be qualified with \\fBsrc\\fR or \\fBdst\\fR.\nNote that this syntax is not valid for IPv6 \\fInetaddr\\fR.\n.IP \"\\fBnet \\fInetaddr\\fR/\\fIlen\\fR\"\nTrue if the IPv4/v6 address matches \\fInetaddr\\fR with a netmask \\fIlen\\fR\nbits wide.\nMay be qualified with \\fBsrc\\fR or \\fBdst\\fR.\n.IP \"\\fBdst port \\fIportnamenum\\fR\"\nTrue if the packet is IPv4/v6 TCP, UDP or SCTP and has a\ndestination port value of \\fIportnamenum\\fP.\nThe \\fIportnamenum\\fP can be a number or a name used in /etc/services (see\n.BR tcp (4P)\nand\n.BR udp (4P)).\nIf a name is used, both the port\nnumber and protocol are checked.\nIf a number or ambiguous name is used,\nonly the port number is checked (e.g., `\\fBdst port\\fR 513' will print both\ntcp/login traffic and udp/who traffic, and `\\fBport\\fR domain' will print\nboth tcp/domain and udp/domain traffic).\n.IP \"\\fBsrc port \\fIportnamenum\\fR\"\nTrue if the packet has a source port value of \\fIportnamenum\\fP.\n.IP \"\\fBport \\fIportnamenum\\fR\"\nTrue if either the source or destination port of the packet is \\fIportnamenum\\fP.\n.IP \"\\fBdst portrange \\fIportnamenum1-portnamenum2\\fR\"\nTrue if the packet is IPv4/v6 TCP, UDP or SCTP and has a\ndestination port value between \\fIportnamenum1\\fP and \\fIportnamenum2\\fP (both inclusive).\n.I portnamenum1\nand\n.I portnamenum2\nare interpreted in the same fashion as the\n.I portnamenum\nparameter for\n.BR port .\n.IP \"\\fBsrc portrange \\fIportnamenum1-portnamenum2\\fR\"\nTrue if the packet has a source port value between \\fIportnamenum1\\fP and\n\\fIportnamenum2\\fP (both inclusive).\n.IP \"\\fBportrange \\fIportnamenum1-portnamenum2\\fR\"\nTrue if either the source or destination port of the packet is between\n\\fIportnamenum1\\fP and \\fIportnamenum2\\fP (both inclusive).\n.IP\nAny of the above port or port range expressions can be prepended with\nthe keywords, \\fBtcp\\fP, \\fBudp\\fP or \\fBsctp\\fP, as in:\n.in +.5i\n.nf\n\\fBtcp src port \\fIportnamenum\\fR\n.fi\n.in -.5i\nwhich matches only TCP packets whose source port is \\fIportnamenum\\fP.\n.IP \"\\fBless \\fIlength\\fR\"\nTrue if the packet has a length less than or equal to \\fIlength\\fP.\nThis is equivalent to:\n.in +.5i\n.nf\n\\fBlen <= \\fIlength\\fP\n.fi\n.in -.5i\n.IP \"\\fBgreater \\fIlength\\fR\"\nTrue if the packet has a length greater than or equal to \\fIlength\\fP.\nThis is equivalent to:\n.in +.5i\n.nf\n\\fBlen >= \\fIlength\\fP\n.fi\n.in -.5i\n.IP \"\\fBip proto \\fIprotocol\\fR\"\nTrue if the packet is an IPv4 packet (see\n.BR ip (4P))\nof protocol type \\fIprotocol\\fP.\n\\fIProtocol\\fP can be a number or one of the names recognized by\n.BR getprotobyname (3),\nfor example:\n.BR ah ,\n.BR esp ,\n.B eigrp\n(only in Linux with glibc, FreeBSD, NetBSD, DragonFly BSD, and macOS),\n.BR icmp ,\n.BR igmp ,\n.B igrp\n(only in Haiku and OpenBSD),\n.BR pim ,\n.BR sctp ,\n.BR tcp ,\n.B udp\nor\n.BR vrrp .\nNote that most of these example identifiers\nare also keywords and must be escaped via backslash (\\\\).\nNote that this primitive does not chase the protocol header chain.\n.IP\nTypically\n.BR getprotobyname (3)\nparses the\n.IR \\%/etc/protocols\nfile to translate protocol names to numbers, and the\n.B \"getent protocols\"\ncommand lists the protocols recognised by the function.  This is not entirely\nso in AIX (which does not have the command), Haiku (which has the file at\n.IR \\%/system/data/network/protocols\nand does not have the command), on Linux with musl libc (which hard-codes the\nlist of protocols) and on hosts that use a network database to resolve\nprotocol names to numbers (see\n.BR nsswitch.conf (5)).\nIf a protocol name fails to translate to a number, this version of libpcap\nwill treat the filter expression as invalid.\n.IP \"\\fBcarp\\fR, \\fBvrrp\\fR\"\nAbbreviations for:\n.in +.5i\n.nf\n\\fBip proto\\fR 112\n.fi\n.in -.5i\n.IP \"\\fBicmp\\fR\"\nAbbreviation for:\n.in +.5i\n.nf\n\\fBip proto\\fR 1\n.fi\n.in -.5i\n.IP \"\\fBigmp\\fR\"\nAbbreviation for:\n.in +.5i\n.nf\n\\fBip proto\\fR 2\n.fi\n.in -.5i\n.IP \"\\fBigrp\\fR\"\nAbbreviation for:\n.in +.5i\n.nf\n\\fBip proto\\fR 9\n.fi\n.in -.5i\n.IP \"\\fBip6 proto \\fIprotocol\\fR\"\nTrue if the packet is an IPv6 packet of protocol type \\fIprotocol\\fP.\n(See `\\fBip proto\\fP' above for the meaning of \\fIprotocol\\fR.)\nNote that the IPv6 variant of ICMP uses a different protocol number, named\n.B \\%ipv6-icmp\nin AIX, FreeBSD, illumos, Haiku, GNU/Hurd, Linux, macOS, NetBSD, OpenBSD,\nSolaris and Windows.\nNote that this primitive does not chase the protocol header chain.\n.IP \"\\fBicmp6\\fR\"\nAbbreviation for:\n.in +.5i\n.nf\n\\fBip6 proto\\fR 58\n.fi\n.in -.5i\n.IP \"\\fBproto \\fIprotocol\\fR\"\nTrue if the packet is an IPv4 or IPv6 packet of protocol type\n\\fIprotocol\\fP.  (See `\\fBip proto\\fP' above for the meaning of\n\\fIprotocol\\fP.)  Note that this primitive does not chase the protocol\nheader chain.\n.IP  \"\\fBah\\fR, \\fBesp\\fR, \\fBpim\\fR, \\fBsctp\\fR, \\fBtcp\\fR, \\fBudp\\fR\"\nAbbreviations for:\n.in +.5i\n.nf\n\\fBproto \\\\\\fIprotocol\\fR\n.fi\n.in -.5i\nwhere \\fIprotocol\\fR is one of the above protocols.\n.IP \"\\fBip6 protochain \\fIprotocol\\fR\"\nTrue if the packet is IPv6 packet,\nand contains protocol header with type \\fIprotocol\\fR\nin its protocol header chain.\n(See `\\fBip proto\\fP' above for the meaning of \\fIprotocol\\fP.)\nFor example,\n.in +.5i\n.nf\n\\fBip6 protochain\\fR 6\n.fi\n.in -.5i\nmatches any IPv6 packet with TCP protocol header in the protocol header chain.\nThe packet may contain, for example,\nauthentication header, routing header, or hop-by-hop option header,\nbetween IPv6 header and TCP header.\nThe BPF code emitted by this primitive is complex and\ncannot be optimized by the BPF optimizer code, and is not supported by\nfilter engines in the kernel, so this can be somewhat slow, and may\ncause more packets to be dropped.\n.IP \"\\fBip protochain \\fIprotocol\\fR\"\nEquivalent to \\fBip6 protochain \\fIprotocol\\fR, but this is for IPv4.\n(See `\\fBip proto\\fP' above for the meaning of \\fIprotocol\\fP.)\n.IP \"\\fBprotochain \\fIprotocol\\fR\"\nTrue if the packet is an IPv4 or IPv6 packet of protocol type\n\\fIprotocol\\fP.  (See `\\fBip proto\\fP' above for the meaning of\n\\fIprotocol\\fP.)  Note that this primitive chases the protocol\nheader chain.\n.IP \"\\fBether broadcast\\fR\"\nTrue if the packet is an Ethernet broadcast packet.\nThe \\fBether\\fP\nkeyword is optional.\n.IP \"\\fBip broadcast\\fR\"\nTrue if the packet is an IPv4 broadcast packet.\nIt checks for both the all-zeroes and all-ones broadcast conventions,\nand looks up the subnet mask on the interface on which the capture is\nbeing done.\n.IP\nIf the subnet mask of the interface on which the capture is being done\nis not available, either because the interface on which capture is being\ndone has no netmask or because the capture is being done on the Linux\n\"any\" interface, which can capture on more than one interface, this\ncheck will not work correctly.\n.IP \"\\fBether multicast\\fR\"\nTrue if the packet is an Ethernet multicast packet.\nThe \\fBether\\fP\nkeyword is optional.\nThis is shorthand for `\\fBether[\\fP0\\fB] & \\fP1\\fB != \\fP0'.\n.IP \"\\fBip multicast\\fR\"\nTrue if the packet is an IPv4 multicast packet.\n.IP \"\\fBip6 multicast\\fR\"\nTrue if the packet is an IPv6 multicast packet.\n.IP  \"\\fBether proto \\fIprotocol\\fR\"\nTrue if the packet is of ether type \\fIprotocol\\fR.\n\\fIProtocol\\fP can be a number or one of the names\n\\fBaarp\\fP, \\fBarp\\fP, \\fBatalk\\fP, \\fBdecnet\\fP, \\fBip\\fP, \\fBip6\\fP,\n\\fBipx\\fP, \\fBiso\\fP, \\fBlat\\fP, \\fBloopback\\fP, \\fBmopdl\\fP, \\fBmoprc\\fP, \\fBnetbeui\\fP,\n\\fBrarp\\fP, \\fBsca\\fP or \\fBstp\\fP.\nNote these identifiers (except \\fBloopback\\fP) are also keywords\nand must be escaped via backslash (\\\\).\n.IP\n[In the case of FDDI (e.g., `\\fBfddi proto \\\\arp\\fR'), Token Ring\n(e.g., `\\fBtr proto \\\\arp\\fR'), and IEEE 802.11 wireless LANs (e.g.,\n`\\fBwlan proto \\\\arp\\fR'), for most of those protocols, the\nprotocol identification comes from the 802.2 Logical Link Control (LLC)\nheader, which is usually layered on top of the FDDI, Token Ring, or\n802.11 header.\n.IP\nWhen filtering for most protocol identifiers on FDDI, Token Ring, or\n802.11, the filter checks only the protocol ID field of an LLC header\nin so-called SNAP format with an Organizational Unit Identifier (OUI) of\n0x000000, for encapsulated Ethernet; it doesn't check whether the packet\nis in SNAP format with an OUI of 0x000000.\nThe exceptions are:\n.RS\n.TP\n\\fBiso\\fP\nthe filter checks the DSAP (Destination Service Access Point) and\nSSAP (Source Service Access Point) fields of the LLC header;\n.TP\n\\fBstp\\fP and \\fBnetbeui\\fP\nthe filter checks the DSAP of the LLC header;\n.TP\n\\fBatalk\\fP\nthe filter checks for a SNAP-format packet with an OUI of 0x080007\nand the AppleTalk etype.\n.RE\n.IP\nIn the case of Ethernet, the filter checks the Ethernet type field\nfor most of those protocols.  The exceptions are:\n.RS\n.TP\n\\fBiso\\fP, \\fBstp\\fP, and \\fBnetbeui\\fP\nthe filter checks for an 802.3 frame and then checks the LLC header as\nit does for FDDI, Token Ring, and 802.11;\n.TP\n\\fBatalk\\fP\nthe filter checks both for the AppleTalk etype in an Ethernet frame and\nfor a SNAP-format packet as it does for FDDI, Token Ring, and 802.11;\n.TP\n\\fBaarp\\fP\nthe filter checks for the AppleTalk ARP etype in either an Ethernet\nframe or an 802.2 SNAP frame with an OUI of 0x000000;\n.TP\n\\fBipx\\fP\nthe filter checks for the IPX etype in an Ethernet frame, the IPX\nDSAP in the LLC header, the 802.3-with-no-LLC-header encapsulation of\nIPX, and the IPX etype in a SNAP frame.\n.RE\n.IP \"\\fBip\\fR, \\fBip6\\fR, \\fBarp\\fR, \\fBrarp\\fR, \\fBatalk\\fR, \\fBaarp\\fR, \\fBdecnet\\fR, \\fBiso\\fR, \\fBstp\\fR, \\fBipx\\fR, \\fBnetbeui\\fP\"\nAbbreviations for:\n.in +.5i\n.nf\n\\fBether proto \\\\\\fIprotocol\\fR\n.fi\n.in -.5i\nwhere \\fIprotocol\\fR is one of the above protocols.\n.IP \"\\fBlat\\fR, \\fBmopdl\\fR, \\fBmoprc\\fR, \\fBsca\\fR\"\nAbbreviations for:\n.in +.5i\n.nf\n\\fBether proto \\\\\\fIprotocol\\fR\n.fi\n.in -.5i\nwhere \\fIprotocol\\fR is one of the above protocols, all of which originated\nat DEC, but are not the same as DECnet.  Namely,\n.B lat\nis Local Area Transport (LAT),\n.B mopdl\nis DNA Dump/Load (MOP),\n.B moprc\nis DNA Remote Console (MOP) and\n.B sca\nis System Communication Architecture (SCA).\n.IP \"\\fBdecnet src \\fIdecnetaddr\\fR\"\nTrue if the DECnet source address is\n.IR decnetaddr ,\nwhich is an address of the form\n.B AREANUMBER.NODENUMBER\n(for example, \"10.123\"), where the area number can be between 0 and 63\nand the node number can be between 0 and 1023 and both numbers always use\ndecimal base.\n.IP \"\\fBdecnet dst \\fIdecnetaddr\\fR\"\nTrue if the DECnet destination address is\n.IR decnetaddr .\n.IP \"\\fBdecnet host \\fIdecnetaddr\\fR\"\nTrue if either the DECnet source or destination address is\n.IR decnetaddr .\n.IP \\fBllc\\fP\nTrue if the packet has an 802.2 LLC header.  This includes:\n.IP\nEthernet packets with a length field rather than a type field that\naren't raw NetWare-over-802.3 packets;\n.IP\nIEEE 802.11 data packets;\n.IP\nToken Ring packets (no check is done for LLC frames);\n.IP\nFDDI packets (no check is done for LLC frames);\n.IP\nLLC-encapsulated ATM packets, for SunATM on Solaris.\n.IP \"\\fBllc\\fP \\fItype\\fR\"\nTrue if the packet has an 802.2 LLC header and has the specified\n.IR type .\n.I type\ncan be one of:\n.RS\n.TP\n\\fBi\\fR\nInformation (I) PDUs\n.TP\n\\fBs\\fR\nSupervisory (S) PDUs\n.TP\n\\fBu\\fR\nUnnumbered (U) PDUs\n.TP\n\\fBrr\\fR\nReceiver Ready (RR) S PDUs\n.TP\n\\fBrnr\\fR\nReceiver Not Ready (RNR) S PDUs\n.TP\n\\fBrej\\fR\nReject (REJ) S PDUs\n.TP\n\\fBui\\fR\nUnnumbered Information (UI) U PDUs\n.TP\n\\fBua\\fR\nUnnumbered Acknowledgment (UA) U PDUs\n.TP\n\\fBdisc\\fR\nDisconnect (DISC) U PDUs\n.TP\n\\fBdm\\fR\nDisconnected Mode (DM) U PDUs\n.TP\n\\fBsabme\\fR\nSet Asynchronous Balanced Mode Extended (SABME) U PDUs\n.TP\n\\fBtest\\fR\nTest (TEST) U PDUs\n.TP\n\\fBxid\\fR\nExchange Identification (XID) U PDUs\n.TP\n\\fBfrmr\\fR\nFrame Reject (FRMR) U PDUs\n.RE\n.IP \\fBinbound\\fP\nPacket was received by the host performing the capture rather than being\nsent by that host.  This is only supported for certain link-layer types,\nsuch as SLIP and the ``cooked'' Linux capture mode\nused for the ``any'' device and for some other device types.\n.IP \\fBoutbound\\fP\nPacket was sent by the host performing the capture rather than being\nreceived by that host.  This is only supported for certain link-layer types,\nsuch as SLIP and the ``cooked'' Linux capture mode\nused for the ``any'' device and for some other device types.\n.IP \"\\fBifindex \\fIinterface_index\\fR\"\nTrue if the packet was logged via the specified interface (applies only to\npackets logged by the Linux \"any\" cooked v2 interface).\n.IP \"\\fBifname \\fIinterface\\fR\"\nTrue if the packet was logged as coming from the specified interface (applies\nonly to packets logged by OpenBSD's or FreeBSD's\n.BR pf (4)).\n.IP \"\\fBon \\fIinterface\\fR\"\nSynonymous with the\n.B ifname\nmodifier.\n.IP \"\\fBrnr \\fInum\\fR\"\nTrue if the packet was logged as matching the specified PF rule number\n(applies only to packets logged by OpenBSD's or FreeBSD's\n.BR pf (4)).\n.IP \"\\fBrulenum \\fInum\\fR\"\nSynonymous with the\n.B rnr\nmodifier.\n.IP \"\\fBreason \\fIcode\\fR\"\nTrue if the packet was logged with the specified PF reason code.  The known\ncodes are:\n.BR \\%match ,\n.BR \\%bad-offset ,\n.BR \\%fragment ,\n.BR \\%short ,\n.BR \\%normalize ,\nand\n.B memory\n(applies only to packets logged by OpenBSD's or FreeBSD's\n.BR pf (4)).\n.IP \"\\fBrset \\fIname\\fR\"\nTrue if the packet was logged as matching the specified PF ruleset\nname of an anchored ruleset (applies only to packets logged by OpenBSD's\nor FreeBSD's\n.BR pf (4)).\n.IP \"\\fBruleset \\fIname\\fR\"\nSynonymous with the\n.B rset\nmodifier.\n.IP \"\\fBsrnr \\fInum\\fR\"\nTrue if the packet was logged as matching the specified PF rule number\nof an anchored ruleset (applies only to packets logged by OpenBSD's or\nFreeBSD's\n.BR pf (4)).\n.IP \"\\fBsubrulenum \\fInum\\fR\"\nSynonymous with the\n.B srnr\nmodifier.\n.IP \"\\fBaction \\fIact\\fR\"\nTrue if PF took the specified action when the packet was logged.  Known actions\nare:\n.B pass\nand\n.B block\nand, with later versions of\n.BR pf (4),\n.BR nat ,\n.BR rdr ,\n.B binat\nand\n.B scrub\n(applies only to packets logged by OpenBSD's or FreeBSD's\n.BR pf (4)).\n.IP \"\\fBwlan ra \\fIehost\\fR\"\nTrue if the IEEE 802.11 RA is\n.IR ehost .\nThe RA field is used in all frames except for management frames.\n.IP \"\\fBwlan ta \\fIehost\\fR\"\nTrue if the IEEE 802.11 TA is\n.IR ehost .\nThe TA field is used in all frames except for management frames and\nCTS (Clear To Send) and ACK (Acknowledgment) control frames.\n.IP \"\\fBwlan addr1 \\fIehost\\fR\"\nTrue if the first IEEE 802.11 address is\n.IR ehost .\n.IP \"\\fBwlan addr2 \\fIehost\\fR\"\nTrue if the second IEEE 802.11 address, if present, is\n.IR ehost .\nThe second address field is used in all frames except for CTS (Clear To\nSend) and ACK (Acknowledgment) control frames.\n.IP \"\\fBwlan addr3 \\fIehost\\fR\"\nTrue if the third IEEE 802.11 address, if present, is\n.IR ehost .\nThe third address field is used in management and data frames, but not\nin control frames.\n.IP \"\\fBwlan addr4 \\fIehost\\fR\"\nTrue if the fourth IEEE 802.11 address, if present, is\n.IR ehost .\nThe fourth address field is only used for\nWDS (Wireless Distribution System) frames.\n.IP \"\\fBwlan type \\fIwlan_type\\fR\"\nTrue if the IEEE 802.11 frame type matches the specified \\fIwlan_type\\fR.\nValid \\fIwlan_type\\fRs are:\n\\fBmgt\\fP,\n\\fBctl\\fP\nand \\fBdata\\fP.\nThe\n.B wlan\nkeyword is optional.\n.IP \"\\fBwlan type \\fIwlan_type \\fBsubtype \\fIwlan_subtype\\fR\"\nTrue if the IEEE 802.11 frame type matches the specified \\fIwlan_type\\fR\nand frame subtype matches the specified \\fIwlan_subtype\\fR.\nThe\n.B wlan\nkeyword is optional.\n.IP\nIf the specified \\fIwlan_type\\fR is \\fBmgt\\fP,\nthen valid \\fIwlan_subtype\\fRs are:\n\\fBassoc-req\\fP,\n\\fBassoc-resp\\fP,\n\\fBreassoc-req\\fP,\n\\fBreassoc-resp\\fP,\n\\fBprobe-req\\fP,\n\\fBprobe-resp\\fP,\n\\fBbeacon\\fP,\n\\fBatim\\fP,\n\\fBdisassoc\\fP,\n\\fBauth\\fP and\n\\fBdeauth\\fP.\n.IP\nIf the specified \\fIwlan_type\\fR is \\fBctl\\fP,\nthen valid \\fIwlan_subtype\\fRs are:\n\\fBbar\\fP,\n\\fBba\\fP,\n\\fBps-poll\\fP,\n\\fBrts\\fP,\n\\fBcts\\fP,\n\\fBack\\fP,\n\\fBcf-end\\fP and\n\\fBcf-end-ack\\fP.\n.IP\nIf the specified \\fIwlan_type\\fR is \\fBdata\\fP,\nthen valid \\fIwlan_subtype\\fRs are:\n.BR \\%data ,\n.BR \\%data-cf-ack ,\n.BR \\%data-cf-poll ,\n.BR \\%data-cf-ack-poll ,\n.BR \\%null ,\n.BR \\%cf-ack ,\n.BR \\%cf-poll ,\n.BR \\%cf-ack-poll ,\n.BR \\%qos-data ,\n.BR \\%qos-data-cf-ack ,\n.BR \\%qos-data-cf-poll ,\n.BR \\%qos-data-cf-ack-poll ,\n.BR \\%qos ,\n.B \\%qos-cf-poll\nand\n.BR \\%qos-cf-ack-poll .\n.IP \"\\fBwlan subtype \\fIwlan_subtype\\fR\"\nTrue if the IEEE 802.11 frame subtype matches the specified \\fIwlan_subtype\\fR\nand frame has the type to which the specified \\fIwlan_subtype\\fR belongs.\nThe\n.B wlan\nkeyword is optional.\n.IP \"\\fBwlan dir \\fIdirection\\fR\"\nTrue if the IEEE 802.11 frame direction matches the specified\n.IR direction .\nValid directions are:\n.BR nods ,\n.BR tods ,\n.BR fromds ,\n.BR dstods ,\nor a numeric value.\nThe\n.B wlan\nkeyword is optional.\n.IP \"\\fBvlan \\fI[vlan_id]\\fR\"\nTrue if the packet is an IEEE 802.1Q VLAN packet.\nIf the optional \\fIvlan_id\\fR is specified, only true if the packet has the specified\n\\fIvlan_id\\fR.\nNote that the first \\fBvlan\\fR keyword encountered in an expression\nchanges the decoding offsets for the remainder of the expression on\nthe assumption that the packet is a VLAN packet.  The `\\fBvlan\n\\fI[vlan_id]\\fR` keyword may be used more than once, to filter on VLAN\nhierarchies.  Each use of that keyword increments the filter offsets\nby 4.\n.IP\nFor example:\n.in +.5i\n.nf\n\\fBvlan\\fP 100 \\fB&& vlan\\fR 200\n.fi\n.in -.5i\nfilters on VLAN 200 encapsulated within VLAN 100, and\n.in +.5i\n.nf\n\\fBvlan && vlan \\fP300 \\fB&& ip\\fR\n.fi\n.in -.5i\nfilters IPv4 protocol encapsulated in VLAN 300 encapsulated within any\nhigher order VLAN.\n.IP \"\\fBmpls \\fI[label_num]\\fR\"\nTrue if the packet is an MPLS packet.\nIf the optional \\fIlabel_num\\fR is specified, only true if the packet has the specified\n\\fIlabel_num\\fR.\nNote that the first \\fBmpls\\fR keyword encountered in an expression\nchanges the decoding offsets for the remainder of the expression on\nthe assumption that the packet is a MPLS-encapsulated IP packet.  The\n`\\fBmpls \\fI[label_num]\\fR` keyword may be used more than once, to\nfilter on MPLS hierarchies.  Each use of that keyword increments the\nfilter offsets by 4.\n.IP\nFor example:\n.in +.5i\n.nf\n\\fBmpls\\fP 100000 \\fB&& mpls\\fR 1024\n.fi\n.in -.5i\nfilters packets with an outer label of 100000 and an inner label of\n1024, and\n.in +.5i\n.nf\n\\fBmpls && mpls\\fP 1024 \\fB&& host\\fR 192.9.200.1\n.fi\n.in -.5i\nfilters packets to or from 192.9.200.1 with an inner label of 1024 and\nany outer label.\n.IP \\fBpppoed\\fP\nTrue if the packet is a PPP-over-Ethernet Discovery packet (Ethernet\ntype 0x8863).\n.IP \"\\fBpppoes \\fI[session_id]\\fR\"\nTrue if the packet is a PPP-over-Ethernet Session packet (Ethernet\ntype 0x8864).\nIf the optional \\fIsession_id\\fR is specified, only true if the packet has the specified\n\\fIsession_id\\fR.\nNote that the first \\fBpppoes\\fR keyword encountered in an expression\nchanges the decoding offsets for the remainder of the expression on\nthe assumption that the packet is a PPPoE session packet.\n.IP\nFor example:\n.in +.5i\n.nf\n\\fBpppoes\\fP 0x27 \\fB&& ip\\fR\n.fi\n.in -.5i\nfilters IPv4 protocol encapsulated in PPPoE session id 0x27.\n.IP \"\\fBgeneve \\fI[vni]\\fR\"\nTrue if the packet is a Geneve packet (UDP port 6081). If the optional \\fIvni\\fR\nis specified, only true if the packet has the specified \\fIvni\\fR.\nNote that when the \\fBgeneve\\fR keyword is encountered in\nan expression, it changes the decoding offsets for the remainder of\nthe expression on the assumption that the packet is a Geneve packet.\n.IP\nFor example:\n.in +.5i\n.nf\n\\fBgeneve\\fP 0xb \\fB&& ip\\fR\n.fi\n.in -.5i\nfilters IPv4 protocol encapsulated in Geneve with VNI 0xb. This will\nmatch both IPv4 directly encapsulated in Geneve as well as IPv4 contained\ninside an Ethernet frame.\n.IP \"\\fBvxlan \\fI[vni]\\fR\"\nTrue if the packet is a VXLAN packet (UDP port 4789). If the optional\n\\fIvni\\fR is specified, only true if the packet has the specified\n\\fIvni\\fR.  Note that when the \\fBvxlan\\fR keyword is encountered in\nan expression, it changes the decoding offsets for the remainder of\nthe expression on the assumption that the packet is a VXLAN packet.\n.IP\nFor example:\n.in +.5i\n.nf\n\\fBvxlan\\fP 0x7 \\fB&& ip6 \\fR\n.fi\n.in -.5i\nfilters IPv6 protocol encapsulated in VXLAN with VNI 0x7.\n.IP \"\\fBiso proto \\fIprotocol\\fR\"\nTrue if the packet is an OSI packet of protocol type \\fIprotocol\\fP.\n\\fIProtocol\\fP can be a number or one of the names\n\\fBclnp\\fP, \\fBesis\\fP, or \\fBisis\\fP.\n.IP \"\\fBclnp\\fR, \\fBesis\\fR, \\fBisis\\fR\"\nAbbreviations for:\n.in +.5i\n.nf\n\\fBiso proto \\\\\\fIprotocol\\fR\n.fi\n.in -.5i\nwhere \\fIprotocol\\fR is one of the above protocols.\n.IP \"\\fBl1\\fR, \\fBl2\\fR, \\fBiih\\fR, \\fBlsp\\fR, \\fBsnp\\fR, \\fBcsnp\\fR, \\fBpsnp\\fR\"\nAbbreviations for IS-IS PDU types.\n.IP \"\\fBvpi\\fP \\fIn\\fR\"\nTrue if the packet is an ATM packet, for SunATM on Solaris, with a\nvirtual path identifier of\n.IR n .\n.IP \"\\fBvci\\fP \\fIn\\fR\"\nTrue if the packet is an ATM packet, for SunATM on Solaris, with a\nvirtual channel identifier of\n.IR n .\n.IP \\fBlane\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\nan ATM LANE packet.\nNote that the first \\fBlane\\fR keyword encountered in an expression\nchanges the tests done in the remainder of the expression\non the assumption that the packet is either a LANE emulated Ethernet\npacket or a LANE LE Control packet.  If \\fBlane\\fR isn't specified, the\ntests are done under the assumption that the packet is an\nLLC-encapsulated packet.\n.IP \\fBoamf4sc\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\na segment OAM F4 flow cell (VPI=0 & VCI=3).\n.IP \\fBoamf4ec\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\nan end-to-end OAM F4 flow cell (VPI=0 & VCI=4).\n.IP \\fBoamf4\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\na segment or end-to-end OAM F4 flow cell (VPI=0 & (VCI=3 | VCI=4)).\n.IP \\fBoam\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\na segment or end-to-end OAM F4 flow cell (VPI=0 & (VCI=3 | VCI=4)).\n.IP \\fBmetac\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non a meta signaling circuit (VPI=0 & VCI=1).\n.IP \\fBbcc\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non a broadcast signaling circuit (VPI=0 & VCI=2).\n.IP \\fBsc\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non a signaling circuit (VPI=0 & VCI=5).\n.IP \\fBilmic\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non an ILMI circuit (VPI=0 & VCI=16).\n.IP \\fBconnectmsg\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non a signaling circuit and is a Q.2931 Setup, Call Proceeding, Connect,\nConnect Ack, Release, or Release Done message.\n.IP \\fBmetaconnect\\fP\nTrue if the packet is an ATM packet, for SunATM on Solaris, and is\non a meta signaling circuit and is a Q.2931 Setup, Call Proceeding, Connect,\nRelease, or Release Done message.\n.IP \\fBfisu\\fP\nTrue if the packet is a Fill-In Signal Unit (FISU) MTP2 packet.\n.IP \\fBlssu\\fP\nTrue if the packet is a Link Status Signal Unit (LSSU) MTP2 packet.\n.IP \\fBmsu\\fP\nTrue if the packet is a Message Signal Unit (MSU) MTP2 packet.\n.IP \"\\fBsio\\fP \\fIval\\fR\"\nTrue if the packet has the Service Information Octet (SIO) field of the MTP2\nMSU header set to the value\n.IR val .\nNote that this keyword does not test whether the packet is an MSU packet.\n.IP \"\\fBdpc\\fP \\fIval\\fR\"\nTrue if the packet has the Destination Point Code (DPC) field of the MTP3\nstandard routing label set to the value\n.IR val .\nNote that this keyword does not test whether the packet is an MTP3 packet.\n.IP \"\\fBopc\\fP \\fIval\\fR\"\nTrue if the packet has the Originating Point Code (OPC) field of the MTP3\nstandard routing label set to the value\n.IR val .\nNote that this keyword does not test whether the packet is an MTP3 packet.\n.IP \"\\fBsls\\fP \\fIval\\fR\"\nTrue if the packet has the Signalling Link Selection (SLS) field of the MTP3\nstandard routing label set to the value\n.IR val .\nNote that this keyword does not test whether the packet is an MTP3 packet.\n.IP \"\\fBhfisu\\fR, \\fBhlssu\\fR, \\fBhmsu\\fR, \\fBhsio\\fR, \\fBhdpc\\fR, \\fBhopc\\fR, \\fBhsls\\fP\"\nSame as\n.BR fisu ,\n.BR lssu ,\n.BR msu ,\n.BR sio ,\n.BR dpc ,\n.B opc\nand\n.B sls\nrespectively, but only if the MTP2 link uses the extended sequence numbers\nencoding specified for high speed signalling links (HSL) in ITU-T\nRecommendation Q.703 Annex A.\n.IP  \"\\fIexpr1 relop expr2\\fR\"\nTrue if the relation holds.  \\fIRelop\\fR is one of\n.RB { > ,\n.BR < ,\n.BR >= ,\n.BR <= ,\n.BR = ,\n.BR == ,\n.BR != }\n(where\n.B =\nmeans the same as\n.BR == ).\nEach of \\fIexpr1\\fR and \\fIexpr2\\fR is an arithmetic expression composed of\ninteger constants (expressed in standard C syntax), the normal binary operators\n.RB { + ,\n.BR - ,\n.BR * ,\n.BR / ,\n.BR % ,\n.BR & ,\n.BR | ,\n.BR ^ ,\n.BR << ,\n.BR >> },\na length operator, and special packet data\naccessors.  Note that all comparisons are unsigned, so that, for example,\n0x80000000 and 0xffffffff are > 0.\n.IP\nThe\n.B %\nand\n.B ^\noperators are currently only supported for filtering in the kernel on\nparticular operating systems (for example: FreeBSD, Linux with 3.7 and later\nkernels, NetBSD); on all other systems (for example: AIX, Hurd, illumos, Solaris,\nOpenBSD), if\nthose operators are used, filtering will be done in user mode, which\nwill increase the overhead of capturing packets and may cause more\npackets to be dropped.\n.IP\nThe length operator, indicated by the keyword \\fBlen\\fP, gives the\nlength of the packet.\n.IP\nTo access data inside the packet, use the following syntax:\n.in +.5i\n.nf\n\\fIproto\\fB [ \\fIexpr\\fB : \\fIsize\\fB ]\\fR\n.fi\n.in -.5i\n.I Proto\nis one of\n.BR arp ,\n.BR atalk ,\n.BR carp ,\n.BR decnet ,\n.BR ether ,\n.BR fddi ,\n.BR icmp ,\n.BR icmp6 ,\n.BR igmp ,\n.BR igrp ,\n.BR ip ,\n.BR ip6 ,\n.BR lat ,\n.BR link ,\n.BR mopdl ,\n.BR moprc ,\n.BR pim ,\n.BR ppp ,\n.BR radio ,\n.BR rarp ,\n.BR sca ,\n.BR sctp ,\n.BR slip ,\n.BR tcp ,\n.BR tr ,\n.BR udp ,\n.B vrrp\nor\n.BR wlan ,\nand\nindicates the protocol layer for the index operation.\n.RB ( ether ,\n.BR fddi ,\n.BR link ,\n.BR ppp ,\n.BR slip ,\n.B tr\nand\n.BR wlan\nall refer to the\nlink layer. \\fBradio\\fR refers to the \"radio header\" added to some\n802.11 captures.)\nNote that \\fBtcp\\fR, \\fBudp\\fR and other upper-layer protocol types only\napply to IPv4, not IPv6 (this will be fixed in the future).\nThe byte offset, relative to the indicated protocol layer, is\ngiven by \\fIexpr\\fR.\n\\fISize\\fR is optional and indicates the number of bytes in the\nfield of interest; it can be either one, two, or four, and defaults to one.\n\nFor example, `\\fBether[\\fP0\\fB] &\\fP 1 \\fB!=\\fP 0' catches all multicast traffic.\nThe expression `\\fBip[\\fP0\\fB] &\\fP 0xf \\fB!=\\fP 5'\ncatches all IPv4 packets with options.\nThe expression\n`\\fBip[\\fP6:2\\fB] &\\fP 0x1fff \\fB=\\fP 0'\ncatches only unfragmented IPv4 datagrams and frag zero of fragmented\nIPv4 datagrams.\nThis check is implicitly applied to the\n.BR tcp ,\n.BR udp ,\n.BR icmp ,\n.BR sctp ,\n.BR igmp ,\n.BR pim ,\n.BR igrp ,\n.BR vrrp\nand\n.BR carp\nindex operations.\nFor instance, \\fBtcp[\\fP0\\fB]\\fP always means the first\nbyte of the TCP \\fIheader\\fP, and never means the first byte of an\nintervening fragment.\n.IP\nSome offsets and field values may be expressed as names rather than\nas numeric values.\nThe following protocol header field offsets are\navailable: \\fBicmptype\\fP (ICMP type field), \\fBicmp6type\\fP (ICMPv6 type field),\n\\fBicmpcode\\fP (ICMP code field), \\fBicmp6code\\fP (ICMPv6 code field) and\n\\fBtcpflags\\fP (TCP flags field).\n.IP\nThe following ICMP type field values are available:\n.BR \\%icmp-echoreply ,\n.BR \\%icmp-unreach ,\n.BR \\%icmp-sourcequench ,\n.BR \\%icmp-redirect ,\n.BR \\%icmp-echo ,\n.BR \\%icmp-routeradvert ,\n.BR \\%icmp-routersolicit ,\n.BR \\%icmp-timxceed ,\n.BR \\%icmp-paramprob ,\n.BR \\%icmp-tstamp ,\n.BR \\%icmp-tstampreply ,\n.BR \\%icmp-ireq ,\n.BR \\%icmp-ireqreply ,\n.BR \\%icmp-maskreq ,\n.BR \\%icmp-maskreply .\n.IP\nThe following ICMPv6 type field values are available:\n.BR \\%icmp6-destinationunreach ,\n.BR \\%icmp6-packettoobig ,\n.BR \\%icmp6-timeexceeded ,\n.BR \\%icmp6-parameterproblem ,\n.BR \\%icmp6-echo ,\n.BR \\%icmp6-echoreply ,\n.BR \\%icmp6-multicastlistenerquery ,\n.BR \\%icmp6-multicastlistenerreportv1 ,\n.BR \\%icmp6-multicastlistenerdone ,\n.BR \\%icmp6-routersolicit ,\n.BR \\%icmp6-routeradvert ,\n.BR \\%icmp6-neighborsolicit ,\n.BR \\%icmp6-neighboradvert ,\n.BR \\%icmp6-redirect ,\n.BR \\%icmp6-routerrenum ,\n.BR \\%icmp6-nodeinformationquery ,\n.BR \\%icmp6-nodeinformationresponse ,\n.BR \\%icmp6-ineighbordiscoverysolicit ,\n.BR \\%icmp6-ineighbordiscoveryadvert ,\n.BR \\%icmp6-multicastlistenerreportv2 ,\n.BR \\%icmp6-homeagentdiscoveryrequest ,\n.BR \\%icmp6-homeagentdiscoveryreply ,\n.BR \\%icmp6-mobileprefixsolicit ,\n.BR \\%icmp6-mobileprefixadvert ,\n.BR \\%icmp6-certpathsolicit ,\n.BR \\%icmp6-certpathadvert ,\n.BR \\%icmp6-multicastrouteradvert ,\n.BR \\%icmp6-multicastroutersolicit ,\n.BR \\%icmp6-multicastrouterterm .\n.IP\nThe following TCP flags field values are available: \\fBtcp-fin\\fP,\n\\fBtcp-syn\\fP, \\fBtcp-rst\\fP, \\fBtcp-push\\fP,\n\\fBtcp-ack\\fP, \\fBtcp-urg\\fP, \\fBtcp-ece\\fP,\n\\fBtcp-cwr\\fP.\n.LP\nPrimitives may be combined using:\n.IP\nA parenthesized group of primitives and operators.\n.IP\nNegation (`\\fB!\\fP' or `\\fBnot\\fP').\n.IP\nConcatenation (`\\fB&&\\fP' or `\\fBand\\fP').\n.IP\nAlternation (`\\fB||\\fP' or `\\fBor\\fP').\n.LP\nNegation has the highest precedence.\nAlternation and concatenation have equal precedence and associate\nleft to right.\n.LP\nIf an identifier is given without a keyword, the most recent keyword\nis assumed.\nFor example,\n.in +.5i\n.nf\n\\fBnot host\\fP vs \\fBand\\fR ace\n.fi\n.in -.5i\nis short for\n.in +.5i\n.nf\n\\fBnot host\\fP vs \\fBand host\\fR ace\n.fi\n.in -.5i\nwhich should not be confused with\n.in +.5i\n.nf\n\\fBnot (host \\fPvs\\fB or \\fPace\\fB)\\fR\n.fi\n.in -.5i\n.SH EXAMPLES\n.LP\nTo select all packets arriving at or departing from `sundown':\n.RS\n.nf\n\\fBhost\\fP sundown\n.fi\n.RE\n.LP\nTo select traffic between `helios' and either `hot' or `ace':\n.RS\n.nf\n\\fBhost\\fP helios \\fBand (\\fPhot \\fBor\\fP ace\\fB)\\fP\n.fi\n.RE\n.LP\nTo select all IPv4 packets between `ace' and any host except `helios':\n.RS\n.nf\n\\fBip host\\fP ace \\fBand not\\fP helios\n.fi\n.RE\n.LP\nTo select all traffic between local hosts and hosts at Berkeley:\n.RS\n.nf\n\\fBnet\\fP ucb-ether\n.fi\n.RE\n.LP\nTo select all FTP traffic through Internet gateway `snup':\n.RS\n.nf\n\\fBgateway\\fP snup \\fBand (port\\fP ftp \\fBor\\fP ftp-data\\fB)\\fP\n.fi\n.RE\n.LP\nTo select IPv4 traffic neither sourced from nor destined for local hosts\n(if you gateway to one other net, this stuff should never make it\nonto your local net).\n.RS\n.nf\n\\fBip and not net \\fPlocalnet\n.fi\n.RE\n.LP\nTo select the start and end packets (the SYN and FIN packets) of each\nTCP conversation that involves a non-local host.\n.RS\n.nf\n\\fBtcp[tcpflags] & (tcp-syn|tcp-fin) !=\\fP 0 \\fBand not src and dst net\\fP localnet\n.fi\n.RE\n.LP\nTo select the TCP packets with flags RST and ACK both set.\n(i.e. select only the RST and ACK flags in the flags field, and if the result\nis \"RST and ACK both set\", match)\n.RS\n.nf\n.B\ntcp[tcpflags] & (tcp-rst|tcp-ack) == (tcp-rst|tcp-ack)\n.fi\n.RE\n.LP\nTo select all IPv4 HTTP packets to and from port 80, i.e. print only\npackets that contain data, not, for example, SYN and FIN packets and\nACK-only packets.  (IPv6 is left as an exercise for the reader.)\n.RS\n.nf\n\\fBtcp port\\fP 80 \\fBand (((ip[\\fP2:2\\fB] - ((ip[\\fP0\\fB]&\\fP0xf\\fB)<<\\fP2\\fB)) - ((tcp[\\fP12\\fB]&\\fP0xf0\\fB)>>\\fP2\\fB)) != \\fP0\\fB)\n.fi\n.RE\n.LP\nTo select IPv4 packets longer than 576 bytes sent through gateway `snup':\n.RS\n.nf\n\\fBgateway\\fP snup \\fBand ip[\\fP2:2\\fB] >\\fP 576\n.fi\n.RE\n.LP\nTo select IPv4 broadcast or multicast packets that were\n.I not\nsent via Ethernet broadcast or multicast:\n.RS\n.nf\n\\fBether[\\fP0\\fB] &\\fP 1 \\fB=\\fP 0 \\fBand ip[\\fP16\\fB] >=\\fP 224\n.fi\n.RE\n.LP\nTo select all ICMP packets that are not echo requests/replies (i.e., not\nping packets):\n.RS\n.nf\n.B\nicmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply\n.B\nicmp6[icmp6type] != icmp6-echo and icmp6[icmp6type] != icmp6-echoreply\n.fi\n.RE\n.SH BACKWARD COMPATIBILITY\nThe\n.B carp\nkeyword became available in libpcap 1.2.1.\n.PP\nThe\n.BR hfisu ,\n.BR hlssu ,\n.BR hmsu ,\n.BR hsio ,\n.BR hopc ,\n.BR hdpc\nand\n.B hsls\nkeywords became available in libpcap 1.5.3.\n.PP\nThe ICMPv6 type code names, as well as the\n.B tcp-ece\nand\n.B tcp-cwr\nTCP flag names became available in libpcap 1.9.0.\n.PP\nThe\n.B geneve\nkeyword became available in libpcap 1.8.0.\n.PP\nThe\n.B ifindex\nkeyword became available in libpcap 1.10.0.\n.PP\nThe\n.B vxlan\nkeyword became available in libpcap 1.11.0.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n.SH BUGS\nTo report a security issue please send an e-mail to \\%security@tcpdump.org.\n.LP\nTo report bugs and other problems, contribute patches, request a\nfeature, provide generic feedback etc please see the file\n.I CONTRIBUTING.md\nin the libpcap source tree root.\n.LP\nFilter expressions on fields other than those in Token Ring headers will\nnot correctly handle source-routed Token Ring packets.\n.LP\nFilter expressions on fields other than those in 802.11 headers will not\ncorrectly handle 802.11 data packets with both To DS and From DS set.\n.LP\n`\\fBip6 proto\\fP'\nshould chase header chain, but at this moment it does not.\n`\\fBip6 protochain\\fP'\nis supplied for this behavior.  For example, to match IPv6 fragments:\n`\\fBip6 protochain\\fP 44'\n.LP\nArithmetic expression against transport layer headers, like \\fBtcp[0]\\fP,\ndoes not work against IPv6 packets.\nIt only looks at IPv4 packets.\n"
        },
        {
          "name": "pcap-haiku.c",
          "type": "blob",
          "size": 15.36328125,
          "content": "/*\n * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.\n * Distributed under the terms of the MIT License.\n *\n * Authors:\n *\t\tAxel Dörfler, axeld@pinc-software.de\n *\t\tJames Woodcock\n */\n\n\n#include <config.h>\n#include \"pcap-int.h\"\n\n#include <OS.h>\n\n#include <sys/socket.h>\n#include <sys/sockio.h>\n#include <sys/utsname.h>\n\n#include <net/if.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n\n\n// IFT_TUN was renamed to IFT_TUNNEL in the master branch after R1/beta4 (the\n// integer value didn't change).  Even though IFT_TUN is a no-op in versions\n// that define it, for the time being it is desirable to support compiling\n// libpcap on versions with the old macro and using it on later versions that\n// support tunnel interfaces.\n#ifndef IFT_TUNNEL\n#define IFT_TUNNEL IFT_TUN\n#endif\n\n/*\n * Private data for capturing on Haiku sockets.\n */\nstruct pcap_haiku {\n\tstruct pcap_stat\tstat;\n\tint aux_socket;\n\tstruct ifreq ifreq;\n\t// The original state of the promiscuous mode at the activation time,\n\t// if the capture should be run in promiscuous mode.\n\tint orig_promisc;\n};\n\n\nstatic int\npcap_read_haiku(pcap_t* handle, int maxPackets _U_, pcap_handler callback,\n\tu_char* userdata)\n{\n\t// Receive a single packet\n\n\tu_char* buffer = handle->buffer;\n\tssize_t bytesReceived;\n\tdo {\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\tbytesReceived = recvfrom(handle->fd, buffer, handle->bufsize, MSG_TRUNC,\n\t\t                         NULL, NULL);\n\t} while (bytesReceived < 0 && errno == B_INTERRUPTED);\n\n\t// The kernel does not implement timestamping of network packets, so\n\t// doing it ASAP in userland is the best that can be done.\n\tbigtime_t ts = real_time_clock_usecs();\n\n\tif (bytesReceived < 0) {\n\t\tif (errno == B_WOULD_BLOCK) {\n\t\t\t// there is no packet for us\n\t\t\treturn 0;\n\t\t}\n\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"recvfrom\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tstruct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;\n\t// BPF is 32-bit, which is more than sufficient for any realistic\n\t// packet size.\n\tif (bytesReceived > UINT32_MAX)\n\t\tgoto drop;\n\t// At this point, if the recvfrom() call populated its struct sockaddr\n\t// and socklen_t arguments, it would be the right time to drop packets\n\t// that have .sa_family not valid for the current DLT.  But in the\n\t// current master branch (hrev57588) this would erroneously drop some\n\t// valid packets: recvfrom(), at least for tap mode tunnels, sets the\n\t// address length to 0 for all incoming packets and sets .sa_len and\n\t// .sa_family to 0 for packets that are broadcast or multicast.  So it\n\t// cannot be done yet, if there is a good reason to do it in the first\n\t// place.\n\thandlep->stat.ps_recv++;\n\n\tbpf_u_int32 wireLength = (bpf_u_int32)bytesReceived;\n\t// As long as the buffer is large enough, the captured length is equal\n\t// to the wire length, but let's get the lengths right anyway in case\n\t// packets grow bigger or the buffer grows smaller in future and the\n\t// MSG_TRUNC effect kicks in.\n\tbpf_u_int32 captureLength =\n\t\twireLength <= handle->bufsize ? wireLength : handle->bufsize;\n\n\t// run the packet filter\n\tif (handle->fcode.bf_insns) {\n\t\t// NB: pcapint_filter() takes the wire length and the captured\n\t\t// length, not the snapshot length of the pcap_t handle.\n\t\tif (pcapint_filter(handle->fcode.bf_insns, buffer, wireLength,\n\t\t                   captureLength) == 0)\n\t\t\tgoto drop;\n\t}\n\n\t// fill in pcap_header\n\tstruct pcap_pkthdr header;\n\theader.caplen = captureLength <= (bpf_u_int32)handle->snapshot ?\n\t                captureLength :\n\t                (bpf_u_int32)handle->snapshot;\n\theader.len = wireLength;\n\theader.ts.tv_usec = ts % 1000000;\n\theader.ts.tv_sec = ts / 1000000;\n\n\t/* Call the user supplied callback function */\n\tcallback(userdata, &header, buffer);\n\treturn 1;\ndrop:\n\thandlep->stat.ps_drop++;\n\treturn 0;\n}\n\n\nstatic int\nPCAP_WARN_UNUSED_RESULT\ndgram_socket(const int af, char *errbuf)\n{\n\tint ret = socket(af, SOCK_DGRAM, 0);\n\tif (ret < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\treturn ret;\n}\n\n\nstatic int\nPCAP_WARN_UNUSED_RESULT\nioctl_ifreq(const int fd, const unsigned long op, const char *name,\n             struct ifreq *ifreq, char *errbuf)\n{\n\tif (ioctl(fd, op, ifreq, sizeof(struct ifreq)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"%s\", name);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nPCAP_WARN_UNUSED_RESULT\nget_promisc(pcap_t *handle)\n{\n\tstruct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;\n\t// SIOCGIFFLAGS would work fine for AF_LINK too.\n\tif (ioctl_ifreq(handlep->aux_socket, SIOCGIFFLAGS, \"SIOCGIFFLAGS\",\n\t                &handlep->ifreq, handle->errbuf) < 0)\n\t\treturn PCAP_ERROR;\n\treturn (handlep->ifreq.ifr_flags & IFF_PROMISC) != 0;\n}\n\n\nstatic int\nset_promisc(pcap_t *handle, const int enable)\n{\n\tstruct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;\n\tif (enable)\n\t\thandlep->ifreq.ifr_flags |= IFF_PROMISC;\n\telse\n\t\thandlep->ifreq.ifr_flags &= ~IFF_PROMISC;\n\t// SIOCSIFFLAGS works for AF_INET, but not for AF_LINK.\n\treturn ioctl_ifreq(handlep->aux_socket, SIOCSIFFLAGS, \"SIOCSIFFLAGS\",\n\t                   &handlep->ifreq, handle->errbuf);\n}\n\n\nstatic void\npcap_cleanup_haiku(pcap_t *handle)\n{\n\tstruct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;\n\tif (handlep->aux_socket >= 0) {\n\t\t// Closing the sockets has no effect on IFF_PROMISC, hence the\n\t\t// need to restore the original state on one hand and the\n\t\t// possibility of clash with other processes managing the same\n\t\t// interface flag.  Unset promiscuous mode iff the activation\n\t\t// function had set it and it is still set now.\n\t\tif (handle->opt.promisc && ! handlep->orig_promisc &&\n\t\t    get_promisc(handle))\n\t\t\t(void)set_promisc(handle, 0);\n\t\tclose(handlep->aux_socket);\n\t\thandlep->aux_socket = -1;\n\t}\n\tpcapint_cleanup_live_common(handle);\n}\n\n\nstatic int\npcap_inject_haiku(pcap_t *handle, const void *buffer _U_, int size _U_)\n{\n\t// Haiku currently (hrev57588) does not support sending raw packets.\n\t// https://dev.haiku-os.org/ticket/18810\n\tpcapint_strlcpy(handle->errbuf, \"Sending packets isn't supported yet\",\n\t\tPCAP_ERRBUF_SIZE);\n\treturn PCAP_ERROR;\n}\n\n\nstatic int\npcap_stats_haiku(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;\n\t*stats = handlep->stat;\n\t// Now ps_recv and ps_drop are accurate, but ps_ifdrop still equals to\n\t// the snapshot value from the activation time.\n\tif (ioctl_ifreq(handlep->aux_socket, SIOCGIFSTATS, \"SIOCGIFSTATS\",\n\t                &handlep->ifreq, handle->errbuf) < 0)\n\t\treturn PCAP_ERROR;\n\t// The result is subject to wrapping around the 32-bit integer space,\n\t// but that cannot be significantly improved as long as it has to fit\n\t// into a 32-bit member of pcap_stats.\n\tstats->ps_ifdrop = handlep->ifreq.ifr_stats.receive.dropped - stats->ps_ifdrop;\n\treturn 0;\n}\n\n\nstatic int\npcap_activate_haiku(pcap_t *handle)\n{\n\tstruct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;\n\tint ret = PCAP_ERROR;\n\n\t// we need a socket to talk to the networking stack\n\tif ((handlep->aux_socket = dgram_socket(AF_INET, handle->errbuf)) < 0)\n\t\tgoto error;\n\n\t// pcap_stats_haiku() will need a baseline for ps_ifdrop.\n\t// At the time of this writing SIOCGIFSTATS returns EINVAL for AF_LINK\n\t// sockets.\n\tif (ioctl_ifreq(handlep->aux_socket, SIOCGIFSTATS, \"SIOCGIFSTATS\",\n\t                &handlep->ifreq, handle->errbuf) < 0) {\n\t\t// Detect a non-existent network interface at least at the\n\t\t// first ioctl() use.\n\t\tif (errno == EINVAL)\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto error;\n\t}\n\thandlep->stat.ps_ifdrop = handlep->ifreq.ifr_stats.receive.dropped;\n\n\t// get link level interface for this interface\n\tif ((handle->fd = dgram_socket(AF_LINK, handle->errbuf)) < 0)\n\t\tgoto error;\n\n\t// Derive a DLT from the interface type.\n\t// At the time of this writing SIOCGIFTYPE cannot be used for this\n\t// purpose: it returns EINVAL for AF_LINK sockets and sets ifr_type to\n\t// 0 for AF_INET sockets.  Use the same method as Haiku ifconfig does\n\t// (SIOCGIFADDR and AF_LINK).\n\tif (ioctl_ifreq(handle->fd, SIOCGIFADDR, \"SIOCGIFADDR\",\n\t                &handlep->ifreq, handle->errbuf) < 0)\n\t\tgoto error;\n\tstruct sockaddr_dl *sdl = (struct sockaddr_dl *)&handlep->ifreq.ifr_addr;\n\tif (sdl->sdl_family != AF_LINK) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"Got AF %d instead of AF_LINK for interface \\\"%s\\\".\",\n\t\t         sdl->sdl_family, handle->opt.device);\n\t\tgoto error;\n\t}\n\tswitch (sdl->sdl_type) {\n\tcase IFT_ETHER:\n\t\t// Ethernet on all versions, also tap (L2) mode tunnels on\n\t\t// versions after R1/beta4.\n\t\thandle->linktype = DLT_EN10MB;\n\t\tbreak;\n\tcase IFT_TUNNEL:\n\t\t// Unused on R1/beta4 and earlier versions, tun (L3) mode\n\t\t// tunnels on later versions.\n\tcase IFT_LOOP:\n\t\t// The loopback interface on all versions.\n\t\t// Both IFT_TUNNEL and IFT_LOOP prepended a dummy Ethernet\n\t\t// header until hrev57585: https://dev.haiku-os.org/ticket/18801\n\t\thandle->linktype = DLT_RAW;\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"Unknown interface type 0x%0x for interface \\\"%s\\\".\",\n\t\t         sdl->sdl_type, handle->opt.device);\n\t\tgoto error;\n\t}\n\n\t// start monitoring\n\tif (ioctl_ifreq(handle->fd, SIOCSPACKETCAP, \"SIOCSPACKETCAP\",\n\t                &handlep->ifreq, handle->errbuf) < 0)\n\t\tgoto error;\n\n\thandle->selectable_fd = handle->fd;\n\thandle->read_op = pcap_read_haiku;\n\thandle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */\n\thandle->inject_op = pcap_inject_haiku;\n\thandle->stats_op = pcap_stats_haiku;\n\thandle->cleanup_op = pcap_cleanup_haiku;\n\n\t// use default hooks where possible\n\thandle->getnonblock_op = pcapint_getnonblock_fd;\n\thandle->setnonblock_op = pcapint_setnonblock_fd;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t// Although it would be trivial to size the buffer at the kernel end of\n\t// the capture socket using setsockopt() and SO_RCVBUF, there seems to\n\t// be no point in doing so: setting the size low silently drops some\n\t// packets in the kernel, setting it high does not result in a visible\n\t// improvement.  Let's leave this buffer as it is until it is clear why\n\t// it would need resizing.  Meanwhile pcap_set_buffer_size() will have\n\t// no effect on Haiku.\n\n\t// It would be wrong to size the buffer at the libpcap end of the\n\t// capture socket to the interface MTU, which limits only outgoing\n\t// packets and only at layer 3.  For example, an Ethernet interface\n\t// with ifconfig/ioctl() MTU set to 1500 ordinarily sends layer 2\n\t// packets as large as 1514 bytes and receives layer 2 packets as large\n\t// as the NIC and the driver happen to accept (e.g. 9018 bytes for\n\t// ipro1000).  This way, valid packets larger than the MTU can occur in\n\t// a capture and will arrive truncated to pcap_read_haiku() if the\n\t// buffer is not large enough.  So let's keep it large enough for most\n\t// if not all practical use cases, then pcap_read_haiku() can handle\n\t// the unlikely truncation as and if necessary.\n\thandle->bufsize = 65536;\n\n\t// allocate buffer for monitoring the device\n\thandle->buffer = (u_char*)malloc(handle->bufsize);\n\tif (handle->buffer == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\terrno, \"buffer malloc\");\n\t\tgoto error;\n\t}\n\n\tif (handle->opt.promisc) {\n\t\t// Set promiscuous mode iff required, in any case remember the\n\t\t// original state.\n\t\tif ((handlep->orig_promisc = get_promisc(handle)) < 0)\n\t\t\tgoto error;\n\t\tif (! handlep->orig_promisc && set_promisc(handle, 1) < 0)\n\t\t\treturn PCAP_WARNING_PROMISC_NOTSUP;\n\t}\n\treturn 0;\nerror:\n\tpcap_cleanup_haiku(handle);\n\treturn ret;\n}\n\n\nstatic int\nPCAP_WARN_UNUSED_RESULT\nvalidate_ifname(const char *device, char *errbuf)\n{\n\tif (strlen(device) >= IF_NAMESIZE) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"Interface name \\\"%s\\\" is too long.\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 0;\n}\n\n\n//\t#pragma mark - pcap API\n\n\nstatic int\ncan_be_bound(const char *name)\n{\n\tif (strcmp(name, \"loop\") != 0)\n\t\treturn 1;\n\n\t// In Haiku versions before hrev57010 the loopback interface allows to\n\t// start a capture, but the capture never receives any packets.\n\t//\n\t// Since compiling libpcap on one Haiku version and using the binary on\n\t// another seems to be commonplace, comparing B_HAIKU_VERSION at the\n\t// compile time would not always work as intended.  Let's at least\n\t// remove unsuitable well-known 64-bit versions (with or without\n\t// updates) from the problem space at run time.\n\tconst char *badversions[] = {\n\t\t\"hrev56578\", // R1/beta4\n\t\t\"hrev55182\", // R1/beta3\n\t\t\"hrev54154\", // R1/beta2\n\t\t\"hrev52295\", // R1/beta1\n\t\t\"hrev44702\", // R1/alpha4\n\t\tNULL\n\t};\n\tstruct utsname uts;\n\t(void)uname(&uts);\n\tfor (const char **s = badversions; *s; s++)\n\t\tif (! strncmp(uts.version, *s, strlen(*s)))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n\npcap_t *\npcapint_create_interface(const char *device, char *errorBuffer)\n{\n\tif (validate_ifname(device, errorBuffer) < 0)\n\t\treturn NULL;\n\tif (! can_be_bound(device)) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE,\n\t\t         \"Interface \\\"%s\\\" does not support capturing traffic.\", device);\n\t\treturn NULL;\n\t}\n\n\tpcap_t* handle = PCAP_CREATE_COMMON(errorBuffer, struct pcap_haiku);\n\tif (handle == NULL)\n\t\treturn NULL;\n\thandle->activate_op = pcap_activate_haiku;\n\n\tstruct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;\n\thandlep->aux_socket = -1;\n\t// validate_ifname() has already checked \"device\" length.\n\t(void)pcapint_strlcpy(handlep->ifreq.ifr_name, device, IF_NAMESIZE);\n\n\treturn handle;\n}\n\n\nstatic int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tif (validate_ifname(name, errbuf) < 0)\n\t\treturn PCAP_ERROR;\n\n\tif (*flags & PCAP_IF_LOOPBACK ||\n\t    ! strncmp(name, \"tun\", strlen(\"tun\")) ||\n\t    ! strncmp(name, \"tap\", strlen(\"tap\"))) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t *\n\t\t * Neither does it to tunnel interfaces.  A tun mode tunnel\n\t\t * can be identified by the IFT_TUNNEL value, but tap mode\n\t\t * tunnels and Ethernet interfaces both use IFT_ETHER, so let's\n\t\t * use the interface name prefix until there is a better\n\t\t * solution.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\n\tint fd = dgram_socket(AF_LINK, errbuf);\n\tif (fd < 0)\n\t\treturn PCAP_ERROR;\n\tstruct ifreq ifreq;\n\t// validate_ifname() has already checked \"name\" length.\n\t(void)pcapint_strlcpy(ifreq.ifr_name, name, IF_NAMESIZE);\n\tif (ioctl_ifreq(fd, SIOCGIFFLAGS, \"SIOCGIFFLAGS\", &ifreq, errbuf) < 0) {\n\t\tclose(fd);\n\t\treturn PCAP_ERROR;\n\t}\n\t*flags |= (ifreq.ifr_flags & IFF_LINK) ?\n\t          PCAP_IF_CONNECTION_STATUS_CONNECTED :\n\t          PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\tif (ioctl_ifreq(fd, SIOCGIFMEDIA, \"SIOCGIFMEDIA\", &ifreq, errbuf) < 0) {\n\t\tclose(fd);\n\t\treturn PCAP_ERROR;\n\t}\n\tif (IFM_TYPE(ifreq.ifr_media) == IFM_IEEE80211)\n\t\t*flags |= PCAP_IF_WIRELESS;\n\tclose(fd);\n\n\treturn (0);\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t* _allDevices, char* errorBuffer)\n{\n\treturn pcapint_findalldevs_interfaces(_allDevices, errorBuffer, can_be_bound,\n\t\tget_if_flags);\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}\n"
        },
        {
          "name": "pcap-hurd.c",
          "type": "blob",
          "size": 10.033203125,
          "content": "#define _GNU_SOURCE\n\n/* XXX Hack not to include the Mach BPF interface */\n#define _DEVICE_BPF_H_\n\n#include <config.h>\n\n#include <fcntl.h>\n#include <hurd.h>\n#include <mach.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <device/device.h>\n#include <device/device_types.h>\n#include <device/net_status.h>\n#include <net/if_ether.h>\n\n#include \"pcap-int.h\"\n\nstruct pcap_hurd {\n\tstruct pcap_stat stat;\n\tdevice_t mach_dev;\n\tmach_port_t rcv_port;\n\tint filtering_in_kernel;\n};\n\n/* Accept all packets. */\nstatic struct bpf_insn filter[] = {\n\t{ NETF_IN | NETF_OUT | NETF_BPF, 0, 0, 0 },\n\t{ BPF_RET | BPF_K, 0, 0, MAXIMUM_SNAPLEN },\n};\n\n/* device_set_filter calls net_set_filter which uses CSPF_BYTES which counts in\n * shorts, not elements, so using extra parenthesis to silence compilers which\n * believe we are computing wrong here. */\n#define FILTER_COUNT (sizeof(filter) / (sizeof(short)))\n\n/*\n * strerror() on GNU/Hurd maps Mach error messages to strings,\n * so we can use pcapint_fmt_errmsg_for_errno() to format\n * messages for them.\n */\n#define pcapint_fmt_errmsg_for_kern_return_t\tpcapint_fmt_errmsg_for_errno\n\nstatic int\nPCAP_WARN_UNUSED_RESULT\npcap_device_set_filter(pcap_t *p, filter_array_t filter_array,\n                       const mach_msg_type_number_t filter_count)\n{\n\tkern_return_t kr;\n\tstruct pcap_hurd *ph = p->priv;\n\tkr = device_set_filter(ph->mach_dev, ph->rcv_port,\n\t                       MACH_MSG_TYPE_MAKE_SEND, 0,\n\t                       filter_array, filter_count);\n\tif (! kr)\n\t\treturn 0;\n\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf, PCAP_ERRBUF_SIZE, kr,\n\t    \"device_set_filter\");\n\treturn PCAP_ERROR;\n}\n\nstatic int\npcap_setfilter_hurd(pcap_t *p, struct bpf_program *program)\n{\n\tif (! program || pcapint_install_bpf_program(p, program) < 0) {\n\t\tpcapint_strlcpy(p->errbuf, \"setfilter: invalid program\",\n\t\t                sizeof(p->errbuf));\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * The bytecode is valid and the copy in p->fcode can be used for\n\t * userland filtering if kernel filtering does not work out.\n\t *\n\t * The kernel BPF implementation supports neither BPF_MOD nor BPF_XOR,\n\t * it also fails to reject unsupported bytecode properly, so the check\n\t * must be done here.\n\t */\n\tstruct pcap_hurd *ph = p->priv;\n\tfor (u_int i = 0; i < program->bf_len; i++) {\n\t\tu_short\tc = program->bf_insns[i].code;\n\t\tif (BPF_CLASS(c) == BPF_ALU &&\n\t\t    (BPF_OP(c) == BPF_MOD || BPF_OP(c) == BPF_XOR))\n\t\t\tgoto userland;\n\t}\n\n\t/*\n\t * The kernel takes an array of 16-bit Hurd network filter commands, no\n\t * more than NET_MAX_FILTER elements.  The first four commands form a\n\t * header that says \"BPF bytecode follows\", the rest is a binary copy\n\t * of 64-bit instructions of the required BPF bytecode.\n\t */\n\tmach_msg_type_number_t cmdcount = 4 + 4 * program->bf_len;\n\tif (cmdcount > NET_MAX_FILTER)\n\t\tgoto userland;\n\n\tfilter_t cmdbuffer[NET_MAX_FILTER];\n\tmemcpy(cmdbuffer, filter, sizeof(struct bpf_insn));\n\tmemcpy(cmdbuffer + 4, program->bf_insns,\n\t       program->bf_len * sizeof(struct bpf_insn));\n\tif (pcap_device_set_filter(p, cmdbuffer, cmdcount))\n\t\tgoto userland;\n\tph->filtering_in_kernel = 1;\n\treturn 0;\n\nuserland:\n\t/*\n\t * Could not install a new kernel filter for a reason, so replace any\n\t * previous kernel filter with one that accepts all packets and lets\n\t * userland filtering do the job.  If that fails too, something is\n\t * badly broken and even userland filtering would not work correctly,\n\t * so expose the failure.\n\t */\n\tph->filtering_in_kernel = 0;\n\treturn pcap_device_set_filter(p, (filter_array_t)filter, FILTER_COUNT);\n}\n\nstatic int\npcap_read_hurd(pcap_t *p, int cnt _U_, pcap_handler callback, u_char *user)\n{\n\tstruct net_rcv_msg *msg;\n\tstruct pcap_hurd *ph;\n\tstruct pcap_pkthdr h;\n\tstruct timespec ts;\n\tint wirelen, caplen;\n\tu_char *pkt;\n\tkern_return_t kr;\n\n\tph = p->priv;\n\tmsg = (struct net_rcv_msg *)p->buffer;\n\nretry:\n\tif (p->break_loop) {\n\t\tp->break_loop = 0;\n\t\treturn PCAP_ERROR_BREAK;\n\t}\n\n\tkr = mach_msg(&msg->msg_hdr, MACH_RCV_MSG | MACH_RCV_INTERRUPT, 0,\n\t\t      p->bufsize, ph->rcv_port, MACH_MSG_TIMEOUT_NONE,\n\t\t      MACH_PORT_NULL);\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\n\tif (kr) {\n\t\tif (kr == MACH_RCV_INTERRUPTED)\n\t\t\tgoto retry;\n\n\t\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf, PCAP_ERRBUF_SIZE, kr,\n\t\t    \"mach_msg\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tph->stat.ps_recv++;\n\n\t/* XXX Ethernet support only */\n\t/*\n\t * wirelen calculation assumes the following:\n\t *   msg->packet_type.msgt_name == MACH_MSG_TYPE_BYTE\n\t *   msg->packet_type.msgt_size == 8\n\t *   msg->packet_type.msgt_number is a size in bytes\n\t */\n\twirelen = ETH_HLEN + msg->net_rcv_msg_packet_count\n\t\t  - sizeof(struct packet_header);\n\tpkt = p->buffer + offsetof(struct net_rcv_msg, packet)\n\t      + sizeof(struct packet_header) - ETH_HLEN;\n\tmemmove(pkt, p->buffer + offsetof(struct net_rcv_msg, header),\n\t\tETH_HLEN);\n\n\t/*\n\t * It seems, kernel device filters treat the K in BPF_MOD as a Boolean:\n\t * so long as it is positive, the Mach message will contain the entire\n\t * packet and wirelen will be set accordingly.  Thus the caplen value\n\t * for the callback needs to be calculated for every packet no matter\n\t * which type of filtering is in effect.\n\t *\n\t * For the userland filtering this calculated value is not an input:\n\t * buflen always equals wirelen and a userland program can examine the\n\t * entire packet, same way as a kernel program.  It is not an output\n\t * either: pcapint_filter() returns either zero or MAXIMUM_SNAPLEN.\n\t * The same principle applies to kernel filtering.\n\t */\n\tcaplen = (wirelen > p->snapshot) ? p->snapshot : wirelen;\n\n\tif (! ph->filtering_in_kernel &&\n\t    ! pcapint_filter(p->fcode.bf_insns, pkt, wirelen, wirelen)) {\n\t\tph->stat.ps_drop++;\n\t\treturn 0;\n\t}\n\n\th.ts.tv_sec = ts.tv_sec;\n\th.ts.tv_usec = ts.tv_nsec / 1000;\n\th.len = wirelen;\n\th.caplen = caplen;\n\tcallback(user, &h, pkt);\n\treturn 1;\n}\n\nstatic int\npcap_inject_hurd(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_hurd *ph;\n\tkern_return_t kr;\n\tint count;\n\n\tph = p->priv;\n\tkr = device_write(ph->mach_dev, D_NOWAIT, 0,\n\t\t\t  (io_buf_ptr_t)buf, size, &count);\n\n\tif (kr) {\n\t\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf, PCAP_ERRBUF_SIZE, kr,\n\t\t    \"device_write\");\n\t\treturn -1;\n\t}\n\n\treturn count;\n}\n\nstatic int\npcap_stats_hurd(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_hurd *ph;\n\n\tph = p->priv;\n\t*ps = ph->stat;\n\treturn 0;\n}\n\nstatic void\npcap_cleanup_hurd(pcap_t *p)\n{\n\tstruct pcap_hurd *ph;\n\n\tph = p->priv;\n\n\tif (ph->rcv_port != MACH_PORT_NULL) {\n\t\tmach_port_deallocate(mach_task_self(), ph->rcv_port);\n\t\tph->rcv_port = MACH_PORT_NULL;\n\t}\n\n\tif (ph->mach_dev != MACH_PORT_NULL) {\n\t\tdevice_close(ph->mach_dev);\n\t\tph->mach_dev = MACH_PORT_NULL;\n\t}\n\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic int\npcap_activate_hurd(pcap_t *p)\n{\n\tstruct pcap_hurd *ph;\n\tmach_port_t master;\n\tkern_return_t kr;\n\tint ret = PCAP_ERROR;\n\n\tph = p->priv;\n\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Try devnode first */\n\tmaster = file_name_lookup(p->opt.device, O_READ | O_WRITE, 0);\n\n\tif (master != MACH_PORT_NULL)\n\t\tkr = device_open(master, D_WRITE | D_READ, \"eth\", &ph->mach_dev);\n\telse {\n\t\t/* If unsuccessful, try Mach device */\n\t\tkr = get_privileged_ports(NULL, &master);\n\n\t\tif (kr) {\n\t\t\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, kr, \"get_privileged_ports\");\n\t\t\tif (kr == EPERM)\n\t\t\t\tret = PCAP_ERROR_PERM_DENIED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tkr = device_open(master, D_READ | D_WRITE, p->opt.device,\n\t\t\t\t &ph->mach_dev);\n\t}\n\n\tmach_port_deallocate(mach_task_self(), master);\n\n\tif (kr) {\n\t\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf, PCAP_ERRBUF_SIZE, kr,\n\t\t    \"device_open\");\n\t\tif (kr == ED_NO_SUCH_DEVICE) /* not ENODEV */\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto error;\n\t}\n\n\tkr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,\n\t\t\t\t&ph->rcv_port);\n\n\tif (kr) {\n\t\tpcapint_fmt_errmsg_for_kern_return_t(p->errbuf, PCAP_ERRBUF_SIZE, kr,\n\t\t    \"mach_port_allocate\");\n\t\tgoto error;\n\t}\n\n\tp->bufsize = sizeof(struct net_rcv_msg);\n\tp->buffer = malloc(p->bufsize);\n\n\tif (p->buffer == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tgoto error;\n\t}\n\n\t/*\n\t * XXX Ethernet only currently\n\t *\n\t * XXX - does \"Ethernet only currently\" mean \"the only devices\n\t * on which the Hurd supports packet capture are Ethernet\n\t * devices\", or \"it supports other devices but makes them\n\t * all provide Ethernet headers\"?\n\t *\n\t * If the latter, is there a way to determine whether the\n\t * device is a real Ethernet, so that we could offer DLT_DOCSIS,\n\t * in case you're capturing DOCSIS traffic that a Cisco Cable\n\t * Modem Termination System is putting out onto an Ethernet\n\t * (it doesn't put an Ethernet header onto the wire, it puts\n\t * raw DOCSIS frames out on the wire inside the low-level\n\t * Ethernet framing)?\n\t */\n\tp->linktype = DLT_EN10MB;\n\n\tp->read_op = pcap_read_hurd;\n\tp->inject_op = pcap_inject_hurd;\n\tp->setfilter_op = pcap_setfilter_hurd;\n\tp->stats_op = pcap_stats_hurd;\n\n\treturn 0;\n\nerror:\n\tpcap_cleanup_hurd(p);\n\treturn ret;\n}\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\tstruct pcap_hurd *ph;\n\tpcap_t *p;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_hurd);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tph = p->priv;\n\tph->mach_dev = MACH_PORT_NULL;\n\tph->rcv_port = MACH_PORT_NULL;\n\tp->activate_op = pcap_activate_hurd;\n\treturn p;\n}\n\nstatic int\ncan_be_bound(const char *name)\n{\n\t/*\n\t * On Hurd lo appears in the list of interfaces, but the call to\n\t * device_open() fails with: \"(os/device) no such device\".\n\t */\n\tif (! strcmp(name, \"lo\"))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)\n{\n\t/*\n\t * This would apply to the loopback interface if it worked.  Ethernet\n\t * interfaces appear up and running regardless of the link status.\n\t */\n\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\treturn 0;\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t                                      get_if_flags);\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn PCAP_VERSION_STRING;\n}\n"
        },
        {
          "name": "pcap-int.h",
          "type": "blob",
          "size": 19.4052734375,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef pcap_int_h\n#define\tpcap_int_h\n\n#include <stddef.h>\n\n#include <signal.h>\n\n#include <pcap/pcap.h>\n\n#include \"varattrs.h\"\n#include \"fmtutils.h\"\n\n#include <stdarg.h>\n\n#include \"portability.h\"\n\n#define PCAP_DEBUG {printf(\" [%s:%d %s] \", __FILE__, __LINE__, __func__); fflush(stdout);}\n\n/*\n * If we're compiling with Visual Studio, make sure we have at least\n * VS 2015 or later, so we have sufficient C99 support.\n *\n * XXX - verify that we have at least C99 support on UN*Xes?\n *\n * What about MinGW?  We're currently assuming\n * sufficient C99 support there.\n */\n#if defined(_MSC_VER)\n  /*\n   * Compiler is MSVC.  Make sure we have VS 2015 or later.\n   */\n  #if _MSC_VER < 1900\n    #error \"Building libpcap requires VS 2015 or later\"\n  #endif\n#endif\n\n/*\n * Version string.\n * Uses PACKAGE_VERSION from config.h.\n */\n#define PCAP_VERSION_STRING \"libpcap version \" PACKAGE_VERSION\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * If pcapint_new_api is set, we disable pcap_lookupdev(), because:\n *\n *    it's not thread-safe, and is marked as deprecated, on all\n *    platforms;\n *\n *    on Windows, it may return UTF-16LE strings, which the program\n *    might then pass to pcap_create() (or to pcap_open_live(), which\n *    then passes them to pcap_create()), requiring pcap_create() to\n *    check for UTF-16LE strings using a hack, and that hack 1)\n *    *cannot* be 100% reliable and 2) runs the risk of going past the\n *    end of the string.\n *\n * We keep it around in legacy mode for compatibility.\n *\n * We also disable the aforementioned hack in pcap_create().\n */\nextern int pcapint_new_api;\n\n/*\n * If pcapint_utf_8_mode is set, on Windows we treat strings as UTF-8.\n *\n * On UN*Xes, we assume all strings are and should be in UTF-8, regardless\n * of the setting of this flag.\n */\nextern int pcapint_utf_8_mode;\n\n/*\n * Map packet buffers with 32-bit addresses.\n */\nextern int pcapint_mmap_32bit;\n\n/*\n * Swap byte ordering of unsigned long long timestamp on a big endian\n * machine.\n */\n#define SWAPLL(ull)  ((ull & 0xff00000000000000ULL) >> 56) | \\\n                      ((ull & 0x00ff000000000000ULL) >> 40) | \\\n                      ((ull & 0x0000ff0000000000ULL) >> 24) | \\\n                      ((ull & 0x000000ff00000000ULL) >> 8)  | \\\n                      ((ull & 0x00000000ff000000ULL) << 8)  | \\\n                      ((ull & 0x0000000000ff0000ULL) << 24) | \\\n                      ((ull & 0x000000000000ff00ULL) << 40) | \\\n                      ((ull & 0x00000000000000ffULL) << 56)\n\n/*\n * Maximum snapshot length.\n *\n * Somewhat arbitrary, but chosen to be:\n *\n *    1) big enough for maximum-size Linux loopback packets (65549)\n *       and some USB packets captured with USBPcap:\n *\n *           https://desowin.org/usbpcap/\n *\n *       (> 131072, < 262144)\n *\n * and\n *\n *    2) small enough not to cause attempts to allocate huge amounts of\n *       memory; some applications might use the snapshot length in a\n *       savefile header to control the size of the buffer they allocate,\n *       so a size of, say, 2^31-1 might not work well.  (libpcap uses it\n *       as a hint, but doesn't start out allocating a buffer bigger than\n *       2 KiB, and grows the buffer as necessary, but not beyond the\n *       per-linktype maximum snapshot length.  Other code might naively\n *       use it; we want to avoid writing a too-large snapshot length,\n *       in order not to cause that code problems.)\n *\n * We don't enforce this in pcap_set_snaplen(), but we use it internally.\n */\n#define MAXIMUM_SNAPLEN\t\t262144\n\n/*\n * Locale-independent macros for testing character types.\n * These can be passed any integral value, without worrying about, for\n * example, sign-extending char values, unlike the C macros.\n */\n#define PCAP_ISDIGIT(c) \\\n\t((c) >= '0' && (c) <= '9')\n#define PCAP_ISXDIGIT(c) \\\n\t(((c) >= '0' && (c) <= '9') || \\\n\t ((c) >= 'A' && (c) <= 'F') || \\\n\t ((c) >= 'a' && (c) <= 'f'))\n\nstruct pcap_opt {\n\tchar\t*device;\n\tint\ttimeout;\t/* timeout for buffering */\n\tu_int\tbuffer_size;\n\tint\tpromisc;\n\tint\trfmon;\t\t/* monitor mode */\n\tint\timmediate;\t/* immediate mode - deliver packets as soon as they arrive */\n\tint\tnonblock;\t/* non-blocking mode - don't wait for packets to be delivered, return \"no packets available\" */\n\tint\ttstamp_type;\n\tint\ttstamp_precision;\n\n\t/*\n\t * Platform-dependent options.\n\t */\n#ifdef __linux__\n\tint\tprotocol;\t/* protocol to use when creating PF_PACKET socket */\n#endif\n#ifdef _WIN32\n\tint\tnocapture_local;/* disable NPF loopback */\n#endif\n};\n\ntypedef int\t(*activate_op_t)(pcap_t *);\ntypedef int\t(*can_set_rfmon_op_t)(pcap_t *);\ntypedef int\t(*read_op_t)(pcap_t *, int cnt, pcap_handler, u_char *);\ntypedef int\t(*next_packet_op_t)(pcap_t *, struct pcap_pkthdr *, u_char **);\ntypedef int\t(*inject_op_t)(pcap_t *, const void *, int);\ntypedef void\t(*save_current_filter_op_t)(pcap_t *, const char *);\ntypedef int\t(*setfilter_op_t)(pcap_t *, struct bpf_program *);\ntypedef int\t(*setdirection_op_t)(pcap_t *, pcap_direction_t);\ntypedef int\t(*set_datalink_op_t)(pcap_t *, int);\ntypedef int\t(*getnonblock_op_t)(pcap_t *);\ntypedef int\t(*setnonblock_op_t)(pcap_t *, int);\ntypedef int\t(*stats_op_t)(pcap_t *, struct pcap_stat *);\ntypedef void\t(*breakloop_op_t)(pcap_t *);\n#ifdef _WIN32\ntypedef struct pcap_stat *(*stats_ex_op_t)(pcap_t *, int *);\ntypedef int\t(*setbuff_op_t)(pcap_t *, int);\ntypedef int\t(*setmode_op_t)(pcap_t *, int);\ntypedef int\t(*setmintocopy_op_t)(pcap_t *, int);\ntypedef HANDLE\t(*getevent_op_t)(pcap_t *);\ntypedef int\t(*oid_get_request_op_t)(pcap_t *, bpf_u_int32, void *, size_t *);\ntypedef int\t(*oid_set_request_op_t)(pcap_t *, bpf_u_int32, const void *, size_t *);\ntypedef u_int\t(*sendqueue_transmit_op_t)(pcap_t *, pcap_send_queue *, int);\ntypedef int\t(*setuserbuffer_op_t)(pcap_t *, int);\ntypedef int\t(*live_dump_op_t)(pcap_t *, char *, int, int);\ntypedef int\t(*live_dump_ended_op_t)(pcap_t *, int);\n#endif\ntypedef void\t(*cleanup_op_t)(pcap_t *);\n\n/*\n * We put all the stuff used in the read code path at the beginning,\n * to try to keep it together in the same cache line or lines.\n */\nstruct pcap {\n\t/*\n\t * Method to call to read packets on a live capture.\n\t */\n\tread_op_t read_op;\n\n\t/*\n\t * Method to call to read the next packet from a savefile.\n\t */\n\tnext_packet_op_t next_packet_op;\n\n#ifdef _WIN32\n\tHANDLE handle;\n#else\n\tint fd;\n#endif /* _WIN32 */\n\n\t/*\n\t * Read buffer.\n\t */\n\tu_int bufsize;\n\tu_char *buffer;\n\tu_char *bp;\n\tu_int cc;\n\n\tsig_atomic_t break_loop; /* flag set to force break from packet-reading loop */\n\n\tvoid *priv;\t\t/* private data for methods */\n\n#ifdef ENABLE_REMOTE\n\tstruct pcap_samp rmt_samp;\t/* parameters related to the sampling process. */\n#endif\n\n\tint swapped;\n\tFILE *rfile;\t\t/* null if live capture, non-null if savefile */\n\tu_int fddipad;\n\tstruct pcap *next;\t/* list of open pcaps that need stuff cleared on close */\n\n\t/*\n\t * File version number; meaningful only for a savefile, but we\n\t * keep it here so that apps that (mistakenly) ask for the\n\t * version numbers will get the same zero values that they\n\t * always did.\n\t */\n\tint version_major;\n\tint version_minor;\n\n\tint snapshot;\n\tint linktype;\t\t/* Network linktype */\n\tint linktype_ext;\t/* Extended information stored in the linktype field of a file */\n\tu_int offset;\t\t/* offset for proper alignment */\n\tint activated;\t\t/* true if the capture is really started */\n\tint oldstyle;\t\t/* if we're opening with pcap_open_live() */\n\n\tstruct pcap_opt opt;\n\n\t/*\n\t * Place holder for pcap_next().\n\t */\n\tu_char *pkt;\n\n#ifdef _WIN32\n\tstruct pcap_stat stat;\t/* used for pcap_stats_ex() */\n#endif\n\n\t/* We're accepting only packets in this direction/these directions. */\n\tpcap_direction_t direction;\n\n\t/*\n\t * Flags to affect BPF code generation.\n\t */\n\tint bpf_codegen_flags;\n\n#if !defined(_WIN32)\n\tint selectable_fd;\t/* FD on which select()/poll()/epoll_wait()/kevent()/etc. can be done */\n\n\t/*\n\t * In case there either is no selectable FD, or there is but\n\t * it doesn't necessarily work (e.g., if it doesn't get notified\n\t * if the packet capture timeout expires before the buffer\n\t * fills up), this points to a timeout that should be used\n\t * in select()/poll()/epoll_wait()/kevent() call.  The pcap_t should\n\t * be put into non-blocking mode, and, if the timeout expires on\n\t * the call, an attempt should be made to read packets from all\n\t * pcap_t's with a required timeout, and the code must be\n\t * prepared not to see any packets from the attempt.\n\t */\n\tconst struct timeval *required_select_timeout;\n#endif\n\n\t/*\n\t * Placeholder for filter code if bpf not in kernel.\n\t */\n\tstruct bpf_program fcode;\n\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\n#ifdef _WIN32\n\tchar acp_errbuf[PCAP_ERRBUF_SIZE + 1];\t/* buffer for local code page error strings */\n#endif\n\tint dlt_count;\n\tu_int *dlt_list;\n\tint tstamp_type_count;\n\tu_int *tstamp_type_list;\n\tint tstamp_precision_count;\n\tu_int *tstamp_precision_list;\n\n\tstruct pcap_pkthdr pcap_header;\t/* This is needed for the pcap_next_ex() to work */\n\n\t/*\n\t * More methods.\n\t */\n\tactivate_op_t activate_op;\n\tcan_set_rfmon_op_t can_set_rfmon_op;\n\tinject_op_t inject_op;\n\tsave_current_filter_op_t save_current_filter_op;\n\tsetfilter_op_t setfilter_op;\n\tsetdirection_op_t setdirection_op;\n\tset_datalink_op_t set_datalink_op;\n\tgetnonblock_op_t getnonblock_op;\n\tsetnonblock_op_t setnonblock_op;\n\tstats_op_t stats_op;\n\tbreakloop_op_t breakloop_op;\n\n\t/*\n\t * Routine to use as callback for pcap_next()/pcap_next_ex().\n\t */\n\tpcap_handler oneshot_callback;\n\n#ifdef _WIN32\n\t/*\n\t * These are, at least currently, specific to the Win32 NPF\n\t * driver.\n\t */\n\tstats_ex_op_t stats_ex_op;\n\tsetbuff_op_t setbuff_op;\n\tsetmode_op_t setmode_op;\n\tsetmintocopy_op_t setmintocopy_op;\n\tgetevent_op_t getevent_op;\n\toid_get_request_op_t oid_get_request_op;\n\toid_set_request_op_t oid_set_request_op;\n\tsendqueue_transmit_op_t sendqueue_transmit_op;\n\tsetuserbuffer_op_t setuserbuffer_op;\n\tlive_dump_op_t live_dump_op;\n\tlive_dump_ended_op_t live_dump_ended_op;\n#endif\n\tcleanup_op_t cleanup_op;\n};\n\n/*\n * BPF code generation flags.\n */\n#define BPF_SPECIAL_VLAN_HANDLING\t0x00000001\t/* special VLAN handling for Linux */\n\n/*\n * User data structure for the one-shot callback used for pcap_next()\n * and pcap_next_ex().\n */\nstruct oneshot_userdata {\n\tstruct pcap_pkthdr *hdr;\n\tconst u_char **pkt;\n\tpcap_t *pd;\n};\n\n#ifndef min\n#define min(a, b) ((a) > (b) ? (b) : (a))\n#endif\n\nint\tpcapint_offline_read(pcap_t *, int, pcap_handler, u_char *);\n\n/*\n * Does the packet count argument to a module's read routine say\n * \"supply packets until you run out of packets\"?\n */\n#define PACKET_COUNT_IS_UNLIMITED(count)\t((count) <= 0)\n\n/*\n * Routines that most pcap implementations can use for non-blocking mode.\n */\n#if !defined(_WIN32)\nint\tpcapint_getnonblock_fd(pcap_t *);\nint\tpcapint_setnonblock_fd(pcap_t *p, int);\n#endif\n\n/*\n * Internal interfaces for \"pcap_create()\".\n *\n * \"pcapint_create_interface()\" is the routine to do a pcap_create on\n * a regular network interface.  There are multiple implementations\n * of this, one for each platform type (Linux, BPF, DLPI, etc.),\n * with the one used chosen by the configure script.\n *\n * \"pcapint_create_common()\" allocates and fills in a pcap_t, for use\n * by pcap_create routines.\n */\npcap_t\t*pcapint_create_interface(const char *, char *);\n/*\n * A format string for something-only libpcap builds, which use a stub\n * implementation of pcapint_create_interface().  It contains the substring\n * \"No such device\" (one of the standard descriptions of ENODEV) -- this way\n * tcpdump can detect a particular error condition even though pcap_create()\n * returns NULL for all errors.\n */\n#define PCAP_ENODEV_MESSAGE \"No such device (this build of libpcap supports %s devices only).\"\n\n/*\n * This wrapper takes an error buffer pointer and a type to use for the\n * private data, and calls pcapint_create_common(), passing it the error\n * buffer pointer, the size for the private data type, in bytes, and the\n * offset of the private data from the beginning of the structure, in\n * bytes.\n */\n#define PCAP_CREATE_COMMON(ebuf, type) \\\n\tpcapint_create_common(ebuf, \\\n\t    sizeof (struct { pcap_t __common; type __private; }), \\\n\t    offsetof (struct { pcap_t __common; type __private; }, __private))\npcap_t\t*pcapint_create_common(char *, size_t, size_t);\nint\tpcapint_do_addexit(pcap_t *);\nvoid\tpcapint_add_to_pcaps_to_close(pcap_t *);\nvoid\tpcapint_remove_from_pcaps_to_close(pcap_t *);\nvoid\tpcapint_cleanup_live_common(pcap_t *);\nint\tpcapint_check_activated(pcap_t *);\nvoid\tpcapint_breakloop_common(pcap_t *);\n\n/*\n * Internal interfaces for \"pcap_findalldevs()\".\n *\n * A pcap_if_list_t * is a reference to a list of devices.\n *\n * A get_if_flags_func is a platform-dependent function called to get\n * additional interface flags.\n *\n * \"pcapint_platform_finddevs()\" is the platform-dependent routine to\n * find local network interfaces.\n *\n * \"pcapint_findalldevs_interfaces()\" is a helper to find those interfaces\n * using the \"standard\" mechanisms (SIOCGIFCONF, \"getifaddrs()\", etc.).\n *\n * \"pcapint_add_dev()\" adds an entry to a pcap_if_list_t.\n *\n * \"pcapint_add_any_dev()\" adds an entry for the \"any\" device to a pcap_if_list_t.\n *\n * \"pcapint_find_dev()\" tries to find a device, by name, in a pcap_if_list_t.\n *\n * \"pcapint_find_or_add_dev()\" checks whether a device is already in a\n * pcap_if_list_t and, if not, adds an entry for it.\n */\nstruct pcap_if_list;\ntypedef struct pcap_if_list pcap_if_list_t;\ntypedef int (*get_if_flags_func)(const char *, bpf_u_int32 *, char *);\nint\tpcapint_platform_finddevs(pcap_if_list_t *, char *);\n#if !defined(_WIN32)\nint\tpcapint_findalldevs_interfaces(pcap_if_list_t *, char *,\n\t    int (*)(const char *), get_if_flags_func);\n#endif\npcap_if_t *pcapint_find_or_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,\n\t    get_if_flags_func, const char *, char *);\npcap_if_t *pcapint_find_dev(pcap_if_list_t *, const char *);\npcap_if_t *pcapint_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,\n\t    const char *, char *);\npcap_if_t *pcapint_add_any_dev(pcap_if_list_t *, char *);\nint\tpcapint_add_addr_to_dev(pcap_if_t *, struct sockaddr *, size_t,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t,\n\t    struct sockaddr *dstaddr, size_t, char *errbuf);\n#ifndef _WIN32\npcap_if_t *pcapint_find_or_add_if(pcap_if_list_t *, const char *, uint64_t,\n\t    get_if_flags_func, char *);\nint\tpcapint_add_addr_to_if(pcap_if_list_t *, const char *, uint64_t,\n\t    get_if_flags_func,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t, char *);\n#endif\n\n/*\n * Internal interfaces for \"pcap_open_offline()\" and other savefile\n * I/O routines.\n *\n * \"pcapint_open_offline_common()\" allocates and fills in a pcap_t, for use\n * by pcap_open_offline routines.\n *\n * \"pcapint_adjust_snapshot()\" adjusts the snapshot to be non-zero and\n * fit within an int.\n *\n * \"pcapint_sf_cleanup()\" closes the file handle associated with a pcap_t, if\n * appropriate, and frees all data common to all modules for handling\n * savefile types.\n *\n * \"pcapint_charset_fopen()\", in UTF-8 mode on Windows, does an fopen() that\n * treats the pathname as being in UTF-8, rather than the local\n * code page, on Windows.\n */\n\n/*\n * This wrapper takes an error buffer pointer and a type to use for the\n * private data, and calls pcapint_create_common(), passing it the error\n * buffer pointer, the size for the private data type, in bytes, and the\n * offset of the private data from the beginning of the structure, in\n * bytes.\n */\n#define PCAP_OPEN_OFFLINE_COMMON(ebuf, type) \\\n\tpcapint_open_offline_common(ebuf, \\\n\t    sizeof (struct { pcap_t __common; type __private; }), \\\n\t    offsetof (struct { pcap_t __common; type __private; }, __private))\npcap_t\t*pcapint_open_offline_common(char *ebuf, size_t total_size,\n    size_t private_data);\nbpf_u_int32 pcapint_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen);\nvoid\tpcapint_sf_cleanup(pcap_t *p);\n#ifdef _WIN32\nFILE\t*pcapint_charset_fopen(const char *path, const char *mode);\n#else\n/*\n * On other OSes, just use Boring Old fopen().\n */\n#define pcapint_charset_fopen(path, mode)\tfopen((path), (mode))\n#endif\n\n/*\n * Internal interfaces for loading code at run time.\n */\n#ifdef _WIN32\n#define pcap_code_handle_t\tHMODULE\n\npcap_code_handle_t\tpcapint_load_code(const char *);\nvoid\t\t\t*pcapint_find_function(pcap_code_handle_t, const char *);\n#endif\n\n/*\n * Internal interfaces for doing user-mode filtering of packets and\n * validating filter programs.\n */\n/*\n * Auxiliary data, for use when interpreting a filter intended for the\n * Linux kernel when the kernel rejects the filter (requiring us to\n * run it in userland).  It contains VLAN tag information.\n */\nstruct pcap_bpf_aux_data {\n\tu_short vlan_tag_present;\n\tu_short vlan_tag;\n};\n\n/*\n * Filtering routine that takes the auxiliary data as an additional\n * argument.\n */\nu_int\tpcapint_filter_with_aux_data(const struct bpf_insn *,\n    const u_char *, u_int, u_int, const struct pcap_bpf_aux_data *);\n\n/*\n * Filtering routine that doesn't.\n */\nu_int\tpcapint_filter(const struct bpf_insn *, const u_char *, u_int, u_int);\n\n/*\n * Routine to validate a BPF program.\n */\nint\tpcapint_validate_filter(const struct bpf_insn *, int);\n\n/*\n * Internal interfaces for both \"pcap_create()\" and routines that\n * open savefiles.\n *\n * \"pcapint_oneshot()\" is the standard one-shot callback for \"pcap_next()\"\n * and \"pcap_next_ex()\".\n */\nvoid\tpcapint_oneshot(u_char *, const struct pcap_pkthdr *, const u_char *);\n\nint\tpcapint_install_bpf_program(pcap_t *, struct bpf_program *);\n\nint\tpcapint_strcasecmp(const char *, const char *);\n\n/*\n * Internal interfaces for pcap_createsrcstr and pcap_parsesrcstr with\n * the additional bit of information regarding SSL support (rpcap:// vs.\n * rpcaps://).\n */\nint\tpcapint_createsrcstr_ex(char *, int, const char *, const char *,\n    const char *, const char *, unsigned char, char *);\nint\tpcapint_parsesrcstr_ex(const char *, int *, char *, char *,\n    char *, char *, unsigned char *, char *);\n\n#ifdef YYDEBUG\nextern int pcap_debug;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "pcap-libdlpi.c",
          "type": "blob",
          "size": 12.9150390625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * This code contributed by Sagun Shakya (sagun.shakya@sun.com)\n */\n/*\n * Packet capture routines for DLPI using libdlpi under SunOS 5.11.\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/bufmod.h>\n#include <sys/stream.h>\n#include <libdlpi.h>\n#include <errno.h>\n#include <memory.h>\n#include <stropts.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n#include \"dlpisubs.h\"\n\n/* Forwards. */\nstatic int dlpromiscon(pcap_t *, bpf_u_int32);\nstatic int pcap_read_libdlpi(pcap_t *, int, pcap_handler, u_char *);\nstatic int pcap_inject_libdlpi(pcap_t *, const void *, int);\nstatic void pcap_libdlpi_err(const char *, const char *, int, char *);\nstatic void pcap_cleanup_libdlpi(pcap_t *);\n\n/*\n * list_interfaces() will list all the network links that are\n * available on a system.\n */\nstatic boolean_t list_interfaces(const char *, void *);\n\ntypedef struct linknamelist {\n\tchar\tlinkname[DLPI_LINKNAME_MAX];\n\tstruct linknamelist *lnl_next;\n} linknamelist_t;\n\ntypedef struct linkwalk {\n\tlinknamelist_t\t*lw_list;\n\tint\t\tlw_err;\n} linkwalk_t;\n\n/*\n * The caller of this function should free the memory allocated\n * for each linknamelist_t \"entry\" allocated.\n */\nstatic boolean_t\nlist_interfaces(const char *linkname, void *arg)\n{\n\tlinkwalk_t\t*lwp = arg;\n\tlinknamelist_t\t*entry;\n\n\tif ((entry = calloc(1, sizeof(linknamelist_t))) == NULL) {\n\t\tlwp->lw_err = ENOMEM;\n\t\treturn (B_TRUE);\n\t}\n\t(void) pcapint_strlcpy(entry->linkname, linkname, DLPI_LINKNAME_MAX);\n\n\tif (lwp->lw_list == NULL) {\n\t\tlwp->lw_list = entry;\n\t} else {\n\t\tentry->lnl_next = lwp->lw_list;\n\t\tlwp->lw_list = entry;\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\npcap_activate_libdlpi(pcap_t *p)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint status = 0;\n\tint retv;\n\tdlpi_handle_t dh;\n\tdlpi_info_t dlinfo;\n\n\t/*\n\t * Enable Solaris raw and passive DLPI extensions;\n\t * dlpi_open() will not fail if the underlying link does not support\n\t * passive mode. See dlpi(7P) for details.\n\t */\n\tretv = dlpi_open(p->opt.device, &dh, DLPI_RAW|DLPI_PASSIVE);\n\tif (retv != DLPI_SUCCESS) {\n\t\tif (retv == DLPI_ELINKNAMEINVAL || retv == DLPI_ENOLINK) {\n\t\t\t/*\n\t\t\t * There's nothing more to say, so clear the\n\t\t\t * error message.\n\t\t\t */\n\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tp->errbuf[0] = '\\0';\n\t\t} else if (retv == DL_SYSERR &&\n\t\t    (errno == EPERM || errno == EACCES)) {\n\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to open DLPI device failed with %s - root privilege may be required\",\n\t\t\t    (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t} else {\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_open\", retv,\n\t\t\t    p->errbuf);\n\t\t}\n\t\treturn (status);\n\t}\n\tpd->dlpi_hd = dh;\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * This device exists, but we don't support monitor mode\n\t\t * any platforms that support DLPI.\n\t\t */\n\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\tgoto bad;\n\t}\n\n\t/* Bind with DLPI_ANY_SAP. */\n\tif ((retv = dlpi_bind(pd->dlpi_hd, DLPI_ANY_SAP, 0)) != DLPI_SUCCESS) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_bind\", retv, p->errbuf);\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Enable promiscuous mode. */\n\tif (p->opt.promisc) {\n\t\tretv = dlpromiscon(p, DL_PROMISC_PHYS);\n\t\tif (retv < 0) {\n\t\t\t/*\n\t\t\t * \"You don't have permission to capture on\n\t\t\t * this device\" and \"you don't have permission\n\t\t\t * to capture in promiscuous mode on this\n\t\t\t * device\" are different; let the user know,\n\t\t\t * so if they can't get permission to\n\t\t\t * capture in promiscuous mode, they can at\n\t\t\t * least try to capture in non-promiscuous\n\t\t\t * mode.\n\t\t\t *\n\t\t\t * XXX - you might have to capture in\n\t\t\t * promiscuous mode to see outgoing packets.\n\t\t\t */\n\t\t\tif (retv == PCAP_ERROR_PERM_DENIED)\n\t\t\t\tstatus = PCAP_ERROR_PROMISC_PERM_DENIED;\n\t\t\telse\n\t\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t} else {\n\t\t/* Try to enable multicast. */\n\t\tretv = dlpromiscon(p, DL_PROMISC_MULTI);\n\t\tif (retv < 0) {\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* Try to enable SAP promiscuity. */\n\tretv = dlpromiscon(p, DL_PROMISC_SAP);\n\tif (retv < 0) {\n\t\t/*\n\t\t * Not fatal, since the DL_PROMISC_PHYS mode worked.\n\t\t * Report it as a warning, however.\n\t\t */\n\t\tif (p->opt.promisc)\n\t\t\tstatus = PCAP_WARNING;\n\t\telse {\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* Determine link type.  */\n\tif ((retv = dlpi_info(pd->dlpi_hd, &dlinfo, 0)) != DLPI_SUCCESS) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_info\", retv, p->errbuf);\n\t\tgoto bad;\n\t}\n\n\tif (pcap_process_mactype(p, dlinfo.di_mactype) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\tp->fd = dlpi_fd(pd->dlpi_hd);\n\n\t/* Push and configure bufmod. */\n\tif (pcap_conf_bufmod(p, p->snapshot) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Flush the read side.\n\t */\n\tif (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"FLUSHR\");\n\t\tgoto bad;\n\t}\n\n\t/* Allocate data buffer. */\n\tif (pcap_alloc_databuf(p) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"p->fd\" is a FD for a STREAMS device, so \"select()\" and\n\t * \"poll()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\tp->read_op = pcap_read_libdlpi;\n\tp->inject_op = pcap_inject_libdlpi;\n\tp->setfilter_op = pcapint_install_bpf_program;\t/* No kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented */\n\tp->set_datalink_op = NULL;\t/* Can't change data link type */\n\tp->getnonblock_op = pcapint_getnonblock_fd;\n\tp->setnonblock_op = pcapint_setnonblock_fd;\n\tp->stats_op = pcap_stats_dlpi;\n\tp->cleanup_op = pcap_cleanup_libdlpi;\n\n\treturn (status);\nbad:\n\tpcap_cleanup_libdlpi(p);\n\treturn (status);\n}\n\n#define STRINGIFY(n)\t#n\n\nstatic int\ndlpromiscon(pcap_t *p, bpf_u_int32 level)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint retv;\n\tint err;\n\n\tretv = dlpi_promiscon(pd->dlpi_hd, level);\n\tif (retv != DLPI_SUCCESS) {\n\t\tif (retv == DL_SYSERR &&\n\t\t    (errno == EPERM || errno == EACCES)) {\n\t\t\tif (level == DL_PROMISC_PHYS) {\n\t\t\t\terr = PCAP_ERROR_PROMISC_PERM_DENIED;\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Attempt to set promiscuous mode failed with %s - root privilege may be required\",\n\t\t\t\t    (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t\t} else {\n\t\t\t\terr = PCAP_ERROR_PERM_DENIED;\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Attempt to set %s mode failed with %s - root privilege may be required\",\n\t\t\t\t    (level == DL_PROMISC_MULTI) ? \"multicast\" : \"SAP promiscuous\",\n\t\t\t\t    (errno == EPERM) ? \"EPERM\" : \"EACCES\");\n\t\t\t}\n\t\t} else {\n\t\t\terr = PCAP_ERROR;\n\t\t\tpcap_libdlpi_err(p->opt.device,\n\t\t\t    \"dlpi_promiscon\" STRINGIFY(level),\n\t\t\t    retv, p->errbuf);\n\t\t}\n\t\treturn (err);\n\t}\n\treturn (0);\n}\n\n/*\n * Presumably everything returned by dlpi_walk() is a DLPI device,\n * so there's no work to be done here to check whether name refers\n * to a DLPI device.\n */\nstatic int\nis_dlpi_interface(const char *name _U_)\n{\n\treturn (1);\n}\n\nstatic int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}\n\n/*\n * In Solaris, the \"standard\" mechanism\" i.e SIOCGLIFCONF will only find\n * network links that are plumbed and are up. dlpi_walk(3DLPI) will find\n * additional network links present in the system.\n */\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint retv = 0;\n\n\tlinknamelist_t\t*entry, *next;\n\tlinkwalk_t\tlw = {NULL, 0};\n\tint\t\tsave_errno;\n\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcapint_findalldevs_interfaces(devlistp, errbuf,\n\t    is_dlpi_interface, get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n\t/* dlpi_walk() for loopback will be added here. */\n\n\t/*\n\t * Find all DLPI devices in the current zone.\n\t *\n\t * XXX - will pcapint_findalldevs_interfaces() find any devices\n\t * outside the current zone?  If not, the only reason to call\n\t * it would be to get the interface addresses.\n\t */\n\tdlpi_walk(list_interfaces, &lw, 0);\n\n\tif (lw.lw_err != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    lw.lw_err, \"dlpi_walk\");\n\t\tretv = -1;\n\t\tgoto done;\n\t}\n\n\t/* Add linkname if it does not exist on the list. */\n\tfor (entry = lw.lw_list; entry != NULL; entry = entry->lnl_next) {\n\t\t/*\n\t\t * If it isn't already in the list of devices, try to\n\t\t * add it.\n\t\t */\n\t\tif (pcapint_find_or_add_dev(devlistp, entry->linkname, 0, get_if_flags,\n\t\t    NULL, errbuf) == NULL)\n\t\t\tretv = -1;\n\t}\ndone:\n\tsave_errno = errno;\n\tfor (entry = lw.lw_list; entry != NULL; entry = next) {\n\t\tnext = entry->lnl_next;\n\t\tfree(entry);\n\t}\n\terrno = save_errno;\n\n\treturn (retv);\n}\n\n/*\n * Read data received on DLPI handle. Returns -2 if told to terminate, else\n * returns the number of packets read.\n */\nstatic int\npcap_read_libdlpi(pcap_t *p, int count, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint len;\n\tu_char *bufp;\n\tsize_t msglen;\n\tint retv;\n\n\tlen = p->cc;\n\tif (len != 0) {\n\t\tbufp = p->bp;\n\t\tgoto process_pkts;\n\t}\n\tdo {\n\t\t/* Has \"pcap_breakloop()\" been called? */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it has,\n\t\t\t * and return -2 to indicate that we were told to\n\t\t\t * break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn (-2);\n\t\t}\n\n\t\tmsglen = p->bufsize;\n\t\tbufp = p->buffer + p->offset;\n\n\t\tretv = dlpi_recv(pd->dlpi_hd, NULL, NULL, bufp,\n\t\t    &msglen, -1, NULL);\n\t\tif (retv != DLPI_SUCCESS) {\n\t\t\t/*\n\t\t\t * This is most likely a call to terminate out of the\n\t\t\t * loop. So, do not return an error message, instead\n\t\t\t * check if \"pcap_breakloop()\" has been called above.\n\t\t\t */\n\t\t\tif (retv == DL_SYSERR && errno == EINTR) {\n\t\t\t\tlen = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpcap_libdlpi_err(dlpi_linkname(pd->dlpi_hd),\n\t\t\t    \"dlpi_recv\", retv, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t\tlen = msglen;\n\t} while (len == 0);\n\nprocess_pkts:\n\treturn (pcap_process_pkts(p, callback, user, count, bufp, len));\n}\n\nstatic int\npcap_inject_libdlpi(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint retv;\n\n\tretv = dlpi_send(pd->dlpi_hd, NULL, 0, buf, size, NULL);\n\tif (retv != DLPI_SUCCESS) {\n\t\tpcap_libdlpi_err(dlpi_linkname(pd->dlpi_hd), \"dlpi_send\", retv,\n\t\t    p->errbuf);\n\t\treturn (-1);\n\t}\n\t/*\n\t * dlpi_send(3DLPI) does not provide a way to return the number of\n\t * bytes sent on the wire. Based on the fact that DLPI_SUCCESS was\n\t * returned we are assuming 'size' bytes were sent.\n\t */\n\treturn (size);\n}\n\n/*\n * Close dlpi handle.\n */\nstatic void\npcap_cleanup_libdlpi(pcap_t *p)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\n\tif (pd->dlpi_hd != NULL) {\n\t\tdlpi_close(pd->dlpi_hd);\n\t\tpd->dlpi_hd = NULL;\n\t\tp->fd = -1;\n\t}\n\tpcapint_cleanup_live_common(p);\n}\n\n/*\n * Write error message to buffer.\n */\nstatic void\npcap_libdlpi_err(const char *linkname, const char *func, int err, char *errbuf)\n{\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"libpcap: %s failed on %s: %s\",\n\t    func, linkname, dlpi_strerror(err));\n}\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_dlpi);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_libdlpi;\n\treturn (p);\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}\n"
        },
        {
          "name": "pcap-linktype.manmisc.in",
          "type": "blob",
          "size": 2.7978515625,
          "content": ".\\\" Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP-LINKTYPE @MAN_MISC_INFO@ \"1 October 2024\"\n.SH NAME\npcap-linktype \\- link-layer header types supported by libpcap\n.SH DESCRIPTION\nFor a live capture or ``savefile'', libpcap supplies, as the return\nvalue of the\n.BR pcap_datalink (3PCAP)\nroutine, a value that indicates the type of link-layer header at the\nbeginning of the packets it provides.  This is not necessarily the type\nof link-layer header that the packets being captured have on the network\nfrom which they're being captured; for example, packets from an IEEE\n802.11 network might be provided by libpcap with Ethernet headers that\nthe network adapter or the network adapter driver generates from the\n802.11 headers.  The names for those values begin with\n.BR DLT_ ,\nso they are sometimes called \"DLT_ values\".\n.PP\nThe\n.BR pcap_datalink_val_to_name (3PCAP)\nand\n.BR pcap_datalink_name_to_val (3PCAP)\nroutines can be used to translate between\n.B DLT_\nvalues and names.  Some capture devices support more than one link-layer\nheader type.  The\n.BR pcap_list_datalinks (3PCAP)\nroutine can be used to retrieve the supported link-layer header types of\na capture device and the\n.BR pcap_set_datalink (3PCAP)\nroutine can be used to change the link-layer header type of a capture\ndevice.\n.PP\nThe values stored in the link-layer header type field in the savefile\nheader are, in most but not all cases, the same as the values returned\nby\n.BR pcap_datalink ().\nThe names for those values begin with\n.BR LINKTYPE_ .\n.PP\nThe link-layer header types supported by libpcap are described at\nhttps://www.tcpdump.org/linktypes.html .\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap-linux.c",
          "type": "blob",
          "size": 162.90625,
          "content": "/*\n *  pcap-linux.c: Packet capture interface to the Linux kernel\n *\n *  Copyright (c) 2000 Torsten Landschoff <torsten@debian.org>\n *\t\t       Sebastian Krahmer  <krahmer@cs.uni-potsdam.de>\n *\n *  License: BSD\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *  3. The names of the authors may not be used to endorse or promote\n *     products derived from this software without specific prior\n *     written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n *  Modifications:     Added PACKET_MMAP support\n *                     Paolo Abeni <paolo.abeni@email.it>\n *                     Added TPACKET_V3 support\n *                     Gabor Tatarka <gabor.tatarka@ericsson.com>\n *\n *                     based on previous works of:\n *                     Simon Patarin <patarin@cs.unibo.it>\n *                     Phil Wood <cpw@lanl.gov>\n *\n * Monitor-mode support for mac80211 includes code taken from the iw\n * command; the copyright notice for that code is\n *\n * Copyright (c) 2007, 2008\tJohannes Berg\n * Copyright (c) 2007\t\tAndy Lutomirski\n * Copyright (c) 2007\t\tMike Kershaw\n * Copyright (c) 2008\t\tGábor Stefanik\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <config.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <limits.h>\n#include <endian.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/utsname.h>\n#include <sys/mman.h>\n#include <linux/if.h>\n#include <linux/if_packet.h>\n#include <linux/sockios.h>\n#include <linux/ethtool.h>\n#include <netinet/in.h>\n#include <linux/if_ether.h>\n\n#include <linux/if_arp.h>\n#ifndef ARPHRD_IEEE802154\n  // Linux before 2.6.31\n  #define ARPHRD_IEEE802154 804\n#endif\n#ifndef ARPHRD_IEEE802154_MONITOR\n  // Linux before 3.5\n  #define ARPHRD_IEEE802154_MONITOR 805\n#endif\n#ifndef ARPHRD_NETLINK\n  // Linux before 3.11\n  #define ARPHRD_NETLINK 824\n#endif\n#ifndef ARPHRD_6LOWPAN\n  // Linux before 3.14\n  #define ARPHRD_6LOWPAN 825\n#endif\n#ifndef ARPHRD_VSOCKMON\n  // Linux before 4.12\n  #define ARPHRD_VSOCKMON 826\n#endif\n#ifndef ARPHRD_LAPD\n  /*\n   * ARPHRD_LAPD is unofficial and randomly allocated, if reallocation\n   * is needed, please report it to <daniele@orlandi.com>\n   */\n  #define ARPHRD_LAPD 8445\n#endif\n\n#include <poll.h>\n#include <dirent.h>\n#include <sys/eventfd.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-util.h\"\n#include \"pcap-snf.h\"\n#include \"pcap/sll.h\"\n#include \"pcap/vlan.h\"\n#include \"pcap/can_socketcan.h\"\n\n#include \"diag-control.h\"\n\n/*\n * We require TPACKET_V2 support.\n */\n#ifndef TPACKET2_HDRLEN\n#error \"Libpcap will only work if TPACKET_V2 is supported; you must build for a 2.6.27 or later kernel\"\n#endif\n\n/* check for memory mapped access availability. We assume every needed\n * struct is defined if the macro TPACKET_HDRLEN is defined, because it\n * uses many ring related structs and macros */\n#ifdef TPACKET3_HDRLEN\n# define HAVE_TPACKET3\n#endif /* TPACKET3_HDRLEN */\n\n/*\n * Not all compilers that are used to compile code to run on Linux have\n * these builtins.  For example, older versions of GCC don't, and at\n * least some people are doing cross-builds for MIPS with older versions\n * of GCC.\n */\n#ifndef HAVE___ATOMIC_LOAD_N\n#define __atomic_load_n(ptr, memory_model)\t\t(*(ptr))\n#endif\n#ifndef HAVE___ATOMIC_STORE_N\n#define __atomic_store_n(ptr, val, memory_model)\t*(ptr) = (val)\n#endif\n\n#define packet_mmap_acquire(pkt) \\\n\t(__atomic_load_n(&pkt->tp_status, __ATOMIC_ACQUIRE) != TP_STATUS_KERNEL)\n#define packet_mmap_release(pkt) \\\n\t(__atomic_store_n(&pkt->tp_status, TP_STATUS_KERNEL, __ATOMIC_RELEASE))\n#define packet_mmap_v3_acquire(pkt) \\\n\t(__atomic_load_n(&pkt->hdr.bh1.block_status, __ATOMIC_ACQUIRE) != TP_STATUS_KERNEL)\n#define packet_mmap_v3_release(pkt) \\\n\t(__atomic_store_n(&pkt->hdr.bh1.block_status, TP_STATUS_KERNEL, __ATOMIC_RELEASE))\n\n#include <linux/types.h>\n#include <linux/filter.h>\n\n#ifdef HAVE_LINUX_NET_TSTAMP_H\n#include <linux/net_tstamp.h>\n#endif\n\n/*\n * For checking whether a device is a bonding device.\n */\n#include <linux/if_bonding.h>\n\n/*\n * Got libnl?\n */\n#ifdef HAVE_LIBNL\n#include <linux/nl80211.h>\n\n#include <netlink/genl/genl.h>\n#include <netlink/genl/family.h>\n#include <netlink/genl/ctrl.h>\n#include <netlink/msg.h>\n#include <netlink/attr.h>\n#endif /* HAVE_LIBNL */\n\n#ifndef HAVE_SOCKLEN_T\ntypedef int\t\tsocklen_t;\n#endif\n\n#define MAX_LINKHEADER_SIZE\t256\n\n/*\n * When capturing on all interfaces we use this as the buffer size.\n * Should be bigger then all MTUs that occur in real life.\n * 64kB should be enough for now.\n */\n#define BIGGER_THAN_ALL_MTUS\t(64*1024)\n\n/*\n * Private data for capturing on Linux PF_PACKET sockets.\n */\nstruct pcap_linux {\n\tlong long sysfs_dropped; /* packets reported dropped by /sys/class/net/{if_name}/statistics/rx_{missed,fifo}_errors */\n\tstruct pcap_stat stat;\n\n\tchar\t*device;\t/* device name */\n\tint\tfilter_in_userland; /* must filter in userland */\n\tu_int\tblocks_to_filter_in_userland;\n\tint\tmust_do_on_close; /* stuff we must do when we close */\n\tint\ttimeout;\t/* timeout for buffering */\n\tint\tcooked;\t\t/* using SOCK_DGRAM rather than SOCK_RAW */\n\tint\tifindex;\t/* interface index of device we're bound to */\n\tint\tlo_ifindex;\t/* interface index of the loopback device */\n\tint\tnetdown;\t/* we got an ENETDOWN and haven't resolved it */\n\tbpf_u_int32 oldmode;\t/* mode to restore when turning monitor mode off */\n\tchar\t*mondevice;\t/* mac80211 monitor device we created */\n\tu_char\t*mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t\tmmapbuflen;\t/* size of region */\n\tint\tvlan_offset;\t/* offset at which to insert vlan tags; if -1, don't insert */\n\tu_int\ttp_version;\t/* version of tpacket_hdr for mmaped ring */\n\tu_int\ttp_hdrlen;\t/* hdrlen of tpacket_hdr for mmaped ring */\n\tu_char\t*oneshot_buffer; /* buffer for copy of packet */\n\tint\tpoll_timeout;\t/* timeout to use in poll() */\n#ifdef HAVE_TPACKET3\n\tunsigned char *current_packet; /* Current packet within the TPACKET_V3 block. Move to next block if NULL. */\n\tint packets_left; /* Unhandled packets left within the block from previous call to pcap_read_linux_mmap_v3 in case of TPACKET_V3. */\n#endif\n\tint poll_breakloop_fd; /* fd to an eventfd to break from blocking operations */\n};\n\n/*\n * Stuff to do when we close.\n */\n#define MUST_DELETE_MONIF\t0x00000001\t/* delete monitor-mode interface */\n\n/*\n * Prototypes for internal functions and methods.\n */\nstatic int is_wifi(const char *);\nstatic int pcap_activate_linux(pcap_t *);\nstatic int setup_socket(pcap_t *, int);\nstatic int setup_mmapped(pcap_t *);\nstatic int pcap_can_set_rfmon_linux(pcap_t *);\nstatic int pcap_inject_linux(pcap_t *, const void *, int);\nstatic int pcap_stats_linux(pcap_t *, struct pcap_stat *);\nstatic int pcap_setfilter_linux(pcap_t *, struct bpf_program *);\nstatic int pcap_setdirection_linux(pcap_t *, pcap_direction_t);\nstatic int pcap_set_datalink_linux(pcap_t *, int);\n\nunion thdr {\n\tstruct tpacket2_hdr\t\t*h2;\n#ifdef HAVE_TPACKET3\n\tstruct tpacket_block_desc\t*h3;\n#endif\n\tu_char\t\t\t\t*raw;\n};\n\n#define RING_GET_FRAME_AT(h, offset) (((u_char **)h->buffer)[(offset)])\n#define RING_GET_CURRENT_FRAME(h) RING_GET_FRAME_AT(h, h->offset)\n\nstatic void destroy_ring(pcap_t *handle);\nstatic int create_ring(pcap_t *handle);\nstatic int prepare_tpacket_socket(pcap_t *handle);\nstatic int pcap_read_linux_mmap_v2(pcap_t *, int, pcap_handler , u_char *);\n#ifdef HAVE_TPACKET3\nstatic int pcap_read_linux_mmap_v3(pcap_t *, int, pcap_handler , u_char *);\n#endif\nstatic int pcap_setnonblock_linux(pcap_t *p, int nonblock);\nstatic int pcap_getnonblock_linux(pcap_t *p);\nstatic void pcapint_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,\n    const u_char *bytes);\n\n/*\n * In pre-3.0 kernels, the tp_vlan_tci field is set to whatever the\n * vlan_tci field in the skbuff is.  0 can either mean \"not on a VLAN\"\n * or \"on VLAN 0\".  There is no flag set in the tp_status field to\n * distinguish between them.\n *\n * In 3.0 and later kernels, if there's a VLAN tag present, the tp_vlan_tci\n * field is set to the VLAN tag, and the TP_STATUS_VLAN_VALID flag is set\n * in the tp_status field, otherwise the tp_vlan_tci field is set to 0 and\n * the TP_STATUS_VLAN_VALID flag isn't set in the tp_status field.\n *\n * With a pre-3.0 kernel, we cannot distinguish between packets with no\n * VLAN tag and packets on VLAN 0, so we will mishandle some packets, and\n * there's nothing we can do about that.\n *\n * So, on those systems, which never set the TP_STATUS_VLAN_VALID flag, we\n * continue the behavior of earlier libpcaps, wherein we treated packets\n * with a VLAN tag of 0 as being packets without a VLAN tag rather than packets\n * on VLAN 0.  We do this by treating packets with a tp_vlan_tci of 0 and\n * with the TP_STATUS_VLAN_VALID flag not set in tp_status as not having\n * VLAN tags.  This does the right thing on 3.0 and later kernels, and\n * continues the old unfixably-imperfect behavior on pre-3.0 kernels.\n *\n * If TP_STATUS_VLAN_VALID isn't defined, we test it as the 0x10 bit; it\n * has that value in 3.0 and later kernels.\n */\n#ifdef TP_STATUS_VLAN_VALID\n  #define VLAN_VALID(hdr, hv)\t((hv)->tp_vlan_tci != 0 || ((hdr)->tp_status & TP_STATUS_VLAN_VALID))\n#else\n  /*\n   * This is being compiled on a system that lacks TP_STATUS_VLAN_VALID,\n   * so we test with the value it has in the 3.0 and later kernels, so\n   * we can test it if we're running on a system that has it.  (If we're\n   * running on a system that doesn't have it, it won't be set in the\n   * tp_status field, so the tests of it will always fail; that means\n   * we behave the way we did before we introduced this macro.)\n   */\n  #define VLAN_VALID(hdr, hv)\t((hv)->tp_vlan_tci != 0 || ((hdr)->tp_status & 0x10))\n#endif\n\n#ifdef TP_STATUS_VLAN_TPID_VALID\n# define VLAN_TPID(hdr, hv)\t(((hv)->tp_vlan_tpid || ((hdr)->tp_status & TP_STATUS_VLAN_TPID_VALID)) ? (hv)->tp_vlan_tpid : ETH_P_8021Q)\n#else\n# define VLAN_TPID(hdr, hv)\tETH_P_8021Q\n#endif\n\n/*\n * Required select timeout if we're polling for an \"interface disappeared\"\n * indication - 1 millisecond.\n */\nstatic const struct timeval netdown_timeout = {\n\t0, 1000\t\t/* 1000 microseconds = 1 millisecond */\n};\n\n/*\n * Wrap some ioctl calls\n */\nstatic int\tiface_get_id(int fd, const char *device, char *ebuf);\nstatic int\tiface_get_mtu(int fd, const char *device, char *ebuf);\nstatic int\tiface_get_arptype(int fd, const char *device, char *ebuf);\nstatic int\tiface_bind(int fd, int ifindex, char *ebuf, int protocol);\nstatic int\tenter_rfmon_mode(pcap_t *handle, int sock_fd,\n    const char *device);\nstatic int\tiface_get_ts_types(const char *device, pcap_t *handle,\n    char *ebuf);\nstatic int\tiface_get_offload(pcap_t *handle);\n\nstatic int\tfix_program(pcap_t *handle, struct sock_fprog *fcode);\nstatic int\tfix_offset(pcap_t *handle, struct bpf_insn *p);\nstatic int\tset_kernel_filter(pcap_t *handle, struct sock_fprog *fcode);\nstatic int\treset_kernel_filter(pcap_t *handle);\n\nstatic struct sock_filter\ttotal_insn\n\t= BPF_STMT(BPF_RET | BPF_K, 0);\nstatic struct sock_fprog\ttotal_fcode\n\t= { 1, &total_insn };\n\nstatic int\tiface_dsa_get_proto_info(const char *device, pcap_t *handle);\n\npcap_t *\npcapint_create_interface(const char *device, char *ebuf)\n{\n\tpcap_t *handle;\n\n\thandle = PCAP_CREATE_COMMON(ebuf, struct pcap_linux);\n\tif (handle == NULL)\n\t\treturn NULL;\n\n\thandle->activate_op = pcap_activate_linux;\n\thandle->can_set_rfmon_op = pcap_can_set_rfmon_linux;\n\n\t/*\n\t * See what time stamp types we support.\n\t */\n\tif (iface_get_ts_types(device, handle, ebuf) == -1) {\n\t\tpcap_close(handle);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t *\n\t * XXX - with adapter-supplied time stamps, can we choose\n\t * microsecond or nanosecond time stamps on arbitrary\n\t * adapters?\n\t */\n\thandle->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (handle->tstamp_precision_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tpcap_close(handle);\n\t\treturn NULL;\n\t}\n\thandle->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\thandle->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\thandle->tstamp_precision_count = 2;\n\n\t/*\n\t * Start out with the breakloop handle not open; we don't\n\t * need it until we're activated and ready to capture.\n\t */\n\tstruct pcap_linux *handlep = handle->priv;\n\thandlep->poll_breakloop_fd = -1;\n\n\treturn handle;\n}\n\n#ifdef HAVE_LIBNL\n/*\n * If interface {if_name} is a mac80211 driver, the file\n * /sys/class/net/{if_name}/phy80211 is a symlink to\n * /sys/class/ieee80211/{phydev_name}, for some {phydev_name}.\n *\n * On Fedora 9, with a 2.6.26.3-29 kernel, my Zydas stick, at\n * least, has a \"wmaster0\" device and a \"wlan0\" device; the\n * latter is the one with the IP address.  Both show up in\n * \"tcpdump -D\" output.  Capturing on the wmaster0 device\n * captures with 802.11 headers.\n *\n * airmon-ng searches through /sys/class/net for devices named\n * monN, starting with mon0; as soon as one *doesn't* exist,\n * it chooses that as the monitor device name.  If the \"iw\"\n * command exists, it does\n *\n *    iw dev {if_name} interface add {monif_name} type monitor\n *\n * where {monif_name} is the monitor device.  It then (sigh) sleeps\n * .1 second, and then configures the device up.  Otherwise, if\n * /sys/class/ieee80211/{phydev_name}/add_iface is a file, it writes\n * {mondev_name}, without a newline, to that file, and again (sigh)\n * sleeps .1 second, and then iwconfig's that device into monitor\n * mode and configures it up.  Otherwise, you can't do monitor mode.\n *\n * All these devices are \"glued\" together by having the\n * /sys/class/net/{if_name}/phy80211 links pointing to the same\n * place, so, given a wmaster, wlan, or mon device, you can\n * find the other devices by looking for devices with\n * the same phy80211 link.\n *\n * To turn monitor mode off, delete the monitor interface,\n * either with\n *\n *    iw dev {monif_name} interface del\n *\n * or by sending {monif_name}, with no NL, down\n * /sys/class/ieee80211/{phydev_name}/remove_iface\n *\n * Note: if you try to create a monitor device named \"monN\", and\n * there's already a \"monN\" device, it fails, as least with\n * the netlink interface (which is what iw uses), with a return\n * value of -ENFILE.  (Return values are negative errnos.)  We\n * could probably use that to find an unused device.\n *\n * Yes, you can have multiple monitor devices for a given\n * physical device.\n */\n\n/*\n * Is this a mac80211 device?  If so, fill in the physical device path and\n * return 1; if not, return 0.  On an error, fill in handle->errbuf and\n * return PCAP_ERROR.\n */\nstatic int\nget_mac80211_phydev(pcap_t *handle, const char *device, char *phydev_path,\n    size_t phydev_max_pathlen)\n{\n\tchar *pathstr;\n\tssize_t bytes_read;\n\n\t/*\n\t * Generate the path string for the symlink to the physical device.\n\t */\n\tif (asprintf(&pathstr, \"/sys/class/net/%s/phy80211\", device) == -1) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: Can't generate path name string for /sys/class/net device\",\n\t\t    device);\n\t\treturn PCAP_ERROR;\n\t}\n\tbytes_read = readlink(pathstr, phydev_path, phydev_max_pathlen);\n\tif (bytes_read == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\t/*\n\t\t\t * This either means that the directory\n\t\t\t * /sys/class/net/{device} exists but doesn't\n\t\t\t * have anything named \"phy80211\" in it,\n\t\t\t * in which case it's not a mac80211 device,\n\t\t\t * or that the directory doesn't exist,\n\t\t\t * in which case the device doesn't exist.\n\t\t\t *\n\t\t\t * Directly check whether the directory\n\t\t\t * exists.\n\t\t\t */\n\t\t\tstruct stat statb;\n\n\t\t\tfree(pathstr);\n\t\t\tif (asprintf(&pathstr, \"/sys/class/net/%s\", device) == -1) {\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: Can't generate path name string for /sys/class/net device\",\n\t\t\t\t    device);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tif (stat(pathstr, &statb) == -1) {\n\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\t/*\n\t\t\t\t\t * No such device.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"%s: %s doesn't exist\",\n\t\t\t\t\t    device, pathstr);\n\t\t\t\t\tfree(pathstr);\n\t\t\t\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\t}\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: Can't stat %s: %s\",\n\t\t\t\t    device, pathstr, strerror(errno));\n\t\t\t\tfree(pathstr);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Path to the directory that would contain\n\t\t\t * \"phy80211\" exists, but \"phy80211\" doesn't\n\t\t\t * exist; that means it's not a mac80211\n\t\t\t * device.\n\t\t\t */\n\t\t\tfree(pathstr);\n\t\t\treturn 0;\n\t\t}\n\t\tif (errno == EINVAL) {\n\t\t\t/*\n\t\t\t * Exists, but it's not a symlink; assume that\n\t\t\t * means it's not a mac80211 device.\n\t\t\t */\n\t\t\tfree(pathstr);\n\t\t\treturn 0;\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't readlink %s\", device, pathstr);\n\t\tfree(pathstr);\n\t\treturn PCAP_ERROR;\n\t}\n\tfree(pathstr);\n\tphydev_path[bytes_read] = '\\0';\n\treturn 1;\n}\n\nstruct nl80211_state {\n\tstruct nl_sock *nl_sock;\n\tstruct nl_cache *nl_cache;\n\tstruct genl_family *nl80211;\n};\n\nstatic int\nnl80211_init(pcap_t *handle, struct nl80211_state *state, const char *device)\n{\n\tint err;\n\n\tstate->nl_sock = nl_socket_alloc();\n\tif (!state->nl_sock) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink handle\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (genl_connect(state->nl_sock)) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to connect to generic netlink\", device);\n\t\tgoto out_handle_destroy;\n\t}\n\n\terr = genl_ctrl_alloc_cache(state->nl_sock, &state->nl_cache);\n\tif (err < 0) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate generic netlink cache: %s\",\n\t\t    device, nl_geterror(-err));\n\t\tgoto out_handle_destroy;\n\t}\n\n\tstate->nl80211 = genl_ctrl_search_by_name(state->nl_cache, \"nl80211\");\n\tif (!state->nl80211) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl80211 not found\", device);\n\t\tgoto out_cache_free;\n\t}\n\n\treturn 0;\n\nout_cache_free:\n\tnl_cache_free(state->nl_cache);\nout_handle_destroy:\n\tnl_socket_free(state->nl_sock);\n\treturn PCAP_ERROR;\n}\n\nstatic void\nnl80211_cleanup(struct nl80211_state *state)\n{\n\tgenl_family_put(state->nl80211);\n\tnl_cache_free(state->nl_cache);\n\tnl_socket_free(state->nl_sock);\n}\n\nstatic int\ndel_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice);\n\nstatic int\nif_type_cb(struct nl_msg *msg, void* arg)\n{\n\tstruct nlmsghdr* ret_hdr = nlmsg_hdr(msg);\n\tstruct nlattr *tb_msg[NL80211_ATTR_MAX + 1];\n\tint *type = (int*)arg;\n\n\tstruct genlmsghdr *gnlh = (struct genlmsghdr*) nlmsg_data(ret_hdr);\n\n\tnla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\n\t\tgenlmsg_attrlen(gnlh, 0), NULL);\n\n\tif (!tb_msg[NL80211_ATTR_IFTYPE]) {\n\t\treturn NL_SKIP;\n\t}\n\n\t*type = nla_get_u32(tb_msg[NL80211_ATTR_IFTYPE]);\n\treturn NL_STOP;\n}\n\nstatic int\nget_if_type(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, int *type)\n{\n\tint ifindex;\n\tstruct nl_msg *msg;\n\tint err;\n\n\tifindex = iface_get_id(sock_fd, device, handle->errbuf);\n\tif (ifindex == -1)\n\t\treturn PCAP_ERROR;\n\n\tstruct nl_cb *cb = nl_cb_alloc(NL_CB_DEFAULT);\n\tnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, if_type_cb, (void*)type);\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink msg\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tgenlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,\n\t\t    0, NL80211_CMD_GET_INTERFACE, 0);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);\n\n\terr = nl_send_auto_complete(state->nl_sock, msg);\n\tif (err < 0) {\n\t\tif (err == -NLE_FAILURE) {\n\t\t\t/*\n\t\t\t * Device not available; our caller should just\n\t\t\t * keep trying.  (libnl 2.x maps ENFILE to\n\t\t\t * NLE_FAILURE; it can also map other errors\n\t\t\t * to that, but there's not much we can do\n\t\t\t * about that.)\n\t\t\t */\n\t\t\tnlmsg_free(msg);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Real failure, not just \"that device is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: nl_send_auto_complete failed getting interface type: %s\",\n\t\t\t    device, nl_geterror(-err));\n\t\t\tnlmsg_free(msg);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\tnl_recvmsgs(state->nl_sock, cb);\n\n\t/*\n\t * Success.\n\t */\n\tnlmsg_free(msg);\n\n\treturn 1;\n\nnla_put_failure:\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: nl_put failed getting interface type\",\n\t    device);\n\tnlmsg_free(msg);\n\treturn PCAP_ERROR;\n}\n\nstatic int\nadd_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ifindex;\n\tstruct nl_msg *msg;\n\tint err;\n\n\tifindex = iface_get_id(sock_fd, device, handle->errbuf);\n\tif (ifindex == -1)\n\t\treturn PCAP_ERROR;\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink msg\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tgenlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,\n\t\t    0, NL80211_CMD_NEW_INTERFACE, 0);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);\nDIAG_OFF_NARROWING\n\tNLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, mondevice);\nDIAG_ON_NARROWING\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);\n\n\terr = nl_send_auto_complete(state->nl_sock, msg);\n\tif (err < 0) {\n\t\tif (err == -NLE_FAILURE) {\n\t\t\t/*\n\t\t\t * Device not available; our caller should just\n\t\t\t * keep trying.  (libnl 2.x maps ENFILE to\n\t\t\t * NLE_FAILURE; it can also map other errors\n\t\t\t * to that, but there's not much we can do\n\t\t\t * about that.)\n\t\t\t */\n\t\t\tnlmsg_free(msg);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Real failure, not just \"that device is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: nl_send_auto_complete failed adding %s interface: %s\",\n\t\t\t    device, mondevice, nl_geterror(-err));\n\t\t\tnlmsg_free(msg);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\terr = nl_wait_for_ack(state->nl_sock);\n\tif (err < 0) {\n\t\tif (err == -NLE_FAILURE) {\n\t\t\t/*\n\t\t\t * Device not available; our caller should just\n\t\t\t * keep trying.  (libnl 2.x maps ENFILE to\n\t\t\t * NLE_FAILURE; it can also map other errors\n\t\t\t * to that, but there's not much we can do\n\t\t\t * about that.)\n\t\t\t */\n\t\t\tnlmsg_free(msg);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Real failure, not just \"that device is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: nl_wait_for_ack failed adding %s interface: %s\",\n\t\t\t    device, mondevice, nl_geterror(-err));\n\t\t\tnlmsg_free(msg);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tnlmsg_free(msg);\n\n\t/*\n\t * Try to remember the monitor device.\n\t */\n\thandlep->mondevice = strdup(mondevice);\n\tif (handlep->mondevice == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"strdup\");\n\t\t/*\n\t\t * Get rid of the monitor device.\n\t\t */\n\t\tdel_mon_if(handle, sock_fd, state, device, mondevice);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 1;\n\nnla_put_failure:\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: nl_put failed adding %s interface\",\n\t    device, mondevice);\n\tnlmsg_free(msg);\n\treturn PCAP_ERROR;\n}\n\nstatic int\ndel_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice)\n{\n\tint ifindex;\n\tstruct nl_msg *msg;\n\tint err;\n\n\tifindex = iface_get_id(sock_fd, mondevice, handle->errbuf);\n\tif (ifindex == -1)\n\t\treturn PCAP_ERROR;\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink msg\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tgenlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,\n\t\t    0, NL80211_CMD_DEL_INTERFACE, 0);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);\n\n\terr = nl_send_auto_complete(state->nl_sock, msg);\n\tif (err < 0) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl_send_auto_complete failed deleting %s interface: %s\",\n\t\t    device, mondevice, nl_geterror(-err));\n\t\tnlmsg_free(msg);\n\t\treturn PCAP_ERROR;\n\t}\n\terr = nl_wait_for_ack(state->nl_sock);\n\tif (err < 0) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl_wait_for_ack failed deleting %s interface: %s\",\n\t\t    device, mondevice, nl_geterror(-err));\n\t\tnlmsg_free(msg);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tnlmsg_free(msg);\n\treturn 1;\n\nnla_put_failure:\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: nl_put failed deleting %s interface\",\n\t    device, mondevice);\n\tnlmsg_free(msg);\n\treturn PCAP_ERROR;\n}\n#endif /* HAVE_LIBNL */\n\nstatic int pcap_protocol(pcap_t *handle)\n{\n\tint protocol;\n\n\tprotocol = handle->opt.protocol;\n\tif (protocol == 0)\n\t\tprotocol = ETH_P_ALL;\n\n\treturn htons(protocol);\n}\n\nstatic int\npcap_can_set_rfmon_linux(pcap_t *handle)\n{\n#ifdef HAVE_LIBNL\n\tchar phydev_path[PATH_MAX+1];\n\tint ret;\n#endif\n\n\tif (strcmp(handle->opt.device, \"any\") == 0) {\n\t\t/*\n\t\t * Monitor mode makes no sense on the \"any\" device.\n\t\t */\n\t\treturn 0;\n\t}\n\n#ifdef HAVE_LIBNL\n\t/*\n\t * Bleah.  There doesn't seem to be a way to ask a mac80211\n\t * device, through libnl, whether it supports monitor mode;\n\t * we'll just check whether the device appears to be a\n\t * mac80211 device and, if so, assume the device supports\n\t * monitor mode.\n\t */\n\tret = get_mac80211_phydev(handle, handle->opt.device, phydev_path,\n\t    PATH_MAX);\n\tif (ret < 0)\n\t\treturn ret;\t/* error */\n\tif (ret == 1)\n\t\treturn 1;\t/* mac80211 device */\n#endif\n\n\treturn 0;\n}\n\n/*\n * Grabs the number of missed packets by the interface from\n * /sys/class/net/{if_name}/statistics/rx_{missed,fifo}_errors.\n *\n * Compared to /proc/net/dev this avoids counting software drops,\n * but may be unimplemented and just return 0.\n * The author has found no straightforward way to check for support.\n */\nstatic long long int\nlinux_get_stat(const char * if_name, const char * stat) {\n\tssize_t bytes_read;\n\tint fd;\n\tchar buffer[PATH_MAX];\n\n\tsnprintf(buffer, sizeof(buffer), \"/sys/class/net/%s/statistics/%s\", if_name, stat);\n\tfd = open(buffer, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tbytes_read = read(fd, buffer, sizeof(buffer) - 1);\n\tclose(fd);\n\tif (bytes_read == -1)\n\t\treturn 0;\n\tbuffer[bytes_read] = '\\0';\n\n\treturn strtoll(buffer, NULL, 10);\n}\n\nstatic long long int\nlinux_if_drops(const char * if_name)\n{\n\tlong long int missed = linux_get_stat(if_name, \"rx_missed_errors\");\n\tlong long int fifo = linux_get_stat(if_name, \"rx_fifo_errors\");\n\treturn missed + fifo;\n}\n\n\n/*\n * Monitor mode is kind of interesting because we have to reset the\n * interface before exiting. The problem can't really be solved without\n * some daemon taking care of managing usage counts.  If we put the\n * interface into monitor mode, we set a flag indicating that we must\n * take it out of that mode when the interface is closed, and, when\n * closing the interface, if that flag is set we take it out of monitor\n * mode.\n */\n\nstatic void\tpcap_cleanup_linux( pcap_t *handle )\n{\n\tstruct pcap_linux *handlep = handle->priv;\n#ifdef HAVE_LIBNL\n\tstruct nl80211_state nlstate;\n\tint ret;\n#endif /* HAVE_LIBNL */\n\n\tif (handlep->must_do_on_close != 0) {\n\t\t/*\n\t\t * There's something we have to do when closing this\n\t\t * pcap_t.\n\t\t */\n#ifdef HAVE_LIBNL\n\t\tif (handlep->must_do_on_close & MUST_DELETE_MONIF) {\n\t\t\tret = nl80211_init(handle, &nlstate, handlep->device);\n\t\t\tif (ret >= 0) {\n\t\t\t\tret = del_mon_if(handle, handle->fd, &nlstate,\n\t\t\t\t    handlep->device, handlep->mondevice);\n\t\t\t\tnl80211_cleanup(&nlstate);\n\t\t\t}\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't delete monitor interface %s (%s).\\n\"\n\t\t\t\t    \"Please delete manually.\\n\",\n\t\t\t\t    handlep->mondevice, handle->errbuf);\n\t\t\t}\n\t\t}\n#endif /* HAVE_LIBNL */\n\n\t\t/*\n\t\t * Take this pcap out of the list of pcaps for which we\n\t\t * have to take the interface out of some mode.\n\t\t */\n\t\tpcapint_remove_from_pcaps_to_close(handle);\n\t}\n\n\tif (handle->fd != -1) {\n\t\t/*\n\t\t * Destroy the ring buffer (assuming we've set it up),\n\t\t * and unmap it if it's mapped.\n\t\t */\n\t\tdestroy_ring(handle);\n\t}\n\n\tif (handlep->oneshot_buffer != NULL) {\n\t\tmunmap(handlep->oneshot_buffer, handle->snapshot);\n\t\thandlep->oneshot_buffer = NULL;\n\t}\n\n\tif (handlep->mondevice != NULL) {\n\t\tfree(handlep->mondevice);\n\t\thandlep->mondevice = NULL;\n\t}\n\tif (handlep->device != NULL) {\n\t\tfree(handlep->device);\n\t\thandlep->device = NULL;\n\t}\n\n\tif (handlep->poll_breakloop_fd != -1) {\n\t\tclose(handlep->poll_breakloop_fd);\n\t\thandlep->poll_breakloop_fd = -1;\n\t}\n\tpcapint_cleanup_live_common(handle);\n}\n\n#ifdef HAVE_TPACKET3\n/*\n * Some versions of TPACKET_V3 have annoying bugs/misfeatures\n * around which we have to work.  Determine if we have those\n * problems or not.\n * 3.19 is the first release with a fixed version of\n * TPACKET_V3.  We treat anything before that as\n * not having a fixed version; that may really mean\n * it has *no* version.\n */\nstatic int has_broken_tpacket_v3(void)\n{\n\tstruct utsname utsname;\n\tconst char *release;\n\tlong major, minor;\n\tint matches, verlen;\n\n\t/* No version information, assume broken. */\n\tif (uname(&utsname) == -1)\n\t\treturn 1;\n\trelease = utsname.release;\n\n\t/* A malformed version, ditto. */\n\tmatches = sscanf(release, \"%ld.%ld%n\", &major, &minor, &verlen);\n\tif (matches != 2)\n\t\treturn 1;\n\tif (release[verlen] != '.' && release[verlen] != '\\0')\n\t\treturn 1;\n\n\t/* OK, a fixed version. */\n\tif (major > 3 || (major == 3 && minor >= 19))\n\t\treturn 0;\n\n\t/* Too old :( */\n\treturn 1;\n}\n#endif\n\n/*\n * Set the timeout to be used in poll() with memory-mapped packet capture.\n */\nstatic void\nset_poll_timeout(struct pcap_linux *handlep)\n{\n#ifdef HAVE_TPACKET3\n\tint broken_tpacket_v3 = has_broken_tpacket_v3();\n#endif\n\tif (handlep->timeout == 0) {\n#ifdef HAVE_TPACKET3\n\t\t/*\n\t\t * XXX - due to a set of (mis)features in the TPACKET_V3\n\t\t * kernel code prior to the 3.19 kernel, blocking forever\n\t\t * with a TPACKET_V3 socket can, if few packets are\n\t\t * arriving and passing the socket filter, cause most\n\t\t * packets to be dropped.  See libpcap issue #335 for the\n\t\t * full painful story.\n\t\t *\n\t\t * The workaround is to have poll() time out very quickly,\n\t\t * so we grab the frames handed to us, and return them to\n\t\t * the kernel, ASAP.\n\t\t */\n\t\tif (handlep->tp_version == TPACKET_V3 && broken_tpacket_v3)\n\t\t\thandlep->poll_timeout = 1;\t/* don't block for very long */\n\t\telse\n#endif\n\t\t\thandlep->poll_timeout = -1;\t/* block forever */\n\t} else if (handlep->timeout > 0) {\n#ifdef HAVE_TPACKET3\n\t\t/*\n\t\t * For TPACKET_V3, the timeout is handled by the kernel,\n\t\t * so block forever; that way, we don't get extra timeouts.\n\t\t * Don't do that if we have a broken TPACKET_V3, though.\n\t\t */\n\t\tif (handlep->tp_version == TPACKET_V3 && !broken_tpacket_v3)\n\t\t\thandlep->poll_timeout = -1;\t/* block forever, let TPACKET_V3 wake us up */\n\t\telse\n#endif\n\t\t\thandlep->poll_timeout = handlep->timeout;\t/* block for that amount of time */\n\t} else {\n\t\t/*\n\t\t * Non-blocking mode; we call poll() to pick up error\n\t\t * indications, but we don't want it to wait for\n\t\t * anything.\n\t\t */\n\t\thandlep->poll_timeout = 0;\n\t}\n}\n\nstatic void pcap_breakloop_linux(pcap_t *handle)\n{\n\tpcapint_breakloop_common(handle);\n\tstruct pcap_linux *handlep = handle->priv;\n\n\tuint64_t value = 1;\n\n\tif (handlep->poll_breakloop_fd != -1) {\n\t\t/*\n\t\t * XXX - pcap_breakloop() doesn't have a return value,\n\t\t * so we can't indicate an error.\n\t\t */\nDIAG_OFF_WARN_UNUSED_RESULT\n\t\t(void)write(handlep->poll_breakloop_fd, &value, sizeof(value));\nDIAG_ON_WARN_UNUSED_RESULT\n\t}\n}\n\n/*\n * Set the offset at which to insert VLAN tags.\n * That should be the offset of the type field.\n */\nstatic void\nset_vlan_offset(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\tswitch (handle->linktype) {\n\n\tcase DLT_EN10MB:\n\t\t/*\n\t\t * The type field is after the destination and source\n\t\t * MAC address.\n\t\t */\n\t\thandlep->vlan_offset = 2 * ETH_ALEN;\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\t/*\n\t\t * The type field is in the last 2 bytes of the\n\t\t * DLT_LINUX_SLL header.\n\t\t */\n\t\thandlep->vlan_offset = SLL_HDR_LEN - 2;\n\t\tbreak;\n\n\tdefault:\n\t\thandlep->vlan_offset = -1; /* unknown */\n\t\tbreak;\n\t}\n}\n\nstatic int\npcap_activate_linux(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tconst char\t*device;\n\tint\t\tis_any_device;\n\tstruct ifreq\tifr;\n\tint\t\tstatus;\n\tint\t\tret;\n\n\tdevice = handle->opt.device;\n\n\t/*\n\t * Start out assuming no warnings.\n\t */\n\tstatus = 0;\n\n\t/*\n\t * Make sure the name we were handed will fit into the ioctls we\n\t * might perform on the device; if not, return a \"No such device\"\n\t * indication, as the Linux kernel shouldn't support creating\n\t * a device whose name won't fit into those ioctls.\n\t *\n\t * \"Will fit\" means \"will fit, complete with a null terminator\",\n\t * so if the length, which does *not* include the null terminator,\n\t * is greater than *or equal to* the size of the field into which\n\t * we'll be copying it, that won't fit.\n\t */\n\tif (strlen(device) >= sizeof(ifr.ifr_name)) {\n\t\t/*\n\t\t * There's nothing more to say, so clear the error\n\t\t * message.\n\t\t */\n\t\thandle->errbuf[0] = '\\0';\n\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\thandlep->device\t= strdup(device);\n\tif (handlep->device == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"strdup\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * The \"any\" device is a special device which causes us not\n\t * to bind to a particular device and thus to look at all\n\t * devices.\n\t */\n\tis_any_device = (strcmp(device, \"any\") == 0);\n\tif (is_any_device) {\n\t\tif (handle->opt.promisc) {\n\t\t\thandle->opt.promisc = 0;\n\t\t\t/* Just a warning. */\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Promiscuous mode not supported on the \\\"any\\\" device\");\n\t\t\tstatus = PCAP_WARNING_PROMISC_NOTSUP;\n\t\t}\n\t}\n\n\t/* copy timeout value */\n\thandlep->timeout = handle->opt.timeout;\n\n\t/*\n\t * If we're in promiscuous mode, then we probably want\n\t * to see when the interface drops packets too, so get an\n\t * initial count from\n\t * /sys/class/net/{if_name}/statistics/rx_{missed,fifo}_errors\n\t */\n\tif (handle->opt.promisc)\n\t\thandlep->sysfs_dropped = linux_if_drops(handlep->device);\n\n\t/*\n\t * If the \"any\" device is specified, try to open a SOCK_DGRAM.\n\t * Otherwise, open a SOCK_RAW.\n\t */\n\tret = setup_socket(handle, is_any_device);\n\tif (ret < 0) {\n\t\t/*\n\t\t * Fatal error; the return value is the error code,\n\t\t * and handle->errbuf has been set to an appropriate\n\t\t * error message.\n\t\t */\n\t\tstatus = ret;\n\t\tgoto fail;\n\t}\n\tif (ret > 0) {\n\t\t/*\n\t\t * We got a warning; return that, as handle->errbuf\n\t\t * might have been overwritten by this warning.\n\t\t */\n\t\tstatus = ret;\n\t}\n\n\t/*\n\t * Success (possibly with a warning).\n\t *\n\t * First, try to allocate an event FD for breakloop, if\n\t * we're not going to start in non-blocking mode.\n\t */\n\tif (!handle->opt.nonblock) {\n\t\thandlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK);\n\t\tif (handlep->poll_breakloop_fd == -1) {\n\t\t\t/*\n\t\t\t * Failed.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"could not open eventfd\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Succeeded.\n\t * Try to set up memory-mapped access.\n\t */\n\tret = setup_mmapped(handle);\n\tif (ret < 0) {\n\t\t/*\n\t\t * We failed to set up to use it, or the\n\t\t * kernel supports it, but we failed to\n\t\t * enable it.  The return value is the\n\t\t * error status to return and, if it's\n\t\t * PCAP_ERROR, handle->errbuf contains\n\t\t * the error message.\n\t\t */\n\t\tstatus = ret;\n\t\tgoto fail;\n\t}\n\tif (ret > 0) {\n\t\t/*\n\t\t * We got a warning; return that, as handle->errbuf\n\t\t * might have been overwritten by this warning.\n\t\t */\n\t\tstatus = ret;\n\t}\n\n\t/*\n\t * We succeeded.  status has been set to the status to return,\n\t * which might be 0, or might be a PCAP_WARNING_ value.\n\t */\n\t/*\n\t * Now that we have activated the mmap ring, we can\n\t * set the correct protocol.\n\t */\n\tif ((ret = iface_bind(handle->fd, handlep->ifindex,\n\t    handle->errbuf, pcap_protocol(handle))) != 0) {\n\t\tstatus = ret;\n\t\tgoto fail;\n\t}\n\n\thandle->inject_op = pcap_inject_linux;\n\thandle->setfilter_op = pcap_setfilter_linux;\n\thandle->setdirection_op = pcap_setdirection_linux;\n\thandle->set_datalink_op = pcap_set_datalink_linux;\n\thandle->setnonblock_op = pcap_setnonblock_linux;\n\thandle->getnonblock_op = pcap_getnonblock_linux;\n\thandle->cleanup_op = pcap_cleanup_linux;\n\thandle->stats_op = pcap_stats_linux;\n\thandle->breakloop_op = pcap_breakloop_linux;\n\n\tswitch (handlep->tp_version) {\n\n\tcase TPACKET_V2:\n\t\thandle->read_op = pcap_read_linux_mmap_v2;\n\t\tbreak;\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\thandle->read_op = pcap_read_linux_mmap_v3;\n\t\tbreak;\n#endif\n\t}\n\thandle->oneshot_callback = pcapint_oneshot_linux;\n\thandle->selectable_fd = handle->fd;\n\n\treturn status;\n\nfail:\n\tpcap_cleanup_linux(handle);\n\treturn status;\n}\n\nstatic int\npcap_set_datalink_linux(pcap_t *handle, int dlt)\n{\n\thandle->linktype = dlt;\n\n\t/*\n\t * Update the offset at which to insert VLAN tags for the\n\t * new link-layer type.\n\t */\n\tset_vlan_offset(handle);\n\n\treturn 0;\n}\n\n/*\n * linux_check_direction()\n *\n * Do checks based on packet direction.\n */\nstatic inline int\nlinux_check_direction(const pcap_t *handle, const struct sockaddr_ll *sll)\n{\n\tstruct pcap_linux\t*handlep = handle->priv;\n\n\tif (sll->sll_pkttype == PACKET_OUTGOING) {\n\t\t/*\n\t\t * Outgoing packet.\n\t\t * If this is from the loopback device, reject it;\n\t\t * we'll see the packet as an incoming packet as well,\n\t\t * and we don't want to see it twice.\n\t\t */\n\t\tif (sll->sll_ifindex == handlep->lo_ifindex)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If this is an outgoing CAN or CAN FD frame, and\n\t\t * the user doesn't only want outgoing packets,\n\t\t * reject it; CAN devices and drivers, and the CAN\n\t\t * stack, always arrange to loop back transmitted\n\t\t * packets, so they also appear as incoming packets.\n\t\t * We don't want duplicate packets, and we can't\n\t\t * easily distinguish packets looped back by the CAN\n\t\t * layer than those received by the CAN layer, so we\n\t\t * eliminate this packet instead.\n\t\t *\n\t\t * We check whether this is a CAN or CAN FD frame\n\t\t * by checking whether the device's hardware type\n\t\t * is ARPHRD_CAN.\n\t\t */\n\t\tif (sll->sll_hatype == ARPHRD_CAN &&\n\t\t     handle->direction != PCAP_D_OUT)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If the user only wants incoming packets, reject it.\n\t\t */\n\t\tif (handle->direction == PCAP_D_IN)\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * Incoming packet.\n\t\t * If the user only wants outgoing packets, reject it.\n\t\t */\n\t\tif (handle->direction == PCAP_D_OUT)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * Check whether the device to which the pcap_t is bound still exists.\n * We do so by asking what address the socket is bound to, and checking\n * whether the ifindex in the address is -1, meaning \"that device is gone\",\n * or some other value, meaning \"that device still exists\".\n */\nstatic int\ndevice_still_exists(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tstruct sockaddr_ll addr;\n\tsocklen_t addr_len;\n\n\t/*\n\t * If handlep->ifindex is -1, the socket isn't bound, meaning\n\t * we're capturing on the \"any\" device; that device never\n\t * disappears.  (It should also never be configured down, so\n\t * we shouldn't even get here, but let's make sure.)\n\t */\n\tif (handlep->ifindex == -1)\n\t\treturn (1);\t/* it's still here */\n\n\t/*\n\t * OK, now try to get the address for the socket.\n\t */\n\taddr_len = sizeof (addr);\n\tif (getsockname(handle->fd, (struct sockaddr *) &addr, &addr_len) == -1) {\n\t\t/*\n\t\t * Error - report an error and return -1.\n\t\t */\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getsockname failed\");\n\t\treturn (-1);\n\t}\n\tif (addr.sll_ifindex == -1) {\n\t\t/*\n\t\t * This means the device went away.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * The device presumably just went down.\n\t */\n\treturn (1);\n}\n\nstatic int\npcap_inject_linux(pcap_t *handle, const void *buf, int size)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ret;\n\n\tif (handlep->ifindex == -1) {\n\t\t/*\n\t\t * We don't support sending on the \"any\" device.\n\t\t */\n\t\tpcapint_strlcpy(handle->errbuf,\n\t\t    \"Sending packets isn't supported on the \\\"any\\\" device\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\treturn (-1);\n\t}\n\n\tif (handlep->cooked) {\n\t\t/*\n\t\t * We don't support sending on cooked-mode sockets.\n\t\t *\n\t\t * XXX - how do you send on a bound cooked-mode\n\t\t * socket?\n\t\t * Is a \"sendto()\" required there?\n\t\t */\n\t\tpcapint_strlcpy(handle->errbuf,\n\t\t    \"Sending packets isn't supported in cooked mode\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\treturn (-1);\n\t}\n\n\tret = (int)send(handle->fd, buf, size, 0);\n\tif (ret == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}\n\n/*\n *  Get the statistics for the given packet capture handle.\n */\nstatic int\npcap_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n#ifdef HAVE_TPACKET3\n\t/*\n\t * For sockets using TPACKET_V2, the extra stuff at the end\n\t * of a struct tpacket_stats_v3 will not be filled in, and\n\t * we don't look at it so this is OK even for those sockets.\n\t * In addition, the PF_PACKET socket code in the kernel only\n\t * uses the length parameter to compute how much data to\n\t * copy out and to indicate how much data was copied out, so\n\t * it's OK to base it on the size of a struct tpacket_stats.\n\t *\n\t * XXX - it's probably OK, in fact, to just use a\n\t * struct tpacket_stats for V3 sockets, as we don't\n\t * care about the tp_freeze_q_cnt stat.\n\t */\n\tstruct tpacket_stats_v3 kstats;\n#else /* HAVE_TPACKET3 */\n\tstruct tpacket_stats kstats;\n#endif /* HAVE_TPACKET3 */\n\tsocklen_t len = sizeof (struct tpacket_stats);\n\n\tlong long if_dropped = 0;\n\n\t/*\n\t * To fill in ps_ifdrop, we parse\n\t * /sys/class/net/{if_name}/statistics/rx_{missed,fifo}_errors\n\t * for the numbers\n\t */\n\tif (handle->opt.promisc)\n\t{\n\t\t/*\n\t\t * XXX - is there any reason to do this by remembering\n\t\t * the last counts value, subtracting it from the\n\t\t * current counts value, and adding that to stat.ps_ifdrop,\n\t\t * maintaining stat.ps_ifdrop as a count, rather than just\n\t\t * saving the *initial* counts value and setting\n\t\t * stat.ps_ifdrop to the difference between the current\n\t\t * value and the initial value?\n\t\t *\n\t\t * One reason might be to handle the count wrapping\n\t\t * around, on platforms where the count is 32 bits\n\t\t * and where you might get more than 2^32 dropped\n\t\t * packets; is there any other reason?\n\t\t *\n\t\t * (We maintain the count as a long long int so that,\n\t\t * if the kernel maintains the counts as 64-bit even\n\t\t * on 32-bit platforms, we can handle the real count.\n\t\t *\n\t\t * Unfortunately, we can't report 64-bit counts; we\n\t\t * need a better API for reporting statistics, such as\n\t\t * one that reports them in a style similar to the\n\t\t * pcapng Interface Statistics Block, so that 1) the\n\t\t * counts are 64-bit, 2) it's easier to add new statistics\n\t\t * without breaking the ABI, and 3) it's easier to\n\t\t * indicate to a caller that wants one particular\n\t\t * statistic that it's not available by just not supplying\n\t\t * it.)\n\t\t */\n\t\tif_dropped = handlep->sysfs_dropped;\n\t\thandlep->sysfs_dropped = linux_if_drops(handlep->device);\n\t\thandlep->stat.ps_ifdrop += (u_int)(handlep->sysfs_dropped - if_dropped);\n\t}\n\n\t/*\n\t * Try to get the packet counts from the kernel.\n\t */\n\tif (getsockopt(handle->fd, SOL_PACKET, PACKET_STATISTICS,\n\t\t\t&kstats, &len) > -1) {\n\t\t/*\n\t\t * \"ps_recv\" counts only packets that *passed* the\n\t\t * filter, not packets that didn't pass the filter.\n\t\t * This includes packets later dropped because we\n\t\t * ran out of buffer space.\n\t\t *\n\t\t * \"ps_drop\" counts packets dropped because we ran\n\t\t * out of buffer space.  It doesn't count packets\n\t\t * dropped by the interface driver.  It counts only\n\t\t * packets that passed the filter.\n\t\t *\n\t\t * See above for ps_ifdrop.\n\t\t *\n\t\t * Both statistics include packets not yet read from\n\t\t * the kernel by libpcap, and thus not yet seen by\n\t\t * the application.\n\t\t *\n\t\t * In \"linux/net/packet/af_packet.c\", at least in 2.6.27\n\t\t * through 5.6 kernels, \"tp_packets\" is incremented for\n\t\t * every packet that passes the packet filter *and* is\n\t\t * successfully copied to the ring buffer; \"tp_drops\" is\n\t\t * incremented for every packet dropped because there's\n\t\t * not enough free space in the ring buffer.\n\t\t *\n\t\t * When the statistics are returned for a PACKET_STATISTICS\n\t\t * \"getsockopt()\" call, \"tp_drops\" is added to \"tp_packets\",\n\t\t * so that \"tp_packets\" counts all packets handed to\n\t\t * the PF_PACKET socket, including packets dropped because\n\t\t * there wasn't room on the socket buffer - but not\n\t\t * including packets that didn't pass the filter.\n\t\t *\n\t\t * In the BSD BPF, the count of received packets is\n\t\t * incremented for every packet handed to BPF, regardless\n\t\t * of whether it passed the filter.\n\t\t *\n\t\t * We can't make \"pcap_stats()\" work the same on both\n\t\t * platforms, but the best approximation is to return\n\t\t * \"tp_packets\" as the count of packets and \"tp_drops\"\n\t\t * as the count of drops.\n\t\t *\n\t\t * Keep a running total because each call to\n\t\t *    getsockopt(handle->fd, SOL_PACKET, PACKET_STATISTICS, ....\n\t\t * resets the counters to zero.\n\t\t */\n\t\thandlep->stat.ps_recv += kstats.tp_packets;\n\t\thandlep->stat.ps_drop += kstats.tp_drops;\n\t\t*stats = handlep->stat;\n\t\treturn 0;\n\t}\n\n\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE, errno,\n\t    \"failed to get statistics from socket\");\n\treturn -1;\n}\n\n/*\n * A PF_PACKET socket can be bound to any network interface.\n */\nstatic int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}\n\n/*\n * Get a socket to use with various interface ioctls.\n */\nstatic int\nget_if_ioctl_socket(void)\n{\n\tint fd;\n\n\t/*\n\t * This is a bit ugly.\n\t *\n\t * There isn't a socket type that's guaranteed to work.\n\t *\n\t * AF_NETLINK will work *if* you have Netlink configured into the\n\t * kernel (can it be configured out if you have any networking\n\t * support at all?) *and* if you're running a sufficiently recent\n\t * kernel, but not all the kernels we support are sufficiently\n\t * recent - that feature was introduced in Linux 4.6.\n\t *\n\t * AF_UNIX will work *if* you have UNIX-domain sockets configured\n\t * into the kernel and *if* you're not on a system that doesn't\n\t * allow them - some SELinux systems don't allow you create them.\n\t * Most systems probably have them configured in, but not all systems\n\t * have them configured in and allow them to be created.\n\t *\n\t * AF_INET will work *if* you have IPv4 configured into the kernel,\n\t * but, apparently, some systems have network adapters but have\n\t * kernels without IPv4 support.\n\t *\n\t * AF_INET6 will work *if* you have IPv6 configured into the\n\t * kernel, but if you don't have AF_INET, you might not have\n\t * AF_INET6, either (that is, independently on its own grounds).\n\t *\n\t * AF_PACKET would work, except that some of these calls should\n\t * work even if you *don't* have capture permission (you should be\n\t * able to enumerate interfaces and get information about them\n\t * without capture permission; you shouldn't get a failure until\n\t * you try pcap_activate()).  (If you don't allow programs to\n\t * get as much information as possible about interfaces if you\n\t * don't have permission to capture, you run the risk of users\n\t * asking \"why isn't it showing XXX\" - or, worse, if you don't\n\t * show interfaces *at all* if you don't have permission to\n\t * capture on them, \"why do no interfaces show up?\" - when the\n\t * real problem is a permissions problem.  Error reports of that\n\t * type require a lot more back-and-forth to debug, as evidenced\n\t * by many Wireshark bugs/mailing list questions/Q&A questions.)\n\t *\n\t * So:\n\t *\n\t * we first try an AF_NETLINK socket, where \"try\" includes\n\t * \"try to do a device ioctl on it\", as, in the future, once\n\t * pre-4.6 kernels are sufficiently rare, that will probably\n\t * be the mechanism most likely to work;\n\t *\n\t * if that fails, we try an AF_UNIX socket, as that's less\n\t * likely to be configured out on a networking-capable system\n\t * than is IP;\n\t *\n\t * if that fails, we try an AF_INET6 socket;\n\t *\n\t * if that fails, we try an AF_INET socket.\n\t */\n\tfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);\n\tif (fd != -1) {\n\t\t/*\n\t\t * OK, let's make sure we can do an SIOCGIFNAME\n\t\t * ioctl.\n\t\t */\n\t\tstruct ifreq ifr;\n\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\tif (ioctl(fd, SIOCGIFNAME, &ifr) == 0 ||\n\t\t    errno != EOPNOTSUPP) {\n\t\t\t/*\n\t\t\t * It succeeded, or failed for some reason\n\t\t\t * other than \"netlink sockets don't support\n\t\t\t * device ioctls\".  Go with the AF_NETLINK\n\t\t\t * socket.\n\t\t\t */\n\t\t\treturn (fd);\n\t\t}\n\n\t\t/*\n\t\t * OK, that didn't work, so it's as bad as \"netlink\n\t\t * sockets aren't available\".  Close the socket and\n\t\t * drive on.\n\t\t */\n\t\tclose(fd);\n\t}\n\n\t/*\n\t * Now try an AF_UNIX socket.\n\t */\n\tfd = socket(AF_UNIX, SOCK_RAW, 0);\n\tif (fd != -1) {\n\t\t/*\n\t\t * OK, we got it!\n\t\t */\n\t\treturn (fd);\n\t}\n\n\t/*\n\t * Now try an AF_INET6 socket.\n\t */\n\tfd = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (fd != -1) {\n\t\treturn (fd);\n\t}\n\n\t/*\n\t * Now try an AF_INET socket.\n\t *\n\t * XXX - if that fails, is there anything else we should try?\n\t * AF_CAN, for embedded systems in vehicles, in case they're\n\t * built without Internet protocol support?  Any other socket\n\t * types popular in non-Internet embedded systems?\n\t */\n\treturn (socket(AF_INET, SOCK_DGRAM, 0));\n}\n\n/*\n * Get additional flags for a device, using SIOCETHTOOL.\n */\nstatic int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tint sock;\n\tFILE *fh;\n\tunsigned int arptype = ARPHRD_VOID;\n\tstruct ifreq ifr;\n\tstruct ethtool_value info;\n\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn 0;\n\t}\n\n\tsock = get_if_ioctl_socket();\n\tif (sock == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"Can't create socket to get ethtool information for %s\",\n\t\t    name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * OK, what type of network is this?\n\t * In particular, is it wired or wireless?\n\t */\n\tif (is_wifi(name)) {\n\t\t/*\n\t\t * Wi-Fi, hence wireless.\n\t\t */\n\t\t*flags |= PCAP_IF_WIRELESS;\n\t} else {\n\t\t/*\n\t\t * OK, what does /sys/class/net/{if_name}/type contain?\n\t\t * (We don't use that for Wi-Fi, as it'll report\n\t\t * \"Ethernet\", i.e. ARPHRD_ETHER, for non-monitor-\n\t\t * mode devices.)\n\t\t */\n\t\tchar *pathstr;\n\n\t\tif (asprintf(&pathstr, \"/sys/class/net/%s/type\", name) == -1) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: Can't generate path name string for /sys/class/net device\",\n\t\t\t    name);\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t\tfh = fopen(pathstr, \"r\");\n\t\tif (fh != NULL) {\n\t\t\tif (fscanf(fh, \"%u\", &arptype) == 1) {\n\t\t\t\t/*\n\t\t\t\t * OK, we got an ARPHRD_ type; what is it?\n\t\t\t\t */\n\t\t\t\tswitch (arptype) {\n\n\t\t\t\tcase ARPHRD_LOOPBACK:\n\t\t\t\t\t/*\n\t\t\t\t\t * These are types to which\n\t\t\t\t\t * \"connected\" and \"disconnected\"\n\t\t\t\t\t * don't apply, so don't bother\n\t\t\t\t\t * asking about it.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - add other types?\n\t\t\t\t\t */\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tfclose(fh);\n\t\t\t\t\tfree(pathstr);\n\t\t\t\t\treturn 0;\n\n\t\t\t\tcase ARPHRD_IRDA:\n\t\t\t\tcase ARPHRD_IEEE80211:\n\t\t\t\tcase ARPHRD_IEEE80211_PRISM:\n\t\t\t\tcase ARPHRD_IEEE80211_RADIOTAP:\n\t\t\t\tcase ARPHRD_IEEE802154:\n\t\t\t\tcase ARPHRD_IEEE802154_MONITOR:\n\t\t\t\tcase ARPHRD_6LOWPAN:\n\t\t\t\t\t/*\n\t\t\t\t\t * Various wireless types.\n\t\t\t\t\t */\n\t\t\t\t\t*flags |= PCAP_IF_WIRELESS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fh);\n\t\t}\n\t\tfree(pathstr);\n\t}\n\n#ifdef ETHTOOL_GLINK\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\tinfo.cmd = ETHTOOL_GLINK;\n\t/*\n\t * XXX - while Valgrind handles SIOCETHTOOL and knows that\n\t * the ETHTOOL_GLINK command sets the .data member of the\n\t * structure, Memory Sanitizer doesn't yet do so:\n\t *\n\t *    https://bugs.llvm.org/show_bug.cgi?id=45814\n\t *\n\t * For now, we zero it out to squelch warnings; if the bug\n\t * in question is fixed, we can remove this.\n\t */\n\tinfo.data = 0;\n\tifr.ifr_data = (caddr_t)&info;\n\tif (ioctl(sock, SIOCETHTOOL, &ifr) == -1) {\n\t\tint save_errno = errno;\n\n\t\tswitch (save_errno) {\n\n\t\tcase EOPNOTSUPP:\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * OK, this OS version or driver doesn't support\n\t\t\t * asking for this information.\n\t\t\t * XXX - distinguish between \"this doesn't\n\t\t\t * support ethtool at all because it's not\n\t\t\t * that type of device\" vs. \"this doesn't\n\t\t\t * support ethtool even though it's that\n\t\t\t * type of device\", and return \"unknown\".\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\n\t\tcase ENODEV:\n\t\t\t/*\n\t\t\t * OK, no such device.\n\t\t\t * The user will find that out when they try to\n\t\t\t * activate the device; just say \"OK\" and\n\t\t\t * don't set anything.\n\t\t\t */\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    save_errno,\n\t\t\t    \"%s: SIOCETHTOOL(ETHTOOL_GLINK) ioctl failed\",\n\t\t\t    name);\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Is it connected?\n\t */\n\tif (info.data) {\n\t\t/*\n\t\t * It's connected.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t} else {\n\t\t/*\n\t\t * It's disconnected.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t}\n#endif\n\n\tclose(sock);\n\n#ifdef HAVE_SNF_API\n\t// For \"down\" SNF devices the SNF API makes the flags more relevant.\n\tif (arptype == ARPHRD_ETHER &&\n\t    ! (*flags & PCAP_IF_UP) &&\n\t    snf_get_if_flags(name, flags, errbuf) < 0)\n\t\treturn PCAP_ERROR;\n#endif // HAVE_SNF_API\n\n\treturn 0;\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n\t/*\n\t * Add the \"any\" device.\n\t */\n\tif (pcapint_add_any_dev(devlistp, errbuf) == NULL)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * Set direction flag: Which packets do we accept on a forwarding\n * single device? IN, OUT or both?\n */\nstatic int\npcap_setdirection_linux(pcap_t *handle, pcap_direction_t d)\n{\n\t/*\n\t * It's guaranteed, at this point, that d is a valid\n\t * direction value.\n\t */\n\thandle->direction = d;\n\treturn 0;\n}\n\nstatic int\nis_wifi(const char *device)\n{\n\tchar *pathstr;\n\tstruct stat statb;\n\n\t/*\n\t * See if there's a sysfs wireless directory for it.\n\t * If so, it's a wireless interface.\n\t */\n\tif (asprintf(&pathstr, \"/sys/class/net/%s/wireless\", device) == -1) {\n\t\t/*\n\t\t * Just give up here.\n\t\t */\n\t\treturn 0;\n\t}\n\tif (stat(pathstr, &statb) == 0) {\n\t\tfree(pathstr);\n\t\treturn 1;\n\t}\n\tfree(pathstr);\n\n\treturn 0;\n}\n\n/*\n *  Linux uses the ARP hardware type to identify the type of an\n *  interface. pcap uses the DLT_xxx constants for this. This\n *  function takes a pointer to a \"pcap_t\", and an ARPHRD_xxx\n *  constant, as arguments, and sets \"handle->linktype\" to the\n *  appropriate DLT_XXX constant and sets \"handle->offset\" to\n *  the appropriate value (to make \"handle->offset\" plus link-layer\n *  header length be a multiple of 4, so that the link-layer payload\n *  will be aligned on a 4-byte boundary when capturing packets).\n *  (If the offset isn't set here, it'll be 0; add code as appropriate\n *  for cases where it shouldn't be 0.)\n *\n *  If \"cooked_ok\" is non-zero, we can use DLT_LINUX_SLL and capture\n *  in cooked mode; otherwise, we can't use cooked mode, so we have\n *  to pick some type that works in raw mode, or fail.\n *\n *  Sets the link type to -1 if unable to map the type.\n *\n *  Returns 0 on success or a PCAP_ERROR_ value on error.\n */\nstatic int map_arphrd_to_dlt(pcap_t *handle, int arptype,\n\t\t\t     const char *device, int cooked_ok)\n{\n\tstatic const char cdma_rmnet[] = \"cdma_rmnet\";\n\n\tswitch (arptype) {\n\n\tcase ARPHRD_ETHER:\n\t\t/*\n\t\t * For various annoying reasons having to do with DHCP\n\t\t * software, some versions of Android give the mobile-\n\t\t * phone-network interface an ARPHRD_ value of\n\t\t * ARPHRD_ETHER, even though the packets supplied by\n\t\t * that interface have no link-layer header, and begin\n\t\t * with an IP header, so that the ARPHRD_ value should\n\t\t * be ARPHRD_NONE.\n\t\t *\n\t\t * Detect those devices by checking the device name, and\n\t\t * use DLT_RAW for them.\n\t\t */\n\t\tif (strncmp(device, cdma_rmnet, sizeof cdma_rmnet - 1) == 0) {\n\t\t\thandle->linktype = DLT_RAW;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Is this a real Ethernet device?  If so, give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t *\n\t\t * XXX - are there any other sorts of \"fake Ethernet\" that\n\t\t * have ARPHRD_ETHER but that shouldn't offer DLT_DOCSIS as\n\t\t * a Cisco CMTS won't put traffic onto it or get traffic\n\t\t * bridged onto it?  ISDN is handled in \"setup_socket()\",\n\t\t * as we fall back on cooked mode there, and we use\n\t\t * is_wifi() to check for 802.11 devices; are there any\n\t\t * others?\n\t\t */\n\t\tif (!is_wifi(device)) {\n\t\t\tint ret;\n\n\t\t\t/*\n\t\t\t * This is not a Wi-Fi device but it could be\n\t\t\t * a DSA master/management network device.\n\t\t\t */\n\t\t\tret = iface_dsa_get_proto_info(device, handle);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a DSA master/management network\n\t\t\t\t * device linktype is already set by\n\t\t\t\t * iface_dsa_get_proto_info() set an\n\t\t\t\t * appropriate offset here.\n\t\t\t\t */\n\t\t\t\thandle->offset = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It's not a Wi-Fi device; offer DOCSIS.\n\t\t\t */\n\t\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\t\tif (handle->dlt_list == NULL) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\thandle->dlt_list[0] = DLT_EN10MB;\n\t\t\thandle->dlt_list[1] = DLT_DOCSIS;\n\t\t\thandle->dlt_count = 2;\n\t\t}\n\t\t/* FALLTHROUGH */\n\n\tcase ARPHRD_METRICOM:\n\tcase ARPHRD_LOOPBACK:\n\t\thandle->linktype = DLT_EN10MB;\n\t\thandle->offset = 2;\n\t\tbreak;\n\n\tcase ARPHRD_EETHER:\n\t\thandle->linktype = DLT_EN3MB;\n\t\tbreak;\n\n\tcase ARPHRD_AX25:\n\t\thandle->linktype = DLT_AX25_KISS;\n\t\tbreak;\n\n\tcase ARPHRD_PRONET:\n\t\thandle->linktype = DLT_PRONET;\n\t\tbreak;\n\n\tcase ARPHRD_CHAOS:\n\t\thandle->linktype = DLT_CHAOS;\n\t\tbreak;\n\n\tcase ARPHRD_CAN:\n\t\thandle->linktype = DLT_CAN_SOCKETCAN;\n\t\tbreak;\n\n\tcase ARPHRD_IEEE802_TR:\n\tcase ARPHRD_IEEE802:\n\t\thandle->linktype = DLT_IEEE802;\n\t\thandle->offset = 2;\n\t\tbreak;\n\n\tcase ARPHRD_ARCNET:\n\t\thandle->linktype = DLT_ARCNET_LINUX;\n\t\tbreak;\n\n\tcase ARPHRD_FDDI:\n\t\thandle->linktype = DLT_FDDI;\n\t\thandle->offset = 3;\n\t\tbreak;\n\n\tcase ARPHRD_ATM:\n\t\t/*\n\t\t * The Classical IP implementation in ATM for Linux\n\t\t * supports both what RFC 1483 calls \"LLC Encapsulation\",\n\t\t * in which each packet has an LLC header, possibly\n\t\t * with a SNAP header as well, prepended to it, and\n\t\t * what RFC 1483 calls \"VC Based Multiplexing\", in which\n\t\t * different virtual circuits carry different network\n\t\t * layer protocols, and no header is prepended to packets.\n\t\t *\n\t\t * They both have an ARPHRD_ type of ARPHRD_ATM, so\n\t\t * you can't use the ARPHRD_ type to find out whether\n\t\t * captured packets will have an LLC header, and,\n\t\t * while there's a socket ioctl to *set* the encapsulation\n\t\t * type, there's no ioctl to *get* the encapsulation type.\n\t\t *\n\t\t * This means that\n\t\t *\n\t\t *\tprograms that dissect Linux Classical IP frames\n\t\t *\twould have to check for an LLC header and,\n\t\t *\tdepending on whether they see one or not, dissect\n\t\t *\tthe frame as LLC-encapsulated or as raw IP (I\n\t\t *\tdon't know whether there's any traffic other than\n\t\t *\tIP that would show up on the socket, or whether\n\t\t *\tthere's any support for IPv6 in the Linux\n\t\t *\tClassical IP code);\n\t\t *\n\t\t *\tfilter expressions would have to compile into\n\t\t *\tcode that checks for an LLC header and does\n\t\t *\tthe right thing.\n\t\t *\n\t\t * Both of those are a nuisance - and, at least on systems\n\t\t * that support PF_PACKET sockets, we don't have to put\n\t\t * up with those nuisances; instead, we can just capture\n\t\t * in cooked mode.  That's what we'll do, if we can.\n\t\t * Otherwise, we'll just fail.\n\t\t */\n\t\tif (cooked_ok)\n\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\telse\n\t\t\thandle->linktype = -1;\n\t\tbreak;\n\n\tcase ARPHRD_IEEE80211:\n\t\thandle->linktype = DLT_IEEE802_11;\n\t\tbreak;\n\n\tcase ARPHRD_IEEE80211_PRISM:\n\t\thandle->linktype = DLT_PRISM_HEADER;\n\t\tbreak;\n\n\tcase ARPHRD_IEEE80211_RADIOTAP:\n\t\thandle->linktype = DLT_IEEE802_11_RADIO;\n\t\tbreak;\n\n\tcase ARPHRD_PPP:\n\t\t/*\n\t\t * Some PPP code in the kernel supplies no link-layer\n\t\t * header whatsoever to PF_PACKET sockets; other PPP\n\t\t * code supplies PPP link-layer headers (\"syncppp.c\");\n\t\t * some PPP code might supply random link-layer\n\t\t * headers (PPP over ISDN - there's code in Ethereal,\n\t\t * for example, to cope with PPP-over-ISDN captures\n\t\t * with which the Ethereal developers have had to cope,\n\t\t * heuristically trying to determine which of the\n\t\t * oddball link-layer headers particular packets have).\n\t\t *\n\t\t * As such, we just punt, and run all PPP interfaces\n\t\t * in cooked mode, if we can; otherwise, we just treat\n\t\t * it as DLT_RAW, for now - if somebody needs to capture,\n\t\t * on a 2.0[.x] kernel, on PPP devices that supply a\n\t\t * link-layer header, they'll have to add code here to\n\t\t * map to the appropriate DLT_ type (possibly adding a\n\t\t * new DLT_ type, if necessary).\n\t\t */\n\t\tif (cooked_ok)\n\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\telse {\n\t\t\t/*\n\t\t\t * XXX - handle ISDN types here?  We can't fall\n\t\t\t * back on cooked sockets, so we'd have to\n\t\t\t * figure out from the device name what type of\n\t\t\t * link-layer encapsulation it's using, and map\n\t\t\t * that to an appropriate DLT_ value, meaning\n\t\t\t * we'd map \"isdnN\" devices to DLT_RAW (they\n\t\t\t * supply raw IP packets with no link-layer\n\t\t\t * header) and \"isdY\" devices to a new DLT_I4L_IP\n\t\t\t * type that has only an Ethernet packet type as\n\t\t\t * a link-layer header.\n\t\t\t *\n\t\t\t * But sometimes we seem to get random crap\n\t\t\t * in the link-layer header when capturing on\n\t\t\t * ISDN devices....\n\t\t\t */\n\t\t\thandle->linktype = DLT_RAW;\n\t\t}\n\t\tbreak;\n\n\tcase ARPHRD_CISCO:\n\t\thandle->linktype = DLT_C_HDLC;\n\t\tbreak;\n\n\t/* Not sure if this is correct for all tunnels, but it\n\t * works for CIPE */\n\tcase ARPHRD_TUNNEL:\n\tcase ARPHRD_SIT:\n\tcase ARPHRD_CSLIP:\n\tcase ARPHRD_SLIP6:\n\tcase ARPHRD_CSLIP6:\n\tcase ARPHRD_ADAPT:\n\tcase ARPHRD_SLIP:\n\tcase ARPHRD_RAWHDLC:\n\tcase ARPHRD_DLCI:\n\t\t/*\n\t\t * XXX - should some of those be mapped to DLT_LINUX_SLL\n\t\t * instead?  Should we just map all of them to DLT_LINUX_SLL?\n\t\t */\n\t\thandle->linktype = DLT_RAW;\n\t\tbreak;\n\n\tcase ARPHRD_FRAD:\n\t\thandle->linktype = DLT_FRELAY;\n\t\tbreak;\n\n\tcase ARPHRD_LOCALTLK:\n\t\thandle->linktype = DLT_LTALK;\n\t\tbreak;\n\n\tcase 18:\n\t\t/*\n\t\t * RFC 4338 defines an encapsulation for IP and ARP\n\t\t * packets that's compatible with the RFC 2625\n\t\t * encapsulation, but that uses a different ARP\n\t\t * hardware type and hardware addresses.  That\n\t\t * ARP hardware type is 18; Linux doesn't define\n\t\t * any ARPHRD_ value as 18, but if it ever officially\n\t\t * supports RFC 4338-style IP-over-FC, it should define\n\t\t * one.\n\t\t *\n\t\t * For now, we map it to DLT_IP_OVER_FC, in the hopes\n\t\t * that this will encourage its use in the future,\n\t\t * should Linux ever officially support RFC 4338-style\n\t\t * IP-over-FC.\n\t\t */\n\t\thandle->linktype = DLT_IP_OVER_FC;\n\t\tbreak;\n\n\tcase ARPHRD_FCPP:\n\tcase ARPHRD_FCAL:\n\tcase ARPHRD_FCPL:\n\tcase ARPHRD_FCFABRIC:\n\t\t/*\n\t\t * Back in 2002, Donald Lee at Cray wanted a DLT_ for\n\t\t * IP-over-FC:\n\t\t *\n\t\t *\thttps://www.mail-archive.com/tcpdump-workers@sandelman.ottawa.on.ca/msg01043.html\n\t\t *\n\t\t * and one was assigned.\n\t\t *\n\t\t * In a later private discussion (spun off from a message\n\t\t * on the ethereal-users list) on how to get that DLT_\n\t\t * value in libpcap on Linux, I ended up deciding that\n\t\t * the best thing to do would be to have him tweak the\n\t\t * driver to set the ARPHRD_ value to some ARPHRD_FCxx\n\t\t * type, and map all those types to DLT_IP_OVER_FC:\n\t\t *\n\t\t *\tI've checked into the libpcap and tcpdump CVS tree\n\t\t *\tsupport for DLT_IP_OVER_FC.  In order to use that,\n\t\t *\tyou'd have to modify your modified driver to return\n\t\t *\tone of the ARPHRD_FCxxx types, in \"fcLINUXfcp.c\" -\n\t\t *\tchange it to set \"dev->type\" to ARPHRD_FCFABRIC, for\n\t\t *\texample (the exact value doesn't matter, it can be\n\t\t *\tany of ARPHRD_FCPP, ARPHRD_FCAL, ARPHRD_FCPL, or\n\t\t *\tARPHRD_FCFABRIC).\n\t\t *\n\t\t * 11 years later, Christian Svensson wanted to map\n\t\t * various ARPHRD_ values to DLT_FC_2 and\n\t\t * DLT_FC_2_WITH_FRAME_DELIMS for raw Fibre Channel\n\t\t * frames:\n\t\t *\n\t\t *\thttps://github.com/mcr/libpcap/pull/29\n\t\t *\n\t\t * There doesn't seem to be any network drivers that uses\n\t\t * any of the ARPHRD_FC* values for IP-over-FC, and\n\t\t * it's not exactly clear what the \"Dummy types for non\n\t\t * ARP hardware\" are supposed to mean (link-layer\n\t\t * header type?  Physical network type?), so it's\n\t\t * not exactly clear why the ARPHRD_FC* types exist\n\t\t * in the first place.\n\t\t *\n\t\t * For now, we map them to DLT_FC_2, and provide an\n\t\t * option of DLT_FC_2_WITH_FRAME_DELIMS, as well as\n\t\t * DLT_IP_OVER_FC just in case there's some old\n\t\t * driver out there that uses one of those types for\n\t\t * IP-over-FC on which somebody wants to capture\n\t\t * packets.\n\t\t */\n\t\thandle->linktype = DLT_FC_2;\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);\n\t\tif (handle->dlt_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\thandle->dlt_list[0] = DLT_FC_2;\n\t\thandle->dlt_list[1] = DLT_FC_2_WITH_FRAME_DELIMS;\n\t\thandle->dlt_list[2] = DLT_IP_OVER_FC;\n\t\thandle->dlt_count = 3;\n\t\tbreak;\n\n\tcase ARPHRD_IRDA:\n\t\t/* Don't expect IP packet out of this interfaces... */\n\t\thandle->linktype = DLT_LINUX_IRDA;\n\t\t/* We need to save packet direction for IrDA decoding,\n\t\t * so let's use \"Linux-cooked\" mode. Jean II\n\t\t *\n\t\t * XXX - this is handled in setup_socket(). */\n\t\t/* handlep->cooked = 1; */\n\t\tbreak;\n\n\tcase ARPHRD_LAPD:\n\t\t/* Don't expect IP packet out of this interfaces... */\n\t\thandle->linktype = DLT_LINUX_LAPD;\n\t\tbreak;\n\n\tcase ARPHRD_NONE:\n\t\t/*\n\t\t * No link-layer header; packets are just IP\n\t\t * packets, so use DLT_RAW.\n\t\t */\n\t\thandle->linktype = DLT_RAW;\n\t\tbreak;\n\n       case ARPHRD_IEEE802154:\n               handle->linktype =  DLT_IEEE802_15_4_NOFCS;\n               break;\n\n\tcase ARPHRD_NETLINK:\n\t\thandle->linktype = DLT_NETLINK;\n\t\t/*\n\t\t * We need to use cooked mode, so that in sll_protocol we\n\t\t * pick up the netlink protocol type such as NETLINK_ROUTE,\n\t\t * NETLINK_GENERIC, NETLINK_FIB_LOOKUP, etc.\n\t\t *\n\t\t * XXX - this is handled in setup_socket().\n\t\t */\n\t\t/* handlep->cooked = 1; */\n\t\tbreak;\n\n\tcase ARPHRD_VSOCKMON:\n\t\thandle->linktype = DLT_VSOCK;\n\t\tbreak;\n\n\tdefault:\n\t\thandle->linktype = -1;\n\t\tbreak;\n\t}\n\treturn (0);\n}\n\n/*\n * Try to set up a PF_PACKET socket.\n * Returns 0 or a PCAP_WARNING_ value on success and a PCAP_ERROR_ value\n * on failure.\n */\nstatic int\nsetup_socket(pcap_t *handle, int is_any_device)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tconst char\t\t*device = handle->opt.device;\n\tint\t\t\tstatus = 0;\n\tint\t\t\tsock_fd, arptype;\n\tint\t\t\tval;\n\tint\t\t\terr = 0;\n\tstruct packet_mreq\tmr;\n#if defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT)\n\tint\t\t\tbpf_extensions;\n\tsocklen_t\t\tlen = sizeof(bpf_extensions);\n#endif\n\n\t/*\n\t * Open a socket with protocol family packet. If cooked is true,\n\t * we open a SOCK_DGRAM socket for the cooked interface, otherwise\n\t * we open a SOCK_RAW socket for the raw interface.\n\t *\n\t * The protocol is set to 0.  This means we will receive no\n\t * packets until we \"bind\" the socket with a non-zero\n\t * protocol.  This allows us to setup the ring buffers without\n\t * dropping any packets.\n\t */\n\tsock_fd = is_any_device ?\n\t\tsocket(PF_PACKET, SOCK_DGRAM, 0) :\n\t\tsocket(PF_PACKET, SOCK_RAW, 0);\n\n\tif (sock_fd == -1) {\n\t\tif (errno == EPERM || errno == EACCES) {\n\t\t\t/*\n\t\t\t * You don't have permission to open the\n\t\t\t * socket.\n\t\t\t */\n\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to create packet socket failed - CAP_NET_RAW may be required\");\n\t\t} else if (errno == EAFNOSUPPORT) {\n\t\t\t/*\n\t\t\t * PF_PACKET sockets not supported.\n\t\t\t * Perhaps we're running on the WSL1 module\n\t\t\t * in the Windows NT kernel rather than on\n\t\t\t * a real Linux kernel.\n\t\t\t */\n\t\t\tstatus = PCAP_ERROR_CAPTURE_NOTSUP;\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PF_PACKET sockets not supported - is this WSL1?\");\n\t\t} else {\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tstatus = PCAP_ERROR;\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn status;\n\t}\n\n\t/*\n\t * Get the interface index of the loopback device.\n\t * If the attempt fails, don't fail, just set the\n\t * \"handlep->lo_ifindex\" to -1.\n\t *\n\t * XXX - can there be more than one device that loops\n\t * packets back, i.e. devices other than \"lo\"?  If so,\n\t * we'd need to find them all, and have an array of\n\t * indices for them, and check all of them in\n\t * \"pcap_read_packet()\".\n\t */\n\thandlep->lo_ifindex = iface_get_id(sock_fd, \"lo\", handle->errbuf);\n\n\t/*\n\t * Default value for offset to align link-layer payload\n\t * on a 4-byte boundary.\n\t */\n\thandle->offset\t = 0;\n\n\t/*\n\t * What kind of frames do we have to deal with? Fall back\n\t * to cooked mode if we have an unknown interface type\n\t * or a type we know doesn't work well in raw mode.\n\t */\n\tif (!is_any_device) {\n\t\t/* Assume for now we don't need cooked mode. */\n\t\thandlep->cooked = 0;\n\n\t\tif (handle->opt.rfmon) {\n\t\t\t/*\n\t\t\t * We were asked to turn on monitor mode.\n\t\t\t * Do so before we get the link-layer type,\n\t\t\t * because entering monitor mode could change\n\t\t\t * the link-layer type.\n\t\t\t */\n\t\t\terr = enter_rfmon_mode(handle, sock_fd, device);\n\t\t\tif (err < 0) {\n\t\t\t\t/* Hard failure */\n\t\t\t\tclose(sock_fd);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\t/*\n\t\t\t\t * Nothing worked for turning monitor mode\n\t\t\t\t * on.\n\t\t\t\t */\n\t\t\t\tclose(sock_fd);\n\n\t\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Either monitor mode has been turned on for\n\t\t\t * the device, or we've been given a different\n\t\t\t * device to open for monitor mode.  If we've\n\t\t\t * been given a different device, use it.\n\t\t\t */\n\t\t\tif (handlep->mondevice != NULL)\n\t\t\t\tdevice = handlep->mondevice;\n\t\t}\n\t\tarptype\t= iface_get_arptype(sock_fd, device, handle->errbuf);\n\t\tif (arptype < 0) {\n\t\t\tclose(sock_fd);\n\t\t\treturn arptype;\n\t\t}\n\t\tstatus = map_arphrd_to_dlt(handle, arptype, device, 1);\n\t\tif (status < 0) {\n\t\t\tclose(sock_fd);\n\t\t\treturn status;\n\t\t}\n\t\tif (handle->linktype == -1 ||\n\t\t    handle->linktype == DLT_LINUX_SLL ||\n\t\t    handle->linktype == DLT_LINUX_IRDA ||\n\t\t    handle->linktype == DLT_LINUX_LAPD ||\n\t\t    handle->linktype == DLT_NETLINK ||\n\t\t    (handle->linktype == DLT_EN10MB &&\n\t\t     (strncmp(\"isdn\", device, 4) == 0 ||\n\t\t      strncmp(\"isdY\", device, 4) == 0))) {\n\t\t\t/*\n\t\t\t * Unknown interface type (-1), or a\n\t\t\t * device we explicitly chose to run\n\t\t\t * in cooked mode (e.g., PPP devices),\n\t\t\t * or an ISDN device (whose link-layer\n\t\t\t * type we can only determine by using\n\t\t\t * APIs that may be different on different\n\t\t\t * kernels) - reopen in cooked mode.\n\t\t\t *\n\t\t\t * If the type is unknown, return a warning;\n\t\t\t * map_arphrd_to_dlt() has already set the\n\t\t\t * warning message.\n\t\t\t */\n\t\t\tif (close(sock_fd) == -1) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"close\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tsock_fd = socket(PF_PACKET, SOCK_DGRAM, 0);\n\t\t\tif (sock_fd < 0) {\n\t\t\t\t/*\n\t\t\t\t * Fatal error.  We treat this as\n\t\t\t\t * a generic error; we already know\n\t\t\t\t * that we were able to open a\n\t\t\t\t * PF_PACKET/SOCK_RAW socket, so\n\t\t\t\t * any failure is a \"this shouldn't\n\t\t\t\t * happen\" case.\n\t\t\t\t */\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"socket\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\thandlep->cooked = 1;\n\n\t\t\t/*\n\t\t\t * Get rid of any link-layer type list\n\t\t\t * we allocated - this only supports cooked\n\t\t\t * capture.\n\t\t\t */\n\t\t\tif (handle->dlt_list != NULL) {\n\t\t\t\tfree(handle->dlt_list);\n\t\t\t\thandle->dlt_list = NULL;\n\t\t\t\thandle->dlt_count = 0;\n\t\t\t}\n\n\t\t\tif (handle->linktype == -1) {\n\t\t\t\t/*\n\t\t\t\t * Warn that we're falling back on\n\t\t\t\t * cooked mode; we may want to\n\t\t\t\t * update \"map_arphrd_to_dlt()\"\n\t\t\t\t * to handle the new type.\n\t\t\t\t */\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"arptype %d not \"\n\t\t\t\t\t\"supported by libpcap - \"\n\t\t\t\t\t\"falling back to cooked \"\n\t\t\t\t\t\"socket\",\n\t\t\t\t\tarptype);\n\t\t\t\tstatus = PCAP_WARNING;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * IrDA capture is not a real \"cooked\" capture,\n\t\t\t * it's IrLAP frames, not IP packets.  The\n\t\t\t * same applies to LAPD capture.\n\t\t\t */\n\t\t\tif (handle->linktype != DLT_LINUX_IRDA &&\n\t\t\t    handle->linktype != DLT_LINUX_LAPD &&\n\t\t\t    handle->linktype != DLT_NETLINK)\n\t\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\t}\n\n\t\thandlep->ifindex = iface_get_id(sock_fd, device,\n\t\t    handle->errbuf);\n\t\tif (handlep->ifindex == -1) {\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\tif ((err = iface_bind(sock_fd, handlep->ifindex,\n\t\t    handle->errbuf, 0)) != 0) {\n\t\t\tclose(sock_fd);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The \"any\" device.\n\t\t */\n\t\tif (handle->opt.rfmon) {\n\t\t\t/*\n\t\t\t * It doesn't support monitor mode.\n\t\t\t */\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t}\n\n\t\t/*\n\t\t * It uses cooked mode.\n\t\t * Support both DLT_LINUX_SLL and DLT_LINUX_SLL2.\n\t\t */\n\t\thandlep->cooked = 1;\n\t\thandle->linktype = DLT_LINUX_SLL;\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\tif (handle->dlt_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\thandle->dlt_list[0] = DLT_LINUX_SLL;\n\t\thandle->dlt_list[1] = DLT_LINUX_SLL2;\n\t\thandle->dlt_count = 2;\n\n\t\t/*\n\t\t * We're not bound to a device.\n\t\t * For now, we're using this as an indication\n\t\t * that we can't transmit; stop doing that only\n\t\t * if we figure out how to transmit in cooked\n\t\t * mode.\n\t\t */\n\t\thandlep->ifindex = -1;\n\t}\n\n\t/*\n\t * Select promiscuous mode on if \"promisc\" is set.\n\t *\n\t * Do not turn allmulti mode on if we don't select\n\t * promiscuous mode - on some devices (e.g., Orinoco\n\t * wireless interfaces), allmulti mode isn't supported\n\t * and the driver implements it by turning promiscuous\n\t * mode on, and that screws up the operation of the\n\t * card as a normal networking interface, and on no\n\t * other platform I know of does starting a non-\n\t * promiscuous capture affect which multicast packets\n\t * are received by the interface.\n\t */\n\n\t/*\n\t * Hmm, how can we set promiscuous mode on all interfaces?\n\t * I am not sure if that is possible at all.  For now, we\n\t * silently ignore attempts to turn promiscuous mode on\n\t * for the \"any\" device (so you don't have to explicitly\n\t * disable it in programs such as tcpdump).\n\t */\n\n\tif (!is_any_device && handle->opt.promisc) {\n\t\tmemset(&mr, 0, sizeof(mr));\n\t\tmr.mr_ifindex = handlep->ifindex;\n\t\tmr.mr_type    = PACKET_MR_PROMISC;\n\t\tif (setsockopt(sock_fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,\n\t\t    &mr, sizeof(mr)) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"setsockopt (PACKET_ADD_MEMBERSHIP)\");\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Enable auxiliary data and reserve room for reconstructing\n\t * VLAN headers.\n\t *\n\t * XXX - is enabling auxiliary data necessary, now that we\n\t * only support memory-mapped capture?  The kernel's memory-mapped\n\t * capture code doesn't seem to check whether auxiliary data\n\t * is enabled, it seems to provide it whether it is or not.\n\t */\n\tval = 1;\n\tif (setsockopt(sock_fd, SOL_PACKET, PACKET_AUXDATA, &val,\n\t\t       sizeof(val)) == -1 && errno != ENOPROTOOPT) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setsockopt (PACKET_AUXDATA)\");\n\t\tclose(sock_fd);\n\t\treturn PCAP_ERROR;\n\t}\n\thandle->offset += VLAN_TAG_LEN;\n\n\t/*\n\t * If we're in cooked mode, make the snapshot length\n\t * large enough to hold a \"cooked mode\" header plus\n\t * 1 byte of packet data (so we don't pass a byte\n\t * count of 0 to \"recvfrom()\").\n\t * XXX - we don't know whether this will be DLT_LINUX_SLL\n\t * or DLT_LINUX_SLL2, so make sure it's big enough for\n\t * a DLT_LINUX_SLL2 \"cooked mode\" header; a snapshot length\n\t * that small is silly anyway.\n\t */\n\tif (handlep->cooked) {\n\t\tif (handle->snapshot < SLL2_HDR_LEN + 1)\n\t\t\thandle->snapshot = SLL2_HDR_LEN + 1;\n\t}\n\thandle->bufsize = handle->snapshot;\n\n\t/*\n\t * Set the offset at which to insert VLAN tags.\n\t */\n\tset_vlan_offset(handle);\n\n\tif (handle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {\n\t\tint nsec_tstamps = 1;\n\n\t\tif (setsockopt(sock_fd, SOL_SOCKET, SO_TIMESTAMPNS, &nsec_tstamps, sizeof(nsec_tstamps)) < 0) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"setsockopt: unable to set SO_TIMESTAMPNS\");\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * We've succeeded. Save the socket FD in the pcap structure.\n\t */\n\thandle->fd = sock_fd;\n\n#if defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT)\n\t/*\n\t * Can we generate special code for VLAN checks?\n\t * (XXX - what if we need the special code but it's not supported\n\t * by the OS?  Is that possible?)\n\t */\n\tif (getsockopt(sock_fd, SOL_SOCKET, SO_BPF_EXTENSIONS,\n\t    &bpf_extensions, &len) == 0) {\n\t\tif (bpf_extensions >= SKF_AD_VLAN_TAG_PRESENT) {\n\t\t\t/*\n\t\t\t * Yes, we can.  Request that we do so.\n\t\t\t */\n\t\t\thandle->bpf_codegen_flags |= BPF_SPECIAL_VLAN_HANDLING;\n\t\t}\n\t}\n#endif /* defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT) */\n\n\treturn status;\n}\n\n/*\n * Attempt to setup memory-mapped access.\n *\n * On success, returns 0 if there are no warnings or a PCAP_WARNING_ code\n * if there is a warning.\n *\n * On error, returns the appropriate error code; if that is PCAP_ERROR,\n * sets handle->errbuf to the appropriate message.\n */\nstatic int\nsetup_mmapped(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint flags = MAP_ANONYMOUS | MAP_PRIVATE;\n\tint status;\n\n\t/*\n\t * Attempt to allocate a buffer to hold the contents of one\n\t * packet, for use by the oneshot callback.\n\t */\n#ifdef MAP_32BIT\n\tif (pcapint_mmap_32bit) flags |= MAP_32BIT;\n#endif\n\thandlep->oneshot_buffer = mmap(0, handle->snapshot, PROT_READ | PROT_WRITE, flags, -1, 0);\n\tif (handlep->oneshot_buffer == MAP_FAILED) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't allocate oneshot buffer\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (handle->opt.buffer_size == 0) {\n\t\t/* by default request 2M for the ring buffer */\n\t\thandle->opt.buffer_size = 2*1024*1024;\n\t}\n\tstatus = prepare_tpacket_socket(handle);\n\tif (status == -1) {\n\t\tmunmap(handlep->oneshot_buffer, handle->snapshot);\n\t\thandlep->oneshot_buffer = NULL;\n\t\treturn PCAP_ERROR;\n\t}\n\tstatus = create_ring(handle);\n\tif (status < 0) {\n\t\t/*\n\t\t * Error attempting to enable memory-mapped capture;\n\t\t * fail.  The return value is the status to return.\n\t\t */\n\t\tmunmap(handlep->oneshot_buffer, handle->snapshot);\n\t\thandlep->oneshot_buffer = NULL;\n\t\treturn status;\n\t}\n\n\t/*\n\t * Success.  status has been set either to 0 if there are no\n\t * warnings or to a PCAP_WARNING_ value if there is a warning.\n\t *\n\t * handle->offset is used to get the current position into the rx ring.\n\t * handle->cc is used to store the ring size.\n\t */\n\n\t/*\n\t * Set the timeout to use in poll() before returning.\n\t */\n\tset_poll_timeout(handlep);\n\n\treturn status;\n}\n\n/*\n * Attempt to set the socket to the specified version of the memory-mapped\n * header.\n *\n * Return 0 if we succeed; return 1 if we fail because that version isn't\n * supported; return -1 on any other error, and set handle->errbuf.\n */\nstatic int\ninit_tpacket(pcap_t *handle, int version, const char *version_str)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint val = version;\n\tsocklen_t len = sizeof(val);\n\n\t/*\n\t * Probe whether kernel supports the specified TPACKET version;\n\t * this also gets the length of the header for that version.\n\t *\n\t * This socket option was introduced in 2.6.27, which was\n\t * also the first release with TPACKET_V2 support.\n\t */\n\tif (getsockopt(handle->fd, SOL_PACKET, PACKET_HDRLEN, &val, &len) < 0) {\n\t\tif (errno == EINVAL) {\n\t\t\t/*\n\t\t\t * EINVAL means this specific version of TPACKET\n\t\t\t * is not supported. Tell the caller they can try\n\t\t\t * with a different one; if they've run out of\n\t\t\t * others to try, let them set the error message\n\t\t\t * appropriately.\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * All other errors are fatal.\n\t\t */\n\t\tif (errno == ENOPROTOOPT) {\n\t\t\t/*\n\t\t\t * PACKET_HDRLEN isn't supported, which means\n\t\t\t * that memory-mapped capture isn't supported.\n\t\t\t * Indicate that in the message.\n\t\t\t */\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Kernel doesn't support memory-mapped capture; a 2.6.27 or later 2.x kernel is required, with CONFIG_PACKET_MMAP specified for 2.x kernels\");\n\t\t} else {\n\t\t\t/*\n\t\t\t * Some unexpected error.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"can't get %s header len on packet socket\",\n\t\t\t    version_str);\n\t\t}\n\t\treturn -1;\n\t}\n\thandlep->tp_hdrlen = val;\n\n\tval = version;\n\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_VERSION, &val,\n\t\t\t   sizeof(val)) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't activate %s on packet socket\", version_str);\n\t\treturn -1;\n\t}\n\thandlep->tp_version = version;\n\n\treturn 0;\n}\n\n/*\n * Attempt to set the socket to version 3 of the memory-mapped header and,\n * if that fails because version 3 isn't supported, attempt to fall\n * back to version 2.  If version 2 isn't supported, just fail.\n *\n * Return 0 if we succeed and -1 on any other error, and set handle->errbuf.\n */\nstatic int\nprepare_tpacket_socket(pcap_t *handle)\n{\n\tint ret;\n\n#ifdef HAVE_TPACKET3\n\t/*\n\t * Try setting the version to TPACKET_V3.\n\t *\n\t * The only mode in which buffering is done on PF_PACKET\n\t * sockets, so that packets might not be delivered\n\t * immediately, is TPACKET_V3 mode.\n\t *\n\t * The buffering cannot be disabled in that mode, so\n\t * if the user has requested immediate mode, we don't\n\t * use TPACKET_V3.\n\t */\n\tif (!handle->opt.immediate) {\n\t\tret = init_tpacket(handle, TPACKET_V3, \"TPACKET_V3\");\n\t\tif (ret == 0) {\n\t\t\t/*\n\t\t\t * Success.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t\tif (ret == -1) {\n\t\t\t/*\n\t\t\t * We failed for some reason other than \"the\n\t\t\t * kernel doesn't support TPACKET_V3\".\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * This means it returned 1, which means \"the kernel\n\t\t * doesn't support TPACKET_V3\"; try TPACKET_V2.\n\t\t */\n\t}\n#endif /* HAVE_TPACKET3 */\n\n\t/*\n\t * Try setting the version to TPACKET_V2.\n\t */\n\tret = init_tpacket(handle, TPACKET_V2, \"TPACKET_V2\");\n\tif (ret == 0) {\n\t\t/*\n\t\t * Success.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (ret == 1) {\n\t\t/*\n\t\t * OK, the kernel supports memory-mapped capture, but\n\t\t * not TPACKET_V2.  Set the error message appropriately.\n\t\t */\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Kernel doesn't support TPACKET_V2; a 2.6.27 or later kernel is required\");\n\t}\n\n\t/*\n\t * We failed.\n\t */\n\treturn -1;\n}\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\n/*\n * Attempt to set up memory-mapped access.\n *\n * On success, returns 0 if there are no warnings or to a PCAP_WARNING_ code\n * if there is a warning.\n *\n * On error, returns the appropriate error code; if that is PCAP_ERROR,\n * sets handle->errbuf to the appropriate message.\n */\nstatic int\ncreate_ring(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunsigned i, j, frames_per_block;\n\tint flags = MAP_SHARED;\n#ifdef HAVE_TPACKET3\n\t/*\n\t * For sockets using TPACKET_V2, the extra stuff at the end of a\n\t * struct tpacket_req3 will be ignored, so this is OK even for\n\t * those sockets.\n\t */\n\tstruct tpacket_req3 req;\n#else\n\tstruct tpacket_req req;\n#endif\n\tsocklen_t len;\n\tunsigned int sk_type, tp_reserve, maclen, tp_hdrlen, netoff, macoff;\n\tunsigned int frame_size;\n\tint status;\n\n\t/*\n\t * Start out assuming no warnings.\n\t */\n\tstatus = 0;\n\n\t/*\n\t * Reserve space for VLAN tag reconstruction.\n\t */\n\ttp_reserve = VLAN_TAG_LEN;\n\n\t/*\n\t * If we're capturing in cooked mode, reserve space for\n\t * a DLT_LINUX_SLL2 header; we don't know yet whether\n\t * we'll be using DLT_LINUX_SLL or DLT_LINUX_SLL2, as\n\t * that can be changed on an open device, so we reserve\n\t * space for the larger of the two.\n\t *\n\t * XXX - we assume that the kernel is still adding\n\t * 16 bytes of extra space, so we subtract 16 from\n\t * SLL2_HDR_LEN to get the additional space needed.\n\t * (Are they doing that for DLT_LINUX_SLL, the link-\n\t * layer header for which is 16 bytes?)\n\t *\n\t * XXX - should we use TPACKET_ALIGN(SLL2_HDR_LEN - 16)?\n\t */\n\tif (handlep->cooked)\n\t\ttp_reserve += SLL2_HDR_LEN - 16;\n\n\t/*\n\t * Try to request that amount of reserve space.\n\t * This must be done before creating the ring buffer.\n\t */\n\tlen = sizeof(tp_reserve);\n\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_RESERVE,\n\t    &tp_reserve, len) < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t    \"setsockopt (PACKET_RESERVE)\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tswitch (handlep->tp_version) {\n\n\tcase TPACKET_V2:\n\t\t/* Note that with large snapshot length (say 256K, which is\n\t\t * the default for recent versions of tcpdump, Wireshark,\n\t\t * TShark, dumpcap or 64K, the value that \"-s 0\" has given for\n\t\t * a long time with tcpdump), if we use the snapshot\n\t\t * length to calculate the frame length, only a few frames\n\t\t * will be available in the ring even with pretty\n\t\t * large ring size (and a lot of memory will be unused).\n\t\t *\n\t\t * Ideally, we should choose a frame length based on the\n\t\t * minimum of the specified snapshot length and the maximum\n\t\t * packet size.  That's not as easy as it sounds; consider,\n\t\t * for example, an 802.11 interface in monitor mode, where\n\t\t * the frame would include a radiotap header, where the\n\t\t * maximum radiotap header length is device-dependent.\n\t\t *\n\t\t * So, for now, we just do this for Ethernet devices, where\n\t\t * there's no metadata header, and the link-layer header is\n\t\t * fixed length.  We can get the maximum packet size by\n\t\t * adding 18, the Ethernet header length plus the CRC length\n\t\t * (just in case we happen to get the CRC in the packet), to\n\t\t * the MTU of the interface; we fetch the MTU in the hopes\n\t\t * that it reflects support for jumbo frames.  (Even if the\n\t\t * interface is just being used for passive snooping, the\n\t\t * driver might set the size of buffers in the receive ring\n\t\t * based on the MTU, so that the MTU limits the maximum size\n\t\t * of packets that we can receive.)\n\t\t *\n\t\t * If segmentation/fragmentation or receive offload are\n\t\t * enabled, we can get reassembled/aggregated packets larger\n\t\t * than MTU, but bounded to 65535 plus the Ethernet overhead,\n\t\t * due to kernel and protocol constraints */\n\t\tframe_size = handle->snapshot;\n\t\tif (handle->linktype == DLT_EN10MB) {\n\t\t\tunsigned int max_frame_len;\n\t\t\tint mtu;\n\t\t\tint offload;\n\n\t\t\tmtu = iface_get_mtu(handle->fd, handle->opt.device,\n\t\t\t    handle->errbuf);\n\t\t\tif (mtu == -1)\n\t\t\t\treturn PCAP_ERROR;\n\t\t\toffload = iface_get_offload(handle);\n\t\t\tif (offload == -1)\n\t\t\t\treturn PCAP_ERROR;\n\t\t\tif (offload)\n\t\t\t\tmax_frame_len = MAX(mtu, 65535);\n\t\t\telse\n\t\t\t\tmax_frame_len = mtu;\n\t\t\tmax_frame_len += 18;\n\n\t\t\tif (frame_size > max_frame_len)\n\t\t\t\tframe_size = max_frame_len;\n\t\t}\n\n\t\t/* NOTE: calculus matching those in tpacket_rcv()\n\t\t * in linux-2.6/net/packet/af_packet.c\n\t\t */\n\t\tlen = sizeof(sk_type);\n\t\tif (getsockopt(handle->fd, SOL_SOCKET, SO_TYPE, &sk_type,\n\t\t    &len) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"getsockopt (SO_TYPE)\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tmaclen = (sk_type == SOCK_DGRAM) ? 0 : MAX_LINKHEADER_SIZE;\n\t\t\t/* XXX: in the kernel maclen is calculated from\n\t\t\t * LL_ALLOCATED_SPACE(dev) and vnet_hdr.hdr_len\n\t\t\t * in:  packet_snd()           in linux-2.6/net/packet/af_packet.c\n\t\t\t * then packet_alloc_skb()     in linux-2.6/net/packet/af_packet.c\n\t\t\t * then sock_alloc_send_pskb() in linux-2.6/net/core/sock.c\n\t\t\t * but I see no way to get those sizes in userspace,\n\t\t\t * like for instance with an ifreq ioctl();\n\t\t\t * the best thing I've found so far is MAX_HEADER in\n\t\t\t * the kernel part of linux-2.6/include/linux/netdevice.h\n\t\t\t * which goes up to 128+48=176; since pcap-linux.c\n\t\t\t * defines a MAX_LINKHEADER_SIZE of 256 which is\n\t\t\t * greater than that, let's use it.. maybe is it even\n\t\t\t * large enough to directly replace macoff..\n\t\t\t */\n\t\ttp_hdrlen = TPACKET_ALIGN(handlep->tp_hdrlen) + sizeof(struct sockaddr_ll) ;\n\t\tnetoff = TPACKET_ALIGN(tp_hdrlen + (maclen < 16 ? 16 : maclen)) + tp_reserve;\n\t\t\t/* NOTE: AFAICS tp_reserve may break the TPACKET_ALIGN\n\t\t\t * of netoff, which contradicts\n\t\t\t * linux-2.6/Documentation/networking/packet_mmap.txt\n\t\t\t * documenting that:\n\t\t\t * \"- Gap, chosen so that packet data (Start+tp_net)\n\t\t\t * aligns to TPACKET_ALIGNMENT=16\"\n\t\t\t */\n\t\t\t/* NOTE: in linux-2.6/include/linux/skbuff.h:\n\t\t\t * \"CPUs often take a performance hit\n\t\t\t *  when accessing unaligned memory locations\"\n\t\t\t */\n\t\tmacoff = netoff - maclen;\n\t\treq.tp_frame_size = TPACKET_ALIGN(macoff + frame_size);\n\t\t/*\n\t\t * Round the buffer size up to a multiple of the\n\t\t * frame size (rather than rounding down, which\n\t\t * would give a buffer smaller than our caller asked\n\t\t * for, and possibly give zero frames if the requested\n\t\t * buffer size is too small for one frame).\n\t\t */\n\t\treq.tp_frame_nr = (handle->opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;\n\t\tbreak;\n\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\t/* The \"frames\" for this are actually buffers that\n\t\t * contain multiple variable-sized frames.\n\t\t *\n\t\t * We pick a \"frame\" size of MAXIMUM_SNAPLEN to leave\n\t\t * enough room for at least one reasonably-sized packet\n\t\t * in the \"frame\". */\n\t\treq.tp_frame_size = MAXIMUM_SNAPLEN;\n\t\t/*\n\t\t * Round the buffer size up to a multiple of the\n\t\t * \"frame\" size (rather than rounding down, which\n\t\t * would give a buffer smaller than our caller asked\n\t\t * for, and possibly give zero \"frames\" if the requested\n\t\t * buffer size is too small for one \"frame\").\n\t\t */\n\t\treq.tp_frame_nr = (handle->opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Internal error: unknown TPACKET_ value %u\",\n\t\t    handlep->tp_version);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* compute the minimum block size that will handle this frame.\n\t * The block has to be page size aligned.\n\t * The max block size allowed by the kernel is arch-dependent and\n\t * it's not explicitly checked here. */\n\treq.tp_block_size = getpagesize();\n\twhile (req.tp_block_size < req.tp_frame_size)\n\t\treq.tp_block_size <<= 1;\n\n\tframes_per_block = req.tp_block_size/req.tp_frame_size;\n\n\t/*\n\t * PACKET_TIMESTAMP was added after linux/net_tstamp.h was,\n\t * so we check for PACKET_TIMESTAMP.  We check for\n\t * linux/net_tstamp.h just in case a system somehow has\n\t * PACKET_TIMESTAMP but not linux/net_tstamp.h; that might\n\t * be unnecessary.\n\t *\n\t * SIOCSHWTSTAMP was introduced in the patch that introduced\n\t * linux/net_tstamp.h, so we don't bother checking whether\n\t * SIOCSHWTSTAMP is defined (if your Linux system has\n\t * linux/net_tstamp.h but doesn't define SIOCSHWTSTAMP, your\n\t * Linux system is badly broken).\n\t */\n#if defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP)\n\t/*\n\t * If we were told to do so, ask the kernel and the driver\n\t * to use hardware timestamps.\n\t *\n\t * Hardware timestamps are only supported with mmapped\n\t * captures.\n\t */\n\tif (handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER ||\n\t    handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER_UNSYNCED) {\n\t\tstruct hwtstamp_config hwconfig;\n\t\tstruct ifreq ifr;\n\t\tint timesource;\n\n\t\t/*\n\t\t * Ask for hardware time stamps on all packets,\n\t\t * including transmitted packets.\n\t\t */\n\t\tmemset(&hwconfig, 0, sizeof(hwconfig));\n\t\thwconfig.tx_type = HWTSTAMP_TX_ON;\n\t\thwconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\tpcapint_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));\n\t\tifr.ifr_data = (void *)&hwconfig;\n\n\t\t/*\n\t\t * This may require CAP_NET_ADMIN.\n\t\t */\n\t\tif (ioctl(handle->fd, SIOCSHWTSTAMP, &ifr) < 0) {\n\t\t\tswitch (errno) {\n\n\t\t\tcase EPERM:\n\t\t\t\t/*\n\t\t\t\t * Treat this as an error, as the\n\t\t\t\t * user should try to run this\n\t\t\t\t * with the appropriate privileges -\n\t\t\t\t * and, if they can't, shouldn't\n\t\t\t\t * try requesting hardware time stamps.\n\t\t\t\t */\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Attempt to set hardware timestamp failed - CAP_NET_ADMIN may be required\");\n\t\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\n\t\t\tcase EOPNOTSUPP:\n\t\t\tcase ERANGE:\n\t\t\t\t/*\n\t\t\t\t * Treat this as a warning, as the\n\t\t\t\t * only way to fix the warning is to\n\t\t\t\t * get an adapter that supports hardware\n\t\t\t\t * time stamps for *all* packets.\n\t\t\t\t * (ERANGE means \"we support hardware\n\t\t\t\t * time stamps, but for packets matching\n\t\t\t\t * that particular filter\", so it means\n\t\t\t\t * \"we don't support hardware time stamps\n\t\t\t\t * for all incoming packets\" here.)\n\t\t\t\t *\n\t\t\t\t * We'll just fall back on the standard\n\t\t\t\t * host time stamps.\n\t\t\t\t */\n\t\t\t\tstatus = PCAP_WARNING_TSTAMP_TYPE_NOTSUP;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCSHWTSTAMP failed\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Well, that worked.  Now specify the type of\n\t\t\t * hardware time stamp we want for this\n\t\t\t * socket.\n\t\t\t */\n\t\t\tif (handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER) {\n\t\t\t\t/*\n\t\t\t\t * Hardware timestamp, synchronized\n\t\t\t\t * with the system clock.\n\t\t\t\t */\n\t\t\t\ttimesource = SOF_TIMESTAMPING_SYS_HARDWARE;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * PCAP_TSTAMP_ADAPTER_UNSYNCED - hardware\n\t\t\t\t * timestamp, not synchronized with the\n\t\t\t\t * system clock.\n\t\t\t\t */\n\t\t\t\ttimesource = SOF_TIMESTAMPING_RAW_HARDWARE;\n\t\t\t}\n\t\t\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_TIMESTAMP,\n\t\t\t\t(void *)&timesource, sizeof(timesource))) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"can't set PACKET_TIMESTAMP\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\t}\n#endif /* HAVE_LINUX_NET_TSTAMP_H && PACKET_TIMESTAMP */\n\n\t/* ask the kernel to create the ring */\nretry:\n\treq.tp_block_nr = req.tp_frame_nr / frames_per_block;\n\n\t/* req.tp_frame_nr is requested to match frames_per_block*req.tp_block_nr */\n\treq.tp_frame_nr = req.tp_block_nr * frames_per_block;\n\n#ifdef HAVE_TPACKET3\n\t/* timeout value to retire block - use the configured buffering timeout, or default if <0. */\n\tif (handlep->timeout > 0) {\n\t\t/* Use the user specified timeout as the block timeout */\n\t\treq.tp_retire_blk_tov = handlep->timeout;\n\t} else if (handlep->timeout == 0) {\n\t\t/*\n\t\t * In pcap, this means \"infinite timeout\"; TPACKET_V3\n\t\t * doesn't support that, so just set it to UINT_MAX\n\t\t * milliseconds.  In the TPACKET_V3 loop, if the\n\t\t * timeout is 0, and we haven't yet seen any packets,\n\t\t * and we block and still don't have any packets, we\n\t\t * keep blocking until we do.\n\t\t */\n\t\treq.tp_retire_blk_tov = UINT_MAX;\n\t} else {\n\t\t/*\n\t\t * XXX - this is not valid; use 0, meaning \"have the\n\t\t * kernel pick a default\", for now.\n\t\t */\n\t\treq.tp_retire_blk_tov = 0;\n\t}\n\t/* private data not used */\n\treq.tp_sizeof_priv = 0;\n\t/* Rx ring - feature request bits - none (rxhash will not be filled) */\n\treq.tp_feature_req_word = 0;\n#endif\n\n\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_RX_RING,\n\t\t\t\t\t(void *) &req, sizeof(req))) {\n\t\tif ((errno == ENOMEM) && (req.tp_block_nr > 1)) {\n\t\t\t/*\n\t\t\t * Memory failure; try to reduce the requested ring\n\t\t\t * size.\n\t\t\t *\n\t\t\t * We used to reduce this by half -- do 5% instead.\n\t\t\t * That may result in more iterations and a longer\n\t\t\t * startup, but the user will be much happier with\n\t\t\t * the resulting buffer size.\n\t\t\t */\n\t\t\tif (req.tp_frame_nr < 20)\n\t\t\t\treq.tp_frame_nr -= 1;\n\t\t\telse\n\t\t\t\treq.tp_frame_nr -= req.tp_frame_nr/20;\n\t\t\tgoto retry;\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't create rx ring on packet socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* memory map the rx ring */\n\thandlep->mmapbuflen = req.tp_block_nr * req.tp_block_size;\n#ifdef MAP_32BIT\n\tif (pcapint_mmap_32bit) flags |= MAP_32BIT;\n#endif\n\thandlep->mmapbuf = mmap(0, handlep->mmapbuflen, PROT_READ | PROT_WRITE, flags, handle->fd, 0);\n\tif (handlep->mmapbuf == MAP_FAILED) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't mmap rx ring\");\n\n\t\t/* clear the allocated ring on error*/\n\t\tdestroy_ring(handle);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* allocate a ring for each frame header pointer*/\n\thandle->cc = req.tp_frame_nr;\n\thandle->buffer = malloc(handle->cc * sizeof(union thdr *));\n\tif (!handle->buffer) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't allocate ring of frame headers\");\n\n\t\tdestroy_ring(handle);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* fill the header ring with proper frame ptr*/\n\thandle->offset = 0;\n\tfor (i=0; i<req.tp_block_nr; ++i) {\n\t\tu_char *base = &handlep->mmapbuf[i*req.tp_block_size];\n\t\tfor (j=0; j<frames_per_block; ++j, ++handle->offset) {\n\t\t\tRING_GET_CURRENT_FRAME(handle) = base;\n\t\t\tbase += req.tp_frame_size;\n\t\t}\n\t}\n\n\thandle->bufsize = req.tp_frame_size;\n\thandle->offset = 0;\n\treturn status;\n}\n\n/* free all ring related resources*/\nstatic void\ndestroy_ring(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/*\n\t * Tell the kernel to destroy the ring.\n\t * We don't check for setsockopt failure, as 1) we can't recover\n\t * from an error and 2) we might not yet have set it up in the\n\t * first place.\n\t */\n\tstruct tpacket_req req;\n\tmemset(&req, 0, sizeof(req));\n\t(void)setsockopt(handle->fd, SOL_PACKET, PACKET_RX_RING,\n\t\t\t\t(void *) &req, sizeof(req));\n\n\t/* if ring is mapped, unmap it*/\n\tif (handlep->mmapbuf) {\n\t\t/* do not test for mmap failure, as we can't recover from any error */\n\t\t(void)munmap(handlep->mmapbuf, handlep->mmapbuflen);\n\t\thandlep->mmapbuf = NULL;\n\t}\n}\n\n/*\n * Special one-shot callback, used for pcap_next() and pcap_next_ex(),\n * for Linux mmapped capture.\n *\n * The problem is that pcap_next() and pcap_next_ex() expect the packet\n * data handed to the callback to be valid after the callback returns,\n * but pcap_read_linux_mmap() has to release that packet as soon as\n * the callback returns (otherwise, the kernel thinks there's still\n * at least one unprocessed packet available in the ring, so a select()\n * will immediately return indicating that there's data to process), so,\n * in the callback, we have to make a copy of the packet.\n *\n * Yes, this means that, if the capture is using the ring buffer, using\n * pcap_next() or pcap_next_ex() requires more copies than using\n * pcap_loop() or pcap_dispatch().  If that bothers you, don't use\n * pcap_next() or pcap_next_ex().\n */\nstatic void\npcapint_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,\n    const u_char *bytes)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *)user;\n\tpcap_t *handle = sp->pd;\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t*sp->hdr = *h;\n\tmemcpy(handlep->oneshot_buffer, bytes, h->caplen);\n\t*sp->pkt = handlep->oneshot_buffer;\n}\n\nstatic int\npcap_getnonblock_linux(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/* use negative value of timeout to indicate non blocking ops */\n\treturn (handlep->timeout<0);\n}\n\nstatic int\npcap_setnonblock_linux(pcap_t *handle, int nonblock)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/*\n\t * Set the file descriptor to the requested mode, as we use\n\t * it for sending packets.\n\t */\n\tif (pcapint_setnonblock_fd(handle, nonblock) == -1)\n\t\treturn -1;\n\n\t/*\n\t * Map each value to their corresponding negation to\n\t * preserve the timeout value provided with pcap_set_timeout.\n\t */\n\tif (nonblock) {\n\t\t/*\n\t\t * We're setting the mode to non-blocking mode.\n\t\t */\n\t\tif (handlep->timeout >= 0) {\n\t\t\t/*\n\t\t\t * Indicate that we're switching to\n\t\t\t * non-blocking mode.\n\t\t\t */\n\t\t\thandlep->timeout = ~handlep->timeout;\n\t\t}\n\t\tif (handlep->poll_breakloop_fd != -1) {\n\t\t\t/* Close the eventfd; we do not need it in nonblock mode. */\n\t\t\tclose(handlep->poll_breakloop_fd);\n\t\t\thandlep->poll_breakloop_fd = -1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're setting the mode to blocking mode.\n\t\t */\n\t\tif (handlep->poll_breakloop_fd == -1) {\n\t\t\t/* If we did not have an eventfd, open one now that we are blocking. */\n\t\t\tif ( ( handlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK) ) == -1 ) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"could not open eventfd\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (handlep->timeout < 0) {\n\t\t\thandlep->timeout = ~handlep->timeout;\n\t\t}\n\t}\n\t/* Update the timeout to use in poll(). */\n\tset_poll_timeout(handlep);\n\treturn 0;\n}\n\n/*\n * Get the status field of the ring buffer frame at a specified offset.\n */\nstatic inline u_int\npcap_get_ring_frame_status(pcap_t *handle, u_int offset)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\n\th.raw = RING_GET_FRAME_AT(handle, offset);\n\tswitch (handlep->tp_version) {\n\tcase TPACKET_V2:\n\t\treturn __atomic_load_n(&h.h2->tp_status, __ATOMIC_ACQUIRE);\n\t\tbreak;\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\treturn __atomic_load_n(&h.h3->hdr.bh1.block_status, __ATOMIC_ACQUIRE);\n\t\tbreak;\n#endif\n\t}\n\t/* This should not happen. */\n\treturn 0;\n}\n\n/*\n * Block waiting for frames to be available.\n */\nstatic int pcap_wait_for_frames_mmap(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint timeout;\n\tstruct ifreq ifr;\n\tint ret;\n\tstruct pollfd pollinfo[2];\n\tint numpollinfo;\n\tpollinfo[0].fd = handle->fd;\n\tpollinfo[0].events = POLLIN;\n\tif ( handlep->poll_breakloop_fd == -1 ) {\n\t\tnumpollinfo = 1;\n\t\tpollinfo[1].revents = 0;\n\t\t/*\n\t\t * We set pollinfo[1].revents to zero, even though\n\t\t * numpollinfo = 1 meaning that poll() doesn't see\n\t\t * pollinfo[1], so that we do not have to add a\n\t\t * conditional of numpollinfo > 1 below when we\n\t\t * test pollinfo[1].revents.\n\t\t */\n\t} else {\n\t\tpollinfo[1].fd = handlep->poll_breakloop_fd;\n\t\tpollinfo[1].events = POLLIN;\n\t\tnumpollinfo = 2;\n\t}\n\n\t/*\n\t * Keep polling until we either get some packets to read, see\n\t * that we got told to break out of the loop, get a fatal error,\n\t * or discover that the device went away.\n\t *\n\t * In non-blocking mode, we must still do one poll() to catch\n\t * any pending error indications, but the poll() has a timeout\n\t * of 0, so that it doesn't block, and we quit after that one\n\t * poll().\n\t *\n\t * If we've seen an ENETDOWN, it might be the first indication\n\t * that the device went away, or it might just be that it was\n\t * configured down.  Unfortunately, there's no guarantee that\n\t * the device has actually been removed as an interface, because:\n\t *\n\t * 1) if, as appears to be the case at least some of the time,\n\t * the PF_PACKET socket code first gets a NETDEV_DOWN indication\n\t * for the device and then gets a NETDEV_UNREGISTER indication\n\t * for it, the first indication will cause a wakeup with ENETDOWN\n\t * but won't set the packet socket's field for the interface index\n\t * to -1, and the second indication won't cause a wakeup (because\n\t * the first indication also caused the protocol hook to be\n\t * unregistered) but will set the packet socket's field for the\n\t * interface index to -1;\n\t *\n\t * 2) even if just a NETDEV_UNREGISTER indication is registered,\n\t * the packet socket's field for the interface index only gets\n\t * set to -1 after the wakeup, so there's a small but non-zero\n\t * risk that a thread blocked waiting for the wakeup will get\n\t * to the \"fetch the socket name\" code before the interface index\n\t * gets set to -1, so it'll get the old interface index.\n\t *\n\t * Therefore, if we got an ENETDOWN and haven't seen a packet\n\t * since then, we assume that we might be waiting for the interface\n\t * to disappear, and poll with a timeout to try again in a short\n\t * period of time.  If we *do* see a packet, the interface has\n\t * come back up again, and is *definitely* still there, so we\n\t * don't need to poll.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Yes, we do this even in non-blocking mode, as it's\n\t\t * the only way to get error indications from a\n\t\t * tpacket socket.\n\t\t *\n\t\t * The timeout is 0 in non-blocking mode, so poll()\n\t\t * returns immediately.\n\t\t */\n\t\ttimeout = handlep->poll_timeout;\n\n\t\t/*\n\t\t * If we got an ENETDOWN and haven't gotten an indication\n\t\t * that the device has gone away or that the device is up,\n\t\t * we don't yet know for certain whether the device has\n\t\t * gone away or not, do a poll() with a 1-millisecond timeout,\n\t\t * as we have to poll indefinitely for \"device went away\"\n\t\t * indications until we either get one or see that the\n\t\t * device is up.\n\t\t */\n\t\tif (handlep->netdown) {\n\t\t\tif (timeout != 0)\n\t\t\t\ttimeout = 1;\n\t\t}\n\t\tret = poll(pollinfo, numpollinfo, timeout);\n\t\tif (ret < 0) {\n\t\t\t/*\n\t\t\t * Error.  If it's not EINTR, report it.\n\t\t\t */\n\t\t\tif (errno != EINTR) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"can't poll on packet socket\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It's EINTR; if we were told to break out of\n\t\t\t * the loop, do so.\n\t\t\t */\n\t\t\tif (handle->break_loop) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t}\n\t\t} else if (ret > 0) {\n\t\t\t/*\n\t\t\t * OK, some descriptor is ready.\n\t\t\t * Check the socket descriptor first.\n\t\t\t *\n\t\t\t * As I read the Linux man page, pollinfo[0].revents\n\t\t\t * will either be POLLIN, POLLERR, POLLHUP, or POLLNVAL.\n\t\t\t */\n\t\t\tif (pollinfo[0].revents == POLLIN) {\n\t\t\t\t/*\n\t\t\t\t * OK, we may have packets to\n\t\t\t\t * read.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pollinfo[0].revents != 0) {\n\t\t\t\t/*\n\t\t\t\t * There's some indication other than\n\t\t\t\t * \"you can read on this descriptor\" on\n\t\t\t\t * the descriptor.\n\t\t\t\t */\n\t\t\t\tif (pollinfo[0].revents & POLLNVAL) {\n\t\t\t\t\tsnprintf(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Invalid polling request on packet socket\");\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\t\t\t\tif (pollinfo[0].revents & (POLLHUP | POLLRDHUP)) {\n\t\t\t\t\tsnprintf(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Hangup on packet socket\");\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\t\t\t\tif (pollinfo[0].revents & POLLERR) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Get the error.\n\t\t\t\t\t */\n\t\t\t\t\tint err;\n\t\t\t\t\tsocklen_t errlen;\n\n\t\t\t\t\terrlen = sizeof(err);\n\t\t\t\t\tif (getsockopt(handle->fd, SOL_SOCKET,\n\t\t\t\t\t    SO_ERROR, &err, &errlen) == -1) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The call *itself* returned\n\t\t\t\t\t\t * an error; make *that*\n\t\t\t\t\t\t * the error.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terr = errno;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * OK, we have the error.\n\t\t\t\t\t */\n\t\t\t\t\tif (err == ENETDOWN) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The device on which we're\n\t\t\t\t\t\t * capturing went away or the\n\t\t\t\t\t\t * interface was taken down.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * We don't know for certain\n\t\t\t\t\t\t * which happened, and the\n\t\t\t\t\t\t * next poll() may indicate\n\t\t\t\t\t\t * that there are packets\n\t\t\t\t\t\t * to be read, so just set\n\t\t\t\t\t\t * a flag to get us to do\n\t\t\t\t\t\t * checks later, and set\n\t\t\t\t\t\t * the required select\n\t\t\t\t\t\t * timeout to 1 millisecond\n\t\t\t\t\t\t * so that event loops that\n\t\t\t\t\t\t * check our socket descriptor\n\t\t\t\t\t\t * also time out so that\n\t\t\t\t\t\t * they can call us and we\n\t\t\t\t\t\t * can do the checks.\n\t\t\t\t\t\t */\n\t\t\t\t\t\thandlep->netdown = 1;\n\t\t\t\t\t\thandle->required_select_timeout = &netdown_timeout;\n\t\t\t\t\t} else if (err == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This shouldn't happen, so\n\t\t\t\t\t\t * report a special indication\n\t\t\t\t\t\t * that it did.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsnprintf(handle->errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t    \"Error condition on packet socket: Reported error was 0\");\n\t\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t    err,\n\t\t\t\t\t\t    \"Error condition on packet socket\");\n\t\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Now check the event device.\n\t\t\t */\n\t\t\tif (pollinfo[1].revents & POLLIN) {\n\t\t\t\tssize_t nread;\n\t\t\t\tuint64_t value;\n\n\t\t\t\t/*\n\t\t\t\t * This should never fail, but, just\n\t\t\t\t * in case....\n\t\t\t\t */\n\t\t\t\tnread = read(handlep->poll_breakloop_fd, &value,\n\t\t\t\t    sizeof(value));\n\t\t\t\tif (nread == -1) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    errno,\n\t\t\t\t\t    \"Error reading from event FD\");\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * According to the Linux read(2) man\n\t\t\t\t * page, read() will transfer at most\n\t\t\t\t * 2^31-1 bytes, so the return value is\n\t\t\t\t * either -1 or a value between 0\n\t\t\t\t * and 2^31-1, so it's non-negative.\n\t\t\t\t *\n\t\t\t\t * Cast it to size_t to squelch\n\t\t\t\t * warnings from the compiler; add this\n\t\t\t\t * comment to squelch warnings from\n\t\t\t\t * humans reading the code. :-)\n\t\t\t\t *\n\t\t\t\t * Don't treat an EOF as an error, but\n\t\t\t\t * *do* treat a short read as an error;\n\t\t\t\t * that \"shouldn't happen\", but....\n\t\t\t\t */\n\t\t\t\tif (nread != 0 &&\n\t\t\t\t    (size_t)nread < sizeof(value)) {\n\t\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Short read from event FD: expected %zu, got %zd\",\n\t\t\t\t\t    sizeof(value), nread);\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * This event gets signaled by a\n\t\t\t\t * pcap_breakloop() call; if we were told\n\t\t\t\t * to break out of the loop, do so.\n\t\t\t\t */\n\t\t\t\tif (handle->break_loop) {\n\t\t\t\t\thandle->break_loop = 0;\n\t\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Either:\n\t\t *\n\t\t *   1) we got neither an error from poll() nor any\n\t\t *      readable descriptors, in which case there\n\t\t *      are no packets waiting to read\n\t\t *\n\t\t * or\n\t\t *\n\t\t *   2) We got readable descriptors but the PF_PACKET\n\t\t *      socket wasn't one of them, in which case there\n\t\t *      are no packets waiting to read\n\t\t *\n\t\t * so, if we got an ENETDOWN, we've drained whatever\n\t\t * packets were available to read at the point of the\n\t\t * ENETDOWN.\n\t\t *\n\t\t * So, if we got an ENETDOWN and haven't gotten an indication\n\t\t * that the device has gone away or that the device is up,\n\t\t * we don't yet know for certain whether the device has\n\t\t * gone away or not, check whether the device exists and is\n\t\t * up.\n\t\t */\n\t\tif (handlep->netdown) {\n\t\t\tif (!device_still_exists(handle)) {\n\t\t\t\t/*\n\t\t\t\t * The device doesn't exist any more;\n\t\t\t\t * report that.\n\t\t\t\t *\n\t\t\t\t * XXX - we should really return an\n\t\t\t\t * appropriate error for that, but\n\t\t\t\t * pcap_dispatch() etc. aren't documented\n\t\t\t\t * as having error returns other than\n\t\t\t\t * PCAP_ERROR or PCAP_ERROR_BREAK.\n\t\t\t\t */\n\t\t\t\tsnprintf(handle->errbuf,  PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"The interface disappeared\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The device still exists; try to see if it's up.\n\t\t\t */\n\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\tpcapint_strlcpy(ifr.ifr_name, handlep->device,\n\t\t\t    sizeof(ifr.ifr_name));\n\t\t\tif (ioctl(handle->fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\t\t\tif (errno == ENXIO || errno == ENODEV) {\n\t\t\t\t\t/*\n\t\t\t\t\t * OK, *now* it's gone.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - see above comment.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"The interface disappeared\");\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t} else {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"%s: Can't get flags\",\n\t\t\t\t\t    handlep->device);\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ifr.ifr_flags & IFF_UP) {\n\t\t\t\t/*\n\t\t\t\t * It's up, so it definitely still exists.\n\t\t\t\t * Cancel the ENETDOWN indication - we\n\t\t\t\t * presumably got it due to the interface\n\t\t\t\t * going down rather than the device going\n\t\t\t\t * away - and revert to \"no required select\n\t\t\t\t * timeout.\n\t\t\t\t */\n\t\t\t\thandlep->netdown = 0;\n\t\t\t\thandle->required_select_timeout = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we're in non-blocking mode, just quit now, rather\n\t\t * than spinning in a loop doing poll()s that immediately\n\t\t * time out if there's no indication on any descriptor.\n\t\t */\n\t\tif (handlep->poll_timeout == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/* handle a single memory mapped packet */\nstatic int pcap_handle_packet_mmap(\n\t\tpcap_t *handle,\n\t\tpcap_handler callback,\n\t\tu_char *user,\n\t\tunsigned char *frame,\n\t\tunsigned int tp_len,\n\t\tunsigned int tp_mac,\n\t\tunsigned int tp_snaplen,\n\t\tunsigned int tp_sec,\n\t\tunsigned int tp_usec,\n\t\tint tp_vlan_tci_valid,\n\t\t__u16 tp_vlan_tci,\n\t\t__u16 tp_vlan_tpid)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunsigned char *bp;\n\tstruct sockaddr_ll *sll;\n\tstruct pcap_pkthdr pcaphdr;\n\tunsigned int snaplen = tp_snaplen;\n\tstruct utsname utsname;\n\n\t/* perform sanity check on internal offset. */\n\tif (tp_mac + tp_snaplen > handle->bufsize) {\n\t\t/*\n\t\t * Report some system information as a debugging aid.\n\t\t */\n\t\tif (uname(&utsname) != -1) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"corrupted frame on kernel ring mac \"\n\t\t\t\t\"offset %u + caplen %u > frame len %d \"\n\t\t\t\t\"(kernel %.32s version %s, machine %.16s)\",\n\t\t\t\ttp_mac, tp_snaplen, handle->bufsize,\n\t\t\t\tutsname.release, utsname.version,\n\t\t\t\tutsname.machine);\n\t\t} else {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"corrupted frame on kernel ring mac \"\n\t\t\t\t\"offset %u + caplen %u > frame len %d\",\n\t\t\t\ttp_mac, tp_snaplen, handle->bufsize);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* run filter on received packet\n\t * If the kernel filtering is enabled we need to run the\n\t * filter until all the frames present into the ring\n\t * at filter creation time are processed.\n\t * In this case, blocks_to_filter_in_userland is used\n\t * as a counter for the packet we need to filter.\n\t * Note: alternatively it could be possible to stop applying\n\t * the filter when the ring became empty, but it can possibly\n\t * happen a lot later... */\n\tbp = frame + tp_mac;\n\n\t/* if required build in place the sll header*/\n\tsll = (void *)(frame + TPACKET_ALIGN(handlep->tp_hdrlen));\n\tif (handlep->cooked) {\n\t\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t\tstruct sll2_header *hdrp;\n\n\t\t\t/*\n\t\t\t * The kernel should have left us with enough\n\t\t\t * space for an sll header; back up the packet\n\t\t\t * data pointer into that space, as that'll be\n\t\t\t * the beginning of the packet we pass to the\n\t\t\t * callback.\n\t\t\t */\n\t\t\tbp -= SLL2_HDR_LEN;\n\n\t\t\t/*\n\t\t\t * Let's make sure that's past the end of\n\t\t\t * the tpacket header, i.e. >=\n\t\t\t * ((u_char *)thdr + TPACKET_HDRLEN), so we\n\t\t\t * don't step on the header when we construct\n\t\t\t * the sll header.\n\t\t\t */\n\t\t\tif (bp < (u_char *)frame +\n\t\t\t\t\t   TPACKET_ALIGN(handlep->tp_hdrlen) +\n\t\t\t\t\t   sizeof(struct sockaddr_ll)) {\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"cooked-mode frame doesn't have room for sll header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, that worked; construct the sll header.\n\t\t\t */\n\t\t\thdrp = (struct sll2_header *)bp;\n\t\t\thdrp->sll2_protocol = sll->sll_protocol;\n\t\t\thdrp->sll2_reserved_mbz = 0;\n\t\t\thdrp->sll2_if_index = htonl(sll->sll_ifindex);\n\t\t\thdrp->sll2_hatype = htons(sll->sll_hatype);\n\t\t\thdrp->sll2_pkttype = sll->sll_pkttype;\n\t\t\thdrp->sll2_halen = sll->sll_halen;\n\t\t\tmemcpy(hdrp->sll2_addr, sll->sll_addr, SLL_ADDRLEN);\n\n\t\t\tsnaplen += sizeof(struct sll2_header);\n\t\t} else {\n\t\t\tstruct sll_header *hdrp;\n\n\t\t\t/*\n\t\t\t * The kernel should have left us with enough\n\t\t\t * space for an sll header; back up the packet\n\t\t\t * data pointer into that space, as that'll be\n\t\t\t * the beginning of the packet we pass to the\n\t\t\t * callback.\n\t\t\t */\n\t\t\tbp -= SLL_HDR_LEN;\n\n\t\t\t/*\n\t\t\t * Let's make sure that's past the end of\n\t\t\t * the tpacket header, i.e. >=\n\t\t\t * ((u_char *)thdr + TPACKET_HDRLEN), so we\n\t\t\t * don't step on the header when we construct\n\t\t\t * the sll header.\n\t\t\t */\n\t\t\tif (bp < (u_char *)frame +\n\t\t\t\t\t   TPACKET_ALIGN(handlep->tp_hdrlen) +\n\t\t\t\t\t   sizeof(struct sockaddr_ll)) {\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"cooked-mode frame doesn't have room for sll header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, that worked; construct the sll header.\n\t\t\t */\n\t\t\thdrp = (struct sll_header *)bp;\n\t\t\thdrp->sll_pkttype = htons(sll->sll_pkttype);\n\t\t\thdrp->sll_hatype = htons(sll->sll_hatype);\n\t\t\thdrp->sll_halen = htons(sll->sll_halen);\n\t\t\tmemcpy(hdrp->sll_addr, sll->sll_addr, SLL_ADDRLEN);\n\t\t\thdrp->sll_protocol = sll->sll_protocol;\n\n\t\t\tsnaplen += sizeof(struct sll_header);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If this is a packet from a CAN device, so that\n\t\t * sll->sll_hatype is ARPHRD_CAN, then, as we're\n\t\t * not capturing in cooked mode, its link-layer\n\t\t * type is DLT_CAN_SOCKETCAN.  Fix up the header\n\t\t * provided by the code below us to match what\n\t\t * DLT_CAN_SOCKETCAN is expected to provide.\n\t\t */\n\t\tif (sll->sll_hatype == ARPHRD_CAN) {\n\t\t\tpcap_can_socketcan_hdr *canhdr = (pcap_can_socketcan_hdr *)bp;\n\t\t\tpcap_can_socketcan_xl_hdr *canxl_hdr = (pcap_can_socketcan_xl_hdr *)bp;\n\t\t\tuint16_t protocol = ntohs(sll->sll_protocol);\n\n\t\t\t/*\n\t\t\t * Check the protocol field from the sll header.\n\t\t\t * If it's one of the known CAN protocol types,\n\t\t\t * make sure the appropriate flags are set, so\n\t\t\t * that a program can tell what type of frame\n\t\t\t * it is.\n\t\t\t *\n\t\t\t * These operations should not have any effect\n\t\t\t * when reading proper CAN frames from Linux\n\t\t\t * CAN interfaces. Enforcing these bit values\n\t\t\t * ensures proper DLT_CAN_SOCKETCAN data even\n\t\t\t * with malformed PF_PACKET content.\n\t\t\t *\n\t\t\t * The two flags are:\n\t\t\t *\n\t\t\t *   CANFD_FDF, which is in the fd_flags field\n\t\t\t *   of the CAN CC/CAN FD header;\n\t\t\t *\n\t\t\t *   CANXL_XLF, which is in the flags field\n\t\t\t *   of the CAN XL header, which overlaps\n\t\t\t *   the payload_length field of the CAN CC/\n\t\t\t *   CAN FD header. Setting CANXL_XLF in the\n\t\t\t *   payload_length of CAN CC/FD frames would\n\t\t\t *   intentionally break the payload length.\n\t\t\t */\n\t\t\tswitch (protocol) {\n\n\t\t\tcase LINUX_SLL_P_CAN:\n\t\t\t\t/*\n\t\t\t\t * CAN CC frame (aka Classical CAN, CAN 2.0B)\n\t\t\t\t *\n\t\t\t\t * Zero out the CAN FD and CAN XL flags\n\t\t\t\t * so that this frame will be identified\n\t\t\t\t * as a CAN CC frame.\n\t\t\t\t */\n\t\t\t\tcanxl_hdr->flags &= ~CANXL_XLF;\n\t\t\t\tcanhdr->fd_flags &= ~CANFD_FDF;\n\t\t\t\tbreak;\n\n\t\t\tcase LINUX_SLL_P_CANFD:\n\t\t\t\t/*\n\t\t\t\t * CAN FD frame\n\t\t\t\t *\n\t\t\t\t * Set CANFD_FDF in the fd_flags field,\n\t\t\t\t * and clear the CANXL_XLF bit in the\n\t\t\t\t * CAN XL flags field, so that this frame\n\t\t\t\t * will be identified as a CAN FD frame.\n\t\t\t\t *\n\t\t\t\t * The CANFD_FDF bit is not reliably\n\t\t\t\t * set by the Linux kernel. But setting\n\t\t\t\t * that bit for CAN FD is recommended.\n\t\t\t\t */\n\t\t\t\tcanxl_hdr->flags &= ~CANXL_XLF;\n\t\t\t\tcanhdr->fd_flags |= CANFD_FDF;\n\t\t\t\tbreak;\n\n\t\t\tcase LINUX_SLL_P_CANXL:\n\t\t\t\t/*\n\t\t\t\t * CAN XL frame\n\t\t\t\t *\n\t\t\t\t * Set CANXL_XLF bit in the CAN XL flags\n\t\t\t\t * field, so that this frame will appear\n\t\t\t\t * to be a CAN XL frame.\n\t\t\t\t */\n\t\t\t\tcanxl_hdr->flags |= CANXL_XLF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Put multi-byte header fields in a byte-order\n\t\t\t *-independent format.\n\t\t\t */\n\t\t\tif (canxl_hdr->flags & CANXL_XLF) {\n\t\t\t\t/*\n\t\t\t\t * This is a CAN XL frame.\n\t\t\t\t *\n\t\t\t\t * DLT_CAN_SOCKETCAN is specified as having\n\t\t\t\t * the Priority ID/VCID field in big--\n\t\t\t\t * endian byte order, and the payload length\n\t\t\t\t * and Acceptance Field in little-endian byte\n\t\t\t\t * order. but capturing on a CAN device\n\t\t\t\t * provides them in host byte order.\n\t\t\t\t * Convert them to the appropriate byte\n\t\t\t\t * orders.\n\t\t\t\t *\n\t\t\t\t * The reason we put the first field\n\t\t\t\t * into big-endian byte order is that\n\t\t\t\t * older libpcap code, ignorant of\n\t\t\t\t * CAN XL, treated it as the CAN ID\n\t\t\t\t * field and put it into big-endian\n\t\t\t\t * byte order, and we don't want to\n\t\t\t\t * break code that understands CAN XL\n\t\t\t\t * headers, and treats that field as\n\t\t\t\t * being big-endian.\n\t\t\t\t *\n\t\t\t\t * The other fields are put in little-\n\t\t\t\t * endian byte order is that older\n\t\t\t\t * libpcap code, ignorant of CAN XL,\n\t\t\t\t * left those fields alone, and the\n\t\t\t\t * processors on which the CAN XL\n\t\t\t\t * frames were captured are likely\n\t\t\t\t * to be little-endian processors.\n\t\t\t\t */\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n\t\t\t\t/*\n\t\t\t\t * We're capturing on a little-endian\n\t\t\t\t * machine, so we put the priority/VCID\n\t\t\t\t * field into big-endian byte order, and\n\t\t\t\t * leave the payload length and acceptance\n\t\t\t\t * field in little-endian byte order.\n\t\t\t\t */\n\t\t\t\t/* Byte-swap priority/VCID. */\n\t\t\t\tcanxl_hdr->priority_vcid = SWAPLONG(canxl_hdr->priority_vcid);\n#elif __BYTE_ORDER == __BIG_ENDIAN\n\t\t\t\t/*\n\t\t\t\t * We're capturing on a big-endian\n\t\t\t\t * machine, so we want to leave the\n\t\t\t\t * priority/VCID field alone, and byte-swap\n\t\t\t\t * the payload length and acceptance\n\t\t\t\t * fields to little-endian.\n\t\t\t\t */\n\t\t\t\t/* Byte-swap the payload length */\n\t\t\t\tcanxl_hdr->payload_length = SWAPSHORT(canxl_hdr->payload_length);\n\n\t\t\t\t/*\n\t\t\t\t * Byte-swap the acceptance field.\n\t\t\t\t *\n\t\t\t\t * XXX - is it just a 4-octet string,\n\t\t\t\t * not in any byte order?\n\t\t\t\t */\n\t\t\t\tcanxl_hdr->acceptance_field = SWAPLONG(canxl_hdr->acceptance_field);\n#else\n#error \"Unknown byte order\"\n#endif\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * CAN CC or CAN FD frame.\n\t\t\t\t *\n\t\t\t\t * DLT_CAN_SOCKETCAN is specified as having\n\t\t\t\t * the CAN ID and flags in network byte\n\t\t\t\t * order, but capturing on a CAN device\n\t\t\t\t * provides it in host byte order.  Convert\n\t\t\t\t * it to network byte order.\n\t\t\t\t */\n\t\t\t\tcanhdr->can_id = htonl(canhdr->can_id);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handlep->filter_in_userland && handle->fcode.bf_insns) {\n\t\tstruct pcap_bpf_aux_data aux_data;\n\n\t\taux_data.vlan_tag_present = tp_vlan_tci_valid;\n\t\taux_data.vlan_tag = tp_vlan_tci & 0x0fff;\n\n\t\tif (pcapint_filter_with_aux_data(handle->fcode.bf_insns,\n\t\t\t\t\t      bp,\n\t\t\t\t\t      tp_len,\n\t\t\t\t\t      snaplen,\n\t\t\t\t\t      &aux_data) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (!linux_check_direction(handle, sll))\n\t\treturn 0;\n\n\t/*\n\t * Get required packet info from ring header.\n\t *\n\t * The seconds part of the time stamp is a 32-bit\n\t * unsigned integer; this will have a problem in 2106,\n\t * but not in 2038.\n\t *\n\t * ts.tv_sec is a time_t, which is signed, and which\n\t * may be 32-bit or 64-bit.  Pass it through; if we\n\t * have a 32-bit signed time_t, in which values >\n\t * 2^31-1 won't fit, then:\n\t *\n\t *    Writing the packet to a file will pass the bits\n\t *    through.  If the program reading the file can\n\t *    handle 32-bit unsigned time stamps, including\n\t *    any conversion to local time or UTC, it will\n\t *    properly handle the time stamps.\n\t *\n\t *    Reporting the packet time stamp may give\n\t *    an error or a pre-1970 time stamp on platforms\n\t *    with signed 32-bit time stamps, but that\n\t *    will happen even if it's captured on a\n\t *    platform with a 64-bit time_t.\n\t */\n\tpcaphdr.ts.tv_sec = tp_sec;\n\tpcaphdr.ts.tv_usec = tp_usec;\n\tpcaphdr.caplen = tp_snaplen;\n\tpcaphdr.len = tp_len;\n\n\t/* if required build in place the sll header*/\n\tif (handlep->cooked) {\n\t\t/* update packet len */\n\t\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t\tpcaphdr.caplen += SLL2_HDR_LEN;\n\t\t\tpcaphdr.len += SLL2_HDR_LEN;\n\t\t} else {\n\t\t\tpcaphdr.caplen += SLL_HDR_LEN;\n\t\t\tpcaphdr.len += SLL_HDR_LEN;\n\t\t}\n\t}\n\n\tif (tp_vlan_tci_valid &&\n\t\thandlep->vlan_offset != -1 &&\n\t\ttp_snaplen >= (unsigned int) handlep->vlan_offset)\n\t{\n\t\tstruct vlan_tag *tag;\n\n\t\t/*\n\t\t * Move everything in the header, except the type field,\n\t\t * down VLAN_TAG_LEN bytes, to allow us to insert the\n\t\t * VLAN tag between that stuff and the type field.\n\t\t */\n\t\tbp -= VLAN_TAG_LEN;\n\t\tmemmove(bp, bp + VLAN_TAG_LEN, handlep->vlan_offset);\n\n\t\t/*\n\t\t * Now insert the tag.\n\t\t */\n\t\ttag = (struct vlan_tag *)(bp + handlep->vlan_offset);\n\t\ttag->vlan_tpid = htons(tp_vlan_tpid);\n\t\ttag->vlan_tci = htons(tp_vlan_tci);\n\n\t\t/*\n\t\t * Add the tag to the packet lengths.\n\t\t */\n\t\tpcaphdr.caplen += VLAN_TAG_LEN;\n\t\tpcaphdr.len += VLAN_TAG_LEN;\n\t}\n\n\t/*\n\t * The only way to tell the kernel to cut off the\n\t * packet at a snapshot length is with a filter program;\n\t * if there's no filter program, the kernel won't cut\n\t * the packet off.\n\t *\n\t * Trim the snapshot length to be no longer than the\n\t * specified snapshot length.\n\t *\n\t * XXX - an alternative is to put a filter, consisting\n\t * of a \"ret <snaplen>\" instruction, on the socket\n\t * in the activate routine, so that the truncation is\n\t * done in the kernel even if nobody specified a filter;\n\t * that means that less buffer space is consumed in\n\t * the memory-mapped buffer.\n\t */\n\tif (pcaphdr.caplen > (bpf_u_int32)handle->snapshot)\n\t\tpcaphdr.caplen = handle->snapshot;\n\n\t/* pass the packet to the user */\n\tcallback(user, &pcaphdr, bp);\n\n\treturn 1;\n}\n\nstatic int\npcap_read_linux_mmap_v2(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\n\t/* wait for frames availability.*/\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (!packet_mmap_acquire(h.h2)) {\n\t\t/*\n\t\t * The current frame is owned by the kernel; wait for\n\t\t * a frame to be handed to us.\n\t\t */\n\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(max_packets))\n\t\tmax_packets = INT_MAX;\n\n\twhile (pkts < max_packets) {\n\t\t/*\n\t\t * Get the current ring buffer frame, and break if\n\t\t * it's still owned by the kernel.\n\t\t */\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (!packet_mmap_acquire(h.h2))\n\t\t\tbreak;\n\n\t\tret = pcap_handle_packet_mmap(\n\t\t\t\thandle,\n\t\t\t\tcallback,\n\t\t\t\tuser,\n\t\t\t\th.raw,\n\t\t\t\th.h2->tp_len,\n\t\t\t\th.h2->tp_mac,\n\t\t\t\th.h2->tp_snaplen,\n\t\t\t\th.h2->tp_sec,\n\t\t\t\thandle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? h.h2->tp_nsec : h.h2->tp_nsec / 1000,\n\t\t\t\tVLAN_VALID(h.h2, h.h2),\n\t\t\t\th.h2->tp_vlan_tci,\n\t\t\t\tVLAN_TPID(h.h2, h.h2));\n\t\tif (ret == 1) {\n\t\t\tpkts++;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Hand this block back to the kernel, and, if we're\n\t\t * counting blocks that need to be filtered in userland\n\t\t * after having been filtered by the kernel, count\n\t\t * the one we've just processed.\n\t\t */\n\t\tpacket_mmap_release(h.h2);\n\t\tif (handlep->blocks_to_filter_in_userland != 0) {\n\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t/*\n\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t * in userland.\n\t\t\t\t */\n\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* next block */\n\t\tif (++handle->offset >= handle->cc)\n\t\t\thandle->offset = 0;\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\treturn pkts;\n}\n\n#ifdef HAVE_TPACKET3\nstatic int\npcap_read_linux_mmap_v3(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\nagain:\n\tif (handlep->current_packet == NULL) {\n\t\t/* wait for frames availability.*/\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (!packet_mmap_v3_acquire(h.h3)) {\n\t\t\t/*\n\t\t\t * The current frame is owned by the kernel; wait\n\t\t\t * for a frame to be handed to us.\n\t\t\t */\n\t\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\t\tif (ret) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (!packet_mmap_v3_acquire(h.h3)) {\n\t\tif (pkts == 0 && handlep->timeout == 0) {\n\t\t\t/* Block until we see a packet. */\n\t\t\tgoto again;\n\t\t}\n\t\treturn pkts;\n\t}\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(max_packets))\n\t\tmax_packets = INT_MAX;\n\n\twhile (pkts < max_packets) {\n\t\tint packets_to_read;\n\n\t\tif (handlep->current_packet == NULL) {\n\t\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\t\tif (!packet_mmap_v3_acquire(h.h3))\n\t\t\t\tbreak;\n\n\t\t\thandlep->current_packet = h.raw + h.h3->hdr.bh1.offset_to_first_pkt;\n\t\t\thandlep->packets_left = h.h3->hdr.bh1.num_pkts;\n\t\t}\n\t\tpackets_to_read = handlep->packets_left;\n\n\t\tif (packets_to_read > (max_packets - pkts)) {\n\t\t\t/*\n\t\t\t * There are more packets in the buffer than\n\t\t\t * the number of packets we have left to\n\t\t\t * process to get up to the maximum number\n\t\t\t * of packets to process.  Only process enough\n\t\t\t * of them to get us up to that maximum.\n\t\t\t */\n\t\t\tpackets_to_read = max_packets - pkts;\n\t\t}\n\n\t\twhile (packets_to_read-- && !handle->break_loop) {\n\t\t\tstruct tpacket3_hdr* tp3_hdr = (struct tpacket3_hdr*) handlep->current_packet;\n\t\t\tret = pcap_handle_packet_mmap(\n\t\t\t\t\thandle,\n\t\t\t\t\tcallback,\n\t\t\t\t\tuser,\n\t\t\t\t\thandlep->current_packet,\n\t\t\t\t\ttp3_hdr->tp_len,\n\t\t\t\t\ttp3_hdr->tp_mac,\n\t\t\t\t\ttp3_hdr->tp_snaplen,\n\t\t\t\t\ttp3_hdr->tp_sec,\n\t\t\t\t\thandle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? tp3_hdr->tp_nsec : tp3_hdr->tp_nsec / 1000,\n\t\t\t\t\tVLAN_VALID(tp3_hdr, &tp3_hdr->hv1),\n\t\t\t\t\ttp3_hdr->hv1.tp_vlan_tci,\n\t\t\t\t\tVLAN_TPID(tp3_hdr, &tp3_hdr->hv1));\n\t\t\tif (ret == 1) {\n\t\t\t\tpkts++;\n\t\t\t} else if (ret < 0) {\n\t\t\t\thandlep->current_packet = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\thandlep->current_packet += tp3_hdr->tp_next_offset;\n\t\t\thandlep->packets_left--;\n\t\t}\n\n\t\tif (handlep->packets_left <= 0) {\n\t\t\t/*\n\t\t\t * Hand this block back to the kernel, and, if\n\t\t\t * we're counting blocks that need to be\n\t\t\t * filtered in userland after having been\n\t\t\t * filtered by the kernel, count the one we've\n\t\t\t * just processed.\n\t\t\t */\n\t\t\tpacket_mmap_v3_release(h.h3);\n\t\t\tif (handlep->blocks_to_filter_in_userland != 0) {\n\t\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t\t * in userland.\n\t\t\t\t\t */\n\t\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* next block */\n\t\t\tif (++handle->offset >= handle->cc)\n\t\t\t\thandle->offset = 0;\n\n\t\t\thandlep->current_packet = NULL;\n\t\t}\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\tif (pkts == 0 && handlep->timeout == 0) {\n\t\t/* Block until we see a packet. */\n\t\tgoto again;\n\t}\n\treturn pkts;\n}\n#endif /* HAVE_TPACKET3 */\n\n/*\n *  Attach the given BPF code to the packet capture device.\n */\nstatic int\npcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)\n{\n\tstruct pcap_linux *handlep;\n\tstruct sock_fprog\tfcode;\n\tint\t\t\tcan_filter_in_kernel;\n\tint\t\t\terr = 0;\n\tu_int\t\t\tn, offset;\n\n\tif (!handle)\n\t\treturn -1;\n\tif (!filter) {\n\t        pcapint_strlcpy(handle->errbuf, \"setfilter: No filter specified\",\n\t\t\tPCAP_ERRBUF_SIZE);\n\t\treturn -1;\n\t}\n\n\thandlep = handle->priv;\n\n\t/* Make our private copy of the filter */\n\n\tif (pcapint_install_bpf_program(handle, filter) < 0)\n\t\t/* pcapint_install_bpf_program() filled in errbuf */\n\t\treturn -1;\n\n\t/*\n\t * Run user level packet filter by default. Will be overridden if\n\t * installing a kernel filter succeeds.\n\t */\n\thandlep->filter_in_userland = 1;\n\n\t/* Install kernel level filter if possible */\n\n\tif (handle->fcode.bf_len > USHRT_MAX) {\n\t\t/*\n\t\t * fcode.len is an unsigned short for current kernel.\n\t\t * I have yet to see BPF-Code with that much\n\t\t * instructions but still it is possible. So for the\n\t\t * sake of correctness I added this check.\n\t\t */\n\t\tfprintf(stderr, \"Warning: Filter too complex for kernel\\n\");\n\t\tfcode.len = 0;\n\t\tfcode.filter = NULL;\n\t\tcan_filter_in_kernel = 0;\n\t} else {\n\t\t/*\n\t\t * Oh joy, the Linux kernel uses struct sock_fprog instead\n\t\t * of struct bpf_program and of course the length field is\n\t\t * of different size. Pointed out by Sebastian\n\t\t *\n\t\t * Oh, and we also need to fix it up so that all \"ret\"\n\t\t * instructions with non-zero operands have MAXIMUM_SNAPLEN\n\t\t * as the operand if we're not capturing in memory-mapped\n\t\t * mode, and so that, if we're in cooked mode, all memory-\n\t\t * reference instructions use special magic offsets in\n\t\t * references to the link-layer header and assume that the\n\t\t * link-layer payload begins at 0; \"fix_program()\" will do\n\t\t * that.\n\t\t */\n\t\tswitch (fix_program(handle, &fcode)) {\n\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Fatal error; just quit.\n\t\t\t * (The \"default\" case shouldn't happen; we\n\t\t\t * return -1 for that reason.)\n\t\t\t */\n\t\t\treturn -1;\n\n\t\tcase 0:\n\t\t\t/*\n\t\t\t * The program performed checks that we can't make\n\t\t\t * work in the kernel.\n\t\t\t */\n\t\t\tcan_filter_in_kernel = 0;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * We have a filter that'll work in the kernel.\n\t\t\t */\n\t\t\tcan_filter_in_kernel = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * NOTE: at this point, we've set both the \"len\" and \"filter\"\n\t * fields of \"fcode\".  As of the 2.6.32.4 kernel, at least,\n\t * those are the only members of the \"sock_fprog\" structure,\n\t * so we initialize every member of that structure.\n\t *\n\t * If there is anything in \"fcode\" that is not initialized,\n\t * it is either a field added in a later kernel, or it's\n\t * padding.\n\t *\n\t * If a new field is added, this code needs to be updated\n\t * to set it correctly.\n\t *\n\t * If there are no other fields, then:\n\t *\n\t *\tif the Linux kernel looks at the padding, it's\n\t *\tbuggy;\n\t *\n\t *\tif the Linux kernel doesn't look at the padding,\n\t *\tthen if some tool complains that we're passing\n\t *\tuninitialized data to the kernel, then the tool\n\t *\tis buggy and needs to understand that it's just\n\t *\tpadding.\n\t */\n\tif (can_filter_in_kernel) {\n\t\tif ((err = set_kernel_filter(handle, &fcode)) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Installation succeeded - using kernel filter,\n\t\t\t * so userland filtering not needed.\n\t\t\t */\n\t\t\thandlep->filter_in_userland = 0;\n\t\t}\n\t\telse if (err == -1)\t/* Non-fatal error */\n\t\t{\n\t\t\t/*\n\t\t\t * Print a warning if we weren't able to install\n\t\t\t * the filter for a reason other than \"this kernel\n\t\t\t * isn't configured to support socket filters.\n\t\t\t */\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\t/*\n\t\t\t\t * Either a kernel memory allocation\n\t\t\t\t * failure occurred, or there's too\n\t\t\t\t * much \"other/option memory\" allocated\n\t\t\t\t * for this socket.  Suggest that they\n\t\t\t\t * increase the \"other/option memory\"\n\t\t\t\t * limit.\n\t\t\t\t */\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Warning: Couldn't allocate kernel memory for filter: try increasing net.core.optmem_max with sysctl\\n\");\n\t\t\t} else if (errno != ENOPROTOOPT && errno != EOPNOTSUPP) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Warning: Kernel filter failed: %s\\n\",\n\t\t\t\t\tpcap_strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we're not using the kernel filter, get rid of any kernel\n\t * filter that might've been there before, e.g. because the\n\t * previous filter could work in the kernel, or because some other\n\t * code attached a filter to the socket by some means other than\n\t * calling \"pcap_setfilter()\".  Otherwise, the kernel filter may\n\t * filter out packets that would pass the new userland filter.\n\t */\n\tif (handlep->filter_in_userland) {\n\t\tif (reset_kernel_filter(handle) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't remove kernel filter\");\n\t\t\terr = -2;\t/* fatal error */\n\t\t}\n\t}\n\n\t/*\n\t * Free up the copy of the filter that was made by \"fix_program()\".\n\t */\n\tif (fcode.filter != NULL)\n\t\tfree(fcode.filter);\n\n\tif (err == -2)\n\t\t/* Fatal error */\n\t\treturn -1;\n\n\t/*\n\t * If we're filtering in userland, there's nothing to do;\n\t * the new filter will be used for the next packet.\n\t */\n\tif (handlep->filter_in_userland)\n\t\treturn 0;\n\n\t/*\n\t * We're filtering in the kernel; the packets present in\n\t * all blocks currently in the ring were already filtered\n\t * by the old filter, and so will need to be filtered in\n\t * userland by the new filter.\n\t *\n\t * Get an upper bound for the number of such blocks; first,\n\t * walk the ring backward and count the free blocks.\n\t */\n\toffset = handle->offset;\n\tif (offset == 0)\n\t\toffset = handle->cc;\n\toffset--;\n\tfor (n=0; n < handle->cc; ++n) {\n\t\tif (offset == 0)\n\t\t\toffset = handle->cc;\n\t\toffset--;\n\t\tif (pcap_get_ring_frame_status(handle, offset) != TP_STATUS_KERNEL)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we found free blocks, decrement the count of free\n\t * blocks by 1, just in case we lost a race with another\n\t * thread of control that was adding a packet while\n\t * we were counting and that had run the filter before\n\t * we changed it.\n\t *\n\t * XXX - could there be more than one block added in\n\t * this fashion?\n\t *\n\t * XXX - is there a way to avoid that race, e.g. somehow\n\t * wait for all packets that passed the old filter to\n\t * be added to the ring?\n\t */\n\tif (n != 0)\n\t\tn--;\n\n\t/*\n\t * Set the count of blocks worth of packets to filter\n\t * in userland to the total number of blocks in the\n\t * ring minus the number of free blocks we found, and\n\t * turn on userland filtering.  (The count of blocks\n\t * worth of packets to filter in userland is guaranteed\n\t * not to be zero - n, above, couldn't be set to a\n\t * value > handle->cc, and if it were equal to\n\t * handle->cc, it wouldn't be zero, and thus would\n\t * be decremented to handle->cc - 1.)\n\t */\n\thandlep->blocks_to_filter_in_userland = handle->cc - n;\n\thandlep->filter_in_userland = 1;\n\n\treturn 0;\n}\n\n/*\n *  Return the index of the given device name. Fill ebuf and return\n *  -1 on failure.\n */\nstatic int\niface_get_id(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFINDEX, &ifr) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFINDEX\");\n\t\treturn -1;\n\t}\n\n\treturn ifr.ifr_ifindex;\n}\n\n/*\n *  Bind the socket associated with FD to the given device.\n *  Return 0 on success or a PCAP_ERROR_ value on a hard error.\n */\nstatic int\niface_bind(int fd, int ifindex, char *ebuf, int protocol)\n{\n\tstruct sockaddr_ll\tsll;\n\tint\t\t\tret, err;\n\tsocklen_t\t\terrlen = sizeof(err);\n\n\tmemset(&sll, 0, sizeof(sll));\n\tsll.sll_family\t\t= AF_PACKET;\n\tsll.sll_ifindex\t\t= ifindex < 0 ? 0 : ifindex;\n\tsll.sll_protocol\t= protocol;\n\n\tif (bind(fd, (struct sockaddr *) &sll, sizeof(sll)) == -1) {\n\t\tif (errno == ENETDOWN) {\n\t\t\t/*\n\t\t\t * Return a \"network down\" indication, so that\n\t\t\t * the application can report that rather than\n\t\t\t * saying we had a mysterious failure and\n\t\t\t * suggest that they report a problem to the\n\t\t\t * libpcap developers.\n\t\t\t */\n\t\t\treturn PCAP_ERROR_IFACE_NOT_UP;\n\t\t}\n\t\tif (errno == ENODEV) {\n\t\t\t/*\n\t\t\t * There's nothing more to say, so clear the\n\t\t\t * error message.\n\t\t\t */\n\t\t\tebuf[0] = '\\0';\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t} else {\n\t\t\tret = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"bind\");\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/* Any pending errors, e.g., network is down? */\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getsockopt (SO_ERROR)\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (err == ENETDOWN) {\n\t\t/*\n\t\t * Return a \"network down\" indication, so that\n\t\t * the application can report that rather than\n\t\t * saying we had a mysterious failure and\n\t\t * suggest that they report a problem to the\n\t\t * libpcap developers.\n\t\t */\n\t\treturn PCAP_ERROR_IFACE_NOT_UP;\n\t} else if (err > 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"bind\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Try to enter monitor mode.\n * If we have libnl, try to create a new monitor-mode device and\n * capture on that; otherwise, just say \"not supported\".\n */\n#ifdef HAVE_LIBNL\nstatic int\nenter_rfmon_mode(pcap_t *handle, int sock_fd, const char *device)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ret;\n\tchar phydev_path[PATH_MAX+1];\n\tstruct nl80211_state nlstate;\n\tstruct ifreq ifr;\n\tu_int n;\n\n\t/*\n\t * Is this a mac80211 device?\n\t */\n\tret = get_mac80211_phydev(handle, device, phydev_path, PATH_MAX);\n\tif (ret < 0)\n\t\treturn ret;\t/* error */\n\tif (ret == 0)\n\t\treturn 0;\t/* no error, but not mac80211 device */\n\n\tret = nl80211_init(handle, &nlstate, device);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/*\n\t * Is this already a monN device?\n\t * If so, we're done.\n\t */\n\tint type;\n\tret = get_if_type(handle, sock_fd, &nlstate, device, &type);\n\tif (ret <= 0) {\n\t\t/*\n\t\t * < 0 is a Hard failure.  Just return ret; handle->errbuf\n\t\t * has already been set.\n\t\t *\n\t\t * 0 is \"device not available\"; the caller should retry later.\n\t\t */\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn ret;\n\t}\n        if (type == NL80211_IFTYPE_MONITOR) {\n\t\t/*\n\t\t * OK, it's already a monitor mode device; just use it.\n\t\t * There's no point in creating another monitor device\n\t\t * that will have to be cleaned up.\n\t\t */\n                nl80211_cleanup(&nlstate);\n                return ret;\n        }\n\n\t/*\n\t * OK, it's apparently a mac80211 device but not a monitor device.\n\t * Try to find an unused monN device for it.\n\t */\n\tfor (n = 0; n < UINT_MAX; n++) {\n\t\t/*\n\t\t * Try mon{n}.\n\t\t */\n\t\tchar mondevice[3+10+1];\t/* mon{UINT_MAX}\\0 */\n\n\t\tsnprintf(mondevice, sizeof mondevice, \"mon%u\", n);\n\t\tret = add_mon_if(handle, sock_fd, &nlstate, device, mondevice);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Success.  We don't clean up the libnl state\n\t\t\t * yet, as we'll be using it later.\n\t\t\t */\n\t\t\tgoto added;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\t/*\n\t\t\t * Hard failure.  Just return ret; handle->errbuf\n\t\t\t * has already been set.\n\t\t\t */\n\t\t\tnl80211_cleanup(&nlstate);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: No free monN interfaces\", device);\n\tnl80211_cleanup(&nlstate);\n\treturn PCAP_ERROR;\n\nadded:\n\n#if 0\n\t/*\n\t * Sleep for .1 seconds.\n\t */\n\tdelay.tv_sec = 0;\n\tdelay.tv_nsec = 500000000;\n\tnanosleep(&delay, NULL);\n#endif\n\n\t/*\n\t * If we haven't already done so, arrange to have\n\t * \"pcap_close_all()\" called when we exit.\n\t */\n\tif (!pcapint_do_addexit(handle)) {\n\t\t/*\n\t\t * \"atexit()\" failed; don't put the interface\n\t\t * in rfmon mode, just give up.\n\t\t * handle->errbuf has already been filled.\n\t\t */\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Now configure the monitor interface up.\n\t */\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, handlep->mondevice, sizeof(ifr.ifr_name));\n\tif (ioctl(sock_fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't get flags for %s\", device,\n\t\t    handlep->mondevice);\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\tifr.ifr_flags |= IFF_UP|IFF_RUNNING;\n\tif (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't set flags for %s\", device,\n\t\t    handlep->mondevice);\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Success.  Clean up the libnl state.\n\t */\n\tnl80211_cleanup(&nlstate);\n\n\t/*\n\t * Note that we have to delete the monitor device when we close\n\t * the handle.\n\t */\n\thandlep->must_do_on_close |= MUST_DELETE_MONIF;\n\n\t/*\n\t * Add this to the list of pcaps to close when we exit.\n\t */\n\tpcapint_add_to_pcaps_to_close(handle);\n\n\treturn 1;\n}\n#else /* HAVE_LIBNL */\nstatic int\nenter_rfmon_mode(pcap_t *handle _U_, int sock_fd _U_, const char *device _U_)\n{\n\t/*\n\t * We don't have libnl, so we can't do monitor mode.\n\t */\n\treturn 0;\n}\n#endif /* HAVE_LIBNL */\n\n#if defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP)\n/*\n * Map SOF_TIMESTAMPING_ values to PCAP_TSTAMP_ values.\n */\nstatic const struct {\n\tint soft_timestamping_val;\n\tint pcap_tstamp_val;\n} sof_ts_type_map[3] = {\n\t{ SOF_TIMESTAMPING_SOFTWARE, PCAP_TSTAMP_HOST },\n\t{ SOF_TIMESTAMPING_SYS_HARDWARE, PCAP_TSTAMP_ADAPTER },\n\t{ SOF_TIMESTAMPING_RAW_HARDWARE, PCAP_TSTAMP_ADAPTER_UNSYNCED }\n};\n#define NUM_SOF_TIMESTAMPING_TYPES\t(sizeof sof_ts_type_map / sizeof sof_ts_type_map[0])\n\n/*\n * Set the list of time stamping types to include all types.\n */\nstatic int\niface_set_all_ts_types(pcap_t *handle, char *ebuf)\n{\n\tu_int i;\n\n\thandle->tstamp_type_list = malloc(NUM_SOF_TIMESTAMPING_TYPES * sizeof(u_int));\n\tif (handle->tstamp_type_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++)\n\t\thandle->tstamp_type_list[i] = sof_ts_type_map[i].pcap_tstamp_val;\n\thandle->tstamp_type_count = NUM_SOF_TIMESTAMPING_TYPES;\n\treturn 0;\n}\n\n/*\n * Get a list of time stamp types.\n */\n#ifdef ETHTOOL_GET_TS_INFO\nstatic int\niface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)\n{\n\tint fd;\n\tstruct ifreq ifr;\n\tstruct ethtool_ts_info info;\n\tint num_ts_types;\n\tu_int i, j;\n\n\t/*\n\t * This doesn't apply to the \"any\" device; you can't say \"turn on\n\t * hardware time stamping for all devices that exist now and arrange\n\t * that it be turned on for any device that appears in the future\",\n\t * and not all devices even necessarily *support* hardware time\n\t * stamping, so don't report any time stamp types.\n\t */\n\tif (strcmp(device, \"any\") == 0) {\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Create a socket from which to fetch time stamping capabilities.\n\t */\n\tfd = get_if_ioctl_socket();\n\tif (fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket for SIOCETHTOOL(ETHTOOL_GET_TS_INFO)\");\n\t\treturn -1;\n\t}\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = ETHTOOL_GET_TS_INFO;\n\tifr.ifr_data = (caddr_t)&info;\n\tif (ioctl(fd, SIOCETHTOOL, &ifr) == -1) {\n\t\tint save_errno = errno;\n\n\t\tclose(fd);\n\t\tswitch (save_errno) {\n\n\t\tcase EOPNOTSUPP:\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * OK, this OS version or driver doesn't support\n\t\t\t * asking for the time stamping types, so let's\n\t\t\t * just return all the possible types.\n\t\t\t */\n\t\t\tif (iface_set_all_ts_types(handle, ebuf) == -1)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\n\t\tcase ENODEV:\n\t\t\t/*\n\t\t\t * OK, no such device.\n\t\t\t * The user will find that out when they try to\n\t\t\t * activate the device; just return an empty\n\t\t\t * list of time stamp types.\n\t\t\t */\n\t\t\thandle->tstamp_type_list = NULL;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    save_errno,\n\t\t\t    \"%s: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed\",\n\t\t\t    device);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(fd);\n\n\t/*\n\t * Do we support hardware time stamping of *all* packets?\n\t */\n\tif (!(info.rx_filters & (1 << HWTSTAMP_FILTER_ALL))) {\n\t\t/*\n\t\t * No, so don't report any time stamp types.\n\t\t *\n\t\t * XXX - some devices either don't report\n\t\t * HWTSTAMP_FILTER_ALL when they do support it, or\n\t\t * report HWTSTAMP_FILTER_ALL but map it to only\n\t\t * time stamping a few PTP packets.  See\n\t\t * http://marc.info/?l=linux-netdev&m=146318183529571&w=2\n\t\t *\n\t\t * Maybe that got fixed later.\n\t\t */\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\tnum_ts_types = 0;\n\tfor (i = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++) {\n\t\tif (info.so_timestamping & sof_ts_type_map[i].soft_timestamping_val)\n\t\t\tnum_ts_types++;\n\t}\n\tif (num_ts_types != 0) {\n\t\thandle->tstamp_type_list = malloc(num_ts_types * sizeof(u_int));\n\t\tif (handle->tstamp_type_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0, j = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++) {\n\t\t\tif (info.so_timestamping & sof_ts_type_map[i].soft_timestamping_val) {\n\t\t\t\thandle->tstamp_type_list[j] = sof_ts_type_map[i].pcap_tstamp_val;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\thandle->tstamp_type_count = num_ts_types;\n\t} else\n\t\thandle->tstamp_type_list = NULL;\n\n\treturn 0;\n}\n#else /* ETHTOOL_GET_TS_INFO */\nstatic int\niface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)\n{\n\t/*\n\t * This doesn't apply to the \"any\" device; you can't say \"turn on\n\t * hardware time stamping for all devices that exist now and arrange\n\t * that it be turned on for any device that appears in the future\",\n\t * and not all devices even necessarily *support* hardware time\n\t * stamping, so don't report any time stamp types.\n\t */\n\tif (strcmp(device, \"any\") == 0) {\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We don't have an ioctl to use to ask what's supported,\n\t * so say we support everything.\n\t */\n\tif (iface_set_all_ts_types(handle, ebuf) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n#endif /* ETHTOOL_GET_TS_INFO */\n#else  /* defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP) */\nstatic int\niface_get_ts_types(const char *device _U_, pcap_t *p _U_, char *ebuf _U_)\n{\n\t/*\n\t * Nothing to fetch, so it always \"succeeds\".\n\t */\n\treturn 0;\n}\n#endif /* defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP) */\n\n/*\n * Find out if we have any form of fragmentation/reassembly offloading.\n *\n * We do so using SIOCETHTOOL checking for various types of offloading;\n * if SIOCETHTOOL isn't defined, or we don't have any #defines for any\n * of the types of offloading, there's nothing we can do to check, so\n * we just say \"no, we don't\".\n *\n * We treat EOPNOTSUPP, EINVAL and, if eperm_ok is true, EPERM as\n * indications that the operation isn't supported.  We do EPERM\n * weirdly because the SIOCETHTOOL code in later kernels 1) doesn't\n * support ETHTOOL_GUFO, 2) also doesn't include it in the list\n * of ethtool operations that don't require CAP_NET_ADMIN privileges,\n * and 3) does the \"is this permitted\" check before doing the \"is\n * this even supported\" check, so it fails with \"this is not permitted\"\n * rather than \"this is not even supported\".  To work around this\n * annoyance, we only treat EPERM as an error for the first feature,\n * and assume that they all do the same permission checks, so if the\n * first one is allowed all the others are allowed if supported.\n */\n#if defined(SIOCETHTOOL) && (defined(ETHTOOL_GTSO) || defined(ETHTOOL_GUFO) || defined(ETHTOOL_GGSO) || defined(ETHTOOL_GFLAGS) || defined(ETHTOOL_GGRO))\nstatic int\niface_ethtool_flag_ioctl(pcap_t *handle, int cmd, const char *cmdname,\n    int eperm_ok)\n{\n\tstruct ifreq\tifr;\n\tstruct ethtool_value eval;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));\n\teval.cmd = cmd;\n\teval.data = 0;\n\tifr.ifr_data = (caddr_t)&eval;\n\tif (ioctl(handle->fd, SIOCETHTOOL, &ifr) == -1) {\n\t\tif (errno == EOPNOTSUPP || errno == EINVAL ||\n\t\t    (errno == EPERM && eperm_ok)) {\n\t\t\t/*\n\t\t\t * OK, let's just return 0, which, in our\n\t\t\t * case, either means \"no, what we're asking\n\t\t\t * about is not enabled\" or \"all the flags\n\t\t\t * are clear (i.e., nothing is enabled)\".\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: SIOCETHTOOL(%s) ioctl failed\",\n\t\t    handle->opt.device, cmdname);\n\t\treturn -1;\n\t}\n\treturn eval.data;\n}\n\n/*\n * XXX - it's annoying that we have to check for offloading at all, but,\n * given that we have to, it's still annoying that we have to check for\n * particular types of offloading, especially that shiny new types of\n * offloading may be added - and, worse, may not be checkable with\n * a particular ETHTOOL_ operation; ETHTOOL_GFEATURES would, in\n * theory, give those to you, but the actual flags being used are\n * opaque (defined in a non-uapi header), and there doesn't seem to\n * be any obvious way to ask the kernel what all the offloading flags\n * are - at best, you can ask for a set of strings(!) to get *names*\n * for various flags.  (That whole mechanism appears to have been\n * designed for the sole purpose of letting ethtool report flags\n * by name and set flags by name, with the names having no semantics\n * ethtool understands.)\n */\nstatic int\niface_get_offload(pcap_t *handle)\n{\n\tint ret;\n\n#ifdef ETHTOOL_GTSO\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GTSO, \"ETHTOOL_GTSO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* TCP segmentation offloading on */\n#endif\n\n#ifdef ETHTOOL_GGSO\n\t/*\n\t * XXX - will this cause large unsegmented packets to be\n\t * handed to PF_PACKET sockets on transmission?  If not,\n\t * this need not be checked.\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGSO, \"ETHTOOL_GGSO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* generic segmentation offloading on */\n#endif\n\n#ifdef ETHTOOL_GFLAGS\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GFLAGS, \"ETHTOOL_GFLAGS\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret & ETH_FLAG_LRO)\n\t\treturn 1;\t/* large receive offloading on */\n#endif\n\n#ifdef ETHTOOL_GGRO\n\t/*\n\t * XXX - will this cause large reassembled packets to be\n\t * handed to PF_PACKET sockets on receipt?  If not,\n\t * this need not be checked.\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGRO, \"ETHTOOL_GGRO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* generic (large) receive offloading on */\n#endif\n\n#ifdef ETHTOOL_GUFO\n\t/*\n\t * Do this one last, as support for it was removed in later\n\t * kernels, and it fails with EPERM on those kernels rather\n\t * than with EOPNOTSUPP (see explanation in comment for\n\t * iface_ethtool_flag_ioctl()).\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GUFO, \"ETHTOOL_GUFO\", 1);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* UDP fragmentation offloading on */\n#endif\n\n\treturn 0;\n}\n#else /* SIOCETHTOOL */\nstatic int\niface_get_offload(pcap_t *handle _U_)\n{\n\t/*\n\t * XXX - do we need to get this information if we don't\n\t * have the ethtool ioctls?  If so, how do we do that?\n\t */\n\treturn 0;\n}\n#endif /* SIOCETHTOOL */\n\nstatic struct dsa_proto {\n\tconst char *name;\n\tbpf_u_int32 linktype;\n} dsa_protos[] = {\n\t/*\n\t * None is special and indicates that the interface does not have\n\t * any tagging protocol configured, and is therefore a standard\n\t * Ethernet interface.\n\t */\n\t{ \"none\", DLT_EN10MB },\n\t{ \"brcm\", DLT_DSA_TAG_BRCM },\n\t{ \"brcm-prepend\", DLT_DSA_TAG_BRCM_PREPEND },\n\t{ \"dsa\", DLT_DSA_TAG_DSA },\n\t{ \"edsa\", DLT_DSA_TAG_EDSA },\n\t{ \"rtl4a\", DLT_EN10MB },\n\t{ \"rtl8_4\", DLT_EN10MB },\n\t{ \"rtl8_4t\", DLT_EN10MB },\n};\n\nstatic int\niface_dsa_get_proto_info(const char *device, pcap_t *handle)\n{\n\tchar *pathstr;\n\tunsigned int i;\n\t/*\n\t * Make this significantly smaller than PCAP_ERRBUF_SIZE;\n\t * the tag *shouldn't* have some huge long name, and making\n\t * it smaller keeps newer versions of GCC from whining that\n\t * the error message if we don't support the tag could\n\t * overflow the error message buffer.\n\t */\n\tchar buf[128];\n\tssize_t r;\n\tint fd;\n\n\tfd = asprintf(&pathstr, \"/sys/class/net/%s/dsa/tagging\", device);\n\tif (fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t  fd, \"asprintf\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tfd = open(pathstr, O_RDONLY);\n\tfree(pathstr);\n\t/*\n\t * This is not fatal, kernel >= 4.20 *might* expose this attribute\n\t */\n\tif (fd < 0)\n\t\treturn 0;\n\n\tr = read(fd, buf, sizeof(buf) - 1);\n\tif (r <= 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t  errno, \"read\");\n\t\tclose(fd);\n\t\treturn PCAP_ERROR;\n\t}\n\tclose(fd);\n\n\t/*\n\t * Buffer should be LF terminated.\n\t */\n\tif (buf[r - 1] == '\\n')\n\t\tr--;\n\tbuf[r] = '\\0';\n\n\tfor (i = 0; i < sizeof(dsa_protos) / sizeof(dsa_protos[0]); i++) {\n\t\tif (strlen(dsa_protos[i].name) == (size_t)r &&\n\t\t    strcmp(buf, dsa_protos[i].name) == 0) {\n\t\t\thandle->linktype = dsa_protos[i].linktype;\n\t\t\tswitch (dsa_protos[i].linktype) {\n\t\t\tcase DLT_EN10MB:\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t      \"unsupported DSA tag: %s\", buf);\n\n\treturn PCAP_ERROR;\n}\n\n/*\n *  Query the kernel for the MTU of the given interface.\n */\nstatic int\niface_get_mtu(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\n\tif (!device)\n\t\treturn BIGGER_THAN_ALL_MTUS;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFMTU, &ifr) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFMTU\");\n\t\treturn -1;\n\t}\n\n\treturn ifr.ifr_mtu;\n}\n\n/*\n *  Get the hardware type of the given interface as ARPHRD_xxx constant.\n */\nstatic int\niface_get_arptype(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\tint\t\tret;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFHWADDR, &ifr) == -1) {\n\t\tif (errno == ENODEV) {\n\t\t\t/*\n\t\t\t * No such device.\n\t\t\t *\n\t\t\t * There's nothing more to say, so clear\n\t\t\t * the error message.\n\t\t\t */\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tebuf[0] = '\\0';\n\t\t} else {\n\t\t\tret = PCAP_ERROR;\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFHWADDR\");\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn ifr.ifr_hwaddr.sa_family;\n}\n\nstatic int\nfix_program(pcap_t *handle, struct sock_fprog *fcode)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tsize_t prog_size;\n\tregister int i;\n\tregister struct bpf_insn *p;\n\tstruct bpf_insn *f;\n\tint len;\n\n\t/*\n\t * Make a copy of the filter, and modify that copy if\n\t * necessary.\n\t */\n\tprog_size = sizeof(*handle->fcode.bf_insns) * handle->fcode.bf_len;\n\tlen = handle->fcode.bf_len;\n\tf = (struct bpf_insn *)malloc(prog_size);\n\tif (f == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn -1;\n\t}\n\tmemcpy(f, handle->fcode.bf_insns, prog_size);\n\tfcode->len = len;\n\tfcode->filter = (struct sock_filter *) f;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tp = &f[i];\n\t\t/*\n\t\t * What type of instruction is this?\n\t\t */\n\t\tswitch (BPF_CLASS(p->code)) {\n\n\t\tcase BPF_LD:\n\t\tcase BPF_LDX:\n\t\t\t/*\n\t\t\t * It's a load instruction; is it loading\n\t\t\t * from the packet?\n\t\t\t */\n\t\t\tswitch (BPF_MODE(p->code)) {\n\n\t\t\tcase BPF_ABS:\n\t\t\tcase BPF_IND:\n\t\t\tcase BPF_MSH:\n\t\t\t\t/*\n\t\t\t\t * Yes; are we in cooked mode?\n\t\t\t\t */\n\t\t\t\tif (handlep->cooked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Yes, so we need to fix this\n\t\t\t\t\t * instruction.\n\t\t\t\t\t */\n\t\t\t\t\tif (fix_offset(handle, p) < 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We failed to do so.\n\t\t\t\t\t\t * Return 0, so our caller\n\t\t\t\t\t\t * knows to punt to userland.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\t/* we succeeded */\n}\n\nstatic int\nfix_offset(pcap_t *handle, struct bpf_insn *p)\n{\n\t/*\n\t * Existing references to auxiliary data shouldn't be adjusted.\n\t *\n\t * Note that SKF_AD_OFF is negative, but p->k is unsigned, so\n\t * we use >= and cast SKF_AD_OFF to unsigned.\n\t */\n\tif (p->k >= (bpf_u_int32)SKF_AD_OFF)\n\t\treturn 0;\n\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t/*\n\t\t * What's the offset?\n\t\t */\n\t\tif (p->k >= SLL2_HDR_LEN) {\n\t\t\t/*\n\t\t\t * It's within the link-layer payload; that starts\n\t\t\t * at an offset of 0, as far as the kernel packet\n\t\t\t * filter is concerned, so subtract the length of\n\t\t\t * the link-layer header.\n\t\t\t */\n\t\t\tp->k -= SLL2_HDR_LEN;\n\t\t} else if (p->k == 0) {\n\t\t\t/*\n\t\t\t * It's the protocol field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PROTOCOL;\n\t\t} else if (p->k == 4) {\n\t\t\t/*\n\t\t\t * It's the ifindex field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_IFINDEX;\n\t\t} else if (p->k == 10) {\n\t\t\t/*\n\t\t\t * It's the packet type field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PKTTYPE;\n\t\t} else if ((bpf_int32)(p->k) > 0) {\n\t\t\t/*\n\t\t\t * It's within the header, but it's not one of\n\t\t\t * those fields; we can't do that in the kernel,\n\t\t\t * so punt to userland.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * What's the offset?\n\t\t */\n\t\tif (p->k >= SLL_HDR_LEN) {\n\t\t\t/*\n\t\t\t * It's within the link-layer payload; that starts\n\t\t\t * at an offset of 0, as far as the kernel packet\n\t\t\t * filter is concerned, so subtract the length of\n\t\t\t * the link-layer header.\n\t\t\t */\n\t\t\tp->k -= SLL_HDR_LEN;\n\t\t} else if (p->k == 0) {\n\t\t\t/*\n\t\t\t * It's the packet type field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PKTTYPE;\n\t\t} else if (p->k == 14) {\n\t\t\t/*\n\t\t\t * It's the protocol field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PROTOCOL;\n\t\t} else if ((bpf_int32)(p->k) > 0) {\n\t\t\t/*\n\t\t\t * It's within the header, but it's not one of\n\t\t\t * those fields; we can't do that in the kernel,\n\t\t\t * so punt to userland.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nset_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)\n{\n\tint total_filter_on = 0;\n\tint save_mode;\n\tint ret;\n\tint save_errno;\n\n\t/*\n\t * The socket filter code doesn't discard all packets queued\n\t * up on the socket when the filter is changed; this means\n\t * that packets that don't match the new filter may show up\n\t * after the new filter is put onto the socket, if those\n\t * packets haven't yet been read.\n\t *\n\t * This means, for example, that if you do a tcpdump capture\n\t * with a filter, the first few packets in the capture might\n\t * be packets that wouldn't have passed the filter.\n\t *\n\t * We therefore discard all packets queued up on the socket\n\t * when setting a kernel filter.  (This isn't an issue for\n\t * userland filters, as the userland filtering is done after\n\t * packets are queued up.)\n\t *\n\t * To flush those packets, we put the socket in read-only mode,\n\t * and read packets from the socket until there are no more to\n\t * read.\n\t *\n\t * In order to keep that from being an infinite loop - i.e.,\n\t * to keep more packets from arriving while we're draining\n\t * the queue - we put the \"total filter\", which is a filter\n\t * that rejects all packets, onto the socket before draining\n\t * the queue.\n\t *\n\t * This code deliberately ignores any errors, so that you may\n\t * get bogus packets if an error occurs, rather than having\n\t * the filtering done in userland even if it could have been\n\t * done in the kernel.\n\t */\n\tif (setsockopt(handle->fd, SOL_SOCKET, SO_ATTACH_FILTER,\n\t\t       &total_fcode, sizeof(total_fcode)) == 0) {\n\t\tchar drain[1];\n\n\t\t/*\n\t\t * Note that we've put the total filter onto the socket.\n\t\t */\n\t\ttotal_filter_on = 1;\n\n\t\t/*\n\t\t * Save the socket's current mode, and put it in\n\t\t * non-blocking mode; we drain it by reading packets\n\t\t * until we get an error (which is normally a\n\t\t * \"nothing more to be read\" error).\n\t\t */\n\t\tsave_mode = fcntl(handle->fd, F_GETFL, 0);\n\t\tif (save_mode == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't get FD flags when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\tif (fcntl(handle->fd, F_SETFL, save_mode | O_NONBLOCK) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't set nonblocking mode when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\twhile (recv(handle->fd, &drain, sizeof drain, MSG_TRUNC) >= 0)\n\t\t\t;\n\t\tsave_errno = errno;\n\t\tif (save_errno != EAGAIN) {\n\t\t\t/*\n\t\t\t * Fatal error.\n\t\t\t *\n\t\t\t * If we can't restore the mode or reset the\n\t\t\t * kernel filter, there's nothing we can do.\n\t\t\t */\n\t\t\t(void)fcntl(handle->fd, F_SETFL, save_mode);\n\t\t\t(void)reset_kernel_filter(handle);\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, save_errno,\n\t\t\t    \"recv failed when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\tif (fcntl(handle->fd, F_SETFL, save_mode) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't restore FD flags when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t}\n\n\t/*\n\t * Now attach the new filter.\n\t */\n\tret = setsockopt(handle->fd, SOL_SOCKET, SO_ATTACH_FILTER,\n\t\t\t fcode, sizeof(*fcode));\n\tif (ret == -1 && total_filter_on) {\n\t\t/*\n\t\t * Well, we couldn't set that filter on the socket,\n\t\t * but we could set the total filter on the socket.\n\t\t *\n\t\t * This could, for example, mean that the filter was\n\t\t * too big to put into the kernel, so we'll have to\n\t\t * filter in userland; in any case, we'll be doing\n\t\t * filtering in userland, so we need to remove the\n\t\t * total filter so we see packets.\n\t\t */\n\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * If this fails, we're really screwed; we have the\n\t\t * total filter on the socket, and it won't come off.\n\t\t * Report it as a fatal error.\n\t\t */\n\t\tif (reset_kernel_filter(handle) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't remove kernel total filter\");\n\t\t\treturn -2;\t/* fatal error */\n\t\t}\n\n\t\terrno = save_errno;\n\t}\n\treturn ret;\n}\n\nstatic int\nreset_kernel_filter(pcap_t *handle)\n{\n\tint ret;\n\t/*\n\t * setsockopt() barfs unless it get a dummy parameter.\n\t * valgrind whines unless the value is initialized,\n\t * as it has no idea that setsockopt() ignores its\n\t * parameter.\n\t */\n\tint dummy = 0;\n\n\tret = setsockopt(handle->fd, SOL_SOCKET, SO_DETACH_FILTER,\n\t\t\t\t   &dummy, sizeof(dummy));\n\t/*\n\t * Ignore ENOENT - it means \"we don't have a filter\", so there\n\t * was no filter to remove, and there's still no filter.\n\t *\n\t * Also ignore ENONET, as a lot of kernel versions had a\n\t * typo where ENONET, rather than ENOENT, was returned.\n\t */\n\tif (ret == -1 && errno != ENOENT && errno != ENONET)\n\t\treturn -1;\n\treturn 0;\n}\n\nint\npcap_set_protocol_linux(pcap_t *p, int protocol)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.protocol = protocol;\n\treturn (0);\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING\n#if defined(HAVE_TPACKET3) && defined(PCAP_SUPPORT_NETMAP)\n\t\t\" (with TPACKET_V3 and netmap)\"\n#elif defined(HAVE_TPACKET3)\n\t\t\" (with TPACKET_V3)\"\n#elif defined(PCAP_SUPPORT_NETMAP)\n\t\t\" (with TPACKET_V2 and netmap)\"\n#else\n\t\t\" (with TPACKET_V2)\"\n#endif\n\t);\n}\n"
        },
        {
          "name": "pcap-namedb.h",
          "type": "blob",
          "size": 1.9765625,
          "content": "/*\n * Copyright (c) 1994, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * For backwards compatibility.\n *\n * Note to OS vendors: do NOT get rid of this file!  Some applications\n * might expect to be able to include <pcap-namedb.h>.\n */\n#include <pcap/namedb.h>\n"
        },
        {
          "name": "pcap-netfilter-linux.c",
          "type": "blob",
          "size": 21.76171875,
          "content": "/*\n * Copyright (c) 2011 Jakub Zawadzki\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include \"pcap-int.h\"\n#include \"diag-control.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\n#include <time.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <linux/types.h>\n\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_log.h>\n#include <linux/netfilter/nfnetlink_queue.h>\n\n/* NOTE: if your program drops privileges after pcap_activate() it WON'T work with nfqueue.\n *       It took me quite some time to debug ;/\n *\n *       Sending any data to nfnetlink socket requires CAP_NET_ADMIN privileges,\n *       and in nfqueue we need to send verdict reply after receiving packet.\n *\n *       In tcpdump you can disable dropping privileges with -Z root\n */\n\n#include \"pcap-netfilter-linux.h\"\n\n#define HDR_LENGTH (NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct nfgenmsg))))\n\n#define NFLOG_IFACE \"nflog\"\n#define NFQUEUE_IFACE \"nfqueue\"\n\ntypedef enum { OTHER = -1, NFLOG, NFQUEUE } nftype_t;\n\n/*\n * Private data for capturing on Linux netfilter sockets.\n */\nstruct pcap_netfilter {\n\tu_int\tpackets_read;\t/* count of packets read with recvfrom() */\n\tu_int   packets_nobufs; /* ENOBUFS counter */\n};\n\nstatic int nfqueue_send_verdict(const pcap_t *handle, uint16_t group_id, u_int32_t id, u_int32_t verdict);\n\n\nstatic int\nnetfilter_read_linux(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_netfilter *handlep = handle->priv;\n\tregister u_char *bp, *ep;\n\tint count = 0;\n\tu_int cc;\n\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (handle->break_loop) {\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t * that we were told to break out of the loop.\n\t\t */\n\t\thandle->break_loop = 0;\n\t\treturn PCAP_ERROR_BREAK;\n\t}\n\tcc = handle->cc;\n\tif (cc == 0) {\n\t\t/*\n\t\t * The buffer is empty; refill it.\n\t\t *\n\t\t * We ignore EINTR, as that might just be due to a signal\n\t\t * being delivered - if the signal should interrupt the\n\t\t * loop, the signal handler should call pcap_breakloop()\n\t\t * to set handle->break_loop (we ignore it on other\n\t\t * platforms as well).\n\t\t */\n\t\tssize_t read_ret;\n\n\t\tdo {\n\t\t\tread_ret = recv(handle->fd, handle->buffer, handle->bufsize, 0);\n\t\t\tif (handle->break_loop) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t}\n\t\t\tif (read_ret == -1 && errno == ENOBUFS)\n\t\t\t\thandlep->packets_nobufs++;\n\t\t} while ((read_ret == -1) && (errno == EINTR || errno == ENOBUFS));\n\n\t\tif (read_ret < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"Can't receive packet\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\t/*\n\t\t * At this point, read_ret is guaranteed to be\n\t\t * >= 0 and < p->bufsize; p->bufsize is a u_int,\n\t\t * so its value is guaranteed to fit in cc, which\n\t\t * is also a u_int.\n\t\t */\n\t\tcc = (u_int)read_ret;\n\t\tbp = (unsigned char *)handle->buffer;\n\t} else\n\t\tbp = handle->bp;\n\n\t/*\n\t * Loop through each message.\n\t *\n\t * This assumes that a single buffer of message will have\n\t * <= INT_MAX packets, so the message count doesn't overflow.\n\t */\n\tep = bp + cc;\n\twhile (bp < ep) {\n\t\tconst struct nlmsghdr *nlh = (const struct nlmsghdr *) bp;\n\t\tuint32_t msg_len;\n\t\tnftype_t type = OTHER;\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return PCAP_ERROR_BREAK\n\t\t * to indicate that we were told to break out of the loop,\n\t\t * otherwise leave the flag set, so that the *next* call\n\t\t * will break out of the loop without having read any\n\t\t * packets, and return the number of packets we've\n\t\t * processed so far.\n\t\t */\n\t\tif (handle->break_loop) {\n\t\t\thandle->bp = bp;\n\t\t\thandle->cc = (u_int)(ep - bp);\n\t\t\tif (count == 0) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t} else\n\t\t\t\treturn count;\n\t\t}\n\t\t/*\n\t\t * NLMSG_SPACE(0) might be signed or might be unsigned,\n\t\t * depending on whether the kernel defines NLMSG_ALIGNTO\n\t\t * as 4, which older kernels do, or as 4U, which newer\n\t\t * kernels do.\n\t\t *\n\t\t * ep - bp is of type ptrdiff_t, which is signed.\n\t\t *\n\t\t * To squelch warnings, we cast both to size_t, which\n\t\t * is unsigned; ep >= bp, so the cast is safe.\n\t\t */\n\t\tif ((size_t)(ep - bp) < (size_t)NLMSG_SPACE(0)) {\n\t\t\t/*\n\t\t\t * There's less than one netlink message left\n\t\t\t * in the buffer.  Give up.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nlh->nlmsg_len < sizeof(struct nlmsghdr) || cc < nlh->nlmsg_len) {\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Message truncated: (got: %u) (nlmsg_len: %u)\", cc, nlh->nlmsg_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (NFNL_SUBSYS_ID(nlh->nlmsg_type) == NFNL_SUBSYS_ULOG &&\n\t\t    NFNL_MSG_TYPE(nlh->nlmsg_type) == NFULNL_MSG_PACKET)\n\t\t\ttype = NFLOG;\n\t\telse if (NFNL_SUBSYS_ID(nlh->nlmsg_type) == NFNL_SUBSYS_QUEUE &&\n\t\t         NFNL_MSG_TYPE(nlh->nlmsg_type) == NFQNL_MSG_PACKET)\n\t\t\ttype = NFQUEUE;\n\n\t\tif (type != OTHER) {\n\t\t\tconst unsigned char *payload = NULL;\n\t\t\tstruct pcap_pkthdr pkth;\n\n\t\t\tconst struct nfgenmsg *nfg = NULL;\n\t\t\tint id = 0;\n\n\t\t\tif (handle->linktype != DLT_NFLOG) {\n\t\t\t\tconst struct nfattr *payload_attr = NULL;\n\n\t\t\t\tif (nlh->nlmsg_len < HDR_LENGTH) {\n\t\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Malformed message: (nlmsg_len: %u)\", nlh->nlmsg_len);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tnfg = NLMSG_DATA(nlh);\n\t\t\t\tif (nlh->nlmsg_len > HDR_LENGTH) {\n\t\t\t\t\tstruct nfattr *attr = NFM_NFA(nfg);\n\t\t\t\t\tint attr_len = nlh->nlmsg_len - NLMSG_ALIGN(HDR_LENGTH);\n\n\t\t\t\t\twhile (NFA_OK(attr, attr_len)) {\n\t\t\t\t\t\tif (type == NFQUEUE) {\n\t\t\t\t\t\t\tswitch (NFA_TYPE(attr)) {\n\t\t\t\t\t\t\t\tcase NFQA_PACKET_HDR:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconst struct nfqnl_msg_packet_hdr *pkt_hdr = (const struct nfqnl_msg_packet_hdr *) NFA_DATA(attr);\n\n\t\t\t\t\t\t\t\t\t\tid = ntohl(pkt_hdr->packet_id);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase NFQA_PAYLOAD:\n\t\t\t\t\t\t\t\t\tpayload_attr = attr;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if (type == NFLOG) {\n\t\t\t\t\t\t\tswitch (NFA_TYPE(attr)) {\n\t\t\t\t\t\t\t\tcase NFULA_PAYLOAD:\n\t\t\t\t\t\t\t\t\tpayload_attr = attr;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattr = NFA_NEXT(attr, attr_len);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (payload_attr) {\n\t\t\t\t\tpayload = NFA_DATA(payload_attr);\n\t\t\t\t\tpkth.len = pkth.caplen = NFA_PAYLOAD(payload_attr);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tpayload = NLMSG_DATA(nlh);\n\t\t\t\tpkth.caplen = pkth.len = nlh->nlmsg_len-NLMSG_ALIGN(sizeof(struct nlmsghdr));\n\t\t\t}\n\n\t\t\tif (payload) {\n\t\t\t\t/* pkth.caplen = min (payload_len, handle->snapshot); */\n\n\t\t\t\tgettimeofday(&pkth.ts, NULL);\n\t\t\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t\t\t\t\tpcapint_filter(handle->fcode.bf_insns, payload, pkth.len, pkth.caplen))\n\t\t\t\t{\n\t\t\t\t\thandlep->packets_read++;\n\t\t\t\t\tcallback(user, &pkth, payload);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type == NFQUEUE) {\n\t\t\t\t/* XXX, possible responses: NF_DROP, NF_ACCEPT, NF_STOLEN, NF_QUEUE, NF_REPEAT, NF_STOP */\n\t\t\t\t/* if type == NFQUEUE, handle->linktype is always != DLT_NFLOG,\n\t\t\t\t   so nfg is always initialized to NLMSG_DATA(nlh). */\n\t\t\t\tif (nfg != NULL)\n\t\t\t\t\tnfqueue_send_verdict(handle, ntohs(nfg->res_id), id, NF_ACCEPT);\n\t\t\t}\n\t\t}\n\n\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\t/*\n\t\t * If the message length would run past the end of the\n\t\t * buffer, truncate it to the remaining space in the\n\t\t * buffer.\n\t\t *\n\t\t * To squelch warnings, we cast ep - bp to uint32_t, which\n\t\t * is unsigned and is the type of msg_len; ep >= bp, and\n\t\t * len should fit in 32 bits (either it's set from an int\n\t\t * or it's set from a recv() call with a buffer size that's\n\t\t * an int, and we're assuming either ILP32 or LP64), so\n\t\t * the cast is safe.\n\t\t */\n\t\tif (msg_len > (uint32_t)(ep - bp))\n\t\t\tmsg_len = (uint32_t)(ep - bp);\n\n\t\tbp += msg_len;\n\t\tif (count >= max_packets && !PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t\thandle->bp = bp;\n\t\t\thandle->cc = (u_int)(ep - bp);\n\t\t\treturn count;\n\t\t}\n\t}\n\n\thandle->cc = 0;\n\treturn count;\n}\n\nstatic int\nnetfilter_set_datalink(pcap_t *handle, int dlt)\n{\n\thandle->linktype = dlt;\n\treturn 0;\n}\n\nstatic int\nnetfilter_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_netfilter *handlep = handle->priv;\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = handlep->packets_nobufs;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}\n\nstatic int\nnetfilter_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on netfilter devices\");\n\treturn (-1);\n}\n\nstruct my_nfattr {\n\tuint16_t nfa_len;\n\tuint16_t nfa_type;\n\tvoid *data;\n};\n\nstatic int\nnetfilter_send_config_msg(const pcap_t *handle, uint16_t msg_type, int ack, u_int8_t family, u_int16_t res_id, const struct my_nfattr *mynfa)\n{\n\tchar buf[1024] __attribute__ ((aligned));\n\tmemset(buf, 0, sizeof(buf));\n\n\tstruct nlmsghdr *nlh = (struct nlmsghdr *) buf;\n\tstruct nfgenmsg *nfg = (struct nfgenmsg *) (buf + sizeof(struct nlmsghdr));\n\n\tstruct sockaddr_nl snl;\n\tstatic unsigned int seq_id;\n\n\tif (!seq_id)\nDIAG_OFF_NARROWING\n\t\tseq_id = time(NULL);\nDIAG_ON_NARROWING\n\t++seq_id;\n\n\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));\n\tnlh->nlmsg_type = msg_type;\n\tnlh->nlmsg_flags = NLM_F_REQUEST | (ack ? NLM_F_ACK : 0);\n\tnlh->nlmsg_pid = 0;\t/* to kernel */\n\tnlh->nlmsg_seq = seq_id;\n\n\tnfg->nfgen_family = family;\n\tnfg->version = NFNETLINK_V0;\n\tnfg->res_id = htons(res_id);\n\n\tif (mynfa) {\n\t\tstruct nfattr *nfa = (struct nfattr *) (buf + NLMSG_ALIGN(nlh->nlmsg_len));\n\n\t\tnfa->nfa_type = mynfa->nfa_type;\n\t\tnfa->nfa_len = NFA_LENGTH(mynfa->nfa_len);\n\t\tmemcpy(NFA_DATA(nfa), mynfa->data, mynfa->nfa_len);\n\t\tnlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NFA_ALIGN(nfa->nfa_len);\n\t}\n\n\tmemset(&snl, 0, sizeof(snl));\n\tsnl.nl_family = AF_NETLINK;\n\n\tif (sendto(handle->fd, nlh, nlh->nlmsg_len, 0, (struct sockaddr *) &snl, sizeof(snl)) == -1)\n\t\treturn -1;\n\n\tif (!ack)\n\t\treturn 0;\n\n\t/* waiting for reply loop */\n\tdo {\n\t\tsocklen_t addrlen = sizeof(snl);\n\t\tint len;\n\n\t\t/* ignore interrupt system call error */\n\t\tdo {\n\t\t\t/*\n\t\t\t * The buffer is not so big that its size won't\n\t\t\t * fit into an int.\n\t\t\t */\n\t\t\tlen = (int)recvfrom(handle->fd, buf, sizeof(buf), 0, (struct sockaddr *) &snl, &addrlen);\n\t\t} while ((len == -1) && (errno == EINTR));\n\n\t\tif (len <= 0)\n\t\t\treturn len;\n\n\t\tif (addrlen != sizeof(snl) || snl.nl_family != AF_NETLINK) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tnlh = (struct nlmsghdr *) buf;\n\t\tif (snl.nl_pid != 0 || seq_id != nlh->nlmsg_seq)\t/* if not from kernel or wrong sequence skip */\n\t\t\tcontinue;\n\n\t\twhile ((u_int)len >= NLMSG_SPACE(0) && NLMSG_OK(nlh, (u_int)len)) {\n\t\t\tif (nlh->nlmsg_type == NLMSG_ERROR || (nlh->nlmsg_type == NLMSG_DONE && nlh->nlmsg_flags & NLM_F_MULTI)) {\n\t\t\t\tif (nlh->nlmsg_len < NLMSG_ALIGN(sizeof(struct nlmsgerr))) {\n\t\t\t\t\terrno = EBADMSG;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terrno = -(*((int *)NLMSG_DATA(nlh)));\n\t\t\t\treturn (errno == 0) ? 0 : -1;\n\t\t\t}\n\t\t\tnlh = NLMSG_NEXT(nlh, len);\n\t\t}\n\t} while (1);\n\n\treturn -1; /* never here */\n}\n\nstatic int\nnflog_send_config_msg(const pcap_t *handle, uint8_t family, u_int16_t group_id, const struct my_nfattr *mynfa)\n{\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_ULOG << 8) | NFULNL_MSG_CONFIG, 1, family, group_id, mynfa);\n}\n\nstatic int\nnflog_send_config_cmd(const pcap_t *handle, uint16_t group_id, u_int8_t cmd, u_int8_t family)\n{\n\tstruct nfulnl_msg_config_cmd msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.command = cmd;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFULA_CFG_CMD;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nflog_send_config_msg(handle, family, group_id, &nfa);\n}\n\nstatic int\nnflog_send_config_mode(const pcap_t *handle, uint16_t group_id, u_int8_t copy_mode, u_int32_t copy_range)\n{\n\tstruct nfulnl_msg_config_mode msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.copy_range = htonl(copy_range);\n\tmsg.copy_mode = copy_mode;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFULA_CFG_MODE;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nflog_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}\n\nstatic int\nnfqueue_send_verdict(const pcap_t *handle, uint16_t group_id, u_int32_t id, u_int32_t verdict)\n{\n\tstruct nfqnl_msg_verdict_hdr msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.id = htonl(id);\n\tmsg.verdict = htonl(verdict);\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_VERDICT_HDR;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_VERDICT, 0, AF_UNSPEC, group_id, &nfa);\n}\n\nstatic int\nnfqueue_send_config_msg(const pcap_t *handle, uint8_t family, u_int16_t group_id, const struct my_nfattr *mynfa)\n{\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_CONFIG, 1, family, group_id, mynfa);\n}\n\nstatic int\nnfqueue_send_config_cmd(const pcap_t *handle, uint16_t group_id, u_int8_t cmd, u_int16_t pf)\n{\n\tstruct nfqnl_msg_config_cmd msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.command = cmd;\n\tmsg.pf = htons(pf);\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_CFG_CMD;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nfqueue_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}\n\nstatic int\nnfqueue_send_config_mode(const pcap_t *handle, uint16_t group_id, u_int8_t copy_mode, u_int32_t copy_range)\n{\n\tstruct nfqnl_msg_config_params msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.copy_range = htonl(copy_range);\n\tmsg.copy_mode = copy_mode;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_CFG_PARAMS;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nfqueue_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}\n\nstatic int\nnetfilter_activate(pcap_t* handle)\n{\n\tconst char *dev = handle->opt.device;\n\tunsigned short groups[32];\n\tint group_count = 0;\n\tnftype_t type = OTHER;\n\tint i;\n\n\tif (strncmp(dev, NFLOG_IFACE, strlen(NFLOG_IFACE)) == 0) {\n\t\tdev += strlen(NFLOG_IFACE);\n\t\ttype = NFLOG;\n\n\t} else if (strncmp(dev, NFQUEUE_IFACE, strlen(NFQUEUE_IFACE)) == 0) {\n\t\tdev += strlen(NFQUEUE_IFACE);\n\t\ttype = NFQUEUE;\n\t}\n\n\tif (type != OTHER && *dev == ':') {\n\t\tdev++;\n\t\twhile (*dev) {\n\t\t\tlong int group_id;\n\t\t\tchar *end_dev;\n\n\t\t\tif (group_count == 32) {\n\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\"Maximum 32 netfilter groups! dev: %s\",\n\t\t\t\t\t\thandle->opt.device);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\tgroup_id = strtol(dev, &end_dev, 0);\n\t\t\tif (end_dev != dev) {\n\t\t\t\tif (group_id < 0 || group_id > 65535) {\n\t\t\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t\"Netfilter group range from 0 to 65535 (got %ld)\",\n\t\t\t\t\t\t\tgroup_id);\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\n\t\t\t\tgroups[group_count++] = (unsigned short) group_id;\n\t\t\t\tdev = end_dev;\n\t\t\t}\n\t\t\tif (*dev != ',')\n\t\t\t\tbreak;\n\t\t\tdev++;\n\t\t}\n\t}\n\n\tif (type == OTHER || *dev) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"Can't get netfilter group(s) index from %s\",\n\t\t\t\thandle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* if no groups, add default: 0 */\n\tif (!group_count) {\n\t\tgroups[0] = 0;\n\t\tgroup_count = 1;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = 128 + handle->snapshot;\n\thandle->offset = 0;\n\thandle->read_op = netfilter_read_linux;\n\thandle->inject_op = netfilter_inject_linux;\n\thandle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = netfilter_set_datalink;\n\thandle->getnonblock_op = pcapint_getnonblock_fd;\n\thandle->setnonblock_op = pcapint_setnonblock_fd;\n\thandle->stats_op = netfilter_stats_linux;\n\n\t/* Create netlink socket */\n\thandle->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\tif (handle->fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't create raw socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (type == NFLOG) {\n\t\thandle->linktype = DLT_NFLOG;\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\tif (handle->dlt_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"Can't allocate DLT list\");\n\t\t\tgoto close_fail;\n\t\t}\n\t\thandle->dlt_list[0] = DLT_NFLOG;\n\t\thandle->dlt_list[1] = DLT_IPV4;\n\t\thandle->dlt_count = 2;\n\t} else\n\t\thandle->linktype = DLT_IPV4;\n\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't allocate dump buffer\");\n\t\tgoto close_fail;\n\t}\n\n\tif (type == NFLOG) {\n\t\tif (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"NFULNL_CFG_CMD_PF_UNBIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\tif (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_BIND, AF_INET) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFULNL_CFG_CMD_PF_BIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\t/* Bind socket to the nflog groups */\n\t\tfor (i = 0; i < group_count; i++) {\n\t\t\tif (nflog_send_config_cmd(handle, groups[i], NFULNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't listen on group index\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\n\t\t\tif (nflog_send_config_mode(handle, groups[i], NFULNL_COPY_PACKET, handle->snapshot) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"NFULNL_COPY_PACKET\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tif (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFQNL_CFG_CMD_PF_UNBIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\tif (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_BIND, AF_INET) < 0) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFQNL_CFG_CMD_PF_BIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\t/* Bind socket to the nfqueue groups */\n\t\tfor (i = 0; i < group_count; i++) {\n\t\t\tif (nfqueue_send_config_cmd(handle, groups[i], NFQNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't listen on group index\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\n\t\t\tif (nfqueue_send_config_mode(handle, groups[i], NFQNL_COPY_PACKET, handle->snapshot) < 0) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"NFQNL_COPY_PACKET\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to netfilter devices.\n\t\t */\n\t\tpcapint_cleanup_live_common(handle);\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\tif (handle->opt.buffer_size != 0) {\n\t\t/*\n\t\t * Set the socket buffer size to the specified value.\n\t\t */\n\t\tif (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF, &handle->opt.buffer_size, sizeof(handle->opt.buffer_size)) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SO_RCVBUF\");\n\t\t\tgoto close_fail;\n\t\t}\n\t}\n\n\thandle->selectable_fd = handle->fd;\n\treturn 0;\n\nclose_fail:\n\tpcapint_cleanup_live_common(handle);\n\treturn PCAP_ERROR;\n}\n\npcap_t *\nnetfilter_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tpcap_t *p;\n\n\t/* Does this look like an netfilter device? */\n\tcp = device;\n\n\t/* Does it begin with NFLOG_IFACE or NFQUEUE_IFACE? */\n\tif (strncmp(cp, NFLOG_IFACE, sizeof NFLOG_IFACE - 1) == 0)\n\t\tcp += sizeof NFLOG_IFACE - 1;\n\telse if (strncmp(cp, NFQUEUE_IFACE, sizeof NFQUEUE_IFACE - 1) == 0)\n\t\tcp += sizeof NFQUEUE_IFACE - 1;\n\telse {\n\t\t/* Nope, doesn't begin with NFLOG_IFACE nor NFQUEUE_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Yes - is that either the end of the name, or is it followed\n\t * by a colon?\n\t */\n\tif (*cp != ':' && *cp != '\\0') {\n\t\t/* Nope */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_netfilter);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = netfilter_activate;\n\treturn (p);\n}\n\nint\nnetfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tint sock;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\tif (sock < 0) {\n\t\t/* if netlink is not supported this is not fatal */\n\t\tif (errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT)\n\t\t\treturn 0;\n\t\tpcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open netlink socket\");\n\t\treturn -1;\n\t}\n\tclose(sock);\n\n\t/*\n\t * The notion of \"connected\" vs. \"disconnected\" doesn't apply.\n\t * XXX - what about \"up\" and \"running\"?\n\t */\n\tif (pcapint_add_dev(devlistp, NFLOG_IFACE,\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    \"Linux netfilter log (NFLOG) interface\", err_str) == NULL)\n\t\treturn -1;\n\tif (pcapint_add_dev(devlistp, NFQUEUE_IFACE,\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    \"Linux netfilter queue (NFQUEUE) interface\", err_str) == NULL)\n\t\treturn -1;\n\treturn 0;\n}\n"
        },
        {
          "name": "pcap-netfilter-linux.h",
          "type": "blob",
          "size": 1.669921875,
          "content": "/*\n * Copyright (c) 2011 Jakub Zawadzki\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Prototypes for netlink-related functions\n */\nint netfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str);\npcap_t *netfilter_create(const char *device, char *ebuf, int *is_ours);\n"
        },
        {
          "name": "pcap-netmap.c",
          "type": "blob",
          "size": 7.9248046875,
          "content": "/*\n * Copyright (C) 2014 Luigi Rizzo. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   1. Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in the\n *      documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <poll.h>\n#include <errno.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define NETMAP_WITH_LIBS\n#include <net/netmap_user.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-netmap.h\"\n\n#ifndef __FreeBSD__\n  /*\n   * On FreeBSD we use IFF_PPROMISC which is in ifr_flagshigh.\n   * Remap to IFF_PROMISC on other platforms.\n   *\n   * XXX - DragonFly BSD?\n   */\n  #define IFF_PPROMISC\tIFF_PROMISC\n#endif /* __FreeBSD__ */\n\nstruct pcap_netmap {\n\tstruct nm_desc *d;\t/* pointer returned by nm_open() */\n\tpcap_handler cb;\t/* callback and argument */\n\tu_char *cb_arg;\n\tint must_clear_promisc;\t/* flag */\n\tuint64_t rx_pkts;\t/* # of pkts received before the filter */\n};\n\n\nstatic int\npcap_netmap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\n\tps->ps_recv = (u_int)pn->rx_pkts;\n\tps->ps_drop = 0;\n\tps->ps_ifdrop = 0;\n\treturn 0;\n}\n\n\nstatic void\npcap_netmap_filter(u_char *arg, struct pcap_pkthdr *h, const u_char *buf)\n{\n\tpcap_t *p = (pcap_t *)arg;\n\tstruct pcap_netmap *pn = p->priv;\n\tconst struct bpf_insn *pc = p->fcode.bf_insns;\n\n\t++pn->rx_pkts;\n\tif (pc == NULL || pcapint_filter(pc, buf, h->len, h->caplen))\n\t\tpn->cb(pn->cb_arg, h, buf);\n}\n\n\nstatic int\npcap_netmap_dispatch(pcap_t *p, int cnt, pcap_handler cb, u_char *user)\n{\n\tint ret;\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tstruct pollfd pfd = { .fd = p->fd, .events = POLLIN, .revents = 0 };\n\n\tpn->cb = cb;\n\tpn->cb_arg = user;\n\n\tfor (;;) {\n\t\tif (p->break_loop) {\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\t/* nm_dispatch won't run forever */\n\n\t\tret = nm_dispatch((void *)d, cnt, (void *)pcap_netmap_filter, (void *)p);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\terrno = 0;\n\t\tret = poll(&pfd, 1, p->opt.timeout);\n\t}\n\treturn ret;\n}\n\n\n/* XXX need to check the NIOCTXSYNC/poll */\nstatic int\npcap_netmap_inject(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\n\treturn nm_inject(d, buf, size);\n}\n\n\nstatic int\npcap_netmap_ioctl(pcap_t *p, u_long what, uint32_t *if_flags)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tstruct ifreq ifr;\n\tint error, fd = d->fd;\n\n#ifdef __linux__\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error: cannot get device control socket.\\n\");\n\t\treturn -1;\n\t}\n#endif /* __linux__ */\n\tbzero(&ifr, sizeof(ifr));\n\t/*\n\t * ifreq.ifr_name and nmreq.nr_name have the same size and both\n\t * contain a NUL-terminated string.\n\t */\n\t(void)pcapint_strlcpy(ifr.ifr_name, d->req.nr_name, sizeof(ifr.ifr_name));\n\tswitch (what) {\n\tcase SIOCSIFFLAGS:\n\t\t/*\n\t\t * The flags we pass in are 32-bit and unsigned.\n\t\t *\n\t\t * On most if not all UN*Xes, ifr_flags is 16-bit and\n\t\t * signed, and the result of assigning a longer\n\t\t * unsigned value to a shorter signed value is\n\t\t * implementation-defined (even if, in practice, it'll\n\t\t * do what's intended on all platforms we support\n\t\t * result of assigning a 32-bit unsigned value).\n\t\t * So we mask out the upper 16 bits.\n\t\t */\n\t\tifr.ifr_flags = *if_flags & 0xffff;\n#ifdef __FreeBSD__\n\t\t/*\n\t\t * In FreeBSD, we need to set the high-order flags,\n\t\t * as we're using IFF_PPROMISC, which is in those bits.\n\t\t *\n\t\t * XXX - DragonFly BSD?\n\t\t */\n\t\tifr.ifr_flagshigh = *if_flags >> 16;\n#endif /* __FreeBSD__ */\n\t\tbreak;\n\t}\n\terror = ioctl(fd, what, &ifr);\n\tif (!error) {\n\t\tswitch (what) {\n\t\tcase SIOCGIFFLAGS:\n\t\t\t/*\n\t\t\t * The flags we return are 32-bit.\n\t\t\t *\n\t\t\t * On most if not all UN*Xes, ifr_flags is\n\t\t\t * 16-bit and signed, and will get sign-\n\t\t\t * extended, so that the upper 16 bits of\n\t\t\t * those flags will be forced on.  So we\n\t\t\t * mask out the upper 16 bits of the\n\t\t\t * sign-extended value.\n\t\t\t */\n\t\t\t*if_flags = ifr.ifr_flags & 0xffff;\n#ifdef __FreeBSD__\n\t\t\t/*\n\t\t\t * In FreeBSD, we need to return the\n\t\t\t * high-order flags, as we're using\n\t\t\t * IFF_PPROMISC, which is in those bits.\n\t\t\t *\n\t\t\t * XXX - DragonFly BSD?\n\t\t\t */\n\t\t\t*if_flags |= (ifr.ifr_flagshigh << 16);\n#endif /* __FreeBSD__ */\n\t\t}\n\t}\n#ifdef __linux__\n\tclose(fd);\n#endif /* __linux__ */\n\treturn error ? -1 : 0;\n}\n\n\nstatic void\npcap_netmap_close(pcap_t *p)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tuint32_t if_flags = 0;\n\n\tif (pn->must_clear_promisc) {\n\t\tpcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */\n\t\tif (if_flags & IFF_PPROMISC) {\n\t\t\tif_flags &= ~IFF_PPROMISC;\n\t\t\tpcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);\n\t\t}\n\t}\n\tnm_close(d);\n\tpcapint_cleanup_live_common(p);\n}\n\n\nstatic int\npcap_netmap_activate(pcap_t *p)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d;\n\tuint32_t if_flags = 0;\n\n\td = nm_open(p->opt.device, NULL, 0, NULL);\n\tif (d == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"netmap open: cannot access %s\",\n\t\t    p->opt.device);\n\t\tpcapint_cleanup_live_common(p);\n\t\treturn (PCAP_ERROR);\n\t}\n#if 0\n\tfprintf(stderr, \"%s device %s priv %p fd %d ports %d..%d\\n\",\n\t    __func__, p->opt.device, d, d->fd,\n\t    d->first_rx_ring, d->last_rx_ring);\n#endif\n\tpn->d = d;\n\tp->fd = d->fd;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.promisc && !(d->req.nr_ringid & NETMAP_SW_RING)) {\n\t\tpcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */\n\t\tif (!(if_flags & IFF_PPROMISC)) {\n\t\t\tpn->must_clear_promisc = 1;\n\t\t\tif_flags |= IFF_PPROMISC;\n\t\t\tpcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);\n\t\t}\n\t}\n\tp->linktype = DLT_EN10MB;\n\tp->selectable_fd = p->fd;\n\tp->read_op = pcap_netmap_dispatch;\n\tp->inject_op = pcap_netmap_inject;\n\tp->setfilter_op = pcapint_install_bpf_program;\n\tp->setdirection_op = NULL;\n\tp->set_datalink_op = NULL;\n\tp->getnonblock_op = pcapint_getnonblock_fd;\n\tp->setnonblock_op = pcapint_setnonblock_fd;\n\tp->stats_op = pcap_netmap_stats;\n\tp->cleanup_op = pcap_netmap_close;\n\n\treturn (0);\n}\n\n\npcap_t *\npcap_netmap_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\n\t*is_ours = (!strncmp(device, \"netmap:\", 7) || !strncmp(device, \"vale\", 4));\n\tif (! *is_ours)\n\t\treturn NULL;\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_netmap);\n\tif (p == NULL)\n\t\treturn (NULL);\n\tp->activate_op = pcap_netmap_activate;\n\treturn (p);\n}\n\n/*\n * The \"device name\" for netmap devices isn't a name for a device, it's\n * an expression that indicates how the device should be set up, so\n * there's no way to enumerate them.\n */\nint\npcap_netmap_findalldevs(pcap_if_list_t *devlistp _U_, char *err_str _U_)\n{\n\treturn 0;\n}\n"
        },
        {
          "name": "pcap-netmap.h",
          "type": "blob",
          "size": 0.123046875,
          "content": "pcap_t *pcap_netmap_create(const char *, char *, int *);\nint pcap_netmap_findalldevs(pcap_if_list_t *devlistp, char *errbuf);\n"
        },
        {
          "name": "pcap-npf.c",
          "type": "blob",
          "size": 64.1962890625,
          "content": "/*\n * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino, CACE Technologies\n * nor the names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n#include <errno.h>\n#include <limits.h> /* for INT_MAX */\n#define PCAP_DONT_INCLUDE_PCAP_BPF_H\n#include <Packet32.h>\n#include <pcap-int.h>\n#include <pcap/dlt.h>\n\n/*\n * XXX - Packet32.h defines bpf_program, so we can't include\n * <pcap/bpf.h>, which also defines it; that's why we define\n * PCAP_DONT_INCLUDE_PCAP_BPF_H,\n *\n * However, no header in the WinPcap or Npcap SDKs defines the\n * macros for BPF code, so we have to define them ourselves.\n */\n#define\t\tBPF_RET\t\t0x06\n#define\t\tBPF_K\t\t0x00\n\n/* Old-school MinGW have these headers in a different place.\n */\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\n  #include <ddk/ntddndis.h>\n  #include <ddk/ndis.h>\n#else\n  #include <ntddndis.h>  /* MSVC/TDM-MinGW/MinGW64 */\n#endif\n\n#include \"diag-control.h\"\n\nstatic int pcap_setfilter_npf(pcap_t *, struct bpf_program *);\nstatic int pcap_setfilter_win32_dag(pcap_t *, struct bpf_program *);\nstatic int pcap_getnonblock_npf(pcap_t *);\nstatic int pcap_setnonblock_npf(pcap_t *, int);\n\n/*dimension of the buffer in the pcap_t structure*/\n#define\tWIN32_DEFAULT_USER_BUFFER_SIZE 256000\n\n/*dimension of the buffer in the kernel driver NPF */\n#define\tWIN32_DEFAULT_KERNEL_BUFFER_SIZE 1000000\n\n/* Equivalent to ntohs(), but a lot faster under Windows */\n#define SWAPS(_X) ((_X & 0xff) << 8) | (_X >> 8)\n\n/*\n * Private data for capturing on WinPcap/Npcap devices.\n */\nstruct pcap_win {\n\tADAPTER *adapter;\t\t/* the packet32 ADAPTER for the device */\n\tint nonblock;\n\tint rfmon_selfstart;\t\t/* a flag tells whether the monitor mode is set by itself */\n\tint filtering_in_kernel;\t/* using kernel filter */\n\n#ifdef ENABLE_REMOTE\n\tint samp_npkt;\t\t\t/* parameter needed for sampling, with '1 out of N' method has been requested */\n\tstruct timeval samp_time;\t/* parameter needed for sampling, with '1 every N ms' method has been requested */\n#endif\n};\n\n/*\n * Define stub versions of the monitor-mode support routines if this\n * isn't Npcap. HAVE_NPCAP_PACKET_API is defined by Npcap but not\n * WinPcap.\n */\n#ifndef HAVE_NPCAP_PACKET_API\nstatic int\nPacketIsMonitorModeSupported(PCHAR AdapterName _U_)\n{\n\t/*\n\t * We don't support monitor mode.\n\t */\n\treturn (0);\n}\n\nstatic int\nPacketSetMonitorMode(PCHAR AdapterName _U_, int mode _U_)\n{\n\t/*\n\t * This should never be called, as PacketIsMonitorModeSupported()\n\t * will return 0, meaning \"we don't support monitor mode, so\n\t * don't try to turn it on or off\".\n\t */\n\treturn (0);\n}\n\nstatic int\nPacketGetMonitorMode(PCHAR AdapterName _U_)\n{\n\t/*\n\t * This should fail, so that pcap_activate_npf() returns\n\t * PCAP_ERROR_RFMON_NOTSUP if our caller requested monitor\n\t * mode.\n\t */\n\treturn (-1);\n}\n#endif\n\n/*\n * If a driver returns an NTSTATUS value:\n *\n *    https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781\n *\n * with the \"Customer\" bit set, it will not be mapped to a Windows error\n * value in userland, so it will be returned by GetLastError().\n *\n * Note that \"driver\" here includes the Npcap NPF driver, as various\n * versions would take NT status values and set the \"Customer\" bit\n * before returning the status code.  The commit message for the\n * change that started doing that is\n *\n *    Returned a customer-defined NTSTATUS in OID requests to avoid\n *    NTSTATUS-to-Win32 Error code translation.\n *\n * but I don't know why the goal was to avoid that translation.  For\n * a while, I suspected that the NT status STATUS_NOT_SUPPORTED was\n * getting mapped to ERROR_GEN_FAILURE, but, in the cases where\n * attempts to set promiscuous mode on regular Ethernet devices were\n * failing with ERROR_GEN_FAILURE, it turns out that the drivers for\n * those devices were NetAdapterCx drivers, and Microsoft's NetAdapterCx\n * mechanism wasn't providing the correct \"bytes processed\" value on\n * attempts to set OIDs, and the Npcap NPF driver was checking for\n * that and returning STATUS_UNSUCCESSFUL, which gets mapped to\n * ERROR_GEN_FAILURE, so perhaps there's no need to avoid that\n * translation.\n *\n * Attempting to set the hardware filter on a Microsoft Surface Pro's\n * Mobile Broadband Adapter returns an error that appears to be\n * NDIS_STATUS_NOT_SUPPORTED ORed with the \"Customer\" bit, so it's\n * probably indicating that it doesn't support that.  It was probably\n * the NPF driver setting that bit.\n */\n#define NT_STATUS_CUSTOMER_DEFINED\t0x20000000\n\n/*\n * PacketRequest() makes a DeviceIoControl() call to the NPF driver to\n * perform the OID request, with a BIOCQUERYOID ioctl.  The kernel code\n * should get back one of NDIS_STATUS_INVALID_OID, NDIS_STATUS_NOT_SUPPORTED,\n * or NDIS_STATUS_NOT_RECOGNIZED if the OID request isn't supported by\n * the OS or the driver.\n *\n * Currently, that code may be returned by the Npcap NPF driver with the\n * NT_STATUS_CUSTOMER_DEFINED bit.  That prevents the return status from\n * being mapped to a Windows error code; if the NPF driver were to stop\n * ORing in the NT_STATUS_CUSTOMER_DEFINED bit, it's not obvious how those\n * the NDIS_STATUS_ values that don't correspond to NTSTATUS values would\n * be translated to Windows error values (NDIS_STATUS_NOT_SUPPORTED is\n * the same as STATUS_NOT_SUPPORTED, which is an NTSTATUS value that is\n * mapped to ERROR_NOT_SUPPORTED).\n */\n#define NDIS_STATUS_INVALID_OID\t\t0xc0010017\n#define NDIS_STATUS_NOT_SUPPORTED\t0xc00000bb\t/* STATUS_NOT_SUPPORTED */\n#define NDIS_STATUS_NOT_RECOGNIZED\t0x00010001\n\nstatic int\noid_get_request(ADAPTER *adapter, bpf_u_int32 oid, void *data, size_t *lenp,\n    char *errbuf)\n{\n\tPACKET_OID_DATA *oid_data_arg;\n\n\t/*\n\t * Allocate a PACKET_OID_DATA structure to hand to PacketRequest().\n\t * It should be big enough to hold \"*lenp\" bytes of data; it\n\t * will actually be slightly larger, as PACKET_OID_DATA has a\n\t * 1-byte data array at the end, standing in for the variable-length\n\t * data that's actually there.\n\t */\n\toid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);\n\tif (oid_data_arg == NULL) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Couldn't allocate argument buffer for PacketRequest\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * No need to copy the data - we're doing a fetch.\n\t */\n\toid_data_arg->Oid = oid;\n\toid_data_arg->Length = (ULONG)(*lenp);\t/* XXX - check for ridiculously large value? */\n\tif (!PacketRequest(adapter, FALSE, oid_data_arg)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"Error calling PacketRequest\");\n\t\tfree(oid_data_arg);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the length actually supplied.\n\t */\n\t*lenp = oid_data_arg->Length;\n\n\t/*\n\t * Copy back the data we fetched.\n\t */\n\tmemcpy(data, oid_data_arg->Data, *lenp);\n\tfree(oid_data_arg);\n\treturn (0);\n}\n\nstatic int\npcap_stats_npf(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_win *pw = p->priv;\n\tstruct bpf_stat bstats;\n\n\t/*\n\t * Try to get statistics.\n\t *\n\t * (Please note - \"struct pcap_stat\" is *not* the same as\n\t * WinPcap's \"struct bpf_stat\". It might currently have the\n\t * same layout, but let's not cheat.\n\t *\n\t * Note also that we don't fill in ps_capt, as we might have\n\t * been called by code compiled against an earlier version of\n\t * WinPcap that didn't have ps_capt, in which case filling it\n\t * in would stomp on whatever comes after the structure passed\n\t * to us.\n\t */\n\tif (!PacketGetStats(pw->adapter, &bstats)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"PacketGetStats error\");\n\t\treturn (-1);\n\t}\n\tps->ps_recv = bstats.bs_recv;\n\tps->ps_drop = bstats.bs_drop;\n\n\t/*\n\t * XXX - PacketGetStats() doesn't fill this in, so we just\n\t * return 0.\n\t */\n#if 0\n\tps->ps_ifdrop = bstats.ps_ifdrop;\n#else\n\tps->ps_ifdrop = 0;\n#endif\n\n\treturn (0);\n}\n\n/*\n * Win32-only routine for getting statistics.\n *\n * This way is definitely safer than passing the pcap_stat * from the userland.\n * In fact, there could happen than the user allocates a variable which is not\n * big enough for the new structure, and the library will write in a zone\n * which is not allocated to this variable.\n *\n * In this way, we're pretty sure we are writing on memory allocated to this\n * variable.\n *\n * XXX - but this is the wrong way to handle statistics.  Instead, we should\n * have an API that returns data in a form like the Options section of a\n * pcapng Interface Statistics Block:\n *\n *    https://xml2rfc.tools.ietf.org/cgi-bin/xml2rfc.cgi?url=https://raw.githubusercontent.com/pcapng/pcapng/master/draft-tuexen-opsawg-pcapng.xml&modeAsFormat=html/ascii&type=ascii#rfc.section.4.6\n *\n * which would let us add new statistics straightforwardly and indicate which\n * statistics we are and are *not* providing, rather than having to provide\n * possibly-bogus values for statistics we can't provide.\n */\nstatic struct pcap_stat *\npcap_stats_ex_npf(pcap_t *p, int *pcap_stat_size)\n{\n\tstruct pcap_win *pw = p->priv;\n\tstruct bpf_stat bstats;\n\n\t*pcap_stat_size = sizeof (p->stat);\n\n\t/*\n\t * Try to get statistics.\n\t *\n\t * (Please note - \"struct pcap_stat\" is *not* the same as\n\t * WinPcap's \"struct bpf_stat\". It might currently have the\n\t * same layout, but let's not cheat.)\n\t */\n\tif (!PacketGetStatsEx(pw->adapter, &bstats)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"PacketGetStatsEx error\");\n\t\treturn (NULL);\n\t}\n\tp->stat.ps_recv = bstats.bs_recv;\n\tp->stat.ps_drop = bstats.bs_drop;\n\tp->stat.ps_ifdrop = bstats.ps_ifdrop;\n\t/*\n\t * Just in case this is ever compiled for a target other than\n\t * Windows, which is somewhere between extremely unlikely and\n\t * impossible.\n\t */\n#ifdef _WIN32\n\tp->stat.ps_capt = bstats.bs_capt;\n#endif\n\treturn (&p->stat);\n}\n\n/* Set the dimension of the kernel-level capture buffer */\nstatic int\npcap_setbuff_npf(pcap_t *p, int dim)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetBuff(pw->adapter,dim)==FALSE)\n\t{\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: not enough memory to allocate the kernel buffer\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/* Set the driver working mode */\nstatic int\npcap_setmode_npf(pcap_t *p, int mode)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetMode(pw->adapter,mode)==FALSE)\n\t{\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: working mode not recognized\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n/*set the minimum amount of data that will release a read call*/\nstatic int\npcap_setmintocopy_npf(pcap_t *p, int size)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetMinToCopy(pw->adapter, size)==FALSE)\n\t{\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: unable to set the requested mintocopy size\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic HANDLE\npcap_getevent_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (PacketGetReadEvent(pw->adapter));\n}\n\nstatic int\npcap_oid_get_request_npf(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (oid_get_request(pw->adapter, oid, data, lenp, p->errbuf));\n}\n\nstatic int\npcap_oid_set_request_npf(pcap_t *p, bpf_u_int32 oid, const void *data,\n    size_t *lenp)\n{\n\tstruct pcap_win *pw = p->priv;\n\tPACKET_OID_DATA *oid_data_arg;\n\n\t/*\n\t * Allocate a PACKET_OID_DATA structure to hand to PacketRequest().\n\t * It should be big enough to hold \"*lenp\" bytes of data; it\n\t * will actually be slightly larger, as PACKET_OID_DATA has a\n\t * 1-byte data array at the end, standing in for the variable-length\n\t * data that's actually there.\n\t */\n\toid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);\n\tif (oid_data_arg == NULL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Couldn't allocate argument buffer for PacketRequest\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\toid_data_arg->Oid = oid;\n\toid_data_arg->Length = (ULONG)(*lenp);\t/* XXX - check for ridiculously large value? */\n\tmemcpy(oid_data_arg->Data, data, *lenp);\n\tif (!PacketRequest(pw->adapter, TRUE, oid_data_arg)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"Error calling PacketRequest\");\n\t\tfree(oid_data_arg);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Get the length actually copied.\n\t */\n\t*lenp = oid_data_arg->Length;\n\n\t/*\n\t * No need to copy the data - we're doing a set.\n\t */\n\tfree(oid_data_arg);\n\treturn (0);\n}\n\nstatic u_int\npcap_sendqueue_transmit_npf(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\tstruct pcap_win *pw = p->priv;\n\tu_int res;\n\n\tres = PacketSendPackets(pw->adapter,\n\t\tqueue->buffer,\n\t\tqueue->len,\n\t\t(BOOLEAN)sync);\n\n\tif(res != queue->len){\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"Error queueing packets\");\n\t}\n\n\treturn (res);\n}\n\nstatic int\npcap_setuserbuffer_npf(pcap_t *p, int size)\n{\n\tunsigned char *new_buff;\n\n\tif (size<=0) {\n\t\t/* Bogus parameter */\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error: invalid size %d\",size);\n\t\treturn (-1);\n\t}\n\n\t/* Allocate the buffer */\n\tnew_buff=(unsigned char*)malloc(sizeof(char)*size);\n\n\tif (!new_buff) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error: not enough memory\");\n\t\treturn (-1);\n\t}\n\n\tfree(p->buffer);\n\n\tp->buffer=new_buff;\n\tp->bufsize=size;\n\n\treturn (0);\n}\n\n#ifdef HAVE_NPCAP_PACKET_API\n/*\n * Kernel dump mode isn't supported in Npcap; calls to PacketSetDumpName(),\n * PacketSetDumpLimits(), and PacketIsDumpEnded() will get compile-time\n * deprecation warnings.\n *\n * Avoid calling them; just return errors indicating that kernel dump\n * mode isn't supported in Npcap.\n */\nstatic int\npcap_live_dump_npf(pcap_t *p, char *filename _U_, int maxsize _U_,\n    int maxpacks _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Npcap doesn't support kernel dump mode\");\n\treturn (-1);\n}\nstatic int\npcap_live_dump_ended_npf(pcap_t *p, int sync)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Npcap doesn't support kernel dump mode\");\n\treturn (-1);\n}\n#else /* HAVE_NPCAP_PACKET_API */\nstatic int\npcap_live_dump_npf(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\tstruct pcap_win *pw = p->priv;\n\tBOOLEAN res;\n\n\t/* Set the packet driver in dump mode */\n\tres = PacketSetMode(pw->adapter, PACKET_MODE_DUMP);\n\tif(res == FALSE){\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error setting dump mode\");\n\t\treturn (-1);\n\t}\n\n\t/* Set the name of the dump file */\n\tres = PacketSetDumpName(pw->adapter, filename, (int)strlen(filename));\n\tif(res == FALSE){\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error setting kernel dump file name\");\n\t\treturn (-1);\n\t}\n\n\t/* Set the limits of the dump file */\n\tres = PacketSetDumpLimits(pw->adapter, maxsize, maxpacks);\n\tif(res == FALSE) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"Error setting dump limit\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nstatic int\npcap_live_dump_ended_npf(pcap_t *p, int sync)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (PacketIsDumpEnded(pw->adapter, (BOOLEAN)sync));\n}\n#endif /* HAVE_NPCAP_PACKET_API */\n\nstatic int\npcap_read_npf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tPACKET Packet;\n\tu_int cc;\n\tint n;\n\tregister u_char *bp, *ep;\n\tu_char *datap;\n\tstruct pcap_win *pw = p->priv;\n\n\tcc = p->cc;\n\tif (cc == 0) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it\n\t\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t\t * that we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t}\n\n\t\t/*\n\t\t * Capture the packets.\n\t\t *\n\t\t * The PACKET structure had a bunch of extra stuff for\n\t\t * Windows 9x/Me, but the only interesting data in it\n\t\t * in the versions of Windows that we support is just\n\t\t * a copy of p->buffer, a copy of p->buflen, and the\n\t\t * actual number of bytes read returned from\n\t\t * PacketReceivePacket(), none of which has to be\n\t\t * retained from call to call, so we just keep one on\n\t\t * the stack.\n\t\t */\n\t\tPacketInitPacket(&Packet, (BYTE *)p->buffer, p->bufsize);\n\t\tif (!PacketReceivePacket(pw->adapter, &Packet, TRUE)) {\n\t\t\t/*\n\t\t\t * Did the device go away?\n\t\t\t * If so, the error we get can either be\n\t\t\t * ERROR_GEN_FAILURE or ERROR_DEVICE_REMOVED.\n\t\t\t */\n\t\t\tDWORD errcode = GetLastError();\n\n\t\t\tif (errcode == ERROR_GEN_FAILURE ||\n\t\t\t    errcode == ERROR_DEVICE_REMOVED) {\n\t\t\t\t/*\n\t\t\t\t * The device on which we're capturing\n\t\t\t\t * went away, or it became unusable\n\t\t\t\t * by NPF due to a suspend/resume.\n\t\t\t\t *\n\t\t\t\t * ERROR_GEN_FAILURE comes from\n\t\t\t\t * STATUS_UNSUCCESSFUL, as well as some\n\t\t\t\t * other NT status codes that the Npcap\n\t\t\t\t * driver is unlikely to return.\n\t\t\t\t * XXX - hopefully no other error\n\t\t\t\t * conditions are indicated by this.\n\t\t\t\t *\n\t\t\t\t * ERROR_DEVICE_REMOVED comes from\n\t\t\t\t * STATUS_DEVICE_REMOVED.\n\t\t\t\t *\n\t\t\t\t * We report the Windows status code\n\t\t\t\t * name and the corresponding NT status\n\t\t\t\t * code name, for the benefit of attempts\n\t\t\t\t * to debug cases where this error is\n\t\t\t\t * reported when the device *wasn't*\n\t\t\t\t * removed, either because it's not\n\t\t\t\t * removable, it's removable but wasn't\n\t\t\t\t * removed, or it's a device that doesn't\n\t\t\t\t * correspond to a physical device.\n\t\t\t\t *\n\t\t\t\t * XXX - we really should return an\n\t\t\t\t * appropriate error for that, but\n\t\t\t\t * pcap_dispatch() etc. aren't\n\t\t\t\t * documented as having error returns\n\t\t\t\t * other than PCAP_ERROR or PCAP_ERROR_BREAK.\n\t\t\t\t */\n\t\t\t\tconst char *errcode_msg;\n\n\t\t\t\tif (errcode == ERROR_GEN_FAILURE)\n\t\t\t\t\terrcode_msg = \"ERROR_GEN_FAILURE/STATUS_UNSUCCESSFUL\";\n\t\t\t\telse\n\t\t\t\t\terrcode_msg = \"ERROR_DEVICE_REMOVED/STATUS_DEVICE_REMOVED\";\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"The interface disappeared (error code %s)\",\n\t\t\t\t    errcode_msg);\n\t\t\t} else {\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errcode,\n\t\t\t\t    \"PacketReceivePacket error\");\n\t\t\t}\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\tcc = Packet.ulBytesReceived;\n\n\t\tbp = p->buffer;\n\t}\n\telse\n\t\tbp = p->bp;\n\n\t/*\n\t * Loop through each packet.\n\t *\n\t * This assumes that a single buffer of packets will have\n\t * <= INT_MAX packets, so the packet count doesn't overflow.\n\t */\n#define bhp ((struct bpf_hdr *)bp)\n\tn = 0;\n\tep = bp + cc;\n\tfor (;;) {\n\t\tregister u_int caplen, hdrlen;\n\t\tsize_t packet_bytes;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return PCAP_ERROR_BREAK\n\t\t * to indicate that we were told to break out of the loop,\n\t\t * otherwise leave the flag set, so that the *next* call\n\t\t * will break out of the loop without having read any\n\t\t * packets, and return the number of packets we've\n\t\t * processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t\t} else {\n\t\t\t\tp->bp = bp;\n\t\t\t\tp->cc = (u_int) (ep - bp);\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\n\t\tcaplen = bhp->bh_caplen;\n\t\thdrlen = bhp->bh_hdrlen;\n\t\tdatap = bp + hdrlen;\n\n\t\t/*\n\t\t * Compute the number of bytes for this packet in\n\t\t * the buffer.\n\t\t *\n\t\t * That's the sum of the header length and the packet\n\t\t * data length plus, if this is not the last packet,\n\t\t * the padding required to align the next packet on\n\t\t * the appropriate boundary.\n\t\t *\n\t\t * That means that it should be the minimum of the\n\t\t * number of bytes left in the buffer and the\n\t\t * rounded-up sum of the header and packet data lengths.\n\t\t */\n\t\tpacket_bytes = min((u_int)(ep - bp), Packet_WORDALIGN(caplen + hdrlen));\n\n\t\t/*\n\t\t * Short-circuit evaluation: if using BPF filter\n\t\t * in kernel, no need to do it now - we already know\n\t\t * the packet passed the filter.\n\t\t *\n\t\t * XXX - pcapint_filter() should always return TRUE if\n\t\t * handed a null pointer for the program, but it might\n\t\t * just try to \"run\" the filter, so we check here.\n\t\t */\n\t\tif (pw->filtering_in_kernel ||\n\t\t    p->fcode.bf_insns == NULL ||\n\t\t    pcapint_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {\n#ifdef ENABLE_REMOTE\n\t\t\tswitch (p->rmt_samp.method) {\n\n\t\t\tcase PCAP_SAMP_1_EVERY_N:\n\t\t\t\tpw->samp_npkt = (pw->samp_npkt + 1) % p->rmt_samp.value;\n\n\t\t\t\t/* Discard all packets that are not '1 out of N' */\n\t\t\t\tif (pw->samp_npkt != 0) {\n\t\t\t\t\tbp += packet_bytes;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PCAP_SAMP_FIRST_AFTER_N_MS:\n\t\t\t    {\n\t\t\t\tstruct pcap_pkthdr *pkt_header = (struct pcap_pkthdr*) bp;\n\n\t\t\t\t/*\n\t\t\t\t * Check if the timestamp of the arrived\n\t\t\t\t * packet is smaller than our target time.\n\t\t\t\t */\n\t\t\t\tif (pkt_header->ts.tv_sec < pw->samp_time.tv_sec ||\n\t\t\t\t   (pkt_header->ts.tv_sec == pw->samp_time.tv_sec && pkt_header->ts.tv_usec < pw->samp_time.tv_usec)) {\n\t\t\t\t\tbp += packet_bytes;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * The arrived packet is suitable for being\n\t\t\t\t * delivered to our caller, so let's update\n\t\t\t\t * the target time.\n\t\t\t\t */\n\t\t\t\tpw->samp_time.tv_usec = pkt_header->ts.tv_usec + p->rmt_samp.value * 1000;\n\t\t\t\tif (pw->samp_time.tv_usec > 1000000) {\n\t\t\t\t\tpw->samp_time.tv_sec = pkt_header->ts.tv_sec + pw->samp_time.tv_usec / 1000000;\n\t\t\t\t\tpw->samp_time.tv_usec = pw->samp_time.tv_usec % 1000000;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n#endif\t/* ENABLE_REMOTE */\n\n\t\t\t/*\n\t\t\t * XXX A bpf_hdr matches a pcap_pkthdr.\n\t\t\t */\n\t\t\t(*callback)(user, (struct pcap_pkthdr*)bp, datap);\n\t\t\tbp += packet_bytes;\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tp->bp = bp;\n\t\t\t\tp->cc = (u_int) (ep - bp);\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Skip this packet.\n\t\t\t */\n\t\t\tbp += packet_bytes;\n\t\t}\n\t}\n#undef bhp\n\tp->cc = 0;\n\treturn (n);\n}\n\n/* Send a packet to the network */\nstatic int\npcap_inject_npf(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_win *pw = p->priv;\n\tPACKET pkt;\n\n\tPacketInitPacket(&pkt, (PVOID)buf, size);\n\tif(PacketSendPacket(pw->adapter,&pkt,TRUE) == FALSE) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"send error: PacketSendPacket failed\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * We assume it all got sent if \"PacketSendPacket()\" succeeded.\n\t * \"pcap_inject()\" is expected to return the number of bytes\n\t * sent.\n\t */\n\treturn (size);\n}\n\nstatic void\npcap_cleanup_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif (pw->adapter != NULL) {\n\t\tPacketCloseAdapter(pw->adapter);\n\t\tpw->adapter = NULL;\n\t}\n\tif (pw->rfmon_selfstart)\n\t{\n\t\tPacketSetMonitorMode(p->opt.device, 0);\n\t}\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic void\npcap_breakloop_npf(pcap_t *p)\n{\n\tpcapint_breakloop_common(p);\n\tstruct pcap_win *pw = p->priv;\n\n\t/* XXX - what if this fails? */\n\tSetEvent(PacketGetReadEvent(pw->adapter));\n}\n\nstatic int\npcap_activate_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\tNetType type;\n\tint res;\n\tint status = 0;\n\tstruct bpf_insn total_insn;\n\tstruct bpf_program total_prog;\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode is supported on Windows Vista and later.\n\t\t */\n\t\tif (PacketGetMonitorMode(p->opt.device) == 1)\n\t\t{\n\t\t\tpw->rfmon_selfstart = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((res = PacketSetMonitorMode(p->opt.device, 1)) != 1)\n\t\t\t{\n\t\t\t\tpw->rfmon_selfstart = 0;\n\t\t\t\t// Monitor mode is not supported.\n\t\t\t\tif (res == 0)\n\t\t\t\t{\n\t\t\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpw->rfmon_selfstart = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpw->adapter = PacketOpenAdapter(p->opt.device);\n\n\tif (pw->adapter == NULL)\n\t{\n\t\tDWORD errcode = GetLastError();\n\n\t\t/*\n\t\t * What error did we get when trying to open the adapter?\n\t\t */\n\t\tswitch (errcode) {\n\n\t\tcase ERROR_BAD_UNIT:\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t * There's nothing to add, so clear the error\n\t\t\t * message.\n\t\t\t */\n\t\t\tp->errbuf[0] = '\\0';\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\t\t/*\n\t\t\t * There is, but we don't have permission to\n\t\t\t * use it.\n\t\t\t *\n\t\t\t * XXX - we currently get ERROR_BAD_UNIT if the\n\t\t\t * user says \"no\" to the UAC prompt.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The helper program for \\\"Admin-only Mode\\\" must be allowed to make changes to your device\");\n\t\t\treturn (PCAP_ERROR_PERM_DENIED);\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Unknown - report details.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errcode, \"Error opening adapter\");\n\t\t\tif (pw->rfmon_selfstart)\n\t\t\t{\n\t\t\t\tPacketSetMonitorMode(p->opt.device, 0);\n\t\t\t}\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\t/*get network type*/\n\tif(PacketGetNetType (pw->adapter,&type) == FALSE)\n\t{\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"Cannot determine the network type\");\n\t\tgoto bad;\n\t}\n\n\t/*Set the linktype*/\n\tswitch (type.LinkType)\n\t{\n\t/*\n\t * NDIS-defined medium types.\n\t */\n\tcase NdisMedium802_3:\n\t\tp->linktype = DLT_EN10MB;\n\t\t/*\n\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t */\n\t\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\tif (p->dlt_list == NULL)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tgoto bad;\n\t\t}\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\tp->dlt_count = 2;\n\t\tbreak;\n\n\tcase NdisMedium802_5:\n\t\t/*\n\t\t * Token Ring.\n\t\t */\n\t\tp->linktype = DLT_IEEE802;\n\t\tbreak;\n\n\tcase NdisMediumFddi:\n\t\tp->linktype = DLT_FDDI;\n\t\tbreak;\n\n\tcase NdisMediumWan:\n\t\tp->linktype = DLT_EN10MB;\n\t\tbreak;\n\n\tcase NdisMediumArcnetRaw:\n\t\tp->linktype = DLT_ARCNET;\n\t\tbreak;\n\n\tcase NdisMediumArcnet878_2:\n\t\tp->linktype = DLT_ARCNET;\n\t\tbreak;\n\n\tcase NdisMediumAtm:\n\t\tp->linktype = DLT_ATM_RFC1483;\n\t\tbreak;\n\n\tcase NdisMediumWirelessWan:\n\t\tp->linktype = DLT_RAW;\n\t\tbreak;\n\n\tcase NdisMediumIP:\n\t\tp->linktype = DLT_RAW;\n\t\tbreak;\n\n\t/*\n\t * Npcap-defined medium types.\n\t */\n\tcase NdisMediumNull:\n\t\tp->linktype = DLT_NULL;\n\t\tbreak;\n\n\tcase NdisMediumCHDLC:\n\t\tp->linktype = DLT_CHDLC;\n\t\tbreak;\n\n\tcase NdisMediumPPPSerial:\n\t\tp->linktype = DLT_PPP_SERIAL;\n\t\tbreak;\n\n\tcase NdisMediumBare80211:\n\t\tp->linktype = DLT_IEEE802_11;\n\t\tbreak;\n\n\tcase NdisMediumRadio80211:\n\t\tp->linktype = DLT_IEEE802_11_RADIO;\n\t\tbreak;\n\n\tcase NdisMediumPpi:\n\t\tp->linktype = DLT_PPI;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * An unknown medium type is assumed to supply Ethernet\n\t\t * headers; if not, the user will have to report it,\n\t\t * so that the medium type and link-layer header type\n\t\t * can be determined.  If we were to fail here, we\n\t\t * might get the link-layer type in the error, but\n\t\t * the user wouldn't get a capture, so we wouldn't\n\t\t * be able to determine the link-layer type; we report\n\t\t * a warning with the link-layer type, so at least\n\t\t * some programs will report the warning.\n\t\t */\n\t\tp->linktype = DLT_EN10MB;\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Unknown NdisMedium value %d, defaulting to DLT_EN10MB\",\n\t\t    type.LinkType);\n\t\tstatus = PCAP_WARNING;\n\t\tbreak;\n\t}\n\n#ifdef HAVE_PACKET_GET_TIMESTAMP_MODES\n\t/*\n\t * Set the timestamp type.\n\t * (Yes, we require PacketGetTimestampModes(), not just\n\t * PacketSetTimestampMode().  If we have the former, we\n\t * have the latter, unless somebody's using a version\n\t * of Npcap that they've hacked to provide the former\n\t * but not the latter; if they've done that, either\n\t * they're confused or they're trolling us.)\n\t */\n\tswitch (p->opt.tstamp_type) {\n\n\tcase PCAP_TSTAMP_HOST_HIPREC_UNSYNCED:\n\t\t/*\n\t\t * Better than low-res, but *not* synchronized with\n\t\t * the OS clock.\n\t\t */\n\t\tif (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_SINGLE_SYNCHRONIZATION))\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    GetLastError(), \"Cannot set the time stamp mode to TIMESTAMPMODE_SINGLE_SYNCHRONIZATION\");\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_HOST_LOWPREC:\n\t\t/*\n\t\t * Low-res, but synchronized with the OS clock.\n\t\t */\n\t\tif (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME))\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    GetLastError(), \"Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME\");\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_HOST_HIPREC:\n\t\t/*\n\t\t * High-res, and synchronized with the OS clock.\n\t\t */\n\t\tif (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE))\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    GetLastError(), \"Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE\");\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_HOST:\n\t\t/*\n\t\t * XXX - do whatever the default is, for now.\n\t\t * Set to the highest resolution that's synchronized\n\t\t * with the system clock?\n\t\t */\n\t\tbreak;\n\t}\n#endif /* HAVE_PACKET_GET_TIMESTAMP_MODES */\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Set promiscuous mode */\n\tif (p->opt.promisc)\n\t{\n\t\t/*\n\t\t * For future reference, in case we ever want to query\n\t\t * whether an adapter supports promiscuous mode, that\n\t\t * would be done on Windows by querying the value\n\t\t * of the OID_GEN_SUPPORTED_PACKET_FILTERS OID.\n\t\t */\n\t\tif (PacketSetHwFilter(pw->adapter,NDIS_PACKET_TYPE_PROMISCUOUS) == FALSE)\n\t\t{\n\t\t\tDWORD errcode = GetLastError();\n\n\t\t\t/*\n\t\t\t * Suppress spurious error generated by non-compliant\n\t\t\t * MS Surface mobile adapters that appear to\n\t\t\t * return NDIS_STATUS_NOT_SUPPORTED for attempts\n\t\t\t * to set the hardware filter.\n\t\t\t *\n\t\t\t * It appears to be reporting NDIS_STATUS_NOT_SUPPORTED,\n\t\t\t * but with the NT status value \"Customer\" bit set;\n\t\t\t * the Npcap NPF driver sets that bit in some cases.\n\t\t\t *\n\t\t\t * If we knew that this meant \"promiscuous mode\n\t\t\t * isn't supported\", we could add a \"promiscuous\n\t\t\t * mode isn't supported\" error code and return\n\t\t\t * that, but:\n\t\t\t *\n\t\t\t *    1) we don't know that it means that\n\t\t\t *    rather than meaning \"we reject attempts\n\t\t\t *    to set the filter, even though the NDIS\n\t\t\t *    specifications say you shouldn't do that\"\n\t\t\t *\n\t\t\t * and\n\t\t\t *\n\t\t\t *    2) other interface types that don't\n\t\t\t *    support promiscuous mode, at least\n\t\t\t *    on UN*Xes, just silently ignore\n\t\t\t *    attempts to set promiscuous mode\n\t\t\t *\n\t\t\t * and rejecting it with an error could disrupt\n\t\t\t * attempts to capture, as many programs (tcpdump,\n\t\t\t * *shark) default to promiscuous mode.\n\t\t\t *\n\t\t\t * Alternatively, we could return the \"promiscuous\n\t\t\t * mode not supported\" *warning* value, so that\n\t\t\t * correct code will either ignore it or report\n\t\t\t * it and continue capturing.  (This may require\n\t\t\t * a pcap_init() flag to request that return\n\t\t\t * value, so that old incorrect programs that\n\t\t\t * assume a non-zero return from pcap_activate()\n\t\t\t * is an error don't break.)\n\t\t\t *\n\t\t\t * We check here for ERROR_NOT_SUPPORTED, which\n\t\t\t * is what NDIS_STATUS_NOT_SUPPORTED (which is\n\t\t\t * the same value as the NTSTATUS value\n\t\t\t * STATUS_NOT_SUPPORTED) gets mapped to, as\n\t\t\t * well as NDIS_STATUS_NOT_SUPPORTED with the\n\t\t\t * \"Customer\" bit set.\n\t\t\t */\n\t\t\tif (errcode != ERROR_NOT_SUPPORTED &&\n\t\t\t    errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errcode,\n\t\t\t\t    \"failed to set hardware filter to promiscuous mode\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * NDIS_PACKET_TYPE_ALL_LOCAL selects \"All packets sent by\n\t\t * installed protocols and all packets indicated by the NIC\",\n\t\t * but if no protocol drivers (like TCP/IP) are installed,\n\t\t * NDIS_PACKET_TYPE_DIRECTED, NDIS_PACKET_TYPE_BROADCAST,\n\t\t * and NDIS_PACKET_TYPE_MULTICAST are needed to capture\n\t\t * incoming frames.\n\t\t */\n\t\tif (PacketSetHwFilter(pw->adapter,\n\t\t\tNDIS_PACKET_TYPE_ALL_LOCAL |\n\t\t\tNDIS_PACKET_TYPE_DIRECTED |\n\t\t\tNDIS_PACKET_TYPE_BROADCAST |\n\t\t\tNDIS_PACKET_TYPE_MULTICAST) == FALSE)\n\t\t{\n\t\t\tDWORD errcode = GetLastError();\n\n\t\t\t/*\n\t\t\t * Suppress spurious error generated by non-compliant\n\t\t\t * MS Surface mobile adapters.\n\t\t\t */\n\t\t\tif (errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errcode,\n\t\t\t\t    \"failed to set hardware filter to non-promiscuous mode\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the buffer size */\n\tp->bufsize = WIN32_DEFAULT_USER_BUFFER_SIZE;\n\n\tif(!(pw->adapter->Flags & INFO_FLAG_DAG_CARD))\n\t{\n\t/*\n\t * Traditional Adapter\n\t */\n\t\t/*\n\t\t * If the buffer size wasn't explicitly set, default to\n\t\t * WIN32_DEFAULT_KERNEL_BUFFER_SIZE.\n\t\t */\n\t\tif (p->opt.buffer_size == 0)\n\t\t\tp->opt.buffer_size = WIN32_DEFAULT_KERNEL_BUFFER_SIZE;\n\n\t\tif(PacketSetBuff(pw->adapter,p->opt.buffer_size)==FALSE)\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: not enough memory to allocate the kernel buffer\");\n\t\t\tgoto bad;\n\t\t}\n\n\t\tp->buffer = malloc(p->bufsize);\n\t\tif (p->buffer == NULL)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (p->opt.immediate)\n\t\t{\n\t\t\t/* tell the driver to copy the buffer as soon as data arrives */\n\t\t\tif(PacketSetMinToCopy(pw->adapter,0)==FALSE)\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, GetLastError(),\n\t\t\t\t    \"Error calling PacketSetMinToCopy\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* tell the driver to copy the buffer only if it contains at least 16K */\n\t\t\tif(PacketSetMinToCopy(pw->adapter,16000)==FALSE)\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, GetLastError(),\n\t\t\t\t    \"Error calling PacketSetMinToCopy\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * If there's no filter program installed, there's\n\t * no indication to the kernel of what the snapshot\n\t * length should be, so no snapshotting is done.\n\t *\n\t * Therefore, when we open the device, we install\n\t * an \"accept everything\" filter with the specified\n\t * snapshot length.\n\t */\n\ttotal_insn.code = (u_short)(BPF_RET | BPF_K);\n\ttotal_insn.jt = 0;\n\ttotal_insn.jf = 0;\n\ttotal_insn.k = p->snapshot;\n\n\ttotal_prog.bf_len = 1;\n\ttotal_prog.bf_insns = &total_insn;\n\tif (!PacketSetBpf(pw->adapter, &total_prog)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"PacketSetBpf\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\tPacketSetReadTimeout(pw->adapter, p->opt.timeout);\n\n\t/* disable loopback capture if requested */\n\tif (p->opt.nocapture_local)\n\t{\n\t\tif (!PacketSetLoopbackBehavior(pw->adapter, NPF_DISABLE_LOOPBACK))\n\t\t{\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Unable to disable the capture of loopback packets.\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* install traditional npf handlers for read and setfilter */\n\tp->read_op = pcap_read_npf;\n\tp->setfilter_op = pcap_setfilter_npf;\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\t    /* XXX - can this be implemented on some versions of Windows? */\n\tp->inject_op = pcap_inject_npf;\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_npf;\n\tp->setnonblock_op = pcap_setnonblock_npf;\n\tp->stats_op = pcap_stats_npf;\n\tp->breakloop_op = pcap_breakloop_npf;\n\tp->stats_ex_op = pcap_stats_ex_npf;\n\tp->setbuff_op = pcap_setbuff_npf;\n\tp->setmode_op = pcap_setmode_npf;\n\tp->setmintocopy_op = pcap_setmintocopy_npf;\n\tp->getevent_op = pcap_getevent_npf;\n\tp->oid_get_request_op = pcap_oid_get_request_npf;\n\tp->oid_set_request_op = pcap_oid_set_request_npf;\n\tp->sendqueue_transmit_op = pcap_sendqueue_transmit_npf;\n\tp->setuserbuffer_op = pcap_setuserbuffer_npf;\n\tp->live_dump_op = pcap_live_dump_npf;\n\tp->live_dump_ended_op = pcap_live_dump_ended_npf;\n\tp->cleanup_op = pcap_cleanup_npf;\n\n\t/*\n\t * XXX - this is only done because WinPcap supported\n\t * pcap_fileno() returning the hFile HANDLE from the\n\t * ADAPTER structure.  We make no general guarantees\n\t * that the caller can do anything useful with it.\n\t *\n\t * (Not that we make any general guarantee of that\n\t * sort on UN*X, either, anymore, given that not\n\t * all capture devices are regular OS network\n\t * interfaces.)\n\t */\n\tp->handle = pw->adapter->hFile;\n\n\treturn (status);\nbad:\n\tpcap_cleanup_npf(p);\n\treturn (PCAP_ERROR);\n}\n\n/*\n* Check if rfmon mode is supported on the pcap_t for Windows systems.\n*/\nstatic int\npcap_can_set_rfmon_npf(pcap_t *p)\n{\n\treturn (PacketIsMonitorModeSupported(p->opt.device) == 1);\n}\n\n/*\n * Get a list of time stamp types.\n */\n#ifdef HAVE_PACKET_GET_TIMESTAMP_MODES\nstatic int\nget_ts_types(const char *device, pcap_t *p, char *ebuf)\n{\n\tchar *device_copy = NULL;\n\tADAPTER *adapter = NULL;\n\tULONG num_ts_modes;\n\t/* Npcap 1.00 driver is buggy and will write 16 bytes regardless of\n\t * buffer size. Using a sufficient stack buffer avoids overflow and\n\t * avoids a heap allocation in most (currently all) cases.\n\t */\n\tULONG ts_modes[4];\n\tBOOL ret;\n\tDWORD error = ERROR_SUCCESS;\n\tULONG *modes = NULL;\n\tint status = 0;\n\n\tdo {\n\t\t/*\n\t\t * First, find out how many time stamp modes we have.\n\t\t * To do that, we have to open the adapter.\n\t\t *\n\t\t * XXX - PacketOpenAdapter() takes a non-const pointer\n\t\t * as an argument, so we make a copy of the argument and\n\t\t * pass that to it.\n\t\t */\n\t\tdevice_copy = strdup(device);\n\t\tif (device_copy == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tadapter = PacketOpenAdapter(device_copy);\n\t\tif (adapter == NULL)\n\t\t{\n\t\t\terror = GetLastError();\n\t\t\t/*\n\t\t\t * If we can't open the device now, we won't be\n\t\t\t * able to later, either.\n\t\t\t *\n\t\t\t * If the error is something that indicates\n\t\t\t * that the device doesn't exist, or that they\n\t\t\t * don't have permission to open the device - or\n\t\t\t * perhaps that they don't have permission to get\n\t\t\t * a list of devices, if PacketOpenAdapter() does\n\t\t\t * that - the user will find that out when they try\n\t\t\t * to activate the device; just return an empty\n\t\t\t * list of time stamp types.\n\t\t\t *\n\t\t\t * Treating either of those as errors will, for\n\t\t\t * example, cause \"tcpdump -i <number>\" to fail,\n\t\t\t * because it first tries to pass the interface\n\t\t\t * name to pcap_create() and pcap_activate(),\n\t\t\t * in order to handle OSes where interfaces can\n\t\t\t * have names that are just numbers (stand up\n\t\t\t * and say hello, Linux!), and, if pcap_activate()\n\t\t\t * fails with a \"no such device\" error, checks\n\t\t\t * whether the interface name is a valid number\n\t\t\t * and, if so, tries to use it as an index in\n\t\t\t * the list of interfaces.\n\t\t\t *\n\t\t\t * That means pcap_create() must succeed even\n\t\t\t * for interfaces that don't exist, with the\n\t\t\t * failure occurring at pcap_activate() time.\n\t\t\t */\n\t\t\tif (error == ERROR_BAD_UNIT ||\n\t\t\t    error == ERROR_ACCESS_DENIED) {\n\t\t\t\tp->tstamp_type_count = 0;\n\t\t\t\tp->tstamp_type_list = NULL;\n\t\t\t\tstatus = 0;\n\t\t\t} else {\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(ebuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, error,\n\t\t\t\t    \"Error opening adapter\");\n\t\t\t\tstatus = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the total number of time stamp modes.\n\t\t *\n\t\t * The buffer for PacketGetTimestampModes() is\n\t\t * a sequence of 1 or more ULONGs.  What's\n\t\t * passed to PacketGetTimestampModes() should have\n\t\t * the total number of ULONGs in the first ULONG;\n\t\t * what's returned *from* PacketGetTimestampModes()\n\t\t * has the total number of time stamp modes in\n\t\t * the first ULONG.\n\t\t *\n\t\t * Yes, that means if there are N time stamp\n\t\t * modes, the first ULONG should be set to N+1\n\t\t * on input, and will be set to N on output.\n\t\t *\n\t\t * We first make a call to PacketGetTimestampModes()\n\t\t * with a pointer to a single ULONG set to 1; the\n\t\t * call should fail with ERROR_MORE_DATA (unless\n\t\t * there are *no* modes, but that should never\n\t\t * happen), and that ULONG should be set to the\n\t\t * number of modes.\n\t\t */\n\t\tts_modes[0] = sizeof(ts_modes) / sizeof(ULONG);\n\t\tret = PacketGetTimestampModes(adapter, ts_modes);\n\t\tif (!ret) {\n\t\t\t/*\n\t\t\t * OK, it failed.  Did it fail with\n\t\t\t * ERROR_MORE_DATA?\n\t\t\t */\n\t\t\terror = GetLastError();\n\t\t\tif (error != ERROR_MORE_DATA) {\n\t\t\t\t/*\n\t\t\t\t * No, did it fail with ERROR_INVALID_FUNCTION?\n\t\t\t\t */\n\t\t\t\tif (error == ERROR_INVALID_FUNCTION) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is probably due to\n\t\t\t\t\t * the driver with which Packet.dll\n\t\t\t\t\t * communicates being older, or\n\t\t\t\t\t * being a WinPcap driver, so\n\t\t\t\t\t * that it doesn't support\n\t\t\t\t\t * BIOCGTIMESTAMPMODES.\n\t\t\t\t\t *\n\t\t\t\t\t * Tell the user to try uninstalling\n\t\t\t\t\t * Npcap - and WinPcap if installed -\n\t\t\t\t\t * and re-installing it, to flush\n\t\t\t\t\t * out all older drivers.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"PacketGetTimestampModes() failed with ERROR_INVALID_FUNCTION; try uninstalling Npcap, and WinPcap if installed, and re-installing it from npcap.com\");\n\t\t\t\t\tstatus = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No, some other error.  Fail.\n\t\t\t\t */\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(ebuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, error,\n\t\t\t\t    \"Error calling PacketGetTimestampModes\");\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yes, so we now know how many types to fetch.\n\t\t\t *\n\t\t\t * The buffer needs to have one ULONG for the\n\t\t\t * count and num_ts_modes ULONGs for the\n\t\t\t * num_ts_modes time stamp types.\n\t\t\t */\n\t\t\tnum_ts_modes = ts_modes[0];\n\t\t\tmodes = (ULONG *)malloc((1 + num_ts_modes) * sizeof(ULONG));\n\t\t\tif (modes == NULL) {\n\t\t\t\t/* Out of memory. */\n\t\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmodes[0] = 1 + num_ts_modes;\n\t\t\tif (!PacketGetTimestampModes(adapter, modes)) {\n\t\t\t\tpcapint_fmt_errmsg_for_win32_err(ebuf,\n\t\t\t\t\t\tPCAP_ERRBUF_SIZE, GetLastError(),\n\t\t\t\t\t\t\"Error calling PacketGetTimestampModes\");\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modes[0] != num_ts_modes) {\n\t\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\"First PacketGetTimestampModes() call gives %lu modes, second call gives %lu modes\",\n\t\t\t\t\t\tnum_ts_modes, modes[0]);\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmodes = ts_modes;\n\t\t\tnum_ts_modes = ts_modes[0];\n\t\t}\n\n\t\t/* If the driver reports no modes supported *and*\n\t\t * ERROR_MORE_DATA, something is seriously wrong.\n\t\t * We *could* ignore the error and continue without supporting\n\t\t * settable timestamp modes, but that would hide a bug.\n\t\t */\n\t\tif (modes[0] == 0) {\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PacketGetTimestampModes() reports 0 modes supported.\");\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Allocate a buffer big enough for\n\t\t * PCAP_TSTAMP_HOST (default) plus\n\t\t * the explicitly specified modes.\n\t\t */\n\t\tp->tstamp_type_list = malloc((1 + num_ts_modes) * sizeof(u_int));\n\t\tif (p->tstamp_type_list == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\t\tu_int num_ts_types = 0;\n\t\tp->tstamp_type_list[num_ts_types] =\n\t\t    PCAP_TSTAMP_HOST;\n\t\tnum_ts_types++;\n\t\tfor (ULONG i = 0; i < num_ts_modes; i++) {\n\t\t\tswitch (modes[i + 1]) {\n\n\t\t\tcase TIMESTAMPMODE_SINGLE_SYNCHRONIZATION:\n\t\t\t\t/*\n\t\t\t\t * Better than low-res,\n\t\t\t\t * but *not* synchronized\n\t\t\t\t * with the OS clock.\n\t\t\t\t */\n\t\t\t\tp->tstamp_type_list[num_ts_types] =\n\t\t\t\t    PCAP_TSTAMP_HOST_HIPREC_UNSYNCED;\n\t\t\t\tnum_ts_types++;\n\t\t\t\tbreak;\n\n\t\t\tcase TIMESTAMPMODE_QUERYSYSTEMTIME:\n\t\t\t\t/*\n\t\t\t\t * Low-res, but synchronized\n\t\t\t\t * with the OS clock.\n\t\t\t\t */\n\t\t\t\tp->tstamp_type_list[num_ts_types] =\n\t\t\t\t    PCAP_TSTAMP_HOST_LOWPREC;\n\t\t\t\tnum_ts_types++;\n\t\t\t\tbreak;\n\n\t\t\tcase TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE:\n\t\t\t\t/*\n\t\t\t\t * High-res, and synchronized\n\t\t\t\t * with the OS clock.\n\t\t\t\t */\n\t\t\t\tp->tstamp_type_list[num_ts_types] =\n\t\t\t\t    PCAP_TSTAMP_HOST_HIPREC;\n\t\t\t\tnum_ts_types++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Unknown, so we can't\n\t\t\t\t * report it.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp->tstamp_type_count = num_ts_types;\n\t} while (0);\n\n\t/* Clean up temporary allocations */\n\tif (device_copy != NULL) {\n\t\tfree(device_copy);\n\t}\n\tif (modes != NULL && modes != ts_modes) {\n\t\tfree(modes);\n\t}\n\tif (adapter != NULL) {\n\t\tPacketCloseAdapter(adapter);\n\t}\n\n\treturn status;\n}\n#else /* HAVE_PACKET_GET_TIMESTAMP_MODES */\nstatic int\nget_ts_types(const char *device _U_, pcap_t *p _U_, char *ebuf _U_)\n{\n\t/*\n\t * Nothing to fetch, so it always \"succeeds\".\n\t */\n\treturn 0;\n}\n#endif /* HAVE_PACKET_GET_TIMESTAMP_MODES */\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_win);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_npf;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_npf;\n\n\tif (get_ts_types(device, p, ebuf) == -1) {\n\t\tpcap_close(p);\n\t\treturn (NULL);\n\t}\n\treturn (p);\n}\n\nstatic int\npcap_setfilter_npf(pcap_t *p, struct bpf_program *fp)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetBpf(pw->adapter,fp)==FALSE){\n\t\t/*\n\t\t * Kernel filter not installed.\n\t\t *\n\t\t * XXX - we don't know whether this failed because:\n\t\t *\n\t\t *  the kernel rejected the filter program as invalid,\n\t\t *  in which case we should fall back on userland\n\t\t *  filtering;\n\t\t *\n\t\t *  the kernel rejected the filter program as too big,\n\t\t *  in which case we should again fall back on\n\t\t *  userland filtering;\n\t\t *\n\t\t *  there was some other problem, in which case we\n\t\t *  should probably report an error.\n\t\t *\n\t\t * For NPF devices, the Win32 status will be\n\t\t * STATUS_INVALID_DEVICE_REQUEST for invalid\n\t\t * filters, but I don't know what it'd be for\n\t\t * other problems, and for some other devices\n\t\t * it might not be set at all.\n\t\t *\n\t\t * So we just fall back on userland filtering in\n\t\t * all cases.\n\t\t */\n\n\t\t/*\n\t\t * pcapint_install_bpf_program() validates the program.\n\t\t *\n\t\t * XXX - what if we already have a filter in the kernel?\n\t\t */\n\t\tif (pcapint_install_bpf_program(p, fp) < 0)\n\t\t\treturn (-1);\n\t\tpw->filtering_in_kernel = 0;\t/* filtering in userland */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * It worked.\n\t */\n\tpw->filtering_in_kernel = 1;\t/* filtering in the kernel */\n\n\t/*\n\t * Discard any previously-received packets, as they might have\n\t * passed whatever filter was formerly in effect, but might\n\t * not pass this filter (BIOCSETF discards packets buffered\n\t * in the kernel, so you can lose packets in any case).\n\t */\n\tp->cc = 0;\n\treturn (0);\n}\n\n/*\n * We filter at user level, since the kernel driver doesn't process the packets\n */\nstatic int\npcap_setfilter_win32_dag(pcap_t *p, struct bpf_program *fp) {\n\n\tif(!fp)\n\t{\n\t\tpcapint_strlcpy(p->errbuf, \"setfilter: No filter specified\", sizeof(p->errbuf));\n\t\treturn (-1);\n\t}\n\n\t/* Install a user level filter */\n\tif (pcapint_install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nstatic int\npcap_getnonblock_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\t/*\n\t * XXX - if there were a PacketGetReadTimeout() call, we\n\t * would use it, and return 1 if the timeout is -1\n\t * and 0 otherwise.\n\t */\n\treturn (pw->nonblock);\n}\n\nstatic int\npcap_setnonblock_npf(pcap_t *p, int nonblock)\n{\n\tstruct pcap_win *pw = p->priv;\n\tint newtimeout;\n\n\tif (nonblock) {\n\t\t/*\n\t\t * Set the packet buffer timeout to -1 for non-blocking\n\t\t * mode.\n\t\t */\n\t\tnewtimeout = -1;\n\t} else {\n\t\t/*\n\t\t * Restore the timeout set when the device was opened.\n\t\t * (Note that this may be -1, in which case we're not\n\t\t * really leaving non-blocking mode.  However, although\n\t\t * the timeout argument to pcap_set_timeout() and\n\t\t * pcap_open_live() is an int, you're not supposed to\n\t\t * supply a negative value, so that \"shouldn't happen\".)\n\t\t */\n\t\tnewtimeout = p->opt.timeout;\n\t}\n\tif (!PacketSetReadTimeout(pw->adapter, newtimeout)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"PacketSetReadTimeout\");\n\t\treturn (-1);\n\t}\n\tpw->nonblock = (newtimeout == -1);\n\treturn (0);\n}\n\nstatic int\npcap_add_if_npf(pcap_if_list_t *devlistp, char *name, bpf_u_int32 flags,\n    const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev;\n\tnpf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];\n\tLONG if_addr_size;\n\tint res = 0;\n\n\tif_addr_size = MAX_NETWORK_ADDRESSES;\n\n\t/*\n\t * Add an entry for this interface, with no addresses.\n\t */\n\tcurdev = pcapint_add_dev(devlistp, name, flags, description, errbuf);\n\tif (curdev == NULL) {\n\t\t/*\n\t\t * Failure.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the list of addresses for the interface.\n\t */\n\tif (!PacketGetNetInfoEx((void *)name, if_addrs, &if_addr_size)) {\n\t\t/*\n\t\t * Failure.\n\t\t *\n\t\t * We don't return an error, because this can happen with\n\t\t * NdisWan interfaces, and we want to supply them even\n\t\t * if we can't supply their addresses.\n\t\t *\n\t\t * We return an entry with an empty address list.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Now add the addresses.\n\t */\n\twhile (if_addr_size-- > 0) {\n\t\t/*\n\t\t * \"curdev\" is an entry for this interface; add an entry for\n\t\t * this address to its list of addresses.\n\t\t */\n\t\tres = pcapint_add_addr_to_dev(curdev,\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].IPAddress,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].SubnetMask,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].Broadcast,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    NULL,\n\t\t    0,\n\t\t    errbuf);\n\t\tif (res == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (res);\n}\n\nstatic int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tchar *name_copy;\n\tADAPTER *adapter;\n\tint status;\n\tsize_t len;\n\tNDIS_HARDWARE_STATUS hardware_status;\n#ifdef OID_GEN_PHYSICAL_MEDIUM\n\tNDIS_PHYSICAL_MEDIUM phys_medium;\n\tbpf_u_int32 gen_physical_medium_oids[] = {\n  #ifdef OID_GEN_PHYSICAL_MEDIUM_EX\n\t\tOID_GEN_PHYSICAL_MEDIUM_EX,\n  #endif\n\t\tOID_GEN_PHYSICAL_MEDIUM\n\t};\n#define N_GEN_PHYSICAL_MEDIUM_OIDS\t(sizeof gen_physical_medium_oids / sizeof gen_physical_medium_oids[0])\n\tsize_t i;\n#endif /* OID_GEN_PHYSICAL_MEDIUM */\n#ifdef OID_GEN_LINK_STATE\n\tNDIS_LINK_STATE link_state;\n#endif\n\tint connect_status;\n\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback interface, so the connection status doesn't\n\t\t * apply. and it's not wireless (or wired, for that\n\t\t * matter...).  We presume it's up and running.\n\t\t */\n\t\t*flags |= PCAP_IF_UP | PCAP_IF_RUNNING | PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * We need to open the adapter to get this information.\n\t *\n\t * XXX - PacketOpenAdapter() takes a non-const pointer\n\t * as an argument, so we make a copy of the argument and\n\t * pass that to it.\n\t */\n\tname_copy = strdup(name);\n\tadapter = PacketOpenAdapter(name_copy);\n\tfree(name_copy);\n\tif (adapter == NULL) {\n\t\t/*\n\t\t * Give up; if they try to open this device, it'll fail.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Get the hardware status, and derive \"up\" and \"running\" from\n\t * that.\n\t */\n\tlen = sizeof (hardware_status);\n\tstatus = oid_get_request(adapter, OID_GEN_HARDWARE_STATUS,\n\t    &hardware_status, &len, errbuf);\n\tif (status == 0) {\n\t\tswitch (hardware_status) {\n\n\t\tcase NdisHardwareStatusReady:\n\t\t\t/*\n\t\t\t * \"Available and capable of sending and receiving\n\t\t\t * data over the wire\", so up and running.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_UP | PCAP_IF_RUNNING;\n\t\t\tbreak;\n\n\t\tcase NdisHardwareStatusInitializing:\n\t\tcase NdisHardwareStatusReset:\n\t\t\t/*\n\t\t\t * \"Initializing\" or \"Resetting\", so up, but\n\t\t\t * not running.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_UP;\n\t\t\tbreak;\n\n\t\tcase NdisHardwareStatusClosing:\n\t\tcase NdisHardwareStatusNotReady:\n\t\t\t/*\n\t\t\t * \"Closing\" or \"Not ready\", so neither up nor\n\t\t\t * running.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Unknown.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Can't get the hardware status, so assume both up and\n\t\t * running.\n\t\t */\n\t\t*flags |= PCAP_IF_UP | PCAP_IF_RUNNING;\n\t}\n\n\t/*\n\t * Get the network type.\n\t */\n#ifdef OID_GEN_PHYSICAL_MEDIUM\n\t/*\n\t * Try the OIDs we have for this, in order.\n\t */\n\tfor (i = 0; i < N_GEN_PHYSICAL_MEDIUM_OIDS; i++) {\n\t\tlen = sizeof (phys_medium);\n\t\tstatus = oid_get_request(adapter, gen_physical_medium_oids[i],\n\t\t    &phys_medium, &len, errbuf);\n\t\tif (status == 0) {\n\t\t\t/*\n\t\t\t * Success.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Failed.  We can't determine whether it failed\n\t\t * because that particular OID isn't supported\n\t\t * or because some other problem occurred, so we\n\t\t * just drive on and try the next OID.\n\t\t */\n\t}\n\tif (status == 0) {\n\t\t/*\n\t\t * We got the physical medium.\n\t\t *\n\t\t * XXX - we might want to check for NdisPhysicalMediumWiMax\n\t\t * and NdisPhysicalMediumNative802_15_4 being\n\t\t * part of the enum, and check for those in the \"wireless\"\n\t\t * case.\n\t\t */\nDIAG_OFF_ENUM_SWITCH\n\t\tswitch (phys_medium) {\n\n\t\tcase NdisPhysicalMediumWirelessLan:\n\t\tcase NdisPhysicalMediumWirelessWan:\n\t\tcase NdisPhysicalMediumNative802_11:\n\t\tcase NdisPhysicalMediumBluetooth:\n\t\tcase NdisPhysicalMediumUWB:\n\t\tcase NdisPhysicalMediumIrda:\n\t\t\t/*\n\t\t\t * Wireless.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_WIRELESS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not wireless or unknown\n\t\t\t */\n\t\t\tbreak;\n\t\t}\nDIAG_ON_ENUM_SWITCH\n\t}\n#endif\n\n\t/*\n\t * Get the connection status.\n\t */\n#ifdef OID_GEN_LINK_STATE\n\tlen = sizeof(link_state);\n\tstatus = oid_get_request(adapter, OID_GEN_LINK_STATE, &link_state,\n\t    &len, errbuf);\n\tif (status == 0) {\n\t\t/*\n\t\t * NOTE: this also gives us the receive and transmit\n\t\t * link state.\n\t\t */\n\t\tswitch (link_state.MediaConnectState) {\n\n\t\tcase MediaConnectStateConnected:\n\t\t\t/*\n\t\t\t * It's connected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t\t\tbreak;\n\n\t\tcase MediaConnectStateDisconnected:\n\t\t\t/*\n\t\t\t * It's disconnected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\t\tbreak;\n\n\t\tcase MediaConnectStateUnknown:\n\t\tdefault:\n\t\t\t/*\n\t\t\t * It's unknown whether it's connected or not.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\t/*\n\t * OID_GEN_LINK_STATE isn't supported because it's not in our SDK.\n\t */\n\tstatus = -1;\n#endif\n\tif (status == -1) {\n\t\t/*\n\t\t * OK, OID_GEN_LINK_STATE didn't work, try\n\t\t * OID_GEN_MEDIA_CONNECT_STATUS.\n\t\t */\n\t\tstatus = oid_get_request(adapter, OID_GEN_MEDIA_CONNECT_STATUS,\n\t\t    &connect_status, &len, errbuf);\n\t\tif (status == 0) {\n\t\t\tswitch (connect_status) {\n\n\t\t\tcase NdisMediaStateConnected:\n\t\t\t\t/*\n\t\t\t\t * It's connected.\n\t\t\t\t */\n\t\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t\t\t\tbreak;\n\n\t\t\tcase NdisMediaStateDisconnected:\n\t\t\t\t/*\n\t\t\t\t * It's disconnected.\n\t\t\t\t */\n\t\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tPacketCloseAdapter(adapter);\n\treturn (0);\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint ret = 0;\n\tconst char *desc;\n\tchar *AdaptersName;\n\tULONG NameLength;\n\tchar *name;\n\n\t/*\n\t * Find out how big a buffer we need.\n\t *\n\t * This call should always return FALSE; if the error is\n\t * ERROR_INSUFFICIENT_BUFFER, NameLength will be set to\n\t * the size of the buffer we need, otherwise there's a\n\t * problem, and NameLength should be set to 0.\n\t *\n\t * It shouldn't require NameLength to be set, but,\n\t * at least as of WinPcap 4.1.3, it checks whether\n\t * NameLength is big enough before it checks for a\n\t * NULL buffer argument, so, while it'll still do\n\t * the right thing if NameLength is uninitialized and\n\t * whatever junk happens to be there is big enough\n\t * (because the pointer argument will be null), it's\n\t * still reading an uninitialized variable.\n\t */\n\tNameLength = 0;\n\tif (!PacketGetAdapterNames(NULL, &NameLength))\n\t{\n\t\tDWORD last_error = GetLastError();\n\n\t\tif (last_error != ERROR_INSUFFICIENT_BUFFER)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    last_error, \"PacketGetAdapterNames\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (NameLength <= 0)\n\t\treturn 0;\n\tAdaptersName = (char*) malloc(NameLength);\n\tif (AdaptersName == NULL)\n\t{\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Cannot allocate enough memory to list the adapters.\");\n\t\treturn (-1);\n\t}\n\n\tif (!PacketGetAdapterNames(AdaptersName, &NameLength)) {\n\t\tpcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"PacketGetAdapterNames\");\n\t\tfree(AdaptersName);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * \"PacketGetAdapterNames()\" returned a list of\n\t * null-terminated ASCII interface name strings,\n\t * terminated by a null string, followed by a list\n\t * of null-terminated ASCII interface description\n\t * strings, terminated by a null string.\n\t * This means there are two ASCII nulls at the end\n\t * of the first list.\n\t *\n\t * Find the end of the first list; that's the\n\t * beginning of the second list.\n\t */\n\tdesc = &AdaptersName[0];\n\twhile (*desc != '\\0' || *(desc + 1) != '\\0')\n\t\tdesc++;\n\n\t/*\n\t * Found it - \"desc\" points to the first of the two\n\t * nulls at the end of the list of names, so the\n\t * first byte of the list of descriptions is two bytes\n\t * after it.\n\t */\n\tdesc += 2;\n\n\t/*\n\t * Loop over the elements in the first list.\n\t */\n\tname = &AdaptersName[0];\n\twhile (*name != '\\0') {\n\t\tbpf_u_int32 flags = 0;\n\n#ifdef HAVE_PACKET_IS_LOOPBACK_ADAPTER\n\t\t/*\n\t\t * Is this a loopback interface?\n\t\t */\n\t\tif (PacketIsLoopbackAdapter(name)) {\n\t\t\t/* Yes */\n\t\t\tflags |= PCAP_IF_LOOPBACK;\n\t\t}\n#endif\n\t\t/*\n\t\t * Get additional flags.\n\t\t */\n\t\tif (get_if_flags(name, &flags, errbuf) == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Add an entry for this interface.\n\t\t */\n\t\tif (pcap_add_if_npf(devlistp, name, flags, desc,\n\t\t    errbuf) == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tname += strlen(name) + 1;\n\t\tdesc += strlen(desc) + 1;\n\t}\n\n\tfree(AdaptersName);\n\treturn (ret);\n}\n\n/*\n * Return the name of a network interface attached to the system, or NULL\n * if none can be found.  The interface must be configured up; the\n * lowest unit number is preferred; loopback is ignored.\n *\n * In the best of all possible worlds, this would be the same as on\n * UN*X, but there may be software that expects this to return a\n * full list of devices after the first device.\n */\n#define ADAPTERSNAME_LEN\t8192\nchar *\npcap_lookupdev(char *errbuf)\n{\n\tDWORD dwVersion;\n\tDWORD dwWindowsMajorVersion;\n\n\t/*\n\t * We disable this in \"new API\" mode, because 1) in WinPcap/Npcap,\n\t * it may return UTF-16 strings, for backwards-compatibility\n\t * reasons, and we're also disabling the hack to make that work,\n\t * for not-going-past-the-end-of-a-string reasons, and 2) we\n\t * want its behavior to be consistent.\n\t *\n\t * In addition, it's not thread-safe, so we've marked it as\n\t * deprecated.\n\t */\n\tif (pcapint_new_api) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()\");\n\t\treturn (NULL);\n\t}\n\n/* disable MSVC's GetVersion() deprecated warning here */\nDIAG_OFF_DEPRECATION\n\tdwVersion = GetVersion();\t/* get the OS version */\nDIAG_ON_DEPRECATION\n\tdwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\n\tif (dwVersion >= 0x80000000 && dwWindowsMajorVersion >= 4) {\n\t\t/*\n\t\t * Windows 95, 98, ME.\n\t\t */\n\t\tULONG NameLength = ADAPTERSNAME_LEN;\n\t\tstatic char AdaptersName[ADAPTERSNAME_LEN];\n\n\t\tif (PacketGetAdapterNames(AdaptersName,&NameLength) )\n\t\t\treturn (AdaptersName);\n\t\telse\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Windows NT (NT 4.0 and later).\n\t\t * Convert the names to Unicode for backward compatibility.\n\t\t */\n\t\tULONG NameLength = ADAPTERSNAME_LEN;\n\t\tstatic WCHAR AdaptersName[ADAPTERSNAME_LEN];\n\t\tsize_t BufferSpaceLeft;\n\t\tchar *tAstr;\n\t\tWCHAR *Unameptr;\n\t\tchar *Adescptr;\n\t\tsize_t namelen, i;\n\t\tWCHAR *TAdaptersName = (WCHAR*)malloc(ADAPTERSNAME_LEN * sizeof(WCHAR));\n\t\tint NAdapts = 0;\n\n\t\tif(TAdaptersName == NULL)\n\t\t{\n\t\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE, \"memory allocation failure\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ( !PacketGetAdapterNames((PTSTR)TAdaptersName,&NameLength) )\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    GetLastError(), \"PacketGetAdapterNames\");\n\t\t\tfree(TAdaptersName);\n\t\t\treturn NULL;\n\t\t}\n\n\n\t\tBufferSpaceLeft = ADAPTERSNAME_LEN * sizeof(WCHAR);\n\t\ttAstr = (char*)TAdaptersName;\n\t\tUnameptr = AdaptersName;\n\n\t\t/*\n\t\t * Convert the device names to Unicode into AdapterName.\n\t\t */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Length of the name, including the terminating\n\t\t\t * NUL.\n\t\t\t */\n\t\t\tnamelen = strlen(tAstr) + 1;\n\n\t\t\t/*\n\t\t\t * Do we have room for the name in the Unicode\n\t\t\t * buffer?\n\t\t\t */\n\t\t\tif (BufferSpaceLeft < namelen * sizeof(WCHAR)) {\n\t\t\t\t/*\n\t\t\t\t * No.\n\t\t\t\t */\n\t\t\t\tgoto quit;\n\t\t\t}\n\t\t\tBufferSpaceLeft -= namelen * sizeof(WCHAR);\n\n\t\t\t/*\n\t\t\t * Copy the name, converting ASCII to Unicode.\n\t\t\t * namelen includes the NUL, so we copy it as\n\t\t\t * well.\n\t\t\t */\n\t\t\tfor (i = 0; i < namelen; i++)\n\t\t\t\t*Unameptr++ = *tAstr++;\n\n\t\t\t/*\n\t\t\t * Count this adapter.\n\t\t\t */\n\t\t\tNAdapts++;\n\t\t} while (namelen != 1);\n\n\t\t/*\n\t\t * Copy the descriptions, but don't convert them from\n\t\t * ASCII to Unicode.\n\t\t */\n\t\tAdescptr = (char *)Unameptr;\n\t\twhile(NAdapts--)\n\t\t{\n\t\t\tsize_t desclen;\n\n\t\t\tdesclen = strlen(tAstr) + 1;\n\n\t\t\t/*\n\t\t\t * Do we have room for the name in the Unicode\n\t\t\t * buffer?\n\t\t\t */\n\t\t\tif (BufferSpaceLeft < desclen) {\n\t\t\t\t/*\n\t\t\t\t * No.\n\t\t\t\t */\n\t\t\t\tgoto quit;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Just copy the ASCII string.\n\t\t\t * namelen includes the NUL, so we copy it as\n\t\t\t * well.\n\t\t\t */\n\t\t\tmemcpy(Adescptr, tAstr, desclen);\n\t\t\tAdescptr += desclen;\n\t\t\ttAstr += desclen;\n\t\t\tBufferSpaceLeft -= desclen;\n\t\t}\n\n\tquit:\n\t\tfree(TAdaptersName);\n\t\treturn (char *)(AdaptersName);\n\t}\n}\n\n/*\n * We can't use the same code that we use on UN*X, as that's doing\n * UN*X-specific calls.\n *\n * We don't just fetch the entire list of devices, search for the\n * particular device, and use its first IPv4 address, as that's too\n * much work to get just one device's netmask.\n */\nint\npcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,\n    char *errbuf)\n{\n\t/*\n\t * We need only the first IPv4 address, so we must scan the array returned by PacketGetNetInfo()\n\t * in order to skip non IPv4 (i.e. IPv6 addresses)\n\t */\n\tnpf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];\n\tLONG if_addr_size = MAX_NETWORK_ADDRESSES;\n\tstruct sockaddr_in *t_addr;\n\tLONG i;\n\n\tif (!PacketGetNetInfoEx((void *)device, if_addrs, &if_addr_size)) {\n\t\t*netp = *maskp = 0;\n\t\treturn (0);\n\t}\n\n\tfor(i = 0; i < if_addr_size; i++)\n\t{\n\t\tif(if_addrs[i].IPAddress.ss_family == AF_INET)\n\t\t{\n\t\t\tt_addr = (struct sockaddr_in *) &(if_addrs[i].IPAddress);\n\t\t\t*netp = t_addr->sin_addr.S_un.S_addr;\n\t\t\tt_addr = (struct sockaddr_in *) &(if_addrs[i].SubnetMask);\n\t\t\t*maskp = t_addr->sin_addr.S_un.S_addr;\n\n\t\t\t*netp &= *maskp;\n\t\t\treturn (0);\n\t\t}\n\n\t}\n\n\t*netp = *maskp = 0;\n\treturn (0);\n}\n\nstatic const char *pcap_lib_version_string;\n\n#ifdef HAVE_VERSION_H\n/*\n * libpcap being built for Windows, as part of a WinPcap/Npcap source\n * tree.  Include version.h from that source tree to get the WinPcap/Npcap\n * version.\n *\n * XXX - it'd be nice if we could somehow generate the WinPcap/Npcap version\n * number when building as part of WinPcap/Npcap.  (It'd be nice to do so\n * for the packet.dll version number as well.)\n */\n#include \"../../version.h\"\n\nstatic const char pcap_version_string[] =\n\tWINPCAP_PRODUCT_NAME \" version \" WINPCAP_VER_STRING \", based on \" PCAP_VERSION_STRING;\n\nconst char *\npcap_lib_version(void)\n{\n\tif (pcap_lib_version_string == NULL) {\n\t\t/*\n\t\t * Generate the version string.\n\t\t */\n\t\tconst char *packet_version_string = PacketGetVersion();\n\n\t\tif (strcmp(WINPCAP_VER_STRING, packet_version_string) == 0) {\n\t\t\t/*\n\t\t\t * WinPcap/Npcap version string and packet.dll version\n\t\t\t * string are the same; just report the WinPcap/Npcap\n\t\t\t * version.\n\t\t\t */\n\t\t\tpcap_lib_version_string = pcap_version_string;\n\t\t} else {\n\t\t\t/*\n\t\t\t * WinPcap/Npcap version string and packet.dll version\n\t\t\t * string are different; that shouldn't be the\n\t\t\t * case (the two libraries should come from the\n\t\t\t * same version of WinPcap/Npcap), so we report both\n\t\t\t * versions.\n\t\t\t */\n\t\t\tchar *full_pcap_version_string;\n\n\t\t\tif (pcapint_asprintf(&full_pcap_version_string,\n\t\t\t    WINPCAP_PRODUCT_NAME \" version \" WINPCAP_VER_STRING \" (packet.dll version %s), based on \" PCAP_VERSION_STRING,\n\t\t\t    packet_version_string) != -1) {\n\t\t\t\t/* Success */\n\t\t\t\tpcap_lib_version_string = full_pcap_version_string;\n\t\t\t}\n\t\t}\n\t}\n\treturn (pcap_lib_version_string);\n}\n\n#else /* HAVE_VERSION_H */\n\n/*\n * libpcap being built for Windows, not as part of a WinPcap/Npcap source\n * tree.\n */\nconst char *\npcap_lib_version(void)\n{\n\tif (pcap_lib_version_string == NULL) {\n\t\t/*\n\t\t * Generate the version string.  Report the packet.dll\n\t\t * version.\n\t\t */\n\t\tchar *full_pcap_version_string;\n\n\t\tif (pcapint_asprintf(&full_pcap_version_string,\n\t\t    PCAP_VERSION_STRING \" (packet.dll version %s)\",\n\t\t    PacketGetVersion()) != -1) {\n\t\t\t/* Success */\n\t\t\tpcap_lib_version_string = full_pcap_version_string;\n\t\t}\n\t}\n\treturn (pcap_lib_version_string);\n}\n#endif /* HAVE_VERSION_H */\n"
        },
        {
          "name": "pcap-null.c",
          "type": "blob",
          "size": 1.8828125,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <string.h>\n\n#include \"pcap-int.h\"\n\nstatic char nosup[] = \"live packet capture not supported on this system\";\n\npcap_t *\npcapint_create_interface(const char *device _U_, char *ebuf)\n{\n\t(void)pcapint_strlcpy(ebuf, nosup, PCAP_ERRBUF_SIZE);\n\treturn (NULL);\n}\n\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf _U_)\n{\n\t/*\n\t * There are no interfaces on which we can capture.\n\t */\n\treturn (0);\n}\n\n#ifdef _WIN32\nint\npcap_lookupnet(const char *device _U_, bpf_u_int32 *netp _U_,\n    bpf_u_int32 *maskp _U_, char *errbuf)\n{\n\t(void)pcapint_strlcpy(errbuf, nosup, PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}\n#endif\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}\n"
        },
        {
          "name": "pcap-options.c",
          "type": "blob",
          "size": 4.2255859375,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n\n/*\n * Private data for storing sets of options.\n * This is to be used by functions which seem to grow additional options\n * This is avoid ABI explosion of do_thing, and do_thing_with_opt_bar(),\n * and then do_thing_with_opt_bar_baz(...). Instead a \"pcap_option\" should be\n * created to which get/set shall be done.\n *\n * each option shall have an element in enum pcap_option_name {}.\n */\nstruct pcap_options {\n        int   tstamp_precision;\n        const char *io_read_plugin;\n        const char *io_write_plugin;\n};\n\npcap_options *pcap_alloc_option(void)\n{\n        pcap_options *po = malloc(sizeof(struct pcap_options));\n        memset(po, 0, sizeof(struct pcap_options));\n        return po;  // caller has to check for NULL anyway.\n}\n\nvoid pcap_free_option(pcap_options *po)\n{\n        if(po != NULL) {\n                if(po->io_read_plugin) free((void *)po->io_read_plugin);\n                if(po->io_write_plugin) free((void *)po->io_write_plugin);\n                free((void *)po);\n        }\n}\n\n/* Return 0 on success, -1 on failure invalid option, -2 on type mismatch */\nint pcap_set_option_string(pcap_options *po,\n                           enum   pcap_option_name pon,\n                           const char *value)\n{\n        const char *saved = strdup(value);\n        switch(pon) {\n        case PON_TSTAMP_PRECISION:\n                free((void *)saved);\n                return -2;\n\n        case PON_IO_READ_PLUGIN:\n                po->io_read_plugin = saved;\n                break;\n        case PON_IO_WRITE_PLUGIN:\n                po->io_write_plugin= saved;\n                break;\n        default:\n                free((void *)saved);\n                return -1;\n        }\n        return 0;\n}\n\n/* Return 0 on success, -1 on failure invalid option, -2 on type mismatch */\nint pcap_set_option_int(pcap_options *po,\n                        enum   pcap_option_name pon,\n                        const int value)\n{\n        switch(pon) {\n        case PON_TSTAMP_PRECISION:\n                po->tstamp_precision = value;\n                break;\n\n        case PON_IO_READ_PLUGIN:\n        case PON_IO_WRITE_PLUGIN:\n                return -2;\n        default:\n                return -1;\n        }\n        return 0;\n}\n\nconst char *pcap_get_option_string(pcap_options *po,\n                                   enum   pcap_option_name pon)\n{\n        switch(pon) {\n        case PON_TSTAMP_PRECISION:\n                return NULL;\n\n        case PON_IO_READ_PLUGIN:\n                return po->io_read_plugin;\n        case PON_IO_WRITE_PLUGIN:\n                return po->io_write_plugin;\n        }\n        return NULL;\n}\n\n\n/* return int value, or zero for not-found, mis-type */\nint pcap_get_option_int(pcap_options *po,\n                        enum   pcap_option_name pon)\n{\n        switch(pon) {\n        case PON_TSTAMP_PRECISION:\n                return po->tstamp_precision;\n                break;\n\n        case PON_IO_READ_PLUGIN:\n        case PON_IO_WRITE_PLUGIN:\n                return 0;\n        }\n        return 0;\n}\n\n"
        },
        {
          "name": "pcap-rdmasniff.c",
          "type": "blob",
          "size": 11.49609375,
          "content": "/*\n * Copyright (c) 2017 Pure Storage, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-rdmasniff.h\"\n\n#include <infiniband/verbs.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h> /* for INT_MAX */\n#include <sys/time.h>\n\n#if !defined(IBV_FLOW_ATTR_SNIFFER)\n#define IBV_FLOW_ATTR_SNIFFER\t3\n#endif\n\nstatic const int RDMASNIFF_NUM_RECEIVES = 128;\nstatic const int RDMASNIFF_RECEIVE_SIZE = 10000;\n\nstruct pcap_rdmasniff {\n\tstruct ibv_device *\t\trdma_device;\n\tstruct ibv_context *\t\tcontext;\n\tstruct ibv_comp_channel *\tchannel;\n\tstruct ibv_pd *\t\t\tpd;\n\tstruct ibv_cq *\t\t\tcq;\n\tstruct ibv_qp *\t\t\tqp;\n\tstruct ibv_flow *               flow;\n\tstruct ibv_mr *\t\t\tmr;\n\tu_char *\t\t\toneshot_buffer;\n\tunsigned long\t\t\tport_num;\n\tint                             cq_event;\n\tu_int                           packets_recv;\n};\n\nstatic int\nrdmasniff_stats(pcap_t *handle, struct pcap_stat *stat)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\tstat->ps_recv = priv->packets_recv;\n\tstat->ps_drop = 0;\n\tstat->ps_ifdrop = 0;\n\n\treturn 0;\n}\n\nstatic void\nrdmasniff_cleanup(pcap_t *handle)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\tibv_dereg_mr(priv->mr);\n\tibv_destroy_flow(priv->flow);\n\tibv_destroy_qp(priv->qp);\n\tibv_destroy_cq(priv->cq);\n\tibv_dealloc_pd(priv->pd);\n\tibv_destroy_comp_channel(priv->channel);\n\tibv_close_device(priv->context);\n\tfree(priv->oneshot_buffer);\n\n\tpcapint_cleanup_live_common(handle);\n}\n\nstatic void\nrdmasniff_post_recv(pcap_t *handle, uint64_t wr_id)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_sge sg_entry;\n\tstruct ibv_recv_wr wr, *bad_wr;\n\n\tsg_entry.length = RDMASNIFF_RECEIVE_SIZE;\n\tsg_entry.addr = (uintptr_t) handle->buffer + RDMASNIFF_RECEIVE_SIZE * wr_id;\n\tsg_entry.lkey = priv->mr->lkey;\n\n\twr.wr_id = wr_id;\n\twr.num_sge = 1;\n\twr.sg_list = &sg_entry;\n\twr.next = NULL;\n\n\tibv_post_recv(priv->qp, &wr, &bad_wr);\n}\n\nstatic int\nrdmasniff_read(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_cq *ev_cq;\n\tvoid *ev_ctx;\n\tstruct ibv_wc wc;\n\tstruct pcap_pkthdr pkth;\n\tu_char *pktd;\n\tint count = 0;\n\n\tif (!priv->cq_event) {\n\t\twhile (ibv_get_cq_event(priv->channel, &ev_cq, &ev_ctx) < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tif (handle->break_loop) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t}\n\t\t}\n\t\tibv_ack_cq_events(priv->cq, 1);\n\t\tibv_req_notify_cq(priv->cq, 0);\n\t\tpriv->cq_event = 1;\n\t}\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(max_packets))\n\t\tmax_packets = INT_MAX;\n\n\twhile (count < max_packets) {\n\t\tif (ibv_poll_cq(priv->cq, 1, &wc) != 1) {\n\t\t\tpriv->cq_event = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc.status != IBV_WC_SUCCESS) {\n\t\t\tfprintf(stderr, \"failed WC wr_id %\" PRIu64 \" status %d/%s\\n\",\n\t\t\t\twc.wr_id,\n\t\t\t\twc.status, ibv_wc_status_str(wc.status));\n\t\t\tcontinue;\n\t\t}\n\n\t\tpkth.len = wc.byte_len;\n\t\tpkth.caplen = min(pkth.len, (u_int)handle->snapshot);\n\t\tgettimeofday(&pkth.ts, NULL);\n\n\t\tpktd = handle->buffer + wc.wr_id * RDMASNIFF_RECEIVE_SIZE;\n\n\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t    pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n\t\t\tcallback(user, &pkth, pktd);\n\t\t\t++priv->packets_recv;\n\t\t\t++count;\n\t\t}\n\n\t\trdmasniff_post_recv(handle, wc.wr_id);\n\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic void\nrdmasniff_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *) user;\n\tpcap_t *handle = sp->pd;\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\t*sp->hdr = *h;\n\tmemcpy(priv->oneshot_buffer, bytes, h->caplen);\n\t*sp->pkt = priv->oneshot_buffer;\n}\n\nstatic int\nrdmasniff_activate(pcap_t *handle)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_qp_init_attr qp_init_attr;\n\tstruct ibv_qp_attr qp_attr;\n\tstruct ibv_flow_attr flow_attr;\n\tstruct ibv_port_attr port_attr;\n\tint i;\n\n\tpriv->context = ibv_open_device(priv->rdma_device);\n\tif (!priv->context) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to open device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->pd = ibv_alloc_pd(priv->context);\n\tif (!priv->pd) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to alloc PD for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->channel = ibv_create_comp_channel(priv->context);\n\tif (!priv->channel) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create comp channel for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->cq = ibv_create_cq(priv->context, RDMASNIFF_NUM_RECEIVES,\n\t\t\t\t NULL, priv->channel, 0);\n\tif (!priv->cq) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create CQ for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tibv_req_notify_cq(priv->cq, 0);\n\n\tmemset(&qp_init_attr, 0, sizeof qp_init_attr);\n\tqp_init_attr.send_cq = qp_init_attr.recv_cq = priv->cq;\n\tqp_init_attr.cap.max_recv_wr = RDMASNIFF_NUM_RECEIVES;\n\tqp_init_attr.cap.max_recv_sge = 1;\n\tqp_init_attr.qp_type = IBV_QPT_RAW_PACKET;\n\tpriv->qp = ibv_create_qp(priv->pd, &qp_init_attr);\n\tif (!priv->qp) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create QP for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = IBV_QPS_INIT;\n\tqp_attr.port_num = priv->port_num;\n\tif (ibv_modify_qp(priv->qp, &qp_attr, IBV_QP_STATE | IBV_QP_PORT)) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to modify QP to INIT for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = IBV_QPS_RTR;\n\tif (ibv_modify_qp(priv->qp, &qp_attr, IBV_QP_STATE)) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to modify QP to RTR for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&flow_attr, 0, sizeof flow_attr);\n\tflow_attr.type = IBV_FLOW_ATTR_SNIFFER;\n\tflow_attr.size = sizeof flow_attr;\n\tflow_attr.port = priv->port_num;\n\tpriv->flow = ibv_create_flow(priv->qp, &flow_attr);\n\tif (!priv->flow) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create flow for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\thandle->bufsize = RDMASNIFF_NUM_RECEIVES * RDMASNIFF_RECEIVE_SIZE;\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to allocate receive buffer for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->oneshot_buffer = malloc(RDMASNIFF_RECEIVE_SIZE);\n\tif (!priv->oneshot_buffer) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to allocate oneshot buffer for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->mr = ibv_reg_mr(priv->pd, handle->buffer, handle->bufsize, IBV_ACCESS_LOCAL_WRITE);\n\tif (!priv->mr) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to register MR for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\n\tfor (i = 0; i < RDMASNIFF_NUM_RECEIVES; ++i) {\n\t\trdmasniff_post_recv(handle, i);\n\t}\n\n\tif (!ibv_query_port(priv->context, priv->port_num, &port_attr) &&\n\t    port_attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {\n\t\thandle->linktype = DLT_INFINIBAND;\n\t} else {\n\t\thandle->linktype = DLT_EN10MB;\n\t}\n\n\tif (handle->snapshot <= 0 || handle->snapshot > RDMASNIFF_RECEIVE_SIZE)\n\t\thandle->snapshot = RDMASNIFF_RECEIVE_SIZE;\n\n\thandle->offset = 0;\n\thandle->read_op = rdmasniff_read;\n\thandle->stats_op = rdmasniff_stats;\n\thandle->cleanup_op = rdmasniff_cleanup;\n\thandle->setfilter_op = pcapint_install_bpf_program;\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = NULL;\n\thandle->getnonblock_op = pcapint_getnonblock_fd;\n\thandle->setnonblock_op = pcapint_setnonblock_fd;\n\thandle->oneshot_callback = rdmasniff_oneshot;\n\thandle->selectable_fd = priv->channel->fd;\n\n\treturn 0;\n\nerror:\n\tif (priv->mr) {\n\t\tibv_dereg_mr(priv->mr);\n\t}\n\n\tif (priv->flow) {\n\t\tibv_destroy_flow(priv->flow);\n\t}\n\n\tif (priv->qp) {\n\t\tibv_destroy_qp(priv->qp);\n\t}\n\n\tif (priv->cq) {\n\t\tibv_destroy_cq(priv->cq);\n\t}\n\n\tif (priv->channel) {\n\t\tibv_destroy_comp_channel(priv->channel);\n\t}\n\n\tif (priv->pd) {\n\t\tibv_dealloc_pd(priv->pd);\n\t}\n\n\tif (priv->context) {\n\t\tibv_close_device(priv->context);\n\t}\n\n\tif (priv->oneshot_buffer) {\n\t\tfree(priv->oneshot_buffer);\n\t}\n\n\treturn PCAP_ERROR;\n}\n\npcap_t *\nrdmasniff_create(const char *device, char *ebuf, int *is_ours)\n{\n\tstruct pcap_rdmasniff *priv;\n\tstruct ibv_device **dev_list;\n\tint numdev;\n\tsize_t namelen;\n\tconst char *port;\n\tunsigned long port_num;\n\tint i;\n\tpcap_t *p = NULL;\n\n\t*is_ours = 0;\n\n\tdev_list = ibv_get_device_list(&numdev);\n\tif (!dev_list) {\n\t\treturn NULL;\n\t}\n\tif (!numdev) {\n\t\tibv_free_device_list(dev_list);\n\t\treturn NULL;\n\t}\n\n\tnamelen = strlen(device);\n\n\tport = strchr(device, ':');\n\tif (port) {\n\t\tport_num = strtoul(port + 1, NULL, 10);\n\t\tif (port_num > 0) {\n\t\t\tnamelen = port - device;\n\t\t} else {\n\t\t\tport_num = 1;\n\t\t}\n\t} else {\n\t\tport_num = 1;\n\t}\n\n\tfor (i = 0; i < numdev; ++i) {\n\t\tif (strlen(dev_list[i]->name) == namelen &&\n\t\t    !strncmp(device, dev_list[i]->name, namelen)) {\n\t\t\t*is_ours = 1;\n\n\t\t\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_rdmasniff);\n\t\t\tif (p) {\n\t\t\t\tp->activate_op = rdmasniff_activate;\n\t\t\t\tpriv = p->priv;\n\t\t\t\tpriv->rdma_device = dev_list[i];\n\t\t\t\tpriv->port_num = port_num;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tibv_free_device_list(dev_list);\n\treturn p;\n}\n\nint\nrdmasniff_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tstruct ibv_device **dev_list;\n\tint numdev;\n\tint i;\n\tint ret = 0;\n\n\tdev_list = ibv_get_device_list(&numdev);\n\tif (!dev_list) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < numdev; ++i) {\n\t\t/*\n\t\t * XXX - do the notions of \"up\", \"running\", or\n\t\t * \"connected\" apply here?\n\t\t */\n\t\tif (!pcapint_add_dev(devlistp, dev_list[i]->name, 0, \"RDMA sniffer\", err_str)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tibv_free_device_list(dev_list);\n\treturn ret;\n}\n"
        },
        {
          "name": "pcap-rdmasniff.h",
          "type": "blob",
          "size": 0.13671875,
          "content": "pcap_t *rdmasniff_create(const char *device, char *ebuf, int *is_ours);\nint rdmasniff_findalldevs(pcap_if_list_t *devlistp, char *err_str);\n"
        },
        {
          "name": "pcap-rpcap.c",
          "type": "blob",
          "size": 109.5888671875,
          "content": "/*\n * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino, CACE Technologies\n * nor the names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n#include \"ftmacros.h\"\n#include \"diag-control.h\"\n\n#include <string.h>\t\t/* for strlen(), ... */\n#include <stdlib.h>\t\t/* for malloc(), free(), ... */\n#include <stdarg.h>\t\t/* for functions with variable number of arguments */\n#include <errno.h>\t\t/* for the errno variable */\n#include <limits.h>\t\t/* for INT_MAX */\n#include \"sockutils.h\"\n#include \"pcap-int.h\"\n#include \"pcap-util.h\"\n#include \"rpcap-protocol.h\"\n#include \"pcap-rpcap.h\"\n\n#ifdef _WIN32\n#include \"charconv.h\"\t\t/* for utf_8_to_acp_truncated() */\n#endif\n\n#ifdef HAVE_OPENSSL\n#include \"sslutils.h\"\n#endif\n\n/*\n * This file contains the pcap module for capturing from a remote machine's\n * interfaces using the RPCAP protocol.\n *\n * WARNING: All the RPCAP functions that are allowed to return a buffer\n * containing the error description can return max PCAP_ERRBUF_SIZE characters.\n * However there is no guarantees that the string will be zero-terminated.\n * Best practice is to define the errbuf variable as a char of size\n * 'PCAP_ERRBUF_SIZE+1' and to insert manually a NULL character at the end\n * of the buffer. This will guarantee that no buffer overflows occur even\n * if we use the printf() to show the error on the screen.\n *\n * XXX - actually, null-terminating the error string is part of the\n * contract for the pcap API; if there's any place in the pcap code\n * that doesn't guarantee null-termination, even at the expense of\n * cutting the message short, that's a bug and needs to be fixed.\n */\n\n#define PCAP_STATS_STANDARD\t0\t/* Used by pcap_stats_rpcap to see if we want standard or extended statistics */\n#ifdef _WIN32\n#define PCAP_STATS_EX\t\t1\t/* Used by pcap_stats_rpcap to see if we want standard or extended statistics */\n#endif\n\n/*\n * \\brief Keeps a list of all the opened connections in the active mode.\n *\n * This structure defines a linked list of items that are needed to keep the info required to\n * manage the active mode.\n * In other words, when a new connection in active mode starts, this structure is updated so that\n * it reflects the list of active mode connections currently opened.\n * This structure is required by findalldevs() and open_remote() to see if they have to open a new\n * control connection toward the host, or they already have a control connection in place.\n */\nstruct activehosts\n{\n\tstruct sockaddr_storage host;\n\tPCAP_SOCKET sockctrl;\n\tSSL *ssl;\n\tuint8_t protocol_version;\n\tint byte_swapped;\n\tstruct activehosts *next;\n};\n\n/* Keeps a list of all the opened connections in the active mode. */\nstatic struct activehosts *activeHosts;\n\n/*\n * Keeps the main socket identifier when we want to accept a new remote\n * connection (active mode only).\n * See the documentation of pcap_remoteact_accept() and\n * pcap_remoteact_cleanup() for more details.\n */\nstatic PCAP_SOCKET sockmain;\nstatic SSL *ssl_main;\n\n/*\n * Private data for capturing remotely using the rpcap protocol.\n */\nstruct pcap_rpcap {\n\t/*\n\t * This is '1' if we're the network client; it is needed by several\n\t * functions (such as pcap_setfilter()) to know whether they have\n\t * to use the socket or have to open the local adapter.\n\t */\n\tint rmt_clientside;\n\n\tPCAP_SOCKET rmt_sockctrl;\t/* socket ID of the socket used for the control connection */\n\tPCAP_SOCKET rmt_sockdata;\t/* socket ID of the socket used for the data connection */\n\tSSL *ctrl_ssl, *data_ssl;\t/* optional transport of rmt_sockctrl and rmt_sockdata via TLS */\n\tint rmt_flags;\t\t\t/* we have to save flags, since they are passed by the pcap_open_live(), but they are used by the pcap_startcapture() */\n\tint rmt_capstarted;\t\t/* 'true' if the capture is already started (needed to know if we have to call the pcap_startcapture() */\n\tchar *currentfilter;\t\t/* Pointer to a buffer (allocated at run-time) that stores the current filter. Needed when flag PCAP_OPENFLAG_NOCAPTURE_RPCAP is turned on. */\n\n\tuint8_t protocol_version;\t/* negotiated protocol version */\n\tuint8_t uses_ssl;\t\t/* User asked for rpcaps scheme */\n\tint byte_swapped;\t\t/* Server byte order is swapped from ours */\n\n\tunsigned int TotNetDrops;\t/* keeps the number of packets that have been dropped by the network */\n\n\t/*\n\t * This keeps the number of packets that have been received by the\n\t * application.\n\t *\n\t * Packets dropped by the kernel buffer are not counted in this\n\t * variable. It is always equal to (TotAccepted - TotDrops),\n\t * except for the case of remote capture, in which we have also\n\t * packets in flight, i.e. that have been transmitted by the remote\n\t * host, but that have not been received (yet) from the client.\n\t * In this case, (TotAccepted - TotDrops - TotNetDrops) gives a\n\t * wrong result, since this number does not corresponds always to\n\t * the number of packet received by the application. For this reason,\n\t * in the remote capture we need another variable that takes into\n\t * account of the number of packets actually received by the\n\t * application.\n\t */\n\tunsigned int TotCapt;\n\n\tstruct pcap_stat stat;\n\t/* XXX */\n\tstruct pcap *next;\t\t/* list of open pcaps that need stuff cleared on close */\n};\n\n/****************************************************\n *                                                  *\n * Locally defined functions                        *\n *                                                  *\n ****************************************************/\nstatic struct pcap_stat *rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode);\nstatic int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog);\nstatic int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog);\nstatic int pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog);\nstatic void pcap_save_current_filter_rpcap(pcap_t *fp, const char *filter);\nstatic int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog);\nstatic int pcap_setsampling_remote(pcap_t *fp);\nstatic int pcap_startcapture_remote(pcap_t *fp);\nstatic int rpcap_recv_msg_header(PCAP_SOCKET sock, SSL *, struct rpcap_header *header, char *errbuf);\nstatic int rpcap_check_msg_ver(PCAP_SOCKET sock, SSL *, uint8_t expected_ver, struct rpcap_header *header, char *errbuf);\nstatic int rpcap_check_msg_type(PCAP_SOCKET sock, SSL *, uint8_t request_type, struct rpcap_header *header, uint16_t *errcode, char *errbuf);\nstatic int rpcap_process_msg_header(PCAP_SOCKET sock, SSL *, uint8_t ver, uint8_t request_type, struct rpcap_header *header, char *errbuf);\nstatic int rpcap_recv(PCAP_SOCKET sock, SSL *, void *buffer, size_t toread, uint32_t *plen, char *errbuf);\nstatic void rpcap_msg_err(PCAP_SOCKET sockctrl, SSL *, uint32_t plen, char *remote_errbuf);\nstatic int rpcap_discard(PCAP_SOCKET sock, SSL *, uint32_t len, char *errbuf);\nstatic int rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t size);\n\n/****************************************************\n *                                                  *\n * Function bodies                                  *\n *                                                  *\n ****************************************************/\n\n/*\n * This function translates (i.e. de-serializes) a 'rpcap_sockaddr'\n * structure from the network byte order to a 'sockaddr_in\" or\n * 'sockaddr_in6' structure in the host byte order.\n *\n * It accepts an 'rpcap_sockaddr' structure as it is received from the\n * network, and checks the address family field against various values\n * to see whether it looks like an IPv4 address, an IPv6 address, or\n * neither of those.  It checks for multiple values in order to try\n * to handle older rpcap daemons that sent the native OS's 'sockaddr_in'\n * or 'sockaddr_in6' structures over the wire with some members\n * byte-swapped, and to handle the fact that AF_INET6 has different\n * values on different OSes.\n *\n * For IPv4 addresses, it converts the address family to host byte\n * order from network byte order and puts it into the structure,\n * sets the length if a sockaddr structure has a length, converts the\n * port number to host byte order from network byte order and puts\n * it into the structure, copies over the IPv4 address, and zeroes\n * out the zero padding.\n *\n * For IPv6 addresses, it converts the address family to host byte\n * order from network byte order and puts it into the structure,\n * sets the length if a sockaddr structure has a length, converts the\n * port number and flow information to host byte order from network\n * byte order and puts them into the structure, copies over the IPv6\n * address, and converts the scope ID to host byte order from network\n * byte order and puts it into the structure.\n *\n * The function will allocate the 'sockaddrout' variable according to the\n * address family in use. In case the address does not belong to the\n * AF_INET nor AF_INET6 families, 'sockaddrout' is not allocated and a\n * NULL pointer is returned.  This usually happens because that address\n * does not exist on the other host, or is of an address family other\n * than AF_INET or AF_INET6, so the RPCAP daemon sent a 'sockaddr_storage'\n * structure containing all 'zero' values.\n *\n * Older RPCAPDs sent the addresses over the wire in the OS's native\n * structure format.  For most OSes, this looks like the over-the-wire\n * format, but might have a different value for AF_INET6 than the value\n * on the machine receiving the reply.  For OSes with the newer BSD-style\n * sockaddr structures, this has, instead of a 2-byte address family,\n * a 1-byte structure length followed by a 1-byte address family.  The\n * RPCAPD code would put the address family in network byte order before\n * sending it; that would set it to 0 on a little-endian machine, as\n * htons() of any value between 1 and 255 would result in a value > 255,\n * with its lower 8 bits zero, so putting that back into a 1-byte field\n * would set it to 0.\n *\n * Therefore, for older RPCAPDs running on an OS with newer BSD-style\n * sockaddr structures, the family field, if treated as a big-endian\n * (network byte order) 16-bit field, would be:\n *\n *\t(length << 8) | family if sent by a big-endian machine\n *\t(length << 8) if sent by a little-endian machine\n *\n * For current RPCAPDs, and for older RPCAPDs running on an OS with\n * older BSD-style sockaddr structures, the family field, if treated\n * as a big-endian 16-bit field, would just contain the family.\n *\n * \\param sockaddrin: a 'rpcap_sockaddr' pointer to the variable that has\n * to be de-serialized.\n *\n * \\param sockaddrout: a 'sockaddr_storage' pointer to the variable that will contain\n * the de-serialized data. The structure returned can be either a 'sockaddr_in' or 'sockaddr_in6'.\n * This variable will be allocated automatically inside this function.\n *\n * \\param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)\n * that will contain the error message (in case there is one).\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred. Basically, the error\n * can be only the fact that the malloc() failed to allocate memory.\n * The error message is returned in the 'errbuf' variable, while the deserialized address\n * is returned into the 'sockaddrout' variable.\n *\n * \\warning This function supports only AF_INET and AF_INET6 address families.\n *\n * \\warning The sockaddrout (if not NULL) must be deallocated by the user.\n */\n\n/*\n * Possible IPv4 family values other than the designated over-the-wire value,\n * which is 2 (because everybody, except for Haiku uses 2 for AF_INET,\n * and Haiku has probably never run the old rpcapd code that put address\n * structures directly on the wire, rather than the new rpcapd code\n * that serializes addresses, using 2 for AF_INET).\n */\n#define SOCKADDR_IN_LEN\t\t16\t/* length of struct sockaddr_in */\n#define SOCKADDR_IN6_LEN\t28\t/* length of struct sockaddr_in6 */\n#define NEW_BSD_AF_INET_BE\t((SOCKADDR_IN_LEN << 8) | 2)\n#define NEW_BSD_AF_INET_LE\t(SOCKADDR_IN_LEN << 8)\n\n/*\n * Possible IPv6 family values other than the designated over-the-wire value,\n * which is 23 (because that's what Windows uses, and most RPCAP servers\n * out there are probably running Windows, as WinPcap includes the server\n * but few if any UN*Xes build and ship it).\n *\n * The new BSD sockaddr structure format was in place before 4.4-Lite, so\n * all the free-software BSDs use it.\n */\n#define NEW_BSD_AF_INET6_BSD_BE\t\t((SOCKADDR_IN6_LEN << 8) | 24)\t/* NetBSD, OpenBSD, BSD/OS */\n#define NEW_BSD_AF_INET6_FREEBSD_BE\t((SOCKADDR_IN6_LEN << 8) | 28)\t/* FreeBSD, DragonFly BSD */\n#define NEW_BSD_AF_INET6_DARWIN_BE\t((SOCKADDR_IN6_LEN << 8) | 30)\t/* macOS, iOS, anything else Darwin-based */\n#define NEW_BSD_AF_INET6_LE\t\t(SOCKADDR_IN6_LEN << 8)\n#define LINUX_AF_INET6\t\t\t10\n#define HPUX_AF_INET6\t\t\t22\n#define AIX_AF_INET6\t\t\t24\n#define SOLARIS_AF_INET6\t\t26\n\nstatic int\nrpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr **sockaddrout, char *errbuf)\n{\n\t/* Warning: we support only AF_INET and AF_INET6 */\n\tswitch (ntohs(sockaddrin->family))\n\t{\n\tcase RPCAP_AF_INET:\n\tcase NEW_BSD_AF_INET_BE:\n\tcase NEW_BSD_AF_INET_LE:\n\t\t{\n\t\tstruct rpcap_sockaddr_in *sockaddrin_ipv4;\n\t\tstruct sockaddr_in *sockaddrout_ipv4;\n\n\t\t(*sockaddrout) = (struct sockaddr *) malloc(sizeof(struct sockaddr_in));\n\t\tif ((*sockaddrout) == NULL)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tsockaddrin_ipv4 = (struct rpcap_sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct sockaddr_in *) (*sockaddrout);\n\t\tsockaddrout_ipv4->sin_family = AF_INET;\n\t\tsockaddrout_ipv4->sin_port = ntohs(sockaddrin_ipv4->port);\n\t\tmemcpy(&sockaddrout_ipv4->sin_addr, &sockaddrin_ipv4->addr, sizeof(sockaddrout_ipv4->sin_addr));\n\t\tmemset(sockaddrout_ipv4->sin_zero, 0, sizeof(sockaddrout_ipv4->sin_zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase RPCAP_AF_INET6:\n\tcase NEW_BSD_AF_INET6_BSD_BE:\n\tcase NEW_BSD_AF_INET6_FREEBSD_BE:\n\tcase NEW_BSD_AF_INET6_DARWIN_BE:\n\tcase NEW_BSD_AF_INET6_LE:\n\tcase LINUX_AF_INET6:\n\tcase HPUX_AF_INET6:\n\tcase AIX_AF_INET6:\n\tcase SOLARIS_AF_INET6:\n\t\t{\n\t\tstruct rpcap_sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct sockaddr_in6 *sockaddrout_ipv6;\n\n\t\t(*sockaddrout) = (struct sockaddr *) malloc(sizeof(struct sockaddr_in6));\n\t\tif ((*sockaddrout) == NULL)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tsockaddrin_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct sockaddr_in6 *) (*sockaddrout);\n\t\tsockaddrout_ipv6->sin6_family = AF_INET6;\n\t\tsockaddrout_ipv6->sin6_port = ntohs(sockaddrin_ipv6->port);\n\t\tsockaddrout_ipv6->sin6_flowinfo = ntohl(sockaddrin_ipv6->flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->sin6_addr, &sockaddrin_ipv6->addr, sizeof(sockaddrout_ipv6->sin6_addr));\n\t\tsockaddrout_ipv6->sin6_scope_id = ntohl(sockaddrin_ipv6->scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\n\tdefault:\n\t\t/*\n\t\t * It is neither AF_INET nor AF_INET6 (or, if the OS doesn't\n\t\t * support AF_INET6, it's not AF_INET).\n\t\t */\n\t\t*sockaddrout = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n * This function reads a packet from the network socket.  It does not\n * deliver the packet to a pcap_dispatch()/pcap_loop() callback (hence\n * the \"nocb\" string into its name).\n *\n * This function is called by pcap_read_rpcap().\n *\n * WARNING: By choice, this function does not make use of semaphores. A smarter\n * implementation should put a semaphore into the data thread, and a signal will\n * be raised as soon as there is data into the socket buffer.\n * However this is complicated and it does not bring any advantages when reading\n * from the network, in which network delays can be much more important than\n * these optimizations. Therefore, we chose the following approach:\n * - the 'timeout' chosen by the user is split in two (half on the server side,\n * with the usual meaning, and half on the client side)\n * - this function checks for packets; if there are no packets, it waits for\n * timeout/2 and then it checks again. If packets are still missing, it returns,\n * otherwise it reads packets.\n */\nstatic int pcap_read_nocb_remote(pcap_t *p, struct pcap_pkthdr *pkt_header, u_char **pkt_data)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header *header;\t\t/* general header according to the RPCAP format */\n\tstruct rpcap_pkthdr *net_pkt_header;\t/* header of the packet, from the message */\n\tu_char *net_pkt_data;\t\t\t/* packet data from the message */\n\tuint32_t plen;\n\tint retval = 0;\t\t\t\t/* generic return value */\n\tint msglen;\n\n\t/* Structures needed for the select() call */\n\tstruct timeval tv;\t\t\t/* maximum time the select() can block waiting for data */\n\tfd_set rfds;\t\t\t\t/* set of socket descriptors we have to check */\n\n\t/*\n\t * Define the packet buffer timeout, to be used in the select()\n\t * 'timeout', in pcap_t, is in milliseconds; we have to convert it into sec and microsec\n\t */\n\ttv.tv_sec = p->opt.timeout / 1000;\n\ttv.tv_usec = (suseconds_t)((p->opt.timeout - tv.tv_sec * 1000) * 1000);\n\n#ifdef HAVE_OPENSSL\n\t/* Check if we still have bytes available in the last decoded TLS record.\n\t * If that's the case, we know SSL_read will not block. */\n\tretval = pr->data_ssl && SSL_pending(pr->data_ssl) > 0;\n#endif\n\tif (! retval)\n\t{\n\t\t/* Watch out sockdata to see if it has input */\n\t\tFD_ZERO(&rfds);\n\n\t\t/*\n\t\t * 'fp->rmt_sockdata' has always to be set before calling the select(),\n\t\t * since it is cleared by the select()\n\t\t */\n\t\tFD_SET(pr->rmt_sockdata, &rfds);\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\tretval = 1;\n#else\n\t\tretval = select((int) pr->rmt_sockdata + 1, &rfds, NULL, NULL, &tv);\n#endif\n\n\t\tif (retval == -1)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == EINTR)\n\t\t\t{\n\t\t\t\t/* Interrupted. */\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\t\t\tsock_geterrmsg(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"select() failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* There is no data waiting, so return '0' */\n\tif (retval == 0)\n\t\treturn 0;\n\n\t/*\n\t * We have to define 'header' as a pointer to a larger buffer,\n\t * because in case of UDP we have to read all the message within a single call\n\t */\n\theader = (struct rpcap_header *) p->buffer;\n\tnet_pkt_header = (struct rpcap_pkthdr *) ((char *)p->buffer + sizeof(struct rpcap_header));\n\tnet_pkt_data = p->buffer + sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr);\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t{\n\t\t/* Read the entire message from the network */\n\t\tmsglen = sock_recv_dgram(pr->rmt_sockdata, pr->data_ssl, p->buffer,\n\t\t    p->bufsize, p->errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (msglen == -1)\n\t\t{\n\t\t\t/* Network error. */\n\t\t\treturn -1;\n\t\t}\n\t\tif (msglen == -3)\n\t\t{\n\t\t\t/* Interrupted receive. */\n\t\t\treturn 0;\n\t\t}\n\t\tif ((size_t)msglen < sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * Message is shorter than an rpcap header.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"UDP packet message is shorter than an rpcap header\");\n\t\t\treturn -1;\n\t\t}\n\t\tplen = ntohl(header->plen);\n\t\tif ((size_t)msglen < sizeof(struct rpcap_header) + plen)\n\t\t{\n\t\t\t/*\n\t\t\t * Message is shorter than the header claims it\n\t\t\t * is.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"UDP packet message is shorter than its rpcap header claims\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint status;\n\n\t\tif ((size_t)p->cc < sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * We haven't read any of the packet header yet.\n\t\t\t * The size we should get is the size of the\n\t\t\t * packet header.\n\t\t\t */\n\t\t\tstatus = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header));\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\t/* Network error. */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -3)\n\t\t\t{\n\t\t\t\t/* Interrupted receive. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We have the header, so we know how long the\n\t\t * message payload is.  The size we should get\n\t\t * is the size of the packet header plus the\n\t\t * size of the payload.\n\t\t */\n\t\tplen = ntohl(header->plen);\n\t\tif (plen > p->bufsize - sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * This is bigger than the largest\n\t\t\t * record we'd expect.  (We do it by\n\t\t\t * subtracting in order to avoid an\n\t\t\t * overflow.)\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Server sent us a message larger than the largest expected packet message\");\n\t\t\treturn -1;\n\t\t}\n\t\tstatus = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header) + plen);\n\t\tif (status == -1)\n\t\t{\n\t\t\t/* Network error. */\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == -3)\n\t\t{\n\t\t\t/* Interrupted receive. */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We have the entire message; reset the buffer pointer\n\t\t * and count, as the next read should start a new\n\t\t * message.\n\t\t */\n\t\tp->bp = p->buffer;\n\t\tp->cc = 0;\n\t}\n\n\t/*\n\t * We have the entire message.\n\t */\n\theader->plen = plen;\n\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (rpcap_check_msg_ver(pr->rmt_sockdata, pr->data_ssl, pr->protocol_version,\n\t    header, p->errbuf) == -1)\n\t{\n\t\treturn 0;\t/* Return 'no packets received' */\n\t}\n\n\t/*\n\t * Is this a RPCAP_MSG_PACKET message?\n\t */\n\tif (header->type != RPCAP_MSG_PACKET)\n\t{\n\t\treturn 0;\t/* Return 'no packets received' */\n\t}\n\n\tif (ntohl(net_pkt_header->caplen) > plen)\n\t{\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Packet's captured data goes past the end of the received packet message.\");\n\t\treturn -1;\n\t}\n\n\t/* Fill in packet header */\n\tpkt_header->caplen = ntohl(net_pkt_header->caplen);\n\tpkt_header->len = ntohl(net_pkt_header->len);\n\tpkt_header->ts.tv_sec = ntohl(net_pkt_header->timestamp_sec);\n\tpkt_header->ts.tv_usec = ntohl(net_pkt_header->timestamp_usec);\n\n\t/* Supply a pointer to the beginning of the packet data */\n\t*pkt_data = net_pkt_data;\n\n\t/*\n\t * I don't update the counter of the packets dropped by the network since we're using TCP,\n\t * therefore no packets are dropped. Just update the number of packets received correctly\n\t */\n\tpr->TotCapt++;\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t{\n\t\tunsigned int npkt;\n\n\t\t/* We're using UDP, so we need to update the counter of the packets dropped by the network */\n\t\tnpkt = ntohl(net_pkt_header->npkt);\n\n\t\tif (pr->TotCapt != npkt)\n\t\t{\n\t\t\tpr->TotNetDrops += (npkt - pr->TotCapt);\n\t\t\tpr->TotCapt = npkt;\n\t\t}\n\t}\n\n\t/* Packet read successfully */\n\treturn 1;\n}\n\n/*\n * This function reads a packet from the network socket.\n *\n * This function relies on the pcap_read_nocb_remote to deliver packets. The\n * difference, here, is that as soon as a packet is read, it is delivered\n * to the application by means of a callback function.\n */\nstatic int pcap_read_rpcap(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct pcap_pkthdr pkt_header;\n\tu_char *pkt_data;\n\tint n = 0;\n\tint ret;\n\n\t/*\n\t * If this is client-side, and we haven't already started\n\t * the capture, start it now.\n\t */\n\tif (pr->rmt_clientside)\n\t{\n\t\t/* We are on an remote capture */\n\t\tif (!pr->rmt_capstarted)\n\t\t{\n\t\t\t/*\n\t\t\t * The capture isn't started yet, so try to\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif (pcap_startcapture_remote(p))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(cnt))\n\t\tcnt = INT_MAX;\n\n\twhile (n < cnt || PACKET_COUNT_IS_UNLIMITED(cnt))\n\t{\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it\n\t\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t\t * that we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t}\n\n\t\t/*\n\t\t * Read some packets.\n\t\t */\n\t\tret = pcap_read_nocb_remote(p, &pkt_header, &pkt_data);\n\t\tif (ret == 1)\n\t\t{\n\t\t\t/*\n\t\t\t * We got a packet.\n\t\t\t *\n\t\t\t * Do whatever post-processing is necessary, hand\n\t\t\t * it to the callback, and count it so we can\n\t\t\t * return the count.\n\t\t\t */\n\t\t\tpcapint_post_process(p->linktype, pr->byte_swapped,\n\t\t\t    &pkt_header, pkt_data);\n\t\t\t(*callback)(user, &pkt_header, pkt_data);\n\t\t\tn++;\n\t\t}\n\t\telse if (ret == -1)\n\t\t{\n\t\t\t/* Error. */\n\t\t\treturn ret;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * No packet; this could mean that we timed\n\t\t\t * out, or that we got interrupted, or that\n\t\t\t * we got a bad packet.\n\t\t\t *\n\t\t\t * Were we told to break out of the loop?\n\t\t\t */\n\t\t\tif (p->break_loop) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t\t}\n\t\t\t/* No - return the number of packets we've processed. */\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}\n\n/*\n * This function sends a CLOSE command to the capture server if we're in\n * passive mode and an ENDCAP command to the capture server if we're in\n * active mode.\n *\n * It is called when the user calls pcap_close().  It sends a command\n * to our peer that says 'ok, let's stop capturing'.\n *\n * WARNING: Since we're closing the connection, we do not check for errors.\n */\nstatic void pcap_cleanup_rpcap(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct activehosts *temp;\t\t/* temp var needed to scan the host list chain, to detect if we're in active mode */\n\tint active = 0;\t\t\t\t/* active mode or not? */\n\n\t/* detect if we're in active mode */\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tif (temp->sockctrl == pr->rmt_sockctrl)\n\t\t{\n\t\t\tactive = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\tif (!active)\n\t{\n\t\trpcap_createhdr(&header, pr->protocol_version,\n\t\t    RPCAP_MSG_CLOSE, 0, 0);\n\n\t\t/*\n\t\t * Send the close request; don't report any errors, as\n\t\t * we're closing this pcap_t, and have no place to report\n\t\t * the error.  No reply is sent to this message.\n\t\t */\n\t\t(void)sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t\t    sizeof(struct rpcap_header), NULL, 0);\n\t}\n\telse\n\t{\n\t\trpcap_createhdr(&header, pr->protocol_version,\n\t\t    RPCAP_MSG_ENDCAP_REQ, 0, 0);\n\n\t\t/*\n\t\t * Send the end capture request; don't report any errors,\n\t\t * as we're closing this pcap_t, and have no place to\n\t\t * report the error.\n\t\t */\n\t\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t\t    sizeof(struct rpcap_header), NULL, 0) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Wait for the answer; don't report any errors,\n\t\t\t * as we're closing this pcap_t, and have no\n\t\t\t * place to report the error.\n\t\t\t */\n\t\t\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl,\n\t\t\t    pr->protocol_version, RPCAP_MSG_ENDCAP_REQ,\n\t\t\t    &header, NULL) == 0)\n\t\t\t{\n\t\t\t\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl,\n\t\t\t\t    header.plen, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pr->rmt_sockdata)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->data_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the data socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->data_ssl);\n\t\t\tpr->data_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockdata, NULL, 0);\n\t\tpr->rmt_sockdata = 0;\n\t}\n\n\tif ((!active) && (pr->rmt_sockctrl))\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->ctrl_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the control socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->ctrl_ssl);\n\t\t\tpr->ctrl_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockctrl, NULL, 0);\n\t}\n\n\tpr->rmt_sockctrl = 0;\n\tpr->ctrl_ssl = NULL;\n\n\tif (pr->currentfilter)\n\t{\n\t\tfree(pr->currentfilter);\n\t\tpr->currentfilter = NULL;\n\t}\n\n\tpcapint_cleanup_live_common(fp);\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n}\n\n/*\n * This function retrieves network statistics from our peer;\n * it provides only the standard statistics.\n */\nstatic int pcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_stat *retval;\n\n\tretval = rpcap_stats_rpcap(p, ps, PCAP_STATS_STANDARD);\n\n\tif (retval)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n#ifdef _WIN32\n/*\n * This function retrieves network statistics from our peer;\n * it provides the additional statistics supported by pcap_stats_ex().\n */\nstatic struct pcap_stat *pcap_stats_ex_rpcap(pcap_t *p, int *pcap_stat_size)\n{\n\t*pcap_stat_size = sizeof (p->stat);\n\n\t/* PCAP_STATS_EX (third param) means 'extended pcap_stats()' */\n\treturn (rpcap_stats_rpcap(p, &(p->stat), PCAP_STATS_EX));\n}\n#endif\n\n/*\n * This function retrieves network statistics from our peer.  It\n * is used by the two previous functions.\n *\n * It can be called in two modes:\n * - PCAP_STATS_STANDARD: if we want just standard statistics (i.e.,\n *   for pcap_stats())\n * - PCAP_STATS_EX: if we want extended statistics (i.e., for\n *   pcap_stats_ex())\n *\n * This 'mode' parameter is needed because in pcap_stats() the variable that\n * keeps the statistics is allocated by the user. On Windows, this structure\n * has been extended in order to keep new stats. However, if the user has a\n * smaller structure and it passes it to pcap_stats(), this function will\n * try to fill in more data than the size of the structure, so that memory\n * after the structure will be overwritten.\n *\n * So, we need to know it we have to copy just the standard fields, or the\n * extended fields as well.\n *\n * In case we want to copy the extended fields as well, the problem of\n * memory overflow no longer exists because the structure that's filled\n * in is part of the pcap_t, so that it can be guaranteed to be large\n * enough for the additional statistics.\n *\n * \\param p: the pcap_t structure related to the current instance.\n *\n * \\param ps: a pointer to a 'pcap_stat' structure, needed for compatibility\n * with pcap_stat(), where the structure is allocated by the user. In case\n * of pcap_stats_ex(), this structure and the function return value point\n * to the same variable.\n *\n * \\param mode: one of PCAP_STATS_STANDARD or PCAP_STATS_EX.\n *\n * \\return The structure that keeps the statistics, or NULL in case of error.\n * The error string is placed in the pcap_t structure.\n */\nstatic struct pcap_stat *rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct rpcap_stats netstats;\t\t/* statistics sent on the network */\n\tuint32_t plen;\t\t\t\t/* data remaining in the message */\n\n#ifdef _WIN32\n\tif (mode != PCAP_STATS_STANDARD && mode != PCAP_STATS_EX)\n#else\n\tif (mode != PCAP_STATS_STANDARD)\n#endif\n\t{\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid stats mode %d\", mode);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If the capture has not yet started, we cannot request statistics\n\t * for the capture from our peer, so we return 0 for all statistics,\n\t * as nothing's been seen yet.\n\t */\n\tif (!pr->rmt_capstarted)\n\t{\n\t\tps->ps_drop = 0;\n\t\tps->ps_ifdrop = 0;\n\t\tps->ps_recv = 0;\n#ifdef _WIN32\n\t\tif (mode == PCAP_STATS_EX)\n\t\t{\n\t\t\tps->ps_capt = 0;\n\t\t\tps->ps_sent = 0;\n\t\t\tps->ps_netdrop = 0;\n\t\t}\n#endif /* _WIN32 */\n\n\t\treturn ps;\n\t}\n\n\trpcap_createhdr(&header, pr->protocol_version,\n\t    RPCAP_MSG_STATS_REQ, 0, 0);\n\n\t/* Send the PCAP_STATS command */\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t    sizeof(struct rpcap_header), p->errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\treturn NULL;\t\t/* Unrecoverable network error */\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_STATS_REQ, &header, p->errbuf) == -1)\n\t\treturn NULL;\t\t/* Error */\n\n\tplen = header.plen;\n\n\t/* Read the reply body */\n\tif (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&netstats,\n\t    sizeof(struct rpcap_stats), &plen, p->errbuf) == -1)\n\t\tgoto error;\n\n\tps->ps_drop = ntohl(netstats.krnldrop);\n\tps->ps_ifdrop = ntohl(netstats.ifdrop);\n\tps->ps_recv = ntohl(netstats.ifrecv);\n#ifdef _WIN32\n\tif (mode == PCAP_STATS_EX)\n\t{\n\t\tps->ps_capt = pr->TotCapt;\n\t\tps->ps_netdrop = pr->TotNetDrops;\n\t\tps->ps_sent = ntohl(netstats.svrcapt);\n\t}\n#endif /* _WIN32 */\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, p->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\treturn ps;\n\nerror:\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n\treturn NULL;\n}\n\n/*\n * This function returns the entry in the list of active hosts for this\n * active connection (active mode only), or NULL if there is no\n * active connection or an error occurred.  It is just for internal\n * use.\n *\n * \\param host: a string that keeps the host name of the host for which we\n * want to get the socket ID for that active connection.\n *\n * \\param error: a pointer to an int that is set to 1 if an error occurred\n * and 0 otherwise.\n *\n * \\param errbuf: a pointer to a user-allocated buffer (of size\n * PCAP_ERRBUF_SIZE) that will contain the error message (in case\n * there is one).\n *\n * \\return the entry for this host in the list of active connections\n * if found, NULL if it's not found or there's an error.\n */\nstatic struct activehosts *\nrpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t/* temp var needed to scan the host list chain */\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n\n\t/* retrieve the network address corresponding to 'host' */\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\taddrinfo = sock_initaddress(host, NULL, &hints, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (addrinfo == NULL)\n\t{\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\n\ttemp = activeHosts;\n\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/*\n\t * The host for which you want to get the socket ID does not have an\n\t * active connection.\n\t */\n\t*error = 0;\n\treturn NULL;\n}\n\n/*\n * This function starts a remote capture.\n *\n * This function is required since the RPCAP protocol decouples the 'open'\n * from the 'start capture' functions.\n * This function takes all the parameters needed (which have been stored\n * into the pcap_t structure) and sends them to the server.\n *\n * \\param fp: the pcap_t descriptor of the device currently open.\n *\n * \\return '0' if everything is fine, '-1' otherwise. The error message\n * (if one) is returned into the 'errbuf' field of the pcap_t structure.\n */\nstatic int pcap_startcapture_remote(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tuint16_t portdata = 0;\t\t\t/* temp variable needed to keep the network port for the data connection */\n\tuint32_t plen;\n\tint active = 0;\t\t\t\t/* '1' if we're in active mode */\n\tstruct activehosts *temp;\t\t/* temp var needed to scan the host list chain, to detect if we're in active mode */\n\tchar host[INET6_ADDRSTRLEN + 1];\t/* numeric name of the other host */\n\n\t/* socket-related variables*/\n\tstruct addrinfo hints;\t\t\t/* temp, needed to open a socket connection */\n\tstruct addrinfo *addrinfo;\t\t/* temp, needed to open a socket connection */\n\tPCAP_SOCKET sockdata = 0;\t\t/* socket descriptor of the data connection */\n\tstruct sockaddr_storage saddr;\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\tsocklen_t saddrlen;\t\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\tint ai_family;\t\t\t\t/* temp, keeps the address family used by the control connection */\n\tstruct sockaddr_in *sin4;\n\tstruct sockaddr_in6 *sin6;\n\n\t/* RPCAP-related variables*/\n\tstruct rpcap_header header;\t\t\t/* header of the RPCAP packet */\n\tstruct rpcap_startcapreq *startcapreq;\t\t/* start capture request message */\n\tstruct rpcap_startcapreply startcapreply;\t/* start capture reply message */\n\n\t/* Variables related to the buffer setting */\n\tint res;\n\tsocklen_t itemp;\n\tint sockbufsize = 0;\n\tuint32_t server_sockbufsize;\n\n\t// Take the opportunity to clear pr->data_ssl before any goto error,\n\t// as it seems p->priv is not zeroed after its malloced.\n\t// XXX - it now should be, as it's allocated by pcap_alloc_pcap_t(),\n\t// which does a calloc().\n\tpr->data_ssl = NULL;\n\n\t/*\n\t * Let's check if sampling has been required.\n\t * If so, let's set it first\n\t */\n\tif (pcap_setsampling_remote(fp) != 0)\n\t\treturn -1;\n\n\t/* detect if we're in active mode */\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tif (temp->sockctrl == pr->rmt_sockctrl)\n\t\t{\n\t\t\tactive = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\taddrinfo = NULL;\n\n\t/*\n\t * Gets the complete sockaddr structure used in the ctrl connection\n\t * This is needed to get the address family of the control socket\n\t * Tip: I cannot save the ai_family of the ctrl sock in the pcap_t struct,\n\t * since the ctrl socket can already be open in case of active mode;\n\t * so I would have to call getpeername() anyway\n\t */\n\tsaddrlen = sizeof(struct sockaddr_storage);\n\tif (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t{\n\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"getsockname() failed\");\n\t\tgoto error_nodiscard;\n\t}\n\tai_family = ((struct sockaddr_storage *) &saddr)->ss_family;\n\n\t/* Get the numeric address of the remote host we are connected to */\n\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, host,\n\t\tsizeof(host), NULL, 0, NI_NUMERICHOST))\n\t{\n\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"getnameinfo() failed\");\n\t\tgoto error_nodiscard;\n\t}\n\n\t/*\n\t * Data connection is opened by the server toward the client if:\n\t * - we're using TCP, and the user wants us to be in active mode\n\t * - we're using UDP\n\t */\n\tif ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\t/*\n\t\t * We have to create a new socket to receive packets\n\t\t * We have to do that immediately, since we have to tell the other\n\t\t * end which network port we picked up\n\t\t */\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t/* TEMP addrinfo is NULL in case of active */\n\t\thints.ai_family = ai_family;\t/* Use the same address family of the control socket */\n\t\thints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;\n\t\thints.ai_flags = AI_PASSIVE;\t/* Data connection is opened by the server toward the client */\n\n\t\t/* Let's the server pick up a free network port for us */\n\t\taddrinfo = sock_initaddress(NULL, NULL, &hints, fp->errbuf,\n\t\t    PCAP_ERRBUF_SIZE);\n\t\tif (addrinfo == NULL)\n\t\t\tgoto error_nodiscard;\n\n\t\tif ((sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER,\n\t\t\t1 /* max 1 connection in queue */, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error_nodiscard;\n\n\t\t/* addrinfo is no longer used */\n\t\tfreeaddrinfo(addrinfo);\n\t\taddrinfo = NULL;\n\n\t\t/* get the complete sockaddr structure used in the data connection */\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getsockname(sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getsockname() failed\");\n\t\t\tgoto error_nodiscard;\n\t\t}\n\n\t\tswitch (saddr.ss_family) {\n\n\t\tcase AF_INET:\n\t\t\tsin4 = (struct sockaddr_in *)&saddr;\n\t\t\tportdata = sin4->sin_port;\n\t\t\tbreak;\n\n\t\tcase AF_INET6:\n\t\t\tsin6 = (struct sockaddr_in6 *)&saddr;\n\t\t\tportdata = sin6->sin6_port;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Local address has unknown address family %u\",\n\t\t\t    saddr.ss_family);\n\t\t\tgoto error_nodiscard;\n\t\t}\n\t}\n\n\t/*\n\t * Now it's time to start playing with the RPCAP protocol\n\t * RPCAP start capture command: create the request message\n\t */\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_STARTCAP_REQ, 0,\n\t    sizeof(struct rpcap_startcapreq) + sizeof(struct rpcap_filter) + fp->fcode.bf_len * sizeof(struct rpcap_filterbpf_insn));\n\n\t/* Fill the structure needed to open an adapter remotely */\n\tstartcapreq = (struct rpcap_startcapreq *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_startcapreq), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\tmemset(startcapreq, 0, sizeof(struct rpcap_startcapreq));\n\n\t/* By default, apply half the timeout on one side, half of the other */\n\tfp->opt.timeout = fp->opt.timeout / 2;\n\tstartcapreq->read_timeout = htonl(fp->opt.timeout);\n\n\t/* portdata on the openreq is meaningful only if we're in active mode */\n\tif ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tstartcapreq->portdata = portdata;\n\t}\n\n\tstartcapreq->snaplen = htonl(fp->snapshot);\n\tstartcapreq->flags = 0;\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_PROMISCUOUS)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_PROMISC;\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_DGRAM;\n\tif (active)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_SERVEROPEN;\n\n\tstartcapreq->flags = htons(startcapreq->flags);\n\n\t/* Pack the capture filter */\n\tif (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, &fp->fcode))\n\t\tgoto error_nodiscard;\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_STARTCAP_REQ, &header, fp->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\tplen = header.plen;\n\n\tif (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&startcapreply,\n\t    sizeof(struct rpcap_startcapreply), &plen, fp->errbuf) == -1)\n\t\tgoto error;\n\n\t/*\n\t * In case of UDP data stream, the connection is always opened by the daemon\n\t * So, this case is already covered by the code above.\n\t * Now, we have still to handle TCP connections, because:\n\t * - if we're in active mode, we have to wait for a remote connection\n\t * - if we're in passive more, we have to start a connection\n\t *\n\t * We have to do he job in two steps because in case we're opening a TCP connection, we have\n\t * to tell the port we're using to the remote side; in case we're accepting a TCP\n\t * connection, we have to wait this info from the remote side.\n\t */\n\tif (!(pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tif (!active)\n\t\t{\n\t\t\tchar portstring[PCAP_BUF_SIZE];\n\n\t\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t\thints.ai_family = ai_family;\t\t/* Use the same address family of the control socket */\n\t\t\thints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tsnprintf(portstring, PCAP_BUF_SIZE, \"%d\", ntohs(startcapreply.portdata));\n\n\t\t\t/* Let's the server pick up a free network port for us */\n\t\t\taddrinfo = sock_initaddress(host, portstring, &hints,\n\t\t\t    fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tif (addrinfo == NULL)\n\t\t\t\tgoto error;\n\n\t\t\tif ((sockdata = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\t\tgoto error;\n\n\t\t\t/* addrinfo is no longer used */\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPCAP_SOCKET socktemp;\t/* We need another socket, since we're going to accept() a connection */\n\n\t\t\t/* Connection creation */\n\t\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\n\t\t\tsocktemp = accept(sockdata, (struct sockaddr *) &saddr, &saddrlen);\n\n\t\t\tif (socktemp == INVALID_SOCKET)\n\t\t\t{\n\t\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"accept() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Now that I accepted the connection, the server socket is no longer needed */\n\t\t\tsock_close(sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tsockdata = socktemp;\n\t\t}\n\t}\n\n\t/* Let's save the socket of the data connection */\n\tpr->rmt_sockdata = sockdata;\n\n#ifdef HAVE_OPENSSL\n\tif (pr->uses_ssl)\n\t{\n\t\tpr->data_ssl = ssl_promotion(0, sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! pr->data_ssl) goto error;\n\t}\n#endif\n\n\t/*\n\t * Set the size of the socket buffer for the data socket.\n\t * It has the same size as the local capture buffer used\n\t * on the other side of the connection.\n\t */\n\tserver_sockbufsize = ntohl(startcapreply.bufsize);\n\n\t/* Let's get the actual size of the socket buffer */\n\titemp = sizeof(sockbufsize);\n\n\tres = getsockopt(sockdata, SOL_SOCKET, SO_RCVBUF, (char *)&sockbufsize, &itemp);\n\tif (res == -1)\n\t{\n\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcap_startcapture_remote(): getsockopt() failed\");\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Warning: on some kernels (e.g. Linux), the size of the user\n\t * buffer does not take into account the pcap_header and such,\n\t * and it is set equal to the snaplen.\n\t *\n\t * In my view, this is wrong (the meaning of the bufsize became\n\t * a bit strange).  So, here bufsize is the whole size of the\n\t * user buffer.  In case the bufsize returned is too small,\n\t * let's adjust it accordingly.\n\t */\n\tif (server_sockbufsize <= (u_int) fp->snapshot)\n\t\tserver_sockbufsize += sizeof(struct pcap_pkthdr);\n\n\t/* if the current socket buffer is smaller than the desired one */\n\tif ((u_int) sockbufsize < server_sockbufsize)\n\t{\n\t\t/*\n\t\t * Loop until the buffer size is OK or the original\n\t\t * socket buffer size is larger than this one.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t\tres = setsockopt(sockdata, SOL_SOCKET, SO_RCVBUF,\n\t\t\t    (char *)&(server_sockbufsize),\n\t\t\t    sizeof(server_sockbufsize));\n\n\t\t\tif (res == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If something goes wrong, halve the buffer size\n\t\t\t * (checking that it does not become smaller than\n\t\t\t * the current one).\n\t\t\t */\n\t\t\tserver_sockbufsize /= 2;\n\n\t\t\tif ((u_int) sockbufsize >= server_sockbufsize)\n\t\t\t{\n\t\t\t\tserver_sockbufsize = sockbufsize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Let's allocate the packet; this is required in order to put\n\t * the packet somewhere when extracting data from the socket.\n\t * Since buffering has already been done in the socket buffer,\n\t * here we need just a buffer whose size is equal to the\n\t * largest possible packet message for the snapshot size,\n\t * namely the length of the message header plus the length\n\t * of the packet header plus the snapshot length.\n\t */\n\tfp->bufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + fp->snapshot;\n\n\tfp->buffer = (u_char *)malloc(fp->bufsize);\n\tif (fp->buffer == NULL)\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tgoto error;\n\t}\n\n\t/*\n\t * The buffer is currently empty.\n\t */\n\tfp->bp = fp->buffer;\n\tfp->cc = 0;\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, fp->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\t/*\n\t * In case the user does not want to capture RPCAP packets, let's update the filter\n\t * We have to update it here (instead of sending it into the 'StartCapture' message\n\t * because when we generate the 'start capture' we do not know (yet) all the ports\n\t * we're currently using.\n\t */\n\tif (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)\n\t{\n\t\tstruct bpf_program fcode;\n\n\t\tif (pcap_createfilter_norpcappkt(fp, &fcode) == -1)\n\t\t\tgoto error;\n\n\t\t/* We cannot use 'pcap_setfilter_rpcap' because formally the capture has not been started yet */\n\t\t/* (the 'pr->rmt_capstarted' variable will be updated some lines below) */\n\t\tif (pcap_updatefilter_remote(fp, &fcode) == -1)\n\t\t\tgoto error;\n\n\t\tpcap_freecode(&fcode);\n\t}\n\n\tpr->rmt_capstarted = 1;\n\treturn 0;\n\nerror:\n\t/*\n\t * When the connection has been established, we have to close it. So, at the\n\t * beginning of this function, if an error occur we return immediately with\n\t * a return NULL; when the connection is established, we have to come here\n\t * ('goto error;') in order to close everything properly.\n\t */\n\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n#ifdef HAVE_OPENSSL\n\tif (pr->data_ssl)\n\t{\n\t\t// Finish using the SSL handle for the data socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(pr->data_ssl);\n\t\tpr->data_ssl = NULL;\n\t}\n#endif\n\n\t/* we can be here because sockdata said 'error' */\n\tif ((sockdata != 0) && (sockdata != INVALID_SOCKET))\n\t\tsock_close(sockdata, NULL, 0);\n\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->ctrl_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the control socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->ctrl_ssl);\n\t\t\tpr->ctrl_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockctrl, NULL, 0);\n\t}\n\n\tif (addrinfo != NULL)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/*\n\t * We do not have to call pcap_close() here, because this function is always called\n\t * by the user in case something bad happens\n\t */\n#if 0\n\tif (fp)\n\t{\n\t\tpcap_close(fp);\n\t\tfp= NULL;\n\t}\n#endif\n\n\treturn -1;\n}\n\n/*\n * This function takes a bpf program and sends it to the other host.\n *\n * This function can be called in two cases:\n * - pcap_startcapture_remote() is called (we have to send the filter\n *   along with the 'start capture' command)\n * - we want to update the filter during a capture (i.e. pcap_setfilter()\n *   after the capture has been started)\n *\n * This function serializes the filter into the sending buffer ('sendbuf',\n * passed as a parameter) and return back. It does not send anything on\n * the network.\n *\n * \\param fp: the pcap_t descriptor of the device currently opened.\n *\n * \\param sendbuf: the buffer on which the serialized data has to copied.\n *\n * \\param sendbufidx: it is used to return the amount of bytes copied into the buffer.\n *\n * \\param prog: the bpf program we have to copy.\n *\n * \\return '0' if everything is fine, '-1' otherwise. The error message (if one)\n * is returned into the 'errbuf' field of the pcap_t structure.\n */\nstatic int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog)\n{\n\tstruct rpcap_filter *filter;\n\tstruct rpcap_filterbpf_insn *insn;\n\tstruct bpf_insn *bf_insn;\n\tstruct bpf_program fake_prog;\t\t/* To be used just in case the user forgot to set a filter */\n\tunsigned int i;\n\n\tif (prog->bf_len == 0)\t/* No filters have been specified; so, let's apply a \"fake\" filter */\n\t{\n\t\tif (pcap_compile(fp, &fake_prog, NULL /* buffer */, 1, 0) == -1)\n\t\t\treturn -1;\n\n\t\tprog = &fake_prog;\n\t}\n\n\tfilter = (struct rpcap_filter *) sendbuf;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_filter), NULL, sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tfilter->filtertype = htons(RPCAP_UPDATEFILTER_BPF);\n\tfilter->nitems = htonl((int32_t)prog->bf_len);\n\n\tif (sock_bufferize(NULL, prog->bf_len * sizeof(struct rpcap_filterbpf_insn),\n\t\tNULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tinsn = (struct rpcap_filterbpf_insn *) (filter + 1);\n\tbf_insn = prog->bf_insns;\n\n\tfor (i = 0; i < prog->bf_len; i++)\n\t{\n\t\tinsn->code = htons(bf_insn->code);\n\t\tinsn->jf = bf_insn->jf;\n\t\tinsn->jt = bf_insn->jt;\n\t\tinsn->k = htonl(bf_insn->k);\n\n\t\tinsn++;\n\t\tbf_insn++;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function updates a filter on a remote host.\n *\n * It is called when the user wants to update a filter.\n * In case we're capturing from the network, it sends the filter to our\n * peer.\n * This function is *not* called automatically when the user calls\n * pcap_setfilter().\n * There will be two cases:\n * - the capture has been started: in this case, pcap_setfilter_rpcap()\n *   calls pcap_updatefilter_remote()\n * - the capture has not started yet: in this case, pcap_setfilter_rpcap()\n *   stores the filter into the pcap_t structure, and then the filter is\n *   sent with pcap_startcap().\n *\n * WARNING This function *does not* clear the packet currently into the\n * buffers. Therefore, the user has to expect to receive some packets\n * that are related to the previous filter.  If you want to discard all\n * the packets before applying a new filter, you have to close the\n * current capture session and start a new one.\n *\n * XXX - we really should have pcap_setfilter() always discard packets\n * received with the old filter, and have a separate pcap_setfilter_noflush()\n * function that doesn't discard any packets.\n */\nstatic int pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tstruct rpcap_header header;\t\t/* To keep the reply message */\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_UPDATEFILTER_REQ, 0,\n\t    sizeof(struct rpcap_filter) + prog->bf_len * sizeof(struct rpcap_filterbpf_insn));\n\n\tif (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, prog))\n\t\treturn -1;\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_UPDATEFILTER_REQ, &header, fp->errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It shouldn't have any contents; discard it if it does.\n\t */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void\npcap_save_current_filter_rpcap(pcap_t *fp, const char *filter)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\n\t/*\n\t * Check if:\n\t *  - We are on an remote capture\n\t *  - we do not want to capture RPCAP traffic\n\t *\n\t * If so, we have to save the current filter, because we have to\n\t * add some piece of stuff later\n\t */\n\tif (pr->rmt_clientside &&\n\t    (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP))\n\t{\n\t\tif (pr->currentfilter)\n\t\t\tfree(pr->currentfilter);\n\n\t\tif (filter == NULL)\n\t\t\tfilter = \"\";\n\n\t\tpr->currentfilter = strdup(filter);\n\t}\n}\n\n/*\n * This function sends a filter to a remote host.\n *\n * This function is called when the user wants to set a filter.\n * It sends the filter to our peer.\n * This function is called automatically when the user calls pcap_setfilter().\n *\n * Parameters and return values are exactly the same of pcap_setfilter().\n */\nstatic int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\n\tif (!pr->rmt_capstarted)\n\t{\n\t\t/* copy filter into the pcap_t structure */\n\t\tif (pcapint_install_bpf_program(fp, prog) == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* we have to update a filter during run-time */\n\tif (pcap_updatefilter_remote(fp, prog))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * This function updates the current filter in order not to capture rpcap\n * packets.\n *\n * This function is called *only* when the user wants exclude RPCAP packets\n * related to the current session from the captured packets.\n *\n * \\return '0' if everything is fine, '-1' otherwise. The error message (if one)\n * is returned into the 'errbuf' field of the pcap_t structure.\n */\nstatic int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tint RetVal = 0;\n\n\t/* We do not want to capture our RPCAP traffic. So, let's update the filter */\n\tif (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)\n\t{\n\t\tstruct sockaddr_storage saddr;\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\t\tsocklen_t saddrlen;\t\t\t\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\t\tchar myaddress[128];\n\t\tchar myctrlport[128];\n\t\tchar mydataport[128];\n\t\tchar peeraddress[128];\n\t\tchar peerctrlport[128];\n\t\tchar *newfilter;\n\n\t\t/* Get the name/port of our peer */\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getpeername() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, peeraddress,\n\t\t\tsizeof(peeraddress), peerctrlport, sizeof(peerctrlport), NI_NUMERICHOST | NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getnameinfo() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* We cannot check the data port, because this is available only in case of TCP sockets */\n\t\t/* Get the name/port of the current host */\n\t\tif (getsockname(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getsockname() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Get the local port the system picked up */\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, myaddress,\n\t\t\tsizeof(myaddress), myctrlport, sizeof(myctrlport), NI_NUMERICHOST | NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getnameinfo() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Let's now check the data port */\n\t\tif (getsockname(pr->rmt_sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getsockname() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Get the local port the system picked up */\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL, 0, mydataport, sizeof(mydataport), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"getnameinfo() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pr->currentfilter && pr->currentfilter[0] != '\\0')\n\t\t{\n\t\t\t/*\n\t\t\t * We have a current filter; add items to it to\n\t\t\t * filter out this rpcap session.\n\t\t\t */\n\t\t\tif (pcapint_asprintf(&newfilter,\n\t\t\t    \"(%s) and not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)\",\n\t\t\t    pr->currentfilter, myaddress, peeraddress,\n\t\t\t    myctrlport, peerctrlport, myaddress, peeraddress,\n\t\t\t    mydataport) == -1)\n\t\t\t{\n\t\t\t\t/* Failed. */\n\t\t\t\tsnprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Can't allocate memory for new filter\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * We have no current filter; construct a filter to\n\t\t\t * filter out this rpcap session.\n\t\t\t */\n\t\t\tif (pcapint_asprintf(&newfilter,\n\t\t\t    \"not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)\",\n\t\t\t    myaddress, peeraddress, myctrlport, peerctrlport,\n\t\t\t    myaddress, peeraddress, mydataport) == -1)\n\t\t\t{\n\t\t\t\t/* Failed. */\n\t\t\t\tsnprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Can't allocate memory for new filter\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * This is only an hack to prevent the save_current_filter\n\t\t * routine, which will be called when we call pcap_compile(),\n\t\t * from saving the modified filter.\n\t\t */\n\t\tpr->rmt_clientside = 0;\n\n\t\tif (pcap_compile(fp, prog, newfilter, 1, 0) == -1)\n\t\t\tRetVal = -1;\n\n\t\t/* Undo the hack. */\n\t\tpr->rmt_clientside = 1;\n\n\t\tfree(newfilter);\n\t}\n\n\treturn RetVal;\n}\n\n/*\n * This function sets sampling parameters in the remote host.\n *\n * It is called when the user wants to set activate sampling on the\n * remote host.\n *\n * Sampling parameters are defined into the 'pcap_t' structure.\n *\n * \\param p: the pcap_t descriptor of the device currently opened.\n *\n * \\return '0' if everything is OK, '-1' is something goes wrong. The\n * error message is returned in the 'errbuf' member of the pcap_t structure.\n */\nstatic int pcap_setsampling_remote(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tstruct rpcap_header header;\t\t/* To keep the reply message */\n\tstruct rpcap_sampling *sampling_pars;\t/* Structure that is needed to send sampling parameters to the remote host */\n\n\t/* If no sampling is requested, return 'ok' */\n\tif (fp->rmt_samp.method == PCAP_SAMP_NOSAMP)\n\t\treturn 0;\n\n\t/*\n\t * Check for sampling parameters that don't fit in a message.\n\t * We'll let the server complain about invalid parameters\n\t * that do fit into the message.\n\t */\n\tif (fp->rmt_samp.method < 0 || fp->rmt_samp.method > 255) {\n\t\tsnprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid sampling method %d\", fp->rmt_samp.method);\n\t\treturn -1;\n\t}\n\tif (fp->rmt_samp.value < 0 || fp->rmt_samp.value > 65535) {\n\t\tsnprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid sampling value %d\", fp->rmt_samp.value);\n\t\treturn -1;\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_SETSAMPLING_REQ, 0,\n\t    sizeof(struct rpcap_sampling));\n\n\t/* Fill the structure needed to open an adapter remotely */\n\tsampling_pars = (struct rpcap_sampling *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_sampling), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tmemset(sampling_pars, 0, sizeof(struct rpcap_sampling));\n\n\tsampling_pars->method = (uint8_t)fp->rmt_samp.method;\n\tsampling_pars->value = (uint16_t)htonl(fp->rmt_samp.value);\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_SETSAMPLING_REQ, &header, fp->errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It shouldn't have any contents; discard it if it does.\n\t */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*********************************************************\n *                                                       *\n * Miscellaneous functions                               *\n *                                                       *\n *********************************************************/\n\n/*\n * This function performs authentication and protocol version\n * negotiation.  It is required in order to open the connection\n * with the other end party.\n *\n * It sends authentication parameters on the control socket and\n * reads the reply.  If the reply is a success indication, it\n * checks whether the reply includes minimum and maximum supported\n * versions from the server; if not, it assumes both are 0, as\n * that means it's an older server that doesn't return supported\n * version numbers in authentication replies, so it only supports\n * version 0.  It then tries to determine the maximum version\n * supported both by us and by the server.  If it can find such a\n * version, it sets us up to use that version; otherwise, it fails,\n * indicating that there is no version supported by us and by the\n * server.\n *\n * \\param sock: the socket we are currently using.\n *\n * \\param ver: pointer to variable to which to set the protocol version\n * number we selected.\n *\n * \\param byte_swapped: pointer to variable to which to set 1 if the\n * byte order the server says it has is byte-swapped from ours, 0\n * otherwise (whether it's the same as ours or is unknown).\n *\n * \\param auth: authentication parameters that have to be sent.\n *\n * \\param errbuf: a pointer to a user-allocated buffer (of size\n * PCAP_ERRBUF_SIZE) that will contain the error message (in case there\n * is one). It could be a network problem or the fact that the authorization\n * failed.\n *\n * \\return '0' if everything is fine, '-1' for an error.  For errors,\n * an error message string is returned in the 'errbuf' variable.\n */\nstatic int rpcap_doauth(PCAP_SOCKET sockctrl, SSL *ssl, uint8_t *ver,\n    int *byte_swapped, struct pcap_rmtauth *auth, char *errbuf)\n{\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data that has to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tuint16_t length;\t\t\t/* length of the payload of this message */\n\tstruct rpcap_auth *rpauth;\n\tuint16_t auth_type;\n\tstruct rpcap_header header;\n\tsize_t str_length;\n\tuint32_t plen;\n\tstruct rpcap_authreply authreply;\t/* authentication reply message */\n\tuint8_t ourvers;\n\tint has_byte_order;\t\t\t/* The server sent its version of the byte-order magic number */\n\tu_int their_byte_order_magic;\t\t/* Here's what it is */\n\n\tif (auth)\n\t{\n\t\tswitch (auth->type)\n\t\t{\n\t\tcase RPCAP_RMTAUTH_NULL:\n\t\t\tlength = sizeof(struct rpcap_auth);\n\t\t\tbreak;\n\n\t\tcase RPCAP_RMTAUTH_PWD:\n\t\t\tlength = sizeof(struct rpcap_auth);\n\t\t\tif (auth->username)\n\t\t\t{\n\t\t\t\tstr_length = strlen(auth->username);\n\t\t\t\tif (str_length > 65535)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"User name is too long (> 65535 bytes)\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tlength += (uint16_t)str_length;\n\t\t\t}\n\t\t\tif (auth->password)\n\t\t\t{\n\t\t\t\tstr_length = strlen(auth->password);\n\t\t\t\tif (str_length > 65535)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Password is too long (> 65535 bytes)\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tlength += (uint16_t)str_length;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication type not recognized.\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tauth_type = (uint16_t)auth->type;\n\t}\n\telse\n\t{\n\t\tauth_type = RPCAP_RMTAUTH_NULL;\n\t\tlength = sizeof(struct rpcap_auth);\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, 0,\n\t    RPCAP_MSG_AUTH_REQ, 0, length);\n\n\trpauth = (struct rpcap_auth *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_auth), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tmemset(rpauth, 0, sizeof(struct rpcap_auth));\n\n\trpauth->type = htons(auth_type);\n\n\tif (auth_type == RPCAP_RMTAUTH_PWD)\n\t{\n\t\tif (auth->username)\n\t\t\trpauth->slen1 = (uint16_t)strlen(auth->username);\n\t\telse\n\t\t\trpauth->slen1 = 0;\n\n\t\tif (sock_bufferize(auth->username, rpauth->slen1, sendbuf,\n\t\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\n\t\tif (auth->password)\n\t\t\trpauth->slen2 = (uint16_t)strlen(auth->password);\n\t\telse\n\t\t\trpauth->slen2 = 0;\n\n\t\tif (sock_bufferize(auth->password, rpauth->slen2, sendbuf,\n\t\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\n\t\trpauth->slen1 = htons(rpauth->slen1);\n\t\trpauth->slen2 = htons(rpauth->slen2);\n\t}\n\n\tif (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header */\n\tif (rpcap_process_msg_header(sockctrl, ssl, 0, RPCAP_MSG_AUTH_REQ,\n\t    &header, errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * OK, it's an authentication reply, so we're logged in.\n\t *\n\t * Did it send any additional information?\n\t */\n\tplen = header.plen;\n\tif (plen != 0)\n\t{\n\t\tsize_t reply_len;\n\n\t\t/* Yes - is it big enough to include version information? */\n\t\tif (plen < sizeof(struct rpcap_authreply_old))\n\t\t{\n\t\t\t/* No - discard it and fail. */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Authentication reply from server is too short\");\n\t\t\t(void)rpcap_discard(sockctrl, ssl, plen, NULL);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Yes - does it include server byte order information? */\n\t\tif (plen == sizeof(struct rpcap_authreply_old))\n\t\t{\n\t\t\t/* No - just read the version information */\n\t\t\thas_byte_order = 0;\n\t\t\treply_len = sizeof(struct rpcap_authreply_old);\n\t\t}\n\t\telse if (plen >= sizeof(struct rpcap_authreply_old))\n\t\t{\n\t\t\t/* Yes - read it all. */\n\t\t\thas_byte_order = 1;\n\t\t\treply_len = sizeof(struct rpcap_authreply);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Too long for old reply, too short for new reply.\n\t\t\t * Discard it and fail.\n\t\t\t */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Authentication reply from server is too short\");\n\t\t\t(void)rpcap_discard(sockctrl, ssl, plen, NULL);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Read the reply body */\n\t\tif (rpcap_recv(sockctrl, ssl, (char *)&authreply,\n\t\t    reply_len, &plen, errbuf) == -1)\n\t\t{\n\t\t\t(void)rpcap_discard(sockctrl, ssl, plen, NULL);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Discard the rest of the message, if there is any. */\n\t\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Check the minimum and maximum versions for sanity;\n\t\t * the minimum must be <= the maximum.\n\t\t */\n\t\tif (authreply.minvers > authreply.maxvers)\n\t\t{\n\t\t\t/*\n\t\t\t * Bogus - give up on this server.\n\t\t\t */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The server's minimum supported protocol version is greater than its maximum supported protocol version\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (has_byte_order)\n\t\t{\n\t\t\ttheir_byte_order_magic = authreply.byte_order_magic;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The server didn't tell us what its byte\n\t\t\t * order is; assume it's ours.\n\t\t\t */\n\t\t\ttheir_byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* No - it supports only version 0. */\n\t\tauthreply.minvers = 0;\n\t\tauthreply.maxvers = 0;\n\n\t\t/*\n\t\t * And it didn't tell us what its byte order is; assume\n\t\t * it's ours.\n\t\t */\n\t\thas_byte_order = 0;\n\t\ttheir_byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;\n\t}\n\n\t/*\n\t * OK, let's start with the maximum version the server supports.\n\t */\n\tourvers = authreply.maxvers;\n\n#if RPCAP_MIN_VERSION != 0\n\t/*\n\t * If that's less than the minimum version we support, we\n\t * can't communicate.\n\t */\n\tif (ourvers < RPCAP_MIN_VERSION)\n\t\tgoto novers;\n#endif\n\n\t/*\n\t * If that's greater than the maximum version we support,\n\t * choose the maximum version we support.\n\t */\n\tif (ourvers > RPCAP_MAX_VERSION)\n\t{\n\t\tourvers = RPCAP_MAX_VERSION;\n\n\t\t/*\n\t\t * If that's less than the minimum version they\n\t\t * support, we can't communicate.\n\t\t */\n\t\tif (ourvers < authreply.minvers)\n\t\t\tgoto novers;\n\t}\n\n\t/*\n\t * Is the server byte order the opposite of ours?\n\t */\n\tif (their_byte_order_magic == RPCAP_BYTE_ORDER_MAGIC)\n\t{\n\t\t/* No, it's the same. */\n\t\t*byte_swapped = 0;\n\t}\n\telse if (their_byte_order_magic == RPCAP_BYTE_ORDER_MAGIC_SWAPPED)\n\t{\n\t\t/* Yes, it's the opposite of ours. */\n\t\t*byte_swapped = 1;\n\t}\n\telse\n\t{\n\t\t/* They sent us something bogus. */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"The server did not send us a valid byte order value\");\n\t\treturn -1;\n\t}\n\n\t*ver = ourvers;\n\treturn 0;\n\nnovers:\n\t/*\n\t * There is no version we both support; that is a fatal error.\n\t */\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The server doesn't support any protocol version that we support\");\n\treturn -1;\n}\n\n/* non-alphanumeric unreserved characters plus sub-delims (RFC3986) */\nstatic const char userinfo_allowed_symbols[] = \"-._~!&'()*+,;=\";\n\n/*\n * This function is a thin wrapper around rpcap_doauth which will use an auth\n * struct created from a username and password parsed out of the userinfo\n * portion of a URI.\n */\nstatic int rpcap_doauth_userinfo(PCAP_SOCKET sockctrl, SSL *ssl, uint8_t *ver,\n    int *byte_swapped, const char *userinfo, char *errbuf)\n{\n\tstruct pcap_rmtauth auth;\n\tconst char *ptr;\n\tchar *buf, username[256], password[256];\n\n\tauth.type = RPCAP_RMTAUTH_PWD;\n\tauth.username = username;\n\tauth.password = password;\n\tbuf = username;\n\n\tusername[0] = password[0] = '\\0';\n\n\tif ((ptr = userinfo) != NULL)\n\t{\n\t\tfor (int pos = -1; (buf[++pos] = *ptr) != '\\0'; ++ptr)\n\t\t{\n\t\t\t/* handle %xx encoded characters */\n\t\t\tif (*ptr == '%')\n\t\t\t{\n\t\t\t\t/* the pedantic thing to do here would be throwing an error on\n\t\t\t\t * a sequence like `%hi', however a lot of common tools just accept\n\t\t\t\t * such malarkey, so... probably it will be fine? */\n\t\t\t\tif (sscanf(ptr, \"%%%02hhx\", (unsigned char *)(buf+pos)) == 1)\n\t\t\t\t\tptr += 2;\n\t\t\t\t/* other implementations aside, rejecting null bytes seems prudent */\n\t\t\t\tif (buf[pos] == '\\0')\n\t\t\t\t{\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Invalid escape `%%00` in userinfo\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*ptr == ':' && buf == username)\n\t\t\t{\n\t\t\t\t/* terminate username string and switch to password string */\n\t\t\t\tbuf[pos] = '\\0';\n\t\t\t\tbuf = password;\n\t\t\t\tpos = -1;\n\t\t\t}\n\t\t\t/* constrain to characters allowed by RFC3986 */\n\t\t\telse if (*ptr >= 'A' && *ptr <= 'Z')\n\t\t\t\tcontinue;\n\t\t\telse if (*ptr >= 'a' && *ptr <= 'z')\n\t\t\t\tcontinue;\n\t\t\telse if (*ptr >= '0' && *ptr <= '9')\n\t\t\t\tcontinue;\n\t\t\telse if (*ptr < ' ' || *ptr > '~')\n\t\t\t{\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Invalid character `\\\\%o` in userinfo\", *ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (strchr(userinfo_allowed_symbols, *ptr) == NULL)\n\t\t\t{\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Invalid character `%c` in userinfo\", *ptr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\treturn rpcap_doauth(sockctrl, ssl, ver, byte_swapped, &auth,\n\t\t    errbuf);\n\t}\n\n\treturn rpcap_doauth(sockctrl, ssl, ver, byte_swapped, NULL, errbuf);\n}\n\n\n/* We don't currently support non-blocking mode. */\nstatic int\npcap_getnonblock_rpcap(pcap_t *p)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing remotely with rpcap\");\n\treturn (-1);\n}\n\nstatic int\npcap_setnonblock_rpcap(pcap_t *p, int nonblock _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing remotely with rpcap\");\n\treturn (-1);\n}\n\nstatic int\nrpcap_setup_session(const char *source, struct pcap_rmtauth *auth,\n    int *activep, PCAP_SOCKET *sockctrlp, uint8_t *uses_sslp, SSL **sslp,\n    int rmt_flags, uint8_t *protocol_versionp, int *byte_swappedp,\n    char *host, char *port, char *iface, char *errbuf)\n{\n\tint type;\n\tint auth_result;\n\tchar userinfo[PCAP_BUF_SIZE+1];\n\tstruct activehosts *activeconn;\t\t/* active connection, if there is one */\n\tint error;\t\t\t\t/* 1 if rpcap_remoteact_getsock got an error */\n\n\tuserinfo[0] = '\\0';\n\n\t/*\n\t * Determine the type of the source (NULL, file, local, remote).\n\t * You must have a valid source string even if we're in active mode,\n\t * because otherwise the call to the following function will fail.\n\t */\n\tif (pcapint_parsesrcstr_ex(source, &type, userinfo, host, port, iface, uses_sslp,\n\t    errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It must be remote.\n\t */\n\tif (type != PCAP_SRC_IFREMOTE)\n\t{\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Non-remote interface passed to remote capture routine\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * We don't yet support DTLS, so if the user asks for a TLS\n\t * connection and asks for data packets to be sent over UDP,\n\t * we have to give up.\n\t */\n\tif (*uses_sslp && (rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"TLS not supported with UDP forward of remote packets\");\n\t\treturn -1;\n\t}\n\n\t/* Warning: this call can be the first one called by the user. */\n\t/* For this reason, we have to initialize the Winsock support. */\n\tif (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\treturn -1;\n\n\t/* Check for active mode */\n\tactiveconn = rpcap_remoteact_getsock(host, &error, errbuf);\n\tif (activeconn != NULL)\n\t{\n\t\t*activep = 1;\n\t\t*sockctrlp = activeconn->sockctrl;\n\t\t*sslp = activeconn->ssl;\n\t\t*protocol_versionp = activeconn->protocol_version;\n\t\t*byte_swappedp = activeconn->byte_swapped;\n\t}\n\telse\n\t{\n\t\t*activep = 0;\n\t\tstruct addrinfo hints;\t\t/* temp variable needed to resolve hostnames into to socket representation */\n\t\tstruct addrinfo *addrinfo;\t/* temp variable needed to resolve hostnames into to socket representation */\n\n\t\tif (error)\n\t\t{\n\t\t\t/*\n\t\t\t * Call failed.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * We're not in active mode; let's try to open a new\n\t\t * control connection.\n\t\t */\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = PF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\tif (port[0] == 0)\n\t\t{\n\t\t\t/* the user chose not to specify the port */\n\t\t\taddrinfo = sock_initaddress(host, RPCAP_DEFAULT_NETPORT,\n\t\t\t    &hints, errbuf, PCAP_ERRBUF_SIZE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddrinfo = sock_initaddress(host, port, &hints,\n\t\t\t    errbuf, PCAP_ERRBUF_SIZE);\n\t\t}\n\t\tif (addrinfo == NULL)\n\t\t\treturn -1;\n\n\t\tif ((*sockctrlp = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0,\n\t\t    errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t{\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* addrinfo is no longer used */\n\t\tfreeaddrinfo(addrinfo);\n\t\taddrinfo = NULL;\n\n\t\tif (*uses_sslp)\n\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\t*sslp = ssl_promotion(0, *sockctrlp, errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\tif (!*sslp)\n\t\t\t{\n\t\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\t\treturn -1;\n\t\t\t}\n#else\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"No TLS support\");\n\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\treturn -1;\n#endif\n\t\t}\n\n\t\tif (auth == NULL && *userinfo != '\\0')\n\t\t{\n\t\t\tauth_result = rpcap_doauth_userinfo(*sockctrlp, *sslp,\n\t\t\t    protocol_versionp, byte_swappedp, userinfo, errbuf);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauth_result = rpcap_doauth(*sockctrlp, *sslp,\n\t\t\t    protocol_versionp, byte_swappedp, auth, errbuf);\n\t\t}\n\n\t\tif (auth_result == -1)\n\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\tif (*sslp)\n\t\t\t{\n\t\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t\t// This must be done *before* the socket is\n\t\t\t\t// closed.\n\t\t\t\tssl_finish(*sslp);\n\t\t\t}\n#endif\n\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * This function opens a remote adapter by opening an RPCAP connection and\n * so on.\n *\n * It does the job of pcap_open_live() for a remote interface; it's called\n * by pcap_open() for remote interfaces.\n *\n * We do not start the capture until pcap_startcapture_remote() is called.\n *\n * This is because, when doing a remote capture, we cannot start capturing\n * data as soon as the 'open adapter' command is sent. Suppose the remote\n * adapter is already overloaded; if we start a capture (which, by default,\n * has a NULL filter) the new traffic can saturate the network.\n *\n * Instead, we want to \"open\" the adapter, then send a \"start capture\"\n * command only when we're ready to start the capture.\n * This function does this job: it sends an \"open adapter\" command\n * (according to the RPCAP protocol), but it does not start the capture.\n *\n * Since the other libpcap functions do not share this way of life, we\n * have to do some dirty things in order to make everything work.\n *\n * \\param source: see pcap_open().\n * \\param snaplen: see pcap_open().\n * \\param flags: see pcap_open().\n * \\param read_timeout: see pcap_open().\n * \\param auth: see pcap_open().\n * \\param errbuf: see pcap_open().\n *\n * \\return a pcap_t pointer in case of success, NULL otherwise. In case of\n * success, the pcap_t pointer can be used as a parameter to the following\n * calls (pcap_compile() and so on). In case of problems, errbuf contains\n * a text explanation of error.\n *\n * WARNING: In case we call pcap_compile() and the capture has not yet\n * been started, the filter will be saved into the pcap_t structure,\n * and it will be sent to the other host later (when\n * pcap_startcapture_remote() is called).\n */\npcap_t *pcap_open_rpcap(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)\n{\n\tpcap_t *fp;\n\tchar *source_str;\n\tstruct pcap_rpcap *pr;\t\t/* structure used when doing a remote live capture */\n\tchar host[PCAP_BUF_SIZE], ctrlport[PCAP_BUF_SIZE], iface[PCAP_BUF_SIZE];\n\tPCAP_SOCKET sockctrl;\n\tSSL *ssl = NULL;\n\tuint8_t protocol_version;\t\t/* negotiated protocol version */\n\tint byte_swapped;\t\t\t/* server is known to be byte-swapped */\n\tint active;\n\tuint32_t plen;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\n\t/* RPCAP-related variables */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct rpcap_openreply openreply;\t/* open reply message */\n\n\tfp = PCAP_CREATE_COMMON(errbuf, struct pcap_rpcap);\n\tif (fp == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\tsource_str = strdup(source);\n\tif (source_str == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t *\n\t * XXX - should we leave this up to the remote server to\n\t * do?\n\t */\n\tif (snaplen <= 0 || snaplen > MAXIMUM_SNAPLEN)\n\t\tsnaplen = MAXIMUM_SNAPLEN;\n\n\tfp->opt.device = source_str;\n\tfp->snapshot = snaplen;\n\tfp->opt.timeout = read_timeout;\n\tpr = fp->priv;\n\tpr->rmt_flags = flags;\n\n\t/*\n\t * Attempt to set up the session with the server.\n\t */\n\tif (rpcap_setup_session(fp->opt.device, auth, &active, &sockctrl,\n\t    &pr->uses_ssl, &ssl, flags, &protocol_version, &byte_swapped,\n\t    host, ctrlport, iface, errbuf) == -1)\n\t{\n\t\t/* Session setup failed. */\n\t\tpcap_close(fp);\n\t\treturn NULL;\n\t}\n\n\t/* All good so far, save the ssl handler */\n\tssl_main = ssl;\n\n\t/*\n\t * Now it's time to start playing with the RPCAP protocol\n\t * RPCAP open command: create the request message\n\t */\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, protocol_version,\n\t    RPCAP_MSG_OPEN_REQ, 0, (uint32_t) strlen(iface));\n\n\tif (sock_bufferize(iface, (int) strlen(iface), sendbuf, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\tif (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(sockctrl, ssl, protocol_version,\n\t    RPCAP_MSG_OPEN_REQ, &header, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\tplen = header.plen;\n\n\t/* Read the reply body */\n\tif (rpcap_recv(sockctrl, ssl, (char *)&openreply,\n\t    sizeof(struct rpcap_openreply), &plen, errbuf) == -1)\n\t\tgoto error;\n\n\t/* Discard the rest of the message, if there is any. */\n\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\t/* Set proper fields into the pcap_t struct */\n\tfp->linktype = ntohl(openreply.linktype);\n\tpr->rmt_sockctrl = sockctrl;\n\tpr->ctrl_ssl = ssl;\n\tpr->protocol_version = protocol_version;\n\tpr->byte_swapped = byte_swapped;\n\tpr->rmt_clientside = 1;\n\n\t/* This code is duplicated from the end of this function */\n\tfp->read_op = pcap_read_rpcap;\n\tfp->save_current_filter_op = pcap_save_current_filter_rpcap;\n\tfp->setfilter_op = pcap_setfilter_rpcap;\n\tfp->getnonblock_op = pcap_getnonblock_rpcap;\n\tfp->setnonblock_op = pcap_setnonblock_rpcap;\n\tfp->stats_op = pcap_stats_rpcap;\n#ifdef _WIN32\n\tfp->stats_ex_op = pcap_stats_ex_rpcap;\n#endif\n\tfp->cleanup_op = pcap_cleanup_rpcap;\n\n\tfp->activated = 1;\n\treturn fp;\n\nerror:\n\t/*\n\t * When the connection has been established, we have to close it. So, at the\n\t * beginning of this function, if an error occur we return immediately with\n\t * a return NULL; when the connection is established, we have to come here\n\t * ('goto error;') in order to close everything properly.\n\t */\n\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t}\n\n\tpcap_close(fp);\n\treturn NULL;\n}\n\n/* String identifier to be used in the pcap_findalldevs_ex() */\n#define PCAP_TEXT_SOURCE_ADAPTER \"Network adapter\"\n#define PCAP_TEXT_SOURCE_ADAPTER_LEN (sizeof PCAP_TEXT_SOURCE_ADAPTER - 1)\n/* String identifier to be used in the pcap_findalldevs_ex() */\n#define PCAP_TEXT_SOURCE_ON_REMOTE_HOST \"on remote node\"\n#define PCAP_TEXT_SOURCE_ON_REMOTE_HOST_LEN (sizeof PCAP_TEXT_SOURCE_ON_REMOTE_HOST - 1)\n\nstatic void\nfreeaddr(struct pcap_addr *addr)\n{\n\tfree(addr->addr);\n\tfree(addr->netmask);\n\tfree(addr->broadaddr);\n\tfree(addr->dstaddr);\n\tfree(addr);\n}\n\nint\npcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)\n{\n\tuint8_t protocol_version;\t/* protocol version */\n\tint byte_swapped;\t\t/* Server byte order is swapped from ours */\n\tPCAP_SOCKET sockctrl;\t\t/* socket descriptor of the control connection */\n\tSSL *ssl = NULL;\t\t/* optional SSL handler for sockctrl */\n\tuint32_t plen;\n\tstruct rpcap_header header;\t/* structure that keeps the general header of the rpcap protocol */\n\tint i, j;\t\t/* temp variables */\n\tint nif;\t\t/* Number of interfaces listed */\n\tint active;\t\t\t/* 'true' if we the other end-party is in active mode */\n\tuint8_t uses_ssl;\n\tchar host[PCAP_BUF_SIZE], port[PCAP_BUF_SIZE];\n\tchar tmpstring[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\tpcap_if_t *lastdev;\t/* Last device in the pcap_if_t list */\n\tpcap_if_t *dev;\t\t/* Device we're adding to the pcap_if_t list */\n\n\t/* List starts out empty. */\n\t(*alldevs) = NULL;\n\tlastdev = NULL;\n\n\t/*\n\t * Attempt to set up the session with the server.\n\t */\n\tif (rpcap_setup_session(source, auth, &active, &sockctrl, &uses_ssl,\n\t    &ssl, 0, &protocol_version, &byte_swapped, host, port, NULL,\n\t    errbuf) == -1)\n\t{\n\t\t/* Session setup failed. */\n\t\treturn -1;\n\t}\n\n\t/* RPCAP findalldevs command */\n\trpcap_createhdr(&header, protocol_version, RPCAP_MSG_FINDALLIF_REQ,\n\t    0, 0);\n\n\tif (sock_send(sockctrl, ssl, (char *)&header, sizeof(struct rpcap_header),\n\t    errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(sockctrl, ssl, protocol_version,\n\t    RPCAP_MSG_FINDALLIF_REQ, &header, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\tplen = header.plen;\n\n\t/* read the number of interfaces */\n\tnif = ntohs(header.value);\n\n\t/* loop until all interfaces have been received */\n\tfor (i = 0; i < nif; i++)\n\t{\n\t\tstruct rpcap_findalldevs_if findalldevs_if;\n\t\tchar tmpstring2[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\t\tstruct pcap_addr *addr, *prevaddr;\n\n\t\ttmpstring2[PCAP_BUF_SIZE] = 0;\n\n\t\t/* receive the findalldevs structure from remote host */\n\t\tif (rpcap_recv(sockctrl, ssl, (char *)&findalldevs_if,\n\t\t    sizeof(struct rpcap_findalldevs_if), &plen, errbuf) == -1)\n\t\t\tgoto error;\n\n\t\tfindalldevs_if.namelen = ntohs(findalldevs_if.namelen);\n\t\tfindalldevs_if.desclen = ntohs(findalldevs_if.desclen);\n\t\tfindalldevs_if.naddr = ntohs(findalldevs_if.naddr);\n\n\t\t/* allocate the main structure */\n\t\tdev = (pcap_if_t *)malloc(sizeof(pcap_if_t));\n\t\tif (dev == NULL)\n\t\t{\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Initialize the structure to 'zero' */\n\t\tmemset(dev, 0, sizeof(pcap_if_t));\n\n\t\t/* Append it to the list. */\n\t\tif (lastdev == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * List is empty, so it's also the first device.\n\t\t\t */\n\t\t\t*alldevs = dev;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Append after the last device.\n\t\t\t */\n\t\t\tlastdev->next = dev;\n\t\t}\n\t\t/* It's now the last device. */\n\t\tlastdev = dev;\n\n\t\t/* allocate mem for name and description */\n\t\tif (findalldevs_if.namelen)\n\t\t{\n\n\t\t\tif (findalldevs_if.namelen >= sizeof(tmpstring))\n\t\t\t{\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Interface name too long\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Retrieve adapter name */\n\t\t\tif (rpcap_recv(sockctrl, ssl, tmpstring,\n\t\t\t    findalldevs_if.namelen, &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\ttmpstring[findalldevs_if.namelen] = 0;\n\n\t\t\t/* Create the new device identifier */\n\t\t\tif (pcapint_createsrcstr_ex(tmpstring2, PCAP_SRC_IFREMOTE,\n\t\t\t    NULL, host, port, tmpstring, uses_ssl, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\tdev->name = strdup(tmpstring2);\n\t\t\tif (dev->name == NULL)\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tif (findalldevs_if.desclen)\n\t\t{\n\t\t\tif (findalldevs_if.desclen >= sizeof(tmpstring))\n\t\t\t{\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Interface description too long\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Retrieve adapter description */\n\t\t\tif (rpcap_recv(sockctrl, ssl, tmpstring,\n\t\t\t    findalldevs_if.desclen, &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\ttmpstring[findalldevs_if.desclen] = 0;\n\n\t\t\tif (pcapint_asprintf(&dev->description,\n\t\t\t    \"%s '%s' %s %s\", PCAP_TEXT_SOURCE_ADAPTER,\n\t\t\t    tmpstring, PCAP_TEXT_SOURCE_ON_REMOTE_HOST, host) == -1)\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tdev->flags = ntohl(findalldevs_if.flags);\n\n\t\tprevaddr = NULL;\n\t\t/* loop until all addresses have been received */\n\t\tfor (j = 0; j < findalldevs_if.naddr; j++)\n\t\t{\n\t\t\tstruct rpcap_findalldevs_ifaddr ifaddr;\n\n\t\t\t/* Retrieve the interface addresses */\n\t\t\tif (rpcap_recv(sockctrl, ssl, (char *)&ifaddr,\n\t\t\t    sizeof(struct rpcap_findalldevs_ifaddr),\n\t\t\t    &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\t/*\n\t\t\t * Deserialize all the address components.\n\t\t\t */\n\t\t\taddr = (struct pcap_addr *) malloc(sizeof(struct pcap_addr));\n\t\t\tif (addr == NULL)\n\t\t\t{\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\taddr->next = NULL;\n\t\t\taddr->addr = NULL;\n\t\t\taddr->netmask = NULL;\n\t\t\taddr->broadaddr = NULL;\n\t\t\taddr->dstaddr = NULL;\n\n\t\t\tif (rpcap_deseraddr(&ifaddr.addr, &addr->addr,\n\t\t\t\terrbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.netmask, &addr->netmask,\n\t\t\t\terrbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.broadaddr, &addr->broadaddr,\n\t\t\t\terrbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.dstaddr, &addr->dstaddr,\n\t\t\t\terrbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif ((addr->addr == NULL) && (addr->netmask == NULL) &&\n\t\t\t\t(addr->broadaddr == NULL) && (addr->dstaddr == NULL))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * None of the addresses are IPv4 or IPv6\n\t\t\t\t * addresses, so throw this entry away.\n\t\t\t\t */\n\t\t\t\tfree(addr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Add this entry to the list.\n\t\t\t\t */\n\t\t\t\tif (prevaddr == NULL)\n\t\t\t\t{\n\t\t\t\t\tdev->addresses = addr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprevaddr->next = addr;\n\t\t\t\t}\n\t\t\t\tprevaddr = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == 1)\n\t\tgoto error_nodiscard;\n\n\t/* Control connection has to be closed only in case the remote machine is in passive mode */\n\tif (!active)\n\t{\n\t\t/* DO not send RPCAP_CLOSE, since we did not open a pcap_t; no need to free resources */\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tif (sock_close(sockctrl, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\t}\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\treturn 0;\n\nerror:\n\t/*\n\t * In case there has been an error, I don't want to overwrite it with a new one\n\t * if the following call fails. I want to return always the original error.\n\t *\n\t * Take care: this connection can already be closed when we try to close it.\n\t * This happens because a previous error in the rpcapd, which requested to\n\t * closed the connection. In that case, we already recognized that into the\n\t * rpspck_isheaderok() and we already acknowledged the closing.\n\t * In that sense, this call is useless here (however it is needed in case\n\t * the client generates the error).\n\t *\n\t * Checks if all the data has been read; if not, discard the data in excess\n\t */\n\t(void) rpcap_discard(sockctrl, ssl, plen, NULL);\n\nerror_nodiscard:\n\t/* Control connection has to be closed only in case the remote machine is in passive mode */\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t}\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\t/* Free whatever interfaces we've allocated. */\n\tpcap_freealldevs(*alldevs);\n\n\treturn -1;\n}\n\n/*\n * Active mode routines.\n *\n * The old libpcap API is somewhat ugly, and makes active mode difficult\n * to implement; we provide some APIs for it that work only with rpcap.\n */\n\nPCAP_SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)\n{\n\t/* socket-related variables */\n\tstruct addrinfo hints;\t\t\t/* temporary struct to keep settings needed to open the new socket */\n\tstruct addrinfo *addrinfo;\t\t/* keeps the addrinfo chain; required to open a new socket */\n\tstruct sockaddr_storage from;\t/* generic sockaddr_storage variable */\n\tsocklen_t fromlen;\t\t\t\t/* keeps the length of the sockaddr_storage variable */\n\tPCAP_SOCKET sockctrl;\t\t\t/* keeps the main socket identifier */\n\tSSL *ssl = NULL;\t\t\t\t/* Optional SSL handler for sockctrl */\n\tuint8_t protocol_version;\t\t/* negotiated protocol version */\n\tint byte_swapped;\t\t\t/* 1 if server byte order is known to be the reverse of ours */\n\tstruct activehosts *temp, *prev;\t/* temp var needed to scan he host list chain */\n\n\t*connectinghost = 0;\t\t/* just in case */\n\n\t/* Prepare to open a new server socket */\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t/* WARNING Currently it supports only ONE socket family among ipv4 and IPv6  */\n\thints.ai_family = AF_INET;\t\t/* PF_UNSPEC to have both IPv4 and IPv6 server */\n\thints.ai_flags = AI_PASSIVE;\t/* Ready to a bind() socket */\n\thints.ai_socktype = SOCK_STREAM;\n\n\t/* Warning: this call can be the first one called by the user. */\n\t/* For this reason, we have to initialize the Winsock support. */\n\tif (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\treturn (PCAP_SOCKET)-1;\n\n\t/* Do the work */\n\tif ((port == NULL) || (port[0] == 0))\n\t{\n\t\taddrinfo = sock_initaddress(address,\n\t\t    RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, errbuf,\n\t\t    PCAP_ERRBUF_SIZE);\n\t}\n\telse\n\t{\n\t\taddrinfo = sock_initaddress(address, port, &hints, errbuf,\n\t\t    PCAP_ERRBUF_SIZE);\n\t}\n\tif (addrinfo == NULL)\n\t{\n\t\treturn (PCAP_SOCKET)-2;\n\t}\n\n\tif ((sockmain = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\treturn (PCAP_SOCKET)-2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\n\t/* Connection creation */\n\tfromlen = sizeof(struct sockaddr_storage);\n\n\tsockctrl = accept(sockmain, (struct sockaddr *) &from, &fromlen);\n\n\t/* We're not using sock_close, since we do not want to send a shutdown */\n\t/* (which is not allowed on a non-connected socket) */\n\tclosesocket(sockmain);\n\tsockmain = 0;\n\n\tif (sockctrl == INVALID_SOCKET)\n\t{\n\t\tsock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE, \"accept() failed\");\n\t\treturn (PCAP_SOCKET)-2;\n\t}\n\n\t/* Promote to SSL early before any error message may be sent */\n\tif (uses_ssl)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tssl = ssl_promotion(0, sockctrl, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! ssl)\n\t\t{\n\t\t\tsock_close(sockctrl, NULL, 0);\n\t\t\treturn (PCAP_SOCKET)-1;\n\t\t}\n#else\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"No TLS support\");\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (PCAP_SOCKET)-1;\n#endif\n\t}\n\n\t/* Get the numeric for of the name of the connecting host */\n\tif (getnameinfo((struct sockaddr *) &from, fromlen, connectinghost, RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST))\n\t{\n\t\tsock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"getnameinfo() failed\");\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (PCAP_SOCKET)-1;\n\t}\n\n\t/* checks if the connecting host is among the ones allowed */\n\tif (sock_check_hostlist(hostlist, RPCAP_HOSTLIST_SEP, &from, errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t{\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (PCAP_SOCKET)-1;\n\t}\n\n\t/*\n\t * Send authentication to the remote machine.\n\t */\n\tif (rpcap_doauth(sockctrl, ssl, &protocol_version, &byte_swapped,\n\t    auth, errbuf) == -1)\n\t{\n\t\t/* Unrecoverable error. */\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (PCAP_SOCKET)-3;\n\t}\n\n\t/* Checks that this host does not already have a cntrl connection in place */\n\n\t/* Initialize pointers */\n\ttemp = activeHosts;\n\tprev = NULL;\n\n\twhile (temp)\n\t{\n\t\t/* This host already has an active connection in place, so I don't have to update the host list */\n\t\tif (sock_cmpaddr(&temp->host, &from) == 0)\n\t\t\treturn sockctrl;\n\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\n\t/* The host does not exist in the list; so I have to update the list */\n\tif (prev)\n\t{\n\t\tprev->next = (struct activehosts *) malloc(sizeof(struct activehosts));\n\t\ttemp = prev->next;\n\t}\n\telse\n\t{\n\t\tactiveHosts = (struct activehosts *) malloc(sizeof(struct activehosts));\n\t\ttemp = activeHosts;\n\t}\n\n\tif (temp == NULL)\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc() failed\");\n\t\trpcap_senderror(sockctrl, ssl, protocol_version, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (PCAP_SOCKET)-1;\n\t}\n\n\tmemcpy(&temp->host, &from, fromlen);\n\ttemp->sockctrl = sockctrl;\n\ttemp->ssl = ssl;\n\ttemp->protocol_version = protocol_version;\n\ttemp->byte_swapped = byte_swapped;\n\ttemp->next = NULL;\n\n\treturn sockctrl;\n}\n\nPCAP_SOCKET pcap_remoteact_accept(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)\n{\n\treturn pcap_remoteact_accept_ex(address, port, hostlist, connectinghost, auth, 0, errbuf);\n}\n\nint pcap_remoteact_close(const char *host, char *errbuf)\n{\n\tstruct activehosts *temp, *prev;\t/* temp var needed to scan the host list chain */\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n\n\ttemp = activeHosts;\n\tprev = NULL;\n\n\t/* retrieve the network address corresponding to 'host' */\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\taddrinfo = sock_initaddress(host, NULL, &hints, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (addrinfo == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\tstruct rpcap_header header;\n\t\t\t\tint status = 0;\n\n\t\t\t\t/* Close this connection */\n\t\t\t\trpcap_createhdr(&header, temp->protocol_version,\n\t\t\t\t    RPCAP_MSG_CLOSE, 0, 0);\n\n\t\t\t\t/*\n\t\t\t\t * Don't check for errors, since we're\n\t\t\t\t * just cleaning up.\n\t\t\t\t */\n\t\t\t\tif (sock_send(temp->sockctrl, temp->ssl,\n\t\t\t\t    (char *)&header,\n\t\t\t\t    sizeof(struct rpcap_header), errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE) < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Let that error be the one we\n\t\t\t\t\t * report.\n\t\t\t\t\t */\n#ifdef HAVE_OPENSSL\n\t\t\t\t\tif (temp->ssl)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Finish using the SSL handle\n\t\t\t\t\t\t// for the socket.\n\t\t\t\t\t\t// This must be done *before*\n\t\t\t\t\t\t// the socket is closed.\n\t\t\t\t\t\tssl_finish(temp->ssl);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t(void)sock_close(temp->sockctrl, NULL,\n\t\t\t\t\t   0);\n\t\t\t\t\tstatus = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\t\t\tif (temp->ssl)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Finish using the SSL handle\n\t\t\t\t\t\t// for the socket.\n\t\t\t\t\t\t// This must be done *before*\n\t\t\t\t\t\t// the socket is closed.\n\t\t\t\t\t\tssl_finish(temp->ssl);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (sock_close(temp->sockctrl, errbuf,\n\t\t\t\t\t   PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\t\tstatus = -1;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Remove the host from the list of active\n\t\t\t\t * hosts.\n\t\t\t\t */\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = temp->next;\n\t\t\t\telse\n\t\t\t\t\tactiveHosts = temp->next;\n\n\t\t\t\tfreeaddrinfo(addrinfo);\n\n\t\t\t\tfree(temp);\n\n\t\t\t\t/* To avoid inconsistencies in the number of sock_init() */\n\t\t\t\tsock_cleanup();\n\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"The host you want to close the active connection is not known\");\n\treturn -1;\n}\n\nvoid pcap_remoteact_cleanup(void)\n{\n#\tifdef HAVE_OPENSSL\n\tif (ssl_main)\n\t{\n\t\t// Finish using the SSL handle for the main active socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(ssl_main);\n\t\tssl_main = NULL;\n\t}\n#\tendif\n\n\t/* Very dirty, but it works */\n\tif (sockmain)\n\t{\n\t\tclosesocket(sockmain);\n\n\t\t/* To avoid inconsistencies in the number of sock_init() */\n\t\tsock_cleanup();\n\t}\n}\n\nint pcap_remoteact_list(char *hostlist, char sep, int size, char *errbuf)\n{\n\tstruct activehosts *temp;\t/* temp var needed to scan the host list chain */\n\tsize_t len;\n\tchar hoststr[RPCAP_HOSTLIST_SIZE + 1];\n\n\ttemp = activeHosts;\n\n\tlen = 0;\n\t*hostlist = 0;\n\n\twhile (temp)\n\t{\n\t\t/*int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen) */\n\n\t\t/* Get the numeric form of the name of the connecting host */\n\t\tif (sock_getascii_addrport((struct sockaddr_storage *) &temp->host, hoststr,\n\t\t\tRPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST, errbuf, PCAP_ERRBUF_SIZE) != -1)\n\t\t\t/*\tif (getnameinfo( (struct sockaddr *) &temp->host, sizeof (struct sockaddr_storage), hoststr, */\n\t\t\t/*\t\tRPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST) ) */\n\t\t{\n\t\t\t/*\tsock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE, */\n\t\t\t/*\t    \"getnameinfo() failed\");             */\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = len + strlen(hoststr) + 1 /* the separator */;\n\n\t\tif ((size < 0) || (len >= (size_t)size))\n\t\t{\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"The string you provided is not able to keep \"\n\t\t\t\t\"the hostnames for all the active connections\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpcapint_strlcat(hostlist, hoststr, PCAP_ERRBUF_SIZE);\n\t\thostlist[len - 1] = sep;\n\t\thostlist[len] = 0;\n\n\t\ttemp = temp->next;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Receive the header of a message.\n */\nstatic int rpcap_recv_msg_header(PCAP_SOCKET sock, SSL *ssl, struct rpcap_header *header, char *errbuf)\n{\n\tint nrecv;\n\n\tnrecv = sock_recv(sock, ssl, (char *) header, sizeof(struct rpcap_header),\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (nrecv == -1)\n\t{\n\t\t/* Network error. */\n\t\treturn -1;\n\t}\n\theader->plen = ntohl(header->plen);\n\treturn 0;\n}\n\n/*\n * Make sure the protocol version of a received message is what we were\n * expecting.\n */\nstatic int rpcap_check_msg_ver(PCAP_SOCKET sock, SSL *ssl, uint8_t expected_ver, struct rpcap_header *header, char *errbuf)\n{\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (header->ver != expected_ver)\n\t{\n\t\t/*\n\t\t * Discard the rest of the message.\n\t\t */\n\t\tif (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Tell our caller that it's not the negotiated version.\n\t\t */\n\t\tif (errbuf != NULL)\n\t\t{\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Server sent us a message with version %u when we were expecting %u\",\n\t\t\t    header->ver, expected_ver);\n\t\t}\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Check the message type of a received message, which should either be\n * the expected message type or RPCAP_MSG_ERROR.\n */\nstatic int rpcap_check_msg_type(PCAP_SOCKET sock, SSL *ssl, uint8_t request_type, struct rpcap_header *header, uint16_t *errcode, char *errbuf)\n{\n\tconst char *request_type_string;\n\tconst char *msg_type_string;\n\n\t/*\n\t * What type of message is it?\n\t */\n\tif (header->type == RPCAP_MSG_ERROR)\n\t{\n\t\t/*\n\t\t * The server reported an error.\n\t\t * Hand that error back to our caller.\n\t\t */\n\t\t*errcode = ntohs(header->value);\n\t\trpcap_msg_err(sock, ssl, header->plen, errbuf);\n\t\treturn -1;\n\t}\n\n\t*errcode = 0;\n\n\t/*\n\t * For a given request type value, the expected reply type value\n\t * is the request type value with ORed with RPCAP_MSG_IS_REPLY.\n\t */\n\tif (header->type != (request_type | RPCAP_MSG_IS_REPLY))\n\t{\n\t\t/*\n\t\t * This isn't a reply to the request we sent.\n\t\t */\n\n\t\t/*\n\t\t * Discard the rest of the message.\n\t\t */\n\t\tif (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Tell our caller about it.\n\t\t */\n\t\trequest_type_string = rpcap_msg_type_string(request_type);\n\t\tmsg_type_string = rpcap_msg_type_string(header->type);\n\t\tif (errbuf != NULL)\n\t\t{\n\t\t\tif (request_type_string == NULL)\n\t\t\t{\n\t\t\t\t/* This should not happen. */\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"rpcap_check_msg_type called for request message with type %u\",\n\t\t\t\t    request_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (msg_type_string != NULL)\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s message received in response to a %s message\",\n\t\t\t\t    msg_type_string, request_type_string);\n\t\t\telse\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Message of unknown type %u message received in response to a %s request\",\n\t\t\t\t    header->type, request_type_string);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Receive and process the header of a message.\n */\nstatic int rpcap_process_msg_header(PCAP_SOCKET sock, SSL *ssl, uint8_t expected_ver, uint8_t request_type, struct rpcap_header *header, char *errbuf)\n{\n\tuint16_t errcode;\n\n\tif (rpcap_recv_msg_header(sock, ssl, header, errbuf) == -1)\n\t{\n\t\t/* Network error. */\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (rpcap_check_msg_ver(sock, ssl, expected_ver, header, errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * Check the message type.\n\t */\n\treturn rpcap_check_msg_type(sock, ssl, request_type, header,\n\t    &errcode, errbuf);\n}\n\n/*\n * Read data from a message.\n * If we're trying to read more data than remains, puts an error\n * message into errbuf and returns -1.  Otherwise, tries to read\n * the data and, if that succeeds, subtracts the amount read from\n * the number of bytes of data that remains.\n * Returns 0 on success and -1 on an error (short message or\n * network error).\n */\nstatic int rpcap_recv(PCAP_SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32_t *plen, char *errbuf)\n{\n\tint nread;\n\n\tif (toread > *plen)\n\t{\n\t\t/* The server sent us a bad message */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Message payload is too short\");\n\t\treturn -1;\n\t}\n\tnread = sock_recv(sock, ssl, buffer, toread,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\treturn -1;\n\t}\n\t*plen -= nread;\n\treturn 0;\n}\n\n/*\n * This handles the RPCAP_MSG_ERROR message.\n */\nstatic void rpcap_msg_err(PCAP_SOCKET sockctrl, SSL *ssl, uint32_t plen, char *remote_errbuf)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\tif (plen >= PCAP_ERRBUF_SIZE)\n\t{\n\t\t/*\n\t\t * Message is too long; just read as much of it as we\n\t\t * can into the buffer provided, and discard the rest.\n\t\t */\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\tDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(remote_errbuf, PCAP_ERRBUF_SIZE, \"Read of error message from client failed: %s\", errbuf);\n\t\t\tDIAG_ON_FORMAT_TRUNCATION\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\\0';\n\n#ifdef _WIN32\n\t\t/*\n\t\t * If we're not in UTF-8 mode, convert it to the local\n\t\t * code page.\n\t\t */\n\t\tif (!pcapint_utf_8_mode)\n\t\t\tutf_8_to_acp_truncated(remote_errbuf);\n#endif\n\n\t\t/*\n\t\t * Throw away the rest.\n\t\t */\n\t\t(void)rpcap_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1), remote_errbuf);\n\t}\n\telse if (plen == 0)\n\t{\n\t\t/* Empty error string. */\n\t\tremote_errbuf[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, plen,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\tDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(remote_errbuf, PCAP_ERRBUF_SIZE, \"Read of error message from client failed: %s\", errbuf);\n\t\t\tDIAG_ON_FORMAT_TRUNCATION\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[plen] = '\\0';\n\t}\n}\n\n/*\n * Discard data from a connection.\n * Mostly used to discard wrong-sized messages.\n * Returns 0 on success, logs a message and returns -1 on a network\n * error.\n */\nstatic int rpcap_discard(PCAP_SOCKET sock, SSL *ssl, uint32_t len, char *errbuf)\n{\n\tif (len != 0)\n\t{\n\t\tif (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Read bytes into the pcap_t's buffer until we have the specified\n * number of bytes read or we get an error or interrupt indication.\n */\nstatic int rpcap_read_packet_msg(struct pcap_rpcap const *rp, pcap_t *p, size_t size)\n{\n\tu_char *bp;\n\tu_int cc;\n\tint bytes_read;\n\n\tbp = p->bp;\n\tcc = p->cc;\n\n\t/*\n\t * Loop until we have the amount of data requested or we get\n\t * an error or interrupt.\n\t */\n\twhile (cc < size)\n\t{\n\t\t/*\n\t\t * We haven't read all of the packet header yet.\n\t\t * Read what remains, which could be all of it.\n\t\t */\n\t\tbytes_read = sock_recv(rp->rmt_sockdata, rp->data_ssl, bp, size - cc,\n\t\t    SOCK_RECEIVEALL_NO|SOCK_EOF_IS_ERROR, p->errbuf,\n\t\t    PCAP_ERRBUF_SIZE);\n\n\t\tif (bytes_read == -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Network error.  Update the read pointer and\n\t\t\t * byte count, and return an error indication.\n\t\t\t */\n\t\t\tp->bp = bp;\n\t\t\tp->cc = cc;\n\t\t\treturn -1;\n\t\t}\n\t\tif (bytes_read == -3)\n\t\t{\n\t\t\t/*\n\t\t\t * Interrupted receive.  Update the read\n\t\t\t * pointer and byte count, and return\n\t\t\t * an interrupted indication.\n\t\t\t */\n\t\t\tp->bp = bp;\n\t\t\tp->cc = cc;\n\t\t\treturn -3;\n\t\t}\n\t\tif (bytes_read == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * EOF - server terminated the connection.\n\t\t\t * Update the read pointer and byte count, and\n\t\t\t * return an error indication.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The server terminated the connection.\");\n\t\t\treturn -1;\n\t\t}\n\t\tbp += bytes_read;\n\t\tcc += bytes_read;\n\t}\n\tp->bp = bp;\n\tp->cc = cc;\n\treturn 0;\n}\n"
        },
        {
          "name": "pcap-rpcap.h",
          "type": "blob",
          "size": 2.1943359375,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef pcap_rpcap_h\n#define\tpcap_rpcap_h\n\n/*\n * Internal interfaces for \"pcap_open()\".\n */\npcap_t\t*pcap_open_rpcap(const char *source, int snaplen, int flags,\n    int read_timeout, struct pcap_rmtauth *auth, char *errbuf);\n\n/*\n * Internal interfaces for \"pcap_findalldevs_ex()\".\n */\nint\tpcap_findalldevs_ex_remote(const char *source,\n    struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf);\n\n#endif\n"
        },
        {
          "name": "pcap-savefile.manfile.in",
          "type": "blob",
          "size": 7.3408203125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP-SAVEFILE @MAN_FILE_FORMATS@ \"6 Jan 2025\"\n.SH NAME\npcap-savefile \\- libpcap savefile format\n.SH DESCRIPTION\nNOTE: applications and libraries should, if possible, use libpcap to\nread savefiles, rather than having their own code to read savefiles.\nIf, in the future, a new file format is supported by libpcap,\napplications and libraries using libpcap to read savefiles will be able\nto read the new format of savefiles, but applications and libraries\nusing their own code to read savefiles will have to be changed to\nsupport the new file format.\n.PP\n``Savefiles'' read and written by libpcap and applications using libpcap\nstart with a per-file header.  The format of the per-file header is:\n.RS\n.TS\nbox;\nc s\nc | c\nc s.\nMagic number\n_\nMajor version\tMinor version\n_\nReserved1\n_\nReserved2\n_\nSnapshot length\n_\nLink-layer header type and additional information\n.TE\n.RE\n.PP\nThe per-file header length is 24 octets.\n.PP\nAll fields in the per-file header are in the byte order of the host\nwriting the file.  Normally, the first field in the per-file header is a\n4-byte magic number, with the value\n.BR 0xa1b2c3d4 .\nThe magic number, when\nread by a host with the same byte order as the host that wrote the file,\nwill have the value\n.BR 0xa1b2c3d4 ,\nand, when read by a host with the\nopposite byte order as the host that wrote the file, will have the value\n.BR 0xd4c3b2a1 .\nThat allows software reading the file to determine whether\nthe byte order of the host that wrote the file is the same as the byte\norder of the host on which the file is being read, and thus whether the\nvalues in the per-file and per-packet headers need to be byte-swapped.\n.PP\nIf the magic number has the value\n.B 0xa1b23c4d\n(with the two nibbles of\nthe two lower-order bytes of the magic number swapped), which would be\nread as\n.B 0xa1b23c4d\nby a host with the same byte order as the host that\nwrote the file and as\n.B 0x4d3cb2a1\nby a host with the opposite byte order\nas the host that wrote the file, the file format is the same as for\nregular files, except that the time stamps for packets are given in\nseconds and nanoseconds rather than seconds and microseconds.\n.PP\nFollowing this are:\n.IP\nA 2-byte file format major version number; the current version number is\n2 (big-endian 0x00 0x02 or little-endian 0x02 0x00).\n.IP\nA 2-byte file format minor version number; the current version number is\n4 (big-endian 0x00 0x04 or little-endian 0x04 0x00).\n.IP\nA 4-byte not used - SHOULD be filled with 0 by pcap file writers, and MUST\nbe ignored by pcap file readers.  This value was documented by some older\nimplementations as \"gmt to local correction\" or \"time zone offset\".\nSome older pcap file writers stored non-zero values in this field.\n.IP\nA 4-byte not used - SHOULD be filled with 0 by pcap file writers, and MUST\nbe ignored by pcap file readers.  This value was documented by some older\nimplementations as \"accuracy of timestamps\".  Some older pcap file\nwriters stored non-zero values in this field.\n.IP\nA 4-byte number giving the \"snapshot length\" of the capture; packets\nlonger than the snapshot length are truncated to the snapshot length, so\nthat, if the snapshot length is\n.IR N ,\nonly the first\n.I N\nbytes of a packet longer than\n.I N\nbytes will be saved in the capture.\n.IP\nA 4-byte number giving the link-layer header type for packets in the\ncapture and optional additional information.\n.IP\nThis format of this field is:\n.PP\n.nf\n                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|FCS len|R|P|     Reserved3     |        Link-layer type        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.fi\n.IP\nThe field is shown as if it were in the byte order of the host reading\nor writing the file, with bit 0 being the most-significant bit of the\nfield and bit 31 being the least-significant bit of the field.\n.IP\nLink-layer type (16 bits):\nA 16-bit value giving the link-layer header type for packets in the file;\nsee\n.BR pcap-linktype (@MAN_MISC_INFO@)\nfor the\n.B LINKTYPE_\nvalues that can appear in this field.\n.IP\nReserved3 (10 bits):\nnot used - MUST be set to zero by pcap writers, and MUST NOT be\ninterpreted by pcap readers; a reader SHOULD treat a non-zero value as\nan error.\n.IP\nP (1 bit):\nA bit that, if set, indicates that the Frame Check Sequence (FCS)\nlength value is present and, if not set, indicates that the FCS value is\nnot present.\n.IP\nR (1 bit):\nnot used - MUST be set to zero by pcap writers, and MUST NOT be\ninterpreted by pcap readers; a reader SHOULD treat a non-zero value as\nan error.\n.IP\nFCS len (4 bits):\nA 4-bit unsigned value giving the number of 16-bit (2-octet) words\nof FCS that are appended to each packet, if the P bit is set; if the P\nbit is not set, and the FCS length is not indicated by the link-layer\ntype value, the FCS length is unknown.  The valid values of the FCS len\nfield are between 0 and 15; Ethernet, for example, would have an FCS\nlength value of 2, corresponding to a 4-octet FCS.\n.PP\nFollowing the per-file header are zero or more packets; each packet\nbegins with a per-packet header, which is immediately followed by the\nraw packet data.  The format of the per-packet header is:\n.RS\n.TS\nbox;\nc.\nTime stamp, seconds value\n_\nTime stamp, microseconds or nanoseconds value\n_\nLength of captured packet data\n_\nUn-truncated length of the packet data\n.TE\n.RE\n.PP\nThe per-packet header length is 16 octets.\n.PP\nAll fields in the per-packet header are in the byte order of the host\nwriting the file.  The per-packet header begins with a time stamp giving\nthe approximate time the packet was captured; the time stamp consists of\na 4-byte value, giving the time in seconds since January 1, 1970,\n00:00:00 UTC, followed by a 4-byte value, giving the time in\nmicroseconds or nanoseconds since that second, depending on the magic\nnumber in the file header.  Following that are a 4-byte value giving the\nnumber of bytes of captured data that follow the per-packet header and a\n4-byte value giving the number of bytes that would have been present had\nthe packet not been truncated by the snapshot length.  The two lengths\nwill be equal if the number of bytes of packet data are less than or\nequal to the snapshot length.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap-snf.c",
          "type": "blob",
          "size": 17.4228515625,
          "content": "#include <config.h>\n\n#ifndef _WIN32\n#include <sys/param.h>\n#endif /* !_WIN32 */\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h> /* for INT_MAX */\n\n#ifndef _WIN32\n#include <netinet/in.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#endif /* !_WIN32 */\n\n#include <snf.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-snf.h\"\n\n/*\n * Private data for capturing on SNF devices.\n */\nstruct pcap_snf {\n\tsnf_handle_t snf_handle; /* opaque device handle */\n\tsnf_ring_t   snf_ring;   /* opaque device ring handle */\n\tsnf_inject_t snf_inj;    /* inject handle, if inject is used */\n\tint          snf_timeout;\n\tint          snf_boardnum;\n};\n\nstatic int\nsnf_set_datalink(pcap_t *p, int dlt)\n{\n\tp->linktype = dlt;\n\treturn (0);\n}\n\nstatic int\nsnf_pcap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct snf_ring_stats stats;\n\tstruct pcap_snf *snfps = p->priv;\n\tint rc;\n\n\tif ((rc = snf_ring_getstats(snfps->snf_ring, &stats))) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    rc, \"snf_get_stats\");\n\t\treturn PCAP_ERROR;\n\t}\n\tps->ps_recv = stats.ring_pkt_recv + stats.ring_pkt_overflow;\n\tps->ps_drop = stats.ring_pkt_overflow;\n\tps->ps_ifdrop = stats.nic_pkt_overflow + stats.nic_pkt_bad;\n\treturn 0;\n}\n\nstatic void\nsnf_platform_cleanup(pcap_t *p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n\tif (ps->snf_inj)\n\t\tsnf_inject_close(ps->snf_inj);\n\tsnf_ring_close(ps->snf_ring);\n\tsnf_close(ps->snf_handle);\n\tpcapint_cleanup_live_common(p);\n}\n\nstatic int\nsnf_getnonblock(pcap_t *p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n\treturn (ps->snf_timeout == 0);\n}\n\nstatic int\nsnf_setnonblock(pcap_t *p, int nonblock)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n\tif (nonblock)\n\t\tps->snf_timeout = 0;\n\telse {\n\t\tif (p->opt.timeout <= 0)\n\t\t\tps->snf_timeout = -1; /* forever */\n\t\telse\n\t\t\tps->snf_timeout = p->opt.timeout;\n\t}\n\treturn (0);\n}\n\n#define _NSEC_PER_SEC 1000000000\n\nstatic inline\nstruct timeval\nsnf_timestamp_to_timeval(const int64_t ts_nanosec, const int tstamp_precision)\n{\n\tstruct timeval tv;\n\tlong tv_nsec;\n\tstatic const struct timeval zero_timeval;\n\n        if (ts_nanosec == 0)\n                return zero_timeval;\n\n\ttv.tv_sec = ts_nanosec / _NSEC_PER_SEC;\n\ttv_nsec = (ts_nanosec % _NSEC_PER_SEC);\n\n\t/* libpcap expects tv_usec to be nanos if using nanosecond precision. */\n\tif (tstamp_precision == PCAP_TSTAMP_PRECISION_NANO)\n\t\ttv.tv_usec = tv_nsec;\n\telse\n\t\ttv.tv_usec = tv_nsec / 1000;\n\n\treturn tv;\n}\n\nstatic int\nsnf_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_snf *ps = p->priv;\n\tstruct pcap_pkthdr hdr;\n\tint err, caplen, n;\n\tstruct snf_recv_req req;\n\tint timeout;\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(cnt))\n\t\tcnt = INT_MAX;\n\n\tn = 0;\n\ttimeout = ps->snf_timeout;\n\twhile (n < cnt) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t} else {\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\n\t\terr = snf_ring_recv(ps->snf_ring, timeout, &req);\n\n\t\tif (err) {\n\t\t\tif (err == EBUSY || err == EAGAIN) {\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t\telse if (err == EINTR) {\n\t\t\t\ttimeout = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, err, \"%s\", __func__);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * In this libpcap module the two length arguments of\n\t\t * pcapint_filter() (the wire length and the captured length)\n\t\t * are always equal because SNF captures full packets.\n\t\t *\n\t\t * The wire and the capture length of this packet is\n\t\t * req.length, the snapshot length configured for this pcap\n\t\t * handle is p->snapshot.\n\t\t */\n\t\tcaplen = req.length;\n\t\tif (caplen > p->snapshot)\n\t\t\tcaplen = p->snapshot;\n\n\t\tif ((p->fcode.bf_insns == NULL) ||\n\t\t     pcapint_filter(p->fcode.bf_insns, req.pkt_addr, req.length, req.length)) {\n\t\t\thdr.ts = snf_timestamp_to_timeval(req.timestamp, p->opt.tstamp_precision);\n\t\t\thdr.caplen = caplen;\n\t\t\thdr.len = req.length;\n\t\t\tcallback(user, &hdr, req.pkt_addr);\n\t\t\tn++;\n\t\t}\n\n\t\t/* After one successful packet is received, we won't block\n\t\t* again for that timeout. */\n\t\tif (timeout != 0)\n\t\t\ttimeout = 0;\n\t}\n\treturn (n);\n}\n\nstatic int\nsnf_inject(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_snf *ps = p->priv;\n\tint rc;\n\tif (ps->snf_inj == NULL) {\n\t\trc = snf_inject_open(ps->snf_boardnum, 0, &ps->snf_inj);\n\t\tif (rc) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    rc, \"snf_inject_open\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\trc = snf_inject_send(ps->snf_inj, -1, 0, buf, size);\n\tif (!rc) {\n\t\treturn (size);\n\t}\n\telse {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    rc, \"snf_inject_send\");\n\t\treturn PCAP_ERROR;\n\t}\n}\n\nstatic int\nsnf_activate(pcap_t* p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\tconst char *nr = NULL;\n\tint err;\n\tint flags = -1, ring_id = -1;\n\n\t/* In Libpcap, we set pshared by default if NUM_RINGS is set to > 1.\n\t * Since libpcap isn't thread-safe */\n\tif ((nr = getenv(\"SNF_FLAGS\")) && *nr)\n\t\tflags = strtol(nr, NULL, 0);\n\telse if ((nr = getenv(\"SNF_NUM_RINGS\")) && *nr && atoi(nr) > 1)\n\t\tflags = SNF_F_PSHARED;\n\telse\n\t\tnr = NULL;\n\n\n        /* Allow pcap_set_buffer_size() to set dataring_size.\n         * Default is zero which allows setting from env SNF_DATARING_SIZE.\n         * pcap_set_buffer_size() is in bytes while snf_open() accepts values\n         * between 0 and 1048576 in Megabytes. Values in this range are\n         * mapped to 1MB.\n         */\n\terr = snf_open(ps->snf_boardnum,\n\t\t\t0, /* let SNF API parse SNF_NUM_RINGS, if set */\n\t\t\tNULL, /* default RSS, or use SNF_RSS_FLAGS env */\n                        (p->opt.buffer_size > 0 && p->opt.buffer_size < 1048576) ? 1048576 : p->opt.buffer_size, /* default to SNF_DATARING_SIZE from env */\n\t\t\tflags, /* may want pshared */\n\t\t\t&ps->snf_handle);\n\tif (err != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_open failed\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif ((nr = getenv(\"SNF_PCAP_RING_ID\")) && *nr) {\n\t\tring_id = (int) strtol(nr, NULL, 0);\n\t}\n\terr = snf_ring_open_id(ps->snf_handle, ring_id, &ps->snf_ring);\n\tif (err != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_ring_open_id(ring=%d) failed\", ring_id);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.timeout <= 0)\n\t\tps->snf_timeout = -1;\n\telse\n\t\tps->snf_timeout = p->opt.timeout;\n\n\terr = snf_start(ps->snf_handle);\n\tif (err != 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_start failed\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * \"select()\" and \"poll()\" don't work on snf descriptors.\n\t */\n#ifndef _WIN32\n\tp->selectable_fd = -1;\n#endif /* !_WIN32 */\n\tp->linktype = DLT_EN10MB;\n\tp->read_op = snf_read;\n\tp->inject_op = snf_inject;\n\tp->setfilter_op = pcapint_install_bpf_program;\n\tp->setdirection_op = NULL; /* Not implemented.*/\n\tp->set_datalink_op = snf_set_datalink;\n\tp->getnonblock_op = snf_getnonblock;\n\tp->setnonblock_op = snf_setnonblock;\n\tp->stats_op = snf_pcap_stats;\n\tp->cleanup_op = snf_platform_cleanup;\n\tps->snf_inj = NULL;\n\treturn 0;\n}\n\n#define MAX_DESC_LENGTH 128\nint\nsnf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tpcap_if_t *dev;\n#ifdef _WIN32\n\tstruct sockaddr_in addr;\n#endif\n\tstruct snf_ifaddrs *ifaddrs, *ifa;\n\tchar name[MAX_DESC_LENGTH];\n\tchar desc[MAX_DESC_LENGTH];\n\tint allports = 0, merge = 0;\n\tconst char *nr = NULL;\n\n\tif (snf_init(SNF_VERSION_API)) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snf_init\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL)\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snf_getifaddrs\");\n\t\treturn PCAP_ERROR;\n\t}\n\tif ((nr = getenv(\"SNF_FLAGS\")) && *nr) {\n\t\terrno = 0;\n\t\tmerge = strtol(nr, NULL, 0);\n\t\tif (errno) {\n\t\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"%s: SNF_FLAGS is not a valid number\", __func__);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tmerge = merge & SNF_F_AGGREGATE_PORTMASK;\n\t}\n\n\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->snf_ifa_next) {\n\t\t/*\n\t\t * Myricom SNF adapter ports may appear as regular\n\t\t * network interfaces, which would already have been\n\t\t * added to the list of adapters by pcapint_platform_finddevs()\n\t\t * regardless of whether this build is SNF-only or not.\n\t\t *\n\t\t * Our create routine intercepts pcap_create() calls for\n\t\t * those interfaces and arranges that they will be\n\t\t * opened using the SNF API instead.\n\t\t *\n\t\t * So if we already have an entry for the device, we\n\t\t * don't add an additional entry for it, we just\n\t\t * update the description for it, if any, to indicate\n\t\t * which snfN device it is.  Otherwise, we add an entry\n\t\t * for it.\n\t\t *\n\t\t * In either case, if SNF_F_AGGREGATE_PORTMASK is set\n\t\t * in SNF_FLAGS, we add this port to the bitmask\n\t\t * of ports, which we use to generate a device\n\t\t * we can use to capture on all ports.\n\t\t *\n\t\t * Generate the description string.  If port aggregation\n\t\t * is set, use 2^{port number} as the unit number,\n\t\t * rather than {port number}.\n\t\t */\n\t\t(void)snprintf(desc, MAX_DESC_LENGTH,\n\t\t    \"Myricom %ssnf%u, Rx rings: %u, Tx handles: %u\",\n\t\t    merge ? \"Merge Bitmask Port \" : \"\",\n\t\t    merge ? 1U << ifa->snf_ifa_portnum : ifa->snf_ifa_portnum,\n\t\t    ifa->snf_ifa_maxrings,\n\t\t    ifa->snf_ifa_maxinject);\n\t\t/*\n\t\t * Add the port to the bitmask.\n\t\t */\n\t\tif (merge)\n\t\t\tallports |= 1 << ifa->snf_ifa_portnum;\n\t\t/*\n\t\t * See if there's already an entry for the device\n\t\t * with the name ifa->snf_ifa_name.\n\t\t */\n\t\tdev = pcapint_find_dev(devlistp, ifa->snf_ifa_name);\n\t\tif (dev != NULL) {\n\t\t\t/*\n\t\t\t * Yes.  Update its description.\n\t\t\t *\n\t\t\t * This is the expected and the most likely result.\n\t\t\t * In this case the device's .flags already has the\n\t\t\t * PCAP_IF_UP and PCAP_IF_RUNNING bits mapped from the\n\t\t\t * regular network interface flags, as well as the\n\t\t\t * PCAP_IF_CONNECTION_STATUS bits mapped from the\n\t\t\t * current struct snf_ifaddrs; .addresses has already\n\t\t\t * been populated.\n\t\t\t */\n\t\t\tchar *desc_str;\n\n\t\t\tdesc_str = strdup(desc);\n\t\t\tif (desc_str == NULL) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"%s strdup\", __func__);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tfree(dev->description);\n\t\t\tdev->description = desc_str;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.  Add an entry for it.\n\t\t\t *\n\t\t\t * Possibly a race condition.  In this case the device\n\t\t\t * will still work, but will not have addresses, also\n\t\t\t * snf_ifaddrs includes the operational (i.e. link\n\t\t\t * detect), but not the administrative state of the\n\t\t\t * port.\n\t\t\t */\n\t\t\tconst bpf_u_int32 flags =\n\t\t\t    ifa->snf_ifa_link_state == SNF_LINK_UP ?\n\t\t\t    PCAP_IF_CONNECTION_STATUS_CONNECTED :\n\t\t\t    PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\t\tdev = pcapint_add_dev(devlistp, ifa->snf_ifa_name, flags, desc,\n\t\t\t    errbuf);\n\t\t\tif (dev == NULL)\n\t\t\t\treturn PCAP_ERROR;\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * On Windows, fill in IP# from device name\n\t\t\t */\n\t\t\tint ret = inet_pton(AF_INET, dev->name, &addr.sin_addr);\n                        if (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * Successful conversion of device name\n\t\t\t\t * to IPv4 address.\n\t\t\t\t */\n\t\t\t\taddr.sin_family = AF_INET;\n\t\t\t\tif (pcapint_add_addr_to_dev(dev, &addr, sizeof(addr),\n\t\t\t\t    NULL, 0, NULL, 0, NULL, 0, errbuf) == -1)\n\t\t\t\t\treturn PCAP_ERROR;\n                        } else if (ret == -1) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"%s inet_pton\", __func__);\n                                return PCAP_ERROR;\n                        }\n#endif // _WIN32\n\t\t}\n\t}\n\tsnf_freeifaddrs(ifaddrs);\n\t/*\n\t * Create a snfX entry if port aggregation is enabled\n\t */\n\tif (merge) {\n\t\t/*\n\t\t * Add a new entry with all ports bitmask\n\t\t */\n\t\t(void)snprintf(name,MAX_DESC_LENGTH,\"snf%d\",allports);\n\t\t(void)snprintf(desc,MAX_DESC_LENGTH,\"Myricom Merge Bitmask All Ports snf%d\",\n\t\t\tallports);\n\t\t/*\n\t\t * XXX - is there any notion of \"up\" and \"running\" that\n\t\t * would apply to this device, given that it handles\n\t\t * multiple ports?\n\t\t *\n\t\t * Presumably, there's no notion of \"connected\" vs.\n\t\t * \"disconnected\", as \"is this plugged into a network?\"\n\t\t * would be a per-port property.\n\t\t */\n\t\tif (pcapint_add_dev(devlistp, name,\n\t\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, desc,\n\t\t    errbuf) == NULL)\n\t\t\treturn PCAP_ERROR;\n\t\t/*\n\t\t * XXX - should we give it a list of addresses with all\n\t\t * the addresses for all the ports?\n\t\t */\n\t}\n\n\treturn 0;\n}\n\n/*\n * If an SNF device exists for the given regular network interface name, copy\n * its struct snf_ifaddrs to the provided pointer if the pointer is not NULL.\n *\n * Return:\n * 0 if such SNF device does not exist\n * 1 if such SNF device exists\n * PCAP_ERROR on an SNF API error\n */\nstatic int\nsnf_device_exists(const char *device, struct snf_ifaddrs *out, char *errbuf)\n{\n\tif (snf_init(SNF_VERSION_API)) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snf_init\");\n\t\treturn PCAP_ERROR;\n\t}\n\tstruct snf_ifaddrs *ifaddrs;\n\tif (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snf_getifaddrs\");\n\t\treturn PCAP_ERROR;\n\t}\n\tint ret = 0;\n\tfor (struct snf_ifaddrs *ifa = ifaddrs; ifa; ifa = ifa->snf_ifa_next)\n\t\tif (! strcmp(device, ifa->snf_ifa_name)) {\n\t\t\tret = 1;\n\t\t\tif (out)\n\t\t\t\t*out = *ifa;\n\t\t\tbreak;\n\t\t}\n\tsnf_freeifaddrs(ifaddrs);\n\treturn ret;\n}\n\n/*\n * If an SNF device exists for the given regular network interface name,\n * replace the PCAP_IF_CONNECTION_STATUS part of the provided flags with the\n * link state from the SNF API.\n *\n * The matter is, for a regular network interface that is administratively\n * down the operational (link) state appears -- at least on Linux -- down and\n * an attempt to capture on the interface would fail with ENETDOWN.  The SNF\n * API works differently: regardless of the administrative state it allows to\n * use an SNF device and reports the same link state as the device's \"link up\"\n * LED.\n *\n * Return:\n * 0 if such SNF device does not exist\n * 1 if such SNF device exists\n * PCAP_ERROR on an SNF API error\n */\nint\nsnf_get_if_flags(const char *device, bpf_u_int32 *flags, char *errbuf)\n{\n\tstruct snf_ifaddrs ifa;\n\tint exists = snf_device_exists(device, &ifa, errbuf);\n\tif (exists <= 0)\n\t\treturn exists;\n\n\t*flags &= ~PCAP_IF_CONNECTION_STATUS;\n\tswitch (ifa.snf_ifa_link_state) {\n\tcase SNF_LINK_UP:\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t\tbreak;\n\tcase SNF_LINK_DOWN:\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid snf_ifa_link_state value %u\",\n\t\t    ifa.snf_ifa_link_state);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 1;\n}\n\npcap_t *\nsnf_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\tint boardnum = -1;\n\tstruct snf_ifaddrs ifa;\n\tstruct pcap_snf *ps;\n\n\t/*\n\t * Match a given interface name to our list of interface names, from\n\t * which we can obtain the intended board number\n\t */\n\tint exists = snf_device_exists(device, &ifa, ebuf);\n\tif (exists < 0) {\n\t\t/* Can't use the API, so no SNF devices */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\tif (! exists) {\n\t\t/*\n\t\t * If we can't find the device by name, support the name \"snfX\"\n\t\t * and \"snf10gX\" where X is the board number.\n\t\t */\n\t\tif (sscanf(device, \"snf10g%d\", &boardnum) != 1 &&\n\t\t    sscanf(device, \"snf%d\", &boardnum) != 1) {\n\t\t\t/* Nope, not a supported name */\n\t\t\t*is_ours = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_snf);\n\tif (p == NULL)\n\t\treturn NULL;\n\tps = p->priv;\n\n\t/*\n\t * We support microsecond and nanosecond time stamps.\n\t */\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"malloc\");\n\t\tpcap_close(p);\n\t\treturn NULL;\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\tp->tstamp_precision_count = 2;\n\n\tp->activate_op = snf_activate;\n\tps->snf_boardnum = boardnum;\n\treturn p;\n}\n\n#ifdef SNF_ONLY\n/*\n * This libpcap build supports only SNF cards, not regular network\n * interfaces..\n */\n\n/*\n * There are no regular interfaces, just SNF interfaces.\n */\nstatic int\ncan_be_bound(const char *name)\n{\n\tchar dummy[PCAP_ERRBUF_SIZE];\n\treturn snf_device_exists(name, NULL, dummy) == 1;\n}\n\n/*\n * Even though this is an SNF-only build, use the regular \"findalldevs\" code\n * for device enumeration, but pick only network interfaces that correspond to\n * SNF devices.  Use SNF-specific interpretation of device flags.\n */\nint\npcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    snf_get_if_flags);\n}\n\n/*\n * Attempts to open a regular interface fail.\n */\npcap_t *\npcapint_create_interface(const char *device _U_, char *errbuf)\n{\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, PCAP_ENODEV_MESSAGE, \"SNF\");\n\treturn NULL;\n}\n\n/*\n * Libpcap version string.\n */\nconst char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (SNF-only)\");\n}\n#endif\n"
        },
        {
          "name": "pcap-snf.h",
          "type": "blob",
          "size": 0.1650390625,
          "content": "pcap_t *snf_create(const char *, char *, int *);\nint snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf);\nint snf_get_if_flags(const char *, bpf_u_int32 *, char *);\n"
        },
        {
          "name": "pcap-tstamp.manmisc.in",
          "type": "blob",
          "size": 9.37109375,
          "content": ".\\\"\n.\\\" Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP-TSTAMP @MAN_MISC_INFO@ \"1 October 2024\"\n.SH NAME\npcap-tstamp \\- packet time stamps in libpcap\n.SH DESCRIPTION\nWhen capturing traffic, each packet is given a time stamp representing,\nfor incoming packets, the arrival time of the packet and, for outgoing\npackets, the transmission time of the packet.  This time is an\napproximation of the arrival or transmission time.  If it is supplied by\nthe operating system running on the host on which the capture is being\ndone, there are several reasons why it might not precisely represent the\narrival or transmission time:\n.IP\nif the time stamp is applied to the packet when the networking stack\nreceives the packet, the networking stack might not see the packet until\nan interrupt is delivered for the packet or a timer event causes the\nnetworking device driver to poll for packets, and the time stamp might\nnot be applied until the packet has had some processing done by other\ncode in the networking stack, so there might be a significant delay\nbetween the time when the last bit of the packet is received by the\ncapture device and when the networking stack time-stamps the packet;\n.IP\nthe timer used to generate the time stamps might have low resolution,\nfor example, it might be a timer updated once per host operating system\ntimer tick, with the host operating system timer ticking once every few\nmilliseconds;\n.IP\na high-resolution timer might use a counter that runs at a rate\ndependent on the processor clock speed, and that clock speed might be\nadjusted upwards or downwards over time and the timer might not be able\nto compensate for all those adjustments;\n.IP\nthe host operating system's clock might be adjusted over time to match a\ntime standard to which the host is being synchronized, which might be\ndone by temporarily slowing down or speeding up the clock or by making a\nsingle adjustment;\n.IP\ndifferent CPU cores on a multi-core or multi-processor system might be\nrunning at different speeds, or might not have time counters all\nsynchronized, so packets time-stamped by different cores might not have\nconsistent time stamps;\n.IP\nsome time sources, such as those that supply POSIX \"seconds since the\nEpoch\" time, do not count leap seconds, meaning that the seconds\nportion\n.RB ( tv_sec )\nof the time stamp might not be incremented for a leap second, so that\nthe fraction-of-a-second part of the time stamp might roll over past\nzero but the second part would not change, or the clock might run\nslightly more slowly for a period before the leap second.\n.LP\nFor these reasons, time differences between packet time stamps will not\nnecessarily accurately reflect the time differences between the receipt\nor transmission times of the packets.\n.LP\nIn addition, packets time-stamped by different cores might be\ntime-stamped in one order and added to the queue of packets for libpcap\nto read in another order, so time stamps might not be monotonically\nincreasing.\n.LP\nSome capture devices on some platforms can provide time stamps for\npackets; those time stamps are usually high-resolution time stamps, and\nare usually applied to the packet when the first or last bit of the\npacket arrives, and are thus more accurate than time stamps provided by\nthe host operating system.  Those time stamps might not, however, be\nsynchronized with the host operating system's clock, so that, for\nexample, the time stamp of a packet might not correspond to the time\nstamp of an event on the host triggered by the arrival of that packet.\nIf they are synchronized with the host operating system's clock, some of\nthe issues listed above with time stamps supplied by the host operating\nsystem may also apply to time stamps supplied by the capture device.\n.LP\nDepending on the capture device and the software on the host, libpcap\nmight allow different types of time stamp to be used.  The\n.BR pcap_list_tstamp_types (3PCAP)\nroutine provides, for a packet capture handle created by\n.BR pcap_create (3PCAP)\nbut not yet activated by\n.BR pcap_activate (3PCAP),\na list of time stamp types supported by the capture device for that\nhandle.\nThe list might be empty, in which case no choice of time stamp type is\noffered for that capture device.  If the list is not empty, the\n.BR pcap_set_tstamp_type (3PCAP)\nroutine can be used after a\n.BR pcap_create ()\ncall and before a\n.BR pcap_activate ()\ncall to specify the type of time stamp to be used on the device.\nThe time stamp types are listed here; the first value is the\n.B #define\nto use in code, the second value is the value returned by\n.BR pcap_tstamp_type_val_to_name (3PCAP)\nand accepted by\n.BR pcap_tstamp_type_name_to_val (3PCAP).\n.RS 5\n.TP 5\n.BR PCAP_TSTAMP_HOST \" - \" host\nTime stamp provided by the host on which the capture is being done.  The\nprecision of this time stamp is unspecified; it might or might not be\nsynchronized with the host operating system's clock.\n.TP 5\n.BR PCAP_TSTAMP_HOST_LOWPREC \" - \" host_lowprec\nTime stamp provided by the host on which the capture is being done.\nThis is a low-precision time stamp, synchronized with the host operating\nsystem's clock.\n.TP 5\n.BR PCAP_TSTAMP_HOST_HIPREC \" - \" host_hiprec\nTime stamp provided by the host on which the capture is being done.\nThis is a high-precision time stamp, synchronized with the host\noperating system's clock. It might be more expensive to fetch than\n.BR PCAP_TSTAMP_HOST_LOWPREC .\n.TP 5\n.BR PCAP_TSTAMP_HOST_HIPREC_UNSYNCED \" - \" host_hiprec_unsynced\nTime stamp provided by the host on which the capture is being done.\nThis is a high-precision time stamp, not synchronized with the host\noperating system's clock. It might be more expensive to fetch than\n.BR PCAP_TSTAMP_HOST_LOWPREC .\n.TP 5\n.BR PCAP_TSTAMP_ADAPTER \" - \" adapter\nTime stamp provided by the network adapter on which the capture is being\ndone.  This is a high-precision time stamp, synchronized with the host\noperating system's clock.\n.TP 5\n.BR PCAP_TSTAMP_ADAPTER_UNSYNCED \" - \" adapter_unsynced\nTime stamp provided by the network adapter on which the capture is being\ndone.  This is a high-precision time stamp; it is not synchronized with\nthe host operating system's clock.\n.RE\n.LP\nTime stamps synchronized with the system clock can go backwards, as the\nsystem clock can go backwards. If a clock is not in sync with the\nsystem clock, that could be because the system clock isn't keeping\naccurate time, because the other clock isn't keeping accurate time, or\nboth.\n.LP\nHost-provided time stamps generally correspond to the time when the\ntime-stamping code sees the packet; this could be some unknown amount of\ntime after the first or last bit of the packet is received by the\nnetwork adapter, due to batching of interrupts for packet arrival,\nqueueing delays, etc..\n.LP\nBy default, when performing a live capture or reading from a savefile,\ntime stamps are supplied as seconds since January 1, 1970, 00:00:00 UTC,\nand microseconds since that seconds value, even if higher-resolution\ntime stamps are available from the capture device or in the savefile.\nIf, when reading a savefile, the time stamps in the file have a higher\nresolution than one microsecond, the additional digits of resolution are\ndiscarded.\n.LP\nThe\n.BR pcap_set_tstamp_precision (3PCAP)\nroutine can be used after a\n.BR pcap_create ()\ncall and before a\n.BR pcap_activate ()\ncall to specify the resolution of the time stamps to get for the device.\nIf the hardware or software cannot supply a higher-resolution time\nstamp, the\n.BR pcap_set_tstamp_precision ()\ncall will fail, and the time stamps supplied after the\n.BR pcap_activate ()\ncall will have microsecond resolution.\n.LP\nWhen opening a savefile, the\n.BR \\%pcap_open_offline_with_tstamp_precision (3PCAP)\nand\n.BR \\%pcap_fopen_offline_with_tstamp_precision (3PCAP)\nroutines can be used to specify the resolution of time stamps to be read\nfrom the file; if the time stamps in the file have a lower resolution,\nthe fraction-of-a-second portion of the time stamps will be scaled to\nthe specified resolution.\n.LP\nThe\n.BR pcap_get_tstamp_precision (3PCAP)\nroutine returns the resolution of time stamps that will be supplied;\nwhen capturing packets, this does not reflect the actual precision of\nthe time stamp supplied by the hardware or operating system and, when\nreading a savefile, this does not indicate the actual precision of time\nstamps in the file.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap-types.h",
          "type": "blob",
          "size": 1.9287109375,
          "content": "/*\n * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2009 CACE Technologies, Inc. Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef pcap_types_h\n#define pcap_types_h\n\n/*\n * Get u_int defined, by hook or by crook.\n */\n#ifdef _WIN32\n  /*\n   * This defines u_int.\n   */\n  #include <winsock2.h>\n#else /* _WIN32 */\n  /*\n   * This defines u_int, among other types.\n   */\n  #include <sys/types.h>\n#endif\n\n#endif /* pcap_types_h */\n"
        },
        {
          "name": "pcap-usb-linux-common.h",
          "type": "blob",
          "size": 4.15625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * pcap-usb-linux-common.h - common code for everything that needs to\n * deal with Linux USB captures, whether live or in a capture file;\n * the later means that this is *not* Linux-only.\n */\n\n#include <limits.h>\n\n/*\n * Return the sum of the two u_int arguments if that sum fits in a u_int,\n * and return UINT_MAX otherwise.\n */\nstatic inline u_int\nu_int_sum(u_int a, u_int b)\n{\n\treturn (((b) <= UINT_MAX - (a)) ? (a) + (b) : UINT_MAX);\n}\n\n/*\n * Is this a completion event for an isochronous transfer?\n */\nstatic inline int\nis_isochronous_transfer_completion(const pcap_usb_header_mmapped *hdr)\n{\n\treturn (hdr->transfer_type == URB_ISOCHRONOUS &&\n\t    hdr->event_type == URB_COMPLETE &&\n\t    (hdr->endpoint_number & URB_TRANSFER_IN));\n}\n\n/*\n * Total length of the pseudo-header, including the isochronous\n * descriptors.\n */\nstatic inline uint32_t\niso_pseudo_header_len(const pcap_usb_header_mmapped *usb_hdr)\n{\n\treturn (sizeof(pcap_usb_header_mmapped) +\n\t    usb_hdr->ndesc * sizeof (usb_isodesc));\n}\n\n/*\n * Calculate the packet length for a \"this is complete\" incoming\n * isochronous transfer event.\n *\n * Calculating that from hdr->urb_len is not correct, because the\n * data is not contiguous, and the isochroous descriptors show how\n * it's scattered.\n */\nstatic inline u_int\nincoming_isochronous_transfer_completed_len(struct pcap_pkthdr *phdr,\n    const u_char *bp)\n{\n\tconst pcap_usb_header_mmapped *hdr;\n\tu_int bytes_left;\n\tconst usb_isodesc *descs;\n\tu_int pre_truncation_data_len;\n\n\t/*\n\t * All callers of this routine must ensure that pkth->caplen is\n\t * >= sizeof (pcap_usb_header_mmapped).\n\t */\n\tbytes_left = phdr->caplen;\n\tbytes_left -= sizeof (pcap_usb_header_mmapped);\n\n\thdr = (const pcap_usb_header_mmapped *) bp;\n\tdescs = (const usb_isodesc *) (bp + sizeof(pcap_usb_header_mmapped));\n\n\t/*\n\t * Find the end of the last chunk of data in the buffer\n\t * referred to by the isochronous descriptors; that indicates\n\t * how far into the buffer the data would have gone.\n\t *\n\t * Make sure we don't run past the end of the captured data\n\t * while processing the isochronous descriptors.\n\t */\n\tpre_truncation_data_len = 0;\n\tfor (uint32_t desc = 0;\n\t    desc < hdr->ndesc && bytes_left >= sizeof (usb_isodesc);\n\t    desc++, bytes_left -= sizeof (usb_isodesc)) {\n\t\tu_int desc_end;\n\n\t\tif (descs[desc].len != 0) {\n\t\t\t/*\n\t\t\t * Compute the end offset of the data\n\t\t\t * for this descriptor, i.e. the offset\n\t\t\t * of the byte after the data.  Clamp\n\t\t\t * the sum at UINT_MAX, so that it fits\n\t\t\t * in a u_int.\n\t\t\t */\n\t\t\tdesc_end = u_int_sum(descs[desc].offset,\n\t\t\t    descs[desc].len);\n\t\t\tif (desc_end > pre_truncation_data_len)\n\t\t\t\tpre_truncation_data_len = desc_end;\n\t\t}\n\t}\n\n\t/*\n\t * Return the sum of the total header length (memory-mapped\n\t * header and ISO descriptors) and the data length, clamped\n\t * to UINT_MAX.\n\t *\n\t * We've made sure that the number of descriptors is\n\t * <= USB_MAXDESC, so we know that the total size,\n\t * in bytes, of the descriptors fits in a 32-bit\n\t * integer.\n\t */\n\treturn (u_int_sum(iso_pseudo_header_len(hdr), pre_truncation_data_len));\n}\n"
        },
        {
          "name": "pcap-usb-linux.c",
          "type": "blob",
          "size": 26.296875,
          "content": "/*\n * Copyright (c) 2006 Paolo Abeni (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * USB sniffing API implementation for Linux platform\n * By Paolo Abeni <paolo.abeni@email.it>\n * Modifications: Kris Katterjohn <katterjohn@gmail.com>\n *\n */\n\n#include <config.h>\n\n#include \"pcap/usb.h\"\n#include \"pcap-int.h\"\n#include \"pcap-usb-linux.h\"\n#include \"pcap-usb-linux-common.h\"\n\n#include \"extract.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <string.h>\n#include <dirent.h>\n#include <byteswap.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/utsname.h>\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n/*\n * We might need <linux/compiler.h> to define __user for\n * <linux/usbdevice_fs.h>.\n */\n#ifdef HAVE_LINUX_COMPILER_H\n#include <linux/compiler.h>\n#endif /* HAVE_LINUX_COMPILER_H */\n#include <linux/usbdevice_fs.h>\n#endif /* HAVE_LINUX_USBDEVICE_FS_H */\n\n#include \"diag-control.h\"\n\n#define USB_IFACE \"usbmon\"\n\n#define USBMON_DEV_PREFIX \"usbmon\"\n#define USBMON_DEV_PREFIX_LEN\t(sizeof USBMON_DEV_PREFIX - 1)\n#define USB_LINE_LEN 4096\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define htols(s) s\n#define htoll(l) l\n#define htol64(ll) ll\n#else\n#define htols(s) bswap_16(s)\n#define htoll(l) bswap_32(l)\n#define htol64(ll) bswap_64(ll)\n#endif\n\nstruct mon_bin_stats {\n\tuint32_t queued;\n\tuint32_t dropped;\n};\n\nstruct mon_bin_get {\n\tpcap_usb_header *hdr;\n\tvoid *data;\n\tsize_t data_len;   /* Length of data (can be zero) */\n};\n\nstruct mon_bin_mfetch {\n\tint32_t *offvec;   /* Vector of events fetched */\n\tint32_t nfetch;    /* Number of events to fetch (out: fetched) */\n\tint32_t nflush;    /* Number of events to flush */\n};\n\n#define MON_IOC_MAGIC 0x92\n\n#define MON_IOCQ_URB_LEN _IO(MON_IOC_MAGIC, 1)\n#define MON_IOCX_URB  _IOWR(MON_IOC_MAGIC, 2, struct mon_bin_hdr)\n#define MON_IOCG_STATS _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)\n#define MON_IOCT_RING_SIZE _IO(MON_IOC_MAGIC, 4)\n#define MON_IOCQ_RING_SIZE _IO(MON_IOC_MAGIC, 5)\n#define MON_IOCX_GET   _IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)\n#define MON_IOCX_MFETCH _IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)\n#define MON_IOCH_MFLUSH _IO(MON_IOC_MAGIC, 8)\n\n#define MON_BIN_SETUP\t0x1 /* setup hdr is present*/\n#define MON_BIN_SETUP_ZERO\t0x2 /* setup buffer is not available */\n#define MON_BIN_DATA_ZERO\t0x4 /* data buffer is not available */\n#define MON_BIN_ERROR\t0x8\n\n/*\n * Private data for capturing on Linux USB.\n */\nstruct pcap_usb_linux {\n\tu_char *mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t mmapbuflen;\t/* size of region */\n\tint bus_index;\n\tu_int packets_read;\n};\n\n/* forward declaration */\nstatic int usb_activate(pcap_t *);\nstatic int usb_stats_linux_bin(pcap_t *, struct pcap_stat *);\nstatic int usb_read_linux_bin(pcap_t *, int , pcap_handler , u_char *);\nstatic int usb_read_linux_mmap(pcap_t *, int , pcap_handler , u_char *);\nstatic int usb_inject_linux(pcap_t *, const void *, int);\nstatic int usb_setdirection_linux(pcap_t *, pcap_direction_t);\nstatic void usb_cleanup_linux_mmap(pcap_t *);\n\n/* facility to add an USB device to the device list*/\nstatic int\nusb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)\n{\n\tchar dev_name[10];\n\tchar dev_descr[30];\n\tsnprintf(dev_name, sizeof(dev_name), USB_IFACE\"%d\", n);\n\t/*\n\t * XXX - is there any notion of \"up\" and \"running\"?\n\t */\n\tif (n == 0) {\n\t\t/*\n\t\t * As this refers to all buses, there's no notion of\n\t\t * \"connected\" vs. \"disconnected\", as that's a property\n\t\t * that would apply to a particular USB interface.\n\t\t */\n\t\tif (pcapint_add_dev(devlistp, dev_name,\n\t\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t\t    \"Raw USB traffic, all USB buses\", err_str) == NULL)\n\t\t\treturn -1;\n\t} else {\n\t\t/*\n\t\t * XXX - is there a way to determine whether anything's\n\t\t * plugged into this bus interface or not, and set\n\t\t * PCAP_IF_CONNECTION_STATUS_CONNECTED or\n\t\t * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?\n\t\t */\n\t\tsnprintf(dev_descr, sizeof(dev_descr), \"Raw USB traffic, bus number %d\", n);\n\t\tif (pcapint_add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint\nusb_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tstruct dirent* data;\n\tint ret = 0;\n\tDIR* dir;\n\tint n;\n\tchar* name;\n\n\t/*\n\t * We require 2.6.27 or later kernels, so we have binary-mode support.\n\t * The devices are of the form /dev/usbmon{N}.\n\t * Open /dev and scan it.\n\t */\n\tdir = opendir(\"/dev\");\n\tif (dir != NULL) {\n\t\twhile ((ret == 0) && ((data = readdir(dir)) != 0)) {\n\t\t\tname = data->d_name;\n\n\t\t\t/*\n\t\t\t * Is this a usbmon device?\n\t\t\t */\n\t\t\tif (strncmp(name, USBMON_DEV_PREFIX,\n\t\t\t    USBMON_DEV_PREFIX_LEN) != 0)\n\t\t\t\tcontinue;\t/* no */\n\n\t\t\t/*\n\t\t\t * What's the device number?\n\t\t\t */\n\t\t\tif (sscanf(&name[USBMON_DEV_PREFIX_LEN], \"%d\", &n) == 0)\n\t\t\t\tcontinue;\t/* failed */\n\n\t\t\tret = usb_dev_add(devlistp, n, err_str);\n\t\t}\n\n\t\tclosedir(dir);\n\t}\n\treturn 0;\n}\n\n/*\n * Matches what's in mon_bin.c in the Linux kernel.\n */\n#define MIN_RING_SIZE\t(8*1024)\n#define MAX_RING_SIZE\t(1200*1024)\n\nstatic int\nusb_set_ring_size(pcap_t* handle, int header_size)\n{\n\t/*\n\t * A packet from binary usbmon has:\n\t *\n\t *  1) a fixed-length header, of size header_size;\n\t *  2) descriptors, for isochronous transfers;\n\t *  3) the payload.\n\t *\n\t * The kernel buffer has a size, defaulting to 300KB, with a\n\t * minimum of 8KB and a maximum of 1200KB.  The size is set with\n\t * the MON_IOCT_RING_SIZE ioctl; the size passed in is rounded up\n\t * to a page size.\n\t *\n\t * No more than {buffer size}/5 bytes worth of payload is saved.\n\t * Therefore, if we subtract the fixed-length size from the\n\t * snapshot length, we have the biggest payload we want (we\n\t * don't worry about the descriptors - if we have descriptors,\n\t * we'll just discard the last bit of the payload to get it\n\t * to fit).  We multiply that result by 5 and set the buffer\n\t * size to that value.\n\t */\n\tint ring_size;\n\n\tif (handle->snapshot < header_size)\n\t\thandle->snapshot = header_size;\n\t/* The maximum snapshot size is small enough that this won't overflow */\n\tring_size = (handle->snapshot - header_size) * 5;\n\n\t/*\n\t * Will this get an error?\n\t * (There's no way to query the minimum or maximum, so we just\n\t * copy the value from the kernel source.  We don't round it\n\t * up to a multiple of the page size.)\n\t */\n\tif (ring_size > MAX_RING_SIZE) {\n\t\t/*\n\t\t * Yes.  Lower the ring size to the maximum, and set the\n\t\t * snapshot length to the value that would give us a\n\t\t * maximum-size ring.\n\t\t */\n\t\tring_size = MAX_RING_SIZE;\n\t\thandle->snapshot = header_size + (MAX_RING_SIZE/5);\n\t} else if (ring_size < MIN_RING_SIZE) {\n\t\t/*\n\t\t * Yes.  Raise the ring size to the minimum, but leave\n\t\t * the snapshot length unchanged, so we show the\n\t\t * callback no more data than specified by the\n\t\t * snapshot length.\n\t\t */\n\t\tring_size = MIN_RING_SIZE;\n\t}\n\n\tif (ioctl(handle->fd, MON_IOCT_RING_SIZE, ring_size) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't set ring size from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\treturn ring_size;\n}\n\nstatic\nint usb_mmap(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tint len;\n\n\t/*\n\t * Attempt to set the ring size as appropriate for the snapshot\n\t * length, reducing the snapshot length if that'd make the ring\n\t * bigger than the kernel supports.\n\t */\n\tlen = usb_set_ring_size(handle, (int)sizeof(pcap_usb_header_mmapped));\n\tif (len == -1) {\n\t\t/* Failed.  Fall back on non-memory-mapped access. */\n\t\treturn 0;\n\t}\n\n\thandlep->mmapbuflen = len;\n\thandlep->mmapbuf = mmap(0, handlep->mmapbuflen, PROT_READ,\n\t    MAP_SHARED, handle->fd, 0);\n\tif (handlep->mmapbuf == MAP_FAILED) {\n\t\t/*\n\t\t * Failed.  We don't treat that as a fatal error, we\n\t\t * just try to fall back on non-memory-mapped access.\n\t\t */\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n\n#define CTRL_TIMEOUT    (5*1000)        /* milliseconds */\n\n#define USB_DIR_IN\t\t0x80\n#define USB_TYPE_STANDARD\t0x00\n#define USB_RECIP_DEVICE\t0x00\n\n#define USB_REQ_GET_DESCRIPTOR\t6\n\n#define USB_DT_DEVICE\t\t1\n#define USB_DT_CONFIG\t\t2\n\n#define USB_DEVICE_DESCRIPTOR_SIZE\t18\n#define USB_CONFIG_DESCRIPTOR_SIZE\t9\n\n/* probe the descriptors of the devices attached to the bus */\n/* the descriptors will end up in the captured packet stream */\n/* and be decoded by external apps like wireshark */\n/* without these identifying probes packet data can't be fully decoded */\nstatic void\nprobe_devices(int bus)\n{\n\tstruct usbdevfs_ctrltransfer ctrl;\n\tstruct dirent* data;\n\tint ret = 0;\n\tchar busdevpath[sizeof(\"/dev/bus/usb/000/\") + NAME_MAX];\n\tDIR* dir;\n\tuint8_t descriptor[USB_DEVICE_DESCRIPTOR_SIZE];\n\tuint8_t configdesc[USB_CONFIG_DESCRIPTOR_SIZE];\n\n\t/* scan usb bus directories for device nodes */\n\tsnprintf(busdevpath, sizeof(busdevpath), \"/dev/bus/usb/%03d\", bus);\n\tdir = opendir(busdevpath);\n\tif (!dir)\n\t\treturn;\n\n\twhile ((ret >= 0) && ((data = readdir(dir)) != 0)) {\n\t\tint fd;\n\t\tchar* name = data->d_name;\n\n\t\tif (name[0] == '.')\n\t\t\tcontinue;\n\n\t\tsnprintf(busdevpath, sizeof(busdevpath), \"/dev/bus/usb/%03d/%s\", bus, data->d_name);\n\n\t\tfd = open(busdevpath, O_RDWR);\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sigh.  Different kernels have different member names\n\t\t * for this structure.\n\t\t */\n#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE\n\t\tctrl.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\n\t\tctrl.bRequest = USB_REQ_GET_DESCRIPTOR;\n\t\tctrl.wValue = USB_DT_DEVICE << 8;\n\t\tctrl.wIndex = 0;\n\t\tctrl.wLength = sizeof(descriptor);\n#else\n\t\tctrl.requesttype = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\n\t\tctrl.request = USB_REQ_GET_DESCRIPTOR;\n\t\tctrl.value = USB_DT_DEVICE << 8;\n\t\tctrl.index = 0;\n\t\tctrl.length = sizeof(descriptor);\n#endif\n\t\tctrl.data = descriptor;\n\t\tctrl.timeout = CTRL_TIMEOUT;\n\n\t\tret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);\n\n\t\t/* Request CONFIGURATION descriptor alone to know wTotalLength */\n#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE\n\t\tctrl.wValue = USB_DT_CONFIG << 8;\n\t\tctrl.wLength = sizeof(configdesc);\n#else\n\t\tctrl.value = USB_DT_CONFIG << 8;\n\t\tctrl.length = sizeof(configdesc);\n#endif\n\t\tctrl.data = configdesc;\n\t\tret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);\n\t\tif (ret >= 0) {\n\t\t\tuint16_t wtotallength;\n\t\t\twtotallength = EXTRACT_LE_U_2(&configdesc[2]);\n#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE\n\t\t\tctrl.wLength = wtotallength;\n#else\n\t\t\tctrl.length = wtotallength;\n#endif\n\t\t\tctrl.data = malloc(wtotallength);\n\t\t\tif (ctrl.data) {\n\t\t\t\tret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);\n\t\t\t\tfree(ctrl.data);\n\t\t\t}\n\t\t}\n\t\tclose(fd);\n\t}\n\tclosedir(dir);\n}\n#endif /* HAVE_LINUX_USBDEVICE_FS_H */\n\npcap_t *\nusb_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\n\t/* Does this look like a USB monitoring device? */\n\tcp = device;\n\t/* Does it begin with USB_IFACE? */\n\tif (strncmp(cp, USB_IFACE, sizeof USB_IFACE - 1) != 0) {\n\t\t/* Nope, doesn't begin with USB_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\t/* Yes - is USB_IFACE followed by a number? */\n\tcp += sizeof USB_IFACE - 1;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\tif (devnum < 0) {\n\t\t/* Followed by a non-valid number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = PCAP_CREATE_COMMON(ebuf, struct pcap_usb_linux);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = usb_activate;\n\treturn (p);\n}\n\nstatic int\nusb_activate(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tchar\t\tfull_path[USB_LINE_LEN];\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = handle->snapshot;\n\thandle->offset = 0;\n\thandle->linktype = DLT_USB_LINUX;\n\n\thandle->inject_op = usb_inject_linux;\n\thandle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = usb_setdirection_linux;\n\thandle->set_datalink_op = NULL;\t/* can't change data link type */\n\thandle->getnonblock_op = pcapint_getnonblock_fd;\n\thandle->setnonblock_op = pcapint_setnonblock_fd;\n\n\t/*get usb bus index from device name */\n\tif (sscanf(handle->opt.device, USB_IFACE\"%d\", &handlep->bus_index) != 1)\n\t{\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't get USB bus index from %s\", handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * We require 2.6.27 or later kernels, so we have binary-mode support.\n\t * Try to open the binary interface.\n\t */\n\tsnprintf(full_path, USB_LINE_LEN, \"/dev/\"USBMON_DEV_PREFIX\"%d\",\n\t    handlep->bus_index);\n\thandle->fd = open(full_path, O_RDONLY, 0);\n\tif (handle->fd < 0)\n\t{\n\t\t/*\n\t\t * The attempt failed; why?\n\t\t */\n\t\tswitch (errno) {\n\n\t\tcase ENOENT:\n\t\t\t/*\n\t\t\t * The device doesn't exist.\n\t\t\t * That could either mean that there's\n\t\t\t * no support for monitoring USB buses\n\t\t\t * (which probably means \"the usbmon\n\t\t\t * module isn't loaded\") or that there\n\t\t\t * is but that *particular* device\n\t\t\t * doesn't exist (no \"scan all buses\"\n\t\t\t * device if the bus index is 0, no\n\t\t\t * such bus if the bus index isn't 0).\n\t\t\t *\n\t\t\t * For now, don't provide an error message;\n\t\t\t * if we can determine what the particular\n\t\t\t * problem is, we should report that.\n\t\t\t */\n\t\t\thandle->errbuf[0] = '\\0';\n\t\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\n\t\tcase EACCES:\n\t\t\t/*\n\t\t\t * We didn't have permission to open it.\n\t\t\t */\nDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Attempt to open %s failed with EACCES - root privileges may be required\",\n\t\t\t    full_path);\nDIAG_ON_FORMAT_TRUNCATION\n\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Something went wrong.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"Can't open USB bus file %s\", full_path);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\tif (handle->opt.rfmon)\n\t{\n\t\t/*\n\t\t * Monitor mode doesn't apply to USB devices.\n\t\t */\n\t\tclose(handle->fd);\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/* try to use fast mmap access */\n\tif (usb_mmap(handle))\n\t{\n\t\t/* We succeeded. */\n\t\thandle->linktype = DLT_USB_LINUX_MMAPPED;\n\t\thandle->stats_op = usb_stats_linux_bin;\n\t\thandle->read_op = usb_read_linux_mmap;\n\t\thandle->cleanup_op = usb_cleanup_linux_mmap;\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n\t\tprobe_devices(handlep->bus_index);\n#endif\n\n\t\t/*\n\t\t * \"handle->fd\" is a real file, so\n\t\t * \"select()\" and \"poll()\" work on it.\n\t\t */\n\t\thandle->selectable_fd = handle->fd;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We failed; try plain binary interface access.\n\t *\n\t * Attempt to set the ring size as appropriate for\n\t * the snapshot length, reducing the snapshot length\n\t * if that'd make the ring bigger than the kernel\n\t * supports.\n\t */\n\tif (usb_set_ring_size(handle, (int)sizeof(pcap_usb_header)) == -1) {\n\t\t/* Failed. */\n\t\tclose(handle->fd);\n\t\treturn PCAP_ERROR;\n\t}\n\thandle->stats_op = usb_stats_linux_bin;\n\thandle->read_op = usb_read_linux_bin;\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n\tprobe_devices(handlep->bus_index);\n#endif\n\n\t/*\n\t * \"handle->fd\" is a real file, so \"select()\" and \"poll()\"\n\t * work on it.\n\t */\n\thandle->selectable_fd = handle->fd;\n\n\t/* for plain binary access and text access we need to allocate the read\n\t * buffer */\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tclose(handle->fd);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 0;\n}\n\nstatic int\nusb_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on USB devices\");\n\treturn (-1);\n}\n\nstatic int\nusb_setdirection_linux(pcap_t *p, pcap_direction_t d)\n{\n\t/*\n\t * It's guaranteed, at this point, that d is a valid\n\t * direction value.\n\t */\n\tp->direction = d;\n\treturn 0;\n}\n\nstatic int\nusb_stats_linux_bin(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tint ret;\n\tstruct mon_bin_stats st;\n\tret = ioctl(handle->fd, MON_IOCG_STATS, &st);\n\tif (ret < 0)\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't read stats from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\n\tstats->ps_recv = handlep->packets_read + st.queued;\n\tstats->ps_drop = st.dropped;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}\n\n/*\n * see <linux-kernel-source>/Documentation/usb/usbmon.txt and\n * <linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI\n */\nstatic int\nusb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tstruct mon_bin_get info;\n\tint ret;\n\tstruct pcap_pkthdr pkth;\n\tu_int clen = handle->snapshot - sizeof(pcap_usb_header);\n\n\t/* the usb header is going to be part of 'packet' data*/\n\tinfo.hdr = (pcap_usb_header*) handle->buffer;\n\tinfo.data = handle->buffer + sizeof(pcap_usb_header);\n\tinfo.data_len = clen;\n\n\t/* ignore interrupt system call errors */\n\tdo {\n\t\tret = ioctl(handle->fd, MON_IOCX_GET, &info);\n\t\tif (handle->break_loop)\n\t\t{\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\t} while ((ret == -1) && (errno == EINTR));\n\tif (ret < 0)\n\t{\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\t/* no data there */\n\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't read from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * info.hdr->data_len is the number of bytes of isochronous\n\t * descriptors (if any) plus the number of bytes of data\n\t * provided.  There are no isochronous descriptors here,\n\t * because we're using the old 48-byte header.\n\t *\n\t * If info.hdr->data_flag is non-zero, there's no URB data;\n\t * info.hdr->urb_len is the size of the buffer into which\n\t * data is to be placed; it does not represent the amount\n\t * of data transferred.  If info.hdr->data_flag is zero,\n\t * there is URB data, and info.hdr->urb_len is the number\n\t * of bytes transmitted or received; it doesn't include\n\t * isochronous descriptors.\n\t *\n\t * The kernel may give us more data than the snaplen; if it did,\n\t * reduce the data length so that the total number of bytes we\n\t * tell our client we have is not greater than the snaplen.\n\t */\n\tif (info.hdr->data_len < clen)\n\t\tclen = info.hdr->data_len;\n\tinfo.hdr->data_len = clen;\n\tpkth.caplen = sizeof(pcap_usb_header) + clen;\n\tif (info.hdr->data_flag) {\n\t\t/*\n\t\t * No data; just base the original length on\n\t\t * info.hdr->data_len (so that it's >= the captured\n\t\t * length).\n\t\t */\n\t\tpkth.len = sizeof(pcap_usb_header) + info.hdr->data_len;\n\t} else {\n\t\t/*\n\t\t * We got data; base the original length on\n\t\t * info.hdr->urb_len, so that it includes data\n\t\t * discarded by the USB monitor device due to\n\t\t * its buffer being too small.\n\t\t */\n\t\tpkth.len = sizeof(pcap_usb_header) + info.hdr->urb_len;\n\t}\n\tpkth.ts.tv_sec = (time_t)info.hdr->ts_sec;\n\tpkth.ts.tv_usec = info.hdr->ts_usec;\n\n\tif (handle->fcode.bf_insns == NULL ||\n\t    pcapint_filter(handle->fcode.bf_insns, handle->buffer,\n\t      pkth.len, pkth.caplen)) {\n\t\thandlep->packets_read++;\n\t\tcallback(user, &pkth, handle->buffer);\n\t\treturn 1;\n\t}\n\n\treturn 0;\t/* didn't pass filter */\n}\n\n/*\n * see <linux-kernel-source>/Documentation/usb/usbmon.txt and\n * <linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI\n */\n#define VEC_SIZE 32\nstatic int\nusb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tstruct mon_bin_mfetch fetch;\n\tint32_t vec[VEC_SIZE];\n\tstruct pcap_pkthdr pkth;\n\tu_char *bp;\n\tpcap_usb_header_mmapped* hdr;\n\tint nflush = 0;\n\tint packets = 0;\n\tu_int clen, max_clen;\n\n\tmax_clen = handle->snapshot - sizeof(pcap_usb_header_mmapped);\n\n\tfor (;;) {\n\t\tint i, ret;\n\t\tint limit;\n\n\t\tif (PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t\t/*\n\t\t\t * There's no limit on the number of packets\n\t\t\t * to process, so try to fetch VEC_SIZE packets.\n\t\t\t */\n\t\t\tlimit = VEC_SIZE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Try to fetch as many packets as we have left\n\t\t\t * to process, or VEC_SIZE packets, whichever\n\t\t\t * is less.\n\t\t\t *\n\t\t\t * At this point, max_packets > 0 (otherwise,\n\t\t\t * PACKET_COUNT_IS_UNLIMITED(max_packets)\n\t\t\t * would be true) and max_packets > packets\n\t\t\t * (packet starts out as 0, and the test\n\t\t\t * at the bottom of the loop exits if\n\t\t\t * max_packets <= packets), so limit is\n\t\t\t * guaranteed to be > 0.\n\t\t\t */\n\t\t\tlimit = max_packets - packets;\n\t\t\tif (limit > VEC_SIZE)\n\t\t\t\tlimit = VEC_SIZE;\n\t\t}\n\n\t\t/*\n\t\t * Try to fetch as many events as possible, up to\n\t\t * the limit, and flush the events we've processed\n\t\t * earlier (nflush) - MON_IOCX_MFETCH does both\n\t\t * (presumably to reduce the number of system\n\t\t * calls in loops like this).\n\t\t */\n\t\tfetch.offvec = vec;\n\t\tfetch.nfetch = limit;\n\t\tfetch.nflush = nflush;\n\t\t/* ignore interrupt system call errors */\n\t\tdo {\n\t\t\tret = ioctl(handle->fd, MON_IOCX_MFETCH, &fetch);\n\t\t\tif (handle->break_loop)\n\t\t\t{\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} while ((ret == -1) && (errno == EINTR));\n\t\tif (ret < 0)\n\t\t{\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 0;\t/* no data there */\n\n\t\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"Can't mfetch fd %d\",\n\t\t\t    handle->fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* keep track of processed events, we will flush them later */\n\t\tnflush = fetch.nfetch;\n\t\tfor (i=0; i<fetch.nfetch; ++i) {\n\t\t\t/*\n\t\t\t * XXX - we can't check break_loop here, as\n\t\t\t * we read the indices of packets into a\n\t\t\t * local variable, so if we're later called\n\t\t\t * to fetch more packets, those packets will\n\t\t\t * not be seen - and won't be flushed, either.\n\t\t\t *\n\t\t\t * Instead, we would have to keep the array\n\t\t\t * of indices in our private data, along\n\t\t\t * with the count of packets to flush - or\n\t\t\t * would have to flush the already-processed\n\t\t\t * packets if we break out of the loop here.\n\t\t\t */\n\n\t\t\t/* Get a pointer to this packet's buffer */\n\t\t\tbp = &handlep->mmapbuf[vec[i]];\n\n\t\t\t/* That begins with a metadata header */\n\t\t\thdr = (pcap_usb_header_mmapped*) bp;\n\n\t\t\t/* discard filler */\n\t\t\tif (hdr->event_type == '@')\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * hdr->data_len is the number of bytes of\n\t\t\t * isochronous descriptors (if any) plus the\n\t\t\t * number of bytes of data provided.\n\t\t\t *\n\t\t\t * If hdr->data_flag is non-zero, there's no\n\t\t\t * URB data; hdr->urb_len is the size of the\n\t\t\t * buffer into which data is to be placed; it does\n\t\t\t * not represent the amount of data transferred.\n\t\t\t * If hdr->data_flag is zero, there is URB data,\n\t\t\t * and hdr->urb_len is the number of bytes\n\t\t\t * transmitted or received; it doesn't include\n\t\t\t * isochronous descriptors.\n\t\t\t *\n\t\t\t * The kernel may give us more data than the\n\t\t\t * snaplen; if it did, reduce the data length\n\t\t\t * so that the total number of bytes we\n\t\t\t * tell our client we have is not greater than\n\t\t\t * the snaplen.\n\t\t\t */\n\t\t\tclen = max_clen;\n\t\t\tif (hdr->data_len < clen)\n\t\t\t\tclen = hdr->data_len;\n\t\t\tpkth.caplen = sizeof(pcap_usb_header_mmapped) + clen;\n\t\t\tif (hdr->data_flag) {\n\t\t\t\t/*\n\t\t\t\t * No data; just base the original length\n\t\t\t\t * on hdr->data_len (so that it's >= the\n\t\t\t\t * captured length).  Clamp the result\n\t\t\t\t * at UINT_MAX, so it fits in an unsigned\n\t\t\t\t * int.\n\t\t\t\t */\n\t\t\t\tpkth.len = u_int_sum(sizeof(pcap_usb_header_mmapped),\n\t\t\t\t    hdr->data_len);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We got data.\n\t\t\t\t */\n\t\t\t\tif (is_isochronous_transfer_completion(hdr)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * For isochronous transfer completion\n\t\t\t\t\t * events, hdr->urb_len doesn't take\n\t\t\t\t\t * into account the way the data is\n\t\t\t\t\t * put into the buffer, as it doesn't\n\t\t\t\t\t * count any padding between the\n\t\t\t\t\t * chunks of isochronous data, so\n\t\t\t\t\t * we have to calculate the amount\n\t\t\t\t\t * of data from the isochronous\n\t\t\t\t\t * descriptors.\n\t\t\t\t\t */\n\t\t\t\t\tpkth.len = incoming_isochronous_transfer_completed_len(&pkth, bp);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * For everything else, the original\n\t\t\t\t\t * data length is just the length of\n\t\t\t\t\t * the memory-mapped Linux USB header\n\t\t\t\t\t * plus hdr->urb_len; we use\n\t\t\t\t\t * hdr->urb_len so that it includes\n\t\t\t\t\t * data discarded by the USB monitor\n\t\t\t\t\t * device due to its buffer being\n\t\t\t\t\t * too small.  Clamp the result at\n\t\t\t\t\t * UINT_MAX, so it fits in an\n\t\t\t\t\t * unsigned int.\n\t\t\t\t\t */\n\t\t\t\t\tpkth.len = u_int_sum(sizeof(pcap_usb_header_mmapped),\n\t\t\t\t\t    hdr->urb_len);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpkth.ts.tv_sec = (time_t)hdr->ts_sec;\n\t\t\tpkth.ts.tv_usec = hdr->ts_usec;\n\n\t\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t\t    pcapint_filter(handle->fcode.bf_insns, (u_char*) hdr,\n\t\t\t      pkth.len, pkth.caplen)) {\n\t\t\t\thandlep->packets_read++;\n\t\t\t\tcallback(user, &pkth, (u_char*) hdr);\n\t\t\t\tpackets++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If max_packets specifies \"unlimited\", we stop after\n\t\t * the first chunk.\n\t\t */\n\t\tif (PACKET_COUNT_IS_UNLIMITED(max_packets) ||\n\t\t    (packets >= max_packets))\n\t\t\tbreak;\n\t}\n\n\t/* flush pending events*/\n\tif (ioctl(handle->fd, MON_IOCH_MFLUSH, nflush) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't mflush fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\treturn packets;\n}\n\nstatic void\nusb_cleanup_linux_mmap(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\n\t/* if we have a memory-mapped buffer, unmap it */\n\tif (handlep->mmapbuf != NULL) {\n\t\tmunmap(handlep->mmapbuf, handlep->mmapbuflen);\n\t\thandlep->mmapbuf = NULL;\n\t}\n\tpcapint_cleanup_live_common(handle);\n}\n"
        },
        {
          "name": "pcap-usb-linux.h",
          "type": "blob",
          "size": 1.7548828125,
          "content": "/*\n * Copyright (c) 2006 Paolo Abeni (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * USB sniffing API implementation for Linux platform\n * By Paolo Abeni <paolo.abeni@email.it>\n */\n\n/*\n * Prototypes for USB-related functions\n */\nint usb_findalldevs(pcap_if_list_t *devlistp, char *err_str);\npcap_t *usb_create(const char *device, char *ebuf, int *is_ours);\n"
        },
        {
          "name": "pcap-util.c",
          "type": "blob",
          "size": 18.931640625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * pcap-util.c - common code for various files\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n\n#include \"pcap/can_socketcan.h\"\n#include \"pcap/sll.h\"\n#include \"pcap/usb.h\"\n#include \"pcap/nflog.h\"\n\n#include \"pcap-int.h\"\n#include \"extract.h\"\n#include \"pcap-usb-linux-common.h\"\n\n#include \"pcap-util.h\"\n#include \"pflog.h\"\n\n/*\n * Most versions of the DLT_PFLOG pseudo-header have UID and PID fields\n * that are saved in host byte order.\n *\n * When reading a DLT_PFLOG packet, we need to convert those fields from\n * the byte order of the host that wrote the file to this host's byte\n * order.\n */\nstatic void\nswap_pflog_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tu_int pfloghdr_length;\n\tstruct pfloghdr *pflhdr = (struct pfloghdr *)buf;\n\n\tif (caplen < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid) ||\n\t    length < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid)) {\n\t\t/* Not enough data to have the uid field */\n\t\treturn;\n\t}\n\n\tpfloghdr_length = pflhdr->length;\n\n\tif (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, uid) + sizeof pflhdr->uid)) {\n\t\t/* Header doesn't include uid field */\n\t\treturn;\n\t}\n\tpflhdr->uid = SWAPLONG(pflhdr->uid);\n\n\tif (caplen < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid) ||\n\t    length < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid)) {\n\t\t/* Not enough data to have the pid field */\n\t\treturn;\n\t}\n\tif (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, pid) + sizeof pflhdr->pid)) {\n\t\t/* Header doesn't include pid field */\n\t\treturn;\n\t}\n\tpflhdr->pid = SWAPLONG(pflhdr->pid);\n\n\tif (caplen < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid) ||\n\t    length < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid)) {\n\t\t/* Not enough data to have the rule_uid field */\n\t\treturn;\n\t}\n\tif (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, rule_uid) + sizeof pflhdr->rule_uid)) {\n\t\t/* Header doesn't include rule_uid field */\n\t\treturn;\n\t}\n\tpflhdr->rule_uid = SWAPLONG(pflhdr->rule_uid);\n\n\tif (caplen < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid) ||\n\t    length < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid)) {\n\t\t/* Not enough data to have the rule_pid field */\n\t\treturn;\n\t}\n\tif (pfloghdr_length < (u_int) (offsetof(struct pfloghdr, rule_pid) + sizeof pflhdr->rule_pid)) {\n\t\t/* Header doesn't include rule_pid field */\n\t\treturn;\n\t}\n\tpflhdr->rule_pid = SWAPLONG(pflhdr->rule_pid);\n}\n\n/*\n * Linux cooked capture packets with a protocol type of LINUX_SLL_P_CAN or\n * LINUX_SLL_P_CANFD have SocketCAN CAN classic/CAN FD headers in front\n * of the payload,with the CAN ID being in the byte order of the host\n * that wrote the packet, and Linux cooked capture packets with a protocol\n * type of LINUX_SLL_P_CANXL have SocketCAN CAN XL headers in front of the\n * payload with the protocol/VCID field, the payload length, and the\n * acceptance field in the byte order of the host that wrote the packet.\n *\n * When reading a Linux cooked capture packet, we need to check for those\n * packets and, if the byte order host that wrote the packet, as\n * indicated by the byte order of the pcap file or pcapng section\n * containing the packet, is the opposite of our byte order, convert\n * the header files to our byte order by byte-swapping them.\n */\nstatic void\nswap_socketcan_header(uint16_t protocol, u_int caplen, u_int length,\n    u_char *buf)\n{\n\tpcap_can_socketcan_hdr *hdrp;\n\tpcap_can_socketcan_xl_hdr *xl_hdrp;\n\n\tswitch (protocol) {\n\n\tcase LINUX_SLL_P_CAN:\n\tcase LINUX_SLL_P_CANFD:\n\t\t/*\n\t\t * CAN classic/CAN FD packet; fix up the packet's header\n\t\t * by byte-swapping the CAN ID field.\n\t\t */\n\t\thdrp = (pcap_can_socketcan_hdr *)buf;\n\t\tif (caplen < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id) ||\n\t\t    length < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id)) {\n\t\t\t/* Not enough data to have the can_id field */\n\t\t\treturn;\n\t\t}\n\t\thdrp->can_id = SWAPLONG(hdrp->can_id);\n\t\tbreak;\n\n\tcase LINUX_SLL_P_CANXL:\n\t\t/*\n\t\t * CAN XL packet; fix up the packet's header by\n\t\t * byte-swapping the priority/VCID field, the\n\t\t * payload length, and the acceptance field.\n\t\t */\n\t\txl_hdrp = (pcap_can_socketcan_xl_hdr *)buf;\n\t\tif (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid) ||\n\t\t    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid)) {\n\t\t\t/* Not enough data to have the priority_vcid field */\n\t\t\treturn;\n\t\t}\n\t\txl_hdrp->priority_vcid = SWAPLONG(xl_hdrp->priority_vcid);\n\t\tif (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length) ||\n\t\t    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length)) {\n\t\t\t/* Not enough data to have the payload_length field */\n\t\t\treturn;\n\t\t}\n\t\txl_hdrp->payload_length = SWAPSHORT(xl_hdrp->payload_length);\n\t\tif (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field) ||\n\t\t    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field)) {\n\t\t\t/* Not enough data to have the acceptance_field field */\n\t\t\treturn;\n\t\t}\n\t\txl_hdrp->acceptance_field = SWAPLONG(xl_hdrp->acceptance_field);\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * Not a CAN packet; nothing to do.\n\t\t */\n\t\tbreak;\n\t}\n}\n\n/*\n * DLT_LINUX_SLL packets with a protocol type of LINUX_SLL_P_CAN or\n * LINUX_SLL_P_CANFD have SocketCAN headers in front of the payload,\n * with the CAN ID being in host byte order.\n *\n * When reading a DLT_LINUX_SLL packet, we need to check for those\n * packets and convert the CAN ID from the byte order of the host that\n * wrote the file to this host's byte order.\n */\nstatic void\nswap_linux_sll_socketcan_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tstruct sll_header *shdr = (struct sll_header *)buf;\n\n\tif (caplen < (u_int) sizeof(struct sll_header) ||\n\t    length < (u_int) sizeof(struct sll_header)) {\n\t\t/* Not enough data to have the protocol field */\n\t\treturn;\n\t}\n\n\t/*\n\t * Byte-swap what needs to be byte-swapped.\n\t */\n\tswap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll_protocol),\n\t    caplen - (u_int) sizeof(struct sll_header),\n\t    length - (u_int) sizeof(struct sll_header),\n\t    buf + sizeof(struct sll_header));\n}\n\n/*\n * The same applies for DLT_LINUX_SLL2.\n */\nstatic void\nswap_linux_sll2_socketcan_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tstruct sll2_header *shdr = (struct sll2_header *)buf;\n\n\tif (caplen < (u_int) sizeof(struct sll2_header) ||\n\t    length < (u_int) sizeof(struct sll2_header)) {\n\t\t/* Not enough data to have the protocol field */\n\t\treturn;\n\t}\n\n\t/*\n\t * Byte-swap what needs to be byte-swapped.\n\t */\n\tswap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll2_protocol),\n\t    caplen - (u_int) sizeof(struct sll2_header),\n\t    length - (u_int) sizeof(struct sll2_header),\n\t    buf + sizeof(struct sll2_header));\n}\n\n/*\n * The DLT_USB_LINUX and DLT_USB_LINUX_MMAPPED headers are in host\n * byte order when capturing (it's supplied directly from a\n * memory-mapped buffer shared by the kernel).\n *\n * When reading a DLT_USB_LINUX or DLT_USB_LINUX_MMAPPED packet, we\n * need to convert it from the byte order of the host that wrote the\n * file to this host's byte order.\n */\nstatic void\nswap_linux_usb_header(const struct pcap_pkthdr *hdr, u_char *buf,\n    int header_len_64_bytes)\n{\n\tpcap_usb_header_mmapped *uhdr = (pcap_usb_header_mmapped *)buf;\n\tbpf_u_int32 offset = 0;\n\n\t/*\n\t * \"offset\" is the offset *past* the field we're swapping;\n\t * we skip the field *before* checking to make sure\n\t * the captured data length includes the entire field.\n\t */\n\n\t/*\n\t * The URB id is a totally opaque value; do we really need to\n\t * convert it to the reading host's byte order???\n\t */\n\toffset += 8;\t\t\t/* skip past id */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->id = SWAPLL(uhdr->id);\n\n\toffset += 4;\t\t\t/* skip past various 1-byte fields */\n\n\toffset += 2;\t\t\t/* skip past bus_id */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->bus_id = SWAPSHORT(uhdr->bus_id);\n\n\toffset += 2;\t\t\t/* skip past various 1-byte fields */\n\n\toffset += 8;\t\t\t/* skip past ts_sec */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->ts_sec = SWAPLL(uhdr->ts_sec);\n\n\toffset += 4;\t\t\t/* skip past ts_usec */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->ts_usec = SWAPLONG(uhdr->ts_usec);\n\n\toffset += 4;\t\t\t/* skip past status */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->status = SWAPLONG(uhdr->status);\n\n\toffset += 4;\t\t\t/* skip past urb_len */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->urb_len = SWAPLONG(uhdr->urb_len);\n\n\toffset += 4;\t\t\t/* skip past data_len */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->data_len = SWAPLONG(uhdr->data_len);\n\n\tif (uhdr->transfer_type == URB_ISOCHRONOUS) {\n\t\toffset += 4;\t\t\t/* skip past s.iso.error_count */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->s.iso.error_count = SWAPLONG(uhdr->s.iso.error_count);\n\n\t\toffset += 4;\t\t\t/* skip past s.iso.numdesc */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->s.iso.numdesc = SWAPLONG(uhdr->s.iso.numdesc);\n\t} else\n\t\toffset += 8;\t\t\t/* skip USB setup header */\n\n\t/*\n\t * With the old header, there are no isochronous descriptors\n\t * after the header.\n\t *\n\t * With the new header, the actual number of descriptors in\n\t * the header is not s.iso.numdesc, it's ndesc - only the\n\t * first N descriptors, for some value of N, are put into\n\t * the header, and ndesc is set to the actual number copied.\n\t * In addition, if s.iso.numdesc is negative, no descriptors\n\t * are captured, and ndesc is set to 0.\n\t */\n\tif (header_len_64_bytes) {\n\t\t/*\n\t\t * This is either the \"version 1\" header, with\n\t\t * 16 bytes of additional fields at the end, or\n\t\t * a \"version 0\" header from a memory-mapped\n\t\t * capture, with 16 bytes of zeroed-out padding\n\t\t * at the end.  Byte swap them as if this were\n\t\t * a \"version 1\" header.\n\t\t */\n\t\toffset += 4;\t\t\t/* skip past interval */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->interval = SWAPLONG(uhdr->interval);\n\n\t\toffset += 4;\t\t\t/* skip past start_frame */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->start_frame = SWAPLONG(uhdr->start_frame);\n\n\t\toffset += 4;\t\t\t/* skip past xfer_flags */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->xfer_flags = SWAPLONG(uhdr->xfer_flags);\n\n\t\toffset += 4;\t\t\t/* skip past ndesc */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->ndesc = SWAPLONG(uhdr->ndesc);\n\n\t\tif (uhdr->transfer_type == URB_ISOCHRONOUS) {\n\t\t\t/* swap the values in struct linux_usb_isodesc */\n\t\t\tusb_isodesc *pisodesc;\n\t\t\tuint32_t i;\n\n\t\t\tpisodesc = (usb_isodesc *)(void *)(buf+offset);\n\t\t\tfor (i = 0; i < uhdr->ndesc; i++) {\n\t\t\t\toffset += 4;\t\t/* skip past status */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->status = SWAPLONG(pisodesc->status);\n\n\t\t\t\toffset += 4;\t\t/* skip past offset */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->offset = SWAPLONG(pisodesc->offset);\n\n\t\t\t\toffset += 4;\t\t/* skip past len */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->len = SWAPLONG(pisodesc->len);\n\n\t\t\t\toffset += 4;\t\t/* skip past padding */\n\n\t\t\t\tpisodesc++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * The DLT_NFLOG \"packets\" have a mixture of big-endian and host-byte-order\n * data.  They begin with a fixed-length header with big-endian fields,\n * followed by a set of TLVs, where the type and length are in host\n * byte order but the values are either big-endian or are a raw byte\n * sequence that's the same regardless of the host's byte order.\n *\n * When reading a DLT_NFLOG packet, we need to convert the type and\n * length values from the byte order of the host that wrote the file\n * to the byte order of this host.\n */\nstatic void\nswap_nflog_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_char *p = buf;\n\tnflog_hdr_t *nfhdr = (nflog_hdr_t *)buf;\n\tnflog_tlv_t *tlv;\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tu_int size;\n\n\tif (caplen < (u_int) sizeof(nflog_hdr_t) ||\n\t    length < (u_int) sizeof(nflog_hdr_t)) {\n\t\t/* Not enough data to have any TLVs. */\n\t\treturn;\n\t}\n\n\tif (nfhdr->nflog_version != 0) {\n\t\t/* Unknown NFLOG version */\n\t\treturn;\n\t}\n\n\tlength -= sizeof(nflog_hdr_t);\n\tcaplen -= sizeof(nflog_hdr_t);\n\tp += sizeof(nflog_hdr_t);\n\n\twhile (caplen >= sizeof(nflog_tlv_t)) {\n\t\ttlv = (nflog_tlv_t *) p;\n\n\t\t/* Swap the type and length. */\n\t\ttlv->tlv_type = SWAPSHORT(tlv->tlv_type);\n\t\ttlv->tlv_length = SWAPSHORT(tlv->tlv_length);\n\n\t\t/* Get the length of the TLV. */\n\t\tsize = tlv->tlv_length;\n\t\tif (size % 4 != 0)\n\t\t\tsize += 4 - size % 4;\n\n\t\t/* Is the TLV's length less than the minimum? */\n\t\tif (size < sizeof(nflog_tlv_t)) {\n\t\t\t/* Yes. Give up now. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Do we have enough data for the full TLV? */\n\t\tif (caplen < size || length < size) {\n\t\t\t/* No. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Skip over the TLV. */\n\t\tlength -= size;\n\t\tcaplen -= size;\n\t\tp += size;\n\t}\n}\n\nstatic void\nswap_pseudo_headers(int linktype, struct pcap_pkthdr *hdr, u_char *data)\n{\n\t/*\n\t * Convert pseudo-headers from the byte order of\n\t * the host on which the file was saved to our\n\t * byte order, as necessary.\n\t */\n\tswitch (linktype) {\n\n\tcase DLT_PFLOG:\n\t\tswap_pflog_header(hdr, data);\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\tswap_linux_sll_socketcan_header(hdr, data);\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\n\t\tswap_linux_sll2_socketcan_header(hdr, data);\n\t\tbreak;\n\n\tcase DLT_USB_LINUX:\n\t\tswap_linux_usb_header(hdr, data, 0);\n\t\tbreak;\n\n\tcase DLT_USB_LINUX_MMAPPED:\n\t\tswap_linux_usb_header(hdr, data, 1);\n\t\tbreak;\n\n\tcase DLT_NFLOG:\n\t\tswap_nflog_header(hdr, data);\n\t\tbreak;\n\t}\n}\n\nstatic inline int\npacket_length_might_be_wrong(struct pcap_pkthdr *hdr,\n    const pcap_usb_header_mmapped *usb_hdr)\n{\n\tuint32_t old_style_packet_length;\n\n\t/*\n\t * Calculate the packet length the old way.\n\t * We know that the multiplication won't overflow, but\n\t * we don't know that the additions won't.  Calculate\n\t * it with no overflow checks, as that's how it\n\t * would have been calculated when it was captured.\n\t */\n\told_style_packet_length = iso_pseudo_header_len(usb_hdr) +\n\t    usb_hdr->urb_len;\n\treturn (hdr->len == old_style_packet_length);\n}\n\nvoid\npcapint_post_process(int linktype, int swapped, struct pcap_pkthdr *hdr,\n    u_char *data)\n{\n\tif (swapped)\n\t\tswap_pseudo_headers(linktype, hdr, data);\n\n\t/*\n\t * Is this a memory-mapped Linux USB capture?\n\t */\n\tif (linktype == DLT_USB_LINUX_MMAPPED) {\n\t\t/*\n\t\t * Yes.\n\t\t *\n\t\t * In older versions of libpcap, in memory-mapped Linux\n\t\t * USB captures, the original length of completion events\n\t\t * for incoming isochronous transfers was miscalculated;\n\t\t * it needed to be calculated based on the offsets and\n\t\t * lengths in the descriptors, not on the raw URB length,\n\t\t * but it wasn't.\n\t\t *\n\t\t * If this packet contains transferred data (yes, data_flag\n\t\t * is 0 if we *do* have data), it's a completion event\n\t\t * for an incoming isochronous transfer, and the\n\t\t * transfer length appears to have been calculated\n\t\t * from the raw URB length, fix it.\n\t\t *\n\t\t * We only do this if we have the full USB pseudo-header,\n\t\t * because we will have to look at that header and at\n\t\t * all of the isochronous descriptors.\n\t\t */\n\t\tif (hdr->caplen < sizeof (pcap_usb_header_mmapped)) {\n\t\t\t/*\n\t\t\t * We don't have the full pseudo-header.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\tconst pcap_usb_header_mmapped *usb_hdr =\n\t\t    (const pcap_usb_header_mmapped *) data;\n\n\t\t/*\n\t\t * Make sure the number of descriptors is sane.\n\t\t *\n\t\t * The Linux binary USB monitor code limits the number of\n\t\t * isochronous descriptors to 128; if the number in the file\n\t\t * is larger than that, either 1) the file's been damaged\n\t\t * or 2) the file was produced after the number was raised\n\t\t * in the kernel.\n\t\t *\n\t\t * In case 1), the number can't be trusted, so don't rely on\n\t\t * it to attempt to fix the original length field in the pcap\n\t\t * or pcapng header.\n\t\t *\n\t\t * In case 2), the system was probably running a version of\n\t\t * libpcap that didn't miscalculate the original length, so\n\t\t * it probably doesn't need to be fixed.\n\t\t *\n\t\t * This avoids the possibility of the product of the number of\n\t\t * descriptors and the size of descriptors won't overflow an\n\t\t * unsigned 32-bit integer.\n\t\t */\n\t\tif (usb_hdr->ndesc > USB_MAXDESC)\n\t\t\treturn;\n\n\t\tif (!usb_hdr->data_flag &&\n\t\t    is_isochronous_transfer_completion(usb_hdr) &&\n\t\t    packet_length_might_be_wrong(hdr, usb_hdr)) {\n\t\t\tu_int len;\n\n\t\t\t/*\n\t\t\t * Make sure we have all of the descriptors,\n\t\t\t * as we will have to look at all of them.\n\t\t\t *\n\t\t\t * If not, we don't bother trying to fix\n\t\t\t * anything.\n\t\t\t */\n\t\t\tif (hdr->caplen < iso_pseudo_header_len(usb_hdr))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Calculate what the length should have been.\n\t\t\t */\n\t\t\tlen = incoming_isochronous_transfer_completed_len(hdr,\n\t\t\t    data);\n\n\t\t\t/*\n\t\t\t * len is the smaller of UINT_MAX and the total\n\t\t\t * header plus data length.  That's guaranteed\n\t\t\t * to fit in a UINT_MAX.\n\t\t\t *\n\t\t\t * Don't reduce the original length to a value\n\t\t\t * below the captured length, however, as that\n\t\t\t * is bogus.\n\t\t\t */\n\t\t\tif (len >= hdr->caplen)\n\t\t\t\thdr->len = len;\n\n\t\t\t/*\n\t\t\t * If the captured length is greater than the\n\t\t\t * length, use the captured length.\n\t\t\t *\n\t\t\t * For completion events for incoming isochronous\n\t\t\t * transfers, it's based on data_len, which is\n\t\t\t * calculated the same way we calculated\n\t\t\t * pre_truncation_data_len above, except that\n\t\t\t * it has access to all the isochronous descriptors,\n\t\t\t * not just the ones that the kernel were able to\n\t\t\t * provide us or, for a capture file, that weren't\n\t\t\t * sliced off by a snapshot length.\n\t\t\t *\n\t\t\t * However, it might have been reduced by the USB\n\t\t\t * capture mechanism arbitrarily limiting the amount\n\t\t\t * of data it provides to userland, or by the libpcap\n\t\t\t * capture code limiting it to being no more than the\n\t\t\t * snapshot, so we don't want to just use it all the\n\t\t\t * time; we only do so to try to get a better estimate\n\t\t\t * of the actual length - and to make sure the\n\t\t\t * original length is always >= the captured length.\n\t\t\t */\n\t\t\tif (hdr->caplen > hdr->len)\n\t\t\t\thdr->len = hdr->caplen;\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pcap-util.h",
          "type": "blob",
          "size": 2.3828125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * pcap-util.h - common code for various files\n */\n\n#ifndef pcap_util_h\n#define pcap_util_h\n\n/*\n * We use the \"receiver-makes-right\" approach to byte order;\n * because time is at a premium when we are writing the file.\n * In other words, the pcap_file_header and pcap_pkthdr,\n * records are written in host byte order.\n * Note that the bytes of packet data are written out in the order in\n * which they were received, so multi-byte fields in packets are not\n * written in host byte order, they're written in whatever order the\n * sending machine put them in.\n *\n * We also use this for fixing up packet data headers from a remote\n * capture, where the server may have a different byte order from the\n * client.\n *\n * ntoh[ls] aren't sufficient because we might need to swap on a big-endian\n * machine (if the file was written in little-end order).\n */\n#define\tSWAPLONG(y) \\\n    (((((u_int)(y))&0xff)<<24) | \\\n     ((((u_int)(y))&0xff00)<<8) | \\\n     ((((u_int)(y))&0xff0000)>>8) | \\\n     ((((u_int)(y))>>24)&0xff))\n#define\tSWAPSHORT(y) \\\n     ((u_short)(((((u_int)(y))&0xff)<<8) | \\\n                ((((u_int)(y))&0xff00)>>8)))\n\nextern void pcapint_post_process(int linktype, int swapped,\n    struct pcap_pkthdr *hdr, u_char *data);\n\n#endif // pcap_util_h\n"
        },
        {
          "name": "pcap.3pcap.in",
          "type": "blob",
          "size": 30.4794921875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP 3PCAP \"18 September 2024\"\n.SH NAME\npcap \\- Packet Capture library\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\n.ft\n.fi\n.SH DESCRIPTION\nThe Packet Capture library\nprovides a high level interface to packet capture systems. All packets\non the network, even those destined for other hosts, are accessible\nthrough this mechanism.\nIt also supports saving captured packets to a ``savefile'', and reading\npackets from a ``savefile''.\n.SS Initializing\n.BR pcap_init ()\ninitializes the library.  It takes an argument giving options;\ncurrently, the options are:\n.TP\n.B PCAP_CHAR_ENC_LOCAL\nTreat all strings supplied as arguments, and return all strings to the\ncaller, as being in the local character encoding.\n.TP\n.B PCAP_CHAR_ENC_UTF_8\nTreat all strings supplied as arguments, and return all strings to the\ncaller, as being in UTF-8.\n.PP\nOn UNIX-like systems, the local character encoding is assumed to be\nUTF-8, so no character encoding transformations are done.\n.PP\nOn Windows, the local character encoding is the local ANSI code page.\n.PP\nIf\n.BR pcap_init ()\nis called, the deprecated\n.BR pcap_lookupdev ()\nroutine always fails, so it should not be used, and, on Windows,\n.BR pcap_create ()\ndoes not attempt to handle UTF-16LE strings.\n.PP\nIf\n.BR pcap_init ()\nis not called, strings are treated as being in the local ANSI code page\non Windows,\n.BR pcap_lookupdev ()\nwill succeed if there is a device on which to capture, and\n.BR pcap_create ()\nmakes an attempt to check whether the string passed as an argument is a\nUTF-16LE string - note that this attempt is unsafe, as it may run past\nthe end of the string - to handle\n.BR pcap_lookupdev ()\nreturning a UTF-16LE string.\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_init (3PCAP)\ninitialize the library\n.RE\n.SS Opening a capture handle for reading\nTo open a handle for a live capture, given the name of the network or\nother interface on which the capture should be done, call\n.BR pcap_create (),\nset the appropriate options on the handle, and then activate it with\n.BR pcap_activate ().\nIf\n.BR pcap_activate ()\nfails, the handle should be closed with\n.BR pcap_close ().\n.PP\nTo obtain a list of devices that can be opened for a live capture, call\n.BR pcap_findalldevs ();\nto free the list returned by\n.BR pcap_findalldevs (),\ncall\n.BR pcap_freealldevs ().\n.BR pcap_lookupdev ()\nwill return the first device on that list that is not a ``loopback``\nnetwork interface.\n.PP\nTo open a handle for a ``savefile'' from which to read packets, given the\npathname of the ``savefile'', call\n.BR pcap_open_offline ();\nto set up a handle for a ``savefile'', given a\n.B \"FILE\\ *\"\nreferring to a file already opened for reading, call\n.BR pcap_fopen_offline ().\n.PP\nIn order to get a ``fake''\n.B pcap_t\nfor use in routines that require a\n.B pcap_t\nas an argument, such as routines to open a ``savefile'' for writing and\nto compile a filter expression, call\n.BR pcap_open_dead ().\n.PP\n.BR pcap_create (),\n.BR pcap_open_offline (),\n.BR pcap_fopen_offline (),\nand\n.BR pcap_open_dead ()\nreturn a pointer to a\n.BR pcap_t ,\nwhich is the handle used for reading packets from the capture stream or\nthe ``savefile'', and for finding out information about the capture\nstream or ``savefile''.\nTo close a handle, use\n.BR pcap_close ().\n.PP\nThe options that can be set on a capture handle include\n.IP \"snapshot length\"\nIf, when capturing, you capture the entire contents of the packet, that\nrequires more CPU time to copy the packet to your application, more disk\nand possibly network bandwidth to write the packet data to a file, and\nmore disk space to save the packet.  If you don't need the entire\ncontents of the packet - for example, if you are only interested in the\nTCP headers of packets - you can set the \"snapshot length\" for the\ncapture to an appropriate value.  If the snapshot length is set to\n.IR snaplen ,\nand\n.I snaplen\nis less\nthan the size of a packet that is captured, only the first\n.I snaplen\nbytes of that packet will be captured and provided as packet data.\n.IP\nA snapshot length of 65535 should be sufficient, on most if not all\nnetworks, to capture all the data available from the packet.\n.IP\nThe snapshot length is set with\n.BR pcap_set_snaplen ().\n.IP \"promiscuous mode\"\nOn broadcast LANs such as Ethernet, if the network isn't switched, or if\nthe adapter is connected to a \"mirror port\" on a switch to which all\npackets passing through the switch are sent, a network adapter receives\nall packets on the LAN, including unicast or multicast packets not sent\nto a network address that the network adapter isn't configured to\nrecognize.\n.IP\nNormally, the adapter will discard those packets; however, many network\nadapters support \"promiscuous mode\", which is a mode in which all\npackets, even if they are not sent to an address that the adapter\nrecognizes, are provided to the host.  This is useful for passively\ncapturing traffic between two or more other hosts for analysis.\n.IP\nNote that even if an application does not set promiscuous mode, the\nadapter could well be in promiscuous mode for some other reason.\n.IP\nFor now, this doesn't work on the \"any\" device; if an argument of \"any\"\nor\n.B NULL\nis supplied, the setting of promiscuous mode is ignored.\n.IP\nPromiscuous mode is set with\n.BR pcap_set_promisc ().\n.IP \"monitor mode\"\nOn IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode,\nit will supply to the host only frames for the network with which it's\nassociated.  It might also supply only data frames, not management or\ncontrol frames, and might not provide the 802.11 header or radio\ninformation pseudo-header for those frames.\n.IP\nIn \"monitor mode\", sometimes also called \"rfmon mode\" (for \"Radio\nFrequency MONitor\"), the adapter will supply all frames that it\nreceives, with 802.11 headers, and might supply a pseudo-header with\nradio information about the frame as well.\n.IP\nNote that in monitor mode the adapter might disassociate from the\nnetwork with which it's associated, so that you will not be able to use\nany wireless networks with that adapter.  This could prevent accessing\nfiles on a network server, or resolving host names or network addresses,\nif you are capturing in monitor mode and are not connected to another\nnetwork with another adapter.\n.IP\nMonitor mode is set with\n.BR pcap_set_rfmon (),\nand\n.BR pcap_can_set_rfmon ()\ncan be used to determine whether an adapter can be put into monitor\nmode.\n.IP \"packet buffer timeout\"\nIf, when capturing, packets are delivered as soon as they arrive, the\napplication capturing the packets will be woken up for each packet as it\narrives, and might have to make one or more calls to the operating\nsystem to fetch each packet.\n.IP\nIf, instead, packets are not delivered as soon as they arrive, but are\ndelivered after a short delay (called a \"packet buffer timeout\"), more\nthan one packet can be accumulated before the packets are delivered, so\nthat a single wakeup would be done for multiple packets, and each set of\ncalls made to the operating system would supply multiple packets, rather\nthan a single packet.  This reduces the per-packet CPU overhead if\npackets are arriving at a high rate, increasing the number of packets\nper second that can be captured.\n.IP\nThe packet buffer timeout is required so that an application won't wait\nfor the operating system's capture buffer to fill up before packets are\ndelivered; if packets are arriving slowly, that wait could take an\narbitrarily long period of time.\n.IP\nNot all platforms support a packet buffer timeout; on platforms that\ndon't, the packet buffer timeout is ignored.  A zero value for the\ntimeout, on platforms that support a packet buffer timeout, will cause a\nread to wait forever to allow enough packets to arrive, with no timeout.\nA negative value is invalid; the result of setting the timeout to a\nnegative value is unpredictable.\n.IP\n.BR NOTE :\nthe packet buffer timeout cannot be used to cause calls that read\npackets to return within a limited period of time, because, on some\nplatforms, the packet buffer timeout isn't supported, and, on other\nplatforms, the timer doesn't start until at least one packet arrives.\nThis means that the packet buffer timeout should\n.B NOT\nbe used, for example, in an interactive application to allow the packet\ncapture loop to ``poll'' for user input periodically, as there's no\nguarantee that a call reading packets will return after the timeout\nexpires even if no packets have arrived.\n.IP\nThe packet buffer timeout is set with\n.BR pcap_set_timeout ().\n.IP \"immediate mode\"\nIn immediate mode, packets are always delivered as soon as they arrive,\nwith no buffering.  Immediate mode is set with\n.BR pcap_set_immediate_mode ().\n.IP \"buffer size\"\nPackets that arrive for a capture are stored in a buffer, so that they\ndo not have to be read by the application as soon as they arrive.  On\nsome platforms, the buffer's size can be set; a size that's too small\ncould mean that, if too many packets are being captured and the snapshot\nlength doesn't limit the amount of data that's buffered, packets could\nbe dropped if the buffer fills up before the application can read\npackets from it, while a size that's too large could use more\nnon-pageable operating system memory than is necessary to prevent\npackets from being dropped.\n.IP\nThe buffer size is set with\n.BR pcap_set_buffer_size ().\n.IP \"timestamp type\"\nOn some platforms, the time stamp given to packets on live captures can\ncome from different sources that can have different resolutions or that\ncan have different relationships to the time values for the current time\nsupplied by routines on the native operating system.  See\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\nfor a list of time stamp types.\n.IP\nThe time stamp type is set with\n.BR pcap_set_tstamp_type ().\n.PP\nReading packets from a network interface may require that you have\nspecial privileges:\n.TP\n.B Under Solaris with DLPI:\nYou must have read/write access to the network pseudo device, e.g.\n.IR /dev/le .\nOn at least some versions of Solaris, however, this is not sufficient to\nallow\n.I tcpdump\nto capture in promiscuous mode; on those versions of Solaris, you must\nbe root, or the application capturing packets\nmust be installed setuid to root, in order to capture in promiscuous\nmode.  Note that, on many (perhaps all) interfaces, if you don't capture\nin promiscuous mode, you will not see any outgoing packets, so a capture\nnot done in promiscuous mode may not be very useful.\n.IP\nIn newer versions of Solaris, you must have been given the\n.B net_rawaccess\nprivilege; this is both necessary and sufficient to give you access to the\nnetwork pseudo-device - there is no need to change the privileges on\nthat device.  A user can be given that privilege by, for example, adding\nthat privilege to the user's\n.B defaultpriv\nkey with the\n.BR usermod (@MAN_ADMIN_COMMANDS@)\ncommand.\n.TP\n.B Under HP-UX with DLPI:\nYou must be root or the application capturing packets must be installed\nsetuid to root.\n.TP\n.B Under Linux:\nYou must be root or the application capturing packets must be installed\nsetuid to root, unless your distribution has a kernel\nthat supports capability bits such as\n.B CAP_NET_RAW\nand code to allow\nthose capability bits to be given to particular accounts and to cause\nthose bits to be set on a user's initial processes when they log in, in\nwhich case you must have\n.B CAP_NET_RAW\nin order to capture.\n.TP\n.B Under BSD (this includes macOS):\nYou must have read access to\n.I /dev/bpf*\non systems that don't have a cloning BPF device, or to\n.I /dev/bpf\non systems that do.\nOn BSDs with a devfs (this includes macOS), this might involve more\nthan just having somebody with super-user access setting the ownership\nor permissions on the BPF devices - it might involve configuring devfs\nto set the ownership or permissions every time the system is booted,\nif the system even supports that; if it doesn't support that, you might\nhave to find some other way to make that happen at boot time.\n.PP\nReading a saved packet file doesn't require special privileges.\n.PP\nThe packets read from the handle may include a ``pseudo-header''\ncontaining various forms of packet meta-data, and probably includes a\nlink-layer header whose contents can differ for different network\ninterfaces.  To determine the format of the packets supplied by the\nhandle, call\n.BR pcap_datalink ();\n.I https://www.tcpdump.org/linktypes.html\nlists the values it returns and describes the packet formats that\ncorrespond to those values.\n.PP\nDo\n.B NOT\nassume that the packets for a given capture or ``savefile`` will have\nany given link-layer header type, such as\n.B DLT_EN10MB\nfor Ethernet.  For example, the \"any\" device on Linux will have a\nlink-layer header type of\n.B DLT_LINUX_SLL\nor\n.B DLT_LINUX_SLL2\neven if all devices on the system at the time the \"any\" device is opened\nhave some other data link type, such as\n.B DLT_EN10MB\nfor Ethernet.\n.PP\nTo obtain the\n.B \"FILE\\ *\"\ncorresponding to a\n.B pcap_t\nopened for a ``savefile'', call\n.BR pcap_file ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_create (3PCAP)\nget a\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_activate (3PCAP)\nactivate a\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_findalldevs (3PCAP)\nget a list of devices that can be opened for a live capture\n.TP\n.BR pcap_freealldevs (3PCAP)\nfree list of devices\n.TP\n.BR pcap_lookupdev (3PCAP)\nget first non-loopback device on that list\n.TP\n.BR pcap_open_offline (3PCAP)\nopen a\n.B pcap_t\nfor a ``savefile'', given a pathname\n.TP\n.BR pcap_open_offline_with_tstamp_precision (3PCAP)\nopen a\n.B pcap_t\nfor a ``savefile'', given a pathname, and specify the precision to\nprovide for packet time stamps\n.TP\n.BR pcap_fopen_offline (3PCAP)\nopen a\n.B pcap_t\nfor a ``savefile'', given a\n.B \"FILE\\ *\"\n.TP\n.BR pcap_fopen_offline_with_tstamp_precision (3PCAP)\nopen a\n.B pcap_t\nfor a ``savefile'', given a\n.BR \"FILE\\ *\" ,\nand specify the precision to provide for packet time stamps\n.TP\n.BR pcap_open_dead (3PCAP)\ncreate a ``fake''\n.B pcap_t\n.TP\n.BR pcap_close (3PCAP)\nclose a\n.B pcap_t\n.TP\n.BR pcap_set_snaplen (3PCAP)\nset the snapshot length for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_snapshot (3PCAP)\nget the snapshot length for a\n.B pcap_t\n.TP\n.BR pcap_set_promisc (3PCAP)\nset promiscuous mode for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_set_protocol_linux (3PCAP)\nset capture protocol for a not-yet-activated\n.B pcap_t\nfor live capture (Linux only)\n.TP\n.BR pcap_set_rfmon (3PCAP)\nset monitor mode for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_can_set_rfmon (3PCAP)\ndetermine whether monitor mode can be set for a\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_set_timeout (3PCAP)\nset packet buffer timeout for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_set_immediate_mode (3PCAP)\nset immediate mode for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_set_buffer_size (3PCAP)\nset buffer size for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_set_tstamp_type (3PCAP)\nset time stamp type for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_list_tstamp_types (3PCAP)\nget list of available time stamp types for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_free_tstamp_types (3PCAP)\nfree list of available time stamp types\n.TP\n.BR pcap_tstamp_type_val_to_name (3PCAP)\nget name for a time stamp type\n.TP\n.BR pcap_tstamp_type_val_to_description (3PCAP)\nget description for a time stamp type\n.TP\n.BR pcap_tstamp_type_name_to_val (3PCAP)\nget time stamp type corresponding to a name\n.TP\n.BR pcap_set_tstamp_precision (3PCAP)\nset time stamp precision for a not-yet-activated\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_get_tstamp_precision (3PCAP)\nget the time stamp precision of a\n.B pcap_t\nfor live capture\n.TP\n.BR pcap_datalink (3PCAP)\nget link-layer header type for a\n.B pcap_t\n.TP\n.BR pcap_file (3PCAP)\nget the\n.B \"FILE\\ *\"\nfor a\n.B pcap_t\nopened for a ``savefile''\n.TP\n.BR pcap_is_swapped (3PCAP)\ndetermine whether a ``savefile'' being read came from a machine with the\nopposite byte order\n.TP\n.BR pcap_major_version (3PCAP)\n.PD 0\n.TP\n.BR pcap_minor_version (3PCAP)\nget the major and minor version of the file format version for a\n``savefile''\n.PD\n.RE\n.SS Selecting a link-layer header type for a live capture\nSome devices may provide more than one link-layer header type.  To\nobtain a list of all link-layer header types provided by a device, call\n.BR pcap_list_datalinks ()\non an activated\n.B pcap_t\nfor the device.\nTo free a list of link-layer header types, call\n.BR pcap_free_datalinks ().\nTo set the link-layer header type for a device, call\n.BR pcap_set_datalink ().\nThis should be done after the device has been activated but before any\npackets are read and before any filters are compiled or installed.\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_list_datalinks (3PCAP)\nget a list of link-layer header types for a device\n.TP\n.BR pcap_free_datalinks (3PCAP)\nfree list of link-layer header types\n.TP\n.BR pcap_set_datalink (3PCAP)\nset link-layer header type for a device\n.TP\n.BR pcap_datalink_val_to_name (3PCAP)\nget name for a link-layer header type\n.TP\n.BR pcap_datalink_val_to_description (3PCAP)\n.PD 0\n.TP\n.BR pcap_datalink_val_to_description_or_dlt (3PCAP)\nget description for a link-layer header type\n.PD\n.TP\n.BR pcap_datalink_name_to_val (3PCAP)\nget link-layer header type corresponding to a name\n.RE\n.SS Reading packets\nPackets are read with\n.BR pcap_dispatch ()\nor\n.BR pcap_loop (),\nwhich process one or more packets, calling a callback routine for each\npacket, or with\n.BR pcap_next ()\nor\n.BR pcap_next_ex (),\nwhich return the next packet.\nThe callback for\n.BR pcap_dispatch ()\nand\n.BR pcap_loop ()\nis supplied a pointer to a\n.BR \"struct pcap_pkthdr\" ,\nwhich includes the following members:\n.RS\n.TP\n.B ts\na\n.B struct timeval\ncontaining the time when the packet was captured\n.TP\n.B caplen\na\n.B bpf_u_int32\ngiving the number of bytes of the packet that are available from the\ncapture\n.TP\n.B len\na\n.B bpf_u_int32\ngiving the length of the packet, in bytes (which might be more than the\nnumber of bytes available from the capture, if the length of the packet\nwas larger than the snapshot length or than some limit imposed by the\ncapture mechanism).\n.RE\n.PP\nThe callback is also supplied a\n.B const u_char\npointer to the first\n.B caplen\n(as given in the\n.B struct pcap_pkthdr\nmentioned above)\nbytes of data from the packet.  This won't necessarily be the entire\npacket; the default value used if\n.BR pcap_create ()\nand\n.BR pcap_activate ()\nare used to open a capture device, and no call to\n.BR pcap_set_snaplen ()\nis made before\n.BR pcap_activate ()\nis called, should be sufficient for that device.  However, if a smaller\nvalue is set with a call to\n.BR pcap_set_snaplen (),\nif the default isn't sufficient for that device, or if the mechanism\nused by libpcap to capture the traffic imposes a separate limit,\nsome captured packets may not contain all the data sent or received.\nWhen reading from a ``savefile'', the snapshot length specified when the\ncapture was performed will limit the amount of packet data available.\n.PP\n.BR pcap_next ()\nis passed an argument that points to a\n.B struct pcap_pkthdr\nstructure, and fills it in with the time stamp and length values for the\npacket.  It returns a\n.B const u_char *\nto the first\n.B caplen\nbytes of the packet on success, and\n.B NULL\non error.\n.PP\n.BR pcap_next_ex ()\nis passed two pointer arguments, one of which points to a\n.B struct pcap_pkthdr *\nand the other points to a\n.BR \"const u_char *\" .\nIt sets the first pointer to point to a\n.B struct pcap_pkthdr\nstructure with the time stamp and length values for the packet, and sets\nthe second pointer to point to the first\n.B caplen\nbytes of the packet.\n.PP\nTo force the loop in\n.BR pcap_dispatch ()\nor\n.BR pcap_loop ()\nto terminate, call\n.BR pcap_breakloop ().\n.PP\nBy default, when reading packets from an interface opened for a live\ncapture,\n.BR pcap_dispatch (),\n.BR pcap_next (),\nand\n.BR pcap_next_ex ()\nwill, if no packets are currently available to be read, block waiting\nfor packets to become available.  On some, but\n.I not\nall, platforms, if a packet buffer timeout was specified, the wait will\nterminate after the packet buffer timeout expires; applications should\nbe prepared for this, as it happens on some platforms, but should not\nrely on it, as it does not happen on other platforms.  Note that the\nwait might, or might not, terminate even if no packets are available;\napplications should be prepared for this to happen, but must not rely on\nit happening.\n.PP\nA handle can be put into ``non-blocking mode'', so that those routines\nwill, rather than blocking, return an indication that no packets are\navailable to read.  Call\n.BR pcap_setnonblock ()\nto put a handle into non-blocking mode or to take it out of non-blocking\nmode; call\n.BR pcap_getnonblock ()\nto determine whether a handle is in non-blocking mode.  Note that\nnon-blocking mode does not work correctly in Mac OS X 10.6.\n.PP\nNon-blocking mode is often combined with routines such as\n.BR select (2)\nor\n.BR poll (2)\nor other routines a platform offers to wait for any of a set of\ndescriptors to be ready to read.  To obtain, for a handle, a descriptor\nthat can be used in those routines, call\n.BR pcap_get_selectable_fd ().\nIf the routine indicates that data is\navailable to read on the descriptor, an attempt should be made to read\nfrom the device.\n.PP\nNot all handles have such a descriptor available;\n.BR pcap_get_selectable_fd ()\nwill return\n.B \\-1\nif no such descriptor is available.  If no such\ndescriptor is available, this may be because the device must be polled\nperiodically for packets; in that case,\n.BR pcap_get_required_select_timeout ()\nwill return a pointer to a\n.B struct timeval\nwhose value can be used as a timeout in those routines.  When the\nroutine returns, an attempt should be made to read packets from the\ndevice.  If\n.BR pcap_get_required_select_timeout ()\nreturns\n.BR NULL ,\nno such timeout is available, and those routines cannot be\nused with the device.\n.PP\nIn addition, for various\nreasons, one or more of those routines will not work properly with the\ndescriptor; the documentation for\n.BR pcap_get_selectable_fd ()\ngives details.  Note that, just as an attempt to read packets from a\n.B pcap_t\nmay not return any packets if the packet buffer timeout expires, a\n.BR select (),\n.BR poll (),\nor other such call may, if the packet buffer timeout expires, indicate\nthat a descriptor is ready to read even if there are no packets\navailable to read.\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_dispatch (3PCAP)\nread a bufferful of packets from a\n.B pcap_t\nopen for a live capture or the full set of packets from a\n.B pcap_t\nopen for a ``savefile''\n.TP\n.BR pcap_loop (3PCAP)\nread packets from a\n.B pcap_t\nuntil an interrupt or error occurs\n.TP\n.BR pcap_next (3PCAP)\nread the next packet from a\n.B pcap_t\nwithout an indication whether an error occurred\n.TP\n.BR pcap_next_ex (3PCAP)\nread the next packet from a\n.B pcap_t\nwith an error indication on an error\n.TP\n.BR pcap_breakloop (3PCAP)\nprematurely terminate the loop in\n.BR pcap_dispatch ()\nor\n.BR pcap_loop ()\n.TP\n.BR pcap_setnonblock (3PCAP)\nset or clear non-blocking mode on a\n.B pcap_t\n.TP\n.BR pcap_getnonblock (3PCAP)\nget the state of non-blocking mode for a\n.B pcap_t\n.TP\n.BR pcap_get_selectable_fd (3PCAP)\nattempt to get a descriptor for a\n.B pcap_t\nthat can be used in calls such as\n.BR select ()\nand\n.BR poll ()\n.TP\n.BR pcap_get_required_select_timeout (3PCAP)\nattempt to get a timeout required for using a\n.B pcap_t\nin calls such as\n.BR select ()\nand\n.BR poll ()\n.RE\n.SS Filters\nIn order to cause only certain packets to be returned when reading\npackets, a filter can be set on a handle.  For a live capture, the\nfiltering will be performed in kernel mode, if possible, to avoid\ncopying ``uninteresting'' packets from the kernel to user mode.\n.PP\nA filter can be specified as a text string; the syntax and semantics of\nthe string are as described by\n.BR \\%pcap-filter (@MAN_MISC_INFO@).\nA filter string is compiled into a program in a pseudo-machine-language\nby\n.BR pcap_compile ()\nand the resulting program can be made a filter for a handle with\n.BR pcap_setfilter ().\nThe result of\n.BR pcap_compile ()\ncan be freed with a call to\n.BR pcap_freecode ().\n.BR pcap_compile ()\nmay require a network mask for certain expressions in the filter string;\n.BR pcap_lookupnet ()\ncan be used to find the network address and network mask for a given\ncapture device.\n.PP\nA compiled filter can also be applied directly to a packet that has been\nread using\n.BR pcap_offline_filter ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_compile (3PCAP)\ncompile filter expression to a pseudo-machine-language code program\n.TP\n.BR pcap_freecode (3PCAP)\nfree a filter program\n.TP\n.BR pcap_setfilter (3PCAP)\nset filter for a\n.B pcap_t\n.TP\n.BR pcap_lookupnet (3PCAP)\nget network address and network mask for a capture device\n.TP\n.BR pcap_offline_filter (3PCAP)\napply a filter program to a packet\n.RE\n.SS Incoming and outgoing packets\nBy default, libpcap will attempt to capture both packets sent by the\nmachine and packets received by the machine.  To limit it to capturing\nonly packets received by the machine or, if possible, only packets sent\nby the machine, call\n.BR pcap_setdirection ().\n.TP\n.BR Routines\n.RS\n.TP\n.BR pcap_setdirection (3PCAP)\nspecify whether to capture incoming packets, outgoing packets, or both\n.RE\n.SS Capture statistics\nTo get statistics about packets received and dropped in a live capture,\ncall\n.BR pcap_stats ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_stats (3PCAP)\nget capture statistics\n.RE\n.SS Opening a handle for writing captured packets\nTo open a ``savefile`` to which to write packets, given the pathname the\n``savefile'' should have, call\n.BR pcap_dump_open ();\nto set up a handle for a ``savefile'', given a\n.B \"FILE\\ *\"\nreferring to a file already opened for writing, call\n.BR pcap_dump_fopen ().\nThey each return pointers to a\n.BR pcap_dumper_t ,\nwhich is the handle used for writing packets to the ``savefile''.  If it\nsucceeds, it will have created the file if it doesn't exist and\ntruncated the file if it does exist.\nTo close a\n.BR pcap_dumper_t ,\ncall\n.BR pcap_dump_close ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_dump_open (3PCAP)\nopen a\n.B pcap_dumper_t\nfor a ``savefile``, given a pathname, replacing any existing data\n.TP\n.BR pcap_dump_open_append (3PCAP)\nopen a\n.B pcap_dumper_t\nfor a ``savefile``, given a pathname, appending to the existing data\n.TP\n.BR pcap_dump_fopen (3PCAP)\nopen a\n.B pcap_dumper_t\nfor a ``savefile``, given a\n.BR \"FILE\\ *\" ,\nassuming an empty file\n.TP\n.BR pcap_dump_close (3PCAP)\nclose a\n.B pcap_dumper_t\n.TP\n.BR pcap_dump_file (3PCAP)\nget the\n.B \"FILE\\ *\"\nfor a\n.B pcap_dumper_t\nopened for a ``savefile''\n.RE\n.SS Writing packets\nTo write a packet to a\n.BR pcap_dumper_t ,\ncall\n.BR pcap_dump ().\nPackets written with\n.BR pcap_dump ()\nmay be buffered, rather than being immediately written to the\n``savefile''.  Closing the\n.B pcap_dumper_t\nwill cause all buffered-but-not-yet-written packets to be written to the\n``savefile''.\nTo force all packets written to the\n.BR pcap_dumper_t ,\nand not yet written to the ``savefile'' because they're buffered by the\n.BR pcap_dumper_t ,\nto be written to the ``savefile'', without closing the\n.BR pcap_dumper_t ,\ncall\n.BR pcap_dump_flush ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_dump (3PCAP)\nwrite packet to a\n.B pcap_dumper_t\n.TP\n.BR pcap_dump_flush (3PCAP)\nflush buffered packets written to a\n.B pcap_dumper_t\nto the ``savefile''\n.TP\n.BR pcap_dump_ftell (3PCAP)\nget current file position for a\n.B pcap_dumper_t\n.RE\n.SS Injecting packets\nIf you have the required privileges, you can inject packets onto a\nnetwork with a\n.B pcap_t\nfor a live capture, using\n.BR pcap_inject ()\nor\n.BR pcap_sendpacket ().\n(The two routines exist for compatibility with both OpenBSD and\nWinPcap/Npcap; they perform the same function, but have different return\nvalues.)\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_inject (3PCAP)\n.PD 0\n.TP\n.BR pcap_sendpacket (3PCAP)\ntransmit a packet\n.PD\n.RE\n.SS Reporting errors\nSome routines return error or warning status codes; to convert them to a\nstring, use\n.BR pcap_statustostr ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_statustostr (3PCAP)\nget a string for an error or warning status code\n.RE\n.SS Getting library version information\nTo get a string giving version information about libpcap, call\n.BR pcap_lib_version ().\n.TP\n.B Routines\n.RS\n.TP\n.BR pcap_lib_version (3PCAP)\nget library version string\n.RE\n.SH BACKWARD COMPATIBILITY\n.PP\nIn versions of libpcap prior to 1.0, the\n.B pcap.h\nheader file was not in a\n.B pcap\ndirectory on most platforms; if you are writing an application that must\nwork on versions of libpcap prior to 1.0, include\n.BR <pcap.h> ,\nwhich will include\n.B <pcap/pcap.h>\nfor you, rather than including\n.BR <pcap/pcap.h> .\n.PP\n.BR pcap_create ()\nand\n.BR pcap_activate ()\nwere not available in versions of libpcap prior to 1.0; if you are\nwriting an application that must work on versions of libpcap prior to\n1.0, either use\n.BR pcap_open_live ()\nto get a handle for a live capture or, if you want to be able to use the\nadditional capabilities offered by using\n.BR pcap_create ()\nand\n.BR pcap_activate (),\nuse an\n.BR autoconf (1)\nscript or some other configuration script to check whether the libpcap\n1.0 APIs are available and use them only if they are.\n.SH SEE ALSO\n.BR autoconf (1),\n.BR tcpdump (1),\n.BR tcpslice (1),\n.BR \\%pcap-filter (@MAN_MISC_INFO@),\n.BR bpf (@MAN_DEVICES@),\n.BR usermod (@MAN_ADMIN_COMMANDS@)\n.SH AUTHORS\nThe original authors of libpcap are:\n.LP\nVan Jacobson,\nCraig Leres and\nSteven McCanne, all of the\nLawrence Berkeley National Laboratory, University of California, Berkeley, CA.\n.LP\nThe current version is available from \"The Tcpdump Group\"'s Web site at\n.LP\n.RS\n.I https://www.tcpdump.org/\n.RE\n.SH BUGS\nTo report a security issue please send an e-mail to \\%security@tcpdump.org.\n.LP\nTo report bugs and other problems, contribute patches, request a\nfeature, provide generic feedback etc please see the file\n.I CONTRIBUTING.md\nin the libpcap source tree root.\n"
        },
        {
          "name": "pcap.c",
          "type": "blob",
          "size": 132.6845703125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n/*\n * Include this before including any system header files, as it\n * may do some #defines that cause those headers to declare\n * more functions than they do by default.\n */\n#include \"ftmacros.h\"\n\n#include <pcap-types.h>\n#ifndef _WIN32\n#include <sys/param.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_SOCKIO_H\n#include <sys/sockio.h>\n#endif\n\n#include <net/if.h>\n#include <netinet/in.h>\n#endif /* _WIN32 */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if !defined(_MSC_VER) && !defined(__BORLANDC__) && !defined(__MINGW32__)\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n#include <errno.h>\n#include <limits.h>\n\n#include \"diag-control.h\"\n\n#include \"thread-local.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"pcap-int.h\"\n\n#include \"optimize.h\"\n\n#ifdef HAVE_DAG_API\n#include \"pcap-dag.h\"\n#endif /* HAVE_DAG_API */\n\n#ifdef HAVE_SNF_API\n#include \"pcap-snf.h\"\n#endif /* HAVE_SNF_API */\n\n#ifdef PCAP_SUPPORT_LINUX_USBMON\n#include \"pcap-usb-linux.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_BT\n#include \"pcap-bt-linux.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_BT_MONITOR\n#include \"pcap-bt-monitor-linux.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_NETFILTER\n#include \"pcap-netfilter-linux.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_NETMAP\n#include \"pcap-netmap.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_DBUS\n#include \"pcap-dbus.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_RDMASNIFF\n#include \"pcap-rdmasniff.h\"\n#endif\n\n#ifdef PCAP_SUPPORT_DPDK\n#include \"pcap-dpdk.h\"\n#endif\n\n#ifdef ENABLE_REMOTE\n#include \"pcap-rpcap.h\"\n#endif\n\n#ifdef _WIN32\n/*\n * To quote the WSAStartup() documentation:\n *\n *   The WSAStartup function typically leads to protocol-specific helper\n *   DLLs being loaded. As a result, the WSAStartup function should not\n *   be called from the DllMain function in a application DLL. This can\n *   potentially cause deadlocks.\n *\n * and the WSACleanup() documentation:\n *\n *   The WSACleanup function typically leads to protocol-specific helper\n *   DLLs being unloaded. As a result, the WSACleanup function should not\n *   be called from the DllMain function in a application DLL. This can\n *   potentially cause deadlocks.\n *\n * So we don't initialize Winsock in a DllMain() routine.\n *\n * Similarly, we cannot register an atexit() handler to call WSACleanup()\n * because that handler will be run in the context of DllMain. Therefore, we\n * call WSAStartup each time Winsock is needed and WSACleanup as soon as it is\n * no longer needed.\n */\n\n/*\n * Shut down Winsock.\n *\n * Ignores the return value of WSACleanup(); given that this is\n * an atexit() routine, there's nothing much we can do about\n * a failure.\n */\nstatic void\ninternal_wsockfini(void)\n{\n\tWSACleanup();\n}\n\n/*\n * Start Winsock.\n * Internal routine.\n */\nstatic int\ninternal_wsockinit(char *errbuf)\n{\n\treturn 0;\n}\n\n/*\n * Exported in case some applications using WinPcap/Npcap called it,\n * even though it wasn't exported.\n */\nint\nwsockinit(void)\n{\n\treturn (internal_wsockinit(NULL));\n}\n\n/*\n * This is the exported function; new programs should call this.\n * *Newer* programs should call pcap_init().\n */\nint\npcap_wsockinit(void)\n{\n\treturn (internal_wsockinit(NULL));\n}\n#endif /* _WIN32 */\n\n/*\n * Do whatever initialization is needed for libpcap.\n *\n * The argument specifies whether we use the local code page or UTF-8\n * for strings; on UN*X, we just assume UTF-8 in places where the encoding\n * would matter, whereas, on Windows, we use the local code page for\n * PCAP_CHAR_ENC_LOCAL and UTF-8 for PCAP_CHAR_ENC_UTF_8.\n *\n * On Windows, we also disable the hack in pcap_create() to deal with\n * being handed UTF-16 strings, because if the user calls this they're\n * explicitly declaring that they will either be passing local code\n * page strings or UTF-8 strings, so we don't need to allow UTF-16LE\n * strings to be passed.  For good measure, on Windows *and* UN*X,\n * we disable pcap_lookupdev(), to prevent anybody from even\n * *trying* to pass the result of pcap_lookupdev() - which might be\n * UTF-16LE on Windows, for ugly compatibility reasons - to pcap_create()\n * or pcap_open_live() or pcap_open().\n *\n * Returns 0 on success, -1 on error.\n */\nint pcapint_new_api;\t\t/* pcap_lookupdev() always fails */\nint pcapint_utf_8_mode;\t\t/* Strings should be in UTF-8. */\nint pcapint_mmap_32bit;\t\t/* Map packet buffers with 32-bit addresses. */\n\nint\npcap_init(unsigned int opts, char *errbuf)\n{\n\tstatic int initialized;\n\n\t/*\n\t * Don't allow multiple calls that set different modes; that\n\t * may mean a library is initializing pcap in one mode and\n\t * a program using that library, or another library used by\n\t * that program, is initializing it in another mode.\n\t */\n\tswitch (opts) {\n\n\tcase PCAP_CHAR_ENC_LOCAL:\n\t\t/* Leave \"UTF-8 mode\" off. */\n\t\tif (initialized) {\n\t\t\tif (pcapint_utf_8_mode) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Multiple pcap_init calls with different character encodings\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_CHAR_ENC_UTF_8:\n\t\t/* Turn on \"UTF-8 mode\". */\n\t\tif (initialized) {\n\t\t\tif (!pcapint_utf_8_mode) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Multiple pcap_init calls with different character encodings\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t}\n\t\tpcapint_utf_8_mode = 1;\n\t\tbreak;\n\n\tcase PCAP_MMAP_32BIT:\n\t\tpcapint_mmap_32bit = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"Unknown options specified\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Turn the appropriate mode on for error messages; those routines\n\t * are also used in rpcapd, which has no access to pcap's internal\n\t * UTF-8 mode flag, so we have to call a routine to set its\n\t * UTF-8 mode flag.\n\t */\n\tpcapint_fmt_set_encoding(opts);\n\n\tif (initialized) {\n\t\t/*\n\t\t * Nothing more to do; for example, on Windows, we've\n\t\t * already initialized Winsock.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * We're done.\n\t */\n\tinitialized = 1;\n\tpcapint_new_api = 1;\n\treturn (0);\n}\n\n/*\n * String containing the library version.\n * Not explicitly exported via a header file - the right API to use\n * is pcap_lib_version() - but some programs included it, so we\n * provide it.\n *\n * We declare it here, right before defining it, to squelch any\n * warnings we might get from compilers about the lack of a\n * declaration.\n */\nPCAP_API char pcap_version[];\nPCAP_API_DEF char pcap_version[] = PACKAGE_VERSION;\n\nstatic void\npcap_set_not_initialized_message(pcap_t *pcap)\n{\n\tif (pcap->activated) {\n\t\t/* A module probably forgot to set the function pointer */\n\t\t(void)snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t\t    \"This operation isn't properly handled by that device\");\n\t\treturn;\n\t}\n\t/* in case the caller doesn't check for PCAP_ERROR_NOT_ACTIVATED */\n\t(void)snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t    \"This handle hasn't been activated yet\");\n}\n\nstatic int\npcap_read_not_initialized(pcap_t *pcap, int cnt _U_, pcap_handler callback _U_,\n    u_char *user _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_inject_not_initialized(pcap_t *pcap, const void * buf _U_, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_setfilter_not_initialized(pcap_t *pcap, struct bpf_program *fp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_setdirection_not_initialized(pcap_t *pcap, pcap_direction_t d _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_set_datalink_not_initialized(pcap_t *pcap, int dlt _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_getnonblock_not_initialized(pcap_t *pcap)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_stats_not_initialized(pcap_t *pcap, struct pcap_stat *ps _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\n#ifdef _WIN32\nstatic struct pcap_stat *\npcap_stats_ex_not_initialized(pcap_t *pcap, int *pcap_stat_size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (NULL);\n}\n\nstatic int\npcap_setbuff_not_initialized(pcap_t *pcap, int dim _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_setmode_not_initialized(pcap_t *pcap, int mode _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_setmintocopy_not_initialized(pcap_t *pcap, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic HANDLE\npcap_getevent_not_initialized(pcap_t *pcap)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (INVALID_HANDLE_VALUE);\n}\n\nstatic int\npcap_oid_get_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,\n    void *data _U_, size_t *lenp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_oid_set_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,\n    const void *data _U_, size_t *lenp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic u_int\npcap_sendqueue_transmit_not_initialized(pcap_t *pcap, pcap_send_queue* queue _U_,\n    int sync _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (0);\n}\n\nstatic int\npcap_setuserbuffer_not_initialized(pcap_t *pcap, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_live_dump_not_initialized(pcap_t *pcap, char *filename _U_, int maxsize _U_,\n    int maxpacks _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n\nstatic int\npcap_live_dump_ended_not_initialized(pcap_t *pcap, int sync _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}\n#endif\n\n/*\n * Returns 1 if rfmon mode can be set on the pcap_t, 0 if it can't,\n * a PCAP_ERROR value on an error.\n */\nint\npcap_can_set_rfmon(pcap_t *p)\n{\n\treturn (p->can_set_rfmon_op(p));\n}\n\n/*\n * For systems where rfmon mode is never supported.\n */\nstatic int\npcap_cant_set_rfmon(pcap_t *p _U_)\n{\n\treturn (0);\n}\n\n/*\n * Sets *tstamp_typesp to point to an array 1 or more supported time stamp\n * types; the return value is the number of supported time stamp types.\n * The list should be freed by a call to pcap_free_tstamp_types() when\n * you're done with it.\n *\n * A return value of 0 means \"you don't get a choice of time stamp type\",\n * in which case *tstamp_typesp is set to null.\n *\n * PCAP_ERROR is returned on error.\n */\nint\npcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp)\n{\n\tif (p->tstamp_type_count == 0) {\n\t\t/*\n\t\t * We don't support multiple time stamp types.\n\t\t * That means the only type we support is PCAP_TSTAMP_HOST;\n\t\t * set up a list containing only that type.\n\t\t */\n\t\t*tstamp_typesp = (int*)malloc(sizeof(**tstamp_typesp));\n\t\tif (*tstamp_typesp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t**tstamp_typesp = PCAP_TSTAMP_HOST;\n\t\treturn (1);\n\t} else {\n\t\t*tstamp_typesp = (int*)calloc(p->tstamp_type_count,\n\t\t\t\t\t      sizeof(**tstamp_typesp));\n\t\tif (*tstamp_typesp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t(void)memcpy(*tstamp_typesp, p->tstamp_type_list,\n\t\t    sizeof(**tstamp_typesp) * p->tstamp_type_count);\n\t\treturn (p->tstamp_type_count);\n\t}\n}\n\n/*\n * In Windows, you might have a library built with one version of the\n * C runtime library and an application built with another version of\n * the C runtime library, which means that the library might use one\n * version of malloc() and free() and the application might use another\n * version of malloc() and free().  If so, that means something\n * allocated by the library cannot be freed by the application, so we\n * need to have a pcap_free_tstamp_types() routine to free up the list\n * allocated by pcap_list_tstamp_types(), even though it's just a wrapper\n * around free().\n */\nvoid\npcap_free_tstamp_types(int *tstamp_type_list)\n{\n\tfree(tstamp_type_list);\n}\n\n/*\n * Default one-shot callback; overridden for capture types where the\n * packet data cannot be guaranteed to be available after the callback\n * returns, so that a copy must be made.\n */\nvoid\npcapint_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *)user;\n\n\t*sp->hdr = *h;\n\t*sp->pkt = pkt;\n}\n\nconst u_char *\npcap_next(pcap_t *p, struct pcap_pkthdr *h)\n{\n\tstruct oneshot_userdata s;\n\tconst u_char *pkt;\n\n\ts.hdr = h;\n\ts.pkt = &pkt;\n\ts.pd = p;\n\tif (pcap_dispatch(p, 1, p->oneshot_callback, (u_char *)&s) <= 0)\n\t\treturn (0);\n\treturn (pkt);\n}\n\nint\npcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,\n    const u_char **pkt_data)\n{\n\tstruct oneshot_userdata s;\n\n\ts.hdr = &p->pcap_header;\n\ts.pkt = pkt_data;\n\ts.pd = p;\n\n\t/* Saves a pointer to the packet headers */\n\t*pkt_header= &p->pcap_header;\n\n\tif (p->rfile != NULL) {\n\t\tint status;\n\n\t\t/* We are on an offline capture */\n\t\tstatus = pcapint_offline_read(p, 1, p->oneshot_callback,\n\t\t    (u_char *)&s);\n\n\t\t/*\n\t\t * Return codes for pcapint_offline_read() are:\n\t\t *   -  0: EOF\n\t\t *   - -1: error\n\t\t *   - >0: OK - result is number of packets read, so\n\t\t *         it will be 1 in this case, as we've passed\n\t\t *         a maximum packet count of 1\n\t\t * The first one ('0') conflicts with the return code of\n\t\t * 0 from pcap_read() meaning \"no packets arrived before\n\t\t * the timeout expired\", so we map it to -2 so you can\n\t\t * distinguish between an EOF from a savefile and a\n\t\t * \"no packets arrived before the timeout expired, try\n\t\t * again\" from a live capture.\n\t\t */\n\t\tif (status == 0)\n\t\t\treturn (-2);\n\t\telse\n\t\t\treturn (status);\n\t}\n\n\t/*\n\t * Return codes for pcap_read() are:\n\t *   -  0: timeout\n\t *   - -1: error\n\t *   - -2: loop was broken out of with pcap_breakloop()\n\t *   - >0: OK, result is number of packets captured, so\n\t *         it will be 1 in this case, as we've passed\n\t *         a maximum packet count of 1\n\t * The first one ('0') conflicts with the return code of 0 from\n\t * pcapint_offline_read() meaning \"end of file\".\n\t*/\n\treturn (p->read_op(p, 1, p->oneshot_callback, (u_char *)&s));\n}\n\n/*\n * Implementation of a pcap_if_list_t.\n */\nstruct pcap_if_list {\n\tpcap_if_t *beginning;\n};\n\nstatic struct capture_source_type {\n\tint (*findalldevs_op)(pcap_if_list_t *, char *);\n\tpcap_t *(*create_op)(const char *, char *, int *);\n} capture_source_types[] = {\n#ifdef HAVE_DAG_API\n\t{ dag_findalldevs, dag_create },\n#endif\n#ifdef HAVE_SNF_API\n\t{ snf_findalldevs, snf_create },\n#endif\n#ifdef PCAP_SUPPORT_BT\n\t{ bt_findalldevs, bt_create },\n#endif\n#ifdef PCAP_SUPPORT_BT_MONITOR\n\t{ bt_monitor_findalldevs, bt_monitor_create },\n#endif\n#ifdef PCAP_SUPPORT_LINUX_USBMON\n\t{ usb_findalldevs, usb_create },\n#endif\n#ifdef PCAP_SUPPORT_NETFILTER\n\t{ netfilter_findalldevs, netfilter_create },\n#endif\n#ifdef PCAP_SUPPORT_NETMAP\n\t{ pcap_netmap_findalldevs, pcap_netmap_create },\n#endif\n#ifdef PCAP_SUPPORT_DBUS\n\t{ dbus_findalldevs, dbus_create },\n#endif\n#ifdef PCAP_SUPPORT_RDMASNIFF\n\t{ rdmasniff_findalldevs, rdmasniff_create },\n#endif\n#ifdef PCAP_SUPPORT_DPDK\n\t{ pcap_dpdk_findalldevs, pcap_dpdk_create },\n#endif\n\t{ NULL, NULL }\n};\n\n/*\n * Get a list of all capture sources that are up and that we can open.\n * Returns -1 on error, 0 otherwise.\n * The list, as returned through \"alldevsp\", may be null if no interfaces\n * were up and could be opened.\n */\nint\npcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)\n{\n\tsize_t i;\n\tpcap_if_list_t devlist;\n\n\t/*\n\t * Find all the local network interfaces on which we\n\t * can capture.\n\t */\n\tdevlist.beginning = NULL;\n\tif (pcapint_platform_finddevs(&devlist, errbuf) == -1) {\n\t\t/*\n\t\t * Failed - free all of the entries we were given\n\t\t * before we failed.\n\t\t */\n\t\tif (devlist.beginning != NULL)\n\t\t\tpcap_freealldevs(devlist.beginning);\n\t\t*alldevsp = NULL;\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Ask each of the non-local-network-interface capture\n\t * source types what interfaces they have.\n\t */\n\tfor (i = 0; capture_source_types[i].findalldevs_op != NULL; i++) {\n\t\tif (capture_source_types[i].findalldevs_op(&devlist, errbuf) == -1) {\n\t\t\t/*\n\t\t\t * We had an error; free the list we've been\n\t\t\t * constructing.\n\t\t\t */\n\t\t\tif (devlist.beginning != NULL)\n\t\t\t\tpcap_freealldevs(devlist.beginning);\n\t\t\t*alldevsp = NULL;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Return the first entry of the list of all devices.\n\t */\n\t*alldevsp = devlist.beginning;\n\treturn (0);\n}\n\nstatic struct sockaddr *\ndup_sockaddr(struct sockaddr *sa, size_t sa_length)\n{\n\tstruct sockaddr *newsa;\n\n\tif ((newsa = malloc(sa_length)) == NULL)\n\t\treturn (NULL);\n\treturn (memcpy(newsa, sa, sa_length));\n}\n\n/*\n * Construct a \"figure of merit\" for an interface, for use when sorting\n * the list of interfaces, in which interfaces that are up are superior\n * to interfaces that aren't up, interfaces that are up and running are\n * superior to interfaces that are up but not running, and non-loopback\n * interfaces that are up and running are superior to loopback interfaces,\n * and interfaces with the same flags have a figure of merit that's higher\n * the lower the instance number.\n *\n * The goal is to try to put the interfaces most likely to be useful for\n * capture at the beginning of the list.\n *\n * The figure of merit, which is lower the \"better\" the interface is,\n * has the uppermost bit set if the interface isn't running, the bit\n * below that set if the interface isn't up, the bit below that\n * set if the interface is a loopback interface, and the bit below\n * that set if it's the \"any\" interface.\n *\n * Note: we don't sort by unit number because 1) not all interfaces have\n * a unit number (systemd, for example, might assign interface names\n * based on the interface's MAC address or on the physical location of\n * the adapter's connector), and 2) if the name does end with a simple\n * unit number, it's not a global property of the interface, it's only\n * useful as a sort key for device names with the same prefix, so xyz0\n * shouldn't necessarily sort before abc2.  This means that interfaces\n * with the same figure of merit will be sorted by the order in which\n * the mechanism from which we're getting the interfaces supplies them.\n */\nstatic u_int\nget_figure_of_merit(pcap_if_t *dev)\n{\n\tu_int n;\n\n\tn = 0;\n\tif (!(dev->flags & PCAP_IF_RUNNING))\n\t\tn |= 0x80000000;\n\tif (!(dev->flags & PCAP_IF_UP))\n\t\tn |= 0x40000000;\n\n\t/*\n\t * Give non-wireless interfaces that aren't disconnected a better\n\t * figure of merit than interfaces that are disconnected, as\n\t * \"disconnected\" should indicate that the interface isn't\n\t * plugged into a network and thus won't give you any traffic.\n\t *\n\t * For wireless interfaces, it means \"associated with a network\",\n\t * which we presume not to necessarily prevent capture, as you\n\t * might run the adapter in some flavor of monitor mode.\n\t */\n\tif (!(dev->flags & PCAP_IF_WIRELESS) &&\n\t    (dev->flags & PCAP_IF_CONNECTION_STATUS) == PCAP_IF_CONNECTION_STATUS_DISCONNECTED)\n\t\tn |= 0x20000000;\n\n\t/*\n\t * Sort loopback devices after non-loopback devices, *except* for\n\t * disconnected devices.\n\t */\n\tif (dev->flags & PCAP_IF_LOOPBACK)\n\t\tn |= 0x10000000;\n\n\t/*\n\t * Sort the \"any\" device before loopback and disconnected devices,\n\t * but after all other devices.\n\t */\n\tif (strcmp(dev->name, \"any\") == 0)\n\t\tn |= 0x08000000;\n\n\treturn (n);\n}\n\n#ifndef _WIN32\n/*\n * Try to get a description for a given device.\n * Returns a malloced description if it could and NULL if it couldn't.\n *\n * XXX - on FreeBSDs that support it, should it get the sysctl named\n * \"dev.{adapter family name}.{adapter unit}.%desc\" to get a description\n * of the adapter?  Note that \"dev.an.0.%desc\" is \"Aironet PC4500/PC4800\"\n * with my Cisco 350 card, so the name isn't entirely descriptive.  The\n * \"dev.an.0.%pnpinfo\" has a better description, although one might argue\n * that the problem is really a driver bug - if it can find out that it's\n * a Cisco 340 or 350, rather than an old Aironet card, it should use\n * that in the description.\n *\n * Do NetBSD, DragonflyBSD, or OpenBSD support this as well?  FreeBSD\n * and OpenBSD let you get a description, but it's not generated by the OS,\n * it's set with another ioctl that ifconfig supports; we use that to get\n * a description in FreeBSD and OpenBSD, but if there is no such\n * description available, it still might be nice to get some description\n * string based on the device type or something such as that.\n *\n * In macOS, the System Configuration framework can apparently return\n * names in 10.4 and later.\n *\n * It also appears that freedesktop.org's HAL offers an \"info.product\"\n * string, but the HAL specification says it \"should not be used in any\n * UI\" and \"subsystem/capability specific properties\" should be used\n * instead and, in any case, I think HAL is being deprecated in\n * favor of other stuff such as DeviceKit.  DeviceKit doesn't appear\n * to have any obvious product information for devices, but maybe\n * I haven't looked hard enough.\n *\n * Using the System Configuration framework, or HAL, or DeviceKit, or\n * whatever, would require that libpcap applications be linked with\n * the frameworks/libraries in question.  That shouldn't be a problem\n * for programs linking with the shared version of libpcap (unless\n * you're running on AIX - which I think is the only UN*X that doesn't\n * support linking a shared library with other libraries on which it\n * depends, and having an executable linked only with the first shared\n * library automatically pick up the other libraries when started -\n * and using HAL or whatever).  Programs linked with the static\n * version of libpcap would have to use pcap-config with the --static\n * flag in order to get the right linker flags in order to pick up\n * the additional libraries/frameworks; those programs need that anyway\n * for libpcap 1.1 and beyond on Linux, as, by default, it requires\n * -lnl.\n *\n * Do any other UN*Xes, or desktop environments support getting a\n * description?\n */\nstatic char *\n#ifdef SIOCGIFDESCR\nget_if_description(const char *name)\n{\n\tchar *description = NULL;\n\tint s;\n\tstruct ifreq ifrdesc;\n#ifndef IFDESCRSIZE\n\tsize_t descrlen = 64;\n#else\n\tsize_t descrlen = IFDESCRSIZE;\n#endif /* IFDESCRSIZE */\n\n\t/*\n\t * Get the description for the interface.\n\t */\n\tmemset(&ifrdesc, 0, sizeof ifrdesc);\n\tpcapint_strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);\n\ts = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (s >= 0) {\n#ifdef __FreeBSD__\n\t\t/*\n\t\t * On FreeBSD, if the buffer isn't big enough for the\n\t\t * description, the ioctl succeeds, but the description\n\t\t * isn't copied, ifr_buffer.length is set to the description\n\t\t * length, and ifr_buffer.buffer is set to NULL.\n\t\t */\n\t\tfor (;;) {\n\t\t\tfree(description);\n\t\t\tif ((description = malloc(descrlen)) != NULL) {\n\t\t\t\tifrdesc.ifr_buffer.buffer = description;\n\t\t\t\tifrdesc.ifr_buffer.length = descrlen;\n\t\t\t\tif (ioctl(s, SIOCGIFDESCR, &ifrdesc) == 0) {\n\t\t\t\t\tif (ifrdesc.ifr_buffer.buffer ==\n\t\t\t\t\t    description)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tdescrlen = ifrdesc.ifr_buffer.length;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Failed to get interface description.\n\t\t\t\t\t */\n\t\t\t\t\tfree(description);\n\t\t\t\t\tdescription = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#else /* __FreeBSD__ */\n\t\t/*\n\t\t * The only other OS that currently supports\n\t\t * SIOCGIFDESCR is OpenBSD, and it has no way\n\t\t * to get the description length - it's clamped\n\t\t * to a maximum of IFDESCRSIZE.\n\t\t */\n\t\tif ((description = malloc(descrlen)) != NULL) {\n\t\t\tifrdesc.ifr_data = (caddr_t)description;\n\t\t\tif (ioctl(s, SIOCGIFDESCR, &ifrdesc) != 0) {\n\t\t\t\t/*\n\t\t\t\t * Failed to get interface description.\n\t\t\t\t */\n\t\t\t\tfree(description);\n\t\t\t\tdescription = NULL;\n\t\t\t}\n\t\t}\n#endif /* __FreeBSD__ */\n\t\tclose(s);\n\t\tif (description != NULL && description[0] == '\\0') {\n\t\t\t/*\n\t\t\t * Description is empty, so discard it.\n\t\t\t */\n\t\t\tfree(description);\n\t\t\tdescription = NULL;\n\t\t}\n\t}\n\n#ifdef __FreeBSD__\n\t/*\n\t * For FreeBSD, if we didn't get a description, and this is\n\t * a device with a name of the form usbusN, label it as a USB\n\t * bus.\n\t */\n\tif (description == NULL) {\n\t\tif (strncmp(name, \"usbus\", 5) == 0) {\n\t\t\t/*\n\t\t\t * OK, it begins with \"usbus\".\n\t\t\t */\n\t\t\tlong busnum;\n\t\t\tchar *p;\n\n\t\t\terrno = 0;\n\t\t\tbusnum = strtol(name + 5, &p, 10);\n\t\t\tif (errno == 0 && p != name + 5 && *p == '\\0' &&\n\t\t\t    busnum >= 0 && busnum <= INT_MAX) {\n\t\t\t\t/*\n\t\t\t\t * OK, it's a valid number that's not\n\t\t\t\t * bigger than INT_MAX.  Construct\n\t\t\t\t * a description from it.\n\t\t\t\t * (If that fails, we don't worry about\n\t\t\t\t * it, we just return NULL.)\n\t\t\t\t */\n\t\t\t\tif (pcapint_asprintf(&description,\n\t\t\t\t    \"USB bus number %ld\", busnum) == -1) {\n\t\t\t\t\t/* Failed. */\n\t\t\t\t\tdescription = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn (description);\n#else /* SIOCGIFDESCR */\nget_if_description(const char *name _U_)\n{\n\treturn (NULL);\n#endif /* SIOCGIFDESCR */\n}\n\n/*\n * Look for a given device in the specified list of devices.\n *\n * If we find it, return a pointer to its entry.\n *\n * If we don't find it, attempt to add an entry for it, with the specified\n * IFF_ flags and description, and, if that succeeds, return a pointer to\n * the new entry, otherwise return NULL and set errbuf to an error message.\n */\npcap_if_t *\npcapint_find_or_add_if(pcap_if_list_t *devlistp, const char *name,\n    uint64_t if_flags, get_if_flags_func get_flags_func, char *errbuf)\n{\n\tbpf_u_int32 pcap_flags;\n\n\t/*\n\t * Convert IFF_ flags to pcap flags.\n\t */\n\tpcap_flags = 0;\n#ifdef IFF_LOOPBACK\n\tif (if_flags & IFF_LOOPBACK)\n\t\tpcap_flags |= PCAP_IF_LOOPBACK;\n#else\n\t/*\n\t * We don't have IFF_LOOPBACK, so look at the device name to\n\t * see if it looks like a loopback device.\n\t */\n\tif (name[0] == 'l' && name[1] == 'o' &&\n\t    (PCAP_ISDIGIT(name[2]) || name[2] == '\\0'))\n\t\tpcap_flags |= PCAP_IF_LOOPBACK;\n#endif\n#ifdef IFF_UP\n\tif (if_flags & IFF_UP)\n\t\tpcap_flags |= PCAP_IF_UP;\n#endif\n#ifdef IFF_RUNNING\n\tif (if_flags & IFF_RUNNING)\n\t\tpcap_flags |= PCAP_IF_RUNNING;\n#endif\n\n\t/*\n\t * Attempt to find an entry for this device; if we don't find one,\n\t * attempt to add one.\n\t */\n\treturn (pcapint_find_or_add_dev(devlistp, name, pcap_flags,\n\t    get_flags_func, get_if_description(name), errbuf));\n}\n\n/*\n * Look for a given device in the specified list of devices.\n *\n * If we find it, then, if the specified address isn't null, add it to\n * the list of addresses for the device and return 0.\n *\n * If we don't find it, attempt to add an entry for it, with the specified\n * IFF_ flags and description, and, if that succeeds, add the specified\n * address to its list of addresses if that address is non-null, and\n * return 0, otherwise return -1 and set errbuf to an error message.\n *\n * (We can get called with a null address because we might get a list\n * of interface name/address combinations from the underlying OS, with\n * the address being absent in some cases, rather than a list of\n * interfaces with each interface having a list of addresses, so this\n * call may be the only call made to add to the list, and we want to\n * add interfaces even if they have no addresses.)\n */\nint\npcapint_add_addr_to_if(pcap_if_list_t *devlistp, const char *name,\n    uint64_t if_flags, get_if_flags_func get_flags_func,\n    struct sockaddr *addr, size_t addr_size,\n    struct sockaddr *netmask, size_t netmask_size,\n    struct sockaddr *broadaddr, size_t broadaddr_size,\n    struct sockaddr *dstaddr, size_t dstaddr_size,\n    char *errbuf)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Check whether the device exists and, if not, add it.\n\t */\n\tcurdev = pcapint_find_or_add_if(devlistp, name, if_flags, get_flags_func,\n\t    errbuf);\n\tif (curdev == NULL) {\n\t\t/*\n\t\t * Error - give up.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\tif (addr == NULL) {\n\t\t/*\n\t\t * There's no address to add; this entry just meant\n\t\t * \"here's a new interface\".\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * \"curdev\" is an entry for this interface, and we have an\n\t * address for it; add an entry for that address to the\n\t * interface's list of addresses.\n\t */\n\treturn (pcapint_add_addr_to_dev(curdev, addr, addr_size, netmask,\n\t    netmask_size, broadaddr, broadaddr_size, dstaddr,\n\t    dstaddr_size, errbuf));\n}\n#endif /* _WIN32 */\n\n/*\n * Add an entry to the list of addresses for an interface.\n * \"curdev\" is the entry for that interface.\n */\nint\npcapint_add_addr_to_dev(pcap_if_t *curdev,\n    struct sockaddr *addr, size_t addr_size,\n    struct sockaddr *netmask, size_t netmask_size,\n    struct sockaddr *broadaddr, size_t broadaddr_size,\n    struct sockaddr *dstaddr, size_t dstaddr_size,\n    char *errbuf)\n{\n\tpcap_addr_t *curaddr, *prevaddr, *nextaddr;\n\n\t/*\n\t * Allocate the new entry and fill it in.\n\t */\n\tcuraddr = (pcap_addr_t *)malloc(sizeof(pcap_addr_t));\n\tif (curaddr == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\n\tcuraddr->next = NULL;\n\tif (addr != NULL && addr_size != 0) {\n\t\tcuraddr->addr = (struct sockaddr *)dup_sockaddr(addr, addr_size);\n\t\tif (curaddr->addr == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->addr = NULL;\n\n\tif (netmask != NULL && netmask_size != 0) {\n\t\tcuraddr->netmask = (struct sockaddr *)dup_sockaddr(netmask, netmask_size);\n\t\tif (curaddr->netmask == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->netmask = NULL;\n\n\tif (broadaddr != NULL && broadaddr_size != 0) {\n\t\tcuraddr->broadaddr = (struct sockaddr *)dup_sockaddr(broadaddr, broadaddr_size);\n\t\tif (curaddr->broadaddr == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->netmask != NULL)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->broadaddr = NULL;\n\n\tif (dstaddr != NULL && dstaddr_size != 0) {\n\t\tcuraddr->dstaddr = (struct sockaddr *)dup_sockaddr(dstaddr, dstaddr_size);\n\t\tif (curaddr->dstaddr == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->broadaddr != NULL)\n\t\t\t\tfree(curaddr->broadaddr);\n\t\t\tif (curaddr->netmask != NULL)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->dstaddr = NULL;\n\n\t/*\n\t * Find the end of the list of addresses.\n\t */\n\tfor (prevaddr = curdev->addresses; prevaddr != NULL; prevaddr = nextaddr) {\n\t\tnextaddr = prevaddr->next;\n\t\tif (nextaddr == NULL) {\n\t\t\t/*\n\t\t\t * This is the end of the list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prevaddr == NULL) {\n\t\t/*\n\t\t * The list was empty; this is the first member.\n\t\t */\n\t\tcurdev->addresses = curaddr;\n\t} else {\n\t\t/*\n\t\t * \"prevaddr\" is the last member of the list; append\n\t\t * this member to it.\n\t\t */\n\t\tprevaddr->next = curaddr;\n\t}\n\n\treturn (0);\n}\n\n/*\n * Look for a given device in the specified list of devices.\n *\n * If we find it, return 0 and set *curdev_ret to point to it.\n *\n * If we don't find it, attempt to add an entry for it, with the specified\n * flags and description, and, if that succeeds, return 0, otherwise\n * return -1 and set errbuf to an error message.\n */\npcap_if_t *\npcapint_find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    get_if_flags_func get_flags_func, const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Is there already an entry in the list for this device?\n\t */\n\tcurdev = pcapint_find_dev(devlistp, name);\n\tif (curdev != NULL) {\n\t\t/*\n\t\t * Yes, return it.\n\t\t */\n\t\treturn (curdev);\n\t}\n\n\t/*\n\t * No, we didn't find it.\n\t */\n\n\t/*\n\t * Try to get additional flags for the device.\n\t */\n\tif ((*get_flags_func)(name, &flags, errbuf) == -1) {\n\t\t/*\n\t\t * Failed.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now, try to add it to the list of devices.\n\t */\n\treturn (pcapint_add_dev(devlistp, name, flags, description, errbuf));\n}\n\n/*\n * Look for a given device in the specified list of devices, and return\n * the entry for it if we find it or NULL if we don't.\n */\npcap_if_t *\npcapint_find_dev(pcap_if_list_t *devlistp, const char *name)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Is there an entry in the list for this device?\n\t */\n\tfor (curdev = devlistp->beginning; curdev != NULL;\n\t    curdev = curdev->next) {\n\t\tif (strcmp(name, curdev->name) == 0) {\n\t\t\t/*\n\t\t\t * We found it, so, yes, there is.  No need to\n\t\t\t * add it.  Provide the entry we found to our\n\t\t\t * caller.\n\t\t\t */\n\t\t\treturn (curdev);\n\t\t}\n\t}\n\n\t/*\n\t * No.\n\t */\n\treturn (NULL);\n}\n\n/*\n * Attempt to add an entry for a device, with the specified flags\n * and description, and, if that succeeds, return 0 and return a pointer\n * to the new entry, otherwise return NULL and set errbuf to an error\n * message.\n *\n * If we weren't given a description, try to get one.\n */\npcap_if_t *\npcapint_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev, *prevdev, *nextdev;\n\tu_int this_figure_of_merit, nextdev_figure_of_merit;\n\n\tcurdev = malloc(sizeof(pcap_if_t));\n\tif (curdev == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Fill in the entry.\n\t */\n\tcurdev->next = NULL;\n\tcurdev->name = strdup(name);\n\tif (curdev->name == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tfree(curdev);\n\t\treturn (NULL);\n\t}\n\tif (description == NULL) {\n\t\t/*\n\t\t * We weren't handed a description for the interface.\n\t\t */\n\t\tcurdev->description = NULL;\n\t} else {\n\t\t/*\n\t\t * We were handed a description; make a copy.\n\t\t */\n\t\tcurdev->description = strdup(description);\n\t\tif (curdev->description == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(curdev->name);\n\t\t\tfree(curdev);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tcurdev->addresses = NULL;\t/* list starts out as empty */\n\tcurdev->flags = flags;\n\n\t/*\n\t * Add it to the list, in the appropriate location.\n\t * First, get the \"figure of merit\" for this interface.\n\t *\n\t * To have the list of devices ordered correctly, after adding a\n\t * device to the list the device flags value must not change (i.e. it\n\t * should be set correctly beforehand).\n\t */\n\tthis_figure_of_merit = get_figure_of_merit(curdev);\n\n\t/*\n\t * Now look for the last interface with an figure of merit\n\t * less than or equal to the new interface's figure of merit.\n\t *\n\t * We start with \"prevdev\" being NULL, meaning we're before\n\t * the first element in the list.\n\t */\n\tprevdev = NULL;\n\tfor (;;) {\n\t\t/*\n\t\t * Get the interface after this one.\n\t\t */\n\t\tif (prevdev == NULL) {\n\t\t\t/*\n\t\t\t * The next element is the first element.\n\t\t\t */\n\t\t\tnextdev = devlistp->beginning;\n\t\t} else\n\t\t\tnextdev = prevdev->next;\n\n\t\t/*\n\t\t * Are we at the end of the list?\n\t\t */\n\t\tif (nextdev == NULL) {\n\t\t\t/*\n\t\t\t * Yes - we have to put the new entry after \"prevdev\".\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Is the new interface's figure of merit less\n\t\t * than the next interface's figure of merit,\n\t\t * meaning that the new interface is better\n\t\t * than the next interface?\n\t\t */\n\t\tnextdev_figure_of_merit = get_figure_of_merit(nextdev);\n\t\tif (this_figure_of_merit < nextdev_figure_of_merit) {\n\t\t\t/*\n\t\t\t * Yes - we should put the new entry\n\t\t\t * before \"nextdev\", i.e. after \"prevdev\".\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tprevdev = nextdev;\n\t}\n\n\t/*\n\t * Insert before \"nextdev\".\n\t */\n\tcurdev->next = nextdev;\n\n\t/*\n\t * Insert after \"prevdev\" - unless \"prevdev\" is null,\n\t * in which case this is the first interface.\n\t */\n\tif (prevdev == NULL) {\n\t\t/*\n\t\t * This is the first interface.  Make it\n\t\t * the first element in the list of devices.\n\t\t */\n\t\tdevlistp->beginning = curdev;\n\t} else\n\t\tprevdev->next = curdev;\n\treturn (curdev);\n}\n\n/*\n * Add an entry for the \"any\" device.\n */\npcap_if_t *\npcapint_add_any_dev(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tstatic const char any_descr[] = \"Pseudo-device that captures on all interfaces\";\n\n\t/*\n\t * As it refers to all network devices, not to any particular\n\t * network device, the notion of \"connected\" vs. \"disconnected\"\n\t * doesn't apply to the \"any\" device.\n\t */\n\treturn pcapint_add_dev(devlistp, \"any\",\n\t    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    any_descr, errbuf);\n}\n\n/*\n * Free a list of interfaces.\n */\nvoid\npcap_freealldevs(pcap_if_t *alldevs)\n{\n\tpcap_if_t *curdev, *nextdev;\n\tpcap_addr_t *curaddr, *nextaddr;\n\n\tfor (curdev = alldevs; curdev != NULL; curdev = nextdev) {\n\t\tnextdev = curdev->next;\n\n\t\t/*\n\t\t * Free all addresses.\n\t\t */\n\t\tfor (curaddr = curdev->addresses; curaddr != NULL; curaddr = nextaddr) {\n\t\t\tnextaddr = curaddr->next;\n\t\t\tif (curaddr->addr)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tif (curaddr->netmask)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->broadaddr)\n\t\t\t\tfree(curaddr->broadaddr);\n\t\t\tif (curaddr->dstaddr)\n\t\t\t\tfree(curaddr->dstaddr);\n\t\t\tfree(curaddr);\n\t\t}\n\n\t\t/*\n\t\t * Free the name string.\n\t\t */\n\t\tfree(curdev->name);\n\n\t\t/*\n\t\t * Free the description string, if any.\n\t\t */\n\t\tif (curdev->description != NULL)\n\t\t\tfree(curdev->description);\n\n\t\t/*\n\t\t * Free the interface.\n\t\t */\n\t\tfree(curdev);\n\t}\n}\n\n/*\n * pcap-npf.c has its own pcap_lookupdev(), for compatibility reasons, as\n * it actually returns the names of all interfaces, with a NUL separator\n * between them; some callers may depend on that.\n *\n * In all other cases, we just use pcap_findalldevs() to get a list of\n * devices, and pick from that list.\n */\n#if !defined(HAVE_PACKET32)\n/*\n * Return the name of a network interface attached to the system, or NULL\n * if none can be found.  The interface must be configured up; the\n * lowest unit number is preferred; loopback is ignored.\n */\nchar *\npcap_lookupdev(char *errbuf)\n{\n\tpcap_if_t *alldevs;\n#ifdef _WIN32\n  /*\n   * Windows - use the same size as the old WinPcap 3.1 code.\n   * XXX - this is probably bigger than it needs to be.\n   */\n  #define IF_NAMESIZE 8192\n#else\n  /*\n   * UN*X - use the system's interface name size.\n   * XXX - that might not be large enough for capture devices\n   * that aren't regular network interfaces.\n   */\n#endif\n\tstatic char device[IF_NAMESIZE + 1];\n\tchar *ret;\n\n\t/*\n\t * We disable this in \"new API\" mode, because 1) in WinPcap/Npcap,\n\t * it may return UTF-16 strings, for backwards-compatibility\n\t * reasons, and we're also disabling the hack to make that work,\n\t * for not-going-past-the-end-of-a-string reasons, and 2) we\n\t * want its behavior to be consistent.\n\t *\n\t * In addition, it's not thread-safe, so we've marked it as\n\t * deprecated.\n\t */\n\tif (pcapint_new_api) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()\");\n\t\treturn (NULL);\n\t}\n\n\tif (pcap_findalldevs(&alldevs, errbuf) == -1)\n\t\treturn (NULL);\n\n\tif (alldevs == NULL || (alldevs->flags & PCAP_IF_LOOPBACK)) {\n\t\t/*\n\t\t * There are no devices on the list, or the first device\n\t\t * on the list is a loopback device, which means there\n\t\t * are no non-loopback devices on the list.  This means\n\t\t * we can't return any device.\n\t\t *\n\t\t * XXX - why not return a loopback device?  If we can't\n\t\t * capture on it, it won't be on the list, and if it's\n\t\t * on the list, there aren't any non-loopback devices,\n\t\t * so why not just supply it as the default device?\n\t\t */\n\t\t(void)pcapint_strlcpy(errbuf, \"no suitable device found\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\tret = NULL;\n\t} else {\n\t\t/*\n\t\t * Return the name of the first device on the list.\n\t\t */\n\t\t(void)pcapint_strlcpy(device, alldevs->name, sizeof(device));\n\t\tret = device;\n\t}\n\n\tpcap_freealldevs(alldevs);\n\treturn (ret);\n}\n#endif /* !defined(HAVE_PACKET32) */\n\n#if !defined(_WIN32)\n/*\n * We don't just fetch the entire list of devices, search for the\n * particular device, and use its first IPv4 address, as that's too\n * much work to get just one device's netmask.\n *\n * If we had an API to get attributes for a given device, we could\n * use that.\n */\nint\npcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,\n    char *errbuf)\n{\n\tregister int fd;\n\tregister struct sockaddr_in *sin4;\n\tstruct ifreq ifr;\n\n\t/*\n\t * The pseudo-device \"any\" listens on all interfaces and therefore\n\t * has the network address and -mask \"0.0.0.0\" therefore catching\n\t * all traffic. Using NULL for the interface is the same as \"any\".\n\t */\n\tif (!device || strcmp(device, \"any\") == 0\n#ifdef HAVE_DAG_API\n\t    || strstr(device, \"dag\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_BT\n\t    || strstr(device, \"bluetooth\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_LINUX_USBMON\n\t    || strstr(device, \"usbmon\") != NULL\n#endif\n#ifdef HAVE_SNF_API\n\t    || strstr(device, \"snf\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_NETMAP\n\t    || strncmp(device, \"netmap:\", 7) == 0\n\t    || strncmp(device, \"vale\", 4) == 0\n#endif\n#ifdef PCAP_SUPPORT_DPDK\n\t    || strncmp(device, \"dpdk:\", 5) == 0\n#endif\n\t    ) {\n\t\t*netp = *maskp = 0;\n\t\treturn (0);\n\t}\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn (-1);\n\t}\n\tmemset(&ifr, 0, sizeof(ifr));\n#ifdef __linux__\n\t/* XXX Work around Linux kernel bug */\n\tifr.ifr_addr.sa_family = AF_INET;\n#endif\n\t(void)pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n#if defined(__HAIKU__) && defined(__clang__)\n\t/*\n\t * In Haiku R1/beta4 <unistd.h> ioctl() is a macro that needs to take 4\n\t * arguments to initialize its intermediate 2-member structure fully so\n\t * that Clang does not generate a -Wmissing-field-initializers warning\n\t * (which manifests only when it runs with -Werror).  This workaround\n\t * can be removed as soon as there is a Haiku release that fixes the\n\t * problem.  See also https://review.haiku-os.org/c/haiku/+/6369\n\t */\n\tif (ioctl(fd, SIOCGIFADDR, (char *)&ifr, sizeof(ifr)) < 0) {\n#else\n\tif (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {\n#endif /* __HAIKU__ && __clang__ */\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: no IPv4 address assigned\", device);\n\t\t} else {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFADDR: %s\", device);\n\t\t}\n\t\t(void)close(fd);\n\t\treturn (-1);\n\t}\n\tsin4 = (struct sockaddr_in *)&ifr.ifr_addr;\n\t*netp = sin4->sin_addr.s_addr;\n\tmemset(&ifr, 0, sizeof(ifr));\n#ifdef __linux__\n\t/* XXX Work around Linux kernel bug */\n\tifr.ifr_addr.sa_family = AF_INET;\n#endif\n\t(void)pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n#if defined(__HAIKU__) && defined(__clang__)\n\t/* Same as above. */\n\tif (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr, sizeof(ifr)) < 0) {\n#else\n\tif (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {\n#endif /* __HAIKU__ && __clang__ */\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFNETMASK: %s\", device);\n\t\t(void)close(fd);\n\t\treturn (-1);\n\t}\n\t(void)close(fd);\n\t*maskp = sin4->sin_addr.s_addr;\n\tif (*maskp == 0) {\n\t\tif (IN_CLASSA(*netp))\n\t\t\t*maskp = IN_CLASSA_NET;\n\t\telse if (IN_CLASSB(*netp))\n\t\t\t*maskp = IN_CLASSB_NET;\n\t\telse if (IN_CLASSC(*netp))\n\t\t\t*maskp = IN_CLASSC_NET;\n\t\telse {\n\t\t\t(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"inet class for 0x%x unknown\", *netp);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t*netp &= *maskp;\n\treturn (0);\n}\n#endif /* !defined(_WIN32) */\n\n/*\n * Extract a substring from a string.\n */\nstatic char *\nget_substring(const char *p, size_t len, char *ebuf)\n{\n\tchar *token;\n\n\ttoken = malloc(len + 1);\n\tif (token == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\tmemcpy(token, p, len);\n\ttoken[len] = '\\0';\n\treturn (token);\n}\n\n/*\n * Parse a capture source that might be a URL.\n *\n * If the source is not a URL, *schemep, *userinfop, *hostp, and *portp\n * are set to NULL, *pathp is set to point to the source, and 0 is\n * returned.\n *\n * If source is a URL, and the URL refers to a local device (a special\n * case of rpcap:), *schemep, *userinfop, *hostp, and *portp are set\n * to NULL, *pathp is set to point to the device name, and 0 is returned.\n *\n * If source is a URL, and it's not a special case that refers to a local\n * device, and the parse succeeds:\n *\n *    *schemep is set to point to an allocated string containing the scheme;\n *\n *    if user information is present in the URL, *userinfop is set to point\n *    to an allocated string containing the user information, otherwise\n *    it's set to NULL;\n *\n *    if host information is present in the URL, *hostp is set to point\n *    to an allocated string containing the host information, otherwise\n *    it's set to NULL;\n *\n *    if a port number is present in the URL, *portp is set to point\n *    to an allocated string containing the port number, otherwise\n *    it's set to NULL;\n *\n *    *pathp is set to point to an allocated string containing the\n *    path;\n *\n * and 0 is returned.\n *\n * If the parse fails, ebuf is set to an error string, and -1 is returned.\n */\nstatic int\npcap_parse_source(const char *source, char **schemep, char **userinfop,\n    char **hostp, char **portp, char **pathp, char *ebuf)\n{\n\tchar *colonp;\n\tsize_t scheme_len;\n\tchar *scheme;\n\tconst char *endp;\n\tsize_t authority_len;\n\tchar *authority;\n\tchar *parsep, *atsignp, *bracketp;\n\tchar *userinfo, *host, *port, *path;\n\n\t/*\n\t * Start out returning nothing.\n\t */\n\t*schemep = NULL;\n\t*userinfop = NULL;\n\t*hostp = NULL;\n\t*portp = NULL;\n\t*pathp = NULL;\n\n\t/*\n\t * RFC 3986 says:\n\t *\n\t *   URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\t *\n\t *   hier-part   = \"//\" authority path-abempty\n\t *               / path-absolute\n\t *               / path-rootless\n\t *               / path-empty\n\t *\n\t *   authority   = [ userinfo \"@\" ] host [ \":\" port ]\n\t *\n\t *   userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n         *\n         * Step 1: look for the \":\" at the end of the scheme.\n\t * A colon in the source is *NOT* sufficient to indicate that\n\t * this is a URL, as interface names on some platforms might\n\t * include colons (e.g., I think some Solaris interfaces\n\t * might).\n\t */\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL) {\n\t\t/*\n\t\t * The source is the device to open.\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\t*pathp = strdup(source);\n\t\tif (*pathp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * All schemes must have \"//\" after them, i.e. we only support\n\t * hier-part   = \"//\" authority path-abempty, not\n\t * hier-part   = path-absolute\n\t * hier-part   = path-rootless\n\t * hier-part   = path-empty\n\t *\n\t * We need that in order to distinguish between a local device\n\t * name that happens to contain a colon and a URI.\n\t */\n\tif (strncmp(colonp + 1, \"//\", 2) != 0) {\n\t\t/*\n\t\t * The source is the device to open.\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\t*pathp = strdup(source);\n\t\tif (*pathp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * XXX - check whether the purported scheme could be a scheme?\n\t */\n\n\t/*\n\t * OK, this looks like a URL.\n\t * Get the scheme.\n\t */\n\tscheme_len = colonp - source;\n\tscheme = malloc(scheme_len + 1);\n\tif (scheme == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\tmemcpy(scheme, source, scheme_len);\n\tscheme[scheme_len] = '\\0';\n\n\t/*\n\t * Treat file: specially - take everything after file:// as\n\t * the pathname.\n\t */\n\tif (pcapint_strcasecmp(scheme, \"file\") == 0) {\n\t\t*pathp = strdup(colonp + 3);\n\t\tif (*pathp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(scheme);\n\t\t\treturn (-1);\n\t\t}\n\t\t*schemep = scheme;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * The WinPcap documentation says you can specify a local\n\t * interface with \"rpcap://{device}\"; we special-case\n\t * that here.  If the scheme is \"rpcap\", and there are\n\t * no slashes past the \"//\", we just return the device.\n\t *\n\t * XXX - %-escaping?\n\t */\n\tif ((pcapint_strcasecmp(scheme, \"rpcap\") == 0 ||\n\t    pcapint_strcasecmp(scheme, \"rpcaps\") == 0) &&\n\t    strchr(colonp + 3, '/') == NULL) {\n\t\t/*\n\t\t * Local device.\n\t\t *\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\tfree(scheme);\n\t\t*pathp = strdup(colonp + 3);\n\t\tif (*pathp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * OK, now start parsing the authority.\n\t * Get token, terminated with / or terminated at the end of\n\t * the string.\n\t */\n\tauthority_len = strcspn(colonp + 3, \"/\");\n\tauthority = get_substring(colonp + 3, authority_len, ebuf);\n\tif (authority == NULL) {\n\t\t/*\n\t\t * Error.\n\t\t */\n\t\tfree(scheme);\n\t\treturn (-1);\n\t}\n\tendp = colonp + 3 + authority_len;\n\n\t/*\n\t * Now carve the authority field into its components.\n\t */\n\tparsep = authority;\n\n\t/*\n\t * Is there a userinfo field?\n\t */\n\tatsignp = strchr(parsep, '@');\n\tif (atsignp != NULL) {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tsize_t userinfo_len;\n\n\t\tuserinfo_len = atsignp - parsep;\n\t\tuserinfo = get_substring(parsep, userinfo_len, ebuf);\n\t\tif (userinfo == NULL) {\n\t\t\t/*\n\t\t\t * Error.\n\t\t\t */\n\t\t\tfree(authority);\n\t\t\tfree(scheme);\n\t\t\treturn (-1);\n\t\t}\n\t\tparsep = atsignp + 1;\n\t} else {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tuserinfo = NULL;\n\t}\n\n\t/*\n\t * Is there a host field?\n\t */\n\tif (*parsep == '\\0') {\n\t\t/*\n\t\t * No; there's no host field or port field.\n\t\t */\n\t\thost = NULL;\n\t\tport = NULL;\n\t} else {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tsize_t host_len;\n\n\t\t/*\n\t\t * Is it an IP-literal?\n\t\t */\n\t\tif (*parsep == '[') {\n\t\t\t/*\n\t\t\t * Yes.\n\t\t\t * Treat everything up to the closing square\n\t\t\t * bracket as the IP-Literal; we don't worry\n\t\t\t * about whether it's a valid IPv6address or\n\t\t\t * IPvFuture (or an IPv4address, for that\n\t\t\t * matter, just in case we get handed a\n\t\t\t * URL with an IPv4 IP-Literal, of the sort\n\t\t\t * that pcap_createsrcstr() used to generate,\n\t\t\t * and that pcap_parsesrcstr(), in the original\n\t\t\t * WinPcap code, accepted).\n\t\t\t */\n\t\t\tbracketp = strchr(parsep, ']');\n\t\t\tif (bracketp == NULL) {\n\t\t\t\t/*\n\t\t\t\t * There's no closing square bracket.\n\t\t\t\t */\n\t\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"IP-literal in URL doesn't end with ]\");\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (*(bracketp + 1) != '\\0' &&\n\t\t\t    *(bracketp + 1) != ':') {\n\t\t\t\t/*\n\t\t\t\t * There's extra crud after the\n\t\t\t\t * closing square bracket.\n\t\t\t\t */\n\t\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Extra text after IP-literal in URL\");\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\thost_len = (bracketp - 1) - parsep;\n\t\t\thost = get_substring(parsep + 1, host_len, ebuf);\n\t\t\tif (host == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tparsep = bracketp + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t * Treat everything up to a : or the end of\n\t\t\t * the string as the host.\n\t\t\t */\n\t\t\thost_len = strcspn(parsep, \":\");\n\t\t\thost = get_substring(parsep, host_len, ebuf);\n\t\t\tif (host == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tparsep = parsep + host_len;\n\t\t}\n\n\t\t/*\n\t\t * Is there a port field?\n\t\t */\n\t\tif (*parsep == ':') {\n\t\t\t/*\n\t\t\t * Yes.  It's the rest of the authority field.\n\t\t\t */\n\t\t\tsize_t port_len;\n\n\t\t\tparsep++;\n\t\t\tport_len = strlen(parsep);\n\t\t\tport = get_substring(parsep, port_len, ebuf);\n\t\t\tif (port == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(host);\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tport = NULL;\n\t\t}\n\t}\n\tfree(authority);\n\n\t/*\n\t * Everything else is the path.  Strip off the leading /.\n\t */\n\tif (*endp == '\\0')\n\t\tpath = strdup(\"\");\n\telse\n\t\tpath = strdup(endp + 1);\n\tif (path == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tfree(port);\n\t\tfree(host);\n\t\tfree(userinfo);\n\t\tfree(scheme);\n\t\treturn (-1);\n\t}\n\t*schemep = scheme;\n\t*userinfop = userinfo;\n\t*hostp = host;\n\t*portp = port;\n\t*pathp = path;\n\treturn (0);\n}\n\nint\npcapint_createsrcstr_ex(char *source, int type, const char *userinfo, const char *host,\n    const char *port, const char *name, unsigned char uses_ssl, char *errbuf)\n{\n\tswitch (type) {\n\n\tcase PCAP_SRC_FILE:\n\t\tpcapint_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);\n\t\tif (name != NULL && *name != '\\0') {\n\t\t\tpcapint_strlcat(source, name, PCAP_BUF_SIZE);\n\t\t\treturn (0);\n\t\t} else {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The file name cannot be NULL.\");\n\t\t\treturn (-1);\n\t\t}\n\n\tcase PCAP_SRC_IFREMOTE:\n\t\tpcapint_strlcpy(source,\n\t\t    (uses_ssl ? \"rpcaps://\" : PCAP_SRC_IF_STRING),\n\t\t    PCAP_BUF_SIZE);\n\t\tif (host != NULL && *host != '\\0') {\n\t\t\tif (userinfo != NULL && *userinfo != '\\0') {\n\t\t\t\tpcapint_strlcat(source, userinfo, PCAP_BUF_SIZE);\n\t\t\t\tpcapint_strlcat(source, \"@\", PCAP_BUF_SIZE);\n\t\t\t}\n\n\t\t\tif (strchr(host, ':') != NULL) {\n\t\t\t\t/*\n\t\t\t\t * The host name contains a colon, so it's\n\t\t\t\t * probably an IPv6 address, and needs to\n\t\t\t\t * be included in square brackets.\n\t\t\t\t */\n\t\t\t\tpcapint_strlcat(source, \"[\", PCAP_BUF_SIZE);\n\t\t\t\tpcapint_strlcat(source, host, PCAP_BUF_SIZE);\n\t\t\t\tpcapint_strlcat(source, \"]\", PCAP_BUF_SIZE);\n\t\t\t} else\n\t\t\t\tpcapint_strlcat(source, host, PCAP_BUF_SIZE);\n\n\t\t\tif (port != NULL && *port != '\\0') {\n\t\t\t\tpcapint_strlcat(source, \":\", PCAP_BUF_SIZE);\n\t\t\t\tpcapint_strlcat(source, port, PCAP_BUF_SIZE);\n\t\t\t}\n\n\t\t\tpcapint_strlcat(source, \"/\", PCAP_BUF_SIZE);\n\t\t} else {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The host name cannot be NULL.\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (name != NULL && *name != '\\0')\n\t\t\tpcapint_strlcat(source, name, PCAP_BUF_SIZE);\n\n\t\treturn (0);\n\n\tcase PCAP_SRC_IFLOCAL:\n\t\tpcapint_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);\n\n\t\tif (name != NULL && *name != '\\0')\n\t\t\tpcapint_strlcat(source, name, PCAP_BUF_SIZE);\n\n\t\treturn (0);\n\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"The interface type is not valid.\");\n\t\treturn (-1);\n\t}\n}\n\n\nint\npcap_createsrcstr(char *source, int type, const char *host, const char *port,\n    const char *name, char *errbuf)\n{\n\treturn (pcapint_createsrcstr_ex(source, type, NULL, host, port, name, 0, errbuf));\n}\n\nint\npcapint_parsesrcstr_ex(const char *source, int *type, char *userinfo, char *host,\n    char *port, char *name, unsigned char *uses_ssl, char *errbuf)\n{\n\tchar *scheme, *tmpuserinfo, *tmphost, *tmpport, *tmppath;\n\n\t/* Initialization stuff */\n\tif (userinfo)\n\t\t*userinfo = '\\0';\n\tif (host)\n\t\t*host = '\\0';\n\tif (port)\n\t\t*port = '\\0';\n\tif (name)\n\t\t*name = '\\0';\n\tif (uses_ssl)\n\t\t*uses_ssl = 0;\n\n\t/* Parse the source string */\n\tif (pcap_parse_source(source, &scheme, &tmpuserinfo, &tmphost,\n\t    &tmpport, &tmppath, errbuf) == -1) {\n\t\t/*\n\t\t * Fail.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\tif (scheme == NULL) {\n\t\t/*\n\t\t * Local device.\n\t\t */\n\t\tif (name && tmppath)\n\t\t\tpcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_IFLOCAL;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\treturn (0);\n\t}\n\n\tint is_rpcap = 0;\n\tif (strcmp(scheme, \"rpcaps\") == 0) {\n\t\tis_rpcap = 1;\n\t\tif (uses_ssl) *uses_ssl = 1;\n\t} else if (strcmp(scheme, \"rpcap\") == 0) {\n\t\tis_rpcap = 1;\n\t}\n\n\tif (is_rpcap) {\n\t\t/*\n\t\t * rpcap[s]://\n\t\t *\n\t\t * pcap_parse_source() has already handled the case of\n\t\t * rpcap[s]://device\n\t\t */\n\t\tif (userinfo && tmpuserinfo)\n\t\t\tpcapint_strlcpy(userinfo, tmpuserinfo, PCAP_BUF_SIZE);\n\t\tif (host && tmphost)\n\t\t\tpcapint_strlcpy(host, tmphost, PCAP_BUF_SIZE);\n\t\tif (port && tmpport)\n\t\t\tpcapint_strlcpy(port, tmpport, PCAP_BUF_SIZE);\n\t\tif (name && tmppath)\n\t\t\tpcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_IFREMOTE;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\tfree(scheme);\n\t\treturn (0);\n\t}\n\n\tif (strcmp(scheme, \"file\") == 0) {\n\t\t/*\n\t\t * file://\n\t\t */\n\t\tif (name && tmppath)\n\t\t\tpcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_FILE;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\tfree(scheme);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Neither rpcap: nor file:; just treat the entire string\n\t * as a local device.\n\t */\n\tif (name)\n\t\tpcapint_strlcpy(name, source, PCAP_BUF_SIZE);\n\tif (type)\n\t\t*type = PCAP_SRC_IFLOCAL;\n\tfree(tmppath);\n\tfree(tmpport);\n\tfree(tmphost);\n\tfree(tmpuserinfo);\n\tfree(scheme);\n\treturn (0);\n}\n\nint\npcap_parsesrcstr(const char *source, int *type, char *host, char *port,\n    char *name, char *errbuf)\n{\n\treturn (pcapint_parsesrcstr_ex(source, type, NULL, host, port, name, NULL, errbuf));\n}\n\npcap_t *\npcap_create(const char *device, char *errbuf)\n{\n\tsize_t i;\n\tint is_theirs;\n\tpcap_t *p;\n\tchar *device_str;\n\n\t/*\n\t * A null device name is equivalent to the \"any\" device -\n\t * which might not be supported on this platform, but\n\t * this means that you'll get a \"not supported\" error\n\t * rather than, say, a crash when we try to dereference\n\t * the null pointer.\n\t */\n\tif (device == NULL)\n\t\tdevice_str = strdup(\"any\");\n\telse {\n#ifdef _WIN32\n\t\t/*\n\t\t * On Windows, for backwards compatibility reasons,\n\t\t * pcap_lookupdev() returns a pointer to a sequence of\n\t\t * pairs of UTF-16LE device names and local code page\n\t\t * description strings.\n\t\t *\n\t\t * This means that if a program uses pcap_lookupdev()\n\t\t * to get a default device, and hands that to an API\n\t\t * that opens devices, we'll get handed a UTF-16LE\n\t\t * string, not a string in the local code page.\n\t\t *\n\t\t * To work around that, we check whether the string\n\t\t * looks as if it might be a UTF-16LE string and, if\n\t\t * so, convert it back to the local code page's\n\t\t * extended ASCII.\n\t\t *\n\t\t * We disable that check in \"new API\" mode, because:\n\t\t *\n\t\t *   1) You *cannot* reliably detect whether a\n\t\t *   string is UTF-16LE or not; \"a\" could either\n\t\t *   be a one-character ASCII string or the first\n\t\t *   character of a UTF-16LE string.\n\t\t *\n\t\t *   2) Doing that test can run past the end of\n\t\t *   the string, if it's a 1-character ASCII\n\t\t *   string\n\t\t *\n\t\t * This particular version of this heuristic dates\n\t\t * back to WinPcap 4.1.1; PacketOpenAdapter() does\n\t\t * uses the same heuristic, with the exact same\n\t\t * vulnerability.\n\t\t *\n\t\t * That's why we disable this in \"new API\" mode.\n\t\t * We keep it around in legacy mode for backwards\n\t\t * compatibility.\n\t\t */\n\t\tif (!pcapint_new_api && device[0] != '\\0' && device[1] == '\\0') {\n\t\t\tsize_t length;\n\n\t\t\tlength = wcslen((wchar_t *)device);\n\t\t\tdevice_str = (char *)malloc(length + 1);\n\t\t\tif (device_str == NULL) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\tsnprintf(device_str, length + 1, \"%ws\",\n\t\t\t    (const wchar_t *)device);\n\t\t} else\n#endif\n\t\t\tdevice_str = strdup(device);\n\t}\n\tif (device_str == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try each of the non-local-network-interface capture\n\t * source types until we find one that works for this\n\t * device or run out of types.\n\t */\n\tfor (i = 0; capture_source_types[i].create_op != NULL; i++) {\n\t\tis_theirs = 0;\n\t\tp = capture_source_types[i].create_op(device_str, errbuf,\n\t\t    &is_theirs);\n\t\tif (is_theirs) {\n\t\t\t/*\n\t\t\t * The device name refers to a device of the\n\t\t\t * type in question; either it succeeded,\n\t\t\t * in which case p refers to a pcap_t to\n\t\t\t * later activate for the device, or it\n\t\t\t * failed, in which case p is null and we\n\t\t\t * should return that to report the failure\n\t\t\t * to create.\n\t\t\t */\n\t\t\tif (p == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We assume the caller filled in errbuf.\n\t\t\t\t */\n\t\t\t\tfree(device_str);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp->opt.device = device_str;\n\t\t\treturn (p);\n\t\t}\n\t}\n\n\t/*\n\t * OK, try it as a regular network interface.\n\t */\n\tp = pcapint_create_interface(device_str, errbuf);\n\tif (p == NULL) {\n\t\t/*\n\t\t * We assume the caller filled in errbuf.\n\t\t */\n\t\tfree(device_str);\n\t\treturn (NULL);\n\t}\n\tp->opt.device = device_str;\n\treturn (p);\n}\n\n/*\n * Set nonblocking mode on an unactivated pcap_t; this sets a flag\n * checked by pcap_activate(), which sets the mode after calling\n * the activate routine.\n */\nstatic int\npcap_setnonblock_unactivated(pcap_t *p, int nonblock)\n{\n\tp->opt.nonblock = nonblock;\n\treturn (0);\n}\n\nstatic void\ninitialize_ops(pcap_t *p)\n{\n\t/*\n\t * Set operation pointers for operations that only work on\n\t * an activated pcap_t to point to a routine that returns\n\t * a \"this isn't activated\" error.\n\t */\n\tp->read_op = pcap_read_not_initialized;\n\tp->inject_op = pcap_inject_not_initialized;\n\tp->setfilter_op = pcap_setfilter_not_initialized;\n\tp->setdirection_op = pcap_setdirection_not_initialized;\n\tp->set_datalink_op = pcap_set_datalink_not_initialized;\n\tp->getnonblock_op = pcap_getnonblock_not_initialized;\n\tp->stats_op = pcap_stats_not_initialized;\n#ifdef _WIN32\n\tp->stats_ex_op = pcap_stats_ex_not_initialized;\n\tp->setbuff_op = pcap_setbuff_not_initialized;\n\tp->setmode_op = pcap_setmode_not_initialized;\n\tp->setmintocopy_op = pcap_setmintocopy_not_initialized;\n\tp->getevent_op = pcap_getevent_not_initialized;\n\tp->oid_get_request_op = pcap_oid_get_request_not_initialized;\n\tp->oid_set_request_op = pcap_oid_set_request_not_initialized;\n\tp->sendqueue_transmit_op = pcap_sendqueue_transmit_not_initialized;\n\tp->setuserbuffer_op = pcap_setuserbuffer_not_initialized;\n\tp->live_dump_op = pcap_live_dump_not_initialized;\n\tp->live_dump_ended_op = pcap_live_dump_ended_not_initialized;\n#endif\n\n\t/*\n\t * Default cleanup operation - implementations can override\n\t * this, but should call pcapint_cleanup_live_common() after\n\t * doing their own additional cleanup.\n\t */\n\tp->cleanup_op = pcapint_cleanup_live_common;\n\n\t/*\n\t * In most cases, the standard one-shot callback can\n\t * be used for pcap_next()/pcap_next_ex().\n\t */\n\tp->oneshot_callback = pcapint_oneshot;\n\n\t/*\n\t * Default breakloop operation - implementations can override\n\t * this, but should call pcapint_breakloop_common() before doing\n\t * their own logic.\n\t */\n\tp->breakloop_op = pcapint_breakloop_common;\n}\n\nstatic pcap_t *\npcap_alloc_pcap_t(char *ebuf, size_t total_size, size_t private_offset)\n{\n\tchar *chunk;\n\tpcap_t *p;\n\n\t/*\n\t * total_size is the size of a structure containing a pcap_t\n\t * followed by a private structure.\n\t */\n\tchunk = calloc(total_size, 1);\n\tif (chunk == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Get a pointer to the pcap_t at the beginning.\n\t */\n\tp = (pcap_t *)chunk;\n\n#ifdef _WIN32\n\tp->handle = INVALID_HANDLE_VALUE;\t/* not opened yet */\n#else /* _WIN32 */\n\tp->fd = -1;\t/* not opened yet */\n\tp->selectable_fd = -1;\n\tp->required_select_timeout = NULL;\n#endif /* _WIN32 */\n\n\t/*\n\t * private_offset is the offset, in bytes, of the private\n\t * data from the beginning of the structure.\n\t *\n\t * Set the pointer to the private data; that's private_offset\n\t * bytes past the pcap_t.\n\t */\n\tp->priv = (void *)(chunk + private_offset);\n\n\treturn (p);\n}\n\npcap_t *\npcapint_create_common(char *ebuf, size_t total_size, size_t private_offset)\n{\n\tpcap_t *p;\n\n\tp = pcap_alloc_pcap_t(ebuf, total_size, private_offset);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\t/*\n\t * Default to \"can't set rfmon mode\"; if it's supported by\n\t * a platform, the create routine that called us can set\n\t * the op to its routine to check whether a particular\n\t * device supports it.\n\t */\n\tp->can_set_rfmon_op = pcap_cant_set_rfmon;\n\n\t/*\n\t * If pcap_setnonblock() is called on a not-yet-activated\n\t * pcap_t, default to setting a flag and turning\n\t * on non-blocking mode when activated.\n\t */\n\tp->setnonblock_op = pcap_setnonblock_unactivated;\n\n\tinitialize_ops(p);\n\n\t/* put in some defaults*/\n\tp->snapshot = 0;\t\t/* max packet size unspecified */\n\tp->opt.timeout = 0;\t\t/* no timeout specified */\n\tp->opt.buffer_size = 0;\t\t/* use the platform's default */\n\tp->opt.promisc = 0;\n\tp->opt.rfmon = 0;\n\tp->opt.immediate = 0;\n\tp->opt.tstamp_type = -1;\t/* default to not setting time stamp type */\n\tp->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\t/*\n\t * Platform-dependent options.\n\t */\n#ifdef __linux__\n\tp->opt.protocol = 0;\n#endif\n#ifdef _WIN32\n\tp->opt.nocapture_local = 0;\n#endif\n\n\t/*\n\t * Start out with no BPF code generation flags set.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\treturn (p);\n}\n\nint\npcapint_check_activated(pcap_t *p)\n{\n\tif (p->activated) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"can't perform \"\n\t\t\t\" operation on activated capture\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nint\npcap_set_snaplen(pcap_t *p, int snaplen)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->snapshot = snaplen;\n\treturn (0);\n}\n\nint\npcap_set_promisc(pcap_t *p, int promisc)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.promisc = promisc;\n\treturn (0);\n}\n\nint\npcap_set_rfmon(pcap_t *p, int rfmon)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.rfmon = rfmon;\n\treturn (0);\n}\n\nint\npcap_set_timeout(pcap_t *p, int timeout_ms)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.timeout = timeout_ms;\n\treturn (0);\n}\n\nint\npcap_set_tstamp_type(pcap_t *p, int tstamp_type)\n{\n\tint i;\n\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\n\t/*\n\t * The argument should have been u_int, but that's too late\n\t * to change now - it's an API.\n\t */\n\tif (tstamp_type < 0)\n\t\treturn (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);\n\n\t/*\n\t * If p->tstamp_type_count is 0, we only support PCAP_TSTAMP_HOST;\n\t * the default time stamp type is PCAP_TSTAMP_HOST.\n\t */\n\tif (p->tstamp_type_count == 0) {\n\t\tif (tstamp_type == PCAP_TSTAMP_HOST) {\n\t\t\tp->opt.tstamp_type = tstamp_type;\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Check whether we claim to support this type of time stamp.\n\t\t */\n\t\tfor (i = 0; i < p->tstamp_type_count; i++) {\n\t\t\tif (p->tstamp_type_list[i] == (u_int)tstamp_type) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->opt.tstamp_type = tstamp_type;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We don't support this type of time stamp.\n\t */\n\treturn (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);\n}\n\nint\npcap_set_immediate_mode(pcap_t *p, int immediate)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.immediate = immediate;\n\treturn (0);\n}\n\nint\npcap_set_buffer_size(pcap_t *p, int buffer_size)\n{\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tif (buffer_size <= 0) {\n\t\t/*\n\t\t * Silently ignore invalid values.\n\t\t */\n\t\treturn (0);\n\t}\n\tp->opt.buffer_size = buffer_size;\n\treturn (0);\n}\n\nint\npcap_set_tstamp_precision(pcap_t *p, int tstamp_precision)\n{\n\tint i;\n\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\n\t/*\n\t * The argument should have been u_int, but that's too late\n\t * to change now - it's an API.\n\t */\n\tif (tstamp_precision < 0)\n\t\treturn (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);\n\n\t/*\n\t * If p->tstamp_precision_count is 0, we only support setting\n\t * the time stamp precision to microsecond precision; every\n\t * pcap module *MUST* support microsecond precision, even if\n\t * it does so by converting the native precision to\n\t * microseconds.\n\t */\n\tif (p->tstamp_precision_count == 0) {\n\t\tif (tstamp_precision == PCAP_TSTAMP_PRECISION_MICRO) {\n\t\t\tp->opt.tstamp_precision = tstamp_precision;\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Check whether we claim to support this precision of\n\t\t * time stamp.\n\t\t */\n\t\tfor (i = 0; i < p->tstamp_precision_count; i++) {\n\t\t\tif (p->tstamp_precision_list[i] == (u_int)tstamp_precision) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->opt.tstamp_precision = tstamp_precision;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We don't support this time stamp precision.\n\t */\n\treturn (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);\n}\n\nint\npcap_get_tstamp_precision(pcap_t *p)\n{\n        return (p->opt.tstamp_precision);\n}\n\nint\npcap_activate(pcap_t *p)\n{\n\tint status;\n\n\t/*\n\t * Catch attempts to re-activate an already-activated\n\t * pcap_t; this should, for example, catch code that\n\t * calls pcap_open_live() followed by pcap_activate(),\n\t * as some code that showed up in a Stack Exchange\n\t * question did.\n\t */\n\tif (pcapint_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tstatus = p->activate_op(p);\n\tif (status >= 0) {\n\t\t/*\n\t\t * If somebody requested non-blocking mode before\n\t\t * calling pcap_activate(), turn it on now.\n\t\t */\n\t\tif (p->opt.nonblock) {\n\t\t\tstatus = p->setnonblock_op(p, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/*\n\t\t\t\t * Failed.  Undo everything done by\n\t\t\t\t * the activate operation.\n\t\t\t\t */\n\t\t\t\tp->cleanup_op(p);\n\t\t\t\tinitialize_ops(p);\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\t\tp->activated = 1;\n\t} else {\n\t\tif (p->errbuf[0] == '\\0') {\n\t\t\t/*\n\t\t\t * No error message supplied by the activate routine;\n\t\t\t * for the benefit of programs that don't specially\n\t\t\t * handle errors other than PCAP_ERROR, return the\n\t\t\t * error message corresponding to the status.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"%s\",\n\t\t\t    pcap_statustostr(status));\n\t\t}\n\n\t\t/*\n\t\t * Undo any operation pointer setting, etc. done by\n\t\t * the activate operation.\n\t\t */\n\t\tinitialize_ops(p);\n\t}\n\treturn (status);\n}\n\npcap_t *\npcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)\n{\n\tpcap_t *p;\n\tint status;\n#ifdef ENABLE_REMOTE\n\tchar host[PCAP_BUF_SIZE + 1];\n\tchar port[PCAP_BUF_SIZE + 1];\n\tchar name[PCAP_BUF_SIZE + 1];\n\tint srctype;\n\n\t/*\n\t * A null device name is equivalent to the \"any\" device -\n\t * which might not be supported on this platform, but\n\t * this means that you'll get a \"not supported\" error\n\t * rather than, say, a crash when we try to dereference\n\t * the null pointer.\n\t */\n\tif (device == NULL)\n\t\tdevice = \"any\";\n\n\t/*\n\t * Retrofit - we have to make older applications compatible with\n\t * remote capture.\n\t * So we're calling pcap_open_remote() from here; this is a very\n\t * dirty hack.\n\t * Obviously, we cannot exploit all the new features; for instance,\n\t * we cannot send authentication, we cannot use a UDP data connection,\n\t * and so on.\n\t */\n\tif (pcap_parsesrcstr(device, &srctype, host, port, name, errbuf))\n\t\treturn (NULL);\n\n\tif (srctype == PCAP_SRC_IFREMOTE) {\n\t\t/*\n\t\t * Although we already have host, port and iface, we prefer\n\t\t * to pass only 'device' to pcap_open_rpcap(), so that it has\n\t\t * to call pcap_parsesrcstr() again.\n\t\t * This is less optimized, but much clearer.\n\t\t */\n\t\treturn (pcap_open_rpcap(device, snaplen,\n\t\t    promisc ? PCAP_OPENFLAG_PROMISCUOUS : 0, to_ms,\n\t\t    NULL, errbuf));\n\t}\n\tif (srctype == PCAP_SRC_FILE) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"unknown URL scheme \\\"file\\\"\");\n\t\treturn (NULL);\n\t}\n\tif (srctype == PCAP_SRC_IFLOCAL) {\n\t\t/*\n\t\t * If it starts with rpcap://, that refers to a local device\n\t\t * (no host part in the URL). Remove the rpcap://, and\n\t\t * fall through to the regular open path.\n\t\t */\n\t\tif (strncmp(device, PCAP_SRC_IF_STRING, strlen(PCAP_SRC_IF_STRING)) == 0) {\n\t\t\tsize_t len = strlen(device) - strlen(PCAP_SRC_IF_STRING) + 1;\n\n\t\t\tif (len > 0)\n\t\t\t\tdevice += strlen(PCAP_SRC_IF_STRING);\n\t\t}\n\t}\n#endif\t/* ENABLE_REMOTE */\n\n\tp = pcap_create(device, errbuf);\n\tif (p == NULL)\n\t\treturn (NULL);\n\tstatus = pcap_set_snaplen(p, snaplen);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_set_promisc(p, promisc);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_set_timeout(p, to_ms);\n\tif (status < 0)\n\t\tgoto fail;\n\t/*\n\t * Mark this as opened with pcap_open_live(), so that, for\n\t * example, we show the full list of DLT_ values, rather\n\t * than just the ones that are compatible with capturing\n\t * when not in monitor mode.  That allows existing applications\n\t * to work the way they used to work, but allows new applications\n\t * that know about the new open API to, for example, find out the\n\t * DLT_ values that they can select without changing whether\n\t * the adapter is in monitor mode or not.\n\t */\n\tp->oldstyle = 1;\n\tstatus = pcap_activate(p);\n\tif (status < 0)\n\t\tgoto fail;\n\treturn (p);\nfail:\n\tif (status == PCAP_ERROR) {\n\t\t/*\n\t\t * Another buffer is a bit cumbersome, but it avoids\n\t\t * -Wformat-truncation.\n\t\t */\n\t\tchar trimbuf[PCAP_ERRBUF_SIZE - 5]; /* 2 bytes shorter */\n\n\t\tpcapint_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %.*s\", device,\n\t\t    PCAP_ERRBUF_SIZE - 3, trimbuf);\n\t} else if (status == PCAP_ERROR_NO_SUCH_DEVICE ||\n\t    status == PCAP_ERROR_PERM_DENIED ||\n\t    status == PCAP_ERROR_PROMISC_PERM_DENIED) {\n\t\t/*\n\t\t * Only show the additional message if it's not\n\t\t * empty.\n\t\t */\n\t\tif (p->errbuf[0] != '\\0') {\n\t\t\t/*\n\t\t\t * Idem.\n\t\t\t */\n\t\t\tchar trimbuf[PCAP_ERRBUF_SIZE - 8]; /* 2 bytes shorter */\n\n\t\t\tpcapint_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s (%.*s)\",\n\t\t\t    device, pcap_statustostr(status),\n\t\t\t    PCAP_ERRBUF_SIZE - 6, trimbuf);\n\t\t} else {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\t}\n\t} else {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\", device,\n\t\t    pcap_statustostr(status));\n\t}\n\tpcap_close(p);\n\treturn (NULL);\n}\n\npcap_t *\npcapint_open_offline_common(char *ebuf, size_t total_size, size_t private_offset)\n{\n\tpcap_t *p;\n\n\tp = pcap_alloc_pcap_t(ebuf, total_size, private_offset);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn (p);\n}\n\nint\npcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\treturn (p->read_op(p, cnt, callback, user));\n}\n\nint\npcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tregister int n;\n\n\tfor (;;) {\n\t\tif (p->rfile != NULL) {\n\t\t\t/*\n\t\t\t * 0 means EOF, so don't loop if we get 0.\n\t\t\t */\n\t\t\tn = pcapint_offline_read(p, cnt, callback, user);\n\t\t} else {\n\t\t\t/*\n\t\t\t * XXX keep reading until we get something\n\t\t\t * (or an error occurs)\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tn = p->read_op(p, cnt, callback, user);\n\t\t\t} while (n == 0);\n\t\t}\n\t\tif (n <= 0)\n\t\t\treturn (n);\n\t\tif (!PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\tcnt -= n;\n\t\t\tif (cnt <= 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n}\n\n/*\n * Force the loop in \"pcap_read()\" or \"pcap_read_offline()\" to terminate.\n */\nvoid\npcap_breakloop(pcap_t *p)\n{\n\tp->breakloop_op(p);\n}\n\nint\npcap_datalink(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->linktype);\n}\n\nint\npcap_datalink_ext(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->linktype_ext);\n}\n\nint\npcap_list_datalinks(pcap_t *p, int **dlt_buffer)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\tif (p->dlt_count == 0) {\n\t\t/*\n\t\t * We couldn't fetch the list of DLTs, which means\n\t\t * this platform doesn't support changing the\n\t\t * DLT for an interface.  Return a list of DLTs\n\t\t * containing only the DLT this device supports.\n\t\t */\n\t\t*dlt_buffer = (int*)malloc(sizeof(**dlt_buffer));\n\t\tif (*dlt_buffer == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t**dlt_buffer = p->linktype;\n\t\treturn (1);\n\t} else {\n\t\t*dlt_buffer = (int*)calloc(p->dlt_count, sizeof(**dlt_buffer));\n\t\tif (*dlt_buffer == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t(void)memcpy(*dlt_buffer, p->dlt_list,\n\t\t    sizeof(**dlt_buffer) * p->dlt_count);\n\t\treturn (p->dlt_count);\n\t}\n}\n\n/*\n * In Windows, you might have a library built with one version of the\n * C runtime library and an application built with another version of\n * the C runtime library, which means that the library might use one\n * version of malloc() and free() and the application might use another\n * version of malloc() and free().  If so, that means something\n * allocated by the library cannot be freed by the application, so we\n * need to have a pcap_free_datalinks() routine to free up the list\n * allocated by pcap_list_datalinks(), even though it's just a wrapper\n * around free().\n */\nvoid\npcap_free_datalinks(int *dlt_list)\n{\n\tfree(dlt_list);\n}\n\nint\npcap_set_datalink(pcap_t *p, int dlt)\n{\n\tint i;\n\tconst char *dlt_name;\n\n\tif (dlt < 0)\n\t\tgoto unsupported;\n\n\tif (p->dlt_count == 0 || p->set_datalink_op == NULL) {\n\t\t/*\n\t\t * We couldn't fetch the list of DLTs, or we don't\n\t\t * have a \"set datalink\" operation, which means\n\t\t * this platform doesn't support changing the\n\t\t * DLT for an interface.  Check whether the new\n\t\t * DLT is the one this interface supports.\n\t\t */\n\t\tif (p->linktype != dlt)\n\t\t\tgoto unsupported;\n\n\t\t/*\n\t\t * It is, so there's nothing we need to do here.\n\t\t */\n\t\treturn (0);\n\t}\n\tfor (i = 0; i < p->dlt_count; i++)\n\t\tif (p->dlt_list[i] == (u_int)dlt)\n\t\t\tbreak;\n\tif (i >= p->dlt_count)\n\t\tgoto unsupported;\n\tif (p->dlt_count == 2 && p->dlt_list[0] == DLT_EN10MB &&\n\t    dlt == DLT_DOCSIS) {\n\t\t/*\n\t\t * This is presumably an Ethernet device, as the first\n\t\t * link-layer type it offers is DLT_EN10MB, and the only\n\t\t * other type it offers is DLT_DOCSIS.  That means that\n\t\t * we can't tell the driver to supply DOCSIS link-layer\n\t\t * headers - we're just pretending that's what we're\n\t\t * getting, as, presumably, we're capturing on a dedicated\n\t\t * link to a Cisco Cable Modem Termination System, and\n\t\t * it's putting raw DOCSIS frames on the wire inside low-level\n\t\t * Ethernet framing.\n\t\t */\n\t\tp->linktype = dlt;\n\t\treturn (0);\n\t}\n\tif (p->set_datalink_op(p, dlt) == -1)\n\t\treturn (-1);\n\tp->linktype = dlt;\n\treturn (0);\n\nunsupported:\n\tdlt_name = pcap_datalink_val_to_name(dlt);\n\tif (dlt_name != NULL) {\n\t\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"%s is not one of the DLTs supported by this device\",\n\t\t    dlt_name);\n\t} else {\n\t\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"DLT %d is not one of the DLTs supported by this device\",\n\t\t    dlt);\n\t}\n\treturn (-1);\n}\n\n/*\n * This array is designed for mapping upper and lower case letter\n * together for a case independent comparison.  The mappings are\n * based upon ascii character sequences.\n */\nstatic const u_char charmap[] = {\n\t(u_char)'\\000', (u_char)'\\001', (u_char)'\\002', (u_char)'\\003',\n\t(u_char)'\\004', (u_char)'\\005', (u_char)'\\006', (u_char)'\\007',\n\t(u_char)'\\010', (u_char)'\\011', (u_char)'\\012', (u_char)'\\013',\n\t(u_char)'\\014', (u_char)'\\015', (u_char)'\\016', (u_char)'\\017',\n\t(u_char)'\\020', (u_char)'\\021', (u_char)'\\022', (u_char)'\\023',\n\t(u_char)'\\024', (u_char)'\\025', (u_char)'\\026', (u_char)'\\027',\n\t(u_char)'\\030', (u_char)'\\031', (u_char)'\\032', (u_char)'\\033',\n\t(u_char)'\\034', (u_char)'\\035', (u_char)'\\036', (u_char)'\\037',\n\t(u_char)'\\040', (u_char)'\\041', (u_char)'\\042', (u_char)'\\043',\n\t(u_char)'\\044', (u_char)'\\045', (u_char)'\\046', (u_char)'\\047',\n\t(u_char)'\\050', (u_char)'\\051', (u_char)'\\052', (u_char)'\\053',\n\t(u_char)'\\054', (u_char)'\\055', (u_char)'\\056', (u_char)'\\057',\n\t(u_char)'\\060', (u_char)'\\061', (u_char)'\\062', (u_char)'\\063',\n\t(u_char)'\\064', (u_char)'\\065', (u_char)'\\066', (u_char)'\\067',\n\t(u_char)'\\070', (u_char)'\\071', (u_char)'\\072', (u_char)'\\073',\n\t(u_char)'\\074', (u_char)'\\075', (u_char)'\\076', (u_char)'\\077',\n\t(u_char)'\\100', (u_char)'\\141', (u_char)'\\142', (u_char)'\\143',\n\t(u_char)'\\144', (u_char)'\\145', (u_char)'\\146', (u_char)'\\147',\n\t(u_char)'\\150', (u_char)'\\151', (u_char)'\\152', (u_char)'\\153',\n\t(u_char)'\\154', (u_char)'\\155', (u_char)'\\156', (u_char)'\\157',\n\t(u_char)'\\160', (u_char)'\\161', (u_char)'\\162', (u_char)'\\163',\n\t(u_char)'\\164', (u_char)'\\165', (u_char)'\\166', (u_char)'\\167',\n\t(u_char)'\\170', (u_char)'\\171', (u_char)'\\172', (u_char)'\\133',\n\t(u_char)'\\134', (u_char)'\\135', (u_char)'\\136', (u_char)'\\137',\n\t(u_char)'\\140', (u_char)'\\141', (u_char)'\\142', (u_char)'\\143',\n\t(u_char)'\\144', (u_char)'\\145', (u_char)'\\146', (u_char)'\\147',\n\t(u_char)'\\150', (u_char)'\\151', (u_char)'\\152', (u_char)'\\153',\n\t(u_char)'\\154', (u_char)'\\155', (u_char)'\\156', (u_char)'\\157',\n\t(u_char)'\\160', (u_char)'\\161', (u_char)'\\162', (u_char)'\\163',\n\t(u_char)'\\164', (u_char)'\\165', (u_char)'\\166', (u_char)'\\167',\n\t(u_char)'\\170', (u_char)'\\171', (u_char)'\\172', (u_char)'\\173',\n\t(u_char)'\\174', (u_char)'\\175', (u_char)'\\176', (u_char)'\\177',\n\t(u_char)'\\200', (u_char)'\\201', (u_char)'\\202', (u_char)'\\203',\n\t(u_char)'\\204', (u_char)'\\205', (u_char)'\\206', (u_char)'\\207',\n\t(u_char)'\\210', (u_char)'\\211', (u_char)'\\212', (u_char)'\\213',\n\t(u_char)'\\214', (u_char)'\\215', (u_char)'\\216', (u_char)'\\217',\n\t(u_char)'\\220', (u_char)'\\221', (u_char)'\\222', (u_char)'\\223',\n\t(u_char)'\\224', (u_char)'\\225', (u_char)'\\226', (u_char)'\\227',\n\t(u_char)'\\230', (u_char)'\\231', (u_char)'\\232', (u_char)'\\233',\n\t(u_char)'\\234', (u_char)'\\235', (u_char)'\\236', (u_char)'\\237',\n\t(u_char)'\\240', (u_char)'\\241', (u_char)'\\242', (u_char)'\\243',\n\t(u_char)'\\244', (u_char)'\\245', (u_char)'\\246', (u_char)'\\247',\n\t(u_char)'\\250', (u_char)'\\251', (u_char)'\\252', (u_char)'\\253',\n\t(u_char)'\\254', (u_char)'\\255', (u_char)'\\256', (u_char)'\\257',\n\t(u_char)'\\260', (u_char)'\\261', (u_char)'\\262', (u_char)'\\263',\n\t(u_char)'\\264', (u_char)'\\265', (u_char)'\\266', (u_char)'\\267',\n\t(u_char)'\\270', (u_char)'\\271', (u_char)'\\272', (u_char)'\\273',\n\t(u_char)'\\274', (u_char)'\\275', (u_char)'\\276', (u_char)'\\277',\n\t(u_char)'\\300', (u_char)'\\341', (u_char)'\\342', (u_char)'\\343',\n\t(u_char)'\\344', (u_char)'\\345', (u_char)'\\346', (u_char)'\\347',\n\t(u_char)'\\350', (u_char)'\\351', (u_char)'\\352', (u_char)'\\353',\n\t(u_char)'\\354', (u_char)'\\355', (u_char)'\\356', (u_char)'\\357',\n\t(u_char)'\\360', (u_char)'\\361', (u_char)'\\362', (u_char)'\\363',\n\t(u_char)'\\364', (u_char)'\\365', (u_char)'\\366', (u_char)'\\367',\n\t(u_char)'\\370', (u_char)'\\371', (u_char)'\\372', (u_char)'\\333',\n\t(u_char)'\\334', (u_char)'\\335', (u_char)'\\336', (u_char)'\\337',\n\t(u_char)'\\340', (u_char)'\\341', (u_char)'\\342', (u_char)'\\343',\n\t(u_char)'\\344', (u_char)'\\345', (u_char)'\\346', (u_char)'\\347',\n\t(u_char)'\\350', (u_char)'\\351', (u_char)'\\352', (u_char)'\\353',\n\t(u_char)'\\354', (u_char)'\\355', (u_char)'\\356', (u_char)'\\357',\n\t(u_char)'\\360', (u_char)'\\361', (u_char)'\\362', (u_char)'\\363',\n\t(u_char)'\\364', (u_char)'\\365', (u_char)'\\366', (u_char)'\\367',\n\t(u_char)'\\370', (u_char)'\\371', (u_char)'\\372', (u_char)'\\373',\n\t(u_char)'\\374', (u_char)'\\375', (u_char)'\\376', (u_char)'\\377',\n};\n\nint\npcapint_strcasecmp(const char *s1, const char *s2)\n{\n\tregister const u_char\t*cm = charmap,\n\t\t\t\t*us1 = (const u_char *)s1,\n\t\t\t\t*us2 = (const u_char *)s2;\n\n\twhile (cm[*us1] == cm[*us2++])\n\t\tif (*us1++ == '\\0')\n\t\t\treturn(0);\n\treturn (cm[*us1] - cm[*--us2]);\n}\n\nstruct dlt_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\tdlt;\n};\n\n#define DLT_CHOICE(code, description) { #code, description, DLT_ ## code }\n#define DLT_CHOICE_SENTINEL { NULL, NULL, 0 }\n\nstatic struct dlt_choice dlt_choices[] = {\n\tDLT_CHOICE(NULL, \"BSD loopback\"),\n\tDLT_CHOICE(EN10MB, \"Ethernet\"),\n\tDLT_CHOICE(IEEE802, \"Token ring\"),\n\tDLT_CHOICE(ARCNET, \"BSD ARCNET\"),\n\tDLT_CHOICE(SLIP, \"SLIP\"),\n\tDLT_CHOICE(PPP, \"PPP\"),\n\tDLT_CHOICE(FDDI, \"FDDI\"),\n\tDLT_CHOICE(ATM_RFC1483, \"RFC 1483 LLC-encapsulated ATM\"),\n\tDLT_CHOICE(RAW, \"Raw IP\"),\n\tDLT_CHOICE(SLIP_BSDOS, \"BSD/OS SLIP\"),\n\tDLT_CHOICE(PPP_BSDOS, \"BSD/OS PPP\"),\n\tDLT_CHOICE(ATM_CLIP, \"Linux Classical IP over ATM\"),\n\tDLT_CHOICE(PPP_SERIAL, \"PPP over serial\"),\n\tDLT_CHOICE(PPP_ETHER, \"PPPoE\"),\n\tDLT_CHOICE(SYMANTEC_FIREWALL, \"Symantec Firewall\"),\n\tDLT_CHOICE(C_HDLC, \"Cisco HDLC\"),\n\tDLT_CHOICE(IEEE802_11, \"802.11\"),\n\tDLT_CHOICE(FRELAY, \"Frame Relay\"),\n\tDLT_CHOICE(LOOP, \"OpenBSD loopback\"),\n\tDLT_CHOICE(ENC, \"OpenBSD encapsulated IP\"),\n\tDLT_CHOICE(LINUX_SLL, \"Linux cooked v1\"),\n\tDLT_CHOICE(LTALK, \"Localtalk\"),\n\tDLT_CHOICE(PFLOG, \"OpenBSD pflog file\"),\n\tDLT_CHOICE(PFSYNC, \"Packet filter state syncing\"),\n\tDLT_CHOICE(PRISM_HEADER, \"802.11 plus Prism header\"),\n\tDLT_CHOICE(IP_OVER_FC, \"RFC 2625 IP-over-Fibre Channel\"),\n\tDLT_CHOICE(SUNATM, \"Sun raw ATM\"),\n\tDLT_CHOICE(IEEE802_11_RADIO, \"802.11 plus radiotap header\"),\n\tDLT_CHOICE(ARCNET_LINUX, \"Linux ARCNET\"),\n\tDLT_CHOICE(JUNIPER_MLPPP, \"Juniper Multi-Link PPP\"),\n\tDLT_CHOICE(JUNIPER_MLFR, \"Juniper Multi-Link Frame Relay\"),\n\tDLT_CHOICE(JUNIPER_ES, \"Juniper Encryption Services PIC\"),\n\tDLT_CHOICE(JUNIPER_GGSN, \"Juniper GGSN PIC\"),\n\tDLT_CHOICE(JUNIPER_MFR, \"Juniper FRF.16 Frame Relay\"),\n\tDLT_CHOICE(JUNIPER_ATM2, \"Juniper ATM2 PIC\"),\n\tDLT_CHOICE(JUNIPER_SERVICES, \"Juniper Advanced Services PIC\"),\n\tDLT_CHOICE(JUNIPER_ATM1, \"Juniper ATM1 PIC\"),\n\tDLT_CHOICE(APPLE_IP_OVER_IEEE1394, \"Apple IP-over-IEEE 1394\"),\n\tDLT_CHOICE(MTP2_WITH_PHDR, \"SS7 MTP2 with Pseudo-header\"),\n\tDLT_CHOICE(MTP2, \"SS7 MTP2\"),\n\tDLT_CHOICE(MTP3, \"SS7 MTP3\"),\n\tDLT_CHOICE(SCCP, \"SS7 SCCP\"),\n\tDLT_CHOICE(DOCSIS, \"DOCSIS\"),\n\tDLT_CHOICE(LINUX_IRDA, \"Linux IrDA\"),\n\tDLT_CHOICE(IEEE802_11_RADIO_AVS, \"802.11 plus AVS radio information header\"),\n\tDLT_CHOICE(JUNIPER_MONITOR, \"Juniper Passive Monitor PIC\"),\n\tDLT_CHOICE(BACNET_MS_TP, \"BACnet MS/TP\"),\n\tDLT_CHOICE(PPP_PPPD, \"PPP for pppd, with direction flag\"),\n\tDLT_CHOICE(JUNIPER_PPPOE, \"Juniper PPPoE\"),\n\tDLT_CHOICE(JUNIPER_PPPOE_ATM, \"Juniper PPPoE/ATM\"),\n\tDLT_CHOICE(GPRS_LLC, \"GPRS LLC\"),\n\tDLT_CHOICE(GPF_T, \"GPF-T\"),\n\tDLT_CHOICE(GPF_F, \"GPF-F\"),\n\tDLT_CHOICE(JUNIPER_PIC_PEER, \"Juniper PIC Peer\"),\n\tDLT_CHOICE(ERF_ETH, \"Ethernet with Endace ERF header\"),\n\tDLT_CHOICE(ERF_POS, \"Packet-over-SONET with Endace ERF header\"),\n\tDLT_CHOICE(LINUX_LAPD, \"Linux vISDN LAPD\"),\n\tDLT_CHOICE(JUNIPER_ETHER, \"Juniper Ethernet\"),\n\tDLT_CHOICE(JUNIPER_PPP, \"Juniper PPP\"),\n\tDLT_CHOICE(JUNIPER_FRELAY, \"Juniper Frame Relay\"),\n\tDLT_CHOICE(JUNIPER_CHDLC, \"Juniper C-HDLC\"),\n\tDLT_CHOICE(MFR, \"FRF.16 Frame Relay\"),\n\tDLT_CHOICE(JUNIPER_VP, \"Juniper Voice PIC\"),\n\tDLT_CHOICE(A429, \"Arinc 429\"),\n\tDLT_CHOICE(A653_ICM, \"Arinc 653 Interpartition Communication\"),\n\tDLT_CHOICE(USB_FREEBSD, \"USB with FreeBSD header\"),\n\tDLT_CHOICE(BLUETOOTH_HCI_H4, \"Bluetooth HCI UART transport layer\"),\n\tDLT_CHOICE(IEEE802_16_MAC_CPS, \"IEEE 802.16 MAC Common Part Sublayer\"),\n\tDLT_CHOICE(USB_LINUX, \"USB with Linux header\"),\n\tDLT_CHOICE(CAN20B, \"Controller Area Network (CAN) v. 2.0B\"),\n\tDLT_CHOICE(IEEE802_15_4_LINUX, \"IEEE 802.15.4 with Linux padding\"),\n\tDLT_CHOICE(PPI, \"Per-Packet Information\"),\n\tDLT_CHOICE(IEEE802_16_MAC_CPS_RADIO, \"IEEE 802.16 MAC Common Part Sublayer plus radiotap header\"),\n\tDLT_CHOICE(JUNIPER_ISM, \"Juniper Integrated Service Module\"),\n\tDLT_CHOICE(IEEE802_15_4, \"IEEE 802.15.4 with FCS\"),\n\tDLT_CHOICE(SITA, \"SITA pseudo-header\"),\n\tDLT_CHOICE(ERF, \"Endace ERF header\"),\n\tDLT_CHOICE(RAIF1, \"Ethernet with u10 Networks pseudo-header\"),\n\tDLT_CHOICE(IPMB_KONTRON, \"IPMB with Kontron pseudo-header\"),\n\tDLT_CHOICE(JUNIPER_ST, \"Juniper Secure Tunnel\"),\n\tDLT_CHOICE(BLUETOOTH_HCI_H4_WITH_PHDR, \"Bluetooth HCI UART transport layer plus pseudo-header\"),\n\tDLT_CHOICE(AX25_KISS, \"AX.25 with KISS header\"),\n\tDLT_CHOICE(I2C_LINUX, \"I2C with Linux/Pigeon Point pseudo-header\"),\n\tDLT_CHOICE(IEEE802_15_4_NONASK_PHY, \"IEEE 802.15.4 with non-ASK PHY data\"),\n\tDLT_CHOICE(MPLS, \"MPLS with label as link-layer header\"),\n\tDLT_CHOICE(LINUX_EVDEV, \"Linux evdev events\"),\n\tDLT_CHOICE(USB_LINUX_MMAPPED, \"USB with padded Linux header\"),\n\tDLT_CHOICE(DECT, \"DECT\"),\n\tDLT_CHOICE(AOS, \"AOS Space Data Link protocol\"),\n\tDLT_CHOICE(WIHART, \"WirelessHART\"),\n\tDLT_CHOICE(FC_2, \"Fibre Channel FC-2\"),\n\tDLT_CHOICE(FC_2_WITH_FRAME_DELIMS, \"Fibre Channel FC-2 with frame delimiters\"),\n\tDLT_CHOICE(IPNET, \"Solaris ipnet\"),\n\tDLT_CHOICE(CAN_SOCKETCAN, \"CAN-bus with SocketCAN headers\"),\n\tDLT_CHOICE(IPV4, \"Raw IPv4\"),\n\tDLT_CHOICE(IPV6, \"Raw IPv6\"),\n\tDLT_CHOICE(IEEE802_15_4_NOFCS, \"IEEE 802.15.4 without FCS\"),\n\tDLT_CHOICE(DBUS, \"D-Bus\"),\n\tDLT_CHOICE(JUNIPER_VS, \"Juniper Virtual Server\"),\n\tDLT_CHOICE(JUNIPER_SRX_E2E, \"Juniper SRX E2E\"),\n\tDLT_CHOICE(JUNIPER_FIBRECHANNEL, \"Juniper Fibre Channel\"),\n\tDLT_CHOICE(DVB_CI, \"DVB-CI\"),\n\tDLT_CHOICE(MUX27010, \"MUX27010\"),\n\tDLT_CHOICE(STANAG_5066_D_PDU, \"STANAG 5066 D_PDUs\"),\n\tDLT_CHOICE(JUNIPER_ATM_CEMIC, \"Juniper ATM CEMIC\"),\n\tDLT_CHOICE(NFLOG, \"Linux netfilter log messages\"),\n\tDLT_CHOICE(NETANALYZER, \"Ethernet with Hilscher netANALYZER pseudo-header\"),\n\tDLT_CHOICE(NETANALYZER_TRANSPARENT, \"Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD\"),\n\tDLT_CHOICE(IPOIB, \"RFC 4391 IP-over-Infiniband\"),\n\tDLT_CHOICE(MPEG_2_TS, \"MPEG-2 transport stream\"),\n\tDLT_CHOICE(NG40, \"ng40 protocol tester Iub/Iur\"),\n\tDLT_CHOICE(NFC_LLCP, \"NFC LLCP PDUs with pseudo-header\"),\n\tDLT_CHOICE(INFINIBAND, \"InfiniBand\"),\n\tDLT_CHOICE(SCTP, \"SCTP\"),\n\tDLT_CHOICE(USBPCAP, \"USB with USBPcap header\"),\n\tDLT_CHOICE(RTAC_SERIAL, \"Schweitzer Engineering Laboratories RTAC packets\"),\n\tDLT_CHOICE(BLUETOOTH_LE_LL, \"Bluetooth Low Energy air interface\"),\n\tDLT_CHOICE(NETLINK, \"Linux netlink\"),\n\tDLT_CHOICE(BLUETOOTH_LINUX_MONITOR, \"Bluetooth Linux Monitor\"),\n\tDLT_CHOICE(BLUETOOTH_BREDR_BB, \"Bluetooth Basic Rate/Enhanced Data Rate baseband packets\"),\n\tDLT_CHOICE(BLUETOOTH_LE_LL_WITH_PHDR, \"Bluetooth Low Energy air interface with pseudo-header\"),\n\tDLT_CHOICE(PROFIBUS_DL, \"PROFIBUS data link layer\"),\n\tDLT_CHOICE(PKTAP, \"Apple DLT_PKTAP\"),\n\tDLT_CHOICE(EPON, \"Ethernet with 802.3 Clause 65 EPON preamble\"),\n\tDLT_CHOICE(IPMI_HPM_2, \"IPMI trace packets\"),\n\tDLT_CHOICE(ZWAVE_R1_R2, \"Z-Wave RF profile R1 and R2 packets\"),\n\tDLT_CHOICE(ZWAVE_R3, \"Z-Wave RF profile R3 packets\"),\n\tDLT_CHOICE(WATTSTOPPER_DLM, \"WattStopper Digital Lighting Management (DLM) and Legrand Nitoo Open protocol\"),\n\tDLT_CHOICE(ISO_14443, \"ISO 14443 messages\"),\n\tDLT_CHOICE(RDS, \"IEC 62106 Radio Data System groups\"),\n\tDLT_CHOICE(USB_DARWIN, \"USB with Darwin header\"),\n\tDLT_CHOICE(OPENFLOW, \"OpenBSD DLT_OPENFLOW\"),\n\tDLT_CHOICE(SDLC, \"IBM SDLC frames\"),\n\tDLT_CHOICE(TI_LLN_SNIFFER, \"TI LLN sniffer frames\"),\n\tDLT_CHOICE(VSOCK, \"Linux vsock\"),\n\tDLT_CHOICE(NORDIC_BLE, \"Nordic Semiconductor Bluetooth LE sniffer frames\"),\n\tDLT_CHOICE(DOCSIS31_XRA31, \"Excentis XRA-31 DOCSIS 3.1 RF sniffer frames\"),\n\tDLT_CHOICE(ETHERNET_MPACKET, \"802.3br mPackets\"),\n\tDLT_CHOICE(DISPLAYPORT_AUX, \"DisplayPort AUX channel monitoring data\"),\n\tDLT_CHOICE(LINUX_SLL2, \"Linux cooked v2\"),\n\tDLT_CHOICE(OPENVIZSLA, \"OpenVizsla USB\"),\n\tDLT_CHOICE(EBHSCR, \"Elektrobit High Speed Capture and Replay (EBHSCR)\"),\n\tDLT_CHOICE(VPP_DISPATCH, \"VPP graph dispatch tracer\"),\n\tDLT_CHOICE(DSA_TAG_BRCM, \"Broadcom tag\"),\n\tDLT_CHOICE(DSA_TAG_BRCM_PREPEND, \"Broadcom tag (prepended)\"),\n\tDLT_CHOICE(IEEE802_15_4_TAP, \"IEEE 802.15.4 with pseudo-header\"),\n\tDLT_CHOICE(DSA_TAG_DSA, \"Marvell DSA\"),\n\tDLT_CHOICE(DSA_TAG_EDSA, \"Marvell EDSA\"),\n\tDLT_CHOICE(ELEE, \"ELEE lawful intercept packets\"),\n\tDLT_CHOICE(Z_WAVE_SERIAL, \"Z-Wave serial frames between host and chip\"),\n\tDLT_CHOICE(USB_2_0, \"USB 2.0/1.1/1.0 as transmitted over the cable\"),\n\tDLT_CHOICE(ATSC_ALP, \"ATSC Link-Layer Protocol packets\"),\n\tDLT_CHOICE(ETW, \"Event Tracing for Windows messages\"),\n\tDLT_CHOICE(NETANALYZER_NG, \"Hilscher netANALYZER NG pseudo-footer\"),\n\tDLT_CHOICE(ZBOSS_NCP, \"ZBOSS NCP protocol with pseudo-header\"),\n\tDLT_CHOICE(USB_2_0_LOW_SPEED, \"Low-Speed USB 2.0/1.1/1.0 as transmitted over the cable\"),\n\tDLT_CHOICE(USB_2_0_FULL_SPEED, \"Full-Speed USB 2.0/1.1/1.0 as transmitted over the cable\"),\n\tDLT_CHOICE(USB_2_0_HIGH_SPEED, \"High-Speed USB 2.0 as transmitted over the cable\"),\n\tDLT_CHOICE(AUERSWALD_LOG, \"Auerswald Logger Protocol\"),\n\tDLT_CHOICE(ZWAVE_TAP, \"Z-Wave packets with a TAP meta-data header\"),\n\tDLT_CHOICE(SILABS_DEBUG_CHANNEL, \"Silicon Labs debug channel protocol\"),\n\tDLT_CHOICE(FIRA_UCI, \"Ultra-wideband controller interface protocol\"),\n\tDLT_CHOICE(MDB, \"Multi-Drop Bus\"),\n\tDLT_CHOICE(DECT_NR, \"DECT New Radio\"),\n\tDLT_CHOICE_SENTINEL\n};\n\nint\npcap_datalink_name_to_val(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (pcapint_strcasecmp(dlt_choices[i].name, name) == 0)\n\t\t\treturn (dlt_choices[i].dlt);\n\t}\n\treturn (-1);\n}\n\nconst char *\npcap_datalink_val_to_name(int dlt)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (dlt_choices[i].dlt == dlt)\n\t\t\treturn (dlt_choices[i].name);\n\t}\n\treturn (NULL);\n}\n\nconst char *\npcap_datalink_val_to_description(int dlt)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (dlt_choices[i].dlt == dlt)\n\t\t\treturn (dlt_choices[i].description);\n\t}\n\treturn (NULL);\n}\n\nconst char *\npcap_datalink_val_to_description_or_dlt(int dlt)\n{\n        static thread_local char unkbuf[40];\n        const char *description;\n\n        description = pcap_datalink_val_to_description(dlt);\n        if (description != NULL) {\n                return description;\n        } else {\n                (void)snprintf(unkbuf, sizeof(unkbuf), \"DLT %d\", dlt);\n                return unkbuf;\n        }\n}\n\nstruct tstamp_type_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\ttype;\n};\n\nstatic struct tstamp_type_choice tstamp_type_choices[] = {\n\t{ \"host\", \"Host\", PCAP_TSTAMP_HOST },\n\t{ \"host_lowprec\", \"Host, low precision\", PCAP_TSTAMP_HOST_LOWPREC },\n\t{ \"host_hiprec\", \"Host, high precision\", PCAP_TSTAMP_HOST_HIPREC },\n\t{ \"adapter\", \"Adapter\", PCAP_TSTAMP_ADAPTER },\n\t{ \"adapter_unsynced\", \"Adapter, not synced with system time\", PCAP_TSTAMP_ADAPTER_UNSYNCED },\n\t{ \"host_hiprec_unsynced\", \"Host, high precision, not synced with system time\", PCAP_TSTAMP_HOST_HIPREC_UNSYNCED },\n\t{ NULL, NULL, 0 }\n};\n\nint\npcap_tstamp_type_name_to_val(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (pcapint_strcasecmp(tstamp_type_choices[i].name, name) == 0)\n\t\t\treturn (tstamp_type_choices[i].type);\n\t}\n\treturn (PCAP_ERROR);\n}\n\nconst char *\npcap_tstamp_type_val_to_name(int tstamp_type)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (tstamp_type_choices[i].type == tstamp_type)\n\t\t\treturn (tstamp_type_choices[i].name);\n\t}\n\treturn (NULL);\n}\n\nconst char *\npcap_tstamp_type_val_to_description(int tstamp_type)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (tstamp_type_choices[i].type == tstamp_type)\n\t\t\treturn (tstamp_type_choices[i].description);\n\t}\n\treturn (NULL);\n}\n\nint\npcap_snapshot(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->snapshot);\n}\n\nint\npcap_is_swapped(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->swapped);\n}\n\nint\npcap_major_version(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->version_major);\n}\n\nint\npcap_minor_version(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->version_minor);\n}\n\nint\npcap_bufsize(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->bufsize);\n}\n\nFILE *\npcap_file(pcap_t *p)\n{\n\treturn (p->rfile);\n}\n\n#ifdef _WIN32\nint\npcap_fileno(pcap_t *p)\n{\n\tif (p->handle != INVALID_HANDLE_VALUE) {\n\t\t/*\n\t\t * This is a bogus and now-deprecated API; we\n\t\t * squelch the narrowing warning for the cast\n\t\t * from HANDLE to intptr_t.  If Windows programmers\n\t\t * need to get at the HANDLE for a pcap_t, *if*\n\t\t * there is one, they should request such a\n\t\t * routine (and be prepared for it to return\n\t\t * INVALID_HANDLE_VALUE).\n\t\t */\nDIAG_OFF_NARROWING\n\t\treturn ((int)(intptr_t)p->handle);\nDIAG_ON_NARROWING\n\t} else\n\t\treturn (PCAP_ERROR);\n}\n#else /* _WIN32 */\nint\npcap_fileno(pcap_t *p)\n{\n\treturn (p->fd);\n}\n#endif /* _WIN32 */\n\n#if !defined(_WIN32)\nint\npcap_get_selectable_fd(pcap_t *p)\n{\n\treturn (p->selectable_fd);\n}\n\nconst struct timeval *\npcap_get_required_select_timeout(pcap_t *p)\n{\n\treturn (p->required_select_timeout);\n}\n#endif\n\nvoid\npcap_perror(pcap_t *p, const char *prefix)\n{\n\tfprintf(stderr, \"%s: %s\\n\", prefix, p->errbuf);\n}\n\nchar *\npcap_geterr(pcap_t *p)\n{\n\treturn (p->errbuf);\n}\n\nint\npcap_getnonblock(pcap_t *p, char *errbuf)\n{\n\tint ret;\n\n\tret = p->getnonblock_op(p);\n\tif (ret == -1) {\n\t\t/*\n\t\t * The get nonblock operation sets p->errbuf; this\n\t\t * function *shouldn't* have had a separate errbuf\n\t\t * argument, as it didn't need one, but I goofed\n\t\t * when adding it.\n\t\t *\n\t\t * We copy the error message to errbuf, so callers\n\t\t * can find it in either place.\n\t\t */\n\t\tpcapint_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);\n\t}\n\treturn (ret);\n}\n\n/*\n * Get the current non-blocking mode setting, under the assumption that\n * it's just the standard POSIX non-blocking flag.\n */\n#if !defined(_WIN32)\nint\npcapint_getnonblock_fd(pcap_t *p)\n{\n\tint fdflags;\n\n\tfdflags = fcntl(p->fd, F_GETFL, 0);\n\tif (fdflags == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_GETFL\");\n\t\treturn (-1);\n\t}\n\tif (fdflags & O_NONBLOCK)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n#endif\n\nint\npcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)\n{\n\tint ret;\n\n\tret = p->setnonblock_op(p, nonblock);\n\tif (ret == -1) {\n\t\t/*\n\t\t * The set nonblock operation sets p->errbuf; this\n\t\t * function *shouldn't* have had a separate errbuf\n\t\t * argument, as it didn't need one, but I goofed\n\t\t * when adding it.\n\t\t *\n\t\t * We copy the error message to errbuf, so callers\n\t\t * can find it in either place.\n\t\t */\n\t\tpcapint_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);\n\t}\n\treturn (ret);\n}\n\n#if !defined(_WIN32)\n/*\n * Set non-blocking mode, under the assumption that it's just the\n * standard POSIX non-blocking flag.  (This can be called by the\n * per-platform non-blocking-mode routine if that routine also\n * needs to do some additional work.)\n */\nint\npcapint_setnonblock_fd(pcap_t *p, int nonblock)\n{\n\tint fdflags;\n\n\tfdflags = fcntl(p->fd, F_GETFL, 0);\n\tif (fdflags == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_GETFL\");\n\t\treturn (-1);\n\t}\n\tif (nonblock)\n\t\tfdflags |= O_NONBLOCK;\n\telse\n\t\tfdflags &= ~O_NONBLOCK;\n\tif (fcntl(p->fd, F_SETFL, fdflags) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_SETFL\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n#endif\n\n/*\n * Generate error strings for PCAP_ERROR_ and PCAP_WARNING_ values.\n */\nconst char *\npcap_statustostr(int errnum)\n{\n\tstatic thread_local char ebuf[15+10+1];\n\n\tswitch (errnum) {\n\n\tcase PCAP_WARNING:\n\t\treturn(\"Generic warning\");\n\n\tcase PCAP_WARNING_TSTAMP_TYPE_NOTSUP:\n\t\treturn (\"That type of time stamp is not supported by that device\");\n\n\tcase PCAP_WARNING_PROMISC_NOTSUP:\n\t\treturn (\"That device doesn't support promiscuous mode\");\n\n\tcase PCAP_ERROR:\n\t\treturn(\"Generic error\");\n\n\tcase PCAP_ERROR_BREAK:\n\t\treturn(\"Loop terminated by pcap_breakloop\");\n\n\tcase PCAP_ERROR_NOT_ACTIVATED:\n\t\treturn(\"The pcap_t has not been activated\");\n\n\tcase PCAP_ERROR_ACTIVATED:\n\t\treturn (\"The setting can't be changed after the pcap_t is activated\");\n\n\tcase PCAP_ERROR_NO_SUCH_DEVICE:\n\t\treturn (\"No such device exists\");\n\n\tcase PCAP_ERROR_RFMON_NOTSUP:\n\t\treturn (\"That device doesn't support monitor mode\");\n\n\tcase PCAP_ERROR_NOT_RFMON:\n\t\treturn (\"That operation is supported only in monitor mode\");\n\n\tcase PCAP_ERROR_PERM_DENIED:\n\t\treturn (\"You don't have permission to perform this capture on that device\");\n\n\tcase PCAP_ERROR_IFACE_NOT_UP:\n\t\treturn (\"That device is not up\");\n\n\tcase PCAP_ERROR_CANTSET_TSTAMP_TYPE:\n\t\treturn (\"That device doesn't support setting the time stamp type\");\n\n\tcase PCAP_ERROR_PROMISC_PERM_DENIED:\n\t\treturn (\"You don't have permission to capture in promiscuous mode on that device\");\n\n\tcase PCAP_ERROR_TSTAMP_PRECISION_NOTSUP:\n\t\treturn (\"That device doesn't support that time stamp precision\");\n\n\tcase PCAP_ERROR_CAPTURE_NOTSUP:\n\t\treturn (\"Packet capture is not supported on that device\");\n\t}\n\t(void)snprintf(ebuf, sizeof ebuf, \"Unknown error: %d\", errnum);\n\treturn(ebuf);\n}\n\n/*\n * A long time ago the purpose of this function was to hide the difference\n * between those Unix-like OSes that implemented strerror() and those that\n * didn't.  All the currently supported OSes implement strerror(), which is in\n * POSIX.1-2001, uniformly and that particular problem no longer exists.  But\n * now they implement a few incompatible thread-safe variants of strerror(),\n * and hiding that difference is the current purpose of this function.\n */\nconst char *\npcap_strerror(int errnum)\n{\n#ifdef _WIN32\n\tstatic thread_local char errbuf[PCAP_ERRBUF_SIZE];\n\terrno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);\n\n\tif (err != 0) /* err = 0 if successful */\n\t\tpcapint_strlcpy(errbuf, \"strerror_s() error\", PCAP_ERRBUF_SIZE);\n\treturn (errbuf);\n#elif defined(HAVE_GNU_STRERROR_R)\n\t/*\n\t * We have a GNU-style strerror_r(), which is *not* guaranteed to\n\t * do anything to the buffer handed to it, and which returns a\n\t * pointer to the error string, which may or may not be in\n\t * the buffer.\n\t *\n\t * It is, however, guaranteed to succeed.\n\t *\n\t * At the time of this writing this applies to the following cases,\n\t * each of which allows to use either the GNU implementation or the\n\t * POSIX implementation, and this source tree defines _GNU_SOURCE to\n\t * use the GNU implementation:\n\t * - Hurd\n\t * - Linux with GNU libc\n\t * - Linux with uClibc-ng\n\t */\n\tstatic thread_local char errbuf[PCAP_ERRBUF_SIZE];\n\treturn strerror_r(errnum, errbuf, PCAP_ERRBUF_SIZE);\n#elif defined(HAVE_POSIX_STRERROR_R)\n\t/*\n\t * We have a POSIX-style strerror_r(), which is guaranteed to fill\n\t * in the buffer, but is not guaranteed to succeed.\n\t *\n\t * At the time of this writing this applies to the following cases:\n\t * - AIX 7\n\t * - FreeBSD\n\t * - Haiku\n\t * - HP-UX 11\n\t * - illumos\n\t * - Linux with musl libc\n\t * - macOS\n\t * - NetBSD\n\t * - OpenBSD\n\t * - Solaris 10 & 11\n\t */\n\tstatic thread_local char errbuf[PCAP_ERRBUF_SIZE];\n\tint err = strerror_r(errnum, errbuf, PCAP_ERRBUF_SIZE);\n\tswitch (err) {\n\tcase 0:\n\t\t/* That worked. */\n\t\tbreak;\n\n\tcase EINVAL:\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"Unknown error: %d\", errnum);\n\t\tbreak;\n\tcase ERANGE:\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"Message for error %d is too long\", errnum);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t         \"strerror_r(%d, ...) unexpectedly returned %d\",\n\t\t         errnum, err);\n\t}\n\treturn errbuf;\n#else\n\t/*\n\t * At the time of this writing every supported OS implements strerror()\n\t * and at least one thread-safe variant thereof, so this is a very\n\t * unlikely last-resort branch.  Particular implementations of strerror()\n\t * may be thread-safe, but this is neither required nor guaranteed.\n\t */\n\treturn (strerror(errnum));\n#endif /* _WIN32 */\n}\n\nint\npcap_setfilter(pcap_t *p, struct bpf_program *fp)\n{\n\treturn (p->setfilter_op(p, fp));\n}\n\n/*\n * Set direction flag, which controls whether we accept only incoming\n * packets, only outgoing packets, or both.\n * Note that, depending on the platform, some or all direction arguments\n * might not be supported.\n */\nint\npcap_setdirection(pcap_t *p, pcap_direction_t d)\n{\n\tif (p->setdirection_op == NULL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Setting direction is not supported on this device\");\n\t\treturn (-1);\n\t} else {\n\t\tswitch (d) {\n\n\t\tcase PCAP_D_IN:\n\t\tcase PCAP_D_OUT:\n\t\tcase PCAP_D_INOUT:\n\t\t\t/*\n\t\t\t * Valid direction.\n\t\t\t */\n\t\t\treturn (p->setdirection_op(p, d));\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Invalid direction.\n\t\t\t */\n\t\t\tsnprintf(p->errbuf, sizeof(p->errbuf),\n\t\t\t    \"Invalid direction\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n}\n\nint\npcap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\treturn (p->stats_op(p, ps));\n}\n\n#ifdef _WIN32\nstruct pcap_stat *\npcap_stats_ex(pcap_t *p, int *pcap_stat_size)\n{\n\treturn (p->stats_ex_op(p, pcap_stat_size));\n}\n\nint\npcap_setbuff(pcap_t *p, int dim)\n{\n\treturn (p->setbuff_op(p, dim));\n}\n\nint\npcap_setmode(pcap_t *p, int mode)\n{\n\treturn (p->setmode_op(p, mode));\n}\n\nint\npcap_setmintocopy(pcap_t *p, int size)\n{\n\treturn (p->setmintocopy_op(p, size));\n}\n\nHANDLE\npcap_getevent(pcap_t *p)\n{\n\treturn (p->getevent_op(p));\n}\n\nint\npcap_oid_get_request(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)\n{\n\treturn (p->oid_get_request_op(p, oid, data, lenp));\n}\n\nint\npcap_oid_set_request(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp)\n{\n\treturn (p->oid_set_request_op(p, oid, data, lenp));\n}\n\npcap_send_queue *\npcap_sendqueue_alloc(u_int memsize)\n{\n\tpcap_send_queue *tqueue;\n\n\t/* Allocate the queue */\n\ttqueue = (pcap_send_queue *)malloc(sizeof(pcap_send_queue));\n\tif (tqueue == NULL){\n\t\treturn (NULL);\n\t}\n\n\t/* Allocate the buffer */\n\ttqueue->buffer = (char *)malloc(memsize);\n\tif (tqueue->buffer == NULL) {\n\t\tfree(tqueue);\n\t\treturn (NULL);\n\t}\n\n\ttqueue->maxlen = memsize;\n\ttqueue->len = 0;\n\n\treturn (tqueue);\n}\n\nvoid\npcap_sendqueue_destroy(pcap_send_queue *queue)\n{\n\tfree(queue->buffer);\n\tfree(queue);\n}\n\nint\npcap_sendqueue_queue(pcap_send_queue *queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)\n{\n\tif (queue->len + sizeof(struct pcap_pkthdr) + pkt_header->caplen > queue->maxlen){\n\t\treturn (-1);\n\t}\n\n\t/* Copy the pcap_pkthdr header*/\n\tmemcpy(queue->buffer + queue->len, pkt_header, sizeof(struct pcap_pkthdr));\n\tqueue->len += sizeof(struct pcap_pkthdr);\n\n\t/* copy the packet */\n\tmemcpy(queue->buffer + queue->len, pkt_data, pkt_header->caplen);\n\tqueue->len += pkt_header->caplen;\n\n\treturn (0);\n}\n\nu_int\npcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\treturn (p->sendqueue_transmit_op(p, queue, sync));\n}\n\nint\npcap_setuserbuffer(pcap_t *p, int size)\n{\n\treturn (p->setuserbuffer_op(p, size));\n}\n\nint\npcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\treturn (p->live_dump_op(p, filename, maxsize, maxpacks));\n}\n\nint\npcap_live_dump_ended(pcap_t *p, int sync)\n{\n\treturn (p->live_dump_ended_op(p, sync));\n}\n\nPAirpcapHandle\npcap_get_airpcap_handle(pcap_t *p)\n{\n\t(void)snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t\"AirPcap devices are no longer supported\");\n\n\treturn (NULL);\n}\n#endif\n\n/*\n * On some platforms, we need to clean up promiscuous or monitor mode\n * when we close a device - and we want that to happen even if the\n * application just exits without explicitly closing devices.\n * On those platforms, we need to register a \"close all the pcaps\"\n * routine to be called when we exit, and need to maintain a list of\n * pcaps that need to be closed to clean up modes.\n *\n * XXX - not thread-safe.\n */\n\n/*\n * List of pcaps on which we've done something that needs to be\n * cleaned up.\n * If there are any such pcaps, we arrange to call \"pcap_close_all()\"\n * when we exit, and have it close all of them.\n */\nstatic struct pcap *pcaps_to_close;\n\n/*\n * TRUE if we've already called \"atexit()\" to cause \"pcap_close_all()\" to\n * be called on exit.\n */\nstatic int did_atexit;\n\nstatic void\npcap_close_all(void)\n{\n\tstruct pcap *handle;\n\n\twhile ((handle = pcaps_to_close) != NULL) {\n\t\tpcap_close(handle);\n\n\t\t/*\n\t\t * If a pcap module adds a pcap_t to the \"close all\"\n\t\t * list by calling pcapint_add_to_pcaps_to_close(), it\n\t\t * must have a cleanup routine that removes it from the\n\t\t * list, by calling pcapint_remove_from_pcaps_to_close(),\n\t\t * and must make that cleanup routine the cleanup_op\n\t\t * for the pcap_t.\n\t\t *\n\t\t * That means that, after pcap_close() - which calls\n\t\t * the cleanup_op for the pcap_t - the pcap_t must\n\t\t * have been removed from the list, so pcaps_to_close\n\t\t * must not be equal to handle.\n\t\t *\n\t\t * We check for that, and abort if handle is still\n\t\t * at the head of the list, to prevent infinite loops.\n\t\t */\n\t\tif (pcaps_to_close == handle)\n\t\t\tabort();\n\t}\n}\n\nint\npcapint_do_addexit(pcap_t *p)\n{\n\t/*\n\t * If we haven't already done so, arrange to have\n\t * \"pcap_close_all()\" called when we exit.\n\t */\n\tif (!did_atexit) {\n\t\tif (atexit(pcap_close_all) != 0) {\n\t\t\t/*\n\t\t\t * \"atexit()\" failed; let our caller know.\n\t\t\t */\n\t\t\tpcapint_strlcpy(p->errbuf, \"atexit failed\", PCAP_ERRBUF_SIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tdid_atexit = 1;\n\t}\n\treturn (1);\n}\n\nvoid\npcapint_add_to_pcaps_to_close(pcap_t *p)\n{\n\tp->next = pcaps_to_close;\n\tpcaps_to_close = p;\n}\n\nvoid\npcapint_remove_from_pcaps_to_close(pcap_t *p)\n{\n\tpcap_t *pc, *prevpc;\n\n\tfor (pc = pcaps_to_close, prevpc = NULL; pc != NULL;\n\t    prevpc = pc, pc = pc->next) {\n\t\tif (pc == p) {\n\t\t\t/*\n\t\t\t * Found it.  Remove it from the list.\n\t\t\t */\n\t\t\tif (prevpc == NULL) {\n\t\t\t\t/*\n\t\t\t\t * It was at the head of the list.\n\t\t\t\t */\n\t\t\t\tpcaps_to_close = pc->next;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * It was in the middle of the list.\n\t\t\t\t */\n\t\t\t\tprevpc->next = pc->next;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\npcapint_breakloop_common(pcap_t *p)\n{\n\tp->break_loop = 1;\n}\n\n\nvoid\npcapint_cleanup_live_common(pcap_t *p)\n{\n\tif (p->opt.device != NULL) {\n\t\tfree(p->opt.device);\n\t\tp->opt.device = NULL;\n\t}\n\tif (p->buffer != NULL) {\n\t\tfree(p->buffer);\n\t\tp->buffer = NULL;\n\t}\n\tif (p->dlt_list != NULL) {\n\t\tfree(p->dlt_list);\n\t\tp->dlt_list = NULL;\n\t\tp->dlt_count = 0;\n\t}\n\tif (p->tstamp_type_list != NULL) {\n\t\tfree(p->tstamp_type_list);\n\t\tp->tstamp_type_list = NULL;\n\t\tp->tstamp_type_count = 0;\n\t}\n\tif (p->tstamp_precision_list != NULL) {\n\t\tfree(p->tstamp_precision_list);\n\t\tp->tstamp_precision_list = NULL;\n\t\tp->tstamp_precision_count = 0;\n\t}\n\tpcap_freecode(&p->fcode);\n#if !defined(_WIN32)\n\tif (p->fd >= 0) {\n\t\tclose(p->fd);\n\t\tp->fd = -1;\n\t}\n\tp->selectable_fd = -1;\n#endif\n}\n\n/*\n * API compatible with WinPcap's \"send a packet\" routine - returns -1\n * on error, 0 otherwise.\n *\n * XXX - what if we get a short write?\n */\nint\npcap_sendpacket(pcap_t *p, const u_char *buf, int size)\n{\n\tif (size <= 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"The number of bytes to be sent must be positive\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (p->inject_op(p, buf, size) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\n/*\n * API compatible with OpenBSD's \"send a packet\" routine - returns -1 on\n * error, number of bytes written otherwise.\n */\nint\npcap_inject(pcap_t *p, const void *buf, size_t size)\n{\n\t/*\n\t * We return the number of bytes written, so the number of\n\t * bytes to write must fit in an int.\n\t */\n\tif (size > INT_MAX) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"More than %d bytes cannot be injected\", INT_MAX);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (size == 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"The number of bytes to be injected must not be zero\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (p->inject_op(p, buf, (int)size));\n}\n\nvoid\npcap_close(pcap_t *p)\n{\n\tp->cleanup_op(p);\n\tfree(p);\n}\n\n/*\n * Helpers for safely loading code at run time.\n * Currently Windows-only.\n */\n#ifdef _WIN32\n//\n// This wrapper around loadlibrary appends the system folder (usually\n// C:\\Windows\\System32) to the relative path of the DLL, so that the DLL\n// is always loaded from an absolute path (it's no longer possible to\n// load modules from the application folder).\n// This solves the DLL Hijacking issue discovered in August 2010:\n//\n// https://blog.rapid7.com/2010/08/23/exploiting-dll-hijacking-flaws/\n// https://blog.rapid7.com/2010/08/23/application-dll-load-hijacking/\n// (the purported Rapid7 blog post link in the first of those two links\n// is broken; the second of those links works.)\n//\n// If any links there are broken from all the content shuffling Rapid&\n// did, see archived versions of the posts at their original homes, at\n//\n// https://web.archive.org/web/20110122175058/http://blog.metasploit.com/2010/08/exploiting-dll-hijacking-flaws.html\n// https://web.archive.org/web/20100828112111/http://blog.rapid7.com/?p=5325\n//\npcap_code_handle_t\npcapint_load_code(const char *name)\n{\n\t/*\n\t * XXX - should this work in UTF-16LE rather than in the local\n\t * ANSI code page?\n\t */\n\tCHAR path[MAX_PATH];\n\tCHAR fullFileName[MAX_PATH];\n\tUINT res;\n\tHMODULE hModule = NULL;\n\n\tdo\n\t{\n\t\tres = GetSystemDirectoryA(path, MAX_PATH);\n\n\t\tif (res == 0) {\n\t\t\t//\n\t\t\t// some bad failure occurred;\n\t\t\t//\n\t\t\tbreak;\n\t\t}\n\n\t\tif (res > MAX_PATH) {\n\t\t\t//\n\t\t\t// the buffer was not big enough\n\t\t\t//\n\t\t\tSetLastError(ERROR_INSUFFICIENT_BUFFER);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (res + 1 + strlen(name) + 1 < MAX_PATH) {\n\t\t\tmemcpy(fullFileName, path, res * sizeof(TCHAR));\n\t\t\tfullFileName[res] = '\\\\';\n\t\t\tmemcpy(&fullFileName[res + 1], name, (strlen(name) + 1) * sizeof(TCHAR));\n\n\t\t\thModule = LoadLibraryA(fullFileName);\n\t\t} else\n\t\t\tSetLastError(ERROR_INSUFFICIENT_BUFFER);\n\n\t} while(FALSE);\n\n\treturn hModule;\n}\n\n/*\n * Casting from FARPROC, which is the type of the return value of\n * GetProcAddress(), to a function pointer gets a C4191 warning\n * from Visual Studio 2022.\n *\n * Casting FARPROC to void * and returning the result, and then\n * casting the void * to a function pointer, doesn't get the\n * same warning.\n *\n * Given that, and given that the equivalent UN*X API, dlsym(),\n * returns a void *, we have pcapint_find_function() return\n * a void *.\n */\nvoid *\npcapint_find_function(pcap_code_handle_t code, const char *func)\n{\n\treturn ((void *)GetProcAddress(code, func));\n}\n#endif\n\n/*\n * Given a BPF program, a pcap_pkthdr structure for a packet, and the raw\n * data for the packet, check whether the packet passes the filter.\n * Returns the return value of the filter program, which will be zero if\n * the packet doesn't pass and non-zero if the packet does pass.\n */\nint\npcap_offline_filter(const struct bpf_program *fp, const struct pcap_pkthdr *h,\n    const u_char *pkt)\n{\n\tconst struct bpf_insn *fcode = fp->bf_insns;\n\n\tif (fcode != NULL)\n\t\treturn (pcapint_filter(fcode, pkt, h->len, h->caplen));\n\telse\n\t\treturn (0);\n}\n\nstatic int\npcap_can_set_rfmon_dead(pcap_t *p)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Rfmon mode doesn't apply on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}\n\nstatic int\npcap_read_dead(pcap_t *p, int cnt _U_, pcap_handler callback _U_,\n    u_char *user _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets aren't available from a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic void\npcap_breakloop_dead(pcap_t *p _U_)\n{\n\t/*\n\t * A \"dead\" pcap_t is just a placeholder to use in order to\n\t * compile a filter to BPF code or to open a savefile for\n\t * writing.  It doesn't support any operations, including\n\t * capturing or reading packets, so there will never be a\n\t * get-packets loop in progress to break out *of*.\n\t *\n\t * As such, this routine doesn't need to do anything.\n\t */\n}\n\nstatic int\npcap_inject_dead(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets can't be sent on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_setfilter_dead(pcap_t *p, struct bpf_program *fp _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A filter cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_setdirection_dead(pcap_t *p, pcap_direction_t d _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The packet direction cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_set_datalink_dead(pcap_t *p, int dlt _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The link-layer header type cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_getnonblock_dead(pcap_t *p)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t does not have a non-blocking mode setting\");\n\treturn (-1);\n}\n\nstatic int\npcap_setnonblock_dead(pcap_t *p, int nonblock _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t does not have a non-blocking mode setting\");\n\treturn (-1);\n}\n\nstatic int\npcap_stats_dead(pcap_t *p, struct pcap_stat *ps _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\n#ifdef _WIN32\nstatic struct pcap_stat *\npcap_stats_ex_dead(pcap_t *p, int *pcap_stat_size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from a pcap_open_dead pcap_t\");\n\treturn (NULL);\n}\n\nstatic int\npcap_setbuff_dead(pcap_t *p, int dim _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The kernel buffer size cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_setmode_dead(pcap_t *p, int mode _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"impossible to set mode on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_setmintocopy_dead(pcap_t *p, int size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The mintocopy parameter cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic HANDLE\npcap_getevent_dead(pcap_t *p)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t has no event handle\");\n\treturn (INVALID_HANDLE_VALUE);\n}\n\nstatic int\npcap_oid_get_request_dead(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,\n    size_t *lenp _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID get request cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}\n\nstatic int\npcap_oid_set_request_dead(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,\n    size_t *lenp _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID set request cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}\n\nstatic u_int\npcap_sendqueue_transmit_dead(pcap_t *p, pcap_send_queue *queue _U_,\n    int sync _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets cannot be transmitted on a pcap_open_dead pcap_t\");\n\treturn (0);\n}\n\nstatic int\npcap_setuserbuffer_dead(pcap_t *p, int size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The user buffer cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_live_dump_dead(pcap_t *p, char *filename _U_, int maxsize _U_,\n    int maxpacks _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n\nstatic int\npcap_live_dump_ended_dead(pcap_t *p, int sync _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n#endif /* _WIN32 */\n\nstatic void\npcap_cleanup_dead(pcap_t *p _U_)\n{\n\t/* Nothing to do. */\n}\n\npcap_t *\npcap_open_dead_with_tstamp_precision(int linktype, int snaplen, u_int precision)\n{\n\tpcap_t *p;\n\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * This doesn't really matter, but we don't have any way\n\t\t * to report particular errors, so the only failure we\n\t\t * should have is a memory allocation failure.  Just\n\t\t * pick microsecond precision.\n\t\t */\n\t\tprecision = PCAP_TSTAMP_PRECISION_MICRO;\n\t\tbreak;\n\t}\n\tp = malloc(sizeof(*p));\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemset (p, 0, sizeof(*p));\n\tp->snapshot = snaplen;\n\tp->linktype = linktype;\n\tp->opt.tstamp_precision = precision;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_dead;\n\tp->read_op = pcap_read_dead;\n\tp->inject_op = pcap_inject_dead;\n\tp->setfilter_op = pcap_setfilter_dead;\n\tp->setdirection_op = pcap_setdirection_dead;\n\tp->set_datalink_op = pcap_set_datalink_dead;\n\tp->getnonblock_op = pcap_getnonblock_dead;\n\tp->setnonblock_op = pcap_setnonblock_dead;\n\tp->stats_op = pcap_stats_dead;\n#ifdef _WIN32\n\tp->stats_ex_op = pcap_stats_ex_dead;\n\tp->setbuff_op = pcap_setbuff_dead;\n\tp->setmode_op = pcap_setmode_dead;\n\tp->setmintocopy_op = pcap_setmintocopy_dead;\n\tp->getevent_op = pcap_getevent_dead;\n\tp->oid_get_request_op = pcap_oid_get_request_dead;\n\tp->oid_set_request_op = pcap_oid_set_request_dead;\n\tp->sendqueue_transmit_op = pcap_sendqueue_transmit_dead;\n\tp->setuserbuffer_op = pcap_setuserbuffer_dead;\n\tp->live_dump_op = pcap_live_dump_dead;\n\tp->live_dump_ended_op = pcap_live_dump_ended_dead;\n#endif\n\tp->breakloop_op = pcap_breakloop_dead;\n\tp->cleanup_op = pcap_cleanup_dead;\n\n\t/*\n\t * A \"dead\" pcap_t never requires special BPF code generation.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\tp->activated = 1;\n\treturn (p);\n}\n\npcap_t *\npcap_open_dead(int linktype, int snaplen)\n{\n\treturn (pcap_open_dead_with_tstamp_precision(linktype, snaplen,\n\t    PCAP_TSTAMP_PRECISION_MICRO));\n}\n\n#ifdef YYDEBUG\n/*\n * Set the internal \"debug printout\" flag for the filter expression parser.\n * The code to print that stuff is present only if YYDEBUG is defined, so\n * the flag, and the routine to set it, are defined only if YYDEBUG is\n * defined.\n *\n * This is intended for libpcap developers, not for general use.\n * If you want to set these in a program, you'll have to declare this\n * routine yourself, with the appropriate DLL import attribute on Windows;\n * it's not declared in any header file, and won't be declared in any\n * header file provided by libpcap.\n */\nPCAP_API void pcap_set_parser_debug(int value);\n\nPCAP_API_DEF void\npcap_set_parser_debug(int value)\n{\n\tpcap_debug = value;\n}\n#endif\n\n/*\n * APIs.added in WinPcap for remote capture.\n *\n * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino, CACE Technologies\n * nor the names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n#ifndef _WIN32\n#include <dirent.h>\t\t// for readdir\n#endif\n\n/* String identifier to be used in the pcap_findalldevs_ex() */\n#define PCAP_TEXT_SOURCE_FILE \"File\"\n#define PCAP_TEXT_SOURCE_FILE_LEN (sizeof PCAP_TEXT_SOURCE_FILE - 1)\n/* String identifier to be used in the pcap_findalldevs_ex() */\n#define PCAP_TEXT_SOURCE_ADAPTER \"Network adapter\"\n#define PCAP_TEXT_SOURCE_ADAPTER_LEN (sizeof \"Network adapter\" - 1)\n\n/* String identifier to be used in the pcap_findalldevs_ex() */\n#define PCAP_TEXT_SOURCE_ON_LOCAL_HOST \"on local host\"\n#define PCAP_TEXT_SOURCE_ON_LOCAL_HOST_LEN (sizeof PCAP_TEXT_SOURCE_ON_LOCAL_HOST + 1)\n\n#ifdef ENABLE_REMOTE\n #define _USED_FOR_REMOTE\n#else\n #define _USED_FOR_REMOTE _U_\n#endif\n\nint\npcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth _USED_FOR_REMOTE,\n    pcap_if_t **alldevs, char *errbuf)\n{\n\tint type;\n\tchar name[PCAP_BUF_SIZE], path[PCAP_BUF_SIZE], filename[PCAP_BUF_SIZE];\n\tsize_t pathlen;\n\tsize_t stringlen;\n\tpcap_t *fp;\n\tchar tmpstring[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\tpcap_if_t *lastdev;\t/* Last device in the pcap_if_t list */\n\tpcap_if_t *dev;\t\t/* Device we're adding to the pcap_if_t list */\n\n\t/* List starts out empty. */\n\t(*alldevs) = NULL;\n\tlastdev = NULL;\n\n\tif (strlen(source) > PCAP_BUF_SIZE) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"The source string is too long. Cannot handle it correctly.\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Determine the type of the source (file, local, remote).\n\t *\n\t * There are some differences if pcap_findalldevs_ex() is called to\n\t * list files and remote adapters.\n\t *\n\t * In the first case, the name of the directory we have to look into\n\t * must be present (therefore the 'name' parameter of the\n\t * pcap_parsesrcstr() is present).\n\t *\n\t * In the second case, the name of the adapter is not required\n\t * (we need just the host). So, we have to use this function a\n\t * first time to get the source type, and a second time to get\n\t * the appropriate info, which depends on the source type.\n\t */\n\tif (pcap_parsesrcstr(source, &type, NULL, NULL, NULL, errbuf) == -1)\n\t\treturn (PCAP_ERROR);\n\n\tswitch (type) {\n\n\tcase PCAP_SRC_IFLOCAL:\n\t\tif (pcap_parsesrcstr(source, &type, NULL, NULL, NULL, errbuf) == -1)\n\t\t\treturn (PCAP_ERROR);\n\n\t\t/* Initialize temporary string */\n\t\ttmpstring[PCAP_BUF_SIZE] = 0;\n\n\t\t/* The user wants to retrieve adapters from a local host */\n\t\tif (pcap_findalldevs(alldevs, errbuf) == -1)\n\t\t\treturn (PCAP_ERROR);\n\n\t\tif (*alldevs == NULL) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"No interfaces found! Make sure libpcap/Npcap is properly installed\"\n\t\t\t    \" on the local machine.\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/*\n\t\t * Scan all the interfaces and modify name and description.\n\t\t *\n\t\t * This is a trick in order to avoid the re-implementation\n\t\t * of pcap_findalldevs here.\n\t\t */\n\t\tdev = *alldevs;\n\t\twhile (dev) {\n\t\t\tchar *localdesc, *desc;\n\n\t\t\t/* Create the new device identifier */\n\t\t\tif (pcap_createsrcstr(tmpstring, PCAP_SRC_IFLOCAL, NULL, NULL, dev->name, errbuf) == -1)\n\t\t\t\treturn (PCAP_ERROR);\n\n\t\t\t/* Delete the old pointer */\n\t\t\tfree(dev->name);\n\n\t\t\t/* Make a copy of the new device identifier */\n\t\t\tdev->name = strdup(tmpstring);\n\t\t\tif (dev->name == NULL) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc() failed\");\n\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create the description.\n\t\t\t */\n\t\t\tif ((dev->description == NULL) ||\n\t\t\t    (dev->description[0] == 0))\n\t\t\t\tlocaldesc = dev->name;\n\t\t\telse\n\t\t\t\tlocaldesc = dev->description;\n\t\t\tif (pcapint_asprintf(&desc, \"%s '%s' %s\",\n\t\t\t    PCAP_TEXT_SOURCE_ADAPTER, localdesc,\n\t\t\t    PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc() failed\");\n\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\n\t\t\t/* Now overwrite the description */\n\t\t\tfree(dev->description);\n\t\t\tdev->description = desc;\n\n\t\t\tdev = dev->next;\n\t\t}\n\n\t\treturn (0);\n\n\tcase PCAP_SRC_FILE:\n\t{\n#ifdef _WIN32\n\t\tWIN32_FIND_DATA filedata;\n\t\tHANDLE filehandle;\n#else\n\t\tstruct dirent *filedata;\n\t\tDIR *unixdir;\n#endif\n\n\t\tif (pcap_parsesrcstr(source, &type, NULL, NULL, name, errbuf) == -1)\n\t\t\treturn (PCAP_ERROR);\n\n\t\t/* Check that the filename is correct */\n\t\tstringlen = strlen(name);\n\n\t\t/*\n\t\t * The directory must end with '\\' in Windows and\n\t\t * '/' in UN*Xes.\n\t\t */\n#ifdef _WIN32\n#define ENDING_CHAR '\\\\'\n#else\n#define ENDING_CHAR '/'\n#endif\n\n\t\tif (name[stringlen - 1] != ENDING_CHAR) {\n\t\t\tname[stringlen] = ENDING_CHAR;\n\t\t\tname[stringlen + 1] = 0;\n\n\t\t\tstringlen++;\n\t\t}\n\n\t\t/* Save the path for future reference */\n\t\tsnprintf(path, sizeof(path), \"%s\", name);\n\t\tpathlen = strlen(path);\n\n#ifdef _WIN32\n\t\t/*\n\t\t * To perform directory listing, Windows must have an\n\t\t * asterisk as the ending character.\n\t\t */\n\t\tif (name[stringlen - 1] != '*')\t{\n\t\t\tname[stringlen] = '*';\n\t\t\tname[stringlen + 1] = 0;\n\t\t}\n\n\t\tfilehandle = FindFirstFile(name, &filedata);\n\n\t\tif (filehandle == INVALID_HANDLE_VALUE) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Error when listing files: does folder '%s' exist?\", path);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n#else\n\t\t/* opening the folder */\n\t\tunixdir= opendir(path);\n\t\tif (unixdir == NULL) {\n\t\t\tDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Error when listing files in '%s': %s\", path, pcap_strerror(errno));\n\t\t\tDIAG_ON_FORMAT_TRUNCATION\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/* get the first file into it */\n\t\terrno = 0;\n\t\tfiledata= readdir(unixdir);\n\n\t\tif (filedata == NULL) {\n\t\t\tDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Error when listing files in '%s': %s\", path, pcap_strerror(errno));\n\t\t\tDIAG_ON_FORMAT_TRUNCATION\n\t\t\tclosedir(unixdir);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n#endif\n\n\t\t/* Add all files we find to the list. */\n\t\tdo {\n#ifdef _WIN32\n\t\t\t/* Skip the file if the pathname won't fit in the buffer */\n\t\t\tif (pathlen + strlen(filedata.cFileName) >= sizeof(filename))\n\t\t\t\tcontinue;\n\t\t\tsnprintf(filename, sizeof(filename), \"%s%s\", path, filedata.cFileName);\n#else\n\t\t\tif (pathlen + strlen(filedata->d_name) >= sizeof(filename))\n\t\t\t\tcontinue;\n\t\t\tDIAG_OFF_FORMAT_TRUNCATION\n\t\t\tsnprintf(filename, sizeof(filename), \"%s%s\", path, filedata->d_name);\n\t\t\tDIAG_ON_FORMAT_TRUNCATION\n#endif\n\n\t\t\tfp = pcap_open_offline(filename, errbuf);\n\n\t\t\tif (fp) {\n\t\t\t\t/* allocate the main structure */\n\t\t\t\tdev = (pcap_if_t *)malloc(sizeof(pcap_if_t));\n\t\t\t\tif (dev == NULL) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n#ifdef _WIN32\n\t\t\t\t\tFindClose(filehandle);\n#else\n\t\t\t\t\tclosedir(unixdir);\n#endif\n\t\t\t\t\treturn (PCAP_ERROR);\n\t\t\t\t}\n\n\t\t\t\t/* Initialize the structure to 'zero' */\n\t\t\t\tmemset(dev, 0, sizeof(pcap_if_t));\n\n\t\t\t\t/* Append it to the list. */\n\t\t\t\tif (lastdev == NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * List is empty, so it's also\n\t\t\t\t\t * the first device.\n\t\t\t\t\t */\n\t\t\t\t\t*alldevs = dev;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Append after the last device.\n\t\t\t\t\t */\n\t\t\t\t\tlastdev->next = dev;\n\t\t\t\t}\n\t\t\t\t/* It's now the last device. */\n\t\t\t\tlastdev = dev;\n\n\t\t\t\t/* Create the new source identifier */\n\t\t\t\tif (pcap_createsrcstr(tmpstring, PCAP_SRC_FILE,\n\t\t\t\t    NULL, NULL, filename, errbuf) == -1) {\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n#ifdef _WIN32\n\t\t\t\t\tFindClose(filehandle);\n#else\n\t\t\t\t\tclosedir(unixdir);\n#endif\n\t\t\t\t\treturn (PCAP_ERROR);\n\t\t\t\t}\n\n\t\t\t\tdev->name = strdup(tmpstring);\n\t\t\t\tif (dev->name == NULL) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n#ifdef _WIN32\n\t\t\t\t\tFindClose(filehandle);\n#else\n\t\t\t\t\tclosedir(unixdir);\n#endif\n\t\t\t\t\treturn (PCAP_ERROR);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Create the description.\n\t\t\t\t */\n\t\t\t\tif (pcapint_asprintf(&dev->description,\n\t\t\t\t    \"%s '%s' %s\", PCAP_TEXT_SOURCE_FILE,\n\t\t\t\t    filename, PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n#ifdef _WIN32\n\t\t\t\t\tFindClose(filehandle);\n#else\n\t\t\t\t\tclosedir(unixdir);\n#endif\n\t\t\t\t\treturn (PCAP_ERROR);\n\t\t\t\t}\n\n\t\t\t\tpcap_close(fp);\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\twhile (FindNextFile(filehandle, &filedata) != 0);\n#else\n\t\twhile ( (filedata= readdir(unixdir)) != NULL);\n#endif\n\n\n\t\t/* Close the search handle. */\n#ifdef _WIN32\n\t\tFindClose(filehandle);\n#else\n\t\tclosedir(unixdir);\n#endif\n\n\t\treturn (0);\n\t}\n\n\tcase PCAP_SRC_IFREMOTE:\n#ifdef ENABLE_REMOTE\n\t\treturn (pcap_findalldevs_ex_remote(source, auth, alldevs, errbuf));\n#else\n\t\tpcapint_strlcpy(errbuf, \"Remote packet capture is not supported\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\treturn (PCAP_ERROR);\n#endif\n\n\tdefault:\n\t\tpcapint_strlcpy(errbuf, \"Source type not supported\", PCAP_ERRBUF_SIZE);\n\t\treturn (PCAP_ERROR);\n\t}\n}\n\npcap_t *\npcap_open(const char *source, int snaplen, int flags, int read_timeout,\n    struct pcap_rmtauth *auth _USED_FOR_REMOTE, char *errbuf)\n{\n\tchar name[PCAP_BUF_SIZE];\n\tint type;\n\tpcap_t *fp;\n\tint status;\n\n\t/*\n\t * A null device name is equivalent to the \"any\" device -\n\t * which might not be supported on this platform, but\n\t * this means that you'll get a \"not supported\" error\n\t * rather than, say, a crash when we try to dereference\n\t * the null pointer.\n\t */\n\tif (source == NULL)\n\t\tsource = \"any\";\n\n\tif (strlen(source) > PCAP_BUF_SIZE) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"The source string is too long. Cannot handle it correctly.\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Determine the type of the source (file, local, remote) and,\n\t * if it's file or local, the name of the file or capture device.\n\t */\n\tif (pcap_parsesrcstr(source, &type, NULL, NULL, name, errbuf) == -1)\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase PCAP_SRC_FILE:\n\t\treturn (pcap_open_offline(name, errbuf));\n\n\tcase PCAP_SRC_IFLOCAL:\n\t\tfp = pcap_create(name, errbuf);\n\t\tbreak;\n\n\tcase PCAP_SRC_IFREMOTE:\n#ifdef ENABLE_REMOTE\n\t\t/*\n\t\t * Although we already have host, port and iface, we prefer\n\t\t * to pass only 'source' to pcap_open_rpcap(), so that it\n\t\t * has to call pcap_parsesrcstr() again.\n\t\t * This is less optimized, but much clearer.\n\t\t */\n\t\treturn (pcap_open_rpcap(source, snaplen, flags, read_timeout,\n\t\t    auth, errbuf));\n#else\n\t\tpcapint_strlcpy(errbuf, \"Remote packet capture is not supported\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\treturn (NULL);\n#endif\n\n\tdefault:\n\t\tpcapint_strlcpy(errbuf, \"Source type not supported\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\treturn (NULL);\n\t}\n\n\tif (fp == NULL)\n\t\treturn (NULL);\n\tstatus = pcap_set_snaplen(fp, snaplen);\n\tif (status < 0)\n\t\tgoto fail;\n\tif (flags & PCAP_OPENFLAG_PROMISCUOUS) {\n\t\tstatus = pcap_set_promisc(fp, 1);\n\t\tif (status < 0)\n\t\t\tgoto fail;\n\t}\n\tif (flags & PCAP_OPENFLAG_MAX_RESPONSIVENESS) {\n\t\tstatus = pcap_set_immediate_mode(fp, 1);\n\t\tif (status < 0)\n\t\t\tgoto fail;\n\t}\n#ifdef _WIN32\n\t/*\n\t * This flag is supported on Windows only.\n\t * XXX - is there a way to support it with\n\t * the capture mechanisms on UN*X?  It's not\n\t * exactly a \"set direction\" operation; I\n\t * think it means \"do not capture packets\n\t * injected with pcap_sendpacket() or\n\t * pcap_inject()\".\n\t */\n\t/* disable loopback capture if requested */\n\tif (flags & PCAP_OPENFLAG_NOCAPTURE_LOCAL)\n\t\tfp->opt.nocapture_local = 1;\n#endif /* _WIN32 */\n\tstatus = pcap_set_timeout(fp, read_timeout);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_activate(fp);\n\tif (status < 0)\n\t\tgoto fail;\n\treturn fp;\n\nfail:\n\tDIAG_OFF_FORMAT_TRUNCATION\n\tif (status == PCAP_ERROR)\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\",\n\t\t    name, fp->errbuf);\n\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE ||\n\t    status == PCAP_ERROR_PERM_DENIED ||\n\t    status == PCAP_ERROR_PROMISC_PERM_DENIED)\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s (%s)\",\n\t\t    name, pcap_statustostr(status), fp->errbuf);\n\telse\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\",\n\t\t    name, pcap_statustostr(status));\n\tDIAG_ON_FORMAT_TRUNCATION\n\tpcap_close(fp);\n\treturn (NULL);\n}\n\nstruct pcap_samp *\npcap_setsampling(pcap_t *p)\n{\n#ifdef ENABLE_REMOTE\n\treturn (&p->rmt_samp);\n#else\n\tpcapint_strlcpy(p->errbuf, \"Capture sampling is not supported\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (NULL);\n#endif\n}\n"
        },
        {
          "name": "pcap.h",
          "type": "blob",
          "size": 2.173828125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * For backwards compatibility.\n *\n * Note to OS vendors: do NOT get rid of this file!  Many applications\n * expect to be able to include <pcap.h>, and at least some of them\n * go through contortions in their configure scripts to try to detect\n * OSes that have \"helpfully\" moved pcap.h to <pcap/pcap.h> without\n * leaving behind a <pcap.h> file.\n */\n#include <pcap/pcap.h>\n"
        },
        {
          "name": "pcap",
          "type": "tree",
          "content": null
        },
        {
          "name": "pcap_activate.3pcap",
          "type": "blob",
          "size": 4.0634765625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_ACTIVATE 3PCAP \"3 June 2024\"\n.SH NAME\npcap_activate \\- activate a capture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_activate(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_activate ()\nis used to activate a packet capture handle to look\nat packets on the network, with the options that were set on the handle\nbeing in effect.\n.SH RETURN VALUE\n.BR pcap_activate ()\nreturns\n.B 0\non success without warnings, a non-zero positive value on\nsuccess with warnings, and a negative value on error.\nA non-zero return value indicates what warning or error condition\noccurred.\n.LP\nThe possible warning values are:\n.TP\n.B PCAP_WARNING_PROMISC_NOTSUP\nPromiscuous mode was requested, but the capture source doesn't support\npromiscuous mode.\n.TP\n.B PCAP_WARNING_TSTAMP_TYPE_NOTSUP\nThe time stamp type specified in a previous\n.BR pcap_set_tstamp_type (3PCAP)\ncall isn't supported by the capture source (the time stamp type is\nleft as the default),\n.TP\n.B PCAP_WARNING\nAnother warning condition occurred;\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display a message describing the warning\ncondition.\n.LP\nThe possible error values are:\n.TP\n.B PCAP_ERROR_ACTIVATED\nThe handle has already been activated.\n.TP\n.B PCAP_ERROR_NO_SUCH_DEVICE\nThe capture source specified when the handle was created doesn't\nexist.\n.TP\n.B PCAP_ERROR_PERM_DENIED\nThe process doesn't have permission to open the capture source.\n.TP\n.B PCAP_ERROR_PROMISC_PERM_DENIED\nThe process has permission to open the capture source but doesn't\nhave permission to put it into promiscuous mode.\n.TP\n.B PCAP_ERROR_RFMON_NOTSUP\nMonitor mode was specified but the capture source doesn't support\nmonitor mode.\n.TP\n.B PCAP_ERROR_IFACE_NOT_UP\nThe capture source device is not up.\n.TP\n.B PCAP_ERROR_CAPTURE_NOTSUP\nPacket capture is not supported on the capture source.\n.TP\n.B PCAP_ERROR\nAnother error occurred.\n.BR pcap_geterr ()\nor\n.BR pcap_perror ()\nmay be called with\n.I p\nas an argument to fetch or display a message describing the error.\n.LP\nIf\n.BR PCAP_WARNING_PROMISC_NOTSUP ,\n.BR PCAP_ERROR_NO_SUCH_DEVICE ,\n.BR PCAP_ERROR_PERM_DENIED ,\nor\n.B PCAP_ERROR_CAPTURE_NOTSUP\nis returned,\n.BR pcap_geterr ()\nor\n.BR pcap_perror ()\nmay be called with\n.I p\nas an argument to fetch or display an message giving additional details\nabout the problem that might be useful for debugging the problem if it's\nunexpected.\n.LP\nAdditional warning and error codes may be added in the future; a program\nshould check for positive, negative, and zero return codes, and treat\nall positive return codes as warnings and all negative return\ncodes as errors.\n.BR pcap_statustostr (3PCAP)\ncan be called, with a warning or error code as an argument, to fetch a\nmessage describing the warning or error code.\n.LP\nIf\n.BR pcap_activate ()\nfails, the\n.B pcap_t *\nis not closed and freed; it should be closed using\n.BR pcap_close (3PCAP).\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_breakloop.3pcap",
          "type": "blob",
          "size": 5.763671875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_BREAKLOOP 3PCAP \"27 January 2024\"\n.SH NAME\npcap_breakloop \\- force a pcap_dispatch() or pcap_loop() call to return\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nvoid pcap_breakloop(pcap_t *);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_breakloop ()\nsets a flag that will force\n.BR pcap_dispatch (3PCAP)\nor\n.BR pcap_loop (3PCAP)\nto return rather than looping; they will return the number of packets\nthat have been processed so far, or\n.B PCAP_ERROR_BREAK\nif no packets have been processed so far.  If the loop is currently\nblocked waiting for packets to arrive,\n.BR pcap_breakloop ()\nwill also, on some platforms, wake up the thread that is blocked.  In\nthis version of libpcap, the only platforms on which a wakeup is caused\nby\n.BR pcap_breakloop ()\nare Linux and Windows, and the wakeup will only be caused when capturing\non network interfaces; it will not be caused on other operating systems,\nand will not be caused on any OS when capturing on other types of\ndevices.\n.PP\nThis routine is safe to use inside a signal handler on UNIX or a console\ncontrol handler on Windows, or in a thread other than the one in which\nthe loop is running, as it merely sets a flag that is checked within the\nloop and, on some platforms, performs a signal-safe and thread-safe API\ncall.\n.PP\nThe flag is checked in loops reading packets from the OS - a signal by\nitself will not necessarily terminate those loops - as well as in loops\nprocessing a set of packets returned by the OS.\n.ft B\nNote that if you are catching signals on UNIX systems that support\nrestarting system calls after a signal, and calling pcap_breakloop()\nin the signal handler, you must specify, when catching those signals,\nthat system calls should NOT be restarted by that signal.  Otherwise,\nif the signal interrupted a call reading packets in a live capture,\nwhen your signal handler returns after calling pcap_breakloop(), the\ncall will be restarted, and the loop will not terminate until more\npackets arrive and the call completes.\n.ft R\n.PP\n.ft B\nNote also that, in a multi-threaded application, if one thread is\nblocked in pcap_dispatch(), pcap_loop(), pcap_next(3PCAP), or\npcap_next_ex(3PCAP), a call to pcap_breakloop() in a different thread\nwill only unblock that thread on the platforms and capture devices\nlisted above.\n.ft R\n.PP\nIf a non-zero packet buffer timeout is set on the\n.BR pcap_t ,\nand you are capturing on a network interface, the thread will be\nunblocked with the timeout expires.  This is not guaranteed to happen\nunless at least one packet has arrived; the only platforms on which it\nhappens are macOS, the BSDs, Solaris 11, AIX, and Windows.\n.PP\nIf you want to ensure that the loop will eventually be unblocked on any\nother platforms, or unblocked when capturing on a device other than a\nnetwork interface, you will need to use whatever mechanism the OS\nprovides for breaking a thread out of blocking calls in order to unblock\nthe thread, such as thread cancellation or thread signalling in systems\nthat support POSIX threads.\n.PP\n.ft B\nNote that if pcap_breakloop() unblocks the thread capturing packets, and\nyou are running on a platform that supports packet buffering, there may\nbe packets in the buffer that arrived before pcap_breakloop() were\ncalled but that weren't yet provided to libpcap, those packets will not\nhave been processed by pcap_dispatch() or pcap_loop().  If\npcap_breakloop() was called in order to terminate the capture process,\nthen, in order to process those packets, you would have to call\npcap_dispatch() one time in order to process the last batch of packets.\nThis may block until the packet buffer timeout expires, so a non-zero\npacket buffer timeout must be used.\n.ft R\n.PP\nNote that\n.BR pcap_next ()\nand\n.BR pcap_next_ex ()\nwill, on some platforms, loop reading packets from the OS; that loop\nwill not necessarily be terminated by a signal, so\n.BR pcap_breakloop ()\nshould be used to terminate packet processing even if\n.BR pcap_next ()\nor\n.BR pcap_next_ex ()\nis being used.\n.PP\n.BR pcap_breakloop ()\ndoes not guarantee that no further packets will be processed by\n.BR pcap_dispatch ()\nor\n.BR pcap_loop ()\nafter it is called; at most one more packet might be processed.\n.PP\nIf\n.B PCAP_ERROR_BREAK\nis returned from\n.BR pcap_dispatch ()\nor\n.BR pcap_loop (),\nthe flag is cleared, so a subsequent call will resume reading packets.\nIf a positive number is returned, the flag is not cleared, so a\nsubsequent call will return\n.B PCAP_ERROR_BREAK\nand clear the flag.\n.SH BACKWARD COMPATIBILITY\n.PP\nThis function became available in libpcap release 0.8.1.\n.PP\nIn releases prior to libpcap 1.10.0,\n.BR pcap_breakloop ()\nwill not wake up a blocked thread on any platform.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_can_set_rfmon.3pcap",
          "type": "blob",
          "size": 2.6708984375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_CAN_SET_RFMON 3PCAP \"31 July 2016\"\n.SH NAME\npcap_can_set_rfmon \\- check whether monitor mode can be set for a\nnot-yet-activated capture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_can_set_rfmon(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_can_set_rfmon ()\nchecks whether monitor mode could be set on a capture handle when\nthe handle is activated.\n.SH RETURN VALUE\n.BR pcap_can_set_rfmon ()\nreturns\n.B 0\nif monitor mode could not be set,\n.B 1\nif monitor mode could be set, and a negative value on error.\nA negative return value indicates what error condition occurred.\nThe possible error values are:\n.TP\n.B PCAP_ERROR_NO_SUCH_DEVICE\nThe capture source specified when the handle was created doesn't\nexist.\n.TP\n.B PCAP_ERROR_PERM_DENIED\nThe process doesn't have permission to check whether monitor mode\ncould be supported.\n.TP\n.B PCAP_ERROR_ACTIVATED\nThe capture handle has already been activated.\n.TP\n.B PCAP_ERROR\nAnother error occurred.\n.BR pcap_geterr (3PCAP)\nor\n.BR \\%pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display a message describing the error.\n.LP\nAdditional error codes may be added in the future; a program should\ncheck for\n.BR 0 ,\n.BR 1 ,\nand negative, return codes, and treat all negative\nreturn codes as errors.\n.BR pcap_statustostr (3PCAP)\ncan be called, with a warning or error code as an argument, to fetch a\nmessage describing the warning or error code.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP),\n.BR pcap_set_rfmon (3PCAP)\n"
        },
        {
          "name": "pcap_close.3pcap",
          "type": "blob",
          "size": 1.732421875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_CLOSE 3PCAP \"12 October 2024\"\n.SH NAME\npcap_close \\- close a capture device or savefile\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nvoid pcap_close(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_close ()\ncloses the files associated with\n.I p\nand deallocates resources. This means that, for example, if\n.I p\nrefers to a savefile that was opened with\n.BR pcap_fopen_offline ()\nor\n.BR pcap_fopen_offline_with_tstamp_precision (),\nthe stream provided to the routine will be closed unless it is\n.BR stdin .\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_open_offline (3PCAP)\n"
        },
        {
          "name": "pcap_compile.3pcap.in",
          "type": "blob",
          "size": 3.0341796875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_COMPILE 3PCAP \"25 November 2024\"\n.SH NAME\npcap_compile \\- compile a filter expression\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_compile(pcap_t *p, struct bpf_program *fp,\n    const char *str, int optimize, bpf_u_int32 netmask);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_compile ()\nis used to compile the string\n.I str\ninto a filter program.  See\n.BR \\%pcap-filter (@MAN_MISC_INFO@)\nfor the syntax of that string.\n.I fp\nis a pointer to a\n.I bpf_program\nstruct and is filled in by\n.BR pcap_compile ().\n.I optimize\ncontrols whether optimization on the resulting code is performed.\n.I netmask\nspecifies the IPv4 netmask of the network on which packets are being\ncaptured; it is used only when checking for IPv4 broadcast addresses in\nthe filter program.  If the netmask of the network on which packets are\nbeing captured isn't known to the program, or if packets are being\ncaptured on the Linux \"any\" pseudo-interface that can capture on more\nthan one network, a value of\n.B PCAP_NETMASK_UNKNOWN\ncan be supplied; tests\nfor IPv4 broadcast addresses will fail to compile, but all other tests in\nthe filter program will be OK.\n.SH RETURN VALUE\n.BR pcap_compile ()\nreturns\n.B 0\non success and\n.B PCAP_ERROR\non failure. If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH BACKWARD COMPATIBILITY\n.PP\nThe\n.B PCAP_NETMASK_UNKNOWN\nconstant became available in libpcap release 1.1.0.\n.PP\nIn libpcap 1.8.0 and later,\n.BR pcap_compile ()\ncan be used in multiple threads within a single process.  However, in\nearlier versions of libpcap, it is\n.I not\nsafe to use\n.BR pcap_compile ()\nin multiple threads in a single process without some form of mutual\nexclusion allowing only one thread to call it at any given time.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_setfilter (3PCAP),\n.BR pcap_freecode (3PCAP)\n"
        },
        {
          "name": "pcap_create.3pcap",
          "type": "blob",
          "size": 2.4033203125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_CREATE 3PCAP \"6 September 2024\"\n.SH NAME\npcap_create \\- create a live capture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\npcap_t *pcap_create(const char *source, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_create ()\nis used to create a packet capture handle to look\nat packets on the network.\n.I source\nis a string that specifies the network device to open; on all supported Linux\nsystems, as well as on recent versions of macOS and Solaris, a\n.I source\nargument of \"any\" or\n.B NULL\ncan be used to capture packets from all network interfaces.  The latter should\nnot be confused with all available capture devices as seen by\n.BR pcap_findalldevs (3PCAP),\nwhich may also include D-Bus, USB etc.\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.PP\nThe returned handle must be activated with\n.BR pcap_activate (3PCAP)\nbefore packets can be captured\nwith it; options for the capture, such as promiscuous mode, can be set\non the handle before activating it.\n.SH RETURN VALUE\n.BR pcap_create ()\nreturns a\n.B pcap_t *\non success and\n.B NULL\non failure.\nIf\n.B NULL\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_datalink.3pcap.in",
          "type": "blob",
          "size": 2.5283203125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DATALINK 3PCAP \"7 April 2014\"\n.SH NAME\npcap_datalink \\- get the link-layer header type\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_datalink(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_datalink ()\nreturns the link-layer header type for the live capture or ``savefile''\nspecified by\n.IR p .\n.PP\nIt must not be called on a pcap descriptor created by\n.BR \\%pcap_create (3PCAP)\nthat has not yet been activated by\n.BR \\%pcap_activate (3PCAP).\n.PP\n.I https://www.tcpdump.org/linktypes.html\nlists the values\n.BR pcap_datalink ()\ncan return and describes the packet formats that\ncorrespond to those values.\n.PP\nDo\n.B NOT\nassume that the packets for a given capture or ``savefile`` will have\nany given link-layer header type, such as\n.B DLT_EN10MB\nfor Ethernet.  For example, the \"any\" device on Linux will have a\nlink-layer header type of\n.B DLT_LINUX_SLL\nor\n.B DLT_LINUX_SLL2\neven if all devices on the system at the time the \"any\" device is opened\nhave some other data link type, such as\n.B DLT_EN10MB\nfor Ethernet.\n.SH RETURN VALUE\n.BR pcap_datalink ()\nreturns the link-layer header type on success and\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_datalink_val_to_name (3PCAP),\n.BR pcap_set_datalink (3PCAP),\n.BR pcap_list_datalinks (3PCAP),\n.BR pcap-linktype (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_datalink_name_to_val.3pcap",
          "type": "blob",
          "size": 1.8916015625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DATALINK_NAME_TO_VAL 3PCAP \"25 July 2018\"\n.SH NAME\npcap_datalink_name_to_val \\- get the link-layer header type value\ncorresponding to a header type name\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_datalink_name_to_val(const char *name);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_datalink_name_to_val ()\ntranslates a link-layer header type name, which is a\n.B DLT_\nname with the\n.B DLT_\nremoved, to the corresponding link-layer header type value.  The\ntranslation is case-insensitive.\n.SH RETURN VALUE\n.BR pcap_datalink_name_to_val ()\nreturns the type value on success and\n.B PCAP_ERROR\nif the name is not a known\ntype name.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_set_datalink (3PCAP),\n.BR pcap_datalink_val_to_name (3PCAP)\n"
        },
        {
          "name": "pcap_datalink_val_to_name.3pcap",
          "type": "blob",
          "size": 2.875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DATALINK_VAL_TO_NAME 3PCAP \"4 May 2022\"\n.SH NAME\npcap_datalink_val_to_name, pcap_datalink_val_to_description,\npcap_datalink_val_to_description_or_dlt \\- get a\nname or description for a link-layer header type value\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap.h>\n.ft\n.LP\n.ft B\nconst char *pcap_datalink_val_to_name(int dlt);\nconst char *pcap_datalink_val_to_description(int dlt);\nconst char *pcap_datalink_val_to_description_or_dlt(int dlt);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_datalink_val_to_name ()\ntranslates a link-layer header type value to the corresponding\nlink-layer header type name, which is the\n.B DLT_\nname for the link-layer header type value with the\n.B DLT_\nremoved.\n.B NULL\nis returned if the type value does not correspond to a known\n.B DLT_\nvalue.\n.PP\n.BR pcap_datalink_val_to_description ()\ntranslates a link-layer header type value to a short description of that\nlink-layer header type.\n.B NULL\nis returned if the type value does not correspond to a known\n.B DLT_\nvalue.\n.PP\n.BR pcap_datalink_val_to_description_or_dlt ()\ntranslates a link-layer header type value to a short description of that\nlink-layer header type just like\n.BR pcap_datalink_val_to_description ().\nIf the type value does not correspond to a known\n.B DLT_\nvalue, the string \"DLT n\" is returned, where n is the value of\nthe dlt argument.\n.SH BACKWARD COMPATIBILITY\nThe\n.BR pcap_datalink_val_to_description_or_dlt ()\nfunction first became available in libpcap release 1.9.1.  In previous\nreleases,\n.BR pcap_datalink_val_to_description ()\nwould have to be called and, if it returned\n.BR NULL ,\na default string would have to be constructed.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_datalink (3PCAP),\n.BR pcap_list_datalinks (3PCAP),\n.BR pcap_datalink_name_to_val (3PCAP)\n"
        },
        {
          "name": "pcap_dump.3pcap",
          "type": "blob",
          "size": 1.7314453125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP 3PCAP \"8 March 2015\"\n.SH NAME\npcap_dump \\- write a packet to a capture file\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nvoid pcap_dump(u_char *user, struct pcap_pkthdr *h,\n    u_char *sp);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump ()\noutputs a packet to the ``savefile'' opened with\n.BR pcap_dump_open (3PCAP).\nNote that its calling arguments are suitable for use with\n.BR pcap_dispatch (3PCAP)\nor\n.BR pcap_loop (3PCAP).\nIf called directly, the\n.I user\nparameter is of type\n.B pcap_dumper_t\nas returned by\n.BR pcap_dump_open ().\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_dump_close.3pcap",
          "type": "blob",
          "size": 1.7333984375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP_CLOSE 3PCAP \"12 October 2024\"\n.SH NAME\npcap_dump_close \\- close a savefile being written to\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nvoid pcap_dump_close(pcap_dumper_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump_close ()\ncloses the ``savefile'' associated with\n.I p\nand deallocates resources. This means that, for example, if\n.I p\nrefers to a savefile that was opened with\n.BR pcap_dump_fopen (),\nthe stream provided to that routine will be closed unless it is\n.BR stdout .\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_dump_open (3PCAP),\n.BR pcap_dump (3PCAP)\n"
        },
        {
          "name": "pcap_dump_file.3pcap",
          "type": "blob",
          "size": 1.54296875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP_FILE 3PCAP \"3 January 2014\"\n.SH NAME\npcap_dump_file \\- get the standard I/O stream for a savefile being written\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nFILE *pcap_dump_file(pcap_dumper_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump_file ()\nreturns the standard I/O stream of the ``savefile'' opened by\n.BR pcap_dump_open (3PCAP).\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_dump_flush.3pcap",
          "type": "blob",
          "size": 1.7080078125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP_FLUSH 3PCAP \"25 July 2018\"\n.SH NAME\npcap_dump_flush \\- flush to a savefile packets dumped\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_dump_flush(pcap_dumper_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump_flush ()\nflushes the output buffer to the ``savefile'', so that any packets\nwritten with\n.BR pcap_dump (3PCAP)\nbut not yet written to the ``savefile'' will be written.\n.SH RETURN VALUE\n.BR pcap_dump_flush ()\nreturns\n.B 0\non success and\n.B PCAP_ERROR\non failure.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_dump_open (3PCAP)\n"
        },
        {
          "name": "pcap_dump_ftell.3pcap",
          "type": "blob",
          "size": 2.3359375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP_FTELL 3PCAP \"25 July 2018\"\n.SH NAME\npcap_dump_ftell, pcap_dump_ftell64 \\- get the current file offset for a savefile being written\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nlong pcap_dump_ftell(pcap_dumper_t *p);\n.ft B\nint64_t pcap_dump_ftell64(pcap_dumper_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump_ftell ()\nreturns the current file position for the ``savefile'', representing the\nnumber of bytes written by\n.BR pcap_dump_open (3PCAP)\nand\n.BR pcap_dump (3PCAP).\n.B PCAP_ERROR\nis returned on error. If the current file position does not fit in a\n.BR long ,\nit will be truncated; this can happen on 32-bit UNIX-like systems with\nlarge file support and on Windows.\n.BR pcap_dump_ftell64 ()\nreturns the current file position in a\n.BR int64_t ,\nso if file offsets that don't fit in a\n.B long\nbut that fit in a\n.B int64_t\nare supported, this will return the file offset without truncation.\n.B PCAP_ERROR\nis returned on error.\n.SH BACKWARD COMPATIBILITY\nThe function\n.BR pcap_dump_ftell64 ()\nbecame available in libpcap release 1.9.0.  In previous releases, there\nwas no mechanism to obtain a file offset that is too large to fit in a\n.BR long .\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_dump_open.3pcap.in",
          "type": "blob",
          "size": 3.56640625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_DUMP_OPEN 3PCAP \"3 July 2020\"\n.SH NAME\npcap_dump_open, pcap_dump_open_append, pcap_dump_fopen \\- open a file to\nwhich to write packets\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.nf\n.LP\n.ft B\npcap_dumper_t *pcap_dump_open(pcap_t *p, const char *fname);\npcap_dumper_t *pcap_dump_open_append(pcap_t *p, const char *fname);\npcap_dumper_t *pcap_dump_fopen(pcap_t *p, FILE *fp);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_dump_open ()\nis called to open a ``savefile'' for writing.\n.I fname\nspecifies the name of the file to open. The file will have\nthe same format as those used by\n.BR tcpdump (1)\nand\n.BR tcpslice (1).\nIf the file does not exist, it will be created; if the file exists, it\nwill be truncated and overwritten.\nThe name \"-\" is a synonym\nfor\n.BR stdout .\n.PP\n.BR pcap_dump_fopen ()\nis called to write data to an existing open stream\n.IR fp ;\nthis stream will be closed by a subsequent call to\n.BR pcap_dump_close (3PCAP).\nThe stream is assumed to be at the beginning of a file that has been\nnewly created or truncated, so that writes will start at the beginning\nof the file.\nNote that on Windows, that stream should be opened in binary mode.\n.PP\n.I p\nis a capture or ``savefile'' handle returned by an earlier call to\n.BR pcap_create (3PCAP)\nand activated by an earlier call to\n.BR \\%pcap_activate (3PCAP),\nor returned by an earlier call to\n.BR \\%pcap_open_offline (3PCAP),\n.BR pcap_open_live (3PCAP),\nor\n.BR pcap_open_dead (3PCAP).\nThe time stamp precision, link-layer type, and snapshot length from\n.I p\nare used as the link-layer type and snapshot length of the output file.\n.PP\n.BR pcap_dump_open_append ()\nis like\n.BR pcap_dump_open ()\nbut, if the file already exists, and is a pcap file with the same byte\norder as the host opening the file, and has the same time stamp\nprecision, link-layer header type, and snapshot length as\n.IR p ,\nit will write new packets at the end of the file.\n.SH RETURN VALUE\nA pointer to a\n.B pcap_dumper_t\nstructure to use in subsequent\n.BR pcap_dump (3PCAP)\nand\n.BR pcap_dump_close (3PCAP)\ncalls is returned on success.\n.B NULL\nis returned on failure.\nIf\n.B NULL\nis returned,\n.BR pcap_geterr (3PCAP)\ncan be used to get the error text.\n.SH BACKWARD COMPATIBILITY\n.PP\nThe\n.BR pcap_dump_open_append ()\nfunction became available in libpcap release 1.7.2.  In previous\nreleases, there is no support for appending packets to an existing\nsavefile.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR \\%pcap-savefile (@MAN_FILE_FORMATS@)\n"
        },
        {
          "name": "pcap_file.3pcap",
          "type": "blob",
          "size": 2.0732421875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_FILE 3PCAP \"3 January 2014\"\n.SH NAME\npcap_file \\- get the standard I/O stream for a savefile being read\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nFILE *pcap_file(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_file ()\nreturns the standard I/O stream of the ``savefile'', if a ``savefile''\nwas opened with\n.BR pcap_open_offline (3PCAP),\nor\n.BR NULL ,\nif a network device was opened with\n.BR pcap_create (3PCAP)\nand\n.BR \\%pcap_activate (3PCAP),\nor with\n.BR pcap_open_live (3PCAP).\n.PP\nNote that the Packet Capture library is usually built with large file\nsupport, so the standard I/O stream of the ``savefile'' might refer to\na file larger than 2 gigabytes; applications that use\n.BR pcap_file ()\nshould, if possible, use calls that support large files on the return\nvalue of\n.BR pcap_file ()\nor the value returned by\n.BR fileno (3)\nwhen passed the return value of\n.BR pcap_file ().\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_fileno.3pcap",
          "type": "blob",
          "size": 2.0068359375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_FILENO 3PCAP \"25 July 2018\"\n.SH NAME\npcap_fileno \\- get the file descriptor for a live capture\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_fileno(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\nIf\n.I p\nrefers to a network device that was opened for a live capture using\na combination of\n.BR pcap_create (3PCAP)\nand\n.BR pcap_activate (3PCAP),\nor using\n.BR pcap_open_live (3PCAP),\n.BR pcap_fileno ()\nreturns the file descriptor from which captured packets are read.\n.LP\nIf\n.I p\nrefers to a ``savefile'' that was opened using functions such as\n.BR pcap_open_offline (3PCAP)\nor\n.BR pcap_fopen_offline (3PCAP),\na ``dead''\n.B pcap_t\nopened using\n.BR pcap_open_dead (3PCAP),\nor a\n.B pcap_t\nthat was created with\n.BR pcap_create ()\nbut that has not yet been activated with\n.BR pcap_activate (),\nit returns\n.BR PCAP_ERROR .\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_findalldevs.3pcap",
          "type": "blob",
          "size": 6.802734375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_FINDALLDEVS 3PCAP \"9 August 2024\"\n.SH NAME\npcap_findalldevs, pcap_freealldevs \\- get a list of capture devices, and\nfree that list\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\nint pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf);\nvoid pcap_freealldevs(pcap_if_t *alldevs);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_findalldevs ()\nconstructs a list of network devices that can be opened with\n.BR pcap_create (3PCAP)\nand\n.BR pcap_activate (3PCAP)\nor with\n.BR pcap_open_live (3PCAP).\n(Note that there may be network devices that cannot be opened by the\nprocess calling\n.BR pcap_findalldevs (),\nbecause, for example, that process does not have sufficient privileges\nto open them for capturing; if so, those devices will not appear on the\nlist.)\n.I alldevsp\nis a pointer to a\n.BR \"pcap_if_t *\" ;\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.PP\nIf\n.BR pcap_findalldevs ()\nsucceeds, the pointer pointed to by\n.I alldevsp\nis set to point to the first element of the list, or to\n.B NULL\nif no devices were found (this is considered success).\nEach element of the list is of type\n.BR pcap_if_t ,\nand has the following members:\n.RS\n.TP\n.B next\nif not\n.BR NULL ,\na pointer to the next element in the list;\n.B NULL\nfor the last element of the list\n.TP\n.B name\na pointer to a string giving a name for the device to pass to\n.BR pcap_open_live ()\n.TP\n.B description\nif not\n.BR NULL ,\na pointer to a string giving a human-readable description of the device\n.TP\n.B addresses\na pointer to the first element of a list of network addresses for the\ndevice,\nor\n.B NULL\nif the device has no addresses\n.TP\n.B flags\ndevice flags:\n.RS\n.TP\n.B PCAP_IF_LOOPBACK\nset if the device is a loopback interface\n.TP\n.B PCAP_IF_UP\nset if the device is up\n.TP\n.B PCAP_IF_RUNNING\nset if the device is running\n.TP\n.B PCAP_IF_WIRELESS\nset if the device is a wireless interface; this includes IrDA as well as\nradio-based networks such as IEEE 802.15.4 and IEEE 802.11, so it\ndoesn't just mean Wi-Fi\n.TP\n.B PCAP_IF_CONNECTION_STATUS\na bitmask for an indication of whether the adapter is connected or not;\nfor wireless interfaces, \"connected\" means \"associated with a network\"\n.TP\nThe possible values for the connection status bits are:\n.TP\n.B PCAP_IF_CONNECTION_STATUS_UNKNOWN\nit's unknown whether the adapter is connected or not\n.TP\n.B PCAP_IF_CONNECTION_STATUS_CONNECTED\nthe adapter is connected\n.TP\n.B PCAP_IF_CONNECTION_STATUS_DISCONNECTED\nthe adapter is disconnected\n.TP\n.B PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE\nthe notion of \"connected\" and \"disconnected\" don't apply to this\ninterface; for example, it doesn't apply to a loopback device\n.RE\n.RE\n.PP\nEach element of the list of addresses is of type\n.BR pcap_addr_t ,\nand has the following members:\n.RS\n.TP\n.B next\nif not\n.BR NULL ,\na pointer to the next element in the list;\n.B NULL\nfor the last element of the list\n.TP\n.B addr\na pointer to a\n.B \"struct sockaddr\"\ncontaining an address\n.TP\n.B netmask\nif not\n.BR NULL ,\na pointer to a\n.B \"struct sockaddr\"\nthat contains the netmask corresponding to the address pointed to by\n.B addr\n.TP\n.B broadaddr\nif not\n.BR NULL ,\na pointer to a\n.B \"struct sockaddr\"\nthat contains the broadcast address corresponding to the address pointed\nto by\n.BR addr ;\nmay be\n.B NULL\nif the device doesn't support broadcasts\n.TP\n.B dstaddr\nif not\n.BR NULL ,\na pointer to a\n.B \"struct sockaddr\"\nthat contains the destination address corresponding to the address pointed\nto by\n.BR addr ;\nmay be\n.B NULL\nif the device isn't a point-to-point interface\n.RE\n.PP\nNote that the addresses in the list of addresses might be IPv4\naddresses, IPv6 addresses, or some other type of addresses, so you must\ncheck the\n.B sa_family\nmember of the\n.B \"struct sockaddr\"\nbefore interpreting the contents of the address; do not assume that the\naddresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses.\nIPv4 addresses have the value\n.BR AF_INET ,\nIPv6 addresses have the value\n.B AF_INET6\n(which older operating systems that don't support IPv6 might not\ndefine), and other addresses have other values.  Whether other addresses\nare returned, and what types they might have is platform-dependent.\nNamely, link-layer addresses, such as Ethernet MAC addresses, have the value\n.B AF_PACKET\n(on Linux) or\n.B AF_LINK\n(on AIX, FreeBSD, Haiku, illumos, macOS, NetBSD and OpenBSD) or are not\nreturned at all (on GNU/Hurd and Solaris).\n.PP\nFor IPv4 addresses, the\n.B \"struct sockaddr\"\npointer can be interpreted as if it pointed to a\n.BR \"struct sockaddr_in\" ;\nfor IPv6 addresses, it can be interpreted as if it pointed to a\n.BR \"struct sockaddr_in6\".\nFor link-layer addresses, it can be interpreted as if it pointed to a\n.B \"struct sockaddr_ll\"\n(for\n.BR AF_PACKET ,\nsee\n.BR packet (7))\nor a\n.B \"struct sockaddr_dl\"\n(for\n.BR AF_LINK ).\n.PP\nThe list of devices must be freed with\n.BR pcap_freealldevs (),\nwhich frees the list pointed to by\n.IR alldevs .\n.SH RETURN VALUE\n.BR pcap_findalldevs ()\nreturns\n.B 0\non success and\n.B PCAP_ERROR\non failure; as indicated, finding no\ndevices is considered success, rather than failure, so\n.B 0\nwill be\nreturned in that case. If\n.B PCAP_ERROR\nis returned,\n.I errbuf\nis filled in with an appropriate error message,\nand the pointer pointed to by\n.I alldevsp\nis set to\n.BR NULL .\n.SH BACKWARD COMPATIBILITY\n.PP\nThe\n.B PCAP_IF_UP\nand\n.B PCAP_IF_RUNNING\nconstants became available in libpcap release 1.6.1.\n.PP\nThe\n.BR PCAP_IF_WIRELESS ,\n.BR PCAP_IF_CONNECTION_STATUS ,\n.BR PCAP_IF_CONNECTION_STATUS_UNKNOWN ,\n.BR PCAP_IF_CONNECTION_STATUS_CONNECTED ,\n.BR PCAP_IF_CONNECTION_STATUS_DISCONNECTED ,\nand\n.B PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE\nconstants became available in libpcap release 1.9.0.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_freecode.3pcap",
          "type": "blob",
          "size": 1.681640625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_FREECODE 3PCAP \"3 January 2014\"\n.SH NAME\npcap_freecode \\- free a BPF program\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nvoid pcap_freecode(struct bpf_program *);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_freecode ()\nis used to free up allocated memory pointed to by a\n.I bpf_program\nstruct generated by\n.BR pcap_compile (3PCAP)\nwhen that BPF program is no longer needed, for example after it\nhas been made the filter program for a pcap structure by a call to\n.BR pcap_setfilter (3PCAP).\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_get_required_select_timeout.3pcap",
          "type": "blob",
          "size": 4.90234375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_GET_REQUIRED_SELECT_TIMEOUT 3PCAP \"29 January 2020\"\n.SH NAME\npcap_get_required_select_timeout \\- get a timeout to be used when doing\nselect() for a live capture\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nconst struct timeval *pcap_get_required_select_timeout(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_get_required_select_timeout ()\nreturns, on UNIX, a pointer to a\n.B struct timeval\ncontaining a value that must be used as the minimum timeout in\n.BR select (2),\n.BR poll (2),\n.BR epoll_wait (2),\nand\n.BR kevent (2)\ncalls, or\n.B NULL\nif there is no such timeout.\nIf a\n.RB non- NULL\nvalue is returned, it must be used regardless of whether\n.BR pcap_get_selectable_fd (3PCAP)\nreturns\n.B \\-1\nfor any descriptor on which those calls are being done.\n.BR pcap_get_required_select_timeout ()\nshould be called for all\n.BR pcap_t s\nbefore a call to\n.BR select (),\n.BR poll (),\n.BR epoll_wait (),\nor\n.BR kevent (),\nand any timeouts used for those calls should be updated as appropriate\ngiven the new value of the timeout.\n.PP\nFor\n.BR kevent (),\none\n.B EVFILT_TIMER\nfilter per selectable descriptor can be used, rather than using the\ntimeout argument to\n.BR kevent ();\nif the\n.B EVFILT_TIMER\nevent for a particular selectable descriptor signals an event,\n.BR pcap_dispatch (3PCAP)\nshould be called for the corresponding\n.BR pcap_t .\n.PP\nOn Linux systems with\n.BR timerfd_create (2),\none timer object created by\n.BR timerfd_create ()\nper selectable descriptor can be used, rather than using the timeout\nargument to\n.BR epoll_wait ();\nif the\ntimer object for a particular selectable descriptor signals an event,\n.BR pcap_dispatch (3PCAP)\nshould be called for the corresponding\n.BR pcap_t .\n.PP\nOtherwise, a timeout value no larger than\nthe smallest of all timeouts returned by\n.BR \\%pcap_get_required_select_timeout ()\nfor devices from which packets will be captured and any other timeouts\nto be used in the call should be used as the timeout for the call, and,\nwhen the call returns,\n.BR pcap_dispatch (3PCAP)\nshould be called for all\n.BR pcap_t s\nfor which a\n.RB non- NULL\ntimeout was returned, regardless of whether it's indicated as having\nanything to read from it or not.\n.PP\nAll devices with a\n.RB non- NULL\ntimeout must be put in non-blocking mode with\n.BR pcap_setnonblock (3PCAP).\n.PP\nNote that a device on which a read can be done without blocking may,\non some platforms, not have any packets to read if the packet buffer\ntimeout has expired.  A call to\n.BR pcap_dispatch ()\nor\n.BR pcap_next_ex (3PCAP)\nwill return\n.B 0\nin this case, but will not block.\n.PP\n.BR pcap_get_required_select_timeout ()\nis not available on Windows.\n.SH RETURN VALUE\nA pointer to a\n.B struct timeval\nis returned if the timeout is required; otherwise\n.B NULL\nis returned.\n.SH BACKWARD COMPATIBILITY\nThis function became available in libpcap release 1.9.0.  In previous\nreleases,\n.BR select (),\n.BR poll (),\n.BR epoll_wait (),\nand\n.BR kevent ()\ncould not be used for devices that don't provide a selectable file\ndescriptor (in other words, on any capture source for that\n.BR pcap_get_selectable_fd ()\nreturns\n.BR \\-1 ).\n.PP\nIn libpcap release 1.10.0 and later, the timeout value can change from\ncall to call, so\n.BR pcap_get_required_select_timeout ()\nmust be called before each call to\n.BR select (),\n.BR poll (),\n.BR epoll_wait (),\nor\n.BR kevent (),\nand the new value must be used to calculate timeouts for the call.  Code\nthat does that will also work with libpcap 1.9.x releases, so code\nusing\n.BR pcap_get_required_select_timeout ()\nshould be changed to call it for each call to\n.BR select (),\n.BR poll (),\n.BR epoll_wait (),\nor\n.BR kevent ()\neven if the code must also work with libpcap 1.9.x.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_get_selectable_fd (3PCAP),\n.BR select (2),\n.BR poll (2),\n.BR epoll_wait (2),\n.BR kqueue (2)\n"
        },
        {
          "name": "pcap_get_selectable_fd.3pcap",
          "type": "blob",
          "size": 4.677734375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_GET_SELECTABLE_FD 3PCAP \"29 January 2020\"\n.SH NAME\npcap_get_selectable_fd \\- get a file descriptor on which a select() can\nbe done for a live capture\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_get_selectable_fd(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_get_selectable_fd ()\nreturns, on UNIX, a file descriptor number for a file descriptor on\nwhich one can\ndo a\n.BR select (2),\n.BR poll (2),\n.BR epoll_wait (2),\n.BR kevent (2),\nor other such call\nto wait for it to be possible to read packets without blocking, if such\na descriptor exists, or\n.BR \\-1 ,\nif no such descriptor exists.\n.PP\nSome network devices opened with\n.BR pcap_create (3PCAP)\nand\n.BR pcap_activate (3PCAP),\nor with\n.BR pcap_open_live (3PCAP),\ndo not support those calls (for example, regular network devices on\nFreeBSD 4.3 and 4.4, and Endace DAG devices), so\n.B \\-1\nis returned for\nthose devices.  In that case, those calls must be given a timeout less\nthan or equal to the timeout returned by\n.BR pcap_get_required_select_timeout (3PCAP)\nfor the device for which\n.BR pcap_get_selectable_fd ()\nreturned\n.BR \\-1 ,\nthe device must be put in non-blocking mode with a call to\n.BR \\%pcap_setnonblock (3PCAP),\nand an attempt must always be made to read packets from the device\nwhen the call returns.  If\n.BR \\%pcap_get_required_select_timeout ()\nreturns\n.BR NULL ,\nit is not possible to wait for packets to arrive on the device in an\nevent loop.\n.PP\nNote that a device on which a read can be done without blocking may,\non some platforms, not have any packets to read if the packet buffer\ntimeout has expired.  A call to\n.BR pcap_dispatch (3PCAP)\nor\n.BR pcap_next_ex (3PCAP)\nwill return 0 in this case, but will not block.\n.PP\nNote that in:\n.IP\nFreeBSD prior to FreeBSD 4.6;\n.IP\nNetBSD prior to NetBSD 3.0;\n.IP\nOpenBSD prior to OpenBSD 2.4;\n.IP\nMac OS X prior to Mac OS X 10.7;\n.PP\n.BR select (),\n.BR poll (),\nand\n.BR kevent ()\ndo not work correctly on BPF devices;\n.BR pcap_get_selectable_fd ()\nwill return a file descriptor on most of those versions (the exceptions\nbeing FreeBSD 4.3 and 4.4), but a simple\n.BR select (),\n.BR poll (),\nor\n.BR kevent ()\ncall will not indicate that the descriptor is readable until a full\nbuffer's worth of packets is received, even if the packet timeout\nexpires before then.  To work around this, code that uses\nthose calls to wait for packets to arrive must put the\n.B pcap_t\nin non-blocking mode, and must arrange that the call\nhave a timeout less than or equal to the packet buffer timeout,\nand must try to read packets after that timeout expires, regardless of\nwhether the call indicated that the file descriptor for the\n.B pcap_t\nis ready to be read or not.  (That workaround will not work in FreeBSD\n4.3 and later; however, in FreeBSD 4.6 and later, those calls\nwork correctly on BPF devices, so the workaround isn't necessary,\nalthough it does no harm.)\n.PP\nNote also that\n.BR poll ()\nand\n.BR kevent ()\ndoesn't work on character special files, including BPF devices, in Mac\nOS X 10.4 and 10.5, so, while\n.BR select ()\ncan be used on the descriptor returned by\n.BR pcap_get_selectable_fd (),\n.BR poll ()\nand\n.BR kevent ()\ncannot be used on it those versions of Mac OS X.\n.BR poll (),\nbut not\n.BR kevent (),\nworks on that descriptor in Mac OS X releases prior to\n10.4;\n.BR poll ()\nand\n.BR kevent ()\nwork on that descriptor in Mac OS X 10.6 and later.\n.PP\n.BR pcap_get_selectable_fd ()\nis not available on Windows.\n.SH RETURN VALUE\nA selectable file descriptor is returned if one exists; otherwise,\n.B \\-1\nis returned.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR kqueue (2)\n"
        },
        {
          "name": "pcap_get_tstamp_precision.3pcap.in",
          "type": "blob",
          "size": 1.8515625,
          "content": ".\\\"Copyright (c) 2013, Michal Sekletar\n.\\\"All rights reserved.\n.\\\"\n.\\\"Redistribution and use in source and binary forms, with or without\n.\\\"modification, are permitted provided that the following conditions\n.\\\"are met:\n.\\\"\n.\\\"  1. Redistributions of source code must retain the above copyright\n.\\\"     notice, this list of conditions and the following disclaimer.\n.\\\"  2. Redistributions in binary form must reproduce the above copyright\n.\\\"     notice, this list of conditions and the following disclaimer in\n.\\\"     the documentation and/or other materials provided with the\n.\\\"     distribution.\n.\\\"  3. The names of the authors may not be used to endorse or promote\n.\\\"     products derived from this software without specific prior\n.\\\"     written permission.\n.\\\"\n.\\\"THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n.\\\"IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n.\\\"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n\n.TH PCAP_GET_TSTAMP_PRECISION 3PCAP \"23 August 2018\"\n.SH NAME\npcap_get_tstamp_precision \\- get the time stamp precision returned in\ncaptures\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_get_tstamp_precision(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_get_tstamp_precision ()\nreturns the precision of the time stamp returned in packet captures on the pcap\ndescriptor.\n.SH RETURN VALUE\n.BR pcap_get_tstamp_precision ()\nreturns\n.B PCAP_TSTAMP_PRECISION_MICRO\nor\n.BR PCAP_TSTAMP_PRECISION_NANO ,\nwhich indicates\nthat pcap captures contains time stamps in microseconds or nanoseconds\nrespectively.\n.SH BACKWARD COMPATIBILITY\nThis function became available in libpcap release 1.5.1.  In previous\nreleases, time stamps from a capture device or savefile are always given\nin seconds and microseconds.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_set_tstamp_precision (3PCAP),\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_geterr.3pcap",
          "type": "blob",
          "size": 1.87109375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_GETERR 3PCAP \"15 January 2016\"\n.SH NAME\npcap_geterr, pcap_perror \\- get or print libpcap error message text\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nchar *pcap_geterr(pcap_t *p);\nvoid pcap_perror(pcap_t *p, const char *prefix);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_geterr ()\nreturns the error text pertaining to the last pcap library error.\n.BR NOTE :\nthe pointer it returns will no longer point to a valid error message\nstring after the\n.B pcap_t\npassed to it is closed; you must use or copy the string before closing\nthe\n.BR pcap_t .\n.PP\n.BR pcap_perror ()\nprints the text of the last pcap library error on\n.BR stderr ,\nprefixed by\n.IR prefix .\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_strerror (3PCAP)\n"
        },
        {
          "name": "pcap_init.3pcap",
          "type": "blob",
          "size": 3.0595703125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_INIT 3PCAP \"18 September 2024\"\n.SH NAME\npcap_init \\- initialize the library\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\nint pcap_init(unsigned int opts, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_init ()\nis used to initialize the Packet Capture library.\n.I opts\nspecifies options for the library;\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.PP\nCurrently, the options that can be specified in\n.I opts\nare:\n.TP\n.B PCAP_MMAP_32BIT\nMap packet buffers with 32-bit addresses.\n.TP\n.B PCAP_CHAR_ENC_LOCAL\nTreat all strings supplied as arguments, and return all strings to the\ncaller, as being in the local character encoding.\n.TP\n.B PCAP_CHAR_ENC_UTF_8\nTreat all strings supplied as arguments, and return all strings to the\ncaller, as being in UTF-8.\n.PP\nOn UNIX-like systems, the local character encoding is assumed to be\nUTF-8, so no character encoding transformations are done.\n.PP\nOn Windows, the local character encoding is the local ANSI code page.\n.PP\nIf\n.BR pcap_init ()\nis not called, strings are treated as being in the local ANSI code page\non Windows,\n.BR pcap_lookupdev (3PCAP)\nwill succeed if there is a device on which to capture, and\n.BR pcap_create (3PCAP)\nmakes an attempt to check whether the string passed as an argument is a\nUTF-16LE string - note that this attempt is unsafe, as it may run past\nthe end of the string - to handle\n.BR pcap_lookupdev ()\nreturning a UTF-16LE string.\n.SH RETURN VALUE\n.BR pcap_init ()\nreturns\n.B 0\non success and\n.B PCAP_ERROR\non failure.\nIf\n.B PCAP_ERROR\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.SH BACKWARD COMPATIBILITY\nThis function became available in libpcap release 1.9.0.  In previous\nreleases, on Windows, all strings supplied as arguments, and all strings\nreturned to the caller, are in the local character encoding.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_inject.3pcap",
          "type": "blob",
          "size": 3.666015625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_INJECT 3PCAP \"23 November 2024\"\n.SH NAME\npcap_inject, pcap_sendpacket \\- transmit a packet\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_inject(pcap_t *p, const void *buf, size_t size);\nint pcap_sendpacket(pcap_t *p, const u_char *buf, int size);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_inject ()\nsends a raw packet through the network interface;\n.I buf\npoints to the data of the packet, including the link-layer header, and\n.I size\nis the number of bytes in the packet.\n.PP\nNote that, even if you successfully open the network interface, you\nmight not have permission to send packets on it, or it might not support\nsending packets; as\n.BR pcap_open_live (3PCAP)\ndoesn't have a flag to indicate whether to open for capturing, sending,\nor capturing and sending, you cannot request an open that supports\nsending and be notified at open time whether sending will be possible.\nThe same limitation applies to\n.BR \\%pcap_create (3PCAP)\nand\n.BR \\%pcap_activate (3PCAP).\nNote also that some devices might not support sending packets.\n.PP\nNote that, on some platforms, the link-layer header of the packet that's\nsent might not be the same as the link-layer header of the packet\nsupplied to\n.BR pcap_inject (),\nas the source link-layer address, if the header contains such an\naddress, might be changed to be the address assigned to the interface on\nwhich the packet it sent, if the platform doesn't support sending\ncompletely raw and unchanged packets.  Even worse, some drivers on some\nplatforms might change the link-layer type field to whatever value\nlibpcap used when attaching to the device, even on platforms that\n.I do\nnominally support sending completely raw and unchanged packets.\n.PP\n.BR pcap_sendpacket ()\nis like\n.BR pcap_inject (),\nbut it returns\n.B 0\non success, rather than returning the number of bytes\nwritten.\n.RB ( pcap_inject ()\ncomes from OpenBSD;\n.BR pcap_sendpacket ()\ncomes from WinPcap/Npcap.  Both are provided for compatibility.)\n.SH RETURN VALUE\n.BR pcap_inject ()\nreturns the number of bytes written on success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated, and\n.B PCAP_ERROR\non other errors.\n.PP\n.BR pcap_sendpacket ()\nreturns\n.B 0\non success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated, and\n.B PCAP_ERROR\non other errors.\n.PP\nIf\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_is_swapped.3pcap",
          "type": "blob",
          "size": 1.947265625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_IS_SWAPPED 3PCAP \"7 April 2014\"\n.SH NAME\npcap_is_swapped \\- find out whether a savefile has the native byte order\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_is_swapped(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_is_swapped ()\nreturns true (\\fB1\\fP) if\n.I p\nrefers to a ``savefile'' that uses a different byte order\nthan the current system.  For a live capture, it always returns false\n(\\fB0\\fP).\n.PP\nIt must not be called on a pcap descriptor created by\n.BR \\%pcap_create (3PCAP)\nthat has not yet been activated by\n.BR \\%pcap_activate (3PCAP).\n.SH RETURN VALUE\n.BR pcap_is_swapped ()\nreturns true (\\fB1\\fP) or false (\\fB0\\fP) on success and\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_lib_version.3pcap",
          "type": "blob",
          "size": 2.3203125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LIB_VERSION 3PCAP \"22 December 2024\"\n.SH NAME\npcap_lib_version \\- get the version information for libpcap\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nconst char *pcap_lib_version(void);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_lib_version ()\nreturns a pointer to a string giving information about the version of\nthe libpcap library being used.  The string begins with the words \"libpcap\nversion\".  Then follows the version, which consists of three dot-separated\nnumbers and the optional \"-PRE-GIT\" suffix to indicate a development\nsnapshot, same as in the output of\n.B \"pcap-config --version\"\nin sufficiently recent libpcap releases.  After the version often follows\nadditional text to indicate particular features.  For example:\n.IP \"an old release, on any OS\"\n.RS\n.nf\n.B\nlibpcap version 1.5.3\n.fi\n.RE\n.IP \"a newer release on a Linux host\"\n.RS\n.nf\n.B\nlibpcap version 1.10.4 (with TPACKET_V3)\n.fi\n.RE\n.IP \"the same, built with DAG support only\"\n.RS\n.nf\n.B\nlibpcap version 1.10.4 (DAG-only)\n.fi\n.RE\n.IP \"a development snapshot on a FreeBSD host\"\n.RS\n.nf\n.B\nlibpcap version 1.11.0-PRE-GIT (with zerocopy support)\n.fi\n.RE\n.SH SEE ALSO\n.BR pcap\\-config (1),\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_list_datalinks.3pcap.in",
          "type": "blob",
          "size": 2.62109375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LIST_DATALINKS 3PCAP \"25 July 2018\"\n.SH NAME\npcap_list_datalinks, pcap_free_datalinks \\- get a list of link-layer header\ntypes supported by a capture device, and free that list\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_list_datalinks(pcap_t *p, int **dlt_buf);\nvoid pcap_free_datalinks(int *dlt_list);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_list_datalinks ()\nis used to get a list of the supported link-layer header types of the\ninterface associated with the pcap descriptor.\n.BR pcap_list_datalinks ()\nallocates an array to hold the list and sets\n.IR *dlt_buf\nto point to that array.\n.LP\nThe caller is responsible for freeing the array with\n.BR pcap_free_datalinks (),\nwhich frees the list of link-layer header types pointed to by\n.IR dlt_list .\n.LP\nIt must not be called on a pcap descriptor created by\n.BR \\%pcap_create (3PCAP)\nthat has not yet been activated by\n.BR \\%pcap_activate (3PCAP).\n.SH RETURN VALUE\n.BR pcap_list_datalinks ()\nreturns the number of link-layer header types in the array on success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nand\n.B PCAP_ERROR\non other errors.\nIf\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR \\%pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_datalink_val_to_name (3PCAP),\n.BR pcap_datalink (3PCAP),\n.BR pcap_set_datalink (3PCAP),\n.BR pcap-linktype (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_list_tstamp_types.3pcap.in",
          "type": "blob",
          "size": 3.0439453125,
          "content": ".\\\"\n.\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LIST_TSTAMP_TYPES 3PCAP \"8 September 2019\"\n.SH NAME\npcap_list_tstamp_types, pcap_free_tstamp_types \\- get a list of time\nstamp types supported by a capture device, and free that list\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp);\nvoid pcap_free_tstamp_types(int *tstamp_types);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_list_tstamp_types ()\nis used to get a list of the supported time stamp types of the interface\nassociated with the pcap descriptor.\n.BR pcap_list_tstamp_types ()\nallocates an array to hold the list and sets\n.I *tstamp_typesp\nto point to the array.\nSee\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\nfor a list of all the time stamp types.\n.PP\nThe caller is responsible for freeing the array with\n.BR pcap_free_tstamp_types (),\nwhich frees the list pointed to by\n.IR tstamp_types .\n.SH RETURN VALUE\n.BR pcap_list_tstamp_types ()\nreturns the number of time stamp types in the array on success and\n.B PCAP_ERROR\non failure.\nA return value of one means that the only time stamp type supported is\nthe one in the list, which is the capture device's default time stamp\ntype.  A return value of zero means that the only time stamp type\nsupported is\n.BR PCAP_TSTAMP_HOST ,\nwhich is the capture device's default time stamp type (only older\nversions of libpcap will return that; newer versions will always return\none or more types).\nIf\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH BACKWARD COMPATIBILITY\n.PP\nThese functions became available in libpcap release 1.2.1.  In previous\nreleases, the time stamp type cannot be set; only the default time stamp\ntype offered by a capture source is available.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_tstamp_type_val_to_name (3PCAP),\n.BR pcap_set_tstamp_type (3PCAP),\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_lookupdev.3pcap",
          "type": "blob",
          "size": 2.63671875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LOOKUPDEV 3PCAP \"30 November 2023\"\n.SH NAME\npcap_lookupdev \\- find the default device on which to capture\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\n[DEPRECATED] char *pcap_lookupdev(char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.B This interface is obsoleted by\n.BR pcap_findalldevs (3PCAP).\nTo find a default device on which to capture, call\n.BR pcap_findalldevs ()\nand, if the list it returns is not empty, use the first device in the\nlist.  (If the list is empty, there are no devices on which capture is\npossible.)\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.LP\n.B If\n.BR pcap_init (3PCAP)\n.B has been called, this interface always returns\n.BR NULL .\n.LP\n.BR pcap_lookupdev ()\nreturns a pointer to a string giving the name of a network device\nsuitable for use with\n.BR pcap_create (3PCAP)\nand\n.BR \\%pcap_activate (3PCAP),\nor with\n.BR pcap_open_live (3PCAP),\nand with\n.BR pcap_lookupnet (3PCAP).\nIf there is an error,\nor if\n.BR pcap_init (3PCAP)\nhas been called,\n.B NULL\nis returned and\n.I errbuf\nis filled in with an appropriate error message.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n.SH BUGS\nThe pointer returned by\n.BR pcap_lookupdev ()\npoints to a static buffer; subsequent calls to\n.BR pcap_lookupdev ()\nin the same thread, or calls to\n.BR pcap_lookupdev ()\nin another thread, may overwrite that buffer.\n.LP\nIn WinPcap and Npcap, this function may return a UTF-16 string rather\nthan an ASCII or UTF-8 string.\n"
        },
        {
          "name": "pcap_lookupnet.3pcap",
          "type": "blob",
          "size": 2.205078125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LOOKUPNET 3PCAP \"13 March 2024\"\n.SH NAME\npcap_lookupnet \\- find the IPv4 network number and netmask for a device\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\nint pcap_lookupnet(const char *device, bpf_u_int32 *netp,\n    bpf_u_int32 *maskp, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_lookupnet ()\nis used to determine the IPv4 network number and mask\nassociated with the network device\n.IR device .\nBoth\n.I netp\nand\n.I maskp\nare\n.B bpf_u_int32\npointers.\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.LP\nThis function is not available on Windows.  It supports neither IPv6 nor\nmultiple IPv4 addresses per interface, which obviously is not practical in\nmodern networks.  See\n.BR pcap_findalldevs (3PCAP)\nfor a more elaborate solution to the problem.\n.SH RETURN VALUE\n.BR pcap_lookupnet ()\nreturns\n.B 0\non success and\n.B PCAP_ERROR\non failure. If\n.B PCAP_ERROR\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_loop.3pcap",
          "type": "blob",
          "size": 6.853515625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_LOOP 3PCAP \"5 March 2022\"\n.SH NAME\npcap_loop, pcap_dispatch \\- process packets from a live capture or savefile\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\ntypedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h,\n    const u_char *bytes);\nint pcap_loop(pcap_t *p, int cnt,\n    pcap_handler callback, u_char *user);\nint pcap_dispatch(pcap_t *p, int cnt,\n    pcap_handler callback, u_char *user);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_loop ()\nprocesses packets from a live capture or ``savefile'' until\n.I cnt\npackets are processed, the end of the ``savefile'' is\nreached when reading from a ``savefile'',\n.BR pcap_breakloop (3PCAP)\nis called, or an error occurs.\nIt does\n.B not\nreturn when live packet buffer timeouts occur.\nA value of\n.B \\-1\nor\n.B 0\nfor\n.I cnt\nis equivalent to infinity, so that packets are processed until another\nending condition occurs.\n.PP\n.BR pcap_dispatch ()\nprocesses packets from a live capture or ``savefile'' until\n.I cnt\npackets are processed, the end of the current bufferful of packets is\nreached when doing a live capture, the end of the ``savefile'' is\nreached when reading from a ``savefile'',\n.BR pcap_breakloop ()\nis called, or an error occurs.\nThus, when doing a live capture,\n.I cnt\nis the maximum number of packets to process before returning, but is not\na minimum number; when reading a live capture, only one\nbufferful of packets is read at a time, so fewer than\n.I cnt\npackets may be processed. A value of\n.B \\-1\nor\n.B 0\nfor\n.I cnt\ncauses all the packets received in one buffer to be processed when\nreading a live capture, and causes all the packets in the file to be\nprocessed when reading a ``savefile''.\n.PP\nNote that, when doing a live capture on some platforms, if the read\ntimeout expires when there are no packets available,\n.BR pcap_dispatch ()\nwill return 0, even when not in non-blocking mode, as there are no\npackets to process.  Applications should be prepared for this to happen,\nbut must not rely on it happening.\n.PP\n.I callback\nspecifies a\n.B pcap_handler\nroutine to be called with three arguments:\na\n.B u_char\npointer which is passed in the\n.I user\nargument to\n.BR pcap_loop ()\nor\n.BR pcap_dispatch (),\na\n.B const struct pcap_pkthdr\npointer pointing to the packet time stamp and lengths, and a\n.B const u_char\npointer to the first\n.B caplen\n(as given in the\n.BR \"struct pcap_pkthdr\" ,\na pointer to which is passed to the callback routine)\nbytes of data from the packet.  The\n.B struct pcap_pkthdr\nand the packet data are not to be freed by the callback routine, and are\nnot guaranteed to be valid after the callback routine returns; if the\ncode needs them to be valid after the callback, it must make a copy of\nthem.\n.PP\nThe bytes of data from the packet begin with a link-layer header.  The\nformat of the link-layer header is indicated by the return value of the\n.BR pcap_datalink (3PCAP)\nroutine when handed the\n.B pcap_t\nvalue also passed to\n.BR pcap_loop ()\nor\n.BR pcap_dispatch ().\n.I https://www.tcpdump.org/linktypes.html\nlists the values\n.BR pcap_datalink ()\ncan return and describes the packet formats that\ncorrespond to those values.  The value it returns will be valid for all\npackets received unless and until\n.BR pcap_set_datalink (3PCAP)\nis called; after a successful call to\n.BR pcap_set_datalink (),\nall subsequent packets will have a link-layer header of the type\nspecified by the link-layer header type value passed to\n.BR pcap_set_datalink ().\n.PP\nDo\n.B NOT\nassume that the packets for a given capture or ``savefile`` will have\nany given link-layer header type, such as\n.B DLT_EN10MB\nfor Ethernet.  For example, the \"any\" device on Linux will have a\nlink-layer header type of\n.B DLT_LINUX_SLL\nor\n.B DLT_LINUX_SLL2\neven if all devices on the system at the time the \"any\" device is opened\nhave some other data link type, such as\n.B DLT_EN10MB\nfor Ethernet.\n.SH RETURN VALUE\n.BR pcap_loop ()\nreturns\n.B 0\nif\n.I cnt\nis exhausted or if, when reading from a ``savefile'', no more packets\nare available.  It returns\n.B PCAP_ERROR_BREAK\nif the loop terminated due to a call to\n.BR pcap_breakloop ()\nbefore any packets were processed,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nor\n.B PCAP_ERROR\nif another error occurs.\nIt does\n.B not\nreturn when live packet buffer timeouts occur; instead, it attempts to\nread more packets.\n.PP\n.BR pcap_dispatch ()\nreturns the number of packets processed on success; this can be 0 if no\npackets were read from a live capture (if, for example, they were\ndiscarded because they didn't pass the packet filter, or if, on\nplatforms that support a packet buffer timeout that starts before any\npackets arrive, the timeout expires before any packets arrive, or if the\nfile descriptor for the capture device is in non-blocking mode and no\npackets were available to be read) or if no more packets are available\nin a ``savefile''. It returns\n.B PCAP_ERROR_BREAK\nif the loop terminated due to a call to\n.BR pcap_breakloop ()\nbefore any packets were processed,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nor\n.B PCAP_ERROR\nif another error occurs.\n.ft B\nIf your application uses pcap_breakloop(),\nmake sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK,\nrather than just checking for a return value < 0.\n.ft R\n.PP\nIf\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH BACKWARD COMPATIBILITY\n.PP\nIn libpcap versions before 1.5.0, the behavior when\n.I cnt\nwas\n.B 0\nwas undefined; different platforms and devices behaved differently,\nso code that must work with these versions of libpcap should use\n.BR \\-1 ,\nnot\n.BR 0 ,\nas the value of\n.IR cnt .\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_major_version.3pcap",
          "type": "blob",
          "size": 1.96875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_MAJOR_VERSION 3PCAP \"8 January 2018\"\n.SH NAME\npcap_major_version, pcap_minor_version \\- get the version number of a savefile\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_major_version(pcap_t *p);\nint pcap_minor_version(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\nIf\n.I p\nrefers to a ``savefile'',\n.BR pcap_major_version ()\nreturns the major number of the file format of the ``savefile'' and\n.BR pcap_minor_version ()\nreturns the minor number of the file format of the ``savefile''.  The\nversion number is stored in the ``savefile''; note that the meaning of\nits values depends on the type of ``savefile'' (for example, pcap or\npcapng).\n.PP\nIf\n.I p\nrefers to a live capture, the values returned by\n.BR pcap_major_version ()\nand\n.BR pcap_minor_version ()\nare not meaningful.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_next_ex.3pcap",
          "type": "blob",
          "size": 5.0087890625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_NEXT_EX 3PCAP \"5 March 2022\"\n.SH NAME\npcap_next_ex, pcap_next \\- read the next packet from a pcap_t\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,\n    const u_char **pkt_data);\nconst u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_next_ex ()\nreads the next packet and returns a success/failure indication.\nIf the packet was read without problems, the pointer pointed to by the\n.I pkt_header\nargument is set to point to the\n.B pcap_pkthdr\nstruct for the packet, and the\npointer pointed to by the\n.I pkt_data\nargument is set to point to the data in the packet.  The\n.B struct pcap_pkthdr\nand the packet data are not to be freed by the caller, and are not\nguaranteed to be valid after the next call to\n.BR pcap_next_ex (),\n.BR pcap_next (),\n.BR pcap_loop (3PCAP),\nor\n.BR pcap_dispatch (3PCAP);\nif the code needs them to remain valid, it must make a copy of them.\n.PP\n.BR pcap_next ()\nreads the next packet (by calling\n.BR pcap_dispatch ()\nwith a\n.I cnt\nof 1) and returns a\n.B u_char\npointer to the data in that packet.  The\npacket data is not to be freed by the caller, and is not\nguaranteed to be valid after the next call to\n.BR pcap_next_ex (),\n.BR pcap_next (),\n.BR pcap_loop (),\nor\n.BR pcap_dispatch ();\nif the code needs it to remain valid, it must make a copy of it.\nThe\n.B pcap_pkthdr\nstructure pointed to by\n.I h\nis filled in with the appropriate values for the packet.\n.PP\nThe bytes of data from the packet begin with a link-layer header.  The\nformat of the link-layer header is indicated by the return value of the\n.BR pcap_datalink (3PCAP)\nroutine when handed the\n.B pcap_t\nvalue also passed to\n.BR pcap_loop ()\nor\n.BR pcap_dispatch ().\n.I https://www.tcpdump.org/linktypes.html\nlists the values\n.BR pcap_datalink ()\ncan return and describes the packet formats that\ncorrespond to those values.  The value it returns will be valid for all\npackets received unless and until\n.BR pcap_set_datalink (3PCAP)\nis called; after a successful call to\n.BR pcap_set_datalink (),\nall subsequent packets will have a link-layer header of the type\nspecified by the link-layer header type value passed to\n.BR pcap_set_datalink ().\n.PP\nDo\n.B NOT\nassume that the packets for a given capture or ``savefile`` will have\nany given link-layer header type, such as\n.B DLT_EN10MB\nfor Ethernet.  For example, the \"any\" device on Linux will have a\nlink-layer header type of\n.B DLT_LINUX_SLL\nor\n.B DLT_LINUX_SLL2\neven if all devices on the system at the time the \"any\" device is opened\nhave some other data link type, such as\n.B DLT_EN10MB\nfor Ethernet.\n.SH RETURN VALUE\n.BR pcap_next_ex ()\nreturns\n.B 1\nif the packet was read without problems,\n.B 0\nif packets are\nbeing read from a live capture and the packet buffer timeout expired,\n.B PCAP_ERROR_BREAK\nif packets\nare being read from a ``savefile'' and there are no more packets to read\nfrom the savefile,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nor\n.B PCAP_ERROR\nif an error occurred while reading the packet.  If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.PP\n.BR pcap_next ()\nreturns a pointer to the packet data on success, and returns\n.B NULL\nif an error occurred, or if no packets were read from a live capture\n(if, for example, they were discarded because they didn't pass the\npacket filter, or if, on platforms that support a packet buffer timeout\nthat starts before any packets arrive, the timeout expires before any\npackets arrive, or if the file descriptor for the capture device is in\nnon-blocking mode and no packets were available to be read), or if no\nmore packets are available in a ``savefile''. Unfortunately, there is no\nway to determine whether an error occurred or not.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_offline_filter.3pcap",
          "type": "blob",
          "size": 1.955078125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_OFFLINE_FILTER 3PCAP \"7 April 2014\"\n.SH NAME\npcap_offline_filter \\- check whether a filter matches a packet\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_offline_filter(const struct bpf_program *fp,\n    const struct pcap_pkthdr *h, const u_char *pkt);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_offline_filter ()\nchecks whether a filter matches a packet.\n.I fp\nis a pointer to a\n.I bpf_program\nstruct, usually the result of a call to\n.BR pcap_compile (3PCAP).\n.I h\npoints to the\n.I pcap_pkthdr\nstructure for the packet, and\n.I pkt\npoints to the data in the packet.\n.SH RETURN VALUE\n.BR pcap_offline_filter ()\nreturns the return value of the filter program.  This will be zero if\nthe packet doesn't match the filter and non-zero if the packet matches\nthe filter.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_open_dead.3pcap.in",
          "type": "blob",
          "size": 2.91015625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_OPEN_DEAD 3PCAP \"3 January 2014\"\n.SH NAME\npcap_open_dead, pcap_open_dead_with_tstamp_precision \\- open a fake\npcap_t for compiling filters or opening a capture for output\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\npcap_t *pcap_open_dead(int linktype, int snaplen);\npcap_t *pcap_open_dead_with_tstamp_precision(int linktype, int snaplen,\n    u_int precision);\n.ft\n.fi\n.SH DESCRIPTION\n.PP\n.BR pcap_open_dead ()\nand\n.BR pcap_open_dead_with_tstamp_precision ()\nare used for creating a\n.B pcap_t\nstructure to use when calling the other functions in libpcap.  It is\ntypically used when just using libpcap for compiling BPF code; it can\nalso be used if using\n.BR pcap_dump_open (3PCAP),\n.BR pcap_dump (3PCAP),\nand\n.BR pcap_dump_close (3PCAP)\nto write a savefile if there is no\n.B pcap_t\nthat supplies the packets to be written.\n.PP\n.I linktype\nspecifies the link-layer type for the\n.BR pcap_t .\n.PP\n.I snaplen\nspecifies the snapshot length for the\n.BR pcap_t .\n.PP\nWhen\n.BR pcap_open_dead_with_tstamp_precision (),\nis used to create a\n.B pcap_t\nfor use with\n.BR pcap_dump_open (),\n.I precision\nspecifies the time stamp precision for packets;\n.B PCAP_TSTAMP_PRECISION_MICRO\nshould be specified if the packets to be written have time stamps in\nseconds and microseconds, and\n.B PCAP_TSTAMP_PRECISION_NANO\nshould be specified if the packets to be written have time stamps in\nseconds and nanoseconds.  Its value does not affect\n.BR pcap_compile (3PCAP).\n.SH BACKWARD COMPATIBILITY\nThe\n.BR pcap_open_dead_with_tstamp_precision ()\nfunction became available in libpcap release 1.5.1.  In previous\nreleases, there was no mechanism to open a savefile for writing with\ntime stamps given in seconds and nanoseconds.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR \\%pcap-linktype (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_open_live.3pcap",
          "type": "blob",
          "size": 3.12109375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_OPEN_LIVE 3PCAP \"4 March 2024\"\n.SH NAME\npcap_open_live \\- open a device for capturing\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\npcap_t *pcap_open_live(const char *device, int snaplen,\n    int promisc, int to_ms, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_open_live ()\nis used to obtain a packet capture handle to look\nat packets on the network.\n.I device\nis a string that specifies the network device to open; on all supported Linux\nsystems, as well as on recent versions of macOS and Solaris, a\n.I device\nargument of \"any\" or\n.B NULL\ncan be used to capture packets from all network interfaces.  The latter should\nnot be confused with all available capture devices as seen by\n.BR pcap_findalldevs (3PCAP),\nwhich may also include D-Bus, USB etc.\n.PP\n.I snaplen\nspecifies the snapshot length to be set on the handle.  If the packet\ndata should not be truncated at the end, a value of 262144 should be\nsufficient for most devices, but D-Bus devices require a value of 128MiB\n(128*1024*1024).\n.PP\n.I promisc\nspecifies whether the interface is to be put into promiscuous mode.\nIf\n.I promisc\nis non-zero, promiscuous mode will be set, otherwise it will not be set.\n.PP\n.I to_ms\nspecifies the packet buffer timeout, as a non-negative value, in\nmilliseconds.  (See\n.BR pcap (3PCAP)\nfor an explanation of the packet buffer timeout.)\n.PP\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.SH RETURN VALUE\n.BR pcap_open_live ()\nreturns a\n.B pcap_t *\non success and\n.B NULL\non failure.\nIf\n.B NULL\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.I errbuf\nmay also be set to warning text when\n.BR pcap_open_live ()\nsucceeds; to detect this case the caller should store a zero-length string in\n.I errbuf\nbefore calling\n.BR pcap_open_live ()\nand display the warning to the user if\n.I errbuf\nis no longer a zero-length string.\n.SH SEE ALSO\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_open_offline.3pcap.in",
          "type": "blob",
          "size": 3.9375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_OPEN_OFFLINE 3PCAP \"12 October 2024\"\n.SH NAME\npcap_open_offline, pcap_open_offline_with_tstamp_precision,\npcap_fopen_offline, pcap_fopen_offline_with_tstamp_precision \\- open a saved capture file for reading\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\npcap_t *pcap_open_offline(const char *fname, char *errbuf);\npcap_t *pcap_open_offline_with_tstamp_precision(const char *fname,\n    u_int precision, char *errbuf);\npcap_t *pcap_fopen_offline(FILE *fp, char *errbuf);\npcap_t *pcap_fopen_offline_with_tstamp_precision(FILE *fp,\n    u_int precision, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_open_offline ()\nand\n.BR pcap_open_offline_with_tstamp_precision ()\nare called to open a ``savefile'' for reading.\n.PP\n.I fname\nspecifies the name of the file to open. The file can have the pcap file\nformat as described in\n.BR \\%pcap-savefile (@MAN_FILE_FORMATS@),\nwhich is the file format used by, among other programs,\n.BR tcpdump (1)\nand\n.BR tcpslice (1),\nor can have the pcapng file format, although not all pcapng files can\nbe read.\nThe name \"-\" is a synonym for\n.BR stdin .\n.PP\n.BR pcap_open_offline_with_tstamp_precision ()\ntakes an additional\n.I precision\nargument specifying the time stamp precision desired;\nif\n.B PCAP_TSTAMP_PRECISION_MICRO\nis specified, packet time stamps will be supplied in seconds and\nmicroseconds,\nand if\n.B PCAP_TSTAMP_PRECISION_NANO\nis specified, packet time stamps will be supplied in seconds and\nnanoseconds.  If the time stamps in the file do not have the same\nprecision as the requested precision, they will be scaled up or down as\nnecessary before being supplied.\n.PP\nAlternatively, you may call\n.BR pcap_fopen_offline ()\nor\n.BR pcap_fopen_offline_with_tstamp_precision ()\nto read dumped data from an existing open stream\n.IR fp ;\nthis stream will be closed by a subsequent call to\n.BR pcap_close (3PCAP)\nunless it is\n.BR stdin .\n.BR pcap_fopen_offline_with_tstamp_precision ()\ntakes an additional\n.I precision\nargument as described above.\nNote that on Windows, that stream should be opened in binary mode.\n.PP\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.SH RETURN VALUE\n.BR pcap_open_offline (),\n.BR pcap_open_offline_with_tstamp_precision (),\n.BR pcap_fopen_offline (),\nand\n.BR pcap_fopen_offline_with_tstamp_precision ()\nreturn a\n.B pcap_t *\non success and\n.B NULL\non failure.\nIf\n.B NULL\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.SH BACKWARD COMPATIBILITY\n.BR pcap_open_offline_with_tstamp_precision ()\nand\n.BR pcap_fopen_offline_with_tstamp_precision ()\nbecame available in libpcap release 1.5.1.  In previous releases, time\nstamps from a savefile are always given in seconds and microseconds.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR \\%pcap-savefile (@MAN_FILE_FORMATS@)\n"
        },
        {
          "name": "pcap_set_buffer_size.3pcap",
          "type": "blob",
          "size": 1.81640625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_BUFFER_SIZE 3PCAP \"3 January 2014\"\n.SH NAME\npcap_set_buffer_size \\- set the buffer size for a not-yet-activated\ncapture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_buffer_size(pcap_t *p, int buffer_size);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_buffer_size ()\nsets the buffer size that will be used on a capture handle when\nthe handle is activated to\n.IR buffer_size ,\nwhich is in units of bytes.\n.SH RETURN VALUE\n.BR pcap_set_buffer_size ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_set_datalink.3pcap",
          "type": "blob",
          "size": 2.01953125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_DATALINK 3PCAP \"5 March 2022\"\n.SH NAME\npcap_set_datalink \\- set the link-layer header type to be used by a\ncapture device\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_set_datalink(pcap_t *p, int dlt);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_datalink ()\nis used to set the current link-layer header type of the pcap descriptor\nto the type specified by\n.IR dlt .\n.SH RETURN VALUE\n.BR pcap_set_datalink ()\nreturns\n.B 0\non success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated, or\n.B PCAP_ERROR\non other errors. If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_datalink (3PCAP),\n.BR pcap_list_datalinks (3PCAP),\n.BR pcap_datalink_name_to_val (3PCAP)\n"
        },
        {
          "name": "pcap_set_immediate_mode.3pcap.in",
          "type": "blob",
          "size": 3.046875,
          "content": ".\\\"\n.\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_IMMEDIATE_MODE 3PCAP \"27 January 2024\"\n.SH NAME\npcap_set_immediate_mode \\- set immediate mode for a not-yet-activated capture\nhandle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_immediate_mode(pcap_t *p, int immediate_mode);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_immediate_mode ()\nsets whether immediate mode should be set on a capture handle when\nthe handle is activated.  In immediate mode, packets are always\ndelivered as soon as they arrive, with no buffering.\nIf\n.I immediate_mode\nis non-zero, immediate mode will be set, otherwise it will not be set.\n.SH RETURN VALUE\n.BR pcap_set_immediate_mode ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH BACKWARD COMPATIBILITY\n.PP\nThis function became available in libpcap release 1.5.0.  In previous\nreleases, if immediate delivery of packets is required:\n.IP\non FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11,\nimmediate mode must be turned on with a\n.B BIOCIMMEDIATE\n.BR ioctl (2),\nas documented in\n.BR bpf (@MAN_DEVICES@),\non the descriptor returned by\n.BR pcap_fileno (3PCAP),\nafter\n.BR pcap_activate (3PCAP)\nis called;\n.IP\non Solaris 10 and earlier versions of Solaris, immediate mode must be\nturned on by using a read timeout of 0 when opening the device (this\nwill not provide immediate delivery of packets on other platforms, so\ndon't assume it's sufficient);\n.IP\non Windows, immediate mode must be turned on by calling\n.BR pcap_setmintocopy ()\nwith a size of 0.\n.PP\nOn Linux, with previous releases of libpcap, capture devices are always\nin immediate mode; however, in 1.5.0 and later, they are, by default,\n.B not\nin immediate mode, so if\n.BR pcap_set_immediate_mode ()\nis available, it should be used.\n.PP\nOn other platforms, capture devices are always in immediate mode.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_set_promisc.3pcap",
          "type": "blob",
          "size": 1.8369140625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_PROMISC 3PCAP \"3 January 2014\"\n.SH NAME\npcap_set_promisc \\- set promiscuous mode for a not-yet-activated\ncapture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_promisc(pcap_t *p, int promisc);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_promisc ()\nsets whether promiscuous mode should be set on a capture handle when\nthe handle is activated.\nIf\n.I promisc\nis non-zero, promiscuous mode will be set, otherwise it will not be set.\n.SH RETURN VALUE\n.BR pcap_set_promisc ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_set_protocol_linux.3pcap",
          "type": "blob",
          "size": 2.8330078125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_PROTOCOL_LINUX 3PCAP \"22 August 2018\"\n.SH NAME\npcap_set_protocol_linux \\- set capture protocol for a not-yet-activated\ncapture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_protocol_linux(pcap_t *p, int protocol);\n.ft\n.fi\n.SH DESCRIPTION\nOn network interface devices on Linux,\n.BR pcap_set_protocol_linux ()\nsets the protocol to be used in the\n.BR socket (2)\ncall to create a capture socket when the handle is activated.  The\nargument is a link-layer protocol value, such as the values in the\n.B <linux/if_ether.h>\nheader file, specified in host byte order.\nIf\n.I protocol\nis non-zero, packets of that protocol will be captured when the\nhandle is activated, otherwise, all packets will be captured.  This\nfunction is only provided on Linux, and, if it is used on any device\nother than a network interface, it will have no effect.\n.LP\nIt should not be used in portable code; instead, a filter should be\nspecified with\n.BR pcap_setfilter (3PCAP).\n.LP\nIf a given network interface provides a standard link-layer header, with\na standard packet type, but provides some packet types with a different\nsocket-layer protocol type from the one in the link-layer header, that\npacket type cannot be filtered with a filter specified with\n.BR pcap_setfilter ()\nbut can be filtered by specifying the socket-layer protocol type using\n.BR pcap_set_protocol_linux ().\n.SH RETURN VALUE\n.BR pcap_set_protocol_linux ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH BACKWARD COMPATIBILITY\nThis function became available in libpcap release 1.9.0.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_set_rfmon.3pcap",
          "type": "blob",
          "size": 1.8427734375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_RFMON 3PCAP \"3 January 2014\"\n.SH NAME\npcap_set_rfmon \\- set monitor mode for a not-yet-activated capture\nhandle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_rfmon(pcap_t *p, int rfmon);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_rfmon ()\nsets whether monitor mode should be set on a capture handle when\nthe handle is activated.\nIf\n.I rfmon\nis non-zero, monitor mode will be set, otherwise it will not be set.\n.SH RETURN VALUE\n.BR pcap_set_rfmon ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP),\n.BR pcap_can_set_rfmon (3PCAP)\n"
        },
        {
          "name": "pcap_set_snaplen.3pcap",
          "type": "blob",
          "size": 1.7626953125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_SNAPLEN 3PCAP \"3 January 2014\"\n.SH NAME\npcap_set_snaplen \\- set the snapshot length for a not-yet-activated\ncapture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_snaplen(pcap_t *p, int snaplen);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_snaplen ()\nsets the snapshot length to be used on a capture handle when the handle\nis activated to\n.IR snaplen .\n.SH RETURN VALUE\n.BR pcap_set_snaplen ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP)\n"
        },
        {
          "name": "pcap_set_timeout.3pcap",
          "type": "blob",
          "size": 2.1669921875,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_TIMEOUT 3PCAP \"6 December 2017\"\n.SH NAME\npcap_set_timeout \\- set the packet buffer timeout for a\nnot-yet-activated capture handle\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.LP\n.ft B\nint pcap_set_timeout(pcap_t *p, int to_ms);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_timeout ()\nsets the packet buffer timeout that will be used on a capture handle\nwhen the handle is activated to\n.IR to_ms ,\nwhich is in units of milliseconds.  (See\n.BR pcap (3PCAP)\nfor an explanation of the packet buffer timeout.)\n.LP\nThe behavior, if the timeout isn't specified, is undefined, as is the\nbehavior if the timeout is set to zero or to a negative value.  We\nrecommend always setting the timeout to a non-zero value unless\nimmediate mode is set, in which case the timeout has no effect.\n.SH RETURN VALUE\n.BR pcap_set_timeout ()\nreturns\n.B 0\non success or\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH SEE ALSO\n.BR pcap_create (3PCAP),\n.BR pcap_activate (3PCAP),\n.BR \\%pcap_set_immediate_mode (3PCAP)\n"
        },
        {
          "name": "pcap_set_tstamp_precision.3pcap.in",
          "type": "blob",
          "size": 2.4345703125,
          "content": ".\\\"Copyright (c) 2013, Michal Sekletar\n.\\\"All rights reserved.\n.\\\"\n.\\\"Redistribution and use in source and binary forms, with or without\n.\\\"modification, are permitted provided that the following conditions\n.\\\"are met:\n.\\\"\n.\\\"  1. Redistributions of source code must retain the above copyright\n.\\\"     notice, this list of conditions and the following disclaimer.\n.\\\"  2. Redistributions in binary form must reproduce the above copyright\n.\\\"     notice, this list of conditions and the following disclaimer in\n.\\\"     the documentation and/or other materials provided with the\n.\\\"     distribution.\n.\\\"  3. The names of the authors may not be used to endorse or promote\n.\\\"     products derived from this software without specific prior\n.\\\"     written permission.\n.\\\"\n.\\\"THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n.\\\"IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n.\\\"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n\n.TH PCAP_SET_TSTAMP_PRECISION 3PCAP \"23 August 2018\"\n.SH NAME\npcap_set_tstamp_precision \\- set the time stamp precision returned in\ncaptures\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_set_tstamp_precision(pcap_t *p, int tstamp_precision);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_tstamp_precision ()\nsets the precision of the time stamp desired for packets captured on the pcap\ndescriptor to the type specified by\n.IR tstamp_precision .\nIt must be called on a pcap descriptor created by\n.BR pcap_create (3PCAP)\nthat has not yet been activated by\n.BR pcap_activate (3PCAP).\nTwo time stamp precisions are supported, microseconds and nanoseconds. One can\nuse options\n.B PCAP_TSTAMP_PRECISION_MICRO\nand\n.B PCAP_TSTAMP_PRECISION_NANO\nto request desired precision. By default, time stamps are in microseconds.\n.SH RETURN VALUE\n.BR pcap_set_tstamp_precision ()\nreturns\n.B 0\non success if the specified time stamp precision is expected to be\nsupported by the capture device,\n.B PCAP_ERROR_TSTAMP_PRECISION_NOTSUP\nif the capture device does not support the requested time stamp\nprecision,\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated.\n.SH BACKWARD COMPATIBILITY\nThis function became available in libpcap release 1.5.1.  In previous\nreleases, time stamps from a capture device or savefile are always given\nin seconds and microseconds.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_get_tstamp_precision (3PCAP),\n.BR pcap_set_tstamp_type (3PCAP),\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\n"
        },
        {
          "name": "pcap_set_tstamp_type.3pcap.in",
          "type": "blob",
          "size": 2.8271484375,
          "content": ".\\\"\n.\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SET_TSTAMP_TYPE 3PCAP \"8 September 2019\"\n.SH NAME\npcap_set_tstamp_type \\- set the time stamp type to be used by a\ncapture device\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_set_tstamp_type(pcap_t *p, int tstamp_type);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_set_tstamp_type ()\nsets the type of time stamp desired for packets captured on the pcap\ndescriptor to the type specified by\n.IR tstamp_type .\nIt must be called on a pcap descriptor created by\n.BR pcap_create (3PCAP)\nthat has not yet been activated by\n.BR pcap_activate (3PCAP).\n.BR pcap_list_tstamp_types (3PCAP)\nwill give a list of the time stamp types supported by a given capture\ndevice.\nSee\n.BR \\%pcap-tstamp (@MAN_MISC_INFO@)\nfor a list of all the time stamp types.\n.SH RETURN VALUE\n.BR pcap_set_tstamp_type ()\nreturns\n.B 0\non success if the specified time stamp type is expected to be\nsupported by the capture device,\n.B PCAP_WARNING_TSTAMP_TYPE_NOTSUP\nif the specified time stamp type is not supported by the\ncapture device,\n.B PCAP_ERROR_ACTIVATED\nif called on a capture handle that has been activated, and\n.B PCAP_ERROR_CANTSET_TSTAMP_TYPE\nif the capture device doesn't support setting the time stamp type (only\nolder versions of libpcap will return that; newer versions will always\nallow the time stamp type to be set to the default type).\n.SH BACKWARD COMPATIBILITY\n.PP\nThis function became available in libpcap release 1.2.1.  In previous\nreleases, the time stamp type cannot be set; only the default time stamp\ntype offered by a capture source is available.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_list_tstamp_types (3PCAP),\n.BR pcap_set_tstamp_precision (3PCAP),\n.BR pcap_tstamp_type_name_to_val (3PCAP)\n"
        },
        {
          "name": "pcap_setdirection.3pcap",
          "type": "blob",
          "size": 2.478515625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SETDIRECTION 3PCAP \"5 March 2022\"\n.SH NAME\npcap_setdirection \\- set the direction for which packets will be captured\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_setdirection(pcap_t *p, pcap_direction_t d);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_setdirection ()\nis used to specify a direction that packets will be captured.\n.I d\nis one of the constants\n.BR PCAP_D_IN ,\n.B PCAP_D_OUT\nor\n.BR PCAP_D_INOUT .\n.B PCAP_D_IN\nwill only capture packets received by the device,\n.B PCAP_D_OUT\nwill only capture packets sent by the device and\n.B PCAP_D_INOUT\nwill capture packets received by or sent by the device.\n.B PCAP_D_INOUT\nis the default setting if this function is not called.\n.PP\n.BR pcap_setdirection ()\nisn't necessarily fully supported on all platforms; some platforms might\nreturn an error for all values, and some other platforms might not\nsupport\n.BR PCAP_D_OUT .\n.PP\nThis operation is not supported if a ``savefile'' is being read.\n.SH RETURN VALUE\n.BR pcap_setdirection ()\nreturns\n.B 0\non success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated, or\n.B PCAP_ERROR\non other errors. If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_setfilter.3pcap",
          "type": "blob",
          "size": 1.9130859375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SETFILTER 3PCAP \"5 March 2022\"\n.SH NAME\npcap_setfilter \\- set the filter\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_setfilter(pcap_t *p, struct bpf_program *fp);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_setfilter ()\nis used to specify a filter program.\n.I fp\nis a pointer to a\n.I bpf_program\nstruct, usually the result of a call to\n.BR \\%pcap_compile (3PCAP).\n.SH RETURN VALUE\n.BR pcap_setfilter ()\nreturns\n.B 0\non success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated, or\n.B PCAP_ERROR\non other errors.  If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_setnonblock.3pcap",
          "type": "blob",
          "size": 3.3037109375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SETNONBLOCK 3PCAP \"30 November 2023\"\n.SH NAME\npcap_setnonblock, pcap_getnonblock \\- set or get the state of\nnon-blocking mode on a capture device\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.nf\n.ft B\nchar errbuf[PCAP_ERRBUF_SIZE];\n.ft\n.LP\n.ft B\nint pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf);\nint pcap_getnonblock(pcap_t *p, char *errbuf);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_setnonblock ()\nputs a capture handle into ``non-blocking'' mode, or takes it out\nof ``non-blocking'' mode, depending on whether the\n.I nonblock\nargument is non-zero or zero.  It has no effect on ``savefiles''.\n.I errbuf\nis a buffer large enough to hold at least\n.B PCAP_ERRBUF_SIZE\nchars.\n.PP\nIn\n``non-blocking'' mode, an attempt to read from the capture descriptor\nwith\n.BR pcap_dispatch (3PCAP)\nand\n.BR pcap_next_ex (3PCAP)\nwill, if no packets are currently available to be read, return\n.B 0\nimmediately rather than blocking waiting for packets to arrive.\n.PP\n.BR pcap_loop (3PCAP)\nwill loop forever, consuming CPU time when no packets are currently\navailable;\n.BR pcap_dispatch ()\nshould be used instead.\n.BR pcap_next (3PCAP)\nwill return\n.B NULL\nif there are no packets currently available to read;\nthis is indistinguishable from an error, so\n.BR pcap_next_ex ()\nshould be used instead.\n.PP\nWhen first activated with\n.BR pcap_activate (3PCAP)\nor opened with\n.BR pcap_open_live (3PCAP),\na capture handle is not in ``non-blocking mode''; a call to\n.BR pcap_setnonblock ()\nis required in order to put it into ``non-blocking'' mode.\n.SH RETURN VALUE\n.BR pcap_setnonblock()\nreturn 0 on success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nand\n.B PCAP_ERROR\nfor other errors.\n.BR pcap_getnonblock ()\nreturns the current ``non-blocking'' state of the capture descriptor on\nsuccess; it always returns\n.B 0\non ``savefiles''.\nIt returns\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nand\n.B PCAP_ERROR\nfor other errors.\nIf\n.B PCAP_ERROR\nis returned,\n.I errbuf\nis filled in with an appropriate error message.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_next_ex (3PCAP),\n.BR pcap_geterr (3PCAP)\n"
        },
        {
          "name": "pcap_snapshot.3pcap",
          "type": "blob",
          "size": 1.923828125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_SNAPSHOT 3PCAP \"7 April 2014\"\n.SH NAME\npcap_snapshot \\- get the snapshot length\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_snapshot(pcap_t *p);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_snapshot ()\nreturns the snapshot length specified when\n.BR pcap_set_snaplen (3PCAP)\nor\n.BR pcap_open_live (3PCAP)\nwas called, for a live capture, or the snapshot length from the capture\nfile, for a ``savefile''.\n.PP\nIt must not be called on a pcap descriptor created by\n.BR \\%pcap_create (3PCAP)\nthat has not yet been activated by\n.BR \\%pcap_activate (3PCAP).\n.SH RETURN VALUE\n.BR pcap_snapshot ()\nreturns the snapshot length on success and\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_stats.3pcap",
          "type": "blob",
          "size": 3.4658203125,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_STATS 3PCAP \"5 March 2022\"\n.SH NAME\npcap_stats \\- get capture statistics\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_stats(pcap_t *p, struct pcap_stat *ps);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_stats ()\nfills in the\n.B struct pcap_stat\npointed to by its second argument.  The values represent\npacket statistics from the start of the run to the time of the call.\n.PP\n.BR pcap_stats ()\nis supported only on live captures, not on ``savefiles''; no statistics\nare stored in ``savefiles'', so no statistics are available when reading\nfrom a ``savefile''.\n.PP\nA\n.B struct pcap_stat\nhas the following members:\n.RS\n.TP\n.B ps_recv\nnumber of packets received;\n.TP\n.B ps_drop\nnumber of packets dropped because there was no room in the operating\nsystem's buffer when they arrived, because packets weren't being read\nfast enough;\n.TP\n.B ps_ifdrop\nnumber of packets dropped by the network interface or its driver.\n.RE\n.PP\nThe statistics do not behave the same way on all platforms.\n.B ps_recv\nmight count packets whether they passed any filter set with\n.BR pcap_setfilter (3PCAP)\nor not, or it might count only packets that pass the filter.\nIt also might, or might not, count packets dropped because there was no\nroom in the operating system's buffer when they arrived.\n.B ps_drop\nis not available on all platforms; it is zero on platforms where it's\nnot available.  If packet filtering is done in libpcap, rather than in\nthe operating system, it would count packets that don't pass the filter.\nBoth\n.B ps_recv\nand\n.B ps_drop\nmight, or might not, count packets not yet read from the operating\nsystem and thus not yet seen by the application.\n.B ps_ifdrop\nmight, or might not, be implemented; if it's zero, that might mean that\nno packets were dropped by the interface, or it might mean that the\nstatistic is unavailable, so it should not be treated as an indication\nthat the interface did not drop any packets.\n.SH RETURN VALUE\n.BR pcap_stats ()\nreturns\n.B 0\non success,\n.B PCAP_ERROR_NOT_ACTIVATED\nif called on a capture handle that has been created but not activated,\nor\n.B PCAP_ERROR\nif there is another error or if\n.I p\ndoesn't support packet statistics. If\n.B PCAP_ERROR\nis returned,\n.BR pcap_geterr (3PCAP)\nor\n.BR pcap_perror (3PCAP)\nmay be called with\n.I p\nas an argument to fetch or display the error text.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_statustostr.3pcap",
          "type": "blob",
          "size": 1.5615234375,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_STATUSTOSTR 3PCAP \"3 January 2014\"\n.SH NAME\npcap_statustostr \\- convert a PCAP_ERROR_ or PCAP_WARNING_ value to a string\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nconst char *pcap_statustostr(int error);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_statustostr ()\nconverts a\n.B PCAP_ERROR_\nor\n.B PCAP_WARNING_\nvalue returned by a libpcap routine to an error string.\n.SH SEE ALSO\n.BR pcap (3PCAP)\n"
        },
        {
          "name": "pcap_strerror.3pcap",
          "type": "blob",
          "size": 1.7744140625,
          "content": ".\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_STRERROR 3PCAP \"26 August 2024\"\n.SH NAME\npcap_strerror \\- convert an errno value to a string\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nconst char *pcap_strerror(int error);\n.ft\n.fi\n.SH DESCRIPTION\nThis function returns an error message string corresponding to\n.IR error .\nIt uses either\n.BR strerror (3)\nor its thread-safe variant if one is available, which currently is the case in\nevery supported OS.\n.SH BACKWARD COMPATIBILITY\nThis function was not thread-safe in libpcap before 1.8.1 on Windows and\nin libpcap before 1.10.5 on all other OSes.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_geterr (3PCAP)\n"
        },
        {
          "name": "pcap_tstamp_type_name_to_val.3pcap",
          "type": "blob",
          "size": 1.9189453125,
          "content": ".\\\"\n.\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_TSTAMP_TYPE_NAME_TO_VAL 3PCAP \"22 August 2018\"\n.SH NAME\npcap_tstamp_type_name_to_val \\- get the time stamp type value\ncorresponding to a time stamp type name\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap/pcap.h>\n.ft\n.LP\n.ft B\nint pcap_tstamp_type_name_to_val(const char *name);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_tstamp_type_name_to_val ()\ntranslates a time stamp type name to the corresponding time stamp type\nvalue.  The translation is case-insensitive.\n.SH RETURN VALUE\n.BR pcap_tstamp_type_name_to_val ()\nreturns time stamp type value on success and\n.B PCAP_ERROR\non failure.\n.SH BACKWARD COMPATIBILITY\n.PP\nThis function became available in libpcap release 1.2.1.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_set_tstamp_type (3PCAP),\n.BR pcap_tstamp_type_val_to_name (3PCAP)\n"
        },
        {
          "name": "pcap_tstamp_type_val_to_name.3pcap",
          "type": "blob",
          "size": 2.041015625,
          "content": ".\\\"\n.\\\" Copyright (c) 1994, 1996, 1997\n.\\\"\tThe Regents of the University of California.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that: (1) source code distributions\n.\\\" retain the above copyright notice and this paragraph in its entirety, (2)\n.\\\" distributions including binary code include the above copyright notice and\n.\\\" this paragraph in its entirety in the documentation or other materials\n.\\\" provided with the distribution, and (3) all advertising materials mentioning\n.\\\" features or use of this software display the following acknowledgement:\n.\\\" ``This product includes software developed by the University of California,\n.\\\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n.\\\" the University nor the names of its contributors may be used to endorse\n.\\\" or promote products derived from this software without specific prior\n.\\\" written permission.\n.\\\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n.\\\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n.\\\"\n.TH PCAP_TSTAMP_TYPE_VAL_TO_NAME 3PCAP \"22 August 2018\"\n.SH NAME\npcap_tstamp_type_val_to_name, pcap_tstamp_type_val_to_description \\- get\na name or description for a time stamp type value\n.SH SYNOPSIS\n.nf\n.ft B\n#include <pcap.h>\n.ft\n.LP\n.ft B\nconst char *pcap_tstamp_type_val_to_name(int tstamp_type);\nconst char *pcap_tstamp_type_val_to_description(int tstamp_type);\n.ft\n.fi\n.SH DESCRIPTION\n.BR pcap_tstamp_type_val_to_name ()\ntranslates a time stamp type value to the corresponding time stamp type\nname.\n.B NULL\nis returned on failure.\n.PP\n.BR pcap_tstamp_type_val_to_description ()\ntranslates a time stamp type value to a short description of that time\nstamp type.\n.B NULL\nis returned on failure.\n.SH BACKWARD COMPATIBILITY\n.PP\nThese functions became available in libpcap release 1.2.1.\n.SH SEE ALSO\n.BR pcap (3PCAP),\n.BR pcap_list_tstamp_types (3PCAP),\n.BR pcap_tstamp_type_name_to_val (3PCAP)\n"
        },
        {
          "name": "pflog.h",
          "type": "blob",
          "size": 4.1142578125,
          "content": "/*\n * Copyright (c) 1982, 1986, 1993\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef _WIN32\n  #include <netinet/in.h>\n#endif\n\n/*\n * pflog headers, at least as they exist now.\n */\n#define PFLOG_IFNAMSIZ\t\t16\n#define PFLOG_RULESET_NAME_SIZE\t16\n\n/*\n * Direction values.\n */\n#define PF_INOUT\t0\n#define PF_IN\t\t1\n#define PF_OUT\t\t2\n#if defined(__OpenBSD__)\n#define PF_FWD\t\t3\n#endif\n\n/*\n * Reason values.\n */\n#define PFRES_MATCH\t0\n#define PFRES_BADOFF\t1\n#define PFRES_FRAG\t2\n#define PFRES_SHORT\t3\n#define PFRES_NORM\t4\n#define PFRES_MEMORY\t5\n#define PFRES_TS\t6\n#define PFRES_CONGEST\t7\n#define PFRES_IPOPTIONS 8\n#define PFRES_PROTCKSUM 9\n#define PFRES_BADSTATE\t10\n#define PFRES_STATEINS\t11\n#define PFRES_MAXSTATES\t12\n#define PFRES_SRCLIMIT\t13\n#define PFRES_SYNPROXY\t14\n#if defined(__FreeBSD__)\n#define PFRES_MAPFAILED\t15\n#elif defined(__NetBSD__)\n#define PFRES_STATELOCKED 15\n#elif defined(__OpenBSD__)\n#define PFRES_TRANSLATE\t15\n#define PFRES_NOROUTE\t16\n#elif defined(__APPLE__)\n#define PFRES_DUMMYNET  15\n#endif\n\n/*\n * Action values.\n */\n#define PF_PASS\t\t\t0\n#define PF_DROP\t\t\t1\n#define PF_SCRUB\t\t2\n#define PF_NOSCRUB\t\t3\n#define PF_NAT\t\t\t4\n#define PF_NONAT\t\t5\n#define PF_BINAT\t\t6\n#define PF_NOBINAT\t\t7\n#define PF_RDR\t\t\t8\n#define PF_NORDR\t\t9\n#define PF_SYNPROXY_DROP\t10\n#if defined(__FreeBSD__)\n#define PF_DEFER\t\t11\n#elif defined(__OpenBSD__)\n#define PF_DEFER\t\t11\n#define PF_MATCH\t\t12\n#define PF_DIVERT\t\t13\n#define PF_RT\t\t\t14\n#define PF_AFRT\t\t\t15\n#elif defined(__APPLE__)\n#define PF_DUMMYNET\t\t11\n#define PF_NODUMMYNET\t\t12\n#define PF_NAT64\t\t13\n#define PF_NONAT64\t\t14\n#endif\n\nstruct pf_addr {\n\tunion {\n\t\tstruct in_addr\t\tv4;\n\t\tstruct in6_addr\t\tv6;\n\t\tuint8_t\t\t\taddr8[16];\n\t\tuint16_t\t\taddr16[8];\n\t\tuint32_t\t\taddr32[4];\n\t} pfa;\t\t    /* 128-bit address */\n#define v4\tpfa.v4\n#define v6\tpfa.v6\n#define addr8\tpfa.addr8\n#define addr16\tpfa.addr16\n#define addr32\tpfa.addr32\n};\n\nstruct pfloghdr {\n\tuint8_t\t\tlength;\n\tuint8_t\t\taf;\n\tuint8_t\t\taction;\n\tuint8_t\t\treason;\n\tchar\t\tifname[PFLOG_IFNAMSIZ];\n\tchar\t\truleset[PFLOG_RULESET_NAME_SIZE];\n\tuint32_t\trulenr;\n\tuint32_t\tsubrulenr;\n\tuint32_t\tuid;\n\tint32_t\t\tpid;\n\tuint32_t\trule_uid;\n\tint32_t\t\trule_pid;\n\tuint8_t\t\tdir;\n#if defined(__OpenBSD__)\n\tuint8_t\t\trewritten;\n\tuint8_t\t\tnaf;\n\tuint8_t\t\tpad[1];\n#else\n\tuint8_t\t\tpad[3];\n#endif\n#if defined(__FreeBSD__)\n\tuint32_t\tridentifier;\n\tuint8_t\t\treserve;\n\tuint8_t\t\tpad2[3];\n#elif defined(__OpenBSD__)\n\tstruct pf_addr\tsaddr;\n\tstruct pf_addr\tdaddr;\n\tuint16_t\tsport;\n\tuint16_t\tdport;\n#endif\n};\n\n\n\n"
        },
        {
          "name": "portability.h",
          "type": "blob",
          "size": 5.2822265625,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef portability_h\n#define\tportability_h\n\n/*\n * Helpers for portability between Windows and UN*X and between different\n * flavors of UN*X.\n */\n#include <stdarg.h>\t/* we declare varargs functions on some platforms */\n\n#include \"pcap/funcattrs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef HAVE_STRLCAT\n  #define pcapint_strlcat\tstrlcat\n#else\n  #if defined(_MSC_VER) || defined(__MINGW32__)\n    /*\n     * strncat_s() is supported at least back to Visual\n     * Studio 2005; we require Visual Studio 2015 or later.\n     */\n    #define pcapint_strlcat(x, y, z) \\\n\tstrncat_s((x), (z), (y), _TRUNCATE)\n  #else\n    /*\n     * Define it ourselves.\n     */\n    extern size_t pcapint_strlcat(char * restrict dst, const char * restrict src, size_t dstsize);\n  #endif\n#endif\n\n#ifdef HAVE_STRLCPY\n  #define pcapint_strlcpy\tstrlcpy\n#else\n  #if defined(_MSC_VER) || defined(__MINGW32__)\n    /*\n     * strncpy_s() is supported at least back to Visual\n     * Studio 2005; we require Visual Studio 2015 or later.\n     */\n    #define pcapint_strlcpy(x, y, z) \\\n\tstrncpy_s((x), (z), (y), _TRUNCATE)\n  #else\n    /*\n     * Define it ourselves.\n     */\n    extern size_t pcapint_strlcpy(char * restrict dst, const char * restrict src, size_t dstsize);\n  #endif\n#endif\n\n#ifdef _MSC_VER\n  /*\n   * If <crtdbg.h> has been included, and _DEBUG is defined, and\n   * __STDC__ is zero, <crtdbg.h> will define strdup() to call\n   * _strdup_dbg().  So if it's already defined, don't redefine\n   * it.\n   */\n  #ifndef strdup\n  #define strdup\t_strdup\n  #endif\n#endif\n\n/*\n * We want asprintf(), for some cases where we use it to construct\n * dynamically-allocated variable-length strings; it's present on\n * some, but not all, platforms.\n */\n#ifdef HAVE_ASPRINTF\n#define pcapint_asprintf asprintf\n#else\nextern int pcapint_asprintf(char **, PCAP_FORMAT_STRING(const char *), ...)\n    PCAP_PRINTFLIKE(2, 3);\n#endif\n\n#ifdef HAVE_VASPRINTF\n#define pcapint_vasprintf vasprintf\n#else\nextern int pcapint_vasprintf(char **, PCAP_FORMAT_STRING(const char *), va_list ap)\n    PCAP_PRINTFLIKE(2, 0);\n#endif\n\n/* For Solaris before 11. */\n#ifndef timeradd\n#define timeradd(a, b, result)                       \\\n  do {                                               \\\n    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;    \\\n    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; \\\n    if ((result)->tv_usec >= 1000000) {              \\\n      ++(result)->tv_sec;                            \\\n      (result)->tv_usec -= 1000000;                  \\\n    }                                                \\\n  } while (0)\n#endif /* timeradd */\n#ifndef timersub\n#define timersub(a, b, result)                       \\\n  do {                                               \\\n    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;    \\\n    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \\\n    if ((result)->tv_usec < 0) {                     \\\n      --(result)->tv_sec;                            \\\n      (result)->tv_usec += 1000000;                  \\\n    }                                                \\\n  } while (0)\n#endif /* timersub */\n\n#ifdef HAVE_STRTOK_R\n  #define pcapint_strtok_r\tstrtok_r\n#else\n  #ifdef _WIN32\n    /*\n     * Microsoft gives it a different name.\n     */\n    #define pcapint_strtok_r\tstrtok_s\n  #else\n    /*\n     * Define it ourselves.\n     */\n    extern char *pcapint_strtok_r(char *, const char *, char **);\n  #endif\n#endif /* HAVE_STRTOK_R */\n\n#ifdef _WIN32\n  #if !defined(__cplusplus)\n    #define inline __inline\n  #endif\n#include <winsock2.h>\n#endif /* _WIN32 */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "ppp.h",
          "type": "blob",
          "size": 2.6171875,
          "content": "/*\n * Point to Point Protocol (PPP) RFC1331\n *\n * Copyright 1989 by Carnegie Mellon.\n *\n * Permission to use, copy, modify, and distribute this program for any\n * purpose and without fee is hereby granted, provided that this copyright\n * and permission notice appear on all copies and supporting documentation,\n * the name of Carnegie Mellon not be used in advertising or publicity\n * pertaining to distribution of the program without specific prior\n * permission, and notice be given in supporting documentation that copying\n * and distribution is by permission of Carnegie Mellon and Stanford\n * University.  Carnegie Mellon makes no representations about the\n * suitability of this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n */\n#define PPP_ADDRESS\t0xff\t/* The address byte value */\n#define PPP_CONTROL\t0x03\t/* The control byte value */\n\n#define PPP_PPPD_IN\t0x00\t/* non-standard for DLT_PPP_PPPD */\n#define PPP_PPPD_OUT\t0x01\t/* non-standard for DLT_PPP_PPPD */\n\n/* Protocol numbers */\n#define PPP_IP\t\t0x0021\t/* Raw IP */\n#define PPP_OSI\t\t0x0023\t/* OSI Network Layer */\n#define PPP_NS\t\t0x0025\t/* Xerox NS IDP */\n#define PPP_DECNET\t0x0027\t/* DECnet Phase IV */\n#define PPP_APPLE\t0x0029\t/* Appletalk */\n#define PPP_IPX\t\t0x002b\t/* Novell IPX */\n#define PPP_VJC\t\t0x002d\t/* Van Jacobson Compressed TCP/IP */\n#define PPP_VJNC\t0x002f\t/* Van Jacobson Uncompressed TCP/IP */\n#define PPP_BRPDU\t0x0031\t/* Bridging PDU */\n#define PPP_STII\t0x0033\t/* Stream Protocol (ST-II) */\n#define PPP_VINES\t0x0035\t/* Banyan Vines */\n#define PPP_IPV6\t0x0057\t/* Internet Protocol version 6 */\n\n#define PPP_HELLO\t0x0201\t/* 802.1d Hello Packets */\n#define PPP_LUXCOM\t0x0231\t/* Luxcom */\n#define PPP_SNS\t\t0x0233\t/* Sigma Network Systems */\n#define PPP_MPLS_UCAST  0x0281  /* rfc 3032 */\n#define PPP_MPLS_MCAST  0x0283  /* rfc 3022 */\n\n#define PPP_IPCP\t0x8021\t/* IP Control Protocol */\n#define PPP_OSICP\t0x8023\t/* OSI Network Layer Control Protocol */\n#define PPP_NSCP\t0x8025\t/* Xerox NS IDP Control Protocol */\n#define PPP_DECNETCP\t0x8027\t/* DECnet Control Protocol */\n#define PPP_APPLECP\t0x8029\t/* Appletalk Control Protocol */\n#define PPP_IPXCP\t0x802b\t/* Novell IPX Control Protocol */\n#define PPP_STIICP\t0x8033\t/* Stream Protocol Control Protocol */\n#define PPP_VINESCP\t0x8035\t/* Banyan Vines Control Protocol */\n#define PPP_IPV6CP\t0x8057\t/* IPv6 Control Protocol */\n#define PPP_MPLSCP      0x8281  /* rfc 3022 */\n\n#define PPP_LCP\t\t0xc021\t/* Link Control Protocol */\n#define PPP_PAP\t\t0xc023\t/* Password Authentication Protocol */\n#define PPP_LQM\t\t0xc025\t/* Link Quality Monitoring */\n#define PPP_CHAP\t0xc223\t/* Challenge Handshake Authentication Protocol */\n"
        },
        {
          "name": "rpcap-protocol.c",
          "type": "blob",
          "size": 6.8330078125,
          "content": "/*\n * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino, CACE Technologies\n * nor the names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n#include <string.h>\t\t/* for strlen(), ... */\n#include <stdlib.h>\t\t/* for malloc(), free(), ... */\n#include <stdarg.h>\t\t/* for functions with variable number of arguments */\n#include <stdint.h>\t\t/* for intN_t and uintN_t types */\n#include <errno.h>\t\t/* for the errno variable */\n#include \"sockutils.h\"\n#include \"portability.h\"\n#include \"rpcap-protocol.h\"\n#include <pcap/pcap.h>\n\n/*\n * This file contains functions used both by the rpcap client and the\n * rpcap daemon.\n */\n\n/*\n * This function sends a RPCAP error to our peer.\n *\n * It has to be called when the main program detects an error.\n * It will send to our peer the 'buffer' specified by the user.\n * This function *does not* request a RPCAP CLOSE connection. A CLOSE\n * command must be sent explicitly by the program, since we do not know\n * whether the error can be recovered in some way or if it is a\n * non-recoverable one.\n *\n * \\param sock: the socket we are currently using.\n *\n * \\param ssl: if compiled with openssl, the optional ssl handler to use with the above socket.\n *\n * \\param ver: the protocol version we want to put in the reply.\n *\n * \\param errcode: a integer which tells the other party the type of error\n * we had.\n *\n * \\param error: an user-allocated (and '0' terminated) buffer that contains\n * the error description that has to be transmitted to our peer. The\n * error message cannot be longer than PCAP_ERRBUF_SIZE.\n *\n * \\param errbuf: a pointer to a user-allocated buffer (of size\n * PCAP_ERRBUF_SIZE) that will contain the error message (in case there\n * is one). It could be network problem.\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred. The\n * error message is returned in the 'errbuf' variable.\n */\nint\nrpcap_senderror(PCAP_SOCKET sock, SSL *ssl, uint8_t ver, unsigned short errcode, const char *error, char *errbuf)\n{\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tuint16_t length;\n\n\tlength = (uint16_t)strlen(error);\n\n\tif (length > PCAP_ERRBUF_SIZE)\n\t\tlength = PCAP_ERRBUF_SIZE;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver, RPCAP_MSG_ERROR, errcode, length);\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tif (sock_bufferize(error, length, sendbuf, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tif (sock_send(sock, ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * This function fills in a structure of type rpcap_header.\n *\n * It is provided just because the creation of an rpcap header is a common\n * task. It accepts all the values that appears into an rpcap_header, and\n * it puts them in place using the proper hton() calls.\n *\n * \\param header: a pointer to a user-allocated buffer which will contain\n * the serialized header, ready to be sent on the network.\n *\n * \\param ver: a value (in the host byte order) which will be placed into the\n * header.ver field and that represents the protocol version number of the\n * current message.\n *\n * \\param type: a value (in the host byte order) which will be placed into the\n * header.type field and that represents the type of the current message.\n *\n * \\param value: a value (in the host byte order) which will be placed into\n * the header.value field and that has a message-dependent meaning.\n *\n * \\param length: a value (in the host by order) which will be placed into\n * the header.length field, representing the payload length of the message.\n *\n * \\return Nothing. The serialized header is returned into the 'header'\n * variable.\n */\nvoid\nrpcap_createhdr(struct rpcap_header *header, uint8_t ver, uint8_t type, uint16_t value, uint32_t length)\n{\n\tmemset(header, 0, sizeof(struct rpcap_header));\n\n\theader->ver = ver;\n\theader->type = type;\n\theader->value = htons(value);\n\theader->plen = htonl(length);\n}\n\n/*\n * Convert a message type to a string containing the type name.\n */\nstatic const char *requests[] =\n{\n\tNULL,\t\t\t\t/* not a valid message type */\n\t\"RPCAP_MSG_ERROR\",\n\t\"RPCAP_MSG_FINDALLIF_REQ\",\n\t\"RPCAP_MSG_OPEN_REQ\",\n\t\"RPCAP_MSG_STARTCAP_REQ\",\n\t\"RPCAP_MSG_UPDATEFILTER_REQ\",\n\t\"RPCAP_MSG_CLOSE\",\n\t\"RPCAP_MSG_PACKET\",\n\t\"RPCAP_MSG_AUTH_REQ\",\n\t\"RPCAP_MSG_STATS_REQ\",\n\t\"RPCAP_MSG_ENDCAP_REQ\",\n\t\"RPCAP_MSG_SETSAMPLING_REQ\",\n};\n#define NUM_REQ_TYPES\t(sizeof requests / sizeof requests[0])\n\nstatic const char *replies[] =\n{\n\tNULL,\n\tNULL,\t\t\t/* this would be a reply to RPCAP_MSG_ERROR */\n\t\"RPCAP_MSG_FINDALLIF_REPLY\",\n\t\"RPCAP_MSG_OPEN_REPLY\",\n\t\"RPCAP_MSG_STARTCAP_REPLY\",\n\t\"RPCAP_MSG_UPDATEFILTER_REPLY\",\n\tNULL,\t\t\t/* this would be a reply to RPCAP_MSG_CLOSE */\n\tNULL,\t\t\t/* this would be a reply to RPCAP_MSG_PACKET */\n\t\"RPCAP_MSG_AUTH_REPLY\",\n\t\"RPCAP_MSG_STATS_REPLY\",\n\t\"RPCAP_MSG_ENDCAP_REPLY\",\n\t\"RPCAP_MSG_SETSAMPLING_REPLY\",\n};\n#define NUM_REPLY_TYPES\t(sizeof replies / sizeof replies[0])\n\nconst char *\nrpcap_msg_type_string(uint8_t type)\n{\n\tif (type & RPCAP_MSG_IS_REPLY) {\n\t\ttype &= ~RPCAP_MSG_IS_REPLY;\n\t\tif (type >= NUM_REPLY_TYPES)\n\t\t\treturn NULL;\n\t\treturn replies[type];\n\t} else {\n\t\tif (type >= NUM_REQ_TYPES)\n\t\t\treturn NULL;\n\t\treturn requests[type];\n\t}\n}\n"
        },
        {
          "name": "rpcap-protocol.h",
          "type": "blob",
          "size": 19.482421875,
          "content": "/*\n * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)\n * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino, CACE Technologies\n * nor the names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __RPCAP_PROTOCOL_H__\n#define __RPCAP_PROTOCOL_H__\n\n#define RPCAP_DEFAULT_NETPORT \"2002\" /* Default port on which the RPCAP daemon is waiting for connections. */\n/* Default port on which the client workstation is waiting for connections in case of active mode. */\n#define RPCAP_DEFAULT_NETPORT_ACTIVE \"2003\"\n#define RPCAP_DEFAULT_NETADDR \"\"\t/* Default network address on which the RPCAP daemon binds to. */\n\n/*\n * Minimum and maximum supported versions of the protocol.\n *\n * If new message types are added, the protocol version MUST be changed,\n * so that a client knows, from the negotiated protocol version, what\n * messages can be sent to the server.\n *\n * If the format of an existing message type is changed, the protocol\n * version MUST be changed, so that each side knows, from the negotiated\n * protocol version, what format should be used.\n *\n * The RPCAP_MSG_ERROR format MUST not change, as it's used to, among\n * other things, report \"incorrect version number\" errors, where, if\n * the format changed, the sender of the message might not know what\n * versions the recipient would understand, or might know a version\n * they support (the version number they sent) but might not know\n * the format of the message in that version.\n *\n * Other message versions SHOULD not change, as that would complicate\n * the process of interpreting the message, making it version-dependent.\n * Introducing a new message with a new format is preferable.\n *\n * Version negotiation is done as part of the authentication process:\n *\n * The client sends an authentication request, with a version number\n * of 0.  All servers must accept authentication requests with a version\n * number of 0, even if they don't support version 0 for any other\n * requests.\n *\n * The server attempts to authenticate the client.  If that succeeds,\n * older servers - which only support version 0 - will send an\n * authentication reply with no payload.  Newer servers - which might\n * support other versions - will send an authentication reply with\n * a payload giving the minimum and maximum versions it supports.\n *\n * The client attempts to find the largest version number that is\n * in both its range of supported versions and the server's supported\n * versions.  If it fails, it gives up; otherwise, it uses that version.\n */\n#define RPCAP_MIN_VERSION 0\n#define RPCAP_MAX_VERSION 0\n\n/*\n * Version numbers are unsigned, so if RPCAP_MIN_VERSION is 0, they\n * are >= the minimum version, by definition; don't check against\n * RPCAP_MIN_VERSION, as you may get compiler warnings that the\n * comparison will always succeed.\n */\n#if RPCAP_MIN_VERSION == 0\n#define RPCAP_VERSION_IS_SUPPORTED(v)\t\\\n\t((v) <= RPCAP_MAX_VERSION)\n#else\n#define RPCAP_VERSION_IS_SUPPORTED(v)\t\\\n\t((v) >= RPCAP_MIN_VERSION && (v) <= RPCAP_MAX_VERSION)\n#endif\n\n/*\n * Separators used for the host list.\n *\n * It is used:\n * - by the rpcapd daemon, when you types a list of allowed connecting hosts\n * - by the rpcap client in active mode, when the client waits for incoming\n * connections from other hosts\n */\n#define RPCAP_HOSTLIST_SEP \" ,;\\n\\r\"\n\n/*********************************************************\n *                                                       *\n * Protocol messages formats                             *\n *                                                       *\n *********************************************************/\n/*\n * WARNING: This file defines some structures that are used to transfer\n * data on the network.\n * Note that your compiler MUST not insert padding into these structures\n * for better alignment.\n * These structures have been created in order to be correctly aligned to\n * a 32-bit boundary, but be careful in any case.\n *\n * The layout of these structures MUST not be changed.  If a packet\n * format is different in different versions of the protocol, versions\n * of the structure should be provided for all the different versions or\n * version ranges (if more than one version of the protocol has the same\n * layout) that we support.\n *\n * We use the C99 intN_t and uintN_t types to indicate fields that are\n * exactly N bits long on the network.  Do not use types that might\n * differ in their lengths.\n *\n * XXX - both libpcap and programs that use it will require significant\n * work if you have machines where integral data types are not multiples\n * of 8-bit bytes.  If, for example, you're trying to get this to work\n * on a PDP-10x, good luck.\n */\n\n/* Common header for all the RPCAP messages */\nstruct rpcap_header\n{\n\tuint8_t ver;\t\t/* RPCAP version number */\n\tuint8_t type;\t\t/* RPCAP message type (error, findalldevs, ...) */\n\tuint16_t value;\t\t/* Message-dependent value (not always used) */\n\tuint32_t plen;\t\t/* Length of the payload of this RPCAP message */\n};\n\n/*\n * Format of data that may appear at the end of an authentication reply,\n * giving the minimum and maximum versions of the protocol that the\n * server supports.\n *\n * Older servers don't provide this; they support only version 0.\n */\nstruct rpcap_authreply\n{\n\tuint8_t minvers;\t\t/* Minimum version supported */\n\tuint8_t maxvers;\t\t/* Maximum version supported */\n\tuint8_t pad[2];\t\t\t/* Pad to 4-byte boundary **/\n\tuint32_t byte_order_magic;\t/* RPCAP_BYTE_ORDER_MAGIC, in server byte order */\n};\n\n/*\n * Any resemblance between this and the pcap file magic number\n * is purely coincidental, trust me.\n */\n#define RPCAP_BYTE_ORDER_MAGIC\t\t0xa1b2c3d4U\n#define RPCAP_BYTE_ORDER_MAGIC_SWAPPED\t0xd4c3b2a1U\n\n/*\n * Older version of authentication reply, without byte order indication\n * and padding.\n */\nstruct rpcap_authreply_old\n{\n\tuint8_t minvers;\t/* Minimum version supported */\n\tuint8_t maxvers;\t/* Maximum version supported */\n};\n\n/* Format of the message for the interface description (findalldevs command) */\nstruct rpcap_findalldevs_if\n{\n\tuint16_t namelen;\t/* Length of the interface name */\n\tuint16_t desclen;\t/* Length of the interface description */\n\tuint32_t flags;\t\t/* Interface flags */\n\tuint16_t naddr;\t\t/* Number of addresses */\n\tuint16_t dummy;\t\t/* Must be zero */\n};\n\n/*\n * Format of an address as sent over the wire.\n *\n * Do *NOT* use struct sockaddr_storage, as the layout for that is\n * machine-dependent.\n *\n * RFC 2553 gives two sample layouts, both of which are 128 bytes long,\n * both of which are aligned on an 8-byte boundary, and both of which\n * have 2 bytes before the address data.\n *\n * However, one has a 2-byte address family value at the beginning\n * and the other has a 1-byte address length value and a 1-byte\n * address family value; this reflects the fact that the original\n * BSD sockaddr structure had a 2-byte address family value, which\n * was later changed to a 1-byte address length value and a 1-byte\n * address family value, when support for variable-length OSI\n * network-layer addresses was added.\n *\n * Furthermore, Solaris's struct sockaddr_storage is 256 bytes\n * long.\n *\n * This structure is supposed to be aligned on an 8-byte boundary;\n * the message header is 8 bytes long, so we don't have to do\n * anything to ensure it's aligned on that boundary within a packet,\n * so we just define it as 128 bytes long, with a 2-byte address\n * family.  (We only support IPv4 and IPv6 addresses, which are fixed-\n * length.)  That way, it's the same size as sockaddr_storage on\n * Windows, and it'll look like what an older Windows client will\n * expect.\n *\n * In addition, do *NOT* use the host's AF_ value for an address,\n * as the value for AF_INET6 is machine-dependent.  We use the\n * Windows value, so it'll look like what an older Windows client\n * will expect.\n *\n * (The Windows client is the only one that has been distributed\n * as a standard part of *pcap; UN*X clients are probably built\n * from source by the user or administrator, so they're in a\n * better position to upgrade an old client.  Therefore, we\n * try to make what goes over the wire look like what comes\n * from a Windows server.)\n */\nstruct rpcap_sockaddr\n{\n\tuint16_t\tfamily;\t\t/* Address family */\n\tchar\t\tdata[128-2];\t/* Data */\n};\n\n/*\n * Format of an IPv4 address as sent over the wire.\n */\n#define RPCAP_AF_INET\t2\t\t/* Value on all OSes except for Haiku */\nstruct rpcap_sockaddr_in\n{\n\tuint16_t family;\t/* Address family */\n\tuint16_t port;\t\t/* Port number */\n\tuint32_t addr;\t\t/* IPv4 address */\n\tuint8_t\t zero[8];\t/* Padding */\n};\n\n/*\n * Format of an IPv6 address as sent over the wire.\n */\n#define RPCAP_AF_INET6\t23\t\t/* Value on Windows */\nstruct rpcap_sockaddr_in6\n{\n\tuint16_t family;\t\t/* Address family */\n\tuint16_t port;\t\t/* Port number */\n\tuint32_t flowinfo;\t/* IPv6 flow information */\n\tuint8_t  addr[16];\t/* IPv6 address */\n\tuint32_t scope_id;\t/* Scope zone index */\n};\n\n/* Format of the message for the address listing (findalldevs command) */\nstruct rpcap_findalldevs_ifaddr\n{\n\tstruct rpcap_sockaddr addr;\t\t/* Network address */\n\tstruct rpcap_sockaddr netmask;\t\t/* Netmask for that address */\n\tstruct rpcap_sockaddr broadaddr;\t/* Broadcast address for that address */\n\tstruct rpcap_sockaddr dstaddr;\t\t/* P2P destination address for that address */\n};\n\n/*\n * \\brief Format of the message of the connection opening reply (open command).\n *\n * This structure transfers over the network some of the values useful on the client side.\n */\nstruct rpcap_openreply\n{\n\tint32_t\tlinktype;\t/* Link type */\n\tint32_t\ttzoff;\t\t/* Timezone offset - not used by newer clients */\n};\n\n/* Format of the message that starts a remote capture (startcap command) */\nstruct rpcap_startcapreq\n{\n\tuint32_t snaplen;\t/* Length of the snapshot (number of bytes to capture for each packet) */\n\tuint32_t read_timeout;\t/* Read timeout in milliseconds */\n\tuint16_t flags;\t\t/* Flags (see RPCAP_STARTCAPREQ_FLAG_xxx) */\n\tuint16_t portdata;\t/* Network port on which the client is waiting at (if 'serveropen') */\n};\n\n/* Format of the reply message that devoted to start a remote capture (startcap reply command) */\nstruct rpcap_startcapreply\n{\n\tint32_t\t bufsize;\t/* Size of the user buffer allocated by WinPcap; it can be different from the one we chose */\n\tuint16_t portdata;\t/* Network port on which the server is waiting at (passive mode only) */\n\tuint16_t dummy;\t\t/* Must be zero */\n};\n\n/*\n * \\brief Format of the header which encapsulates captured packets when transmitted on the network.\n *\n * This message requires the general header as well, since we want to be able to exchange\n * more information across the network in the future (for example statistics, and kind like that).\n */\nstruct rpcap_pkthdr\n{\n\t/*\n\t * This protocol needs to be updated with a new version before\n\t * 2038-01-19 03:14:07 UTC.\n\t */\n\tuint32_t timestamp_sec;\t\t/* 'struct timeval' compatible, it represents the 'tv_sec' field */\n\tuint32_t timestamp_usec;\t/* 'struct timeval' compatible, it represents the 'tv_usec' field */\n\tuint32_t caplen;\t\t/* Length of portion present in the capture */\n\tuint32_t len;\t\t\t/* Real length of this packet (off wire) */\n\tuint32_t npkt;\t\t\t/* Ordinal number of the packet (i.e. the first one captured has '1', the second one '2', etc) */\n};\n\n/* General header used for the pcap_setfilter() command; keeps just the number of BPF instructions */\nstruct rpcap_filter\n{\n\tuint16_t filtertype;\t/* type of the filter transferred (BPF instructions, ...) */\n\tuint16_t dummy;\t\t/* Must be zero */\n\tuint32_t nitems;\t/* Number of items contained into the filter (e.g. BPF instructions for BPF filters) */\n};\n\n/* Structure that keeps a single BPF instruction; it is repeated 'ninsn' times according to the 'rpcap_filterbpf' header */\nstruct rpcap_filterbpf_insn\n{\n\tuint16_t\tcode;\t/* opcode of the instruction */\n\tuint8_t\t\tjt;\t/* relative offset to jump to in case of 'true' */\n\tuint8_t\t\tjf;\t/* relative offset to jump to in case of 'false' */\n\tint32_t\t\tk;\t/* instruction-dependent value */\n};\n\n/* Structure that keeps the data required for the authentication on the remote host */\nstruct rpcap_auth\n{\n\tuint16_t type;\t/* Authentication type */\n\tuint16_t dummy;\t/* Must be zero */\n\tuint16_t slen1;\t/* Length of the first authentication item (e.g. username) */\n\tuint16_t slen2;\t/* Length of the second authentication item (e.g. password) */\n};\n\n/* Structure that keeps the statistics about the number of packets captured, dropped, etc. */\nstruct rpcap_stats\n{\n\tuint32_t ifrecv;\t/* Packets received by the kernel filter (i.e. pcap_stats.ps_recv) */\n\tuint32_t ifdrop;\t/* Packets dropped by the network interface (e.g. not enough buffers) (i.e. pcap_stats.ps_ifdrop) */\n\tuint32_t krnldrop;\t/* Packets dropped by the kernel filter (i.e. pcap_stats.ps_drop) */\n\tuint32_t svrcapt;\t/* Packets captured by the RPCAP daemon and sent on the network */\n};\n\n/* Structure that is needed to set sampling parameters */\nstruct rpcap_sampling\n{\n\tuint8_t  method;\t/* Sampling method */\n\tuint8_t  dummy1;\t/* Must be zero */\n\tuint16_t dummy2;\t/* Must be zero */\n\tuint32_t value;\t\t/* Parameter related to the sampling method */\n};\n\n/*\n * Messages field coding.\n *\n * These values are used in messages sent over the network, and MUST\n * not be changed.\n */\n#define RPCAP_MSG_IS_REPLY\t\t0x080\t/* Flag indicating a reply */\n\n#define RPCAP_MSG_ERROR\t\t\t0x01\t/* Message that keeps an error notification */\n#define RPCAP_MSG_FINDALLIF_REQ\t\t0x02\t/* Request to list all the remote interfaces */\n#define RPCAP_MSG_OPEN_REQ\t\t0x03\t/* Request to open a remote device */\n#define RPCAP_MSG_STARTCAP_REQ\t\t0x04\t/* Request to start a capture on a remote device */\n#define RPCAP_MSG_UPDATEFILTER_REQ\t0x05\t/* Send a compiled filter into the remote device */\n#define RPCAP_MSG_CLOSE\t\t\t0x06\t/* Close the connection with the remote peer */\n#define RPCAP_MSG_PACKET\t\t0x07\t/* This is a 'data' message, which carries a network packet */\n#define RPCAP_MSG_AUTH_REQ\t\t0x08\t/* Message that keeps the authentication parameters */\n#define RPCAP_MSG_STATS_REQ\t\t0x09\t/* It requires to have network statistics */\n#define RPCAP_MSG_ENDCAP_REQ\t\t0x0A\t/* Stops the current capture, keeping the device open */\n#define RPCAP_MSG_SETSAMPLING_REQ\t0x0B\t/* Set sampling parameters */\n\n#define RPCAP_MSG_FINDALLIF_REPLY\t(RPCAP_MSG_FINDALLIF_REQ | RPCAP_MSG_IS_REPLY)\t\t/* Keeps the list of all the remote interfaces */\n#define RPCAP_MSG_OPEN_REPLY\t\t(RPCAP_MSG_OPEN_REQ | RPCAP_MSG_IS_REPLY)\t\t/* The remote device has been opened correctly */\n#define RPCAP_MSG_STARTCAP_REPLY\t(RPCAP_MSG_STARTCAP_REQ | RPCAP_MSG_IS_REPLY)\t\t/* The capture is starting correctly */\n#define RPCAP_MSG_UPDATEFILTER_REPLY\t(RPCAP_MSG_UPDATEFILTER_REQ | RPCAP_MSG_IS_REPLY)\t/* The filter has been applied correctly on the remote device */\n#define RPCAP_MSG_AUTH_REPLY\t\t(RPCAP_MSG_AUTH_REQ | RPCAP_MSG_IS_REPLY)\t\t/* Sends a message that says 'ok, authorization successful' */\n#define RPCAP_MSG_STATS_REPLY\t\t(RPCAP_MSG_STATS_REQ | RPCAP_MSG_IS_REPLY)\t\t/* Message that keeps the network statistics */\n#define RPCAP_MSG_ENDCAP_REPLY\t\t(RPCAP_MSG_ENDCAP_REQ | RPCAP_MSG_IS_REPLY)\t\t/* Confirms that the capture stopped successfully */\n#define RPCAP_MSG_SETSAMPLING_REPLY\t(RPCAP_MSG_SETSAMPLING_REQ | RPCAP_MSG_IS_REPLY)\t\t/* Confirms that the capture stopped successfully */\n\n#define RPCAP_STARTCAPREQ_FLAG_PROMISC\t\t0x00000001\t/* Enables promiscuous mode (default: disabled) */\n#define RPCAP_STARTCAPREQ_FLAG_DGRAM\t\t0x00000002\t/* Use a datagram (i.e. UDP) connection for the data stream (default: use TCP)*/\n#define RPCAP_STARTCAPREQ_FLAG_SERVEROPEN\t0x00000004\t/* The server has to open the data connection toward the client */\n#define RPCAP_STARTCAPREQ_FLAG_INBOUND\t\t0x00000008\t/* Capture only inbound packets (take care: the flag has no effect with promiscuous enabled) */\n#define RPCAP_STARTCAPREQ_FLAG_OUTBOUND\t\t0x00000010\t/* Capture only outbound packets (take care: the flag has no effect with promiscuous enabled) */\n\n#define RPCAP_UPDATEFILTER_BPF 1\t\t\t/* This code tells us that the filter is encoded with the BPF/NPF syntax */\n\n/*\n * Network error codes.\n *\n * These values are used in messages sent over the network, and MUST\n * not be changed.\n */\n#define PCAP_ERR_NETW\t\t\t1\t/* Network error */\n#define PCAP_ERR_INITTIMEOUT\t\t2\t/* The RPCAP initial timeout has expired */\n#define PCAP_ERR_AUTH\t\t\t3\t/* Generic authentication error */\n#define PCAP_ERR_FINDALLIF\t\t4\t/* Generic findalldevs error */\n#define PCAP_ERR_NOREMOTEIF\t\t5\t/* The findalldevs was ok, but the remote end had no interfaces to list */\n#define PCAP_ERR_OPEN\t\t\t6\t/* Generic pcap_open error */\n#define PCAP_ERR_UPDATEFILTER\t\t7\t/* Generic updatefilter error */\n#define PCAP_ERR_GETSTATS\t\t8\t/* Generic pcap_stats error */\n#define PCAP_ERR_READEX\t\t\t9\t/* Generic pcap_next_ex error */\n#define PCAP_ERR_HOSTNOAUTH\t\t10\t/* The host is not authorized to connect to this server */\n#define PCAP_ERR_REMOTEACCEPT\t\t11\t/* Generic pcap_remoteaccept error */\n#define PCAP_ERR_STARTCAPTURE\t\t12\t/* Generic pcap_startcapture error */\n#define PCAP_ERR_ENDCAPTURE\t\t13\t/* Generic pcap_endcapture error */\n#define PCAP_ERR_RUNTIMETIMEOUT\t\t14\t/* The RPCAP run-time timeout has expired */\n#define PCAP_ERR_SETSAMPLING\t\t15\t/* Error during the settings of sampling parameters */\n#define PCAP_ERR_WRONGMSG\t\t16\t/* The other end endpoint sent a message which has not been recognized */\n#define PCAP_ERR_WRONGVER\t\t17\t/* The other end endpoint has a version number that is not compatible with our */\n#define PCAP_ERR_AUTH_FAILED\t\t18\t/* The user couldn't be authenticated */\n#define PCAP_ERR_TLS_REQUIRED\t\t19\t/* The server requires TLS to connect */\n#define PCAP_ERR_AUTH_TYPE_NOTSUP\t20\t/* The authentication type isn't supported */\n\n/*\n * \\brief Buffer used by socket functions to send-receive packets.\n * In case you plan to have messages larger than this value, you have to increase it.\n */\n#define RPCAP_NETBUF_SIZE 64000\n\n/*********************************************************\n *                                                       *\n * Routines used by the rpcap client and rpcap daemon    *\n *                                                       *\n *********************************************************/\n\n#include \"sockutils.h\"\n#include \"sslutils.h\"\n\nextern void rpcap_createhdr(struct rpcap_header *header, uint8_t ver, uint8_t type, uint16_t value, uint32_t length);\nextern const char *rpcap_msg_type_string(uint8_t type);\nextern int rpcap_senderror(PCAP_SOCKET sock, SSL *ssl, uint8_t ver, uint16_t errcode, const char *error, char *errbuf);\n\n#endif\n"
        },
        {
          "name": "rpcapd",
          "type": "tree",
          "content": null
        },
        {
          "name": "savefile.c",
          "type": "blob",
          "size": 17.0947265625,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * savefile.c - supports offline use of tcpdump\n *\tExtraction/creation by Jeffrey Mogul, DECWRL\n *\tModified by Steve McCanne, LBL.\n *\n * Used to save the received packet headers, after filtering, to\n * a file, and then read them later.\n * The first record in the file contains saved values for the machine\n * dependent values so we can print the dump file on any architecture.\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n#ifdef _WIN32\n#include <io.h>\n#include <fcntl.h>\n#endif /* _WIN32 */\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h> /* for INT_MAX */\n\n#include \"pcap-int.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"sf-pcap.h\"\n#include \"sf-pcapng.h\"\n#include \"pcap-common.h\"\n#include \"charconv.h\"\n\n#ifdef _WIN32\n/*\n * This isn't exported on Windows, because it would only work if both\n * WinPcap/Npcap and the code using it were to use the Universal CRT; otherwise,\n * a FILE structure in WinPcap/Npcap and a FILE structure in the code using it\n * could be different if they're using different versions of the C runtime.\n *\n * Instead, pcap/pcap.h defines it as a macro that wraps the hopen version,\n * with the wrapper calling _fileno() and _get_osfhandle() themselves,\n * so that it convert the appropriate CRT version's FILE structure to\n * a HANDLE (which is OS-defined, not CRT-defined, and is part of the Win32\n * and Win64 ABIs).\n */\nstatic pcap_t *pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *);\n#endif\n\n/*\n * Setting O_BINARY on Windows is a bit tricky.\n */\n#if defined(_WIN32)\n  #define SET_BINMODE(f)  _setmode(_fileno(f), _O_BINARY)\n#endif\n\nstatic int\nsf_getnonblock(pcap_t *p _U_)\n{\n\t/*\n\t * This is a savefile, not a live capture file, so never say\n\t * it's in non-blocking mode.\n\t */\n\treturn (0);\n}\n\nstatic int\nsf_setnonblock(pcap_t *p, int nonblock _U_)\n{\n\t/*\n\t * This is a savefile, not a live capture file, so reject\n\t * requests to put it in non-blocking mode.  (If it's a\n\t * pipe, it could be put in non-blocking mode, but that\n\t * would significantly complicate the code to read packets,\n\t * as it would have to handle reading partial packets and\n\t * keeping the state of the read.)\n\t */\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Savefiles cannot be put into non-blocking mode\");\n\treturn (-1);\n}\n\nstatic int\nsf_cant_set_rfmon(pcap_t *p _U_)\n{\n\t/*\n\t * This is a savefile, not a device on which you can capture,\n\t * so never say it supports being put into monitor mode.\n\t */\n\treturn (0);\n}\n\nstatic int\nsf_stats(pcap_t *p, struct pcap_stat *ps _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from savefiles\");\n\treturn (-1);\n}\n\n#ifdef _WIN32\nstatic struct pcap_stat *\nsf_stats_ex(pcap_t *p, int *size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from savefiles\");\n\treturn (NULL);\n}\n\nstatic int\nsf_setbuff(pcap_t *p, int dim _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The kernel buffer size cannot be set while reading from a file\");\n\treturn (-1);\n}\n\nstatic int\nsf_setmode(pcap_t *p, int mode _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"impossible to set mode while reading from a file\");\n\treturn (-1);\n}\n\nstatic int\nsf_setmintocopy(pcap_t *p, int size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The mintocopy parameter cannot be set while reading from a file\");\n\treturn (-1);\n}\n\nstatic HANDLE\nsf_getevent(pcap_t *pcap)\n{\n\t(void)snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t    \"The read event cannot be retrieved while reading from a file\");\n\treturn (INVALID_HANDLE_VALUE);\n}\n\nstatic int\nsf_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,\n    size_t *lenp _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID get request cannot be performed on a file\");\n\treturn (PCAP_ERROR);\n}\n\nstatic int\nsf_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,\n    size_t *lenp _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID set request cannot be performed on a file\");\n\treturn (PCAP_ERROR);\n}\n\nstatic u_int\nsf_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)\n{\n\tpcapint_strlcpy(p->errbuf, \"Sending packets isn't supported on savefiles\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (0);\n}\n\nstatic int\nsf_setuserbuffer(pcap_t *p, int size _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The user buffer cannot be set when reading from a file\");\n\treturn (-1);\n}\n\nstatic int\nsf_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_, int maxpacks _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed when reading from a file\");\n\treturn (-1);\n}\n\nstatic int\nsf_live_dump_ended(pcap_t *p, int sync _U_)\n{\n\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}\n#endif\n\nstatic int\nsf_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\tpcapint_strlcpy(p->errbuf, \"Sending packets isn't supported on savefiles\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}\n\n/*\n * Set direction flag: Which packets do we accept on a forwarding\n * single device? IN, OUT or both?\n */\nstatic int\nsf_setdirection(pcap_t *p, pcap_direction_t d _U_)\n{\n\tsnprintf(p->errbuf, sizeof(p->errbuf),\n\t    \"Setting direction is not supported on savefiles\");\n\treturn (-1);\n}\n\nvoid\npcapint_sf_cleanup(pcap_t *p)\n{\n\tif (p->rfile != stdin)\n\t\t(void)fclose(p->rfile);\n\tif (p->buffer != NULL)\n\t\tfree(p->buffer);\n\tpcap_freecode(&p->fcode);\n}\n\n#ifdef _WIN32\n/*\n * Wrapper for fopen() and _wfopen().\n *\n * If we're in UTF-8 mode, map the pathname from UTF-8 to UTF-16LE and\n * call _wfopen().\n *\n * If we're not, just use fopen(); that'll treat it as being in the\n * local code page.\n */\nFILE *\npcapint_charset_fopen(const char *path, const char *mode)\n{\n\twchar_t *utf16_path;\n#define MAX_MODE_LEN\t16\n\twchar_t utf16_mode[MAX_MODE_LEN+1];\n\tint i;\n\tchar c;\n\tFILE *fp;\n\tint save_errno;\n\n\tif (pcapint_utf_8_mode) {\n\t\t/*\n\t\t * Map from UTF-8 to UTF-16LE.\n\t\t * Fail if there are invalid characters in the input\n\t\t * string, rather than converting them to REPLACEMENT\n\t\t * CHARACTER; the latter is appropriate for strings\n\t\t * to be displayed to the user, but for file names\n\t\t * you just want the attempt to open the file to fail.\n\t\t */\n\t\tutf16_path = cp_to_utf_16le(CP_UTF8, path,\n\t\t    MB_ERR_INVALID_CHARS);\n\t\tif (utf16_path == NULL) {\n\t\t\t/*\n\t\t\t * Error.  Assume errno has been set.\n\t\t\t *\n\t\t\t * XXX - what about Windows errors?\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t/*\n\t\t * Now convert the mode to UTF-16LE as well.\n\t\t * We assume the mode is ASCII, and that\n\t\t * it's short, so that's easy.\n\t\t */\n\t\tfor (i = 0; (c = *mode) != '\\0'; i++, mode++) {\n\t\t\tif (c > 0x7F) {\n\t\t\t\t/* Not an ASCII character; fail with EINVAL. */\n\t\t\t\tfree(utf16_path);\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tif (i >= MAX_MODE_LEN) {\n\t\t\t\t/* The mode string is longer than we allow. */\n\t\t\t\tfree(utf16_path);\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tutf16_mode[i] = c;\n\t\t}\n\t\tutf16_mode[i] = '\\0';\n\n\t\t/*\n\t\t * OK, we have UTF-16LE strings; hand them to\n\t\t * _wfopen().\n\t\t */\n\t\tfp = _wfopen(utf16_path, utf16_mode);\n\n\t\t/*\n\t\t * Make sure freeing the UTF-16LE string doesn't\n\t\t * overwrite the error code we got from _wfopen().\n\t\t */\n\t\tsave_errno = errno;\n\t\tfree(utf16_path);\n\t\terrno = save_errno;\n\n\t\treturn (fp);\n\t} else {\n\t\t/*\n\t\t * This takes strings in the local code page as an\n\t\t * argument.\n\t\t */\n\t\treturn (fopen(path, mode));\n\t}\n}\n#endif\n\npcap_t *\npcap_open_offline_with_tstamp_precision(const char *fname, u_int precision,\n\t\t\t\t\tchar *errbuf)\n{\n\tFILE *fp;\n\tpcap_t *p;\n\n\tif (fname == NULL) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn (NULL);\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0')\n\t{\n\t\tfp = stdin;\n\t\tif (fp == NULL) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The standard input is not open\");\n\t\t\treturn (NULL);\n\t\t}\n#if defined(_WIN32)\n\t\t/*\n\t\t * We're reading from the standard input, so put it in binary\n\t\t * mode, as savefiles are binary files.\n\t\t */\n\t\tSET_BINMODE(fp);\n#endif\n\t}\n\telse {\n\t\t/*\n\t\t * Use pcapint_charset_fopen(); on Windows, it tests whether we're\n\t\t * in \"local code page\" or \"UTF-8\" mode, and treats the\n\t\t * pathname appropriately, and on other platforms, it just\n\t\t * wraps fopen().\n\t\t *\n\t\t * \"b\" is supported as of C90, so *all* UN*Xes should\n\t\t * support it, even though it does nothing.\n\t\t */\n\t\tfp = pcapint_charset_fopen(fname, \"rb\");\n\t\tif (fp == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tp = pcap_fopen_offline_with_tstamp_precision(fp, precision, errbuf);\n\tif (p == NULL) {\n\t\tif (fp != stdin)\n\t\t\tfclose(fp);\n\t}\n\treturn (p);\n}\n\npcap_t *\npcap_open_offline(const char *fname, char *errbuf)\n{\n\treturn (pcap_open_offline_with_tstamp_precision(fname,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf));\n}\n\n#ifdef _WIN32\npcap_t* pcap_hopen_offline_with_tstamp_precision(intptr_t osfd, u_int precision,\n    char *errbuf)\n{\n\tint fd;\n\tFILE *file;\n\n\tfd = _open_osfhandle(osfd, _O_RDONLY);\n\tif ( fd < 0 )\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_open_osfhandle\");\n\t\treturn NULL;\n\t}\n\n\tfile = _fdopen(fd, \"rb\");\n\tif ( file == NULL )\n\t{\n\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_fdopen\");\n\t\t_close(fd);\n\t\treturn NULL;\n\t}\n\n\treturn pcap_fopen_offline_with_tstamp_precision(file, precision,\n\t    errbuf);\n}\n\npcap_t* pcap_hopen_offline(intptr_t osfd, char *errbuf)\n{\n\treturn pcap_hopen_offline_with_tstamp_precision(osfd,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf);\n}\n#endif\n\n/*\n * Given a link-layer header type and snapshot length, return a\n * snapshot length to use when reading the file; it's guaranteed\n * to be > 0 and <= INT_MAX.\n *\n * XXX - the only reason why we limit it to <= INT_MAX is so that\n * it fits in p->snapshot, and the only reason that p->snapshot is\n * signed is that pcap_snapshot() returns an int, not an unsigned int.\n */\nbpf_u_int32\npcapint_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen)\n{\n\tif (snaplen == 0 || snaplen > INT_MAX) {\n\t\t/*\n\t\t * Bogus snapshot length; use the maximum for this\n\t\t * link-layer type as a fallback.\n\t\t *\n\t\t * XXX - we don't clamp snapshot lengths that are\n\t\t * <= INT_MAX but > max_snaplen_for_dlt(linktype),\n\t\t * so a capture file could cause us to allocate\n\t\t * a Really Big Buffer.\n\t\t */\n\t\tsnaplen = max_snaplen_for_dlt(linktype);\n\t}\n\treturn snaplen;\n}\n\nstatic pcap_t *(*check_headers[])(const uint8_t *, FILE *, u_int, char *, int *) = {\n\tpcap_check_header,\n\tpcap_ng_check_header\n};\n\n#define\tN_FILE_TYPES\t(sizeof check_headers / sizeof check_headers[0])\n\n#ifdef _WIN32\nstatic\n#endif\npcap_t *\npcap_fopen_offline_with_tstamp_precision(FILE *fp, u_int precision,\n    char *errbuf)\n{\n\tregister pcap_t *p;\n\tuint8_t magic[4];\n\tsize_t amt_read;\n\tu_int i;\n\tint err;\n\n\t/*\n\t * Fail if we were passed a NULL fp.\n\t *\n\t * That shouldn't happen if we're opening with a path name, but\n\t * it could happen if buggy code is opening with a FILE * and\n\t * didn't bother to make sure the FILE * isn't null.\n\t */\n\tif (fp == NULL) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Null FILE * pointer provided to savefile open routine\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Read the first 4 bytes of the file; the network analyzer dump\n\t * file formats we support (pcap and pcapng), and several other\n\t * formats we might support in the future (such as snoop, DOS and\n\t * Windows Sniffer, and Microsoft Network Monitor) all have magic\n\t * numbers that are unique in their first 4 bytes.\n\t */\n\tamt_read = fread(&magic, 1, sizeof(magic), fp);\n\tif (amt_read != sizeof(magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %zu file header bytes, only got %zu\",\n\t\t\t    sizeof(magic), amt_read);\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try all file types.\n\t */\n\tfor (i = 0; i < N_FILE_TYPES; i++) {\n\t\tp = (*check_headers[i])(magic, fp, precision, errbuf, &err);\n\t\tif (p != NULL) {\n\t\t\t/* Yup, that's it. */\n\t\t\tgoto found;\n\t\t}\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Error trying to read the header.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/*\n\t * Well, who knows what this mess is....\n\t */\n\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"unknown file format\");\n\treturn (NULL);\n\nfound:\n\tp->rfile = fp;\n\n\t/* Padding only needed for live capture fcode */\n\tp->fddipad = 0;\n\n#if !defined(_WIN32)\n\t/*\n\t * You can do \"select()\" and \"poll()\" on plain files on most\n\t * platforms, and should be able to do so on pipes.\n\t *\n\t * You can't do \"select()\" on anything other than sockets in\n\t * Windows, so, on Win32 systems, we don't have \"selectable_fd\".\n\t */\n\tp->selectable_fd = fileno(fp);\n#endif\n\n\tp->can_set_rfmon_op = sf_cant_set_rfmon;\n\tp->read_op = pcapint_offline_read;\n\tp->inject_op = sf_inject;\n\tp->setfilter_op = pcapint_install_bpf_program;\n\tp->setdirection_op = sf_setdirection;\n\tp->set_datalink_op = NULL;\t/* we don't support munging link-layer headers */\n\tp->getnonblock_op = sf_getnonblock;\n\tp->setnonblock_op = sf_setnonblock;\n\tp->stats_op = sf_stats;\n#ifdef _WIN32\n\tp->stats_ex_op = sf_stats_ex;\n\tp->setbuff_op = sf_setbuff;\n\tp->setmode_op = sf_setmode;\n\tp->setmintocopy_op = sf_setmintocopy;\n\tp->getevent_op = sf_getevent;\n\tp->oid_get_request_op = sf_oid_get_request;\n\tp->oid_set_request_op = sf_oid_set_request;\n\tp->sendqueue_transmit_op = sf_sendqueue_transmit;\n\tp->setuserbuffer_op = sf_setuserbuffer;\n\tp->live_dump_op = sf_live_dump;\n\tp->live_dump_ended_op = sf_live_dump_ended;\n#endif\n\n\t/*\n\t * For offline captures, the standard one-shot callback can\n\t * be used for pcap_next()/pcap_next_ex().\n\t */\n\tp->oneshot_callback = pcapint_oneshot;\n\n\t/*\n\t * Default breakloop operation.\n\t */\n\tp->breakloop_op = pcapint_breakloop_common;\n\n\t/*\n\t * Savefiles never require special BPF code generation.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\tp->activated = 1;\n\n\treturn (p);\n}\n\n/*\n * This isn't needed on Windows; we #define pcap_fopen_offline() as\n * a wrapper around pcap_hopen_offline(), and we don't call it from\n * inside this file, so it's unused.\n */\n#ifndef _WIN32\npcap_t *\npcap_fopen_offline(FILE *fp, char *errbuf)\n{\n\treturn (pcap_fopen_offline_with_tstamp_precision(fp,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf));\n}\n#endif\n\n/*\n * Read packets from a capture file, and call the callback for each\n * packet.\n * If cnt > 0, return after 'cnt' packets, otherwise continue until eof.\n */\nint\npcapint_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct bpf_insn *fcode;\n\tint n = 0;\n\tu_char *data;\n\n\t/*\n\t * This can conceivably process more than INT_MAX packets,\n\t * which would overflow the packet count, causing it either\n\t * to look like a negative number, and thus cause us to\n\t * return a value that looks like an error, or overflow\n\t * back into positive territory, and thus cause us to\n\t * return a too-low count.\n\t *\n\t * Therefore, if the packet count is unlimited, we clip\n\t * it at INT_MAX; this routine is not expected to\n\t * process packets indefinitely, so that's not an issue.\n\t */\n\tif (PACKET_COUNT_IS_UNLIMITED(cnt))\n\t\tcnt = INT_MAX;\n\n\tfor (;;) {\n\t\tstruct pcap_pkthdr h;\n\t\tint status;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else\n\t\t\t\treturn (n);\n\t\t}\n\n\t\tstatus = p->next_packet_op(p, &h, &data);\n\t\tif (status < 0) {\n\t\t\t/*\n\t\t\t * Error.  Pass it back to the caller.\n\t\t\t */\n\t\t\treturn (status);\n\t\t}\n\t\tif (status == 0) {\n\t\t\t/*\n\t\t\t * EOF.  Nothing more to process;\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * OK, we've read a packet; run it through the filter\n\t\t * and, if it passes, process it.\n\t\t */\n\t\tif ((fcode = p->fcode.bf_insns) == NULL ||\n\t\t    pcapint_filter(fcode, data, h.len, h.caplen)) {\n\t\t\t(*callback)(user, &h, data);\n\t\t\tn++;\t/* count the packet */\n\t\t\tif (n >= cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*XXX this breaks semantics tcpslice expects */\n\treturn (n);\n}\n"
        },
        {
          "name": "scanner.l",
          "type": "blob",
          "size": 17.765625,
          "content": "%top {\n/* Must come first for _LARGE_FILE_API on AIX. */\n#include <config.h>\n\n/*\n * Must come first to avoid warnings on Windows.\n *\n * Flex-generated scanners may only include <inttypes.h> if __STDC_VERSION__\n * is defined with a value >= 199901, meaning \"full C99\", and MSVC may not\n * define it with that value, because it isn't 100% C99-compliant, even\n * though it has an <inttypes.h> capable of defining everything the Flex\n * scanner needs.\n *\n * We, however, will include it if we know we have an MSVC version that has\n * it; this means that we may define the INTn_MAX and UINTn_MAX values in\n * scanner.c, and then include <stdint.h>, which may define them differently\n * (same value, but different string of characters), causing compiler warnings.\n *\n * If we include it here, and they're defined, that'll prevent scanner.c\n * from defining them.  So we include <pcap/pcap-inttypes.h>, to get\n * <inttypes.h> if we have it.\n */\n#include <pcap/pcap-inttypes.h>\n\n/*\n * grammar.h requires gencode.h and sometimes breaks in a polluted namespace\n * (see ftmacros.h), so include it early.\n */\n#include \"gencode.h\"\n#include \"grammar.h\"\n\n#include \"diag-control.h\"\n\n/*\n * Convert string to 32-bit unsigned integer; the string starts at\n * string and is string_len bytes long.\n *\n * On success, sets *val to the value and returns 1.\n * On failure, sets the BPF error string and returns 0.\n *\n * Also used in gencode.c\n */\ntypedef enum {\n\tSTOULEN_OK,\n\tSTOULEN_NOT_HEX_NUMBER,\n\tSTOULEN_NOT_OCTAL_NUMBER,\n\tSTOULEN_NOT_DECIMAL_NUMBER,\n\tSTOULEN_ERROR\n} stoulen_ret;\n\nstoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,\n    compiler_state_t *cstate);\n}\n\n/*\n * We want a reentrant scanner.\n */\n%option reentrant\n\n/*\n * And we need to pass the compiler state to the scanner.\n */\n%option extra-type=\"compiler_state_t *\"\n\n/*\n * We don't use input, so don't generate code for it.\n */\n%option noinput\n\n/*\n * We don't use unput, so don't generate code for it.\n */\n%option nounput\n\n/*\n * We don't read from the terminal.\n */\n%option never-interactive\n\n/*\n * We want to stop processing when we get to the end of the input.\n */\n%option noyywrap\n\n/*\n * We want to generate code that can be used by a reentrant parser\n * generated by Bison or Berkeley YACC.\n */\n%option bison-bridge\n\n%{\n/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include <string.h>\n\n#include \"pcap-int.h\"\n\n/*\n * Earlier versions of Flex don't declare these, so we declare them\n * ourselves to squelch warnings.\n */\nint pcap_get_column(yyscan_t);\nvoid pcap_set_column(int, yyscan_t);\n\n#ifdef INET6\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else /* _WIN32 */\n#include <sys/socket.h>\t/* for \"struct sockaddr\" in \"struct addrinfo\" */\n#include <netdb.h>\t/* for \"struct addrinfo\" */\n#endif /* _WIN32 */\n\n#endif /*INET6*/\n\n#include <pcap/namedb.h>\n#include \"grammar.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\nstatic int stou(const char *, YYSTYPE *, compiler_state_t *);\n\n/*\n * Disable diagnostics in the code generated by Flex.\n */\nDIAG_OFF_FLEX\n\n%}\n\nN\t\t([0-9]+|(0X|0x)[0-9A-Fa-f]+)\nB\t\t([0-9A-Fa-f][0-9A-Fa-f]?)\nB2\t\t([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])\nW\t\t([0-9A-Fa-f][0-9A-Fa-f]?[0-9A-Fa-f]?[0-9A-Fa-f]?)\n\n%a 18400\n%o 21500\n%e 7600\n%k 4550\n%p 27600\n%n 2000\n\nV680\t\t{W}:{W}:{W}:{W}:{W}:{W}:{W}:{W}\n\nV670\t\t::{W}:{W}:{W}:{W}:{W}:{W}:{W}\nV671\t\t{W}::{W}:{W}:{W}:{W}:{W}:{W}\nV672\t\t{W}:{W}::{W}:{W}:{W}:{W}:{W}\nV673\t\t{W}:{W}:{W}::{W}:{W}:{W}:{W}\nV674\t\t{W}:{W}:{W}:{W}::{W}:{W}:{W}\nV675\t\t{W}:{W}:{W}:{W}:{W}::{W}:{W}\nV676\t\t{W}:{W}:{W}:{W}:{W}:{W}::{W}\nV677\t\t{W}:{W}:{W}:{W}:{W}:{W}:{W}::\n\nV660\t\t::{W}:{W}:{W}:{W}:{W}:{W}\nV661\t\t{W}::{W}:{W}:{W}:{W}:{W}\nV662\t\t{W}:{W}::{W}:{W}:{W}:{W}\nV663\t\t{W}:{W}:{W}::{W}:{W}:{W}\nV664\t\t{W}:{W}:{W}:{W}::{W}:{W}\nV665\t\t{W}:{W}:{W}:{W}:{W}::{W}\nV666\t\t{W}:{W}:{W}:{W}:{W}:{W}::\n\nV650\t\t::{W}:{W}:{W}:{W}:{W}\nV651\t\t{W}::{W}:{W}:{W}:{W}\nV652\t\t{W}:{W}::{W}:{W}:{W}\nV653\t\t{W}:{W}:{W}::{W}:{W}\nV654\t\t{W}:{W}:{W}:{W}::{W}\nV655\t\t{W}:{W}:{W}:{W}:{W}::\n\nV640\t\t::{W}:{W}:{W}:{W}\nV641\t\t{W}::{W}:{W}:{W}\nV642\t\t{W}:{W}::{W}:{W}\nV643\t\t{W}:{W}:{W}::{W}\nV644\t\t{W}:{W}:{W}:{W}::\n\nV630\t\t::{W}:{W}:{W}\nV631\t\t{W}::{W}:{W}\nV632\t\t{W}:{W}::{W}\nV633\t\t{W}:{W}:{W}::\n\nV620\t\t::{W}:{W}\nV621\t\t{W}::{W}\nV622\t\t{W}:{W}::\n\nV610\t\t::{W}\nV611\t\t{W}::\n\nV600\t\t::\n\nV6604\t\t{W}:{W}:{W}:{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\n\nV6504\t\t::{W}:{W}:{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6514\t\t{W}::{W}:{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6524\t\t{W}:{W}::{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6534\t\t{W}:{W}:{W}::{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6544\t\t{W}:{W}:{W}:{W}::{W}:{N}\\.{N}\\.{N}\\.{N}\nV6554\t\t{W}:{W}:{W}:{W}:{W}::{N}\\.{N}\\.{N}\\.{N}\n\nV6404\t\t::{W}:{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6414\t\t{W}::{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6424\t\t{W}:{W}::{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6434\t\t{W}:{W}:{W}::{W}:{N}\\.{N}\\.{N}\\.{N}\nV6444\t\t{W}:{W}:{W}:{W}::{N}\\.{N}\\.{N}\\.{N}\n\nV6304\t\t::{W}:{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6314\t\t{W}::{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6324\t\t{W}:{W}::{W}:{N}\\.{N}\\.{N}\\.{N}\nV6334\t\t{W}:{W}:{W}::{N}\\.{N}\\.{N}\\.{N}\n\nV6204\t\t::{W}:{W}:{N}\\.{N}\\.{N}\\.{N}\nV6214\t\t{W}::{W}:{N}\\.{N}\\.{N}\\.{N}\nV6224\t\t{W}:{W}::{N}\\.{N}\\.{N}\\.{N}\n\nV6104\t\t::{W}:{N}\\.{N}\\.{N}\\.{N}\nV6114\t\t{W}::{N}\\.{N}\\.{N}\\.{N}\n\nV6004\t\t::{N}\\.{N}\\.{N}\\.{N}\n\n\nV6\t\t({V680}|{V670}|{V671}|{V672}|{V673}|{V674}|{V675}|{V676}|{V677}|{V660}|{V661}|{V662}|{V663}|{V664}|{V665}|{V666}|{V650}|{V651}|{V652}|{V653}|{V654}|{V655}|{V640}|{V641}|{V642}|{V643}|{V644}|{V630}|{V631}|{V632}|{V633}|{V620}|{V621}|{V622}|{V610}|{V611}|{V600}|{V6604}|{V6504}|{V6514}|{V6524}|{V6534}|{V6544}|{V6554}|{V6404}|{V6414}|{V6424}|{V6434}|{V6444}|{V6304}|{V6314}|{V6324}|{V6334}|{V6204}|{V6214}|{V6224}|{V6104}|{V6114}|{V6004})\n\nMAC\t\t({B}:{B}:{B}:{B}:{B}:{B}|{B}\\-{B}\\-{B}\\-{B}\\-{B}\\-{B}|{B}\\.{B}\\.{B}\\.{B}\\.{B}\\.{B}|{B2}\\.{B2}\\.{B2}|{B2}{3})\n\n\n\n%%\ndst\t\treturn DST;\nsrc\t\treturn SRC;\n\nlink|ether|ppp|slip  return LINK;\nfddi|tr|wlan\treturn LINK;\narp\t\treturn ARP;\nrarp\t\treturn RARP;\nip\t\treturn IP;\nsctp\t\treturn SCTP;\ntcp\t\treturn TCP;\nudp\t\treturn UDP;\nicmp\t\treturn ICMP;\nigmp\t\treturn IGMP;\nigrp\t\treturn IGRP;\npim\t\treturn PIM;\nvrrp\t\treturn VRRP;\ncarp\t\treturn CARP;\nradio\t\treturn RADIO;\n\nip6\t\treturn IPV6;\nicmp6\t\treturn ICMPV6;\nah\t\treturn AH;\nesp\t\treturn ESP;\n\natalk\t\treturn ATALK;\naarp\t\treturn AARP;\ndecnet\t\treturn DECNET;\nlat\t\treturn LAT;\nsca\t\treturn SCA;\nmoprc\t\treturn MOPRC;\nmopdl\t\treturn MOPDL;\n\niso\t\treturn ISO;\nesis\t\treturn ESIS;\nes-is\t\treturn ESIS;\nisis\t\treturn ISIS;\nis-is\t\treturn ISIS;\nl1              return L1;\nl2              return L2;\niih             return IIH;\nlsp             return LSP;\nsnp             return SNP;\ncsnp            return CSNP;\npsnp            return PSNP;\n\nclnp\t\treturn CLNP;\n\nstp\t\treturn STP;\n\nipx\t\treturn IPX;\n\nnetbeui\t\treturn NETBEUI;\n\nhost\t\treturn HOST;\nnet\t\treturn NET;\nmask\t\treturn NETMASK;\nport\t\treturn PORT;\nportrange\treturn PORTRANGE;\nproto\t\treturn PROTO;\nprotochain\treturn PROTOCHAIN;\n\ngateway\t\treturn GATEWAY;\n\ntype\t\treturn TYPE;\nsubtype\t\treturn SUBTYPE;\ndirection|dir\treturn DIR;\naddress1|addr1\treturn ADDR1;\naddress2|addr2\treturn ADDR2;\naddress3|addr3\treturn ADDR3;\naddress4|addr4\treturn ADDR4;\nra\t\treturn RA;\nta\t\treturn TA;\n\nless\t\treturn LESS;\ngreater\t\treturn GREATER;\nbyte\t\treturn CBYTE;\nbroadcast\treturn TK_BROADCAST;\nmulticast\treturn TK_MULTICAST;\n\nand|\"&&\"\treturn AND;\nor|\"||\"\t\treturn OR;\nnot\t\treturn '!';\n\nlen|length\treturn LEN;\ninbound\t\treturn INBOUND;\noutbound\treturn OUTBOUND;\n\nifindex\t\treturn IFINDEX;\n\nvlan\t\treturn VLAN;\nmpls\t\treturn MPLS;\npppoed\t\treturn PPPOED;\npppoes\t\treturn PPPOES;\ngeneve\t\treturn GENEVE;\nvxlan\t\treturn VXLAN;\n\nlane\t\treturn LANE;\nllc\t\treturn LLC;\nmetac\t\treturn METAC;\nbcc\t\treturn BCC;\noam\t\treturn OAM;\noamf4\t\treturn OAMF4;\noamf4ec\t\treturn OAMF4EC;\noamf4sc\t\treturn OAMF4SC;\nsc\t\treturn SC;\nilmic\t\treturn ILMIC;\nvpi\t\treturn VPI;\nvci\t\treturn VCI;\nconnectmsg\treturn CONNECTMSG;\nmetaconnect\treturn METACONNECT;\n\non|ifname\treturn PF_IFNAME;\nrset|ruleset\treturn PF_RSET;\nrnr|rulenum\treturn PF_RNR;\nsrnr|subrulenum\treturn PF_SRNR;\nreason\t\treturn PF_REASON;\naction\t\treturn PF_ACTION;\n\nfisu\t\treturn FISU;\nlssu\t\treturn LSSU;\nlsu\t\treturn LSSU;\nmsu\t\treturn MSU;\nhfisu\t\treturn HFISU;\nhlssu\t\treturn HLSSU;\nhmsu\t\treturn HMSU;\nsio\t\treturn SIO;\nopc\t\treturn OPC;\ndpc\t\treturn DPC;\nsls\t\treturn SLS;\nhsio\t\treturn HSIO;\nhopc\t\treturn HOPC;\nhdpc\t\treturn HDPC;\nhsls\t\treturn HSLS;\n\n[ \\r\\n\\t]\t\t;\n[+\\-*/%:\\[\\]!<>()&|\\^=]\treturn yytext[0];\n\">=\"\t\t\treturn GEQ;\n\"<=\"\t\t\treturn LEQ;\n\"!=\"\t\t\treturn NEQ;\n\"==\"\t\t\treturn '=';\n\"<<\"\t\t\treturn LSH;\n\">>\"\t\t\treturn RSH;\n${B}\t\t\t{ yylval->s = sdup(yyextra, yytext); return AID; }\n{MAC}\t\t\t{ yylval->s = sdup(yyextra, yytext); return EID; }\n{N}\t\t\t{ return stou(yytext, yylval, yyextra); }\n({N}\\.{N})|({N}\\.{N}\\.{N})|({N}\\.{N}\\.{N}\\.{N})\t{\n\t\t\tyylval->s = sdup(yyextra, (char *)yytext); return HID; }\n{V6}\t\t\t{\n#ifdef INET6\n\t\t\t  struct addrinfo hints, *res;\n\t\t\t  memset(&hints, 0, sizeof(hints));\n\t\t\t  hints.ai_family = AF_INET6;\n\t\t\t  hints.ai_flags = AI_NUMERICHOST;\n\t\t\t  if (getaddrinfo(yytext, NULL, &hints, &res)) {\n\t\t\t\tbpf_set_error(yyextra, \"bogus IPv6 address %s\", yytext);\n\t\t\t\tyylval->s = NULL;\n\t\t\t  } else {\n\t\t\t\tfreeaddrinfo(res);\n\t\t\t\tyylval->s = sdup(yyextra, (char *)yytext);\n\t\t\t  }\n#else\n\t\t\t  bpf_set_error(yyextra, \"IPv6 address %s not supported\", yytext);\n\t\t\t  yylval->s = NULL;\n#endif /*INET6*/\n\t\t\t  return HID6;\n\t\t\t}\n{B}:+({B}:+)+\t\t{ bpf_set_error(yyextra, \"bogus ethernet address %s\", yytext); yylval->s = NULL; return EID; }\nicmptype\t\t{ yylval->h = 0; return NUM; }\nicmpcode\t\t{ yylval->h = 1; return NUM; }\nicmp-echoreply\t\t{ yylval->h = 0; return NUM; }\nicmp-unreach\t\t{ yylval->h = 3; return NUM; }\nicmp-sourcequench\t{ yylval->h = 4; return NUM; }\nicmp-redirect\t\t{ yylval->h = 5; return NUM; }\nicmp-echo\t\t{ yylval->h = 8; return NUM; }\nicmp-routeradvert\t{ yylval->h = 9; return NUM; }\nicmp-routersolicit\t{ yylval->h = 10; return NUM; }\nicmp-timxceed\t\t{ yylval->h = 11; return NUM; }\nicmp-paramprob\t\t{ yylval->h = 12; return NUM; }\nicmp-tstamp\t\t{ yylval->h = 13; return NUM; }\nicmp-tstampreply\t{ yylval->h = 14; return NUM; }\nicmp-ireq\t\t{ yylval->h = 15; return NUM; }\nicmp-ireqreply\t\t{ yylval->h = 16; return NUM; }\nicmp-maskreq\t\t{ yylval->h = 17; return NUM; }\nicmp-maskreply\t\t{ yylval->h = 18; return NUM; }\n\nicmp6type       { yylval->h = 0; return NUM; }\nicmp6code       { yylval->h = 1; return NUM; }\n\nicmp6-destinationunreach\t{ yylval->h = 1; return NUM; }\nicmp6-packettoobig\t\t{ yylval->h = 2; return NUM; }\nicmp6-timeexceeded\t\t{ yylval->h = 3; return NUM; }\nicmp6-parameterproblem\t\t{ yylval->h = 4; return NUM; }\nicmp6-echo      { yylval->h = 128; return NUM; }\nicmp6-echoreply { yylval->h = 129; return NUM; }\nicmp6-multicastlistenerquery    { yylval->h = 130; return NUM; }\nicmp6-multicastlistenerreportv1 { yylval->h = 131; return NUM; }\nicmp6-multicastlistenerdone     { yylval->h = 132; return NUM; }\nicmp6-routersolicit   { yylval->h = 133; return NUM; }\nicmp6-routeradvert    { yylval->h = 134; return NUM; }\nicmp6-neighborsolicit { yylval->h = 135; return NUM; }\nicmp6-neighboradvert  { yylval->h = 136; return NUM; }\nicmp6-redirect    { yylval->h = 137; return NUM; }\nicmp6-routerrenum { yylval->h = 138; return NUM; }\nicmp6-nodeinformationquery      { yylval->h = 139; return NUM; }\nicmp6-nodeinformationresponse   { yylval->h = 140; return NUM; }\nicmp6-ineighbordiscoverysolicit { yylval->h = 141; return NUM; }\nicmp6-ineighbordiscoveryadvert  { yylval->h = 142; return NUM; }\nicmp6-multicastlistenerreportv2 { yylval->h = 143; return NUM; }\nicmp6-homeagentdiscoveryrequest { yylval->h = 144; return NUM; }\nicmp6-homeagentdiscoveryreply   { yylval->h = 145; return NUM; }\nicmp6-mobileprefixsolicit       { yylval->h = 146; return NUM; }\nicmp6-mobileprefixadvert        { yylval->h = 147; return NUM; }\nicmp6-certpathsolicit           { yylval->h = 148; return NUM; }\nicmp6-certpathadvert            { yylval->h = 149; return NUM; }\nicmp6-multicastrouteradvert     { yylval->h = 151; return NUM; }\nicmp6-multicastroutersolicit    { yylval->h = 152; return NUM; }\nicmp6-multicastrouterterm       { yylval->h = 153; return NUM; }\n\ntcpflags\t\t{ yylval->h = 13; return NUM; }\ntcp-fin\t\t\t{ yylval->h = 0x01; return NUM; }\ntcp-syn\t\t\t{ yylval->h = 0x02; return NUM; }\ntcp-rst\t\t\t{ yylval->h = 0x04; return NUM; }\ntcp-push\t\t{ yylval->h = 0x08; return NUM; }\ntcp-ack\t\t\t{ yylval->h = 0x10; return NUM; }\ntcp-urg\t\t\t{ yylval->h = 0x20; return NUM; }\ntcp-ece\t\t\t{ yylval->h = 0x40; return NUM; }\ntcp-cwr\t\t\t{ yylval->h = 0x80; return NUM; }\n[A-Za-z0-9]([-_.A-Za-z0-9]*[.A-Za-z0-9])? {\n\t\t\t yylval->s = sdup(yyextra, (char *)yytext); return ID; }\n\"\\\\\"[^ !()\\n\\t]+\t{ yylval->s = sdup(yyextra, (char *)yytext + 1); return ID; }\n.\t\t\t{ return LEX_ERROR; }\n%%\n\n/*\n * Turn diagnostics back on, so we check the code that we've written.\n */\nDIAG_ON_FLEX\n\nstoulen_ret\nstoulen(const char *string, size_t string_len, bpf_u_int32 *val,\n    compiler_state_t *cstate)\n{\n\tbpf_u_int32 n = 0;\n\tunsigned int digit;\n\tconst char *s = string;\n\n\t/*\n\t * string is guaranteed either to be a string of decimal digits\n\t * or 0[xX] followed by a string of hex digits.\n\t */\n\tif (string_len >= 1 && *s == '0') {\n\t\tif (string_len >= 2  && (s[1] == 'x' || s[1] == 'X')) {\n\t\t\t/*\n\t\t\t * Begins with 0x or 0X, so hex.\n\t\t\t * Guaranteed to be all hex digits following the\n\t\t\t * prefix, so anything that's not 0-9 or a-f is\n\t\t\t * A-F.\n\t\t\t */\n\t\t\ts += 2;\t/* skip the prefix */\n\t\t\tstring_len -= 2;\n\t\t\twhile (string_len != 0) {\n\t\t\t\tdigit = *s++;\n\t\t\t\tstring_len--;\n\t\t\t\tif (digit >= '0' && digit <= '9')\n\t\t\t\t\tdigit = digit - '0';\n\t\t\t\telse if (digit >= 'a' && digit <= 'f')\n\t\t\t\t\tdigit = digit - 'a' + 10;\n\t\t\t\telse if (digit >= 'A' && digit <= 'F')\n\t\t\t\t\tdigit = digit - 'A' + 10;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not a valid hex number.\n\t\t\t\t\t * Don't treat this as an error,\n\t\t\t\t\t * in case the caller wants to\n\t\t\t\t\t * interpret it as something else.\n\t\t\t\t\t */\n\t\t\t\t\treturn STOULEN_NOT_HEX_NUMBER;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Check for overflow.\n\t\t\t\t */\n\t\t\t\tif (n > 0xFFFFFFFU) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We have more than 28 bits of\n\t\t\t\t\t * number, and are about to\n\t\t\t\t\t * add 4 more; that won't fit\n\t\t\t\t\t * in 32 bits.\n\t\t\t\t\t */\n\t\t\t\t\tbpf_set_error(cstate,\n\t\t\t\t\t    \"number %.*s overflows 32 bits\",\n\t\t\t\t\t   (int)string_len, string);\n\t\t\t\t\treturn STOULEN_ERROR;\n\t\t\t\t}\n\t\t\t\tn = (n << 4) + digit;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Begins with 0, but not 0x or 0X, so octal.\n\t\t\t * Guaranteed to be all *decimal* digits following\n\t\t\t * the prefix, so we need to catch 8 and 9 and\n\t\t\t * report an error.\n\t\t\t */\n\t\t\ts += 1;\n\t\t\tstring_len -= 1;\n\t\t\twhile (string_len != 0) {\n\t\t\t\tdigit = *s++;\n\t\t\t\tstring_len--;\n\t\t\t\tif (digit >= '0' && digit <= '7')\n\t\t\t\t\tdigit = digit - '0';\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not a valid octal number.\n\t\t\t\t\t * Don't treat this as an error,\n\t\t\t\t\t * in case the caller wants to\n\t\t\t\t\t * interpret it as something else.\n\t\t\t\t\t */\n\t\t\t\t\treturn STOULEN_NOT_OCTAL_NUMBER;\n\t\t\t\t}\n\t\t\t\tif (n > 03777777777U) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We have more than 29 bits of\n\t\t\t\t\t * number, and are about to add\n\t\t\t\t\t * 3 more; that won't fit in\n\t\t\t\t\t * 32 bits.\n\t\t\t\t\t */\n\t\t\t\t\tbpf_set_error(cstate,\n\t\t\t\t\t    \"number %.*s overflows 32 bits\",\n\t\t\t\t\t   (int)string_len, string);\n\t\t\t\t\treturn STOULEN_ERROR;\n\t\t\t\t}\n\t\t\t\tn = (n << 3) + digit;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Decimal.\n\t\t */\n\t\twhile (string_len != 0) {\n\t\t\tdigit = *s++;\n\t\t\tstring_len--;\n\t\t\tif (digit >= '0' && digit <= '9')\n\t\t\t\tdigit = digit - '0';\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Not a valid decimal number.\n\t\t\t\t * Don't treat this as an error,\n\t\t\t\t * in case the caller wants to\n\t\t\t\t * interpret it as something else.\n\t\t\t\t */\n\t\t\t\treturn STOULEN_NOT_DECIMAL_NUMBER;\n\t\t\t}\n#define CUTOFF_DEC\t(0xFFFFFFFFU / 10U)\n#define CUTLIM_DEC\t(0xFFFFFFFFU % 10U)\n\t\t\tif (n > CUTOFF_DEC ||\n\t\t\t    (n == CUTOFF_DEC && digit > CUTLIM_DEC)) {\n\t\t\t\t/*\n\t\t\t\t * Adding that digit will result in a\n\t\t\t\t * number that won't fit in 32 bits.\n\t\t\t\t */\n\t\t\t\tbpf_set_error(cstate,\n\t\t\t\t    \"number %.*s overflows 32 bits\",\n\t\t\t\t   (int)string_len, string);\n\t\t\t\treturn STOULEN_ERROR;\n\t\t\t}\n\t\t\tn = (n * 10) + digit;\n\t\t}\n\t}\n\n\t*val = n;\n\treturn STOULEN_OK;\n}\n\n/*\n * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for\n * preceding 0x or 0 and uses hex or octal instead of decimal.\n *\n * On success, sets yylval->h to the value and returns NUM.\n * On failure, sets the BPF error string and returns LEX_ERROR, to force\n * the parse to stop.\n */\nstatic int\nstou(const char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)\n{\n\tstoulen_ret ret;\n\n\tret = stoulen(yytext_arg, strlen(yytext_arg), &yylval_arg->h,\n\t    yyextra_arg);\n\tswitch (ret) {\n\n\tcase STOULEN_OK:\n\t\treturn NUM;\n\n\tcase STOULEN_NOT_OCTAL_NUMBER:\n\t\tbpf_set_error(yyextra_arg, \"number %s contains non-octal digit\",\n\t\t    yytext_arg);\n\t\treturn LEX_ERROR;\n\n\tcase STOULEN_NOT_HEX_NUMBER:\n\t\tbpf_set_error(yyextra_arg, \"number %s contains non-hex digit\",\n\t\t    yytext_arg);\n\t\treturn LEX_ERROR;\n\n\tcase STOULEN_NOT_DECIMAL_NUMBER:\n\t\tbpf_set_error(yyextra_arg, \"number %s contains non-decimal digit\",\n\t\t    yytext_arg);\n\t\treturn LEX_ERROR;\n\n\tcase STOULEN_ERROR:\n\t\t/* Error already set. */\n\t\treturn LEX_ERROR;\n\n\tdefault:\n\t\t/* Should not happen */\n\t\tbpf_set_error(yyextra_arg, \"stoulen returned %d - this should not happen\", ret);\n\t\treturn LEX_ERROR;\n\t}\n}\n"
        },
        {
          "name": "sf-pcap.c",
          "type": "blob",
          "size": 34.580078125,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcap.c - libpcap-file-format-specific code from savefile.c\n *\tExtraction/creation by Jeffrey Mogul, DECWRL\n *\tModified by Steve McCanne, LBL.\n *\n * Used to save the received packet headers, after filtering, to\n * a file, and then read them later.\n * The first record in the file contains saved values for the machine\n * dependent values so we can print the dump file on any architecture.\n */\n\n#include <config.h>\n\n#include <pcap-types.h>\n#ifdef _WIN32\n#include <io.h>\n#include <fcntl.h>\n#endif /* _WIN32 */\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h> /* for INT_MAX */\n\n#include \"pcap-int.h\"\n#include \"pcap-util.h\"\n\n#include \"pcap-common.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"sf-pcap.h\"\n\n/*\n * Setting O_BINARY on Windows is a bit tricky.\n */\n#if defined(_WIN32)\n  #define SET_BINMODE(f)  _setmode(_fileno(f), _O_BINARY)\n#endif\n\n/*\n * Standard libpcap format.\n *\n * The same value is used in the rpcap protocol as an indication of\n * the server byte order, to let the client know whether it needs to\n * byte-swap some host-byte-order metadata.\n */\n#define TCPDUMP_MAGIC\t\t0xa1b2c3d4\n\n/*\n * Alexey Kuznetzov's modified libpcap format.\n */\n#define KUZNETZOV_TCPDUMP_MAGIC\t0xa1b2cd34\n\n/*\n * Reserved for Francisco Mesquita <francisco.mesquita@radiomovel.pt>\n * for another modified format.\n */\n#define FMESQUITA_TCPDUMP_MAGIC\t0xa1b234cd\n\n/*\n * Navtel Communications' format, with nanosecond timestamps,\n * as per a request from Dumas Hwang <dumas.hwang@navtelcom.com>.\n */\n#define NAVTEL_TCPDUMP_MAGIC\t0xa12b3c4d\n\n/*\n * Normal libpcap format, except for seconds/nanoseconds timestamps,\n * as per a request by Ulf Lamping <ulf.lamping@web.de>\n */\n#define NSEC_TCPDUMP_MAGIC\t0xa1b23c4d\n\n/*\n * Used for identification of cbpf-savefile(5).\n */\n#define CBPF_SAVEFILE_MAGIC\t0xa1b2c3cb\n\n/*\n * This is a timeval as stored in a savefile.\n * It has to use the same types everywhere, independent of the actual\n * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some\n * platforms and 64-bit tv_sec values on other platforms, and writing\n * out native `struct timeval' values would mean files could only be\n * read on systems with the same tv_sec size as the system on which\n * the file was written.\n *\n * The fields are unsigned, as that's what the pcap draft specification\n * says they are.  (That gives pcap a 68-year Y2.038K reprieve, although\n * in 2106 it runs out for good.  pcapng doesn't have that problem,\n * unless you pick a *really* high time stamp precision.)\n */\n\nstruct pcap_timeval {\n\tbpf_u_int32 tv_sec;\t/* seconds */\n\tbpf_u_int32 tv_usec;\t/* microseconds */\n};\n\n/*\n * This is a `pcap_pkthdr' as actually stored in a savefile.\n *\n * Do not change the format of this structure, in any way (this includes\n * changes that only affect the length of fields in this structure),\n * and do not make the time stamp anything other than seconds and\n * microseconds (e.g., seconds and nanoseconds).  Instead:\n *\n *\tintroduce a new structure for the new format;\n *\n *\tsend mail to \"tcpdump-workers@lists.tcpdump.org\", requesting\n *\ta new magic number for your new capture file format, and, when\n *\tyou get the new magic number, put it in \"savefile.c\";\n *\n *\tuse that magic number for save files with the changed record\n *\theader;\n *\n *\tmake the code in \"savefile.c\" capable of reading files with\n *\tthe old record header as well as files with the new record header\n *\t(using the magic number to determine the header format).\n *\n * Then supply the changes by forking the branch at\n *\n *\thttps://github.com/the-tcpdump-group/libpcap/tree/master\n *\n * and issuing a pull request, so that future versions of libpcap and\n * programs that use it (such as tcpdump) will be able to read your new\n * capture file format.\n */\n\nstruct pcap_sf_pkthdr {\n\tstruct pcap_timeval ts;\t/* time stamp */\n\tbpf_u_int32 caplen;\t/* length of portion present */\n\tbpf_u_int32 len;\t/* length of this packet (off wire) */\n};\n\n/*\n * How a `pcap_pkthdr' is actually stored in savefiles written\n * by some patched versions of libpcap (e.g. the ones in Red\n * Hat Linux 6.1 and 6.2).\n *\n * Do not change the format of this structure, in any way (this includes\n * changes that only affect the length of fields in this structure).\n * Instead, introduce a new structure, as per the above.\n */\n\nstruct pcap_sf_patched_pkthdr {\n\tstruct pcap_timeval ts;\t/* time stamp */\n\tbpf_u_int32 caplen;\t/* length of portion present */\n\tbpf_u_int32 len;\t/* length of this packet (off wire) */\n\tint index;\n\tunsigned short protocol;\n\tunsigned char pkt_type;\n};\n\nstatic int pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **datap);\n\n#ifdef _WIN32\n/*\n * This isn't exported on Windows, because it would only work if both\n * libpcap and the code using it were using the same C runtime; otherwise they\n * would be using different definitions of a FILE structure.\n *\n * Instead we define this as a macro in pcap/pcap.h that wraps the hopen\n * version that we do export, passing it a raw OS HANDLE, as defined by the\n * Win32 / Win64 ABI, obtained from the _fileno() and _get_osfhandle()\n * functions of the appropriate CRT.\n */\nstatic pcap_dumper_t *pcap_dump_fopen(pcap_t *p, FILE *f);\n#endif /* _WIN32 */\n\n/*\n * Private data for reading pcap savefiles.\n */\ntypedef enum {\n\tNOT_SWAPPED,\n\tSWAPPED,\n\tMAYBE_SWAPPED\n} swapped_type_t;\n\ntypedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP,\n\tSCALE_DOWN\n} tstamp_scale_type_t;\n\nstruct pcap_sf {\n\tsize_t hdrsize;\n\tswapped_type_t lengths_swapped;\n\ttstamp_scale_type_t scale_type;\n};\n\n/*\n * Check whether this is a pcap savefile and, if it is, extract the\n * relevant information from the header.\n */\npcap_t *\npcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,\n\t\t  int *err)\n{\n\tbpf_u_int32 magic_int;\n\tstruct pcap_file_header hdr;\n\tsize_t amt_read;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_sf *ps;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the magic\n\t * number for a pcap savefile, or for a byte-swapped pcap\n\t * savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != TCPDUMP_MAGIC &&\n\t    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&\n\t    magic_int != NSEC_TCPDUMP_MAGIC) {\n\t\tmagic_int = SWAPLONG(magic_int);\n\t\tif (magic_int != TCPDUMP_MAGIC &&\n\t\t    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&\n\t\t    magic_int != NSEC_TCPDUMP_MAGIC)\n\t\t\treturn (NULL);\t/* nope */\n\t\tswapped = 1;\n\t}\n\n\t/*\n\t * They are.  Put the magic number in the header, and read\n\t * the rest of the header.\n\t */\n\thdr.magic = magic_int;\n\tamt_read = fread(((char *)&hdr) + sizeof hdr.magic, 1,\n\t    sizeof(hdr) - sizeof(hdr.magic), fp);\n\tif (amt_read != sizeof(hdr) - sizeof(hdr.magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %zu file header bytes, only got %zu\",\n\t\t\t    sizeof(hdr), amt_read);\n\t\t}\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * If it's a byte-swapped capture file, byte-swap the header.\n\t */\n\tif (swapped) {\n\t\thdr.version_major = SWAPSHORT(hdr.version_major);\n\t\thdr.version_minor = SWAPSHORT(hdr.version_minor);\n\t\thdr.thiszone = SWAPLONG(hdr.thiszone);\n\t\thdr.sigfigs = SWAPLONG(hdr.sigfigs);\n\t\thdr.snaplen = SWAPLONG(hdr.snaplen);\n\t\thdr.linktype = SWAPLONG(hdr.linktype);\n\t}\n\n\tif (hdr.version_major < PCAP_VERSION_MAJOR) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"archaic pcap savefile format\");\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * currently only versions 2.[0-4] are supported with\n\t * the exception of 543.0 for DG/UX tcpdump.\n\t */\n\tif (! ((hdr.version_major == PCAP_VERSION_MAJOR &&\n\t\thdr.version_minor <= PCAP_VERSION_MINOR) ||\n\t       (hdr.version_major == 543 &&\n\t\thdr.version_minor == 0))) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"unsupported pcap savefile version %u.%u\",\n\t\t\t hdr.version_major, hdr.version_minor);\n\t\t*err = 1;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Check the main reserved field.\n\t */\n\tif (LT_RESERVED1(hdr.linktype) != 0) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"savefile linktype reserved field not zero (0x%08x)\",\n\t\t\t LT_RESERVED1(hdr.linktype));\n\t\t*err = 1;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * OK, this is a good pcap file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_sf);\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tp->version_major = hdr.version_major;\n\tp->version_minor = hdr.version_minor;\n\tp->linktype = linktype_to_dlt(LT_LINKTYPE(hdr.linktype));\n\tp->linktype_ext = LT_LINKTYPE_EXT(hdr.linktype);\n\tp->snapshot = pcapint_adjust_snapshot(p->linktype, hdr.snaplen);\n\n\tp->next_packet_op = pcap_next_packet;\n\n\tps = p->priv;\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Will we need to scale the timestamps to match what the\n\t * user wants?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tif (magic_int == NSEC_TCPDUMP_MAGIC) {\n\t\t\t/*\n\t\t\t * The file has nanoseconds, the user\n\t\t\t * wants microseconds; scale the\n\t\t\t * precision down.\n\t\t\t */\n\t\t\tps->scale_type = SCALE_DOWN;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The file has microseconds, the\n\t\t\t * user wants microseconds; nothing to do.\n\t\t\t */\n\t\t\tps->scale_type = PASS_THROUGH;\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tif (magic_int == NSEC_TCPDUMP_MAGIC) {\n\t\t\t/*\n\t\t\t * The file has nanoseconds, the\n\t\t\t * user wants nanoseconds; nothing to do.\n\t\t\t */\n\t\t\tps->scale_type = PASS_THROUGH;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The file has microseconds, the user\n\t\t\t * wants nanoseconds; scale the\n\t\t\t * precision up.\n\t\t\t */\n\t\t\tps->scale_type = SCALE_UP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * We interchanged the caplen and len fields at version 2.3,\n\t * in order to match the bpf header layout.  But unfortunately\n\t * some files were written with version 2.3 in their headers\n\t * but without the interchanged fields.\n\t *\n\t * In addition, DG/UX tcpdump writes out files with a version\n\t * number of 543.0, and with the caplen and len fields in the\n\t * pre-2.3 order.\n\t */\n\tswitch (hdr.version_major) {\n\n\tcase 2:\n\t\tif (hdr.version_minor < 3)\n\t\t\tps->lengths_swapped = SWAPPED;\n\t\telse if (hdr.version_minor == 3)\n\t\t\tps->lengths_swapped = MAYBE_SWAPPED;\n\t\telse\n\t\t\tps->lengths_swapped = NOT_SWAPPED;\n\t\tbreak;\n\n\tcase 543:\n\t\tps->lengths_swapped = SWAPPED;\n\t\tbreak;\n\n\tdefault:\n\t\tps->lengths_swapped = NOT_SWAPPED;\n\t\tbreak;\n\t}\n\n\tif (magic_int == KUZNETZOV_TCPDUMP_MAGIC) {\n\t\t/*\n\t\t * XXX - the patch that's in some versions of libpcap\n\t\t * changes the packet header but not the magic number,\n\t\t * and some other versions with this magic number have\n\t\t * some extra debugging information in the packet header;\n\t\t * we'd have to use some hacks^H^H^H^H^Hheuristics to\n\t\t * detect those variants.\n\t\t *\n\t\t * Ethereal does that, but it does so by trying to read\n\t\t * the first two packets of the file with each of the\n\t\t * record header formats.  That currently means it seeks\n\t\t * backwards and retries the reads, which doesn't work\n\t\t * on pipes.  We want to be able to read from a pipe, so\n\t\t * that strategy won't work; we'd have to buffer some\n\t\t * data ourselves and read from that buffer in order to\n\t\t * make that work.\n\t\t */\n\t\tps->hdrsize = sizeof(struct pcap_sf_patched_pkthdr);\n\n\t\tif (p->linktype == DLT_EN10MB) {\n\t\t\t/*\n\t\t\t * This capture might have been done in raw mode\n\t\t\t * or cooked mode.\n\t\t\t *\n\t\t\t * If it was done in cooked mode, p->snapshot was\n\t\t\t * passed to recvfrom() as the buffer size, meaning\n\t\t\t * that the most packet data that would be copied\n\t\t\t * would be p->snapshot.  However, a faked Ethernet\n\t\t\t * header would then have been added to it, so the\n\t\t\t * most data that would be in a packet in the file\n\t\t\t * would be p->snapshot + 14.\n\t\t\t *\n\t\t\t * We can't easily tell whether the capture was done\n\t\t\t * in raw mode or cooked mode, so we'll assume it was\n\t\t\t * cooked mode, and add 14 to the snapshot length.\n\t\t\t * That means that, for a raw capture, the snapshot\n\t\t\t * length will be misleading if you use it to figure\n\t\t\t * out why a capture doesn't have all the packet data,\n\t\t\t * but there's not much we can do to avoid that.\n\t\t\t *\n\t\t\t * But don't grow the snapshot length past the\n\t\t\t * maximum value of an int.\n\t\t\t */\n\t\t\tif (p->snapshot <= INT_MAX - 14)\n\t\t\t\tp->snapshot += 14;\n\t\t\telse\n\t\t\t\tp->snapshot = INT_MAX;\n\t\t}\n\t} else\n\t\tps->hdrsize = sizeof(struct pcap_sf_pkthdr);\n\n\t/*\n\t * Allocate a buffer for the packet data.\n\t * Choose the minimum of the file's snapshot length and 2K bytes;\n\t * that should be enough for most network packets - we'll grow it\n\t * if necessary.  That way, we don't allocate a huge chunk of\n\t * memory just because there's a huge snapshot length, as the\n\t * snapshot length might be larger than the size of the largest\n\t * packet.\n\t */\n\tp->bufsize = p->snapshot;\n\tif (p->bufsize > 2048)\n\t\tp->bufsize = 2048;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->cleanup_op = pcapint_sf_cleanup;\n\n\treturn (p);\n}\n\n/*\n * Grow the packet buffer to the specified size.\n */\nstatic int\ngrow_buffer(pcap_t *p, u_int bufsize)\n{\n\tvoid *bigger_buffer;\n\n\tbigger_buffer = realloc(p->buffer, bufsize);\n\tif (bigger_buffer == NULL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\treturn (0);\n\t}\n\tp->buffer = bigger_buffer;\n\tp->bufsize = bufsize;\n\treturn (1);\n}\n\n/*\n * Read and return the next packet from the savefile.  Return the header\n * in hdr and a pointer to the contents in data.  Return 1 on success, 0\n * if there were no more packets, and -1 on an error.\n */\nstatic int\npcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_sf *ps = p->priv;\n\tstruct pcap_sf_patched_pkthdr sf_hdr;\n\tFILE *fp = p->rfile;\n\tsize_t amt_read;\n\tbpf_u_int32 t;\n\n\t/*\n\t * Read the packet header; the structure we use as a buffer\n\t * is the longer structure for files generated by the patched\n\t * libpcap, but if the file has the magic number for an\n\t * unpatched libpcap we only read as many bytes as the regular\n\t * header has.\n\t */\n\tamt_read = fread(&sf_hdr, 1, ps->hdrsize, fp);\n\tif (amt_read != ps->hdrsize) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\treturn (-1);\n\t\t} else {\n\t\t\tif (amt_read != 0) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %zu header bytes, only got %zu\",\n\t\t\t\t    ps->hdrsize, amt_read);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* EOF */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (p->swapped) {\n\t\t/* these were written in opposite byte order */\n\t\thdr->caplen = SWAPLONG(sf_hdr.caplen);\n\t\thdr->len = SWAPLONG(sf_hdr.len);\n\t\thdr->ts.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);\n\t\thdr->ts.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);\n\t} else {\n\t\thdr->caplen = sf_hdr.caplen;\n\t\thdr->len = sf_hdr.len;\n\t\thdr->ts.tv_sec = sf_hdr.ts.tv_sec;\n\t\thdr->ts.tv_usec = sf_hdr.ts.tv_usec;\n\t}\n\n\tswitch (ps->scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * Just pass the time stamp through.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP:\n\t\t/*\n\t\t * File has microseconds, user wants nanoseconds; convert\n\t\t * it.\n\t\t */\n\t\thdr->ts.tv_usec = hdr->ts.tv_usec * 1000;\n\t\tbreak;\n\n\tcase SCALE_DOWN:\n\t\t/*\n\t\t * File has nanoseconds, user wants microseconds; convert\n\t\t * it.\n\t\t */\n\t\thdr->ts.tv_usec = hdr->ts.tv_usec / 1000;\n\t\tbreak;\n\t}\n\n\t/* Swap the caplen and len fields, if necessary. */\n\tswitch (ps->lengths_swapped) {\n\n\tcase NOT_SWAPPED:\n\t\tbreak;\n\n\tcase MAYBE_SWAPPED:\n\t\tif (hdr->caplen <= hdr->len) {\n\t\t\t/*\n\t\t\t * The captured length is <= the actual length,\n\t\t\t * so presumably they weren't swapped.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\n\tcase SWAPPED:\n\t\tt = hdr->caplen;\n\t\thdr->caplen = hdr->len;\n\t\thdr->len = t;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Is the packet bigger than we consider sane?\n\t */\n\tif (hdr->caplen > max_snaplen_for_dlt(p->linktype)) {\n\t\t/*\n\t\t * Yes.  This may be a damaged or fuzzed file.\n\t\t *\n\t\t * Is it bigger than the snapshot length?\n\t\t * (We don't treat that as an error if it's not\n\t\t * bigger than the maximum we consider sane; see\n\t\t * below.)\n\t\t */\n\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\t} else {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t\t    \"maximum of %u\", hdr->caplen,\n\t\t\t    max_snaplen_for_dlt(p->linktype));\n\t\t}\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\t/*\n\t\t * The packet is bigger than the snapshot length\n\t\t * for this file.\n\t\t *\n\t\t * This can happen due to Solaris 2.3 systems tripping\n\t\t * over the BUFMOD problem and not setting the snapshot\n\t\t * length correctly in the savefile header.\n\t\t *\n\t\t * libpcap 0.4 and later on Solaris 2.3 should set the\n\t\t * snapshot length correctly in the pcap file header,\n\t\t * even though they don't set a snapshot length in bufmod\n\t\t * (the buggy bufmod chops off the *beginning* of the\n\t\t * packet if a snapshot length is specified); they should\n\t\t * also reduce the captured length, as supplied to the\n\t\t * per-packet callback, to the snapshot length if it's\n\t\t * greater than the snapshot length, so the code using\n\t\t * libpcap should see the packet cut off at the snapshot\n\t\t * length, even though the full packet is copied up to\n\t\t * userland.\n\t\t *\n\t\t * However, perhaps some versions of libpcap failed to\n\t\t * set the snapshot length correctly in the file header\n\t\t * or the per-packet header, or perhaps this is a\n\t\t * corrupted savefile or a savefile built/modified by a\n\t\t * fuzz tester, so we check anyway.  We grow the buffer\n\t\t * to be big enough for the snapshot length, read up\n\t\t * to the snapshot length, discard the rest of the\n\t\t * packet, and report the snapshot length as the captured\n\t\t * length; we don't want to hand our caller a packet\n\t\t * bigger than the snapshot length, because they might\n\t\t * be assuming they'll never be handed such a packet,\n\t\t * and might copy the packet into a snapshot-length-\n\t\t * sized buffer, assuming it'll fit.\n\t\t */\n\t\tsize_t bytes_to_discard;\n\t\tsize_t bytes_to_read, bytes_read;\n\t\tchar discard_buf[4096];\n\n\t\tif (hdr->caplen > p->bufsize) {\n\t\t\t/*\n\t\t\t * Grow the buffer to the snapshot length.\n\t\t\t */\n\t\t\tif (!grow_buffer(p, p->snapshot))\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Read the first p->snapshot bytes into the buffer.\n\t\t */\n\t\tamt_read = fread(p->buffer, 1, p->snapshot, fp);\n\t\tif (amt_read != (bpf_u_int32)p->snapshot) {\n\t\t\tif (ferror(fp)) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t     PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"error reading dump file\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Yes, this uses hdr->caplen; technically,\n\t\t\t\t * it's true, because we would try to read\n\t\t\t\t * and discard the rest of those bytes, and\n\t\t\t\t * that would fail because we got EOF before\n\t\t\t\t * the read finished.\n\t\t\t\t */\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %d captured bytes, only got %zu\",\n\t\t\t\t    p->snapshot, amt_read);\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Now read and discard what's left.\n\t\t */\n\t\tbytes_to_discard = hdr->caplen - p->snapshot;\n\t\tbytes_read = amt_read;\n\t\twhile (bytes_to_discard != 0) {\n\t\t\tbytes_to_read = bytes_to_discard;\n\t\t\tif (bytes_to_read > sizeof (discard_buf))\n\t\t\t\tbytes_to_read = sizeof (discard_buf);\n\t\t\tamt_read = fread(discard_buf, 1, bytes_to_read, fp);\n\t\t\tbytes_read += amt_read;\n\t\t\tif (amt_read != bytes_to_read) {\n\t\t\t\tif (ferror(fp)) {\n\t\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"error reading dump file\");\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"truncated dump file; tried to read %u captured bytes, only got %zu\",\n\t\t\t\t\t    hdr->caplen, bytes_read);\n\t\t\t\t}\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tbytes_to_discard -= amt_read;\n\t\t}\n\n\t\t/*\n\t\t * Adjust caplen accordingly, so we don't get confused later\n\t\t * as to how many bytes we have to play with.\n\t\t */\n\t\thdr->caplen = p->snapshot;\n\t} else {\n\t\t/*\n\t\t * The packet is within the snapshot length for this file.\n\t\t */\n\t\tif (hdr->caplen > p->bufsize) {\n\t\t\t/*\n\t\t\t * Grow the buffer to the next power of 2, or\n\t\t\t * the snaplen, whichever is lower.\n\t\t\t */\n\t\t\tu_int new_bufsize;\n\n\t\t\tnew_bufsize = hdr->caplen;\n\t\t\t/*\n\t\t\t * https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n\t\t\t */\n\t\t\tnew_bufsize--;\n\t\t\tnew_bufsize |= new_bufsize >> 1;\n\t\t\tnew_bufsize |= new_bufsize >> 2;\n\t\t\tnew_bufsize |= new_bufsize >> 4;\n\t\t\tnew_bufsize |= new_bufsize >> 8;\n\t\t\tnew_bufsize |= new_bufsize >> 16;\n\t\t\tnew_bufsize++;\n\n\t\t\tif (new_bufsize > (u_int)p->snapshot)\n\t\t\t\tnew_bufsize = p->snapshot;\n\n\t\t\tif (!grow_buffer(p, new_bufsize))\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\t/* read the packet itself */\n\t\tamt_read = fread(p->buffer, 1, hdr->caplen, fp);\n\t\tif (amt_read != hdr->caplen) {\n\t\t\tif (ferror(fp)) {\n\t\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"error reading dump file\");\n\t\t\t} else {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %u captured bytes, only got %zu\",\n\t\t\t\t    hdr->caplen, amt_read);\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t*data = p->buffer;\n\n\tpcapint_post_process(p->linktype, p->swapped, hdr, *data);\n\n\treturn (1);\n}\n\nstatic int\nsf_write_header(pcap_t *p, FILE *fp, int linktype, int snaplen)\n{\n\tstruct pcap_file_header hdr;\n\n\thdr.magic = p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? NSEC_TCPDUMP_MAGIC : TCPDUMP_MAGIC;\n\thdr.version_major = PCAP_VERSION_MAJOR;\n\thdr.version_minor = PCAP_VERSION_MINOR;\n\n\t/*\n\t * https://www.tcpdump.org/manpages/pcap-savefile.5.txt states:\n\t * thiszone (Reserved1): 4-byte not used - SHOULD be filled with 0\n\t * sigfigs (Reserved2):  4-byte not used - SHOULD be filled with 0\n\t */\n\thdr.thiszone = 0;\n\thdr.sigfigs = 0;\n\thdr.snaplen = snaplen;\n\thdr.linktype = linktype;\n\n\tif (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * Output a packet to the initialized dump file.\n */\nvoid\npcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tregister FILE *f;\n\tstruct pcap_sf_pkthdr sf_hdr;\n\n\tf = (FILE *)user;\n\t/*\n\t * If the output file handle is in an error state, don't write\n\t * anything.\n\t *\n\t * While in principle a file handle can return from an error state\n\t * to a normal state (for example if a disk that is full has space\n\t * freed), we have possibly left a broken file already, and won't\n\t * be able to clean it up. The safest option is to do nothing.\n\t *\n\t * Note that if we could guarantee that fwrite() was atomic we\n\t * might be able to insure that we don't produce a corrupted file,\n\t * but the standard defines fwrite() as a series of fputc() calls,\n\t * so we really have no insurance that things are not fubared.\n\t *\n\t * http://pubs.opengroup.org/onlinepubs/009695399/functions/fwrite.html\n\t */\n\tif (ferror(f))\n\t\treturn;\n\t/*\n\t * Better not try writing pcap files after\n\t * 2106-02-07 06:28:15 UTC; switch to pcapng.\n\t * (And better not try writing pcap files with time stamps\n\t * that predate 1970-01-01 00:00:00 UTC; that's not supported.\n\t * You could try using pcapng with the if_tsoffset field in\n\t * the IDB for the interface(s) with packets with those time\n\t * stamps, but you may also have to get a link-layer type for\n\t * IBM Bisync or whatever link layer even older forms\n\t * of computer communication used.)\n\t */\n\tsf_hdr.ts.tv_sec  = (bpf_u_int32)h->ts.tv_sec;\n\tsf_hdr.ts.tv_usec = (bpf_u_int32)h->ts.tv_usec;\n\tsf_hdr.caplen     = h->caplen;\n\tsf_hdr.len        = h->len;\n\t/*\n\t * We only write the packet if we can write the header properly.\n\t *\n\t * This doesn't prevent us from having corrupted output, and if we\n\t * for some reason don't get a complete write we don't have any\n\t * way to set ferror() to prevent future writes from being\n\t * attempted, but it is better than nothing.\n\t */\n\tif (fwrite(&sf_hdr, sizeof(sf_hdr), 1, f) == 1) {\n\t\t(void)fwrite(sp, h->caplen, 1, f);\n\t}\n}\n\nstatic pcap_dumper_t *\npcap_setup_dump(pcap_t *p, int linktype, FILE *f, const char *fname)\n{\n\n#if defined(_WIN32)\n\t/*\n\t * If we're writing to the standard output, put it in binary\n\t * mode, as savefiles are binary files.\n\t *\n\t * Otherwise, we turn off buffering.\n\t * XXX - why?  And why not on the standard output?\n\t */\n\tif (f == stdout)\n\t\tSET_BINMODE(f);\n\telse\n\t\tsetvbuf(f, NULL, _IONBF, 0);\n#endif\n\tif (sf_write_header(p, f, linktype, p->snapshot) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't write to %s\", fname);\n\t\tif (f != stdout)\n\t\t\t(void)fclose(f);\n\t\treturn (NULL);\n\t}\n\treturn ((pcap_dumper_t *)f);\n}\n\n/*\n * Initialize so that sf_write() will output to the file named 'fname'.\n */\npcap_dumper_t *\npcap_dump_open(pcap_t *p, const char *fname)\n{\n\tFILE *f;\n\tint linktype;\n\n\t/*\n\t * If this pcap_t hasn't been activated, it doesn't have a\n\t * link-layer type, so we can't use it.\n\t */\n\tif (!p->activated) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: not-yet-activated pcap_t passed to pcap_dump_open\",\n\t\t    fname);\n\t\treturn (NULL);\n\t}\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: link-layer type %d isn't supported in savefiles\",\n\t\t    fname, p->linktype);\n\t\treturn (NULL);\n\t}\n\tlinktype |= p->linktype_ext;\n\n\tif (fname == NULL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn NULL;\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0') {\n\t\tf = stdout;\n\t\tfname = \"standard output\";\n\t} else {\n\t\t/*\n\t\t * \"b\" is supported as of C90, so *all* UN*Xes should\n\t\t * support it, even though it does nothing.  It's\n\t\t * required on Windows, as the file is a binary file\n\t\t * and must be written in binary mode.\n\t\t */\n\t\tf = pcapint_charset_fopen(fname, \"wb\");\n\t\tif (f == NULL) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (pcap_setup_dump(p, linktype, f, fname));\n}\n\n#ifdef _WIN32\n/*\n * Initialize so that sf_write() will output to a stream wrapping the given raw\n * OS file HANDLE.\n */\npcap_dumper_t *\npcap_dump_hopen(pcap_t *p, intptr_t osfd)\n{\n\tint fd;\n\tFILE *file;\n\n\tfd = _open_osfhandle(osfd, _O_APPEND);\n\tif (fd < 0) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_open_osfhandle\");\n\t\treturn NULL;\n\t}\n\n\tfile = _fdopen(fd, \"wb\");\n\tif (file == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_fdopen\");\n\t\t_close(fd);\n\t\treturn NULL;\n\t}\n\n\treturn pcap_dump_fopen(p, file);\n}\n#endif /* _WIN32 */\n\n/*\n * Initialize so that sf_write() will output to the given stream.\n */\n#ifdef _WIN32\nstatic\n#endif /* _WIN32 */\npcap_dumper_t *\npcap_dump_fopen(pcap_t *p, FILE *f)\n{\n\tint linktype;\n\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"stream: link-layer type %d isn't supported in savefiles\",\n\t\t    p->linktype);\n\t\treturn (NULL);\n\t}\n\tlinktype |= p->linktype_ext;\n\n\treturn (pcap_setup_dump(p, linktype, f, \"stream\"));\n}\n\npcap_dumper_t *\npcap_dump_open_append(pcap_t *p, const char *fname)\n{\n\tFILE *f;\n\tint linktype;\n\tsize_t amt_read;\n\tstruct pcap_file_header ph;\n\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: link-layer type %d isn't supported in savefiles\",\n\t\t    fname, linktype);\n\t\treturn (NULL);\n\t}\n\n\tif (fname == NULL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn NULL;\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0')\n\t\treturn (pcap_setup_dump(p, linktype, stdout, \"standard output\"));\n\n\t/*\n\t * \"a\" will cause the file *not* to be truncated if it exists\n\t * but will cause it to be created if it doesn't.  It will\n\t * also cause all writes to be done at the end of the file,\n\t * but will allow reads to be done anywhere in the file.  This\n\t * is what we need, because we need to read from the beginning\n\t * of the file to see if it already has a header and packets\n\t * or if it doesn't.\n\t *\n\t * \"b\" is supported as of C90, so *all* UN*Xes should support it,\n\t * even though it does nothing.  It's required on Windows, as the\n\t * file is a binary file and must be read in binary mode.\n\t */\n\tf = pcapint_charset_fopen(fname, \"ab+\");\n\tif (f == NULL) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s\", fname);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try to read a pcap header.\n\t *\n\t * We do not assume that the file will be positioned at the\n\t * beginning immediately after we've opened it - we seek to\n\t * the beginning.  ISO C says it's implementation-defined\n\t * whether the file position indicator is at the beginning\n\t * or the end of the file after an append-mode open, and\n\t * it wasn't obvious from the Single UNIX Specification\n\t * or the Microsoft documentation how that works on SUS-\n\t * compliant systems or on Windows.\n\t */\n\tif (fseek(f, 0, SEEK_SET) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't seek to the beginning of %s\", fname);\n\t\t(void)fclose(f);\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&ph, 1, sizeof (ph), f);\n\tif (amt_read != sizeof (ph)) {\n\t\tif (ferror(f)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t} else if (feof(f) && amt_read > 0) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: truncated pcap file header\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n#if defined(_WIN32)\n\t/*\n\t * We turn off buffering.\n\t * XXX - why?  And why not on the standard output?\n\t */\n\tsetvbuf(f, NULL, _IONBF, 0);\n#endif\n\n\t/*\n\t * If a header is already present and:\n\t *\n\t *\tit's not for a pcap file of the appropriate resolution\n\t *\tand the right byte order for this machine;\n\t *\n\t *\tthe link-layer header types don't match;\n\t *\n\t *\tthe snapshot lengths don't match;\n\t *\n\t * return an error.\n\t */\n\tif (amt_read > 0) {\n\t\t/*\n\t\t * A header is already present.\n\t\t * Do the checks.\n\t\t */\n\t\tswitch (ph.magic) {\n\n\t\tcase TCPDUMP_MAGIC:\n\t\t\tif (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_MICRO) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: different time stamp precision, cannot append to file\", fname);\n\t\t\t\t(void)fclose(f);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NSEC_TCPDUMP_MAGIC:\n\t\t\tif (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_NANO) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: different time stamp precision, cannot append to file\", fname);\n\t\t\t\t(void)fclose(f);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SWAPLONG(TCPDUMP_MAGIC):\n\t\tcase SWAPLONG(NSEC_TCPDUMP_MAGIC):\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different byte order, cannot append to file\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\n\t\tcase KUZNETZOV_TCPDUMP_MAGIC:\n\t\tcase SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):\n\t\tcase NAVTEL_TCPDUMP_MAGIC:\n\t\tcase SWAPLONG(NAVTEL_TCPDUMP_MAGIC):\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: not a pcap file to which we can append\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\n\t\tdefault:\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: not a pcap file\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t/*\n\t\t * Good version?\n\t\t */\n\t\tif (ph.version_major != PCAP_VERSION_MAJOR ||\n\t\t    ph.version_minor != PCAP_VERSION_MINOR) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: version is %u.%u, cannot append to file\", fname,\n\t\t\t    ph.version_major, ph.version_minor);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif ((bpf_u_int32)linktype != ph.linktype) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different linktype, cannot append to file\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif ((bpf_u_int32)p->snapshot != ph.snaplen) {\n\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different snaplen, cannot append to file\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * A header isn't present; attempt to write it.\n\t\t */\n\t\tif (sf_write_header(p, f, linktype, p->snapshot) == -1) {\n\t\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Can't write to %s\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/*\n\t * Start writing at the end of the file.\n\t *\n\t * XXX - this shouldn't be necessary, given that we're opening\n\t * the file in append mode, and ISO C specifies that all writes\n\t * are done at the end of the file in that mode.\n\t */\n\tif (fseek(f, 0, SEEK_END) == -1) {\n\t\tpcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't seek to the end of %s\", fname);\n\t\t(void)fclose(f);\n\t\treturn (NULL);\n\t}\n\treturn ((pcap_dumper_t *)f);\n}\n\nFILE *\npcap_dump_file(pcap_dumper_t *p)\n{\n\treturn ((FILE *)p);\n}\n\nlong\npcap_dump_ftell(pcap_dumper_t *p)\n{\n\treturn (ftell((FILE *)p));\n}\n\n#if defined(HAVE_FSEEKO)\n/*\n * We have fseeko(), so we have ftello().\n * If we have large file support (files larger than 2^31-1 bytes),\n * ftello() will give us a current file position with more than 32\n * bits.\n */\nint64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (ftello((FILE *)p));\n}\n#elif defined(_MSC_VER)\n/*\n * We have Visual Studio; we support only 2015 and later, so we have\n * _ftelli64().\n */\nint64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (_ftelli64((FILE *)p));\n}\n#else\n/*\n * We don't have ftello() or _ftelli64(), so fall back on ftell().\n * Either long is 64 bits, in which case ftell() should suffice,\n * or this is probably an older 32-bit UN*X without large file\n * support, which means you'll probably get errors trying to\n * write files > 2^31-1, so it won't matter anyway.\n *\n * XXX - what about MinGW?\n */\nint64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (ftell((FILE *)p));\n}\n#endif\n\nint\npcap_dump_flush(pcap_dumper_t *p)\n{\n\n\tif (fflush((FILE *)p) == EOF)\n\t\treturn (-1);\n\telse\n\t\treturn (0);\n}\n\nvoid\npcap_dump_close(pcap_dumper_t *p)\n{\n\tFILE *fp = (FILE *)p;\n\n#ifdef notyet\n\tif (ferror(fp))\n\t\treturn-an-error;\n\t/* XXX should check return from fflush()/fclose() too */\n#endif\n\t/* Don't close the standard output, but *do* flush it */\n\tif (fp == stdout)\n\t\t(void)fflush(fp);\n\telse\n\t\t(void)fclose(fp);\n}\n"
        },
        {
          "name": "sf-pcap.h",
          "type": "blob",
          "size": 1.6865234375,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcap.h - libpcap-file-format-specific routines\n *\tExtraction/creation by Jeffrey Mogul, DECWRL\n *\tModified by Steve McCanne, LBL.\n *\n * Used to save the received packet headers, after filtering, to\n * a file, and then read them later.\n * The first record in the file contains saved values for the machine\n * dependent values so we can print the dump file on any architecture.\n */\n\n#ifndef sf_pcap_h\n#define\tsf_pcap_h\n\nextern pcap_t *pcap_check_header(const uint8_t *magic, FILE *fp,\n    u_int precision, char *errbuf, int *err);\n\n#endif\n"
        },
        {
          "name": "sf-pcapng.c",
          "type": "blob",
          "size": 39.537109375,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcapng.c - pcapng-file-format-specific code from savefile.c\n */\n\n#include <config.h>\n\n#include <pcap/pcap-inttypes.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n#include \"pcap-util.h\"\n\n#include \"pcap-common.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"sf-pcapng.h\"\n\n/*\n * Block types.\n */\n\n/*\n * Common part at the beginning of all blocks.\n */\nstruct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common trailer at the end of all blocks.\n */\nstruct block_trailer {\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common options.\n */\n#define OPT_ENDOFOPT\t0\t/* end of options */\n#define OPT_COMMENT\t1\t/* comment string */\n\n/*\n * Option header.\n */\nstruct option_header {\n\tu_short\t\toption_code;\n\tu_short\t\toption_length;\n};\n\n/*\n * Structures for the part of each block type following the common\n * part.\n */\n\n/*\n * Section Header Block.\n */\n#define BT_SHB\t\t\t0x0A0D0D0A\n#define BT_SHB_INSANE_MAX       1024U*1024U*1U  /* 1MB should be enough */\nstruct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n};\n\n/*\n * Byte-order magic value.\n */\n#define BYTE_ORDER_MAGIC\t0x1A2B3C4D\n\n/*\n * Current version number.  If major_version isn't PCAP_NG_VERSION_MAJOR,\n * or if minor_version isn't PCAP_NG_VERSION_MINOR or 2, that means that\n * this code can't read the file.\n */\n#define PCAP_NG_VERSION_MAJOR\t1\n#define PCAP_NG_VERSION_MINOR\t0\n\n/*\n * Interface Description Block.\n */\n#define BT_IDB\t\t\t0x00000001\n\nstruct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n};\n\n/*\n * Options in the IDB.\n */\n#define IF_NAME\t\t2\t/* interface name string */\n#define IF_DESCRIPTION\t3\t/* interface description string */\n#define IF_IPV4ADDR\t4\t/* interface's IPv4 address and netmask */\n#define IF_IPV6ADDR\t5\t/* interface's IPv6 address and prefix length */\n#define IF_MACADDR\t6\t/* interface's MAC address */\n#define IF_EUIADDR\t7\t/* interface's EUI address */\n#define IF_SPEED\t8\t/* interface's speed, in bits/s */\n#define IF_TSRESOL\t9\t/* interface's time stamp resolution */\n#define IF_TZONE\t10\t/* interface's time zone */\n#define IF_FILTER\t11\t/* filter used when capturing on interface */\n#define IF_OS\t\t12\t/* string OS on which capture on this interface was done */\n#define IF_FCSLEN\t13\t/* FCS length for this interface */\n#define IF_TSOFFSET\t14\t/* time stamp offset for this interface */\n\n/*\n * Enhanced Packet Block.\n */\n#define BT_EPB\t\t\t0x00000006\n\nstruct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Simple Packet Block.\n */\n#define BT_SPB\t\t\t0x00000003\n\nstruct simple_packet_block {\n\tbpf_u_int32\tlen;\n\t/* followed by packet data and trailer */\n};\n\n/*\n * Packet Block.\n */\n#define BT_PB\t\t\t0x00000002\n\nstruct packet_block {\n\tu_short\t\tinterface_id;\n\tu_short\t\tdrops_count;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Block cursor - used when processing the contents of a block.\n * Contains a pointer into the data being processed and a count\n * of bytes remaining in the block.\n */\nstruct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n};\n\ntypedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP_DEC,\n\tSCALE_DOWN_DEC,\n\tSCALE_UP_BIN,\n\tSCALE_DOWN_BIN\n} tstamp_scale_type_t;\n\n/*\n * Per-interface information.\n */\nstruct pcap_ng_if {\n\tuint32_t snaplen;\t\t/* snapshot length */\n\tuint64_t tsresol;\t\t/* time stamp resolution */\n\ttstamp_scale_type_t scale_type;\t/* how to scale */\n\tuint64_t scale_factor;\t\t/* time stamp scale factor for power-of-10 tsresol */\n\tint64_t tsoffset;\t\t/* time stamp offset */\n};\n\n/*\n * Per-pcap_t private data.\n *\n * max_blocksize is the maximum size of a block that we'll accept.  We\n * reject blocks bigger than this, so we don't consume too much memory\n * with a truly huge block.  It can change as we see IDBs with different\n * link-layer header types.  (Currently, we don't support IDBs with\n * different link-layer header types, but we will support it in the\n * future, when we offer file-reading APIs that support it.)\n *\n * XXX - that's an issue on ILP32 platforms, where the maximum block\n * size of 2^31-1 would eat all but one byte of the entire address space.\n * It's less of an issue on ILP64/LLP64 platforms, but the actual size\n * of the address space may be limited by 1) the number of *significant*\n * address bits (currently, x86-64 only supports 48 bits of address), 2)\n * any limitations imposed by the operating system; 3) any limitations\n * imposed by the amount of available backing store for anonymous pages,\n * so we impose a limit regardless of the size of a pointer.\n */\nstruct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n};\n\n/*\n * The maximum block size we start with; we use an arbitrary value of\n * 16 MiB.\n */\n#define INITIAL_MAX_BLOCKSIZE\t(16*1024*1024)\n\n/*\n * Maximum block size for a given maximum snapshot length; we define it\n * as the size of an EPB with a max_snaplen-sized packet and 128KB of\n * options.\n */\n#define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \\\n\t(sizeof (struct block_header) + \\\n\t sizeof (struct enhanced_packet_block) + \\\n\t (max_snaplen) + 131072 + \\\n\t sizeof (struct block_trailer))\n\nstatic void pcap_ng_cleanup(pcap_t *p);\nstatic int pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,\n    u_char **data);\n\nstatic int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated pcapng dump file; tried to read %zu bytes, only got %zu\",\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\nstatic int\nread_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_header bhdr;\n\tstruct block_trailer *btrlr;\n\tu_char *bdata;\n\tsize_t data_remaining;\n\n\tps = p->priv;\n\n\tstatus = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);\n\tif (status <= 0)\n\t\treturn (status);\t/* error or EOF */\n\n\tif (p->swapped) {\n\t\tbhdr.block_type = SWAPLONG(bhdr.block_type);\n\t\tbhdr.total_length = SWAPLONG(bhdr.total_length);\n\t}\n\n\t/*\n\t * Is this block \"too small\" - i.e., is it shorter than a block\n\t * header plus a block trailer?\n\t */\n\tif (bhdr.total_length < sizeof(struct block_header) +\n\t    sizeof(struct block_trailer)) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u < %zu\",\n\t\t    bhdr.total_length,\n\t\t    sizeof(struct block_header) + sizeof(struct block_trailer));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the block total length a multiple of 4?\n\t */\n\tif ((bhdr.total_length % 4) != 0) {\n\t\t/*\n\t\t * No.  Report that as an error.\n\t\t */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u that is not a multiple of 4\",\n\t\t    bhdr.total_length);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the buffer big enough?\n\t */\n\tif (p->bufsize < bhdr.total_length) {\n\t\t/*\n\t\t * No - make it big enough, unless it's too big, in\n\t\t * which case we fail.\n\t\t */\n\t\tvoid *bigger_buffer;\n\n\t\tif (bhdr.total_length > ps->max_blocksize) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"pcapng block size %u > maximum %u\", bhdr.total_length,\n\t\t\t    ps->max_blocksize);\n\t\t\treturn (-1);\n\t\t}\n\t\tbigger_buffer = realloc(p->buffer, bhdr.total_length);\n\t\tif (bigger_buffer == NULL) {\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\t\treturn (-1);\n\t\t}\n\t\tp->buffer = bigger_buffer;\n\t}\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the block.\n\t */\n\tmemcpy(p->buffer, &bhdr, sizeof(bhdr));\n\tbdata = p->buffer + sizeof(bhdr);\n\tdata_remaining = bhdr.total_length - sizeof(bhdr);\n\tif (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)\n\t\treturn (-1);\n\n\t/*\n\t * Get the block size from the trailer.\n\t */\n\tbtrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));\n\tif (p->swapped)\n\t\tbtrlr->total_length = SWAPLONG(btrlr->total_length);\n\n\t/*\n\t * Is the total length from the trailer the same as the total\n\t * length from the header?\n\t */\n\tif (bhdr.total_length != btrlr->total_length) {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block total length in header and trailer don't match\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcursor->data = bdata;\n\tcursor->data_remaining = data_remaining - sizeof(struct block_trailer);\n\tcursor->block_type = bhdr.block_type;\n\treturn (1);\n}\n\nstatic void *\nget_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)\n{\n\tvoid *data;\n\n\t/*\n\t * Make sure we have the specified amount of data remaining in\n\t * the block data.\n\t */\n\tif (cursor->data_remaining < chunk_size) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block of type %u in pcapng dump file is too short\",\n\t\t    cursor->block_type);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Return the current pointer, and skip past the chunk.\n\t */\n\tdata = cursor->data;\n\tcursor->data += chunk_size;\n\tcursor->data_remaining -= chunk_size;\n\treturn (data);\n}\n\nstatic struct option_header *\nget_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\n\topthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);\n\tif (opthdr == NULL) {\n\t\t/*\n\t\t * Option header is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Byte-swap it if necessary.\n\t */\n\tif (p->swapped) {\n\t\topthdr->option_code = SWAPSHORT(opthdr->option_code);\n\t\topthdr->option_length = SWAPSHORT(opthdr->option_length);\n\t}\n\n\treturn (opthdr);\n}\n\nstatic void *\nget_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)\n{\n\tsize_t padded_option_len;\n\tvoid *optvalue;\n\n\t/* Pad option length to 4-byte boundary */\n\tpadded_option_len = opthdr->option_length;\n\tpadded_option_len = ((padded_option_len + 3)/4)*4;\n\n\toptvalue = get_from_block_data(cursor, padded_option_len, errbuf);\n\tif (optvalue == NULL) {\n\t\t/*\n\t\t * Option value is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\treturn (optvalue);\n}\n\nstatic int\nprocess_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,\n    int64_t *tsoffset, int *is_binary, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\tvoid *optvalue;\n\tint saw_tsresol, saw_tsoffset;\n\tuint8_t tsresol_opt;\n\tu_int i;\n\n\tsaw_tsresol = 0;\n\tsaw_tsoffset = 0;\n\twhile (cursor->data_remaining != 0) {\n\t\t/*\n\t\t * Get the option header.\n\t\t */\n\t\topthdr = get_opthdr_from_block_data(p, cursor, errbuf);\n\t\tif (opthdr == NULL) {\n\t\t\t/*\n\t\t\t * Option header is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Get option value.\n\t\t */\n\t\toptvalue = get_optvalue_from_block_data(cursor, opthdr,\n\t\t    errbuf);\n\t\tif (optvalue == NULL) {\n\t\t\t/*\n\t\t\t * Option value is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\tswitch (opthdr->option_code) {\n\n\t\tcase OPT_ENDOFOPT:\n\t\t\tif (opthdr->option_length != 0) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has opt_endofopt option with length %u != 0\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase IF_TSRESOL:\n\t\t\tif (opthdr->option_length != 1) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsresol option with length %u != 1\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsresol) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsresol option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsresol = 1;\n\t\t\tmemcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));\n\t\t\tif (tsresol_opt & 0x80) {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 2.\n\t\t\t\t */\n\t\t\t\tuint8_t tsresol_shift = (tsresol_opt & 0x7F);\n\n\t\t\t\tif (tsresol_shift > 63) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value.\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 2^-%u is too high\",\n\t\t\t\t\t    tsresol_shift);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 1;\n\t\t\t\t*tsresol = ((uint64_t)1) << tsresol_shift;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 10.\n\t\t\t\t */\n\t\t\t\tif (tsresol_opt > 19) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value (the\n\t\t\t\t\t * largest power of 10 that fits\n\t\t\t\t\t * in a 64-bit value is 10^19, as\n\t\t\t\t\t * the largest 64-bit unsigned\n\t\t\t\t\t * value is ~1.8*10^19).\n\t\t\t\t\t */\n\t\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 10^-%u is too high\",\n\t\t\t\t\t    tsresol_opt);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 0;\n\t\t\t\t*tsresol = 1;\n\t\t\t\tfor (i = 0; i < tsresol_opt; i++)\n\t\t\t\t\t*tsresol *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IF_TSOFFSET:\n\t\t\tif (opthdr->option_length != 8) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsoffset option with length %u != 8\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsoffset) {\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsoffset option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsoffset = 1;\n\t\t\tmemcpy(tsoffset, optvalue, sizeof(*tsoffset));\n\t\t\tif (p->swapped)\n\t\t\t\t*tsoffset = SWAPLL(*tsoffset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn (0);\n}\n\nstatic int\nadd_interface(pcap_t *p, struct interface_description_block *idbp,\n    struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tuint64_t tsresol;\n\tint64_t tsoffset;\n\tint is_binary;\n\n\tps = p->priv;\n\n\t/*\n\t * Count this interface.\n\t */\n\tps->ifcount++;\n\n\t/*\n\t * Grow the array of per-interface information as necessary.\n\t */\n\tif (ps->ifcount > ps->ifaces_size) {\n\t\t/*\n\t\t * We need to grow the array.\n\t\t */\n\t\tbpf_u_int32 new_ifaces_size;\n\t\tstruct pcap_ng_if *new_ifaces;\n\n\t\tif (ps->ifaces_size == 0) {\n\t\t\t/*\n\t\t\t * It's currently empty.\n\t\t\t *\n\t\t\t * (The Clang static analyzer doesn't do enough,\n\t\t\t * err, umm, dataflow *analysis* to realize that\n\t\t\t * ps->ifaces_size == 0 if ps->ifaces == NULL,\n\t\t\t * and so complains about a possible zero argument\n\t\t\t * to realloc(), so we check for the former\n\t\t\t * condition to shut it up.\n\t\t\t *\n\t\t\t * However, it doesn't complain that one of the\n\t\t\t * multiplications below could overflow, which is\n\t\t\t * a real, albeit extremely unlikely, problem (you'd\n\t\t\t * need a pcapng file with tens of millions of\n\t\t\t * interfaces).)\n\t\t\t */\n\t\t\tnew_ifaces_size = 1;\n\t\t\tnew_ifaces = malloc(sizeof (struct pcap_ng_if));\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's not currently empty; double its size.\n\t\t\t * (Perhaps overkill once we have a lot of interfaces.)\n\t\t\t *\n\t\t\t * Check for overflow if we double it.\n\t\t\t */\n\t\t\tif (ps->ifaces_size * 2 < ps->ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * The maximum number of interfaces before\n\t\t\t\t * ps->ifaces_size overflows is the largest\n\t\t\t\t * possible 32-bit power of 2, as we do\n\t\t\t\t * size doubling.\n\t\t\t\t */\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0x80000000U);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ps->ifaces_size * 2 doesn't overflow, so it's\n\t\t\t * safe to multiply.\n\t\t\t */\n\t\t\tnew_ifaces_size = ps->ifaces_size * 2;\n\n\t\t\t/*\n\t\t\t * Now make sure that's not so big that it overflows\n\t\t\t * if we multiply by sizeof (struct pcap_ng_if).\n\t\t\t *\n\t\t\t * That can happen on 32-bit platforms, with a 32-bit\n\t\t\t * size_t; it shouldn't happen on 64-bit platforms,\n\t\t\t * with a 64-bit size_t, as new_ifaces_size is\n\t\t\t * 32 bits.\n\t\t\t */\n\t\t\tif (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * As this fails only with 32-bit size_t,\n\t\t\t\t * the multiplication was 32x32->32, and\n\t\t\t\t * the largest 32-bit value that can safely\n\t\t\t\t * be multiplied by sizeof (struct pcap_ng_if)\n\t\t\t\t * without overflow is the largest 32-bit\n\t\t\t\t * (unsigned) value divided by\n\t\t\t\t * sizeof (struct pcap_ng_if).\n\t\t\t\t */\n\t\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tnew_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));\n\t\t}\n\t\tif (new_ifaces == NULL) {\n\t\t\t/*\n\t\t\t * We ran out of memory.\n\t\t\t * Give up.\n\t\t\t */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"out of memory for per-interface information (%u interfaces)\",\n\t\t\t    ps->ifcount);\n\t\t\treturn (0);\n\t\t}\n\t\tps->ifaces_size = new_ifaces_size;\n\t\tps->ifaces = new_ifaces;\n\t}\n\n\tps->ifaces[ps->ifcount - 1].snaplen = idbp->snaplen;\n\n\t/*\n\t * Set the default time stamp resolution and offset.\n\t */\n\ttsresol = 1000000;\t/* microsecond resolution */\n\tis_binary = 0;\t\t/* which is a power of 10 */\n\ttsoffset = 0;\t\t/* absolute timestamps */\n\n\t/*\n\t * Now look for various time stamp options, so we know\n\t * how to interpret the time stamps for this interface.\n\t */\n\tif (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,\n\t    errbuf) == -1)\n\t\treturn (0);\n\n\tps->ifaces[ps->ifcount - 1].tsresol = tsresol;\n\tps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;\n\n\t/*\n\t * Determine whether we're scaling up or down or not\n\t * at all for this interface.\n\t */\n\tif (tsresol == ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is the resolution the user wants,\n\t\t * so we don't have to do scaling.\n\t\t */\n\t\tps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;\n\t} else if (tsresol > ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is greater than what the user wants,\n\t\t * so we have to scale the timestamps down.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The resolution is less than what the user wants,\n\t\t * so we have to scale the timestamps up.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;\n\t\t}\n\t}\n\treturn (1);\n}\n\n/*\n * Check whether this is a pcapng savefile and, if it is, extract the\n * relevant information from the header.\n */\npcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %zu < _%u_ < %u (BT_SHB_INSANE_MAX)\",\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n\t\t    total_length,\n\t\t    BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_ng_sf);\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)(p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* Currently only SHB versions 1.0 and 1.2 are supported;\n\t   version 1.2 is treated as being the same as version 1.0.\n\t   See the current version of the pcapng specification.\n\n\t   Version 1.2 is written by some programs that write additional\n\t   block types (which can be read by any code that handles them,\n\t   regardless of whether the minor version if 0 or 2, so that's\n\t   not a reason to change the minor version number).\n\n\t   XXX - the pcapng specification says that readers should\n\t   just ignore sections with an unsupported version number;\n\t   presumably they can also report an error if they skip\n\t   all the way to the end of the file without finding\n\t   any versions that they support. */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       (shbp->minor_version == PCAP_NG_VERSION_MINOR ||\n\t        shbp->minor_version == 2))) {\n\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, idbp, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tsnprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcapint_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}\n\nstatic void\npcap_ng_cleanup(pcap_t *p)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\n\tfree(ps->ifaces);\n\tpcapint_sf_cleanup(p);\n}\n\n/*\n * Read and return the next packet from the savefile.  Return the header\n * in hdr and a pointer to the contents in data.  Return 1 on success, 0\n * if there were no more packets, and -1 on an error.\n */\nstatic int\npcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\tstruct block_cursor cursor;\n\tint status;\n\tstruct enhanced_packet_block *epbp;\n\tstruct simple_packet_block *spbp;\n\tstruct packet_block *pbp;\n\tbpf_u_int32 interface_id = 0xFFFFFFFF;\n\tstruct interface_description_block *idbp;\n\tstruct section_header_block *shbp;\n\tFILE *fp = p->rfile;\n\tuint64_t t, sec, frac;\n\n\t/*\n\t * Look for an Enhanced Packet Block, a Simple Packet Block,\n\t * or a Packet Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the block type and length; those are common\n\t\t * to all blocks.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, p->errbuf);\n\t\tif (status == 0)\n\t\t\treturn (0);\t/* EOF */\n\t\tif (status == -1)\n\t\t\treturn (-1);\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_EPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * EPB.\n\t\t\t */\n\t\t\tepbp = get_from_block_data(&cursor, sizeof(*epbp),\n\t\t\t    p->errbuf);\n\t\t\tif (epbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPLONG(epbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(epbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(epbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(epbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = epbp->interface_id;\n\t\t\t\thdr->caplen = epbp->caplen;\n\t\t\t\thdr->len = epbp->len;\n\t\t\t\tt = ((uint64_t)epbp->timestamp_high) << 32 |\n\t\t\t\t    epbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_SPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * SPB.\n\t\t\t */\n\t\t\tspbp = get_from_block_data(&cursor, sizeof(*spbp),\n\t\t\t    p->errbuf);\n\t\t\tif (spbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * SPB packets are assumed to have arrived on\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tinterface_id = 0;\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\thdr->len = SWAPLONG(spbp->len);\n\t\t\t} else\n\t\t\t\thdr->len = spbp->len;\n\n\t\t\t/*\n\t\t\t * The SPB doesn't give the captured length;\n\t\t\t * it's the minimum of the snapshot length\n\t\t\t * and the packet length.\n\t\t\t */\n\t\t\thdr->caplen = hdr->len;\n\t\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\thdr->caplen = p->snapshot;\n\t\t\tt = 0;\t/* no time stamps */\n\t\t\tgoto found;\n\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * PB.\n\t\t\t */\n\t\t\tpbp = get_from_block_data(&cursor, sizeof(*pbp),\n\t\t\t    p->errbuf);\n\t\t\tif (pbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPSHORT(pbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(pbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(pbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(pbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = pbp->interface_id;\n\t\t\t\thdr->caplen = pbp->caplen;\n\t\t\t\thdr->len = pbp->len;\n\t\t\t\tt = ((uint64_t)pbp->timestamp_high) << 32 |\n\t\t\t\t    pbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Interface Description Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    p->errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the link-layer type or snapshot length\n\t\t\t * differ from the ones for the first IDB we\n\t\t\t * saw, quit.\n\t\t\t *\n\t\t\t * XXX - just discard packets from those\n\t\t\t * interfaces?\n\t\t\t */\n\t\t\tif (p->linktype != idbp->linktype) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a type %u different from the type of the first interface\",\n\t\t\t\t    idbp->linktype);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check against the *adjusted* value of this IDB's\n\t\t\t * snapshot length.\n\t\t\t */\n\t\t\tif ((bpf_u_int32)p->snapshot !=\n\t\t\t    pcapint_adjust_snapshot(p->linktype, idbp->snaplen)) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a snapshot length %u different from the snapshot length of the first interface\",\n\t\t\t\t    idbp->snaplen);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, idbp, &cursor, p->errbuf))\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\n\t\tcase BT_SHB:\n\t\t\t/*\n\t\t\t * Section Header Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tshbp = get_from_block_data(&cursor, sizeof(*shbp),\n\t\t\t    p->errbuf);\n\t\t\tif (shbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Assume the byte order of this section is\n\t\t\t * the same as that of the previous section.\n\t\t\t * We'll check for that later.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tshbp->byte_order_magic =\n\t\t\t\t    SWAPLONG(shbp->byte_order_magic);\n\t\t\t\tshbp->major_version =\n\t\t\t\t    SWAPSHORT(shbp->major_version);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the byte order doesn't change;\n\t\t\t * pcap_is_swapped() shouldn't change its\n\t\t\t * return value in the middle of reading a capture.\n\t\t\t */\n\t\t\tswitch (shbp->byte_order_magic) {\n\n\t\t\tcase BYTE_ORDER_MAGIC:\n\t\t\t\t/*\n\t\t\t\t * OK.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase SWAPLONG(BYTE_ORDER_MAGIC):\n\t\t\t\t/*\n\t\t\t\t * Byte order changes.\n\t\t\t\t */\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has sections with different byte orders\");\n\t\t\t\treturn (-1);\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Not a valid SHB.\n\t\t\t\t */\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has a section with a bad byte order magic field\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the major version is the version\n\t\t\t * we handle.\n\t\t\t */\n\t\t\tif (shbp->major_version != PCAP_NG_VERSION_MAJOR) {\n\t\t\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"unknown pcapng savefile major version number %u\",\n\t\t\t\t    shbp->major_version);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Reset the interface count; this section should\n\t\t\t * have its own set of IDBs.  If any of them\n\t\t\t * don't have the same interface type, snapshot\n\t\t\t * length, or resolution as the first interface\n\t\t\t * we saw, we'll fail.  (And if we don't see\n\t\t\t * any IDBs, we'll fail when we see a packet\n\t\t\t * block.)\n\t\t\t */\n\t\t\tps->ifcount = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a packet block, IDB, or SHB; ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\nfound:\n\t/*\n\t * Is the interface ID an interface we know?\n\t */\n\tif (interface_id >= ps->ifcount) {\n\t\t/*\n\t\t * Yes.  Fail.\n\t\t */\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"a packet arrived on interface %u, but there's no Interface Description Block for that interface\",\n\t\t    interface_id);\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Convert the time stamp to seconds and fractions of a second,\n\t * with the fractions being in units of the file-supplied resolution.\n\t */\n\tsec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;\n\tfrac = t % ps->ifaces[interface_id].tsresol;\n\n\t/*\n\t * Convert the fractions from units of the file-supplied resolution\n\t * to units of the user-requested resolution.\n\t */\n\tswitch (ps->ifaces[interface_id].scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * The interface resolution is what the user wants,\n\t\t * so we're done.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP_DEC:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is greater than the file-supplied\n\t\t * resolution, so the quotient in question is an integer.\n\t\t * We've calculated that quotient already, so we just\n\t\t * multiply by it.\n\t\t */\n\t\tfrac *= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\tcase SCALE_UP_BIN:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, so, in order to do this\n\t\t * entirely with integer arithmetic, we multiply by the\n\t\t * user-requested resolution and divide by the file-\n\t\t * supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\n\tcase SCALE_DOWN_DEC:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is less than the file-supplied\n\t\t * resolution, so the quotient in question isn't an\n\t\t * integer, but its reciprocal is, and we can just divide\n\t\t * by the reciprocal of the quotient.  We've calculated\n\t\t * the reciprocal of that quotient already, so we must\n\t\t * divide by it.\n\t\t */\n\t\tfrac /= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\n\tcase SCALE_DOWN_BIN:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; convert the fractional part to units of the\n\t\t * resolution the user requested by multiplying by the\n\t\t * quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.  We do that by multiplying\n\t\t * by the user-requested resolution and dividing by the\n\t\t * file-supplied resolution, as the quotient might not\n\t\t * fit in an integer.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, and neither is its\n\t\t * reciprocal, so, in order to do this entirely with\n\t\t * integer arithmetic, we multiply by the user-requested\n\t\t * resolution and divide by the file-supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\t}\n#ifdef _WIN32\n\t/*\n\t * tv_sec and tv_usec in the Windows struct timeval are both\n\t * longs.\n\t */\n\thdr->ts.tv_sec = (long)sec;\n\thdr->ts.tv_usec = (long)frac;\n#else\n\t/*\n\t * tv_sec in the UN*X struct timeval is a time_t; tv_usec is\n\t * suseconds_t in UN*Xes that work the way the current Single\n\t * UNIX Standard specify - but not all older UN*Xes necessarily\n\t * support that type, so just cast to int.\n\t */\n\thdr->ts.tv_sec = (time_t)sec;\n\thdr->ts.tv_usec = (int)frac;\n#endif\n\n\t/*\n\t * Get a pointer to the packet data.\n\t */\n\t*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);\n\tif (*data == NULL)\n\t\treturn (-1);\n\n\tpcapint_post_process(p->linktype, p->swapped, hdr, *data);\n\n\treturn (1);\n}\n"
        },
        {
          "name": "sf-pcapng.h",
          "type": "blob",
          "size": 1.4091796875,
          "content": "/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcapng.h - pcapng-file-format-specific routines\n *\n * Used to read pcapng savefiles.\n */\n\n#ifndef sf_pcapng_h\n#define\tsf_pcapng_h\n\nextern pcap_t *pcap_ng_check_header(const uint8_t *magic, FILE *fp,\n    u_int precision, char *errbuf, int *err);\n\n#endif\n"
        },
        {
          "name": "sockutils.c",
          "type": "blob",
          "size": 62.330078125,
          "content": "/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n/*\n * \\file sockutils.c\n *\n * The goal of this file is to provide a common set of primitives for socket\n * manipulation.\n *\n * Although the socket interface defined in the RFC 2553 (and its updates)\n * is excellent, there are still differences between the behavior of those\n * routines on UN*X and Windows, and between UN*Xes.\n *\n * These calls provide an interface similar to the socket interface, but\n * that hides the differences between operating systems.  It does not\n * attempt to significantly improve on the socket interface in other\n * ways.\n */\n\n#include \"ftmacros.h\"\n\n#include <string.h>\n#include <errno.h>\t/* for the errno variable */\n#include <stdio.h>\t/* for the stderr file */\n#include <stdlib.h>\t/* for malloc() and free() */\n#include <limits.h>\t/* for INT_MAX */\n\n#include \"pcap-int.h\"\n\n#include \"sockutils.h\"\n#include \"portability.h\"\n\n#ifdef _WIN32\n  /*\n   * Winsock initialization.\n   *\n   * Ask for Winsock 2.2.\n   */\n  #define WINSOCK_MAJOR_VERSION 2\n  #define WINSOCK_MINOR_VERSION 2\n#endif\n\n/* Some minor differences between UNIX and Win32 */\n#ifdef _WIN32\n  #define SHUT_WR SD_SEND\t/* The control code for shutdown() is different in Win32 */\n#endif\n\n/* Size of the buffer that has to keep error messages */\n#define SOCK_ERRBUF_SIZE 1024\n\n/* Constants; used in order to keep strings here */\n#define SOCKET_NO_NAME_AVAILABLE \"No name available\"\n#define SOCKET_NO_PORT_AVAILABLE \"No port available\"\n#define SOCKET_NAME_NULL_DAD \"Null address (possibly DAD Phase)\"\n\n/*\n * On UN*X, send() and recv() return ssize_t.\n *\n * On Windows, send() and recv() return an int.\n *\n *   With MSVC, there *is* no ssize_t.\n *\n *   With MinGW, there is an ssize_t type; it is either an int (32 bit)\n *   or a long long (64 bit).\n *\n * So, on Windows, if we don't have ssize_t defined, define it as an\n * int, so we can use it, on all platforms, as the type of variables\n * that hold the return values from send() and recv().\n */\n#if defined(_WIN32) && !defined(_SSIZE_T_DEFINED)\ntypedef int ssize_t;\n#endif\n\n/****************************************************\n *                                                  *\n * Locally defined functions                        *\n *                                                  *\n ****************************************************/\n\nstatic int sock_ismcastaddr(const struct sockaddr *saddr);\n\n/****************************************************\n *                                                  *\n * Function bodies                                  *\n *                                                  *\n ****************************************************/\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\nconst uint8_t *fuzzBuffer;\nsize_t fuzzSize;\nsize_t fuzzPos;\n\nvoid sock_initfuzz(const uint8_t *Data, size_t Size) {\n\tfuzzPos = 0;\n\tfuzzSize = Size;\n\tfuzzBuffer = Data;\n}\n\nstatic int fuzz_recv(char *bufp, int remaining) {\n\tif (remaining > fuzzSize - fuzzPos) {\n\t\tremaining = fuzzSize - fuzzPos;\n\t}\n\tif (fuzzPos < fuzzSize) {\n\t\tmemcpy(bufp, fuzzBuffer + fuzzPos, remaining);\n\t}\n\tfuzzPos += remaining;\n\treturn remaining;\n}\n#endif\n\nint sock_geterrcode(void)\n{\n#ifdef _WIN32\n\treturn GetLastError();\n#else\n\treturn errno;\n#endif\n}\n\n/*\n * Format an error message given an errno value (UN*X) or a Winsock error\n * (Windows).\n */\nvoid sock_vfmterrmsg(char *errbuf, size_t errbuflen, int errcode,\n    const char *fmt, va_list ap)\n{\n\tif (errbuf == NULL)\n\t\treturn;\n\n#ifdef _WIN32\n\tpcapint_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errcode,\n\t    fmt, ap);\n#else\n\tpcapint_vfmt_errmsg_for_errno(errbuf, errbuflen, errcode,\n\t    fmt, ap);\n#endif\n}\n\nvoid sock_fmterrmsg(char *errbuf, size_t errbuflen, int errcode,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tsock_vfmterrmsg(errbuf, errbuflen, errcode, fmt, ap);\n\tva_end(ap);\n}\n\n/*\n * Format an error message for the last socket error.\n */\nvoid sock_geterrmsg(char *errbuf, size_t errbuflen, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tsock_vfmterrmsg(errbuf, errbuflen, sock_geterrcode(), fmt, ap);\n\tva_end(ap);\n}\n\n/*\n * Types of error.\n *\n * These are sorted by how likely they are to be the \"underlying\" problem,\n * so that lower-rated errors for a given address in a given family\n * should not overwrite higher-rated errors for another address in that\n * family, and higher-rated errors should overwrite lower-rated errors.\n */\ntypedef enum {\n\tSOCK_CONNERR,\t\t/* connection error */\n\tSOCK_HOSTERR,\t\t/* host error */\n\tSOCK_NETERR,\t\t/* network error */\n\tSOCK_AFNOTSUPERR,\t/* address family not supported */\n\tSOCK_UNKNOWNERR,\t/* unknown error */\n\tSOCK_NOERR\t\t/* no error */\n} sock_errtype;\n\nstatic sock_errtype sock_geterrtype(int errcode)\n{\n\tswitch (errcode) {\n\n#ifdef _WIN32\n\tcase WSAECONNRESET:\n\tcase WSAECONNABORTED:\n\tcase WSAECONNREFUSED:\n#else\n\tcase ECONNRESET:\n\tcase ECONNABORTED:\n\tcase ECONNREFUSED:\n#endif\n\t\t/*\n\t\t * Connection error; this means the problem is probably\n\t\t * that there's no server set up on the remote machine,\n\t\t * or that it is set up, but it's IPv4-only or IPv6-only\n\t\t * and we're trying the wrong address family.\n\t\t *\n\t\t * These overwrite all other errors, as they indicate\n\t\t * that, even if something else went wrong in another\n\t\t * attempt, this probably wouldn't work even if the\n\t\t * other problems were fixed.\n\t\t */\n\t\treturn (SOCK_CONNERR);\n\n#ifdef _WIN32\n\tcase WSAENETUNREACH:\n\tcase WSAETIMEDOUT:\n\tcase WSAEHOSTDOWN:\n\tcase WSAEHOSTUNREACH:\n#else\n\tcase ENETUNREACH:\n\tcase ETIMEDOUT:\n\tcase EHOSTDOWN:\n\tcase EHOSTUNREACH:\n#endif\n\t\t/*\n\t\t * Network errors that could be IPv4-specific, IPv6-\n\t\t * specific, or present with both.\n\t\t *\n\t\t * Don't overwrite connection errors, but overwrite\n\t\t * everything else.\n\t\t */\n\t\treturn (SOCK_HOSTERR);\n\n#ifdef _WIN32\n\tcase WSAENETDOWN:\n\tcase WSAENETRESET:\n#else\n\tcase ENETDOWN:\n\tcase ENETRESET:\n#endif\n\t\t/*\n\t\t * Network error; this means we don't know whether\n\t\t * there's a server set up on the remote machine,\n\t\t * and we don't have a reason to believe that IPv6\n\t\t * any worse or better than IPv4.\n\t\t *\n\t\t * These probably indicate a local failure, e.g.\n\t\t * an interface is down.\n\t\t *\n\t\t * Don't overwrite connection errors or host errors,\n\t\t * but overwrite everything else.\n\t\t */\n\t\treturn (SOCK_NETERR);\n\n#ifdef _WIN32\n\tcase WSAEAFNOSUPPORT:\n#else\n\tcase EAFNOSUPPORT:\n#endif\n\t\t/*\n\t\t * \"Address family not supported\" probably means\n\t\t * \"No soup^WIPv6 for you!\".\n\t\t *\n\t\t * Don't overwrite connection errors, host errors, or\n\t\t * network errors (none of which we should get for this\n\t\t * address family if it's not supported), but overwrite\n\t\t * everything else.\n\t\t */\n\t\treturn (SOCK_AFNOTSUPERR);\n\n\tdefault:\n\t\t/*\n\t\t * Anything else.\n\t\t *\n\t\t * Don't overwrite any errors.\n\t\t */\n\t\treturn (SOCK_UNKNOWNERR);\n\t}\n}\n\n/*\n * \\brief This function initializes the socket mechanism, if\n * necessary.\n *\n * On UN*Xes, it doesn't need to do anything; on Windows, it needs to\n * call WSAStartup().\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain\n * the complete error message. This buffer has to be at least 'errbuflen'\n * in length. It can be NULL; in this case no error message is supplied.\n *\n * \\param errbuflen: length of the buffer that will contains the error.\n * The error message cannot be larger than 'errbuflen - 1' because the\n * last char is reserved for the string terminator.\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred. The\n * error message is returned in the buffer pointed to by 'errbuf' variable.\n */\n#ifdef _WIN32\nint sock_init(char *errbuf, int errbuflen)\n{\n\tint errcode;\n\tWSADATA wsaData;\t\t\t/* helper variable needed to initialize Winsock */\n\n\terrcode = WSAStartup(MAKEWORD(WINSOCK_MAJOR_VERSION,\n\t    WINSOCK_MINOR_VERSION), &wsaData);\n\tif (errcode != 0)\n\t{\n\t\tif (errbuf) {\n\t\t\tsock_fmterrmsg(errbuf, errbuflen, errcode,\n\t\t\t    \"WSAStartup() failed\");\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n#else\nint sock_init(char *errbuf _U_, int errbuflen _U_)\n{\n\t/*\n\t * Nothing to do on UN*Xes.\n\t */\n\treturn 0;\n}\n#endif\n\n/*\n * \\brief This function cleans up after a sock_init().\n *\n * On UN*Xes, it doesn't need to do anything; on Windows, it needs\n * to clean up Winsock.\n *\n * \\return No error values.\n */\nvoid sock_cleanup(void)\n{\n#ifdef _WIN32\n\tWSACleanup();\n#endif\n}\n\n/*\n * \\brief It checks if the sockaddr variable contains a multicast address.\n *\n * \\return '0' if the address is multicast, '-1' if it is not.\n */\nstatic int sock_ismcastaddr(const struct sockaddr *saddr)\n{\n\tif (saddr->sa_family == PF_INET)\n\t{\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *) saddr;\n\t\tif (IN_MULTICAST(ntohl(saddr4->sin_addr.s_addr))) return 0;\n\t\telse return -1;\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *) saddr;\n\t\tif (IN6_IS_ADDR_MULTICAST(&saddr6->sin6_addr)) return 0;\n\t\telse return -1;\n\t}\n}\n\nstruct addr_status {\n\tstruct addrinfo *info;\n\tint errcode;\n\tsock_errtype errtype;\n};\n\n/*\n * Sort by IPv4 address vs. IPv6 address.\n */\nstatic int compare_addrs_to_try_by_address_family(const void *a, const void *b)\n{\n\tconst struct addr_status *addr_a = (const struct addr_status *)a;\n\tconst struct addr_status *addr_b = (const struct addr_status *)b;\n\n\treturn addr_a->info->ai_family - addr_b->info->ai_family;\n}\n\n/*\n * Sort by error type and, within a given error type, by error code and,\n * within a given error code, by IPv4 address vs. IPv6 address.\n */\nstatic int compare_addrs_to_try_by_status(const void *a, const void *b)\n{\n\tconst struct addr_status *addr_a = (const struct addr_status *)a;\n\tconst struct addr_status *addr_b = (const struct addr_status *)b;\n\n\tif (addr_a->errtype == addr_b->errtype)\n\t{\n\t\tif (addr_a->errcode == addr_b->errcode)\n\t\t{\n\t\t\treturn addr_a->info->ai_family - addr_b->info->ai_family;\n\t\t}\n\t\treturn addr_a->errcode - addr_b->errcode;\n\t}\n\n\treturn addr_a->errtype - addr_b->errtype;\n}\n\nstatic PCAP_SOCKET sock_create_socket(struct addrinfo *addrinfo, char *errbuf,\n    int errbuflen)\n{\n\tPCAP_SOCKET sock;\n#ifdef SO_NOSIGPIPE\n\tint on = 1;\n#endif\n\n\tsock = socket(addrinfo->ai_family, addrinfo->ai_socktype,\n\t    addrinfo->ai_protocol);\n\tif (sock == INVALID_SOCKET)\n\t{\n\t\tsock_geterrmsg(errbuf, errbuflen, \"socket() failed\");\n\t\treturn INVALID_SOCKET;\n\t}\n\n\t/*\n\t * Disable SIGPIPE, if we have SO_NOSIGPIPE.  We don't want to\n\t * have to deal with signals if the peer closes the connection,\n\t * especially in client programs, which may not even be aware that\n\t * they're sending to sockets.\n\t */\n#ifdef SO_NOSIGPIPE\n\tif (setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (char *)&on,\n\t    sizeof (int)) == -1)\n\t{\n\t\tsock_geterrmsg(errbuf, errbuflen,\n\t\t    \"setsockopt(SO_NOSIGPIPE) failed\");\n\t\tclosesocket(sock);\n\t\treturn INVALID_SOCKET;\n\t}\n#endif\n\treturn sock;\n}\n\n/*\n * \\brief It initializes a network connection both from the client and the server side.\n *\n * In case of a client socket, this function calls socket() and connect().\n * In the meanwhile, it checks for any socket error.\n * If an error occurs, it writes the error message into 'errbuf'.\n *\n * In case of a server socket, the function calls socket(), bind() and listen().\n *\n * This function is usually preceded by the sock_initaddress().\n *\n * \\param host: for client sockets, the host name to which we're trying\n * to connect.\n *\n * \\param addrinfo: pointer to an addrinfo variable which will be used to\n * open the socket and such. This variable is the one returned by the previous call to\n * sock_initaddress().\n *\n * \\param server: '1' if this is a server socket, '0' otherwise.\n *\n * \\param nconn: number of the connections that are allowed to wait into the listen() call.\n * This value has no meanings in case of a client socket.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return the socket that has been opened (that has to be used in the following sockets calls)\n * if everything is fine, INVALID_SOCKET if some errors occurred. The error message is returned\n * in the 'errbuf' variable.\n */\nPCAP_SOCKET sock_open(const char *host, struct addrinfo *addrinfo,\n    int server, int nconn, char *errbuf, int errbuflen)\n{\n\tPCAP_SOCKET sock;\n\n\t/* This is a server socket */\n\tif (server)\n\t{\n\t\tint on;\n\n\t\t/*\n\t\t * Attempt to create the socket.\n\t\t */\n\t\tsock = sock_create_socket(addrinfo, errbuf, errbuflen);\n\t\tif (sock == INVALID_SOCKET)\n\t\t{\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\n\t\t/*\n\t\t * Allow a new server to bind the socket after the old one\n\t\t * exited, even if lingering sockets are still present.\n\t\t *\n\t\t * Don't treat an error as a failure.\n\t\t */\n\t\ton = 1;\n\t\t(void)setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t    (char *)&on, sizeof (on));\n\n#if defined(IPV6_V6ONLY) || defined(IPV6_BINDV6ONLY)\n\t\t/*\n\t\t * Force the use of IPv6-only addresses.\n\t\t *\n\t\t * RFC 3493 indicates that you can support IPv4 on an\n\t\t * IPv6 socket:\n\t\t *\n\t\t *    https://tools.ietf.org/html/rfc3493#section-3.7\n\t\t *\n\t\t * and that this is the default behavior.  This means\n\t\t * that if we first create an IPv6 socket bound to the\n\t\t * \"any\" address, it is, in effect, also bound to the\n\t\t * IPv4 \"any\" address, so when we create an IPv4 socket\n\t\t * and try to bind it to the IPv4 \"any\" address, it gets\n\t\t * EADDRINUSE.\n\t\t *\n\t\t * Not all network stacks support IPv4 on IPv6 sockets;\n\t\t * pre-NT 6 Windows stacks don't support it, and the\n\t\t * OpenBSD stack doesn't support it for security reasons\n\t\t * (see the OpenBSD inet6(4) man page).  Therefore, we\n\t\t * don't want to rely on this behavior.\n\t\t *\n\t\t * So we try to disable it, using either the IPV6_V6ONLY\n\t\t * option from RFC 3493:\n\t\t *\n\t\t *    https://tools.ietf.org/html/rfc3493#section-5.3\n\t\t *\n\t\t * or the IPV6_BINDV6ONLY option from older UN*Xes.\n\t\t */\n#ifndef IPV6_V6ONLY\n  /* For older systems */\n  #define IPV6_V6ONLY IPV6_BINDV6ONLY\n#endif /* IPV6_V6ONLY */\n\t\tif (addrinfo->ai_family == PF_INET6)\n\t\t{\n\t\t\ton = 1;\n\t\t\tif (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t    (char *)&on, sizeof (int)) == -1)\n\t\t\t{\n\t\t\t\tif (errbuf)\n\t\t\t\t\tsnprintf(errbuf, errbuflen, \"setsockopt(IPV6_V6ONLY)\");\n\t\t\t\tclosesocket(sock);\n\t\t\t\treturn INVALID_SOCKET;\n\t\t\t}\n\t\t}\n#endif /* defined(IPV6_V6ONLY) || defined(IPV6_BINDV6ONLY) */\n\n\t\t/* WARNING: if the address is a mcast one, I should place the proper Win32 code here */\n\t\tif (bind(sock, addrinfo->ai_addr, (int) addrinfo->ai_addrlen) != 0)\n\t\t{\n\t\t\tsock_geterrmsg(errbuf, errbuflen, \"bind() failed\");\n\t\t\tclosesocket(sock);\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\n\t\tif (addrinfo->ai_socktype == SOCK_STREAM)\n\t\t\tif (listen(sock, nconn) == -1)\n\t\t\t{\n\t\t\t\tsock_geterrmsg(errbuf, errbuflen,\n\t\t\t\t    \"listen() failed\");\n\t\t\t\tclosesocket(sock);\n\t\t\t\treturn INVALID_SOCKET;\n\t\t\t}\n\n\t\t/* server side ended */\n\t\treturn sock;\n\t}\n\telse\t/* we're the client */\n\t{\n\t\tstruct addr_status *addrs_to_try;\n\t\tstruct addrinfo *tempaddrinfo;\n\t\tsize_t numaddrinfos;\n\t\tsize_t i;\n\t\tint current_af = AF_UNSPEC;\n\n\t\t/*\n\t\t * We have to loop though all the addrinfos returned.\n\t\t * For instance, we can have both IPv6 and IPv4 addresses,\n\t\t * but the service we're trying to connect to is unavailable\n\t\t * in IPv6, so we have to try in IPv4 as well.\n\t\t *\n\t\t * How many addrinfos do we have?\n\t\t */\n\t\tnumaddrinfos =  0;\n\t\tfor (tempaddrinfo = addrinfo; tempaddrinfo != NULL;\n\t\t    tempaddrinfo = tempaddrinfo->ai_next)\n\t\t{\n\t\t\tnumaddrinfos++;\n\t\t}\n\n\t\tif (numaddrinfos == 0)\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"There are no addresses in the address list\");\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\n\t\t/*\n\t\t * Allocate an array of struct addr_status and fill it in.\n\t\t */\n\t\taddrs_to_try = calloc(numaddrinfos, sizeof *addrs_to_try);\n\t\tif (addrs_to_try == NULL)\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"Out of memory connecting to %s\", host);\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\n\t\tfor (tempaddrinfo = addrinfo, i = 0; tempaddrinfo != NULL;\n\t\t    tempaddrinfo = tempaddrinfo->ai_next, i++)\n\t\t{\n\t\t\taddrs_to_try[i].info = tempaddrinfo;\n\t\t\taddrs_to_try[i].errcode = 0;\n\t\t\taddrs_to_try[i].errtype = SOCK_NOERR;\n\t\t}\n\n\t\t/*\n\t\t * Sort the structures to put the IPv4 addresses before the\n\t\t * IPv6 addresses; we will have to create an IPv4 socket\n\t\t * for the IPv4 addresses and an IPv6 socket for the IPv6\n\t\t * addresses (one of the arguments to socket() is the\n\t\t * address/protocol family to use, and IPv4 and IPv6 are\n\t\t * separate address/protocol families).\n\t\t */\n\t\tqsort(addrs_to_try, numaddrinfos, sizeof *addrs_to_try,\n\t\t    compare_addrs_to_try_by_address_family);\n\n\t\t/* Start out with no socket. */\n\t\tsock = INVALID_SOCKET;\n\n\t\t/*\n\t\t * Now try them all.\n\t\t */\n\t\tfor (i = 0; i < numaddrinfos; i++)\n\t\t{\n\t\t\ttempaddrinfo = addrs_to_try[i].info;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\tbreak;\n#endif\n\t\t\t/*\n\t\t\t * If we have a socket, but it's for a\n\t\t\t * different address family, close it.\n\t\t\t */\n\t\t\tif (sock != INVALID_SOCKET &&\n\t\t\t    current_af != tempaddrinfo->ai_family)\n\t\t\t{\n\t\t\t\tclosesocket(sock);\n\t\t\t\tsock = INVALID_SOCKET;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we don't have a socket, open one\n\t\t\t * for *this* address's address family.\n\t\t\t */\n\t\t\tif (sock == INVALID_SOCKET)\n\t\t\t{\n\t\t\t\tsock = sock_create_socket(tempaddrinfo,\n\t\t\t\t    errbuf, errbuflen);\n\t\t\t\tif (sock == INVALID_SOCKET)\n\t\t\t\t{\n\t\t\t\t\tfree(addrs_to_try);\n\t\t\t\t\treturn INVALID_SOCKET;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (connect(sock, tempaddrinfo->ai_addr, (int) tempaddrinfo->ai_addrlen) == -1)\n\t\t\t{\n\t\t\t\taddrs_to_try[i].errcode = sock_geterrcode();\n\t\t\t\taddrs_to_try[i].errtype =\n\t\t\t\t   sock_geterrtype(addrs_to_try[i].errcode);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check how we exited from the previous loop.\n\t\t * If tempaddrinfo is equal to NULL, it means that all\n\t\t * the connect() attempts failed.  Construct an\n\t\t * error message.\n\t\t */\n\t\tif (i == numaddrinfos)\n\t\t{\n\t\t\tint same_error_for_all;\n\t\t\tint first_error;\n\n\t\t\tclosesocket(sock);\n\n\t\t\t/*\n\t\t\t * Sort the statuses to group together categories\n\t\t\t * of errors, errors within categories, and\n\t\t\t * address families within error sets.\n\t\t\t */\n\t\t\tqsort(addrs_to_try, numaddrinfos, sizeof *addrs_to_try,\n\t\t\t    compare_addrs_to_try_by_status);\n\n\t\t\t/*\n\t\t\t * Are all the errors the same?\n\t\t\t */\n\t\t\tsame_error_for_all = 1;\n\t\t\tfirst_error = addrs_to_try[0].errcode;\n\t\t\tfor (i = 1; i < numaddrinfos; i++)\n\t\t\t{\n\t\t\t\tif (addrs_to_try[i].errcode != first_error)\n\t\t\t\t{\n\t\t\t\t\tsame_error_for_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (same_error_for_all) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  No need to show the IP\n\t\t\t\t * addresses.\n\t\t\t\t */\n\t\t\t\tif (addrs_to_try[0].errtype == SOCK_CONNERR) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Connection error; note that\n\t\t\t\t\t * the daemon might not be set\n\t\t\t\t\t * up correctly, or set up at all.\n\t\t\t\t\t */\n\t\t\t\t\tsock_fmterrmsg(errbuf, errbuflen,\n\t\t\t\t\t    addrs_to_try[0].errcode,\n\t\t\t\t\t    \"Is the server properly installed? Cannot connect to %s\",\n\t\t\t\t\t    host);\n\t\t\t\t} else {\n\t\t\t\t\tsock_fmterrmsg(errbuf, errbuflen,\n\t\t\t\t\t    addrs_to_try[0].errcode,\n\t\t\t\t\t    \"Cannot connect to %s\", host);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Show all the errors and the IP addresses\n\t\t\t\t * to which they apply.\n\t\t\t\t */\n\t\t\t\tchar *errbufptr;\n\t\t\t\tsize_t bufspaceleft;\n\t\t\t\tsize_t msglen;\n\n\t\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t\t    \"Connect to %s failed: \", host);\n\n\t\t\t\tmsglen = strlen(errbuf);\n\t\t\t\terrbufptr = errbuf + msglen;\n\t\t\t\tbufspaceleft = errbuflen - msglen;\n\n\t\t\t\tfor (i = 0; i < numaddrinfos &&\n\t\t\t\t    addrs_to_try[i].errcode != SOCK_NOERR;\n\t\t\t\t    i++)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Get the string for the address\n\t\t\t\t\t * and port that got this error.\n\t\t\t\t\t */\n\t\t\t\t\tsock_getascii_addrport((struct sockaddr_storage *) addrs_to_try[i].info->ai_addr,\n\t\t\t\t\t    errbufptr, (int)bufspaceleft,\n\t\t\t\t\t    NULL, 0, NI_NUMERICHOST, NULL, 0);\n\t\t\t\t\tmsglen = strlen(errbuf);\n\t\t\t\t\terrbufptr = errbuf + msglen;\n\t\t\t\t\tbufspaceleft = errbuflen - msglen;\n\n\t\t\t\t\tif (i + 1 < numaddrinfos &&\n\t\t\t\t\t    addrs_to_try[i + 1].errcode == addrs_to_try[i].errcode)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's another error\n\t\t\t\t\t\t * after this, and it has\n\t\t\t\t\t\t * the same error code.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Append a comma, as the\n\t\t\t\t\t\t * list of addresses with\n\t\t\t\t\t\t * this error has another\n\t\t\t\t\t\t * entry.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsnprintf(errbufptr, bufspaceleft,\n\t\t\t\t\t\t    \", \");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Either there are no\n\t\t\t\t\t\t * more errors after this,\n\t\t\t\t\t\t * or the next error is\n\t\t\t\t\t\t * different.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Append a colon and\n\t\t\t\t\t\t * the message for tis\n\t\t\t\t\t\t * error, followed by a\n\t\t\t\t\t\t * comma if there are\n\t\t\t\t\t\t * more errors.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsock_fmterrmsg(errbufptr,\n\t\t\t\t\t\t    bufspaceleft,\n\t\t\t\t\t\t    addrs_to_try[i].errcode,\n\t\t\t\t\t\t    \"%s\", \"\");\n\t\t\t\t\t\tmsglen = strlen(errbuf);\n\t\t\t\t\t\terrbufptr = errbuf + msglen;\n\t\t\t\t\t\tbufspaceleft = errbuflen - msglen;\n\n\t\t\t\t\t\tif (i + 1 < numaddrinfos &&\n\t\t\t\t\t\t    addrs_to_try[i + 1].errcode != SOCK_NOERR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * More to come.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tsnprintf(errbufptr,\n\t\t\t\t\t\t\t    bufspaceleft,\n\t\t\t\t\t\t\t    \", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmsglen = strlen(errbuf);\n\t\t\t\t\terrbufptr = errbuf + msglen;\n\t\t\t\t\tbufspaceleft = errbuflen - msglen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(addrs_to_try);\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree(addrs_to_try);\n\t\t\treturn sock;\n\t\t}\n\t}\n}\n\n/*\n * \\brief Closes the present (TCP and UDP) socket connection.\n *\n * This function sends a shutdown() on the socket in order to disable send() calls\n * (while recv() ones are still allowed). Then, it closes the socket.\n *\n * \\param sock: the socket identifier of the connection that has to be closed.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred. The error message is returned\n * in the 'errbuf' variable.\n */\nint sock_close(PCAP_SOCKET sock, char *errbuf, int errbuflen)\n{\n\t/*\n\t * SHUT_WR: subsequent calls to the send function are disallowed.\n\t * For TCP sockets, a FIN will be sent after all data is sent and\n\t * acknowledged by the Server.\n\t */\n\tif (shutdown(sock, SHUT_WR))\n\t{\n\t\tsock_geterrmsg(errbuf, errbuflen, \"shutdown() failed\");\n\t\t/* close the socket anyway */\n\t\tclosesocket(sock);\n\t\treturn -1;\n\t}\n\n\tclosesocket(sock);\n\treturn 0;\n}\n\n/*\n * gai_strerror() has some problems:\n *\n * 1) on Windows, Microsoft explicitly says it's not thread-safe;\n * 2) on UN*X, the Single UNIX Specification doesn't say it *is*\n *    thread-safe, so an implementation might use a static buffer\n *    for unknown error codes;\n * 3) the error message for the most likely error, EAI_NONAME, is\n *    truly horrible on several platforms (\"nodename nor servname\n *    provided, or not known\"?  It's typically going to be \"not\n *    known\", not \"oopsie, I passed null pointers for the host name\n *    and service name\", not to mention they forgot the \"neither\");\n *\n * so we roll our own.\n */\nstatic void\nget_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,\n    const char *hostname, const char *portname)\n{\n\tchar hostport[PCAP_ERRBUF_SIZE];\n\n\tif (hostname != NULL && portname != NULL)\n\t\tsnprintf(hostport, PCAP_ERRBUF_SIZE, \"host and port %s:%s\",\n\t\t    hostname, portname);\n\telse if (hostname != NULL)\n\t\tsnprintf(hostport, PCAP_ERRBUF_SIZE, \"host %s\",\n\t\t    hostname);\n\telse if (portname != NULL)\n\t\tsnprintf(hostport, PCAP_ERRBUF_SIZE, \"port %s\",\n\t\t    portname);\n\telse\n\t\tsnprintf(hostport, PCAP_ERRBUF_SIZE, \"<no host or port!>\");\n\tswitch (err)\n\t{\n#ifdef EAI_ADDRFAMILY\n\t\tcase EAI_ADDRFAMILY:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sAddress family for %s not supported\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tcase EAI_AGAIN:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%s%s could not be resolved at this time\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_BADFLAGS:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe ai_flags parameter for looking up %s had an invalid value\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_FAIL:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sA non-recoverable error occurred when attempting to resolve %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_FAMILY:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe address family for looking up %s was not recognized\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_MEMORY:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sOut of memory trying to allocate storage when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\t/*\n\t\t * RFC 2553 had both EAI_NODATA and EAI_NONAME.\n\t\t *\n\t\t * RFC 3493 has only EAI_NONAME.\n\t\t *\n\t\t * Some implementations define EAI_NODATA and EAI_NONAME\n\t\t * to the same value, others don't.  If EAI_NODATA is\n\t\t * defined and isn't the same as EAI_NONAME, we handle\n\t\t * EAI_NODATA.\n\t\t */\n#if defined(EAI_NODATA) && EAI_NODATA != EAI_NONAME\n\t\tcase EAI_NODATA:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sNo address associated with %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tcase EAI_NONAME:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe %s couldn't be resolved\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_SERVICE:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe service value specified when looking up %s as not recognized for the socket type\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_SOCKTYPE:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe socket type specified when looking up %s as not recognized\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n#ifdef EAI_SYSTEM\n\t\tcase EAI_SYSTEM:\n\t\t\t/*\n\t\t\t * Assumed to be UN*X.\n\t\t\t */\n\t\t\tpcapint_fmt_errmsg_for_errno(errbuf, errbuflen, errno,\n\t\t\t    \"%sAn error occurred when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_BADHINTS\n\t\tcase EAI_BADHINTS:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sInvalid value for hints when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_PROTOCOL\n\t\tcase EAI_PROTOCOL:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sResolved protocol when looking up %s is unknown\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_OVERFLOW\n\t\tcase EAI_OVERFLOW:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sArgument buffer overflow when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"%sgetaddrinfo() error %d when looking up %s\",\n\t\t\t    prefix, err, hostport);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * \\brief Checks that the address, port and flags given are valid and it returns an 'addrinfo' structure.\n *\n * This function basically calls the getaddrinfo() calls, and it performs a set of sanity checks\n * to control that everything is fine (e.g. a TCP socket cannot have a mcast address, and such).\n * If an error occurs, it writes the error message into 'errbuf'.\n *\n * \\param host: a pointer to a string identifying the host. It can be\n * a host name, a numeric literal address, or NULL or \"\" (useful\n * in case of a server socket which has to bind to all addresses).\n *\n * \\param port: a pointer to a user-allocated buffer containing the network port to use.\n *\n * \\param hints: an addrinfo variable (passed by reference) containing the flags needed to create the\n * addrinfo structure appropriately.\n *\n * \\param addrinfo: it represents the true returning value. This is a pointer to an addrinfo variable\n * (passed by reference), which will be allocated by this function and returned back to the caller.\n * This variable will be used in the next sockets calls.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return a pointer to the first element in a list of addrinfo structures\n * if everything is fine, NULL if some errors occurred. The error message\n * is returned in the 'errbuf' variable.\n *\n * \\warning The list of addrinfo structures returned has to be deleted by\n * the programmer by calling freeaddrinfo() when it is no longer needed.\n *\n * \\warning This function requires the 'hints' variable as parameter. The semantic of this variable is the same\n * of the one of the corresponding variable used into the standard getaddrinfo() socket function. We suggest\n * the programmer to look at that function in order to set the 'hints' variable appropriately.\n */\nstruct addrinfo *sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tint retval;\n\n\t/*\n\t * We allow both the host and port to be null, but getaddrinfo()\n\t * is not guaranteed to do so; to handle that, if port is null,\n\t * we provide \"0\" as the port number.\n\t *\n\t * This results in better error messages from get_gai_errstring(),\n\t * as those messages won't talk about a problem with the port if\n\t * no port was specified.\n\t */\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, &addrinfo);\n\tif (retval != 0)\n\t{\n\t\t/*\n\t\t * That call failed.\n\t\t * Determine whether the problem is that the host is bad.\n\t\t */\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Try with just a host, to distinguish\n\t\t\t\t * between \"host is bad\" and \"port is\n\t\t\t\t * bad\".\n\t\t\t\t */\n\t\t\t\tint try_retval;\n\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    &addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Worked with just the host,\n\t\t\t\t\t * so assume the problem is\n\t\t\t\t\t * with the port.\n\t\t\t\t\t *\n\t\t\t\t\t * Free up the address info first.\n\t\t\t\t\t */\n\t\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Didn't work with just the host,\n\t\t\t\t\t * so assume the problem is\n\t\t\t\t\t * with the host; we assume\n\t\t\t\t\t * the original error indicates\n\t\t\t\t\t * the underlying problem.\n\t\t\t\t\t */\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Either the host or port was null, so\n\t\t\t\t * there's nothing to determine; report\n\t\t\t\t * the error from the original call.\n\t\t\t\t */\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\t/*\n\t * \\warning SOCKET: I should check all the accept() in order to bind to all addresses in case\n\t * addrinfo has more han one pointers\n\t */\n\n\t/*\n\t * This software only supports PF_INET and PF_INET6.\n\t *\n\t * XXX - should we just check that at least *one* address is\n\t * either PF_INET or PF_INET6, and, when using the list,\n\t * ignore all addresses that are neither?  (What, no IPX\n\t * support? :-))\n\t */\n\tif ((addrinfo->ai_family != PF_INET) &&\n\t    (addrinfo->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(addrinfo);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * You can't do multicast (or broadcast) TCP.\n\t */\n\tif ((addrinfo->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr(addrinfo->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(addrinfo);\n\t\treturn NULL;\n\t}\n\n\treturn addrinfo;\n}\n\n/*\n * \\brief It sends the amount of data contained into 'buffer' on the given socket.\n *\n * This function basically calls the send() socket function and it checks that all\n * the data specified in 'buffer' (of size 'size') will be sent. If an error occurs,\n * it writes the error message into 'errbuf'.\n * In case the socket buffer does not have enough space, it loops until all data\n * has been sent.\n *\n * \\param socket: the connected socket currently opened.\n *\n * \\param buffer: a char pointer to a user-allocated buffer in which data is contained.\n *\n * \\param size: number of bytes that have to be sent.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return '0' if everything is fine, '-1' if an error other than\n * \"connection reset\" or \"peer has closed the receive side\" occurred,\n * '-2' if we got one of those errors.\n * For errors, an error message is returned in the 'errbuf' variable.\n */\nint sock_send(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, const char *buffer,\n    size_t size, char *errbuf, int errbuflen)\n{\n\tint remaining;\n\tssize_t nsent;\n\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"Can't send more than %u bytes with sock_send\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\tremaining = (int)size;\n\n\tdo {\n#ifdef HAVE_OPENSSL\n\t\tif (ssl) return ssl_send(ssl, buffer, remaining, errbuf, errbuflen);\n#endif\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\tnsent = remaining;\n#else\n#ifdef MSG_NOSIGNAL\n\t\t/*\n\t\t * Send with MSG_NOSIGNAL, so that we don't get SIGPIPE\n\t\t * on errors on stream-oriented sockets when the other\n\t\t * end breaks the connection.\n\t\t * The EPIPE error is still returned.\n\t\t */\n\t\tnsent = send(sock, buffer, remaining, MSG_NOSIGNAL);\n#else\n\t\tnsent = send(sock, buffer, remaining, 0);\n#endif\n#endif //FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\n\t\tif (nsent == -1)\n\t\t{\n\t\t\t/*\n\t\t\t * If the client closed the connection out from\n\t\t\t * under us, there's no need to log that as an\n\t\t\t * error.\n\t\t\t */\n\t\t\tint errcode;\n\n#ifdef _WIN32\n\t\t\terrcode = GetLastError();\n\t\t\tif (errcode == WSAECONNRESET ||\n\t\t\t    errcode == WSAECONNABORTED)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * WSAECONNABORTED appears to be the error\n\t\t\t\t * returned in Winsock when you try to send\n\t\t\t\t * on a connection where the peer has closed\n\t\t\t\t * the receive side.\n\t\t\t\t */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tsock_fmterrmsg(errbuf, errbuflen, errcode,\n\t\t\t    \"send() failed\");\n#else\n\t\t\terrcode = errno;\n\t\t\tif (errcode == ECONNRESET || errcode == EPIPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * EPIPE is what's returned on UN*X when\n\t\t\t\t * you try to send on a connection when\n\t\t\t\t * the peer has closed the receive side.\n\t\t\t\t */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tsock_fmterrmsg(errbuf, errbuflen, errcode,\n\t\t\t    \"send() failed\");\n#endif\n\t\t\treturn -1;\n\t\t}\n\n\t\tremaining -= nsent;\n\t\tbuffer += nsent;\n\t} while (remaining != 0);\n\n\treturn 0;\n}\n\n/*\n * \\brief It copies the amount of data contained in 'data' into 'outbuf'.\n * and it checks for buffer overflows.\n *\n * This function basically copies 'size' bytes of data contained in 'data'\n * into 'outbuf', starting at offset 'offset'. Before that, it checks that the\n * resulting buffer will not be larger\tthan 'totsize'. Finally, it updates\n * the 'offset' variable in order to point to the first empty location of the buffer.\n *\n * In case the function is called with 'checkonly' equal to 1, it does not copy\n * the data into the buffer. It only checks for buffer overflows and it updates the\n * 'offset' variable. This mode can be useful when the buffer already contains the\n * data (maybe because the producer writes directly into the target buffer), so\n * only the buffer overflow check has to be made.\n * In this case, both 'data' and 'outbuf' can be NULL values.\n *\n * This function is useful in case the userland application does not know immediately\n * all the data it has to write into the socket. This function provides a way to create\n * the \"stream\" step by step, appending the new data to the old one. Then, when all the\n * data has been bufferized, the application can call the sock_send() function.\n *\n * \\param data: a void pointer to the data that has to be copied.\n *\n * \\param size: number of bytes that have to be copied.\n *\n * \\param outbuf: user-allocated buffer (of size 'totsize') into which data\n * has to be copied.\n *\n * \\param offset: an index into 'outbuf' which keeps the location of its first\n * empty location.\n *\n * \\param totsize: total size of the buffer into which data is being copied.\n *\n * \\param checkonly: '1' if we do not want to copy data into the buffer and we\n * want just do a buffer overflow control, '0' if data has to be copied as well.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred. The error message\n * is returned in the 'errbuf' variable. When the function returns, 'outbuf' will\n * have the new string appended, and 'offset' will keep the length of that buffer.\n * In case of 'checkonly == 1', data is not copied, but 'offset' is updated in any case.\n *\n * \\warning This function assumes that the buffer in which data has to be stored is\n * large 'totbuf' bytes.\n *\n * \\warning In case of 'checkonly', be carefully to call this function *before* copying\n * the data into the buffer. Otherwise, the control about the buffer overflow is useless.\n */\nint sock_bufferize(const void *data, int size, char *outbuf, int *offset, int totsize, int checkonly, char *errbuf, int errbuflen)\n{\n\tif ((*offset + size) > totsize)\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"Not enough space in the temporary send buffer.\");\n\t\treturn -1;\n\t}\n\n\tif (!checkonly)\n\t\tmemcpy(outbuf + (*offset), data, size);\n\n\t(*offset) += size;\n\n\treturn 0;\n}\n\n/*\n * \\brief It waits on a connected socket and it manages to receive data.\n *\n * This function basically calls the recv() socket function and it checks that no\n * error occurred. If that happens, it writes the error message into 'errbuf'.\n *\n * This function changes its behavior according to the 'receiveall' flag: if we\n * want to receive exactly 'size' byte, it loops on the recv()\tuntil all the requested\n * data is arrived. Otherwise, it returns the data currently available.\n *\n * In case the socket does not have enough data available, it cycles on the recv()\n * until the requested data (of size 'size') is arrived.\n * In this case, it blocks until the number of bytes read is equal to 'size'.\n *\n * \\param sock: the connected socket currently opened.\n *\n * \\param buffer: a char pointer to a user-allocated buffer in which data has to be stored\n *\n * \\param size: size of the allocated buffer. WARNING: this indicates the number of bytes\n * that we are expecting to be read.\n *\n * \\param flags:\n *\n *   SOCK_RECEIVALL_XXX:\n *\n *\tif SOCK_RECEIVEALL_NO, return as soon as some data is ready\n *\tif SOCK_RECEIVALL_YES, wait until 'size' data has been\n *\t    received (in case the socket does not have enough data available).\n *\n *   SOCK_EOF_XXX:\n *\n *\tif SOCK_EOF_ISNT_ERROR, if the first read returns 0, just return 0,\n *\t    and return an error on any subsequent read that returns 0;\n *\tif SOCK_EOF_IS_ERROR, if any read returns 0, return an error.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return the number of bytes read if everything is fine, '-1' if some errors occurred.\n * The error message is returned in the 'errbuf' variable.\n */\n\nint sock_recv(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,\n    int flags, char *errbuf, int errbuflen)\n{\n\tint recv_flags = 0;\n\tchar *bufp = buffer;\n\tint remaining;\n\tssize_t nread;\n\n\tif (size == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"Can't read more than %u bytes with sock_recv\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (flags & SOCK_MSG_PEEK)\n\t\trecv_flags |= MSG_PEEK;\n\n\tbufp = (char *) buffer;\n\tremaining = (int) size;\n\n\t/*\n\t * We don't use MSG_WAITALL because it's not supported in\n\t * Win32.\n\t */\n\tfor (;;) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\tnread = fuzz_recv(bufp, remaining);\n#elif defined(HAVE_OPENSSL)\n\t\tif (ssl)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX - what about MSG_PEEK?\n\t\t\t */\n\t\t\tnread = ssl_recv(ssl, bufp, remaining, errbuf, errbuflen);\n\t\t\tif (nread == -2) return -1;\n\t\t}\n\t\telse\n\t\t\tnread = recv(sock, bufp, remaining, recv_flags);\n#else\n\t\tnread = recv(sock, bufp, remaining, recv_flags);\n#endif\n\n\t\tif (nread == -1)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == EINTR)\n\t\t\t\treturn -3;\n#endif\n\t\t\tsock_geterrmsg(errbuf, errbuflen, \"recv() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nread == 0)\n\t\t{\n\t\t\tif ((flags & SOCK_EOF_IS_ERROR) ||\n\t\t\t    (remaining != (int) size))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Either we've already read some data,\n\t\t\t\t * or we're always supposed to return\n\t\t\t\t * an error on EOF.\n\t\t\t\t */\n\t\t\t\tif (errbuf)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t\t\t    \"The other host terminated the connection.\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Do we want to read the amount requested, or just return\n\t\t * what we got?\n\t\t */\n\t\tif (!(flags & SOCK_RECEIVEALL_YES))\n\t\t{\n\t\t\t/*\n\t\t\t * Just return what we got.\n\t\t\t */\n\t\t\treturn (int) nread;\n\t\t}\n\n\t\tbufp += nread;\n\t\tremaining -= nread;\n\n\t\tif (remaining == 0)\n\t\t\treturn (int) size;\n\t}\n}\n\n/*\n * Receives a datagram from a socket.\n *\n * Returns the size of the datagram on success or -1 on error.\n */\nint sock_recv_dgram(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer,\n    size_t size, char *errbuf, int errbuflen)\n{\n\tssize_t nread;\n#ifndef _WIN32\n\tstruct msghdr message;\n\tstruct iovec iov;\n#endif\n\n\tif (size == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen,\n\t\t\t    \"Can't read more than %u bytes with sock_recv_dgram\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_OPENSSL\n\t// TODO: DTLS\n\tif (ssl)\n\t{\n\t\tsnprintf(errbuf, errbuflen, \"DTLS not implemented yet\");\n\t\treturn -1;\n\t}\n#endif\n\n\t/*\n\t * This should be a datagram socket, so we should get the\n\t * entire datagram in one recv() or recvmsg() call, and\n\t * don't need to loop.\n\t */\n#ifdef _WIN32\n\tnread = recv(sock, buffer, (int)size, 0);\n\tif (nread == SOCKET_ERROR)\n\t{\n\t\t/*\n\t\t * To quote the MSDN documentation for recv(),\n\t\t * \"If the datagram or message is larger than\n\t\t * the buffer specified, the buffer is filled\n\t\t * with the first part of the datagram, and recv\n\t\t * generates the error WSAEMSGSIZE. For unreliable\n\t\t * protocols (for example, UDP) the excess data is\n\t\t * lost...\"\n\t\t *\n\t\t * So if the message is bigger than the buffer\n\t\t * supplied to us, the excess data is discarded,\n\t\t * and we'll report an error.\n\t\t */\n\t\tsock_fmterrmsg(errbuf, errbuflen, sock_geterrcode(),\n\t\t    \"recv() failed\");\n\t\treturn -1;\n\t}\n#else /* _WIN32 */\n\t/*\n\t * The Single UNIX Specification says that a recv() on\n\t * a socket for a message-oriented protocol will discard\n\t * the excess data.  It does *not* indicate that the\n\t * receive will fail with, for example, EMSGSIZE.\n\t *\n\t * Therefore, we use recvmsg(), which appears to be\n\t * the only way to get a \"message truncated\" indication\n\t * when receiving a message for a message-oriented\n\t * protocol.\n\t */\n\tmessage.msg_name = NULL;\t/* we don't care who it's from */\n\tmessage.msg_namelen = 0;\n\tiov.iov_base = buffer;\n\tiov.iov_len = size;\n\tmessage.msg_iov = &iov;\n\tmessage.msg_iovlen = 1;\n#ifdef HAVE_STRUCT_MSGHDR_MSG_CONTROL\n\tmessage.msg_control = NULL;\t/* we don't care about control information */\n\tmessage.msg_controllen = 0;\n#endif\n#ifdef HAVE_STRUCT_MSGHDR_MSG_FLAGS\n\tmessage.msg_flags = 0;\n#endif\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\tnread = fuzz_recv(buffer, size);\n#else\n\tnread = recvmsg(sock, &message, 0);\n#endif\n\tif (nread == -1)\n\t{\n\t\tif (errno == EINTR)\n\t\t\treturn -3;\n\t\tsock_geterrmsg(errbuf, errbuflen, \"recv() failed\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_STRUCT_MSGHDR_MSG_FLAGS\n\t/*\n\t * XXX - Solaris supports this, but only if you ask for the\n\t * X/Open version of recvmsg(); should we use that, or will\n\t * that cause other problems?\n\t */\n\tif (message.msg_flags & MSG_TRUNC)\n\t{\n\t\t/*\n\t\t * Message was bigger than the specified buffer size.\n\t\t *\n\t\t * Report this as an error, as the Microsoft documentation\n\t\t * implies we'd do in a similar case on Windows.\n\t\t */\n\t\tsnprintf(errbuf, errbuflen, \"recv(): Message too long\");\n\t\treturn -1;\n\t}\n#endif /* HAVE_STRUCT_MSGHDR_MSG_FLAGS */\n#endif /* _WIN32 */\n\n\t/*\n\t * The size we're reading fits in an int, so the return value\n\t * will fit in an int.\n\t */\n\treturn (int)nread;\n}\n\n/*\n * \\brief It discards N bytes that are currently waiting to be read on the current socket.\n *\n * This function is useful in case we receive a message we cannot understand (e.g.\n * wrong version number when receiving a network packet), so that we have to discard all\n * data before reading a new message.\n *\n * This function will read 'size' bytes from the socket and discard them.\n * It defines an internal buffer in which data will be copied; however, in case\n * this buffer is not large enough, it will cycle in order to read everything as well.\n *\n * \\param sock: the connected socket currently opened.\n *\n * \\param size: number of bytes that have to be discarded.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return '0' if everything is fine, '-1' if some errors occurred.\n * The error message is returned in the 'errbuf' variable.\n */\nint sock_discard(PCAP_SOCKET sock, SSL *ssl, int size, char *errbuf,\n    int errbuflen)\n{\n#define TEMP_BUF_SIZE 32768\n\n\tchar buffer[TEMP_BUF_SIZE];\t\t/* network buffer, to be used when the message is discarded */\n\n\t/*\n\t * A static allocation avoids the need of a 'malloc()' each time we want to discard a message\n\t * Our feeling is that a buffer if 32KB is enough for most of the application;\n\t * in case this is not enough, the \"while\" loop discards the message by calling the\n\t * sockrecv() several times.\n\t * We do not want to create a bigger variable because this causes the program to exit on\n\t * some platforms (e.g. BSD)\n\t */\n\twhile (size > TEMP_BUF_SIZE)\n\t{\n\t\tif (sock_recv(sock, ssl, buffer, TEMP_BUF_SIZE, SOCK_RECEIVEALL_YES, errbuf, errbuflen) == -1)\n\t\t\treturn -1;\n\n\t\tsize -= TEMP_BUF_SIZE;\n\t}\n\n\t/*\n\t * If there is still data to be discarded\n\t * In this case, the data can fit into the temporary buffer\n\t */\n\tif (size)\n\t{\n\t\tif (sock_recv(sock, ssl, buffer, size, SOCK_RECEIVEALL_YES, errbuf, errbuflen) == -1)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * \\brief Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.\n *\n * This function is useful after an accept() call in order to check if the connecting\n * host is allowed to connect to me. To do that, we have a buffer that keeps the list of the\n * allowed host; this function checks the sockaddr_storage structure of the connecting host\n * against this host list, and it returns '0' is the host is included in this list.\n *\n * \\param hostlist: pointer to a string that contains the list of the allowed host.\n *\n * \\param sep: a string that keeps the separators used between the hosts (for example the\n * space character) in the host list.\n *\n * \\param from: a sockaddr_storage structure, as it is returned by the accept() call.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return It returns:\n * - '1' if the host list is empty\n * - '0' if the host belongs to the host list (and therefore it is allowed to connect)\n * - '-1' in case the host does not belong to the host list (and therefore it is not allowed to connect\n * - '-2' in case or error. The error message is returned in the 'errbuf' variable.\n */\nint sock_check_hostlist(const char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen)\n{\n\t/* checks if the connecting host is among the ones allowed */\n\tif ((hostlist) && (hostlist[0]))\n\t{\n\t\tchar *token;\t\t\t\t\t/* temp, needed to separate items into the hostlist */\n\t\tstruct addrinfo *addrinfo, *ai_next;\n\t\tchar *temphostlist;\n\t\tchar *lasts;\n\t\tint getaddrinfo_failed = 0;\n\n\t\t/*\n\t\t * The problem is that strtok modifies the original variable by putting '0' at the end of each token\n\t\t * So, we have to create a new temporary string in which the original content is kept\n\t\t */\n\t\ttemphostlist = strdup(hostlist);\n\t\tif (temphostlist == NULL)\n\t\t{\n\t\t\tsock_geterrmsg(errbuf, errbuflen,\n\t\t\t    \"sock_check_hostlist(), malloc() failed\");\n\t\t\treturn -2;\n\t\t}\n\n\t\ttoken = pcapint_strtok_r(temphostlist, sep, &lasts);\n\n\t\t/* it avoids a warning in the compilation ('addrinfo used but not initialized') */\n\t\taddrinfo = NULL;\n\n\t\twhile (token != NULL)\n\t\t{\n\t\t\tstruct addrinfo hints;\n\t\t\tint retval;\n\n\t\t\taddrinfo = NULL;\n\t\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t\thints.ai_family = PF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tretval = getaddrinfo(token, NULL, &hints, &addrinfo);\n\t\t\tif (retval != 0)\n\t\t\t{\n\t\t\t\tif (errbuf)\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"Allowed host list error: \",\n\t\t\t\t\t    retval, token, NULL);\n\n\t\t\t\t/*\n\t\t\t\t * Note that at least one call to getaddrinfo()\n\t\t\t\t * failed.\n\t\t\t\t */\n\t\t\t\tgetaddrinfo_failed = 1;\n\n\t\t\t\t/* Get next token */\n\t\t\t\ttoken = pcapint_strtok_r(NULL, sep, &lasts);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* ai_next is required to preserve the content of addrinfo, in order to deallocate it properly */\n\t\t\tai_next = addrinfo;\n\t\t\twhile (ai_next)\n\t\t\t{\n\t\t\t\tif (sock_cmpaddr(from, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t\t{\n\t\t\t\t\tfree(temphostlist);\n\t\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If we are here, it means that the current address does not matches\n\t\t\t\t * Let's try with the next one in the header chain\n\t\t\t\t */\n\t\t\t\tai_next = ai_next->ai_next;\n\t\t\t}\n\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\n\t\t\t/* Get next token */\n\t\t\ttoken = pcapint_strtok_r(NULL, sep, &lasts);\n\t\t}\n\n\t\tif (addrinfo)\n\t\t{\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\t\t}\n\n\t\tfree(temphostlist);\n\n\t\tif (getaddrinfo_failed) {\n\t\t\t/*\n\t\t\t * At least one getaddrinfo() call failed;\n\t\t\t * treat that as an error, so rpcapd knows\n\t\t\t * that it should log it locally as well\n\t\t\t * as telling the client about it.\n\t\t\t */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/*\n\t\t\t * All getaddrinfo() calls succeeded, but\n\t\t\t * the host wasn't in the list.\n\t\t\t */\n\t\t\tif (errbuf)\n\t\t\t\tsnprintf(errbuf, errbuflen, \"The host is not in the allowed host list. Connection refused.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* No hostlist, so we have to return 'empty list' */\n\treturn 1;\n}\n\n/*\n * \\brief Compares two addresses contained into two sockaddr_storage structures.\n *\n * This function is useful to compare two addresses, given their internal representation,\n * i.e. an sockaddr_storage structure.\n *\n * The two structures do not need to be sockaddr_storage; you can have both 'sockaddr_in' and\n * sockaddr_in6, properly casted in order to be compliant to the function interface.\n *\n * This function will return '0' if the two addresses matches, '-1' if not.\n *\n * \\param first: a sockaddr_storage structure, (for example the one that is returned by an\n * accept() call), containing the first address to compare.\n *\n * \\param second: a sockaddr_storage structure containing the second address to compare.\n *\n * \\return '0' if the addresses are equal, '-1' if they are different.\n */\nint sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second)\n{\n\tif (first->ss_family == second->ss_family)\n\t{\n\t\tif (first->ss_family == AF_INET)\n\t\t{\n\t\t\tif (memcmp(&(((struct sockaddr_in *) first)->sin_addr),\n\t\t\t\t&(((struct sockaddr_in *) second)->sin_addr),\n\t\t\t\tsizeof(struct in_addr)) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse /* address family is AF_INET6 */\n\t\t{\n\t\t\tif (memcmp(&(((struct sockaddr_in6 *) first)->sin6_addr),\n\t\t\t\t&(((struct sockaddr_in6 *) second)->sin6_addr),\n\t\t\t\tsizeof(struct in6_addr)) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/*\n * \\brief It gets the address/port the system picked for this socket (on connected sockets).\n *\n * It is used to return the address and port the server picked for our socket on the local machine.\n * It works only on:\n * - connected sockets\n * - server sockets\n *\n * On unconnected client sockets it does not work because the system dynamically chooses a port\n * only when the socket calls a send() call.\n *\n * \\param sock: the connected socket currently opened.\n *\n * \\param address: it contains the address that will be returned by the function. This buffer\n * must be properly allocated by the user. The address can be either literal or numeric depending\n * on the value of 'Flags'.\n *\n * \\param addrlen: the length of the 'address' buffer.\n *\n * \\param port: it contains the port that will be returned by the function. This buffer\n * must be properly allocated by the user.\n *\n * \\param portlen: the length of the 'port' buffer.\n *\n * \\param flags: a set of flags (the ones defined into the getnameinfo() standard socket function)\n * that determine if the resulting address must be in numeric / literal form, and so on.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return It returns '-1' if this function succeeds, '0' otherwise.\n * The address and port corresponding are returned back in the buffers 'address' and 'port'.\n * In any case, the returned strings are '0' terminated.\n *\n * \\warning If the socket is using a connectionless protocol, the address may not be available\n * until I/O occurs on the socket.\n */\nint sock_getmyinfo(PCAP_SOCKET sock, char *address, int addrlen, char *port,\n    int portlen, int flags, char *errbuf, int errbuflen)\n{\n\tstruct sockaddr_storage mysockaddr;\n\tsocklen_t sockaddrlen;\n\n\n\tsockaddrlen = sizeof(struct sockaddr_storage);\n\n\tif (getsockname(sock, (struct sockaddr *) &mysockaddr, &sockaddrlen) == -1)\n\t{\n\t\tsock_geterrmsg(errbuf, errbuflen, \"getsockname() failed\");\n\t\treturn 0;\n\t}\n\n\t/* Returns the numeric address of the host that triggered the error */\n\treturn sock_getascii_addrport(&mysockaddr, address, addrlen, port, portlen, flags, errbuf, errbuflen);\n}\n\n/*\n * \\brief It retrieves two strings containing the address and the port of a given 'sockaddr' variable.\n *\n * This function is basically an extended version of the inet_ntop(), which does not exist in\n * Winsock because the same result can be obtained by using the getnameinfo().\n * However, differently from inet_ntop(), this function is able to return also literal names\n * (e.g. 'localhost') dependently from the 'Flags' parameter.\n *\n * The function accepts a sockaddr_storage variable (which can be returned by several functions\n * like bind(), connect(), accept(), and more) and it transforms its content into a 'human'\n * form. So, for instance, it is able to translate an hex address (stored in binary form) into\n * a standard IPv6 address like \"::1\".\n *\n * The behavior of this function depends on the parameters we have in the 'Flags' variable, which\n * are the ones allowed in the standard getnameinfo() socket function.\n *\n * \\param sockaddr: a 'sockaddr_in' or 'sockaddr_in6' structure containing the address that\n * need to be translated from network form into the presentation form. This structure must be\n * zero-ed prior using it, and the address family field must be filled with the proper value.\n * The user must cast any 'sockaddr_in' or 'sockaddr_in6' structures to 'sockaddr_storage' before\n * calling this function.\n *\n * \\param address: it contains the address that will be returned by the function. This buffer\n * must be properly allocated by the user. The address can be either literal or numeric depending\n * on the value of 'Flags'.\n *\n * \\param addrlen: the length of the 'address' buffer.\n *\n * \\param port: it contains the port that will be returned by the function. This buffer\n * must be properly allocated by the user.\n *\n * \\param portlen: the length of the 'port' buffer.\n *\n * \\param flags: a set of flags (the ones defined into the getnameinfo() standard socket function)\n * that determine if the resulting address must be in numeric / literal form, and so on.\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return It returns '-1' if this function succeeds, '0' otherwise.\n * The address and port corresponding to the given SockAddr are returned back in the buffers 'address'\n * and 'port'.\n * In any case, the returned strings are '0' terminated.\n */\nint sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, size_t errbuflen)\n{\n\tsocklen_t sockaddrlen;\n\tint retval;\t\t\t\t\t/* Variable that keeps the return value; */\n\n\tretval = -1;\n\n#ifdef _WIN32\n\tif (sockaddr->ss_family == AF_INET)\n\t\tsockaddrlen = sizeof(struct sockaddr_in);\n\telse\n\t\tsockaddrlen = sizeof(struct sockaddr_in6);\n#else\n\tsockaddrlen = sizeof(struct sockaddr_storage);\n#endif\n\n\tif ((flags & NI_NUMERICHOST) == 0)\t/* Check that we want literal names */\n\t{\n\t\tif ((sockaddr->ss_family == AF_INET6) &&\n\t\t\t(memcmp(&((struct sockaddr_in6 *) sockaddr)->sin6_addr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(struct in6_addr)) == 0))\n\t\t{\n\t\t\tif (address)\n\t\t\t\tpcapint_strlcpy(address, SOCKET_NAME_NULL_DAD, addrlen);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (getnameinfo((struct sockaddr *) sockaddr, sockaddrlen, address, addrlen, port, portlen, flags) != 0)\n\t{\n\t\t/* If the user wants to receive an error message */\n\t\tif (errbuf)\n\t\t{\n\t\t\tsock_geterrmsg(errbuf, errbuflen,\n\t\t\t    \"getnameinfo() failed\");\n\t\t\terrbuf[errbuflen - 1] = 0;\n\t\t}\n\n\t\tif (address)\n\t\t{\n\t\t\tpcapint_strlcpy(address, SOCKET_NO_NAME_AVAILABLE, addrlen);\n\t\t\taddress[addrlen - 1] = 0;\n\t\t}\n\n\t\tif (port)\n\t\t{\n\t\t\tpcapint_strlcpy(port, SOCKET_NO_PORT_AVAILABLE, portlen);\n\t\t\tport[portlen - 1] = 0;\n\t\t}\n\n\t\tretval = 0;\n\t}\n\n\treturn retval;\n}\n\n/*\n * \\brief It translates an address from the 'presentation' form into the 'network' form.\n *\n * This function basically replaces inet_pton(), which does not exist in Winsock because\n * the same result can be obtained by using the getaddrinfo().\n * An additional advantage is that 'Address' can be both a numeric address (e.g. '127.0.0.1',\n * like in inet_pton() ) and a literal name (e.g. 'localhost').\n *\n * This function does the reverse job of sock_getascii_addrport().\n *\n * \\param address: a zero-terminated string which contains the name you have to\n * translate. The name can be either literal (e.g. 'localhost') or numeric (e.g. '::1').\n *\n * \\param sockaddr: a user-allocated sockaddr_storage structure which will contains the\n * 'network' form of the requested address.\n *\n * \\param addr_family: a constant which can assume the following values:\n * - 'AF_INET' if we want to ping an IPv4 host\n * - 'AF_INET6' if we want to ping an IPv6 host\n * - 'AF_UNSPEC' if we do not have preferences about the protocol used to ping the host\n *\n * \\param errbuf: a pointer to an user-allocated buffer that will contain the complete\n * error message. This buffer has to be at least 'errbuflen' in length.\n * It can be NULL; in this case the error cannot be printed.\n *\n * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n *\n * \\return '-1' if the translation succeeded, '-2' if there was some non critical error, '0'\n * otherwise. In case it fails, the content of the SockAddr variable remains unchanged.\n * A 'non critical error' can occur in case the 'Address' is a literal name, which can be mapped\n * to several network addresses (e.g. 'foo.bar.com' => '10.2.2.2' and '10.2.2.3'). In this case\n * the content of the SockAddr parameter will be the address corresponding to the first mapping.\n *\n * \\warning The sockaddr_storage structure MUST be allocated by the user.\n */\nint sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\n\tmemset(&hints, 0, sizeof(hints));\n\n\thints.ai_family = addr_family;\n\n\taddrinfo = sock_initaddress(address, \"22222\" /* fake port */, &hints,\n\t    errbuf, errbuflen);\n\tif (addrinfo == NULL)\n\t\treturn 0;\n\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}\n"
        },
        {
          "name": "sockutils.h",
          "type": "blob",
          "size": 5.8056640625,
          "content": "/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __SOCKUTILS_H__\n#define __SOCKUTILS_H__\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include <stdarg.h>\t/* we declare varargs functions */\n\n#include \"pcap/funcattrs.h\"\n\n#include \"pcap/socket.h\"\n\n#ifndef _WIN32\n  /* UN*X */\n  #include <unistd.h>\t/* close() */\n\n  /*!\n   * \\brief In Winsock, the close() call cannot be used on a socket;\n   * closesocket() must be used.\n   * We define closesocket() to be a wrapper around close() on UN*X,\n   * so that it can be used on both platforms.\n   */\n  #define closesocket(a) close(a)\n#endif\n\n#include \"sslutils.h\"  // for SSL type, whatever that turns out to be\n\n/*\n * MingW headers include this definition, but only for Windows XP and above.\n * MSDN states that this function is available for most versions on Windows.\n */\n#if ((defined(__MINGW32__)) && (_WIN32_WINNT < 0x0501))\nint WSAAPI getnameinfo(const struct sockaddr*,socklen_t,char*,DWORD,\n\tchar*,DWORD,int);\n#endif\n\n/*\n * \\defgroup SockUtils Cross-platform socket utilities (IPv4-IPv6)\n */\n\n/*\n * \\addtogroup SockUtils\n * \\{\n */\n\n/*\n * \\defgroup ExportedStruct Exported Structures and Definitions\n */\n\n/*\n * \\addtogroup ExportedStruct\n * \\{\n */\n\n/****************************************************\n *                                                  *\n * Exported functions / definitions                 *\n *                                                  *\n ****************************************************/\n\n/* 'checkonly' flag, into the rpsock_bufferize() */\n#define SOCKBUF_CHECKONLY 1\n/* no 'checkonly' flag, into the rpsock_bufferize() */\n#define SOCKBUF_BUFFERIZE 0\n\n/* no 'server' flag; it opens a client socket */\n#define SOCKOPEN_CLIENT 0\n/* 'server' flag; it opens a server socket */\n#define SOCKOPEN_SERVER 1\n\n/*\n * Flags for sock_recv().\n */\n#define SOCK_RECEIVEALL_NO\t0x00000000\t/* Don't wait to receive all data */\n#define SOCK_RECEIVEALL_YES\t0x00000001\t/* Wait to receive all data */\n\n#define SOCK_EOF_ISNT_ERROR\t0x00000000\t/* Return 0 on EOF */\n#define SOCK_EOF_IS_ERROR\t0x00000002\t/* Return an error on EOF */\n\n#define SOCK_MSG_PEEK\t\t0x00000004\t/* Return data but leave it in the socket queue */\n\n/*\n * \\}\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * \\defgroup ExportedFunc Exported Functions\n */\n\n/*\n * \\addtogroup ExportedFunc\n * \\{\n */\n\nint sock_init(char *errbuf, int errbuflen);\nvoid sock_cleanup(void);\nint sock_geterrcode(void);\nvoid sock_vfmterrmsg(char *errbuf, size_t errbuflen, int errcode,\n    PCAP_FORMAT_STRING(const char *fmt), va_list ap) PCAP_PRINTFLIKE(4, 0);\nvoid sock_fmterrmsg(char *errbuf, size_t errbuflen, int errcode,\n    PCAP_FORMAT_STRING(const char *fmt), ...) PCAP_PRINTFLIKE(4, 5);\nvoid sock_geterrmsg(char *errbuf, size_t errbuflen,\n    PCAP_FORMAT_STRING(const char *fmt), ...)  PCAP_PRINTFLIKE(3, 4);\nstruct addrinfo *sock_initaddress(const char *address, const char *port,\n    struct addrinfo *hints, char *errbuf, int errbuflen);\nint sock_recv(PCAP_SOCKET sock, SSL *, void *buffer, size_t size,\n    int receiveall, char *errbuf, int errbuflen);\nint sock_recv_dgram(PCAP_SOCKET sock, SSL *, void *buffer, size_t size,\n    char *errbuf, int errbuflen);\nPCAP_SOCKET sock_open(const char *host, struct addrinfo *addrinfo, int server,\n    int nconn, char *errbuf, int errbuflen);\nint sock_close(PCAP_SOCKET sock, char *errbuf, int errbuflen);\n\nint sock_send(PCAP_SOCKET sock, SSL *, const char *buffer, size_t size,\n    char *errbuf, int errbuflen);\nint sock_bufferize(const void *data, int size, char *outbuf, int *offset, int totsize, int checkonly, char *errbuf, int errbuflen);\nint sock_discard(PCAP_SOCKET sock, SSL *, int size, char *errbuf,\n    int errbuflen);\nint\tsock_check_hostlist(const char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen);\nint sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second);\n\nint sock_getmyinfo(PCAP_SOCKET sock, char *address, int addrlen, char *port,\n    int portlen, int flags, char *errbuf, int errbuflen);\n\nint sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, size_t errbuflen);\nint sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen);\n\n#ifdef __cplusplus\n}\n#endif\n\n/*\n * \\}\n */\n\n/*\n * \\}\n */\n\n#endif\n"
        },
        {
          "name": "sslutils.c",
          "type": "blob",
          "size": 6.361328125,
          "content": "/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <config.h>\n\n#ifdef HAVE_OPENSSL\n#include <stdlib.h>\n\n#include \"portability.h\"\n\n#include \"sslutils.h\"\n\nstatic const char *ssl_keyfile = \"\";   //!< file containing the private key in PEM format\nstatic const char *ssl_certfile = \"\";  //!< file containing the server's certificate in PEM format\nstatic const char *ssl_rootfile = \"\";  //!< file containing the list of CAs trusted by the client\n// TODO: a way to set ssl_rootfile from the command line, or an envvar?\n\n// TODO: lock?\nstatic SSL_CTX *ctx;\n\nvoid ssl_set_certfile(const char *certfile)\n{\n\tssl_certfile = certfile;\n}\n\nvoid ssl_set_keyfile(const char *keyfile)\n{\n\tssl_keyfile = keyfile;\n}\n\nint ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen)\n{\n\tstatic int inited = 0;\n\tif (inited) return 0;\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\tOpenSSL_add_ssl_algorithms();\n\tif (enable_compression)\n\t\tSSL_COMP_get_compression_methods();\n\n\tSSL_METHOD const *meth =\n\t    is_server ? SSLv23_server_method() : SSLv23_client_method();\n\tctx = SSL_CTX_new(meth);\n\tif (! ctx)\n\t{\n\t\tsnprintf(errbuf, errbuflen, \"Cannot get a new SSL context: %s\", ERR_error_string(ERR_get_error(), NULL));\n\t\tgoto die;\n\t}\n\n\tSSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n\tif (is_server)\n\t{\n\t\tchar const *certfile = ssl_certfile[0] ? ssl_certfile : \"cert.pem\";\n\t\tif (1 != SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen, \"Cannot read certificate file %s: %s\", certfile, ERR_error_string(ERR_get_error(), NULL));\n\t\t\tgoto die;\n\t\t}\n\n\t\tchar const *keyfile = ssl_keyfile[0] ? ssl_keyfile : \"key.pem\";\n\t\tif (1 != SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM))\n\t\t{\n\t\t\tsnprintf(errbuf, errbuflen, \"Cannot read private key file %s: %s\", keyfile, ERR_error_string(ERR_get_error(), NULL));\n\t\t\tgoto die;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (ssl_rootfile[0])\n\t\t{\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, ssl_rootfile, 0))\n\t\t\t{\n\t\t\t\tsnprintf(errbuf, errbuflen, \"Cannot read CA list from %s\", ssl_rootfile);\n\t\t\t\tgoto die;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\t}\n\n#if 0\n\tif (! RAND_load_file(RANDOM, 1024*1024))\n\t{\n\t\tsnprintf(errbuf, errbuflen, \"Cannot init random\");\n\t\tgoto die;\n\t}\n\n\tif (is_server)\n\t{\n\t\tSSL_CTX_set_session_id_context(ctx, (void *)&s_server_session_id_context, sizeof(s_server_session_id_context));\n\t}\n#endif\n\n\tinited = 1;\n\treturn 0;\n\ndie:\n\treturn -1;\n}\n\nSSL *ssl_promotion(int is_server, PCAP_SOCKET s, char *errbuf, size_t errbuflen)\n{\n\tif (ssl_init_once(is_server, 1, errbuf, errbuflen) < 0) {\n\t\treturn NULL;\n\t}\n\n\tSSL *ssl = SSL_new(ctx); // TODO: also a DTLS context\n\tSSL_set_fd(ssl, (int)s);\n\n\tif (is_server) {\n\t\tif (SSL_accept(ssl) <= 0) {\n\t\t\tsnprintf(errbuf, errbuflen, \"SSL_accept(): %s\",\n\t\t\t\t\tERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (SSL_connect(ssl) <= 0) {\n\t\t\tsnprintf(errbuf, errbuflen, \"SSL_connect(): %s\",\n\t\t\t\t\tERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ssl;\n}\n\n// Finish using an SSL handle; shut down the connection and free the\n// handle.\nvoid ssl_finish(SSL *ssl)\n{\n\t//\n\t// We won't be using this again, so we can just send the\n\t// shutdown alert and free up the handle, and have our\n\t// caller close the socket.\n\t//\n\t// XXX - presumably, if the connection is shut down on\n\t// our side, either our peer won't have a problem sending\n\t// their shutdown alert or will not treat such a problem\n\t// as an error.  If this causes errors to be reported,\n\t// fix that as appropriate.\n\t//\n\tSSL_shutdown(ssl);\n\tSSL_free(ssl);\n}\n\n// Same return value as sock_send:\n// 0 on OK, -1 on error but closed connection (-2).\nint ssl_send(SSL *ssl, char const *buffer, int size, char *errbuf, size_t errbuflen)\n{\n\tint status = SSL_write(ssl, buffer, size);\n\tif (status > 0)\n\t{\n\t\t// \"SSL_write() will only return with success, when the complete contents (...) has been written.\"\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint ssl_err = SSL_get_error(ssl, status); // TODO: does it pop the error?\n\t\tif (ssl_err == SSL_ERROR_ZERO_RETURN)\n\t\t{\n\t\t\treturn -2;\n\t\t}\n\t\telse if (ssl_err == SSL_ERROR_SYSCALL)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == ECONNRESET || errno == EPIPE) return -2;\n#endif\n\t\t}\n\t\tsnprintf(errbuf, errbuflen, \"SSL_write(): %s\",\n\t\t    ERR_error_string(ERR_get_error(), NULL));\n\t\treturn -1;\n\t}\n}\n\n// Returns the number of bytes read, or -1 on syserror, or -2 on SSL error.\nint ssl_recv(SSL *ssl, char *buffer, int size, char *errbuf, size_t errbuflen)\n{\n\tint status = SSL_read(ssl, buffer, size);\n\tif (status <= 0)\n\t{\n\t\tint ssl_err = SSL_get_error(ssl, status);\n\t\tif (ssl_err == SSL_ERROR_ZERO_RETURN)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telse if (ssl_err == SSL_ERROR_SYSCALL)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Should not happen\n\t\t\tsnprintf(errbuf, errbuflen, \"SSL_read(): %s\",\n\t\t\t    ERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn -2;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn status;\n\t}\n}\n\n#endif // HAVE_OPENSSL\n"
        },
        {
          "name": "sslutils.h",
          "type": "blob",
          "size": 2.66796875,
          "content": "/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __SSLUTILS_H__\n#define __SSLUTILS_H__\n\n#ifdef HAVE_OPENSSL\n#include \"pcap/socket.h\"  // for PCAP_SOCKET\n// If this is OpenSSL 1.0, at least one header may trigger a -Wdocumentation\n// in Clang, which should not be a problem of this header or a file that\n// includes it.\n#include \"diag-control.h\"\nDIAG_OFF_DOCUMENTATION\n#include <openssl/ssl.h>\n#include <openssl/err.h>\nDIAG_ON_DOCUMENTATION\n\n/*\n * Utility functions\n */\n\nvoid ssl_set_certfile(const char *certfile);\nvoid ssl_set_keyfile(const char *keyfile);\nint ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen);\nSSL *ssl_promotion(int is_server, PCAP_SOCKET s, char *errbuf, size_t errbuflen);\nvoid ssl_finish(SSL *ssl);\nint ssl_send(SSL *, char const *buffer, int size, char *errbuf, size_t errbuflen);\nint ssl_recv(SSL *, char *buffer, int size, char *errbuf, size_t errbuflen);\n\n// The SSL parameters are used\n#define _U_NOSSL_\n\n#else   // HAVE_OPENSSL\n\n// This saves us from a lot of ifdefs:\n#define SSL void const\n\n// The SSL parameters are unused\n#define _U_NOSSL_\t_U_\n\n#endif  // HAVE_OPENSSL\n\n#endif  // __SSLUTILS_H__\n"
        },
        {
          "name": "testprogs",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "thread-local.h",
          "type": "blob",
          "size": 2.9912109375,
          "content": "/*\n * Copyright (c) 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef thread_local_h\n#define\tthread_local_h\n\n/*\n * This defines thread_local to specify thread-local storage, if it\n * is not already defined.\n *\n * C11, if __STDC_NO_THREADS__ is not defined to be 1, defines\n * _Thread_local to indicate thread-local storage.  (You can also\n * include <threads.h> to so define it, but we don't use any of\n * the other stuff there.)\n *\n * Otherwise, we define it ourselves, based on the compiler.\n *\n * This is taken from https://stackoverflow.com/a/18298965/16139739.\n */\n#ifndef thread_local\n  #if __STDC_VERSION__ >= 201112 && !defined __STDC_NO_THREADS__\n    #define thread_local _Thread_local\n  #elif defined __TINYC__\n    #define thread_local\n    #warning \"Some libpcap calls will not be thread-safe.\"\n  #elif defined _WIN32 && ( \\\n         defined _MSC_VER || \\\n         defined __ICL || \\\n         defined __DMC__ || \\\n         defined __BORLANDC__ )\n    #define thread_local __declspec(thread)\n  /* note that ICC (linux) and Clang are covered by __GNUC__ */\n  #elif defined __GNUC__ || \\\n         defined __SUNPRO_C || \\\n         defined __xlC__ || \\\n         defined __HP_cc\n    #define thread_local __thread\n  #else\n    #error \"Cannot define thread_local\"\n  #endif\n#endif\n\n#endif\n"
        },
        {
          "name": "varattrs.h",
          "type": "blob",
          "size": 2.3837890625,
          "content": "/* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */\n/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the Computer Systems\n *\tEngineering Group at Lawrence Berkeley Laboratory.\n * 4. Neither the name of the University nor of the Laboratory may be used\n *    to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef varattrs_h\n#define varattrs_h\n\n#include <pcap/compiler-tests.h>\n\n/*\n * Attributes to apply to variables, using various compiler-specific\n * extensions.\n */\n\n#if __has_attribute(unused) \\\n    || PCAP_IS_AT_LEAST_GNUC_VERSION(2,0)\n  /*\n   * Compiler with support for __attribute__((unused)), or GCC 2.0 and\n   * later, so it supports __attribute__((unused)).\n   */\n  #define _U_ __attribute__((unused))\n#else\n  /*\n   * We don't know of any way to mark a variable as unused.\n   */\n  #define _U_\n#endif\n\n#endif\n"
        }
      ]
    }
  ]
}