{
  "metadata": {
    "timestamp": 1736709842102,
    "page": 312,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "stefanesser/dumpdecrypted",
      "stars": 2953,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.47265625,
          "content": "GCC_BIN=`xcrun --sdk iphoneos --find gcc`\nGCC_UNIVERSAL=$(GCC_BASE) -arch armv7 -arch armv7s -arch arm64\nSDK=`xcrun --sdk iphoneos --show-sdk-path`\n\nCFLAGS = \nGCC_BASE = $(GCC_BIN) -Os $(CFLAGS) -Wimplicit -isysroot $(SDK) -F$(SDK)/System/Library/Frameworks -F$(SDK)/System/Library/PrivateFrameworks\n\nall: dumpdecrypted.dylib\n\ndumpdecrypted.dylib: dumpdecrypted.o \n\t$(GCC_UNIVERSAL) -dynamiclib -o $@ $^\n\n%.o: %.c\n\t$(GCC_UNIVERSAL) -c -o $@ $< \n\nclean:\n\trm -f *.o dumpdecrypted.dylib\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 1.2646484375,
          "content": "Dumps decrypted iPhone Applications to a file - better solution than those GDB scripts for non working GDB versions\n(C) Copyright 2011-2014 Stefan Esser\n\n\nCompile:\n\nFirst adjust the Makefile if you have a different iOS SDK installed.\n\nAnd then just: make\n\n\nUsage:\n\niPod:~ root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Scan.app/Scan\nmach-o decryption dumper\n\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n\n[+] Found encrypted data at address 00002000 of length 1826816 bytes - type 1.\n[+] Opening /private/var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Scan.app/Scan for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a FAT image - searching for right architecture\n[+] Correct arch is at offset 2408224 in the file\n[+] Opening Scan.decrypted for writing.\n[-] Failed opening. Most probably a sandbox issue. Trying something different.\n[+] Opening /private/var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/tmp/Scan.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Closing original file\n[+] Closing dump file\n"
        },
        {
          "name": "dumpdecrypted.c",
          "type": "blob",
          "size": 7.8681640625,
          "content": "/*\n\nDumps decrypted iPhone Applications to a file - better solution than those GDB scripts for non working GDB versions\n(C) Copyright 2011-2014 Stefan Esser\n\niPod:~ root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Scan.app/Scan\nmach-o decryption dumper\n\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n\n[+] Found encrypted data at address 00002000 of length 1826816 bytes - type 1.\n[+] Opening /private/var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Scan.app/Scan for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a FAT image - searching for right architecture\n[+] Correct arch is at offset 2408224 in the file\n[+] Opening Scan.decrypted for writing.\n[-] Failed opening. Most probably a sandbox issue. Trying something different.\n[+] Opening /private/var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/tmp/Scan.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Closing original file\n[+] Closing dump file\n\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <mach-o/fat.h>\n#include <mach-o/loader.h>\n\nstruct ProgramVars {\n  struct mach_header*\tmh;\n  int*\t\tNXArgcPtr;\n  const char***\tNXArgvPtr;\n  const char***\tenvironPtr;\n  const char**\t__prognamePtr;\n};\n\n#define swap32(value) (((value & 0xFF000000) >> 24) | ((value & 0x00FF0000) >> 8) | ((value & 0x0000FF00) << 8) | ((value & 0x000000FF) << 24) )\n\n__attribute__((constructor))\nvoid dumptofile(int argc, const char **argv, const char **envp, const char **apple, struct ProgramVars *pvars)\n{\t\n\tstruct load_command *lc;\n\tstruct encryption_info_command *eic;\n\tstruct fat_header *fh;\n\tstruct fat_arch *arch;\n\tstruct mach_header *mh;\n\tchar buffer[1024];\n\tchar rpath[4096],npath[4096]; /* should be big enough for PATH_MAX */\n\tunsigned int fileoffs = 0, off_cryptid = 0, restsize;\n\tint i,fd,outfd,r,n,toread;\n\tchar *tmp;\n\t\n\tprintf(\"mach-o decryption dumper\\n\\n\");\n\t\t\n\tprintf(\"DISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\\n\\n\");\n\t\n\t/* detect if this is a arm64 binary */\n\tif (pvars->mh->magic == MH_MAGIC_64) {\n\t\tlc = (struct load_command *)((unsigned char *)pvars->mh + sizeof(struct mach_header_64));\n\t\tprintf(\"[+] detected 64bit ARM binary in memory.\\n\");\n\t} else { /* we might want to check for other errors here, too */\n\t\tlc = (struct load_command *)((unsigned char *)pvars->mh + sizeof(struct mach_header));\n\t\tprintf(\"[+] detected 32bit ARM binary in memory.\\n\");\n\t}\n\t\n\t/* searching all load commands for an LC_ENCRYPTION_INFO load command */\n\tfor (i=0; i<pvars->mh->ncmds; i++) {\n\t\t/*printf(\"Load Command (%d): %08x\\n\", i, lc->cmd);*/\n\t\t\n\t\tif (lc->cmd == LC_ENCRYPTION_INFO || lc->cmd == LC_ENCRYPTION_INFO_64) {\n\t\t\teic = (struct encryption_info_command *)lc;\n\t\t\t\n\t\t\t/* If this load command is present, but data is not crypted then exit */\n\t\t\tif (eic->cryptid == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff_cryptid=(off_t)((void*)&eic->cryptid - (void*)pvars->mh);\n\t\t\tprintf(\"[+] offset to cryptid found: @%p(from %p) = %x\\n\", &eic->cryptid, pvars->mh, off_cryptid);\n\n\t\t\tprintf(\"[+] Found encrypted data at address %08x of length %u bytes - type %u.\\n\", eic->cryptoff, eic->cryptsize, eic->cryptid);\n\t\t\t\n\t\t\tif (realpath(argv[0], rpath) == NULL) {\n\t\t\t\tstrlcpy(rpath, argv[0], sizeof(rpath));\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"[+] Opening %s for reading.\\n\", rpath);\n\t\t\tfd = open(rpath, O_RDONLY);\n\t\t\tif (fd == -1) {\n\t\t\t\tprintf(\"[-] Failed opening.\\n\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"[+] Reading header\\n\");\n\t\t\tn = read(fd, (void *)buffer, sizeof(buffer));\n\t\t\tif (n != sizeof(buffer)) {\n\t\t\t\tprintf(\"[W] Warning read only %d bytes\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"[+] Detecting header type\\n\");\n\t\t\tfh = (struct fat_header *)buffer;\n\t\t\t\n\t\t\t/* Is this a FAT file - we assume the right endianess */\n\t\t\tif (fh->magic == FAT_CIGAM) {\n\t\t\t\tprintf(\"[+] Executable is a FAT image - searching for right architecture\\n\");\n\t\t\t\tarch = (struct fat_arch *)&fh[1];\n\t\t\t\tfor (i=0; i<swap32(fh->nfat_arch); i++) {\n\t\t\t\t\tif ((pvars->mh->cputype == swap32(arch->cputype)) && (pvars->mh->cpusubtype == swap32(arch->cpusubtype))) {\n\t\t\t\t\t\tfileoffs = swap32(arch->offset);\n\t\t\t\t\t\tprintf(\"[+] Correct arch is at offset %u in the file\\n\", fileoffs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tarch++;\n\t\t\t\t}\n\t\t\t\tif (fileoffs == 0) {\n\t\t\t\t\tprintf(\"[-] Could not find correct arch in FAT image\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t} else if (fh->magic == MH_MAGIC || fh->magic == MH_MAGIC_64) {\n\t\t\t\tprintf(\"[+] Executable is a plain MACH-O image\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"[-] Executable is of unknown type\\n\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t/* extract basename */\n\t\t\ttmp = strrchr(rpath, '/');\n\t\t\tif (tmp == NULL) {\n\t\t\t\tprintf(\"[-] Unexpected error with filename.\\n\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tstrlcpy(npath, tmp+1, sizeof(npath));\n\t\t\tstrlcat(npath, \".decrypted\", sizeof(npath));\n\t\t\tstrlcpy(buffer, npath, sizeof(buffer));\n\n\t\t\tprintf(\"[+] Opening %s for writing.\\n\", npath);\n\t\t\toutfd = open(npath, O_RDWR|O_CREAT|O_TRUNC, 0644);\n\t\t\tif (outfd == -1) {\n\t\t\t\tif (strncmp(\"/private/var/mobile/Applications/\", rpath, 33) == 0) {\n\t\t\t\t\tprintf(\"[-] Failed opening. Most probably a sandbox issue. Trying something different.\\n\");\n\t\t\t\t\t\n\t\t\t\t\t/* create new name */\n\t\t\t\t\tstrlcpy(npath, \"/private/var/mobile/Applications/\", sizeof(npath));\n\t\t\t\t\ttmp = strchr(rpath+33, '/');\n\t\t\t\t\tif (tmp == NULL) {\n\t\t\t\t\t\tprintf(\"[-] Unexpected error with filename.\\n\");\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\ttmp++;\n\t\t\t\t\t*tmp++ = 0;\n\t\t\t\t\tstrlcat(npath, rpath+33, sizeof(npath));\n\t\t\t\t\tstrlcat(npath, \"tmp/\", sizeof(npath));\n\t\t\t\t\tstrlcat(npath, buffer, sizeof(npath));\n\t\t\t\t\tprintf(\"[+] Opening %s for writing.\\n\", npath);\n\t\t\t\t\toutfd = open(npath, O_RDWR|O_CREAT|O_TRUNC, 0644);\n\t\t\t\t}\n\t\t\t\tif (outfd == -1) {\n\t\t\t\t\tperror(\"[-] Failed opening\");\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* calculate address of beginning of crypted data */\n\t\t\tn = fileoffs + eic->cryptoff;\n\t\t\t\n\t\t\trestsize = lseek(fd, 0, SEEK_END) - n - eic->cryptsize;\t\t\t\n\t\t\tlseek(fd, 0, SEEK_SET);\n\t\t\t\n\t\t\tprintf(\"[+] Copying the not encrypted start of the file\\n\");\n\t\t\t/* first copy all the data before the encrypted data */\n\t\t\twhile (n > 0) {\n\t\t\t\ttoread = (n > sizeof(buffer)) ? sizeof(buffer) : n;\n\t\t\t\tr = read(fd, buffer, toread);\n\t\t\t\tif (r != toread) {\n\t\t\t\t\tprintf(\"[-] Error reading file\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\tn -= r;\n\t\t\t\t\n\t\t\t\tr = write(outfd, buffer, toread);\n\t\t\t\tif (r != toread) {\n\t\t\t\t\tprintf(\"[-] Error writing file\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* now write the previously encrypted data */\n\t\t\tprintf(\"[+] Dumping the decrypted data into the file\\n\");\n\t\t\tr = write(outfd, (unsigned char *)pvars->mh + eic->cryptoff, eic->cryptsize);\n\t\t\tif (r != eic->cryptsize) {\n\t\t\t\tprintf(\"[-] Error writing file\\n\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\t/* and finish with the remainder of the file */\n\t\t\tn = restsize;\n\t\t\tlseek(fd, eic->cryptsize, SEEK_CUR);\n\t\t\tprintf(\"[+] Copying the not encrypted remainder of the file\\n\");\n\t\t\twhile (n > 0) {\n\t\t\t\ttoread = (n > sizeof(buffer)) ? sizeof(buffer) : n;\n\t\t\t\tr = read(fd, buffer, toread);\n\t\t\t\tif (r != toread) {\n\t\t\t\t\tprintf(\"[-] Error reading file\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\tn -= r;\n\t\t\t\t\n\t\t\t\tr = write(outfd, buffer, toread);\n\t\t\t\tif (r != toread) {\n\t\t\t\t\tprintf(\"[-] Error writing file\\n\");\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (off_cryptid) {\n\t\t\t\tuint32_t zero=0;\n\t\t\t\toff_cryptid+=fileoffs;\n\t\t\t\tprintf(\"[+] Setting the LC_ENCRYPTION_INFO->cryptid to 0 at offset %x\\n\", off_cryptid);\n\t\t\t\tif (lseek(outfd, off_cryptid, SEEK_SET) != off_cryptid || write(outfd, &zero, 4) != 4) {\n\t\t\t\t\tprintf(\"[-] Error writing cryptid value\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"[+] Closing original file\\n\");\n\t\t\tclose(fd);\n\t\t\tprintf(\"[+] Closing dump file\\n\");\n\t\t\tclose(outfd);\n\t\t\t\n\t\t\t_exit(1);\n\t\t}\n\t\t\n\t\tlc = (struct load_command *)((unsigned char *)lc+lc->cmdsize);\t\t\n\t}\n\tprintf(\"[-] This mach-o file is not encrypted. Nothing was decrypted.\\n\");\n\t_exit(1);\n}\n"
        }
      ]
    }
  ]
}