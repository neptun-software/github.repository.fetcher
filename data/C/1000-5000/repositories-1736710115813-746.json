{
  "metadata": {
    "timestamp": 1736710115813,
    "page": 746,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lh3/minimap2",
      "stars": 1852,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.056640625,
          "content": ".cproject\n.project\n.*.swp\n*.a\n*.o\n*.dSYM\nminimap2\nmappy.c\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0830078125,
          "content": "[submodule \"lib/simde\"]\n\tpath = lib/simde\n\turl = https://github.com/nemequ/simde.git\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 1.9912109375,
          "content": "#### 1. Alignment different with option `-a` or `-c`?\n\nWithout `-a`, `-c` or `--cs`, minimap2 only finds *approximate* mapping\nlocations without detailed base alignment. In particular, the start and end\npositions of the alignment are imprecise. With one of those options, minimap2\nwill perform base alignment, which is generally more accurate but is much\nslower.\n\n#### 2. How to map Illumina short reads to noisy long reads?\n\nNo good solutions. The better approach is to assemble short reads into contigs\nand then map noisy reads to contigs.\n\n#### 3. The output SAM doesn't have a header.\n\nBy default, minimap2 indexes 4 billion reference bases (4Gb) in a batch and map\nall reads against each reference batch. Given a reference longer than 4Gb,\nminimap2 is unable to see all the sequences and thus can't produce a correct\nSAM header. In this case, minimap2 doesn't output any SAM header. There are two\nsolutions to this issue. First, you may increase option `-I` to, for example,\n`-I8g` to index more reference bases in a batch. This is preferred if your\nmachine has enough memory. Second, if your machines doesn't have enough memory\nto hold the reference index, you can use the `--split-prefix` option in a\ncommand line like:\n```sh\nminimap2 -ax map-ont --split-prefix=tmp ref.fa reads.fq\n```\nThis second approach uses less memory, but it is slower and requires temporary\ndisk space.\n\n#### 4. The output SAM is malformatted.\n\nThis typically happens when you use nohup to wrap a minimap2 command line.\nNohup is discouraged as it breaks piping. If you have to use nohup, please\nspecify an output file with option `-o`.\n\n#### 5. How to output one alignment per read?\n\nYou can use `--secondary=no` to suppress secondary alignments (aka multiple\nmappings), but you can't suppress supplementary alignment (aka split or\nchimeric alignment) this way. You can use samtools to filter out these\nalignments:\n```sh\nminimap2 -ax map-out ref.fa reads.fq | samtools view -F0x900\n```\nHowever, this is discouraged as supplementary alignment is informative.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.11328125,
          "content": "The MIT License\n\nCopyright (c) 2018-     Dana-Farber Cancer Institute\n              2017-2018 Broad Institute, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.2109375,
          "content": "include *.h\ninclude Makefile\ninclude ksw2_dispatch.c\ninclude main.c\ninclude README.md\ninclude sse2neon/emmintrin.h\ninclude python/cmappy.h\ninclude python/cmappy.pxd\ninclude python/mappy.pyx\ninclude python/README.rst\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.615234375,
          "content": "CFLAGS=\t\t-g -Wall -O2 -Wc++-compat #-Wextra\nCPPFLAGS=\t-DHAVE_KALLOC\nINCLUDES=\nOBJS=\t\tkthread.o kalloc.o misc.o bseq.o sketch.o sdust.o options.o index.o \\\n\t\t\tlchain.o align.o hit.o seed.o map.o format.o pe.o esterr.o splitidx.o \\\n\t\t\tksw2_ll_sse.o\nPROG=\t\tminimap2\nPROG_EXTRA=\tsdust minimap2-lite\nLIBS=\t\t-lm -lz -lpthread\n\nifneq ($(aarch64),)\n\tarm_neon=1\nendif\n\nifeq ($(arm_neon),) # if arm_neon is not defined\nifeq ($(sse2only),) # if sse2only is not defined\n\tOBJS+=ksw2_extz2_sse41.o ksw2_extd2_sse41.o ksw2_exts2_sse41.o ksw2_extz2_sse2.o ksw2_extd2_sse2.o ksw2_exts2_sse2.o ksw2_dispatch.o\nelse                # if sse2only is defined\n\tOBJS+=ksw2_extz2_sse.o ksw2_extd2_sse.o ksw2_exts2_sse.o\nendif\nelse\t\t\t\t# if arm_neon is defined\n\tOBJS+=ksw2_extz2_neon.o ksw2_extd2_neon.o ksw2_exts2_neon.o\n    INCLUDES+=-Isse2neon\nifeq ($(aarch64),)\t#if aarch64 is not defined\n\tCFLAGS+=-D_FILE_OFFSET_BITS=64 -mfpu=neon -fsigned-char\nelse\t\t\t\t#if aarch64 is defined\n\tCFLAGS+=-D_FILE_OFFSET_BITS=64 -fsigned-char\nendif\nendif\n\nifneq ($(asan),)\n\tCFLAGS+=-fsanitize=address\n\tLIBS+=-fsanitize=address -ldl\nendif\n\nifneq ($(tsan),)\n\tCFLAGS+=-fsanitize=thread\n\tLIBS+=-fsanitize=thread -ldl\nendif\n\n.PHONY:all extra clean depend\n.SUFFIXES:.c .o\n\n.c.o:\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $(INCLUDES) $< -o $@\n\nall:$(PROG)\n\nextra:all $(PROG_EXTRA)\n\nminimap2:main.o libminimap2.a\n\t\t$(CC) $(CFLAGS) main.o -o $@ -L. -lminimap2 $(LIBS)\n\nminimap2-lite:example.o libminimap2.a\n\t\t$(CC) $(CFLAGS) $< -o $@ -L. -lminimap2 $(LIBS)\n\nlibminimap2.a:$(OBJS)\n\t\t$(AR) -csru $@ $(OBJS)\n\nsdust:sdust.c kalloc.o kalloc.h kdq.h kvec.h kseq.h ketopt.h sdust.h\n\t\t$(CC) -D_SDUST_MAIN $(CFLAGS) $< kalloc.o -o $@ -lz\n\n# SSE-specific targets on x86/x86_64\n\nifeq ($(arm_neon),)   # if arm_neon is defined, compile this target with the default setting (i.e. no -msse2)\nksw2_ll_sse.o:ksw2_ll_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse2 $(CPPFLAGS) $(INCLUDES) $< -o $@\nendif\n\nksw2_extz2_sse41.o:ksw2_extz2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH $(INCLUDES) $< -o $@\n\nksw2_extz2_sse2.o:ksw2_extz2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse2 -mno-sse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH -DKSW_SSE2_ONLY $(INCLUDES) $< -o $@\n\nksw2_extd2_sse41.o:ksw2_extd2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH $(INCLUDES) $< -o $@\n\nksw2_extd2_sse2.o:ksw2_extd2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse2 -mno-sse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH -DKSW_SSE2_ONLY $(INCLUDES) $< -o $@\n\nksw2_exts2_sse41.o:ksw2_exts2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH $(INCLUDES) $< -o $@\n\nksw2_exts2_sse2.o:ksw2_exts2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse2 -mno-sse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH -DKSW_SSE2_ONLY $(INCLUDES) $< -o $@\n\nksw2_dispatch.o:ksw2_dispatch.c ksw2.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) -DKSW_CPU_DISPATCH $(INCLUDES) $< -o $@\n\n# NEON-specific targets on ARM\n\nksw2_extz2_neon.o:ksw2_extz2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) -DKSW_SSE2_ONLY -D__SSE2__ $(INCLUDES) $< -o $@\n\nksw2_extd2_neon.o:ksw2_extd2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) -DKSW_SSE2_ONLY -D__SSE2__ $(INCLUDES) $< -o $@\n\nksw2_exts2_neon.o:ksw2_exts2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) -DKSW_SSE2_ONLY -D__SSE2__ $(INCLUDES) $< -o $@\n\n# other non-file targets\n\nclean:\n\t\trm -fr gmon.out *.o a.out $(PROG) $(PROG_EXTRA) *~ *.a *.dSYM build dist mappy*.so mappy.c python/mappy.c mappy.egg*\n\ndepend:\n\t\t(LC_ALL=C; export LC_ALL; makedepend -Y -- $(CFLAGS) $(CPPFLAGS) -- *.c)\n\n# DO NOT DELETE\n\nalign.o: minimap.h mmpriv.h bseq.h kseq.h ksw2.h kalloc.h\nbseq.o: bseq.h kvec.h kalloc.h kseq.h\nesterr.o: mmpriv.h minimap.h bseq.h kseq.h\nexample.o: minimap.h kseq.h\nformat.o: kalloc.h mmpriv.h minimap.h bseq.h kseq.h\nhit.o: mmpriv.h minimap.h bseq.h kseq.h kalloc.h khash.h\nindex.o: kthread.h bseq.h minimap.h mmpriv.h kseq.h kvec.h kalloc.h khash.h\nindex.o: ksort.h\nkalloc.o: kalloc.h\nksw2_extd2_sse.o: ksw2.h kalloc.h\nksw2_exts2_sse.o: ksw2.h kalloc.h\nksw2_extz2_sse.o: ksw2.h kalloc.h\nksw2_ll_sse.o: ksw2.h kalloc.h\nkthread.o: kthread.h\nlchain.o: mmpriv.h minimap.h bseq.h kseq.h kalloc.h krmq.h\nmain.o: bseq.h minimap.h mmpriv.h kseq.h ketopt.h\nmap.o: kthread.h kvec.h kalloc.h sdust.h mmpriv.h minimap.h bseq.h kseq.h\nmap.o: khash.h ksort.h\nmisc.o: mmpriv.h minimap.h bseq.h kseq.h ksort.h\noptions.o: mmpriv.h minimap.h bseq.h kseq.h\npe.o: mmpriv.h minimap.h bseq.h kseq.h kvec.h kalloc.h ksort.h\nsdust.o: kalloc.h kdq.h kvec.h sdust.h\nseed.o: mmpriv.h minimap.h bseq.h kseq.h kalloc.h ksort.h\nsketch.o: kvec.h kalloc.h mmpriv.h minimap.h bseq.h kseq.h\nsplitidx.o: mmpriv.h minimap.h bseq.h kseq.h\n"
        },
        {
          "name": "Makefile.simde",
          "type": "blob",
          "size": 3.037109375,
          "content": "CFLAGS=\t\t-g -Wall -O2 -Wc++-compat #-Wextra\nCPPFLAGS=\t-DHAVE_KALLOC -DUSE_SIMDE -DSIMDE_ENABLE_NATIVE_ALIASES\nINCLUDES=\t-Ilib/simde\nOBJS=\t\tkthread.o kalloc.o misc.o bseq.o sketch.o sdust.o options.o index.o lchain.o align.o hit.o map.o format.o pe.o seed.o esterr.o splitidx.o \\\n\t\t\tksw2_extz2_simde.o ksw2_extd2_simde.o ksw2_exts2_simde.o ksw2_ll_simde.o\nPROG=\t\tminimap2\nPROG_EXTRA=\tsdust minimap2-lite\nLIBS=\t\t-lm -lz -lpthread\n\n\nifneq ($(arm_neon),) # if arm_neon is defined\nifeq ($(aarch64),)   #if aarch64 is not defined\n\tCFLAGS+=-D_FILE_OFFSET_BITS=64 -mfpu=neon -fsigned-char\nelse                 #if aarch64 is defined\n\tCFLAGS+=-D_FILE_OFFSET_BITS=64 -fsigned-char\nendif\nendif\n\nifneq ($(asan),)\n\tCFLAGS+=-fsanitize=address\n\tLIBS+=-fsanitize=address\nendif\n\nifneq ($(tsan),)\n\tCFLAGS+=-fsanitize=thread\n\tLIBS+=-fsanitize=thread\nendif\n\n.PHONY:all extra clean depend\n.SUFFIXES:.c .o\n\n.c.o:\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $(INCLUDES) $< -o $@\n\nall:$(PROG)\n\nextra:all $(PROG_EXTRA)\n\nminimap2:main.o libminimap2.a\n\t\t$(CC) $(CFLAGS) main.o -o $@ -L. -lminimap2 $(LIBS)\n\nminimap2-lite:example.o libminimap2.a\n\t\t$(CC) $(CFLAGS) $< -o $@ -L. -lminimap2 $(LIBS)\n\nlibminimap2.a:$(OBJS)\n\t\t$(AR) -csru $@ $(OBJS)\n\nsdust:sdust.c kalloc.o kalloc.h kdq.h kvec.h kseq.h ketopt.h sdust.h\n\t\t$(CC) -D_SDUST_MAIN $(CFLAGS) $< kalloc.o -o $@ -lz\n\nksw2_ll_simde.o:ksw2_ll_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse2 $(CPPFLAGS) $(INCLUDES) $< -o $@\n\nksw2_extz2_simde.o:ksw2_extz2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) $(INCLUDES) $< -o $@\n\nksw2_extd2_simde.o:ksw2_extd2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) $(INCLUDES) $< -o $@\n\nksw2_exts2_simde.o:ksw2_exts2_sse.c ksw2.h kalloc.h\n\t\t$(CC) -c $(CFLAGS) -msse4.1 $(CPPFLAGS) $(INCLUDES) $< -o $@\n\n# other non-file targets\n\nclean:\n\t\trm -fr gmon.out *.o a.out $(PROG) $(PROG_EXTRA) *~ *.a *.dSYM build dist mappy*.so mappy.c python/mappy.c mappy.egg*\n\ndepend:\n\t\t(LC_ALL=C; export LC_ALL; makedepend -Y -- $(CFLAGS) $(CPPFLAGS) -- *.c)\n\n# DO NOT DELETE\n\nalign.o: minimap.h mmpriv.h bseq.h kseq.h ksw2.h kalloc.h\nbseq.o: bseq.h kvec.h kalloc.h kseq.h\nchain.o: minimap.h mmpriv.h bseq.h kseq.h kalloc.h\nesterr.o: mmpriv.h minimap.h bseq.h kseq.h\nexample.o: minimap.h kseq.h\nformat.o: kalloc.h mmpriv.h minimap.h bseq.h kseq.h\nhit.o: mmpriv.h minimap.h bseq.h kseq.h kalloc.h khash.h\nindex.o: kthread.h bseq.h minimap.h mmpriv.h kseq.h kvec.h kalloc.h khash.h\nindex.o: ksort.h\nkalloc.o: kalloc.h\nksw2_extd2_sse.o: ksw2.h kalloc.h\nksw2_exts2_sse.o: ksw2.h kalloc.h\nksw2_extz2_sse.o: ksw2.h kalloc.h\nksw2_ll_sse.o: ksw2.h kalloc.h\nkthread.o: kthread.h\nmain.o: bseq.h minimap.h mmpriv.h kseq.h ketopt.h\nmap.o: kthread.h kvec.h kalloc.h sdust.h mmpriv.h minimap.h bseq.h kseq.h\nmap.o: khash.h ksort.h\nmisc.o: mmpriv.h minimap.h bseq.h kseq.h ksort.h\noptions.o: mmpriv.h minimap.h bseq.h kseq.h\npe.o: mmpriv.h minimap.h bseq.h kseq.h kvec.h kalloc.h ksort.h\nsdust.o: kalloc.h kdq.h kvec.h sdust.h\nself-chain.o: minimap.h kseq.h\nsketch.o: kvec.h kalloc.h mmpriv.h minimap.h bseq.h kseq.h\nsplitidx.o: mmpriv.h minimap.h bseq.h kseq.h\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 31.708984375,
          "content": "Release 2.28-r1209 (27 March 2024)\n----------------------------------\n\nNotable changes to minimap2:\n\n * Bugfix: `--MD` was not working properly due to the addition of `--ds` in the\n   last release (#1181 and #1182).\n\n * New feature: added an experimental preset `lq:hqae` for aligning accurate\n   long reads back to their assembly. It has been observed that `map-hifi` and\n   `lr:hq` may produce many wrong alignments around centromeres when accurate\n   long reads (PacBio HiFi or Nanopore duplex/Q20+) are mapped to a diploid\n   assembly constructed from them. This new preset produces much more accurate\n   alignment. It is still experimental and may be subjective to changes in\n   future.\n\n * Change: reduced the default `--cap-kalloc` to 500m to lower the peak\n   memory consumption (#855).\n\nNotable changes to mappy:\n\n * Bugfix: mappy option struct was out of sync with minimap2 (#1177).\n\nMinimap2 should output identical alignments to v2.27.\n\n(2.28: 27 March 2024, r1209)\n\n\n\nRelease 2.27-r1193 (12 March 2024)\n----------------------------------\n\nNotable changes to minimap2:\n\n * New feature: added the `lr:hq` preset for accurate long reads at ~1% error\n   rate. This was suggested by Oxford Nanopore developers (#1127). It is not\n   clear if this preset also works well for PacBio HiFi reads.\n\n * New feature: added the `map-iclr` preset for Illumina Complete Long Reads\n   (#1069), provided by Illumina developers.\n\n * New feature: added option `-b` to specify mismatch penalty for base\n   transitions (i.e. A-to-G or C-to-T changes).\n\n * New feature: added option `--ds` to generate a new `ds:Z` tag that\n   indicates uncertainty in INDEL positions. It is an extension to `cs`. The\n   `mgutils-es6.js` script in minigraph parses `ds`.\n\n * Bugfix: avoided a NULL pointer dereference (#1154). This would not have an\n   effect on most systems but would still be good to fix.\n\n * Bugfix: reverted the value of `ms:i` to pre-2.22 versions (#1146). This was\n   an oversight. See fcd4df2 for details.\n\nNotable changes to paftools.js and mappy:\n\n * New feature: expose `bw_long` to mappy's Aligner class (#1124).\n\n * Bugfix: fixed several compatibility issues with k8 v1.0 (#1161 and #1166).\n   Subcommands \"call\", \"pbsim2fq\" and \"mason2fq\" were not working with v1.0.\n\nMinimap2 should output identical alignments to v2.26, except the ms tag.\n\n(2.27: 12 March 2024, r1193)\n\n\n\nRelease 2.26-r1175 (29 April 2023)\n----------------------------------\n\nFixed the broken Python package. This is the only change.\n\n(2.26: 25 April 2023, r1173)\n\n\n\nRelease 2.25-r1173 (25 April 2023)\n----------------------------------\n\nNotable changes:\n\n * Improvement: use the miniprot splice model for RNA-seq alignment by default.\n   This model considers non-GT-AG splice sites and leads to slightly higher\n   (<0.1%) accuracy and sensitivity on real human data.\n\n * Change: increased the default `-I` to `8G` such that minimap2 would create a\n   uni-part index for a pair of mammalian genomes. This change may increase the\n   memory for all-vs-all read overlap alignment given large datasets.\n\n * New feature: output the sequences in secondary alignments with option\n   `--secondary-seq` (#687).\n\n * Bugfix: --rmq was not parsed correctly (#1010)\n\n * Bugfix: possibly incorrect coordinate when applying end bonus to the target\n   sequence (#1025). This is a ksw2 bug. It does not affect minimap2 as\n   minimap2 is not using the affected feature.\n\n * Improvement: incorporated several changes for better compatibility with\n   Windows (#1051) and for minimap2 integration at Oxford Nanopore Technologies\n   (#1048 and #1033).\n\n * Improvement: output the HD-line in SAM output (#1019).\n\n * Improvement: check minimap2 index file in mappy to prevent segmentation\n   fault for certain indices (#1008).\n\nFor genomic sequences, minimap2 should give identical output to v2.24.\nLong-read RNA-seq alignment may occasionally differ from previous versions.\n\n(2.25: 25 April 2023, r1173)\n\n\n\nRelease 2.24-r1122 (26 December 2021)\n-------------------------------------\n\nThis release improves alignment around long poorly aligned regions. Older\nminimap2 may chain through such regions in rare cases which may result in\nmissing alignments later. The issue has become worse since the the change of\nthe chaining algorithm in v2.19. v2.23 implements an incomplete remedy. This\nrelease provides a better solution with a X-drop-like heuristic and by enabling\ntwo-bandwidth chaining in the assembly mode.\n\n(2.24: 26 December 2021, r1122)\n\n\n\nRelease 2.23-r1111 (18 November 2021)\n-------------------------------------\n\nNotable changes:\n\n * Bugfix: fixed missing alignments around long inversions (#806 and #816).\n   This bug affected v2.19 through v2.22.\n\n * Improvement: avoid extremely long mapping time for pathologic reads with\n   highly repeated k-mers not in the reference (#771). Use --q-occ-frac=0\n   to disable the new heuristic.\n\n * Change: use --cap-kalloc=1g by default.\n\n(2.23: 18 November 2021, r1111)\n\n\n\nRelease 2.22-r1101 (7 August 2021)\n----------------------------------\n\nWhen choosing the best alignment, this release uses logarithm gap penalty and\nquery-specific mismatch penalty. It improves the sensitivity to long INDELs in\nrepetitive regions.\n\nOther notable changes:\n\n * Bugfix: fixed an indirect memory leak that may waste a large amount of\n   memory given highly repetitive reference such as a 16S RNA database (#749).\n   All versions of minimap2 have this issue.\n\n * New feature: added --cap-kalloc to reduce the peak memory. This option is\n   not enabled by default but may become the default in future releases.\n\nKnown issue:\n\n * Minimap2 may take a long time to map a read (#771). So far it is not clear\n   if this happens to v2.18 and earlier versions.\n\n(2.22: 7 August 2021, r1101)\n\n\n\nRelease 2.21-r1071 (6 July 2021)\n--------------------------------\n\nThis release fixed a regression in short-read mapping introduced in v2.19\n(#776). It also fixed invalid comparisons of uninitialized variables, though\nthese are harmless (#752). Long-read alignment should be identical to v2.20.\n\n(2.21: 6 July 2021, r1071)\n\n\n\nRelease 2.20-r1061 (27 May 2021)\n--------------------------------\n\nThis release fixed a bug in the Python module and improves the command-line\ncompatibiliity with v2.18. In v2.19, if `-r` is specified with an `asm*` preset,\nusers would get alignments more fragmented than v2.18. This could be an issue\nfor existing pipelines specifying `-r`. This release resolves this issue.\n\n(2.20: 27 May 2021, r1061)\n\n\n\nRelease 2.19-r1057 (26 May 2021)\n--------------------------------\n\nThis release includes a few important improvements backported from unimap:\n\n * Improvement: more contiguous alignment through long INDELs. This is enabled\n   by the minigraph chaining algorithm. All `asm*` presets now use the new\n   algorithm. They can find INDELs up to 100kb and may be faster for\n   chromosome-long contigs. The default mode and `map*` presets use this\n   algorithm to replace the long-join heuristic.\n\n * Improvement: better alignment in highly repetitive regions by rescuing\n   high-occurrence seeds. If the distance between two adjacent seeds is too\n   large, attempt to choose a fraction of high-occurrence seeds in-between.\n   Minimap2 now produces fewer clippings and alignment break points in long\n   satellite regions.\n\n * Improvement: allow to specify an interval of k-mer occurrences with `-U`.\n   For repeat-rich genomes, the automatic k-mer occurrence threshold determined\n   by `-f` may be too large and makes alignment impractically slow. The new\n   option protects against such cases. Enabled for `asm*` and `map-hifi`.\n\n * New feature: added the `map-hifi` preset for maping PacBio High-Fidelity\n   (HiFi) reads.\n\n * Change to the default: apply `--cap-sw-mem=100m` for genomic alignment.\n\n * Bugfix: minimap2 could not generate an index file with `-xsr` (#734).\n\nThis release represents the most signficant algorithmic change since v2.1 in\n2017. With features backported from unimap, minimap2 now has similar power to\nunimap for contig alignment. Unimap will remain an experimental project and is\nno longer recommended over minimap2. Sorry for reverting the recommendation in\nshort time.\n\n(2.19: 26 May 2021, r1057)\n\n\n\nRelease 2.18-r1015 (9 April 2021)\n---------------------------------\n\nThis release fixes multiple rare bugs in minimap2 and adds additional\nfunctionality to paftools.js.\n\nChanges to minimap2:\n\n * Bugfix: a rare segfault caused by an off-by-one error (#489)\n\n * Bugfix: minimap2 segfaulted due to an uninitilized variable (#622 and #625).\n\n * Bugfix: minimap2 parsed spaces as field separators in BED (#721). This led\n   to issues when the BED name column contains spaces.\n\n * Bugfix: minimap2 `--split-prefix` did not work with long reference names\n   (#394).\n\n * Bugfix: option `--junc-bonus` didn't work (#513)\n\n * Bugfix: minimap2 didn't return 1 on I/O errors (#532)\n\n * Bugfix: the `de:f` tag (sequence divergence) could be negative if there were\n   ambiguous bases\n\n * Bugfix: fixed two undefined behaviors caused by calling memcpy() on\n   zero-length blocks (#443)\n\n * Bugfix: there were duplicated SAM @SQ lines if option `--split-prefix` is in\n   use (#400 and #527)\n\n * Bugfix: option -K had to be smaller than 2 billion (#491). This was caused\n   by a 32-bit integer overflow.\n\n * Improvement: optionally compile against SIMDe (#597). Minimap2 should work\n   with IBM POWER CPUs, though this has not been tested. To compile with SIMDe,\n   please use `make -f Makefile.simde`.\n\n * Improvement: more informative error message for I/O errors (#454) and for\n   FASTQ parsing errors (#510)\n\n * Improvement: abort given malformatted RG line (#541)\n\n * Improvement: better formula to estimate the `dv:f` tag (approximate sequence\n   divergence). See DOI:10.1101/2021.01.15.426881.\n\n * New feature: added the `--mask-len` option to fine control the removal of\n   redundant hits (#659). The default behavior is unchanged.\n\nChanges to mappy:\n\n * Bugfix: mappy caused segmentation fault if the reference index is not\n   present (#413).\n\n * Bugfix: fixed a memory leak via 238b6bb3\n\n * Change: always require Cython to compile the mappy module (#723). Older\n   mappy packages at PyPI bundled the C source code generated by Cython such\n   that end users did not need to install Cython to compile mappy. However, as\n   Python 3.9 is breaking backward compatibility, older mappy does not work\n   with Python 3.9 anymore. We have to add this Cython dependency as a\n   workaround.\n\nChanges to paftools.js:\n\n * Bugfix: the \"part10-\" line from asmgene was wrong (#581)\n\n * Improvement: compatibility with GTF files from GenBank (#422)\n\n * New feature: asmgene also checks missing multi-copy genes\n\n * New feature: added the misjoin command to evaluate large-scale misjoins and\n   megabase-long inversions.\n\nAlthough given the many bug fixes and minor improvements, the core algorithm\nstays the same. This version of minimap2 produces nearly identical alignments\nto v2.17 except very rare corner cases.\n\nNow unimap is recommended over minimap2 for aligning long contigs against a\nreference genome. It often takes less wall-clock time and is much more\nsensitive to long insertions and deletions.\n\n(2.18: 9 April 2021, r1015)\n\n\n\nRelease 2.17-r941 (4 May 2019)\n------------------------------\n\nChanges since the last release:\n\n * Fixed flawed CIGARs like `5I6D7I` (#392).\n\n * Bugfix: TLEN should be 0 when either end is unmapped (#373 and #365).\n\n * Bugfix: mappy is unable to write index (#372).\n\n * Added option `--junc-bed` to load known gene annotations in the BED12\n   format. Minimap2 prefers annotated junctions over novel junctions (#197 and\n   #348). GTF can be converted to BED12 with `paftools.js gff2bed`.\n\n * Added option `--sam-hit-only` to suppress unmapped hits in SAM (#377).\n\n * Added preset `splice:hq` for high-quality CCS or mRNA sequences. It applies\n   better scoring and improves the sensitivity to small exons. This preset may\n   introduce false small introns, but the overall accuracy should be higher.\n\nThis version produces nearly identical alignments to v2.16, except for CIGARs\naffected by the bug mentioned above.\n\n(2.17: 5 May 2019, r941)\n\n\n\nRelease 2.16-r922 (28 February 2019)\n------------------------------------\n\nThis release is 50% faster for mapping ultra-long nanopore reads at comparable\naccuracy. For short-read mapping, long-read overlapping and ordinary long-read\nmapping, the performance and accuracy remain similar. This speedup is achieved\nwith a new heuristic to limit the number of chaining iterations (#324). Users\ncan disable the heuristic by increasing a new option `--max-chain-iter` to a\nhuge number.\n\nOther changes to minimap2:\n\n * Implemented option `--paf-no-hit` to output unmapped query sequences in PAF.\n   The strand and reference name columns are both `*` at an unmapped line. The\n   hidden option is available in earlier minimap2 but had a different 2-column\n   output format instead of PAF.\n\n * Fixed a bug that leads to wrongly calculated `de` tags when ambiguous bases\n   are involved (#309). This bug only affects v2.15.\n\n * Fixed a bug when parsing command-line option `--splice` (#344). This bug was\n   introduced in v2.13.\n\n * Fixed two division-by-zero cases (#326). They don't affect final alignments\n   because the results of the divisions are not used in both case.\n\n * Added an option `-o` to output alignments to a specified file. It is still\n   recommended to use UNIX pipes for on-the-fly conversion or compression.\n\n * Output a new `rl` tag to give the length of query regions harboring\n   repetitive seeds.\n\nChanges to paftool.js:\n\n * Added a new option to convert the MD tag to the long form of the cs tag.\n\nChanges to mappy:\n\n * Added the `mappy.Aligner.seq_names` method to return sequence names (#312).\n\nFor NA12878 ultra-long reads, this release changes the alignments of <0.1% of\nreads in comparison to v2.15. All these reads have highly fragmented alignments\nand are likely to be problematic anyway. For shorter or well aligned reads,\nthis release should produce mostly identical alignments to v2.15.\n\n(2.16: 28 February 2019, r922)\n\n\n\nRelease 2.15-r905 (10 January 2019)\n-----------------------------------\n\nChanges to minimap2:\n\n * Fixed a rare segmentation fault when option -H is in use (#307). This may\n   happen when there are very long homopolymers towards the 5'-end of a read.\n\n * Fixed wrong CIGARs when option --eqx is used (#266).\n\n * Fixed a typo in the base encoding table (#264). This should have no\n   practical effect.\n\n * Fixed a typo in the example code (#265).\n\n * Improved the C++ compatibility by removing \"register\" (#261). However,\n   minimap2 still can't be compiled in the pedantic C++ mode (#306).\n\n * Output a new \"de\" tag for gap-compressed sequence divergence.\n\nChanges to paftools.js:\n\n * Added \"asmgene\" to evaluate the completeness of an assembly by measuring the\n   uniquely mapped single-copy genes. This command learns the idea of BUSCO.\n\n * Added \"vcfpair\" to call a phased VCF from phased whole-genome assemblies. An\n   earlier version of this script is used to produce the ground truth for the\n   syndip benchmark [PMID:30013044].\n\nThis release produces identical alignment coordinates and CIGARs in comparison\nto v2.14. Users are advised to upgrade due to the several bug fixes.\n\n(2.15: 10 Janurary 2019, r905)\n\n\n\nRelease 2.14-r883 (5 November 2018)\n-----------------------------------\n\nNotable changes:\n\n * Fixed two minor bugs caused by typos (#254 and #266).\n\n * Fixed a bug that made minimap2 abort when --eqx was used together with --MD\n   or --cs (#257).\n\n * Added --cap-sw-mem to cap the size of DP matrices (#259). Base alignment may\n   take a lot of memory in the splicing mode. This may lead to issues when we\n   run minimap2 on a cluster with a hard memory limit. The new option avoids\n   unlimited memory usage at the cost of missing a few long introns.\n\n * Conforming to C99 and C11 when possible (#261).\n\n * Warn about malformatted FASTA or FASTQ (#252 and #255).\n\nThis release occasionally produces base alignments different from v2.13. The\noverall alignment accuracy remain similar.\n\n(2.14: 5 November 2018, r883)\n\n\n\nRelease 2.13-r850 (11 October 2018)\n-----------------------------------\n\nChanges to minimap2:\n\n * Fixed wrongly formatted SAM when -L is in use (#231 and #233).\n\n * Fixed an integer overflow in rare cases.\n\n * Added --hard-mask-level to fine control split alignments (#244).\n\n * Made --MD work with spliced alignment (#139).\n\n * Replaced musl's getopt with ketopt for portability.\n\n * Log peak memory usage on exit.\n\nThis release should produce alignments identical to v2.12 and v2.11.\n\n(2.13: 11 October 2018, r850)\n\n\n\nRelease 2.12-r827 (6 August 2018)\n---------------------------------\n\nChanges to minimap2:\n\n * Added option --split-prefix to write proper alignments (correct mapping\n   quality and clustered query sequences) given a multi-part index (#141 and\n   #189; mostly by @hasindu2008).\n\n * Fixed a memory leak when option -y is in use.\n\nChanges to mappy:\n\n * Support the MD/cs tag (#183 and #203).\n\n * Allow mappy to index a single sequence, to add extra flags and to change the\n   scoring system.\n\nMinimap2 should produce alignments identical to v2.11.\n\n(2.12: 6 August 2018, r827)\n\n\n\nRelease 2.11-r797 (20 June 2018)\n--------------------------------\n\nChanges to minimap2:\n\n * Improved alignment accuracy in low-complexity regions for SV calling. Thank\n   @armintoepfer for multiple offline examples.\n\n * Added option --eqx to encode sequence match/mismatch with the =/X CIGAR\n   operators (#156, #157 and #175).\n\n * When compiled with VC++, minimap2 generated wrong alignments due to a\n   comparison between a signed integer and an unsigned integer (#184). Also\n   fixed warnings reported by \"clang -Wextra\".\n\n * Fixed incorrect anchor filtering due to a missing 64- to 32-bit cast.\n\n * Fixed incorrect mapping quality for inversions (#148).\n\n * Fixed incorrect alignment involving ambiguous bases (#155).\n\n * Fixed incorrect presets: option `-r 2000` is intended to be used with\n   ava-ont, not ava-pb. The bug was introduced in 2.10.\n\n * Fixed a bug when --for-only/--rev-only is used together with --sr or\n   --heap-sort=yes (#166).\n\n * Fixed option -Y that was not working in the previous releases.\n\n * Added option --lj-min-ratio to fine control the alignment of long gaps\n   found by the \"long-join\" heuristic (#128).\n\n * Exposed `mm_idx_is_idx`, `mm_idx_load` and `mm_idx_dump` C APIs (#177).\n   Also fixed a bug when indexing without reference names (this feature is not\n   exposed to the command line).\n\nChanges to mappy:\n\n * Added `__version__` (#165).\n\n * Exposed the maximum fragment length parameter to mappy (#174).\n\nChanges to paftools:\n\n * Don't crash when there is no \"cg\" tag (#153).\n\n * Fixed wrong coverage report by \"paftools.js call\" (#145).\n\nThis version may produce slightly different base-level alignment. The overall\nalignment statistics should remain similar.\n\n(2.11: 20 June 2018, r797)\n\n\n\nRelease 2.10-r761 (27 March 2018)\n---------------------------------\n\nChanges to minimap2:\n\n * Optionally output the MD tag for compatibility with existing tools (#63,\n   #118 and #137).\n\n * Use SSE compiler flags more precisely to prevent compiling errors on certain\n   machines (#127).\n\n * Added option --min-occ-floor to set a minimum occurrence threshold. Presets\n   intended for assembly-to-reference alignment set this option to 100. This\n   option alleviates issues with regions having high copy numbers (#107).\n\n * Exit with non-zero code on file writing errors (e.g. disk full; #103 and\n   #132).\n\n * Added option -y to copy FASTA/FASTQ comments in query sequences to the\n   output (#136).\n\n * Added the asm20 preset for alignments between genomes at 5-10% sequence\n   divergence.\n\n * Changed the band-width in the ava-ont preset from 500 to 2000. Oxford\n   Nanopore reads may contain long deletion sequencing errors that break\n   chaining.\n\nChanges to mappy, the Python binding:\n\n * Fixed a typo in Align.seq() (#126).\n\nChanges to paftools.js, the companion script:\n\n * Command sam2paf now converts the MD tag to cs.\n\n * Support VCF output for assembly-to-reference variant calling (#109).\n\nThis version should produce identical alignment for read overlapping, RNA-seq\nread mapping, and genomic read mapping. We have also added a cook book to show\nthe variety uses of minimap2 on real datasets. Please see cookbook.md in the\nminimap2 source code directory.\n\n(2.10: 27 March 2017, r761)\n\n\n\nRelease 2.9-r720 (23 February 2018)\n-----------------------------------\n\nThis release fixed multiple minor bugs.\n\n* Fixed two bugs that lead to incorrect inversion alignment. Also improved the\n  sensitivity to small inversions by using double Z-drop cutoff (#112).\n\n* Fixed an issue that may cause the end of a query sequence unmapped (#104).\n\n* Added a mappy API to retrieve sequences from the index (#126) and to reverse\n  complement DNA sequences. Fixed a bug where the `best_n` parameter did not\n  work (#117).\n\n* Avoided segmentation fault given incorrect FASTQ input (#111).\n\n* Combined all auxiliary javascripts to paftools.js. Fixed several bugs in\n  these scripts at the same time.\n\n(2.9: 24 February 2018, r720)\n\n\n\nRelease 2.8-r672 (1 February 2018)\n----------------------------------\n\nNotable changes in this release include:\n\n * Speed up short-read alignment by ~10%. The overall mapping accuracy stays\n   the same, but the output alignments are not always identical to v2.7 due to\n   unstable sorting employed during chaining. Long-read alignment is not\n   affected by this change as the speedup is short-read specific.\n\n * Mappy now supports paired-end short-read alignment (#87). Please see\n   python/README.rst for details.\n\n * Added option --for-only and --rev-only to perform alignment against the\n   forward or the reverse strand of the reference genome only (#91).\n\n * Alleviated the issue with undesired diagonal alignment in the self mapping\n   mode (#10). Even if the output is not ideal, it should not interfere with\n   other alignments. Fully resolving the issue is intricate and may require\n   additional heuristic thresholds.\n\n * Enhanced error checking against incorrect input (#92 and #96).\n\nFor long query sequences, minimap2 should output identical alignments to v2.7.\n\n(2.8: 1 February 2018, r672)\n\n\n\nRelease 2.7-r654 (9 January 2018)\n---------------------------------\n\nThis release fixed a bug in the splice mode and added a few minor features:\n\n * Fixed a bug that occasionally takes an intron as a long deletion in the\n   splice mode. This was caused by wrong backtracking at the last CIGAR\n   operator. The current fix eliminates the error, but it is not optimal in\n   that it often produces a wrong junction when the last operator is an intron.\n   A future version of minimap2 may improve upon this.\n\n * Support high-end ARM CPUs that implement the NEON instruction set (#81).\n   This enables minimap2 to work on Raspberry Pi 3 and Odroid XU4.\n\n * Added a C API to construct a minimizer index from a set of C strings (#80).\n\n * Check scoring specified on the command line (#79). Due to the 8-bit limit,\n   excessively large score penalties fail minimap2.\n\nFor genomic sequences, minimap2 should give identical alignments to v2.6.\n\n(2.7: 9 January 2018, r654)\n\n\n\nRelease 2.6-r623 (12 December 2017)\n-----------------------------------\n\nThis release adds several features and fixes two minor bugs:\n\n * Optionally build an index without sequences. This helps to reduce the\n   peak memory for read overlapping and is automatically applied when\n   base-level alignment is not requested.\n\n * Approximately estimate per-base sequence divergence (i.e. 1-identity)\n   without performing base-level alignment, using a MashMap-like method. The\n   estimate is written to a new dv:f tag.\n\n * Reduced the number of tiny terminal exons in RNA-seq alignment. The current\n   setting is conservative. Increase --end-seed-pen to drop more such exons.\n\n * Reduced the peak memory when aligning long query sequences.\n\n * Fixed a bug that is caused by HPC minimizers longer than 256bp. This should\n   have no effect in practice, but it is recommended to rebuild HPC indices if\n   possible.\n\n * Fixed a bug when identifying identical hits (#71). This should only affect\n   artifactual reference consisting of near identical sequences.\n\nFor genomic sequences, minimap2 should give nearly identical alignments to\nv2.5, except the new dv:f tag.\n\n(2.6: 12 December 2017, r623)\n\n\n\nRelease 2.5-r572 (11 November 2017)\n-----------------------------------\n\nThis release fixes several bugs and brings a couple of minor improvements:\n\n * Fixed a severe bug that leads to incorrect mapping coordinates in rare\n   corner cases.\n\n * Fixed underestimated mapping quality for chimeric alignments when the whole\n   query sequence contain many repetitive minimizers, and for chimeric\n   alignments caused by Z-drop.\n\n * Fixed two bugs in Python binding: incorrect strand field (#57) and incorrect\n   sequence names for Python3 (#55).\n\n * Improved mapping accuracy for highly overlapping paired ends.\n\n * Added option -Y to use soft clipping for supplementary alignments (#56).\n\n(2.5: 11 November 2017, r572)\n\n\n\nRelease 2.4-r555 (6 November 2017)\n----------------------------------\n\nAs is planned, this release focuses on fine tuning the base algorithm. Notable\nchanges include\n\n * Changed the mapping quality scale to match the scale of BWA-MEM. This makes\n   minimap2 and BWA-MEM achieve similar sensitivity-specificity balance on real\n   short-read data.\n\n * Improved the accuracy of splice alignment by modeling one additional base\n   close to the GT-AG signal. This model is used by default with `-x splice`.\n   For SIRV control data, however, it is recommended to add `--splice-flank=no`\n   to disable this feature as the SIRV splice signals are slightly different.\n\n * Tuned the parameters for Nanopore Direct RNA reads. The recommended command\n   line is `-axsplice -k14 -uf` (#46).\n\n * Fixed a segmentation fault when aligning PacBio reads (#47 and #48). This\n   bug is very rare but it affects all versions of minimap2. It is also\n   recommended to re-index reference genomes created with `map-pb`. For human,\n   two minimizers in an old index are wrong.\n\n * Changed option `-L` in sync with the final decision of hts-specs: a fake\n   CIGAR takes the form of `<readLen>S<refLen>N`. Note that `-L` only enables\n   future tools to recognize long CIGARs. It is not possible for older tools to\n   work with such alignments in BAM (#43 and #51).\n\n * Fixed a tiny issue whereby minimap2 may waste 8 bytes per candidate\n   alignment.\n\nThe minimap2 technical note hosted at arXiv has also been updated to reflect\nrecent changes.\n\n(2.4: 6 November 2017, r555)\n\n\n\nRelease 2.3-r531 (22 October 2017)\n----------------------------------\n\nThis release come with many improvements and bug fixes:\n\n * The **sr** preset now supports paired-end short-read alignment. Minimap2 is\n   3-4 times as fast as BWA-MEM, but is slightly less accurate on simulated\n   reads.\n\n * Meticulous improvements to assembly-to-assembly alignment (special thanks to\n   Alexey Gurevich from the QUAST team): a) apply a small penalty to matches\n   between ambiguous bases; b) reduce missing alignments due to spurious\n   overlaps; c) introduce the short form of the `cs` tag, an improvement to the\n   SAM MD tag.\n\n * Make sure gaps are always left-aligned.\n\n * Recognize `U` bases from Oxford Nanopore Direct RNA-seq (#33).\n\n * Fixed slightly wrong chaining score. Fixed slightly inaccurate coordinates\n   for split alignment.\n\n * Fixed multiple reported bugs: 1) wrong reference name for inversion\n   alignment (#30); 2) redundant SQ lines when multiple query files are\n   specified (#39); 3) non-functioning option `-K` (#36).\n\nThis release has implemented all the major features I planned five months ago,\nwith the addition of spliced long-read alignment. The next couple of releases\nwill focus on fine tuning of the base algorithms.\n\n(2.3: 22 October 2017, r531)\n\n\n\nRelease 2.2-r409 (17 September 2017)\n------------------------------------\n\nThis is a feature release. It improves single-end short-read alignment and\ncomes with Python bindings. Detailed changes include:\n\n * Added the **sr** preset for single-end short-read alignment. In this mode,\n   minimap2 runs faster than BWA-MEM, but is slightly less accurate on\n   simulated data sets. Paired-end alignment is not supported as of now.\n\n * Improved mapping quality estimate with more accurate identification of\n   repetitive hits. This mainly helps short-read alignment.\n\n * Implemented **mappy**, a Python binding for minimap2, which is available\n   from PyPI and can be installed with `pip install --user mappy`. Python users\n   can perform read alignment without the minimap2 executable.\n\n * Restructured the indexing APIs and documented key minimap2 APIs in the\n   header file minimap.h. Updated example.c with the new APIs. Old APIs still\n   work but may become deprecated in future.\n\nThis release may output alignments different from the previous version, though\nthe overall alignment statistics, such as the number of aligned bases and long\ngaps, remain close.\n\n(2.2: 17 September 2017, r409)\n\n\n\nRelease 2.1.1-r341 (6 September 2017)\n-------------------------------------\n\nThis is a maintenance release that is expected to output identical alignment to\nv2.1. Detailed changes include:\n\n * Support CPU dispatch. By default, minimap2 is compiled with both SSE2 and\n   SSE4 based implementation of alignment and automatically chooses the right\n   one at runtime. This avoids unexpected errors on older CPUs (#21).\n\n * Improved Windows support as is requested by Oxford Nanopore (#19). Minimap2\n   now avoids variable-length stacked arrays, eliminates alloca(), ships with\n   getopt_long() and provides timing functions implemented with Windows APIs.\n\n * Fixed a potential segmentation fault when specifying -k/-w/-H with\n   multi-part index (#23).\n\n * Fixed two memory leaks in example.c\n\n(2.1.1: 6 September 2017, r341)\n\n\n\nRelease 2.1-r311 (25 August 2017)\n---------------------------------\n\nThis release adds spliced alignment for long noisy RNA-seq reads. On a SMRT\nIso-Seq and a Oxford Nanopore data sets, minimap2 appears to outperform\ntraditional mRNA aligners. For DNA alignment, this release gives almost\nidentical output to v2.0. Other changes include:\n\n * Added option `-R` to set the read group header line in SAM.\n\n * Optionally output the `cs:Z` tag in PAF to encode both the query and the\n   reference sequences in the alignment.\n\n * Fixed an issue where DP alignment uses excessive memory.\n\nThe minimap2 technical report has been updated with more details and the\nevaluation of spliced alignment:\n\n * Li, H. (2017). Minimap2: fast pairwise alignment for long nucleotide\n   sequences. [arXiv:1708.01492v2](https://arxiv.org/abs/1708.01492v2).\n\n(2.1: 25 August 2017, r311)\n\n\n\nRelease 2.0-r275 (8 August 2017)\n--------------------------------\n\nThis release is identical to version 2.0rc1, except the version number. It is\ndescribed and evaluated in the following technical report:\n\n * Li, H. (2017). Minimap2: fast pairwise alignment for long DNA sequences.\n   [arXiv:1708.01492v1](https://arxiv.org/abs/1708.01492v1).\n\n(2.0: 8 August 2017, r275)\n\n\n\nRelease 2.0rc1-r232 (30 July 2017)\n----------------------------------\n\nThis release improves the accuracy of long-read alignment and added several\nminor features.\n\n * Improved mapping quality estimate for short alignments containing few seed\n   hits.\n\n * Fixed a minor bug that affects the chaining accuracy towards the ends of a\n   chain. Changed the gap cost for chaining to reduce false seeding.\n\n * Skip potentially wrong seeding and apply dynamic programming more frequently.\n   This slightly increases run time, but greatly reduces false long gaps.\n\n * Perform local alignment at Z-drop break point to recover potential inversion\n   alignment. Output the SA tag in the SAM format. Added scripts to evaluate\n   mapping accuracy for reads simulated with pbsim.\n\nThis release completes features intended for v2.0. No major features will be\nadded to the master branch before the final v2.0.\n\n(2.0rc1: 30 July 2017, r232)\n\n\n\nRelease r191 (19 July 2017)\n---------------------------\n\nThis is the first public release of minimap2, an aligner for long reads and\nassemblies. This release has a few issues and is generally not recommended for\nproduction uses.\n\n(19 July 2017, r191)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.248046875,
          "content": "[![GitHub Downloads](https://img.shields.io/github/downloads/lh3/minimap2/total.svg?style=social&logo=github&label=Download)](https://github.com/lh3/minimap2/releases)\n[![BioConda Install](https://img.shields.io/conda/dn/bioconda/minimap2.svg?style=flag&label=BioConda%20install)](https://anaconda.org/bioconda/minimap2)\n[![PyPI](https://img.shields.io/pypi/v/mappy.svg?style=flat)](https://pypi.python.org/pypi/mappy)\n[![Build Status](https://github.com/lh3/minimap2/actions/workflows/ci.yaml/badge.svg)](https://github.com/lh3/minimap2/actions)\n## <a name=\"started\"></a>Getting Started\n```sh\ngit clone https://github.com/lh3/minimap2\ncd minimap2 && make\n# long sequences against a reference genome\n./minimap2 -a test/MT-human.fa test/MT-orang.fa > test.sam\n# create an index first and then map\n./minimap2 -x map-ont -d MT-human-ont.mmi test/MT-human.fa\n./minimap2 -a MT-human-ont.mmi test/MT-orang.fa > test.sam\n# use presets (no test data)\n./minimap2 -ax map-pb ref.fa pacbio.fq.gz > aln.sam       # PacBio CLR genomic reads\n./minimap2 -ax map-ont ref.fa ont.fq.gz > aln.sam         # Oxford Nanopore genomic reads\n./minimap2 -ax map-hifi ref.fa pacbio-ccs.fq.gz > aln.sam # PacBio HiFi/CCS genomic reads (v2.19 or later)\n./minimap2 -ax lr:hq ref.fa ont-Q20.fq.gz > aln.sam       # Nanopore Q20 genomic reads (v2.27 or later)\n./minimap2 -ax sr ref.fa read1.fa read2.fa > aln.sam      # short genomic paired-end reads\n./minimap2 -ax splice ref.fa rna-reads.fa > aln.sam       # spliced long reads (strand unknown)\n./minimap2 -ax splice -uf -k14 ref.fa reads.fa > aln.sam  # noisy Nanopore Direct RNA-seq\n./minimap2 -ax splice:hq -uf ref.fa query.fa > aln.sam    # Final PacBio Iso-seq or traditional cDNA\n./minimap2 -ax splice --junc-bed anno.bed12 ref.fa query.fa > aln.sam  # prioritize on annotated junctions\n./minimap2 -cx asm5 asm1.fa asm2.fa > aln.paf             # intra-species asm-to-asm alignment\n./minimap2 -x ava-pb reads.fa reads.fa > overlaps.paf     # PacBio read overlap\n./minimap2 -x ava-ont reads.fa reads.fa > overlaps.paf    # Nanopore read overlap\n# man page for detailed command line options\nman ./minimap2.1\n```\n\n## Table of Contents\n\n- [Getting Started](#started)\n- [Users' Guide](#uguide)\n  - [Installation](#install)\n  - [General usage](#general)\n  - [Use cases](#cases)\n    - [Map long noisy genomic reads](#map-long-genomic)\n    - [Map long mRNA/cDNA reads](#map-long-splice)\n    - [Find overlaps between long reads](#long-overlap)\n    - [Map short accurate genomic reads](#short-genomic)\n    - [Full genome/assembly alignment](#full-genome)\n  - [Advanced features](#advanced)\n    - [Working with >65535 CIGAR operations](#long-cigar)\n    - [The cs optional tag](#cs)\n    - [Working with the PAF format](#paftools)\n  - [Algorithm overview](#algo)\n  - [Getting help](#help)\n  - [Citing minimap2](#cite)\n- [Developers' Guide](#dguide)\n- [Limitations](#limit)\n\n## <a name=\"uguide\"></a>Users' Guide\n\nMinimap2 is a versatile sequence alignment program that aligns DNA or mRNA\nsequences against a large reference database. Typical use cases include: (1)\nmapping PacBio or Oxford Nanopore genomic reads to the human genome; (2)\nfinding overlaps between long reads with error rate up to ~15%; (3)\nsplice-aware alignment of PacBio Iso-Seq or Nanopore cDNA or Direct RNA reads\nagainst a reference genome; (4) aligning Illumina single- or paired-end reads;\n(5) assembly-to-assembly alignment; (6) full-genome alignment between two\nclosely related species with divergence below ~15%.\n\nFor ~10kb noisy reads sequences, minimap2 is tens of times faster than\nmainstream long-read mappers such as BLASR, BWA-MEM, NGMLR and GMAP. It is more\naccurate on simulated long reads and produces biologically meaningful alignment\nready for downstream analyses. For >100bp Illumina short reads, minimap2 is\nthree times as fast as BWA-MEM and Bowtie2, and as accurate on simulated data.\nDetailed evaluations are available from the [minimap2 paper][doi] or the\n[preprint][preprint].\n\n### <a name=\"install\"></a>Installation\n\nMinimap2 is optimized for x86-64 CPUs. You can acquire precompiled binaries from\nthe [release page][release] with:\n```sh\ncurl -L https://github.com/lh3/minimap2/releases/download/v2.28/minimap2-2.28_x64-linux.tar.bz2 | tar -jxvf -\n./minimap2-2.28_x64-linux/minimap2\n```\nIf you want to compile from the source, you need to have a C compiler, GNU make\nand zlib development files installed. Then type `make` in the source code\ndirectory to compile. If you see compilation errors, try `make sse2only=1`\nto disable SSE4 code, which will make minimap2 slightly slower.\n\nMinimap2 also works with ARM CPUs supporting the NEON instruction sets. To\ncompile for 32 bit ARM architectures (such as ARMv7), use `make arm_neon=1`. To\ncompile for for 64 bit ARM architectures (such as ARMv8), use `make arm_neon=1\naarch64=1`.\n\nMinimap2 can use [SIMD Everywhere (SIMDe)][simde] library for porting\nimplementation to the different SIMD instruction sets. To compile using SIMDe,\nuse `make -f Makefile.simde`. To compile for ARM CPUs, use `Makefile.simde`\nwith the ARM related command lines given above.\n\n### <a name=\"general\"></a>General usage\n\nWithout any options, minimap2 takes a reference database and a query sequence\nfile as input and produce approximate mapping, without base-level alignment\n(i.e. coordinates are only approximate and no CIGAR in output), in the [PAF format][paf]:\n```sh\nminimap2 ref.fa query.fq > approx-mapping.paf\n```\nYou can ask minimap2 to generate CIGAR at the `cg` tag of PAF with:\n```sh\nminimap2 -c ref.fa query.fq > alignment.paf\n```\nor to output alignments in the [SAM format][sam]:\n```sh\nminimap2 -a ref.fa query.fq > alignment.sam\n```\nMinimap2 seamlessly works with gzip'd FASTA and FASTQ formats as input. You\ndon't need to convert between FASTA and FASTQ or decompress gzip'd files first.\n\nFor the human reference genome, minimap2 takes a few minutes to generate a\nminimizer index for the reference before mapping. To reduce indexing time, you\ncan optionally save the index with option **-d** and replace the reference\nsequence file with the index file on the minimap2 command line:\n```sh\nminimap2 -d ref.mmi ref.fa                     # indexing\nminimap2 -a ref.mmi reads.fq > alignment.sam   # alignment\n```\n***Importantly***, it should be noted that once you build the index, indexing\nparameters such as **-k**, **-w**, **-H** and **-I** can't be changed during\nmapping. If you are running minimap2 for different data types, you will\nprobably need to keep multiple indexes generated with different parameters.\nThis makes minimap2 different from BWA which always uses the same index\nregardless of query data types.\n\n### <a name=\"cases\"></a>Use cases\n\nMinimap2 uses the same base algorithm for all applications. However, due to the\ndifferent data types it supports (e.g. short vs long reads; DNA vs mRNA reads),\nminimap2 needs to be tuned for optimal performance and accuracy. It is usually\nrecommended to choose a preset with option **-x**, which sets multiple\nparameters at the same time. The default setting is the same as `map-ont`.\n\n#### <a name=\"map-long-genomic\"></a>Map long noisy genomic reads\n\n```sh\nminimap2 -ax map-pb  ref.fa pacbio-reads.fq > aln.sam   # for PacBio CLR reads\nminimap2 -ax map-ont ref.fa ont-reads.fq > aln.sam      # for Oxford Nanopore reads\nminimap2 -ax map-iclr ref.fa iclr-reads.fq > aln.sam    # for Illumina Complete Long Reads\n```\nThe difference between `map-pb` and `map-ont` is that `map-pb` uses\nhomopolymer-compressed (HPC) minimizers as seeds, while `map-ont` uses ordinary\nminimizers as seeds. Empirical evaluation suggests HPC minimizers improve\nperformance and sensitivity when aligning PacBio CLR reads, but hurt when aligning\nNanopore reads. `map-iclr` uses an adjusted alignment scoring matrix that\naccounts for the low overall error rate in the reads, with transversion errors\nbeing less frequent than transitions.\n\n#### <a name=\"map-long-splice\"></a>Map long mRNA/cDNA reads\n\n```sh\nminimap2 -ax splice:hq -uf ref.fa iso-seq.fq > aln.sam       # PacBio Iso-seq/traditional cDNA\nminimap2 -ax splice ref.fa nanopore-cdna.fa > aln.sam        # Nanopore 2D cDNA-seq\nminimap2 -ax splice -uf -k14 ref.fa direct-rna.fq > aln.sam  # Nanopore Direct RNA-seq\nminimap2 -ax splice --splice-flank=no SIRV.fa SIRV-seq.fa    # mapping against SIRV control\n```\nThere are different long-read RNA-seq technologies, including tranditional\nfull-length cDNA, EST, PacBio Iso-seq, Nanopore 2D cDNA-seq and Direct RNA-seq.\nThey produce data of varying quality and properties. By default, `-x splice`\nassumes the read orientation relative to the transcript strand is unknown. It\ntries two rounds of alignment to infer the orientation and write the strand to\nthe `ts` SAM/PAF tag if possible. For Iso-seq, Direct RNA-seq and tranditional\nfull-length cDNAs, it would be desired to apply `-u f` to force minimap2 to\nconsider the forward transcript strand only. This speeds up alignment with\nslight improvement to accuracy. For noisy Nanopore Direct RNA-seq reads, it is\nrecommended to use a smaller k-mer size for increased sensitivity to the first\nor the last exons.\n\nMinimap2 rates an alignment by the score of the max-scoring sub-segment,\n*excluding* introns, and marks the best alignment as primary in SAM. When a\nspliced gene also has unspliced pseudogenes, minimap2 does not intentionally\nprefer spliced alignment, though in practice it more often marks the spliced\nalignment as the primary. By default, minimap2 outputs up to five secondary\nalignments (i.e. likely pseudogenes in the context of RNA-seq mapping). This\ncan be tuned with option **-N**.\n\nFor long RNA-seq reads, minimap2 may produce chimeric alignments potentially\ncaused by gene fusions/structural variations or by an intron longer than the\nmax intron length **-G** (200k by default). For now, it is not recommended to\napply an excessively large **-G** as this slows down minimap2 and sometimes\nleads to false alignments.\n\nIt is worth noting that by default `-x splice` prefers GT[A/G]..[C/T]AG\nover GT[C/T]..[A/G]AG, and then over other splicing signals. Considering\none additional base improves the junction accuracy for noisy reads, but\nreduces the accuracy when aligning against the widely used SIRV control data.\nThis is because SIRV does not honor the evolutionarily conservative splicing\nsignal. If you are studying SIRV, you may apply `--splice-flank=no` to let\nminimap2 only model GT..AG, ignoring the additional base.\n\nSince v2.17, minimap2 can optionally take annotated genes as input and\nprioritize on annotated splice junctions. To use this feature, you can \n```sh\npaftools.js gff2bed anno.gff > anno.bed\nminimap2 -ax splice --junc-bed anno.bed ref.fa query.fa > aln.sam\n```\nHere, `anno.gff` is the gene annotation in the GTF or GFF3 format (`gff2bed`\nautomatically tests the format). The output of `gff2bed` is in the 12-column\nBED format, or the BED12 format. With the `--junc-bed` option, minimap2 adds a\nbonus score (tuned by `--junc-bonus`) if an aligned junction matches a junction\nin the annotation. Option `--junc-bed` also takes 5-column BED, including the\nstrand field. In this case, each line indicates an oriented junction.\n\n#### <a name=\"long-overlap\"></a>Find overlaps between long reads\n\n```sh\nminimap2 -x ava-pb  reads.fq reads.fq > ovlp.paf    # PacBio CLR read overlap\nminimap2 -x ava-ont reads.fq reads.fq > ovlp.paf    # Oxford Nanopore read overlap\n```\nSimilarly, `ava-pb` uses HPC minimizers while `ava-ont` uses ordinary\nminimizers. It is usually not recommended to perform base-level alignment in\nthe overlapping mode because it is slow and may produce false positive\noverlaps. However, if performance is not a concern, you may try to add `-a` or\n`-c` anyway.\n\n#### <a name=\"short-genomic\"></a>Map short accurate genomic reads\n\n```sh\nminimap2 -ax sr ref.fa reads-se.fq > aln.sam           # single-end alignment\nminimap2 -ax sr ref.fa read1.fq read2.fq > aln.sam     # paired-end alignment\nminimap2 -ax sr ref.fa reads-interleaved.fq > aln.sam  # paired-end alignment\n```\nWhen two read files are specified, minimap2 reads from each file in turn and\nmerge them into an interleaved stream internally. Two reads are considered to\nbe paired if they are adjacent in the input stream and have the same name (with\nthe `/[0-9]` suffix trimmed if present). Single- and paired-end reads can be\nmixed.\n\nMinimap2 does not work well with short spliced reads. There are many capable\nRNA-seq mappers for short reads.\n\n#### <a name=\"full-genome\"></a>Full genome/assembly alignment\n\n```sh\nminimap2 -ax asm5 ref.fa asm.fa > aln.sam       # assembly to assembly/ref alignment\n```\nFor cross-species full-genome alignment, the scoring system needs to be tuned\naccording to the sequence divergence.\n\n### <a name=\"advanced\"></a>Advanced features\n\n#### <a name=\"long-cigar\"></a>Working with >65535 CIGAR operations\n\nDue to a design flaw, BAM does not work with CIGAR strings with >65535\noperations (SAM and CRAM work). However, for ultra-long nanopore reads minimap2\nmay align ~1% of read bases with long CIGARs beyond the capability of BAM. If\nyou convert such SAM/CRAM to BAM, Picard and recent samtools will throw an\nerror and abort. Older samtools and other tools may create corrupted BAM.\n\nTo avoid this issue, you can add option `-L` at the minimap2 command line.\nThis option moves a long CIGAR to the `CG` tag and leaves a fully clipped CIGAR\nat the SAM CIGAR column. Current tools that don't read CIGAR (e.g. merging and\nsorting) still work with such BAM records; tools that read CIGAR will\neffectively ignore these records. It has been decided that future tools\nwill seamlessly recognize long-cigar records generated by option `-L`.\n\n**TL;DR**: if you work with ultra-long reads and use tools that only process\nBAM files, please add option `-L`.\n\n#### <a name=\"cs\"></a>The cs optional tag\n\nThe `cs` SAM/PAF tag encodes bases at mismatches and INDELs. It matches regular\nexpression `/(:[0-9]+|\\*[a-z][a-z]|[=\\+\\-][A-Za-z]+)+/`. Like CIGAR, `cs`\nconsists of series of operations.  Each leading character specifies the\noperation; the following sequence is the one involved in the operation.\n\nThe `cs` tag is enabled by command line option `--cs`. The following alignment,\nfor example:\n```txt\nCGATCGATAAATAGAGTAG---GAATAGCA\n||||||   ||||||||||   |||| |||\nCGATCG---AATAGAGTAGGTCGAATtGCA\n```\nis represented as `:6-ata:10+gtc:4*at:3`, where `:[0-9]+` represents an\nidentical block, `-ata` represents a deletion, `+gtc` an insertion and `*at`\nindicates reference base `a` is substituted with a query base `t`. It is\nsimilar to the `MD` SAM tag but is standalone and easier to parse.\n\nIf `--cs=long` is used, the `cs` string also contains identical sequences in\nthe alignment. The above example will become\n`=CGATCG-ata=AATAGAGTAG+gtc=GAAT*at=GCA`. The long form of `cs` encodes both\nreference and query sequences in one string. The `cs` tag also encodes intron\npositions and splicing signals (see the [minimap2 manpage][manpage-cs] for\ndetails).\n\n#### <a name=\"paftools\"></a>Working with the PAF format\n\nMinimap2 also comes with a (java)script [paftools.js](misc/paftools.js) that\nprocesses alignments in the PAF format. It calls variants from\nassembly-to-reference alignment, lifts over BED files based on alignment,\nconverts between formats and provides utilities for various evaluations. For\ndetails, please see [misc/README.md](misc/README.md).\n\n### <a name=\"algo\"></a>Algorithm overview\n\nIn the following, minimap2 command line options have a dash ahead and are\nhighlighted in bold. The description may help to tune minimap2 parameters.\n\n1. Read **-I** [=*4G*] reference bases, extract (**-k**,**-w**)-minimizers and\n   index them in a hash table.\n\n2. Read **-K** [=*200M*] query bases. For each query sequence, do step 3\n   through 7:\n\n3. For each (**-k**,**-w**)-minimizer on the query, check against the reference\n   index. If a reference minimizer is not among the top **-f** [=*2e-4*] most\n   frequent, collect its the occurrences in the reference, which are called\n   *seeds*.\n\n4. Sort seeds by position in the reference. Chain them with dynamic\n   programming. Each chain represents a potential mapping. For read\n   overlapping, report all chains and then go to step 8. For reference mapping,\n   do step 5 through 7:\n\n5. Let *P* be the set of primary mappings, which is an empty set initially. For\n   each chain from the best to the worst according to their chaining scores: if\n   on the query, the chain overlaps with a chain in *P* by **--mask-level**\n   [=*0.5*] or higher fraction of the shorter chain, mark the chain as\n   *secondary* to the chain in *P*; otherwise, add the chain to *P*.\n\n6. Retain all primary mappings. Also retain up to **-N** [=*5*] top secondary\n   mappings if their chaining scores are higher than **-p** [=*0.8*] of their\n   corresponding primary mappings.\n\n7. If alignment is requested, filter out an internal seed if it potentially\n   leads to both a long insertion and a long deletion. Extend from the\n   left-most seed. Perform global alignments between internal seeds.  Split the\n   chain if the accumulative score along the global alignment drops by **-z**\n   [=*400*], disregarding long gaps. Extend from the right-most seed.  Output\n   chains and their alignments.\n\n8. If there are more query sequences in the input, go to step 2 until no more\n   queries are left.\n\n9. If there are more reference sequences, reopen the query file from the start\n   and go to step 1; otherwise stop.\n\n### <a name=\"help\"></a>Getting help\n\nManpage [minimap2.1][manpage] provides detailed description of minimap2\ncommand line options and optional tags. The [FAQ](FAQ.md) page answers several\nfrequently asked questions. If you encounter bugs or have further questions or\nrequests, you can raise an issue at the [issue page][issue].  There is not a\nspecific mailing list for the time being.\n\n### <a name=\"cite\"></a>Citing minimap2\n\nIf you use minimap2 in your work, please cite:\n\n> Li, H. (2018). Minimap2: pairwise alignment for nucleotide sequences.\n> *Bioinformatics*, **34**:3094-3100. [doi:10.1093/bioinformatics/bty191][doi]\n\nand/or:\n\n> Li, H. (2021). New strategies to improve minimap2 alignment accuracy.\n> *Bioinformatics*, **37**:4572-4574. [doi:10.1093/bioinformatics/btab705][doi2]\n\n## <a name=\"dguide\"></a>Developers' Guide\n\nMinimap2 is not only a command line tool, but also a programming library.\nIt provides C APIs to build/load index and to align sequences against the\nindex. File [example.c](example.c) demonstrates typical uses of C APIs. Header\nfile [minimap.h](minimap.h) gives more detailed API documentation. Minimap2\naims to keep APIs in this header stable. File [mmpriv.h](mmpriv.h) contains\nadditional private APIs which may be subjected to changes frequently.\n\nThis repository also provides Python bindings to a subset of C APIs. File\n[python/README.rst](python/README.rst) gives the full documentation;\n[python/minimap2.py](python/minimap2.py) shows an example. This Python\nextension, mappy, is also [available from PyPI][mappypypi] via `pip install\nmappy` or [from BioConda][mappyconda] via `conda install -c bioconda mappy`.\n\n## <a name=\"limit\"></a>Limitations\n\n* Minimap2 may produce suboptimal alignments through long low-complexity\n  regions where seed positions may be suboptimal. This should not be a big\n  concern because even the optimal alignment may be wrong in such regions.\n\n* Minimap2 requires SSE2 instructions on x86 CPUs or NEON on ARM CPUs. It is\n  possible to add non-SIMD support, but it would make minimap2 slower by\n  several times.\n\n* Minimap2 does not work with a single query or database sequence ~2\n  billion bases or longer (2,147,483,647 to be exact). The total length of all\n  sequences can well exceed this threshold.\n\n* Minimap2 often misses small exons.\n\n\n\n[paf]: https://github.com/lh3/miniasm/blob/master/PAF.md\n[sam]: https://samtools.github.io/hts-specs/SAMv1.pdf\n[minimap]: https://github.com/lh3/minimap\n[smartdenovo]: https://github.com/ruanjue/smartdenovo\n[longislnd]: https://www.ncbi.nlm.nih.gov/pubmed/27667791\n[gaba]: https://github.com/ocxtal/libgaba\n[ksw2]: https://github.com/lh3/ksw2\n[preprint]: https://arxiv.org/abs/1708.01492\n[release]: https://github.com/lh3/minimap2/releases\n[mappypypi]: https://pypi.python.org/pypi/mappy\n[mappyconda]: https://anaconda.org/bioconda/mappy\n[issue]: https://github.com/lh3/minimap2/issues\n[k8]: https://github.com/attractivechaos/k8\n[manpage]: https://lh3.github.io/minimap2/minimap2.html\n[manpage-cs]: https://lh3.github.io/minimap2/minimap2.html#10\n[doi]: https://doi.org/10.1093/bioinformatics/bty191\n[doi2]: https://doi.org/10.1093/bioinformatics/btab705\n[simde]: https://github.com/nemequ/simde\n[unimap]: https://github.com/lh3/unimap\n"
        },
        {
          "name": "align.c",
          "type": "blob",
          "size": 37.74609375,
          "content": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"minimap.h\"\n#include \"mmpriv.h\"\n#include \"ksw2.h\"\n\nstatic void ksw_gen_simple_mat(int m, int8_t *mat, int8_t a, int8_t b, int8_t sc_ambi)\n{\n\tint i, j;\n\ta = a < 0? -a : a;\n\tb = b > 0? -b : b;\n\tsc_ambi = sc_ambi > 0? -sc_ambi : sc_ambi;\n\tfor (i = 0; i < m - 1; ++i) {\n\t\tfor (j = 0; j < m - 1; ++j)\n\t\t\tmat[i * m + j] = i == j? a : b;\n\t\tmat[i * m + m - 1] = sc_ambi;\n\t}\n\tfor (j = 0; j < m; ++j)\n\t\tmat[(m - 1) * m + j] = sc_ambi;\n}\n\nstatic void ksw_gen_ts_mat(int m, int8_t *mat, int8_t a, int8_t b, int8_t transition, int8_t sc_ambi)\n{\n\tassert(m == 5);\n\tksw_gen_simple_mat(m, mat, a, b, sc_ambi);\n\tif (transition == 0 || transition == b) return;\n\ttransition = transition > 0? -transition : transition;\n\tmat[0 * m + 2] = transition;  // A->G\n\tmat[1 * m + 3] = transition;  // C->T\n\tmat[2 * m + 0] = transition;  // G->A\n\tmat[3 * m + 1] = transition;  // T->C\n}\n\nstatic inline void mm_seq_rev(uint32_t len, uint8_t *seq)\n{\n\tuint32_t i;\n\tuint8_t t;\n\tfor (i = 0; i < len>>1; ++i)\n\t\tt = seq[i], seq[i] = seq[len - 1 - i], seq[len - 1 - i] = t;\n}\n\nstatic inline void update_max_zdrop(int32_t score, int i, int j, int32_t *max, int *max_i, int *max_j, int e, int *max_zdrop, int pos[2][2])\n{\n\tif (score < *max) {\n\t\tint li = i - *max_i;\n\t\tint lj = j - *max_j;\n\t\tint diff = li > lj? li - lj : lj - li;\n\t\tint z = *max - score - diff * e;\n\t\tif (z > *max_zdrop) {\n\t\t\t*max_zdrop = z;\n\t\t\tpos[0][0] = *max_i, pos[0][1] = i;\n\t\t\tpos[1][0] = *max_j, pos[1][1] = j;\n\t\t}\n\t} else *max = score, *max_i = i, *max_j = j;\n}\n\nstatic int mm_test_zdrop(void *km, const mm_mapopt_t *opt, const uint8_t *qseq, const uint8_t *tseq, uint32_t n_cigar, uint32_t *cigar, const int8_t *mat)\n{\n\tuint32_t k;\n\tint32_t score = 0, max = INT32_MIN, max_i = -1, max_j = -1, i = 0, j = 0, max_zdrop = 0;\n\tint pos[2][2] = {{-1, -1}, {-1, -1}}, q_len, t_len;\n\n\t// find the score and the region where score drops most along diagonal\n\tfor (k = 0, score = 0; k < n_cigar; ++k) {\n\t\tuint32_t l, op = cigar[k]&0xf, len = cigar[k]>>4;\n\t\tif (op == MM_CIGAR_MATCH) {\n\t\t\tfor (l = 0; l < len; ++l) {\n\t\t\t\tscore += mat[tseq[i + l] * 5 + qseq[j + l]];\n\t\t\t\tupdate_max_zdrop(score, i+l, j+l, &max, &max_i, &max_j, opt->e, &max_zdrop, pos);\n\t\t\t}\n\t\t\ti += len, j += len;\n\t\t} else if (op == MM_CIGAR_INS || op == MM_CIGAR_DEL || op == MM_CIGAR_N_SKIP) {\n\t\t\tscore -= opt->q + opt->e * len;\n\t\t\tif (op == MM_CIGAR_INS) j += len;\n\t\t\telse i += len;\n\t\t\tupdate_max_zdrop(score, i, j, &max, &max_i, &max_j, opt->e, &max_zdrop, pos);\n\t\t}\n\t}\n\n\t// test if there is an inversion in the most dropped region\n\tq_len = pos[1][1] - pos[1][0], t_len = pos[0][1] - pos[0][0];\n\tif (!(opt->flag&(MM_F_SPLICE|MM_F_SR|MM_F_FOR_ONLY|MM_F_REV_ONLY)) && max_zdrop > opt->zdrop_inv && q_len < opt->max_gap && t_len < opt->max_gap) {\n\t\tuint8_t *qseq2;\n\t\tvoid *qp;\n\t\tint q_off, t_off;\n\t\tqseq2 = (uint8_t*)kmalloc(km, q_len);\n\t\tfor (i = 0; i < q_len; ++i) {\n\t\t\tint c = qseq[pos[1][1] - i - 1];\n\t\t\tqseq2[i] = c >= 4? 4 : 3 - c;\n\t\t}\n\t\tqp = ksw_ll_qinit(km, 2, q_len, qseq2, 5, mat);\n\t\tscore = ksw_ll_i16(qp, t_len, tseq + pos[0][0], opt->q, opt->e, &q_off, &t_off);\n\t\tkfree(km, qseq2);\n\t\tkfree(km, qp);\n\t\tif (score >= opt->min_chain_score * opt->a && score >= opt->min_dp_max)\n\t\t\treturn 2; // there is a potential inversion\n\t}\n\treturn max_zdrop > opt->zdrop? 1 : 0;\n}\n\nstatic void mm_fix_cigar(mm_reg1_t *r, const uint8_t *qseq, const uint8_t *tseq, int *qshift, int *tshift)\n{\n\tmm_extra_t *p = r->p;\n\tint32_t toff = 0, qoff = 0, to_shrink = 0;\n\tuint32_t k;\n\t*qshift = *tshift = 0;\n\tif (p->n_cigar <= 1) return;\n\tfor (k = 0; k < p->n_cigar; ++k) { // indel left alignment\n\t\tuint32_t op = p->cigar[k]&0xf, len = p->cigar[k]>>4;\n\t\tif (len == 0) to_shrink = 1;\n\t\tif (op == MM_CIGAR_MATCH) {\n\t\t\ttoff += len, qoff += len;\n\t\t} else if (op == MM_CIGAR_INS || op == MM_CIGAR_DEL) {\n\t\t\tif (k > 0 && k < p->n_cigar - 1 && (p->cigar[k-1]&0xf) == 0 && (p->cigar[k+1]&0xf) == 0) {\n\t\t\t\tint l, prev_len = p->cigar[k-1] >> 4;\n\t\t\t\tif (op == MM_CIGAR_INS) {\n\t\t\t\t\tfor (l = 0; l < prev_len; ++l)\n\t\t\t\t\t\tif (qseq[qoff - 1 - l] != qseq[qoff + len - 1 - l])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tfor (l = 0; l < prev_len; ++l)\n\t\t\t\t\t\tif (tseq[toff - 1 - l] != tseq[toff + len - 1 - l])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (l > 0)\n\t\t\t\t\tp->cigar[k-1] -= l<<4, p->cigar[k+1] += l<<4, qoff -= l, toff -= l;\n\t\t\t\tif (l == prev_len) to_shrink = 1;\n\t\t\t}\n\t\t\tif (op == MM_CIGAR_INS) qoff += len;\n\t\t\telse toff += len;\n\t\t} else if (op == MM_CIGAR_N_SKIP) {\n\t\t\ttoff += len;\n\t\t}\n\t}\n\tassert(qoff == r->qe - r->qs && toff == r->re - r->rs);\n\tfor (k = 0; k < p->n_cigar - 2; ++k) { // fix CIGAR like 5I6D7I\n\t\tif ((p->cigar[k]&0xf) > 0 && (p->cigar[k]&0xf) + (p->cigar[k+1]&0xf) == 3) {\n\t\t\tuint32_t l, s[3] = {0,0,0};\n\t\t\tfor (l = k; l < p->n_cigar; ++l) { // count number of adjacent I and D\n\t\t\t\tuint32_t op = p->cigar[l]&0xf;\n\t\t\t\tif (op == MM_CIGAR_INS || op == MM_CIGAR_DEL || p->cigar[l]>>4 == 0)\n\t\t\t\t\ts[op] += p->cigar[l] >> 4;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (s[1] > 0 && s[2] > 0 && l - k > 2) { // turn to a single I and a single D\n\t\t\t\tp->cigar[k]   = s[1]<<4|MM_CIGAR_INS;\n\t\t\t\tp->cigar[k+1] = s[2]<<4|MM_CIGAR_DEL;\n\t\t\t\tfor (k += 2; k < l; ++k)\n\t\t\t\t\tp->cigar[k] &= 0xf;\n\t\t\t\tto_shrink = 1;\n\t\t\t}\n\t\t\tk = l;\n\t\t}\n\t}\n\tif (to_shrink) { // squeeze out zero-length operations\n\t\tint32_t l = 0;\n\t\tfor (k = 0; k < p->n_cigar; ++k) // squeeze out zero-length operations\n\t\t\tif (p->cigar[k]>>4 != 0)\n\t\t\t\tp->cigar[l++] = p->cigar[k];\n\t\tp->n_cigar = l;\n\t\tfor (k = l = 0; k < p->n_cigar; ++k) // merge two adjacent operations if they are the same\n\t\t\tif (k == p->n_cigar - 1 || (p->cigar[k]&0xf) != (p->cigar[k+1]&0xf))\n\t\t\t\tp->cigar[l++] = p->cigar[k];\n\t\t\telse p->cigar[k+1] += p->cigar[k]>>4<<4; // add length to the next CIGAR operator\n\t\tp->n_cigar = l;\n\t}\n\tif ((p->cigar[0]&0xf) == MM_CIGAR_INS || (p->cigar[0]&0xf) == MM_CIGAR_DEL) { // get rid of leading I or D\n\t\tint32_t l = p->cigar[0] >> 4;\n\t\tif ((p->cigar[0]&0xf) == MM_CIGAR_INS) {\n\t\t\tif (r->rev) r->qe -= l;\n\t\t\telse r->qs += l;\n\t\t\t*qshift = l;\n\t\t} else r->rs += l, *tshift = l;\n\t\t--p->n_cigar;\n\t\tmemmove(p->cigar, p->cigar + 1, p->n_cigar * 4);\n\t}\n}\n\nstatic void mm_update_cigar_eqx(mm_reg1_t *r, const uint8_t *qseq, const uint8_t *tseq) // written by @armintoepfer\n{\n\tuint32_t n_EQX = 0;\n\tuint32_t k, l, m, cap, toff = 0, qoff = 0, n_M = 0;\n\tmm_extra_t *p;\n\tif (r->p == 0) return;\n\tfor (k = 0; k < r->p->n_cigar; ++k) {\n\t\tuint32_t op = r->p->cigar[k]&0xf, len = r->p->cigar[k]>>4;\n\t\tif (op == MM_CIGAR_MATCH) {\n\t\t\twhile (len > 0) {\n\t\t\t\tfor (l = 0; l < len && qseq[qoff + l] == tseq[toff + l]; ++l) {} // run of \"=\"; TODO: N<=>N is converted to \"=\"\n\t\t\t\tif (l > 0) { ++n_EQX; len -= l; toff += l; qoff += l; }\n\n\t\t\t\tfor (l = 0; l < len && qseq[qoff + l] != tseq[toff + l]; ++l) {} // run of \"X\"\n\t\t\t\tif (l > 0) { ++n_EQX; len -= l; toff += l; qoff += l; }\n\t\t\t}\n\t\t\t++n_M;\n\t\t} else if (op == MM_CIGAR_INS) {\n\t\t\tqoff += len;\n\t\t} else if (op == MM_CIGAR_DEL) {\n\t\t\ttoff += len;\n\t\t} else if (op == MM_CIGAR_N_SKIP) {\n\t\t\ttoff += len;\n\t\t}\n\t}\n\t// update in-place if we can\n\tif (n_EQX == n_M) {\n\t\tfor (k = 0; k < r->p->n_cigar; ++k) {\n\t\t\tuint32_t op = r->p->cigar[k]&0xf, len = r->p->cigar[k]>>4;\n\t\t\tif (op == MM_CIGAR_MATCH) r->p->cigar[k] = len << 4 | MM_CIGAR_EQ_MATCH;\n\t\t}\n\t\treturn;\n\t}\n\t// allocate new storage\n\tcap = r->p->n_cigar + (n_EQX - n_M) + sizeof(mm_extra_t);\n\tkroundup32(cap);\n\tp = (mm_extra_t*)calloc(cap, 4);\n\tmemcpy(p, r->p, sizeof(mm_extra_t));\n\tp->capacity = cap;\n\t// update cigar while copying\n\ttoff = qoff = m = 0;\n\tfor (k = 0; k < r->p->n_cigar; ++k) {\n\t\tuint32_t op = r->p->cigar[k]&0xf, len = r->p->cigar[k]>>4;\n\t\tif (op == MM_CIGAR_MATCH) {\n\t\t\twhile (len > 0) {\n\t\t\t\t// match\n\t\t\t\tfor (l = 0; l < len && qseq[qoff + l] == tseq[toff + l]; ++l) {}\n\t\t\t\tif (l > 0) p->cigar[m++] = l << 4 | MM_CIGAR_EQ_MATCH;\n\t\t\t\tlen -= l;\n\t\t\t\ttoff += l, qoff += l;\n\t\t\t\t// mismatch\n\t\t\t\tfor (l = 0; l < len && qseq[qoff + l] != tseq[toff + l]; ++l) {}\n\t\t\t\tif (l > 0) p->cigar[m++] = l << 4 | MM_CIGAR_X_MISMATCH;\n\t\t\t\tlen -= l;\n\t\t\t\ttoff += l, qoff += l;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (op == MM_CIGAR_INS) {\n\t\t\tqoff += len;\n\t\t} else if (op == MM_CIGAR_DEL) {\n\t\t\ttoff += len;\n\t\t} else if (op == MM_CIGAR_N_SKIP) {\n\t\t\ttoff += len;\n\t\t}\n\t\tp->cigar[m++] = r->p->cigar[k];\n\t}\n\tp->n_cigar = m;\n\tfree(r->p);\n\tr->p = p;\n}\n\nstatic void mm_update_extra(mm_reg1_t *r, const uint8_t *qseq, const uint8_t *tseq, const int8_t *mat, int8_t q, int8_t e, int is_eqx, int log_gap)\n{\n\tuint32_t k, l;\n\tint32_t qshift, tshift, toff = 0, qoff = 0;\n\tdouble s = 0.0, max = 0.0;\n\tmm_extra_t *p = r->p;\n\tif (p == 0) return;\n\tmm_fix_cigar(r, qseq, tseq, &qshift, &tshift);\n\tqseq += qshift, tseq += tshift; // qseq and tseq may be shifted due to the removal of leading I/D\n\tr->blen = r->mlen = 0;\n\tfor (k = 0; k < p->n_cigar; ++k) {\n\t\tuint32_t op = p->cigar[k]&0xf, len = p->cigar[k]>>4;\n\t\tif (op == MM_CIGAR_MATCH) {\n\t\t\tint n_ambi = 0, n_diff = 0;\n\t\t\tfor (l = 0; l < len; ++l) {\n\t\t\t\tint cq = qseq[qoff + l], ct = tseq[toff + l];\n\t\t\t\tif (ct > 3 || cq > 3) ++n_ambi;\n\t\t\t\telse if (ct != cq) ++n_diff;\n\t\t\t\ts += mat[ct * 5 + cq];\n\t\t\t\tif (s < 0) s = 0;\n\t\t\t\telse max = max > s? max : s;\n\t\t\t}\n\t\t\tr->blen += len - n_ambi, r->mlen += len - (n_ambi + n_diff), p->n_ambi += n_ambi;\n\t\t\ttoff += len, qoff += len;\n\t\t} else if (op == MM_CIGAR_INS) {\n\t\t\tint n_ambi = 0;\n\t\t\tfor (l = 0; l < len; ++l)\n\t\t\t\tif (qseq[qoff + l] > 3) ++n_ambi;\n\t\t\tr->blen += len - n_ambi, p->n_ambi += n_ambi;\n\t\t\tif (log_gap) s -= q + (double)e * mg_log2(1.0 + len);\n\t\t\telse s -= q + e;\n\t\t\tif (s < 0) s = 0;\n\t\t\tqoff += len;\n\t\t} else if (op == MM_CIGAR_DEL) {\n\t\t\tint n_ambi = 0;\n\t\t\tfor (l = 0; l < len; ++l)\n\t\t\t\tif (tseq[toff + l] > 3) ++n_ambi;\n\t\t\tr->blen += len - n_ambi, p->n_ambi += n_ambi;\n\t\t\tif (log_gap) s -= q + (double)e * mg_log2(1.0 + len);\n\t\t\telse s -= q + e;\n\t\t\tif (s < 0) s = 0;\n\t\t\ttoff += len;\n\t\t} else if (op == MM_CIGAR_N_SKIP) {\n\t\t\ttoff += len;\n\t\t}\n\t}\n\tp->dp_max = p->dp_max0 = (int32_t)(max + .499);\n\tassert(qoff == r->qe - r->qs && toff == r->re - r->rs);\n\tif (is_eqx) mm_update_cigar_eqx(r, qseq, tseq); // NB: it has to be called here as changes to qseq and tseq are not returned\n}\n\nstatic void mm_append_cigar(mm_reg1_t *r, uint32_t n_cigar, uint32_t *cigar) // TODO: this calls the libc realloc()\n{\n\tmm_extra_t *p;\n\tif (n_cigar == 0) return;\n\tif (r->p == 0) {\n\t\tuint32_t capacity = n_cigar + sizeof(mm_extra_t)/4;\n\t\tkroundup32(capacity);\n\t\tr->p = (mm_extra_t*)calloc(capacity, 4);\n\t\tr->p->capacity = capacity;\n\t} else if (r->p->n_cigar + n_cigar + sizeof(mm_extra_t)/4 > r->p->capacity) {\n\t\tr->p->capacity = r->p->n_cigar + n_cigar + sizeof(mm_extra_t)/4;\n\t\tkroundup32(r->p->capacity);\n\t\tr->p = (mm_extra_t*)realloc(r->p, r->p->capacity * 4);\n\t}\n\tp = r->p;\n\tif (p->n_cigar > 0 && (p->cigar[p->n_cigar-1]&0xf) == (cigar[0]&0xf)) { // same CIGAR op at the boundary\n\t\tp->cigar[p->n_cigar-1] += cigar[0]>>4<<4;\n\t\tif (n_cigar > 1) memcpy(p->cigar + p->n_cigar, cigar + 1, (n_cigar - 1) * 4);\n\t\tp->n_cigar += n_cigar - 1;\n\t} else {\n\t\tmemcpy(p->cigar + p->n_cigar, cigar, n_cigar * 4);\n\t\tp->n_cigar += n_cigar;\n\t}\n}\n\nstatic void mm_align_pair(void *km, const mm_mapopt_t *opt, int qlen, const uint8_t *qseq, int tlen, const uint8_t *tseq, const uint8_t *junc,\n\t\t\t\t\t\t  const int8_t *mat, int w, int end_bonus, int zdrop, int ksw_flag, ksw_extz_t *ez)\n{\n\tif (mm_dbg_flag & MM_DBG_PRINT_ALN_SEQ) {\n\t\tint i;\n\t\tfprintf(stderr, \"===> q=(%d,%d), e=(%d,%d), bw=%d, ksw_flag=%d, zdrop=%d <===\\n\", opt->q, opt->q2, opt->e, opt->e2, w, ksw_flag, opt->zdrop);\n\t\tfor (i = 0; i < tlen; ++i) fputc(\"ACGTN\"[tseq[i]], stderr);\n\t\tfputc('\\n', stderr);\n\t\tfor (i = 0; i < qlen; ++i) fputc(\"ACGTN\"[qseq[i]], stderr);\n\t\tfputc('\\n', stderr);\n\t}\n\tif (opt->transition != 0 && opt->b != opt->transition)\n\t\tksw_flag |= KSW_EZ_GENERIC_SC;\n\tif (opt->max_sw_mat > 0 && (int64_t)tlen * qlen > opt->max_sw_mat) { // too much memory; skip alignment\n\t\tksw_reset_extz(ez);\n\t\tez->zdropped = 1;\n\t} else if (opt->flag & MM_F_SPLICE) { // spliced alignment\n\t\tassert((ksw_flag & KSW_EZ_SPLICE_FOR) == 0 || (ksw_flag & KSW_EZ_SPLICE_REV) == 0);\n\t\tif (!(opt->flag & MM_F_SPLICE_OLD)) ksw_flag |= KSW_EZ_SPLICE_CMPLX;\n\t\tksw_exts2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, opt->q2, opt->noncan, zdrop, opt->junc_bonus, opt->junc_pen, ksw_flag, junc, ez);\n\t} else if (opt->q == opt->q2 && opt->e == opt->e2) { // affine gap\n\t\tksw_extz2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, w, zdrop, end_bonus, ksw_flag, ez);\n\t} else { // dual affine gap\n\t\tksw_extd2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, opt->q2, opt->e2, w, zdrop, end_bonus, ksw_flag, ez);\n\t}\n\tif (mm_dbg_flag & MM_DBG_PRINT_ALN_SEQ) {\n\t\tint i;\n\t\tfprintf(stderr, \"score=%d, cigar=\", ez->score);\n\t\tfor (i = 0; i < ez->n_cigar; ++i)\n\t\t\tfprintf(stderr, \"%d%c\", ez->cigar[i]>>4, MM_CIGAR_STR[ez->cigar[i]&0xf]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nstatic inline int mm_get_hplen_back(const mm_idx_t *mi, uint32_t rid, uint32_t x)\n{\n\tint64_t i, off0 = mi->seq[rid].offset, off = off0 + x;\n\tint c = mm_seq4_get(mi->S, off);\n\tfor (i = off - 1; i >= off0; --i)\n\t\tif (mm_seq4_get(mi->S, i) != c) break;\n\treturn (int)(off - i);\n}\n\nstatic inline void mm_adjust_minier(const mm_idx_t *mi, uint8_t *const qseq0[2], mm128_t *a, int32_t *r, int32_t *q)\n{\n\tif (mi->flag & MM_I_HPC) {\n\t\tconst uint8_t *qseq = qseq0[a->x>>63];\n\t\tint i, c;\n\t\t*q = (int32_t)a->y;\n\t\tfor (i = *q - 1, c = qseq[*q]; i > 0; --i)\n\t\t\tif (qseq[i] != c) break;\n\t\t*q = i + 1;\n\t\tc = mm_get_hplen_back(mi, a->x<<1>>33, (int32_t)a->x);\n\t\t*r = (int32_t)a->x + 1 - c;\n\t} else {\n\t\t*r = (int32_t)a->x - (mi->k>>1);\n\t\t*q = (int32_t)a->y - (mi->k>>1);\n\t}\n}\n\nstatic int *collect_long_gaps(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int *n_)\n{\n\tint i, n, *K;\n\t*n_ = 0;\n\tfor (i = 1, n = 0; i < cnt1; ++i) { // count the number of gaps longer than min_gap\n\t\tint gap = ((int32_t)a[as1 + i].y - a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - a[as1 + i - 1].x);\n\t\tif (gap < -min_gap || gap > min_gap) ++n;\n\t}\n\tif (n <= 1) return 0;\n\tK = (int*)kmalloc(km, n * sizeof(int));\n\tfor (i = 1, n = 0; i < cnt1; ++i) { // store the positions of long gaps\n\t\tint gap = ((int32_t)a[as1 + i].y - a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - a[as1 + i - 1].x);\n\t\tif (gap < -min_gap || gap > min_gap)\n\t\t\tK[n++] = i;\n\t}\n\t*n_ = n;\n\treturn K;\n}\n\nstatic void mm_filter_bad_seeds(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int diff_thres, int max_ext_len, int max_ext_cnt)\n{\n\tint max_st, max_en, n, i, k, max, *K;\n\tK = collect_long_gaps(km, as1, cnt1, a, min_gap, &n);\n\tif (K == 0) return;\n\tmax = 0, max_st = max_en = -1;\n\tfor (k = 0;; ++k) { // traverse long gaps\n\t\tint gap, l, n_ins = 0, n_del = 0, qs, rs, max_diff = 0, max_diff_l = -1;\n\t\tif (k == n || k >= max_en) {\n\t\t\tif (max_en > 0)\n\t\t\t\tfor (i = K[max_st]; i < K[max_en]; ++i)\n\t\t\t\t\ta[as1 + i].y |= MM_SEED_IGNORE;\n\t\t\tmax = 0, max_st = max_en = -1;\n\t\t\tif (k == n) break;\n\t\t}\n\t\ti = K[k];\n\t\tgap = ((int32_t)a[as1 + i].y - (int32_t)a[as1 + i - 1].y) - (int32_t)(a[as1 + i].x - a[as1 + i - 1].x);\n\t\tif (gap > 0) n_ins += gap;\n\t\telse n_del += -gap;\n\t\tqs = (int32_t)a[as1 + i - 1].y;\n\t\trs = (int32_t)a[as1 + i - 1].x;\n\t\tfor (l = k + 1; l < n && l <= k + max_ext_cnt; ++l) {\n\t\t\tint j = K[l], diff;\n\t\t\tif ((int32_t)a[as1 + j].y - qs > max_ext_len || (int32_t)a[as1 + j].x - rs > max_ext_len) break;\n\t\t\tgap = ((int32_t)a[as1 + j].y - (int32_t)a[as1 + j - 1].y) - (int32_t)(a[as1 + j].x - a[as1 + j - 1].x);\n\t\t\tif (gap > 0) n_ins += gap;\n\t\t\telse n_del += -gap;\n\t\t\tdiff = n_ins + n_del - abs(n_ins - n_del);\n\t\t\tif (max_diff < diff)\n\t\t\t\tmax_diff = diff, max_diff_l = l;\n\t\t}\n\t\tif (max_diff > diff_thres && max_diff > max)\n\t\t\tmax = max_diff, max_st = k, max_en = max_diff_l;\n\t}\n\tkfree(km, K);\n}\n\nstatic void mm_filter_bad_seeds_alt(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int max_ext)\n{\n\tint n, k, *K;\n\tK = collect_long_gaps(km, as1, cnt1, a, min_gap, &n);\n\tif (K == 0) return;\n\tfor (k = 0; k < n;) {\n\t\tint i = K[k], l;\n\t\tint gap1 = ((int32_t)a[as1 + i].y - (int32_t)a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - (int32_t)a[as1 + i - 1].x);\n\t\tint re1 = (int32_t)a[as1 + i].x;\n\t\tint qe1 = (int32_t)a[as1 + i].y;\n\t\tgap1 = gap1 > 0? gap1 : -gap1;\n\t\tfor (l = k + 1; l < n; ++l) {\n\t\t\tint j = K[l], gap2, q_span_pre, rs2, qs2, m;\n\t\t\tif ((int32_t)a[as1 + j].y - qe1 > max_ext || (int32_t)a[as1 + j].x - re1 > max_ext) break;\n\t\t\tgap2 = ((int32_t)a[as1 + j].y - (int32_t)a[as1 + j - 1].y) - (int32_t)(a[as1 + j].x - a[as1 + j - 1].x);\n\t\t\tq_span_pre = a[as1 + j - 1].y >> 32 & 0xff;\n\t\t\trs2 = (int32_t)a[as1 + j - 1].x + q_span_pre;\n\t\t\tqs2 = (int32_t)a[as1 + j - 1].y + q_span_pre;\n\t\t\tm = rs2 - re1 < qs2 - qe1? rs2 - re1 : qs2 - qe1;\n\t\t\tgap2 = gap2 > 0? gap2 : -gap2;\n\t\t\tif (m > gap1 + gap2) break;\n\t\t\tre1 = (int32_t)a[as1 + j].x;\n\t\t\tqe1 = (int32_t)a[as1 + j].y;\n\t\t\tgap1 = gap2;\n\t\t}\n\t\tif (l > k + 1) {\n\t\t\tint j, end = K[l - 1];\n\t\t\tfor (j = K[k]; j < end; ++j)\n\t\t\t\ta[as1 + j].y |= MM_SEED_IGNORE;\n\t\t\ta[as1 + end].y |= MM_SEED_LONG_JOIN;\n\t\t}\n\t\tk = l;\n\t}\n\tkfree(km, K);\n}\n\nstatic void mm_fix_bad_ends(const mm_reg1_t *r, const mm128_t *a, int bw, int min_match, int32_t *as, int32_t *cnt)\n{\n\tint32_t i, l, m;\n\t*as = r->as, *cnt = r->cnt;\n\tif (r->cnt < 3) return;\n\tm = l = a[r->as].y >> 32 & 0xff;\n\tfor (i = r->as + 1; i < r->as + r->cnt - 1; ++i) {\n\t\tint32_t lq, lr, min, max;\n\t\tint32_t q_span = a[i].y >> 32 & 0xff;\n\t\tif (a[i].y & MM_SEED_LONG_JOIN) break;\n\t\tlr = (int32_t)a[i].x - (int32_t)a[i-1].x;\n\t\tlq = (int32_t)a[i].y - (int32_t)a[i-1].y;\n\t\tmin = lr < lq? lr : lq;\n\t\tmax = lr > lq? lr : lq;\n\t\tif (max - min > l >> 1) *as = i;\n\t\tl += min;\n\t\tm += min < q_span? min : q_span;\n\t\tif (l >= bw << 1 || (m >= min_match && m >= bw) || m >= r->mlen >> 1) break;\n\t}\n\t*cnt = r->as + r->cnt - *as;\n\tm = l = a[r->as + r->cnt - 1].y >> 32 & 0xff;\n\tfor (i = r->as + r->cnt - 2; i > *as; --i) {\n\t\tint32_t lq, lr, min, max;\n\t\tint32_t q_span = a[i+1].y >> 32 & 0xff;\n\t\tif (a[i+1].y & MM_SEED_LONG_JOIN) break;\n\t\tlr = (int32_t)a[i+1].x - (int32_t)a[i].x;\n\t\tlq = (int32_t)a[i+1].y - (int32_t)a[i].y;\n\t\tmin = lr < lq? lr : lq;\n\t\tmax = lr > lq? lr : lq;\n\t\tif (max - min > l >> 1) *cnt = i + 1 - *as;\n\t\tl += min;\n\t\tm += min < q_span? min : q_span;\n\t\tif (l >= bw << 1 || (m >= min_match && m >= bw) || m >= r->mlen >> 1) break;\n\t}\n}\n\nstatic void mm_max_stretch(const mm_reg1_t *r, const mm128_t *a, int32_t *as, int32_t *cnt)\n{\n\tint32_t i, score, max_score, len, max_i, max_len;\n\n\t*as = r->as, *cnt = r->cnt;\n\tif (r->cnt < 2) return;\n\n\tmax_score = -1, max_i = -1, max_len = 0;\n\tscore = a[r->as].y >> 32 & 0xff, len = 1;\n\tfor (i = r->as + 1; i < r->as + r->cnt; ++i) {\n\t\tint32_t lq, lr, q_span;\n\t\tq_span = a[i].y >> 32 & 0xff;\n\t\tlr = (int32_t)a[i].x - (int32_t)a[i-1].x;\n\t\tlq = (int32_t)a[i].y - (int32_t)a[i-1].y;\n\t\tif (lq == lr) {\n\t\t\tscore += lq < q_span? lq : q_span;\n\t\t\t++len;\n\t\t} else {\n\t\t\tif (score > max_score)\n\t\t\t\tmax_score = score, max_len = len, max_i = i - len;\n\t\t\tscore = q_span, len = 1;\n\t\t}\n\t}\n\tif (score > max_score)\n\t\tmax_score = score, max_len = len, max_i = i - len;\n\t*as = max_i, *cnt = max_len;\n}\n\nstatic int mm_seed_ext_score(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, const int8_t mat[25], int qlen, uint8_t *qseq0[2], const mm128_t *a)\n{\n\tuint8_t *qseq, *tseq;\n\tint q_span = a->y>>32&0xff, qs, qe, rs, re, rid, score, q_off, t_off, ext_len = opt->anchor_ext_len;\n\tvoid *qp;\n\trid = a->x<<1>>33;\n\tre = (uint32_t)a->x + 1, rs = re - q_span;\n\tqe = (uint32_t)a->y + 1, qs = qe - q_span;\n\trs = rs - ext_len > 0? rs - ext_len : 0;\n\tqs = qs - ext_len > 0? qs - ext_len : 0;\n\tre = re + ext_len < (int32_t)mi->seq[rid].len? re + ext_len : mi->seq[rid].len;\n\tqe = qe + ext_len < qlen? qe + ext_len : qlen;\n\ttseq = (uint8_t*)kmalloc(km, re - rs);\n\tif (opt->flag & MM_F_QSTRAND) {\n\t\tqseq = qseq0[0] + qs;\n\t\tmm_idx_getseq2(mi, a->x>>63, rid, rs, re, tseq);\n\t} else {\n\t\tqseq = qseq0[a->x>>63] + qs;\n\t\tmm_idx_getseq(mi, rid, rs, re, tseq);\n\t}\n\tqp = ksw_ll_qinit(km, 2, qe - qs, qseq, 5, mat);\n\tscore = ksw_ll_i16(qp, re - rs, tseq, opt->q, opt->e, &q_off, &t_off);\n\tkfree(km, tseq);\n\tkfree(km, qp);\n\treturn score;\n}\n\nstatic void mm_fix_bad_ends_splice(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, const mm_reg1_t *r, const int8_t mat[25], int qlen, uint8_t *qseq0[2], const mm128_t *a, int *as1, int *cnt1)\n{ // this assumes a very crude k-mer based mode; it is not necessary to use a good model just for filtering bounary exons\n\tint score;\n\tdouble log_gap;\n\t*as1 = r->as, *cnt1 = r->cnt;\n\tif (r->cnt < 3) return;\n\tlog_gap = log((int32_t)a[r->as + 1].x - (int32_t)a[r->as].x);\n\tif ((a[r->as].y>>32&0xff) < log_gap + opt->anchor_ext_shift) {\n\t\tscore = mm_seed_ext_score(km, opt, mi, mat, qlen, qseq0, &a[r->as]);\n\t\tif ((double)score / mat[0] < log_gap + opt->anchor_ext_shift) // a more exact format is \"score < log_4(gap) + shift\"\n\t\t\t++(*as1), --(*cnt1);\n\t}\n\tlog_gap = log((int32_t)a[r->as + r->cnt - 1].x - (int32_t)a[r->as + r->cnt - 2].x);\n\tif ((a[r->as + r->cnt - 1].y>>32&0xff) < log_gap + opt->anchor_ext_shift) {\n\t\tscore = mm_seed_ext_score(km, opt, mi, mat, qlen, qseq0, &a[r->as + r->cnt - 1]);\n\t\tif ((double)score / mat[0] < log_gap + opt->anchor_ext_shift)\n\t\t\t--(*cnt1);\n\t}\n}\n\nstatic inline void mm_get_junc(const mm_idx_t *mi, int32_t ctg, int32_t st, int32_t en, int32_t rev, uint8_t *junc)\n{\n\tif (mi->spsc) mm_idx_spsc_get(mi, ctg, st, en, rev, junc);\n\telse if (mi->I) mm_idx_bed_junc(mi, ctg, st, en, junc);\n\telse memset(junc, 0, en - st);\n}\n\nstatic void mm_align1(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, uint8_t *qseq0[2], mm_reg1_t *r, mm_reg1_t *r2, int n_a, mm128_t *a, ksw_extz_t *ez, int splice_flag)\n{\n\tint is_sr = !!(opt->flag & MM_F_SR), is_splice = !!(opt->flag & MM_F_SPLICE);\n\tint32_t rid = a[r->as].x<<1>>33, rev = a[r->as].x>>63, as1, cnt1;\n\tuint8_t *tseq, *qseq, *junc;\n\tint32_t i, l, bw, bw_long, dropped = 0, ksw_flag = 0, rs0, re0, qs0, qe0;\n\tint32_t rs, re, qs, qe;\n\tint32_t rs1, qs1, re1, qe1;\n\tint8_t mat[25];\n\n\tif (is_sr) assert(!(mi->flag & MM_I_HPC)); // HPC won't work with SR because with HPC we can't easily tell if there is a gap\n\n\tr2->cnt = 0;\n\tif (r->cnt == 0) return;\n\tksw_gen_ts_mat(5, mat, opt->a, opt->b, opt->transition, opt->sc_ambi);\n\tbw = (int)(opt->bw * 1.5 + 1.);\n\tbw_long = (int)(opt->bw_long * 1.5 + 1.);\n\tif (bw_long < bw) bw_long = bw;\n\n\tif (is_sr && !(mi->flag & MM_I_HPC)) {\n\t\tmm_max_stretch(r, a, &as1, &cnt1);\n\t\trs = (int32_t)a[as1].x + 1 - (int32_t)(a[as1].y>>32&0xff);\n\t\tqs = (int32_t)a[as1].y + 1 - (int32_t)(a[as1].y>>32&0xff);\n\t\tre = (int32_t)a[as1+cnt1-1].x + 1;\n\t\tqe = (int32_t)a[as1+cnt1-1].y + 1;\n\t} else {\n\t\tif (!(opt->flag & MM_F_NO_END_FLT)) {\n\t\t\tif (is_splice)\n\t\t\t\tmm_fix_bad_ends_splice(km, opt, mi, r, mat, qlen, qseq0, a, &as1, &cnt1);\n\t\t\telse\n\t\t\t\tmm_fix_bad_ends(r, a, opt->bw, opt->min_chain_score * 2, &as1, &cnt1);\n\t\t} else as1 = r->as, cnt1 = r->cnt;\n\t\tmm_filter_bad_seeds(km, as1, cnt1, a, 10, 40, opt->max_gap>>1, 10);\n\t\tmm_filter_bad_seeds_alt(km, as1, cnt1, a, 30, opt->max_gap>>1);\n\t\tmm_adjust_minier(mi, qseq0, &a[as1], &rs, &qs);\n\t\tmm_adjust_minier(mi, qseq0, &a[as1 + cnt1 - 1], &re, &qe);\n\t}\n\tassert(cnt1 > 0);\n\n\tif (is_splice) {\n\t\tif (splice_flag & MM_F_SPLICE_FOR) ksw_flag |= rev? KSW_EZ_SPLICE_REV : KSW_EZ_SPLICE_FOR;\n\t\tif (splice_flag & MM_F_SPLICE_REV) ksw_flag |= rev? KSW_EZ_SPLICE_FOR : KSW_EZ_SPLICE_REV;\n\t\tif (opt->flag & MM_F_SPLICE_FLANK) ksw_flag |= KSW_EZ_SPLICE_FLANK;\n\t\tif (mi->spsc) ksw_flag |= KSW_EZ_SPLICE_SCORE;\n\t}\n\n\t/* Look for the start and end of regions to perform DP. This sounds easy\n\t * but is in fact tricky. Excessively small regions lead to unnecessary\n\t * clippings and lose alignable sequences. Excessively large regions\n\t * occasionally lead to large overlaps between two chains and may cause\n\t * loss of alignments in corner cases. */\n\tif (is_sr) {\n\t\tqs0 = 0, qe0 = qlen;\n\t\tl = qs;\n\t\tl += l * opt->a + opt->end_bonus > opt->q? (l * opt->a + opt->end_bonus - opt->q) / opt->e : 0;\n\t\trs0 = rs - l > 0? rs - l : 0;\n\t\tl = qlen - qe;\n\t\tl += l * opt->a + opt->end_bonus > opt->q? (l * opt->a + opt->end_bonus - opt->q) / opt->e : 0;\n\t\tre0 = re + l < (int32_t)mi->seq[rid].len? re + l : mi->seq[rid].len;\n\t} else {\n\t\t// compute rs0 and qs0\n\t\trs0 = (int32_t)a[r->as].x + 1 - (int32_t)(a[r->as].y>>32&0xff);\n\t\tqs0 = (int32_t)a[r->as].y + 1 - (int32_t)(a[r->as].y>>32&0xff);\n\t\tif (rs0 < 0) rs0 = 0; // this may happen when HPC is in use\n\t\tassert(qs0 >= 0); // this should never happen, or it is logic error\n\t\trs1 = qs1 = 0;\n\t\tfor (i = r->as - 1, l = 0; i >= 0 && a[i].x>>32 == a[r->as].x>>32; --i) { // inspect nearby seeds\n\t\t\tint32_t x = (int32_t)a[i].x + 1 - (int32_t)(a[i].y>>32&0xff);\n\t\t\tint32_t y = (int32_t)a[i].y + 1 - (int32_t)(a[i].y>>32&0xff);\n\t\t\tif (x < rs0 && y < qs0) {\n\t\t\t\tif (++l > opt->min_cnt) {\n\t\t\t\t\tl = rs0 - x > qs0 - y? rs0 - x : qs0 - y;\n\t\t\t\t\trs1 = rs0 - l, qs1 = qs0 - l;\n\t\t\t\t\tif (rs1 < 0) rs1 = 0; // not strictly necessary; better have this guard for explicit\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (qs > 0 && rs > 0) {\n\t\t\tl = qs < opt->max_gap? qs : opt->max_gap;\n\t\t\tqs1 = qs1 > qs - l? qs1 : qs - l;\n\t\t\tqs0 = qs0 < qs1? qs0 : qs1; // at least include qs0\n\t\t\tl += l * opt->a > opt->q? (l * opt->a - opt->q) / opt->e : 0;\n\t\t\tl = l < opt->max_gap? l : opt->max_gap;\n\t\t\tl = l < rs? l : rs;\n\t\t\trs1 = rs1 > rs - l? rs1 : rs - l;\n\t\t\trs0 = rs0 < rs1? rs0 : rs1;\n\t\t\trs0 = rs0 < rs? rs0 : rs;\n\t\t} else rs0 = rs, qs0 = qs;\n\t\t// compute re0 and qe0\n\t\tre0 = (int32_t)a[r->as + r->cnt - 1].x + 1;\n\t\tqe0 = (int32_t)a[r->as + r->cnt - 1].y + 1;\n\t\tre1 = mi->seq[rid].len, qe1 = qlen;\n\t\tfor (i = r->as + r->cnt, l = 0; i < n_a && a[i].x>>32 == a[r->as].x>>32; ++i) { // inspect nearby seeds\n\t\t\tint32_t x = (int32_t)a[i].x + 1;\n\t\t\tint32_t y = (int32_t)a[i].y + 1;\n\t\t\tif (x > re0 && y > qe0) {\n\t\t\t\tif (++l > opt->min_cnt) {\n\t\t\t\t\tl = x - re0 > y - qe0? x - re0 : y - qe0;\n\t\t\t\t\tre1 = re0 + l, qe1 = qe0 + l;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (qe < qlen && re < (int32_t)mi->seq[rid].len) {\n\t\t\tl = qlen - qe < opt->max_gap? qlen - qe : opt->max_gap;\n\t\t\tqe1 = qe1 < qe + l? qe1 : qe + l;\n\t\t\tqe0 = qe0 > qe1? qe0 : qe1; // at least include qe0\n\t\t\tl += l * opt->a > opt->q? (l * opt->a - opt->q) / opt->e : 0;\n\t\t\tl = l < opt->max_gap? l : opt->max_gap;\n\t\t\tl = l < (int32_t)mi->seq[rid].len - re? l : mi->seq[rid].len - re;\n\t\t\tre1 = re1 < re + l? re1 : re + l;\n\t\t\tre0 = re0 > re1? re0 : re1;\n\t\t} else re0 = re, qe0 = qe;\n\t}\n\tif (a[r->as].y & MM_SEED_SELF) {\n\t\tint max_ext = r->qs > r->rs? r->qs - r->rs : r->rs - r->qs;\n\t\tif (r->rs - rs0 > max_ext) rs0 = r->rs - max_ext;\n\t\tif (r->qs - qs0 > max_ext) qs0 = r->qs - max_ext;\n\t\tmax_ext = r->qe > r->re? r->qe - r->re : r->re - r->qe;\n\t\tif (re0 - r->re > max_ext) re0 = r->re + max_ext;\n\t\tif (qe0 - r->qe > max_ext) qe0 = r->qe + max_ext;\n\t}\n\n\tassert(re0 > rs0);\n\ttseq = (uint8_t*)kmalloc(km, re0 - rs0);\n\tjunc = (uint8_t*)kmalloc(km, re0 - rs0);\n\n\tif (qs > 0 && rs > 0) { // left extension; probably the condition can be changed to \"qs > qs0 && rs > rs0\"\n\t\tif (opt->flag & MM_F_QSTRAND) {\n\t\t\tqseq = &qseq0[0][qs0];\n\t\t\tmm_idx_getseq2(mi, rev, rid, rs0, rs, tseq);\n\t\t} else {\n\t\t\tqseq = &qseq0[rev][qs0];\n\t\t\tmm_idx_getseq(mi, rid, rs0, rs, tseq);\n\t\t}\n\t\tmm_get_junc(mi, rid, rs0, rs, !!(ksw_flag&KSW_EZ_SPLICE_REV), junc);\n\t\tmm_seq_rev(qs - qs0, qseq);\n\t\tmm_seq_rev(rs - rs0, tseq);\n\t\tmm_seq_rev(rs - rs0, junc);\n\t\tmm_align_pair(km, opt, qs - qs0, qseq, rs - rs0, tseq, junc, mat, bw, opt->end_bonus, r->split_inv? opt->zdrop_inv : opt->zdrop, ksw_flag|KSW_EZ_EXTZ_ONLY|KSW_EZ_RIGHT|KSW_EZ_REV_CIGAR, ez);\n\t\tif (ez->n_cigar > 0) {\n\t\t\tmm_append_cigar(r, ez->n_cigar, ez->cigar);\n\t\t\tr->p->dp_score += ez->max;\n\t\t}\n\t\trs1 = rs - (ez->reach_end? ez->mqe_t + 1 : ez->max_t + 1);\n\t\tqs1 = qs - (ez->reach_end? qs - qs0 : ez->max_q + 1);\n\t\tmm_seq_rev(qs - qs0, qseq);\n\t} else rs1 = rs, qs1 = qs;\n\tre1 = rs, qe1 = qs;\n\tassert(qs1 >= 0 && rs1 >= 0);\n\n\tfor (i = is_sr? cnt1 - 1 : 1; i < cnt1; ++i) { // gap filling\n\t\tif ((a[as1+i].y & (MM_SEED_IGNORE|MM_SEED_TANDEM)) && i != cnt1 - 1) continue;\n\t\tif (is_sr && !(mi->flag & MM_I_HPC)) {\n\t\t\tre = (int32_t)a[as1 + i].x + 1;\n\t\t\tqe = (int32_t)a[as1 + i].y + 1;\n\t\t} else mm_adjust_minier(mi, qseq0, &a[as1 + i], &re, &qe);\n\t\tre1 = re, qe1 = qe;\n\t\tif (i == cnt1 - 1 || (a[as1+i].y&MM_SEED_LONG_JOIN) || (qe - qs >= opt->min_ksw_len && re - rs >= opt->min_ksw_len)) {\n\t\t\tint j, bw1 = bw_long, zdrop_code;\n\t\t\tif (a[as1+i].y & MM_SEED_LONG_JOIN)\n\t\t\t\tbw1 = qe - qs > re - rs? qe - qs : re - rs;\n\t\t\t// perform alignment\n\t\t\tif (opt->flag & MM_F_QSTRAND) {\n\t\t\t\tqseq = &qseq0[0][qs];\n\t\t\t\tmm_idx_getseq2(mi, rev, rid, rs, re, tseq);\n\t\t\t} else {\n\t\t\t\tqseq = &qseq0[rev][qs];\n\t\t\t\tmm_idx_getseq(mi, rid, rs, re, tseq);\n\t\t\t}\n\t\t\tmm_get_junc(mi, rid, rs, re, !!(ksw_flag&KSW_EZ_SPLICE_REV), junc);\n\t\t\tif (is_sr) { // perform ungapped alignment\n\t\t\t\tassert(qe - qs == re - rs);\n\t\t\t\tksw_reset_extz(ez);\n\t\t\t\tfor (j = 0, ez->score = 0; j < qe - qs; ++j) {\n\t\t\t\t\tif (qseq[j] >= 4 || tseq[j] >= 4) ez->score += opt->e2;\n\t\t\t\t\telse ez->score += qseq[j] == tseq[j]? opt->a : -opt->b;\n\t\t\t\t}\n\t\t\t\tez->cigar = ksw_push_cigar(km, &ez->n_cigar, &ez->m_cigar, ez->cigar, MM_CIGAR_MATCH, qe - qs);\n\t\t\t} else { // perform normal gapped alignment\n\t\t\t\tmm_align_pair(km, opt, qe - qs, qseq, re - rs, tseq, junc, mat, bw1, -1, opt->zdrop, ksw_flag|KSW_EZ_APPROX_MAX, ez); // first pass: with approximate Z-drop\n\t\t\t}\n\t\t\t// test Z-drop and inversion Z-drop\n\t\t\tif ((zdrop_code = mm_test_zdrop(km, opt, qseq, tseq, ez->n_cigar, ez->cigar, mat)) != 0)\n\t\t\t\tmm_align_pair(km, opt, qe - qs, qseq, re - rs, tseq, junc, mat, bw1, -1, zdrop_code == 2? opt->zdrop_inv : opt->zdrop, ksw_flag, ez); // second pass: lift approximate\n\t\t\t// update CIGAR\n\t\t\tif (ez->n_cigar > 0)\n\t\t\t\tmm_append_cigar(r, ez->n_cigar, ez->cigar);\n\t\t\tif (ez->zdropped) { // truncated by Z-drop; TODO: sometimes Z-drop kicks in because the next seed placement is wrong. This can be fixed in principle.\n\t\t\t\tif (!r->p) {\n\t\t\t\t\tassert(ez->n_cigar == 0);\n\t\t\t\t\tuint32_t capacity = sizeof(mm_extra_t)/4;\n\t\t\t\t\tkroundup32(capacity);\n\t\t\t\t\tr->p = (mm_extra_t*)calloc(capacity, 4);\n\t\t\t\t\tr->p->capacity = capacity;\n\t\t\t\t}\n\t\t\t\tfor (j = i - 1; j >= 0; --j)\n\t\t\t\t\tif ((int32_t)a[as1 + j].x <= rs + ez->max_t)\n\t\t\t\t\t\tbreak;\n\t\t\t\tdropped = 1;\n\t\t\t\tif (j < 0) j = 0;\n\t\t\t\tr->p->dp_score += ez->max;\n\t\t\t\tre1 = rs + (ez->max_t + 1);\n\t\t\t\tqe1 = qs + (ez->max_q + 1);\n\t\t\t\tif (cnt1 - (j + 1) >= opt->min_cnt) {\n\t\t\t\t\tmm_split_reg(r, r2, as1 + j + 1 - r->as, qlen, a, !!(opt->flag&MM_F_QSTRAND));\n\t\t\t\t\tif (zdrop_code == 2) r2->split_inv = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else r->p->dp_score += ez->score;\n\t\t\trs = re, qs = qe;\n\t\t}\n\t}\n\n\tif (!dropped && qe < qe0 && re < re0) { // right extension\n\t\tif (opt->flag & MM_F_QSTRAND) {\n\t\t\tqseq = &qseq0[0][qe];\n\t\t\tmm_idx_getseq2(mi, rev, rid, re, re0, tseq);\n\t\t} else {\n\t\t\tqseq = &qseq0[rev][qe];\n\t\t\tmm_idx_getseq(mi, rid, re, re0, tseq);\n\t\t}\n\t\tmm_get_junc(mi, rid, re, re0, !!(ksw_flag&KSW_EZ_SPLICE_REV), junc);\n\t\tmm_align_pair(km, opt, qe0 - qe, qseq, re0 - re, tseq, junc, mat, bw, opt->end_bonus, opt->zdrop, ksw_flag|KSW_EZ_EXTZ_ONLY, ez);\n\t\tif (ez->n_cigar > 0) {\n\t\t\tmm_append_cigar(r, ez->n_cigar, ez->cigar);\n\t\t\tr->p->dp_score += ez->max;\n\t\t}\n\t\tre1 = re + (ez->reach_end? ez->mqe_t + 1 : ez->max_t + 1);\n\t\tqe1 = qe + (ez->reach_end? qe0 - qe : ez->max_q + 1);\n\t}\n\tassert(qe1 <= qlen);\n\n\tr->rs = rs1, r->re = re1;\n\tif (!rev || (opt->flag & MM_F_QSTRAND)) r->qs = qs1, r->qe = qe1;\n\telse r->qs = qlen - qe1, r->qe = qlen - qs1;\n\n\tassert(re1 - rs1 <= re0 - rs0);\n\tif (r->p) {\n\t\tif (opt->flag & MM_F_QSTRAND) {\n\t\t\tmm_idx_getseq2(mi, r->rev, rid, rs1, re1, tseq);\n\t\t\tqseq = &qseq0[0][qs1];\n\t\t} else {\n\t\t\tmm_idx_getseq(mi, rid, rs1, re1, tseq);\n\t\t\tqseq = &qseq0[r->rev][qs1];\n\t\t}\n\t\tmm_update_extra(r, qseq, tseq, mat, opt->q, opt->e, opt->flag & MM_F_EQX, !(opt->flag & MM_F_SR));\n\t\tif (rev && r->p->trans_strand)\n\t\t\tr->p->trans_strand ^= 3; // flip to the read strand\n\t}\n\n\tkfree(km, tseq);\n\tkfree(km, junc);\n}\n\nstatic int mm_align1_inv(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, uint8_t *qseq0[2], const mm_reg1_t *r1, const mm_reg1_t *r2, mm_reg1_t *r_inv, ksw_extz_t *ez)\n{ // NB: this doesn't work with the qstrand mode\n\tint tl, ql, score, ret = 0, q_off, t_off;\n\tuint8_t *tseq, *qseq;\n\tint8_t mat[25];\n\tvoid *qp;\n\n\tmemset(r_inv, 0, sizeof(mm_reg1_t));\n\tif (!(r1->split&1) || !(r2->split&2)) return 0;\n\tif (r1->id != r1->parent && r1->parent != MM_PARENT_TMP_PRI) return 0;\n\tif (r2->id != r2->parent && r2->parent != MM_PARENT_TMP_PRI) return 0;\n\tif (r1->rid != r2->rid || r1->rev != r2->rev) return 0;\n\tql = r1->rev? r1->qs - r2->qe : r2->qs - r1->qe;\n\ttl = r2->rs - r1->re;\n\tif (ql < opt->min_chain_score || ql > opt->max_gap) return 0;\n\tif (tl < opt->min_chain_score || tl > opt->max_gap) return 0;\n\n\tksw_gen_ts_mat(5, mat, opt->a, opt->b, opt->transition, opt->sc_ambi);\n\ttseq = (uint8_t*)kmalloc(km, tl);\n\tmm_idx_getseq(mi, r1->rid, r1->re, r2->rs, tseq);\n\tqseq = r1->rev? &qseq0[0][r2->qe] : &qseq0[1][qlen - r2->qs];\n\n\tmm_seq_rev(ql, qseq);\n\tmm_seq_rev(tl, tseq);\n\tqp = ksw_ll_qinit(km, 2, ql, qseq, 5, mat);\n\tscore = ksw_ll_i16(qp, tl, tseq, opt->q, opt->e, &q_off, &t_off);\n\tkfree(km, qp);\n\tmm_seq_rev(ql, qseq);\n\tmm_seq_rev(tl, tseq);\n\tif (score < opt->min_dp_max) goto end_align1_inv;\n\tq_off = ql - (q_off + 1), t_off = tl - (t_off + 1);\n\tmm_align_pair(km, opt, ql - q_off, qseq + q_off, tl - t_off, tseq + t_off, 0, mat, (int)(opt->bw * 1.5), -1, opt->zdrop, KSW_EZ_EXTZ_ONLY, ez);\n\tif (ez->n_cigar == 0) goto end_align1_inv; // should never be here\n\tmm_append_cigar(r_inv, ez->n_cigar, ez->cigar);\n\tr_inv->p->dp_score = ez->max;\n\tr_inv->id = -1;\n\tr_inv->parent = MM_PARENT_UNSET;\n\tr_inv->inv = 1;\n\tr_inv->rev = !r1->rev;\n\tr_inv->rid = r1->rid;\n\tr_inv->div = -1.0f;\n\tif (r_inv->rev == 0) {\n\t\tr_inv->qs = r2->qe + q_off;\n\t\tr_inv->qe = r_inv->qs + ez->max_q + 1;\n\t} else {\n\t\tr_inv->qe = r2->qs - q_off;\n\t\tr_inv->qs = r_inv->qe - (ez->max_q + 1);\n\t}\n\tr_inv->rs = r1->re + t_off;\n\tr_inv->re = r_inv->rs + ez->max_t + 1;\n\tmm_update_extra(r_inv, &qseq[q_off], &tseq[t_off], mat, opt->q, opt->e, opt->flag & MM_F_EQX, !(opt->flag & MM_F_SR));\n\tret = 1;\nend_align1_inv:\n\tkfree(km, tseq);\n\treturn ret;\n}\n\nstatic inline mm_reg1_t *mm_insert_reg(const mm_reg1_t *r, int i, int *n_regs, mm_reg1_t *regs)\n{\n\tregs = (mm_reg1_t*)realloc(regs, (*n_regs + 1) * sizeof(mm_reg1_t));\n\tif (i + 1 != *n_regs)\n\t\tmemmove(&regs[i + 2], &regs[i + 1], sizeof(mm_reg1_t) * (*n_regs - i - 1));\n\tregs[i + 1] = *r;\n\t++*n_regs;\n\treturn regs;\n}\n\nstatic inline void mm_count_gaps(const mm_reg1_t *r, int32_t *n_gap_, int32_t *n_gapo_)\n{\n\tuint32_t i;\n\tint32_t n_gapo = 0, n_gap = 0;\n\t*n_gap_ = *n_gapo_ = -1;\n\tif (r->p == 0) return;\n\tfor (i = 0; i < r->p->n_cigar; ++i) {\n\t\tint32_t op = r->p->cigar[i] & 0xf, len = r->p->cigar[i] >> 4;\n\t\tif (op == MM_CIGAR_INS || op == MM_CIGAR_DEL)\n\t\t\t++n_gapo, n_gap += len;\n\t}\n\t*n_gap_ = n_gap, *n_gapo_ = n_gapo;\n}\n\ndouble mm_event_identity(const mm_reg1_t *r)\n{\n\tint32_t n_gap, n_gapo;\n\tif (r->p == 0) return -1.0f;\n\tmm_count_gaps(r, &n_gap, &n_gapo);\n\treturn (double)r->mlen / (r->blen + r->p->n_ambi - n_gap + n_gapo);\n}\n\nstatic int32_t mm_recal_max_dp(const mm_reg1_t *r, double b2, int32_t match_sc)\n{\n\tuint32_t i;\n\tint32_t n_gap = 0, n_mis;\n\tdouble gap_cost = 0.0;\n\tif (r->p == 0) return -1;\n\tfor (i = 0; i < r->p->n_cigar; ++i) {\n\t\tint32_t op = r->p->cigar[i] & 0xf, len = r->p->cigar[i] >> 4;\n\t\tif (op == MM_CIGAR_INS || op == MM_CIGAR_DEL) {\n\t\t\tgap_cost += b2 + (double)mg_log2(1.0 + len);\n\t\t\tn_gap += len;\n\t\t}\n\t}\n\tn_mis = r->blen + r->p->n_ambi - r->mlen - n_gap;\n\treturn (int32_t)(match_sc * (r->mlen - b2 * n_mis - gap_cost) + .499);\n}\n\nvoid mm_update_dp_max(int qlen, int n_regs, mm_reg1_t *regs, float frac, int a, int b)\n{\n\tint32_t max = -1, max2 = -1, i, max_i = -1;\n\tdouble div, b2;\n\tif (n_regs < 2) return;\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tif (r->p == 0) continue;\n\t\tif (r->p->dp_max > max) max2 = max, max = r->p->dp_max, max_i = i;\n\t\telse if (r->p->dp_max > max2) max2 = r->p->dp_max;\n\t}\n\tif (max_i < 0 || max < 0 || max2 < 0) return;\n\tif (regs[max_i].qe - regs[max_i].qs < (double)qlen * frac) return;\n\tif (max2 < (double)max * frac) return;\n\tdiv = 1. - mm_event_identity(&regs[max_i]);\n\tif (div < 0.02) div = 0.02;\n\tb2 = 0.5 / div; // max value: 25\n\tif (b2 * a < b) b2 = (double)a / b;\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tif (r->p == 0) continue;\n\t\tr->p->dp_max = mm_recal_max_dp(r, b2, a);\n\t\tif (r->p->dp_max < 0) r->p->dp_max = 0;\n\t}\n}\n\nmm_reg1_t *mm_align_skeleton(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, const char *qstr, int *n_regs_, mm_reg1_t *regs, mm128_t *a)\n{\n\textern unsigned char seq_nt4_table[256];\n\tint32_t i, n_regs = *n_regs_, n_a;\n\tuint8_t *qseq0[2];\n\tksw_extz_t ez;\n\n\t// encode the query sequence\n\tqseq0[0] = (uint8_t*)kmalloc(km, qlen * 2);\n\tqseq0[1] = qseq0[0] + qlen;\n\tfor (i = 0; i < qlen; ++i) {\n\t\tqseq0[0][i] = seq_nt4_table[(uint8_t)qstr[i]];\n\t\tqseq0[1][qlen - 1 - i] = qseq0[0][i] < 4? 3 - qseq0[0][i] : 4;\n\t}\n\n\t// align through seed hits\n\tn_a = mm_squeeze_a(km, n_regs, regs, a);\n\tmemset(&ez, 0, sizeof(ksw_extz_t));\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t r2;\n\t\tif ((opt->flag&MM_F_SPLICE) && (opt->flag&MM_F_SPLICE_FOR) && (opt->flag&MM_F_SPLICE_REV)) { // then do two rounds of alignments for both strands\n\t\t\tmm_reg1_t s[2], s2[2];\n\t\t\tint which, trans_strand;\n\t\t\ts[0] = s[1] = regs[i];\n\t\t\tmm_align1(km, opt, mi, qlen, qseq0, &s[0], &s2[0], n_a, a, &ez, MM_F_SPLICE_FOR);\n\t\t\tmm_align1(km, opt, mi, qlen, qseq0, &s[1], &s2[1], n_a, a, &ez, MM_F_SPLICE_REV);\n\t\t\tif (s[0].p->dp_score > s[1].p->dp_score) which = 0, trans_strand = 1;\n\t\t\telse if (s[0].p->dp_score < s[1].p->dp_score) which = 1, trans_strand = 2;\n\t\t\telse trans_strand = 3, which = (qlen + s[0].p->dp_score) & 1; // randomly choose a strand, effectively\n\t\t\tif (which == 0) {\n\t\t\t\tregs[i] = s[0], r2 = s2[0];\n\t\t\t\tfree(s[1].p);\n\t\t\t} else {\n\t\t\t\tregs[i] = s[1], r2 = s2[1];\n\t\t\t\tfree(s[0].p);\n\t\t\t}\n\t\t\tregs[i].p->trans_strand = trans_strand;\n\t\t} else { // one round of alignment\n\t\t\tmm_align1(km, opt, mi, qlen, qseq0, &regs[i], &r2, n_a, a, &ez, opt->flag);\n\t\t\tif (opt->flag&MM_F_SPLICE)\n\t\t\t\tregs[i].p->trans_strand = opt->flag&MM_F_SPLICE_FOR? 1 : 2;\n\t\t}\n\t\tif (r2.cnt > 0) regs = mm_insert_reg(&r2, i, &n_regs, regs);\n\t\tif (i > 0 && regs[i].split_inv && !(opt->flag & MM_F_NO_INV)) {\n\t\t\tif (mm_align1_inv(km, opt, mi, qlen, qseq0, &regs[i-1], &regs[i], &r2, &ez)) {\n\t\t\t\tregs = mm_insert_reg(&r2, i, &n_regs, regs);\n\t\t\t\t++i; // skip the inserted INV alignment\n\t\t\t}\n\t\t}\n\t}\n\t*n_regs_ = n_regs;\n\tkfree(km, qseq0[0]);\n\tkfree(km, ez.cigar);\n\tmm_filter_regs(opt, qlen, n_regs_, regs);\n\tif (!(opt->flag&MM_F_SR) && !opt->split_prefix && qlen >= opt->rank_min_len) {\n\t\tmm_update_dp_max(qlen, *n_regs_, regs, opt->rank_frac, opt->a, opt->b);\n\t\tmm_filter_regs(opt, qlen, n_regs_, regs);\n\t}\n\tmm_hit_sort(km, n_regs_, regs, opt->alt_drop);\n\treturn regs;\n}\n"
        },
        {
          "name": "bseq.c",
          "type": "blob",
          "size": 5.2373046875,
          "content": "#include <zlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#define __STDC_LIMIT_MACROS\n#include \"bseq.h\"\n#include \"kvec.h\"\n#include \"kseq.h\"\nKSEQ_INIT2(, gzFile, gzread)\n\nunsigned char seq_comp_table[256] = {\n\t  0,   1,\t2,\t 3,\t  4,   5,\t6,\t 7,\t  8,   9,  10,\t11,\t 12,  13,  14,\t15,\n\t 16,  17,  18,\t19,\t 20,  21,  22,\t23,\t 24,  25,  26,\t27,\t 28,  29,  30,\t31,\n\t 32,  33,  34,\t35,\t 36,  37,  38,\t39,\t 40,  41,  42,\t43,\t 44,  45,  46,\t47,\n\t 48,  49,  50,\t51,\t 52,  53,  54,\t55,\t 56,  57,  58,\t59,\t 60,  61,  62,\t63,\n\t 64, 'T', 'V', 'G', 'H', 'E', 'F', 'C', 'D', 'I', 'J', 'M', 'L', 'K', 'N', 'O',\n\t'P', 'Q', 'Y', 'S', 'A', 'A', 'B', 'W', 'X', 'R', 'Z',\t91,\t 92,  93,  94,\t95,\n\t 96, 't', 'v', 'g', 'h', 'e', 'f', 'c', 'd', 'i', 'j', 'm', 'l', 'k', 'n', 'o',\n\t'p', 'q', 'y', 's', 'a', 'a', 'b', 'w', 'x', 'r', 'z', 123, 124, 125, 126, 127,\n\t128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n\t144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n\t160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n\t176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\n\t192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\n\t208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n\t224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n\t240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n};\n\n#define CHECK_PAIR_THRES 1000000\n\nstruct mm_bseq_file_s {\n\tgzFile fp;\n\tkseq_t *ks;\n\tmm_bseq1_t s;\n};\n\nmm_bseq_file_t *mm_bseq_open(const char *fn)\n{\n\tmm_bseq_file_t *fp;\n\tgzFile f;\n\tf = fn && strcmp(fn, \"-\")? gzopen(fn, \"r\") : gzdopen(0, \"r\");\n\tif (f == 0) return 0;\n\tfp = (mm_bseq_file_t*)calloc(1, sizeof(mm_bseq_file_t));\n\tfp->fp = f;\n\tfp->ks = kseq_init(fp->fp);\n\treturn fp;\n}\n\nvoid mm_bseq_close(mm_bseq_file_t *fp)\n{\n\tkseq_destroy(fp->ks);\n\tgzclose(fp->fp);\n\tfree(fp);\n}\n\nstatic inline char *kstrdup(const kstring_t *s)\n{\n\tchar *t;\n\tt = (char*)malloc(s->l + 1);\n\tmemcpy(t, s->s, s->l + 1);\n\treturn t;\n}\n\nstatic inline void kseq2bseq(kseq_t *ks, mm_bseq1_t *s, int with_qual, int with_comment)\n{\n\tint i;\n\tif (ks->name.l == 0)\n\t\tfprintf(stderr, \"[WARNING]\\033[1;31m empty sequence name in the input.\\033[0m\\n\");\n\ts->name = kstrdup(&ks->name);\n\ts->seq = kstrdup(&ks->seq);\n\tfor (i = 0; i < (int)ks->seq.l; ++i) // convert U to T\n\t\tif (s->seq[i] == 'u' || s->seq[i] == 'U')\n\t\t\t--s->seq[i];\n\ts->qual = with_qual && ks->qual.l? kstrdup(&ks->qual) : 0;\n\ts->comment = with_comment && ks->comment.l? kstrdup(&ks->comment) : 0;\n\ts->l_seq = ks->seq.l;\n}\n\nmm_bseq1_t *mm_bseq_read3(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int with_comment, int frag_mode, int *n_)\n{\n\tint64_t size = 0;\n\tint ret;\n\tkvec_t(mm_bseq1_t) a = {0,0,0};\n\tkseq_t *ks = fp->ks;\n\t*n_ = 0;\n\tif (fp->s.seq) {\n\t\tkv_resize(mm_bseq1_t, 0, a, 256);\n\t\tkv_push(mm_bseq1_t, 0, a, fp->s);\n\t\tsize = fp->s.l_seq;\n\t\tmemset(&fp->s, 0, sizeof(mm_bseq1_t));\n\t}\n\twhile ((ret = kseq_read(ks)) >= 0) {\n\t\tmm_bseq1_t *s;\n\t\tassert(ks->seq.l <= INT32_MAX);\n\t\tif (a.m == 0) kv_resize(mm_bseq1_t, 0, a, 256);\n\t\tkv_pushp(mm_bseq1_t, 0, a, &s);\n\t\tkseq2bseq(ks, s, with_qual, with_comment);\n\t\tsize += s->l_seq;\n\t\tif (size >= chunk_size) {\n\t\t\tif (frag_mode && a.a[a.n-1].l_seq < CHECK_PAIR_THRES) {\n\t\t\t\twhile ((ret = kseq_read(ks)) >= 0) {\n\t\t\t\t\tkseq2bseq(ks, &fp->s, with_qual, with_comment);\n\t\t\t\t\tif (mm_qname_same(fp->s.name, a.a[a.n-1].name)) {\n\t\t\t\t\t\tkv_push(mm_bseq1_t, 0, a, fp->s);\n\t\t\t\t\t\tmemset(&fp->s, 0, sizeof(mm_bseq1_t));\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < -1) {\n\t\tif (a.n) fprintf(stderr, \"[WARNING]\\033[1;31m failed to parse the FASTA/FASTQ record next to '%s'. Continue anyway.\\033[0m\\n\", a.a[a.n-1].name);\n\t\telse fprintf(stderr, \"[WARNING]\\033[1;31m failed to parse the first FASTA/FASTQ record. Continue anyway.\\033[0m\\n\");\n\t}\n\t*n_ = a.n;\n\treturn a.a;\n}\n\nmm_bseq1_t *mm_bseq_read2(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int frag_mode, int *n_)\n{\n\treturn mm_bseq_read3(fp, chunk_size, with_qual, 0, frag_mode, n_);\n}\n\nmm_bseq1_t *mm_bseq_read(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int *n_)\n{\n\treturn mm_bseq_read2(fp, chunk_size, with_qual, 0, n_);\n}\n\nmm_bseq1_t *mm_bseq_read_frag2(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int with_comment, int *n_)\n{\n\tint i;\n\tint64_t size = 0;\n\tkvec_t(mm_bseq1_t) a = {0,0,0};\n\t*n_ = 0;\n\tif (n_fp < 1) return 0;\n\twhile (1) {\n\t\tint n_read = 0;\n\t\tfor (i = 0; i < n_fp; ++i)\n\t\t\tif (kseq_read(fp[i]->ks) >= 0)\n\t\t\t\t++n_read;\n\t\tif (n_read < n_fp) {\n\t\t\tif (n_read > 0)\n\t\t\t\tfprintf(stderr, \"[W::%s]\\033[1;31m query files have different number of records; extra records skipped.\\033[0m\\n\", __func__);\n\t\t\tbreak; // some file reaches the end\n\t\t}\n\t\tif (a.m == 0) kv_resize(mm_bseq1_t, 0, a, 256);\n\t\tfor (i = 0; i < n_fp; ++i) {\n\t\t\tmm_bseq1_t *s;\n\t\t\tkv_pushp(mm_bseq1_t, 0, a, &s);\n\t\t\tkseq2bseq(fp[i]->ks, s, with_qual, with_comment);\n\t\t\tsize += s->l_seq;\n\t\t}\n\t\tif (size >= chunk_size) break;\n\t}\n\t*n_ = a.n;\n\treturn a.a;\n}\n\nmm_bseq1_t *mm_bseq_read_frag(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int *n_)\n{\n\treturn mm_bseq_read_frag2(n_fp, fp, chunk_size, with_qual, 0, n_);\n}\n\nint mm_bseq_eof(mm_bseq_file_t *fp)\n{\n\treturn (ks_eof(fp->ks->f) && fp->s.seq == 0);\n}\n"
        },
        {
          "name": "bseq.h",
          "type": "blob",
          "size": 1.7685546875,
          "content": "#ifndef MM_BSEQ_H\n#define MM_BSEQ_H\n\n#include <stdint.h>\n#include <string.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct mm_bseq_file_s;\ntypedef struct mm_bseq_file_s mm_bseq_file_t;\n\ntypedef struct {\n\tint l_seq, rid;\n\tchar *name, *seq, *qual, *comment;\n} mm_bseq1_t;\n\nmm_bseq_file_t *mm_bseq_open(const char *fn);\nvoid mm_bseq_close(mm_bseq_file_t *fp);\nmm_bseq1_t *mm_bseq_read3(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int with_comment, int frag_mode, int *n_);\nmm_bseq1_t *mm_bseq_read2(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int frag_mode, int *n_);\nmm_bseq1_t *mm_bseq_read(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int *n_);\nmm_bseq1_t *mm_bseq_read_frag2(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int with_comment, int *n_);\nmm_bseq1_t *mm_bseq_read_frag(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int *n_);\nint mm_bseq_eof(mm_bseq_file_t *fp);\n\nextern unsigned char seq_nt4_table[256];\nextern unsigned char seq_comp_table[256];\n\nstatic inline int mm_qname_len(const char *s)\n{\n\tint l;\n\tl = strlen(s);\n\treturn l >= 3 && s[l-1] >= '0' && s[l-1] <= '9' && s[l-2] == '/'? l - 2 : l;\n}\n\nstatic inline int mm_qname_same(const char *s1, const char *s2)\n{\n\tint l1, l2;\n\tl1 = mm_qname_len(s1);\n\tl2 = mm_qname_len(s2);\n\treturn (l1 == l2 && strncmp(s1, s2, l1) == 0);\n}\n\nstatic inline void mm_revcomp_bseq(mm_bseq1_t *s)\n{\n\tint i, t, l = s->l_seq;\n\tfor (i = 0; i < l>>1; ++i) {\n\t\tt = s->seq[l - i - 1];\n\t\ts->seq[l - i - 1] = seq_comp_table[(uint8_t)s->seq[i]];\n\t\ts->seq[i] = seq_comp_table[t];\n\t}\n\tif (l&1) s->seq[l>>1] = seq_comp_table[(uint8_t)s->seq[l>>1]];\n\tif (s->qual)\n\t\tfor (i = 0; i < l>>1; ++i)\n\t\t\tt = s->qual[l - i - 1], s->qual[l - i - 1] = s->qual[i], s->qual[i] = t;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "code_of_conduct.md",
          "type": "blob",
          "size": 1.353515625,
          "content": "## Contributor Code of Conduct\n\nAs contributors and maintainers of this project, we pledge to respect all\npeople who contribute through reporting issues, posting feature requests,\nupdating documentation, submitting pull requests or patches, and other\nactivities.\n\nWe are committed to making participation in this project a harassment-free\nexperience for everyone, regardless of level of experience, gender, gender\nidentity and expression, sexual orientation, disability, personal appearance,\nbody size, race, age, or religion.\n\nExamples of unacceptable behavior by participants include the use of sexual\nlanguage or imagery, derogatory comments or personal attacks, trolling, public\nor private harassment, insults, or other unprofessional conduct.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct. Project maintainers or\ncontributors who do not follow the Code of Conduct may be removed from the\nproject team.\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by opening an issue or contacting the maintainer via email.\n\nThis Code of Conduct is adapted from the [Contributor Covenant][cc], [version\n1.0.0][v1].\n\n[cc]: http://contributor-covenant.org/\n[v1]: http://contributor-covenant.org/version/1/0/0/\n"
        },
        {
          "name": "cookbook.md",
          "type": "blob",
          "size": 10.2119140625,
          "content": "## Table of Contents\n\n- [Introduction & Installation](#intro)\n- [Mapping Genomic Reads](#map-reads)\n  * [Mapping long reads](#map-pb)\n  * [Mapping Illumina paired-end reads](#map-sr)\n  * [Evaluating mapping accuracy with simulated reads (for developers)](#mapeval)\n- [Mapping Long RNA-seq Reads](#map-rna)\n  * [Mapping Nanopore 2D cDNA reads](#map-ont-cdna-2d)\n  * [Mapping Nanopore direct-RNA reads](#map-direct-rna)\n  * [Mapping PacBio Iso-seq reads](#map-iso-seq)\n- [Full-Genome Alignment](#genome-aln)\n  * [Intra-species assembly alignment](#asm-to-ref)\n  * [Cross-species full-genome alignment](#x-species)\n  * [Eyeballing alignment](#view-aln)\n  * [Calling variants from assembly-to-reference alignment](#asm-var)\n  * [Constructing self-homology map](#hom-map)\n  * [Lift Over (for developers)](#liftover)\n- [Read Overlap](#read-overlap)\n  * [Long-read overlap](#long-read-overlap)\n  * [Evaluating overlap sensitivity (for developers)](#ov-eval)\n\n## <a name=\"intro\"></a>Introduction & Installation\n\nThis cookbook walks you through a variety of applications of minimap2 and its\ncompanion script `paftools.js`. All data here are freely available from the\nminimap2 release page at version tag [v2.10][v2.10]. Some examples only work\nwith v2.10 or later.\n\nTo acquire the data used in this cookbook and to install minimap2 and paftools,\nplease follow the command lines below:\n```sh\n# install minimap2 executables\ncurl -L https://github.com/lh3/minimap2/releases/download/v2.28/minimap2-2.28_x64-linux.tar.bz2 | tar jxf -\ncp minimap2-2.28_x64-linux/{minimap2,k8,paftools.js} .  # copy executables\nexport PATH=\"$PATH:\"`pwd`                               # put the current directory on PATH\n# download example datasets\ncurl -L https://github.com/lh3/minimap2/releases/download/v2.10/cookbook-data.tgz | tar zxf -\n```\n\n## <a name=\"map-reads\"></a>Mapping Genomic Reads\n\n### <a name=\"map-pb\"></a>Mapping long reads\n```sh\nminimap2 -ax map-pb -t4 ecoli_ref.fa ecoli_p6_25x_canu.fa > mapped.sam\n```\nAlternatively, you can create a minimap2 index first and then map:\n```sh\nminimap2 -x map-pb -d ecoli-pb.mmi ecoli_ref.fa                      # create an index\nminimap2 -ax map-pb ecoli-pb.mmi ecoli_p6_25x_canu.fa > mapped.sam\n```\nThis will save you a couple of minutes when you map against the human genome.\n**HOWEVER**, key algorithm parameters such as the k-mer length and window\nsize can't be changed after indexing. Minimap2 will give you a warning if\nparameters used in a pre-built index doesn't match parameters on the command\nline. **Please always make sure you are using an intended pre-built index.**\n\n### <a name=\"map-sr\"></a>Mapping Illumina paired-end reads:\n```sh\nminimap2 -ax sr -t4 ecoli_ref.fa ecoli_mason_1.fq ecoli_mason_2.fq > mapped-sr.sam\n```\n\n### <a name=\"mapeval\"></a>Evaluating mapping accuracy with simulated reads (for developers)\n```sh\nminimap2 -ax sr ecoli_ref.fa ecoli_mason_1.fq ecoli_mason_2.fq | paftools.js mapeval -\n```\nThe output is:\n```\nQ       60      19712   0       0.000000000     19712\nQ       0       282     219     0.010953286     19994\nU       6\n```\nwhere a `U`-line gives the number of unmapped reads (for SAM input only); a\n`Q`-line gives:\n\n1. Mapping quality (mapQ) threshold\n2. Number of mapped reads between this threshold and the previous mapQ threshold.\n3. Number of wrong mappings in the same mapQ interval\n4. Accumulative mapping error rate\n5. Accumulative number of mappings\n\nFor `paftools.js mapeval` to work, you need to encode the true read positions\nin read names in the right format. For [pbsim2][pbsim] and [mason2][mason2], we\nprovide scripts to generate the right format. Simulated reads in this cookbook\nwere created with the following command lines:\n```sh\n# in the pbsim2 source code directory:\nsrc/pbsim --depth 1 --length-min 5000 --length-mean 20000 --accuracy-mean 0.95 --hmm_model data/R94.model ../ecoli_ref.fa\npaftools.js pbsim2fq ../ecoli_ref.fa.fai sd_0001.maf > ../ecoli_pbsim.fa\n\n# mason2 simulation\nmason_simulator --illumina-prob-mismatch-scale 2.5 -ir ecoli_ref.fa -n 10000 -o tmp-l.fq -or tmp-r.fq -oa tmp.sam\npaftools.js mason2fq tmp.sam | seqtk seq -1 > ecoli_mason_1.fq\npaftools.js mason2fq tmp.sam | seqtk seq -2 > ecoli_mason_2.fq\n```\n\n\n\n## <a name=\"map-rna\"></a>Mapping Long RNA-seq Reads\n\n### <a name=\"map-ont-cdna-2d\"></a>Mapping Nanopore 2D cDNA reads\n```sh\nminimap2 -ax splice SIRV_E2.fa SIRV_ont-cdna.fa > aln.sam\n```\nYou can compare the alignment to the true annotations with:\n```sh\npaftools.js junceval SIRV_E2C.gtf aln.sam\n```\nIt gives the percentage of introns found in the annotation. For SIRV data, it\nis possible to achieve higher junction accuracy with\n```sh\nminimap2 -ax splice --splice-flank=no SIRV_E2.fa SIRV_ont-cdna.fa | paftools.js junceval SIRV_E2C.gtf\n```\nThis is because minimap2 models one additional evolutionarily conserved base\naround a canonical junction, but SIRV doesn't honor this signal. Option\n`--splice-flank=no` asks minimap2 no to model this additional base.\n\nIn the output a tag `ts:A:+` indicates that the read strand is the same as the\ntranscript strand; `ts:A:-` indicates the read strand is opposite to the\ntranscript strand. This tag is inferred from the GT-AG signal and is thus only\navailable to spliced reads.\n\n### <a name=\"map-direct-rna\"></a>Mapping Nanopore direct-RNA reads\n```sh\nminimap2 -ax splice -k14 -uf SIRV_E2.fa SIRV_ont-drna.fa > aln.sam\n```\nDirect-RNA reads are noisier, so we use a shorter k-mer for improved\nsensitivity. Here, option `-uf` forces minimap2 to map reads to the forward\ntranscript strand only because direct-RNA reads are stranded. Again, applying\n`--splice-flank=no` helps junction accuracy for SIRV data.\n\n### <a name=\"map-iso-seq\"></a>Mapping PacBio Iso-seq reads\n```sh\nminimap2 -ax splice -uf -C5 SIRV_E2.fa SIRV_iso-seq.fq > aln.sam\n```\nOption `-C5` reduces the penalty on non-canonical splicing sites. It helps\nto align such sites correctly for data with low error rate such as Iso-seq\nreads and traditional cDNAs. On this example, minimap2 makes one junction\nerror. Applying `--splice-flank=no` fixes this alignment error.\n\nNote that the command line above is optimized for the final Iso-seq reads.\nPacBio's Iso-seq pipeline produces intermediate sequences at varying quality.\nFor example, some intermediate reads are not stranded. For these reads, option\n`-uf` will lead to more errors. Please revise the minimap2 command line\naccordingly.\n\n\n\n## <a name=\"genome-aln\"></a>Full-Genome Alignment\n\n### <a name=\"asm-to-ref\"></a>Intra-species assembly alignment\n```sh\n# option \"--cs\" is recommended as paftools.js may need it\nminimap2 -cx asm5 --cs ecoli_ref.fa ecoli_canu.fa > ecoli_canu.paf\n```\nHere `ecoli_canu.fa` is the Canu assembly of `ecoli_p6_25x_canu.fa`. This\ncommand line outputs alignments in the [PAF format][paf]. Use `-a` instead of\n`-c` to get output in the SAM format.\n\n### <a name=\"x-species\"></a>Cross-species full-genome alignment\n```sh\nminimap2 -cx asm20 --cs ecoli_ref.fa ecoli_O104:H4.fa > ecoli_O104:H4.paf\nsort -k6,6 -k8,8n ecoli_O104:H4.paf | paftools.js call -f ecoli_ref.fa -L10000 -l1000 - > out.vcf\n```\nMinimap2 has three presets for full-genome alignment: \"asm5\" for sequence\ndivergence below 1%, \"asm10\" for divergence around a couple of percent and\n\"asm20\" for divergence not more than 10%. In theory, with the right setting,\nminimap2 should work for sequence pairs with sequence divergence up to ~15%,\nbut this has not been carefully evaluated.\n\n### <a name=\"view-aln\"></a>Eyeballing alignment\n```sh\n# option \"--cs\" required; minimap2-r741 or higher required for the \"asm20\" preset\nminimap2 -cx asm20 --cs ecoli_ref.fa ecoli_O104:H4.fa | paftools.js view - | less -S\n```\nThis prints the alignment in a BLAST-like format.\n\n### <a name=\"asm-var\"></a>Calling variants from assembly-to-reference alignment\n```sh\n# don't forget the \"--cs\" option; otherwise it doesn't work\nminimap2 -cx asm5 --cs ecoli_ref.fa ecoli_canu.fa \\\n  | sort -k6,6 -k8,8n \\\n  | paftools.js call -f ecoli_ref.fa - > out.vcf\n```\nWithout option `-f`, `paftools.js call` outputs in a custom format. In this\nformat, lines starting with `R` give the regions covered by one contig only.\nThis information is not available in the VCF output.\n\n### <a name=\"hom-map\"></a>Constructing self-homology map\n```sh\nminimap2 -DP -k19 -w19 -m200 ecoli_ref.fa ecoli_ref.fa > out.paf\n```\nOption `-D` asks minimap2 to ignore anchors from perfect self match and `-P`\noutputs all chains. For large nomes, we don't recommend to perform base-level\nalignment (with `-c`, `-a` or `--cs`) when `-P` is applied. This is because\nbase-alignment is slow and occasionally gives wrong alignments close to the\ndiagonal of a dotter plot. For E. coli, though, base-alignment is still fast.\n\n### <a name=\"liftover\"></a>Lift over (for developers)\n```sh\nminimap2 -cx asm5 --cs ecoli_ref.fa ecoli_canu.fa > ecoli_canu.paf\necho -e 'tig00000001\\t200000\\t300000' | paftools.js liftover ecoli_canu.paf -\n```\nThis lifts over a region on query sequences to one or multiple regions on\nreference sequences. Note that this paftools.js command may not be efficient\nenough to lift millions of regions.\n\n\n\n## <a name=\"read-overlap\"></a>Read Overlap\n\n### <a name=\"long-read-overlap\"></a>Long read overlap\n```sh\n# For pacbio reads:\nminimap2 -x ava-pb ecoli_p6_25x_canu.fa ecoli_p6_25x_canu.fa > overlap.paf\n# For Nanopore reads (ava-ont also works with PacBio but not as good):\nminimap2 -x ava-ont -r 10000 ecoli_p6_25x_canu.fa ecoli_p6_25x_canu.fa > overlap.paf\n# If you have miniasm installed:\nminiasm -f ecoli_p6_25x_canu.fa overlap.paf > asm.gfa\n```\nHere we explicitly applied `-r 10000`. We are considering to set this as the\ndefault for the `ava-ont` mode as this seems to improve the contiguity for\nnanopore read assembly (Loman, personal communication).\n\n*Minimap2 doesn't work well with short-read overlap.*\n\n### <a name=\"ov-eval\"></a>Evaluating overlap sensitivity (for developers)\n\n```sh\n# read to reference mapping\nminimap2 -cx map-pb ecoli_ref.fa ecoli_p6_25x_canu.fa > to-ref.paf\n# evaluate overlap sensitivity\nsort -k6,6 -k8,8n to-ref.paf | paftools.js ov-eval - overlap.paf\n```\nYou can see that for PacBio reads, minimap2 achieves higher overlap sensitivity\nwith `-x ava-pb` (99% vs 93% with `-x ava-ont`).\n\n\n\n[pbsim]: https://github.com/yukiteruono/pbsim2\n[mason2]: https://github.com/seqan/seqan/tree/master/apps/mason2\n[paf]: https://github.com/lh3/miniasm/blob/master/PAF.md\n[v2.10]: https://github.com/lh3/minimap2/releases/tag/v2.10\n"
        },
        {
          "name": "esterr.c",
          "type": "blob",
          "size": 1.8271484375,
          "content": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"mmpriv.h\"\n\nstatic inline int32_t get_for_qpos(int32_t qlen, const mm128_t *a)\n{\n\tint32_t x = (int32_t)a->y;\n\tint32_t q_span = a->y>>32 & 0xff;\n\tif (a->x>>63)\n\t\tx = qlen - 1 - (x + 1 - q_span); // revert the position to the forward strand of query\n\treturn x;\n}\n\nstatic int get_mini_idx(int qlen, const mm128_t *a, int32_t n, const uint64_t *mini_pos)\n{\n\tint32_t x, L = 0, R = n - 1;\n\tx = get_for_qpos(qlen, a);\n\twhile (L <= R) { // binary search\n\t\tint32_t m = ((uint64_t)L + R) >> 1;\n\t\tint32_t y = (int32_t)mini_pos[m];\n\t\tif (y < x) L = m + 1;\n\t\telse if (y > x) R = m - 1;\n\t\telse return m;\n\t}\n\treturn -1;\n}\n\nvoid mm_est_err(const mm_idx_t *mi, int qlen, int n_regs, mm_reg1_t *regs, const mm128_t *a, int32_t n, const uint64_t *mini_pos)\n{\n\tint i;\n\tuint64_t sum_k = 0;\n\tfloat avg_k;\n\n\tif (n == 0) return;\n\tfor (i = 0; i < n; ++i)\n\t\tsum_k += mini_pos[i] >> 32 & 0xff;\n\tavg_k = (float)sum_k / n;\n\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tint32_t st, en, j, k, n_match, n_tot, l_ref;\n\t\tr->div = -1.0f;\n\t\tif (r->cnt == 0) continue;\n\t\tst = en = get_mini_idx(qlen, r->rev? &a[r->as + r->cnt - 1] : &a[r->as], n, mini_pos);\n\t\tif (st < 0) {\n\t\t\tif (mm_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[WARNING] logic inconsistency in mm_est_err(). Please contact the developer.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tl_ref = mi->seq[r->rid].len;\n\t\tfor (k = 1, j = st + 1, n_match = 1; j < n && k < r->cnt; ++j) {\n\t\t\tint32_t x;\n\t\t\tx = get_for_qpos(qlen, r->rev? &a[r->as + r->cnt - 1 - k] : &a[r->as + k]);\n\t\t\tif (x == (int32_t)mini_pos[j])\n\t\t\t\t++k, en = j, ++n_match;\n\t\t}\n\t\tn_tot = en - st + 1;\n\t\tif (r->qs > avg_k && r->rs > avg_k) ++n_tot;\n\t\tif (qlen - r->qs > avg_k && l_ref - r->re > avg_k) ++n_tot;\n\t\tr->div = n_match >= n_tot? 0.0f : (float)(1.0 - pow((double)n_match / n_tot, 1.0 / avg_k));\n\t}\n}\n"
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 2.1064453125,
          "content": "// To compile:\n//   gcc -g -O2 example.c libminimap2.a -lz\n\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <zlib.h>\n#include \"minimap.h\"\n#include \"kseq.h\"\nKSEQ_INIT(gzFile, gzread)\n\nint main(int argc, char *argv[])\n{\n\tmm_idxopt_t iopt;\n\tmm_mapopt_t mopt;\n\tint n_threads = 3;\n\n\tmm_verbose = 2; // disable message output to stderr\n\tmm_set_opt(0, &iopt, &mopt);\n\tmopt.flag |= MM_F_CIGAR; // perform alignment\n\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: minimap2-lite <target.fa> <query.fa>\\n\");\n\t\treturn 1;\n\t}\n\n\t// open query file for reading; you may use your favorite FASTA/Q parser\n\tgzFile f = gzopen(argv[2], \"r\");\n\tassert(f);\n\tkseq_t *ks = kseq_init(f);\n\n\t// open index reader\n\tmm_idx_reader_t *r = mm_idx_reader_open(argv[1], &iopt, 0);\n\tmm_idx_t *mi;\n\twhile ((mi = mm_idx_reader_read(r, n_threads)) != 0) { // traverse each part of the index\n\t\tmm_mapopt_update(&mopt, mi); // this sets the maximum minimizer occurrence; TODO: set a better default in mm_mapopt_init()!\n\t\tmm_tbuf_t *tbuf = mm_tbuf_init(); // thread buffer; for multi-threading, allocate one tbuf for each thread\n\t\tgzrewind(f);\n\t\tkseq_rewind(ks);\n\t\twhile (kseq_read(ks) >= 0) { // each kseq_read() call reads one query sequence\n\t\t\tmm_reg1_t *reg;\n\t\t\tint j, i, n_reg;\n\t\t\treg = mm_map(mi, ks->seq.l, ks->seq.s, &n_reg, tbuf, &mopt, 0); // get all hits for the query\n\t\t\tfor (j = 0; j < n_reg; ++j) { // traverse hits and print them out\n\t\t\t\tmm_reg1_t *r = &reg[j];\n\t\t\t\tassert(r->p); // with MM_F_CIGAR, this should not be NULL\n\t\t\t\tprintf(\"%s\\t%d\\t%d\\t%d\\t%c\\t\", ks->name.s, ks->seq.l, r->qs, r->qe, \"+-\"[r->rev]);\n\t\t\t\tprintf(\"%s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\tcg:Z:\", mi->seq[r->rid].name, mi->seq[r->rid].len, r->rs, r->re, r->mlen, r->blen, r->mapq);\n\t\t\t\tfor (i = 0; i < r->p->n_cigar; ++i) // IMPORTANT: this gives the CIGAR in the aligned regions. NO soft/hard clippings!\n\t\t\t\t\tprintf(\"%d%c\", r->p->cigar[i]>>4, MM_CIGAR_STR[r->p->cigar[i]&0xf]);\n\t\t\t\tputchar('\\n');\n\t\t\t\tfree(r->p);\n\t\t\t}\n\t\t\tfree(reg);\n\t\t}\n\t\tmm_tbuf_destroy(tbuf);\n\t\tmm_idx_destroy(mi);\n\t}\n\tmm_idx_reader_close(r); // close the index reader\n\tkseq_destroy(ks); // close the query file\n\tgzclose(f);\n\treturn 0;\n}\n"
        },
        {
          "name": "format.c",
          "type": "blob",
          "size": 20.8984375,
          "content": "#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include \"kalloc.h\"\n#include \"mmpriv.h\"\n\nstatic char mm_rg_id[256];\n\nstatic inline void str_enlarge(kstring_t *s, int l)\n{\n\tif (s->l + l + 1 > s->m) {\n\t\ts->m = s->l + l + 1;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n}\n\nstatic inline void str_copy(kstring_t *s, const char *st, const char *en)\n{\n\tstr_enlarge(s, en - st);\n\tmemcpy(&s->s[s->l], st, en - st);\n\ts->l += en - st;\n}\n\nstatic void mm_sprintf_lite(kstring_t *s, const char *fmt, ...)\n{\n\tchar buf[16]; // for integer to string conversion\n\tconst char *p, *q;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfor (q = p = fmt; *p; ++p) {\n\t\tif (*p == '%') {\n\t\t\tif (p > q) str_copy(s, q, p);\n\t\t\t++p;\n\t\t\tif (*p == 'd') {\n\t\t\t\tint c, i, l = 0;\n\t\t\t\tunsigned int x;\n\t\t\t\tc = va_arg(ap, int);\n\t\t\t\tx = c >= 0? c : -c;\n\t\t\t\tdo { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);\n\t\t\t\tif (c < 0) buf[l++] = '-';\n\t\t\t\tstr_enlarge(s, l);\n\t\t\t\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\t\t\t} else if (*p == 'u') {\n\t\t\t\tint i, l = 0;\n\t\t\t\tuint32_t x;\n\t\t\t\tx = va_arg(ap, uint32_t);\n\t\t\t\tdo { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);\n\t\t\t\tstr_enlarge(s, l);\n\t\t\t\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\t\t\t} else if (*p == 's') {\n\t\t\t\tchar *r = va_arg(ap, char*);\n\t\t\t\tstr_copy(s, r, r + strlen(r));\n\t\t\t} else if (*p == 'c') {\n\t\t\t\tstr_enlarge(s, 1);\n\t\t\t\ts->s[s->l++] = va_arg(ap, int);\n\t\t\t} else abort();\n\t\t\tq = p + 1;\n\t\t}\n\t}\n\tif (p > q) str_copy(s, q, p);\n\tva_end(ap);\n\ts->s[s->l] = 0;\n}\n\nstatic char *mm_escape(char *s)\n{\n\tchar *p, *q;\n\tfor (p = q = s; *p; ++p) {\n\t\tif (*p == '\\\\') {\n\t\t\t++p;\n\t\t\tif (*p == 't') *q++ = '\\t';\n\t\t\telse if (*p == '\\\\') *q++ = '\\\\';\n\t\t} else *q++ = *p;\n\t}\n\t*q = '\\0';\n\treturn s;\n}\n\nstatic int sam_write_rg_line(kstring_t *str, const char *s)\n{\n\tchar *p, *q, *r, *rg_line = 0;\n\tmemset(mm_rg_id, 0, 256);\n\tif (s == 0) return 0;\n\tif (strstr(s, \"@RG\") != s) {\n\t\tif (mm_verbose >= 1) fprintf(stderr, \"[ERROR] the read group line is not started with @RG\\n\");\n\t\tgoto err_set_rg;\n\t}\n\tif (strstr(s, \"\\t\") != NULL) {\n\t\tif (mm_verbose >= 1) fprintf(stderr, \"[ERROR] the read group line contained literal <tab> characters -- replace with escaped tabs: \\\\t\\n\");\n\t\tgoto err_set_rg;\n\t}\n\trg_line = (char*)malloc(strlen(s) + 1);\n\tstrcpy(rg_line, s);\n\tmm_escape(rg_line);\n\tif ((p = strstr(rg_line, \"\\tID:\")) == 0) {\n\t\tif (mm_verbose >= 1) fprintf(stderr, \"[ERROR] no ID within the read group line\\n\");\n\t\tgoto err_set_rg;\n\t}\n\tp += 4;\n\tfor (q = p; *q && *q != '\\t' && *q != '\\n'; ++q);\n\tif (q - p + 1 > 256) {\n\t\tif (mm_verbose >= 1) fprintf(stderr, \"[ERROR] @RG:ID is longer than 255 characters\\n\");\n\t\tgoto err_set_rg;\n\t}\n\tfor (q = p, r = mm_rg_id; *q && *q != '\\t' && *q != '\\n'; ++q)\n\t\t*r++ = *q;\n\tmm_sprintf_lite(str, \"%s\\n\", rg_line);\n\treturn 0;\n\nerr_set_rg:\n\tfree(rg_line);\n\treturn -1;\n}\n\nint mm_write_sam_hdr(const mm_idx_t *idx, const char *rg, const char *ver, int argc, char *argv[])\n{\n\tkstring_t str = {0,0,0};\n\tint ret = 0;\n\tmm_sprintf_lite(&str, \"@HD\\tVN:1.6\\tSO:unsorted\\tGO:query\\n\");\n\tif (idx) {\n\t\tuint32_t i;\n\t\tfor (i = 0; i < idx->n_seq; ++i)\n\t\t\tmm_sprintf_lite(&str, \"@SQ\\tSN:%s\\tLN:%d\\n\", idx->seq[i].name, idx->seq[i].len);\n\t}\n\tif (rg) ret = sam_write_rg_line(&str, rg);\n\tmm_sprintf_lite(&str, \"@PG\\tID:minimap2\\tPN:minimap2\");\n\tif (ver) mm_sprintf_lite(&str, \"\\tVN:%s\", ver);\n\tif (argc > 1) {\n\t\tint i;\n\t\tmm_sprintf_lite(&str, \"\\tCL:minimap2\");\n\t\tfor (i = 1; i < argc; ++i)\n\t\t\tmm_sprintf_lite(&str, \" %s\", argv[i]);\n\t}\n\tmm_err_puts(str.s);\n\tfree(str.s);\n\treturn ret;\n}\n\nstatic void write_indel_ds(kstring_t *str, int64_t len, const uint8_t *seq, int64_t ll, int64_t lr) // write an indel to ds; adapted from minigraph\n{\n\tint64_t i;\n\tif (ll + lr >= len) {\n\t\tmm_sprintf_lite(str, \"[\");\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tmm_sprintf_lite(str, \"%c\", \"acgtn\"[seq[i]]);\n\t\tmm_sprintf_lite(str, \"]\");\n\t} else {\n\t\tint64_t k = 0;\n\t\tif (ll > 0) {\n\t\t\tmm_sprintf_lite(str, \"[\");\n\t\t\tfor (i = 0; i < ll; ++i)\n\t\t\t\tmm_sprintf_lite(str, \"%c\", \"acgtn\"[seq[k+i]]);\n\t\t\tmm_sprintf_lite(str, \"]\");\n\t\t\tk += ll;\n\t\t}\n\t\tfor (i = 0; i < len - lr - ll; ++i)\n\t\t\tmm_sprintf_lite(str, \"%c\", \"acgtn\"[seq[k+i]]);\n\t\tk += len - lr - ll;\n\t\tif (lr > 0) {\n\t\t\tmm_sprintf_lite(str, \"[\");\n\t\t\tfor (i = 0; i < lr; ++i)\n\t\t\t\tmm_sprintf_lite(str, \"%c\", \"acgtn\"[seq[k+i]]);\n\t\t\tmm_sprintf_lite(str, \"]\");\n\t\t}\n\t}\n}\n\nstatic void write_cs_ds_core(kstring_t *s, const uint8_t *tseq, const uint8_t *qseq, const mm_reg1_t *r, char *tmp, int no_iden, int is_ds, int write_tag)\n{\n\tint i, q_off, t_off, q_len = 0, t_len = 0;\n\tif (write_tag) mm_sprintf_lite(s, \"\\t%cs:Z:\", is_ds? 'd' : 'c');\n\tfor (i = 0; i < (int)r->p->n_cigar; ++i) {\n\t\tint op = r->p->cigar[i]&0xf, len = r->p->cigar[i]>>4;\n\t\tif (op == MM_CIGAR_MATCH || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH)\n\t\t\tq_len += len, t_len += len;\n\t\telse if (op == MM_CIGAR_INS)\n\t\t\tq_len += len;\n\t\telse if (op == MM_CIGAR_DEL || op == MM_CIGAR_N_SKIP)\n\t\t\tt_len += len;\n\t}\n\tfor (i = q_off = t_off = 0; i < (int)r->p->n_cigar; ++i) {\n\t\tint j, op = r->p->cigar[i]&0xf, len = r->p->cigar[i]>>4;\n\t\tassert((op >= MM_CIGAR_MATCH && op <= MM_CIGAR_N_SKIP) || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH);\n\t\tif (op == MM_CIGAR_MATCH || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH) {\n\t\t\tint l_tmp = 0;\n\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\tif (qseq[q_off + j] != tseq[t_off + j]) {\n\t\t\t\t\tif (l_tmp > 0) {\n\t\t\t\t\t\tif (!no_iden) {\n\t\t\t\t\t\t\ttmp[l_tmp] = 0;\n\t\t\t\t\t\t\tmm_sprintf_lite(s, \"=%s\", tmp);\n\t\t\t\t\t\t} else mm_sprintf_lite(s, \":%d\", l_tmp);\n\t\t\t\t\t\tl_tmp = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmm_sprintf_lite(s, \"*%c%c\", \"acgtn\"[tseq[t_off + j]], \"acgtn\"[qseq[q_off + j]]);\n\t\t\t\t} else tmp[l_tmp++] = \"ACGTN\"[qseq[q_off + j]];\n\t\t\t}\n\t\t\tif (l_tmp > 0) {\n\t\t\t\tif (!no_iden) {\n\t\t\t\t\ttmp[l_tmp] = 0;\n\t\t\t\t\tmm_sprintf_lite(s, \"=%s\", tmp);\n\t\t\t\t} else mm_sprintf_lite(s, \":%d\", l_tmp);\n\t\t\t}\n\t\t\tq_off += len, t_off += len;\n\t\t} else if (op == MM_CIGAR_INS) {\n\t\t\tif (is_ds) {\n\t\t\t\tint z, ll, lr, y = q_off;\n\t\t\t\tfor (z = 1; z <= len; ++z)\n\t\t\t\t\tif (y - z < 0 || qseq[y + len - z] != qseq[y - z])\n\t\t\t\t\t\tbreak;\n\t\t\t\tlr = z - 1;\n\t\t\t\tfor (z = 0; z < len; ++z)\n\t\t\t\t\tif (y + len + z >= q_len || qseq[y + len + z] != qseq[y + z])\n\t\t\t\t\t\tbreak;\n\t\t\t\tll = z;\n\t\t\t\tmm_sprintf_lite(s, \"+\");\n\t\t\t\twrite_indel_ds(s, len, &qseq[y], ll, lr);\n\t\t\t} else {\n\t\t\t\tfor (j = 0, tmp[len] = 0; j < len; ++j)\n\t\t\t\t\ttmp[j] = \"acgtn\"[qseq[q_off + j]];\n\t\t\t\tmm_sprintf_lite(s, \"+%s\", tmp);\n\t\t\t}\n\t\t\tq_off += len;\n\t\t} else if (op == MM_CIGAR_DEL) {\n\t\t\tif (is_ds) {\n\t\t\t\tint z, ll, lr, x = t_off;\n\t\t\t\tfor (z = 1; z <= len; ++z)\n\t\t\t\t\tif (x - z < 0 || tseq[x + len - z] != tseq[x - z])\n\t\t\t\t\t\tbreak;\n\t\t\t\tlr = z - 1;\n\t\t\t\tfor (z = 0; z < len; ++z)\n\t\t\t\t\tif (x + len + z >= t_len || tseq[x + z] != tseq[x + len + z])\n\t\t\t\t\t\tbreak;\n\t\t\t\tll = z;\n\t\t\t\tmm_sprintf_lite(s, \"-\");\n\t\t\t\twrite_indel_ds(s, len, &tseq[x], ll, lr);\n\t\t\t} else {\n\t\t\t\tfor (j = 0, tmp[len] = 0; j < len; ++j)\n\t\t\t\t\ttmp[j] = \"acgtn\"[tseq[t_off + j]];\n\t\t\t\tmm_sprintf_lite(s, \"-%s\", tmp);\n\t\t\t}\n\t\t\tt_off += len;\n\t\t} else { // intron\n\t\t\tassert(len >= 2);\n\t\t\tmm_sprintf_lite(s, \"~%c%c%d%c%c\", \"acgtn\"[tseq[t_off]], \"acgtn\"[tseq[t_off+1]],\n\t\t\t\tlen, \"acgtn\"[tseq[t_off+len-2]], \"acgtn\"[tseq[t_off+len-1]]);\n\t\t\tt_off += len;\n\t\t}\n\t}\n\tassert(t_off == r->re - r->rs && q_off == r->qe - r->qs);\n}\n\nstatic void write_MD_core(kstring_t *s, const uint8_t *tseq, const uint8_t *qseq, const mm_reg1_t *r, char *tmp, int write_tag)\n{\n\tint i, q_off, t_off, l_MD = 0;\n\tif (write_tag) mm_sprintf_lite(s, \"\\tMD:Z:\");\n\tfor (i = q_off = t_off = 0; i < (int)r->p->n_cigar; ++i) {\n\t\tint j, op = r->p->cigar[i]&0xf, len = r->p->cigar[i]>>4;\n\t\tassert((op >= MM_CIGAR_MATCH && op <= MM_CIGAR_N_SKIP) || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH);\n\t\tif (op == MM_CIGAR_MATCH || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH) {\n\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\tif (qseq[q_off + j] != tseq[t_off + j]) {\n\t\t\t\t\tmm_sprintf_lite(s, \"%d%c\", l_MD, \"ACGTN\"[tseq[t_off + j]]);\n\t\t\t\t\tl_MD = 0;\n\t\t\t\t} else ++l_MD;\n\t\t\t}\n\t\t\tq_off += len, t_off += len;\n\t\t} else if (op == MM_CIGAR_INS) {\n\t\t\tq_off += len;\n\t\t} else if (op == MM_CIGAR_DEL) {\n\t\t\tfor (j = 0, tmp[len] = 0; j < len; ++j)\n\t\t\t\ttmp[j] = \"ACGTN\"[tseq[t_off + j]];\n\t\t\tmm_sprintf_lite(s, \"%d^%s\", l_MD, tmp);\n\t\t\tl_MD = 0;\n\t\t\tt_off += len;\n\t\t} else if (op == MM_CIGAR_N_SKIP) {\n\t\t\tt_off += len;\n\t\t}\n\t}\n\tif (l_MD > 0) mm_sprintf_lite(s, \"%d\", l_MD);\n\tassert(t_off == r->re - r->rs && q_off == r->qe - r->qs);\n}\n\nstatic void write_cs_ds_or_MD(void *km, kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, int no_iden, int is_MD, int is_ds, int write_tag, int is_qstrand)\n{\n\textern unsigned char seq_nt4_table[256];\n\tint i;\n\tuint8_t *qseq, *tseq;\n\tchar *tmp;\n\tif (r->p == 0) return;\n\tqseq = (uint8_t*)kmalloc(km, r->qe - r->qs);\n\ttseq = (uint8_t*)kmalloc(km, r->re - r->rs);\n\ttmp = (char*)kmalloc(km, r->re - r->rs > r->qe - r->qs? r->re - r->rs + 1 : r->qe - r->qs + 1);\n\tif (is_qstrand) {\n\t\tmm_idx_getseq2(mi, r->rev, r->rid, r->rs, r->re, tseq);\n\t\tfor (i = r->qs; i < r->qe; ++i)\n\t\t\tqseq[i - r->qs] = seq_nt4_table[(uint8_t)t->seq[i]];\n\t} else {\n\t\tmm_idx_getseq(mi, r->rid, r->rs, r->re, tseq);\n\t\tif (!r->rev) {\n\t\t\tfor (i = r->qs; i < r->qe; ++i)\n\t\t\t\tqseq[i - r->qs] = seq_nt4_table[(uint8_t)t->seq[i]];\n\t\t} else {\n\t\t\tfor (i = r->qs; i < r->qe; ++i) {\n\t\t\t\tuint8_t c = seq_nt4_table[(uint8_t)t->seq[i]];\n\t\t\t\tqseq[r->qe - i - 1] = c >= 4? 4 : 3 - c;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_MD) write_MD_core(s, tseq, qseq, r, tmp, write_tag);\n\telse write_cs_ds_core(s, tseq, qseq, r, tmp, no_iden, is_ds, write_tag);\n\tkfree(km, qseq); kfree(km, tseq); kfree(km, tmp);\n}\n\nint mm_gen_cs_or_MD(void *km, char **buf, int *max_len, const mm_idx_t *mi, const mm_reg1_t *r, const char *seq, int is_MD, int no_iden, int is_qstrand)\n{\n\tmm_bseq1_t t;\n\tkstring_t str;\n\tstr.s = *buf, str.l = 0, str.m = *max_len;\n\tt.l_seq = strlen(seq);\n\tt.seq = (char*)seq;\n\twrite_cs_ds_or_MD(km, &str, mi, &t, r, no_iden, is_MD, 0, 0, is_qstrand);\n\t*max_len = str.m;\n\t*buf = str.s;\n\treturn str.l;\n}\n\nint mm_gen_cs(void *km, char **buf, int *max_len, const mm_idx_t *mi, const mm_reg1_t *r, const char *seq, int no_iden)\n{\n\treturn mm_gen_cs_or_MD(km, buf, max_len, mi, r, seq, 0, no_iden, 0);\n}\n\nint mm_gen_MD(void *km, char **buf, int *max_len, const mm_idx_t *mi, const mm_reg1_t *r, const char *seq)\n{\n\treturn mm_gen_cs_or_MD(km, buf, max_len, mi, r, seq, 1, 0, 0);\n}\n\nstatic inline void write_tags(kstring_t *s, const mm_reg1_t *r)\n{\n\tint type;\n\tif (r->id == r->parent) type = r->inv? 'I' : 'P';\n\telse type = r->inv? 'i' : 'S';\n\tif (r->p) {\n\t\tmm_sprintf_lite(s, \"\\tNM:i:%d\\tms:i:%d\\tAS:i:%d\\tnn:i:%d\", r->blen - r->mlen + r->p->n_ambi, r->p->dp_max0, r->p->dp_score, r->p->n_ambi);\n\t\tif (r->p->trans_strand == 1 || r->p->trans_strand == 2)\n\t\t\tmm_sprintf_lite(s, \"\\tts:A:%c\", \"?+-?\"[r->p->trans_strand]);\n\t}\n\tmm_sprintf_lite(s, \"\\ttp:A:%c\\tcm:i:%d\\ts1:i:%d\", type, r->cnt, r->score);\n\tif (r->parent == r->id) mm_sprintf_lite(s, \"\\ts2:i:%d\", r->subsc);\n\tif (r->p) {\n\t\tchar buf[16];\n\t\tdouble div;\n\t\tdiv = 1.0 - mm_event_identity(r);\n\t\tif (div == 0.0) buf[0] = '0', buf[1] = 0;\n\t\telse snprintf(buf, 16, \"%.4f\", 1.0 - mm_event_identity(r));\n\t\tmm_sprintf_lite(s, \"\\tde:f:%s\", buf);\n\t} else if (r->div >= 0.0f && r->div <= 1.0f) {\n\t\tchar buf[16];\n\t\tif (r->div == 0.0f) buf[0] = '0', buf[1] = 0;\n\t\telse snprintf(buf, 16, \"%.4f\", r->div);\n\t\tmm_sprintf_lite(s, \"\\tdv:f:%s\", buf);\n\t}\n\tif (r->split) mm_sprintf_lite(s, \"\\tzd:i:%d\", r->split);\n}\n\nvoid mm_write_paf3(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, void *km, int64_t opt_flag, int rep_len)\n{\n\ts->l = 0;\n\tif (r == 0) {\n\t\tmm_sprintf_lite(s, \"%s\\t%d\\t0\\t0\\t*\\t*\\t0\\t0\\t0\\t0\\t0\\t0\", t->name, t->l_seq);\n\t\tif (rep_len >= 0) mm_sprintf_lite(s, \"\\trl:i:%d\", rep_len);\n\t\treturn;\n\t}\n\tmm_sprintf_lite(s, \"%s\\t%d\\t%d\\t%d\\t%c\\t\", t->name, t->l_seq, r->qs, r->qe, \"+-\"[r->rev]);\n\tif (mi->seq[r->rid].name) mm_sprintf_lite(s, \"%s\", mi->seq[r->rid].name);\n\telse mm_sprintf_lite(s, \"%d\", r->rid);\n\tmm_sprintf_lite(s, \"\\t%d\", mi->seq[r->rid].len);\n\tif ((opt_flag & MM_F_QSTRAND) && r->rev)\n\t\tmm_sprintf_lite(s, \"\\t%d\\t%d\", mi->seq[r->rid].len - r->re, mi->seq[r->rid].len - r->rs);\n\telse\n\t\tmm_sprintf_lite(s, \"\\t%d\\t%d\", r->rs, r->re);\n\tmm_sprintf_lite(s, \"\\t%d\\t%d\", r->mlen, r->blen);\n\tmm_sprintf_lite(s, \"\\t%d\", r->mapq);\n\twrite_tags(s, r);\n\tif (rep_len >= 0) mm_sprintf_lite(s, \"\\trl:i:%d\", rep_len);\n\tif (r->p && (opt_flag & MM_F_OUT_CG)) {\n\t\tuint32_t k;\n\t\tmm_sprintf_lite(s, \"\\tcg:Z:\");\n\t\tfor (k = 0; k < r->p->n_cigar; ++k)\n\t\t\tmm_sprintf_lite(s, \"%d%c\", r->p->cigar[k]>>4, MM_CIGAR_STR[r->p->cigar[k]&0xf]);\n\t}\n\tif (r->p && (opt_flag & (MM_F_OUT_CS|MM_F_OUT_DS|MM_F_OUT_MD)))\n\t\twrite_cs_ds_or_MD(km, s, mi, t, r, !(opt_flag&MM_F_OUT_CS_LONG), !!(opt_flag&MM_F_OUT_MD), !!(opt_flag&MM_F_OUT_DS), 1, !!(opt_flag&MM_F_QSTRAND));\n\tif ((opt_flag & MM_F_COPY_COMMENT) && t->comment)\n\t\tmm_sprintf_lite(s, \"\\t%s\", t->comment);\n}\n\nvoid mm_write_paf(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, void *km, int64_t opt_flag)\n{\n\tmm_write_paf3(s, mi, t, r, km, opt_flag, -1);\n}\n\nstatic void sam_write_sq(kstring_t *s, char *seq, int l, int rev, int comp)\n{\n\textern unsigned char seq_comp_table[256];\n\tif (rev) {\n\t\tint i;\n\t\tstr_enlarge(s, l);\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tint c = seq[l - 1 - i];\n\t\t\ts->s[s->l + i] = c < 128 && comp? seq_comp_table[c] : c;\n\t\t}\n\t\ts->l += l;\n\t} else str_copy(s, seq, seq + l);\n}\n\nstatic inline const mm_reg1_t *get_sam_pri(int n_regs, const mm_reg1_t *regs)\n{\n\tint i;\n\tfor (i = 0; i < n_regs; ++i)\n\t\tif (regs[i].sam_pri)\n\t\t\treturn &regs[i];\n\tassert(n_regs == 0);\n\treturn NULL;\n}\n\nstatic void write_sam_cigar(kstring_t *s, int sam_flag, int in_tag, int qlen, const mm_reg1_t *r, int64_t opt_flag)\n{\n\tif (r->p == 0) {\n\t\tmm_sprintf_lite(s, \"*\");\n\t} else {\n\t\tuint32_t k, clip_len[2];\n\t\tclip_len[0] = r->rev? qlen - r->qe : r->qs;\n\t\tclip_len[1] = r->rev? r->qs : qlen - r->qe;\n\t\tif (in_tag) {\n\t\t\tint clip_char = (((sam_flag&0x800) || ((sam_flag&0x100) && (opt_flag&MM_F_SECONDARY_SEQ))) &&\n\t\t\t\t\t\t\t !(opt_flag&MM_F_SOFTCLIP)) ? 5 : 4;\n\t\t\tmm_sprintf_lite(s, \"\\tCG:B:I\");\n\t\t\tif (clip_len[0]) mm_sprintf_lite(s, \",%u\", clip_len[0]<<4|clip_char);\n\t\t\tfor (k = 0; k < r->p->n_cigar; ++k)\n\t\t\t\tmm_sprintf_lite(s, \",%u\", r->p->cigar[k]);\n\t\t\tif (clip_len[1]) mm_sprintf_lite(s, \",%u\", clip_len[1]<<4|clip_char);\n\t\t} else {\n\t\t\tint clip_char = (((sam_flag&0x800) || ((sam_flag&0x100) && (opt_flag&MM_F_SECONDARY_SEQ))) &&\n\t\t\t\t\t\t\t !(opt_flag&MM_F_SOFTCLIP)) ? 'H' : 'S';\n\t\t\tassert(clip_len[0] < qlen && clip_len[1] < qlen);\n\t\t\tif (clip_len[0]) mm_sprintf_lite(s, \"%d%c\", clip_len[0], clip_char);\n\t\t\tfor (k = 0; k < r->p->n_cigar; ++k)\n\t\t\t\tmm_sprintf_lite(s, \"%d%c\", r->p->cigar[k]>>4, MM_CIGAR_STR[r->p->cigar[k]&0xf]);\n\t\t\tif (clip_len[1]) mm_sprintf_lite(s, \"%d%c\", clip_len[1], clip_char);\n\t\t}\n\t}\n}\n\nvoid mm_write_sam3(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, int seg_idx, int reg_idx, int n_seg, const int *n_regss, const mm_reg1_t *const* regss, void *km, int64_t opt_flag, int rep_len)\n{\n\tconst int max_bam_cigar_op = 65535;\n\tint flag, n_regs = n_regss[seg_idx], cigar_in_tag = 0;\n\tint this_rid = -1, this_pos = -1;\n\tconst mm_reg1_t *regs = regss[seg_idx], *r_prev = NULL, *r_next;\n\tconst mm_reg1_t *r = n_regs > 0 && reg_idx < n_regs && reg_idx >= 0? &regs[reg_idx] : NULL;\n\n\t// find the primary of the previous and the next segments, if they are mapped\n\tif (n_seg > 1) {\n\t\tint i, next_sid = (seg_idx + 1) % n_seg;\n\t\tr_next = get_sam_pri(n_regss[next_sid], regss[next_sid]);\n\t\tif (n_seg > 2) {\n\t\t\tfor (i = 1; i <= n_seg - 1; ++i) {\n\t\t\t\tint prev_sid = (seg_idx + n_seg - i) % n_seg;\n\t\t\t\tif (n_regss[prev_sid] > 0) {\n\t\t\t\t\tr_prev = get_sam_pri(n_regss[prev_sid], regss[prev_sid]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else r_prev = r_next;\n\t} else r_prev = r_next = NULL;\n\n\t// write QNAME\n\ts->l = 0;\n\tmm_sprintf_lite(s, \"%s\", t->name);\n\tif (n_seg > 1) s->l = mm_qname_len(t->name); // trim the suffix like /1 or /2\n\n\t// write flag\n\tflag = n_seg > 1? 0x1 : 0x0;\n\tif (r == 0) {\n\t\tflag |= 0x4;\n\t} else {\n\t\tif (r->rev) flag |= 0x10;\n\t\tif (r->parent != r->id) flag |= 0x100;\n\t\telse if (!r->sam_pri) flag |= 0x800;\n\t}\n\tif (n_seg > 1) {\n\t\tif (r && r->proper_frag) flag |= 0x2; // TODO: this doesn't work when there are more than 2 segments\n\t\tif (seg_idx == 0) flag |= 0x40;\n\t\telse if (seg_idx == n_seg - 1) flag |= 0x80;\n\t\tif (r_next == NULL) flag |= 0x8;\n\t\telse if (r_next->rev) flag |= 0x20;\n\t}\n\tmm_sprintf_lite(s, \"\\t%d\", flag);\n\n\t// write coordinate, MAPQ and CIGAR\n\tif (r == 0) {\n\t\tif (r_prev) {\n\t\t\tthis_rid = r_prev->rid, this_pos = r_prev->rs;\n\t\t\tmm_sprintf_lite(s, \"\\t%s\\t%d\\t0\\t*\", mi->seq[this_rid].name, this_pos+1);\n\t\t} else mm_sprintf_lite(s, \"\\t*\\t0\\t0\\t*\");\n\t} else {\n\t\tthis_rid = r->rid, this_pos = r->rs;\n\t\tmm_sprintf_lite(s, \"\\t%s\\t%d\\t%d\\t\", mi->seq[r->rid].name, r->rs+1, r->mapq);\n\t\tif ((opt_flag & MM_F_LONG_CIGAR) && r->p && r->p->n_cigar > max_bam_cigar_op - 2) {\n\t\t\tint n_cigar = r->p->n_cigar;\n\t\t\tif (r->qs != 0) ++n_cigar;\n\t\t\tif (r->qe != t->l_seq) ++n_cigar;\n\t\t\tif (n_cigar > max_bam_cigar_op)\n\t\t\t\tcigar_in_tag = 1;\n\t\t}\n\t\tif (cigar_in_tag) {\n\t\t\tint slen;\n\t\t\tif ((flag & 0x900) == 0 || (opt_flag & MM_F_SOFTCLIP)) slen = t->l_seq;\n\t\t\telse if ((flag & 0x100) && !(opt_flag & MM_F_SECONDARY_SEQ)) slen = 0;\n\t\t\telse slen = r->qe - r->qs;\n\t\t\tmm_sprintf_lite(s, \"%dS%dN\", slen, r->re - r->rs);\n\t\t} else write_sam_cigar(s, flag, 0, t->l_seq, r, opt_flag);\n\t}\n\n\t// write mate positions\n\tif (n_seg > 1) {\n\t\tint tlen = 0;\n\t\tif (this_rid >= 0 && r_next) {\n\t\t\tif (this_rid == r_next->rid) {\n\t\t\t\tif (r) {\n\t\t\t\t\tint this_pos5 = r->rev? r->re - 1 : this_pos;\n\t\t\t\t\tint next_pos5 = r_next->rev? r_next->re - 1 : r_next->rs;\n\t\t\t\t\ttlen = next_pos5 - this_pos5;\n\t\t\t\t}\n\t\t\t\tmm_sprintf_lite(s, \"\\t=\\t\");\n\t\t\t} else mm_sprintf_lite(s, \"\\t%s\\t\", mi->seq[r_next->rid].name);\n\t\t\tmm_sprintf_lite(s, \"%d\\t\", r_next->rs + 1);\n\t\t} else if (r_next) { // && this_rid < 0\n\t\t\tmm_sprintf_lite(s, \"\\t%s\\t%d\\t\", mi->seq[r_next->rid].name, r_next->rs + 1);\n\t\t} else if (this_rid >= 0) { // && r_next == NULL\n\t\t\tmm_sprintf_lite(s, \"\\t=\\t%d\\t\", this_pos + 1); // next segment will take r's coordinate\n\t\t} else mm_sprintf_lite(s, \"\\t*\\t0\\t\"); // neither has coordinates\n\t\tif (tlen > 0) ++tlen;\n\t\telse if (tlen < 0) --tlen;\n\t\tmm_sprintf_lite(s, \"%d\\t\", tlen);\n\t} else mm_sprintf_lite(s, \"\\t*\\t0\\t0\\t\");\n\n\t// write SEQ and QUAL\n\tif (r == 0) {\n\t\tsam_write_sq(s, t->seq, t->l_seq, 0, 0);\n\t\tmm_sprintf_lite(s, \"\\t\");\n\t\tif (t->qual) sam_write_sq(s, t->qual, t->l_seq, 0, 0);\n\t\telse mm_sprintf_lite(s, \"*\");\n\t} else {\n\t\tif ((flag & 0x900) == 0 || (opt_flag & MM_F_SOFTCLIP)) {\n\t\t\tsam_write_sq(s, t->seq, t->l_seq, r->rev, r->rev);\n\t\t\tmm_sprintf_lite(s, \"\\t\");\n\t\t\tif (t->qual) sam_write_sq(s, t->qual, t->l_seq, r->rev, 0);\n\t\t\telse mm_sprintf_lite(s, \"*\");\n\t\t} else if ((flag & 0x100) && !(opt_flag & MM_F_SECONDARY_SEQ)){\n\t\t\tmm_sprintf_lite(s, \"*\\t*\");\n\t\t} else {\n\t\t\tsam_write_sq(s, t->seq + r->qs, r->qe - r->qs, r->rev, r->rev);\n\t\t\tmm_sprintf_lite(s, \"\\t\");\n\t\t\tif (t->qual) sam_write_sq(s, t->qual + r->qs, r->qe - r->qs, r->rev, 0);\n\t\t\telse mm_sprintf_lite(s, \"*\");\n\t\t}\n\t}\n\n\t// write tags\n\tif (mm_rg_id[0]) mm_sprintf_lite(s, \"\\tRG:Z:%s\", mm_rg_id);\n\tif (n_seg > 2) mm_sprintf_lite(s, \"\\tFI:i:%d\", seg_idx);\n\tif (r) {\n\t\twrite_tags(s, r);\n\t\tif (r->parent == r->id && r->p && n_regs > 1 && regs && r >= regs && r - regs < n_regs) { // supplementary aln may exist\n\t\t\tint i, n_sa = 0; // n_sa: number of SA fields\n\t\t\tfor (i = 0; i < n_regs; ++i)\n\t\t\t\tif (i != r - regs && regs[i].parent == regs[i].id && regs[i].p)\n\t\t\t\t\t++n_sa;\n\t\t\tif (n_sa > 0) {\n\t\t\t\tmm_sprintf_lite(s, \"\\tSA:Z:\");\n\t\t\t\tfor (i = 0; i < n_regs; ++i) {\n\t\t\t\t\tconst mm_reg1_t *q = &regs[i];\n\t\t\t\t\tint l_M, l_I = 0, l_D = 0, clip5 = 0, clip3 = 0;\n\t\t\t\t\tif (r == q || q->parent != q->id || q->p == 0) continue;\n\t\t\t\t\tif (q->qe - q->qs < q->re - q->rs) l_M = q->qe - q->qs, l_D = (q->re - q->rs) - l_M;\n\t\t\t\t\telse l_M = q->re - q->rs, l_I = (q->qe - q->qs) - l_M;\n\t\t\t\t\tclip5 = q->rev? t->l_seq - q->qe : q->qs;\n\t\t\t\t\tclip3 = q->rev? q->qs : t->l_seq - q->qe;\n\t\t\t\t\tmm_sprintf_lite(s, \"%s,%d,%c,\", mi->seq[q->rid].name, q->rs+1, \"+-\"[q->rev]);\n\t\t\t\t\tif (clip5) mm_sprintf_lite(s, \"%dS\", clip5);\n\t\t\t\t\tif (l_M) mm_sprintf_lite(s, \"%dM\", l_M);\n\t\t\t\t\tif (l_I) mm_sprintf_lite(s, \"%dI\", l_I);\n\t\t\t\t\tif (l_D) mm_sprintf_lite(s, \"%dD\", l_D);\n\t\t\t\t\tif (clip3) mm_sprintf_lite(s, \"%dS\", clip3);\n\t\t\t\t\tmm_sprintf_lite(s, \",%d,%d;\", q->mapq, q->blen - q->mlen + q->p->n_ambi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r->p && (opt_flag & (MM_F_OUT_CS|MM_F_OUT_DS|MM_F_OUT_MD)))\n\t\t\twrite_cs_ds_or_MD(km, s, mi, t, r, !(opt_flag&MM_F_OUT_CS_LONG), opt_flag&MM_F_OUT_MD, !!(opt_flag&MM_F_OUT_DS), 1, 0);\n\t\tif (cigar_in_tag)\n\t\t\twrite_sam_cigar(s, flag, 1, t->l_seq, r, opt_flag);\n\t}\n\tif (rep_len >= 0) mm_sprintf_lite(s, \"\\trl:i:%d\", rep_len);\n\n\tif ((opt_flag & MM_F_COPY_COMMENT) && t->comment)\n\t\tmm_sprintf_lite(s, \"\\t%s\", t->comment);\n\n\ts->s[s->l] = 0; // we always have room for an extra byte (see str_enlarge)\n}\n\nvoid mm_write_sam2(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, int seg_idx, int reg_idx, int n_seg, const int *n_regss, const mm_reg1_t *const* regss, void *km, int64_t opt_flag)\n{\n\tmm_write_sam3(s, mi, t, seg_idx, reg_idx, n_seg, n_regss, regss, km, opt_flag, -1);\n}\n\nvoid mm_write_sam(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, int n_regs, const mm_reg1_t *regs)\n{\n\tint i;\n\tfor (i = 0; i < n_regs; ++i)\n\t\tif (r == &regs[i]) break;\n\tmm_write_sam2(s, mi, t, 0, i, 1, &n_regs, &regs, NULL, 0);\n}\n"
        },
        {
          "name": "hit.c",
          "type": "blob",
          "size": 14.9541015625,
          "content": "#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"mmpriv.h\"\n#include \"kalloc.h\"\n#include \"khash.h\"\n\nstatic inline void mm_cal_fuzzy_len(mm_reg1_t *r, const mm128_t *a)\n{\n\tint i;\n\tr->mlen = r->blen = 0;\n\tif (r->cnt <= 0) return;\n\tr->mlen = r->blen = a[r->as].y>>32&0xff;\n\tfor (i = r->as + 1; i < r->as + r->cnt; ++i) {\n\t\tint span = a[i].y>>32&0xff;\n\t\tint tl = (int32_t)a[i].x - (int32_t)a[i-1].x;\n\t\tint ql = (int32_t)a[i].y - (int32_t)a[i-1].y;\n\t\tr->blen += tl > ql? tl : ql;\n\t\tr->mlen += tl > span && ql > span? span : tl < ql? tl : ql;\n\t}\n}\n\nstatic inline void mm_reg_set_coor(mm_reg1_t *r, int32_t qlen, const mm128_t *a, int is_qstrand)\n{ // NB: r->as and r->cnt MUST BE set correctly for this function to work\n\tint32_t k = r->as, q_span = (int32_t)(a[k].y>>32&0xff);\n\tr->rev = a[k].x>>63;\n\tr->rid = a[k].x<<1>>33;\n\tr->rs = (int32_t)a[k].x + 1 > q_span? (int32_t)a[k].x + 1 - q_span : 0; // NB: target span may be shorter, so this test is necessary\n\tr->re = (int32_t)a[k + r->cnt - 1].x + 1;\n\tif (!r->rev || is_qstrand) {\n\t\tr->qs = (int32_t)a[k].y + 1 - q_span;\n\t\tr->qe = (int32_t)a[k + r->cnt - 1].y + 1;\n\t} else {\n\t\tr->qs = qlen - ((int32_t)a[k + r->cnt - 1].y + 1);\n\t\tr->qe = qlen - ((int32_t)a[k].y + 1 - q_span);\n\t}\n\tmm_cal_fuzzy_len(r, a);\n}\n\nstatic inline uint64_t hash64(uint64_t key)\n{\n\tkey = (~key + (key << 21));\n\tkey = key ^ key >> 24;\n\tkey = ((key + (key << 3)) + (key << 8));\n\tkey = key ^ key >> 14;\n\tkey = ((key + (key << 2)) + (key << 4));\n\tkey = key ^ key >> 28;\n\tkey = (key + (key << 31));\n\treturn key;\n}\n\nmm_reg1_t *mm_gen_regs(void *km, uint32_t hash, int qlen, int n_u, uint64_t *u, mm128_t *a, int is_qstrand) // convert chains to hits\n{\n\tmm128_t *z, tmp;\n\tmm_reg1_t *r;\n\tint i, k;\n\n\tif (n_u == 0) return 0;\n\n\t// sort by score\n\tz = (mm128_t*)kmalloc(km, n_u * 16);\n\tfor (i = k = 0; i < n_u; ++i) {\n\t\tuint32_t h;\n\t\th = (uint32_t)hash64((hash64(a[k].x) + hash64(a[k].y)) ^ hash);\n\t\tz[i].x = u[i] ^ h; // u[i] -- higher 32 bits: chain score; lower 32 bits: number of seeds in the chain\n\t\tz[i].y = (uint64_t)k << 32 | (int32_t)u[i];\n\t\tk += (int32_t)u[i];\n\t}\n\tradix_sort_128x(z, z + n_u);\n\tfor (i = 0; i < n_u>>1; ++i) // reverse, s.t. larger score first\n\t\ttmp = z[i], z[i] = z[n_u-1-i], z[n_u-1-i] = tmp;\n\n\t// populate r[]\n\tr = (mm_reg1_t*)calloc(n_u, sizeof(mm_reg1_t));\n\tfor (i = 0; i < n_u; ++i) {\n\t\tmm_reg1_t *ri = &r[i];\n\t\tri->id = i;\n\t\tri->parent = MM_PARENT_UNSET;\n\t\tri->score = ri->score0 = z[i].x >> 32;\n\t\tri->hash = (uint32_t)z[i].x;\n\t\tri->cnt = (int32_t)z[i].y;\n\t\tri->as = z[i].y >> 32;\n\t\tri->div = -1.0f;\n\t\tmm_reg_set_coor(ri, qlen, a, is_qstrand);\n\t}\n\tkfree(km, z);\n\treturn r;\n}\n\nvoid mm_mark_alt(const mm_idx_t *mi, int n, mm_reg1_t *r)\n{\n\tint i;\n\tif (mi->n_alt == 0) return;\n\tfor (i = 0; i < n; ++i)\n\t\tif (mi->seq[r[i].rid].is_alt)\n\t\t\tr[i].is_alt = 1;\n}\n\nstatic inline int mm_alt_score(int score, float alt_diff_frac)\n{\n\tif (score < 0) return score;\n\tscore = (int)(score * (1.0 - alt_diff_frac) + .499);\n\treturn score > 0? score : 1;\n}\n\nvoid mm_split_reg(mm_reg1_t *r, mm_reg1_t *r2, int n, int qlen, mm128_t *a, int is_qstrand)\n{\n\tif (n <= 0 || n >= r->cnt) return;\n\t*r2 = *r;\n\tr2->id = -1;\n\tr2->sam_pri = 0;\n\tr2->p = 0;\n\tr2->split_inv = 0;\n\tr2->cnt = r->cnt - n;\n\tr2->score = (int32_t)(r->score * ((float)r2->cnt / r->cnt) + .499);\n\tr2->as = r->as + n;\n\tif (r->parent == r->id) r2->parent = MM_PARENT_TMP_PRI;\n\tmm_reg_set_coor(r2, qlen, a, is_qstrand);\n\tr->cnt -= r2->cnt;\n\tr->score -= r2->score;\n\tmm_reg_set_coor(r, qlen, a, is_qstrand);\n\tr->split |= 1, r2->split |= 2;\n}\n\nvoid mm_set_parent(void *km, float mask_level, int mask_len, int n, mm_reg1_t *r, int sub_diff, int hard_mask_level, float alt_diff_frac) // and compute mm_reg1_t::subsc\n{\n\tint i, j, k, *w;\n\tuint64_t *cov;\n\tif (n <= 0) return;\n\tfor (i = 0; i < n; ++i) r[i].id = i;\n\tcov = (uint64_t*)kmalloc(km, n * sizeof(uint64_t));\n\tw = (int*)kmalloc(km, n * sizeof(int));\n\tw[0] = 0, r[0].parent = 0;\n\tfor (i = 1, k = 1; i < n; ++i) {\n\t\tmm_reg1_t *ri = &r[i];\n\t\tint si = ri->qs, ei = ri->qe, n_cov = 0, uncov_len = 0;\n\t\tif (hard_mask_level) goto skip_uncov;\n\t\tfor (j = 0; j < k; ++j) { // traverse existing primary hits to find overlapping hits\n\t\t\tmm_reg1_t *rp = &r[w[j]];\n\t\t\tint sj = rp->qs, ej = rp->qe;\n\t\t\tif (ej <= si || sj >= ei) continue;\n\t\t\tif (sj < si) sj = si;\n\t\t\tif (ej > ei) ej = ei;\n\t\t\tcov[n_cov++] = (uint64_t)sj<<32 | ej;\n\t\t}\n\t\tif (n_cov == 0) {\n\t\t\tgoto set_parent_test; // no overlapping primary hits; then i is a new primary hit\n\t\t} else if (n_cov > 0) { // there are overlapping primary hits; find the length not covered by existing primary hits\n\t\t\tint j, x = si;\n\t\t\tradix_sort_64(cov, cov + n_cov);\n\t\t\tfor (j = 0; j < n_cov; ++j) {\n\t\t\t\tif ((int)(cov[j]>>32) > x) uncov_len += (cov[j]>>32) - x;\n\t\t\t\tx = (int32_t)cov[j] > x? (int32_t)cov[j] : x;\n\t\t\t}\n\t\t\tif (ei > x) uncov_len += ei - x;\n\t\t}\nskip_uncov:\n\t\tfor (j = 0; j < k; ++j) { // traverse existing primary hits again\n\t\t\tmm_reg1_t *rp = &r[w[j]];\n\t\t\tint sj = rp->qs, ej = rp->qe, min, max, ol;\n\t\t\tif (ej <= si || sj >= ei) continue; // no overlap\n\t\t\tmin = ej - sj < ei - si? ej - sj : ei - si;\n\t\t\tmax = ej - sj > ei - si? ej - sj : ei - si;\n\t\t\tol = si < sj? (ei < sj? 0 : ei < ej? ei - sj : ej - sj) : (ej < si? 0 : ej < ei? ej - si : ei - si); // overlap length; TODO: this can be simplified\n\t\t\tif ((float)ol / min - (float)uncov_len / max > mask_level && uncov_len <= mask_len) { // then this is a secondary hit\n\t\t\t\tint cnt_sub = 0, sci = ri->score;\n\t\t\t\tri->parent = rp->parent;\n\t\t\t\tif (!rp->is_alt && ri->is_alt) sci = mm_alt_score(sci, alt_diff_frac);\n\t\t\t\trp->subsc = rp->subsc > sci? rp->subsc : sci;\n\t\t\t\tif (ri->cnt >= rp->cnt) cnt_sub = 1;\n\t\t\t\tif (rp->p && ri->p && (rp->rid != ri->rid || rp->rs != ri->rs || rp->re != ri->re || ol != min)) { // the last condition excludes identical hits after DP\n\t\t\t\t\tsci = ri->p->dp_max;\n\t\t\t\t\tif (!rp->is_alt && ri->is_alt) sci = mm_alt_score(sci, alt_diff_frac);\n\t\t\t\t\trp->p->dp_max2 = rp->p->dp_max2 > sci? rp->p->dp_max2 : sci;\n\t\t\t\t\tif (rp->p->dp_max - ri->p->dp_max <= sub_diff) cnt_sub = 1;\n\t\t\t\t}\n\t\t\t\tif (cnt_sub) ++rp->n_sub;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nset_parent_test:\n\t\tif (j == k) w[k++] = i, ri->parent = i, ri->n_sub = 0;\n\t}\n\tkfree(km, cov);\n\tkfree(km, w);\n}\n\nvoid mm_hit_sort(void *km, int *n_regs, mm_reg1_t *r, float alt_diff_frac)\n{\n\tint32_t i, n_aux, n = *n_regs, has_cigar = 0, no_cigar = 0;\n\tmm128_t *aux;\n\tmm_reg1_t *t;\n\n\tif (n <= 1) return;\n\taux = (mm128_t*)kmalloc(km, n * 16);\n\tt = (mm_reg1_t*)kmalloc(km, n * sizeof(mm_reg1_t));\n\tfor (i = n_aux = 0; i < n; ++i) {\n\t\tif (r[i].inv || r[i].cnt > 0) { // squeeze out elements with cnt==0 (soft deleted)\n\t\t\tint score;\n\t\t\tif (r[i].p) score = r[i].p->dp_max, has_cigar = 1;\n\t\t\telse score = r[i].score, no_cigar = 1;\n\t\t\tif (r[i].is_alt) score = mm_alt_score(score, alt_diff_frac);\n\t\t\taux[n_aux].x = (uint64_t)score << 32 | r[i].hash;\n\t\t\taux[n_aux++].y = i;\n\t\t} else if (r[i].p) {\n\t\t\tfree(r[i].p);\n\t\t\tr[i].p = 0;\n\t\t}\n\t}\n\tassert(has_cigar + no_cigar == 1);\n\tradix_sort_128x(aux, aux + n_aux);\n\tfor (i = n_aux - 1; i >= 0; --i)\n\t\tt[n_aux - 1 - i] = r[aux[i].y];\n\tmemcpy(r, t, sizeof(mm_reg1_t) * n_aux);\n\t*n_regs = n_aux;\n\tkfree(km, aux);\n\tkfree(km, t);\n}\n\nint mm_set_sam_pri(int n, mm_reg1_t *r)\n{\n\tint i, n_pri = 0;\n\tfor (i = 0; i < n; ++i)\n\t\tif (r[i].id == r[i].parent) {\n\t\t\t++n_pri;\n\t\t\tr[i].sam_pri = (n_pri == 1);\n\t\t} else r[i].sam_pri = 0;\n\treturn n_pri;\n}\n\nvoid mm_sync_regs(void *km, int n_regs, mm_reg1_t *regs) // keep mm_reg1_t::{id,parent} in sync; also reset id\n{\n\tint *tmp, i, max_id = -1, n_tmp;\n\tif (n_regs <= 0) return;\n\tfor (i = 0; i < n_regs; ++i) // NB: doesn't work if mm_reg1_t::id is negative\n\t\tmax_id = max_id > regs[i].id? max_id : regs[i].id;\n\tn_tmp = max_id + 1;\n\ttmp = (int*)kmalloc(km, n_tmp * sizeof(int));\n\tfor (i = 0; i < n_tmp; ++i) tmp[i] = -1;\n\tfor (i = 0; i < n_regs; ++i)\n\t\tif (regs[i].id >= 0) tmp[regs[i].id] = i;\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tr->id = i;\n\t\tif (r->parent == MM_PARENT_TMP_PRI)\n\t\t\tr->parent = i;\n\t\telse if (r->parent >= 0 && tmp[r->parent] >= 0)\n\t\t\tr->parent = tmp[r->parent];\n\t\telse r->parent = MM_PARENT_UNSET;\n\t}\n\tkfree(km, tmp);\n\tmm_set_sam_pri(n_regs, regs);\n}\n\nvoid mm_select_sub(void *km, float pri_ratio, int min_diff, int best_n, int check_strand, int min_strand_sc, int *n_, mm_reg1_t *r)\n{\n\tif (pri_ratio > 0.0f && *n_ > 0) {\n\t\tint i, k, n = *n_, n_2nd = 0;\n\t\tfor (i = k = 0; i < n; ++i) {\n\t\t\tint p = r[i].parent;\n\t\t\tif (p == i || r[i].inv) { // primary or inversion\n\t\t\t\tr[k++] = r[i];\n\t\t\t} else if ((r[i].score >= r[p].score * pri_ratio || r[i].score + min_diff >= r[p].score) && n_2nd < best_n) {\n\t\t\t\tif (!(r[i].qs == r[p].qs && r[i].qe == r[p].qe && r[i].rid == r[p].rid && r[i].rs == r[p].rs && r[i].re == r[p].re)) // not identical hits\n\t\t\t\t\tr[k++] = r[i], ++n_2nd;\n\t\t\t\telse if (r[i].p) free(r[i].p);\n\t\t\t} else if (check_strand && n_2nd < best_n && r[i].score > min_strand_sc && r[i].rev != r[p].rev) {\n\t\t\t\tr[i].strand_retained = 1;\n\t\t\t\tr[k++] = r[i], ++n_2nd;\n\t\t\t} else if (r[i].p) free(r[i].p);\n\t\t}\n\t\tif (k != n) mm_sync_regs(km, k, r); // removing hits requires sync()\n\t\t*n_ = k;\n\t}\n}\n\nint mm_filter_strand_retained(int n_regs, mm_reg1_t *r)\n{\n\tint i, k;\n\tfor (i = k = 0; i < n_regs; ++i) {\n\t\tint p = r[i].parent;\n\t\tif (!r[i].strand_retained || r[i].div < r[p].div * 5.0f || r[i].div < 0.01f) {\n\t\t\tif (k < i) r[k++] = r[i];\n\t\t\telse ++k;\n\t\t}\n\t}\n\treturn k;\n}\n\nvoid mm_filter_regs(const mm_mapopt_t *opt, int qlen, int *n_regs, mm_reg1_t *regs)\n{ // NB: after this call, mm_reg1_t::parent can be -1 if its parent filtered out\n\tint i, k;\n\tfor (i = k = 0; i < *n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tint flt = 0;\n\t\tif (!r->inv && !r->seg_split && r->cnt < opt->min_cnt) flt = 1;\n\t\tif (r->p) { // these filters are only applied when base-alignment is available\n\t\t\tif (r->mlen < opt->min_chain_score) flt = 1;\n\t\t\telse if (r->p->dp_max < opt->min_dp_max) flt = 1;\n\t\t\telse if (r->qs > qlen * opt->max_clip_ratio && qlen - r->qe > qlen * opt->max_clip_ratio) flt = 1;\n\t\t\tif (flt) free(r->p);\n\t\t}\n\t\tif (!flt) {\n\t\t\tif (k < i) regs[k++] = regs[i];\n\t\t\telse ++k;\n\t\t}\n\t}\n\t*n_regs = k;\n}\n\nint mm_squeeze_a(void *km, int n_regs, mm_reg1_t *regs, mm128_t *a)\n{ // squeeze out regions in a[] that are not referenced by regs[]\n\tint i, as = 0;\n\tuint64_t *aux;\n\taux = (uint64_t*)kmalloc(km, n_regs * 8);\n\tfor (i = 0; i < n_regs; ++i)\n\t\taux[i] = (uint64_t)regs[i].as << 32 | i;\n\tradix_sort_64(aux, aux + n_regs);\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[(int32_t)aux[i]];\n\t\tif (r->as != as) {\n\t\t\tmemmove(&a[as], &a[r->as], r->cnt * 16);\n\t\t\tr->as = as;\n\t\t}\n\t\tas += r->cnt;\n\t}\n\tkfree(km, aux);\n\treturn as;\n}\n\nmm_seg_t *mm_seg_gen(void *km, uint32_t hash, int n_segs, const int *qlens, int n_regs0, const mm_reg1_t *regs0, int *n_regs, mm_reg1_t **regs, const mm128_t *a)\n{\n\tint s, i, j, acc_qlen[MM_MAX_SEG+1], qlen_sum = 0;\n\tmm_seg_t *seg;\n\n\tassert(n_segs <= MM_MAX_SEG);\n\tfor (s = 1, acc_qlen[0] = 0; s < n_segs; ++s)\n\t\tacc_qlen[s] = acc_qlen[s-1] + qlens[s-1];\n\tqlen_sum = acc_qlen[n_segs - 1] + qlens[n_segs - 1];\n\n\tseg = (mm_seg_t*)kcalloc(km, n_segs, sizeof(mm_seg_t));\n\tfor (s = 0; s < n_segs; ++s) {\n\t\tseg[s].u = (uint64_t*)kmalloc(km, n_regs0 * 8);\n\t\tfor (i = 0; i < n_regs0; ++i)\n\t\t\tseg[s].u[i] = (uint64_t)regs0[i].score << 32;\n\t}\n\tfor (i = 0; i < n_regs0; ++i) {\n\t\tconst mm_reg1_t *r = &regs0[i];\n\t\tfor (j = 0; j < r->cnt; ++j) {\n\t\t\tint sid = (a[r->as + j].y&MM_SEED_SEG_MASK)>>MM_SEED_SEG_SHIFT;\n\t\t\t++seg[sid].u[i];\n\t\t\t++seg[sid].n_a;\n\t\t}\n\t}\n\tfor (s = 0; s < n_segs; ++s) {\n\t\tmm_seg_t *sr = &seg[s];\n\t\tfor (i = 0, sr->n_u = 0; i < n_regs0; ++i) // squeeze out zero-length per-segment chains\n\t\t\tif ((int32_t)sr->u[i] != 0)\n\t\t\t\tsr->u[sr->n_u++] = sr->u[i];\n\t\tsr->a = (mm128_t*)kmalloc(km, sr->n_a * sizeof(mm128_t));\n\t\tsr->n_a = 0;\n\t}\n\n\tfor (i = 0; i < n_regs0; ++i) {\n\t\tconst mm_reg1_t *r = &regs0[i];\n\t\tfor (j = 0; j < r->cnt; ++j) {\n\t\t\tint sid = (a[r->as + j].y&MM_SEED_SEG_MASK)>>MM_SEED_SEG_SHIFT;\n\t\t\tmm128_t a1 = a[r->as + j];\n\t\t\t// on reverse strand, the segment position is:\n\t\t\t//   x_for_cat = qlen_sum - 1 - (int32_t)a1.y - 1 + q_span\n\t\t\t//   (int32_t)new_a1.y = qlens[sid] - (x_for_cat - acc_qlen[sid] + 1 - q_span) - 1 = (int32_t)a1.y - (qlen_sum - (qlens[sid] + acc_qlen[sid]))\n\t\t\ta1.y -= a1.x>>63? qlen_sum - (qlens[sid] + acc_qlen[sid]) : acc_qlen[sid];\n\t\t\tseg[sid].a[seg[sid].n_a++] = a1;\n\t\t}\n\t}\n\tfor (s = 0; s < n_segs; ++s) {\n\t\tregs[s] = mm_gen_regs(km, hash, qlens[s], seg[s].n_u, seg[s].u, seg[s].a, 0);\n\t\tn_regs[s] = seg[s].n_u;\n\t\tfor (i = 0; i < n_regs[s]; ++i) {\n\t\t\tregs[s][i].seg_split = 1;\n\t\t\tregs[s][i].seg_id = s;\n\t\t}\n\t}\n\treturn seg;\n}\n\nvoid mm_seg_free(void *km, int n_segs, mm_seg_t *segs)\n{\n\tint i;\n\tfor (i = 0; i < n_segs; ++i) kfree(km, segs[i].u);\n\tfor (i = 0; i < n_segs; ++i) kfree(km, segs[i].a);\n\tkfree(km, segs);\n}\n\nstatic void mm_set_inv_mapq(void *km, int n_regs, mm_reg1_t *regs)\n{\n\tint i, n_aux;\n\tmm128_t *aux;\n\tif (n_regs < 3) return;\n\tfor (i = 0; i < n_regs; ++i)\n\t\tif (regs[i].inv) break;\n\tif (i == n_regs) return; // no inversion hits\n\n\taux = (mm128_t*)kmalloc(km, n_regs * 16);\n\tfor (i = n_aux = 0; i < n_regs; ++i)\n\t\tif (regs[i].parent == i || regs[i].parent < 0)\n\t\t\taux[n_aux].y = i, aux[n_aux++].x = (uint64_t)regs[i].rid << 32 | regs[i].rs;\n\tradix_sort_128x(aux, aux + n_aux);\n\n\tfor (i = 1; i < n_aux - 1; ++i) {\n\t\tmm_reg1_t *inv = &regs[aux[i].y];\n\t\tif (inv->inv) {\n\t\t\tmm_reg1_t *l = &regs[aux[i-1].y];\n\t\t\tmm_reg1_t *r = &regs[aux[i+1].y];\n\t\t\tinv->mapq = l->mapq < r->mapq? l->mapq : r->mapq;\n\t\t}\n\t}\n\tkfree(km, aux);\n}\n\nvoid mm_set_mapq(void *km, int n_regs, mm_reg1_t *regs, int min_chain_sc, int match_sc, int rep_len, int is_sr)\n{\n\tstatic const float q_coef = 40.0f;\n\tint64_t sum_sc = 0;\n\tfloat uniq_ratio;\n\tint i;\n\tif (n_regs == 0) return;\n\tfor (i = 0; i < n_regs; ++i)\n\t\tif (regs[i].parent == regs[i].id)\n\t\t\tsum_sc += regs[i].score;\n\tuniq_ratio = (float)sum_sc / (sum_sc + rep_len);\n\tfor (i = 0; i < n_regs; ++i) {\n\t\tmm_reg1_t *r = &regs[i];\n\t\tif (r->inv) {\n\t\t\tr->mapq = 0;\n\t\t} else if (r->parent == r->id) {\n\t\t\tint mapq, subsc;\n\t\t\tfloat pen_s1 = (r->score > 100? 1.0f : 0.01f * r->score) * uniq_ratio;\n\t\t\tfloat pen_cm = r->cnt > 10? 1.0f : 0.1f * r->cnt;\n\t\t\tpen_cm = pen_s1 < pen_cm? pen_s1 : pen_cm;\n\t\t\tsubsc = r->subsc > min_chain_sc? r->subsc : min_chain_sc;\n\t\t\tif (r->p && r->p->dp_max2 > 0 && r->p->dp_max > 0) {\n\t\t\t\tfloat identity = (float)r->mlen / r->blen;\n\t\t\t\tfloat x = (float)r->p->dp_max2 * subsc / r->p->dp_max / r->score0;\n\t\t\t\tmapq = (int)(identity * pen_cm * q_coef * (1.0f - x * x) * logf((float)r->p->dp_max / match_sc));\n\t\t\t\tif (!is_sr) {\n\t\t\t\t\tint mapq_alt = (int)(6.02f * identity * identity * (r->p->dp_max - r->p->dp_max2) / match_sc + .499f); // BWA-MEM like mapQ, mostly for short reads\n\t\t\t\t\tmapq = mapq < mapq_alt? mapq : mapq_alt; // in case the long-read heuristic fails\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfloat x = (float)subsc / r->score0;\n\t\t\t\tif (r->p) {\n\t\t\t\t\tfloat identity = (float)r->mlen / r->blen;\n\t\t\t\t\tmapq = (int)(identity * pen_cm * q_coef * (1.0f - x) * logf((float)r->p->dp_max / match_sc));\n\t\t\t\t} else {\n\t\t\t\t\tmapq = (int)(pen_cm * q_coef * (1.0f - x) * logf(r->score));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapq -= (int)(4.343f * logf(r->n_sub + 1) + .499f);\n\t\t\tmapq = mapq > 0? mapq : 0;\n\t\t\tr->mapq = mapq < 60? mapq : 60;\n\t\t\tif (r->p && r->p->dp_max > r->p->dp_max2 && r->mapq == 0) r->mapq = 1;\n\t\t} else r->mapq = 0;\n\t}\n\tmm_set_inv_mapq(km, n_regs, regs);\n}\n"
        },
        {
          "name": "index.c",
          "type": "blob",
          "size": 24.0390625,
          "content": "#include <stdlib.h>\n#include <assert.h>\n#if defined(WIN32) || defined(_WIN32)\n#include <io.h> // for open(2)\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n#include <stdio.h>\n#define __STDC_LIMIT_MACROS\n#include \"kthread.h\"\n#include \"bseq.h\"\n#include \"minimap.h\"\n#include \"mmpriv.h\"\n#include \"ksw2.h\"\n#include \"kvec.h\"\n#include \"khash.h\"\n\n#define idx_hash(a) ((a)>>1)\n#define idx_eq(a, b) ((a)>>1 == (b)>>1)\nKHASH_INIT(idx, uint64_t, uint64_t, 1, idx_hash, idx_eq)\ntypedef khash_t(idx) idxhash_t;\n\nKHASH_MAP_INIT_STR(str, uint32_t)\n\n#define kroundup64(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, (x)|=(x)>>32, ++(x))\n\ntypedef struct mm_idx_bucket_s {\n\tmm128_v a;   // (minimizer, position) array\n\tint32_t n;   // size of the _p_ array\n\tuint64_t *p; // position array for minimizers appearing >1 times\n\tvoid *h;     // hash table indexing _p_ and minimizers appearing once\n} mm_idx_bucket_t;\n\ntypedef struct {\n\tint32_t st, en, max; // max is not used for now\n\tint32_t score:30, strand:2;\n} mm_idx_intv1_t;\n\ntypedef struct mm_idx_intv_s {\n\tint32_t n, m;\n\tmm_idx_intv1_t *a;\n} mm_idx_intv_t;\n\nmm_idx_t *mm_idx_init(int w, int k, int b, int flag)\n{\n\tmm_idx_t *mi;\n\tif (k*2 < b) b = k * 2;\n\tif (w < 1) w = 1;\n\tmi = (mm_idx_t*)calloc(1, sizeof(mm_idx_t));\n\tmi->w = w, mi->k = k, mi->b = b, mi->flag = flag;\n\tmi->B = (mm_idx_bucket_t*)calloc(1<<b, sizeof(mm_idx_bucket_t));\n\tif (!(mm_dbg_flag & 1)) mi->km = km_init();\n\treturn mi;\n}\n\nvoid mm_idx_destroy(mm_idx_t *mi)\n{\n\tuint32_t i;\n\tif (mi == 0) return;\n\tif (mi->h) kh_destroy(str, (khash_t(str)*)mi->h);\n\tif (mi->B) {\n\t\tfor (i = 0; i < 1U<<mi->b; ++i) {\n\t\t\tfree(mi->B[i].p);\n\t\t\tfree(mi->B[i].a.a);\n\t\t\tkh_destroy(idx, (idxhash_t*)mi->B[i].h);\n\t\t}\n\t}\n\tif (mi->spsc) free(mi->spsc);\n\tif (mi->I) {\n\t\tfor (i = 0; i < mi->n_seq; ++i)\n\t\t\tfree(mi->I[i].a);\n\t\tfree(mi->I);\n\t}\n\tif (!mi->km) {\n\t\tfor (i = 0; i < mi->n_seq; ++i)\n\t\t\tfree(mi->seq[i].name);\n\t\tfree(mi->seq);\n\t} else km_destroy(mi->km);\n\tfree(mi->B); free(mi->S); free(mi);\n}\n\nconst uint64_t *mm_idx_get(const mm_idx_t *mi, uint64_t minier, int *n)\n{\n\tint mask = (1<<mi->b) - 1;\n\tkhint_t k;\n\tmm_idx_bucket_t *b = &mi->B[minier&mask];\n\tidxhash_t *h = (idxhash_t*)b->h;\n\t*n = 0;\n\tif (h == 0) return 0;\n\tk = kh_get(idx, h, minier>>mi->b<<1);\n\tif (k == kh_end(h)) return 0;\n\tif (kh_key(h, k)&1) { // special casing when there is only one k-mer\n\t\t*n = 1;\n\t\treturn &kh_val(h, k);\n\t} else {\n\t\t*n = (uint32_t)kh_val(h, k);\n\t\treturn &b->p[kh_val(h, k)>>32];\n\t}\n}\n\nvoid mm_idx_stat(const mm_idx_t *mi)\n{\n\tint n = 0, n1 = 0;\n\tuint32_t i;\n\tuint64_t sum = 0, len = 0;\n\tfprintf(stderr, \"[M::%s] kmer size: %d; skip: %d; is_hpc: %d; #seq: %d\\n\", __func__, mi->k, mi->w, mi->flag&MM_I_HPC, mi->n_seq);\n\tfor (i = 0; i < mi->n_seq; ++i)\n\t\tlen += mi->seq[i].len;\n\tfor (i = 0; i < 1U<<mi->b; ++i)\n\t\tif (mi->B[i].h) n += kh_size((idxhash_t*)mi->B[i].h);\n\tfor (i = 0; i < 1U<<mi->b; ++i) {\n\t\tidxhash_t *h = (idxhash_t*)mi->B[i].h;\n\t\tkhint_t k;\n\t\tif (h == 0) continue;\n\t\tfor (k = 0; k < kh_end(h); ++k)\n\t\t\tif (kh_exist(h, k)) {\n\t\t\t\tsum += kh_key(h, k)&1? 1 : (uint32_t)kh_val(h, k);\n\t\t\t\tif (kh_key(h, k)&1) ++n1;\n\t\t\t}\n\t}\n\tfprintf(stderr, \"[M::%s::%.3f*%.2f] distinct minimizers: %d (%.2f%% are singletons); average occurrences: %.3lf; average spacing: %.3lf; total length: %ld\\n\",\n\t\t\t__func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), n, 100.0*n1/n, (double)sum / n, (double)len / sum, (long)len);\n}\n\nint mm_idx_index_name(mm_idx_t *mi)\n{\n\tkhash_t(str) *h;\n\tuint32_t i;\n\tint has_dup = 0, absent;\n\tif (mi->h) return 0;\n\th = kh_init(str);\n\tfor (i = 0; i < mi->n_seq; ++i) {\n\t\tkhint_t k;\n\t\tk = kh_put(str, h, mi->seq[i].name, &absent);\n\t\tif (absent) kh_val(h, k) = i;\n\t\telse has_dup = 1;\n\t}\n\tmi->h = h;\n\tif (has_dup && mm_verbose >= 2)\n\t\tfprintf(stderr, \"[WARNING] some database sequences have identical sequence names\\n\");\n\treturn has_dup;\n}\n\nint mm_idx_name2id(const mm_idx_t *mi, const char *name)\n{\n\tkhash_t(str) *h = (khash_t(str)*)mi->h;\n\tkhint_t k;\n\tif (h == 0) return -2;\n\tk = kh_get(str, h, name);\n\treturn k == kh_end(h)? -1 : kh_val(h, k);\n}\n\nint mm_idx_getseq(const mm_idx_t *mi, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq)\n{\n\tuint64_t i, st1, en1;\n\tif (rid >= mi->n_seq || st >= mi->seq[rid].len) return -1;\n\tif (en > mi->seq[rid].len) en = mi->seq[rid].len;\n\tst1 = mi->seq[rid].offset + st;\n\ten1 = mi->seq[rid].offset + en;\n\tfor (i = st1; i < en1; ++i)\n\t\tseq[i - st1] = mm_seq4_get(mi->S, i);\n\treturn en - st;\n}\n\nint mm_idx_getseq_rev(const mm_idx_t *mi, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq)\n{\n\tuint64_t i, st1, en1;\n\tconst mm_idx_seq_t *s;\n\tif (rid >= mi->n_seq || st >= mi->seq[rid].len) return -1;\n\ts = &mi->seq[rid];\n\tif (en > s->len) en = s->len;\n\tst1 = s->offset + (s->len - en);\n\ten1 = s->offset + (s->len - st);\n\tfor (i = st1; i < en1; ++i) {\n\t\tuint8_t c = mm_seq4_get(mi->S, i);\n\t\tseq[en1 - i - 1] = c < 4? 3 - c : c;\n\t}\n\treturn en - st;\n}\n\nint mm_idx_getseq2(const mm_idx_t *mi, int is_rev, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq)\n{\n\tif (is_rev) return mm_idx_getseq_rev(mi, rid, st, en, seq);\n\telse return mm_idx_getseq(mi, rid, st, en, seq);\n}\n\nint32_t mm_idx_cal_max_occ(const mm_idx_t *mi, float f)\n{\n\tint i;\n\tsize_t n = 0;\n\tuint32_t thres;\n\tkhint_t *a, k;\n\tif (f <= 0.) return INT32_MAX;\n\tfor (i = 0; i < 1<<mi->b; ++i)\n\t\tif (mi->B[i].h) n += kh_size((idxhash_t*)mi->B[i].h);\n\tif (n == 0) return INT32_MAX;\n\ta = (uint32_t*)malloc(n * 4);\n\tfor (i = n = 0; i < 1<<mi->b; ++i) {\n\t\tidxhash_t *h = (idxhash_t*)mi->B[i].h;\n\t\tif (h == 0) continue;\n\t\tfor (k = 0; k < kh_end(h); ++k) {\n\t\t\tif (!kh_exist(h, k)) continue;\n\t\t\ta[n++] = kh_key(h, k)&1? 1 : (uint32_t)kh_val(h, k);\n\t\t}\n\t}\n\tthres = ks_ksmall_uint32_t(n, a, (uint32_t)((1. - f) * n)) + 1;\n\tfree(a);\n\treturn thres;\n}\n\n/*********************************\n * Sort and generate hash tables *\n *********************************/\n\nstatic void worker_post(void *g, long i, int tid)\n{\n\tint n, n_keys;\n\tsize_t j, start_a, start_p;\n\tidxhash_t *h;\n\tmm_idx_t *mi = (mm_idx_t*)g;\n\tmm_idx_bucket_t *b = &mi->B[i];\n\tif (b->a.n == 0) return;\n\n\t// sort by minimizer\n\tradix_sort_128x(b->a.a, b->a.a + b->a.n);\n\n\t// count and preallocate\n\tfor (j = 1, n = 1, n_keys = 0, b->n = 0; j <= b->a.n; ++j) {\n\t\tif (j == b->a.n || b->a.a[j].x>>8 != b->a.a[j-1].x>>8) {\n\t\t\t++n_keys;\n\t\t\tif (n > 1) b->n += n;\n\t\t\tn = 1;\n\t\t} else ++n;\n\t}\n\th = kh_init(idx);\n\tkh_resize(idx, h, n_keys);\n\tb->p = (uint64_t*)calloc(b->n, 8);\n\n\t// create the hash table\n\tfor (j = 1, n = 1, start_a = start_p = 0; j <= b->a.n; ++j) {\n\t\tif (j == b->a.n || b->a.a[j].x>>8 != b->a.a[j-1].x>>8) {\n\t\t\tkhint_t itr;\n\t\t\tint absent;\n\t\t\tmm128_t *p = &b->a.a[j-1];\n\t\t\titr = kh_put(idx, h, p->x>>8>>mi->b<<1, &absent);\n\t\t\tassert(absent && j == start_a + n);\n\t\t\tif (n == 1) {\n\t\t\t\tkh_key(h, itr) |= 1;\n\t\t\t\tkh_val(h, itr) = p->y;\n\t\t\t} else {\n\t\t\t\tint k;\n\t\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t\t\tb->p[start_p + k] = b->a.a[start_a + k].y;\n\t\t\t\tradix_sort_64(&b->p[start_p], &b->p[start_p + n]); // sort by position; needed as in-place radix_sort_128x() is not stable\n\t\t\t\tkh_val(h, itr) = (uint64_t)start_p<<32 | n;\n\t\t\t\tstart_p += n;\n\t\t\t}\n\t\t\tstart_a = j, n = 1;\n\t\t} else ++n;\n\t}\n\tb->h = h;\n\tassert(b->n == (int32_t)start_p);\n\n\t// deallocate and clear b->a\n\tkfree(0, b->a.a);\n\tb->a.n = b->a.m = 0, b->a.a = 0;\n}\n \nstatic void mm_idx_post(mm_idx_t *mi, int n_threads)\n{\n\tkt_for(n_threads, worker_post, mi, 1<<mi->b);\n}\n\n/******************\n * Generate index *\n ******************/\n\n#include <string.h>\n#include <zlib.h>\n#include \"bseq.h\"\n\ntypedef struct {\n\tint mini_batch_size;\n\tuint64_t batch_size, sum_len;\n\tmm_bseq_file_t *fp;\n\tmm_idx_t *mi;\n} pipeline_t;\n\ntypedef struct {\n    int n_seq;\n\tmm_bseq1_t *seq;\n\tmm128_v a;\n} step_t;\n\nstatic void mm_idx_add(mm_idx_t *mi, int n, const mm128_t *a)\n{\n\tint i, mask = (1<<mi->b) - 1;\n\tfor (i = 0; i < n; ++i) {\n\t\tmm128_v *p = &mi->B[a[i].x>>8&mask].a;\n\t\tkv_push(mm128_t, 0, *p, a[i]);\n\t}\n}\n\nstatic void *worker_pipeline(void *shared, int step, void *in)\n{\n\tint i;\n    pipeline_t *p = (pipeline_t*)shared;\n    if (step == 0) { // step 0: read sequences\n        step_t *s;\n\t\tif (p->sum_len > p->batch_size) return 0;\n        s = (step_t*)calloc(1, sizeof(step_t));\n\t\ts->seq = mm_bseq_read(p->fp, p->mini_batch_size, 0, &s->n_seq); // read a mini-batch\n\t\tif (s->seq) {\n\t\t\tuint32_t old_m, m;\n\t\t\tassert((uint64_t)p->mi->n_seq + s->n_seq <= UINT32_MAX); // to prevent integer overflow\n\t\t\t// make room for p->mi->seq\n\t\t\told_m = p->mi->n_seq, m = p->mi->n_seq + s->n_seq;\n\t\t\tkroundup32(m); kroundup32(old_m);\n\t\t\tif (old_m != m)\n\t\t\t\tp->mi->seq = (mm_idx_seq_t*)krealloc(p->mi->km, p->mi->seq, m * sizeof(mm_idx_seq_t));\n\t\t\t// make room for p->mi->S\n\t\t\tif (!(p->mi->flag & MM_I_NO_SEQ)) {\n\t\t\t\tuint64_t sum_len, old_max_len, max_len;\n\t\t\t\tfor (i = 0, sum_len = 0; i < s->n_seq; ++i) sum_len += s->seq[i].l_seq;\n\t\t\t\told_max_len = (p->sum_len + 7) / 8;\n\t\t\t\tmax_len = (p->sum_len + sum_len + 7) / 8;\n\t\t\t\tkroundup64(old_max_len); kroundup64(max_len);\n\t\t\t\tif (old_max_len != max_len) {\n\t\t\t\t\tp->mi->S = (uint32_t*)realloc(p->mi->S, max_len * 4);\n\t\t\t\t\tmemset(&p->mi->S[old_max_len], 0, 4 * (max_len - old_max_len));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// populate p->mi->seq\n\t\t\tfor (i = 0; i < s->n_seq; ++i) {\n\t\t\t\tmm_idx_seq_t *seq = &p->mi->seq[p->mi->n_seq];\n\t\t\t\tuint32_t j;\n\t\t\t\tif (!(p->mi->flag & MM_I_NO_NAME)) {\n\t\t\t\t\tseq->name = (char*)kmalloc(p->mi->km, strlen(s->seq[i].name) + 1);\n\t\t\t\t\tstrcpy(seq->name, s->seq[i].name);\n\t\t\t\t} else seq->name = 0;\n\t\t\t\tseq->len = s->seq[i].l_seq;\n\t\t\t\tseq->offset = p->sum_len;\n\t\t\t\tseq->is_alt = 0;\n\t\t\t\t// copy the sequence\n\t\t\t\tif (!(p->mi->flag & MM_I_NO_SEQ)) {\n\t\t\t\t\tfor (j = 0; j < seq->len; ++j) { // TODO: this is not the fastest way, but let's first see if speed matters here\n\t\t\t\t\t\tuint64_t o = p->sum_len + j;\n\t\t\t\t\t\tint c = seq_nt4_table[(uint8_t)s->seq[i].seq[j]];\n\t\t\t\t\t\tmm_seq4_set(p->mi->S, o, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update p->sum_len and p->mi->n_seq\n\t\t\t\tp->sum_len += seq->len;\n\t\t\t\ts->seq[i].rid = p->mi->n_seq++;\n\t\t\t}\n\t\t\treturn s;\n\t\t} else free(s);\n    } else if (step == 1) { // step 1: compute sketch\n        step_t *s = (step_t*)in;\n\t\tfor (i = 0; i < s->n_seq; ++i) {\n\t\t\tmm_bseq1_t *t = &s->seq[i];\n\t\t\tif (t->l_seq > 0)\n\t\t\t\tmm_sketch(0, t->seq, t->l_seq, p->mi->w, p->mi->k, t->rid, p->mi->flag&MM_I_HPC, &s->a);\n\t\t\telse if (mm_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[WARNING] the length database sequence '%s' is 0\\n\", t->name);\n\t\t\tfree(t->seq); free(t->name);\n\t\t}\n\t\tfree(s->seq); s->seq = 0;\n\t\treturn s;\n    } else if (step == 2) { // dispatch sketch to buckets\n        step_t *s = (step_t*)in;\n\t\tmm_idx_add(p->mi, s->a.n, s->a.a);\n\t\tkfree(0, s->a.a); free(s);\n\t}\n    return 0;\n}\n\nmm_idx_t *mm_idx_gen(mm_bseq_file_t *fp, int w, int k, int b, int flag, int mini_batch_size, int n_threads, uint64_t batch_size)\n{\n\tpipeline_t pl;\n\tif (fp == 0 || mm_bseq_eof(fp)) return 0;\n\tmemset(&pl, 0, sizeof(pipeline_t));\n\tpl.mini_batch_size = (uint64_t)mini_batch_size < batch_size? mini_batch_size : batch_size;\n\tpl.batch_size = batch_size;\n\tpl.fp = fp;\n\tpl.mi = mm_idx_init(w, k, b, flag);\n\n\tkt_pipeline(n_threads < 3? n_threads : 3, worker_pipeline, &pl, 3);\n\tif (mm_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s::%.3f*%.2f] collected minimizers\\n\", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0));\n\n\tmm_idx_post(pl.mi, n_threads);\n\tif (mm_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s::%.3f*%.2f] sorted minimizers\\n\", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0));\n\n\treturn pl.mi;\n}\n\nmm_idx_t *mm_idx_build(const char *fn, int w, int k, int flag, int n_threads) // a simpler interface; deprecated\n{\n\tmm_bseq_file_t *fp;\n\tmm_idx_t *mi;\n\tfp = mm_bseq_open(fn);\n\tif (fp == 0) return 0;\n\tmi = mm_idx_gen(fp, w, k, 14, flag, 1<<18, n_threads, UINT64_MAX);\n\tmm_bseq_close(fp);\n\treturn mi;\n}\n\nmm_idx_t *mm_idx_str(int w, int k, int is_hpc, int bucket_bits, int n, const char **seq, const char **name)\n{\n\tuint64_t sum_len = 0;\n\tmm128_v a = {0,0,0};\n\tmm_idx_t *mi;\n\tkhash_t(str) *h;\n\tint i, flag = 0;\n\n\tif (n <= 0) return 0;\n\tfor (i = 0; i < n; ++i) // get the total length\n\t\tsum_len += strlen(seq[i]);\n\tif (is_hpc) flag |= MM_I_HPC;\n\tif (name == 0) flag |= MM_I_NO_NAME;\n\tif (bucket_bits < 0) bucket_bits = 14;\n\tmi = mm_idx_init(w, k, bucket_bits, flag);\n\tmi->n_seq = n;\n\tmi->seq = (mm_idx_seq_t*)kcalloc(mi->km, n, sizeof(mm_idx_seq_t)); // ->seq is allocated from km\n\tmi->S = (uint32_t*)calloc((sum_len + 7) / 8, 4);\n\tmi->h = h = kh_init(str);\n\tfor (i = 0, sum_len = 0; i < n; ++i) {\n\t\tconst char *s = seq[i];\n\t\tmm_idx_seq_t *p = &mi->seq[i];\n\t\tuint32_t j;\n\t\tif (name && name[i]) {\n\t\t\tint absent;\n\t\t\tp->name = (char*)kmalloc(mi->km, strlen(name[i]) + 1);\n\t\t\tstrcpy(p->name, name[i]);\n\t\t\tkh_put(str, h, p->name, &absent);\n\t\t\tassert(absent);\n\t\t}\n\t\tp->offset = sum_len;\n\t\tp->len = strlen(s);\n\t\tp->is_alt = 0;\n\t\tfor (j = 0; j < p->len; ++j) {\n\t\t\tint c = seq_nt4_table[(uint8_t)s[j]];\n\t\t\tuint64_t o = sum_len + j;\n\t\t\tmm_seq4_set(mi->S, o, c);\n\t\t}\n\t\tsum_len += p->len;\n\t\tif (p->len > 0) {\n\t\t\ta.n = 0;\n\t\t\tmm_sketch(0, s, p->len, w, k, i, is_hpc, &a);\n\t\t\tmm_idx_add(mi, a.n, a.a);\n\t\t}\n\t}\n\tfree(a.a);\n\tmm_idx_post(mi, 1);\n\treturn mi;\n}\n\n/*************\n * index I/O *\n *************/\n\nvoid mm_idx_dump(FILE *fp, const mm_idx_t *mi)\n{\n\tuint64_t sum_len = 0;\n\tuint32_t x[5], i;\n\n\tx[0] = mi->w, x[1] = mi->k, x[2] = mi->b, x[3] = mi->n_seq, x[4] = mi->flag;\n\tfwrite(MM_IDX_MAGIC, 1, 4, fp);\n\tfwrite(x, 4, 5, fp);\n\tfor (i = 0; i < mi->n_seq; ++i) {\n\t\tif (mi->seq[i].name) {\n\t\t\tuint8_t l = strlen(mi->seq[i].name);\n\t\t\tfwrite(&l, 1, 1, fp);\n\t\t\tfwrite(mi->seq[i].name, 1, l, fp);\n\t\t} else {\n\t\t\tuint8_t l = 0;\n\t\t\tfwrite(&l, 1, 1, fp);\n\t\t}\n\t\tfwrite(&mi->seq[i].len, 4, 1, fp);\n\t\tsum_len += mi->seq[i].len;\n\t}\n\tfor (i = 0; i < 1<<mi->b; ++i) {\n\t\tmm_idx_bucket_t *b = &mi->B[i];\n\t\tkhint_t k;\n\t\tidxhash_t *h = (idxhash_t*)b->h;\n\t\tuint32_t size = h? h->size : 0;\n\t\tfwrite(&b->n, 4, 1, fp);\n\t\tfwrite(b->p, 8, b->n, fp);\n\t\tfwrite(&size, 4, 1, fp);\n\t\tif (size == 0) continue;\n\t\tfor (k = 0; k < kh_end(h); ++k) {\n\t\t\tuint64_t x[2];\n\t\t\tif (!kh_exist(h, k)) continue;\n\t\t\tx[0] = kh_key(h, k), x[1] = kh_val(h, k);\n\t\t\tfwrite(x, 8, 2, fp);\n\t\t}\n\t}\n\tif (!(mi->flag & MM_I_NO_SEQ))\n\t\tfwrite(mi->S, 4, (sum_len + 7) / 8, fp);\n\tfflush(fp);\n}\n\nmm_idx_t *mm_idx_load(FILE *fp)\n{\n\tchar magic[4];\n\tuint32_t x[5], i;\n\tuint64_t sum_len = 0;\n\tmm_idx_t *mi;\n\n\tif (fread(magic, 1, 4, fp) != 4) return 0;\n\tif (strncmp(magic, MM_IDX_MAGIC, 4) != 0) return 0;\n\tif (fread(x, 4, 5, fp) != 5) return 0;\n\tmi = mm_idx_init(x[0], x[1], x[2], x[4]);\n\tmi->n_seq = x[3];\n\tmi->seq = (mm_idx_seq_t*)kcalloc(mi->km, mi->n_seq, sizeof(mm_idx_seq_t));\n\tfor (i = 0; i < mi->n_seq; ++i) {\n\t\tuint8_t l;\n\t\tmm_idx_seq_t *s = &mi->seq[i];\n\t\tfread(&l, 1, 1, fp);\n\t\tif (l) {\n\t\t\ts->name = (char*)kmalloc(mi->km, l + 1);\n\t\t\tfread(s->name, 1, l, fp);\n\t\t\ts->name[l] = 0;\n\t\t}\n\t\tfread(&s->len, 4, 1, fp);\n\t\ts->offset = sum_len;\n\t\ts->is_alt = 0;\n\t\tsum_len += s->len;\n\t}\n\tfor (i = 0; i < 1<<mi->b; ++i) {\n\t\tmm_idx_bucket_t *b = &mi->B[i];\n\t\tuint32_t j, size;\n\t\tkhint_t k;\n\t\tidxhash_t *h;\n\t\tfread(&b->n, 4, 1, fp);\n\t\tb->p = (uint64_t*)malloc(b->n * 8);\n\t\tfread(b->p, 8, b->n, fp);\n\t\tfread(&size, 4, 1, fp);\n\t\tif (size == 0) continue;\n\t\tb->h = h = kh_init(idx);\n\t\tkh_resize(idx, h, size);\n\t\tfor (j = 0; j < size; ++j) {\n\t\t\tuint64_t x[2];\n\t\t\tint absent;\n\t\t\tfread(x, 8, 2, fp);\n\t\t\tk = kh_put(idx, h, x[0], &absent);\n\t\t\tassert(absent);\n\t\t\tkh_val(h, k) = x[1];\n\t\t}\n\t}\n\tif (!(mi->flag & MM_I_NO_SEQ)) {\n\t\tmi->S = (uint32_t*)malloc((sum_len + 7) / 8 * 4);\n\t\tfread(mi->S, 4, (sum_len + 7) / 8, fp);\n\t}\n\treturn mi;\n}\n\nint64_t mm_idx_is_idx(const char *fn)\n{\n\tint fd, is_idx = 0;\n\tint64_t ret, off_end;\n\tchar magic[4];\n\n\tif (strcmp(fn, \"-\") == 0) return 0; // read from pipe; not an index\n\tfd = open(fn, O_RDONLY);\n\tif (fd < 0) return -1; // error\n#ifdef WIN32\n\tif ((off_end = _lseeki64(fd, 0, SEEK_END)) >= 4) {\n\t\t_lseeki64(fd, 0, SEEK_SET);\n#else\n\tif ((off_end = lseek(fd, 0, SEEK_END)) >= 4) {\n\t\tlseek(fd, 0, SEEK_SET);\n#endif // WIN32\n\t\tret = read(fd, magic, 4);\n\t\tif (ret == 4 && strncmp(magic, MM_IDX_MAGIC, 4) == 0)\n\t\t\tis_idx = 1;\n\t}\n\tclose(fd);\n\treturn is_idx? off_end : 0;\n}\n\nmm_idx_reader_t *mm_idx_reader_open(const char *fn, const mm_idxopt_t *opt, const char *fn_out)\n{\n\tint64_t is_idx;\n\tmm_idx_reader_t *r;\n\tis_idx = mm_idx_is_idx(fn);\n\tif (is_idx < 0) return 0; // failed to open the index\n\tr = (mm_idx_reader_t*)calloc(1, sizeof(mm_idx_reader_t));\n\tr->is_idx = is_idx;\n\tif (opt) r->opt = *opt;\n\telse mm_idxopt_init(&r->opt);\n\tif (r->is_idx) {\n\t\tr->fp.idx = fopen(fn, \"rb\");\n\t\tr->idx_size = is_idx;\n\t} else r->fp.seq = mm_bseq_open(fn);\n\tif (fn_out) r->fp_out = fopen(fn_out, \"wb\");\n\treturn r;\n}\n\nvoid mm_idx_reader_close(mm_idx_reader_t *r)\n{\n\tif (r->is_idx) fclose(r->fp.idx);\n\telse mm_bseq_close(r->fp.seq);\n\tif (r->fp_out) fclose(r->fp_out);\n\tfree(r);\n}\n\nmm_idx_t *mm_idx_reader_read(mm_idx_reader_t *r, int n_threads)\n{\n\tmm_idx_t *mi;\n\tif (r->is_idx) {\n\t\tmi = mm_idx_load(r->fp.idx);\n\t\tif (mi && mm_verbose >= 2 && (mi->k != r->opt.k || mi->w != r->opt.w || (mi->flag&MM_I_HPC) != (r->opt.flag&MM_I_HPC)))\n\t\t\tfprintf(stderr, \"[WARNING]\\033[1;31m Indexing parameters (-k, -w or -H) overridden by parameters used in the prebuilt index.\\033[0m\\n\");\n\t} else\n\t\tmi = mm_idx_gen(r->fp.seq, r->opt.w, r->opt.k, r->opt.bucket_bits, r->opt.flag, r->opt.mini_batch_size, n_threads, r->opt.batch_size);\n\tif (mi) {\n\t\tif (r->fp_out) mm_idx_dump(r->fp_out, mi);\n\t\tmi->index = r->n_parts++;\n\t}\n\treturn mi;\n}\n\nint mm_idx_reader_eof(const mm_idx_reader_t *r) // TODO: in extremely rare cases, mm_bseq_eof() might not work\n{\n\treturn r->is_idx? (feof(r->fp.idx) || ftell(r->fp.idx) == r->idx_size) : mm_bseq_eof(r->fp.seq);\n}\n\n#include <ctype.h>\n#include <zlib.h>\n#include \"ksort.h\"\n#include \"kseq.h\"\nKSTREAM_DECLARE(gzFile, gzread)\n\nint mm_idx_alt_read(mm_idx_t *mi, const char *fn)\n{\n\tint n_alt = 0;\n\tgzFile fp;\n\tkstream_t *ks;\n\tkstring_t str = {0,0,0};\n\tfp = fn && strcmp(fn, \"-\")? gzopen(fn, \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (fp == 0) return -1;\n\tks = ks_init(fp);\n\tif (mi->h == 0) mm_idx_index_name(mi);\n\twhile (ks_getuntil(ks, KS_SEP_LINE, &str, 0) >= 0) {\n\t\tchar *p;\n\t\tint id;\n\t\tfor (p = str.s; *p && !isspace(*p); ++p) { }\n\t\t*p = 0;\n\t\tid = mm_idx_name2id(mi, str.s);\n\t\tif (id >= 0) mi->seq[id].is_alt = 1, ++n_alt;\n\t}\n\tmi->n_alt = n_alt;\n\tif (mm_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] found %d ALT contigs\\n\", __func__, n_alt);\n\treturn n_alt;\n}\n\n/*******************\n * Known junctions *\n *******************/\n\n#define sort_key_bed(a) ((a).st)\nKRADIX_SORT_INIT(bed, mm_idx_intv1_t, sort_key_bed, 4)\n\nmm_idx_intv_t *mm_idx_read_bed(const mm_idx_t *mi, const char *fn, int read_junc)\n{\n\tgzFile fp;\n\tkstream_t *ks;\n\tkstring_t str = {0,0,0};\n\tmm_idx_intv_t *I;\n\n\tfp = fn && strcmp(fn, \"-\")? gzopen(fn, \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (fp == 0) return 0;\n\tI = (mm_idx_intv_t*)calloc(mi->n_seq, sizeof(*I));\n\tks = ks_init(fp);\n\twhile (ks_getuntil(ks, KS_SEP_LINE, &str, 0) >= 0) {\n\t\tmm_idx_intv_t *r;\n\t\tmm_idx_intv1_t t = {-1,-1,-1,-1,0};\n\t\tchar *p, *q, *bl, *bs;\n\t\tint32_t i, id = -1, n_blk = 0;\n\t\tfor (p = q = str.s, i = 0;; ++p) {\n\t\t\tif (*p == 0 || *p == '\\t') {\n\t\t\t\tint32_t c = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tif (i == 0) { // chr\n\t\t\t\t\tid = mm_idx_name2id(mi, q);\n\t\t\t\t\tif (id < 0) break; // unknown name; TODO: throw a warning\n\t\t\t\t} else if (i == 1) { // start\n\t\t\t\t\tt.st = atol(q); // TODO: watch out integer overflow!\n\t\t\t\t\tif (t.st < 0) break;\n\t\t\t\t} else if (i == 2) { // end\n\t\t\t\t\tt.en = atol(q);\n\t\t\t\t\tif (t.en < 0) break;\n\t\t\t\t} else if (i == 4) { // BED score\n\t\t\t\t\tt.score = atol(q);\n\t\t\t\t} else if (i == 5) { // strand\n\t\t\t\t\tt.strand = *q == '+'? 1 : *q == '-'? -1 : 0;\n\t\t\t\t} else if (i == 9) {\n\t\t\t\t\tif (!isdigit(*q)) break;\n\t\t\t\t\tn_blk = atol(q);\n\t\t\t\t} else if (i == 10) {\n\t\t\t\t\tbl = q;\n\t\t\t\t} else if (i == 11) {\n\t\t\t\t\tbs = q;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (c == 0) break;\n\t\t\t\t++i, q = p + 1;\n\t\t\t}\n\t\t}\n\t\tif (id < 0 || t.st < 0 || t.st >= t.en) continue;\n\t\tr = &I[id];\n\t\tif (i >= 11 && read_junc) { // BED12\n\t\t\tint32_t st, sz, en;\n\t\t\tst = strtol(bs, &bs, 10); ++bs;\n\t\t\tsz = strtol(bl, &bl, 10); ++bl;\n\t\t\ten = t.st + st + sz;\n\t\t\tfor (i = 1; i < n_blk; ++i) {\n\t\t\t\tmm_idx_intv1_t s = t;\n\t\t\t\tif (r->n == r->m) {\n\t\t\t\t\tr->m = r->m? r->m + (r->m>>1) : 16;\n\t\t\t\t\tr->a = (mm_idx_intv1_t*)realloc(r->a, sizeof(*r->a) * r->m);\n\t\t\t\t}\n\t\t\t\tst = strtol(bs, &bs, 10); ++bs;\n\t\t\t\tsz = strtol(bl, &bl, 10); ++bl;\n\t\t\t\ts.st = en, s.en = t.st + st;\n\t\t\t\ten = t.st + st + sz;\n\t\t\t\tif (s.en > s.st) r->a[r->n++] = s;\n\t\t\t}\n\t\t} else {\n\t\t\tif (r->n == r->m) {\n\t\t\t\tr->m = r->m? r->m + (r->m>>1) : 16;\n\t\t\t\tr->a = (mm_idx_intv1_t*)realloc(r->a, sizeof(*r->a) * r->m);\n\t\t\t}\n\t\t\tr->a[r->n++] = t;\n\t\t}\n\t}\n\tfree(str.s);\n\tks_destroy(ks);\n\tgzclose(fp);\n\treturn I;\n}\n\nint mm_idx_bed_read(mm_idx_t *mi, const char *fn, int read_junc)\n{\n\tint32_t i;\n\tif (mi->h == 0) mm_idx_index_name(mi);\n\tmi->I = mm_idx_read_bed(mi, fn, read_junc);\n\tif (mi->I == 0) return -1;\n\tfor (i = 0; i < mi->n_seq; ++i) // TODO: eliminate redundant intervals\n\t\tradix_sort_bed(mi->I[i].a, mi->I[i].a + mi->I[i].n);\n\treturn 0;\n}\n\nint mm_idx_bed_junc(const mm_idx_t *mi, int32_t ctg, int32_t st, int32_t en, uint8_t *s)\n{\n\tint32_t i, left, right;\n\tmm_idx_intv_t *r;\n\tmemset(s, 0, en - st);\n\tif (mi->I == 0 || ctg < 0 || ctg >= mi->n_seq) return -1;\n\tr = &mi->I[ctg];\n\tleft = 0, right = r->n;\n\twhile (right > left) {\n\t\tint32_t mid = left + ((right - left) >> 1);\n\t\tif (r->a[mid].st >= st) right = mid;\n\t\telse left = mid + 1;\n\t}\n\tfor (i = left; i < r->n; ++i) {\n\t\tif (st <= r->a[i].st && en >= r->a[i].en && r->a[i].strand != 0) {\n\t\t\tif (r->a[i].strand > 0) {\n\t\t\t\ts[r->a[i].st - st] |= 1, s[r->a[i].en - 1 - st] |= 2;\n\t\t\t} else {\n\t\t\t\ts[r->a[i].st - st] |= 8, s[r->a[i].en - 1 - st] |= 4;\n\t\t\t}\n\t\t}\n\t}\n\treturn left;\n}\n\n/****************\n * splice score *\n ****************/\n\ntypedef struct mm_idx_spsc_s {\n\tuint32_t n, m;\n\tuint64_t *a; // pos<<56 | score<<1 | acceptor\n} mm_idx_spsc_t;\n\nint32_t mm_idx_spsc_read(mm_idx_t *idx, const char *fn, int32_t max_sc)\n{\n\tgzFile fp;\n\tkstring_t str = {0,0,0};\n\tkstream_t *ks;\n\tint32_t dret, j;\n\tint64_t n_read = 0;\n\n\tfp = fn && strcmp(fn, \"-\") != 0? gzopen(fn, \"rb\") : gzdopen(0, \"rb\");\n\tif (fp == 0) return -1;\n\tif (idx->h == 0) mm_idx_index_name(idx);\n\tif (max_sc > 63) max_sc = 63;\n\tidx->spsc = Kcalloc(0, mm_idx_spsc_t, idx->n_seq * 2);\n\tks = ks_init(fp);\n\twhile (ks_getuntil(ks, KS_SEP_LINE, &str, &dret) >= 0) {\n\t\tmm_idx_spsc_t *s;\n\t\tchar *p, *q, *name = 0;\n\t\tint32_t i, type = -1, strand = 0, cid = -1, score = -1;\n\t\tint64_t pos = -1;\n\t\tfor (i = 0, p = q = str.s;; ++p) {\n\t\t\tif (*p == '\\t' || *p == 0) {\n\t\t\t\tint c = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tname = q;\n\t\t\t\t} else if (i == 1) {\n\t\t\t\t\tpos = atol(q);\n\t\t\t\t} else if (i == 2) {\n\t\t\t\t\tstrand = *q == '+'? 1 : '-'? -1 : 0;\n\t\t\t\t} else if (i == 3) {\n\t\t\t\t\ttype = *q == 'D'? 0 : *q == 'A'? 1 : -1;\n\t\t\t\t} else if (i == 4) {\n\t\t\t\t\tscore = atoi(q);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (c == 0) break;\n\t\t\t\tq = p + 1, ++i;\n\t\t\t}\n\t\t}\n\t\tif (i < 4) continue; // not enough fields\n\t\tif (score > max_sc) score = max_sc;\n\t\tif (score < -max_sc) score = -max_sc;\n\t\tcid = mm_idx_name2id(idx, name);\n\t\tif (cid < 0 || type < 0 || strand == 0 || pos < 0) continue; // FIXME: give a warning!\n\t\ts = &idx->spsc[cid << 1 | (strand > 0? 0 : 1)];\n\t\tKgrow(0, uint64_t, s->a, s->n, s->m);\n\t\tif (pos > 0 && pos < idx->seq[cid].len) { // ignore scores at the ends\n\t\t\ts->a[s->n++] = (uint64_t)pos << 8 | (score + KSW_SPSC_OFFSET) << 1 | type;\n\t\t\t++n_read;\n\t\t}\n\t}\n\tks_destroy(ks);\n\tgzclose(fp);\n\tfor (j = 0; j < idx->n_seq * 2; ++j) {\n\t\tmm_idx_spsc_t *s = &idx->spsc[j];\n\t\tif (s->n > 0)\n\t\t\tradix_sort_64(s->a, s->a + s->n);\n\t}\n\tif (mm_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] read %ld splice scores\\n\", __func__, (long)n_read);\n\treturn 0;\n}\n\nstatic int32_t mm_idx_find_intv(int32_t n, const uint64_t *a, int64_t x)\n{\n\tint32_t s = 0, e = n;\n\tif (n == 0) return -1;\n\tif (x < a[0]>>8) return -1;\n\twhile (s < e) {\n\t\tint32_t mid = s + (e - s) / 2;\n\t\tif (x >= a[mid]>>8 && (mid + 1 >= n || x < a[mid+1]>>8)) return mid;\n\t\telse if (x < a[mid]>>8) e = mid;\n\t\telse s = mid + 1;\n\t}\n\tassert(0);\n}\n\nint64_t mm_idx_spsc_get(const mm_idx_t *db, int32_t cid, int64_t st, int64_t en, int32_t rev, uint8_t *sc)\n{\n\tconst mm_idx_spsc_t *s;\n\tif (cid >= db->n_seq || cid < 0 || db->spsc == 0) return -1;\n\tif (en < 0 || en > db->seq[cid].len) en = db->seq[cid].len;\n\tmemset(sc, 0xff, en - st);\n\ts = &db->spsc[cid << 1 | (!!rev)];\n\tif (s->n > 0) {\n\t\tint32_t j, l, r;\n\t\tl = mm_idx_find_intv(s->n, s->a, st);\n\t\tr = mm_idx_find_intv(s->n, s->a, en);\n\t\tfor (j = l + 1; j <= r; ++j) {\n\t\t\tint64_t x = (s->a[j]>>8) - st;\n\t\t\tuint8_t score = s->a[j] & 0xff;\n\t\t\tassert(x <= en - st);\n\t\t\tif (x == en - st) continue;\n\t\t\tif (sc[x] == 0xff || sc[x] < score) sc[x] = score;\n\t\t}\n\t}\n\treturn en - st;\n}\n"
        },
        {
          "name": "kalloc.c",
          "type": "blob",
          "size": 7.865234375,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"kalloc.h\"\n\n/* In kalloc, a *core* is a large chunk of contiguous memory. Each core is\n * associated with a master header, which keeps the size of the current core\n * and the pointer to next core. Kalloc allocates small *blocks* of memory from\n * the cores and organizes free memory blocks in a circular single-linked list.\n *\n * In the following diagram, \"@\" stands for the header of a free block (of type\n * header_t), \"#\" for the header of an allocated block (of type size_t), \"-\"\n * for free memory, and \"+\" for allocated memory.\n *\n * master        This region is core 1.          master           This region is core 2.\n *      |                                             |\n *      *@-------#++++++#++++++++++++@--------        *@----------#++++++++++++#+++++++@------------\n *       |                           |                 |                               |\n *       p=p->ptr->ptr->ptr->ptr     p->ptr            p->ptr->ptr                     p->ptr->ptr->ptr\n */\ntypedef struct header_t {\n\tsize_t size;\n\tstruct header_t *ptr;\n} header_t;\n\ntypedef struct {\n\tvoid *par;\n\tsize_t min_core_size;\n\theader_t base, *loop_head, *core_head; /* base is a zero-sized block always kept in the loop */\n} kmem_t;\n\nstatic void panic(const char *s)\n{\n\tfprintf(stderr, \"%s\\n\", s);\n\tabort();\n}\n\nvoid *km_init2(void *km_par, size_t min_core_size)\n{\n\tkmem_t *km;\n\tkm = (kmem_t*)kcalloc(km_par, 1, sizeof(kmem_t));\n\tkm->par = km_par;\n\tif (km_par) km->min_core_size = min_core_size > 0? min_core_size : ((kmem_t*)km_par)->min_core_size - 2;\n\telse km->min_core_size = min_core_size > 0? min_core_size : 0x80000;\n\treturn (void*)km;\n}\n\nvoid *km_init(void) { return km_init2(0, 0); }\n\nvoid km_destroy(void *_km)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tvoid *km_par;\n\theader_t *p, *q;\n\tif (km == NULL) return;\n\tkm_par = km->par;\n\tfor (p = km->core_head; p != NULL;) {\n\t\tq = p->ptr;\n\t\tkfree(km_par, p);\n\t\tp = q;\n\t}\n\tkfree(km_par, km);\n}\n\nstatic header_t *morecore(kmem_t *km, size_t nu)\n{\n\theader_t *q;\n\tsize_t bytes, *p;\n\tnu = (nu + 1 + (km->min_core_size - 1)) / km->min_core_size * km->min_core_size; /* the first +1 for core header */\n\tbytes = nu * sizeof(header_t);\n\tq = (header_t*)kmalloc(km->par, bytes);\n\tif (!q) panic(\"[morecore] insufficient memory\");\n\tq->ptr = km->core_head, q->size = nu, km->core_head = q;\n\tp = (size_t*)(q + 1);\n\t*p = nu - 1; /* the size of the free block; -1 because the first unit is used for the core header */\n\tkfree(km, p + 1); /* initialize the new \"core\"; NB: the core header is not looped. */\n\treturn km->loop_head;\n}\n\nvoid kfree(void *_km, void *ap) /* kfree() also adds a new core to the circular list */\n{\n\theader_t *p, *q;\n\tkmem_t *km = (kmem_t*)_km;\n\t\n\tif (!ap) return;\n\tif (km == NULL) {\n\t\tfree(ap);\n\t\treturn;\n\t}\n\tp = (header_t*)((size_t*)ap - 1);\n\tp->size = *((size_t*)ap - 1);\n\t/* Find the pointer that points to the block to be freed. The following loop can stop on two conditions:\n\t *\n\t * a) \"p>q && p<q->ptr\": @------#++++++++#+++++++@-------    @---------------#+++++++@-------\n\t *    (can also be in    |      |                |        -> |                       |\n\t *     two cores)        q      p           q->ptr           q                  q->ptr\n\t *\n\t *                       @--------    #+++++++++@--------    @--------    @------------------\n\t *                       |            |         |         -> |            |\n\t *                       q            p    q->ptr            q       q->ptr\n\t *\n\t * b) \"q>=q->ptr && (p>q || p<q->ptr)\":  @-------#+++++   @--------#+++++++     @-------#+++++   @----------------\n\t *                                       |                |        |         -> |                |\n\t *                                  q->ptr                q        p       q->ptr                q\n\t *\n\t *                                       #+++++++@-----   #++++++++@-------     @-------------   #++++++++@-------\n\t *                                       |       |                 |         -> |                         |\n\t *                                       p  q->ptr                 q       q->ptr                         q\n\t */\n\tfor (q = km->loop_head; !(p > q && p < q->ptr); q = q->ptr)\n\t\tif (q >= q->ptr && (p > q || p < q->ptr)) break;\n\tif (p + p->size == q->ptr) { /* two adjacent blocks, merge p and q->ptr (the 2nd and 4th cases) */\n\t\tp->size += q->ptr->size;\n\t\tp->ptr = q->ptr->ptr;\n\t} else if (p + p->size > q->ptr && q->ptr >= p) {\n\t\tpanic(\"[kfree] The end of the allocated block enters a free block.\");\n\t} else p->ptr = q->ptr; /* backup q->ptr */\n\n\tif (q + q->size == p) { /* two adjacent blocks, merge q and p (the other two cases) */\n\t\tq->size += p->size;\n\t\tq->ptr = p->ptr;\n\t\tkm->loop_head = q;\n\t} else if (q + q->size > p && p >= q) {\n\t\tpanic(\"[kfree] The end of a free block enters the allocated block.\");\n\t} else km->loop_head = p, q->ptr = p; /* in two cores, cannot be merged; create a new block in the list */\n}\n\nvoid *kmalloc(void *_km, size_t n_bytes)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tsize_t n_units;\n\theader_t *p, *q;\n\n\tif (n_bytes == 0) return 0;\n\tif (km == NULL) return malloc(n_bytes);\n\tn_units = (n_bytes + sizeof(size_t) + sizeof(header_t) - 1) / sizeof(header_t); /* header+n_bytes requires at least this number of units */\n\n\tif (!(q = km->loop_head)) /* the first time when kmalloc() is called, intialize it */\n\t\tq = km->loop_head = km->base.ptr = &km->base;\n\tfor (p = q->ptr;; q = p, p = p->ptr) { /* search for a suitable block */\n\t\tif (p->size >= n_units) { /* p->size if the size of current block. This line means the current block is large enough. */\n\t\t\tif (p->size == n_units) q->ptr = p->ptr; /* no need to split the block */\n\t\t\telse { /* split the block. NB: memory is allocated at the end of the block! */\n\t\t\t\tp->size -= n_units; /* reduce the size of the free block */\n\t\t\t\tp += p->size; /* p points to the allocated block */\n\t\t\t\t*(size_t*)p = n_units; /* set the size */\n\t\t\t}\n\t\t\tkm->loop_head = q; /* set the end of chain */\n\t\t\treturn (size_t*)p + 1;\n\t\t}\n\t\tif (p == km->loop_head) { /* then ask for more \"cores\" */\n\t\t\tif ((p = morecore(km, n_units)) == 0) return 0;\n\t\t}\n\t}\n}\n\nvoid *kcalloc(void *_km, size_t count, size_t size)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tvoid *p;\n\tif (size == 0 || count == 0) return 0;\n\tif (km == NULL) return calloc(count, size);\n\tp = kmalloc(km, count * size);\n\tmemset(p, 0, count * size);\n\treturn p;\n}\n\nvoid *krealloc(void *_km, void *ap, size_t n_bytes) // TODO: this can be made more efficient in principle\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tsize_t cap, *p, *q;\n\n\tif (n_bytes == 0) {\n\t\tkfree(km, ap); return 0;\n\t}\n\tif (km == NULL) return realloc(ap, n_bytes);\n\tif (ap == NULL) return kmalloc(km, n_bytes);\n\tp = (size_t*)ap - 1;\n\tcap = (*p) * sizeof(header_t) - sizeof(size_t);\n\tif (cap >= n_bytes) return ap; /* TODO: this prevents shrinking */\n\tq = (size_t*)kmalloc(km, n_bytes);\n\tmemcpy(q, ap, cap);\n\tkfree(km, ap);\n\treturn q;\n}\n\nvoid *krelocate(void *km, void *ap, size_t n_bytes)\n{\n\tvoid *p;\n\tif (km == 0 || ap == 0) return ap;\n\tp = kmalloc(km, n_bytes);\n\tmemcpy(p, ap, n_bytes);\n\tkfree(km, ap);\n\treturn p;\n}\n\nvoid km_stat(const void *_km, km_stat_t *s)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\theader_t *p;\n\tmemset(s, 0, sizeof(km_stat_t));\n\tif (km == NULL || km->loop_head == NULL) return;\n\tfor (p = km->loop_head;; p = p->ptr) {\n\t\ts->available += p->size * sizeof(header_t);\n\t\tif (p->size != 0) ++s->n_blocks; /* &kmem_t::base is always one of the cores. It is zero-sized. */\n\t\tif (p->ptr > p && p + p->size > p->ptr)\n\t\t\tpanic(\"[km_stat] The end of a free block enters another free block.\");\n\t\tif (p->ptr == km->loop_head) break;\n\t}\n\tfor (p = km->core_head; p != NULL; p = p->ptr) {\n\t\tsize_t size = p->size * sizeof(header_t);\n\t\t++s->n_cores;\n\t\ts->capacity += size;\n\t\ts->largest = s->largest > size? s->largest : size;\n\t}\n}\n\nvoid km_stat_print(const void *km)\n{\n\tkm_stat_t st;\n\tkm_stat(km, &st);\n\tfprintf(stderr, \"[km_stat] cap=%ld, avail=%ld, largest=%ld, n_core=%ld, n_block=%ld\\n\",\n\t\t\tst.capacity, st.available, st.largest, st.n_blocks, st.n_cores);\n}\n"
        },
        {
          "name": "kalloc.h",
          "type": "blob",
          "size": 2.755859375,
          "content": "#ifndef _KALLOC_H_\n#define _KALLOC_H_\n\n#include <stddef.h> /* for size_t */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\tsize_t capacity, available, n_blocks, n_cores, largest;\n} km_stat_t;\n\nvoid *kmalloc(void *km, size_t size);\nvoid *krealloc(void *km, void *ptr, size_t size);\nvoid *krelocate(void *km, void *ap, size_t n_bytes);\nvoid *kcalloc(void *km, size_t count, size_t size);\nvoid kfree(void *km, void *ptr);\n\nvoid *km_init(void);\nvoid *km_init2(void *km_par, size_t min_core_size);\nvoid km_destroy(void *km);\nvoid km_stat(const void *_km, km_stat_t *s);\nvoid km_stat_print(const void *km);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Kmalloc(km, type, cnt)       ((type*)kmalloc((km), (cnt) * sizeof(type)))\n#define Kcalloc(km, type, cnt)       ((type*)kcalloc((km), (cnt), sizeof(type)))\n#define Krealloc(km, type, ptr, cnt) ((type*)krealloc((km), (ptr), (cnt) * sizeof(type)))\n\n#define Kgrow(km, type, ptr, __i, __m) do { \\\n\t\tif ((__i) >= (__m)) { \\\n\t\t\t(__m) = (__i) + 1; \\\n\t\t\t(__m) += ((__m)>>1) + 16; \\\n\t\t\t(ptr) = Krealloc(km, type, ptr, (__m)); \\\n\t\t} \\\n\t} while (0)\n\n#define Kexpand(km, type, a, m) do { \\\n\t\t(m) = (m) >= 4? (m) + ((m)>>1) : 16; \\\n\t\t(a) = Krealloc(km, type, (a), (m)); \\\n\t} while (0)\n\n#define KMALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))kmalloc((km), (len) * sizeof(*(ptr))))\n#define KCALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))kcalloc((km), (len), sizeof(*(ptr))))\n#define KREALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))krealloc((km), (ptr), (len) * sizeof(*(ptr))))\n\n#define KEXPAND(km, a, m) do { \\\n\t\t(m) = (m) >= 4? (m) + ((m)>>1) : 16; \\\n\t\tKREALLOC((km), (a), (m)); \\\n\t} while (0)\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KALLOC_POOL_INIT2(SCOPE, name, kmptype_t) \\\n\ttypedef struct { \\\n\t\tsize_t cnt, n, max; \\\n\t\tkmptype_t **buf; \\\n\t\tvoid *km; \\\n\t} kmp_##name##_t; \\\n\tSCOPE kmp_##name##_t *kmp_init_##name(void *km) { \\\n\t\tkmp_##name##_t *mp; \\\n\t\tmp = Kcalloc(km, kmp_##name##_t, 1); \\\n\t\tmp->km = km; \\\n\t\treturn mp; \\\n\t} \\\n\tSCOPE void kmp_destroy_##name(kmp_##name##_t *mp) { \\\n\t\tsize_t k; \\\n\t\tfor (k = 0; k < mp->n; ++k) kfree(mp->km, mp->buf[k]); \\\n\t\tkfree(mp->km, mp->buf); kfree(mp->km, mp); \\\n\t} \\\n\tSCOPE kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) { \\\n\t\t++mp->cnt; \\\n\t\tif (mp->n == 0) return (kmptype_t*)kcalloc(mp->km, 1, sizeof(kmptype_t)); \\\n\t\treturn mp->buf[--mp->n]; \\\n\t} \\\n\tSCOPE void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \\\n\t\t--mp->cnt; \\\n\t\tif (mp->n == mp->max) Kexpand(mp->km, kmptype_t*, mp->buf, mp->max); \\\n\t\tmp->buf[mp->n++] = p; \\\n\t}\n\n#define KALLOC_POOL_INIT(name, kmptype_t) \\\n\tKALLOC_POOL_INIT2(static inline klib_unused, name, kmptype_t)\n\n#endif\n"
        },
        {
          "name": "kdq.h",
          "type": "blob",
          "size": 4.296875,
          "content": "#ifndef __AC_KDQ_H\n#define __AC_KDQ_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include \"kalloc.h\"\n\n#define __KDQ_TYPE(type) \\\n\ttypedef struct { \\\n\t\tuint64_t front:58, bits:6, count, mask; \\\n\t\ttype *a; \\\n\t\tvoid *km; \\\n\t} kdq_##type##_t;\n\n#define kdq_t(type) kdq_##type##_t\n#define kdq_size(q) ((q)->count)\n#define kdq_first(q) ((q)->a[(q)->front])\n#define kdq_last(q) ((q)->a[((q)->front + (q)->count - 1) & (q)->mask])\n#define kdq_at(q, i) ((q)->a[((q)->front + (i)) & (q)->mask])\n\n#define __KDQ_IMPL(type, SCOPE) \\\n\tSCOPE kdq_##type##_t *kdq_init_##type(void *km) \\\n\t{ \\\n\t\tkdq_##type##_t *q; \\\n\t\tq = (kdq_##type##_t*)kcalloc(km, 1, sizeof(kdq_##type##_t)); \\\n\t\tq->bits = 2, q->mask = (1ULL<<q->bits) - 1; \\\n\t\tq->a = (type*)kmalloc(km, (1<<q->bits) * sizeof(type)); \\\n\t\tq->km = km; \\\n\t\treturn q; \\\n\t} \\\n\tSCOPE void kdq_destroy_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q == 0) return; \\\n\t\tkfree(q->km, q->a); kfree(q->km, q); \\\n\t} \\\n\tSCOPE int kdq_resize_##type(kdq_##type##_t *q, int new_bits) \\\n\t{ \\\n\t\tsize_t new_size = 1ULL<<new_bits, old_size = 1ULL<<q->bits; \\\n\t\tif (new_size < q->count) { /* not big enough */ \\\n\t\t\tint i; \\\n\t\t\tfor (i = 0; i < 64; ++i) \\\n\t\t\t\tif (1ULL<<i > q->count) break; \\\n\t\t\tnew_bits = i, new_size = 1ULL<<new_bits; \\\n\t\t} \\\n\t\tif (new_bits == q->bits) return q->bits; /* unchanged */ \\\n\t\tif (new_bits > q->bits) q->a = (type*)krealloc(q->km, q->a, (1ULL<<new_bits) * sizeof(type)); \\\n\t\tif (q->front + q->count <= old_size) { /* unwrapped */ \\\n\t\t\tif (q->front + q->count > new_size) /* only happens for shrinking */ \\\n\t\t\t\tmemmove(q->a, q->a + new_size, (q->front + q->count - new_size) * sizeof(type)); \\\n\t\t} else { /* wrapped */ \\\n\t\t\tmemmove(q->a + (new_size - (old_size - q->front)), q->a + q->front, (old_size - q->front) * sizeof(type)); \\\n\t\t\tq->front = new_size - (old_size - q->front); \\\n\t\t} \\\n\t\tq->bits = new_bits, q->mask = (1ULL<<q->bits) - 1; \\\n\t\tif (new_bits < q->bits) q->a = (type*)krealloc(q->km, q->a, (1ULL<<new_bits) * sizeof(type)); \\\n\t\treturn q->bits; \\\n\t} \\\n\tSCOPE type *kdq_pushp_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\treturn &q->a[((q->count++) + q->front) & (q)->mask]; \\\n\t} \\\n\tSCOPE void kdq_push_##type(kdq_##type##_t *q, type v) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\tq->a[((q->count++) + q->front) & (q)->mask] = v; \\\n\t} \\\n\tSCOPE type *kdq_unshiftp_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\t++q->count; \\\n\t\tq->front = q->front? q->front - 1 : (1ULL<<q->bits) - 1; \\\n\t\treturn &q->a[q->front]; \\\n\t} \\\n\tSCOPE void kdq_unshift_##type(kdq_##type##_t *q, type v) \\\n\t{ \\\n\t\ttype *p; \\\n\t\tp = kdq_unshiftp_##type(q); \\\n\t\t*p = v; \\\n\t} \\\n\tSCOPE type *kdq_pop_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\treturn q->count? &q->a[((--q->count) + q->front) & q->mask] : 0; \\\n\t} \\\n\tSCOPE type *kdq_shift_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\ttype *d = 0; \\\n\t\tif (q->count == 0) return 0; \\\n\t\td = &q->a[q->front++]; \\\n\t\tq->front &= q->mask; \\\n\t\t--q->count; \\\n\t\treturn d; \\\n\t}\n\n#define KDQ_INIT2(type, SCOPE) \\\n\t__KDQ_TYPE(type) \\\n\t__KDQ_IMPL(type, SCOPE)\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KDQ_INIT(type) KDQ_INIT2(type, static inline klib_unused)\n\n#define KDQ_DECLARE(type) \\\n\t__KDQ_TYPE(type) \\\n\tkdq_##type##_t *kdq_init_##type(); \\\n\tvoid kdq_destroy_##type(kdq_##type##_t *q); \\\n\tint kdq_resize_##type(kdq_##type##_t *q, int new_bits); \\\n\ttype *kdq_pushp_##type(kdq_##type##_t *q); \\\n\tvoid kdq_push_##type(kdq_##type##_t *q, type v); \\\n\ttype *kdq_unshiftp_##type(kdq_##type##_t *q); \\\n\tvoid kdq_unshift_##type(kdq_##type##_t *q, type v); \\\n\ttype *kdq_pop_##type(kdq_##type##_t *q); \\\n\ttype *kdq_shift_##type(kdq_##type##_t *q);\n\n#define kdq_init(type, km) kdq_init_##type(km)\n#define kdq_destroy(type, q) kdq_destroy_##type(q)\n#define kdq_resize(type, q, new_bits) kdq_resize_##type(q, new_bits)\n#define kdq_pushp(type, q) kdq_pushp_##type(q)\n#define kdq_push(type, q, v) kdq_push_##type(q, v)\n#define kdq_pop(type, q) kdq_pop_##type(q)\n#define kdq_unshiftp(type, q) kdq_unshiftp_##type(q)\n#define kdq_unshift(type, q, v) kdq_unshift_##type(q, v)\n#define kdq_shift(type, q) kdq_shift_##type(q)\n\n#endif\n"
        },
        {
          "name": "ketopt.h",
          "type": "blob",
          "size": 3.8759765625,
          "content": "#ifndef KETOPT_H\n#define KETOPT_H\n\n#include <string.h> /* for strchr() and strncmp() */\n\n#define ko_no_argument       0\n#define ko_required_argument 1\n#define ko_optional_argument 2\n\ntypedef struct {\n\tint ind;   /* equivalent to optind */\n\tint opt;   /* equivalent to optopt */\n\tchar *arg; /* equivalent to optarg */\n\tint longidx; /* index of a long option; or -1 if short */\n\t/* private variables not intended for external uses */\n\tint i, pos, n_args;\n} ketopt_t;\n\ntypedef struct {\n\tchar *name;\n\tint has_arg;\n\tint val;\n} ko_longopt_t;\n\nstatic ketopt_t KETOPT_INIT = { 1, 0, 0, -1, 1, 0, 0 };\n\nstatic void ketopt_permute(char *argv[], int j, int n) /* move argv[j] over n elements to the left */\n{\n\tint k;\n\tchar *p = argv[j];\n\tfor (k = 0; k < n; ++k)\n\t\targv[j - k] = argv[j - k - 1];\n\targv[j - k] = p;\n}\n\n/**\n * Parse command-line options and arguments\n *\n * This fuction has a similar interface to GNU's getopt_long(). Each call\n * parses one option and returns the option name.  s->arg points to the option\n * argument if present. The function returns -1 when all command-line arguments\n * are parsed. In this case, s->ind is the index of the first non-option\n * argument.\n *\n * @param s         status; shall be initialized to KETOPT_INIT on the first call\n * @param argc      length of argv[]\n * @param argv      list of command-line arguments; argv[0] is ignored\n * @param permute   non-zero to move options ahead of non-option arguments\n * @param ostr      option string\n * @param longopts  long options\n *\n * @return ASCII for a short option; ko_longopt_t::val for a long option; -1 if\n *         argv[] is fully processed; '?' for an unknown option or an ambiguous\n *         long option; ':' if an option argument is missing\n */\nstatic int ketopt(ketopt_t *s, int argc, char *argv[], int permute, const char *ostr, const ko_longopt_t *longopts)\n{\n\tint opt = -1, i0, j;\n\tif (permute) {\n\t\twhile (s->i < argc && (argv[s->i][0] != '-' || argv[s->i][1] == '\\0'))\n\t\t\t++s->i, ++s->n_args;\n\t}\n\ts->arg = 0, s->longidx = -1, i0 = s->i;\n\tif (s->i >= argc || argv[s->i][0] != '-' || argv[s->i][1] == '\\0') {\n\t\ts->ind = s->i - s->n_args;\n\t\treturn -1;\n\t}\n\tif (argv[s->i][0] == '-' && argv[s->i][1] == '-') { /* \"--\" or a long option */\n\t\tif (argv[s->i][2] == '\\0') { /* a bare \"--\" */\n\t\t\tketopt_permute(argv, s->i, s->n_args);\n\t\t\t++s->i, s->ind = s->i - s->n_args;\n\t\t\treturn -1;\n\t\t}\n\t\ts->opt = 0, opt = '?', s->pos = -1;\n\t\tif (longopts) { /* parse long options */\n\t\t\tint k, n_exact = 0, n_partial = 0;\n\t\t\tconst ko_longopt_t *o = 0, *o_exact = 0, *o_partial = 0;\n\t\t\tfor (j = 2; argv[s->i][j] != '\\0' && argv[s->i][j] != '='; ++j) {} /* find the end of the option name */\n\t\t\tfor (k = 0; longopts[k].name != 0; ++k)\n\t\t\t\tif (strncmp(&argv[s->i][2], longopts[k].name, j - 2) == 0) {\n\t\t\t\t\tif (longopts[k].name[j - 2] == 0) ++n_exact, o_exact = &longopts[k];\n\t\t\t\t\telse ++n_partial, o_partial = &longopts[k];\n\t\t\t\t}\n\t\t\tif (n_exact > 1 || (n_exact == 0 && n_partial > 1)) return '?';\n\t\t\to = n_exact == 1? o_exact : n_partial == 1? o_partial : 0;\n\t\t\tif (o) {\n\t\t\t\ts->opt = opt = o->val, s->longidx = o - longopts;\n\t\t\t\tif (argv[s->i][j] == '=') s->arg = &argv[s->i][j + 1];\n\t\t\t\tif (o->has_arg == 1 && argv[s->i][j] == '\\0') {\n\t\t\t\t\tif (s->i < argc - 1) s->arg = argv[++s->i];\n\t\t\t\t\telse opt = ':'; /* missing option argument */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { /* a short option */\n\t\tchar *p;\n\t\tif (s->pos == 0) s->pos = 1;\n\t\topt = s->opt = argv[s->i][s->pos++];\n\t\tp = strchr((char*)ostr, opt);\n\t\tif (p == 0) {\n\t\t\topt = '?'; /* unknown option */\n\t\t} else if (p[1] == ':') {\n\t\t\tif (argv[s->i][s->pos] == 0) {\n\t\t\t\tif (s->i < argc - 1) s->arg = argv[++s->i];\n\t\t\t\telse opt = ':'; /* missing option argument */\n\t\t\t} else s->arg = &argv[s->i][s->pos];\n\t\t\ts->pos = -1;\n\t\t}\n\t}\n\tif (s->pos < 0 || argv[s->i][s->pos] == 0) {\n\t\t++s->i, s->pos = 0;\n\t\tif (s->n_args > 0) /* permute */\n\t\t\tfor (j = i0; j < s->i; ++j)\n\t\t\t\tketopt_permute(argv, j, s->n_args);\n\t}\n\ts->ind = s->i - s->n_args;\n\treturn opt;\n}\n\n#endif\n"
        },
        {
          "name": "khash.h",
          "type": "blob",
          "size": 20.8798828125,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"khash.h\"\nKHASH_MAP_INIT_INT(32, char)\nint main() {\n\tint ret, is_missing;\n\tkhiter_t k;\n\tkhash_t(32) *h = kh_init(32);\n\tk = kh_put(32, h, 5, &ret);\n\tkh_value(h, k) = 10;\n\tk = kh_get(32, h, 10);\n\tis_missing = (k == kh_end(h));\n\tk = kh_get(32, h, 5);\n\tkh_del(32, h, k);\n\tfor (k = kh_begin(h); k != kh_end(h); ++k)\n\t\tif (kh_exist(h, k)) kh_value(h, k) = 1;\n\tkh_destroy(32, h);\n\treturn 0;\n}\n*/\n\n/*\n  2013-05-02 (0.2.8):\n\n\t* Use quadratic probing. When the capacity is power of 2, stepping function\n\t  i*(i+1)/2 guarantees to traverse each bucket. It is better than double\n\t  hashing on cache performance and is more robust than linear probing.\n\n\t  In theory, double hashing should be more robust than quadratic probing.\n\t  However, my implementation is probably not for large hash tables, because\n\t  the second hash function is closely tied to the first hash function,\n\t  which reduce the effectiveness of double hashing.\n\n\tReference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php\n\n  2011-12-29 (0.2.7):\n\n    * Minor code clean up; no actual effect.\n\n  2011-09-16 (0.2.6):\n\n\t* The capacity is a power of 2. This seems to dramatically improve the\n\t  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:\n\n\t   - http://code.google.com/p/ulib/\n\t   - http://nothings.org/computer/judy/\n\n\t* Allow to optionally use linear probing which usually has better\n\t  performance for random input. Double hashing is still the default as it\n\t  is more robust to certain non-random input.\n\n\t* Added Wang's integer hash function (not used by default). This hash\n\t  function is more robust to certain non-random input.\n\n  2011-02-14 (0.2.5):\n\n    * Allow to declare global functions.\n\n  2009-09-26 (0.2.4):\n\n    * Improve portability\n\n  2008-09-19 (0.2.3):\n\n\t* Corrected the example\n\t* Improved interfaces\n\n  2008-09-11 (0.2.2):\n\n\t* Improved speed a little in kh_put()\n\n  2008-09-10 (0.2.1):\n\n\t* Added kh_clear()\n\t* Fixed a compiling error\n\n  2008-09-02 (0.2.0):\n\n\t* Changed to token concatenation which increases flexibility.\n\n  2008-08-31 (0.1.2):\n\n\t* Fixed a bug in kh_get(), which has not been tested previously.\n\n  2008-08-31 (0.1.1):\n\n\t* Added destructor\n*/\n\n\n#ifndef __AC_KHASH_H\n#define __AC_KHASH_H\n\n/*!\n  @header\n\n  Generic hash table library.\n */\n\n#define AC_VERSION_KHASH_H \"0.2.8\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"kalloc.h\"\n\n/* compiler specific configuration */\n\n#if UINT_MAX == 0xffffffffu\ntypedef unsigned int khint32_t;\n#elif ULONG_MAX == 0xffffffffu\ntypedef unsigned long khint32_t;\n#endif\n\n#if ULONG_MAX == ULLONG_MAX\ntypedef unsigned long khint64_t;\n#else\ntypedef unsigned long long khint64_t;\n#endif\n\n#ifndef kh_inline\n#ifdef _MSC_VER\n#define kh_inline __inline\n#else\n#define kh_inline inline\n#endif\n#endif /* kh_inline */\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\ntypedef khint32_t khint_t;\ntypedef khint_t khiter_t;\n\n#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)\n#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)\n#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)\n#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))\n#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))\n#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))\n#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))\n\n#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\nstatic const double __ac_HASH_UPPER = 0.77;\n\n#define __KHASH_TYPE(name, khkey_t, khval_t) \\\n\ttypedef struct kh_##name##_s { \\\n\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\\n\t\tkhint32_t *flags; \\\n\t\tkhkey_t *keys; \\\n\t\tkhval_t *vals; \\\n\t} kh_##name##_t;\n\n#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)\t \t\t\t\t\t\\\n\textern kh_##name##_t *kh_init_##name(void);\t\t\t\t\t\t\t\\\n\textern void kh_destroy_##name(kh_##name##_t *h);\t\t\t\t\t\\\n\textern void kh_clear_##name(kh_##name##_t *h);\t\t\t\t\t\t\\\n\textern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); \t\\\n\textern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \\\n\textern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \\\n\textern void kh_del_##name(kh_##name##_t *h, khint_t x);\n\n#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tSCOPE kh_##name##_t *kh_init_##name(void) {\t\t\t\t\t\t\t\\\n\t\treturn (kh_##name##_t*)kcalloc(0, 1, sizeof(kh_##name##_t));\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_destroy_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(0, (void *)h->keys); kfree(0, h->flags);\t\t\t\t\\\n\t\t\tkfree(0, (void *)h->vals);\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(0, h);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_clear_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h && h->flags) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \\\n\t\t\th->size = h->n_occupied = 0;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_buckets) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, last, mask, step = 0; \\\n\t\t\tmask = h->n_buckets - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\tk = __hash_func(key); i = k & mask;\t\t\t\t\t\t\t\\\n\t\t\tlast = i; \\\n\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\tif (i == last) return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn __ac_iseither(h->flags, i)? h->n_buckets : i;\t\t\\\n\t\t} else return 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \\\n\t{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \\\n\t\tkhint32_t *new_flags = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t j = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkroundup32(new_n_buckets); \t\t\t\t\t\t\t\t\t\\\n\t\t\tif (new_n_buckets < 4) new_n_buckets = 4;\t\t\t\t\t\\\n\t\t\tif (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;\t/* requested size is too small */ \\\n\t\t\telse { /* hash table size to be changed (shrink or expand); rehash */ \\\n\t\t\t\tnew_flags = (khint32_t*)kmalloc(0, __ac_fsize(new_n_buckets) * sizeof(khint32_t));\t\\\n\t\t\t\tif (!new_flags) return -1;\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \\\n\t\t\t\tif (h->n_buckets < new_n_buckets) {\t/* expand */\t\t\\\n\t\t\t\t\tkhkey_t *new_keys = (khkey_t*)krealloc(0, (void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\t\tif (!new_keys) { kfree(0, new_flags); return -1; }\t\\\n\t\t\t\t\th->keys = new_keys;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tkhval_t *new_vals = (khval_t*)krealloc(0, (void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t\t\t\tif (!new_vals) { kfree(0, new_flags); return -1; } \\\n\t\t\t\t\t\th->vals = new_vals;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} /* otherwise shrink */\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (j) { /* rehashing is needed */\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = 0; j != h->n_buckets; ++j) {\t\t\t\t\t\t\\\n\t\t\t\tif (__ac_iseither(h->flags, j) == 0) {\t\t\t\t\t\\\n\t\t\t\t\tkhkey_t key = h->keys[j];\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhval_t val;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhint_t new_mask;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tnew_mask = new_n_buckets - 1; \t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) val = h->vals[j];\t\t\t\t\t\\\n\t\t\t\t\t__ac_set_isdel_true(h->flags, j);\t\t\t\t\t\\\n\t\t\t\t\twhile (1) { /* kick-out process; sort of like in Cuckoo hashing */ \\\n\t\t\t\t\t\tkhint_t k, i, step = 0; \\\n\t\t\t\t\t\tk = __hash_func(key);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\ti = k & new_mask;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\twhile (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \\\n\t\t\t\t\t\t__ac_set_isempty_false(new_flags, i);\t\t\t\\\n\t\t\t\t\t\tif (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \\\n\t\t\t\t\t\t\t{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \\\n\t\t\t\t\t\t\tif (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \\\n\t\t\t\t\t\t\t__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \\\n\t\t\t\t\t\t} else { /* write the element and jump out of the loop */ \\\n\t\t\t\t\t\t\th->keys[i] = key;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tif (kh_is_map) h->vals[i] = val;\t\t\t\\\n\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\\n\t\t\t\th->keys = (khkey_t*)krealloc(0, (void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\tif (kh_is_map) h->vals = (khval_t*)krealloc(0, (void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(0, h->flags); /* free the working space */\t\t\t\\\n\t\t\th->flags = new_flags;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\th->n_buckets = new_n_buckets;\t\t\t\t\t\t\t\t\\\n\t\t\th->n_occupied = h->size;\t\t\t\t\t\t\t\t\t\\\n\t\t\th->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_occupied >= h->upper_bound) { /* update the hash table */ \\\n\t\t\tif (h->n_buckets > (h->size<<1)) {\t\t\t\t\t\t\t\\\n\t\t\t\tif (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear \"deleted\" elements */ \\\n\t\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \\\n\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \\\n\t\t\tx = site = h->n_buckets; k = __hash_func(key); i = k & mask; \\\n\t\t\tif (__ac_isempty(h->flags, i)) x = i; /* for speed up */\t\\\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tlast = i; \\\n\t\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\t\tif (__ac_isdel(h->flags, i)) site = i;\t\t\t\t\\\n\t\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\t\tif (i == last) { x = site; break; }\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x == h->n_buckets) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \\\n\t\t\t\t\telse x = i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (__ac_isempty(h->flags, x)) { /* not present at all */\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size; ++h->n_occupied;\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else if (__ac_isdel(h->flags, x)) { /* deleted */\t\t\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 2;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \\\n\t\treturn x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x != h->n_buckets && !__ac_iseither(h->flags, x)) {\t\t\t\\\n\t\t\t__ac_set_isdel_true(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t--h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)\n\n#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tKHASH_INIT2(name, static kh_inline klib_unused, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n/* --- BEGIN OF HASH FUNCTIONS --- */\n\n/*! @function\n  @abstract     Integer hash function\n  @param  key   The integer [khint32_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int_hash_func(key) (khint32_t)(key)\n/*! @function\n  @abstract     Integer comparison function\n */\n#define kh_int_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     64-bit integer hash function\n  @param  key   The integer [khint64_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)\n/*! @function\n  @abstract     64-bit integer comparison function\n */\n#define kh_int64_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     const char* hash function\n  @param  s     Pointer to a null terminated string\n  @return       The hash value\n */\nstatic kh_inline khint_t __ac_X31_hash_string(const char *s)\n{\n\tkhint_t h = (khint_t)*s;\n\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;\n\treturn h;\n}\n/*! @function\n  @abstract     Another interface to const char* hash function\n  @param  key   Pointer to a null terminated string [const char*]\n  @return       The hash value [khint_t]\n */\n#define kh_str_hash_func(key) __ac_X31_hash_string(key)\n/*! @function\n  @abstract     Const char* comparison function\n */\n#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)\n\nstatic kh_inline khint_t __ac_Wang_hash(khint_t key)\n{\n    key += ~(key << 15);\n    key ^=  (key >> 10);\n    key +=  (key << 3);\n    key ^=  (key >> 6);\n    key += ~(key << 11);\n    key ^=  (key >> 16);\n    return key;\n}\n#define kh_int_hash_func2(key) __ac_Wang_hash((khint_t)key)\n\n/* --- END OF HASH FUNCTIONS --- */\n\n/* Other convenient macros... */\n\n/*!\n  @abstract Type of the hash table.\n  @param  name  Name of the hash table [symbol]\n */\n#define khash_t(name) kh_##name##_t\n\n/*! @function\n  @abstract     Initiate a hash table.\n  @param  name  Name of the hash table [symbol]\n  @return       Pointer to the hash table [khash_t(name)*]\n */\n#define kh_init(name) kh_init_##name()\n\n/*! @function\n  @abstract     Destroy a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_destroy(name, h) kh_destroy_##name(h)\n\n/*! @function\n  @abstract     Reset a hash table without deallocating memory.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_clear(name, h) kh_clear_##name(h)\n\n/*! @function\n  @abstract     Resize a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  s     New size [khint_t]\n */\n#define kh_resize(name, h, s) kh_resize_##name(h, s)\n\n/*! @function\n  @abstract     Insert a key to the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @param  r     Extra return code: -1 if the operation failed;\n                0 if the key is present in the hash table;\n                1 if the bucket is empty (never used); 2 if the element in\n\t\t\t\tthe bucket has been deleted [int*]\n  @return       Iterator to the inserted element [khint_t]\n */\n#define kh_put(name, h, k, r) kh_put_##name(h, k, r)\n\n/*! @function\n  @abstract     Retrieve a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @return       Iterator to the found element, or kh_end(h) if the element is absent [khint_t]\n */\n#define kh_get(name, h, k) kh_get_##name(h, k)\n\n/*! @function\n  @abstract     Remove a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Iterator to the element to be deleted [khint_t]\n */\n#define kh_del(name, h, k) kh_del_##name(h, k)\n\n/*! @function\n  @abstract     Test whether a bucket contains data.\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       1 if containing data; 0 otherwise [int]\n */\n#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))\n\n/*! @function\n  @abstract     Get key given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Key [type of keys]\n */\n#define kh_key(h, x) ((h)->keys[x])\n\n/*! @function\n  @abstract     Get value given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Value [type of values]\n  @discussion   For hash sets, calling this results in segfault.\n */\n#define kh_val(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Alias of kh_val()\n */\n#define kh_value(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Get the start iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The start iterator [khint_t]\n */\n#define kh_begin(h) (khint_t)(0)\n\n/*! @function\n  @abstract     Get the end iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The end iterator [khint_t]\n */\n#define kh_end(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Get the number of elements in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of elements in the hash table [khint_t]\n */\n#define kh_size(h) ((h)->size)\n\n/*! @function\n  @abstract     Get the number of buckets in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of buckets in the hash table [khint_t]\n */\n#define kh_n_buckets(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Iterate over the entries in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  kvar  Variable to which key will be assigned\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/*! @function\n  @abstract     Iterate over the values in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/* More conenient interfaces */\n\n/*! @function\n  @abstract     Instantiate a hash set containing integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)\n\ntypedef const char *kh_cstr_t;\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_STR(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)\n\n#endif /* __AC_KHASH_H */\n"
        },
        {
          "name": "krmq.h",
          "type": "blob",
          "size": 16.060546875,
          "content": "/* The MIT License\n\n   Copyright (c) 2019 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* An example:\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"krmq.h\"\n\nstruct my_node {\n  char key;\n  KRMQ_HEAD(struct my_node) head;\n};\n#define my_cmp(p, q) (((q)->key < (p)->key) - ((p)->key < (q)->key))\nKRMQ_INIT(my, struct my_node, head, my_cmp)\n\nint main(void) {\n  const char *str = \"MNOLKQOPHIA\"; // from wiki, except a duplicate\n  struct my_node *root = 0;\n  int i, l = strlen(str);\n  for (i = 0; i < l; ++i) {        // insert in the input order\n    struct my_node *q, *p = malloc(sizeof(*p));\n    p->key = str[i];\n    q = krmq_insert(my, &root, p, 0);\n    if (p != q) free(p);           // if already present, free\n  }\n  krmq_itr_t(my) itr;\n  krmq_itr_first(my, root, &itr);  // place at first\n  do {                             // traverse\n    const struct my_node *p = krmq_at(&itr);\n    putchar(p->key);\n    free((void*)p);                // free node\n  } while (krmq_itr_next(my, &itr));\n  putchar('\\n');\n  return 0;\n}\n*/\n\n#ifndef KRMQ_H\n#define KRMQ_H\n\n#ifdef __STRICT_ANSI__\n#define inline __inline__\n#endif\n\n#define KRMQ_MAX_DEPTH 64\n\n#define krmq_size(head, p) ((p)? (p)->head.size : 0)\n#define krmq_size_child(head, q, i) ((q)->head.p[(i)]? (q)->head.p[(i)]->head.size : 0)\n\n#define KRMQ_HEAD(__type) \\\n\tstruct { \\\n\t\t__type *p[2], *s; \\\n\t\tsigned char balance; /* balance factor */ \\\n\t\tunsigned size; /* #elements in subtree */ \\\n\t}\n\n#define __KRMQ_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__scope __type *krmq_find_##suf(const __type *root, const __type *x, unsigned *cnt_) { \\\n\t\tconst __type *p = root; \\\n\t\tunsigned cnt = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\treturn (__type*)p; \\\n\t} \\\n\t__scope __type *krmq_interval_##suf(const __type *root, const __type *x, __type **lower, __type **upper) { \\\n\t\tconst __type *p = root, *l = 0, *u = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) u = p, p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) l = p, p = p->__head.p[1]; \\\n\t\t\telse { l = u = p; break; } \\\n\t\t} \\\n\t\tif (lower) *lower = (__type*)l; \\\n\t\tif (upper) *upper = (__type*)u; \\\n\t\treturn (__type*)p; \\\n\t}\n\n#define __KRMQ_RMQ(suf, __scope, __type, __head,  __cmp, __lt2) \\\n\t__scope __type *krmq_rmq_##suf(const __type *root, const __type *lo, const __type *up) { /* CLOSED interval */ \\\n\t\tconst __type *p = root, *path[2][KRMQ_MAX_DEPTH], *min; \\\n\t\tint plen[2] = {0, 0}, pcmp[2][KRMQ_MAX_DEPTH], i, cmp, lca; \\\n\t\tif (root == 0) return 0; \\\n\t\twhile (p) { \\\n\t\t\tcmp = __cmp(lo, p); \\\n\t\t\tpath[0][plen[0]] = p, pcmp[0][plen[0]++] = cmp; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tp = root; \\\n\t\twhile (p) { \\\n\t\t\tcmp = __cmp(up, p); \\\n\t\t\tpath[1][plen[1]] = p, pcmp[1][plen[1]++] = cmp; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tfor (i = 0; i < plen[0] && i < plen[1]; ++i) /* find the LCA */ \\\n\t\t\tif (path[0][i] == path[1][i] && pcmp[0][i] <= 0 && pcmp[1][i] >= 0) \\\n\t\t\t\tbreak; \\\n\t\tif (i == plen[0] || i == plen[1]) return 0; /* no elements in the closed interval */ \\\n\t\tlca = i, min = path[0][lca]; \\\n\t\tfor (i = lca + 1; i < plen[0]; ++i) { \\\n\t\t\tif (pcmp[0][i] <= 0) { \\\n\t\t\t\tif (__lt2(path[0][i], min)) min = path[0][i]; \\\n\t\t\t\tif (path[0][i]->__head.p[1] && __lt2(path[0][i]->__head.p[1]->__head.s, min)) \\\n\t\t\t\t\tmin = path[0][i]->__head.p[1]->__head.s; \\\n\t\t\t} \\\n\t\t} \\\n\t\tfor (i = lca + 1; i < plen[1]; ++i) { \\\n\t\t\tif (pcmp[1][i] >= 0) { \\\n\t\t\t\tif (__lt2(path[1][i], min)) min = path[1][i]; \\\n\t\t\t\tif (path[1][i]->__head.p[0] && __lt2(path[1][i]->__head.p[0]->__head.s, min)) \\\n\t\t\t\t\tmin = path[1][i]->__head.p[0]->__head.s; \\\n\t\t\t} \\\n\t\t} \\\n\t\treturn (__type*)min; \\\n\t}\n\n#define __KRMQ_ROTATE(suf, __type, __head, __lt2) \\\n\t/* */ \\\n\tstatic inline void krmq_update_min_##suf(__type *p, const __type *q, const __type *r) { \\\n\t\tp->__head.s = !q || __lt2(p, q->__head.s)? p : q->__head.s; \\\n\t\tp->__head.s = !r || __lt2(p->__head.s, r->__head.s)? p->__head.s : r->__head.s; \\\n\t} \\\n\t/* one rotation: (a,(b,c)q)p => ((a,b)p,c)q */ \\\n\tstatic inline __type *krmq_rotate1_##suf(__type *p, int dir) { /* dir=0 to left; dir=1 to right */ \\\n\t\tint opp = 1 - dir; /* opposite direction */ \\\n\t\t__type *q = p->__head.p[opp], *s = p->__head.s; \\\n\t\tunsigned size_p = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - krmq_size_child(__head, q, dir); \\\n\t\tq->__head.size = size_p; \\\n\t\tkrmq_update_min_##suf(p, p->__head.p[dir], q->__head.p[dir]); \\\n\t\tq->__head.s = s; \\\n\t\tp->__head.p[opp] = q->__head.p[dir]; \\\n\t\tq->__head.p[dir] = p; \\\n\t\treturn q; \\\n\t} \\\n\t/* two consecutive rotations: (a,((b,c)r,d)q)p => ((a,b)p,(c,d)q)r */ \\\n\tstatic inline __type *krmq_rotate2_##suf(__type *p, int dir) { \\\n\t\tint b1, opp = 1 - dir; \\\n\t\t__type *q = p->__head.p[opp], *r = q->__head.p[dir], *s = p->__head.s; \\\n\t\tunsigned size_x_dir = krmq_size_child(__head, r, dir); \\\n\t\tr->__head.size = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - size_x_dir; \\\n\t\tq->__head.size -= size_x_dir + 1; \\\n\t\tkrmq_update_min_##suf(p, p->__head.p[dir], r->__head.p[dir]); \\\n\t\tkrmq_update_min_##suf(q, q->__head.p[opp], r->__head.p[opp]); \\\n\t\tr->__head.s = s; \\\n\t\tp->__head.p[opp] = r->__head.p[dir]; \\\n\t\tr->__head.p[dir] = p; \\\n\t\tq->__head.p[dir] = r->__head.p[opp]; \\\n\t\tr->__head.p[opp] = q; \\\n\t\tb1 = dir == 0? +1 : -1; \\\n\t\tif (r->__head.balance == b1) q->__head.balance = 0, p->__head.balance = -b1; \\\n\t\telse if (r->__head.balance == 0) q->__head.balance = p->__head.balance = 0; \\\n\t\telse q->__head.balance = b1, p->__head.balance = 0; \\\n\t\tr->__head.balance = 0; \\\n\t\treturn r; \\\n\t}\n\n#define __KRMQ_INSERT(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__scope __type *krmq_insert_##suf(__type **root_, __type *x, unsigned *cnt_) { \\\n\t\tunsigned char stack[KRMQ_MAX_DEPTH]; \\\n\t\t__type *path[KRMQ_MAX_DEPTH]; \\\n\t\t__type *bp, *bq; \\\n\t\t__type *p, *q, *r = 0; /* _r_ is potentially the new root */ \\\n\t\tint i, which = 0, top, b1, path_len; \\\n\t\tunsigned cnt = 0; \\\n\t\tbp = *root_, bq = 0; \\\n\t\t/* find the insertion location */ \\\n\t\tfor (p = bp, q = bq, top = path_len = 0; p; q = p, p = p->__head.p[which]) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp == 0) { \\\n\t\t\t\tif (cnt_) *cnt_ = cnt; \\\n\t\t\t\treturn p; \\\n\t\t\t} \\\n\t\t\tif (p->__head.balance != 0) \\\n\t\t\t\tbq = q, bp = p, top = 0; \\\n\t\t\tstack[top++] = which = (cmp > 0); \\\n\t\t\tpath[path_len++] = p; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tx->__head.balance = 0, x->__head.size = 1, x->__head.p[0] = x->__head.p[1] = 0, x->__head.s = x; \\\n\t\tif (q == 0) *root_ = x; \\\n\t\telse q->__head.p[which] = x; \\\n\t\tif (bp == 0) return x; \\\n\t\tfor (i = 0; i < path_len; ++i) ++path[i]->__head.size; \\\n\t\tfor (i = path_len - 1; i >= 0; --i) { \\\n\t\t\tkrmq_update_min_##suf(path[i], path[i]->__head.p[0], path[i]->__head.p[1]); \\\n\t\t\tif (path[i]->__head.s != x) break; \\\n\t\t} \\\n\t\tfor (p = bp, top = 0; p != x; p = p->__head.p[stack[top]], ++top) /* update balance factors */ \\\n\t\t\tif (stack[top] == 0) --p->__head.balance; \\\n\t\t\telse ++p->__head.balance; \\\n\t\tif (bp->__head.balance > -2 && bp->__head.balance < 2) return x; /* no re-balance needed */ \\\n\t\t/* re-balance */ \\\n\t\twhich = (bp->__head.balance < 0); \\\n\t\tb1 = which == 0? +1 : -1; \\\n\t\tq = bp->__head.p[1 - which]; \\\n\t\tif (q->__head.balance == b1) { \\\n\t\t\tr = krmq_rotate1_##suf(bp, which); \\\n\t\t\tq->__head.balance = bp->__head.balance = 0; \\\n\t\t} else r = krmq_rotate2_##suf(bp, which); \\\n\t\tif (bq == 0) *root_ = r; \\\n\t\telse bq->__head.p[bp != bq->__head.p[0]] = r; \\\n\t\treturn x; \\\n\t}\n\n#define __KRMQ_ERASE(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__scope __type *krmq_erase_##suf(__type **root_, const __type *x, unsigned *cnt_) { \\\n\t\t__type *p, *path[KRMQ_MAX_DEPTH], fake; \\\n\t\tunsigned char dir[KRMQ_MAX_DEPTH]; \\\n\t\tint i, d = 0, cmp; \\\n\t\tunsigned cnt = 0; \\\n\t\tfake = **root_, fake.__head.p[0] = *root_, fake.__head.p[1] = 0; \\\n\t\tif (cnt_) *cnt_ = 0; \\\n\t\tif (x) { \\\n\t\t\tfor (cmp = -1, p = &fake; cmp; cmp = __cmp(x, p)) { \\\n\t\t\t\tint which = (cmp > 0); \\\n\t\t\t\tif (cmp > 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\t\tdir[d] = which; \\\n\t\t\t\tpath[d++] = p; \\\n\t\t\t\tp = p->__head.p[which]; \\\n\t\t\t\tif (p == 0) { \\\n\t\t\t\t\tif (cnt_) *cnt_ = 0; \\\n\t\t\t\t\treturn 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\tcnt += krmq_size_child(__head, p, 0) + 1; /* because p==x is not counted */ \\\n\t\t} else { \\\n\t\t\tfor (p = &fake, cnt = 1; p; p = p->__head.p[0]) \\\n\t\t\t\tdir[d] = 0, path[d++] = p; \\\n\t\t\tp = path[--d]; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tfor (i = 1; i < d; ++i) --path[i]->__head.size; \\\n\t\tif (p->__head.p[1] == 0) { /* ((1,.)2,3)4 => (1,3)4; p=2 */ \\\n\t\t\tpath[d-1]->__head.p[dir[d-1]] = p->__head.p[0]; \\\n\t\t} else { \\\n\t\t\t__type *q = p->__head.p[1]; \\\n\t\t\tif (q->__head.p[0] == 0) { /* ((1,2)3,4)5 => ((1)2,4)5; p=3,q=2 */ \\\n\t\t\t\tq->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = q; \\\n\t\t\t\tpath[d] = q, dir[d++] = 1; \\\n\t\t\t\tq->__head.size = p->__head.size - 1; \\\n\t\t\t} else { /* ((1,((.,2)3,4)5)6,7)8 => ((1,(2,4)5)3,7)8; p=6 */ \\\n\t\t\t\t__type *r; \\\n\t\t\t\tint e = d++; /* backup _d_ */\\\n\t\t\t\tfor (;;) { \\\n\t\t\t\t\tdir[d] = 0; \\\n\t\t\t\t\tpath[d++] = q; \\\n\t\t\t\t\tr = q->__head.p[0]; \\\n\t\t\t\t\tif (r->__head.p[0] == 0) break; \\\n\t\t\t\t\tq = r; \\\n\t\t\t\t} \\\n\t\t\t\tr->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.p[0] = r->__head.p[1]; \\\n\t\t\t\tr->__head.p[1] = p->__head.p[1]; \\\n\t\t\t\tr->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[e-1]->__head.p[dir[e-1]] = r; \\\n\t\t\t\tpath[e] = r, dir[e] = 1; \\\n\t\t\t\tfor (i = e + 1; i < d; ++i) --path[i]->__head.size; \\\n\t\t\t\tr->__head.size = p->__head.size - 1; \\\n\t\t\t} \\\n\t\t} \\\n\t\tfor (i = d - 1; i >= 0; --i) /* not sure why adding condition \"path[i]->__head.s==p\" doesn't work */ \\\n\t\t\tkrmq_update_min_##suf(path[i], path[i]->__head.p[0], path[i]->__head.p[1]); \\\n\t\twhile (--d > 0) { \\\n\t\t\t__type *q = path[d]; \\\n\t\t\tint which, other, b1 = 1, b2 = 2; \\\n\t\t\twhich = dir[d], other = 1 - which; \\\n\t\t\tif (which) b1 = -b1, b2 = -b2; \\\n\t\t\tq->__head.balance += b1; \\\n\t\t\tif (q->__head.balance == b1) break; \\\n\t\t\telse if (q->__head.balance == b2) { \\\n\t\t\t\t__type *r = q->__head.p[other]; \\\n\t\t\t\tif (r->__head.balance == -b1) { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = krmq_rotate2_##suf(q, which); \\\n\t\t\t\t} else { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = krmq_rotate1_##suf(q, which); \\\n\t\t\t\t\tif (r->__head.balance == 0) { \\\n\t\t\t\t\t\tr->__head.balance = -b1; \\\n\t\t\t\t\t\tq->__head.balance = b1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t} else r->__head.balance = q->__head.balance = 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\t*root_ = fake.__head.p[0]; \\\n\t\treturn p; \\\n\t}\n\n#define krmq_free(__type, __head, __root, __free) do { \\\n\t\t__type *_p, *_q; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t__free(_p); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define __KRMQ_ITR(suf, __scope, __type, __head, __cmp) \\\n\tstruct krmq_itr_##suf { \\\n\t\tconst __type *stack[KRMQ_MAX_DEPTH], **top; \\\n\t}; \\\n\t__scope void krmq_itr_first_##suf(const __type *root, struct krmq_itr_##suf *itr) { \\\n\t\tconst __type *p; \\\n\t\tfor (itr->top = itr->stack - 1, p = root; p; p = p->__head.p[0]) \\\n\t\t\t*++itr->top = p; \\\n\t} \\\n\t__scope int krmq_itr_find_##suf(const __type *root, const __type *x, struct krmq_itr_##suf *itr) { \\\n\t\tconst __type *p = root; \\\n\t\titr->top = itr->stack - 1; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\t*++itr->top = p; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\treturn p? 1 : 0; \\\n\t} \\\n\t__scope int krmq_itr_next_bidir_##suf(struct krmq_itr_##suf *itr, int dir) { \\\n\t\tconst __type *p; \\\n\t\tif (itr->top < itr->stack) return 0; \\\n\t\tdir = !!dir; \\\n\t\tp = (*itr->top)->__head.p[dir]; \\\n\t\tif (p) { /* go down */ \\\n\t\t\tfor (; p; p = p->__head.p[!dir]) \\\n\t\t\t\t*++itr->top = p; \\\n\t\t\treturn 1; \\\n\t\t} else { /* go up */ \\\n\t\t\tdo { \\\n\t\t\t\tp = *itr->top--; \\\n\t\t\t} while (itr->top >= itr->stack && p == (*itr->top)->__head.p[dir]); \\\n\t\t\treturn itr->top < itr->stack? 0 : 1; \\\n\t\t} \\\n\t} \\\n\n/**\n * Insert a node to the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node to insert (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return _x_ if not present in the tree, or the node equal to x.\n */\n#define krmq_insert(suf, proot, x, cnt) krmq_insert_##suf(proot, x, cnt)\n\n/**\n * Find a node in the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param x       node value to find (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return node equal to _x_ if present, or NULL if absent\n */\n#define krmq_find(suf, root, x, cnt) krmq_find_##suf(root, x, cnt)\n#define krmq_interval(suf, root, x, lower, upper) krmq_interval_##suf(root, x, lower, upper)\n#define krmq_rmq(suf, root, lo, up) krmq_rmq_##suf(root, lo, up)\n\n/**\n * Delete a node from the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node value to delete; if NULL, delete the first node (in)\n *\n * @return node removed from the tree if present, or NULL if absent\n */\n#define krmq_erase(suf, proot, x, cnt) krmq_erase_##suf(proot, x, cnt)\n#define krmq_erase_first(suf, proot) krmq_erase_##suf(proot, 0, 0)\n\n#define krmq_itr_t(suf) struct krmq_itr_##suf\n\n/**\n * Place the iterator at the smallest object\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param itr     iterator\n */\n#define krmq_itr_first(suf, root, itr) krmq_itr_first_##suf(root, itr)\n\n/**\n * Place the iterator at the object equal to or greater than the query\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param x       query (in)\n * @param itr     iterator (out)\n *\n * @return 1 if find; 0 otherwise. krmq_at(itr) is NULL if and only if query is\n *         larger than all objects in the tree\n */\n#define krmq_itr_find(suf, root, x, itr) krmq_itr_find_##suf(root, x, itr)\n\n/**\n * Move to the next object in order\n *\n * @param itr     iterator (modified)\n *\n * @return 1 if there is a next object; 0 otherwise\n */\n#define krmq_itr_next(suf, itr) krmq_itr_next_bidir_##suf(itr, 1)\n#define krmq_itr_prev(suf, itr) krmq_itr_next_bidir_##suf(itr, 0)\n\n/**\n * Return the pointer at the iterator\n *\n * @param itr     iterator\n *\n * @return pointer if present; NULL otherwise\n */\n#define krmq_at(itr) ((itr)->top < (itr)->stack? 0 : *(itr)->top)\n\n#define KRMQ_INIT2(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__KRMQ_RMQ(suf, __scope, __type, __head,  __cmp, __lt2) \\\n\t__KRMQ_ROTATE(suf, __type, __head, __lt2) \\\n\t__KRMQ_INSERT(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_ERASE(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_ITR(suf, __scope, __type, __head, __cmp)\n\n#define KRMQ_INIT(suf, __type, __head, __cmp, __lt2) \\\n\tKRMQ_INIT2(suf,, __type, __head, __cmp, __lt2)\n\n#endif\n"
        },
        {
          "name": "kseq.h",
          "type": "blob",
          "size": 8.57421875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Last Modified: 05MAR2012 */\n\n#ifndef AC_KSEQ_H\n#define AC_KSEQ_H\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define KS_SEP_SPACE 0 // isspace(): \\t, \\n, \\v, \\f, \\r\n#define KS_SEP_TAB   1 // isspace() && !' '\n#define KS_SEP_LINE  2 // line separator: \"\\n\" (Unix) or \"\\r\\n\" (Windows)\n#define KS_SEP_MAX   2\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define __KS_TYPE(type_t) \\\n\ttypedef struct __kstream_t { \\\n\t\tint begin, end; \\\n\t\tint is_eof:2, bufsize:30; \\\n\t\ttype_t f; \\\n\t\tunsigned char *buf; \\\n\t} kstream_t;\n\n#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)\n#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)\n\n#define __KS_BASIC(SCOPE, type_t, __bufsize) \\\n\tSCOPE kstream_t *ks_init(type_t f) \\\n\t{ \\\n\t\tkstream_t *ks = (kstream_t*)calloc(1, sizeof(kstream_t)); \\\n\t\tks->f = f; ks->bufsize = __bufsize; \\\n\t\tks->buf = (unsigned char*)malloc(__bufsize); \\\n\t\treturn ks; \\\n\t} \\\n\tSCOPE void ks_destroy(kstream_t *ks) \\\n\t{ \\\n\t\tif (!ks) return; \\\n\t\tfree(ks->buf); \\\n\t\tfree(ks); \\\n\t}\n\n#define __KS_INLINED(__read) \\\n\tstatic inline klib_unused int ks_getc(kstream_t *ks) \\\n\t{ \\\n\t\tif (ks->is_eof && ks->begin >= ks->end) return -1; \\\n\t\tif (ks->begin >= ks->end) { \\\n\t\t\tks->begin = 0; \\\n\t\t\tks->end = __read(ks->f, ks->buf, ks->bufsize); \\\n\t\t\tif (ks->end < ks->bufsize) ks->is_eof = 1; \\\n\t\t\tif (ks->end == 0) return -1; \\\n\t\t} \\\n\t\treturn (int)ks->buf[ks->begin++]; \\\n\t} \\\n\tstatic inline int ks_getuntil(kstream_t *ks, int delimiter, kstring_t *str, int *dret) \\\n\t{ return ks_getuntil2(ks, delimiter, str, dret, 0); }\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#define __KS_GETUNTIL(SCOPE, __read) \\\n\tSCOPE int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append) \\\n\t{ \\\n\t\tif (dret) *dret = 0; \\\n\t\tstr->l = append? str->l : 0; \\\n\t\tif (ks->begin >= ks->end && ks->is_eof) return -1; \\\n\t\tfor (;;) { \\\n\t\t\tint i; \\\n\t\t\tif (ks->begin >= ks->end) { \\\n\t\t\t\tif (!ks->is_eof) { \\\n\t\t\t\t\tks->begin = 0; \\\n\t\t\t\t\tks->end = __read(ks->f, ks->buf, ks->bufsize); \\\n\t\t\t\t\tif (ks->end < ks->bufsize) ks->is_eof = 1; \\\n\t\t\t\t\tif (ks->end == 0) break; \\\n\t\t\t\t} else break; \\\n\t\t\t} \\\n\t\t\tif (delimiter == KS_SEP_LINE) { \\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i) \\\n\t\t\t\t\tif (ks->buf[i] == '\\n') break; \\\n\t\t\t} else if (delimiter > KS_SEP_MAX) { \\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i) \\\n\t\t\t\t\tif (ks->buf[i] == delimiter) break; \\\n\t\t\t} else if (delimiter == KS_SEP_SPACE) { \\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i) \\\n\t\t\t\t\tif (isspace(ks->buf[i])) break; \\\n\t\t\t} else if (delimiter == KS_SEP_TAB) { \\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i) \\\n\t\t\t\t\tif (isspace(ks->buf[i]) && ks->buf[i] != ' ') break; \\\n\t\t\t} else i = 0; /* never come to here! */ \\\n\t\t\tif (str->m - str->l < (size_t)(i - ks->begin + 1)) { \\\n\t\t\t\tstr->m = str->l + (i - ks->begin) + 1; \\\n\t\t\t\tkroundup32(str->m); \\\n\t\t\t\tstr->s = (char*)realloc(str->s, str->m); \\\n\t\t\t} \\\n\t\t\tmemcpy(str->s + str->l, ks->buf + ks->begin, i - ks->begin); \\\n\t\t\tstr->l = str->l + (i - ks->begin); \\\n\t\t\tks->begin = i + 1; \\\n\t\t\tif (i < ks->end) { \\\n\t\t\t\tif (dret) *dret = ks->buf[i]; \\\n\t\t\t\tbreak; \\\n\t\t\t} \\\n\t\t} \\\n\t\tif (str->s == 0) { \\\n\t\t\tstr->m = 1; \\\n\t\t\tstr->s = (char*)calloc(1, 1); \\\n\t\t} else if (delimiter == KS_SEP_LINE && str->l > 1 && str->s[str->l-1] == '\\r') --str->l; \\\n\t\tstr->s[str->l] = '\\0'; \\\n\t\treturn str->l; \\\n\t}\n\n#define KSTREAM_INIT2(SCOPE, type_t, __read, __bufsize) \\\n\t__KS_TYPE(type_t) \\\n\t__KS_BASIC(SCOPE, type_t, __bufsize) \\\n\t__KS_GETUNTIL(SCOPE, __read) \\\n\t__KS_INLINED(__read)\n\n#define KSTREAM_INIT(type_t, __read, __bufsize) KSTREAM_INIT2(static, type_t, __read, __bufsize)\n\n#define KSTREAM_DECLARE(type_t, __read) \\\n\t__KS_TYPE(type_t) \\\n\textern int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append); \\\n\textern kstream_t *ks_init(type_t f); \\\n\textern void ks_destroy(kstream_t *ks); \\\n\t__KS_INLINED(__read)\n\n/******************\n * FASTA/Q parser *\n ******************/\n\n#define kseq_rewind(ks) ((ks)->last_char = (ks)->f->is_eof = (ks)->f->begin = (ks)->f->end = 0)\n\n#define __KSEQ_BASIC(SCOPE, type_t) \\\n\tSCOPE kseq_t *kseq_init(type_t fd) \\\n\t{ \\\n\t\tkseq_t *s = (kseq_t*)calloc(1, sizeof(kseq_t)); \\\n\t\ts->f = ks_init(fd); \\\n\t\treturn s; \\\n\t} \\\n\tSCOPE void kseq_destroy(kseq_t *ks) \\\n\t{ \\\n\t\tif (!ks) return; \\\n\t\tfree(ks->name.s); free(ks->comment.s); free(ks->seq.s);\tfree(ks->qual.s); \\\n\t\tks_destroy(ks->f); \\\n\t\tfree(ks); \\\n\t}\n\n/* Return value:\n   >=0  length of the sequence (normal)\n   -1   end-of-file\n   -2   truncated quality string\n */\n#define __KSEQ_READ(SCOPE) \\\n\tSCOPE int kseq_read(kseq_t *seq) \\\n\t{ \\\n\t\tint c; \\\n\t\tkstream_t *ks = seq->f; \\\n\t\tif (seq->last_char == 0) { /* then jump to the next header line */ \\\n\t\t\twhile ((c = ks_getc(ks)) != -1 && c != '>' && c != '@'); \\\n\t\t\tif (c == -1) return -1; /* end of file */ \\\n\t\t\tseq->last_char = c; \\\n\t\t} /* else: the first header char has been read in the previous call */ \\\n\t\tseq->comment.l = seq->seq.l = seq->qual.l = 0; /* reset all members */ \\\n\t\tif (ks_getuntil(ks, 0, &seq->name, &c) < 0) return -1; /* normal exit: EOF */ \\\n\t\tif (c != '\\n') ks_getuntil(ks, KS_SEP_LINE, &seq->comment, 0); /* read FASTA/Q comment */ \\\n\t\tif (seq->seq.s == 0) { /* we can do this in the loop below, but that is slower */ \\\n\t\t\tseq->seq.m = 256; \\\n\t\t\tseq->seq.s = (char*)malloc(seq->seq.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) != -1 && c != '>' && c != '+' && c != '@') { \\\n\t\t\tif (c == '\\n') continue; /* skip empty lines */ \\\n\t\t\tseq->seq.s[seq->seq.l++] = c; /* this is safe: we always have enough space for 1 char */ \\\n\t\t\tks_getuntil2(ks, KS_SEP_LINE, &seq->seq, 0, 1); /* read the rest of the line */ \\\n\t\t} \\\n\t\tif (c == '>' || c == '@') seq->last_char = c; /* the first header char has been read */ \\\n\t\tif (seq->seq.l + 1 >= seq->seq.m) { /* seq->seq.s[seq->seq.l] below may be out of boundary */ \\\n\t\t\tseq->seq.m = seq->seq.l + 2; \\\n\t\t\tkroundup32(seq->seq.m); /* rounded to the next closest 2^k */ \\\n\t\t\tseq->seq.s = (char*)realloc(seq->seq.s, seq->seq.m); \\\n\t\t} \\\n\t\tseq->seq.s[seq->seq.l] = 0;\t/* null terminated string */ \\\n\t\tif (c != '+') return seq->seq.l; /* FASTA */ \\\n\t\tif (seq->qual.m < seq->seq.m) {\t/* allocate memory for qual in case insufficient */ \\\n\t\t\tseq->qual.m = seq->seq.m; \\\n\t\t\tseq->qual.s = (char*)realloc(seq->qual.s, seq->qual.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) != -1 && c != '\\n'); /* skip the rest of '+' line */ \\\n\t\tif (c == -1) return -2; /* error: no quality string */ \\\n\t\twhile (ks_getuntil2(ks, KS_SEP_LINE, &seq->qual, 0, 1) >= 0 && seq->qual.l < seq->seq.l); \\\n\t\tseq->last_char = 0;\t/* we have not come to the next header line */ \\\n\t\tif (seq->seq.l != seq->qual.l) return -2; /* error: qual string is of a different length */ \\\n\t\treturn seq->seq.l; \\\n\t}\n\n#define __KSEQ_TYPE(type_t) \\\n\ttypedef struct { \\\n\t\tkstring_t name, comment, seq, qual; \\\n\t\tint last_char; \\\n\t\tkstream_t *f; \\\n\t} kseq_t;\n\n#define KSEQ_INIT2(SCOPE, type_t, __read) \\\n\tKSTREAM_INIT2(SCOPE, type_t, __read, 16384) \\\n\t__KSEQ_TYPE(type_t) \\\n\t__KSEQ_BASIC(SCOPE, type_t) \\\n\t__KSEQ_READ(SCOPE)\n\n#define KSEQ_INIT(type_t, __read) KSEQ_INIT2(static, type_t, __read)\n\n#define KSEQ_DECLARE(type_t) \\\n\t__KS_TYPE(type_t) \\\n\t__KSEQ_TYPE(type_t) \\\n\textern kseq_t *kseq_init(type_t fd); \\\n\tvoid kseq_destroy(kseq_t *ks); \\\n\tint kseq_read(kseq_t *seq);\n\n#endif\n"
        },
        {
          "name": "ksort.h",
          "type": "blob",
          "size": 5.0244140625,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n// This is a simplified version of ksort.h\n\n#ifndef AC_KSORT_H\n#define AC_KSORT_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\ntypedef struct {\n\tvoid *left, *right;\n\tint depth;\n} ks_isort_stack_t;\n\n#define KSORT_SWAP(type_t, a, b) { type_t t=(a); (a)=(b); (b)=t; }\n\n#define KSORT_INIT(name, type_t, __sort_lt) \\\n\tvoid ks_heapdown_##name(size_t i, size_t n, type_t l[]) \\\n\t{ \\\n\t\tsize_t k = i; \\\n\t\ttype_t tmp = l[i]; \\\n\t\twhile ((k = (k << 1) + 1) < n) { \\\n\t\t\tif (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k; \\\n\t\t\tif (__sort_lt(l[k], tmp)) break; \\\n\t\t\tl[i] = l[k]; i = k; \\\n\t\t} \\\n\t\tl[i] = tmp; \\\n\t} \\\n\tvoid ks_heapmake_##name(size_t lsize, type_t l[]) \\\n\t{ \\\n\t\tsize_t i; \\\n\t\tfor (i = (lsize >> 1) - 1; i != (size_t)(-1); --i) \\\n\t\t\tks_heapdown_##name(i, lsize, l); \\\n\t} \\\n\ttype_t ks_ksmall_##name(size_t n, type_t arr[], size_t kk)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *low, *high, *k, *ll, *hh, *mid;\t\t\t\t\t\t\t\\\n\t\tlow = arr; high = arr + n - 1; k = arr + kk;\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high <= low) return *k;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high == low + 1) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\t\treturn *k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmid = low + (high - low) / 2;\t\t\t\t\t\t\t\t\\\n\t\t\tif (__sort_lt(*high, *mid)) KSORT_SWAP(type_t, *mid, *high); \\\n\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\tif (__sort_lt(*low, *mid)) KSORT_SWAP(type_t, *mid, *low);\t\\\n\t\t\tKSORT_SWAP(type_t, *mid, *(low+1));\t\t\t\t\t\t\t\\\n\t\t\tll = low + 1; hh = high;\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tdo ++ll; while (__sort_lt(*ll, *low));\t\t\t\t\t\\\n\t\t\t\tdo --hh; while (__sort_lt(*low, *hh));\t\t\t\t\t\\\n\t\t\t\tif (hh < ll) break;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tKSORT_SWAP(type_t, *ll, *hh);\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tKSORT_SWAP(type_t, *low, *hh);\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh <= k) low = ll;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh >= k) high = hh - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#define ks_ksmall(name, n, a, k) ks_ksmall_##name(n, a, k)\n\n#define ks_lt_generic(a, b) ((a) < (b))\n#define ks_lt_str(a, b) (strcmp((a), (b)) < 0)\n\ntypedef const char *ksstr_t;\n\n#define KSORT_INIT_GENERIC(type_t) KSORT_INIT(type_t, type_t, ks_lt_generic)\n#define KSORT_INIT_STR KSORT_INIT(str, ksstr_t, ks_lt_str)\n\n#define RS_MIN_SIZE 64\n#define RS_MAX_BITS 8\n\n#define KRADIX_SORT_INIT(name, rstype_t, rskey, sizeof_key) \\\n\ttypedef struct { \\\n\t\trstype_t *b, *e; \\\n\t} rsbucket_##name##_t; \\\n\tvoid rs_insertsort_##name(rstype_t *beg, rstype_t *end) \\\n\t{ \\\n\t\trstype_t *i; \\\n\t\tfor (i = beg + 1; i < end; ++i) \\\n\t\t\tif (rskey(*i) < rskey(*(i - 1))) { \\\n\t\t\t\trstype_t *j, tmp = *i; \\\n\t\t\t\tfor (j = i; j > beg && rskey(tmp) < rskey(*(j-1)); --j) \\\n\t\t\t\t\t*j = *(j - 1); \\\n\t\t\t\t*j = tmp; \\\n\t\t\t} \\\n\t} \\\n\tvoid rs_sort_##name(rstype_t *beg, rstype_t *end, int n_bits, int s) \\\n\t{ \\\n\t\trstype_t *i; \\\n\t\tint size = 1<<n_bits, m = size - 1; \\\n\t\trsbucket_##name##_t *k, b[1<<RS_MAX_BITS], *be = b + size; \\\n\t\tassert(n_bits <= RS_MAX_BITS); \\\n\t\tfor (k = b; k != be; ++k) k->b = k->e = beg; \\\n\t\tfor (i = beg; i != end; ++i) ++b[rskey(*i)>>s&m].e; \\\n\t\tfor (k = b + 1; k != be; ++k) \\\n\t\t\tk->e += (k-1)->e - beg, k->b = (k-1)->e; \\\n\t\tfor (k = b; k != be;) { \\\n\t\t\tif (k->b != k->e) { \\\n\t\t\t\trsbucket_##name##_t *l; \\\n\t\t\t\tif ((l = b + (rskey(*k->b)>>s&m)) != k) { \\\n\t\t\t\t\trstype_t tmp = *k->b, swap; \\\n\t\t\t\t\tdo { \\\n\t\t\t\t\t\tswap = tmp; tmp = *l->b; *l->b++ = swap; \\\n\t\t\t\t\t\tl = b + (rskey(tmp)>>s&m); \\\n\t\t\t\t\t} while (l != k); \\\n\t\t\t\t\t*k->b++ = tmp; \\\n\t\t\t\t} else ++k->b; \\\n\t\t\t} else ++k; \\\n\t\t} \\\n\t\tfor (b->b = beg, k = b + 1; k != be; ++k) k->b = (k-1)->e; \\\n\t\tif (s) { \\\n\t\t\ts = s > n_bits? s - n_bits : 0; \\\n\t\t\tfor (k = b; k != be; ++k) \\\n\t\t\t\tif (k->e - k->b > RS_MIN_SIZE) rs_sort_##name(k->b, k->e, n_bits, s); \\\n\t\t\t\telse if (k->e - k->b > 1) rs_insertsort_##name(k->b, k->e); \\\n\t\t} \\\n\t} \\\n\tvoid radix_sort_##name(rstype_t *beg, rstype_t *end) \\\n\t{ \\\n\t\tif (end - beg <= RS_MIN_SIZE) rs_insertsort_##name(beg, end); \\\n\t\telse rs_sort_##name(beg, end, RS_MAX_BITS, (sizeof_key - 1) * RS_MAX_BITS); \\\n\t}\n\n#endif\n"
        },
        {
          "name": "ksw2.h",
          "type": "blob",
          "size": 8.5498046875,
          "content": "#ifndef KSW2_H_\n#define KSW2_H_\n\n#include <stdint.h>\n\n#define KSW_NEG_INF -0x40000000\n\n#define KSW_EZ_SCORE_ONLY  0x01 // don't record alignment path/cigar\n#define KSW_EZ_RIGHT       0x02 // right-align gaps\n#define KSW_EZ_GENERIC_SC  0x04 // without this flag: match/mismatch only; last symbol is a wildcard\n#define KSW_EZ_APPROX_MAX  0x08 // approximate max; this is faster with sse\n#define KSW_EZ_APPROX_DROP 0x10 // approximate Z-drop; faster with sse\n#define KSW_EZ_EXTZ_ONLY   0x40 // only perform extension\n#define KSW_EZ_REV_CIGAR   0x80 // reverse CIGAR in the output\n#define KSW_EZ_SPLICE_FOR  0x100\n#define KSW_EZ_SPLICE_REV  0x200\n#define KSW_EZ_SPLICE_FLANK 0x400\n#define KSW_EZ_SPLICE_CMPLX 0x800  // use the miniprot splice model\n#define KSW_EZ_SPLICE_SCORE 0x1000 // use splice score\n\n// The subset of CIGAR operators used by ksw code.\n// Use MM_CIGAR_* from minimap.h if you need the full list.\n#define KSW_CIGAR_MATCH  0\n#define KSW_CIGAR_INS    1\n#define KSW_CIGAR_DEL    2\n#define KSW_CIGAR_N_SKIP 3\n\n#define KSW_SPSC_OFFSET  64\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\tuint32_t max:31, zdropped:1;\n\tint max_q, max_t;      // max extension coordinate\n\tint mqe, mqe_t;        // max score when reaching the end of query\n\tint mte, mte_q;        // max score when reaching the end of target\n\tint score;             // max score reaching both ends; may be KSW_NEG_INF\n\tint m_cigar, n_cigar;\n\tint reach_end;\n\tuint32_t *cigar;\n} ksw_extz_t;\n\n/**\n * NW-like extension\n *\n * @param km        memory pool, when used with kalloc\n * @param qlen      query length\n * @param query     query sequence with 0 <= query[i] < m\n * @param tlen      target length\n * @param target    target sequence with 0 <= target[i] < m\n * @param m         number of residue types\n * @param mat       m*m scoring mattrix in one-dimension array\n * @param gapo      gap open penalty; a gap of length l cost \"-(gapo+l*gape)\"\n * @param gape      gap extension penalty\n * @param w         band width (<0 to disable)\n * @param zdrop     off-diagonal drop-off to stop extension (positive; <0 to disable)\n * @param flag      flag (see KSW_EZ_* macros)\n * @param ez        (out) scores and cigar\n */\nvoid ksw_extz(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t  int8_t q, int8_t e, int w, int zdrop, int flag, ksw_extz_t *ez);\n\nvoid ksw_extz2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\nvoid ksw_extd(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t  int8_t gapo, int8_t gape, int8_t gapo2, int8_t gape2, int w, int zdrop, int flag, ksw_extz_t *ez);\n\nvoid ksw_extd2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t gapo, int8_t gape, int8_t gapo2, int8_t gape2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\nvoid ksw_exts2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t gapo, int8_t gape, int8_t gapo2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez);\n\nvoid ksw_extf2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t mch, int8_t mis, int8_t e, int w, int xdrop, ksw_extz_t *ez);\n\n/**\n * Global alignment\n *\n * (first 10 parameters identical to ksw_extz_sse())\n * @param m_cigar   (modified) max CIGAR length; feed 0 if cigar==0\n * @param n_cigar   (out) number of CIGAR elements\n * @param cigar     (out) BAM-encoded CIGAR; caller need to deallocate with kfree(km, )\n *\n * @return          score of the alignment\n */\nint ksw_gg(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t gapo, int8_t gape, int w, int *m_cigar_, int *n_cigar_, uint32_t **cigar_);\nint ksw_gg2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t gapo, int8_t gape, int w, int *m_cigar_, int *n_cigar_, uint32_t **cigar_);\nint ksw_gg2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t gapo, int8_t gape, int w, int *m_cigar_, int *n_cigar_, uint32_t **cigar_);\n\nvoid *ksw_ll_qinit(void *km, int size, int qlen, const uint8_t *query, int m, const int8_t *mat);\nint ksw_ll_i16(void *q, int tlen, const uint8_t *target, int gapo, int gape, int *qe, int *te);\n\n#ifdef __cplusplus\n}\n#endif\n\n/************************************\n *** Private macros and functions ***\n ************************************/\n\n#ifdef HAVE_KALLOC\n#include \"kalloc.h\"\n#else\n#include <stdlib.h>\n#define kmalloc(km, size) malloc((size))\n#define kcalloc(km, count, size) calloc((count), (size))\n#define krealloc(km, ptr, size) realloc((ptr), (size))\n#define kfree(km, ptr) free((ptr))\n#endif\n\nstatic inline uint32_t *ksw_push_cigar(void *km, int *n_cigar, int *m_cigar, uint32_t *cigar, uint32_t op, int len)\n{\n\tif (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {\n\t\tif (*n_cigar == *m_cigar) {\n\t\t\t*m_cigar = *m_cigar? (*m_cigar)<<1 : 4;\n\t\t\tcigar = (uint32_t*)krealloc(km, cigar, (*m_cigar) << 2);\n\t\t}\n\t\tcigar[(*n_cigar)++] = len<<4 | op;\n\t} else cigar[(*n_cigar)-1] += len<<4;\n\treturn cigar;\n}\n\n// In the backtrack matrix, value p[] has the following structure:\n//   bit 0-2: which type gets the max - 0 for H, 1 for E, 2 for F, 3 for \\tilde{E} and 4 for \\tilde{F}\n//   bit 3/0x08: 1 if a continuation on the E state (bit 5/0x20 for a continuation on \\tilde{E})\n//   bit 4/0x10: 1 if a continuation on the F state (bit 6/0x40 for a continuation on \\tilde{F})\nstatic inline void ksw_backtrack(void *km, int is_rot, int is_rev, int min_intron_len, const uint8_t *p, const int *off, const int *off_end, int n_col, int i0, int j0,\n\t\t\t\t\t\t\t\t int *m_cigar_, int *n_cigar_, uint32_t **cigar_)\n{ // p[] - lower 3 bits: which type gets the max; bit\n\tint n_cigar = 0, m_cigar = *m_cigar_, i = i0, j = j0, r, state = 0;\n\tuint32_t *cigar = *cigar_, tmp;\n\twhile (i >= 0 && j >= 0) { // at the beginning of the loop, _state_ tells us which state to check\n\t\tint force_state = -1;\n\t\tif (is_rot) {\n\t\t\tr = i + j;\n\t\t\tif (i < off[r]) force_state = 2;\n\t\t\tif (off_end && i > off_end[r]) force_state = 1;\n\t\t\ttmp = force_state < 0? p[(size_t)r * n_col + i - off[r]] : 0;\n\t\t} else {\n\t\t\tif (j < off[i]) force_state = 2;\n\t\t\tif (off_end && j > off_end[i]) force_state = 1;\n\t\t\ttmp = force_state < 0? p[(size_t)i * n_col + j - off[i]] : 0;\n\t\t}\n\t\tif (state == 0) state = tmp & 7; // if requesting the H state, find state one maximizes it.\n\t\telse if (!(tmp >> (state + 2) & 1)) state = 0; // if requesting other states, _state_ stays the same if it is a continuation; otherwise, set to H\n\t\tif (state == 0) state = tmp & 7; // TODO: probably this line can be merged into the \"else if\" line right above; not 100% sure\n\t\tif (force_state >= 0) state = force_state;\n\t\tif (state == 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, KSW_CIGAR_MATCH, 1), --i, --j;\n\t\telse if (state == 1 || (state == 3 && min_intron_len <= 0)) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, KSW_CIGAR_DEL, 1), --i;\n\t\telse if (state == 3 && min_intron_len > 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, KSW_CIGAR_N_SKIP, 1), --i;\n\t\telse cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, KSW_CIGAR_INS, 1), --j;\n\t}\n\tif (i >= 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, min_intron_len > 0 && i >= min_intron_len? KSW_CIGAR_N_SKIP : KSW_CIGAR_DEL, i + 1); // first deletion\n\tif (j >= 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, KSW_CIGAR_INS, j + 1); // first insertion\n\tif (!is_rev)\n\t\tfor (i = 0; i < n_cigar>>1; ++i) // reverse CIGAR\n\t\t\ttmp = cigar[i], cigar[i] = cigar[n_cigar-1-i], cigar[n_cigar-1-i] = tmp;\n\t*m_cigar_ = m_cigar, *n_cigar_ = n_cigar, *cigar_ = cigar;\n}\n\nstatic inline void ksw_reset_extz(ksw_extz_t *ez)\n{\n\tez->max_q = ez->max_t = ez->mqe_t = ez->mte_q = -1;\n\tez->max = 0, ez->score = ez->mqe = ez->mte = KSW_NEG_INF;\n\tez->n_cigar = 0, ez->zdropped = 0, ez->reach_end = 0;\n}\n\nstatic inline int ksw_apply_zdrop(ksw_extz_t *ez, int is_rot, int32_t H, int a, int b, int zdrop, int8_t e)\n{\n\tint r, t;\n\tif (is_rot) r = a, t = b;\n\telse r = a + b, t = a;\n\tif (H > (int32_t)ez->max) {\n\t\tez->max = H, ez->max_t = t, ez->max_q = r - t;\n\t} else if (t >= ez->max_t && r - t >= ez->max_q) {\n\t\tint tl = t - ez->max_t, ql = (r - t) - ez->max_q, l;\n\t\tl = tl > ql? tl - ql : ql - tl;\n\t\tif (zdrop >= 0 && ez->max - H > zdrop + l * e) {\n\t\t\tez->zdropped = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "ksw2_dispatch.c",
          "type": "blob",
          "size": 4.5673828125,
          "content": "#ifdef KSW_CPU_DISPATCH\n#include <stdlib.h>\n#include \"ksw2.h\"\n\n#define SIMD_SSE     0x1\n#define SIMD_SSE2    0x2\n#define SIMD_SSE3    0x4\n#define SIMD_SSSE3   0x8\n#define SIMD_SSE4_1  0x10\n#define SIMD_SSE4_2  0x20\n#define SIMD_AVX     0x40\n#define SIMD_AVX2    0x80\n#define SIMD_AVX512F 0x100\n\n#ifndef _MSC_VER\n// adapted from https://github.com/01org/linux-sgx/blob/master/common/inc/internal/linux/cpuid_gnu.h\nvoid __cpuidex(int cpuid[4], int func_id, int subfunc_id)\n{\n#if defined(__x86_64__)\n\t__asm__ volatile (\"cpuid\"\n\t\t\t: \"=a\" (cpuid[0]), \"=b\" (cpuid[1]), \"=c\" (cpuid[2]), \"=d\" (cpuid[3])\n\t\t\t: \"0\" (func_id), \"2\" (subfunc_id));\n#else // on 32bit, ebx can NOT be used as PIC code\n\t__asm__ volatile (\"xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1\"\n\t\t\t: \"=a\" (cpuid[0]), \"=r\" (cpuid[1]), \"=c\" (cpuid[2]), \"=d\" (cpuid[3])\n\t\t\t: \"0\" (func_id), \"2\" (subfunc_id));\n#endif\n}\n#endif\n\nstatic int ksw_simd = -1;\n\nstatic int x86_simd(void)\n{\n\tint flag = 0, cpuid[4], max_id;\n\t__cpuidex(cpuid, 0, 0);\n\tmax_id = cpuid[0];\n\tif (max_id == 0) return 0;\n\t__cpuidex(cpuid, 1, 0);\n\tif (cpuid[3]>>25&1) flag |= SIMD_SSE;\n\tif (cpuid[3]>>26&1) flag |= SIMD_SSE2;\n\tif (cpuid[2]>>0 &1) flag |= SIMD_SSE3;\n\tif (cpuid[2]>>9 &1) flag |= SIMD_SSSE3;\n\tif (cpuid[2]>>19&1) flag |= SIMD_SSE4_1;\n\tif (cpuid[2]>>20&1) flag |= SIMD_SSE4_2;\n\tif (cpuid[2]>>28&1) flag |= SIMD_AVX;\n\tif (max_id >= 7) {\n\t\t__cpuidex(cpuid, 7, 0);\n\t\tif (cpuid[1]>>5 &1) flag |= SIMD_AVX2;\n\t\tif (cpuid[1]>>16&1) flag |= SIMD_AVX512F;\n\t}\n\treturn flag;\n}\n\nvoid ksw_extz2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n{\n\textern void ksw_extz2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\textern void ksw_extz2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\tif (ksw_simd < 0) ksw_simd = x86_simd();\n\tif (ksw_simd & SIMD_SSE4_1)\n\t\tksw_extz2_sse41(km, qlen, query, tlen, target, m, mat, q, e, w, zdrop, end_bonus, flag, ez);\n\telse if (ksw_simd & SIMD_SSE2)\n\t\tksw_extz2_sse2(km, qlen, query, tlen, target, m, mat, q, e, w, zdrop, end_bonus, flag, ez);\n\telse abort();\n}\n\nvoid ksw_extd2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n{\n\textern void ksw_extd2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\textern void ksw_extd2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez);\n\tif (ksw_simd < 0) ksw_simd = x86_simd();\n\tif (ksw_simd & SIMD_SSE4_1)\n\t\tksw_extd2_sse41(km, qlen, query, tlen, target, m, mat, q, e, q2, e2, w, zdrop, end_bonus, flag, ez);\n\telse if (ksw_simd & SIMD_SSE2)\n\t\tksw_extd2_sse2(km, qlen, query, tlen, target, m, mat, q, e, q2, e2, w, zdrop, end_bonus, flag, ez);\n\telse abort();\n}\n\nvoid ksw_exts2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez)\n{\n\textern void ksw_exts2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez);\n\textern void ksw_exts2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez);\n\tif (ksw_simd < 0) ksw_simd = x86_simd();\n\tif (ksw_simd & SIMD_SSE4_1)\n\t\tksw_exts2_sse41(km, qlen, query, tlen, target, m, mat, q, e, q2, noncan, zdrop, junc_bonus, junc_pen, flag, junc, ez);\n\telse if (ksw_simd & SIMD_SSE2)\n\t\tksw_exts2_sse2(km, qlen, query, tlen, target, m, mat, q, e, q2, noncan, zdrop, junc_bonus, junc_pen, flag, junc, ez);\n\telse abort();\n}\n#endif\n"
        },
        {
          "name": "ksw2_extd2_sse.c",
          "type": "blob",
          "size": 17.1708984375,
          "content": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"ksw2.h\"\n\n#ifdef __SSE2__\n#ifdef USE_SIMDE\n#include <simde/x86/sse2.h>\n#else\n#include <emmintrin.h>\n#endif\n\n#ifdef KSW_SSE2_ONLY\n#undef __SSE4_1__\n#endif\n\n#ifdef __SSE4_1__\n#ifdef USE_SIMDE\n#include <simde/x86/sse4.1.h>\n#else\n#include <smmintrin.h>\n#endif\n#endif\n\n#ifdef KSW_CPU_DISPATCH\n#ifdef __SSE4_1__\nvoid ksw_extd2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#else\nvoid ksw_extd2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#endif\n#else\nvoid ksw_extd2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#endif // ~KSW_CPU_DISPATCH\n{\n#define __dp_code_block1 \\\n\tz = _mm_load_si128(&s[t]); \\\n\txt1 = _mm_load_si128(&x[t]);                     /* xt1 <- x[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(xt1, 15);                   /* tmp <- x[r-1][t+15] */ \\\n\txt1 = _mm_or_si128(_mm_slli_si128(xt1, 1), x1_); /* xt1 <- x[r-1][t-1..t+14] */ \\\n\tx1_ = tmp; \\\n\tvt1 = _mm_load_si128(&v[t]);                     /* vt1 <- v[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(vt1, 15);                   /* tmp <- v[r-1][t+15] */ \\\n\tvt1 = _mm_or_si128(_mm_slli_si128(vt1, 1), v1_); /* vt1 <- v[r-1][t-1..t+14] */ \\\n\tv1_ = tmp; \\\n\ta = _mm_add_epi8(xt1, vt1);                      /* a <- x[r-1][t-1..t+14] + v[r-1][t-1..t+14] */ \\\n\tut = _mm_load_si128(&u[t]);                      /* ut <- u[t..t+15] */ \\\n\tb = _mm_add_epi8(_mm_load_si128(&y[t]), ut);     /* b <- y[r-1][t..t+15] + u[r-1][t..t+15] */ \\\n\tx2t1= _mm_load_si128(&x2[t]); \\\n\ttmp = _mm_srli_si128(x2t1, 15); \\\n\tx2t1= _mm_or_si128(_mm_slli_si128(x2t1, 1), x21_); \\\n\tx21_= tmp; \\\n\ta2= _mm_add_epi8(x2t1, vt1); \\\n\tb2= _mm_add_epi8(_mm_load_si128(&y2[t]), ut);\n\n#define __dp_code_block2 \\\n\t_mm_store_si128(&u[t], _mm_sub_epi8(z, vt1));    /* u[r][t..t+15] <- z - v[r-1][t-1..t+14] */ \\\n\t_mm_store_si128(&v[t], _mm_sub_epi8(z, ut));     /* v[r][t..t+15] <- z - u[r-1][t..t+15] */ \\\n\ttmp = _mm_sub_epi8(z, q_); \\\n\ta = _mm_sub_epi8(a, tmp); \\\n\tb = _mm_sub_epi8(b, tmp); \\\n\ttmp = _mm_sub_epi8(z, q2_); \\\n\ta2= _mm_sub_epi8(a2, tmp); \\\n\tb2= _mm_sub_epi8(b2, tmp);\n\n\tint r, t, qe = q + e, n_col_, *off = 0, *off_end = 0, tlen_, qlen_, last_st, last_en, wl, wr, max_sc, min_sc, long_thres, long_diff;\n\tint with_cigar = !(flag&KSW_EZ_SCORE_ONLY), approx_max = !!(flag&KSW_EZ_APPROX_MAX);\n\tint32_t *H = 0, H0 = 0, last_H0_t = 0;\n\tuint8_t *qr, *sf, *mem, *mem2 = 0;\n\t__m128i q_, q2_, qe_, qe2_, zero_, sc_mch_, sc_mis_, m1_, sc_N_;\n\t__m128i *u, *v, *x, *y, *x2, *y2, *s, *p = 0;\n\n\tksw_reset_extz(ez);\n\tif (m <= 1 || qlen <= 0 || tlen <= 0) return;\n\n\tif (q2 + e2 < q + e) t = q, q = q2, q2 = t, t = e, e = e2, e2 = t; // make sure q+e no larger than q2+e2\n\n\tzero_   = _mm_set1_epi8(0);\n\tq_      = _mm_set1_epi8(q);\n\tq2_     = _mm_set1_epi8(q2);\n\tqe_     = _mm_set1_epi8(q + e);\n\tqe2_    = _mm_set1_epi8(q2 + e2);\n\tsc_mch_ = _mm_set1_epi8(mat[0]);\n\tsc_mis_ = _mm_set1_epi8(mat[1]);\n\tsc_N_   = mat[m*m-1] == 0? _mm_set1_epi8(-e2) : _mm_set1_epi8(mat[m*m-1]);\n\tm1_     = _mm_set1_epi8(m - 1); // wildcard\n\n\tif (w < 0) w = tlen > qlen? tlen : qlen;\n\twl = wr = w;\n\ttlen_ = (tlen + 15) / 16;\n\tn_col_ = qlen < tlen? qlen : tlen;\n\tn_col_ = ((n_col_ < w + 1? n_col_ : w + 1) + 15) / 16 + 1;\n\tqlen_ = (qlen + 15) / 16;\n\tfor (t = 1, max_sc = mat[0], min_sc = mat[1]; t < m * m; ++t) {\n\t\tmax_sc = max_sc > mat[t]? max_sc : mat[t];\n\t\tmin_sc = min_sc < mat[t]? min_sc : mat[t];\n\t}\n\tif (-min_sc > 2 * (q + e)) return; // otherwise, we won't see any mismatches\n\n\tlong_thres = e != e2? (q2 - q) / (e - e2) - 1 : 0;\n\tif (q2 + e2 + long_thres * e2 > q + e + long_thres * e)\n\t\t++long_thres;\n\tlong_diff = long_thres * (e - e2) - (q2 - q) - e2;\n\n\tmem = (uint8_t*)kcalloc(km, tlen_ * 8 + qlen_ + 1, 16);\n\tu = (__m128i*)(((size_t)mem + 15) >> 4 << 4); // 16-byte aligned\n\tv = u + tlen_, x = v + tlen_, y = x + tlen_, x2 = y + tlen_, y2 = x2 + tlen_;\n\ts = y2 + tlen_, sf = (uint8_t*)(s + tlen_), qr = sf + tlen_ * 16;\n\tmemset(u,  -q  - e,  tlen_ * 16);\n\tmemset(v,  -q  - e,  tlen_ * 16);\n\tmemset(x,  -q  - e,  tlen_ * 16);\n\tmemset(y,  -q  - e,  tlen_ * 16);\n\tmemset(x2, -q2 - e2, tlen_ * 16);\n\tmemset(y2, -q2 - e2, tlen_ * 16);\n\tif (!approx_max) {\n\t\tH = (int32_t*)kmalloc(km, tlen_ * 16 * 4);\n\t\tfor (t = 0; t < tlen_ * 16; ++t) H[t] = KSW_NEG_INF;\n\t}\n\tif (with_cigar) {\n\t\tmem2 = (uint8_t*)kmalloc(km, ((size_t)(qlen + tlen - 1) * n_col_ + 1) * 16);\n\t\tp = (__m128i*)(((size_t)mem2 + 15) >> 4 << 4);\n\t\toff = (int*)kmalloc(km, (qlen + tlen - 1) * sizeof(int) * 2);\n\t\toff_end = off + qlen + tlen - 1;\n\t}\n\n\tfor (t = 0; t < qlen; ++t) qr[t] = query[qlen - 1 - t];\n\tmemcpy(sf, target, tlen);\n\n\tfor (r = 0, last_st = last_en = -1; r < qlen + tlen - 1; ++r) {\n\t\tint st = 0, en = tlen - 1, st0, en0, st_, en_;\n\t\tint8_t x1, x21, v1;\n\t\tuint8_t *qrr = qr + (qlen - 1 - r);\n\t\tint8_t *u8 = (int8_t*)u, *v8 = (int8_t*)v, *x8 = (int8_t*)x, *x28 = (int8_t*)x2;\n\t\t__m128i x1_, x21_, v1_;\n\t\t// find the boundaries\n\t\tif (st < r - qlen + 1) st = r - qlen + 1;\n\t\tif (en > r) en = r;\n\t\tif (st < (r-wr+1)>>1) st = (r-wr+1)>>1; // take the ceil\n\t\tif (en > (r+wl)>>1) en = (r+wl)>>1; // take the floor\n\t\tif (st > en) {\n\t\t\tez->zdropped = 1;\n\t\t\tbreak;\n\t\t}\n\t\tst0 = st, en0 = en;\n\t\tst = st / 16 * 16, en = (en + 16) / 16 * 16 - 1;\n\t\t// set boundary conditions\n\t\tif (st > 0) {\n\t\t\tif (st - 1 >= last_st && st - 1 <= last_en) {\n\t\t\t\tx1 = x8[st - 1], x21 = x28[st - 1], v1 = v8[st - 1]; // (r-1,s-1) calculated in the last round\n\t\t\t} else {\n\t\t\t\tx1 = -q - e, x21 = -q2 - e2;\n\t\t\t\tv1 = -q - e;\n\t\t\t}\n\t\t} else {\n\t\t\tx1 = -q - e, x21 = -q2 - e2;\n\t\t\tv1 = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : -e2;\n\t\t}\n\t\tif (en >= r) {\n\t\t\t((int8_t*)y)[r] = -q - e, ((int8_t*)y2)[r] = -q2 - e2;\n\t\t\tu8[r] = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : -e2;\n\t\t}\n\t\t// loop fission: set scores first\n\t\tif (!(flag & KSW_EZ_GENERIC_SC)) {\n\t\t\tfor (t = st0; t <= en0; t += 16) {\n\t\t\t\t__m128i sq, st, tmp, mask;\n\t\t\t\tsq = _mm_loadu_si128((__m128i*)&sf[t]);\n\t\t\t\tst = _mm_loadu_si128((__m128i*)&qrr[t]);\n\t\t\t\tmask = _mm_or_si128(_mm_cmpeq_epi8(sq, m1_), _mm_cmpeq_epi8(st, m1_));\n\t\t\t\ttmp = _mm_cmpeq_epi8(sq, st);\n#ifdef __SSE4_1__\n\t\t\t\ttmp = _mm_blendv_epi8(sc_mis_, sc_mch_, tmp);\n\t\t\t\ttmp = _mm_blendv_epi8(tmp,     sc_N_,   mask);\n#else\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(tmp,  sc_mis_), _mm_and_si128(tmp,  sc_mch_));\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(mask, tmp),     _mm_and_si128(mask, sc_N_));\n#endif\n\t\t\t\t_mm_storeu_si128((__m128i*)((int8_t*)s + t), tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (t = st0; t <= en0; ++t)\n\t\t\t\t((uint8_t*)s)[t] = mat[sf[t] * m + qrr[t]];\n\t\t}\n\t\t// core loop\n\t\tx1_  = _mm_cvtsi32_si128((uint8_t)x1);\n\t\tx21_ = _mm_cvtsi32_si128((uint8_t)x21);\n\t\tv1_  = _mm_cvtsi32_si128((uint8_t)v1);\n\t\tst_ = st / 16, en_ = en / 16;\n\t\tassert(en_ - st_ + 1 <= n_col_);\n\t\tif (!with_cigar) { // score only\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\tz = _mm_max_epi8(z, a2);\n\t\t\t\tz = _mm_max_epi8(z, b2);\n\t\t\t\tz = _mm_min_epi8(z, sc_mch_);\n\t\t\t\t__dp_code_block2; // save u[] and v[]; update a, b, a2 and b2\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_max_epi8(a,  zero_), qe_));\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_max_epi8(b,  zero_), qe_));\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_max_epi8(a2, zero_), qe2_));\n\t\t\t\t_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_max_epi8(b2, zero_), qe2_));\n#else\n\t\t\t\ttmp = _mm_cmpgt_epi8(a,  z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b,  z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a2));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b2, z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b2));\n\t\t\t\ttmp = _mm_cmplt_epi8(sc_mch_, z);\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, sc_mch_), _mm_andnot_si128(tmp, z));\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_and_si128(tmp, a),  qe_));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_and_si128(tmp, b),  qe_));\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, zero_);\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_and_si128(tmp, a2), qe2_));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b2, zero_);\n\t\t\t\t_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_and_si128(tmp, b2), qe2_));\n#endif\n\t\t\t}\n\t\t} else if (!(flag&KSW_EZ_RIGHT)) { // gap left-alignment\n\t\t\t__m128i *pr = p + (size_t)r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\td = _mm_and_si128(_mm_cmpgt_epi8(a, z), _mm_set1_epi8(1));       // d = a  > z? 1 : 0\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\td = _mm_blendv_epi8(d, _mm_set1_epi8(2), _mm_cmpgt_epi8(b,  z)); // d = b  > z? 2 : d\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\td = _mm_blendv_epi8(d, _mm_set1_epi8(3), _mm_cmpgt_epi8(a2, z)); // d = a2 > z? 3 : d\n\t\t\t\tz = _mm_max_epi8(z, a2);\n\t\t\t\td = _mm_blendv_epi8(d, _mm_set1_epi8(4), _mm_cmpgt_epi8(b2, z)); // d = a2 > z? 3 : d\n\t\t\t\tz = _mm_max_epi8(z, b2);\n\t\t\t\tz = _mm_min_epi8(z, sc_mch_);\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\ttmp = _mm_cmpgt_epi8(a,  z);\n\t\t\t\td = _mm_and_si128(tmp, _mm_set1_epi8(1));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b,  z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, _mm_set1_epi8(2)));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, _mm_set1_epi8(3)));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a2));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b2, z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, _mm_set1_epi8(4)));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b2));\n\t\t\t\ttmp = _mm_cmplt_epi8(sc_mch_, z);\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, sc_mch_), _mm_andnot_si128(tmp, z));\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_and_si128(tmp, a),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x08))); // d = a > 0? 1<<3 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_and_si128(tmp, b),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x10))); // d = b > 0? 1<<4 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, zero_);\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_and_si128(tmp, a2), qe2_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x20))); // d = a > 0? 1<<5 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(b2, zero_);\n\t\t\t\t_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_and_si128(tmp, b2), qe2_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x40))); // d = b > 0? 1<<6 : 0\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t} else { // gap right-alignment\n\t\t\t__m128i *pr = p + (size_t)r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\td = _mm_andnot_si128(_mm_cmpgt_epi8(z, a), _mm_set1_epi8(1));    // d = z > a?  0 : 1\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\td = _mm_blendv_epi8(_mm_set1_epi8(2), d, _mm_cmpgt_epi8(z, b));  // d = z > b?  d : 2\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\td = _mm_blendv_epi8(_mm_set1_epi8(3), d, _mm_cmpgt_epi8(z, a2)); // d = z > a2? d : 3\n\t\t\t\tz = _mm_max_epi8(z, a2);\n\t\t\t\td = _mm_blendv_epi8(_mm_set1_epi8(4), d, _mm_cmpgt_epi8(z, b2)); // d = z > b2? d : 4\n\t\t\t\tz = _mm_max_epi8(z, b2);\n\t\t\t\tz = _mm_min_epi8(z, sc_mch_);\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, a);\n\t\t\t\td = _mm_andnot_si128(tmp, _mm_set1_epi8(1));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, b);\n\t\t\t\td = _mm_or_si128(_mm_and_si128(tmp, d), _mm_andnot_si128(tmp, _mm_set1_epi8(2)));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, a2);\n\t\t\t\td = _mm_or_si128(_mm_and_si128(tmp, d), _mm_andnot_si128(tmp, _mm_set1_epi8(3)));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, a2));\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, b2);\n\t\t\t\td = _mm_or_si128(_mm_and_si128(tmp, d), _mm_andnot_si128(tmp, _mm_set1_epi8(4)));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, b2));\n\t\t\t\ttmp = _mm_cmplt_epi8(sc_mch_, z);\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, sc_mch_), _mm_andnot_si128(tmp, z));\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, a);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_andnot_si128(tmp, a),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x08))); // d = a > 0? 1<<3 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, b);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_andnot_si128(tmp, b),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x10))); // d = b > 0? 1<<4 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, a2);\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_andnot_si128(tmp, a2), qe2_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x20))); // d = a > 0? 1<<5 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, b2);\n\t\t\t\t_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_andnot_si128(tmp, b2), qe2_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x40))); // d = b > 0? 1<<6 : 0\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t}\n\t\tif (!approx_max) { // find the exact max with a 32-bit score array\n\t\t\tint32_t max_H, max_t;\n\t\t\t// compute H[], max_H and max_t\n\t\t\tif (r > 0) {\n\t\t\t\tint32_t HH[4], tt[4], en1 = st0 + (en0 - st0) / 4 * 4, i;\n\t\t\t\t__m128i max_H_, max_t_;\n\t\t\t\tmax_H = H[en0] = en0 > 0? H[en0-1] + u8[en0] : H[en0] + v8[en0]; // special casing the last element\n\t\t\t\tmax_t = en0;\n\t\t\t\tmax_H_ = _mm_set1_epi32(max_H);\n\t\t\t\tmax_t_ = _mm_set1_epi32(max_t);\n\t\t\t\tfor (t = st0; t < en1; t += 4) { // this implements: H[t]+=v8[t]-qe; if(H[t]>max_H) max_H=H[t],max_t=t;\n\t\t\t\t\t__m128i H1, tmp, t_;\n\t\t\t\t\tH1 = _mm_loadu_si128((__m128i*)&H[t]);\n\t\t\t\t\tt_ = _mm_setr_epi32(v8[t], v8[t+1], v8[t+2], v8[t+3]);\n\t\t\t\t\tH1 = _mm_add_epi32(H1, t_);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)&H[t], H1);\n\t\t\t\t\tt_ = _mm_set1_epi32(t);\n\t\t\t\t\ttmp = _mm_cmpgt_epi32(H1, max_H_);\n#ifdef __SSE4_1__\n\t\t\t\t\tmax_H_ = _mm_blendv_epi8(max_H_, H1, tmp);\n\t\t\t\t\tmax_t_ = _mm_blendv_epi8(max_t_, t_, tmp);\n#else\n\t\t\t\t\tmax_H_ = _mm_or_si128(_mm_and_si128(tmp, H1), _mm_andnot_si128(tmp, max_H_));\n\t\t\t\t\tmax_t_ = _mm_or_si128(_mm_and_si128(tmp, t_), _mm_andnot_si128(tmp, max_t_));\n#endif\n\t\t\t\t}\n\t\t\t\t_mm_storeu_si128((__m128i*)HH, max_H_);\n\t\t\t\t_mm_storeu_si128((__m128i*)tt, max_t_);\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\tif (max_H < HH[i]) max_H = HH[i], max_t = tt[i] + i;\n\t\t\t\tfor (; t < en0; ++t) { // for the rest of values that haven't been computed with SSE\n\t\t\t\t\tH[t] += (int32_t)v8[t];\n\t\t\t\t\tif (H[t] > max_H)\n\t\t\t\t\t\tmax_H = H[t], max_t = t;\n\t\t\t\t}\n\t\t\t} else H[0] = v8[0] - qe, max_H = H[0], max_t = 0; // special casing r==0\n\t\t\t// update ez\n\t\t\tif (en0 == tlen - 1 && H[en0] > ez->mte)\n\t\t\t\tez->mte = H[en0], ez->mte_q = r - en0;\n\t\t\tif (r - st0 == qlen - 1 && H[st0] > ez->mqe)\n\t\t\t\tez->mqe = H[st0], ez->mqe_t = st0;\n\t\t\tif (ksw_apply_zdrop(ez, 1, max_H, r, max_t, zdrop, e2)) break;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H[tlen - 1];\n\t\t} else { // find approximate max; Z-drop might be inaccurate, too.\n\t\t\tif (r > 0) {\n\t\t\t\tif (last_H0_t >= st0 && last_H0_t <= en0 && last_H0_t + 1 >= st0 && last_H0_t + 1 <= en0) {\n\t\t\t\t\tint32_t d0 = v8[last_H0_t];\n\t\t\t\t\tint32_t d1 = u8[last_H0_t + 1];\n\t\t\t\t\tif (d0 > d1) H0 += d0;\n\t\t\t\t\telse H0 += d1, ++last_H0_t;\n\t\t\t\t} else if (last_H0_t >= st0 && last_H0_t <= en0) {\n\t\t\t\t\tH0 += v8[last_H0_t];\n\t\t\t\t} else {\n\t\t\t\t\t++last_H0_t, H0 += u8[last_H0_t];\n\t\t\t\t}\n\t\t\t} else H0 = v8[0] - qe, last_H0_t = 0;\n\t\t\tif ((flag & KSW_EZ_APPROX_DROP) && ksw_apply_zdrop(ez, 1, H0, r, last_H0_t, zdrop, e2)) break;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H0;\n\t\t}\n\t\tlast_st = st, last_en = en;\n\t\t//for (t = st0; t <= en0; ++t) printf(\"(%d,%d)\\t(%d,%d,%d,%d)\\t%d\\n\", r, t, ((int8_t*)u)[t], ((int8_t*)v)[t], ((int8_t*)x)[t], ((int8_t*)y)[t], H[t]); // for debugging\n\t}\n\tkfree(km, mem);\n\tif (!approx_max) kfree(km, H);\n\tif (with_cigar) { // backtrack\n\t\tint rev_cigar = !!(flag & KSW_EZ_REV_CIGAR);\n\t\tif (!ez->zdropped && !(flag&KSW_EZ_EXTZ_ONLY)) {\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, tlen-1, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t} else if (!ez->zdropped && (flag&KSW_EZ_EXTZ_ONLY) && ez->mqe + end_bonus > (int)ez->max) {\n\t\t\tez->reach_end = 1;\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->mqe_t, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t} else if (ez->max_t >= 0 && ez->max_q >= 0) {\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->max_t, ez->max_q, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t}\n\t\tkfree(km, mem2); kfree(km, off);\n\t}\n}\n#endif // __SSE2__\n"
        },
        {
          "name": "ksw2_exts2_sse.c",
          "type": "blob",
          "size": 20.009765625,
          "content": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"ksw2.h\"\n\n#ifdef __SSE2__\n#ifdef USE_SIMDE\n#include <simde/x86/sse2.h>\n#else\n#include <emmintrin.h>\n#endif\n#ifdef KSW_SSE2_ONLY\n#undef __SSE4_1__\n#endif\n\n#ifdef __SSE4_1__\n#ifdef USE_SIMDE\n#include <simde/x86/sse4.1.h>\n#else\n#include <smmintrin.h>\n#endif\n#endif\n\n#ifdef KSW_CPU_DISPATCH\n#ifdef __SSE4_1__\nvoid ksw_exts2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez)\n#else\nvoid ksw_exts2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez)\n#endif\n#else\nvoid ksw_exts2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,\n\t\t\t\t   int8_t q, int8_t e, int8_t q2, int8_t noncan, int zdrop, int8_t junc_bonus, int8_t junc_pen, int flag, const uint8_t *junc, ksw_extz_t *ez)\n#endif // ~KSW_CPU_DISPATCH\n{\n#define __dp_code_block1 \\\n\tz = _mm_load_si128(&s[t]); \\\n\txt1 = _mm_load_si128(&x[t]);                     /* xt1 <- x[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(xt1, 15);                   /* tmp <- x[r-1][t+15] */ \\\n\txt1 = _mm_or_si128(_mm_slli_si128(xt1, 1), x1_); /* xt1 <- x[r-1][t-1..t+14] */ \\\n\tx1_ = tmp; \\\n\tvt1 = _mm_load_si128(&v[t]);                     /* vt1 <- v[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(vt1, 15);                   /* tmp <- v[r-1][t+15] */ \\\n\tvt1 = _mm_or_si128(_mm_slli_si128(vt1, 1), v1_); /* vt1 <- v[r-1][t-1..t+14] */ \\\n\tv1_ = tmp; \\\n\ta = _mm_add_epi8(xt1, vt1);                      /* a <- x[r-1][t-1..t+14] + v[r-1][t-1..t+14] */ \\\n\tut = _mm_load_si128(&u[t]);                      /* ut <- u[t..t+15] */ \\\n\tb = _mm_add_epi8(_mm_load_si128(&y[t]), ut);     /* b <- y[r-1][t..t+15] + u[r-1][t..t+15] */ \\\n\tx2t1= _mm_load_si128(&x2[t]); \\\n\ttmp = _mm_srli_si128(x2t1, 15); \\\n\tx2t1= _mm_or_si128(_mm_slli_si128(x2t1, 1), x21_); \\\n\tx21_= tmp; \\\n\ta2  = _mm_add_epi8(x2t1, vt1); \\\n\ta2a = _mm_add_epi8(a2, _mm_load_si128(&acceptor[t]));\n\n#define __dp_code_block2 \\\n\t_mm_store_si128(&u[t], _mm_sub_epi8(z, vt1));    /* u[r][t..t+15] <- z - v[r-1][t-1..t+14] */ \\\n\t_mm_store_si128(&v[t], _mm_sub_epi8(z, ut));     /* v[r][t..t+15] <- z - u[r-1][t..t+15] */ \\\n\ttmp = _mm_sub_epi8(z, q_); \\\n\ta = _mm_sub_epi8(a, tmp); \\\n\tb = _mm_sub_epi8(b, tmp); \\\n\ta2= _mm_sub_epi8(a2, _mm_sub_epi8(z, q2_));\n\n\tint r, t, qe = q + e, n_col_, *off = 0, *off_end = 0, tlen_, qlen_, last_st, last_en, max_sc, min_sc, long_thres, long_diff;\n\tint with_cigar = !(flag&KSW_EZ_SCORE_ONLY), approx_max = !!(flag&KSW_EZ_APPROX_MAX);\n\tint32_t *H = 0, H0 = 0, last_H0_t = 0;\n\tuint8_t *qr, *sf, *mem, *mem2 = 0;\n\t__m128i q_, q2_, qe_, zero_, sc_mch_, sc_mis_, sc_N_, m1_;\n\t__m128i *u, *v, *x, *y, *x2, *s, *p = 0, *donor, *acceptor;\n\n\tksw_reset_extz(ez);\n\tif (m <= 1 || qlen <= 0 || tlen <= 0 || q2 <= q + e) return;\n\tassert((flag & KSW_EZ_SPLICE_FOR) == 0 || (flag & KSW_EZ_SPLICE_REV) == 0); // can't be both set\n\n\tzero_   = _mm_set1_epi8(0);\n\tq_      = _mm_set1_epi8(q);\n\tq2_     = _mm_set1_epi8(q2);\n\tqe_     = _mm_set1_epi8(q + e);\n\tsc_mch_ = _mm_set1_epi8(mat[0]);\n\tsc_mis_ = _mm_set1_epi8(mat[1]);\n\tsc_N_   = mat[m*m-1] == 0? _mm_set1_epi8(-e) : _mm_set1_epi8(mat[m*m-1]);\n\tm1_     = _mm_set1_epi8(m - 1); // wildcard\n\n\ttlen_ = (tlen + 15) / 16;\n\tn_col_ = ((qlen < tlen? qlen : tlen) + 15) / 16 + 1;\n\tqlen_ = (qlen + 15) / 16;\n\tfor (t = 1, max_sc = mat[0], min_sc = mat[1]; t < m * m; ++t) {\n\t\tmax_sc = max_sc > mat[t]? max_sc : mat[t];\n\t\tmin_sc = min_sc < mat[t]? min_sc : mat[t];\n\t}\n\tif (-min_sc > 2 * (q + e)) return; // otherwise, we won't see any mismatches\n\n\tlong_thres = (q2 - q) / e - 1;\n\tif (q2 > q + e + long_thres * e)\n\t\t++long_thres;\n\tlong_diff = long_thres * e - (q2 - q);\n\n\tmem = (uint8_t*)kcalloc(km, tlen_ * 9 + qlen_ + 1, 16);\n\tu = (__m128i*)(((size_t)mem + 15) >> 4 << 4); // 16-byte aligned\n\tv = u + tlen_, x = v + tlen_, y = x + tlen_, x2 = y + tlen_;\n\tdonor = x2 + tlen_, acceptor = donor + tlen_;\n\ts = acceptor + tlen_, sf = (uint8_t*)(s + tlen_), qr = sf + tlen_ * 16;\n\tmemset(u,  -q - e,  tlen_ * 16 * 4); // this set u, v, x, y (because they are in the same array)\n\tmemset(x2, -q2,     tlen_ * 16);\n\tif (!approx_max) {\n\t\tH = (int32_t*)kmalloc(km, tlen_ * 16 * 4);\n\t\tfor (t = 0; t < tlen_ * 16; ++t) H[t] = KSW_NEG_INF;\n\t}\n\tif (with_cigar) {\n\t\tmem2 = (uint8_t*)kmalloc(km, ((size_t)(qlen + tlen - 1) * n_col_ + 1) * 16);\n\t\tp = (__m128i*)(((size_t)mem2 + 15) >> 4 << 4);\n\t\toff = (int*)kmalloc(km, (qlen + tlen - 1) * sizeof(int) * 2);\n\t\toff_end = off + qlen + tlen - 1;\n\t}\n\n\tfor (t = 0; t < qlen; ++t) qr[t] = query[qlen - 1 - t];\n\tmemcpy(sf, target, tlen);\n\n\t// set the donor and acceptor arrays. TODO: this assumes 0/1/2/3 encoding!\n\tif (flag & (KSW_EZ_SPLICE_FOR|KSW_EZ_SPLICE_REV)) {\n\t\tconst int sp0[4] = { 8, 15, 21, 30 };\n\t\tint sp[4];\n\t\tif (flag & KSW_EZ_SPLICE_CMPLX) {\n\t\t\tfor (t = 0; t < 4; ++t)\n\t\t\t\tsp[t] = (int)((double)sp0[t] / 3. + .499);\n\t\t} else {\n\t\t\tsp[0] = flag&KSW_EZ_SPLICE_FLANK? noncan / 2 : 0;\n\t\t\tsp[1] = sp[2] = sp[3] = noncan;\n\t\t}\n\t\tmemset(donor,    -sp[3], tlen_ * 16);\n\t\tmemset(acceptor, -sp[3], tlen_ * 16);\n\t\tif (!(flag & KSW_EZ_REV_CIGAR)) {\n\t\t\tfor (t = 0; t < tlen - 4; ++t) {\n\t\t\t\tint z = 3;\n\t\t\t\tif (flag & KSW_EZ_SPLICE_FOR) {\n\t\t\t\t\tif (target[t+1] == 2 && target[t+2] == 3)             // |GT.\n\t\t\t\t\t\tz = target[t+3] == 0 || target[t+3] == 2? -1 : 0; // |GTr or not\n\t\t\t\t\telse if (target[t+1] == 2 && target[t+2] == 1) z = 1; // |GC.\n\t\t\t\t\telse if (target[t+1] == 0 && target[t+2] == 3) z = 2; // |AT.\n\t\t\t\t} else if (flag & KSW_EZ_SPLICE_REV) {\n\t\t\t\t\tif (target[t+1] == 1 && target[t+2] == 3)             // |CT. (revcomp of .AG|)\n\t\t\t\t\t\tz = target[t+3] == 0 || target[t+3] == 2? -1 : 0;\n\t\t\t\t\telse if (target[t+1] == 2 && target[t+2] == 3) z = 2; // |GT. (revcomp of .AC|)\n\t\t\t\t}\n\t\t\t\t((int8_t*)donor)[t] = z < 0? 0 : -sp[z];\n\t\t\t}\n\t\t\tfor (t = 2; t < tlen; ++t) {\n\t\t\t\tint z = 3;\n\t\t\t\tif (flag & KSW_EZ_SPLICE_FOR) {\n\t\t\t\t\tif (target[t-1] == 0 && target[t] == 2)               // .AG|\n\t\t\t\t\t\tz = target[t-2] == 1 || target[t-2] == 3? -1 : 0; // yAG| or not\n\t\t\t\t\telse if (target[t-1] == 0 && target[t] == 1) z = 2;   // .AC|\n\t\t\t\t} else if (flag & KSW_EZ_SPLICE_REV) {\n\t\t\t\t\tif (target[t-1] == 0 && target[t] == 1)               // .AC| (revcomp of |GT.)\n\t\t\t\t\t\tz = target[t-2] == 1 || target[t-2] == 3? -1 : 0; // yAC| or not\n\t\t\t\t\telse if (target[t-1] == 2 && target[t] == 1) z = 1;   // .GC| (revcomp of |GC.)\n\t\t\t\t\telse if (target[t-1] == 0 && target[t] == 3) z = 2;   // .AT| (revcomp of |AT.)\n\t\t\t\t}\n\t\t\t\t((int8_t*)acceptor)[t] = z < 0? 0 : -sp[z];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (t = 0; t < tlen - 4; ++t) {\n\t\t\t\tint z = 3;\n\t\t\t\tif (flag & KSW_EZ_SPLICE_FOR) {\n\t\t\t\t\tif (target[t+1] == 2 && target[t+2] == 0)             // |GA. (rev of .AG|)\n\t\t\t\t\t\tz = target[t+3] == 1 || target[t+3] == 3? -1 : 0;\n\t\t\t\t\telse if (target[t+1] == 1 && target[t+2] == 0) z = 2; // |CA. (rev of .AC|)\n\t\t\t\t} else if (flag & KSW_EZ_SPLICE_REV) {\n\t\t\t\t\tif (target[t+1] == 1 && target[t+2] == 0)             // |CA. (comp of |GT.)\n\t\t\t\t\t\tz = target[t+3] == 1 || target[t+3] == 3? -1 : 0;\n\t\t\t\t\telse if (target[t+1] == 1 && target[t+2] == 2) z = 1; // |CG. (comp of |GC.)\n\t\t\t\t\telse if (target[t+1] == 3 && target[t+2] == 0) z = 2; // |TA. (comp of |AT.)\n\t\t\t\t}\n\t\t\t\t((int8_t*)donor)[t] = z < 0? 0 : -sp[z];\n\t\t\t}\n\t\t\tfor (t = 2; t < tlen; ++t) {\n\t\t\t\tint z = 3;\n\t\t\t\tif (flag & KSW_EZ_SPLICE_FOR) {\n\t\t\t\t\tif (target[t-1] == 3 && target[t] == 2)               // .TG| (rev of |GT.)\n\t\t\t\t\t\tz = target[t-2] == 0 || target[t-2] == 2? -1 : 0;\n\t\t\t\t\telse if (target[t-1] == 1 && target[t] == 2) z = 1;   // .CG| (rev of |GC.)\n\t\t\t\t\telse if (target[t-1] == 3 && target[t] == 0) z = 2;   // .TA| (rev of |AT.)\n\t\t\t\t} else if (flag & KSW_EZ_SPLICE_REV) {\n\t\t\t\t\tif (target[t-1] == 3 && target[t] == 1)               // .TC| (comp of .AG|)\n\t\t\t\t\t\tz = target[t-2] == 0 || target[t-2] == 2? -1 : 0;\n\t\t\t\t\telse if (target[t-1] == 3 && target[t] == 2) z = 2;   // .TG| (comp of .AC|)\n\t\t\t\t}\n\t\t\t\t((int8_t*)acceptor)[t] = z < 0? 0 : -sp[z];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (junc && (flag & KSW_EZ_SPLICE_SCORE)) { // junc[] keeps the donor score\n\t\tuint8_t donor_val = !!(flag & KSW_EZ_SPLICE_FOR) == !(flag & KSW_EZ_REV_CIGAR)? 0 : 1;\n\t\tfor (t = 0; t < tlen - 1; ++t)\n\t\t\t((int8_t*)donor)[t]    += junc[t+1] == 0xff || (junc[t+1]&1) !=  donor_val? -junc_pen : (int8_t)(junc[t+1]>>1) - (int8_t)KSW_SPSC_OFFSET;\n\t\tfor (t = 0; t < tlen - 1; ++t)\n\t\t\t((int8_t*)acceptor)[t] += junc[t+1] == 0xff || (junc[t+1]&1) != !donor_val? -junc_pen : (int8_t)(junc[t+1]>>1) - (int8_t)KSW_SPSC_OFFSET;\n\t\t//for (t = 0; t < tlen - 1; ++t) if (junc[t+1] != 0xff) fprintf(stderr, \"Y2\\t%d\\t%d\\t%c\\t%d\\n\", ((int8_t*)donor)[t], ((int8_t*)acceptor)[t], \"DA\"[junc[t+1]&1], (int8_t)(junc[t+1]>>1) - (int8_t)KSW_SPSC_OFFSET);\n\t} else if (junc) { // junc[] keeps the splice sites\n\t\tif (!(flag & KSW_EZ_REV_CIGAR)) {\n\t\t\tfor (t = 0; t < tlen - 1; ++t)\n\t\t\t\tif (((flag & KSW_EZ_SPLICE_FOR) && (junc[t+1]&1)) || ((flag & KSW_EZ_SPLICE_REV) && (junc[t+1]&8)))\n\t\t\t\t\t((int8_t*)donor)[t] += junc_bonus;\n\t\t\tfor (t = 0; t < tlen; ++t)\n\t\t\t\tif (((flag & KSW_EZ_SPLICE_FOR) && (junc[t]&2)) || ((flag & KSW_EZ_SPLICE_REV) && (junc[t]&4)))\n\t\t\t\t\t((int8_t*)acceptor)[t] += junc_bonus;\n\t\t} else {\n\t\t\tfor (t = 0; t < tlen - 1; ++t)\n\t\t\t\tif (((flag & KSW_EZ_SPLICE_FOR) && (junc[t+1]&2)) || ((flag & KSW_EZ_SPLICE_REV) && (junc[t+1]&4)))\n\t\t\t\t\t((int8_t*)donor)[t] += junc_bonus;\n\t\t\tfor (t = 0; t < tlen; ++t)\n\t\t\t\tif (((flag & KSW_EZ_SPLICE_FOR) && (junc[t]&1)) || ((flag & KSW_EZ_SPLICE_REV) && (junc[t]&8)))\n\t\t\t\t\t((int8_t*)acceptor)[t] += junc_bonus;\n\t\t}\n\t}\n\n\tfor (r = 0, last_st = last_en = -1; r < qlen + tlen - 1; ++r) {\n\t\tint st = 0, en = tlen - 1, st0, en0, st_, en_;\n\t\tint8_t x1, x21, v1, *u8 = (int8_t*)u, *v8 = (int8_t*)v;\n\t\tuint8_t *qrr = qr + (qlen - 1 - r);\n\t\t__m128i x1_, x21_, v1_;\n\t\t// find the boundaries\n\t\tif (st < r - qlen + 1) st = r - qlen + 1;\n\t\tif (en > r) en = r;\n\t\tst0 = st, en0 = en;\n\t\tst = st / 16 * 16, en = (en + 16) / 16 * 16 - 1;\n\t\t// set boundary conditions\n\t\tif (st > 0) {\n\t\t\tif (st - 1 >= last_st && st - 1 <= last_en)\n\t\t\t\tx1 = ((int8_t*)x)[st - 1], x21 = ((int8_t*)x2)[st - 1], v1 = v8[st - 1]; // (r-1,s-1) calculated in the last round\n\t\t\telse x1 = -q - e, x21 = -q2, v1 = -q - e;\n\t\t} else {\n\t\t\tx1 = -q - e, x21 = -q2;\n\t\t\tv1 = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : 0;\n\t\t}\n\t\tif (en >= r) {\n\t\t\t((int8_t*)y)[r] = -q - e;\n\t\t\tu8[r] = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : 0;\n\t\t}\n\t\t// loop fission: set scores first\n\t\tif (!(flag & KSW_EZ_GENERIC_SC)) {\n\t\t\tfor (t = st0; t <= en0; t += 16) {\n\t\t\t\t__m128i sq, st, tmp, mask;\n\t\t\t\tsq = _mm_loadu_si128((__m128i*)&sf[t]);\n\t\t\t\tst = _mm_loadu_si128((__m128i*)&qrr[t]);\n\t\t\t\tmask = _mm_or_si128(_mm_cmpeq_epi8(sq, m1_), _mm_cmpeq_epi8(st, m1_));\n\t\t\t\ttmp = _mm_cmpeq_epi8(sq, st);\n#ifdef __SSE4_1__\n\t\t\t\ttmp = _mm_blendv_epi8(sc_mis_, sc_mch_, tmp);\n\t\t\t\ttmp = _mm_blendv_epi8(tmp,     sc_N_,   mask);\n#else\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(tmp,  sc_mis_), _mm_and_si128(tmp,  sc_mch_));\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(mask, tmp),     _mm_and_si128(mask, sc_N_));\n#endif\n\t\t\t\t_mm_storeu_si128((__m128i*)((int8_t*)s + t), tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (t = st0; t <= en0; ++t)\n\t\t\t\t((uint8_t*)s)[t] = mat[sf[t] * m + qrr[t]];\n\t\t}\n\t\t// core loop\n\t\tx1_  = _mm_cvtsi32_si128((uint8_t)x1);\n\t\tx21_ = _mm_cvtsi32_si128((uint8_t)x21);\n\t\tv1_  = _mm_cvtsi32_si128((uint8_t)v1);\n\t\tst_ = st / 16, en_ = en / 16;\n\t\tassert(en_ - st_ + 1 <= n_col_);\n\t\tif (!with_cigar) { // score only\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i z, a, b, a2, a2a, xt1, x2t1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\tz = _mm_max_epi8(z, a2a);\n\t\t\t\t__dp_code_block2; // save u[] and v[]; update a, b and a2\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_max_epi8(a,  zero_), qe_));\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_max_epi8(b,  zero_), qe_));\n\t\t\t\ttmp = _mm_load_si128(&donor[t]);\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_max_epi8(a2, tmp), q2_));\n#else\n\t\t\t\ttmp = _mm_cmpgt_epi8(a,  z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b,  z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2a, z);\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a2a));\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_and_si128(tmp, a),  qe_));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_and_si128(tmp, b),  qe_));\n\t\t\t\ttmp = _mm_load_si128(&donor[t]); // TODO: check if this is correct\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, tmp);\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(tmp, tmp), _mm_and_si128(tmp, a2));\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(tmp, q2_));\n#endif\n\t\t\t}\n\t\t} else if (!(flag&KSW_EZ_RIGHT)) { // gap left-alignment\n\t\t\t__m128i *pr = p + r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, a2, a2a, xt1, x2t1, vt1, ut, tmp, tmp2;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\td = _mm_and_si128(_mm_cmpgt_epi8(a, z), _mm_set1_epi8(1));       // d = a  > z? 1 : 0\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\td = _mm_blendv_epi8(d, _mm_set1_epi8(2), _mm_cmpgt_epi8(b,  z)); // d = b  > z? 2 : d\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\td = _mm_blendv_epi8(d, _mm_set1_epi8(3), _mm_cmpgt_epi8(a2a, z)); // d = a2 > z? 3 : d\n\t\t\t\tz = _mm_max_epi8(z, a2a);\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\ttmp = _mm_cmpgt_epi8(a,  z);\n\t\t\t\td = _mm_and_si128(tmp, _mm_set1_epi8(1));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b,  z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, _mm_set1_epi8(2)));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2a, z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, _mm_set1_epi8(3)));\n\t\t\t\tz = _mm_or_si128(_mm_andnot_si128(tmp, z), _mm_and_si128(tmp, a2a));\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_and_si128(tmp, a),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x08))); // d = a > 0? 1<<3 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_and_si128(tmp, b),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x10))); // d = b > 0? 1<<4 : 0\n\n\t\t\t\ttmp2 = _mm_load_si128(&donor[t]);\n\t\t\t\ttmp = _mm_cmpgt_epi8(a2, tmp2);\n#ifdef __SSE4_1__\n\t\t\t\ttmp2 = _mm_max_epi8(a2, tmp2);\n#else\n\t\t\t\ttmp2 = _mm_or_si128(_mm_andnot_si128(tmp, tmp2), _mm_and_si128(tmp, a2));\n#endif\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(tmp2, q2_));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x20)));\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t} else { // gap right-alignment\n\t\t\t__m128i *pr = p + r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, a2, a2a, xt1, x2t1, vt1, ut, tmp, tmp2;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\td = _mm_andnot_si128(_mm_cmpgt_epi8(z, a), _mm_set1_epi8(1));    // d = z > a?  0 : 1\n\t\t\t\tz = _mm_max_epi8(z, a);\n\t\t\t\td = _mm_blendv_epi8(_mm_set1_epi8(2), d, _mm_cmpgt_epi8(z, b));  // d = z > b?  d : 2\n\t\t\t\tz = _mm_max_epi8(z, b);\n\t\t\t\td = _mm_blendv_epi8(_mm_set1_epi8(3), d, _mm_cmpgt_epi8(z, a2a)); // d = z > a2? d : 3\n\t\t\t\tz = _mm_max_epi8(z, a2a);\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, a);\n\t\t\t\td = _mm_andnot_si128(tmp, _mm_set1_epi8(1));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, a));\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, b);\n\t\t\t\td = _mm_or_si128(_mm_and_si128(tmp, d), _mm_andnot_si128(tmp, _mm_set1_epi8(2)));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, b));\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, a2a);\n\t\t\t\td = _mm_or_si128(_mm_and_si128(tmp, d), _mm_andnot_si128(tmp, _mm_set1_epi8(3)));\n\t\t\t\tz = _mm_or_si128(_mm_and_si128(tmp, z), _mm_andnot_si128(tmp, a2a));\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, a);\n\t\t\t\t_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_andnot_si128(tmp, a),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x08))); // d = a > 0? 1<<3 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, b);\n\t\t\t\t_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_andnot_si128(tmp, b),  qe_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x10))); // d = b > 0? 1<<4 : 0\n\n\t\t\t\ttmp2 = _mm_load_si128(&donor[t]);\n\t\t\t\ttmp = _mm_cmpgt_epi8(tmp2, a2);\n#ifdef __SSE4_1__\n\t\t\t\ttmp2 = _mm_max_epi8(tmp2, a2);\n#else\n\t\t\t\ttmp2 = _mm_or_si128(_mm_andnot_si128(tmp, a2), _mm_and_si128(tmp, tmp2));\n#endif\n\t\t\t\t_mm_store_si128(&x2[t], _mm_sub_epi8(tmp2, q2_));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x20))); // d = a > 0? 1<<5 : 0\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t}\n\t\tif (!approx_max) { // find the exact max with a 32-bit score array\n\t\t\tint32_t max_H, max_t;\n\t\t\t// compute H[], max_H and max_t\n\t\t\tif (r > 0) {\n\t\t\t\tint32_t HH[4], tt[4], en1 = st0 + (en0 - st0) / 4 * 4, i;\n\t\t\t\t__m128i max_H_, max_t_;\n\t\t\t\tmax_H = H[en0] = en0 > 0? H[en0-1] + u8[en0] : H[en0] + v8[en0]; // special casing the last element\n\t\t\t\tmax_t = en0;\n\t\t\t\tmax_H_ = _mm_set1_epi32(max_H);\n\t\t\t\tmax_t_ = _mm_set1_epi32(max_t);\n\t\t\t\tfor (t = st0; t < en1; t += 4) { // this implements: H[t]+=v8[t]-qe; if(H[t]>max_H) max_H=H[t],max_t=t;\n\t\t\t\t\t__m128i H1, tmp, t_;\n\t\t\t\t\tH1 = _mm_loadu_si128((__m128i*)&H[t]);\n\t\t\t\t\tt_ = _mm_setr_epi32(v8[t], v8[t+1], v8[t+2], v8[t+3]);\n\t\t\t\t\tH1 = _mm_add_epi32(H1, t_);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)&H[t], H1);\n\t\t\t\t\tt_ = _mm_set1_epi32(t);\n\t\t\t\t\ttmp = _mm_cmpgt_epi32(H1, max_H_);\n#ifdef __SSE4_1__\n\t\t\t\t\tmax_H_ = _mm_blendv_epi8(max_H_, H1, tmp);\n\t\t\t\t\tmax_t_ = _mm_blendv_epi8(max_t_, t_, tmp);\n#else\n\t\t\t\t\tmax_H_ = _mm_or_si128(_mm_and_si128(tmp, H1), _mm_andnot_si128(tmp, max_H_));\n\t\t\t\t\tmax_t_ = _mm_or_si128(_mm_and_si128(tmp, t_), _mm_andnot_si128(tmp, max_t_));\n#endif\n\t\t\t\t}\n\t\t\t\t_mm_storeu_si128((__m128i*)HH, max_H_);\n\t\t\t\t_mm_storeu_si128((__m128i*)tt, max_t_);\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\tif (max_H < HH[i]) max_H = HH[i], max_t = tt[i] + i;\n\t\t\t\tfor (; t < en0; ++t) { // for the rest of values that haven't been computed with SSE\n\t\t\t\t\tH[t] += (int32_t)v8[t];\n\t\t\t\t\tif (H[t] > max_H)\n\t\t\t\t\t\tmax_H = H[t], max_t = t;\n\t\t\t\t}\n\t\t\t} else H[0] = v8[0] - qe, max_H = H[0], max_t = 0; // special casing r==0\n\t\t\t// update ez\n\t\t\tif (en0 == tlen - 1 && H[en0] > ez->mte)\n\t\t\t\tez->mte = H[en0], ez->mte_q = r - en0;\n\t\t\tif (r - st0 == qlen - 1 && H[st0] > ez->mqe)\n\t\t\t\tez->mqe = H[st0], ez->mqe_t = st0;\n\t\t\tif (ksw_apply_zdrop(ez, 1, max_H, r, max_t, zdrop, 0)) break;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H[tlen - 1];\n\t\t} else { // find approximate max; Z-drop might be inaccurate, too.\n\t\t\tif (r > 0) {\n\t\t\t\tif (last_H0_t >= st0 && last_H0_t <= en0 && last_H0_t + 1 >= st0 && last_H0_t + 1 <= en0) {\n\t\t\t\t\tint32_t d0 = v8[last_H0_t];\n\t\t\t\t\tint32_t d1 = u8[last_H0_t + 1];\n\t\t\t\t\tif (d0 > d1) H0 += d0;\n\t\t\t\t\telse H0 += d1, ++last_H0_t;\n\t\t\t\t} else if (last_H0_t >= st0 && last_H0_t <= en0) {\n\t\t\t\t\tH0 += v8[last_H0_t];\n\t\t\t\t} else {\n\t\t\t\t\t++last_H0_t, H0 += u8[last_H0_t];\n\t\t\t\t}\n\t\t\t} else H0 = v8[0] - qe, last_H0_t = 0;\n\t\t\tif ((flag & KSW_EZ_APPROX_DROP) && ksw_apply_zdrop(ez, 1, H0, r, last_H0_t, zdrop, 0)) break;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H0;\n\t\t}\n\t\tlast_st = st, last_en = en;\n\t\t//for (t = st0; t <= en0; ++t) printf(\"(%d,%d)\\t(%d,%d,%d,%d)\\t%d\\n\", r, t, ((int8_t*)u)[t], ((int8_t*)v)[t], ((int8_t*)x)[t], ((int8_t*)y)[t], H[t]); // for debugging\n\t}\n\tkfree(km, mem);\n\tif (!approx_max) kfree(km, H);\n\tif (with_cigar) { // backtrack\n\t\tint rev_cigar = !!(flag & KSW_EZ_REV_CIGAR);\n\t\tif (!ez->zdropped && !(flag&KSW_EZ_EXTZ_ONLY))\n\t\t\tksw_backtrack(km, 1, rev_cigar, long_thres, (uint8_t*)p, off, off_end, n_col_*16, tlen-1, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\telse if (ez->max_t >= 0 && ez->max_q >= 0)\n\t\t\tksw_backtrack(km, 1, rev_cigar, long_thres, (uint8_t*)p, off, off_end, n_col_*16, ez->max_t, ez->max_q, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\tkfree(km, mem2); kfree(km, off);\n\t}\n}\n#endif // __SSE2__\n"
        },
        {
          "name": "ksw2_extz2_sse.c",
          "type": "blob",
          "size": 13.041015625,
          "content": "#include <string.h>\n#include <assert.h>\n#include \"ksw2.h\"\n\n#ifdef __SSE2__\n#ifdef USE_SIMDE\n#include <simde/x86/sse2.h>\n#else\n#include <emmintrin.h>\n#endif\n\n#ifdef KSW_SSE2_ONLY\n#undef __SSE4_1__\n#endif\n\n#ifdef __SSE4_1__\n#ifdef USE_SIMDE\n#include <simde/x86/sse4.1.h>\n#else\n#include <smmintrin.h>\n#endif\n#endif\n\n#ifdef KSW_CPU_DISPATCH\n#ifdef __SSE4_1__\nvoid ksw_extz2_sse41(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#else\nvoid ksw_extz2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#endif\n#else\nvoid ksw_extz2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat, int8_t q, int8_t e, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)\n#endif // ~KSW_CPU_DISPATCH\n{\n#define __dp_code_block1 \\\n\tz = _mm_add_epi8(_mm_load_si128(&s[t]), qe2_); \\\n\txt1 = _mm_load_si128(&x[t]);                     /* xt1 <- x[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(xt1, 15);                   /* tmp <- x[r-1][t+15] */ \\\n\txt1 = _mm_or_si128(_mm_slli_si128(xt1, 1), x1_); /* xt1 <- x[r-1][t-1..t+14] */ \\\n\tx1_ = tmp; \\\n\tvt1 = _mm_load_si128(&v[t]);                     /* vt1 <- v[r-1][t..t+15] */ \\\n\ttmp = _mm_srli_si128(vt1, 15);                   /* tmp <- v[r-1][t+15] */ \\\n\tvt1 = _mm_or_si128(_mm_slli_si128(vt1, 1), v1_); /* vt1 <- v[r-1][t-1..t+14] */ \\\n\tv1_ = tmp; \\\n\ta = _mm_add_epi8(xt1, vt1);                      /* a <- x[r-1][t-1..t+14] + v[r-1][t-1..t+14] */ \\\n\tut = _mm_load_si128(&u[t]);                      /* ut <- u[t..t+15] */ \\\n\tb = _mm_add_epi8(_mm_load_si128(&y[t]), ut);     /* b <- y[r-1][t..t+15] + u[r-1][t..t+15] */\n\n#define __dp_code_block2 \\\n\tz = _mm_max_epu8(z, b);                          /* z = max(z, b); this works because both are non-negative */ \\\n\tz = _mm_min_epu8(z, max_sc_); \\\n\t_mm_store_si128(&u[t], _mm_sub_epi8(z, vt1));    /* u[r][t..t+15] <- z - v[r-1][t-1..t+14] */ \\\n\t_mm_store_si128(&v[t], _mm_sub_epi8(z, ut));     /* v[r][t..t+15] <- z - u[r-1][t..t+15] */ \\\n\tz = _mm_sub_epi8(z, q_); \\\n\ta = _mm_sub_epi8(a, z); \\\n\tb = _mm_sub_epi8(b, z);\n\n\tint r, t, qe = q + e, n_col_, *off = 0, *off_end = 0, tlen_, qlen_, last_st, last_en, wl, wr, max_sc, min_sc;\n\tint with_cigar = !(flag&KSW_EZ_SCORE_ONLY), approx_max = !!(flag&KSW_EZ_APPROX_MAX);\n\tint32_t *H = 0, H0 = 0, last_H0_t = 0;\n\tuint8_t *qr, *sf, *mem, *mem2 = 0;\n\t__m128i q_, qe2_, zero_, flag1_, flag2_, flag8_, flag16_, sc_mch_, sc_mis_, sc_N_, m1_, max_sc_;\n\t__m128i *u, *v, *x, *y, *s, *p = 0;\n\n\tksw_reset_extz(ez);\n\tif (m <= 0 || qlen <= 0 || tlen <= 0) return;\n\n\tzero_   = _mm_set1_epi8(0);\n\tq_      = _mm_set1_epi8(q);\n\tqe2_    = _mm_set1_epi8((q + e) * 2);\n\tflag1_  = _mm_set1_epi8(1);\n\tflag2_  = _mm_set1_epi8(2);\n\tflag8_  = _mm_set1_epi8(0x08);\n\tflag16_ = _mm_set1_epi8(0x10);\n\tsc_mch_ = _mm_set1_epi8(mat[0]);\n\tsc_mis_ = _mm_set1_epi8(mat[1]);\n\tsc_N_   = mat[m*m-1] == 0? _mm_set1_epi8(-e) : _mm_set1_epi8(mat[m*m-1]);\n\tm1_     = _mm_set1_epi8(m - 1); // wildcard\n\tmax_sc_ = _mm_set1_epi8(mat[0] + (q + e) * 2);\n\n\tif (w < 0) w = tlen > qlen? tlen : qlen;\n\twl = wr = w;\n\ttlen_ = (tlen + 15) / 16;\n\tn_col_ = qlen < tlen? qlen : tlen;\n\tn_col_ = ((n_col_ < w + 1? n_col_ : w + 1) + 15) / 16 + 1;\n\tqlen_ = (qlen + 15) / 16;\n\tfor (t = 1, max_sc = mat[0], min_sc = mat[1]; t < m * m; ++t) {\n\t\tmax_sc = max_sc > mat[t]? max_sc : mat[t];\n\t\tmin_sc = min_sc < mat[t]? min_sc : mat[t];\n\t}\n\tif (-min_sc > 2 * (q + e)) return; // otherwise, we won't see any mismatches\n\n\tmem = (uint8_t*)kcalloc(km, tlen_ * 6 + qlen_ + 1, 16);\n\tu = (__m128i*)(((size_t)mem + 15) >> 4 << 4); // 16-byte aligned\n\tv = u + tlen_, x = v + tlen_, y = x + tlen_, s = y + tlen_, sf = (uint8_t*)(s + tlen_), qr = sf + tlen_ * 16;\n\tif (!approx_max) {\n\t\tH = (int32_t*)kmalloc(km, tlen_ * 16 * 4);\n\t\tfor (t = 0; t < tlen_ * 16; ++t) H[t] = KSW_NEG_INF;\n\t}\n\tif (with_cigar) {\n\t\tmem2 = (uint8_t*)kmalloc(km, ((size_t)(qlen + tlen - 1) * n_col_ + 1) * 16);\n\t\tp = (__m128i*)(((size_t)mem2 + 15) >> 4 << 4);\n\t\toff = (int*)kmalloc(km, (qlen + tlen - 1) * sizeof(int) * 2);\n\t\toff_end = off + qlen + tlen - 1;\n\t}\n\n\tfor (t = 0; t < qlen; ++t) qr[t] = query[qlen - 1 - t];\n\tmemcpy(sf, target, tlen);\n\n\tfor (r = 0, last_st = last_en = -1; r < qlen + tlen - 1; ++r) {\n\t\tint st = 0, en = tlen - 1, st0, en0, st_, en_;\n\t\tint8_t x1, v1;\n\t\tuint8_t *qrr = qr + (qlen - 1 - r), *u8 = (uint8_t*)u, *v8 = (uint8_t*)v;\n\t\t__m128i x1_, v1_;\n\t\t// find the boundaries\n\t\tif (st < r - qlen + 1) st = r - qlen + 1;\n\t\tif (en > r) en = r;\n\t\tif (st < (r-wr+1)>>1) st = (r-wr+1)>>1; // take the ceil\n\t\tif (en > (r+wl)>>1) en = (r+wl)>>1; // take the floor\n\t\tif (st > en) {\n\t\t\tez->zdropped = 1;\n\t\t\tbreak;\n\t\t}\n\t\tst0 = st, en0 = en;\n\t\tst = st / 16 * 16, en = (en + 16) / 16 * 16 - 1;\n\t\t// set boundary conditions\n\t\tif (st > 0) {\n\t\t\tif (st - 1 >= last_st && st - 1 <= last_en)\n\t\t\t\tx1 = ((uint8_t*)x)[st - 1], v1 = v8[st - 1]; // (r-1,s-1) calculated in the last round\n\t\t\telse x1 = v1 = 0; // not calculated; set to zeros\n\t\t} else x1 = 0, v1 = r? q : 0;\n\t\tif (en >= r) ((uint8_t*)y)[r] = 0, u8[r] = r? q : 0;\n\t\t// loop fission: set scores first\n\t\tif (!(flag & KSW_EZ_GENERIC_SC)) {\n\t\t\tfor (t = st0; t <= en0; t += 16) {\n\t\t\t\t__m128i sq, st, tmp, mask;\n\t\t\t\tsq = _mm_loadu_si128((__m128i*)&sf[t]);\n\t\t\t\tst = _mm_loadu_si128((__m128i*)&qrr[t]);\n\t\t\t\tmask = _mm_or_si128(_mm_cmpeq_epi8(sq, m1_), _mm_cmpeq_epi8(st, m1_));\n\t\t\t\ttmp = _mm_cmpeq_epi8(sq, st);\n#ifdef __SSE4_1__\n\t\t\t\ttmp = _mm_blendv_epi8(sc_mis_, sc_mch_, tmp);\n\t\t\t\ttmp = _mm_blendv_epi8(tmp,     sc_N_,   mask);\n#else\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(tmp,  sc_mis_), _mm_and_si128(tmp,  sc_mch_));\n\t\t\t\ttmp = _mm_or_si128(_mm_andnot_si128(mask, tmp),     _mm_and_si128(mask, sc_N_));\n#endif\n\t\t\t\t_mm_storeu_si128((__m128i*)((uint8_t*)s + t), tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (t = st0; t <= en0; ++t)\n\t\t\t\t((uint8_t*)s)[t] = mat[sf[t] * m + qrr[t]];\n\t\t}\n\t\t// core loop\n\t\tx1_ = _mm_cvtsi32_si128(x1);\n\t\tv1_ = _mm_cvtsi32_si128(v1);\n\t\tst_ = st / 16, en_ = en / 16;\n\t\tassert(en_ - st_ + 1 <= n_col_);\n\t\tif (!with_cigar) { // score only\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i z, a, b, xt1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n#ifdef __SSE4_1__\n\t\t\t\tz = _mm_max_epi8(z, a);                          // z = z > a? z : a (signed)\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8()\n\t\t\t\tz = _mm_and_si128(z, _mm_cmpgt_epi8(z, zero_));  // z = z > 0? z : 0;\n\t\t\t\tz = _mm_max_epu8(z, a);                          // z = max(z, a); this works because both are non-negative\n#endif\n\t\t\t\t__dp_code_block2;\n#ifdef __SSE4_1__\n\t\t\t\t_mm_store_si128(&x[t], _mm_max_epi8(a, zero_));\n\t\t\t\t_mm_store_si128(&y[t], _mm_max_epi8(b, zero_));\n#else\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t], _mm_and_si128(a, tmp));\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t], _mm_and_si128(b, tmp));\n#endif\n\t\t\t}\n\t\t} else if (!(flag&KSW_EZ_RIGHT)) { // gap left-alignment\n\t\t\t__m128i *pr = p + (size_t)r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, xt1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n\t\t\t\td = _mm_and_si128(_mm_cmpgt_epi8(a, z), flag1_); // d = a > z? 1 : 0\n#ifdef __SSE4_1__\n\t\t\t\tz = _mm_max_epi8(z, a);                          // z = z > a? z : a (signed)\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, z);\n\t\t\t\td = _mm_blendv_epi8(d, flag2_, tmp);             // d = b > z? 2 : d\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\tz = _mm_and_si128(z, _mm_cmpgt_epi8(z, zero_));  // z = z > 0? z : 0;\n\t\t\t\tz = _mm_max_epu8(z, a);                          // z = max(z, a); this works because both are non-negative\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, z);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, d), _mm_and_si128(tmp, flag2_)); // d = b > z? 2 : d; emulating blendv\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(a, zero_);\n\t\t\t\t_mm_store_si128(&x[t], _mm_and_si128(tmp, a));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, flag8_));  // d = a > 0? 0x08 : 0\n\t\t\t\ttmp = _mm_cmpgt_epi8(b, zero_);\n\t\t\t\t_mm_store_si128(&y[t], _mm_and_si128(tmp, b));\n\t\t\t\td = _mm_or_si128(d, _mm_and_si128(tmp, flag16_)); // d = b > 0? 0x10 : 0\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t} else { // gap right-alignment\n\t\t\t__m128i *pr = p + (size_t)r * n_col_ - st_;\n\t\t\toff[r] = st, off_end[r] = en;\n\t\t\tfor (t = st_; t <= en_; ++t) {\n\t\t\t\t__m128i d, z, a, b, xt1, vt1, ut, tmp;\n\t\t\t\t__dp_code_block1;\n\t\t\t\td = _mm_andnot_si128(_mm_cmpgt_epi8(z, a), flag1_); // d = z > a? 0 : 1\n#ifdef __SSE4_1__\n\t\t\t\tz = _mm_max_epi8(z, a);                          // z = z > a? z : a (signed)\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, b);\n\t\t\t\td = _mm_blendv_epi8(flag2_, d, tmp);             // d = z > b? d : 2\n#else // we need to emulate SSE4.1 intrinsics _mm_max_epi8() and _mm_blendv_epi8()\n\t\t\t\tz = _mm_and_si128(z, _mm_cmpgt_epi8(z, zero_));  // z = z > 0? z : 0;\n\t\t\t\tz = _mm_max_epu8(z, a);                          // z = max(z, a); this works because both are non-negative\n\t\t\t\ttmp = _mm_cmpgt_epi8(z, b);\n\t\t\t\td = _mm_or_si128(_mm_andnot_si128(tmp, flag2_), _mm_and_si128(tmp, d)); // d = z > b? d : 2; emulating blendv\n#endif\n\t\t\t\t__dp_code_block2;\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, a);\n\t\t\t\t_mm_store_si128(&x[t], _mm_andnot_si128(tmp, a));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, flag8_));  // d = 0 > a? 0 : 0x08\n\t\t\t\ttmp = _mm_cmpgt_epi8(zero_, b);\n\t\t\t\t_mm_store_si128(&y[t], _mm_andnot_si128(tmp, b));\n\t\t\t\td = _mm_or_si128(d, _mm_andnot_si128(tmp, flag16_)); // d = 0 > b? 0 : 0x10\n\t\t\t\t_mm_store_si128(&pr[t], d);\n\t\t\t}\n\t\t}\n\t\tif (!approx_max) { // find the exact max with a 32-bit score array\n\t\t\tint32_t max_H, max_t;\n\t\t\t// compute H[], max_H and max_t\n\t\t\tif (r > 0) {\n\t\t\t\tint32_t HH[4], tt[4], en1 = st0 + (en0 - st0) / 4 * 4, i;\n\t\t\t\t__m128i max_H_, max_t_, qe_;\n\t\t\t\tmax_H = H[en0] = en0 > 0? H[en0-1] + u8[en0] - qe : H[en0] + v8[en0] - qe; // special casing the last element\n\t\t\t\tmax_t = en0;\n\t\t\t\tmax_H_ = _mm_set1_epi32(max_H);\n\t\t\t\tmax_t_ = _mm_set1_epi32(max_t);\n\t\t\t\tqe_    = _mm_set1_epi32(q + e);\n\t\t\t\tfor (t = st0; t < en1; t += 4) { // this implements: H[t]+=v8[t]-qe; if(H[t]>max_H) max_H=H[t],max_t=t;\n\t\t\t\t\t__m128i H1, tmp, t_;\n\t\t\t\t\tH1 = _mm_loadu_si128((__m128i*)&H[t]);\n\t\t\t\t\tt_ = _mm_setr_epi32(v8[t], v8[t+1], v8[t+2], v8[t+3]);\n\t\t\t\t\tH1 = _mm_add_epi32(H1, t_);\n\t\t\t\t\tH1 = _mm_sub_epi32(H1, qe_);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)&H[t], H1);\n\t\t\t\t\tt_ = _mm_set1_epi32(t);\n\t\t\t\t\ttmp = _mm_cmpgt_epi32(H1, max_H_);\n#ifdef __SSE4_1__\n\t\t\t\t\tmax_H_ = _mm_blendv_epi8(max_H_, H1, tmp);\n\t\t\t\t\tmax_t_ = _mm_blendv_epi8(max_t_, t_, tmp);\n#else\n\t\t\t\t\tmax_H_ = _mm_or_si128(_mm_and_si128(tmp, H1), _mm_andnot_si128(tmp, max_H_));\n\t\t\t\t\tmax_t_ = _mm_or_si128(_mm_and_si128(tmp, t_), _mm_andnot_si128(tmp, max_t_));\n#endif\n\t\t\t\t}\n\t\t\t\t_mm_storeu_si128((__m128i*)HH, max_H_);\n\t\t\t\t_mm_storeu_si128((__m128i*)tt, max_t_);\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\tif (max_H < HH[i]) max_H = HH[i], max_t = tt[i] + i;\n\t\t\t\tfor (; t < en0; ++t) { // for the rest of values that haven't been computed with SSE\n\t\t\t\t\tH[t] += (int32_t)v8[t] - qe;\n\t\t\t\t\tif (H[t] > max_H)\n\t\t\t\t\t\tmax_H = H[t], max_t = t;\n\t\t\t\t}\n\t\t\t} else H[0] = v8[0] - qe - qe, max_H = H[0], max_t = 0; // special casing r==0\n\t\t\t// update ez\n\t\t\tif (en0 == tlen - 1 && H[en0] > ez->mte)\n\t\t\t\tez->mte = H[en0], ez->mte_q = r - en0;\n\t\t\tif (r - st0 == qlen - 1 && H[st0] > ez->mqe)\n\t\t\t\tez->mqe = H[st0], ez->mqe_t = st0;\n\t\t\tif (ksw_apply_zdrop(ez, 1, max_H, r, max_t, zdrop, e)) break;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H[tlen - 1];\n\t\t} else { // find approximate max; Z-drop might be inaccurate, too.\n\t\t\tif (r > 0) {\n\t\t\t\tif (last_H0_t >= st0 && last_H0_t <= en0 && last_H0_t + 1 >= st0 && last_H0_t + 1 <= en0) {\n\t\t\t\t\tint32_t d0 = v8[last_H0_t] - qe;\n\t\t\t\t\tint32_t d1 = u8[last_H0_t + 1] - qe;\n\t\t\t\t\tif (d0 > d1) H0 += d0;\n\t\t\t\t\telse H0 += d1, ++last_H0_t;\n\t\t\t\t} else if (last_H0_t >= st0 && last_H0_t <= en0) {\n\t\t\t\t\tH0 += v8[last_H0_t] - qe;\n\t\t\t\t} else {\n\t\t\t\t\t++last_H0_t, H0 += u8[last_H0_t] - qe;\n\t\t\t\t}\n\t\t\t\tif ((flag & KSW_EZ_APPROX_DROP) && ksw_apply_zdrop(ez, 1, H0, r, last_H0_t, zdrop, e)) break;\n\t\t\t} else H0 = v8[0] - qe - qe, last_H0_t = 0;\n\t\t\tif (r == qlen + tlen - 2 && en0 == tlen - 1)\n\t\t\t\tez->score = H0;\n\t\t}\n\t\tlast_st = st, last_en = en;\n\t\t//for (t = st0; t <= en0; ++t) printf(\"(%d,%d)\\t(%d,%d,%d,%d)\\t%d\\n\", r, t, ((int8_t*)u)[t], ((int8_t*)v)[t], ((int8_t*)x)[t], ((int8_t*)y)[t], H[t]); // for debugging\n\t}\n\tkfree(km, mem);\n\tif (!approx_max) kfree(km, H);\n\tif (with_cigar) { // backtrack\n\t\tint rev_cigar = !!(flag & KSW_EZ_REV_CIGAR);\n\t\tif (!ez->zdropped && !(flag&KSW_EZ_EXTZ_ONLY)) {\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, tlen-1, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t} else if (!ez->zdropped && (flag&KSW_EZ_EXTZ_ONLY) && ez->mqe + end_bonus > (int)ez->max) {\n\t\t\tez->reach_end = 1;\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->mqe_t, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t} else if (ez->max_t >= 0 && ez->max_q >= 0) {\n\t\t\tksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->max_t, ez->max_q, &ez->m_cigar, &ez->n_cigar, &ez->cigar);\n\t\t}\n\t\tkfree(km, mem2); kfree(km, off);\n\t}\n}\n#endif // __SSE2__\n"
        },
        {
          "name": "ksw2_ll_sse.c",
          "type": "blob",
          "size": 4.5146484375,
          "content": "#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include \"ksw2.h\"\n\n#ifdef USE_SIMDE\n#include <simde/x86/sse2.h>\n#else\n#include <emmintrin.h>\n#endif\n\n#ifdef __GNUC__\n#define LIKELY(x) __builtin_expect((x),1)\n#define UNLIKELY(x) __builtin_expect((x),0)\n#else\n#define LIKELY(x) (x)\n#define UNLIKELY(x) (x)\n#endif\n\ntypedef struct {\n\tint qlen, slen;\n\tuint8_t shift, mdiff, max, size;\n\t__m128i *qp, *H0, *H1, *E, *Hmax;\n} kswq_t;\n\n/**\n * Initialize the query data structure\n *\n * @param size   Number of bytes used to store a score; valid valures are 1 or 2\n * @param qlen   Length of the query sequence\n * @param query  Query sequence\n * @param m      Size of the alphabet\n * @param mat    Scoring matrix in a one-dimension array\n *\n * @return       Query data structure\n */\nvoid *ksw_ll_qinit(void *km, int size, int qlen, const uint8_t *query, int m, const int8_t *mat)\n{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)kmalloc(km, sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}\n\nint ksw_ll_i16(void *q_, int tlen, const uint8_t *target, int _gapo, int _gape, int *qe, int *te)\n{\n\tkswq_t *q = (kswq_t*)q_;\n\tint slen, i, gmax = 0, qlen8;\n\t__m128i zero, gapoe, gape, *H0, *H1, *E, *Hmax;\n\tuint16_t *H8;\n\n#define __max_8(ret, xx) do { \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 2)); \\\n\t\t(ret) = _mm_extract_epi16((xx), 0); \\\n\t} while (0)\n\n\t// initialization\n\t*qe = *te = -1;\n\tzero = _mm_set1_epi32(0);\n\tgapoe = _mm_set1_epi16(_gapo + _gape);\n\tgape = _mm_set1_epi16(_gape);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen, qlen8 = slen * 8;\n\tmemset(E,    0, slen * sizeof(__m128i));\n\tmemset(H0,   0, slen * sizeof(__m128i));\n\tmemset(Hmax, 0, slen * sizeof(__m128i));\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, imax;\n\t\t__m128i e, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 2);\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\th = _mm_adds_epi16(h, *S++);\n\t\t\te = _mm_load_si128(E + j);\n\t\t\th = _mm_max_epi16(h, e);\n\t\t\th = _mm_max_epi16(h, f);\n\t\t\tmax = _mm_max_epi16(max, h);\n\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\th = _mm_subs_epu16(h, gapoe);\n\t\t\te = _mm_subs_epu16(e, gape);\n\t\t\te = _mm_max_epi16(e, h);\n\t\t\t_mm_store_si128(E + j, e);\n\t\t\tf = _mm_subs_epu16(f, gape);\n\t\t\tf = _mm_max_epi16(f, h);\n\t\t\th = _mm_load_si128(H0 + j);\n\t\t}\n\t\tfor (k = 0; LIKELY(k < 8); ++k) {\n\t\t\tf = _mm_slli_si128(f, 2);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epi16(h, f);\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu16(h, gapoe);\n\t\t\t\tf = _mm_subs_epu16(f, gape);\n\t\t\t\tif(UNLIKELY(!_mm_movemask_epi8(_mm_cmpgt_epi16(f, h)))) goto end_loop_i16;\n\t\t\t}\n\t\t}\nend_loop_i16:\n\t\t__max_8(imax, max);\n\t\tif (imax >= gmax) {\n\t\t\tgmax = imax; *te = i;\n\t\t\tmemcpy(Hmax, H1, slen * sizeof(__m128i));\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S;\n\t}\n\tfor (i = 0, H8 = (uint16_t*)Hmax; i < qlen8; ++i)\n\t\tif ((int)H8[i] == gmax) *qe = i / 8 + i % 8 * slen;\n\treturn gmax;\n}\n"
        },
        {
          "name": "kthread.c",
          "type": "blob",
          "size": 3.978515625,
          "content": "#include <pthread.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdint.h>\n#include \"kthread.h\"\n\n#if (defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER)\n#define __sync_fetch_and_add(ptr, addend)     _InterlockedExchangeAdd((void*)ptr, addend)\n#endif\n\n/************\n * kt_for() *\n ************/\n\nstruct kt_for_t;\n\ntypedef struct {\n\tstruct kt_for_t *t;\n\tlong i;\n} ktf_worker_t;\n\ntypedef struct kt_for_t {\n\tint n_threads;\n\tlong n;\n\tktf_worker_t *w;\n\tvoid (*func)(void*,long,int);\n\tvoid *data;\n} kt_for_t;\n\nstatic inline long steal_work(kt_for_t *t)\n{\n\tint i, min_i = -1;\n\tlong k, min = LONG_MAX;\n\tfor (i = 0; i < t->n_threads; ++i)\n\t\tif (min > t->w[i].i) min = t->w[i].i, min_i = i;\n\tk = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);\n\treturn k >= t->n? -1 : k;\n}\n\nstatic void *ktf_worker(void *data)\n{\n\tktf_worker_t *w = (ktf_worker_t*)data;\n\tlong i;\n\tfor (;;) {\n\t\ti = __sync_fetch_and_add(&w->i, w->t->n_threads);\n\t\tif (i >= w->t->n) break;\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\t}\n\twhile ((i = steal_work(w->t)) >= 0)\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\tpthread_exit(0);\n}\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n)\n{\n\tif (n_threads > 1) {\n\t\tint i;\n\t\tkt_for_t t;\n\t\tpthread_t *tid;\n\t\tt.func = func, t.data = data, t.n_threads = n_threads, t.n = n;\n\t\tt.w = (ktf_worker_t*)calloc(n_threads, sizeof(ktf_worker_t));\n\t\ttid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));\n\t\tfor (i = 0; i < n_threads; ++i)\n\t\t\tt.w[i].t = &t, t.w[i].i = i;\n\t\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktf_worker, &t.w[i]);\n\t\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n\t\tfree(tid); free(t.w);\n\t} else {\n\t\tlong j;\n\t\tfor (j = 0; j < n; ++j) func(data, j, 0);\n\t}\n}\n\n/*****************\n * kt_pipeline() *\n *****************/\n\nstruct ktp_t;\n\ntypedef struct {\n\tstruct ktp_t *pl;\n\tint64_t index;\n\tint step;\n\tvoid *data;\n} ktp_worker_t;\n\ntypedef struct ktp_t {\n\tvoid *shared;\n\tvoid *(*func)(void*, int, void*);\n\tint64_t index;\n\tint n_workers, n_steps;\n\tktp_worker_t *workers;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cv;\n} ktp_t;\n\nstatic void *ktp_worker(void *data)\n{\n\tktp_worker_t *w = (ktp_worker_t*)data;\n\tktp_t *p = w->pl;\n\twhile (w->step < p->n_steps) {\n\t\t// test whether we can kick off the job with this worker\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tfor (;;) {\n\t\t\tint i;\n\t\t\t// test whether another worker is doing the same step\n\t\t\tfor (i = 0; i < p->n_workers; ++i) {\n\t\t\t\tif (w == &p->workers[i]) continue; // ignore itself\n\t\t\t\tif (p->workers[i].step <= w->step && p->workers[i].index < w->index)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps\n\t\t\tpthread_cond_wait(&p->cv, &p->mutex);\n\t\t}\n\t\tpthread_mutex_unlock(&p->mutex);\n\n\t\t// working on w->step\n\t\tw->data = p->func(p->shared, w->step, w->step? w->data : 0); // for the first step, input is NULL\n\n\t\t// update step and let other workers know\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tw->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;\n\t\tif (w->step == 0) w->index = p->index++;\n\t\tpthread_cond_broadcast(&p->cv);\n\t\tpthread_mutex_unlock(&p->mutex);\n\t}\n\tpthread_exit(0);\n}\n\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps)\n{\n\tktp_t aux;\n\tpthread_t *tid;\n\tint i;\n\n\tif (n_threads < 1) n_threads = 1;\n\taux.n_workers = n_threads;\n\taux.n_steps = n_steps;\n\taux.func = func;\n\taux.shared = shared_data;\n\taux.index = 0;\n\tpthread_mutex_init(&aux.mutex, 0);\n\tpthread_cond_init(&aux.cv, 0);\n\n\taux.workers = (ktp_worker_t*)calloc(n_threads, sizeof(ktp_worker_t));\n\tfor (i = 0; i < n_threads; ++i) {\n\t\tktp_worker_t *w = &aux.workers[i];\n\t\tw->step = 0; w->pl = &aux; w->data = 0;\n\t\tw->index = aux.index++;\n\t}\n\n\ttid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));\n\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);\n\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n\tfree(tid); free(aux.workers);\n\n\tpthread_mutex_destroy(&aux.mutex);\n\tpthread_cond_destroy(&aux.cv);\n}\n"
        },
        {
          "name": "kthread.h",
          "type": "blob",
          "size": 0.2841796875,
          "content": "#ifndef KTHREAD_H\n#define KTHREAD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n);\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kvec.h",
          "type": "blob",
          "size": 2.9580078125,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"kvec.h\"\nint main() {\n\tkvec_t(int) array;\n\tkv_init(array);\n\tkv_push(int, array, 10); // append\n\tkv_a(int, array, 20) = 5; // dynamic\n\tkv_A(array, 20) = 4; // static\n\tkv_destroy(array);\n\treturn 0;\n}\n*/\n\n/*\n  2008-09-22 (0.1.0):\n\n\t* The initial version.\n\n*/\n\n#ifndef AC_KVEC_H\n#define AC_KVEC_H\n\n#include <stdlib.h>\n#include \"kalloc.h\"\n\n#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n\n#define kvec_t(type) struct { size_t n, m; type *a; }\n#define kv_init(v) ((v).n = (v).m = 0, (v).a = 0)\n#define kv_destroy(v) free((v).a)\n#define kv_A(v, i) ((v).a[(i)])\n#define kv_pop(v) ((v).a[--(v).n])\n#define kv_size(v) ((v).n)\n#define kv_max(v) ((v).m)\n\n#define kv_resize(type, km, v, s) do { \\\n\t\tif ((v).m < (s)) { \\\n\t\t\t(v).m = (s); \\\n\t\t\tkv_roundup32((v).m); \\\n\t\t\t(v).a = (type*)krealloc((km), (v).a, sizeof(type) * (v).m); \\\n\t\t} \\\n\t} while (0)\n\n#define kv_copy(type, km, v1, v0) do { \\\n\t\tif ((v1).m < (v0).n) kv_resize(type, (km), (v1), (v0).n); \\\n\t\t(v1).n = (v0).n; \\\n\t\tmemcpy((v1).a, (v0).a, sizeof(type) * (v0).n); \\\n\t} while (0) \\\n\n#define kv_push(type, km, v, x) do { \\\n\t\tif ((v).n == (v).m) { \\\n\t\t\t(v).m = (v).m? (v).m<<1 : 2; \\\n\t\t\t(v).a = (type*)krealloc((km), (v).a, sizeof(type) * (v).m); \\\n\t\t} \\\n\t\t(v).a[(v).n++] = (x); \\\n\t} while (0)\n\n#define kv_pushp(type, km, v, p) do { \\\n\t\tif ((v).n == (v).m) { \\\n\t\t\t(v).m = (v).m? (v).m<<1 : 2; \\\n\t\t\t(v).a = (type*)krealloc((km), (v).a, sizeof(type) * (v).m); \\\n\t\t} \\\n\t\t*(p) = &(v).a[(v).n++]; \\\n\t} while (0)\n\n#define kv_reverse(type, v, start) do { \\\n\t\tif ((v).m > 0 && (v).n > (start)) { \\\n\t\t\tsize_t __i, __end = (v).n - (start); \\\n\t\t\ttype *__a = (v).a + (start); \\\n\t\t\tfor (__i = 0; __i < __end>>1; ++__i) { \\\n\t\t\t\ttype __t = __a[__end - 1 - __i]; \\\n\t\t\t\t__a[__end - 1 - __i] = __a[__i]; __a[__i] = __t; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#endif\n"
        },
        {
          "name": "lchain.c",
          "type": "blob",
          "size": 12.5654296875,
          "content": "#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"mmpriv.h\"\n#include \"kalloc.h\"\n#include \"krmq.h\"\n\nstatic int64_t mg_chain_bk_end(int32_t max_drop, const mm128_t *z, const int32_t *f, const int64_t *p, int32_t *t, int64_t k)\n{\n\tint64_t i = z[k].y, end_i = -1, max_i = i;\n\tint32_t max_s = 0;\n\tif (i < 0 || t[i] != 0) return i;\n\tdo {\n\t\tint32_t s;\n\t\tt[i] = 2;\n\t\tend_i = i = p[i];\n\t\ts = i < 0? z[k].x : (int32_t)z[k].x - f[i];\n\t\tif (s > max_s) max_s = s, max_i = i;\n\t\telse if (max_s - s > max_drop) break;\n\t} while (i >= 0 && t[i] == 0);\n\tfor (i = z[k].y; i >= 0 && i != end_i; i = p[i]) // reset modified t[]\n\t\tt[i] = 0;\n\treturn max_i;\n}\n\nuint64_t *mg_chain_backtrack(void *km, int64_t n, const int32_t *f, const int64_t *p, int32_t *v, int32_t *t, int32_t min_cnt, int32_t min_sc, int32_t max_drop, int32_t *n_u_, int32_t *n_v_)\n{\n\tmm128_t *z;\n\tuint64_t *u;\n\tint64_t i, k, n_z, n_v;\n\tint32_t n_u;\n\n\t*n_u_ = *n_v_ = 0;\n\tfor (i = 0, n_z = 0; i < n; ++i) // precompute n_z\n\t\tif (f[i] >= min_sc) ++n_z;\n\tif (n_z == 0) return 0;\n\tz = Kmalloc(km, mm128_t, n_z);\n\tfor (i = 0, k = 0; i < n; ++i) // populate z[]\n\t\tif (f[i] >= min_sc) z[k].x = f[i], z[k++].y = i;\n\tradix_sort_128x(z, z + n_z);\n\n\tmemset(t, 0, n * 4);\n\tfor (k = n_z - 1, n_v = n_u = 0; k >= 0; --k) { // precompute n_u\n\t\tif (t[z[k].y] == 0) {\n\t\t\tint64_t n_v0 = n_v, end_i;\n\t\t\tint32_t sc;\n\t\t\tend_i = mg_chain_bk_end(max_drop, z, f, p, t, k);\n\t\t\tfor (i = z[k].y; i != end_i; i = p[i])\n\t\t\t\t++n_v, t[i] = 1;\n\t\t\tsc = i < 0? z[k].x : (int32_t)z[k].x - f[i];\n\t\t\tif (sc >= min_sc && n_v > n_v0 && n_v - n_v0 >= min_cnt)\n\t\t\t\t++n_u;\n\t\t\telse n_v = n_v0;\n\t\t}\n\t}\n\tu = Kmalloc(km, uint64_t, n_u);\n\tmemset(t, 0, n * 4);\n\tfor (k = n_z - 1, n_v = n_u = 0; k >= 0; --k) { // populate u[]\n\t\tif (t[z[k].y] == 0) {\n\t\t\tint64_t n_v0 = n_v, end_i;\n\t\t\tint32_t sc;\n\t\t\tend_i = mg_chain_bk_end(max_drop, z, f, p, t, k);\n\t\t\tfor (i = z[k].y; i != end_i; i = p[i])\n\t\t\t\tv[n_v++] = i, t[i] = 1;\n\t\t\tsc = i < 0? z[k].x : (int32_t)z[k].x - f[i];\n\t\t\tif (sc >= min_sc && n_v > n_v0 && n_v - n_v0 >= min_cnt)\n\t\t\t\tu[n_u++] = (uint64_t)sc << 32 | (n_v - n_v0);\n\t\t\telse n_v = n_v0;\n\t\t}\n\t}\n\tkfree(km, z);\n\tassert(n_v < INT32_MAX);\n\t*n_u_ = n_u, *n_v_ = n_v;\n\treturn u;\n}\n\nstatic mm128_t *compact_a(void *km, int32_t n_u, uint64_t *u, int32_t n_v, int32_t *v, mm128_t *a)\n{\n\tmm128_t *b, *w;\n\tuint64_t *u2;\n\tint64_t i, j, k;\n\n\t// write the result to b[]\n\tb = Kmalloc(km, mm128_t, n_v);\n\tfor (i = 0, k = 0; i < n_u; ++i) {\n\t\tint32_t k0 = k, ni = (int32_t)u[i];\n\t\tfor (j = 0; j < ni; ++j)\n\t\t\tb[k++] = a[v[k0 + (ni - j - 1)]];\n\t}\n\tkfree(km, v);\n\n\t// sort u[] and a[] by the target position, such that adjacent chains may be joined\n\tw = Kmalloc(km, mm128_t, n_u);\n\tfor (i = k = 0; i < n_u; ++i) {\n\t\tw[i].x = b[k].x, w[i].y = (uint64_t)k<<32|i;\n\t\tk += (int32_t)u[i];\n\t}\n\tradix_sort_128x(w, w + n_u);\n\tu2 = Kmalloc(km, uint64_t, n_u);\n\tfor (i = k = 0; i < n_u; ++i) {\n\t\tint32_t j = (int32_t)w[i].y, n = (int32_t)u[j];\n\t\tu2[i] = u[j];\n\t\tmemcpy(&a[k], &b[w[i].y>>32], n * sizeof(mm128_t));\n\t\tk += n;\n\t}\n\tmemcpy(u, u2, n_u * 8);\n\tmemcpy(b, a, k * sizeof(mm128_t)); // write _a_ to _b_ and deallocate _a_ because _a_ is oversized, sometimes a lot\n\tkfree(km, a); kfree(km, w); kfree(km, u2);\n\treturn b;\n}\n\nstatic inline int32_t comput_sc(const mm128_t *ai, const mm128_t *aj, int32_t max_dist_x, int32_t max_dist_y, int32_t bw, float chn_pen_gap, float chn_pen_skip, int is_cdna, int n_seg)\n{\n\tint32_t dq = (int32_t)ai->y - (int32_t)aj->y, dr, dd, dg, q_span, sc;\n\tint32_t sidi = (ai->y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;\n\tint32_t sidj = (aj->y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;\n\tif (dq <= 0 || dq > max_dist_x) return INT32_MIN;\n\tdr = (int32_t)(ai->x - aj->x);\n\tif (sidi == sidj && (dr == 0 || dq > max_dist_y)) return INT32_MIN;\n\tdd = dr > dq? dr - dq : dq - dr;\n\tif (sidi == sidj && dd > bw) return INT32_MIN;\n\tif (n_seg > 1 && !is_cdna && sidi == sidj && dr > max_dist_y) return INT32_MIN;\n\tdg = dr < dq? dr : dq;\n\tq_span = aj->y>>32&0xff;\n\tsc = q_span < dg? q_span : dg;\n\tif (dd || dg > q_span) {\n\t\tfloat lin_pen, log_pen;\n\t\tlin_pen = chn_pen_gap * (float)dd + chn_pen_skip * (float)dg;\n\t\tlog_pen = dd >= 1? mg_log2(dd + 1) : 0.0f; // mg_log2() only works for dd>=2\n\t\tif (is_cdna || sidi != sidj) {\n\t\t\tif (sidi != sidj && dr == 0) ++sc; // possibly due to overlapping paired ends; give a minor bonus\n\t\t\telse if (dr > dq || sidi != sidj) sc -= (int)(lin_pen < log_pen? lin_pen : log_pen); // deletion or jump between paired ends\n\t\t\telse sc -= (int)(lin_pen + .5f * log_pen);\n\t\t} else sc -= (int)(lin_pen + .5f * log_pen);\n\t}\n\treturn sc;\n}\n\n/* Input:\n *   a[].x: rev<<63 | tid<<32 | tpos\n *   a[].y: flags<<40 | q_span<<32 | q_pos\n * Output:\n *   n_u: #chains\n *   u[]: score<<32 | #anchors (sum of lower 32 bits of u[] is the returned length of a[])\n * input a[] is deallocated on return\n */\nmm128_t *mg_lchain_dp(int max_dist_x, int max_dist_y, int bw, int max_skip, int max_iter, int min_cnt, int min_sc, float chn_pen_gap, float chn_pen_skip,\n\t\t\t\t\t  int is_cdna, int n_seg, int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, void *km)\n{ // TODO: make sure this works when n has more than 32 bits\n\tint32_t *f, *t, *v, n_u, n_v, mmax_f = 0, max_drop = bw;\n\tint64_t *p, i, j, max_ii, st = 0;\n\tuint64_t *u;\n\n\tif (_u) *_u = 0, *n_u_ = 0;\n\tif (n == 0 || a == 0) {\n\t\tkfree(km, a);\n\t\treturn 0;\n\t}\n\tif (max_dist_x < bw) max_dist_x = bw;\n\tif (max_dist_y < bw && !is_cdna) max_dist_y = bw;\n\tif (is_cdna) max_drop = INT32_MAX;\n\tp = Kmalloc(km, int64_t, n);\n\tf = Kmalloc(km, int32_t, n);\n\tv = Kmalloc(km, int32_t, n);\n\tt = Kcalloc(km, int32_t, n);\n\n\t// fill the score and backtrack arrays\n\tfor (i = 0, max_ii = -1; i < n; ++i) {\n\t\tint64_t max_j = -1, end_j;\n\t\tint32_t max_f = a[i].y>>32&0xff, n_skip = 0;\n\t\twhile (st < i && (a[i].x>>32 != a[st].x>>32 || a[i].x > a[st].x + max_dist_x)) ++st;\n\t\tif (i - st > max_iter) st = i - max_iter;\n\t\tfor (j = i - 1; j >= st; --j) {\n\t\t\tint32_t sc;\n\t\t\tsc = comput_sc(&a[i], &a[j], max_dist_x, max_dist_y, bw, chn_pen_gap, chn_pen_skip, is_cdna, n_seg);\n\t\t\tif (sc == INT32_MIN) continue;\n\t\t\tsc += f[j];\n\t\t\tif (sc > max_f) {\n\t\t\t\tmax_f = sc, max_j = j;\n\t\t\t\tif (n_skip > 0) --n_skip;\n\t\t\t} else if (t[j] == (int32_t)i) {\n\t\t\t\tif (++n_skip > max_skip)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p[j] >= 0) t[p[j]] = i;\n\t\t}\n\t\tend_j = j;\n\t\tif (max_ii < 0 || a[i].x - a[max_ii].x > (int64_t)max_dist_x) {\n\t\t\tint32_t max = INT32_MIN;\n\t\t\tmax_ii = -1;\n\t\t\tfor (j = i - 1; j >= st; --j)\n\t\t\t\tif (max < f[j]) max = f[j], max_ii = j;\n\t\t}\n\t\tif (max_ii >= 0 && max_ii < end_j) {\n\t\t\tint32_t tmp;\n\t\t\ttmp = comput_sc(&a[i], &a[max_ii], max_dist_x, max_dist_y, bw, chn_pen_gap, chn_pen_skip, is_cdna, n_seg);\n\t\t\tif (tmp != INT32_MIN && max_f < tmp + f[max_ii])\n\t\t\t\tmax_f = tmp + f[max_ii], max_j = max_ii;\n\t\t}\n\t\tf[i] = max_f, p[i] = max_j;\n\t\tv[i] = max_j >= 0 && v[max_j] > max_f? v[max_j] : max_f; // v[] keeps the peak score up to i; f[] is the score ending at i, not always the peak\n\t\tif (max_ii < 0 || (a[i].x - a[max_ii].x <= (int64_t)max_dist_x && f[max_ii] < f[i]))\n\t\t\tmax_ii = i;\n\t\tif (mmax_f < max_f) mmax_f = max_f;\n\t\t//fprintf(stderr, \"X1\\t%ld\\t%ld:%d\\t%ld\\t%ld:%d\\t%ld\\t%ld\\n\", (long)i, (long)(a[i].x>>32), (int32_t)a[i].x, (long)max_j, max_j<0?-1L:(long)(a[max_j].x>>32), max_j<0?-1:(int32_t)a[max_j].x, (long)max_f, (long)v[i]);\n\t}\n\n\tu = mg_chain_backtrack(km, n, f, p, v, t, min_cnt, min_sc, max_drop, &n_u, &n_v);\n\t*n_u_ = n_u, *_u = u; // NB: note that u[] may not be sorted by score here\n\tkfree(km, p); kfree(km, f); kfree(km, t);\n\tif (n_u == 0) {\n\t\tkfree(km, a); kfree(km, v);\n\t\treturn 0;\n\t}\n\treturn compact_a(km, n_u, u, n_v, v, a);\n}\n\ntypedef struct lc_elem_s {\n\tint32_t y;\n\tint64_t i;\n\tdouble pri;\n\tKRMQ_HEAD(struct lc_elem_s) head;\n} lc_elem_t;\n\n#define lc_elem_cmp(a, b) ((a)->y < (b)->y? -1 : (a)->y > (b)->y? 1 : ((a)->i > (b)->i) - ((a)->i < (b)->i))\n#define lc_elem_lt2(a, b) ((a)->pri < (b)->pri)\nKRMQ_INIT(lc_elem, lc_elem_t, head, lc_elem_cmp, lc_elem_lt2)\n\nKALLOC_POOL_INIT(rmq, lc_elem_t)\n\nstatic inline int32_t comput_sc_simple(const mm128_t *ai, const mm128_t *aj, float chn_pen_gap, float chn_pen_skip, int32_t *exact, int32_t *width)\n{\n\tint32_t dq = (int32_t)ai->y - (int32_t)aj->y, dr, dd, dg, q_span, sc;\n\tdr = (int32_t)(ai->x - aj->x);\n\t*width = dd = dr > dq? dr - dq : dq - dr;\n\tdg = dr < dq? dr : dq;\n\tq_span = aj->y>>32&0xff;\n\tsc = q_span < dg? q_span : dg;\n\tif (exact) *exact = (dd == 0 && dg <= q_span);\n\tif (dd || dq > q_span) {\n\t\tfloat lin_pen, log_pen;\n\t\tlin_pen = chn_pen_gap * (float)dd + chn_pen_skip * (float)dg;\n\t\tlog_pen = dd >= 1? mg_log2(dd + 1) : 0.0f; // mg_log2() only works for dd>=2\n\t\tsc -= (int)(lin_pen + .5f * log_pen);\n\t}\n\treturn sc;\n}\n\nmm128_t *mg_lchain_rmq(int max_dist, int max_dist_inner, int bw, int max_chn_skip, int cap_rmq_size, int min_cnt, int min_sc, float chn_pen_gap, float chn_pen_skip,\n\t\t\t\t\t   int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, void *km)\n{\n\tint32_t *f,*t, *v, n_u, n_v, mmax_f = 0, max_rmq_size = 0, max_drop = bw;\n\tint64_t *p, i, i0, st = 0, st_inner = 0;\n\tuint64_t *u;\n\tlc_elem_t *root = 0, *root_inner = 0;\n\tvoid *mem_mp = 0;\n\tkmp_rmq_t *mp;\n\n\tif (_u) *_u = 0, *n_u_ = 0;\n\tif (n == 0 || a == 0) {\n\t\tkfree(km, a);\n\t\treturn 0;\n\t}\n\tif (max_dist < bw) max_dist = bw;\n\tif (max_dist_inner < 0) max_dist_inner = 0;\n\tif (max_dist_inner > max_dist) max_dist_inner = max_dist;\n\tp = Kmalloc(km, int64_t, n);\n\tf = Kmalloc(km, int32_t, n);\n\tt = Kcalloc(km, int32_t, n);\n\tv = Kmalloc(km, int32_t, n);\n\tmem_mp = km_init2(km, 0x10000);\n\tmp = kmp_init_rmq(mem_mp);\n\n\t// fill the score and backtrack arrays\n\tfor (i = i0 = 0; i < n; ++i) {\n\t\tint64_t max_j = -1;\n\t\tint32_t q_span = a[i].y>>32&0xff, max_f = q_span;\n\t\tlc_elem_t s, *q, *r, lo, hi;\n\t\t// add in-range anchors\n\t\tif (i0 < i && a[i0].x != a[i].x) {\n\t\t\tint64_t j;\n\t\t\tfor (j = i0; j < i; ++j) {\n\t\t\t\tq = kmp_alloc_rmq(mp);\n\t\t\t\tq->y = (int32_t)a[j].y, q->i = j, q->pri = -(f[j] + 0.5 * chn_pen_gap * ((int32_t)a[j].x + (int32_t)a[j].y));\n\t\t\t\tkrmq_insert(lc_elem, &root, q, 0);\n\t\t\t\tif (max_dist_inner > 0) {\n\t\t\t\t\tr = kmp_alloc_rmq(mp);\n\t\t\t\t\t*r = *q;\n\t\t\t\t\tkrmq_insert(lc_elem, &root_inner, r, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti0 = i;\n\t\t}\n\t\t// get rid of active chains out of range\n\t\twhile (st < i && (a[i].x>>32 != a[st].x>>32 || a[i].x > a[st].x + max_dist || krmq_size(head, root) > cap_rmq_size)) {\n\t\t\ts.y = (int32_t)a[st].y, s.i = st;\n\t\t\tif ((q = krmq_find(lc_elem, root, &s, 0)) != 0) {\n\t\t\t\tq = krmq_erase(lc_elem, &root, q, 0);\n\t\t\t\tkmp_free_rmq(mp, q);\n\t\t\t}\n\t\t\t++st;\n\t\t}\n\t\tif (max_dist_inner > 0)  { // similar to the block above, but applied to the inner tree\n\t\t\twhile (st_inner < i && (a[i].x>>32 != a[st_inner].x>>32 || a[i].x > a[st_inner].x + max_dist_inner || krmq_size(head, root_inner) > cap_rmq_size)) {\n\t\t\t\ts.y = (int32_t)a[st_inner].y, s.i = st_inner;\n\t\t\t\tif ((q = krmq_find(lc_elem, root_inner, &s, 0)) != 0) {\n\t\t\t\t\tq = krmq_erase(lc_elem, &root_inner, q, 0);\n\t\t\t\t\tkmp_free_rmq(mp, q);\n\t\t\t\t}\n\t\t\t\t++st_inner;\n\t\t\t}\n\t\t}\n\t\t// RMQ\n\t\tlo.i = INT32_MAX, lo.y = (int32_t)a[i].y - max_dist;\n\t\thi.i = 0, hi.y = (int32_t)a[i].y;\n\t\tif ((q = krmq_rmq(lc_elem, root, &lo, &hi)) != 0) {\n\t\t\tint32_t sc, exact, width, n_skip = 0;\n\t\t\tint64_t j = q->i;\n\t\t\tassert(q->y >= lo.y && q->y <= hi.y);\n\t\t\tsc = f[j] + comput_sc_simple(&a[i], &a[j], chn_pen_gap, chn_pen_skip, &exact, &width);\n\t\t\tif (width <= bw && sc > max_f) max_f = sc, max_j = j;\n\t\t\tif (!exact && root_inner && (int32_t)a[i].y > 0) {\n\t\t\t\tlc_elem_t *lo, *hi;\n\t\t\t\ts.y = (int32_t)a[i].y - 1, s.i = n;\n\t\t\t\tkrmq_interval(lc_elem, root_inner, &s, &lo, &hi);\n\t\t\t\tif (lo) {\n\t\t\t\t\tconst lc_elem_t *q;\n\t\t\t\t\tint32_t width;\n\t\t\t\t\tkrmq_itr_t(lc_elem) itr;\n\t\t\t\t\tkrmq_itr_find(lc_elem, root_inner, lo, &itr);\n\t\t\t\t\twhile ((q = krmq_at(&itr)) != 0) {\n\t\t\t\t\t\tif (q->y < (int32_t)a[i].y - max_dist_inner) break;\n\t\t\t\t\t\tj = q->i;\n\t\t\t\t\t\tsc = f[j] + comput_sc_simple(&a[i], &a[j], chn_pen_gap, chn_pen_skip, 0, &width);\n\t\t\t\t\t\tif (width <= bw) {\n\t\t\t\t\t\t\tif (sc > max_f) {\n\t\t\t\t\t\t\t\tmax_f = sc, max_j = j;\n\t\t\t\t\t\t\t\tif (n_skip > 0) --n_skip;\n\t\t\t\t\t\t\t} else if (t[j] == (int32_t)i) {\n\t\t\t\t\t\t\t\tif (++n_skip > max_chn_skip)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (p[j] >= 0) t[p[j]] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!krmq_itr_prev(lc_elem, &itr)) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// set max\n\t\tassert(max_j < 0 || (a[max_j].x < a[i].x && (int32_t)a[max_j].y < (int32_t)a[i].y));\n\t\tf[i] = max_f, p[i] = max_j;\n\t\tv[i] = max_j >= 0 && v[max_j] > max_f? v[max_j] : max_f; // v[] keeps the peak score up to i; f[] is the score ending at i, not always the peak\n\t\tif (mmax_f < max_f) mmax_f = max_f;\n\t\tif (max_rmq_size < krmq_size(head, root)) max_rmq_size = krmq_size(head, root);\n\t}\n\tkm_destroy(mem_mp);\n\n\tu = mg_chain_backtrack(km, n, f, p, v, t, min_cnt, min_sc, max_drop, &n_u, &n_v);\n\t*n_u_ = n_u, *_u = u; // NB: note that u[] may not be sorted by score here\n\tkfree(km, p); kfree(km, f); kfree(km, t);\n\tif (n_u == 0) {\n\t\tkfree(km, a); kfree(km, v);\n\t\treturn 0;\n\t}\n\treturn compact_a(km, n_u, u, n_v, v, a);\n}\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 22.9443359375,
          "content": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include \"bseq.h\"\n#include \"minimap.h\"\n#include \"mmpriv.h\"\n#include \"ketopt.h\"\n\n#ifdef __linux__\n#include <sys/resource.h>\n#include <sys/time.h>\nvoid liftrlimit()\n{\n\tstruct rlimit r;\n\tgetrlimit(RLIMIT_AS, &r);\n\tr.rlim_cur = r.rlim_max;\n\tsetrlimit(RLIMIT_AS, &r);\n}\n#else\nvoid liftrlimit() {}\n#endif\n\nstatic ko_longopt_t long_options[] = {\n\t{ \"bucket-bits\",    ko_required_argument, 300 },\n\t{ \"mb-size\",        ko_required_argument, 'K' },\n\t{ \"seed\",           ko_required_argument, 302 },\n\t{ \"no-kalloc\",      ko_no_argument,       303 },\n\t{ \"print-qname\",    ko_no_argument,       304 },\n\t{ \"no-self\",        ko_no_argument,       'D' },\n\t{ \"print-seeds\",    ko_no_argument,       306 },\n\t{ \"max-chain-skip\", ko_required_argument, 307 },\n\t{ \"min-dp-len\",     ko_required_argument, 308 },\n\t{ \"print-aln-seq\",  ko_no_argument,       309 },\n\t{ \"splice\",         ko_no_argument,       310 },\n\t{ \"cost-non-gt-ag\", ko_required_argument, 'C' },\n\t{ \"no-long-join\",   ko_no_argument,       312 },\n\t{ \"sr\",             ko_no_argument,       313 },\n\t{ \"frag\",           ko_required_argument, 314 },\n\t{ \"secondary\",      ko_required_argument, 315 },\n\t{ \"cs\",             ko_optional_argument, 316 },\n\t{ \"end-bonus\",      ko_required_argument, 317 },\n\t{ \"no-pairing\",     ko_no_argument,       318 },\n\t{ \"splice-flank\",   ko_required_argument, 319 },\n\t{ \"idx-no-seq\",     ko_no_argument,       320 },\n\t{ \"end-seed-pen\",   ko_required_argument, 321 },\n\t{ \"for-only\",       ko_no_argument,       322 },\n\t{ \"rev-only\",       ko_no_argument,       323 },\n\t{ \"heap-sort\",      ko_required_argument, 324 },\n\t{ \"all-chain\",      ko_no_argument,       'P' },\n\t{ \"dual\",           ko_required_argument, 326 },\n\t{ \"max-clip-ratio\", ko_required_argument, 327 },\n\t{ \"min-occ-floor\",  ko_required_argument, 328 },\n\t{ \"MD\",             ko_no_argument,       329 },\n\t{ \"lj-min-ratio\",   ko_required_argument, 330 },\n\t{ \"score-N\",        ko_required_argument, 331 },\n\t{ \"eqx\",            ko_no_argument,       332 },\n\t{ \"paf-no-hit\",     ko_no_argument,       333 },\n\t{ \"split-prefix\",   ko_required_argument, 334 },\n\t{ \"no-end-flt\",     ko_no_argument,       335 },\n\t{ \"hard-mask-level\",ko_no_argument,       336 },\n\t{ \"cap-sw-mem\",     ko_required_argument, 337 },\n\t{ \"max-qlen\",       ko_required_argument, 338 },\n\t{ \"max-chain-iter\", ko_required_argument, 339 },\n\t{ \"junc-bed\",       ko_required_argument, 340 },\n\t{ \"junc-bonus\",     ko_required_argument, 341 },\n\t{ \"sam-hit-only\",   ko_no_argument,       342 },\n\t{ \"chain-gap-scale\",ko_required_argument, 343 },\n\t{ \"alt\",            ko_required_argument, 344 },\n\t{ \"alt-drop\",       ko_required_argument, 345 },\n\t{ \"mask-len\",       ko_required_argument, 346 },\n\t{ \"rmq\",            ko_optional_argument, 347 },\n\t{ \"qstrand\",        ko_no_argument,       348 },\n\t{ \"cap-kalloc\",     ko_required_argument, 349 },\n\t{ \"q-occ-frac\",     ko_required_argument, 350 },\n\t{ \"chain-skip-scale\",ko_required_argument,351 },\n\t{ \"print-chains\",   ko_no_argument,       352 },\n\t{ \"no-hash-name\",   ko_no_argument,       353 },\n\t{ \"secondary-seq\",  ko_no_argument,       354 },\n\t{ \"ds\",             ko_no_argument,       355 },\n\t{ \"rmq-inner\",      ko_required_argument, 356 },\n\t{ \"spsc\",           ko_required_argument, 357 },\n\t{ \"junc-pen\",       ko_required_argument, 358 },\n\t{ \"dbg-seed-occ\",   ko_no_argument,       501 },\n\t{ \"help\",           ko_no_argument,       'h' },\n\t{ \"max-intron-len\", ko_required_argument, 'G' },\n\t{ \"version\",        ko_no_argument,       'V' },\n\t{ \"min-count\",      ko_required_argument, 'n' },\n\t{ \"min-chain-score\",ko_required_argument, 'm' },\n\t{ \"mask-level\",     ko_required_argument, 'M' },\n\t{ \"min-dp-score\",   ko_required_argument, 's' },\n\t{ \"sam\",            ko_no_argument,       'a' },\n\t{ 0, 0, 0 }\n};\n\nstatic inline int64_t mm_parse_num2(const char *str, char **q)\n{\n\tdouble x;\n\tchar *p;\n\tx = strtod(str, &p);\n\tif (*p == 'G' || *p == 'g') x *= 1e9, ++p;\n\telse if (*p == 'M' || *p == 'm') x *= 1e6, ++p;\n\telse if (*p == 'K' || *p == 'k') x *= 1e3, ++p;\n\tif (q) *q = p;\n\treturn (int64_t)(x + .499);\n}\n\nstatic inline int64_t mm_parse_num(const char *str)\n{\n\treturn mm_parse_num2(str, 0);\n}\n\nstatic inline void yes_or_no(mm_mapopt_t *opt, int64_t flag, int long_idx, const char *arg, int yes_to_set)\n{\n\tif (yes_to_set) {\n\t\tif (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"y\") == 0) opt->flag |= flag;\n\t\telse if (strcmp(arg, \"no\") == 0 || strcmp(arg, \"n\") == 0) opt->flag &= ~flag;\n\t\telse fprintf(stderr, \"[WARNING]\\033[1;31m option '--%s' only accepts 'yes' or 'no'.\\033[0m\\n\", long_options[long_idx].name);\n\t} else {\n\t\tif (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"y\") == 0) opt->flag &= ~flag;\n\t\telse if (strcmp(arg, \"no\") == 0 || strcmp(arg, \"n\") == 0) opt->flag |= flag;\n\t\telse fprintf(stderr, \"[WARNING]\\033[1;31m option '--%s' only accepts 'yes' or 'no'.\\033[0m\\n\", long_options[long_idx].name);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tconst char *opt_str = \"2aSDw:k:K:t:r:f:Vv:g:G:I:d:XT:s:x:Hcp:M:n:z:A:B:b:O:E:m:N:Qu:R:hF:LC:yYPo:e:U:J:\";\n\tketopt_t o = KETOPT_INIT;\n\tmm_mapopt_t opt;\n\tmm_idxopt_t ipt;\n\tint i, c, n_threads = 3, n_parts, old_best_n = -1;\n\tchar *fnw = 0, *rg = 0, *junc_bed = 0, *fn_spsc = 0, *s, *alt_list = 0;\n\tFILE *fp_help = stderr;\n\tmm_idx_reader_t *idx_rdr;\n\tmm_idx_t *mi;\n\n\tmm_verbose = 3;\n\tliftrlimit();\n\tmm_realtime0 = realtime();\n\tmm_set_opt(0, &ipt, &opt);\n\n\twhile ((c = ketopt(&o, argc, argv, 1, opt_str, long_options)) >= 0) { // test command line options and apply option -x/preset first\n\t\tif (c == 'x') {\n\t\t\tif (mm_set_opt(o.arg, &ipt, &opt) < 0) {\n\t\t\t\tfprintf(stderr, \"[ERROR] unknown preset '%s'\\n\", o.arg);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (c == ':') {\n\t\t\tfprintf(stderr, \"[ERROR] missing option argument\\n\");\n\t\t\treturn 1;\n\t\t} else if (c == '?') {\n\t\t\tfprintf(stderr, \"[ERROR] unknown option in \\\"%s\\\"\\n\", argv[o.i - 1]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\to = KETOPT_INIT;\n\n\twhile ((c = ketopt(&o, argc, argv, 1, opt_str, long_options)) >= 0) {\n\t\tif (c == 'w') ipt.w = atoi(o.arg);\n\t\telse if (c == 'k') ipt.k = atoi(o.arg);\n\t\telse if (c == 'H') ipt.flag |= MM_I_HPC;\n\t\telse if (c == 'd') fnw = o.arg; // the above are indexing related options, except -I\n\t\telse if (c == 't') n_threads = atoi(o.arg);\n\t\telse if (c == 'v') mm_verbose = atoi(o.arg);\n\t\telse if (c == 'g') opt.max_gap = (int)mm_parse_num(o.arg);\n\t\telse if (c == 'G') mm_mapopt_max_intron_len(&opt, (int)mm_parse_num(o.arg));\n\t\telse if (c == 'F') opt.max_frag_len = (int)mm_parse_num(o.arg);\n\t\telse if (c == 'N') old_best_n = opt.best_n, opt.best_n = atoi(o.arg);\n\t\telse if (c == 'p') opt.pri_ratio = atof(o.arg);\n\t\telse if (c == 'M') opt.mask_level = atof(o.arg);\n\t\telse if (c == 'c') opt.flag |= MM_F_OUT_CG | MM_F_CIGAR;\n\t\telse if (c == 'D') opt.flag |= MM_F_NO_DIAG;\n\t\telse if (c == 'P') opt.flag |= MM_F_ALL_CHAINS;\n\t\telse if (c == 'X') opt.flag |= MM_F_ALL_CHAINS | MM_F_NO_DIAG | MM_F_NO_DUAL | MM_F_NO_LJOIN; // -D -P --no-long-join --dual=no\n\t\telse if (c == 'a') opt.flag |= MM_F_OUT_SAM | MM_F_CIGAR;\n\t\telse if (c == 'Q') opt.flag |= MM_F_NO_QUAL;\n\t\telse if (c == 'Y') opt.flag |= MM_F_SOFTCLIP;\n\t\telse if (c == 'L') opt.flag |= MM_F_LONG_CIGAR;\n\t\telse if (c == 'y') opt.flag |= MM_F_COPY_COMMENT;\n\t\telse if (c == 'T') opt.sdust_thres = atoi(o.arg);\n\t\telse if (c == 'n') opt.min_cnt = atoi(o.arg);\n\t\telse if (c == 'm') opt.min_chain_score = atoi(o.arg);\n\t\telse if (c == 'A') opt.a = atoi(o.arg);\n\t\telse if (c == 'B') opt.b = atoi(o.arg);\n\t\telse if (c == 'b') opt.transition = atoi(o.arg);\n\t\telse if (c == 's') opt.min_dp_max = atoi(o.arg);\n\t\telse if (c == 'C') opt.noncan = atoi(o.arg);\n\t\telse if (c == 'I') ipt.batch_size = mm_parse_num(o.arg);\n\t\telse if (c == 'K') opt.mini_batch_size = mm_parse_num(o.arg);\n\t\telse if (c == 'e') opt.occ_dist = mm_parse_num(o.arg);\n\t\telse if (c == 'R') rg = o.arg;\n\t\telse if (c == 'h') fp_help = stdout;\n\t\telse if (c == '2') opt.flag |= MM_F_2_IO_THREADS;\n\t\telse if (c == 'J') {\n\t\t\tint t;\n\t\t\tt = atoi(o.arg);\n\t\t\tif (t == 0) opt.flag |= MM_F_SPLICE_OLD;\n\t\t\telse if (t == 1) opt.flag &= ~MM_F_SPLICE_OLD;\n\t\t} else if (c == 'o') {\n\t\t\tif (strcmp(o.arg, \"-\") != 0) {\n\t\t\t\tif (freopen(o.arg, \"wb\", stdout) == NULL) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m failed to write the output to file '%s'\\033[0m: %s\\n\", o.arg, strerror(errno));\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (c == 300) ipt.bucket_bits = atoi(o.arg); // --bucket-bits\n\t\telse if (c == 302) opt.seed = atoi(o.arg); // --seed\n\t\telse if (c == 303) mm_dbg_flag |= MM_DBG_NO_KALLOC; // --no-kalloc\n\t\telse if (c == 304) mm_dbg_flag |= MM_DBG_PRINT_QNAME; // --print-qname\n\t\telse if (c == 306) mm_dbg_flag |= MM_DBG_PRINT_QNAME | MM_DBG_PRINT_SEED, n_threads = 1; // --print-seed\n\t\telse if (c == 307) opt.max_chain_skip = atoi(o.arg); // --max-chain-skip\n\t\telse if (c == 339) opt.max_chain_iter = atoi(o.arg); // --max-chain-iter\n\t\telse if (c == 308) opt.min_ksw_len = atoi(o.arg); // --min-dp-len\n\t\telse if (c == 309) mm_dbg_flag |= MM_DBG_PRINT_QNAME | MM_DBG_PRINT_ALN_SEQ, n_threads = 1; // --print-aln-seq\n\t\telse if (c == 310) opt.flag |= MM_F_SPLICE; // --splice\n\t\telse if (c == 312) opt.flag |= MM_F_NO_LJOIN; // --no-long-join\n\t\telse if (c == 313) opt.flag |= MM_F_SR; // --sr\n\t\telse if (c == 317) opt.end_bonus = atoi(o.arg); // --end-bonus\n\t\telse if (c == 318) opt.flag |= MM_F_INDEPEND_SEG; // --no-pairing\n\t\telse if (c == 320) ipt.flag |= MM_I_NO_SEQ; // --idx-no-seq\n\t\telse if (c == 321) opt.anchor_ext_shift = atoi(o.arg); // --end-seed-pen\n\t\telse if (c == 322) opt.flag |= MM_F_FOR_ONLY; // --for-only\n\t\telse if (c == 323) opt.flag |= MM_F_REV_ONLY; // --rev-only\n\t\telse if (c == 327) opt.max_clip_ratio = atof(o.arg); // --max-clip-ratio\n\t\telse if (c == 328) opt.min_mid_occ = atoi(o.arg); // --min-occ-floor\n\t\telse if (c == 329) opt.flag |= MM_F_OUT_MD; // --MD\n\t\telse if (c == 331) opt.sc_ambi = atoi(o.arg); // --score-N\n\t\telse if (c == 332) opt.flag |= MM_F_EQX; // --eqx\n\t\telse if (c == 333) opt.flag |= MM_F_PAF_NO_HIT; // --paf-no-hit\n\t\telse if (c == 334) opt.split_prefix = o.arg; // --split-prefix\n\t\telse if (c == 335) opt.flag |= MM_F_NO_END_FLT; // --no-end-flt\n\t\telse if (c == 336) opt.flag |= MM_F_HARD_MLEVEL; // --hard-mask-level\n\t\telse if (c == 337) opt.max_sw_mat = mm_parse_num(o.arg); // --cap-sw-mat\n\t\telse if (c == 338) opt.max_qlen = mm_parse_num(o.arg); // --max-qlen\n\t\telse if (c == 340) junc_bed = o.arg; // --junc-bed\n\t\telse if (c == 341) opt.junc_bonus = atoi(o.arg); // --junc-bonus\n\t\telse if (c == 358) opt.junc_pen = atoi(o.arg); // --junc-pen\n\t\telse if (c == 342) opt.flag |= MM_F_SAM_HIT_ONLY; // --sam-hit-only\n\t\telse if (c == 343) opt.chain_gap_scale = atof(o.arg); // --chain-gap-scale\n\t\telse if (c == 351) opt.chain_skip_scale = atof(o.arg); // --chain-skip-scale\n\t\telse if (c == 344) alt_list = o.arg; // --alt\n\t\telse if (c == 345) opt.alt_drop = atof(o.arg); // --alt-drop\n\t\telse if (c == 346) opt.mask_len = mm_parse_num(o.arg); // --mask-len\n\t\telse if (c == 348) opt.flag |= MM_F_QSTRAND | MM_F_NO_INV; // --qstrand\n\t\telse if (c == 349) opt.cap_kalloc = mm_parse_num(o.arg); // --cap-kalloc\n\t\telse if (c == 350) opt.q_occ_frac = atof(o.arg); // --q-occ-frac\n\t\telse if (c == 352) mm_dbg_flag |= MM_DBG_PRINT_CHAIN; // --print-chains\n\t\telse if (c == 353) opt.flag |= MM_F_NO_HASH_NAME; // --no-hash-name\n\t\telse if (c == 354) opt.flag |= MM_F_SECONDARY_SEQ; // --secondary-seq\n\t\telse if (c == 355) opt.flag |= MM_F_OUT_DS; // --ds\n\t\telse if (c == 356) opt.rmq_inner_dist = mm_parse_num(o.arg); // --rmq-inner\n\t\telse if (c == 357) fn_spsc = o.arg; // --spsc\n\t\telse if (c == 501) mm_dbg_flag |= MM_DBG_SEED_FREQ; // --dbg-seed-occ\n\t\telse if (c == 330) {\n\t\t\tfprintf(stderr, \"[WARNING] \\033[1;31m --lj-min-ratio has been deprecated.\\033[0m\\n\");\n\t\t} else if (c == 314) { // --frag\n\t\t\tyes_or_no(&opt, MM_F_FRAG_MODE, o.longidx, o.arg, 1);\n\t\t} else if (c == 315) { // --secondary\n\t\t\tyes_or_no(&opt, MM_F_NO_PRINT_2ND, o.longidx, o.arg, 0);\n\t\t} else if (c == 316) { // --cs\n\t\t\topt.flag |= MM_F_OUT_CS | MM_F_CIGAR;\n\t\t\tif (o.arg == 0 || strcmp(o.arg, \"short\") == 0) {\n\t\t\t\topt.flag &= ~MM_F_OUT_CS_LONG;\n\t\t\t} else if (strcmp(o.arg, \"long\") == 0) {\n\t\t\t\topt.flag |= MM_F_OUT_CS_LONG;\n\t\t\t} else if (strcmp(o.arg, \"none\") == 0) {\n\t\t\t\topt.flag &= ~MM_F_OUT_CS;\n\t\t\t} else if (mm_verbose >= 2) {\n\t\t\t\tfprintf(stderr, \"[WARNING]\\033[1;31m --cs only takes 'short' or 'long'. Invalid values are assumed to be 'short'.\\033[0m\\n\");\n\t\t\t}\n\t\t} else if (c == 319) { // --splice-flank\n\t\t\tyes_or_no(&opt, MM_F_SPLICE_FLANK, o.longidx, o.arg, 1);\n\t\t} else if (c == 324) { // --heap-sort\n\t\t\tyes_or_no(&opt, MM_F_HEAP_SORT, o.longidx, o.arg, 1);\n\t\t} else if (c == 326) { // --dual\n\t\t\tyes_or_no(&opt, MM_F_NO_DUAL, o.longidx, o.arg, 0);\n\t\t} else if (c == 347) { // --rmq\n\t\t\tif (o.arg) yes_or_no(&opt, MM_F_RMQ, o.longidx, o.arg, 1);\n\t\t\telse opt.flag |= MM_F_RMQ;\n\t\t} else if (c == 'S') {\n\t\t\topt.flag |= MM_F_OUT_CS | MM_F_CIGAR | MM_F_OUT_CS_LONG;\n\t\t\tif (mm_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[WARNING]\\033[1;31m option -S is deprecated and may be removed in future. Please use --cs=long instead.\\033[0m\\n\");\n\t\t} else if (c == 'V') {\n\t\t\tputs(MM_VERSION);\n\t\t\treturn 0;\n\t\t} else if (c == 'r') {\n\t\t\topt.bw = (int)mm_parse_num2(o.arg, &s);\n\t\t\tif (*s == ',') opt.bw_long = (int)mm_parse_num2(s + 1, &s);\n\t\t} else if (c == 'U') {\n\t\t\topt.min_mid_occ = strtol(o.arg, &s, 10);\n\t\t\tif (*s == ',') opt.max_mid_occ = strtol(s + 1, &s, 10);\n\t\t} else if (c == 'f') {\n\t\t\tdouble x;\n\t\t\tchar *p;\n\t\t\tx = strtod(o.arg, &p);\n\t\t\tif (x < 1.0) opt.mid_occ_frac = x, opt.mid_occ = 0;\n\t\t\telse opt.mid_occ = (int)(x + .499);\n\t\t\tif (*p == ',') opt.max_occ = (int)(strtod(p+1, &p) + .499);\n\t\t} else if (c == 'u') {\n\t\t\tif (*o.arg == 'b') opt.flag |= MM_F_SPLICE_FOR|MM_F_SPLICE_REV; // both strands\n\t\t\telse if (*o.arg == 'f') opt.flag |= MM_F_SPLICE_FOR, opt.flag &= ~MM_F_SPLICE_REV; // match GT-AG\n\t\t\telse if (*o.arg == 'r') opt.flag |= MM_F_SPLICE_REV, opt.flag &= ~MM_F_SPLICE_FOR; // match CT-AC (reverse complement of GT-AG)\n\t\t\telse if (*o.arg == 'n') opt.flag &= ~(MM_F_SPLICE_FOR|MM_F_SPLICE_REV); // don't try to match the GT-AG signal\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m unrecognized cDNA direction\\033[0m\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (c == 'z') {\n\t\t\topt.zdrop = opt.zdrop_inv = strtol(o.arg, &s, 10);\n\t\t\tif (*s == ',') opt.zdrop_inv = strtol(s + 1, &s, 10);\n\t\t} else if (c == 'O') {\n\t\t\topt.q = opt.q2 = strtol(o.arg, &s, 10);\n\t\t\tif (*s == ',') opt.q2 = strtol(s + 1, &s, 10);\n\t\t} else if (c == 'E') {\n\t\t\topt.e = opt.e2 = strtol(o.arg, &s, 10);\n\t\t\tif (*s == ',') opt.e2 = strtol(s + 1, &s, 10);\n\t\t}\n\t}\n\tif ((opt.flag & MM_F_SPLICE) && (opt.flag & MM_F_FRAG_MODE)) {\n\t\tfprintf(stderr, \"[ERROR]\\033[1;31m --splice and --frag should not be specified at the same time.\\033[0m\\n\");\n\t\treturn 1;\n\t}\n\tif (!fnw && !(opt.flag&MM_F_CIGAR))\n\t\tipt.flag |= MM_I_NO_SEQ;\n\tif (mm_check_opt(&ipt, &opt) < 0)\n\t\treturn 1;\n\tif (opt.best_n == 0) {\n\t\tfprintf(stderr, \"[WARNING]\\033[1;31m changed '-N 0' to '-N %d --secondary=no'.\\033[0m\\n\", old_best_n);\n\t\topt.best_n = old_best_n, opt.flag |= MM_F_NO_PRINT_2ND;\n\t}\n\n\tif (argc == o.ind || fp_help == stdout) {\n\t\tfprintf(fp_help, \"Usage: minimap2 [options] <target.fa>|<target.idx> [query.fa] [...]\\n\");\n\t\tfprintf(fp_help, \"Options:\\n\");\n\t\tfprintf(fp_help, \"  Indexing:\\n\");\n\t\tfprintf(fp_help, \"    -H           use homopolymer-compressed k-mer (preferrable for PacBio)\\n\");\n\t\tfprintf(fp_help, \"    -k INT       k-mer size (no larger than 28) [%d]\\n\", ipt.k);\n\t\tfprintf(fp_help, \"    -w INT       minimizer window size [%d]\\n\", ipt.w);\n\t\tfprintf(fp_help, \"    -I NUM       split index for every ~NUM input bases [8G]\\n\");\n\t\tfprintf(fp_help, \"    -d FILE      dump index to FILE []\\n\");\n\t\tfprintf(fp_help, \"  Mapping:\\n\");\n\t\tfprintf(fp_help, \"    -f FLOAT     filter out top FLOAT fraction of repetitive minimizers [%g]\\n\", opt.mid_occ_frac);\n\t\tfprintf(fp_help, \"    -g NUM       stop chain enlongation if there are no minimizers in INT-bp [%d]\\n\", opt.max_gap);\n\t\tfprintf(fp_help, \"    -G NUM       max intron length (effective with -xsplice; changing -r) [200k]\\n\");\n\t\tfprintf(fp_help, \"    -F NUM       max fragment length (effective with -xsr or in the fragment mode) [800]\\n\");\n\t\tfprintf(fp_help, \"    -r NUM[,NUM] chaining/alignment bandwidth and long-join bandwidth [%d,%d]\\n\", opt.bw, opt.bw_long);\n\t\tfprintf(fp_help, \"    -n INT       minimal number of minimizers on a chain [%d]\\n\", opt.min_cnt);\n\t\tfprintf(fp_help, \"    -m INT       minimal chaining score (matching bases minus log gap penalty) [%d]\\n\", opt.min_chain_score);\n//\t\tfprintf(fp_help, \"    -T INT       SDUST threshold; 0 to disable SDUST [%d]\\n\", opt.sdust_thres); // TODO: this option is never used; might be buggy\n\t\tfprintf(fp_help, \"    -X           skip self and dual mappings (for the all-vs-all mode)\\n\");\n\t\tfprintf(fp_help, \"    -p FLOAT     min secondary-to-primary score ratio [%g]\\n\", opt.pri_ratio);\n\t\tfprintf(fp_help, \"    -N INT       retain at most INT secondary alignments [%d]\\n\", opt.best_n);\n\t\tfprintf(fp_help, \"  Alignment:\\n\");\n\t\tfprintf(fp_help, \"    -A INT       matching score [%d]\\n\", opt.a);\n\t\tfprintf(fp_help, \"    -B INT       mismatch penalty (larger value for lower divergence) [%d]\\n\", opt.b);\n\t\tfprintf(fp_help, \"    -O INT[,INT] gap open penalty [%d,%d]\\n\", opt.q, opt.q2);\n\t\tfprintf(fp_help, \"    -E INT[,INT] gap extension penalty; a k-long gap costs min{O1+k*E1,O2+k*E2} [%d,%d]\\n\", opt.e, opt.e2);\n\t\tfprintf(fp_help, \"    -z INT[,INT] Z-drop score and inversion Z-drop score [%d,%d]\\n\", opt.zdrop, opt.zdrop_inv);\n\t\tfprintf(fp_help, \"    -s INT       minimal peak DP alignment score [%d]\\n\", opt.min_dp_max);\n\t\tfprintf(fp_help, \"    -u CHAR      how to find GT-AG. f:transcript strand, b:both strands, n:don't match GT-AG [n]\\n\");\n\t\tfprintf(fp_help, \"    -J INT       splice mode. 0: original minimap2 model; 1: miniprot model [1]\\n\");\n\t\tfprintf(fp_help, \"  Input/Output:\\n\");\n\t\tfprintf(fp_help, \"    -a           output in the SAM format (PAF by default)\\n\");\n\t\tfprintf(fp_help, \"    -o FILE      output alignments to FILE [stdout]\\n\");\n\t\tfprintf(fp_help, \"    -L           write CIGAR with >65535 ops at the CG tag\\n\");\n\t\tfprintf(fp_help, \"    -R STR       SAM read group line in a format like '@RG\\\\tID:foo\\\\tSM:bar' []\\n\");\n\t\tfprintf(fp_help, \"    -c           output CIGAR in PAF\\n\");\n\t\tfprintf(fp_help, \"    --cs[=STR]   output the cs tag; STR is 'short' (if absent) or 'long' [none]\\n\");\n\t\tfprintf(fp_help, \"    --ds         output the ds tag, which is an extension to cs\\n\");\n\t\tfprintf(fp_help, \"    --MD         output the MD tag\\n\");\n\t\tfprintf(fp_help, \"    --eqx        write =/X CIGAR operators\\n\");\n\t\tfprintf(fp_help, \"    -Y           use soft clipping for supplementary alignments\\n\");\n\t\tfprintf(fp_help, \"    -t INT       number of threads [%d]\\n\", n_threads);\n\t\tfprintf(fp_help, \"    -K NUM       minibatch size for mapping [500M]\\n\");\n//\t\tfprintf(fp_help, \"    -v INT       verbose level [%d]\\n\", mm_verbose);\n\t\tfprintf(fp_help, \"    --version    show version number\\n\");\n\t\tfprintf(fp_help, \"  Preset:\\n\");\n\t\tfprintf(fp_help, \"    -x STR       preset (always applied before other options; see minimap2.1 for details) []\\n\");\n\t\tfprintf(fp_help, \"                 - lr:hq - accurate long reads (error rate <1%%) against a reference genome\\n\");\n\t\tfprintf(fp_help, \"                 - splice/splice:hq - spliced alignment for long reads/accurate long reads\\n\");\n\t\tfprintf(fp_help, \"                 - asm5/asm10/asm20 - asm-to-ref mapping, for ~0.1/1/5%% sequence divergence\\n\");\n\t\tfprintf(fp_help, \"                 - sr - short reads against a reference\\n\");\n\t\tfprintf(fp_help, \"                 - map-pb/map-hifi/map-ont/map-iclr - CLR/HiFi/Nanopore/ICLR vs reference mapping\\n\");\n\t\tfprintf(fp_help, \"                 - ava-pb/ava-ont - PacBio CLR/Nanopore read overlap\\n\");\n\t\tfprintf(fp_help, \"\\nSee `man ./minimap2.1' for detailed description of these and other advanced command-line options.\\n\");\n\t\treturn fp_help == stdout? 0 : 1;\n\t}\n\n\tif ((opt.flag & MM_F_SR) && argc - o.ind > 3) {\n\t\tfprintf(stderr, \"[ERROR] incorrect input: in the sr mode, please specify no more than two query files.\\n\");\n\t\treturn 1;\n\t}\n\tidx_rdr = mm_idx_reader_open(argv[o.ind], &ipt, fnw);\n\tif (idx_rdr == 0) {\n\t\tfprintf(stderr, \"[ERROR] failed to open file '%s': %s\\n\", argv[o.ind], strerror(errno));\n\t\treturn 1;\n\t}\n\tif (!idx_rdr->is_idx && fnw == 0 && argc - o.ind < 2) {\n\t\tfprintf(stderr, \"[ERROR] missing input: please specify a query file to map or option -d to keep the index\\n\");\n\t\tmm_idx_reader_close(idx_rdr);\n\t\treturn 1;\n\t}\n\tif (opt.best_n == 0 && (opt.flag&MM_F_CIGAR) && mm_verbose >= 2)\n\t\tfprintf(stderr, \"[WARNING]\\033[1;31m `-N 0' reduces alignment accuracy. Please use --secondary=no to suppress secondary alignments.\\033[0m\\n\");\n\twhile ((mi = mm_idx_reader_read(idx_rdr, n_threads)) != 0) {\n\t\tint ret;\n\t\tif ((opt.flag & MM_F_CIGAR) && (mi->flag & MM_I_NO_SEQ)) {\n\t\t\tfprintf(stderr, \"[ERROR] the prebuilt index doesn't contain sequences.\\n\");\n\t\t\tmm_idx_destroy(mi);\n\t\t\tmm_idx_reader_close(idx_rdr);\n\t\t\treturn 1;\n\t\t}\n\t\tif ((opt.flag & MM_F_OUT_SAM) && idx_rdr->n_parts == 1) {\n\t\t\tif (mm_idx_reader_eof(idx_rdr)) {\n\t\t\t\tif (opt.split_prefix == 0)\n\t\t\t\t\tret = mm_write_sam_hdr(mi, rg, MM_VERSION, argc, argv);\n\t\t\t\telse\n\t\t\t\t\tret = mm_write_sam_hdr(0, rg, MM_VERSION, argc, argv);\n\t\t\t} else {\n\t\t\t\tret = mm_write_sam_hdr(0, rg, MM_VERSION, argc, argv);\n\t\t\t\tif (opt.split_prefix == 0 && mm_verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"[WARNING]\\033[1;31m For a multi-part index, no @SQ lines will be outputted. Please use --split-prefix.\\033[0m\\n\");\n\t\t\t}\n\t\t\tif (ret != 0) {\n\t\t\t\tmm_idx_destroy(mi);\n\t\t\t\tmm_idx_reader_close(idx_rdr);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (mm_verbose >= 3)\n\t\t\tfprintf(stderr, \"[M::%s::%.3f*%.2f] loaded/built the index for %d target sequence(s)\\n\",\n\t\t\t\t\t__func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), mi->n_seq);\n\t\tif (argc != o.ind + 1) mm_mapopt_update(&opt, mi);\n\t\tif (mm_verbose >= 3) mm_idx_stat(mi);\n\t\tif (junc_bed) {\n\t\t\tmm_idx_bed_read(mi, junc_bed, 1);\n\t\t\tif (mi->I == 0 && mm_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[WARNING] failed to load the junction BED file\\n\");\n\t\t}\n\t\tif (fn_spsc) {\n\t\t\tmm_idx_spsc_read(mi, fn_spsc, mm_max_spsc_bonus(&opt));\n\t\t\tif (mi->spsc == 0 && mm_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[WARNING] failed to load the splice score file\\n\");\n\t\t}\n\t\tif (alt_list) mm_idx_alt_read(mi, alt_list);\n\t\tif (argc - (o.ind + 1) == 0) {\n\t\t\tmm_idx_destroy(mi);\n\t\t\tcontinue; // no query files\n\t\t}\n\t\tret = 0;\n\t\tif (!(opt.flag & MM_F_FRAG_MODE)) {\n\t\t\tfor (i = o.ind + 1; i < argc; ++i) {\n\t\t\t\tret = mm_map_file(mi, argv[i], &opt, n_threads);\n\t\t\t\tif (ret < 0) break;\n\t\t\t}\n\t\t} else {\n\t\t\tret = mm_map_file_frag(mi, argc - (o.ind + 1), (const char**)&argv[o.ind + 1], &opt, n_threads);\n\t\t}\n\t\tmm_idx_destroy(mi);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"ERROR: failed to map the query file\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tn_parts = idx_rdr->n_parts;\n\tmm_idx_reader_close(idx_rdr);\n\n\tif (opt.split_prefix)\n\t\tmm_split_merge(argc - (o.ind + 1), (const char**)&argv[o.ind + 1], &opt, n_parts);\n\n\tif (fflush(stdout) == EOF) {\n\t\tperror(\"[ERROR] failed to write the results\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (mm_verbose >= 3) {\n\t\tfprintf(stderr, \"[M::%s] Version: %s\\n\", __func__, MM_VERSION);\n\t\tfprintf(stderr, \"[M::%s] CMD:\", __func__);\n\t\tfor (i = 0; i < argc; ++i)\n\t\t\tfprintf(stderr, \" %s\", argv[i]);\n\t\tfprintf(stderr, \"\\n[M::%s] Real time: %.3f sec; CPU: %.3f sec; Peak RSS: %.3f GB\\n\", __func__, realtime() - mm_realtime0, cputime(), peakrss() / 1024.0 / 1024.0 / 1024.0);\n\t}\n\treturn 0;\n}\n"
        },
        {
          "name": "map.c",
          "type": "blob",
          "size": 27.3818359375,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include \"kthread.h\"\n#include \"kvec.h\"\n#include \"kalloc.h\"\n#include \"sdust.h\"\n#include \"mmpriv.h\"\n#include \"bseq.h\"\n#include \"khash.h\"\n\nmm_tbuf_t *mm_tbuf_init(void)\n{\n\tmm_tbuf_t *b;\n\tb = (mm_tbuf_t*)calloc(1, sizeof(mm_tbuf_t));\n\tif (!(mm_dbg_flag & 1)) b->km = km_init();\n\treturn b;\n}\n\nvoid mm_tbuf_destroy(mm_tbuf_t *b)\n{\n\tif (b == 0) return;\n\tkm_destroy(b->km);\n\tfree(b);\n}\n\nvoid *mm_tbuf_get_km(mm_tbuf_t *b)\n{\n\treturn b->km;\n}\n\nstatic int mm_dust_minier(void *km, int n, mm128_t *a, int l_seq, const char *seq, int sdust_thres)\n{\n\tint n_dreg, j, k, u = 0;\n\tconst uint64_t *dreg;\n\tsdust_buf_t *sdb;\n\tif (sdust_thres <= 0) return n;\n\tsdb = sdust_buf_init(km);\n\tdreg = sdust_core((const uint8_t*)seq, l_seq, sdust_thres, 64, &n_dreg, sdb);\n\tfor (j = k = 0; j < n; ++j) { // squeeze out minimizers that significantly overlap with LCRs\n\t\tint32_t qpos = (uint32_t)a[j].y>>1, span = a[j].x&0xff;\n\t\tint32_t s = qpos - (span - 1), e = s + span;\n\t\twhile (u < n_dreg && (int32_t)dreg[u] <= s) ++u;\n\t\tif (u < n_dreg && (int32_t)(dreg[u]>>32) < e) {\n\t\t\tint v, l = 0;\n\t\t\tfor (v = u; v < n_dreg && (int32_t)(dreg[v]>>32) < e; ++v) { // iterate over LCRs overlapping this minimizer\n\t\t\t\tint ss = s > (int32_t)(dreg[v]>>32)? s : dreg[v]>>32;\n\t\t\t\tint ee = e < (int32_t)dreg[v]? e : (uint32_t)dreg[v];\n\t\t\t\tl += ee - ss;\n\t\t\t}\n\t\t\tif (l <= span>>1) a[k++] = a[j]; // keep the minimizer if less than half of it falls in masked region\n\t\t} else a[k++] = a[j];\n\t}\n\tsdust_buf_destroy(sdb);\n\treturn k; // the new size\n}\n\nstatic void collect_minimizers(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int n_segs, const int *qlens, const char **seqs, mm128_v *mv)\n{\n\tint i, n, sum = 0;\n\tmv->n = 0;\n\tfor (i = n = 0; i < n_segs; ++i) {\n\t\tsize_t j;\n\t\tmm_sketch(km, seqs[i], qlens[i], mi->w, mi->k, i, mi->flag&MM_I_HPC, mv);\n\t\tfor (j = n; j < mv->n; ++j)\n\t\t\tmv->a[j].y += sum << 1;\n\t\tif (opt->sdust_thres > 0) // mask low-complexity minimizers\n\t\t\tmv->n = n + mm_dust_minier(km, mv->n - n, mv->a + n, qlens[i], seqs[i], opt->sdust_thres);\n\t\tsum += qlens[i], n = mv->n;\n\t}\n}\n\n#include \"ksort.h\"\n#define heap_lt(a, b) ((a).x > (b).x)\nKSORT_INIT(heap, mm128_t, heap_lt)\n\nstatic inline int skip_seed(int flag, uint64_t r, const mm_seed_t *q, const char *qname, int qlen, const mm_idx_t *mi, int *is_self)\n{\n\t*is_self = 0;\n\tif (qname && (flag & (MM_F_NO_DIAG|MM_F_NO_DUAL))) {\n\t\tconst mm_idx_seq_t *s = &mi->seq[r>>32];\n\t\tint cmp;\n\t\tcmp = strcmp(qname, s->name);\n\t\tif ((flag&MM_F_NO_DIAG) && cmp == 0 && (int)s->len == qlen) {\n\t\t\tif ((uint32_t)r>>1 == (q->q_pos>>1)) return 1; // avoid the diagnonal anchors\n\t\t\tif ((r&1) == (q->q_pos&1)) *is_self = 1; // this flag is used to avoid spurious extension on self chain\n\t\t}\n\t\tif ((flag&MM_F_NO_DUAL) && cmp > 0) // all-vs-all mode: map once\n\t\t\treturn 1;\n\t}\n\tif (flag & (MM_F_FOR_ONLY|MM_F_REV_ONLY)) {\n\t\tif ((r&1) == (q->q_pos&1)) { // forward strand\n\t\t\tif (flag & MM_F_REV_ONLY) return 1;\n\t\t} else {\n\t\t\tif (flag & MM_F_FOR_ONLY) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic mm128_t *collect_seed_hits_heap(void *km, const mm_mapopt_t *opt, int max_occ, const mm_idx_t *mi, const char *qname, const mm128_v *mv, int qlen, int64_t *n_a, int *rep_len,\n\t\t\t\t\t\t\t\t  int *n_mini_pos, uint64_t **mini_pos)\n{\n\tint i, n_m, heap_size = 0;\n\tint64_t j, n_for = 0, n_rev = 0;\n\tmm_seed_t *m;\n\tmm128_t *a, *heap;\n\n\tm = mm_collect_matches(km, &n_m, qlen, max_occ, opt->max_max_occ, opt->occ_dist, mi, mv, n_a, rep_len, n_mini_pos, mini_pos);\n\n\theap = (mm128_t*)kmalloc(km, n_m * sizeof(mm128_t));\n\ta = (mm128_t*)kmalloc(km, *n_a * sizeof(mm128_t));\n\n\tfor (i = 0, heap_size = 0; i < n_m; ++i) {\n\t\tif (m[i].n > 0) {\n\t\t\theap[heap_size].x = m[i].cr[0];\n\t\t\theap[heap_size].y = (uint64_t)i<<32;\n\t\t\t++heap_size;\n\t\t}\n\t}\n\tks_heapmake_heap(heap_size, heap);\n\twhile (heap_size > 0) {\n\t\tmm_seed_t *q = &m[heap->y>>32];\n\t\tmm128_t *p;\n\t\tuint64_t r = heap->x;\n\t\tint32_t is_self, rpos = (uint32_t)r >> 1;\n\t\tif (!skip_seed(opt->flag, r, q, qname, qlen, mi, &is_self)) {\n\t\t\tif ((r&1) == (q->q_pos&1)) { // forward strand\n\t\t\t\tp = &a[n_for++];\n\t\t\t\tp->x = (r&0xffffffff00000000ULL) | rpos;\n\t\t\t\tp->y = (uint64_t)q->q_span << 32 | q->q_pos >> 1;\n\t\t\t} else { // reverse strand\n\t\t\t\tp = &a[(*n_a) - (++n_rev)];\n\t\t\t\tp->x = 1ULL<<63 | (r&0xffffffff00000000ULL) | rpos;\n\t\t\t\tp->y = (uint64_t)q->q_span << 32 | (qlen - ((q->q_pos>>1) + 1 - q->q_span) - 1);\n\t\t\t}\n\t\t\tp->y |= (uint64_t)q->seg_id << MM_SEED_SEG_SHIFT;\n\t\t\tif (q->is_tandem) p->y |= MM_SEED_TANDEM;\n\t\t\tif (is_self) p->y |= MM_SEED_SELF;\n\t\t}\n\t\t// update the heap\n\t\tif ((uint32_t)heap->y < q->n - 1) {\n\t\t\t++heap[0].y;\n\t\t\theap[0].x = m[heap[0].y>>32].cr[(uint32_t)heap[0].y];\n\t\t} else {\n\t\t\theap[0] = heap[heap_size - 1];\n\t\t\t--heap_size;\n\t\t}\n\t\tks_heapdown_heap(0, heap_size, heap);\n\t}\n\tkfree(km, m);\n\tkfree(km, heap);\n\n\t// reverse anchors on the reverse strand, as they are in the descending order\n\tfor (j = 0; j < n_rev>>1; ++j) {\n\t\tmm128_t t = a[(*n_a) - 1 - j];\n\t\ta[(*n_a) - 1 - j] = a[(*n_a) - (n_rev - j)];\n\t\ta[(*n_a) - (n_rev - j)] = t;\n\t}\n\tif (*n_a > n_for + n_rev) {\n\t\tmemmove(a + n_for, a + (*n_a) - n_rev, n_rev * sizeof(mm128_t));\n\t\t*n_a = n_for + n_rev;\n\t}\n\treturn a;\n}\n\nstatic mm128_t *collect_seed_hits(void *km, const mm_mapopt_t *opt, int max_occ, const mm_idx_t *mi, const char *qname, const mm128_v *mv, int qlen, int64_t *n_a, int *rep_len,\n\t\t\t\t\t\t\t\t  int *n_mini_pos, uint64_t **mini_pos)\n{\n\tint i, n_m;\n\tmm_seed_t *m;\n\tmm128_t *a;\n\tm = mm_collect_matches(km, &n_m, qlen, max_occ, opt->max_max_occ, opt->occ_dist, mi, mv, n_a, rep_len, n_mini_pos, mini_pos);\n\ta = (mm128_t*)kmalloc(km, *n_a * sizeof(mm128_t));\n\tfor (i = 0, *n_a = 0; i < n_m; ++i) {\n\t\tmm_seed_t *q = &m[i];\n\t\tconst uint64_t *r = q->cr;\n\t\tuint32_t k;\n\t\tfor (k = 0; k < q->n; ++k) {\n\t\t\tint32_t is_self, rpos = (uint32_t)r[k] >> 1;\n\t\t\tmm128_t *p;\n\t\t\tif (skip_seed(opt->flag, r[k], q, qname, qlen, mi, &is_self)) continue;\n\t\t\tp = &a[(*n_a)++];\n\t\t\tif ((r[k]&1) == (q->q_pos&1)) { // forward strand\n\t\t\t\tp->x = (r[k]&0xffffffff00000000ULL) | rpos;\n\t\t\t\tp->y = (uint64_t)q->q_span << 32 | q->q_pos >> 1;\n\t\t\t} else if (!(opt->flag & MM_F_QSTRAND)) { // reverse strand and not in the query-strand mode\n\t\t\t\tp->x = 1ULL<<63 | (r[k]&0xffffffff00000000ULL) | rpos;\n\t\t\t\tp->y = (uint64_t)q->q_span << 32 | (qlen - ((q->q_pos>>1) + 1 - q->q_span) - 1);\n\t\t\t} else { // reverse strand; query-strand\n\t\t\t\tint32_t len = mi->seq[r[k]>>32].len;\n\t\t\t\tp->x = 1ULL<<63 | (r[k]&0xffffffff00000000ULL) | (len - (rpos + 1 - q->q_span) - 1); // coordinate only accurate for non-HPC seeds\n\t\t\t\tp->y = (uint64_t)q->q_span << 32 | q->q_pos >> 1;\n\t\t\t}\n\t\t\tp->y |= (uint64_t)q->seg_id << MM_SEED_SEG_SHIFT;\n\t\t\tif (q->is_tandem) p->y |= MM_SEED_TANDEM;\n\t\t\tif (is_self) p->y |= MM_SEED_SELF;\n\t\t}\n\t}\n\tkfree(km, m);\n\tradix_sort_128x(a, a + (*n_a));\n\treturn a;\n}\n\nstatic void chain_post(const mm_mapopt_t *opt, int max_chain_gap_ref, const mm_idx_t *mi, void *km, int qlen, int n_segs, const int *qlens, int *n_regs, mm_reg1_t *regs, mm128_t *a)\n{\n\tif (!(opt->flag & MM_F_ALL_CHAINS)) { // don't choose primary mapping(s)\n\t\tmm_set_parent(km, opt->mask_level, opt->mask_len, *n_regs, regs, opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);\n\t\tif (n_segs <= 1) mm_select_sub(km, opt->pri_ratio, mi->k*2, opt->best_n, 1, opt->max_gap * 0.8, n_regs, regs);\n\t\telse mm_select_sub_multi(km, opt->pri_ratio, 0.2f, 0.7f, max_chain_gap_ref, mi->k*2, opt->best_n, n_segs, qlens, n_regs, regs);\n\t}\n}\n\nstatic mm_reg1_t *align_regs(const mm_mapopt_t *opt, const mm_idx_t *mi, void *km, int qlen, const char *seq, int *n_regs, mm_reg1_t *regs, mm128_t *a)\n{\n\tif (!(opt->flag & MM_F_CIGAR)) return regs;\n\tregs = mm_align_skeleton(km, opt, mi, qlen, seq, n_regs, regs, a); // this calls mm_filter_regs()\n\tif (!(opt->flag & MM_F_ALL_CHAINS)) { // don't choose primary mapping(s)\n\t\tmm_set_parent(km, opt->mask_level, opt->mask_len, *n_regs, regs, opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);\n\t\tmm_select_sub(km, opt->pri_ratio, mi->k*2, opt->best_n, 0, opt->max_gap * 0.8, n_regs, regs);\n\t\tmm_set_sam_pri(*n_regs, regs);\n\t}\n\treturn regs;\n}\n\nvoid mm_map_frag(const mm_idx_t *mi, int n_segs, const int *qlens, const char **seqs, int *n_regs, mm_reg1_t **regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *qname)\n{\n\tint i, j, rep_len, qlen_sum, n_regs0, n_mini_pos;\n\tint max_chain_gap_qry, max_chain_gap_ref, is_splice = !!(opt->flag & MM_F_SPLICE), is_sr = !!(opt->flag & MM_F_SR);\n\tuint32_t hash;\n\tint64_t n_a;\n\tuint64_t *u, *mini_pos;\n\tmm128_t *a;\n\tmm128_v mv = {0,0,0};\n\tmm_reg1_t *regs0;\n\tkm_stat_t kmst;\n\tfloat chn_pen_gap, chn_pen_skip;\n\n\tfor (i = 0, qlen_sum = 0; i < n_segs; ++i)\n\t\tqlen_sum += qlens[i], n_regs[i] = 0, regs[i] = 0;\n\n\tif (qlen_sum == 0 || n_segs <= 0 || n_segs > MM_MAX_SEG) return;\n\tif (opt->max_qlen > 0 && qlen_sum > opt->max_qlen) return;\n\n\thash  = qname && !(opt->flag & MM_F_NO_HASH_NAME)? __ac_X31_hash_string(qname) : 0;\n\thash ^= __ac_Wang_hash(qlen_sum) + __ac_Wang_hash(opt->seed);\n\thash  = __ac_Wang_hash(hash);\n\n\tcollect_minimizers(b->km, opt, mi, n_segs, qlens, seqs, &mv);\n\tif (opt->q_occ_frac > 0.0f) mm_seed_mz_flt(b->km, &mv, opt->mid_occ, opt->q_occ_frac);\n\tif (opt->flag & MM_F_HEAP_SORT) a = collect_seed_hits_heap(b->km, opt, opt->mid_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);\n\telse a = collect_seed_hits(b->km, opt, opt->mid_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);\n\n\tif (mm_dbg_flag & MM_DBG_PRINT_SEED) {\n\t\tfprintf(stderr, \"RS\\t%d\\n\", rep_len);\n\t\tfor (i = 0; i < n_a; ++i)\n\t\t\tfprintf(stderr, \"SD\\t%s\\t%d\\t%c\\t%d\\t%d\\t%d\\n\", mi->seq[a[i].x<<1>>33].name, (int32_t)a[i].x, \"+-\"[a[i].x>>63], (int32_t)a[i].y, (int32_t)(a[i].y>>32&0xff),\n\t\t\t\t\ti == 0? 0 : ((int32_t)a[i].y - (int32_t)a[i-1].y) - ((int32_t)a[i].x - (int32_t)a[i-1].x));\n\t}\n\n\t// set max chaining gap on the query and the reference sequence\n\tif (is_sr)\n\t\tmax_chain_gap_qry = qlen_sum > opt->max_gap? qlen_sum : opt->max_gap;\n\telse max_chain_gap_qry = opt->max_gap;\n\tif (opt->max_gap_ref > 0) {\n\t\tmax_chain_gap_ref = opt->max_gap_ref; // always honor mm_mapopt_t::max_gap_ref if set\n\t} else if (opt->max_frag_len > 0) {\n\t\tmax_chain_gap_ref = opt->max_frag_len - qlen_sum;\n\t\tif (max_chain_gap_ref < opt->max_gap) max_chain_gap_ref = opt->max_gap;\n\t} else max_chain_gap_ref = opt->max_gap;\n\n\tchn_pen_gap  = opt->chain_gap_scale * 0.01 * mi->k;\n\tchn_pen_skip = opt->chain_skip_scale * 0.01 * mi->k;\n\tif (opt->flag & MM_F_RMQ) {\n\t\ta = mg_lchain_rmq(opt->max_gap, opt->rmq_inner_dist, opt->bw, opt->max_chain_skip, opt->rmq_size_cap, opt->min_cnt, opt->min_chain_score,\n\t\t\t\t\t\t  chn_pen_gap, chn_pen_skip, n_a, a, &n_regs0, &u, b->km);\n\t} else {\n\t\ta = mg_lchain_dp(max_chain_gap_ref, max_chain_gap_qry, opt->bw, opt->max_chain_skip, opt->max_chain_iter, opt->min_cnt, opt->min_chain_score,\n\t\t\t\t\t\t chn_pen_gap, chn_pen_skip, is_splice, n_segs, n_a, a, &n_regs0, &u, b->km);\n\t}\n\n\tif (opt->bw_long > opt->bw && (opt->flag & (MM_F_SPLICE|MM_F_SR|MM_F_NO_LJOIN)) == 0 && n_segs == 1 && n_regs0 > 1) { // re-chain/long-join for long sequences\n\t\tint32_t st = (int32_t)a[0].y, en = (int32_t)a[(int32_t)u[0] - 1].y;\n\t\tif (qlen_sum - (en - st) > opt->rmq_rescue_size || en - st > qlen_sum * opt->rmq_rescue_ratio) {\n\t\t\tint32_t i;\n\t\t\tfor (i = 0, n_a = 0; i < n_regs0; ++i) n_a += (int32_t)u[i];\n\t\t\tkfree(b->km, u);\n\t\t\tradix_sort_128x(a, a + n_a);\n\t\t\ta = mg_lchain_rmq(opt->max_gap, opt->rmq_inner_dist, opt->bw_long, opt->max_chain_skip, opt->rmq_size_cap, opt->min_cnt, opt->min_chain_score,\n\t\t\t\t\t\t\t  chn_pen_gap, chn_pen_skip, n_a, a, &n_regs0, &u, b->km);\n\t\t}\n\t} else if (opt->max_occ > opt->mid_occ && rep_len > 0 && !(opt->flag & MM_F_RMQ)) { // re-chain, mostly for short reads\n\t\tint rechain = 0;\n\t\tif (n_regs0 > 0) { // test if the best chain has all the segments\n\t\t\tint n_chained_segs = 1, max = 0, max_i = -1, max_off = -1, off = 0;\n\t\t\tfor (i = 0; i < n_regs0; ++i) { // find the best chain\n\t\t\t\tif (max < (int)(u[i]>>32)) max = u[i]>>32, max_i = i, max_off = off;\n\t\t\t\toff += (uint32_t)u[i];\n\t\t\t}\n\t\t\tfor (i = 1; i < (int32_t)u[max_i]; ++i) // count the number of segments in the best chain\n\t\t\t\tif ((a[max_off+i].y&MM_SEED_SEG_MASK) != (a[max_off+i-1].y&MM_SEED_SEG_MASK))\n\t\t\t\t\t++n_chained_segs;\n\t\t\tif (n_chained_segs < n_segs)\n\t\t\t\trechain = 1;\n\t\t} else rechain = 1;\n\t\tif (rechain) { // redo chaining with a higher max_occ threshold\n\t\t\tkfree(b->km, a);\n\t\t\tkfree(b->km, u);\n\t\t\tkfree(b->km, mini_pos);\n\t\t\tif (opt->flag & MM_F_HEAP_SORT) a = collect_seed_hits_heap(b->km, opt, opt->max_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);\n\t\t\telse a = collect_seed_hits(b->km, opt, opt->max_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);\n\t\t\ta = mg_lchain_dp(max_chain_gap_ref, max_chain_gap_qry, opt->bw, opt->max_chain_skip, opt->max_chain_iter, opt->min_cnt, opt->min_chain_score,\n\t\t\t\t\t\t\t chn_pen_gap, chn_pen_skip, is_splice, n_segs, n_a, a, &n_regs0, &u, b->km);\n\t\t}\n\t}\n\tb->frag_gap = max_chain_gap_ref;\n\tb->rep_len = rep_len;\n\n\tregs0 = mm_gen_regs(b->km, hash, qlen_sum, n_regs0, u, a, !!(opt->flag&MM_F_QSTRAND));\n\tif (mi->n_alt) {\n\t\tmm_mark_alt(mi, n_regs0, regs0);\n\t\tmm_hit_sort(b->km, &n_regs0, regs0, opt->alt_drop); // this step can be merged into mm_gen_regs(); will do if this shows up in profile\n\t}\n\n\tif (mm_dbg_flag & (MM_DBG_PRINT_SEED|MM_DBG_PRINT_CHAIN))\n\t\tfor (j = 0; j < n_regs0; ++j)\n\t\t\tfor (i = regs0[j].as; i < regs0[j].as + regs0[j].cnt; ++i)\n\t\t\t\tfprintf(stderr, \"CN\\t%d\\t%s\\t%d\\t%c\\t%d\\t%d\\t%d\\n\", j, mi->seq[a[i].x<<1>>33].name, (int32_t)a[i].x, \"+-\"[a[i].x>>63], (int32_t)a[i].y, (int32_t)(a[i].y>>32&0xff),\n\t\t\t\t\t\ti == regs0[j].as? 0 : ((int32_t)a[i].y - (int32_t)a[i-1].y) - ((int32_t)a[i].x - (int32_t)a[i-1].x));\n\n\tchain_post(opt, max_chain_gap_ref, mi, b->km, qlen_sum, n_segs, qlens, &n_regs0, regs0, a);\n\tif (!is_sr && !(opt->flag&MM_F_QSTRAND)) {\n\t\tmm_est_err(mi, qlen_sum, n_regs0, regs0, a, n_mini_pos, mini_pos);\n\t\tn_regs0 = mm_filter_strand_retained(n_regs0, regs0);\n\t}\n\n\tif (n_segs == 1) { // uni-segment\n\t\tregs0 = align_regs(opt, mi, b->km, qlens[0], seqs[0], &n_regs0, regs0, a);\n\t\tregs0 = (mm_reg1_t*)realloc(regs0, sizeof(*regs0) * n_regs0);\n\t\tmm_set_mapq(b->km, n_regs0, regs0, opt->min_chain_score, opt->a, rep_len, is_sr);\n\t\tn_regs[0] = n_regs0, regs[0] = regs0;\n\t} else { // multi-segment\n\t\tmm_seg_t *seg;\n\t\tseg = mm_seg_gen(b->km, hash, n_segs, qlens, n_regs0, regs0, n_regs, regs, a); // split fragment chain to separate segment chains\n\t\tfree(regs0);\n\t\tfor (i = 0; i < n_segs; ++i) {\n\t\t\tmm_set_parent(b->km, opt->mask_level, opt->mask_len, n_regs[i], regs[i], opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop); // update mm_reg1_t::parent\n\t\t\tregs[i] = align_regs(opt, mi, b->km, qlens[i], seqs[i], &n_regs[i], regs[i], seg[i].a);\n\t\t\tmm_set_mapq(b->km, n_regs[i], regs[i], opt->min_chain_score, opt->a, rep_len, is_sr);\n\t\t}\n\t\tmm_seg_free(b->km, n_segs, seg);\n\t\tif (n_segs == 2 && opt->pe_ori >= 0 && (opt->flag&MM_F_CIGAR))\n\t\t\tmm_pair(b->km, max_chain_gap_ref, opt->pe_bonus, opt->a * 2 + opt->b, opt->a, qlens, n_regs, regs); // pairing\n\t}\n\n\tkfree(b->km, mv.a);\n\tkfree(b->km, a);\n\tkfree(b->km, u);\n\tkfree(b->km, mini_pos);\n\n\tif (b->km) {\n\t\tkm_stat(b->km, &kmst);\n\t\tif (mm_dbg_flag & MM_DBG_PRINT_QNAME)\n\t\t\tfprintf(stderr, \"QM\\t%s\\t%d\\tcap=%ld,nCore=%ld,largest=%ld\\n\", qname, qlen_sum, kmst.capacity, kmst.n_cores, kmst.largest);\n\t\tassert(kmst.n_blocks == kmst.n_cores); // otherwise, there is a memory leak\n\t\tif (kmst.largest > 1U<<28 || (opt->cap_kalloc > 0 && kmst.capacity > opt->cap_kalloc)) {\n\t\t\tif (mm_dbg_flag & MM_DBG_PRINT_QNAME)\n\t\t\t\tfprintf(stderr, \"[W::%s] reset thread-local memory after read %s\\n\", __func__, qname);\n\t\t\tkm_destroy(b->km);\n\t\t\tb->km = km_init();\n\t\t}\n\t}\n}\n\nmm_reg1_t *mm_map(const mm_idx_t *mi, int qlen, const char *seq, int *n_regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *qname)\n{\n\tmm_reg1_t *regs;\n\tmm_map_frag(mi, 1, &qlen, &seq, n_regs, &regs, b, opt, qname);\n\treturn regs;\n}\n\n/**************************\n * Multi-threaded mapping *\n **************************/\n\ntypedef struct {\n\tint n_processed, n_threads, n_fp;\n\tint64_t mini_batch_size;\n\tconst mm_mapopt_t *opt;\n\tmm_bseq_file_t **fp;\n\tconst mm_idx_t *mi;\n\tkstring_t str;\n\n\tint n_parts;\n\tuint32_t *rid_shift;\n\tFILE *fp_split, **fp_parts;\n} pipeline_t;\n\ntypedef struct {\n\tconst pipeline_t *p;\n    int n_seq, n_frag;\n\tmm_bseq1_t *seq;\n\tint *n_reg, *seg_off, *n_seg, *rep_len, *frag_gap;\n\tmm_reg1_t **reg;\n\tmm_tbuf_t **buf;\n} step_t;\n\nstatic void worker_for(void *_data, long i, int tid) // kt_for() callback\n{\n    step_t *s = (step_t*)_data;\n\tint qlens[MM_MAX_SEG], j, off = s->seg_off[i], pe_ori = s->p->opt->pe_ori;\n\tconst char *qseqs[MM_MAX_SEG];\n\tdouble t = 0.0;\n\tmm_tbuf_t *b = s->buf[tid];\n\tassert(s->n_seg[i] <= MM_MAX_SEG);\n\tif (mm_dbg_flag & MM_DBG_PRINT_QNAME) {\n\t\tfprintf(stderr, \"QR\\t%s\\t%d\\t%d\\n\", s->seq[off].name, tid, s->seq[off].l_seq);\n\t\tt = realtime();\n\t}\n\tfor (j = 0; j < s->n_seg[i]; ++j) {\n\t\tif (s->n_seg[i] == 2 && ((j == 0 && (pe_ori>>1&1)) || (j == 1 && (pe_ori&1))))\n\t\t\tmm_revcomp_bseq(&s->seq[off + j]);\n\t\tqlens[j] = s->seq[off + j].l_seq;\n\t\tqseqs[j] = s->seq[off + j].seq;\n\t}\n\tif (s->p->opt->flag & MM_F_INDEPEND_SEG) {\n\t\tfor (j = 0; j < s->n_seg[i]; ++j) {\n\t\t\tmm_map_frag(s->p->mi, 1, &qlens[j], &qseqs[j], &s->n_reg[off+j], &s->reg[off+j], b, s->p->opt, s->seq[off+j].name);\n\t\t\ts->rep_len[off + j] = b->rep_len;\n\t\t\ts->frag_gap[off + j] = b->frag_gap;\n\t\t}\n\t} else {\n\t\tmm_map_frag(s->p->mi, s->n_seg[i], qlens, qseqs, &s->n_reg[off], &s->reg[off], b, s->p->opt, s->seq[off].name);\n\t\tfor (j = 0; j < s->n_seg[i]; ++j) {\n\t\t\ts->rep_len[off + j] = b->rep_len;\n\t\t\ts->frag_gap[off + j] = b->frag_gap;\n\t\t}\n\t}\n\tfor (j = 0; j < s->n_seg[i]; ++j) // flip the query strand and coordinate to the original read strand\n\t\tif (s->n_seg[i] == 2 && ((j == 0 && (pe_ori>>1&1)) || (j == 1 && (pe_ori&1)))) {\n\t\t\tint k, t;\n\t\t\tmm_revcomp_bseq(&s->seq[off + j]);\n\t\t\tfor (k = 0; k < s->n_reg[off + j]; ++k) {\n\t\t\t\tmm_reg1_t *r = &s->reg[off + j][k];\n\t\t\t\tt = r->qs;\n\t\t\t\tr->qs = qlens[j] - r->qe;\n\t\t\t\tr->qe = qlens[j] - t;\n\t\t\t\tr->rev = !r->rev;\n\t\t\t}\n\t\t}\n\tif (mm_dbg_flag & MM_DBG_PRINT_QNAME)\n\t\tfprintf(stderr, \"QT\\t%s\\t%d\\t%.6f\\n\", s->seq[off].name, tid, realtime() - t);\n}\n\nstatic void merge_hits(step_t *s)\n{\n\tint f, i, k0, k, max_seg = 0, *n_reg_part, *rep_len_part, *frag_gap_part, *qlens;\n\tvoid *km;\n\tFILE **fp = s->p->fp_parts;\n\tconst mm_mapopt_t *opt = s->p->opt;\n\n\tkm = km_init();\n\tfor (f = 0; f < s->n_frag; ++f)\n\t\tmax_seg = max_seg > s->n_seg[f]? max_seg : s->n_seg[f];\n\tqlens = CALLOC(int, max_seg + s->p->n_parts * 3);\n\tn_reg_part = qlens + max_seg;\n\trep_len_part = n_reg_part + s->p->n_parts;\n\tfrag_gap_part = rep_len_part + s->p->n_parts;\n\tfor (f = 0, k = k0 = 0; f < s->n_frag; ++f) {\n\t\tk0 = k;\n\t\tfor (i = 0; i < s->n_seg[f]; ++i, ++k) {\n\t\t\tint j, l, t, rep_len = 0;\n\t\t\tqlens[i] = s->seq[k].l_seq;\n\t\t\tfor (j = 0, s->n_reg[k] = 0; j < s->p->n_parts; ++j) {\n\t\t\t\tmm_err_fread(&n_reg_part[j],    sizeof(int), 1, fp[j]);\n\t\t\t\tmm_err_fread(&rep_len_part[j],  sizeof(int), 1, fp[j]);\n\t\t\t\tmm_err_fread(&frag_gap_part[j], sizeof(int), 1, fp[j]);\n\t\t\t\ts->n_reg[k] += n_reg_part[j];\n\t\t\t\tif (rep_len < rep_len_part[j])\n\t\t\t\t\trep_len = rep_len_part[j];\n\t\t\t}\n\t\t\ts->reg[k] = CALLOC(mm_reg1_t, s->n_reg[k]);\n\t\t\tfor (j = 0, l = 0; j < s->p->n_parts; ++j) {\n\t\t\t\tfor (t = 0; t < n_reg_part[j]; ++t, ++l) {\n\t\t\t\t\tmm_reg1_t *r = &s->reg[k][l];\n\t\t\t\t\tuint32_t capacity;\n\t\t\t\t\tmm_err_fread(r, sizeof(mm_reg1_t), 1, fp[j]);\n\t\t\t\t\tr->rid += s->p->rid_shift[j];\n\t\t\t\t\tif (opt->flag & MM_F_CIGAR) {\n\t\t\t\t\t\tmm_err_fread(&capacity, 4, 1, fp[j]);\n\t\t\t\t\t\tr->p = (mm_extra_t*)calloc(capacity, 4);\n\t\t\t\t\t\tr->p->capacity = capacity;\n\t\t\t\t\t\tmm_err_fread(r->p, r->p->capacity, 4, fp[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(opt->flag&MM_F_SR) && s->seq[k].l_seq >= opt->rank_min_len)\n\t\t\t\tmm_update_dp_max(s->seq[k].l_seq, s->n_reg[k], s->reg[k], opt->rank_frac, opt->a, opt->b);\n\t\t\tfor (j = 0; j < s->n_reg[k]; ++j) {\n\t\t\t\tmm_reg1_t *r = &s->reg[k][j];\n\t\t\t\tif (r->p) r->p->dp_max2 = 0; // reset ->dp_max2 as mm_set_parent() doesn't clear it; necessary with mm_update_dp_max()\n\t\t\t\tr->subsc = 0; // this may not be necessary\n\t\t\t\tr->n_sub = 0; // n_sub will be an underestimate as we don't see all the chains now, but it can't be accurate anyway\n\t\t\t}\n\t\t\tmm_hit_sort(km, &s->n_reg[k], s->reg[k], opt->alt_drop);\n\t\t\tmm_set_parent(km, opt->mask_level, opt->mask_len, s->n_reg[k], s->reg[k], opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);\n\t\t\tif (!(opt->flag & MM_F_ALL_CHAINS)) {\n\t\t\t\tmm_select_sub(km, opt->pri_ratio, s->p->mi->k*2, opt->best_n, 0, opt->max_gap * 0.8, &s->n_reg[k], s->reg[k]);\n\t\t\t\tmm_set_sam_pri(s->n_reg[k], s->reg[k]);\n\t\t\t}\n\t\t\tmm_set_mapq(km, s->n_reg[k], s->reg[k], opt->min_chain_score, opt->a, rep_len, !!(opt->flag & MM_F_SR));\n\t\t}\n\t\tif (s->n_seg[f] == 2 && opt->pe_ori >= 0 && (opt->flag&MM_F_CIGAR))\n\t\t\tmm_pair(km, frag_gap_part[0], opt->pe_bonus, opt->a * 2 + opt->b, opt->a, qlens, &s->n_reg[k0], &s->reg[k0]);\n\t}\n\tfree(qlens);\n\tkm_destroy(km);\n}\n\nstatic void *worker_pipeline(void *shared, int step, void *in)\n{\n\tint i, j, k;\n    pipeline_t *p = (pipeline_t*)shared;\n    if (step == 0) { // step 0: read sequences\n\t\tint with_qual = (!!(p->opt->flag & MM_F_OUT_SAM) && !(p->opt->flag & MM_F_NO_QUAL));\n\t\tint with_comment = !!(p->opt->flag & MM_F_COPY_COMMENT);\n\t\tint frag_mode = (p->n_fp > 1 || !!(p->opt->flag & MM_F_FRAG_MODE));\n        step_t *s;\n        s = (step_t*)calloc(1, sizeof(step_t));\n\t\tif (p->n_fp > 1) s->seq = mm_bseq_read_frag2(p->n_fp, p->fp, p->mini_batch_size, with_qual, with_comment, &s->n_seq);\n\t\telse s->seq = mm_bseq_read3(p->fp[0], p->mini_batch_size, with_qual, with_comment, frag_mode, &s->n_seq);\n\t\tif (s->seq) {\n\t\t\ts->p = p;\n\t\t\tfor (i = 0; i < s->n_seq; ++i)\n\t\t\t\ts->seq[i].rid = p->n_processed++;\n\t\t\ts->buf = (mm_tbuf_t**)calloc(p->n_threads, sizeof(mm_tbuf_t*));\n\t\t\tfor (i = 0; i < p->n_threads; ++i)\n\t\t\t\ts->buf[i] = mm_tbuf_init();\n\t\t\ts->n_reg = (int*)calloc(5 * s->n_seq, sizeof(int));\n\t\t\ts->seg_off = s->n_reg + s->n_seq; // seg_off, n_seg, rep_len and frag_gap are allocated together with n_reg\n\t\t\ts->n_seg = s->seg_off + s->n_seq;\n\t\t\ts->rep_len = s->n_seg + s->n_seq;\n\t\t\ts->frag_gap = s->rep_len + s->n_seq;\n\t\t\ts->reg = (mm_reg1_t**)calloc(s->n_seq, sizeof(mm_reg1_t*));\n\t\t\tfor (i = 1, j = 0; i <= s->n_seq; ++i)\n\t\t\t\tif (i == s->n_seq || !frag_mode || !mm_qname_same(s->seq[i-1].name, s->seq[i].name)) {\n\t\t\t\t\ts->n_seg[s->n_frag] = i - j;\n\t\t\t\t\ts->seg_off[s->n_frag++] = j;\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\treturn s;\n\t\t} else free(s);\n    } else if (step == 1) { // step 1: map\n\t\tif (p->n_parts > 0) merge_hits((step_t*)in);\n\t\telse kt_for(p->n_threads, worker_for, in, ((step_t*)in)->n_frag);\n\t\treturn in;\n    } else if (step == 2) { // step 2: output\n\t\tvoid *km = 0;\n        step_t *s = (step_t*)in;\n\t\tconst mm_idx_t *mi = p->mi;\n\t\tfor (i = 0; i < p->n_threads; ++i) mm_tbuf_destroy(s->buf[i]);\n\t\tfree(s->buf);\n\t\tif ((p->opt->flag & MM_F_OUT_CS) && !(mm_dbg_flag & MM_DBG_NO_KALLOC)) km = km_init();\n\t\tfor (k = 0; k < s->n_frag; ++k) {\n\t\t\tint seg_st = s->seg_off[k], seg_en = s->seg_off[k] + s->n_seg[k];\n\t\t\tfor (i = seg_st; i < seg_en; ++i) {\n\t\t\t\tmm_bseq1_t *t = &s->seq[i];\n\t\t\t\tif (p->opt->split_prefix && p->n_parts == 0) { // then write to temporary files\n\t\t\t\t\tmm_err_fwrite(&s->n_reg[i],    sizeof(int), 1, p->fp_split);\n\t\t\t\t\tmm_err_fwrite(&s->rep_len[i],  sizeof(int), 1, p->fp_split);\n\t\t\t\t\tmm_err_fwrite(&s->frag_gap[i], sizeof(int), 1, p->fp_split);\n\t\t\t\t\tfor (j = 0; j < s->n_reg[i]; ++j) {\n\t\t\t\t\t\tmm_reg1_t *r = &s->reg[i][j];\n\t\t\t\t\t\tmm_err_fwrite(r, sizeof(mm_reg1_t), 1, p->fp_split);\n\t\t\t\t\t\tif (p->opt->flag & MM_F_CIGAR) {\n\t\t\t\t\t\t\tmm_err_fwrite(&r->p->capacity, 4, 1, p->fp_split);\n\t\t\t\t\t\t\tmm_err_fwrite(r->p, r->p->capacity, 4, p->fp_split);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (s->n_reg[i] > 0) { // the query has at least one hit\n\t\t\t\t\tfor (j = 0; j < s->n_reg[i]; ++j) {\n\t\t\t\t\t\tmm_reg1_t *r = &s->reg[i][j];\n\t\t\t\t\t\tassert(!r->sam_pri || r->id == r->parent);\n\t\t\t\t\t\tif ((p->opt->flag & MM_F_NO_PRINT_2ND) && r->id != r->parent)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (p->opt->flag & MM_F_OUT_SAM)\n\t\t\t\t\t\t\tmm_write_sam3(&p->str, mi, t, i - seg_st, j, s->n_seg[k], &s->n_reg[seg_st], (const mm_reg1_t*const*)&s->reg[seg_st], km, p->opt->flag, s->rep_len[i]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmm_write_paf3(&p->str, mi, t, r, km, p->opt->flag, s->rep_len[i]);\n\t\t\t\t\t\tmm_err_puts(p->str.s);\n\t\t\t\t\t}\n\t\t\t\t} else if ((p->opt->flag & MM_F_PAF_NO_HIT) || ((p->opt->flag & MM_F_OUT_SAM) && !(p->opt->flag & MM_F_SAM_HIT_ONLY))) { // output an empty hit, if requested\n\t\t\t\t\tif (p->opt->flag & MM_F_OUT_SAM)\n\t\t\t\t\t\tmm_write_sam3(&p->str, mi, t, i - seg_st, -1, s->n_seg[k], &s->n_reg[seg_st], (const mm_reg1_t*const*)&s->reg[seg_st], km, p->opt->flag, s->rep_len[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tmm_write_paf3(&p->str, mi, t, 0, 0, p->opt->flag, s->rep_len[i]);\n\t\t\t\t\tmm_err_puts(p->str.s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = seg_st; i < seg_en; ++i) {\n\t\t\t\tfor (j = 0; j < s->n_reg[i]; ++j) free(s->reg[i][j].p);\n\t\t\t\tfree(s->reg[i]);\n\t\t\t\tfree(s->seq[i].seq); free(s->seq[i].name);\n\t\t\t\tif (s->seq[i].qual) free(s->seq[i].qual);\n\t\t\t\tif (s->seq[i].comment) free(s->seq[i].comment);\n\t\t\t}\n\t\t}\n\t\tfree(s->reg); free(s->n_reg); free(s->seq); // seg_off, n_seg, rep_len and frag_gap were allocated with reg; no memory leak here\n\t\tkm_destroy(km);\n\t\tif (mm_verbose >= 3)\n\t\t\tfprintf(stderr, \"[M::%s::%.3f*%.2f] mapped %d sequences\\n\", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), s->n_seq);\n\t\tfree(s);\n\t}\n    return 0;\n}\n\nstatic mm_bseq_file_t **open_bseqs(int n, const char **fn)\n{\n\tmm_bseq_file_t **fp;\n\tint i, j;\n\tfp = (mm_bseq_file_t**)calloc(n, sizeof(mm_bseq_file_t*));\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((fp[i] = mm_bseq_open(fn[i])) == 0) {\n\t\t\tif (mm_verbose >= 1)\n\t\t\t\tfprintf(stderr, \"ERROR: failed to open file '%s': %s\\n\", fn[i], strerror(errno));\n\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\tmm_bseq_close(fp[j]);\n\t\t\tfree(fp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn fp;\n}\n\nint mm_map_file_frag(const mm_idx_t *idx, int n_segs, const char **fn, const mm_mapopt_t *opt, int n_threads)\n{\n\tint i, pl_threads;\n\tpipeline_t pl;\n\tif (n_segs < 1) return -1;\n\tmemset(&pl, 0, sizeof(pipeline_t));\n\tpl.n_fp = n_segs;\n\tpl.fp = open_bseqs(pl.n_fp, fn);\n\tif (pl.fp == 0) return -1;\n\tpl.opt = opt, pl.mi = idx;\n\tpl.n_threads = n_threads > 1? n_threads : 1;\n\tpl.mini_batch_size = opt->mini_batch_size;\n\tif (opt->split_prefix)\n\t\tpl.fp_split = mm_split_init(opt->split_prefix, idx);\n\tpl_threads = n_threads == 1? 1 : (opt->flag&MM_F_2_IO_THREADS)? 3 : 2;\n\tkt_pipeline(pl_threads, worker_pipeline, &pl, 3);\n\n\tfree(pl.str.s);\n\tif (pl.fp_split) fclose(pl.fp_split);\n\tfor (i = 0; i < pl.n_fp; ++i)\n\t\tmm_bseq_close(pl.fp[i]);\n\tfree(pl.fp);\n\treturn 0;\n}\n\nint mm_map_file(const mm_idx_t *idx, const char *fn, const mm_mapopt_t *opt, int n_threads)\n{\n\treturn mm_map_file_frag(idx, 1, &fn, opt, n_threads);\n}\n\nint mm_split_merge(int n_segs, const char **fn, const mm_mapopt_t *opt, int n_split_idx)\n{\n\tint i;\n\tpipeline_t pl;\n\tmm_idx_t *mi;\n\tif (n_segs < 1 || n_split_idx < 1) return -1;\n\tmemset(&pl, 0, sizeof(pipeline_t));\n\tpl.n_fp = n_segs;\n\tpl.fp = open_bseqs(pl.n_fp, fn);\n\tif (pl.fp == 0) return -1;\n\tpl.opt = opt;\n\tpl.mini_batch_size = opt->mini_batch_size;\n\n\tpl.n_parts = n_split_idx;\n\tpl.fp_parts  = CALLOC(FILE*, pl.n_parts);\n\tpl.rid_shift = CALLOC(uint32_t, pl.n_parts);\n\tpl.mi = mi = mm_split_merge_prep(opt->split_prefix, n_split_idx, pl.fp_parts, pl.rid_shift);\n\tif (pl.mi == 0) {\n\t\tfree(pl.fp_parts);\n\t\tfree(pl.rid_shift);\n\t\treturn -1;\n\t}\n\tfor (i = n_split_idx - 1; i > 0; --i)\n\t\tpl.rid_shift[i] = pl.rid_shift[i - 1];\n\tfor (pl.rid_shift[0] = 0, i = 1; i < n_split_idx; ++i)\n\t\tpl.rid_shift[i] += pl.rid_shift[i - 1];\n\tif (opt->flag & MM_F_OUT_SAM)\n\t\tfor (i = 0; i < (int32_t)pl.mi->n_seq; ++i)\n\t\t\tprintf(\"@SQ\\tSN:%s\\tLN:%d\\n\", pl.mi->seq[i].name, pl.mi->seq[i].len);\n\n\tkt_pipeline(2, worker_pipeline, &pl, 3);\n\n\tfree(pl.str.s);\n\tmm_idx_destroy(mi);\n\tfree(pl.rid_shift);\n\tfor (i = 0; i < n_split_idx; ++i)\n\t\tfclose(pl.fp_parts[i]);\n\tfree(pl.fp_parts);\n\tfor (i = 0; i < pl.n_fp; ++i)\n\t\tmm_bseq_close(pl.fp[i]);\n\tfree(pl.fp);\n\tmm_split_rm_tmp(opt->split_prefix, n_split_idx);\n\treturn 0;\n}\n"
        },
        {
          "name": "minimap.h",
          "type": "blob",
          "size": 14.3017578125,
          "content": "#ifndef MINIMAP2_H\n#define MINIMAP2_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#define MM_VERSION \"2.28-r1221-dirty\"\n\n#define MM_F_NO_DIAG       (0x001LL) // no exact diagonal hit\n#define MM_F_NO_DUAL       (0x002LL) // skip pairs where query name is lexicographically larger than target name\n#define MM_F_CIGAR         (0x004LL)\n#define MM_F_OUT_SAM       (0x008LL)\n#define MM_F_NO_QUAL       (0x010LL)\n#define MM_F_OUT_CG        (0x020LL)\n#define MM_F_OUT_CS        (0x040LL)\n#define MM_F_SPLICE        (0x080LL) // splice mode\n#define MM_F_SPLICE_FOR    (0x100LL) // match GT-AG\n#define MM_F_SPLICE_REV    (0x200LL) // match CT-AC, the reverse complement of GT-AG\n#define MM_F_NO_LJOIN      (0x400LL)\n#define MM_F_OUT_CS_LONG   (0x800LL)\n#define MM_F_SR            (0x1000LL)\n#define MM_F_FRAG_MODE     (0x2000LL)\n#define MM_F_NO_PRINT_2ND  (0x4000LL)\n#define MM_F_2_IO_THREADS  (0x8000LL)\n#define MM_F_LONG_CIGAR    (0x10000LL)\n#define MM_F_INDEPEND_SEG  (0x20000LL)\n#define MM_F_SPLICE_FLANK  (0x40000LL)\n#define MM_F_SOFTCLIP      (0x80000LL)\n#define MM_F_FOR_ONLY      (0x100000LL)\n#define MM_F_REV_ONLY      (0x200000LL)\n#define MM_F_HEAP_SORT     (0x400000LL)\n#define MM_F_ALL_CHAINS    (0x800000LL)\n#define MM_F_OUT_MD        (0x1000000LL)\n#define MM_F_COPY_COMMENT  (0x2000000LL)\n#define MM_F_EQX           (0x4000000LL) // use =/X instead of M\n#define MM_F_PAF_NO_HIT    (0x8000000LL) // output unmapped reads to PAF\n#define MM_F_NO_END_FLT    (0x10000000LL)\n#define MM_F_HARD_MLEVEL   (0x20000000LL)\n#define MM_F_SAM_HIT_ONLY  (0x40000000LL)\n#define MM_F_RMQ           (0x80000000LL)\n#define MM_F_QSTRAND       (0x100000000LL)\n#define MM_F_NO_INV        (0x200000000LL)\n#define MM_F_NO_HASH_NAME  (0x400000000LL)\n#define MM_F_SPLICE_OLD    (0x800000000LL)\n#define MM_F_SECONDARY_SEQ (0x1000000000LL)\t//output SEQ field for seqondary alignments using hard clipping\n#define MM_F_OUT_DS        (0x2000000000LL)\n\n#define MM_I_HPC          0x1\n#define MM_I_NO_SEQ       0x2\n#define MM_I_NO_NAME      0x4\n\n#define MM_IDX_MAGIC   \"MMI\\2\"\n\n#define MM_MAX_SEG       255\n\n#define MM_CIGAR_MATCH      0\n#define MM_CIGAR_INS        1\n#define MM_CIGAR_DEL        2\n#define MM_CIGAR_N_SKIP     3\n#define MM_CIGAR_SOFTCLIP   4\n#define MM_CIGAR_HARDCLIP   5\n#define MM_CIGAR_PADDING    6\n#define MM_CIGAR_EQ_MATCH   7\n#define MM_CIGAR_X_MISMATCH 8\n\n#define MM_CIGAR_STR  \"MIDNSHP=XB\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// emulate 128-bit integers and arrays\ntypedef struct { uint64_t x, y; } mm128_t;\ntypedef struct { size_t n, m; mm128_t *a; } mm128_v;\n\n// minimap2 index\ntypedef struct {\n\tchar *name;      // name of the db sequence\n\tuint64_t offset; // offset in mm_idx_t::S\n\tuint32_t len;    // length\n\tuint32_t is_alt;\n} mm_idx_seq_t;\n\ntypedef struct {\n\tint32_t b, w, k, flag;\n\tuint32_t n_seq;            // number of reference sequences\n\tint32_t index;\n\tint32_t n_alt;\n\tmm_idx_seq_t *seq;         // sequence name, length and offset\n\tuint32_t *S;               // 4-bit packed sequence\n\tstruct mm_idx_bucket_s *B; // index (hidden)\n\tstruct mm_idx_intv_s *I;   // intervals (hidden)\n\tstruct mm_idx_spsc_s *spsc;// splice score (hidden)\n\tvoid *km, *h;\n} mm_idx_t;\n\n// minimap2 alignment\ntypedef struct {\n\tuint32_t capacity;                  // the capacity of cigar[]\n\tint32_t dp_score, dp_max, dp_max2;  // DP score; score of the max-scoring segment; score of the best alternate mappings\n\tint32_t dp_max0;                    // DP score before mm_update_dp_max() adjustment\n\tuint32_t n_ambi:30, trans_strand:2; // number of ambiguous bases; transcript strand: 0 for unknown, 1 for +, 2 for -\n\tuint32_t n_cigar;                   // number of cigar operations in cigar[]\n\tuint32_t cigar[];\n} mm_extra_t;\n\ntypedef struct {\n\tint32_t id;             // ID for internal uses (see also parent below)\n\tint32_t cnt;            // number of minimizers; if on the reverse strand\n\tint32_t rid;            // reference index; if this is an alignment from inversion rescue\n\tint32_t score;          // DP alignment score\n\tint32_t qs, qe, rs, re; // query start and end; reference start and end\n\tint32_t parent, subsc;  // parent==id if primary; best alternate mapping score\n\tint32_t as;             // offset in the a[] array (for internal uses only)\n\tint32_t mlen, blen;     // seeded exact match length; seeded alignment block length\n\tint32_t n_sub;          // number of suboptimal mappings\n\tint32_t score0;         // initial chaining score (before chain merging/spliting)\n\tuint32_t mapq:8, split:2, rev:1, inv:1, sam_pri:1, proper_frag:1, pe_thru:1, seg_split:1, seg_id:8, split_inv:1, is_alt:1, strand_retained:1, dummy:5;\n\tuint32_t hash;\n\tfloat div;\n\tmm_extra_t *p;\n} mm_reg1_t;\n\n// indexing and mapping options\ntypedef struct {\n\tshort k, w, flag, bucket_bits;\n\tint64_t mini_batch_size;\n\tuint64_t batch_size;\n} mm_idxopt_t;\n\ntypedef struct {\n\tint64_t flag;    // see MM_F_* macros\n\tint seed;\n\tint sdust_thres; // score threshold for SDUST; 0 to disable\n\n\tint max_qlen;    // max query length\n\n\tint bw, bw_long; // bandwidth\n\tint max_gap, max_gap_ref; // break a chain if there are no minimizers in a max_gap window\n\tint max_frag_len;\n\tint max_chain_skip, max_chain_iter;\n\tint min_cnt;         // min number of minimizers on each chain\n\tint min_chain_score; // min chaining score\n\tfloat chain_gap_scale;\n\tfloat chain_skip_scale;\n\tint rmq_size_cap, rmq_inner_dist;\n\tint rmq_rescue_size;\n\tfloat rmq_rescue_ratio;\n\n\tfloat mask_level;\n\tint mask_len;\n\tfloat pri_ratio;\n\tint best_n;      // top best_n chains are subjected to DP alignment\n\n\tfloat alt_drop;\n\n\tint a, b, q, e, q2, e2; // matching score, mismatch, gap-open and gap-ext penalties\n\tint transition; // transition mismatch score (A:G, C:T)\n\tint sc_ambi; // score when one or both bases are \"N\"\n\tint noncan;      // cost of non-canonical splicing sites\n\tint junc_bonus, junc_pen;\n\tint zdrop, zdrop_inv;   // break alignment if alignment score drops too fast along the diagonal\n\tint end_bonus;\n\tint min_dp_max;  // drop an alignment if the score of the max scoring segment is below this threshold\n\tint min_ksw_len;\n\tint anchor_ext_len, anchor_ext_shift;\n\tfloat max_clip_ratio; // drop an alignment if BOTH ends are clipped above this ratio\n\n\tint rank_min_len;\n\tfloat rank_frac;\n\n\tint pe_ori, pe_bonus;\n\n\tfloat mid_occ_frac;  // only used by mm_mapopt_update(); see below\n\tfloat q_occ_frac;\n\tint32_t min_mid_occ, max_mid_occ;\n\tint32_t mid_occ;     // ignore seeds with occurrences above this threshold\n\tint32_t max_occ, max_max_occ, occ_dist;\n\tint64_t mini_batch_size; // size of a batch of query bases to process in parallel\n\tint64_t max_sw_mat;\n\tint64_t cap_kalloc;\n\n\tconst char *split_prefix;\n} mm_mapopt_t;\n\n// index reader\ntypedef struct {\n\tint is_idx, n_parts;\n\tint64_t idx_size;\n\tmm_idxopt_t opt;\n\tFILE *fp_out;\n\tunion {\n\t\tstruct mm_bseq_file_s *seq;\n\t\tFILE *idx;\n\t} fp;\n} mm_idx_reader_t;\n\n// memory buffer for thread-local storage during mapping\nstruct mm_tbuf_s {\n\tvoid *km;\n\tint rep_len, frag_gap;\n};\n\ntypedef struct mm_tbuf_s mm_tbuf_t;\n\n// global variables\nextern int mm_verbose, mm_dbg_flag; // verbose level: 0 for no info, 1 for error, 2 for warning, 3 for message (default); debugging flag\nextern double mm_realtime0; // wall-clock timer\n\n/**\n * Set default or preset parameters\n *\n * @param preset     NULL to set all parameters as default; otherwise apply preset to affected parameters\n * @param io         pointer to indexing parameters\n * @param mo         pointer to mapping parameters\n *\n * @return 0 if success; -1 if _present_ unknown\n */\nint mm_set_opt(const char *preset, mm_idxopt_t *io, mm_mapopt_t *mo);\nint mm_check_opt(const mm_idxopt_t *io, const mm_mapopt_t *mo);\n\n/**\n * Update mm_mapopt_t::mid_occ via mm_mapopt_t::mid_occ_frac\n *\n * If mm_mapopt_t::mid_occ is 0, this function sets it to a number such that no\n * more than mm_mapopt_t::mid_occ_frac of minimizers in the index have a higher\n * occurrence.\n *\n * @param opt        mapping parameters\n * @param mi         minimap2 index\n */\nvoid mm_mapopt_update(mm_mapopt_t *opt, const mm_idx_t *mi);\n\nvoid mm_mapopt_max_intron_len(mm_mapopt_t *opt, int max_intron_len);\n\n/**\n * Initialize an index reader\n *\n * @param fn         index or fasta/fastq file name (this function tests the file type)\n * @param opt        indexing parameters\n * @param fn_out     if not NULL, write built index to this file\n *\n * @return an index reader on success; NULL if fail to open _fn_\n */\nmm_idx_reader_t *mm_idx_reader_open(const char *fn, const mm_idxopt_t *opt, const char *fn_out);\n\n/**\n * Read/build an index\n *\n * If the input file is an index file, this function reads one part of the\n * index and returns. If the input file is a sequence file (fasta or fastq),\n * this function constructs the index for about mm_idxopt_t::batch_size bases.\n * Importantly, for a huge collection of sequences, this function may only\n * return an index for part of sequences. It needs to be repeatedly called\n * to traverse the entire index/sequence file.\n *\n * @param r          index reader\n * @param n_threads  number of threads for constructing index\n *\n * @return an index on success; NULL if reaching the end of the input file\n */\nmm_idx_t *mm_idx_reader_read(mm_idx_reader_t *r, int n_threads);\n\n/**\n * Destroy/deallocate an index reader\n *\n * @param r          index reader\n */\nvoid mm_idx_reader_close(mm_idx_reader_t *r);\n\nint mm_idx_reader_eof(const mm_idx_reader_t *r);\n\n/**\n * Check whether the file contains a minimap2 index\n *\n * @param fn         file name\n *\n * @return the file size if fn is an index file; 0 if fn is not.\n */\nint64_t mm_idx_is_idx(const char *fn);\n\n/**\n * Load a part of an index\n *\n * Given a uni-part index, this function loads the entire index into memory.\n * Given a multi-part index, it loads one part only and places the file pointer\n * at the end of that part.\n *\n * @param fp         pointer to FILE object\n *\n * @return minimap2 index read from fp\n */\nmm_idx_t *mm_idx_load(FILE *fp);\n\n/**\n * Append an index (or one part of a full index) to file\n *\n * @param fp         pointer to FILE object\n * @param mi         minimap2 index\n */\nvoid mm_idx_dump(FILE *fp, const mm_idx_t *mi);\n\n/**\n * Create an index from strings in memory\n *\n * @param w            minimizer window size\n * @param k            minimizer k-mer size\n * @param is_hpc       use HPC k-mer if true\n * @param bucket_bits  number of bits for the first level of the hash table\n * @param n            number of sequences\n * @param seq          sequences in A/C/G/T\n * @param name         sequence names; could be NULL\n *\n * @return minimap2 index\n */\nmm_idx_t *mm_idx_str(int w, int k, int is_hpc, int bucket_bits, int n, const char **seq, const char **name);\n\n/**\n * Print index statistics to stderr\n *\n * @param mi         minimap2 index\n */\nvoid mm_idx_stat(const mm_idx_t *idx);\n\n/**\n * Destroy/deallocate an index\n *\n * @param r          minimap2 index\n */\nvoid mm_idx_destroy(mm_idx_t *mi);\n\n/**\n * Initialize a thread-local buffer for mapping\n *\n * Each mapping thread requires a buffer specific to the thread (see mm_map()\n * below). The primary purpose of this buffer is to reduce frequent heap\n * allocations across threads. A buffer shall not be used by two or more\n * threads.\n *\n * @return pointer to a thread-local buffer\n */\nmm_tbuf_t *mm_tbuf_init(void);\n\n/**\n * Destroy/deallocate a thread-local buffer for mapping\n *\n * @param b          the buffer\n */\nvoid mm_tbuf_destroy(mm_tbuf_t *b);\n\nvoid *mm_tbuf_get_km(mm_tbuf_t *b);\n\n/**\n * Align a query sequence against an index\n *\n * This function possibly finds multiple alignments of the query sequence.\n * The returned array and the mm_reg1_t::p field of each element are allocated\n * with malloc().\n *\n * @param mi         minimap2 index\n * @param l_seq      length of the query sequence\n * @param seq        the query sequence\n * @param n_regs     number of hits (out)\n * @param b          thread-local buffer; two mm_map() calls shall not use one buffer at the same time!\n * @param opt        mapping parameters\n * @param name       query name, used for all-vs-all overlapping and debugging\n *\n * @return an array of hits which need to be deallocated with free() together\n *         with mm_reg1_t::p of each element. The size is written to _n_regs_.\n */\nmm_reg1_t *mm_map(const mm_idx_t *mi, int l_seq, const char *seq, int *n_regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *name);\n\nvoid mm_map_frag(const mm_idx_t *mi, int n_segs, const int *qlens, const char **seqs, int *n_regs, mm_reg1_t **regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *qname);\n\n/**\n * Align a fasta/fastq file and print alignments to stdout\n *\n * @param idx        minimap2 index\n * @param fn         fasta/fastq file name\n * @param opt        mapping parameters\n * @param n_threads  number of threads\n *\n * @return 0 on success; -1 if _fn_ can't be read\n */\nint mm_map_file(const mm_idx_t *idx, const char *fn, const mm_mapopt_t *opt, int n_threads);\n\nint mm_map_file_frag(const mm_idx_t *idx, int n_segs, const char **fn, const mm_mapopt_t *opt, int n_threads);\n\n/**\n * Generate the cs tag (new in 2.12)\n *\n * @param km         memory blocks; set to NULL if unsure\n * @param buf        buffer to write the cs/MD tag; typicall NULL on the first call\n * @param max_len    max length of the buffer; typically set to 0 on the first call\n * @param mi         index\n * @param r          alignment\n * @param seq        query sequence\n * @param no_iden    true to use : instead of =\n *\n * @return the length of cs\n */\nint mm_gen_cs(void *km, char **buf, int *max_len, const mm_idx_t *mi, const mm_reg1_t *r, const char *seq, int no_iden);\nint mm_gen_MD(void *km, char **buf, int *max_len, const mm_idx_t *mi, const mm_reg1_t *r, const char *seq);\n\n// query sequence name and sequence in the minimap2 index\nint mm_idx_index_name(mm_idx_t *mi);\nint mm_idx_name2id(const mm_idx_t *mi, const char *name);\nint mm_idx_getseq(const mm_idx_t *mi, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq);\n\nint mm_idx_alt_read(mm_idx_t *mi, const char *fn);\nint mm_idx_bed_read(mm_idx_t *mi, const char *fn, int read_junc);\nint mm_idx_bed_junc(const mm_idx_t *mi, int32_t ctg, int32_t st, int32_t en, uint8_t *s);\n\nint mm_max_spsc_bonus(const mm_mapopt_t *mo);\nint32_t mm_idx_spsc_read(mm_idx_t *idx, const char *fn, int32_t max_sc);\nint64_t mm_idx_spsc_get(const mm_idx_t *db, int32_t cid, int64_t st0, int64_t en0, int32_t rev, uint8_t *sc);\n\n// deprecated APIs for backward compatibility\nvoid mm_mapopt_init(mm_mapopt_t *opt);\nmm_idx_t *mm_idx_build(const char *fn, int w, int k, int flag, int n_threads);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // MINIMAP2_H\n"
        },
        {
          "name": "minimap2.1",
          "type": "blob",
          "size": 21.2529296875,
          "content": ".TH minimap2 1 \"12 March 2024\" \"minimap2-2.28 (r1209)\" \"Bioinformatics tools\"\n.SH NAME\n.PP\nminimap2 - mapping and alignment between collections of DNA sequences\n.SH SYNOPSIS\n* Indexing the target sequences (optional):\n.RS 4\nminimap2\n.RB [ -x\n.IR preset ]\n.B -d\n.I target.mmi\n.I target.fa\n.br\nminimap2\n.RB [ -H ]\n.RB [ -k\n.IR kmer ]\n.RB [ -w\n.IR miniWinSize ]\n.RB [ -I\n.IR batchSize ]\n.B -d\n.I target.mmi\n.I target.fa\n.RE\n\n* Long-read alignment with CIGAR:\n.RS 4\nminimap2\n.B -a\n.RB [ -x\n.IR preset ]\n.I target.mmi\n.I query.fa\n>\n.I output.sam\n.br\nminimap2\n.B -c\n.RB [ -H ]\n.RB [ -k\n.IR kmer ]\n.RB [ -w\n.IR miniWinSize ]\n.RB [ ... ]\n.I target.fa\n.I query.fa\n>\n.I output.paf\n.RE\n\n* Long-read overlap without CIGAR:\n.RS 4\nminimap2\n.B -x\nava-ont\n.RB [ -t\n.IR nThreads ]\n.I target.fa\n.I query.fa\n>\n.I output.paf\n.RE\n.SH DESCRIPTION\n.PP\nMinimap2 is a fast sequence mapping and alignment program that can find\noverlaps between long noisy reads, or map long reads or their assemblies to a\nreference genome optionally with detailed alignment (i.e. CIGAR). At present,\nit works efficiently with query sequences from a few kilobases to ~100\nmegabases in length at a error rate ~15%. Minimap2 outputs in the PAF or the\nSAM format.\n.SH OPTIONS\n.SS Indexing options\n.TP 10\n.BI -k \\ INT\nMinimizer k-mer length [15]\n.TP\n.BI -w \\ INT\nMinimizer window size [10]. A minimizer is the smallest k-mer\nin a window of w consecutive k-mers.\n.TP\n.BI -j \\ INT\nSyncmer submer size [10]. Option\n.B -j\nand\n.B -w\nwill override each: if\n.B -w\nis applied after\n.BR -j ,\n.B -j\nwill have no effect, and vice versa.\n\n.TP\n.B -H\nUse homopolymer-compressed (HPC) minimizers. An HPC sequence is constructed by\ncontracting homopolymer runs to a single base. An HPC minimizer is a minimizer\non the HPC sequence.\n.TP\n.BI -I \\ NUM\nLoad at most\n.I NUM\ntarget bases into RAM for indexing [8G]. If there are more than\n.I NUM\nbases in\n.IR target.fa ,\nminimap2 needs to read\n.I query.fa\nmultiple times to map it against each batch of target sequences. This would create a multi-part index.\n.I NUM\nmay be ending with k/K/m/M/g/G. NB: mapping quality is incorrect given a\nmulti-part index. See also option\n.BR --split-prefix .\n.TP\n.B --idx-no-seq\nDon't store target sequences in the index. It saves disk space and memory but\nthe index generated with this option will not work with\n.B -a\nor\n.BR -c .\nWhen base-level alignment is not requested, this option is automatically applied.\n.TP\n.BI -d \\ FILE\nSave the minimizer index of\n.I target.fa\nto\n.I FILE\n[no dump]. Minimap2 indexing is fast. It can index the human genome in a couple\nof minutes. If even shorter startup time is desired, use this option to save\nthe index. Indexing options are fixed in the index file. When an index file is\nprovided as the target sequences, options\n.BR -H ,\n.BR -k ,\n.BR -w ,\n.B -I\nwill be effectively overridden by the options stored in the index file.\n.TP\n.BI --alt \\ FILE\nList of ALT contigs [null]\n.TP\n.BI --alt-drop \\ FLOAT\nDrop ALT hits by\n.I FLOAT\nfraction when ranking and computing mapping quality [0.15]\n.SS Mapping options\n.TP 10\n.BI -f \\ FLOAT | INT1 [, INT2 ]\nIf fraction, ignore top\n.I FLOAT\nfraction of most frequent minimizers [0.0002]. If integer,\nignore minimizers occuring more than\n.I INT1\ntimes.\n.I INT2\nis only effective in the\n.B --sr\nor\n.B -xsr\nmode, which sets the threshold for a second round of seeding.\n.TP\n.BI -U \\ INT1 [, INT2 ]\nLower and upper bounds of k-mer occurrences [10,1000000]. The final k-mer occurrence threshold is\n.RI max{ INT1 ,\\ min{ INT2 ,\n.BR -f }}.\nThis option prevents excessively small or large\n.B -f\nestimated from the input reference. Available since r1034 and deprecating\n.B --min-occ-floor\nin earlier versions of minimap2.\n.TP\n.BI --q-occ-frac \\ FLOAT\nDiscard a query minimizer if its occurrence is higher than\n.I FLOAT\nfraction of query minimizers and than the reference occurrence threshold\n[0.01]. Set 0 to disable. Available since r1105.\n.TP\n.BI -e \\ INT\nSample a high-frequency minimizer every\n.I INT\nbasepairs [500].\n.TP\n.BI -g \\ NUM\nStop chain enlongation if there are no minimizers within\n.IR NUM -bp\n[10k].\n.TP\n.BI -r \\ NUM1 [, NUM2 ]\nBandwidth for chaining and base alignment [500,20k].\n.I NUM1\nis used for initial chaining and alignment extension;\n.I NUM2\nfor RMQ-based re-chaining and closing gaps in alignments.\n.TP\n.BI -n \\ INT\nDiscard chains consisting of\n.RI < INT\nnumber of minimizers [3]\n.TP\n.BI -m \\ INT\nDiscard chains with chaining score\n.RI < INT\n[40]. Chaining score equals the approximate number of matching bases minus a\nconcave gap penalty. It is computed with dynamic programming.\n.TP\n.B -D\nIf query sequence name/length are identical to the target name/length, ignore\ndiagonal anchors. This option also reduces DP-based extension along the\ndiagonal.\n.TP\n.B -P\nRetain all chains and don't attempt to set primary chains. Options\n.B -p\nand\n.B -N\nhave no effect when this option is in use.\n.TP\n.BR --dual = yes | no\nIf\n.BR no ,\nskip query-target pairs wherein the query name is lexicographically greater\nthan the target name [yes]\n.TP\n.B -X\nEquivalent to\n.RB ' -DP\n.BR --dual = no\n.BR --no-long-join '.\nPrimarily used for all-vs-all read overlapping.\n.TP\n.BI -p \\ FLOAT\nMinimal secondary-to-primary score ratio to output secondary mappings [0.8].\nBetween two chains overlaping over half of the shorter chain (controlled by\n.BR -M ),\nthe chain with a lower score is secondary to the chain with a higher score.\nIf the ratio of the scores is below\n.IR FLOAT ,\nthe secondary chain will not be outputted or extended with DP alignment later.\nThis option has no effect when\n.B -X\nis applied.\n.TP\n.BI -N \\ INT\nOutput at most\n.I INT\nsecondary alignments [5]. This option has no effect when\n.B -X\nis applied.\n.TP\n.BI -G \\ NUM\nMaximum gap on the reference (effective with\n.BR -xsplice / --splice ).\nThis option also changes the chaining and alignment band width to\n.IR NUM .\nIncreasing this option slows down spliced alignment. [200k]\n.TP\n.BI -F \\ NUM\nMaximum fragment length (aka insert size; effective with\n.BR -xsr / --frag = yes )\n[800]\n.TP\n.BI -M \\ FLOAT\nMark as secondary a chain that overlaps with a better chain by\n.I FLOAT\nor more of the shorter chain [0.5]\n.TP\n.BR --rmq = no | yes\nUse the minigraph chaining algorithm [no]. The minigraph algorithm is better\nfor aligning contigs through long INDELs.\n.TP\n.BI --rmq-inner \\ NUM\nApply full dynamic programming for anchors within distance\n.I NUM\n[1000].\n.TP\n.B --hard-mask-level\nHonor option\n.B -M\nand disable a heurstic to save unmapped subsequences and disables\n.BR --mask-len .\n.TP\n.BI --mask-len \\ NUM\nKeep an alignment if dropping it leaves an unaligned region on query longer than\n.IR INT\n[inf]. Effective without\n.BR --hard-mask-level .\n.TP\n.BI --max-chain-skip \\ INT\nA heuristics that stops chaining early [25]. Minimap2 uses dynamic programming\nfor chaining. The time complexity is quadratic in the number of seeds. This\noption makes minimap2 exits the inner loop if it repeatedly sees seeds already\non chains. Set\n.I INT\nto a large number to switch off this heurstics.\n.TP\n.BI --max-chain-iter \\ INT\nCheck up to\n.I INT\npartial chains during chaining [5000]. This is a heuristic to avoid quadratic\ntime complexity in the worst case.\n.TP\n.BI --chain-gap-scale \\ FLOAT\nScale of gap cost during chaining [1.0]\n.TP\n.B --no-long-join\nDisable the long gap patching heuristic. When this option is applied, the\nmaximum alignment gap is mostly controlled by\n.BR -r .\n.TP\n.B --splice\nEnable the splice alignment mode.\n.TP\n.B --sr\nEnable short-read alignment heuristics. In the short-read mode, minimap2\napplies a second round of chaining with a higher minimizer occurrence threshold\nif no good chain is found. In addition, minimap2 attempts to patch gaps between\nseeds with ungapped alignment.\n.TP\n.BI --split-prefix \\ STR\nPrefix to create temporary files. Typically used for a multi-part index.\n.TP\n.BR --frag = no | yes\nWhether to enable the fragment mode [no]\n.TP\n.B --for-only\nOnly map to the forward strand of the reference sequences. For paired-end\nreads in the forward-reverse orientation, the first read is mapped to forward\nstrand of the reference and the second read to the reverse stand.\n.TP\n.B --rev-only\nOnly map to the reverse complement strand of the reference sequences.\n.TP\n.BR --heap-sort = no | yes\nIf yes, sort anchors with heap merge, instead of radix sort. Heap merge is\nfaster for short reads, but slower for long reads. [no]\n.TP\n.B --no-pairing\nTreat two reads in a pair as independent reads. The mate related fields in SAM\nare still properly populated.\n.TP\n.B --no-hash-name\nProduce the same alignment for identical sequences regardless of their sequence names.\n.SS Alignment options\n.TP 10\n.BI -A \\ INT\nMatching score [2]\n.TP\n.BI -B \\ INT\nMismatching penalty [4]\n.TP\n.BI -b \\ INT\nMismatching penalty for transitions [same as\n.BR -B ].\n.TP\n.BI -O \\ INT1[,INT2]\nGap open penalty [4,24]. If\n.I INT2\nis not specified, it is set to\n.IR INT1 .\n.TP\n.BI -E \\ INT1[,INT2]\nGap extension penalty [2,1]. A gap of length\n.I k\ncosts\n.RI min{ O1 + k * E1 , O2 + k * E2 }.\nIn the splice mode, the second gap penalties are not used.\n.TP\n.BI -J \\ INT\nSplice model [1]. 0 for the original minimap2 splice model that always penalizes non-GT-AG splicing;\n1 for the miniprot model that considers non-GT-AG. Option\n.B -C\nhas no effect with the default\n.BR -J1 .\n.BR -J0 .\n.TP\n.BI -C \\ INT\nCost for a non-canonical GT-AG splicing (effective with\n.B --splice\n.BR -J0 )\n[0].\n.TP\n.BI -z \\ INT1[,INT2]\nTruncate an alignment if the running alignment score drops too quickly along\nthe diagonal of the DP matrix (diagonal X-drop, or Z-drop) [400,200]. If the\ndrop of score is above\n.IR INT2 ,\nminimap2 will reverse complement the query in the related region and align\nagain to test small inversions. Minimap2 truncates alignment if there is an\ninversion or the drop of score is greater than\n.IR INT1 .\nDecrease\n.I INT2\nto find small inversions at the cost of performance and false positives.\nIncrease\n.I INT1\nto improves the contiguity of alignment at the cost of poor alignment in the\nmiddle.\n.TP\n.BI -s \\ INT\nMinimal peak DP alignment score to output [40]. The peak score is computed from\nthe final CIGAR. It is the score of the max scoring segment in the alignment\nand may be different from the total alignment score.\n.TP\n.BI -u \\ CHAR\nHow to find canonical splicing sites GT-AG -\n.BR f :\ntranscript strand;\n.BR b :\nboth strands;\n.BR n :\nno attempt to match GT-AG [n]\n.TP\n.BI --end-bonus \\ INT\nScore bonus when alignment extends to the end of the query sequence [0].\n.TP\n.BI --score-N \\ INT\nScore of a mismatch involving ambiguous bases [1].\n.TP\n.BR --splice-flank = yes | no\nAssume the next base to a\n.B GT\ndonor site tends to be A/G (91% in human and 92% in mouse) and the preceding\nbase to a\n.B AG\nacceptor tends to be C/T [no].\nThis trend is evolutionarily conservative, all the way to S. cerevisiae\n(PMID:18688272). Specifying this option generally leads to higher junction\naccuracy by several percents, so it is applied by default with\n.BR --splice .\nHowever, the SIRV control does not honor this trend\n(only ~60%). This option reduces accuracy. If you are benchmarking minimap2\non SIRV data, please add\n.B --splice-flank=no\nto the command line.\n.TP\n.BR --spsc \\ FILE\nSplice scores []. Each line consists of five fields: 1) contig, 2) offset, 3) `+' or `-', 4) `D' or `A', and 5) score,\nwhere offset is the number of bases before a splice junction, `D' indicates the\nline corresponds to a donor site and `A' for an acceptor site.\nA positive score suggests the junction is preferred and a negative score\nsuggests the junction is not preferred.\n.TP\n.BR --junc-pen \\ INT\nPenalty for a position not in FILE specified by\n.B --spsc\n[5]. Effective with\n.B --spsc\nbut not\n.BR --junc-bed .\n.TP\n.BR --junc-bed \\ FILE\nGene annotations in the BED12 format (aka 12-column BED), or intron positions\nin 5-column BED. With this option, minimap2 prefers splicing in annotations.\nBED12 file can be converted from GTF/GFF3 with `paftools.js gff2bed anno.gtf'\n[].\n.TP\n.BR --junc-bonus \\ INT\nScore bonus for a splice donor or acceptor found in annotation [9]. Effective with\n.B --junc-bed\nbut not\n.BR --spsc .\n.TP\n.BI --end-seed-pen \\ INT\nDrop a terminal anchor if\n.IR s <log( g )+ INT ,\nwhere\n.I s\nis the local alignment score around the anchor and\n.I g\nthe length of the terminal gap in the chain. This option is only effective\nwith\n.BR --splice .\nIt helps to avoid tiny terminal exons. [6]\n.TP\n.B --no-end-flt\nDon't filter seeds towards the ends of chains before performing base-level\nalignment.\n.TP\n.BI --cap-sw-mem \\ NUM\nSkip alignment if the DP matrix size is above\n.IR NUM .\nSet 0 to disable [100m].\n.TP\n.BI --cap-kalloc \\ NUM\nFree thread-local kalloc memory reservoir if after the alignment the size of the reservoir above\n.IR NUM .\nSet 0 to disable [500m].\n.SS Input/output options\n.TP 10\n.B -a\nGenerate CIGAR and output alignments in the SAM format. Minimap2 outputs in PAF\nby default.\n.TP\n.BI -o \\ FILE\nOutput alignments to\n.I FILE\n[stdout].\n.TP\n.B -Q\nIgnore base quality in the input file.\n.TP\n.B -L\nWrite CIGAR with >65535 operators at the CG tag. Older tools are unable to\nconvert alignments with >65535 CIGAR ops to BAM. This option makes minimap2 SAM\ncompatible with older tools. Newer tools recognizes this tag and reconstruct\nthe real CIGAR in memory.\n.TP\n.BI -R \\ STR\nSAM read group line in a format like\n.B @RG\\\\\\\\tID:foo\\\\\\\\tSM:bar\n[].\n.TP\n.B -y\nCopy input FASTA/Q comments to output.\n.TP\n.B -c\nGenerate CIGAR. In PAF, the CIGAR is written to the `cg' custom tag.\n.TP\n.BI --cs[= STR ]\nOutput the\n.B cs\ntag.\n.I STR\ncan be either\n.I short\nor\n.IR long .\nIf no\n.I STR\nis given,\n.I short\nis assumed. [none]\n.TP\n.B --MD\nOutput the MD tag (see the SAM spec).\n.TP\n.B --eqx\nOutput =/X CIGAR operators for sequence match/mismatch.\n.TP\n.B -Y\nIn SAM output, use soft clipping for supplementary alignments.\n.TP\n.B --secondary-seq\nIn SAM output, show query sequences for secondary alignments.\n.TP\n.BI --seed \\ INT\nInteger seed for randomizing equally best hits. Minimap2 hashes\n.I INT\nand read name when choosing between equally best hits. [11]\n.TP\n.BI -t \\ INT\nNumber of threads [3]. Minimap2 uses at most three threads when indexing target\nsequences, and uses up to\n.IR INT +1\nthreads when mapping (the extra thread is for I/O, which is frequently idle and\ntakes little CPU time).\n.TP\n.B -2\nUse two I/O threads during mapping. By default, minimap2 uses one I/O thread.\nWhen I/O is slow (e.g. piping to gzip, or reading from a slow pipe), the I/O\nthread may become the bottleneck. Apply this option to use one thread for input\nand another thread for output, at the cost of increased peak RAM.\n.TP\n.BI -K \\ NUM\nNumber of bases loaded into memory to process in a mini-batch [500M].\nSimilar to option\n.BR -I ,\nK/M/G/k/m/g suffix is accepted. A large\n.I NUM\nhelps load balancing in the multi-threading mode, at the cost of increased\nmemory.\n.TP\n.BR --secondary = yes | no\nWhether to output secondary alignments [yes]\n.TP\n.BI --max-qlen \\ NUM\nFilter out query sequences longer than\n.IR NUM .\n.TP\n.B --paf-no-hit\nIn PAF, output unmapped queries; the strand and the reference name fields are\nset to `*'. Warning: some paftools.js commands may not work with such output\nfor the moment.\n.TP\n.B --sam-hit-only\nIn SAM, don't output unmapped reads.\n.TP\n.B --version\nPrint version number to stdout\n.SS Preset options\n.TP 10\n.BI -x \\ STR\nPreset []. This option applies multiple options at the same time. It should be\napplied before other options because options applied later will overwrite the\nvalues set by\n.BR -x .\nAvailable\n.I STR\nare:\n.RS\n.TP 10\n.B map-ont\nAlign noisy long reads of ~10% error rate to a reference genome. This is the\ndefault mode.\n.TP\n.B lr:hq\nAlign accurate long reads (error rate <1%) to a reference genome\n.RB ( -k19\n.B -w19 -U50,500\n.BR -g10k ).\nThis was recommended by ONT developers for recent Nanopore reads\nproduced with chemistry v14 that can reach ~99% in accuracy.\nIt was shown to work better for accurate Nanopore reads\nthan\n.BR map-hifi .\n.TP\n.B map-hifi\nAlign PacBio high-fidelity (HiFi) reads to a reference genome\n.RB ( -xlr:hq\n.B -A1 -B4 -O6,26 -E2,1\n.BR -s200 ).\nIt differs from\n.B lr:hq\nonly in scoring. It has not been tested whether\n.B lr:hq\nwould work better for PacBio HiFi reads.\n.TP\n.B map-pb\nAlign older PacBio continuous long (CLR) reads to a reference genome\n.RB ( -Hk19 ).\nNote that this data type is effectively deprecated by HiFi.\nUnless you work on very old data, you probably want to use\n.B map-hifi\nor\n.BR lr:hq .\n.TP\n.B map-iclr\nAlign Illumina Complete Long Reads (ICLR) to a reference genome\n.RB ( -k19\n.B -B6 -b4\n.BR -O10,50 ).\nThis was recommended by Illumina developers.\n.TP\n.B asm5\nLong assembly to reference mapping\n.RB ( -k19\n.B -w19 -U50,500 --rmq -r1k,100k -g10k -A1 -B19 -O39,81 -E3,1 -s200 -z200\n.BR -N50 ).\nTypically, the alignment will not extend to regions with 5% or higher sequence\ndivergence. Use this preset if the average divergence is not much higher than 0.1%.\n.TP\n.B asm10\nLong assembly to reference mapping\n.RB ( -k19\n.B -w19 -U50,500 --rmq -r1k,100k -g10k -A1 -B9 -O16,41 -E2,1 -s200 -z200\n.BR -N50 ).\nUse this if the average divergence is around 1%.\n.TP\n.B asm20\nLong assembly to reference mapping\n.RB ( -k19\n.B -w10 -U50,500 --rmq -r1k,100k -g10k -A1 -B4 -O6,26 -E2,1 -s200 -z200\n.BR -N50 ).\nUse this if the average divergence is around several percent.\n.TP\n.B splice\nLong-read spliced alignment\n.RB ( -k15\n.B -w5 --splice -g2k -G200k -A1 -B2 -O2,32 -E1,0 -C9 -z200 -ub --junc-bonus=9 --cap-sw-mem=0\n.BR --splice-flank=yes ).\nIn the splice mode, 1) long deletions are taken as introns and represented as\nthe\n.RB ` N '\nCIGAR operator; 2) long insertions are disabled; 3) deletion and insertion gap\ncosts are different during chaining; 4) the computation of the\n.RB ` ms '\ntag ignores introns to demote hits to pseudogenes.\n.TP\n.B splice:hq\nSpliced alignment for accurate long RNA-seq reads such as PacBio iso-seq\n.RB ( -xsplice\n.B -C5 -O6,24\n.BR -B4 ).\n.TP\n.B sr\nShort-read alignment without splicing\n.RB ( -k21\n.B -w11 --sr --frag=yes -A2 -B8 -O12,32 -E2,1 -b0 -r100 -p.5 -N20 -f1000,5000 -n2 -m25\n.B -s40 -g100 -2K50m --heap-sort=yes\n.BR --secondary=no ).\n.TP\n.B ava-pb\nPacBio CLR all-vs-all overlap mapping\n.RB ( -Hk19\n.B -Xw5 -e0\n.BR -m100 ).\n.TP\n.B ava-ont\nOxford Nanopore all-vs-all overlap mapping\n.RB ( -k15\n.B -Xw5 -e0 -m100\n.BR -r2k ).\n.RE\n.SS Miscellaneous options\n.TP 10\n.B --no-kalloc\nUse the libc default allocator instead of the kalloc thread-local allocator.\nThis debugging option is mostly used with Valgrind to detect invalid memory\naccesses. Minimap2 runs slower with this option, especially in the\nmulti-threading mode.\n.TP\n.B --print-qname\nPrint query names to stderr, mostly to see which query is crashing minimap2.\n.TP\n.B --print-seeds\nPrint seed positions to stderr, for debugging only.\n.SH OUTPUT FORMAT\n.PP\nMinimap2 outputs mapping positions in the Pairwise mApping Format (PAF) by\ndefault. PAF is a TAB-delimited text format with each line consisting of at\nleast 12 fields as are described in the following table:\n.TS\ncenter box;\ncb | cb | cb\nr | c | l .\nCol\tType\tDescription\n_\n1\tstring\tQuery sequence name\n2\tint\tQuery sequence length\n3\tint\tQuery start coordinate (0-based)\n4\tint\tQuery end coordinate (0-based)\n5\tchar\t`+' if query/target on the same strand; `-' if opposite\n6\tstring\tTarget sequence name\n7\tint\tTarget sequence length\n8\tint\tTarget start coordinate on the original strand\n9\tint\tTarget end coordinate on the original strand\n10\tint\tNumber of matching bases in the mapping\n11\tint\tNumber bases, including gaps, in the mapping\n12\tint\tMapping quality (0-255 with 255 for missing)\n.TE\n\n.PP\nWhen alignment is available, column 11 gives the total number of sequence\nmatches, mismatches and gaps in the alignment; column 10 divided by column 11\ngives the BLAST-like alignment identity. When alignment is unavailable,\nthese two columns are approximate. PAF may optionally have additional fields in\nthe SAM-like typed key-value format. Minimap2 may output the following tags:\n.TS\ncenter box;\ncb | cb | cb\nr | c | l .\nTag\tType\tDescription\n_\ntp\tA\tType of aln: P/primary, S/secondary and I,i/inversion\ncm\ti\tNumber of minimizers on the chain\ns1\ti\tChaining score\ns2\ti\tChaining score of the best secondary chain\nNM\ti\tTotal number of mismatches and gaps in the alignment\nMD\tZ\tTo generate the ref sequence in the alignment\nAS\ti\tDP alignment score\nSA\tZ\tList of other supplementary alignments (with approximate CIGAR strings)\nms\ti\tDP score of the max scoring segment in the alignment\nnn\ti\tNumber of ambiguous bases in the alignment\nts\tA\tTranscript strand (splice mode only)\ncg\tZ\tCIGAR string (only in PAF)\ncs\tZ\tDifference string\ndv\tf\tApproximate per-base sequence divergence\nde\tf\tGap-compressed per-base sequence divergence\nrl\ti\tLength of query regions harboring repetitive seeds\n.TE\n\n.PP\nThe\n.B cs\ntag encodes difference sequences in the short form or the entire query\n.I AND\nreference sequences in the long form. It consists of a series of operations:\n.TS\ncenter box;\ncb | cb |cb\nr | l | l .\nOp\tRegex\tDescription\n_\n =\t[ACGTN]+\tIdentical sequence (long form)\n :\t[0-9]+\tIdentical sequence length\n *\t[acgtn][acgtn]\tSubstitution: ref to query\n +\t[acgtn]+\tInsertion to the reference\n -\t[acgtn]+\tDeletion from the reference\n ~\t[acgtn]{2}[0-9]+[acgtn]{2}\tIntron length and splice signal\n.TE\n\n.SH LIMITATIONS\n.TP 2\n*\nMinimap2 may produce suboptimal alignments through long low-complexity regions\nwhere seed positions may be suboptimal. This should not be a big concern\nbecause even the optimal alignment may be wrong in such regions.\n.TP\n*\nMinimap2 requires SSE2 or NEON instructions to compile. It is possible to add\nnon-SSE2/NEON support, but it would make minimap2 slower by several times.\n.SH SEE ALSO\n.PP\nminiasm(1), minimap(1), bwa(1).\n"
        },
        {
          "name": "misc.c",
          "type": "blob",
          "size": 4.2900390625,
          "content": "#include <stdlib.h>\n#include \"mmpriv.h\"\n\nint mm_verbose = 1;\nint mm_dbg_flag = 0;\ndouble mm_realtime0;\n\n#if defined(WIN32) || defined(_WIN32)\n#include <windows.h>\n\nstruct timezone\n{\n  __int32  tz_minuteswest; /* minutes W of Greenwich */\n  int  tz_dsttime;     /* type of dst correction */\n};\n\n/*\n * gettimeofday.c\n *    Win32 gettimeofday() replacement\n *    taken from PostgreSQL, according to\n *    https://stackoverflow.com/questions/1676036/what-should-i-use-to-replace-gettimeofday-on-windows\n *\n * src/port/gettimeofday.c\n *\n * Copyright (c) 2003 SRA, Inc.\n * Copyright (c) 2003 SKC, Inc.\n *\n * Permission to use, copy, modify, and distribute this software and\n * its documentation for any purpose, without fee, and without a\n * written agreement is hereby granted, provided that the above\n * copyright notice and this paragraph and the following two\n * paragraphs appear in all copies.\n *\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT,\n * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\n * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\n * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN \"AS\n * IS\" BASIS, AND THE AUTHOR HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,\n * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n */\n\n/* FILETIME of Jan 1 1970 00:00:00. */\nstatic const unsigned __int64 epoch = ((unsigned __int64) 116444736000000000ULL);\n\n/*\n * timezone information is stored outside the kernel so tzp isn't used anymore.\n *\n * Note: this function is not for Win32 high precision timing purpose. See\n * elapsed_time().\n */\nint gettimeofday(struct timeval * tp, struct timezone *tzp)\n{\n    FILETIME    file_time;\n    SYSTEMTIME  system_time;\n    ULARGE_INTEGER ularge;\n\n    GetSystemTime(&system_time);\n    SystemTimeToFileTime(&system_time, &file_time);\n    ularge.LowPart = file_time.dwLowDateTime;\n    ularge.HighPart = file_time.dwHighDateTime;\n\n    tp->tv_sec = (long) ((ularge.QuadPart - epoch) / 10000000L);\n    tp->tv_usec = (long) (system_time.wMilliseconds * 1000);\n\n    return 0;\n}\n\n// taken from https://stackoverflow.com/questions/5272470/c-get-cpu-usage-on-linux-and-windows\ndouble cputime()\n{\n\tHANDLE hProcess = GetCurrentProcess();\n\tFILETIME ftCreation, ftExit, ftKernel, ftUser;\n\tSYSTEMTIME stKernel;\n\tSYSTEMTIME stUser;\n\n\tGetProcessTimes(hProcess, &ftCreation, &ftExit, &ftKernel, &ftUser);\n\tFileTimeToSystemTime(&ftKernel, &stKernel);\n\tFileTimeToSystemTime(&ftUser, &stUser);\n\n\tdouble kernelModeTime = ((stKernel.wHour * 60.) + stKernel.wMinute * 60.) + stKernel.wSecond * 1. + stKernel.wMilliseconds / 1000.;\n\tdouble userModeTime = ((stUser.wHour * 60.) + stUser.wMinute * 60.) + stUser.wSecond * 1. + stUser.wMilliseconds / 1000.;\n\n\treturn kernelModeTime + userModeTime;\n}\n\nlong peakrss(void) { return 0; }\n#else\n#include <sys/resource.h>\n#include <sys/time.h>\n\ndouble cputime(void)\n{\n\tstruct rusage r;\n\tgetrusage(RUSAGE_SELF, &r);\n\treturn r.ru_utime.tv_sec + r.ru_stime.tv_sec + 1e-6 * (r.ru_utime.tv_usec + r.ru_stime.tv_usec);\n}\n\nlong peakrss(void)\n{\n\tstruct rusage r;\n\tgetrusage(RUSAGE_SELF, &r);\n#ifdef __linux__\n\treturn r.ru_maxrss * 1024;\n#else\n\treturn r.ru_maxrss;\n#endif\n}\n\n#endif /* WIN32 || _WIN32 */\n\ndouble realtime(void)\n{\n\tstruct timeval tp;\n\tgettimeofday(&tp, NULL);\n\treturn tp.tv_sec + tp.tv_usec * 1e-6;\n}\n\nvoid mm_err_puts(const char *str)\n{\n\tint ret;\n\tret = puts(str);\n\tif (ret == EOF) {\n\t\tperror(\"[ERROR] failed to write the results\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid mm_err_fwrite(const void *p, size_t size, size_t nitems, FILE *fp)\n{\n\tint ret;\n\tret = fwrite(p, size, nitems, fp);\n\tif (ret == EOF) {\n\t\tperror(\"[ERROR] failed to write data\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid mm_err_fread(void *p, size_t size, size_t nitems, FILE *fp)\n{\n\tint ret;\n\tret = fread(p, size, nitems, fp);\n\tif (ret == EOF) {\n\t\tperror(\"[ERROR] failed to read data\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n#include \"ksort.h\"\n\n#define sort_key_128x(a) ((a).x)\nKRADIX_SORT_INIT(128x, mm128_t, sort_key_128x, 8) \n\n#define sort_key_64(x) (x)\nKRADIX_SORT_INIT(64, uint64_t, sort_key_64, 8)\n\nKSORT_INIT_GENERIC(uint32_t)\nKSORT_INIT_GENERIC(uint64_t)\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "mmpriv.h",
          "type": "blob",
          "size": 6.1708984375,
          "content": "#ifndef MMPRIV2_H\n#define MMPRIV2_H\n\n#include <assert.h>\n#include \"minimap.h\"\n#include \"bseq.h\"\n#include \"kseq.h\"\n\n#define MM_PARENT_UNSET   (-1)\n#define MM_PARENT_TMP_PRI (-2)\n\n#define MM_DBG_NO_KALLOC     0x1\n#define MM_DBG_PRINT_QNAME   0x2\n#define MM_DBG_PRINT_SEED    0x4\n#define MM_DBG_PRINT_ALN_SEQ 0x8\n#define MM_DBG_PRINT_CHAIN   0x10\n#define MM_DBG_SEED_FREQ     0x20\n\n#define MM_SEED_LONG_JOIN  (1ULL<<40)\n#define MM_SEED_IGNORE     (1ULL<<41)\n#define MM_SEED_TANDEM     (1ULL<<42)\n#define MM_SEED_SELF       (1ULL<<43)\n\n#define MM_SEED_SEG_SHIFT  48\n#define MM_SEED_SEG_MASK   (0xffULL<<(MM_SEED_SEG_SHIFT))\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#define mm_seq4_set(s, i, c) ((s)[(i)>>3] |= (uint32_t)(c) << (((i)&7)<<2))\n#define mm_seq4_get(s, i)    ((s)[(i)>>3] >> (((i)&7)<<2) & 0xf)\n\n#define MALLOC(type, len) ((type*)malloc((len) * sizeof(type)))\n#define CALLOC(type, len) ((type*)calloc((len), sizeof(type)))\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\tuint32_t n;\n\tuint32_t q_pos;\n\tuint32_t q_span:31, flt:1;\n\tuint32_t seg_id:31, is_tandem:1;\n\tconst uint64_t *cr;\n} mm_seed_t;\n\ntypedef struct {\n\tint n_u, n_a;\n\tuint64_t *u;\n\tmm128_t *a;\n} mm_seg_t;\n\ndouble cputime(void);\ndouble realtime(void);\nlong peakrss(void);\n\nvoid radix_sort_128x(mm128_t *beg, mm128_t *end);\nvoid radix_sort_64(uint64_t *beg, uint64_t *end);\nuint32_t ks_ksmall_uint32_t(size_t n, uint32_t arr[], size_t kk);\n\nvoid mm_sketch(void *km, const char *str, int len, int w, int k, uint32_t rid, int is_hpc, mm128_v *p);\n\nmm_seed_t *mm_collect_matches(void *km, int *_n_m, int qlen, int max_occ, int max_max_occ, int dist, const mm_idx_t *mi, const mm128_v *mv, int64_t *n_a, int *rep_len, int *n_mini_pos, uint64_t **mini_pos);\nvoid mm_seed_mz_flt(void *km, mm128_v *mv, int32_t q_occ_max, float q_occ_frac);\n\ndouble mm_event_identity(const mm_reg1_t *r);\nint mm_write_sam_hdr(const mm_idx_t *mi, const char *rg, const char *ver, int argc, char *argv[]);\nvoid mm_write_paf(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, void *km, int64_t opt_flag);\nvoid mm_write_paf3(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, void *km, int64_t opt_flag, int rep_len);\nvoid mm_write_sam(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, const mm_reg1_t *r, int n_regs, const mm_reg1_t *regs);\nvoid mm_write_sam2(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, int seg_idx, int reg_idx, int n_seg, const int *n_regs, const mm_reg1_t *const* regs, void *km, int64_t opt_flag);\nvoid mm_write_sam3(kstring_t *s, const mm_idx_t *mi, const mm_bseq1_t *t, int seg_idx, int reg_idx, int n_seg, const int *n_regss, const mm_reg1_t *const* regss, void *km, int64_t opt_flag, int rep_len);\n\nvoid mm_idxopt_init(mm_idxopt_t *opt);\nconst uint64_t *mm_idx_get(const mm_idx_t *mi, uint64_t minier, int *n);\nint32_t mm_idx_cal_max_occ(const mm_idx_t *mi, float f);\nint mm_idx_getseq2(const mm_idx_t *mi, int is_rev, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq);\nmm_reg1_t *mm_align_skeleton(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, const char *qstr, int *n_regs_, mm_reg1_t *regs, mm128_t *a);\nmm_reg1_t *mm_gen_regs(void *km, uint32_t hash, int qlen, int n_u, uint64_t *u, mm128_t *a, int is_qstrand);\n\nmm128_t *mg_lchain_dp(int max_dist_x, int max_dist_y, int bw, int max_skip, int max_iter, int min_cnt, int min_sc, float chn_pen_gap, float chn_pen_skip,\n\t\t\t\t\t  int is_cdna, int n_segs, int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, void *km);\nmm128_t *mg_lchain_rmq(int max_dist, int max_dist_inner, int bw, int max_chn_skip, int cap_rmq_size, int min_cnt, int min_sc, float chn_pen_gap, float chn_pen_skip,\n\t\t\t\t\t   int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, void *km);\n\nvoid mm_mark_alt(const mm_idx_t *mi, int n, mm_reg1_t *r);\nvoid mm_split_reg(mm_reg1_t *r, mm_reg1_t *r2, int n, int qlen, mm128_t *a, int is_qstrand);\nvoid mm_sync_regs(void *km, int n_regs, mm_reg1_t *regs);\nint mm_squeeze_a(void *km, int n_regs, mm_reg1_t *regs, mm128_t *a);\nint mm_set_sam_pri(int n, mm_reg1_t *r);\nvoid mm_set_parent(void *km, float mask_level, int mask_len, int n, mm_reg1_t *r, int sub_diff, int hard_mask_level, float alt_diff_frac);\nvoid mm_select_sub(void *km, float pri_ratio, int min_diff, int best_n, int check_strand, int min_strand_sc, int *n_, mm_reg1_t *r);\nvoid mm_select_sub_multi(void *km, float pri_ratio, float pri1, float pri2, int max_gap_ref, int min_diff, int best_n, int n_segs, const int *qlens, int *n_, mm_reg1_t *r);\nint mm_filter_strand_retained(int n_regs, mm_reg1_t *r);\nvoid mm_filter_regs(const mm_mapopt_t *opt, int qlen, int *n_regs, mm_reg1_t *regs);\nvoid mm_hit_sort(void *km, int *n_regs, mm_reg1_t *r, float alt_diff_frac);\nvoid mm_set_mapq(void *km, int n_regs, mm_reg1_t *regs, int min_chain_sc, int match_sc, int rep_len, int is_sr);\nvoid mm_update_dp_max(int qlen, int n_regs, mm_reg1_t *regs, float frac, int a, int b);\n\nvoid mm_est_err(const mm_idx_t *mi, int qlen, int n_regs, mm_reg1_t *regs, const mm128_t *a, int32_t n, const uint64_t *mini_pos);\n\nmm_seg_t *mm_seg_gen(void *km, uint32_t hash, int n_segs, const int *qlens, int n_regs0, const mm_reg1_t *regs0, int *n_regs, mm_reg1_t **regs, const mm128_t *a);\nvoid mm_seg_free(void *km, int n_segs, mm_seg_t *segs);\nvoid mm_pair(void *km, int max_gap_ref, int dp_bonus, int sub_diff, int match_sc, const int *qlens, int *n_regs, mm_reg1_t **regs);\n\nFILE *mm_split_init(const char *prefix, const mm_idx_t *mi);\nmm_idx_t *mm_split_merge_prep(const char *prefix, int n_splits, FILE **fp, uint32_t *n_seq_part);\nint mm_split_merge(int n_segs, const char **fn, const mm_mapopt_t *opt, int n_split_idx);\nvoid mm_split_rm_tmp(const char *prefix, int n_splits);\n\nvoid mm_err_puts(const char *str);\nvoid mm_err_fwrite(const void *p, size_t size, size_t nitems, FILE *fp);\nvoid mm_err_fread(void *p, size_t size, size_t nitems, FILE *fp);\n\nstatic inline float mg_log2(float x) // NB: this doesn't work when x<2\n{\n\tunion { float f; uint32_t i; } z = { x };\n\tfloat log_2 = ((z.i >> 23) & 255) - 128;\n\tz.i &= ~(255 << 23);\n\tz.i += 127 << 23;\n\tlog_2 += (-0.34484843f * z.f + 2.02466578f) * z.f - 0.67487759f;\n\treturn log_2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 9.0625,
          "content": "#include <stdio.h>\n#include <limits.h>\n#include \"mmpriv.h\"\n\nvoid mm_idxopt_init(mm_idxopt_t *opt)\n{\n\tmemset(opt, 0, sizeof(mm_idxopt_t));\n\topt->k = 15, opt->w = 10, opt->flag = 0;\n\topt->bucket_bits = 14;\n\topt->mini_batch_size = 50000000;\n\topt->batch_size = 8000000000ULL;\n}\n\nvoid mm_mapopt_init(mm_mapopt_t *opt)\n{\n\tmemset(opt, 0, sizeof(mm_mapopt_t));\n\topt->seed = 11;\n\topt->mid_occ_frac = 2e-4f;\n\topt->min_mid_occ = 10;\n\topt->max_mid_occ = 1000000;\n\topt->sdust_thres = 0; // no SDUST masking\n\topt->q_occ_frac = 0.01f;\n\n\topt->min_cnt = 3;\n\topt->min_chain_score = 40;\n\topt->bw = 500, opt->bw_long = 20000;\n\topt->max_gap = 5000;\n\topt->max_gap_ref = -1;\n\topt->max_chain_skip = 25;\n\topt->max_chain_iter = 5000;\n\topt->rmq_inner_dist = 1000;\n\topt->rmq_size_cap = 100000;\n\topt->rmq_rescue_size = 1000;\n\topt->rmq_rescue_ratio = 0.1f;\n\topt->chain_gap_scale = 0.8f;\n\topt->chain_skip_scale = 0.0f;\n\topt->max_max_occ = 4095;\n\topt->occ_dist = 500;\n\n\topt->mask_level = 0.5f;\n\topt->mask_len = INT_MAX;\n\topt->pri_ratio = 0.8f;\n\topt->best_n = 5;\n\n\topt->alt_drop = 0.15f;\n\n\topt->a = 2, opt->b = 4, opt->q = 4, opt->e = 2, opt->q2 = 24, opt->e2 = 1;\n\topt->transition = 0;\n\topt->sc_ambi = 1;\n\topt->zdrop = 400, opt->zdrop_inv = 200;\n\topt->end_bonus = -1;\n\topt->min_dp_max = opt->min_chain_score * opt->a;\n\topt->min_ksw_len = 200;\n\topt->anchor_ext_len = 20, opt->anchor_ext_shift = 6;\n\topt->max_clip_ratio = 1.0f;\n\topt->mini_batch_size = 500000000;\n\topt->max_sw_mat = 100000000;\n\topt->cap_kalloc = 500000000;\n\n\topt->rank_min_len = 500;\n\topt->rank_frac = 0.9f;\n\n\topt->pe_ori = 0; // FF\n\topt->pe_bonus = 33;\n}\n\nvoid mm_mapopt_update(mm_mapopt_t *opt, const mm_idx_t *mi)\n{\n\tif ((opt->flag & MM_F_SPLICE_FOR) || (opt->flag & MM_F_SPLICE_REV))\n\t\topt->flag |= MM_F_SPLICE;\n\tif (opt->mid_occ <= 0) {\n\t\topt->mid_occ = mm_idx_cal_max_occ(mi, opt->mid_occ_frac);\n\t\tif (opt->mid_occ < opt->min_mid_occ)\n\t\t\topt->mid_occ = opt->min_mid_occ;\n\t\tif (opt->max_mid_occ > opt->min_mid_occ && opt->mid_occ > opt->max_mid_occ)\n\t\t\topt->mid_occ = opt->max_mid_occ;\n\t}\n\tif (opt->bw_long < opt->bw) opt->bw_long = opt->bw;\n\tif (mm_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s::%.3f*%.2f] mid_occ = %d\\n\", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), opt->mid_occ);\n}\n\nvoid mm_mapopt_max_intron_len(mm_mapopt_t *opt, int max_intron_len)\n{\n\tif ((opt->flag & MM_F_SPLICE) && max_intron_len > 0)\n\t\topt->max_gap_ref = opt->bw = opt->bw_long = max_intron_len;\n}\n\nint mm_set_opt(const char *preset, mm_idxopt_t *io, mm_mapopt_t *mo)\n{\n\tif (preset == 0) {\n\t\tmm_idxopt_init(io);\n\t\tmm_mapopt_init(mo);\n\t} else if (strcmp(preset, \"lr\") == 0 || strcmp(preset, \"map-ont\") == 0) { // this is the same as the default\n\t} else if (strcmp(preset, \"ava-ont\") == 0) {\n\t\tio->flag = 0, io->k = 15, io->w = 5;\n\t\tmo->flag |= MM_F_ALL_CHAINS | MM_F_NO_DIAG | MM_F_NO_DUAL | MM_F_NO_LJOIN;\n\t\tmo->min_chain_score = 100, mo->pri_ratio = 0.0f, mo->max_chain_skip = 25;\n\t\tmo->bw = mo->bw_long = 2000;\n\t\tmo->occ_dist = 0;\n\t} else if (strcmp(preset, \"map10k\") == 0 || strcmp(preset, \"map-pb\") == 0) {\n\t\tio->flag |= MM_I_HPC, io->k = 19;\n\t} else if (strcmp(preset, \"ava-pb\") == 0) {\n\t\tio->flag |= MM_I_HPC, io->k = 19, io->w = 5;\n\t\tmo->flag |= MM_F_ALL_CHAINS | MM_F_NO_DIAG | MM_F_NO_DUAL | MM_F_NO_LJOIN;\n\t\tmo->min_chain_score = 100, mo->pri_ratio = 0.0f, mo->max_chain_skip = 25;\n\t\tmo->bw_long = mo->bw;\n\t\tmo->occ_dist = 0;\n\t} else if (strcmp(preset, \"lr:hq\") == 0 || strcmp(preset, \"map-hifi\") == 0 || strcmp(preset, \"map-ccs\") == 0) {\n\t\tio->flag = 0, io->k = 19, io->w = 19;\n\t\tmo->max_gap = 10000;\n\t\tmo->min_mid_occ = 50, mo->max_mid_occ = 500;\n\t\tif (strcmp(preset, \"map-hifi\") == 0 || strcmp(preset, \"map-ccs\") == 0) {\n\t\t\tmo->a = 1, mo->b = 4, mo->q = 6, mo->q2 = 26, mo->e = 2, mo->e2 = 1;\n\t\t\tmo->min_dp_max = 200;\n\t\t}\n\t} else if (strcmp(preset, \"lr:hqae\") == 0) { // high-quality assembly evaluation\n\t\tio->flag = 0, io->k = 25, io->w = 51;\n\t\tmo->flag |= MM_F_RMQ;\n\t\tmo->min_mid_occ = 50, mo->max_mid_occ = 500;\n\t\tmo->rmq_inner_dist = 5000;\n\t\tmo->occ_dist = 200;\n\t\tmo->best_n = 100;\n\t\tmo->chain_gap_scale = 5.0f;\n\t} else if (strcmp(preset, \"map-iclr-prerender\") == 0) {\n\t\tio->flag = 0, io->k = 15;\n\t\tmo->b = 6, mo->transition = 1;\n\t\tmo->q = 10, mo->q2 = 50;\n\t} else if (strcmp(preset, \"map-iclr\") == 0) {\n\t\tio->flag = 0, io->k = 19;\n\t\tmo->b = 6, mo->transition = 4;\n\t\tmo->q = 10, mo->q2 = 50;\n\t} else if (strncmp(preset, \"asm\", 3) == 0) {\n\t\tio->flag = 0, io->k = 19, io->w = 19;\n\t\tmo->bw = 1000, mo->bw_long = 100000;\n\t\tmo->max_gap = 10000;\n\t\tmo->flag |= MM_F_RMQ;\n\t\tmo->min_mid_occ = 50, mo->max_mid_occ = 500;\n\t\tmo->min_dp_max = 200;\n\t\tmo->best_n = 50;\n\t\tif (strcmp(preset, \"asm5\") == 0) {\n\t\t\tmo->a = 1, mo->b = 19, mo->q = 39, mo->q2 = 81, mo->e = 3, mo->e2 = 1, mo->zdrop = mo->zdrop_inv = 200;\n\t\t} else if (strcmp(preset, \"asm10\") == 0) {\n\t\t\tmo->a = 1, mo->b = 9, mo->q = 16, mo->q2 = 41, mo->e = 2, mo->e2 = 1, mo->zdrop = mo->zdrop_inv = 200;\n\t\t} else if (strcmp(preset, \"asm20\") == 0) {\n\t\t\tmo->a = 1, mo->b = 4, mo->q = 6, mo->q2 = 26, mo->e = 2, mo->e2 = 1, mo->zdrop = mo->zdrop_inv = 200;\n\t\t\tio->w = 10;\n\t\t} else return -1;\n\t} else if (strcmp(preset, \"short\") == 0 || strcmp(preset, \"sr\") == 0) {\n\t\tio->flag = 0, io->k = 21, io->w = 11;\n\t\tmo->flag |= MM_F_SR | MM_F_FRAG_MODE | MM_F_NO_PRINT_2ND | MM_F_2_IO_THREADS | MM_F_HEAP_SORT;\n\t\tmo->pe_ori = 0<<1|1; // FR\n\t\tmo->a = 2, mo->b = 8, mo->q = 12, mo->e = 2, mo->q2 = 24, mo->e2 = 1;\n\t\tmo->zdrop = mo->zdrop_inv = 100;\n\t\tmo->end_bonus = 10;\n\t\tmo->max_frag_len = 800;\n\t\tmo->max_gap = 100;\n\t\tmo->bw = mo->bw_long = 100;\n\t\tmo->pri_ratio = 0.5f;\n\t\tmo->min_cnt = 2;\n\t\tmo->min_chain_score = 25;\n\t\tmo->min_dp_max = 40;\n\t\tmo->best_n = 20;\n\t\tmo->mid_occ = 1000;\n\t\tmo->max_occ = 5000;\n\t\tmo->mini_batch_size = 50000000;\n\t} else if (strncmp(preset, \"splice\", 6) == 0 || strcmp(preset, \"cdna\") == 0) {\n\t\tio->flag = 0, io->k = 15, io->w = 5;\n\t\tmo->flag |= MM_F_SPLICE | MM_F_SPLICE_FOR | MM_F_SPLICE_REV | MM_F_SPLICE_FLANK;\n\t\tmo->max_sw_mat = 0;\n\t\tmo->max_gap = 2000, mo->max_gap_ref = mo->bw = mo->bw_long = 200000;\n\t\tmo->a = 1, mo->b = 2, mo->q = 2, mo->e = 1, mo->q2 = 32, mo->e2 = 0;\n\t\tmo->noncan = 9;\n\t\tmo->junc_bonus = 9;\n\t\tmo->junc_pen = 5;\n\t\tmo->zdrop = 200, mo->zdrop_inv = 100; // because mo->a is halved\n\t\tif (strcmp(preset, \"splice:hq\") == 0)\n\t\t\tmo->noncan = 5, mo->b = 4, mo->q = 6, mo->q2 = 24;\n\t} else return -1;\n\treturn 0;\n}\n\nint mm_max_spsc_bonus(const mm_mapopt_t *mo)\n{\n\tint max_sc = (mo->q2 + 1) / 2 - 1;\n\tmax_sc = max_sc > mo->q2 - mo->q? max_sc : mo->q2 - mo->q;\n\treturn max_sc;\n}\n\nint mm_check_opt(const mm_idxopt_t *io, const mm_mapopt_t *mo)\n{\n\tif (mo->bw > mo->bw_long) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m with '-rNUM1,NUM2', NUM1 (%d) can't be larger than NUM2 (%d)\\033[0m\\n\", mo->bw, mo->bw_long);\n\t\treturn -8;\n\t}\n\tif ((mo->flag & MM_F_RMQ) && (mo->flag & (MM_F_SR|MM_F_SPLICE))) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m --rmq doesn't work with --sr or --splice\\033[0m\\n\");\n\t\treturn -7;\n\t}\n\tif (mo->split_prefix && (mo->flag & (MM_F_OUT_CS|MM_F_OUT_MD))) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m --cs or --MD doesn't work with --split-prefix\\033[0m\\n\");\n\t\treturn -6;\n\t}\n\tif (io->k <= 0 || io->w <= 0) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m -k and -w must be positive\\033[0m\\n\");\n\t\treturn -5;\n\t}\n\tif (mo->best_n < 0) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m -N must be no less than 0\\033[0m\\n\");\n\t\treturn -4;\n\t}\n\tif (mo->best_n == 0 && mm_verbose >= 2)\n\t\tfprintf(stderr, \"[WARNING]\\033[1;31m '-N 0' reduces mapping accuracy. Please use '--secondary=no' instead.\\033[0m\\n\");\n\tif (mo->pri_ratio < 0.0f || mo->pri_ratio > 1.0f) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m -p must be within 0 and 1 (including 0 and 1)\\033[0m\\n\");\n\t\treturn -4;\n\t}\n\tif ((mo->flag & MM_F_FOR_ONLY) && (mo->flag & MM_F_REV_ONLY)) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m --for-only and --rev-only can't be applied at the same time\\033[0m\\n\");\n\t\treturn -3;\n\t}\n\tif (mo->e <= 0 || mo->q <= 0) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m -O and -E must be positive\\033[0m\\n\");\n\t\treturn -1;\n\t}\n\tif ((mo->q != mo->q2 || mo->e != mo->e2) && !(mo->e > mo->e2 && mo->q + mo->e < mo->q2 + mo->e2)) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m dual gap penalties violating E1>E2 and O1+E1<O2+E2\\033[0m\\n\");\n\t\treturn -2;\n\t}\n\tif ((mo->q + mo->e) + (mo->q2 + mo->e2) > 127) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m scoring system violating ({-O}+{-E})+({-O2}+{-E2}) <= 127\\033[0m\\n\");\n\t\treturn -1;\n\t}\n\tif (mo->zdrop < mo->zdrop_inv) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m Z-drop should not be less than inversion-Z-drop\\033[0m\\n\");\n\t\treturn -5;\n\t}\n\tif ((mo->flag & MM_F_NO_PRINT_2ND) && (mo->flag & MM_F_ALL_CHAINS)) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m -X/-P and --secondary=no can't be applied at the same time\\033[0m\\n\");\n\t\treturn -5;\n\t}\n\tif ((mo->flag & MM_F_QSTRAND) && ((mo->flag & (MM_F_OUT_SAM|MM_F_SPLICE|MM_F_FRAG_MODE)) || (io->flag & MM_I_HPC))) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m --qstrand doesn't work with -a, -H, --frag or --splice\\033[0m\\n\");\n\t\treturn -5;\n\t}\n\treturn 0;\n}\n"
        },
        {
          "name": "pe.c",
          "type": "blob",
          "size": 5.5634765625,
          "content": "#include <stdlib.h>\n#include <math.h>\n#include \"mmpriv.h\"\n#include \"kvec.h\"\n\nvoid mm_select_sub_multi(void *km, float pri_ratio, float pri1, float pri2, int max_gap_ref, int min_diff, int best_n, int n_segs, const int *qlens, int *n_, mm_reg1_t *r)\n{\n\tif (pri_ratio > 0.0f && *n_ > 0) {\n\t\tint i, k, n = *n_, n_2nd = 0;\n\t\tint max_dist = n_segs == 2? qlens[0] + qlens[1] + max_gap_ref : 0;\n\t\tfor (i = k = 0; i < n; ++i) {\n\t\t\tint to_keep = 0;\n\t\t\tif (r[i].parent == i) { // primary\n\t\t\t\tto_keep = 1;\n\t\t\t} else if (r[i].score + min_diff >= r[r[i].parent].score) {\n\t\t\t\tto_keep = 1;\n\t\t\t} else {\n\t\t\t\tmm_reg1_t *p = &r[r[i].parent], *q = &r[i];\n\t\t\t\tif (p->rev == q->rev && p->rid == q->rid && q->re - p->rs < max_dist && p->re - q->rs < max_dist) { // child and parent are close on the ref\n\t\t\t\t\tif (q->score >= p->score * pri1)\n\t\t\t\t\t\tto_keep = 1;\n\t\t\t\t} else {\n\t\t\t\t\tint is_par_both = (n_segs == 2 && p->qs < qlens[0] && p->qe > qlens[0]);\n\t\t\t\t\tint is_chi_both = (n_segs == 2 && q->qs < qlens[0] && q->qe > qlens[0]);\n\t\t\t\t\tif (is_chi_both || is_chi_both == is_par_both) {\n\t\t\t\t\t\tif (q->score >= p->score * pri_ratio)\n\t\t\t\t\t\t\tto_keep = 1;\n\t\t\t\t\t} else { // the remaining case: is_chi_both == 0 && is_par_both == 1\n\t\t\t\t\t\tif (q->score >= p->score * pri2)\n\t\t\t\t\t\t\tto_keep = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (to_keep && r[i].parent != i) {\n\t\t\t\tif (n_2nd++ >= best_n) to_keep = 0; // don't keep if there are too many secondary hits\n\t\t\t}\n\t\t\tif (to_keep) r[k++] = r[i];\n\t\t\telse if (r[i].p) free(r[i].p);\n\t\t}\n\t\tif (k != n) mm_sync_regs(km, k, r); // removing hits requires sync()\n\t\t*n_ = k;\n\t}\n}\n\nvoid mm_set_pe_thru(const int *qlens, int *n_regs, mm_reg1_t **regs)\n{\n\tint s, i, n_pri[2], pri[2];\n\tn_pri[0] = n_pri[1] = 0;\n\tpri[0] = pri[1] = -1;\n\tfor (s = 0; s < 2; ++s)\n\t\tfor (i = 0; i < n_regs[s]; ++i)\n\t\t\tif (regs[s][i].id == regs[s][i].parent)\n\t\t\t\t++n_pri[s], pri[s] = i;\n\tif (n_pri[0] == 1 && n_pri[1] == 1) {\n\t\tmm_reg1_t *p = &regs[0][pri[0]];\n\t\tmm_reg1_t *q = &regs[1][pri[1]];\n\t\tif (p->rid == q->rid && p->rev == q->rev && abs(p->rs - q->rs) < 3 && abs(p->re - q->re) < 3\n\t\t\t&& ((p->qs == 0 && qlens[1] - q->qe == 0) || (q->qs == 0 && qlens[0] - p->qe == 0)))\n\t\t{\n\t\t\tp->pe_thru = q->pe_thru = 1;\n\t\t}\n\t}\n}\n\n#include \"ksort.h\"\n\ntypedef struct {\n\tint s, rev;\n\tuint64_t key;\n\tmm_reg1_t *r;\n} pair_arr_t;\n\n#define sort_key_pair(a) ((a).key)\nKRADIX_SORT_INIT(pair, pair_arr_t, sort_key_pair, 8)\n\nvoid mm_pair(void *km, int max_gap_ref, int pe_bonus, int sub_diff, int match_sc, const int *qlens, int *n_regs, mm_reg1_t **regs)\n{\n\tint i, j, s, n, last[2], dp_thres, segs = 0, max_idx[2];\n\tint64_t max;\n\tpair_arr_t *a;\n\tkvec_t(uint64_t) sc = {0,0,0};\n\n\ta = (pair_arr_t*)kmalloc(km, (n_regs[0] + n_regs[1]) * sizeof(pair_arr_t));\n\tfor (s = n = 0, dp_thres = 0; s < 2; ++s) {\n\t\tint max = 0;\n\t\tfor (i = 0; i < n_regs[s]; ++i) {\n\t\t\ta[n].s = s;\n\t\t\ta[n].r = &regs[s][i];\n\t\t\ta[n].rev = a[n].r->rev;\n\t\t\ta[n].key = (uint64_t)a[n].r->rid << 32 | a[n].r->rs<<1 | (s^a[n].rev);\n\t\t\tmax = max > a[n].r->p->dp_max? max : a[n].r->p->dp_max;\n\t\t\t++n;\n\t\t\tsegs |= 1<<s;\n\t\t}\n\t\tdp_thres += max;\n\t}\n\tif (segs != 3) {\n\t\tkfree(km, a); // only one end is mapped\n\t\treturn;\n\t}\n\tdp_thres -= pe_bonus;\n\tif (dp_thres < 0) dp_thres = 0;\n\tradix_sort_pair(a, a + n);\n\n\tmax = -1;\n\tmax_idx[0] = max_idx[1] = -1;\n\tlast[0] = last[1] = -1;\n\tkv_resize(uint64_t, km, sc, (size_t)n);\n\tfor (i = 0; i < n; ++i) {\n\t\tif (a[i].key & 1) { // reverse first read or forward second read\n\t\t\tmm_reg1_t *q, *r;\n\t\t\tif (last[a[i].rev] < 0) continue;\n\t\t\tr = a[i].r;\n\t\t\tq = a[last[a[i].rev]].r;\n\t\t\tif (r->rid != q->rid || r->rs - q->re > max_gap_ref) continue;\n\t\t\tfor (j = last[a[i].rev]; j >= 0; --j) {\n\t\t\t\tint64_t score;\n\t\t\t\tif (a[j].rev != a[i].rev || a[j].s == a[i].s) continue;\n\t\t\t\tq = a[j].r;\n\t\t\t\tif (r->rid != q->rid || r->rs - q->re > max_gap_ref) break;\n\t\t\t\tif (r->p->dp_max + q->p->dp_max < dp_thres) continue;\n\t\t\t\tscore = (int64_t)(r->p->dp_max + q->p->dp_max) << 32 | (r->hash + q->hash);\n\t\t\t\tif (score > max)\n\t\t\t\t\tmax = score, max_idx[a[j].s] = j, max_idx[a[i].s] = i;\n\t\t\t\tkv_push(uint64_t, km, sc, score);\n\t\t\t}\n\t\t} else { // forward first read or reverse second read\n\t\t\tlast[a[i].rev] = i;\n\t\t}\n\t}\n\tif (sc.n > 1)\n\t\tradix_sort_64(sc.a, sc.a + sc.n);\n\n\tif (sc.n > 0 && max > 0) { // found at least one pair\n\t\tint n_sub = 0, mapq_pe;\n\t\tmm_reg1_t *r[2];\n\t\tr[0] = a[max_idx[0]].r, r[1] = a[max_idx[1]].r;\n\t\tr[0]->proper_frag = r[1]->proper_frag = 1;\n\t\tfor (s = 0; s < 2; ++s) {\n\t\t\tif (r[s]->id != r[s]->parent) { // then lift to primary and update parent\n\t\t\t\tmm_reg1_t *p = &regs[s][r[s]->parent];\n\t\t\t\tfor (i = 0; i < n_regs[s]; ++i)\n\t\t\t\t\tif (regs[s][i].parent == p->id)\n\t\t\t\t\t\tregs[s][i].parent = r[s]->id;\n\t\t\t\tp->mapq = 0;\n\t\t\t}\n\t\t\tif (!r[s]->sam_pri) { // then sync sam_pri\n\t\t\t\tfor (i = 0; i < n_regs[s]; ++i)\n\t\t\t\t\tregs[s][i].sam_pri = 0;\n\t\t\t\tr[s]->sam_pri = 1;\n\t\t\t}\n\t\t}\n\t\tmapq_pe = r[0]->mapq > r[1]->mapq? r[0]->mapq : r[1]->mapq;\n\t\tfor (i = 0; i < (int)sc.n; ++i)\n\t\t\tif ((sc.a[i]>>32) + sub_diff >= (uint64_t)max>>32)\n\t\t\t\t++n_sub;\n\t\tif (sc.n > 1) {\n\t\t\tint mapq_pe_alt;\n\t\t\tmapq_pe_alt = (int)(6.02f * ((max>>32) - (sc.a[sc.n - 2]>>32)) / match_sc - 4.343f * logf(n_sub)); // n_sub > 0 because it counts the optimal, too\n\t\t\tmapq_pe = mapq_pe < mapq_pe_alt? mapq_pe : mapq_pe_alt;\n\t\t}\n\t\tif (r[0]->mapq < mapq_pe) r[0]->mapq = (int)(.2f * r[0]->mapq + .8f * mapq_pe + .499f);\n\t\tif (r[1]->mapq < mapq_pe) r[1]->mapq = (int)(.2f * r[1]->mapq + .8f * mapq_pe + .499f);\n\t\tif (sc.n == 1) {\n\t\t\tif (r[0]->mapq < 2) r[0]->mapq = 2;\n\t\t\tif (r[1]->mapq < 2) r[1]->mapq = 2;\n\t\t} else if ((uint64_t)max>>32 > sc.a[sc.n - 2]>>32) {\n\t\t\tif (r[0]->mapq < 1) r[0]->mapq = 1;\n\t\t\tif (r[1]->mapq < 1) r[1]->mapq = 1;\n\t\t}\n\t}\n\n\tkfree(km, a);\n\tkfree(km, sc.a);\n\n\tmm_set_pe_thru(qlens, n_regs, regs);\n}\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.05859375,
          "content": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"Cython\"]\n"
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "sdust.c",
          "type": "blob",
          "size": 6.486328125,
          "content": "#include <string.h>\n#include <stdint.h>\n#include <stdio.h>\n#include \"kalloc.h\"\n#include \"kdq.h\"\n#include \"kvec.h\"\n#include \"sdust.h\"\n\n#define SD_WLEN 3\n#define SD_WTOT (1<<(SD_WLEN<<1))\n#define SD_WMSK (SD_WTOT - 1)\n\ntypedef struct {\n\tint start, finish;\n\tint r, l;\n} perf_intv_t;\n\ntypedef kvec_t(perf_intv_t) perf_intv_v;\ntypedef kvec_t(uint64_t) uint64_v;\n\nKDQ_INIT(int)\n\n#if defined(_NO_NT4_TBL) || defined(_SDUST_MAIN)\nunsigned char seq_nt4_table[256] = {\n\t0, 1, 2, 3,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4\n};\n#else\nextern unsigned char seq_nt4_table[256];\n#endif\n\nstruct sdust_buf_s {\n\tkdq_t(int) *w;\n\tperf_intv_v P; // the list of perfect intervals for the current window, sorted by descending start and then by ascending finish\n\tuint64_v res;  // the result\n\tvoid *km;      // memory pool\n};\n\nsdust_buf_t *sdust_buf_init(void *km)\n{\n\tsdust_buf_t *buf;\n\tbuf = (sdust_buf_t*)kcalloc(km, 1, sizeof(sdust_buf_t));\n\tbuf->km = km;\n\tbuf->w = kdq_init(int, buf->km);\n\tkdq_resize(int, buf->w, 8);\n\treturn buf;\n}\n\nvoid sdust_buf_destroy(sdust_buf_t *buf)\n{\n\tif (buf == 0) return;\n\tkdq_destroy(int, buf->w);\n\tkfree(buf->km, buf->P.a); kfree(buf->km, buf->res.a); kfree(buf->km, buf);\n}\n\nstatic inline void shift_window(int t, kdq_t(int) *w, int T, int W, int *L, int *rw, int *rv, int *cw, int *cv)\n{\n\tint s;\n\tif ((int)kdq_size(w) >= W - SD_WLEN + 1) { // TODO: is this right for SD_WLEN!=3?\n\t\ts = *kdq_shift(int, w);\n\t\t*rw -= --cw[s];\n\t\tif (*L > (int)kdq_size(w))\n\t\t\t--*L, *rv -= --cv[s];\n\t}\n\tkdq_push(int, w, t);\n\t++*L;\n\t*rw += cw[t]++;\n\t*rv += cv[t]++;\n\tif (cv[t] * 10 > T<<1) {\n\t\tdo {\n\t\t\ts = kdq_at(w, kdq_size(w) - *L);\n\t\t\t*rv -= --cv[s];\n\t\t\t--*L;\n\t\t} while (s != t);\n\t}\n}\n\nstatic inline void save_masked_regions(void *km, uint64_v *res, perf_intv_v *P, int start)\n{\n\tint i, saved = 0;\n\tperf_intv_t *p;\n\tif (P->n == 0 || P->a[P->n - 1].start >= start) return;\n\tp = &P->a[P->n - 1];\n\tif (res->n) {\n\t\tint s = res->a[res->n - 1]>>32, f = (uint32_t)res->a[res->n - 1];\n\t\tif (p->start <= f) // if overlapping with or adjacent to the previous interval\n\t\t\tsaved = 1, res->a[res->n - 1] = (uint64_t)s<<32 | (f > p->finish? f : p->finish);\n\t}\n\tif (!saved) kv_push(uint64_t, km, *res, (uint64_t)p->start<<32|p->finish);\n\tfor (i = P->n - 1; i >= 0 && P->a[i].start < start; --i); // remove perfect intervals that have falled out of the window\n\tP->n = i + 1;\n}\n\nstatic void find_perfect(void *km, perf_intv_v *P, const kdq_t(int) *w, int T, int start, int L, int rv, const int *cv)\n{\n\tint c[SD_WTOT], r = rv, i, max_r = 0, max_l = 0;\n\tmemcpy(c, cv, SD_WTOT * sizeof(int));\n\tfor (i = (long)kdq_size(w) - L - 1; i >= 0; --i) {\n\t\tint j, t = kdq_at(w, i), new_r, new_l;\n\t\tr += c[t]++;\n\t\tnew_r = r, new_l = kdq_size(w) - i - 1;\n\t\tif (new_r * 10 > T * new_l) {\n\t\t\tfor (j = 0; j < (int)P->n && P->a[j].start >= i + start; ++j) { // find insertion position\n\t\t\t\tperf_intv_t *p = &P->a[j];\n\t\t\t\tif (max_r == 0 || p->r * max_l > max_r * p->l)\n\t\t\t\t\tmax_r = p->r, max_l = p->l;\n\t\t\t}\n\t\t\tif (max_r == 0 || new_r * max_l >= max_r * new_l) { // then insert\n\t\t\t\tmax_r = new_r, max_l = new_l;\n\t\t\t\tif (P->n == P->m) kv_resize(perf_intv_t, km, *P, P->n + 1);\n\t\t\t\tmemmove(&P->a[j+1], &P->a[j], (P->n - j) * sizeof(perf_intv_t)); // make room\n\t\t\t\t++P->n;\n\t\t\t\tP->a[j].start = i + start, P->a[j].finish = kdq_size(w) + (SD_WLEN - 1) + start;\n\t\t\t\tP->a[j].r = new_r, P->a[j].l = new_l;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst uint64_t *sdust_core(const uint8_t *seq, int l_seq, int T, int W, int *n, sdust_buf_t *buf)\n{\n\tint rv = 0, rw = 0, L = 0, cv[SD_WTOT], cw[SD_WTOT];\n\tint i, start, l; // _start_: start of the current window; _l_: length of a contiguous A/C/G/T (sub)sequence\n\tunsigned t; // current word\n\n\tbuf->P.n = buf->res.n = 0;\n\tbuf->w->front = buf->w->count = 0;\n\tmemset(cv, 0, SD_WTOT * sizeof(int));\n\tmemset(cw, 0, SD_WTOT * sizeof(int));\n\tif (l_seq < 0) l_seq = strlen((const char*)seq);\n\tfor (i = l = t = 0; i <= l_seq; ++i) {\n\t\tint b = i < l_seq? seq_nt4_table[seq[i]] : 4;\n\t\tif (b < 4) { // an A/C/G/T base\n\t\t\t++l, t = (t<<2 | b) & SD_WMSK;\n\t\t\tif (l >= SD_WLEN) { // we have seen a word\n\t\t\t\tstart = (l - W > 0? l - W : 0) + (i + 1 - l); // set the start of the current window\n\t\t\t\tsave_masked_regions(buf->km, &buf->res, &buf->P, start); // save intervals falling out of the current window?\n\t\t\t\tshift_window(t, buf->w, T, W, &L, &rw, &rv, cw, cv);\n\t\t\t\tif (rw * 10 > L * T)\n\t\t\t\t\tfind_perfect(buf->km, &buf->P, buf->w, T, start, L, rv, cv);\n\t\t\t}\n\t\t} else { // N or the end of sequence; N effectively breaks input into pieces of independent sequences\n\t\t\tstart = (l - W + 1 > 0? l - W + 1 : 0) + (i + 1 - l);\n\t\t\twhile (buf->P.n) save_masked_regions(buf->km, &buf->res, &buf->P, start++); // clear up unsaved perfect intervals\n\t\t\tl = t = 0;\n\t\t}\n\t}\n\t*n = buf->res.n;\n\treturn buf->res.a;\n}\n\nuint64_t *sdust(void *km, const uint8_t *seq, int l_seq, int T, int W, int *n)\n{\n\tuint64_t *ret;\n\tsdust_buf_t *buf;\n\tbuf = sdust_buf_init(km);\n\tret = (uint64_t*)sdust_core(seq, l_seq, T, W, n, buf);\n\tbuf->res.a = 0;\n\tsdust_buf_destroy(buf);\n\treturn ret;\n}\n\n#ifdef _SDUST_MAIN\n#include <zlib.h>\n#include <stdio.h>\n#include \"ketopt.h\"\n#include \"kseq.h\"\nKSEQ_INIT(gzFile, gzread)\n\nint main(int argc, char *argv[])\n{\n\tgzFile fp;\n\tkseq_t *ks;\n\tint W = 64, T = 20, c;\n\tketopt_t o = KETOPT_INIT;\n\n\twhile ((c = ketopt(&o, argc, argv, 1, \"w:t:\", 0)) >= 0) {\n\t\tif (c == 'w') W = atoi(o.arg);\n\t\telse if (c == 't') T = atoi(o.arg);\n\t}\n\tif (o.ind == argc) {\n\t\tfprintf(stderr, \"Usage: sdust [-w %d] [-t %d] <in.fa>\\n\", W, T);\n\t\treturn 1;\n\t}\n\tfp = strcmp(argv[o.ind], \"-\")? gzopen(argv[o.ind], \"r\") : gzdopen(fileno(stdin), \"r\");\n\tks = kseq_init(fp);\n\twhile (kseq_read(ks) >= 0) {\n\t\tuint64_t *r;\n\t\tint i, n;\n\t\tr = sdust(0, (uint8_t*)ks->seq.s, -1, T, W, &n);\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tprintf(\"%s\\t%d\\t%d\\n\", ks->name.s, (int)(r[i]>>32), (int)r[i]);\n\t\tfree(r);\n\t}\n\tkseq_destroy(ks);\n\tgzclose(fp);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "sdust.h",
          "type": "blob",
          "size": 0.560546875,
          "content": "#ifndef SDUST_H\n#define SDUST_H\n\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct sdust_buf_s;\ntypedef struct sdust_buf_s sdust_buf_t;\n\n// the simple interface\nuint64_t *sdust(void *km, const uint8_t *seq, int l_seq, int T, int W, int *n);\n\n// the following interface dramatically reduce heap allocations when sdust is frequently called.\nsdust_buf_t *sdust_buf_init(void *km);\nvoid sdust_buf_destroy(sdust_buf_t *buf);\nconst uint64_t *sdust_core(const uint8_t *seq, int l_seq, int T, int W, int *n, sdust_buf_t *buf);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "seed.c",
          "type": "blob",
          "size": 4.095703125,
          "content": "#include \"mmpriv.h\"\n#include \"kalloc.h\"\n#include \"ksort.h\"\n\nvoid mm_seed_mz_flt(void *km, mm128_v *mv, int32_t q_occ_max, float q_occ_frac)\n{\n\tmm128_t *a;\n\tsize_t i, j, st;\n\tif (mv->n <= q_occ_max || q_occ_frac <= 0.0f || q_occ_max <= 0) return;\n\ta = Kmalloc(km, mm128_t, mv->n);\n\tfor (i = 0; i < mv->n; ++i)\n\t\ta[i].x = mv->a[i].x, a[i].y = i;\n\tradix_sort_128x(a, a + mv->n);\n\tfor (st = 0, i = 1; i <= mv->n; ++i) {\n\t\tif (i == mv->n || a[i].x != a[st].x) {\n\t\t\tint32_t cnt = i - st;\n\t\t\tif (cnt > q_occ_max && cnt > mv->n * q_occ_frac)\n\t\t\t\tfor (j = st; j < i; ++j)\n\t\t\t\t\tmv->a[a[j].y].x = 0;\n\t\t\tst = i;\n\t\t}\n\t}\n\tkfree(km, a);\n\tfor (i = j = 0; i < mv->n; ++i)\n\t\tif (mv->a[i].x != 0)\n\t\t\tmv->a[j++] = mv->a[i];\n\tmv->n = j;\n}\n\nmm_seed_t *mm_seed_collect_all(void *km, const mm_idx_t *mi, const mm128_v *mv, int32_t *n_m_)\n{\n\tmm_seed_t *m;\n\tsize_t i;\n\tint32_t k;\n\tm = (mm_seed_t*)kmalloc(km, mv->n * sizeof(mm_seed_t));\n\tfor (i = k = 0; i < mv->n; ++i) {\n\t\tconst uint64_t *cr;\n\t\tmm_seed_t *q;\n\t\tmm128_t *p = &mv->a[i];\n\t\tuint32_t q_pos = (uint32_t)p->y, q_span = p->x & 0xff;\n\t\tint t;\n\t\tcr = mm_idx_get(mi, p->x>>8, &t);\n\t\tif (t == 0) continue;\n\t\tq = &m[k++];\n\t\tq->q_pos = q_pos, q->q_span = q_span, q->cr = cr, q->n = t, q->seg_id = p->y >> 32;\n\t\tq->is_tandem = q->flt = 0;\n\t\tif (i > 0 && p->x>>8 == mv->a[i - 1].x>>8) q->is_tandem = 1;\n\t\tif (i < mv->n - 1 && p->x>>8 == mv->a[i + 1].x>>8) q->is_tandem = 1;\n\t}\n\t*n_m_ = k;\n\treturn m;\n}\n\n#define MAX_MAX_HIGH_OCC 128\n\nvoid mm_seed_select(int32_t n, mm_seed_t *a, int len, int max_occ, int max_max_occ, int dist)\n{ // for high-occ minimizers, choose up to max_high_occ in each high-occ streak\n\textern void ks_heapdown_uint64_t(size_t i, size_t n, uint64_t*);\n\textern void ks_heapmake_uint64_t(size_t n, uint64_t*);\n\tint32_t i, last0, m;\n\tuint64_t b[MAX_MAX_HIGH_OCC]; // this is to avoid a heap allocation\n\n\tif (n == 0 || n == 1) return;\n\tfor (i = m = 0; i < n; ++i)\n\t\tif (a[i].n > max_occ) ++m;\n\tif (m == 0) return; // no high-frequency k-mers; do nothing\n\tfor (i = 0, last0 = -1; i <= n; ++i) {\n\t\tif (i == n || a[i].n <= max_occ) {\n\t\t\tif (i - last0 > 1) {\n\t\t\t\tint32_t ps = last0 < 0? 0 : (uint32_t)a[last0].q_pos>>1;\n\t\t\t\tint32_t pe = i == n? len : (uint32_t)a[i].q_pos>>1;\n\t\t\t\tint32_t j, k, st = last0 + 1, en = i;\n\t\t\t\tint32_t max_high_occ = (int32_t)((double)(pe - ps) / dist + .499);\n\t\t\t\tif (max_high_occ > 0) {\n\t\t\t\t\tif (max_high_occ > MAX_MAX_HIGH_OCC)\n\t\t\t\t\t\tmax_high_occ = MAX_MAX_HIGH_OCC;\n\t\t\t\t\tfor (j = st, k = 0; j < en && k < max_high_occ; ++j, ++k)\n\t\t\t\t\t\tb[k] = (uint64_t)a[j].n<<32 | j;\n\t\t\t\t\tks_heapmake_uint64_t(k, b); // initialize the binomial heap\n\t\t\t\t\tfor (; j < en; ++j) { // if there are more, choose top max_high_occ\n\t\t\t\t\t\tif (a[j].n < (int32_t)(b[0]>>32)) { // then update the heap\n\t\t\t\t\t\t\tb[0] = (uint64_t)a[j].n<<32 | j;\n\t\t\t\t\t\t\tks_heapdown_uint64_t(0, k, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < k; ++j) a[(uint32_t)b[j]].flt = 1;\n\t\t\t\t}\n\t\t\t\tfor (j = st; j < en; ++j) a[j].flt ^= 1;\n\t\t\t\tfor (j = st; j < en; ++j)\n\t\t\t\t\tif (a[j].n > max_max_occ)\n\t\t\t\t\t\ta[j].flt = 1;\n\t\t\t}\n\t\t\tlast0 = i;\n\t\t}\n\t}\n}\n\nmm_seed_t *mm_collect_matches(void *km, int *_n_m, int qlen, int max_occ, int max_max_occ, int dist, const mm_idx_t *mi, const mm128_v *mv, int64_t *n_a, int *rep_len, int *n_mini_pos, uint64_t **mini_pos)\n{\n\tint rep_st = 0, rep_en = 0, n_m, n_m0;\n\tsize_t i;\n\tmm_seed_t *m;\n\t*n_mini_pos = 0;\n\t*mini_pos = (uint64_t*)kmalloc(km, mv->n * sizeof(uint64_t));\n\tm = mm_seed_collect_all(km, mi, mv, &n_m0);\n\tif (dist > 0 && max_max_occ > max_occ) {\n\t\tmm_seed_select(n_m0, m, qlen, max_occ, max_max_occ, dist);\n\t} else {\n\t\tfor (i = 0; i < n_m0; ++i)\n\t\t\tif (m[i].n > max_occ)\n\t\t\t\tm[i].flt = 1;\n\t}\n\tfor (i = 0, n_m = 0, *rep_len = 0, *n_a = 0; i < n_m0; ++i) {\n\t\tmm_seed_t *q = &m[i];\n\t\tif (mm_dbg_flag & MM_DBG_SEED_FREQ)\n\t\t\tfprintf(stderr, \"SF\\t%d\\t%d\\t%d\\n\", q->q_pos>>1, q->n, q->flt);\n\t\tif (q->flt) {\n\t\t\tint en = (q->q_pos >> 1) + 1, st = en - q->q_span;\n\t\t\tif (st > rep_en) {\n\t\t\t\t*rep_len += rep_en - rep_st;\n\t\t\t\trep_st = st, rep_en = en;\n\t\t\t} else rep_en = en;\n\t\t} else {\n\t\t\t*n_a += q->n;\n\t\t\t(*mini_pos)[(*n_mini_pos)++] = (uint64_t)q->q_span<<32 | q->q_pos>>1;\n\t\t\tm[n_m++] = *q;\n\t\t}\n\t}\n\t*rep_len += rep_en - rep_st;\n\t*_n_m = n_m;\n\treturn m;\n}\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.912109375,
          "content": "try:\n\tfrom setuptools import setup, Extension\nexcept ImportError:\n\tfrom distutils.core import setup\n\tfrom distutils.extension import Extension\n\nimport sys, platform\n\nsys.path.append('python')\n\nextra_compile_args = ['-DHAVE_KALLOC']\ninclude_dirs = [\".\"]\n\nif platform.machine() in [\"aarch64\", \"arm64\"]:\n\tinclude_dirs.append(\"sse2neon/\")\n\textra_compile_args.extend(['-ftree-vectorize', '-DKSW_SSE2_ONLY', '-D__SSE2__'])\nelse:\n\textra_compile_args.append('-msse4.1') # WARNING: ancient x86_64 CPUs don't have SSE4\n\ndef readme():\n\twith open('python/README.rst') as f:\n\t\treturn f.read()\n\nsetup(\n\tname = 'mappy',\n\tversion = '2.28',\n\turl = 'https://github.com/lh3/minimap2',\n\tdescription = 'Minimap2 python binding',\n\tlong_description = readme(),\n\tauthor = 'Heng Li',\n\tauthor_email = 'lh3@me.com',\n\tlicense = 'MIT',\n\tkeywords = 'sequence-alignment',\n\tscripts = ['python/minimap2.py'],\n\text_modules = [Extension('mappy',\n\t\tsources = ['python/mappy.pyx', 'align.c', 'bseq.c', 'lchain.c', 'seed.c', 'format.c', 'hit.c', 'index.c', 'pe.c', 'options.c',\n\t\t\t\t   'ksw2_extd2_sse.c', 'ksw2_exts2_sse.c', 'ksw2_extz2_sse.c', 'ksw2_ll_sse.c',\n\t\t\t\t   'kalloc.c', 'kthread.c', 'map.c', 'misc.c', 'sdust.c', 'sketch.c', 'esterr.c', 'splitidx.c'],\n\t\tdepends = ['minimap.h', 'bseq.h', 'kalloc.h', 'kdq.h', 'khash.h', 'kseq.h', 'ksort.h',\n\t\t\t\t   'ksw2.h', 'kthread.h', 'kvec.h', 'mmpriv.h', 'sdust.h',\n\t\t\t\t   'python/cmappy.h', 'python/cmappy.pxd'],\n\t\textra_compile_args = extra_compile_args,\n\t\tinclude_dirs = include_dirs,\n\t\tlibraries = ['z', 'm', 'pthread'])],\n\tclassifiers = [\n\t\t'Development Status :: 5 - Production/Stable',\n\t\t'License :: OSI Approved :: MIT License',\n\t\t'Operating System :: POSIX',\n\t\t'Programming Language :: C',\n\t\t'Programming Language :: Cython',\n\t\t'Programming Language :: Python :: 2.7',\n\t\t'Programming Language :: Python :: 3',\n\t\t'Intended Audience :: Science/Research',\n\t\t'Topic :: Scientific/Engineering :: Bio-Informatics'],\n\tsetup_requires=[\"cython\"])\n"
        },
        {
          "name": "sketch.c",
          "type": "blob",
          "size": 5.6923828125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#define __STDC_LIMIT_MACROS\n#include \"kvec.h\"\n#include \"mmpriv.h\"\n\nunsigned char seq_nt4_table[256] = {\n\t0, 1, 2, 3,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  3, 3, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  3, 3, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4\n};\n\nstatic inline uint64_t hash64(uint64_t key, uint64_t mask)\n{\n\tkey = (~key + (key << 21)) & mask; // key = (key << 21) - key - 1;\n\tkey = key ^ key >> 24;\n\tkey = ((key + (key << 3)) + (key << 8)) & mask; // key * 265\n\tkey = key ^ key >> 14;\n\tkey = ((key + (key << 2)) + (key << 4)) & mask; // key * 21\n\tkey = key ^ key >> 28;\n\tkey = (key + (key << 31)) & mask;\n\treturn key;\n}\n\ntypedef struct { // a simplified version of kdq\n\tint front, count;\n\tint a[32];\n} tiny_queue_t;\n\nstatic inline void tq_push(tiny_queue_t *q, int x)\n{\n\tq->a[((q->count++) + q->front) & 0x1f] = x;\n}\n\nstatic inline int tq_shift(tiny_queue_t *q)\n{\n\tint x;\n\tif (q->count == 0) return -1;\n\tx = q->a[q->front++];\n\tq->front &= 0x1f;\n\t--q->count;\n\treturn x;\n}\n\n/**\n * Find symmetric (w,k)-minimizers on a DNA sequence\n *\n * @param km     thread-local memory pool; using NULL falls back to malloc()\n * @param str    DNA sequence\n * @param len    length of $str\n * @param w      find a minimizer for every $w consecutive k-mers\n * @param k      k-mer size\n * @param rid    reference ID; will be copied to the output $p array\n * @param is_hpc homopolymer-compressed or not\n * @param p      minimizers\n *               p->a[i].x = kMer<<8 | kmerSpan\n *               p->a[i].y = rid<<32 | lastPos<<1 | strand\n *               where lastPos is the position of the last base of the i-th minimizer,\n *               and strand indicates whether the minimizer comes from the top or the bottom strand.\n *               Callers may want to set \"p->n = 0\"; otherwise results are appended to p\n */\nvoid mm_sketch(void *km, const char *str, int len, int w, int k, uint32_t rid, int is_hpc, mm128_v *p)\n{\n\tuint64_t shift1 = 2 * (k - 1), mask = (1ULL<<2*k) - 1, kmer[2] = {0,0};\n\tint i, j, l, buf_pos, min_pos, kmer_span = 0;\n\tmm128_t buf[256], min = { UINT64_MAX, UINT64_MAX };\n\ttiny_queue_t tq;\n\n\tassert(len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)); // 56 bits for k-mer; could use long k-mers, but 28 enough in practice\n\tmemset(buf, 0xff, w * 16);\n\tmemset(&tq, 0, sizeof(tiny_queue_t));\n\tkv_resize(mm128_t, km, *p, p->n + len/w);\n\n\tfor (i = l = buf_pos = min_pos = 0; i < len; ++i) {\n\t\tint c = seq_nt4_table[(uint8_t)str[i]];\n\t\tmm128_t info = { UINT64_MAX, UINT64_MAX };\n\t\tif (c < 4) { // not an ambiguous base\n\t\t\tint z;\n\t\t\tif (is_hpc) {\n\t\t\t\tint skip_len = 1;\n\t\t\t\tif (i + 1 < len && seq_nt4_table[(uint8_t)str[i + 1]] == c) {\n\t\t\t\t\tfor (skip_len = 2; i + skip_len < len; ++skip_len)\n\t\t\t\t\t\tif (seq_nt4_table[(uint8_t)str[i + skip_len]] != c)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\ti += skip_len - 1; // put $i at the end of the current homopolymer run\n\t\t\t\t}\n\t\t\t\ttq_push(&tq, skip_len);\n\t\t\t\tkmer_span += skip_len;\n\t\t\t\tif (tq.count > k) kmer_span -= tq_shift(&tq);\n\t\t\t} else kmer_span = l + 1 < k? l + 1 : k;\n\t\t\tkmer[0] = (kmer[0] << 2 | c) & mask;           // forward k-mer\n\t\t\tkmer[1] = (kmer[1] >> 2) | (3ULL^c) << shift1; // reverse k-mer\n\t\t\tif (kmer[0] == kmer[1]) continue; // skip \"symmetric k-mers\" as we don't know it strand\n\t\t\tz = kmer[0] < kmer[1]? 0 : 1; // strand\n\t\t\t++l;\n\t\t\tif (l >= k && kmer_span < 256) {\n\t\t\t\tinfo.x = hash64(kmer[z], mask) << 8 | kmer_span;\n\t\t\t\tinfo.y = (uint64_t)rid<<32 | (uint32_t)i<<1 | z;\n\t\t\t}\n\t\t} else l = 0, tq.count = tq.front = 0, kmer_span = 0;\n\t\tbuf[buf_pos] = info; // need to do this here as appropriate buf_pos and buf[buf_pos] are needed below\n\t\tif (l == w + k - 1 && min.x != UINT64_MAX) { // special case for the first window - because identical k-mers are not stored yet\n\t\t\tfor (j = buf_pos + 1; j < w; ++j)\n\t\t\t\tif (min.x == buf[j].x && buf[j].y != min.y) kv_push(mm128_t, km, *p, buf[j]);\n\t\t\tfor (j = 0; j < buf_pos; ++j)\n\t\t\t\tif (min.x == buf[j].x && buf[j].y != min.y) kv_push(mm128_t, km, *p, buf[j]);\n\t\t}\n\t\tif (info.x <= min.x) { // a new minimum; then write the old min\n\t\t\tif (l >= w + k && min.x != UINT64_MAX) kv_push(mm128_t, km, *p, min);\n\t\t\tmin = info, min_pos = buf_pos;\n\t\t} else if (buf_pos == min_pos) { // old min has moved outside the window\n\t\t\tif (l >= w + k - 1 && min.x != UINT64_MAX) kv_push(mm128_t, km, *p, min);\n\t\t\tfor (j = buf_pos + 1, min.x = UINT64_MAX; j < w; ++j) // the two loops are necessary when there are identical k-mers\n\t\t\t\tif (min.x >= buf[j].x) min = buf[j], min_pos = j; // >= is important s.t. min is always the closest k-mer\n\t\t\tfor (j = 0; j <= buf_pos; ++j)\n\t\t\t\tif (min.x >= buf[j].x) min = buf[j], min_pos = j;\n\t\t\tif (l >= w + k - 1 && min.x != UINT64_MAX) { // write identical k-mers\n\t\t\t\tfor (j = buf_pos + 1; j < w; ++j) // these two loops make sure the output is sorted\n\t\t\t\t\tif (min.x == buf[j].x && min.y != buf[j].y) kv_push(mm128_t, km, *p, buf[j]);\n\t\t\t\tfor (j = 0; j <= buf_pos; ++j)\n\t\t\t\t\tif (min.x == buf[j].x && min.y != buf[j].y) kv_push(mm128_t, km, *p, buf[j]);\n\t\t\t}\n\t\t}\n\t\tif (++buf_pos == w) buf_pos = 0;\n\t}\n\tif (min.x != UINT64_MAX)\n\t\tkv_push(mm128_t, km, *p, min);\n}\n"
        },
        {
          "name": "splitidx.c",
          "type": "blob",
          "size": 2.076171875,
          "content": "#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"mmpriv.h\"\n\nFILE *mm_split_init(const char *prefix, const mm_idx_t *mi)\n{\n\tchar *fn;\n\tFILE *fp;\n\tuint32_t i, k = mi->k;\n\tfn = (char*)calloc(strlen(prefix) + 10, 1);\n\tsprintf(fn, \"%s.%.4d.tmp\", prefix, mi->index);\n\tif ((fp = fopen(fn, \"wb\")) == NULL) {\n\t\tif (mm_verbose >= 1)\n\t\t\tfprintf(stderr, \"[ERROR]\\033[1;31m failed to write to temporary file '%s'\\033[0m: %s\\n\", fn, strerror(errno));\n\t\texit(1);\n\t}\n\tmm_err_fwrite(&k, 4, 1, fp);\n\tmm_err_fwrite(&mi->n_seq, 4, 1, fp);\n\tfor (i = 0; i < mi->n_seq; ++i) {\n\t\tuint32_t l;\n\t\tl = strlen(mi->seq[i].name);\n\t\tmm_err_fwrite(&l, 1, 4, fp);\n\t\tmm_err_fwrite(mi->seq[i].name, 1, l, fp);\n\t\tmm_err_fwrite(&mi->seq[i].len, 4, 1, fp);\n\t}\n\tfree(fn);\n\treturn fp;\n}\n\nmm_idx_t *mm_split_merge_prep(const char *prefix, int n_splits, FILE **fp, uint32_t *n_seq_part)\n{\n\tmm_idx_t *mi = 0;\n\tchar *fn;\n\tint i, j;\n\n\tif (n_splits < 1) return 0;\n\tfn = CALLOC(char, strlen(prefix) + 10);\n\tfor (i = 0; i < n_splits; ++i) {\n\t\tsprintf(fn, \"%s.%.4d.tmp\", prefix, i);\n\t\tif ((fp[i] = fopen(fn, \"rb\")) == 0) {\n\t\t\tif (mm_verbose >= 1)\n\t\t\t\tfprintf(stderr, \"ERROR: failed to open temporary file '%s': %s\\n\", fn, strerror(errno));\n\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\tfclose(fp[j]);\n\t\t\tfree(fn);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(fn);\n\n\tmi = CALLOC(mm_idx_t, 1);\n\tfor (i = 0; i < n_splits; ++i) {\n\t\tmm_err_fread(&mi->k, 4, 1, fp[i]); // TODO: check if k is all the same\n\t\tmm_err_fread(&n_seq_part[i], 4, 1, fp[i]);\n\t\tmi->n_seq += n_seq_part[i];\n\t}\n\tmi->seq = CALLOC(mm_idx_seq_t, mi->n_seq);\n\tfor (i = j = 0; i < n_splits; ++i) {\n\t\tuint32_t k;\n\t\tfor (k = 0; k < n_seq_part[i]; ++k, ++j) {\n\t\t\tuint32_t l;\n\t\t\tmm_err_fread(&l, 1, 4, fp[i]);\n\t\t\tmi->seq[j].name = (char*)calloc(l + 1, 1);\n\t\t\tmm_err_fread(mi->seq[j].name, 1, l, fp[i]);\n\t\t\tmm_err_fread(&mi->seq[j].len, 4, 1, fp[i]);\n\t\t}\n\t}\n\treturn mi;\n}\n\nvoid mm_split_rm_tmp(const char *prefix, int n_splits)\n{\n\tint i;\n\tchar *fn;\n\tfn = CALLOC(char, strlen(prefix) + 10);\n\tfor (i = 0; i < n_splits; ++i) {\n\t\tsprintf(fn, \"%s.%.4d.tmp\", prefix, i);\n\t\tremove(fn);\n\t}\n\tfree(fn);\n}\n"
        },
        {
          "name": "sse2neon",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tex",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}