{
  "metadata": {
    "timestamp": 1736709969503,
    "page": 523,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vedderb/bldc",
      "stars": 2289,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gdbinit",
          "type": "blob",
          "size": 0.3251953125,
          "content": "define connect\n\ttarget extended localhost:3333\nend\n\ndefine dump_flash\n\tif ($argc == 0)\n\t\tdump binary memory flash_dump.bin 0 0x100000\n\tend\n\tif ($argc == 1)\n\t\tdump binary memory $arg0 0 0x100000\n\telse\n\t\thelp dump_flash\n\tend\nend\ndocument dump_flash\nDump the enitire stm flash area to a bin file.\nUsage: dump_flash <optional> *.bin\nend\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1787109375,
          "content": "*~\n\nbuild\ntools\ndownloads\npackage/\n\n.dep\n.project\n.cproject\n.settings/language.settings.xml\n.DS_Store\nworkspace.code-workspace\n\n# Qt project settings\n*.pro.user\n*.pro.shared\n\n.vscode\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.197265625,
          "content": "language: cpp\ncompiler: gcc\ncache: apt\nsudo: required\ndist: trusty\naddons:\n  apt:\n    packages:\n      - gcc-arm-none-eabi\n      - libnewlib-arm-none-eabi\nenv:\n\nscript:\n  - cd build_all && ./rebuild_all\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 29.169921875,
          "content": "### 6.06\n#### TBD\n* LispBM:\n\t* New core extansions, optimization and much more unit testing.\n\t* Many bug fixes in the reader.\n\t* Moved const memory into its own flash sector.\n\t* Added const-heap-erase extension.\n* New offset calibration modes and options.\n* Automatic offset calibration support.\n* Added HFI ambiguity resolution modes using id injection.\n\n### 6.05\n#### 2024-08-19\n* LispBM:\n\t* Support for var in progn.\n\t* Support for curly brackets instead of progn.\n\t* Added set and setq.\n\t* Added defunret.\n\t* Added support for detaching only one of the ADCs.\n\t* Added set-encoder.\n\t* Support for moving code and data to flash.\n\t* Incremental read of uploaded code.\n\t* Removed array types other than byte arrays.\n\t* Added more position extensions.\n\t* Use timeout when app_adc is detached.\n\t* Added extension conf-restore-mc.\n\t* Added extension conf-restore-app.\n\t* Added extension conf-dc-cal.\n\t* Added access to several config parameters.\n\t* Many improvements and bug fixes.\n\t* Better error descriptions.\n\t* Added thread profiler.\n\t* Added flat value support.\n\t* Added recv-to with a timeout argument.\n\t* Added remote message extensions.\n\t* Added phase-hall extension.\n\t* Added loopwhile-thd.\n\t* Added can-recv-sid.\n\t* Added can-recv-eid.\n\t* Added app-adc-range-ok.\n\t* Much faster return on error for i2c-tx-rx.\n\t* Added shutdown-hold.\n\t* Added crc32.\n\t* Support for only polling variables starting with VT.\n\t* Added rand.\n\t* Built-in sort function that is much faster and can sort much larger lists.\n\t* Added foc-play-tone and foc-play-stop.\n\t* Added foc-play-samples.\n\t* Added can-msg-age.\n\t* Massive performance boost for string functions and 64-bit operations due to much faster memory allocation.\n* Hall sensors improvements:\n\t* Smooth transition to sensorless.\n\t* Bug fix in interpolation.\n\t* Use less noisy speed estimator for interpolation.\n\t* Adjusted rate limit.\n* Added soft regen cutoff. See https://github.com/vedderb/vesc_tool/pull/310\n* Attempt at limiting the input current when using MTPA and field weakening.\n* Removed built-in balance app. The balance-package can be used instead, which is where new development is done.\n* Added option to select PID-controller speed source.\n* Try to make odometer persistent even without shutdown switch. See https://github.com/vedderb/bldc/pull/624\n* Dual motor flux linkage measurement current spike bug fix.\n* Fix possible runaway after faults during openloop measurements (flux linkage, encoder).\n* Added more current sampling modes.\n* Added FOC interpolation mode.\n* Allow passive flux linkage measurement.\n* Fixed some braking glitches.\n* Configurable HFI error truncation to reject noise.\n* Removed GPDrive.\n* FOC: Option to short phases on 0 duty.\n* FOC: Added MXV observer.\n\n### 6.02\n#### 2023-03-12\n* LispBM:\n\t* Bug fixes.\n\t* Added floor, ceil, round.\n\t* Added resistance, inductance and flux linkage estimator functions.\n\t* Added adc_ctrl_type setting.\n\t* Added app_is_disabled.\n\t* Added ICU-driver.\n\t* Inductance measurement support.\n\t* Rewrite of the event system.\n\t* Added canget-vin\n\t* Added hw-type sysinfo.\n\t* Added crc16-extension.\n* IMU filtering changes and new defaults.\n* Increased hall sensor switch hysteresis.\n* Added and updated hardware configs.\n* Systime overflow fix.\n* Some can-command fixes.\n\n---\n\n### 6.00\n#### Released 2022-12-08\n* Added stack checks.\n* Release motor fix when cc_min_current is 0.\n* Added support for NTC and PTC temperature sensors with custom resistance and base temperature.\n* Added sandboxed lisp scripting using https://github.com/svenssonjoel/lispBM.\n* Encoder driver split and rewrite to make it easier to support more encoders.\n* Flash writes now work on lower MCU voltages too.\n* Added fwinfo terminal command.\n* CAN status messages are now configured using bitfields.\n* There are two rates at which CAN status messages can be sent now.\n* New silent HFI mode with much better performance at high load.\n* Added app ADC min and max voltage limits for throttle fault detection.\n* Another new silent HFI mode that is less sensitive to getting the inductance correct.\n* Added openloop current boost parameter.\n* Added openloop current max parameter.\n* Added support for dynamic loading of C libraries.\n* Added more observers:\n\t* mxlemming\n\t* ortega with flux linkage tracking\n\t* mxlemming with flux linkage tracking\n* AS5x47 encoder support: https://github.com/vedderb/bldc/pull/511\n* Disable BMS limit options.\n* Added PT1000 temperature sensor support.\n* APP ADC button bitfield and CC disable support.\n* BissC encoder support: https://github.com/vedderb/bldc/pull/536\n* Better detection failt handling and reporting: https://github.com/vedderb/bldc/pull/533\n* TLE5012-support: https://github.com/vedderb/bldc/pull/551\n\n---\n\n### 5.03\n#### Released 2022-01-16\n* Fixed inductance measurement bug.\n* Speed tracker windup protection.\n* Phase filter support.\n* Phase voltage offset calibration.\n* Better current offset calibration.\n* Added power switch commands.\n* Synchronize observer state when running in open loop.\n* Force oberver state magnitude above 50% of flux linkage. This prevents the motor from getting stuck and 'screaming'.\n* Observer global convergence update. Helps tracking the motor through 0 speed.\n* Added HFI start sensor mode.\n* Added TEMP_SENSOR_KTY84_130.\n* Major UAVCAN update. See: https://github.com/vedderb/bldc/pull/269\n* Avoid numerical instability when mapping is done over a narrow range. See: https://github.com/vedderb/bldc/issues/262\n* App Balance updates.\n* Added servo_out_enable appconf option, so that the PPM port can be used to control servos with the default firmware.\n* Better current controller windup protection.\n* Field weakening support (experimental, be careful and use at your own risk).\n* Use filtered current for axis decoupling.\n* Odometer is now persistent after firmware updates.\n* Added hw runtime counter (see hw_status in terminal)\n* Added custom UI support.\n* Limit hall sensor angle rate of change based on ERPM.\n* Added p_pid_gain_dec_angle parameter.\n* Low pass filter input voltage.\n* Dual hardware CAN-scan fix.\n* Dynamic QML-script write support.\n* Use fast speed tracker for current controller.\n* Disable motor for 5 seconds after flash operations.\n* Added kill switch support.\n* Added process derivative term to position controller.\n* Added position PID-controller angle offset.\n* Configurable PID controller rate.\n* Added several AUX port modes.\n* Added configurable safe start modes.\n* Added fusion IMU filter.\n* Added constant torque PAS mode.\n* Correct scaling for resistance and inductance.\n* Fixed inductance measurement bug with f_sw > 30k.\n* Corrected inductance measurement algorithm.\n* Fixed max power loss calculation.\n* Better input current estimation.\n* Added raw sampled data mode.\n* Compensate inductance for motor saliency in observer.\n* Added MTPA mode based on measured current.\n* Faster overvoltage protection.\n* Added statistics counters.\n* Added configurable observer offset.\n\n---\n\n### 5.02\n#### Released 2021-01-11\n* IMU calibration improvement.\n* Added COMM_GET_MCCONF_TEMP command.\n* Added bidirectional current command to VESC remote.\n* Fixed motor temperature reading on hw with ADC mux.\n* Added speed PID input ramping option.\n* Added LSM6DS3 IMU support.\n* Added MTPA support. See See: https://github.com/vedderb/bldc/pull/179\n* Added HW_HD75 support.\n* NRF52 UICR write fix.\n* App PPM rework. See https://github.com/vedderb/bldc/pull/192\n* Added bm_reset terminal command.\n* Added bm support for STM32F30x and STM32L47x.\n* App Balance updates. See https://github.com/vedderb/bldc/pull/193\n* Motor current now based on magnitude of both axes.\n* Initial VESC BMS support.\n* Hall sensor interpolation improvement.\n* Made hall sensor filter configurable.\n* Added locking time and ramp up time parameters to sensorless startup.\n* Removed D axis current injection.\n* Initial VESC IO-board support.\n* Added hall sensor interpolation ERPM config option.\n* Use fast speed estimator for RPM limit.\n* Avoid accumulated rounding error when using PID position angle division.\n* Added UAVCAN raw throttle drive mode (current or duty cycle control).\n* Added MT6816 encoder support. See https://github.com/vedderb/bldc/pull/238\n* Added modulation-based D axis current controller gain scaling. Addresses https://github.com/vedderb/bldc/pull/220\n* Added PAS app. See: https://github.com/vedderb/bldc/pull/243\n* Added 100k CAN-baudrate.\n* Added 100k NTC temperature sensor support.\n\n---\n\n### 5.01\n#### Released 2020-04-27\n* Fixed PPM bug in previous release.\n\n---\n\n### 5.00\n#### Released 2020-04-27\n* Dual motor support. VESC-based controllers such as the focbox unity will now work.\n* Fixed bug in cross BEMF decoupling.\n* Disable CC decoupling during flux linkage measurement.\n* Balance app updates. See: https://github.com/vedderb/bldc/pull/141\n* Observer gain calculation update.\n* Better observer gain scaling. This has a large impact on some motors.\n* Added test build flag, that is transmitted with the FW Version command.\n* Detect all bug fix.\n* Added COMM_SET_BATTERY_CUT command.\n* Added CAN_PACKET_SHUTDOWN CAN-command.\n* GPDRIVE output sample fix.\n* Some ISR optimization.\n* Updated ChibiOS to version 3.0.5.\n* Increased USB thread priority to avoid freeze during connect/disconnect on windows.\n* Smooth current ramping during resistance measurement.\n* Moved fault stop to thread, and added SPI mutexes to DRV drivers.\n* Smooth current ramping in flux linkage measurement and sensor detection.\n* Added hall_analyze terminal command.\n* Motor temperature filtering bug fix.\n* Inductance measurement scaling fix.\n* Better flux linkage measurement.\n* Improved battery level and range estimation.\n* Use fast speed estimator for encoder sensorless transition.\n* Signigicantly improved hall sensor transitions and interpolation.\n* More filtering on the motor temperature.\n* Added IMU orientation calibration support: https://github.com/vedderb/bldc/pull/158\n* Added mcconf_l_duty_start so that the current can be limited smoothly when reaching max speed.\n* Allow throttle in opposite direction even after passing speed limit for PPM and VESC Remote apps.\n\n---\n\n### 4.02\n#### Released 2020-03-06\n* Position PID fix (most notable on multiturn encoders).\n* App balance updates. See https://github.com/vedderb/bldc/pull/138.\n* Changed FOC time constant back to 1000 us.\n* Do not count AS5047 all ones as fault.\n* Improved axis decoupling and integrator windup protection. Should prevent wobbles.\n\n---\n\n### 4.01\n#### Released 2020-02-01\n* Leave debug mode on NRF5x after disconnect to avoid excess power consumption before power cycle.\n* Added encoder_clear_errors and encoder_clear_multiturn terminal commands.\n* Initialize current offsets to 2048 to avoid a fault code to be logged at boot.\n* Added 10K, 20K, 50K and 75K CAN baud rates.\n* Added very basic TS5700N8501 multiturn mode.\n\n---\n\n### 4.00\n#### Released 2020-01-28\n* Added support for HFI to track motor position at 0 speed without sensors. This is the main new feature of FW 4.\n* Fixed CAN-bug in VESC Remote.\n* Reset current integrator when leaving duty cycle control mode. Fixes braking issue https://github.com/vedderb/bldc/issues/125.\n* More accurate and faster inductance measurement.\n* Ability to measyre ld - lq. Useful for MTPA in future firmwares.\n* Reset shutdown when uploading FW data.\n* Added CAN-bride and COMM_CAN_FWD_FRAME.\n* Added CAN_PACKET_POLL_TS5700N8501_STATUS to poll most relevant data last received from the TS5700N8501 encoder.\n* Added TS57N8501 ABM, SF and ALMC to encoder terminal command.\n\n---\n\n### 3.66\n#### Released 2020-01-12\n* Added support for HW 100/250.\n* Added uptime terminal command.\n* Added some delays to DRV8323s SPI driver.\n* Added SWD support for NRF52840 with idcode 0x015B.\n\t* TODO: Have a look at https://github.com/blacksphere/blackmagic/commit/302ff20a6d5b806c09e0ca7e996beab3ef3596f4.\n* Fixed INVERTED_SHUNT_POLARITY for BLDC.\n* Added decoupling to FOC current controller.\n* Better motor tracking at high ERPM and low Fsw.\n* Made uart and permanent uart more independent.\n* Do not write to USB if cable has not been connected.\n* Added timeout to USB write.\n* Better FOC current control integrator windup protection.\n* Added FOC observer type selection options.\n* Print TS5700N8501 position in encoder terminal command.\n\n---\n\n### 3.65\n#### Released 2019-12-22\n* Added support for PTC motor temperature sensor (e.g. KTY84)\n* APP_PPM sleep fix. Should solve CAN issues.\n\n---\n\n### 3.64\n#### Released 2019-12-19\n* Added support for HW60_MK3\n* Disable shutdown sampling when the watchdog runs slowly.\n* Added COMM_SET_CURRENT_REL.\n* Added support for boot/ok signal.\n* Added unused mode for aux port.\n* Fixed positive ramping time setting.\n* Changed PPM timeout handling.\n* IRQ priority fix: SYSTICK < UART < MCPWM. Possibly related to http://www.chibios.com/forum/viewtopic.php?f=3&t=4665.\n\n---\n\n### 3.63\n#### Released 2019-12-05\n* NRF remote power meter is now unaffected by temperature decrease and speed limits.\n* Added LZO compression support to firmware upload, making firmware updates 30% - 50% faster.\n* Added LZO compression support to SWD upload.\n* Made serial interrupts priority higher than PWM so that higher speed UART is possible.\n* Added support for TS5700N8501 encoder (via COMM port).\n* Better observer gain calculation.\n\n---\n\n### 3.62\n#### Released 2019-09-27\n* Added COMM_BM_MEM_READ.\n* Merged EUC app (experimental).\n* Fixed NRF remote reverse bug.\n* Do not stop FOC on configuration updates if not needed.\n\n---\n\n### 3.61\n#### Released 2019-09-09\n* Added PPM_CTRL_TYPE_CURRENT_SMART_REV mode.\n\n---\n\n### 3.60\n#### Released 2019-09-08\n* Fixed IMU9x50 bug.\n* Unrigester ICM20948 terminal callbacks when unused.\n* Added experiment plot functions.\n* Added D and Q axis voltage to RT data.\n* Added smart reverse function to nunchuk app.\n\n---\n\n### 3.59\n#### Released 2019-09-03\n* Added more data to MOTE_PACKET_ALIVE.\n* Added app template.\n* Added function to unregister terminal callbacks.\n* Added BMI160 support.\n* Added support for the VESC HD.\n* Added support for SWD programming permanent NRF.\n* Encoder SW SPI fix.\n* Slightly faster boot.\n* Moved custom HW and APP configurations to conf_general.h.\n* Added support for passing HW and APP default configuration as make arguments.\n* Added SW shutdown support.\n* Added command to erase bootloader.\n* Added function to stop IMU threads, so that IMUs can be switched during runtime.\n* Only generate encoder fault when the ERPM is low enough to use the encoder.\n* Added many IMU and AHRS settings to appconf.\n* Re-initialize IMU when appconf is written.\n* Added imu_gyro_info terminal command.\n\n---\n\n### 3.58\n#### Released 2019-07-01\n* Set motor to FOC mode after successful FOC detection instead of the default type for the hardware.\n* APP_ADC: Do not send brake command over CAN if config.multi_esc is not set.\n* APP_PPM: Make pulses invalid if they are above 150 % instead of 120 %.\n* Introduced a new control mode that allows reverse with hysteria (@ackmaniac port)\n\n---\n\n### 3.57\n#### Released 2019-05-16\n* Added CAN status message 5 with input voltage and tachometer data.\n* Fix github issue https://github.com/vedderb/bldc/issues/94.\n* Use default F_SW for HW after autodetect FOC.\n\n---\n\n### 3.56\n#### Released 2019-05-03\n* Fixed current offset fault bug in non-FOC mode.\n* Multiple IMU support.\n* Added support for the ICM-20948 IMU.\n* Decreased ERPM cut in open loop flux linkage measurement.\n\n---\n\n### 3.55\n#### Released 2019-04-26\n* Initial sin/cos encoder support.\n* New ADC control mode.\n* Virtual motor support.\n* Disable chuk cruise control on dropouts.\n* Fix multiple VESCs over CAN duty cycle mode.\n* Added boot and runtime flash memory CRC integrity check.\n* Updated chuk RPM filter and moved it to the beginning of the output thread.\n* Decreased chuk output thread rate from 1 kHz to 200 Hz.\n* Added mpu_read_reg terminal command.\n* Fixed DRV8301 fault readout bug.\n* Added unbalanced current detection.\n* Added high current offset detection.\n\n---\n\n### 3.54\n#### Released 2019-03-31\n* Added mcpwm_foc_set_openloop_duty and mcpwm_foc_set_openloop_duty_phase.\n* Added blackmagic probe SWD output to program other MCUs.\n\t* Can be used to flash bricked VESCs from a working one.\n\t* Can be used to make a custom NRF5x module.\n\n---\n\n### 3.53\n#### Released 2019-03-20\n* Limit foc_current_filter_const range to prevent damage due to bad configuration.\n* Set default NRF speed to 1 Mbit/s.\n* Use lower switching frequency when detecting resistance to reduce deat-time distortion.\n* Don't enable temperature compensation in auto detection by default.\n\n---\n\n### 3.52\n#### Released 2019-03-10\n* Added support for second revision of HW75/300 with separate UART for NRF51.\n* Added COMM_TERMINAL_CMD_SYNC, which does not drop commands when busy.\n* Added option to disable permanent UART.\n* Moved TIM5 to own file, and use it from other places.\n* Removed need for TIM2 in mcpwm.\n* Added utilization percentage to threads terminal command.\n* Added IMU interface.\n* Added support for the MPU9150 and MPU9250.\n* Added COMM_GET_IMU_DATA.\n\n---\n\n### 3.51\n#### Released 2019-03-04\n* Fixed AS5047 error rate bug at position 0.\n* Increased threshold for AS5047 fault to 5 %.\n* Set correct V_REG value for HW 75/300.\n* Better command processing.\n* Proper scaling when setting relative currents and acceleration and braking currents are different.\n\n---\n\n### 3.50\n#### Released 2019-03-01\n* AS5047 parity check and fault code on error rates > 1 %.\n* Signature on mc and app configuration.\n* FOC loop frequency truncation on all hardwares.\n\n---\n\n### 3.49\n#### Released 2019-03-01\n* New watchdog implementation.\n* HW updates.\n* Fixed DC motor current sampling issue.\n* Deadtime in nanoseconds instead of register value.\n* Use fastest ramping time when throttle is applied.\n\n---\n\n### 3.48\n#### Released 2019-02-18\n* Added pairing flag to appconf.\n* Decreased CAN TX timeout.\n\n---\n\n### 3.47\n#### No official release\n* Current percentage limits.\n* Mcconf_temp based on current scale instead of absolute current.\n* Removed battery current from mcconf_temp.\n* Added current scale parameter.\n* Different braking behavior: prefer cogging over locking the brakes.\n\n---\n\n### 3.46\n#### No official release\n* DC motor RPM measurement and RPM control when using encoder.\n* Support for configurable current low pass filter.\n* Much better recovery when failing to decode packets.\n* Run all detect functions in separate thread.\n* Fixed bug introduced when adding support for dual UARTs.\n* Added support for reverse state on NRF remote.\n* Support to disable app output for a specified time.\n\n---\n\n### 3.45\n#### No official release\n* Default CAN ID from UUID, and hook to define it in hwconf.\n* CAN ping support.\n* Simultaneous firmware update over CAN-bus.\n* Fully automated motor detection, based on maximum motor power losses.\n* Sensor autodetection and configuration support.\n* Softer encoder detection.\n* Better NRF_EXT support.\n* New more reliable flux linkage measurement.\n* Simpler to add hardware versions to build system.\n* More DAS hardware support.\n* DRV8323s support.\n* Initial UAVCAN support.\n* Moved from uart to serial driver to avoid DMA conflicts.\n* Support for permanent UART.\n\n---\n\n### 3.44\n#### No official release\n* NRF_EXT commands support.\n\t* Use NRF51822 with ESB remotes.\n* Different radio channel for NRF pairing.\n\n---\n\n### 3.43\n#### No official release\n* Added battery ah to setup info.\n* Changed tacho values in COMM_GET_VALUES_SETUP to meters.\n* Added battery wh COMM_GET_VALUES_SETUP.\n* Better remaining battery capacity calculation.\n\n---\n\n### 3.42\n#### No official release\n* Added setup info parameters:\n\t* Motor Poles\n\t* Gear Ratio\n\t* Wheel Diameter\n\t* Battery Type\n\t* Battery Cells\n* Added more CAN status messages.\n* Updated speed PID to start properly when braking is disabled.\n* Added COMM_GET_VALUES_SETUP.\n* Added COMM_SET_MCCONF_TEMP.\n* Added COMM_SET_MCCONF_TEMP_SETUP.\n* Added COMM_GET_VALUES_SELECTIVE.\n* Added COMM_GET_VALUES_SETUP_SELECTIVE.\n\n---\n\n### 3.41\n#### No official release\n* First general purpose DC output implementation.\n\n---\n\n### 3.40\n#### Released 2018-07-23\n* Added motor controller ID to COMM_GET_VALUES.\n\n---\n\n### 3.39\n#### Released 2018-07-06\n* Updated HW75_300.\n* Added AUX output support.\n\n---\n\n### 3.38\n#### Released 2018-04-22\n* Fixed temperature limit bug when the acceleration and brake current limits are different in magnitude.\n\n---\n\n### 3.37\n#### Released 2018-03-24\n* Temperature compensation on KI in addition to the observer resistance.\n* Configurable FOC current filter (useful for slow abs max current setting).\n\n---\n\n### 3.36\n#### No official release\n* Added handbrake current commands to the simple CAN interface.\n* Added D-term filter to position and speed controllers.\n\n---\n\n### 3.35\n#### Released 2018-02-17\n* Added option to disable nRF transmission (option in Transmit Power parameter).\n* Fixed servo output driver for all hardwares and removed software servo driver.\n\n---\n\n### 3.34\n#### Released 2018-01-24\n* Added motor PID position to COMM_GET_VALUES.\n* Inverted direction angle normalization in mc_interface.\n* Use relative current mode in APP_ADC to support multiple VESCs with different current limits.\n\n---\n\n### 3.33\n#### Released 2017-11-08\n* Fixed CAN-bus baud rate update.\n\n---\n\n### 3.32\n#### Released 2017-11-08\n* Added CAN-bus baud rate setting.\n\n---\n\n### 3.31\n#### Released 2017-10-27\n* Option to decrease temperature limits during acceleration to still have braking torque left.\n* Added PID speed control mode to ADC app.\n\n---\n\n### 3.30\n#### Released 2017-10-20\n* Activated iterative observer for better operation at high ERPM.\n* Check for NAN and truncate some FOC variables.\n* Speed controller windup protection improvement.\n\n---\n\n### 3.29\n#### Released 2017-09-21\n* Disabled throttle limit scaling for now.\n* Increased packet timeout.\n\n---\n\n### 3.28\n#### Released 2017-09-06\n* DC_CAL timeout.\n* Added board configuration file to avoid braking at boot.\n* Shorter default fault stop time.\n* Lower default PPM ramping time.\n* Configurable beta value for motor thermistor.\n* Individual throttle curves for acceleration and braking.\n\n---\n\n### 3.27\n#### Released 2017-09-04\n* Watt hour reset bug fix\n* Changed the way custom applications are implemented.\n* FOC: high current sampling mode.\n\n---\n\n### 3.26\n#### No official release\n* Current limit bug fix. It is now possible to apply break past the RPM limits.\n* Openloop RPM calculation bug fix.\n\n---\n\n### 3.25\n#### No official release\n* APP multi-VESC PID control: send current instead of duty cycle for better load sharing.\n* Added relative current commands to mc_interface and comm_can.\n* APP ADC: added mode ADC_CTRL_TYPE_CURRENT_REV_BUTTON_BRAKE_ADC.\n* APP ADC: changed behavior when throttle and brake ADC channels are used simultaneously for smoother combination.\n* APP ADC: ramping support.\n* Flux linkage measurement: Added extra try with high integrator value.\n\n---\n\n### 3.24\n#### No official release\n* Changed back inductance calculation since that seems to work much better in practise. (TODO: Have a closer look at why)\n\n---\n\n### 3.23\n#### No official release\n* Improved inductance measurement (bug fix).\n* Multiple tries with different settings on flux linkage measurement.\n* Observer improvements for high speed operation and better performance across the whole speed range.\n* Compile time option to disable override limits.\n\n---\n\n### 3.22\n#### No official release\n* Added hardware-specific limits to configuration parameters.\n* Permanent NRF bug fix.\n\n---\n\n### 3.21\n#### No official release\n* Fixed regression in PID speed controller.\n\n---\n\n### 3.20\n#### No official release\n* PID speed control: Set prev_error to error when the PID is off to make the start smoother.\n* Improved spinup algorithm for flux linkage and bldc parameter measurement.\n* APP ADC: Configurable center voltage for channel 1.\n* APP_UARTCOMM: Keep the processing thread running when stopping the app in case the configuration is made from the UART port itself.\n* Commands: Return results of long running commands to the port they came from even if commands come in between and change the last port.\n\n---\n\n### 3.19\n#### No official release\n* Added terminal plugin hook implementation. Inspired by https://github.com/vedderb/bldc/pull/28\n* Moved sampling buffers to CCM to free some RAM.\n* Added hardware info terminal command.\n* NRF init SPI check fix.\n* Sampled data is now transmitted in floating point with scaling done at the VESC. This avoids hard-coded scaling in VESC Tool.\n\n---\n\n### 3.18\n#### No official release\n* NRF init SPI check.\n* Permanent NRF: reconfigure NRF pins to SPI pins on init failure in case the permanent NRF is not mounted and behave as if there is no permanent NRF.\n\n---\n\n### 3.17\n#### No official release\n* Temperature filtering.\n* FOC: temperature resistance compensation.\n\n---\n\n### 3.16\n#### No official release\n* FOC: stator saturation compensation parameter.\n* FOC: Another update for the fix for throttle limits to prevent loosing range at high speed when the battery current limit is lower than the motor current limit.\n* DRV8301: over current protection settings added to configuration.\n* DRV8301: Reset command andded to terminal.\n* DRV8301: Log fault code read over SPI.\n* DRV: Check for faults in ADC interrupt to catch the state as fast as possible.\n* Send phase samples as well with the sampling function.\n* New sampling modes for debugging.\n* BLDC and DC: Configurable switching frequency\n* FOC detect: increase minimum switching frequency for motor spinup to make it possible to detect high kv motors at high voltage.\n* FOC: observer gain scaling parameter for low modulation.\n\n---\n\n### 3.15\n#### No official release\n* FOC: added the option for FOC sampling in both V0 and V7 to mcconf, so that it can be changed without recompiling the firmware.\n* FOC: tweaked repetition counter and preload to get cleaner waveforms with low latency.\n* FOC: Input voltage filterting and vd/vq filtering while undriven for more stable performance.\n\n---\n\n### 3.14\n#### No official release\n* Different throttle curve modes\n* Improved FOC sensorless startup.\n\n---\n\n### 3.13\n#### No official release\n* Throttle curve for PPM, ADC and Nunchuk.\n* Updated fix for throttle limits to prevent loosing range at high speed when the battery current limit is lower than the motor current limit.\n* APP PPM ramping.\n* APP ADC and PPM current range bug fix for some control modes.\n\n---\n\n### 3.12\n#### No official release\n* APP PPM throttle center setting.\n\n---\n\n### 3.11\n#### No official release\n* BLDC detect: disable direction inversion before detecting parameters.\n* FOC speed control: remove supply voltage scaling since that does not make any sense in current control mode.\n* BLDC speed control: added current-based speed controller option.\n* BLDC: heavier RPM filtering.\n* Speed control: option to disable braking in speed control mode.\n* Added wattage limits. Useful for following laws for electric vehicles in some regions.\n* Use override current limits to scale throttle inputs in apps. Will prevent the throttle from loosing rage at speed if e.g. the battery current limits are lower than the motor current limits.\n\n---\n\n### 3.10\n#### Released 2016-11-06\n* BLDC: removed cycles_running variable.\n* BLDC: update ADC sampling in correct order to avoid corrupt samples when the switching frequency changes a lot at once.\n* Terminal: print fault duty cycle state with one extra decimal.\n\n---\n\n### 3.09\n#### Released 2016-11-06\n* Configuration option for inverting the motor direction.\n* STM32 96-bit unique ID readout.\n\n---\n\n### 3.08\n#### No official release\n* Communication protocol update for floating point variables. This breaks almost all compatibility with old firmwares.\n\n---\n\n### 3.07\n#### Released 2016-11-04\n* Delay after app and motor conf write.\n\t* Fixes NRF bug.\n\t* Fixes glitches if throttle is given while updating the configurations.\n* Lock mc_interface while storing configuration.\n* Nunchuk app local timeout.\n\t* Prevents the output thread from blocking other outputs after being used before.\n* Lock MC interface while storing configurations to flash.\n\n---\n\n### 3.06\n#### No official release\n* spi_sw for NRF stop bug fix.\n\n---\n\n### 3.05\n#### No official release\n* App NRF pairing.\n* App nunchuk chuk error restore bug fix.\n\n---\n\n### 3.04\n#### No official release\n* HW version built into firmware.\n\t* Allows VESC Tool to only list firmwares compatible with the hardware.\n\n---\n\n### 3.02\n#### No official release\n* hw_60 support.\n* hw_das support.\n* DRV8301 support.\n\t* SPI implementation.\n\t* Some terminal commands.\n* DRV8313 support.\n* 3 shunt support.\n* Phase shunt support.\n* Global RPM limit for both BLDC and FOC.\n* Hall sensor software filtering.\n* SPI software filtering.\n* The software filters remove the need for hardware filtering on the sensor port, making it work for all different sensors without modification.\n* Handbrake function for FOC (open loop braking).\n* FOC updates and fixes.\n\t* Current control signs.\n\t* Control loop integrator fixes.\n\t* Phase delay compensation and minimization.\n\t* More consistent flux linkage detection.\n\t* Resistance and inductance measurement bug fix that could cause a reboot.\n\t* Timer sampling improvement and cleanup.\n\t* Support for sampling in V0 and V7 when using phase shunts.\n* Fix reboot on over temperature fault code.\n* Motor temperature measurement and soft backoff.\n* Terminal command for rotating magnet field generation (ACIM experimentation).\n* Prevent motor start command during initialization.\n* Hardware specific default configuration support.\n* Stop functionality for apps so that reboots are not required anymore when changing app.\n* EEPROM emulation bug fix: https://github.com/vedderb/bldc/issues/27\n\n---\n\n### 3.00\n#### Released 2016-06-27\n* HW60 support\n* 3 low/high side shunt support\n* permanent NRF option\n\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 5.0888671875,
          "content": "So you want to contribute to the VESC firmware? That's great! Benjamin (the creator of the VESC) welcomes more people to join the development.\n\nBut Benjamin is a busy man, and to reduce the workload of reviewing patches, it's important that your code follows the guidelines below. These are meant to make _you_ work a bit harder, so that Benjamin can work a bit less (and use his time to develop the VESC instead of trying to fix your patches :).\n\n\n=== Process ===\n\nPlease discuss your ideas in the forum (http://vesc-project.com/forum) so that you don't just dump a large amount of code on Benjamin out of nowhere. Try to reach some kind of consensus with others on the forum about scope and functionality of your contribution.\n\nWhen Benjamin is prepared for your patch, and you have checked that it follows these guidelines, contribute it through a github pull request.\n\n\n=== Create clean patches ===\n\nWhen committing code to your git repo, it's easy to forget stuff: maybe you forget to add a new file, maybe you leave some debug code that you remove with a later commit, maybe you find spelling errors, and of course you will probably find bugs in the new code later, that needs to be fixed. This can all lead to a lot of commits in the style of:\n\n\t\"Fixed code I broke for other hardware\"\n\nand\n\n\t\"Fixed typo in new commutation implementation\"\n\nThese types of commits just mess up the tree, and makes it hard to see what's actually been done to the code. Fortunately, there is a great tool in git that you can use to clean these up: 'git rebase -i <parent-hash>'! It's quite easy to use: once run, you get a list of all commits after <parent-hash>, and have the option to move commits around and also to squash them (make them as one). So you can group the \"main\" commit for a logical change together with all its \"fix-the-code-I-broke\" commits, and then squash them together to one, well functioning commit!\n\nPlease do this, so that each commit represents a logical, well-functioning change.\n\nSee INTERACTIVE MODE in 'man git-rebase' for detailed info. Here is a good article as well:\nhttp://www.siliconfidential.com/articles/15-seconds-to-cleaner-git-history/\n\n\n=== Describe the changes ===\n\nIn the commit messages, describe the technical detail of the change(s) you make.\n\nBe as specific as possible. The WORST descriptions possible include things like \"update bldc code\", \"bug fix for FOC\", or \"this patch includes updates for the observer. Please apply.\"\n\nYour commit message(s) will end up in the commit log for the VESC firmware, and someone reading the log a year later should be able to infer what each commit does.\n\n\n=== Coding Style ===\n\nMake sure your coding style matches the style in the existing code. Among other things, that means:\n\n* Use tabs for indentation (make sure your editor does not replace tabs with spaces). Never use spaces before tabs. Preferably use a tab width of 4.\n\n* Place the opening brace '{' of code blocks on the same line as the preceding text, both after function headers and after control statements:\n\n\tint main(void) {\n\nand\n\n\tif (send_func) {\n\n* Always use braces, even for single-line blocks:\n\n\tif (send_func) {\n\t\tsend_func(data, len);\n\t}\n\n* Write \"else\" on the same line as both the preceding and the following brace:\n\n\t} else {\n\n* Use C99-style single-line comments (\"// ...\", not \"/* ... */\"):\n\n\tstatic mc_configuration mcconf, mcconf_old; // Static to save some stack space\n\nand\n\n\t// Lock the system and enter an infinite loop. The watchdog will reboot.\n\n* If you write function comments, write them Doxygen-style.\n\n* Line lengths should be kept below 90 characters if possible, but that is not a strict requirement if braking the line looks ugly.\n\n* Source files should end with a new line.\n\n* Avoid more than one conscutive empty line.\n\n\n=== Make sure that all hardware versions and configuration variations work ===\n\nWhen making updates it is easy to break things for different configurations. In order to make sure that the firmware at least builds for different hardwares and configurations it is a good idea to run the build_all/rebuild_all script and ensure that is finished without warnings and/or errors.\n\n\n=== Other guidelines ===\n\n* Use single precision floating point operations, as the FPU in the STM32F4 is 32 bits only. Double precision operations can take up to 50 times (!) longer.\n - float instead of double\n - Use the math library functions ending with f (sinf, cosf, powf, fabsf etc.)\n\n* Make sure that the code compiles without warnings.\n\n* Avoid dynamic memory allocation if possible, so that the RAM usage is known at compile time.\n\n* If the code crashed randomly, use the ChibiOS state checker:\nhttps://www.chibios.org/dokuwiki/doku.php?id=chibios:documentation:books:rt:kernel_debug#system_state_checks\n\n\n=== Be patient, and don't take criticism personally ===\n\nBe prepared to have to rework your contribution several times before it is considered acceptable. Once code is in, it's difficult to get it reworked for better quality, so it's important that this is done before the code is even accepted. Don't take it personally; instead appreciate that it is this peer review that makes the code great in the end!\n\n\n\nThanks for reading!\n"
        },
        {
          "name": "ChibiOS_3.0.5",
          "type": "tree",
          "content": null
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 11.669921875,
          "content": "# Makefile for Rootloader project\n.DEFAULT_GOAL := help\n\nWHEREAMI := $(dir $(lastword $(MAKEFILE_LIST)))\nROOT_DIR := $(realpath $(WHEREAMI)/ )\n\n# Define a recursive wildcard function\n# C.f. https://stackoverflow.com/a/18258352\nrwildcard=$(foreach d,$(wildcard $(1:=/*)),$(call rwildcard,$d,$2) $(filter $(subst *,%,$2),$d))\n\n# Get the raw paths for all *.h files\nRAW_TARGET_PATHS := $(call rwildcard,$(ROOT_DIR)/hwconf,*.h)\n\n# Get the target paths by filtering out any core.h files, then stripping extra whitespace\nTARGET_PATHS := $(strip $(filter-out %core.h,$(RAW_TARGET_PATHS)))\n\n# Strip the paths down to just the names. Do this by first using `notdir` to remove the paths, then the prefix (hw_), then remove the suffix (.h). Finally, sort into lexical order.\nALL_BOARD_NAMES := $(sort $(subst .h,,$(subst hw_,,$(filter hw_%, $(notdir $(TARGET_PATHS))))))\n\n# configure some directories that are relative to wherever ROOT_DIR is located\nTOOLS_DIR := $(ROOT_DIR)/tools\nMAKE_DIR := $(ROOT_DIR)/make\nBUILD_DIR := $(ROOT_DIR)/build\nDL_DIR    := $(ROOT_DIR)/downloads\n\n# import macros common to all supported build systems\ninclude $(ROOT_DIR)/make/system-id.mk\n\n# import macros that are OS specific\ninclude $(ROOT_DIR)/make/$(OSFAMILY).mk\n\n# include the tools makefile\ninclude $(ROOT_DIR)/make/tools.mk\n\n# Clean out undesirable variables from the environment and command-line\n# to remove the chance that they will cause problems with our build\ndefine SANITIZE_VAR\n$(if $(filter-out undefined,$(origin $(1))),\n  $(info *NOTE*      Sanitized $(2) variable '$(1)' from $(origin $(1)))\n  MAKEOVERRIDES = $(filter-out $(1)=%,$(MAKEOVERRIDES))\n  override $(1) :=\n  unexport $(1)\n)\nendef\n\n# These specific variables can influence gcc in unexpected (and undesirable) ways\nSANITIZE_GCC_VARS := TMPDIR GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\nSANITIZE_GCC_VARS += CFLAGS CPATH C_INCLUDE_PATH CPLUS_INCLUDE_PATH OBJC_INCLUDE_PATH DEPENDENCIES_OUTPUT\nSANITIZE_GCC_VARS += ARCHFLAGS\n$(foreach var, $(SANITIZE_GCC_VARS), $(eval $(call SANITIZE_VAR,$(var),disallowed)))\n\n# These specific variables used to be valid but now they make no sense\nSANITIZE_DEPRECATED_VARS := FOO_BAR\n$(foreach var, $(SANITIZE_DEPRECATED_VARS), $(eval $(call SANITIZE_VAR,$(var),deprecated)))\n\n# Decide on a verbosity level based on the V= parameter\nexport AT := @\n\nifndef V\nexport V0    :=\nexport V1    := $(AT)\nelse ifeq ($(V), 0)\nexport V0    := $(AT)\nexport V1    := $(AT)\nelse ifeq ($(V), 1)\nendif\n\n\n##############################\n#\n# Help instructions\n#\n##############################\n.PHONY: help\nhelp:\n\t@echo \"\"\n\t@echo \"   This Makefile is known to work on Linux and Mac in a standard shell environment.\"\n\t@echo \"\"\n\t@echo \"   Here is a summary of the available targets:\"\n\t@echo \"\"\n\t@echo \"   [Tool Installers]\"\n\t@echo \"     arm_sdk_install      - Install the GNU ARM gcc toolchain\"\n\t@echo \"     qt_install           - Install the all tools for Qt\"\n\t@echo \"\"\n\t@echo \"   [Big Hammer]\"\n\t@echo \"     all_fw               - Build firmware for all boards\"\n\t@echo \"     all_fw_package       - Packaage firmware for boards in package list\"\n\t@echo \"\"\n\t@echo \"   [Unit Tests]\"\n\t@echo \"     all_ut               - Build all unit tests\"\n\t@echo \"     all_ut_xml           - Run all unit tests and capture all XML output to files\"\n\t@echo \"     all_ut_run           - Run all unit tests and dump XML output to console\"\n\t@echo \"\"\n\t@echo \"   [Firmware]\"\n\t@echo \"     fw   - Build firmware for default target\"\n\t@echo \"                            supported boards are: $(ALL_BOARD_NAMES)\"\n\t@echo \"     fw_<board>           - Build firmware for target <board>\"\n\t@echo \"     PROJECT=<target> fw  - Build firmware for <target>\"\n\t@echo \"     fw_<board>_clean     - Remove firmware for <board>\"\n\t@echo \"     fw_<board>_flash     - Use OpenOCD + SWD/JTAG to write firmware to <target>\"\n\t@echo \"\"\n\t@echo \"     fw_custom            - Build firmware with custom hwconf file locations, you must specify these by setting the HW_SRC and HW_HEADER variables\"\n\t@echo \"     fw_custom_clean      - Remove firmware for custom\"\n\t@echo \"     fw_custom_flash      - Use OpenOCD + SWD/JTAG to write firmware to custom\"\n\t@echo \"\"\n\t@echo \"   Hint: Add V=1 to your command line to see verbose build output.\"\n\t@echo \"\"\n\t@echo \"   Note: All tools will be installed into $(TOOLS_DIR)\"\n\t@echo \"         All build output will be placed in $(BUILD_DIR)\"\n\t@echo \"\"\n\n\n$(DL_DIR):\n\t$(V1) $(MKDIR) $@\n\n$(TOOLS_DIR):\n\t$(V1) $(MKDIR) $@\n\n##############################\n#\n# Build and Upload\n#\n##############################\n\n# $(1) = destination variable\n# $(2) = Canonical board name all in lower case (e.g. 100_250)\n# $(3) = Target hardware directory\ndefine FIND_TARGET_C_CODE\n   # Remove `_no_limits`\n   $(eval ROOT_TARGET_NAME = $(subst _no_limits,,$(2)))\n\n   # Look for `*_core.c` file\n   ifneq (\"$(wildcard $(3)/hw_*_core.c)\",\"\")\n      # Good luck, there it is!\n      $(1) = $(realpath $(wildcard $(3)/hw_*_core.c))\n   else\n      # There isn't one, so let's hope for the sister `.c` file\n      $(1) = $(realpath $(3)/hw_$(ROOT_TARGET_NAME).c)\n   endif\n\nendef\n\n# $(1) = Canonical board name all in lower case (e.g. 100_250)\n# $(2) = firmware build directory\n# $(3) = firmware name\n# $(4) = git branch name\n# $(5) = git hash (and dirty flag)\n# $(6) = compiler version\n# $(7) [optional] = hw source filepath\n# $(8) [optional] = hw header filepath (must be given/not given if $(7) is given/not given)\ndefine FW_TEMPLATE\n.PHONY: $(1) fw_$(1)\n$(1): fw_$(1)_vescfw\nfw_$(1): fw_$(1)_vescfw\n\nifeq ($(7),)\n  $(1)_HW_DIR = $(dir $(filter %/hw_$(1).h, $(TARGET_PATHS)))\n  $(1)_HW_HEADER = $$($(1)_HW_DIR)/hw_$(1).h\n  \n  $$(eval $$(call FIND_TARGET_C_CODE,$(1)_HW_SRC_FILE,$(1),$$($(1)_HW_DIR)))\nelse\n  $(1)_HW_SRC_FILE = $(7)\n  $(1)_HW_HEADER = $(8)\nendif\n\n$(1)_BUILD_MACROS = -DHW_SOURCE=\\\"$$($(1)_HW_SRC_FILE)\\\" -DHW_HEADER=\\\"$$($(1)_HW_HEADER)\\\" -DGIT_BRANCH_NAME=\\\"$(4)\\\" -DGIT_COMMIT_HASH=\\\"$(5)\\\" -DARM_GCC_VERSION=\\\"$(6)\\\"\nifdef USER_GIT_COMMIT_HASH\n  $(1)_BUILD_MACROS += -DUSER_GIT_COMMIT_HASH=\\\"$(USER_GIT_COMMIT_HASH)\\\"\nendif\nifdef USER_GIT_BRANCH_NAME\n  $(1)_BUILD_MACROS += -DUSER_GIT_BRANCH_NAME=\\\"$(USER_GIT_BRANCH_NAME)\\\"\nendif\n\nfw_$(1)_vescfw: $$($(1)_HW_DIR)\nfw_$(1)_vescfw: $$($(1)_HW_SRC_FILE)\nfw_$(1)_vescfw:\n\t@echo \"********* BUILD: $(1) **********\"\n\t$(V1) $(MKDIR) $(BUILD_DIR)/$(1)\n\t$(V1) $$(MAKE) -f $(MAKE_DIR)/fw.mk \\\n\t\tTCHAIN_PREFIX=\"$(ARM_SDK_PREFIX)\" \\\n\t\tBUILDDIR=\"$(2)\" \\\n\t\tPROJECT=\"$(3)\" \\\n\t\tbuild_args='$$($(1)_BUILD_MACROS)' USE_VERBOSE_COMPILE=no\n\n$(1)_flash: fw_$(1)_flash\nfw_$(1)_flash: fw_$(1)_vescfw fw_$(1)_flash_only\n\n$(1)_flash_only: fw_$(1)_flash_only\nfw_$(1)_flash_only:\n\t@echo \"********* PROGRAM: $(1) **********\"\n\t$(V1) openocd -f board/stm32f4discovery.cfg -c \"reset_config trst_only combined\" -c \"program $(2)/$(3).elf verify reset exit\"\n\n.PHONY: $(1)_clean\n$(1)_clean: fw_$(1)_clean\nfw_$(1)_clean: TARGET=fw_$(1)\nfw_$(1)_clean: OUTDIR=$(BUILD_DIR)/$$(TARGET)\nfw_$(1)_clean:\n\t$(V0) @echo \" CLEAN      $$@\"\nifneq ($(OSFAMILY), windows)\n\t$(V1) [ ! -d \"$(BUILD_DIR)/$(1)\" ] || $(RM) -r \"$(BUILD_DIR)/$(1)\"\n\t$(V1) [ ! -d \"$(ROOT_DIR)/.dep\" ] || $(RM) -r \"$(ROOT_DIR)/.dep\"\nelse\n\t$(V1) powershell -noprofile -command \"& {if (Test-Path $(BUILD_DIR)/$(1)) {Remove-Item -Recurse $(BUILD_DIR)/$(1)}}\"\n\t$(V1) powershell -noprofile -command \"& {if (Test-Path $(ROOT_DIR)/.dep) {Remove-Item -Recurse $(ROOT_DIR)/.dep}}\"\nendif\nendef\n\nclear_option_bytes:\n\t$(V1) openocd -f board/stm32f4discovery.cfg -c \"init\" -c \"stm32f2x unlock 0\" -c \"mww 0x40023C08 0x08192A3B; mww 0x40023C08 0x4C5D6E7F; mww 0x40023C14 0x0fffaaed\" -c \"exit\"\n\n#program with olimex arm-usb-tiny-h and jtag-swd adapter board. needs openocd>=0.9\nupload-olimex: fw\n\t$(V1) openocd -f interface/ftdi/olimex-arm-usb-tiny-h.cfg -f interface/ftdi/olimex-arm-jtag-swd.cfg -c \"set WORKAREASIZE 0x2000\" -f target/stm32f4x.cfg -c \"program build/$(PROJECT).elf verify reset\"\n\nupload-pi: fw\n\t$(V1) openocd -f pi_stm32.cfg -c \"reset_config trst_only combined\" -c \"program build/$(PROJECT).elf verify reset exit\"\n\nupload-pi-remote: fw\n\t$(V1) ./upload_remote_pi build/$(PROJECT).elf ted 10.42.0.199 22\n\ndebug-start:\n\t$(V1) openocd -f stm32-bv_openocd.cfg\n\nsize: build/$(PROJECT).elf\n\t@$(SZ) $<\n\n# Generate the targets for whatever boards are in each list\nFW_TARGETS := $(addprefix fw_, $(ALL_BOARD_NAMES))\n\n.PHONY: all_fw all_fw_clean\nall_fw:        $(addsuffix _vescfw, $(FW_TARGETS))\nall_fw_clean:  $(addsuffix _clean,  $(FW_TARGETS))\n\n# Expand the firmware rules\n$(foreach board, $(ALL_BOARD_NAMES), $(eval $(call FW_TEMPLATE,$(board),$(BUILD_DIR)/$(board),$(board),$(GIT_BRANCH_NAME),$(GIT_COMMIT_HASH)$(GIT_DIRTY_LABEL),$(ARM_GCC_VERSION),,)))\n\n.PHONY: fw_custom fw_custom_check\n\nifndef HW_SRC\nfw_custom_check:\n\t$(error \"HW_SRC not defined: you must set HW_SRC and HW_HEADER to build fw_custom\")\nelse ifndef HW_HEADER\nfw_custom_check:\n\t$(error \"HW_HEADER not defined: you must set HW_SRC and HW_HEADER to build fw_custom\")\nendif\nfw_custom: fw_custom_check\n$(eval $(call FW_TEMPLATE,custom,$(BUILD_DIR)/custom,custom,$(GIT_BRANCH_NAME),$(GIT_COMMIT_HASH)$(GIT_DIRTY_LABEL),$(ARM_GCC_VERSION),$(HW_SRC),$(HW_HEADER)))\n\n##############################\n#\n# Packaging\n#\n##############################\n\n.PHONY: all_fw_package\nall_fw_package: all_fw all_fw_package_clean\n\t$(V0) @echo \" PACKAGE        $(ROOT_DIR)/package/*\"\n\n# Place all firmware files into `./package` directory\n\t$(V1) $(PYTHON) package_firmware.py\n\n# Find all the leftover object and lst files\n\t$(eval BUILD_CRUFT := $(call rwildcard,$(ROOT_DIR)/build,*.lst *.o))\n\n# Delete the cruft files, so as not to unnecessarily consume GB of space\nifneq ($(OSFAMILY), windows)\n\t$(V1) $(RM) $(BUILD_CRUFT)\nelse\n\t$(V1) powershell -noprofile -command \"& {Remove-Item $(BUILD_CRUFT)}\"\nendif\n\n.PHONY: all_fw_package_clean\nall_fw_package_clean:\n\t$(V0) @echo \" CLEAN        $(ROOT_DIR)/package/*\"\nifneq ($(OSFAMILY), windows)\n\t$(V1) [ ! -d \"$(ROOT_DIR)/package/\" ] || $(RM) -rf $(ROOT_DIR)/package/*\nelse\n\t$(V1) powershell -noprofile -command \"& {if (Test-Path $(ROOT_DIR)/package/*) {Remove-Item -Recurse $(ROOT_DIR)/package/*}}\"\nendif\n\n\n##############################\n#\n# Unit Tests\n#\n##############################\n\nALL_UNITTESTS := utils_math\n\nUT_OUT_DIR := $(BUILD_DIR)/unit_tests\n\n$(UT_OUT_DIR):\n\t$(V1) $(MKDIR) $@\n\n.PHONY: all_ut\nall_ut: $(addsuffix _elf, $(addprefix ut_, $(ALL_UNITTESTS))) $(ALL_PYTHON_UNITTESTS)\n\n.PHONY: all_ut_xml\nall_ut_xml: $(addsuffix _xml, $(addprefix ut_, $(ALL_UNITTESTS)))\n\n.PHONY: all_ut_run\nall_ut_run: $(addsuffix _run, $(addprefix ut_, $(ALL_UNITTESTS))) $(ALL_PYTHON_UNITTESTS)\n\n.PHONY: all_ut_gcov\nall_ut_gcov: | $(addsuffix _gcov, $(addprefix ut_, $(ALL_UNITTESTS)))\n\n.PHONY: all_ut_clean\nall_ut_clean:\n\t$(V0) @echo \" CLEAN      $@\"\n\t$(V1) [ ! -d \"$(UT_OUT_DIR)\" ] || $(RM) -r \"$(UT_OUT_DIR)\"\n\n# $(1) = Unit test name\ndefine UT_TEMPLATE\n.PHONY: ut_$(1)\nut_$(1): ut_$(1)_run\nut_$(1)_gcov: | ut_$(1)_xml\n\nut_$(1)_%: TARGET=$(1)\nut_$(1)_%: OUTDIR=$(UT_OUT_DIR)/$$(TARGET)\nut_$(1)_%: UT_ROOT_DIR=$(ROOT_DIR)/tests/$(1)\nut_$(1)_%: $$(UT_OUT_DIR)\n\t$(V1) $(MKDIR) $(UT_OUT_DIR)/$(1)\n\t$(V1) cd $$(UT_ROOT_DIR) && \\\n\t\t$$(MAKE) -r --no-print-directory \\\n\t\tBUILD_TYPE=ut \\\n\t\tTCHAIN_PREFIX=\"\" \\\n\t\tREMOVE_CMD=\"$(RM)\" \\\n\t\t\\\n\t\tMAKE_INC_DIR=$(MAKE_INC_DIR) \\\n\t\tROOT_DIR=$(ROOT_DIR) \\\n\t\tTARGET=$$(TARGET) \\\n\t\tOUTDIR=$$(OUTDIR) \\\n\t\t\\\n\t\tGTEST_DIR=$(GTEST_DIR) \\\n\t\t\\\n\t\t$$*\n\n.PHONY: ut_$(1)_clean\nut_$(1)_clean: TARGET=$(1)\nut_$(1)_clean: OUTDIR=$(UT_OUT_DIR)/$$(TARGET)\nut_$(1)_clean:\n\t$(V0) @echo \" CLEAN      $(1)\"\n\t$(V1) [ ! -d \"$$(OUTDIR)\" ] || $(RM) -r \"$$(OUTDIR)\"\nendef\n\n# Expand the unittest rules\n$(foreach ut, $(ALL_UNITTESTS), $(eval $(call UT_TEMPLATE,$(ut))))\n\n# Disable parallel make when the all_ut_run target is requested otherwise the TAP/XML\n# output is interleaved with the rest of the make output.\nifneq ($(strip $(filter all_ut_run,$(MAKECMDGOALS))),)\n.NOTPARALLEL:\n$(info *NOTE*     Parallel make disabled by all_ut_run target so we have sane console output)\nendif\n"
        },
        {
          "name": "Project",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.474609375,
          "content": "# VESC firmware\n\n[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)\n[![Travis CI Status](https://travis-ci.com/vedderb/bldc.svg?branch=master)](https://travis-ci.com/vedderb/bldc)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/75e90ffbd46841a3a7be2a9f7a94c242)](https://www.codacy.com/app/vedderb/bldc?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=vedderb/bldc&amp;utm_campaign=Badge_Grade)\n[![Contributors](https://img.shields.io/github/contributors/vedderb/bldc.svg)](https://github.com/vedderb/bldc/graphs/contributors)\n[![Watchers](https://img.shields.io/github/watchers/vedderb/bldc.svg)](https://github.com/vedderb/bldc/watchers)\n[![Stars](https://img.shields.io/github/stars/vedderb/bldc.svg)](https://github.com/vedderb/bldc/stargazers)\n[![Forks](https://img.shields.io/github/forks/vedderb/bldc.svg)](https://github.com/vedderb/bldc/network/members)\n\nAn open source motor controller firmware.\n\nThis is the source code for the VESC DC/BLDC/FOC controller. Read more at\n[https://vesc-project.com/](https://vesc-project.com/)\n\n## Supported boards\n\nAll of them!\n\nCheck the supported boards by typing `make`\n\n```\n[Firmware]\n     fw   - Build firmware for default target\n                            supported boards are: 100_250 100_250_no_limits 100_500...\n```\n\nThere are also many other options that can be changed in [conf_general.h](conf_general.h).\n\n## Prerequisites\n\n### On Ubuntu (Linux)/macOS\n- Tools: `git`, `wget`, and `make`\n- Additional Linux requirements: `libgl-dev` and `libxcb-xinerama0`\n- Helpful Ubuntu commands:\n```bash\nsudo apt install git build-essential libgl-dev libxcb-xinerama0 wget git-gui\n```\n- Helpful macOS tools: \n\n```bash\nbrew install stlink\nbrew install openocd\n```\n\n### On Windows\n- Chocolately: https://chocolatey.org/install\n- Git: https://git-scm.com/download/win. Make sure to click any boxes to add Git to your Environment (aka PATH)\n\n## Install Dev environment and build\n\n### On Ubuntu (Linux)/MacOS\nOpen up a terminal\n1.  `git clone http://github.com/vedderb/bldc.git`\n2.  `cd bldc`\n3.  Continue with [On all platforms](#on-all-platforms)\n\n### On Windows\n\n1.  Open up a Windows Powershell terminal (Resist the urge to run Powershell as administrator, that will break things)\n2.  Type `choco install make`\n3.  `git clone http://github.com/vedderb/bldc`\n4.  `cd bldc`\n5.  Continue with [On all platforms](#on-all-platforms)\n\n### On all platforms\n\n1.  `git checkout origin/master`\n2.  `make arm_sdk_install`\n3.  `make` <-- Pick out the name of your target device from the supported boards list. For instance, I have a Trampa **VESC 100/250**, so my target is `100_250`\n4.   `make 100_250` <-- This will build the **VESC 100/250** firmware and place it into the `bldc/builds/100_250/` directory\n\n## Other tools\n\n**Linux Optional - Add udev rules to use the stlink v2 programmer without being root**\n```bash\nwget vedder.se/Temp/49-stlinkv2.rules\nsudo mv 49-stlinkv2.rules /etc/udev/rules.d/\nsudo udevadm trigger\n```\n\n## IDE\n### Prerequisites\n#### On macOS/Linux\n\n- `python3`, and `pip`\n\n#### On Windows\n- Python 3: https://www.python.org/downloads/. Make sure to click the box to add Python3 to your Environment.\n\n### All platforms\n\n1.  `pip install aqtinstall`\n2.  `make qt_install`\n3.  Open Qt Creator IDE installed in `tools/Qt/Tools/QtCreator/bin/qtcreator`\n4.  With Qt Creator, open the vesc firmware Qt Creator project, named vesc.pro. You will find it in `Project/Qt Creator/vesc.pro`\n5.  The IDE is configured by default to build 100_250 firmware, this can be changed in the bottom of the left panel, there you will find all hardware variants supported by VESC\n\n## Upload to VESC\n### Method 1 - Flash it using an STLink SWD debugger\n\n1.  Build and flash the [bootloader](https://github.com/vedderb/bldc-bootloader) first\n2.  Then `_flash` to the target of your choice. So for instance, for the VESC 100/250: \n```bash\nmake 100_250_flash\n```\n\n### Method 2 - Upload Firmware via VESC tool through USB\n\n1.  Clone and build the firmware in **.bin** format as in the above Build instructions\n\nIn VESC tool\n\n2.  Connect to the VESC\n3.  Navigate to the Firmware tab on the left side menu \n4.  Click on Custom file tab\n5.  Click on the folder icon to select the built firmware in .bin format (e.g. `build/100_250/100_250.bin`)\n\n##### [ Reminder : It is normal to see VESC disconnects during the firmware upload process ]  \n#####  **[ Warning : DO NOT DISCONNECT POWER/USB to VESC during the upload process, or you will risk bricking your VESC ]**  \n#####  **[ Warning : ONLY DISCONNECT your VESC 10s after the upload loading bar completed and \"FW Upload DONE\" ]**\n\n6.  Press the upload firmware button (downward arrow) on the bottom right to start upload the selected firmware.\n7.  Wait for **10s** after the loading bar completed (Warning: unplug sooner will risk bricking your VESC)\n8.  The VESC will disconnect itself after new firmware is uploaded.\n\n## In case you bricked your VESC\nyou will need to upload a new working firmware to the VESC.  \nHowever, to upload a firmware to a bricked VESC, you have to use a SWD Debugger.\n\n\n## Contribute\n\nHead to the [forums](https://vesc-project.com/forum) to get involved and improve this project.\nJoin the [Discord](https://discord.gg/JgvV5NwYts) for real-time support and chat\n\n## Tags\n\nEvery firmware release has a tag. They are created as follows:\n\n```bash\ngit tag -a [version] [commit] -m \"VESC Firmware Version [version]\"\ngit push --tags\n```\n\n## License\n\nThe software is released under the GNU General Public License version 3.0\n"
        },
        {
          "name": "applications",
          "type": "tree",
          "content": null
        },
        {
          "name": "blackmagic",
          "type": "tree",
          "content": null
        },
        {
          "name": "bms.c",
          "type": "blob",
          "size": 20.7939453125,
          "content": "/*\n\tCopyright 2020 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n/**\n * This is the BMS module of the VESC firmware. It mainly supports the VESC BMS, but\n * the intention is to have it extendible to other BMSs too. The first step is\n * to add the BMS you want to support to the BMS_TYPE enum, and then you need to update\n * this module to interpret CAN-messages from it properly.\n */\n\n#pragma GCC push_options\n#pragma GCC optimize (\"Os\")\n\n#include \"bms.h\"\n#include \"buffer.h\"\n#include \"utils_math.h\"\n#include \"utils_sys.h\"\n#include \"datatypes.h\"\n#include \"comm_can.h\"\n#include \"commands.h\"\n#include \"comm_usb.h\"\n#include \"app.h\"\n#include <string.h>\n#include <math.h>\n\n// Settings\n#define MAX_CAN_AGE_SEC\t\t\t\t2.0\n\n// Private variables\nstatic volatile bms_config m_conf;\nstatic volatile bms_values m_values;\nstatic volatile bms_soc_soh_temp_stat m_stat_temp_max;\nstatic volatile bms_soc_soh_temp_stat m_stat_soc_min;\nstatic volatile bms_soc_soh_temp_stat m_stat_soc_max;\nstatic volatile bms_soc_soh_temp_stat m_stat_vcell_min;\nstatic volatile bms_soc_soh_temp_stat m_stat_vcell_max;\n\nvoid bms_init(bms_config *conf) {\n\tm_conf = *conf;\n\tmemset((void*)&m_values, 0, sizeof(m_values));\n\tmemset((void*)&m_stat_temp_max, 0, sizeof(m_stat_temp_max));\n\tmemset((void*)&m_stat_soc_min, 0, sizeof(m_stat_soc_min));\n\tmemset((void*)&m_stat_soc_max, 0, sizeof(m_stat_soc_max));\n\tmemset((void*)&m_stat_vcell_min, 0, sizeof(m_stat_vcell_min));\n\tmemset((void*)&m_stat_vcell_max, 0, sizeof(m_stat_vcell_max));\n\n\tm_values.can_id = -1;\n\tm_stat_temp_max.id = -1;\n\tm_stat_soc_min.id = -1;\n\tm_stat_soc_max.id = -1;\n\tm_stat_vcell_min.id = -1;\n\tm_stat_vcell_max.id = -1;\n}\n\nbool bms_process_can_frame(uint32_t can_id, uint8_t *data8, int len, bool is_ext) {\n\tbool used_data = false;\n\n\tif (m_conf.type == BMS_TYPE_VESC) {\n\t\tif (is_ext) {\n\t\t\tuint8_t id = can_id & 0xFF;\n\t\t\tCAN_PACKET_ID cmd = can_id >> 8;\n\n\t\t\tswitch (cmd) {\n\t\t\tcase CAN_PACKET_BMS_SOC_SOH_TEMP_STAT:\n\t\t\tcase CAN_PACKET_BMS_V_TOT:\n\t\t\tcase CAN_PACKET_BMS_I:\n\t\t\tcase CAN_PACKET_BMS_AH_WH:\n\t\t\tcase CAN_PACKET_BMS_V_CELL:\n\t\t\tcase CAN_PACKET_BMS_BAL:\n\t\t\tcase CAN_PACKET_BMS_TEMPS:\n\t\t\tcase CAN_PACKET_BMS_HUM:\n\t\t\t{\n\t\t\t\tunsigned char fwd_data[11];\n\t\t\t\tunsigned int fwd_len = 0;\n\t\t\t\tfwd_data[fwd_len++] = COMM_BMS_FWD_CAN_RX;\n\t\t\t\tfwd_data[fwd_len++] = id;\n\t\t\t\tfwd_data[fwd_len++] = cmd;\n\t\t\t\tmemcpy(fwd_data + fwd_len, data8, len);\n\t\t\t\tfwd_len += len;\n\n\t\t\t\tswitch (m_conf.fwd_can_mode) {\n\t\t\t\tcase BMS_FWD_CAN_MODE_DISABLED:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BMS_FWD_CAN_MODE_USB_ONLY:\n\t\t\t\t\tcomm_usb_send_packet(fwd_data, fwd_len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BMS_FWD_CAN_MODE_ANY:\n\t\t\t\t\tcommands_send_packet(fwd_data, fwd_len);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (cmd) {\n\t\t\tcase CAN_PACKET_BMS_SOC_SOH_TEMP_STAT: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tint32_t ind = 0;\n\t\t\t\tbms_soc_soh_temp_stat msg;\n\t\t\t\tmsg.id = id;\n\t\t\t\tmsg.rx_time = chVTGetSystemTimeX();\n\t\t\t\tmsg.v_cell_min = buffer_get_float16(data8, 1e3, &ind);\n\t\t\t\tmsg.v_cell_max = buffer_get_float16(data8, 1e3, &ind);\n\t\t\t\tmsg.soc = ((float)((uint8_t)data8[ind++])) / 255.0;\n\t\t\t\tmsg.soh = ((float)((uint8_t)data8[ind++])) / 255.0;\n\t\t\t\tmsg.t_cell_max = (float)((int8_t)data8[ind++]);\n\t\t\t\tuint8_t stat = data8[ind++];\n\t\t\t\tmsg.is_charging = (stat >> 0) & 1;\n\t\t\t\tmsg.is_balancing = (stat >> 1) & 1;\n\t\t\t\tmsg.is_charge_allowed = (stat >> 2) & 1;\n\t\t\t\tmsg.data_version = (stat >> 4) & 0x0f;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.soc = msg.soc;\n\t\t\t\t\tm_values.soh = msg.soh;\n\t\t\t\t\tm_values.temp_max_cell = msg.t_cell_max;\n\t\t\t\t\tm_values.v_cell_min = msg.v_cell_min;\n\t\t\t\t\tm_values.v_cell_max = msg.v_cell_max;\n\t\t\t\t\tm_values.is_charging = msg.is_charging ? 1 : 0;\n\t\t\t\t\tm_values.is_balancing = msg.is_balancing ? 1 : 0;\n\t\t\t\t\tm_values.is_charge_allowed = msg.is_charge_allowed ? 1 : 0;\n\t\t\t\t\tm_values.data_version = msg.data_version;\n\t\t\t\t}\n\n\t\t\t\t// In case there is more than one BMS, keep track of the limiting\n\t\t\t\t// values for all of them.\n\n\t\t\t\tif (m_stat_temp_max.id < 0 ||\n\t\t\t\t\t\tUTILS_AGE_S(m_stat_temp_max.rx_time) > MAX_CAN_AGE_SEC ||\n\t\t\t\t\t\tm_stat_temp_max.t_cell_max < msg.t_cell_max) {\n\t\t\t\t\tm_stat_temp_max = msg;\n\t\t\t\t} else if (m_stat_temp_max.id == msg.id) {\n\t\t\t\t\tm_stat_temp_max = msg;\n\t\t\t\t}\n\n\t\t\t\tif (m_stat_soc_min.id < 0 ||\n\t\t\t\t\t\tUTILS_AGE_S(m_stat_soc_min.rx_time) > MAX_CAN_AGE_SEC ||\n\t\t\t\t\t\tm_stat_soc_min.soc > msg.soc) {\n\t\t\t\t\tm_stat_soc_min = msg;\n\t\t\t\t} else if (m_stat_soc_min.id == msg.id) {\n\t\t\t\t\tm_stat_soc_min = msg;\n\t\t\t\t}\n\n\t\t\t\tif (m_stat_soc_max.id < 0 ||\n\t\t\t\t\t\tUTILS_AGE_S(m_stat_soc_max.rx_time) > MAX_CAN_AGE_SEC ||\n\t\t\t\t\t\tm_stat_soc_max.soc < msg.soc) {\n\t\t\t\t\tm_stat_soc_max = msg;\n\t\t\t\t} else if (m_stat_soc_max.id == msg.id) {\n\t\t\t\t\tm_stat_soc_max = msg;\n\t\t\t\t}\n\n\t\t\t\tif (m_stat_vcell_min.id < 0 ||\n\t\t\t\t\t\tUTILS_AGE_S(m_stat_vcell_min.rx_time) > MAX_CAN_AGE_SEC ||\n\t\t\t\t\t\tm_stat_vcell_min.v_cell_min > msg.v_cell_min) {\n\t\t\t\t\tm_stat_vcell_min = msg;\n\t\t\t\t} else if (m_stat_vcell_min.id == msg.id) {\n\t\t\t\t\tm_stat_vcell_min = msg;\n\t\t\t\t}\n\n\t\t\t\tif (m_stat_vcell_max.id < 0 ||\n\t\t\t\t\t\tUTILS_AGE_S(m_stat_vcell_max.rx_time) > MAX_CAN_AGE_SEC ||\n\t\t\t\t\t\tm_stat_vcell_max.v_cell_max < msg.v_cell_max) {\n\t\t\t\t\tm_stat_vcell_max = msg;\n\t\t\t\t} else if (m_stat_vcell_max.id == msg.id) {\n\t\t\t\t\tm_stat_vcell_max = msg;\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_V_TOT: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.v_tot = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t\tm_values.v_charge = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_I: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.i_in = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t\tm_values.i_in_ic = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_AH_WH: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.ah_cnt = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t\tm_values.wh_cnt = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_V_CELL: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tunsigned int ofs = data8[ind++];\n\t\t\t\t\tm_values.cell_num = data8[ind++];\n\n\t\t\t\t\twhile(ind < len) {\n\t\t\t\t\t\tif (ofs >= (sizeof(m_values.v_cell) / sizeof(float))) {\n\t\t\t\t\t\t\t// Out of buffer space\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm_values.v_cell[ofs++] = buffer_get_float16(data8, 1e3, &ind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_BAL: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\n\t\t\t\t\tint cell_num = data8[0];\n\t\t\t\t\tuint64_t bal_state_0 = buffer_get_uint32(data8, &ind);\n\t\t\t\t\tbal_state_0 &= 0x00FFFFFF;\n\t\t\t\t\tuint64_t bal_state_1 = buffer_get_uint32(data8, &ind);\n\t\t\t\t\tuint64_t bal_state = bal_state_0 << 32 | bal_state_1;\n\t\t\t\t\tind = 0;\n\n\t\t\t\t\twhile (ind < (int)(sizeof(m_values.bal_state) / sizeof(bool)) && ind < cell_num) {\n\t\t\t\t\t\tm_values.bal_state[ind] = (bal_state >> ind) & 1;\n\t\t\t\t\t\tind++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_TEMPS: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tunsigned int ofs = data8[ind++];\n\t\t\t\t\tm_values.temp_adc_num = data8[ind++];\n\n\t\t\t\t\twhile(ind < len) {\n\t\t\t\t\t\tif (ofs >= (sizeof(m_values.temps_adc) / sizeof(float))) {\n\t\t\t\t\t\t\t// Out of buffer space\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm_values.temps_adc[ofs++] = buffer_get_float16(data8, 1e2, &ind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_HUM: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.temp_hum = buffer_get_float16(data8, 1e2, &ind);\n\t\t\t\t\tm_values.hum = buffer_get_float16(data8, 1e2, &ind);\n\t\t\t\t\tm_values.temp_ic = buffer_get_float16(data8, 1e2, &ind);\n\t\t\t\t\tif (len == 8) {\n\t\t\t\t\t\tm_values.pressure = buffer_get_float16(data8, 1e-1, &ind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_AH_WH_CHG_TOTAL: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.ah_cnt_chg_total = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t\tm_values.wh_cnt_chg_total = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tcase CAN_PACKET_BMS_AH_WH_DIS_TOTAL: {\n\t\t\t\tused_data = true;\n\n\t\t\t\tif (id == m_values.can_id || UTILS_AGE_S(m_values.update_time) > MAX_CAN_AGE_SEC) {\n\t\t\t\t\tint32_t ind = 0;\n\t\t\t\t\tm_values.can_id = id;\n\t\t\t\t\tm_values.update_time = chVTGetSystemTimeX();\n\t\t\t\t\tm_values.ah_cnt_dis_total = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t\tm_values.wh_cnt_dis_total = buffer_get_float32_auto(data8, &ind);\n\t\t\t\t}\n\t\t\t} break;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn used_data;\n}\n\nstatic void disable_on_timeout(volatile bms_soc_soh_temp_stat *stat) {\n\tif (UTILS_AGE_S(stat->rx_time) > MAX_CAN_AGE_SEC) {\n\t\tstat->id = -1;\n\t}\n}\n\nvoid bms_update_limits(float *i_in_min, float *i_in_max,\n\t\tfloat i_in_min_conf, float i_in_max_conf) {\n\tfloat i_in_min_bms = i_in_min_conf;\n\tfloat i_in_max_bms = i_in_max_conf;\n\n\tdisable_on_timeout(&m_stat_temp_max);\n\tdisable_on_timeout(&m_stat_soc_min);\n\tdisable_on_timeout(&m_stat_soc_max);\n\tdisable_on_timeout(&m_stat_vcell_min);\n\tdisable_on_timeout(&m_stat_vcell_max);\n\n\t// Temperature\n\tfloat i_in_max_bms_temp = i_in_max_conf;\n\tfloat i_in_min_bms_temp = i_in_min_conf;\n\tif ((m_conf.limit_mode >> 0) & 1) {\n\t\tif (m_stat_temp_max.id >= 0) {\n\t\t\tfloat temp = m_stat_temp_max.t_cell_max;\n\n\t\t\tif (temp < (m_conf.t_limit_start + 0.1)) {\n\t\t\t\t// OK\n\t\t\t} else if (temp > (m_conf.t_limit_end - 0.1)) {\n\t\t\t\ti_in_max_bms_temp = 0.0;\n\t\t\t\ti_in_min_bms_temp = 0.0;\n\t\t\t\t// Maybe add fault code?\n//\t\t\t\tmc_interface_fault_stop(FAULT_CODE_OVER_TEMP_FET, false, false);\n\t\t\t} else {\n\t\t\t\tfloat maxc = fabsf(i_in_max_conf);\n\t\t\t\tif (fabsf(i_in_min_conf) > maxc) {\n\t\t\t\t\tmaxc = fabsf(i_in_min_conf);\n\t\t\t\t}\n\n\t\t\t\tmaxc = utils_map(temp, m_conf.t_limit_start, m_conf.t_limit_end, maxc, 0.0);\n\n\t\t\t\tif (fabsf(i_in_min_bms_temp) > maxc) {\n\t\t\t\t\ti_in_min_bms_temp = SIGN(i_in_min_bms_temp) * maxc;\n\t\t\t\t}\n\n\t\t\t\tif (fabsf(i_in_max_bms_temp) > maxc) {\n\t\t\t\t\ti_in_max_bms_temp = SIGN(i_in_max_bms_temp) * maxc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// SOC\n\tfloat i_in_max_bms_soc = i_in_max_conf;\n\tif ((m_conf.limit_mode >> 1) & 1) {\n\t\tif (m_stat_soc_min.id >= 0) {\n\t\t\tfloat soc = m_stat_soc_min.soc;\n\n\t\t\tif (soc > (m_conf.soc_limit_start - 0.001)) {\n\t\t\t\t// OK\n\t\t\t} else if (soc < (m_conf.soc_limit_end + 0.001)) {\n\t\t\t\ti_in_max_bms_soc = 0.0;\n\t\t\t} else {\n\t\t\t\ti_in_max_bms_soc = utils_map(soc, m_conf.soc_limit_start,\n\t\t\t\t\t\tm_conf.soc_limit_end, i_in_max_conf, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// VMIN\n\tfloat i_in_max_bms_vmin = i_in_max_conf;\n\tif ((m_conf.limit_mode >> 2) & 1) {\n\t\tif (m_stat_vcell_min.id >= 0) {\n\t\t\tfloat vmin = m_stat_vcell_min.soc;\n\n\t\t\tif (vmin > (m_conf.vmin_limit_start - 0.1)) {\n\t\t\t\t// OK\n\t\t\t} else if (vmin < (m_conf.vmin_limit_end + 0.1)) {\n\t\t\t\ti_in_max_bms_vmin = 0.0;\n\t\t\t} else {\n\t\t\t\ti_in_max_bms_vmin = utils_map(vmin, m_conf.vmin_limit_start,\n\t\t\t\t\t\tm_conf.vmin_limit_end, i_in_max_conf, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// VMAX (regen)\n\tfloat i_in_min_bms_vmax = i_in_min_conf;\n\tif ((m_conf.limit_mode >> 3) & 1) {\n\t\tif (m_stat_vcell_max.id >= 0) {\n\t\t\tfloat vmax = m_stat_vcell_max.soc;\n\n\t\t\tif (vmax < (m_conf.vmax_limit_start + 0.1)) {\n\t\t\t\t// OK\n\t\t\t} else if (vmax > (m_conf.vmax_limit_end - 0.1)) {\n\t\t\t\ti_in_min_bms_vmax = 0.0;\n\t\t\t} else {\n\t\t\t\ti_in_min_bms_vmax = utils_map(vmax, m_conf.vmax_limit_start,\n\t\t\t\t\t\tm_conf.vmax_limit_end, i_in_min_conf, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\ti_in_max_bms = utils_min_abs(i_in_max_bms, i_in_max_bms_temp);\n\ti_in_max_bms = utils_min_abs(i_in_max_bms, i_in_max_bms_soc);\n\ti_in_max_bms = utils_min_abs(i_in_max_bms, i_in_max_bms_vmin);\n\n\ti_in_min_bms = utils_min_abs(i_in_min_bms, i_in_min_bms_temp);\n\ti_in_min_bms = utils_min_abs(i_in_min_bms, i_in_min_bms_vmax);\n\n\t// TODO: add support for conf->l_temp_accel_dec to still have braking.\n\n\tif (fabsf(i_in_min_bms) < fabsf(*i_in_min)) {\n\t\t*i_in_min = i_in_min_bms;\n\t}\n\n\tif (fabsf(i_in_max_bms) < fabsf(*i_in_max)) {\n\t\t*i_in_max = i_in_max_bms;\n\t}\n}\n\nvoid bms_process_cmd(unsigned char *data, unsigned int len,\n\t\tvoid(*reply_func)(unsigned char *data, unsigned int len)) {\n\tCOMM_PACKET_ID packet_id;\n\n\tpacket_id = data[0];\n\tdata++;\n\tlen--;\n\n\tswitch (packet_id) {\n\tcase COMM_BMS_GET_VALUES: {\n\t\tint32_t ind = 0;\n\t\tuint8_t send_buffer[256];\n\n\t\tsend_buffer[ind++] = packet_id;\n\n\t\tbuffer_append_float32(send_buffer, m_values.v_tot, 1e6, &ind);\n\t\tbuffer_append_float32(send_buffer, m_values.v_charge, 1e6, &ind);\n\t\tbuffer_append_float32(send_buffer, m_values.i_in, 1e6, &ind);\n\t\tbuffer_append_float32(send_buffer, m_values.i_in_ic, 1e6, &ind);\n\t\tbuffer_append_float32(send_buffer, m_values.ah_cnt, 1e3, &ind);\n\t\tbuffer_append_float32(send_buffer, m_values.wh_cnt, 1e3, &ind);\n\n\t\t// Cell voltages\n\t\tsend_buffer[ind++] = m_values.cell_num;\n\t\tfor (int i = 0;i < m_values.cell_num;i++) {\n\t\t\tbuffer_append_float16(send_buffer, m_values.v_cell[i], 1e3, &ind);\n\t\t}\n\n\t\t// Balancing state\n\t\tfor (int i = 0;i < m_values.cell_num;i++) {\n\t\t\tsend_buffer[ind++] = m_values.bal_state[i];\n\t\t}\n\n\t\t// Temperatures\n\t\tsend_buffer[ind++] = m_values.temp_adc_num;\n\t\tfor (int i = 0;i < m_values.temp_adc_num;i++) {\n\t\t\tbuffer_append_float16(send_buffer, m_values.temps_adc[i], 1e2, &ind);\n\t\t}\n\t\tbuffer_append_float16(send_buffer, m_values.temp_ic, 1e2, &ind);\n\n\t\t// Humidity\n\t\tbuffer_append_float16(send_buffer, m_values.temp_hum, 1e2, &ind);\n\t\tbuffer_append_float16(send_buffer, m_values.hum, 1e2, &ind);\n\n\t\t// Highest cell temperature\n\t\tbuffer_append_float16(send_buffer, m_values.temp_max_cell, 1e2, &ind);\n\n\t\t// State of charge and state of health\n\t\tbuffer_append_float16(send_buffer, m_values.soc, 1e3, &ind);\n\t\tbuffer_append_float16(send_buffer, m_values.soh, 1e3, &ind);\n\n\t\t// CAN ID\n\t\tsend_buffer[ind++] = m_values.can_id;\n\n\t\t// Total charge and discharge counters\n\t\tbuffer_append_float32_auto(send_buffer, m_values.ah_cnt_chg_total, &ind);\n\t\tbuffer_append_float32_auto(send_buffer, m_values.wh_cnt_chg_total, &ind);\n\t\tbuffer_append_float32_auto(send_buffer, m_values.ah_cnt_dis_total, &ind);\n\t\tbuffer_append_float32_auto(send_buffer, m_values.wh_cnt_dis_total, &ind);\n\n\t\t// Pressure\n\t\tbuffer_append_float16(send_buffer, m_values.pressure, 1e-1, &ind);\n\n\t\tsend_buffer[ind++] = m_values.data_version;\n\n\t\treply_func(send_buffer, ind);\n\t} break;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (m_conf.type == BMS_TYPE_VESC && UTILS_AGE_S(m_values.update_time) < MAX_CAN_AGE_SEC) {\n\t\tswitch (packet_id) {\n\t\tcase COMM_BMS_SET_CHARGE_ALLOWED:\n\t\tcase COMM_BMS_SET_BALANCE_OVERRIDE:\n\t\tcase COMM_BMS_RESET_COUNTERS:\n\t\tcase COMM_BMS_FORCE_BALANCE:\n\t\tcase COMM_BMS_ZERO_CURRENT_OFFSET: {\n\t\t\tcomm_can_send_buffer(m_values.can_id, data - 1, len + 1, 0);\n\t\t} break;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\nvolatile bms_values *bms_get_values(void) {\n\treturn &m_values;\n}\n\nvoid bms_send_status_can(void) {\n\tint32_t send_index = 0;\n\tuint8_t buffer[8];\n\n\tuint8_t id = app_get_configuration()->controller_id;\n\n\tbuffer_append_float32_auto(buffer, m_values.v_tot, &send_index);\n\tbuffer_append_float32_auto(buffer, m_values.v_charge, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_V_TOT << 8), buffer, send_index);\n\n\tsend_index = 0;\n\tbuffer_append_float32_auto(buffer, m_values.i_in, &send_index);\n\tbuffer_append_float32_auto(buffer, m_values.i_in_ic, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_I << 8), buffer, send_index);\n\n\tsend_index = 0;\n\tbuffer_append_float32_auto(buffer, m_values.ah_cnt, &send_index);\n\tbuffer_append_float32_auto(buffer, m_values.wh_cnt, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_AH_WH << 8), buffer, send_index);\n\n\tint cell_now = 0;\n\tint cell_max = m_values.cell_num;\n\tif (cell_max > BMS_MAX_CELLS) {\n\t\tcell_max = BMS_MAX_CELLS;\n\t}\n\n\twhile (cell_now < cell_max) {\n\t\tsend_index = 0;\n\t\tbuffer[send_index++] = cell_now;\n\t\tbuffer[send_index++] = m_values.cell_num;\n\t\tif (cell_now < cell_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.v_cell[cell_now++], 1e3, &send_index);\n\t\t}\n\t\tif (cell_now < cell_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.v_cell[cell_now++], 1e3, &send_index);\n\t\t}\n\t\tif (cell_now < cell_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.v_cell[cell_now++], 1e3, &send_index);\n\t\t}\n\t\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_V_CELL << 8), buffer, send_index);\n\t}\n\n\tsend_index = 0;\n\tbuffer[send_index++] = cell_max;\n\tuint64_t bal_state = 0;\n\tfor (int i = 0;i < cell_max;i++) {\n\t\tbal_state |= (uint64_t)m_values.bal_state[i] << i;\n\t}\n\tbuffer[send_index++] = (bal_state >> 48) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 40) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 32) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 24) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 16) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 8) & 0xFF;\n\tbuffer[send_index++] = (bal_state >> 0) & 0xFF;\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_BAL << 8), buffer, send_index);\n\n\tint temp_now = 0;\n\tint temp_max = m_values.temp_adc_num;\n\tif (temp_max > BMS_MAX_TEMPS) {\n\t\ttemp_max = BMS_MAX_TEMPS;\n\t}\n\n\twhile (temp_now < temp_max) {\n\t\tsend_index = 0;\n\t\tbuffer[send_index++] = temp_now;\n\t\tbuffer[send_index++] = temp_max;\n\t\tif (temp_now < temp_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.temps_adc[temp_now++], 1e2, &send_index);\n\t\t}\n\t\tif (temp_now < temp_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.temps_adc[temp_now++], 1e2, &send_index);\n\t\t}\n\t\tif (temp_now < temp_max) {\n\t\t\tbuffer_append_float16(buffer, m_values.temps_adc[temp_now++], 1e2, &send_index);\n\t\t}\n\t\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_TEMPS << 8), buffer, send_index);\n\t}\n\n\tsend_index = 0;\n\tbuffer_append_float16(buffer, m_values.temp_hum, 1e2, &send_index);\n\tbuffer_append_float16(buffer, m_values.hum, 1e2, &send_index);\n\tbuffer_append_float16(buffer, m_values.temp_ic, 1e2, &send_index); // Put IC temp here instead of making mew msg\n\tbuffer_append_float16(buffer, m_values.pressure, 1e-1, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_HUM << 8), buffer, send_index);\n\n\t/*\n\t * CAN_PACKET_BMS_SOC_SOH_TEMP_STAT\n\t *\n\t * b[0] - b[1]: V_CELL_MIN (mV)\n\t * b[2] - b[3]: V_CELL_MAX (mV)\n\t * b[4]: SoC (0 - 255)\n\t * b[5]: SoH (0 - 255)\n\t * b[6]: T_CELL_MAX (-128 to +127 degC)\n\t * b[7]: State bitfield:\n\t * [B7      B6      B5      B4      B3      B2      B1      B0      ]\n\t * [DV3     DV2     DV1     DV0     RSV     CHG_OK  IS_BAL  IS_CHG  ]\n\t */\n\tsend_index = 0;\n\tbuffer_append_float16(buffer, (float_t)m_values.v_cell_min, 1e3, &send_index);\n\tbuffer_append_float16(buffer, (float_t)m_values.v_cell_max, 1e3, &send_index);\n\tbuffer[send_index++] = (uint8_t)(m_values.soc * 255.0);\n\tbuffer[send_index++] = (uint8_t)(m_values.soh * 255.0);\n\tbuffer[send_index++] = (int8_t)m_values.temp_max_cell;\n\tbuffer[send_index++] =\n\t\t\t\t((m_values.is_charging ? 1 : 0) << 0) |\n\t\t\t\t((m_values.is_balancing ? 1 : 0) << 1) |\n\t\t\t\t((m_values.is_charge_allowed ? 1 : 0) << 2) |\n\t\t\t\t(m_values.data_version << 4);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_SOC_SOH_TEMP_STAT << 8), buffer, send_index);\n\n\tsend_index = 0;\n\tbuffer_append_float32_auto(buffer, m_values.ah_cnt_chg_total, &send_index);\n\tbuffer_append_float32_auto(buffer, m_values.wh_cnt_chg_total, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_AH_WH_CHG_TOTAL << 8), buffer, send_index);\n\n\tsend_index = 0;\n\tbuffer_append_float32_auto(buffer, m_values.ah_cnt_dis_total, &send_index);\n\tbuffer_append_float32_auto(buffer, m_values.wh_cnt_dis_total, &send_index);\n\tcomm_can_transmit_eid(id | ((uint32_t)CAN_PACKET_BMS_AH_WH_DIS_TOTAL << 8), buffer, send_index);\n}\n\n#pragma GCC pop_options\n"
        },
        {
          "name": "bms.h",
          "type": "blob",
          "size": 1.26953125,
          "content": "/*\n\tCopyright 2020 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef BMS_H_\n#define BMS_H_\n\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"datatypes.h\"\n\n// Functions\nvoid bms_init(bms_config *conf);\nbool bms_process_can_frame(uint32_t can_id, uint8_t *data8, int len, bool is_ext);\nvoid bms_update_limits(float *i_in_min, float *i_in_max,\n\t\tfloat i_in_min_conf, float i_in_max_conf);\nvoid bms_process_cmd(unsigned char *data, unsigned int len,\n\t\tvoid(*reply_func)(unsigned char *data, unsigned int len));\nvolatile bms_values *bms_get_values(void);\nvoid bms_send_status_can(void);\n\n#endif /* BMS_H_ */\n"
        },
        {
          "name": "chconf.h",
          "type": "blob",
          "size": 15.375,
          "content": "/*\n    ChibiOS - Copyright (C) 2006..2015 Giovanni Di Sirio\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\n * @file    templates/chconf.h\n * @brief   Configuration file template.\n * @details A copy of this file must be placed in each project directory, it\n *          contains the application specific kernel settings.\n *\n * @addtogroup config\n * @details Kernel related settings and hooks.\n * @{\n */\n\n#ifndef _CHCONF_H_\n#define _CHCONF_H_\n\n#define CHPRINTF_USE_FLOAT\t\t\t\tTRUE\n#define CORTEX_SIMPLIFIED_PRIORITY\t\tTRUE\n#define PORT_IDLE_THREAD_STACK_SIZE\t\t64\n#define PORT_INT_REQUIRED_STACK\t\t\t128\n\n/*===========================================================================*/\n/**\n * @name System timers settings\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   System time counter resolution.\n * @note    Allowed values are 16 or 32 bits.\n */\n#define CH_CFG_ST_RESOLUTION                32\n\n/**\n * @brief   System tick frequency.\n * @details Frequency of the system timer that drives the system ticks. This\n *          setting also defines the system tick time unit.\n */\n#define CH_CFG_ST_FREQUENCY                 10000\n\n/**\n * @brief   Time delta constant for the tick-less mode.\n * @note    If this value is zero then the system uses the classic\n *          periodic tick. This value represents the minimum number\n *          of ticks that is safe to specify in a timeout directive.\n *          The value one is not valid, timeouts are rounded up to\n *          this value.\n */\n#define CH_CFG_ST_TIMEDELTA                 0\n\n/** @} */\n\n/*===========================================================================*/\n/**\n * @name Kernel parameters and options\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   Round robin interval.\n * @details This constant is the number of system ticks allowed for the\n *          threads before preemption occurs. Setting this value to zero\n *          disables the preemption for threads with equal priority and the\n *          round robin becomes cooperative. Note that higher priority\n *          threads can still preempt, the kernel is always preemptive.\n * @note    Disabling the round robin preemption makes the kernel more compact\n *          and generally faster.\n * @note    The round robin preemption is not supported in tickless mode and\n *          must be set to zero in that case.\n */\n#define CH_CFG_TIME_QUANTUM                 4\n\n/**\n * @brief   Managed RAM size.\n * @details Size of the RAM area to be managed by the OS. If set to zero\n *          then the whole available RAM is used. The core memory is made\n *          available to the heap allocator and/or can be used directly through\n *          the simplified core memory allocator.\n *\n * @note    In order to let the OS manage the whole RAM the linker script must\n *          provide the @p __heap_base__ and @p __heap_end__ symbols.\n * @note    Requires @p CH_CFG_USE_MEMCORE.\n */\n#define CH_CFG_MEMCORE_SIZE                 0\n\n/**\n * @brief   Idle thread automatic spawn suppression.\n * @details When this option is activated the function @p chSysInit()\n *          does not spawn the idle thread. The application @p main()\n *          function becomes the idle thread and must implement an\n *          infinite loop.\n */\n#define CH_CFG_NO_IDLE_THREAD               FALSE\n\n/** @} */\n\n/*===========================================================================*/\n/**\n * @name Performance options\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   OS optimization.\n * @details If enabled then time efficient rather than space efficient code\n *          is used when two possible implementations exist.\n *\n * @note    This is not related to the compiler optimization options.\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_OPTIMIZE_SPEED               TRUE\n\n/** @} */\n\n/*===========================================================================*/\n/**\n * @name Subsystem options\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   Time Measurement APIs.\n * @details If enabled then the time measurement APIs are included in\n *          the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_TM                       TRUE\n\n/**\n * @brief   Threads registry APIs.\n * @details If enabled then the registry APIs are included in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_REGISTRY                 TRUE\n\n/**\n * @brief   Threads synchronization APIs.\n * @details If enabled then the @p chThdWait() function is included in\n *          the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_WAITEXIT                 TRUE\n\n/**\n * @brief   Semaphores APIs.\n * @details If enabled then the Semaphores APIs are included in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_SEMAPHORES               TRUE\n\n/**\n * @brief   Semaphores queuing mode.\n * @details If enabled then the threads are enqueued on semaphores by\n *          priority rather than in FIFO order.\n *\n * @note    The default is @p FALSE. Enable this if you have special\n *          requirements.\n * @note    Requires @p CH_CFG_USE_SEMAPHORES.\n */\n#define CH_CFG_USE_SEMAPHORES_PRIORITY      FALSE\n\n/**\n * @brief   Mutexes APIs.\n * @details If enabled then the mutexes APIs are included in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_MUTEXES                  TRUE\n\n/**\n * @brief   Enables recursive behavior on mutexes.\n * @note    Recursive mutexes are heavier and have an increased\n *          memory footprint.\n *\n * @note    The default is @p FALSE.\n * @note    Requires @p CH_CFG_USE_MUTEXES.\n */\n#define CH_CFG_USE_MUTEXES_RECURSIVE        FALSE\n\n/**\n * @brief   Conditional Variables APIs.\n * @details If enabled then the conditional variables APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_MUTEXES.\n */\n#define CH_CFG_USE_CONDVARS                 TRUE\n\n/**\n * @brief   Conditional Variables APIs with timeout.\n * @details If enabled then the conditional variables APIs with timeout\n *          specification are included in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_CONDVARS.\n */\n#define CH_CFG_USE_CONDVARS_TIMEOUT         TRUE\n\n/**\n * @brief   Events Flags APIs.\n * @details If enabled then the event flags APIs are included in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_EVENTS                   TRUE\n\n/**\n * @brief   Events Flags APIs with timeout.\n * @details If enabled then the events APIs with timeout specification\n *          are included in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_EVENTS.\n */\n#define CH_CFG_USE_EVENTS_TIMEOUT           TRUE\n\n/**\n * @brief   Synchronous Messages APIs.\n * @details If enabled then the synchronous messages APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_MESSAGES                 TRUE\n\n/**\n * @brief   Synchronous Messages queuing mode.\n * @details If enabled then messages are served by priority rather than in\n *          FIFO order.\n *\n * @note    The default is @p FALSE. Enable this if you have special\n *          requirements.\n * @note    Requires @p CH_CFG_USE_MESSAGES.\n */\n#define CH_CFG_USE_MESSAGES_PRIORITY        FALSE\n\n/**\n * @brief   Mailboxes APIs.\n * @details If enabled then the asynchronous messages (mailboxes) APIs are\n *          included in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_SEMAPHORES.\n */\n#define CH_CFG_USE_MAILBOXES                TRUE\n\n/**\n * @brief   I/O Queues APIs.\n * @details If enabled then the I/O queues APIs are included in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_QUEUES                   TRUE\n\n/**\n * @brief   Core Memory Manager APIs.\n * @details If enabled then the core memory manager APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_MEMCORE                  TRUE\n\n/**\n * @brief   Heap Allocator APIs.\n * @details If enabled then the memory heap allocator APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_MEMCORE and either @p CH_CFG_USE_MUTEXES or\n *          @p CH_CFG_USE_SEMAPHORES.\n * @note    Mutexes are recommended.\n */\n#define CH_CFG_USE_HEAP                     TRUE\n\n/**\n * @brief   Memory Pools Allocator APIs.\n * @details If enabled then the memory pools allocator APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n */\n#define CH_CFG_USE_MEMPOOLS                 TRUE\n\n/**\n * @brief   Dynamic Threads APIs.\n * @details If enabled then the dynamic threads creation APIs are included\n *          in the kernel.\n *\n * @note    The default is @p TRUE.\n * @note    Requires @p CH_CFG_USE_WAITEXIT.\n * @note    Requires @p CH_CFG_USE_HEAP and/or @p CH_CFG_USE_MEMPOOLS.\n */\n#define CH_CFG_USE_DYNAMIC                  TRUE\n\n/** @} */\n\n/*===========================================================================*/\n/**\n * @name Debug options\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   Debug option, kernel statistics.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_STATISTICS                   FALSE\n\n/**\n * @brief   Debug option, system state check.\n * @details If enabled the correct call protocol for system APIs is checked\n *          at runtime.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_SYSTEM_STATE_CHECK           FALSE\n\n/**\n * @brief   Debug option, parameters checks.\n * @details If enabled then the checks on the API functions input\n *          parameters are activated.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_ENABLE_CHECKS                FALSE\n\n/**\n * @brief   Debug option, consistency checks.\n * @details If enabled then all the assertions in the kernel code are\n *          activated. This includes consistency checks inside the kernel,\n *          runtime anomalies and port-defined checks.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_ENABLE_ASSERTS               FALSE\n\n/**\n * @brief   Debug option, trace buffer.\n * @details If enabled then the context switch circular trace buffer is\n *          activated.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_ENABLE_TRACE                 FALSE\n\n/**\n * @brief   Debug option, stack checks.\n * @details If enabled then a runtime stack check is performed.\n *\n * @note    The default is @p FALSE.\n * @note    The stack check is performed in a architecture/port dependent way.\n *          It may not be implemented or some ports.\n * @note    The default failure mode is to halt the system with the global\n *          @p panic_msg variable set to @p NULL.\n */\n#define CH_DBG_ENABLE_STACK_CHECK           TRUE\n\n/**\n * @brief   Debug option, stacks initialization.\n * @details If enabled then the threads working area is filled with a byte\n *          value when a thread is created. This can be useful for the\n *          runtime measurement of the used stack.\n *\n * @note    The default is @p FALSE.\n */\n#define CH_DBG_FILL_THREADS                 TRUE\n\n/**\n * @brief   Debug option, threads profiling.\n * @details If enabled then a field is added to the @p thread_t structure that\n *          counts the system ticks occurred while executing the thread.\n *\n * @note    The default is @p FALSE.\n * @note    This debug option is not currently compatible with the\n *          tickless mode.\n */\n#define CH_DBG_THREADS_PROFILING            TRUE\n\n/** @} */\n\n/*===========================================================================*/\n/**\n * @name Kernel hooks\n * @{\n */\n/*===========================================================================*/\n\n/**\n * @brief   Threads descriptor structure extension.\n * @details User fields added to the end of the @p thread_t structure.\n */\n#define CH_CFG_THREAD_EXTRA_FIELDS                                          \\\n  int motor_selected;\n\n/**\n * @brief   Threads initialization hook.\n * @details User initialization code added to the @p chThdInit() API.\n *\n * @note    It is invoked from within @p chThdInit() and implicitly from all\n *          the threads creation APIs.\n */\n#define CH_CFG_THREAD_INIT_HOOK(tp) {                                       \\\n  /* Add threads initialization code here.*/                                \\\n  tp->motor_selected = 1; \\\n}\n\n/**\n * @brief   Threads finalization hook.\n * @details User finalization code added to the @p chThdExit() API.\n *\n * @note    It is inserted into lock zone.\n * @note    It is also invoked when the threads simply return in order to\n *          terminate.\n */\n#define CH_CFG_THREAD_EXIT_HOOK(tp) {                                       \\\n  /* Add threads finalization code here.*/                                  \\\n}\n\n/**\n * @brief   Context switch hook.\n * @details This hook is invoked just before switching between threads.\n */\n#define CH_CFG_CONTEXT_SWITCH_HOOK(ntp, otp) {                              \\\n  /* Context switch code here.*/                                            \\\n}\n\n/**\n * @brief   Idle thread enter hook.\n * @note    This hook is invoked within a critical zone, no OS functions\n *          should be invoked from here.\n * @note    This macro can be used to activate a power saving mode.\n */\n#define CH_CFG_IDLE_ENTER_HOOK() {                                          \\\n}\n\n/**\n * @brief   Idle thread leave hook.\n * @note    This hook is invoked within a critical zone, no OS functions\n *          should be invoked from here.\n * @note    This macro can be used to deactivate a power saving mode.\n */\n#define CH_CFG_IDLE_LEAVE_HOOK() {                                          \\\n}\n\n/**\n * @brief   Idle Loop hook.\n * @details This hook is continuously invoked by the idle thread loop.\n */\n#define CH_CFG_IDLE_LOOP_HOOK() {                                           \\\n  /* Idle loop code here.*/                                                 \\\n}\n\n/**\n * @brief   System tick event hook.\n * @details This hook is invoked in the system tick handler immediately\n *          after processing the virtual timers queue.\n */\n#define CH_CFG_SYSTEM_TICK_HOOK() {                                         \\\n  /* System tick event code here.*/                                         \\\n}\n\n/**\n * @brief   System halt hook.\n * @details This hook is invoked in case to a system halting error before\n *          the system is halted.\n */\n#define CH_CFG_SYSTEM_HALT_HOOK(reason) {                                   \\\n  /* System halt code here.*/                                               \\\n}\n\n/** @} */\n\n/*===========================================================================*/\n/* Port-specific settings (override port settings defaulted in chcore.h).    */\n/*===========================================================================*/\n\n#endif  /* _CHCONF_H_ */\n\n/** @} */\n"
        },
        {
          "name": "comm",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf_custom.c",
          "type": "blob",
          "size": 3.59375,
          "content": "/*\n\tCopyright 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"conf_custom.h\"\n#include \"datatypes.h\"\n#include \"packet.h\"\n#include \"mempools.h\"\n#include \"buffer.h\"\n#include \"utils_sys.h\"\n\n#include <string.h>\n\n// Function pointers\nstatic int (*m_get_cfg)(uint8_t *data, bool is_default) = 0;\nstatic bool (*m_set_cfg)(uint8_t *data) = 0;\nstatic int (*m_get_cfg_xml)(uint8_t **data) = 0;\n\nvoid conf_custom_add_config(\n\t\tint (*get_cfg)(uint8_t *data, bool is_default),\n\t\tbool (*set_cfg)(uint8_t *data),\n\t\tint (*get_cfg_xml)(uint8_t **data)) {\n\n\tif (utils_is_func_valid(get_cfg) &&\n\t\t\tutils_is_func_valid(set_cfg) &&\n\t\t\tutils_is_func_valid(get_cfg_xml)) {\n\t\tm_get_cfg = get_cfg;\n\t\tm_set_cfg = set_cfg;\n\t\tm_get_cfg_xml = get_cfg_xml;\n\t}\n}\n\nvoid conf_custom_clear_configs(void) {\n\tm_get_cfg = 0;\n\tm_set_cfg = 0;\n\tm_get_cfg_xml = 0;\n}\n\nint conf_custom_cfg_num(void) {\n\tint res = 0;\n\n\tif (m_get_cfg_xml) {\n\t\tuint8_t *xml_data = 0;\n\t\tm_get_cfg_xml(&xml_data);\n\n\t\tif (utils_is_func_valid(xml_data)) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint conf_custom_get_cfg_xml(int conf_ind, uint8_t **data) {\n\tif (conf_ind != 0 || m_get_cfg_xml == 0) {\n\t\treturn 0;\n\t}\n\n\treturn m_get_cfg_xml(data);\n}\n\nvoid conf_custom_process_cmd(unsigned char *data, unsigned int len,\n\t\tvoid(*reply_func)(unsigned char *data, unsigned int len)) {\n\tCOMM_PACKET_ID packet_id;\n\n\tpacket_id = data[0];\n\tdata++;\n\tlen--;\n\n\tswitch (packet_id) {\n\n\tcase COMM_GET_CUSTOM_CONFIG:\n\tcase COMM_GET_CUSTOM_CONFIG_DEFAULT: {\n\t\tint conf_ind = data[0];\n\t\tif (m_get_cfg && conf_ind == 0) {\n\t\t\tuint8_t *send_buffer = mempools_get_packet_buffer();\n\t\t\tint32_t ind = 0;\n\t\t\tsend_buffer[ind++] = packet_id;\n\t\t\tsend_buffer[ind++] = conf_ind;\n\t\t\tint32_t len_cfg = m_get_cfg(send_buffer + ind, packet_id == COMM_GET_CUSTOM_CONFIG_DEFAULT);\n\t\t\tind += len_cfg;\n\t\t\treply_func(send_buffer, ind);\n\t\t\tmempools_free_packet_buffer(send_buffer);\n\t\t}\n\t} break;\n\n\tcase COMM_SET_CUSTOM_CONFIG: {\n\t\tint conf_ind = data[0];\n\t\tif (m_set_cfg && conf_ind == 0) {\n\t\t\tm_set_cfg(data + 1);\n\t\t\tint32_t ind = 0;\n\t\t\tuint8_t send_buffer[50];\n\t\t\tsend_buffer[ind++] = packet_id;\n\t\t\treply_func(send_buffer, ind);\n\t\t}\n\t} break;\n\n\tcase COMM_GET_CUSTOM_CONFIG_XML: {\n\t\tint32_t ind = 0;\n\n\t\tint conf_ind = data[ind++];\n\n\t\tif (conf_ind != 0 || m_get_cfg_xml == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint32_t len_conf = buffer_get_int32(data, &ind);\n\t\tint32_t ofs_conf = buffer_get_int32(data, &ind);\n\n\t\tuint8_t *xml_data = 0;\n\t\tint xml_len = m_get_cfg_xml(&xml_data);\n\n\t\tif ((len_conf + ofs_conf) > xml_len || len_conf > (PACKET_MAX_PL_LEN - 10)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tuint8_t *send_buffer = mempools_get_packet_buffer();\n\t\tind = 0;\n\t\tsend_buffer[ind++] = packet_id;\n\t\tsend_buffer[ind++] = conf_ind;\n\t\tbuffer_append_int32(send_buffer, xml_len, &ind);\n\t\tbuffer_append_int32(send_buffer, ofs_conf, &ind);\n\t\tmemcpy(send_buffer + ind, xml_data + ofs_conf, len_conf);\n\t\tind += len_conf;\n\t\treply_func(send_buffer, ind);\n\n\t\tmempools_free_packet_buffer(send_buffer);\n\t} break;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n"
        },
        {
          "name": "conf_custom.h",
          "type": "blob",
          "size": 1.2705078125,
          "content": "/*\n\tCopyright 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CONF_CUSTOM_H_\n#define CONF_CUSTOM_H_\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// Functions\nvoid conf_custom_add_config(\n\t\tint (*get_cfg)(uint8_t *data, bool is_default),\n\t\tbool (*set_cfg)(uint8_t *data),\n\t\tint (*get_cfg_xml)(uint8_t **data));\nvoid conf_custom_clear_configs(void);\nint conf_custom_cfg_num(void);\nint conf_custom_get_cfg_xml(int conf_ind, uint8_t **data);\nvoid conf_custom_process_cmd(unsigned char *data, unsigned int len,\n\t\tvoid(*reply_func)(unsigned char *data, unsigned int len));\n\n#endif /* CONF_CUSTOM_H_ */\n"
        },
        {
          "name": "conf_general.c",
          "type": "blob",
          "size": 58.7705078125,
          "content": "/*\n\tCopyright 2016 - 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#pragma GCC push_options\n#pragma GCC optimize (\"Os\")\n\n#include \"conf_general.h\"\n#include \"ch.h\"\n#include \"eeprom.h\"\n#include \"mcpwm.h\"\n#include \"mcpwm_foc.h\"\n#include \"mc_interface.h\"\n#include \"utils_math.h\"\n#include \"utils_sys.h\"\n#include \"stm32f4xx_conf.h\"\n#include \"timeout.h\"\n#include \"commands.h\"\n#include \"encoder/encoder.h\"\n#include \"comm_can.h\"\n#include \"app.h\"\n#include \"confgenerator.h\"\n#include \"mempools.h\"\n#include \"worker.h\"\n#include \"crc.h\"\n#include \"terminal.h\"\n#include \"firmware_metadata.h\"\n\n#include <string.h>\n#include <math.h>\n\n//#define TEST_BAD_MC_CRC\n//#define TEST_BAD_APP_CRC\n\n// EEPROM settings\n#define EEPROM_BASE_MCCONF\t\t1000\n#define EEPROM_BASE_APPCONF\t\t2000\n#define EEPROM_BASE_HW\t\t\t3000\n#define EEPROM_BASE_CUSTOM\t\t4000\n#define EEPROM_BASE_MCCONF_2\t5000\n#define EEPROM_BASE_BACKUP\t\t6000\n\n// Global variables\nuint16_t VirtAddVarTab[NB_OF_VAR];\nbool conf_general_permanent_nrf_found = false;\n__attribute__((section(\".ram4\"))) volatile backup_data g_backup;\n\n// Private functions\nstatic bool read_eeprom_var(eeprom_var *v, int address, uint16_t base);\nstatic bool store_eeprom_var(eeprom_var *v, int address, uint16_t base);\n\nvoid conf_general_init(void) {\n\t// First, make sure that all relevant virtual addresses are assigned for page swapping.\n\tmemset(VirtAddVarTab, 0, sizeof(VirtAddVarTab));\n\n\tint ind = 0;\n\tfor (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {\n\t\tVirtAddVarTab[ind++] = EEPROM_BASE_MCCONF + i;\n\t}\n\n\tfor (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {\n\t\tVirtAddVarTab[ind++] = EEPROM_BASE_APPCONF + i;\n\t}\n\n\tfor (unsigned int i = 0;i < (EEPROM_VARS_HW * 2);i++) {\n\t\tVirtAddVarTab[ind++] = EEPROM_BASE_HW + i;\n\t}\n\n\tfor (unsigned int i = 0;i < (EEPROM_VARS_CUSTOM * 2);i++) {\n\t\tVirtAddVarTab[ind++] = EEPROM_BASE_CUSTOM + i;\n\t}\n\n\tfor (unsigned int i = 0;i < (sizeof(backup_data) / 2);i++) {\n\t\tVirtAddVarTab[ind++] = EEPROM_BASE_BACKUP + i;\n\t}\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\tEE_Init();\n\tFLASH_Lock();\n\n\t// Read backup data\n\tbool is_ok = true;\n\tbackup_data backup_tmp;\n\tuint8_t *data_addr = (uint8_t*)&backup_tmp;\n\tuint16_t var;\n\n\tfor (unsigned int i = 0;i < (sizeof(backup_data) / 2);i++) {\n\t\tif (EE_ReadVariable(EEPROM_BASE_BACKUP + i, &var) == 0) {\n\t\t\tdata_addr[2 * i] = (var >> 8) & 0xFF;\n\t\t\tdata_addr[2 * i + 1] = var & 0xFF;\n\t\t} else {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_ok) {\n\t\tmemset(data_addr, 0, sizeof(backup_data));\n\n\t\t// If the missing data is a result of programming it might still be in RAM4. Check\n\t\t// and recover the valid values one by one.\n\n\t\tif (g_backup.odometer_init_flag == BACKUP_VAR_INIT_CODE) {\n\t\t\tbackup_tmp.odometer = g_backup.odometer;\n\t\t}\n\n\t\tif (g_backup.runtime_init_flag == BACKUP_VAR_INIT_CODE) {\n\t\t\tbackup_tmp.runtime = g_backup.runtime;\n\t\t}\n\n\t\tif (g_backup.hw_config_init_flag == BACKUP_VAR_INIT_CODE) {\n\t\t\tmemcpy((void*)backup_tmp.hw_config, (uint8_t*)g_backup.hw_config, sizeof(g_backup.hw_config));\n\t\t}\n\t}\n\n\tbackup_tmp.odometer_init_flag = BACKUP_VAR_INIT_CODE;\n\tbackup_tmp.runtime_init_flag = BACKUP_VAR_INIT_CODE;\n\tbackup_tmp.hw_config_init_flag = BACKUP_VAR_INIT_CODE;\n\n\tg_backup = backup_tmp;\n\tconf_general_store_backup_data();\n}\n\n/*\n * Store backup data to emulated eeprom. Currently this is only done from the shutdown function, which\n * only works if the hardware has a power switch. It would be possible to do this when the input voltage\n * drops (e.g. on FAULT_CODE_UNDER_VOLTAGE) to not rely on a power switch. The risk with that is that\n * a page swap might longer than the capacitors have voltage left, which could make cause the motor and\n * app config to get lost.\n */\nbool conf_general_store_backup_data(void) {\n\ttimeout_configure_IWDT_slowest();\n\n\tbool is_ok = true;\n\tuint8_t *data_addr = (uint8_t*)&g_backup;\n\tuint16_t var;\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tfor (unsigned int i = 0;i < (sizeof(backup_data) / 2);i++) {\n\t\tvar = (data_addr[2 * i] << 8) & 0xFF00;\n\t\tvar |= data_addr[2 * i + 1] & 0xFF;\n\n\t\tif (EE_WriteVariable(EEPROM_BASE_BACKUP + i, var) != FLASH_COMPLETE) {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFLASH_Lock();\n\n\ttimeout_configure_IWDT();\n\n\treturn is_ok;\n}\n\n/**\n * Read hw-specific variable from emulated EEPROM.\n *\n * @param v\n * The variable to read the result from.\n *\n * @param address\n * Mapped address in EEPROM. Range 0 to 31.\n *\n * @return\n * true for success, false if variable was not found.\n */\nbool conf_general_read_eeprom_var_hw(eeprom_var *v, int address) {\n\tif (address < 0 || address >= EEPROM_VARS_HW) {\n\t\treturn false;\n\t}\n\treturn read_eeprom_var(v, address, EEPROM_BASE_HW);\n}\n\n/**\n * Read custom variable from emulated EEPROM.\n *\n * @param v\n * The variable to read the result from.\n *\n * @param address\n * Mapped address in EEPROM. Range 0 to 127.\n *\n * @return\n * true for success, false if variable was not found.\n */\nbool conf_general_read_eeprom_var_custom(eeprom_var *v, int address) {\n\tif (address < 0 || address >= EEPROM_VARS_CUSTOM) {\n\t\treturn false;\n\t}\n\treturn read_eeprom_var(v, address, EEPROM_BASE_CUSTOM);\n}\n\n/**\n * Store hw-specific variable to emulated EEPROM.\n *\n * @param v\n * The variable to store the result in.\n *\n * @param address\n * Mapped address in EEPROM. Range 0 to 31.\n *\n * @return\n * true for success, false if something went wrong.\n */\nbool conf_general_store_eeprom_var_hw(eeprom_var *v, int address) {\n\tif (address < 0 || address >= EEPROM_VARS_HW) {\n\t\treturn false;\n\t}\n\treturn store_eeprom_var(v, address, EEPROM_BASE_HW);\n}\n\n/**\n * Store custom variable to emulated EEPROM.\n *\n * @param v\n * The variable to store the result in.\n *\n * @param address\n * Mapped address in EEPROM. Range 0 to 127.\n *\n * @return\n * true for success, false if something went wrong.\n */\nbool conf_general_store_eeprom_var_custom(eeprom_var *v, int address) {\n\tif (address < 0 || address >= EEPROM_VARS_CUSTOM) {\n\t\treturn false;\n\t}\n\treturn store_eeprom_var(v, address, EEPROM_BASE_CUSTOM);\n}\n\nstatic bool read_eeprom_var(eeprom_var *v, int address, uint16_t base) {\n\tbool is_ok = true;\n\tuint16_t var0, var1;\n\n\tif (EE_ReadVariable(base + 2 * address, &var0) == 0 &&\n\t\t\tEE_ReadVariable(base + 2 * address + 1, &var1) == 0) {\n\t\tuint32_t res = ((uint32_t)var0) << 16 | var1;\n\t\tv->as_u32 = res;\n\t} else {\n\t\tis_ok = false;\n\t}\n\n\treturn is_ok;\n}\n\nstatic bool store_eeprom_var(eeprom_var *v, int address, uint16_t base) {\n\tbool is_ok = true;\n\tuint16_t var0, var1;\n\n\tvar0 = v->as_u32 >> 16;\n\tvar1 = v->as_u32 & 0xFFFF;\n\n\ttimeout_configure_IWDT_slowest();\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tif (EE_WriteVariable(base + address * 2, var0) != FLASH_COMPLETE) {\n\t\tis_ok = false;\n\t}\n\n\tif (is_ok) {\n\t\tif (EE_WriteVariable(base + address * 2 + 1, var1) != FLASH_COMPLETE) {\n\t\t\tis_ok = false;\n\t\t}\n\t}\n\n\tFLASH_Lock();\n\n\ttimeout_configure_IWDT();\n\n\treturn is_ok;\n}\n\n/**\n * Read app_configuration from EEPROM. If this fails, default values will be used.\n *\n * @param conf\n * A pointer to a app_configuration struct to write the read configuration to.\n */\nvoid conf_general_read_app_configuration(app_configuration *conf) {\n\tbool is_ok = true;\n\tuint8_t *conf_addr = (uint8_t*)conf;\n\tuint16_t var;\n\n\tfor (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {\n\t\tif (EE_ReadVariable(EEPROM_BASE_APPCONF + i, &var) == 0) {\n\t\t\tconf_addr[2 * i] = (var >> 8) & 0xFF;\n\t\t\tconf_addr[2 * i + 1] = var & 0xFF;\n\t\t} else {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// check CRC\n#ifdef TEST_BAD_APP_CRC\n\tconf->crc++;\n#endif\n\tif(conf->crc != app_calc_crc(conf)) {\n\t\tis_ok = false;\n//\t\tmc_interface_fault_stop(FAULT_CODE_FLASH_CORRUPTION_APP_CFG, false, false);\n\t\tfault_data f;\n\t\tf.fault = FAULT_CODE_FLASH_CORRUPTION_APP_CFG;\n\t\tterminal_add_fault_data(&f);\n\t}\n\n\t// Set the default configuration\n\tif (!is_ok) {\n\t\tconfgenerator_set_defaults_appconf(conf);\n\t}\n}\n\n/**\n * Write app_configuration to EEPROM.\n *\n * @param conf\n * A pointer to the configuration that should be stored.\n */\nbool conf_general_store_app_configuration(app_configuration *conf) {\n\tint motor_old = mc_interface_get_motor_thread();\n\n\tmc_interface_select_motor_thread(1);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_lock();\n\n\tif (!mc_interface_wait_for_motor_release(2.0)) {\n\t\tmc_interface_unlock();\n\t\tmc_interface_select_motor_thread(motor_old);\n\t\treturn false;\n\t}\n\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_lock();\n\n\tif (!mc_interface_wait_for_motor_release(2.0)) {\n\t\tmc_interface_unlock();\n\t\tmc_interface_select_motor_thread(motor_old);\n\t\treturn false;\n\t}\n\n\tutils_sys_lock_cnt();\n\n\ttimeout_configure_IWDT_slowest();\n\n\tbool is_ok = true;\n\tuint8_t *conf_addr = (uint8_t*)conf;\n\tuint16_t var;\n\n\tconf->crc = app_calc_crc(conf);\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tfor (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {\n\t\tvar = (conf_addr[2 * i] << 8) & 0xFF00;\n\t\tvar |= conf_addr[2 * i + 1] & 0xFF;\n\n\t\tif (EE_WriteVariable(EEPROM_BASE_APPCONF + i, var) != FLASH_COMPLETE) {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFLASH_Lock();\n\n\ttimeout_configure_IWDT();\n\n\tchThdSleepMilliseconds(100);\n\n\tmc_interface_select_motor_thread(1);\n\tmc_interface_unlock();\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_unlock();\n\n\tutils_sys_unlock_cnt();\n\n\tmc_interface_select_motor_thread(motor_old);\n\n\treturn is_ok;\n}\n\n/**\n * Read mc_configuration from EEPROM. If this fails, default values will be used.\n *\n * @param conf\n * A pointer to a mc_configuration struct to write the read configuration to.\n */\nvoid conf_general_read_mc_configuration(mc_configuration *conf, bool is_motor_2) {\n\tbool is_ok = true;\n\tuint8_t *conf_addr = (uint8_t*)conf;\n\tuint16_t var;\n\tunsigned int base = is_motor_2 ? EEPROM_BASE_MCCONF_2 : EEPROM_BASE_MCCONF;\n\n\tfor (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {\n\t\tif (EE_ReadVariable(base + i, &var) == 0) {\n\t\t\tconf_addr[2 * i] = (var >> 8) & 0xFF;\n\t\t\tconf_addr[2 * i + 1] = var & 0xFF;\n\t\t} else {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// check CRC\n#ifdef TEST_BAD_MC_CRC\n\tconf->crc++;\n#endif\n\tif(conf->crc != mc_interface_calc_crc(conf, is_motor_2)) {\n\t\tis_ok = false;\n//\t\tmc_interface_fault_stop(FAULT_CODE_FLASH_CORRUPTION_MC_CFG, is_motor_2, false);\n\t\tfault_data f;\n\t\tf.fault = FAULT_CODE_FLASH_CORRUPTION_MC_CFG;\n\t\tterminal_add_fault_data(&f);\n\t}\n\n\tif (!is_ok) {\n\t\tconfgenerator_set_defaults_mcconf(conf);\n\t}\n}\n\n/**\n * Write mc_configuration to EEPROM.\n *\n * @param conf\n * A pointer to the configuration that should be stored.\n */\nbool conf_general_store_mc_configuration(mc_configuration *conf, bool is_motor_2) {\n\tint motor_old = mc_interface_get_motor_thread();\n\n\tmc_interface_select_motor_thread(1);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_lock();\n\n\tif (!mc_interface_wait_for_motor_release(2.0)) {\n\t\tmc_interface_unlock();\n\t\tmc_interface_select_motor_thread(motor_old);\n\t\treturn false;\n\t}\n\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_lock();\n\n\tif (!mc_interface_wait_for_motor_release(2.0)) {\n\t\tmc_interface_unlock();\n\t\tmc_interface_select_motor_thread(motor_old);\n\t\treturn false;\n\t}\n\n\tutils_sys_lock_cnt();\n\n\ttimeout_configure_IWDT_slowest();\n\n\tbool is_ok = true;\n\tuint8_t *conf_addr = (uint8_t*)conf;\n\tunsigned int base = is_motor_2 ? EEPROM_BASE_MCCONF_2 : EEPROM_BASE_MCCONF;\n\n\tconf->crc = mc_interface_calc_crc(conf, is_motor_2);\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tfor (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {\n\t\tuint16_t var = (conf_addr[2 * i] << 8) & 0xFF00;\n\t\tvar |= conf_addr[2 * i + 1] & 0xFF;\n\n\t\tif (EE_WriteVariable(base + i, var) != FLASH_COMPLETE) {\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFLASH_Lock();\n\n\ttimeout_configure_IWDT();\n\n\tchThdSleepMilliseconds(100);\n\n\tmc_interface_select_motor_thread(1);\n\tmc_interface_unlock();\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_unlock();\n\n\tutils_sys_unlock_cnt();\n\n\tmc_interface_select_motor_thread(motor_old);\n\n\treturn is_ok;\n}\n\nbool conf_general_detect_motor_param(float current, float min_rpm, float low_duty,\n\t\tfloat *int_limit, float *bemf_coupling_k, int8_t *hall_table, int *hall_res) {\n\n\tint ok_steps = 0;\n\tconst float spinup_to_duty = 0.5;\n\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\n\t*mcconf = *mc_interface_get_configuration();\n\t*mcconf_old = *mcconf;\n\n\tmcconf->motor_type = MOTOR_TYPE_BLDC;\n\tmcconf->sensor_mode = SENSOR_MODE_SENSORLESS;\n\tmcconf->comm_mode = COMM_MODE_INTEGRATE;\n\tmcconf->sl_phase_advance_at_br = 1.0;\n\tmcconf->sl_min_erpm = min_rpm;\n\tmcconf->sl_bemf_coupling_k = 300;\n\tmcconf->sl_cycle_int_limit = 50;\n\tmcconf->sl_min_erpm_cycle_int_limit = 1100;\n\tmcconf->m_invert_direction = false;\n\tmc_interface_set_configuration(mcconf);\n\n\t// Wait maximum 5s for fault code to disappear\n\tfor (int i = 0;i < 500;i++) {\n\t\tif (mc_interface_get_fault() == FAULT_CODE_NONE) {\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\t// Wait one second for things to get ready after\n\t// the fault disappears. (will fry things otherwise...)\n\tchThdSleepMilliseconds(1000);\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\tmc_interface_lock();\n\n\tmc_interface_lock_override_once();\n\tmc_interface_set_current(current);\n\n\t// Try to spin up the motor. Up to three attempts with different settings are made.\n\tbool started = false;\n\tfor (int i = 0;i < 3;i++) {\n\t\tif (i == 1) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmcconf->sl_min_erpm = 2 * min_rpm;\n\t\t\tmcconf->sl_cycle_int_limit = 20;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_current(current);\n\t\t} else if (i == 2) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmcconf->sl_min_erpm = 4 * min_rpm;\n\t\t\tmcconf->comm_mode = COMM_MODE_DELAY;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_current(current);\n\t\t}\n\n\t\tint cnt = 0;\n\t\tbool switch_done = false;\n\t\tstarted = true;\n\n\t\twhile (mc_interface_get_duty_cycle_now() < spinup_to_duty) {\n\t\t\tchThdSleepMilliseconds(1);\n\t\t\tcnt++;\n\n\t\t\tif (mc_interface_get_duty_cycle_now() >= (spinup_to_duty / 2.0) && !switch_done) {\n\t\t\t\tmcpwm_switch_comm_mode(COMM_MODE_DELAY);\n\t\t\t\tswitch_done = true;\n\t\t\t}\n\n\t\t\tif (cnt > 2000 && !switch_done) {\n\t\t\t\tstarted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cnt >= 5000) {\n\t\t\t\tstarted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (switch_done) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!started) {\n\t\tmc_interface_set_current(0.0);\n\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmc_interface_unlock();\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn false;\n\t}\n\n\tok_steps++;\n\n\t// Reset hall sensor samples\n\tmcpwm_reset_hall_detect_table();\n\n\t// Run for a while to get hall sensor samples\n\tmc_interface_lock_override_once();\n\tmc_interface_set_duty(spinup_to_duty);\n\tchThdSleepMilliseconds(400);\n\n\t// Release the motor and wait a few commutations\n\tmc_interface_lock_override_once();\n\tmc_interface_set_current(0.0);\n\tint tacho = mc_interface_get_tachometer_value(0);\n\tfor (int i = 0;i < 2000;i++) {\n\t\tif ((mc_interface_get_tachometer_value(0) - tacho) < 3) {\n\t\t\tchThdSleepMilliseconds(1);\n\t\t} else {\n\t\t\tok_steps++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Average the cycle integrator for 50 commutations\n\tmcpwm_read_reset_avg_cycle_integrator();\n\ttacho = mc_interface_get_tachometer_value(false);\n\tfor (int i = 0;i < 3000;i++) {\n\t\tif ((mc_interface_get_tachometer_value(false) - tacho) < 50) {\n\t\t\tchThdSleepMilliseconds(1);\n\t\t} else {\n\t\t\tok_steps++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Get hall detect result\n\t*hall_res = mcpwm_get_hall_detect_result(hall_table);\n\n\t*int_limit = mcpwm_read_reset_avg_cycle_integrator();\n\n\t// Wait for the motor to slow down\n\tfor (int i = 0;i < 5000;i++) {\n\t\tif (mc_interface_get_duty_cycle_now() > low_duty) {\n\t\t\tchThdSleepMilliseconds(1);\n\t\t} else {\n\t\t\tok_steps++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmc_interface_lock_override_once();\n\tmc_interface_set_duty(low_duty);\n\n\t// Average the cycle integrator for 100 commutations\n\tmcpwm_read_reset_avg_cycle_integrator();\n\ttacho = mc_interface_get_tachometer_value(0);\n\tfloat rpm_sum = 0.0;\n\tfloat rpm_iterations = 0.0;\n\tfor (int i = 0;i < 3000;i++) {\n\t\tif ((mc_interface_get_tachometer_value(0) - tacho) < 100) {\n\t\t\trpm_sum += mc_interface_get_rpm();\n\t\t\trpm_iterations += 1;\n\t\t\tchThdSleepMilliseconds(1);\n\t\t} else {\n\t\t\tok_steps++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfloat avg_cycle_integrator_running = mcpwm_read_reset_avg_cycle_integrator();\n\tfloat rpm = rpm_sum / rpm_iterations;\n\n\tmc_interface_lock_override_once();\n\tmc_interface_release_motor();\n\tmc_interface_wait_for_motor_release(1.0);\n\n\t// Try to figure out the coupling factor\n\tavg_cycle_integrator_running -= *int_limit;\n\tavg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];\n\tavg_cycle_integrator_running *= rpm;\n\t*bemf_coupling_k = avg_cycle_integrator_running;\n\n\t// Restore settings\n\tmc_interface_set_configuration(mcconf_old);\n\ttimeout_configure(tout, tout_c, tout_ksw);\n\n\tmc_interface_unlock();\n\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_mcconf(mcconf_old);\n\n\treturn ok_steps == 5 ? true : false;\n}\n\n/**\n * Try to measure the motor flux linkage.\n *\n * @param current\n * The current so spin up the motor with.\n *\n * @param duty\n * The duty cycle to maintain.\n *\n * @param min_erpm\n * The minimum ERPM for the delay commutation mode.\n *\n * @param res\n * The motor phase resistance.\n *\n * @param linkage\n * The calculated flux linkage.\n *\n * @return\n * True for success, false otherwise.\n */\nbool conf_general_measure_flux_linkage(float current, float duty,\n\t\tfloat min_erpm, float res, float *linkage) {\n\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\n\t*mcconf = *mc_interface_get_configuration();\n\t*mcconf_old = *mcconf;\n\n\tmcconf->motor_type = MOTOR_TYPE_BLDC;\n\tmcconf->sensor_mode = SENSOR_MODE_SENSORLESS;\n\tmcconf->comm_mode = COMM_MODE_INTEGRATE;\n\tmcconf->sl_phase_advance_at_br = 1.0;\n\tmcconf->sl_min_erpm = min_erpm;\n\tmcconf->m_bldc_f_sw_min = 10000.0;\n\tmcconf->sl_bemf_coupling_k = 300;\n\tmcconf->sl_cycle_int_limit = 50;\n\tmcconf->sl_min_erpm_cycle_int_limit = 1100;\n\tmc_interface_set_configuration(mcconf);\n\n\t// Wait maximum 5s for fault code to disappear\n\tfor (int i = 0;i < 500;i++) {\n\t\tif (mc_interface_get_fault() == FAULT_CODE_NONE) {\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\tif (mc_interface_get_fault() != FAULT_CODE_NONE) {\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn false;\n\t}\n\n\t// Wait one second for things to get ready after\n\t// the fault disapears.\n\tchThdSleepMilliseconds(1000);\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\tmc_interface_lock();\n\n\tmc_interface_lock_override_once();\n\tmc_interface_set_current(current);\n\n\t// Try to spin up the motor. Up to three attempts with different settings are made.\n\tbool started = false;\n\tfor (int i = 0;i < 4;i++) {\n\t\tif (i == 1) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmcconf->sl_cycle_int_limit = 250;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_current(current);\n\t\t} else if (i == 2) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmcconf->sl_min_erpm = 2 * min_erpm;\n\t\t\tmcconf->sl_cycle_int_limit = 20;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_current(current);\n\t\t} else if (i == 3) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmcconf->sl_min_erpm = 4 * min_erpm;\n\t\t\tmcconf->comm_mode = COMM_MODE_DELAY;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_current(current);\n\t\t}\n\n\t\tint cnt = 0;\n\t\tbool switch_done = false;\n\t\tstarted = true;\n\n\t\twhile (mc_interface_get_duty_cycle_now() < duty) {\n\t\t\tchThdSleepMilliseconds(1);\n\t\t\tcnt++;\n\n\t\t\tif (mc_interface_get_duty_cycle_now() >= (duty / 2.0) && !switch_done) {\n\t\t\t\tmcpwm_switch_comm_mode(COMM_MODE_DELAY);\n\t\t\t\tswitch_done = true;\n\t\t\t}\n\n\t\t\tif (cnt > 2000 && !switch_done) {\n\t\t\t\tstarted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cnt >= 5000) {\n\t\t\t\tstarted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (switch_done) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!started) {\n\t\tmc_interface_set_current(0.0);\n\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\tmc_interface_set_configuration(mcconf);\n\t\tmc_interface_unlock();\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn false;\n\t}\n\n\tmc_interface_lock_override_once();\n\tmc_interface_set_duty(duty);\n\n\tfloat avg_voltage = 0.0;\n\tfloat avg_rpm = 0.0;\n\tfloat avg_current = 0.0;\n\tfloat samples = 0.0;\n\tfor (int i = 0;i < 2000;i++) {\n\t\tavg_voltage += GET_INPUT_VOLTAGE() * mc_interface_get_duty_cycle_now();\n\t\tavg_rpm += mc_interface_get_rpm();\n\t\tavg_current += mc_interface_get_tot_current();\n\t\tsamples += 1.0;\n\t\tchThdSleepMilliseconds(1.0);\n\t}\n\n\ttimeout_configure(tout, tout_c, tout_ksw);\n\tmc_interface_set_configuration(mcconf_old);\n\tmc_interface_unlock();\n\tmc_interface_set_current(0.0);\n\n\tavg_voltage /= samples;\n\tavg_rpm /= samples;\n\tavg_current /= samples;\n\tavg_voltage -= avg_current * res * 2.0;\n\n\t*linkage = avg_voltage / (sqrtf(3.0) * RPM2RADPS_f(avg_rpm));\n\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_mcconf(mcconf_old);\n\n\treturn true;\n}\n\n/* Calculate DTG register */\nuint8_t conf_general_calculate_deadtime(float deadtime_ns, float core_clock_freq) {\n\tuint8_t DTG = 0;\n\tfloat timebase = 1.0 / (core_clock_freq / 1000000.0) * 1000.0;\n\n\tif (deadtime_ns <= (timebase * 127.0)) {\n\t\tDTG = deadtime_ns / timebase;\n\t} else {\n\t\tif (deadtime_ns <= ((63.0 + 64.0) * 2.0 * timebase)) {\n\t\t\tDTG = deadtime_ns / (2.0 * timebase) - 64.0;\n\t\t\tDTG |= 0x80;\n\t\t} else {\n\t\t\tif (deadtime_ns <= ((31.0 + 32.0) * 8.0 * timebase)) {\n\t\t\t\tDTG = deadtime_ns / (8.0 * timebase) - 32.0;\n\t\t\t\tDTG |= 0xC0;\n\t\t\t} else {\n\t\t\t\tif (deadtime_ns <= ((31.0 + 32) * 16 * timebase)) {\n\t\t\t\t\tDTG = deadtime_ns / (16.0 * timebase) - 32.0;\n\t\t\t\t\tDTG |= 0xE0;\n\t\t\t\t} else {\n\t\t\t\t\t// Deadtime requested is longer than max achievable. Set deadtime at\n\t\t\t\t\t// longest possible value\n\t\t\t\t\tDTG = 0xFF;\n\t\t\t\t\tassert_param(1); //catch this\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DTG;\n}\n\n/**\n * Try to measure the motor flux linkage using open loop FOC control.\n *\n * @param current\n * The Q-axis current to spin up the motor.\n *\n * @param duty\n * Duty cycle % to measure at\n *\n * @param erpm_per_sec\n * Acceleration rate\n *\n * @param res\n * The motor phase resistance.\n *\n * @param ind\n * The motor phase inductance.\n *\n * @param linkage\n * The calculated flux linkage.\n *\n * @param linkage_undriven\n * Flux linkage measured while the motor was undriven.\n *\n * @param undriven_samples\n * Number of flux linkage samples while the motor was undriven.\n *\n * @param result\n * True for success, false for anything else\n *\n * @return\n * Fault code\n */\nint conf_general_measure_flux_linkage_openloop(float current, float duty,\n\t\tfloat erpm_per_sec, float res, float ind, float *linkage,\n\t\tfloat *linkage_undriven, float *undriven_samples, bool *result) {\n\n\t*result = false;\n\tint fault = FAULT_CODE_NONE;\n\n\t// Allow using old values when only measuring the flux linkage undriven\n\tif (fabsf(current) <= mc_interface_get_configuration()->cc_min_current) {\n\t\tif (res <= 0.0) {\n\t\t\tres = mc_interface_get_configuration()->foc_motor_r;\n\t\t}\n\t\tif (ind <= 0.0) {\n\t\t\tind = mc_interface_get_configuration()->foc_motor_l;\n\t\t}\n\t}\n\n\t// Don't let impossible values through.\n\tif (res <= 0.0 || ind <= 0.0) {\n\t\treturn fault;\n\t}\n\t// Calculate kp and ki from supplied resistance and inductance, default to 1000us time constant.\n\tfloat tc = 1500;\n\tfloat bw = 1.0 / (tc * 1e-6);\n\tfloat kp = ind * bw;\n\tfloat ki = res * bw;\n\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\n\t*mcconf = *mc_interface_get_configuration();\n\t*mcconf_old = *mcconf;\n\n\tif (duty > (mcconf->l_max_duty * 0.9)) {\n\t\tduty = mcconf->l_max_duty * 0.9;\n\t}\n\n\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\tmcconf->foc_sensor_mode = FOC_SENSOR_MODE_SENSORLESS;\n\tmcconf->foc_current_kp = kp;\n\tmcconf->foc_current_ki = ki;\n\tmcconf->foc_cc_decoupling = FOC_CC_DECOUPLING_DISABLED;\n\tmc_interface_set_configuration(mcconf);\n\n\t// Wait maximum 5s for fault code to disappear\n\tfor (int i = 0;i < 500;i++) {\n\t\tif (mc_interface_get_fault() == FAULT_CODE_NONE) {\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\tfault = mc_interface_get_fault();\n\tif (fault != FAULT_CODE_NONE) {\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn fault;\n\t}\n\n\t// Wait one second for things to get ready after\n\t// the fault disapears.\n\tchThdSleepMilliseconds(1000);\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\tmc_interface_lock();\n\n\tint cnt = 0;\n\tfloat rpm_now = 0;\n\n\tif (fabsf(current) > mcconf->cc_min_current) {\n\t\t// Start by locking the motor\n\t\tfor (int i = 0;i < 200;i++) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_openloop_current((float)i * current / 200.0, rpm_now);\n\t\t\tfault = mc_interface_get_fault();\n\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\t\tmc_interface_unlock();\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\t\treturn fault;\n\t\t\t}\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\n\t\tfloat duty_still = 0;\n\t\tfloat samples = 0;\n\t\tfor (int i = 0;i < 1000;i++) {\n\t\t\tduty_still += fabsf(mc_interface_get_duty_cycle_now());\n\t\t\tsamples += 1.0;\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\n\t\tfault = mc_interface_get_fault();\n\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\tmc_interface_unlock();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\tmempools_free_mcconf(mcconf);\n\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\treturn fault;\n\t\t}\n\n\t\tduty_still /= samples;\n\t\tfloat duty_max = 0.0;\n\t\tconst int max_time = 15000;\n\n\t\twhile (fabsf(mc_interface_get_duty_cycle_now()) < duty) {\n\t\t\trpm_now += erpm_per_sec / 1000.0;\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_openloop_current(current, mcconf->m_invert_direction ? -rpm_now : rpm_now);\n\n\t\t\tfault = mc_interface_get_fault();\n\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\t\tmc_interface_unlock();\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\t\treturn fault;\n\t\t\t}\n\n\n\t\t\tchThdSleepMilliseconds(1);\n\t\t\tcnt++;\n\n\t\t\tfloat duty_now = fabsf(mc_interface_get_duty_cycle_now());\n\n\t\t\tif (duty_now > duty_max) {\n\t\t\t\tduty_max = duty_now;\n\t\t\t}\n\n\t\t\tif (cnt >= max_time) {\n\t\t\t\t*linkage = -1.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cnt > 4000 && duty_now < (duty_max * 0.7)) {\n\t\t\t\tcnt = max_time;\n\t\t\t\t*linkage = -2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cnt > 4000 && duty < duty_still * 1.1) {\n\t\t\t\tcnt = max_time;\n\t\t\t\t*linkage = -3.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rpm_now >= 12000) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tchThdSleepMilliseconds(1000);\n\n\t\tif (cnt < max_time) {\n\t\t\tfloat vq_avg = 0.0;\n\t\t\tfloat vd_avg = 0.0;\n\t\t\tfloat iq_avg = 0.0;\n\t\t\tfloat id_avg = 0.0;\n\t\t\tfloat samples2 = 0.0;\n\n\t\t\tfor (int i = 0;i < 10000;i++) {\n\t\t\t\tvq_avg += mcpwm_foc_get_vq();\n\t\t\t\tvd_avg += mcpwm_foc_get_vd();\n\t\t\t\tiq_avg += mcpwm_foc_get_iq();\n\t\t\t\tid_avg += mcpwm_foc_get_id();\n\t\t\t\tsamples2 += 1.0;\n\t\t\t\tchThdSleep(1);\n\n\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvq_avg /= samples2;\n\t\t\tvd_avg /= samples2;\n\t\t\tiq_avg /= samples2;\n\t\t\tid_avg /= samples2;\n\n\t\t\tfloat rad_s = RPM2RADPS_f(rpm_now);\n\t\t\tfloat v_mag = NORM2_f(vq_avg, vd_avg);\n\t\t\tfloat i_mag = NORM2_f(iq_avg, id_avg);\n\t\t\t*linkage = (v_mag - res * i_mag) / rad_s - i_mag * ind;\n\n\t\t\tmcconf->foc_motor_r = res;\n\t\t\tmcconf->foc_motor_l = ind;\n\t\t\tmcconf->foc_motor_flux_linkage = *linkage;\n\t\t\tmcconf->foc_observer_gain = 0.5e3 / SQ(*linkage);\n\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t// Give the observer time to settle\n\t\t\tchThdSleepMilliseconds(500);\n\n\t\t\t// Turn off the FETs\n\t\t\tmcpwm_foc_stop_pwm(mc_interface_get_motor_thread() == 2);\n\n\t\t\t// Clear any lingering current set points\n\t\t\tmcpwm_foc_set_current(0.0);\n\n\t\t\t// Let the H-bridges settle\n\t\t\tchThdSleepMilliseconds(5);\n\t\t}\n\t} else {\n\t\t*linkage = 0.0;\n\t}\n\n\tfloat linkage_sum = 0.0;\n\tfloat linkage_samples = 0.0;\n\tif (fault == FAULT_CODE_NONE) {\n\t\tfor (int i = 0;i < 2000;i++) {\n\t\t\tfloat rad_s_now = RPM2RADPS_f(mcpwm_foc_get_rpm_faster());\n\t\t\tif (fabsf(mcpwm_foc_get_duty_cycle_now()) < 0.02) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlinkage_sum += mcpwm_foc_get_vq() / rad_s_now;\n\n\t\t\t// Optionally use magnitude\n\t\t\t//              linkage_sum += sqrtf(SQ(mcpwm_foc_get_vq()) + SQ(mcpwm_foc_get_vd())) / rad_s_now;\n\n\t\t\t// Optionally use magnitude of observer state\n\t\t\t//              float x1, x2;\n\t\t\t//              mcpwm_foc_get_observer_state(&x1, &x2);\n\t\t\t//              linkage_sum += sqrtf(SQ(x1) + SQ(x2));\n\n\t\t\tlinkage_samples += 1.0;\n\t\t\tchThdSleep(1);\n\n\t\t\tfault = mc_interface_get_fault();\n\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*undriven_samples = linkage_samples;\n\n\t\tif (linkage_samples > 0) {\n\t\t\t*linkage_undriven = linkage_sum / linkage_samples;\n\t\t\t*result = true;\n\t\t} else {\n\t\t\t*linkage_undriven = 0.0;\n\t\t}\n\n\t\tif (*linkage > 0.0) {\n\t\t\t*result = true;\n\t\t}\n\t}\n\n\t// Some functions use 0 to detect a failure\n\tif (fault != FAULT_CODE_NONE) {\n\t\t*linkage_undriven = 0.0;\n\t\t*linkage = 0.0;\n\t}\n\n\ttimeout_configure(tout, tout_c, tout_ksw);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_wait_for_motor_release(1.0);\n\tmc_interface_set_configuration(mcconf_old);\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_mcconf(mcconf_old);\n\treturn fault;\n}\n\n/**\n * Automatically detect sensors and apply settings in FOC mode.\n *\n * @param current\n * Current to use for detection.\n *\n * @param store_mcconf_on_success\n * Store motor configuration in emulated EEPROM if the detection succeeds.\n *\n * @param send_mcconf_on_success\n * Send motor configuration if the detection succeeds.\n *\n * @result\n * 2: AS5147 detected successfully\n * 1: Hall sensors detected successfully\n * 0: No sensors detected and sensorless mode applied successfully\n * -1: Detection failed\n *\n * @return\n * The fault code\n */\nint conf_general_autodetect_apply_sensors_foc(float current,\n\t\t\t\t\t\t\t\t\t\t\t  bool store_mcconf_on_success, bool send_mcconf_on_success, int *result) {\n\t*result = -1;\n\tint fault = FAULT_CODE_NONE;\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\n\t*mcconf = *mc_interface_get_configuration();\n\t*mcconf_old = *mcconf;\n\n\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\tmcconf->foc_sensor_mode = FOC_SENSOR_MODE_SENSORLESS;\n\tmcconf->foc_current_kp = 0.0005;\n\tmcconf->foc_current_ki = 1.0;\n\tmc_interface_set_configuration(mcconf);\n\n\t// Wait maximum 5s for fault code to disappear\n\tfor (int i = 0;i < 500;i++) {\n\t\tif (mc_interface_get_fault() == FAULT_CODE_NONE) {\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\tfault = mc_interface_get_fault();\n\tif (fault != FAULT_CODE_NONE) {\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn fault;\n\t}\n\n\t// Wait one second for things to get ready after\n\t// the fault disappears.\n\tchThdSleepMilliseconds(1000);\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\tmc_interface_lock();\n\n\t// Hall sensors\n\tmcconf->m_sensor_port_mode = SENSOR_PORT_MODE_HALL;\n\tmc_interface_set_configuration(mcconf);\n\n\tuint8_t hall_table[8];\n\tbool res;\n\tfault = mcpwm_foc_hall_detect(current, hall_table, &res);\n\tif (fault != FAULT_CODE_NONE) {\n\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\tmc_interface_unlock();\n\t\tmc_interface_release_motor();\n\t\tmc_interface_wait_for_motor_release(1.0);\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t\treturn fault;\n\t}\n\t// Lock again, as hall detection will undo the lock\n\tmc_interface_lock();\n\n\tif (res) {\n\t\tmcconf_old->m_sensor_port_mode = SENSOR_PORT_MODE_HALL;\n\t\tmcconf_old->foc_sensor_mode = FOC_SENSOR_MODE_HALL;\n\t\tfor (int i = 0;i < 8;i++) {\n\t\t\tmcconf_old->foc_hall_table[i] = hall_table[i];\n\t\t}\n\n\t\t*result = 1;\n\t}\n\n\t// AS5047 encoder\n#ifndef HW_HAS_DUAL_MOTORS\n\tif (!res) {\n\t\tmcconf->m_sensor_port_mode = SENSOR_PORT_MODE_AS5047_SPI;\n\t\tmc_interface_set_configuration(mcconf);\n\n\t\tfor (int i = 0;i < 1000;i++) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_openloop_phase((float)i * current / 1000.0, 0.0);\n\t\t\tfault = mc_interface_get_fault();\n\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\t\tmc_interface_unlock();\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\t\treturn fault;\n\t\t\t}\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\n\t\tfloat phase_start = encoder_read_deg();\n\t\tfloat phase_mid = 0.0;\n\t\tfloat phase_end = 0.0;\n\n\t\tfor (int i = 0;i < 180.0;i++) {\n\t\t\tmc_interface_lock_override_once();\n\t\t\tmc_interface_set_openloop_phase(current, i);\n\t\t\tfault = mc_interface_get_fault();\n\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\t\tmc_interface_unlock();\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\t\treturn fault;\n\t\t\t}\n\n\t\t\tchThdSleepMilliseconds(5);\n\n\t\t\tif (i == 90) {\n\t\t\t\tphase_mid = encoder_read_deg();\n\t\t\t}\n\t\t}\n\n\t\tphase_end = encoder_read_deg();\n\t\tfloat diff = fabsf(utils_angle_difference(phase_start, phase_end));\n\t\tfloat diff_mid = fabsf(utils_angle_difference(phase_mid, phase_end));\n\n\t\tif (diff > 2.0 && (diff_mid - diff / 2.0) < (diff / 4)) {\n\t\t\tfloat offset, ratio;\n\t\t\tbool inverted;\n\t\t\tmcpwm_foc_encoder_detect(current, false, &offset, &ratio, &inverted);\n\t\t\tmcconf_old->m_sensor_port_mode = SENSOR_PORT_MODE_AS5047_SPI;\n\t\t\tmcconf_old->foc_sensor_mode = FOC_SENSOR_MODE_ENCODER;\n\t\t\tmcconf_old->foc_encoder_offset = offset;\n\t\t\tmcconf_old->foc_encoder_ratio = ratio;\n\t\t\tmcconf_old->foc_encoder_inverted = inverted;\n\n\t\t\tres = true;\n\t\t\t*result = 2;\n\t\t}\n\t}\n#endif\n\n\t// Sensorless\n\tif (!res) {\n\t\tmcconf_old->foc_sensor_mode = FOC_SENSOR_MODE_SENSORLESS;\n\t\t*result = 0;\n\t\tres = true;\n\t}\n\n\ttimeout_configure(tout, tout_c, tout_ksw);\n\tmc_interface_unlock();\n\tmc_interface_release_motor();\n\tmc_interface_wait_for_motor_release(1.0);\n\tmc_interface_set_configuration(mcconf_old);\n\n\t// On success store the mc configuration, also send it to VESC Tool.\n\tif (res) {\n\t\tif (store_mcconf_on_success) {\n\t\t\tconf_general_store_mc_configuration(mcconf_old,\n\t\t\t\t\t\t\t\t\t\t\t\tmc_interface_get_motor_thread() == 2);\n\t\t}\n\n\t\tif (send_mcconf_on_success) {\n\t\t\tcommands_send_mcconf(COMM_GET_MCCONF, mcconf_old, 0);\n\t\t}\n\t}\n\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_mcconf(mcconf_old);\n\n\treturn fault;\n}\n\nvoid conf_general_calc_apply_foc_cc_kp_ki_gain(mc_configuration *mcconf, float tc) {\n\tfloat r = mcconf->foc_motor_r;\n\tfloat l = mcconf->foc_motor_l;\n\tfloat lambda = mcconf->foc_motor_flux_linkage;\n\n\tfloat bw = 1.0 / (tc * 1e-6);\n\tfloat kp = l * bw;\n\tfloat ki = r * bw;\n\tfloat gain = 1.0e-3 / SQ(lambda);\n\t//\tfloat gain = (0.00001 / r) / SQ(lambda); // Old method\n\n\tmcconf->foc_current_kp = kp;\n\tmcconf->foc_current_ki = ki;\n\tmcconf->foc_observer_gain = gain * 1e6;\n}\n\nstatic int measure_r_l_imax(float current_min, float current_max,\n\t\t\t\t\t\t\tfloat max_power_loss, float *r, float *l, float *ld_lq_diff, float *i_max) {\n\tfloat current_start = current_max / 50;\n\tif (current_start < (current_min * 1.1)) {\n\t\tcurrent_start = current_min * 1.1;\n\t}\n\n\tint fault = FAULT_CODE_NONE;\n\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t*mcconf = *mc_interface_get_configuration();\n\n\tconst float res_old = mcconf->foc_motor_r;\n\n\tfloat i_last = 0.0;\n\tfor (float i = current_start;i < current_max;i *= 1.5) {\n\t\tfloat res_tmp = 0.0;\n\t\tfault = mcpwm_foc_measure_resistance(i, 5, false, &res_tmp);\n\t\ti_last = i;\n\n\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\tmempools_free_mcconf(mcconf);\n\t\t\treturn fault;\n\t\t}\n\n\t\tif ((i * i * res_tmp * 1.5) >= (max_power_loss / 5.0)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfault = mcpwm_foc_measure_resistance(i_last, 100, true, r);\n\tif (fault != FAULT_CODE_NONE) {\n\t\tmempools_free_mcconf(mcconf);\n\t\treturn fault;\n\t}\n\n\tmcconf->foc_motor_r = *r;\n\tmc_interface_set_configuration(mcconf);\n\n\tfault = mcpwm_foc_measure_inductance_current(i_last, 100, 0, ld_lq_diff, l);\n\n\t*l *= 1e-6;\n\t*ld_lq_diff *= 1e-6;\n\t*i_max = sqrtf(max_power_loss / *r / 1.5);\n\tutils_truncate_number(i_max, HW_LIM_CURRENT);\n\n\tmcconf->foc_motor_r = res_old;\n\tmc_interface_set_configuration(mcconf);\n\tmempools_free_mcconf(mcconf);\n\n\treturn fault;\n}\n\nstatic bool wait_fault(int timeout_ms) {\n\tint motor_last = mc_interface_get_motor_thread();\n\n\tfor (int i = 0;i < (timeout_ms / 10);i++) {\n\t\tmc_interface_select_motor_thread(1);\n\t\tmc_fault_code fault1 = mc_interface_get_fault();\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_fault_code fault2 = mc_interface_get_fault();\n\n\t\tif (fault1 == FAULT_CODE_NONE && fault2 == FAULT_CODE_NONE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\tmc_interface_select_motor_thread(1);\n\tmc_fault_code fault1 = mc_interface_get_fault();\n\tmc_interface_select_motor_thread(2);\n\tmc_fault_code fault2 = mc_interface_get_fault();\n\n\tmc_interface_select_motor_thread(motor_last);\n\n\treturn fault1 == FAULT_CODE_NONE && fault2 == FAULT_CODE_NONE;\n}\n\nstatic bool wait_motor_stop(int timeout_ms) {\n\tint motor_last = mc_interface_get_motor_thread();\n\n\tfor (int i = 0;i < (timeout_ms / 10);i++) {\n\t\tmc_interface_select_motor_thread(1);\n\t\tfloat rpm1 = mc_interface_get_rpm();\n\t\tmc_interface_select_motor_thread(2);\n\t\tfloat rpm2 = mc_interface_get_rpm();\n\n\t\tif (fabsf(rpm1) < 100.0 && fabsf(rpm2) < 100.0) {\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\tmc_interface_select_motor_thread(1);\n\tfloat rpm1 = mc_interface_get_rpm();\n\tmc_interface_select_motor_thread(2);\n\tfloat rpm2 = mc_interface_get_rpm();\n\n\tmc_interface_select_motor_thread(motor_last);\n\n\treturn fabsf(rpm1) < 100.0 && fabsf(rpm2) < 100.0;\n}\n\n#ifdef HW_HAS_DUAL_MOTORS\ntypedef struct {\n\tfloat current_min;\n\tfloat current_max;\n\tfloat max_power_loss;\n\tfloat r;\n\tfloat l;\n\tfloat ld_lq_diff;\n\tfloat i_max;\n\tint fault;\n\tint motor;\n} measure_r_l_imax_arg_t;\n\nstatic void measure_r_l_imax_task(void *arg) {\n\tmeasure_r_l_imax_arg_t *args = (measure_r_l_imax_arg_t*)arg;\n\tmc_interface_select_motor_thread(args->motor);\n\targs->fault = measure_r_l_imax(\n\t\t\t\targs->current_min,\n\t\t\t\targs->current_max,\n\t\t\t\targs->max_power_loss,\n\t\t\t\t&args->r, &args->l, &args->ld_lq_diff, &args->i_max);\n}\n\ntypedef struct {\n\tfloat current;\n\tfloat duty;\n\tfloat erpm_per_sec;\n\tfloat res;\n\tfloat ind;\n\tfloat linkage;\n\tint fault;\n\tbool result;\n\tint motor;\n} measure_flux_linkage_arg_t;\n\nstatic void measure_flux_linkage_task(void *arg) {\n\tmeasure_flux_linkage_arg_t *args = (measure_flux_linkage_arg_t*)arg;\n\tmc_interface_select_motor_thread(args->motor);\n\n\tfloat linkage, linkage_undriven, undriven_samples;\n\n\targs->fault = conf_general_measure_flux_linkage_openloop(\n\t\t\t\targs->current,\n\t\t\t\targs->duty,\n\t\t\t\targs->erpm_per_sec,\n\t\t\t\targs->res,\n\t\t\t\targs->ind,\n\t\t\t\t&linkage,\n\t\t\t\t&linkage_undriven,\n\t\t\t\t&undriven_samples,\n\t\t\t\t&args->result);\n\n\tif (undriven_samples > 60) {\n\t\targs->linkage = linkage_undriven;\n\t\tif (args->linkage <= 0.0){\n\t\t\targs->result = false;\n\t\t}\n\t} else {\n\t\targs->linkage = linkage;\n\t}\n}\n\ntypedef struct {\n\tfloat current;\n\tbool store_mcconf_on_success;\n\tbool send_mcconf_on_success;\n\tint fault;\n\tint res;\n\tint motor;\n} detect_sensors_arg_t;\n\nstatic void detect_sensors_task(void *arg) {\n\tdetect_sensors_arg_t *args = (detect_sensors_arg_t*)arg;\n\tmc_interface_select_motor_thread(args->motor);\n\n\n\n\targs->fault = conf_general_autodetect_apply_sensors_foc(\n\t\t\t\targs->current,\n\t\t\t\targs->store_mcconf_on_success,\n\t\t\t\targs->send_mcconf_on_success,\n\t\t\t\t&args->res);\n}\n#endif\n\n/**\n * Detect and apply all parameters, current limits and sensors. This is done for\n * both motors on dual controllers.\n *\n * @param max_power_loss\n * The maximum power loss to derive current limits, as well as detection currents, from.\n *\n * @param store_mcconf_on_success\n * Store motor configuration in emulated EEPROM if the detection succeeds.\n *\n * @param send_mcconf_on_success\n * Send motor configuration if the detection succeeds.\n *\n * @return\n * >=0: Success, see conf_general_autodetect_apply_sensors_foc codes\n * -10: Flux linkage detection failed\n *  -x: see conf_general_autodetect_apply_sensors_foc faults\n *  -100 + fault: Fault code that occured during detection see \"mc_fault_code\"\n */\nint conf_general_detect_apply_all_foc(float max_power_loss,\n\t\t\t\t\t\t\t\t\t  bool store_mcconf_on_success, bool send_mcconf_on_success) {\n\tint result = -1;\n\n\tint faultM1 = FAULT_CODE_NONE;\n\tint faultM2 = FAULT_CODE_NONE;\n\n\t// Measure DC offsets\n\t// Needs to be done before getting the motor configuration\n\tif(mcpwm_foc_dc_cal(false) == -1) {\n\t\treturn mc_interface_get_fault() - 100; // Offset fault by -100\n\t}\n\n\tint motor_last = mc_interface_get_motor_thread();\n\tmc_interface_select_motor_thread(1);\n\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\n\t*mcconf = *mc_interface_get_configuration();\n\t*mcconf_old = *mcconf;\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_select_motor_thread(2);\n\tmc_configuration *mcconf_second = mempools_alloc_mcconf();\n\tmc_configuration *mcconf_old_second = mempools_alloc_mcconf();\n\t*mcconf_second = *mc_interface_get_configuration();\n\t*mcconf_old_second = *mcconf_second;\n\tmc_interface_select_motor_thread(1);\n#endif\n\n\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\tmcconf->foc_sensor_mode = FOC_SENSOR_MODE_SENSORLESS;\n\tmcconf->foc_f_zv = 10000.0; // Lower f_zv => less dead-time distortion\n\tmcconf->foc_current_kp = 0.0005;\n\tmcconf->foc_current_ki = 1.0;\n\tmcconf->l_current_max = MCCONF_L_CURRENT_MAX;\n\tmcconf->l_current_min = MCCONF_L_CURRENT_MIN;\n\tmcconf->l_abs_current_max = MCCONF_L_MAX_ABS_CURRENT;\t\t\t\n\tmcconf->l_current_max_scale = MCCONF_L_CURRENT_MAX_SCALE;\n\tmcconf->l_current_min_scale = MCCONF_L_CURRENT_MIN_SCALE;\n\tmcconf->l_watt_max = MCCONF_L_WATT_MAX;\n\tmcconf->l_watt_min = MCCONF_L_WATT_MIN;\n\tmcconf->l_max_erpm = MCCONF_L_RPM_MAX;\n\tmcconf->l_min_erpm = MCCONF_L_RPM_MIN;\n\tmc_interface_set_configuration(mcconf);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmcconf_second->motor_type = MOTOR_TYPE_FOC;\n\tmcconf_second->foc_sensor_mode = FOC_SENSOR_MODE_SENSORLESS;\n\tmcconf_second->foc_f_zv = 10000.0; // Lower f_zv => less dead-time distortion\n\tmcconf_second->foc_current_kp = 0.0005;\n\tmcconf_second->foc_current_ki = 1.0;\n\tmcconf_second->l_current_max = MCCONF_L_CURRENT_MAX;\n\tmcconf_second->l_current_min = MCCONF_L_CURRENT_MIN;\n\tmcconf_second->l_abs_current_max = MCCONF_L_MAX_ABS_CURRENT;\n\tmcconf_second->l_current_max_scale = MCCONF_L_CURRENT_MAX_SCALE;\n\tmcconf_second->l_current_min_scale = MCCONF_L_CURRENT_MIN_SCALE;\n\tmcconf_second->l_watt_max = MCCONF_L_WATT_MAX;\n\tmcconf_second->l_watt_min = MCCONF_L_WATT_MIN;\n\tmcconf_second->l_max_erpm = MCCONF_L_RPM_MAX;\n\tmcconf_second->l_min_erpm = MCCONF_L_RPM_MIN;\n\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_set_configuration(mcconf_second);\n\tmc_interface_select_motor_thread(1);\n#endif\n\n\t// Wait maximum 5s for fault code to disappear\n\tif (!wait_fault(5000)) {\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_interface_set_configuration(mcconf_old_second);\n\t\tmc_interface_select_motor_thread(1);\n\t\tmempools_free_mcconf(mcconf_second);\n\t\tmempools_free_mcconf(mcconf_old_second);\n#endif\n\t\tmc_interface_select_motor_thread(motor_last);\n\t\treturn mc_interface_get_fault() - 100; // Offset fault by -100\n\t}\n\n\t// Wait one second for things to get ready after\n\t// the fault disappears.\n\tchThdSleepMilliseconds(1000);\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\tmc_interface_lock();\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_select_motor_thread(2);\n\tmc_interface_lock();\n\tmc_interface_select_motor_thread(1);\n#endif\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmeasure_r_l_imax_arg_t r_l_imax_args;\n\tr_l_imax_args.current_min = mcconf->cc_min_current;\n\tr_l_imax_args.current_max = mcconf->l_current_max;\n\tr_l_imax_args.max_power_loss = max_power_loss;\n\tr_l_imax_args.motor = 2;\n\tworker_execute(measure_r_l_imax_task, &r_l_imax_args);\n#endif\n\n\tfloat r = 0.0;\n\tfloat l = 0.0;\n\tfloat ld_lq_diff;\n\tfloat i_max = 0.0;\n\tfaultM1 = measure_r_l_imax(mcconf->cc_min_current,\n\t\t\t\t\t\t\t   mcconf->l_current_max, max_power_loss, &r, &l, &ld_lq_diff, &i_max);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tworker_wait();\n\tfaultM2 = r_l_imax_args.fault;\n#endif\n\n\tif (faultM1 != FAULT_CODE_NONE || faultM2 != FAULT_CODE_NONE) {\n\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\tmc_interface_unlock();\n\t\tmc_interface_release_motor();\n\t\tmc_interface_wait_for_motor_release(1.0);\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_interface_set_configuration(mcconf_old_second);\n\t\tmc_interface_select_motor_thread(1);\n\t\tmempools_free_mcconf(mcconf_second);\n\t\tmempools_free_mcconf(mcconf_old_second);\n#endif\n\t\tmc_interface_select_motor_thread(motor_last);\n\t\tif(faultM1 != FAULT_CODE_NONE) {\n\t\t\treturn faultM1 - 100; // Offset fault codes by -100 to leave room for extra fault codes to be added later.\n\t\t} else {\n\t\t\treturn faultM2 - 100;\n\t\t}\n\t}\n\n\t// Increase switching frequency for flux linkage measurement\n\t// as dead-time distortion has less effect at higher modulation.\n\t// Having a smooth rotation is more important.\n#ifdef HW_HAS_DUAL_MOTORS\n\tmcconf->foc_f_zv = 25000.0;\n#else\n\tif (mcconf->foc_control_sample_mode == FOC_CONTROL_SAMPLE_MODE_V0_V7) {\n\t\tmcconf->foc_f_zv = 25000.0;\n\t} else {\n\t\tmcconf->foc_f_zv = 40000.0;\n\t}\n#endif\n\tmc_interface_set_configuration(mcconf);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_select_motor_thread(2);\n\tmcconf_second->foc_f_zv = 25000.0; // TODO: Is 40khz here actually OK?\n\tmc_interface_set_configuration(mcconf_second);\n\tmc_interface_select_motor_thread(1);\n#endif\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmeasure_flux_linkage_arg_t linkage_args;\n\tlinkage_args.current = r_l_imax_args.i_max / 2.5;\n\tlinkage_args.duty = 0.3;\n\tlinkage_args.erpm_per_sec = 1800;\n\tlinkage_args.res = r_l_imax_args.r;\n\tlinkage_args.ind = r_l_imax_args.l;\n\tlinkage_args.motor = 2;\n\tworker_execute(measure_flux_linkage_task, &linkage_args);\n#endif\n\n\tfloat lambda = 0.0;\n\tfloat lambda_undriven = 0.0;\n\tfloat lambda_undriven_samples = 0.0;\n\tbool res;\n\tfaultM1 = conf_general_measure_flux_linkage_openloop(i_max / 2.5, 0.3, 1800, r, l,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &lambda, &lambda_undriven, &lambda_undriven_samples, &res);\n\n\tif (lambda_undriven_samples > 60) {\n\t\tlambda = lambda_undriven;\n\t\tif (lambda <= 0.0){\n\t\t\tres = false;\n\t\t}\n\t}\n\n\tres = true;\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tworker_wait();\n\tfaultM2 = linkage_args.fault;\n\tbool res_linkage_m2 = linkage_args.result;\n#else\n\tbool res_linkage_m2 = true;\n#endif\n\n\tif (faultM1 != FAULT_CODE_NONE || faultM2 != FAULT_CODE_NONE) {\n\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\tmc_interface_unlock();\n\t\tmc_interface_release_motor();\n\t\tmc_interface_wait_for_motor_release(1.0);\n\t\tmc_interface_set_configuration(mcconf_old);\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_interface_set_configuration(mcconf_old_second);\n\t\tmc_interface_select_motor_thread(1);\n\t\tmempools_free_mcconf(mcconf_second);\n\t\tmempools_free_mcconf(mcconf_old_second);\n#endif\n\t\tmc_interface_select_motor_thread(motor_last);\n\t\tif(faultM1 != FAULT_CODE_NONE) {\n\t\t\treturn faultM1 - 100; // Offset fault codes by -100 to leave room for extra fault codes to be added later.\n\t\t} else {\n\t\t\treturn faultM2 - 100;\n\t\t}\n\t}\n\n\tif (res && res_linkage_m2) {\n\t\tmcconf_old->l_current_max = i_max;\n\t\tmcconf_old->l_current_min = -i_max;\n\t\tfloat abs_max = i_max * 1.5;\n\t\tutils_truncate_number(&abs_max, HW_LIM_CURRENT_ABS);\n\t\tmcconf_old->l_abs_current_max = abs_max;\t\t\n\t\tmcconf_old->motor_type = MOTOR_TYPE_FOC;\n\t\tmcconf_old->foc_motor_r = r;\n\t\tmcconf_old->foc_motor_l = l;\n\t\tmcconf_old->foc_motor_ld_lq_diff = ld_lq_diff;\n\t\tmcconf_old->foc_motor_flux_linkage = lambda;\n\n\t\tif (mc_interface_temp_motor_filtered() > -10) {\n\t\t\tmcconf_old->foc_temp_comp_base_temp = mc_interface_temp_motor_filtered();\n#ifdef HW_HAS_PHASE_FILTERS\n\t\t\tmcconf_old->foc_temp_comp = true;\n#endif\n\t\t}\n\n\t\tconf_general_calc_apply_foc_cc_kp_ki_gain(mcconf_old, 1000);\n\t\tmc_interface_set_configuration(mcconf_old);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tmcconf_old_second->l_current_max = r_l_imax_args.i_max;\n\t\tmcconf_old_second->l_current_min = -r_l_imax_args.i_max;\n\t\tabs_max = r_l_imax_args.i_max * 1.5;\n\t\tutils_truncate_number(&abs_max, HW_LIM_CURRENT_ABS);\n\t\tmcconf_old_second->l_abs_current_max = abs_max;\n\t\tmcconf_old_second->motor_type = MOTOR_TYPE_FOC;\n\t\tmcconf_old_second->foc_motor_r = r_l_imax_args.r;\n\t\tmcconf_old_second->foc_motor_l = r_l_imax_args.l;\n\t\tmcconf_old_second->foc_motor_ld_lq_diff = r_l_imax_args.ld_lq_diff;\n\t\tmcconf_old_second->foc_motor_flux_linkage = linkage_args.linkage;\n\t\tconf_general_calc_apply_foc_cc_kp_ki_gain(mcconf_old_second, 1000);\n\t\tmc_interface_select_motor_thread(2);\n\n\t\tif (mc_interface_temp_motor_filtered() > -10) {\n\t\t\tmcconf_old_second->foc_temp_comp_base_temp = mc_interface_temp_motor_filtered();\n#ifdef HW_HAS_PHASE_FILTERS\n\t\t\tmcconf_old_second->foc_temp_comp = true;\n#endif\n\t\t}\n\n\t\tmc_interface_set_configuration(mcconf_old_second);\n\t\tmc_interface_select_motor_thread(1);\n#endif\n\n\t\twait_motor_stop(10000);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tdetect_sensors_arg_t sensors_args;\n\t\tsensors_args.current = r_l_imax_args.i_max / 3.0;\n\t\tsensors_args.store_mcconf_on_success = store_mcconf_on_success;\n\t\tsensors_args.send_mcconf_on_success = send_mcconf_on_success;\n\t\tsensors_args.motor = 2;\n\t\tworker_execute(detect_sensors_task, &sensors_args);\n#endif\n\n\t\t// This will also store the settings to emulated eeprom and send them to vesc tool\n\t\tfaultM1 = conf_general_autodetect_apply_sensors_foc(i_max / 3.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstore_mcconf_on_success, send_mcconf_on_success, &result);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tworker_wait();\n\t\tint res_sensors_m2 = sensors_args.res;\n\t\tfaultM2 = sensors_args.fault;\n#else\n\t\tint res_sensors_m2 = 0;\n#endif\n\n\t\tif (res_sensors_m2 < 0) {\n\t\t\tresult = res_sensors_m2;\n\t\t}\n\n\t\tif (faultM1 != FAULT_CODE_NONE || faultM2 != FAULT_CODE_NONE) {\n\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\t\t\tmc_interface_unlock();\n\t\t\tmc_interface_release_motor();\n\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\tmempools_free_mcconf(mcconf);\n\t\t\tmempools_free_mcconf(mcconf_old);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\tmc_interface_select_motor_thread(2);\n\t\t\tmc_interface_set_configuration(mcconf_old_second);\n\t\t\tmc_interface_select_motor_thread(1);\n\t\t\tmempools_free_mcconf(mcconf_second);\n\t\t\tmempools_free_mcconf(mcconf_old_second);\n#endif\n\t\t\tmc_interface_select_motor_thread(motor_last);\n\t\t\tif(faultM1 != FAULT_CODE_NONE) {\n\t\t\t\treturn faultM1 - 100; // Offset fault codes by -100 to leave room for extra fault codes to be added later.\n\t\t\t} else {\n\t\t\t\treturn faultM2 - 100;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = -10;\n\t}\n\n\ttimeout_configure(tout, tout_c, tout_ksw);\n\tmc_interface_lock_override_once();\n\tmc_interface_release_motor();\n\tmc_interface_wait_for_motor_release(1.0);\n\tmc_interface_unlock();\n\n\tif (result < 0) {\n\t\tmc_interface_set_configuration(mcconf_old);\n\t}\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_select_motor_thread(2);\n\tif (result < 0) {\n\t\tmc_interface_set_configuration(mcconf_old_second);\n\t}\n\tmc_interface_select_motor_thread(1);\n#endif\n\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_mcconf(mcconf_old);\n#ifdef HW_HAS_DUAL_MOTORS\n\tmempools_free_mcconf(mcconf_second);\n\tmempools_free_mcconf(mcconf_old_second);\n#endif\n\n\tmc_interface_select_motor_thread(motor_last);\n\n\treturn result;\n}\n\n/**\n * Same as conf_general_detect_apply_all_foc, but also start detection on VESCs found on the CAN-bus.\n *\n * @param detect_can\n * Run detection on VESCs found on the CAN-bus as well. Setting this to false makes\n * this function behave like conf_general_detect_apply_all_foc, with the convenience\n * of also applying the settings.\n *\n * @param max_power_loss\n * The maximum power loss to derive current limits, as well as detection currents, from.\n *\n * @param min_current_in\n * Minimum input current (negative value). 0 means leave it unchanged.\n *\n * @param max_current_in\n * MAximum input current. 0 means leave it unchanged.\n *\n * @param openloop_rpm\n * FOC openloop ERPM in sensorless mode. 0 means leave it unchanged.\n *\n * @param sl_erpm\n * FOC ERPM above which sensorless should be used in sensored modes. 0 means leave it unchanged.\n *\n * @param reply_func\n * Send the motor and app config using this function pointer. If it is null the last function\n * from commands will be used.\n *\n * @return\n * Same as conf_general_detect_apply_all_foc, and\n * -50: CAN detection timed out\n * -51: CAN detection failed\n */\nint conf_general_detect_apply_all_foc_can(bool detect_can, float max_power_loss,\n\t\t\t\t\t\t\t\t\t\t  float min_current_in, float max_current_in,\n\t\t\t\t\t\t\t\t\t\t  float openloop_rpm, float sl_erpm,\n\t\t\t\t\t\t\t\t\t\t  void(*reply_func)(unsigned char* data, unsigned int len)) {\n\n\tint motor_last = mc_interface_get_motor_thread();\n\tmc_interface_select_motor_thread(1);\n\n\tapp_configuration *appconf = mempools_alloc_appconf();\n\t*appconf = *app_get_configuration();\n\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t*mcconf = *mc_interface_get_configuration();\n\n\tuint8_t id_new = appconf->controller_id;\n\n\tif (fabsf(min_current_in) > 0.001) {\n\t\tmcconf->l_in_current_min = min_current_in;\n\t} else {\n\t\tmcconf->l_in_current_min = MCCONF_L_IN_CURRENT_MIN;\n\t}\n\n\tif (fabsf(max_current_in) > 0.001) {\n\t\tmcconf->l_in_current_max = max_current_in;\n\t} else {\n\t\tmcconf->l_in_current_max = MCCONF_L_IN_CURRENT_MAX;\n\t}\n\n\tif (fabsf(openloop_rpm) > 0.001) {\n\t\tmcconf->foc_openloop_rpm = openloop_rpm;\n\t} else {\n\t\tmcconf->foc_openloop_rpm = MCCONF_FOC_OPENLOOP_RPM;\n\t}\n\n\tif (fabsf(sl_erpm) > 0.001) {\n\t\tmcconf->foc_sl_erpm = sl_erpm;\n\t} else {\n\t\tmcconf->foc_sl_erpm = MCCONF_FOC_SL_ERPM;\n\t}\n\n\tmc_interface_set_configuration(mcconf);\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_select_motor_thread(2);\n\tmc_configuration *mcconf_second = mempools_alloc_mcconf();\n\t*mcconf_second = *mc_interface_get_configuration();\n\n\tmcconf_second->l_in_current_min = mcconf->l_in_current_min;\n\tmcconf_second->l_in_current_max = mcconf->l_in_current_max;\n\tmcconf_second->foc_openloop_rpm = mcconf->foc_openloop_rpm;\n\tmcconf_second->foc_sl_erpm = mcconf->foc_sl_erpm;\n\n\tmc_interface_set_configuration(mcconf_second);\n\tmc_interface_select_motor_thread(1);\n\tmempools_free_mcconf(mcconf_second);\n#endif\n\n\tint can_devs = 0;\n\tcomm_can_detect_all_foc_res_clear();\n\n\tif (detect_can) {\n\t\tfor (int i = 0;i < 255;i++) {\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\tif (i == utils_second_motor_id()) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tHW_TYPE hw_type;\n\t\t\tif (comm_can_ping(i, &hw_type)) {\n\t\t\t\tif (hw_type != HW_TYPE_VESC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcomm_can_conf_current_limits_in(i, false, mcconf->l_in_current_min, mcconf->l_in_current_max);\n\t\t\t\tcomm_can_conf_foc_erpms(i, false, mcconf->foc_openloop_rpm, mcconf->foc_sl_erpm);\n\t\t\t\tcomm_can_detect_apply_all_foc(i, true, max_power_loss);\n\t\t\t\tcan_devs++;\n\n\t\t\t\t// If some other controller has the same ID, change the local one.\n\t\t\t\tif (i == id_new) {\n\t\t\t\t\t// Add 2 in case this was a dual controller\n\t\t\t\t\tid_new++;\n\t\t\t\t\tif (id_new == 255) {\n\t\t\t\t\t\tid_new = 0;\n\t\t\t\t\t}\n\t\t\t\t\tid_new++;\n\t\t\t\t\tif (id_new == 255) {\n\t\t\t\t\t\tid_new = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = conf_general_detect_apply_all_foc(max_power_loss, false, false);\n\n\t// Wait for all VESCs on the CAN-bus to finish detection\n\tint timeout = true;\n\tfor (int i = 0;i < 18000;i++) {\n\t\tif (comm_can_detect_all_foc_res_size() >= can_devs) {\n\t\t\ttimeout = false;\n\t\t\tbreak;\n\t\t}\n\t\tchThdSleepMilliseconds(10);\n\t}\n\n\tif (timeout) {\n\t\tres = -50;\n\t} else {\n\t\tfor (int i = 0;i < can_devs;i++) {\n\t\t\tif (comm_can_detect_all_foc_res(i) < 0) {\n\t\t\t\tres = -51;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Store and send settings\n\tif (res >= 0) {\n\t\tif (appconf->controller_id != id_new || appconf->can_status_msgs_r1 != 0b00001111) {\n\t\t\tappconf->controller_id = id_new;\n\t\t\tappconf->can_status_msgs_r1 = 0b00001111;\n\t\t\tconf_general_store_app_configuration(appconf);\n\t\t\tapp_set_configuration(appconf);\n\t\t\tcommands_send_appconf(COMM_GET_APPCONF, appconf, reply_func);\n\t\t\tchThdSleepMilliseconds(1000);\n\t\t}\n\n\t\t*mcconf = *mc_interface_get_configuration();\n\t\tconf_general_store_mc_configuration(mcconf, mc_interface_get_motor_thread() == 2);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tmc_interface_select_motor_thread(2);\n\t\t*mcconf = *mc_interface_get_configuration();\n\t\tconf_general_store_mc_configuration(mcconf, mc_interface_get_motor_thread() == 2);\n\t\tmc_interface_select_motor_thread(1);\n\t\t*mcconf = *mc_interface_get_configuration();\n#endif\n\t\tcommands_send_mcconf(COMM_GET_MCCONF, mcconf, reply_func);\n\t\tchThdSleepMilliseconds(1000);\n\t}\n\n\tmempools_free_mcconf(mcconf);\n\tmempools_free_appconf(appconf);\n\n\tmc_interface_select_motor_thread(motor_last);\n\n\treturn res;\n}\n\n#pragma GCC pop_options\n"
        },
        {
          "name": "conf_general.h",
          "type": "blob",
          "size": 7.2724609375,
          "content": "/*\n\tCopyright 2017 - 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef CONF_GENERAL_H_\n#define CONF_GENERAL_H_\n\n// Firmware version\n#define FW_VERSION_MAJOR\t\t\t6\n#define FW_VERSION_MINOR\t\t\t06\n// Set to 0 for building a release and iterate during beta test builds\n#define FW_TEST_VERSION_NUMBER\t\t3\n\n#include \"datatypes.h\"\n\n// Disable hardware limits on configuration parameters\n//#define DISABLE_HW_LIMITS\n\n#if !defined(HW_SOURCE) && !defined(HW_SOURCE_ALT)\n#error \"No hardware source file set\"\n#endif\n\n#ifndef HW_HEADER\n#error \"No hardware header file set\"\n#endif\n\n#ifdef USER_MC_CONF\n#include USER_MC_CONF\n#endif\n\n#ifdef USER_APP_CONF\n#include USER_APP_CONF\n#endif\n\n// This is how to provide a custom UI in VESC Tool. The UI can be created and tested in the\n// scripting page, then the source files can be exported. The defines below use the exported\n// files to provide the custom UI when VESC Tool connects.\n//\n// The intention if the HW gui is to be part of the HW-file and the app gui is for custom apps.\n// Both can be used at the same time.\n//\n// Defining QMLUI_HW_FULLSCREEN and/or QMLUI_APP_FULLSCREEN will disable the other pages in the\n// mobile version of VESC Tool.\n//\n//#define QMLUI_SOURCE_HW\t\t\"qmlui/hw/qmlui_example_hw.c\"\n//#define QMLUI_HEADER_HW\t\t\"qmlui/hw/qmlui_example_hw.h\"\n//#define QMLUI_HW_FULLSCREEN\n//\n//#define QMLUI_SOURCE_APP\t\"qmlui/app/qmlui_example_app.c\"\n//#define QMLUI_HEADER_APP\t\"qmlui/app/qmlui_example_app.h\"\n//#define QMLUI_APP_FULLSCREEN\n\n/*\n * Select default user motor configuration\n */\n//#include\t\t\t\"mcconf_default.h\"\n//#include \t\t\t\"mcconf_china_60kv.h\"\n\n/*\n * Select default user app configuration\n */\n//#include\t\t\t\"appconf_example_ppm.h\"\n//#include\t\t\t\"appconf_custom.h\"\n\n/*\n * Set APP_CUSTOM_TO_USE to the name of the main C file of the custom application.\n */\n//#define APP_CUSTOM_TO_USE\t\t\t\"app_custom_template.c\"\n//#define APP_CUSTOM_TO_USE\t\t\t\"app_motor_heater.c\"\n//#include \"er/app_erockit_conf_v2.h\"\n//#include \"finn/app_finn_az_conf.h\"\n\n#include \"hw.h\"\n#include \"mcconf_default.h\"\n#include \"appconf_default.h\"\n\n/*\n * Enable blackmagic probe output on SWD port\n */\n#ifndef HAS_BLACKMAGIC\n#define HAS_BLACKMAGIC\t\t\t\t1\n#endif\n\n/*\n * Enable CAN-bus\n */\n#ifndef CAN_ENABLE\n#define CAN_ENABLE\t\t\t\t\t1\n#endif\n\n#ifdef HW_HAS_NO_CAN\n#undef CAN_ENABLE\n#define CAN_ENABLE \t\t\t\t\t0\n#endif\n\n/*\n * Servo output driver\n */\n#define SERVO_OUT_PULSE_MIN_US\t\t1000\t// Minimum pulse length in microseconds\n#define SERVO_OUT_PULSE_MAX_US\t\t2000\t// Maximum pulse length in microseconds\n#define SERVO_OUT_RATE_HZ\t\t\t50\t\t// Update rate in Hz\n\n// Correction factor for computations that depend on the old resistor division factor\n#define VDIV_CORR\t\t\t\t\t((VIN_R2 / (VIN_R2 + VIN_R1)) / (2.2 / (2.2 + 33.0)))\n\n// Current ADC to amperes factor\n#define FAC_CURRENT\t\t\t\t\t((V_REG / 4095.0) / (CURRENT_SHUNT_RES * CURRENT_AMP_GAIN))\n#define FAC_CURRENT1\t\t\t\t(FAC_CURRENT * CURRENT_CAL1)\n#define FAC_CURRENT2\t\t\t\t(FAC_CURRENT * CURRENT_CAL2)\n#define FAC_CURRENT3\t\t\t\t(FAC_CURRENT * CURRENT_CAL3)\n#define FAC_CURRENT1_M2\t\t\t\t(FAC_CURRENT * CURRENT_CAL1_M2)\n#define FAC_CURRENT2_M2\t\t\t\t(FAC_CURRENT * CURRENT_CAL2_M2)\n#define FAC_CURRENT3_M2\t\t\t\t(FAC_CURRENT * CURRENT_CAL3_M2)\n\n#define VOLTAGE_TO_ADC_FACTOR\t( VIN_R2 / (VIN_R2 + VIN_R1) ) * ( 4096.0 / V_REG )\n\n// Actual voltage on 3.3V net based on internal reference\n//#define V_REG\t\t\t\t\t\t(1.21 / ((float)ADC_Value[ADC_IND_VREFINT] / 4095.0))\n//#define V_REG\t\t\t\t\t\t3.3\n\n// Use the pins for the hardware SPI port instead of the hall/encoder pins for the AS5047\n#ifndef AS504x_USE_SW_MOSI_PIN\n#define AS504x_USE_SW_MOSI_PIN \t\t0\n#endif\n\n/*\n * MCU\n */\n#define SYSTEM_CORE_CLOCK\t\t\t168000000\n#define STM32_UUID\t\t\t\t\t((uint32_t*)0x1FFF7A10)\n#define STM32_UUID_8\t\t\t\t((uint8_t*)0x1FFF7A10)\n\n/*\n *\tRun the BLDC speed controller in current mode instead of duty cycle mode. This will\n *\tmake it behave like the FOC speed controller. The duty cycle mode has the advantage\n *\tthat it does not require the extra current controller since bldc inherently runs\n *\twith duty cycle control. The current controller also outputs a duty cycle in the\n *\tend, and then the speed controller might as well do the same without the current\n *\tcontroller dynamics in between. FOC on the other hand is inherently based on current\n *\tcontrol.\n */\n#define BLDC_SPEED_CONTROL_CURRENT\t1\n\n/*\n *\tRun the FOC loop once every N ADC ISR requests. This way the pwm frequency is\n *\tdetached from the FOC calculation, which because it takes ~25usec it can't work\n *\tat >40khz. To set a 100kHz pwm FOC_CONTROL_LOOP_FREQ_DIVIDER can be set at 3\n *\tso it skips 2 ISR calls and execute the control loop in the 3rd call.\n */\n#ifndef FOC_CONTROL_LOOP_FREQ_DIVIDER\n#define FOC_CONTROL_LOOP_FREQ_DIVIDER\t1\n#endif\n\n// Global configuration variables\nextern bool conf_general_permanent_nrf_found;\nextern volatile backup_data g_backup;\n\n// Functions\nvoid conf_general_init(void);\nbool conf_general_store_backup_data(void);\nbool conf_general_read_eeprom_var_hw(eeprom_var *v, int address);\nbool conf_general_read_eeprom_var_custom(eeprom_var *v, int address);\nbool conf_general_store_eeprom_var_hw(eeprom_var *v, int address);\nbool conf_general_store_eeprom_var_custom(eeprom_var *v, int address);\nvoid conf_general_read_app_configuration(app_configuration *conf);\nbool conf_general_store_app_configuration(app_configuration *conf);\nvoid conf_general_read_mc_configuration(mc_configuration *conf, bool is_motor_2);\nbool conf_general_store_mc_configuration(mc_configuration *conf, bool is_motor_2);\nbool conf_general_detect_motor_param(float current, float min_rpm, float low_duty,\n\t\t\t\t\t\t\t\t\t float *int_limit, float *bemf_coupling_k, int8_t *hall_table, int *hall_res);\nbool conf_general_measure_flux_linkage(float current, float duty,\n\t\t\t\t\t\t\t\t\t   float min_erpm, float res, float *linkage);\nuint8_t conf_general_calculate_deadtime(float deadtime_ns, float core_clock_freq);\nint conf_general_measure_flux_linkage_openloop(float current, float duty,\n\t\t\t\t\t\t\t\t\t\t\t   float erpm_per_sec, float res, float ind, float *linkage,\n\t\t\t\t\t\t\t\t\t\t\t   float *linkage_undriven, float *undriven_samples, bool *result);\nint conf_general_autodetect_apply_sensors_foc(float current,\n\t\t\t\t\t\t\t\t\t\t\t  bool store_mcconf_on_success, bool send_mcconf_on_success, int *result);\nvoid conf_general_calc_apply_foc_cc_kp_ki_gain(mc_configuration *mcconf, float tc);\nint conf_general_detect_apply_all_foc(float max_power_loss,\n\t\t\t\t\t\t\t\t\t  bool store_mcconf_on_success, bool send_mcconf_on_success);\nint conf_general_detect_apply_all_foc_can(bool detect_can, float max_power_loss,\n\t\t\t\t\t\t\t\t\t\t  float min_current_in, float max_current_in,\n\t\t\t\t\t\t\t\t\t\t  float openloop_rpm, float sl_erpm,\n\t\t\t\t\t\t\t\t\t\t  void(*reply_func)(unsigned char* data, unsigned int len));\n\n\n#endif /* CONF_GENERAL_H_ */\n"
        },
        {
          "name": "confgenerator.c",
          "type": "blob",
          "size": 55.998046875,
          "content": "// This file is autogenerated by VESC Tool\n\n#include <string.h>\n#include \"buffer.h\"\n#include \"conf_general.h\"\n#include \"confgenerator.h\"\n\nint32_t confgenerator_serialize_mcconf(uint8_t *buffer, const mc_configuration *conf) {\n\tint32_t ind = 0;\n\n\tbuffer_append_uint32(buffer, MCCONF_SIGNATURE, &ind);\n\n\tbuffer[ind++] = conf->pwm_mode;\n\tbuffer[ind++] = conf->comm_mode;\n\tbuffer[ind++] = conf->motor_type;\n\tbuffer[ind++] = conf->sensor_mode;\n\tbuffer_append_float32_auto(buffer, conf->l_current_max, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_current_min, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_in_current_max, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_in_current_min, &ind);\n\tbuffer_append_float16(buffer, conf->l_in_current_map_start, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->l_in_current_map_filter, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_abs_current_max, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_min_erpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_max_erpm, &ind);\n\tbuffer_append_float16(buffer, conf->l_erpm_start, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_max_erpm_fbrake, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_max_erpm_fbrake_cc, &ind);\n\tbuffer_append_float16(buffer, conf->l_min_vin, 10, &ind);\n\tbuffer_append_float16(buffer, conf->l_max_vin, 10, &ind);\n\tbuffer_append_float16(buffer, conf->l_battery_cut_start, 10, &ind);\n\tbuffer_append_float16(buffer, conf->l_battery_cut_end, 10, &ind);\n\tbuffer_append_float16(buffer, conf->l_battery_regen_cut_start, 10, &ind);\n\tbuffer_append_float16(buffer, conf->l_battery_regen_cut_end, 10, &ind);\n\tbuffer[ind++] = conf->l_slow_abs_current;\n\tbuffer[ind++] = (uint8_t)conf->l_temp_fet_start;\n\tbuffer[ind++] = (uint8_t)conf->l_temp_fet_end;\n\tbuffer[ind++] = (uint8_t)conf->l_temp_motor_start;\n\tbuffer[ind++] = (uint8_t)conf->l_temp_motor_end;\n\tbuffer_append_float16(buffer, conf->l_temp_accel_dec, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->l_min_duty, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->l_max_duty, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_watt_max, &ind);\n\tbuffer_append_float32_auto(buffer, conf->l_watt_min, &ind);\n\tbuffer_append_float16(buffer, conf->l_current_max_scale, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->l_current_min_scale, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->l_duty_start, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->sl_min_erpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->sl_min_erpm_cycle_int_limit, &ind);\n\tbuffer_append_float32_auto(buffer, conf->sl_max_fullbreak_current_dir_change, &ind);\n\tbuffer_append_float16(buffer, conf->sl_cycle_int_limit, 10, &ind);\n\tbuffer_append_float16(buffer, conf->sl_phase_advance_at_br, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->sl_cycle_int_rpm_br, &ind);\n\tbuffer_append_float32_auto(buffer, conf->sl_bemf_coupling_k, &ind);\n\tbuffer[ind++] = (uint8_t)conf->hall_table[0];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[1];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[2];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[3];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[4];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[5];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[6];\n\tbuffer[ind++] = (uint8_t)conf->hall_table[7];\n\tbuffer_append_float32_auto(buffer, conf->hall_sl_erpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_current_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_current_ki, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_f_zv, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_dt_us, &ind);\n\tbuffer[ind++] = conf->foc_encoder_inverted;\n\tbuffer_append_float32_auto(buffer, conf->foc_encoder_offset, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_encoder_ratio, &ind);\n\tbuffer[ind++] = conf->foc_sensor_mode;\n\tbuffer_append_float32_auto(buffer, conf->foc_pll_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_pll_ki, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_motor_l, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_motor_ld_lq_diff, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_motor_r, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_motor_flux_linkage, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_observer_gain, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_observer_gain_slow, &ind);\n\tbuffer_append_float16(buffer, conf->foc_observer_offset, 1000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_duty_dowmramp_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_duty_dowmramp_ki, &ind);\n\tbuffer_append_float16(buffer, conf->foc_start_curr_dec, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_start_curr_dec_rpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_openloop_rpm, &ind);\n\tbuffer_append_float16(buffer, conf->foc_openloop_rpm_low, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_d_gain_scale_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_d_gain_scale_max_mod, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_hyst, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_time_lock, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_time_ramp, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_time, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_boost_q, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_sl_openloop_max_q, 100, &ind);\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[0];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[1];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[2];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[3];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[4];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[5];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[6];\n\tbuffer[ind++] = (uint8_t)conf->foc_hall_table[7];\n\tbuffer_append_float32_auto(buffer, conf->foc_hall_interp_erpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_sl_erpm_start, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_sl_erpm, &ind);\n\tbuffer[ind++] = conf->foc_control_sample_mode;\n\tbuffer[ind++] = conf->foc_current_sample_mode;\n\tbuffer[ind++] = conf->foc_sat_comp_mode;\n\tbuffer_append_float16(buffer, conf->foc_sat_comp, 1000, &ind);\n\tbuffer[ind++] = conf->foc_temp_comp;\n\tbuffer_append_float16(buffer, conf->foc_temp_comp_base_temp, 100, &ind);\n\tbuffer_append_float16(buffer, conf->foc_current_filter_const, 10000, &ind);\n\tbuffer[ind++] = conf->foc_cc_decoupling;\n\tbuffer[ind++] = conf->foc_observer_type;\n\tbuffer[ind++] = conf->foc_hfi_amb_mode;\n\tbuffer_append_float16(buffer, conf->foc_hfi_amb_current, 10, &ind);\n\tbuffer[ind++] = (uint8_t)conf->foc_hfi_amb_tres;\n\tbuffer_append_float16(buffer, conf->foc_hfi_voltage_start, 10, &ind);\n\tbuffer_append_float16(buffer, conf->foc_hfi_voltage_run, 10, &ind);\n\tbuffer_append_float16(buffer, conf->foc_hfi_voltage_max, 10, &ind);\n\tbuffer_append_float16(buffer, conf->foc_hfi_gain, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_hfi_max_err, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_hfi_hyst, 100, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_sl_erpm_hfi, &ind);\n\tbuffer_append_uint16(buffer, conf->foc_hfi_start_samples, &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_hfi_obs_ovr_sec, &ind);\n\tbuffer[ind++] = conf->foc_hfi_samples;\n\tbuffer[ind++] = conf->foc_offsets_cal_mode;\n\tbuffer_append_float32_auto(buffer, conf->foc_offsets_current[0], &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_offsets_current[1], &ind);\n\tbuffer_append_float32_auto(buffer, conf->foc_offsets_current[2], &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage[0], 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage[1], 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage[2], 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage_undriven[0], 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage_undriven[1], 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_offsets_voltage_undriven[2], 10000, &ind);\n\tbuffer[ind++] = conf->foc_phase_filter_enable;\n\tbuffer[ind++] = conf->foc_phase_filter_disable_fault;\n\tbuffer_append_float32_auto(buffer, conf->foc_phase_filter_max_erpm, &ind);\n\tbuffer[ind++] = conf->foc_mtpa_mode;\n\tbuffer_append_float32_auto(buffer, conf->foc_fw_current_max, &ind);\n\tbuffer_append_float16(buffer, conf->foc_fw_duty_start, 10000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_fw_ramp_time, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->foc_fw_q_current_factor, 10000, &ind);\n\tbuffer[ind++] = conf->foc_speed_soure;\n\tbuffer[ind++] = conf->foc_short_ls_on_zero_duty;\n\tbuffer[ind++] = conf->sp_pid_loop_rate;\n\tbuffer_append_float32_auto(buffer, conf->s_pid_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->s_pid_ki, &ind);\n\tbuffer_append_float32_auto(buffer, conf->s_pid_kd, &ind);\n\tbuffer_append_float16(buffer, conf->s_pid_kd_filter, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->s_pid_min_erpm, &ind);\n\tbuffer[ind++] = conf->s_pid_allow_braking;\n\tbuffer_append_float32_auto(buffer, conf->s_pid_ramp_erpms_s, &ind);\n\tbuffer[ind++] = conf->s_pid_speed_source;\n\tbuffer_append_float32_auto(buffer, conf->p_pid_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->p_pid_ki, &ind);\n\tbuffer_append_float32_auto(buffer, conf->p_pid_kd, &ind);\n\tbuffer_append_float32_auto(buffer, conf->p_pid_kd_proc, &ind);\n\tbuffer_append_float16(buffer, conf->p_pid_kd_filter, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->p_pid_ang_div, &ind);\n\tbuffer_append_float16(buffer, conf->p_pid_gain_dec_angle, 10, &ind);\n\tbuffer_append_float32_auto(buffer, conf->p_pid_offset, &ind);\n\tbuffer_append_float16(buffer, conf->cc_startup_boost_duty, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->cc_min_current, &ind);\n\tbuffer_append_float32_auto(buffer, conf->cc_gain, &ind);\n\tbuffer_append_float16(buffer, conf->cc_ramp_step_max, 10000, &ind);\n\tbuffer_append_int32(buffer, conf->m_fault_stop_time_ms, &ind);\n\tbuffer_append_float16(buffer, conf->m_duty_ramp_step, 10000, &ind);\n\tbuffer_append_float32_auto(buffer, conf->m_current_backoff_gain, &ind);\n\tbuffer_append_uint32(buffer, conf->m_encoder_counts, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_sin_amp, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_cos_amp, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_sin_offset, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_cos_offset, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_sincos_filter_constant, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->m_encoder_sincos_phase_correction, 1000, &ind);\n\tbuffer[ind++] = conf->m_sensor_port_mode;\n\tbuffer[ind++] = conf->m_invert_direction;\n\tbuffer[ind++] = conf->m_drv8301_oc_mode;\n\tbuffer[ind++] = (uint8_t)conf->m_drv8301_oc_adj;\n\tbuffer_append_float32_auto(buffer, conf->m_bldc_f_sw_min, &ind);\n\tbuffer_append_float32_auto(buffer, conf->m_bldc_f_sw_max, &ind);\n\tbuffer_append_float32_auto(buffer, conf->m_dc_f_sw, &ind);\n\tbuffer_append_float32_auto(buffer, conf->m_ntc_motor_beta, &ind);\n\tbuffer[ind++] = conf->m_out_aux_mode;\n\tbuffer[ind++] = conf->m_motor_temp_sens_type;\n\tbuffer_append_float32_auto(buffer, conf->m_ptc_motor_coeff, &ind);\n\tbuffer_append_float16(buffer, conf->m_ntcx_ptcx_res, 0.1, &ind);\n\tbuffer_append_float16(buffer, conf->m_ntcx_ptcx_temp_base, 10, &ind);\n\tbuffer[ind++] = (uint8_t)conf->m_hall_extra_samples;\n\tbuffer[ind++] = (uint8_t)conf->m_batt_filter_const;\n\tbuffer[ind++] = (uint8_t)conf->si_motor_poles;\n\tbuffer_append_float32_auto(buffer, conf->si_gear_ratio, &ind);\n\tbuffer_append_float32_auto(buffer, conf->si_wheel_diameter, &ind);\n\tbuffer[ind++] = conf->si_battery_type;\n\tbuffer[ind++] = (uint8_t)conf->si_battery_cells;\n\tbuffer_append_float32_auto(buffer, conf->si_battery_ah, &ind);\n\tbuffer_append_float32_auto(buffer, conf->si_motor_nl_current, &ind);\n\tbuffer[ind++] = conf->bms.type;\n\tbuffer[ind++] = conf->bms.limit_mode;\n\tbuffer[ind++] = (uint8_t)conf->bms.t_limit_start;\n\tbuffer[ind++] = (uint8_t)conf->bms.t_limit_end;\n\tbuffer_append_float16(buffer, conf->bms.soc_limit_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->bms.soc_limit_end, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->bms.vmin_limit_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->bms.vmin_limit_end, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->bms.vmax_limit_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->bms.vmax_limit_end, 1000, &ind);\n\tbuffer[ind++] = conf->bms.fwd_can_mode;\n\n\treturn ind;\n}\n\nint32_t confgenerator_serialize_appconf(uint8_t *buffer, const app_configuration *conf) {\n\tint32_t ind = 0;\n\n\tbuffer_append_uint32(buffer, APPCONF_SIGNATURE, &ind);\n\n\tbuffer[ind++] = (uint8_t)conf->controller_id;\n\tbuffer_append_uint32(buffer, conf->timeout_msec, &ind);\n\tbuffer_append_float32_auto(buffer, conf->timeout_brake_current, &ind);\n\tbuffer_append_uint16(buffer, conf->can_status_rate_1, &ind);\n\tbuffer_append_uint16(buffer, conf->can_status_rate_2, &ind);\n\tbuffer[ind++] = conf->can_status_msgs_r1;\n\tbuffer[ind++] = conf->can_status_msgs_r2;\n\tbuffer[ind++] = conf->can_baud_rate;\n\tbuffer[ind++] = conf->pairing_done;\n\tbuffer[ind++] = conf->permanent_uart_enabled;\n\tbuffer[ind++] = conf->shutdown_mode;\n\tbuffer[ind++] = conf->can_mode;\n\tbuffer[ind++] = (uint8_t)conf->uavcan_esc_index;\n\tbuffer[ind++] = conf->uavcan_raw_mode;\n\tbuffer_append_float32_auto(buffer, conf->uavcan_raw_rpm_max, &ind);\n\tbuffer[ind++] = conf->uavcan_status_current_mode;\n\tbuffer[ind++] = conf->servo_out_enable;\n\tbuffer[ind++] = conf->kill_sw_mode;\n\tbuffer[ind++] = conf->app_to_use;\n\tbuffer[ind++] = conf->app_ppm_conf.ctrl_type;\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.pid_max_erpm, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.hyst, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_start, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_end, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_center, &ind);\n\tbuffer[ind++] = conf->app_ppm_conf.median_filter;\n\tbuffer[ind++] = conf->app_ppm_conf.safe_start;\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.throttle_exp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.throttle_exp_brake, &ind);\n\tbuffer[ind++] = conf->app_ppm_conf.throttle_exp_mode;\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.ramp_time_pos, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.ramp_time_neg, &ind);\n\tbuffer[ind++] = conf->app_ppm_conf.multi_esc;\n\tbuffer[ind++] = conf->app_ppm_conf.tc;\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.tc_max_diff, &ind);\n\tbuffer_append_float16(buffer, conf->app_ppm_conf.max_erpm_for_dir, 1, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.smart_rev_max_duty, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_ppm_conf.smart_rev_ramp_time, &ind);\n\tbuffer[ind++] = conf->app_adc_conf.ctrl_type;\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.hyst, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage_end, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage_min, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage_max, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage_center, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage2_start, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_adc_conf.voltage2_end, 1000, &ind);\n\tbuffer[ind++] = conf->app_adc_conf.use_filter;\n\tbuffer[ind++] = conf->app_adc_conf.safe_start;\n\tbuffer[ind++] = conf->app_adc_conf.buttons;\n\tbuffer[ind++] = conf->app_adc_conf.voltage_inverted;\n\tbuffer[ind++] = conf->app_adc_conf.voltage2_inverted;\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.throttle_exp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.throttle_exp_brake, &ind);\n\tbuffer[ind++] = conf->app_adc_conf.throttle_exp_mode;\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.ramp_time_pos, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.ramp_time_neg, &ind);\n\tbuffer[ind++] = conf->app_adc_conf.multi_esc;\n\tbuffer[ind++] = conf->app_adc_conf.tc;\n\tbuffer_append_float32_auto(buffer, conf->app_adc_conf.tc_max_diff, &ind);\n\tbuffer_append_uint16(buffer, conf->app_adc_conf.update_rate_hz, &ind);\n\tbuffer_append_uint32(buffer, conf->app_uart_baudrate, &ind);\n\tbuffer[ind++] = conf->app_chuk_conf.ctrl_type;\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.hyst, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.ramp_time_pos, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.ramp_time_neg, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.stick_erpm_per_s_in_cc, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.throttle_exp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.throttle_exp_brake, &ind);\n\tbuffer[ind++] = conf->app_chuk_conf.throttle_exp_mode;\n\tbuffer[ind++] = conf->app_chuk_conf.multi_esc;\n\tbuffer[ind++] = conf->app_chuk_conf.tc;\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.tc_max_diff, &ind);\n\tbuffer[ind++] = conf->app_chuk_conf.use_smart_rev;\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.smart_rev_max_duty, &ind);\n\tbuffer_append_float32_auto(buffer, conf->app_chuk_conf.smart_rev_ramp_time, &ind);\n\tbuffer[ind++] = conf->app_nrf_conf.speed;\n\tbuffer[ind++] = conf->app_nrf_conf.power;\n\tbuffer[ind++] = conf->app_nrf_conf.crc_type;\n\tbuffer[ind++] = conf->app_nrf_conf.retry_delay;\n\tbuffer[ind++] = (uint8_t)conf->app_nrf_conf.retries;\n\tbuffer[ind++] = (uint8_t)conf->app_nrf_conf.channel;\n\tbuffer[ind++] = (uint8_t)conf->app_nrf_conf.address[0];\n\tbuffer[ind++] = (uint8_t)conf->app_nrf_conf.address[1];\n\tbuffer[ind++] = (uint8_t)conf->app_nrf_conf.address[2];\n\tbuffer[ind++] = conf->app_nrf_conf.send_crc_ack;\n\tbuffer[ind++] = conf->app_pas_conf.ctrl_type;\n\tbuffer[ind++] = conf->app_pas_conf.sensor_type;\n\tbuffer_append_float16(buffer, conf->app_pas_conf.current_scaling, 1000, &ind);\n\tbuffer_append_float16(buffer, conf->app_pas_conf.pedal_rpm_start, 10, &ind);\n\tbuffer_append_float16(buffer, conf->app_pas_conf.pedal_rpm_end, 10, &ind);\n\tbuffer[ind++] = conf->app_pas_conf.invert_pedal_direction;\n\tbuffer_append_uint16(buffer, conf->app_pas_conf.magnets, &ind);\n\tbuffer[ind++] = conf->app_pas_conf.use_filter;\n\tbuffer_append_float16(buffer, conf->app_pas_conf.ramp_time_pos, 100, &ind);\n\tbuffer_append_float16(buffer, conf->app_pas_conf.ramp_time_neg, 100, &ind);\n\tbuffer_append_uint16(buffer, conf->app_pas_conf.update_rate_hz, &ind);\n\tbuffer[ind++] = conf->imu_conf.type;\n\tbuffer[ind++] = conf->imu_conf.mode;\n\tbuffer[ind++] = conf->imu_conf.filter;\n\tbuffer_append_float16(buffer, conf->imu_conf.accel_lowpass_filter_x, 1, &ind);\n\tbuffer_append_float16(buffer, conf->imu_conf.accel_lowpass_filter_y, 1, &ind);\n\tbuffer_append_float16(buffer, conf->imu_conf.accel_lowpass_filter_z, 1, &ind);\n\tbuffer_append_float16(buffer, conf->imu_conf.gyro_lowpass_filter, 1, &ind);\n\tbuffer_append_uint16(buffer, conf->imu_conf.sample_rate_hz, &ind);\n\tbuffer[ind++] = conf->imu_conf.use_magnetometer;\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.accel_confidence_decay, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.mahony_kp, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.mahony_ki, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.madgwick_beta, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.rot_roll, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.rot_pitch, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.rot_yaw, &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[0], &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[1], &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[2], &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[0], &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[1], &ind);\n\tbuffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[2], &ind);\n\n\treturn ind;\n}\n\nbool confgenerator_deserialize_mcconf(const uint8_t *buffer, mc_configuration *conf) {\n\tint32_t ind = 0;\n\n\tuint32_t signature = buffer_get_uint32(buffer, &ind);\n\tif (signature != MCCONF_SIGNATURE) {\n\t\treturn false;\n\t}\n\n\tconf->pwm_mode = buffer[ind++];\n\tconf->comm_mode = buffer[ind++];\n\tconf->motor_type = buffer[ind++];\n\tconf->sensor_mode = buffer[ind++];\n\tconf->l_current_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_current_min = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_in_current_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_in_current_min = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_in_current_map_start = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_in_current_map_filter = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_abs_current_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_min_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_max_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_erpm_start = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_max_erpm_fbrake = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_max_erpm_fbrake_cc = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_min_vin = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_max_vin = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_battery_cut_start = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_battery_cut_end = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_battery_regen_cut_start = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_battery_regen_cut_end = buffer_get_float16(buffer, 10, &ind);\n\tconf->l_slow_abs_current = buffer[ind++];\n\tconf->l_temp_fet_start = buffer[ind++];\n\tconf->l_temp_fet_end = buffer[ind++];\n\tconf->l_temp_motor_start = buffer[ind++];\n\tconf->l_temp_motor_end = buffer[ind++];\n\tconf->l_temp_accel_dec = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_min_duty = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_max_duty = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_watt_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_watt_min = buffer_get_float32_auto(buffer, &ind);\n\tconf->l_current_max_scale = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_current_min_scale = buffer_get_float16(buffer, 10000, &ind);\n\tconf->l_duty_start = buffer_get_float16(buffer, 10000, &ind);\n\tconf->sl_min_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->sl_min_erpm_cycle_int_limit = buffer_get_float32_auto(buffer, &ind);\n\tconf->sl_max_fullbreak_current_dir_change = buffer_get_float32_auto(buffer, &ind);\n\tconf->sl_cycle_int_limit = buffer_get_float16(buffer, 10, &ind);\n\tconf->sl_phase_advance_at_br = buffer_get_float16(buffer, 10000, &ind);\n\tconf->sl_cycle_int_rpm_br = buffer_get_float32_auto(buffer, &ind);\n\tconf->sl_bemf_coupling_k = buffer_get_float32_auto(buffer, &ind);\n\tconf->hall_table[0] = (int8_t)buffer[ind++];\n\tconf->hall_table[1] = (int8_t)buffer[ind++];\n\tconf->hall_table[2] = (int8_t)buffer[ind++];\n\tconf->hall_table[3] = (int8_t)buffer[ind++];\n\tconf->hall_table[4] = (int8_t)buffer[ind++];\n\tconf->hall_table[5] = (int8_t)buffer[ind++];\n\tconf->hall_table[6] = (int8_t)buffer[ind++];\n\tconf->hall_table[7] = (int8_t)buffer[ind++];\n\tconf->hall_sl_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_current_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_current_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_f_zv = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_dt_us = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_encoder_inverted = buffer[ind++];\n\tconf->foc_encoder_offset = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_encoder_ratio = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_sensor_mode = buffer[ind++];\n\tconf->foc_pll_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_pll_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_motor_l = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_motor_ld_lq_diff = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_motor_r = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_motor_flux_linkage = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_observer_gain = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_observer_gain_slow = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_observer_offset = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_duty_dowmramp_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_duty_dowmramp_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_start_curr_dec = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_start_curr_dec_rpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_openloop_rpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_openloop_rpm_low = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_d_gain_scale_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_d_gain_scale_max_mod = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_sl_openloop_hyst = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_openloop_time_lock = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_openloop_time_ramp = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_openloop_time = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_openloop_boost_q = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_openloop_max_q = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_hall_table[0] = buffer[ind++];\n\tconf->foc_hall_table[1] = buffer[ind++];\n\tconf->foc_hall_table[2] = buffer[ind++];\n\tconf->foc_hall_table[3] = buffer[ind++];\n\tconf->foc_hall_table[4] = buffer[ind++];\n\tconf->foc_hall_table[5] = buffer[ind++];\n\tconf->foc_hall_table[6] = buffer[ind++];\n\tconf->foc_hall_table[7] = buffer[ind++];\n\tconf->foc_hall_interp_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_sl_erpm_start = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_sl_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_control_sample_mode = buffer[ind++];\n\tconf->foc_current_sample_mode = buffer[ind++];\n\tconf->foc_sat_comp_mode = buffer[ind++];\n\tconf->foc_sat_comp = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_temp_comp = buffer[ind++];\n\tconf->foc_temp_comp_base_temp = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_current_filter_const = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_cc_decoupling = buffer[ind++];\n\tconf->foc_observer_type = buffer[ind++];\n\tconf->foc_hfi_amb_mode = buffer[ind++];\n\tconf->foc_hfi_amb_current = buffer_get_float16(buffer, 10, &ind);\n\tconf->foc_hfi_amb_tres = buffer[ind++];\n\tconf->foc_hfi_voltage_start = buffer_get_float16(buffer, 10, &ind);\n\tconf->foc_hfi_voltage_run = buffer_get_float16(buffer, 10, &ind);\n\tconf->foc_hfi_voltage_max = buffer_get_float16(buffer, 10, &ind);\n\tconf->foc_hfi_gain = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_hfi_max_err = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_hfi_hyst = buffer_get_float16(buffer, 100, &ind);\n\tconf->foc_sl_erpm_hfi = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_hfi_start_samples = buffer_get_uint16(buffer, &ind);\n\tconf->foc_hfi_obs_ovr_sec = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_hfi_samples = buffer[ind++];\n\tconf->foc_offsets_cal_mode = buffer[ind++];\n\tconf->foc_offsets_current[0] = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_offsets_current[1] = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_offsets_current[2] = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_offsets_voltage[0] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_offsets_voltage[1] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_offsets_voltage[2] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_offsets_voltage_undriven[0] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_offsets_voltage_undriven[1] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_offsets_voltage_undriven[2] = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_phase_filter_enable = buffer[ind++];\n\tconf->foc_phase_filter_disable_fault = buffer[ind++];\n\tconf->foc_phase_filter_max_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_mtpa_mode = buffer[ind++];\n\tconf->foc_fw_current_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->foc_fw_duty_start = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_fw_ramp_time = buffer_get_float16(buffer, 1000, &ind);\n\tconf->foc_fw_q_current_factor = buffer_get_float16(buffer, 10000, &ind);\n\tconf->foc_speed_soure = buffer[ind++];\n\tconf->foc_short_ls_on_zero_duty = buffer[ind++];\n\tconf->sp_pid_loop_rate = buffer[ind++];\n\tconf->s_pid_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->s_pid_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->s_pid_kd = buffer_get_float32_auto(buffer, &ind);\n\tconf->s_pid_kd_filter = buffer_get_float16(buffer, 10000, &ind);\n\tconf->s_pid_min_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->s_pid_allow_braking = buffer[ind++];\n\tconf->s_pid_ramp_erpms_s = buffer_get_float32_auto(buffer, &ind);\n\tconf->s_pid_speed_source = buffer[ind++];\n\tconf->p_pid_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->p_pid_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->p_pid_kd = buffer_get_float32_auto(buffer, &ind);\n\tconf->p_pid_kd_proc = buffer_get_float32_auto(buffer, &ind);\n\tconf->p_pid_kd_filter = buffer_get_float16(buffer, 10000, &ind);\n\tconf->p_pid_ang_div = buffer_get_float32_auto(buffer, &ind);\n\tconf->p_pid_gain_dec_angle = buffer_get_float16(buffer, 10, &ind);\n\tconf->p_pid_offset = buffer_get_float32_auto(buffer, &ind);\n\tconf->cc_startup_boost_duty = buffer_get_float16(buffer, 10000, &ind);\n\tconf->cc_min_current = buffer_get_float32_auto(buffer, &ind);\n\tconf->cc_gain = buffer_get_float32_auto(buffer, &ind);\n\tconf->cc_ramp_step_max = buffer_get_float16(buffer, 10000, &ind);\n\tconf->m_fault_stop_time_ms = buffer_get_int32(buffer, &ind);\n\tconf->m_duty_ramp_step = buffer_get_float16(buffer, 10000, &ind);\n\tconf->m_current_backoff_gain = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_encoder_counts = buffer_get_uint32(buffer, &ind);\n\tconf->m_encoder_sin_amp = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_encoder_cos_amp = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_encoder_sin_offset = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_encoder_cos_offset = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_encoder_sincos_filter_constant = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_encoder_sincos_phase_correction = buffer_get_float16(buffer, 1000, &ind);\n\tconf->m_sensor_port_mode = buffer[ind++];\n\tconf->m_invert_direction = buffer[ind++];\n\tconf->m_drv8301_oc_mode = buffer[ind++];\n\tconf->m_drv8301_oc_adj = buffer[ind++];\n\tconf->m_bldc_f_sw_min = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_bldc_f_sw_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_dc_f_sw = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_ntc_motor_beta = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_out_aux_mode = buffer[ind++];\n\tconf->m_motor_temp_sens_type = buffer[ind++];\n\tconf->m_ptc_motor_coeff = buffer_get_float32_auto(buffer, &ind);\n\tconf->m_ntcx_ptcx_res = buffer_get_float16(buffer, 0.1, &ind);\n\tconf->m_ntcx_ptcx_temp_base = buffer_get_float16(buffer, 10, &ind);\n\tconf->m_hall_extra_samples = buffer[ind++];\n\tconf->m_batt_filter_const = buffer[ind++];\n\tconf->si_motor_poles = buffer[ind++];\n\tconf->si_gear_ratio = buffer_get_float32_auto(buffer, &ind);\n\tconf->si_wheel_diameter = buffer_get_float32_auto(buffer, &ind);\n\tconf->si_battery_type = buffer[ind++];\n\tconf->si_battery_cells = buffer[ind++];\n\tconf->si_battery_ah = buffer_get_float32_auto(buffer, &ind);\n\tconf->si_motor_nl_current = buffer_get_float32_auto(buffer, &ind);\n\tconf->bms.type = buffer[ind++];\n\tconf->bms.limit_mode = buffer[ind++];\n\tconf->bms.t_limit_start = buffer[ind++];\n\tconf->bms.t_limit_end = buffer[ind++];\n\tconf->bms.soc_limit_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.soc_limit_end = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.vmin_limit_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.vmin_limit_end = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.vmax_limit_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.vmax_limit_end = buffer_get_float16(buffer, 1000, &ind);\n\tconf->bms.fwd_can_mode = buffer[ind++];\n\n\treturn true;\n}\n\nbool confgenerator_deserialize_appconf(const uint8_t *buffer, app_configuration *conf) {\n\tint32_t ind = 0;\n\n\tuint32_t signature = buffer_get_uint32(buffer, &ind);\n\tif (signature != APPCONF_SIGNATURE) {\n\t\treturn false;\n\t}\n\n\tconf->controller_id = buffer[ind++];\n\tconf->timeout_msec = buffer_get_uint32(buffer, &ind);\n\tconf->timeout_brake_current = buffer_get_float32_auto(buffer, &ind);\n\tconf->can_status_rate_1 = buffer_get_uint16(buffer, &ind);\n\tconf->can_status_rate_2 = buffer_get_uint16(buffer, &ind);\n\tconf->can_status_msgs_r1 = buffer[ind++];\n\tconf->can_status_msgs_r2 = buffer[ind++];\n\tconf->can_baud_rate = buffer[ind++];\n\tconf->pairing_done = buffer[ind++];\n\tconf->permanent_uart_enabled = buffer[ind++];\n\tconf->shutdown_mode = buffer[ind++];\n\tconf->can_mode = buffer[ind++];\n\tconf->uavcan_esc_index = buffer[ind++];\n\tconf->uavcan_raw_mode = buffer[ind++];\n\tconf->uavcan_raw_rpm_max = buffer_get_float32_auto(buffer, &ind);\n\tconf->uavcan_status_current_mode = buffer[ind++];\n\tconf->servo_out_enable = buffer[ind++];\n\tconf->kill_sw_mode = buffer[ind++];\n\tconf->app_to_use = buffer[ind++];\n\tconf->app_ppm_conf.ctrl_type = buffer[ind++];\n\tconf->app_ppm_conf.pid_max_erpm = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.hyst = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.pulse_start = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.pulse_end = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.pulse_center = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.median_filter = buffer[ind++];\n\tconf->app_ppm_conf.safe_start = buffer[ind++];\n\tconf->app_ppm_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.throttle_exp_mode = buffer[ind++];\n\tconf->app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.multi_esc = buffer[ind++];\n\tconf->app_ppm_conf.tc = buffer[ind++];\n\tconf->app_ppm_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.max_erpm_for_dir = buffer_get_float16(buffer, 1, &ind);\n\tconf->app_ppm_conf.smart_rev_max_duty = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_ppm_conf.smart_rev_ramp_time = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.ctrl_type = buffer[ind++];\n\tconf->app_adc_conf.hyst = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.voltage_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage_end = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage_min = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage_max = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage_center = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage2_start = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.voltage2_end = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_adc_conf.use_filter = buffer[ind++];\n\tconf->app_adc_conf.safe_start = buffer[ind++];\n\tconf->app_adc_conf.buttons = buffer[ind++];\n\tconf->app_adc_conf.voltage_inverted = buffer[ind++];\n\tconf->app_adc_conf.voltage2_inverted = buffer[ind++];\n\tconf->app_adc_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.throttle_exp_mode = buffer[ind++];\n\tconf->app_adc_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.multi_esc = buffer[ind++];\n\tconf->app_adc_conf.tc = buffer[ind++];\n\tconf->app_adc_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_adc_conf.update_rate_hz = buffer_get_uint16(buffer, &ind);\n\tconf->app_uart_baudrate = buffer_get_uint32(buffer, &ind);\n\tconf->app_chuk_conf.ctrl_type = buffer[ind++];\n\tconf->app_chuk_conf.hyst = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.stick_erpm_per_s_in_cc = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.throttle_exp_mode = buffer[ind++];\n\tconf->app_chuk_conf.multi_esc = buffer[ind++];\n\tconf->app_chuk_conf.tc = buffer[ind++];\n\tconf->app_chuk_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.use_smart_rev = buffer[ind++];\n\tconf->app_chuk_conf.smart_rev_max_duty = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_chuk_conf.smart_rev_ramp_time = buffer_get_float32_auto(buffer, &ind);\n\tconf->app_nrf_conf.speed = buffer[ind++];\n\tconf->app_nrf_conf.power = buffer[ind++];\n\tconf->app_nrf_conf.crc_type = buffer[ind++];\n\tconf->app_nrf_conf.retry_delay = buffer[ind++];\n\tconf->app_nrf_conf.retries = (int8_t)buffer[ind++];\n\tconf->app_nrf_conf.channel = (int8_t)buffer[ind++];\n\tconf->app_nrf_conf.address[0] = buffer[ind++];\n\tconf->app_nrf_conf.address[1] = buffer[ind++];\n\tconf->app_nrf_conf.address[2] = buffer[ind++];\n\tconf->app_nrf_conf.send_crc_ack = buffer[ind++];\n\tconf->app_pas_conf.ctrl_type = buffer[ind++];\n\tconf->app_pas_conf.sensor_type = buffer[ind++];\n\tconf->app_pas_conf.current_scaling = buffer_get_float16(buffer, 1000, &ind);\n\tconf->app_pas_conf.pedal_rpm_start = buffer_get_float16(buffer, 10, &ind);\n\tconf->app_pas_conf.pedal_rpm_end = buffer_get_float16(buffer, 10, &ind);\n\tconf->app_pas_conf.invert_pedal_direction = buffer[ind++];\n\tconf->app_pas_conf.magnets = buffer_get_uint16(buffer, &ind);\n\tconf->app_pas_conf.use_filter = buffer[ind++];\n\tconf->app_pas_conf.ramp_time_pos = buffer_get_float16(buffer, 100, &ind);\n\tconf->app_pas_conf.ramp_time_neg = buffer_get_float16(buffer, 100, &ind);\n\tconf->app_pas_conf.update_rate_hz = buffer_get_uint16(buffer, &ind);\n\tconf->imu_conf.type = buffer[ind++];\n\tconf->imu_conf.mode = buffer[ind++];\n\tconf->imu_conf.filter = buffer[ind++];\n\tconf->imu_conf.accel_lowpass_filter_x = buffer_get_float16(buffer, 1, &ind);\n\tconf->imu_conf.accel_lowpass_filter_y = buffer_get_float16(buffer, 1, &ind);\n\tconf->imu_conf.accel_lowpass_filter_z = buffer_get_float16(buffer, 1, &ind);\n\tconf->imu_conf.gyro_lowpass_filter = buffer_get_float16(buffer, 1, &ind);\n\tconf->imu_conf.sample_rate_hz = buffer_get_uint16(buffer, &ind);\n\tconf->imu_conf.use_magnetometer = buffer[ind++];\n\tconf->imu_conf.accel_confidence_decay = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.mahony_kp = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.mahony_ki = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.madgwick_beta = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.rot_roll = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.rot_pitch = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.rot_yaw = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.accel_offsets[0] = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.accel_offsets[1] = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.accel_offsets[2] = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.gyro_offsets[0] = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.gyro_offsets[1] = buffer_get_float32_auto(buffer, &ind);\n\tconf->imu_conf.gyro_offsets[2] = buffer_get_float32_auto(buffer, &ind);\n\n\treturn true;\n}\n\nvoid confgenerator_set_defaults_mcconf(mc_configuration *conf) {\n\tconf->pwm_mode = MCCONF_PWM_MODE;\n\tconf->comm_mode = MCCONF_COMM_MODE;\n\tconf->motor_type = MCCONF_DEFAULT_MOTOR_TYPE;\n\tconf->sensor_mode = MCCONF_SENSOR_MODE;\n\tconf->l_current_max = MCCONF_L_CURRENT_MAX;\n\tconf->l_current_min = MCCONF_L_CURRENT_MIN;\n\tconf->l_in_current_max = MCCONF_L_IN_CURRENT_MAX;\n\tconf->l_in_current_min = MCCONF_L_IN_CURRENT_MIN;\n\tconf->l_in_current_map_start = MCCONF_L_IN_CURRENT_MAP_START;\n\tconf->l_in_current_map_filter = MCCONF_L_IN_CURRENT_MAP_FILTER;\n\tconf->l_abs_current_max = MCCONF_L_MAX_ABS_CURRENT;\n\tconf->l_min_erpm = MCCONF_L_RPM_MIN;\n\tconf->l_max_erpm = MCCONF_L_RPM_MAX;\n\tconf->l_erpm_start = MCCONF_L_RPM_START;\n\tconf->l_max_erpm_fbrake = MCCONF_L_CURR_MAX_RPM_FBRAKE;\n\tconf->l_max_erpm_fbrake_cc = MCCONF_L_CURR_MAX_RPM_FBRAKE_CC;\n\tconf->l_min_vin = MCCONF_L_MIN_VOLTAGE;\n\tconf->l_max_vin = MCCONF_L_MAX_VOLTAGE;\n\tconf->l_battery_cut_start = MCCONF_L_BATTERY_CUT_START;\n\tconf->l_battery_cut_end = MCCONF_L_BATTERY_CUT_END;\n\tconf->l_battery_regen_cut_start = MCCONF_L_BATTERY_REGEN_CUT_START;\n\tconf->l_battery_regen_cut_end = MCCONF_L_BATTERY_REGEN_CUT_END;\n\tconf->l_slow_abs_current = MCCONF_L_SLOW_ABS_OVERCURRENT;\n\tconf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;\n\tconf->l_temp_fet_end = MCCONF_L_LIM_TEMP_FET_END;\n\tconf->l_temp_motor_start = MCCONF_L_LIM_TEMP_MOTOR_START;\n\tconf->l_temp_motor_end = MCCONF_L_LIM_TEMP_MOTOR_END;\n\tconf->l_temp_accel_dec = MCCONF_L_LIM_TEMP_ACCEL_DEC;\n\tconf->l_min_duty = MCCONF_L_MIN_DUTY;\n\tconf->l_max_duty = MCCONF_L_MAX_DUTY;\n\tconf->l_watt_max = MCCONF_L_WATT_MAX;\n\tconf->l_watt_min = MCCONF_L_WATT_MIN;\n\tconf->l_current_max_scale = MCCONF_L_CURRENT_MAX_SCALE;\n\tconf->l_current_min_scale = MCCONF_L_CURRENT_MIN_SCALE;\n\tconf->l_duty_start = MCCONF_L_DUTY_START;\n\tconf->sl_min_erpm = MCCONF_SL_MIN_RPM;\n\tconf->sl_min_erpm_cycle_int_limit = MCCONF_SL_MIN_ERPM_CYCLE_INT_LIMIT;\n\tconf->sl_max_fullbreak_current_dir_change = MCCONF_SL_MAX_FB_CURR_DIR_CHANGE;\n\tconf->sl_cycle_int_limit = MCCONF_SL_CYCLE_INT_LIMIT;\n\tconf->sl_phase_advance_at_br = MCCONF_SL_PHASE_ADVANCE_AT_BR;\n\tconf->sl_cycle_int_rpm_br = MCCONF_SL_CYCLE_INT_BR;\n\tconf->sl_bemf_coupling_k = MCCONF_SL_BEMF_COUPLING_K;\n\tconf->hall_table[0] = MCCONF_HALL_TAB_0;\n\tconf->hall_table[1] = MCCONF_HALL_TAB_1;\n\tconf->hall_table[2] = MCCONF_HALL_TAB_2;\n\tconf->hall_table[3] = MCCONF_HALL_TAB_3;\n\tconf->hall_table[4] = MCCONF_HALL_TAB_4;\n\tconf->hall_table[5] = MCCONF_HALL_TAB_5;\n\tconf->hall_table[6] = MCCONF_HALL_TAB_6;\n\tconf->hall_table[7] = MCCONF_HALL_TAB_7;\n\tconf->hall_sl_erpm = MCCONF_HALL_ERPM;\n\tconf->foc_current_kp = MCCONF_FOC_CURRENT_KP;\n\tconf->foc_current_ki = MCCONF_FOC_CURRENT_KI;\n\tconf->foc_f_zv = MCCONF_FOC_F_ZV;\n\tconf->foc_dt_us = MCCONF_FOC_DT_US;\n\tconf->foc_encoder_inverted = MCCONF_FOC_ENCODER_INVERTED;\n\tconf->foc_encoder_offset = MCCONF_FOC_ENCODER_OFFSET;\n\tconf->foc_encoder_ratio = MCCONF_FOC_ENCODER_RATIO;\n\tconf->foc_sensor_mode = MCCONF_FOC_SENSOR_MODE;\n\tconf->foc_pll_kp = MCCONF_FOC_PLL_KP;\n\tconf->foc_pll_ki = MCCONF_FOC_PLL_KI;\n\tconf->foc_motor_l = MCCONF_FOC_MOTOR_L;\n\tconf->foc_motor_ld_lq_diff = MCCONF_FOC_MOTOR_LD_LQ_DIFF;\n\tconf->foc_motor_r = MCCONF_FOC_MOTOR_R;\n\tconf->foc_motor_flux_linkage = MCCONF_FOC_MOTOR_FLUX_LINKAGE;\n\tconf->foc_observer_gain = MCCONF_FOC_OBSERVER_GAIN;\n\tconf->foc_observer_gain_slow = MCCONF_FOC_OBSERVER_GAIN_SLOW;\n\tconf->foc_observer_offset = MCCONF_FOC_OBSERVER_OFFSET;\n\tconf->foc_duty_dowmramp_kp = MCCONF_FOC_DUTY_DOWNRAMP_KP;\n\tconf->foc_duty_dowmramp_ki = MCCONF_FOC_DUTY_DOWNRAMP_KI;\n\tconf->foc_start_curr_dec = MCCONF_FOC_START_CURR_DEC;\n\tconf->foc_start_curr_dec_rpm = MCCONF_FOC_START_CURR_DEC_RPM;\n\tconf->foc_openloop_rpm = MCCONF_FOC_OPENLOOP_RPM;\n\tconf->foc_openloop_rpm_low = MCCONF_FOC_OPENLOOP_RPM_LOW;\n\tconf->foc_d_gain_scale_start = MCCONF_FOC_D_GAIN_SCALE_START;\n\tconf->foc_d_gain_scale_max_mod = MCCONF_FOC_D_GAIN_SCALE_MAX_MOD;\n\tconf->foc_sl_openloop_hyst = MCCONF_FOC_SL_OPENLOOP_HYST;\n\tconf->foc_sl_openloop_time_lock = MCCONF_FOC_SL_OPENLOOP_T_LOCK;\n\tconf->foc_sl_openloop_time_ramp = MCCONF_FOC_SL_OPENLOOP_T_RAMP;\n\tconf->foc_sl_openloop_time = MCCONF_FOC_SL_OPENLOOP_TIME;\n\tconf->foc_sl_openloop_boost_q = MCCONF_FOC_SL_OPENLOOP_BOOST_Q;\n\tconf->foc_sl_openloop_max_q = MCCONF_FOC_SL_OPENLOOP_MAX_Q;\n\tconf->foc_hall_table[0] = MCCONF_FOC_HALL_TAB_0;\n\tconf->foc_hall_table[1] = MCCONF_FOC_HALL_TAB_1;\n\tconf->foc_hall_table[2] = MCCONF_FOC_HALL_TAB_2;\n\tconf->foc_hall_table[3] = MCCONF_FOC_HALL_TAB_3;\n\tconf->foc_hall_table[4] = MCCONF_FOC_HALL_TAB_4;\n\tconf->foc_hall_table[5] = MCCONF_FOC_HALL_TAB_5;\n\tconf->foc_hall_table[6] = MCCONF_FOC_HALL_TAB_6;\n\tconf->foc_hall_table[7] = MCCONF_FOC_HALL_TAB_7;\n\tconf->foc_hall_interp_erpm = MCCONF_FOC_HALL_INTERP_ERPM;\n\tconf->foc_sl_erpm_start = MCCONF_FOC_SL_ERPM_START;\n\tconf->foc_sl_erpm = MCCONF_FOC_SL_ERPM;\n\tconf->foc_control_sample_mode = MCCONF_FOC_CONTROL_SAMPLE_MODE;\n\tconf->foc_current_sample_mode = MCCONF_FOC_CURRENT_SAMPLE_MODE;\n\tconf->foc_sat_comp_mode = MCCONF_FOC_SAT_COMP_MODE;\n\tconf->foc_sat_comp = MCCONF_FOC_SAT_COMP;\n\tconf->foc_temp_comp = MCCONF_FOC_TEMP_COMP;\n\tconf->foc_temp_comp_base_temp = MCCONF_FOC_TEMP_COMP_BASE_TEMP;\n\tconf->foc_current_filter_const = MCCONF_FOC_CURRENT_FILTER_CONST;\n\tconf->foc_cc_decoupling = MCCONF_FOC_CC_DECOUPLING;\n\tconf->foc_observer_type = MCCONF_FOC_OBSERVER_TYPE;\n\tconf->foc_hfi_amb_mode = MCCONF_FOC_HFI_AMB_MODE;\n\tconf->foc_hfi_amb_current = MCCONF_FOC_HFI_AMB_CURRENT;\n\tconf->foc_hfi_amb_tres = MCCONF_FOC_HFI_AMB_TRES;\n\tconf->foc_hfi_voltage_start = MCCONF_FOC_HFI_VOLTAGE_START;\n\tconf->foc_hfi_voltage_run = MCCONF_FOC_HFI_VOLTAGE_RUN;\n\tconf->foc_hfi_voltage_max = MCCONF_FOC_HFI_VOLTAGE_MAX;\n\tconf->foc_hfi_gain = MCCONF_FOC_HFI_GAIN;\n\tconf->foc_hfi_max_err = MCCONF_FOC_HFI_MAX_ERR;\n\tconf->foc_hfi_hyst = MCCONF_FOC_HFI_HYST;\n\tconf->foc_sl_erpm_hfi = MCCONF_FOC_SL_ERPM_HFI;\n\tconf->foc_hfi_start_samples = MCCONF_FOC_HFI_START_SAMPLES;\n\tconf->foc_hfi_obs_ovr_sec = MCCONF_FOC_HFI_OBS_OVR_SEC;\n\tconf->foc_hfi_samples = MCCONF_FOC_HFI_SAMPLES;\n\tconf->foc_offsets_cal_mode = MCCONF_FOC_OFFSETS_CAL_MODE;\n\tconf->foc_offsets_current[0] = MCCONF_FOC_OFFSETS_CURRENT_0;\n\tconf->foc_offsets_current[1] = MCCONF_FOC_OFFSETS_CURRENT_1;\n\tconf->foc_offsets_current[2] = MCCONF_FOC_OFFSETS_CURRENT_2;\n\tconf->foc_offsets_voltage[0] = MCCONF_FOC_OFFSETS_VOLTAGE_0;\n\tconf->foc_offsets_voltage[1] = MCCONF_FOC_OFFSETS_VOLTAGE_1;\n\tconf->foc_offsets_voltage[2] = MCCONF_FOC_OFFSETS_VOLTAGE_2;\n\tconf->foc_offsets_voltage_undriven[0] = MCCONF_FOC_OFFSETS_VOLTAGE_UNDRIVEN_0;\n\tconf->foc_offsets_voltage_undriven[1] = MCCONF_FOC_OFFSETS_VOLTAGE_UNDRIVEN_1;\n\tconf->foc_offsets_voltage_undriven[2] = MCCONF_FOC_OFFSETS_VOLTAGE_UNDRIVEN_2;\n\tconf->foc_phase_filter_enable = MCCONF_FOC_PHASE_FILTER_ENABLE;\n\tconf->foc_phase_filter_disable_fault = MCCONF_FOC_PHASE_FILTER_DISABLE_FAULT;\n\tconf->foc_phase_filter_max_erpm = MCCONF_FOC_PHASE_FILTER_MAX_ERPM;\n\tconf->foc_mtpa_mode = MCCONF_FOC_MTPA_MODE;\n\tconf->foc_fw_current_max = MCCONF_FOC_FW_CURRENT_MAX;\n\tconf->foc_fw_duty_start = MCCONF_FOC_FW_DUTY_START;\n\tconf->foc_fw_ramp_time = MCCONF_FOC_FW_RAMP_TIME;\n\tconf->foc_fw_q_current_factor = MCCONF_FOC_FW_Q_CURRENT_FACTOR;\n\tconf->foc_speed_soure = MCCONF_FOC_SPEED_SOURCE;\n\tconf->foc_short_ls_on_zero_duty = MCCONF_FOC_SHORT_LS_ON_ZERO_DUTY;\n\tconf->sp_pid_loop_rate = MCCONF_SP_PID_LOOP_RATE;\n\tconf->s_pid_kp = MCCONF_S_PID_KP;\n\tconf->s_pid_ki = MCCONF_S_PID_KI;\n\tconf->s_pid_kd = MCCONF_S_PID_KD;\n\tconf->s_pid_kd_filter = MCCONF_S_PID_KD_FILTER;\n\tconf->s_pid_min_erpm = MCCONF_S_PID_MIN_RPM;\n\tconf->s_pid_allow_braking = MCCONF_S_PID_ALLOW_BRAKING;\n\tconf->s_pid_ramp_erpms_s = MCCONF_S_PID_RAMP_ERPMS_S;\n\tconf->s_pid_speed_source = MCCONF_S_PID_SPEED_SOURCE;\n\tconf->p_pid_kp = MCCONF_P_PID_KP;\n\tconf->p_pid_ki = MCCONF_P_PID_KI;\n\tconf->p_pid_kd = MCCONF_P_PID_KD;\n\tconf->p_pid_kd_proc = MCCONF_P_PID_KD_PROC;\n\tconf->p_pid_kd_filter = MCCONF_P_PID_KD_FILTER;\n\tconf->p_pid_ang_div = MCCONF_P_PID_ANG_DIV;\n\tconf->p_pid_gain_dec_angle = MCCONF_P_PID_GAIN_DEC_ANGLE;\n\tconf->p_pid_offset = MCCONF_P_PID_OFFSET;\n\tconf->cc_startup_boost_duty = MCCONF_CC_STARTUP_BOOST_DUTY;\n\tconf->cc_min_current = MCCONF_CC_MIN_CURRENT;\n\tconf->cc_gain = MCCONF_CC_GAIN;\n\tconf->cc_ramp_step_max = MCCONF_CC_RAMP_STEP;\n\tconf->m_fault_stop_time_ms = MCCONF_M_FAULT_STOP_TIME;\n\tconf->m_duty_ramp_step = MCCONF_M_RAMP_STEP;\n\tconf->m_current_backoff_gain = MCCONF_M_CURRENT_BACKOFF_GAIN;\n\tconf->m_encoder_counts = MCCONF_M_ENCODER_COUNTS;\n\tconf->m_encoder_sin_amp = MCCONF_M_ENCODER_SIN_AMP;\n\tconf->m_encoder_cos_amp = MCCONF_M_ENCODER_COS_AMP;\n\tconf->m_encoder_sin_offset = MCCONF_M_ENCODER_SIN_OFFSET;\n\tconf->m_encoder_cos_offset = MCCONF_M_ENCODER_COS_OFFSET;\n\tconf->m_encoder_sincos_filter_constant = MCCONF_M_ENCODER_SINCOS_FILTER;\n\tconf->m_encoder_sincos_phase_correction = MCCONF_M_ENCODER_SINCOS_PHASE;\n\tconf->m_sensor_port_mode = MCCONF_M_SENSOR_PORT_MODE;\n\tconf->m_invert_direction = MCCONF_M_INVERT_DIRECTION;\n\tconf->m_drv8301_oc_mode = MCCONF_M_DRV8301_OC_MODE;\n\tconf->m_drv8301_oc_adj = MCCONF_M_DRV8301_OC_ADJ;\n\tconf->m_bldc_f_sw_min = MCCONF_M_BLDC_F_SW_MIN;\n\tconf->m_bldc_f_sw_max = MCCONF_M_BLDC_F_SW_MAX;\n\tconf->m_dc_f_sw = MCCONF_M_DC_F_SW;\n\tconf->m_ntc_motor_beta = MCCONF_M_NTC_MOTOR_BETA;\n\tconf->m_out_aux_mode = MCCONF_M_OUT_AUX_MODE;\n\tconf->m_motor_temp_sens_type = MCCONF_M_MOTOR_TEMP_SENS_TYPE;\n\tconf->m_ptc_motor_coeff = MCCONF_M_PTC_MOTOR_COEFF;\n\tconf->m_ntcx_ptcx_res = MCCONF_M_NTCX_PTCX_RES;\n\tconf->m_ntcx_ptcx_temp_base = MCCONF_M_NTCX_PTCX_BASE_TEMP;\n\tconf->m_hall_extra_samples = MCCONF_M_HALL_EXTRA_SAMPLES;\n\tconf->m_batt_filter_const = MCCONF_M_BATT_FILTER_CONST;\n\tconf->si_motor_poles = MCCONF_SI_MOTOR_POLES;\n\tconf->si_gear_ratio = MCCONF_SI_GEAR_RATIO;\n\tconf->si_wheel_diameter = MCCONF_SI_WHEEL_DIAMETER;\n\tconf->si_battery_type = MCCONF_SI_BATTERY_TYPE;\n\tconf->si_battery_cells = MCCONF_SI_BATTERY_CELLS;\n\tconf->si_battery_ah = MCCONF_SI_BATTERY_AH;\n\tconf->si_motor_nl_current = MCCONF_SI_MOTOR_NL_CURRENT;\n\tconf->bms.type = MCCONF_BMS_TYPE;\n\tconf->bms.limit_mode = MCCONF_BMS_LIMIT_MODE;\n\tconf->bms.t_limit_start = MCCONF_BMS_T_LIMIT_START;\n\tconf->bms.t_limit_end = MCCONF_BMS_T_LIMIT_END;\n\tconf->bms.soc_limit_start = MCCONF_BMS_SOC_LIMIT_START;\n\tconf->bms.soc_limit_end = MCCONF_BMS_SOC_LIMIT_END;\n\tconf->bms.vmin_limit_start = MCCONF_BMS_VMIN_LIMIT_START;\n\tconf->bms.vmin_limit_end = MCCONF_BMS_VMIN_LIMIT_END;\n\tconf->bms.vmax_limit_start = MCCONF_BMS_VMAX_LIMIT_START;\n\tconf->bms.vmax_limit_end = MCCONF_BMS_VMAX_LIMIT_END;\n\tconf->bms.fwd_can_mode = MCCONF_BMS_FWD_CAN_MODE;\n}\n\nvoid confgenerator_set_defaults_appconf(app_configuration *conf) {\n\tconf->controller_id = HW_DEFAULT_ID;\n\tconf->timeout_msec = APPCONF_TIMEOUT_MSEC;\n\tconf->timeout_brake_current = APPCONF_TIMEOUT_BRAKE_CURRENT;\n\tconf->can_status_rate_1 = APPCONF_CAN_STATUS_RATE_1;\n\tconf->can_status_rate_2 = APPCONF_CAN_STATUS_RATE_2;\n\tconf->can_status_msgs_r1 = APPCONF_CAN_STATUS_MSGS_R1;\n\tconf->can_status_msgs_r2 = APPCONF_CAN_STATUS_MSGS_R2;\n\tconf->can_baud_rate = APPCONF_CAN_BAUD_RATE;\n\tconf->pairing_done = APPCONF_PAIRING_DONE;\n\tconf->permanent_uart_enabled = APPCONF_PERMANENT_UART_ENABLED;\n\tconf->shutdown_mode = APPCONF_SHUTDOWN_MODE;\n\tconf->can_mode = APPCONF_CAN_MODE;\n\tconf->uavcan_esc_index = APPCONF_UAVCAN_ESC_INDEX;\n\tconf->uavcan_raw_mode = APPCONF_UAVCAN_RAW_MODE;\n\tconf->uavcan_raw_rpm_max = APPCONF_UAVCAN_RAW_RPM_MAX;\n\tconf->uavcan_status_current_mode = APPCONF_UAVCAN_STATUS_CURRENT_MODE;\n\tconf->servo_out_enable = APPCONF_SERVO_OUT_ENABLE;\n\tconf->kill_sw_mode = APPCONF_KILL_SW_MODE;\n\tconf->app_to_use = APPCONF_APP_TO_USE;\n\tconf->app_ppm_conf.ctrl_type = APPCONF_PPM_CTRL_TYPE;\n\tconf->app_ppm_conf.pid_max_erpm = APPCONF_PPM_PID_MAX_ERPM;\n\tconf->app_ppm_conf.hyst = APPCONF_PPM_HYST;\n\tconf->app_ppm_conf.pulse_start = APPCONF_PPM_PULSE_START;\n\tconf->app_ppm_conf.pulse_end = APPCONF_PPM_PULSE_END;\n\tconf->app_ppm_conf.pulse_center = APPCONF_PPM_PULSE_CENTER;\n\tconf->app_ppm_conf.median_filter = APPCONF_PPM_MEDIAN_FILTER;\n\tconf->app_ppm_conf.safe_start = APPCONF_PPM_SAFE_START;\n\tconf->app_ppm_conf.throttle_exp = APPCONF_PPM_THROTTLE_EXP;\n\tconf->app_ppm_conf.throttle_exp_brake = APPCONF_PPM_THROTTLE_EXP_BRAKE;\n\tconf->app_ppm_conf.throttle_exp_mode = APPCONF_PPM_THROTTLE_EXP_MODE;\n\tconf->app_ppm_conf.ramp_time_pos = APPCONF_PPM_RAMP_TIME_POS;\n\tconf->app_ppm_conf.ramp_time_neg = APPCONF_PPM_RAMP_TIME_NEG;\n\tconf->app_ppm_conf.multi_esc = APPCONF_PPM_MULTI_ESC;\n\tconf->app_ppm_conf.tc = APPCONF_PPM_TC;\n\tconf->app_ppm_conf.tc_max_diff = APPCONF_PPM_TC_MAX_DIFF;\n\tconf->app_ppm_conf.max_erpm_for_dir = APPCONF_PPM_MAX_ERPM_FOR_DIR;\n\tconf->app_ppm_conf.smart_rev_max_duty = APPCONF_PPM_SMART_REV_MAX_DUTY;\n\tconf->app_ppm_conf.smart_rev_ramp_time = APPCONF_PPM_SMART_REV_RAMP_TIME;\n\tconf->app_adc_conf.ctrl_type = APPCONF_ADC_CTRL_TYPE;\n\tconf->app_adc_conf.hyst = APPCONF_ADC_HYST;\n\tconf->app_adc_conf.voltage_start = APPCONF_ADC_VOLTAGE_START;\n\tconf->app_adc_conf.voltage_end = APPCONF_ADC_VOLTAGE_END;\n\tconf->app_adc_conf.voltage_min = APPCONF_ADC_VOLTAGE_MIN;\n\tconf->app_adc_conf.voltage_max = APPCONF_ADC_VOLTAGE_MAX;\n\tconf->app_adc_conf.voltage_center = APPCONF_ADC_VOLTAGE_CENTER;\n\tconf->app_adc_conf.voltage2_start = APPCONF_ADC_VOLTAGE2_START;\n\tconf->app_adc_conf.voltage2_end = APPCONF_ADC_VOLTAGE2_END;\n\tconf->app_adc_conf.use_filter = APPCONF_ADC_USE_FILTER;\n\tconf->app_adc_conf.safe_start = APPCONF_ADC_SAFE_START;\n\tconf->app_adc_conf.buttons = APPCONF_ADC_BUTTONS;\n\tconf->app_adc_conf.voltage_inverted = APPCONF_ADC_VOLTAGE_INVERTED;\n\tconf->app_adc_conf.voltage2_inverted = APPCONF_ADC_VOLTAGE2_INVERTED;\n\tconf->app_adc_conf.throttle_exp = APPCONF_ADC_THROTTLE_EXP;\n\tconf->app_adc_conf.throttle_exp_brake = APPCONF_ADC_THROTTLE_EXP_BRAKE;\n\tconf->app_adc_conf.throttle_exp_mode = APPCONF_ADC_THROTTLE_EXP_MODE;\n\tconf->app_adc_conf.ramp_time_pos = APPCONF_ADC_RAMP_TIME_POS;\n\tconf->app_adc_conf.ramp_time_neg = APPCONF_ADC_RAMP_TIME_NEG;\n\tconf->app_adc_conf.multi_esc = APPCONF_ADC_MULTI_ESC;\n\tconf->app_adc_conf.tc = APPCONF_ADC_TC;\n\tconf->app_adc_conf.tc_max_diff = APPCONF_ADC_TC_MAX_DIFF;\n\tconf->app_adc_conf.update_rate_hz = APPCONF_ADC_UPDATE_RATE_HZ;\n\tconf->app_uart_baudrate = APPCONF_UART_BAUDRATE;\n\tconf->app_chuk_conf.ctrl_type = APPCONF_CHUK_CTRL_TYPE;\n\tconf->app_chuk_conf.hyst = APPCONF_CHUK_HYST;\n\tconf->app_chuk_conf.ramp_time_pos = APPCONF_CHUK_RAMP_TIME_POS;\n\tconf->app_chuk_conf.ramp_time_neg = APPCONF_CHUK_RAMP_TIME_NEG;\n\tconf->app_chuk_conf.stick_erpm_per_s_in_cc = APPCONF_STICK_ERPM_PER_S_IN_CC;\n\tconf->app_chuk_conf.throttle_exp = APPCONF_CHUK_THROTTLE_EXP;\n\tconf->app_chuk_conf.throttle_exp_brake = APPCONF_CHUK_THROTTLE_EXP_BRAKE;\n\tconf->app_chuk_conf.throttle_exp_mode = APPCONF_CHUK_THROTTLE_EXP_MODE;\n\tconf->app_chuk_conf.multi_esc = APPCONF_CHUK_MULTI_ESC;\n\tconf->app_chuk_conf.tc = APPCONF_CHUK_TC;\n\tconf->app_chuk_conf.tc_max_diff = APPCONF_CHUK_TC_MAX_DIFF;\n\tconf->app_chuk_conf.use_smart_rev = APPCONF_CHUK_USE_SMART_REV;\n\tconf->app_chuk_conf.smart_rev_max_duty = APPCONF_CHUK_SMART_REV_MAX_DUTY;\n\tconf->app_chuk_conf.smart_rev_ramp_time = APPCONF_CHUK_SMART_REV_RAMP_TIME;\n\tconf->app_nrf_conf.speed = APPCONF_NRF_SPEED;\n\tconf->app_nrf_conf.power = APPCONF_NRF_POWER;\n\tconf->app_nrf_conf.crc_type = APPCONF_NRF_CRC;\n\tconf->app_nrf_conf.retry_delay = APPCONF_NRF_RETR_DELAY;\n\tconf->app_nrf_conf.retries = APPCONF_NRF_RETRIES;\n\tconf->app_nrf_conf.channel = APPCONF_NRF_CHANNEL;\n\tconf->app_nrf_conf.address[0] = APPCONF_NRF_ADDR_B0;\n\tconf->app_nrf_conf.address[1] = APPCONF_NRF_ADDR_B1;\n\tconf->app_nrf_conf.address[2] = APPCONF_NRF_ADDR_B2;\n\tconf->app_nrf_conf.send_crc_ack = APPCONF_NRF_SEND_CRC_ACK;\n\tconf->app_pas_conf.ctrl_type = APPCONF_PAS_CTRL_TYPE;\n\tconf->app_pas_conf.sensor_type = APPCONF_PAS_SENSOR_TYPE;\n\tconf->app_pas_conf.current_scaling = APPCONF_PAS_CURRENT_SCALING;\n\tconf->app_pas_conf.pedal_rpm_start = APPCONF_PAS_PEDAL_RPM_START;\n\tconf->app_pas_conf.pedal_rpm_end = APPCONF_PAS_PEDAL_RPM_END;\n\tconf->app_pas_conf.invert_pedal_direction = APPCONF_PAS_INVERT_PEDAL_DIRECTION;\n\tconf->app_pas_conf.magnets = APPCONF_PAS_MAGNETS;\n\tconf->app_pas_conf.use_filter = APPCONF_PAS_USE_FILTER;\n\tconf->app_pas_conf.ramp_time_pos = APPCONF_PAS_RAMP_TIME_POS;\n\tconf->app_pas_conf.ramp_time_neg = APPCONF_PAS_RAMP_TIME_NEG;\n\tconf->app_pas_conf.update_rate_hz = APPCONF_PAS_UPDATE_RATE_HZ;\n\tconf->imu_conf.type = APPCONF_IMU_TYPE;\n\tconf->imu_conf.mode = APPCONF_IMU_AHRS_MODE;\n\tconf->imu_conf.filter = APPCONF_IMU_FILTER;\n\tconf->imu_conf.accel_lowpass_filter_x = APPCONF_IMU_ACCEL_LOWPASS_FILTER_X;\n\tconf->imu_conf.accel_lowpass_filter_y = APPCONF_IMU_ACCEL_LOWPASS_FILTER_Y;\n\tconf->imu_conf.accel_lowpass_filter_z = APPCONF_IMU_ACCEL_LOWPASS_FILTER_Z;\n\tconf->imu_conf.gyro_lowpass_filter = APPCONF_IMU_GYRO_LOWPASS_FILTER;\n\tconf->imu_conf.sample_rate_hz = APPCONF_IMU_SAMPLE_RATE_HZ;\n\tconf->imu_conf.use_magnetometer = APPCONF_IMU_USE_MAGNETOMETER;\n\tconf->imu_conf.accel_confidence_decay = APPCONF_IMU_ACCEL_CONFIDENCE_DECAY;\n\tconf->imu_conf.mahony_kp = APPCONF_IMU_MAHONY_KP;\n\tconf->imu_conf.mahony_ki = APPCONF_IMU_MAHONY_KI;\n\tconf->imu_conf.madgwick_beta = APPCONF_IMU_MADGWICK_BETA;\n\tconf->imu_conf.rot_roll = APPCONF_IMU_ROT_ROLL;\n\tconf->imu_conf.rot_pitch = APPCONF_IMU_ROT_PITCH;\n\tconf->imu_conf.rot_yaw = APPCONF_IMU_ROT_YAW;\n\tconf->imu_conf.accel_offsets[0] = APPCONF_IMU_A_OFFSET_0;\n\tconf->imu_conf.accel_offsets[1] = APPCONF_IMU_A_OFFSET_1;\n\tconf->imu_conf.accel_offsets[2] = APPCONF_IMU_A_OFFSET_2;\n\tconf->imu_conf.gyro_offsets[0] = APPCONF_IMU_G_OFFSET_0;\n\tconf->imu_conf.gyro_offsets[1] = APPCONF_IMU_G_OFFSET_1;\n\tconf->imu_conf.gyro_offsets[2] = APPCONF_IMU_G_OFFSET_2;\n}\n"
        },
        {
          "name": "confgenerator.h",
          "type": "blob",
          "size": 0.751953125,
          "content": "// This file is autogenerated by VESC Tool\n\n#ifndef CONFGENERATOR_H_\n#define CONFGENERATOR_H_\n\n#include \"datatypes.h\"\n#include <stdint.h>\n#include <stdbool.h>\n\n// Constants\n#define MCCONF_SIGNATURE\t\t76650945\n#define APPCONF_SIGNATURE\t\t2099347128\n\n// Functions\nint32_t confgenerator_serialize_mcconf(uint8_t *buffer, const mc_configuration *conf);\nint32_t confgenerator_serialize_appconf(uint8_t *buffer, const app_configuration *conf);\n\nbool confgenerator_deserialize_mcconf(const uint8_t *buffer, mc_configuration *conf);\nbool confgenerator_deserialize_appconf(const uint8_t *buffer, app_configuration *conf);\n\nvoid confgenerator_set_defaults_mcconf(mc_configuration *conf);\nvoid confgenerator_set_defaults_appconf(app_configuration *conf);\n\n// CONFGENERATOR_H_\n#endif\n"
        },
        {
          "name": "datatypes.h",
          "type": "blob",
          "size": 31.701171875,
          "content": "/*\n\tCopyright 2016 - 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef DATATYPES_H_\n#define DATATYPES_H_\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"ch.h\"\n\n// Data types\ntypedef enum {\n\tHW_TYPE_VESC = 0,\n\tHW_TYPE_VESC_BMS,\n\tHW_TYPE_CUSTOM_MODULE\n} HW_TYPE;\n\ntypedef enum {\n   MC_STATE_OFF = 0,\n   MC_STATE_DETECTING,\n   MC_STATE_RUNNING,\n   MC_STATE_FULL_BRAKE,\n} mc_state;\n\ntypedef enum {\n\tPWM_MODE_NONSYNCHRONOUS_HISW = 0, // This mode is not recommended\n\tPWM_MODE_SYNCHRONOUS, // The recommended and most tested mode\n\tPWM_MODE_BIPOLAR // Some glitches occasionally, can kill MOSFETs\n} mc_pwm_mode;\n\ntypedef enum {\n\tCOMM_MODE_INTEGRATE = 0,\n\tCOMM_MODE_DELAY\n} mc_comm_mode;\n\ntypedef enum {\n\tSENSOR_MODE_SENSORLESS = 0,\n\tSENSOR_MODE_SENSORED,\n\tSENSOR_MODE_HYBRID\n} mc_sensor_mode;\n\ntypedef enum {\n\tFOC_SENSOR_MODE_SENSORLESS = 0,\n\tFOC_SENSOR_MODE_ENCODER,\n\tFOC_SENSOR_MODE_HALL,\n\tFOC_SENSOR_MODE_HFI,\n\tFOC_SENSOR_MODE_HFI_START,\n\tFOC_SENSOR_MODE_HFI_V2,\n\tFOC_SENSOR_MODE_HFI_V3,\n\tFOC_SENSOR_MODE_HFI_V4,\n\tFOC_SENSOR_MODE_HFI_V5\n} mc_foc_sensor_mode;\n\ntypedef enum {\n\tFOC_CONTROL_SAMPLE_MODE_V0 = 0,\n\tFOC_CONTROL_SAMPLE_MODE_V0_V7,\n\tFOC_CONTROL_SAMPLE_MODE_V0_V7_INTERPOL\n} mc_foc_control_sample_mode;\n\ntypedef enum {\n\tFOC_CURRENT_SAMPLE_MODE_LONGEST_ZERO = 0,\n\tFOC_CURRENT_SAMPLE_MODE_ALL_SENSORS,\n\tFOC_CURRENT_SAMPLE_MODE_HIGH_CURRENT\n} mc_foc_current_sample_mode;\n\n// Auxiliary output mode\ntypedef enum {\n\tOUT_AUX_MODE_OFF = 0,\n\tOUT_AUX_MODE_ON_AFTER_2S,\n\tOUT_AUX_MODE_ON_AFTER_5S,\n\tOUT_AUX_MODE_ON_AFTER_10S,\n\tOUT_AUX_MODE_UNUSED,\n\tOUT_AUX_MODE_ON_WHEN_RUNNING,\n\tOUT_AUX_MODE_ON_WHEN_NOT_RUNNING,\n\tOUT_AUX_MODE_MOTOR_50,\n\tOUT_AUX_MODE_MOSFET_50,\n\tOUT_AUX_MODE_MOTOR_70,\n\tOUT_AUX_MODE_MOSFET_70,\n\tOUT_AUX_MODE_MOTOR_MOSFET_50,\n\tOUT_AUX_MODE_MOTOR_MOSFET_70,\n} out_aux_mode;\n\n// Temperature sensor type\ntypedef enum {\n\tTEMP_SENSOR_NTC_10K_25C = 0,\n\tTEMP_SENSOR_PTC_1K_100C,\n\tTEMP_SENSOR_KTY83_122,\n\tTEMP_SENSOR_NTC_100K_25C,\n\tTEMP_SENSOR_KTY84_130,\n\tTEMP_SENSOR_NTCX,\n\tTEMP_SENSOR_PTCX,\n\tTEMP_SENSOR_PT1000,\n\tTEMP_SENSOR_DISABLED\n} temp_sensor_type;\n\ntypedef enum {\n\tMOTOR_TYPE_BLDC = 0,\n\tMOTOR_TYPE_DC,\n\tMOTOR_TYPE_FOC\n} mc_motor_type;\n\n// FOC current controller decoupling mode.\ntypedef enum {\n\tFOC_CC_DECOUPLING_DISABLED = 0,\n\tFOC_CC_DECOUPLING_CROSS,\n\tFOC_CC_DECOUPLING_BEMF,\n\tFOC_CC_DECOUPLING_CROSS_BEMF\n} mc_foc_cc_decoupling_mode;\n\ntypedef enum {\n\tFOC_OBSERVER_ORTEGA_ORIGINAL = 0,\n\tFOC_OBSERVER_MXLEMMING,\n\tFOC_OBSERVER_ORTEGA_LAMBDA_COMP,\n\tFOC_OBSERVER_MXLEMMING_LAMBDA_COMP,\n\tFOC_OBSERVER_MXV,\n\tFOC_OBSERVER_MXV_LAMBDA_COMP,\n\tFOC_OBSERVER_MXV_LAMBDA_COMP_LIN,\n} mc_foc_observer_type;\n\ntypedef enum {\n\tFOC_AMB_MODE_SIX_VECTOR = 0,\n\tFOC_AMB_MODE_D_SINGLE_PULSE,\n\tFOC_AMB_MODE_D_DOUBLE_PULSE\n} mc_foc_hfi_amb_mode;\n\ntypedef enum {\n\tFAULT_CODE_NONE = 0,\n\tFAULT_CODE_OVER_VOLTAGE,\n\tFAULT_CODE_UNDER_VOLTAGE,\n\tFAULT_CODE_DRV,\n\tFAULT_CODE_ABS_OVER_CURRENT,\n\tFAULT_CODE_OVER_TEMP_FET,\n\tFAULT_CODE_OVER_TEMP_MOTOR,\n\tFAULT_CODE_GATE_DRIVER_OVER_VOLTAGE,\n\tFAULT_CODE_GATE_DRIVER_UNDER_VOLTAGE,\n\tFAULT_CODE_MCU_UNDER_VOLTAGE,\n\tFAULT_CODE_BOOTING_FROM_WATCHDOG_RESET,\n\tFAULT_CODE_ENCODER_SPI,\n\tFAULT_CODE_ENCODER_SINCOS_BELOW_MIN_AMPLITUDE,\n\tFAULT_CODE_ENCODER_SINCOS_ABOVE_MAX_AMPLITUDE,\n\tFAULT_CODE_FLASH_CORRUPTION,\n\tFAULT_CODE_HIGH_OFFSET_CURRENT_SENSOR_1,\n\tFAULT_CODE_HIGH_OFFSET_CURRENT_SENSOR_2,\n\tFAULT_CODE_HIGH_OFFSET_CURRENT_SENSOR_3,\n\tFAULT_CODE_UNBALANCED_CURRENTS,\n\tFAULT_CODE_BRK,\n\tFAULT_CODE_RESOLVER_LOT,\n\tFAULT_CODE_RESOLVER_DOS,\n\tFAULT_CODE_RESOLVER_LOS,\n\tFAULT_CODE_FLASH_CORRUPTION_APP_CFG,\n\tFAULT_CODE_FLASH_CORRUPTION_MC_CFG,\n\tFAULT_CODE_ENCODER_NO_MAGNET,\n\tFAULT_CODE_ENCODER_MAGNET_TOO_STRONG,\n\tFAULT_CODE_PHASE_FILTER,\n\tFAULT_CODE_ENCODER_FAULT,\n\tFAULT_CODE_LV_OUTPUT_FAULT,\n} mc_fault_code;\n\ntypedef enum {\n\tCONTROL_MODE_DUTY = 0,\n\tCONTROL_MODE_SPEED,\n\tCONTROL_MODE_CURRENT,\n\tCONTROL_MODE_CURRENT_BRAKE,\n\tCONTROL_MODE_POS,\n\tCONTROL_MODE_HANDBRAKE,\n\tCONTROL_MODE_OPENLOOP,\n\tCONTROL_MODE_OPENLOOP_PHASE,\n\tCONTROL_MODE_OPENLOOP_DUTY,\n\tCONTROL_MODE_OPENLOOP_DUTY_PHASE,\n\tCONTROL_MODE_NONE\n} mc_control_mode;\n\ntypedef enum {\n\tDISP_POS_MODE_NONE = 0,\n\tDISP_POS_MODE_INDUCTANCE,\n\tDISP_POS_MODE_OBSERVER,\n\tDISP_POS_MODE_ENCODER,\n\tDISP_POS_MODE_PID_POS,\n\tDISP_POS_MODE_PID_POS_ERROR,\n\tDISP_POS_MODE_ENCODER_OBSERVER_ERROR,\n\tDISP_POS_MODE_HALL_OBSERVER_ERROR\n} disp_pos_mode;\n\ntypedef enum {\n\tSENSOR_PORT_MODE_HALL = 0,\n\tSENSOR_PORT_MODE_ABI,\n\tSENSOR_PORT_MODE_AS5047_SPI,\n\tSENSOR_PORT_MODE_AD2S1205,\n\tSENSOR_PORT_MODE_SINCOS,\n\tSENSOR_PORT_MODE_TS5700N8501,\n\tSENSOR_PORT_MODE_TS5700N8501_MULTITURN,\n\tSENSOR_PORT_MODE_MT6816_SPI_HW,\n\tSENSOR_PORT_MODE_AS5x47U_SPI,\n\tSENSOR_PORT_MODE_BISSC,\n\tSENSOR_PORT_MODE_TLE5012_SSC_SW,\n\tSENSOR_PORT_MODE_TLE5012_SSC_HW,\n\tSENSOR_PORT_MODE_CUSTOM_ENCODER,\n} sensor_port_mode;\n\ntypedef struct {\n\tfloat cycle_int_limit;\n\tfloat cycle_int_limit_running;\n\tfloat cycle_int_limit_max;\n\tfloat comm_time_sum;\n\tfloat comm_time_sum_min_rpm;\n\tint32_t comms;\n\tfloat time_at_comm;\n} mc_rpm_dep_struct;\n\ntypedef enum {\n\tDRV8301_OC_LIMIT = 0,\n\tDRV8301_OC_LATCH_SHUTDOWN,\n\tDRV8301_OC_REPORT_ONLY,\n\tDRV8301_OC_DISABLED\n} drv8301_oc_mode;\n\ntypedef enum {\n\tDEBUG_SAMPLING_OFF = 0,\n\tDEBUG_SAMPLING_NOW,\n\tDEBUG_SAMPLING_START,\n\tDEBUG_SAMPLING_TRIGGER_START,\n\tDEBUG_SAMPLING_TRIGGER_FAULT,\n\tDEBUG_SAMPLING_TRIGGER_START_NOSEND,\n\tDEBUG_SAMPLING_TRIGGER_FAULT_NOSEND,\n\tDEBUG_SAMPLING_SEND_LAST_SAMPLES,\n\tDEBUG_SAMPLING_SEND_SINGLE_SAMPLE\n} debug_sampling_mode;\n\ntypedef enum {\n\tCAN_BAUD_125K = 0,\n\tCAN_BAUD_250K,\n\tCAN_BAUD_500K,\n\tCAN_BAUD_1M,\n\tCAN_BAUD_10K,\n\tCAN_BAUD_20K,\n\tCAN_BAUD_50K,\n\tCAN_BAUD_75K,\n\tCAN_BAUD_100K\n} CAN_BAUD;\n\ntypedef enum {\n\tBATTERY_TYPE_LIION_3_0__4_2,\n\tBATTERY_TYPE_LIIRON_2_6__3_6,\n\tBATTERY_TYPE_LEAD_ACID\n} BATTERY_TYPE;\n\ntypedef enum {\n\tHFI_SAMPLES_8 = 0,\n\tHFI_SAMPLES_16,\n\tHFI_SAMPLES_32\n} foc_hfi_samples;\n\ntypedef enum {\n\tBMS_TYPE_NONE = 0,\n\tBMS_TYPE_VESC\n} BMS_TYPE;\n\ntypedef enum {\n\tBMS_FWD_CAN_MODE_DISABLED = 0,\n\tBMS_FWD_CAN_MODE_USB_ONLY,\n\tBMS_FWD_CAN_MODE_ANY\n} BMS_FWD_CAN_MODE;\n\ntypedef struct {\n\tBMS_TYPE type;\n\tuint8_t limit_mode;\n\tfloat t_limit_start;\n\tfloat t_limit_end;\n\tfloat soc_limit_start;\n\tfloat soc_limit_end;\n\tfloat vmin_limit_start;\n\tfloat vmin_limit_end;\n\tfloat vmax_limit_start;\n\tfloat vmax_limit_end;\n\tBMS_FWD_CAN_MODE fwd_can_mode;\n} bms_config;\n\n#define BMS_MAX_CELLS\t50\n#define BMS_MAX_TEMPS\t50\n\ntypedef struct {\n\tfloat v_tot;\n\tfloat v_charge;\n\tfloat i_in;\n\tfloat i_in_ic;\n\tfloat ah_cnt;\n\tfloat wh_cnt;\n\tint cell_num;\n\tfloat v_cell[BMS_MAX_CELLS];\n\tbool bal_state[BMS_MAX_CELLS];\n\tint temp_adc_num;\n\tfloat temps_adc[BMS_MAX_TEMPS];\n\tfloat temp_ic;\n\tfloat temp_hum;\n\tfloat pressure;\n\tfloat hum;\n\tfloat temp_max_cell;\n\tfloat v_cell_min;\n\tfloat v_cell_max;\n\tfloat soc;\n\tfloat soh;\n\tint can_id;\n\tfloat ah_cnt_chg_total;\n\tfloat wh_cnt_chg_total;\n\tfloat ah_cnt_dis_total;\n\tfloat wh_cnt_dis_total;\n\tint is_charging;\n\tint is_balancing;\n\tint is_charge_allowed;\n\tint data_version;\n\tsystime_t update_time;\n} bms_values;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat v_cell_min;\n\tfloat v_cell_max;\n\tfloat t_cell_max;\n\tfloat soc;\n\tfloat soh;\n\tbool is_charging;\n\tbool is_balancing;\n\tbool is_charge_allowed;\n\tint data_version;\n} bms_soc_soh_temp_stat;\n\ntypedef enum {\n\tPID_RATE_25_HZ = 0,\n\tPID_RATE_50_HZ,\n\tPID_RATE_100_HZ,\n\tPID_RATE_250_HZ,\n\tPID_RATE_500_HZ,\n\tPID_RATE_1000_HZ,\n\tPID_RATE_2500_HZ,\n\tPID_RATE_5000_HZ,\n\tPID_RATE_10000_HZ,\n} PID_RATE;\n\ntypedef enum {\n\tMTPA_MODE_OFF = 0,\n\tMTPA_MODE_IQ_TARGET,\n\tMTPA_MODE_IQ_MEASURED\n} MTPA_MODE;\n\ntypedef enum {\n\tFOC_SPEED_SRC_CORRECTED = 0,\n\tFOC_SPEED_SRC_OBSERVER,\n} FOC_SPEED_SRC;\n\ntypedef enum {\n\tS_PID_SPEED_SRC_PLL = 0,\n\tS_PID_SPEED_SRC_FAST,\n\tS_PID_SPEED_SRC_FASTER,\n} S_PID_SPEED_SRC;\n\ntypedef enum {\n\tSAT_COMP_DISABLED = 0,\n\tSAT_COMP_FACTOR,\n\tSAT_COMP_LAMBDA,\n\tSAT_COMP_LAMBDA_AND_FACTOR\n} SAT_COMP_MODE;\n\ntypedef struct {\n\t// Limits\n\tfloat l_current_max;\n\tfloat l_current_min;\n\tfloat l_in_current_max;\n\tfloat l_in_current_min;\n\tfloat l_in_current_map_start;\n\tfloat l_in_current_map_filter;\n\tfloat l_abs_current_max;\n\tfloat l_min_erpm;\n\tfloat l_max_erpm;\n\tfloat l_erpm_start;\n\tfloat l_max_erpm_fbrake;\n\tfloat l_max_erpm_fbrake_cc;\n\tfloat l_min_vin;\n\tfloat l_max_vin;\n\tfloat l_battery_cut_start;\n\tfloat l_battery_cut_end;\n\tfloat l_battery_regen_cut_start;\n\tfloat l_battery_regen_cut_end;\n\tbool l_slow_abs_current;\n\tfloat l_temp_fet_start;\n\tfloat l_temp_fet_end;\n\tfloat l_temp_motor_start;\n\tfloat l_temp_motor_end;\n\tfloat l_temp_accel_dec;\n\tfloat l_min_duty;\n\tfloat l_max_duty;\n\tfloat l_watt_max;\n\tfloat l_watt_min;\n\tfloat l_current_max_scale;\n\tfloat l_current_min_scale;\n\tfloat l_duty_start;\n\t// Overridden limits (Computed during runtime)\n\tfloat lo_current_max;\n\tfloat lo_current_min;\n\tfloat lo_in_current_max;\n\tfloat lo_in_current_min;\n\n\t// BLDC switching and drive\n\tmc_pwm_mode pwm_mode;\n\tmc_comm_mode comm_mode;\n\tmc_motor_type motor_type;\n\tmc_sensor_mode sensor_mode;\n\n\t// Sensorless (bldc)\n\tfloat sl_min_erpm;\n\tfloat sl_min_erpm_cycle_int_limit;\n\tfloat sl_max_fullbreak_current_dir_change;\n\tfloat sl_cycle_int_limit;\n\tfloat sl_phase_advance_at_br;\n\tfloat sl_cycle_int_rpm_br;\n\tfloat sl_bemf_coupling_k;\n\t// Hall sensor\n\tint8_t hall_table[8];\n\tfloat hall_sl_erpm;\n\n\t// FOC\n\tfloat foc_current_kp;\n\tfloat foc_current_ki;\n\tfloat foc_f_zv;\n\tfloat foc_dt_us;\n\tfloat foc_encoder_offset;\n\tbool foc_encoder_inverted;\n\tfloat foc_encoder_ratio;\n\tfloat foc_motor_l;\n\tfloat foc_motor_ld_lq_diff;\n\tfloat foc_motor_r;\n\tfloat foc_motor_flux_linkage;\n\tfloat foc_observer_gain;\n\tfloat foc_observer_gain_slow;\n\tfloat foc_observer_offset;\n\tfloat foc_pll_kp;\n\tfloat foc_pll_ki;\n\tfloat foc_duty_dowmramp_kp;\n\tfloat foc_duty_dowmramp_ki;\n\tfloat foc_start_curr_dec;\n\tfloat foc_start_curr_dec_rpm;\n\tfloat foc_openloop_rpm;\n\tfloat foc_openloop_rpm_low;\n\tfloat foc_d_gain_scale_start;\n\tfloat foc_d_gain_scale_max_mod;\n\tfloat foc_sl_openloop_hyst;\n\tfloat foc_sl_openloop_time;\n\tfloat foc_sl_openloop_time_lock;\n\tfloat foc_sl_openloop_time_ramp;\n\tfloat foc_sl_openloop_boost_q;\n\tfloat foc_sl_openloop_max_q;\n\tmc_foc_sensor_mode foc_sensor_mode;\n\tuint8_t foc_hall_table[8];\n\tfloat foc_hall_interp_erpm;\n\tfloat foc_sl_erpm_start;\n\tfloat foc_sl_erpm;\n\tmc_foc_control_sample_mode foc_control_sample_mode;\n\tmc_foc_current_sample_mode foc_current_sample_mode;\n\tSAT_COMP_MODE foc_sat_comp_mode;\n\tfloat foc_sat_comp;\n\tbool foc_temp_comp;\n\tfloat foc_temp_comp_base_temp;\n\tfloat foc_current_filter_const;\n\tmc_foc_cc_decoupling_mode foc_cc_decoupling;\n\tmc_foc_observer_type foc_observer_type;\n\tmc_foc_hfi_amb_mode foc_hfi_amb_mode;\n\tfloat foc_hfi_amb_current;\n\tuint8_t foc_hfi_amb_tres;\n\tfloat foc_hfi_voltage_start;\n\tfloat foc_hfi_voltage_run;\n\tfloat foc_hfi_voltage_max;\n\tfloat foc_hfi_gain;\n\tfloat foc_hfi_max_err;\n\tfloat foc_hfi_hyst;\n\tfloat foc_sl_erpm_hfi;\n\tuint16_t foc_hfi_start_samples;\n\tfloat foc_hfi_obs_ovr_sec;\n\tfoc_hfi_samples foc_hfi_samples;\n\tuint8_t foc_offsets_cal_mode;\n\tfloat foc_offsets_current[3];\n\tfloat foc_offsets_voltage[3];\n\tfloat foc_offsets_voltage_undriven[3];\n\tbool foc_phase_filter_enable;\n\tbool foc_phase_filter_disable_fault;\n\tfloat foc_phase_filter_max_erpm;\n\tMTPA_MODE foc_mtpa_mode;\n\t// Field Weakening\n\tfloat foc_fw_current_max;\n\tfloat foc_fw_duty_start;\n\tfloat foc_fw_ramp_time;\n\tfloat foc_fw_q_current_factor;\n\tFOC_SPEED_SRC foc_speed_soure;\n\tbool foc_short_ls_on_zero_duty;\n\n\tPID_RATE sp_pid_loop_rate;\n\n\t// Speed PID\n\tfloat s_pid_kp;\n\tfloat s_pid_ki;\n\tfloat s_pid_kd;\n\tfloat s_pid_kd_filter;\n\tfloat s_pid_min_erpm;\n\tbool s_pid_allow_braking;\n\tfloat s_pid_ramp_erpms_s;\n\tS_PID_SPEED_SRC s_pid_speed_source;\n\n\t// Pos PID\n\tfloat p_pid_kp;\n\tfloat p_pid_ki;\n\tfloat p_pid_kd;\n\tfloat p_pid_kd_proc;\n\tfloat p_pid_kd_filter;\n\tfloat p_pid_ang_div;\n\tfloat p_pid_gain_dec_angle;\n\tfloat p_pid_offset;\n\n\t// Current controller\n\tfloat cc_startup_boost_duty;\n\tfloat cc_min_current;\n\tfloat cc_gain;\n\tfloat cc_ramp_step_max;\n\n\t// Misc\n\tint32_t m_fault_stop_time_ms;\n\tfloat m_duty_ramp_step;\n\tfloat m_current_backoff_gain;\n\tuint32_t m_encoder_counts;\n\tfloat m_encoder_sin_offset;\n\tfloat m_encoder_sin_amp;\n\tfloat m_encoder_cos_offset;\n\tfloat m_encoder_cos_amp;\n\tfloat m_encoder_sincos_filter_constant;\n\tfloat m_encoder_sincos_phase_correction;\n\tsensor_port_mode m_sensor_port_mode;\n\tbool m_invert_direction;\n\tdrv8301_oc_mode m_drv8301_oc_mode;\n\tint m_drv8301_oc_adj;\n\tfloat m_bldc_f_sw_min;\n\tfloat m_bldc_f_sw_max;\n\tfloat m_dc_f_sw;\n\tfloat m_ntc_motor_beta;\n\tout_aux_mode m_out_aux_mode;\n\ttemp_sensor_type m_motor_temp_sens_type;\n\tfloat m_ptc_motor_coeff;\n\tint m_hall_extra_samples;\n\tint m_batt_filter_const;\n\tfloat m_ntcx_ptcx_temp_base;\n\tfloat m_ntcx_ptcx_res;\n\t// Setup info\n\tuint8_t si_motor_poles;\n\tfloat si_gear_ratio;\n\tfloat si_wheel_diameter;\n\tBATTERY_TYPE si_battery_type;\n\tint si_battery_cells;\n\tfloat si_battery_ah;\n\tfloat si_motor_nl_current;\n\n\t// BMS Configuration\n\tbms_config bms;\n\n\t// Protect from flash corruption.\n\tuint16_t crc;\n} mc_configuration;\n\n// Applications to use\ntypedef enum {\n\tAPP_NONE = 0,\n\tAPP_PPM,\n\tAPP_ADC,\n\tAPP_UART,\n\tAPP_PPM_UART,\n\tAPP_ADC_UART,\n\tAPP_NUNCHUK,\n\tAPP_NRF,\n\tAPP_CUSTOM,\n\tAPP_PAS,\n\tAPP_ADC_PAS\n} app_use;\n\n// Throttle curve mode\ntypedef enum {\n\tTHR_EXP_EXPO = 0,\n\tTHR_EXP_NATURAL,\n\tTHR_EXP_POLY\n} thr_exp_mode;\n\ntypedef enum {\n\tSAFE_START_DISABLED = 0,\n\tSAFE_START_REGULAR,\n\tSAFE_START_NO_FAULT\n} SAFE_START_MODE;\n\n// PPM control types\ntypedef enum {\n\tPPM_CTRL_TYPE_NONE = 0,\n\tPPM_CTRL_TYPE_CURRENT,\n\tPPM_CTRL_TYPE_CURRENT_NOREV,\n\tPPM_CTRL_TYPE_CURRENT_NOREV_BRAKE,\n\tPPM_CTRL_TYPE_DUTY,\n\tPPM_CTRL_TYPE_DUTY_NOREV,\n\tPPM_CTRL_TYPE_PID,\n\tPPM_CTRL_TYPE_PID_NOREV,\n\tPPM_CTRL_TYPE_CURRENT_BRAKE_REV_HYST,\n\tPPM_CTRL_TYPE_CURRENT_SMART_REV,\n\tPPM_CTRL_TYPE_PID_POSITION_180,\n\tPPM_CTRL_TYPE_PID_POSITION_360,\n} ppm_control_type;\n\ntypedef struct {\n\tppm_control_type ctrl_type;\n\tfloat pid_max_erpm;\n\tfloat hyst;\n\tfloat pulse_start;\n\tfloat pulse_end;\n\tfloat pulse_center;\n\tbool median_filter;\n\tSAFE_START_MODE safe_start;\n\tfloat throttle_exp;\n\tfloat throttle_exp_brake;\n\tthr_exp_mode throttle_exp_mode;\n\tfloat ramp_time_pos;\n\tfloat ramp_time_neg;\n\tbool multi_esc;\n\tbool tc;\n\tfloat tc_max_diff;\n\tfloat max_erpm_for_dir;\n\tfloat smart_rev_max_duty;\n\tfloat smart_rev_ramp_time;\n} ppm_config;\n\n// ADC control types\ntypedef enum {\n\tADC_CTRL_TYPE_NONE = 0,\n\tADC_CTRL_TYPE_CURRENT,\n\tADC_CTRL_TYPE_CURRENT_REV_CENTER,\n\tADC_CTRL_TYPE_CURRENT_REV_BUTTON,\n\tADC_CTRL_TYPE_CURRENT_REV_BUTTON_BRAKE_ADC,\n\tADC_CTRL_TYPE_CURRENT_REV_BUTTON_BRAKE_CENTER,\n\tADC_CTRL_TYPE_CURRENT_NOREV_BRAKE_CENTER,\n\tADC_CTRL_TYPE_CURRENT_NOREV_BRAKE_BUTTON,\n\tADC_CTRL_TYPE_CURRENT_NOREV_BRAKE_ADC,\n\tADC_CTRL_TYPE_DUTY,\n\tADC_CTRL_TYPE_DUTY_REV_CENTER,\n\tADC_CTRL_TYPE_DUTY_REV_BUTTON,\n\tADC_CTRL_TYPE_PID,\n\tADC_CTRL_TYPE_PID_REV_CENTER,\n\tADC_CTRL_TYPE_PID_REV_BUTTON\n} adc_control_type;\n\n// PAS control types\ntypedef enum {\n\tPAS_CTRL_TYPE_NONE = 0,\n\tPAS_CTRL_TYPE_CADENCE,\n\tPAS_CTRL_TYPE_TORQUE,\n\tPAS_CTRL_TYPE_TORQUE_WITH_CADENCE_TIMEOUT\n} pas_control_type;\n\n// PAS sensor types\ntypedef enum {\n\tPAS_SENSOR_TYPE_QUADRATURE = 0\n} pas_sensor_type;\n\ntypedef struct {\n\tadc_control_type ctrl_type;\n\tfloat hyst;\n\tfloat voltage_start;\n\tfloat voltage_end;\n\tfloat voltage_min;\n\tfloat voltage_max;\n\tfloat voltage_center;\n\tfloat voltage2_start;\n\tfloat voltage2_end;\n\tbool use_filter;\n\tSAFE_START_MODE safe_start;\n\tuint8_t buttons;\n\tbool voltage_inverted;\n\tbool voltage2_inverted;\n\tfloat throttle_exp;\n\tfloat throttle_exp_brake;\n\tthr_exp_mode throttle_exp_mode;\n\tfloat ramp_time_pos;\n\tfloat ramp_time_neg;\n\tbool multi_esc;\n\tbool tc;\n\tfloat tc_max_diff;\n\tuint32_t update_rate_hz;\n} adc_config;\n\n// Nunchuk control types\ntypedef enum {\n\tCHUK_CTRL_TYPE_NONE = 0,\n\tCHUK_CTRL_TYPE_CURRENT,\n\tCHUK_CTRL_TYPE_CURRENT_NOREV,\n\tCHUK_CTRL_TYPE_CURRENT_BIDIRECTIONAL\n} chuk_control_type;\n\ntypedef struct {\n\tchuk_control_type ctrl_type;\n\tfloat hyst;\n\tfloat ramp_time_pos;\n\tfloat ramp_time_neg;\n\tfloat stick_erpm_per_s_in_cc;\n\tfloat throttle_exp;\n\tfloat throttle_exp_brake;\n\tthr_exp_mode throttle_exp_mode;\n\tbool multi_esc;\n\tbool tc;\n\tfloat tc_max_diff;\n\tbool use_smart_rev;\n\tfloat smart_rev_max_duty;\n\tfloat smart_rev_ramp_time;\n} chuk_config;\n\ntypedef struct {\n\tpas_control_type ctrl_type;\n\tpas_sensor_type sensor_type;\n\tfloat current_scaling;\n\tfloat pedal_rpm_start;\n\tfloat pedal_rpm_end;\n\tbool invert_pedal_direction;\n\tuint8_t magnets;\n\tbool use_filter;\n\tfloat ramp_time_pos;\n\tfloat ramp_time_neg;\n\tuint32_t update_rate_hz;\n} pas_config;\n\n// NRF Datatypes\ntypedef enum {\n\tNRF_SPEED_250K = 0,\n\tNRF_SPEED_1M,\n\tNRF_SPEED_2M\n} NRF_SPEED;\n\ntypedef enum {\n\tNRF_POWER_M18DBM = 0,\n\tNRF_POWER_M12DBM,\n\tNRF_POWER_M6DBM,\n\tNRF_POWER_0DBM,\n  NRF_POWER_OFF\n} NRF_POWER;\n\ntypedef enum {\n\tNRF_AW_3 = 0,\n\tNRF_AW_4,\n\tNRF_AW_5\n} NRF_AW;\n\ntypedef enum {\n\tNRF_CRC_DISABLED = 0,\n\tNRF_CRC_1B,\n\tNRF_CRC_2B\n} NRF_CRC;\n\ntypedef enum {\n\tNRF_RETR_DELAY_250US = 0,\n\tNRF_RETR_DELAY_500US,\n\tNRF_RETR_DELAY_750US,\n\tNRF_RETR_DELAY_1000US,\n\tNRF_RETR_DELAY_1250US,\n\tNRF_RETR_DELAY_1500US,\n\tNRF_RETR_DELAY_1750US,\n\tNRF_RETR_DELAY_2000US,\n\tNRF_RETR_DELAY_2250US,\n\tNRF_RETR_DELAY_2500US,\n\tNRF_RETR_DELAY_2750US,\n\tNRF_RETR_DELAY_3000US,\n\tNRF_RETR_DELAY_3250US,\n\tNRF_RETR_DELAY_3500US,\n\tNRF_RETR_DELAY_3750US,\n\tNRF_RETR_DELAY_4000US\n} NRF_RETR_DELAY;\n\ntypedef struct {\n\tNRF_SPEED speed;\n\tNRF_POWER power;\n\tNRF_CRC crc_type;\n\tNRF_RETR_DELAY retry_delay;\n\tunsigned char retries;\n\tunsigned char channel;\n\tunsigned char address[3];\n\tbool send_crc_ack;\n} nrf_config;\n\ntypedef enum {\n\tSHUTDOWN_MODE_ALWAYS_OFF = 0,\n\tSHUTDOWN_MODE_ALWAYS_ON,\n\tSHUTDOWN_MODE_TOGGLE_BUTTON_ONLY,\n\tSHUTDOWN_MODE_OFF_AFTER_10S,\n\tSHUTDOWN_MODE_OFF_AFTER_1M,\n\tSHUTDOWN_MODE_OFF_AFTER_5M,\n\tSHUTDOWN_MODE_OFF_AFTER_10M,\n\tSHUTDOWN_MODE_OFF_AFTER_30M,\n\tSHUTDOWN_MODE_OFF_AFTER_1H,\n\tSHUTDOWN_MODE_OFF_AFTER_5H,\n} SHUTDOWN_MODE;\n\ntypedef enum {\n\tIMU_TYPE_OFF = 0,\n\tIMU_TYPE_INTERNAL,\n\tIMU_TYPE_EXTERNAL_MPU9X50,\n\tIMU_TYPE_EXTERNAL_ICM20948,\n\tIMU_TYPE_EXTERNAL_BMI160,\n\tIMU_TYPE_EXTERNAL_LSM6DS3\n} IMU_TYPE;\n\ntypedef enum {\n\tAHRS_MODE_MADGWICK = 0,\n\tAHRS_MODE_MAHONY,\n\tAHRS_MODE_MADGWICK_FUSION\n} AHRS_MODE;\n\ntypedef enum {\n\tIMU_FILTER_LOW = 0,\n\tIMU_FILTER_MEDIUM,\n\tIMU_FILTER_HIGH\n} IMU_FILTER;\n\ntypedef struct {\n\tIMU_TYPE type;\n\tAHRS_MODE mode;\n\tIMU_FILTER filter;\n\tfloat accel_lowpass_filter_x;\n\tfloat accel_lowpass_filter_y;\n\tfloat accel_lowpass_filter_z;\n\tfloat gyro_lowpass_filter;\n\tint sample_rate_hz;\n\tbool use_magnetometer;\n\tfloat accel_confidence_decay;\n\tfloat mahony_kp;\n\tfloat mahony_ki;\n\tfloat madgwick_beta;\n\tfloat rot_roll;\n\tfloat rot_pitch;\n\tfloat rot_yaw;\n\tfloat accel_offsets[3];\n\tfloat gyro_offsets[3];\n} imu_config;\n\ntypedef enum {\n\tCAN_MODE_VESC = 0,\n\tCAN_MODE_UAVCAN,\n\tCAN_MODE_COMM_BRIDGE,\n\tCAN_MODE_UNUSED,\n} CAN_MODE;\n\ntypedef enum {\n\tUAVCAN_RAW_MODE_CURRENT = 0,\n\tUAVCAN_RAW_MODE_CURRENT_NO_REV_BRAKE,\n\tUAVCAN_RAW_MODE_DUTY,\n\tUAVCAN_RAW_MODE_RPM\n} UAVCAN_RAW_MODE;\n\ntypedef enum {\n\tUAVCAN_STATUS_CURRENT_MODE_MOTOR = 0,\n\tUAVCAN_STATUS_CURRENT_MODE_INPUT\n} UAVCAN_STATUS_CURRENT_MODE;\n\ntypedef enum {\n\tKILL_SW_MODE_DISABLED = 0,\n\tKILL_SW_MODE_PPM_LOW,\n\tKILL_SW_MODE_PPM_HIGH,\n\tKILL_SW_MODE_ADC2_LOW,\n\tKILL_SW_MODE_ADC2_HIGH\n} KILL_SW_MODE;\n\ntypedef struct {\n\t// Settings\n\tuint8_t controller_id;\n\tuint32_t timeout_msec;\n\tfloat timeout_brake_current;\n\tuint32_t can_status_rate_1;\n\tuint8_t can_status_msgs_r1;\n\tuint32_t can_status_rate_2;\n\tuint8_t can_status_msgs_r2;\n\tCAN_BAUD can_baud_rate;\n\tbool pairing_done;\n\tbool permanent_uart_enabled;\n\tSHUTDOWN_MODE shutdown_mode;\n\tbool servo_out_enable;\n\tKILL_SW_MODE kill_sw_mode;\n\n\t// CAN modes\n\tCAN_MODE can_mode;\n\tuint8_t uavcan_esc_index;\n\tUAVCAN_RAW_MODE uavcan_raw_mode;\n\tfloat uavcan_raw_rpm_max;\n\tUAVCAN_STATUS_CURRENT_MODE uavcan_status_current_mode;\n\n\t// Application to use\n\tapp_use app_to_use;\n\n\t// PPM application settings\n\tppm_config app_ppm_conf;\n\n\t// ADC application settings\n\tadc_config app_adc_conf;\n\n\t// UART application settings\n\tuint32_t app_uart_baudrate;\n\n\t// Nunchuk application settings\n\tchuk_config app_chuk_conf;\n\n\t// NRF application settings\n\tnrf_config app_nrf_conf;\n\n\t// Pedal Assist application settings\n\tpas_config app_pas_conf;\n\n\t// IMU Settings\n\timu_config imu_conf;\n\n\t// Protect from flash corruption\n\tuint16_t crc;\n} app_configuration;\n\n// Communication commands\ntypedef enum {\n\tCOMM_FW_VERSION\t\t\t\t\t\t\t= 0,\n\tCOMM_JUMP_TO_BOOTLOADER\t\t\t\t\t= 1,\n\tCOMM_ERASE_NEW_APP\t\t\t\t\t\t= 2,\n\tCOMM_WRITE_NEW_APP_DATA\t\t\t\t\t= 3,\n\tCOMM_GET_VALUES\t\t\t\t\t\t\t= 4,\n\tCOMM_SET_DUTY\t\t\t\t\t\t\t= 5,\n\tCOMM_SET_CURRENT\t\t\t\t\t\t= 6,\n\tCOMM_SET_CURRENT_BRAKE\t\t\t\t\t= 7,\n\tCOMM_SET_RPM\t\t\t\t\t\t\t= 8,\n\tCOMM_SET_POS\t\t\t\t\t\t\t= 9,\n\tCOMM_SET_HANDBRAKE\t\t\t\t\t\t= 10,\n\tCOMM_SET_DETECT\t\t\t\t\t\t\t= 11,\n\tCOMM_SET_SERVO_POS\t\t\t\t\t\t= 12,\n\tCOMM_SET_MCCONF\t\t\t\t\t\t\t= 13,\n\tCOMM_GET_MCCONF\t\t\t\t\t\t\t= 14,\n\tCOMM_GET_MCCONF_DEFAULT\t\t\t\t\t= 15,\n\tCOMM_SET_APPCONF\t\t\t\t\t\t= 16,\n\tCOMM_GET_APPCONF\t\t\t\t\t\t= 17,\n\tCOMM_GET_APPCONF_DEFAULT\t\t\t\t= 18,\n\tCOMM_SAMPLE_PRINT\t\t\t\t\t\t= 19,\n\tCOMM_TERMINAL_CMD\t\t\t\t\t\t= 20,\n\tCOMM_PRINT\t\t\t\t\t\t\t\t= 21,\n\tCOMM_ROTOR_POSITION\t\t\t\t\t\t= 22,\n\tCOMM_EXPERIMENT_SAMPLE\t\t\t\t\t= 23,\n\tCOMM_DETECT_MOTOR_PARAM\t\t\t\t\t= 24,\n\tCOMM_DETECT_MOTOR_R_L\t\t\t\t\t= 25,\n\tCOMM_DETECT_MOTOR_FLUX_LINKAGE\t\t\t= 26,\n\tCOMM_DETECT_ENCODER\t\t\t\t\t\t= 27,\n\tCOMM_DETECT_HALL_FOC\t\t\t\t\t= 28,\n\tCOMM_REBOOT\t\t\t\t\t\t\t\t= 29,\n\tCOMM_ALIVE\t\t\t\t\t\t\t\t= 30,\n\tCOMM_GET_DECODED_PPM\t\t\t\t\t= 31,\n\tCOMM_GET_DECODED_ADC\t\t\t\t\t= 32,\n\tCOMM_GET_DECODED_CHUK\t\t\t\t\t= 33,\n\tCOMM_FORWARD_CAN\t\t\t\t\t\t= 34,\n\tCOMM_SET_CHUCK_DATA\t\t\t\t\t\t= 35,\n\tCOMM_CUSTOM_APP_DATA\t\t\t\t\t= 36,\n\tCOMM_NRF_START_PAIRING\t\t\t\t\t= 37,\n\tCOMM_GPD_SET_FSW\t\t\t\t\t\t= 38,\n\tCOMM_GPD_BUFFER_NOTIFY\t\t\t\t\t= 39,\n\tCOMM_GPD_BUFFER_SIZE_LEFT\t\t\t\t= 40,\n\tCOMM_GPD_FILL_BUFFER\t\t\t\t\t= 41,\n\tCOMM_GPD_OUTPUT_SAMPLE\t\t\t\t\t= 42,\n\tCOMM_GPD_SET_MODE\t\t\t\t\t\t= 43,\n\tCOMM_GPD_FILL_BUFFER_INT8\t\t\t\t= 44,\n\tCOMM_GPD_FILL_BUFFER_INT16\t\t\t\t= 45,\n\tCOMM_GPD_SET_BUFFER_INT_SCALE\t\t\t= 46,\n\tCOMM_GET_VALUES_SETUP\t\t\t\t\t= 47,\n\tCOMM_SET_MCCONF_TEMP\t\t\t\t\t= 48,\n\tCOMM_SET_MCCONF_TEMP_SETUP\t\t\t\t= 49,\n\tCOMM_GET_VALUES_SELECTIVE\t\t\t\t= 50,\n\tCOMM_GET_VALUES_SETUP_SELECTIVE\t\t\t= 51,\n\tCOMM_EXT_NRF_PRESENT\t\t\t\t\t= 52,\n\tCOMM_EXT_NRF_ESB_SET_CH_ADDR\t\t\t= 53,\n\tCOMM_EXT_NRF_ESB_SEND_DATA\t\t\t\t= 54,\n\tCOMM_EXT_NRF_ESB_RX_DATA\t\t\t\t= 55,\n\tCOMM_EXT_NRF_SET_ENABLED\t\t\t\t= 56,\n\tCOMM_DETECT_MOTOR_FLUX_LINKAGE_OPENLOOP\t= 57,\n\tCOMM_DETECT_APPLY_ALL_FOC\t\t\t\t= 58,\n\tCOMM_JUMP_TO_BOOTLOADER_ALL_CAN\t\t\t= 59,\n\tCOMM_ERASE_NEW_APP_ALL_CAN\t\t\t\t= 60,\n\tCOMM_WRITE_NEW_APP_DATA_ALL_CAN\t\t\t= 61,\n\tCOMM_PING_CAN\t\t\t\t\t\t\t= 62,\n\tCOMM_APP_DISABLE_OUTPUT\t\t\t\t\t= 63,\n\tCOMM_TERMINAL_CMD_SYNC\t\t\t\t\t= 64,\n\tCOMM_GET_IMU_DATA\t\t\t\t\t\t= 65,\n\tCOMM_BM_CONNECT\t\t\t\t\t\t\t= 66,\n\tCOMM_BM_ERASE_FLASH_ALL\t\t\t\t\t= 67,\n\tCOMM_BM_WRITE_FLASH\t\t\t\t\t\t= 68,\n\tCOMM_BM_REBOOT\t\t\t\t\t\t\t= 69,\n\tCOMM_BM_DISCONNECT\t\t\t\t\t\t= 70,\n\tCOMM_BM_MAP_PINS_DEFAULT\t\t\t\t= 71,\n\tCOMM_BM_MAP_PINS_NRF5X\t\t\t\t\t= 72,\n\tCOMM_ERASE_BOOTLOADER\t\t\t\t\t= 73,\n\tCOMM_ERASE_BOOTLOADER_ALL_CAN\t\t\t= 74,\n\tCOMM_PLOT_INIT\t\t\t\t\t\t\t= 75,\n\tCOMM_PLOT_DATA\t\t\t\t\t\t\t= 76,\n\tCOMM_PLOT_ADD_GRAPH\t\t\t\t\t\t= 77,\n\tCOMM_PLOT_SET_GRAPH\t\t\t\t\t\t= 78,\n\tCOMM_GET_DECODED_BALANCE\t\t\t\t= 79,\n\tCOMM_BM_MEM_READ\t\t\t\t\t\t= 80,\n\tCOMM_WRITE_NEW_APP_DATA_LZO\t\t\t\t= 81,\n\tCOMM_WRITE_NEW_APP_DATA_ALL_CAN_LZO\t\t= 82,\n\tCOMM_BM_WRITE_FLASH_LZO\t\t\t\t\t= 83,\n\tCOMM_SET_CURRENT_REL\t\t\t\t\t= 84,\n\tCOMM_CAN_FWD_FRAME\t\t\t\t\t\t= 85,\n\tCOMM_SET_BATTERY_CUT\t\t\t\t\t= 86,\n\tCOMM_SET_BLE_NAME\t\t\t\t\t\t= 87,\n\tCOMM_SET_BLE_PIN\t\t\t\t\t\t= 88,\n\tCOMM_SET_CAN_MODE\t\t\t\t\t\t= 89,\n\tCOMM_GET_IMU_CALIBRATION\t\t\t\t= 90,\n\tCOMM_GET_MCCONF_TEMP\t\t\t\t\t= 91,\n\n\t// Custom configuration for hardware\n\tCOMM_GET_CUSTOM_CONFIG_XML\t\t\t\t= 92,\n\tCOMM_GET_CUSTOM_CONFIG\t\t\t\t\t= 93,\n\tCOMM_GET_CUSTOM_CONFIG_DEFAULT\t\t\t= 94,\n\tCOMM_SET_CUSTOM_CONFIG\t\t\t\t\t= 95,\n\n\t// BMS commands\n\tCOMM_BMS_GET_VALUES\t\t\t\t\t\t= 96,\n\tCOMM_BMS_SET_CHARGE_ALLOWED\t\t\t\t= 97,\n\tCOMM_BMS_SET_BALANCE_OVERRIDE\t\t\t= 98,\n\tCOMM_BMS_RESET_COUNTERS\t\t\t\t\t= 99,\n\tCOMM_BMS_FORCE_BALANCE\t\t\t\t\t= 100,\n\tCOMM_BMS_ZERO_CURRENT_OFFSET\t\t\t= 101,\n\n\t// FW updates commands for different HW types\n\tCOMM_JUMP_TO_BOOTLOADER_HW\t\t\t\t= 102,\n\tCOMM_ERASE_NEW_APP_HW\t\t\t\t\t= 103,\n\tCOMM_WRITE_NEW_APP_DATA_HW\t\t\t\t= 104,\n\tCOMM_ERASE_BOOTLOADER_HW\t\t\t\t= 105,\n\tCOMM_JUMP_TO_BOOTLOADER_ALL_CAN_HW\t\t= 106,\n\tCOMM_ERASE_NEW_APP_ALL_CAN_HW\t\t\t= 107,\n\tCOMM_WRITE_NEW_APP_DATA_ALL_CAN_HW\t\t= 108,\n\tCOMM_ERASE_BOOTLOADER_ALL_CAN_HW\t\t= 109,\n\n\tCOMM_SET_ODOMETER\t\t\t\t\t\t= 110,\n\n\t// Power switch commands\n\tCOMM_PSW_GET_STATUS\t\t\t\t\t\t= 111,\n\tCOMM_PSW_SWITCH\t\t\t\t\t\t\t= 112,\n\n\tCOMM_BMS_FWD_CAN_RX\t\t\t\t\t\t= 113,\n\tCOMM_BMS_HW_DATA\t\t\t\t\t\t= 114,\n\tCOMM_GET_BATTERY_CUT\t\t\t\t\t= 115,\n\tCOMM_BM_HALT_REQ\t\t\t\t\t\t= 116,\n\tCOMM_GET_QML_UI_HW\t\t\t\t\t\t= 117,\n\tCOMM_GET_QML_UI_APP\t\t\t\t\t\t= 118,\n\tCOMM_CUSTOM_HW_DATA\t\t\t\t\t\t= 119,\n\tCOMM_QMLUI_ERASE\t\t\t\t\t\t= 120,\n\tCOMM_QMLUI_WRITE\t\t\t\t\t\t= 121,\n\n\t// IO Board\n\tCOMM_IO_BOARD_GET_ALL\t\t\t\t\t= 122,\n\tCOMM_IO_BOARD_SET_PWM\t\t\t\t\t= 123,\n\tCOMM_IO_BOARD_SET_DIGITAL\t\t\t\t= 124,\n\n\tCOMM_BM_MEM_WRITE\t\t\t\t\t\t= 125,\n\tCOMM_BMS_BLNC_SELFTEST\t\t\t\t\t= 126,\n\tCOMM_GET_EXT_HUM_TMP\t\t\t\t\t= 127,\n\tCOMM_GET_STATS\t\t\t\t\t\t\t= 128,\n\tCOMM_RESET_STATS\t\t\t\t\t\t= 129,\n\n\t// Lisp\n\tCOMM_LISP_READ_CODE\t\t\t\t\t\t= 130,\n\tCOMM_LISP_WRITE_CODE\t\t\t\t\t= 131,\n\tCOMM_LISP_ERASE_CODE\t\t\t\t\t= 132,\n\tCOMM_LISP_SET_RUNNING\t\t\t\t\t= 133,\n\tCOMM_LISP_GET_STATS\t\t\t\t\t\t= 134,\n\tCOMM_LISP_PRINT\t\t\t\t\t\t\t= 135,\n\n\tCOMM_BMS_SET_BATT_TYPE\t\t\t\t\t= 136,\n\tCOMM_BMS_GET_BATT_TYPE\t\t\t\t\t= 137,\n\n\tCOMM_LISP_REPL_CMD\t\t\t\t\t\t= 138,\n\tCOMM_LISP_STREAM_CODE\t\t\t\t\t= 139,\n\n\tCOMM_FILE_LIST\t\t\t\t\t\t\t= 140,\n\tCOMM_FILE_READ\t\t\t\t\t\t\t= 141,\n\tCOMM_FILE_WRITE\t\t\t\t\t\t\t= 142,\n\tCOMM_FILE_MKDIR\t\t\t\t\t\t\t= 143,\n\tCOMM_FILE_REMOVE\t\t\t\t\t\t= 144,\n\n\tCOMM_LOG_START\t\t\t\t\t\t\t= 145,\n\tCOMM_LOG_STOP\t\t\t\t\t\t\t= 146,\n\tCOMM_LOG_CONFIG_FIELD\t\t\t\t\t= 147,\n\tCOMM_LOG_DATA_F32\t\t\t\t\t\t= 148,\n\n\tCOMM_SET_APPCONF_NO_STORE\t\t\t\t= 149,\n\tCOMM_GET_GNSS\t\t\t\t\t\t\t= 150,\n\n\tCOMM_LOG_DATA_F64\t\t\t\t\t\t= 151,\n\n\tCOMM_LISP_RMSG\t\t\t\t\t\t\t= 152,\n\n\t//Placeholders for pinlock commands\n\t//COMM_PINLOCK1\t\t\t\t\t\t\t= 153,\n\t//COMM_PINLOCK2\t\t\t\t\t\t\t= 154,\n\t//COMM_PINLOCK3\t\t\t\t\t\t\t= 155,\n\n\tCOMM_SHUTDOWN\t\t\t\t\t\t\t= 156,\n\t\n\tCOMM_FW_INFO\t\t\t\t\t\t\t= 157,\n} COMM_PACKET_ID;\n\n// CAN commands\ntypedef enum {\n\tCAN_PACKET_SET_DUTY\t\t\t\t\t\t= 0,\n\tCAN_PACKET_SET_CURRENT\t\t\t\t\t= 1,\n\tCAN_PACKET_SET_CURRENT_BRAKE\t\t\t= 2,\n\tCAN_PACKET_SET_RPM\t\t\t\t\t\t= 3,\n\tCAN_PACKET_SET_POS\t\t\t\t\t\t= 4,\n\tCAN_PACKET_FILL_RX_BUFFER\t\t\t\t= 5,\n\tCAN_PACKET_FILL_RX_BUFFER_LONG\t\t\t= 6,\n\tCAN_PACKET_PROCESS_RX_BUFFER\t\t\t= 7,\n\tCAN_PACKET_PROCESS_SHORT_BUFFER\t\t\t= 8,\n\tCAN_PACKET_STATUS\t\t\t\t\t\t= 9,\n\tCAN_PACKET_SET_CURRENT_REL\t\t\t\t= 10,\n\tCAN_PACKET_SET_CURRENT_BRAKE_REL\t\t= 11,\n\tCAN_PACKET_SET_CURRENT_HANDBRAKE\t\t= 12,\n\tCAN_PACKET_SET_CURRENT_HANDBRAKE_REL\t= 13,\n\tCAN_PACKET_STATUS_2\t\t\t\t\t\t= 14,\n\tCAN_PACKET_STATUS_3\t\t\t\t\t\t= 15,\n\tCAN_PACKET_STATUS_4\t\t\t\t\t\t= 16,\n\tCAN_PACKET_PING\t\t\t\t\t\t\t= 17,\n\tCAN_PACKET_PONG\t\t\t\t\t\t\t= 18,\n\tCAN_PACKET_DETECT_APPLY_ALL_FOC\t\t\t= 19,\n\tCAN_PACKET_DETECT_APPLY_ALL_FOC_RES\t\t= 20,\n\tCAN_PACKET_CONF_CURRENT_LIMITS\t\t\t= 21,\n\tCAN_PACKET_CONF_STORE_CURRENT_LIMITS\t= 22,\n\tCAN_PACKET_CONF_CURRENT_LIMITS_IN\t\t= 23,\n\tCAN_PACKET_CONF_STORE_CURRENT_LIMITS_IN\t= 24,\n\tCAN_PACKET_CONF_FOC_ERPMS\t\t\t\t= 25,\n\tCAN_PACKET_CONF_STORE_FOC_ERPMS\t\t\t= 26,\n\tCAN_PACKET_STATUS_5\t\t\t\t\t\t= 27,\n\tCAN_PACKET_POLL_TS5700N8501_STATUS\t\t= 28,\n\tCAN_PACKET_CONF_BATTERY_CUT\t\t\t\t= 29,\n\tCAN_PACKET_CONF_STORE_BATTERY_CUT\t\t= 30,\n\tCAN_PACKET_SHUTDOWN\t\t\t\t\t\t= 31,\n\tCAN_PACKET_IO_BOARD_ADC_1_TO_4\t\t\t= 32,\n\tCAN_PACKET_IO_BOARD_ADC_5_TO_8\t\t\t= 33,\n\tCAN_PACKET_IO_BOARD_ADC_9_TO_12\t\t\t= 34,\n\tCAN_PACKET_IO_BOARD_DIGITAL_IN\t\t\t= 35,\n\tCAN_PACKET_IO_BOARD_SET_OUTPUT_DIGITAL\t= 36,\n\tCAN_PACKET_IO_BOARD_SET_OUTPUT_PWM\t\t= 37,\n\tCAN_PACKET_BMS_V_TOT\t\t\t\t\t= 38,\n\tCAN_PACKET_BMS_I\t\t\t\t\t\t= 39,\n\tCAN_PACKET_BMS_AH_WH\t\t\t\t\t= 40,\n\tCAN_PACKET_BMS_V_CELL\t\t\t\t\t= 41,\n\tCAN_PACKET_BMS_BAL\t\t\t\t\t\t= 42,\n\tCAN_PACKET_BMS_TEMPS\t\t\t\t\t= 43,\n\tCAN_PACKET_BMS_HUM\t\t\t\t\t\t= 44,\n\tCAN_PACKET_BMS_SOC_SOH_TEMP_STAT\t\t= 45,\n\tCAN_PACKET_PSW_STAT\t\t\t\t\t\t= 46,\n\tCAN_PACKET_PSW_SWITCH\t\t\t\t\t= 47,\n\tCAN_PACKET_BMS_HW_DATA_1\t\t\t\t= 48,\n\tCAN_PACKET_BMS_HW_DATA_2\t\t\t\t= 49,\n\tCAN_PACKET_BMS_HW_DATA_3\t\t\t\t= 50,\n\tCAN_PACKET_BMS_HW_DATA_4\t\t\t\t= 51,\n\tCAN_PACKET_BMS_HW_DATA_5\t\t\t\t= 52,\n\tCAN_PACKET_BMS_AH_WH_CHG_TOTAL\t\t\t= 53,\n\tCAN_PACKET_BMS_AH_WH_DIS_TOTAL\t\t\t= 54,\n\tCAN_PACKET_UPDATE_PID_POS_OFFSET\t\t= 55,\n\tCAN_PACKET_POLL_ROTOR_POS\t\t\t\t= 56,\n\tCAN_PACKET_NOTIFY_BOOT\t\t\t\t\t= 57,\n\tCAN_PACKET_STATUS_6\t\t\t\t\t\t= 58,\n\tCAN_PACKET_GNSS_TIME\t\t\t\t\t= 59,\n\tCAN_PACKET_GNSS_LAT\t\t\t\t\t\t= 60,\n\tCAN_PACKET_GNSS_LON\t\t\t\t\t\t= 61,\n\tCAN_PACKET_GNSS_ALT_SPEED_HDOP\t\t\t= 62,\n\tCAN_PACKET_MAKE_ENUM_32_BITS = 0xFFFFFFFF,\n} CAN_PACKET_ID;\n\ntypedef struct {\n\tdouble lat;\n\tdouble lon;\n\tfloat height;\n\tfloat speed;\n\tfloat hdop;\n\tint32_t ms_today;\n\tint16_t yy;\n\tint8_t mo;\n\tint8_t dd;\n\tsystime_t last_update;\n} gnss_data;\n\n// Logged fault data\ntypedef struct {\n\tuint8_t motor;\n\tmc_fault_code fault;\n\tfloat current;\n\tfloat current_filtered;\n\tfloat voltage;\n\tfloat gate_driver_voltage;\n\tfloat duty;\n\tfloat rpm;\n\tint tacho;\n\tint cycles_running;\n\tint tim_val_samp;\n\tint tim_current_samp;\n\tint tim_top;\n\tint comm_step;\n\tfloat temperature;\n\tint drv8301_faults;\n\tconst char *info_str;\n\tint info_argn;\n\tfloat info_args[2];\n} fault_data;\n\ntypedef struct {\n\tint js_x;\n\tint js_y;\n\tint acc_x;\n\tint acc_y;\n\tint acc_z;\n\tbool bt_c;\n\tbool bt_z;\n\tbool rev_has_state;\n\tbool is_rev;\n} chuck_data;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat rpm;\n\tfloat current;\n\tfloat duty;\n} can_status_msg;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat amp_hours;\n\tfloat amp_hours_charged;\n} can_status_msg_2;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat watt_hours;\n\tfloat watt_hours_charged;\n} can_status_msg_3;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat temp_fet;\n\tfloat temp_motor;\n\tfloat current_in;\n\tfloat pid_pos_now;\n} can_status_msg_4;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat v_in;\n\tint32_t tacho_value;\n} can_status_msg_5;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat adc_1;\n\tfloat adc_2;\n\tfloat adc_3;\n\tfloat ppm;\n} can_status_msg_6;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat adc_voltages[4];\n} io_board_adc_values;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tuint64_t inputs;\n} io_board_digial_inputs;\n\ntypedef struct {\n\tint id;\n\tsystime_t rx_time;\n\tfloat v_in;\n\tfloat v_out;\n\tfloat temp;\n\tbool is_out_on;\n\tbool is_pch_on;\n\tbool is_dsc_on;\n} psw_status;\n\ntypedef struct {\n\tuint8_t js_x;\n\tuint8_t js_y;\n\tbool bt_c;\n\tbool bt_z;\n\tbool bt_push;\n\tbool rev_has_state;\n\tbool is_rev;\n\tfloat vbat;\n} mote_state;\n\ntypedef enum {\n\tMOTE_PACKET_BATT_LEVEL = 0,\n\tMOTE_PACKET_BUTTONS,\n\tMOTE_PACKET_ALIVE,\n\tMOTE_PACKET_FILL_RX_BUFFER,\n\tMOTE_PACKET_FILL_RX_BUFFER_LONG,\n\tMOTE_PACKET_PROCESS_RX_BUFFER,\n\tMOTE_PACKET_PROCESS_SHORT_BUFFER,\n\tMOTE_PACKET_PAIRING_INFO\n} MOTE_PACKET;\n\ntypedef struct {\n\tfloat v_in;\n\tfloat temp_mos;\n\tfloat temp_mos_1;\n\tfloat temp_mos_2;\n\tfloat temp_mos_3;\n\tfloat temp_motor;\n    float current_motor;\n    float current_in;\n    float id;\n    float iq;\n    float rpm;\n    float duty_now;\n    float amp_hours;\n    float amp_hours_charged;\n    float watt_hours;\n    float watt_hours_charged;\n    int tachometer;\n    int tachometer_abs;\n    float position;\n    mc_fault_code fault_code;\n    int vesc_id;\n    float vd;\n    float vq;\n} mc_values;\n\ntypedef enum {\n\tNRF_PAIR_STARTED = 0,\n\tNRF_PAIR_OK,\n\tNRF_PAIR_FAIL\n} NRF_PAIR_RES;\n\ntypedef struct {\n\tfloat q0;\n\tfloat q1;\n\tfloat q2;\n\tfloat q3;\n\tfloat integralFBx;\n\tfloat integralFBy;\n\tfloat integralFBz;\n\tfloat accMagP;\n\tint initialUpdateDone;\n\n\t// Parameters\n\tfloat acc_confidence_decay;\n\tfloat kp;\n\tfloat ki;\n\tfloat beta;\n} ATTITUDE_INFO;\n\n// Custom EEPROM variables\ntypedef union {\n\tuint32_t as_u32;\n\tint32_t as_i32;\n\tfloat as_float;\n} eeprom_var;\n\n#define EEPROM_VARS_HW\t\t\t32\n#define EEPROM_VARS_CUSTOM\t\t256\n\ntypedef struct {\n\tfloat ah_tot;\n\tfloat ah_charge_tot;\n\tfloat wh_tot;\n\tfloat wh_charge_tot;\n\tfloat current_tot;\n\tfloat current_in_tot;\n\tuint8_t num_vescs;\n} setup_values;\n\ntypedef struct {\n\tsystime_t time_start;\n\tdouble samples;\n\tdouble speed_sum;\n\tfloat max_speed;\n\tdouble power_sum;\n\tfloat max_power;\n\tdouble temp_motor_sum;\n\tfloat max_temp_motor;\n\tdouble temp_mos_sum;\n\tfloat max_temp_mos;\n\tdouble current_sum;\n\tfloat max_current;\n} setup_stats;\n\n#define BACKUP_VAR_INIT_CODE\t\t\t\t92891934\n\ntypedef struct __attribute__((packed)) {\n\tuint32_t odometer_init_flag;\n\tuint64_t odometer; // Meters\n\n\tuint32_t runtime_init_flag;\n\tuint64_t runtime; // Seconds\n\n\t// HW-specific data\n\tuint32_t hw_config_init_flag;\n\tuint8_t hw_config[128];\n} backup_data;\n\n#endif /* DATATYPES_H_ */\n"
        },
        {
          "name": "documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "driver",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder",
          "type": "tree",
          "content": null
        },
        {
          "name": "events.c",
          "type": "blob",
          "size": 2.8544921875,
          "content": "/*\n\tCopyright 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#include \"events.h\"\n#include \"terminal.h\"\n#include \"commands.h\"\n#include \"utils_sys.h\"\n#include \"ch.h\"\n#include <string.h>\n#include <math.h>\n\n// Settings\n#define EVENTS_LEN\t30\n\n// Private types\ntypedef struct {\n\tconst char *name;\n\tthread_t *thread;\n\tfloat param;\n\tsystime_t time;\n\tbool set;\n} event_t;\n\n// Private variables\nstatic volatile event_t m_events[EVENTS_LEN];\nstatic volatile int m_event_now = 0;\nstatic mutex_t m_mtx;\n\n// Private functions\nstatic void terminal_print(int argc, const char **argv);\n\nvoid events_init(void) {\n\tchMtxObjectInit(&m_mtx);\n\n\tfor (int i = 0;i < EVENTS_LEN;i++) {\n\t\tvolatile event_t *e = &m_events[i];\n\t\te->set = false;\n\t}\n\n\tterminal_register_command_callback(\n\t\t\t\"events\",\n\t\t\t\"Print recent motor events\",\n\t\t\t0,\n\t\t\tterminal_print);\n}\n\nvoid events_add(const char *name, float param) {\n\tchMtxLock(&m_mtx);\n\n\tint event = m_event_now;\n\n\tevent--;\n\tif (event < 0) {\n\t\tevent = EVENTS_LEN - 1;\n\t}\n\tvolatile event_t *e = &m_events[event];\n\n\t// Just update the last event if it looks like\n\t// a repeated command. Otherwise the buffer will\n\t// fill too fast.\n\tif (e->name != name || // Comparing memory location is enough\n\t\t\te->thread != chThdGetSelfX() ||\n\t\t\tUTILS_AGE_S(e->time) > 0.2 ||\n\t\t\t(fabsf(param) > 1e-4) != (fabsf(e->param) > 1e-4)) {\n\t\tevent = (event + 1) % EVENTS_LEN;\n\t\te = &m_events[event];\n\t}\n\n\te->name = name;\n\te->thread = chThdGetSelfX();\n\te->param = param;\n\te->time = chVTGetSystemTimeX();\n\te->set = true;\n\n\tevent = (event + 1) % EVENTS_LEN;\n\tm_event_now = event;\n\n\tchMtxUnlock(&m_mtx);\n}\n\nstatic void terminal_print(int argc, const char **argv) {\n\t(void)argc; (void)argv;\n\n\tint event = m_event_now;\n\tint print_cnt = 0;\n\n\tdo {\n\t\tvolatile event_t *e = &m_events[event];\n\n\t\tif (e->set) {\n\t\t\tprint_cnt++;\n\t\t\tcommands_printf(\"Age    : %.2f s\", (double)UTILS_AGE_S(e->time));\n\t\t\tcommands_printf(\"Thread : %s\", e->thread->p_name);\n\t\t\tcommands_printf(\"Motor  : %i\", e->thread->motor_selected);\n\t\t\tcommands_printf(\"Command: %s\", e->name);\n\t\t\tcommands_printf(\"Param  : %.3f\\n\", (double)e->param);\n\t\t}\n\n\t\tevent = (event + 1) % EVENTS_LEN;\n\t} while (event != m_event_now);\n\n\tcommands_printf(\"Events total: %d\\n\", print_cnt);\n}\n"
        },
        {
          "name": "events.h",
          "type": "blob",
          "size": 0.9169921875,
          "content": "/*\n\tCopyright 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef EVENTS_H_\n#define EVENTS_H_\n\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid events_init(void);\nvoid events_add(const char *name, float param);\n\n#endif /* EVENTS_H_ */\n"
        },
        {
          "name": "firmware_metadata.h",
          "type": "blob",
          "size": 0.5185546875,
          "content": "#ifndef FIRMWARE_METADATA_H\r\n#define FIRMWARE_METADATA_H\r\n\r\n//#define STRING2(x) #x\r\n//#define STRING(x) STRING2(x)\r\n//#pragma message \"ARM_GCC_VERSION = \" STRING(ARM_GCC_VERSION)\r\n\r\n// Track the git branch name\r\n#ifndef GIT_BRANCH_NAME\r\n#define GIT_BRANCH_NAME \"undefined\"\r\n#endif\r\n\r\n// Track the git hash version\r\n#ifndef GIT_COMMIT_HASH\r\n#define GIT_COMMIT_HASH \"undefined\"\r\n#endif\r\n\r\n// Track the cross-compiler version\r\n#ifndef ARM_GCC_VERSION\r\n#define ARM_GCC_VERSION \"undefined\"\r\n#endif\r\n\r\n\r\n#endif  // FIRMWARE_METADATA_H\r\n"
        },
        {
          "name": "flash_helper.c",
          "type": "blob",
          "size": 14.5146484375,
          "content": "/*\n\tCopyright 2016 - 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#pragma GCC push_options\n#pragma GCC optimize (\"Os\")\n\n#include \"flash_helper.h\"\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"stm32f4xx_conf.h\"\n#include \"utils_sys.h\"\n#include \"mc_interface.h\"\n#include \"timeout.h\"\n#include \"hw.h\"\n#include \"crc.h\"\n#include \"buffer.h\"\n#include <string.h>\n\n#ifdef USE_LISPBM\n#include \"lispif.h\"\n#endif\n\n/*\n * Defines\n */\n#define FLASH_SECTORS\t\t\t\t\t\t\t12\n#define BOOTLOADER_BASE\t\t\t\t\t\t\t11\n#define APP_BASE\t\t\t\t\t\t\t\t0\n#define NEW_APP_BASE\t\t\t\t\t\t\t8\n#define NEW_APP_SECTORS\t\t\t\t\t\t\t3\n#define APP_MAX_SIZE\t\t\t\t\t\t\t(1024 * 128 * 4 - 8) // Note that the bootloader needs 8 extra bytes\n#define QMLUI_BASE\t\t\t\t\t\t\t\t9\n#define LISP_BASE\t\t\t\t\t\t\t\t10\n#define LISP_CONST_BASE\t\t\t\t\t\t\t8\n#define QMLUI_MAX_SIZE\t\t\t\t\t\t\t(1024 * 128 - 8)\n#define LISP_MAX_SIZE\t\t\t\t\t\t\t(1024 * 128 - 8)\n\n// Base address of the Flash sectors\n#define ADDR_FLASH_SECTOR_0    \t\t\t\t\t((uint32_t)0x08000000) // Base @ of Sector 0, 16 Kbytes\n#define ADDR_FLASH_SECTOR_1    \t\t\t\t\t((uint32_t)0x08004000) // Base @ of Sector 1, 16 Kbytes\n#define ADDR_FLASH_SECTOR_2    \t\t\t\t\t((uint32_t)0x08008000) // Base @ of Sector 2, 16 Kbytes\n#define ADDR_FLASH_SECTOR_3\t\t\t\t\t\t((uint32_t)0x0800C000) // Base @ of Sector 3, 16 Kbytes\n#define ADDR_FLASH_SECTOR_4    \t\t\t\t\t((uint32_t)0x08010000) // Base @ of Sector 4, 64 Kbytes\n#define ADDR_FLASH_SECTOR_5    \t\t\t\t\t((uint32_t)0x08020000) // Base @ of Sector 5, 128 Kbytes\n#define ADDR_FLASH_SECTOR_6     \t\t\t\t((uint32_t)0x08040000) // Base @ of Sector 6, 128 Kbytes\n#define ADDR_FLASH_SECTOR_7     \t\t\t\t((uint32_t)0x08060000) // Base @ of Sector 7, 128 Kbytes\n#define ADDR_FLASH_SECTOR_8     \t\t\t\t((uint32_t)0x08080000) // Base @ of Sector 8, 128 Kbytes\n#define ADDR_FLASH_SECTOR_9 \t\t\t\t    ((uint32_t)0x080A0000) // Base @ of Sector 9, 128 Kbytes\n#define ADDR_FLASH_SECTOR_10\t\t\t\t    ((uint32_t)0x080C0000) // Base @ of Sector 10, 128 Kbytes\n#define ADDR_FLASH_SECTOR_11\t\t\t\t    ((uint32_t)0x080E0000) // Base @ of Sector 11, 128 Kbytes\n\n#define VECTOR_TABLE_ADDRESS\t\t\t\t\t((uint32_t*)ADDR_FLASH_SECTOR_0)\n#define VECTOR_TABLE_SIZE\t\t\t\t\t\t((uint32_t)(ADDR_FLASH_SECTOR_1 - ADDR_FLASH_SECTOR_0))\n#define EEPROM_EMULATION_SIZE\t\t\t\t\t((uint32_t)(ADDR_FLASH_SECTOR_4 - ADDR_FLASH_SECTOR_2))\n\n#define APP_START_ADDRESS\t\t\t\t\t\t((uint32_t*)(ADDR_FLASH_SECTOR_3))\n#define APP_SIZE\t\t\t\t\t\t\t\t((uint32_t)(APP_MAX_SIZE - VECTOR_TABLE_SIZE - EEPROM_EMULATION_SIZE))\n\n#define\tAPP_CRC_WAS_CALCULATED_FLAG\t\t\t\t((uint32_t)0x00000000)\n#define\tAPP_CRC_WAS_CALCULATED_FLAG_ADDRESS\t\t((uint32_t*)(ADDR_FLASH_SECTOR_0 + APP_MAX_SIZE - 8))\n#define APP_CRC_ADDRESS\t\t\t\t\t\t\t((uint32_t*)(ADDR_FLASH_SECTOR_0 + APP_MAX_SIZE - 4))\n\n#define ERASE_VOLTAGE_RANGE\t\t\t\t\t\t(uint8_t)((PWR->CSR & PWR_CSR_PVDO) ? VoltageRange_2 : VoltageRange_3)\n\ntypedef struct {\n\tuint32_t crc_flag;\n\tuint32_t crc;\n} crc_info_t;\n\n// Make sure the app image has the CRC bits set to '1' to later write the flag and CRC.\nconst crc_info_t __attribute__((section (\".crcinfo\"))) crc_info = {0xFFFFFFFF, 0xFFFFFFFF};\n\n// Private functions\nstatic uint16_t erase_sector(uint32_t sector);\nstatic uint16_t write_data(uint32_t base, uint8_t *data, uint32_t len);\nstatic void qmlui_check(int ind);\n\n// Private variables\ntypedef struct {\n\tbool check_done;\n\tbool ok;\n} _code_checks;\n\nstatic _code_checks code_checks[3] = {0};\nstatic int code_sectors[3] = {QMLUI_BASE, LISP_BASE, LISP_CONST_BASE};\n\n// Private constants\nstatic const uint32_t flash_addr[FLASH_SECTORS] = {\n\t\tADDR_FLASH_SECTOR_0,\n\t\tADDR_FLASH_SECTOR_1,\n\t\tADDR_FLASH_SECTOR_2,\n\t\tADDR_FLASH_SECTOR_3,\n\t\tADDR_FLASH_SECTOR_4,\n\t\tADDR_FLASH_SECTOR_5,\n\t\tADDR_FLASH_SECTOR_6,\n\t\tADDR_FLASH_SECTOR_7,\n\t\tADDR_FLASH_SECTOR_8,\n\t\tADDR_FLASH_SECTOR_9,\n\t\tADDR_FLASH_SECTOR_10,\n\t\tADDR_FLASH_SECTOR_11\n};\nstatic const uint16_t flash_sector[FLASH_SECTORS] = {\n\t\tFLASH_Sector_0,\n\t\tFLASH_Sector_1,\n\t\tFLASH_Sector_2,\n\t\tFLASH_Sector_3,\n\t\tFLASH_Sector_4,\n\t\tFLASH_Sector_5,\n\t\tFLASH_Sector_6,\n\t\tFLASH_Sector_7,\n\t\tFLASH_Sector_8,\n\t\tFLASH_Sector_9,\n\t\tFLASH_Sector_10,\n\t\tFLASH_Sector_11\n};\n\nuint16_t flash_helper_erase_new_app(uint32_t new_app_size) {\n#ifdef USE_LISPBM\n\tlispif_restart(false, false, false);\n#endif\n\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tnew_app_size += flash_addr[NEW_APP_BASE];\n\n\tmc_interface_ignore_input_both(5000);\n\tmc_interface_release_motor_override_both();\n\n\tif (!mc_interface_wait_for_motor_release_both(3.0)) {\n\t\treturn 100;\n\t}\n\n\tutils_sys_lock_cnt();\n\ttimeout_configure_IWDT_slowest();\n\n\tfor (int i = 0;i < NEW_APP_SECTORS;i++) {\n\t\tif (new_app_size > flash_addr[NEW_APP_BASE + i]) {\n\t\t\tuint16_t res = FLASH_EraseSector(flash_sector[NEW_APP_BASE + i], ERASE_VOLTAGE_RANGE);\n\t\t\tif (res != FLASH_COMPLETE) {\n\t\t\t\tFLASH_Lock();\n\t\t\t\ttimeout_configure_IWDT();\n\t\t\t\tmc_interface_ignore_input_both(5000);\n\t\t\t\tutils_sys_unlock_cnt();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFLASH_Lock();\n\ttimeout_configure_IWDT();\n\tmc_interface_ignore_input_both(100);\n\tutils_sys_unlock_cnt();\n\n\treturn FLASH_COMPLETE;\n}\n\nuint16_t flash_helper_erase_bootloader(void) {\n\treturn erase_sector(flash_sector[BOOTLOADER_BASE]);\n}\n\nuint16_t flash_helper_write_new_app_data(uint32_t offset, uint8_t *data, uint32_t len) {\n\treturn write_data(flash_addr[NEW_APP_BASE] + offset, data, len);\n}\n\nuint16_t flash_helper_erase_code(int ind) {\n#ifdef USE_LISPBM\n\tif (ind == CODE_IND_LISP || ind == CODE_IND_LISP_CONST) {\n\t\tlispif_stop_lib();\n\t}\n#endif\n\n\tuint8_t *ptr = flash_helper_code_data_raw(ind);\n\n\tbool has_data = false;\n\tfor (int i = 0;i < (1024 * 128); i++) {\n\t\tif (*ptr != 0xFF) {\n\t\t\thas_data = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!has_data) {\n\t\treturn FLASH_COMPLETE;\n\t}\n\n\tcode_checks[ind].check_done = false;\n\tcode_checks[ind].ok = false;\n\treturn erase_sector(flash_sector[code_sectors[ind]]);\n}\n\nuint16_t flash_helper_write_code(int ind, uint32_t offset, uint8_t *data, uint32_t len) {\n\tcode_checks[ind].check_done = false;\n\tcode_checks[ind].ok = false;\n\treturn write_data(flash_addr[code_sectors[ind]] + offset, data, len);\n}\n\nuint8_t* flash_helper_code_data(int ind) {\n\tqmlui_check(ind);\n\n\tif (code_checks[ind].check_done && code_checks[ind].ok) {\n\t\treturn (uint8_t*)(flash_addr[code_sectors[ind]]) + 8;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nuint8_t* flash_helper_code_data_raw(int ind) {\n\treturn (uint8_t*)flash_addr[code_sectors[ind]];\n}\n\nuint32_t flash_helper_code_size(int ind) {\n\tqmlui_check(ind);\n\n\tif (code_checks[ind].check_done && code_checks[ind].ok) {\n\t\tuint8_t *base = (uint8_t*)(flash_addr[code_sectors[ind]]);\n\t\tint32_t index = 0;\n\t\treturn buffer_get_uint32(base, &index);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nuint16_t flash_helper_code_flags(int ind) {\n\tqmlui_check(ind);\n\n\tif (code_checks[ind].check_done && code_checks[ind].ok) {\n\t\tuint8_t *base = (uint8_t*)(flash_addr[code_sectors[ind]]);\n\t\tint32_t index = 6;\n\t\treturn buffer_get_uint16(base, &index);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * Stop the system and jump to the bootloader.\n */\nvoid flash_helper_jump_to_bootloader(void) {\n\ttypedef void (*pFunction)(void);\n\n\tmc_interface_release_motor_override();\n\tusbDisconnectBus(&USBD1);\n\tusbStop(&USBD1);\n\n\tsdStop(&HW_UART_DEV);\n\tpalSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT);\n\tpalSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_INPUT);\n\n\t// Disable watchdog\n\ttimeout_configure_IWDT_slowest();\n\n\tchSysDisable();\n\n\tpFunction jump_to_bootloader;\n\n\t// Variable that will be loaded with the start address of the application\n\tvolatile uint32_t* jump_address;\n\tconst volatile uint32_t* bootloader_address = (volatile uint32_t*)0x080E0000;\n\n\t// Get jump address from application vector table\n\tjump_address = (volatile uint32_t*) bootloader_address[1];\n\n\t// Load this address into function pointer\n\tjump_to_bootloader = (pFunction) jump_address;\n\n\t// Clear pending interrupts\n\tSCB->ICSR = SCB_ICSR_PENDSVCLR_Msk;\n\n\t// Disable all interrupts\n\tfor(int i = 0;i < 8;i++) {\n\t\tNVIC->ICER[i] = NVIC->IABR[i];\n\t}\n\n\t// Set stack pointer\n\t__set_MSP((uint32_t) (bootloader_address[0]));\n\n\t// Jump to the bootloader\n\tjump_to_bootloader();\n}\n\nuint8_t* flash_helper_get_sector_address(uint32_t fsector) {\n\tuint8_t *res = 0;\n\n\tfor (int i = 0;i < FLASH_SECTORS;i++) {\n\t\tif (flash_sector[i] == fsector) {\n\t\t\tres = (uint8_t *)flash_addr[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\n  * @brief  Compute the CRC of the application code to verify its integrity\n  * @retval FAULT_CODE_NONE or FAULT_CODE_FLASH_CORRUPTION\n  */\nuint32_t flash_helper_verify_flash_memory(void) {\n\tuint32_t crc;\n\t// Look for a flag indicating that the CRC was previously computed.\n\t// If it is blank (0xFFFFFFFF), calculate and store the CRC.\n\tif(APP_CRC_WAS_CALCULATED_FLAG_ADDRESS[0] == APP_CRC_WAS_CALCULATED_FLAG) {\n\t\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, ENABLE);\n\t\tcrc32_reset();\n\n\t\t// compute vector table (sector 0)\n\t\tcrc32(VECTOR_TABLE_ADDRESS, (VECTOR_TABLE_SIZE) / 4);\n\n\t\t// skip emulated EEPROM (sector 1 and 2)\n\n\t\t// compute application code\n\t\tcrc = crc32(APP_START_ADDRESS, (APP_SIZE) / 4);\n\n\t\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, DISABLE);\n\n\t\t// A CRC over the full image should return zero.\n\t\treturn (crc == 0) ? FAULT_CODE_NONE : FAULT_CODE_FLASH_CORRUPTION;\n\t} else {\n\t\tFLASH_Unlock();\n\t\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\t\t// Write the flag to indicate CRC has been computed.\n\t\tuint16_t res = FLASH_ProgramWord((uint32_t)APP_CRC_WAS_CALCULATED_FLAG_ADDRESS, APP_CRC_WAS_CALCULATED_FLAG);\n\t\tif (res != FLASH_COMPLETE) {\n\t\t\tFLASH_Lock();\n\t\t\treturn FAULT_CODE_FLASH_CORRUPTION;\n\t\t}\n\n\t\t// Compute flash crc including the new flag\n\t\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, ENABLE);\n\t\tcrc32_reset();\n\n\t\t// compute vector table (sector 0)\n\t\tcrc32(VECTOR_TABLE_ADDRESS, (VECTOR_TABLE_SIZE) / 4);\n\n\t\t// skip emulated EEPROM (sector 1 and 2)\n\n\t\t// compute application code\n\t\tcrc = crc32(APP_START_ADDRESS, (APP_SIZE - 4) / 4);\n\n\t\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, DISABLE);\n\n\t\t//Store CRC\n\t\tres = FLASH_ProgramWord((uint32_t)APP_CRC_ADDRESS, crc);\n\t\tif (res != FLASH_COMPLETE) {\n\t\t\tFLASH_Lock();\n\t\t\treturn FAULT_CODE_FLASH_CORRUPTION;\n\t\t}\n\t\tFLASH_Lock();\n\n\t\t// reboot\n\t\tNVIC_SystemReset();\n\t\treturn FAULT_CODE_NONE;\n\t}\n}\n\nuint32_t flash_helper_verify_flash_memory_chunk(void) {\n\tstatic uint32_t index = 0;\n\tuint32_t chunk_size = 1024;\n\tuint32_t res = FAULT_CODE_NONE;\n\tuint32_t crc = 0;\n\tuint32_t tot_bytes = VECTOR_TABLE_SIZE + APP_SIZE;\n\n\t// Make sure RCC_AHB1Periph_CRC is enabled\n\tif (index == 0) {\n\t\tcrc32_reset();\n\t}\n\n\tif ((index + chunk_size) >= tot_bytes) {\n\t\tchunk_size = tot_bytes - index;\n\t}\n\n\tif (index < VECTOR_TABLE_SIZE) {\n\t\tcrc32(VECTOR_TABLE_ADDRESS + index / 4, chunk_size / 4);\n\t} else {\n\t\tcrc = crc32(APP_START_ADDRESS + (index - VECTOR_TABLE_SIZE) / 4, chunk_size / 4);\n\t}\n\n\tindex += chunk_size;\n\tif (index >= tot_bytes) {\n\t\tindex = 0;\n\t\tif (crc != 0) {\n\t\t\tres = FAULT_CODE_FLASH_CORRUPTION;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic uint16_t erase_sector(uint32_t sector) {\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tmc_interface_ignore_input_both(5000);\n\tmc_interface_release_motor_override_both();\n\n\tif (!mc_interface_wait_for_motor_release_both(3.0)) {\n\t\treturn 100;\n\t}\n\n\tutils_sys_lock_cnt();\n\ttimeout_configure_IWDT_slowest();\n\n\tuint16_t res = FLASH_EraseSector(sector, ERASE_VOLTAGE_RANGE);\n\n\tFLASH_Lock();\n\ttimeout_configure_IWDT();\n\tmc_interface_ignore_input_both(100);\n\tutils_sys_unlock_cnt();\n\treturn res;\n}\n\nstatic uint16_t write_data(uint32_t base, uint8_t *data, uint32_t len) {\n\tFLASH_Unlock();\n\tFLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |\n\t\t\tFLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n\n\tmc_interface_ignore_input_both(5000);\n\tmc_interface_release_motor_override_both();\n\n\tif (!mc_interface_wait_for_motor_release_both(3.0)) {\n\t\treturn 100;\n\t}\n\n\tutils_sys_lock_cnt();\n\ttimeout_configure_IWDT_slowest();\n\n\tfor (uint32_t i = 0;i < len;i++) {\n\t\tuint16_t res = FLASH_ProgramByte(base + i, data[i]);\n\t\tif (res != FLASH_COMPLETE) {\n\t\t\tFLASH_Lock();\n\t\t\ttimeout_configure_IWDT();\n\t\t\tmc_interface_ignore_input_both(5000);\n\t\t\tutils_sys_unlock_cnt();\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tFLASH_Lock();\n\ttimeout_configure_IWDT();\n\tmc_interface_ignore_input_both(100);\n\tutils_sys_unlock_cnt();\n\n\treturn FLASH_COMPLETE;\n}\n\nstatic void qmlui_check(int ind) {\n\tif (code_checks[ind].check_done) {\n\t\treturn;\n\t}\n\n\tuint8_t *base = (uint8_t*)(flash_addr[code_sectors[ind]]);\n\tint32_t index = 0;\n\tuint32_t qmlui_len = buffer_get_uint32(base, &index);\n\tuint16_t qmlui_crc = buffer_get_uint16(base, &index);\n\n\tif (qmlui_len <= QMLUI_MAX_SIZE) {\n\t\tuint16_t crc_calc = crc16(base + index, qmlui_len + 2); // CRC includes the 2 byte flags\n\t\tcode_checks[ind].ok = crc_calc == qmlui_crc;\n\t} else {\n\t\tcode_checks[ind].ok = false;\n\t}\n\n\tcode_checks[ind].check_done = true;\n}\n\n#define VESC_IF_NVM_REGION_SIZE\t(ADDR_FLASH_SECTOR_9 - ADDR_FLASH_SECTOR_8)\n\n/**\n  * @brief  Reads len bytes to v from nvm at address\n  * @param\tv: array of bytes to which the result will be written\n  * @param\tlen: number of bytes to read\n  * @param\taddress: address of the first byte\n  * @retval Boolean indicating success or failure\n  */\nbool flash_helper_read_nvm(uint8_t *v, unsigned int len, unsigned int address) {\n\tif ((address + len) > VESC_IF_NVM_REGION_SIZE) {\n\t\treturn false;\n\t}\n\n\tmemcpy(v, (uint8_t*)(ADDR_FLASH_SECTOR_8 + address), len);\n\n\treturn true;\n}\n\n/**\n  * @brief  Writes len bytes from v to nvm at address\n  * @param\tv: array of bytes to write\n  * @param\tlen: number of bytes to write\n  * @param\taddress: address of the first byte\n  * @retval Boolean indicating success or failure\n  */\nbool flash_helper_write_nvm(uint8_t *v, unsigned int len, unsigned int address) {\n\tif ((address + len) > VESC_IF_NVM_REGION_SIZE) {\n\t\treturn false;\n\t}\n\n\tuint16_t res = write_data(ADDR_FLASH_SECTOR_8 + address, v, len);\n\n\treturn (res == FLASH_COMPLETE);\n}\n\n/**\n  * @brief  Erase region of NVM used by packages.\n  * @retval Boolean indicating success or failure\n  */\nbool flash_helper_wipe_nvm(void) {\n\treturn (erase_sector(flash_sector[8]) == FLASH_COMPLETE);\n}\n\n#pragma GCC pop_options\n"
        },
        {
          "name": "flash_helper.h",
          "type": "blob",
          "size": 1.8994140625,
          "content": "/*\n\tCopyright 2016 - 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef FLASH_HELPER_H_\n#define FLASH_HELPER_H_\n\n#include \"conf_general.h\"\n\n#define CODE_IND_QML\t\t0\n#define CODE_IND_LISP\t\t1\n#define CODE_IND_LISP_CONST 2\n\n// Functions\nuint16_t flash_helper_erase_new_app(uint32_t new_app_size);\nuint16_t flash_helper_erase_bootloader(void);\nuint16_t flash_helper_write_new_app_data(uint32_t offset, uint8_t *data, uint32_t len);\n\nuint16_t flash_helper_erase_code(int ind);\nuint16_t flash_helper_write_code(int ind, uint32_t offset, uint8_t *data, uint32_t len);\nuint8_t* flash_helper_code_data(int ind);\nuint8_t* flash_helper_code_data_raw(int ind);\nuint32_t flash_helper_code_size(int ind);\nuint16_t flash_helper_code_flags(int ind);\n\nvoid flash_helper_jump_to_bootloader(void);\nuint8_t* flash_helper_get_sector_address(uint32_t fsector);\nuint32_t flash_helper_verify_flash_memory(void);\nuint32_t flash_helper_verify_flash_memory_chunk(void);\n\n// functions used in vesc_c_if.h and therefore accessible to packages\nbool flash_helper_read_nvm(uint8_t *v, unsigned int len, unsigned int address);\nbool flash_helper_write_nvm(uint8_t *v, unsigned int len, unsigned int address);\nbool flash_helper_wipe_nvm(void);\n\n#endif /* FLASH_HELPER_H_ */\n"
        },
        {
          "name": "halconf.h",
          "type": "blob",
          "size": 10.05078125,
          "content": "/*\n    ChibiOS - Copyright (C) 2006..2015 Giovanni Di Sirio\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\n * @file    templates/halconf.h\n * @brief   HAL configuration header.\n * @details HAL configuration file, this file allows to enable or disable the\n *          various device drivers from your application. You may also use\n *          this file in order to override the device drivers default settings.\n *\n * @addtogroup HAL_CONF\n * @{\n */\n\n#ifndef _HALCONF_H_\n#define _HALCONF_H_\n\n#include \"mcuconf.h\"\n\n/**\n * @brief   Enables the PAL subsystem.\n */\n#if !defined(HAL_USE_PAL) || defined(__DOXYGEN__)\n#define HAL_USE_PAL                 TRUE\n#endif\n\n/**\n * @brief   Enables the ADC subsystem.\n */\n#if !defined(HAL_USE_ADC) || defined(__DOXYGEN__)\n#define HAL_USE_ADC                 FALSE\n#endif\n\n/**\n * @brief   Enables the CAN subsystem.\n */\n#if !defined(HAL_USE_CAN) || defined(__DOXYGEN__)\n#define HAL_USE_CAN                 TRUE\n#endif\n\n/**\n * @brief   Enables the DAC subsystem.\n */\n#if !defined(HAL_USE_DAC) || defined(__DOXYGEN__)\n#define HAL_USE_DAC                 FALSE\n#endif\n\n/**\n * @brief   Enables the EXT subsystem.\n */\n#if !defined(HAL_USE_EXT) || defined(__DOXYGEN__)\n#define HAL_USE_EXT                 FALSE\n#endif\n\n/**\n * @brief   Enables the GPT subsystem.\n */\n#if !defined(HAL_USE_GPT) || defined(__DOXYGEN__)\n#define HAL_USE_GPT                 FALSE\n#endif\n\n/**\n * @brief   Enables the I2C subsystem.\n */\n#if !defined(HAL_USE_I2C) || defined(__DOXYGEN__)\n#define HAL_USE_I2C                 TRUE\n#endif\n\n/**\n * @brief   Enables the I2S subsystem.\n */\n#if !defined(HAL_USE_I2S) || defined(__DOXYGEN__)\n#define HAL_USE_I2S                 FALSE\n#endif\n\n/**\n * @brief   Enables the ICU subsystem.\n */\n#if !defined(HAL_USE_ICU) || defined(__DOXYGEN__)\n#define HAL_USE_ICU                 TRUE\n#endif\n\n/**\n * @brief   Enables the MAC subsystem.\n */\n#if !defined(HAL_USE_MAC) || defined(__DOXYGEN__)\n#define HAL_USE_MAC                 FALSE\n#endif\n\n/**\n * @brief   Enables the MMC_SPI subsystem.\n */\n#if !defined(HAL_USE_MMC_SPI) || defined(__DOXYGEN__)\n#define HAL_USE_MMC_SPI             FALSE\n#endif\n\n/**\n * @brief   Enables the PWM subsystem.\n */\n#if !defined(HAL_USE_PWM) || defined(__DOXYGEN__)\n#define HAL_USE_PWM                 FALSE\n#endif\n\n/**\n * @brief   Enables the RTC subsystem.\n */\n#if !defined(HAL_USE_RTC) || defined(__DOXYGEN__)\n#define HAL_USE_RTC                 FALSE\n#endif\n\n/**\n * @brief   Enables the SDC subsystem.\n */\n#if !defined(HAL_USE_SDC) || defined(__DOXYGEN__)\n#define HAL_USE_SDC                 FALSE\n#endif\n\n/**\n * @brief   Enables the SERIAL subsystem.\n */\n#if !defined(HAL_USE_SERIAL) || defined(__DOXYGEN__)\n#define HAL_USE_SERIAL              TRUE\n#endif\n\n/**\n * @brief   Enables the SERIAL over USB subsystem.\n */\n#if !defined(HAL_USE_SERIAL_USB) || defined(__DOXYGEN__)\n#define HAL_USE_SERIAL_USB          TRUE\n#endif\n\n/**\n * @brief   Enables the SPI subsystem.\n */\n#if !defined(HAL_USE_SPI) || defined(__DOXYGEN__)\n#define HAL_USE_SPI                 TRUE\n#endif\n\n/**\n * @brief   Enables the UART subsystem.\n */\n#if !defined(HAL_USE_UART) || defined(__DOXYGEN__)\n#define HAL_USE_UART                FALSE\n#endif\n\n/**\n * @brief   Enables the USB subsystem.\n */\n#if !defined(HAL_USE_USB) || defined(__DOXYGEN__)\n#define HAL_USE_USB                 TRUE\n#endif\n\n/*===========================================================================*/\n/* ADC driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Enables synchronous APIs.\n * @note    Disabling this option saves both code and data space.\n */\n#if !defined(ADC_USE_WAIT) || defined(__DOXYGEN__)\n#define ADC_USE_WAIT                TRUE\n#endif\n\n/**\n * @brief   Enables the @p adcAcquireBus() and @p adcReleaseBus() APIs.\n * @note    Disabling this option saves both code and data space.\n */\n#if !defined(ADC_USE_MUTUAL_EXCLUSION) || defined(__DOXYGEN__)\n#define ADC_USE_MUTUAL_EXCLUSION    TRUE\n#endif\n\n/*===========================================================================*/\n/* CAN driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Sleep mode related APIs inclusion switch.\n */\n#if !defined(CAN_USE_SLEEP_MODE) || defined(__DOXYGEN__)\n#define CAN_USE_SLEEP_MODE          TRUE\n#endif\n\n/*===========================================================================*/\n/* I2C driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Enables the mutual exclusion APIs on the I2C bus.\n */\n#if !defined(I2C_USE_MUTUAL_EXCLUSION) || defined(__DOXYGEN__)\n#define I2C_USE_MUTUAL_EXCLUSION    TRUE\n#endif\n\n/*===========================================================================*/\n/* MAC driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Enables an event sources for incoming packets.\n */\n#if !defined(MAC_USE_ZERO_COPY) || defined(__DOXYGEN__)\n#define MAC_USE_ZERO_COPY           FALSE\n#endif\n\n/**\n * @brief   Enables an event sources for incoming packets.\n */\n#if !defined(MAC_USE_EVENTS) || defined(__DOXYGEN__)\n#define MAC_USE_EVENTS              TRUE\n#endif\n\n/*===========================================================================*/\n/* MMC_SPI driver related settings.                                          */\n/*===========================================================================*/\n\n/**\n * @brief   Delays insertions.\n * @details If enabled this options inserts delays into the MMC waiting\n *          routines releasing some extra CPU time for the threads with\n *          lower priority, this may slow down the driver a bit however.\n *          This option is recommended also if the SPI driver does not\n *          use a DMA channel and heavily loads the CPU.\n */\n#if !defined(MMC_NICE_WAITING) || defined(__DOXYGEN__)\n#define MMC_NICE_WAITING            TRUE\n#endif\n\n/*===========================================================================*/\n/* SDC driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Number of initialization attempts before rejecting the card.\n * @note    Attempts are performed at 10mS intervals.\n */\n#if !defined(SDC_INIT_RETRY) || defined(__DOXYGEN__)\n#define SDC_INIT_RETRY              100\n#endif\n\n/**\n * @brief   Include support for MMC cards.\n * @note    MMC support is not yet implemented so this option must be kept\n *          at @p FALSE.\n */\n#if !defined(SDC_MMC_SUPPORT) || defined(__DOXYGEN__)\n#define SDC_MMC_SUPPORT             FALSE\n#endif\n\n/**\n * @brief   Delays insertions.\n * @details If enabled this options inserts delays into the MMC waiting\n *          routines releasing some extra CPU time for the threads with\n *          lower priority, this may slow down the driver a bit however.\n */\n#if !defined(SDC_NICE_WAITING) || defined(__DOXYGEN__)\n#define SDC_NICE_WAITING            TRUE\n#endif\n\n/*===========================================================================*/\n/* SERIAL driver related settings.                                           */\n/*===========================================================================*/\n\n/**\n * @brief   Default bit rate.\n * @details Configuration parameter, this is the baud rate selected for the\n *          default configuration.\n */\n#if !defined(SERIAL_DEFAULT_BITRATE) || defined(__DOXYGEN__)\n#define SERIAL_DEFAULT_BITRATE      115200\n#endif\n\n/**\n * @brief   Serial buffers size.\n * @details Configuration parameter, you can change the depth of the queue\n *          buffers depending on the requirements of your application.\n * @note    The default is 64 bytes for both the transmission and receive\n *          buffers.\n */\n#if !defined(SERIAL_BUFFERS_SIZE) || defined(__DOXYGEN__)\n#define SERIAL_BUFFERS_SIZE         128\n#endif\n\n/*===========================================================================*/\n/* SERIAL_USB driver related setting.                                        */\n/*===========================================================================*/\n\n/**\n * @brief   Serial over USB buffers size.\n * @details Configuration parameter, the buffer size must be a multiple of\n *          the USB data endpoint maximum packet size.\n * @note    The default is 64 bytes for both the transmission and receive\n *          buffers.\n */\n#if !defined(SERIAL_USB_BUFFERS_SIZE) || defined(__DOXYGEN__)\n#define SERIAL_USB_BUFFERS_SIZE     1024\n#endif\n\n/*===========================================================================*/\n/* SPI driver related settings.                                              */\n/*===========================================================================*/\n\n/**\n * @brief   Enables synchronous APIs.\n * @note    Disabling this option saves both code and data space.\n */\n#if !defined(SPI_USE_WAIT) || defined(__DOXYGEN__)\n#define SPI_USE_WAIT                TRUE\n#endif\n\n/**\n * @brief   Enables the @p spiAcquireBus() and @p spiReleaseBus() APIs.\n * @note    Disabling this option saves both code and data space.\n */\n#if !defined(SPI_USE_MUTUAL_EXCLUSION) || defined(__DOXYGEN__)\n#define SPI_USE_MUTUAL_EXCLUSION    TRUE\n#endif\n\n/**\n * @brief   Allows adding custom fields to the @p SPIDriver struct.\n */\n#if !defined(SPI_DRIVER_EXT_FIELDS) || defined(__DOXYGEN__)\n#define SPI_DRIVER_EXT_FIELDS       void* app_arg; void (*err_cb)(SPIDriver *pspi);\n#endif\n\n#endif /* _HALCONF_H_ */\n\n/** @} */\n"
        },
        {
          "name": "hwconf",
          "type": "tree",
          "content": null
        },
        {
          "name": "imu",
          "type": "tree",
          "content": null
        },
        {
          "name": "irq_handlers.c",
          "type": "blob",
          "size": 2.072265625,
          "content": "/*\n\tCopyright 2016 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"stm32f4xx_conf.h\"\n#include \"isr_vector_table.h\"\n#include \"mc_interface.h\"\n#include \"mcpwm_foc.h\"\n#include \"hw.h\"\n#include \"encoder/encoder.h\"\n\nCH_IRQ_HANDLER(ADC1_2_3_IRQHandler) {\n\tCH_IRQ_PROLOGUE();\n\tADC_ClearITPendingBit(ADC1, ADC_IT_JEOC);\n\tmc_interface_adc_inj_int_handler();\n\tCH_IRQ_EPILOGUE();\n}\n\nCH_IRQ_HANDLER(HW_ENC_EXTI_ISR_VEC) {\n\tif (EXTI_GetITStatus(HW_ENC_EXTI_LINE) != RESET) {\n\t\tencoder_pin_isr();\n\n\t\t// Clear the EXTI line pending bit\n\t\tEXTI_ClearITPendingBit(HW_ENC_EXTI_LINE);\n\t}\n}\n\nCH_IRQ_HANDLER(HW_ENC_TIM_ISR_VEC) {\n\tif (TIM_GetITStatus(HW_ENC_TIM, TIM_IT_Update) != RESET) {\n\t\tencoder_tim_isr();\n\n\t\t// Clear the IT pending bit\n\t\tTIM_ClearITPendingBit(HW_ENC_TIM, TIM_IT_Update);\n\t}\n}\n\nCH_IRQ_HANDLER(TIM2_IRQHandler) {\n\tif (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET) {\n\t\tmcpwm_foc_tim_sample_int_handler();\n\n\t\t// Clear the IT pending bit\n\t\tTIM_ClearITPendingBit(TIM2, TIM_IT_CC2);\n\t}\n\tTIM_ClearITPendingBit(TIM2, TIM_IT_CC2);\n}\n\nCH_IRQ_HANDLER(PVD_IRQHandler) {\n\tif (EXTI_GetITStatus(EXTI_Line16) != RESET) {\n\t\t// Log the fault. Supply voltage dropped below 2.9V,\n\t\t// could corrupt an ongoing flash programming\n\t\tmc_interface_fault_stop(FAULT_CODE_MCU_UNDER_VOLTAGE, false, true);\n\n\t\t// Clear the PVD pending bit\n\t\tEXTI_ClearITPendingBit(EXTI_Line16);\n\t\tEXTI_ClearFlag(EXTI_Line16);\n\t}\n}\n"
        },
        {
          "name": "isr_vector_table.h",
          "type": "blob",
          "size": 6.9677734375,
          "content": "#ifndef ISR_VECTOR_TABLE_H_\n#define ISR_VECTOR_TABLE_H_\n\n#define WWDG_IRQHandler         Vector40    /**< Window Watchdog.           */\n#define PVD_IRQHandler          Vector44    /**< PVD through EXTI Line\n                                                 detect.                    */\n#define TAMP_STAMP_IRQHandler   Vector48    /**< Tamper and TimeStamp\n                                                 through EXTI Line.         */\n#define RTC_WKUP_IRQHandler     Vector4C    /**< RTC wakeup EXTI Line.      */\n#define FLASH_IRQHandler        Vector50    /**< Flash.                     */\n#define RCC_IRQHandler          Vector54    /**< RCC.                       */\n#define EXTI0_IRQHandler        Vector58    /**< EXTI Line 0.               */\n#define EXTI1_IRQHandler        Vector5C    /**< EXTI Line 1.               */\n#define EXTI2_IRQHandler        Vector60    /**< EXTI Line 2.               */\n#define EXTI3_IRQHandler        Vector64    /**< EXTI Line 3.               */\n#define EXTI4_IRQHandler        Vector68    /**< EXTI Line 4.               */\n#define DMA1_Stream0_IRQHandler Vector6C    /**< DMA1 Stream 0.             */\n#define DMA1_Stream1_IRQHandler Vector70    /**< DMA1 Stream 1.             */\n#define DMA1_Stream2_IRQHandler Vector74    /**< DMA1 Stream 2.             */\n#define DMA1_Stream3_IRQHandler Vector78    /**< DMA1 Stream 3.             */\n#define DMA1_Stream4_IRQHandler Vector7C    /**< DMA1 Stream 4.             */\n#define DMA1_Stream5_IRQHandler Vector80    /**< DMA1 Stream 5.             */\n#define DMA1_Stream6_IRQHandler Vector84    /**< DMA1 Stream 6.             */\n#define ADC1_2_3_IRQHandler     Vector88    /**< ADC1, ADC2 and ADC3.       */\n#define CAN1_TX_IRQHandler      Vector8C    /**< CAN1 TX.                   */\n#define CAN1_RX0_IRQHandler     Vector90    /**< CAN1 RX0.                  */\n#define CAN1_RX1_IRQHandler     Vector94    /**< CAN1 RX1.                  */\n#define CAN1_SCE_IRQHandler     Vector98    /**< CAN1 SCE.                  */\n#define EXTI9_5_IRQHandler      Vector9C    /**< EXTI Line 9..5.            */\n#define TIM1_BRK_IRQHandler     VectorA0    /**< TIM1 Break.                */\n#define TIM1_UP_IRQHandler      VectorA4    /**< TIM1 Update.               */\n#define TIM1_TRG_COM_IRQHandler VectorA8    /**< TIM1 Trigger and\n                                                 Commutation.               */\n#define TIM1_CC_IRQHandler      VectorAC    /**< TIM1 Capture Compare.      */\n#define TIM2_IRQHandler         VectorB0    /**< TIM2.                      */\n#define TIM3_IRQHandler         VectorB4    /**< TIM3.                      */\n#define TIM4_IRQHandler         VectorB8    /**< TIM4.                      */\n#define I2C1_EV_IRQHandler      VectorBC    /**< I2C1 Event.                */\n#define I2C1_ER_IRQHandler      VectorC0    /**< I2C1 Error.                */\n#define I2C2_EV_IRQHandler      VectorC4    /**< I2C2 Event.                */\n#define I2C2_ER_IRQHandler      VectorC8    /**< I2C1 Error.                */\n#define SPI1_IRQHandler         VectorCC    /**< SPI1.                      */\n#define SPI2_IRQHandler         VectorD0    /**< SPI2.                      */\n#define USART1_IRQHandler       VectorD4    /**< USART1.                    */\n#define USART2_IRQHandler       VectorD8    /**< USART2.                    */\n#define USART3_IRQHandler       VectorDC    /**< USART3.                    */\n#define EXTI15_10_IRQHandler    VectorE0    /**< EXTI Line 15..10.          */\n#define RTC_Alarm_IRQHandler    VectorE4    /**< RTC alarms (A and B)\n                                                 through EXTI line.         */\n#define OTG_FS_WKUP_IRQHandler  VectorE8    /**< USB OTG FS Wakeup through\n                                                 EXTI line.                 */\n#define TIM8_BRK_IRQHandler     VectorEC    /**< TIM8 Break.                */\n#define TIM8_UP_IRQHandler      VectorF0    /**< TIM8 Update.               */\n#define TIM8_TRG_COM_IRQHandler VectorF4    /**< TIM8 Trigger and\n                                                 Commutation.               */\n#define TIM8_CC_IRQHandler      VectorF8    /**< TIM8 Capture Compare.      */\n#define DMA1_Stream7_IRQHandler VectorFC    /**< DMA1 Stream 7.             */\n#define FSMC_IRQHandler         Vector100   /**< FSMC.                      */\n#define SDIO_IRQHandler         Vector104   /**< SDIO.                      */\n#define TIM5_IRQHandler         Vector108   /**< TIM5.                      */\n#define SPI3_IRQHandler         Vector10C   /**< SPI3.                      */\n#define UART4_IRQHandler        Vector110   /**< UART4.                     */\n#define UART5_IRQHandler        Vector114   /**< UART5.                     */\n#define TIM6_IRQHandler         Vector118   /**< TIM6.                      */\n#define TIM7_IRQHandler         Vector11C   /**< TIM7.                      */\n#define DMA2_Stream0_IRQHandler Vector120   /**< DMA2 Stream0.              */\n#define DMA2_Stream1_IRQHandler Vector124   /**< DMA2 Stream1.              */\n#define DMA2_Stream2_IRQHandler Vector128   /**< DMA2 Stream2.              */\n#define DMA2_Stream3_IRQHandler Vector12C   /**< DMA2 Stream3.              */\n#define DMA2_Stream4_IRQHandler Vector130   /**< DMA2 Stream4.              */\n#define ETH_IRQHandler          Vector134   /**< Ethernet.                  */\n#define ETH_WKUP_IRQHandler     Vector138   /**< Ethernet Wakeup through\n                                                 EXTI line.                 */\n#define CAN2_TX_IRQHandler      Vector13C   /**< CAN2 TX.                   */\n#define CAN2_RX0_IRQHandler     Vector140   /**< CAN2 RX0.                  */\n#define CAN2_RX1_IRQHandler     Vector144   /**< CAN2 RX1.                  */\n#define CAN2_SCE_IRQHandler     Vector148   /**< CAN2 SCE.                  */\n#define OTG_FS_IRQHandler       Vector14C   /**< USB OTG FS.                */\n#define DMA2_Stream5_IRQHandler Vector150   /**< DMA2 Stream5.              */\n#define DMA2_Stream6_IRQHandler Vector154   /**< DMA2 Stream6.              */\n#define DMA2_Stream7_IRQHandler Vector158   /**< DMA2 Stream7.              */\n#define USART6_IRQHandler       Vector15C   /**< USART6.                    */\n#define I2C3_EV_IRQHandler      Vector160   /**< I2C3 Event.                */\n#define I2C3_ER_IRQHandler      Vector164   /**< I2C3 Error.                */\n#define OTG_HS_EP1_OUT_IRQHandler Vector168 /**< USB OTG HS End Point 1 Out.*/\n#define OTG_HS_EP1_IN_IRQHandler Vector16C  /**< USB OTG HS End Point 1 In. */\n#define OTG_HS_WKUP_IRQHandler  Vector170   /**< USB OTG HS Wakeup through\n                                                 EXTI line.                 */\n#define OTG_HS_IRQHandler       Vector174   /**< USB OTG HS.                */\n#define DCMI_IRQHandler         Vector178   /**< DCMI.                      */\n#define CRYP_IRQHandler         Vector17C   /**< CRYP.                      */\n#define HASH_RNG_IRQHandler     Vector180   /**< Hash and Rng.              */\n#define FPU_IRQHandler          Vector184   /**< Floating Point Unit.       */\n\n#endif /* ISR_VECTOR_TABLE_H_ */\n"
        },
        {
          "name": "ld_eeprom_emu.ld",
          "type": "blob",
          "size": 7.021484375,
          "content": "/*\r\n    ChibiOS - Copyright (C) 2006..2015 Giovanni Di Sirio.\r\n\r\n    This file is part of ChibiOS.\r\n\r\n    ChibiOS is free software; you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation; either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    ChibiOS is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\n * STM32F407xG memory setup.\r\n * Note: Use of ram1 and ram2 is mutually exclusive with use of ram0.\r\n * Note: flash2 length decreased by 8 bytes to use it as hardcoded CRC\r\n * flags.\r\n */\r\nMEMORY\r\n{\r\n    flash : org = 0x08000000, len = 16k\r\n    flash2 : org = 0x0800C000, len = 524288 - 16\t/* NEW_APP_MAX_SIZE - CRC_INFO */\r\n\tcrcinfo : org = 0x0807FFF0, len = 8\t\t/* CRC info */\r\n    ram0  : org = 0x20000000, len = 128k    /* SRAM1 + SRAM2 */\r\n    ram1  : org = 0x20000000, len = 112k    /* SRAM1 */\r\n    ram2  : org = 0x2001C000, len = 16k     /* SRAM2 */\r\n    ram3  : org = 0x00000000, len = 0\r\n    ram4  : org = 0x10000000, len = 62k     /* CCM SRAM */\r\n    libif : org = 0x1000F800, len = 2k\r\n    ram5  : org = 0x40024000, len = 4k      /* BCKP SRAM */\r\n    ram6  : org = 0x00000000, len = 0\r\n    ram7  : org = 0x00000000, len = 0\r\n}\r\n\r\n/* RAM region to be used for Main stack. This stack accommodates the processing\r\n   of all exceptions and interrupts*/\r\nREGION_ALIAS(\"MAIN_STACK_RAM\", ram0);\r\n\r\n/* RAM region to be used for the process stack. This is the stack used by\r\n   the main() function.*/\r\nREGION_ALIAS(\"PROCESS_STACK_RAM\", ram0);\r\n\r\n/* RAM region to be used for data segment.*/\r\nREGION_ALIAS(\"DATA_RAM\", ram0);\r\n\r\n/* RAM region to be used for BSS segment.*/\r\nREGION_ALIAS(\"BSS_RAM\", ram0);\r\n\r\n__ram0_start__          = ORIGIN(ram0);\r\n__ram0_size__           = LENGTH(ram0);\r\n__ram0_end__            = __ram0_start__ + __ram0_size__;\r\n__ram1_start__          = ORIGIN(ram1);\r\n__ram1_size__           = LENGTH(ram1);\r\n__ram1_end__            = __ram1_start__ + __ram1_size__;\r\n__ram2_start__          = ORIGIN(ram2);\r\n__ram2_size__           = LENGTH(ram2);\r\n__ram2_end__            = __ram2_start__ + __ram2_size__;\r\n__ram3_start__          = ORIGIN(ram3);\r\n__ram3_size__           = LENGTH(ram3);\r\n__ram3_end__            = __ram3_start__ + __ram3_size__;\r\n__ram4_start__          = ORIGIN(ram4);\r\n__ram4_size__           = LENGTH(ram4);\r\n__ram4_end__            = __ram4_start__ + __ram4_size__;\r\n__ram5_start__          = ORIGIN(ram5);\r\n__ram5_size__           = LENGTH(ram5);\r\n__ram5_end__            = __ram5_start__ + __ram5_size__;\r\n__ram6_start__          = ORIGIN(ram6);\r\n__ram6_size__           = LENGTH(ram6);\r\n__ram6_end__            = __ram6_start__ + __ram6_size__;\r\n__ram7_start__          = ORIGIN(ram7);\r\n__ram7_size__           = LENGTH(ram7);\r\n__ram7_end__            = __ram7_start__ + __ram7_size__;\r\n\r\nENTRY(Reset_Handler)\r\n\r\nSECTIONS\r\n{\r\n    . = 0;\r\n    _text = .;\r\n\r\n    startup : ALIGN(16) SUBALIGN(16)\r\n    {\r\n        KEEP(*(.vectors))\r\n    } > flash\r\n\r\n    constructors : ALIGN(4) SUBALIGN(4)\r\n    {\r\n        PROVIDE(__init_array_start = .);\r\n        KEEP(*(SORT(.init_array.*)))\r\n        KEEP(*(.init_array))\r\n        PROVIDE(__init_array_end = .);\r\n    } > flash2\r\n\r\n    destructors : ALIGN(4) SUBALIGN(4)\r\n    {\r\n        PROVIDE(__fini_array_start = .);\r\n        KEEP(*(.fini_array))\r\n        KEEP(*(SORT(.fini_array.*)))\r\n        PROVIDE(__fini_array_end = .);\r\n    } > flash2\r\n\r\n    .text : ALIGN(16) SUBALIGN(16)\r\n    {\r\n        *(.text)\r\n        *(.text.*)\r\n        *(.rodata)\r\n        *(.rodata.*)\r\n        *(.glue_7t)\r\n        *(.glue_7)\r\n        *(.gcc*)\r\n    } > flash2\r\n\r\n    .ARM.extab :\r\n    {\r\n        *(.ARM.extab* .gnu.linkonce.armextab.*)\r\n    } > flash2\r\n\r\n    .ARM.exidx : {\r\n        PROVIDE(__exidx_start = .);\r\n        *(.ARM.exidx* .gnu.linkonce.armexidx.*)\r\n        PROVIDE(__exidx_end = .);\r\n     } > flash2\r\n\r\n    .eh_frame_hdr :\r\n    {\r\n        *(.eh_frame_hdr)\r\n    } > flash2\r\n\r\n    .eh_frame : ONLY_IF_RO\r\n    {\r\n        *(.eh_frame)\r\n    } > flash2\r\n    \r\n    .textalign : ONLY_IF_RO\r\n    {\r\n        . = ALIGN(8);\r\n    } > flash2\r\n\r\n    . = ALIGN(4);\r\n    _etext = .;\r\n    _textdata = _etext;\r\n    \r\n    _crcinfo_start_address = 0x0807FFF0;\r\n    \r\n    .crcinfo _crcinfo_start_address :\r\n\t{\r\n\t\tKEEP(*(.crcinfo))\r\n\t}  > crcinfo\r\n\r\n    .mstack :\r\n    {\r\n        . = ALIGN(8);\r\n        __main_stack_base__ = .;\r\n        . += __main_stack_size__;\r\n        . = ALIGN(8);\r\n        __main_stack_end__ = .;\r\n    } > MAIN_STACK_RAM\r\n\r\n    .pstack :\r\n    {\r\n        __process_stack_base__ = .;\r\n        __main_thread_stack_base__ = .;\r\n        . += __process_stack_size__;\r\n        . = ALIGN(8);\r\n        __process_stack_end__ = .;\r\n        __main_thread_stack_end__ = .;\r\n    } > PROCESS_STACK_RAM\r\n\r\n    .data : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        PROVIDE(_data = .);\r\n        *(.data)\r\n        *(.data.*)\r\n        *(.ramtext)\r\n        . = ALIGN(4);\r\n        PROVIDE(_edata = .);\r\n    } > DATA_RAM AT > flash2\r\n\r\n    .bss : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        PROVIDE(_bss_start = .);\r\n        *(.bss)\r\n        *(.bss.*)\r\n        *(COMMON)\r\n        . = ALIGN(4);\r\n        PROVIDE(_bss_end = .);\r\n        PROVIDE(end = .);\r\n    } > BSS_RAM    \r\n\r\n    .ram0 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram0)\r\n        *(.ram0.*)\r\n        . = ALIGN(4);\r\n        __ram0_free__ = .;\r\n    } > ram0\r\n\r\n    .ram1 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram1)\r\n        *(.ram1.*)\r\n        . = ALIGN(4);\r\n        __ram1_free__ = .;\r\n    } > ram1\r\n\r\n    .ram2 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram2)\r\n        *(.ram2.*)\r\n        . = ALIGN(4);\r\n        __ram2_free__ = .;\r\n    } > ram2\r\n\r\n    .ram3 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram3)\r\n        *(.ram3.*)\r\n        . = ALIGN(4);\r\n        __ram3_free__ = .;\r\n    } > ram3\r\n\r\n    .ram4 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram4)\r\n        *(.ram4.*)\r\n        . = ALIGN(4);\r\n        __ram4_free__ = .;\r\n    } > ram4\r\n    \r\n    .libif (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.libif)\r\n    } > libif\r\n\r\n    .ram5 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram5)\r\n        *(.ram5.*)\r\n        . = ALIGN(4);\r\n        __ram5_free__ = .;\r\n    } > ram5\r\n\r\n    .ram6 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram6)\r\n        *(.ram6.*)\r\n        . = ALIGN(4);\r\n        __ram6_free__ = .;\r\n    } > ram6\r\n\r\n    .ram7 (NOLOAD) : ALIGN(4)\r\n    {\r\n        . = ALIGN(4);\r\n        *(.ram7)\r\n        *(.ram7.*)\r\n        . = ALIGN(4);\r\n        __ram7_free__ = .;\r\n    } > ram7\r\n}\r\n\r\n/* Heap default boundaries, it is defaulted to be the non-used part\r\n   of ram0 region.*/\r\n__heap_base__   = __ram0_free__;\r\n__heap_end__    = __ram0_end__;\r\n"
        },
        {
          "name": "libcanard",
          "type": "tree",
          "content": null
        },
        {
          "name": "lispBM",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 8.7294921875,
          "content": "/*\n\tCopyright 2016 - 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#pragma GCC push_options\n#pragma GCC optimize (\"Os\")\n\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"stm32f4xx_conf.h\"\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"mc_interface.h\"\n#include \"mcpwm.h\"\n#include \"mcpwm_foc.h\"\n#include \"ledpwm.h\"\n#include \"comm_usb.h\"\n#include \"ledpwm.h\"\n#include \"terminal.h\"\n#include \"hw.h\"\n#include \"app.h\"\n#include \"packet.h\"\n#include \"commands.h\"\n#include \"timeout.h\"\n#include \"encoder/encoder.h\"\n#include \"pwm_servo.h\"\n#include \"utils_math.h\"\n#include \"nrf_driver.h\"\n#include \"rfhelp.h\"\n#include \"spi_sw.h\"\n#include \"timer.h\"\n#include \"imu.h\"\n#include \"flash_helper.h\"\n#include \"conf_custom.h\"\n#include \"crc.h\"\n#include \"qmlui.h\"\n\n#if HAS_BLACKMAGIC\n#include \"bm_if.h\"\n#endif\n#include \"shutdown.h\"\n#include \"mempools.h\"\n#include \"events.h\"\n#include \"main.h\"\n\n#ifdef CAN_ENABLE\n#include \"comm_can.h\"\n#define CAN_FRAME_MAX_PL_SIZE\t8\n#endif\n\n#ifdef USE_LISPBM\n#include \"lispif.h\"\n#endif\n\n/*\n * HW resources used:\n *\n * TIM1: mcpwm\n * TIM2: mcpwm_foc\n * TIM5: timer\n * TIM8: mcpwm\n * TIM3: servo_dec/Encoder (HW_R2)/pwm_servo\n * TIM4: WS2811/WS2812 LEDs/Encoder (other HW)\n *\n * DMA/stream\tDevice\t\tFunction\n * 1, 2\t\t\tI2C1\t\tNunchuk, temp on rev 4.5\n * 1, 7\t\t\tI2C1\t\tNunchuk, temp on rev 4.5\n * 2, 4\t\t\tADC\t\t\tmcpwm\n *\n */\n\n// Private variables\nstatic THD_WORKING_AREA(periodic_thread_wa, 256);\nstatic THD_WORKING_AREA(led_thread_wa, 256);\nstatic THD_WORKING_AREA(flash_integrity_check_thread_wa, 256);\nstatic volatile bool m_init_done = false;\n\nstatic THD_FUNCTION(flash_integrity_check_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"Flash check\");\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, ENABLE);\n\n\tfor(;;) {\n\t\tif (flash_helper_verify_flash_memory_chunk() == FAULT_CODE_FLASH_CORRUPTION) {\n\t\t\tNVIC_SystemReset();\n\t\t}\n\n\t\tchThdSleepMilliseconds(6);\n\t}\n}\n\nstatic THD_FUNCTION(led_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"Main LED\");\n\n\tfor(;;) {\n\t\tmc_state state1 = mc_interface_get_state();\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_state state2 = mc_interface_get_state();\n\t\tmc_interface_select_motor_thread(1);\n\t\tif ((state1 == MC_STATE_RUNNING) || (state2 == MC_STATE_RUNNING)) {\n\t\t\tledpwm_set_intensity(LED_GREEN, 1.0);\n\t\t} else {\n\t\t\tledpwm_set_intensity(LED_GREEN, 0.2);\n\t\t}\n\n\t\tmc_fault_code fault = mc_interface_get_fault();\n\t\tmc_interface_select_motor_thread(2);\n\t\tmc_fault_code fault2 = mc_interface_get_fault();\n\t\tmc_interface_select_motor_thread(1);\n\t\tif (fault != FAULT_CODE_NONE || fault2 != FAULT_CODE_NONE) {\n\t\t\tfor (int i = 0;i < (int)fault;i++) {\n\t\t\t\tledpwm_set_intensity(LED_RED, 1.0);\n\t\t\t\tchThdSleepMilliseconds(250);\n\t\t\t\tledpwm_set_intensity(LED_RED, 0.0);\n\t\t\t\tchThdSleepMilliseconds(250);\n\t\t\t}\n\n\t\t\tchThdSleepMilliseconds(500);\n\n\t\t\tfor (int i = 0;i < (int)fault2;i++) {\n\t\t\t\tledpwm_set_intensity(LED_RED, 1.0);\n\t\t\t\tchThdSleepMilliseconds(250);\n\t\t\t\tledpwm_set_intensity(LED_RED, 0.0);\n\t\t\t\tchThdSleepMilliseconds(250);\n\t\t\t}\n\n\t\t\tchThdSleepMilliseconds(500);\n\t\t} else {\n\t\t\tledpwm_set_intensity(LED_RED, 0.0);\n\t\t}\n\n\t\tchThdSleepMilliseconds(10);\n\t}\n}\n\nstatic THD_FUNCTION(periodic_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"Main periodic\");\n\n\tfor(;;) {\n\t\tif (mc_interface_get_state() == MC_STATE_DETECTING) {\n\t\t\tcommands_send_rotor_pos(mcpwm_get_detect_pos());\n\t\t}\n\n\t\tdisp_pos_mode display_mode = commands_get_disp_pos_mode();\n\n\t\tswitch (display_mode) {\n\t\tcase DISP_POS_MODE_ENCODER:\n\t\t\tcommands_send_rotor_pos(encoder_read_deg());\n\t\t\tbreak;\n\n\t\tcase DISP_POS_MODE_PID_POS:\n\t\t\tcommands_send_rotor_pos(mc_interface_get_pid_pos_now());\n\t\t\tbreak;\n\n\t\tcase DISP_POS_MODE_PID_POS_ERROR:\n\t\t\tcommands_send_rotor_pos(utils_angle_difference(mc_interface_get_pid_pos_set(), mc_interface_get_pid_pos_now()));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mc_interface_get_configuration()->motor_type == MOTOR_TYPE_FOC) {\n\t\t\tswitch (display_mode) {\n\t\t\tcase DISP_POS_MODE_OBSERVER:\n\t\t\t\tcommands_send_rotor_pos(mcpwm_foc_get_phase_observer());\n\t\t\t\tbreak;\n\n\t\t\tcase DISP_POS_MODE_ENCODER_OBSERVER_ERROR:\n\t\t\t\tcommands_send_rotor_pos(utils_angle_difference(mcpwm_foc_get_phase_observer(), mcpwm_foc_get_phase_encoder()));\n\t\t\t\tbreak;\n\n\t\t\tcase DISP_POS_MODE_HALL_OBSERVER_ERROR:\n\t\t\t\tcommands_send_rotor_pos(utils_angle_difference(mcpwm_foc_get_phase_observer(), mcpwm_foc_get_phase_hall()));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t \n\t\tHW_TRIM_HSI(); // Compensate HSI for temperature\n\n\t\tchThdSleepMilliseconds(10);\n\t}\n}\n\n// When assertions enabled halve PWM frequency. The control loop ISR runs 40% slower\nvoid assert_failed(uint8_t* file, uint32_t line) {\n\tcommands_printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line);\n\tmc_interface_release_motor();\n\twhile(1) {\n\t\tchThdSleepMilliseconds(1);\n\t}\n}\n\nbool main_init_done(void) {\n\treturn m_init_done;\n}\n\nuint32_t main_calc_hw_crc(void) {\n\tuint32_t crc = 0;\n\n#ifdef QMLUI_SOURCE_HW\n\tcrc = crc32_with_init(data_qml_hw, DATA_QML_HW_SIZE, crc);\n#endif\n\n\tfor (int i = 0;i < conf_custom_cfg_num();i++) {\n\t\tuint8_t *data = 0;\n\t\tint len = conf_custom_get_cfg_xml(i, &data);\n\t\tif (len > 0) {\n\t\t\tcrc = crc32_with_init(data, len, crc);\n\t\t}\n\t}\n\n\tif (flash_helper_code_size(CODE_IND_QML) > 0) {\n\t\tcrc = crc32_with_init(\n\t\t\t\tflash_helper_code_data(CODE_IND_QML),\n\t\t\t\tflash_helper_code_size(CODE_IND_QML),\n\t\t\t\tcrc);\n\t}\n\n\treturn crc;\n}\n\nint main(void) {\n\thalInit();\n\tchSysInit();\n\n\t// Initialize the enable pins here and disable them\n\t// to avoid excessive current draw at boot because of\n\t// floating pins.\n#ifdef HW_HAS_DRV8313\n\tINIT_BR();\n#endif\n\n\tHW_EARLY_INIT();\n\n#ifdef BOOT_OK_GPIO\n\tpalSetPadMode(BOOT_OK_GPIO, BOOT_OK_PIN, PAL_MODE_OUTPUT_PUSHPULL);\n\tpalClearPad(BOOT_OK_GPIO, BOOT_OK_PIN);\n#endif\n\n\tchThdSleepMilliseconds(100);\n\n\tmempools_init();\n\tevents_init();\n\ttimer_init(); // Initialize timer here to allow I2C in hw_init\n\thw_init_gpio();\n\tLED_RED_OFF();\n\tLED_GREEN_OFF();\n\n\tconf_general_init();\n\n\tif (flash_helper_verify_flash_memory() == FAULT_CODE_FLASH_CORRUPTION)\t{\n\t\t// Loop here, it is not safe to run any code\n\t\twhile (1) {\n\t\t\tchThdSleepMilliseconds(100);\n\t\t\tLED_RED_ON();\n\t\t\tchThdSleepMilliseconds(75);\n\t\t\tLED_RED_OFF();\n\t\t}\n\t}\n\n\tledpwm_init();\n\tmc_interface_init();\n\n\tcommands_init();\n\n#if COMM_USE_USB\n\tcomm_usb_init();\n#endif\n\n\tapp_uartcomm_initialize();\n\tapp_configuration *appconf = mempools_alloc_appconf();\n\tconf_general_read_app_configuration(appconf);\n\tapp_uartcomm_start(UART_PORT_BUILTIN);\n\tapp_uartcomm_start(UART_PORT_EXTRA_HEADER);\n\tapp_set_configuration(appconf);\n\n\t// This reads the appconf, that must be initialized first.\n#if CAN_ENABLE\n\tcomm_can_init();\n#endif\n\n#ifdef HW_HAS_PERMANENT_NRF\n\tconf_general_permanent_nrf_found = nrf_driver_init();\n\tif (conf_general_permanent_nrf_found) {\n\t\trfhelp_restart();\n\t} else {\n\t\tnrf_driver_stop();\n\t\t// Set the nrf SPI pins to the general SPI interface so that\n\t\t// an external NRF can be used with the NRF app.\n\t\tspi_sw_change_pins(\n\t\t\t\tHW_SPI_PORT_NSS, HW_SPI_PIN_NSS,\n\t\t\t\tHW_SPI_PORT_SCK, HW_SPI_PIN_SCK,\n\t\t\t\tHW_SPI_PORT_MOSI, HW_SPI_PIN_MOSI,\n\t\t\t\tHW_SPI_PORT_MISO, HW_SPI_PIN_MISO);\n\t\tHW_PERMANENT_NRF_FAILED_HOOK();\n\t}\n#endif\n\n\t// Threads\n\tchThdCreateStatic(led_thread_wa, sizeof(led_thread_wa), NORMALPRIO, led_thread, NULL);\n\tchThdCreateStatic(periodic_thread_wa, sizeof(periodic_thread_wa), NORMALPRIO, periodic_thread, NULL);\n\tchThdCreateStatic(flash_integrity_check_thread_wa, sizeof(flash_integrity_check_thread_wa), LOWPRIO, flash_integrity_check_thread, NULL);\n\n\ttimeout_init();\n\ttimeout_configure(appconf->timeout_msec, appconf->timeout_brake_current, appconf->kill_sw_mode);\n\n#if HAS_BLACKMAGIC\n\tbm_init();\n#endif\n\n\tshutdown_init();\n\n\timu_reset_orientation();\n\n\tchThdSleepMilliseconds(500);\n\tm_init_done = true;\n\n#ifdef BOOT_OK_GPIO\n\tpalSetPad(BOOT_OK_GPIO, BOOT_OK_PIN);\n#endif\n\n#ifdef CAN_ENABLE\n\t// Transmit a CAN boot-frame to notify other nodes on the bus about it.\n\tif (appconf->can_mode == CAN_MODE_VESC) {\n\t\tcomm_can_transmit_eid(\n\t\t\t\tapp_get_configuration()->controller_id | (CAN_PACKET_NOTIFY_BOOT << 8),\n\t\t\t\t(uint8_t *)HW_NAME, (strlen(HW_NAME) <= CAN_FRAME_MAX_PL_SIZE) ?\n\t\t\t\t\t\tstrlen(HW_NAME) : CAN_FRAME_MAX_PL_SIZE);\n\t}\n#endif\n\n\tmempools_free_appconf(appconf);\n\n\tfor(;;) {\n\t\tchThdSleepMilliseconds(10);\n\t}\n}\n\n#pragma GCC pop_options\n"
        },
        {
          "name": "main.h",
          "type": "blob",
          "size": 0.85546875,
          "content": "/*\n\tCopyright 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MAIN_H_\n#define MAIN_H_\n\nbool main_init_done(void);\nuint32_t main_calc_hw_crc(void);\n\n#endif /* MAIN_H_ */\n"
        },
        {
          "name": "make",
          "type": "tree",
          "content": null
        },
        {
          "name": "motor",
          "type": "tree",
          "content": null
        },
        {
          "name": "package_firmware.py",
          "type": "blob",
          "size": 13.619140625,
          "content": "import shutil\nimport os\nimport subprocess\n\n# https://stackoverflow.com/questions/14989858/get-the-current-git-hash-in-a-python-script\ndef get_git_revision_short_hash() -> str:\n    return subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode('ascii').strip()\n\n# Get the origin and destination directories\nbuild_dir = os.path.dirname(os.path.abspath(__file__)) + '/build'\npackage_dir = os.path.dirname(os.path.abspath(__file__)) + '/package'\n\n# Get the short git hash\ngit_hash = get_git_revision_short_hash()\n\n# Define default destination filenames\nno_limits_name = \"VESC_default_no_hw_limits.bin\"\ndefault_name = \"VESC_default.bin\"\n\n# Add directories and targets to the dictionary\n# package_dict[\"group name diplayed in firmware tab of the vesc tool\"] = [['.c filename minus the hw_', 'compiled .bin filename']]\npackage_dict = {}\npackage_dict[\"46_o_47\"] = [['46', default_name],\n                    ['46_33k', 'VESC_33k.bin'],\n                    ['46_0005ohm', 'VESC_0005ohm.bin']]\npackage_dict[\"48\"] = [['48', default_name]]\npackage_dict[\"410_o_411_o_412\"] = [['410', default_name],\n                    ['410_no_limits', no_limits_name],\n                    ['410_0005ohm', 'VESC_0005ohm.bin'],\n                    ['410_005ohm', 'VESC_005ohm.bin']]\npackage_dict[\"60\"] = [['60', default_name],\n                    ['60_no_limits', no_limits_name]]\npackage_dict[\"60_MK3\"] = [['60_mk3', default_name],\n                    ['60_mk3_no_limits', no_limits_name]]\npackage_dict[\"60_MK4\"] = [['60_mk4', default_name],\n                    ['60_mk4_no_limits', no_limits_name]]\npackage_dict[\"60_MK5\"] = [['60_mk5', default_name],\n                    ['60_mk5_no_limits', no_limits_name]]\npackage_dict[\"60_MK6\"] = [['60_mk6', default_name],\n                    ['60_mk6_no_limits', no_limits_name]]\npackage_dict[\"60_MK6_MAX\"] = [['60_mk6_max', default_name]]\npackage_dict[\"DAS_RS\"] = [['das_rs', default_name]]\npackage_dict[\"75_300\"] = [['75_300', default_name],\n                    ['75_300_no_limits', no_limits_name]]\npackage_dict[\"75_300_R2\"] = [['75_300_r2', default_name],\n                    ['75_300_r2_no_limits', no_limits_name]]\npackage_dict[\"75_300_R3\"] = [['75_300_r3', default_name],\n                    ['75_300_r3_no_limits', no_limits_name]]\npackage_dict[\"AXIOM\"] = [['axiom', default_name]]\npackage_dict[\"UAVC_OMEGA\"] = [['uavc_omega', default_name]]\npackage_dict[\"HD60\"] = [['hd60', default_name],\n                    ['hd60_no_limits', no_limits_name]]\npackage_dict[\"HD75\"] = [['hd75', default_name],\n                    ['hd75_no_limits', no_limits_name]]\npackage_dict[\"A50S_6S\"] = [['a50s_v22_6s', default_name]]\npackage_dict[\"A50S_6S_HG\"] = [['a50s_v22_6s_hg', default_name]]\npackage_dict[\"A50S_12S\"] = [['a50s_v22_12s', default_name]]\npackage_dict[\"A50S_12S_HG\"] = [['a50s_v22_12s_hg', default_name]]\npackage_dict[\"A50S_V23_6S\"] = [['a50s_v23_6s', default_name]]\npackage_dict[\"A50S_V23_8S\"] = [['a50s_v23_8s', default_name]]\npackage_dict[\"A50S_V23_12S\"] = [['a50s_v23_12s', default_name]]\npackage_dict[\"A50S_V23c_8S\"] = [['a50s_v23c_8s', default_name]]\npackage_dict[\"A50S_V23c_12S\"] = [['a50s_v23c_12s', default_name]]\npackage_dict[\"A50S_V23_20S\"] = [['a50s_v23_20s', default_name]]\npackage_dict[\"A100S_V4\"] = [['a100s_v4', default_name]]\npackage_dict[\"A200S_V2.1\"] = [['a200s_v2.1', default_name]]\npackage_dict[\"A200S_V2.2\"] = [['a200s_v2.2', default_name]]\npackage_dict[\"A200S_V3\"] = [['a200s_v3', default_name]]\npackage_dict[\"A200S_V4\"] = [['a200s_v4', default_name]]\npackage_dict[\"A200S_V41\"] = [['a200s_v41', default_name]]\npackage_dict[\"100_250\"] = [['100_250', default_name],\n                    ['100_250_no_limits', no_limits_name]]\npackage_dict[\"100_250_MKIII\"] = [['100_250_mkiii', default_name],\n                    ['100_250_mkiii_no_limits', no_limits_name]]\npackage_dict[\"LUNA_BBSHD\"] = [['luna_bbshd', default_name]]\npackage_dict[\"LUNA_M600\"] = [['luna_m600', default_name]]\npackage_dict[\"LUNA_M600_V2\"] = [['luna_m600', default_name]]\npackage_dict[\"LUNA_M600_V2_Rev5\"] = [['luna_m600_Rev5', default_name]]\npackage_dict[\"LUNA_M600_V2_Rev5_60V\"] = [['luna_m600_Rev5_60V', default_name]]\npackage_dict[\"UNITY\"] = [['unity', default_name],\n                    ['unity_no_limits', no_limits_name]]\npackage_dict[\"Cheap_FOCer_2\"] = [['Cheap_FOCer_2', default_name],\n                    ['Cheap_FOCer_2_no_limits', no_limits_name]]\npackage_dict[\"Cheap_FOCer_2_V09\"] = [['Cheap_FOCer_2_V09', default_name],\n                    ['Cheap_FOCer_2_V09_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_60D\"] = [['stormcore_60d', default_name],\n                    ['stormcore_60d_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_60Dxs\"] = [['stormcore_60dxs', default_name],\n                    ['stormcore_60dxs_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_60D+\"] = [['stormcore_60d+', default_name],\n                    ['stormcore_60d+_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_100D\"] = [['stormcore_100d', default_name],\n                    ['stormcore_100d_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_100D_V2\"] = [['stormcore_100d_v2', default_name],\n                    ['stormcore_100d_v2_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_100DX\"] = [['stormcore_100dx', default_name],\n                    ['stormcore_100dx_no_limits', no_limits_name]]\npackage_dict[\"STORMCORE_100S\"] = [['stormcore_100s', default_name],\n                    ['stormcore_100s_no_limits', no_limits_name]]\npackage_dict[\"Little_FOCer\"] = [['Little_FOCer', default_name]]\npackage_dict[\"Little_FOCer_V3\"] = [['Little_FOCer_V3', default_name]]\npackage_dict[\"Little_FOCer_V3_1\"] = [['Little_FOCer_V3_1', default_name]]\npackage_dict[\"Little_FOCer_V4\"] = [['Little_FOCer_V4', default_name]]\npackage_dict[\"TRONIC_250R\"] = [['TRONIC_250R', default_name]]\npackage_dict[\"X12_PRO24\"] = [['x12_pro24', default_name]]\npackage_dict[\"X12_PRO30\"] = [['x12_pro30', default_name]]\npackage_dict[\"Thor300\"] = [['Thor300_20s', default_name]]\npackage_dict[\"JetFleetF6\"] = [['JetFleetF6', default_name]]\npackage_dict[\"UXV_SR\"] = [['uxv_sr', default_name]]\npackage_dict[\"GESC\"] = [['gesc', default_name]]\npackage_dict[\"Warrior6\"] = [['warrior6', default_name]]\npackage_dict[\"Raiden7\"] = [['raiden7', default_name]]\npackage_dict[\"ADV200\"] = [['adv200', default_name]]\npackage_dict[\"ADV500\"] = [['adv500', default_name]]\npackage_dict[\"100_500\"] = [['100_500', default_name],\n                    ['100_500_no_limits', no_limits_name]]\npackage_dict[\"75_600\"] = [['75_600', default_name],\n                    ['75_600_no_limits', no_limits_name]]\npackage_dict[\"60v2_alva\"] = [['60v2_alva', default_name]]\npackage_dict[\"60v2_alva_mk1\"] = [['60v2_alva_mk1', default_name]]\npackage_dict[\"60v2_alva_mk2\"] = [['60v2_alva_mk2', default_name]]\npackage_dict[\"gp\"] = [['gp', default_name]]\npackage_dict[\"60_75\"] = [['60_75', default_name],\n                    ['60_75_no_limits', no_limits_name]]\npackage_dict[\"60_75_mk2\"] = [['60_75_mk2', default_name],\n                    ['60_75_mk2_no_limits', no_limits_name]]\npackage_dict[\"UBOX_SINGLE_75\"] = [['ubox_single_75', default_name],\n                                  ['ubox_single_75_no_limits', no_limits_name]]\npackage_dict[\"UBOX_V1_75_MICRO\"] = [['ubox_v1_75_micro', default_name],\n                                    ['ubox_v1_75_micro_no_limits', no_limits_name]]\npackage_dict[\"UBOX_V1_75_TYPEC\"] = [['ubox_v1_75_typec', default_name],\n                                    ['ubox_v1_75_typec_no_limits', no_limits_name]]\npackage_dict[\"UBOX_V2_75\"] = [['ubox_v2_75', default_name],\n                              ['ubox_v2_75_no_limits', no_limits_name]]\npackage_dict[\"UBOX_SINGLE_100\"] = [['ubox_single_100', default_name],\n                                   ['ubox_single_100_no_limits', no_limits_name]]\npackage_dict[\"UBOX_SINGLE_80\"] = [['ubox_single_80', default_name],\n                                  ['ubox_single_80_no_limits', no_limits_name]]\npackage_dict[\"UBOX_SINGLE_85_200\"] = [['ubox_single_85_200', default_name],\n                                  ['ubox_single_85_200_no_limits', no_limits_name]]\npackage_dict[\"UBOX_V2_100\"] = [['ubox_v2_100', default_name],\n                               ['ubox_v2_100_no_limits', no_limits_name]]\npackage_dict[\"EDU\"] = [['edu', default_name],\n                    ['edu_no_limits', no_limits_name]]\npackage_dict[\"75_300_MKIV\"] = [['75_300_mkiv', default_name],\n                    ['75_300_mkiv_no_limits', no_limits_name]]\npackage_dict[\"60_MK6_HP\"] = [['60_mk6_hp', default_name],\n                    ['60_mk6_hp_no_limits', no_limits_name]]\npackage_dict[\"KA160\"] = [['ka160', default_name]]\npackage_dict[\"75_100\"] = [['75_100', default_name],\n                    ['75_100_no_limits', no_limits_name]]\npackage_dict[\"75_100_V2\"] = [['75_100_V2', default_name],\n                    ['75_100_V2_no_limits', no_limits_name],\n                    ['75_100_V2_0005ohm', 'VESC_0005ohm.bin']]\npackage_dict[\"FSESC75300\"] = [['fsesc_75_300', default_name]]\npackage_dict[\"GO_FOC_DV6_PRO\"] = [['go_foc_dv6_pro', default_name],\n                    ['go_foc_dv6_pro_no_limits', no_limits_name]]\npackage_dict[\"GO_FOC_G300\"] = [['go_foc_g300', default_name],\n                    ['go_foc_g300_no_limits', no_limits_name]]\npackage_dict[\"GO_FOC_HI200\"] = [['go_foc_hi200', default_name],\n                    ['go_foc_hi200_no_limits', no_limits_name]]\npackage_dict[\"GO_FOC_HV200\"] = [['go_foc_hv200', default_name],\n                    ['go_foc_hv200_no_limits', no_limits_name]]\npackage_dict[\"GO_FOC_M100\"] = [['go_foc_m100', default_name],\n                    ['go_foc_m100_no_limits', no_limits_name]]\npackage_dict[\"SOLO\"] = [['solo', default_name],\n                    ['solo_no_limits', no_limits_name]]\npackage_dict[\"FSESC_75_200_ALU\"] = [['fsesc_75_200_alu', default_name],\n                    ['fsesc_75_200_alu_no_limits', no_limits_name]]\npackage_dict[\"MKSESC_75_100\"] = [['mksesc_75_100', default_name],\n                    ['mksesc_75_100_no_limits', no_limits_name]]\npackage_dict[\"MKSESC_75_100_OLD\"] = [['mksesc_75_100_old', default_name],\n                    ['mksesc_75_100_old_no_limits', no_limits_name]]\npackage_dict[\"MKSESC_75_100_V2\"] = [['mksesc_75_100_v2', default_name],\n                    ['mksesc_75_100_v2_no_limits', no_limits_name]]      \npackage_dict[\"MKSESC_75_100_V2_OLD\"] = [['mksesc_75_100_v2_old', default_name],\n                    ['mksesc_75_100_v2_old_no_limits', no_limits_name]]                \npackage_dict[\"MKSESC_75_200_V2\"] = [['mksesc_75_200_v2', default_name],\n                    ['mksesc_75_200_v2_no_limits', no_limits_name]]\npackage_dict[\"MKSESC_75_200_V2_OLD\"] = [['mksesc_75_200_v2_old', default_name],\n                    ['mksesc_75_200_v2_old_no_limits', no_limits_name]]\npackage_dict[\"MKSESC_84_100_HP\"] = [['mksesc_84_100_hp', default_name],\n                    ['mksesc_84_100_hp_no_limits', no_limits_name]]                    \npackage_dict[\"MKSESC_84_200_HP\"] = [['mksesc_84_200_hp', default_name],\n                    ['mksesc_84_200_hp_no_limits', no_limits_name]] \npackage_dict[\"MKSESC_100_300_HP\"] = [['mksesc_100_300_hp', default_name],\n                    ['mksesc_100_300_hp_no_limits', no_limits_name]] \npackage_dict[\"STR500\"] = [['str500', default_name],\n                    ['str500_no_limits', no_limits_name]]\npackage_dict[\"STR500_01\"] = [['str500_01', default_name]]\npackage_dict[\"STR500_HP\"] = [['str500_hp', default_name],\n                    ['str500_hp_no_limits', no_limits_name]]\npackage_dict[\"RB\"] = [['rb', default_name]]\npackage_dict[\"STR365\"] = [['str365', default_name],\n                    ['str365_no_limits', no_limits_name]]\npackage_dict[\"SPARKF\"] = [['sparkf', default_name]]\npackage_dict[\"VESC_BASIC\"] = [['basic', default_name],\n                    ['basic_no_limits', no_limits_name]]\npackage_dict[\"VESC_BASIC_035\"] = [['basic_035', default_name],\n                    ['basic_035_no_limits', no_limits_name]]\npackage_dict[\"VESC_BASIC_025\"] = [['basic_025', default_name],\n                    ['basic_025_no_limits', no_limits_name]]\npackage_dict[\"RSR_DD_V1\"] = [['RSR_DD_V1', default_name],\n                    ['RSR_DD_V1_005', 'RSR_DD_V1_005.bin']]\npackage_dict[\"RSR_DD_V2\"] = [['RSR_DD_V2', default_name]]\npackage_dict[\"RSR_DD_V2.1\"] = [['RSR_DD_V2.1', default_name]]\n\n# This is the firmware stub string\nres_firmwares_string = '        <file>TARGET_DESTINATION_DIRECTORY/TARGET_DESTINATION_FILENAME</file>\\n'\n\n# This is the XML stub string\nresource_xml_stub_string = '''\n<RCC>\n   <qresource prefix=\"/res/firmwares/\">\nREPLACEABLE_STRING\n   </qresource>\n</RCC>\n'''\n\n# Declare an empty string\nres_string = \"\"\n\n# Iterate over all directories in the dictionary\nfor directory in package_dict:\n\n    # Set the destination path\n    destination_path = os.path.join(package_dir, directory)\n\n    # Create the destination directory\n    os.makedirs(destination_path, exist_ok=True)\n\n    # Iterate over each target\n    for target in package_dict[directory]:\n        # Shorthand variable\n        destination_file_name = target[1]\n        destination_full_path = os.path.join(destination_path, destination_file_name)\n        origin_file_name = target[0] + '.bin'\n        origin_full_path = os.path.join(build_dir, target[0], origin_file_name)\n\n        # Skip firmware that has not been built\n        if not os.path.isfile(origin_full_path):\n            continue\n\n        # Copy the file\n        shutil.copy(origin_full_path, destination_full_path)\n\n        # Replace the stub string with the target specifics\n        target_res_string = res_firmwares_string.replace(\"TARGET_DESTINATION_DIRECTORY\", directory).replace(\"TARGET_DESTINATION_FILENAME\", destination_file_name)\n\n        # Add this string to the master Qt resource string\n        res_string = res_string + target_res_string\n\n# Print the QRC file\nwith open(os.path.join(package_dir, 'res_fw.qrc'), 'w') as f:\n    print(resource_xml_stub_string.replace(\"REPLACEABLE_STRING\", res_string[:-1]), file=f)\n\n"
        },
        {
          "name": "pi_stm32.cfg",
          "type": "blob",
          "size": 0.3115234375,
          "content": "source [find interface/raspberrypi2-native.cfg]\ntransport select swd\n \nset CHIPNAME stm32f4x\nsource [find target/stm32f4x.cfg]\n \n# did not yet manage to make a working setup using srst\n#reset_config srst_only\nreset_config  srst_nogate\n \nadapter_nsrst_delay 100\nadapter_nsrst_assert_width 100\n \ninit\ntargets\nreset halt\n\n"
        },
        {
          "name": "qmlui",
          "type": "tree",
          "content": null
        },
        {
          "name": "stm32-bv_openocd.cfg",
          "type": "blob",
          "size": 0.154296875,
          "content": "source [find interface/stlink-v2.cfg]\nsource [find target/stm32f4x_stlink.cfg]\n\n# use hardware reset, connect under reset\nreset_config srst_only srst_nogate\n\n"
        },
        {
          "name": "terminal.c",
          "type": "blob",
          "size": 51.2373046875,
          "content": "/*\n\tCopyright 2016 - 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#pragma GCC push_options\n#pragma GCC optimize (\"Os\")\n\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"terminal.h\"\n#include \"mcpwm.h\"\n#include \"mcpwm_foc.h\"\n#include \"mc_interface.h\"\n#include \"commands.h\"\n#include \"hw.h\"\n#include \"comm_can.h\"\n#include \"utils_math.h\"\n#include \"utils_sys.h\"\n#include \"timeout.h\"\n#include \"encoder/encoder.h\"\n#include \"app.h\"\n#include \"comm_usb.h\"\n#include \"comm_usb_serial.h\"\n#include \"mempools.h\"\n#include \"crc.h\"\n#include \"firmware_metadata.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <math.h>\n\n// Settings\n#define FAULT_VEC_LEN\t\t\t\t\t\t25\n#define CALLBACK_LEN\t\t\t\t\t\t40\n\n// Private types\ntypedef struct _terminal_callback_struct {\n\tconst char *command;\n\tconst char *help;\n\tconst char *arg_names;\n\tvoid(*cbf)(int argc, const char **argv);\n} terminal_callback_struct;\n\n// Private variables\nstatic volatile fault_data fault_vec[FAULT_VEC_LEN];\nstatic volatile int fault_vec_write = 0;\nstatic terminal_callback_struct callbacks[CALLBACK_LEN];\nstatic int callback_write = 0;\n\nvoid terminal_process_string(char *str) {\n\t// Echo command so user can see what they previously ran\n\tcommands_printf(\"-> %s \\n\", str);\n\n\tenum { kMaxArgs = 64 };\n\tint argc = 0;\n\tchar *argv[kMaxArgs];\n\n\tchar *p2 = strtok(str, \" \");\n\twhile (p2 && argc < kMaxArgs) {\n\t\targv[argc++] = p2;\n\t\tp2 = strtok(0, \" \");\n\t}\n\n\tif (argc == 0) {\n\t\tcommands_printf(\"No command received\\n\");\n\t\treturn;\n\t}\n\n\t// force command argument to be lowercase\n\tfor(int i = 0; argv[0][i] != '\\0'; i++){\n  \t\targv[0][i] = tolower(argv[0][i]);\n\t}\n\n\tfor (int i = 0;i < callback_write;i++) {\n\t\tif (callbacks[i].cbf != 0 && strcmp(argv[0], callbacks[i].command) == 0) {\n\t\t\tcallbacks[i].cbf(argc, (const char**)argv);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"last_adc_duration\") == 0) {\n\t\tcommands_printf(\"Latest ADC duration: %.4f ms\", (double)(mcpwm_get_last_adc_isr_duration() * 1000.0));\n\t\tcommands_printf(\"Latest injected ADC duration: %.4f ms\", (double)(mc_interface_get_last_inj_adc_isr_duration() * 1000.0));\n\t\tcommands_printf(\"Latest sample ADC duration: %.4f ms\\n\", (double)(mc_interface_get_last_sample_adc_isr_duration() * 1000.0));\n\t} else if (strcmp(argv[0], \"kv\") == 0) {\n\t\tcommands_printf(\"Calculated KV: %.2f rpm/volt\\n\", (double)mcpwm_get_kv_filtered());\n\t} else if (strcmp(argv[0], \"mem\") == 0) {\n\t\tsize_t n, size;\n\t\tn = chHeapStatus(NULL, &size);\n\t\tcommands_printf(\"core free memory : %u bytes\", chCoreGetStatusX());\n\t\tcommands_printf(\"heap fragments   : %u\", n);\n\t\tcommands_printf(\"heap free total  : %u bytes\\n\", size);\n\t} else if (strcmp(argv[0], \"threads\") == 0) {\n\t\tthread_t *tp;\n\t\tstatic const char *states[] = {CH_STATE_NAMES};\n\t\tstatic systime_t last_check_time = 0;\n\t\tcommands_printf(\"    addr    stack prio refs     state           name motor stackmin  time    \");\n\t\tcommands_printf(\"-----------------------------------------------------------------------------\");\n\t\ttp = chRegFirstThread();\n\t\tdo {\n\t\t\tint stack_left = utils_check_min_stack_left(tp);\n\t\t\tcommands_printf(\"%.8lx %.8lx %4lu %4lu %9s %14s %5lu %8d  %lu (%.1f %%)\",\n\t\t\t\t\t(uint32_t)tp, (uint32_t)tp->p_ctx.r13,\n\t\t\t\t\t(uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),\n\t\t\t\t\tstates[tp->p_state], tp->p_name, tp->motor_selected, stack_left, (uint32_t)tp->p_time,\n\t\t\t\t\t(double)(100.0 * (float)tp->p_time / (float)(chVTGetSystemTimeX() - last_check_time)));\n\t\t\ttp->p_time = 0;\n\t\t\ttp = chRegNextThread(tp);\n\t\t} while (tp != NULL);\n\t\tlast_check_time = chVTGetSystemTimeX();\n\t\tcommands_printf(\" \");\n\t} else if (strcmp(argv[0], \"fault\") == 0) {\n\t\tcommands_printf(\"%s\\n\", mc_interface_fault_to_string(mc_interface_get_fault()));\n\t} else if (strcmp(argv[0], \"faults\") == 0) {\n\t\tif (fault_vec_write == 0) {\n\t\t\tcommands_printf(\"No faults registered since startup\\n\");\n\t\t} else {\n\t\t\tcommands_printf(\"Active fault: %s\\n\", mc_interface_fault_to_string(mc_interface_get_fault()));\n\t\t\tcommands_printf(\"The following faults were registered since start:\\n\");\n\t\t\tfor (int i = 0;i < fault_vec_write;i++) {\n\t\t\t\tcommands_printf(\"Fault            : %s\", mc_interface_fault_to_string(fault_vec[i].fault));\n\t\t\t\tcommands_printf(\"Motor            : %d\", fault_vec[i].motor);\n\t\t\t\tcommands_printf(\"Current          : %.1f\", (double)fault_vec[i].current);\n\t\t\t\tcommands_printf(\"Current filtered : %.1f\", (double)fault_vec[i].current_filtered);\n\t\t\t\tcommands_printf(\"Voltage          : %.2f\", (double)fault_vec[i].voltage);\n#ifdef HW_HAS_GATE_DRIVER_SUPPLY_MONITOR\n\t\t\t\tcommands_printf(\"Gate drv voltage : %.2f\", (double)fault_vec[i].gate_driver_voltage);\n#endif\n\t\t\t\tcommands_printf(\"Duty             : %.3f\", (double)fault_vec[i].duty);\n\t\t\t\tcommands_printf(\"RPM              : %.1f\", (double)fault_vec[i].rpm);\n\t\t\t\tcommands_printf(\"Tacho            : %d\", fault_vec[i].tacho);\n\t\t\t\tcommands_printf(\"Cycles running   : %d\", fault_vec[i].cycles_running);\n\t\t\t\tcommands_printf(\"TIM duty         : %d\", (int)((float)fault_vec[i].tim_top * fault_vec[i].duty));\n\t\t\t\tcommands_printf(\"TIM val samp     : %d\", fault_vec[i].tim_val_samp);\n\t\t\t\tcommands_printf(\"TIM current samp : %d\", fault_vec[i].tim_current_samp);\n\t\t\t\tcommands_printf(\"TIM top          : %d\", fault_vec[i].tim_top);\n\t\t\t\tcommands_printf(\"Comm step        : %d\", fault_vec[i].comm_step);\n\t\t\t\tcommands_printf(\"Temperature      : %.2f\", (double)fault_vec[i].temperature);\n#ifdef HW_HAS_DRV8301\n\t\t\t\tif (fault_vec[i].fault == FAULT_CODE_DRV) {\n\t\t\t\t\tcommands_printf(\"DRV8301_FAULTS   : %s\", drv8301_faults_to_string(fault_vec[i].drv8301_faults));\n\t\t\t\t}\n#elif defined(HW_HAS_DRV8320S)\n\t\t\t\tif (fault_vec[i].fault == FAULT_CODE_DRV) {\n\t\t\t\t\tcommands_printf(\"DRV8320S_FAULTS  : %s\", drv8320s_faults_to_string(fault_vec[i].drv8301_faults));\n\t\t\t\t}\n#elif defined(HW_HAS_DRV8323S)\n\t\t\t\tif (fault_vec[i].fault == FAULT_CODE_DRV) {\n\t\t\t\t\tcommands_printf(\"DRV8323S_FAULTS  : %s\", drv8323s_faults_to_string(fault_vec[i].drv8301_faults));\n\t\t\t\t}\n#endif\n\t\t\t\tif (fault_vec[i].info_str != 0) {\n\t\t\t\t\tchar f_str[100];\n\t\t\t\t\tstrcpy(f_str, \"Info             : \");\n\t\t\t\t\tstrcpy(f_str + 19, fault_vec[i].info_str);\n\t\t\t\t\tif (fault_vec[i].info_argn == 0) {\n\t\t\t\t\t\tcommands_printf(f_str);\n\t\t\t\t\t} else if (fault_vec[i].info_argn == 1) {\n\t\t\t\t\t\tcommands_printf(f_str, (double)fault_vec[i].info_args[0]);\n\t\t\t\t\t} else if (fault_vec[i].info_argn == 2) {\n\t\t\t\t\t\tcommands_printf(f_str, (double)fault_vec[i].info_args[0], (double)fault_vec[i].info_args[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t}\n\t} else if (strcmp(argv[0], \"tim\") == 0) {\n\t\tchSysLock();\n\t\tvolatile int t1_cnt = TIM1->CNT;\n\t\tvolatile int t8_cnt = TIM8->CNT;\n\t\tvolatile int t1_cnt2 = TIM1->CNT;\n\t\tvolatile int t2_cnt = TIM2->CNT;\n\t\tvolatile int dir1 = !!(TIM1->CR1 & (1 << 4));\n\t\tvolatile int dir8 = !!(TIM8->CR1 & (1 << 4));\n\t\tchSysUnlock();\n\n\t\tint duty1 = TIM1->CCR1;\n\t\tint duty2 = TIM1->CCR2;\n\t\tint duty3 = TIM1->CCR3;\n\t\tint top = TIM1->ARR;\n\t\tint voltage_samp = TIM8->CCR1;\n\t\tint current1_samp = TIM1->CCR4;\n\t\tint current2_samp = TIM8->CCR2;\n\n\t\tcommands_printf(\"Tim1 CNT: %i\", t1_cnt);\n\t\tcommands_printf(\"Tim8 CNT: %i\", t8_cnt);\n\t\tcommands_printf(\"Tim2 CNT: %i\", t2_cnt);\n\t\tcommands_printf(\"Amount off CNT: %i\",top - (2*t8_cnt + t1_cnt + t1_cnt2)/2);\n\t\tcommands_printf(\"Duty cycle1: %u\", duty1);\n\t\tcommands_printf(\"Duty cycle2: %u\", duty2);\n\t\tcommands_printf(\"Duty cycle3: %u\", duty3);\n\t\tcommands_printf(\"Top: %u\", top);\n\t\tcommands_printf(\"Dir1: %u\", dir1);\n\t\tcommands_printf(\"Dir8: %u\", dir8);\n\t\tcommands_printf(\"Voltage sample: %u\", voltage_samp);\n\t\tcommands_printf(\"Current 1 sample: %u\", current1_samp);\n\t\tcommands_printf(\"Current 2 sample: %u\\n\", current2_samp);\n\t} else if (strcmp(argv[0], \"volt\") == 0) {\n\t\tcommands_printf(\"Input voltage: %.2f\\n\", (double)mc_interface_get_input_voltage_filtered());\n#ifdef HW_HAS_GATE_DRIVER_SUPPLY_MONITOR\n\t\tcommands_printf(\"Gate driver power supply output voltage: %.2f\\n\", (double)GET_GATE_DRIVER_SUPPLY_VOLTAGE());\n#endif\n\t} else if (strcmp(argv[0], \"param_detect\") == 0) {\n\t\t// Use COMM_MODE_DELAY and try to figure out the motor parameters.\n\t\tif (argc == 4) {\n\t\t\tfloat current = -1.0;\n\t\t\tfloat min_rpm = -1.0;\n\t\t\tfloat low_duty = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tsscanf(argv[2], \"%f\", &min_rpm);\n\t\t\tsscanf(argv[3], \"%f\", &low_duty);\n\t\t\tcommands_printf(\"Detecting parameters for BLDC...\");\n\t\t\tif (current > 0.0 && current < mc_interface_get_configuration()->l_current_max &&\n\t\t\t\t\tmin_rpm > 10.0 && min_rpm < 3000.0 &&\n\t\t\t\t\tlow_duty > 0.02 && low_duty < 0.8) {\n\n\t\t\t\tfloat cycle_integrator;\n\t\t\t\tfloat coupling_k;\n\t\t\t\tint8_t hall_table[8];\n\t\t\t\tint hall_res;\n\t\t\t\tif (conf_general_detect_motor_param(current, min_rpm, low_duty, &cycle_integrator, &coupling_k, hall_table, &hall_res)) {\n\t\t\t\t\tcommands_printf(\"Cycle integrator limit: %.2f\", (double)cycle_integrator);\n\t\t\t\t\tcommands_printf(\"Coupling factor: %.2f\", (double)coupling_k);\n\n\t\t\t\t\tif (hall_res == 0) {\n\t\t\t\t\t\tcommands_printf(\"Detected hall sensor table:\");\n\t\t\t\t\t\tcommands_printf(\"%i, %i, %i, %i, %i, %i, %i, %i\\n\",\n\t\t\t\t\t\t\t\thall_table[0], hall_table[1], hall_table[2], hall_table[3],\n\t\t\t\t\t\t\t\thall_table[4], hall_table[5], hall_table[6], hall_table[7]);\n\t\t\t\t\t} else if (hall_res == -1) {\n\t\t\t\t\t\tcommands_printf(\"Hall sensor detection failed:\");\n\t\t\t\t\t\tcommands_printf(\"%i, %i, %i, %i, %i, %i, %i, %i\\n\",\n\t\t\t\t\t\t\t\thall_table[0], hall_table[1], hall_table[2], hall_table[3],\n\t\t\t\t\t\t\t\thall_table[4], hall_table[5], hall_table[6], hall_table[7]);\n\t\t\t\t\t} else if (hall_res == -2) {\n\t\t\t\t\t\tcommands_printf(\"WS2811 enabled. Hall sensors cannot be used.\\n\");\n\t\t\t\t\t} else if (hall_res == -3) {\n\t\t\t\t\t\tcommands_printf(\"Encoder enabled. Hall sensors cannot be used.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Detection failed. Try again with different parameters.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s)\");\n\t\t\t\tif (!(current > 0.0 && current < mc_interface_get_configuration()->l_current_max)) {\n\t\t\t\t\tcommands_printf(\"Current must be between 0.0 and %.2f\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t\t}\n\t\t\t\tif (!(min_rpm > 10.0 && min_rpm < 3000.0)) {\n\t\t\t\t\tcommands_printf(\"ERPM must be between 10 and 3000\");\n\t\t\t\t}\n\t\t\t\tif (!(low_duty > 0.02 && low_duty < 0.8)) {\n\t\t\t\t\tcommands_printf(\"Duty must be between 0.02 and 0.8\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires three arguments. [current erpm duty]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"rpm_dep\") == 0) {\n\t\tmc_rpm_dep_struct rpm_dep = mcpwm_get_rpm_dep();\n\t\tcommands_printf(\"Cycle int limit: %.2f\", (double)rpm_dep.cycle_int_limit);\n\t\tcommands_printf(\"Cycle int limit running: %.2f\", (double)rpm_dep.cycle_int_limit_running);\n\t\tcommands_printf(\"Cycle int limit max: %.2f\\n\", (double)rpm_dep.cycle_int_limit_max);\n\t} else if (strcmp(argv[0], \"foc_encoder_detect\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat current = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\n\t\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t\t*mcconf = *mc_interface_get_configuration();\n\t\t\tcommands_printf(\"Detecting encoder...\");\n\t\t\tif (current > 0.0 && current <= mcconf->l_current_max) {\n\t\t\t\tif (encoder_is_configured()) {\n\t\t\t\t\tmc_motor_type type_old = mcconf->motor_type;\n\t\t\t\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\t\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t\t\tfloat offset = 0.0;\n\t\t\t\t\tfloat ratio = 0.0;\n\t\t\t\t\tbool inverted = false;\n\t\t\t\t\tmcpwm_foc_encoder_detect(current, true, &offset, &ratio, &inverted);\n\n\t\t\t\t\tmcconf->motor_type = type_old;\n\t\t\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t\t\tcommands_printf(\"Offset   : %.2f\", (double)offset);\n\t\t\t\t\tcommands_printf(\"Ratio    : %.2f\", (double)ratio);\n\t\t\t\t\tcommands_printf(\"Inverted : %s\\n\", inverted ? \"true\" : \"false\");\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Encoder not enabled.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s). Current must be between 0.0 and %.2f\\n\", (double)mcconf->l_current_max);\n\t\t\t}\n\n\t\t\tmempools_free_mcconf(mcconf);\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [current]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"measure_res\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat current = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\n\t\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t\t*mcconf = *mc_interface_get_configuration();\n\t\t\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\t\t\t*mcconf_old = *mc_interface_get_configuration();\n\t\t\tcommands_printf(\"Measuring resistance...\");\n\t\t\tif (current > 0.0 && current <= mcconf->l_current_max) {\n\t\t\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\t\tfloat tmp_r = 0.0;\n\t\t\t\tint fault = mcpwm_foc_measure_resistance(current, 2000, true, &tmp_r);\n\t\t\t\tif(fault == FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Resistance: %.6f ohm\\n\", (double)tmp_r);\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Resistance measurement failed due to fault: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s). Current must be between 0.0 and %.2f\\n\", (double)mcconf->l_current_max);\n\t\t\t}\n\n\t\t\tmempools_free_mcconf(mcconf);\n\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [current]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"measure_ind\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat duty = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &duty);\n\t\t\tcommands_printf(\"Measuring inductance...\");\n\t\t\tif (duty > 0.0 && duty <= 0.9) {\n\t\t\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t\t\t*mcconf = *mc_interface_get_configuration();\n\t\t\t\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\t\t\t\t*mcconf_old = *mc_interface_get_configuration();\n\n\t\t\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t\tfloat curr, ld_lq_diff, ind;\n\t\t\t\tint fault = mcpwm_foc_measure_inductance(duty, 400, &curr, &ld_lq_diff, &ind);\n\t\t\t\tif(fault == FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Inductance: %.2f uH, ld_lq_diff: %.2f uH (%.2f A)\\n\",\n\t\t\t\t\t\t\t\t\t(double)ind, (double)ld_lq_diff, (double)curr);\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Inductance measurement failed with fault: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument. Duty must be between 0.0 and 0.9 \\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [duty]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"measure_linkage\") == 0) {\n\t\tif (argc == 5) {\n\t\t\tfloat current = -1.0;\n\t\t\tfloat duty = -1.0;\n\t\t\tfloat min_erpm = -1.0;\n\t\t\tfloat res = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tsscanf(argv[2], \"%f\", &duty);\n\t\t\tsscanf(argv[3], \"%f\", &min_erpm);\n\t\t\tsscanf(argv[4], \"%f\", &res);\n\t\t\tcommands_printf(\"Measuring flux linkage...\");\n\t\t\tif (current > 0.0 && current <= mc_interface_get_configuration()->l_current_max &&\n\t\t\t\t\tmin_erpm > 0.0 && duty > 0.02 && duty <= 0.9 && res >= 0.0) {\n\t\t\t\tfloat linkage;\n\t\t\t\tconf_general_measure_flux_linkage(current, duty, min_erpm, res, &linkage);\n\t\t\t\tcommands_printf(\"Flux linkage: %.7f\\n\", (double)linkage);\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s).\");\n\t\t\t\tif (!(current > 0.0 && current <= mc_interface_get_configuration()->l_current_max)) {\n\t\t\t\t\tcommands_printf(\"Current must be between 0.0 and %.2f\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t\t}\n\t\t\t\tif (!(duty > 0.02 && duty <= 0.9)) {\n\t\t\t\t\tcommands_printf(\"Duty must be between 0.02 and 0.9\");\n\t\t\t\t}\n\t\t\t\tif (!(min_erpm > 0.0)) {\n\t\t\t\t\tcommands_printf(\"ERPM must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tif (!(res >= 0.0)) {\n\t\t\t\t\tcommands_printf(\"Resistance must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires four arguments. [current duty min_erpm resistance]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"measure_res_ind\") == 0) {\n\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t*mcconf = *mc_interface_get_configuration();\n\t\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\t\t*mcconf_old = *mc_interface_get_configuration();\n\n\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\tmc_interface_set_configuration(mcconf);\n\t\tcommands_printf(\"Measuring resistance and inductance...\");\n\t\tfloat res = 0.0;\n\t\tfloat ind = 0.0;\n\t\tfloat ld_lq_diff = 0.0;\n\t\tint fault = mcpwm_foc_measure_res_ind(&res, &ind, &ld_lq_diff);\n\t\tif (fault == FAULT_CODE_NONE) {\n\t\t\tcommands_printf(\"Resistance: %.6f ohm\", (double)res);\n\t\t\tcommands_printf(\"Inductance: %.2f uH (Lq-Ld: %.2f uH)\\n\", (double)ind, (double)ld_lq_diff);\n\t\t} else {\n\t\t\tcommands_printf(\"Fault occured while measuring resistance and inductance: %s\", mc_interface_fault_to_string(fault));\n\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t}\n\t\t\n\n\t\tmc_interface_set_configuration(mcconf_old);\n\n\t\tmempools_free_mcconf(mcconf);\n\t\tmempools_free_mcconf(mcconf_old);\n\t} else if (strcmp(argv[0], \"measure_linkage_foc\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat duty = -1.0;\n\t\t\tint fault = FAULT_CODE_NONE;\n\t\t\tsscanf(argv[1], \"%f\", &duty);\n\t\t\tcommands_printf(\"Measuring flux linkage foc...\");\n\t\t\tif (duty > 0.0 && duty <= 0.9) {\n\t\t\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t\t\t*mcconf = *mc_interface_get_configuration();\n\t\t\t\tmc_configuration *mcconf_old = mempools_alloc_mcconf();\n\t\t\t\t*mcconf_old = *mc_interface_get_configuration();\n\n\t\t\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t\t// Disable timeout\n\t\t\t\tsystime_t tout = timeout_get_timeout_msec();\n\t\t\t\tfloat tout_c = timeout_get_brake_current();\n\t\t\t\tKILL_SW_MODE tout_ksw = timeout_get_kill_sw_mode();\n\t\t\t\ttimeout_reset();\n\t\t\t\ttimeout_configure(60000, 0.0, KILL_SW_MODE_DISABLED);\n\n\t\t\t\tfor (int i = 0;i < 100;i++) {\n\t\t\t\t\tmc_interface_set_duty(((float)i / 100.0) * duty);\n\t\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchThdSleepMilliseconds(20);\n\t\t\t\t}\n\n\t\t\t\tfloat vq_avg = 0.0;\n\t\t\t\tfloat rpm_avg = 0.0;\n\t\t\t\tfloat samples = 0.0;\n\t\t\t\tfloat iq_avg = 0.0;\n\t\t\t\tfor (int i = 0;i < 1000;i++) {\n\t\t\t\t\tvq_avg += mcpwm_foc_get_vq();\n\t\t\t\t\trpm_avg += mc_interface_get_rpm();\n\t\t\t\t\tiq_avg += mc_interface_get_tot_current_directional();\n\t\t\t\t\tsamples += 1.0;\n\t\t\t\t\tchThdSleepMilliseconds(1);\n\t\t\t\t}\n\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmc_interface_set_configuration(mcconf_old);\n\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf_old);\n\n\t\t\t\t// Enable timeout\n\t\t\t\ttimeout_configure(tout, tout_c, tout_ksw);\n\n\t\t\t\tvq_avg /= samples;\n\t\t\t\trpm_avg /= samples;\n\t\t\t\tiq_avg /= samples;\n\n\t\t\t\tfloat linkage = (vq_avg - mcconf->foc_motor_r * iq_avg) / RPM2RADPS_f(rpm_avg);\n\n\t\t\t\tif (fault == FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Flux linkage: %.7f\\n\", (double)linkage);\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Flux linkage detection failed with fault: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument. Duty must be between 0.0 and 0.9\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [duty]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"measure_linkage_openloop\") == 0) {\n\t\tif (argc == 6) {\n\t\t\tfloat current = -1.0;\n\t\t\tfloat duty = -1.0;\n\t\t\tfloat erpm_per_sec = -1.0;\n\t\t\tfloat res = -1.0;\n\t\t\tfloat ind = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tsscanf(argv[2], \"%f\", &duty);\n\t\t\tsscanf(argv[3], \"%f\", &erpm_per_sec);\n\t\t\tsscanf(argv[4], \"%f\", &res);\n\t\t\tsscanf(argv[5], \"%f\", &ind);\n\t\t\tcommands_printf(\"Measuring flux linkage openloop...\");\n\t\t\tif (current > 0.0 && current <= mc_interface_get_configuration()->l_current_max &&\n\t\t\t\t\terpm_per_sec > 0.0 && duty > 0.02 && duty <= 0.9 && res >= 0.0 && ind >= 0.0) {\n\t\t\t\tfloat linkage = 0.0, linkage_undriven = 0.0, undriven_samples = 0.0;\n\t\t\t\tbool result;\n\n\t\t\t\tint fault = conf_general_measure_flux_linkage_openloop(current, duty, erpm_per_sec, res, ind,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &linkage, &linkage_undriven, &undriven_samples, &result);\n\t\t\t\tif (fault == FAULT_CODE_NONE) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tcommands_printf(\n\t\t\t\t\t\t\t\t\t\"Flux linkage            : %.7f\\n\"\n\t\t\t\t\t\t\t\t\t\"Flux Linkage (undriven) : %.7f\\n\"\n\t\t\t\t\t\t\t\t\t\"Undriven samples        : %.1f\\n\",\n\t\t\t\t\t\t\t\t\t(double)linkage, (double)linkage_undriven, (double)undriven_samples);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Failed to measure flux linkage\");\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Fault occured while measuring flux linkage: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s).\");\n\t\t\t\tif (!(current > 0.0 && current <= mc_interface_get_configuration()->l_current_max)) {\n\t\t\t\t\tcommands_printf(\"Current must be between 0.0 and %.2f\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t\t}\n\t\t\t\tif (!(duty > 0.02 && duty <= 0.9)) {\n\t\t\t\t\tcommands_printf(\"Duty must be between 0.02 and 0.9\");\n\t\t\t\t}\n\t\t\t\tif (!(erpm_per_sec > 0.0)) {\n\t\t\t\t\tcommands_printf(\"ERPM ramp rate must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tif (!(res >= 0.0)) {\n\t\t\t\t\tcommands_printf(\"Resistance must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tif (!(ind >= 0.0)) {\n\t\t\t\t\tcommands_printf(\"Inductance must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires five arguments. [current duty erpm_ramp_per_sec resistance inductance]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"foc_state\") == 0) {\n        commands_printf(\"FOC State:\");\n\t\tmcpwm_foc_print_state();\n\t\tcommands_printf(\" \");\n\t} else if (strcmp(argv[0], \"foc_dc_cal\") == 0) {\n\t\tcommands_printf(\"Performing DC offset calibration...\");\n\t\tint res = mcpwm_foc_dc_cal(true);\n\t\tif (res >= 0) {\n\t\t\tconf_general_store_mc_configuration((mc_configuration*)mc_interface_get_configuration(),\n\t\t\t\t\tmc_interface_get_motor_thread() == 2);\n\t\t\tcommands_printf(\"Done!\\n\");\n\t\t} else {\n\t\t\tcommands_printf(\"DC Cal Failed: %d\\n\", res);\n\t\t}\n\t} else if (strcmp(argv[0], \"hw_status\") == 0) {\n\t\tcommands_printf(\"Firmware: %d.%d\", FW_VERSION_MAJOR, FW_VERSION_MINOR);\n#ifdef HW_NAME\n\t\tcommands_printf(\"Hardware: %s\", HW_NAME);\n#endif\n\t\tcommands_printf(\"UUID: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\",\n\t\t\t\tSTM32_UUID_8[0], STM32_UUID_8[1], STM32_UUID_8[2], STM32_UUID_8[3],\n\t\t\t\tSTM32_UUID_8[4], STM32_UUID_8[5], STM32_UUID_8[6], STM32_UUID_8[7],\n\t\t\t\tSTM32_UUID_8[8], STM32_UUID_8[9], STM32_UUID_8[10], STM32_UUID_8[11]);\n\t\tcommands_printf(\"Permanent NRF found: %s\", conf_general_permanent_nrf_found ? \"Yes\" : \"No\");\n#ifdef HW_HAS_PHASE_SHUNTS\n\t\tcommands_printf(\"Phase Shunts: Yes\");\n#else\n\t\tcommands_printf(\"Phase Shunts: No\");\n#endif\n\n\t\tcommands_printf(\"Odometer : %llu m\", mc_interface_get_odometer());\n\t\tcommands_printf(\"Runtime  : %llu s\", g_backup.runtime);\n\n\t\tfloat curr0_offset;\n\t\tfloat curr1_offset;\n\t\tfloat curr2_offset;\n\n\t\tmcpwm_foc_get_current_offsets(&curr0_offset, &curr1_offset, &curr2_offset,\n\t\t\t\tmc_interface_get_motor_thread() == 2);\n\n\t\tcommands_printf(\"FOC Current Offsets: %.2f %.2f %.2f\",\n\t\t\t\t(double)curr0_offset, (double)curr1_offset, (double)curr2_offset);\n\n\t\tfloat v0_offset;\n\t\tfloat v1_offset;\n\t\tfloat v2_offset;\n\n\t\tmcpwm_foc_get_voltage_offsets(&v0_offset, &v1_offset, &v2_offset,\n\t\t\t\tmc_interface_get_motor_thread() == 2);\n\n\t\tcommands_printf(\"FOC Voltage Offsets: %.4f %.4f %.4f\",\n\t\t\t\t(double)v0_offset, (double)v1_offset, (double)v2_offset);\n\n\t\tmcpwm_foc_get_voltage_offsets_undriven(&v0_offset, &v1_offset, &v2_offset,\n\t\t\t\tmc_interface_get_motor_thread() == 2);\n\n\t\tcommands_printf(\"FOC Voltage Offsets Undriven: %.4f %.4f %.4f\",\n\t\t\t\t(double)v0_offset, (double)v1_offset, (double)v2_offset);\n\n#ifdef COMM_USE_USB\n\t\tcommands_printf(\"USB config events: %d\", comm_usb_serial_configured_cnt());\n\t\tcommands_printf(\"USB write timeouts: %u\", comm_usb_get_write_timeout_cnt());\n#else\n\t\tcommands_printf(\"USB not enabled on hardware.\");\n#endif\n\n#if defined (V_REG) && defined (CURRENT_AMP_GAIN) && defined(CURRENT_SHUNT_RES)\n\t\tcommands_printf(\"Current Measurement Range: %.1f A\", (double)((V_REG / 2.0) / (CURRENT_AMP_GAIN * CURRENT_SHUNT_RES)));\n#endif\n\n#if defined (V_REG) && defined (VIN_R1) && defined(VIN_R2)\n\t\tcommands_printf(\"Voltage Measurement Range: %.1f V\", (double)((V_REG / 4095.0) * 4095.0 * ((VIN_R1 + VIN_R2) / VIN_R2)));\n#endif\n\n#ifdef HW_DEAD_TIME_NSEC\n\t\tcommands_printf(\"Dead time: %.0f ns\", (double)HW_DEAD_TIME_NSEC);\n#endif\n\n\t\tcommands_printf(\"Mempool mcconf now: %d highest: %d (max %d)\",\n\t\t\t\tmempools_mcconf_allocated_num(), mempools_mcconf_highest(), MEMPOOLS_MCCONF_NUM - 1);\n\t\tcommands_printf(\"Mempool appconf now: %d highest: %d (max %d)\",\n\t\t\t\tmempools_appconf_allocated_num(), mempools_appconf_highest(), MEMPOOLS_APPCONF_NUM - 1);\n\n\t\tcommands_printf(\" \");\n\t} else if (strcmp(argv[0], \"foc_openloop\") == 0) {\n\t\tif (argc == 3) {\n\t\t\tfloat current = -1.0;\n\t\t\tfloat erpm = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tsscanf(argv[2], \"%f\", &erpm);\n\t\t\tcommands_printf(\"Running FOC openloop...\");\n\t\t\tif (current > 0.0 && current <= mc_interface_get_configuration()->l_current_max && erpm >= 0.0) {\n\t\t\t\ttimeout_reset();\n\t\t\t\tmc_interface_set_openloop_current(current, erpm);\n\t\t\t\tint fault = mc_interface_get_fault();\n\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Fault occured during openloop: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s).\");\n\t\t\t\tif (!(current > 0.0 && current <= mc_interface_get_configuration()->l_current_max)) {\n\t\t\t\t\tcommands_printf(\"Current must be between 0.0 and %.2f\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t\t}\n\t\t\t\tif (!(erpm >= 0.0)) {\n\t\t\t\t\tcommands_printf(\"ERPM must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires two arguments. [current erpm]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"foc_openloop_duty\") == 0) {\n\t\tif (argc == 3) {\n\t\t\tfloat duty = -1.0;\n\t\t\tfloat erpm = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &duty);\n\t\t\tsscanf(argv[2], \"%f\", &erpm);\n\t\t\tcommands_printf(\"Running FOC openloop duty...\");\n\t\t\tif (duty >= 0.0 && duty <= 0.9 && erpm >= 0.0) {\n\t\t\t\ttimeout_reset();\n\t\t\t\tmc_interface_set_openloop_duty(duty, erpm);\n\t\t\t\tint fault = mc_interface_get_fault();\n\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Fault occured during openloop: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s).\");\n\t\t\t\tif (!(duty >= 0.0 && duty <= 0.9)) {\n\t\t\t\t\tcommands_printf(\"Duty must be between 0.0 and 0.9\");\n\t\t\t\t}\n\t\t\t\tif (!(erpm >= 0.0)) {\n\t\t\t\t\tcommands_printf(\"ERPM must be greater than 0.0\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires two arguments. [duty erpm]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"nrf_ext_set_enabled\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tint enabled = -1;\n\t\t\tsscanf(argv[1], \"%d\", &enabled);\n\t\t\tcommands_printf(\"Sending COMM_EXT_NRF_SET_ENABLED...\");\n\t\t\tif (enabled >= 0) {\n\t\t\t\tuint8_t buffer[2];\n\t\t\t\tbuffer[0] = COMM_EXT_NRF_SET_ENABLED;\n\t\t\t\tbuffer[1] = enabled;\n\t\t\t\tcommands_send_packet_nrf(buffer, 2);\n\t\t\t\tcommands_printf(\"Sent.\\n\");\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument. Enabled must be >= 0 \\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [enabled]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"foc_sensors_detect_apply\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat current = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tcommands_printf(\"Detecting sensors for FOC...\");\n\t\t\tif (current > 0.0 && current <= mc_interface_get_configuration()->l_current_max) {\n\t\t\t\tint res;\n\t\t\t\tint fault = conf_general_autodetect_apply_sensors_foc(current, true, true, &res);\n\n\t\t\t\tif (fault == FAULT_CODE_NONE) {\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tcommands_printf(\"No sensors found, using sensorless mode.\\n\");\n\t\t\t\t\t} else if (res == 1) {\n\t\t\t\t\t\tcommands_printf(\"Found hall sensors, using them.\\n\");\n\t\t\t\t\t} else if (res == 2) {\n\t\t\t\t\t\tcommands_printf(\"Found AS5047 encoder, using it.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Detection error: %d\\n\", res);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcommands_printf(\"Fault occured while detecting sensors: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s). Current must be between 0.0 and %.2f\\n\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [current]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"rotor_lock_openloop\") == 0) {\n\t\tif (argc == 4) {\n\t\t\tfloat current = -1.0;\n\t\t\tfloat time = -1.0;\n\t\t\tfloat angle = -1.0;\n\t\t\tint fault = FAULT_CODE_NONE;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tsscanf(argv[2], \"%f\", &time);\n\t\t\tsscanf(argv[3], \"%f\", &angle);\n\t\t\tcommands_printf(\"Locking rotor with openloop...\");\n\t\t\tif (fabsf(current) <= mc_interface_get_configuration()->l_current_max &&\n\t\t\t\t\tangle >= 0.0 && angle <= 360.0) {\n\t\t\t\tif (time <= 1e-6) {\n\t\t\t\t\ttimeout_reset();\n\t\t\t\t\tmc_interface_set_openloop_phase(current, angle);\n\t\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\t\tcommands_printf(\"Fault occured during openloop: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcommands_printf(\"OK\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint print_div = 0;\n\t\t\t\t\tfor (float t = 0.0;t < time;t += 0.002) {\n\t\t\t\t\t\ttimeout_reset();\n\t\t\t\t\t\tmc_interface_set_openloop_phase(current, angle);\n\t\t\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\t\t\tcommands_printf(\"Fault occured during openloop: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchThdSleepMilliseconds(2);\n\n\t\t\t\t\t\tprint_div++;\n\t\t\t\t\t\tif (print_div >= 200) {\n\t\t\t\t\t\t\tprint_div = 0;\n\t\t\t\t\t\t\tcommands_printf(\"T left: %.2f s\", (double)(time - t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmc_interface_set_current(0.0);\n\n\t\t\t\t\tcommands_printf(\"Done\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s).\");\n\t\t\t\tif (!(fabsf(current) <= mc_interface_get_configuration()->l_current_max)) {\n\t\t\t\t\tcommands_printf(\"Current must be less than %.2f\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t\t}\n\t\t\t\tif (!(angle >= 0.0 && angle <= 360.0)) {\n\t\t\t\t\tcommands_printf(\"Angle must be between 0.0 and 360.0\");\n\t\t\t\t}\n\t\t\t\tcommands_printf(\" \");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires three arguments. [current time angle]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"foc_detect_apply_all\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat max_power_loss = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &max_power_loss);\n\t\t\tcommands_printf(\"Running detection...\");\n\t\t\tif (max_power_loss > 0.0) {\n\t\t\t\tint motor_thread_old = mc_interface_get_motor_thread();\n\n\t\t\t\tint res = conf_general_detect_apply_all_foc(max_power_loss, true, true);\n\n\t\t\t\tcommands_printf(\"Result: %d\", res);\n\t\t\t\tmc_interface_select_motor_thread(1);\n\n\t\t\t\tif (res >= 0) {\n\t\t\t\t\tcommands_printf(\"Detection finished and applied. Results:\");\n\t\t\t\t\tconst volatile mc_configuration *mcconf = mc_interface_get_configuration();\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\t\t\tcommands_printf(\"\\nMOTOR 1\\n\");\n#endif\n\t\t\t\t\tcommands_printf(\"Motor Current       : %.1f A\", (double)(mcconf->l_current_max));\n\t\t\t\t\tcommands_printf(\"Motor R             : %.2f mOhm\", (double)(mcconf->foc_motor_r * 1e3));\n\t\t\t\t\tcommands_printf(\"Motor L             : %.2f uH\", (double)(mcconf->foc_motor_l * 1e6));\n\t\t\t\t\tcommands_printf(\"Motor Flux Linkage  : %.3f mWb\", (double)(mcconf->foc_motor_flux_linkage * 1e3));\n\t\t\t\t\tcommands_printf(\"Temp Comp           : %s\", mcconf->foc_temp_comp ? \"true\" : \"false\");\n\t\t\t\t\tif (mcconf->foc_temp_comp) {\n\t\t\t\t\t\tcommands_printf(\"Temp Comp Base Temp : %.1f degC\", (double)mcconf->foc_temp_comp_base_temp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_SENSORLESS) {\n\t\t\t\t\t\tcommands_printf(\"No sensors found, using sensorless mode.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_HALL) {\n\t\t\t\t\t\tcommands_printf(\"Found hall sensors, using them.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_ENCODER) {\n\t\t\t\t\t\tcommands_printf(\"Found AS5047 encoder, using it.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Detection error: %d\\n\", res);\n\t\t\t\t\t}\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\t\t\tmc_interface_select_motor_thread(2);\n\t\t\t\t\tmcconf = mc_interface_get_configuration();\n\t\t\t\t\tcommands_printf(\"\\nMOTOR 2\\n\");\n\t\t\t\t\tcommands_printf(\"Motor Current       : %.1f A\", (double)(mcconf->l_current_max));\n\t\t\t\t\tcommands_printf(\"Motor R             : %.2f mOhm\", (double)(mcconf->foc_motor_r * 1e3));\n\t\t\t\t\tcommands_printf(\"Motor L             : %.2f uH\", (double)(mcconf->foc_motor_l * 1e6));\n\t\t\t\t\tcommands_printf(\"Motor Flux Linkage  : %.3f mWb\", (double)(mcconf->foc_motor_flux_linkage * 1e3));\n\t\t\t\t\tcommands_printf(\"Temp Comp           : %s\", mcconf->foc_temp_comp ? \"true\" : \"false\");\n\t\t\t\t\tif (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_SENSORLESS) {\n\t\t\t\t\t\tcommands_printf(\"No sensors found, using sensorless mode.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_HALL) {\n\t\t\t\t\t\tcommands_printf(\"Found hall sensors, using them.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_ENCODER) {\n\t\t\t\t\t\tcommands_printf(\"Found AS5047 encoder, using it.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Detection error: %d\\n\", res);\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (res == -10) {\n\t\t\t\t\t\tcommands_printf(\"Could not measure flux linkage.\");\n\t\t\t\t\t} else if (res == -11) {\n\t\t\t\t\t\tcommands_printf(\"Persistent fault occurred during detection.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Fault code occurred during detection: %s\\n\", mc_interface_fault_to_string(res+100)); // faults are offset by -100 here\n\t\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t\t}\n\n\n\t\t\t\t\tcommands_printf(\"Detection failed.\\n\");\n\t\t\t\t}\n\n\t\t\t\tmc_interface_select_motor_thread(motor_thread_old);\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument. Max power loss must be greater than 0\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [Max_power_loss]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"foc_detect_apply_all_can\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat max_power_loss = -1.0;\n\t\t\tsscanf(argv[1], \"%f\", &max_power_loss);\n\t\t\tcommands_printf(\"Running detection...\");\n\t\t\tif (max_power_loss > 0.0) {\n\n\t\t\t\tint res = conf_general_detect_apply_all_foc_can(true, max_power_loss, 0.0, 0.0, 0.0, 0.0, NULL);\n\n\t\t\t\tcommands_printf(\"Res: %d\", res);\n\n\t\t\t\tif (res >= 0) {\n\t\t\t\t\tcommands_printf(\"Detection finished and applied. Results:\");\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\t\t\tcommands_printf(\"\\nMOTOR 1\\n\");\n#endif\n\t\t\t\t\tconst volatile mc_configuration *mcconf = mc_interface_get_configuration();\n\t\t\t\t\tcommands_printf(\"Motor Current       : %.1f A\", (double)(mcconf->l_current_max));\n\t\t\t\t\tcommands_printf(\"Motor R             : %.2f mOhm\", (double)(mcconf->foc_motor_r * 1e3));\n\t\t\t\t\tcommands_printf(\"Motor L             : %.2f microH\", (double)(mcconf->foc_motor_l * 1e6));\n\t\t\t\t\tcommands_printf(\"Motor Flux Linkage  : %.3f mWb\", (double)(mcconf->foc_motor_flux_linkage * 1e3));\n\t\t\t\t\tcommands_printf(\"Temp Comp           : %s\", mcconf->foc_temp_comp ? \"true\" : \"false\");\n\t\t\t\t\tif (mcconf->foc_temp_comp) {\n\t\t\t\t\t\tcommands_printf(\"Temp Comp Base Temp : %.1f degC\", (double)mcconf->foc_temp_comp_base_temp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_SENSORLESS) {\n\t\t\t\t\t\tcommands_printf(\"No sensors found, using sensorless mode.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_HALL) {\n\t\t\t\t\t\tcommands_printf(\"Found hall sensors, using them.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_ENCODER) {\n\t\t\t\t\t\tcommands_printf(\"Found AS5047 encoder, using it.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Detection error: %d\\n\", res);\n\t\t\t\t\t}\n#ifdef HW_HAS_DUAL_MOTORS\n\t\t\t\t\tmc_interface_select_motor_thread(2);\n\t\t\t\t\tmcconf = mc_interface_get_configuration();\n\t\t\t\t\tcommands_printf(\"\\nMOTOR 2\\n\");\n\t\t\t\t\tcommands_printf(\"Motor Current       : %.1f A\", (double)(mcconf->l_current_max));\n\t\t\t\t\tcommands_printf(\"Motor R             : %.2f mOhm\", (double)(mcconf->foc_motor_r * 1e3));\n\t\t\t\t\tcommands_printf(\"Motor L             : %.2f microH\", (double)(mcconf->foc_motor_l * 1e6));\n\t\t\t\t\tcommands_printf(\"Motor Flux Linkage  : %.3f mWb\", (double)(mcconf->foc_motor_flux_linkage * 1e3));\n\t\t\t\t\tcommands_printf(\"Temp Comp           : %s\", mcconf->foc_temp_comp ? \"true\" : \"false\");\n\t\t\t\t\tif (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_SENSORLESS) {\n\t\t\t\t\t\tcommands_printf(\"No sensors found, using sensorless mode.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_HALL) {\n\t\t\t\t\t\tcommands_printf(\"Found hall sensors, using them.\\n\");\n\t\t\t\t\t} else if (mcconf->foc_sensor_mode == FOC_SENSOR_MODE_ENCODER) {\n\t\t\t\t\t\tcommands_printf(\"Found AS5047 encoder, using it.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Detection error: %d\\n\", res);\n\t\t\t\t\t}\n\t\t\t\t\tcommands_printf(\"\\nNote that this is only printing values of motors 1\");\n\t\t\t\t\tcommands_printf(\"and 2 of the currently connected unit, other motors\");\n\t\t\t\t\tcommands_printf(\"may have been detected, but won't be printed here\");\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (res == -10) {\n\t\t\t\t\t\tcommands_printf(\"Could not measure flux linkage.\");\n\t\t\t\t\t} else if (res == -11) {\n\t\t\t\t\t\tcommands_printf(\"Persistent fault occurred during detection.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Fault code occurred during detection: %s\\n\", mc_interface_fault_to_string(res+100)); // faults are offset by -100 here\n\t\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcommands_printf(\"Detection failed.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument. Max power loss must be greater than 0\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [Max_power_loss]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"uptime\") == 0) {\n\t\tcommands_printf(\"Uptime: %.2f s\\n\", (double)chVTGetSystemTimeX() / (double)CH_CFG_ST_FREQUENCY);\n\t} else if (strcmp(argv[0], \"hall_analyze\") == 0) {\n\t\tif (argc == 2) {\n\t\t\tfloat current = -1.0;\n\t\t\tint fault = FAULT_CODE_NONE;\n\t\t\tsscanf(argv[1], \"%f\", &current);\n\t\t\tcommands_printf(\"Starting hall sensor analysis...\\n\");\n\t\t\tif (current > 0.0 && current <= mc_interface_get_configuration()->l_current_max) {\n\t\t\t\tmc_interface_lock();\n\t\t\t\tmc_configuration *mcconf = mempools_alloc_mcconf();\n\t\t\t\t*mcconf = *mc_interface_get_configuration();\n\t\t\t\tmc_motor_type motor_type_old = mcconf->motor_type;\n\t\t\t\tmcconf->motor_type = MOTOR_TYPE_FOC;\n\t\t\t\tmc_interface_set_configuration(mcconf);\n\n\t\t\t\tcommands_init_plot(\"Angle\", \"Hall Sensor State\");\n\t\t\t\tcommands_plot_add_graph(\"Hall 1\");\n\t\t\t\tcommands_plot_add_graph(\"Hall 2\");\n\t\t\t\tcommands_plot_add_graph(\"Hall 3\");\n\t\t\t\tcommands_plot_add_graph(\"Combined\");\n\n\t\t\t\tfloat phase = 0.0;\n\n\t\t\t\tfor (int i = 0;i < 1000;i++) {\n\t\t\t\t\ttimeout_reset();\n\t\t\t\t\tmc_interface_lock_override_once();\n\t\t\t\t\tmc_interface_set_openloop_phase((float)i * current / 1000.0, phase);\n\t\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchThdSleepMilliseconds(1);\n\t\t\t\t}\n\n\t\t\t\tbool is_second_motor = mc_interface_get_motor_thread() == 2;\n\t\t\t\tint hall_last = utils_read_hall(is_second_motor, mcconf->m_hall_extra_samples);\n\t\t\t\tfloat transitions[7] = {0.0};\n\t\t\t\tint states[8] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\t\t\t\tint transition_index = 0;\n\n\t\t\t\tif (fault == FAULT_CODE_NONE) {\n\n\t\t\t\t\tfor (int i = 0;i < 720;i++) {\n\t\t\t\t\t\tint hall = utils_read_hall(is_second_motor, mcconf->m_hall_extra_samples);\n\t\t\t\t\t\tif (hall_last != hall) {\n\t\t\t\t\t\t\tif (transition_index < 7) {\n\t\t\t\t\t\t\t\ttransitions[transition_index++] = phase;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (int j = 0;j < 8;j++) {\n\t\t\t\t\t\t\t\tif (states[j] == hall || states[j] == -1) {\n\t\t\t\t\t\t\t\t\tstates[j] = hall;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\thall_last = hall;\n\n\t\t\t\t\t\t// Notice that the plots are offset slightly in Y, to make it easier to see them.\n\t\t\t\t\t\tcommands_plot_set_graph(0);\n\t\t\t\t\t\tcommands_send_plot_points(phase, (float)(hall & 1) * 1.02);\n\t\t\t\t\t\tcommands_plot_set_graph(1);\n\t\t\t\t\t\tcommands_send_plot_points(phase, (float)((hall >> 1) & 1) * 1.04);\n\t\t\t\t\t\tcommands_plot_set_graph(2);\n\t\t\t\t\t\tcommands_send_plot_points(phase, (float)((hall >> 2) & 1) * 1.06);\n\t\t\t\t\t\tcommands_plot_set_graph(3);\n\t\t\t\t\t\tcommands_send_plot_points(phase, (float)hall);\n\n\t\t\t\t\t\tphase += 1.0;\n\t\t\t\t\t\ttimeout_reset();\n\t\t\t\t\t\tmc_interface_lock_override_once();\n\t\t\t\t\t\tmc_interface_set_openloop_phase(current, phase);\n\t\t\t\t\t\tfault = mc_interface_get_fault();\n\t\t\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchThdSleepMilliseconds(20);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmc_interface_lock_override_once();\n\t\t\t\tmc_interface_release_motor();\n\t\t\t\tmc_interface_wait_for_motor_release(1.0);\n\t\t\t\tmcconf->motor_type = motor_type_old;\n\t\t\t\tmc_interface_set_configuration(mcconf);\n\t\t\t\tmempools_free_mcconf(mcconf);\n\t\t\t\tmc_interface_unlock();\n\n\t\t\t\tif (fault != FAULT_CODE_NONE) {\n\t\t\t\t\tcommands_printf(\"Fault occured while analyzing hall sensors: %s\", mc_interface_fault_to_string(fault));\n\t\t\t\t\tcommands_printf(\"For more info type \\\"faults\\\" to view all logged faults\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint state_num = 0;\n\t\t\t\t\tfor (int i = 0;i < 8;i++) {\n\t\t\t\t\t\tif (states[i] != -1) {\n\t\t\t\t\t\t\tstate_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (state_num == 6) {\n\t\t\t\t\t\tcommands_printf(\"Found 6 different states. This seems correct.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Found %d different states. Something is most likely wrong...\\n\", state_num);\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat min = 900.0;\n\t\t\t\t\tfloat max = 0.0;\n\t\t\t\t\tfor (int i = 0;i < 6;i++) {\n\t\t\t\t\t\tfloat diff = fabsf(utils_angle_difference(transitions[i], transitions[i + 1]));\n\t\t\t\t\t\tcommands_printf(\"Hall diff %d: %.1f degrees\", i + 1, (double)diff);\n\t\t\t\t\t\tif (diff < min) {\n\t\t\t\t\t\t\tmin = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (diff > max) {\n\t\t\t\t\t\t\tmax = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat deviation = (max - min) / 2.0;\n\t\t\t\t\tif (deviation < 5) {\n\t\t\t\t\t\tcommands_printf(\"Maximum deviation: %.2f degrees. This is good alignment.\\n\", (double)deviation);\n\t\t\t\t\t} else if ((max - min) < 10) {\n\t\t\t\t\t\tcommands_printf(\"Maximum deviation: %.2f degrees. This is OK, but not great alignment.\\n\", (double)deviation);\n\t\t\t\t\t} else if ((max - min) < 15) {\n\t\t\t\t\t\tcommands_printf(\"Maximum deviation: %.2f degrees. This is bad, but probably usable alignment.\\n\", (double)deviation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands_printf(\"Maximum deviation: %.2f degrees. The hall sensors are significantly misaligned. This has \"\n\t\t\t\t\t\t\t\t\t\t\"to be fixed for proper operation.\\n\", (double)(max - min));\n\t\t\t\t\t}\n\n\t\t\t\t\tcommands_printf(\"Done. Go to the Realtime Data > Experiment page to see the plot.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid argument(s). Current must be between 0.0 and %.2f\\n\", (double)mc_interface_get_configuration()->l_current_max);\n\t\t\t}\n\t\t} else {\n\t\t\tcommands_printf(\"This command requires one argument. [current]\\n\");\n\t\t}\n\t} else if (strcmp(argv[0], \"crc\") == 0) {\n\t\tunsigned mc_crc0 = mc_interface_get_configuration()->crc;\n\t\tunsigned mc_crc1 = mc_interface_calc_crc(NULL, false);\n\t\tunsigned app_crc0 = app_get_configuration()->crc;\n\t\tunsigned app_crc1 = app_calc_crc(NULL);\n\t\tcommands_printf(\"MC CFG crc: 0x%04X (stored)  0x%04X (recalc)\", mc_crc0, mc_crc1);\n\t\tcommands_printf(\"APP CFG crc: 0x%04X (stored)  0x%04X (recalc)\", app_crc0, app_crc1);\n\t\tcommands_printf(\"Discrepancy is expected due to run-time recalculation of config params.\\n\");\n\t} else if (strcmp(argv[0], \"drv_reset_faults\") == 0) {\n\t\tHW_RESET_DRV_FAULTS();\n\t} else if (strcmp(argv[0], \"update_pid_pos_offset\") == 0) {\n\t\tif (argc == 3) {\n\t\t\tfloat angle_now = -500.0;\n\t\t\tint store = false;\n\n\t\t\tsscanf(argv[1], \"%f\", &angle_now);\n\t\t\tsscanf(argv[2], \"%d\", &store);\n\n\t\t\tif (angle_now > -360.0 && angle_now < 360.0) {\n\t\t\t\tmc_interface_update_pid_pos_offset(angle_now, store);\n\t\t\t\tcommands_printf(\"OK\\n\");\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"Invalid arguments\\n\");\n\t\t\t}\n\t\t}\n\t} else if (strcmp(argv[0], \"fw_info\") == 0) {\n\t\tcommands_printf(\"Git Branch: %s\", GIT_BRANCH_NAME);\n\t\tcommands_printf(\"Git Hash  : %s\", GIT_COMMIT_HASH);\n\t\tcommands_printf(\"Compiler  : %s\", ARM_GCC_VERSION);\n#ifdef USER_GIT_BRANCH_NAME\n\t\tcommands_printf(\"User Git Branch: %s\", USER_GIT_BRANCH_NAME);\n#endif\n#ifdef USER_GIT_COMMIT_HASH\n\t\tcommands_printf(\"User Git Hash  : %s\", USER_GIT_COMMIT_HASH);\n#endif\n\t\tcommands_printf(\" \");\n\t} else if (strcmp(argv[0], \"rebootwdt\") == 0) {\n\t\tchSysLock();\n\t\tfor (;;) {__NOP();}\n\t}\n\n\t// The help command\n\telse if (strcmp(argv[0], \"help\") == 0) {\n\t\tcommands_printf(\"Valid commands are:\");\n\t\tcommands_printf(\"help\");\n\t\tcommands_printf(\"  Show this help\");\n\n\t\tcommands_printf(\"last_adc_duration\");\n\t\tcommands_printf(\"  The time the latest ADC interrupt consumed\");\n\n\t\tcommands_printf(\"kv\");\n\t\tcommands_printf(\"  The calculated kv of the motor (BLDC)\");\n\n\t\tcommands_printf(\"mem\");\n\t\tcommands_printf(\"  Show memory usage\");\n\n\t\tcommands_printf(\"threads\");\n\t\tcommands_printf(\"  List all threads\");\n\n\t\tcommands_printf(\"fault\");\n\t\tcommands_printf(\"  Prints the current fault code\");\n\n\t\tcommands_printf(\"faults\");\n\t\tcommands_printf(\"  Prints all stored fault codes and conditions when they arrived\");\n\n\t\tcommands_printf(\"tim\");\n\t\tcommands_printf(\"  Prints tim1 and tim8 settings\");\n\n\t\tcommands_printf(\"volt\");\n\t\tcommands_printf(\"  Prints different voltages\");\n\n\t\tcommands_printf(\"param_detect [current] [min_rpm] [low_duty]\");\n\t\tcommands_printf(\"  Spin up the motor in COMM_MODE_DELAY and compute its parameters.\");\n\t\tcommands_printf(\"  This test should be performed without load on the motor.\");\n\t\tcommands_printf(\"  Example: param_detect 5.0 600 0.06\");\n\n\t\tcommands_printf(\"rpm_dep\");\n\t\tcommands_printf(\"  Prints some rpm-dep values\");\n\n\t\tcommands_printf(\"foc_encoder_detect [current]\");\n\t\tcommands_printf(\"  Run the motor at 1Hz on open loop and compute encoder settings\");\n\n\t\tcommands_printf(\"measure_res [current]\");\n\t\tcommands_printf(\"  Lock the motor with a current and calculate its resistance\");\n\n\t\tcommands_printf(\"measure_ind [duty]\");\n\t\tcommands_printf(\"  Send short voltage pulses, measure the current and calculate the motor inductance\");\n\n\t\tcommands_printf(\"measure_linkage [current] [duty] [min_erpm] [motor_res]\");\n\t\tcommands_printf(\"  Run the motor in BLDC delay mode and measure the flux linkage\");\n\t\tcommands_printf(\"  example measure_linkage 5 0.5 700 0.076\");\n\t\tcommands_printf(\"  tip: measure the resistance with measure_res first\");\n\n\t\tcommands_printf(\"measure_res_ind\");\n\t\tcommands_printf(\"  Measure the motor resistance and inductance with an incremental adaptive algorithm.\");\n\n\t\tcommands_printf(\"measure_linkage_foc [duty]\");\n\t\tcommands_printf(\"  Run the motor with FOC and measure the flux linkage.\");\n\n\t\tcommands_printf(\"measure_linkage_openloop [current] [duty] [erpm_per_sec] [motor_res] [motor_ind]\");\n\t\tcommands_printf(\"  Run the motor in openloop FOC and measure the flux linkage\");\n\t\tcommands_printf(\"  example measure_linkage_openloop 5 0.5 1000 0.076 0.000015\");\n\t\tcommands_printf(\"  tip: measure the resistance with measure_res first\");\n\n\t\tcommands_printf(\"foc_state\");\n\t\tcommands_printf(\"  Print some FOC state variables.\");\n\n\t\tcommands_printf(\"foc_dc_cal\");\n\t\tcommands_printf(\"  Calibrate current and voltage DC offsets.\");\n\n\t\tcommands_printf(\"hw_status\");\n\t\tcommands_printf(\"  Print some hardware status information.\");\n\n\t\tcommands_printf(\"foc_openloop [current] [erpm]\");\n\t\tcommands_printf(\"  Create an open loop rotating current vector.\");\n\n\t\tcommands_printf(\"foc_openloop_duty [duty] [erpm]\");\n\t\tcommands_printf(\"  Create an open loop rotating voltage vector.\");\n\n\t\tcommands_printf(\"nrf_ext_set_enabled [enabled]\");\n\t\tcommands_printf(\"  Enable or disable external NRF51822.\");\n\n\t\tcommands_printf(\"foc_sensors_detect_apply [current]\");\n\t\tcommands_printf(\"  Automatically detect FOC sensors, and apply settings on success.\");\n\n\t\tcommands_printf(\"rotor_lock_openloop [current_A] [time_S] [angle_DEG]\");\n\t\tcommands_printf(\"  Lock the motor with a current for a given time. Time 0 means forever, or\");\n\t\tcommands_printf(\"  or until the heartbeat packets stop.\");\n\n\t\tcommands_printf(\"foc_detect_apply_all [max_power_loss_W]\");\n\t\tcommands_printf(\"  Detect and apply all motor settings, based on maximum resistive motor power losses.\");\n\n\t\tcommands_printf(\"foc_detect_apply_all_can [max_power_loss_W]\");\n\t\tcommands_printf(\"  Detect and apply all motor settings, based on maximum resistive motor power losses. Also\");\n\t\tcommands_printf(\"  initiates detection in all VESCs found on the CAN-bus.\");\n\n\t\tcommands_printf(\"uptime\");\n\t\tcommands_printf(\"  Prints how many seconds have passed since boot.\");\n\n\t\tcommands_printf(\"hall_analyze [current]\");\n\t\tcommands_printf(\"  Rotate motor in open loop and analyze hall sensors.\");\n\n\t\tcommands_printf(\"crc\");\n\t\tcommands_printf(\"  Print CRC values.\");\n\n\t\tcommands_printf(\"drv_reset_faults\");\n\t\tcommands_printf(\"  Reset gate driver faults (if possible).\");\n\n\t\tcommands_printf(\"update_pid_pos_offset [angle_now] [store]\");\n\t\tcommands_printf(\"  Update position PID offset.\");\n\n\t\tcommands_printf(\"fw_info\");\n\t\tcommands_printf(\"  Print detailed firmware info.\");\n\n\t\tcommands_printf(\"rebootwdt\");\n\t\tcommands_printf(\"  Reboot using the watchdog timer.\");\n\n\t\tfor (int i = 0;i < callback_write;i++) {\n\t\t\tif (callbacks[i].cbf == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (callbacks[i].arg_names) {\n\t\t\t\tcommands_printf(\"%s %s\", callbacks[i].command, callbacks[i].arg_names);\n\t\t\t} else {\n\t\t\t\tcommands_printf(callbacks[i].command);\n\t\t\t}\n\n\t\t\tif (callbacks[i].help) {\n\t\t\t\tcommands_printf(\"  %s\", callbacks[i].help);\n\t\t\t} else {\n\t\t\t\tcommands_printf(\"  There is no help available for this command.\");\n\t\t\t}\n\t\t}\n\n\t\tcommands_printf(\" \");\n\t} else {\n\t\tcommands_printf(\"Invalid command: %s\\n\"\n\t\t\t\t\"type help to list all available commands\\n\", argv[0]);\n\t}\n}\n\nvoid terminal_add_fault_data(fault_data *data) {\n\tfault_vec[fault_vec_write++] = *data;\n\tif (fault_vec_write >= FAULT_VEC_LEN) {\n\t\tfault_vec_write = 0;\n\t}\n}\n\nmc_fault_code terminal_get_first_fault(void) {\n\tif (fault_vec_write == 0) {\n\t\treturn FAULT_CODE_NONE;\n\t} else {\n\t\treturn fault_vec[0].fault;\n\t}\n}\n\n/**\n * Register a custom command  callback to the terminal. If the command\n * is already registered the old command callback will be replaced.\n *\n * @param command\n * The command name.\n *\n * @param help\n * A help text for the command. Can be NULL.\n *\n * @param arg_names\n * The argument names for the command, e.g. [arg_a] [arg_b]\n * Can be NULL.\n *\n * @param cbf\n * The callback function for the command.\n */\nvoid terminal_register_command_callback(\n\t\tconst char* command,\n\t\tconst char *help,\n\t\tconst char *arg_names,\n\t\tvoid(*cbf)(int argc, const char **argv)) {\n\n\tint callback_num = callback_write;\n\n\tfor (int i = 0;i < callback_write;i++) {\n\t\t// First check the address in case the same callback is registered more than once.\n\t\tif (callbacks[i].command == command) {\n\t\t\tcallback_num = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check by string comparison.\n\t\tif (strcmp(callbacks[i].command, command) == 0) {\n\t\t\tcallback_num = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check if the callback is empty (unregistered)\n\t\tif (callbacks[i].cbf == 0) {\n\t\t\tcallback_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcallbacks[callback_num].command = command;\n\tcallbacks[callback_num].help = help;\n\tcallbacks[callback_num].arg_names = arg_names;\n\tcallbacks[callback_num].cbf = cbf;\n\n\tif (callback_num == callback_write) {\n\t\tcallback_write++;\n\t\tif (callback_write >= CALLBACK_LEN) {\n\t\t\tcallback_write = 0;\n\t\t}\n\t}\n}\n\nvoid terminal_unregister_callback(void(*cbf)(int argc, const char **argv)) {\n\tfor (int i = 0;i < callback_write;i++) {\n\t\tif (callbacks[i].cbf == cbf) {\n\t\t\tcallbacks[i].cbf = 0;\n\t\t}\n\t}\n}\n\n#pragma GCC pop_options\n"
        },
        {
          "name": "terminal.h",
          "type": "blob",
          "size": 1.2099609375,
          "content": "/*\n\tCopyright 2016 - 2022 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef TERMINAL_H_\n#define TERMINAL_H_\n\n#include \"datatypes.h\"\n\n// Functions\nvoid terminal_process_string(char *str);\nvoid terminal_add_fault_data(fault_data *data);\nmc_fault_code terminal_get_first_fault(void);\nvoid terminal_register_command_callback(\n\t\tconst char* command,\n\t\tconst char *help,\n\t\tconst char *arg_names,\n\t\tvoid(*cbf)(int argc, const char **argv));\nvoid terminal_unregister_callback(void(*cbf)(int argc, const char **argv));\n\n#endif /* TERMINAL_H_ */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "timeout.c",
          "type": "blob",
          "size": 6.7900390625,
          "content": "/*\n\tCopyright 2016 - 2021 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#include \"timeout.h\"\n#include \"mc_interface.h\"\n#include \"stm32f4xx_conf.h\"\n#include \"shutdown.h\"\n#include \"utils.h\"\n\n// Private variables\nstatic volatile bool init_done = false;\nstatic volatile systime_t timeout_msec;\nstatic volatile systime_t last_update_time;\nstatic volatile float timeout_brake_current;\nstatic volatile KILL_SW_MODE timeout_kill_sw_mode;\nstatic volatile bool has_timeout;\nstatic volatile bool kill_sw_active;\nstatic volatile uint32_t feed_counter[MAX_THREADS_MONITOR];\n\n// Threads\nstatic THD_WORKING_AREA(timeout_thread_wa, 256);\nstatic THD_FUNCTION(timeout_thread, arg);\n\nvoid timeout_init(void) {\n\ttimeout_msec = 1000;\n\tlast_update_time = 0;\n\ttimeout_brake_current = 0.0;\n\ttimeout_kill_sw_mode = KILL_SW_MODE_DISABLED;\n\thas_timeout = false;\n\tkill_sw_active = false;\n\tinit_done = true;\n\n\tIWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);\n\n\t// IWDG counter clock: LSI/4\n\tIWDG_SetPrescaler(IWDG_Prescaler_4);\n\n\t/* Set counter reload value to obtain 12ms IWDG TimeOut.\n\t *\n\t * LSI timer per datasheet is 32KHz typical, but 17KHz min\n\t * and 47KHz max over the complete range of operating conditions,\n\t * so reload time must ensure watchdog will work correctly under\n\t * all conditions.\n\t *\n\t * Timeout threads runs every 10ms. Take 20% margin so wdt should\n\t * be fed every 12ms. The worst condition occurs when the wdt clock\n\t * runs at the max freq (47KHz) due to oscillator tolerances.\n\t *\n\t * t_IWDG(ms) = t_LSI(ms) * 4 * 2^(IWDG_PR[2:0]) * (IWDG_RLR[11:0] + 1)\n\t * t_LSI(ms) [MAX] = 0.021276ms\n\t * 12ms = 0.0212765 * 4 * 1 * (140 + 1)\n\t *\n\t * Counter Reload Value = 140\n\t *\n\t * When LSI clock runs the slowest, the IWDG will expire every 33.17ms\n\t*/\n\tIWDG_SetReload(140);\n\n\tIWDG_ReloadCounter();\n\n\t/* Enable IWDG (the LSI oscillator will be enabled by hardware) */\n\tIWDG_Enable();\n\n\tchThdSleepMilliseconds(10);\n\n\tchThdCreateStatic(timeout_thread_wa, sizeof(timeout_thread_wa), NORMALPRIO, timeout_thread, NULL);\n}\n\nvoid timeout_configure(systime_t timeout, float brake_current, KILL_SW_MODE kill_sw_mode) {\n\ttimeout_msec = timeout;\n\ttimeout_brake_current = brake_current;\n\ttimeout_kill_sw_mode = kill_sw_mode;\n}\n\nvoid timeout_reset(void) {\n\tlast_update_time = chVTGetSystemTimeX();\n}\n\nbool timeout_has_timeout(void) {\n\treturn has_timeout;\n}\n\nfloat timeout_secs_since_update(void) {\n\treturn UTILS_AGE_S(last_update_time);\n}\n\nbool timeout_kill_sw_active(void) {\n\treturn kill_sw_active;\n}\n\nsystime_t timeout_get_timeout_msec(void) {\n\treturn timeout_msec;\n}\n\nfloat timeout_get_brake_current(void) {\n\treturn timeout_brake_current;\n}\n\nKILL_SW_MODE timeout_get_kill_sw_mode(void) {\n\treturn timeout_kill_sw_mode;\n}\n\nvoid timeout_feed_WDT(uint8_t index) {\n\t++feed_counter[index];\n}\n\nvoid timeout_configure_IWDT_slowest(void) {\n\tif (!init_done) {\n\t\treturn;\n\t}\n\n\t// As we expect to lock the CPU for a couple of ms make sure that shutdown is not sampling the button input,\n\t// as that can cause a shutdown.\n\tSHUTDOWN_SET_SAMPLING_DISABLED(true);\n\n\twhile(((IWDG->SR & IWDG_SR_RVU) != 0) || ((IWDG->SR & IWDG_SR_PVU) != 0)) {\n\t\t// Continue to kick the dog\n\t\tIWDG_ReloadCounter();\n\t}\n\n\t// Unlock register\n\tIWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);\n\t// Update configuration\n\tIWDG_SetReload(4000);\n\tIWDG_SetPrescaler(IWDG_Prescaler_256);\n\n\t// Wait for the new configuration to be taken into account\n\twhile(((IWDG->SR & IWDG_SR_RVU) != 0) || ((IWDG->SR & IWDG_SR_PVU) != 0)) {\n\t\t// Continue to kick the dog\n\t\tIWDG_ReloadCounter();\n\t}\n}\n\nvoid timeout_configure_IWDT(void) {\n\tif (!init_done) {\n\t\treturn;\n\t}\n\n\tSHUTDOWN_SET_SAMPLING_DISABLED(false);\n\n\twhile(((IWDG->SR & IWDG_SR_RVU) != 0) || ((IWDG->SR & IWDG_SR_PVU) != 0)) {\n\t\t// Continue to kick the dog\n\t\tIWDG_ReloadCounter();\n\t}\n\n\t// Unlock register\n\tIWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);\n\t// Update configuration\n\tIWDG_SetReload(140);\n\tIWDG_SetPrescaler(IWDG_Prescaler_4);\n\n\t// Wait for the new configuration to be taken into account\n\twhile(((IWDG->SR & IWDG_SR_RVU) != 0) || ((IWDG->SR & IWDG_SR_PVU) != 0)) {\n\t\t// Continue to kick the dog\n\t\tIWDG_ReloadCounter();\n\t}\n}\n\nbool timeout_had_IWDG_reset(void) {\n\t// Check if the system has resumed from IWDG reset\n\tif (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET) {\n\t\t/* IWDGRST flag set */\n\t\t/* Clear reset flags */\n\t\tRCC_ClearFlag();\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic THD_FUNCTION(timeout_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"Timeout\");\n\n\tfor(;;) {\n\t\tbool kill_sw = false;\n\n\t\tswitch (timeout_kill_sw_mode) {\n\t\tcase KILL_SW_MODE_PPM_LOW:\n\t\t\tkill_sw = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);\n\t\t\tbreak;\n\n\t\tcase KILL_SW_MODE_PPM_HIGH:\n\t\t\tkill_sw = palReadPad(HW_ICU_GPIO, HW_ICU_PIN);\n\t\t\tbreak;\n\n\t\tcase KILL_SW_MODE_ADC2_LOW:\n\t\t\tkill_sw = ADC_VOLTS(ADC_IND_EXT2) < 1.65;\n\t\t\tbreak;\n\n\t\tcase KILL_SW_MODE_ADC2_HIGH:\n\t\t\tkill_sw = ADC_VOLTS(ADC_IND_EXT2) > 1.65;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (kill_sw || (timeout_msec != 0 && chVTTimeElapsedSinceX(last_update_time) > MS2ST(timeout_msec))) {\n\t\t\tif (!has_timeout && !kill_sw_active) {\n\t\t\t\tmc_interface_release_motor_override();\n\t\t\t}\n\t\t\tmc_interface_unlock();\n\t\t\tmc_interface_select_motor_thread(1);\n\t\t\tmc_interface_set_brake_current(timeout_brake_current);\n\t\t\tmc_interface_select_motor_thread(2);\n\t\t\tmc_interface_set_brake_current(timeout_brake_current);\n\n\t\t\tif (kill_sw) {\n\t\t\t\tmc_interface_ignore_input_both(20);\n\t\t\t} else {\n\t\t\t\thas_timeout = true;\n\t\t\t}\n\t\t} else {\n\t\t\thas_timeout = false;\n\t\t}\n\n\t\tkill_sw_active = kill_sw;\n\n\t\tbool threads_ok = true;\n\n\t\t// Monitored threads (foc, can, timer) must report at least one iteration,\n\t\t// otherwise the watchdog won't be feed and MCU will reset. All threads should\n\t\t// be monitored\n\t\tif(feed_counter[THREAD_MCPWM] < MIN_THREAD_ITERATIONS) {\n\t\t\tthreads_ok = false;\n\t\t}\n\n#if CAN_ENABLE\n\t\tif(feed_counter[THREAD_CANBUS] < MIN_THREAD_ITERATIONS) {\n\t\t\tthreads_ok = false;\n\t\t}\n#endif\n\n\t\tfor( int i = 0; i < MAX_THREADS_MONITOR; i++) {\n\t\t\tfeed_counter[i] = 0;\n\t\t}\n\n\t\tif (threads_ok == true) {\n\t\t\t// Feed WDT\n\t\t\tIWDG_ReloadCounter();\t// must reload in <12ms\n\t\t} else {\n\t\t\t// not reloading the watchdog will produce a reset.\n\t\t\t// This can be checked from the GUI logs as\n\t\t\t// \"FAULT_CODE_BOOTING_FROM_WATCHDOG_RESET\"\n\t\t}\n\n\t\tchThdSleepMilliseconds(10);\n\t}\n}\n"
        },
        {
          "name": "timeout.h",
          "type": "blob",
          "size": 1.5751953125,
          "content": "/*\n\tCopyright 2016 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#ifndef TIMEOUT_H_\n#define TIMEOUT_H_\n\n#include \"ch.h\"\n#include \"chtypes.h\"\n#include \"chsystypes.h\"\n#include \"datatypes.h\"\n\n#define MAX_THREADS_MONITOR\t\t10\n#define MIN_THREAD_ITERATIONS\t1\n\ntypedef enum {\n\tTHREAD_MCPWM = 0,\n\tTHREAD_CANBUS,\n\tTHREAD_USB,\n\tTHREAD_APP\n} WWDT_THREAD_TYPES;\n\n// Functions\nvoid timeout_init(void);\nvoid timeout_configure(systime_t timeout, float brake_current, KILL_SW_MODE kill_sw_mode);\nvoid timeout_reset(void);\nbool timeout_has_timeout(void);\nfloat timeout_secs_since_update(void);\nbool timeout_kill_sw_active(void);\nsystime_t timeout_get_timeout_msec(void);\nvoid timeout_configure_IWDT(void);\nvoid timeout_configure_IWDT_slowest(void);\nbool timeout_had_IWDG_reset(void);\nvoid timeout_feed_WDT(uint8_t index);\nfloat timeout_get_brake_current(void);\nKILL_SW_MODE timeout_get_kill_sw_mode(void);\n\n#endif /* TIMEOUT_H_ */\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}