{
  "metadata": {
    "timestamp": 1736710179798,
    "page": 866,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cesanta/elk",
      "stars": 1677,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7158203125,
          "content": "Copyright (c) 2013-2021 Cesanta Software Limited\nAll rights reserved\n\nThis software is dual-licensed: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License version 3 as\npublished by the Free Software Foundation. For the terms of this\nlicense, see http://www.fsf.org/licensing/licenses/agpl-3.0.html\n\nYou are free to use this software under the terms of the GNU Affero General\nPublic License, but WITHOUT ANY WARRANTY; without even the implied\nwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nSee the GNU General Public License for more details.\n\nAlternatively, you can license this software under a commercial\nlicense, please contact us at https://cesanta.com/contact.html\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.994140625,
          "content": "# Elk: a tiny JS engine for embedded systems\n\n[![Build Status](https://github.com/cesanta/elk/workflows/build/badge.svg)](https://github.com/cesanta/elk/actions)\n[![License: AGPL/Commercial](https://img.shields.io/badge/License-AGPL%20or%20Commercial-green.svg)](https://opensource.org/licenses/gpl-2.0.php)\n[![Code Coverage](https://codecov.io/gh/cesanta/elk/branch/master/graph/badge.svg)](https://codecov.io/gh/cesanta/elk)\n\n\nElk is a tiny embeddable JavaScript engine that implements a small but usable\nsubset of ES6. It is designed for microcontroller development. Instead of\nwriting firmware code entirely in C/C++, Elk allows to add JavaScript\ncustomisations to the firmware developed in C - which is a great way to let\ncustomers to extend/customise device functionality.\n\nElk features include:\n\n- Cross platform. Works anywhere from 8-bit microcontrollers to 64-bit servers\n- Zero dependencies. Builds cleanly by ISO C or ISO C++ compilers\n- Easy to embed: just copy `elk.c` and `elk.h` to your source tree\n- Small and simple embedding API\n- Does not use malloc. Operates with a given memory buffer only\n- Small footprint: about 20KB on flash/disk, about 100 bytes RAM for core VM\n- No bytecode. Interprets JS code directly\n\nElk approach is different from other scripting environments like micropython,\nwhich provide a complete JS API for everything.  Elk is completely bare, it\ndoes not even have a standard library. All required functionality is supposed\nto be imported from C/C++ firmware, and JS code simply orchestrates things.\nThat leaves Elk very minimal and tunable.\n\nBelow is a blinky demonstration on a classic Arduino Nano board which has\n2K RAM and 30K flash (see [full sketch](examples/BlinkyJS/BlinkyJS.ino)):\n\n![Elk on Arduino Nano](test/nano.gif)\n\n\n## JavaScript on ESP32\n\nThe [Esp32JS](examples/Esp32JS) Arduino sketch is an example of Elk integration\nwith ESP32. Flash this sketch on your ESP32 board, go to\nhttps://cesanta.com/elk, and get a JavaScript development environment\ninstantly! All components, including ESP32 firmware and Web editor, are open.\nHere how it looks like:\n\n![](test/editor.png)\n\nThe example JS firmware implements a classic blinky that uses timers imported\nfrom C.\n\n\n## Call JavaScript from C\n```c\n#include <stdio.h>\n#include \"elk.h\"\n\nint main(void) {\n  char mem[200];\n  struct js *js = js_create(mem, sizeof(mem));  // Create JS instance\n  jsval_t v = js_eval(js, \"1 + 2 * 3\", ~0);     // Execute JS code\n  printf(\"result: %s\\n\", js_str(js, v));        // result: 7\n  return 0;\n}\n```\n\n## Call C from JavaScript\n\nThis demonstrates how JS code can import and call existing C functions:\n\n```c\n#include <stdio.h>\n#include \"elk.h\"\n\n// C function that adds two numbers. Will be called from JS\njsval_t sum(struct js *js, jsval_t *args, int nargs) {\n  if (nargs != 2) return js_err(js, \"2 args expected\");\n  double a = js_getnum(args[0]);  // Fetch 1st arg\n  double b = js_getnum(args[1]);  // Fetch 2nd arg\n  return js_mknum(a + b);\n}\n\nint main(void) {\n  char mem[200];\n  struct js *js = js_create(mem, sizeof(mem));      // Create JS instance\n  js_set(js, js_glob(js), \"sum\", js_mkfun(sum)));   // Import sum()\n  jsval_t result = js_eval(js, \"sum(3, 4);\", ~0);   // Call sum\n  printf(\"result: %s\\n\", js_str(js, result));       // result: 7\n  return 0;\n}\n```\n\n## Supported features\n\n- Operations: all standard JS operations except:\n   - `!=`, `==`. Use strict comparison `!==`, `===`\n   - No computed member access `a[b]`\n   - No exponentiation operation `a ** b`\n- Typeof: `typeof('a') === 'string'`\n- For loop: `for (...;...;...)  ...`\n- Conditional: `if (...) ... else ...`\n- Ternary operator `a ? b : c`\n- Simple types: `let a, b, c = 12.3, d = 'a', e = null, f = true, g = false;`\n- Functions: `let f = function(x, y) { return x + y; };`\n- Objects: `let obj = {f: function(x) { return x * 2}}; obj.f(3);`\n- Every statement must end with a semicolon `;`\n- Strings are binary data chunks, not Unicode strings: `'Київ'.length === 8`\n\n## Not supported features\n\n- No `var`, no `const`. Use `let` (strict mode only)\n- No `do`, `switch`, `while`. Use `for`\n- No `=>` functions. Use `let f = function(...) {...};`\n- No arrays, closures, prototypes, `this`, `new`, `delete`\n- No standard library: no `Date`, `Regexp`, `Function`, `String`, `Number`\n\n## Performance\n\nSince Elk parses and interprets JS code on the fly, it is not meant to be\nused in a performance-critical scenarios. For example, below are the numbers\nfor a simple loop code on a different architectures.\n\n```javascript\nfor (let i = 0; i < 100; i++) true;\n// 97 milliseconds on a 16Mhz 8-bit Atmega328P (Arduino Uno and alike)\n// 16 milliseconds on a 48Mhz SAMD21\n//  5 milliseconds on a 133Mhz Raspberry RP2040\n//  2 milliseconds on a 240Mhz ESP32\n```\n\n## Build options\n\nAvailable preprocessor definitions:\n\n| Name         | Default   | Description |\n| ------------ | --------- | ----------- |\n|`JS_EXPR_MAX` | 20        | Maximum tokens in expression. Expression evaluation function declares an on-stack array `jsval_t stk[JS_EXPR_MAX];`. Increase to allow very long expressions. Reduce to save C stack space. |\n|`JS_DUMP`     | undefined | Define to enable `js_dump(struct js *)` function which prints JS memory internals to stdout |\n\nNote: on ESP32 or ESP8266, compiled functions go into the `.text` ELF\nsection and subsequently into the IRAM MCU memory. It is possible to save\nIRAM space by copying Elk code into the irom section before linking.\nFirst, compile the object file, then rename `.text` section, e.g. for ESP32:\n\n```sh\n$ xtensa-esp32-elf-gcc $CFLAGS elk.c -c elk.tmp\n$ xtensa-esp32-elf-objcopy --rename-section .text=.irom0.text elk.tmp elk.o\n```\n\nNote: Elk uses `snprintf()` standard function to format numbers (double).\nOn some architectures, for example AVR Arduino, that standard function does\nnot support float formatting - therefore printing numbers may output nothing\nor `?` symbols.\n\n## API reference\n\n### js\\_create()\n\n```c\nstruct js *js_create(void *buf, size_t len);\n```\n\nInitialize JS engine in a given memory block. Elk will only use that memory\nblock to hold its runtime, and never use any extra memory.\nReturn: a non-`NULL` opaque pointer on success, or `NULL` when\n`len` is too small. The minimum `len` is about 100 bytes.\n\nThe given memory buffer is laid out in the following way:\n```\n  | <-------------------------------- len ------------------------------> |\n  | struct js, ~100 bytes  |   runtime vars    |    free memory           | \n```\n\n### js\\_eval()\n\n```c\njsval_t js_eval(struct js *, const char *buf, size_t len);\n```\n\nEvaluate JS code in `buf`, `len` and return result of the evaluation.  During\nthe evaluation, Elk stores variables in the \"runtime\" memory section. When\n`js_eval()` returns, Elk does not keep any reference to the evaluated code: all\nstrings, functions, etc, are copied to the runtime.\n\nImportant note: the returned result is valid only before the next call to\n`js_eval()`. The reason is that `js_eval()` triggers a garbage collection.\nA garbage collection is mark-and-sweep, run before every top-level statement\ngets executed.\n\nThe runtime footprint is as follows:\n- An empty object is 8 bytes\n- Each object property is 16 bytes\n- A string is 4 bytes + string length, aligned to 4 byte boundary\n- A C stack usage is ~200 bytes per nested expression evaluation\n\n\n### js\\_str()\n\n```c\nconst char *js_str(struct js *, jsval_t val);\n```\n\nStringify JS value `val` and return a pointer to a 0-terminated result.\nThe string is allocated in the \"free\" memory section. If there is no\nenough space there, an empty string is returned. The returned pointer\nis valid until the next `js_eval()` call.\n\n### js\\_glob()\n\n```c\njsval_t js_glob(struct js *);\n```\n\nReturn global JS object, i.e. a root namespace.\n\n\n### js\\_mk\\*()\n\n```c\njsval_t js_mkundef(void);  // Create undefined\njsval_t js_mknull(void);   // Create null, null, true, false\njsval_t js_mktrue(void);   // Create true\njsval_t js_mkfalse(void);  // Create false\njsval_t js_mkstr(struct js *, const void *, size_t);           // Create string\njsval_t js_mknum(double);                                      // Create number\njsval_t js_mkerr(struct js *js, const char *fmt, ...);         // Create error\njsval_t js_mkfun(jsval_t (*fn)(struct js *, jsval_t *, int));  // Create func\njsval_t js_mkobj(struct js *);                                 // Create object\nvoid js_set(struct js *, jsval_t, const char *, jsval_t);      // Set obj attr\n```\n\nCreate JS values from C values\n\n### js\\_get\\*()\n\n```c\nenum { JS_UNDEF, JS_NULL, JS_TRUE, JS_FALSE, JS_STR, JS_NUM, JS_ERR, JS_PRIV };\nint js_type(jsval_t val);       // Return JS value type\ndouble js_getnum(jsval_t val);  // Get number\nint js_getbool(jsval_t val);    // Get boolean, 0 or 1\nchar *js_getstr(struct js *js, jsval_t val, size_t *len);  // Get string\n```\n\nExtract C values from JS values\n\n### js\\_chkargs()\n\n```c\nbool js_chkargs(jsval_t *args, int nargs, const char *spec);\n```\n\nA helper function that checks a validity of the arguments passed to a function.\nA `spec` is a 0-terminated string where each character represents a type of\nthe expected argument: `b` for `bool`, `d` for number, `s` for string, `j`\nfor any other JS value.\n\nUsage example - a C function that implements a JS function\n`greater_than(number1, number2)`:\n\n```c\nstatic jsval_t js_gt(struct js *js, jsval_t *args, int nargs) {\n  if (!js_chkargs(args, nargs, \"dd\")) return js_mkerr(js, \"bad args!\");\n  return js_getnum(args[0]) > js_getnum(args[1]) ? js_mktrue() : js_mkfalse();\n}\n```\n\n### js\\_setmaxcss()\n\n```c\nvoid js_setmaxcss(struct js *, size_t max);\n```\n\nSet maximum allowed C stack size usage\n\n### js\\_stats()\n\n```c\nvoid js_stats(struct js *, size_t *total, size_t *min, size_t *cstacksize);\n```\n\nReturn resource usage statistics: `total` for total usable JS memory, `min`\nfor the lowest free JS memory observed (low watermark), and `cstacksize` for\nthe largest C stack usage observed.\n\n### js\\_dump()\n\n```c\nvoid js_dump(struct js *);\n```\n\nPrint debug info about the current JS state to stdout. Requires `-DJS_DUMP`\n\n## LICENSE\n\nDual license: AGPLv3 or commercial. For commercial licensing, technical support\nand integration help, please contact us at https://cesanta.com/contact.html\n"
        },
        {
          "name": "elk.c",
          "type": "blob",
          "size": 56.3173828125,
          "content": "// Copyright (c) 2013-2022 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License version 3 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.fsf.org/licensing/licenses/agpl-3.0.html\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, please contact us at https://cesanta.com/contact.html\n\n#if defined(__GNUC__) && !defined(JS_OPT) && !defined(ARDUINO_AVR_UNO) && \\\n    !defined(ARDUINO_AVR_NANO) && !defined(ARDUINO_AVR_PRO) &&            \\\n    !defined(__APPLE__)\n#pragma GCC optimize(\"O3,inline\")\n#endif\n\n#include <assert.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"elk.h\"\n\n#ifndef JS_EXPR_MAX\n#define JS_EXPR_MAX 20\n#endif\n\n#ifndef JS_GC_THRESHOLD\n#define JS_GC_THRESHOLD 0.75\n#endif\n\ntypedef uint32_t jsoff_t;\n\nstruct js {\n  jsoff_t css;        // Max observed C stack size\n  jsoff_t lwm;        // JS RAM low watermark: min free RAM observed\n  const char *code;   // Currently parsed code snippet\n  char errmsg[33];    // Error message placeholder\n  uint8_t tok;        // Last parsed token value\n  uint8_t consumed;   // Indicator that last parsed token was consumed\n  uint8_t flags;      // Execution flags, see F_* constants below\n#define F_NOEXEC 1U   // Parse code, but not execute\n#define F_LOOP 2U     // We're inside the loop\n#define F_CALL 4U     // We're inside a function call\n#define F_BREAK 8U    // Exit the loop\n#define F_RETURN 16U  // Return has been executed\n  jsoff_t clen;       // Code snippet length\n  jsoff_t pos;        // Current parsing position\n  jsoff_t toff;       // Offset of the last parsed token\n  jsoff_t tlen;       // Length of the last parsed token\n  jsoff_t nogc;       // Entity offset to exclude from GC\n  jsval_t tval;       // Holds last parsed numeric or string literal value\n  jsval_t scope;      // Current scope\n  uint8_t *mem;       // Available JS memory\n  jsoff_t size;       // Memory size\n  jsoff_t brk;        // Current mem usage boundary\n  jsoff_t gct;        // GC threshold. If brk > gct, trigger GC\n  jsoff_t maxcss;     // Maximum allowed C stack size usage\n  void *cstk;         // C stack pointer at the beginning of js_eval()\n};\n\n// A JS memory stores diffenent entities: objects, properties, strings\n// All entities are packed to the beginning of a buffer.\n// The `brk` marks the end of the used memory:\n//\n//    | entity1 | entity2| .... |entityN|         unused memory        |\n//    |---------|--------|------|-------|------------------------------|\n//  js.mem                           js.brk                        js.size\n//\n//  Each entity is 4-byte aligned, therefore 2 LSB bits store entity type.\n//  Object:   8 bytes: offset of the first property, offset of the upper obj\n//  Property: 8 bytes + val: 4 byte next prop, 4 byte key offs, N byte value\n//  String:   4xN bytes: 4 byte len << 2, 4byte-aligned 0-terminated data\n//\n// If C functions are imported, they use the upper part of memory as stack for\n// passing params. Each argument is pushed to the top of the memory as jsval_t,\n// and js.size is decreased by sizeof(jsval_t), i.e. 8 bytes. When function\n// returns, js.size is restored back. So js.size is used as a stack pointer.\n\n// clang-format off\nenum { \n  TOK_ERR, TOK_EOF, TOK_IDENTIFIER, TOK_NUMBER, TOK_STRING, TOK_SEMICOLON,\n  TOK_LPAREN, TOK_RPAREN, TOK_LBRACE, TOK_RBRACE,\n  // Keyword tokens\n  TOK_BREAK = 50, TOK_CASE, TOK_CATCH, TOK_CLASS, TOK_CONST, TOK_CONTINUE,\n  TOK_DEFAULT, TOK_DELETE, TOK_DO, TOK_ELSE, TOK_FINALLY, TOK_FOR, TOK_FUNC,\n  TOK_IF, TOK_IN, TOK_INSTANCEOF, TOK_LET, TOK_NEW, TOK_RETURN, TOK_SWITCH,\n  TOK_THIS, TOK_THROW, TOK_TRY, TOK_VAR, TOK_VOID, TOK_WHILE, TOK_WITH,\n  TOK_YIELD, TOK_UNDEF, TOK_NULL, TOK_TRUE, TOK_FALSE,\n  // JS Operator tokens\n  TOK_DOT = 100, TOK_CALL, TOK_POSTINC, TOK_POSTDEC, TOK_NOT, TOK_TILDA,    // 100\n  TOK_TYPEOF, TOK_UPLUS, TOK_UMINUS, TOK_EXP, TOK_MUL, TOK_DIV, TOK_REM,    // 106\n  TOK_PLUS, TOK_MINUS, TOK_SHL, TOK_SHR, TOK_ZSHR, TOK_LT, TOK_LE, TOK_GT,  // 113\n  TOK_GE, TOK_EQ, TOK_NE, TOK_AND, TOK_XOR, TOK_OR, TOK_LAND, TOK_LOR,      // 121 \n  TOK_COLON, TOK_Q,  TOK_ASSIGN, TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN,\n  TOK_MUL_ASSIGN, TOK_DIV_ASSIGN, TOK_REM_ASSIGN, TOK_SHL_ASSIGN,\n  TOK_SHR_ASSIGN, TOK_ZSHR_ASSIGN, TOK_AND_ASSIGN, TOK_XOR_ASSIGN,\n  TOK_OR_ASSIGN, TOK_COMMA,\n};\n\nenum {\n  // IMPORTANT: T_OBJ, T_PROP, T_STR must go first.  That is required by the\n  // memory layout functions: memory entity types are encoded in the 2 bits,\n  // thus type values must be 0,1,2,3\n  T_OBJ, T_PROP, T_STR, T_UNDEF, T_NULL, T_NUM, T_BOOL, T_FUNC, T_CODEREF,\n  T_CFUNC, T_ERR\n};\n\nstatic const char *typestr(uint8_t t) {\n  const char *names[] = { \"object\", \"prop\", \"string\", \"undefined\", \"null\",\n                          \"number\", \"boolean\", \"function\", \"coderef\",\n                          \"cfunc\", \"err\", \"nan\" };\n  return (t < sizeof(names) / sizeof(names[0])) ? names[t] : \"??\";\n}\n\n// Pack JS values into uin64_t, double nan, per IEEE 754\n// 64bit \"double\": 1 bit sign, 11 bits exponent, 52 bits mantissa\n//\n// seeeeeee|eeeemmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm\n// 11111111|11110000|00000000|00000000|00000000|00000000|00000000|00000000 inf\n// 11111111|11111000|00000000|00000000|00000000|00000000|00000000|00000000 qnan\n//\n// 11111111|1111tttt|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv\n//  NaN marker |type|  48-bit placeholder for values: pointers, strings\n//\n// On 64-bit platforms, pointers are really 48 bit only, so they can fit,\n// provided they are sign extended\nstatic jsval_t tov(double d) { union { double d; jsval_t v; } u = {d}; return u.v; }\nstatic double tod(jsval_t v) { union { jsval_t v; double d; } u = {v}; return u.d; }\nstatic jsval_t mkval(uint8_t type, uint64_t data) { return ((jsval_t) 0x7ff0U << 48U) | ((jsval_t) (type) << 48) | (data & 0xffffffffffffUL); }\nstatic bool is_nan(jsval_t v) { return (v >> 52U) == 0x7ffU; }\nstatic uint8_t vtype(jsval_t v) { return is_nan(v) ? ((v >> 48U) & 15U) : (uint8_t) T_NUM; }\nstatic size_t vdata(jsval_t v) { return (size_t) (v & ~((jsval_t) 0x7fffUL << 48U)); }\nstatic jsval_t mkcoderef(jsval_t off, jsoff_t len) { return mkval(T_CODEREF, (off & 0xffffffU) | ((jsval_t)(len & 0xffffffU) << 24U)); }\nstatic jsoff_t coderefoff(jsval_t v) { return v & 0xffffffU; }\nstatic jsoff_t codereflen(jsval_t v) { return (v >> 24U) & 0xffffffU; }\n\nstatic uint8_t unhex(uint8_t c) { return (c >= '0' && c <= '9') ? (uint8_t) (c - '0') : (c >= 'a' && c <= 'f') ? (uint8_t) (c - 'W') : (c >= 'A' && c <= 'F') ? (uint8_t) (c - '7') : 0; }\nstatic bool is_space(int c) { return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t' || c == '\\f' || c == '\\v'; }\nstatic bool is_digit(int c) { return c >= '0' && c <= '9'; }\nstatic bool is_xdigit(int c) { return is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }\nstatic bool is_alpha(int c) { return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'); }\nstatic bool is_ident_begin(int c) { return c == '_' || c == '$' || is_alpha(c); }\nstatic bool is_ident_continue(int c) { return c == '_' || c == '$' || is_alpha(c) || is_digit(c); }\nstatic bool is_err(jsval_t v) { return vtype(v) == T_ERR; }\nstatic bool is_unary(uint8_t tok) { return tok >= TOK_POSTINC && tok <= TOK_UMINUS; }\nstatic bool is_assign(uint8_t tok) { return (tok >= TOK_ASSIGN && tok <= TOK_OR_ASSIGN); }\nstatic void saveoff(struct js *js, jsoff_t off, jsoff_t val) { memcpy(&js->mem[off], &val, sizeof(val)); }\nstatic void saveval(struct js *js, jsoff_t off, jsval_t val) { memcpy(&js->mem[off], &val, sizeof(val)); }\nstatic jsoff_t loadoff(struct js *js, jsoff_t off) { jsoff_t v = 0; assert(js->brk <= js->size); memcpy(&v, &js->mem[off], sizeof(v)); return v; }\nstatic jsoff_t offtolen(jsoff_t off) { return (off >> 2) - 1; }\nstatic jsoff_t vstrlen(struct js *js, jsval_t v) { return offtolen(loadoff(js, (jsoff_t) vdata(v))); }\nstatic jsval_t loadval(struct js *js, jsoff_t off) { jsval_t v = 0; memcpy(&v, &js->mem[off], sizeof(v)); return v; }\nstatic jsval_t upper(struct js *js, jsval_t scope) { return mkval(T_OBJ, loadoff(js, (jsoff_t) (vdata(scope) + sizeof(jsoff_t)))); }\nstatic jsoff_t align32(jsoff_t v) { return ((v + 3) >> 2) << 2; }\n\n#define CHECKV(_v) do { if (is_err(_v)) { res = (_v); goto done; } } while (0)\n#define EXPECT(_tok, _e) do { if (next(js) != _tok) { _e; return js_mkerr(js, \"parse error\"); }; js->consumed = 1; } while (0)\n// clang-format on\n\n// Forward declarations of the private functions\nstatic size_t tostr(struct js *js, jsval_t value, char *buf, size_t len);\nstatic jsval_t js_expr(struct js *js);\nstatic jsval_t js_stmt(struct js *js);\nstatic jsval_t do_op(struct js *, uint8_t op, jsval_t l, jsval_t r);\n\nstatic void setlwm(struct js *js) {\n  jsoff_t n = 0, css = 0;\n  if (js->brk < js->size) n = js->size - js->brk;\n  if (js->lwm > n) js->lwm = n;\n  if ((char *) js->cstk > (char *) &n)\n    css = (jsoff_t) ((char *) js->cstk - (char *) &n);\n  if (css > js->css) js->css = css;\n}\n\n// Copy src to dst, make no overflows, 0-terminate. Return bytes copied\nstatic size_t cpy(char *dst, size_t dstlen, const char *src, size_t srclen) {\n  size_t i = 0;\n  for (i = 0; i < dstlen && i < srclen && src[i] != 0; i++) dst[i] = src[i];\n  if (dstlen > 0) dst[i < dstlen ? i : dstlen - 1] = '\\0';\n  return i;\n}\n\n// Stringify JS object\nstatic size_t strobj(struct js *js, jsval_t obj, char *buf, size_t len) {\n  size_t n = cpy(buf, len, \"{\", 1);\n  jsoff_t next = loadoff(js, (jsoff_t) vdata(obj)) & ~3U;  // First prop offset\n  while (next < js->brk && next != 0) {                    // Iterate over props\n    jsoff_t koff = loadoff(js, next + (jsoff_t) sizeof(next));\n    jsval_t val = loadval(js, next + (jsoff_t) (sizeof(next) + sizeof(koff)));\n    // printf(\"PROP %u, koff %u\\n\", next & ~3, koff);\n    n += cpy(buf + n, len - n, \",\", n == 1 ? 0 : 1);\n    n += tostr(js, mkval(T_STR, koff), buf + n, len - n);\n    n += cpy(buf + n, len - n, \":\", 1);\n    n += tostr(js, val, buf + n, len - n);\n    next = loadoff(js, next) & ~3U;  // Load next prop offset\n  }\n  return n + cpy(buf + n, len - n, \"}\", 1);\n}\n\n// Stringify numeric JS value\nstatic size_t strnum(jsval_t value, char *buf, size_t len) {\n  double dv = tod(value), iv;\n  const char *fmt = modf(dv, &iv) == 0.0 ? \"%.17g\" : \"%g\";\n  return (size_t) snprintf(buf, len, fmt, dv);\n}\n\n// Return mem offset and length of the JS string\nstatic jsoff_t vstr(struct js *js, jsval_t value, jsoff_t *len) {\n  jsoff_t off = (jsoff_t) vdata(value);\n  if (len) *len = offtolen(loadoff(js, off));\n  return (jsoff_t) (off + sizeof(off));\n}\n\n// Stringify string JS value\nstatic size_t strstring(struct js *js, jsval_t value, char *buf, size_t len) {\n  jsoff_t slen, off = vstr(js, value, &slen);\n  size_t n = 0;\n  n += cpy(buf + n, len - n, \"\\\"\", 1);\n  n += cpy(buf + n, len - n, (char *) &js->mem[off], slen);\n  n += cpy(buf + n, len - n, \"\\\"\", 1);\n  return n;\n}\n\n// Stringify JS function\nstatic size_t strfunc(struct js *js, jsval_t value, char *buf, size_t len) {\n  jsoff_t sn, off = vstr(js, value, &sn);\n  size_t n = cpy(buf, len, \"function\", 8);\n  return n + cpy(buf + n, len - n, (char *) &js->mem[off], sn);\n}\n\njsval_t js_mkerr(struct js *js, const char *xx, ...) {\n  va_list ap;\n  size_t n = cpy(js->errmsg, sizeof(js->errmsg), \"ERROR: \", 7);\n  va_start(ap, xx);\n  vsnprintf(js->errmsg + n, sizeof(js->errmsg) - n, xx, ap);\n  va_end(ap);\n  js->errmsg[sizeof(js->errmsg) - 1] = '\\0';\n  js->pos = js->clen, js->tok = TOK_EOF, js->consumed = 0;  // Jump to the end\n  return mkval(T_ERR, 0);\n}\n\n// Stringify JS value into the given buffer\nstatic size_t tostr(struct js *js, jsval_t value, char *buf, size_t len) {\n  switch (vtype(value)) {  // clang-format off\n    case T_UNDEF: return cpy(buf, len, \"undefined\", 9);\n    case T_NULL:  return cpy(buf, len, \"null\", 4);\n    case T_BOOL:  return cpy(buf, len, vdata(value) & 1 ? \"true\" : \"false\", vdata(value) & 1 ? 4 : 5);\n    case T_OBJ:   return strobj(js, value, buf, len);\n    case T_STR:   return strstring(js, value, buf, len);\n    case T_NUM:   return strnum(value, buf, len);\n    case T_FUNC:  return strfunc(js, value, buf, len);\n    case T_CFUNC: return (size_t) snprintf(buf, len, \"\\\"c_func_0x%lx\\\"\", (unsigned long) vdata(value));\n    case T_PROP:  return (size_t) snprintf(buf, len, \"PROP@%lu\", (unsigned long) vdata(value));\n    default:      return (size_t) snprintf(buf, len, \"VTYPE%d\", vtype(value));\n  }  // clang-format on\n}\n\n// Stringify JS value into a free JS memory block\nconst char *js_str(struct js *js, jsval_t value) {\n  // Leave jsoff_t placeholder between js->brk and a stringify buffer,\n  // in case if next step is convert it into a JS variable\n  char *buf = (char *) &js->mem[js->brk + sizeof(jsoff_t)];\n  size_t len, available = js->size - js->brk - sizeof(jsoff_t);\n  if (is_err(value)) return js->errmsg;\n  if (js->brk + sizeof(jsoff_t) >= js->size) return \"\";\n  len = tostr(js, value, buf, available);\n  js_mkstr(js, NULL, len);\n  return buf;\n}\n\nbool js_truthy(struct js *js, jsval_t v) {\n  uint8_t t = vtype(v);\n  return (t == T_BOOL && vdata(v) != 0) || (t == T_NUM && tod(v) != 0.0) ||\n         (t == T_OBJ || t == T_FUNC) || (t == T_STR && vstrlen(js, v) > 0);\n}\n\nstatic jsoff_t js_alloc(struct js *js, size_t size) {\n  jsoff_t ofs = js->brk;\n  size = align32((jsoff_t) size);  // 4-byte align, (n + k - 1) / k * k\n  if (js->brk + size > js->size) return ~(jsoff_t) 0;\n  js->brk += (jsoff_t) size;\n  return ofs;\n}\n\nstatic jsval_t mkentity(struct js *js, jsoff_t b, const void *buf, size_t len) {\n  jsoff_t ofs = js_alloc(js, len + sizeof(b));\n  if (ofs == (jsoff_t) ~0) return js_mkerr(js, \"oom\");\n  memcpy(&js->mem[ofs], &b, sizeof(b));\n  // Using memmove - in case we're stringifying data from the free JS mem\n  if (buf != NULL) memmove(&js->mem[ofs + sizeof(b)], buf, len);\n  if ((b & 3) == T_STR) js->mem[ofs + sizeof(b) + len - 1] = 0;  // 0-terminate\n  // printf(\"MKE: %u @ %u type %d\\n\", js->brk - ofs, ofs, b & 3);\n  return mkval(b & 3, ofs);\n}\n\njsval_t js_mkstr(struct js *js, const void *ptr, size_t len) {\n  jsoff_t n = (jsoff_t) (len + 1);\n  // printf(\"MKSTR %u %u\\n\", n, js->brk);\n  return mkentity(js, (jsoff_t) ((n << 2) | T_STR), ptr, n);\n}\n\nstatic jsval_t mkobj(struct js *js, jsoff_t parent) {\n  return mkentity(js, 0 | T_OBJ, &parent, sizeof(parent));\n}\n\nstatic jsval_t setprop(struct js *js, jsval_t obj, jsval_t k, jsval_t v) {\n  jsoff_t koff = (jsoff_t) vdata(k);          // Key offset\n  jsoff_t b, head = (jsoff_t) vdata(obj);     // Property list head\n  char buf[sizeof(koff) + sizeof(v)];         // Property memory layout\n  memcpy(&b, &js->mem[head], sizeof(b));      // Load current 1st prop offset\n  memcpy(buf, &koff, sizeof(koff));           // Initialize prop data: copy key\n  memcpy(buf + sizeof(koff), &v, sizeof(v));  // Copy value\n  jsoff_t brk = js->brk | T_OBJ;              // New prop offset\n  memcpy(&js->mem[head], &brk, sizeof(brk));  // Repoint head to the new prop\n  // printf(\"PROP: %u -> %u\\n\", b, brk);\n  return mkentity(js, (b & ~3U) | T_PROP, buf, sizeof(buf));  // Create new prop\n}\n\n// Return T_OBJ/T_PROP/T_STR entity size based on the first word in memory\nstatic inline jsoff_t esize(jsoff_t w) {\n  switch (w & 3U) {  // clang-format off\n    case T_OBJ:   return (jsoff_t) (sizeof(jsoff_t) + sizeof(jsoff_t));\n    case T_PROP:  return (jsoff_t) (sizeof(jsoff_t) + sizeof(jsoff_t) + sizeof(jsval_t));\n    case T_STR:   return (jsoff_t) (sizeof(jsoff_t) + align32(w >> 2U));\n    default:      return (jsoff_t) ~0U;\n  }  // clang-format on\n}\n\nstatic bool is_mem_entity(uint8_t t) {\n  return t == T_OBJ || t == T_PROP || t == T_STR || t == T_FUNC;\n}\n\n#define GCMASK ~(((jsoff_t) ~0) >> 1)  // Entity deletion marker\nstatic void js_fixup_offsets(struct js *js, jsoff_t start, jsoff_t size) {\n  for (jsoff_t n, v, off = 0; off < js->brk; off += n) {  // start from 0!\n    v = loadoff(js, off);\n    n = esize(v & ~GCMASK);\n    if (v & GCMASK) continue;  // To be deleted, don't bother\n    if ((v & 3) != T_OBJ && (v & 3) != T_PROP) continue;\n    if (v > start) saveoff(js, off, v - size);\n    if ((v & 3) == T_OBJ) {\n      jsoff_t u = loadoff(js, (jsoff_t) (off + sizeof(jsoff_t)));\n      if (u > start) saveoff(js, (jsoff_t) (off + sizeof(jsoff_t)), u - size);\n    }\n    if ((v & 3) == T_PROP) {\n      jsoff_t koff = loadoff(js, (jsoff_t) (off + sizeof(off)));\n      if (koff > start) saveoff(js, (jsoff_t) (off + sizeof(off)), koff - size);\n      jsval_t val = loadval(js, (jsoff_t) (off + sizeof(off) + sizeof(off)));\n      if (is_mem_entity(vtype(val)) && vdata(val) > start) {\n        saveval(js, (jsoff_t) (off + sizeof(off) + sizeof(off)),\n                mkval(vtype(val), (unsigned long) (vdata(val) - size)));\n      }\n    }\n  }\n  // Fixup js->scope\n  jsoff_t off = (jsoff_t) vdata(js->scope);\n  if (off > start) js->scope = mkval(T_OBJ, off - size);\n  if (js->nogc >= start) js->nogc -= size;\n  // Fixup code that we're executing now, if required\n  if (js->code > (char *) js->mem && js->code - (char *) js->mem < js->size &&\n      js->code - (char *) js->mem > start) {\n    js->code -= size;\n    // printf(\"GC-ing code under us!! %ld\\n\", js->code - (char *) js->mem);\n  }\n  // printf(\"FIXEDOFF %u %u\\n\", start, size);\n}\n\nstatic void js_delete_marked_entities(struct js *js) {\n  for (jsoff_t n, v, off = 0; off < js->brk; off += n) {\n    v = loadoff(js, off);\n    n = esize(v & ~GCMASK);\n    if (v & GCMASK) {  // This entity is marked for deletion, remove it\n      // printf(\"DEL: %4u %d %x\\n\", off, v & 3, n);\n      // assert(off + n <= js->brk);\n      js_fixup_offsets(js, off, n);\n      memmove(&js->mem[off], &js->mem[off + n], js->brk - off - n);\n      js->brk -= n;  // Shrink brk boundary by the size of deleted entity\n      n = 0;         // We shifted data, next iteration stay on this offset\n    }\n  }\n}\n\nstatic void js_mark_all_entities_for_deletion(struct js *js) {\n  for (jsoff_t v, off = 0; off < js->brk; off += esize(v)) {\n    v = loadoff(js, off);\n    saveoff(js, off, v | GCMASK);\n  }\n}\n\nstatic jsoff_t js_unmark_entity(struct js *js, jsoff_t off) {\n  jsoff_t v = loadoff(js, off);\n  if (v & GCMASK) {\n    saveoff(js, off, v & ~GCMASK);\n    // printf(\"UNMARK %5u %d\\n\", off, v & 3);\n    if ((v & 3) == T_OBJ) js_unmark_entity(js, v & ~(GCMASK | 3));\n    if ((v & 3) == T_PROP) {\n      js_unmark_entity(js, v & ~(GCMASK | 3));  // Unmark next prop\n      js_unmark_entity(js, loadoff(js, (jsoff_t) (off + sizeof(off))));  // key\n      jsval_t val = loadval(js, (jsoff_t) (off + sizeof(off) + sizeof(off)));\n      if (is_mem_entity(vtype(val))) js_unmark_entity(js, (jsoff_t) vdata(val));\n    }\n  }\n  return v & ~(GCMASK | 3U);\n}\n\nstatic void js_unmark_used_entities(struct js *js) {\n  jsval_t scope = js->scope;\n  do {\n    js_unmark_entity(js, (jsoff_t) vdata(scope));\n    scope = upper(js, scope);\n  } while (vdata(scope) != 0);  // When global scope is GC-ed, stop\n  if (js->nogc) js_unmark_entity(js, js->nogc);\n  // printf(\"UNMARK: nogc %u\\n\", js->nogc);\n  // js_dump(js);\n}\n\nvoid js_gc(struct js *js) {\n  // printf(\"================== GC %u\\n\", js->nogc);\n  setlwm(js);\n  if (js->nogc == (jsoff_t) ~0) return;  // ~0 is a special case: GC Is disabled\n  js_mark_all_entities_for_deletion(js);\n  js_unmark_used_entities(js);\n  js_delete_marked_entities(js);\n}\n\n// Skip whitespaces and comments\nstatic jsoff_t skiptonext(const char *code, jsoff_t len, jsoff_t n) {\n  // printf(\"SKIP: [%.*s]\\n\", len - n, &code[n]);\n  while (n < len) {\n    if (is_space(code[n])) {\n      n++;\n    } else if (n + 1 < len && code[n] == '/' && code[n + 1] == '/') {\n      for (n += 2; n < len && code[n] != '\\n';) n++;\n    } else if (n + 3 < len && code[n] == '/' && code[n + 1] == '*') {\n      for (n += 4; n < len && (code[n - 2] != '*' || code[n - 1] != '/');) n++;\n    } else {\n      break;\n    }\n  }\n  return n;\n}\n\nstatic bool streq(const char *buf, size_t len, const char *p, size_t n) {\n  return n == len && memcmp(buf, p, len) == 0;\n}\n\nstatic uint8_t parsekeyword(const char *buf, size_t len) {\n  switch (buf[0]) {  // clang-format off\n    case 'b': if (streq(\"break\", 5, buf, len)) return TOK_BREAK; break;\n    case 'c': if (streq(\"class\", 5, buf, len)) return TOK_CLASS; if (streq(\"case\", 4, buf, len)) return TOK_CASE; if (streq(\"catch\", 5, buf, len)) return TOK_CATCH; if (streq(\"const\", 5, buf, len)) return TOK_CONST; if (streq(\"continue\", 8, buf, len)) return TOK_CONTINUE; break;\n    case 'd': if (streq(\"do\", 2, buf, len)) return TOK_DO;  if (streq(\"default\", 7, buf, len)) return TOK_DEFAULT; break; // if (streq(\"delete\", 6, buf, len)) return TOK_DELETE; break;\n    case 'e': if (streq(\"else\", 4, buf, len)) return TOK_ELSE; break;\n    case 'f': if (streq(\"for\", 3, buf, len)) return TOK_FOR; if (streq(\"function\", 8, buf, len)) return TOK_FUNC; if (streq(\"finally\", 7, buf, len)) return TOK_FINALLY; if (streq(\"false\", 5, buf, len)) return TOK_FALSE; break;\n    case 'i': if (streq(\"if\", 2, buf, len)) return TOK_IF; if (streq(\"in\", 2, buf, len)) return TOK_IN; if (streq(\"instanceof\", 10, buf, len)) return TOK_INSTANCEOF; break;\n    case 'l': if (streq(\"let\", 3, buf, len)) return TOK_LET; break;\n    case 'n': if (streq(\"new\", 3, buf, len)) return TOK_NEW; if (streq(\"null\", 4, buf, len)) return TOK_NULL; break;\n    case 'r': if (streq(\"return\", 6, buf, len)) return TOK_RETURN; break;\n    case 's': if (streq(\"switch\", 6, buf, len)) return TOK_SWITCH; break;\n    case 't': if (streq(\"try\", 3, buf, len)) return TOK_TRY; if (streq(\"this\", 4, buf, len)) return TOK_THIS; if (streq(\"throw\", 5, buf, len)) return TOK_THROW; if (streq(\"true\", 4, buf, len)) return TOK_TRUE; if (streq(\"typeof\", 6, buf, len)) return TOK_TYPEOF; break;\n    case 'u': if (streq(\"undefined\", 9, buf, len)) return TOK_UNDEF; break;\n    case 'v': if (streq(\"var\", 3, buf, len)) return TOK_VAR; if (streq(\"void\", 4, buf, len)) return TOK_VOID; break;\n    case 'w': if (streq(\"while\", 5, buf, len)) return TOK_WHILE; if (streq(\"with\", 4, buf, len)) return TOK_WITH; break;\n    case 'y': if (streq(\"yield\", 5, buf, len)) return TOK_YIELD; break;\n  }  // clang-format on\n  return TOK_IDENTIFIER;\n}\n\nstatic uint8_t parseident(const char *buf, jsoff_t len, jsoff_t *tlen) {\n  if (is_ident_begin(buf[0])) {\n    while (*tlen < len && is_ident_continue(buf[*tlen])) (*tlen)++;\n    return parsekeyword(buf, *tlen);\n  }\n  return TOK_ERR;\n}\n\nstatic uint8_t next(struct js *js) {\n  if (js->consumed == 0) return js->tok;\n  js->consumed = 0;\n  js->tok = TOK_ERR;\n  js->toff = js->pos = skiptonext(js->code, js->clen, js->pos);\n  js->tlen = 0;\n  const char *buf = js->code + js->toff;\n  // clang-format off\n  if (js->toff >= js->clen) { js->tok = TOK_EOF; return js->tok; }\n#define TOK(T, LEN) { js->tok = T; js->tlen = (LEN); break; }\n#define LOOK(OFS, CH) js->toff + OFS < js->clen && buf[OFS] == CH\n  switch (buf[0]) {\n    case '?': TOK(TOK_Q, 1);\n    case ':': TOK(TOK_COLON, 1);\n    case '(': TOK(TOK_LPAREN, 1);\n    case ')': TOK(TOK_RPAREN, 1);\n    case '{': TOK(TOK_LBRACE, 1);\n    case '}': TOK(TOK_RBRACE, 1);\n    case ';': TOK(TOK_SEMICOLON, 1);\n    case ',': TOK(TOK_COMMA, 1);\n    case '!': if (LOOK(1, '=') && LOOK(2, '=')) TOK(TOK_NE, 3); TOK(TOK_NOT, 1);\n    case '.': TOK(TOK_DOT, 1);\n    case '~': TOK(TOK_TILDA, 1);\n    case '-': if (LOOK(1, '-')) TOK(TOK_POSTDEC, 2); if (LOOK(1, '=')) TOK(TOK_MINUS_ASSIGN, 2); TOK(TOK_MINUS, 1);\n    case '+': if (LOOK(1, '+')) TOK(TOK_POSTINC, 2); if (LOOK(1, '=')) TOK(TOK_PLUS_ASSIGN, 2); TOK(TOK_PLUS, 1);\n    case '*': if (LOOK(1, '*')) TOK(TOK_EXP, 2); if (LOOK(1, '=')) TOK(TOK_MUL_ASSIGN, 2); TOK(TOK_MUL, 1);\n    case '/': if (LOOK(1, '=')) TOK(TOK_DIV_ASSIGN, 2); TOK(TOK_DIV, 1);\n    case '%': if (LOOK(1, '=')) TOK(TOK_REM_ASSIGN, 2); TOK(TOK_REM, 1);\n    case '&': if (LOOK(1, '&')) TOK(TOK_LAND, 2); if (LOOK(1, '=')) TOK(TOK_AND_ASSIGN, 2); TOK(TOK_AND, 1);\n    case '|': if (LOOK(1, '|')) TOK(TOK_LOR, 2); if (LOOK(1, '=')) TOK(TOK_OR_ASSIGN, 2); TOK(TOK_OR, 1);\n    case '=': if (LOOK(1, '=') && LOOK(2, '=')) TOK(TOK_EQ, 3); TOK(TOK_ASSIGN, 1);\n    case '<': if (LOOK(1, '<') && LOOK(2, '=')) TOK(TOK_SHL_ASSIGN, 3); if (LOOK(1, '<')) TOK(TOK_SHL, 2); if (LOOK(1, '=')) TOK(TOK_LE, 2); TOK(TOK_LT, 1);\n    case '>': if (LOOK(1, '>') && LOOK(2, '=')) TOK(TOK_SHR_ASSIGN, 3); if (LOOK(1, '>')) TOK(TOK_SHR, 2); if (LOOK(1, '=')) TOK(TOK_GE, 2); TOK(TOK_GT, 1);\n    case '^': if (LOOK(1, '=')) TOK(TOK_XOR_ASSIGN, 2); TOK(TOK_XOR, 1);\n    case '\"': case '\\'':\n      js->tlen++;\n      while (js->toff + js->tlen < js->clen && buf[js->tlen] != buf[0]) {\n        uint8_t increment = 1;\n        if (buf[js->tlen] == '\\\\') {\n          if (js->toff + js->tlen + 2 > js->clen) break;\n          increment = 2;\n          if (buf[js->tlen + 1] == 'x') {\n            if (js->toff + js->tlen + 4 > js->clen) break;\n            increment = 4;\n          }\n        }\n        js->tlen += increment;\n      }\n      if (buf[0] == buf[js->tlen]) js->tok = TOK_STRING, js->tlen++;\n      break;\n    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': {\n      char *end;\n      js->tval = tov(strtod(buf, &end)); // TODO(lsm): protect against OOB access\n      TOK(TOK_NUMBER, (jsoff_t) (end - buf));\n    }\n    default: js->tok = parseident(buf, js->clen - js->toff, &js->tlen); break;\n  }  // clang-format on\n  js->pos = js->toff + js->tlen;\n  // printf(\"NEXT: %d %d [%.*s]\\n\", js->tok, js->pos, (int) js->tlen, buf);\n  return js->tok;\n}\n\nstatic inline uint8_t lookahead(struct js *js) {\n  uint8_t old = js->tok, tok = 0;\n  jsoff_t pos = js->pos;\n  js->consumed = 1;\n  tok = next(js);\n  js->pos = pos, js->tok = old;\n  return tok;\n}\n\nstatic void mkscope(struct js *js) {\n  assert((js->flags & F_NOEXEC) == 0);\n  jsoff_t prev = (jsoff_t) vdata(js->scope);\n  js->scope = mkobj(js, prev);\n  // printf(\"ENTER SCOPE %u, prev %u\\n\", (jsoff_t) vdata(js->scope), prev);\n}\n\nstatic void delscope(struct js *js) {\n  js->scope = upper(js, js->scope);\n  // printf(\"EXIT  SCOPE %u\\n\", (jsoff_t) vdata(js->scope));\n}\n\nstatic jsval_t js_block(struct js *js, bool create_scope) {\n  jsval_t res = js_mkundef();\n  if (create_scope) mkscope(js);  // Enter new scope\n  js->consumed = 1;\n  // jsoff_t pos = js->pos;\n  while (next(js) != TOK_EOF && next(js) != TOK_RBRACE && !is_err(res)) {\n    uint8_t t = js->tok;\n    res = js_stmt(js);\n    if (!is_err(res) && t != TOK_LBRACE && t != TOK_IF && t != TOK_WHILE &&\n        js->tok != TOK_SEMICOLON) {\n      res = js_mkerr(js, \"; expected\");\n      break;\n    }\n  }\n  // printf(\"BLOCKEND %s\\n\", js_str(js, res));\n  if (create_scope) delscope(js);  // Exit scope\n  return res;\n}\n\n// Seach for property in a single object\nstatic jsoff_t lkp(struct js *js, jsval_t obj, const char *buf, size_t len) {\n  jsoff_t off = loadoff(js, (jsoff_t) vdata(obj)) & ~3U;  // Load first prop off\n  // printf(\"LKP: %lu %u [%.*s]\\n\", vdata(obj), off, (int) len, buf);\n  while (off < js->brk && off != 0) {  // Iterate over props\n    jsoff_t koff = loadoff(js, (jsoff_t) (off + sizeof(off)));\n    jsoff_t klen = (loadoff(js, koff) >> 2) - 1;\n    const char *p = (char *) &js->mem[koff + sizeof(koff)];\n    // printf(\"  %u %u[%.*s]\\n\", off, (int) klen, (int) klen, p);\n    if (streq(buf, len, p, klen)) return off;  // Found !\n    off = loadoff(js, off) & ~3U;              // Load next prop offset\n  }\n  return 0;  // Not found\n}\n\n// Lookup variable in the scope chain\nstatic jsval_t lookup(struct js *js, const char *buf, size_t len) {\n  if (js->flags & F_NOEXEC) return 0;\n  for (jsval_t scope = js->scope;;) {\n    jsoff_t off = lkp(js, scope, buf, len);\n    if (off != 0) return mkval(T_PROP, off);\n    if (vdata(scope) == 0) break;\n    scope =\n        mkval(T_OBJ, loadoff(js, (jsoff_t) (vdata(scope) + sizeof(jsoff_t))));\n  }\n  return js_mkerr(js, \"'%.*s' not found\", (int) len, buf);\n}\n\nstatic jsval_t resolveprop(struct js *js, jsval_t v) {\n  if (vtype(v) != T_PROP) return v;\n  return resolveprop(js,\n                     loadval(js, (jsoff_t) (vdata(v) + sizeof(jsoff_t) * 2)));\n}\n\nstatic jsval_t assign(struct js *js, jsval_t lhs, jsval_t val) {\n  saveval(js, (jsoff_t) ((vdata(lhs) & ~3U) + sizeof(jsoff_t) * 2), val);\n  return lhs;\n}\n\nstatic jsval_t do_assign_op(struct js *js, uint8_t op, jsval_t l, jsval_t r) {\n  uint8_t m[] = {TOK_PLUS, TOK_MINUS, TOK_MUL, TOK_DIV, TOK_REM, TOK_SHL,\n                 TOK_SHR,  TOK_ZSHR,  TOK_AND, TOK_XOR, TOK_OR};\n  jsval_t res = do_op(js, m[op - TOK_PLUS_ASSIGN], resolveprop(js, l), r);\n  return assign(js, l, res);\n}\n\nstatic jsval_t do_string_op(struct js *js, uint8_t op, jsval_t l, jsval_t r) {\n  jsoff_t n1, off1 = vstr(js, l, &n1);\n  jsoff_t n2, off2 = vstr(js, r, &n2);\n  if (op == TOK_PLUS) {\n    jsval_t res = js_mkstr(js, NULL, n1 + n2);\n    // printf(\"STRPLUS %u %u %u %u [%.*s] [%.*s]\\n\", n1, off1, n2, off2, (int)\n    // n1,\n    //       &js->mem[off1], (int) n2, &js->mem[off2]);\n    if (vtype(res) == T_STR) {\n      jsoff_t n, off = vstr(js, res, &n);\n      memmove(&js->mem[off], &js->mem[off1], n1);\n      memmove(&js->mem[off + n1], &js->mem[off2], n2);\n    }\n    return res;\n  } else if (op == TOK_EQ) {\n    bool eq = n1 == n2 && memcmp(&js->mem[off1], &js->mem[off2], n1) == 0;\n    return mkval(T_BOOL, eq ? 1 : 0);\n  } else if (op == TOK_NE) {\n    bool eq = n1 == n2 && memcmp(&js->mem[off1], &js->mem[off2], n1) == 0;\n    return mkval(T_BOOL, eq ? 0 : 1);\n  } else {\n    return js_mkerr(js, \"bad str op\");\n  }\n}\n\nstatic jsval_t do_dot_op(struct js *js, jsval_t l, jsval_t r) {\n  const char *ptr = (char *) &js->code[coderefoff(r)];\n  if (vtype(r) != T_CODEREF) return js_mkerr(js, \"ident expected\");\n  // Handle stringvalue.length\n  if (vtype(l) == T_STR && streq(ptr, codereflen(r), \"length\", 6)) {\n    return tov(offtolen(loadoff(js, (jsoff_t) vdata(l))));\n  }\n  if (vtype(l) != T_OBJ) return js_mkerr(js, \"lookup in non-obj\");\n  jsoff_t off = lkp(js, l, ptr, codereflen(r));\n  return off == 0 ? js_mkundef() : mkval(T_PROP, off);\n}\n\nstatic jsval_t js_call_params(struct js *js) {\n  jsoff_t pos = js->pos;\n  uint8_t flags = js->flags;\n  js->flags |= F_NOEXEC;\n  js->consumed = 1;\n  for (bool comma = false; next(js) != TOK_EOF; comma = true) {\n    if (!comma && next(js) == TOK_RPAREN) break;\n    js_expr(js);\n    if (next(js) == TOK_RPAREN) break;\n    EXPECT(TOK_COMMA, js->flags = flags);\n  }\n  EXPECT(TOK_RPAREN, js->flags = flags);\n  js->flags = flags;\n  return mkcoderef(pos, js->pos - pos - js->tlen);\n}\n\nstatic void reverse(jsval_t *args, int nargs) {\n  for (int i = 0; i < nargs / 2; i++) {\n    jsval_t tmp = args[i];\n    args[i] = args[nargs - i - 1], args[nargs - i - 1] = tmp;\n  }\n}\n\n// Call native C function\nstatic jsval_t call_c(struct js *js,\n                      jsval_t (*fn)(struct js *, jsval_t *, int)) {\n  int argc = 0;\n  while (js->pos < js->clen) {\n    if (next(js) == TOK_RPAREN) break;\n    jsval_t arg = resolveprop(js, js_expr(js));\n    if (js->brk + sizeof(arg) > js->size) return js_mkerr(js, \"call oom\");\n    js->size -= (jsoff_t) sizeof(arg);\n    memcpy(&js->mem[js->size], &arg, sizeof(arg));\n    argc++;\n    // printf(\"  arg %d -> %s\\n\", argc, js_str(js, arg));\n    if (next(js) == TOK_COMMA) js->consumed = 1;\n  }\n  reverse((jsval_t *) &js->mem[js->size], argc);\n  jsval_t res = fn(js, (jsval_t *) &js->mem[js->size], argc);\n  setlwm(js);\n  js->size += (jsoff_t) sizeof(jsval_t) * (jsoff_t) argc;  // Restore stack\n  return res;\n}\n\n// Call JS function. 'fn' looks like this: \"(a,b) { return a + b; }\"\nstatic jsval_t call_js(struct js *js, const char *fn, jsoff_t fnlen) {\n  jsoff_t fnpos = 1;\n  // printf(\"JSCALL [%.*s] -> %.*s\\n\", (int) js->clen, js->code, (int) fnlen,\n  // fn);\n  // printf(\"JSCALL, nogc %u [%.*s]\\n\", js->nogc, (int) fnlen, fn);\n  mkscope(js);  // Create function call scope\n  // Loop over arguments list \"(a, b)\" and set scope variables\n  while (fnpos < fnlen) {\n    fnpos = skiptonext(fn, fnlen, fnpos);          // Skip to the identifier\n    if (fnpos < fnlen && fn[fnpos] == ')') break;  // Closing paren? break!\n    jsoff_t identlen = 0;                          // Identifier length\n    uint8_t tok = parseident(&fn[fnpos], fnlen - fnpos, &identlen);\n    if (tok != TOK_IDENTIFIER) break;\n    // Here we have argument name. Calculate arg value\n    // printf(\"  [%.*s] -> %u [%.*s] -> \", (int) identlen, &fn[fnpos], js->pos,\n    //       (int) js->clen, js->code);\n    js->pos = skiptonext(js->code, js->clen, js->pos);\n    js->consumed = 1;\n    jsval_t v = js->code[js->pos] == ')' ? js_mkundef() : js_expr(js);\n    // Set argument in the function scope\n    setprop(js, js->scope, js_mkstr(js, &fn[fnpos], identlen), v);\n    js->pos = skiptonext(js->code, js->clen, js->pos);\n    if (js->pos < js->clen && js->code[js->pos] == ',') js->pos++;\n    fnpos = skiptonext(fn, fnlen, fnpos + identlen);  // Skip past identifier\n    if (fnpos < fnlen && fn[fnpos] == ',') fnpos++;   // And skip comma\n  }\n  if (fnpos < fnlen && fn[fnpos] == ')') fnpos++;  // Skip to the function body\n  fnpos = skiptonext(fn, fnlen, fnpos);            // Up to the opening brace\n  if (fnpos < fnlen && fn[fnpos] == '{') fnpos++;  // And skip the brace\n  size_t n = fnlen - fnpos - 1U;  // Function code with stripped braces\n  // printf(\"flags: %d, body: %zu [%.*s]\\n\", js->flags, n, (int) n, &fn[fnpos]);\n  js->flags = F_CALL;                        // Mark we're in the function call\n  jsval_t res = js_eval(js, &fn[fnpos], n);  // Call function, no GC\n  if (!is_err(res) && !(js->flags & F_RETURN)) res = js_mkundef();  // No return\n  delscope(js);  // Delete call scope\n  // printf(\"  -> %d [%s], tok %d\\n\", js->flags, js_str(js, res), js->tok);\n  return res;\n}\n\nstatic jsval_t do_call_op(struct js *js, jsval_t func, jsval_t args) {\n  if (vtype(args) != T_CODEREF) return js_mkerr(js, \"bad call\");\n  if (vtype(func) != T_FUNC && vtype(func) != T_CFUNC)\n    return js_mkerr(js, \"calling non-function\");\n  const char *code = js->code;             // Save current parser state\n  jsoff_t clen = js->clen, pos = js->pos;  // code, position and code length\n  js->code = &js->code[coderefoff(args)];  // Point parser to args\n  js->clen = codereflen(args);             // Set args length\n  js->pos = skiptonext(js->code, js->clen, 0);  // Skip to 1st arg\n  uint8_t tok = js->tok, flags = js->flags;     // Save flags\n  jsoff_t nogc = js->nogc;\n  jsval_t res = js_mkundef();\n  if (vtype(func) == T_FUNC) {\n    jsoff_t fnlen, fnoff = vstr(js, func, &fnlen);\n    js->nogc = (jsoff_t) (fnoff - sizeof(jsoff_t));\n    res = call_js(js, (const char *) (&js->mem[fnoff]), fnlen);\n  } else {\n    res = call_c(js, (jsval_t(*)(struct js *, jsval_t *, int)) vdata(func));\n  }\n  js->code = code, js->clen = clen, js->pos = pos;  // Restore parser\n  js->flags = flags, js->tok = tok, js->nogc = nogc;\n  js->consumed = 1;\n  return res;\n}\n\n// clang-format off\nstatic jsval_t do_op(struct js *js, uint8_t op, jsval_t lhs, jsval_t rhs) {\n  if (js->flags & F_NOEXEC) return 0;\n  jsval_t l = resolveprop(js, lhs), r = resolveprop(js, rhs);\n  // printf(\"OP %d %d %d\\n\", op, vtype(lhs), vtype(r));\n  setlwm(js);\n  if (is_err(l)) return l;\n  if (is_err(r)) return r;\n  if (is_assign(op) && vtype(lhs) != T_PROP) return js_mkerr(js, \"bad lhs\");\n  switch (op) {\n    case TOK_TYPEOF:  return js_mkstr(js, typestr(vtype(r)), strlen(typestr(vtype(r))));\n    case TOK_CALL:    return do_call_op(js, l, r);\n    case TOK_ASSIGN:  return assign(js, lhs, r);\n    case TOK_POSTINC: { do_assign_op(js, TOK_PLUS_ASSIGN, lhs, tov(1)); return l; }\n    case TOK_POSTDEC: { do_assign_op(js, TOK_MINUS_ASSIGN, lhs, tov(1)); return l; }\n    case TOK_NOT:     if (vtype(r) == T_BOOL) return mkval(T_BOOL, !vdata(r)); break;\n  }\n  if (is_assign(op))    return do_assign_op(js, op, lhs, r);\n  if (vtype(l) == T_STR && vtype(r) == T_STR) return do_string_op(js, op, l, r);\n  if (is_unary(op) && vtype(r) != T_NUM) return js_mkerr(js, \"type mismatch\");\n  if (!is_unary(op) && op != TOK_DOT && (vtype(l) != T_NUM || vtype(r) != T_NUM)) return js_mkerr(js, \"type mismatch\");\n  double a = tod(l), b = tod(r);\n  switch (op) {\n    //case TOK_EXP:     return tov(pow(a, b));\n    case TOK_DIV:     return tod(r) == 0 ? js_mkerr(js, \"div by zero\") : tov(a / b);\n    case TOK_REM:     return tov(a - b * ((double) (long) (a / b)));\n    case TOK_MUL:     return tov(a * b);\n    case TOK_PLUS:    return tov(a + b);\n    case TOK_MINUS:   return tov(a - b);\n    case TOK_XOR:     return tov((double)((long) a ^ (long) b));\n    case TOK_AND:     return tov((double)((long) a & (long) b));\n    case TOK_OR:      return tov((double)((long) a | (long) b));\n    case TOK_UMINUS:  return tov(-b);\n    case TOK_UPLUS:   return r;\n    case TOK_TILDA:   return tov((double)(~(long) b));\n    case TOK_NOT:     return mkval(T_BOOL, b == 0);\n    case TOK_SHL:     return tov((double)((long) a << (long) b));\n    case TOK_SHR:     return tov((double)((long) a >> (long) b));\n    case TOK_DOT:     return do_dot_op(js, l, r);\n    case TOK_EQ:      return mkval(T_BOOL, (long) a == (long) b);\n    case TOK_NE:      return mkval(T_BOOL, (long) a != (long) b);\n    case TOK_LT:      return mkval(T_BOOL, a < b);\n    case TOK_LE:      return mkval(T_BOOL, a <= b);\n    case TOK_GT:      return mkval(T_BOOL, a > b);\n    case TOK_GE:      return mkval(T_BOOL, a >= b);\n    default:          return js_mkerr(js, \"unknown op %d\", (int) op);  // LCOV_EXCL_LINE\n  }\n}  // clang-format on\n\nstatic jsval_t js_str_literal(struct js *js) {\n  uint8_t *in = (uint8_t *) &js->code[js->toff];\n  uint8_t *out = &js->mem[js->brk + sizeof(jsoff_t)];\n  size_t n1 = 0, n2 = 0;\n  // printf(\"STR %u %lu %lu\\n\", js->brk, js->tlen, js->clen);\n  if (js->brk + sizeof(jsoff_t) + js->tlen > js->size)\n    return js_mkerr(js, \"oom\");\n  while (n2++ + 2 < js->tlen) {\n    if (in[n2] == '\\\\') {\n      if (in[n2 + 1] == in[0]) {\n        out[n1++] = in[0];\n      } else if (in[n2 + 1] == 'n') {\n        out[n1++] = '\\n';\n      } else if (in[n2 + 1] == 't') {\n        out[n1++] = '\\t';\n      } else if (in[n2 + 1] == 'r') {\n        out[n1++] = '\\r';\n      } else if (in[n2 + 1] == 'x' && is_xdigit(in[n2 + 2]) &&\n                 is_xdigit(in[n2 + 3])) {\n        out[n1++] = (uint8_t) ((unhex(in[n2 + 2]) << 4U) | unhex(in[n2 + 3]));\n        n2 += 2;\n      } else {\n        return js_mkerr(js, \"bad str literal\");\n      }\n      n2++;\n    } else {\n      out[n1++] = ((uint8_t *) js->code)[js->toff + n2];\n    }\n  }\n  return js_mkstr(js, NULL, n1);\n}\n\nstatic jsval_t js_obj_literal(struct js *js) {\n  uint8_t exe = !(js->flags & F_NOEXEC);\n  // printf(\"OLIT1\\n\");\n  jsval_t obj = exe ? mkobj(js, 0) : js_mkundef();\n  if (is_err(obj)) return obj;\n  js->consumed = 1;\n  while (next(js) != TOK_RBRACE) {\n    jsval_t key = 0;\n    if (js->tok == TOK_IDENTIFIER) {\n      if (exe) key = js_mkstr(js, js->code + js->toff, js->tlen);\n    } else if (js->tok == TOK_STRING) {\n      if (exe) key = js_str_literal(js);\n    } else {\n      return js_mkerr(js, \"parse error\");\n    }\n    js->consumed = 1;\n    EXPECT(TOK_COLON, );\n    jsval_t val = js_expr(js);\n    if (exe) {\n      // printf(\"XXXX [%s] scope: %lu\\n\", js_str(js, val), vdata(js->scope));\n      if (is_err(val)) return val;\n      if (is_err(key)) return key;\n      jsval_t res = setprop(js, obj, key, resolveprop(js, val));\n      if (is_err(res)) return res;\n    }\n    if (next(js) == TOK_RBRACE) break;\n    EXPECT(TOK_COMMA, );\n  }\n  EXPECT(TOK_RBRACE, );\n  return obj;\n}\n\nstatic jsval_t js_func_literal(struct js *js) {\n  uint8_t flags = js->flags;  // Save current flags\n  js->consumed = 1;\n  EXPECT(TOK_LPAREN, js->flags = flags);\n  jsoff_t pos = js->pos - 1;\n  for (bool comma = false; next(js) != TOK_EOF; comma = true) {\n    if (!comma && next(js) == TOK_RPAREN) break;\n    EXPECT(TOK_IDENTIFIER, js->flags = flags);\n    if (next(js) == TOK_RPAREN) break;\n    EXPECT(TOK_COMMA, js->flags = flags);\n  }\n  EXPECT(TOK_RPAREN, js->flags = flags);\n  EXPECT(TOK_LBRACE, js->flags = flags);\n  js->consumed = 0;\n  js->flags |= F_NOEXEC;              // Set no-execution flag to parse the\n  jsval_t res = js_block(js, false);  // Skip function body - no exec\n  if (is_err(res)) {                  // But fail short on parse error\n    js->flags = flags;\n    return res;\n  }\n  js->flags = flags;  // Restore flags\n  jsval_t str = js_mkstr(js, &js->code[pos], js->pos - pos);\n  js->consumed = 1;\n  // printf(\"FUNC: %u [%.*s]\\n\", pos, js->pos - pos, &js->code[pos]);\n  return mkval(T_FUNC, (unsigned long) vdata(str));\n}\n\n#define RTL_BINOP(_f1, _f2, _cond)  \\\n  jsval_t res = _f1(js);            \\\n  while (!is_err(res) && (_cond)) { \\\n    uint8_t op = js->tok;           \\\n    js->consumed = 1;               \\\n    jsval_t rhs = _f2(js);          \\\n    if (is_err(rhs)) return rhs;    \\\n    res = do_op(js, op, res, rhs);  \\\n  }                                 \\\n  return res;\n\n#define LTR_BINOP(_f, _cond)        \\\n  jsval_t res = _f(js);             \\\n  while (!is_err(res) && (_cond)) { \\\n    uint8_t op = js->tok;           \\\n    js->consumed = 1;               \\\n    jsval_t rhs = _f(js);           \\\n    if (is_err(rhs)) return rhs;    \\\n    res = do_op(js, op, res, rhs);  \\\n  }                                 \\\n  return res;\n\nstatic jsval_t js_literal(struct js *js) {\n  next(js);\n  setlwm(js);\n  // printf(\"css : %u\\n\", js->css);\n  if (js->maxcss > 0 && js->css > js->maxcss) return js_mkerr(js, \"C stack\");\n  js->consumed = 1;\n  switch (js->tok) {  // clang-format off\n    case TOK_ERR:         return js_mkerr(js, \"parse error\");\n    case TOK_NUMBER:      return js->tval;\n    case TOK_STRING:      return js_str_literal(js);\n    case TOK_LBRACE:      return js_obj_literal(js);\n    case TOK_FUNC:        return js_func_literal(js);\n    case TOK_NULL:        return js_mknull();\n    case TOK_UNDEF:       return js_mkundef();\n    case TOK_TRUE:        return js_mktrue();\n    case TOK_FALSE:       return js_mkfalse();\n    case TOK_IDENTIFIER:  return mkcoderef((jsoff_t) js->toff, (jsoff_t) js->tlen);\n    default:              return js_mkerr(js, \"bad expr\");\n  }  // clang-format on\n}\n\nstatic jsval_t js_group(struct js *js) {\n  if (next(js) == TOK_LPAREN) {\n    js->consumed = 1;\n    jsval_t v = js_expr(js);\n    if (is_err(v)) return v;\n    if (next(js) != TOK_RPAREN) return js_mkerr(js, \") expected\");\n    js->consumed = 1;\n    return v;\n  } else {\n    return js_literal(js);\n  }\n}\n\nstatic jsval_t js_call_dot(struct js *js) {\n  jsval_t res = js_group(js);\n  if (is_err(res)) return res;\n  if (vtype(res) == T_CODEREF) {\n    res = lookup(js, &js->code[coderefoff(res)], codereflen(res));\n  }\n  while (next(js) == TOK_LPAREN || next(js) == TOK_DOT) {\n    if (js->tok == TOK_DOT) {\n      js->consumed = 1;\n      res = do_op(js, TOK_DOT, res, js_group(js));\n    } else {\n      jsval_t params = js_call_params(js);\n      if (is_err(params)) return params;\n      res = do_op(js, TOK_CALL, res, params);\n    }\n  }\n  return res;\n}\n\nstatic jsval_t js_postfix(struct js *js) {\n  jsval_t res = js_call_dot(js);\n  if (is_err(res)) return res;\n  next(js);\n  if (js->tok == TOK_POSTINC || js->tok == TOK_POSTDEC) {\n    js->consumed = 1;\n    res = do_op(js, js->tok, res, 0);\n  }\n  return res;\n}\n\nstatic jsval_t js_unary(struct js *js) {\n  if (next(js) == TOK_NOT || js->tok == TOK_TILDA || js->tok == TOK_TYPEOF ||\n      js->tok == TOK_MINUS || js->tok == TOK_PLUS) {\n    uint8_t t = js->tok;\n    if (t == TOK_MINUS) t = TOK_UMINUS;\n    if (t == TOK_PLUS) t = TOK_UPLUS;\n    js->consumed = 1;\n    return do_op(js, t, js_mkundef(), js_unary(js));\n  } else {\n    return js_postfix(js);\n  }\n}\n\nstatic jsval_t js_mul_div_rem(struct js *js) {\n  LTR_BINOP(js_unary,\n            (next(js) == TOK_MUL || js->tok == TOK_DIV || js->tok == TOK_REM));\n}\n\nstatic jsval_t js_plus_minus(struct js *js) {\n  LTR_BINOP(js_mul_div_rem, (next(js) == TOK_PLUS || js->tok == TOK_MINUS));\n}\n\nstatic jsval_t js_shifts(struct js *js) {\n  LTR_BINOP(js_plus_minus, (next(js) == TOK_SHR || next(js) == TOK_SHL ||\n                            next(js) == TOK_ZSHR));\n}\n\nstatic jsval_t js_comparison(struct js *js) {\n  LTR_BINOP(js_shifts, (next(js) == TOK_LT || next(js) == TOK_LE ||\n                        next(js) == TOK_GT || next(js) == TOK_GE));\n}\n\nstatic jsval_t js_equality(struct js *js) {\n  LTR_BINOP(js_comparison, (next(js) == TOK_EQ || next(js) == TOK_NE));\n}\n\nstatic jsval_t js_bitwise_and(struct js *js) {\n  LTR_BINOP(js_equality, (next(js) == TOK_AND));\n}\n\nstatic jsval_t js_bitwise_xor(struct js *js) {\n  LTR_BINOP(js_bitwise_and, (next(js) == TOK_XOR));\n}\n\nstatic jsval_t js_bitwise_or(struct js *js) {\n  LTR_BINOP(js_bitwise_xor, (next(js) == TOK_OR));\n}\n\nstatic jsval_t js_logical_and(struct js *js) {\n  jsval_t res = js_bitwise_or(js);\n  if (is_err(res)) return res;\n  uint8_t flags = js->flags;\n  while (next(js) == TOK_LAND) {\n    js->consumed = 1;\n    res = resolveprop(js, res);\n    if (!js_truthy(js, res)) js->flags |= F_NOEXEC;  // false && ... shortcut\n    if (js->flags & F_NOEXEC) {\n      js_logical_and(js);\n    } else {\n      res = js_logical_and(js);\n    }\n  }\n  js->flags = flags;\n  return res;\n}\n\nstatic jsval_t js_logical_or(struct js *js) {\n  jsval_t res = js_logical_and(js);\n  if (is_err(res)) return res;\n  uint8_t flags = js->flags;\n  while (next(js) == TOK_LOR) {\n    js->consumed = 1;\n    res = resolveprop(js, res);\n    if (js_truthy(js, res)) js->flags |= F_NOEXEC;  // true || ... shortcut\n    if (js->flags & F_NOEXEC) {\n      js_logical_or(js);\n    } else {\n      res = js_logical_or(js);\n    }\n  }\n  js->flags = flags;\n  return res;\n}\n\nstatic jsval_t js_ternary(struct js *js) {\n  jsval_t res = js_logical_or(js);\n  if (next(js) == TOK_Q) {\n    uint8_t flags = js->flags;\n    js->consumed = 1;\n    if (js_truthy(js, resolveprop(js, res))) {\n      res = js_ternary(js);\n      js->flags |= F_NOEXEC;\n      EXPECT(TOK_COLON, js->flags = flags);\n      js_ternary(js);\n      js->flags = flags;\n    } else {\n      js->flags |= F_NOEXEC;\n      js_ternary(js);\n      EXPECT(TOK_COLON, js->flags = flags);\n      js->flags = flags;\n      res = js_ternary(js);\n    }\n  }\n  return res;\n}\n\nstatic jsval_t js_assignment(struct js *js) {\n  RTL_BINOP(js_ternary, js_assignment,\n            (next(js) == TOK_ASSIGN || js->tok == TOK_PLUS_ASSIGN ||\n             js->tok == TOK_MINUS_ASSIGN || js->tok == TOK_MUL_ASSIGN ||\n             js->tok == TOK_DIV_ASSIGN || js->tok == TOK_REM_ASSIGN ||\n             js->tok == TOK_SHL_ASSIGN || js->tok == TOK_SHR_ASSIGN ||\n             js->tok == TOK_ZSHR_ASSIGN || js->tok == TOK_AND_ASSIGN ||\n             js->tok == TOK_XOR_ASSIGN || js->tok == TOK_OR_ASSIGN));\n}\n\nstatic jsval_t js_expr(struct js *js) {\n  return js_assignment(js);\n}\n\nstatic jsval_t js_let(struct js *js) {\n  uint8_t exe = !(js->flags & F_NOEXEC);\n  js->consumed = 1;\n  for (;;) {\n    EXPECT(TOK_IDENTIFIER, );\n    js->consumed = 0;\n    jsoff_t noff = js->toff, nlen = js->tlen;\n    char *name = (char *) &js->code[noff];\n    jsval_t v = js_mkundef();\n    js->consumed = 1;\n    if (next(js) == TOK_ASSIGN) {\n      js->consumed = 1;\n      v = js_expr(js);\n      if (is_err(v)) return v;  // Propagate error if any\n    }\n    if (exe) {\n      if (lkp(js, js->scope, name, nlen) > 0)\n        return js_mkerr(js, \"'%.*s' already declared\", (int) nlen, name);\n      jsval_t x =\n          setprop(js, js->scope, js_mkstr(js, name, nlen), resolveprop(js, v));\n      if (is_err(x)) return x;\n    }\n    if (next(js) == TOK_SEMICOLON || next(js) == TOK_EOF) break;  // Stop\n    EXPECT(TOK_COMMA, );\n  }\n  return js_mkundef();\n}\n\nstatic jsval_t js_block_or_stmt(struct js *js) {\n  if (next(js) == TOK_LBRACE) return js_block(js, !(js->flags & F_NOEXEC));\n  jsval_t res = resolveprop(js, js_stmt(js));\n  js->consumed = 0;  //\n  return res;\n}\n\nstatic jsval_t js_if(struct js *js) {\n  js->consumed = 1;\n  EXPECT(TOK_LPAREN, );\n  jsval_t res = js_mkundef(), cond = resolveprop(js, js_expr(js));\n  EXPECT(TOK_RPAREN, );\n  bool cond_true = js_truthy(js, cond), exe = !(js->flags & F_NOEXEC);\n  // printf(\"IF COND: %s, true? %d\\n\", js_str(js, cond), cond_true);\n  if (!cond_true) js->flags |= F_NOEXEC;\n  jsval_t blk = js_block_or_stmt(js);\n  if (cond_true) res = blk;\n  if (exe && !cond_true) js->flags &= (uint8_t) ~F_NOEXEC;\n  if (lookahead(js) == TOK_ELSE) {\n    js->consumed = 1;\n    next(js);\n    js->consumed = 1;\n    if (cond_true) js->flags |= F_NOEXEC;\n    blk = js_block_or_stmt(js);\n    if (!cond_true) res = blk;\n    if (cond_true && exe) js->flags &= (uint8_t) ~F_NOEXEC;\n  }\n  return res;\n}\n\nstatic inline bool expect(struct js *js, uint8_t tok, jsval_t *res) {\n  if (next(js) != tok) {\n    *res = js_mkerr(js, \"parse error\");\n    return false;\n  } else {\n    js->consumed = 1;\n    return true;\n  }\n}\n\nstatic inline bool is_err2(jsval_t *v, jsval_t *res) {\n  bool r = is_err(*v);\n  if (r) *res = *v;\n  return r;\n}\n\nstatic jsval_t js_for(struct js *js) {\n  uint8_t flags = js->flags, exe = !(flags & F_NOEXEC);\n  jsval_t v, res = js_mkundef();\n  jsoff_t pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n  if (exe) mkscope(js);  // Enter new scope\n  if (!expect(js, TOK_FOR, &res)) goto done;\n  if (!expect(js, TOK_LPAREN, &res)) goto done;\n\n  if (next(js) == TOK_SEMICOLON) {  // initialisation\n  } else if (next(js) == TOK_LET) {\n    v = js_let(js);\n    if (is_err2(&v, &res)) goto done;\n  } else {\n    v = js_expr(js);\n    if (is_err2(&v, &res)) goto done;\n  }\n  if (!expect(js, TOK_SEMICOLON, &res)) goto done;\n  js->flags |= F_NOEXEC;\n  pos1 = js->pos;  // condition\n  if (next(js) != TOK_SEMICOLON) {\n    v = js_expr(js);\n    if (is_err2(&v, &res)) goto done;\n  }\n  if (!expect(js, TOK_SEMICOLON, &res)) goto done;\n  pos2 = js->pos;  // final expr\n  if (next(js) != TOK_RPAREN) {\n    v = js_expr(js);\n    if (is_err2(&v, &res)) goto done;\n  }\n  if (!expect(js, TOK_RPAREN, &res)) goto done;\n  pos3 = js->pos;  // body\n  v = js_block_or_stmt(js);\n  if (is_err2(&v, &res)) goto done;\n  pos4 = js->pos;  // end of body\n  while (!(flags & F_NOEXEC)) {\n    js->flags = flags, js->pos = pos1, js->consumed = 1;\n    if (next(js) != TOK_SEMICOLON) {     // Is condition specified?\n      v = resolveprop(js, js_expr(js));  // Yes. check condition\n      if (is_err2(&v, &res)) goto done;  // Fail short on error\n      if (!js_truthy(js, v)) break;      // Exit the loop if condition is false\n    }\n    js->pos = pos3, js->consumed = 1, js->flags |= F_LOOP;  // Execute the\n    v = js_block_or_stmt(js);                               // loop body\n    if (is_err2(&v, &res)) goto done;                       // Fail on error\n    if (js->flags & F_BREAK) break;  // break was executed - exit the loop!\n    js->flags = flags, js->pos = pos2, js->consumed = 1;  // Jump to final expr\n    if (next(js) != TOK_RPAREN) {                         // Is it specified?\n      v = js_expr(js);                                    // Yes. Execute it\n      if (is_err2(&v, &res)) goto done;  // On error, fail short\n    }\n  }\n  js->pos = pos4, js->tok = TOK_SEMICOLON, js->consumed = 0;\ndone:\n  if (exe) delscope(js);  // Exit scope\n  js->flags = flags;      // Restore flags\n  return res;\n}\n\nstatic jsval_t js_break(struct js *js) {\n  if (js->flags & F_NOEXEC) {\n  } else {\n    if (!(js->flags & F_LOOP)) return js_mkerr(js, \"not in loop\");\n    js->flags |= F_BREAK | F_NOEXEC;\n  }\n  js->consumed = 1;\n  return js_mkundef();\n}\n\nstatic jsval_t js_continue(struct js *js) {\n  if (js->flags & F_NOEXEC) {\n  } else {\n    if (!(js->flags & F_LOOP)) return js_mkerr(js, \"not in loop\");\n    js->flags |= F_NOEXEC;\n  }\n  js->consumed = 1;\n  return js_mkundef();\n}\n\nstatic jsval_t js_return(struct js *js) {\n  uint8_t exe = !(js->flags & F_NOEXEC);\n  js->consumed = 1;\n  if (exe && !(js->flags & F_CALL)) return js_mkerr(js, \"not in func\");\n  if (next(js) == TOK_SEMICOLON) return js_mkundef();\n  jsval_t res = resolveprop(js, js_expr(js));\n  if (exe) {\n    js->pos = js->clen;     // Shift to the end - exit the code snippet\n    js->flags |= F_RETURN;  // Tell caller we've executed\n  }\n  return resolveprop(js, res);\n}\n\nstatic jsval_t js_stmt(struct js *js) {\n  jsval_t res;\n  // jsoff_t pos = js->pos - js->tlen;\n  if (js->brk > js->gct) js_gc(js);\n  switch (next(js)) {  // clang-format off\n    case TOK_CASE: case TOK_CATCH: case TOK_CLASS: case TOK_CONST:\n    case TOK_DEFAULT: case TOK_DELETE: case TOK_DO: case TOK_FINALLY:\n    case TOK_IN: case TOK_INSTANCEOF: case TOK_NEW: case TOK_SWITCH:\n    case TOK_THIS: case TOK_THROW: case TOK_TRY: case TOK_VAR: case TOK_VOID:\n    case TOK_WITH: case TOK_WHILE: case TOK_YIELD:\n      res = js_mkerr(js, \"'%.*s' not implemented\", (int) js->tlen, js->code + js->toff);\n      break;\n    case TOK_CONTINUE:  res = js_continue(js); break;\n    case TOK_BREAK:     res = js_break(js); break;\n    case TOK_LET:       res = js_let(js); break;\n    case TOK_IF:        res = js_if(js); break;\n    case TOK_LBRACE:    res = js_block(js, !(js->flags & F_NOEXEC)); break;\n    case TOK_FOR:       res = js_for(js); break; // 25222 -> 27660\n    case TOK_RETURN:    res = js_return(js); break;\n    default:            res = resolveprop(js, js_expr(js)); break;\n  }\n  //printf(\"STMT [%.*s] -> %s, tok %d, flags %d\\n\", (int) (js->pos - pos), &js->code[pos], js_str(js, res), next(js), js->flags);\n  if (next(js) != TOK_SEMICOLON && next(js) != TOK_EOF && next(js) != TOK_RBRACE) return js_mkerr(js, \"; expected\");\n  js->consumed = 1;\n  // clang-format on\n  return res;\n}\n\nstruct js *js_create(void *buf, size_t len) {\n  struct js *js = NULL;\n  if (len < sizeof(*js) + esize(T_OBJ)) return js;\n  memset(buf, 0, len);                       // Important!\n  js = (struct js *) buf;                    // struct js lives at the beginning\n  js->mem = (uint8_t *) (js + 1);            // Then goes memory for JS data\n  js->size = (jsoff_t) (len - sizeof(*js));  // JS memory size\n  js->scope = mkobj(js, 0);                  // Create global scope\n  js->size = js->size / 8U * 8U;             // Align js->size by 8 byte\n  js->lwm = js->size;                        // Initial LWM: 100% free\n  js->gct = js->size / 2;\n  return js;\n}\n\n// clang-format off\nvoid js_setgct(struct js *js, size_t gct) { js->gct = (jsoff_t) gct; }\nvoid js_setmaxcss(struct js *js, size_t max) { js->maxcss = (jsoff_t) max; }\njsval_t js_mktrue(void) { return mkval(T_BOOL, 1); }\njsval_t js_mkfalse(void) { return mkval(T_BOOL, 0); }\njsval_t js_mkundef(void) { return mkval(T_UNDEF, 0); }\njsval_t js_mknull(void) { return mkval(T_NULL, 0); }\njsval_t js_mknum(double value) { return tov(value); }\njsval_t js_mkobj(struct js *js) { return mkobj(js, 0); }\njsval_t js_mkfun(jsval_t (*fn)(struct js *, jsval_t *, int)) { return mkval(T_CFUNC, (size_t) (void *) fn); }\ndouble js_getnum(jsval_t value) { return tod(value); }\nint js_getbool(jsval_t value) { return vdata(value) & 1 ? 1 : 0; }\n\njsval_t js_glob(struct js *js) { (void) js; return mkval(T_OBJ, 0); }\n\nvoid js_set(struct js *js, jsval_t obj, const char *key, jsval_t val) {\n  if (vtype(obj) == T_OBJ) setprop(js, obj, js_mkstr(js, key, strlen(key)), val);\n}\n\nchar *js_getstr(struct js *js, jsval_t value, size_t *len) {\n  if (vtype(value) != T_STR) return NULL;\n  jsoff_t n, off = vstr(js, value, &n);\n  if (len != NULL) *len = n;\n  return (char *) &js->mem[off];\n}\n\nint js_type(jsval_t val) {\n  switch (vtype(val)) {  \n    case T_UNDEF:   return JS_UNDEF;\n    case T_NULL:    return JS_NULL;\n    case T_BOOL:    return vdata(val) == 0 ? JS_FALSE: JS_TRUE;\n    case T_STR:     return JS_STR;\n    case T_NUM:     return JS_NUM;\n    case T_ERR:     return JS_ERR;\n    default:        return JS_PRIV;\n  }\n}\nvoid js_stats(struct js *js, size_t *total, size_t *lwm, size_t *css) {\n  if (total) *total = js->size;\n  if (lwm) *lwm = js->lwm;\n  if (css) *css = js->css;\n}\n// clang-format on\n\nbool js_chkargs(jsval_t *args, int nargs, const char *spec) {\n  int i = 0, ok = 1;\n  for (; ok && i < nargs && spec[i]; i++) {\n    uint8_t t = vtype(args[i]), c = (uint8_t) spec[i];\n    ok = (c == 'b' && t == T_BOOL) || (c == 'd' && t == T_NUM) ||\n         (c == 's' && t == T_STR) || (c == 'j');\n  }\n  if (spec[i] != '\\0' || i != nargs) ok = 0;\n  return ok;\n}\n\njsval_t js_eval(struct js *js, const char *buf, size_t len) {\n  // printf(\"EVAL: [%.*s]\\n\", (int) len, buf);\n  jsval_t res = js_mkundef();\n  if (len == (size_t) ~0U) len = strlen(buf);\n  js->consumed = 1;\n  js->tok = TOK_ERR;\n  js->code = buf;\n  js->clen = (jsoff_t) len;\n  js->pos = 0;\n  js->cstk = &res;\n  while (next(js) != TOK_EOF && !is_err(res)) {\n    res = js_stmt(js);\n  }\n  return res;\n}\n\n#ifdef JS_DUMP\nvoid js_dump(struct js *js) {\n  jsoff_t off = 0, v;\n  printf(\"JS size %u, brk %u, lwm %u, css %u, nogc %u\\n\", js->size, js->brk,\n         js->lwm, (unsigned) js->css, js->nogc);\n  while (off < js->brk) {\n    memcpy(&v, &js->mem[off], sizeof(v));\n    printf(\" %5u: \", off);\n    if ((v & 3U) == T_OBJ) {\n      printf(\"OBJ %u %u\\n\", v & ~3U,\n             loadoff(js, (jsoff_t) (off + sizeof(off))));\n    } else if ((v & 3U) == T_PROP) {\n      jsoff_t koff = loadoff(js, (jsoff_t) (off + sizeof(v)));\n      jsval_t val = loadval(js, (jsoff_t) (off + sizeof(v) + sizeof(v)));\n      printf(\"PROP next %u, koff %u vtype %d vdata %lu\\n\", v & ~3U, koff,\n             vtype(val), (unsigned long) vdata(val));\n    } else if ((v & 3) == T_STR) {\n      jsoff_t len = offtolen(v);\n      printf(\"STR %u [%.*s]\\n\", len, (int) len, js->mem + off + sizeof(v));\n    } else {\n      printf(\"???\\n\");\n      break;\n    }\n    off += esize(v);\n  }\n}\n#endif\n"
        },
        {
          "name": "elk.h",
          "type": "blob",
          "size": 2.76953125,
          "content": "// Copyright (c) 2013-2022 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License version 3 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.fsf.org/licensing/licenses/agpl-3.0.html\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, please contact us at https://cesanta.com/contact.html\n\n#define JS_VERSION \"3.0.0\"\n#pragma once\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct js;                 // JS engine (opaque)\ntypedef uint64_t jsval_t;  // JS value\n\nstruct js *js_create(void *buf, size_t len);         // Create JS instance\njsval_t js_eval(struct js *, const char *, size_t);  // Execute JS code\njsval_t js_glob(struct js *);                        // Return global object\nconst char *js_str(struct js *, jsval_t val);        // Stringify JS value\nbool js_chkargs(jsval_t *, int, const char *);       // Check args validity\nbool js_truthy(struct js *, jsval_t);                // Check if value is true\nvoid js_setmaxcss(struct js *, size_t);              // Set max C stack size\nvoid js_setgct(struct js *, size_t);                 // Set GC trigger threshold\nvoid js_stats(struct js *, size_t *total, size_t *min, size_t *cstacksize);\nvoid js_dump(struct js *);  // Print debug info. Requires -DJS_DUMP\n\n// Create JS values from C values\njsval_t js_mkundef(void);  // Create undefined\njsval_t js_mknull(void);   // Create null, null, true, false\njsval_t js_mktrue(void);   // Create true\njsval_t js_mkfalse(void);  // Create false\njsval_t js_mkstr(struct js *, const void *, size_t);           // Create string\njsval_t js_mknum(double);                                      // Create number\njsval_t js_mkerr(struct js *js, const char *fmt, ...);         // Create error\njsval_t js_mkfun(jsval_t (*fn)(struct js *, jsval_t *, int));  // Create func\njsval_t js_mkobj(struct js *);                                 // Create object\nvoid js_set(struct js *, jsval_t, const char *, jsval_t);      // Set obj attr\n\n// Extract C values from JS values\nenum { JS_UNDEF, JS_NULL, JS_TRUE, JS_FALSE, JS_STR, JS_NUM, JS_ERR, JS_PRIV };\nint js_type(jsval_t val);       // Return JS value type\ndouble js_getnum(jsval_t val);  // Get number\nint js_getbool(jsval_t val);    // Get boolean, 0 or 1\nchar *js_getstr(struct js *js, jsval_t val, size_t *len);  // Get string\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.2998046875,
          "content": "name=elk\nversion=3.0.0\nauthor=Cesanta Software Limited <support@cesanta.com>\nmaintainer=Cesanta Software Limited <support@cesanta.com>\nsentence=Tiny JavaScript Engine\nparagraph=Implements small but usable subset of JavaScript\ncategory=Other\nurl=https://github.com/cesanta/elk\narchitectures=*\nincludes=elk.h\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}