{
  "metadata": {
    "timestamp": 1736710238428,
    "page": 974,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lh3/bwa",
      "stars": 1559,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0537109375,
          "content": "*.[oa]\nbwa\ntest\ntest64\n.*.swp\nMakefile.bak\nbwamem-lite\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 34.3232421875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 122.7119140625,
          "content": "------------------------------------------------------------------------\nr1605 | lh3 | 2010-12-29 20:20:20 -0500 (Wed, 29 Dec 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.9rc1-2 (r1605)\n * fixed a typo/bug in bwasw\n\n------------------------------------------------------------------------\nr1587 | lh3 | 2010-12-21 18:48:30 -0500 (Tue, 21 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\na typo in the manual\n\n------------------------------------------------------------------------\nr1586 | lh3 | 2010-12-21 18:47:48 -0500 (Tue, 21 Dec 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/utils.c\n   M /branches/prog/bwa/utils.h\n\n * bwa-0.5.9rc1-1 (r1586)\n * a few patches by John\n\n------------------------------------------------------------------------\nr1562 | lh3 | 2010-12-10 01:02:06 -0500 (Fri, 10 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n\ndocumentation on specifying @RG\n\n------------------------------------------------------------------------\nr1561 | lh3 | 2010-12-10 00:45:40 -0500 (Fri, 10 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.9rc1 (r1561)\n\n------------------------------------------------------------------------\nr1560 | lh3 | 2010-12-10 00:29:08 -0500 (Fri, 10 Dec 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/main.c\n\n * fixed a small memory leak caused by the BAM reader\n * fixed a memory violation, also in the BAM reader\n\n------------------------------------------------------------------------\nr1559 | lh3 | 2010-12-10 00:10:48 -0500 (Fri, 10 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/Makefile\n\nchange Makefile gcc options\n\n------------------------------------------------------------------------\nr1558 | lh3 | 2010-12-10 00:09:22 -0500 (Fri, 10 Dec 2010) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.8-6 (r1557)\n * added a little more comments to BWA-SW\n * randomly choosing a mapping if there are more than one\n\n------------------------------------------------------------------------\nr1557 | lh3 | 2010-12-09 21:58:00 -0500 (Thu, 09 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_aux.c\n\nsometimes unmapped reads may not be printed...\n\n------------------------------------------------------------------------\nr1556 | lh3 | 2010-12-09 21:50:26 -0500 (Thu, 09 Dec 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_aux.c\n\nprint unmapped reads\n\n------------------------------------------------------------------------\nr1555 | lh3 | 2010-12-09 21:17:20 -0500 (Thu, 09 Dec 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.8-5 (r1555)\n * BAM input documentation\n\n------------------------------------------------------------------------\nr1544 | lh3 | 2010-11-23 11:01:41 -0500 (Tue, 23 Nov 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.8-4 (r1544)\n * supporting adding RG tags and RG lines\n\n------------------------------------------------------------------------\nr1543 | lh3 | 2010-11-23 00:16:40 -0500 (Tue, 23 Nov 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.8-3 (r1543)\n * fixed a memory leak\n\n------------------------------------------------------------------------\nr1542 | lh3 | 2010-11-22 23:50:56 -0500 (Mon, 22 Nov 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.8-2 (r1542)\n * fixed a long existing bug in random placement of reads\n\n------------------------------------------------------------------------\nr1541 | lh3 | 2010-11-22 23:27:29 -0500 (Mon, 22 Nov 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/bamlite.c\n   A /branches/prog/bwa/bamlite.h\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\npreliminary BAM input support\n\n------------------------------------------------------------------------\nr1537 | lh3 | 2010-10-16 23:46:20 -0400 (Sat, 16 Oct 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n\nchange version number and ChangeLog\n\n------------------------------------------------------------------------\nr1536 | lh3 | 2010-10-16 23:35:10 -0400 (Sat, 16 Oct 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n\n * fixed a bug in the scoring matrix\n * release bwa-0.5.8c (r1536)\n\n------------------------------------------------------------------------\nr1451 | lh3 | 2010-06-15 09:43:52 -0400 (Tue, 15 Jun 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nversion change\n\n------------------------------------------------------------------------\nr1450 | lh3 | 2010-06-15 09:42:21 -0400 (Tue, 15 Jun 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n\n * bwa-0.5.8b (r1450)\n * fixed a bug in scoring matrix\n\n------------------------------------------------------------------------\nr1445 | lh3 | 2010-06-11 08:58:33 -0400 (Fri, 11 Jun 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n\nfixed a serious bug\n\n------------------------------------------------------------------------\nr1442 | lh3 | 2010-06-08 10:22:14 -0400 (Tue, 08 Jun 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.8 (r1442)\n\n------------------------------------------------------------------------\nr1440 | lh3 | 2010-05-19 13:43:50 -0400 (Wed, 19 May 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-r1440\n * sorry, forget to remove a debugging line\n\n------------------------------------------------------------------------\nr1439 | lh3 | 2010-05-19 13:43:08 -0400 (Wed, 19 May 2010) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-r1439\n * fixed a bug in bwasw caused by a recent modification\n * throwing insane insert size when estimating isize\n\n------------------------------------------------------------------------\nr1425 | lh3 | 2010-04-29 15:15:23 -0400 (Thu, 29 Apr 2010) | 10 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.7-7 (r1425)\n * fixed a minor bug in bwasw command-line parsing\n * When band-width is not large enough, bwasw may find two highly\n   overlapping but not completely overlapping alignments. The old\n   version will filter out one of them, which leads to false\n   negatives. The current outputs both. This solution is obviously not\n   ideal. The ideal one would be to increase the band-width and redo the\n   alignment.\n\n\n------------------------------------------------------------------------\nr1399 | lh3 | 2010-04-16 09:20:49 -0400 (Fri, 16 Apr 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.7-6 (r1399)\n * fixed a typo/bug (by Vaughn Iverson)\n\n------------------------------------------------------------------------\nr1329 | lh3 | 2010-03-19 23:32:46 -0400 (Fri, 19 Mar 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\nsmall correction\n\n------------------------------------------------------------------------\nr1328 | lh3 | 2010-03-19 23:28:44 -0400 (Fri, 19 Mar 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.7-4 (r1328)\n * automatically adjust ap_prior based on alignment\n\n------------------------------------------------------------------------\nr1327 | lh3 | 2010-03-19 23:02:40 -0400 (Fri, 19 Mar 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.5.7-3 (r1327)\n * evaluate hits obtained from SW alignment in a more proper way.\n\n------------------------------------------------------------------------\nr1320 | lh3 | 2010-03-17 15:13:22 -0400 (Wed, 17 Mar 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n\nfixed a potential out-of-boundary error. Need more testing.\n\n------------------------------------------------------------------------\nr1319 | lh3 | 2010-03-14 22:44:46 -0400 (Sun, 14 Mar 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n\ninsert size is `weird' if the 3rd quatile larger than 100,000bp\n\n------------------------------------------------------------------------\nr1318 | lh3 | 2010-03-14 22:37:35 -0400 (Sun, 14 Mar 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.7-2 (r1318)\n * in sampe, allow to disable insert size estimate\n\n------------------------------------------------------------------------\nr1317 | lh3 | 2010-03-14 22:14:14 -0400 (Sun, 14 Mar 2010) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/solid2fastq.pl\n\n * bwa-0.5.7-1 (r1317)\n * fixed a potential bug in solid2fastq.pl\n * fixed a bug in calculating mapping quality (by Rodrigo Goya)\n * fixed a very rare bug (if ever occur) about pairing\n\n------------------------------------------------------------------------\nr1310 | lh3 | 2010-03-01 10:35:45 -0500 (Mon, 01 Mar 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.7\n\n------------------------------------------------------------------------\nr1309 | lh3 | 2010-02-26 21:42:22 -0500 (Fri, 26 Feb 2010) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.6-2 (r1309)\n * fixed an unfixed bug (by Carol Scott)\n * fixed some tiny formatting\n\n------------------------------------------------------------------------\nr1305 | lh3 | 2010-02-25 13:47:58 -0500 (Thu, 25 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.6-1 (r1304)\n * optionally write output to a file (by Tim Fennel)\n\n------------------------------------------------------------------------\nr1303 | lh3 | 2010-02-10 23:43:48 -0500 (Wed, 10 Feb 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.6\n\n------------------------------------------------------------------------\nr1302 | lh3 | 2010-02-10 11:11:49 -0500 (Wed, 10 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-10 (r1302)\n * improve max insert size estimate (method suggested by Gerton Lunter)\n\n------------------------------------------------------------------------\nr1301 | lh3 | 2010-02-09 16:15:28 -0500 (Tue, 09 Feb 2010) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-9 (r1301)\n * improve mapping quality calculation for abnomalous pairs\n * fixed a bug in multiple hits\n * SOLiD multiple hits should work now\n\n------------------------------------------------------------------------\nr1300 | lh3 | 2010-02-09 12:50:02 -0500 (Tue, 09 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-8 (r1300)\n * output kurtosis\n\n------------------------------------------------------------------------\nr1299 | lh3 | 2010-02-09 12:33:34 -0500 (Tue, 09 Feb 2010) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-7 (r1299)\n * calculate skewness in sampe\n * increase min_len in SW to 20\n * perform more SW to fix discordant pairs\n\n------------------------------------------------------------------------\nr1298 | lh3 | 2010-02-08 12:40:31 -0500 (Mon, 08 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.5.5-6 (r1297)\n * prepare to replace all 16-bit CIGAR (patches by Rodrigo Goya)\n\n------------------------------------------------------------------------\nr1297 | lh3 | 2010-02-05 22:26:11 -0500 (Fri, 05 Feb 2010) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/solid2fastq.pl\n\nthe old fix seems not working!\n\n------------------------------------------------------------------------\nr1296 | lh3 | 2010-02-05 21:51:03 -0500 (Fri, 05 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-5 (r1296)\n * fixed a minor issue that the lower bound of insert size is not correctly set.\n\n------------------------------------------------------------------------\nr1295 | lh3 | 2010-02-05 21:01:10 -0500 (Fri, 05 Feb 2010) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-4 (r1295)\n * fixed a memory leak\n * change the behaviour of -n (samse and sampe)\n * change the default of -n\n\n------------------------------------------------------------------------\nr1294 | lh3 | 2010-02-05 17:24:06 -0500 (Fri, 05 Feb 2010) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-3 (r1294)\n * improved multi-hit report\n\n------------------------------------------------------------------------\nr1293 | lh3 | 2010-02-05 12:57:38 -0500 (Fri, 05 Feb 2010) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/solid2fastq.pl\n\n * bwa-0.5.5-2 (r1293)\n * bugfix: truncated quality string\n * bugfix: quality -1 in solid->fastq conversion\n * bugfix: color reads on the reverse strand is not complemented\n\n------------------------------------------------------------------------\nr1279 | lh3 | 2009-11-23 22:42:34 -0500 (Mon, 23 Nov 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwase.c\n   A /branches/prog/bwa/bwase.h\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.5-1 (r1279)\n * incorporate changes from Matt Hanna for Java bindings.\n\n------------------------------------------------------------------------\nr1275 | lh3 | 2009-11-10 22:13:10 -0500 (Tue, 10 Nov 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n\nupdate ChangeLog\n\n------------------------------------------------------------------------\nr1273 | lh3 | 2009-11-10 22:08:16 -0500 (Tue, 10 Nov 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n   A /branches/prog/bwa/qualfa2fq.pl\n\nRelease bwa-0.5.5 (r1273)\n\n------------------------------------------------------------------------\nr1272 | lh3 | 2009-11-10 22:02:50 -0500 (Tue, 10 Nov 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.4-3 (r1272)\n * fixed another typo which may lead to incorrect single-end mapping quality\n\n------------------------------------------------------------------------\nr1271 | lh3 | 2009-11-10 21:59:47 -0500 (Tue, 10 Nov 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.4-2 (r1271)\n * fixed a serious typo/bug which does not hurt if we allow one gap open\n   and work with <200bp reads, but causes segfault for long reads.\n\n------------------------------------------------------------------------\nr1270 | lh3 | 2009-11-09 23:12:42 -0500 (Mon, 09 Nov 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.4-1 (r1270)\n * fixed a bug in color alignment\n\n------------------------------------------------------------------------\nr1245 | lh3 | 2009-10-09 07:42:52 -0400 (Fri, 09 Oct 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.4\n\n------------------------------------------------------------------------\nr1244 | lh3 | 2009-10-09 05:53:52 -0400 (Fri, 09 Oct 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n\n * bwa-0.5.3-4 (r1244)\n * output the clipped length in XC:i: tag\n * skip mate alignment when stdaln is buggy\n * fixed a bug in NM:i: tag\n\n------------------------------------------------------------------------\nr1243 | lh3 | 2009-10-07 08:15:04 -0400 (Wed, 07 Oct 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.3-3 (r1243)\n * sampe: fixed a bug when a read sequence is identical its reverse complement.\n\n------------------------------------------------------------------------\nr1242 | lh3 | 2009-10-07 07:49:13 -0400 (Wed, 07 Oct 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.3-2 (r1242)\n * sampe: optionall preload the full index into memory\n * aln: change the default seed length to 32bp\n\n------------------------------------------------------------------------\nr1238 | lh3 | 2009-09-26 18:38:15 -0400 (Sat, 26 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/khash.h\n\nImprove portability of khash.h\n\n------------------------------------------------------------------------\nr1228 | lh3 | 2009-09-15 09:20:22 -0400 (Tue, 15 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n\nfixed a typo\n\n------------------------------------------------------------------------\nr1227 | lh3 | 2009-09-15 09:19:35 -0400 (Tue, 15 Sep 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.3-1 (r1226)\n * in dBWT-SW, optionall use hard clipping instead of soft clipping\n\n------------------------------------------------------------------------\nr1225 | lh3 | 2009-09-15 08:32:30 -0400 (Tue, 15 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.3 (r1225)\n\n------------------------------------------------------------------------\nr1223 | lh3 | 2009-09-13 07:30:41 -0400 (Sun, 13 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.2\n\n------------------------------------------------------------------------\nr1222 | lh3 | 2009-09-11 09:11:39 -0400 (Fri, 11 Sep 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.1-5 (r1222)\n * fixed a typo. No real change\n\n------------------------------------------------------------------------\nr1221 | lh3 | 2009-09-11 09:09:44 -0400 (Fri, 11 Sep 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.1-4 (r1221)\n * trim reads before alignment\n\n------------------------------------------------------------------------\nr1216 | lh3 | 2009-09-08 17:50:15 -0400 (Tue, 08 Sep 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.1-3 (r1216)\n * fixed a bug about NM tags for gapped alignment\n * print SAM header\n\n------------------------------------------------------------------------\nr1215 | lh3 | 2009-09-08 17:14:42 -0400 (Tue, 08 Sep 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.1-2 (r1215)\n * fixed a bug when read lengths vary (by John Marshall)\n\n------------------------------------------------------------------------\nr1213 | lh3 | 2009-09-06 18:58:15 -0400 (Sun, 06 Sep 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.1-1 (r1213)\n * change default -T to 30\n\n------------------------------------------------------------------------\nr1209 | lh3 | 2009-09-02 06:06:02 -0400 (Wed, 02 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.1\n\n------------------------------------------------------------------------\nr1208 | lh3 | 2009-09-02 05:56:33 -0400 (Wed, 02 Sep 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n\n * ChangeLog\n\n------------------------------------------------------------------------\nr1206 | lh3 | 2009-08-30 18:27:30 -0400 (Sun, 30 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.0-6 (r1206)\n * fixed two bugs caused by previous modification\n\n------------------------------------------------------------------------\nr1205 | lh3 | 2009-08-30 17:28:36 -0400 (Sun, 30 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.0-4 (r1205)\n * reduce false coordinates and CIGAR when a query bridges two reference\n   sequences, although some very rare cases may fail bwa.\n\n------------------------------------------------------------------------\nr1204 | lh3 | 2009-08-30 06:06:16 -0400 (Sun, 30 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.0-3 (r1204)\n * choose one repetitive hit to extend\n\n------------------------------------------------------------------------\nr1203 | lh3 | 2009-08-29 18:11:51 -0400 (Sat, 29 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.0-2 (r1203)\n * dBWT-SW: change a parameter in calculating mapping quality\n * fixed a bug in samse\n\n------------------------------------------------------------------------\nr1202 | lh3 | 2009-08-28 19:48:41 -0400 (Fri, 28 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.5.0-1 (r1202)\n * change default band width to 50\n * improve mapping quality a bit\n\n------------------------------------------------------------------------\nr1200 | lh3 | 2009-08-20 06:21:24 -0400 (Thu, 20 Aug 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.5.0 (r1200)\n\n------------------------------------------------------------------------\nr1199 | lh3 | 2009-08-20 04:49:15 -0400 (Thu, 20 Aug 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n\nUpdated ChangeLog and the manual\n\n------------------------------------------------------------------------\nr1198 | lh3 | 2009-08-19 11:09:15 -0400 (Wed, 19 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-36 (r1198)\n * simplify duphits removal. The accuracy is changed a tiny bit, sometimes better, sometimes worse.\n\n------------------------------------------------------------------------\nr1197 | lh3 | 2009-08-19 08:15:05 -0400 (Wed, 19 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_aux.c\n   A /branches/prog/bwa/bwtsw2_chain.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-35 (r1197)\n * further heuristic acceleration for long queries\n\n------------------------------------------------------------------------\nr1196 | lh3 | 2009-08-18 06:54:03 -0400 (Tue, 18 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-34 (r1196)\n * updated the manual page\n * output base quality if the input is fastq\n\n------------------------------------------------------------------------\nr1195 | lh3 | 2009-08-18 06:23:00 -0400 (Tue, 18 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/simple_dp.c\n\n * bwa-0.4.9-33 (r1191)\n * fixed a bug in sampe/samse when gaps occur to the 5'-end in SW alignment\n * in dbwtsw adjust -T and -c according to -a\n\n------------------------------------------------------------------------\nr1192 | lh3 | 2009-08-13 05:37:28 -0400 (Thu, 13 Aug 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate manual\n\n------------------------------------------------------------------------\nr1191 | lh3 | 2009-08-12 19:40:51 -0400 (Wed, 12 Aug 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtsw2_main.c\n\nupdate documentation\n\n------------------------------------------------------------------------\nr1190 | lh3 | 2009-08-12 08:56:10 -0400 (Wed, 12 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-32 (r1190)\n * only help messages are changed\n\n------------------------------------------------------------------------\nr1189 | lh3 | 2009-08-11 09:28:55 -0400 (Tue, 11 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-31 (r1189)\n * in bwape/bwase, print CIGAR \"*\" if the read is unmapped\n * improved the calculation of mapping quality\n\n------------------------------------------------------------------------\nr1181 | lh3 | 2009-08-03 12:09:41 -0400 (Mon, 03 Aug 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n\nfflush()\n\n------------------------------------------------------------------------\nr1180 | lh3 | 2009-08-03 12:08:46 -0400 (Mon, 03 Aug 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-30 (r1180)\n * fixed a memory problem\n * multi-threading sometimes does not work...\n\n------------------------------------------------------------------------\nr1179 | lh3 | 2009-08-03 11:04:39 -0400 (Mon, 03 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-29 (r1179)\n * preliminary mutli-threading support in dbwtsw\n\n------------------------------------------------------------------------\nr1178 | lh3 | 2009-08-03 09:14:54 -0400 (Mon, 03 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-28 (r1178)\n * fixed a bug in printing repetitive hits\n\n------------------------------------------------------------------------\nr1177 | lh3 | 2009-08-03 05:03:42 -0400 (Mon, 03 Aug 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-27 (r1177)\n * bwtsw2: fixed a hidden memory leak\n\n------------------------------------------------------------------------\nr1176 | lh3 | 2009-07-31 10:58:24 -0400 (Fri, 31 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-26\n * change the way mapping quality is calculated\n\n------------------------------------------------------------------------\nr1175 | lh3 | 2009-07-31 09:15:54 -0400 (Fri, 31 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-25\n * code clean up\n * automatically adjust ->t and ->is_rev based on input\n\n------------------------------------------------------------------------\nr1174 | lh3 | 2009-07-30 08:50:25 -0400 (Thu, 30 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-24\n * fixed a bug in printing the hits\n\n------------------------------------------------------------------------\nr1173 | lh3 | 2009-07-29 18:32:43 -0400 (Wed, 29 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-23\n * allow to skip reverse alignment\n * increase opt->t to 37\n\n------------------------------------------------------------------------\nr1172 | lh3 | 2009-07-29 17:22:39 -0400 (Wed, 29 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-22\n * report if the hit is found in both directions\n\n------------------------------------------------------------------------\nr1171 | lh3 | 2009-07-29 17:12:02 -0400 (Wed, 29 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-21\n * dbwtsw: map to both forward and reverse BWT to reduce false alignment\n\n------------------------------------------------------------------------\nr1170 | lh3 | 2009-07-29 15:25:14 -0400 (Wed, 29 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\nsave hits before cut_tail()\n\n------------------------------------------------------------------------\nr1169 | lh3 | 2009-07-29 08:06:01 -0400 (Wed, 29 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.9-19\n * use a global memory pool to reduce the CPU time spent on malloc/free().\n\n------------------------------------------------------------------------\nr1168 | lh3 | 2009-07-29 06:13:29 -0400 (Wed, 29 Jul 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-18\n * reduce unnecessary extension to the 5'-end\n * allow to use different interval size for the 2 rounds\n * change default parameters\n\n------------------------------------------------------------------------\nr1167 | lh3 | 2009-07-28 19:06:17 -0400 (Tue, 28 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-17\n * dbwtsw: fixed THE memory leak.\n\n------------------------------------------------------------------------\nr1166 | lh3 | 2009-07-28 16:31:41 -0400 (Tue, 28 Jul 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n\n * bwa-0.4.9-16\n * fixed a memory leak\n * a small memory leak still occurs to bwtsw2_core(). I will work on that later.\n * changed the default parameters\n\n------------------------------------------------------------------------\nr1165 | lh3 | 2009-07-28 10:15:40 -0400 (Tue, 28 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n\n * bwa-0.4.9-15\n * generate CIGAR right before output. This saves unnecessary computation.\n * this version may be buggy as I have not tested it.\n\n------------------------------------------------------------------------\nr1164 | lh3 | 2009-07-28 09:04:14 -0400 (Tue, 28 Jul 2009) | 11 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.9-14\n\n * deplete unique hits in dbwtsw and postprocess them with standard sw\n\n * in principle, this stratgy should be faster and more accurate, but I\n   have not tested this point. I may switch back to the old method if\n   this does not work.\n\n * the code looks quite nasty now. it needs clean up...\n\n\n------------------------------------------------------------------------\nr1163 | lh3 | 2009-07-27 17:41:10 -0400 (Mon, 27 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n\nchange a default parameter\n\n------------------------------------------------------------------------\nr1162 | lh3 | 2009-07-27 17:04:35 -0400 (Mon, 27 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-13\n * dbwtsw: switch between small and large Z-best\n\n------------------------------------------------------------------------\nr1161 | lh3 | 2009-07-27 12:17:41 -0400 (Mon, 27 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-12\n * changed the default -z to 100\n * heuristically speed up alignments for polyA reads\n\n------------------------------------------------------------------------\nr1160 | lh3 | 2009-07-27 07:50:57 -0400 (Mon, 27 Jul 2009) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-11\n\n * dbwtsw potentially generates less false alignments, although in\n   practice, the modification brings no improvement.\n\n\n------------------------------------------------------------------------\nr1159 | lh3 | 2009-07-27 04:37:02 -0400 (Mon, 27 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-10\n * disabled debugging code\n * add \"BAM_FMU\" if both ends are unmapped\n\n------------------------------------------------------------------------\nr1158 | lh3 | 2009-07-24 09:36:52 -0400 (Fri, 24 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n\nnothing, really\n\n------------------------------------------------------------------------\nr1157 | lh3 | 2009-07-24 09:05:44 -0400 (Fri, 24 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-9\n * bwtsw2: generate SAM output\n\n------------------------------------------------------------------------\nr1156 | lh3 | 2009-07-24 05:42:47 -0400 (Fri, 24 Jul 2009) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-8\n\n * fixed a weird deadloop which only happens to icc -O3. Thanks John\n   Marshall for the fix.\n\n\n------------------------------------------------------------------------\nr1155 | lh3 | 2009-07-24 05:28:40 -0400 (Fri, 24 Jul 2009) | 8 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-7\n\n * fixed a typo in bwtsw2 alignment. Now score from the standard SW\n   seems to agree with score from bwtsw2, except that in reporting\n   alignments, bwtsw2 may report non-optimal segments. This is expected,\n   though. I will improve in future.\n\n\n------------------------------------------------------------------------\nr1154 | lh3 | 2009-07-23 17:40:20 -0400 (Thu, 23 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * aln_left_core() seems to work properly\n * aln_local_core() has a bug... AN EVER EXISTING BUG!!!!!!!!!!!\n\n------------------------------------------------------------------------\nr1153 | lh3 | 2009-07-23 17:06:09 -0400 (Thu, 23 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/stdaln.c\n\nremoved debugging code...\n\n------------------------------------------------------------------------\nr1152 | lh3 | 2009-07-23 17:01:00 -0400 (Thu, 23 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/stdaln.c\n\n * radical changes failed...\n * fixed a bug\n\n------------------------------------------------------------------------\nr1151 | lh3 | 2009-07-23 14:46:35 -0400 (Thu, 23 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/stdaln.c\n\ntemporary changes. Will apply some radical changes to this file...\n\n------------------------------------------------------------------------\nr1150 | lh3 | 2009-07-23 10:09:56 -0400 (Thu, 23 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/stdaln.c\n\nfixed a long-existing bug in Smith-Waterman alignment\n\n------------------------------------------------------------------------\nr1149 | lh3 | 2009-07-23 08:50:52 -0400 (Thu, 23 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.9-6\n * unexplained inconsistency still occurs, but the results largely look reasonable.\n\n------------------------------------------------------------------------\nr1148 | lh3 | 2009-07-23 08:07:29 -0400 (Thu, 23 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/stdaln.c\n\nhalf DP\n\n------------------------------------------------------------------------\nr1147 | lh3 | 2009-07-22 08:03:06 -0400 (Wed, 22 Jul 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n\na bit code clean up\n\n------------------------------------------------------------------------\nr1145 | lh3 | 2009-07-21 15:52:05 -0400 (Tue, 21 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-5\n * fixed a bug in determining sub-optimal hits\n * removed some debugging codes\n\n------------------------------------------------------------------------\nr1144 | lh3 | 2009-07-21 10:17:29 -0400 (Tue, 21 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-4\n * better cmd interface\n * faster speed\n\n------------------------------------------------------------------------\nr1143 | lh3 | 2009-07-20 16:38:18 -0400 (Mon, 20 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\nbwtsw2 (dBWT-SW) is working apparently...\n\n\n------------------------------------------------------------------------\nr1139 | lh3 | 2009-07-15 05:52:18 -0400 (Wed, 15 Jul 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.9-2\n * bwtsw2: change cut_tail() such that it is faster but more likely to\n   miss true hits\n\n------------------------------------------------------------------------\nr1138 | lh3 | 2009-07-15 05:18:42 -0400 (Wed, 15 Jul 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/bwt_lite.c\n   A /branches/prog/bwa/bwt_lite.h\n   A /branches/prog/bwa/bwtsw2.h\n   A /branches/prog/bwa/bwtsw2_aux.c\n   A /branches/prog/bwa/bwtsw2_core.c\n   A /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * bwa-0.4.9-1\n * added back bwtsw2\n\n------------------------------------------------------------------------\nr1075 | lh3 | 2009-05-19 05:14:50 -0400 (Tue, 19 May 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.9\n\n------------------------------------------------------------------------\nr1073 | lh3 | 2009-05-18 17:13:19 -0400 (Mon, 18 May 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.8\n\n------------------------------------------------------------------------\nr1069 | lh3 | 2009-05-14 09:54:54 -0400 (Thu, 14 May 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.7-2\n * change the default of \"aln -R\" to 30\n\n------------------------------------------------------------------------\nr1068 | lh3 | 2009-05-14 09:27:55 -0400 (Thu, 14 May 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.7-1\n * search for suboptimal hits if the top hit is not so repetitive\n\n------------------------------------------------------------------------\nr1066 | lh3 | 2009-05-12 15:31:31 -0400 (Tue, 12 May 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.7\n\n------------------------------------------------------------------------\nr1065 | lh3 | 2009-05-12 15:20:40 -0400 (Tue, 12 May 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.6-9\n * fixed compiling errors on some Linux machines\n\n------------------------------------------------------------------------\nr1064 | lh3 | 2009-05-12 07:30:46 -0400 (Tue, 12 May 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.6-8\n * avoid compilation error on some systems.\n\n------------------------------------------------------------------------\nr1035 | lh3 | 2009-05-09 05:41:33 -0400 (Sat, 09 May 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.6-7\n * fixed an integer overflow caused by previous modifications\n * made insert size estimation more robust\n\n------------------------------------------------------------------------\nr1008 | lh3 | 2009-04-29 05:41:58 -0400 (Wed, 29 Apr 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.6-5\n * fixed a integer overflow problem which may cause seg fault in very rare cases\n * made XN tags more accurate\n\n------------------------------------------------------------------------\nr1005 | lh3 | 2009-04-27 07:37:23 -0400 (Mon, 27 Apr 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.6-4\n * heuristic rules to detect suboptimal alignment\n * stdsw: support double-strand and protein alignment\n\n------------------------------------------------------------------------\nr1003 | lh3 | 2009-04-26 12:48:19 -0400 (Sun, 26 Apr 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.6-2\n * improve the functionality of stdsw\n * allow to add a threshold on SW alignment. Hope this does not incur new bugs...\n\n------------------------------------------------------------------------\nr1002 | lh3 | 2009-04-22 03:56:15 -0400 (Wed, 22 Apr 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.6-1\n * output SM and AM tag\n\n------------------------------------------------------------------------\nr914 | lh3 | 2009-03-09 17:53:50 -0400 (Mon, 09 Mar 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.6\n\n------------------------------------------------------------------------\nr913 | lh3 | 2009-03-09 17:23:24 -0400 (Mon, 09 Mar 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   A /branches/prog/bwa/solid2fastq.pl\n\n * added notes to bwa\n * added a script to convert SOLiD reads\n * updated documentations\n\n------------------------------------------------------------------------\nr912 | lh3 | 2009-03-09 16:57:05 -0400 (Mon, 09 Mar 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/kstring.c\n   M /branches/prog/bwa/main.c\n\nfixed a bug in kstring\n\n------------------------------------------------------------------------\nr881 | lh3 | 2009-03-02 15:36:06 -0500 (Mon, 02 Mar 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtmisc.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.5-7\n * fixed a bug in pac2cspac\n\n------------------------------------------------------------------------\nr880 | lh3 | 2009-03-01 16:34:08 -0500 (Sun, 01 Mar 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n\ndisable debugging\n\n------------------------------------------------------------------------\nr879 | lh3 | 2009-03-01 16:28:04 -0500 (Sun, 01 Mar 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.5-6\n * fixed problems with coordinates for color gapped alignment\n\n------------------------------------------------------------------------\nr878 | lh3 | 2009-03-01 13:43:09 -0500 (Sun, 01 Mar 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.5-5\n * added support for gapped color alignment\n\n------------------------------------------------------------------------\nr877 | lh3 | 2009-03-01 10:27:52 -0500 (Sun, 01 Mar 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/cs2nt.c\n   M /branches/prog/bwa/main.c\n\n * convert cs read to nt read (for ungapped alignment only)\n\n------------------------------------------------------------------------\nr860 | lh3 | 2009-02-27 08:58:39 -0500 (Fri, 27 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwase.c\n   A /branches/prog/bwa/cs2nt.c\n\nprepare to implement cs->nt conversion (have not yet...)\n\n------------------------------------------------------------------------\nr859 | lh3 | 2009-02-27 07:00:03 -0500 (Fri, 27 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/bwtmisc.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * bwa-0.4.5-3\n * generate color index from nucleotide fasta reference\n\n------------------------------------------------------------------------\nr857 | lh3 | 2009-02-26 10:22:58 -0500 (Thu, 26 Feb 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.5-2\n * improved mapping quality a bit if one end falls in a tandem repeat\n   but the mate is unique.\n\n------------------------------------------------------------------------\nr856 | lh3 | 2009-02-26 10:02:29 -0500 (Thu, 26 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.5-1\n * make bwa work for SOLiD reads\n\n------------------------------------------------------------------------\nr828 | lh3 | 2009-02-18 17:36:41 -0500 (Wed, 18 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.5\n\n------------------------------------------------------------------------\nr827 | lh3 | 2009-02-18 16:48:48 -0500 (Wed, 18 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.4.4-6\n * fixed a bug in SW alignment when no residue matches\n\n------------------------------------------------------------------------\nr824 | lh3 | 2009-02-17 05:33:07 -0500 (Tue, 17 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.4-5\n * fixed that bounary bug\n\n------------------------------------------------------------------------\nr823 | lh3 | 2009-02-17 04:54:18 -0500 (Tue, 17 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwape.c\n\njust change some logging information\n\n------------------------------------------------------------------------\nr822 | lh3 | 2009-02-17 04:20:39 -0500 (Tue, 17 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate manual\n\n------------------------------------------------------------------------\nr821 | lh3 | 2009-02-17 04:11:14 -0500 (Tue, 17 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.4-4\n * fixed a bug on boundary check in pair_sw\n\n------------------------------------------------------------------------\nr820 | lh3 | 2009-02-16 17:43:37 -0500 (Mon, 16 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.4-3\n * allow to change mismatch penalty\n\n------------------------------------------------------------------------\nr819 | lh3 | 2009-02-16 17:40:28 -0500 (Mon, 16 Feb 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.4-2\n * remove timer\n * allow to change default gapo and gape penalty at the command line\n\n------------------------------------------------------------------------\nr818 | lh3 | 2009-02-16 09:30:51 -0500 (Mon, 16 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate benchmark\n\n------------------------------------------------------------------------\nr817 | lh3 | 2009-02-16 08:44:40 -0500 (Mon, 16 Feb 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/kvec.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.4-1\n * automatically detect insert size\n * use insert size in pairing. This may potentially improve accuracy (untested!)\n\n------------------------------------------------------------------------\nr814 | lh3 | 2009-02-15 11:10:23 -0500 (Sun, 15 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.4\n\n------------------------------------------------------------------------\nr813 | lh3 | 2009-02-15 10:22:50 -0500 (Sun, 15 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.3-5\n * impose boundary check in refine_gapped\n\n------------------------------------------------------------------------\nr811 | lh3 | 2009-02-14 09:46:13 -0500 (Sat, 14 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.3-4\n * change MD tag to match the latest SAM specification\n\n------------------------------------------------------------------------\nr810 | lh3 | 2009-02-13 04:46:04 -0500 (Fri, 13 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n\nupdate ChangeLog\n\n------------------------------------------------------------------------\nr799 | lh3 | 2009-02-05 12:01:17 -0500 (Thu, 05 Feb 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\nchange MD tag to meet the latest SAM specification\n\n------------------------------------------------------------------------\nr796 | lh3 | 2009-02-05 08:35:13 -0500 (Thu, 05 Feb 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.3-2\n * fixed a bug on counting 'N'\n\n------------------------------------------------------------------------\nr795 | lh3 | 2009-02-05 07:41:27 -0500 (Thu, 05 Feb 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.3-1\n * fixed potential boundary problems\n * update benchmark result\n\n------------------------------------------------------------------------\nr791 | lh3 | 2009-01-25 05:20:47 -0500 (Sun, 25 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate some numbers\n\n------------------------------------------------------------------------\nr790 | lh3 | 2009-01-24 15:13:03 -0500 (Sat, 24 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate benchmark\n\n------------------------------------------------------------------------\nr789 | lh3 | 2009-01-22 10:18:44 -0500 (Thu, 22 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtindex.c\n\na warning message for index\n\n------------------------------------------------------------------------\nr788 | lh3 | 2009-01-22 09:54:06 -0500 (Thu, 22 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/main.c\n\nforget to change release number\n\n------------------------------------------------------------------------\nr786 | lh3 | 2009-01-22 06:27:39 -0500 (Thu, 22 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n\nRelease bwa-0.4.3\n\n------------------------------------------------------------------------\nr785 | lh3 | 2009-01-22 06:27:16 -0500 (Thu, 22 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n\nRelease bwa-0.4.3\n\n------------------------------------------------------------------------\nr784 | lh3 | 2009-01-22 06:19:59 -0500 (Thu, 22 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-10\n * update documentation\n * fixed a bug on generating MD tags for SW alignment\n\n------------------------------------------------------------------------\nr782 | lh3 | 2009-01-19 12:08:38 -0500 (Mon, 19 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-9\n * fixed a bug in samse -n...\n\n------------------------------------------------------------------------\nr781 | lh3 | 2009-01-19 11:26:37 -0500 (Mon, 19 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-8\n * given -N, the previous version would stop if the top hit is a repeat. Now changed.\n\n------------------------------------------------------------------------\nr780 | lh3 | 2009-01-19 11:20:18 -0500 (Mon, 19 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-7\n * use a bit-wise flag to replace some member variables in the option struct\n * allow to switch off the iterative strategy\n\n------------------------------------------------------------------------\nr779 | lh3 | 2009-01-19 10:45:57 -0500 (Mon, 19 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-6\n * allow to dump multiple hits from samse, in another format, though\n\n------------------------------------------------------------------------\nr778 | lh3 | 2009-01-19 06:24:29 -0500 (Mon, 19 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/kseq.h\n   A /branches/prog/bwa/kstring.c\n   A /branches/prog/bwa/kstring.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/simple_dp.c\n\n * bwa-0.4.2-5\n * update kseq.h to the latest version\n * generate MD tag\n * print mate coordinate if only one end is unmapped\n\n------------------------------------------------------------------------\nr775 | lh3 | 2009-01-18 05:40:35 -0500 (Sun, 18 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-4\n * fixed a bug for SAM format\n\n------------------------------------------------------------------------\nr774 | lh3 | 2009-01-17 13:48:52 -0500 (Sat, 17 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-3\n * change default fnr to 0.04\n * print max_diff for valid fnr\n\n------------------------------------------------------------------------\nr773 | lh3 | 2009-01-17 05:54:37 -0500 (Sat, 17 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-2\n * automatically choose max_diff\n\n------------------------------------------------------------------------\nr772 | lh3 | 2009-01-16 18:16:14 -0500 (Fri, 16 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.2-1\n * take N as a mismatch\n\n------------------------------------------------------------------------\nr768 | lh3 | 2009-01-09 11:57:23 -0500 (Fri, 09 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.2\n\n------------------------------------------------------------------------\nr759 | lh3 | 2009-01-07 09:55:43 -0500 (Wed, 07 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.1\n\n------------------------------------------------------------------------\nr758 | lh3 | 2009-01-07 05:36:06 -0500 (Wed, 07 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.0-2\n * make mate_sw fully working\n\n------------------------------------------------------------------------\nr757 | lh3 | 2009-01-06 18:04:29 -0500 (Tue, 06 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.4.0-1\n * do SW alignment for unmapped mate. It is working.\n * I still need to do some extra work for SW alignment, but it is too late\n   and I am getting tired... I will do tomorrow.\n\n------------------------------------------------------------------------\nr755 | lh3 | 2009-01-06 10:23:29 -0500 (Tue, 06 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.4.0\n\n------------------------------------------------------------------------\nr754 | lh3 | 2009-01-06 07:45:02 -0500 (Tue, 06 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-12\n * better lock\n\n------------------------------------------------------------------------\nr753 | lh3 | 2009-01-06 06:17:21 -0500 (Tue, 06 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-11\n * fixed a small memory leak in bwa_seq_close()\n * fixed \"uninitialized memory\" from bwt_aln1_t\n * multithreading for \"aln\" command\n\n------------------------------------------------------------------------\nr752 | lh3 | 2009-01-05 17:34:13 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   D /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwt_gen/bwt_gen.c\n   A /branches/prog/bwa/bwtmisc.c (from /branches/prog/bwa/pac2bwt.c:748)\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   D /branches/prog/bwa/pac2bwt.c\n\n * bwa-0.3.0-10\n * a little bit code clean up\n\n------------------------------------------------------------------------\nr751 | lh3 | 2009-01-05 17:19:04 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-9\n * use 64-bit integer to speed up Occ calculate, although just a little bit\n\n------------------------------------------------------------------------\nr750 | lh3 | 2009-01-05 16:44:26 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-8\n * a little bit code cleanup\n\n------------------------------------------------------------------------\nr749 | lh3 | 2009-01-05 16:37:28 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-7\n * accelerate Occ calculation\n\n------------------------------------------------------------------------\nr748 | lh3 | 2009-01-05 16:12:28 -0500 (Mon, 05 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/pac2bwt.c\n\n * bwa-0.3.0-6\n * put occ table along with bwt to save another cache miss\n * this version is already faster than the previous and I can still improve it...\n\n------------------------------------------------------------------------\nr747 | lh3 | 2009-01-05 10:16:18 -0500 (Mon, 05 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-5\n * remove occ_major to save a cache miss; however, OCC_INTERVAL has to be\n   increased to keep the same memory. As a result, the speed is a little\n   slower in fact.\n\n------------------------------------------------------------------------\nr746 | lh3 | 2009-01-05 09:50:53 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-4\n * added back optimization codes (it is a pain...)\n\n------------------------------------------------------------------------\nr745 | lh3 | 2009-01-05 08:23:00 -0500 (Mon, 05 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-3\n * faster bit operations\n\n------------------------------------------------------------------------\nr744 | lh3 | 2009-01-05 05:58:46 -0500 (Mon, 05 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-2\n * removed optimization codes again...\n * use a new method to count the bits\n\n------------------------------------------------------------------------\nr743 | lh3 | 2009-01-04 17:18:38 -0500 (Sun, 04 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.3.0-1\n * added back the optimization codes\n * added a new option to aln: max_entries, although this is disabled by default\n * updated benchmark\n\n------------------------------------------------------------------------\nr742 | lh3 | 2009-01-04 07:56:12 -0500 (Sun, 04 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nadd URL\n\n------------------------------------------------------------------------\nr740 | lh3 | 2009-01-04 07:39:43 -0500 (Sun, 04 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.3.0\n\n------------------------------------------------------------------------\nr739 | lh3 | 2009-01-04 06:55:06 -0500 (Sun, 04 Jan 2009) | 2 lines\nChanged paths:\n   A /branches/prog/bwa/COPYING\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/utils.c\n   M /branches/prog/bwa/utils.h\n\nadded licensing information\n\n------------------------------------------------------------------------\nr738 | lh3 | 2009-01-04 06:18:25 -0500 (Sun, 04 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-31\n * better mapping quality\n * update benchmark\n\n------------------------------------------------------------------------\nr737 | lh3 | 2009-01-03 16:00:58 -0500 (Sat, 03 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n\nupdate documentation\n\n------------------------------------------------------------------------\nr736 | lh3 | 2009-01-02 10:26:38 -0500 (Fri, 02 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate documentation\n\n------------------------------------------------------------------------\nr735 | lh3 | 2009-01-02 07:10:20 -0500 (Fri, 02 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-30\n * reduce memory a little bit\n * update documentation\n\n------------------------------------------------------------------------\nr734 | lh3 | 2009-01-01 13:45:45 -0500 (Thu, 01 Jan 2009) | 8 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-29\n * sampe: removed -O option; changed default -o to 100000\n * sampe: fixed a bug in calculating paired mapping quality\n * aln: added an option to search for suboptimal hits even if the best is a repeat.\n   This option will make sampe MUCH SLOWER.\n * sampe: set isize as zero if mapped to two different chr\n * update manual (unfinished)\n\n------------------------------------------------------------------------\nr733 | lh3 | 2009-01-01 11:01:20 -0500 (Thu, 01 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-28\n * fixed a bug in calculating paired mapping quality\n\n------------------------------------------------------------------------\nr732 | lh3 | 2009-01-01 09:27:46 -0500 (Thu, 01 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   A /branches/prog/bwa/khash.h (from /branches/prog/sclib/khash/khash.h:675)\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-27\n * accelerate sampe by storing visited large intervals\n\n------------------------------------------------------------------------\nr731 | lh3 | 2009-01-01 06:51:21 -0500 (Thu, 01 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-26\n * remove the optimation codes\n\n------------------------------------------------------------------------\nr730 | lh3 | 2009-01-01 06:48:59 -0500 (Thu, 01 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-25\n * accelerate OCC calculation by ~7%. However, it seems not worth doing\n   this by complicate the codes. I will change back later.\n\n------------------------------------------------------------------------\nr729 | lh3 | 2008-12-31 16:43:56 -0500 (Wed, 31 Dec 2008) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-24\n * change command \"sai2sam_pe\" to \"sampe\"\n * print usage for sampe command\n * in sampe: change default max_occ to 1000\n * fixed a few compiling warnings in bntseq.c\n\n------------------------------------------------------------------------\nr728 | lh3 | 2008-12-27 07:14:59 -0500 (Sat, 27 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-22\n * mating information can be printed to SAM\n\n------------------------------------------------------------------------\nr727 | lh3 | 2008-12-26 18:10:59 -0500 (Fri, 26 Dec 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-21\n * implement pairing (still UNFINISHED)\n * output all reads even if full of N\n\n------------------------------------------------------------------------\nr726 | lh3 | 2008-12-26 13:31:27 -0500 (Fri, 26 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/bwape.c\n   M /branches/prog/bwa/bwase.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * bwa-0.2.0-20\n * remove \"-t\" from aln cmd\n * code clean up: move some functions in bwt2fmv.c to other source files\n * added sai2sam_pe cmd: *UNFINISHED*\n\n------------------------------------------------------------------------\nr725 | lh3 | 2008-12-26 07:04:11 -0500 (Fri, 26 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/bwase.c\n   A /branches/prog/bwa/bwaseqio.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/kseq.h\n   A /branches/prog/bwa/ksort.h (from /branches/prog/sclib/ksort/ksort.h:712)\n   A /branches/prog/bwa/kvec.h (from /branches/prog/sclib/kvec/kvec.h:537)\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-19\n * considerable code cleanup; no actual changes\n\n------------------------------------------------------------------------\nr724 | lh3 | 2008-12-25 11:32:11 -0500 (Thu, 25 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-18\n * generate SAM output\n\n------------------------------------------------------------------------\nr723 | lh3 | 2008-12-25 10:48:31 -0500 (Thu, 25 Dec 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * bwa-0.2.0-17\n * remove bwtsw2 related codes\n * separate searching for SA interval from generating alignments\n\n------------------------------------------------------------------------\nr722 | lh3 | 2008-12-25 08:57:13 -0500 (Thu, 25 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt2fmv.c\n   D /branches/prog/bwa/bwt_lite.c\n   D /branches/prog/bwa/bwt_lite.h\n   M /branches/prog/bwa/bwtgap.c\n   D /branches/prog/bwa/bwtsw2.h\n   D /branches/prog/bwa/bwtsw2_aux.c\n   D /branches/prog/bwa/bwtsw2_core.c\n   D /branches/prog/bwa/bwtsw2_main.c\n   D /branches/prog/bwa/khash.h\n   D /branches/prog/bwa/ksort.h\n   D /branches/prog/bwa/kvec.h\n   M /branches/prog/bwa/main.c\n\n * added interface to \"aln -t\"\n * remove bwtsw2 related codes\n\n------------------------------------------------------------------------\nr666 | lh3 | 2008-11-18 18:34:29 -0500 (Tue, 18 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-16\n * allow to set max mismatches based on read length, but I do not know\n   whether this really works\n\n------------------------------------------------------------------------\nr665 | lh3 | 2008-11-18 08:34:03 -0500 (Tue, 18 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-15\n * fixed a bug in sequence parser.\n\n------------------------------------------------------------------------\nr612 | lh3 | 2008-10-28 06:50:53 -0400 (Tue, 28 Oct 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/utils.c\n\n * bwa-0.2.0-14\n * fixed a bug caused by the change of the FASTA/Q parser\n\n------------------------------------------------------------------------\nr611 | lh3 | 2008-10-28 06:24:56 -0400 (Tue, 28 Oct 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   A /branches/prog/bwa/kseq.h\n   D /branches/prog/bwa/seq.c\n   D /branches/prog/bwa/seq.h\n   M /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/utils.c\n   M /branches/prog/bwa/utils.h\n\nreplace seq.* with kseq.h\n\n------------------------------------------------------------------------\nr610 | lh3 | 2008-10-27 13:00:04 -0400 (Mon, 27 Oct 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-13\n * make bwtsw2 output sub-optimal hits. not completed\n\n------------------------------------------------------------------------\nr609 | lh3 | 2008-10-24 16:52:00 -0400 (Fri, 24 Oct 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/kvec.h\n\nlittle...\n\n------------------------------------------------------------------------\nr532 | lh3 | 2008-09-19 05:28:45 -0400 (Fri, 19 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/khash.h\n\nimprove interface of khash\n\n------------------------------------------------------------------------\nr531 | lh3 | 2008-09-18 06:52:59 -0400 (Thu, 18 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nimprove minor things, which make bwtsw2 slower, but should miss less true hits\n\n------------------------------------------------------------------------\nr530 | lh3 | 2008-09-17 18:19:26 -0400 (Wed, 17 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * fixed a bug in calculating ->D\n * enforce band-width checking\n\n------------------------------------------------------------------------\nr529 | lh3 | 2008-09-17 18:06:49 -0400 (Wed, 17 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\ndelete a line of code that is never visited\n\n------------------------------------------------------------------------\nr528 | lh3 | 2008-09-17 17:58:51 -0400 (Wed, 17 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\na bit code clean up\n\n------------------------------------------------------------------------\nr527 | lh3 | 2008-09-17 10:55:45 -0400 (Wed, 17 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-12\n * max-depth can be set, although it does not help the speed at all\n\n------------------------------------------------------------------------\nr526 | lh3 | 2008-09-16 17:59:36 -0400 (Tue, 16 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\ncut_tail after remove duplicate\n\n------------------------------------------------------------------------\nr525 | lh3 | 2008-09-16 17:56:11 -0400 (Tue, 16 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/khash.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-11\n * improved cut_tail()\n\n------------------------------------------------------------------------\nr524 | lh3 | 2008-09-15 16:53:22 -0400 (Mon, 15 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-10\n * fixed a bug in cut_tail()\n\n------------------------------------------------------------------------\nr518 | lh3 | 2008-09-15 04:35:59 -0400 (Mon, 15 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\na bit code clean up\n\n------------------------------------------------------------------------\nr517 | lh3 | 2008-09-14 18:18:11 -0400 (Sun, 14 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nimprove speed (<1%)\n\n------------------------------------------------------------------------\nr516 | lh3 | 2008-09-14 18:08:55 -0400 (Sun, 14 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * fixed two potential bugs, although I have not seen their effects\n * improve speed a bit (<2%)\n\n------------------------------------------------------------------------\nr515 | lh3 | 2008-09-14 17:26:49 -0400 (Sun, 14 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n\nnothing, really\n\n------------------------------------------------------------------------\nr514 | lh3 | 2008-09-14 17:10:13 -0400 (Sun, 14 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\ndisable X-drop, which has to be reimplemented in the current algorithm\n\n------------------------------------------------------------------------\nr513 | lh3 | 2008-09-14 16:49:42 -0400 (Sun, 14 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt_lite.c\n   M /branches/prog/bwa/bwt_lite.h\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n\n * temporarily disable cut_tail()\n * calculate SA in bwt_lite.c\n * fixed a bug in reversing the sequence\n\n------------------------------------------------------------------------\nr512 | lh3 | 2008-09-13 17:35:40 -0400 (Sat, 13 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   A /branches/prog/bwa/ksort.h\n\nn-best method\n\n------------------------------------------------------------------------\nr507 | lh3 | 2008-09-13 09:06:54 -0400 (Sat, 13 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_core.c\n\ngive correct result again\n\n------------------------------------------------------------------------\nr506 | lh3 | 2008-09-13 08:12:07 -0400 (Sat, 13 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nI think I know the reason. It needs more work...\n\n------------------------------------------------------------------------\nr505 | lh3 | 2008-09-13 06:20:43 -0400 (Sat, 13 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_core.c\n\nfixed another bug, but still have\n\n------------------------------------------------------------------------\nr504 | lh3 | 2008-09-12 18:13:37 -0400 (Fri, 12 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nfixed another bug\n\n------------------------------------------------------------------------\nr503 | lh3 | 2008-09-12 17:15:56 -0400 (Fri, 12 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/khash.h\n\n * do not segfault, but the result is WRONG!\n * prepare to remove bsw2_connectivity_check()\n\n------------------------------------------------------------------------\nr502 | lh3 | 2008-09-12 15:52:41 -0400 (Fri, 12 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/kvec.h\n\nmore revisions\n\n------------------------------------------------------------------------\nr501 | lh3 | 2008-09-11 18:06:15 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nfurther simply codes with kvec.h\n\n------------------------------------------------------------------------\nr500 | lh3 | 2008-09-11 17:42:15 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\npart of revisions... have not finished\n\n------------------------------------------------------------------------\nr499 | lh3 | 2008-09-11 17:24:15 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/khash.h\n   A /branches/prog/bwa/kvec.h\n\nprepare for abrupt change\n\n------------------------------------------------------------------------\nr496 | lh3 | 2008-09-11 10:34:38 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nfixed a bug; now \"bwtsw2 -d\" is useless\n\n------------------------------------------------------------------------\nr495 | lh3 | 2008-09-11 09:22:03 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\nimprove speed a little bit\n\n------------------------------------------------------------------------\nr494 | lh3 | 2008-09-11 08:28:08 -0400 (Thu, 11 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nremove debug codes\n\n------------------------------------------------------------------------\nr493 | lh3 | 2008-09-11 07:49:53 -0400 (Thu, 11 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * improve the speed a little bit (<5%)\n * prepare to remove BSW_DEBUG\n\n------------------------------------------------------------------------\nr492 | lh3 | 2008-09-11 06:15:56 -0400 (Thu, 11 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-9\n * support reverse strand\n * fixed a bug that causes missing hits\n\n------------------------------------------------------------------------\nr491 | lh3 | 2008-09-11 05:46:16 -0400 (Thu, 11 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-8\n * better progress report\n\n------------------------------------------------------------------------\nr490 | lh3 | 2008-09-10 17:04:49 -0400 (Wed, 10 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-7\n * avoid some missing hits\n * add maximum depth\n\n------------------------------------------------------------------------\nr489 | lh3 | 2008-09-10 11:51:13 -0400 (Wed, 10 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-6\n * bwtsw2 works although on the forward strand only for now\n * better progress information\n\n------------------------------------------------------------------------\nr488 | lh3 | 2008-09-10 10:21:53 -0400 (Wed, 10 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * implement memory pool\n * avoid some rehashing\n\n------------------------------------------------------------------------\nr487 | lh3 | 2008-09-10 09:23:38 -0400 (Wed, 10 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_main.c\n\n * fixed a memory leak\n * prepare to implement mempool\n\n------------------------------------------------------------------------\nr486 | lh3 | 2008-09-10 09:10:09 -0400 (Wed, 10 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/khash.h\n\n * add X-dropoff\n * remove duplicated results\n * switch to simple stack\n\n------------------------------------------------------------------------\nr485 | lh3 | 2008-09-10 06:31:20 -0400 (Wed, 10 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n\n * check whether t-node has been visited\n * prepare to remove two-level stack\n\n------------------------------------------------------------------------\nr484 | lh3 | 2008-09-10 05:00:57 -0400 (Wed, 10 Sep 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bwa/khash.h\n\nkhash library\n\n------------------------------------------------------------------------\nr483 | lh3 | 2008-09-10 04:22:53 -0400 (Wed, 10 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nadd inline\n\n------------------------------------------------------------------------\nr482 | lh3 | 2008-09-09 16:34:57 -0400 (Tue, 09 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n\nimprove speed\n\n------------------------------------------------------------------------\nr481 | lh3 | 2008-09-09 13:13:00 -0400 (Tue, 09 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2_core.c\n\nUse a 128bit hash table to keep all (tk,tl,qk,ql). This is slow. Just\nkeep a copy in case I may need this in future.\n\n\n------------------------------------------------------------------------\nr480 | lh3 | 2008-09-09 12:53:32 -0400 (Tue, 09 Sep 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * no principal modification\n\n------------------------------------------------------------------------\nr479 | lh3 | 2008-09-09 11:01:45 -0400 (Tue, 09 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2_core.c\n\n * fixed a bug which may cause duplicated matching\n * accelerate the speed a bit, although using hash in avoiding duplications\n   slows the speed down in the end\n\n------------------------------------------------------------------------\nr474 | lh3 | 2008-09-03 17:22:57 -0400 (Wed, 03 Sep 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtsw2.h\n   M /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-5\n * indel seems to work on toy example\n * add band\n\n------------------------------------------------------------------------\nr469 | lh3 | 2008-09-01 09:18:45 -0400 (Mon, 01 Sep 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt_lite.c\n   M /branches/prog/bwa/bwt_lite.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtsw2.h\n   A /branches/prog/bwa/bwtsw2_aux.c\n   M /branches/prog/bwa/bwtsw2_core.c\n   M /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/is.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/simple_dp.c\n\n * bwa-0.2.0-4\n * updated bwtsw2, which seems to work properly on toy examples\n\n------------------------------------------------------------------------\nr447 | lh3 | 2008-08-27 10:05:09 -0400 (Wed, 27 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-3\n * tune for longer gaps, but it does not really work with kilo-bp gaps...\n\n------------------------------------------------------------------------\nr446 | lh3 | 2008-08-26 13:30:41 -0400 (Tue, 26 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-2\n * changed the way to extend long deletions. Now use max_del_occ.\n\n------------------------------------------------------------------------\nr445 | lh3 | 2008-08-26 13:05:58 -0400 (Tue, 26 Aug 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt_lite.c\n   M /branches/prog/bwa/bwt_lite.h\n\nupdated from bwtsw2_lite\n\n------------------------------------------------------------------------\nr436 | lh3 | 2008-08-23 12:28:44 -0400 (Sat, 23 Aug 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.h\n   A /branches/prog/bwa/bwt_lite.c\n   A /branches/prog/bwa/bwt_lite.h\n   A /branches/prog/bwa/bwtsw2.h\n   A /branches/prog/bwa/bwtsw2_core.c\n   A /branches/prog/bwa/bwtsw2_main.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.2.0-1\n * add bwt_lite: a light-weighted version of bwt (NOT TESTED!)\n * add core codes for bwtsw2: NOT TESTED!!!\n\n------------------------------------------------------------------------\nr427 | lh3 | 2008-08-15 05:38:12 -0400 (Fri, 15 Aug 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.2.0\n\n------------------------------------------------------------------------\nr426 | lh3 | 2008-08-14 11:26:19 -0400 (Thu, 14 Aug 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.6-7\n * change default seed length to 31\n * add incomplete support to color sequences (not tested yet!)\n\n------------------------------------------------------------------------\nr425 | lh3 | 2008-08-14 06:23:11 -0400 (Thu, 14 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.6-6\n * change default seed length to 33bp\n\n------------------------------------------------------------------------\nr424 | lh3 | 2008-08-14 05:55:33 -0400 (Thu, 14 Aug 2008) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.6-5\n * fixed a bug that may miss true alignments. this bugs exists in most\n   early versions.\n * fixed a bug that yields wrong coordinates for reads mapped on the forward\n   strands with gaps.\n\n------------------------------------------------------------------------\nr423 | lh3 | 2008-08-14 04:07:28 -0400 (Thu, 14 Aug 2008) | 2 lines\nChanged paths:\n   D /branches/prog/bwa/Makefile.div\n\nuseless\n\n------------------------------------------------------------------------\nr422 | lh3 | 2008-08-13 19:21:14 -0400 (Wed, 13 Aug 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.6-4\n * fixed one bug\n * there is another one...\n\n------------------------------------------------------------------------\nr421 | lh3 | 2008-08-13 18:23:33 -0400 (Wed, 13 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.6-3\n * almost there, but not quite right\n\n------------------------------------------------------------------------\nr419 | lh3 | 2008-08-13 17:27:02 -0400 (Wed, 13 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * improve the seeding method\n * prepare to load two BWTs into memory. A BIG change!\n\n------------------------------------------------------------------------\nr418 | lh3 | 2008-08-13 10:56:54 -0400 (Wed, 13 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * added seeding\n * unfinished yet\n\n------------------------------------------------------------------------\nr413 | lh3 | 2008-08-08 11:48:35 -0400 (Fri, 08 Aug 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.6\n\n------------------------------------------------------------------------\nr410 | lh3 | 2008-08-06 15:48:22 -0400 (Wed, 06 Aug 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/simple_dp.c\n\nsw: output alignment score\n\n------------------------------------------------------------------------\nr407 | lh3 | 2008-08-04 10:01:20 -0400 (Mon, 04 Aug 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   A /branches/prog/bwa/simple_dp.c\n   M /branches/prog/bwa/stdaln.c\n   M /branches/prog/bwa/stdaln.h\n\n * bwa-0.1.5-3\n * added a simple interface to SW/NW alignment\n * stdaln-0.9.8 (see header for more details)\n\n------------------------------------------------------------------------\nr406 | lh3 | 2008-08-01 19:21:59 -0400 (Fri, 01 Aug 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   A /branches/prog/bwa/stdaln.c\n   A /branches/prog/bwa/stdaln.h\n\n * bwa-0.1.5-2\n * give accurate gap positions\n\n------------------------------------------------------------------------\nr405 | lh3 | 2008-08-01 19:06:19 -0400 (Fri, 01 Aug 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n\nunfinished, but I am tired...\n\n------------------------------------------------------------------------\nr401 | lh3 | 2008-07-30 05:59:24 -0400 (Wed, 30 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.5-1\n * fixed a potential bug which may produce an alignment in N regions,\n   although extremely rare.\n\n------------------------------------------------------------------------\nr399 | lh3 | 2008-07-27 11:41:52 -0400 (Sun, 27 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.5\n\n------------------------------------------------------------------------\nr398 | lh3 | 2008-07-25 12:14:47 -0400 (Fri, 25 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate documentation\n\n------------------------------------------------------------------------\nr397 | lh3 | 2008-07-25 09:58:56 -0400 (Fri, 25 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * \n\n------------------------------------------------------------------------\nr396 | lh3 | 2008-07-25 06:42:01 -0400 (Fri, 25 Jul 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.4-4\n * add timer for debugging\n\n------------------------------------------------------------------------\nr395 | lh3 | 2008-07-24 05:46:21 -0400 (Thu, 24 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.4-3\n * fixed a bug in the previous code\n * this version gives identical result to bwa-0.1.4, just 10% faster\n\n------------------------------------------------------------------------\nr394 | lh3 | 2008-07-24 05:18:53 -0400 (Thu, 24 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.4-2\n * further improve the speed\n * The result is slightly different from bwa-0.1.4 now. I need to check...\n\n------------------------------------------------------------------------\nr393 | lh3 | 2008-07-23 12:04:16 -0400 (Wed, 23 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n\ncomments only\n\n------------------------------------------------------------------------\nr392 | lh3 | 2008-07-23 10:34:03 -0400 (Wed, 23 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\nfurther improve the speed in Occ functions\n\n------------------------------------------------------------------------\nr386 | lh3 | 2008-07-22 10:03:54 -0400 (Tue, 22 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.4\n\n------------------------------------------------------------------------\nr385 | lh3 | 2008-07-22 09:44:50 -0400 (Tue, 22 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n\nupdate documentation and ChangeLog\n\n------------------------------------------------------------------------\nr384 | lh3 | 2008-07-22 08:50:03 -0400 (Tue, 22 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.3-2\n * fixed the bug in the last modification\n * now the alignment should be more clearly defined\n\n------------------------------------------------------------------------\nr383 | lh3 | 2008-07-21 18:32:21 -0400 (Mon, 21 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.3-1\n * this is a buggy verion!\n * i will fix the bug tomorrow. It is late...\n\n------------------------------------------------------------------------\nr381 | lh3 | 2008-07-21 06:45:32 -0400 (Mon, 21 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.3\n\n------------------------------------------------------------------------\nr380 | lh3 | 2008-07-21 06:07:43 -0400 (Mon, 21 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.2-3\n * improve the speed for gcc on Intel Mac OS X, but not really on icc on Linux\n * aln: more command-line options\n\n------------------------------------------------------------------------\nr373 | lh3 | 2008-07-17 09:09:46 -0400 (Thu, 17 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.2-2\n * further improve the speed\n * this version gives exactly the same result as bwa-0.1.2\n\n------------------------------------------------------------------------\nr372 | lh3 | 2008-07-17 07:51:08 -0400 (Thu, 17 Jul 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.2-1\n * speed up by about 5%\n\n------------------------------------------------------------------------\nr370 | lh3 | 2008-07-17 05:12:00 -0400 (Thu, 17 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.2\n\n------------------------------------------------------------------------\nr368 | lh3 | 2008-07-16 08:51:25 -0400 (Wed, 16 Jul 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   D /branches/prog/bwa/bwt1away.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   D /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-9\n * some code cleanup\n * remove 1away and top2\n\n------------------------------------------------------------------------\nr367 | lh3 | 2008-07-16 08:24:34 -0400 (Wed, 16 Jul 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/is.c\n\nYuta Mori's implementation of IS algorithm.\n\n------------------------------------------------------------------------\nr365 | lh3 | 2008-07-16 06:58:04 -0400 (Wed, 16 Jul 2008) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-8\n * improve gapped alignment\n * this version will miss more gapped alignments, but the speed is much faster\n * prepare to remove top2 and 1away algorithms\n * prepare to add SAIS algorithm for bwt construction\n\n------------------------------------------------------------------------\nr358 | lh3 | 2008-06-09 06:03:04 -0400 (Mon, 09 Jun 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-7\n * change END_SKIP from 3 to 5, but still gaps may be wrongly added\n * change default '-g' from 5 to 3\n\n------------------------------------------------------------------------\nr357 | lh3 | 2008-06-09 05:18:36 -0400 (Mon, 09 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-6\n * fix a bug in nested stack\n\n------------------------------------------------------------------------\nr356 | lh3 | 2008-06-08 18:43:13 -0400 (Sun, 08 Jun 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   A /branches/prog/bwa/bwtgap.h\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-5\n * replace heap with nested stacks\n * there are still obvious bugs...\n\n------------------------------------------------------------------------\nr355 | lh3 | 2008-06-08 17:13:44 -0400 (Sun, 08 Jun 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * bwa-0.1.1-4\n * add interface to affine gap alignment\n * there are obvious bugs and I will fix them later\n\n------------------------------------------------------------------------\nr354 | lh3 | 2008-06-08 15:39:05 -0400 (Sun, 08 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-3\n * affine gap seems to work, at least partially\n\n------------------------------------------------------------------------\nr353 | lh3 | 2008-06-08 09:27:18 -0400 (Sun, 08 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   A /branches/prog/bwa/bwtgap.c\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-2\n * initial gapped alignment. not work at the moment\n\n------------------------------------------------------------------------\nr352 | lh3 | 2008-06-06 04:37:34 -0400 (Fri, 06 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.1-1\n * ungap: remove a useless varible in top2_entry_t\n\n------------------------------------------------------------------------\nr348 | lh3 | 2008-06-03 09:04:12 -0400 (Tue, 03 Jun 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/ChangeLog\n   A /branches/prog/bwa/NEWS\n   M /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/main.c\n\nRelease bwa-0.1.1\n\n------------------------------------------------------------------------\nr347 | lh3 | 2008-06-03 05:45:08 -0400 (Tue, 03 Jun 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwa.1\n\nupdate documentation\n\n------------------------------------------------------------------------\nr346 | lh3 | 2008-06-02 18:59:50 -0400 (Mon, 02 Jun 2008) | 5 lines\nChanged paths:\n   A /branches/prog/bwa/ChangeLog\n   A /branches/prog/bwa/bwa.1\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-11\n * improve approximating mapping qualities\n * add documentation\n * add ChangeLog\n\n------------------------------------------------------------------------\nr345 | lh3 | 2008-06-02 16:04:39 -0400 (Mon, 02 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-10\n * output a random position for repetitive reads\n\n------------------------------------------------------------------------\nr344 | lh3 | 2008-06-02 15:03:54 -0400 (Mon, 02 Jun 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/pac2bwt.c\n\n * bwa-0.1.0-9\n * fix memory leaks\n * fix a potential bug in coverting to the real coordinate\n\n------------------------------------------------------------------------\nr343 | lh3 | 2008-06-02 13:44:51 -0400 (Mon, 02 Jun 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile.div\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-8\n * fix a bug about strand\n * update Makefile.div\n * change top2b as the default method\n\n------------------------------------------------------------------------\nr342 | lh3 | 2008-06-02 11:23:26 -0400 (Mon, 02 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt1away.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-7\n * use bwt_2occ() and bwt_2occ4() in other functions\n\n------------------------------------------------------------------------\nr341 | lh3 | 2008-06-02 09:31:39 -0400 (Mon, 02 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-6\n * fix a bug for missing hits\n\n------------------------------------------------------------------------\nr340 | lh3 | 2008-06-02 09:10:18 -0400 (Mon, 02 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-5\n * accelerate comparisons in heap, a bit\n\n------------------------------------------------------------------------\nr339 | lh3 | 2008-06-02 08:41:31 -0400 (Mon, 02 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-4\n * avoid marginal repeated calculation in occ\n\n------------------------------------------------------------------------\nr338 | lh3 | 2008-06-02 06:46:51 -0400 (Mon, 02 Jun 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-3\n * fix a bug caused by previours change\n * fix a bug in heap\n * order the heap by more criteria\n\n------------------------------------------------------------------------\nr337 | lh3 | 2008-06-01 19:11:15 -0400 (Sun, 01 Jun 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n\n * bwa-0.1.0-2\n * also sort sa range in heapsort, in attempt to improve cache performance.\n   Unfortunately, it does not work well at all.\n\n------------------------------------------------------------------------\nr336 | lh3 | 2008-06-01 17:45:23 -0400 (Sun, 01 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/Makefile.div\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/main.c\n\n * 0.1.0-1\n * fix a bug in calculating the real coordinate\n\n------------------------------------------------------------------------\nr335 | lh3 | 2008-06-01 16:03:09 -0400 (Sun, 01 Jun 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n\nnothing, really\n\n------------------------------------------------------------------------\nr334 | lh3 | 2008-06-01 15:59:13 -0400 (Sun, 01 Jun 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/Makefile.div\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/pac2bwt.c\n\nuse IS algorithm by default\n\n------------------------------------------------------------------------\nr333 | lh3 | 2008-06-01 15:05:15 -0400 (Sun, 01 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/is.c\n   M /branches/prog/bwa/pac2bwt.c\n\n * a bit code clean up in is.c\n * add IS algorithm for constructing BWT, albeit slower\n\n------------------------------------------------------------------------\nr332 | lh3 | 2008-06-01 13:23:08 -0400 (Sun, 01 Jun 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bwa/is.c\n\nIS linear-time algorithm for constructing SA/BWT\n\n------------------------------------------------------------------------\nr331 | lh3 | 2008-06-01 10:35:26 -0400 (Sun, 01 Jun 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bntseq.c\n   A /branches/prog/bwa/bwtindex.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * fix a bug in generating .pac\n * index in one go\n\n------------------------------------------------------------------------\nr330 | lh3 | 2008-06-01 09:17:05 -0400 (Sun, 01 Jun 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwttop2.c\n\nreal coordinates can be ouput\n\n------------------------------------------------------------------------\nr329 | lh3 | 2008-05-31 19:21:02 -0400 (Sat, 31 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwttop2.c\n\nadd top2e which is similar to 1away\n\n------------------------------------------------------------------------\nr328 | lh3 | 2008-05-31 18:46:12 -0400 (Sat, 31 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwttop2.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * unified cmd-line interface for ungapped alignment\n * add two alternatives to top2 algorithm\n\n------------------------------------------------------------------------\nr327 | lh3 | 2008-05-31 18:14:46 -0400 (Sat, 31 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\nadd cmd-line interface to alntop2\n\n------------------------------------------------------------------------\nr326 | lh3 | 2008-05-31 17:59:31 -0400 (Sat, 31 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt1away.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   A /branches/prog/bwa/bwttop2.c\n\ntop2 algorithm seems to work. I need to change interface, though\n\n------------------------------------------------------------------------\nr325 | lh3 | 2008-05-31 15:11:49 -0400 (Sat, 31 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt1away.c\n\nchange the variable in the structure\n\n------------------------------------------------------------------------\nr324 | lh3 | 2008-05-31 14:52:13 -0400 (Sat, 31 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt1away.c\n\nset a slightly better bound on the maximum allowed mismatches\n\n------------------------------------------------------------------------\nr323 | lh3 | 2008-05-30 18:40:21 -0400 (Fri, 30 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n\n * output time statistics\n\n------------------------------------------------------------------------\nr322 | lh3 | 2008-05-30 17:58:25 -0400 (Fri, 30 May 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   A /branches/prog/bwa/bwt1away.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n\n * presumably better way to make use of prefix. But for the moment I do\n   not know whether it is correct or not.\n * a bit code clean up: separate alignment part\n\n------------------------------------------------------------------------\nr321 | lh3 | 2008-05-30 13:57:43 -0400 (Fri, 30 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt_gen/Makefile\n   M /branches/prog/bwa/bwt_gen/bwt_gen.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/pac2bwt.c\n\n * a bit code clean up\n * put bwt_gen in bwa\n\n------------------------------------------------------------------------\nr320 | lh3 | 2008-05-30 11:40:11 -0400 (Fri, 30 May 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtio.c\n\n * improve cmd-line interface\n * fix a bug in loading .sa\n * change default sa interval to 32\n\n------------------------------------------------------------------------\nr319 | lh3 | 2008-05-30 10:31:37 -0400 (Fri, 30 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwtaln.c\n\n * fix memory leak (I know that. Just a bit lazy)\n * change to another method to do 1-away alignment\n\n------------------------------------------------------------------------\nr318 | lh3 | 2008-05-30 09:21:49 -0400 (Fri, 30 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\nbest unique match is partially finished\n\n------------------------------------------------------------------------\nr317 | lh3 | 2008-05-30 06:33:28 -0400 (Fri, 30 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\nremove \"ungapped\" command and related codes\n\n------------------------------------------------------------------------\nr316 | lh3 | 2008-05-30 06:05:20 -0400 (Fri, 30 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n\nchange variable name thick to width\n\n------------------------------------------------------------------------\nr315 | lh3 | 2008-05-29 19:06:13 -0400 (Thu, 29 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/pac2bwt.c\n\nrevised algorithm for ungapped alignment. the old one can still be used.\n\n------------------------------------------------------------------------\nr314 | lh3 | 2008-05-29 16:36:11 -0400 (Thu, 29 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwt_gen/bwt_gen.c\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/pac2bwt.c\n\n * make commands more independent, but ungapped does not work at the moment\n\n------------------------------------------------------------------------\nr313 | lh3 | 2008-05-29 15:56:14 -0400 (Thu, 29 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt_gen/bwt_gen.c\n\nlittle...\n\n------------------------------------------------------------------------\nr312 | lh3 | 2008-05-29 15:54:01 -0400 (Thu, 29 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt_gen/bwt_gen.c\n   M /branches/prog/bwa/bwt_gen/bwt_gen.h\n\n * add CopyRight information from the original codes\n * do not dump .fmv files\n\n------------------------------------------------------------------------\nr311 | lh3 | 2008-05-29 15:44:36 -0400 (Thu, 29 May 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bwa/bwt_gen\n   A /branches/prog/bwa/bwt_gen/Makefile\n   A /branches/prog/bwa/bwt_gen/QSufSort.c\n   A /branches/prog/bwa/bwt_gen/QSufSort.h\n   A /branches/prog/bwa/bwt_gen/bwt_gen.c\n   A /branches/prog/bwa/bwt_gen/bwt_gen.h\n\ncodes from BWT-SW, for building BWT from packed file\n\n------------------------------------------------------------------------\nr310 | lh3 | 2008-05-28 17:03:35 -0400 (Wed, 28 May 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * change OCC_INTERVAL to 0x40, which makes bwa twice as fast.\n * write Occ file as \".occ\" as it is using a different interval from\n   .fmv, the BWT-SW correspondance of .occ\n\n------------------------------------------------------------------------\nr309 | lh3 | 2008-05-28 11:39:37 -0400 (Wed, 28 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n\nfix a bug\n\n------------------------------------------------------------------------\nr308 | lh3 | 2008-05-28 09:56:16 -0400 (Wed, 28 May 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n\nadd heuristics to improve the speed, but I have not tested whether the\nresults are correct or not.\n\n\n------------------------------------------------------------------------\nr307 | lh3 | 2008-05-28 06:31:34 -0400 (Wed, 28 May 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/bwtaln.c\n   M /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * make ungapped alignment basically works...\n * but it is very slow in comparison to others...\n * also I need to improve the interface...\n * a lot of things to keep me busy today...\n\n------------------------------------------------------------------------\nr306 | lh3 | 2008-05-27 18:41:27 -0400 (Tue, 27 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwtaln.c\n\n * remove recursion\n * fixed a bug in bwt_occ()\n\n------------------------------------------------------------------------\nr305 | lh3 | 2008-05-27 16:59:44 -0400 (Tue, 27 May 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwtaln.c\n\n * bwa now tells whether a sequenced can be mapped with maximum allowed\n   mismatches. ONLY ungapped.\n * this is a recursive version. I will remove recursion later.\n\n\n------------------------------------------------------------------------\nr304 | lh3 | 2008-05-27 09:12:17 -0400 (Tue, 27 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   A /branches/prog/bwa/bwtaln.c\n   A /branches/prog/bwa/bwtaln.h\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/utils.c\n\n * load .sa and .fmv files\n * exact alignment now works\n\n------------------------------------------------------------------------\nr303 | lh3 | 2008-05-27 06:33:38 -0400 (Tue, 27 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/utils.c\n   M /branches/prog/bwa/utils.h\n\nadd xassert and fix a bug\n\n------------------------------------------------------------------------\nr302 | lh3 | 2008-05-27 06:23:20 -0400 (Tue, 27 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwtio.c\n   A /branches/prog/bwa/utils.c\n   A /branches/prog/bwa/utils.h\n\nimprove error message and error handling\n\n------------------------------------------------------------------------\nr301 | lh3 | 2008-05-27 05:37:51 -0400 (Tue, 27 May 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n   A /branches/prog/bwa/bwtio.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n\n * move I/O codes to bwtio.c\n * SA can be dumped and interestingly, it is identical to BWTSW\n * now, .fmv is still different from BWTSW\n\n------------------------------------------------------------------------\nr299 | lh3 | 2008-05-26 18:07:44 -0400 (Mon, 26 May 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n\ngenerate/retrieve SA and Occ\n\n------------------------------------------------------------------------\nr298 | lh3 | 2008-05-26 13:16:49 -0400 (Mon, 26 May 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/bwt.c\n   M /branches/prog/bwa/bwt.h\n   M /branches/prog/bwa/bwt2fmv.c\n\n * retrieve occ value at any position\n * move bwt_cal_occ() to bwt.c\n\n------------------------------------------------------------------------\nr297 | lh3 | 2008-05-25 17:43:58 -0400 (Sun, 25 May 2008) | 6 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   A /branches/prog/bwa/bwt.c\n   A /branches/prog/bwa/bwt.h\n   A /branches/prog/bwa/bwt2fmv.c\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   M /branches/prog/bwa/pac2bwt.c\n\n * add bwt2fmv. It works to some extend. However, I do not understand\n   the purpose of some weird codes in BWT-SW. As a consequence, bwt2fmv\n   could generate a file almost identical, but not exactly identical, to\n   the .fmv file from BWT-SW.\n\n\n------------------------------------------------------------------------\nr296 | lh3 | 2008-05-24 18:35:02 -0400 (Sat, 24 May 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bntseq.c\n   M /branches/prog/bwa/bntseq.h\n   M /branches/prog/bwa/main.c\n   M /branches/prog/bwa/main.h\n   A /branches/prog/bwa/pac2bwt.c\n\nBurrows-Wheeler Transform now works. At least on one example, the\ncurrent code generates the same BWT as BWT-SW. Kind of magical, I would\nsay. :)\n\n\n------------------------------------------------------------------------\nr295 | lh3 | 2008-05-24 11:25:31 -0400 (Sat, 24 May 2008) | 3 lines\nChanged paths:\n   A /branches/prog/bwa/Makefile\n   M /branches/prog/bwa/bntseq.c\n   A /branches/prog/bwa/main.c\n   A /branches/prog/bwa/main.h\n\n * add Makefile and main.*\n * improve interface to fa2bns, a bit\n\n------------------------------------------------------------------------\nr293 | lh3 | 2008-05-24 10:57:03 -0400 (Sat, 24 May 2008) | 3 lines\nChanged paths:\n   A /branches/prog/bwa\n   A /branches/prog/bwa/bntseq.c\n   A /branches/prog/bwa/bntseq.h\n   A /branches/prog/bwa/seq.c\n   A /branches/prog/bwa/seq.h\n\n * Burrow-Wheeler Alignment\n * initial codes\n\n------------------------------------------------------------------------\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.208984375,
          "content": "CC=\t\t\tgcc\n#CC=\t\t\tclang --analyze\nCFLAGS=\t\t-g -Wall -Wno-unused-function -O2\nWRAP_MALLOC=-DUSE_MALLOC_WRAPPERS\nAR=\t\t\tar\nDFLAGS=\t\t-DHAVE_PTHREAD $(WRAP_MALLOC)\nLOBJS=\t\tutils.o kthread.o kstring.o ksw.o bwt.o bntseq.o bwa.o bwamem.o bwamem_pair.o bwamem_extra.o malloc_wrap.o \\\n\t\t\tQSufSort.o bwt_gen.o rope.o rle.o is.o bwtindex.o\nAOBJS=\t\tbwashm.o bwase.o bwaseqio.o bwtgap.o bwtaln.o bamlite.o \\\n\t\t\tbwape.o kopen.o pemerge.o maxk.o \\\n\t\t\tbwtsw2_core.o bwtsw2_main.o bwtsw2_aux.o bwt_lite.o \\\n\t\t\tbwtsw2_chain.o fastmap.o bwtsw2_pair.o\nPROG=\t\tbwa\nINCLUDES=\t\nLIBS=\t\t-lm -lz -lpthread\nSUBDIRS=\t.\n\nifeq ($(shell uname -s),Linux)\n\tLIBS += -lrt\nendif\n\n.SUFFIXES:.c .o .cc\n\n.c.o:\n\t\t$(CC) -c $(CFLAGS) $(DFLAGS) $(INCLUDES) $(CPPFLAGS) $< -o $@\n\nall:$(PROG)\n\nbwa:libbwa.a $(AOBJS) main.o\n\t\t$(CC) $(CFLAGS) $(LDFLAGS) $(AOBJS) main.o -o $@ -L. -lbwa $(LIBS)\n\nbwamem-lite:libbwa.a example.o\n\t\t$(CC) $(CFLAGS) $(LDFLAGS) example.o -o $@ -L. -lbwa $(LIBS)\n\nlibbwa.a:$(LOBJS)\n\t\t$(AR) -csru $@ $(LOBJS)\n\nclean:\n\t\trm -f gmon.out *.o a.out $(PROG) *~ *.a\n\ndepend:\n\t( LC_ALL=C ; export LC_ALL; makedepend -Y -- $(CFLAGS) $(DFLAGS) $(CPPFLAGS) -- *.c )\n\n# DO NOT DELETE THIS LINE -- make depend depends on it.\n\nQSufSort.o: QSufSort.h\nbamlite.o: bamlite.h malloc_wrap.h\nbntseq.o: bntseq.h utils.h kseq.h malloc_wrap.h khash.h\nbwa.o: bntseq.h bwa.h bwt.h ksw.h utils.h kstring.h malloc_wrap.h kvec.h\nbwa.o: kseq.h\nbwamem.o: kstring.h malloc_wrap.h bwamem.h bwt.h bntseq.h bwa.h ksw.h kvec.h\nbwamem.o: ksort.h utils.h kbtree.h\nbwamem_extra.o: bwa.h bntseq.h bwt.h bwamem.h kstring.h malloc_wrap.h\nbwamem_pair.o: kstring.h malloc_wrap.h bwamem.h bwt.h bntseq.h bwa.h kvec.h\nbwamem_pair.o: utils.h ksw.h\nbwape.o: bwtaln.h bwt.h kvec.h malloc_wrap.h bntseq.h utils.h bwase.h bwa.h\nbwape.o: ksw.h khash.h\nbwase.o: bwase.h bntseq.h bwt.h bwtaln.h utils.h kstring.h malloc_wrap.h\nbwase.o: bwa.h ksw.h\nbwaseqio.o: bwtaln.h bwt.h utils.h bamlite.h malloc_wrap.h kseq.h\nbwashm.o: bwa.h bntseq.h bwt.h\nbwt.o: utils.h bwt.h kvec.h malloc_wrap.h\nbwt_gen.o: QSufSort.h malloc_wrap.h\nbwt_lite.o: bwt_lite.h malloc_wrap.h\nbwtaln.o: bwtaln.h bwt.h bwtgap.h utils.h bwa.h bntseq.h malloc_wrap.h\nbwtgap.o: bwtgap.h bwt.h bwtaln.h malloc_wrap.h\nbwtindex.o: bntseq.h bwa.h bwt.h utils.h rle.h rope.h malloc_wrap.h\nbwtsw2_aux.o: bntseq.h bwt_lite.h utils.h bwtsw2.h bwt.h kstring.h\nbwtsw2_aux.o: malloc_wrap.h bwa.h ksw.h kseq.h ksort.h\nbwtsw2_chain.o: bwtsw2.h bntseq.h bwt_lite.h bwt.h malloc_wrap.h ksort.h\nbwtsw2_core.o: bwt_lite.h bwtsw2.h bntseq.h bwt.h kvec.h malloc_wrap.h\nbwtsw2_core.o: khash.h ksort.h\nbwtsw2_main.o: bwt.h bwtsw2.h bntseq.h bwt_lite.h utils.h bwa.h\nbwtsw2_pair.o: utils.h bwt.h bntseq.h bwtsw2.h bwt_lite.h kstring.h\nbwtsw2_pair.o: malloc_wrap.h ksw.h\nexample.o: bwamem.h bwt.h bntseq.h bwa.h kseq.h malloc_wrap.h\nfastmap.o: bwa.h bntseq.h bwt.h bwamem.h kvec.h malloc_wrap.h utils.h kseq.h\nis.o: malloc_wrap.h\nkopen.o: malloc_wrap.h\nkstring.o: kstring.h malloc_wrap.h\nksw.o: ksw.h neon_sse.h scalar_sse.h malloc_wrap.h\nmain.o: kstring.h malloc_wrap.h utils.h\nmalloc_wrap.o: malloc_wrap.h\nmaxk.o: bwa.h bntseq.h bwt.h bwamem.h kseq.h malloc_wrap.h\npemerge.o: ksw.h kseq.h malloc_wrap.h kstring.h bwa.h bntseq.h bwt.h utils.h\nrle.o: rle.h\nrope.o: rle.h rope.h\nutils.o: utils.h ksort.h malloc_wrap.h kseq.h\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 39.716796875,
          "content": "Release 0.7.18 (14 April 2024)\n------------------------------\n\nNotable changes:\n\n * Support ARM64 (#359)\n * Output SAM header line (#336)\n * Added the XB tag to output alignment score and mapping quality\n * Fixed a compiling error with GCC 10 (#267)\n * Avoid potential buffer overflow (#232)\n\n(0.7.18: 14 April 2024, r1243)\n\n\n\nRelease 0.7.17 (23 October 2017)\n--------------------------------\n\nThis release adds option -q to preserve the mapping quality of split alignment\nwith a lower alignment score than the primary alignment. Option -5\nautomatically applies -q as well.\n\n(0.7.17: 23 October 2017, r1188)\n\n\n\nRelease 0.7.16 (30 July 2017)\n-----------------------------\n\nThis release added a couple of minor features and incorporated multiple pull\nrequests, including:\n\n * Added option -5, which is useful to some Hi-C pipelines.\n\n * Fixed an error with samtools sorting (#129). Updated download link for\n   GRCh38 (#123). Fixed README MarkDown formatting (#70). Addressed multiple\n   issues via a collected pull request #139 by @jmarshall. Avoid malformatted\n   SAM header when -R is used with TAB (#84). Output mate CIGAR (#138).\n\n(0.7.16: 30 July 2017, r1180)\n\n\n\nRelease 0.7.15 (31 May 2016)\n----------------------------\n\nFixed a long existing bug which potentially leads to underestimated insert size\nupper bound. This bug should have little effect in practice.\n\n(0.7.15: 31 May 2016, r1140)\n\n\n\nRelease 0.7.14 (4 May 2016)\n---------------------------\n\nIn the ALT mapping mode, this release adds the \"AH:*\" header tag to SQ lines\ncorresponding to alternate haplotypes.\n\n(0.7.14: 4 May 2016, r1136)\n\n\n\nRelease 0.7.13 (23 Feburary 2016)\n---------------------------------\n\nThis release fixes a few minor bugs in the previous version and adds a few\nminor features. All BWA algorithms should produce identical output to 0.7.12\nwhen there are no ALT contigs.\n\nDetailed changes:\n\n * Fixed a bug in \"bwa-postalt.js\". The old version may produce 0.5% of wrong\n   bases for reads mapped to the ALT contigs.\n\n * Fixed a potential bug in the multithreading mode. It may occur when mapping\n   is much faster than file reading, which should almost never happen in\n   practice.\n\n * Changed the download URL of GRCh38.\n\n * Removed the read overlap mode. It is not working well.\n\n * Added the ropebwt2 algorithm as an alternative to index large genomes.\n   Ropebwt2 is slower than the \"bwtsw\" algorithm, but it has a permissive\n   license. This allows us to create an Apache2-licensed BWA (in the \"Apache2\"\n   branch) for commercial users who are concerned with GPL.\n\n(0.7.13: 23 Feburary 2016, r1126)\n\n\n\nRelease 0.7.12 (28 December 2014)\n---------------------------------\n\nThis release fixed a bug in the pair-end mode when ALT contigs are present. It\nleads to undercalling in regions overlapping ALT contigs.\n\n(0.7.12: 28 December 2014, r1039)\n\n\n\nRelease 0.7.11 (23 December, 2014)\n----------------------------------\n\nA major change to BWA-MEM is the support of mapping to ALT contigs in addition\nto the primary assembly. Part of the ALT mapping strategy is implemented in\nBWA-MEM and the rest in a postprocessing script for now. Due to the extra\nlayer of complexity on generating the reference genome and on the two-step\nmapping, we start to provide a wrapper script and precompiled binaries since\nthis release. The package may be more convenient to some specific use cases.\nFor general uses, the single BWA binary still works like the old way.\n\nAnother major addition to BWA-MEM is HLA typing, which made possible with the\nnew ALT mapping strategy. Necessary data and programs are included in the\nbinary release. The wrapper script also optionally performs HLA typing when HLA\ngenes are included in the reference genome as additional ALT contigs.\n\nOther notable changes to BWA-MEM:\n\n * Added option `-b` to `bwa index`. This option tunes the batch size used in\n   the construction of BWT. It is advised to use large `-b` for huge reference\n   sequences such as the BLAST *nt* database.\n\n * Optimized for PacBio data. This includes a change to scoring based on a\n   study done by Aaron Quinlan and a heuristic speedup. Further speedup is\n   possible, but needs more careful investigation.\n\n * Dropped PacBio read-to-read alignment for now. BWA-MEM is good for finding\n   the best hit, but is not very sensitive to suboptimal hits. Option `-x pbread`\n   is still available, but hidden on the command line. This may be removed in\n   future releases.\n\n * Added a new pre-setting for Oxford Nanopore 2D reads. LAST is still a little\n   more sensitive on older bacterial data, but bwa-mem is as good on more\n   recent data and is times faster for mapping against mammalian genomes.\n\n * Added LAST-like seeding. This improves the accuracy for longer reads.\n\n * Added option `-H` to insert arbitrary header lines.\n\n * Smarter option `-p`. Given an interleaved FASTQ stream, old bwa-mem identifies\n   the 2i-th and (2i+1)-th reads as a read pair. The new verion identifies\n   adjacent reads with the same read name as a read pair. It is possible to mix\n   single-end and paired-end reads in one FASTQ.\n\n * Improved parallelization. Old bwa-mem waits for I/O. The new version puts\n   I/O on a separate thread. It performs mapping while reading FASTQ and\n   writing SAM. This saves significant wall-clock time when reading from\n   or writing to a slow Unix pipe.\n\nWith the new release, the recommended way to map Illumina reads to GRCh38 is to\nuse the bwakit binary package:\n\n    bwa.kit/run-gen-ref hs38DH\n    bwa.kit/bwa index hs38DH.fa\n    bwa.kit/run-bwamem -t8 -H -o out-prefix hs38DH.fa read1.fq.gz read2.fq.gz | sh\n\nPlease check bwa.kit/README.md for details and command line options.\n\n(0.7.11: 23 December 2014, r1034)\n\n\n\nRelease 0.7.10 (13 July, 2014)\n------------------------------\n\nNotable changes to BWA-MEM:\n\n * Fixed a segmentation fault due to an alignment bridging the forward-reverse\n   boundary. This is a bug.\n\n * Use the PacBio heuristic to map contigs to the reference genome. The old\n   heuristic evaluates the necessity of full extension for each chain. This may\n   not work in long low-complexity regions. The PacBio heuristic performs\n   SSE2-SW around each short seed. It works better. Note that the heuristic is\n   only applied to long query sequences. For Illumina reads, the output is\n   identical to the previous version.\n\n(0.7.10: 13 July 2014, r789)\n\n\n\nRelease 0.7.9 (19 May, 2014)\n----------------------------\n\nThis release brings several major changes to BWA-MEM. Notably, BWA-MEM now\nformally supports PacBio read-to-reference alignment and experimentally supports\nPacBio read-to-read alignment. BWA-MEM also runs faster at a minor cost of\naccuracy. The speedup is more significant when GRCh38 is in use. More\nspecifically:\n\n * Support PacBio subread-to-reference alignment. Although older BWA-MEM works\n   with PacBio data in principle, the resultant alignments are frequently\n   fragmented. In this release, we fine tuned existing methods and introduced\n   new heuristics to improve PacBio alignment. These changes are not used by\n   default. Users need to add option \"-x pacbio\" to enable the feature.\n\n * Support PacBio subread-to-subread alignment (EXPERIMENTAL). This feature is\n   enabled with option \"-x pbread\". In this mode, the output only gives the\n   overlapping region between a pair of reads without detailed alignment.\n\n * Output alternative hits in the XA tag if there are not so many of them. This\n   is a BWA-backtrack feature.\n\n * Support mapping to ALT contigs in GRCh38 (EXPERIMENTAL). We provide a script\n   to postprocess hits in the XA tag to adjust the mapping quality and generate\n   new primary alignments to all overlapping ALT contigs. We would *NOT*\n   recommend this feature for production uses.\n\n * Improved alignments to many short reference sequences. Older BWA-MEM may\n   generate an alignment bridging two or more adjacent reference sequences.\n   Such alignments are split at a later step as postprocessing. This approach\n   is complex and does not always work. This release forbids these alignments\n   from the very beginning. BWA-MEM should not produce an alignment bridging\n   two or more reference sequences any more.\n\n * Reduced the maximum seed occurrence from 10000 to 500. Reduced the maximum\n   rounds of Smith-Waterman mate rescue from 100 to 50. Added a heuristic to\n   lower the mapping quality if a read contains seeds with excessive\n   occurrences. These changes make BWA-MEM faster at a minor cost of accuracy\n   in highly repetitive regions.\n\n * Added an option \"-Y\" to use soft clipping for supplementary alignments.\n\n * Bugfix: incomplete alignment extension in corner cases.\n\n * Bugfix: integer overflow when aligning long query sequences.\n\n * Bugfix: chain score is not computed correctly (almost no practical effect)\n\n * General code cleanup\n\n * Added FAQs to README\n\nChanges in BWA-backtrack:\n\n * Bugfix: a segmentation fault when an alignment stands out of the end of the\n   last chromosome.\n\n(0.7.9: 19 May 2014, r783)\n\n\n\nRelease 0.7.8 (31 March, 2014)\n------------------------------\n\nChanges in BWA-MEM:\n\n * Bugfix: off-diagonal X-dropoff (option -d) not working as intended.\n   Short-read alignment is not affected.\n\n * Bugfix: unnecessarily large bandwidth used during global alignment,\n   which reduces the mapping speed by -5% for short reads. Results are not\n   affected.\n\n * Bugfix: when the matching score is not one, paired-end mapping quality is\n   inaccurate.\n\n * When the matching score (option -A) is changed, scale all score-related\n   options accordingly unless overridden by users.\n\n * Allow to specify different gap open (or extension) penalties for deletions\n   and insertions separately.\n\n * Allow to specify the insert size distribution.\n\n * Better and more detailed debugging information.\n\nWith the default setting, 0.7.8 and 0.7.7 gave identical output on one million\n100bp read pairs.\n\n(0.7.8: 31 March 2014, r455)\n\n\n\nRelease 0.7.7 (25 Feburary, 2014)\n---------------------------------\n\nThis release fixes incorrect MD tags in the BWA-MEM output.\n\nA note about short-read mapping to GRCh38. The new human reference genome\nGRCh38 contains 60Mbp program generated alpha repeat arrays, some of which are\nhard masked as they cannot be localized. These highly repetitive arrays make\nBWA-MEM -50% slower. If you are concerned with the performance of BWA-MEM, you\nmay consider to use option \"-c2000 -m50\". On simulated data, this setting helps\nthe performance at a very minor cost on accuracy. I may consider to change the\ndefault in future releases.\n\n(0.7.7: 25 Feburary 2014, r441)\n\n\n\nRelease 0.7.6 (31 Januaray, 2014)\n---------------------------------\n\nChanges in BWA-MEM:\n\n * Changed the way mapping quality is estimated. The new method tends to give\n   the same alignment a higher mapping quality. On paired-end reads, the change\n   is minor as with pairing, the mapping quality is usually high. For short\n   single-end reads, the difference is considerable.\n\n * Improved load balance when many threads are spawned. However, bwa-mem is\n   still not very thread efficient, probably due to the frequent heap memory\n   allocation. Further improvement is a little difficult and may affect the\n   code stability.\n\n * Allow to use different clipping penalties for 5'- and 3'-ends. This helps\n   when we do not want to clip one end.\n\n * Print the @PG line, including the command line options.\n\n * Improved the band width estimate: a) fixed a bug causing the band\n   width extimated from extension not used in the final global alignment; b)\n   try doubled band width if the global alignment score is smaller.\n   Insufficient band width leads to wrong CIGAR and spurious mismatches/indels.\n\n * Added a new option -D to fine tune a heuristic on dropping suboptimal hits.\n   Reducing -D increases accuracy but decreases the mapping speed. If unsure,\n   leave it to the default.\n\n * Bugfix: for a repetitive single-end read, the reported hit is not randomly\n   distributed among equally best hits.\n\n * Bugfix: missing paired-end hits due to unsorted list of SE hits.\n\n * Bugfix: incorrect CIGAR caused by a defect in the global alignment.\n\n * Bugfix: incorrect CIGAR caused by failed SW rescue.\n\n * Bugfix: alignments largely mapped to the same position are regarded to be\n   distinct from each other, which leads to underestimated mapping quality.\n\n * Added the MD tag.\n\nThere are no changes to BWA-backtrack in this release. However, it has a few\nknown issues yet to be fixed. If you prefer BWA-track, It is still advised to\nuse bwa-0.6.x.\n\nWhile I developed BWA-MEM, I also found a few issues with BWA-SW. It is now\npossible to improve BWA-SW with the lessons learned from BWA-MEM. However, as\nBWA-MEM is usually better, I will not improve BWA-SW until I find applications\nwhere BWA-SW may excel.\n\n(0.7.6: 31 January 2014, r432)\n\n\n\nRelease 0.7.5a (30 May, 2013)\n-----------------------------\n\nFixed a bug in BWA-backtrack which leads to off-by-one mapping errors in rare\ncases.\n\n(0.7.5a: 30 May 2013, r405)\n\n\n\nRelease 0.7.5 (29 May, 2013)\n----------------------------\n\nChanges in all components:\n\n * Improved error checking on memory allocation and file I/O. Patches provided\n   by Rob Davies.\n\n * Updated README.\n\n * Bugfix: return code is zero upon errors.\n\nChanges in BWA-MEM:\n\n * Changed the way a chimeric alignment is reported (conforming to the upcoming\n   SAM spec v1.5). With 0.7.5, if the read has a chimeric alignment, the paired\n   or the top hit uses soft clipping and is marked with neither 0x800 nor 0x100\n   bits. All the other hits part of the chimeric alignment will use hard\n   clipping and be marked with 0x800 if option \"-M\" is not in use, or marked\n   with 0x100 otherwise.\n\n * Other hits part of a chimeric alignment are now reported in the SA tag,\n   conforming to the SAM spec v1.5.\n\n * Better method for resolving an alignment bridging two or more short\n   reference sequences. The current strategy maps the query to the reference\n   sequence that covers the middle point of the alignment. For most\n   applications, this change has no effects.\n\nChanges in BWA-backtrack:\n\n * Added a magic number to .sai files. This prevents samse/sampe from reading\n   corrupted .sai (e.g. a .sai file containing LSF log) or incompatible .sai\n   generated by a different version of bwa.\n\n * Bugfix: alignments in the XA:Z: tag were wrong.\n\n * Keep track of #ins and #del during backtracking. This simplifies the code\n   and reduces errors in rare corner cases. I should have done this in the\n   early days of bwa.\n\nIn addition, if you use BWA-MEM or the fastmap command of BWA, please cite:\n\n - Li H. (2013) Aligning sequence reads, clone sequences and assembly contigs\n   with BWA-MEM. arXiv:1303.3997v2 [q-bio.GN].\n\nThank you.\n\n(0.7.5: 29 May 2013, r404)\n\n\n\nRelease 0.7.4 (23 April, 2013)\n------------------------------\n\nThis is a bugfix release. Most of bugs are considered to be minor which only\noccur very rarely.\n\n * Bugfix: wrong CIGAR when a query sequence bridges three or more target\n   sequences. This only happens when aligning reads to short assembly contigs.\n\n * Bugfix: leading \"D\" operator in CIGAR.\n\n * Extend more seeds for better alignment around tandem repeats. This is also\n   a cause of the leading \"D\" operator in CIGAR.\n\n * Bugfix: SSE2-SSW may occasionally find incorrect query starting position\n   around tandem repeat. This will lead to a suboptimal CIGAR in BWA-MEM and\n   a wrong CIGAR in BWA.\n\n * Bugfix: clipping penalty does not work as is intended when there is a gap\n   towards the end of a read.\n\n * Fixed an issue caused by a bug in the libc from Mac/Darwin. In Darwin,\n   fread() is unable to read a data block longer than 2GB due to an integer\n   overflow bug in its implementation.\n\nSince version 0.7.4, BWA-MEM is considered to reach similar stability to\nBWA-backtrack for short-read mapping.\n\n(0.7.4: 23 April, r385)\n\n\n\nRelease 0.7.3a (15 March, 2013)\n-------------------------------\n\nIn 0.7.3, the wrong CIGAR bug was only fixed in one scenario, but not fixed\nin another corner case.\n\n(0.7.3a: 15 March 2013, r367)\n\n\n\nRelease 0.7.3 (15 March, 2013)\n------------------------------\n\nChanges to BWA-MEM:\n\n * Bugfix: pairing score is inaccurate when option -A does not take the default\n   value. This is a very minor issue even if it happens.\n\n * Bugfix: occasionally wrong CIGAR. This happens when in the alignment there\n   is a 1bp deletion and a 1bp insertion which are close to the end of the\n   reads, and there are no other substitutions or indels. BWA-MEM would not do\n   a gapped alignment due to the bug.\n\n * New feature: output other non-overlapping alignments in the XP tag such that\n   we can see the entire picture of alignment from one SAM line. XP gives the\n   position, CIGAR, NM and mapQ of each aligned subsequence of the query.\n\nBWA-MEM has been used to align -300Gbp 100-700bp SE/PE reads. SNP/indel calling\nhas also been evaluated on part of these data. BWA-MEM generally gives better\npre-filtered SNP calls than BWA. No significant issues have been observed since\n0.7.2, though minor improvements or bugs (e.g. the bug fixed in this release)\nare still possible. If you find potential issues, please send bug reports to\n<bio-bwa-help@lists.sourceforge.net> (free registration required).\n\nIn addition, more detailed description of the BWA-MEM algorithm can be found at\n<https://github.com/lh3/mem-paper>.\n\n(0.7.3: 15 March 2013, r366)\n\n\n\nRelease 0.7.2 (9 March, 2013)\n-----------------------------\n\nEmergent bug fix: 0.7.0 and 0.7.1 give a wrong sign to TLEN. In addition,\nflagging 'properly paired' also gets improved a little.\n\n(0.7.2: 9 March 2013, r351)\n\n\n\nRelease 0.7.1 (8 March, 2013)\n-----------------------------\n\nChanges to BWA-MEM:\n\n * Bugfix: rare segmentation fault caused by a partial hit to the end of the\n   last sequence.\n\n * Bugfix: occasional mis-pairing given an interleaved fastq.\n\n * Bugfix: wrong mate information when the mate is unmapped. SAM generated by\n   BWA-MEM can now be validated with Picard.\n\n * Improved the performance and accuracy for ultra-long query sequences.\n   Short-read alignment is not affected.\n\nChanges to other components:\n\n * In BWA-backtrack and BWA-SW, replaced the code for global alignment,\n   Smith-Waterman and SW extension. The performance and accuracy of the two\n   algorithms stay the same.\n\n * Added an experimental subcommand to merge overlapping paired ends. The\n   algorithm is very conservative: it may miss true overlaps but rarely makes\n   mistakes.\n\nAn important note is that like BWA-SW, BWA-MEM may output multiple primary\nalignments for a read, which may cause problems to some tools. For aligning\nsequence reads, it is advised to use '-M' to flag extra hits as secondary. This\noption is not the default because multiple primary alignments are theoretically\npossible in sequence alignment.\n\n(0.7.1: 8 March 2013, r347)\n\n\n\nBeta Release 0.7.0 (28 Feburary, 2013)\n--------------------------------------\n\nThis release comes with a new alignment algorithm, BWA-MEM, for 70bp-1Mbp query\nsequences. BWA-MEM essentially seeds alignments with a variant of the fastmap\nalgorithm and extends seeds with banded affine-gap-penalty dynamic programming\n(i.e. the Smith-Waterman-Gotoh algorithm). For typical Illumina 100bp reads or\nlonger low-divergence query sequences, BWA-MEM is about twice as fast as BWA\nand BWA-SW and is more accurate. It also supports split alignments like BWA-SW\nand may optionally output multiple hits like BWA. BWA-MEM does not guarantee\nto find hits within a certain edit distance, but BWA is not efficient for such\ntask given longer reads anyway, and the edit-distance criterion is arguably\nnot as important in long-read alignment.\n\nIn addition to the algorithmic improvements, BWA-MEM also implements a few\nhandy features in practical aspects:\n\n 1. BWA-MEM automatically switches between local and glocal (global wrt reads;\n    local wrt reference) alignment. It reports the end-to-end glocal alignment\n    if the glocal alignment is not much worse than the optimal local alignment.\n    Glocal alignment reduces reference bias.\n\n 2. BWA-MEM automatically infers pair orientation from a batch of single-end\n    alignments. It allows more than one orientations if there are sufficient\n    supporting reads. This feature has not been tested on reads from Illumina\n    jumping library yet. (EXPERIMENTAL)\n\n 3. BWA-MEM optionally takes one interleaved fastq for paired-end mapping. It\n    is possible to convert a name-sorted BAM to an interleaved fastq on the fly\n    and feed the data stream to BWA-MEM for mapping.\n\n 4. BWA-MEM optionally copies FASTA/Q comments to the final SAM output, which\n    helps to transfer individual read annotations to the output.\n\n 5. BWA-MEM supports more advanced piping. Users can now run:\n    (bwa mem ref.fa '<bzcat r1.fq.bz2' '<bzcat r2.fq.bz2') to map bzip'd read\n    files without replying on bash features.\n\n 6. BWA-MEM provides a few basic APIs for single-end mapping. The 'example.c'\n    program in the source code directory implements a full single-end mapper in\n    50 lines of code.\n\nThe BWA-MEM algorithm is in the beta phase. It is not advised to use BWA-MEM\nfor production use yet. However, when the implementation becomes stable after a\nfew release cycles, existing BWA users are recommended to migrate to BWA-MEM\nfor 76bp or longer Illumina reads and long query sequences. The original BWA\nshort-read algorithm will not deliver satisfactory results for 150bp+ Illumina\nreads. Change of mappers will be necessary sooner or later.\n\n(0.7.0 beta: 28 Feburary 2013, r313)\n\n\n\nRelease 0.6.2 (19 June, 2012)\n-----------------------------\n\nThis is largely a bug-fix release. Notable changes in BWA-short and BWA-SW:\n\n * Bugfix: BWA-SW may give bad alignments due to incorrect band width.\n\n * Bugfix: A segmentation fault due to an out-of-boundary error. The fix is a\n   temporary solution. The real cause has not been identified.\n\n * Attempt to read index from prefix.64.bwt, such that the 32-bit and 64-bit\n   index can coexist.\n\n * Added options '-I' and '-S' to control BWA-SW pairing.\n\n(0.6.2: 19 June 2012, r126)\n\n\n\nRelease 0.6.1 (28 November, 2011)\n---------------------------------\n\nNotable changes to BWA-short:\n\n * Bugfix: duplicated alternative hits in the XA tag.\n\n * Bugfix: when trimming enabled, bwa-aln trims 1bp less.\n\n * Disabled the color-space alignment. 0.6.x is not working with SOLiD reads at\n   present.\n\nNotable changes to BWA-SW:\n\n * Bugfix: segfault due to excessive ambiguous bases.\n\n * Bugfix: incorrect mate position in the SE mode.\n\n * Bugfix: rare segfault in the PE mode\n\n * When macro _NO_SSE2 is in use, fall back to the standard Smith-Waterman\n   instead of SSE2-SW.\n\n * Optionally mark split hits with lower alignment scores as secondary.\n\nChanges to fastmap:\n\n * Bugfix: infinite loop caused by ambiguous bases.\n\n * Optionally output the query sequence.\n\n(0.6.1: 28 November 2011, r104)\n\n\n\nRelease 0.5.10 and 0.6.0 (12 November, 2011)\n--------------------------------------------\n\nThe 0.6.0 release comes with two major changes. Firstly, the index data\nstructure has been changed to support genomes longer than 4GB. The forward and\nreverse backward genome is now integrated in one index. This change speeds up\nBWA-short by about 20% and BWA-SW by 90% with the mapping acccuracy largely\nunchanged. A tradeoff is BWA requires more memory, but this is the price almost\nall mappers that index the genome have to pay.\n\nSecondly, BWA-SW in 0.6.0 now works with paired-end data. It is more accurate\nfor highly unique reads and more robust to long indels and structural\nvariations. However, BWA-short still has edges for reads with many suboptimal\nhits. It is yet to know which algorithm is the best for variant calling.\n\n0.5.10 is a bugfix release only and is likely to be the last release in the 0.5\nbranch unless I find critical bugs in future.\n\nOther notable changes:\n\n * Added the 'fastmap' command that finds super-maximal exact matches. It does\n   not give the final alignment, but runs much faster. It can be a building\n   block for other alignment algorithms. [0.6.0 only]\n\n * Output the timing information before BWA exits. This also tells users that\n   the task has been finished instead of being killed or aborted. [0.6.0 only]\n\n * Sped up multi-threading when using many (>20) CPU cores.\n\n * Check I/O error.\n\n * Increased the maximum barcode length to 63bp.\n\n * Automatically choose the indexing algorithm.\n\n * Bugfix: very rare segfault due to an uninitialized variable. The bug also\n   affects the placement of suboptimal alignments. The effect is very minor.\n\nThis release involves quite a lot of tricky changes. Although it has been\ntested on a few data sets, subtle bugs may be still hidden. It is *NOT*\nrecommended to use this release in a production pipeline. In future, however,\nBWA-SW may be better when reads continue to go longer. I would encourage users\nto try the 0.6 release. I would also like to hear the users' experience. Thank\nyou.\n\n(0.6.0: 12 November 2011, r85)\n\n\n\nBeta Release 0.5.9 (24 January, 2011)\n-------------------------------------\n\nNotable changes:\n\n * Feature: barcode support via the '-B' option.\n\n * Feature: Illumina 1.3+ read format support via the '-I' option.\n\n * Bugfix: RG tags are not attached to unmapped reads.\n\n * Bugfix: very rare bwasw mismappings\n\n * Recommend options for PacBio reads in bwasw help message.\n\n\nAlso, since January 13, the BWA master repository has been moved to github:\n\n  https://github.com/lh3/bwa\n\nThe revision number has been reset. All recent changes will be first\ncommitted to this repository.\n\n(0.5.9: 24 January 2011, r16)\n\n\n\nBeta Release Candidate 0.5.9rc1 (10 December, 2010)\n---------------------------------------------------\n\nNotable changes in bwasw:\n\n * Output unmapped reads.\n\n * For a repetitive read, choose a random hit instead of a fixed\n   one. This is not well tested.\n\nNotable changes in bwa-short:\n\n * Fixed a bug in the SW scoring system, which may lead to unexpected\n   gaps towards the end of a read.\n\n * Fixed a bug which invalidates the randomness of repetitive reads.\n\n * Fixed a rare memory leak.\n\n * Allowed to specify the read group at the command line.\n\n * Take name-grouped BAM files as input.\n\nChanges to this release are usually safe in that they do not interfere\nwith the key functionality. However, the release has only been tested on\nsmall samples instead of on large-scale real data. If anything weird\nhappens, please report the bugs to the bio-bwa-help mailing list.\n\n(0.5.9rc1: 10 December 2010, r1561)\n\n\n\nBeta Release 0.5.8 (8 June, 2010)\n---------------------------------\n\nNotable changes in bwasw:\n\n * Fixed an issue of missing alignments. This should happen rarely and\n   only when the contig/read alignment is multi-part. Very rarely, bwasw\n   may still miss a segment in a multi-part alignment. This is difficult\n   to fix, although possible.\n\nNotable changes in bwa-short:\n\n * Discard the SW alignment when the best single-end alignment is much\n   better. Such a SW alignment may caused by structural variations and\n   forcing it to be aligned leads to false alignment. This fix has not\n   been tested thoroughly. It would be great to receive more users\n   feedbacks on this issue.\n\n * Fixed a typo/bug in sampe which leads to unnecessarily large memory\n   usage in some cases.\n\n * Further reduced the chance of reporting 'weird pairing'.\n\n(0.5.8: 8 June 2010, r1442)\n\n\n\nBeta Release 0.5.7 (1 March, 2010)\n----------------------------------\n\nThis release only has an effect on paired-end data with fat insert-size\ndistribution. Users are still recommended to update as the new release\nimproves the robustness to poor data.\n\n * The fix for 'weird pairing' was not working in version 0.5.6, pointed\n   out by Carol Scott. It should work now.\n\n * Optionally output to a normal file rather than to stdout (by Tim\n   Fennel).\n\n(0.5.7: 1 March 2010, r1310)\n\n\n\nBeta Release 0.5.6 (10 Feburary, 2010)\n--------------------------------------\n\nNotable changes in bwa-short:\n\n * Report multiple hits in the SAM format at a new tag XA encoded as:\n   (chr,pos,CIGAR,NM;)*. By default, if a paired or single-end read has\n   4 or fewer hits, they will all be reported; if a read in a anomalous\n   pair has 11 or fewer hits, all of them will be reported.\n\n * Perform Smith-Waterman alignment also for anomalous read pairs when\n   both ends have quality higher than 17. This reduces false positives\n   for some SV discovery algorithms.\n\n * Do not report \"weird pairing\" when the insert size distribution is\n   too fat or has a mean close to zero.\n\n * If a read is bridging two adjacent chromsomes, flag it as unmapped.\n\n * Fixed a small but long existing memory leak in paired-end mapping.\n\n * Multiple bug fixes in SOLiD mapping: a) quality \"-1\" can be correctly\n   parsed by solid2fastq.pl; b) truncated quality string is resolved; c)\n   SOLiD read mapped to the reverse strand is complemented.\n\n * Bwa now calculates skewness and kurtosis of the insert size\n   distribution.\n\n * Deploy a Bayesian method to estimate the maximum distance for a read\n   pair considered to be paired properly. The method is proposed by\n   Gerton Lunter, but bwa only implements a simplified version.\n\n * Export more functions for Java bindings, by Matt Hanna (See:\n   http://www.broadinstitute.org/gsa/wiki/index.php/Sting_BWA/C_bindings)\n\n * Abstract bwa CIGAR for further extension, by Rodrigo Goya.\n\n(0.5.6: 10 Feburary 2010, r1303)\n\n\n\nBeta Release 0.5.5 (10 November, 2009)\n--------------------------------------\n\nThis is a bug fix release:\n\n * Fixed a serious bug/typo in aln which does not occur given short\n   reads, but will lead to segfault for >500bp reads. Of course, the aln\n   command is not recommended for reads longer than 200bp, but this is a\n   bug anyway.\n\n * Fixed a minor bug/typo which leads to incorrect single-end mapping\n   quality when one end is moved to meet the mate-pair requirement.\n\n * Fixed a bug in samse for mapping in the color space. This bug is\n   caused by quality filtration added since 0.5.1.\n\n(0.5.5: 10 November 2009, r1273)\n\n\n\nBeta Release 0.5.4 (9 October, 2009)\n------------------------------------\n\nSince this version, the default seed length used in the \"aln\" command is\nchanged to 32.\n\nNotable changes in bwa-short:\n\n * Added a new tag \"XC:i\" which gives the length of clipped reads.\n\n * In sampe, skip alignments in case of a bug in the Smith-Waterman\n   alignment module.\n\n * In sampe, fixed a bug in pairing when the read sequence is identical\n   to its reverse complement.\n\n * In sampe, optionally preload the entire FM-index into memory to\n   reduce disk operations.\n\nNotable changes in dBWT-SW/BWA-SW:\n\n * Changed name dBWT-SW to BWA-SW.\n\n * Optionally use \"hard clipping\" in the SAM output.\n\n(0.5.4: 9 October 2009, r1245)\n\n\n\nBeta Release 0.5.3 (15 September, 2009)\n---------------------------------------\n\nFixed a critical bug in bwa-short: reads mapped to the reverse strand\nare not complemented.\n\n(0.5.3: 15 September 2009, r1225)\n\n\n\nBeta Release 0.5.2 (13 September, 2009)\n---------------------------------------\n\nNotable changes in bwa-short:\n\n * Optionally trim reads before alignment. See the manual page on 'aln\n   -q' for detailed description.\n\n * Fixed a bug in calculating the NM tag for a gapped alignment.\n\n * Fixed a bug given a mixture of reads with some longer than the seed\n   length and some shorter.\n\n * Print SAM header.\n\nNotable changes in dBWT-SW:\n\n * Changed the default value of -T to 30. As a result, the accuracy is a\n   little higher for short reads at the cost of speed.\n\n(0.5.2: 13 September 2009, r1223)\n\n\n\nBeta Release 0.5.1 (2 September, 2009)\n--------------------------------------\n\nNotable changes in the short read alignment component:\n\n * Fixed a bug in samse: do not write mate coordinates.\n\nNotable changes in dBWT-SW:\n\n * Randomly choose one alignment if the read is a repetitive.\n\n * Fixed a flaw when a read is mapped across two adjacent reference\n   sequences. However, wrong alignment reports may still occur rarely in\n   this case.\n\n * Changed the default band width to 50. The speed is slower due to this\n   change.\n\n * Improved the mapping quality a little given long query sequences.\n\n(0.5.1: 2 September 2009, r1209)\n\n\n\nBeta Release 0.5.0 (20 August, 2009)\n------------------------------------\n\nThis release implements a novel algorithm, dBWT-SW, specifically\ndesigned for long reads. It is 10-50 times faster than SSAHA2, depending\non the characteristics of the input data, and achieves comparable\nalignment accuracy while allowing chimera detection. In comparison to\nBLAT, dBWT-SW is several times faster and much more accurate especially\nwhen the error rate is high. Please read the manual page for more\ninformation.\n\nThe dBWT-SW algorithm is kind of developed for future sequencing\ntechnologies which produce much longer reads with a little higher error\nrate. It is still at its early development stage. Some features are\nmissing and it may be buggy although I have evaluated on several\nsimulated and real data sets. But following the \"release early\"\nparadigm, I would like the users to try it first.\n\nOther notable changes in BWA are:\n\n * Fixed a rare bug in the Smith-Waterman alignment module.\n\n * Fixed a rare bug about the wrong alignment coordinate when a read is\n   poorly aligned.\n\n * Fixed a bug in generating the \"mate-unmap\" SAM tag when both ends in\n   a pair are unmapped.\n\n(0.5.0: 20 August 2009, r1200)\n\n\n\nBeta Release 0.4.9 (19 May, 2009)\n---------------------------------\n\nInterestingly, the integer overflow bug claimed to be fixed in 0.4.7 has\nnot in fact. Now I have fixed the bug. Sorry for this and thank Quan\nLong for pointing out the bug (again).\n\n(0.4.9: 19 May 2009, r1075)\n\n\n\nBeta Release 0.4.8 (18 May, 2009)\n---------------------------------\n\nOne change to \"aln -R\". Now by default, if there are no more than '-R'\nequally best hits, bwa will search for suboptimal hits. This change\naffects the ability in finding SNPs in segmental duplications.\n\nI have not tested this option thoroughly, but this simple change is less\nlikely to cause new bugs. Hope I am right.\n\n(0.4.8: 18 May 2009, r1073)\n\n\n\nBeta Release 0.4.7 (12 May, 2009)\n---------------------------------\n\nNotable changes:\n\n * Output SM (single-end mapping quality) and AM (smaller mapping\n   quality among the two ends) tag from sam output.\n\n * Improved the functionality of stdsw.\n\n * Made the XN tag more accurate.\n\n * Fixed a very rare segfault caused by integer overflow.\n\n * Improve the insert size estimation.\n\n * Fixed compiling errors for some Linux systems.\n\n(0.4.7: 12 May 2009, r1066)\n\n\n\nBeta Release 0.4.6 (9 March, 2009)\n----------------------------------\n\nThis release improves the SOLiD support. First, a script for converting\nSOLiD raw data is provided. This script is adapted from solid2fastq.pl\nin the MAQ package. Second, a nucleotide reference file can be directly\nused with 'bwa index'. Third, SOLiD paired-end support is\ncompleted. Fourth, color-space reads will be converted to nucleotides\nwhen SAM output is generated. Color errors are corrected in this\nprocess. Please note that like MAQ, BWA cannot make use of the primer\nbase and the first color.\n\nIn addition, the calculation of mapping quality is also improved a\nlittle bit, although end-users may barely observe the difference.\n\n(0.4.6: 9 March 2009, r915)\n\n\n\nBeta Release 0.4.5 (18 Feburary, 2009)\n--------------------------------------\n\nNot much happened, but I think it would be good to let the users use the\nlatest version.\n\nNotable changes (Thank Bob Handsaker for catching the two bugs):\n\n * Improved bounary check. Previous version may still give incorrect\n   alignment coordinates in rare cases.\n\n * Fixed a bug in SW alignment when no residue matches. This only\n   affects the 'sampe' command.\n\n * Robustly estimate insert size without setting the maximum on the\n   command line. Since this release 'sampe -a' only has an effect if\n   there are not enough good pairs to infer the insert size\n   distribution.\n\n * Reduced false PE alignments a little bit by using the inferred insert\n   size distribution. This fix may be more important for long insert\n   size libraries.\n\n(0.4.5: 18 Feburary 2009, r829)\n\n\n\nBeta Release 0.4.4 (15 Feburary, 2009)\n--------------------------------------\n\nThis is mainly a bug fix release. Notable changes are:\n\n * Imposed boundary check for extracting subsequence from the\n   genome. Previously this causes memory problem in rare cases.\n\n * Fixed a bug in failing to find whether an alignment overlapping with\n   N on the genome.\n\n * Changed MD tag to meet the latest SAM specification.\n\n(0.4.4: 15 Feburary 2009, r815)\n\n\n\nBeta Release 0.4.3 (22 January, 2009)\n------------------------------------\n\nNotable changes:\n\n * Treat an ambiguous base N as a mismatch. Previous versions will not\n   map reads containing any N.\n\n * Automatically choose the maximum allowed number of differences. This\n   is important when reads of different lengths are mixed together.\n\n * Print mate coordinate if only one end is unmapped.\n\n * Generate MD tag. This tag encodes the mismatching positions and the\n   reference bases at these positions. Deletions from the reference will\n   also be printed.\n\n * Optionally dump multiple hits from samse, in another concise format\n   rather than SAM.\n\n * Optionally disable iterative search. This is VERY SLOOOOW, though.\n\n * Fixed a bug in generate SAM.\n\n(0.4.3: 22 January 2009, r787)\n\n\n\nBeta Release 0.4.2 (9 January, 2009)\n------------------------------------\n\nAaron Quinlan found a bug in the indexer: the bwa indexer segfaults if\nthere are no comment texts in the FASTA header. This is a critical\nbug. Nothing else was changed.\n\n(0.4.2: 9 January 2009, r769)\n\n\n\nBeta Release 0.4.1 (7 January, 2009)\n------------------------------------\n\nI am sorry for the quick updates these days. I like to set a milestone\nfor BWA and this release seems to be. For paired end reads, BWA also\ndoes Smith-Waterman alignment for an unmapped read whose mate can be\nmapped confidently. With this strategy BWA achieves similar accuracy to\nmaq. Benchmark is also updated accordingly.\n\n(0.4.1: 7 January 2009, r760)\n\n\n\nBeta Release 0.4.0 (6 January, 2009)\n------------------------------------\n\nIn comparison to the release two days ago, this release is mainly tuned\nfor performance with some tricks I learnt from Bowtie. However, as the\nindexing format has also been changed, I have to increase the version\nnumber to 0.4.0 to emphasize that *DATABASE MUST BE RE-INDEXED* with\n'bwa index'.\n\n * Improved the speed by about 20%.\n\n * Added multi-threading to 'bwa aln'.\n\n(0.4.0: 6 January 2009, r756)\n\n\n\nBeta Release 0.3.0 (4 January, 2009)\n------------------------------------\n\n * Added paired-end support by separating SA calculation and alignment\n   output.\n\n * Added SAM output.\n\n * Added evaluation to the documentation.\n\n(0.3.0: 4 January 2009, r741)\n\n\n\nBeta Release 0.2.0 (15 Augusst, 2008)\n-------------------------------------\n\n * Take the subsequence at the 5'-end as seed. Seeding strategy greatly\n   improves the speed for long reads, at the cost of missing a few true\n   hits that contain many differences in the seed. Seeding also increase\n   the memory by 800MB.\n\n * Fixed a bug which may miss some gapped alignments. Fixing the bug\n   also slows the speed a little.\n\n(0.2.0: 15 August 2008, r428)\n\n\n\nBeta Release 0.1.6 (08 Augusst, 2008)\n-------------------------------------\n\n * Give accurate CIGAR string.\n\n * Add a simple interface to SW/NW alignment\n\n(0.1.6: 08 August 2008, r414)\n\n\n\nBeta Release 0.1.5 (27 July, 2008)\n----------------------------------\n\n * Improve the speed. This version is expected to give the same results.\n\n(0.1.5: 27 July 2008, r400)\n\n\n\nBeta Release 0.1.4 (22 July, 2008)\n----------------------------------\n\n * Fixed a bug which may cause missing gapped alignments.\n\n * More clearly define what alignments can be found by BWA (See\n   manual). Now BWA runs a little slower because it will visit more\n   potential gapped alignments.\n\n * A bit code clean up.\n\n(0.1.4: 22 July 2008, r387)\n\n\n\nBeta Release 0.1.3 (21 July, 2008)\n----------------------------------\n\nImprove the speed with some tricks on retrieving occurences. The results\nshould be exactly the same as that of 0.1.2.\n\n(0.1.3: 21 July 2008, r382)\n\n\n\nBeta Release 0.1.2 (17 July, 2008)\n----------------------------------\n\nSupport gapped alignment. Codes for ungapped alignment has been removed.\n\n(0.1.2: 17 July 2008, r371)\n\n\n\nBeta Release 0.1.1 (03 June, 2008)\n-----------------------------------\n\nThis is the first release of BWA, Burrows-Wheeler Alignment tool. Please\nread man page for more information about this software.\n\n(0.1.1: 03 June 2008, r349)\n"
        },
        {
          "name": "QSufSort.c",
          "type": "blob",
          "size": 12.341796875,
          "content": "/* QSufSort.c\n\n   Original source from qsufsort.c\n\n   Copyright 1999, N. Jesper Larsson, all rights reserved.\n\n   This file contains an implementation of the algorithm presented in \"Faster\n   Suffix Sorting\" by N. Jesper Larsson (jesper@cs.lth.se) and Kunihiko\n   Sadakane (sada@is.s.u-tokyo.ac.jp).\n\n   This software may be used freely for any purpose. However, when distributed,\n   the original source must be clearly stated, and, when the source code is\n   distributed, the copyright notice must be retained and any alterations in\n   the code must be clearly marked. No warranty is given regarding the quality\n   of this software.\n\n   Modified by Wong Chi-Kwong, 2004\n\n   Changes summary:\t- Used long variable and function names\n\t\t\t\t\t- Removed global variables\n\t\t\t\t\t- Replace pointer references with array references\n\t\t\t\t\t- Used insertion sort in place of selection sort and increased insertion sort threshold\n\t\t\t\t\t- Reconstructing suffix array from inverse becomes an option\n\t\t\t\t\t- Add handling where end-of-text symbol is not necessary < all characters\n\t\t\t\t\t- Removed codes for supporting alphabet size > number of characters\n  \n  No warrenty is given regarding the quality of the modifications.\n\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include \"QSufSort.h\"\n\n#define min(value1, value2)\t\t\t\t\t\t( ((value1) < (value2)) ? (value1) : (value2) )\n#define med3(a, b, c)\t\t\t\t\t\t\t( a<b ? (b<c ? b : a<c ? c : a) : (b>c ? b : a>c ? c : a))\n#define swap(a, b, t);\t\t\t\t\t\t\tt = a; a = b; b = t;\n\n// Static functions\nstatic void QSufSortSortSplit(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t  const qsint_t highestPos, const qsint_t numSortedChar);\nstatic qsint_t QSufSortChoosePivot(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t   const qsint_t highestPos, const qsint_t numSortedChar);\nstatic void QSufSortInsertSortSplit(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t\t\tconst qsint_t highestPos, const qsint_t numSortedChar);\nstatic void QSufSortBucketSort(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t alphabetSize);\nstatic qsint_t QSufSortTransform(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t largestInputSymbol, \n\t\t\t\t\t\t\t const qsint_t smallestInputSymbol, const qsint_t maxNewAlphabetSize, qsint_t *numSymbolAggregated);\n\n/* Makes suffix array p of x. x becomes inverse of p. p and x are both of size\n   n+1. Contents of x[0...n-1] are integers in the range l...k-1. Original\n   contents of x[n] is disregarded, the n-th symbol being regarded as\n   end-of-string smaller than all other symbols.*/\nvoid QSufSortSuffixSort(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t largestInputSymbol, \n\t\t\t\t\t\tconst qsint_t smallestInputSymbol, const int skipTransform)\n{\n\tqsint_t i, j;\n\tqsint_t s, negatedSortedGroupLength;\n\tqsint_t numSymbolAggregated;\n\tqsint_t numSortedPos = 1;\n\tqsint_t newAlphabetSize;\n   \n\tif (!skipTransform) {\n\t\t/* bucketing possible*/\n\t\tnewAlphabetSize = QSufSortTransform(V, I, numChar, largestInputSymbol, smallestInputSymbol, \n\t\t\t\t\t\t\t\t\t\t\tnumChar, &numSymbolAggregated);\n\t\tQSufSortBucketSort(V, I, numChar, newAlphabetSize);\n\t\tI[0] = -1;\n\t\tV[numChar] = 0;\n\t\tnumSortedPos = numSymbolAggregated;\n\t}\n\n\twhile ((qsint_t)(I[0]) >= -(qsint_t)numChar) {\n\t\ti = 0;\n\t\tnegatedSortedGroupLength = 0;\n\t\tdo {\n\t\t\ts = I[i];\n\t\t\tif (s < 0) {\n\t\t\t\ti -= s;\t\t\t\t\t\t/* skip over sorted group.*/\n\t\t\t\tnegatedSortedGroupLength += s;\n\t\t\t} else {\n\t\t\t\tif (negatedSortedGroupLength) {\n\t\t\t\t\tI[i+negatedSortedGroupLength] = negatedSortedGroupLength;\t/* combine preceding sorted groups */\n\t\t\t\t\tnegatedSortedGroupLength = 0;\n\t\t\t\t}\n\t\t\t\tj = V[s] + 1;\n\t\t\t\tQSufSortSortSplit(V, I, i, j - 1, numSortedPos);\n\t\t\t\ti = j;\n\t\t\t}\n\t\t} while (i <= numChar);\n\t\tif (negatedSortedGroupLength) {\n\t\t\t/* array ends with a sorted group.*/\n\t\t\tI[i+negatedSortedGroupLength] = negatedSortedGroupLength;\t/* combine sorted groups at end of I.*/\n\t\t}\n\t\tnumSortedPos *= 2;\t/* double sorted-depth.*/\n\t}\n}\n\nvoid QSufSortGenerateSaFromInverse(const qsint_t* V, qsint_t* __restrict I, const qsint_t numChar)\n{\n\tqsint_t i;\n\tfor (i=0; i<=numChar; i++)\n\t\tI[V[i]] = i + 1;\n}\n\n/* Sorting routine called for each unsorted group. Sorts the array of integers\n   (suffix numbers) of length n starting at p. The algorithm is a ternary-split\n   quicksort taken from Bentley & McIlroy, \"Engineering a Sort Function\",\n   Software -- Practice and Experience 23(11), 1249-1265 (November 1993). This\n   function is based on Program 7.*/\nstatic void QSufSortSortSplit(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t  const qsint_t highestPos, const qsint_t numSortedChar) {\n\n\tqsint_t a, b, c, d;\n\tqsint_t l, m;\n\tqsint_t f, v, s, t;\n\tqsint_t tmp;\n\tqsint_t numItem;\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tif (numItem <= INSERT_SORT_NUM_ITEM) {\n\t\tQSufSortInsertSortSplit(V, I, lowestPos, highestPos, numSortedChar);\n\t\treturn;\n\t}\n\n\tv = QSufSortChoosePivot(V, I, lowestPos, highestPos, numSortedChar);\n\n\ta = b = lowestPos;\n\tc = d = highestPos;\n\n\twhile (1) {\n\t\twhile (c >= b && (f = KEY(V, I, b, numSortedChar)) <= v) {\n\t\t\tif (f == v) {\n\t\t\t\tswap(I[a], I[b], tmp);\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\twhile (c >= b && (f = KEY(V, I, c, numSortedChar)) >= v) {\n\t\t\tif (f == v) {\n\t\t\t\tswap(I[c], I[d], tmp);\n\t\t\t\td--;\n\t\t\t}\n\t\t\tc--;\n\t\t}\n\t\tif (b > c)\n\t\t\tbreak;\n\t\tswap(I[b], I[c], tmp);\n\t\tb++;\n\t\tc--;\n\t}\n\n\ts = a - lowestPos;\n\tt = b - a;\n\ts = min(s, t);\n\tfor (l = lowestPos, m = b - s; m < b; l++, m++) {\n\t\tswap(I[l], I[m], tmp);\n\t}\n\n\ts = d - c;\n\tt = highestPos - d;\n\ts = min(s, t);\n\tfor (l = b, m = highestPos - s + 1; m <= highestPos; l++, m++) {\n\t\tswap(I[l], I[m], tmp);\n\t}\n\n\ts = b - a;\n\tt = d - c;\n\tif (s > 0)\n\t\tQSufSortSortSplit(V, I, lowestPos, lowestPos + s - 1, numSortedChar);\n\n\t// Update group number for equal portion\n\ta = lowestPos + s;\n\tb = highestPos - t;\n\tif (a == b) {\n\t\t// Sorted group\n\t\tV[I[a]] = a;\n\t\tI[a] = -1;\n\t} else {\n\t\t// Unsorted group\n\t\tfor (c=a; c<=b; c++)\n\t\t\tV[I[c]] = b;\n\t}\n\n\tif (t > 0)\n\t\tQSufSortSortSplit(V, I, highestPos - t + 1, highestPos, numSortedChar);\n\n}\n\n/* Algorithm by Bentley & McIlroy.*/\nstatic qsint_t QSufSortChoosePivot(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t   const qsint_t highestPos, const qsint_t numSortedChar) {\n\n\tqsint_t m;\n\tqsint_t keyl, keym, keyn;\n\tqsint_t key1, key2, key3;\n\tqsint_t s;\n\tqsint_t numItem;\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tm = lowestPos + numItem / 2;\n\n\ts = numItem / 8;\n\tkey1 = KEY(V, I, lowestPos, numSortedChar);\n\tkey2 = KEY(V, I, lowestPos+s, numSortedChar);\n\tkey3 = KEY(V, I, lowestPos+2*s, numSortedChar);\n\tkeyl = med3(key1, key2, key3);\n\tkey1 = KEY(V, I, m-s, numSortedChar);\n\tkey2 = KEY(V, I, m, numSortedChar);\n\tkey3 = KEY(V, I, m+s, numSortedChar);\n\tkeym = med3(key1, key2, key3);\n\tkey1 = KEY(V, I, highestPos-2*s, numSortedChar);\n\tkey2 = KEY(V, I, highestPos-s, numSortedChar);\n\tkey3 = KEY(V, I, highestPos, numSortedChar);\n\tkeyn = med3(key1, key2, key3);\n\n\treturn med3(keyl, keym, keyn);\n\n\n}\n\n/* Quadratic sorting method to use for small subarrays. */\nstatic void QSufSortInsertSortSplit(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t\t\tconst qsint_t highestPos, const qsint_t numSortedChar)\n{\n\tqsint_t i, j;\n\tqsint_t tmpKey, tmpPos;\n\tqsint_t numItem;\n\tqsint_t key[INSERT_SORT_NUM_ITEM], pos[INSERT_SORT_NUM_ITEM];\n\tqsint_t negativeSortedLength;\n\tqsint_t groupNum;\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tfor (i=0; i<numItem; i++) {\n\t\tpos[i] = I[lowestPos + i];\n\t\tkey[i] = V[pos[i] + numSortedChar];\n\t}\n\n\tfor (i=1; i<numItem; i++) {\n\t\ttmpKey = key[i];\n\t\ttmpPos = pos[i];\n\t\tfor (j=i; j>0 && key[j-1] > tmpKey; j--) {\n\t\t\tkey[j] = key[j-1];\n\t\t\tpos[j] = pos[j-1];\n\t\t}\n\t\tkey[j] = tmpKey;\n\t\tpos[j] = tmpPos;\n\t}\n\n\tnegativeSortedLength = -1;\n\n\ti = numItem - 1;\n\tgroupNum = highestPos;\n\twhile (i > 0) {\n\t\tI[i+lowestPos] = pos[i];\n\t\tV[I[i+lowestPos]] = groupNum;\n\t\tif (key[i-1] == key[i]) {\n\t\t\tnegativeSortedLength = 0;\n\t\t} else {\n\t\t\tif (negativeSortedLength < 0)\n\t\t\t\tI[i+lowestPos] = negativeSortedLength;\n\t\t\tgroupNum = i + lowestPos - 1;\n\t\t\tnegativeSortedLength--;\n\t\t}\n\t\ti--;\n\t}\n\n\tI[lowestPos] = pos[0];\n\tV[I[lowestPos]] = groupNum;\n\tif (negativeSortedLength < 0)\n\t\tI[lowestPos] = negativeSortedLength;\n}\n\n/* Bucketsort for first iteration.\n\n   Input: x[0...n-1] holds integers in the range 1...k-1, all of which appear\n   at least once. x[n] is 0. (This is the corresponding output of transform.) k\n   must be at most n+1. p is array of size n+1 whose contents are disregarded.\n\n   Output: x is V and p is I after the initial sorting stage of the refined\n   suffix sorting algorithm.*/\n      \nstatic void QSufSortBucketSort(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t alphabetSize)\n{\n\tqsint_t i, c;\n\tqsint_t d;\n\tqsint_t groupNum;\n\tqsint_t currentIndex;\n\n\t// mark linked list empty\n\tfor (i=0; i<alphabetSize; i++)\n\t\tI[i] = -1;\n\n\t// insert to linked list\n\tfor (i=0; i<=numChar; i++) {\n\t\tc = V[i];\n\t\tV[i] = (qsint_t)(I[c]);\n\t\tI[c] = i;\n\t}\n\n\tcurrentIndex = numChar;\n\tfor (i=alphabetSize; i>0; i--) {\n\t\tc = I[i-1];\n\t\td = (qsint_t)(V[c]);\n\t\tgroupNum = currentIndex;\n\t\tV[c] = groupNum;\n\t\tif (d >= 0) {\n\t\t\tI[currentIndex] = c;\n\t\t\twhile (d >= 0) {\n\t\t\t\tc = d;\n\t\t\t\td = V[c];\n\t\t\t\tV[c] = groupNum;\n\t\t\t\tcurrentIndex--;\n\t\t\t\tI[currentIndex] = c;\n\t\t\t}\n\t\t} else {\n\t\t\t// sorted group\n\t\t\tI[currentIndex] = -1;\n\t\t}\n\t\tcurrentIndex--;\n\t}\n}\n\n/* Transforms the alphabet of x by attempting to aggregate several symbols into\n   one, while preserving the suffix order of x. The alphabet may also be\n   compacted, so that x on output comprises all integers of the new alphabet\n   with no skipped numbers.\n\n   Input: x is an array of size n+1 whose first n elements are positive\n   integers in the range l...k-1. p is array of size n+1, used for temporary\n   storage. q controls aggregation and compaction by defining the maximum intue\n   for any symbol during transformation: q must be at least k-l; if q<=n,\n   compaction is guaranteed; if k-l>n, compaction is never done; if q is\n   INT_MAX, the maximum number of symbols are aggregated into one.\n   \n   Output: Returns an integer j in the range 1...q representing the size of the\n   new alphabet. If j<=n+1, the alphabet is compacted. The global variable r is\n   set to the number of old symbols grouped into one. Only x[n] is 0.*/\nstatic qsint_t QSufSortTransform(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t largestInputSymbol, \n\t\t\t\t\t\t\t const qsint_t smallestInputSymbol, const qsint_t maxNewAlphabetSize, qsint_t *numSymbolAggregated)\n{\n\tqsint_t c, i, j;\n\tqsint_t a;\t// numSymbolAggregated\n\tqsint_t mask;\n\tqsint_t minSymbolInChunk = 0, maxSymbolInChunk = 0;\n\tqsint_t newAlphabetSize;\n\tqsint_t maxNumInputSymbol, maxNumBit, maxSymbol;\n\n\tmaxNumInputSymbol = largestInputSymbol - smallestInputSymbol + 1;\n\n\tfor (maxNumBit = 0, i = maxNumInputSymbol; i; i >>= 1) ++maxNumBit;\n\tmaxSymbol = QSINT_MAX >> maxNumBit;\n\n\tc = maxNumInputSymbol;\n\tfor (a = 0; a < numChar && maxSymbolInChunk <= maxSymbol && c <= maxNewAlphabetSize; a++) {\n\t\tminSymbolInChunk = (minSymbolInChunk << maxNumBit) | (V[a] - smallestInputSymbol + 1);\n\t\tmaxSymbolInChunk = c;\n\t\tc = (maxSymbolInChunk << maxNumBit) | maxNumInputSymbol;\n\t}\n\n\tmask = (1 << (a-1) * maxNumBit) - 1;\t/* mask masks off top old symbol from chunk.*/\n\tV[numChar] = smallestInputSymbol - 1;\t/* emulate zero terminator.*/\n\n\t/* bucketing possible, compact alphabet.*/\n\tfor (i=0; i<=maxSymbolInChunk; i++)\n\t\tI[i] = 0;\t/* zero transformation table.*/\n\tc = minSymbolInChunk;\n\tfor (i=a; i<=numChar; i++) {\n\t\tI[c] = 1;\t\t\t/* mark used chunk symbol.*/\n\t\tc = ((c & mask) << maxNumBit) | (V[i] - smallestInputSymbol + 1);\t/* shift in next old symbol in chunk.*/\n\t}\n\tfor (i=1; i<a; i++) {\t/* handle last r-1 positions.*/\n\t\tI[c] = 1;\t\t\t/* mark used chunk symbol.*/\n\t\tc = (c & mask) << maxNumBit;\t/* shift in next old symbol in chunk.*/\n\t}\n\tnewAlphabetSize = 1;\n\tfor (i=0; i<=maxSymbolInChunk; i++) {\n\t\tif (I[i]) {\n\t\t\tI[i] = newAlphabetSize;\n\t\t\tnewAlphabetSize++;\n\t\t}\n\t}\n\tc = minSymbolInChunk;\n\tfor (i=0, j=a; j<=numChar; i++, j++) {\n\t\tV[i] = I[c];\t\t\t\t\t\t/* transform to new alphabet.*/\n\t\tc = ((c & mask) << maxNumBit) | (V[j] - smallestInputSymbol + 1);\t/* shift in next old symbol in chunk.*/\n\t}\n\tfor (; i<numChar; i++) {\t/* handle last a-1 positions.*/\n\t\tV[i] = I[c];\t\t\t/* transform to new alphabet.*/\n\t\tc = (c & mask) << maxNumBit;\t/* shift right-end zero in chunk.*/\n\t}\n\n\tV[numChar] = 0;\t\t/* end-of-string symbol is zero.*/\n\n    *numSymbolAggregated = a;\n\treturn newAlphabetSize;\n}\n"
        },
        {
          "name": "QSufSort.h",
          "type": "blob",
          "size": 1.607421875,
          "content": "/* QSufSort.h\n\n   Header file for QSufSort.c\n\n   This file contains an implementation of the algorithm presented in \"Faster\n   Suffix Sorting\" by N. Jesper Larsson (jesper@cs.lth.se) and Kunihiko\n   Sadakane (sada@is.s.u-tokyo.ac.jp).\n\n   This software may be used freely for any purpose. However, when distributed,\n   the original source must be clearly stated, and, when the source code is\n   distributed, the copyright notice must be retained and any alterations in\n   the code must be clearly marked. No warranty is given regarding the quality\n   of this software.\n\n   Modified by Wong Chi-Kwong, 2004\n\n   Changes summary:\t- Used long variable and function names\n\t\t\t\t\t- Removed global variables\n\t\t\t\t\t- Replace pointer references with array references\n\t\t\t\t\t- Used insertion sort in place of selection sort and increased insertion sort threshold\n\t\t\t\t\t- Reconstructing suffix array from inverse becomes an option\n\t\t\t\t\t- Add handling where end-of-text symbol is not necessary < all characters\n\t\t\t\t\t- Removed codes for supporting alphabet size > number of characters\n  \n  No warrenty is given regarding the quality of the modifications.\n\n*/\n\n#ifndef __QSUFSORT_H__\n#define __QSUFSORT_H__\n\n#include <stdint.h>\n\n#define KEY(V, I, p, h)\t\t\t\t\t( V[ I[p] + h ] )\n#define INSERT_SORT_NUM_ITEM\t16\n\ntypedef int64_t qsint_t;\n#define QSINT_MAX INT64_MAX\n\nvoid QSufSortSuffixSort(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t largestInputSymbol, \n\t\t\t\t\t\tconst qsint_t smallestInputSymbol, const int skipTransform);\nvoid QSufSortGenerateSaFromInverse(const qsint_t *V, qsint_t* __restrict I, const qsint_t numChar);\n\n\n#endif\n"
        },
        {
          "name": "README-alt.md",
          "type": "blob",
          "size": 9.1728515625,
          "content": "## For the Impatient\n\n```sh\n# Download bwakit (or from <http://sourceforge.net/projects/bio-bwa/files/bwakit/> manually)\nwget -O- http://sourceforge.net/projects/bio-bwa/files/bwakit/bwakit-0.7.12_x64-linux.tar.bz2/download \\\n  | gzip -dc | tar xf -\n# Generate the GRCh38+ALT+decoy+HLA and create the BWA index\nbwa.kit/run-gen-ref hs38DH   # download GRCh38 and write hs38DH.fa\nbwa.kit/bwa index hs38DH.fa  # create BWA index\n# mapping\nbwa.kit/run-bwamem -o out -H hs38DH.fa read1.fq read2.fq | sh  # skip \"|sh\" to show command lines\n```\n\nThis generates `out.aln.bam` as the final alignment, `out.hla.top` for best HLA\ngenotypes on each gene and `out.hla.all` for other possible HLA genotypes.\nPlease check out [bwa/bwakit/README.md][kithelp] for details.\n\n## Background\n\nGRCh38 consists of several components: chromosomal assembly, unlocalized contigs\n(chromosome known but location unknown), unplaced contigs (chromosome unknown)\nand ALT contigs (long clustered variations). The combination of the first three\ncomponents is called the *primary assembly*. It is recommended to use the\ncomplete primary assembly for all analyses. Using ALT contigs in read mapping is\ntricky.\n\nGRCh38 ALT contigs are totaled 109Mb in length, spanning 60Mbp of the primary\nassembly. However, sequences that are highly diverged from the primary assembly\nonly contribute a few million bp. Most subsequences of ALT contigs are nearly\nidentical to the primary assembly. If we align sequence reads to GRCh38+ALT\nblindly, we will get many additional reads with zero mapping quality and miss\nvariants on them. It is crucial to make mappers aware of ALTs.\n\nBWA-MEM is ALT-aware. It essentially computes mapping quality across the\nnon-redundant content of the primary assembly plus the ALT contigs and is free\nof the problem above.\n\n## Methods\n\n### Sequence alignment\n\nAs of now, ALT mapping is done in two separate steps: BWA-MEM mapping and\npostprocessing. The `bwa.kit/run-bwamem` script performs the two steps when ALT\ncontigs are present. The following picture shows an example about how BWA-MEM\ninfers mapping quality and reports alignment after step 2:\n\n![](http://lh3lh3.users.sourceforge.net/images/alt-demo.png)\n\n#### Step 1: BWA-MEM mapping\n\nAt this step, BWA-MEM reads the ALT contig names from \"*idxbase*.alt\", ignoring\nthe ALT-to-ref alignment, and labels a potential hit as *ALT* or *non-ALT*,\ndepending on whether the hit lands on an ALT contig or not. BWA-MEM then reports\nalignments and assigns mapQ following these two rules:\n\n1. The mapQ of a non-ALT hit is computed across non-ALT hits only. The mapQ of\n   an ALT hit is computed across all hits.\n\n2. If there are no non-ALT hits, the best ALT hit is outputted as the primary\n   alignment. If there are both ALT and non-ALT hits, non-ALT hits will be\n   primary and ALT hits be supplementary (SAM flag 0x800).\n\nIn theory, non-ALT alignments from step 1 should be identical to alignments\nagainst the reference genome with ALT contigs. In practice, the two types of\nalignments may differ in rare cases due to seeding heuristics. When an ALT hit\nis significantly better than non-ALT hits, BWA-MEM may miss seeds on the\nnon-ALT hits.\n\nIf we don't care about ALT hits, we may skip postprocessing (step 2).\nNonetheless, postprocessing is recommended as it improves mapQ and gives more\ninformation about ALT hits.\n\n#### Step 2: Postprocessing\n\nPostprocessing is done with a separate script `bwa-postalt.js`. It reads all\npotential hits reported in the XA tag, lifts ALT hits to the chromosomal\npositions using the ALT-to-ref alignment, groups them based on overlaps between\ntheir lifted positions, and then re-estimates mapQ across the best scoring hit\nin each group. Being aware of the ALT-to-ref alignment, this script can greatly\nimprove mapQ of ALT hits and occasionally improve mapQ of non-ALT hits. It also\nwrites each hit overlapping the reported hit into a separate SAM line. This\nenables variant calling on each ALT contig independent of others.\n\n### On the completeness of GRCh38+ALT\n\nWhile GRCh38 is much more complete than GRCh37, it is still missing some true\nhuman sequences. To make sure every piece of sequence in the reference assembly\nis correct, the [Genome Reference Consortium][grc] (GRC) require each ALT contig\nto have enough support from multiple sources before considering to add it to the\nreference assembly. This careful and sophisticated procedure has left out some\nsequences, one of which is [this example][novel], a 10kb contig assembled from\nCHM1 short reads and present also in NA12878. You can try [BLAT][blat] or\n[BLAST][blast] to see where it maps.\n\nFor a more complete reference genome, we compiled a new set of decoy sequences\nfrom GenBank clones and the de novo assembly of 254 public [SGDP][sgdp] samples.\nThe sequences are included in `hs38DH-extra.fa` from the [BWA binary\npackage][res].\n\nIn addition to decoy, we also put multiple alleles of HLA genes in\n`hs38DH-extra.fa`. These genomic sequences were acquired from [IMGT/HLA][hladb],\nversion 3.18.0 and are used to collect reads sequenced from these genes.\n\n### HLA typing\n\nHLA genes are known to be associated with many autoimmune diseases, infectious\ndiseases and drug responses. They are among the most important genes but are\nrarely studied by WGS projects due to the high sequence divergence between\nHLA genes and the reference genome in these regions.\n\nBy including the HLA gene regions in the reference assembly as ALT contigs, we\nare able to effectively identify reads coming from these genes. We also provide\na pipeline, which is included in the [BWA binary package][res], to type the\nseveral classic HLA genes. The pipeline is conceptually simple. It de novo\nassembles sequence reads mapped to each gene, aligns exon sequences of each\nallele to the assembled contigs and then finds the pairs of alleles that best\nexplain the contigs. In practice, however, the completeness of IMGT/HLA and\ncopy-number changes related to these genes are not so straightforward to\nresolve. HLA typing may not always be successful. Users may also consider to use\nother programs for typing such as [Warren et al (2012)][hla4], [Liu et al\n(2013)][hla2], [Bai et al (2014)][hla3] and [Dilthey et al (2014)][hla1], though\nmost of them are distributed under restrictive licenses.\n\n## Preliminary Evaluation\n\nTo check whether GRCh38 is better than GRCh37, we mapped the CHM1 and NA12878\nunitigs to GRCh37 primary (hs37), GRCh38 primary (hs38) and GRCh38+ALT+decoy\n(hs38DH), and called small variants from the alignment. CHM1 is haploid.\nIdeally, heterozygous calls are false positives (FP). NA12878 is diploid. The\ntrue positive (TP) heterozygous calls from NA12878 are approximately equal\nto the difference between NA12878 and CHM1 heterozygous calls. A better assembly\nshould yield higher TP and lower FP. The following table shows the numbers for\nthese assemblies:\n\n|Assembly|hs37   |hs38   |hs38DH|CHM1_1.1|  huref|\n|:------:|------:|------:|------:|------:|------:|\n|FP      | 255706| 168068| 142516|307172 | 575634|\n|TP      |2142260|2163113|2150844|2167235|2137053|\n\nWith this measurement, hs38 is clearly better than hs37. Genome hs38DH reduces\nFP by ~25k but also reduces TP by ~12k. We manually inspected variants called\nfrom hs38 only and found the majority of them are associated with excessive read\ndepth, clustered variants or weak alignment. We believe most hs38-only calls are\nproblematic. In addition, if we compare two NA12878 replicates from HiSeq X10\nwith nearly identical library construction, the difference is ~140k, an order\nof magnitude higher than the difference between hs38 and hs38DH. ALT contigs,\ndecoy and HLA genes in hs38DH improve variant calling and enable the analyses of\nALT contigs and HLA typing at little cost.\n\n## Problems and Future Development\n\nThere are some uncertainties about ALT mappings - we are not sure whether they\nhelp biological discovery and don't know the best way to analyze them. Without\nclear demand from downstream analyses, it is very difficult to design the\noptimal mapping strategy. The current BWA-MEM method is just a start. If it\nturns out to be useful in research, we will probably rewrite bwa-postalt.js in C\nfor performance; if not, we may make changes. It is also possible that we might\nmake breakthrough on the representation of multiple genomes, in which case, we\ncan even get rid of ALT contigs for good.\n\n\n\n[res]: https://sourceforge.net/projects/bio-bwa/files/bwakit\n[sb]: https://github.com/GregoryFaust/samblaster\n[grc]: http://www.ncbi.nlm.nih.gov/projects/genome/assembly/grc/\n[novel]: https://gist.github.com/lh3/9935148b71f04ba1a8cc\n[blat]: https://genome.ucsc.edu/cgi-bin/hgBlat\n[blast]: http://blast.st-va.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&PAGE_TYPE=BlastSearch&LINK_LOC=blasthome\n[sgdp]: http://www.simonsfoundation.org/life-sciences/simons-genome-diversity-project/\n[hladb]: http://www.ebi.ac.uk/ipd/imgt/hla/\n[grcdef]: http://www.ncbi.nlm.nih.gov/projects/genome/assembly/grc/info/definitions.shtml\n[hla1]: http://biorxiv.org/content/early/2014/07/08/006973\n[hlalink]: http://www.hladiseaseassociations.com\n[hlatools]: https://www.biostars.org/p/93245/\n[hla2]: http://nar.oxfordjournals.org/content/41/14/e142.full.pdf+html\n[hla3]: http://www.biomedcentral.com/1471-2164/15/325\n[hla4]: http://genomemedicine.com/content/4/12/95\n[kithelp]: https://github.com/lh3/bwa/tree/master/bwakit\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.1220703125,
          "content": "[![Build Status](https://github.com/lh3/bwa/actions/workflows/ci.yaml/badge.svg)](https://github.com/lh3/bwa/actions)\n[![SourceForge Downloads](https://img.shields.io/sourceforge/dt/bio-bwa.svg?label=SF%20downloads)](https://sourceforge.net/projects/bio-bwa/files/?source=navbar)\n[![GitHub Downloads](https://img.shields.io/github/downloads/lh3/bwa/total.svg?style=flat&label=GitHub%20downloads)](https://github.com/lh3/bwa/releases)\n[![BioConda Install](https://img.shields.io/conda/dn/bioconda/bwa.svg?style=flag&label=BioConda%20install)](https://anaconda.org/bioconda/bwa)\n\n**Note: [minimap2][minimap2] has replaced BWA-MEM for __PacBio and Nanopore__ read\nalignment.** It retains all major BWA-MEM features, but is ~50 times as fast,\nmore versatile, more accurate and produces better base-level alignment.\nA beta version of [BWA-MEM2][bwa-mem2] has been released for short-read mapping.\nBWA-MEM2 is about twice as fast as BWA-MEM and outputs near identical alignments.\n\n[minimap2]: https://github.com/lh3/minimap2\n[bwa-mem2]: https://github.com/bwa-mem2/bwa-mem2\n\n## Getting started\n\n\tgit clone https://github.com/lh3/bwa.git\n\tcd bwa; make\n\t./bwa index ref.fa\n\t./bwa mem ref.fa read-se.fq.gz | gzip -3 > aln-se.sam.gz\n\t./bwa mem ref.fa read1.fq read2.fq | gzip -3 > aln-pe.sam.gz\n\n## Introduction\n\nBWA is a software package for mapping DNA sequences against a large reference\ngenome, such as the human genome. It consists of three algorithms:\nBWA-backtrack, BWA-SW and BWA-MEM. The first algorithm is designed for Illumina\nsequence reads up to 100bp, while the rest two for longer sequences ranged from\n70bp to a few megabases. BWA-MEM and BWA-SW share similar features such as the\nsupport of long reads and chimeric alignment, but BWA-MEM, which is the latest,\nis generally recommended as it is faster and more accurate. BWA-MEM also has\nbetter performance than BWA-backtrack for 70-100bp Illumina reads.\n\nFor all the algorithms, BWA first needs to construct the FM-index for the\nreference genome (the **index** command). Alignment algorithms are invoked with\ndifferent sub-commands: **aln/samse/sampe** for BWA-backtrack,\n**bwasw** for BWA-SW and **mem** for the BWA-MEM algorithm.\n\n## Availability\n\nBWA is released under [GPLv3][1]. The latest source code is [freely\navailable at github][2]. Released packages can [be downloaded][3] at\nSourceForge. After you acquire the source code, simply use `make` to compile\nand copy the single executable `bwa` to the destination you want. The only\ndependency required to build BWA is [zlib][14].\n\nSince 0.7.11, precompiled binary for x86\\_64-linux is available in [bwakit][17].\nIn addition to BWA, this self-consistent package also comes with bwa-associated\nand 3rd-party tools for proper BAM-to-FASTQ conversion, mapping to ALT contigs,\nadapter triming, duplicate marking, HLA typing and associated data files.\n\n## Seeking help\n\nThe detailed usage is described in the man page available together with the\nsource code. You can use `man ./bwa.1` to view the man page in a terminal. The\n[HTML version][4] of the man page can be found at the [BWA website][5]. If you\nhave questions about BWA, you may [sign up the mailing list][6] and then send\nthe questions to [bio-bwa-help@sourceforge.net][7]. You may also ask questions\nin forums such as [BioStar][8] and [SEQanswers][9].\n\n## Citing BWA\n\n* Li H. and Durbin R. (2009) Fast and accurate short read alignment with\n Burrows-Wheeler transform. *Bioinformatics*, **25**, 1754-1760. [PMID:\n [19451168][10]]. (if you use the BWA-backtrack algorithm)\n\n* Li H. and Durbin R. (2010) Fast and accurate long-read alignment with\n Burrows-Wheeler transform. *Bioinformatics*, **26**, 589-595. [PMID:\n [20080505][11]]. (if you use the BWA-SW algorithm)\n\n* Li H. (2013) Aligning sequence reads, clone sequences and assembly contigs\n with BWA-MEM. [arXiv:1303.3997v2][12] [q-bio.GN]. (if you use the BWA-MEM\n algorithm or the **fastmap** command, or want to cite the whole BWA package)\n\nPlease note that the last reference is a preprint hosted at [arXiv.org][13]. I\ndo not have plan to submit it to a peer-reviewed journal in the near future.\n\n## Frequently asked questions (FAQs)\n\n1. [What types of data does BWA work with?](#type)\n2. [Why does a read appear multiple times in the output SAM?](#multihit)\n3. [Does BWA work on reference sequences longer than 4GB in total?](#4gb)\n4. [Why can one read in a pair has high mapping quality but the other has zero?](#pe0)\n5. [How can a BWA-backtrack alignment stands out of the end of a chromosome?](#endref)\n6. [Does BWA work with ALT contigs in the GRCh38 release?](#altctg)\n7. [Can I just run BWA-MEM against GRCh38+ALT without post-processing?](#postalt)\n\n#### <a name=\"type\"></a>1. What types of data does BWA work with?\n\nBWA works with a variety types of DNA sequence data, though the optimal\nalgorithm and setting may vary. The following list gives the recommended\nsettings:\n\n* Illumina/454/IonTorrent single-end reads longer than ~70bp or assembly\n  contigs up to a few megabases mapped to a closely related reference genome:\n\n\t\tbwa mem ref.fa reads.fq > aln.sam\n\n* Illumina single-end reads shorter than ~70bp:\n\n\t\tbwa aln ref.fa reads.fq > reads.sai; bwa samse ref.fa reads.sai reads.fq > aln-se.sam\n\n* Illumina/454/IonTorrent paired-end reads longer than ~70bp:\n\n\t\tbwa mem ref.fa read1.fq read2.fq > aln-pe.sam\n\n* Illumina paired-end reads shorter than ~70bp:\n\n\t\tbwa aln ref.fa read1.fq > read1.sai; bwa aln ref.fa read2.fq > read2.sai\n\t\tbwa sampe ref.fa read1.sai read2.sai read1.fq read2.fq > aln-pe.sam\n\n* PacBio subreads or Oxford Nanopore reads to a reference genome:\n\n\t\tbwa mem -x pacbio ref.fa reads.fq > aln.sam\n\t\tbwa mem -x ont2d ref.fa reads.fq > aln.sam\n\nBWA-MEM is recommended for query sequences longer than ~70bp for a variety of\nerror rates (or sequence divergence). Generally, BWA-MEM is more tolerant with\nerrors given longer query sequences as the chance of missing all seeds is small.\nAs is shown above, with non-default settings, BWA-MEM works with Oxford Nanopore\nreads with a sequencing error rate over 20%.\n\n#### <a name=\"multihit\"></a>2. Why does a read appear multiple times in the output SAM?\n\nBWA-SW and BWA-MEM perform local alignments. If there is a translocation, a gene\nfusion or a long deletion, a read bridging the break point may have two hits,\noccupying two lines in the SAM output. With the default setting of BWA-MEM, one\nand only one line is primary and is soft clipped; other lines are tagged with\n0x800 SAM flag (supplementary alignment) and are hard clipped.\n\n#### <a name=\"4gb\"></a>3. Does BWA work on reference sequences longer than 4GB in total?\n\nYes. Since 0.6.x, all BWA algorithms work with a genome with total length over\n4GB. However, individual chromosome should not be longer than 2GB.\n\n#### <a name=\"pe0\"></a>4. Why can one read in a pair have a high mapping quality but the other has zero?\n\nThis is correct. Mapping quality is assigned for individual read, not for a read\npair. It is possible that one read can be mapped unambiguously, but its mate\nfalls in a tandem repeat and thus its accurate position cannot be determined.\n\n#### <a name=\"endref\"></a>5. How can a BWA-backtrack alignment stand out of the end of a chromosome?\n\nInternally BWA concatenates all reference sequences into one long sequence. A\nread may be mapped to the junction of two adjacent reference sequences. In this\ncase, BWA-backtrack will flag the read as unmapped (0x4), but you will see\nposition, CIGAR and all the tags. A similar issue may occur to BWA-SW alignment\nas well. BWA-MEM does not have this problem.\n\n#### <a name=\"altctg\"></a>6. Does BWA work with ALT contigs in the GRCh38 release?\n\nYes, since 0.7.11, BWA-MEM officially supports mapping to GRCh38+ALT.\nBWA-backtrack and BWA-SW don't properly support ALT mapping as of now. Please\nsee [README-alt.md][18] for details. Briefly, it is recommended to use\n[bwakit][17], the binary release of BWA, for generating the reference genome\nand for mapping.\n\n#### <a name=\"postalt\"></a>7. Can I just run BWA-MEM against GRCh38+ALT without post-processing?\n\nIf you are not interested in hits to ALT contigs, it is okay to run BWA-MEM\nwithout post-processing. The alignments produced this way are very close to\nalignments against GRCh38 without ALT contigs. Nonetheless, applying\npost-processing helps to reduce false mappings caused by reads from the\ndiverged part of ALT contigs and also enables HLA typing. It is recommended to\nrun the post-processing script.\n\n\n\n[1]: http://en.wikipedia.org/wiki/GNU_General_Public_License\n[2]: https://github.com/lh3/bwa\n[3]: http://sourceforge.net/projects/bio-bwa/files/\n[4]: http://bio-bwa.sourceforge.net/bwa.shtml\n[5]: http://bio-bwa.sourceforge.net/\n[6]: https://lists.sourceforge.net/lists/listinfo/bio-bwa-help\n[7]: mailto:bio-bwa-help@sourceforge.net\n[8]: http://biostars.org\n[9]: http://seqanswers.com/\n[10]: http://www.ncbi.nlm.nih.gov/pubmed/19451168\n[11]: http://www.ncbi.nlm.nih.gov/pubmed/20080505\n[12]: http://arxiv.org/abs/1303.3997\n[13]: http://arxiv.org/\n[14]: http://zlib.net/\n[15]: https://github.com/lh3/bwa/tree/mem\n[16]: ftp://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh38/seqs_for_alignment_pipelines/\n[17]: http://sourceforge.net/projects/bio-bwa/files/bwakit/\n[18]: https://github.com/lh3/bwa/blob/master/README-alt.md\n"
        },
        {
          "name": "bamlite.c",
          "type": "blob",
          "size": 5.955078125,
          "content": "#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"bamlite.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n/*********************\n * from bam_endian.c *\n *********************/\n\nstatic inline int bam_is_big_endian()\n{\n\tlong one= 1;\n\treturn !(*((char *)(&one)));\n}\nstatic inline uint16_t bam_swap_endian_2(uint16_t v)\n{\n\treturn (uint16_t)(((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8));\n}\nstatic inline void *bam_swap_endian_2p(void *x)\n{\n\t*(uint16_t*)x = bam_swap_endian_2(*(uint16_t*)x);\n\treturn x;\n}\nstatic inline uint32_t bam_swap_endian_4(uint32_t v)\n{\n\tv = ((v & 0x0000FFFFU) << 16) | (v >> 16);\n\treturn ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);\n}\nstatic inline void *bam_swap_endian_4p(void *x)\n{\n\t*(uint32_t*)x = bam_swap_endian_4(*(uint32_t*)x);\n\treturn x;\n}\nstatic inline uint64_t bam_swap_endian_8(uint64_t v)\n{\n\tv = ((v & 0x00000000FFFFFFFFLLU) << 32) | (v >> 32);\n\tv = ((v & 0x0000FFFF0000FFFFLLU) << 16) | ((v & 0xFFFF0000FFFF0000LLU) >> 16);\n\treturn ((v & 0x00FF00FF00FF00FFLLU) << 8) | ((v & 0xFF00FF00FF00FF00LLU) >> 8);\n}\nstatic inline void *bam_swap_endian_8p(void *x)\n{\n\t*(uint64_t*)x = bam_swap_endian_8(*(uint64_t*)x);\n\treturn x;\n}\n\n/**************\n * from bam.c *\n **************/\n\nint bam_is_be;\n\nbam_header_t *bam_header_init()\n{\n\tbam_is_be = bam_is_big_endian();\n\treturn (bam_header_t*)calloc(1, sizeof(bam_header_t));\n}\n\nvoid bam_header_destroy(bam_header_t *header)\n{\n\tint32_t i;\n\tif (header == 0) return;\n\tif (header->target_name) {\n\t\tfor (i = 0; i < header->n_targets; ++i)\n\t\t\tif (header->target_name[i]) free(header->target_name[i]);\n\t\tif (header->target_len) free(header->target_len);\n\t\tfree(header->target_name);\n\t}\n\tif (header->text) free(header->text);\n\tfree(header);\n}\n\nbam_header_t *bam_header_read(bamFile fp)\n{\n\tbam_header_t *header;\n\tchar buf[4];\n\tint magic_len;\n\tint32_t i = 1, name_len;\n\t// read \"BAM1\"\n\tmagic_len = bam_read(fp, buf, 4);\n\tif (magic_len != 4 || strncmp(buf, \"BAM\\001\", 4) != 0) {\n\t\tfprintf(stderr, \"[bam_header_read] invalid BAM binary header (this is not a BAM file).\\n\");\n\t\treturn NULL;\n\t}\n\theader = bam_header_init();\n\t// read plain text and the number of reference sequences\n\tif (bam_read(fp, &header->l_text, 4) != 4) goto fail; \n\tif (bam_is_be) bam_swap_endian_4p(&header->l_text);\n\theader->text = (char*)calloc(header->l_text + 1, 1);\n\tif (bam_read(fp, header->text, header->l_text) != header->l_text) goto fail;\n\tif (bam_read(fp, &header->n_targets, 4) != 4) goto fail;\n\tif (bam_is_be) bam_swap_endian_4p(&header->n_targets);\n\t// read reference sequence names and lengths\n\theader->target_name = (char**)calloc(header->n_targets, sizeof(char*));\n\theader->target_len = (uint32_t*)calloc(header->n_targets, 4);\n\tfor (i = 0; i != header->n_targets; ++i) {\n\t\tif (bam_read(fp, &name_len, 4) != 4) goto fail;\n\t\tif (bam_is_be) bam_swap_endian_4p(&name_len);\n\t\theader->target_name[i] = (char*)calloc(name_len, 1);\n\t\tif (bam_read(fp, header->target_name[i], name_len) != name_len) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif (bam_read(fp, &header->target_len[i], 4) != 4) goto fail;\n\t\tif (bam_is_be) bam_swap_endian_4p(&header->target_len[i]);\n\t}\n\treturn header;\n fail:\n\tbam_header_destroy(header);\n\treturn NULL;\n}\n\nstatic void swap_endian_data(const bam1_core_t *c, int data_len, uint8_t *data)\n{\n\tuint8_t *s;\n\tuint32_t i, *cigar = (uint32_t*)(data + c->l_qname);\n\ts = data + c->n_cigar*4 + c->l_qname + c->l_qseq + (c->l_qseq + 1)/2;\n\tfor (i = 0; i < c->n_cigar; ++i) bam_swap_endian_4p(&cigar[i]);\n\twhile (s < data + data_len) {\n\t\tuint8_t type;\n\t\ts += 2; // skip key\n\t\ttype = toupper(*s); ++s; // skip type\n\t\tif (type == 'C' || type == 'A') ++s;\n\t\telse if (type == 'S') { bam_swap_endian_2p(s); s += 2; }\n\t\telse if (type == 'I' || type == 'F') { bam_swap_endian_4p(s); s += 4; }\n\t\telse if (type == 'D') { bam_swap_endian_8p(s); s += 8; }\n\t\telse if (type == 'Z' || type == 'H') { while (*s) ++s; ++s; }\n\t}\n}\n\nint bam_read1(bamFile fp, bam1_t *b)\n{\n\tbam1_core_t *c = &b->core;\n\tint32_t block_len, ret, i;\n\tuint32_t x[8];\n\n\tif ((ret = bam_read(fp, &block_len, 4)) != 4) {\n\t\tif (ret == 0) return -1; // normal end-of-file\n\t\telse return -2; // truncated\n\t}\n\tif (bam_read(fp, x, sizeof(bam1_core_t)) != sizeof(bam1_core_t)) return -3;\n\tif (bam_is_be) {\n\t\tbam_swap_endian_4p(&block_len);\n\t\tfor (i = 0; i < 8; ++i) bam_swap_endian_4p(x + i);\n\t}\n\tc->tid = x[0]; c->pos = x[1];\n\tc->bin = x[2]>>16; c->qual = x[2]>>8&0xff; c->l_qname = x[2]&0xff;\n\tc->flag = x[3]>>16; c->n_cigar = x[3]&0xffff;\n\tc->l_qseq = x[4];\n\tc->mtid = x[5]; c->mpos = x[6]; c->isize = x[7];\n\tb->data_len = block_len - sizeof(bam1_core_t);\n\tif (b->m_data < b->data_len) {\n\t\tb->m_data = b->data_len;\n\t\tkroundup32(b->m_data);\n\t\tb->data = (uint8_t*)realloc(b->data, b->m_data);\n\t}\n\tif (bam_read(fp, b->data, b->data_len) != b->data_len) return -4;\n\tb->l_aux = b->data_len - c->n_cigar * 4 - c->l_qname - c->l_qseq - (c->l_qseq+1)/2;\n\tif (bam_is_be) swap_endian_data(c, b->data_len, b->data);\n\treturn 4 + block_len;\n}\n\n\n#ifdef USE_VERBOSE_ZLIB_WRAPPERS\n// Versions of gzopen, gzread and gzclose that print up error messages\n\ngzFile bamlite_gzopen(const char *fn, const char *mode) {\n\tgzFile fp;\n\tif (strcmp(fn, \"-\") == 0) {\n\t\tfp = gzdopen(fileno((strstr(mode, \"r\"))? stdin : stdout), mode);\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Couldn't open %s : %s\",\n\t\t\t\t\t(strstr(mode, \"r\"))? \"stdin\" : \"stdout\",\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t\treturn fp;\n\t}\n\tif ((fp = gzopen(fn, mode)) == 0) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\", fn,\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t}\n\treturn fp;\n}\n\nint bamlite_gzread(gzFile file, void *ptr, unsigned int len) {\n\tint ret = gzread(file, ptr, len);\n\t\n\tif (ret < 0) {\n\t\tint errnum = 0;\n\t\tconst char *msg = gzerror(file, &errnum);\n\t\tfprintf(stderr, \"gzread error: %s\\n\",\n\t\t\t\tZ_ERRNO == errnum ? strerror(errno) : msg);\n\t}\n\treturn ret;\n}\n\nint bamlite_gzclose(gzFile file) {\n\tint ret = gzclose(file);\n\tif (Z_OK != ret) {\n\t\tfprintf(stderr, \"gzclose error: %s\\n\",\n\t\t\t\t\t\t  Z_ERRNO == ret ? strerror(errno) : zError(ret));\n\t}\n\t\n\treturn ret;\n}\n#endif /* USE_VERBOSE_ZLIB_WRAPPERS */\n"
        },
        {
          "name": "bamlite.h",
          "type": "blob",
          "size": 3.05078125,
          "content": "#ifndef BAMLITE_H_\n#define BAMLITE_H_\n\n#include <stdint.h>\n#include <zlib.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define USE_VERBOSE_ZLIB_WRAPPERS\n\ntypedef gzFile bamFile;\n#ifdef USE_VERBOSE_ZLIB_WRAPPERS\n/* These print error messages on failure */\n#  define bam_open(fn, mode)      bamlite_gzopen(fn, mode)\n#  define bam_dopen(fd, mode)     gzdopen(fd, mode)\n#  define bam_close(fp)           bamlite_gzclose(fp)\n#  define bam_read(fp, buf, size) bamlite_gzread(fp, buf, size)\n#else\n#  define bam_open(fn, mode)      gzopen(fn, mode)\n#  define bam_dopen(fd, mode)     gzdopen(fd, mode)\n#  define bam_close(fp)           gzclose(fp)\n#  define bam_read(fp, buf, size) gzread(fp, buf, size)\n#endif /* USE_VERBOSE_ZLIB_WRAPPERS */\n\ntypedef struct {\n\tint32_t n_targets;\n\tchar **target_name;\n\tuint32_t *target_len;\n\tsize_t l_text, n_text;\n\tchar *text;\n} bam_header_t;\n\n#define BAM_FPAIRED        1\n#define BAM_FPROPER_PAIR   2\n#define BAM_FUNMAP         4\n#define BAM_FMUNMAP        8\n#define BAM_FREVERSE      16\n#define BAM_FMREVERSE     32\n#define BAM_FREAD1        64\n#define BAM_FREAD2       128\n#define BAM_FSECONDARY   256\n#define BAM_FQCFAIL      512\n#define BAM_FDUP        1024\n\n#define BAM_CIGAR_SHIFT 4\n#define BAM_CIGAR_MASK  ((1 << BAM_CIGAR_SHIFT) - 1)\n\n#define BAM_CMATCH      0\n#define BAM_CINS        1\n#define BAM_CDEL        2\n#define BAM_CREF_SKIP   3\n#define BAM_CSOFT_CLIP  4\n#define BAM_CHARD_CLIP  5\n#define BAM_CPAD        6\n\ntypedef struct {\n\tint32_t tid;\n\tint32_t pos;\n\tuint32_t bin:16, qual:8, l_qname:8;\n\tuint32_t flag:16, n_cigar:16;\n\tint32_t l_qseq;\n\tint32_t mtid;\n\tint32_t mpos;\n\tint32_t isize;\n} bam1_core_t;\n\ntypedef struct {\n\tbam1_core_t core;\n\tint l_aux, data_len, m_data;\n\tuint8_t *data;\n} bam1_t;\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#define bam1_strand(b) (((b)->core.flag&BAM_FREVERSE) != 0)\n#define bam1_mstrand(b) (((b)->core.flag&BAM_FMREVERSE) != 0)\n#define bam1_cigar(b) ((uint32_t*)((b)->data + (b)->core.l_qname))\n#define bam1_qname(b) ((char*)((b)->data))\n#define bam1_seq(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname)\n#define bam1_qual(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname + (((b)->core.l_qseq + 1)>>1))\n#define bam1_seqi(s, i) ((s)[(i)/2] >> 4*(1-(i)%2) & 0xf)\n#define bam1_aux(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname + (b)->core.l_qseq + ((b)->core.l_qseq + 1)/2)\n\n#define bam_init1() ((bam1_t*)calloc(1, sizeof(bam1_t)))\n#define bam_destroy1(b) do {\t\t\t\t\t\\\n\t\tif (b) { free((b)->data); free(b); }\t\\\n\t} while (0)\n\nextern int bam_is_be;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tbam_header_t *bam_header_init(void);\n\tvoid bam_header_destroy(bam_header_t *header);\n\tbam_header_t *bam_header_read(bamFile fp);\n\tint bam_read1(bamFile fp, bam1_t *b);\n\n#ifdef USE_VERBOSE_ZLIB_WRAPPERS\n\tgzFile bamlite_gzopen(const char *fn, const char *mode);\n\tint bamlite_gzread(gzFile file, void *ptr, unsigned int len);\n\tint bamlite_gzclose(gzFile file);\n#endif /* USE_VERBOSE_ZLIB_WRAPPERS */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bntseq.c",
          "type": "blob",
          "size": 13.66015625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <zlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"bntseq.h\"\n#include \"utils.h\"\n\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\n#include \"khash.h\"\nKHASH_MAP_INIT_STR(str, int)\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nunsigned char nst_nt4_table[256] = {\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 5 /*'-'*/, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4\n};\n\nvoid bns_dump(const bntseq_t *bns, const char *prefix)\n{\n\tchar str[1024];\n\tFILE *fp;\n\tint i;\n\t{ // dump .ann\n\t\tstrcpy(str, prefix); strcat(str, \".ann\");\n\t\tfp = xopen(str, \"w\");\n\t\terr_fprintf(fp, \"%lld %d %u\\n\", (long long)bns->l_pac, bns->n_seqs, bns->seed);\n\t\tfor (i = 0; i != bns->n_seqs; ++i) {\n\t\t\tbntann1_t *p = bns->anns + i;\n\t\t\terr_fprintf(fp, \"%d %s\", p->gi, p->name);\n\t\t\tif (p->anno[0]) err_fprintf(fp, \" %s\\n\", p->anno);\n\t\t\telse err_fprintf(fp, \"\\n\");\n\t\t\terr_fprintf(fp, \"%lld %d %d\\n\", (long long)p->offset, p->len, p->n_ambs);\n\t\t}\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n\t{ // dump .amb\n\t\tstrcpy(str, prefix); strcat(str, \".amb\");\n\t\tfp = xopen(str, \"w\");\n\t\terr_fprintf(fp, \"%lld %d %u\\n\", (long long)bns->l_pac, bns->n_seqs, bns->n_holes);\n\t\tfor (i = 0; i != bns->n_holes; ++i) {\n\t\t\tbntamb1_t *p = bns->ambs + i;\n\t\t\terr_fprintf(fp, \"%lld %d %c\\n\", (long long)p->offset, p->len, p->amb);\n\t\t}\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n}\n\nbntseq_t *bns_restore_core(const char *ann_filename, const char* amb_filename, const char* pac_filename)\n{\n\tchar str[8192];\n\tFILE *fp;\n\tconst char *fname;\n\tbntseq_t *bns;\n\tlong long xx;\n\tint i;\n\tint scanres;\n\tbns = (bntseq_t*)calloc(1, sizeof(bntseq_t));\n\t{ // read .ann\n\t\tfp = xopen(fname = ann_filename, \"r\");\n\t\tscanres = fscanf(fp, \"%lld%d%u\", &xx, &bns->n_seqs, &bns->seed);\n\t\tif (scanres != 3) goto badread;\n\t\tbns->l_pac = xx;\n\t\tbns->anns = (bntann1_t*)calloc(bns->n_seqs, sizeof(bntann1_t));\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tbntann1_t *p = bns->anns + i;\n\t\t\tchar *q = str;\n\t\t\tint c;\n\t\t\t// read gi and sequence name\n\t\t\tscanres = fscanf(fp, \"%u%s\", &p->gi, str);\n\t\t\tif (scanres != 2) goto badread;\n\t\t\tp->name = strdup(str);\n\t\t\t// read fasta comments \n\t\t\twhile (q - str < sizeof(str) - 1 && (c = fgetc(fp)) != '\\n' && c != EOF) *q++ = c;\n\t\t\twhile (c != '\\n' && c != EOF) c = fgetc(fp);\n\t\t\tif (c == EOF) {\n\t\t\t\tscanres = EOF;\n\t\t\t\tgoto badread;\n\t\t\t}\n\t\t\t*q = 0;\n\t\t\tif (q - str > 1 && strcmp(str, \" (null)\") != 0) p->anno = strdup(str + 1); // skip leading space\n\t\t\telse p->anno = strdup(\"\");\n\t\t\t// read the rest\n\t\t\tscanres = fscanf(fp, \"%lld%d%d\", &xx, &p->len, &p->n_ambs);\n\t\t\tif (scanres != 3) goto badread;\n\t\t\tp->offset = xx;\n\t\t}\n\t\terr_fclose(fp);\n\t}\n\t{ // read .amb\n\t\tint64_t l_pac;\n\t\tint32_t n_seqs;\n\t\tfp = xopen(fname = amb_filename, \"r\");\n\t\tscanres = fscanf(fp, \"%lld%d%d\", &xx, &n_seqs, &bns->n_holes);\n\t\tif (scanres != 3) goto badread;\n\t\tl_pac = xx;\n\t\txassert(l_pac == bns->l_pac && n_seqs == bns->n_seqs, \"inconsistent .ann and .amb files.\");\n\t\tbns->ambs = bns->n_holes? (bntamb1_t*)calloc(bns->n_holes, sizeof(bntamb1_t)) : 0;\n\t\tfor (i = 0; i < bns->n_holes; ++i) {\n\t\t\tbntamb1_t *p = bns->ambs + i;\n\t\t\tscanres = fscanf(fp, \"%lld%d%s\", &xx, &p->len, str);\n\t\t\tif (scanres != 3) goto badread;\n\t\t\tp->offset = xx;\n\t\t\tp->amb = str[0];\n\t\t}\n\t\terr_fclose(fp);\n\t}\n\t{ // open .pac\n\t\tbns->fp_pac = xopen(pac_filename, \"rb\");\n\t}\n\treturn bns;\n\n badread:\n\tif (EOF == scanres) {\n\t\terr_fatal(__func__, \"Error reading %s : %s\\n\", fname, ferror(fp) ? strerror(errno) : \"Unexpected end of file\");\n\t}\n\terr_fatal(__func__, \"Parse error reading %s\\n\", fname);\n}\n\nbntseq_t *bns_restore(const char *prefix)\n{  \n\tchar ann_filename[1024], amb_filename[1024], pac_filename[1024], alt_filename[1024];\n\tFILE *fp;\n\tbntseq_t *bns;\n\tstrcat(strcpy(ann_filename, prefix), \".ann\");\n\tstrcat(strcpy(amb_filename, prefix), \".amb\");\n\tstrcat(strcpy(pac_filename, prefix), \".pac\");\n\tbns = bns_restore_core(ann_filename, amb_filename, pac_filename);\n\tif (bns == 0) return 0;\n\tif ((fp = fopen(strcat(strcpy(alt_filename, prefix), \".alt\"), \"r\")) != 0) { // read .alt file if present\n\t\tchar str[1024];\n\t\tkhash_t(str) *h;\n\t\tint c, i, absent;\n\t\tkhint_t k;\n\t\th = kh_init(str);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tk = kh_put(str, h, bns->anns[i].name, &absent);\n\t\t\tkh_val(h, k) = i;\n\t\t}\n\t\ti = 0;\n\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\tif (c == '\\t' || c == '\\n' || c == '\\r') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tif (str[0] != '@') {\n\t\t\t\t\tk = kh_get(str, h, str);\n\t\t\t\t\tif (k != kh_end(h))\n\t\t\t\t\t\tbns->anns[kh_val(h, k)].is_alt = 1;\n\t\t\t\t}\n\t\t\t\twhile (c != '\\n' && c != EOF) c = fgetc(fp);\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tif (i >= 1022) {\n\t\t\t\t\tfprintf(stderr, \"[E::%s] sequence name longer than 1023 characters. Abort!\\n\", __func__);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tstr[i++] = c;\n\t\t\t}\n\t\t}\n\t\tkh_destroy(str, h);\n\t\tfclose(fp);\n\t}\n\treturn bns;\n}\n\nvoid bns_destroy(bntseq_t *bns)\n{\n\tif (bns == 0) return;\n\telse {\n\t\tint i;\n\t\tif (bns->fp_pac) err_fclose(bns->fp_pac);\n\t\tfree(bns->ambs);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tfree(bns->anns[i].name);\n\t\t\tfree(bns->anns[i].anno);\n\t\t}\n\t\tfree(bns->anns);\n\t\tfree(bns);\n\t}\n}\n\n#define _set_pac(pac, l, c) ((pac)[(l)>>2] |= (c)<<((~(l)&3)<<1))\n#define _get_pac(pac, l) ((pac)[(l)>>2]>>((~(l)&3)<<1)&3)\n\nstatic uint8_t *add1(const kseq_t *seq, bntseq_t *bns, uint8_t *pac, int64_t *m_pac, int *m_seqs, int *m_holes, bntamb1_t **q)\n{\n\tbntann1_t *p;\n\tint i, lasts;\n\tif (bns->n_seqs == *m_seqs) {\n\t\t*m_seqs <<= 1;\n\t\tbns->anns = (bntann1_t*)realloc(bns->anns, *m_seqs * sizeof(bntann1_t));\n\t}\n\tp = bns->anns + bns->n_seqs;\n\tp->name = strdup((char*)seq->name.s);\n\tp->anno = seq->comment.l > 0? strdup((char*)seq->comment.s) : strdup(\"(null)\");\n\tp->gi = 0; p->len = seq->seq.l;\n\tp->offset = (bns->n_seqs == 0)? 0 : (p-1)->offset + (p-1)->len;\n\tp->n_ambs = 0;\n\tfor (i = lasts = 0; i < seq->seq.l; ++i) {\n\t\tint c = nst_nt4_table[(int)seq->seq.s[i]];\n\t\tif (c >= 4) { // N\n\t\t\tif (lasts == seq->seq.s[i]) { // contiguous N\n\t\t\t\t++(*q)->len;\n\t\t\t} else {\n\t\t\t\tif (bns->n_holes == *m_holes) {\n\t\t\t\t\t(*m_holes) <<= 1;\n\t\t\t\t\tbns->ambs = (bntamb1_t*)realloc(bns->ambs, (*m_holes) * sizeof(bntamb1_t));\n\t\t\t\t}\n\t\t\t\t*q = bns->ambs + bns->n_holes;\n\t\t\t\t(*q)->len = 1;\n\t\t\t\t(*q)->offset = p->offset + i;\n\t\t\t\t(*q)->amb = seq->seq.s[i];\n\t\t\t\t++p->n_ambs;\n\t\t\t\t++bns->n_holes;\n\t\t\t}\n\t\t}\n\t\tlasts = seq->seq.s[i];\n\t\t{ // fill buffer\n\t\t\tif (c >= 4) c = lrand48()&3;\n\t\t\tif (bns->l_pac == *m_pac) { // double the pac size\n\t\t\t\t*m_pac <<= 1;\n\t\t\t\tpac = realloc(pac, *m_pac/4);\n\t\t\t\tmemset(pac + bns->l_pac/4, 0, (*m_pac - bns->l_pac)/4);\n\t\t\t}\n\t\t\t_set_pac(pac, bns->l_pac, c);\n\t\t\t++bns->l_pac;\n\t\t}\n\t}\n\t++bns->n_seqs;\n\treturn pac;\n}\n\nint64_t bns_fasta2bntseq(gzFile fp_fa, const char *prefix, int for_only)\n{\n\textern void seq_reverse(int len, ubyte_t *seq, int is_comp); // in bwaseqio.c\n\tkseq_t *seq;\n\tchar name[1024];\n\tbntseq_t *bns;\n\tuint8_t *pac = 0;\n\tint32_t m_seqs, m_holes;\n\tint64_t ret = -1, m_pac, l;\n\tbntamb1_t *q;\n\tFILE *fp;\n\n\t// initialization\n\tseq = kseq_init(fp_fa);\n\tbns = (bntseq_t*)calloc(1, sizeof(bntseq_t));\n\tbns->seed = 11; // fixed seed for random generator\n\tsrand48(bns->seed);\n\tm_seqs = m_holes = 8; m_pac = 0x10000;\n\tbns->anns = (bntann1_t*)calloc(m_seqs, sizeof(bntann1_t));\n\tbns->ambs = (bntamb1_t*)calloc(m_holes, sizeof(bntamb1_t));\n\tpac = calloc(m_pac/4, 1);\n\tq = bns->ambs;\n\tstrcpy(name, prefix); strcat(name, \".pac\");\n\tfp = xopen(name, \"wb\");\n\t// read sequences\n\twhile (kseq_read(seq) >= 0) pac = add1(seq, bns, pac, &m_pac, &m_seqs, &m_holes, &q);\n\tif (!for_only) { // add the reverse complemented sequence\n\t\tint64_t ll_pac = (bns->l_pac * 2 + 3) / 4 * 4;\n\t\tif (ll_pac > m_pac) pac = realloc(pac, ll_pac/4);\n\t\tmemset(pac + (bns->l_pac+3)/4, 0, (ll_pac - (bns->l_pac+3)/4*4) / 4);\n\t\tfor (l = bns->l_pac - 1; l >= 0; --l, ++bns->l_pac)\n\t\t\t_set_pac(pac, bns->l_pac, 3-_get_pac(pac, l));\n\t}\n\tret = bns->l_pac;\n\t{ // finalize .pac file\n\t\tubyte_t ct;\n\t\terr_fwrite(pac, 1, (bns->l_pac>>2) + ((bns->l_pac&3) == 0? 0 : 1), fp);\n\t\t// the following codes make the pac file size always (l_pac/4+1+1)\n\t\tif (bns->l_pac % 4 == 0) {\n\t\t\tct = 0;\n\t\t\terr_fwrite(&ct, 1, 1, fp);\n\t\t}\n\t\tct = bns->l_pac % 4;\n\t\terr_fwrite(&ct, 1, 1, fp);\n\t\t// close .pac file\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n\tbns_dump(bns, prefix);\n\tbns_destroy(bns);\n\tkseq_destroy(seq);\n\tfree(pac);\n\treturn ret;\n}\n\nint bwa_fa2pac(int argc, char *argv[])\n{\n\tint c, for_only = 0;\n\tgzFile fp;\n\twhile ((c = getopt(argc, argv, \"f\")) >= 0) {\n\t\tswitch (c) {\n\t\t\tcase 'f': for_only = 1; break;\n\t\t}\n\t}\n\tif (argc == optind) {\n\t\tfprintf(stderr, \"Usage: bwa fa2pac [-f] <in.fasta> [<out.prefix>]\\n\");\n\t\treturn 1;\n\t}\n\tfp = xzopen(argv[optind], \"r\");\n\tbns_fasta2bntseq(fp, (optind+1 < argc)? argv[optind+1] : argv[optind], for_only);\n\terr_gzclose(fp);\n\treturn 0;\n}\n\nint bns_pos2rid(const bntseq_t *bns, int64_t pos_f)\n{\n\tint left, mid, right;\n\tif (pos_f >= bns->l_pac) return -1;\n\tleft = 0; mid = 0; right = bns->n_seqs;\n\twhile (left < right) { // binary search\n\t\tmid = (left + right) >> 1;\n\t\tif (pos_f >= bns->anns[mid].offset) {\n\t\t\tif (mid == bns->n_seqs - 1) break;\n\t\t\tif (pos_f < bns->anns[mid+1].offset) break; // bracketed\n\t\t\tleft = mid + 1;\n\t\t} else right = mid;\n\t}\n\treturn mid;\n}\n\nint bns_intv2rid(const bntseq_t *bns, int64_t rb, int64_t re)\n{\n\tint is_rev, rid_b, rid_e;\n\tif (rb < bns->l_pac && re > bns->l_pac) return -2;\n\tassert(rb <= re);\n\trid_b = bns_pos2rid(bns, bns_depos(bns, rb, &is_rev));\n\trid_e = rb < re? bns_pos2rid(bns, bns_depos(bns, re - 1, &is_rev)) : rid_b;\n\treturn rid_b == rid_e? rid_b : -1;\n}\n\nint bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)\n{\n\tint left, mid, right, nn;\n\tif (ref_id) *ref_id = bns_pos2rid(bns, pos_f);\n\tleft = 0; right = bns->n_holes; nn = 0;\n\twhile (left < right) {\n\t\tmid = (left + right) >> 1;\n\t\tif (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;\n\t\telse if (pos_f + len <= bns->ambs[mid].offset) right = mid;\n\t\telse { // overlap\n\t\t\tif (pos_f >= bns->ambs[mid].offset) {\n\t\t\t\tnn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?\n\t\t\t\t\tbns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;\n\t\t\t} else {\n\t\t\t\tnn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?\n\t\t\t\t\tbns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nn;\n}\n\nuint8_t *bns_get_seq(int64_t l_pac, const uint8_t *pac, int64_t beg, int64_t end, int64_t *len)\n{\n\tuint8_t *seq = 0;\n\tif (end < beg) end ^= beg, beg ^= end, end ^= beg; // if end is smaller, swap\n\tif (end > l_pac<<1) end = l_pac<<1;\n\tif (beg < 0) beg = 0;\n\tif (beg >= l_pac || end <= l_pac) {\n\t\tint64_t k, l = 0;\n\t\t*len = end - beg;\n\t\tseq = malloc(end - beg);\n\t\tif (beg >= l_pac) { // reverse strand\n\t\t\tint64_t beg_f = (l_pac<<1) - 1 - end;\n\t\t\tint64_t end_f = (l_pac<<1) - 1 - beg;\n\t\t\tfor (k = end_f; k > beg_f; --k)\n\t\t\t\tseq[l++] = 3 - _get_pac(pac, k);\n\t\t} else { // forward strand\n\t\t\tfor (k = beg; k < end; ++k)\n\t\t\t\tseq[l++] = _get_pac(pac, k);\n\t\t}\n\t} else *len = 0; // if bridging the forward-reverse boundary, return nothing\n\treturn seq;\n}\n\nuint8_t *bns_fetch_seq(const bntseq_t *bns, const uint8_t *pac, int64_t *beg, int64_t mid, int64_t *end, int *rid)\n{\n\tint64_t far_beg, far_end, len;\n\tint is_rev;\n\tuint8_t *seq;\n\n\tif (*end < *beg) *end ^= *beg, *beg ^= *end, *end ^= *beg; // if end is smaller, swap\n\tassert(*beg <= mid && mid < *end);\n\t*rid = bns_pos2rid(bns, bns_depos(bns, mid, &is_rev));\n\tfar_beg = bns->anns[*rid].offset;\n\tfar_end = far_beg + bns->anns[*rid].len;\n\tif (is_rev) { // flip to the reverse strand\n\t\tint64_t tmp = far_beg;\n\t\tfar_beg = (bns->l_pac<<1) - far_end;\n\t\tfar_end = (bns->l_pac<<1) - tmp;\n\t}\n\t*beg = *beg > far_beg? *beg : far_beg;\n\t*end = *end < far_end? *end : far_end;\n\tseq = bns_get_seq(bns->l_pac, pac, *beg, *end, &len);\n\tif (seq == 0 || *end - *beg != len) {\n\t\tfprintf(stderr, \"[E::%s] begin=%ld, mid=%ld, end=%ld, len=%ld, seq=%p, rid=%d, far_beg=%ld, far_end=%ld\\n\",\n\t\t\t\t__func__, (long)*beg, (long)mid, (long)*end, (long)len, seq, *rid, (long)far_beg, (long)far_end);\n\t}\n\tassert(seq && *end - *beg == len); // assertion failure should never happen\n\treturn seq;\n}\n"
        },
        {
          "name": "bntseq.h",
          "type": "blob",
          "size": 2.775390625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef BWT_BNTSEQ_H\n#define BWT_BNTSEQ_H\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <zlib.h>\n\n#ifndef BWA_UBYTE\n#define BWA_UBYTE\ntypedef uint8_t ubyte_t;\n#endif\n\ntypedef struct {\n\tint64_t offset;\n\tint32_t len;\n\tint32_t n_ambs;\n\tuint32_t gi;\n\tint32_t is_alt;\n\tchar *name, *anno;\n} bntann1_t;\n\ntypedef struct {\n\tint64_t offset;\n\tint32_t len;\n\tchar amb;\n} bntamb1_t;\n\ntypedef struct {\n\tint64_t l_pac;\n\tint32_t n_seqs;\n\tuint32_t seed;\n\tbntann1_t *anns; // n_seqs elements\n\tint32_t n_holes;\n\tbntamb1_t *ambs; // n_holes elements\n\tFILE *fp_pac;\n} bntseq_t;\n\nextern unsigned char nst_nt4_table[256];\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tvoid bns_dump(const bntseq_t *bns, const char *prefix);\n\tbntseq_t *bns_restore(const char *prefix);\n\tbntseq_t *bns_restore_core(const char *ann_filename, const char* amb_filename, const char* pac_filename);\n\tvoid bns_destroy(bntseq_t *bns);\n\tint64_t bns_fasta2bntseq(gzFile fp_fa, const char *prefix, int for_only);\n\tint bns_pos2rid(const bntseq_t *bns, int64_t pos_f);\n\tint bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id);\n\tuint8_t *bns_get_seq(int64_t l_pac, const uint8_t *pac, int64_t beg, int64_t end, int64_t *len);\n\tuint8_t *bns_fetch_seq(const bntseq_t *bns, const uint8_t *pac, int64_t *beg, int64_t mid, int64_t *end, int *rid);\n\tint bns_intv2rid(const bntseq_t *bns, int64_t rb, int64_t re);\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline int64_t bns_depos(const bntseq_t *bns, int64_t pos, int *is_rev)\n{\n\treturn (*is_rev = (pos >= bns->l_pac))? (bns->l_pac<<1) - 1 - pos : pos;\n}\n\n#endif\n"
        },
        {
          "name": "bwa.1",
          "type": "blob",
          "size": 26.73046875,
          "content": ".TH bwa 1 \"14 April 2023\" \"bwa-0.7.18-r1243\" \"Bioinformatics tools\"\n.SH NAME\n.PP\nbwa - Burrows-Wheeler Alignment Tool\n.SH SYNOPSIS\n.PP\nbwa index ref.fa\n.PP\nbwa mem ref.fa reads.fq > aln-se.sam\n.PP\nbwa mem ref.fa read1.fq read2.fq > aln-pe.sam\n.PP\nbwa aln ref.fa short_read.fq > aln_sa.sai\n.PP\nbwa samse ref.fa aln_sa.sai short_read.fq > aln-se.sam\n.PP\nbwa sampe ref.fa aln_sa1.sai aln_sa2.sai read1.fq read2.fq > aln-pe.sam\n.PP\nbwa bwasw ref.fa long_read.fq > aln.sam\n\n.SH DESCRIPTION\n.PP\nBWA is a software package for mapping low-divergent sequences against a large\nreference genome, such as the human genome. It consists of three algorithms:\nBWA-backtrack, BWA-SW and BWA-MEM. The first algorithm is designed for Illumina\nsequence reads up to 100bp, while the rest two for longer sequences ranged from\n70bp to 1Mbp. BWA-MEM and BWA-SW share similar features such as long-read\nsupport and split alignment, but BWA-MEM, which is the latest, is generally\nrecommended for high-quality queries as it is faster and more accurate.\nBWA-MEM also has better performance than BWA-backtrack for 70-100bp Illumina\nreads.\n\nFor all the algorithms, BWA first needs to construct the FM-index for\nthe reference genome (the\n.B index\ncommand). Alignment algorithms are invoked with different sub-commands:\n.BR aln / samse / sampe\nfor BWA-backtrack,\n.B bwasw\nfor BWA-SW and\n.B mem\nfor the BWA-MEM algorithm.\n\n.SH COMMANDS AND OPTIONS\n.TP\n.B index\n.B bwa index\n.RB [ -p\n.IR prefix ]\n.RB [ -a\n.IR algoType ]\n.I db.fa\n\nIndex database sequences in the FASTA format.\n\n.B OPTIONS:\n.RS\n.TP 10\n.BI -p \\ STR\nPrefix of the output database [same as db filename]\n.TP\n.BI -a \\ STR\nAlgorithm for constructing BWT index. BWA implements three algorithms for BWT\nconstruction:\n.BR is ,\n.B bwtsw\nand\n.BR rb2 .\nThe first algorithm is a little faster for small database but requires large\nRAM and does not work for databases with total length longer than 2GB. The\nsecond algorithm is adapted from the BWT-SW source code. It in theory works\nwith database with trillions of bases. When this option is not specified, the\nappropriate algorithm will be chosen automatically.\n.RE\n\n.TP\n.B mem\n.B bwa mem\n.RB [ -aCHjMpP ]\n.RB [ -t\n.IR nThreads ]\n.RB [ -k\n.IR minSeedLen ]\n.RB [ -w\n.IR bandWidth ]\n.RB [ -d\n.IR zDropoff ]\n.RB [ -r\n.IR seedSplitRatio ]\n.RB [ -c\n.IR maxOcc ]\n.RB [ -D\n.IR chainShadow ]\n.RB [ -m\n.IR maxMateSW ]\n.RB [ -W\n.IR minSeedMatch ]\n.RB [ -A\n.IR matchScore ]\n.RB [ -B\n.IR mmPenalty ]\n.RB [ -O\n.IR gapOpenPen ]\n.RB [ -E\n.IR gapExtPen ]\n.RB [ -L\n.IR clipPen ]\n.RB [ -U\n.IR unpairPen ]\n.RB [ -x\n.IR readType ]\n.RB [ -R\n.IR RGline ]\n.RB [ -H\n.IR HDlines ]\n.RB [ -v\n.IR verboseLevel ]\n.I db.prefix\n.I reads.fq\n.RI [ mates.fq ]\n\nAlign 70bp-1Mbp query sequences with the BWA-MEM algorithm. Briefly, the\nalgorithm works by seeding alignments with maximal exact matches (MEMs) and\nthen extending seeds with the affine-gap Smith-Waterman algorithm (SW).\n\nIf\n.I mates.fq\nfile is absent and option\n.B -p\nis not set, this command regards input reads are single-end. If\n.I mates.fq\nis present, this command assumes the\n.IR i -th\nread in\n.I reads.fq\nand the\n.IR i -th\nread in\n.I mates.fq\nconstitute a read pair. If\n.B -p\nis used, the command assumes the\n.RI 2 i -th\nand the\n.RI (2 i +1)-th\nread in\n.I reads.fq\nconstitute a read pair (such input file is said to be interleaved). In this case,\n.I mates.fq\nis ignored. In the paired-end mode, the\n.B mem\ncommand will infer the read orientation and the insert size distribution from a\nbatch of reads.\n\nThe BWA-MEM algorithm performs local alignment. It may produce multiple primary\nalignments for different part of a query sequence. This is a crucial feature\nfor long sequences. However, some tools may not work with split alignments. \nOne may consider to use option\n.B -M\nto flag shorter split hits as secondary.\n\n.RS\n.TP 10\n.B ALGORITHM OPTIONS:\n.TP\n.BI -t \\ INT\nNumber of threads [1]\n.TP\n.BI -k \\ INT\nMinimum seed length. Matches shorter than\n.I INT\nwill be missed. The alignment speed is usually insensitive to this value unless\nit significantly deviates from 20. [19]\n.TP\n.BI -w \\ INT\nBand width. Essentially, gaps longer than\n.I INT\nwill not be found. Note that the maximum gap length is also affected by the\nscoring matrix and the hit length, not solely determined by this option. [100]\n.TP\n.BI -d \\ INT\nOff-diagonal X-dropoff (Z-dropoff). Stop extension when the difference between\nthe best and the current extension score is above\n.RI | i - j |* A + INT ,\nwhere\n.I i\nand\n.I j\nare the current positions of the query and reference, respectively, and\n.I A\nis the matching score. Z-dropoff is similar to BLAST's X-dropoff except that it\ndoesn't penalize gaps in one of the sequences in the alignment. Z-dropoff not\nonly avoids unnecessary extension, but also reduces poor alignments inside a\nlong good alignment. [100]\n.TP\n.BI -r \\ FLOAT\nTrigger re-seeding for a MEM longer than\n.IR minSeedLen * FLOAT .\nThis is a key heuristic parameter for tuning the performance. Larger value\nyields fewer seeds, which leads to faster alignment speed but lower accuracy. [1.5]\n.TP\n.BI -c \\ INT\nDiscard a MEM if it has more than\n.I INT\noccurence in the genome. This is an insensitive parameter. [500]\n.TP\n.BI -D \\ FLOAT\nDrop chains shorter than\n.I FLOAT\nfraction of the longest overlapping chain [0.5]\n.TP\n.BI -m \\ INT\nPerform at most\n.I INT\nrounds of mate-SW [50]\n.TP\n.BI -W \\ INT\nDrop a chain if the number of bases in seeds is smaller than\n.IR INT .\nThis option is primarily used for longer contigs/reads. When positive, it also\naffects seed filtering. [0]\n.TP\n.B -P\nIn the paired-end mode, perform SW to rescue missing hits only but do not try to find\nhits that fit a proper pair.\n\n.TP\n.B SCORING OPTIONS:\n.TP\n.BI -A \\ INT\nMatching score. [1]\n.TP\n.BI -B \\ INT\nMismatch penalty. The sequence error rate is approximately: {.75 * exp[-log(4) * B/A]}. [4]\n.TP\n.BI -O \\ INT[,INT]\nGap open penalty. If two numbers are specified, the first is the penalty of\nopenning a deletion and the second for openning an insertion. [6]\n.TP\n.BI -E \\ INT[,INT]\nGap extension penalty. If two numbers are specified, the first is the penalty\nof extending a deletion and second for extending an insertion. A gap of length\nk costs O + k*E (i.e.\n.B -O\nis for opening a zero-length gap). [1]\n.TP\n.BI -L \\ INT[,INT]\nClipping penalty. When performing SW extension, BWA-MEM keeps track of the best\nscore reaching the end of query. If this score is larger than the best SW score\nminus the clipping penalty, clipping will not be applied. Note that in this\ncase, the SAM AS tag reports the best SW score; clipping penalty is not\ndeduced. If two numbers are provided, the first is for 5'-end clipping and\nsecond for 3'-end clipping. [5]\n.TP\n.BI -U \\ INT\nPenalty for an unpaired read pair. BWA-MEM scores an unpaired read pair as\n.RI scoreRead1+scoreRead2- INT\nand scores a paired as scoreRead1+scoreRead2-insertPenalty. It compares these\ntwo scores to determine whether we should force pairing. A larger value leads to\nmore aggressive read pair. [17]\n.TP\n.BI -x \\ STR\nRead type. Changes multiple parameters unless overriden [null]\n.RS\n.TP 10\n.BR pacbio :\n.B -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0\n(PacBio reads to ref)\n.TP\n.BR ont2d :\n.B -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0\n(Oxford Nanopore 2D-reads to ref)\n.TP\n.BR intractg :\n.B -B9 -O16 -L5\n(intra-species contigs to ref)\n.RE\n.TP\n.B INPUT/OUTPUT OPTIONS:\n.TP\n.B -p\nSmart pairing. If two adjacent reads have the same name, they are considered\nto form a read pair. This way, paired-end and single-end reads can be mixed\nin a single FASTA/Q stream.\n.TP\n.BI -R \\ STR\nComplete read group header line. '\\\\t' can be used in\n.I STR\nand will be converted to a TAB in the output SAM. The read group ID will be\nattached to every read in the output. An example is '@RG\\\\tID:foo\\\\tSM:bar'.\n[null]\n.TP\n.BI -H \\ ARG\nIf ARG starts with @, it is interpreted as a string and gets inserted into the\noutput SAM header; otherwise, ARG is interpreted as a file with all lines\nstarting with @ in the file inserted into the SAM header. [null]\n.TP\n.BI -o \\ FILE\nWrite the output SAM file to\n.IR FILE .\nFor compatibility with other BWA commands, this option may also be given as\n.B -f\n.IR FILE .\n[standard ouptut]\n.TP\n.B -q\n Don't reduce the mapping quality of split alignment of lower alignment score.\n.TP\n.B -5\nFor split alignment, mark the segment with the smallest coordinate as the\nprimary. It automatically applies option\n.B -q\nas well. This option may help some Hi-C pipelines. By default, BWA-MEM marks\nhighest scoring segment as primary.\n.TP\n.B -K \\ INT\nProcess\n.I INT\ninput bases in each batch regardless of the number of threads in use\n.RI [10000000* nThreads ].\nBy default, the batch size is proportional to the number of threads in use.\nBecause the inferred insert size distribution slightly depends on the batch\nsize, using different number of threads may produce different output.\nSpecifying this option helps reproducibility.\n.TP\n.BI -T \\ INT\nDon't output alignment with score lower than\n.IR INT .\nThis option affects output and occasionally SAM flag 2. [30]\n.TP\n.BI -j\nTreat ALT contigs as part of the primary assembly (i.e. ignore the\n.I db.prefix.alt\nfile).\n.TP\n.BI -h \\ INT[,INT2]\nIf a query has not more than\n.I INT\nhits with score higher than 80% of the best hit, output them all in the XA tag.\nIf\n.I INT2\nis specified, BWA-MEM outputs up to\n.I INT2\nhits if the list contains a hit to an ALT contig. [5,200]\n.TP\n.B -a\nOutput all found alignments for single-end or unpaired paired-end reads. These\nalignments will be flagged as secondary alignments.\n.TP\n.B -C\nAppend FASTA/Q comment to SAM output. This option can be used to\ntransfer read meta information (e.g. barcode) to the SAM output. Note that the\nFASTA/Q comment (the string after a space in the header line) must conform the SAM\nspec (e.g. BC:Z:CGTAC). Malformated comments lead to incorrect SAM output.\n.TP\n.B -Y\nUse soft clipping CIGAR operation for supplementary alignments. By default, BWA-MEM\nuses soft clipping for the primary alignment and hard clipping for\nsupplementary alignments.\n.TP\n.B -M\nMark shorter split hits as secondary (for Picard compatibility).\n.TP\n.BI -v \\ INT\nControl the verbosity level of the output. This option has not been fully\nsupported throughout BWA. Ideally, a value 0 for disabling all the output to\nstderr; 1 for outputting errors only; 2 for warnings and errors; 3 for\nall normal messages; 4 or higher for debugging. When this option takes value\n4, the output is not SAM. [3]\n.TP\n.BI -I \\ FLOAT[,FLOAT[,INT[,INT]]]\nSpecify the mean, standard deviation (10% of the mean if absent), max (4 sigma\nfrom the mean if absent) and min (4 sigma if absent) of the insert size\ndistribution. Only applicable to the FR orientation. By default, BWA-MEM infers\nthese numbers and the pair orientations given enough reads. [inferred]\n\n.RE\n\n.TP\n.B aln\nbwa aln [-n maxDiff] [-o maxGapO] [-e maxGapE] [-d nDelTail] [-i\nnIndelEnd] [-k maxSeedDiff] [-l seedLen] [-t nThrds] [-cRN] [-M misMsc]\n[-O gapOsc] [-E gapEsc] [-q trimQual] <in.db.fasta> <in.query.fq> >\n<out.sai>\n\nFind the SA coordinates of the input reads. Maximum\n.I maxSeedDiff\ndifferences are allowed in the first\n.I seedLen\nsubsequence and maximum\n.I maxDiff\ndifferences are allowed in the whole sequence.\n\n.B OPTIONS:\n.RS\n.TP 10\n.BI -n \\ NUM\nMaximum edit distance if the value is INT, or the fraction of missing\nalignments given 2% uniform base error rate if FLOAT. In the latter\ncase, the maximum edit distance is automatically chosen for different\nread lengths. [0.04]\n.TP\n.BI -o \\ INT\nMaximum number of gap opens [1]\n.TP\n.BI -e \\ INT\nMaximum number of gap extensions, -1 for k-difference mode (disallowing\nlong gaps) [-1]\n.TP\n.BI -d \\ INT\nDisallow a long deletion within INT bp towards the 3'-end [16]\n.TP\n.BI -i \\ INT\nDisallow an indel within INT bp towards the ends [5]\n.TP\n.BI -l \\ INT\nTake the first INT subsequence as seed. If INT is larger than the query\nsequence, seeding will be disabled. For long reads, this option is\ntypically ranged from 25 to 35 for `-k 2'. [inf]\n.TP\n.BI -k \\ INT\nMaximum edit distance in the seed [2]\n.TP\n.BI -t \\ INT\nNumber of threads (multi-threading mode) [1]\n.TP\n.BI -M \\ INT\nMismatch penalty. BWA will not search for suboptimal hits with a score\nlower than (bestScore-misMsc). [3]\n.TP\n.BI -O \\ INT\nGap open penalty [11]\n.TP\n.BI -E \\ INT\nGap extension penalty [4]\n.TP\n.BI -R \\ INT\nProceed with suboptimal alignments if there are no more than INT equally\nbest hits. This option only affects paired-end mapping. Increasing this\nthreshold helps to improve the pairing accuracy at the cost of speed,\nespecially for short reads (~32bp).\n.TP\n.B -c\nReverse query but not complement it, which is required for alignment in\nthe color space. (Disabled since 0.6.x)\n.TP\n.B -N\nDisable iterative search. All hits with no more than\n.I maxDiff\ndifferences will be found. This mode is much slower than the default.\n.TP\n.BI -q \\ INT\nParameter for read trimming. BWA trims a read down to\nargmax_x{\\\\sum_{i=x+1}^l(INT-q_i)} if q_l<INT where l is the original\nread length. [0]\n.TP\n.B -I\nThe input is in the Illumina 1.3+ read format (quality equals ASCII-64).\n.TP\n.BI -B \\ INT\nLength of barcode starting from the 5'-end. When\n.I INT\nis positive, the barcode of each read will be trimmed before mapping and will\nbe written at the\n.B BC\nSAM tag. For paired-end reads, the barcode from both ends are concatenated. [0]\n.TP\n.B -b\nSpecify the input read sequence file is the BAM format. For paired-end\ndata, two ends in a pair must be grouped together and options\n.B -1\nor\n.B -2\nare usually applied to specify which end should be mapped. Typical\ncommand lines for mapping pair-end data in the BAM format are:\n\n    bwa aln ref.fa -b1 reads.bam > 1.sai\n    bwa aln ref.fa -b2 reads.bam > 2.sai\n    bwa sampe ref.fa 1.sai 2.sai reads.bam reads.bam > aln.sam\n.TP\n.B -0\nWhen\n.B -b\nis specified, only use single-end reads in mapping.\n.TP\n.B -1\nWhen\n.B -b\nis specified, only use the first read in a read pair in mapping (skip\nsingle-end reads and the second reads).\n.TP\n.B -2\nWhen\n.B -b\nis specified, only use the second read in a read pair in mapping.\n.B\n.RE\n\n.TP\n.B samse\nbwa samse [-n maxOcc] <in.db.fasta> <in.sai> <in.fq> > <out.sam>\n\nGenerate alignments in the SAM format given single-end reads. Repetitive\nhits will be randomly chosen.\n\n.B OPTIONS:\n.RS\n.TP 10\n.BI -n \\ INT\nMaximum number of alignments to output in the XA tag for reads paired\nproperly. If a read has more than INT hits, the XA tag will not be\nwritten. [3]\n.TP\n.BI -r \\ STR\nSpecify the read group in a format like `@RG\\\\tID:foo\\\\tSM:bar'. [null]\n.RE\n\n.TP\n.B sampe\nbwa sampe [-a maxInsSize] [-o maxOcc] [-n maxHitPaired] [-N maxHitDis]\n[-P] <in.db.fasta> <in1.sai> <in2.sai> <in1.fq> <in2.fq> > <out.sam>\n\nGenerate alignments in the SAM format given paired-end reads. Repetitive\nread pairs will be placed randomly.\n\n.B OPTIONS:\n.RS\n.TP 8\n.BI -a \\ INT\nMaximum insert size for a read pair to be considered being mapped\nproperly. Since 0.4.5, this option is only used when there are not\nenough good alignment to infer the distribution of insert sizes. [500]\n.TP\n.BI -o \\ INT\nMaximum occurrences of a read for pairing. A read with more occurrneces\nwill be treated as a single-end read. Reducing this parameter helps\nfaster pairing. [100000]\n.TP\n.B -P\nLoad the entire FM-index into memory to reduce disk operations\n(base-space reads only). With this option, at least 1.25N bytes of\nmemory are required, where N is the length of the genome.\n.TP\n.BI -n \\ INT\nMaximum number of alignments to output in the XA tag for reads paired\nproperly. If a read has more than INT hits, the XA tag will not be\nwritten. [3]\n.TP\n.BI -N \\ INT\nMaximum number of alignments to output in the XA tag for disconcordant\nread pairs (excluding singletons). If a read has more than INT hits, the\nXA tag will not be written. [10]\n.TP\n.BI -r \\ STR\nSpecify the read group in a format like `@RG\\\\tID:foo\\\\tSM:bar'. [null]\n.RE\n\n.TP\n.B bwasw\nbwa bwasw [-a matchScore] [-b mmPen] [-q gapOpenPen] [-r gapExtPen] [-t\nnThreads] [-w bandWidth] [-T thres] [-s hspIntv] [-z zBest] [-N\nnHspRev] [-c thresCoef] <in.db.fasta> <in.fq> [mate.fq]\n\nAlign query sequences in the\n.I in.fq\nfile. When\n.I mate.fq\nis present, perform paired-end alignment. The paired-end mode only works\nfor reads Illumina short-insert libraries. In the paired-end mode, BWA-SW\nmay still output split alignments but they are all marked as not properly\npaired; the mate positions will not be written if the mate has multiple\nlocal hits.\n\n.B OPTIONS:\n.RS\n.TP 10\n.BI -a \\ INT\nScore of a match [1]\n.TP\n.BI -b \\ INT\nMismatch penalty [3]\n.TP\n.BI -q \\ INT\nGap open penalty [5]\n.TP\n.BI -r \\ INT\nGap extension penalty. The penalty for a contiguous gap of size k is\nq+k*r. [2]\n.TP\n.BI -t \\ INT\nNumber of threads in the multi-threading mode [1]\n.TP\n.BI -w \\ INT\nBand width in the banded alignment [33]\n.TP\n.BI -T \\ INT\nMinimum score threshold divided by a [37]\n.TP\n.BI -c \\ FLOAT\nCoefficient for threshold adjustment according to query length. Given an\nl-long query, the threshold for a hit to be retained is\na*max{T,c*log(l)}. [5.5]\n.TP\n.BI -z \\ INT\nZ-best heuristics. Higher -z increases accuracy at the cost of speed. [1]\n.TP\n.BI -s \\ INT\nMaximum SA interval size for initiating a seed. Higher -s increases\naccuracy at the cost of speed. [3]\n.TP\n.BI -N \\ INT\nMinimum number of seeds supporting the resultant alignment to skip\nreverse alignment. [5]\n.RE\n\n.SH SAM ALIGNMENT FORMAT\n.PP\nThe output of the\n.B `aln'\ncommand is binary and designed for BWA use only. BWA outputs the final\nalignment in the SAM (Sequence Alignment/Map) format. Each line consists\nof:\n\n.TS\ncenter box;\ncb | cb | cb\nn | l | l .\nCol\tField\tDescription\n_\n1\tQNAME\tQuery (pair) NAME\n2\tFLAG\tbitwise FLAG\n3\tRNAME\tReference sequence NAME\n4\tPOS\t1-based leftmost POSition/coordinate of clipped sequence\n5\tMAPQ\tMAPping Quality (Phred-scaled)\n6\tCIAGR\textended CIGAR string\n7\tMRNM\tMate Reference sequence NaMe (`=' if same as RNAME)\n8\tMPOS\t1-based Mate POSistion\n9\tISIZE\tInferred insert SIZE\n10\tSEQ\tquery SEQuence on the same strand as the reference\n11\tQUAL\tquery QUALity (ASCII-33 gives the Phred base quality)\n12\tOPT\tvariable OPTional fields in the format TAG:VTYPE:VALUE\n.TE\n\n.PP\nEach bit in the FLAG field is defined as:\n\n.TS\ncenter box;\ncb | cb | cb\nc | l | l .\nChr\tFlag\tDescription\n_\np\t0x0001\tthe read is paired in sequencing\nP\t0x0002\tthe read is mapped in a proper pair\nu\t0x0004\tthe query sequence itself is unmapped\nU\t0x0008\tthe mate is unmapped\nr\t0x0010\tstrand of the query (1 for reverse)\nR\t0x0020\tstrand of the mate\n1\t0x0040\tthe read is the first read in a pair\n2\t0x0080\tthe read is the second read in a pair\ns\t0x0100\tthe alignment is not primary\nf\t0x0200\tQC failure\nd\t0x0400\toptical or PCR duplicate\nS\t0x0800\tsupplementary alignment\n.TE\n\n.PP\nThe Please check <http://samtools.sourceforge.net> for the format\nspecification and the tools for post-processing the alignment.\n\nBWA generates the following optional fields. Tags starting with `X' are\nspecific to BWA.\n\n.TS\ncenter box;\ncb | cb\ncB | l .\nTag\tMeaning\n_\nNM\tEdit distance\nMD\tMismatching positions/bases\nAS\tAlignment score\nBC\tBarcode sequence\nSA\tSupplementary alignments\n_\nX0\tNumber of best hits\nX1\tNumber of suboptimal hits found by BWA\nXN\tNumber of ambiguous bases in the referenece\nXM\tNumber of mismatches in the alignment\nXO\tNumber of gap opens\nXG\tNumber of gap extentions\nXT\tType: Unique/Repeat/N/Mate-sw\nXA\tAlternative hits; format: /(chr,pos,CIGAR,NM;)*/\n_\nXS\tSuboptimal alignment score\nXF\tSupport from forward/reverse alignment\nXE\tNumber of supporting seeds\n.TE\n\n.PP\nNote that XO and XG are generated by BWT search while the CIGAR string\nby Smith-Waterman alignment. These two tags may be inconsistent with the\nCIGAR string. This is not a bug.\n\n.SH NOTES ON SHORT-READ ALIGNMENT\n.SS Alignment Accuracy\n.PP\nWhen seeding is disabled, BWA guarantees to find an alignment\ncontaining maximum\n.I maxDiff\ndifferences including\n.I maxGapO\ngap opens which do not occur within\n.I nIndelEnd\nbp towards either end of the query. Longer gaps may be found if\n.I maxGapE\nis positive, but it is not guaranteed to find all hits. When seeding is\nenabled, BWA further requires that the first\n.I seedLen\nsubsequence contains no more than\n.I maxSeedDiff\ndifferences.\n.PP\nWhen gapped alignment is disabled, BWA is expected to generate the same\nalignment as Eland version 1, the Illumina alignment program. However, as BWA\nchange `N' in the database sequence to random nucleotides, hits to these\nrandom sequences will also be counted. As a consequence, BWA may mark a\nunique hit as a repeat, if the random sequences happen to be identical\nto the sequences which should be unqiue in the database.\n.PP\nBy default, if the best hit is not highly repetitive (controlled by -R), BWA\nalso finds all hits contains one more mismatch; otherwise, BWA finds all\nequally best hits only. Base quality is NOT considered in evaluating\nhits. In the paired-end mode, BWA pairs all hits it found. It further\nperforms Smith-Waterman alignment for unmapped reads to rescue reads with a\nhigh erro rate, and for high-quality anomalous pairs to fix potential alignment\nerrors.\n\n.SS Estimating Insert Size Distribution\n.PP\nBWA estimates the insert size distribution per 256*1024 read pairs. It\nfirst collects pairs of reads with both ends mapped with a single-end\nquality 20 or higher and then calculates median (Q2), lower and higher\nquartile (Q1 and Q3). It estimates the mean and the variance of the\ninsert size distribution from pairs whose insert sizes are within\ninterval [Q1-2(Q3-Q1), Q3+2(Q3-Q1)]. The maximum distance x for a pair\nconsidered to be properly paired (SAM flag 0x2) is calculated by solving\nequation Phi((x-mu)/sigma)=x/L*p0, where mu is the mean, sigma is the\nstandard error of the insert size distribution, L is the length of the\ngenome, p0 is prior of anomalous pair and Phi() is the standard\ncumulative distribution function. For mapping Illumina short-insert\nreads to the human genome, x is about 6-7 sigma away from the\nmean. Quartiles, mean, variance and x will be printed to the standard\nerror output.\n\n.SS Memory Requirement\n.PP\nWith bwtsw algorithm, 5GB memory is required for indexing the complete\nhuman genome sequences. For short reads, the\n.B aln\ncommand uses ~3.2GB memory and the\n.B sampe\ncommand uses ~5.4GB.\n\n.SS Speed\n.PP\nIndexing the human genome sequences takes 3 hours with bwtsw\nalgorithm. Indexing smaller genomes with IS algorithms is\nfaster, but requires more memory.\n.PP\nThe speed of alignment is largely determined by the error rate of the query\nsequences (r). Firstly, BWA runs much faster for near perfect hits than\nfor hits with many differences, and it stops searching for a hit with\nl+2 differences if a l-difference hit is found. This means BWA will be\nvery slow if r is high because in this case BWA has to visit hits with\nmany differences and looking for these hits is expensive. Secondly, the\nalignment algorithm behind makes the speed sensitive to [k log(N)/m],\nwhere k is the maximum allowed differences, N the size of database and m\nthe length of a query. In practice, we choose k w.r.t. r and therefore r\nis the leading factor. I would not recommend to use BWA on data with\nr>0.02.\n.PP\nPairing is slower for shorter reads. This is mainly because shorter\nreads have more spurious hits and converting SA coordinates to\nchromosomal coordinates are very costly.\n\n.SH CHANGES IN BWA-0.6\n.PP\nSince version 0.6, BWA has been able to work with a reference genome longer than 4GB.\nThis feature makes it possible to integrate the forward and reverse complemented\ngenome in one FM-index, which speeds up both BWA-short and BWA-SW. As a tradeoff,\nBWA uses more memory because it has to keep all positions and ranks in 64-bit\nintegers, twice larger than 32-bit integers used in the previous versions.\n\nThe latest BWA-SW also works for paired-end reads longer than 100bp. In\ncomparison to BWA-short, BWA-SW tends to be more accurate for highly unique\nreads and more robust to relative long INDELs and structural variants.\nNonetheless, BWA-short usually has higher power to distinguish the optimal hit\nfrom many suboptimal hits. The choice of the mapping algorithm may depend on\nthe application.\n\n.SH SEE ALSO\nBWA website <http://bio-bwa.sourceforge.net>, Samtools website\n<http://samtools.sourceforge.net>\n\n.SH AUTHOR\nHeng Li at the Sanger Institute wrote the key source codes and\nintegrated the following codes for BWT construction: bwtsw\n<http://i.cs.hku.hk/~ckwong3/bwtsw/>, implemented by Chi-Kwong Wong at\nthe University of Hong Kong and IS\n<http://yuta.256.googlepages.com/sais> originally proposed by Nong Ge\n<http://www.cs.sysu.edu.cn/nong/> at the Sun Yat-Sen University and\nimplemented by Yuta Mori.\n\n.SH LICENSE AND CITATION\n.PP\nThe full BWA package is distributed under GPLv3 as it uses source codes\nfrom BWT-SW which is covered by GPL. Sorting, hash table, BWT and IS\nlibraries are distributed under the MIT license.\n.PP\nIf you use the BWA-backtrack algorithm, please cite the following\npaper:\n.PP\nLi H. and Durbin R. (2009) Fast and accurate short read alignment with\nBurrows-Wheeler transform. Bioinformatics, 25, 1754-1760. [PMID: 19451168]\n.PP\nIf you use the BWA-SW algorithm, please cite:\n.PP\nLi H. and Durbin R. (2010) Fast and accurate long-read alignment with\nBurrows-Wheeler transform. Bioinformatics, 26, 589-595. [PMID: 20080505]\n.PP\nIf you use BWA-MEM or the fastmap component of BWA, please cite:\n.PP\nLi H. (2013) Aligning sequence reads, clone sequences and assembly contigs with\nBWA-MEM. arXiv:1303.3997v1 [q-bio.GN].\n.PP\nIt is likely that the BWA-MEM manuscript will not appear in a peer-reviewed\njournal.\n\n.SH HISTORY\nBWA is largely influenced by BWT-SW. It uses source codes from BWT-SW\nand mimics its binary file formats; BWA-SW resembles BWT-SW in several\nways. The initial idea about BWT-based alignment also came from the\ngroup who developed BWT-SW. At the same time, BWA is different enough\nfrom BWT-SW. The short-read alignment algorithm bears no similarity to\nSmith-Waterman algorithm any more. While BWA-SW learns from BWT-SW, it\nintroduces heuristics that can hardly be applied to the original\nalgorithm. In all, BWA does not guarantee to find all local hits as what\nBWT-SW is designed to do, but it is much faster than BWT-SW on both\nshort and long query sequences.\n\nI started to write the first piece of codes on 24 May 2008 and got the\ninitial stable version on 02 June 2008. During this period, I was\nacquainted that Professor Tak-Wah Lam, the first author of BWT-SW paper,\nwas collaborating with Beijing Genomics Institute on SOAP2, the successor\nto SOAP (Short Oligonucleotide Analysis Package). SOAP2 has come out in\nNovember 2008. According to the SourceForge download page, the third\nBWT-based short read aligner, bowtie, was first released in August\n2008. At the time of writing this manual, at least three more BWT-based\nshort-read aligners are being implemented.\n\nThe BWA-SW algorithm is a new component of BWA. It was conceived in\nNovember 2008 and implemented ten months later.\n\nThe BWA-MEM algorithm is based on an algorithm finding super-maximal exact\nmatches (SMEMs), which was first published with the fermi assembler paper\nin 2012. I first implemented the basic SMEM algorithm in the\n.B fastmap\ncommand for an experiment and then extended the basic algorithm and added the\nextension part in Feburary 2013 to make BWA-MEM a fully featured mapper.\n\n"
        },
        {
          "name": "bwa.c",
          "type": "blob",
          "size": 15.2177734375,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <string.h>\n#include <stdio.h>\n#include <zlib.h>\n#include <assert.h>\n#include \"bntseq.h\"\n#include \"bwa.h\"\n#include \"ksw.h\"\n#include \"utils.h\"\n#include \"kstring.h\"\n#include \"kvec.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nint bwa_verbose = 3;\nint bwa_dbg = 0;\nchar bwa_rg_id[256];\nchar *bwa_pg;\n\n/************************\n * Batch FASTA/Q reader *\n ************************/\n\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\nstatic inline void trim_readno(kstring_t *s)\n{\n\tif (s->l > 2 && s->s[s->l-2] == '/' && isdigit(s->s[s->l-1]))\n\t\ts->l -= 2, s->s[s->l] = 0;\n}\n\nstatic inline char *dupkstring(const kstring_t *str, int dupempty)\n{\n\tchar *s = (str->l > 0 || dupempty)? malloc(str->l + 1) : NULL;\n\tif (!s) return NULL;\n\n\tmemcpy(s, str->s, str->l);\n\ts[str->l] = '\\0';\n\treturn s;\n}\n\nstatic inline void kseq2bseq1(const kseq_t *ks, bseq1_t *s)\n{ // TODO: it would be better to allocate one chunk of memory, but probably it does not matter in practice\n\ts->name = dupkstring(&ks->name, 1);\n\ts->comment = dupkstring(&ks->comment, 0);\n\ts->seq = dupkstring(&ks->seq, 1);\n\ts->qual = dupkstring(&ks->qual, 0);\n\ts->l_seq = ks->seq.l;\n}\n\nbseq1_t *bseq_read(int chunk_size, int *n_, void *ks1_, void *ks2_)\n{\n\tkseq_t *ks = (kseq_t*)ks1_, *ks2 = (kseq_t*)ks2_;\n\tint size = 0, m, n;\n\tbseq1_t *seqs;\n\tm = n = 0; seqs = 0;\n\twhile (kseq_read(ks) >= 0) {\n\t\tif (ks2 && kseq_read(ks2) < 0) { // the 2nd file has fewer reads\n\t\t\tfprintf(stderr, \"[W::%s] the 2nd file has fewer sequences.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (n >= m) {\n\t\t\tm = m? m<<1 : 256;\n\t\t\tseqs = realloc(seqs, m * sizeof(bseq1_t));\n\t\t}\n\t\ttrim_readno(&ks->name);\n\t\tkseq2bseq1(ks, &seqs[n]);\n\t\tseqs[n].id = n;\n\t\tsize += seqs[n++].l_seq;\n\t\tif (ks2) {\n\t\t\ttrim_readno(&ks2->name);\n\t\t\tkseq2bseq1(ks2, &seqs[n]);\n\t\t\tseqs[n].id = n;\n\t\t\tsize += seqs[n++].l_seq;\n\t\t}\n\t\tif (size >= chunk_size && (n&1) == 0) break;\n\t}\n\tif (size == 0) { // test if the 2nd file is finished\n\t\tif (ks2 && kseq_read(ks2) >= 0)\n\t\t\tfprintf(stderr, \"[W::%s] the 1st file has fewer sequences.\\n\", __func__);\n\t}\n\t*n_ = n;\n\treturn seqs;\n}\n\nvoid bseq_classify(int n, bseq1_t *seqs, int m[2], bseq1_t *sep[2])\n{\n\tint i, has_last;\n\tkvec_t(bseq1_t) a[2] = {{0,0,0}, {0,0,0}};\n\tfor (i = 1, has_last = 1; i < n; ++i) {\n\t\tif (has_last) {\n\t\t\tif (strcmp(seqs[i].name, seqs[i-1].name) == 0) {\n\t\t\t\tkv_push(bseq1_t, a[1], seqs[i-1]);\n\t\t\t\tkv_push(bseq1_t, a[1], seqs[i]);\n\t\t\t\thas_last = 0;\n\t\t\t} else kv_push(bseq1_t, a[0], seqs[i-1]);\n\t\t} else has_last = 1;\n\t}\n\tif (has_last) kv_push(bseq1_t, a[0], seqs[i-1]);\n\tsep[0] = a[0].a, m[0] = a[0].n;\n\tsep[1] = a[1].a, m[1] = a[1].n;\n}\n\n/*****************\n * CIGAR related *\n *****************/\n\nvoid bwa_fill_scmat(int a, int b, int8_t mat[25])\n{\n\tint i, j, k;\n\tfor (i = k = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tmat[k++] = i == j? a : -b;\n\t\tmat[k++] = -1; // ambiguous base\n\t}\n\tfor (j = 0; j < 5; ++j) mat[k++] = -1;\n}\n\n// Generate CIGAR when the alignment end points are known\nuint32_t *bwa_gen_cigar2(const int8_t mat[25], int o_del, int e_del, int o_ins, int e_ins, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM)\n{\n\tuint32_t *cigar = 0;\n\tuint8_t tmp, *rseq;\n\tint i;\n\tint64_t rlen;\n\tkstring_t str;\n\tconst char *int2base;\n\n\tif (n_cigar) *n_cigar = 0;\n\tif (NM) *NM = -1;\n\tif (l_query <= 0 || rb >= re || (rb < l_pac && re > l_pac)) return 0; // reject if negative length or bridging the forward and reverse strand\n\trseq = bns_get_seq(l_pac, pac, rb, re, &rlen);\n\tif (re - rb != rlen) goto ret_gen_cigar; // possible if out of range\n\tif (rb >= l_pac) { // then reverse both query and rseq; this is to ensure indels to be placed at the leftmost position\n\t\tfor (i = 0; i < l_query>>1; ++i)\n\t\t\ttmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;\n\t\tfor (i = 0; i < rlen>>1; ++i)\n\t\t\ttmp = rseq[i], rseq[i] = rseq[rlen - 1 - i], rseq[rlen - 1 - i] = tmp;\n\t}\n\tif (l_query == re - rb && w_ == 0) { // no gap; no need to do DP\n\t\t// UPDATE: we come to this block now... FIXME: due to an issue in mem_reg2aln(), we never come to this block. This does not affect accuracy, but it hurts performance.\n\t\tif (n_cigar) {\n\t\t\tcigar = malloc(4);\n\t\t\tcigar[0] = l_query<<4 | 0;\n\t\t\t*n_cigar = 1;\n\t\t}\n\t\tfor (i = 0, *score = 0; i < l_query; ++i)\n\t\t\t*score += mat[rseq[i]*5 + query[i]];\n\t} else {\n\t\tint w, max_gap, max_ins, max_del, min_w;\n\t\t// set the band-width\n\t\tmax_ins = (int)((double)(((l_query+1)>>1) * mat[0] - o_ins) / e_ins + 1.);\n\t\tmax_del = (int)((double)(((l_query+1)>>1) * mat[0] - o_del) / e_del + 1.);\n\t\tmax_gap = max_ins > max_del? max_ins : max_del;\n\t\tmax_gap = max_gap > 1? max_gap : 1;\n\t\tw = (max_gap + abs((int)rlen - l_query) + 1) >> 1;\n\t\tw = w < w_? w : w_;\n\t\tmin_w = abs((int)rlen - l_query) + 3;\n\t\tw = w > min_w? w : min_w;\n\t\t// NW alignment\n\t\tif (bwa_verbose >= 4) {\n\t\t\tprintf(\"* Global bandwidth: %d\\n\", w);\n\t\t\tprintf(\"* Global ref:   \"); for (i = 0; i < rlen; ++i) putchar(\"ACGTN\"[(int)rseq[i]]); putchar('\\n');\n\t\t\tprintf(\"* Global query: \"); for (i = 0; i < l_query; ++i) putchar(\"ACGTN\"[(int)query[i]]); putchar('\\n');\n\t\t}\n\t\t*score = ksw_global2(l_query, query, rlen, rseq, 5, mat, o_del, e_del, o_ins, e_ins, w, n_cigar, &cigar);\n\t}\n\tif (NM && n_cigar) {// compute NM and MD\n\t\tint k, x, y, u, n_mm = 0, n_gap = 0;\n\t\tstr.l = str.m = *n_cigar * 4; str.s = (char*)cigar; // append MD to CIGAR\n\t\tint2base = rb < l_pac? \"ACGTN\" : \"TGCAN\";\n\t\tfor (k = 0, x = y = u = 0; k < *n_cigar; ++k) {\n\t\t\tint op, len;\n\t\t\tcigar = (uint32_t*)str.s;\n\t\t\top  = cigar[k]&0xf, len = cigar[k]>>4;\n\t\t\tif (op == 0) { // match\n\t\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\t\tif (query[x + i] != rseq[y + i]) {\n\t\t\t\t\t\tkputw(u, &str);\n\t\t\t\t\t\tkputc(int2base[rseq[y+i]], &str);\n\t\t\t\t\t\t++n_mm; u = 0;\n\t\t\t\t\t} else ++u;\n\t\t\t\t}\n\t\t\t\tx += len; y += len;\n\t\t\t} else if (op == 2) { // deletion\n\t\t\t\tif (k > 0 && k < *n_cigar - 1) { // don't do the following if D is the first or the last CIGAR\n\t\t\t\t\tkputw(u, &str); kputc('^', &str);\n\t\t\t\t\tfor (i = 0; i < len; ++i)\n\t\t\t\t\t\tkputc(int2base[rseq[y+i]], &str);\n\t\t\t\t\tu = 0; n_gap += len;\n\t\t\t\t}\n\t\t\t\ty += len;\n\t\t\t} else if (op == 1) x += len, n_gap += len; // insertion\n\t\t}\n\t\tkputw(u, &str); kputc(0, &str);\n\t\t*NM = n_mm + n_gap;\n\t\tcigar = (uint32_t*)str.s;\n\t}\n\tif (rb >= l_pac) // reverse back query\n\t\tfor (i = 0; i < l_query>>1; ++i)\n\t\t\ttmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;\n\nret_gen_cigar:\n\tfree(rseq);\n\treturn cigar;\n}\n\nuint32_t *bwa_gen_cigar(const int8_t mat[25], int q, int r, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM)\n{\n\treturn bwa_gen_cigar2(mat, q, r, q, r, w_, l_pac, pac, l_query, query, rb, re, score, n_cigar, NM);\n}\n\n/*********************\n * Full index reader *\n *********************/\n\nchar *bwa_idx_infer_prefix(const char *hint)\n{\n\tchar *prefix;\n\tint l_hint;\n\tFILE *fp;\n\tl_hint = strlen(hint);\n\tprefix = malloc(l_hint + 3 + 4 + 1);\n\tstrcpy(prefix, hint);\n\tstrcpy(prefix + l_hint, \".64.bwt\");\n\tif ((fp = fopen(prefix, \"rb\")) != 0) {\n\t\tfclose(fp);\n\t\tprefix[l_hint + 3] = 0;\n\t\treturn prefix;\n\t} else {\n\t\tstrcpy(prefix + l_hint, \".bwt\");\n\t\tif ((fp = fopen(prefix, \"rb\")) == 0) {\n\t\t\tfree(prefix);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfclose(fp);\n\t\t\tprefix[l_hint] = 0;\n\t\t\treturn prefix;\n\t\t}\n\t}\n}\n\nbwt_t *bwa_idx_load_bwt(const char *hint)\n{\n\tchar *tmp, *prefix;\n\tbwt_t *bwt;\n\tprefix = bwa_idx_infer_prefix(hint);\n\tif (prefix == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to locate the index files\\n\", __func__);\n\t\treturn 0;\n\t}\n\ttmp = calloc(strlen(prefix) + 5, 1);\n\tstrcat(strcpy(tmp, prefix), \".bwt\"); // FM-index\n\tbwt = bwt_restore_bwt(tmp);\n\tstrcat(strcpy(tmp, prefix), \".sa\");  // partial suffix array (SA)\n\tbwt_restore_sa(tmp, bwt);\n\tfree(tmp); free(prefix);\n\treturn bwt;\n}\n\nbwaidx_t *bwa_idx_load_from_disk(const char *hint, int which)\n{\n\tbwaidx_t *idx;\n\tchar *prefix;\n\tprefix = bwa_idx_infer_prefix(hint);\n\tif (prefix == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to locate the index files\\n\", __func__);\n\t\treturn 0;\n\t}\n\tidx = calloc(1, sizeof(bwaidx_t));\n\tif (which & BWA_IDX_BWT) idx->bwt = bwa_idx_load_bwt(hint);\n\tif (which & BWA_IDX_BNS) {\n\t\tint i, c;\n\t\tidx->bns = bns_restore(prefix);\n\t\tfor (i = c = 0; i < idx->bns->n_seqs; ++i)\n\t\t\tif (idx->bns->anns[i].is_alt) ++c;\n\t\tif (bwa_verbose >= 3)\n\t\t\tfprintf(stderr, \"[M::%s] read %d ALT contigs\\n\", __func__, c);\n\t\tif (which & BWA_IDX_PAC) {\n\t\t\tidx->pac = calloc(idx->bns->l_pac/4+1, 1);\n\t\t\terr_fread_noeof(idx->pac, 1, idx->bns->l_pac/4+1, idx->bns->fp_pac); // concatenated 2-bit encoded sequence\n\t\t\terr_fclose(idx->bns->fp_pac);\n\t\t\tidx->bns->fp_pac = 0;\n\t\t}\n\t}\n\tfree(prefix);\n\treturn idx;\n}\n\nbwaidx_t *bwa_idx_load(const char *hint, int which)\n{\n\treturn bwa_idx_load_from_disk(hint, which);\n}\n\nvoid bwa_idx_destroy(bwaidx_t *idx)\n{\n\tif (idx == 0) return;\n\tif (idx->mem == 0) {\n\t\tif (idx->bwt) bwt_destroy(idx->bwt);\n\t\tif (idx->bns) bns_destroy(idx->bns);\n\t\tif (idx->pac) free(idx->pac);\n\t} else {\n\t\tfree(idx->bwt); free(idx->bns->anns); free(idx->bns);\n\t\tif (!idx->is_shm) free(idx->mem);\n\t}\n\tfree(idx);\n}\n\nint bwa_mem2idx(int64_t l_mem, uint8_t *mem, bwaidx_t *idx)\n{\n\tint64_t k = 0, x;\n\tint i;\n\n\t// generate idx->bwt\n\tx = sizeof(bwt_t); idx->bwt = malloc(x); memcpy(idx->bwt, mem + k, x); k += x;\n\tx = idx->bwt->bwt_size * 4; idx->bwt->bwt = (uint32_t*)(mem + k); k += x;\n\tx = idx->bwt->n_sa * sizeof(bwtint_t); idx->bwt->sa = (bwtint_t*)(mem + k); k += x;\n\n\t// generate idx->bns and idx->pac\n\tx = sizeof(bntseq_t); idx->bns = malloc(x); memcpy(idx->bns, mem + k, x); k += x;\n\tx = idx->bns->n_holes * sizeof(bntamb1_t); idx->bns->ambs = (bntamb1_t*)(mem + k); k += x;\n\tx = idx->bns->n_seqs  * sizeof(bntann1_t); idx->bns->anns = malloc(x); memcpy(idx->bns->anns, mem + k, x); k += x;\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) {\n\t\tidx->bns->anns[i].name = (char*)(mem + k); k += strlen(idx->bns->anns[i].name) + 1;\n\t\tidx->bns->anns[i].anno = (char*)(mem + k); k += strlen(idx->bns->anns[i].anno) + 1;\n\t}\n\tidx->pac = (uint8_t*)(mem + k); k += idx->bns->l_pac/4+1;\n\tassert(k == l_mem);\n\n\tidx->l_mem = k; idx->mem = mem;\n\treturn 0;\n}\n\nint bwa_idx2mem(bwaidx_t *idx)\n{\n\tint i;\n\tint64_t k, x, tmp;\n\tuint8_t *mem;\n\n\t// copy idx->bwt\n\tx = idx->bwt->bwt_size * 4;\n\tmem = realloc(idx->bwt->bwt, sizeof(bwt_t) + x); idx->bwt->bwt = 0;\n\tmemmove(mem + sizeof(bwt_t), mem, x);\n\tmemcpy(mem, idx->bwt, sizeof(bwt_t)); k = sizeof(bwt_t) + x;\n\tx = idx->bwt->n_sa * sizeof(bwtint_t); mem = realloc(mem, k + x); memcpy(mem + k, idx->bwt->sa, x); k += x;\n\tfree(idx->bwt->sa);\n\tfree(idx->bwt); idx->bwt = 0;\n\n\t// copy idx->bns\n\ttmp = idx->bns->n_seqs * sizeof(bntann1_t) + idx->bns->n_holes * sizeof(bntamb1_t);\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) // compute the size of heap-allocated memory\n\t\ttmp += strlen(idx->bns->anns[i].name) + strlen(idx->bns->anns[i].anno) + 2;\n\tmem = realloc(mem, k + sizeof(bntseq_t) + tmp);\n\tx = sizeof(bntseq_t); memcpy(mem + k, idx->bns, x); k += x;\n\tx = idx->bns->n_holes * sizeof(bntamb1_t); memcpy(mem + k, idx->bns->ambs, x); k += x;\n\tfree(idx->bns->ambs);\n\tx = idx->bns->n_seqs * sizeof(bntann1_t); memcpy(mem + k, idx->bns->anns, x); k += x;\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) {\n\t\tx = strlen(idx->bns->anns[i].name) + 1; memcpy(mem + k, idx->bns->anns[i].name, x); k += x;\n\t\tx = strlen(idx->bns->anns[i].anno) + 1; memcpy(mem + k, idx->bns->anns[i].anno, x); k += x;\n\t\tfree(idx->bns->anns[i].name); free(idx->bns->anns[i].anno);\n\t}\n\tfree(idx->bns->anns);\n\n\t// copy idx->pac\n\tx = idx->bns->l_pac/4+1;\n\tmem = realloc(mem, k + x);\n\tmemcpy(mem + k, idx->pac, x); k += x;\n\tfree(idx->bns); idx->bns = 0;\n\tfree(idx->pac); idx->pac = 0;\n\n\treturn bwa_mem2idx(k, mem, idx);\n}\n\n/***********************\n * SAM header routines *\n ***********************/\n\nvoid bwa_print_sam_hdr(const bntseq_t *bns, const char *hdr_line)\n{\n\tint i, n_HD = 0, n_SQ = 0;\n\textern char *bwa_pg;\n\t\n\tif (hdr_line) {\n\t\t// check for HD line\n\t\tconst char *p = hdr_line;\n\t\tif ((p = strstr(p, \"@HD\")) != 0) {\n\t\t\t++n_HD;\n\t\t}\t\n\t\t// check for SQ lines\n\t\tp = hdr_line;\n\t\twhile ((p = strstr(p, \"@SQ\\t\")) != 0) {\n\t\t\tif (p == hdr_line || *(p-1) == '\\n') ++n_SQ;\n\t\t\tp += 4;\n\t\t}\n\t}\n\tif (n_SQ == 0) {\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\terr_printf(\"@SQ\\tSN:%s\\tLN:%d\", bns->anns[i].name, bns->anns[i].len);\n\t\t\tif (bns->anns[i].is_alt) err_printf(\"\\tAH:*\\n\");\n\t\t\telse err_fputc('\\n', stdout);\n\t\t}\n\t} else if (n_SQ != bns->n_seqs && bwa_verbose >= 2)\n\t\tfprintf(stderr, \"[W::%s] %d @SQ lines provided with -H; %d sequences in the index. Continue anyway.\\n\", __func__, n_SQ, bns->n_seqs);\n\tif (n_HD == 0) {\n\t\terr_printf(\"@HD\\tVN:1.5\\tSO:unsorted\\tGO:query\\n\");\n\t}\n\tif (hdr_line) err_printf(\"%s\\n\", hdr_line);\n\tif (bwa_pg) err_printf(\"%s\\n\", bwa_pg);\n}\n\nstatic char *bwa_escape(char *s)\n{\n\tchar *p, *q;\n\tfor (p = q = s; *p; ++p) {\n\t\tif (*p == '\\\\') {\n\t\t\t++p;\n\t\t\tif (*p == 't') *q++ = '\\t';\n\t\t\telse if (*p == 'n') *q++ = '\\n';\n\t\t\telse if (*p == 'r') *q++ = '\\r';\n\t\t\telse if (*p == '\\\\') *q++ = '\\\\';\n\t\t} else *q++ = *p;\n\t}\n\t*q = '\\0';\n\treturn s;\n}\n\nchar *bwa_set_rg(const char *s)\n{\n\tchar *p, *q, *r, *rg_line = 0;\n\tmemset(bwa_rg_id, 0, 256);\n\tif (strstr(s, \"@RG\") != s) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] the read group line is not started with @RG\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tif (strstr(s, \"\\t\") != NULL) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] the read group line contained literal <tab> characters -- replace with escaped tabs: \\\\t\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\trg_line = strdup(s);\n\tbwa_escape(rg_line);\n\tif ((p = strstr(rg_line, \"\\tID:\")) == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] no ID within the read group line\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tp += 4;\n\tfor (q = p; *q && *q != '\\t' && *q != '\\n'; ++q);\n\tif (q - p + 1 > 256) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] @RG:ID is longer than 255 characters\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tfor (q = p, r = bwa_rg_id; *q && *q != '\\t' && *q != '\\n'; ++q)\n\t\t*r++ = *q;\n\treturn rg_line;\n\nerr_set_rg:\n\tfree(rg_line);\n\treturn 0;\n}\n\nchar *bwa_insert_header(const char *s, char *hdr)\n{\n\tint len = 0;\n\tif (s == 0 || s[0] != '@') return hdr;\n\tif (hdr) {\n\t\tlen = strlen(hdr);\n\t\thdr = realloc(hdr, len + strlen(s) + 2);\n\t\thdr[len++] = '\\n';\n\t\tstrcpy(hdr + len, s);\n\t} else hdr = strdup(s);\n\tbwa_escape(hdr + len);\n\treturn hdr;\n}\n"
        },
        {
          "name": "bwa.h",
          "type": "blob",
          "size": 3.2587890625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#ifndef BWA_H_\n#define BWA_H_\n\n#include <stdint.h>\n#include \"bntseq.h\"\n#include \"bwt.h\"\n\n#define BWA_IDX_BWT 0x1\n#define BWA_IDX_BNS 0x2\n#define BWA_IDX_PAC 0x4\n#define BWA_IDX_ALL 0x7\n\n#define BWA_CTL_SIZE 0x10000\n\n#define BWTALGO_AUTO  0\n#define BWTALGO_RB2   1\n#define BWTALGO_BWTSW 2\n#define BWTALGO_IS    3\n\n#define BWA_DBG_QNAME 0x1\n\ntypedef struct {\n\tbwt_t    *bwt; // FM-index\n\tbntseq_t *bns; // information on the reference sequences\n\tuint8_t  *pac; // the actual 2-bit encoded reference sequences with 'N' converted to a random base\n\n\tint    is_shm;\n\tint64_t l_mem;\n\tuint8_t  *mem;\n} bwaidx_t;\n\ntypedef struct {\n\tint l_seq, id;\n\tchar *name, *comment, *seq, *qual, *sam;\n} bseq1_t;\n\nextern int bwa_verbose, bwa_dbg;\nextern char bwa_rg_id[256];\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tbseq1_t *bseq_read(int chunk_size, int *n_, void *ks1_, void *ks2_);\n\tvoid bseq_classify(int n, bseq1_t *seqs, int m[2], bseq1_t *sep[2]);\n\n\tvoid bwa_fill_scmat(int a, int b, int8_t mat[25]);\n\tuint32_t *bwa_gen_cigar(const int8_t mat[25], int q, int r, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM);\n\tuint32_t *bwa_gen_cigar2(const int8_t mat[25], int o_del, int e_del, int o_ins, int e_ins, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM);\n\n\tint bwa_idx_build(const char *fa, const char *prefix, int algo_type, int block_size);\n\n\tchar *bwa_idx_infer_prefix(const char *hint);\n\tbwt_t *bwa_idx_load_bwt(const char *hint);\n\n\tbwaidx_t *bwa_idx_load_from_shm(const char *hint);\n\tbwaidx_t *bwa_idx_load_from_disk(const char *hint, int which);\n\tbwaidx_t *bwa_idx_load(const char *hint, int which);\n\tvoid bwa_idx_destroy(bwaidx_t *idx);\n\tint bwa_idx2mem(bwaidx_t *idx);\n\tint bwa_mem2idx(int64_t l_mem, uint8_t *mem, bwaidx_t *idx);\n\n\tvoid bwa_print_sam_hdr(const bntseq_t *bns, const char *hdr_line);\n\tchar *bwa_set_rg(const char *s);\n\tchar *bwa_insert_header(const char *s, char *hdr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwakit",
          "type": "tree",
          "content": null
        },
        {
          "name": "bwamem.c",
          "type": "blob",
          "size": 48.0703125,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#ifdef HAVE_PTHREAD\n#include <pthread.h>\n#endif\n\n#include \"kstring.h\"\n#include \"bwamem.h\"\n#include \"bntseq.h\"\n#include \"ksw.h\"\n#include \"kvec.h\"\n#include \"ksort.h\"\n#include \"utils.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n/* Theory on probability and scoring *ungapped* alignment\n *\n * s'(a,b) = log[P(b|a)/P(b)] = log[4P(b|a)], assuming uniform base distribution\n * s'(a,a) = log(4), s'(a,b) = log(4e/3), where e is the error rate\n *\n * Scale s'(a,b) to s(a,a) s.t. s(a,a)=x. Then s(a,b) = x*s'(a,b)/log(4), or conversely: s'(a,b)=s(a,b)*log(4)/x\n *\n * If the matching score is x and mismatch penalty is -y, we can compute error rate e:\n *   e = .75 * exp[-log(4) * y/x]\n *\n * log P(seq) = \\sum_i log P(b_i|a_i) = \\sum_i {s'(a,b) - log(4)}\n *   = \\sum_i { s(a,b)*log(4)/x - log(4) } = log(4) * (S/x - l)\n *\n * where S=\\sum_i s(a,b) is the alignment score. Converting to the phred scale:\n *   Q(seq) = -10/log(10) * log P(seq) = 10*log(4)/log(10) * (l - S/x) = 6.02 * (l - S/x)\n *\n *\n * Gap open (zero gap): q' = log[P(gap-open)], r' = log[P(gap-ext)] (see Durbin et al. (1998) Section 4.1)\n * Then q = x*log[P(gap-open)]/log(4), r = x*log[P(gap-ext)]/log(4)\n *\n * When there are gaps, l should be the length of alignment matches (i.e. the M operator in CIGAR)\n */\n\nstatic const bntseq_t *global_bns = 0; // for debugging only\n\nmem_opt_t *mem_opt_init()\n{\n\tmem_opt_t *o;\n\to = calloc(1, sizeof(mem_opt_t));\n\to->flag = 0;\n\to->a = 1; o->b = 4;\n\to->o_del = o->o_ins = 6;\n\to->e_del = o->e_ins = 1;\n\to->w = 100;\n\to->T = 30;\n\to->zdrop = 100;\n\to->pen_unpaired = 17;\n\to->pen_clip5 = o->pen_clip3 = 5;\n\n\to->max_mem_intv = 20;\n\n\to->min_seed_len = 19;\n\to->split_width = 10;\n\to->max_occ = 500;\n\to->max_chain_gap = 10000;\n\to->max_ins = 10000;\n\to->mask_level = 0.50;\n\to->drop_ratio = 0.50;\n\to->XA_drop_ratio = 0.80;\n\to->split_factor = 1.5;\n\to->chunk_size = 10000000;\n\to->n_threads = 1;\n\to->max_XA_hits = 5;\n\to->max_XA_hits_alt = 200;\n\to->max_matesw = 50;\n\to->mask_level_redun = 0.95;\n\to->min_chain_weight = 0;\n\to->max_chain_extend = 1<<30;\n\to->mapQ_coef_len = 50; o->mapQ_coef_fac = log(o->mapQ_coef_len);\n\tbwa_fill_scmat(o->a, o->b, o->mat);\n\treturn o;\n}\n\n/***************************\n * Collection SA invervals *\n ***************************/\n\n#define intv_lt(a, b) ((a).info < (b).info)\nKSORT_INIT(mem_intv, bwtintv_t, intv_lt)\n\ntypedef struct {\n\tbwtintv_v mem, mem1, *tmpv[2];\n} smem_aux_t;\n\nstatic smem_aux_t *smem_aux_init()\n{\n\tsmem_aux_t *a;\n\ta = calloc(1, sizeof(smem_aux_t));\n\ta->tmpv[0] = calloc(1, sizeof(bwtintv_v));\n\ta->tmpv[1] = calloc(1, sizeof(bwtintv_v));\n\treturn a;\n}\n\nstatic void smem_aux_destroy(smem_aux_t *a)\n{\t\n\tfree(a->tmpv[0]->a); free(a->tmpv[0]);\n\tfree(a->tmpv[1]->a); free(a->tmpv[1]);\n\tfree(a->mem.a); free(a->mem1.a);\n\tfree(a);\n}\n\nstatic void mem_collect_intv(const mem_opt_t *opt, const bwt_t *bwt, int len, const uint8_t *seq, smem_aux_t *a)\n{\n\tint i, k, x = 0, old_n;\n\tint start_width = 1;\n\tint split_len = (int)(opt->min_seed_len * opt->split_factor + .499);\n\ta->mem.n = 0;\n\t// first pass: find all SMEMs\n\twhile (x < len) {\n\t\tif (seq[x] < 4) {\n\t\t\tx = bwt_smem1(bwt, len, seq, x, start_width, &a->mem1, a->tmpv);\n\t\t\tfor (i = 0; i < a->mem1.n; ++i) {\n\t\t\t\tbwtintv_t *p = &a->mem1.a[i];\n\t\t\t\tint slen = (uint32_t)p->info - (p->info>>32); // seed length\n\t\t\t\tif (slen >= opt->min_seed_len)\n\t\t\t\t\tkv_push(bwtintv_t, a->mem, *p);\n\t\t\t}\n\t\t} else ++x;\n\t}\n\t// second pass: find MEMs inside a long SMEM\n\told_n = a->mem.n;\n\tfor (k = 0; k < old_n; ++k) {\n\t\tbwtintv_t *p = &a->mem.a[k];\n\t\tint start = p->info>>32, end = (int32_t)p->info;\n\t\tif (end - start < split_len || p->x[2] > opt->split_width) continue;\n\t\tbwt_smem1(bwt, len, seq, (start + end)>>1, p->x[2]+1, &a->mem1, a->tmpv);\n\t\tfor (i = 0; i < a->mem1.n; ++i)\n\t\t\tif ((uint32_t)a->mem1.a[i].info - (a->mem1.a[i].info>>32) >= opt->min_seed_len)\n\t\t\t\tkv_push(bwtintv_t, a->mem, a->mem1.a[i]);\n\t}\n\t// third pass: LAST-like\n\tif (opt->max_mem_intv > 0) {\n\t\tx = 0;\n\t\twhile (x < len) {\n\t\t\tif (seq[x] < 4) {\n\t\t\t\tif (1) {\n\t\t\t\t\tbwtintv_t m;\n\t\t\t\t\tx = bwt_seed_strategy1(bwt, len, seq, x, opt->min_seed_len, opt->max_mem_intv, &m);\n\t\t\t\t\tif (m.x[2] > 0) kv_push(bwtintv_t, a->mem, m);\n\t\t\t\t} else { // for now, we never come to this block which is slower\n\t\t\t\t\tx = bwt_smem1a(bwt, len, seq, x, start_width, opt->max_mem_intv, &a->mem1, a->tmpv);\n\t\t\t\t\tfor (i = 0; i < a->mem1.n; ++i)\n\t\t\t\t\t\tkv_push(bwtintv_t, a->mem, a->mem1.a[i]);\n\t\t\t\t}\n\t\t\t} else ++x;\n\t\t}\n\t}\n\t// sort\n\tks_introsort(mem_intv, a->mem.n, a->mem.a);\n}\n\n/************\n * Chaining *\n ************/\n\ntypedef struct {\n\tint64_t rbeg;\n\tint32_t qbeg, len;\n\tint score;\n} mem_seed_t; // unaligned memory\n\ntypedef struct {\n\tint n, m, first, rid;\n\tuint32_t w:29, kept:2, is_alt:1;\n\tfloat frac_rep;\n\tint64_t pos;\n\tmem_seed_t *seeds;\n} mem_chain_t;\n\ntypedef struct { size_t n, m; mem_chain_t *a;  } mem_chain_v;\n\n#include \"kbtree.h\"\n\n#define chain_cmp(a, b) (((b).pos < (a).pos) - ((a).pos < (b).pos))\nKBTREE_INIT(chn, mem_chain_t, chain_cmp)\n\n// return 1 if the seed is merged into the chain\nstatic int test_and_merge(const mem_opt_t *opt, int64_t l_pac, mem_chain_t *c, const mem_seed_t *p, int seed_rid)\n{\n\tint64_t qend, rend, x, y;\n\tconst mem_seed_t *last = &c->seeds[c->n-1];\n\tqend = last->qbeg + last->len;\n\trend = last->rbeg + last->len;\n\tif (seed_rid != c->rid) return 0; // different chr; request a new chain\n\tif (p->qbeg >= c->seeds[0].qbeg && p->qbeg + p->len <= qend && p->rbeg >= c->seeds[0].rbeg && p->rbeg + p->len <= rend)\n\t\treturn 1; // contained seed; do nothing\n\tif ((last->rbeg < l_pac || c->seeds[0].rbeg < l_pac) && p->rbeg >= l_pac) return 0; // don't chain if on different strand\n\tx = p->qbeg - last->qbeg; // always non-negtive\n\ty = p->rbeg - last->rbeg;\n\tif (y >= 0 && x - y <= opt->w && y - x <= opt->w && x - last->len < opt->max_chain_gap && y - last->len < opt->max_chain_gap) { // grow the chain\n\t\tif (c->n == c->m) {\n\t\t\tc->m <<= 1;\n\t\t\tc->seeds = realloc(c->seeds, c->m * sizeof(mem_seed_t));\n\t\t}\n\t\tc->seeds[c->n++] = *p;\n\t\treturn 1;\n\t}\n\treturn 0; // request to add a new chain\n}\n\nint mem_chain_weight(const mem_chain_t *c)\n{\n\tint64_t end;\n\tint j, w = 0, tmp;\n\tfor (j = 0, end = 0; j < c->n; ++j) {\n\t\tconst mem_seed_t *s = &c->seeds[j];\n\t\tif (s->qbeg >= end) w += s->len;\n\t\telse if (s->qbeg + s->len > end) w += s->qbeg + s->len - end;\n\t\tend = end > s->qbeg + s->len? end : s->qbeg + s->len;\n\t}\n\ttmp = w; w = 0;\n\tfor (j = 0, end = 0; j < c->n; ++j) {\n\t\tconst mem_seed_t *s = &c->seeds[j];\n\t\tif (s->rbeg >= end) w += s->len;\n\t\telse if (s->rbeg + s->len > end) w += s->rbeg + s->len - end;\n\t\tend = end > s->rbeg + s->len? end : s->rbeg + s->len;\n\t}\n\tw = w < tmp? w : tmp;\n\treturn w < 1<<30? w : (1<<30)-1;\n}\n\nvoid mem_print_chain(const bntseq_t *bns, mem_chain_v *chn)\n{\n\tint i, j;\n\tfor (i = 0; i < chn->n; ++i) {\n\t\tmem_chain_t *p = &chn->a[i];\n\t\terr_printf(\"* Found CHAIN(%d): n=%d; weight=%d\", i, p->n, mem_chain_weight(p));\n\t\tfor (j = 0; j < p->n; ++j) {\n\t\t\tbwtint_t pos;\n\t\t\tint is_rev;\n\t\t\tpos = bns_depos(bns, p->seeds[j].rbeg, &is_rev);\n\t\t\tif (is_rev) pos -= p->seeds[j].len - 1;\n\t\t\terr_printf(\"\\t%d;%d;%d,%ld(%s:%c%ld)\", p->seeds[j].score, p->seeds[j].len, p->seeds[j].qbeg, (long)p->seeds[j].rbeg, bns->anns[p->rid].name, \"+-\"[is_rev], (long)(pos - bns->anns[p->rid].offset) + 1);\n\t\t}\n\t\terr_putchar('\\n');\n\t}\n}\n\nmem_chain_v mem_chain(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, int len, const uint8_t *seq, void *buf)\n{\n\tint i, b, e, l_rep;\n\tint64_t l_pac = bns->l_pac;\n\tmem_chain_v chain;\n\tkbtree_t(chn) *tree;\n\tsmem_aux_t *aux;\n\n\tkv_init(chain);\n\tif (len < opt->min_seed_len) return chain; // if the query is shorter than the seed length, no match\n\ttree = kb_init(chn, KB_DEFAULT_SIZE);\n\n\taux = buf? (smem_aux_t*)buf : smem_aux_init();\n\tmem_collect_intv(opt, bwt, len, seq, aux);\n\tfor (i = 0, b = e = l_rep = 0; i < aux->mem.n; ++i) { // compute frac_rep\n\t\tbwtintv_t *p = &aux->mem.a[i];\n\t\tint sb = (p->info>>32), se = (uint32_t)p->info;\n\t\tif (p->x[2] <= opt->max_occ) continue;\n\t\tif (sb > e) l_rep += e - b, b = sb, e = se;\n\t\telse e = e > se? e : se;\n\t}\n\tl_rep += e - b;\n\tfor (i = 0; i < aux->mem.n; ++i) {\n\t\tbwtintv_t *p = &aux->mem.a[i];\n\t\tint step, count, slen = (uint32_t)p->info - (p->info>>32); // seed length\n\t\tint64_t k;\n\t\t// if (slen < opt->min_seed_len) continue; // ignore if too short or too repetitive\n\t\tstep = p->x[2] > opt->max_occ? p->x[2] / opt->max_occ : 1;\n\t\tfor (k = count = 0; k < p->x[2] && count < opt->max_occ; k += step, ++count) {\n\t\t\tmem_chain_t tmp, *lower, *upper;\n\t\t\tmem_seed_t s;\n\t\t\tint rid, to_add = 0;\n\t\t\ts.rbeg = tmp.pos = bwt_sa(bwt, p->x[0] + k); // this is the base coordinate in the forward-reverse reference\n\t\t\ts.qbeg = p->info>>32;\n\t\t\ts.score= s.len = slen;\n\t\t\trid = bns_intv2rid(bns, s.rbeg, s.rbeg + s.len);\n\t\t\tif (rid < 0) continue; // bridging multiple reference sequences or the forward-reverse boundary; TODO: split the seed; don't discard it!!!\n\t\t\tif (kb_size(tree)) {\n\t\t\t\tkb_intervalp(chn, tree, &tmp, &lower, &upper); // find the closest chain\n\t\t\t\tif (!lower || !test_and_merge(opt, l_pac, lower, &s, rid)) to_add = 1;\n\t\t\t} else to_add = 1;\n\t\t\tif (to_add) { // add the seed as a new chain\n\t\t\t\ttmp.n = 1; tmp.m = 4;\n\t\t\t\ttmp.seeds = calloc(tmp.m, sizeof(mem_seed_t));\n\t\t\t\ttmp.seeds[0] = s;\n\t\t\t\ttmp.rid = rid;\n\t\t\t\ttmp.is_alt = !!bns->anns[rid].is_alt;\n\t\t\t\tkb_putp(chn, tree, &tmp);\n\t\t\t}\n\t\t}\n\t}\n\tif (buf == 0) smem_aux_destroy(aux);\n\n\tkv_resize(mem_chain_t, chain, kb_size(tree));\n\n\t#define traverse_func(p_) (chain.a[chain.n++] = *(p_))\n\t__kb_traverse(mem_chain_t, tree, traverse_func);\n\t#undef traverse_func\n\n\tfor (i = 0; i < chain.n; ++i) chain.a[i].frac_rep = (float)l_rep / len;\n\tif (bwa_verbose >= 4) printf(\"* fraction of repetitive seeds: %.3f\\n\", (float)l_rep / len);\n\n\tkb_destroy(chn, tree);\n\treturn chain;\n}\n\n/********************\n * Filtering chains *\n ********************/\n\n#define chn_beg(ch) ((ch).seeds->qbeg)\n#define chn_end(ch) ((ch).seeds[(ch).n-1].qbeg + (ch).seeds[(ch).n-1].len)\n\n#define flt_lt(a, b) ((a).w > (b).w)\nKSORT_INIT(mem_flt, mem_chain_t, flt_lt)\n\nint mem_chain_flt(const mem_opt_t *opt, int n_chn, mem_chain_t *a)\n{\n\tint i, k;\n\tkvec_t(int) chains = {0,0,0}; // this keeps int indices of the non-overlapping chains\n\tif (n_chn == 0) return 0; // no need to filter\n\t// compute the weight of each chain and drop chains with small weight\n\tfor (i = k = 0; i < n_chn; ++i) {\n\t\tmem_chain_t *c = &a[i];\n\t\tc->first = -1; c->kept = 0;\n\t\tc->w = mem_chain_weight(c);\n\t\tif (c->w < opt->min_chain_weight) free(c->seeds);\n\t\telse a[k++] = *c;\n\t}\n\tn_chn = k;\n\tks_introsort(mem_flt, n_chn, a);\n\t// pairwise chain comparisons\n\ta[0].kept = 3;\n\tkv_push(int, chains, 0);\n\tfor (i = 1; i < n_chn; ++i) {\n\t\tint large_ovlp = 0;\n\t\tfor (k = 0; k < chains.n; ++k) {\n\t\t\tint j = chains.a[k];\n\t\t\tint b_max = chn_beg(a[j]) > chn_beg(a[i])? chn_beg(a[j]) : chn_beg(a[i]);\n\t\t\tint e_min = chn_end(a[j]) < chn_end(a[i])? chn_end(a[j]) : chn_end(a[i]);\n\t\t\tif (e_min > b_max && (!a[j].is_alt || a[i].is_alt)) { // have overlap; don't consider ovlp where the kept chain is ALT while the current chain is primary\n\t\t\t\tint li = chn_end(a[i]) - chn_beg(a[i]);\n\t\t\t\tint lj = chn_end(a[j]) - chn_beg(a[j]);\n\t\t\t\tint min_l = li < lj? li : lj;\n\t\t\t\tif (e_min - b_max >= min_l * opt->mask_level && min_l < opt->max_chain_gap) { // significant overlap\n\t\t\t\t\tlarge_ovlp = 1;\n\t\t\t\t\tif (a[j].first < 0) a[j].first = i; // keep the first shadowed hit s.t. mapq can be more accurate\n\t\t\t\t\tif (a[i].w < a[j].w * opt->drop_ratio && a[j].w - a[i].w >= opt->min_seed_len<<1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (k == chains.n) {\n\t\t\tkv_push(int, chains, i);\n\t\t\ta[i].kept = large_ovlp? 2 : 3;\n\t\t}\n\t}\n\tfor (i = 0; i < chains.n; ++i) {\n\t\tmem_chain_t *c = &a[chains.a[i]];\n\t\tif (c->first >= 0) a[c->first].kept = 1;\n\t}\n\tfree(chains.a);\n\tfor (i = k = 0; i < n_chn; ++i) { // don't extend more than opt->max_chain_extend .kept=1/2 chains\n\t\tif (a[i].kept == 0 || a[i].kept == 3) continue;\n\t\tif (++k >= opt->max_chain_extend) break;\n\t}\n\tfor (; i < n_chn; ++i)\n\t\tif (a[i].kept < 3) a[i].kept = 0;\n\tfor (i = k = 0; i < n_chn; ++i) { // free discarded chains\n\t\tmem_chain_t *c = &a[i];\n\t\tif (c->kept == 0) free(c->seeds);\n\t\telse a[k++] = a[i];\n\t}\n\treturn k;\n}\n\n/******************************\n * De-overlap single-end hits *\n ******************************/\n\n#define alnreg_slt2(a, b) ((a).re < (b).re)\nKSORT_INIT(mem_ars2, mem_alnreg_t, alnreg_slt2)\n\n#define alnreg_slt(a, b) ((a).score > (b).score || ((a).score == (b).score && ((a).rb < (b).rb || ((a).rb == (b).rb && (a).qb < (b).qb))))\nKSORT_INIT(mem_ars, mem_alnreg_t, alnreg_slt)\n\n#define alnreg_hlt(a, b)  ((a).score > (b).score || ((a).score == (b).score && ((a).is_alt < (b).is_alt || ((a).is_alt == (b).is_alt && (a).hash < (b).hash))))\nKSORT_INIT(mem_ars_hash, mem_alnreg_t, alnreg_hlt)\n\n#define alnreg_hlt2(a, b) ((a).is_alt < (b).is_alt || ((a).is_alt == (b).is_alt && ((a).score > (b).score || ((a).score == (b).score && (a).hash < (b).hash))))\nKSORT_INIT(mem_ars_hash2, mem_alnreg_t, alnreg_hlt2)\n\n#define PATCH_MAX_R_BW 0.05f\n#define PATCH_MIN_SC_RATIO 0.90f\n\nint mem_patch_reg(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, uint8_t *query, const mem_alnreg_t *a, const mem_alnreg_t *b, int *_w)\n{\n\tint w, score, q_s, r_s;\n\tdouble r;\n\tif (bns == 0 || pac == 0 || query == 0) return 0;\n\tassert(a->rid == b->rid && a->rb <= b->rb);\n\tif (a->rb < bns->l_pac && b->rb >= bns->l_pac) return 0; // on different strands\n\tif (a->qb >= b->qb || a->qe >= b->qe || a->re >= b->re) return 0; // not colinear\n\tw = (a->re - b->rb) - (a->qe - b->qb); // required bandwidth\n\tw = w > 0? w : -w; // l = abs(l)\n\tr = (double)(a->re - b->rb) / (b->re - a->rb) - (double)(a->qe - b->qb) / (b->qe - a->qb); // relative bandwidth\n\tr = r > 0.? r : -r; // r = fabs(r)\n\tif (bwa_verbose >= 4)\n\t\tprintf(\"* potential hit merge between [%d,%d)<=>[%ld,%ld) and [%d,%d)<=>[%ld,%ld), @ %s; w=%d, r=%.4g\\n\",\n\t\t\t   a->qb, a->qe, (long)a->rb, (long)a->re, b->qb, b->qe, (long)b->rb, (long)b->re, bns->anns[a->rid].name, w, r);\n\tif (a->re < b->rb || a->qe < b->qb) { // no overlap on query or on ref\n\t\tif (w > opt->w<<1 || r >= PATCH_MAX_R_BW) return 0; // the bandwidth or the relative bandwidth is too large\n\t} else if (w > opt->w<<2 || r >= PATCH_MAX_R_BW*2) return 0; // more permissive if overlapping on both ref and query\n\t// global alignment\n\tw += a->w + b->w;\n\tw = w < opt->w<<2? w : opt->w<<2;\n\tif (bwa_verbose >= 4) printf(\"* test potential hit merge with global alignment; w=%d\\n\", w);\n\tbwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w, bns->l_pac, pac, b->qe - a->qb, query + a->qb, a->rb, b->re, &score, 0, 0);\n\tq_s = (int)((double)(b->qe - a->qb) / ((b->qe - b->qb) + (a->qe - a->qb)) * (b->score + a->score) + .499); // predicted score from query\n\tr_s = (int)((double)(b->re - a->rb) / ((b->re - b->rb) + (a->re - a->rb)) * (b->score + a->score) + .499); // predicted score from ref\n\tif (bwa_verbose >= 4) printf(\"* score=%d;(%d,%d)\\n\", score, q_s, r_s);\n\tif ((double)score / (q_s > r_s? q_s : r_s) < PATCH_MIN_SC_RATIO) return 0;\n\t*_w = w;\n\treturn score;\n}\n\nint mem_sort_dedup_patch(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, uint8_t *query, int n, mem_alnreg_t *a)\n{\n\tint m, i, j;\n\tif (n <= 1) return n;\n\tks_introsort(mem_ars2, n, a); // sort by the END position, not START!\n\tfor (i = 0; i < n; ++i) a[i].n_comp = 1;\n\tfor (i = 1; i < n; ++i) {\n\t\tmem_alnreg_t *p = &a[i];\n\t\tif (p->rid != a[i-1].rid || p->rb >= a[i-1].re + opt->max_chain_gap) continue; // then no need to go into the loop below\n\t\tfor (j = i - 1; j >= 0 && p->rid == a[j].rid && p->rb < a[j].re + opt->max_chain_gap; --j) {\n\t\t\tmem_alnreg_t *q = &a[j];\n\t\t\tint64_t or, oq, mr, mq;\n\t\t\tint score, w;\n\t\t\tif (q->qe == q->qb) continue; // a[j] has been excluded\n\t\t\tor = q->re - p->rb; // overlap length on the reference\n\t\t\toq = q->qb < p->qb? q->qe - p->qb : p->qe - q->qb; // overlap length on the query\n\t\t\tmr = q->re - q->rb < p->re - p->rb? q->re - q->rb : p->re - p->rb; // min ref len in alignment\n\t\t\tmq = q->qe - q->qb < p->qe - p->qb? q->qe - q->qb : p->qe - p->qb; // min qry len in alignment\n\t\t\tif (or > opt->mask_level_redun * mr && oq > opt->mask_level_redun * mq) { // one of the hits is redundant\n\t\t\t\tif (p->score < q->score) {\n\t\t\t\t\tp->qe = p->qb;\n\t\t\t\t\tbreak;\n\t\t\t\t} else q->qe = q->qb;\n\t\t\t} else if (q->rb < p->rb && (score = mem_patch_reg(opt, bns, pac, query, q, p, &w)) > 0) { // then merge q into p\n\t\t\t\tp->n_comp += q->n_comp + 1;\n\t\t\t\tp->seedcov = p->seedcov > q->seedcov? p->seedcov : q->seedcov;\n\t\t\t\tp->sub = p->sub > q->sub? p->sub : q->sub;\n\t\t\t\tp->csub = p->csub > q->csub? p->csub : q->csub;\n\t\t\t\tp->qb = q->qb, p->rb = q->rb;\n\t\t\t\tp->truesc = p->score = score;\n\t\t\t\tp->w = w;\n\t\t\t\tq->qb = q->qe;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0, m = 0; i < n; ++i) // exclude identical hits\n\t\tif (a[i].qe > a[i].qb) {\n\t\t\tif (m != i) a[m++] = a[i];\n\t\t\telse ++m;\n\t\t}\n\tn = m;\n\tks_introsort(mem_ars, n, a);\n\tfor (i = 1; i < n; ++i) { // mark identical hits\n\t\tif (a[i].score == a[i-1].score && a[i].rb == a[i-1].rb && a[i].qb == a[i-1].qb)\n\t\t\ta[i].qe = a[i].qb;\n\t}\n\tfor (i = 1, m = 1; i < n; ++i) // exclude identical hits\n\t\tif (a[i].qe > a[i].qb) {\n\t\t\tif (m != i) a[m++] = a[i];\n\t\t\telse ++m;\n\t\t}\n\treturn m;\n}\n\ntypedef kvec_t(int) int_v;\n\nstatic void mem_mark_primary_se_core(const mem_opt_t *opt, int n, mem_alnreg_t *a, int_v *z)\n{ // similar to the loop in mem_chain_flt()\n\tint i, k, tmp;\n\ttmp = opt->a + opt->b;\n\ttmp = opt->o_del + opt->e_del > tmp? opt->o_del + opt->e_del : tmp;\n\ttmp = opt->o_ins + opt->e_ins > tmp? opt->o_ins + opt->e_ins : tmp;\n\tz->n = 0;\n\tkv_push(int, *z, 0);\n\tfor (i = 1; i < n; ++i) {\n\t\tfor (k = 0; k < z->n; ++k) {\n\t\t\tint j = z->a[k];\n\t\t\tint b_max = a[j].qb > a[i].qb? a[j].qb : a[i].qb;\n\t\t\tint e_min = a[j].qe < a[i].qe? a[j].qe : a[i].qe;\n\t\t\tif (e_min > b_max) { // have overlap\n\t\t\t\tint min_l = a[i].qe - a[i].qb < a[j].qe - a[j].qb? a[i].qe - a[i].qb : a[j].qe - a[j].qb;\n\t\t\t\tif (e_min - b_max >= min_l * opt->mask_level) { // significant overlap\n\t\t\t\t\tif (a[j].sub == 0) a[j].sub = a[i].score;\n\t\t\t\t\tif (a[j].score - a[i].score <= tmp && (a[j].is_alt || !a[i].is_alt))\n\t\t\t\t\t\t++a[j].sub_n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (k == z->n) kv_push(int, *z, i);\n\t\telse a[i].secondary = z->a[k];\n\t}\n}\n\nint mem_mark_primary_se(const mem_opt_t *opt, int n, mem_alnreg_t *a, int64_t id)\n{\n\tint i, n_pri;\n\tint_v z = {0,0,0};\n\tif (n == 0) return 0;\n\tfor (i = n_pri = 0; i < n; ++i) {\n\t\ta[i].sub = a[i].alt_sc = 0, a[i].secondary = a[i].secondary_all = -1, a[i].hash = hash_64(id+i);\n\t\tif (!a[i].is_alt) ++n_pri;\n\t}\n\tks_introsort(mem_ars_hash, n, a);\n\tmem_mark_primary_se_core(opt, n, a, &z);\n\tfor (i = 0; i < n; ++i) {\n\t\tmem_alnreg_t *p = &a[i];\n\t\tp->secondary_all = i; // keep the rank in the first round\n\t\tif (!p->is_alt && p->secondary >= 0 && a[p->secondary].is_alt)\n\t\t\tp->alt_sc = a[p->secondary].score;\n\t}\n\tif (n_pri >= 0 && n_pri < n) {\n\t\tkv_resize(int, z, n);\n\t\tif (n_pri > 0) ks_introsort(mem_ars_hash2, n, a);\n\t\tfor (i = 0; i < n; ++i) z.a[a[i].secondary_all] = i;\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tif (a[i].secondary >= 0) {\n\t\t\t\ta[i].secondary_all = z.a[a[i].secondary];\n\t\t\t\tif (a[i].is_alt) a[i].secondary = INT_MAX;\n\t\t\t} else a[i].secondary_all = -1;\n\t\t}\n\t\tif (n_pri > 0) { // mark primary for hits to the primary assembly only\n\t\t\tfor (i = 0; i < n_pri; ++i) a[i].sub = 0, a[i].secondary = -1;\n\t\t\tmem_mark_primary_se_core(opt, n_pri, a, &z);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < n; ++i)\n\t\t\ta[i].secondary_all = a[i].secondary;\n\t}\n\tfree(z.a);\n\treturn n_pri;\n}\n\n/*********************************\n * Test if a seed is good enough *\n *********************************/\n\n#define MEM_SHORT_EXT 50\n#define MEM_SHORT_LEN 200\n\n#define MEM_HSP_COEF 1.1f\n#define MEM_MINSC_COEF 5.5f\n#define MEM_SEEDSW_COEF 0.05f\n\nint mem_seed_sw(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const uint8_t *query, const mem_seed_t *s)\n{\n\tint qb, qe, rid;\n\tint64_t rb, re, mid, l_pac = bns->l_pac;\n\tuint8_t *rseq = 0;\n\tkswr_t x;\n\n\tif (s->len >= MEM_SHORT_LEN) return -1; // the seed is longer than the max-extend; no need to do SW\n\tqb = s->qbeg, qe = s->qbeg + s->len;\n\trb = s->rbeg, re = s->rbeg + s->len;\n\tmid = (rb + re) >> 1;\n\tqb -= MEM_SHORT_EXT; qb = qb > 0? qb : 0;\n\tqe += MEM_SHORT_EXT; qe = qe < l_query? qe : l_query;\n\trb -= MEM_SHORT_EXT; rb = rb > 0? rb : 0;\n\tre += MEM_SHORT_EXT; re = re < l_pac<<1? re : l_pac<<1;\n\tif (rb < l_pac && l_pac < re) {\n\t\tif (mid < l_pac) re = l_pac;\n\t\telse rb = l_pac;\n\t}\n\tif (qe - qb >= MEM_SHORT_LEN || re - rb >= MEM_SHORT_LEN) return -1; // the seed seems good enough; no need to do SW\n\n\trseq = bns_fetch_seq(bns, pac, &rb, mid, &re, &rid);\n\tx = ksw_align2(qe - qb, (uint8_t*)query + qb, re - rb, rseq, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, KSW_XSTART, 0);\n\tfree(rseq);\n\treturn x.score;\n}\n\nvoid mem_flt_chained_seeds(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const uint8_t *query, int n_chn, mem_chain_t *a)\n{\n\tdouble min_l = opt->min_chain_weight? MEM_HSP_COEF * opt->min_chain_weight : MEM_MINSC_COEF * log(l_query);\n\tint i, j, k, min_HSP_score = (int)(opt->a * min_l + .499);\n\tif (min_l > MEM_SEEDSW_COEF * l_query) return; // don't run the following for short reads\n\tfor (i = 0; i < n_chn; ++i) {\n\t\tmem_chain_t *c = &a[i];\n\t\tfor (j = k = 0; j < c->n; ++j) {\n\t\t\tmem_seed_t *s = &c->seeds[j];\n\t\t\ts->score = mem_seed_sw(opt, bns, pac, l_query, query, s);\n\t\t\tif (s->score < 0 || s->score >= min_HSP_score) {\n\t\t\t\ts->score = s->score < 0? s->len * opt->a : s->score;\n\t\t\t\tc->seeds[k++] = *s;\n\t\t\t}\n\t\t}\n\t\tc->n = k;\n\t}\n}\n\n/****************************************\n * Construct the alignment from a chain *\n ****************************************/\n\nstatic inline int cal_max_gap(const mem_opt_t *opt, int qlen)\n{\n\tint l_del = (int)((double)(qlen * opt->a - opt->o_del) / opt->e_del + 1.);\n\tint l_ins = (int)((double)(qlen * opt->a - opt->o_ins) / opt->e_ins + 1.);\n\tint l = l_del > l_ins? l_del : l_ins;\n\tl = l > 1? l : 1;\n\treturn l < opt->w<<1? l : opt->w<<1;\n}\n\n#define MAX_BAND_TRY  2\n\nvoid mem_chain2aln(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const uint8_t *query, const mem_chain_t *c, mem_alnreg_v *av)\n{\n\tint i, k, rid, max_off[2], aw[2]; // aw: actual bandwidth used in extension\n\tint64_t l_pac = bns->l_pac, rmax[2], tmp, max = 0;\n\tconst mem_seed_t *s;\n\tuint8_t *rseq = 0;\n\tuint64_t *srt;\n\n\tif (c->n == 0) return;\n\t// get the max possible span\n\trmax[0] = l_pac<<1; rmax[1] = 0;\n\tfor (i = 0; i < c->n; ++i) {\n\t\tint64_t b, e;\n\t\tconst mem_seed_t *t = &c->seeds[i];\n\t\tb = t->rbeg - (t->qbeg + cal_max_gap(opt, t->qbeg));\n\t\te = t->rbeg + t->len + ((l_query - t->qbeg - t->len) + cal_max_gap(opt, l_query - t->qbeg - t->len));\n\t\trmax[0] = rmax[0] < b? rmax[0] : b;\n\t\trmax[1] = rmax[1] > e? rmax[1] : e;\n\t\tif (t->len > max) max = t->len;\n\t}\n\trmax[0] = rmax[0] > 0? rmax[0] : 0;\n\trmax[1] = rmax[1] < l_pac<<1? rmax[1] : l_pac<<1;\n\tif (rmax[0] < l_pac && l_pac < rmax[1]) { // crossing the forward-reverse boundary; then choose one side\n\t\tif (c->seeds[0].rbeg < l_pac) rmax[1] = l_pac; // this works because all seeds are guaranteed to be on the same strand\n\t\telse rmax[0] = l_pac;\n\t}\n\t// retrieve the reference sequence\n\trseq = bns_fetch_seq(bns, pac, &rmax[0], c->seeds[0].rbeg, &rmax[1], &rid);\n\tassert(c->rid == rid);\n\n\tsrt = malloc(c->n * 8);\n\tfor (i = 0; i < c->n; ++i)\n\t\tsrt[i] = (uint64_t)c->seeds[i].score<<32 | i;\n\tks_introsort_64(c->n, srt);\n\n\tfor (k = c->n - 1; k >= 0; --k) {\n\t\tmem_alnreg_t *a;\n\t\ts = &c->seeds[(uint32_t)srt[k]];\n\n\t\tfor (i = 0; i < av->n; ++i) { // test whether extension has been made before\n\t\t\tmem_alnreg_t *p = &av->a[i];\n\t\t\tint64_t rd;\n\t\t\tint qd, w, max_gap;\n\t\t\tif (s->rbeg < p->rb || s->rbeg + s->len > p->re || s->qbeg < p->qb || s->qbeg + s->len > p->qe) continue; // not fully contained\n\t\t\tif (s->len - p->seedlen0 > .1 * l_query) continue; // this seed may give a better alignment\n\t\t\t// qd: distance ahead of the seed on query; rd: on reference\n\t\t\tqd = s->qbeg - p->qb; rd = s->rbeg - p->rb;\n\t\t\tmax_gap = cal_max_gap(opt, qd < rd? qd : rd); // the maximal gap allowed in regions ahead of the seed\n\t\t\tw = max_gap < p->w? max_gap : p->w; // bounded by the band width\n\t\t\tif (qd - rd < w && rd - qd < w) break; // the seed is \"around\" a previous hit\n\t\t\t// similar to the previous four lines, but this time we look at the region behind\n\t\t\tqd = p->qe - (s->qbeg + s->len); rd = p->re - (s->rbeg + s->len);\n\t\t\tmax_gap = cal_max_gap(opt, qd < rd? qd : rd);\n\t\t\tw = max_gap < p->w? max_gap : p->w;\n\t\t\tif (qd - rd < w && rd - qd < w) break;\n\t\t}\n\t\tif (i < av->n) { // the seed is (almost) contained in an existing alignment; further testing is needed to confirm it is not leading to a different aln\n\t\t\tif (bwa_verbose >= 4)\n\t\t\t\tprintf(\"** Seed(%d) [%ld;%ld,%ld] is almost contained in an existing alignment [%d,%d) <=> [%ld,%ld)\\n\",\n\t\t\t\t\t   k, (long)s->len, (long)s->qbeg, (long)s->rbeg, av->a[i].qb, av->a[i].qe, (long)av->a[i].rb, (long)av->a[i].re);\n\t\t\tfor (i = k + 1; i < c->n; ++i) { // check overlapping seeds in the same chain\n\t\t\t\tconst mem_seed_t *t;\n\t\t\t\tif (srt[i] == 0) continue;\n\t\t\t\tt = &c->seeds[(uint32_t)srt[i]];\n\t\t\t\tif (t->len < s->len * .95) continue; // only check overlapping if t is long enough; TODO: more efficient by early stopping\n\t\t\t\tif (s->qbeg <= t->qbeg && s->qbeg + s->len - t->qbeg >= s->len>>2 && t->qbeg - s->qbeg != t->rbeg - s->rbeg) break;\n\t\t\t\tif (t->qbeg <= s->qbeg && t->qbeg + t->len - s->qbeg >= s->len>>2 && s->qbeg - t->qbeg != s->rbeg - t->rbeg) break;\n\t\t\t}\n\t\t\tif (i == c->n) { // no overlapping seeds; then skip extension\n\t\t\t\tsrt[k] = 0; // mark that seed extension has not been performed\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bwa_verbose >= 4)\n\t\t\t\tprintf(\"** Seed(%d) might lead to a different alignment even though it is contained. Extension will be performed.\\n\", k);\n\t\t}\n\n\t\ta = kv_pushp(mem_alnreg_t, *av);\n\t\tmemset(a, 0, sizeof(mem_alnreg_t));\n\t\ta->w = aw[0] = aw[1] = opt->w;\n\t\ta->score = a->truesc = -1;\n\t\ta->rid = c->rid;\n\n\t\tif (bwa_verbose >= 4) err_printf(\"** ---> Extending from seed(%d) [%ld;%ld,%ld] @ %s <---\\n\", k, (long)s->len, (long)s->qbeg, (long)s->rbeg, bns->anns[c->rid].name);\n\t\tif (s->qbeg) { // left extension\n\t\t\tuint8_t *rs, *qs;\n\t\t\tint qle, tle, gtle, gscore;\n\t\t\tqs = malloc(s->qbeg);\n\t\t\tfor (i = 0; i < s->qbeg; ++i) qs[i] = query[s->qbeg - 1 - i];\n\t\t\ttmp = s->rbeg - rmax[0];\n\t\t\trs = malloc(tmp);\n\t\t\tfor (i = 0; i < tmp; ++i) rs[i] = rseq[tmp - 1 - i];\n\t\t\tfor (i = 0; i < MAX_BAND_TRY; ++i) {\n\t\t\t\tint prev = a->score;\n\t\t\t\taw[0] = opt->w << i;\n\t\t\t\tif (bwa_verbose >= 4) {\n\t\t\t\t\tint j;\n\t\t\t\t\tprintf(\"*** Left ref:   \"); for (j = 0; j < tmp; ++j) putchar(\"ACGTN\"[(int)rs[j]]); putchar('\\n');\n\t\t\t\t\tprintf(\"*** Left query: \"); for (j = 0; j < s->qbeg; ++j) putchar(\"ACGTN\"[(int)qs[j]]); putchar('\\n');\n\t\t\t\t}\n\t\t\t\ta->score = ksw_extend2(s->qbeg, qs, tmp, rs, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, aw[0], opt->pen_clip5, opt->zdrop, s->len * opt->a, &qle, &tle, &gtle, &gscore, &max_off[0]);\n\t\t\t\tif (bwa_verbose >= 4) { printf(\"*** Left extension: prev_score=%d; score=%d; bandwidth=%d; max_off_diagonal_dist=%d\\n\", prev, a->score, aw[0], max_off[0]); fflush(stdout); }\n\t\t\t\tif (a->score == prev || max_off[0] < (aw[0]>>1) + (aw[0]>>2)) break;\n\t\t\t}\n\t\t\t// check whether we prefer to reach the end of the query\n\t\t\tif (gscore <= 0 || gscore <= a->score - opt->pen_clip5) { // local extension\n\t\t\t\ta->qb = s->qbeg - qle, a->rb = s->rbeg - tle;\n\t\t\t\ta->truesc = a->score;\n\t\t\t} else { // to-end extension\n\t\t\t\ta->qb = 0, a->rb = s->rbeg - gtle;\n\t\t\t\ta->truesc = gscore;\n\t\t\t}\n\t\t\tfree(qs); free(rs);\n\t\t} else a->score = a->truesc = s->len * opt->a, a->qb = 0, a->rb = s->rbeg;\n\n\t\tif (s->qbeg + s->len != l_query) { // right extension\n\t\t\tint qle, tle, qe, re, gtle, gscore, sc0 = a->score;\n\t\t\tqe = s->qbeg + s->len;\n\t\t\tre = s->rbeg + s->len - rmax[0];\n\t\t\tassert(re >= 0);\n\t\t\tfor (i = 0; i < MAX_BAND_TRY; ++i) {\n\t\t\t\tint prev = a->score;\n\t\t\t\taw[1] = opt->w << i;\n\t\t\t\tif (bwa_verbose >= 4) {\n\t\t\t\t\tint j;\n\t\t\t\t\tprintf(\"*** Right ref:   \"); for (j = 0; j < rmax[1] - rmax[0] - re; ++j) putchar(\"ACGTN\"[(int)rseq[re+j]]); putchar('\\n');\n\t\t\t\t\tprintf(\"*** Right query: \"); for (j = 0; j < l_query - qe; ++j) putchar(\"ACGTN\"[(int)query[qe+j]]); putchar('\\n');\n\t\t\t\t}\n\t\t\t\ta->score = ksw_extend2(l_query - qe, query + qe, rmax[1] - rmax[0] - re, rseq + re, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, aw[1], opt->pen_clip3, opt->zdrop, sc0, &qle, &tle, &gtle, &gscore, &max_off[1]);\n\t\t\t\tif (bwa_verbose >= 4) { printf(\"*** Right extension: prev_score=%d; score=%d; bandwidth=%d; max_off_diagonal_dist=%d\\n\", prev, a->score, aw[1], max_off[1]); fflush(stdout); }\n\t\t\t\tif (a->score == prev || max_off[1] < (aw[1]>>1) + (aw[1]>>2)) break;\n\t\t\t}\n\t\t\t// similar to the above\n\t\t\tif (gscore <= 0 || gscore <= a->score - opt->pen_clip3) { // local extension\n\t\t\t\ta->qe = qe + qle, a->re = rmax[0] + re + tle;\n\t\t\t\ta->truesc += a->score - sc0;\n\t\t\t} else { // to-end extension\n\t\t\t\ta->qe = l_query, a->re = rmax[0] + re + gtle;\n\t\t\t\ta->truesc += gscore - sc0;\n\t\t\t}\n\t\t} else a->qe = l_query, a->re = s->rbeg + s->len;\n\t\tif (bwa_verbose >= 4) printf(\"*** Added alignment region: [%d,%d) <=> [%ld,%ld); score=%d; {left,right}_bandwidth={%d,%d}\\n\", a->qb, a->qe, (long)a->rb, (long)a->re, a->score, aw[0], aw[1]);\n\n\t\t// compute seedcov\n\t\tfor (i = 0, a->seedcov = 0; i < c->n; ++i) {\n\t\t\tconst mem_seed_t *t = &c->seeds[i];\n\t\t\tif (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe && t->rbeg >= a->rb && t->rbeg + t->len <= a->re) // seed fully contained\n\t\t\t\ta->seedcov += t->len; // this is not very accurate, but for approx. mapQ, this is good enough\n\t\t}\n\t\ta->w = aw[0] > aw[1]? aw[0] : aw[1];\n\t\ta->seedlen0 = s->len;\n\n\t\ta->frac_rep = c->frac_rep;\n\t}\n\tfree(srt); free(rseq);\n}\n\n/*****************************\n * Basic hit->SAM conversion *\n *****************************/\n\nstatic inline int infer_bw(int l1, int l2, int score, int a, int q, int r)\n{\n\tint w;\n\tif (l1 == l2 && l1 * a - score < (q + r - a)<<1) return 0; // to get equal alignment length, we need at least two gaps\n\tw = ((double)((l1 < l2? l1 : l2) * a - score - q) / r + 2.);\n\tif (w < abs(l1 - l2)) w = abs(l1 - l2);\n\treturn w;\n}\n\nstatic inline int get_rlen(int n_cigar, const uint32_t *cigar)\n{\n\tint k, l;\n\tfor (k = l = 0; k < n_cigar; ++k) {\n\t\tint op = cigar[k]&0xf;\n\t\tif (op == 0 || op == 2)\n\t\t\tl += cigar[k]>>4;\n\t}\n\treturn l;\n}\n\nstatic inline void add_cigar(const mem_opt_t *opt, mem_aln_t *p, kstring_t *str, int which)\n{\n\tint i;\n\tif (p->n_cigar) { // aligned\n\t\tfor (i = 0; i < p->n_cigar; ++i) {\n\t\t\tint c = p->cigar[i]&0xf;\n\t\t\tif (!(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt && (c == 3 || c == 4))\n\t\t\t\tc = which? 4 : 3; // use hard clipping for supplementary alignments\n\t\t\tkputw(p->cigar[i]>>4, str); kputc(\"MIDSH\"[c], str);\n\t\t}\n\t} else kputc('*', str); // having a coordinate but unaligned (e.g. when copy_mate is true)\n}\n\nvoid mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq1_t *s, int n, const mem_aln_t *list, int which, const mem_aln_t *m_)\n{\n\tint i, l_name;\n\tmem_aln_t ptmp = list[which], *p = &ptmp, mtmp, *m = 0; // make a copy of the alignment to convert\n\n\tif (m_) mtmp = *m_, m = &mtmp;\n\t// set flag\n\tp->flag |= m? 0x1 : 0; // is paired in sequencing\n\tp->flag |= p->rid < 0? 0x4 : 0; // is mapped\n\tp->flag |= m && m->rid < 0? 0x8 : 0; // is mate mapped\n\tif (p->rid < 0 && m && m->rid >= 0) // copy mate to alignment\n\t\tp->rid = m->rid, p->pos = m->pos, p->is_rev = m->is_rev, p->n_cigar = 0;\n\tif (m && m->rid < 0 && p->rid >= 0) // copy alignment to mate\n\t\tm->rid = p->rid, m->pos = p->pos, m->is_rev = p->is_rev, m->n_cigar = 0;\n\tp->flag |= p->is_rev? 0x10 : 0; // is on the reverse strand\n\tp->flag |= m && m->is_rev? 0x20 : 0; // is mate on the reverse strand\n\n\t// print up to CIGAR\n\tl_name = strlen(s->name);\n\tks_resize(str, str->l + s->l_seq + l_name + (s->qual? s->l_seq : 0) + 20);\n\tkputsn(s->name, l_name, str); kputc('\\t', str); // QNAME\n\tkputw((p->flag&0xffff) | (p->flag&0x10000? 0x100 : 0), str); kputc('\\t', str); // FLAG\n\tif (p->rid >= 0) { // with coordinate\n\t\tkputs(bns->anns[p->rid].name, str); kputc('\\t', str); // RNAME\n\t\tkputl(p->pos + 1, str); kputc('\\t', str); // POS\n\t\tkputw(p->mapq, str); kputc('\\t', str); // MAPQ\n\t\tadd_cigar(opt, p, str, which);\n\t} else kputsn(\"*\\t0\\t0\\t*\", 7, str); // without coordinte\n\tkputc('\\t', str);\n\n\t// print the mate position if applicable\n\tif (m && m->rid >= 0) {\n\t\tif (p->rid == m->rid) kputc('=', str);\n\t\telse kputs(bns->anns[m->rid].name, str);\n\t\tkputc('\\t', str);\n\t\tkputl(m->pos + 1, str); kputc('\\t', str);\n\t\tif (p->rid == m->rid) {\n\t\t\tint64_t p0 = p->pos + (p->is_rev? get_rlen(p->n_cigar, p->cigar) - 1 : 0);\n\t\t\tint64_t p1 = m->pos + (m->is_rev? get_rlen(m->n_cigar, m->cigar) - 1 : 0);\n\t\t\tif (m->n_cigar == 0 || p->n_cigar == 0) kputc('0', str);\n\t\t\telse kputl(-(p0 - p1 + (p0 > p1? 1 : p0 < p1? -1 : 0)), str);\n\t\t} else kputc('0', str);\n\t} else kputsn(\"*\\t0\\t0\", 5, str);\n\tkputc('\\t', str);\n\n\t// print SEQ and QUAL\n\tif (p->flag & 0x100) { // for secondary alignments, don't write SEQ and QUAL\n\t\tkputsn(\"*\\t*\", 3, str);\n\t} else if (!p->is_rev) { // the forward strand\n\t\tint i, qb = 0, qe = s->l_seq;\n\t\tif (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) { // have cigar && not the primary alignment && not softclip all\n\t\t\tif ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qb += p->cigar[0]>>4;\n\t\t\tif ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qe -= p->cigar[p->n_cigar-1]>>4;\n\t\t}\n\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\tfor (i = qb; i < qe; ++i) str->s[str->l++] = \"ACGTN\"[(int)s->seq[i]];\n\t\tkputc('\\t', str);\n\t\tif (s->qual) { // printf qual\n\t\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\t\tfor (i = qb; i < qe; ++i) str->s[str->l++] = s->qual[i];\n\t\t\tstr->s[str->l] = 0;\n\t\t} else kputc('*', str);\n\t} else { // the reverse strand\n\t\tint i, qb = 0, qe = s->l_seq;\n\t\tif (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) {\n\t\t\tif ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qe -= p->cigar[0]>>4;\n\t\t\tif ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qb += p->cigar[p->n_cigar-1]>>4;\n\t\t}\n\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\tfor (i = qe-1; i >= qb; --i) str->s[str->l++] = \"TGCAN\"[(int)s->seq[i]];\n\t\tkputc('\\t', str);\n\t\tif (s->qual) { // printf qual\n\t\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\t\tfor (i = qe-1; i >= qb; --i) str->s[str->l++] = s->qual[i];\n\t\t\tstr->s[str->l] = 0;\n\t\t} else kputc('*', str);\n\t}\n\n\t// print optional tags\n\tif (p->n_cigar) {\n\t\tkputsn(\"\\tNM:i:\", 6, str); kputw(p->NM, str);\n\t\tkputsn(\"\\tMD:Z:\", 6, str); kputs((char*)(p->cigar + p->n_cigar), str);\n\t}\n\tif (m && m->n_cigar) { kputsn(\"\\tMC:Z:\", 6, str); add_cigar(opt, m, str, which); }\n\tif (m) { kputsn(\"\\tMQ:i:\", 6, str); kputw(m->mapq, str);}\n\tif (p->score >= 0) { kputsn(\"\\tAS:i:\", 6, str); kputw(p->score, str); }\n\tif (p->sub >= 0) { kputsn(\"\\tXS:i:\", 6, str); kputw(p->sub, str); }\n\tif (bwa_rg_id[0]) { kputsn(\"\\tRG:Z:\", 6, str); kputs(bwa_rg_id, str); }\n\tif (!(p->flag & 0x100)) { // not multi-hit\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tif (i != which && !(list[i].flag&0x100)) break;\n\t\tif (i < n) { // there are other primary hits; output them\n\t\t\tkputsn(\"\\tSA:Z:\", 6, str);\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tconst mem_aln_t *r = &list[i];\n\t\t\t\tint k;\n\t\t\t\tif (i == which || (r->flag&0x100)) continue; // proceed if: 1) different from the current; 2) not shadowed multi hit\n\t\t\t\tkputs(bns->anns[r->rid].name, str); kputc(',', str);\n\t\t\t\tkputl(r->pos+1, str); kputc(',', str);\n\t\t\t\tkputc(\"+-\"[r->is_rev], str); kputc(',', str);\n\t\t\t\tfor (k = 0; k < r->n_cigar; ++k) {\n\t\t\t\t\tkputw(r->cigar[k]>>4, str); kputc(\"MIDSH\"[r->cigar[k]&0xf], str);\n\t\t\t\t}\n\t\t\t\tkputc(',', str); kputw(r->mapq, str);\n\t\t\t\tkputc(',', str); kputw(r->NM, str);\n\t\t\t\tkputc(';', str);\n\t\t\t}\n\t\t}\n\t\tif (p->alt_sc > 0)\n\t\t\tksprintf(str, \"\\tpa:f:%.3f\", (double)p->score / p->alt_sc);\n\t}\n\tif (p->XA) {\n\t\tkputsn((opt->flag&MEM_F_XB)? \"\\tXB:Z:\" : \"\\tXA:Z:\", 6, str);\n\t\tkputs(p->XA, str);\n\t}\n\tif (s->comment) { kputc('\\t', str); kputs(s->comment, str); }\n\tif ((opt->flag&MEM_F_REF_HDR) && p->rid >= 0 && bns->anns[p->rid].anno != 0 && bns->anns[p->rid].anno[0] != 0) {\n\t\tint tmp;\n\t\tkputsn(\"\\tXR:Z:\", 6, str);\n\t\ttmp = str->l;\n\t\tkputs(bns->anns[p->rid].anno, str);\n\t\tfor (i = tmp; i < str->l; ++i) // replace TAB in the comment to SPACE\n\t\t\tif (str->s[i] == '\\t') str->s[i] = ' ';\n\t}\n\tkputc('\\n', str);\n}\n\n/************************\n * Integrated interface *\n ************************/\n\nint mem_approx_mapq_se(const mem_opt_t *opt, const mem_alnreg_t *a)\n{\n\tint mapq, l, sub = a->sub? a->sub : opt->min_seed_len * opt->a;\n\tdouble identity;\n\tsub = a->csub > sub? a->csub : sub;\n\tif (sub >= a->score) return 0;\n\tl = a->qe - a->qb > a->re - a->rb? a->qe - a->qb : a->re - a->rb;\n\tidentity = 1. - (double)(l * opt->a - a->score) / (opt->a + opt->b) / l;\n\tif (a->score == 0) {\n\t\tmapq = 0;\n\t} else if (opt->mapQ_coef_len > 0) {\n\t\tdouble tmp;\n\t\ttmp = l < opt->mapQ_coef_len? 1. : opt->mapQ_coef_fac / log(l);\n\t\ttmp *= identity * identity;\n\t\tmapq = (int)(6.02 * (a->score - sub) / opt->a * tmp * tmp + .499);\n\t} else {\n\t\tmapq = (int)(MEM_MAPQ_COEF * (1. - (double)sub / a->score) * log(a->seedcov) + .499);\n\t\tmapq = identity < 0.95? (int)(mapq * identity * identity + .499) : mapq;\n\t}\n\tif (a->sub_n > 0) mapq -= (int)(4.343 * log(a->sub_n+1) + .499);\n\tif (mapq > 60) mapq = 60;\n\tif (mapq < 0) mapq = 0;\n\tmapq = (int)(mapq * (1. - a->frac_rep) + .499);\n\treturn mapq;\n}\n\nvoid mem_reorder_primary5(int T, mem_alnreg_v *a)\n{\n\tint k, n_pri = 0, left_st = INT_MAX, left_k = -1;\n\tmem_alnreg_t t;\n\tfor (k = 0; k < a->n; ++k)\n\t\tif (a->a[k].secondary < 0 && !a->a[k].is_alt && a->a[k].score >= T) ++n_pri;\n\tif (n_pri <= 1) return; // only one alignment\n\tfor (k = 0; k < a->n; ++k) {\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tif (p->secondary >= 0 || p->is_alt || p->score < T) continue;\n\t\tif (p->qb < left_st) left_st = p->qb, left_k = k;\n\t}\n\tassert(a->a[0].secondary < 0);\n\tif (left_k == 0) return; // no need to reorder\n\tt = a->a[0], a->a[0] = a->a[left_k], a->a[left_k] = t;\n\tfor (k = 1; k < a->n; ++k) { // update secondary and secondary_all\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tif (p->secondary == 0) p->secondary = left_k;\n\t\telse if (p->secondary == left_k) p->secondary = 0;\n\t\tif (p->secondary_all == 0) p->secondary_all = left_k;\n\t\telse if (p->secondary_all == left_k) p->secondary_all = 0;\n\t}\n}\n\n// TODO (future plan): group hits into a uint64_t[] array. This will be cleaner and more flexible\nvoid mem_reg2sam(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, bseq1_t *s, mem_alnreg_v *a, int extra_flag, const mem_aln_t *m)\n{\n\textern char **mem_gen_alt(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, mem_alnreg_v *a, int l_query, const char *query);\n\tkstring_t str;\n\tkvec_t(mem_aln_t) aa;\n\tint k, l;\n\tchar **XA = 0;\n\n\tif (!(opt->flag & MEM_F_ALL))\n\t\tXA = mem_gen_alt(opt, bns, pac, a, s->l_seq, s->seq);\n\tkv_init(aa);\n\tstr.l = str.m = 0; str.s = 0;\n\tfor (k = l = 0; k < a->n; ++k) {\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tmem_aln_t *q;\n\t\tif (p->score < opt->T) continue;\n\t\tif (p->secondary >= 0 && (p->is_alt || !(opt->flag&MEM_F_ALL))) continue;\n\t\tif (p->secondary >= 0 && p->secondary < INT_MAX && p->score < a->a[p->secondary].score * opt->drop_ratio) continue;\n\t\tq = kv_pushp(mem_aln_t, aa);\n\t\t*q = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, p);\n\t\tassert(q->rid >= 0); // this should not happen with the new code\n\t\tq->XA = XA? XA[k] : 0;\n\t\tq->flag |= extra_flag; // flag secondary\n\t\tif (p->secondary >= 0) q->sub = -1; // don't output sub-optimal score\n\t\tif (l && p->secondary < 0) // if supplementary\n\t\t\tq->flag |= (opt->flag&MEM_F_NO_MULTI)? 0x10000 : 0x800;\n\t\tif (!(opt->flag & MEM_F_KEEP_SUPP_MAPQ) && l && !p->is_alt && q->mapq > aa.a[0].mapq)\n\t\t\tq->mapq = aa.a[0].mapq; // lower mapq for supplementary mappings, unless -5 or -q is applied\n\t\t++l;\n\t}\n\tif (aa.n == 0) { // no alignments good enough; then write an unaligned record\n\t\tmem_aln_t t;\n\t\tt = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, 0);\n\t\tt.flag |= extra_flag;\n\t\tmem_aln2sam(opt, bns, &str, s, 1, &t, 0, m);\n\t} else {\n\t\tfor (k = 0; k < aa.n; ++k)\n\t\t\tmem_aln2sam(opt, bns, &str, s, aa.n, aa.a, k, m);\n\t\tfor (k = 0; k < aa.n; ++k) free(aa.a[k].cigar);\n\t\tfree(aa.a);\n\t}\n\ts->sam = str.s;\n\tif (XA) {\n\t\tfor (k = 0; k < a->n; ++k) free(XA[k]);\n\t\tfree(XA);\n\t}\n}\n\nmem_alnreg_v mem_align1_core(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, char *seq, void *buf)\n{\n\tint i;\n\tmem_chain_v chn;\n\tmem_alnreg_v regs;\n\n\tfor (i = 0; i < l_seq; ++i) // convert to 2-bit encoding if we have not done so\n\t\tseq[i] = seq[i] < 4? seq[i] : nst_nt4_table[(int)seq[i]];\n\n\tchn = mem_chain(opt, bwt, bns, l_seq, (uint8_t*)seq, buf);\n\tchn.n = mem_chain_flt(opt, chn.n, chn.a);\n\tmem_flt_chained_seeds(opt, bns, pac, l_seq, (uint8_t*)seq, chn.n, chn.a);\n\tif (bwa_verbose >= 4) mem_print_chain(bns, &chn);\n\n\tkv_init(regs);\n\tfor (i = 0; i < chn.n; ++i) {\n\t\tmem_chain_t *p = &chn.a[i];\n\t\tif (bwa_verbose >= 4) err_printf(\"* ---> Processing chain(%d) <---\\n\", i);\n\t\tmem_chain2aln(opt, bns, pac, l_seq, (uint8_t*)seq, p, &regs);\n\t\tfree(chn.a[i].seeds);\n\t}\n\tfree(chn.a);\n\tregs.n = mem_sort_dedup_patch(opt, bns, pac, (uint8_t*)seq, regs.n, regs.a);\n\tif (bwa_verbose >= 4) {\n\t\terr_printf(\"* %ld chains remain after removing duplicated chains\\n\", regs.n);\n\t\tfor (i = 0; i < regs.n; ++i) {\n\t\t\tmem_alnreg_t *p = &regs.a[i];\n\t\t\tprintf(\"** %d, [%d,%d) <=> [%ld,%ld)\\n\", p->score, p->qb, p->qe, (long)p->rb, (long)p->re);\n\t\t}\n\t}\n\tfor (i = 0; i < regs.n; ++i) {\n\t\tmem_alnreg_t *p = &regs.a[i];\n\t\tif (p->rid >= 0 && bns->anns[p->rid].is_alt)\n\t\t\tp->is_alt = 1;\n\t}\n\treturn regs;\n}\n\nmem_aln_t mem_reg2aln(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const char *query_, const mem_alnreg_t *ar)\n{\n\tmem_aln_t a;\n\tint i, w2, tmp, qb, qe, NM, score, is_rev, last_sc = -(1<<30), l_MD;\n\tint64_t pos, rb, re;\n\tuint8_t *query;\n\n\tmemset(&a, 0, sizeof(mem_aln_t));\n\tif (ar == 0 || ar->rb < 0 || ar->re < 0) { // generate an unmapped record\n\t\ta.rid = -1; a.pos = -1; a.flag |= 0x4;\n\t\treturn a;\n\t}\n\tqb = ar->qb, qe = ar->qe;\n\trb = ar->rb, re = ar->re;\n\tquery = malloc(l_query);\n\tfor (i = 0; i < l_query; ++i) // convert to the nt4 encoding\n\t\tquery[i] = query_[i] < 5? query_[i] : nst_nt4_table[(int)query_[i]];\n\ta.mapq = ar->secondary < 0? mem_approx_mapq_se(opt, ar) : 0;\n\tif (ar->secondary >= 0) a.flag |= 0x100; // secondary alignment\n\ttmp = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_del, opt->e_del);\n\tw2  = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_ins, opt->e_ins);\n\tw2 = w2 > tmp? w2 : tmp;\n\tif (bwa_verbose >= 4) printf(\"* Band width: inferred=%d, cmd_opt=%d, alnreg=%d\\n\", w2, opt->w, ar->w);\n\tif (w2 > opt->w) w2 = w2 < ar->w? w2 : ar->w;\n\ti = 0; a.cigar = 0;\n\tdo {\n\t\tfree(a.cigar);\n\t\tw2 = w2 < opt->w<<2? w2 : opt->w<<2;\n\t\ta.cigar = bwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w2, bns->l_pac, pac, qe - qb, (uint8_t*)&query[qb], rb, re, &score, &a.n_cigar, &NM);\n\t\tif (bwa_verbose >= 4) printf(\"* Final alignment: w2=%d, global_sc=%d, local_sc=%d\\n\", w2, score, ar->truesc);\n\t\tif (score == last_sc || w2 == opt->w<<2) break; // it is possible that global alignment and local alignment give different scores\n\t\tlast_sc = score;\n\t\tw2 <<= 1;\n\t} while (++i < 3 && score < ar->truesc - opt->a);\n\tl_MD = strlen((char*)(a.cigar + a.n_cigar)) + 1;\n\ta.NM = NM;\n\tpos = bns_depos(bns, rb < bns->l_pac? rb : re - 1, &is_rev);\n\ta.is_rev = is_rev;\n\tif (a.n_cigar > 0) { // squeeze out leading or trailing deletions\n\t\tif ((a.cigar[0]&0xf) == 2) {\n\t\t\tpos += a.cigar[0]>>4;\n\t\t\t--a.n_cigar;\n\t\t\tmemmove(a.cigar, a.cigar + 1, a.n_cigar * 4 + l_MD);\n\t\t} else if ((a.cigar[a.n_cigar-1]&0xf) == 2) {\n\t\t\t--a.n_cigar;\n\t\t\tmemmove(a.cigar + a.n_cigar, a.cigar + a.n_cigar + 1, l_MD); // MD needs to be moved accordingly\n\t\t}\n\t}\n\tif (qb != 0 || qe != l_query) { // add clipping to CIGAR\n\t\tint clip5, clip3;\n\t\tclip5 = is_rev? l_query - qe : qb;\n\t\tclip3 = is_rev? qb : l_query - qe;\n\t\ta.cigar = realloc(a.cigar, 4 * (a.n_cigar + 2) + l_MD);\n\t\tif (clip5) {\n\t\t\tmemmove(a.cigar+1, a.cigar, a.n_cigar * 4 + l_MD); // make room for 5'-end clipping\n\t\t\ta.cigar[0] = clip5<<4 | 3;\n\t\t\t++a.n_cigar;\n\t\t}\n\t\tif (clip3) {\n\t\t\tmemmove(a.cigar + a.n_cigar + 1, a.cigar + a.n_cigar, l_MD); // make room for 3'-end clipping\n\t\t\ta.cigar[a.n_cigar++] = clip3<<4 | 3;\n\t\t}\n\t}\n\ta.rid = bns_pos2rid(bns, pos);\n\tassert(a.rid == ar->rid);\n\ta.pos = pos - bns->anns[a.rid].offset;\n\ta.score = ar->score; a.sub = ar->sub > ar->csub? ar->sub : ar->csub;\n\ta.is_alt = ar->is_alt; a.alt_sc = ar->alt_sc;\n\tfree(query);\n\treturn a;\n}\n\ntypedef struct {\n\tconst mem_opt_t *opt;\n\tconst bwt_t *bwt;\n\tconst bntseq_t *bns;\n\tconst uint8_t *pac;\n\tconst mem_pestat_t *pes;\n\tsmem_aux_t **aux;\n\tbseq1_t *seqs;\n\tmem_alnreg_v *regs;\n\tint64_t n_processed;\n} worker_t;\n\nstatic void worker1(void *data, int i, int tid)\n{\n\tworker_t *w = (worker_t*)data;\n\tif (!(w->opt->flag&MEM_F_PE)) {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s' <=====\\n\", w->seqs[i].name);\n\t\tw->regs[i] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i].l_seq, w->seqs[i].seq, w->aux[tid]);\n\t} else {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s'/1 <=====\\n\", w->seqs[i<<1|0].name);\n\t\tw->regs[i<<1|0] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i<<1|0].l_seq, w->seqs[i<<1|0].seq, w->aux[tid]);\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s'/2 <=====\\n\", w->seqs[i<<1|1].name);\n\t\tw->regs[i<<1|1] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i<<1|1].l_seq, w->seqs[i<<1|1].seq, w->aux[tid]);\n\t}\n}\n\nstatic void worker2(void *data, int i, int tid)\n{\n\textern int mem_sam_pe(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_pestat_t pes[4], uint64_t id, bseq1_t s[2], mem_alnreg_v a[2]);\n\textern void mem_reg2ovlp(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, bseq1_t *s, mem_alnreg_v *a);\n\tworker_t *w = (worker_t*)data;\n\tif (!(w->opt->flag&MEM_F_PE)) {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Finalizing read '%s' <=====\\n\", w->seqs[i].name);\n\t\tmem_mark_primary_se(w->opt, w->regs[i].n, w->regs[i].a, w->n_processed + i);\n\t\tif (w->opt->flag & MEM_F_PRIMARY5) mem_reorder_primary5(w->opt->T, &w->regs[i]);\n\t\tmem_reg2sam(w->opt, w->bns, w->pac, &w->seqs[i], &w->regs[i], 0, 0);\n\t\tfree(w->regs[i].a);\n\t} else {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Finalizing read pair '%s' <=====\\n\", w->seqs[i<<1|0].name);\n\t\tmem_sam_pe(w->opt, w->bns, w->pac, w->pes, (w->n_processed>>1) + i, &w->seqs[i<<1], &w->regs[i<<1]);\n\t\tfree(w->regs[i<<1|0].a); free(w->regs[i<<1|1].a);\n\t}\n}\n\nvoid mem_process_seqs(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int64_t n_processed, int n, bseq1_t *seqs, const mem_pestat_t *pes0)\n{\n\textern void kt_for(int n_threads, void (*func)(void*,int,int), void *data, int n);\n\tworker_t w;\n\tmem_pestat_t pes[4];\n\tdouble ctime, rtime;\n\tint i;\n\n\tctime = cputime(); rtime = realtime();\n\tglobal_bns = bns;\n\tw.regs = malloc(n * sizeof(mem_alnreg_v));\n\tw.opt = opt; w.bwt = bwt; w.bns = bns; w.pac = pac;\n\tw.seqs = seqs; w.n_processed = n_processed;\n\tw.pes = &pes[0];\n\tw.aux = malloc(opt->n_threads * sizeof(smem_aux_t));\n\tfor (i = 0; i < opt->n_threads; ++i)\n\t\tw.aux[i] = smem_aux_init();\n\tkt_for(opt->n_threads, worker1, &w, (opt->flag&MEM_F_PE)? n>>1 : n); // find mapping positions\n\tfor (i = 0; i < opt->n_threads; ++i)\n\t\tsmem_aux_destroy(w.aux[i]);\n\tfree(w.aux);\n\tif (opt->flag&MEM_F_PE) { // infer insert sizes if not provided\n\t\tif (pes0) memcpy(pes, pes0, 4 * sizeof(mem_pestat_t)); // if pes0 != NULL, set the insert-size distribution as pes0\n\t\telse mem_pestat(opt, bns->l_pac, n, w.regs, pes); // otherwise, infer the insert size distribution from data\n\t}\n\tkt_for(opt->n_threads, worker2, &w, (opt->flag&MEM_F_PE)? n>>1 : n); // generate alignment\n\tfree(w.regs);\n\tif (bwa_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] Processed %d reads in %.3f CPU sec, %.3f real sec\\n\", __func__, n, cputime() - ctime, realtime() - rtime);\n}\n"
        },
        {
          "name": "bwamem.h",
          "type": "blob",
          "size": 9.064453125,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#ifndef BWAMEM_H_\n#define BWAMEM_H_\n\n#include \"bwt.h\"\n#include \"bntseq.h\"\n#include \"bwa.h\"\n\n#define MEM_MAPQ_COEF 30.0\n#define MEM_MAPQ_MAX  60\n\nstruct __smem_i;\ntypedef struct __smem_i smem_i;\n\n#define MEM_F_PE        0x2\n#define MEM_F_NOPAIRING 0x4\n#define MEM_F_ALL       0x8\n#define MEM_F_NO_MULTI  0x10\n#define MEM_F_NO_RESCUE 0x20\n#define MEM_F_REF_HDR\t0x100\n#define MEM_F_SOFTCLIP  0x200\n#define MEM_F_SMARTPE   0x400\n#define MEM_F_PRIMARY5  0x800\n#define MEM_F_KEEP_SUPP_MAPQ 0x1000\n#define MEM_F_XB        0x2000\n\ntypedef struct {\n\tint a, b;               // match score and mismatch penalty\n\tint o_del, e_del;\n\tint o_ins, e_ins;\n\tint pen_unpaired;       // phred-scaled penalty for unpaired reads\n\tint pen_clip5,pen_clip3;// clipping penalty. This score is not deducted from the DP score.\n\tint w;                  // band width\n\tint zdrop;              // Z-dropoff\n\n\tuint64_t max_mem_intv;\n\n\tint T;                  // output score threshold; only affecting output\n\tint flag;               // see MEM_F_* macros\n\tint min_seed_len;       // minimum seed length\n\tint min_chain_weight;\n\tint max_chain_extend;\n\tfloat split_factor;     // split into a seed if MEM is longer than min_seed_len*split_factor\n\tint split_width;        // split into a seed if its occurence is smaller than this value\n\tint max_occ;            // skip a seed if its occurence is larger than this value\n\tint max_chain_gap;      // do not chain seed if it is max_chain_gap-bp away from the closest seed\n\tint n_threads;          // number of threads\n\tint chunk_size;         // process chunk_size-bp sequences in a batch\n\tfloat mask_level;       // regard a hit as redundant if the overlap with another better hit is over mask_level times the min length of the two hits\n\tfloat drop_ratio;       // drop a chain if its seed coverage is below drop_ratio times the seed coverage of a better chain overlapping with the small chain\n\tfloat XA_drop_ratio;    // when counting hits for the XA tag, ignore alignments with score < XA_drop_ratio * max_score; only effective for the XA tag\n\tfloat mask_level_redun;\n\tfloat mapQ_coef_len;\n\tint mapQ_coef_fac;\n\tint max_ins;            // when estimating insert size distribution, skip pairs with insert longer than this value\n\tint max_matesw;         // perform maximally max_matesw rounds of mate-SW for each end\n\tint max_XA_hits, max_XA_hits_alt; // if there are max_hits or fewer, output them all\n\tint8_t mat[25];         // scoring matrix; mat[0] == 0 if unset\n} mem_opt_t;\n\ntypedef struct {\n\tint64_t rb, re; // [rb,re): reference sequence in the alignment\n\tint qb, qe;     // [qb,qe): query sequence in the alignment\n\tint rid;        // reference seq ID\n\tint score;      // best local SW score\n\tint truesc;     // actual score corresponding to the aligned region; possibly smaller than $score\n\tint sub;        // 2nd best SW score\n\tint alt_sc;\n\tint csub;       // SW score of a tandem hit\n\tint sub_n;      // approximate number of suboptimal hits\n\tint w;          // actual band width used in extension\n\tint seedcov;    // length of regions coverged by seeds\n\tint secondary;  // index of the parent hit shadowing the current hit; <0 if primary\n\tint secondary_all;\n\tint seedlen0;   // length of the starting seed\n\tint n_comp:30, is_alt:2; // number of sub-alignments chained together\n\tfloat frac_rep;\n\tuint64_t hash;\n} mem_alnreg_t;\n\ntypedef struct { size_t n, m; mem_alnreg_t *a; } mem_alnreg_v;\n\ntypedef struct {\n\tint low, high;   // lower and upper bounds within which a read pair is considered to be properly paired\n\tint failed;      // non-zero if the orientation is not supported by sufficient data\n\tdouble avg, std; // mean and stddev of the insert size distribution\n} mem_pestat_t;\n\ntypedef struct { // This struct is only used for the convenience of API.\n\tint64_t pos;     // forward strand 5'-end mapping position\n\tint rid;         // reference sequence index in bntseq_t; <0 for unmapped\n\tint flag;        // extra flag\n\tuint32_t is_rev:1, is_alt:1, mapq:8, NM:22; // is_rev: whether on the reverse strand; mapq: mapping quality; NM: edit distance\n\tint n_cigar;     // number of CIGAR operations\n\tuint32_t *cigar; // CIGAR in the BAM encoding: opLen<<4|op; op to integer mapping: MIDSH=>01234\n\tchar *XA;        // alternative mappings\n\n\tint score, sub, alt_sc;\n} mem_aln_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tsmem_i *smem_itr_init(const bwt_t *bwt);\n\tvoid smem_itr_destroy(smem_i *itr);\n\tvoid smem_set_query(smem_i *itr, int len, const uint8_t *query);\n\tvoid smem_config(smem_i *itr, int min_intv, int max_len, uint64_t max_intv);\n\tconst bwtintv_v *smem_next(smem_i *itr);\n\n\tmem_opt_t *mem_opt_init(void);\n\tvoid mem_fill_scmat(int a, int b, int8_t mat[25]);\n\n\t/**\n\t * Align a batch of sequences and generate the alignments in the SAM format\n\t *\n\t * This routine requires $seqs[i].{l_seq,seq,name} and write $seqs[i].sam.\n\t * Note that $seqs[i].sam may consist of several SAM lines if the\n\t * corresponding sequence has multiple primary hits.\n\t *\n\t * In the paired-end mode (i.e. MEM_F_PE is set in $opt->flag), query\n\t * sequences must be interleaved: $n must be an even number and the 2i-th\n\t * sequence and the (2i+1)-th sequence constitute a read pair. In this\n\t * mode, there should be enough (typically >50) unique pairs for the\n\t * routine to infer the orientation and insert size.\n\t *\n\t * @param opt    alignment parameters\n\t * @param bwt    FM-index of the reference sequence\n\t * @param bns    Information of the reference\n\t * @param pac    2-bit encoded reference\n\t * @param n      number of query sequences\n\t * @param seqs   query sequences; $seqs[i].seq/sam to be modified after the call\n\t * @param pes0   insert-size info; if NULL, infer from data; if not NULL, it should be an array with 4 elements,\n\t *               corresponding to each FF, FR, RF and RR orientation. See mem_pestat() for more info.\n\t */\n\tvoid mem_process_seqs(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int64_t n_processed, int n, bseq1_t *seqs, const mem_pestat_t *pes0);\n\n\t/**\n\t * Find the aligned regions for one query sequence\n\t *\n\t * Note that this routine does not generate CIGAR. CIGAR should be\n\t * generated later by mem_reg2aln() below.\n\t *\n\t * @param opt    alignment parameters\n\t * @param bwt    FM-index of the reference sequence\n\t * @param bns    Information of the reference\n\t * @param pac    2-bit encoded reference\n\t * @param l_seq  length of query sequence\n\t * @param seq    query sequence\n\t *\n\t * @return       list of aligned regions.\n\t */\n\tmem_alnreg_v mem_align1(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, const char *seq);\n\n\t/**\n\t * Generate CIGAR and forward-strand position from alignment region\n\t *\n\t * @param opt    alignment parameters\n\t * @param bns    Information of the reference\n\t * @param pac    2-bit encoded reference\n\t * @param l_seq  length of query sequence\n\t * @param seq    query sequence\n\t * @param ar     one alignment region\n\t *\n\t * @return       CIGAR, strand, mapping quality and forward-strand position\n\t */\n\tmem_aln_t mem_reg2aln(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_seq, const char *seq, const mem_alnreg_t *ar);\n\tmem_aln_t mem_reg2aln2(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_seq, const char *seq, const mem_alnreg_t *ar, const char *name);\n\n\t/**\n\t * Infer the insert size distribution from interleaved alignment regions\n\t *\n\t * This function can be called after mem_align1(), as long as paired-end\n\t * reads are properly interleaved.\n\t *\n\t * @param opt    alignment parameters\n\t * @param l_pac  length of concatenated reference sequence\n\t * @param n      number of query sequences; must be an even number\n\t * @param regs   region array of size $n; 2i-th and (2i+1)-th elements constitute a pair\n\t * @param pes    inferred insert size distribution (output)\n\t */\n\tvoid mem_pestat(const mem_opt_t *opt, int64_t l_pac, int n, const mem_alnreg_v *regs, mem_pestat_t pes[4]);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwamem_extra.c",
          "type": "blob",
          "size": 5.673828125,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <limits.h>\n#include \"bwa.h\"\n#include \"bwamem.h\"\n#include \"bntseq.h\"\n#include \"kstring.h\"\n\n/***************************\n * SMEM iterator interface *\n ***************************/\n\nstruct __smem_i {\n\tconst bwt_t *bwt;\n\tconst uint8_t *query;\n\tint start, len;\n\tint min_intv, max_len;\n\tuint64_t max_intv;\n\tbwtintv_v *matches; // matches; to be returned by smem_next()\n\tbwtintv_v *sub;     // sub-matches inside the longest match; temporary\n\tbwtintv_v *tmpvec[2]; // temporary arrays\n};\n\nsmem_i *smem_itr_init(const bwt_t *bwt)\n{\n\tsmem_i *itr;\n\titr = calloc(1, sizeof(smem_i));\n\titr->bwt = bwt;\n\titr->tmpvec[0] = calloc(1, sizeof(bwtintv_v));\n\titr->tmpvec[1] = calloc(1, sizeof(bwtintv_v));\n\titr->matches   = calloc(1, sizeof(bwtintv_v));\n\titr->sub       = calloc(1, sizeof(bwtintv_v));\n\titr->min_intv = 1;\n\titr->max_len  = INT_MAX;\n\titr->max_intv = 0;\n\treturn itr;\n}\n\nvoid smem_itr_destroy(smem_i *itr)\n{\n\tfree(itr->tmpvec[0]->a); free(itr->tmpvec[0]);\n\tfree(itr->tmpvec[1]->a); free(itr->tmpvec[1]);\n\tfree(itr->matches->a);   free(itr->matches);\n\tfree(itr->sub->a);       free(itr->sub);\n\tfree(itr);\n}\n\nvoid smem_set_query(smem_i *itr, int len, const uint8_t *query)\n{\n\titr->query = query;\n\titr->start = 0;\n\titr->len = len;\n}\n\nvoid smem_config(smem_i *itr, int min_intv, int max_len, uint64_t max_intv)\n{\n\titr->min_intv = min_intv;\n\titr->max_len  = max_len;\n\titr->max_intv = max_intv;\n}\n\nconst bwtintv_v *smem_next(smem_i *itr)\n{\n\tint ori_start;\n\titr->tmpvec[0]->n = itr->tmpvec[1]->n = itr->matches->n = itr->sub->n = 0;\n\tif (itr->start >= itr->len || itr->start < 0) return 0;\n\twhile (itr->start < itr->len && itr->query[itr->start] > 3) ++itr->start; // skip ambiguous bases\n\tif (itr->start == itr->len) return 0;\n\tori_start = itr->start;\n\titr->start = bwt_smem1a(itr->bwt, itr->len, itr->query, ori_start, itr->min_intv, itr->max_intv, itr->matches, itr->tmpvec); // search for SMEM\n\treturn itr->matches;\n}\n\n/***********************\n *** Extra functions ***\n ***********************/\n\nmem_alnreg_v mem_align1(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, const char *seq_)\n{ // the difference from mem_align1_core() is that this routine: 1) calls mem_mark_primary_se(); 2) does not modify the input sequence\n\textern mem_alnreg_v mem_align1_core(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, char *seq, void *buf);\n\textern void mem_mark_primary_se(const mem_opt_t *opt, int n, mem_alnreg_t *a, int64_t id);\n\tmem_alnreg_v ar;\n\tchar *seq;\n\tseq = malloc(l_seq);\n\tmemcpy(seq, seq_, l_seq); // makes a copy of seq_\n\tar = mem_align1_core(opt, bwt, bns, pac, l_seq, seq, 0);\n\tmem_mark_primary_se(opt, ar.n, ar.a, lrand48());\n\tfree(seq);\n\treturn ar;\n}\n\nstatic inline int get_pri_idx(double XA_drop_ratio, const mem_alnreg_t *a, int i)\n{\n\tint k = a[i].secondary_all;\n\tif (k >= 0 && a[i].score >= a[k].score * XA_drop_ratio) return k;\n\treturn -1;\n}\n\n// Okay, returning strings is bad, but this has happened a lot elsewhere. If I have time, I need serious code cleanup.\nchar **mem_gen_alt(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_alnreg_v *a, int l_query, const char *query) // ONLY work after mem_mark_primary_se()\n{\n\tint i, k, r, *cnt, tot;\n\tkstring_t *aln = 0, str = {0,0,0};\n\tchar **XA = 0, *has_alt;\n\n\tcnt = calloc(a->n, sizeof(int));\n\thas_alt = calloc(a->n, 1);\n\tfor (i = 0, tot = 0; i < a->n; ++i) {\n\t\tr = get_pri_idx(opt->XA_drop_ratio, a->a, i);\n\t\tif (r >= 0) {\n\t\t\t++cnt[r], ++tot;\n\t\t\tif (a->a[i].is_alt) has_alt[r] = 1;\n\t\t}\n\t}\n\tif (tot == 0) goto end_gen_alt;\n\taln = calloc(a->n, sizeof(kstring_t));\n\tfor (i = 0; i < a->n; ++i) {\n\t\tmem_aln_t t;\n\t\tif ((r = get_pri_idx(opt->XA_drop_ratio, a->a, i)) < 0) continue;\n\t\tif (cnt[r] > opt->max_XA_hits_alt || (!has_alt[r] && cnt[r] > opt->max_XA_hits)) continue;\n\t\tt = mem_reg2aln(opt, bns, pac, l_query, query, &a->a[i]);\n\t\tstr.l = 0;\n\t\tkputs(bns->anns[t.rid].name, &str);\n\t\tkputc(',', &str); kputc(\"+-\"[t.is_rev], &str); kputl(t.pos + 1, &str);\n\t\tkputc(',', &str);\n\t\tfor (k = 0; k < t.n_cigar; ++k) {\n\t\t\tkputw(t.cigar[k]>>4, &str);\n\t\t\tkputc(\"MIDSHN\"[t.cigar[k]&0xf], &str);\n\t\t}\n\t\tkputc(',', &str); kputw(t.NM, &str);\n\t\tif (opt->flag & MEM_F_XB) {\n\t\t\tkputc(',', &str);\n\t\t\tkputw(t.score, &str);\n\t\t\tkputc(',', &str);\n\t\t\tkputw(t.mapq, &str);\n\t\t}\n\t\tkputc(';', &str);\n\t\tfree(t.cigar);\n\t\tkputsn(str.s, str.l, &aln[r]);\n\t}\n\tXA = calloc(a->n, sizeof(char*));\n\tfor (k = 0; k < a->n; ++k)\n\t\tXA[k] = aln[k].s;\n\nend_gen_alt:\n\tfree(has_alt); free(cnt); free(aln); free(str.s);\n\treturn XA;\n}\n"
        },
        {
          "name": "bwamem_pair.c",
          "type": "blob",
          "size": 18.181640625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include \"kstring.h\"\n#include \"bwamem.h\"\n#include \"kvec.h\"\n#include \"utils.h\"\n#include \"ksw.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n\n#define MIN_RATIO     0.8\n#define MIN_DIR_CNT   10\n#define MIN_DIR_RATIO 0.05\n#define OUTLIER_BOUND 2.0\n#define MAPPING_BOUND 3.0\n#define MAX_STDDEV    4.0\n\nstatic inline int mem_infer_dir(int64_t l_pac, int64_t b1, int64_t b2, int64_t *dist)\n{\n\tint64_t p2;\n\tint r1 = (b1 >= l_pac), r2 = (b2 >= l_pac);\n\tp2 = r1 == r2? b2 : (l_pac<<1) - 1 - b2; // p2 is the coordinate of read 2 on the read 1 strand\n\t*dist = p2 > b1? p2 - b1 : b1 - p2;\n\treturn (r1 == r2? 0 : 1) ^ (p2 > b1? 0 : 3);\n}\n\nstatic int cal_sub(const mem_opt_t *opt, mem_alnreg_v *r)\n{\n\tint j;\n\tfor (j = 1; j < r->n; ++j) { // choose unique alignment\n\t\tint b_max = r->a[j].qb > r->a[0].qb? r->a[j].qb : r->a[0].qb;\n\t\tint e_min = r->a[j].qe < r->a[0].qe? r->a[j].qe : r->a[0].qe;\n\t\tif (e_min > b_max) { // have overlap\n\t\t\tint min_l = r->a[j].qe - r->a[j].qb < r->a[0].qe - r->a[0].qb? r->a[j].qe - r->a[j].qb : r->a[0].qe - r->a[0].qb;\n\t\t\tif (e_min - b_max >= min_l * opt->mask_level) break; // significant overlap\n\t\t}\n\t}\n\treturn j < r->n? r->a[j].score : opt->min_seed_len * opt->a;\n}\n\nvoid mem_pestat(const mem_opt_t *opt, int64_t l_pac, int n, const mem_alnreg_v *regs, mem_pestat_t pes[4])\n{\n\tint i, d, max;\n\tuint64_v isize[4];\n\tmemset(pes, 0, 4 * sizeof(mem_pestat_t));\n\tmemset(isize, 0, sizeof(kvec_t(int)) * 4);\n\tfor (i = 0; i < n>>1; ++i) {\n\t\tint dir;\n\t\tint64_t is;\n\t\tmem_alnreg_v *r[2];\n\t\tr[0] = (mem_alnreg_v*)&regs[i<<1|0];\n\t\tr[1] = (mem_alnreg_v*)&regs[i<<1|1];\n\t\tif (r[0]->n == 0 || r[1]->n == 0) continue;\n\t\tif (cal_sub(opt, r[0]) > MIN_RATIO * r[0]->a[0].score) continue;\n\t\tif (cal_sub(opt, r[1]) > MIN_RATIO * r[1]->a[0].score) continue;\n\t\tif (r[0]->a[0].rid != r[1]->a[0].rid) continue; // not on the same chr\n\t\tdir = mem_infer_dir(l_pac, r[0]->a[0].rb, r[1]->a[0].rb, &is);\n\t\tif (is && is <= opt->max_ins) kv_push(uint64_t, isize[dir], is);\n\t}\n\tif (bwa_verbose >= 3) fprintf(stderr, \"[M::%s] # candidate unique pairs for (FF, FR, RF, RR): (%ld, %ld, %ld, %ld)\\n\", __func__, isize[0].n, isize[1].n, isize[2].n, isize[3].n);\n\tfor (d = 0; d < 4; ++d) { // TODO: this block is nearly identical to the one in bwtsw2_pair.c. It would be better to merge these two.\n\t\tmem_pestat_t *r = &pes[d];\n\t\tuint64_v *q = &isize[d];\n\t\tint p25, p50, p75, x;\n\t\tif (q->n < MIN_DIR_CNT) {\n\t\t\tfprintf(stderr, \"[M::%s] skip orientation %c%c as there are not enough pairs\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\t\tr->failed = 1;\n\t\t\tfree(q->a);\n\t\t\tcontinue;\n\t\t} else fprintf(stderr, \"[M::%s] analyzing insert size distribution for orientation %c%c...\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\tks_introsort_64(q->n, q->a);\n\t\tp25 = q->a[(int)(.25 * q->n + .499)];\n\t\tp50 = q->a[(int)(.50 * q->n + .499)];\n\t\tp75 = q->a[(int)(.75 * q->n + .499)];\n\t\tr->low  = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\t\tif (r->low < 1) r->low = 1;\n\t\tr->high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\t\tfprintf(stderr, \"[M::%s] (25, 50, 75) percentile: (%d, %d, %d)\\n\", __func__, p25, p50, p75);\n\t\tfprintf(stderr, \"[M::%s] low and high boundaries for computing mean and std.dev: (%d, %d)\\n\", __func__, r->low, r->high);\n\t\tfor (i = x = 0, r->avg = 0; i < q->n; ++i)\n\t\t\tif (q->a[i] >= r->low && q->a[i] <= r->high)\n\t\t\t\tr->avg += q->a[i], ++x;\n\t\tr->avg /= x;\n\t\tfor (i = 0, r->std = 0; i < q->n; ++i)\n\t\t\tif (q->a[i] >= r->low && q->a[i] <= r->high)\n\t\t\t\tr->std += (q->a[i] - r->avg) * (q->a[i] - r->avg);\n\t\tr->std = sqrt(r->std / x);\n\t\tfprintf(stderr, \"[M::%s] mean and std.dev: (%.2f, %.2f)\\n\", __func__, r->avg, r->std);\n\t\tr->low  = (int)(p25 - MAPPING_BOUND * (p75 - p25) + .499);\n\t\tr->high = (int)(p75 + MAPPING_BOUND * (p75 - p25) + .499);\n\t\tif (r->low  > r->avg - MAX_STDDEV * r->std) r->low  = (int)(r->avg - MAX_STDDEV * r->std + .499);\n\t\tif (r->high < r->avg + MAX_STDDEV * r->std) r->high = (int)(r->avg + MAX_STDDEV * r->std + .499);\n\t\tif (r->low < 1) r->low = 1;\n\t\tfprintf(stderr, \"[M::%s] low and high boundaries for proper pairs: (%d, %d)\\n\", __func__, r->low, r->high);\n\t\tfree(q->a);\n\t}\n\tfor (d = 0, max = 0; d < 4; ++d)\n\t\tmax = max > isize[d].n? max : isize[d].n;\n\tfor (d = 0; d < 4; ++d)\n\t\tif (pes[d].failed == 0 && isize[d].n < max * MIN_DIR_RATIO) {\n\t\t\tpes[d].failed = 1;\n\t\t\tfprintf(stderr, \"[M::%s] skip orientation %c%c\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\t}\n}\n\nint mem_matesw(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_pestat_t pes[4], const mem_alnreg_t *a, int l_ms, const uint8_t *ms, mem_alnreg_v *ma)\n{\n\textern int mem_sort_dedup_patch(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, uint8_t *query, int n, mem_alnreg_t *a);\n\tint64_t l_pac = bns->l_pac;\n\tint i, r, skip[4], n = 0, rid;\n\tfor (r = 0; r < 4; ++r)\n\t\tskip[r] = pes[r].failed? 1 : 0;\n\tfor (i = 0; i < ma->n; ++i) { // check which orinentation has been found\n\t\tint64_t dist;\n\t\tr = mem_infer_dir(l_pac, a->rb, ma->a[i].rb, &dist);\n\t\tif (dist >= pes[r].low && dist <= pes[r].high)\n\t\t\tskip[r] = 1;\n\t}\n\tif (skip[0] + skip[1] + skip[2] + skip[3] == 4) return 0; // consistent pair exist; no need to perform SW\n\tfor (r = 0; r < 4; ++r) {\n\t\tint is_rev, is_larger;\n\t\tuint8_t *seq, *rev = 0, *ref = 0;\n\t\tint64_t rb, re;\n\t\tif (skip[r]) continue;\n\t\tis_rev = (r>>1 != (r&1)); // whether to reverse complement the mate\n\t\tis_larger = !(r>>1); // whether the mate has larger coordinate\n\t\tif (is_rev) {\n\t\t\trev = malloc(l_ms); // this is the reverse complement of $ms\n\t\t\tfor (i = 0; i < l_ms; ++i) rev[l_ms - 1 - i] = ms[i] < 4? 3 - ms[i] : 4;\n\t\t\tseq = rev;\n\t\t} else seq = (uint8_t*)ms;\n\t\tif (!is_rev) {\n\t\t\trb = is_larger? a->rb + pes[r].low : a->rb - pes[r].high;\n\t\t\tre = (is_larger? a->rb + pes[r].high: a->rb - pes[r].low) + l_ms; // if on the same strand, end position should be larger to make room for the seq length\n\t\t} else {\n\t\t\trb = (is_larger? a->rb + pes[r].low : a->rb - pes[r].high) - l_ms; // similarly on opposite strands\n\t\t\tre = is_larger? a->rb + pes[r].high: a->rb - pes[r].low;\n\t\t}\n\t\tif (rb < 0) rb = 0;\n\t\tif (re > l_pac<<1) re = l_pac<<1;\n\t\tif (rb < re) ref = bns_fetch_seq(bns, pac, &rb, (rb+re)>>1, &re, &rid);\n\t\tif (a->rid == rid && re - rb >= opt->min_seed_len) { // no funny things happening\n\t\t\tkswr_t aln;\n\t\t\tmem_alnreg_t b;\n\t\t\tint tmp, xtra = KSW_XSUBO | KSW_XSTART | (l_ms * opt->a < 250? KSW_XBYTE : 0) | (opt->min_seed_len * opt->a);\n\t\t\taln = ksw_align2(l_ms, seq, re - rb, ref, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, xtra, 0);\n\t\t\tmemset(&b, 0, sizeof(mem_alnreg_t));\n\t\t\tif (aln.score >= opt->min_seed_len && aln.qb >= 0) { // something goes wrong if aln.qb < 0\n\t\t\t\tb.rid = a->rid;\n\t\t\t\tb.is_alt = a->is_alt;\n\t\t\t\tb.qb = is_rev? l_ms - (aln.qe + 1) : aln.qb;                                                                                                                                                                              \n\t\t\t\tb.qe = is_rev? l_ms - aln.qb : aln.qe + 1; \n\t\t\t\tb.rb = is_rev? (l_pac<<1) - (rb + aln.te + 1) : rb + aln.tb;\n\t\t\t\tb.re = is_rev? (l_pac<<1) - (rb + aln.tb) : rb + aln.te + 1;\n\t\t\t\tb.score = aln.score;\n\t\t\t\tb.csub = aln.score2;\n\t\t\t\tb.secondary = -1;\n\t\t\t\tb.seedcov = (b.re - b.rb < b.qe - b.qb? b.re - b.rb : b.qe - b.qb) >> 1;\n//\t\t\t\tprintf(\"*** %d, [%lld,%lld], %d:%d, (%lld,%lld), (%lld,%lld) == (%lld,%lld)\\n\", aln.score, rb, re, is_rev, is_larger, a->rb, a->re, ma->a[0].rb, ma->a[0].re, b.rb, b.re);\n\t\t\t\tkv_push(mem_alnreg_t, *ma, b); // make room for a new element\n\t\t\t\t// move b s.t. ma is sorted\n\t\t\t\tfor (i = 0; i < ma->n - 1; ++i) // find the insertion point\n\t\t\t\t\tif (ma->a[i].score < b.score) break;\n\t\t\t\ttmp = i;\n\t\t\t\tfor (i = ma->n - 1; i > tmp; --i) ma->a[i] = ma->a[i-1];\n\t\t\t\tma->a[i] = b;\n\t\t\t}\n\t\t\t++n;\n\t\t}\n\t\tif (n) ma->n = mem_sort_dedup_patch(opt, 0, 0, 0, ma->n, ma->a);\n\t\tif (rev) free(rev);\n\t\tfree(ref);\n\t}\n\treturn n;\n}\n\nint mem_pair(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_pestat_t pes[4], bseq1_t s[2], mem_alnreg_v a[2], int id, int *sub, int *n_sub, int z[2], int n_pri[2])\n{\n\tpair64_v v, u;\n\tint r, i, k, y[4], ret; // y[] keeps the last hit\n\tint64_t l_pac = bns->l_pac;\n\tkv_init(v); kv_init(u);\n\tfor (r = 0; r < 2; ++r) { // loop through read number\n\t\tfor (i = 0; i < n_pri[r]; ++i) {\n\t\t\tpair64_t key;\n\t\t\tmem_alnreg_t *e = &a[r].a[i];\n\t\t\tkey.x = e->rb < l_pac? e->rb : (l_pac<<1) - 1 - e->rb; // forward position\n\t\t\tkey.x = (uint64_t)e->rid<<32 | (key.x - bns->anns[e->rid].offset);\n\t\t\tkey.y = (uint64_t)e->score << 32 | i << 2 | (e->rb >= l_pac)<<1 | r;\n\t\t\tkv_push(pair64_t, v, key);\n\t\t}\n\t}\n\tks_introsort_128(v.n, v.a);\n\ty[0] = y[1] = y[2] = y[3] = -1;\n\t//for (i = 0; i < v.n; ++i) printf(\"[%d]\\t%d\\t%c%ld\\n\", i, (int)(v.a[i].y&1)+1, \"+-\"[v.a[i].y>>1&1], (long)v.a[i].x);\n\tfor (i = 0; i < v.n; ++i) {\n\t\tfor (r = 0; r < 2; ++r) { // loop through direction\n\t\t\tint dir = r<<1 | (v.a[i].y>>1&1), which;\n\t\t\tif (pes[dir].failed) continue; // invalid orientation\n\t\t\twhich = r<<1 | ((v.a[i].y&1)^1);\n\t\t\tif (y[which] < 0) continue; // no previous hits\n\t\t\tfor (k = y[which]; k >= 0; --k) { // TODO: this is a O(n^2) solution in the worst case; remember to check if this loop takes a lot of time (I doubt)\n\t\t\t\tint64_t dist;\n\t\t\t\tint q;\n\t\t\t\tdouble ns;\n\t\t\t\tpair64_t *p;\n\t\t\t\tif ((v.a[k].y&3) != which) continue;\n\t\t\t\tdist = (int64_t)v.a[i].x - v.a[k].x;\n\t\t\t\t//printf(\"%d: %lld\\n\", k, dist);\n\t\t\t\tif (dist > pes[dir].high) break;\n\t\t\t\tif (dist < pes[dir].low)  continue;\n\t\t\t\tns = (dist - pes[dir].avg) / pes[dir].std;\n\t\t\t\tq = (int)((v.a[i].y>>32) + (v.a[k].y>>32) + .721 * log(2. * erfc(fabs(ns) * M_SQRT1_2)) * opt->a + .499); // .721 = 1/log(4)\n\t\t\t\tif (q < 0) q = 0;\n\t\t\t\tp = kv_pushp(pair64_t, u);\n\t\t\t\tp->y = (uint64_t)k<<32 | i;\n\t\t\t\tp->x = (uint64_t)q<<32 | (hash_64(p->y ^ id<<8) & 0xffffffffU);\n\t\t\t\t//printf(\"[%lld,%lld]\\t%d\\tdist=%ld\\n\", v.a[k].x, v.a[i].x, q, (long)dist);\n\t\t\t}\n\t\t}\n\t\ty[v.a[i].y&3] = i;\n\t}\n\tif (u.n) { // found at least one proper pair\n\t\tint tmp = opt->a + opt->b;\n\t\ttmp = tmp > opt->o_del + opt->e_del? tmp : opt->o_del + opt->e_del;\n\t\ttmp = tmp > opt->o_ins + opt->e_ins? tmp : opt->o_ins + opt->e_ins;\n\t\tks_introsort_128(u.n, u.a);\n\t\ti = u.a[u.n-1].y >> 32; k = u.a[u.n-1].y << 32 >> 32;\n\t\tz[v.a[i].y&1] = v.a[i].y<<32>>34; // index of the best pair\n\t\tz[v.a[k].y&1] = v.a[k].y<<32>>34;\n\t\tret = u.a[u.n-1].x >> 32;\n\t\t*sub = u.n > 1? u.a[u.n-2].x>>32 : 0;\n\t\tfor (i = (long)u.n - 2, *n_sub = 0; i >= 0; --i)\n\t\t\tif (*sub - (int)(u.a[i].x>>32) <= tmp) ++*n_sub;\n\t} else ret = 0, *sub = 0, *n_sub = 0;\n\tfree(u.a); free(v.a);\n\treturn ret;\n}\n\nvoid mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq1_t *s, int n, const mem_aln_t *list, int which, const mem_aln_t *m);\nvoid mem_reorder_primary5(int T, mem_alnreg_v *a);\n\n#define raw_mapq(diff, a) ((int)(6.02 * (diff) / (a) + .499))\n\nint mem_sam_pe(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_pestat_t pes[4], uint64_t id, bseq1_t s[2], mem_alnreg_v a[2])\n{\n\textern int mem_mark_primary_se(const mem_opt_t *opt, int n, mem_alnreg_t *a, int64_t id);\n\textern int mem_approx_mapq_se(const mem_opt_t *opt, const mem_alnreg_t *a);\n\textern void mem_reg2sam(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, bseq1_t *s, mem_alnreg_v *a, int extra_flag, const mem_aln_t *m);\n\textern char **mem_gen_alt(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_alnreg_v *a, int l_query, const char *query);\n\n\tint n = 0, i, j, z[2], o, subo, n_sub, extra_flag = 1, n_pri[2], n_aa[2];\n\tkstring_t str;\n\tmem_aln_t h[2], g[2], aa[2][2];\n\n\tstr.l = str.m = 0; str.s = 0;\n\tmemset(h, 0, sizeof(mem_aln_t) * 2);\n\tmemset(g, 0, sizeof(mem_aln_t) * 2);\n\tn_aa[0] = n_aa[1] = 0;\n\tif (!(opt->flag & MEM_F_NO_RESCUE)) { // then perform SW for the best alignment\n\t\tmem_alnreg_v b[2];\n\t\tkv_init(b[0]); kv_init(b[1]);\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\tfor (j = 0; j < a[i].n; ++j)\n\t\t\t\tif (a[i].a[j].score >= a[i].a[0].score  - opt->pen_unpaired)\n\t\t\t\t\tkv_push(mem_alnreg_t, b[i], a[i].a[j]);\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\tfor (j = 0; j < b[i].n && j < opt->max_matesw; ++j)\n\t\t\t\tn += mem_matesw(opt, bns, pac, pes, &b[i].a[j], s[!i].l_seq, (uint8_t*)s[!i].seq, &a[!i]);\n\t\tfree(b[0].a); free(b[1].a);\n\t}\n\tn_pri[0] = mem_mark_primary_se(opt, a[0].n, a[0].a, id<<1|0);\n\tn_pri[1] = mem_mark_primary_se(opt, a[1].n, a[1].a, id<<1|1);\n\tif (opt->flag & MEM_F_PRIMARY5) {\n\t\tmem_reorder_primary5(opt->T, &a[0]);\n\t\tmem_reorder_primary5(opt->T, &a[1]);\n\t}\n\tif (opt->flag&MEM_F_NOPAIRING) goto no_pairing;\n\t// pairing single-end hits\n\tif (n_pri[0] && n_pri[1] && (o = mem_pair(opt, bns, pac, pes, s, a, id, &subo, &n_sub, z, n_pri)) > 0) {\n\t\tint is_multi[2], q_pe, score_un, q_se[2];\n\t\tchar **XA[2];\n\t\t// check if an end has multiple hits even after mate-SW\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\tfor (j = 1; j < n_pri[i]; ++j)\n\t\t\t\tif (a[i].a[j].secondary < 0 && a[i].a[j].score >= opt->T) break;\n\t\t\tis_multi[i] = j < n_pri[i]? 1 : 0;\n\t\t}\n\t\tif (is_multi[0] || is_multi[1]) goto no_pairing; // TODO: in rare cases, the true hit may be long but with low score\n\t\t// compute mapQ for the best SE hit\n\t\tscore_un = a[0].a[0].score + a[1].a[0].score - opt->pen_unpaired;\n\t\t//q_pe = o && subo < o? (int)(MEM_MAPQ_COEF * (1. - (double)subo / o) * log(a[0].a[z[0]].seedcov + a[1].a[z[1]].seedcov) + .499) : 0;\n\t\tsubo = subo > score_un? subo : score_un;\n\t\tq_pe = raw_mapq(o - subo, opt->a);\n\t\tif (n_sub > 0) q_pe -= (int)(4.343 * log(n_sub+1) + .499);\n\t\tif (q_pe < 0) q_pe = 0;\n\t\tif (q_pe > 60) q_pe = 60;\n\t\tq_pe = (int)(q_pe * (1. - .5 * (a[0].a[0].frac_rep + a[1].a[0].frac_rep)) + .499);\n\t\t// the following assumes no split hits\n\t\tif (o > score_un) { // paired alignment is preferred\n\t\t\tmem_alnreg_t *c[2];\n\t\t\tc[0] = &a[0].a[z[0]]; c[1] = &a[1].a[z[1]];\n\t\t\tfor (i = 0; i < 2; ++i) {\n\t\t\t\tif (c[i]->secondary >= 0)\n\t\t\t\t\tc[i]->sub = a[i].a[c[i]->secondary].score, c[i]->secondary = -2;\n\t\t\t\tq_se[i] = mem_approx_mapq_se(opt, c[i]);\n\t\t\t}\n\t\t\tq_se[0] = q_se[0] > q_pe? q_se[0] : q_pe < q_se[0] + 40? q_pe : q_se[0] + 40;\n\t\t\tq_se[1] = q_se[1] > q_pe? q_se[1] : q_pe < q_se[1] + 40? q_pe : q_se[1] + 40;\n\t\t\textra_flag |= 2;\n\t\t\t// cap at the tandem repeat score\n\t\t\tq_se[0] = q_se[0] < raw_mapq(c[0]->score - c[0]->csub, opt->a)? q_se[0] : raw_mapq(c[0]->score - c[0]->csub, opt->a);\n\t\t\tq_se[1] = q_se[1] < raw_mapq(c[1]->score - c[1]->csub, opt->a)? q_se[1] : raw_mapq(c[1]->score - c[1]->csub, opt->a);\n\t\t} else { // the unpaired alignment is preferred\n\t\t\tz[0] = z[1] = 0;\n\t\t\tq_se[0] = mem_approx_mapq_se(opt, &a[0].a[0]);\n\t\t\tq_se[1] = mem_approx_mapq_se(opt, &a[1].a[0]);\n\t\t}\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\tint k = a[i].a[z[i]].secondary_all;\n\t\t\tif (k >= 0 && k < n_pri[i]) { // switch secondary and primary if both of them are non-ALT\n\t\t\t\tassert(a[i].a[k].secondary_all < 0);\n\t\t\t\tfor (j = 0; j < a[i].n; ++j)\n\t\t\t\t\tif (a[i].a[j].secondary_all == k || j == k)\n\t\t\t\t\t\ta[i].a[j].secondary_all = z[i];\n\t\t\t\ta[i].a[z[i]].secondary_all = -1;\n\t\t\t}\n\t\t}\n\t\tif (!(opt->flag & MEM_F_ALL)) {\n\t\t\tfor (i = 0; i < 2; ++i)\n\t\t\t\tXA[i] = mem_gen_alt(opt, bns, pac, &a[i], s[i].l_seq, s[i].seq);\n\t\t} else XA[0] = XA[1] = 0;\n\t\t// write SAM\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\th[i] = mem_reg2aln(opt, bns, pac, s[i].l_seq, s[i].seq, &a[i].a[z[i]]);\n\t\t\th[i].mapq = q_se[i];\n\t\t\th[i].flag |= 0x40<<i | extra_flag;\n\t\t\th[i].XA = XA[i]? XA[i][z[i]] : 0;\n\t\t\taa[i][n_aa[i]++] = h[i];\n\t\t\tif (n_pri[i] < a[i].n) { // the read has ALT hits\n\t\t\t\tmem_alnreg_t *p = &a[i].a[n_pri[i]];\n\t\t\t\tif (p->score < opt->T || p->secondary >= 0 || !p->is_alt) continue;\n\t\t\t\tg[i] = mem_reg2aln(opt, bns, pac, s[i].l_seq, s[i].seq, p);\n\t\t\t\tg[i].flag |= 0x800 | 0x40<<i | extra_flag;\n\t\t\t\tg[i].XA = XA[i]? XA[i][n_pri[i]] : 0;\n\t\t\t\taa[i][n_aa[i]++] = g[i];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n_aa[0]; ++i)\n\t\t\tmem_aln2sam(opt, bns, &str, &s[0], n_aa[0], aa[0], i, &h[1]); // write read1 hits\n\t\ts[0].sam = strdup(str.s); str.l = 0;\n\t\tfor (i = 0; i < n_aa[1]; ++i)\n\t\t\tmem_aln2sam(opt, bns, &str, &s[1], n_aa[1], aa[1], i, &h[0]); // write read2 hits\n\t\ts[1].sam = str.s;\n\t\tif (strcmp(s[0].name, s[1].name) != 0) err_fatal(__func__, \"paired reads have different names: \\\"%s\\\", \\\"%s\\\"\\n\", s[0].name, s[1].name);\n\t\t// free\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\tfree(h[i].cigar); free(g[i].cigar);\n\t\t\tif (XA[i] == 0) continue;\n\t\t\tfor (j = 0; j < a[i].n; ++j) free(XA[i][j]);\n\t\t\tfree(XA[i]);\n\t\t}\n\t} else goto no_pairing;\n\treturn n;\n\nno_pairing:\n\tfor (i = 0; i < 2; ++i) {\n\t\tint which = -1;\n\t\tif (a[i].n) {\n\t\t\tif (a[i].a[0].score >= opt->T) which = 0;\n\t\t\telse if (n_pri[i] < a[i].n && a[i].a[n_pri[i]].score >= opt->T)\n\t\t\t\twhich = n_pri[i];\n\t\t}\n\t\tif (which >= 0) h[i] = mem_reg2aln(opt, bns, pac, s[i].l_seq, s[i].seq, &a[i].a[which]);\n\t\telse h[i] = mem_reg2aln(opt, bns, pac, s[i].l_seq, s[i].seq, 0);\n\t}\n\tif (!(opt->flag & MEM_F_NOPAIRING) && h[0].rid == h[1].rid && h[0].rid >= 0) { // if the top hits from the two ends constitute a proper pair, flag it.\n\t\tint64_t dist;\n\t\tint d;\n\t\td = mem_infer_dir(bns->l_pac, a[0].a[0].rb, a[1].a[0].rb, &dist);\n\t\tif (!pes[d].failed && dist >= pes[d].low && dist <= pes[d].high) extra_flag |= 2;\n\t}\n\tmem_reg2sam(opt, bns, pac, &s[0], &a[0], 0x41|extra_flag, &h[1]);\n\tmem_reg2sam(opt, bns, pac, &s[1], &a[1], 0x81|extra_flag, &h[0]);\n\tif (strcmp(s[0].name, s[1].name) != 0) err_fatal(__func__, \"paired reads have different names: \\\"%s\\\", \\\"%s\\\"\\n\", s[0].name, s[1].name);\n\tfree(h[0].cigar); free(h[1].cigar);\n\treturn n;\n}\n"
        },
        {
          "name": "bwape.c",
          "type": "blob",
          "size": 28.70703125,
          "content": "#include <unistd.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include \"bwtaln.h\"\n#include \"kvec.h\"\n#include \"bntseq.h\"\n#include \"utils.h\"\n#include \"bwase.h\"\n#include \"bwa.h\"\n#include \"ksw.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef struct {\n\tint n;\n\tbwtint_t *a;\n} poslist_t;\n\ntypedef struct {\n\tdouble avg, std, ap_prior;\n\tbwtint_t low, high, high_bayesian;\n} isize_info_t;\n\n#define b128_eq(a, b) ((a).x == (b).x && (a).y == (b).y)\n#define b128_hash(a) ((uint32_t)(a).x)\n\n#include \"khash.h\"\nKHASH_INIT(b128, pair64_t, poslist_t, 1, b128_hash, b128_eq)\n\ntypedef struct {\n\tpair64_v arr;\n\tpair64_v pos[2];\n\tkvec_t(bwt_aln1_t) aln[2];\n} pe_data_t;\n\n#define MIN_HASH_WIDTH 1000\n\nextern int g_log_n[256]; // in bwase.c\nstatic kh_b128_t *g_hash;\n\nvoid bwa_aln2seq_core(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s, int set_main, int n_multi);\nvoid bwa_aln2seq(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s);\nint bwa_approx_mapQ(const bwa_seq_t *p, int mm);\nvoid bwa_print_sam1(const bntseq_t *bns, bwa_seq_t *p, const bwa_seq_t *mate, int mode, int max_top2);\nbntseq_t *bwa_open_nt(const char *prefix);\nvoid bwa_print_sam_SQ(const bntseq_t *bns);\n\npe_opt_t *bwa_init_pe_opt()\n{\n\tpe_opt_t *po;\n\tpo = (pe_opt_t*)calloc(1, sizeof(pe_opt_t));\n\tpo->max_isize = 500;\n\tpo->force_isize = 0;\n\tpo->max_occ = 100000;\n\tpo->n_multi = 3;\n\tpo->N_multi = 10;\n\tpo->type = BWA_PET_STD;\n\tpo->is_sw = 1;\n\tpo->ap_prior = 1e-5;\n\treturn po;\n}\n/*\nstatic double ierfc(double x) // inverse erfc(); iphi(x) = M_SQRT2 *ierfc(2 * x);\n{\n\tconst double a = 0.140012;\n\tdouble b, c;\n\tb = log(x * (2 - x));\n\tc = 2./M_PI/a + b / 2.;\n\treturn sqrt(sqrt(c * c - b / a) - c);\n}\n*/\n\n// for normal distribution, this is about 3std\n#define OUTLIER_BOUND 2.0\n\nstatic int infer_isize(int n_seqs, bwa_seq_t *seqs[2], isize_info_t *ii, double ap_prior, int64_t L)\n{\n\tuint64_t x, *isizes, n_ap = 0;\n\tint n, i, tot, p25, p75, p50, max_len = 1, tmp;\n\tdouble skewness = 0.0, kurtosis = 0.0, y;\n\n\tii->avg = ii->std = -1.0;\n\tii->low = ii->high = ii->high_bayesian = 0;\n\tisizes = (uint64_t*)calloc(n_seqs, 8);\n\tfor (i = 0, tot = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p[2];\n\t\tp[0] = seqs[0] + i; p[1] = seqs[1] + i;\n\t\tif (p[0]->mapQ >= 20 && p[1]->mapQ >= 20) {\n\t\t\tx = (p[0]->pos < p[1]->pos)? p[1]->pos + p[1]->len - p[0]->pos : p[0]->pos + p[0]->len - p[1]->pos;\n\t\t\tif (x < 100000) isizes[tot++] = x;\n\t\t}\n\t\tif (p[0]->len > max_len) max_len = p[0]->len;\n\t\tif (p[1]->len > max_len) max_len = p[1]->len;\n\t}\n\tif (tot < 20) {\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: too few good pairs\\n\");\n\t\tfree(isizes);\n\t\treturn -1;\n\t}\n\tks_introsort_64(tot, isizes);\n\tp25 = isizes[(int)(tot*0.25 + 0.5)];\n\tp50 = isizes[(int)(tot*0.50 + 0.5)];\n\tp75 = isizes[(int)(tot*0.75 + 0.5)];\n\ttmp  = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\tii->low = tmp > max_len? tmp : max_len; // ii->low is unsigned\n\tii->high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\tif (ii->low > ii->high) {\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: upper bound is smaller than read length\\n\");\n\t\tfree(isizes);\n\t\treturn -1;\n\t}\n\tfor (i = 0, x = n = 0; i < tot; ++i)\n\t\tif (isizes[i] >= ii->low && isizes[i] <= ii->high)\n\t\t\t++n, x += isizes[i];\n\tii->avg = (double)x / n;\n\tfor (i = 0; i < tot; ++i) {\n\t\tif (isizes[i] >= ii->low && isizes[i] <= ii->high) {\n\t\t\tdouble tmp = (isizes[i] - ii->avg) * (isizes[i] - ii->avg);\n\t\t\tii->std += tmp;\n\t\t\tskewness += tmp * (isizes[i] - ii->avg);\n\t\t\tkurtosis += tmp * tmp;\n\t\t}\n\t}\n\tkurtosis = kurtosis/n / (ii->std / n * ii->std / n) - 3;\n\tii->std = sqrt(ii->std / n); // it would be better as n-1, but n is usually very large\n\tskewness = skewness / n / (ii->std * ii->std * ii->std);\n\tfor (y = 1.0; y < 10.0; y += 0.01)\n\t\tif (.5 * erfc(y / M_SQRT2) < ap_prior / L * (y * ii->std + ii->avg)) break;\n\tii->high_bayesian = (bwtint_t)(y * ii->std + ii->avg + .499);\n\tfor (i = 0; i < tot; ++i)\n\t\tif (isizes[i] > ii->high_bayesian) ++n_ap;\n\tii->ap_prior = .01 * (n_ap + .01) / tot;\n\tif (ii->ap_prior < ap_prior) ii->ap_prior = ap_prior;\n\tfree(isizes);\n\tfprintf(stderr, \"[infer_isize] (25, 50, 75) percentile: (%d, %d, %d)\\n\", p25, p50, p75);\n\tif (isnan(ii->std) || p75 > 100000) {\n\t\tii->low = ii->high = ii->high_bayesian = 0; ii->avg = ii->std = -1.0;\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: weird pairing\\n\");\n\t\treturn -1;\n\t}\n\tfor (y = 1.0; y < 10.0; y += 0.01)\n\t\tif (.5 * erfc(y / M_SQRT2) < ap_prior / L * (y * ii->std + ii->avg)) break;\n\tii->high_bayesian = (bwtint_t)(y * ii->std + ii->avg + .499);\n\tfprintf(stderr, \"[infer_isize] low and high boundaries: %ld and %ld for estimating avg and std\\n\", (long)ii->low, (long)ii->high);\n\tfprintf(stderr, \"[infer_isize] inferred external isize from %d pairs: %.3lf +/- %.3lf\\n\", n, ii->avg, ii->std);\n\tfprintf(stderr, \"[infer_isize] skewness: %.3lf; kurtosis: %.3lf; ap_prior: %.2e\\n\", skewness, kurtosis, ii->ap_prior);\n\tfprintf(stderr, \"[infer_isize] inferred maximum insert size: %ld (%.2lf sigma)\\n\", (long)ii->high_bayesian, y);\n\treturn 0;\n}\n\nstatic int pairing(bwa_seq_t *p[2], pe_data_t *d, const pe_opt_t *opt, int s_mm, const isize_info_t *ii)\n{\n\tint i, j, o_n, subo_n, cnt_chg = 0, low_bound = ii->low, max_len;\n\tuint64_t o_score, subo_score;\n\tpair64_t last_pos[2][2], o_pos[2];\n\tmax_len = p[0]->full_len;\n\tif (max_len < p[1]->full_len) max_len = p[1]->full_len;\n\tif (low_bound < max_len) low_bound = max_len;\n\n\t// here v>=u. When ii is set, we check insert size with ii; otherwise with opt->max_isize\n#define __pairing_aux(u,v) do { \\\n\t\tbwtint_t l = (v).x + p[(v).y&1]->len - ((u).x); \\\n\t\tif ((u).x != (uint64_t)-1 && (v).x > (u).x && l >= max_len \\\n\t\t\t&& ((ii->high && l <= ii->high_bayesian) || (ii->high == 0 && l <= opt->max_isize))) \\\n\t\t{ \\\n\t\t\tuint64_t s = d->aln[(v).y&1].a[(v).y>>2].score + d->aln[(u).y&1].a[(u).y>>2].score; \\\n\t\t\ts *= 10; \\\n\t\t\tif (ii->high) s += (int)(-4.343 * log(.5 * erfc(M_SQRT1_2 * fabs(l - ii->avg) / ii->std)) + .499); \\\n\t\t\ts = s<<32 | (uint32_t)hash_64((u).x<<32 | (v).x); \\\n\t\t\tif (s>>32 == o_score>>32) ++o_n; \\\n\t\t\telse if (s>>32 < o_score>>32) { subo_n += o_n; o_n = 1; } \\\n\t\t\telse ++subo_n; \\\n\t\t\tif (s < o_score) subo_score = o_score, o_score = s, o_pos[(u).y&1] = (u), o_pos[(v).y&1] = (v); \\\n\t\t\telse if (s < subo_score) subo_score = s; \\\n\t\t} \\\n\t} while (0)\n\n#define __pairing_aux2(q, w) do { \\\n\t\tconst bwt_aln1_t *r = d->aln[(w).y&1].a + ((w).y>>2); \\\n\t\t(q)->extra_flag |= SAM_FPP; \\\n\t\tif ((q)->pos != (w).x || (q)->strand != ((w).y>>1&1)) { \\\n\t\t\t(q)->n_mm = r->n_mm; (q)->n_gapo = r->n_gapo; (q)->n_gape = r->n_gape; (q)->strand = (w).y>>1&1; \\\n\t\t\t(q)->score = r->score; \\\n\t\t\t(q)->pos = (w).x; \\\n\t\t\tif ((q)->mapQ > 0) ++cnt_chg; \\\n\t\t} \\\n\t} while (0)\n\n\to_score = subo_score = (uint64_t)-1;\n\to_n = subo_n = 0;\n\tks_introsort_128(d->arr.n, d->arr.a);\n\tfor (j = 0; j < 2; ++j) last_pos[j][0].x = last_pos[j][0].y = last_pos[j][1].x = last_pos[j][1].y = (uint64_t)-1;\n\tif (opt->type == BWA_PET_STD) {\n\t\tfor (i = 0; i < d->arr.n; ++i) {\n\t\t\tpair64_t x = d->arr.a[i];\n\t\t\tint strand = x.y>>1&1;\n\t\t\tif (strand == 1) { // reverse strand, then check\n\t\t\t\tint y = 1 - (x.y&1);\n\t\t\t\t__pairing_aux(last_pos[y][1], x);\n\t\t\t\t__pairing_aux(last_pos[y][0], x);\n\t\t\t} else { // forward strand, then push\n\t\t\t\tlast_pos[x.y&1][0] = last_pos[x.y&1][1];\n\t\t\t\tlast_pos[x.y&1][1] = x;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"[paring] not implemented yet!\\n\");\n\t\texit(1);\n\t}\n\t// set pairing\n\t//fprintf(stderr, \"[%ld, %d, %d, %d]\\n\", d->arr.n, (int)(o_score>>32), (int)(subo_score>>32), o_n);\n\tif (o_score != (uint64_t)-1) {\n\t\tint mapQ_p = 0; // this is the maximum mapping quality when one end is moved\n\t\t//fprintf(stderr, \"%d, %d\\n\", o_n, subo_n);\n\t\tif (o_n == 1) {\n\t\t\tif (subo_score == (uint64_t)-1) mapQ_p = 29; // no sub-optimal pair\n\t\t\telse if ((subo_score>>32) - (o_score>>32) > s_mm * 10) mapQ_p = 23; // poor sub-optimal pair\n\t\t\telse {\n\t\t\t\tint n = subo_n > 255? 255 : subo_n;\n\t\t\t\tmapQ_p = ((subo_score>>32) - (o_score>>32)) / 2 - g_log_n[n];\n\t\t\t\tif (mapQ_p < 0) mapQ_p = 0;\n\t\t\t}\n\t\t}\n\t\tif ((p[0]->pos == o_pos[0].x && p[0]->strand == (o_pos[0].y>>1&1)) && (p[1]->pos == o_pos[1].x && p[1]->strand == (o_pos[1].y>>1&1))) { // both ends not moved\n\t\t\tif (p[0]->mapQ > 0 && p[1]->mapQ > 0) {\n\t\t\t\tint mapQ = p[0]->mapQ + p[1]->mapQ;\n\t\t\t\tif (mapQ > 60) mapQ = 60;\n\t\t\t\tp[0]->mapQ = p[1]->mapQ = mapQ;\n\t\t\t} else {\n\t\t\t\tif (p[0]->mapQ == 0) p[0]->mapQ = (mapQ_p + 7 < p[1]->mapQ)? mapQ_p + 7 : p[1]->mapQ;\n\t\t\t\tif (p[1]->mapQ == 0) p[1]->mapQ = (mapQ_p + 7 < p[0]->mapQ)? mapQ_p + 7 : p[0]->mapQ;\n\t\t\t}\n\t\t} else if (p[0]->pos == o_pos[0].x && p[0]->strand == (o_pos[0].y>>1&1)) { // [1] moved\n\t\t\tp[1]->seQ = 0; p[1]->mapQ = p[0]->mapQ;\n\t\t\tif (p[1]->mapQ > mapQ_p) p[1]->mapQ = mapQ_p;\n\t\t} else if (p[1]->pos == o_pos[1].x && p[1]->strand == (o_pos[1].y>>1&1)) { // [0] moved\n\t\t\tp[0]->seQ = 0; p[0]->mapQ = p[1]->mapQ;\n\t\t\tif (p[0]->mapQ > mapQ_p) p[0]->mapQ = mapQ_p;\n\t\t} else { // both ends moved\n\t\t\tp[0]->seQ = p[1]->seQ = 0;\n\t\t\tmapQ_p -= 20;\n\t\t\tif (mapQ_p < 0) mapQ_p = 0;\n\t\t\tp[0]->mapQ = p[1]->mapQ = mapQ_p;\n\t\t}\n\t\t__pairing_aux2(p[0], o_pos[0]);\n\t\t__pairing_aux2(p[1], o_pos[1]);\n\t}\n\treturn cnt_chg;\n}\n\ntypedef struct {\n\tkvec_t(bwt_aln1_t) aln;\n} aln_buf_t;\n\nint bwa_cal_pac_pos_pe(const bntseq_t *bns, const char *prefix, bwt_t *const _bwt, int n_seqs, bwa_seq_t *seqs[2], FILE *fp_sa[2], isize_info_t *ii,\n\t\t\t\t\t   const pe_opt_t *opt, const gap_opt_t *gopt, const isize_info_t *last_ii)\n{\n\tint i, j, cnt_chg = 0;\n\tchar str[1024];\n\tbwt_t *bwt;\n\tpe_data_t *d;\n\taln_buf_t *buf[2];\n\n\td = (pe_data_t*)calloc(1, sizeof(pe_data_t));\n\tbuf[0] = (aln_buf_t*)calloc(n_seqs, sizeof(aln_buf_t));\n\tbuf[1] = (aln_buf_t*)calloc(n_seqs, sizeof(aln_buf_t));\n\n\tif (_bwt == 0) { // load forward SA\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");  bwt = bwt_restore_bwt(str);\n\t\tstrcpy(str, prefix); strcat(str, \".sa\"); bwt_restore_sa(str, bwt);\n\t} else bwt = _bwt;\n\n\t// SE\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p[2];\n\t\tfor (j = 0; j < 2; ++j) {\n\t\t\tint n_aln;\n\t\t\tp[j] = seqs[j] + i;\n\t\t\tp[j]->n_multi = 0;\n\t\t\tp[j]->extra_flag |= SAM_FPD | (j == 0? SAM_FR1 : SAM_FR2);\n\t\t\terr_fread_noeof(&n_aln, 4, 1, fp_sa[j]);\n\t\t\tif (n_aln > kv_max(d->aln[j]))\n\t\t\t\tkv_resize(bwt_aln1_t, d->aln[j], n_aln);\n\t\t\td->aln[j].n = n_aln;\n\t\t\terr_fread_noeof(d->aln[j].a, sizeof(bwt_aln1_t), n_aln, fp_sa[j]);\n\t\t\tkv_copy(bwt_aln1_t, buf[j][i].aln, d->aln[j]); // backup d->aln[j]\n\t\t\t// generate SE alignment and mapping quality\n\t\t\tbwa_aln2seq(n_aln, d->aln[j].a, p[j]);\n\t\t\tif (p[j]->type == BWA_TYPE_UNIQUE || p[j]->type == BWA_TYPE_REPEAT) {\n\t\t\t\tint strand;\n\t\t\t\tint max_diff = gopt->fnr > 0.0? bwa_cal_maxdiff(p[j]->len, BWA_AVG_ERR, gopt->fnr) : gopt->max_diff;\n\t\t\t\tp[j]->seQ = p[j]->mapQ = bwa_approx_mapQ(p[j], max_diff);\n\t\t\t\tp[j]->pos = bwa_sa2pos(bns, bwt, p[j]->sa, p[j]->len + p[j]->ref_shift, &strand);\n\t\t\t\tp[j]->strand = strand;\n\t\t\t\tif (p[j]->pos == (bwtint_t)-1) p[j]->type = BWA_TYPE_NO_MATCH;\n\t\t\t}\n\t\t}\n\t}\n\n\t// infer isize\n\tinfer_isize(n_seqs, seqs, ii, opt->ap_prior, bwt->seq_len/2);\n\tif (ii->avg < 0.0 && last_ii->avg > 0.0) *ii = *last_ii;\n\tif (opt->force_isize) {\n\t\tfprintf(stderr, \"[%s] discard insert size estimate as user's request.\\n\", __func__);\n\t\tii->low = ii->high = 0; ii->avg = ii->std = -1.0;\n\t}\n\n\t// PE\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p[2];\n\t\tfor (j = 0; j < 2; ++j) {\n\t\t\tp[j] = seqs[j] + i;\n\t\t\tkv_copy(bwt_aln1_t, d->aln[j], buf[j][i].aln);\n\t\t}\n\t\tif ((p[0]->type == BWA_TYPE_UNIQUE || p[0]->type == BWA_TYPE_REPEAT)\n\t\t\t&& (p[1]->type == BWA_TYPE_UNIQUE || p[1]->type == BWA_TYPE_REPEAT))\n\t\t{ // only when both ends mapped\n\t\t\tpair64_t x;\n\t\t\tint j, k;\n\t\t\tlong long n_occ[2];\n\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\tn_occ[j] = 0;\n\t\t\t\tfor (k = 0; k < d->aln[j].n; ++k)\n\t\t\t\t\tn_occ[j] += d->aln[j].a[k].l - d->aln[j].a[k].k + 1;\n\t\t\t}\n\t\t\tif (n_occ[0] > opt->max_occ || n_occ[1] > opt->max_occ) continue;\n\t\t\td->arr.n = 0;\n\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\tfor (k = 0; k < d->aln[j].n; ++k) {\n\t\t\t\t\tbwt_aln1_t *r = d->aln[j].a + k;\n\t\t\t\t\tbwtint_t l;\n\t\t\t\t\tif (0 && r->l - r->k + 1 >= MIN_HASH_WIDTH) { // then check hash table\n\t\t\t\t\t\tpair64_t key;\n\t\t\t\t\t\tint ret;\n\t\t\t\t\t\tkey.x = r->k; key.y = r->l;\n\t\t\t\t\t\tkhint_t iter = kh_put(b128, g_hash, key, &ret);\n\t\t\t\t\t\tif (ret) { // not in the hash table; ret must equal 1 as we never remove elements\n\t\t\t\t\t\t\tposlist_t *z = &kh_val(g_hash, iter);\n\t\t\t\t\t\t\tz->n = r->l - r->k + 1;\n\t\t\t\t\t\t\tz->a = (bwtint_t*)malloc(sizeof(bwtint_t) * z->n);\n\t\t\t\t\t\t\tfor (l = r->k; l <= r->l; ++l) {\n\t\t\t\t\t\t\t\tint strand;\n\t\t\t\t\t\t\t\tz->a[l - r->k] = bwa_sa2pos(bns, bwt, l, p[j]->len + p[j]->ref_shift, &strand)<<1;\n\t\t\t\t\t\t\t\tz->a[l - r->k] |= strand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (l = 0; l < kh_val(g_hash, iter).n; ++l) {\n\t\t\t\t\t\t\tx.x = kh_val(g_hash, iter).a[l]>>1;\n\t\t\t\t\t\t\tx.y = k<<2 | (kh_val(g_hash, iter).a[l]&1)<<1 | j;\n\t\t\t\t\t\t\tkv_push(pair64_t, d->arr, x);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // then calculate on the fly\n\t\t\t\t\t\tfor (l = r->k; l <= r->l; ++l) {\n\t\t\t\t\t\t\tint strand;\n\t\t\t\t\t\t\tx.x = bwa_sa2pos(bns, bwt, l, p[j]->len + p[j]->ref_shift, &strand);\n\t\t\t\t\t\t\tx.y = k<<2 | strand<<1 | j;\n\t\t\t\t\t\t\tkv_push(pair64_t, d->arr, x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt_chg += pairing(p, d, opt, gopt->s_mm, ii);\n\t\t}\n\n\t\tif (opt->N_multi || opt->n_multi) {\n\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\tif (p[j]->type != BWA_TYPE_NO_MATCH) {\n\t\t\t\t\tint k, n_multi;\n\t\t\t\t\tif (!(p[j]->extra_flag&SAM_FPP) && p[1-j]->type != BWA_TYPE_NO_MATCH) {\n\t\t\t\t\t\tbwa_aln2seq_core(d->aln[j].n, d->aln[j].a, p[j], 0, p[j]->c1+p[j]->c2-1 > opt->N_multi? opt->n_multi : opt->N_multi);\n\t\t\t\t\t} else bwa_aln2seq_core(d->aln[j].n, d->aln[j].a, p[j], 0, opt->n_multi);\n\t\t\t\t\tfor (k = 0, n_multi = 0; k < p[j]->n_multi; ++k) {\n\t\t\t\t\t\tint strand;\n\t\t\t\t\t\tbwt_multi1_t *q = p[j]->multi + k;\n\t\t\t\t\t\tq->pos = bwa_sa2pos(bns, bwt, q->pos, p[j]->len + q->ref_shift, &strand);\n\t\t\t\t\t\tq->strand = strand;\n\t\t\t\t\t\tif (q->pos != p[j]->pos && q->pos != (bwtint_t)-1)\n\t\t\t\t\t\t\tp[j]->multi[n_multi++] = *q;\n\t\t\t\t\t}\n\t\t\t\t\tp[j]->n_multi = n_multi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// free\n\tfor (i = 0; i < n_seqs; ++i) {\n\t\tkv_destroy(buf[0][i].aln);\n\t\tkv_destroy(buf[1][i].aln);\n\t}\n\tfree(buf[0]); free(buf[1]);\n\tif (_bwt == 0) bwt_destroy(bwt);\n\tkv_destroy(d->arr);\n\tkv_destroy(d->pos[0]); kv_destroy(d->pos[1]);\n\tkv_destroy(d->aln[0]); kv_destroy(d->aln[1]);\n\tfree(d);\n\treturn cnt_chg;\n}\n\n#define SW_MIN_MATCH_LEN 20\n#define SW_MIN_MAPQ 17\n\n// cnt = n_mm<<16 | n_gapo<<8 | n_gape\nbwa_cigar_t *bwa_sw_core(bwtint_t l_pac, const ubyte_t *pacseq, int len, const ubyte_t *seq, int64_t *beg, int reglen, int *n_cigar, uint32_t *_cnt)\n{\n\tkswr_t r;\n\tuint32_t *cigar32 = 0;\n\tbwa_cigar_t *cigar = 0;\n\tubyte_t *ref_seq;\n\tbwtint_t k, x, y, l;\n\tint xtra, gscore;\n\tint8_t mat[25];\n\n\tbwa_fill_scmat(1, 3, mat);\n\t// check whether there are too many N's\n\tif (reglen < SW_MIN_MATCH_LEN || (int64_t)l_pac - *beg < len) return 0;\n\tfor (k = 0, x = 0; k < len; ++k)\n\t\tif (seq[k] >= 4) ++x;\n\tif ((float)x/len >= 0.25 || len - x < SW_MIN_MATCH_LEN) return 0;\n\n\t// get reference subsequence\n\tref_seq = (ubyte_t*)calloc(reglen, 1);\n\tfor (k = *beg, l = 0; l < reglen && k < l_pac; ++k)\n\t\tref_seq[l++] = pacseq[k>>2] >> ((~k&3)<<1) & 3;\n\n\t// do alignment\n\txtra = KSW_XSUBO | KSW_XSTART | (len < 250? KSW_XBYTE : 0);\n\tr = ksw_align(len, (uint8_t*)seq, l, ref_seq, 5, mat, 5, 1, xtra, 0);\n\tgscore = ksw_global(r.qe - r.qb + 1, &seq[r.qb], r.te - r.tb + 1, &ref_seq[r.tb], 5, mat, 5, 1, 50, n_cigar, &cigar32);\n\tcigar = (bwa_cigar_t*)cigar32;\n\tfor (k = 0; k < *n_cigar; ++k)\n\t\tcigar[k] = __cigar_create((cigar32[k]&0xf), (cigar32[k]>>4));\n\n\tif (r.score < SW_MIN_MATCH_LEN || r.score2 == r.score || gscore != r.score) { // poor hit or tandem hits or weird alignment\n\t\tfree(cigar); free(ref_seq); *n_cigar = 0;\n\t\treturn 0;\n\t}\n\n\t// check whether the alignment is good enough\n\tfor (k = 0, x = y = 0; k < *n_cigar; ++k) {\n\t\tbwa_cigar_t c = cigar[k];\n\t\tif (__cigar_op(c) == FROM_M) x += __cigar_len(c), y += __cigar_len(c);\n\t\telse if (__cigar_op(c) == FROM_D) x += __cigar_len(c);\n\t\telse y += __cigar_len(c);\n\t}\n\tif (x < SW_MIN_MATCH_LEN || y < SW_MIN_MATCH_LEN) { // not good enough\n\t\tfree(cigar); free(ref_seq);\n\t\t*n_cigar = 0;\n\t\treturn 0;\n\t}\n\n\t{ // update cigar and coordinate;\n\t\tint start = r.qb, end = r.qe + 1;\n\t\t*beg += r.tb;\n\t\tcigar = (bwa_cigar_t*)realloc(cigar, sizeof(bwa_cigar_t) * (*n_cigar + 2));\n\t\tif (start) {\n\t\t\tmemmove(cigar + 1, cigar, sizeof(bwa_cigar_t) * (*n_cigar));\n\t\t\tcigar[0] = __cigar_create(3, start);\n\t\t\t++(*n_cigar);\n\t\t}\n\t\tif (end < len) {\n\t\t\t/*cigar[*n_cigar] = 3<<14 | (len - end);*/\n\t\t\tcigar[*n_cigar] = __cigar_create(3, (len - end));\n\t\t\t++(*n_cigar);\n\t\t}\n\t}\n\n\t{ // set *cnt\n\t\tint n_mm, n_gapo, n_gape;\n\t\tn_mm = n_gapo = n_gape = 0;\n\t\tx = r.tb; y = r.qb;\n\t\tfor (k = 0; k < *n_cigar; ++k) {\n\t\t\tbwa_cigar_t c = cigar[k];\n\t\t\tif (__cigar_op(c) == FROM_M) {\n\t\t\t\tfor (l = 0; l < (__cigar_len(c)); ++l)\n\t\t\t\t\tif (ref_seq[x+l] < 4 && seq[y+l] < 4 && ref_seq[x+l] != seq[y+l]) ++n_mm;\n\t\t\t\tx += __cigar_len(c), y += __cigar_len(c);\n\t\t\t} else if (__cigar_op(c) == FROM_D) {\n\t\t\t\tx += __cigar_len(c), ++n_gapo, n_gape += (__cigar_len(c)) - 1;\n\t\t\t} else if (__cigar_op(c) == FROM_I) {\n\t\t\t\ty += __cigar_len(c), ++n_gapo, n_gape += (__cigar_len(c)) - 1;\n\t\t\t}\n\t\t}\n\t\t*_cnt = (uint32_t)n_mm<<16 | n_gapo<<8 | n_gape;\n\t}\n\t\n\tfree(ref_seq);\n\treturn cigar;\n}\n\nubyte_t *bwa_paired_sw(const bntseq_t *bns, const ubyte_t *_pacseq, int n_seqs, bwa_seq_t *seqs[2], const pe_opt_t *popt, const isize_info_t *ii)\n{\n\tubyte_t *pacseq;\n\tint i;\n\tuint64_t n_tot[2], n_mapped[2];\n\n\t// load reference sequence\n\tif (_pacseq == 0) {\n\t\tpacseq = (ubyte_t*)calloc(bns->l_pac/4+1, 1);\n\t\terr_rewind(bns->fp_pac);\n\t\terr_fread_noeof(pacseq, 1, bns->l_pac/4+1, bns->fp_pac);\n\t} else pacseq = (ubyte_t*)_pacseq;\n\tif (!popt->is_sw || ii->avg < 0.0) return pacseq;\n\n\t// perform mate alignment\n\tn_tot[0] = n_tot[1] = n_mapped[0] = n_mapped[1] = 0;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p[2];\n\t\tp[0] = seqs[0] + i; p[1] = seqs[1] + i;\n\t\tif ((p[0]->mapQ >= SW_MIN_MAPQ || p[1]->mapQ >= SW_MIN_MAPQ) && (p[0]->extra_flag&SAM_FPP) == 0) { // unpaired and one read has high mapQ\n\t\t\tint k, n_cigar[2], is_singleton, mapQ = 0, mq_adjust[2];\n\t\t\tint64_t beg[2], end[2];\n\t\t\tbwa_cigar_t *cigar[2];\n\t\t\tuint32_t cnt[2];\n\n\t\t\t/* In the following, _pref points to the reference read\n\t\t\t * which must be aligned; _pmate points to its mate which is\n\t\t\t * considered to be modified. */\n\n#define __set_rght_coor(_a, _b, _pref, _pmate) do {\t\t\t\t\t\t\\\n\t\t\t\t(_a) = (int64_t)_pref->pos + ii->avg - 3 * ii->std - _pmate->len * 1.5; \\\n\t\t\t\t(_b) = (_a) + 6 * ii->std + 2 * _pmate->len;\t\t\t\\\n\t\t\t\tif ((_a) < (int64_t)_pref->pos + _pref->len) (_a) = _pref->pos + _pref->len; \\\n\t\t\t\tif ((_b) > bns->l_pac) (_b) = bns->l_pac;\t\t\t\t\\\n\t\t\t} while (0)\n\n#define __set_left_coor(_a, _b, _pref, _pmate) do {\t\t\t\t\t\t\\\n\t\t\t\t(_a) = (int64_t)_pref->pos + _pref->len - ii->avg - 3 * ii->std - _pmate->len * 0.5; \\\n\t\t\t\t(_b) = (_a) + 6 * ii->std + 2 * _pmate->len;\t\t\t\\\n\t\t\t\tif ((_a) < 0) (_a) = 0;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif ((_b) > _pref->pos) (_b) = _pref->pos;\t\t\t\t\\\n\t\t\t} while (0)\n\t\t\t\n#define __set_fixed(_pref, _pmate, _beg, _cnt) do {\t\t\t\t\t\t\\\n\t\t\t\t_pmate->type = BWA_TYPE_MATESW;\t\t\t\t\t\t\t\\\n\t\t\t\t_pmate->pos = _beg;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t_pmate->seQ = _pref->seQ;\t\t\t\t\t\t\t\t\\\n\t\t\t\t_pmate->strand = (popt->type == BWA_PET_STD)? 1 - _pref->strand : _pref->strand; \\\n\t\t\t\t_pmate->n_mm = _cnt>>16; _pmate->n_gapo = _cnt>>8&0xff; _pmate->n_gape = _cnt&0xff; \\\n\t\t\t\t_pmate->extra_flag |= SAM_FPP;\t\t\t\t\t\t\t\\\n\t\t\t\t_pref->extra_flag |= SAM_FPP;\t\t\t\t\t\t\t\\\n\t\t\t} while (0)\n\n\t\t\tmq_adjust[0] = mq_adjust[1] = 255; // not effective\n\t\t\tis_singleton = (p[0]->type == BWA_TYPE_NO_MATCH || p[1]->type == BWA_TYPE_NO_MATCH)? 1 : 0;\n\n\t\t\t++n_tot[is_singleton];\n\t\t\tcigar[0] = cigar[1] = 0;\n\t\t\tn_cigar[0] = n_cigar[1] = 0;\n\t\t\tif (popt->type != BWA_PET_STD) continue; // other types of pairing is not considered\n\t\t\tfor (k = 0; k < 2; ++k) { // p[1-k] is the reference read and p[k] is the read considered to be modified\n\t\t\t\tubyte_t *seq;\n\t\t\t\tif (p[1-k]->type == BWA_TYPE_NO_MATCH) continue; // if p[1-k] is unmapped, skip\n\t\t\t\t{ // note that popt->type == BWA_PET_STD always true; in older versions, there was a branch for color-space FF/RR reads\n\t\t\t\t\tif (p[1-k]->strand == 0) { // then the mate is on the reverse strand and has larger coordinate\n\t\t\t\t\t\t__set_rght_coor(beg[k], end[k], p[1-k], p[k]);\n\t\t\t\t\t\tseq = p[k]->rseq;\n\t\t\t\t\t} else { // then the mate is on forward stand and has smaller coordinate\n\t\t\t\t\t\t__set_left_coor(beg[k], end[k], p[1-k], p[k]);\n\t\t\t\t\t\tseq = p[k]->seq;\n\t\t\t\t\t\tseq_reverse(p[k]->len, seq, 0); // because ->seq is reversed; this will reversed back shortly\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// perform SW alignment\n\t\t\t\tcigar[k] = bwa_sw_core(bns->l_pac, pacseq, p[k]->len, seq, &beg[k], end[k] - beg[k], &n_cigar[k], &cnt[k]);\n\t\t\t\tif (cigar[k] && p[k]->type != BWA_TYPE_NO_MATCH) { // re-evaluate cigar[k]\n\t\t\t\t\tint s_old, clip = 0, s_new;\n\t\t\t\t\tif (__cigar_op(cigar[k][0]) == 3) clip += __cigar_len(cigar[k][0]);\n\t\t\t\t\tif (__cigar_op(cigar[k][n_cigar[k]-1]) == 3) clip += __cigar_len(cigar[k][n_cigar[k]-1]);\n\t\t\t\t\ts_old = (int)((p[k]->n_mm * 9 + p[k]->n_gapo * 13 + p[k]->n_gape * 2) / 3. * 8. + .499);\n\t\t\t\t\ts_new = (int)(((cnt[k]>>16) * 9 + (cnt[k]>>8&0xff) * 13 + (cnt[k]&0xff) * 2 + clip * 3) / 3. * 8. + .499);\n\t\t\t\t\ts_old += -4.343 * log(ii->ap_prior / bns->l_pac);\n\t\t\t\t\ts_new += (int)(-4.343 * log(.5 * erfc(M_SQRT1_2 * 1.5) + .499)); // assume the mapped isize is 1.5\\sigma\n\t\t\t\t\tif (s_old < s_new) { // reject SW alignment\n\t\t\t\t\t\tmq_adjust[k] = s_new - s_old;\n\t\t\t\t\t\tfree(cigar[k]); cigar[k] = 0; n_cigar[k] = 0;\n\t\t\t\t\t} else mq_adjust[k] = s_old - s_new;\n\t\t\t\t}\n\t\t\t\t// now revserse sequence back such that p[*]->seq looks untouched\n\t\t\t\tif (popt->type == BWA_PET_STD) {\n\t\t\t\t\tif (p[1-k]->strand == 1) seq_reverse(p[k]->len, seq, 0);\n\t\t\t\t} else {\n\t\t\t\t\tif (p[1-k]->strand == 0) seq_reverse(p[k]->len, seq, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk = -1; // no read to be changed\n\t\t\tif (cigar[0] && cigar[1]) {\n\t\t\t\tk = p[0]->mapQ < p[1]->mapQ? 0 : 1; // p[k] to be fixed\n\t\t\t\tmapQ = abs(p[1]->mapQ - p[0]->mapQ);\n\t\t\t} else if (cigar[0]) k = 0, mapQ = p[1]->mapQ;\n\t\t\telse if (cigar[1]) k = 1, mapQ = p[0]->mapQ;\n\t\t\tif (k >= 0 && p[k]->pos != beg[k]) {\n\t\t\t\t++n_mapped[is_singleton];\n\t\t\t\t{ // recalculate mapping quality\n\t\t\t\t\tint tmp = (int)p[1-k]->mapQ - p[k]->mapQ/2 - 8;\n\t\t\t\t\tif (tmp <= 0) tmp = 1;\n\t\t\t\t\tif (mapQ > tmp) mapQ = tmp;\n\t\t\t\t\tp[k]->mapQ = p[1-k]->mapQ = mapQ;\n\t\t\t\t\tp[k]->seQ = p[1-k]->seQ = p[1-k]->seQ < mapQ? p[1-k]->seQ : mapQ;\n\t\t\t\t\tif (p[k]->mapQ > mq_adjust[k]) p[k]->mapQ = mq_adjust[k];\n\t\t\t\t\tif (p[k]->seQ > mq_adjust[k]) p[k]->seQ = mq_adjust[k];\n\t\t\t\t}\n\t\t\t\t// update CIGAR\n\t\t\t\tfree(p[k]->cigar); p[k]->cigar = cigar[k]; cigar[k] = 0;\n\t\t\t\tp[k]->n_cigar = n_cigar[k];\n\t\t\t\t// update the rest of information\n\t\t\t\t__set_fixed(p[1-k], p[k], beg[k], cnt[k]);\n\t\t\t}\n\t\t\tfree(cigar[0]); free(cigar[1]);\n\t\t}\n\t}\n\tfprintf(stderr, \"[bwa_paired_sw] %lld out of %lld Q%d singletons are mated.\\n\",\n\t\t\t(long long)n_mapped[1], (long long)n_tot[1], SW_MIN_MAPQ);\n\tfprintf(stderr, \"[bwa_paired_sw] %lld out of %lld Q%d discordant pairs are fixed.\\n\",\n\t\t\t(long long)n_mapped[0], (long long)n_tot[0], SW_MIN_MAPQ);\n\treturn pacseq;\n}\n\nvoid bwa_sai2sam_pe_core(const char *prefix, char *const fn_sa[2], char *const fn_fa[2], pe_opt_t *popt, const char *rg_line)\n{\n\textern bwa_seqio_t *bwa_open_reads(int mode, const char *fn_fa);\n\tint i, j, n_seqs;\n\tlong long tot_seqs = 0;\n\tbwa_seq_t *seqs[2];\n\tbwa_seqio_t *ks[2];\n\tclock_t t;\n\tbntseq_t *bns;\n\tFILE *fp_sa[2];\n\tgap_opt_t opt, opt0;\n\tkhint_t iter;\n\tisize_info_t last_ii; // this is for the last batch of reads\n\tchar str[1024], magic[2][4];\n\tbwt_t *bwt;\n\tuint8_t *pac;\n\n\t// initialization\n\tbwase_initialize(); // initialize g_log_n[] in bwase.c\n\tpac = 0; bwt = 0;\n\tfor (i = 1; i != 256; ++i) g_log_n[i] = (int)(4.343 * log(i) + 0.5);\n\tbns = bns_restore(prefix);\n\tsrand48(bns->seed);\n\tfp_sa[0] = xopen(fn_sa[0], \"r\");\n\tfp_sa[1] = xopen(fn_sa[1], \"r\");\n\tg_hash = kh_init(b128);\n\tlast_ii.avg = -1.0;\n\n\terr_fread_noeof(magic[0], 1, 4, fp_sa[0]);\n\terr_fread_noeof(magic[1], 1, 4, fp_sa[1]);\n\tif (strncmp(magic[0], SAI_MAGIC, 4) != 0 || strncmp(magic[1], SAI_MAGIC, 4) != 0) {\n\t\tfprintf(stderr, \"[E::%s] Unmatched SAI magic. Please re-run `aln' with the same version of bwa.\\n\", __func__);\n\t\texit(1);\n\t}\n\terr_fread_noeof(&opt, sizeof(gap_opt_t), 1, fp_sa[0]);\n\tks[0] = bwa_open_reads(opt.mode, fn_fa[0]);\n\topt0 = opt;\n\terr_fread_noeof(&opt, sizeof(gap_opt_t), 1, fp_sa[1]); // overwritten!\n\tks[1] = bwa_open_reads(opt.mode, fn_fa[1]);\n\t{ // for Illumina alignment only\n\t\tif (popt->is_preload) {\n\t\t\tstrcpy(str, prefix); strcat(str, \".bwt\");  bwt = bwt_restore_bwt(str);\n\t\t\tstrcpy(str, prefix); strcat(str, \".sa\"); bwt_restore_sa(str, bwt);\n\t\t\tpac = (ubyte_t*)calloc(bns->l_pac/4+1, 1);\n\t\t\terr_rewind(bns->fp_pac);\n\t\t\terr_fread_noeof(pac, 1, bns->l_pac/4+1, bns->fp_pac);\n\t\t}\n\t}\n\n\t// core loop\n\tbwa_print_sam_hdr(bns, rg_line);\n\twhile ((seqs[0] = bwa_read_seq(ks[0], 0x40000, &n_seqs, opt0.mode, opt0.trim_qual)) != 0) {\n\t\tint cnt_chg;\n\t\tisize_info_t ii;\n\t\tubyte_t *pacseq;\n\n\t\tseqs[1] = bwa_read_seq(ks[1], 0x40000, &n_seqs, opt.mode, opt.trim_qual);\n\t\ttot_seqs += n_seqs;\n\t\tt = clock();\n\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] convert to sequence coordinate... \\n\");\n\t\tcnt_chg = bwa_cal_pac_pos_pe(bns, prefix, bwt, n_seqs, seqs, fp_sa, &ii, popt, &opt, &last_ii);\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] time elapses: %.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] changing coordinates of %d alignments.\\n\", cnt_chg);\n\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] align unmapped mate...\\n\");\n\t\tpacseq = bwa_paired_sw(bns, pac, n_seqs, seqs, popt, &ii);\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] time elapses: %.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] refine gapped alignments... \");\n\t\tfor (j = 0; j < 2; ++j)\n\t\t\tbwa_refine_gapped(bns, n_seqs, seqs[j], pacseq);\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\t\tif (pac == 0) free(pacseq);\n\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] print alignments... \");\n\t\tfor (i = 0; i < n_seqs; ++i) {\n\t\t\tbwa_seq_t *p[2];\n\t\t\tp[0] = seqs[0] + i; p[1] = seqs[1] + i;\n\t\t\tif (p[0]->bc[0] || p[1]->bc[0]) {\n\t\t\t\tstrcat(p[0]->bc, p[1]->bc);\n\t\t\t\tstrcpy(p[1]->bc, p[0]->bc);\n\t\t\t}\n\t\t\tbwa_print_sam1(bns, p[0], p[1], opt.mode, opt.max_top2);\n\t\t\tbwa_print_sam1(bns, p[1], p[0], opt.mode, opt.max_top2);\n\t\t\tif (strcmp(p[0]->name, p[1]->name) != 0) err_fatal(__func__, \"paired reads have different names: \\\"%s\\\", \\\"%s\\\"\\n\", p[0]->name, p[1]->name);\n\t\t}\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\n\t\tfor (j = 0; j < 2; ++j)\n\t\t\tbwa_free_read_seq(n_seqs, seqs[j]);\n\t\tfprintf(stderr, \"[bwa_sai2sam_pe_core] %lld sequences have been processed.\\n\", tot_seqs);\n\t\tlast_ii = ii;\n\t}\n\n\t// destroy\n\tbns_destroy(bns);\n\tfor (i = 0; i < 2; ++i) {\n\t\tbwa_seq_close(ks[i]);\n\t\terr_fclose(fp_sa[i]);\n\t}\n\tfor (iter = kh_begin(g_hash); iter != kh_end(g_hash); ++iter)\n\t\tif (kh_exist(g_hash, iter)) free(kh_val(g_hash, iter).a);\n\tkh_destroy(b128, g_hash);\n\tif (pac) {\n\t\tfree(pac); bwt_destroy(bwt);\n\t}\n}\n\nint bwa_sai2sam_pe(int argc, char *argv[])\n{\n\tint c;\n\tpe_opt_t *popt;\n\tchar *prefix, *rg_line = 0;\n\n\tpopt = bwa_init_pe_opt();\n\twhile ((c = getopt(argc, argv, \"a:o:sPn:N:c:f:Ar:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1;\n\t\t\tbreak;\n\t\tcase 'a': popt->max_isize = atoi(optarg); break;\n\t\tcase 'o': popt->max_occ = atoi(optarg); break;\n\t\tcase 's': popt->is_sw = 0; break;\n\t\tcase 'P': popt->is_preload = 1; break;\n\t\tcase 'n': popt->n_multi = atoi(optarg); break;\n\t\tcase 'N': popt->N_multi = atoi(optarg); break;\n\t\tcase 'c': popt->ap_prior = atof(optarg); break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tcase 'A': popt->force_isize = 1; break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\n\tif (optind + 5 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa sampe [options] <prefix> <in1.sai> <in2.sai> <in1.fq> <in2.fq>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -a INT   maximum insert size [%d]\\n\", popt->max_isize);\n\t\tfprintf(stderr, \"         -o INT   maximum occurrences for one end [%d]\\n\", popt->max_occ);\n\t\tfprintf(stderr, \"         -n INT   maximum hits to output for paired reads [%d]\\n\", popt->n_multi);\n\t\tfprintf(stderr, \"         -N INT   maximum hits to output for discordant pairs [%d]\\n\", popt->N_multi);\n\t\tfprintf(stderr, \"         -c FLOAT prior of chimeric rate (lower bound) [%.1le]\\n\", popt->ap_prior);\n        fprintf(stderr, \"         -f FILE  sam file to output results to [stdout]\\n\");\n\t\tfprintf(stderr, \"         -r STR   read group header line such as `@RG\\\\tID:foo\\\\tSM:bar' [null]\\n\");\n\t\tfprintf(stderr, \"         -P       preload index into memory (for base-space reads only)\\n\");\n\t\tfprintf(stderr, \"         -s       disable Smith-Waterman for the unmapped mate\\n\");\n\t\tfprintf(stderr, \"         -A       disable insert size estimate (force -s)\\n\\n\");\n\t\tfprintf(stderr, \"Notes: 1. For SOLiD reads, <in1.fq> corresponds R3 reads and <in2.fq> to F3.\\n\");\n\t\tfprintf(stderr, \"       2. For reads shorter than 30bp, applying a smaller -o is recommended to\\n\");\n\t\tfprintf(stderr, \"          to get a sensible speed at the cost of pairing accuracy.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 1;\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\treturn 1;\n\t}\n\tbwa_sai2sam_pe_core(prefix, argv + optind + 1, argv + optind+3, popt, rg_line);\n\tfree(prefix); free(popt);\n\treturn 0;\n}\n"
        },
        {
          "name": "bwase.c",
          "type": "blob",
          "size": 19.107421875,
          "content": "#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\n#include \"bwase.h\"\n#include \"bwtaln.h\"\n#include \"bntseq.h\"\n#include \"utils.h\"\n#include \"kstring.h\"\n#include \"bwa.h\"\n#include \"ksw.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nint g_log_n[256];\n\nvoid bwa_aln2seq_core(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s, int set_main, int n_multi)\n{\n\tint i, cnt, best;\n\tif (n_aln == 0) {\n\t\ts->type = BWA_TYPE_NO_MATCH;\n\t\ts->c1 = s->c2 = 0;\n\t\treturn;\n\t}\n\n\tif (set_main) {\n\t\tbest = aln[0].score;\n\t\tfor (i = cnt = 0; i < n_aln; ++i) {\n\t\t\tconst bwt_aln1_t *p = aln + i;\n\t\t\tif (p->score > best) break;\n\t\t\tif (drand48() * (p->l - p->k + 1 + cnt) > (double)cnt) {\n\t\t\t\ts->n_mm = p->n_mm; s->n_gapo = p->n_gapo; s->n_gape = p->n_gape;\n\t\t\t\ts->ref_shift = (int)p->n_del - (int)p->n_ins;\n\t\t\t\ts->score = p->score;\n\t\t\t\ts->sa = p->k + (bwtint_t)((p->l - p->k + 1) * drand48());\n\t\t\t}\n\t\t\tcnt += p->l - p->k + 1;\n\t\t}\n\t\ts->c1 = cnt;\n\t\tfor (; i < n_aln; ++i) cnt += aln[i].l - aln[i].k + 1;\n\t\ts->c2 = cnt - s->c1;\n\t\ts->type = s->c1 > 1? BWA_TYPE_REPEAT : BWA_TYPE_UNIQUE;\n\t}\n\n\tif (n_multi) {\n\t\tint k, rest, n_occ, z = 0;\n\t\tfor (k = n_occ = 0; k < n_aln; ++k) {\n\t\t\tconst bwt_aln1_t *q = aln + k;\n\t\t\tn_occ += q->l - q->k + 1;\n\t\t}\n\t\tif (s->multi) free(s->multi);\n\t\tif (n_occ > n_multi + 1) { // if there are too many hits, generate none of them\n\t\t\ts->multi = 0; s->n_multi = 0;\n\t\t\treturn;\n\t\t}\n\t\t/* The following code is more flexible than what is required\n\t\t * here. In principle, due to the requirement above, we can\n\t\t * simply output all hits, but the following samples \"rest\"\n\t\t * number of random hits. */\n\t\trest = n_occ > n_multi + 1? n_multi + 1 : n_occ; // find one additional for ->sa\n\t\ts->multi = calloc(rest, sizeof(bwt_multi1_t));\n\t\tfor (k = 0; k < n_aln; ++k) {\n\t\t\tconst bwt_aln1_t *q = aln + k;\n\t\t\tif (q->l - q->k + 1 <= rest) {\n\t\t\t\tbwtint_t l;\n\t\t\t\tfor (l = q->k; l <= q->l; ++l) {\n\t\t\t\t\ts->multi[z].pos = l;\n\t\t\t\t\ts->multi[z].gap = q->n_gapo + q->n_gape;\n\t\t\t\t\ts->multi[z].ref_shift = (int)q->n_del - (int)q->n_ins;\n\t\t\t\t\ts->multi[z++].mm = q->n_mm;\n\t\t\t\t}\n\t\t\t\trest -= q->l - q->k + 1;\n\t\t\t} else { // Random sampling (http://code.activestate.com/recipes/272884/). In fact, we never come here. \n\t\t\t\tint j, i;\n\t\t\t\tfor (j = rest, i = q->l - q->k + 1; j > 0; --j) {\n\t\t\t\t\tdouble p = 1.0, x = drand48();\n\t\t\t\t\twhile (x < p) p -= p * j / (i--);\n\t\t\t\t\ts->multi[z].pos = q->l - i;\n\t\t\t\t\ts->multi[z].gap = q->n_gapo + q->n_gape;\n\t\t\t\t\ts->multi[z].ref_shift = (int)q->n_del - (int)q->n_ins;\n\t\t\t\t\ts->multi[z++].mm = q->n_mm;\n\t\t\t\t}\n\t\t\t\trest = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ts->n_multi = z;\n\t}\n}\n\nvoid bwa_aln2seq(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s)\n{\n\tbwa_aln2seq_core(n_aln, aln, s, 1, 0);\n}\n\nint bwa_approx_mapQ(const bwa_seq_t *p, int mm)\n{\n\tint n;\n\tif (p->c1 == 0) return 23;\n\tif (p->c1 > 1) return 0;\n\tif (p->n_mm == mm) return 25;\n\tif (p->c2 == 0) return 37;\n\tn = (p->c2 >= 255)? 255 : p->c2;\n\treturn (23 < g_log_n[n])? 0 : 23 - g_log_n[n];\n}\n\nbwtint_t bwa_sa2pos(const bntseq_t *bns, const bwt_t *bwt, bwtint_t sapos, int ref_len, int *strand)\n{\n\tbwtint_t pos_f;\n\tint is_rev;\n\t*strand = 0; // initialise strand to 0 otherwise we could return without setting it\n\tpos_f = bwt_sa(bwt, sapos); // position on the forward-reverse coordinate\n\tif (pos_f < bns->l_pac && bns->l_pac < pos_f + ref_len) return (bwtint_t)-1;\n\tpos_f = bns_depos(bns, pos_f, &is_rev); // position on the forward strand; this may be the first base or the last base\n\t*strand = !is_rev;\n\tif (is_rev) pos_f = pos_f + 1 < ref_len? 0 : pos_f - ref_len + 1; // position of the first base\n\treturn pos_f; // FIXME: it is possible that pos_f < bns->anns[ref_id].offset\n}\n\n/**\n * Derive the actual position in the read from the given suffix array\n * coordinates. Note that the position will be approximate based on\n * whether indels appear in the read and whether calculations are\n * performed from the start or end of the read.\n */\nvoid bwa_cal_pac_pos_core(const bntseq_t *bns, const bwt_t *bwt, bwa_seq_t *seq, const int max_mm, const float fnr)\n{\n\tint max_diff, strand;\n\tif (seq->type != BWA_TYPE_UNIQUE && seq->type != BWA_TYPE_REPEAT) return;\n\tmax_diff = fnr > 0.0? bwa_cal_maxdiff(seq->len, BWA_AVG_ERR, fnr) : max_mm;\n\tseq->seQ = seq->mapQ = bwa_approx_mapQ(seq, max_diff);\n\t//fprintf(stderr, \"%d\\n\", seq->ref_shift);\n\tseq->pos = bwa_sa2pos(bns, bwt, seq->sa, seq->len + seq->ref_shift, &strand);\n\tseq->strand = strand;\n\tseq->seQ = seq->mapQ = bwa_approx_mapQ(seq, max_diff);\n\tif (seq->pos == (bwtint_t)-1) seq->type = BWA_TYPE_NO_MATCH;\n}\n\nvoid bwa_cal_pac_pos(const bntseq_t *bns, const char *prefix, int n_seqs, bwa_seq_t *seqs, int max_mm, float fnr)\n{\n\tint i, j, strand, n_multi;\n\tchar str[1024];\n\tbwt_t *bwt;\n\t// load forward SA\n\tstrcpy(str, prefix); strcat(str, \".bwt\");  bwt = bwt_restore_bwt(str);\n\tstrcpy(str, prefix); strcat(str, \".sa\"); bwt_restore_sa(str, bwt);\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = &seqs[i];\n\t\tbwa_cal_pac_pos_core(bns, bwt, p, max_mm, fnr);\n\t\tfor (j = n_multi = 0; j < p->n_multi; ++j) {\n\t\t\tbwt_multi1_t *q = p->multi + j;\n\t\t\tq->pos = bwa_sa2pos(bns, bwt, q->pos, p->len + q->ref_shift, &strand);\n\t\t\tq->strand = strand;\n\t\t\tif (q->pos != p->pos && q->pos != (bwtint_t)-1)\n\t\t\t\tp->multi[n_multi++] = *q;\n\t\t}\n\t\tp->n_multi = n_multi;\n\t}\n\tbwt_destroy(bwt);\n}\n\n#define SW_BW 50\n\nbwa_cigar_t *bwa_refine_gapped_core(bwtint_t l_pac, const ubyte_t *pacseq, int len, ubyte_t *seq, int ref_shift, bwtint_t *_rb, int *n_cigar)\n{\n\tbwa_cigar_t *cigar = 0;\n\tuint32_t *cigar32 = 0;\n\tubyte_t *rseq;\n\tint64_t k, rb, re, rlen;\n\tint8_t mat[25];\n\tint w;\n\n\tbwa_fill_scmat(1, 3, mat);\n\trb = *_rb; re = rb + len + ref_shift;\n\tassert(re <= l_pac);\n\trseq = bns_get_seq(l_pac, pacseq, rb, re, &rlen);\n\tassert(re - rb == rlen);\n\tw = abs((int)rlen - len) * 1.5;\n\tksw_global(len, seq, rlen, rseq, 5, mat, 5, 1, SW_BW > w? SW_BW : w, n_cigar, &cigar32);\n\tassert(*n_cigar > 0);\n\tif ((cigar32[*n_cigar - 1]&0xf) == 1) cigar32[*n_cigar - 1] = (cigar32[*n_cigar - 1]>>4<<4) | 3; // change endding ins to soft clipping\n\tif ((cigar32[0]&0xf) == 1) cigar32[0] = (cigar32[0]>>4<<4) | 3; // change beginning ins to soft clipping\n\tif ((cigar32[*n_cigar - 1]&0xf) == 2) --*n_cigar; // delete endding del\n\tif ((cigar32[0]&0xf) == 2) { // delete beginning del\n\t\t*_rb += cigar32[0]>>4;\n\t\t--*n_cigar;\n\t\tmemmove(cigar32, cigar32+1, (*n_cigar) * 4);\n\t}\n\tcigar = (bwa_cigar_t*)cigar32;\n\tfor (k = 0; k < *n_cigar; ++k)\n\t\tcigar[k] = __cigar_create((cigar32[k]&0xf), (cigar32[k]>>4));\n\tfree(rseq);\n\treturn cigar;\n}\n\nchar *bwa_cal_md1(int n_cigar, bwa_cigar_t *cigar, int len, bwtint_t pos, ubyte_t *seq,\n\t\t\t\t  bwtint_t l_pac, ubyte_t *pacseq, kstring_t *str, int *_nm)\n{\n\tbwtint_t x, y;\n\tint z, u, c, nm = 0;\n\tstr->l = 0; // reset\n\tx = pos; y = 0;\n\tif (cigar) {\n\t\tint k, l;\n\t\tfor (k = u = 0; k < n_cigar; ++k) {\n\t\t\tl = __cigar_len(cigar[k]);\n\t\t\tif (__cigar_op(cigar[k]) == FROM_M) {\n\t\t\t\tfor (z = 0; z < l && x+z < l_pac; ++z) {\n\t\t\t\t\tc = pacseq[(x+z)>>2] >> ((~(x+z)&3)<<1) & 3;\n\t\t\t\t\tif (c > 3 || seq[y+z] > 3 || c != seq[y+z]) {\n\t\t\t\t\t\tksprintf(str, \"%d\", u);\n\t\t\t\t\t\tkputc(\"ACGTN\"[c], str);\n\t\t\t\t\t\t++nm;\n\t\t\t\t\t\tu = 0;\n\t\t\t\t\t} else ++u;\n\t\t\t\t}\n\t\t\t\tx += l; y += l;\n\t\t\t} else if (__cigar_op(cigar[k]) == FROM_I || __cigar_op(cigar[k]) == FROM_S) {\n\t\t\t\ty += l;\n\t\t\t\tif (__cigar_op(cigar[k]) == FROM_I) nm += l;\n\t\t\t} else if (__cigar_op(cigar[k]) == FROM_D) {\n\t\t\t\tksprintf(str, \"%d\", u);\n\t\t\t\tkputc('^', str);\n\t\t\t\tfor (z = 0; z < l && x+z < l_pac; ++z)\n\t\t\t\t\tkputc(\"ACGT\"[pacseq[(x+z)>>2] >> ((~(x+z)&3)<<1) & 3], str);\n\t\t\t\tu = 0;\n\t\t\t\tx += l; nm += l;\n\t\t\t}\n\t\t}\n\t} else { // no gaps\n\t\tfor (z = u = 0; z < (bwtint_t)len && x+z < l_pac; ++z) {\n\t\t\tc = pacseq[(x+z)>>2] >> ((~(x+z)&3)<<1) & 3;\n\t\t\tif (c > 3 || seq[y+z] > 3 || c != seq[y+z]) {\n\t\t\t\tksprintf(str, \"%d\", u);\n\t\t\t\tkputc(\"ACGTN\"[c], str);\n\t\t\t\t++nm;\n\t\t\t\tu = 0;\n\t\t\t} else ++u;\n\t\t}\n\t}\n\tksprintf(str, \"%d\", u);\n\t*_nm = nm;\n\treturn strdup(str->s);\n}\n\nvoid bwa_correct_trimmed(bwa_seq_t *s)\n{\n\tif (s->len == s->full_len) return;\n\tif (s->strand == 0) { // forward\n\t\tif (s->cigar && __cigar_op(s->cigar[s->n_cigar-1]) == FROM_S) { // the last is S\n\t\t\ts->cigar[s->n_cigar-1] += s->full_len - s->len;\n\t\t} else {\n\t\t\tif (s->cigar == 0) {\n\t\t\t\ts->n_cigar = 2;\n\t\t\t\ts->cigar = calloc(s->n_cigar, sizeof(bwa_cigar_t));\n\t\t\t\ts->cigar[0] = __cigar_create(0, s->len);\n\t\t\t} else {\n\t\t\t\t++s->n_cigar;\n\t\t\t\ts->cigar = realloc(s->cigar, s->n_cigar * sizeof(bwa_cigar_t));\n\t\t\t}\n\t\t\ts->cigar[s->n_cigar-1] = __cigar_create(3, (s->full_len - s->len));\n\t\t}\n\t} else { // reverse\n\t\tif (s->cigar && __cigar_op(s->cigar[0]) == FROM_S) { // the first is S\n\t\t\ts->cigar[0] += s->full_len - s->len;\n\t\t} else {\n\t\t\tif (s->cigar == 0) {\n\t\t\t\ts->n_cigar = 2;\n\t\t\t\ts->cigar = calloc(s->n_cigar, sizeof(bwa_cigar_t));\n\t\t\t\ts->cigar[1] = __cigar_create(0, s->len);\n\t\t\t} else {\n\t\t\t\t++s->n_cigar;\n\t\t\t\ts->cigar = realloc(s->cigar, s->n_cigar * sizeof(bwa_cigar_t));\n\t\t\t\tmemmove(s->cigar + 1, s->cigar, (s->n_cigar-1) * sizeof(bwa_cigar_t));\n\t\t\t}\n\t\t\ts->cigar[0] = __cigar_create(3, (s->full_len - s->len));\n\t\t}\n\t}\n\ts->len = s->full_len;\n}\n\nvoid bwa_refine_gapped(const bntseq_t *bns, int n_seqs, bwa_seq_t *seqs, ubyte_t *_pacseq)\n{\n\tubyte_t *pacseq;\n\tint i, j, k;\n\tkstring_t *str;\n\n\tif (!_pacseq) {\n\t\tpacseq = (ubyte_t*)calloc(bns->l_pac/4+1, 1);\n\t\terr_rewind(bns->fp_pac);\n\t\terr_fread_noeof(pacseq, 1, bns->l_pac/4+1, bns->fp_pac);\n\t} else pacseq = _pacseq;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *s = seqs + i;\n\t\tseq_reverse(s->len, s->seq, 0); // IMPORTANT: s->seq is reversed here!!!\n\t\tfor (j = k = 0; j < s->n_multi; ++j) {\n\t\t\tbwt_multi1_t *q = s->multi + j;\n\t\t\tint n_cigar;\n\t\t\tif (q->gap) { // gapped alignment\n\t\t\t\tq->cigar = bwa_refine_gapped_core(bns->l_pac, pacseq, s->len, q->strand? s->rseq : s->seq, q->ref_shift, &q->pos, &n_cigar);\n\t\t\t\tq->n_cigar = n_cigar;\n\t\t\t\tif (q->cigar) s->multi[k++] = *q;\n\t\t\t} else s->multi[k++] = *q;\n\t\t}\n\t\ts->n_multi = k; // this squeezes out gapped alignments which failed the CIGAR generation\n\t\tif (s->type == BWA_TYPE_NO_MATCH || s->type == BWA_TYPE_MATESW || s->n_gapo == 0) continue;\n\t\ts->cigar = bwa_refine_gapped_core(bns->l_pac, pacseq, s->len, s->strand? s->rseq : s->seq, s->ref_shift, &s->pos, &s->n_cigar);\n\t\tif (s->cigar == 0) s->type = BWA_TYPE_NO_MATCH;\n\t}\n\t// generate MD tag\n\tstr = (kstring_t*)calloc(1, sizeof(kstring_t));\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *s = seqs + i;\n\t\tif (s->type != BWA_TYPE_NO_MATCH) {\n\t\t\tint nm;\n\t\t\ts->md = bwa_cal_md1(s->n_cigar, s->cigar, s->len, s->pos, s->strand? s->rseq : s->seq, bns->l_pac, pacseq, str, &nm);\n\t\t\ts->nm = nm;\n\t\t}\n\t}\n\tfree(str->s); free(str);\n\n\t// correct for trimmed reads\n\tfor (i = 0; i < n_seqs; ++i) bwa_correct_trimmed(seqs + i);\n\n\tif (!_pacseq) free(pacseq);\n}\n\nint64_t pos_end(const bwa_seq_t *p)\n{\n\tif (p->cigar) {\n\t\tint j;\n\t\tint64_t x = p->pos;\n\t\tfor (j = 0; j != p->n_cigar; ++j) {\n\t\t\tint op = __cigar_op(p->cigar[j]);\n\t\t\tif (op == 0 || op == 2) x += __cigar_len(p->cigar[j]);\n\t\t}\n\t\treturn x;\n\t} else return p->pos + p->len;\n}\n\nint64_t pos_end_multi(const bwt_multi1_t *p, int len) // analogy to pos_end()\n{\n\tif (p->cigar) {\n\t\tint j;\n\t\tint64_t x = p->pos;\n\t\tfor (j = 0; j != p->n_cigar; ++j) {\n\t\t\tint op = __cigar_op(p->cigar[j]);\n\t\t\tif (op == 0 || op == 2) x += __cigar_len(p->cigar[j]);\n\t\t}\n\t\treturn x;\n\t} else return p->pos + len;\n}\n\nstatic int64_t pos_5(const bwa_seq_t *p)\n{\n\tif (p->type != BWA_TYPE_NO_MATCH)\n\t\treturn p->strand? pos_end(p) : p->pos;\n\treturn -1;\n}\n\nvoid bwa_print_seq(FILE *stream, bwa_seq_t *seq) {\n\tchar buffer[4096];\n\tconst int bsz = sizeof(buffer);\n\tint i, j, l;\n\t\n\tif (seq->strand == 0) {\n\t\tfor (i = 0; i < seq->full_len; i += bsz) {\n\t\t\tl = seq->full_len - i > bsz ? bsz : seq->full_len - i;\n\t\t\tfor (j = 0; j < l; j++) buffer[j] = \"ACGTN\"[seq->seq[i + j]];\n\t\t\terr_fwrite(buffer, 1, l, stream);\n\t\t}\n\t} else {\n\t\tfor (i = seq->full_len - 1; i >= 0; i -= bsz) {\n\t\t\tl = i + 1 > bsz ? bsz : i + 1;\n\t\t\tfor (j = 0; j < l; j++) buffer[j] = \"TGCAN\"[seq->seq[i - j]];\n\t\t\terr_fwrite(buffer, 1, l, stream);\n\t\t}\n\t}\n}\n\nvoid bwa_print_sam1(const bntseq_t *bns, bwa_seq_t *p, const bwa_seq_t *mate, int mode, int max_top2)\n{\n\tint j;\n\tif (p->type != BWA_TYPE_NO_MATCH || (mate && mate->type != BWA_TYPE_NO_MATCH)) {\n\t\tint seqid, nn, am = 0, flag = p->extra_flag;\n\t\tchar XT;\n\n\t\tif (p->type == BWA_TYPE_NO_MATCH) {\n\t\t\tp->pos = mate->pos;\n\t\t\tp->strand = mate->strand;\n\t\t\tflag |= SAM_FSU;\n\t\t\tj = 1;\n\t\t} else j = pos_end(p) - p->pos; // j is the length of the reference in the alignment\n\n\t\t// get seqid\n\t\tnn = bns_cnt_ambi(bns, p->pos, j, &seqid);\n\t\tif (p->type != BWA_TYPE_NO_MATCH && p->pos + j - bns->anns[seqid].offset > bns->anns[seqid].len)\n\t\t\tflag |= SAM_FSU; // flag UNMAP as this alignment bridges two adjacent reference sequences\n\n\t\t// update flag and print it\n\t\tif (p->strand) flag |= SAM_FSR;\n\t\tif (mate) {\n\t\t\tif (mate->type != BWA_TYPE_NO_MATCH) {\n\t\t\t\tif (mate->strand) flag |= SAM_FMR;\n\t\t\t} else flag |= SAM_FMU;\n\t\t}\n\t\terr_printf(\"%s\\t%d\\t%s\\t\", p->name, flag, bns->anns[seqid].name);\n\t\terr_printf(\"%d\\t%d\\t\", (int)(p->pos - bns->anns[seqid].offset + 1), p->mapQ);\n\n\t\t// print CIGAR\n\t\tif (p->cigar) {\n\t\t\tfor (j = 0; j != p->n_cigar; ++j)\n\t\t\t\terr_printf(\"%d%c\", __cigar_len(p->cigar[j]), \"MIDS\"[__cigar_op(p->cigar[j])]);\n\t\t} else if (p->type == BWA_TYPE_NO_MATCH) err_printf(\"*\");\n\t\telse err_printf(\"%dM\", p->len);\n\n\t\t// print mate coordinate\n\t\tif (mate && mate->type != BWA_TYPE_NO_MATCH) {\n\t\t\tint m_seqid;\n\t\t\tlong long isize;\n\t\t\tam = mate->seQ < p->seQ? mate->seQ : p->seQ; // smaller single-end mapping quality\n\t\t\t// redundant calculation here, but should not matter too much\n\t\t\tbns_cnt_ambi(bns, mate->pos, mate->len, &m_seqid);\n\t\t\terr_printf(\"\\t%s\\t\", (seqid == m_seqid)? \"=\" : bns->anns[m_seqid].name);\n\t\t\tisize = (seqid == m_seqid)? pos_5(mate) - pos_5(p) : 0;\n\t\t\tif (p->type == BWA_TYPE_NO_MATCH) isize = 0;\n\t\t\terr_printf(\"%d\\t%lld\\t\", (int)(mate->pos - bns->anns[m_seqid].offset + 1), isize);\n\t\t} else if (mate) err_printf(\"\\t=\\t%d\\t0\\t\", (int)(p->pos - bns->anns[seqid].offset + 1));\n\t\telse err_printf(\"\\t*\\t0\\t0\\t\");\n\n\t\t// print sequence and quality\n\t\tbwa_print_seq(stdout, p);\n\t\terr_putchar('\\t');\n\t\tif (p->qual) {\n\t\t\tif (p->strand) seq_reverse(p->len, p->qual, 0); // reverse quality\n\t\t\terr_printf(\"%s\", p->qual);\n\t\t} else err_printf(\"*\");\n\n\t\tif (bwa_rg_id[0]) err_printf(\"\\tRG:Z:%s\", bwa_rg_id);\n\t\tif (p->bc[0]) err_printf(\"\\tBC:Z:%s\", p->bc);\n\t\tif (p->clip_len < p->full_len) err_printf(\"\\tXC:i:%d\", p->clip_len);\n\t\tif (p->type != BWA_TYPE_NO_MATCH) {\n\t\t\tint i;\n\t\t\t// calculate XT tag\n\t\t\tXT = \"NURM\"[p->type];\n\t\t\tif (nn > 10) XT = 'N';\n\t\t\t// print tags\n\t\t\terr_printf(\"\\tXT:A:%c\\t%s:i:%d\", XT, (mode & BWA_MODE_COMPREAD)? \"NM\" : \"CM\", p->nm);\n\t\t\tif (nn) err_printf(\"\\tXN:i:%d\", nn);\n\t\t\tif (mate) err_printf(\"\\tSM:i:%d\\tAM:i:%d\", p->seQ, am);\n\t\t\tif (p->type != BWA_TYPE_MATESW) { // X0 and X1 are not available for this type of alignment\n\t\t\t\terr_printf(\"\\tX0:i:%d\", p->c1);\n\t\t\t\tif (p->c1 <= max_top2) err_printf(\"\\tX1:i:%d\", p->c2);\n\t\t\t}\n\t\t\terr_printf(\"\\tXM:i:%d\\tXO:i:%d\\tXG:i:%d\", p->n_mm, p->n_gapo, p->n_gapo+p->n_gape);\n\t\t\tif (p->md) err_printf(\"\\tMD:Z:%s\", p->md);\n\t\t\t// print multiple hits\n\t\t\tif (p->n_multi) {\n\t\t\t\terr_printf(\"\\tXA:Z:\");\n\t\t\t\tfor (i = 0; i < p->n_multi; ++i) {\n\t\t\t\t\tbwt_multi1_t *q = p->multi + i;\n\t\t\t\t\tint k;\n\t\t\t\t\tj = pos_end_multi(q, p->len) - q->pos;\n\t\t\t\t\tnn = bns_cnt_ambi(bns, q->pos, j, &seqid);\n\t\t\t\t\terr_printf(\"%s,%c%d,\", bns->anns[seqid].name, q->strand? '-' : '+',\n\t\t\t\t\t\t   (int)(q->pos - bns->anns[seqid].offset + 1));\n\t\t\t\t\tif (q->cigar) {\n\t\t\t\t\t\tfor (k = 0; k < q->n_cigar; ++k)\n\t\t\t\t\t\t\terr_printf(\"%d%c\", __cigar_len(q->cigar[k]), \"MIDS\"[__cigar_op(q->cigar[k])]);\n\t\t\t\t\t} else err_printf(\"%dM\", p->len);\n\t\t\t\t\terr_printf(\",%d;\", q->gap + q->mm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr_putchar('\\n');\n\t} else { // this read has no match\n\t\t//ubyte_t *s = p->strand? p->rseq : p->seq;\n\t\tint flag = p->extra_flag | SAM_FSU;\n\t\tif (mate && mate->type == BWA_TYPE_NO_MATCH) flag |= SAM_FMU;\n\t\terr_printf(\"%s\\t%d\\t*\\t0\\t0\\t*\\t*\\t0\\t0\\t\", p->name, flag);\n\t\t//Why did this work differently to the version above??\n\t\t//for (j = 0; j != p->len; ++j) putchar(\"ACGTN\"[(int)s[j]]);\n\t\tbwa_print_seq(stdout, p);\n\t\terr_putchar('\\t');\n\t\tif (p->qual) {\n\t\t\tif (p->strand) seq_reverse(p->len, p->qual, 0); // reverse quality\n\t\t\terr_printf(\"%s\", p->qual);\n\t\t} else err_printf(\"*\");\n\t\tif (bwa_rg_id[0]) err_printf(\"\\tRG:Z:%s\", bwa_rg_id);\n\t\tif (p->bc[0]) err_printf(\"\\tBC:Z:%s\", p->bc);\n\t\tif (p->clip_len < p->full_len) err_printf(\"\\tXC:i:%d\", p->clip_len);\n\t\terr_putchar('\\n');\n\t}\n}\n\nvoid bwase_initialize() \n{\n\tint i;\n\tfor (i = 1; i != 256; ++i) g_log_n[i] = (int)(4.343 * log(i) + 0.5);\n}\n\nvoid bwa_sai2sam_se_core(const char *prefix, const char *fn_sa, const char *fn_fa, int n_occ, const char *rg_line)\n{\n\textern bwa_seqio_t *bwa_open_reads(int mode, const char *fn_fa);\n\tint i, n_seqs, m_aln;\n\tlong long tot_seqs = 0;\n\tbwt_aln1_t *aln = 0;\n\tbwa_seq_t *seqs;\n\tbwa_seqio_t *ks;\n\tclock_t t;\n\tbntseq_t *bns;\n\tFILE *fp_sa;\n\tgap_opt_t opt;\n\tchar magic[4];\n\n\t// initialization\n\tbwase_initialize();\n\tbns = bns_restore(prefix);\n\tsrand48(bns->seed);\n\tfp_sa = xopen(fn_sa, \"r\");\n\n\tm_aln = 0;\n\terr_fread_noeof(magic, 1, 4, fp_sa);\n\tif (strncmp(magic, SAI_MAGIC, 4) != 0) {\n\t\tfprintf(stderr, \"[E::%s] Unmatched SAI magic. Please re-run `aln' with the same version of bwa.\\n\", __func__);\n\t\texit(1);\n\t}\n\terr_fread_noeof(&opt, sizeof(gap_opt_t), 1, fp_sa);\n\tbwa_print_sam_hdr(bns, rg_line);\n\t// set ks\n\tks = bwa_open_reads(opt.mode, fn_fa);\n\t// core loop\n\twhile ((seqs = bwa_read_seq(ks, 0x40000, &n_seqs, opt.mode, opt.trim_qual)) != 0) {\n\t\ttot_seqs += n_seqs;\n\t\tt = clock();\n\n\t\t// read alignment\n\t\tfor (i = 0; i < n_seqs; ++i) {\n\t\t\tbwa_seq_t *p = seqs + i;\n\t\t\tint n_aln;\n\t\t\terr_fread_noeof(&n_aln, 4, 1, fp_sa);\n\t\t\tif (n_aln > m_aln) {\n\t\t\t\tm_aln = n_aln;\n\t\t\t\taln = (bwt_aln1_t*)realloc(aln, sizeof(bwt_aln1_t) * m_aln);\n\t\t\t}\n\t\t\terr_fread_noeof(aln, sizeof(bwt_aln1_t), n_aln, fp_sa);\n\t\t\tbwa_aln2seq_core(n_aln, aln, p, 1, n_occ);\n\t\t}\n\n\t\tfprintf(stderr, \"[bwa_aln_core] convert to sequence coordinate... \");\n\t\tbwa_cal_pac_pos(bns, prefix, n_seqs, seqs, opt.max_diff, opt.fnr); // forward bwt will be destroyed here\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\n\t\tfprintf(stderr, \"[bwa_aln_core] refine gapped alignments... \");\n\t\tbwa_refine_gapped(bns, n_seqs, seqs, 0);\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC); t = clock();\n\n\t\tfprintf(stderr, \"[bwa_aln_core] print alignments... \");\n\t\tfor (i = 0; i < n_seqs; ++i)\n\t\t\tbwa_print_sam1(bns, seqs + i, 0, opt.mode, opt.max_top2);\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\n\t\tbwa_free_read_seq(n_seqs, seqs);\n\t\tfprintf(stderr, \"[bwa_aln_core] %lld sequences have been processed.\\n\", tot_seqs);\n\t}\n\n\t// destroy\n\tbwa_seq_close(ks);\n\tbns_destroy(bns);\n\terr_fclose(fp_sa);\n\tfree(aln);\n}\n\nint bwa_sai2sam_se(int argc, char *argv[])\n{\n\tint c, n_occ = 3;\n\tchar *prefix, *rg_line = 0;\n\twhile ((c = getopt(argc, argv, \"hn:f:r:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'h': break;\n\t\tcase 'r':\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1;\n\t\t\tbreak;\n\t\tcase 'n': n_occ = atoi(optarg); break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\n\tif (optind + 3 > argc) {\n\t\tfprintf(stderr, \"Usage: bwa samse [-n max_occ] [-f out.sam] [-r RG_line] <prefix> <in.sai> <in.fq>\\n\");\n\t\treturn 1;\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\treturn 1;\n\t}\n\tbwa_sai2sam_se_core(prefix, argv[optind+1], argv[optind+2], n_occ, rg_line);\n\tfree(prefix);\n\treturn 0;\n}\n"
        },
        {
          "name": "bwase.h",
          "type": "blob",
          "size": 1.0087890625,
          "content": "#ifndef BWASE_H\n#define BWASE_H\n\n#include \"bntseq.h\"\n#include \"bwt.h\"\n#include \"bwtaln.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t// Initialize mapping tables in the bwa single-end mapper.\n\tvoid bwase_initialize();\n\t// Calculate the approximate position of the sequence from the specified bwt with loaded suffix array.\n\tvoid bwa_cal_pac_pos_core(const bntseq_t *bns, const bwt_t* bwt, bwa_seq_t* seq, const int max_mm, const float fnr);\n\t// Refine the approximate position of the sequence to an actual placement for the sequence.\n\tvoid bwa_refine_gapped(const bntseq_t *bns, int n_seqs, bwa_seq_t *seqs, ubyte_t *_pacseq);\n\t// Backfill certain alignment properties mainly centering around number of matches.\n\tvoid bwa_aln2seq(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s);\n\t// Calculate the end position of a read given a certain sequence.\n\tint64_t pos_end(const bwa_seq_t *p);\n\t//\n\tbwtint_t bwa_sa2pos(const bntseq_t *bns, const bwt_t *bwt, bwtint_t sapos, int len, int *strand);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // BWASE_H\n"
        },
        {
          "name": "bwaseqio.c",
          "type": "blob",
          "size": 6.70703125,
          "content": "#include <zlib.h>\n#include <ctype.h>\n#include \"bwtaln.h\"\n#include \"utils.h\"\n#include \"bamlite.h\"\n\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nextern unsigned char nst_nt4_table[256];\nstatic char bam_nt16_nt4_table[] = { 4, 0, 1, 4, 2, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4 };\n\nstruct __bwa_seqio_t {\n\t// for BAM input\n\tint is_bam, which; // 1st bit: read1, 2nd bit: read2, 3rd: SE\n\tbamFile fp;\n\t// for fastq input\n\tkseq_t *ks;\n};\n\nbwa_seqio_t *bwa_bam_open(const char *fn, int which)\n{\n\tbwa_seqio_t *bs;\n\tbam_header_t *h;\n\tbs = (bwa_seqio_t*)calloc(1, sizeof(bwa_seqio_t));\n\tbs->is_bam = 1;\n\tbs->which = which;\n\tbs->fp = bam_open(fn, \"r\");\n\tif (0 == bs->fp) err_fatal_simple(\"Couldn't open bam file\");\n\th = bam_header_read(bs->fp);\n\tbam_header_destroy(h);\n\treturn bs;\n}\n\nbwa_seqio_t *bwa_seq_open(const char *fn)\n{\n\tgzFile fp;\n\tbwa_seqio_t *bs;\n\tbs = (bwa_seqio_t*)calloc(1, sizeof(bwa_seqio_t));\n\tfp = xzopen(fn, \"r\");\n\tbs->ks = kseq_init(fp);\n\treturn bs;\n}\n\nvoid bwa_seq_close(bwa_seqio_t *bs)\n{\n\tif (bs == 0) return;\n\tif (bs->is_bam) {\n\t\tif (0 != bam_close(bs->fp)) err_fatal_simple(\"Error closing bam file\");\n\t} else {\n\t\terr_gzclose(bs->ks->f->f);\n\t\tkseq_destroy(bs->ks);\n\t}\n\tfree(bs);\n}\n\nvoid seq_reverse(int len, ubyte_t *seq, int is_comp)\n{\n\tint i;\n\tif (is_comp) {\n\t\tfor (i = 0; i < len>>1; ++i) {\n\t\t\tchar tmp = seq[len-1-i];\n\t\t\tif (tmp < 4) tmp = 3 - tmp;\n\t\t\tseq[len-1-i] = (seq[i] >= 4)? seq[i] : 3 - seq[i];\n\t\t\tseq[i] = tmp;\n\t\t}\n\t\tif (len&1) seq[i] = (seq[i] >= 4)? seq[i] : 3 - seq[i];\n\t} else {\n\t\tfor (i = 0; i < len>>1; ++i) {\n\t\t\tchar tmp = seq[len-1-i];\n\t\t\tseq[len-1-i] = seq[i]; seq[i] = tmp;\n\t\t}\n\t}\n}\n\nint bwa_trim_read(int trim_qual, bwa_seq_t *p)\n{\n\tint s = 0, l, max = 0, max_l = p->len;\n\tif (trim_qual < 1 || p->qual == 0) return 0;\n\tfor (l = p->len - 1; l >= BWA_MIN_RDLEN; --l) {\n\t\ts += trim_qual - (p->qual[l] - 33);\n\t\tif (s < 0) break;\n\t\tif (s > max) max = s, max_l = l;\n\t}\n\tp->clip_len = p->len = max_l;\n\treturn p->full_len - p->len;\n}\n\nstatic bwa_seq_t *bwa_read_bam(bwa_seqio_t *bs, int n_needed, int *n, int is_comp, int trim_qual)\n{\n\tbwa_seq_t *seqs, *p;\n\tint n_seqs, l, i;\n\tlong n_trimmed = 0, n_tot = 0;\n\tbam1_t *b;\n\tint res;\n\n\tb = bam_init1();\n\tn_seqs = 0;\n\tseqs = (bwa_seq_t*)calloc(n_needed, sizeof(bwa_seq_t));\n\twhile ((res = bam_read1(bs->fp, b)) >= 0) {\n\t\tuint8_t *s, *q;\n\t\tint go = 0;\n\t\tif ((bs->which & 1) && (b->core.flag & BAM_FREAD1)) go = 1;\n\t\tif ((bs->which & 2) && (b->core.flag & BAM_FREAD2)) go = 1;\n\t\tif ((bs->which & 4) && !(b->core.flag& BAM_FREAD1) && !(b->core.flag& BAM_FREAD2))go = 1;\n\t\tif (go == 0) continue;\n\t\tl = b->core.l_qseq;\n\t\tp = &seqs[n_seqs++];\n\t\tp->tid = -1; // no assigned to a thread\n\t\tp->qual = 0;\n\t\tp->full_len = p->clip_len = p->len = l;\n\t\tn_tot += p->full_len;\n\t\ts = bam1_seq(b); q = bam1_qual(b);\n\t\tp->seq = (ubyte_t*)calloc(p->len + 1, 1);\n\t\tp->qual = (ubyte_t*)calloc(p->len + 1, 1);\n\t\tfor (i = 0; i != p->full_len; ++i) {\n\t\t\tp->seq[i] = bam_nt16_nt4_table[(int)bam1_seqi(s, i)];\n\t\t\tp->qual[i] = q[i] + 33 < 126? q[i] + 33 : 126;\n\t\t}\n\t\tif (bam1_strand(b)) { // then reverse \n\t\t\tseq_reverse(p->len, p->seq, 1);\n\t\t\tseq_reverse(p->len, p->qual, 0);\n\t\t}\n\t\tif (trim_qual >= 1) n_trimmed += bwa_trim_read(trim_qual, p);\n\t\tp->rseq = (ubyte_t*)calloc(p->full_len, 1);\n\t\tmemcpy(p->rseq, p->seq, p->len);\n\t\tseq_reverse(p->len, p->seq, 0); // *IMPORTANT*: will be reversed back in bwa_refine_gapped()\n\t\tseq_reverse(p->len, p->rseq, is_comp);\n\t\tp->name = strdup((const char*)bam1_qname(b));\n\t\tif (n_seqs == n_needed) break;\n\t}\n\tif (res < 0 && res != -1) err_fatal_simple(\"Error reading bam file\");\n\t*n = n_seqs;\n\tif (n_seqs && trim_qual >= 1)\n\t\tfprintf(stderr, \"[bwa_read_seq] %.1f%% bases are trimmed.\\n\", 100.0f * n_trimmed/n_tot);\n\tif (n_seqs == 0) {\n\t\tfree(seqs);\n\t\tbam_destroy1(b);\n\t\treturn 0;\n\t}\n\tbam_destroy1(b);\n\treturn seqs;\n}\n\n#define BARCODE_LOW_QUAL 13\n\nbwa_seq_t *bwa_read_seq(bwa_seqio_t *bs, int n_needed, int *n, int mode, int trim_qual)\n{\n\tbwa_seq_t *seqs, *p;\n\tkseq_t *seq = bs->ks;\n\tint n_seqs, l, i, is_comp = mode&BWA_MODE_COMPREAD, is_64 = mode&BWA_MODE_IL13, l_bc = mode>>24;\n\tlong n_trimmed = 0, n_tot = 0;\n\n\tif (l_bc > BWA_MAX_BCLEN) {\n\t\tfprintf(stderr, \"[%s] the maximum barcode length is %d.\\n\", __func__, BWA_MAX_BCLEN);\n\t\treturn 0;\n\t}\n\tif (bs->is_bam) return bwa_read_bam(bs, n_needed, n, is_comp, trim_qual); // l_bc has no effect for BAM input\n\tn_seqs = 0;\n\tseqs = (bwa_seq_t*)calloc(n_needed, sizeof(bwa_seq_t));\n\twhile ((l = kseq_read(seq)) >= 0) {\n\t\tif ((mode & BWA_MODE_CFY) && (seq->comment.l != 0)) {\n\t\t\t// skip reads that are marked to be filtered by Casava\n\t\t\tchar *s = index(seq->comment.s, ':');\n\t\t\tif (s && *(++s) == 'Y') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (is_64 && seq->qual.l)\n\t\t\tfor (i = 0; i < seq->qual.l; ++i) seq->qual.s[i] -= 31;\n\t\tif (seq->seq.l <= l_bc) continue; // sequence length equals or smaller than the barcode length\n\t\tp = &seqs[n_seqs++];\n\t\tif (l_bc) { // then trim barcode\n\t\t\tfor (i = 0; i < l_bc; ++i)\n\t\t\t\tp->bc[i] = (seq->qual.l && seq->qual.s[i]-33 < BARCODE_LOW_QUAL)? tolower(seq->seq.s[i]) : toupper(seq->seq.s[i]);\n\t\t\tp->bc[i] = 0;\n\t\t\tfor (; i < seq->seq.l; ++i)\n\t\t\t\tseq->seq.s[i - l_bc] = seq->seq.s[i];\n\t\t\tseq->seq.l -= l_bc; seq->seq.s[seq->seq.l] = 0;\n\t\t\tif (seq->qual.l) {\n\t\t\t\tfor (i = l_bc; i < seq->qual.l; ++i)\n\t\t\t\t\tseq->qual.s[i - l_bc] = seq->qual.s[i];\n\t\t\t\tseq->qual.l -= l_bc; seq->qual.s[seq->qual.l] = 0;\n\t\t\t}\n\t\t\tl = seq->seq.l;\n\t\t} else p->bc[0] = 0;\n\t\tp->tid = -1; // no assigned to a thread\n\t\tp->qual = 0;\n\t\tp->full_len = p->clip_len = p->len = l;\n\t\tn_tot += p->full_len;\n\t\tp->seq = (ubyte_t*)calloc(p->full_len, 1);\n\t\tfor (i = 0; i != p->full_len; ++i)\n\t\t\tp->seq[i] = nst_nt4_table[(int)seq->seq.s[i]];\n\t\tif (seq->qual.l) { // copy quality\n\t\t\tp->qual = (ubyte_t*)strdup((char*)seq->qual.s);\n\t\t\tif (trim_qual >= 1) n_trimmed += bwa_trim_read(trim_qual, p);\n\t\t}\n\t\tp->rseq = (ubyte_t*)calloc(p->full_len, 1);\n\t\tmemcpy(p->rseq, p->seq, p->len);\n\t\tseq_reverse(p->len, p->seq, 0); // *IMPORTANT*: will be reversed back in bwa_refine_gapped()\n\t\tseq_reverse(p->len, p->rseq, is_comp);\n\t\tp->name = strdup((const char*)seq->name.s);\n\t\t{ // trim /[12]$\n\t\t\tint t = strlen(p->name);\n\t\t\tif (t > 2 && p->name[t-2] == '/' && (p->name[t-1] == '1' || p->name[t-1] == '2')) p->name[t-2] = '\\0';\n\t\t}\n\t\tif (n_seqs == n_needed) break;\n\t}\n\t*n = n_seqs;\n\tif (n_seqs && trim_qual >= 1)\n\t\tfprintf(stderr, \"[bwa_read_seq] %.1f%% bases are trimmed.\\n\", 100.0f * n_trimmed/n_tot);\n\tif (n_seqs == 0) {\n\t\tfree(seqs);\n\t\treturn 0;\n\t}\n\treturn seqs;\n}\n\nvoid bwa_free_read_seq(int n_seqs, bwa_seq_t *seqs)\n{\n\tint i, j;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = seqs + i;\n\t\tfor (j = 0; j < p->n_multi; ++j)\n\t\t\tif (p->multi[j].cigar) free(p->multi[j].cigar);\n\t\tfree(p->name);\n\t\tfree(p->seq); free(p->rseq); free(p->qual); free(p->aln); free(p->md); free(p->multi);\n\t\tfree(p->cigar);\n\t}\n\tfree(seqs);\n}\n"
        },
        {
          "name": "bwashm.c",
          "type": "blob",
          "size": 5.6796875,
          "content": "#include <sys/types.h>\n#include <sys/mman.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"bwa.h\"\n\nint bwa_shm_stage(bwaidx_t *idx, const char *hint, const char *_tmpfn)\n{\n\tconst char *name;\n\tuint8_t *shm, *shm_idx;\n\tuint16_t *cnt;\n\tint shmid, to_init = 0, l;\n\tchar path[PATH_MAX + 1], *tmpfn = (char*)_tmpfn;\n\n\tif (hint == 0 || hint[0] == 0) return -1;\n\tfor (name = hint + strlen(hint) - 1; name >= hint && *name != '/'; --name);\n\t++name;\n\n\tif ((shmid = shm_open(\"/bwactl\", O_RDWR, 0)) < 0) {\n\t\tshmid = shm_open(\"/bwactl\", O_CREAT|O_RDWR|O_EXCL, 0644);\n\t\tto_init = 1;\n\t}\n\tif (shmid < 0) return -1;\n\tftruncate(shmid, BWA_CTL_SIZE);\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tif (to_init) {\n\t\tmemset(shm, 0, BWA_CTL_SIZE);\n\t\tcnt[1] = 4;\n\t}\n\n\tif (idx->mem == 0) bwa_idx2mem(idx);\n\n\tif (tmpfn) {\n\t\tFILE *fp;\n\t\tif ((fp = fopen(tmpfn, \"wb\")) != 0) {\n\t\t\tint64_t rest = idx->l_mem;\n\t\t\twhile (rest > 0) {\n\t\t\t\tint64_t l = rest < 0x1000000? rest : 0x1000000;\n\t\t\t\trest -= fwrite(&idx->mem[idx->l_mem - rest], 1, l, fp);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tfree(idx->mem); idx->mem = 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"[W::%s] fail to create the temporary file. Option '-f' is ignored.\\n\", __func__);\n\t\t\ttmpfn = 0;\n\t\t}\n\t}\n\n\tstrcat(strcpy(path, \"/bwaidx-\"), name);\n\tif ((shmid = shm_open(path, O_CREAT|O_RDWR|O_EXCL, 0644)) < 0) {\n\t\tshm_unlink(path);\n\t\tperror(\"shm_open()\");\n\t\treturn -1;\n\t}\n\tl = 8 + strlen(name) + 1;\n\tif (cnt[1] + l > BWA_CTL_SIZE) return -1;\n\tmemcpy(shm + cnt[1], &idx->l_mem, 8);\n\tmemcpy(shm + cnt[1] + 8, name, l - 8);\n\tcnt[1] += l; ++cnt[0];\n\tftruncate(shmid, idx->l_mem);\n\tshm_idx = mmap(0, idx->l_mem, PROT_READ|PROT_WRITE, MAP_SHARED, shmid, 0);\n\tif (tmpfn) {\n\t\tFILE *fp;\n\t\tfp = fopen(tmpfn, \"rb\");\n\t\tint64_t rest = idx->l_mem;\n\t\twhile (rest > 0) {\n\t\t\tint64_t l = rest < 0x1000000? rest : 0x1000000;\n\t\t\trest -= fread(&shm_idx[idx->l_mem - rest], 1, l, fp);\n\t\t}\n\t\tfclose(fp);\n\t\tunlink(tmpfn);\n\t} else {\n\t\tmemcpy(shm_idx, idx->mem, idx->l_mem);\n\t\tfree(idx->mem);\n\t}\n\tbwa_mem2idx(idx->l_mem, shm_idx, idx);\n\tidx->is_shm = 1;\n\treturn 0;\n}\n\nbwaidx_t *bwa_idx_load_from_shm(const char *hint)\n{\n\tconst char *name;\n\tuint8_t *shm, *shm_idx;\n\tuint16_t *cnt, i;\n\tchar *p, path[PATH_MAX + 1];\n\tint shmid;\n\tint64_t l_mem;\n\tbwaidx_t *idx;\n\n\tif (hint == 0 || hint[0] == 0) return 0;\n\tfor (name = hint + strlen(hint) - 1; name >= hint && *name != '/'; --name);\n\t++name;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return 0;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tif (cnt[0] == 0) return 0;\n\tfor (i = 0, p = (char*)(shm + 4); i < cnt[0]; ++i) {\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tif (strcmp(p, name) == 0) break;\n\t\tp += strlen(p) + 1;\n\t}\n\tif (i == cnt[0]) return 0;\n\n\tstrcat(strcpy(path, \"/bwaidx-\"), name);\n\tif ((shmid = shm_open(path, O_RDONLY, 0)) < 0) return 0;\n\tshm_idx = mmap(0, l_mem, PROT_READ, MAP_SHARED, shmid, 0);\n\tidx = calloc(1, sizeof(bwaidx_t));\n\tbwa_mem2idx(l_mem, shm_idx, idx);\n\tidx->is_shm = 1;\n\treturn idx;\n}\n\nint bwa_shm_test(const char *hint)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tconst char *name;\n\n\tif (hint == 0 || hint[0] == 0) return 0;\n\tfor (name = hint + strlen(hint) - 1; name >= hint && *name != '/'; --name);\n\t++name;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return 0;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tif (strcmp(p + 8, name) == 0) return 1;\n\t\tp += strlen(p) + 9;\n\t}\n\treturn 0;\n}\n\nint bwa_shm_list(void)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return -1;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tint64_t l_mem;\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tprintf(\"%s\\t%ld\\n\", p, (long)l_mem);\n\t\tp += strlen(p) + 1;\n\t}\n\treturn 0;\n}\n\nint bwa_shm_destroy(void)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tchar path[PATH_MAX + 1];\n\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return -1;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tint64_t l_mem;\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tstrcat(strcpy(path, \"/bwaidx-\"), p);\n\t\tshm_unlink(path);\n\t\tp += strlen(p) + 1;\n\t}\n\tmunmap(shm, BWA_CTL_SIZE);\n\tshm_unlink(\"/bwactl\");\n\treturn 0;\n}\n\nint main_shm(int argc, char *argv[])\n{\n\tint c, to_list = 0, to_drop = 0, ret = 0;\n\tchar *tmpfn = 0;\n\twhile ((c = getopt(argc, argv, \"ldf:\")) >= 0) {\n\t\tif (c == 'l') to_list = 1;\n\t\telse if (c == 'd') to_drop = 1;\n\t\telse if (c == 'f') tmpfn = optarg;\n\t}\n\tif (optind == argc && !to_list && !to_drop) {\n\t\tfprintf(stderr, \"\\nUsage: bwa shm [-d|-l] [-f tmpFile] [idxbase]\\n\\n\");\n\t\tfprintf(stderr, \"Options: -d       destroy all indices in shared memory\\n\");\n\t\tfprintf(stderr, \"         -l       list names of indices in shared memory\\n\");\n\t\tfprintf(stderr, \"         -f FILE  temporary file to reduce peak memory\\n\\n\");\n\t\treturn 1;\n\t}\n\tif (optind < argc && (to_list || to_drop)) {\n\t\tfprintf(stderr, \"[E::%s] open -l or -d cannot be used when 'idxbase' is present\\n\", __func__);\n\t\treturn 1;\n\t}\n\tif (optind < argc) {\n\t\tif (bwa_shm_test(argv[optind]) == 0) {\n\t\t\tbwaidx_t *idx;\n\t\t\tidx = bwa_idx_load_from_disk(argv[optind], BWA_IDX_ALL);\n\t\t\tif (bwa_shm_stage(idx, argv[optind], tmpfn) < 0) {\n\t\t\t\tfprintf(stderr, \"[E::%s] failed to stage the index in shared memory\\n\", __func__);\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tbwa_idx_destroy(idx);\n\t\t} else fprintf(stderr, \"[M::%s] index '%s' is already in shared memory\\n\", __func__, argv[optind]);\n\t}\n\tif (to_list) bwa_shm_list();\n\tif (to_drop) bwa_shm_destroy();\n\treturn ret;\n}\n"
        },
        {
          "name": "bwt.c",
          "type": "blob",
          "size": 14.982421875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008 Genome Research Ltd (GRL).\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Contact: Heng Li <lh3@sanger.ac.uk> */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdint.h>\n#include <limits.h>\n#include \"utils.h\"\n#include \"bwt.h\"\n#include \"kvec.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nvoid bwt_gen_cnt_table(bwt_t *bwt)\n{\n\tint i, j;\n\tfor (i = 0; i != 256; ++i) {\n\t\tuint32_t x = 0;\n\t\tfor (j = 0; j != 4; ++j)\n\t\t\tx |= (((i&3) == j) + ((i>>2&3) == j) + ((i>>4&3) == j) + (i>>6 == j)) << (j<<3);\n\t\tbwt->cnt_table[i] = x;\n\t}\n}\n\nstatic inline bwtint_t bwt_invPsi(const bwt_t *bwt, bwtint_t k) // compute inverse CSA\n{\n\tbwtint_t x = k - (k > bwt->primary);\n\tx = bwt_B0(bwt, x);\n\tx = bwt->L2[x] + bwt_occ(bwt, k, x);\n\treturn k == bwt->primary? 0 : x;\n}\n\n// bwt->bwt and bwt->occ must be precalculated\nvoid bwt_cal_sa(bwt_t *bwt, int intv)\n{\n\tbwtint_t isa, sa, i; // S(isa) = sa\n\tint intv_round = intv;\n\n\tkv_roundup32(intv_round);\n\txassert(intv_round == intv, \"SA sample interval is not a power of 2.\");\n\txassert(bwt->bwt, \"bwt_t::bwt is not initialized.\");\n\n\tif (bwt->sa) free(bwt->sa);\n\tbwt->sa_intv = intv;\n\tbwt->n_sa = (bwt->seq_len + intv) / intv;\n\tbwt->sa = (bwtint_t*)calloc(bwt->n_sa, sizeof(bwtint_t));\n\t// calculate SA value\n\tisa = 0; sa = bwt->seq_len;\n\tfor (i = 0; i < bwt->seq_len; ++i) {\n\t\tif (isa % intv == 0) bwt->sa[isa/intv] = sa;\n\t\t--sa;\n\t\tisa = bwt_invPsi(bwt, isa);\n\t}\n\tif (isa % intv == 0) bwt->sa[isa/intv] = sa;\n\tbwt->sa[0] = (bwtint_t)-1; // before this line, bwt->sa[0] = bwt->seq_len\n}\n\nbwtint_t bwt_sa(const bwt_t *bwt, bwtint_t k)\n{\n\tbwtint_t sa = 0, mask = bwt->sa_intv - 1;\n\twhile (k & mask) {\n\t\t++sa;\n\t\tk = bwt_invPsi(bwt, k);\n\t}\n\t/* without setting bwt->sa[0] = -1, the following line should be\n\t   changed to (sa + bwt->sa[k/bwt->sa_intv]) % (bwt->seq_len + 1) */\n\treturn sa + bwt->sa[k/bwt->sa_intv];\n}\n\nstatic inline int __occ_aux(uint64_t y, int c)\n{\n\t// reduce nucleotide counting to bits counting\n\ty = ((c&2)? y : ~y) >> 1 & ((c&1)? y : ~y) & 0x5555555555555555ull;\n\t// count the number of 1s in y\n\ty = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);\n\treturn ((y + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;\n}\n\nbwtint_t bwt_occ(const bwt_t *bwt, bwtint_t k, ubyte_t c)\n{\n\tbwtint_t n;\n\tuint32_t *p, *end;\n\n\tif (k == bwt->seq_len) return bwt->L2[c+1] - bwt->L2[c];\n\tif (k == (bwtint_t)(-1)) return 0;\n\tk -= (k >= bwt->primary); // because $ is not in bwt\n\n\t// retrieve Occ at k/OCC_INTERVAL\n\tn = ((bwtint_t*)(p = bwt_occ_intv(bwt, k)))[c];\n\tp += sizeof(bwtint_t); // jump to the start of the first BWT cell\n\n\t// calculate Occ up to the last k/32\n\tend = p + (((k>>5) - ((k&~OCC_INTV_MASK)>>5))<<1);\n\tfor (; p < end; p += 2) n += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\n\t// calculate Occ\n\tn += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~k&31)<<1)) - 1), c);\n\tif (c == 0) n -= ~k&31; // corrected for the masked bits\n\n\treturn n;\n}\n\n// an analogy to bwt_occ() but more efficient, requiring k <= l\nvoid bwt_2occ(const bwt_t *bwt, bwtint_t k, bwtint_t l, ubyte_t c, bwtint_t *ok, bwtint_t *ol)\n{\n\tbwtint_t _k, _l;\n\t_k = (k >= bwt->primary)? k-1 : k;\n\t_l = (l >= bwt->primary)? l-1 : l;\n\tif (_l/OCC_INTERVAL != _k/OCC_INTERVAL || k == (bwtint_t)(-1) || l == (bwtint_t)(-1)) {\n\t\t*ok = bwt_occ(bwt, k, c);\n\t\t*ol = bwt_occ(bwt, l, c);\n\t} else {\n\t\tbwtint_t m, n, i, j;\n\t\tuint32_t *p;\n\t\tif (k >= bwt->primary) --k;\n\t\tif (l >= bwt->primary) --l;\n\t\tn = ((bwtint_t*)(p = bwt_occ_intv(bwt, k)))[c];\n\t\tp += sizeof(bwtint_t);\n\t\t// calculate *ok\n\t\tj = k >> 5 << 5;\n\t\tfor (i = k/OCC_INTERVAL*OCC_INTERVAL; i < j; i += 32, p += 2)\n\t\t\tn += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\t\tm = n;\n\t\tn += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~k&31)<<1)) - 1), c);\n\t\tif (c == 0) n -= ~k&31; // corrected for the masked bits\n\t\t*ok = n;\n\t\t// calculate *ol\n\t\tj = l >> 5 << 5;\n\t\tfor (; i < j; i += 32, p += 2)\n\t\t\tm += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\t\tm += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~l&31)<<1)) - 1), c);\n\t\tif (c == 0) m -= ~l&31; // corrected for the masked bits\n\t\t*ol = m;\n\t}\n}\n\n#define __occ_aux4(bwt, b)\t\t\t\t\t\t\t\t\t\t\t\\\n\t((bwt)->cnt_table[(b)&0xff] + (bwt)->cnt_table[(b)>>8&0xff]\t\t\\\n\t + (bwt)->cnt_table[(b)>>16&0xff] + (bwt)->cnt_table[(b)>>24])\n\nvoid bwt_occ4(const bwt_t *bwt, bwtint_t k, bwtint_t cnt[4])\n{\n\tbwtint_t x;\n\tuint32_t *p, tmp, *end;\n\tif (k == (bwtint_t)(-1)) {\n\t\tmemset(cnt, 0, 4 * sizeof(bwtint_t));\n\t\treturn;\n\t}\n\tk -= (k >= bwt->primary); // because $ is not in bwt\n\tp = bwt_occ_intv(bwt, k);\n\tmemcpy(cnt, p, 4 * sizeof(bwtint_t));\n\tp += sizeof(bwtint_t); // sizeof(bwtint_t) = 4*(sizeof(bwtint_t)/sizeof(uint32_t))\n\tend = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4)); // this is the end point of the following loop\n\tfor (x = 0; p < end; ++p) x += __occ_aux4(bwt, *p);\n\ttmp = *p & ~((1U<<((~k&15)<<1)) - 1);\n\tx += __occ_aux4(bwt, tmp) - (~k&15);\n\tcnt[0] += x&0xff; cnt[1] += x>>8&0xff; cnt[2] += x>>16&0xff; cnt[3] += x>>24;\n}\n\n// an analogy to bwt_occ4() but more efficient, requiring k <= l\nvoid bwt_2occ4(const bwt_t *bwt, bwtint_t k, bwtint_t l, bwtint_t cntk[4], bwtint_t cntl[4])\n{\n\tbwtint_t _k, _l;\n\t_k = k - (k >= bwt->primary);\n\t_l = l - (l >= bwt->primary);\n\tif (_l>>OCC_INTV_SHIFT != _k>>OCC_INTV_SHIFT || k == (bwtint_t)(-1) || l == (bwtint_t)(-1)) {\n\t\tbwt_occ4(bwt, k, cntk);\n\t\tbwt_occ4(bwt, l, cntl);\n\t} else {\n\t\tbwtint_t x, y;\n\t\tuint32_t *p, tmp, *endk, *endl;\n\t\tk -= (k >= bwt->primary); // because $ is not in bwt\n\t\tl -= (l >= bwt->primary);\n\t\tp = bwt_occ_intv(bwt, k);\n\t\tmemcpy(cntk, p, 4 * sizeof(bwtint_t));\n\t\tp += sizeof(bwtint_t); // sizeof(bwtint_t) = 4*(sizeof(bwtint_t)/sizeof(uint32_t))\n\t\t// prepare cntk[]\n\t\tendk = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4));\n\t\tendl = p + ((l>>4) - ((l&~OCC_INTV_MASK)>>4));\n\t\tfor (x = 0; p < endk; ++p) x += __occ_aux4(bwt, *p);\n\t\ty = x;\n\t\ttmp = *p & ~((1U<<((~k&15)<<1)) - 1);\n\t\tx += __occ_aux4(bwt, tmp) - (~k&15);\n\t\t// calculate cntl[] and finalize cntk[]\n\t\tfor (; p < endl; ++p) y += __occ_aux4(bwt, *p);\n\t\ttmp = *p & ~((1U<<((~l&15)<<1)) - 1);\n\t\ty += __occ_aux4(bwt, tmp) - (~l&15);\n\t\tmemcpy(cntl, cntk, 4 * sizeof(bwtint_t));\n\t\tcntk[0] += x&0xff; cntk[1] += x>>8&0xff; cntk[2] += x>>16&0xff; cntk[3] += x>>24;\n\t\tcntl[0] += y&0xff; cntl[1] += y>>8&0xff; cntl[2] += y>>16&0xff; cntl[3] += y>>24;\n\t}\n}\n\nint bwt_match_exact(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *sa_begin, bwtint_t *sa_end)\n{\n\tbwtint_t k, l, ok, ol;\n\tint i;\n\tk = 0; l = bwt->seq_len;\n\tfor (i = len - 1; i >= 0; --i) {\n\t\tubyte_t c = str[i];\n\t\tif (c > 3) return 0; // no match\n\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\tk = bwt->L2[c] + ok + 1;\n\t\tl = bwt->L2[c] + ol;\n\t\tif (k > l) break; // no match\n\t}\n\tif (k > l) return 0; // no match\n\tif (sa_begin) *sa_begin = k;\n\tif (sa_end)   *sa_end = l;\n\treturn l - k + 1;\n}\n\nint bwt_match_exact_alt(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *k0, bwtint_t *l0)\n{\n\tint i;\n\tbwtint_t k, l, ok, ol;\n\tk = *k0; l = *l0;\n\tfor (i = len - 1; i >= 0; --i) {\n\t\tubyte_t c = str[i];\n\t\tif (c > 3) return 0; // there is an N here. no match\n\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\tk = bwt->L2[c] + ok + 1;\n\t\tl = bwt->L2[c] + ol;\n\t\tif (k > l) return 0; // no match\n\t}\n\t*k0 = k; *l0 = l;\n\treturn l - k + 1;\n}\n\n/*********************\n * Bidirectional BWT *\n *********************/\n\nvoid bwt_extend(const bwt_t *bwt, const bwtintv_t *ik, bwtintv_t ok[4], int is_back)\n{\n\tbwtint_t tk[4], tl[4];\n\tint i;\n\tbwt_2occ4(bwt, ik->x[!is_back] - 1, ik->x[!is_back] - 1 + ik->x[2], tk, tl);\n\tfor (i = 0; i != 4; ++i) {\n\t\tok[i].x[!is_back] = bwt->L2[i] + 1 + tk[i];\n\t\tok[i].x[2] = tl[i] - tk[i];\n\t}\n\tok[3].x[is_back] = ik->x[is_back] + (ik->x[!is_back] <= bwt->primary && ik->x[!is_back] + ik->x[2] - 1 >= bwt->primary);\n\tok[2].x[is_back] = ok[3].x[is_back] + ok[3].x[2];\n\tok[1].x[is_back] = ok[2].x[is_back] + ok[2].x[2];\n\tok[0].x[is_back] = ok[1].x[is_back] + ok[1].x[2];\n}\n\nstatic void bwt_reverse_intvs(bwtintv_v *p)\n{\n\tif (p->n > 1) {\n\t\tint j;\n\t\tfor (j = 0; j < p->n>>1; ++j) {\n\t\t\tbwtintv_t tmp = p->a[p->n - 1 - j];\n\t\t\tp->a[p->n - 1 - j] = p->a[j];\n\t\t\tp->a[j] = tmp;\n\t\t}\n\t}\n}\n// NOTE: $max_intv is not currently used in BWA-MEM\nint bwt_smem1a(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_intv, uint64_t max_intv, bwtintv_v *mem, bwtintv_v *tmpvec[2])\n{\n\tint i, j, c, ret;\n\tbwtintv_t ik, ok[4];\n\tbwtintv_v a[2], *prev, *curr, *swap;\n\n\tmem->n = 0;\n\tif (q[x] > 3) return x + 1;\n\tif (min_intv < 1) min_intv = 1; // the interval size should be at least 1\n\tkv_init(a[0]); kv_init(a[1]);\n\tprev = tmpvec && tmpvec[0]? tmpvec[0] : &a[0]; // use the temporary vector if provided\n\tcurr = tmpvec && tmpvec[1]? tmpvec[1] : &a[1];\n\tbwt_set_intv(bwt, q[x], ik); // the initial interval of a single base\n\tik.info = x + 1;\n\n\tfor (i = x + 1, curr->n = 0; i < len; ++i) { // forward search\n\t\tif (ik.x[2] < max_intv) { // an interval small enough\n\t\t\tkv_push(bwtintv_t, *curr, ik);\n\t\t\tbreak;\n\t\t} else if (q[i] < 4) { // an A/C/G/T base\n\t\t\tc = 3 - q[i]; // complement of q[i]\n\t\t\tbwt_extend(bwt, &ik, ok, 0);\n\t\t\tif (ok[c].x[2] != ik.x[2]) { // change of the interval size\n\t\t\t\tkv_push(bwtintv_t, *curr, ik);\n\t\t\t\tif (ok[c].x[2] < min_intv) break; // the interval size is too small to be extended further\n\t\t\t}\n\t\t\tik = ok[c]; ik.info = i + 1;\n\t\t} else { // an ambiguous base\n\t\t\tkv_push(bwtintv_t, *curr, ik);\n\t\t\tbreak; // always terminate extension at an ambiguous base; in this case, i<len always stands\n\t\t}\n\t}\n\tif (i == len) kv_push(bwtintv_t, *curr, ik); // push the last interval if we reach the end\n\tbwt_reverse_intvs(curr); // s.t. smaller intervals (i.e. longer matches) visited first\n\tret = curr->a[0].info; // this will be the returned value\n\tswap = curr; curr = prev; prev = swap;\n\n\tfor (i = x - 1; i >= -1; --i) { // backward search for MEMs\n\t\tc = i < 0? -1 : q[i] < 4? q[i] : -1; // c==-1 if i<0 or q[i] is an ambiguous base\n\t\tfor (j = 0, curr->n = 0; j < prev->n; ++j) {\n\t\t\tbwtintv_t *p = &prev->a[j];\n\t\t\tif (c >= 0 && ik.x[2] >= max_intv) bwt_extend(bwt, p, ok, 1);\n\t\t\tif (c < 0 || ik.x[2] < max_intv || ok[c].x[2] < min_intv) { // keep the hit if reaching the beginning or an ambiguous base or the intv is small enough\n\t\t\t\tif (curr->n == 0) { // test curr->n>0 to make sure there are no longer matches\n\t\t\t\t\tif (mem->n == 0 || i + 1 < mem->a[mem->n-1].info>>32) { // skip contained matches\n\t\t\t\t\t\tik = *p; ik.info |= (uint64_t)(i + 1)<<32;\n\t\t\t\t\t\tkv_push(bwtintv_t, *mem, ik);\n\t\t\t\t\t}\n\t\t\t\t} // otherwise the match is contained in another longer match\n\t\t\t} else if (curr->n == 0 || ok[c].x[2] != curr->a[curr->n-1].x[2]) {\n\t\t\t\tok[c].info = p->info;\n\t\t\t\tkv_push(bwtintv_t, *curr, ok[c]);\n\t\t\t}\n\t\t}\n\t\tif (curr->n == 0) break;\n\t\tswap = curr; curr = prev; prev = swap;\n\t}\n\tbwt_reverse_intvs(mem); // s.t. sorted by the start coordinate\n\n\tif (tmpvec == 0 || tmpvec[0] == 0) free(a[0].a);\n\tif (tmpvec == 0 || tmpvec[1] == 0) free(a[1].a);\n\treturn ret;\n}\n\nint bwt_smem1(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_intv, bwtintv_v *mem, bwtintv_v *tmpvec[2])\n{\n\treturn bwt_smem1a(bwt, len, q, x, min_intv, 0, mem, tmpvec);\n}\n\nint bwt_seed_strategy1(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_len, int max_intv, bwtintv_t *mem)\n{\n\tint i, c;\n\tbwtintv_t ik, ok[4];\n\n\tmemset(mem, 0, sizeof(bwtintv_t));\n\tif (q[x] > 3) return x + 1;\n\tbwt_set_intv(bwt, q[x], ik); // the initial interval of a single base\n\tfor (i = x + 1; i < len; ++i) { // forward search\n\t\tif (q[i] < 4) { // an A/C/G/T base\n\t\t\tc = 3 - q[i]; // complement of q[i]\n\t\t\tbwt_extend(bwt, &ik, ok, 0);\n\t\t\tif (ok[c].x[2] < max_intv && i - x >= min_len) {\n\t\t\t\t*mem = ok[c];\n\t\t\t\tmem->info = (uint64_t)x<<32 | (i + 1);\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t\tik = ok[c];\n\t\t} else return i + 1;\n\t}\n\treturn len;\n}\n\n/*************************\n * Read/write BWT and SA *\n *************************/\n\nvoid bwt_dump_bwt(const char *fn, const bwt_t *bwt)\n{\n\tFILE *fp;\n\tfp = xopen(fn, \"wb\");\n\terr_fwrite(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\terr_fwrite(bwt->bwt, 4, bwt->bwt_size, fp);\n\terr_fflush(fp);\n\terr_fclose(fp);\n}\n\nvoid bwt_dump_sa(const char *fn, const bwt_t *bwt)\n{\n\tFILE *fp;\n\tfp = xopen(fn, \"wb\");\n\terr_fwrite(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\terr_fwrite(&bwt->sa_intv, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(&bwt->seq_len, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->sa + 1, sizeof(bwtint_t), bwt->n_sa - 1, fp);\n\terr_fflush(fp);\n\terr_fclose(fp);\n}\n\nstatic bwtint_t fread_fix(FILE *fp, bwtint_t size, void *a)\n{ // Mac/Darwin has a bug when reading data longer than 2GB. This function fixes this issue by reading data in small chunks\n\tconst int bufsize = 0x1000000; // 16M block\n\tbwtint_t offset = 0;\n\twhile (size) {\n\t\tint x = bufsize < size? bufsize : size;\n\t\tif ((x = err_fread_noeof(a + offset, 1, x, fp)) == 0) break;\n\t\tsize -= x; offset += x;\n\t}\n\treturn offset;\n}\n\nvoid bwt_restore_sa(const char *fn, bwt_t *bwt)\n{\n\tchar skipped[256];\n\tFILE *fp;\n\tbwtint_t primary;\n\n\tfp = xopen(fn, \"rb\");\n\terr_fread_noeof(&primary, sizeof(bwtint_t), 1, fp);\n\txassert(primary == bwt->primary, \"SA-BWT inconsistency: primary is not the same.\");\n\terr_fread_noeof(skipped, sizeof(bwtint_t), 4, fp); // skip\n\terr_fread_noeof(&bwt->sa_intv, sizeof(bwtint_t), 1, fp);\n\terr_fread_noeof(&primary, sizeof(bwtint_t), 1, fp);\n\txassert(primary == bwt->seq_len, \"SA-BWT inconsistency: seq_len is not the same.\");\n\n\tbwt->n_sa = (bwt->seq_len + bwt->sa_intv) / bwt->sa_intv;\n\tbwt->sa = (bwtint_t*)calloc(bwt->n_sa, sizeof(bwtint_t));\n\tbwt->sa[0] = -1;\n\n\tfread_fix(fp, sizeof(bwtint_t) * (bwt->n_sa - 1), bwt->sa + 1);\n\terr_fclose(fp);\n}\n\nbwt_t *bwt_restore_bwt(const char *fn)\n{\n\tbwt_t *bwt;\n\tFILE *fp;\n\n\tbwt = (bwt_t*)calloc(1, sizeof(bwt_t));\n\tfp = xopen(fn, \"rb\");\n\terr_fseek(fp, 0, SEEK_END);\n\tbwt->bwt_size = (err_ftell(fp) - sizeof(bwtint_t) * 5) >> 2;\n\tbwt->bwt = (uint32_t*)calloc(bwt->bwt_size, 4);\n\terr_fseek(fp, 0, SEEK_SET);\n\terr_fread_noeof(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fread_noeof(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\tfread_fix(fp, bwt->bwt_size<<2, bwt->bwt);\n\tbwt->seq_len = bwt->L2[4];\n\terr_fclose(fp);\n\tbwt_gen_cnt_table(bwt);\n\n\treturn bwt;\n}\n\nvoid bwt_destroy(bwt_t *bwt)\n{\n\tif (bwt == 0) return;\n\tfree(bwt->sa); free(bwt->bwt);\n\tfree(bwt);\n}\n"
        },
        {
          "name": "bwt.h",
          "type": "blob",
          "size": 4.9619140625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Contact: Heng Li <hli@jimmy.harvard.edu> */\n\n#ifndef BWA_BWT_H\n#define BWA_BWT_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n// requirement: (OCC_INTERVAL%16 == 0); please DO NOT change this line because some part of the code assume OCC_INTERVAL=0x80\n#define OCC_INTV_SHIFT 7\n#define OCC_INTERVAL   (1LL<<OCC_INTV_SHIFT)\n#define OCC_INTV_MASK  (OCC_INTERVAL - 1)\n\n#ifndef BWA_UBYTE\n#define BWA_UBYTE\ntypedef unsigned char ubyte_t;\n#endif\n\ntypedef uint64_t bwtint_t;\n\ntypedef struct {\n\tbwtint_t primary; // S^{-1}(0), or the primary index of BWT\n\tbwtint_t L2[5]; // C(), cumulative count\n\tbwtint_t seq_len; // sequence length\n\tbwtint_t bwt_size; // size of bwt, about seq_len/4\n\tuint32_t *bwt; // BWT\n\t// occurance array, separated to two parts\n\tuint32_t cnt_table[256];\n\t// suffix array\n\tint sa_intv;\n\tbwtint_t n_sa;\n\tbwtint_t *sa;\n} bwt_t;\n\ntypedef struct {\n\tbwtint_t x[3], info;\n} bwtintv_t;\n\ntypedef struct { size_t n, m; bwtintv_t *a; } bwtintv_v;\n\n/* For general OCC_INTERVAL, the following is correct:\n#define bwt_bwt(b, k) ((b)->bwt[(k)/OCC_INTERVAL * (OCC_INTERVAL/(sizeof(uint32_t)*8/2) + sizeof(bwtint_t)/4*4) + sizeof(bwtint_t)/4*4 + (k)%OCC_INTERVAL/16])\n#define bwt_occ_intv(b, k) ((b)->bwt + (k)/OCC_INTERVAL * (OCC_INTERVAL/(sizeof(uint32_t)*8/2) + sizeof(bwtint_t)/4*4)\n*/\n\n// The following two lines are ONLY correct when OCC_INTERVAL==0x80\n#define bwt_bwt(b, k) ((b)->bwt[((k)>>7<<4) + sizeof(bwtint_t) + (((k)&0x7f)>>4)])\n#define bwt_occ_intv(b, k) ((b)->bwt + ((k)>>7<<4))\n\n/* retrieve a character from the $-removed BWT string. Note that\n * bwt_t::bwt is not exactly the BWT string and therefore this macro is\n * called bwt_B0 instead of bwt_B */\n#define bwt_B0(b, k) (bwt_bwt(b, k)>>((~(k)&0xf)<<1)&3)\n\n#define bwt_set_intv(bwt, c, ik) ((ik).x[0] = (bwt)->L2[(int)(c)]+1, (ik).x[2] = (bwt)->L2[(int)(c)+1]-(bwt)->L2[(int)(c)], (ik).x[1] = (bwt)->L2[3-(c)]+1, (ik).info = 0)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tvoid bwt_dump_bwt(const char *fn, const bwt_t *bwt);\n\tvoid bwt_dump_sa(const char *fn, const bwt_t *bwt);\n\n\tbwt_t *bwt_restore_bwt(const char *fn);\n\tvoid bwt_restore_sa(const char *fn, bwt_t *bwt);\n\n\tvoid bwt_destroy(bwt_t *bwt);\n\n\tvoid bwt_bwtgen(const char *fn_pac, const char *fn_bwt); // from BWT-SW\n\tvoid bwt_bwtgen2(const char *fn_pac, const char *fn_bwt, int block_size); // from BWT-SW\n\tvoid bwt_cal_sa(bwt_t *bwt, int intv);\n\n\tvoid bwt_bwtupdate_core(bwt_t *bwt);\n\n\tbwtint_t bwt_occ(const bwt_t *bwt, bwtint_t k, ubyte_t c);\n\tvoid bwt_occ4(const bwt_t *bwt, bwtint_t k, bwtint_t cnt[4]);\n\tbwtint_t bwt_sa(const bwt_t *bwt, bwtint_t k);\n\n\t// more efficient version of bwt_occ/bwt_occ4 for retrieving two close Occ values\n\tvoid bwt_gen_cnt_table(bwt_t *bwt);\n\tvoid bwt_2occ(const bwt_t *bwt, bwtint_t k, bwtint_t l, ubyte_t c, bwtint_t *ok, bwtint_t *ol);\n\tvoid bwt_2occ4(const bwt_t *bwt, bwtint_t k, bwtint_t l, bwtint_t cntk[4], bwtint_t cntl[4]);\n\n\tint bwt_match_exact(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *sa_begin, bwtint_t *sa_end);\n\tint bwt_match_exact_alt(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *k0, bwtint_t *l0);\n\n\t/**\n\t * Extend bi-SA-interval _ik_\n\t */\n\tvoid bwt_extend(const bwt_t *bwt, const bwtintv_t *ik, bwtintv_t ok[4], int is_back);\n\n\t/**\n\t * Given a query _q_, collect potential SMEMs covering position _x_ and store them in _mem_.\n\t * Return the end of the longest exact match starting from _x_.\n\t */\n\tint bwt_smem1(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_intv, bwtintv_v *mem, bwtintv_v *tmpvec[2]);\n\tint bwt_smem1a(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_intv, uint64_t max_intv, bwtintv_v *mem, bwtintv_v *tmpvec[2]);\n\n\tint bwt_seed_strategy1(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_len, int max_intv, bwtintv_t *mem);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwt_gen.c",
          "type": "blob",
          "size": 52.7607421875,
          "content": "/*\n\n   BWTConstruct.c\t\tBWT-Index Construction\n\n   This module constructs BWT and auxiliary data structures.\n\n   Copyright (C) 2004, Wong Chi Kwong.\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License\n   as published by the Free Software Foundation; either version 2\n   of the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdint.h>\n#include <errno.h>\n#include \"QSufSort.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef uint64_t bgint_t;\ntypedef int64_t sbgint_t;\n\n#define ALPHABET_SIZE\t\t\t\t4\n#define BIT_PER_CHAR\t\t\t\t2\n#define CHAR_PER_WORD\t\t\t\t16\n#define CHAR_PER_BYTE\t\t\t\t4\n\n#define BITS_IN_WORD 32\n#define BITS_IN_BYTE 8\n#define BYTES_IN_WORD 4\n\n#define ALL_ONE_MASK 0xFFFFFFFF\n#define DNA_OCC_CNT_TABLE_SIZE_IN_WORD\t65536\n\n#define BITS_PER_OCC_VALUE\t\t\t16\n#define OCC_VALUE_PER_WORD\t\t\t2\n#define OCC_INTERVAL\t\t\t\t256\n#define OCC_INTERVAL_MAJOR\t\t\t65536\n\n#define TRUE    1\n#define FALSE   0\n\n#define BWTINC_INSERT_SORT_NUM_ITEM 7\n\n#define MIN_AVAILABLE_WORD 0x10000\n\n#define average(value1, value2)\t\t\t\t\t( ((value1) & (value2)) + ((value1) ^ (value2)) / 2 )\n#define min(value1, value2)\t\t\t\t\t\t( ((value1) < (value2)) ? (value1) : (value2) )\n#define max(value1, value2)\t\t\t\t\t\t( ((value1) > (value2)) ? (value1) : (value2) )\n#define med3(a, b, c)\t\t\t\t\t\t\t( a<b ? (b<c ? b : a<c ? c : a) : (b>c ? b : a>c ? c : a))\n#define swap(a, b, t);\t\t\t\t\t\t\tt = a; a = b; b = t;\n#define truncateLeft(value, offset)\t\t\t\t( (value) << (offset) >> (offset) )\n#define truncateRight(value, offset)\t\t\t( (value) >> (offset) << (offset) )\n#define DNA_OCC_SUM_EXCEPTION(sum)\t\t\t((sum & 0xfefefeff) == 0)\n\ntypedef struct BWT {\n\tbgint_t textLength;\t\t\t\t\t// length of the text\n\tbgint_t inverseSa0;\t\t\t\t\t// SA-1[0]\n\tbgint_t *cumulativeFreq;\t\t\t// cumulative frequency\n\tunsigned int *bwtCode;\t\t\t\t// BWT code\n\tunsigned int *occValue;\t\t\t\t// Occurrence values stored explicitly\n\tbgint_t *occValueMajor;\t\t\t\t// Occurrence values stored explicitly\n\tunsigned int *decodeTable;\t\t\t// For decoding BWT by table lookup\n\tbgint_t bwtSizeInWord;\t\t\t\t// Temporary variable to hold the memory allocated\n\tbgint_t occSizeInWord;\t\t\t\t// Temporary variable to hold the memory allocated\n\tbgint_t occMajorSizeInWord;\t\t\t// Temporary variable to hold the memory allocated\n} BWT;\n\ntypedef struct BWTInc {\n\tBWT *bwt;\n\tunsigned int numberOfIterationDone;\n\tbgint_t *cumulativeCountInCurrentBuild;\n\tbgint_t availableWord;\n\tbgint_t buildSize;\n\tbgint_t initialMaxBuildSize;\n\tbgint_t incMaxBuildSize;\n\tunsigned int firstCharInLastIteration;\n\tunsigned int *workingMemory;\n\tunsigned int *packedText;\n\tunsigned char *textBuffer;\n\tunsigned int *packedShift;\n} BWTInc;\n\nstatic bgint_t TextLengthFromBytePacked(bgint_t bytePackedLength, unsigned int bitPerChar,\n\t\t\t\t\t\t\t\t\t\t\t unsigned int lastByteLength)\n{\n\treturn (bytePackedLength - 1) * (BITS_IN_BYTE / bitPerChar) + lastByteLength;\n}\n\nstatic void initializeVAL(unsigned int *startAddr, const bgint_t length, const unsigned int initValue)\n{\n\tbgint_t i;\n\tfor (i=0; i<length; i++) startAddr[i] = initValue;\n}\n\nstatic void initializeVAL_bg(bgint_t *startAddr, const bgint_t length, const bgint_t initValue)\n{\n\tbgint_t i;\n\tfor (i=0; i<length; i++) startAddr[i] = initValue;\n}\n\nstatic void GenerateDNAOccCountTable(unsigned int *dnaDecodeTable)\n{\n\tunsigned int i, j, c, t;\n\n\tfor (i=0; i<DNA_OCC_CNT_TABLE_SIZE_IN_WORD; i++) {\n\t\tdnaDecodeTable[i] = 0;\n\t\tc = i;\n\t\tfor (j=0; j<8; j++) {\n\t\t\tt = c & 0x00000003;\n\t\t\tdnaDecodeTable[i] += 1 << (t * 8);\n\t\t\tc >>= 2;\n\t\t}\n\t}\n\n}\n// for BWTIncCreate()\nstatic bgint_t BWTOccValueMajorSizeInWord(const bgint_t numChar)\n{\n\tbgint_t numOfOccValue;\n\tunsigned numOfOccIntervalPerMajor;\n\tnumOfOccValue = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL + 1; // Value at both end for bi-directional encoding\n\tnumOfOccIntervalPerMajor = OCC_INTERVAL_MAJOR / OCC_INTERVAL;\n\treturn (numOfOccValue + numOfOccIntervalPerMajor - 1) / numOfOccIntervalPerMajor * ALPHABET_SIZE;\n}\n// for BWTIncCreate()\nstatic bgint_t BWTOccValueMinorSizeInWord(const bgint_t numChar)\n{\n\tbgint_t numOfOccValue;\n\tnumOfOccValue = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL + 1;\t\t// Value at both end for bi-directional encoding\n\treturn (numOfOccValue + OCC_VALUE_PER_WORD - 1) / OCC_VALUE_PER_WORD * ALPHABET_SIZE;\n}\n// for BWTIncCreate()\nstatic bgint_t BWTResidentSizeInWord(const bgint_t numChar) {\n\n\tbgint_t numCharRoundUpToOccInterval;\n\n\t// The $ in BWT at the position of inverseSa0 is not encoded\n\tnumCharRoundUpToOccInterval = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL * OCC_INTERVAL;\n\n\treturn (numCharRoundUpToOccInterval + CHAR_PER_WORD - 1) / CHAR_PER_WORD;\n\n}\n\nstatic void BWTIncSetBuildSizeAndTextAddr(BWTInc *bwtInc)\n{\n\tbgint_t maxBuildSize;\n\n\tif (bwtInc->bwt->textLength == 0) {\n\t\t// initial build\n\t\t// Minus 2 because n+1 entries of seq and rank needed for n char\n\t\tmaxBuildSize = (bwtInc->availableWord - (2 + OCC_INTERVAL / CHAR_PER_WORD) * (sizeof(bgint_t) / 4))\n\t\t\t\t\t\t\t/ (2 * CHAR_PER_WORD + 1) * CHAR_PER_WORD / (sizeof(bgint_t) / 4);\n\t\tif (bwtInc->initialMaxBuildSize > 0) {\n\t\t\tbwtInc->buildSize = min(bwtInc->initialMaxBuildSize, maxBuildSize);\n\t\t} else {\n\t\t\tbwtInc->buildSize = maxBuildSize;\n\t\t}\n\t} else {\n\t\t// Minus 3 because n+1 entries of sorted rank, seq and rank needed for n char\n\t\t// Minus numberOfIterationDone because bwt slightly shift to left in each iteration\n\t\tmaxBuildSize = (bwtInc->availableWord - bwtInc->bwt->bwtSizeInWord - bwtInc->bwt->occSizeInWord\n\t\t\t\t\t\t\t - (3 + bwtInc->numberOfIterationDone * OCC_INTERVAL / BIT_PER_CHAR) * (sizeof(bgint_t) / 4)) \n\t\t\t\t\t\t\t / 3 / (sizeof(bgint_t) / 4);\n\t\tif (maxBuildSize < CHAR_PER_WORD) {\n\t\t\tfprintf(stderr, \"BWTIncSetBuildSizeAndTextAddr(): Not enough space allocated to continue construction!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (bwtInc->incMaxBuildSize > 0) {\n            bwtInc->buildSize = min(bwtInc->incMaxBuildSize, maxBuildSize);\n\t\t} else {\n\t\t\tbwtInc->buildSize = maxBuildSize;\n\t\t}\n\t\tif (bwtInc->buildSize < CHAR_PER_WORD)\n\t\t\tbwtInc->buildSize = CHAR_PER_WORD;\n\t}\n\n\tif (bwtInc->buildSize < CHAR_PER_WORD) {\n\t\tfprintf(stderr, \"BWTIncSetBuildSizeAndTextAddr(): Not enough space allocated to continue construction!\\n\");\n\t\texit(1);\n\t}\n\n\tbwtInc->buildSize = bwtInc->buildSize / CHAR_PER_WORD * CHAR_PER_WORD;\n\n\tbwtInc->packedText = bwtInc->workingMemory + 2 * (bwtInc->buildSize + 1) * (sizeof(bgint_t) / 4);\n\tbwtInc->textBuffer = (unsigned char*)(bwtInc->workingMemory + (bwtInc->buildSize + 1) * (sizeof(bgint_t) / 4));\n}\n\n// for ceilLog2()\nunsigned int leadingZero(const unsigned int input)\n{\n\tunsigned int l;\n\tconst static unsigned int leadingZero8bit[256] = {8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n\t\t\t\t\t\t\t\t\t\t\t 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n\t\t\t\t\t\t\t\t\t\t\t 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t\t\t\t\t\t\t\t\t\t\t 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n\tif (input & 0xFFFF0000) {\n\t\tif (input & 0xFF000000) {\n\t\t\tl = leadingZero8bit[input >> 24];\n\t\t} else {\n\t\t\tl = 8 + leadingZero8bit[input >> 16];\n\t\t}\n\t} else {\n\t\tif (input & 0x0000FF00) {\n\t\t\tl = 16 + leadingZero8bit[input >> 8];\n\t\t} else {\n\t\t\tl = 24 + leadingZero8bit[input];\n\t\t}\n\t}\n\treturn l;\n\n}\n// for BitPerBytePackedChar()\nstatic unsigned int ceilLog2(const unsigned int input)\n{\n\tif (input <= 1) return 0;\n\treturn BITS_IN_WORD - leadingZero(input - 1);\n\n}\n// for ConvertBytePackedToWordPacked()\nstatic unsigned int BitPerBytePackedChar(const unsigned int alphabetSize)\n{\n\tunsigned int bitPerChar;\n\tbitPerChar = ceilLog2(alphabetSize);\n\t// Return the largest number of bit that does not affect packing efficiency\n\tif (BITS_IN_BYTE / (BITS_IN_BYTE / bitPerChar) > bitPerChar)\n\t\tbitPerChar = BITS_IN_BYTE / (BITS_IN_BYTE / bitPerChar);\n\treturn bitPerChar;\n}\n// for ConvertBytePackedToWordPacked()\nstatic unsigned int BitPerWordPackedChar(const unsigned int alphabetSize)\n{\n\treturn ceilLog2(alphabetSize);\n}\n\nstatic void ConvertBytePackedToWordPacked(const unsigned char *input, unsigned int *output, const unsigned int alphabetSize,\n\t\t\t\t\t\t\t\t\t\t  const bgint_t textLength)\n{\n\tbgint_t i;\n\tunsigned int j, k, c;\n\tunsigned int bitPerBytePackedChar;\n\tunsigned int bitPerWordPackedChar;\n\tunsigned int charPerWord;\n\tunsigned int charPerByte;\n\tunsigned int bytePerIteration;\n\tbgint_t byteProcessed = 0;\n\tbgint_t wordProcessed = 0;\n\tunsigned int mask, shift;\n\t\n\tunsigned int buffer[BITS_IN_WORD];\n\n\tbitPerBytePackedChar = BitPerBytePackedChar(alphabetSize);\n\tbitPerWordPackedChar = BitPerWordPackedChar(alphabetSize);\n\tcharPerByte = BITS_IN_BYTE / bitPerBytePackedChar;\n\tcharPerWord = BITS_IN_WORD / bitPerWordPackedChar;\n\n\tbytePerIteration = charPerWord / charPerByte;\n\tmask = truncateRight(ALL_ONE_MASK, BITS_IN_WORD - bitPerWordPackedChar);\n\tshift = BITS_IN_WORD - BITS_IN_BYTE + bitPerBytePackedChar - bitPerWordPackedChar;\n\n\twhile ((wordProcessed + 1) * charPerWord < textLength) {\n\n\t\tk = 0;\n\t\tfor (i=0; i<bytePerIteration; i++) {\n\t\t\tc = (unsigned int)input[byteProcessed] << shift;\n\t\t\tfor (j=0; j<charPerByte; j++) {\n\t\t\t\tbuffer[k] = c & mask;\n\t\t\t\tc <<= bitPerBytePackedChar;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tbyteProcessed++;\n\t\t}\n\n\t\tc = 0;\n\t\tfor (i=0; i<charPerWord; i++) {\n\t\t\tc |= buffer[i] >> bitPerWordPackedChar * i;\n\t\t}\n\t\toutput[wordProcessed] = c;\n\t\twordProcessed++;\n\n\t}\n\n\tk = 0;\n\tfor (i=0; i < (textLength - wordProcessed * charPerWord - 1) / charPerByte + 1; i++) {\n\t\tc = (unsigned int)input[byteProcessed] << shift;\n\t\tfor (j=0; j<charPerByte; j++) {\n\t\t\tbuffer[k] = c & mask;\n\t\t\tc <<= bitPerBytePackedChar;\n\t\t\tk++;\n\t\t}\n\t\tbyteProcessed++;\n\t}\n\n\tc = 0;\n\tfor (i=0; i<textLength - wordProcessed * charPerWord; i++) {\n\t\tc |= buffer[i] >> bitPerWordPackedChar * i;\n\t}\n\toutput[wordProcessed] = c;\n}\n\nBWT *BWTCreate(const bgint_t textLength, unsigned int *decodeTable)\n{\n\tBWT *bwt;\n\n\tbwt = (BWT*)calloc(1, sizeof(BWT));\n\n\tbwt->textLength = 0;\n\n\tbwt->cumulativeFreq = (bgint_t*)calloc((ALPHABET_SIZE + 1), sizeof(bgint_t));\n\tinitializeVAL_bg(bwt->cumulativeFreq, ALPHABET_SIZE + 1, 0);\n\n\tbwt->bwtSizeInWord = 0;\n\n\t// Generate decode tables\n\tif (decodeTable == NULL) {\n\t\tbwt->decodeTable = (unsigned*)calloc(DNA_OCC_CNT_TABLE_SIZE_IN_WORD, sizeof(unsigned int));\n\t\tGenerateDNAOccCountTable(bwt->decodeTable);\n\t} else {\n\t\t// FIXME Prevent BWTFree() from freeing decodeTable in this case\n\t\tbwt->decodeTable = decodeTable;\n\t}\n\n\tbwt->occMajorSizeInWord = BWTOccValueMajorSizeInWord(textLength);\n\tbwt->occValueMajor = (bgint_t*)calloc(bwt->occMajorSizeInWord, sizeof(bgint_t));\n\n\tbwt->occSizeInWord = 0;\n\tbwt->occValue = NULL;\n\n\treturn bwt;\n}\n\nBWTInc *BWTIncCreate(const bgint_t textLength, unsigned int initialMaxBuildSize, unsigned int incMaxBuildSize)\n{\n\tBWTInc *bwtInc;\n\tunsigned int i, n_iter;\n\n\tif (textLength < incMaxBuildSize) incMaxBuildSize = textLength;\n\tif (textLength < initialMaxBuildSize) initialMaxBuildSize = textLength;\n\n\tbwtInc = (BWTInc*)calloc(1, sizeof(BWTInc));\n\tbwtInc->numberOfIterationDone = 0;\n\tbwtInc->bwt = BWTCreate(textLength, NULL);\n\tbwtInc->initialMaxBuildSize = initialMaxBuildSize;\n\tbwtInc->incMaxBuildSize = incMaxBuildSize;\n\tbwtInc->cumulativeCountInCurrentBuild = (bgint_t*)calloc((ALPHABET_SIZE + 1), sizeof(bgint_t));\n\tinitializeVAL_bg(bwtInc->cumulativeCountInCurrentBuild, ALPHABET_SIZE + 1, 0);\n\n\t// Build frequently accessed data\n\tbwtInc->packedShift = (unsigned*)calloc(CHAR_PER_WORD, sizeof(unsigned int));\n\tfor (i=0; i<CHAR_PER_WORD; i++)\n\t\tbwtInc->packedShift[i] = BITS_IN_WORD - (i+1) * BIT_PER_CHAR;\n\n\tn_iter = (textLength - initialMaxBuildSize) / incMaxBuildSize + 1;\n\tbwtInc->availableWord = BWTResidentSizeInWord(textLength) + BWTOccValueMinorSizeInWord(textLength) // minimal memory requirement\n\t\t+ OCC_INTERVAL / BIT_PER_CHAR * n_iter * 2 * (sizeof(bgint_t) / 4) // buffer at the end of occ array \n\t\t+ incMaxBuildSize/5 * 3 * (sizeof(bgint_t) / 4); // space for the 3 temporary arrays in each iteration\n\tif (bwtInc->availableWord < MIN_AVAILABLE_WORD) bwtInc->availableWord = MIN_AVAILABLE_WORD; // lh3: otherwise segfaul when availableWord is too small\n\tfprintf(stderr, \"[%s] textLength=%ld, availableWord=%ld\\n\", __func__, (long)textLength, (long)bwtInc->availableWord);\n\tbwtInc->workingMemory = (unsigned*)calloc(bwtInc->availableWord, BYTES_IN_WORD);\n\n\treturn bwtInc;\n}\n// for BWTIncConstruct()\nstatic void BWTIncPutPackedTextToRank(const unsigned int *packedText, bgint_t* __restrict rank,\n\t\t\t\t\t\t\t\t\t  bgint_t* __restrict cumulativeCount, const bgint_t numChar)\n{\n\tbgint_t i;\n\tunsigned int j;\n\tunsigned int c, t;\n\tunsigned int packedMask;\n\tbgint_t rankIndex;\n\tbgint_t lastWord;\n\tunsigned int numCharInLastWord;\n\n\tlastWord = (numChar - 1) / CHAR_PER_WORD;\n\tnumCharInLastWord = numChar - lastWord * CHAR_PER_WORD;\n\n\tpackedMask = ALL_ONE_MASK >> (BITS_IN_WORD - BIT_PER_CHAR);\n\trankIndex = numChar - 1;\n\n\tt = packedText[lastWord] >> (BITS_IN_WORD - numCharInLastWord * BIT_PER_CHAR);\n\tfor (i=0; i<numCharInLastWord; i++) {\n\t\tc = t & packedMask;\n\t\tcumulativeCount[c+1]++;\n\t\trank[rankIndex] = c;\n\t\trankIndex--;\n\t\tt >>= BIT_PER_CHAR;\n\t}\n\n\tfor (i=lastWord; i--;) {\t// loop from lastWord - 1 to 0\n\t\tt = packedText[i];\n\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\tc = t & packedMask;\n\t\t\tcumulativeCount[c+1]++;\n\t\t\trank[rankIndex] = c;\n\t\t\trankIndex--;\n\t\t\tt >>= BIT_PER_CHAR;\n\t\t}\n\t}\n\n\t// Convert occurrence to cumulativeCount\n\tcumulativeCount[2] += cumulativeCount[1];\n\tcumulativeCount[3] += cumulativeCount[2];\n\tcumulativeCount[4] += cumulativeCount[3];\n}\n\n\nstatic void ForwardDNAAllOccCountNoLimit(const unsigned int*  dna, const bgint_t index,\n\t\t\t\t\t\t\t\t\t\t bgint_t* __restrict occCount, const unsigned int*  dnaDecodeTable)\n{\n\tstatic const unsigned int truncateRightMask[16] = { 0x00000000, 0xC0000000, 0xF0000000, 0xFC000000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFF000000, 0xFFC00000, 0xFFF00000, 0xFFFC0000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFF0000, 0xFFFFC000, 0xFFFFF000, 0xFFFFFC00,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFFFF00, 0xFFFFFFC0, 0xFFFFFFF0, 0xFFFFFFFC };\n\n\tbgint_t iteration, i;\n\tunsigned int wordToCount, charToCount;\n\tunsigned int j, c, sum;\n\n\toccCount[0] = 0;\n\toccCount[1] = 0;\n\toccCount[2] = 0;\n\toccCount[3] = 0;\n\n\titeration = index / 256;\n\twordToCount = (index - iteration * 256) / 16;\n\tcharToCount = index - iteration * 256 - wordToCount * 16;\n\n\tfor (i=0; i<iteration; i++) {\n\n\t\tsum = 0;\n\t\tfor (j=0; j<16; j++) {\n\t\t\tsum += dnaDecodeTable[*dna >> 16];\n\t\t\tsum += dnaDecodeTable[*dna & 0x0000FFFF];\n\t\t\tdna++;\n\t\t}\n\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\toccCount[0] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\toccCount[1] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\toccCount[2] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\toccCount[3] += sum;\n\t\t} else {\n\t\t\t// only some or all of the 3 bits are on\n\t\t\t// in reality, only one of the four cases are possible\n\t\t\tif (sum == 0x00000100) {\n\t\t\t\toccCount[0] += 256;\n\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\toccCount[1] += 256;\n\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\toccCount[2] += 256;\n\t\t\t} else if (sum == 0x00000000) {\n\t\t\t\toccCount[3] += 256;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ForwardDNAAllOccCountNoLimit(): DNA occ sum exception!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tsum = 0;\n\tfor (j=0; j<wordToCount; j++) {\n\t\tsum += dnaDecodeTable[*dna >> 16];\n\t\tsum += dnaDecodeTable[*dna & 0x0000FFFF];\n\t\tdna++;\n\t}\n\n\tif (charToCount > 0) {\n\t\tc = *dna & truncateRightMask[charToCount];\t// increase count of 'a' by 16 - c;\n\t\tsum += dnaDecodeTable[c >> 16];\n\t\tsum += dnaDecodeTable[c & 0xFFFF];\n\t\tsum += charToCount - 16;\t// decrease count of 'a' by 16 - positionToProcess\n\t}\n\n\toccCount[0] += sum & 0x000000FF;\tsum >>= 8;\n\toccCount[1] += sum & 0x000000FF;\tsum >>= 8;\n\toccCount[2] += sum & 0x000000FF;\tsum >>= 8;\n\toccCount[3] += sum;\n}\n\nstatic void BWTIncBuildPackedBwt(const bgint_t *relativeRank, unsigned int* __restrict bwt, const bgint_t numChar,\n\t\t\t\t\t\t\t\t const bgint_t *cumulativeCount, const unsigned int *packedShift) {\n\n\tbgint_t i, r;\n\tunsigned int c;\n\tbgint_t previousRank, currentRank;\n\tbgint_t wordIndex, charIndex;\n\tbgint_t inverseSa0;\n\n\tinverseSa0 = previousRank = relativeRank[0];\n\n\tfor (i=1; i<=numChar; i++) {\n\t\tcurrentRank = relativeRank[i];\n\t\t// previousRank > cumulativeCount[c] because $ is one of the char\n\t\tc = (previousRank > cumulativeCount[1]) + (previousRank > cumulativeCount[2]) \n\t\t\t\t\t\t\t\t\t\t\t    + (previousRank > cumulativeCount[3]);\n\t\t// set bwt for currentRank\n\t\tif (c > 0) {\n\t\t\t// c <> 'a'\n\t\t\tr = currentRank;\n\t\t\tif (r > inverseSa0) {\n\t\t\t\t// - 1 because $ at inverseSa0 is not encoded\t\t\t\n\t\t\t\tr--;\n\t\t\t}\n\t\t\twordIndex = r / CHAR_PER_WORD;\n\t\t\tcharIndex = r - wordIndex * CHAR_PER_WORD;\n\t\t\tbwt[wordIndex] |= c << packedShift[charIndex];\n\t\t}\n\t\tpreviousRank = currentRank;\n\t}\n}\n\nstatic inline bgint_t BWTOccValueExplicit(const BWT *bwt, const bgint_t occIndexExplicit,\n\t\t\t\t\t\t\t\t\t\t\t   const unsigned int character)\n{\n\tbgint_t occIndexMajor;\n\n\toccIndexMajor = occIndexExplicit * OCC_INTERVAL / OCC_INTERVAL_MAJOR;\n\n\tif (occIndexExplicit % OCC_VALUE_PER_WORD == 0) {\n\t\treturn bwt->occValueMajor[occIndexMajor * ALPHABET_SIZE + character] +\n\t\t\t   (bwt->occValue[occIndexExplicit / OCC_VALUE_PER_WORD * ALPHABET_SIZE + character] >> 16);\n\n\t} else {\n\t\treturn bwt->occValueMajor[occIndexMajor * ALPHABET_SIZE + character] +\n\t\t\t   (bwt->occValue[occIndexExplicit / OCC_VALUE_PER_WORD * ALPHABET_SIZE + character] & 0x0000FFFF);\n\t}\n}\n\n\nstatic unsigned int ForwardDNAOccCount(const unsigned int*  dna, const unsigned int index, const unsigned int character,\n\t\t\t\t\t\t\t\t\t   const unsigned int*  dnaDecodeTable)\n{\n\tstatic const unsigned int truncateRightMask[16] = { 0x00000000, 0xC0000000, 0xF0000000, 0xFC000000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFF000000, 0xFFC00000, 0xFFF00000, 0xFFFC0000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFF0000, 0xFFFFC000, 0xFFFFF000, 0xFFFFFC00,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFFFF00, 0xFFFFFFC0, 0xFFFFFFF0, 0xFFFFFFFC };\n\n\tunsigned int wordToCount, charToCount;\n\tunsigned int i, c;\n\tunsigned int sum = 0;\n\n\twordToCount = index / 16;\n\tcharToCount = index - wordToCount * 16;\n\n\tfor (i=0; i<wordToCount; i++) {\n\t\tsum += dnaDecodeTable[dna[i] >> 16];\n\t\tsum += dnaDecodeTable[dna[i] & 0x0000FFFF];\n\t}\n\n\tif (charToCount > 0) {\n\t\tc = dna[i] & truncateRightMask[charToCount];\t// increase count of 'a' by 16 - c;\n\t\tsum += dnaDecodeTable[c >> 16];\n\t\tsum += dnaDecodeTable[c & 0xFFFF];\n\t\tsum += charToCount - 16;\t// decrease count of 'a' by 16 - positionToProcess\n\t}\n\n\treturn (sum >> (character * 8)) & 0x000000FF;\n\n}\n\nstatic unsigned int BackwardDNAOccCount(const unsigned int*  dna, const unsigned int index, const unsigned int character,\n\t\t\t\t\t\t\t\t\t\tconst unsigned int*  dnaDecodeTable)\n{\n\tstatic const unsigned int truncateLeftMask[16] =  { 0x00000000, 0x00000003, 0x0000000F, 0x0000003F,\n\t\t\t\t\t\t\t\t\t\t\t   0x000000FF, 0x000003FF, 0x00000FFF, 0x00003FFF,\n\t\t\t\t\t\t\t\t\t\t\t   0x0000FFFF, 0x0003FFFF, 0x000FFFFF, 0x003FFFFF,\n\t\t\t\t\t\t\t\t\t\t\t   0x00FFFFFF, 0x03FFFFFF, 0x0FFFFFFF, 0x3FFFFFFF };\n\n\tunsigned int wordToCount, charToCount;\n\tunsigned int i, c;\n\tunsigned int sum = 0;\n\n\twordToCount = index / 16;\n\tcharToCount = index - wordToCount * 16;\n\n\tdna -= wordToCount + 1;\n\n\tif (charToCount > 0) {\n\t\tc = *dna & truncateLeftMask[charToCount];\t// increase count of 'a' by 16 - c;\n\t\tsum += dnaDecodeTable[c >> 16];\n\t\tsum += dnaDecodeTable[c & 0xFFFF];\n\t\tsum += charToCount - 16;\t// decrease count of 'a' by 16 - positionToProcess\n\t}\n\t\n\tfor (i=0; i<wordToCount; i++) {\n\t\tdna++;\n\t\tsum += dnaDecodeTable[*dna >> 16];\n\t\tsum += dnaDecodeTable[*dna & 0x0000FFFF];\n\t}\n\n\treturn (sum >> (character * 8)) & 0x000000FF;\n\n}\n\nbgint_t BWTOccValue(const BWT *bwt, bgint_t index, const unsigned int character)\n{\n\tbgint_t occValue;\n\tbgint_t occExplicitIndex, occIndex;\n\n\t// $ is supposed to be positioned at inverseSa0 but it is not encoded\n\t// therefore index is subtracted by 1 for adjustment\n\tif (index > bwt->inverseSa0)\n\t\tindex--;\n\n\toccExplicitIndex = (index + OCC_INTERVAL / 2 - 1) / OCC_INTERVAL;\t// Bidirectional encoding\n\toccIndex = occExplicitIndex * OCC_INTERVAL;\n\toccValue = BWTOccValueExplicit(bwt, occExplicitIndex, character);\n\n\tif (occIndex == index)\n\t\treturn occValue;\n\n\tif (occIndex < index) {\n\t\treturn occValue + ForwardDNAOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, index - occIndex, character, bwt->decodeTable);\n\t} else {\n\t\treturn occValue - BackwardDNAOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, occIndex - index, character, bwt->decodeTable);\n\t}\n}\n\nstatic bgint_t BWTIncGetAbsoluteRank(BWT *bwt, bgint_t* __restrict absoluteRank, bgint_t* __restrict seq,\n\t\t\t\t\t\t\t\t\t\t  const unsigned int *packedText, const bgint_t numChar,\n\t\t\t\t\t\t\t\t\t\t  const bgint_t* cumulativeCount, const unsigned int firstCharInLastIteration)\n{\n\tbgint_t saIndex;\n\tbgint_t lastWord;\n\tunsigned int packedMask;\n\tbgint_t i;\n\tunsigned int c, t, j;\n\tbgint_t rankIndex;\n\tunsigned int shift;\n\tbgint_t seqIndexFromStart[ALPHABET_SIZE];\n\tbgint_t seqIndexFromEnd[ALPHABET_SIZE];\n\n\tfor (i=0; i<ALPHABET_SIZE; i++) {\n\t\tseqIndexFromStart[i] = cumulativeCount[i];\n\t\tseqIndexFromEnd[i] = cumulativeCount[i+1] - 1;\n\t}\n\n\tshift = BITS_IN_WORD - BIT_PER_CHAR;\n\tpackedMask = ALL_ONE_MASK >> shift;\n\tsaIndex = bwt->inverseSa0;\n\trankIndex = numChar - 1;\n\n\tlastWord = numChar / CHAR_PER_WORD;\n\tfor (i=lastWord; i--;) {\t// loop from lastWord - 1 to 0\n\t\tt = packedText[i];\n\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\tc = t & packedMask;\n\t\t\tsaIndex = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndex, c) + 1;\n\t\t\t// A counting sort using the first character of suffix is done here\n\t\t\t// If rank > inverseSa0 -> fill seq from end, otherwise fill seq from start -> to leave the right entry for inverseSa0\n\t\t\tif (saIndex > bwt->inverseSa0) {\n\t\t\t\tseq[seqIndexFromEnd[c]] = rankIndex;\n\t\t\t\tabsoluteRank[seqIndexFromEnd[c]] = saIndex;\n\t\t\t\tseqIndexFromEnd[c]--;\n\t\t\t} else {\n\t\t\t\tseq[seqIndexFromStart[c]] = rankIndex;\n\t\t\t\tabsoluteRank[seqIndexFromStart[c]] = saIndex;\n\t\t\t\tseqIndexFromStart[c]++;\n\t\t\t}\n\t\t\trankIndex--;\n\t\t\tt >>= BIT_PER_CHAR;\n\t\t}\n\t}\n\n\tabsoluteRank[seqIndexFromStart[firstCharInLastIteration]] = bwt->inverseSa0;\t// representing the substring of all preceding characters\n\tseq[seqIndexFromStart[firstCharInLastIteration]] = numChar;\n\n\treturn seqIndexFromStart[firstCharInLastIteration];\n}\n\nstatic void BWTIncSortKey(bgint_t* __restrict key, bgint_t* __restrict seq, const bgint_t numItem)\n{\n\t#define EQUAL_KEY_THRESHOLD\t4\t// Partition for equal key if data array size / the number of data with equal value with pivot < EQUAL_KEY_THRESHOLD\n\n\tint64_t lowIndex, highIndex, midIndex;\n\tint64_t lowPartitionIndex, highPartitionIndex;\n\tint64_t lowStack[32], highStack[32];\n\tint stackDepth;\n\tint64_t i, j;\n\tbgint_t tempSeq, tempKey;\n\tint64_t numberOfEqualKey;\n\n\tif (numItem < 2) return;\n\n\tstackDepth = 0;\n\n    lowIndex = 0;\n    highIndex = numItem - 1;\n\n\tfor (;;) {\n\n\t\tfor (;;) {\n\n\t\t\t// Sort small array of data\n\t\t\tif (highIndex - lowIndex < BWTINC_INSERT_SORT_NUM_ITEM) {\t // Insertion sort on smallest arrays\n\t\t\t\tfor (i=lowIndex+1; i<=highIndex; i++) {\n\t\t\t\t\ttempSeq = seq[i];\n\t\t\t\t\ttempKey = key[i];\n\t\t\t\t\tfor (j = i; j > lowIndex && key[j-1] > tempKey; j--) {\n\t\t\t\t\t\tseq[j] = seq[j-1];\n\t\t\t\t\t\tkey[j] = key[j-1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j != i) {\n\t\t\t\t\t\tseq[j] = tempSeq;\n\t\t\t\t\t\tkey[j] = tempKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Choose pivot as median of the lowest, middle, and highest data; sort the three data\n\n\t\t\tmidIndex = average(lowIndex, highIndex);\n\t\t\tif (key[lowIndex] > key[midIndex]) {\n\t\t\t\ttempSeq = seq[lowIndex];\n\t\t\t\ttempKey = key[lowIndex];\n\t\t\t\tseq[lowIndex] = seq[midIndex];\n\t\t\t\tkey[lowIndex] = key[midIndex];\n\t\t\t\tseq[midIndex] = tempSeq;\n\t\t\t\tkey[midIndex] = tempKey;\n\t\t\t}\n\t\t\tif (key[lowIndex] > key[highIndex]) {\n\t\t\t\ttempSeq = seq[lowIndex];\n\t\t\t\ttempKey = key[lowIndex];\n\t\t\t\tseq[lowIndex] = seq[highIndex];\n\t\t\t\tkey[lowIndex] = key[highIndex];\n\t\t\t\tseq[highIndex] = tempSeq;\n\t\t\t\tkey[highIndex] = tempKey;\n\t\t\t}\n\t\t\tif (key[midIndex] > key[highIndex]) {\n\t\t\t\ttempSeq = seq[midIndex];\n\t\t\t\ttempKey = key[midIndex];\n\t\t\t\tseq[midIndex] = seq[highIndex];\n\t\t\t\tkey[midIndex] = key[highIndex];\n\t\t\t\tseq[highIndex] = tempSeq;\n\t\t\t\tkey[highIndex] = tempKey;\n\t\t\t}\n\n\t\t\t// Partition data\n\n\t\t\tnumberOfEqualKey = 0;\n\n\t\t\tlowPartitionIndex = lowIndex + 1;\n\t\t\thighPartitionIndex = highIndex - 1;\n\n\t\t\tfor (;;) {\n\t\t\t\twhile (lowPartitionIndex <= highPartitionIndex && key[lowPartitionIndex] <= key[midIndex]) {\n\t\t\t\t\tnumberOfEqualKey += (key[lowPartitionIndex] == key[midIndex]);\n\t\t\t\t\tlowPartitionIndex++;\n\t\t\t\t}\n\t\t\t\twhile (lowPartitionIndex < highPartitionIndex) {\n\t\t\t\t\tif (key[midIndex] >= key[highPartitionIndex]) {\n\t\t\t\t\t\tnumberOfEqualKey += (key[midIndex] == key[highPartitionIndex]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\thighPartitionIndex--;\n\t\t\t\t}\n\t\t\t\tif (lowPartitionIndex >= highPartitionIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttempSeq = seq[lowPartitionIndex];\n\t\t\t\ttempKey = key[lowPartitionIndex];\n\t\t\t\tseq[lowPartitionIndex] = seq[highPartitionIndex];\n\t\t\t\tkey[lowPartitionIndex] = key[highPartitionIndex];\n\t\t\t\tseq[highPartitionIndex] = tempSeq;\n\t\t\t\tkey[highPartitionIndex] = tempKey;\n\t\t\t\tif (highPartitionIndex == midIndex) {\n\t\t\t\t\t// partition key has been moved\n\t\t\t\t\tmidIndex = lowPartitionIndex;\n\t\t\t\t}\n\t\t\t\tlowPartitionIndex++;\n\t\t\t\thighPartitionIndex--;\n\t\t\t}\n\n\t\t\t// Adjust the partition index\n\t\t\thighPartitionIndex = lowPartitionIndex;\n\t\t\tlowPartitionIndex--;\n\n\t\t\t// move the partition key to end of low partition\n\t\t\ttempSeq = seq[midIndex];\n\t\t\ttempKey = key[midIndex];\n\t\t\tseq[midIndex] = seq[lowPartitionIndex];\n\t\t\tkey[midIndex] = key[lowPartitionIndex];\n\t\t\tseq[lowPartitionIndex] = tempSeq;\n\t\t\tkey[lowPartitionIndex] = tempKey;\n\n\t\t\tif (highIndex - lowIndex + BWTINC_INSERT_SORT_NUM_ITEM <= EQUAL_KEY_THRESHOLD * numberOfEqualKey) {\n\n\t\t\t\t// Many keys = partition key; separate the equal key data from the lower partition\n\t\t\n\t\t\t\tmidIndex = lowIndex;\n\n\t\t\t\tfor (;;) {\n\t\t\t\t\twhile (midIndex < lowPartitionIndex && key[midIndex] < key[lowPartitionIndex]) {\n\t\t\t\t\t\tmidIndex++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (midIndex < lowPartitionIndex && key[lowPartitionIndex] == key[lowPartitionIndex - 1]) {\n\t\t\t\t\t\tlowPartitionIndex--;\n\t\t\t\t\t}\n\t\t\t\t\tif (midIndex >= lowPartitionIndex) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttempSeq = seq[midIndex];\n\t\t\t\t\ttempKey = key[midIndex];\n\t\t\t\t\tseq[midIndex] = seq[lowPartitionIndex - 1];\n\t\t\t\t\tkey[midIndex] = key[lowPartitionIndex - 1];\n\t\t\t\t\tseq[lowPartitionIndex - 1] = tempSeq;\n\t\t\t\t\tkey[lowPartitionIndex - 1] = tempKey;\n\t\t\t\t\tmidIndex++;\n\t\t\t\t\tlowPartitionIndex--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (lowPartitionIndex - lowIndex > highIndex - highPartitionIndex) {\n\t\t\t\t// put the larger partition to stack\n\t\t\t\tlowStack[stackDepth] = lowIndex;\n\t\t\t\thighStack[stackDepth] = lowPartitionIndex - 1;\n\t\t\t\tstackDepth++;\n\t\t\t\t// sort the smaller partition first\n\t\t\t\tlowIndex = highPartitionIndex;\n\t\t\t} else {\n\t\t\t\t// put the larger partition to stack\n\t\t\t\tlowStack[stackDepth] = highPartitionIndex;\n\t\t\t\thighStack[stackDepth] = highIndex;\n\t\t\t\tstackDepth++;\n\t\t\t\t// sort the smaller partition first\n\t\t\t\tif (lowPartitionIndex > lowIndex) {\n\t\t\t\t\thighIndex = lowPartitionIndex - 1;\n\t\t\t\t} else {\n\t\t\t\t\t// all keys in the partition equals to the partition key\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Pop a range from stack\n\t\tif (stackDepth > 0) {\n\t\t\tstackDepth--;\n\t\t\tlowIndex = lowStack[stackDepth];\n\t\t\thighIndex = highStack[stackDepth];\n\t\t\tcontinue;\n\t\t} else return;\n\t}\n}\n\n\nstatic void BWTIncBuildRelativeRank(bgint_t* __restrict sortedRank, bgint_t* __restrict seq,\n\t\t\t\t\t\t\t\t\tbgint_t* __restrict relativeRank, const bgint_t numItem,\n\t\t\t\t\t\t\t\t\tbgint_t oldInverseSa0, const bgint_t *cumulativeCount)\n{\n\tbgint_t i, c;\n\tbgint_t s, r;\n\tbgint_t lastRank, lastIndex;\n\tbgint_t oldInverseSa0RelativeRank = 0;\n\tbgint_t freq;\n\n\tlastIndex = numItem;\n\tlastRank = sortedRank[numItem];\n\tif (lastRank > oldInverseSa0) {\n\t\tsortedRank[numItem]--;\t// to prepare for merging; $ is not encoded in bwt\n\t}\n\ts = seq[numItem];\n\trelativeRank[s] = numItem;\n\tif (lastRank == oldInverseSa0) {\n\t\toldInverseSa0RelativeRank = numItem;\n\t\toldInverseSa0++;\t// so that this segment of code is not run again\n\t\tlastRank++;\t\t\t// so that oldInverseSa0 become a sorted group with 1 item\n\t}\n\n\tc = ALPHABET_SIZE - 1;\n\tfreq = cumulativeCount[c];\n\n\tfor (i=numItem; i--;) {\t// from numItem - 1 to 0\n\t\tr = sortedRank[i];\n\t\tif (r > oldInverseSa0)\n\t\t\tsortedRank[i]--;\t// to prepare for merging; $ is not encoded in bwt\n\t\ts = seq[i];\n\t\tif (i < freq) {\n\t\t\tif (lastIndex >= freq)\n\t\t\t\tlastRank++;\t// to trigger the group across alphabet boundary to be split\n\t\t\tc--;\n\t\t\tfreq = cumulativeCount[c];\n\t\t}\n\t\tif (r == lastRank) {\n\t\t\trelativeRank[s] = lastIndex;\n\t\t} else {\n\t\t\tif (i == lastIndex - 1) {\n\t\t\t\tif (lastIndex < numItem && (sbgint_t)seq[lastIndex + 1] < 0) {\n\t\t\t\t\tseq[lastIndex] = seq[lastIndex + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\tseq[lastIndex] = (bgint_t)-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastIndex = i;\n\t\t\tlastRank = r;\n\t\t\trelativeRank[s] = i;\n\t\t\tif (r == oldInverseSa0) {\n\t\t\t\toldInverseSa0RelativeRank = i;\n\t\t\t\toldInverseSa0++;\t// so that this segment of code is not run again\n\t\t\t\tlastRank++;\t\t\t// so that oldInverseSa0 become a sorted group with 1 item\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic void BWTIncBuildBwt(unsigned int* insertBwt, const bgint_t *relativeRank, const bgint_t numChar,\n\t\t\t\t\t\t   const bgint_t *cumulativeCount)\n{\n\tunsigned int c;\n\tbgint_t i;\n\tbgint_t previousRank, currentRank;\n\n\tpreviousRank = relativeRank[0];\n\n\tfor (i=1; i<=numChar; i++) {\n\t\tcurrentRank = relativeRank[i];\n\t\tc = (previousRank >= cumulativeCount[1]) + (previousRank >= cumulativeCount[2])\n\t\t\t\t\t\t\t\t\t\t\t  \t + (previousRank >= cumulativeCount[3]);\n\t\tinsertBwt[currentRank] = c;\n\t\tpreviousRank = currentRank;\n\t}\n}\n\nstatic void BWTIncMergeBwt(const bgint_t *sortedRank, const unsigned int* oldBwt, const unsigned int *insertBwt,\n\t\t\t\t\t\t   unsigned int* __restrict mergedBwt, const bgint_t numOldBwt, const bgint_t numInsertBwt)\n{\n\tunsigned int bitsInWordMinusBitPerChar;\n\tbgint_t leftShift, rightShift;\n\tbgint_t o;\n\tbgint_t oIndex, iIndex, mIndex;\n\tbgint_t mWord, mChar, oWord, oChar;\n\tbgint_t numInsert;\n\n\tbitsInWordMinusBitPerChar = BITS_IN_WORD - BIT_PER_CHAR;\n\n\toIndex = 0;\n\tiIndex = 0;\n\tmIndex = 0;\n\n\tmWord = 0;\n\tmChar = 0;\n\n\tmergedBwt[0] = 0;\t// this can be cleared as merged Bwt slightly shift to the left in each iteration\n\n\twhile (oIndex < numOldBwt) {\n\n\t\t// copy from insertBwt\n\t\twhile (iIndex <= numInsertBwt && sortedRank[iIndex] <= oIndex) {\n\t\t\tif (sortedRank[iIndex] != 0) {\t// special value to indicate that this is for new inverseSa0\n\t\t\t\tmergedBwt[mWord] |= insertBwt[iIndex] << (BITS_IN_WORD - (mChar + 1) * BIT_PER_CHAR);\n\t\t\t\tmIndex++;\n\t\t\t\tmChar++;\n\t\t\t\tif (mChar == CHAR_PER_WORD) {\n\t\t\t\t\tmChar = 0;\n\t\t\t\t\tmWord++;\n\t\t\t\t\tmergedBwt[mWord] = 0;\t// no need to worry about crossing mergedBwt boundary\n\t\t\t\t}\n\t\t\t}\n\t\t\tiIndex++;\n\t\t}\n\n\t\t// Copy from oldBwt to mergedBwt\n\t\tif (iIndex <= numInsertBwt) {\n\t\t\to = sortedRank[iIndex];\n\t\t} else {\n\t\t\to = numOldBwt;\n\t\t}\n\t\tnumInsert = o - oIndex;\n\n\t\toWord = oIndex / CHAR_PER_WORD;\n\t\toChar = oIndex - oWord * CHAR_PER_WORD;\n\t\tif (oChar > mChar) {\n\t\t\tleftShift = (oChar - mChar) * BIT_PER_CHAR;\n\t\t\trightShift = (CHAR_PER_WORD + mChar - oChar) * BIT_PER_CHAR;\n\t\t\tmergedBwt[mWord] = mergedBwt[mWord]\n\t\t\t\t\t\t\t\t| (oldBwt[oWord] << (oChar * BIT_PER_CHAR) >> (mChar * BIT_PER_CHAR))\n\t\t\t\t\t\t\t\t| (oldBwt[oWord+1] >> rightShift);\n\t\t\toIndex += min(numInsert, CHAR_PER_WORD - mChar);\n\t\t\twhile (o > oIndex) {\n\t\t\t\toWord++;\n\t\t\t\tmWord++;\n\t\t\t\tmergedBwt[mWord] = (oldBwt[oWord] << leftShift) | (oldBwt[oWord+1] >> rightShift);\n\t\t\t\toIndex += CHAR_PER_WORD;\n\t\t\t}\n\t\t} else if (oChar < mChar) {\n\t\t\trightShift = (mChar - oChar) * BIT_PER_CHAR;\n\t\t\tleftShift = (CHAR_PER_WORD + oChar - mChar) * BIT_PER_CHAR;\n\t\t\tmergedBwt[mWord] = mergedBwt[mWord] \n\t\t\t\t\t\t\t\t| (oldBwt[oWord] << (oChar * BIT_PER_CHAR) >> (mChar * BIT_PER_CHAR));\n\t\t\toIndex += min(numInsert, CHAR_PER_WORD - mChar);\n\t\t\twhile (o > oIndex) {\n\t\t\t\toWord++;\n\t\t\t\tmWord++;\n\t\t\t\tmergedBwt[mWord] = (oldBwt[oWord-1] << leftShift) | (oldBwt[oWord] >> rightShift);\n\t\t\t\toIndex += CHAR_PER_WORD;\n\t\t\t}\n\t\t} else { // oChar == mChar\n\t\t\tmergedBwt[mWord] = mergedBwt[mWord] | truncateLeft(oldBwt[oWord], mChar * BIT_PER_CHAR);\n\t\t\toIndex += min(numInsert, CHAR_PER_WORD - mChar);\n\t\t\twhile (o > oIndex) {\n\t\t\t\toWord++;\n\t\t\t\tmWord++;\n\t\t\t\tmergedBwt[mWord] = oldBwt[oWord];\n\t\t\t\toIndex += CHAR_PER_WORD;\n\t\t\t}\n\t\t}\n\t\toIndex = o;\n\t\tmIndex += numInsert;\n\n\t\t// Clear the trailing garbage in mergedBwt\n\t\tmWord = mIndex / CHAR_PER_WORD;\n\t\tmChar = mIndex - mWord * CHAR_PER_WORD;\n\t\tif (mChar == 0) {\n\t\t\tmergedBwt[mWord] = 0;\n\t\t} else {\n\t\t\tmergedBwt[mWord] = truncateRight(mergedBwt[mWord], (BITS_IN_WORD - mChar * BIT_PER_CHAR));\n\t\t}\n\n\t}\n\n\t// copy from insertBwt\n\twhile (iIndex <= numInsertBwt) {\n\t\tif (sortedRank[iIndex] != 0) {\n\t\t\tmergedBwt[mWord] |= insertBwt[iIndex] << (BITS_IN_WORD - (mChar + 1) * BIT_PER_CHAR);\n\t\t\tmIndex++;\n\t\t\tmChar++;\n\t\t\tif (mChar == CHAR_PER_WORD) {\n\t\t\t\tmChar = 0;\n\t\t\t\tmWord++;\n\t\t\t\tmergedBwt[mWord] = 0;\t// no need to worry about crossing mergedBwt boundary\n\t\t\t}\n\t\t}\n\t\tiIndex++;\n\t}\n}\n\nvoid BWTClearTrailingBwtCode(BWT *bwt)\n{\n\tbgint_t bwtResidentSizeInWord;\n\tbgint_t wordIndex, offset;\n\tbgint_t i;\n\n\tbwtResidentSizeInWord = BWTResidentSizeInWord(bwt->textLength);\n\n\twordIndex = bwt->textLength / CHAR_PER_WORD;\n\toffset = (bwt->textLength - wordIndex * CHAR_PER_WORD) * BIT_PER_CHAR;\n\tif (offset > 0) {\n\t\tbwt->bwtCode[wordIndex] = truncateRight(bwt->bwtCode[wordIndex], BITS_IN_WORD - offset);\n\t} else {\n\t\tif (wordIndex < bwtResidentSizeInWord) {\n\t\t\tbwt->bwtCode[wordIndex] = 0;\n\t\t}\n\t}\n\n\tfor (i=wordIndex+1; i<bwtResidentSizeInWord; i++) {\n\t\tbwt->bwtCode[i] = 0;\n\t}\n}\n\n\nvoid BWTGenerateOccValueFromBwt(const unsigned int*  bwt, unsigned int* __restrict occValue,\n\t\t\t\t\t\t\t\tbgint_t* __restrict occValueMajor,\n\t\t\t\t\t\t\t\tconst bgint_t textLength, const unsigned int*  decodeTable)\n{\n\tbgint_t numberOfOccValueMajor, numberOfOccValue;\n\tunsigned int wordBetweenOccValue;\n\tbgint_t numberOfOccIntervalPerMajor;\n\tunsigned int c;\n\tbgint_t i, j;\n\tbgint_t occMajorIndex;\n\tbgint_t occIndex, bwtIndex;\n\tbgint_t sum; // perhaps unsigned is big enough\n\tbgint_t tempOccValue0[ALPHABET_SIZE], tempOccValue1[ALPHABET_SIZE];\n\n\twordBetweenOccValue = OCC_INTERVAL / CHAR_PER_WORD;\n\n\t// Calculate occValue\n\tnumberOfOccValue = (textLength + OCC_INTERVAL - 1) / OCC_INTERVAL + 1;\t\t\t\t// Value at both end for bi-directional encoding\n\tnumberOfOccIntervalPerMajor = OCC_INTERVAL_MAJOR / OCC_INTERVAL;\n\tnumberOfOccValueMajor = (numberOfOccValue + numberOfOccIntervalPerMajor - 1) / numberOfOccIntervalPerMajor;\n\n\ttempOccValue0[0] = 0;\n\ttempOccValue0[1] = 0;\n\ttempOccValue0[2] = 0;\n\ttempOccValue0[3] = 0;\n\toccValueMajor[0] = 0;\n\toccValueMajor[1] = 0;\n\toccValueMajor[2] = 0;\n\toccValueMajor[3] = 0;\n\n\toccIndex = 0;\n\tbwtIndex = 0;\n\tfor (occMajorIndex=1; occMajorIndex<numberOfOccValueMajor; occMajorIndex++) {\n\n\t\tfor (i=0; i<numberOfOccIntervalPerMajor/2; i++) {\n\n\t\t\tsum = 0;\n\t\t\ttempOccValue1[0] = tempOccValue0[0];\n\t\t\ttempOccValue1[1] = tempOccValue0[1];\n\t\t\ttempOccValue1[2] = tempOccValue0[2];\n\t\t\ttempOccValue1[3] = tempOccValue0[3];\n\n\t\t\tfor (j=0; j<wordBetweenOccValue; j++) {\n\t\t\t\tc = bwt[bwtIndex];\n\t\t\t\tsum += decodeTable[c >> 16];\n\t\t\t\tsum += decodeTable[c & 0x0000FFFF];\n\t\t\t\tbwtIndex++;\n\t\t\t}\n\t\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\t\ttempOccValue1[0] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue1[1] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue1[2] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue1[3] += sum;\n\t\t\t} else {\n\t\t\t\tif (sum == 0x00000100) {\n\t\t\t\t\ttempOccValue1[0] += 256;\n\t\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\t\ttempOccValue1[1] += 256;\n\t\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\t\ttempOccValue1[2] += 256;\n\t\t\t\t} else {\n\t\t\t\t\ttempOccValue1[3] += 256;\n\t\t\t\t}\n\t\t\t}\n\t\t\toccValue[occIndex * 4 + 0] = (tempOccValue0[0] << 16) | tempOccValue1[0];\n\t\t\toccValue[occIndex * 4 + 1] = (tempOccValue0[1] << 16) | tempOccValue1[1];\n\t\t\toccValue[occIndex * 4 + 2] = (tempOccValue0[2] << 16) | tempOccValue1[2];\n\t\t\toccValue[occIndex * 4 + 3] = (tempOccValue0[3] << 16) | tempOccValue1[3];\n\t\t\ttempOccValue0[0] = tempOccValue1[0];\n\t\t\ttempOccValue0[1] = tempOccValue1[1];\n\t\t\ttempOccValue0[2] = tempOccValue1[2];\n\t\t\ttempOccValue0[3] = tempOccValue1[3];\n\t\t\tsum = 0;\n\n\t\t\toccIndex++;\n\n\t\t\tfor (j=0; j<wordBetweenOccValue; j++) {\n\t\t\t\tc = bwt[bwtIndex];\n\t\t\t\tsum += decodeTable[c >> 16];\n\t\t\t\tsum += decodeTable[c & 0x0000FFFF];\n\t\t\t\tbwtIndex++;\n\t\t\t}\n\t\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\t\ttempOccValue0[0] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue0[1] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue0[2] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\t\ttempOccValue0[3] += sum;\n\t\t\t} else {\n\t\t\t\tif (sum == 0x00000100) {\n\t\t\t\t\ttempOccValue0[0] += 256;\n\t\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\t\ttempOccValue0[1] += 256;\n\t\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\t\ttempOccValue0[2] += 256;\n\t\t\t\t} else {\n\t\t\t\t\ttempOccValue0[3] += 256;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toccValueMajor[occMajorIndex * 4 + 0] = occValueMajor[(occMajorIndex - 1) * 4 + 0] + tempOccValue0[0];\n\t\toccValueMajor[occMajorIndex * 4 + 1] = occValueMajor[(occMajorIndex - 1) * 4 + 1] + tempOccValue0[1];\n\t\toccValueMajor[occMajorIndex * 4 + 2] = occValueMajor[(occMajorIndex - 1) * 4 + 2] + tempOccValue0[2];\n\t\toccValueMajor[occMajorIndex * 4 + 3] = occValueMajor[(occMajorIndex - 1) * 4 + 3] + tempOccValue0[3];\n\t\ttempOccValue0[0] = 0;\n\t\ttempOccValue0[1] = 0;\n\t\ttempOccValue0[2] = 0;\n\t\ttempOccValue0[3] = 0;\n\n\t}\n\n\twhile (occIndex < (numberOfOccValue-1)/2) {\n\t\tsum = 0;\n\t\ttempOccValue1[0] = tempOccValue0[0];\n\t\ttempOccValue1[1] = tempOccValue0[1];\n\t\ttempOccValue1[2] = tempOccValue0[2];\n\t\ttempOccValue1[3] = tempOccValue0[3];\n\t\tfor (j=0; j<wordBetweenOccValue; j++) {\n\t\t\tc = bwt[bwtIndex];\n\t\t\tsum += decodeTable[c >> 16];\n\t\t\tsum += decodeTable[c & 0x0000FFFF];\n\t\t\tbwtIndex++;\n\t\t}\n\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\ttempOccValue1[0] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[1] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[2] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[3] += sum;\n\t\t} else {\n\t\t\tif (sum == 0x00000100) {\n\t\t\t\ttempOccValue1[0] += 256;\n\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\ttempOccValue1[1] += 256;\n\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\ttempOccValue1[2] += 256;\n\t\t\t} else {\n\t\t\t\ttempOccValue1[3] += 256;\n\t\t\t}\n\t\t}\n\t\toccValue[occIndex * 4 + 0] = (tempOccValue0[0] << 16) | tempOccValue1[0];\n\t\toccValue[occIndex * 4 + 1] = (tempOccValue0[1] << 16) | tempOccValue1[1];\n\t\toccValue[occIndex * 4 + 2] = (tempOccValue0[2] << 16) | tempOccValue1[2];\n\t\toccValue[occIndex * 4 + 3] = (tempOccValue0[3] << 16) | tempOccValue1[3];\n\t\ttempOccValue0[0] = tempOccValue1[0];\n\t\ttempOccValue0[1] = tempOccValue1[1];\n\t\ttempOccValue0[2] = tempOccValue1[2];\n\t\ttempOccValue0[3] = tempOccValue1[3];\n\t\tsum = 0;\n\t\toccIndex++;\n\n\t\tfor (j=0; j<wordBetweenOccValue; j++) {\n\t\t\tc = bwt[bwtIndex];\n\t\t\tsum += decodeTable[c >> 16];\n\t\t\tsum += decodeTable[c & 0x0000FFFF];\n\t\t\tbwtIndex++;\n\t\t}\n\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\ttempOccValue0[0] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue0[1] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue0[2] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue0[3] += sum;\n\t\t} else {\n\t\t\tif (sum == 0x00000100) {\n\t\t\t\ttempOccValue0[0] += 256;\n\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\ttempOccValue0[1] += 256;\n\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\ttempOccValue0[2] += 256;\n\t\t\t} else {\n\t\t\t\ttempOccValue0[3] += 256;\n\t\t\t}\n\t\t}\n\t}\n\n\tsum = 0;\n\ttempOccValue1[0] = tempOccValue0[0];\n\ttempOccValue1[1] = tempOccValue0[1];\n\ttempOccValue1[2] = tempOccValue0[2];\n\ttempOccValue1[3] = tempOccValue0[3];\n\n\tif (occIndex * 2 < numberOfOccValue - 1) {\n\t\tfor (j=0; j<wordBetweenOccValue; j++) {\n\t\t\tc = bwt[bwtIndex];\n\t\t\tsum += decodeTable[c >> 16];\n\t\t\tsum += decodeTable[c & 0x0000FFFF];\n\t\t\tbwtIndex++;\n\t\t}\n\t\tif (!DNA_OCC_SUM_EXCEPTION(sum)) {\n\t\t\ttempOccValue1[0] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[1] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[2] += (sum & 0x000000FF);\tsum >>= 8;\n\t\t\ttempOccValue1[3] += sum;\n\t\t} else {\n\t\t\tif (sum == 0x00000100) {\n\t\t\t\ttempOccValue1[0] += 256;\n\t\t\t} else if (sum == 0x00010000) {\n\t\t\t\ttempOccValue1[1] += 256;\n\t\t\t} else if (sum == 0x01000000) {\n\t\t\t\ttempOccValue1[2] += 256;\n\t\t\t} else {\n\t\t\t\ttempOccValue1[3] += 256;\n\t\t\t}\n\t\t}\n\t}\n\n\toccValue[occIndex * 4 + 0] = (tempOccValue0[0] << 16) | tempOccValue1[0];\n\toccValue[occIndex * 4 + 1] = (tempOccValue0[1] << 16) | tempOccValue1[1];\n\toccValue[occIndex * 4 + 2] = (tempOccValue0[2] << 16) | tempOccValue1[2];\n\toccValue[occIndex * 4 + 3] = (tempOccValue0[3] << 16) | tempOccValue1[3];\n\n}\n\nstatic void BWTIncConstruct(BWTInc *bwtInc, const bgint_t numChar)\n{\n\tunsigned int i;\n\tbgint_t mergedBwtSizeInWord, mergedOccSizeInWord;\n\tunsigned int firstCharInThisIteration;\n\n\tbgint_t *relativeRank, *seq, *sortedRank;\n\tunsigned int *insertBwt, *mergedBwt;\n\tbgint_t newInverseSa0RelativeRank, oldInverseSa0RelativeRank, newInverseSa0;\n\n\tmergedBwtSizeInWord = BWTResidentSizeInWord(bwtInc->bwt->textLength + numChar);\n\tmergedOccSizeInWord = BWTOccValueMinorSizeInWord(bwtInc->bwt->textLength + numChar);\n\n\tinitializeVAL_bg(bwtInc->cumulativeCountInCurrentBuild, ALPHABET_SIZE + 1, 0);\n\n\tif (bwtInc->bwt->textLength == 0) {\t\t// Initial build\n\n\t\t// Set address\n\t\tseq = (bgint_t*)bwtInc->workingMemory;\n\t\trelativeRank = seq + bwtInc->buildSize + 1;\n\t\t// mergedBwt and packedTex may share memory\n\t\tmergedBwt = insertBwt = bwtInc->workingMemory + bwtInc->availableWord - mergedBwtSizeInWord;\t// build in place\n\n\t\tassert((void*)(relativeRank + bwtInc->buildSize + 1) <= (void*)bwtInc->packedText);\n\t\tassert((void*)(relativeRank + bwtInc->buildSize + 1) <= (void*)mergedBwt);\n\n\t\t// ->packedText is not used any more and may be overwritten by mergedBwt\n\t\tBWTIncPutPackedTextToRank(bwtInc->packedText, relativeRank, bwtInc->cumulativeCountInCurrentBuild, numChar);\n\n\t\tfirstCharInThisIteration = relativeRank[0];\n\t\trelativeRank[numChar] = 0;\n\n\t\t// Sort suffix\n\t\tQSufSortSuffixSort((qsint_t*)relativeRank, (qsint_t*)seq, (qsint_t)numChar, (qsint_t)ALPHABET_SIZE - 1, 0, FALSE);\n\t\tnewInverseSa0 = relativeRank[0];\n\n\t\t// Clear BWT area\n\t\tinitializeVAL(insertBwt, mergedBwtSizeInWord, 0);\n\n\t\t// Build BWT\n\t\tBWTIncBuildPackedBwt(relativeRank, insertBwt, numChar, bwtInc->cumulativeCountInCurrentBuild, bwtInc->packedShift);\n\n\t\t// so that the cumulativeCount is not deducted\n\t\tbwtInc->firstCharInLastIteration = ALPHABET_SIZE;\n\n\t} else {\t\t// Incremental build\n\t\t// Set address\n\t\tsortedRank = (bgint_t*)bwtInc->workingMemory;\n\t\tseq = sortedRank + bwtInc->buildSize + 1;\n\t\tinsertBwt = (unsigned*)seq; // insertBwt and seq share memory\n\t\t// relativeRank and ->packedText may share memory\n\t\trelativeRank = seq + bwtInc->buildSize + 1;\n\n\t\tassert((void*)relativeRank <= (void*)bwtInc->packedText);\n\n\t\t// Store the first character of this iteration\n\t\tfirstCharInThisIteration = bwtInc->packedText[0] >> (BITS_IN_WORD - BIT_PER_CHAR);\n\n\t\t// Count occurrence of input text\n\t\tForwardDNAAllOccCountNoLimit(bwtInc->packedText, numChar, bwtInc->cumulativeCountInCurrentBuild + 1, bwtInc->bwt->decodeTable);\n\t\t// Add the first character of the previous iteration to represent the inverseSa0 of the previous iteration\n\t\tbwtInc->cumulativeCountInCurrentBuild[bwtInc->firstCharInLastIteration + 1]++;\n\t\tbwtInc->cumulativeCountInCurrentBuild[2] += bwtInc->cumulativeCountInCurrentBuild[1];\n\t\tbwtInc->cumulativeCountInCurrentBuild[3] += bwtInc->cumulativeCountInCurrentBuild[2];\n\t\tbwtInc->cumulativeCountInCurrentBuild[4] += bwtInc->cumulativeCountInCurrentBuild[3];\n\n\t\t// Get rank of new suffix among processed suffix\n\t\t// The seq array is built into ALPHABET_SIZE + 2 groups; ALPHABET_SIZE groups + 1 group divided into 2 by inverseSa0 + inverseSa0 as 1 group\n\t\t// ->packedText is not used any more and will be overwritten by relativeRank\n\t\toldInverseSa0RelativeRank = BWTIncGetAbsoluteRank(bwtInc->bwt, sortedRank, seq, bwtInc->packedText, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  numChar, bwtInc->cumulativeCountInCurrentBuild, bwtInc->firstCharInLastIteration);\n\n\t\t// Sort rank by ALPHABET_SIZE + 2 groups (or ALPHABET_SIZE + 1 groups when inverseSa0 sit on the border of a group)\n\t\tfor (i=0; i<ALPHABET_SIZE; i++) {\n\t\t\tif (bwtInc->cumulativeCountInCurrentBuild[i] > oldInverseSa0RelativeRank ||\n\t\t\t\tbwtInc->cumulativeCountInCurrentBuild[i+1] <= oldInverseSa0RelativeRank) {\n\t\t\t\tBWTIncSortKey(sortedRank + bwtInc->cumulativeCountInCurrentBuild[i], seq + bwtInc->cumulativeCountInCurrentBuild[i], bwtInc->cumulativeCountInCurrentBuild[i+1] - bwtInc->cumulativeCountInCurrentBuild[i]);\n\t\t\t} else {\n\t\t\t\tif (bwtInc->cumulativeCountInCurrentBuild[i] < oldInverseSa0RelativeRank) {\n\t\t\t\t\tBWTIncSortKey(sortedRank + bwtInc->cumulativeCountInCurrentBuild[i], seq + bwtInc->cumulativeCountInCurrentBuild[i], oldInverseSa0RelativeRank - bwtInc->cumulativeCountInCurrentBuild[i]);\n\t\t\t\t}\n\t\t\t\tif (bwtInc->cumulativeCountInCurrentBuild[i+1] > oldInverseSa0RelativeRank + 1) {\n\t\t\t\t\tBWTIncSortKey(sortedRank + oldInverseSa0RelativeRank + 1, seq + oldInverseSa0RelativeRank + 1, bwtInc->cumulativeCountInCurrentBuild[i+1] - oldInverseSa0RelativeRank - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build relative rank; sortedRank is updated for merging to cater for the fact that $ is not encoded in bwt\n\t\t// the cumulative freq information is used to make sure that inverseSa0 and suffix beginning with different characters are kept in different unsorted groups)\n\t\tBWTIncBuildRelativeRank(sortedRank, seq, relativeRank, numChar, bwtInc->bwt->inverseSa0, bwtInc->cumulativeCountInCurrentBuild);\n\t\tassert(relativeRank[numChar] == oldInverseSa0RelativeRank);\n\n\t\t// Sort suffix\n\t\tQSufSortSuffixSort((qsint_t*)relativeRank, (qsint_t*)seq, (qsint_t)numChar, (qsint_t)numChar, 1, TRUE);\n\n\t\tnewInverseSa0RelativeRank = relativeRank[0];\n\t\tnewInverseSa0 = sortedRank[newInverseSa0RelativeRank] + newInverseSa0RelativeRank;\n\n\t\tsortedRank[newInverseSa0RelativeRank] = 0;\t// a special value so that this is skipped in the merged bwt\n\n\t\t// Build BWT; seq is overwritten by insertBwt\n\t\tBWTIncBuildBwt(insertBwt, relativeRank, numChar, bwtInc->cumulativeCountInCurrentBuild);\n\n\t\t// Merge BWT; relativeRank may be overwritten by mergedBwt\n\t\tmergedBwt = bwtInc->workingMemory + bwtInc->availableWord - mergedBwtSizeInWord \n\t\t\t\t    - bwtInc->numberOfIterationDone * OCC_INTERVAL / BIT_PER_CHAR * (sizeof(bgint_t) / 4); // minus numberOfIteration * occInterval to create a buffer for merging\n\t\tassert(mergedBwt >= insertBwt + numChar);\n\t\tBWTIncMergeBwt(sortedRank, bwtInc->bwt->bwtCode, insertBwt, mergedBwt, bwtInc->bwt->textLength, numChar);\n\t}\n\n\t// Build auxiliary structure and update info and pointers in BWT\n\tbwtInc->bwt->textLength += numChar;\n\tbwtInc->bwt->bwtCode = mergedBwt;\n\tbwtInc->bwt->bwtSizeInWord = mergedBwtSizeInWord;\n\tbwtInc->bwt->occSizeInWord = mergedOccSizeInWord;\n\tassert(mergedBwt >= bwtInc->workingMemory + mergedOccSizeInWord);\n\n\tbwtInc->bwt->occValue = mergedBwt - mergedOccSizeInWord;\n\n\tBWTClearTrailingBwtCode(bwtInc->bwt);\n\tBWTGenerateOccValueFromBwt(bwtInc->bwt->bwtCode, bwtInc->bwt->occValue, bwtInc->bwt->occValueMajor,\n\t\t\t\t\t\t\t   bwtInc->bwt->textLength, bwtInc->bwt->decodeTable);\n\n\tbwtInc->bwt->inverseSa0 = newInverseSa0;\n\t\n\tbwtInc->bwt->cumulativeFreq[1] += bwtInc->cumulativeCountInCurrentBuild[1] - (bwtInc->firstCharInLastIteration <= 0);\n\tbwtInc->bwt->cumulativeFreq[2] += bwtInc->cumulativeCountInCurrentBuild[2] - (bwtInc->firstCharInLastIteration <= 1);\n\tbwtInc->bwt->cumulativeFreq[3] += bwtInc->cumulativeCountInCurrentBuild[3] - (bwtInc->firstCharInLastIteration <= 2);\n\tbwtInc->bwt->cumulativeFreq[4] += bwtInc->cumulativeCountInCurrentBuild[4] - (bwtInc->firstCharInLastIteration <= 3);\n\n\tbwtInc->firstCharInLastIteration = firstCharInThisIteration;\n\n\t// Set build size and text address for the next build\n\tBWTIncSetBuildSizeAndTextAddr(bwtInc);\n\tbwtInc->numberOfIterationDone++;\n\n}\n\nBWTInc *BWTIncConstructFromPacked(const char *inputFileName, bgint_t initialMaxBuildSize, bgint_t incMaxBuildSize)\n{\n\n\tFILE *packedFile;\n\tbgint_t packedFileLen;\n\tbgint_t totalTextLength;\n\tbgint_t textToLoad, textSizeInByte;\n\tbgint_t processedTextLength;\n\tunsigned char lastByteLength;\n\n\tBWTInc *bwtInc;\n\n\tpackedFile = (FILE*)fopen(inputFileName, \"rb\");\n\n\tif (packedFile == NULL) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Cannot open %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fseek(packedFile, -1, SEEK_END) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tpackedFileLen = ftell(packedFile);\n\tif (packedFileLen == -1) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't ftell on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fread(&lastByteLength, sizeof(unsigned char), 1, packedFile) != 1) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\texit(1);\n\t}\n\ttotalTextLength = TextLengthFromBytePacked(packedFileLen, BIT_PER_CHAR, lastByteLength);\n\n\tbwtInc = BWTIncCreate(totalTextLength, initialMaxBuildSize, incMaxBuildSize);\n\n\tBWTIncSetBuildSizeAndTextAddr(bwtInc);\n\n\tif (bwtInc->buildSize > totalTextLength) {\n\t\ttextToLoad = totalTextLength;\n\t} else {\n\t\ttextToLoad = totalTextLength - ((totalTextLength - bwtInc->buildSize + CHAR_PER_WORD - 1) / CHAR_PER_WORD * CHAR_PER_WORD);\n\t}\n\ttextSizeInByte = textToLoad / CHAR_PER_BYTE;\t// excluded the odd byte\n\n\tif (fseek(packedFile, -((long)textSizeInByte + 2), SEEK_CUR) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fread(bwtInc->textBuffer, sizeof(unsigned char), textSizeInByte + 1, packedFile) != textSizeInByte + 1) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\texit(1);\n\t}\n\tif (fseek(packedFile, -((long)textSizeInByte + 1), SEEK_CUR) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tConvertBytePackedToWordPacked(bwtInc->textBuffer, bwtInc->packedText, ALPHABET_SIZE, textToLoad);\n\tBWTIncConstruct(bwtInc, textToLoad);\n\n\tprocessedTextLength = textToLoad;\n\n\twhile (processedTextLength < totalTextLength) {\n\t\ttextToLoad = bwtInc->buildSize / CHAR_PER_WORD * CHAR_PER_WORD;\n\t\tif (textToLoad > totalTextLength - processedTextLength) {\n\t\t\ttextToLoad = totalTextLength - processedTextLength;\n\t\t}\n\t\ttextSizeInByte = textToLoad / CHAR_PER_BYTE;\n\t\tif (fseek(packedFile, -((long)textSizeInByte), SEEK_CUR) != 0) {\n\t\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\t\tinputFileName, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tif (fread(bwtInc->textBuffer, sizeof(unsigned char), textSizeInByte, packedFile) != textSizeInByte) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\t\texit(1);\n\t\t}\n\t\tif (fseek(packedFile, -((long)textSizeInByte), SEEK_CUR) != 0) {\n\t\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\t\tinputFileName, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tConvertBytePackedToWordPacked(bwtInc->textBuffer, bwtInc->packedText, ALPHABET_SIZE, textToLoad);\n\t\tBWTIncConstruct(bwtInc, textToLoad);\n\t\tprocessedTextLength += textToLoad;\n\t\tif (bwtInc->numberOfIterationDone % 10 == 0) {\n\t\t\tfprintf(stderr, \"[BWTIncConstructFromPacked] %lu iterations done. %lu characters processed.\\n\",\n\t\t\t\t\t(long)bwtInc->numberOfIterationDone, (long)processedTextLength);\n\t\t}\n\t}\n\n\tfclose(packedFile);\n\treturn bwtInc;\n}\n\nvoid BWTIncFree(BWTInc *bwtInc)\n{\n\tif (bwtInc == 0) return;\n\tfree(bwtInc->bwt->cumulativeFreq);\n\tfree(bwtInc->bwt->occValueMajor);\n\tfree(bwtInc->bwt->decodeTable);\n\tfree(bwtInc->bwt);\n\tfree(bwtInc->workingMemory);\n\tfree(bwtInc->cumulativeCountInCurrentBuild);\n\tfree(bwtInc->packedShift);\n\tfree(bwtInc);\n}\n\nstatic bgint_t BWTFileSizeInWord(const bgint_t numChar)\n{\n\t// The $ in BWT at the position of inverseSa0 is not encoded\n\treturn (numChar + CHAR_PER_WORD - 1) / CHAR_PER_WORD;\n}\n\nvoid BWTSaveBwtCodeAndOcc(const BWT *bwt, const char *bwtFileName, const char *occValueFileName)\n{\n\tFILE *bwtFile;\n/*\tFILE *occValueFile; */\n\tbgint_t bwtLength;\n\n\tbwtFile = (FILE*)fopen(bwtFileName, \"wb\");\n\tif (bwtFile == NULL) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTSaveBwtCodeAndOcc(): Cannot open %s for writing: %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tbwtLength = BWTFileSizeInWord(bwt->textLength);\n\n\tif (fwrite(&bwt->inverseSa0, sizeof(bgint_t), 1, bwtFile) != 1\n\t\t|| fwrite(bwt->cumulativeFreq + 1,\n\t\t\t\t  sizeof(bgint_t), ALPHABET_SIZE, bwtFile) != ALPHABET_SIZE\n\t\t|| fwrite(bwt->bwtCode,\n\t\t\t\t  sizeof(unsigned int), bwtLength, bwtFile) != bwtLength) {\n\t\tfprintf(stderr, \"BWTSaveBwtCodeAndOcc(): Error writing to %s : %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fclose(bwtFile) != 0) {\n\t\tfprintf(stderr, \"BWTSaveBwtCodeAndOcc(): Error on closing %s : %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n}\n\nvoid bwt_bwtgen2(const char *fn_pac, const char *fn_bwt, int block_size)\n{\n\tBWTInc *bwtInc;\n\tbwtInc = BWTIncConstructFromPacked(fn_pac, block_size, block_size);\n\tfprintf(stderr, \"[bwt_gen] Finished constructing BWT in %u iterations.\\n\", bwtInc->numberOfIterationDone);\n\tBWTSaveBwtCodeAndOcc(bwtInc->bwt, fn_bwt, 0);\n\tBWTIncFree(bwtInc);\n}\n\nvoid bwt_bwtgen(const char *fn_pac, const char *fn_bwt)\n{\n\tbwt_bwtgen2(fn_pac, fn_bwt, 10000000);\n}\n\nint bwt_bwtgen_main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: bwtgen <in.pac> <out.bwt>\\n\");\n\t\treturn 1;\n\t}\n\tbwt_bwtgen(argv[1], argv[2]);\n\treturn 0;\n}\n\n#ifdef MAIN_BWT_GEN\n\nint main(int argc, char *argv[])\n{\n\treturn bwt_bwtgen_main(argc, argv);\n}\n\n#endif\n"
        },
        {
          "name": "bwt_lite.c",
          "type": "blob",
          "size": 2.619140625,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"bwt_lite.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nint is_sa(const uint8_t *T, int *SA, int n);\nint is_bwt(uint8_t *T, int n);\n\nbwtl_t *bwtl_seq2bwtl(int len, const uint8_t *seq)\n{\n\tbwtl_t *b;\n\tint i;\n\tb = (bwtl_t*)calloc(1, sizeof(bwtl_t));\n\tb->seq_len = len;\n\n\t{ // calculate b->bwt\n\t\tuint8_t *s;\n\t\tb->sa = (uint32_t*)calloc(len + 1, 4);\n\t\tis_sa(seq, (int*)b->sa, len);\n\t\ts = (uint8_t*)calloc(len + 1, 1);\n\t\tfor (i = 0; i <= len; ++i) {\n\t\t\tif (b->sa[i] == 0) b->primary = i;\n\t\t\telse s[i] = seq[b->sa[i] - 1];\n\t\t}\n\t\tfor (i = b->primary; i < len; ++i) s[i] = s[i + 1];\n\t\tb->bwt_size = (len + 15) / 16;\n\t\tb->bwt = (uint32_t*)calloc(b->bwt_size, 4);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tb->bwt[i>>4] |= s[i] << ((15 - (i&15)) << 1);\n\t\tfree(s);\n\t}\n\t{ // calculate b->occ\n\t\tuint32_t c[4];\n\t\tb->n_occ = (len + 15) / 16 * 4;\n\t\tb->occ = (uint32_t*)calloc(b->n_occ, 4);\n\t\tmemset(c, 0, 16);\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (i % 16 == 0)\n\t\t\t\tmemcpy(b->occ + (i/16) * 4, c, 16);\n\t\t\t++c[bwtl_B0(b, i)];\n\t\t}\n\t\tmemcpy(b->L2+1, c, 16);\n\t\tfor (i = 2; i < 5; ++i) b->L2[i] += b->L2[i-1];\n\t}\n\t{ // generate cnt_table\n\t\tfor (i = 0; i != 256; ++i) {\n\t\t\tuint32_t j, x = 0;\n\t\t\tfor (j = 0; j != 4; ++j)\n\t\t\t\tx |= (((i&3) == j) + ((i>>2&3) == j) + ((i>>4&3) == j) + (i>>6 == j)) << (j<<3);\n\t\t\tb->cnt_table[i] = x;\n\t\t}\n\t}\n\treturn b;\n}\nuint32_t bwtl_occ(const bwtl_t *bwt, uint32_t k, uint8_t c)\n{\n\tuint32_t n, b;\n\tif (k == bwt->seq_len) return bwt->L2[c+1] - bwt->L2[c];\n\tif (k == (uint32_t)(-1)) return 0;\n\tif (k >= bwt->primary) --k; // because $ is not in bwt\n\tn = bwt->occ[k/16<<2|c];\n\tb = bwt->bwt[k/16] & ~((1U<<((15-(k&15))<<1)) - 1);\n\tn += (bwt->cnt_table[b&0xff] + bwt->cnt_table[b>>8&0xff]\n\t\t  + bwt->cnt_table[b>>16&0xff] + bwt->cnt_table[b>>24]) >> (c<<3) & 0xff;\n\tif (c == 0) n -= 15 - (k&15); // corrected for the masked bits\n\treturn n;\n}\nvoid bwtl_occ4(const bwtl_t *bwt, uint32_t k, uint32_t cnt[4])\n{\n\tuint32_t x, b;\n\tif (k == (uint32_t)(-1)) {\n\t\tmemset(cnt, 0, 16);\n\t\treturn;\n\t}\n\tif (k >= bwt->primary) --k; // because $ is not in bwt\n\tmemcpy(cnt, bwt->occ + (k>>4<<2), 16);\n\tb = bwt->bwt[k>>4] & ~((1U<<((~k&15)<<1)) - 1);\n\tx = bwt->cnt_table[b&0xff] + bwt->cnt_table[b>>8&0xff]\n\t\t+ bwt->cnt_table[b>>16&0xff] + bwt->cnt_table[b>>24];\n\tx -= 15 - (k&15);\n\tcnt[0] += x&0xff; cnt[1] += x>>8&0xff; cnt[2] += x>>16&0xff; cnt[3] += x>>24;\n}\nvoid bwtl_2occ4(const bwtl_t *bwt, uint32_t k, uint32_t l, uint32_t cntk[4], uint32_t cntl[4])\n{\n\tbwtl_occ4(bwt, k, cntk);\n\tbwtl_occ4(bwt, l, cntl);\n}\nvoid bwtl_destroy(bwtl_t *bwt)\n{\n\tif (bwt) {\n\t\tfree(bwt->occ); free(bwt->bwt); free(bwt->sa);\n\t\tfree(bwt);\n\t}\n}\n"
        },
        {
          "name": "bwt_lite.h",
          "type": "blob",
          "size": 0.6376953125,
          "content": "#ifndef BWT_LITE_H_\n#define BWT_LITE_H_\n\n#include <stdint.h>\n\ntypedef struct {\n\tuint32_t seq_len, bwt_size, n_occ;\n\tuint32_t primary;\n\tuint32_t *bwt, *occ, *sa, L2[5];\n\tuint32_t cnt_table[256];\n} bwtl_t;\n\n#define bwtl_B0(b, k) ((b)->bwt[(k)>>4]>>((~(k)&0xf)<<1)&3)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tbwtl_t *bwtl_seq2bwtl(int len, const uint8_t *seq);\n\tuint32_t bwtl_occ(const bwtl_t *bwt, uint32_t k, uint8_t c);\n\tvoid bwtl_occ4(const bwtl_t *bwt, uint32_t k, uint32_t cnt[4]);\n\tvoid bwtl_2occ4(const bwtl_t *bwt, uint32_t k, uint32_t l, uint32_t cntk[4], uint32_t cntl[4]);\n\tvoid bwtl_destroy(bwtl_t *bwt);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwtaln.c",
          "type": "blob",
          "size": 10.7587890625,
          "content": "#include <stdio.h>\n#include <unistd.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <stdint.h>\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"bwtaln.h\"\n#include \"bwtgap.h\"\n#include \"utils.h\"\n#include \"bwa.h\"\n\n#ifdef HAVE_PTHREAD\n#include <pthread.h>\n#endif\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ngap_opt_t *gap_init_opt()\n{\n\tgap_opt_t *o;\n\to = (gap_opt_t*)calloc(1, sizeof(gap_opt_t));\n\t/* IMPORTANT: s_mm*10 should be about the average base error\n\t   rate. Voilating this requirement will break pairing! */\n\to->s_mm = 3; o->s_gapo = 11; o->s_gape = 4;\n\to->max_diff = -1; o->max_gapo = 1; o->max_gape = 6;\n\to->indel_end_skip = 5; o->max_del_occ = 10; o->max_entries = 2000000;\n\to->mode = BWA_MODE_GAPE | BWA_MODE_COMPREAD;\n\to->seed_len = 32; o->max_seed_diff = 2;\n\to->fnr = 0.04;\n\to->n_threads = 1;\n\to->max_top2 = 30;\n\to->trim_qual = 0;\n\treturn o;\n}\n\nint bwa_cal_maxdiff(int l, double err, double thres)\n{\n\tdouble elambda = exp(-l * err);\n\tdouble sum, y = 1.0;\n\tint k, x = 1;\n\tfor (k = 1, sum = elambda; k < 1000; ++k) {\n\t\ty *= l * err;\n\t\tx *= k;\n\t\tsum += elambda * y / x;\n\t\tif (1.0 - sum < thres) return k;\n\t}\n\treturn 2;\n}\n\n// width must be filled as zero\nint bwt_cal_width(const bwt_t *bwt, int len, const ubyte_t *str, bwt_width_t *width)\n{\n\tbwtint_t k, l, ok, ol;\n\tint i, bid;\n\tbid = 0;\n\tk = 0; l = bwt->seq_len;\n\tfor (i = 0; i < len; ++i) {\n\t\tubyte_t c = str[i];\n\t\tif (c < 4) {\n\t\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\t\tk = bwt->L2[c] + ok + 1;\n\t\t\tl = bwt->L2[c] + ol;\n\t\t}\n\t\tif (k > l || c > 3) { // then restart\n\t\t\tk = 0;\n\t\t\tl = bwt->seq_len;\n\t\t\t++bid;\n\t\t}\n\t\twidth[i].w = l - k + 1;\n\t\twidth[i].bid = bid;\n\t}\n\twidth[len].w = 0;\n\twidth[len].bid = ++bid;\n\treturn bid;\n}\n\nvoid bwa_cal_sa_reg_gap(int tid, bwt_t *const bwt, int n_seqs, bwa_seq_t *seqs, const gap_opt_t *opt)\n{\n\tint i, j, max_l = 0, max_len;\n\tgap_stack_t *stack;\n\tbwt_width_t *w, *seed_w;\n\tgap_opt_t local_opt = *opt;\n\n\t// initiate priority stack\n\tfor (i = max_len = 0; i != n_seqs; ++i)\n\t\tif (seqs[i].len > max_len) max_len = seqs[i].len;\n\tif (opt->fnr > 0.0) local_opt.max_diff = bwa_cal_maxdiff(max_len, BWA_AVG_ERR, opt->fnr);\n\tif (local_opt.max_diff < local_opt.max_gapo) local_opt.max_gapo = local_opt.max_diff;\n\tstack = gap_init_stack(local_opt.max_diff, local_opt.max_gapo, local_opt.max_gape, &local_opt);\n\n\tseed_w = (bwt_width_t*)calloc(opt->seed_len+1, sizeof(bwt_width_t));\n\tw = 0;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = seqs + i;\n#ifdef HAVE_PTHREAD\n\t\tif (i % opt->n_threads != tid) continue;\n#endif\n\t\tp->sa = 0; p->type = BWA_TYPE_NO_MATCH; p->c1 = p->c2 = 0; p->n_aln = 0; p->aln = 0;\n\t\tif (max_l < p->len) {\n\t\t\tmax_l = p->len;\n\t\t\tw = (bwt_width_t*)realloc(w, (max_l + 1) * sizeof(bwt_width_t));\n\t\t\tmemset(w, 0, (max_l + 1) * sizeof(bwt_width_t));\n\t\t}\n\t\tbwt_cal_width(bwt, p->len, p->seq, w);\n\t\tif (opt->fnr > 0.0) local_opt.max_diff = bwa_cal_maxdiff(p->len, BWA_AVG_ERR, opt->fnr);\n\t\tlocal_opt.seed_len = opt->seed_len < p->len? opt->seed_len : 0x7fffffff;\n\t\tif (p->len > opt->seed_len)\n\t\t\tbwt_cal_width(bwt, opt->seed_len, p->seq + (p->len - opt->seed_len), seed_w);\n\t\t// core function\n\t\tfor (j = 0; j < p->len; ++j) // we need to complement\n\t\t\tp->seq[j] = p->seq[j] > 3? 4 : 3 - p->seq[j];\n\t\tp->aln = bwt_match_gap(bwt, p->len, p->seq, w, p->len <= opt->seed_len? 0 : seed_w, &local_opt, &p->n_aln, stack);\n\t\t//fprintf(stderr, \"mm=%lld,ins=%lld,del=%lld,gapo=%lld\\n\", p->aln->n_mm, p->aln->n_ins, p->aln->n_del, p->aln->n_gapo);\n\t\t// clean up the unused data in the record\n\t\tfree(p->name); free(p->seq); free(p->rseq); free(p->qual);\n\t\tp->name = 0; p->seq = p->rseq = p->qual = 0;\n\t}\n\tfree(seed_w); free(w);\n\tgap_destroy_stack(stack);\n}\n\n#ifdef HAVE_PTHREAD\ntypedef struct {\n\tint tid;\n\tbwt_t *bwt;\n\tint n_seqs;\n\tbwa_seq_t *seqs;\n\tconst gap_opt_t *opt;\n} thread_aux_t;\n\nstatic void *worker(void *data)\n{\n\tthread_aux_t *d = (thread_aux_t*)data;\n\tbwa_cal_sa_reg_gap(d->tid, d->bwt, d->n_seqs, d->seqs, d->opt);\n\treturn 0;\n}\n#endif\n\nbwa_seqio_t *bwa_open_reads(int mode, const char *fn_fa)\n{\n\tbwa_seqio_t *ks;\n\tif (mode & BWA_MODE_BAM) { // open BAM\n\t\tint which = 0;\n\t\tif (mode & BWA_MODE_BAM_SE) which |= 4;\n\t\tif (mode & BWA_MODE_BAM_READ1) which |= 1;\n\t\tif (mode & BWA_MODE_BAM_READ2) which |= 2;\n\t\tif (which == 0) which = 7; // then read all reads\n\t\tks = bwa_bam_open(fn_fa, which);\n\t} else ks = bwa_seq_open(fn_fa);\n\treturn ks;\n}\n\nvoid bwa_aln_core(const char *prefix, const char *fn_fa, const gap_opt_t *opt)\n{\n\tint i, n_seqs;\n\tlong long tot_seqs = 0;\n\tbwa_seq_t *seqs;\n\tbwa_seqio_t *ks;\n\tclock_t t;\n\tbwt_t *bwt;\n\n\t// initialization\n\tks = bwa_open_reads(opt->mode, fn_fa);\n\n\t{ // load BWT\n\t\tchar *str = (char*)calloc(strlen(prefix) + 10, 1);\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");  bwt = bwt_restore_bwt(str);\n\t\tfree(str);\n\t}\n\n\t// core loop\n\terr_fwrite(SAI_MAGIC, 1, 4, stdout);\n\terr_fwrite(opt, sizeof(gap_opt_t), 1, stdout);\n\twhile ((seqs = bwa_read_seq(ks, 0x40000, &n_seqs, opt->mode, opt->trim_qual)) != 0) {\n\t\ttot_seqs += n_seqs;\n\t\tt = clock();\n\n\t\tfprintf(stderr, \"[bwa_aln_core] calculate SA coordinate... \");\n\n#ifdef HAVE_PTHREAD\n\t\tif (opt->n_threads <= 1) { // no multi-threading at all\n\t\t\tbwa_cal_sa_reg_gap(0, bwt, n_seqs, seqs, opt);\n\t\t} else {\n\t\t\tpthread_t *tid;\n\t\t\tpthread_attr_t attr;\n\t\t\tthread_aux_t *data;\n\t\t\tint j;\n\t\t\tpthread_attr_init(&attr);\n\t\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\t\t\tdata = (thread_aux_t*)calloc(opt->n_threads, sizeof(thread_aux_t));\n\t\t\ttid = (pthread_t*)calloc(opt->n_threads, sizeof(pthread_t));\n\t\t\tfor (j = 0; j < opt->n_threads; ++j) {\n\t\t\t\tdata[j].tid = j; data[j].bwt = bwt;\n\t\t\t\tdata[j].n_seqs = n_seqs; data[j].seqs = seqs; data[j].opt = opt;\n\t\t\t\tpthread_create(&tid[j], &attr, worker, data + j);\n\t\t\t}\n\t\t\tfor (j = 0; j < opt->n_threads; ++j) pthread_join(tid[j], 0);\n\t\t\tfree(data); free(tid);\n\t\t}\n#else\n\t\tbwa_cal_sa_reg_gap(0, bwt, n_seqs, seqs, opt);\n#endif\n\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\n\t\tt = clock();\n\t\tfprintf(stderr, \"[bwa_aln_core] write to the disk... \");\n\t\tfor (i = 0; i < n_seqs; ++i) {\n\t\t\tbwa_seq_t *p = seqs + i;\n\t\t\terr_fwrite(&p->n_aln, 4, 1, stdout);\n\t\t\tif (p->n_aln) err_fwrite(p->aln, sizeof(bwt_aln1_t), p->n_aln, stdout);\n\t\t}\n\t\tfprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\n\t\tbwa_free_read_seq(n_seqs, seqs);\n\t\tfprintf(stderr, \"[bwa_aln_core] %lld sequences have been processed.\\n\", tot_seqs);\n\t}\n\n\t// destroy\n\tbwt_destroy(bwt);\n\tbwa_seq_close(ks);\n}\n\nint bwa_aln(int argc, char *argv[])\n{\n\tint c, opte = -1;\n\tgap_opt_t *opt;\n\tchar *prefix;\n\n\topt = gap_init_opt();\n\twhile ((c = getopt(argc, argv, \"n:o:e:i:d:l:k:LR:m:t:NM:O:E:q:f:b012IYB:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (strstr(optarg, \".\")) opt->fnr = atof(optarg), opt->max_diff = -1;\n\t\t\telse opt->max_diff = atoi(optarg), opt->fnr = -1.0;\n\t\t\tbreak;\n\t\tcase 'o': opt->max_gapo = atoi(optarg); break;\n\t\tcase 'e': opte = atoi(optarg); break;\n\t\tcase 'M': opt->s_mm = atoi(optarg); break;\n\t\tcase 'O': opt->s_gapo = atoi(optarg); break;\n\t\tcase 'E': opt->s_gape = atoi(optarg); break;\n\t\tcase 'd': opt->max_del_occ = atoi(optarg); break;\n\t\tcase 'i': opt->indel_end_skip = atoi(optarg); break;\n\t\tcase 'l': opt->seed_len = atoi(optarg); break;\n\t\tcase 'k': opt->max_seed_diff = atoi(optarg); break;\n\t\tcase 'm': opt->max_entries = atoi(optarg); break;\n\t\tcase 't': opt->n_threads = atoi(optarg); break;\n\t\tcase 'L': opt->mode |= BWA_MODE_LOGGAP; break;\n\t\tcase 'R': opt->max_top2 = atoi(optarg); break;\n\t\tcase 'q': opt->trim_qual = atoi(optarg); break;\n\t\tcase 'N': opt->mode |= BWA_MODE_NONSTOP; opt->max_top2 = 0x7fffffff; break;\n\t\tcase 'f': xreopen(optarg, \"wb\", stdout); break;\n\t\tcase 'b': opt->mode |= BWA_MODE_BAM; break;\n\t\tcase '0': opt->mode |= BWA_MODE_BAM_SE; break;\n\t\tcase '1': opt->mode |= BWA_MODE_BAM_READ1; break;\n\t\tcase '2': opt->mode |= BWA_MODE_BAM_READ2; break;\n\t\tcase 'I': opt->mode |= BWA_MODE_IL13; break;\n\t\tcase 'Y': opt->mode |= BWA_MODE_CFY; break;\n\t\tcase 'B': opt->mode |= atoi(optarg) << 24; break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\tif (opte > 0) {\n\t\topt->max_gape = opte;\n\t\topt->mode &= ~BWA_MODE_GAPE;\n\t}\n\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa aln [options] <prefix> <in.fq>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -n NUM    max #diff (int) or missing prob under %.2f err rate (float) [%.2f]\\n\",\n\t\t\t\tBWA_AVG_ERR, opt->fnr);\n\t\tfprintf(stderr, \"         -o INT    maximum number or fraction of gap opens [%d]\\n\", opt->max_gapo);\n\t\tfprintf(stderr, \"         -e INT    maximum number of gap extensions, -1 for disabling long gaps [-1]\\n\");\n\t\tfprintf(stderr, \"         -i INT    do not put an indel within INT bp towards the ends [%d]\\n\", opt->indel_end_skip);\n\t\tfprintf(stderr, \"         -d INT    maximum occurrences for extending a long deletion [%d]\\n\", opt->max_del_occ);\n\t\tfprintf(stderr, \"         -l INT    seed length [%d]\\n\", opt->seed_len);\n\t\tfprintf(stderr, \"         -k INT    maximum differences in the seed [%d]\\n\", opt->max_seed_diff);\n\t\tfprintf(stderr, \"         -m INT    maximum entries in the queue [%d]\\n\", opt->max_entries);\n\t\tfprintf(stderr, \"         -t INT    number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -M INT    mismatch penalty [%d]\\n\", opt->s_mm);\n\t\tfprintf(stderr, \"         -O INT    gap open penalty [%d]\\n\", opt->s_gapo);\n\t\tfprintf(stderr, \"         -E INT    gap extension penalty [%d]\\n\", opt->s_gape);\n\t\tfprintf(stderr, \"         -R INT    stop searching when there are >INT equally best hits [%d]\\n\", opt->max_top2);\n\t\tfprintf(stderr, \"         -q INT    quality threshold for read trimming down to %dbp [%d]\\n\", BWA_MIN_RDLEN, opt->trim_qual);\n        fprintf(stderr, \"         -f FILE   file to write output to instead of stdout\\n\");\n\t\tfprintf(stderr, \"         -B INT    length of barcode\\n\");\n\t\tfprintf(stderr, \"         -L        log-scaled gap penalty for long deletions\\n\");\n\t\tfprintf(stderr, \"         -N        non-iterative mode: search for all n-difference hits (slooow)\\n\");\n\t\tfprintf(stderr, \"         -I        the input is in the Illumina 1.3+ FASTQ-like format\\n\");\n\t\tfprintf(stderr, \"         -b        the input read file is in the BAM format\\n\");\n\t\tfprintf(stderr, \"         -0        use single-end reads only (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -1        use the 1st read in a pair (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -2        use the 2nd read in a pair (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -Y        filter Casava-filtered sequences\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 1;\n\t}\n\tif (opt->fnr > 0.0) {\n\t\tint i, k;\n\t\tfor (i = 17, k = 0; i <= 250; ++i) {\n\t\t\tint l = bwa_cal_maxdiff(i, BWA_AVG_ERR, opt->fnr);\n\t\t\tif (l != k) fprintf(stderr, \"[bwa_aln] %dbp reads: max_diff = %d\\n\", i, l);\n\t\t\tk = l;\n\t\t}\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\tbwa_aln_core(prefix, argv[optind+1], opt);\n\tfree(opt); free(prefix);\n\treturn 0;\n}\n"
        },
        {
          "name": "bwtaln.h",
          "type": "blob",
          "size": 3.7431640625,
          "content": "#ifndef BWTALN_H\n#define BWTALN_H\n\n#include <stdint.h>\n#include \"bwt.h\"\n\n#define BWA_TYPE_NO_MATCH 0\n#define BWA_TYPE_UNIQUE 1\n#define BWA_TYPE_REPEAT 2\n#define BWA_TYPE_MATESW 3\n\n#define SAM_FPD   1 // paired\n#define SAM_FPP   2 // properly paired\n#define SAM_FSU   4 // self-unmapped\n#define SAM_FMU   8 // mate-unmapped\n#define SAM_FSR  16 // self on the reverse strand\n#define SAM_FMR  32 // mate on the reverse strand\n#define SAM_FR1  64 // this is read one\n#define SAM_FR2 128 // this is read two\n#define SAM_FSC 256 // secondary alignment\n\n#define BWA_AVG_ERR 0.02\n#define BWA_MIN_RDLEN 35 // for read trimming\n\n#define BWA_MAX_BCLEN 63 // maximum barcode length; 127 is the maximum\n\n#ifndef bns_pac\n#define bns_pac(pac, k) ((pac)[(k)>>2] >> ((~(k)&3)<<1) & 3)\n#endif\n\n#define FROM_M 0\n#define FROM_I 1\n#define FROM_D 2\n#define FROM_S 3\n\n#define SAI_MAGIC \"SAI\\1\"\n\ntypedef struct {\n\tbwtint_t w;\n\tint bid;\n} bwt_width_t;\n\ntypedef struct {\n\tuint64_t n_mm:8, n_gapo:8, n_gape:8, score:20, n_ins:10, n_del:10;\n\tbwtint_t k, l;\n} bwt_aln1_t;\n\ntypedef uint16_t bwa_cigar_t;\n/* rgoya: If changing order of bytes, beware of operations like:\n *     s->cigar[0] += s->full_len - s->len;\n */\n#define CIGAR_OP_SHIFT 14\n#define CIGAR_LN_MASK 0x3fff\n\n#define __cigar_op(__cigar) ((__cigar)>>CIGAR_OP_SHIFT)\n#define __cigar_len(__cigar) ((__cigar)&CIGAR_LN_MASK)\n#define __cigar_create(__op, __len) ((__op)<<CIGAR_OP_SHIFT | (__len))\n\ntypedef struct {\n\tuint32_t n_cigar:15, gap:8, mm:8, strand:1;\n\tint ref_shift;\n\tbwtint_t pos;\n\tbwa_cigar_t *cigar;\n} bwt_multi1_t;\n\ntypedef struct {\n\tchar *name;\n\tubyte_t *seq, *rseq, *qual;\n\tuint32_t len:20, strand:1, type:2, dummy:1, extra_flag:8;\n\tuint32_t n_mm:8, n_gapo:8, n_gape:8, mapQ:8;\n\tint score;\n\tint clip_len;\n\t// alignments in SA coordinates\n\tint n_aln;\n\tbwt_aln1_t *aln;\n\t// multiple hits\n\tint n_multi;\n\tbwt_multi1_t *multi;\n\t// alignment information\n\tbwtint_t sa, pos;\n\tuint64_t c1:28, c2:28, seQ:8; // number of top1 and top2 hits; single-end mapQ\n\tint ref_shift;\n\tint n_cigar;\n\tbwa_cigar_t *cigar;\n\t// for multi-threading only\n\tint tid;\n\t// barcode\n\tchar bc[BWA_MAX_BCLEN+1]; // null terminated; up to BWA_MAX_BCLEN bases\n\t// NM and MD tags\n\tuint32_t full_len:20, nm:12;\n\tchar *md;\n} bwa_seq_t;\n\n#define BWA_MODE_GAPE       0x01\n#define BWA_MODE_COMPREAD   0x02\n#define BWA_MODE_LOGGAP     0x04\n#define BWA_MODE_CFY        0x08\n#define BWA_MODE_NONSTOP    0x10\n#define BWA_MODE_BAM        0x20\n#define BWA_MODE_BAM_SE     0x40\n#define BWA_MODE_BAM_READ1  0x80\n#define BWA_MODE_BAM_READ2  0x100\n#define BWA_MODE_IL13       0x200\n\ntypedef struct {\n\tint s_mm, s_gapo, s_gape;\n\tint mode; // bit 24-31 are the barcode length\n\tint indel_end_skip, max_del_occ, max_entries;\n\tfloat fnr;\n\tint max_diff, max_gapo, max_gape;\n\tint max_seed_diff, seed_len;\n\tint n_threads;\n\tint max_top2;\n\tint trim_qual;\n} gap_opt_t;\n\n#define BWA_PET_STD   1\n\ntypedef struct {\n\tint max_isize, force_isize;\n\tint max_occ;\n\tint n_multi, N_multi;\n\tint type, is_sw, is_preload;\n\tdouble ap_prior;\n} pe_opt_t;\n\nstruct __bwa_seqio_t;\ntypedef struct __bwa_seqio_t bwa_seqio_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tgap_opt_t *gap_init_opt();\n\tvoid bwa_aln_core(const char *prefix, const char *fn_fa, const gap_opt_t *opt);\n\n\tbwa_seqio_t *bwa_seq_open(const char *fn);\n\tbwa_seqio_t *bwa_bam_open(const char *fn, int which);\n\tvoid bwa_seq_close(bwa_seqio_t *bs);\n\tvoid seq_reverse(int len, ubyte_t *seq, int is_comp);\n\tbwa_seq_t *bwa_read_seq(bwa_seqio_t *seq, int n_needed, int *n, int mode, int trim_qual);\n\tvoid bwa_free_read_seq(int n_seqs, bwa_seq_t *seqs);\n\n\tint bwa_cal_maxdiff(int l, double err, double thres);\n\tvoid bwa_cal_sa_reg_gap(int tid, bwt_t *const bwt, int n_seqs, bwa_seq_t *seqs, const gap_opt_t *opt);\n\n\tvoid bwa_cs2nt_core(bwa_seq_t *p, bwtint_t l_pac, ubyte_t *pac);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwtgap.c",
          "type": "blob",
          "size": 8.9404296875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"bwtgap.h\"\n#include \"bwtaln.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define STATE_M 0\n#define STATE_I 1\n#define STATE_D 2\n\n#define aln_score(m,o,e,p) ((m)*(p)->s_mm + (o)*(p)->s_gapo + (e)*(p)->s_gape)\n\ngap_stack_t *gap_init_stack2(int max_score)\n{\n\tgap_stack_t *stack;\n\tstack = (gap_stack_t*)calloc(1, sizeof(gap_stack_t));\n\tstack->n_stacks = max_score;\n\tstack->stacks = (gap_stack1_t*)calloc(stack->n_stacks, sizeof(gap_stack1_t));\n\treturn stack;\n}\n\ngap_stack_t *gap_init_stack(int max_mm, int max_gapo, int max_gape, const gap_opt_t *opt)\n{\n\treturn gap_init_stack2(aln_score(max_mm+1, max_gapo+1, max_gape+1, opt));\n}\n\nvoid gap_destroy_stack(gap_stack_t *stack)\n{\n\tint i;\n\tfor (i = 0; i != stack->n_stacks; ++i) free(stack->stacks[i].stack);\n\tfree(stack->stacks);\n\tfree(stack);\n}\n\nstatic void gap_reset_stack(gap_stack_t *stack)\n{\n\tint i;\n\tfor (i = 0; i != stack->n_stacks; ++i)\n\t\tstack->stacks[i].n_entries = 0;\n\tstack->best = stack->n_stacks;\n\tstack->n_entries = 0;\n}\n\nstatic inline void gap_push(gap_stack_t *stack, int i, bwtint_t k, bwtint_t l, int n_mm, int n_gapo, int n_gape, int n_ins, int n_del,\n\t\t\t\t\t\t\tint state, int is_diff, const gap_opt_t *opt)\n{\n\tint score;\n\tgap_entry_t *p;\n\tgap_stack1_t *q;\n\tscore = aln_score(n_mm, n_gapo, n_gape, opt);\n\tq = stack->stacks + score;\n\tif (q->n_entries == q->m_entries) {\n\t\tq->m_entries = q->m_entries? q->m_entries<<1 : 4;\n\t\tq->stack = (gap_entry_t*)realloc(q->stack, sizeof(gap_entry_t) * q->m_entries);\n\t}\n\tp = q->stack + q->n_entries;\n\tp->info = (uint32_t)score<<21 | i; p->k = k; p->l = l;\n\tp->n_mm = n_mm; p->n_gapo = n_gapo; p->n_gape = n_gape;\n\tp->n_ins = n_ins; p->n_del = n_del;\n\tp->state = state; \n\tp->last_diff_pos = is_diff? i : 0;\n\t++(q->n_entries);\n\t++(stack->n_entries);\n\tif (stack->best > score) stack->best = score;\n}\n\nstatic inline void gap_pop(gap_stack_t *stack, gap_entry_t *e)\n{\n\tgap_stack1_t *q;\n\tq = stack->stacks + stack->best;\n\t*e = q->stack[q->n_entries - 1];\n\t--(q->n_entries);\n\t--(stack->n_entries);\n\tif (q->n_entries == 0 && stack->n_entries) { // reset best\n\t\tint i;\n\t\tfor (i = stack->best + 1; i < stack->n_stacks; ++i)\n\t\t\tif (stack->stacks[i].n_entries != 0) break;\n\t\tstack->best = i;\n\t} else if (stack->n_entries == 0) stack->best = stack->n_stacks;\n}\n\nstatic inline void gap_shadow(int x, int len, bwtint_t max, int last_diff_pos, bwt_width_t *w)\n{\n\tint i, j;\n\tfor (i = j = 0; i < last_diff_pos; ++i) {\n\t\tif (w[i].w > x) w[i].w -= x;\n\t\telse if (w[i].w == x) {\n\t\t\tw[i].bid = 1;\n\t\t\tw[i].w = max - (++j);\n\t\t} // else should not happen\n\t}\n}\n\nstatic inline int int_log2(uint32_t v)\n{\n\tint c = 0;\n\tif (v & 0xffff0000u) { v >>= 16; c |= 16; }\n\tif (v & 0xff00) { v >>= 8; c |= 8; }\n\tif (v & 0xf0) { v >>= 4; c |= 4; }\n\tif (v & 0xc) { v >>= 2; c |= 2; }\n\tif (v & 0x2) c |= 1;\n\treturn c;\n}\n\nbwt_aln1_t *bwt_match_gap(bwt_t *const bwt, int len, const ubyte_t *seq, bwt_width_t *width,\n\t\t\t\t\t\t  bwt_width_t *seed_width, const gap_opt_t *opt, int *_n_aln, gap_stack_t *stack)\n{ // $seq is the reverse complement of the input read\n\tint best_score = aln_score(opt->max_diff+1, opt->max_gapo+1, opt->max_gape+1, opt);\n\tint best_diff = opt->max_diff + 1, max_diff = opt->max_diff;\n\tint best_cnt = 0;\n\tint max_entries = 0, j, _j, n_aln, m_aln;\n\tbwt_aln1_t *aln;\n\n\tm_aln = 4; n_aln = 0;\n\taln = (bwt_aln1_t*)calloc(m_aln, sizeof(bwt_aln1_t));\n\n\t// check whether there are too many N\n\tfor (j = _j = 0; j < len; ++j)\n\t\tif (seq[j] > 3) ++_j;\n\tif (_j > max_diff) {\n\t\t*_n_aln = n_aln;\n\t\treturn aln;\n\t}\n\n\t//for (j = 0; j != len; ++j) printf(\"#0 %d: [%d,%u]\\t[%d,%u]\\n\", j, w[0][j].bid, w[0][j].w, w[1][j].bid, w[1][j].w);\n\tgap_reset_stack(stack); // reset stack\n\tgap_push(stack, len, 0, bwt->seq_len, 0, 0, 0, 0, 0, 0, 0, opt);\n\n\twhile (stack->n_entries) {\n\t\tgap_entry_t e;\n\t\tint i, m, m_seed = 0, hit_found, allow_diff, allow_M, tmp;\n\t\tbwtint_t k, l, cnt_k[4], cnt_l[4], occ;\n\n\t\tif (max_entries < stack->n_entries) max_entries = stack->n_entries;\n\t\tif (stack->n_entries > opt->max_entries) break;\n\t\tgap_pop(stack, &e); // get the best entry\n\t\tk = e.k; l = e.l; // SA interval\n\t\ti = e.info&0xffff; // length\n\t\tif (!(opt->mode & BWA_MODE_NONSTOP) && e.info>>21 > best_score + opt->s_mm) break; // no need to proceed\n\n\t\tm = max_diff - (e.n_mm + e.n_gapo);\n\t\tif (opt->mode & BWA_MODE_GAPE) m -= e.n_gape;\n\t\tif (m < 0) continue;\n\t\tif (seed_width) { // apply seeding\n\t\t\tm_seed = opt->max_seed_diff - (e.n_mm + e.n_gapo);\n\t\t\tif (opt->mode & BWA_MODE_GAPE) m_seed -= e.n_gape;\n\t\t}\n\t\t//printf(\"#1\\t[%d,%d,%d,%c]\\t[%d,%d,%d]\\t[%u,%u]\\t[%u,%u]\\t%d\\n\", stack->n_entries, a, i, \"MID\"[e.state], e.n_mm, e.n_gapo, e.n_gape, width[i-1].bid, width[i-1].w, k, l, e.last_diff_pos);\n\t\tif (i > 0 && m < width[i-1].bid) continue;\n\n\t\t// check whether a hit is found\n\t\thit_found = 0;\n\t\tif (i == 0) hit_found = 1;\n\t\telse if (m == 0 && (e.state == STATE_M || (opt->mode&BWA_MODE_GAPE) || e.n_gape == opt->max_gape)) { // no diff allowed\n\t\t\tif (bwt_match_exact_alt(bwt, i, seq, &k, &l)) hit_found = 1;\n\t\t\telse continue; // no hit, skip\n\t\t}\n\n\t\tif (hit_found) { // action for found hits\n\t\t\tint score = aln_score(e.n_mm, e.n_gapo, e.n_gape, opt);\n\t\t\tint do_add = 1;\n\t\t\t//printf(\"#2 hits found: %d:(%u,%u)\\n\", e.n_mm+e.n_gapo, k, l);\n\t\t\tif (n_aln == 0) {\n\t\t\t\tbest_score = score;\n\t\t\t\tbest_diff = e.n_mm + e.n_gapo;\n\t\t\t\tif (opt->mode & BWA_MODE_GAPE) best_diff += e.n_gape;\n\t\t\t\tif (!(opt->mode & BWA_MODE_NONSTOP))\n\t\t\t\t\tmax_diff = (best_diff + 1 > opt->max_diff)? opt->max_diff : best_diff + 1; // top2 behaviour\n\t\t\t}\n\t\t\tif (score == best_score) best_cnt += l - k + 1;\n\t\t\telse if (best_cnt > opt->max_top2) break; // top2b behaviour\n\t\t\tif (e.n_gapo) { // check whether the hit has been found. this may happen when a gap occurs in a tandem repeat\n\t\t\t\tfor (j = 0; j != n_aln; ++j)\n\t\t\t\t\tif (aln[j].k == k && aln[j].l == l) break;\n\t\t\t\tif (j < n_aln) do_add = 0;\n\t\t\t}\n\t\t\tif (do_add) { // append\n\t\t\t\tbwt_aln1_t *p;\n\t\t\t\tgap_shadow(l - k + 1, len, bwt->seq_len, e.last_diff_pos, width);\n\t\t\t\tif (n_aln == m_aln) {\n\t\t\t\t\tm_aln <<= 1;\n\t\t\t\t\taln = (bwt_aln1_t*)realloc(aln, m_aln * sizeof(bwt_aln1_t));\n\t\t\t\t\tmemset(aln + m_aln/2, 0, m_aln/2*sizeof(bwt_aln1_t));\n\t\t\t\t}\n\t\t\t\tp = aln + n_aln;\n\t\t\t\tp->n_mm = e.n_mm; p->n_gapo = e.n_gapo; p->n_gape = e.n_gape;\n\t\t\t\tp->n_ins = e.n_ins; p->n_del = e.n_del;\n\t\t\t\tp->k = k; p->l = l;\n\t\t\t\tp->score = score;\n\t\t\t\t//fprintf(stderr, \"*** n_mm=%d,n_gapo=%d,n_gape=%d,n_ins=%d,n_del=%d\\n\", e.n_mm, e.n_gapo, e.n_gape, e.n_ins, e.n_del);\n\t\t\t\t++n_aln;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t--i;\n\t\tbwt_2occ4(bwt, k - 1, l, cnt_k, cnt_l); // retrieve Occ values\n\t\tocc = l - k + 1;\n\t\t// test whether diff is allowed\n\t\tallow_diff = allow_M = 1;\n\t\tif (i > 0) {\n\t\t\tint ii = i - (len - opt->seed_len);\n\t\t\tif (width[i-1].bid > m-1) allow_diff = 0;\n\t\t\telse if (width[i-1].bid == m-1 && width[i].bid == m-1 && width[i-1].w == width[i].w) allow_M = 0;\n\t\t\tif (seed_width && ii > 0) {\n\t\t\t\tif (seed_width[ii-1].bid > m_seed-1) allow_diff = 0;\n\t\t\t\telse if (seed_width[ii-1].bid == m_seed-1 && seed_width[ii].bid == m_seed-1\n\t\t\t\t\t\t && seed_width[ii-1].w == seed_width[ii].w) allow_M = 0;\n\t\t\t}\n\t\t}\n\t\t// indels\n\t\ttmp = (opt->mode & BWA_MODE_LOGGAP)? int_log2(e.n_gape + e.n_gapo)/2+1 : e.n_gapo + e.n_gape;\n\t\tif (allow_diff && i >= opt->indel_end_skip + tmp && len - i >= opt->indel_end_skip + tmp) {\n\t\t\tif (e.state == STATE_M) { // gap open\n\t\t\t\tif (e.n_gapo < opt->max_gapo) { // gap open is allowed\n\t\t\t\t\t// insertion\n\t\t\t\t\tgap_push(stack, i, k, l, e.n_mm, e.n_gapo + 1, e.n_gape, e.n_ins + 1, e.n_del, STATE_I, 1, opt);\n\t\t\t\t\t// deletion\n\t\t\t\t\tfor (j = 0; j != 4; ++j) {\n\t\t\t\t\t\tk = bwt->L2[j] + cnt_k[j] + 1;\n\t\t\t\t\t\tl = bwt->L2[j] + cnt_l[j];\n\t\t\t\t\t\tif (k <= l) gap_push(stack, i + 1, k, l, e.n_mm, e.n_gapo + 1, e.n_gape, e.n_ins, e.n_del + 1, STATE_D, 1, opt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (e.state == STATE_I) { // extention of an insertion\n\t\t\t\tif (e.n_gape < opt->max_gape) // gap extention is allowed\n\t\t\t\t\tgap_push(stack, i, k, l, e.n_mm, e.n_gapo, e.n_gape + 1, e.n_ins + 1, e.n_del, STATE_I, 1, opt);\n\t\t\t} else if (e.state == STATE_D) { // extention of a deletion\n\t\t\t\tif (e.n_gape < opt->max_gape) { // gap extention is allowed\n\t\t\t\t\tif (e.n_gape + e.n_gapo < max_diff || occ < opt->max_del_occ) {\n\t\t\t\t\t\tfor (j = 0; j != 4; ++j) {\n\t\t\t\t\t\t\tk = bwt->L2[j] + cnt_k[j] + 1;\n\t\t\t\t\t\t\tl = bwt->L2[j] + cnt_l[j];\n\t\t\t\t\t\t\tif (k <= l) gap_push(stack, i + 1, k, l, e.n_mm, e.n_gapo, e.n_gape + 1, e.n_ins, e.n_del + 1, STATE_D, 1, opt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// mismatches\n\t\tif (allow_diff && allow_M) { // mismatch is allowed\n\t\t\tfor (j = 1; j <= 4; ++j) {\n\t\t\t\tint c = (seq[i] + j) & 3;\n\t\t\t\tint is_mm = (j != 4 || seq[i] > 3);\n\t\t\t\tk = bwt->L2[c] + cnt_k[c] + 1;\n\t\t\t\tl = bwt->L2[c] + cnt_l[c];\n\t\t\t\tif (k <= l) gap_push(stack, i, k, l, e.n_mm + is_mm, e.n_gapo, e.n_gape, e.n_ins, e.n_del, STATE_M, is_mm, opt);\n\t\t\t}\n\t\t} else if (seq[i] < 4) { // try exact match only\n\t\t\tint c = seq[i] & 3;\n\t\t\tk = bwt->L2[c] + cnt_k[c] + 1;\n\t\t\tl = bwt->L2[c] + cnt_l[c];\n\t\t\tif (k <= l) gap_push(stack, i, k, l, e.n_mm, e.n_gapo, e.n_gape, e.n_ins, e.n_del, STATE_M, 0, opt);\n\t\t}\n\t}\n\n\t*_n_aln = n_aln;\n\t//fprintf(stderr, \"max_entries = %d\\n\", max_entries);\n\treturn aln;\n}\n"
        },
        {
          "name": "bwtgap.h",
          "type": "blob",
          "size": 0.97265625,
          "content": "#ifndef BWTGAP_H_\n#define BWTGAP_H_\n\n#include \"bwt.h\"\n#include \"bwtaln.h\"\n\ntypedef struct { // recursion stack\n\tuint32_t info; // score<<21 | i\n\tuint32_t n_mm:8, n_gapo:8, n_gape:8, state:2, n_seed_mm:6;\n\tuint32_t n_ins:16, n_del:16;\n\tint last_diff_pos;\n\tbwtint_t k, l; // (k,l) is the SA region of [i,n-1]\n} gap_entry_t;\n\ntypedef struct {\n\tint n_entries, m_entries;\n\tgap_entry_t *stack;\n} gap_stack1_t;\n\ntypedef struct {\n\tint n_stacks, best, n_entries;\n\tgap_stack1_t *stacks;\n} gap_stack_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tgap_stack_t *gap_init_stack2(int max_score);\n\tgap_stack_t *gap_init_stack(int max_mm, int max_gapo, int max_gape, const gap_opt_t *opt);\n\tvoid gap_destroy_stack(gap_stack_t *stack);\n\tbwt_aln1_t *bwt_match_gap(bwt_t *const bwt, int len, const ubyte_t *seq, bwt_width_t *w,\n\t\t\t\t\t\t\t  bwt_width_t *seed_w, const gap_opt_t *opt, int *_n_aln, gap_stack_t *stack);\n\tvoid bwa_aln2seq(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwtindex.c",
          "type": "blob",
          "size": 9.671875,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n#include <zlib.h>\n#include \"bntseq.h\"\n#include \"bwa.h\"\n#include \"bwt.h\"\n#include \"utils.h\"\n#include \"rle.h\"\n#include \"rope.h\"\n\n#ifdef _DIVBWT\n#include \"divsufsort.h\"\n#endif\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n\nint is_bwt(ubyte_t *T, int n);\n\nint64_t bwa_seq_len(const char *fn_pac)\n{\n\tFILE *fp;\n\tint64_t pac_len;\n\tubyte_t c;\n\tfp = xopen(fn_pac, \"rb\");\n\terr_fseek(fp, -1, SEEK_END);\n\tpac_len = err_ftell(fp);\n\terr_fread_noeof(&c, 1, 1, fp);\n\terr_fclose(fp);\n\treturn (pac_len - 1) * 4 + (int)c;\n}\n\nbwt_t *bwt_pac2bwt(const char *fn_pac, int use_is)\n{\n\tbwt_t *bwt;\n\tubyte_t *buf, *buf2;\n\tint64_t i, pac_size;\n\tFILE *fp;\n\n\t// initialization\n\tbwt = (bwt_t*)calloc(1, sizeof(bwt_t));\n\tbwt->seq_len = bwa_seq_len(fn_pac);\n\tbwt->bwt_size = (bwt->seq_len + 15) >> 4;\n\tfp = xopen(fn_pac, \"rb\");\n\n\t// prepare sequence\n\tpac_size = (bwt->seq_len>>2) + ((bwt->seq_len&3) == 0? 0 : 1);\n\tbuf2 = (ubyte_t*)calloc(pac_size, 1);\n\terr_fread_noeof(buf2, 1, pac_size, fp);\n\terr_fclose(fp);\n\tmemset(bwt->L2, 0, 5 * 4);\n\tbuf = (ubyte_t*)calloc(bwt->seq_len + 1, 1);\n\tfor (i = 0; i < bwt->seq_len; ++i) {\n\t\tbuf[i] = buf2[i>>2] >> ((3 - (i&3)) << 1) & 3;\n\t\t++bwt->L2[1+buf[i]];\n\t}\n\tfor (i = 2; i <= 4; ++i) bwt->L2[i] += bwt->L2[i-1];\n\tfree(buf2);\n\n\t// Burrows-Wheeler Transform\n\tif (use_is) {\n\t\tbwt->primary = is_bwt(buf, bwt->seq_len);\n\t} else {\n\t\trope_t *r;\n\t\tint64_t x;\n\t\trpitr_t itr;\n\t\tconst uint8_t *blk;\n\n\t\tr = rope_init(ROPE_DEF_MAX_NODES, ROPE_DEF_BLOCK_LEN);\n\t\tfor (i = bwt->seq_len - 1, x = 0; i >= 0; --i) {\n\t\t\tint c = buf[i] + 1;\n\t\t\tx = rope_insert_run(r, x, c, 1, 0) + 1;\n\t\t\twhile (--c >= 0) x += r->c[c];\n\t\t}\n\t\tbwt->primary = x;\n\t\trope_itr_first(r, &itr);\n\t\tx = 0;\n\t\twhile ((blk = rope_itr_next_block(&itr)) != 0) {\n\t\t\tconst uint8_t *q = blk + 2, *end = blk + 2 + *rle_nptr(blk);\n\t\t\twhile (q < end) {\n\t\t\t\tint c = 0;\n\t\t\t\tint64_t l;\n\t\t\t\trle_dec1(q, c, l);\n\t\t\t\tfor (i = 0; i < l; ++i)\n\t\t\t\t\tbuf[x++] = c - 1;\n\t\t\t}\n\t\t}\n\t\trope_destroy(r);\n\t}\n\tbwt->bwt = (uint32_t*)calloc(bwt->bwt_size, 4);\n\tfor (i = 0; i < bwt->seq_len; ++i)\n\t\tbwt->bwt[i>>4] |= buf[i] << ((15 - (i&15)) << 1);\n\tfree(buf);\n\treturn bwt;\n}\n\nint bwa_pac2bwt(int argc, char *argv[]) // the \"pac2bwt\" command; IMPORTANT: bwt generated at this step CANNOT be used with BWA. bwtupdate is required!\n{\n\tbwt_t *bwt;\n\tint c, use_is = 1;\n\twhile ((c = getopt(argc, argv, \"d\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'd': use_is = 0; break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"Usage: bwa pac2bwt [-d] <in.pac> <out.bwt>\\n\");\n\t\treturn 1;\n\t}\n\tbwt = bwt_pac2bwt(argv[optind], use_is);\n\tbwt_dump_bwt(argv[optind+1], bwt);\n\tbwt_destroy(bwt);\n\treturn 0;\n}\n\n#define bwt_B00(b, k) ((b)->bwt[(k)>>4]>>((~(k)&0xf)<<1)&3)\n\nvoid bwt_bwtupdate_core(bwt_t *bwt)\n{\n\tbwtint_t i, k, c[4], n_occ;\n\tuint32_t *buf;\n\n\tn_occ = (bwt->seq_len + OCC_INTERVAL - 1) / OCC_INTERVAL + 1;\n\tbwt->bwt_size += n_occ * sizeof(bwtint_t); // the new size\n\tbuf = (uint32_t*)calloc(bwt->bwt_size, 4); // will be the new bwt\n\tc[0] = c[1] = c[2] = c[3] = 0;\n\tfor (i = k = 0; i < bwt->seq_len; ++i) {\n\t\tif (i % OCC_INTERVAL == 0) {\n\t\t\tmemcpy(buf + k, c, sizeof(bwtint_t) * 4);\n\t\t\tk += sizeof(bwtint_t); // in fact: sizeof(bwtint_t)=4*(sizeof(bwtint_t)/4)\n\t\t}\n\t\tif (i % 16 == 0) buf[k++] = bwt->bwt[i/16]; // 16 == sizeof(uint32_t)/2\n\t\t++c[bwt_B00(bwt, i)];\n\t}\n\t// the last element\n\tmemcpy(buf + k, c, sizeof(bwtint_t) * 4);\n\txassert(k + sizeof(bwtint_t) == bwt->bwt_size, \"inconsistent bwt_size\");\n\t// update bwt\n\tfree(bwt->bwt); bwt->bwt = buf;\n}\n\nint bwa_bwtupdate(int argc, char *argv[]) // the \"bwtupdate\" command\n{\n\tbwt_t *bwt;\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"Usage: bwa bwtupdate <the.bwt>\\n\");\n\t\treturn 1;\n\t}\n\tbwt = bwt_restore_bwt(argv[1]);\n\tbwt_bwtupdate_core(bwt);\n\tbwt_dump_bwt(argv[1], bwt);\n\tbwt_destroy(bwt);\n\treturn 0;\n}\n\nint bwa_bwt2sa(int argc, char *argv[]) // the \"bwt2sa\" command\n{\n\tbwt_t *bwt;\n\tint c, sa_intv = 32;\n\twhile ((c = getopt(argc, argv, \"i:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'i': sa_intv = atoi(optarg); break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"Usage: bwa bwt2sa [-i %d] <in.bwt> <out.sa>\\n\", sa_intv);\n\t\treturn 1;\n\t}\n\tbwt = bwt_restore_bwt(argv[optind]);\n\tbwt_cal_sa(bwt, sa_intv);\n\tbwt_dump_sa(argv[optind+1], bwt);\n\tbwt_destroy(bwt);\n\treturn 0;\n}\n\nint bwa_index(int argc, char *argv[]) // the \"index\" command\n{\n\tint c, algo_type = BWTALGO_AUTO, is_64 = 0, block_size = 10000000;\n\tchar *prefix = 0, *str;\n\twhile ((c = getopt(argc, argv, \"6a:p:b:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'a': // if -a is not set, algo_type will be determined later\n\t\t\tif (strcmp(optarg, \"rb2\") == 0) algo_type = BWTALGO_RB2;\n\t\t\telse if (strcmp(optarg, \"bwtsw\") == 0) algo_type = BWTALGO_BWTSW;\n\t\t\telse if (strcmp(optarg, \"is\") == 0) algo_type = BWTALGO_IS;\n\t\t\telse err_fatal(__func__, \"unknown algorithm: '%s'.\", optarg);\n\t\t\tbreak;\n\t\tcase 'p': prefix = strdup(optarg); break;\n\t\tcase '6': is_64 = 1; break;\n\t\tcase 'b':\n\t\t\tblock_size = strtol(optarg, &str, 10);\n\t\t\tif (*str == 'G' || *str == 'g') block_size *= 1024 * 1024 * 1024;\n\t\t\telse if (*str == 'M' || *str == 'm') block_size *= 1024 * 1024;\n\t\t\telse if (*str == 'K' || *str == 'k') block_size *= 1024;\n\t\t\tbreak;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\n\tif (optind + 1 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa index [options] <in.fasta>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -a STR    BWT construction algorithm: bwtsw, is or rb2 [auto]\\n\");\n\t\tfprintf(stderr, \"         -p STR    prefix of the index [same as fasta name]\\n\");\n\t\tfprintf(stderr, \"         -b INT    block size for the bwtsw algorithm (effective with -a bwtsw) [%d]\\n\", block_size);\n\t\tfprintf(stderr, \"         -6        index files named as <in.fasta>.64.* instead of <in.fasta>.* \\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr,\t\"Warning: `-a bwtsw' does not work for short genomes, while `-a is' and\\n\");\n\t\tfprintf(stderr, \"         `-a div' do not work not for long genomes.\\n\\n\");\n\t\treturn 1;\n\t}\n\tif (prefix == 0) {\n\t\tprefix = malloc(strlen(argv[optind]) + 4);\n\t\tstrcpy(prefix, argv[optind]);\n\t\tif (is_64) strcat(prefix, \".64\");\n\t}\n\tbwa_idx_build(argv[optind], prefix, algo_type, block_size);\n\tfree(prefix);\n\treturn 0;\n}\n\nint bwa_idx_build(const char *fa, const char *prefix, int algo_type, int block_size)\n{\n\textern void bwa_pac_rev_core(const char *fn, const char *fn_rev);\n\n\tchar *str, *str2, *str3;\n\tclock_t t;\n\tint64_t l_pac;\n\n\tstr  = (char*)calloc(strlen(prefix) + 10, 1);\n\tstr2 = (char*)calloc(strlen(prefix) + 10, 1);\n\tstr3 = (char*)calloc(strlen(prefix) + 10, 1);\n\n\t{ // nucleotide indexing\n\t\tgzFile fp = xzopen(fa, \"r\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Pack FASTA... \");\n\t\tl_pac = bns_fasta2bntseq(fp, prefix, 0);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t\terr_gzclose(fp);\n\t}\n\tif (algo_type == 0) algo_type = l_pac > 50000000? 2 : 3; // set the algorithm for generating BWT\n\t{\n\t\tstrcpy(str, prefix); strcat(str, \".pac\");\n\t\tstrcpy(str2, prefix); strcat(str2, \".bwt\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Construct BWT for the packed sequence...\\n\");\n\t\tif (algo_type == 2) bwt_bwtgen2(str, str2, block_size);\n\t\telse if (algo_type == 1 || algo_type == 3) {\n\t\t\tbwt_t *bwt;\n\t\t\tbwt = bwt_pac2bwt(str, algo_type == 3);\n\t\t\tbwt_dump_bwt(str2, bwt);\n\t\t\tbwt_destroy(bwt);\n\t\t}\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] %.2f seconds elapse.\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\t{\n\t\tbwt_t *bwt;\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Update BWT... \");\n\t\tbwt = bwt_restore_bwt(str);\n\t\tbwt_bwtupdate_core(bwt);\n\t\tbwt_dump_bwt(str, bwt);\n\t\tbwt_destroy(bwt);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\t{\n\t\tgzFile fp = xzopen(fa, \"r\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Pack forward-only FASTA... \");\n\t\tl_pac = bns_fasta2bntseq(fp, prefix, 1);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t\terr_gzclose(fp);\n\t}\n\t{\n\t\tbwt_t *bwt;\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");\n\t\tstrcpy(str3, prefix); strcat(str3, \".sa\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Construct SA from BWT and Occ... \");\n\t\tbwt = bwt_restore_bwt(str);\n\t\tbwt_cal_sa(bwt, 32);\n\t\tbwt_dump_sa(str3, bwt);\n\t\tbwt_destroy(bwt);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\tfree(str3); free(str2); free(str);\n\treturn 0;\n}\n"
        },
        {
          "name": "bwtsw2.h",
          "type": "blob",
          "size": 1.48828125,
          "content": "#ifndef LH3_BWTSW2_H\n#define LH3_BWTSW2_H\n\n#include <stdint.h>\n#include \"bntseq.h\"\n#include \"bwt_lite.h\"\n#include \"bwt.h\"\n\n#define BSW2_FLAG_MATESW  0x100\n#define BSW2_FLAG_TANDEM  0x200\n#define BSW2_FLAG_MOVED   0x400\n#define BSW2_FLAG_RESCUED 0x800\n\ntypedef struct {\n\tint skip_sw:8, cpy_cmt:8, hard_clip:16;\n\tint a, b, q, r, t, qr, bw, max_ins, max_chain_gap;\n\tint z, is, t_seeds, multi_2nd;\n\tfloat mask_level, coef;\n\tint n_threads, chunk_size;\n} bsw2opt_t;\n\ntypedef struct {\n\tbwtint_t k, l;\n\tuint32_t flag:18, n_seeds:13, is_rev:1;\n\tint len, G, G2;\n\tint beg, end;\n} bsw2hit_t;\n\ntypedef struct {\n\tint flag, nn, n_cigar, chr, pos, qual, mchr, mpos, pqual, isize, nm;\n\tuint32_t *cigar;\n} bsw2aux_t;\n\ntypedef struct {\n\tint n, max;\n\tbsw2hit_t *hits;\n\tbsw2aux_t *aux;\n} bwtsw2_t;\n\ntypedef struct {\n\tvoid *stack;\n\tint max_l;\n\tuint8_t *aln_mem;\n} bsw2global_t;\n\ntypedef struct {\n\tint l, tid;\n\tchar *name, *seq, *qual, *sam, *comment;\n} bsw2seq1_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tbsw2opt_t *bsw2_init_opt();\n\tbwtsw2_t **bsw2_core(const bntseq_t *bns, const bsw2opt_t *opt, const bwtl_t *target, const bwt_t *query, bsw2global_t *pool);\n\tvoid bsw2_aln(const bsw2opt_t *opt, const bntseq_t *bns, bwt_t * const target, const char *fn, const char *fn2);\n\tvoid bsw2_destroy(bwtsw2_t *b);\n\n\tbsw2global_t *bsw2_global_init();\n\tvoid bsw2_global_destroy(bsw2global_t *_pool);\n\n\tvoid bsw2_pair(const bsw2opt_t *opt, int64_t l_pac, const uint8_t *pac, int n, bsw2seq1_t *seq, bwtsw2_t **hit);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bwtsw2_aux.c",
          "type": "blob",
          "size": 24.37890625,
          "content": "#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#ifdef HAVE_PTHREAD\n#include <pthread.h>\n#endif\n#include \"bntseq.h\"\n#include \"bwt_lite.h\"\n#include \"utils.h\"\n#include \"bwtsw2.h\"\n#include \"kstring.h\"\n#include \"bwa.h\"\n#include \"ksw.h\"\n\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\n#include \"ksort.h\"\n#define __left_lt(a, b) ((a).end > (b).end)\nKSORT_INIT(hit, bsw2hit_t, __left_lt)\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n\nextern unsigned char nst_nt4_table[256];\n\nunsigned char nt_comp_table[256] = {\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','T','V','G', 'H','N','N','C', 'D','N','N','M', 'N','K','N','N',\n\t'N','N','Y','S', 'A','N','B','W', 'X','R','N','N', 'N','N','N','N',\n\t'n','t','v','g', 'h','n','n','c', 'd','n','n','m', 'n','k','n','n',\n\t'n','n','y','s', 'a','n','b','w', 'x','r','n','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',\n\t'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N'\n};\n\nextern int bsw2_resolve_duphits(const bntseq_t *bns, const bwt_t *bwt, bwtsw2_t *b, int IS);\nextern int bsw2_resolve_query_overlaps(bwtsw2_t *b, float mask_level);\n\nbsw2opt_t *bsw2_init_opt()\n{\n\tbsw2opt_t *o = (bsw2opt_t*)calloc(1, sizeof(bsw2opt_t));\n\to->a = 1; o->b = 3; o->q = 5; o->r = 2; o->t = 30;\n\to->bw = 50;\n\to->max_ins = 20000;\n\to->z = 1; o->is = 3; o->t_seeds = 5; o->hard_clip = 0; o->skip_sw = 0;\n\to->mask_level = 0.50f; o->coef = 5.5f;\n\to->qr = o->q + o->r; o->n_threads = 1; o->chunk_size = 10000000;\n\to->max_chain_gap = 10000;\n\to->cpy_cmt = 0;\n\treturn o;\n}\n\nvoid bsw2_destroy(bwtsw2_t *b)\n{\n\tint i;\n\tif (b == 0) return;\n\tif (b->aux)\n\t\tfor (i = 0; i < b->n; ++i) free(b->aux[i].cigar);\n\tfree(b->aux); free(b->hits);\n\tfree(b);\n}\n\nbwtsw2_t *bsw2_dup_no_cigar(const bwtsw2_t *b)\n{\n\tbwtsw2_t *p;\n\tp = calloc(1, sizeof(bwtsw2_t));\n\tp->max = p->n = b->n;\n\tif (b->n) {\n\t\tkroundup32(p->max);\n\t\tp->hits = calloc(p->max, sizeof(bsw2hit_t));\n\t\tmemcpy(p->hits, b->hits, p->n * sizeof(bsw2hit_t));\n\t}\n\treturn p;\n}\n\n#define __gen_ap(par, opt) do {\t\t\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < 25; ++i) (par).matrix[i] = -(opt)->b;\t\\\n\t\tfor (i = 0; i < 4; ++i) (par).matrix[i*5+i] = (opt)->a; \\\n\t\t(par).gap_open = (opt)->q; (par).gap_ext = (opt)->r;\t\\\n\t\t(par).gap_end = (opt)->r;\t\t\t\t\t\t\t\t\\\n\t\t(par).row = 5; (par).band_width = opt->bw;\t\t\t\t\\\n\t} while (0)\n\nvoid bsw2_extend_left(const bsw2opt_t *opt, bwtsw2_t *b, uint8_t *_query, int lq, uint8_t *pac, bwtint_t l_pac, uint8_t *_mem)\n{\n\tint i;\n\tbwtint_t k;\n\tuint8_t *target = 0, *query;\n\tint8_t mat[25];\n\n\tbwa_fill_scmat(opt->a, opt->b, mat);\n\tquery = calloc(lq, 1);\n\t// sort according to the descending order of query end\n\tks_introsort(hit, b->n, b->hits);\n\ttarget = calloc(((lq + 1) / 2 * opt->a + opt->r) / opt->r + lq, 1);\n\t// reverse _query\n\tfor (i = 0; i < lq; ++i) query[lq - i - 1] = _query[i];\n\t// core loop\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tint lt = ((p->beg + 1) / 2 * opt->a + opt->r) / opt->r + lq;\n\t\tint score, j, qle, tle;\n\t\tp->n_seeds = 1;\n\t\tif (p->l || p->k == 0) continue;\n\t\tfor (j = score = 0; j < i; ++j) {\n\t\t\tbsw2hit_t *q = b->hits + j;\n\t\t\tif (q->beg <= p->beg && q->k <= p->k && q->k + q->len >= p->k + p->len) {\n\t\t\t\tif (q->n_seeds < (1<<13) - 2) ++q->n_seeds;\n\t\t\t\t++score;\n\t\t\t}\n\t\t}\n\t\tif (score) continue;\n\t\tif (lt > p->k) lt = p->k;\n\t\tfor (k = p->k - 1, j = 0; k > 0 && j < lt; --k) // FIXME: k=0 not considered!\n\t\t\ttarget[j++] = pac[k>>2] >> (~k&3)*2 & 0x3;\n\t\tlt = j;\n\t\tscore = ksw_extend(p->beg, &query[lq - p->beg], lt, target, 5, mat, opt->q, opt->r, opt->bw, 0, -1, p->G, &qle, &tle, 0, 0, 0);\n\t\tif (score > p->G) { // extensible\n\t\t\tp->G = score;\n\t\t\tp->k -= tle;\n\t\t\tp->len += tle;\n\t\t\tp->beg -= qle;\n\t\t}\n\t}\n\tfree(query); free(target);\n}\n\nvoid bsw2_extend_rght(const bsw2opt_t *opt, bwtsw2_t *b, uint8_t *query, int lq, uint8_t *pac, bwtint_t l_pac, uint8_t *_mem)\n{\n\tint i;\n\tbwtint_t k;\n\tuint8_t *target;\n\tint8_t mat[25];\n\n\tbwa_fill_scmat(opt->a, opt->b, mat);\n\ttarget = calloc(((lq + 1) / 2 * opt->a + opt->r) / opt->r + lq, 1);\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tint lt = ((lq - p->beg + 1) / 2 * opt->a + opt->r) / opt->r + lq;\n\t\tint j, score, qle, tle;\n\t\tif (p->l) continue;\n\t\tfor (k = p->k, j = 0; k < p->k + lt && k < l_pac; ++k)\n\t\t\ttarget[j++] = pac[k>>2] >> (~k&3)*2 & 0x3;\n\t\tlt = j;\n\t\tscore = ksw_extend(lq - p->beg, &query[p->beg], lt, target, 5, mat, opt->q, opt->r, opt->bw, 0, -1, 1, &qle, &tle, 0, 0, 0) - 1;\n//\t\tif (score < p->G) fprintf(stderr, \"[bsw2_extend_hits] %d < %d\\n\", score, p->G);\n\t\tif (score >= p->G) {\n\t\t\tp->G = score;\n\t\t\tp->len = tle;\n\t\t\tp->end = p->beg + qle;\n\t\t}\n\t}\n\tfree(target);\n}\n\n/* generate CIGAR array(s) in b->cigar[] */\nstatic void gen_cigar(const bsw2opt_t *opt, int lq, uint8_t *seq[2], int64_t l_pac, const uint8_t *pac, bwtsw2_t *b, const char *name)\n{\n\tint i;\n\tint8_t mat[25];\n\n\tbwa_fill_scmat(opt->a, opt->b, mat);\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tbsw2aux_t *q = b->aux + i;\n\t\tuint8_t *query;\n\t\tint beg, end, score;\n\t\tif (p->l) continue;\n\t\tbeg = (p->flag & 0x10)? lq - p->end : p->beg;\n\t\tend = (p->flag & 0x10)? lq - p->beg : p->end;\n\t\tquery = seq[(p->flag & 0x10)? 1 : 0] + beg;\n\t\tq->cigar = bwa_gen_cigar(mat, opt->q, opt->r, opt->bw, l_pac, pac, end - beg, query, p->k, p->k + p->len, &score, &q->n_cigar, &q->nm);\n#if 0\n\t\tif (name && score != p->G) { // debugging only\n\t\t\tint j, glen = 0;\n\t\t\tfor (j = 0; j < q->n_cigar; ++j)\n\t\t\t\tif ((q->cigar[j]&0xf) == 1 || (q->cigar[j]&0xf) == 2)\n\t\t\t\t\tglen += q->cigar[j]>>4;\n\t\t\tfprintf(stderr, \"[E::%s] %s - unequal score: %d != %d; (qlen, aqlen, arlen, glen, bw) = (%d, %d, %d, %d, %d)\\n\",\n\t\t\t\t\t__func__, name, score, p->G, lq, end - beg, p->len, glen, opt->bw);\n\t\t}\n#endif\n\t\tif (q->cigar && (beg != 0 || end < lq)) { // write soft clipping\n\t\t\tq->cigar = realloc(q->cigar, 4 * (q->n_cigar + 2));\n\t\t\tif (beg != 0) {\n\t\t\t\tmemmove(q->cigar + 1, q->cigar, q->n_cigar * 4);\n\t\t\t\tq->cigar[0] = beg<<4 | 4;\n\t\t\t\t++q->n_cigar;\n\t\t\t}\n\t\t\tif (end < lq) {\n\t\t\t\tq->cigar[q->n_cigar] = (lq - end)<<4 | 4;\n\t\t\t\t++q->n_cigar;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* this is for the debugging purpose only */\nvoid bsw2_debug_hits(const bwtsw2_t *b)\n{\n\tint i;\n\tprintf(\"# raw hits: %d\\n\", b->n);\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tif (p->G > 0)\n\t\t\tprintf(\"G=%d, G2=%d, len=%d, [%d,%d), k=%lu, l=%lu, #seeds=%d, is_rev=%d\\n\", p->G, p->G2, p->len, p->beg, p->end, (long)p->k, (long)p->l, p->n_seeds, p->is_rev);\n\t}\n}\n\nstatic void merge_hits(bwtsw2_t *b[2], int l, int is_reverse)\n{\n\tint i;\n\tif (b[0]->n + b[1]->n > b[0]->max) {\n\t\tb[0]->max = b[0]->n + b[1]->n;\n\t\tb[0]->hits = realloc(b[0]->hits, b[0]->max * sizeof(bsw2hit_t));\n\t}\n\tfor (i = 0; i < b[1]->n; ++i) {\n\t\tbsw2hit_t *p = b[0]->hits + b[0]->n + i;\n\t\t*p = b[1]->hits[i];\n\t\tif (is_reverse) {\n\t\t\tint x = p->beg;\n\t\t\tp->beg = l - p->end;\n\t\t\tp->end = l - x;\n\t\t\tp->flag |= 0x10;\n\t\t}\n\t}\n\tb[0]->n += b[1]->n;\n\tbsw2_destroy(b[1]);\n\tb[1] = 0;\n}\n/* seq[0] is the forward sequence and seq[1] is the reverse complement. */\nstatic bwtsw2_t *bsw2_aln1_core(const bsw2opt_t *opt, const bntseq_t *bns, uint8_t *pac, const bwt_t *target,\n\t\t\t\t\t\t\t\tint l, uint8_t *seq[2], bsw2global_t *pool)\n{\n\textern void bsw2_chain_filter(const bsw2opt_t *opt, int len, bwtsw2_t *b[2]);\n\tbwtsw2_t *b[2], **bb[2], **_b, *p;\n\tint k, j;\n\tbwtl_t *query;\n\tquery = bwtl_seq2bwtl(l, seq[0]);\n\t_b = bsw2_core(bns, opt, query, target, pool);\n\tbwtl_destroy(query);\n\tfor (k = 0; k < 2; ++k) {\n\t\tbb[k] = calloc(2, sizeof(void*));\n\t\tbb[k][0] = calloc(1, sizeof(bwtsw2_t));\n\t\tbb[k][1] = calloc(1, sizeof(bwtsw2_t));\n\t}\n\tfor (k = 0; k < 2; ++k) { // separate _b into bb[2] based on the strand\n\t\tfor (j = 0; j < _b[k]->n; ++j) {\n\t\t\tbsw2hit_t *q;\n\t\t\tp = bb[_b[k]->hits[j].is_rev][k];\n\t\t\tif (p->n == p->max) {\n\t\t\t\tp->max = p->max? p->max<<1 : 8;\n\t\t\t\tp->hits = realloc(p->hits, p->max * sizeof(bsw2hit_t));\n\t\t\t}\n\t\t\tq = &p->hits[p->n++];\n\t\t\t*q = _b[k]->hits[j];\n\t\t\tif (_b[k]->hits[j].is_rev) {\n\t\t\t\tint x = q->beg;\n\t\t\t\tq->beg = l - q->end;\n\t\t\t\tq->end = l - x;\n\t\t\t}\n\t\t}\n\t}\n\tb[0] = bb[0][1]; b[1] = bb[1][1]; // bb[*][1] are \"narrow SA hits\"\n\tbsw2_chain_filter(opt, l, b); // NB: only unique seeds are chained\n\tfor (k = 0; k < 2; ++k) {\n\t\tbsw2_extend_left(opt, bb[k][1], seq[k], l, pac, bns->l_pac, pool->aln_mem);\n\t\tmerge_hits(bb[k], l, 0); // bb[k][1] is merged to bb[k][0] here\n\t\tbsw2_resolve_duphits(0, 0, bb[k][0], 0);\n\t\tbsw2_extend_rght(opt, bb[k][0], seq[k], l, pac, bns->l_pac, pool->aln_mem);\n\t\tbsw2_resolve_duphits(0, 0, bb[k][0], 0);\n\t\tb[k] = bb[k][0];\n\t\tfree(bb[k]);\t\t\n\t}\n\tmerge_hits(b, l, 1); // again, b[1] is merged to b[0]\n\tbsw2_resolve_query_overlaps(b[0], opt->mask_level);\n\tbsw2_destroy(_b[0]); bsw2_destroy(_b[1]); free(_b);\n\treturn b[0];\n}\n\n/* set ->flag to records the origin of the hit (to forward bwt or reverse bwt) */\nstatic void flag_fr(bwtsw2_t *b[2])\n{\n\tint i, j;\n\tfor (i = 0; i < b[0]->n; ++i) {\n\t\tbsw2hit_t *p = b[0]->hits + i;\n\t\tp->flag |= 0x10000;\n\t}\n\tfor (i = 0; i < b[1]->n; ++i) {\n\t\tbsw2hit_t *p = b[1]->hits + i;\n\t\tp->flag |= 0x20000;\n\t}\n\tfor (i = 0; i < b[0]->n; ++i) {\n\t\tbsw2hit_t *p = b[0]->hits + i;\n\t\tfor (j = 0; j < b[1]->n; ++j) {\n\t\t\tbsw2hit_t *q = b[1]->hits + j;\n\t\t\tif (q->beg == p->beg && q->end == p->end && q->k == p->k && q->len == p->len && q->G == p->G) {\n\t\t\t\tq->flag |= 0x30000; p->flag |= 0x30000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef struct {\n\tint n, max;\n\tbsw2seq1_t *seq;\n} bsw2seq_t;\n\nstatic int fix_cigar(const bntseq_t *bns, bsw2hit_t *p, int n_cigar, uint32_t *cigar)\n{\n\t// FIXME: this routine does not work if the query bridge three reference sequences\n\tint32_t coor, refl, lq;\n\tint x, y, i, seqid;\n\tbns_cnt_ambi(bns, p->k, p->len, &seqid);\n\tcoor = p->k - bns->anns[seqid].offset;\n\trefl = bns->anns[seqid].len;\n\tx = coor; y = 0;\n\t// test if the alignment goes beyond the boundary\n\tfor (i = 0; i < n_cigar; ++i) {\n\t\tint op = cigar[i]&0xf, ln = cigar[i]>>4;\n\t\tif (op == 1 || op == 4 || op == 5) y += ln;\n\t\telse if (op == 2) x += ln;\n\t\telse x += ln, y += ln;\n\t}\n\tlq = y; // length of the query sequence\n\tif (x > refl) { // then fix it\n\t\tint j, nc, mq[2], nlen[2];\n\t\tuint32_t *cn;\n\t\tbwtint_t kk = 0;\n\t\tnc = mq[0] = mq[1] = nlen[0] = nlen[1] = 0;\n\t\tcn = calloc(n_cigar + 3, 4);\n\t\tx = coor; y = 0;\n\t\tfor (i = j = 0; i < n_cigar; ++i) {\n\t\t\tint op = cigar[i]&0xf, ln = cigar[i]>>4;\n\t\t\tif (op == 4 || op == 5 || op == 1) { // ins or clipping\n\t\t\t\ty += ln;\n\t\t\t\tcn[j++] = cigar[i];\n\t\t\t} else if (op == 2) { // del\n\t\t\t\tif (x + ln >= refl && nc == 0) {\n\t\t\t\t\tcn[j++] = (uint32_t)(lq - y)<<4 | 4;\n\t\t\t\t\tnc = j;\n\t\t\t\t\tcn[j++] = (uint32_t)y<<4 | 4;\n\t\t\t\t\tkk = p->k + (x + ln - refl);\n\t\t\t\t\tnlen[0] = x - coor;\n\t\t\t\t\tnlen[1] = p->len - nlen[0] - ln;\n\t\t\t\t} else cn[j++] = cigar[i];\n\t\t\t\tx += ln;\n\t\t\t} else if (op == 0) { // match\n\t\t\t\tif (x + ln >= refl && nc == 0) {\n\t\t\t\t\t// FIXME: not consider a special case where a split right between M and I\n\t\t\t\t\tcn[j++] = (uint32_t)(refl - x)<<4 | 0; // write M\n\t\t\t\t\tcn[j++] = (uint32_t)(lq - y - (refl - x))<<4 | 4; // write S\n\t\t\t\t\tnc = j;\n\t\t\t\t\tmq[0] += refl - x;\n\t\t\t\t\tcn[j++] = (uint32_t)(y + (refl - x))<<4 | 4;\n\t\t\t\t\tif (x + ln - refl) cn[j++] = (uint32_t)(x + ln - refl)<<4 | 0;\n\t\t\t\t\tmq[1] += x + ln - refl;\n\t\t\t\t\tkk = bns->anns[seqid].offset + refl;\n\t\t\t\t\tnlen[0] = refl - coor;\n\t\t\t\t\tnlen[1] = p->len - nlen[0];\n\t\t\t\t} else {\n\t\t\t\t\tcn[j++] = cigar[i];\n\t\t\t\t\tmq[nc?1:0] += ln;\n\t\t\t\t}\n\t\t\t\tx += ln; y += ln;\n\t\t\t}\n\t\t}\n\t\tif (mq[0] > mq[1]) { // then take the first alignment\n\t\t\tn_cigar = nc;\n\t\t\tmemcpy(cigar, cn, 4 * nc);\n\t\t\tp->len = nlen[0];\n\t\t} else {\n\t\t\tp->k = kk; p->len = nlen[1];\n\t\t\tn_cigar = j - nc;\n\t\t\tmemcpy(cigar, cn + nc, 4 * (j - nc));\n\t\t}\n\t\tfree(cn);\n\t}\n\treturn n_cigar;\n}\n\nstatic void write_aux(const bsw2opt_t *opt, const bntseq_t *bns, int qlen, uint8_t *seq[2], const uint8_t *pac, bwtsw2_t *b, const char *name)\n{\n\tint i;\n\t// allocate for b->aux\n\tif (b->n<<1 < b->max) {\n\t\tb->max = b->n;\n\t\tkroundup32(b->max);\n\t\tb->hits = realloc(b->hits, b->max * sizeof(bsw2hit_t));\n\t}\n\tb->aux = calloc(b->n, sizeof(bsw2aux_t));\n\t// generate CIGAR\n\tgen_cigar(opt, qlen, seq, bns->l_pac, pac, b, name);\n\t// fix CIGAR, generate mapQ, and write chromosomal position\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = &b->hits[i];\n\t\tbsw2aux_t *q = &b->aux[i];\n\t\tq->flag = p->flag & 0xfe;\n\t\tq->isize = 0;\n\t\tif (p->l == 0) { // unique hit\n\t\t\tfloat c = 1.0;\n\t\t\tint subo;\n\t\t\t// fix out-of-boundary CIGAR\n\t\t\tq->n_cigar = fix_cigar(bns, p, q->n_cigar, q->cigar);\n\t\t\t// compute mapQ\n\t\t\tsubo = p->G2 > opt->t? p->G2 : opt->t;\n\t\t\tif (p->flag>>16 == 1 || p->flag>>16 == 2) c *= .5;\n\t\t\tif (p->n_seeds < 2) c *= .2;\n\t\t\tq->qual = (int)(c * (p->G - subo) * (250.0 / p->G + 0.03 / opt->a) + .499);\n\t\t\tif (q->qual > 250) q->qual = 250;\n\t\t\tif (q->qual < 0) q->qual = 0;\n\t\t\tif (p->flag&1) q->qual = 0; // this is a random hit\n\t\t\tq->pqual = q->qual; // set the paired qual as qual\n\t\t\t// get the chromosomal position\n\t\t\tq->nn = bns_cnt_ambi(bns, p->k, p->len, &q->chr);\n\t\t\tq->pos = p->k - bns->anns[q->chr].offset;\n\t\t} else q->qual = 0, q->n_cigar = 0, q->chr = q->pos = -1, q->nn = 0;\n\t}\n}\n\nstatic void update_mate_aux(bwtsw2_t *b, const bwtsw2_t *m)\n{\n\tint i;\n\tif (m == 0) return;\n\t// update flag, mchr and mpos\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2aux_t *q = &b->aux[i];\n\t\tq->flag |= 1; // paired\n\t\tif (m->n == 0) q->flag |= 8; // mate unmapped\n\t\tif (m->n == 1) {\n\t\t\tq->mchr = m->aux[0].chr;\n\t\t\tq->mpos = m->aux[0].pos;\n\t\t\tif (m->aux[0].flag&0x10) q->flag |= 0x20; // mate reverse strand\n\t\t\tif (q->chr == q->mchr) { // set insert size\n\t\t\t\tif (q->mpos + m->hits[0].len > q->pos)\n\t\t\t\t\tq->isize = q->mpos + m->hits[0].len - q->pos;\n\t\t\t\telse q->isize = q->mpos - q->pos - b->hits[0].len;\n\t\t\t} else q->isize = 0;\n\t\t} else q->mchr = q->mpos = -1;\n\t}\n\t// update mapping quality\n\tif (b->n == 1 && m->n == 1) {\n\t\tbsw2hit_t *p = &b->hits[0];\n\t\tif (p->flag & BSW2_FLAG_MATESW) { // this alignment is found by Smith-Waterman\n\t\t\tif (!(p->flag & BSW2_FLAG_TANDEM) && b->aux[0].pqual < 20)\n\t\t\t\tb->aux[0].pqual = 20;\n\t\t\tif (b->aux[0].pqual >= m->aux[0].qual) b->aux[0].pqual = m->aux[0].qual;\n\t\t} else if ((p->flag & 2) && !(m->hits[0].flag & BSW2_FLAG_MATESW)) { // properly paired\n\t\t\tif (!(p->flag & BSW2_FLAG_TANDEM)) { // pqual is bounded by [b->aux[0].qual,m->aux[0].qual]\n\t\t\t\tb->aux[0].pqual += 20;\n\t\t\t\tif (b->aux[0].pqual > m->aux[0].qual) b->aux[0].pqual = m->aux[0].qual;\n\t\t\t\tif (b->aux[0].pqual < b->aux[0].qual) b->aux[0].pqual = b->aux[0].qual;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* generate SAM lines for a sequence in ks with alignment stored in\n * b. ks->name and ks->seq will be freed and set to NULL in the end. */\nstatic void print_hits(const bntseq_t *bns, const bsw2opt_t *opt, bsw2seq1_t *ks, bwtsw2_t *b, int is_pe, bwtsw2_t *bmate)\n{\n\tint i, k;\n\tkstring_t str;\n\tmemset(&str, 0, sizeof(kstring_t));\n\tif (b == 0 || b->n == 0) { // no hits\n\t\tksprintf(&str, \"%s\\t4\\t*\\t0\\t0\\t*\\t*\\t0\\t0\\t\", ks->name);\n\t\tfor (i = 0; i < ks->l; ++i) kputc(ks->seq[i], &str);\n\t\tif (ks->qual) {\n\t\t\tkputc('\\t', &str);\n\t\t\tfor (i = 0; i < ks->l; ++i) kputc(ks->qual[i], &str);\n\t\t} else kputs(\"\\t*\", &str);\n\t\tkputc('\\n', &str);\n\t}\n\tfor (i = 0; b && i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tbsw2aux_t *q = b->aux + i;\n\t\tint j, beg, end, type = 0;\n\t\t// print mandatory fields before SEQ\n\t\tif (q->cigar == 0) q->flag |= 0x4;\n\t\tksprintf(&str, \"%s\\t%d\", ks->name, q->flag | (opt->multi_2nd && i? 0x100 : 0));\n\t\tksprintf(&str, \"\\t%s\\t%ld\", q->chr>=0? bns->anns[q->chr].name : \"*\", (long)q->pos + 1);\n\t\tif (p->l == 0 && q->cigar) { // not a repetitive hit\n\t\t\tksprintf(&str, \"\\t%d\\t\", q->pqual);\n\t\t\tfor (k = 0; k < q->n_cigar; ++k)\n\t\t\t\tksprintf(&str, \"%d%c\", q->cigar[k]>>4, (opt->hard_clip? \"MIDNHHP\" : \"MIDNSHP\")[q->cigar[k]&0xf]);\n\t\t} else ksprintf(&str, \"\\t0\\t*\");\n\t\tif (!is_pe) kputs(\"\\t*\\t0\\t0\\t\", &str);\n\t\telse ksprintf(&str, \"\\t%s\\t%d\\t%d\\t\", q->mchr==q->chr? \"=\" : (q->mchr<0? \"*\" : bns->anns[q->mchr].name), q->mpos+1, q->isize);\n\t\t// get the sequence begin and end\n\t\tbeg = 0; end = ks->l;\n\t\tif (opt->hard_clip && q->cigar) {\n\t\t\tif ((q->cigar[0]&0xf) == 4) beg += q->cigar[0]>>4;\n\t\t\tif ((q->cigar[q->n_cigar-1]&0xf) == 4) end -= q->cigar[q->n_cigar-1]>>4;\n\t\t}\n\t\tfor (j = beg; j < end; ++j) {\n\t\t\tif (p->flag&0x10) kputc(nt_comp_table[(int)ks->seq[ks->l - 1 - j]], &str);\n\t\t\telse kputc(ks->seq[j], &str);\n\t\t}\n\t\t// print base quality if present\n\t\tif (ks->qual) {\n\t\t\tkputc('\\t', &str);\n\t\t\tfor (j = beg; j < end; ++j) {\n\t\t\t\tif (p->flag&0x10) kputc(ks->qual[ks->l - 1 - j], &str);\n\t\t\t\telse kputc(ks->qual[j], &str);\n\t\t\t}\n\t\t} else kputs(\"\\t*\", &str);\n\t\t// print optional tags\n\t\tksprintf(&str, \"\\tAS:i:%d\\tXS:i:%d\\tXF:i:%d\\tXE:i:%d\\tNM:i:%d\", p->G, p->G2, p->flag>>16, p->n_seeds, q->nm);\n\t\tif (q->nn) ksprintf(&str, \"\\tXN:i:%d\", q->nn);\n\t\tif (p->l) ksprintf(&str, \"\\tXI:i:%d\", p->l - p->k + 1);\n\t\tif (p->flag&BSW2_FLAG_MATESW) type |= 1;\n\t\tif (p->flag&BSW2_FLAG_TANDEM) type |= 2;\n\t\tif (type) ksprintf(&str, \"\\tXT:i:%d\", type);\n\t\tif (opt->cpy_cmt && ks->comment) {\n\t\t\tint l = strlen(ks->comment);\n\t\t\tif (l >= 6 && ks->comment[2] == ':' && ks->comment[4] == ':') {\n\t\t\t\tkputc('\\t', &str); kputs(ks->comment, &str);\n\t\t\t}\n\t\t}\n\t\tkputc('\\n', &str);\n\t}\n\tks->sam = str.s;\n\tfree(ks->seq); ks->seq = 0;\n\tfree(ks->qual); ks->qual = 0;\n\tfree(ks->name); ks->name = 0;\n}\n\nstatic void update_opt(bsw2opt_t *dst, const bsw2opt_t *src, int qlen)\n{\n\tdouble ll = log(qlen);\n\tint i, k;\n\t*dst = *src;\n\tif (dst->t < ll * dst->coef) dst->t = (int)(ll * dst->coef + .499);\n\t// set band width: the query length sets a boundary on the maximum band width\n\tk = (qlen * dst->a - 2 * dst->q) / (2 * dst->r + dst->a);\n\ti = (qlen * dst->a - dst->a - dst->t) / dst->r;\n\tif (k > i) k = i;\n\tif (k < 1) k = 1; // I do not know if k==0 causes troubles\n\tdst->bw = src->bw < k? src->bw : k;\n}\n\n/* Core routine to align reads in _seq. It is separated from\n * process_seqs() to realize multi-threading */ \nstatic void bsw2_aln_core(bsw2seq_t *_seq, const bsw2opt_t *_opt, const bntseq_t *bns, uint8_t *pac, const bwt_t *target, int is_pe)\n{\n\tint x;\n\tbsw2opt_t opt;\n\tbsw2global_t *pool = bsw2_global_init();\n\tbwtsw2_t **buf;\n\tbuf = calloc(_seq->n, sizeof(void*));\n\tfor (x = 0; x < _seq->n; ++x) {\n\t\tbsw2seq1_t *p = _seq->seq + x;\n\t\tuint8_t *seq[2], *rseq[2];\n\t\tint i, l, k;\n\t\tbwtsw2_t *b[2];\n\t\tl = p->l;\n\t\tupdate_opt(&opt, _opt, p->l);\n\t\tif (pool->max_l < l) { // then enlarge working space for aln_extend_core()\n\t\t\tint tmp = ((l + 1) / 2 * opt.a + opt.r) / opt.r + l;\n\t\t\tpool->max_l = l;\n\t\t\tpool->aln_mem = realloc(pool->aln_mem, (tmp + 2) * 24);\n\t\t}\n\t\t// set seq[2] and rseq[2]\n\t\tseq[0] = calloc(l * 4, 1);\n\t\tseq[1] = seq[0] + l;\n\t\trseq[0] = seq[1] + l; rseq[1] = rseq[0] + l;\n\t\t// convert sequences to 2-bit representation\n\t\tfor (i = k = 0; i < l; ++i) {\n\t\t\tint c = nst_nt4_table[(int)p->seq[i]];\n\t\t\tif (c >= 4) { c = (int)(drand48() * 4); ++k; } // FIXME: ambiguous bases are not properly handled\n\t\t\tseq[0][i] = c;\n\t\t\tseq[1][l-1-i] = 3 - c;\n\t\t\trseq[0][l-1-i] = 3 - c;\n\t\t\trseq[1][i] = c;\n\t\t}\n\t\tif (l - k < opt.t) { // too few unambiguous bases\n\t\t\tbuf[x] = calloc(1, sizeof(bwtsw2_t));\n\t\t\tfree(seq[0]); continue;\n\t\t}\n\t\t// alignment\n\t\tb[0] = bsw2_aln1_core(&opt, bns, pac, target, l, seq, pool);\n\t\tfor (k = 0; k < b[0]->n; ++k)\n\t\t\tif (b[0]->hits[k].n_seeds < opt.t_seeds) break;\n\t\tif (k < b[0]->n) {\n\t\t\tb[1] = bsw2_aln1_core(&opt, bns, pac, target, l, rseq, pool);\n\t\t\tfor (i = 0; i < b[1]->n; ++i) {\n\t\t\t\tbsw2hit_t *p = &b[1]->hits[i];\n\t\t\t\tint x = p->beg;\n\t\t\t\tp->flag ^= 0x10, p->is_rev ^= 1; // flip the strand\n\t\t\t\tp->beg = l - p->end;\n\t\t\t\tp->end = l - x;\n\t\t\t}\n\t\t\tflag_fr(b);\n\t\t\tmerge_hits(b, l, 0);\n\t\t\tbsw2_resolve_duphits(0, 0, b[0], 0);\n\t\t\tbsw2_resolve_query_overlaps(b[0], opt.mask_level);\n\t\t} else b[1] = 0;\n\t\t// generate CIGAR and print SAM\n\t\tbuf[x] = bsw2_dup_no_cigar(b[0]);\n\t\t// free\n\t\tfree(seq[0]);\n\t\tbsw2_destroy(b[0]);\n\t}\n\tif (is_pe) bsw2_pair(&opt, bns->l_pac, pac, _seq->n, _seq->seq, buf);\n\tfor (x = 0; x < _seq->n; ++x) {\n\t\tbsw2seq1_t *p = _seq->seq + x;\n\t\tuint8_t *seq[2];\n\t\tint i;\n\t\tseq[0] = malloc(p->l * 2); seq[1] = seq[0] + p->l;\n\t\tfor (i = 0; i < p->l; ++i) {\n\t\t\tint c = nst_nt4_table[(int)p->seq[i]];\n\t\t\tif (c >= 4) c = (int)(drand48() * 4);\n\t\t\tseq[0][i] = c;\n\t\t\tseq[1][p->l-1-i] = 3 - c;\n\t\t}\n\t\tupdate_opt(&opt, _opt, p->l);\n\t\twrite_aux(&opt, bns, p->l, seq, pac, buf[x], _seq->seq[x].name);\n\t\tfree(seq[0]);\n\t}\n\tfor (x = 0; x < _seq->n; ++x) {\n\t\tif (is_pe) update_mate_aux(buf[x], buf[x^1]);\n\t\tprint_hits(bns, &opt, &_seq->seq[x], buf[x], is_pe, buf[x^1]);\n\t}\n\tfor (x = 0; x < _seq->n; ++x) bsw2_destroy(buf[x]);\n\tfree(buf);\n\tbsw2_global_destroy(pool);\n}\n\n#ifdef HAVE_PTHREAD\ntypedef struct {\n\tint tid, is_pe;\n\tbsw2seq_t *_seq;\n\tconst bsw2opt_t *_opt;\n\tconst bntseq_t *bns;\n\tuint8_t *pac;\n\tconst bwt_t *target;\n} thread_aux_t;\n\n/* another interface to bsw2_aln_core() to facilitate pthread_create() */\nstatic void *worker(void *data)\n{\n\tthread_aux_t *p = (thread_aux_t*)data;\n\tbsw2_aln_core(p->_seq, p->_opt, p->bns, p->pac, p->target, p->is_pe);\n\treturn 0;\n}\n#endif\n\n/* process sequences stored in _seq, generate SAM lines for these\n * sequences and reset _seq afterwards. */\nstatic void process_seqs(bsw2seq_t *_seq, const bsw2opt_t *opt, const bntseq_t *bns, uint8_t *pac, const bwt_t *target, int is_pe)\n{\n\tint i;\n\tis_pe = is_pe? 1 : 0;\n\n#ifdef HAVE_PTHREAD\n\tif (opt->n_threads <= 1) {\n\t\tbsw2_aln_core(_seq, opt, bns, pac, target, is_pe);\n\t} else {\n\t\tpthread_t *tid;\n\t\tpthread_attr_t attr;\n\t\tthread_aux_t *data;\n\t\tint j;\n\t\tpthread_attr_init(&attr);\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\t\tdata = (thread_aux_t*)calloc(opt->n_threads, sizeof(thread_aux_t));\n\t\ttid = (pthread_t*)calloc(opt->n_threads, sizeof(pthread_t));\n\t\tfor (j = 0; j < opt->n_threads; ++j) {\n\t\t\tthread_aux_t *p = data + j;\n\t\t\tp->tid = j; p->_opt = opt; p->bns = bns; p->is_pe = is_pe;\n\t\t\tp->pac = pac; p->target = target;\n\t\t\tp->_seq = calloc(1, sizeof(bsw2seq_t));\n\t\t\tp->_seq->max = (_seq->n + opt->n_threads - 1) / opt->n_threads + 1;\n\t\t\tp->_seq->n = 0;\n\t\t\tp->_seq->seq = calloc(p->_seq->max, sizeof(bsw2seq1_t));\n\t\t}\n\t\tfor (i = 0; i < _seq->n; ++i) { // assign sequences to each thread\n\t\t\tbsw2seq_t *p = data[(i>>is_pe)%opt->n_threads]._seq;\n\t\t\tp->seq[p->n++] = _seq->seq[i];\n\t\t}\n\t\tfor (j = 0; j < opt->n_threads; ++j) pthread_create(&tid[j], &attr, worker, &data[j]);\n\t\tfor (j = 0; j < opt->n_threads; ++j) pthread_join(tid[j], 0);\n\t\tfor (j = 0; j < opt->n_threads; ++j) data[j]._seq->n = 0;\n\t\tfor (i = 0; i < _seq->n; ++i) { // copy the result from each thread back\n\t\t\tbsw2seq_t *p = data[(i>>is_pe)%opt->n_threads]._seq;\n\t\t\t_seq->seq[i] = p->seq[p->n++];\n\t\t}\n\t\tfor (j = 0; j < opt->n_threads; ++j) {\n\t\t\tthread_aux_t *p = data + j;\n\t\t\tfree(p->_seq->seq);\n\t\t\tfree(p->_seq);\n\t\t}\n\t\tfree(data); free(tid);\n\t}\n#else\n\tbsw2_aln_core(_seq, opt, bns, pac, target, is_pe);\n#endif\n\n\t// print and reset\n\tfor (i = 0; i < _seq->n; ++i) {\n\t\tbsw2seq1_t *p = _seq->seq + i;\n\t\tif (p->sam) err_printf(\"%s\", p->sam);\n\t\tfree(p->name); free(p->seq); free(p->qual); free(p->sam);\n\t\tp->tid = -1; p->l = 0;\n\t\tp->name = p->seq = p->qual = p->sam = 0;\n\t}\n\terr_fflush(stdout);\n\t_seq->n = 0;\n}\n\nvoid bsw2_aln(const bsw2opt_t *opt, const bntseq_t *bns, bwt_t * const target, const char *fn, const char *fn2)\n{\n\tgzFile fp, fp2;\n\tkseq_t *ks, *ks2;\n\tint l, is_pe = 0, i, n;\n\tuint8_t *pac;\n\tbsw2seq_t *_seq;\n\tbseq1_t *bseq;\n\n\tpac = calloc(bns->l_pac/4+1, 1);\n\tfor (l = 0; l < bns->n_seqs; ++l)\n\t\terr_printf(\"@SQ\\tSN:%s\\tLN:%d\\n\", bns->anns[l].name, bns->anns[l].len);\n\terr_fread_noeof(pac, 1, bns->l_pac/4+1, bns->fp_pac);\n\tfp = xzopen(fn, \"r\");\n\tks = kseq_init(fp);\n\t_seq = calloc(1, sizeof(bsw2seq_t));\n\tif (fn2) {\n\t\tfp2 = xzopen(fn2, \"r\");\n\t\tks2 = kseq_init(fp2);\n\t\tis_pe = 1;\n\t} else fp2 = 0, ks2 = 0, is_pe = 0;\n\twhile ((bseq = bseq_read(opt->chunk_size * opt->n_threads, &n, ks, ks2)) != 0) {\n\t\tint size = 0;\n\t\tif (n > _seq->max) {\n\t\t\t_seq->max = n;\n\t\t\tkroundup32(_seq->max);\n\t\t\t_seq->seq = realloc(_seq->seq, _seq->max * sizeof(bsw2seq1_t));\n\t\t}\n\t\t_seq->n = n;\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tbseq1_t *b = &bseq[i];\n\t\t\tbsw2seq1_t *p = &_seq->seq[i];\n\t\t\tp->tid = -1; p->l = b->l_seq;\n\t\t\tp->name = b->name; p->seq = b->seq; p->qual = b->qual; p->comment = b->comment; p->sam = 0;\n\t\t\tsize += p->l;\n\t\t}\n\t\tfprintf(stderr, \"[bsw2_aln] read %d sequences/pairs (%d bp) ...\\n\", n, size);\n\t\tfree(bseq);\n\t\tprocess_seqs(_seq, opt, bns, pac, target, is_pe);\n\t}\n\t// free\n\tfree(pac);\n\tfree(_seq->seq); free(_seq);\n\tkseq_destroy(ks);\n\terr_gzclose(fp);\n\tif (fn2) {\n\t\tkseq_destroy(ks2);\n\t\terr_gzclose(fp2);\n\t}\n}\n"
        },
        {
          "name": "bwtsw2_chain.c",
          "type": "blob",
          "size": 2.9912109375,
          "content": "#include <stdio.h>\n#include \"bwtsw2.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef struct {\n\tuint32_t tbeg, tend;\n\tint qbeg, qend;\n\tuint32_t flag:1, idx:31;\n\tint chain; // also reuse as a counter\n} hsaip_t;\n\n#define _hsaip_lt(a, b) ((a).qbeg < (b).qbeg)\n\n#include \"ksort.h\"\nKSORT_INIT(hsaip, hsaip_t, _hsaip_lt)\n\nstatic int chaining(const bsw2opt_t *opt, int shift, int n, hsaip_t *z, hsaip_t *chain)\n{\n\tint j, k, m = 0;\n\tks_introsort(hsaip, n, z);\n\tfor (j = 0; j < n; ++j) {\n\t\thsaip_t *p = z + j;\n\t\tfor (k = m - 1; k >= 0; --k) {\n\t\t\thsaip_t *q = chain + k;\n\t\t\tint x = p->qbeg - q->qbeg; // always positive\n\t\t\tint y = p->tbeg - q->tbeg;\n\t\t\tif (y > 0 && x < opt->max_chain_gap && y < opt->max_chain_gap && x - y <= opt->bw && y - x <= opt->bw) { // chained\n\t\t\t\tif (p->qend > q->qend) q->qend = p->qend;\n\t\t\t\tif (p->tend > q->tend) q->tend = p->tend;\n\t\t\t\t++q->chain;\n\t\t\t\tp->chain = shift + k;\n\t\t\t\tbreak;\n\t\t\t} else if (q->chain > opt->t_seeds * 2) k = 0; // if the chain is strong enough, do not check the previous chains\n\t\t}\n\t\tif (k < 0) { // not added to any previous chains\n\t\t\tchain[m] = *p;\n\t\t\tchain[m].chain = 1;\n\t\t\tchain[m].idx = p->chain = shift + m;\n\t\t\t++m;\n\t\t}\n\t}\n\treturn m;\n}\n\nvoid bsw2_chain_filter(const bsw2opt_t *opt, int len, bwtsw2_t *b[2])\n{\n\thsaip_t *z[2], *chain[2];\n\tint i, j, k, n[2], m[2], thres = opt->t_seeds * 2;\n\tchar *flag;\n\t// initialization\n\tn[0] = b[0]->n; n[1] = b[1]->n;\n\tz[0] = calloc(n[0] + n[1], sizeof(hsaip_t));\n\tz[1] = z[0] + n[0];\n\tchain[0] = calloc(n[0] + n[1], sizeof(hsaip_t));\n\tfor (k = j = 0; k < 2; ++k) {\n\t\tfor (i = 0; i < b[k]->n; ++i) {\n\t\t\tbsw2hit_t *p = b[k]->hits + i;\n\t\t\thsaip_t *q = z[k] + i;\n\t\t\tq->flag = k; q->idx = i;\n\t\t\tq->tbeg = p->k; q->tend = p->k + p->len;\n\t\t\tq->chain = -1;\n\t\t\tq->qbeg = p->beg; q->qend = p->end;\n\t\t}\n\t}\n\t// chaining\n\tm[0] = chaining(opt, 0,    n[0], z[0], chain[0]);\n\tchain[1] = chain[0] + m[0];\n\tm[1] = chaining(opt, m[0], n[1], z[1], chain[1]);\t\n\t// change query coordinate on the reverse strand\n\tfor (k = 0; k < m[1]; ++k) {\n\t\thsaip_t *p = chain[1] + k;\n\t\tint tmp = p->qbeg;\n\t\tp->qbeg = len - p->qend; p->qend = len - tmp;\n\t}\n\t//for (k = 0; k < m[0]; ++k) printf(\"%d, [%d,%d), [%d,%d)\\n\", chain[0][k].chain, chain[0][k].tbeg, chain[0][k].tend, chain[0][k].qbeg, chain[0][k].qend);\n\t// filtering\n\tflag = calloc(m[0] + m[1], 1);\n\tks_introsort(hsaip, m[0] + m[1], chain[0]);\n\tfor (k = 1; k < m[0] + m[1]; ++k) {\n\t\thsaip_t *p = chain[0] + k;\n\t\tfor (j = 0; j < k; ++j) {\n\t\t\thsaip_t *q = chain[0] + j;\n\t\t\tif (flag[q->idx]) continue;\n\t\t\tif (q->qend >= p->qend && q->chain > p->chain * thres && p->chain < thres) {\n\t\t\t\tflag[p->idx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k < n[0] + n[1]; ++k) {\n\t\thsaip_t *p = z[0] + k;\n\t\tif (flag[p->chain])\n\t\t\tb[p->flag]->hits[p->idx].G = 0;\n\t}\n\tfree(flag);\n\t// squeeze out filtered elements in b[2]\n\tfor (k = 0; k < 2; ++k) {\n\t\tfor (j = i = 0; j < n[k]; ++j) {\n\t\t\tbsw2hit_t *p = b[k]->hits + j;\n\t\t\tif (p->G) {\n\t\t\t\tif (i != j) b[k]->hits[i++] = *p;\n\t\t\t\telse ++i;\n\t\t\t}\n\t\t}\n\t\tb[k]->n = i;\n\t}\n\t// free\n\tfree(z[0]); free(chain[0]);\n}\n"
        },
        {
          "name": "bwtsw2_core.c",
          "type": "blob",
          "size": 18.5107421875,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/resource.h>\n#include <assert.h>\n#include \"bwt_lite.h\"\n#include \"bwtsw2.h\"\n#include \"bwt.h\"\n#include \"kvec.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef struct {\n\tbwtint_t k, l;\n} qintv_t;\n\n#define qintv_eq(a, b) ((a).k == (b).k && (a).l == (b).l)\n#define qintv_hash(a) ((a).k>>7^(a).l<<17)\n\n#include \"khash.h\"\nKHASH_INIT(qintv, qintv_t, uint64_t, 1, qintv_hash, qintv_eq)\nKHASH_MAP_INIT_INT64(64, uint64_t)\n\n#define MINUS_INF -0x3fffffff\n#define MASK_LEVEL 0.90f\n\nstruct __mempool_t;\nstatic void mp_destroy(struct __mempool_t*);\ntypedef struct {\n\tbwtint_t qk, ql;\n\tint I, D, G;\n\tuint32_t pj:2, qlen:30;\n\tint tlen;\n\tint ppos, upos;\n\tint cpos[4];\n} bsw2cell_t;\n\n#include \"ksort.h\"\nKSORT_INIT_GENERIC(int)\n#define __hitG_lt(a, b) (((a).G + ((int)(a).n_seeds<<2)) > (b).G + ((int)(b).n_seeds<<2))\nKSORT_INIT(hitG, bsw2hit_t, __hitG_lt)\n\nstatic const bsw2cell_t g_default_cell = { 0, 0, MINUS_INF, MINUS_INF, MINUS_INF, 0, 0, 0, -1, -1, {-1, -1, -1, -1} };\n\ntypedef struct {\n\tint n, max;\n\tuint32_t tk, tl; // this is fine\n\tbsw2cell_t *array;\n} bsw2entry_t, *bsw2entry_p;\n\n/* --- BEGIN: Stack operations --- */\ntypedef struct {\n\tint n_pending;\n\tkvec_t(bsw2entry_p) stack0, pending;\n\tstruct __mempool_t *pool;\n} bsw2stack_t;\n\n#define stack_isempty(s) (kv_size(s->stack0) == 0 && s->n_pending == 0)\nstatic void stack_destroy(bsw2stack_t *s) { mp_destroy(s->pool); kv_destroy(s->stack0); kv_destroy(s->pending); free(s); }\ninline static void stack_push0(bsw2stack_t *s, bsw2entry_p e) { kv_push(bsw2entry_p, s->stack0, e); }\ninline static bsw2entry_p stack_pop(bsw2stack_t *s)\n{\n\tassert(!(kv_size(s->stack0) == 0 && s->n_pending != 0));\n\treturn kv_pop(s->stack0);\n}\n/* --- END: Stack operations --- */\n\n/* --- BEGIN: memory pool --- */\ntypedef struct __mempool_t {\n\tint cnt; // if cnt!=0, then there must be memory leak\n\tkvec_t(bsw2entry_p) pool;\n} mempool_t;\ninline static bsw2entry_p mp_alloc(mempool_t *mp)\n{\n\t++mp->cnt;\n\tif (kv_size(mp->pool) == 0) return (bsw2entry_t*)calloc(1, sizeof(bsw2entry_t));\n\telse return kv_pop(mp->pool);\n}\ninline static void mp_free(mempool_t *mp, bsw2entry_p e)\n{\n\t--mp->cnt; e->n = 0;\n\tkv_push(bsw2entry_p, mp->pool, e);\n}\nstatic void mp_destroy(struct __mempool_t *mp)\n{\n\tint i;\n\tfor (i = 0; i != kv_size(mp->pool); ++i) {\n\t\tfree(kv_A(mp->pool, i)->array);\n\t\tfree(kv_A(mp->pool, i));\n\t}\n\tkv_destroy(mp->pool);\n\tfree(mp);\n}\n/* --- END: memory pool --- */\n\n/* --- BEGIN: utilities --- */\nstatic khash_t(64) *bsw2_connectivity(const bwtl_t *b)\n{\n\tkhash_t(64) *h;\n\tuint32_t k, l, cntk[4], cntl[4]; // this is fine\n\tuint64_t x;\n\tkhiter_t iter;\n\tint j, ret;\n\tkvec_t(uint64_t) stack;\n\n\tkv_init(stack);\n\th = kh_init(64);\n\tkh_resize(64, h, b->seq_len * 4);\n\tx = b->seq_len;\n\tkv_push(uint64_t, stack, x);\n\twhile (kv_size(stack)) {\n\t\tx = kv_pop(stack);\n\t\tk = x>>32; l = (uint32_t)x;\n\t\tbwtl_2occ4(b, k-1, l, cntk, cntl);\n\t\tfor (j = 0; j != 4; ++j) {\n\t\t\tk = b->L2[j] + cntk[j] + 1;\n\t\t\tl = b->L2[j] + cntl[j];\n\t\t\tif (k > l) continue;\n\t\t\tx = (uint64_t)k << 32 | l;\n\t\t\titer = kh_put(64, h, x, &ret);\n\t\t\tif (ret) { // if not present\n\t\t\t\tkh_value(h, iter) = 1;\n\t\t\t\tkv_push(uint64_t, stack, x);\n\t\t\t} else ++kh_value(h, iter);\n\t\t}\n\t}\n\tkv_destroy(stack);\n\t//fprintf(stderr, \"[bsw2_connectivity] %u nodes in the DAG\\n\", kh_size(h));\n\treturn h;\n}\n// pick up top T matches at a node\nstatic void cut_tail(bsw2entry_t *u, int T, bsw2entry_t *aux)\n{\n\tint i, *a, n, x;\n\tif (u->n <= T) return;\n\tif (aux->max < u->n) {\n\t\taux->max = u->n;\n\t\taux->array = (bsw2cell_t*)realloc(aux->array, aux->max * sizeof(bsw2cell_t));\n\t}\n\ta = (int*)aux->array;\n\tfor (i = n = 0; i != u->n; ++i)\n\t\tif (u->array[i].ql && u->array[i].G > 0)\n\t\t\ta[n++] = -u->array[i].G;\n\tif (n <= T) return;\n\tx = -ks_ksmall(int, n, a, T);\n\tn = 0;\n\tfor (i = 0; i < u->n; ++i) {\n\t\tbsw2cell_t *p = u->array + i;\n\t\tif (p->G == x) ++n;\n\t\tif (p->G < x || (p->G == x && n >= T)) {\n\t\t\tp->qk = p->ql = 0; p->G = 0;\n\t\t\tif (p->ppos >= 0) u->array[p->ppos].cpos[p->pj] = -1;\n\t\t}\n\t}\n}\n// remove duplicated cells\nstatic inline void remove_duplicate(bsw2entry_t *u, khash_t(qintv) *hash)\n{\n\tint i, ret, j;\n\tkhiter_t k;\n\tqintv_t key;\n\tkh_clear(qintv, hash);\n\tfor (i = 0; i != u->n; ++i) {\n\t\tbsw2cell_t *p = u->array + i;\n\t\tif (p->ql == 0) continue;\n\t\tkey.k = p->qk; key.l = p->ql;\n\t\tk = kh_put(qintv, hash, key, &ret);\n\t\tj = -1;\n\t\tif (ret == 0) {\n\t\t\tif ((uint32_t)kh_value(hash, k) >= p->G) j = i;\n\t\t\telse {\n\t\t\t\tj = kh_value(hash, k)>>32;\n\t\t\t\tkh_value(hash, k) = (uint64_t)i<<32 | p->G;\n\t\t\t}\n\t\t} else kh_value(hash, k) = (uint64_t)i<<32 | p->G;\n\t\tif (j >= 0) {\n\t\t\tp = u->array + j;\n\t\t\tp->qk = p->ql = 0; p->G = 0;\n\t\t\tif (p->ppos >= 0) u->array[p->ppos].cpos[p->pj] = -3;\n\t\t}\n\t}\n}\n// merge two entries\nstatic void merge_entry(const bsw2opt_t * __restrict opt, bsw2entry_t *u, bsw2entry_t *v, bwtsw2_t *b)\n{\n\tint i;\n\tif (u->n + v->n >= u->max) {\n\t\tu->max = u->n + v->n;\n\t\tu->array = (bsw2cell_t*)realloc(u->array, u->max * sizeof(bsw2cell_t));\n\t}\n\tfor (i = 0; i != v->n; ++i) {\n\t\tbsw2cell_t *p = v->array + i;\n\t\tif (p->ppos >= 0) p->ppos += u->n;\n\t\tif (p->cpos[0] >= 0) p->cpos[0] += u->n;\n\t\tif (p->cpos[1] >= 0) p->cpos[1] += u->n;\n\t\tif (p->cpos[2] >= 0) p->cpos[2] += u->n;\n\t\tif (p->cpos[3] >= 0) p->cpos[3] += u->n;\n\t}\n\tmemcpy(u->array + u->n, v->array, v->n * sizeof(bsw2cell_t));\n\tu->n += v->n;\n}\n\nstatic inline bsw2cell_t *push_array_p(bsw2entry_t *e)\n{\n\tif (e->n == e->max) {\n\t\te->max = e->max? e->max<<1 : 256;\n\t\te->array = (bsw2cell_t*)realloc(e->array, sizeof(bsw2cell_t) * e->max);\n\t}\n\treturn e->array + e->n;\n}\n\nstatic inline double time_elapse(const struct rusage *curr, const struct rusage *last)\n{\n\tlong t1 = (curr->ru_utime.tv_sec - last->ru_utime.tv_sec) + (curr->ru_stime.tv_sec - last->ru_stime.tv_sec);\n\tlong t2 = (curr->ru_utime.tv_usec - last->ru_utime.tv_usec) + (curr->ru_stime.tv_usec - last->ru_stime.tv_usec);\n\treturn (double)t1 + t2 * 1e-6;\n}\n/* --- END: utilities --- */\n\n/* --- BEGIN: processing partial hits --- */\nstatic void save_hits(const bwtl_t *bwt, int thres, bsw2hit_t *hits, bsw2entry_t *u)\n{\n\tint i;\n\tuint32_t k; // this is fine\n\tfor (i = 0; i < u->n; ++i) {\n\t\tbsw2cell_t *p = u->array + i;\n\t\tif (p->G < thres) continue;\n\t\tfor (k = u->tk; k <= u->tl; ++k) {\n\t\t\tint beg, end;\n\t\t\tbsw2hit_t *q = 0;\n\t\t\tbeg = bwt->sa[k]; end = beg + p->tlen;\n\t\t\tif (p->G > hits[beg*2].G) {\n\t\t\t\thits[beg*2+1] = hits[beg*2];\n\t\t\t\tq = hits + beg * 2;\n\t\t\t} else if (p->G > hits[beg*2+1].G) q = hits + beg * 2 + 1;\n\t\t\tif (q) {\n\t\t\t\tq->k = p->qk; q->l = p->ql; q->len = p->qlen; q->G = p->G;\n\t\t\t\tq->beg = beg; q->end = end; q->G2 = q->k == q->l? 0 : q->G;\n\t\t\t\tq->flag = q->n_seeds = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n/* \"narrow hits\" are node-to-node hits that have a high score and\n * are not so repetitive (|SA interval|<=IS). */\nstatic void save_narrow_hits(const bwtl_t *bwtl, bsw2entry_t *u, bwtsw2_t *b1, int t, int IS)\n{\n\tint i;\n\tfor (i = 0; i < u->n; ++i) {\n\t\tbsw2hit_t *q;\n\t\tbsw2cell_t *p = u->array + i;\n\t\tif (p->G >= t && p->ql - p->qk + 1 <= IS) { // good narrow hit\n\t\t\tif (b1->max == b1->n) {\n\t\t\t\tb1->max = b1->max? b1->max<<1 : 4;\n\t\t\t\tb1->hits = realloc(b1->hits, b1->max * sizeof(bsw2hit_t));\n\t\t\t}\n\t\t\tq = &b1->hits[b1->n++];\n\t\t\tq->k = p->qk; q->l = p->ql;\n\t\t\tq->len = p->qlen;\n\t\t\tq->G = p->G; q->G2 = 0;\n\t\t\tq->beg = bwtl->sa[u->tk]; q->end = q->beg + p->tlen;\n\t\t\tq->flag = 0;\n\t\t\t// delete p\n\t\t\tp->qk = p->ql = 0; p->G = 0;\n\t\t\tif (p->ppos >= 0) u->array[p->ppos].cpos[p->pj] = -3;\n\t\t}\n\t}\n}\n/* after this, \"narrow SA hits\" will be expanded and the coordinates\n * will be obtained and stored in b->hits[*].k. */\nint bsw2_resolve_duphits(const bntseq_t *bns, const bwt_t *bwt, bwtsw2_t *b, int IS)\n{\n\tint i, j, n, is_rev;\n\tif (b->n == 0) return 0;\n\tif (bwt && bns) { // convert to chromosomal coordinates if requested\n\t\tint old_n = b->n;\n\t\tbsw2hit_t *old_hits = b->hits;\n\t\tfor (i = n = 0; i < b->n; ++i) { // compute the memory to allocated\n\t\t\tbsw2hit_t *p = old_hits + i;\n\t\t\tif (p->l - p->k + 1 <= IS) n += p->l - p->k + 1;\n\t\t\telse if (p->G > 0) ++n;\n\t\t}\n\t\tb->n = b->max = n;\n\t\tb->hits = calloc(b->max, sizeof(bsw2hit_t));\n\t\tfor (i = j = 0; i < old_n; ++i) {\n\t\t\tbsw2hit_t *p = old_hits + i;\n\t\t\tif (p->l - p->k + 1 <= IS) { // the hit is no so repetitive\n\t\t\t\tbwtint_t k;\n\t\t\t\tif (p->G == 0 && p->k == 0 && p->l == 0 && p->len == 0) continue;\n\t\t\t\tfor (k = p->k; k <= p->l; ++k) {\n\t\t\t\t\tb->hits[j] = *p;\n\t\t\t\t\tb->hits[j].k = bns_depos(bns, bwt_sa(bwt, k), &is_rev);\n\t\t\t\t\tb->hits[j].l = 0;\n\t\t\t\t\tb->hits[j].is_rev = is_rev;\n\t\t\t\t\tif (is_rev) b->hits[j].k -= p->len - 1;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t} else if (p->G > 0) {\n\t\t\t\tb->hits[j] = *p;\n\t\t\t\tb->hits[j].k = bns_depos(bns, bwt_sa(bwt, p->k), &is_rev);\n\t\t\t\tb->hits[j].l = 0;\n\t\t\t\tb->hits[j].flag |= 1;\n\t\t\t\tb->hits[j].is_rev = is_rev;\n\t\t\t\tif (is_rev) b->hits[j].k -= p->len - 1;\n\t\t\t\t++j;\n\t\t\t}\n\t\t}\n\t\tfree(old_hits);\n\t}\n\tfor (i = j = 0; i < b->n; ++i) // squeeze out empty elements\n\t\tif (b->hits[i].G) b->hits[j++] = b->hits[i];\n\tb->n = j;\n\tks_introsort(hitG, b->n, b->hits);\n\tfor (i = 1; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\tbsw2hit_t *q = b->hits + j;\n\t\t\tint compatible = 1;\n\t\t\tif (p->is_rev != q->is_rev) continue; // hits from opposite strands are not duplicates\n\t\t\tif (p->l == 0 && q->l == 0) {\n\t\t\t\tint qol = (p->end < q->end? p->end : q->end) - (p->beg > q->beg? p->beg : q->beg); // length of query overlap\n\t\t\t\tif (qol < 0) qol = 0;\n\t\t\t\tif ((float)qol / (p->end - p->beg) > MASK_LEVEL || (float)qol / (q->end - q->beg) > MASK_LEVEL) {\n\t\t\t\t\tint64_t tol = (int64_t)(p->k + p->len < q->k + q->len? p->k + p->len : q->k + q->len)\n\t\t\t\t\t\t- (int64_t)(p->k > q->k? p->k : q->k); // length of target overlap\n\t\t\t\t\tif ((double)tol / p->len > MASK_LEVEL || (double)tol / q->len > MASK_LEVEL)\n\t\t\t\t\t\tcompatible = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!compatible) {\n\t\t\t\tp->G = 0;\n\t\t\t\tif (q->G2 < p->G2) q->G2 = p->G2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tn = i;\n\tfor (i = j = 0; i < n; ++i) {\n\t\tif (b->hits[i].G == 0) continue;\n\t\tif (i != j) b->hits[j++] = b->hits[i];\n\t\telse ++j;\n\t}\n\tb->n = j;\n\treturn b->n;\n}\n\nint bsw2_resolve_query_overlaps(bwtsw2_t *b, float mask_level)\n{\n\tint i, j, n;\n\tif (b->n == 0) return 0;\n\tks_introsort(hitG, b->n, b->hits);\n\t{ // choose a random one\n\t\tint G0 = b->hits[0].G;\n\t\tfor (i = 1; i < b->n; ++i)\n\t\t\tif (b->hits[i].G != G0) break;\n\t\tj = (int)(i * drand48());\n\t\tif (j) {\n\t\t\tbsw2hit_t tmp;\n\t\t\ttmp = b->hits[0]; b->hits[0] = b->hits[j]; b->hits[j] = tmp;\n\t\t}\n\t}\n\tfor (i = 1; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tint all_compatible = 1;\n\t\tif (p->G == 0) break;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\tbsw2hit_t *q = b->hits + j;\n\t\t\tint64_t tol = 0;\n\t\t\tint qol, compatible = 0;\n\t\t\tfloat fol;\n\t\t\tif (q->G == 0) continue;\n\t\t\tqol = (p->end < q->end? p->end : q->end) - (p->beg > q->beg? p->beg : q->beg);\n\t\t\tif (qol < 0) qol = 0;\n\t\t\tif (p->l == 0 && q->l == 0) {\n\t\t\t\ttol = (int64_t)(p->k + p->len < q->k + q->len? p->k + p->len : q->k + q->len)\n\t\t\t\t\t- (p->k > q->k? p->k : q->k);\n\t\t\t\tif (tol < 0) tol = 0;\n\t\t\t}\n\t\t\tfol = (float)qol / (p->end - p->beg < q->end - q->beg? p->end - p->beg : q->end - q->beg);\n\t\t\tif (fol < mask_level || (tol > 0 && qol < p->end - p->beg && qol < q->end - q->beg)) compatible = 1;\n\t\t\tif (!compatible) {\n\t\t\t\tif (q->G2 < p->G) q->G2 = p->G;\n\t\t\t\tall_compatible = 0;\n\t\t\t}\n\t\t}\n\t\tif (!all_compatible) p->G = 0;\n\t}\n\tn = i;\n\tfor (i = j = 0; i < n; ++i) {\n\t\tif (b->hits[i].G == 0) continue;\n\t\tif (i != j) b->hits[j++] = b->hits[i];\n\t\telse ++j;\n\t}\n\tb->n = j;\n\treturn j;\n}\n/* --- END: processing partial hits --- */\n\n/* --- BEGIN: global mem pool --- */\nbsw2global_t *bsw2_global_init()\n{\n\tbsw2global_t *pool;\n\tbsw2stack_t *stack;\n\tpool = calloc(1, sizeof(bsw2global_t));\n\tstack = calloc(1, sizeof(bsw2stack_t));\n\tstack->pool = (mempool_t*)calloc(1, sizeof(mempool_t));\n\tpool->stack = (void*)stack;\n\treturn pool;\n}\n\nvoid bsw2_global_destroy(bsw2global_t *pool)\n{\n\tstack_destroy((bsw2stack_t*)pool->stack);\n\tfree(pool->aln_mem);\n\tfree(pool);\n}\n/* --- END: global mem pool --- */\n\nstatic inline int fill_cell(const bsw2opt_t *o, int match_score, bsw2cell_t *c[4])\n{\n\tint G = c[3]? c[3]->G + match_score : MINUS_INF;\n\tif (c[1]) {\n\t\tc[0]->I = c[1]->I > c[1]->G - o->q? c[1]->I - o->r : c[1]->G - o->qr;\n\t\tif (c[0]->I > G) G = c[0]->I;\n\t} else c[0]->I = MINUS_INF;\n\tif (c[2]) {\n\t\tc[0]->D = c[2]->D > c[2]->G - o->q? c[2]->D - o->r : c[2]->G - o->qr;\n\t\tif (c[0]->D > G) G = c[0]->D;\n\t} else c[0]->D = MINUS_INF;\n\treturn(c[0]->G = G);\n}\n\nstatic void init_bwtsw2(const bwtl_t *target, const bwt_t *query, bsw2stack_t *s)\n{\n\tbsw2entry_t *u;\n\tbsw2cell_t *x;\n\n\tu = mp_alloc(s->pool);\n\tu->tk = 0; u->tl = target->seq_len;\n\tx = push_array_p(u);\n\t*x = g_default_cell;\n\tx->G = 0; x->qk = 0; x->ql = query->seq_len;\n\tu->n++;\n\tstack_push0(s, u);\n}\n/* On return, ret[1] keeps not-so-repetitive hits (narrow SA hits); ret[0] keeps all hits (right?) */\nbwtsw2_t **bsw2_core(const bntseq_t *bns, const bsw2opt_t *opt, const bwtl_t *target, const bwt_t *query, bsw2global_t *pool)\n{\n\tbsw2stack_t *stack = (bsw2stack_t*)pool->stack;\n\tbwtsw2_t *b, *b1, **b_ret;\n\tint i, j, score_mat[16], *heap, heap_size, n_tot = 0;\n\tstruct rusage curr, last;\n\tkhash_t(qintv) *rhash;\n\tkhash_t(64) *chash;\n\n\t// initialize connectivity hash (chash)\n\tchash = bsw2_connectivity(target);\n\t// calculate score matrix\n\tfor (i = 0; i != 4; ++i)\n\t\tfor (j = 0; j != 4; ++j)\n\t\t\tscore_mat[i<<2|j] = (i == j)? opt->a : -opt->b;\n\t// initialize other variables\n\trhash = kh_init(qintv);\n\tinit_bwtsw2(target, query, stack);\n\theap_size = opt->z;\n\theap = calloc(heap_size, sizeof(int));\n\t// initialize the return struct\n\tb = (bwtsw2_t*)calloc(1, sizeof(bwtsw2_t));\n\tb->n = b->max = target->seq_len * 2;\n\tb->hits = calloc(b->max, sizeof(bsw2hit_t));\n\tb1 = (bwtsw2_t*)calloc(1, sizeof(bwtsw2_t));\n\tb_ret = calloc(2, sizeof(void*));\n\tb_ret[0] = b; b_ret[1] = b1;\n\t// initialize timer\n\tgetrusage(0, &last);\n\t// the main loop: traversal of the DAG\n\twhile (!stack_isempty(stack)) {\n\t\tint old_n, tj;\n\t\tbsw2entry_t *v;\n\t\tuint32_t tcntk[4], tcntl[4];\n\t\tbwtint_t k, l;\n\n\t\tv = stack_pop(stack); old_n = v->n;\n\t\tn_tot += v->n;\n\n\t\tfor (i = 0; i < v->n; ++i) { // test max depth and band width\n\t\t\tbsw2cell_t *p = v->array + i;\n\t\t\tif (p->ql == 0) continue;\n\t\t\tif (p->tlen - (int)p->qlen > opt->bw || (int)p->qlen - p->tlen > opt->bw) {\n\t\t\t\tp->qk = p->ql = 0;\n\t\t\t\tif (p->ppos >= 0) v->array[p->ppos].cpos[p->pj] = -5;\n\t\t\t}\n\t\t}\n\n\t\t// get Occ for the DAG\n\t\tbwtl_2occ4(target, v->tk - 1, v->tl, tcntk, tcntl);\n\t\tfor (tj = 0; tj != 4; ++tj) { // descend to the children\n\t\t\tbwtint_t qcntk[4], qcntl[4];\n\t\t\tint qj, *curr_score_mat = score_mat + tj * 4;\n\t\t\tkhiter_t iter;\n\t\t\tbsw2entry_t *u;\n\n\t\t\tk = target->L2[tj] + tcntk[tj] + 1;\n\t\t\tl = target->L2[tj] + tcntl[tj];\n\t\t\tif (k > l) continue;\n\t\t\t// update counter\n\t\t\titer = kh_get(64, chash, (uint64_t)k<<32 | l);\n\t\t\t--kh_value(chash, iter);\n\t\t\t// initialization\n\t\t\tu = mp_alloc(stack->pool);\n\t\t\tu->tk = k; u->tl = l;\n\t\t\tmemset(heap, 0, sizeof(int) * opt->z);\n\t\t\t// loop through all the nodes in v\n\t\t    for (i = 0; i < v->n; ++i) {\n\t\t\t\tbsw2cell_t *p = v->array + i, *x, *c[4]; // c[0]=>current, c[1]=>I, c[2]=>D, c[3]=>G\n\t\t\t\tint is_added = 0;\n\t\t\t\tif (p->ql == 0) continue; // deleted node\n\t\t\t\tc[0] = x = push_array_p(u);\n\t\t\t\tx->G = MINUS_INF;\n\t\t\t\tp->upos = x->upos = -1;\n\t\t\t\tif (p->ppos >= 0) { // parent has been visited\n\t\t\t\t\tc[1] = (v->array[p->ppos].upos >= 0)? u->array + v->array[p->ppos].upos : 0;\n\t\t\t\t\tc[3] = v->array + p->ppos; c[2] = p;\n\t\t\t\t\tif (fill_cell(opt, curr_score_mat[p->pj], c) > 0) { // then update topology at p and x\n\t\t\t\t\t\tx->ppos = v->array[p->ppos].upos; // the parent pos in u\n\t\t\t\t\t\tp->upos = u->n++; // the current pos in u\n\t\t\t\t\t\tif (x->ppos >= 0) u->array[x->ppos].cpos[p->pj] = p->upos; // the child pos of its parent in u\n\t\t\t\t\t\tis_added = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx->D = p->D > p->G - opt->q? p->D - opt->r : p->G - opt->qr;\n\t\t\t\t\tif (x->D > 0) {\n\t\t\t\t\t\tx->G = x->D;\n\t\t\t\t\t\tx->I = MINUS_INF; x->ppos = -1;\n\t\t\t\t\t\tp->upos = u->n++;\n\t\t\t\t\t\tis_added = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_added) { // x has been added to u->array. fill the remaining variables\n\t\t\t\t\tx->cpos[0] = x->cpos[1] = x->cpos[2] = x->cpos[3] = -1;\n\t\t\t\t\tx->pj = p->pj; x->qk = p->qk; x->ql = p->ql; x->qlen = p->qlen; x->tlen = p->tlen + 1;\n\t\t\t\t\tif (x->G > -heap[0]) {\n\t\t\t\t\t\theap[0] = -x->G;\n\t\t\t\t\t\tks_heapadjust(int, 0, heap_size, heap);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((x->G > opt->qr && x->G >= -heap[0]) || i < old_n) { // good node in u, or in v\n\t\t\t\t\tif (p->cpos[0] == -1 || p->cpos[1] == -1 || p->cpos[2] == -1 || p->cpos[3] == -1) {\n\t\t\t\t\t\tbwt_2occ4(query, p->qk - 1, p->ql, qcntk, qcntl);\n\t\t\t\t\t\tfor (qj = 0; qj != 4; ++qj) { // descend to the prefix trie\n\t\t\t\t\t\t\tif (p->cpos[qj] != -1) continue; // this node will be visited later\n\t\t\t\t\t\t\tk = query->L2[qj] + qcntk[qj] + 1;\n\t\t\t\t\t\t\tl = query->L2[qj] + qcntl[qj];\n\t\t\t\t\t\t\tif (k > l) { p->cpos[qj] = -2; continue; }\n\t\t\t\t\t\t\tx = push_array_p(v);\n\t\t\t\t\t\t\tp = v->array + i; // p may not point to the correct position after realloc\n\t\t\t\t\t\t\tx->G = x->I = x->D = MINUS_INF;\n\t\t\t\t\t\t\tx->qk = k; x->ql = l; x->pj = qj; x->qlen = p->qlen + 1; x->ppos = i; x->tlen = p->tlen;\n\t\t\t\t\t\t\tx->cpos[0] = x->cpos[1] = x->cpos[2] = x->cpos[3] = -1;\n\t\t\t\t\t\t\tp->cpos[qj] = v->n++;\n\t\t\t\t\t\t} // ~for(qj)\n\t\t\t\t\t} // ~if(p->cpos[])\n\t\t\t\t} // ~if\n\t\t\t} // ~for(i)\n\t\t\tif (u->n) save_hits(target, opt->t, b->hits, u);\n\t\t\t{ // push u to the stack (or to the pending array)\n\t\t\t\tuint32_t cnt, pos;\n\t\t\t\tcnt = (uint32_t)kh_value(chash, iter);\n\t\t\t\tpos = kh_value(chash, iter)>>32;\n\t\t\t\tif (pos) { // something in the pending array, then merge\n\t\t\t\t\tbsw2entry_t *w = kv_A(stack->pending, pos-1);\n\t\t\t\t\tif (u->n) {\n\t\t\t\t\t\tif (w->n < u->n) { // swap\n\t\t\t\t\t\t\tw = u; u = kv_A(stack->pending, pos-1); kv_A(stack->pending, pos-1) = w;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmerge_entry(opt, w, u, b);\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt == 0) { // move from pending to stack0\n\t\t\t\t\t\tremove_duplicate(w, rhash);\n\t\t\t\t\t\tsave_narrow_hits(target, w, b1, opt->t, opt->is);\n\t\t\t\t\t\tcut_tail(w, opt->z, u);\n\t\t\t\t\t\tstack_push0(stack, w);\n\t\t\t\t\t\tkv_A(stack->pending, pos-1) = 0;\n\t\t\t\t\t\t--stack->n_pending;\n\t\t\t\t\t}\n\t\t\t\t\tmp_free(stack->pool, u);\n\t\t\t\t} else if (cnt) { // the first time\n\t\t\t\t\tif (u->n) { // push to the pending queue\n\t\t\t\t\t\t++stack->n_pending;\n\t\t\t\t\t\tkv_push(bsw2entry_p, stack->pending, u);\n\t\t\t\t\t\tkh_value(chash, iter) = (uint64_t)kv_size(stack->pending)<<32 | cnt;\n\t\t\t\t\t} else mp_free(stack->pool, u);\n\t\t\t\t} else { // cnt == 0, then push to the stack\n\t\t\t\t\tbsw2entry_t *w = mp_alloc(stack->pool);\n\t\t\t\t\tsave_narrow_hits(target, u, b1, opt->t, opt->is);\n\t\t\t\t\tcut_tail(u, opt->z, w);\n\t\t\t\t\tmp_free(stack->pool, w);\n\t\t\t\t\tstack_push0(stack, u);\n\t\t\t\t}\n\t\t\t}\n\t\t} // ~for(tj)\n\t\tmp_free(stack->pool, v);\n\t} // while(top)\n\tgetrusage(0, &curr);\n\tfor (i = 0; i < 2; ++i)\n\t\tfor (j = 0; j < b_ret[i]->n; ++j)\n\t\t\tb_ret[i]->hits[j].n_seeds = 0;\n\tbsw2_resolve_duphits(bns, query, b, opt->is);\n\tbsw2_resolve_duphits(bns, query, b1, opt->is);\n\t//fprintf(stderr, \"stats: %.3lf sec; %d elems\\n\", time_elapse(&curr, &last), n_tot);\n\t// free\n\tfree(heap);\n\tkh_destroy(qintv, rhash);\n\tkh_destroy(64, chash);\n\tstack->pending.n = stack->stack0.n = 0;\n\treturn b_ret;\n}\n"
        },
        {
          "name": "bwtsw2_main.c",
          "type": "blob",
          "size": 3.728515625,
          "content": "#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include \"bwt.h\"\n#include \"bwtsw2.h\"\n#include \"utils.h\"\n#include \"bwa.h\"\n\nint bwa_bwtsw2(int argc, char *argv[])\n{\n\tbsw2opt_t *opt;\n\tbwaidx_t *idx;\n\tint c;\n\n\topt = bsw2_init_opt();\n\tsrand48(11);\n\twhile ((c = getopt(argc, argv, \"q:r:a:b:t:T:w:d:z:m:s:c:N:Hf:MI:SG:C\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'q': opt->q = atoi(optarg); break;\n\t\tcase 'r': opt->r = atoi(optarg); break;\n\t\tcase 'a': opt->a = atoi(optarg); break;\n\t\tcase 'b': opt->b = atoi(optarg); break;\n\t\tcase 'w': opt->bw = atoi(optarg); break;\n\t\tcase 'T': opt->t = atoi(optarg); break;\n\t\tcase 't': opt->n_threads = atoi(optarg); break;\n\t\tcase 'z': opt->z = atoi(optarg); break;\n\t\tcase 's': opt->is = atoi(optarg); break;\n\t\tcase 'm': opt->mask_level = atof(optarg); break;\n\t\tcase 'c': opt->coef = atof(optarg); break;\n\t\tcase 'N': opt->t_seeds = atoi(optarg); break;\n\t\tcase 'M': opt->multi_2nd = 1; break;\n\t\tcase 'H': opt->hard_clip = 1; break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tcase 'I': opt->max_ins = atoi(optarg); break;\n\t\tcase 'S': opt->skip_sw = 1; break;\n\t\tcase 'C': opt->cpy_cmt = 1; break;\n\t\tcase 'G': opt->max_chain_gap = atoi(optarg); break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\topt->qr = opt->q + opt->r;\n\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa bwasw [options] <target.prefix> <query.fa> [query2.fa]\\n\\n\");\n\t\tfprintf(stderr, \"Options: -a INT   score for a match [%d]\\n\", opt->a);\n\t\tfprintf(stderr, \"         -b INT   mismatch penalty [%d]\\n\", opt->b);\n\t\tfprintf(stderr, \"         -q INT   gap open penalty [%d]\\n\", opt->q);\n\t\tfprintf(stderr, \"         -r INT   gap extension penalty [%d]\\n\", opt->r);\n\t\tfprintf(stderr, \"         -w INT   band width [%d]\\n\", opt->bw);\n\t\tfprintf(stderr, \"         -m FLOAT mask level [%.2f]\\n\", opt->mask_level);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"         -t INT   number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -f FILE  file to output results to instead of stdout\\n\");\n\t\tfprintf(stderr, \"         -H       in SAM output, use hard clipping instead of soft clipping\\n\");\n\t\tfprintf(stderr, \"         -C       copy FASTA/Q comment to SAM output\\n\");\n\t\tfprintf(stderr, \"         -M       mark multi-part alignments as secondary\\n\");\n\t\tfprintf(stderr, \"         -S       skip Smith-Waterman read pairing\\n\");\n\t\tfprintf(stderr, \"         -I INT   ignore pairs with insert >=INT for inferring the size distr [%d]\\n\", opt->max_ins);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"         -T INT   score threshold divided by a [%d]\\n\", opt->t);\n\t\tfprintf(stderr, \"         -c FLOAT coefficient of length-threshold adjustment [%.1f]\\n\", opt->coef);\n\t\tfprintf(stderr, \"         -z INT   Z-best [%d]\\n\", opt->z);\n\t\tfprintf(stderr, \"         -s INT   maximum seeding interval size [%d]\\n\", opt->is);\n\t\tfprintf(stderr, \"         -N INT   # seeds to trigger rev aln; 2*INT is also the chaining threshold [%d]\\n\", opt->t_seeds);\n\t\tfprintf(stderr, \"         -G INT   maximum gap size during chaining [%d]\\n\", opt->max_chain_gap);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Note: For long Illumina, 454 and Sanger reads, assembly contigs, fosmids and\\n\");\n\t\tfprintf(stderr, \"      BACs, the default setting usually works well. For the current PacBio\\n\");\n\t\tfprintf(stderr, \"      reads (end of 2010), '-b5 -q2 -r1 -z10' is recommended. One may also\\n\");\n\t\tfprintf(stderr, \"      increase '-z' for better sensitivity.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\n\t\treturn 1;\n\t}\n\n\t// adjust opt for opt->a\n\topt->t *= opt->a;\n\topt->coef *= opt->a;\n\n\tif ((idx = bwa_idx_load(argv[optind], BWA_IDX_BWT|BWA_IDX_BNS)) == 0) return 1;\n\tbsw2_aln(opt, idx->bns, idx->bwt, argv[optind+1], optind+2 < argc? argv[optind+2] : 0);\n\tbwa_idx_destroy(idx);\n\tfree(opt);\n\t\n\treturn 0;\n}\n"
        },
        {
          "name": "bwtsw2_pair.c",
          "type": "blob",
          "size": 10.2705078125,
          "content": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"utils.h\"\n#include \"bwt.h\"\n#include \"bntseq.h\"\n#include \"bwtsw2.h\"\n#include \"kstring.h\"\n#include \"ksw.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define MIN_RATIO     0.8\n#define OUTLIER_BOUND 2.0\n#define MAX_STDDEV    4.0\n#define EXT_STDDEV    4.0\n\ntypedef struct {\n\tint low, high, failed;\n\tdouble avg, std;\n} bsw2pestat_t;\n\nbsw2pestat_t bsw2_stat(int n, bwtsw2_t **buf, kstring_t *msg, int max_ins)\n{\n\tint i, k, x, p25, p50, p75, tmp, max_len = 0;\n\tuint64_t *isize;\n\tbsw2pestat_t r;\n\n\tmemset(&r, 0, sizeof(bsw2pestat_t));\n\tisize = calloc(n, 8);\n\tfor (i = k = 0; i < n; i += 2) {\n\t\tbsw2hit_t *t[2];\n\t\tint l;\n\t\tif (buf[i] == 0 || buf[i]->n != 1 || buf[i+1]->n != 1) continue; // more than 1 hits\n\t\tt[0] = &buf[i]->hits[0]; t[1] = &buf[i+1]->hits[0];\n\t\tif (t[0]->G2 > 0.8 * t[0]->G) continue; // the best hit is not good enough\n\t\tif (t[1]->G2 > 0.8 * t[1]->G) continue; // the best hit is not good enough\n\t\tl = t[0]->k > t[1]->k? t[0]->k - t[1]->k + t[1]->len : t[1]->k - t[0]->k + t[0]->len;\n\t\tif (l >= max_ins) continue; // skip pairs with excessively large insert\n\t\tmax_len = max_len > t[0]->end - t[0]->beg? max_len : t[0]->end - t[0]->beg;\n\t\tmax_len = max_len > t[1]->end - t[1]->beg? max_len : t[1]->end - t[1]->beg;\n\t\tisize[k++] = l;\n\t}\n\tks_introsort_64(k, isize);\n\tp25 = isize[(int)(.25 * k + .499)];\n\tp50 = isize[(int)(.50 * k + .499)];\n\tp75 = isize[(int)(.75 * k + .499)];\n\tksprintf(msg, \"[%s] infer the insert size distribution from %d high-quality pairs.\\n\", __func__, k);\n\tif (k < 8) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: too few good pairs.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\ttmp    = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\tr.low  = tmp > max_len? tmp : max_len;\n\tif (r.low < 1) r.low = 1;\n\tr.high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\tif (r.low > r.high) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: upper bound is smaller than max read length.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\tksprintf(msg, \"[%s] (25, 50, 75) percentile: (%d, %d, %d)\\n\", __func__, p25, p50, p75);\n\tksprintf(msg, \"[%s] low and high boundaries for computing mean and std.dev: (%d, %d)\\n\", __func__, r.low, r.high);\n\tfor (i = x = 0, r.avg = 0; i < k; ++i)\n\t\tif (isize[i] >= r.low && isize[i] <= r.high)\n\t\t\tr.avg += isize[i], ++x;\n\tif (x == 0) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: no pairs within boundaries.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\tr.avg /= x;\n\tfor (i = 0, r.std = 0; i < k; ++i)\n\t\tif (isize[i] >= r.low && isize[i] <= r.high)\n\t\t\tr.std += (isize[i] - r.avg) * (isize[i] - r.avg);\n\tr.std = sqrt(r.std / x);\n\tksprintf(msg, \"[%s] mean and std.dev: (%.2f, %.2f)\\n\", __func__, r.avg, r.std);\n\ttmp  = (int)(p25 - 3. * (p75 - p25) + .499);\n\tr.low  = tmp > max_len? tmp : max_len;\n\tif (r.low < 1) r.low = 1;\n\tr.high = (int)(p75 + 3. * (p75 - p25) + .499);\n\tif (r.low > r.avg - MAX_STDDEV * r.std) r.low = (int)(r.avg - MAX_STDDEV * r.std + .499);\n\tr.low = tmp > max_len? tmp : max_len;\n\tif (r.high < r.avg + MAX_STDDEV * r.std) r.high = (int)(r.avg + MAX_STDDEV * r.std + .499);\n\tksprintf(msg, \"[%s] low and high boundaries for proper pairs: (%d, %d)\\n\", __func__, r.low, r.high);\n\tfree(isize);\n\treturn r;\n}\n\ntypedef struct {\n\tint n_cigar, beg, end, len;\n\tint64_t pos;\n\tuint32_t *cigar;\n} pairaux_t;\n\nextern unsigned char nst_nt4_table[256];\n\nvoid bsw2_pair1(const bsw2opt_t *opt, int64_t l_pac, const uint8_t *pac, const bsw2pestat_t *st, const bsw2hit_t *h, int l_mseq, const char *mseq, bsw2hit_t *a, int8_t g_mat[25])\n{\n\textern void seq_reverse(int len, ubyte_t *seq, int is_comp);\n\tint64_t k, beg, end;\n\tuint8_t *seq, *ref;\n\tint i;\n\t// compute the region start and end\n\ta->n_seeds = 1; a->flag |= BSW2_FLAG_MATESW; // before calling this routine, *a has been cleared with memset(0); the flag is set with 1<<6/7\n\tif (h->is_rev == 0) {\n\t\tbeg = (int64_t)(h->k + st->avg - EXT_STDDEV * st->std - l_mseq + .499);\n\t\tif (beg < h->k) beg = h->k;\n\t\tend = (int64_t)(h->k + st->avg + EXT_STDDEV * st->std + .499);\n\t\ta->is_rev = 1; a->flag |= 16;\n\t} else {\n\t\tbeg = (int64_t)(h->k + h->end - h->beg - st->avg - EXT_STDDEV * st->std + .499);\n\t\tend = (int64_t)(h->k + h->end - h->beg - st->avg + EXT_STDDEV * st->std + l_mseq + .499);\n\t\tif (end > h->k + (h->end - h->beg)) end = h->k + (h->end - h->beg);\n\t\ta->is_rev = 0;\n\t}\n\tif (beg < 1) beg = 1;\n\tif (end > l_pac) end = l_pac;\n\tif (end - beg < l_mseq) return;\n\t// generate the sequence\n\tseq = malloc(l_mseq + (end - beg));\n\tref = seq + l_mseq;\n\tfor (k = beg; k < end; ++k)\n\t\tref[k - beg] = pac[k>>2] >> ((~k&3)<<1) & 0x3;\n\tif (h->is_rev == 0) {\n\t\tfor (i = 0; i < l_mseq; ++i) { // on the reverse strand\n\t\t\tint c = nst_nt4_table[(int)mseq[i]];\n\t\t\tseq[l_mseq - 1 - i] = c > 3? 4 : 3 - c;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < l_mseq; ++i) // on the forward strand\n\t\t\tseq[i] = nst_nt4_table[(int)mseq[i]];\n\t}\n\t{\n\t\tint flag = KSW_XSUBO | KSW_XSTART | (l_mseq * g_mat[0] < 250? KSW_XBYTE : 0) | opt->t;\n\t\tkswr_t aln;\n\t\taln = ksw_align(l_mseq, seq, end - beg, ref, 5, g_mat, opt->q, opt->r, flag, 0);\n\t\ta->G = aln.score;\n\t\ta->G2 = aln.score2;\n\t\tif (a->G < opt->t) a->G = 0;\n\t\tif (a->G2 < opt->t) a->G2 = 0;\n\t\tif (a->G2) a->flag |= BSW2_FLAG_TANDEM;\n\t\ta->k = beg + aln.tb;\n\t\ta->len = aln.te - aln.tb + 1;\n\t\ta->beg = aln.qb;\n\t\ta->end = aln.qe + 1;\n\t\t/*\n\t\tprintf(\"[Q] \"); for (i = 0; i < l_mseq; ++i) putchar(\"ACGTN\"[(int)seq[i]]); putchar('\\n');\n\t\tprintf(\"[R] \"); for (i = 0; i < end - beg; ++i) putchar(\"ACGTN\"[(int)ref[i]]); putchar('\\n');\n\t\tprintf(\"G=%d,G2=%d,beg=%d,end=%d,k=%lld,len=%d\\n\", a->G, a->G2, a->beg, a->end, a->k, a->len);\n\t\t*/\n\t}\n\tif (a->is_rev) i = a->beg, a->beg = l_mseq - a->end, a->end = l_mseq - i;\n\tfree(seq);\n}\n\nvoid bsw2_pair(const bsw2opt_t *opt, int64_t l_pac, const uint8_t *pac, int n, bsw2seq1_t *seq, bwtsw2_t **hits)\n{\n\textern int bsw2_resolve_duphits(const bntseq_t *bns, const bwt_t *bwt, bwtsw2_t *b, int IS);\n\tbsw2pestat_t pes;\n\tint i, j, k, n_rescued = 0, n_moved = 0, n_fixed = 0;\n\tint8_t g_mat[25];\n\tkstring_t msg;\n\tmemset(&msg, 0, sizeof(kstring_t));\n\tpes = bsw2_stat(n, hits, &msg, opt->max_ins);\n\tfor (i = k = 0; i < 5; ++i) {\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tg_mat[k++] = i == j? opt->a : -opt->b;\n\t\tg_mat[k++] = 0;\n\t}\n\tfor (i = 0; i < n; i += 2) {\n\t\tbsw2hit_t a[2];\n\t\tmemset(&a, 0, sizeof(bsw2hit_t) * 2);\n\t\ta[0].flag = 1<<6; a[1].flag = 1<<7;\n\t\tfor (j = 0; j < 2; ++j) { // set the read1/2 flag\n\t\t\tif (hits[i+j] == 0) continue;\n\t\t\tfor (k = 0; k < hits[i+j]->n; ++k) {\n\t\t\t\tbsw2hit_t *p = &hits[i+j]->hits[k];\n\t\t\t\tp->flag |= 1<<(6+j);\n\t\t\t}\n\t\t}\n\t\tif (pes.failed) continue;\n\t\tif (hits[i] == 0 || hits[i+1] == 0) continue; // one end has excessive N\n\t\tif (hits[i]->n != 1 && hits[i+1]->n != 1) continue; // no end has exactly one hit\n\t\tif (hits[i]->n > 1 || hits[i+1]->n > 1) continue; // one read has more than one hit\n\t\tif (!opt->skip_sw) {\n\t\t\tif (hits[i+0]->n == 1) bsw2_pair1(opt, l_pac, pac, &pes, &hits[i+0]->hits[0], seq[i+1].l, seq[i+1].seq, &a[1], g_mat);\n\t\t\tif (hits[i+1]->n == 1) bsw2_pair1(opt, l_pac, pac, &pes, &hits[i+1]->hits[0], seq[i+0].l, seq[i+0].seq, &a[0], g_mat);\n\t\t} // else a[0].G == a[1].G == a[0].G2 == a[1].G2 == 0\n\t\t// the following enumerate all possibilities. It is tedious but necessary...\n\t\tif (hits[i]->n + hits[i+1]->n == 1) { // one end mapped; the other not;\n\t\t\tbwtsw2_t *p[2];\n\t\t\tint which;\n\t\t\tif (hits[i]->n == 1) p[0] = hits[i], p[1] = hits[i+1], which = 1;\n\t\t\telse p[0] = hits[i+1], p[1] = hits[i], which = 0;\n\t\t\tif (a[which].G == 0) continue;\n\t\t\ta[which].flag |= BSW2_FLAG_RESCUED;\n\t\t\tif (p[1]->max == 0) {\n\t\t\t\tp[1]->max = 1;\n\t\t\t\tp[1]->hits = malloc(sizeof(bsw2hit_t));\n\t\t\t}\n\t\t\tp[1]->hits[0] = a[which];\n\t\t\tp[1]->n = 1;\n\t\t\tp[0]->hits[0].flag |= 2;\n\t\t\tp[1]->hits[0].flag |= 2;\n\t\t\t++n_rescued;\n\t\t} else { // then both ends mapped\n\t\t\tint is_fixed = 0;\n\t\t\t//fprintf(stderr, \"%d; %lld,%lld; %d,%d\\n\", a[0].is_rev, hits[i]->hits[0].k, a[0].k, hits[i]->hits[0].end, a[0].end);\n\t\t\tfor (j = 0; j < 2; ++j) { // fix wrong mappings and wrong suboptimal alignment score\n\t\t\t\tbsw2hit_t *p = &hits[i+j]->hits[0];\n\t\t\t\tif (p->G < a[j].G) { // the orginal mapping is suboptimal\n\t\t\t\t\ta[j].G2 = a[j].G2 > p->G? a[j].G2 : p->G; // FIXME: reset BSW2_FLAG_TANDEM?\n\t\t\t\t\t*p = a[j];\n\t\t\t\t\t++n_fixed;\n\t\t\t\t\tis_fixed = 1;\n\t\t\t\t} else if (p->k != a[j].k && p->G2 < a[j].G) {\n\t\t\t\t\tp->G2 = a[j].G;\n\t\t\t\t} else if (p->k == a[j].k && p->G2 < a[j].G2) {\n\t\t\t\t\tp->G2 = a[j].G2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hits[i]->hits[0].k == a[0].k && hits[i+1]->hits[0].k == a[1].k) { // properly paired and no ends need to be moved\n\t\t\t\tfor (j = 0; j < 2; ++j)\n\t\t\t\t\thits[i+j]->hits[0].flag |= 2 | (a[j].flag & BSW2_FLAG_TANDEM);\n\t\t\t} else if (hits[i]->hits[0].k == a[0].k || hits[i+1]->hits[0].k == a[1].k) { // a tandem match\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\thits[i+j]->hits[0].flag |= 2;\n\t\t\t\t\tif (hits[i+j]->hits[0].k != a[j].k)\n\t\t\t\t\t\thits[i+j]->hits[0].flag |= BSW2_FLAG_TANDEM;\n\t\t\t\t}\n\t\t\t} else if (!is_fixed && (a[0].G || a[1].G)) { // it is possible to move one end\n\t\t\t\tif (a[0].G && a[1].G) { // now we have two \"proper pairs\"\n\t\t\t\t\tint G[2];\n\t\t\t\t\tdouble diff;\n\t\t\t\t\tG[0] = hits[i]->hits[0].G + a[1].G;\n\t\t\t\t\tG[1] = hits[i+1]->hits[0].G + a[0].G;\n\t\t\t\t\tdiff = fabs((double)(G[0] - G[1])) / (opt->a + opt->b) / ((hits[i]->hits[0].len + a[1].len + hits[i+1]->hits[0].len + a[0].len) / 2.);\n\t\t\t\t\tif (diff > 0.05) a[G[0] > G[1]? 0 : 1].G = 0;\n\t\t\t\t}\n\t\t\t\tif (a[0].G == 0 || a[1].G == 0) { // one proper pair only\n\t\t\t\t\tbsw2hit_t *p[2]; // p[0] points the unchanged hit; p[1] to the hit to be moved\n\t\t\t\t\tint which, isize;\n\t\t\t\t\tdouble dev, diff;\n\t\t\t\t\tif (a[0].G) p[0] = &hits[i+1]->hits[0], p[1] = &hits[i]->hits[0], which = 0;\n\t\t\t\t\telse p[0] = &hits[i]->hits[0], p[1] = &hits[i+1]->hits[0], which = 1;\n\t\t\t\t\tisize = p[0]->is_rev? p[0]->k + p[0]->len - a[which].k : a[which].k + a[which].len - p[0]->k;\n\t\t\t\t\tdev = fabs(isize - pes.avg) / pes.std;\n\t\t\t\t\tdiff = (double)(p[1]->G - a[which].G) / (opt->a + opt->b) / (p[1]->end - p[1]->beg) * 100.0;\n\t\t\t\t\tif (diff < dev * 2.) { // then move (heuristic)\n\t\t\t\t\t\ta[which].G2 = a[which].G;\n\t\t\t\t\t\tp[1][0] = a[which];\n\t\t\t\t\t\tp[1]->flag |= BSW2_FLAG_MOVED | 2;\n\t\t\t\t\t\tp[0]->flag |= 2;\n\t\t\t\t\t\t++n_moved;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (is_fixed) {\n\t\t\t\thits[i+0]->hits[0].flag |= 2;\n\t\t\t\thits[i+1]->hits[0].flag |= 2;\n\t\t\t}\n\t\t}\n\t}\n\tksprintf(&msg, \"[%s] #fixed=%d, #rescued=%d, #moved=%d\\n\", __func__, n_fixed, n_rescued, n_moved);\n\tfputs(msg.s, stderr);\n\tfree(msg.s);\n}\n"
        },
        {
          "name": "code_of_conduct.md",
          "type": "blob",
          "size": 1.353515625,
          "content": "## Contributor Code of Conduct\n\nAs contributors and maintainers of this project, we pledge to respect all\npeople who contribute through reporting issues, posting feature requests,\nupdating documentation, submitting pull requests or patches, and other\nactivities.\n\nWe are committed to making participation in this project a harassment-free\nexperience for everyone, regardless of level of experience, gender, gender\nidentity and expression, sexual orientation, disability, personal appearance,\nbody size, race, age, or religion.\n\nExamples of unacceptable behavior by participants include the use of sexual\nlanguage or imagery, derogatory comments or personal attacks, trolling, public\nor private harassment, insults, or other unprofessional conduct.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct. Project maintainers or\ncontributors who do not follow the Code of Conduct may be removed from the\nproject team.\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by opening an issue or contacting the maintainer via email.\n\nThis Code of Conduct is adapted from the [Contributor Covenant][cc], [version\n1.0.0][v1].\n\n[cc]: http://contributor-covenant.org/\n[v1]: http://contributor-covenant.org/version/1/0/0/\n"
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 1.80078125,
          "content": "#include <stdio.h>\n#include <zlib.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n#include \"bwamem.h\"\n#include \"kseq.h\" // for the FASTA/Q parser\nKSEQ_DECLARE(gzFile)\n\nint main(int argc, char *argv[])\n{\n\tbwaidx_t *idx;\n\tgzFile fp;\n\tkseq_t *ks;\n\tmem_opt_t *opt;\n\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: bwamem-lite <idx.base> <reads.fq>\\n\");\n\t\treturn 1;\n\t}\n\n\tidx = bwa_idx_load(argv[1], BWA_IDX_ALL); // load the BWA index\n\tif (NULL == idx) {\n\t\tfprintf(stderr, \"Index load failed.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tfp = strcmp(argv[2], \"-\")? gzopen(argv[2], \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (NULL == fp) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\tstrcmp(argv[2], \"-\") ? argv[2] : \"stdin\",\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tks = kseq_init(fp); // initialize the FASTA/Q parser\n\topt = mem_opt_init(); // initialize the BWA-MEM parameters to the default values\n\n\twhile (kseq_read(ks) >= 0) { // read one sequence\n\t\tmem_alnreg_v ar;\n\t\tint i, k;\n\t\tar = mem_align1(opt, idx->bwt, idx->bns, idx->pac, ks->seq.l, ks->seq.s); // get all the hits\n\t\tfor (i = 0; i < ar.n; ++i) { // traverse each hit\n\t\t\tmem_aln_t a;\n\t\t\tif (ar.a[i].secondary >= 0) continue; // skip secondary alignments\n\t\t\ta = mem_reg2aln(opt, idx->bns, idx->pac, ks->seq.l, ks->seq.s, &ar.a[i]); // get forward-strand position and CIGAR\n\t\t\t// print alignment\n\t\t\tprintf(\"%s\\t%c\\t%s\\t%ld\\t%d\\t\", ks->name.s, \"+-\"[a.is_rev], idx->bns->anns[a.rid].name, (long)a.pos, a.mapq);\n\t\t\tfor (k = 0; k < a.n_cigar; ++k) // print CIGAR\n\t\t\t\tprintf(\"%d%c\", a.cigar[k]>>4, \"MIDSH\"[a.cigar[k]&0xf]);\n\t\t\tprintf(\"\\t%d\\n\", a.NM); // print edit distance\n\t\t\tfree(a.cigar); // don't forget to deallocate CIGAR\n\t\t}\n\t\tfree(ar.a); // and deallocate the hit list\n\t}\n\n\tfree(opt);\n\tkseq_destroy(ks);\n\tgzclose(fp);\n\tbwa_idx_destroy(idx);\n\treturn 0;\n}\n"
        },
        {
          "name": "fastmap.c",
          "type": "blob",
          "size": 20.5341796875,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <zlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include <math.h>\n#include \"bwa.h\"\n#include \"bwamem.h\"\n#include \"kvec.h\"\n#include \"utils.h\"\n#include \"bntseq.h\"\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\nextern unsigned char nst_nt4_table[256];\n\nvoid *kopen(const char *fn, int *_fd);\nint kclose(void *a);\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps);\n\ntypedef struct {\n\tkseq_t *ks, *ks2;\n\tmem_opt_t *opt;\n\tmem_pestat_t *pes0;\n\tint64_t n_processed;\n\tint copy_comment, actual_chunk_size;\n\tbwaidx_t *idx;\n} ktp_aux_t;\n\ntypedef struct {\n\tktp_aux_t *aux;\n\tint n_seqs;\n\tbseq1_t *seqs;\n} ktp_data_t;\n\nstatic void *process(void *shared, int step, void *_data)\n{\n\tktp_aux_t *aux = (ktp_aux_t*)shared;\n\tktp_data_t *data = (ktp_data_t*)_data;\n\tint i;\n\tif (step == 0) {\n\t\tktp_data_t *ret;\n\t\tint64_t size = 0;\n\t\tret = calloc(1, sizeof(ktp_data_t));\n\t\tret->seqs = bseq_read(aux->actual_chunk_size, &ret->n_seqs, aux->ks, aux->ks2);\n\t\tif (ret->seqs == 0) {\n\t\t\tfree(ret);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!aux->copy_comment)\n\t\t\tfor (i = 0; i < ret->n_seqs; ++i) {\n\t\t\t\tfree(ret->seqs[i].comment);\n\t\t\t\tret->seqs[i].comment = 0;\n\t\t\t}\n\t\tfor (i = 0; i < ret->n_seqs; ++i) size += ret->seqs[i].l_seq;\n\t\tif (bwa_verbose >= 3)\n\t\t\tfprintf(stderr, \"[M::%s] read %d sequences (%ld bp)...\\n\", __func__, ret->n_seqs, (long)size);\n\t\treturn ret;\n\t} else if (step == 1) {\n\t\tconst mem_opt_t *opt = aux->opt;\n\t\tconst bwaidx_t *idx = aux->idx;\n\t\tif (opt->flag & MEM_F_SMARTPE) {\n\t\t\tbseq1_t *sep[2];\n\t\t\tint n_sep[2];\n\t\t\tmem_opt_t tmp_opt = *opt;\n\t\t\tbseq_classify(data->n_seqs, data->seqs, n_sep, sep);\n\t\t\tif (bwa_verbose >= 3)\n\t\t\t\tfprintf(stderr, \"[M::%s] %d single-end sequences; %d paired-end sequences\\n\", __func__, n_sep[0], n_sep[1]);\n\t\t\tif (n_sep[0]) {\n\t\t\t\ttmp_opt.flag &= ~MEM_F_PE;\n\t\t\t\tmem_process_seqs(&tmp_opt, idx->bwt, idx->bns, idx->pac, aux->n_processed, n_sep[0], sep[0], 0);\n\t\t\t\tfor (i = 0; i < n_sep[0]; ++i)\n\t\t\t\t\tdata->seqs[sep[0][i].id].sam = sep[0][i].sam;\n\t\t\t}\n\t\t\tif (n_sep[1]) {\n\t\t\t\ttmp_opt.flag |= MEM_F_PE;\n\t\t\t\tmem_process_seqs(&tmp_opt, idx->bwt, idx->bns, idx->pac, aux->n_processed + n_sep[0], n_sep[1], sep[1], aux->pes0);\n\t\t\t\tfor (i = 0; i < n_sep[1]; ++i)\n\t\t\t\t\tdata->seqs[sep[1][i].id].sam = sep[1][i].sam;\n\t\t\t}\n\t\t\tfree(sep[0]); free(sep[1]);\n\t\t} else mem_process_seqs(opt, idx->bwt, idx->bns, idx->pac, aux->n_processed, data->n_seqs, data->seqs, aux->pes0);\n\t\taux->n_processed += data->n_seqs;\n\t\treturn data;\n\t} else if (step == 2) {\n\t\tfor (i = 0; i < data->n_seqs; ++i) {\n\t\t\tif (data->seqs[i].sam) err_fputs(data->seqs[i].sam, stdout);\n\t\t\tfree(data->seqs[i].name); free(data->seqs[i].comment);\n\t\t\tfree(data->seqs[i].seq); free(data->seqs[i].qual); free(data->seqs[i].sam);\n\t\t}\n\t\tfree(data->seqs); free(data);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void update_a(mem_opt_t *opt, const mem_opt_t *opt0)\n{\n\tif (opt0->a) { // matching score is changed\n\t\tif (!opt0->b) opt->b *= opt->a;\n\t\tif (!opt0->T) opt->T *= opt->a;\n\t\tif (!opt0->o_del) opt->o_del *= opt->a;\n\t\tif (!opt0->e_del) opt->e_del *= opt->a;\n\t\tif (!opt0->o_ins) opt->o_ins *= opt->a;\n\t\tif (!opt0->e_ins) opt->e_ins *= opt->a;\n\t\tif (!opt0->zdrop) opt->zdrop *= opt->a;\n\t\tif (!opt0->pen_clip5) opt->pen_clip5 *= opt->a;\n\t\tif (!opt0->pen_clip3) opt->pen_clip3 *= opt->a;\n\t\tif (!opt0->pen_unpaired) opt->pen_unpaired *= opt->a;\n\t}\n}\n\nint main_mem(int argc, char *argv[])\n{\n\tmem_opt_t *opt, opt0;\n\tint fd, fd2, i, c, ignore_alt = 0, no_mt_io = 0;\n\tint fixed_chunk_size = -1;\n\tgzFile fp, fp2 = 0;\n\tchar *p, *rg_line = 0, *hdr_line = 0;\n\tconst char *mode = 0;\n\tvoid *ko = 0, *ko2 = 0;\n\tmem_pestat_t pes[4];\n\tktp_aux_t aux;\n\n\tmemset(&aux, 0, sizeof(ktp_aux_t));\n\tmemset(pes, 0, 4 * sizeof(mem_pestat_t));\n\tfor (i = 0; i < 4; ++i) pes[i].failed = 1;\n\n\taux.opt = opt = mem_opt_init();\n\tmemset(&opt0, 0, sizeof(mem_opt_t));\n\twhile ((c = getopt(argc, argv, \"51qpaMCSPVYjuk:c:v:s:r:t:R:A:B:O:E:U:w:L:d:T:Q:D:m:I:N:o:f:W:x:G:h:y:K:X:H:F:z:\")) >= 0) {\n\t\tif (c == 'k') opt->min_seed_len = atoi(optarg), opt0.min_seed_len = 1;\n\t\telse if (c == '1') no_mt_io = 1;\n\t\telse if (c == 'x') mode = optarg;\n\t\telse if (c == 'w') opt->w = atoi(optarg), opt0.w = 1;\n\t\telse if (c == 'A') opt->a = atoi(optarg), opt0.a = 1;\n\t\telse if (c == 'B') opt->b = atoi(optarg), opt0.b = 1;\n\t\telse if (c == 'T') opt->T = atoi(optarg), opt0.T = 1;\n\t\telse if (c == 'U') opt->pen_unpaired = atoi(optarg), opt0.pen_unpaired = 1;\n\t\telse if (c == 't') opt->n_threads = atoi(optarg), opt->n_threads = opt->n_threads > 1? opt->n_threads : 1;\n\t\telse if (c == 'P') opt->flag |= MEM_F_NOPAIRING;\n\t\telse if (c == 'a') opt->flag |= MEM_F_ALL;\n\t\telse if (c == 'p') opt->flag |= MEM_F_PE | MEM_F_SMARTPE;\n\t\telse if (c == 'M') opt->flag |= MEM_F_NO_MULTI;\n\t\telse if (c == 'S') opt->flag |= MEM_F_NO_RESCUE;\n\t\telse if (c == 'Y') opt->flag |= MEM_F_SOFTCLIP;\n\t\telse if (c == 'V') opt->flag |= MEM_F_REF_HDR;\n\t\telse if (c == '5') opt->flag |= MEM_F_PRIMARY5 | MEM_F_KEEP_SUPP_MAPQ; // always apply MEM_F_KEEP_SUPP_MAPQ with -5\n\t\telse if (c == 'q') opt->flag |= MEM_F_KEEP_SUPP_MAPQ;\n\t\telse if (c == 'u') opt->flag |= MEM_F_XB;\n\t\telse if (c == 'c') opt->max_occ = atoi(optarg), opt0.max_occ = 1;\n\t\telse if (c == 'd') opt->zdrop = atoi(optarg), opt0.zdrop = 1;\n\t\telse if (c == 'v') bwa_verbose = atoi(optarg);\n\t\telse if (c == 'j') ignore_alt = 1;\n\t\telse if (c == 'r') opt->split_factor = atof(optarg), opt0.split_factor = 1.;\n\t\telse if (c == 'D') opt->drop_ratio = atof(optarg), opt0.drop_ratio = 1.;\n\t\telse if (c == 'm') opt->max_matesw = atoi(optarg), opt0.max_matesw = 1;\n\t\telse if (c == 's') opt->split_width = atoi(optarg), opt0.split_width = 1;\n\t\telse if (c == 'G') opt->max_chain_gap = atoi(optarg), opt0.max_chain_gap = 1;\n\t\telse if (c == 'N') opt->max_chain_extend = atoi(optarg), opt0.max_chain_extend = 1;\n\t\telse if (c == 'o' || c == 'f') xreopen(optarg, \"wb\", stdout);\n\t\telse if (c == 'W') opt->min_chain_weight = atoi(optarg), opt0.min_chain_weight = 1;\n\t\telse if (c == 'y') opt->max_mem_intv = atol(optarg), opt0.max_mem_intv = 1;\n\t\telse if (c == 'C') aux.copy_comment = 1;\n\t\telse if (c == 'K') fixed_chunk_size = atoi(optarg);\n\t\telse if (c == 'X') opt->mask_level = atof(optarg);\n\t\telse if (c == 'F') bwa_dbg = atoi(optarg);\n\t\telse if (c == 'h') {\n\t\t\topt0.max_XA_hits = opt0.max_XA_hits_alt = 1;\n\t\t\topt->max_XA_hits = opt->max_XA_hits_alt = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->max_XA_hits_alt = strtol(p+1, &p, 10);\n\t\t}\n\t\telse if (c == 'z') opt->XA_drop_ratio = atof(optarg);\n\t\telse if (c == 'Q') {\n\t\t\topt0.mapQ_coef_len = 1;\n\t\t\topt->mapQ_coef_len = atoi(optarg);\n\t\t\topt->mapQ_coef_fac = opt->mapQ_coef_len > 0? log(opt->mapQ_coef_len) : 0;\n\t\t} else if (c == 'O') {\n\t\t\topt0.o_del = opt0.o_ins = 1;\n\t\t\topt->o_del = opt->o_ins = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->o_ins = strtol(p+1, &p, 10);\n\t\t} else if (c == 'E') {\n\t\t\topt0.e_del = opt0.e_ins = 1;\n\t\t\topt->e_del = opt->e_ins = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->e_ins = strtol(p+1, &p, 10);\n\t\t} else if (c == 'L') {\n\t\t\topt0.pen_clip5 = opt0.pen_clip3 = 1;\n\t\t\topt->pen_clip5 = opt->pen_clip3 = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->pen_clip3 = strtol(p+1, &p, 10);\n\t\t} else if (c == 'R') {\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1; // FIXME: memory leak\n\t\t} else if (c == 'H') {\n\t\t\tif (optarg[0] != '@') {\n\t\t\t\tFILE *fp;\n\t\t\t\tif ((fp = fopen(optarg, \"r\")) != 0) {\n\t\t\t\t\tchar *buf;\n\t\t\t\t\tbuf = calloc(1, 0x10000);\n\t\t\t\t\twhile (fgets(buf, 0xffff, fp)) {\n\t\t\t\t\t\ti = strlen(buf);\n\t\t\t\t\t\tassert(buf[i-1] == '\\n'); // a long line\n\t\t\t\t\t\tbuf[i-1] = 0;\n\t\t\t\t\t\thdr_line = bwa_insert_header(buf, hdr_line);\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t} else hdr_line = bwa_insert_header(optarg, hdr_line);\n\t\t} else if (c == 'I') { // specify the insert size distribution\n\t\t\taux.pes0 = pes;\n\t\t\tpes[1].failed = 0;\n\t\t\tpes[1].avg = strtod(optarg, &p);\n\t\t\tpes[1].std = pes[1].avg * .1;\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].std = strtod(p+1, &p);\n\t\t\tpes[1].high = (int)(pes[1].avg + 4. * pes[1].std + .499);\n\t\t\tpes[1].low  = (int)(pes[1].avg - 4. * pes[1].std + .499);\n\t\t\tif (pes[1].low < 1) pes[1].low = 1;\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].high = (int)(strtod(p+1, &p) + .499);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].low  = (int)(strtod(p+1, &p) + .499);\n\t\t\tif (bwa_verbose >= 3)\n\t\t\t\tfprintf(stderr, \"[M::%s] mean insert size: %.3f, stddev: %.3f, max: %d, min: %d\\n\",\n\t\t\t\t\t\t__func__, pes[1].avg, pes[1].std, pes[1].high, pes[1].low);\n\t\t}\n\t\telse return 1;\n\t}\n\n\tif (rg_line) {\n\t\thdr_line = bwa_insert_header(rg_line, hdr_line);\n\t\tfree(rg_line);\n\t}\n\n\tif (opt->n_threads < 1) opt->n_threads = 1;\n\tif (optind + 1 >= argc || optind + 3 < argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage: bwa mem [options] <idxbase> <in1.fq> [in2.fq]\\n\\n\");\n\t\tfprintf(stderr, \"Algorithm options:\\n\\n\");\n\t\tfprintf(stderr, \"       -t INT        number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"       -k INT        minimum seed length [%d]\\n\", opt->min_seed_len);\n\t\tfprintf(stderr, \"       -w INT        band width for banded alignment [%d]\\n\", opt->w);\n\t\tfprintf(stderr, \"       -d INT        off-diagonal X-dropoff [%d]\\n\", opt->zdrop);\n\t\tfprintf(stderr, \"       -r FLOAT      look for internal seeds inside a seed longer than {-k} * FLOAT [%g]\\n\", opt->split_factor);\n\t\tfprintf(stderr, \"       -y INT        seed occurrence for the 3rd round seeding [%ld]\\n\", (long)opt->max_mem_intv);\n//\t\tfprintf(stderr, \"       -s INT        look for internal seeds inside a seed with less than INT occ [%d]\\n\", opt->split_width);\n\t\tfprintf(stderr, \"       -c INT        skip seeds with more than INT occurrences [%d]\\n\", opt->max_occ);\n\t\tfprintf(stderr, \"       -D FLOAT      drop chains shorter than FLOAT fraction of the longest overlapping chain [%.2f]\\n\", opt->drop_ratio);\n\t\tfprintf(stderr, \"       -W INT        discard a chain if seeded bases shorter than INT [0]\\n\");\n\t\tfprintf(stderr, \"       -m INT        perform at most INT rounds of mate rescues for each read [%d]\\n\", opt->max_matesw);\n\t\tfprintf(stderr, \"       -S            skip mate rescue\\n\");\n\t\tfprintf(stderr, \"       -P            skip pairing; mate rescue performed unless -S also in use\\n\");\n\t\tfprintf(stderr, \"\\nScoring options:\\n\\n\");\n\t\tfprintf(stderr, \"       -A INT        score for a sequence match, which scales options -TdBOELU unless overridden [%d]\\n\", opt->a);\n\t\tfprintf(stderr, \"       -B INT        penalty for a mismatch [%d]\\n\", opt->b);\n\t\tfprintf(stderr, \"       -O INT[,INT]  gap open penalties for deletions and insertions [%d,%d]\\n\", opt->o_del, opt->o_ins);\n\t\tfprintf(stderr, \"       -E INT[,INT]  gap extension penalty; a gap of size k cost '{-O} + {-E}*k' [%d,%d]\\n\", opt->e_del, opt->e_ins);\n\t\tfprintf(stderr, \"       -L INT[,INT]  penalty for 5'- and 3'-end clipping [%d,%d]\\n\", opt->pen_clip5, opt->pen_clip3);\n\t\tfprintf(stderr, \"       -U INT        penalty for an unpaired read pair [%d]\\n\\n\", opt->pen_unpaired);\n\t\tfprintf(stderr, \"       -x STR        read type. Setting -x changes multiple parameters unless overridden [null]\\n\");\n\t\tfprintf(stderr, \"                     pacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref)\\n\");\n\t\tfprintf(stderr, \"                     ont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref)\\n\");\n\t\tfprintf(stderr, \"                     intractg: -B9 -O16 -L5  (intra-species contigs to ref)\\n\");\n\t\tfprintf(stderr, \"\\nInput/output options:\\n\\n\");\n\t\tfprintf(stderr, \"       -p            smart pairing (ignoring in2.fq)\\n\");\n\t\tfprintf(stderr, \"       -R STR        read group header line such as '@RG\\\\tID:foo\\\\tSM:bar' [null]\\n\");\n\t\tfprintf(stderr, \"       -H STR/FILE   insert STR to header if it starts with @; or insert lines in FILE [null]\\n\");\n\t\tfprintf(stderr, \"       -o FILE       sam file to output results to [stdout]\\n\");\n\t\tfprintf(stderr, \"       -j            treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)\\n\");\n\t\tfprintf(stderr, \"       -5            for split alignment, take the alignment with the smallest query (not genomic) coordinate as primary\\n\");\n\t\tfprintf(stderr, \"       -q            don't modify mapQ of supplementary alignments\\n\");\n\t\tfprintf(stderr, \"       -K INT        process INT input bases in each batch regardless of nThreads (for reproducibility) []\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"       -v INT        verbosity level: 1=error, 2=warning, 3=message, 4+=debugging [%d]\\n\", bwa_verbose);\n\t\tfprintf(stderr, \"       -T INT        minimum score to output [%d]\\n\", opt->T);\n\t\tfprintf(stderr, \"       -h INT[,INT]  if there are <INT hits with score >%.2f%% of the max score, output all in XA [%d,%d]\\n\", \n\t\t\t\topt->XA_drop_ratio * 100.0,\n\t\t\t\topt->max_XA_hits, opt->max_XA_hits_alt);\n\t\tfprintf(stderr, \"                     A second value may be given for alternate sequences.\\n\");\n\t\tfprintf(stderr, \"       -z FLOAT      The fraction of the max score to use with -h [%f].\\n\", opt->XA_drop_ratio);\n\t\tfprintf(stderr, \"                     specify the mean, standard deviation (10%% of the mean if absent), max\\n\");\n\t\tfprintf(stderr, \"       -a            output all alignments for SE or unpaired PE\\n\");\n\t\tfprintf(stderr, \"       -C            append FASTA/FASTQ comment to SAM output\\n\");\n\t\tfprintf(stderr, \"       -V            output the reference FASTA header in the XR tag\\n\");\n\t\tfprintf(stderr, \"       -Y            use soft clipping for supplementary alignments\\n\");\n\t\tfprintf(stderr, \"       -M            mark shorter split hits as secondary\\n\\n\");\n\t\tfprintf(stderr, \"       -I FLOAT[,FLOAT[,INT[,INT]]]\\n\");\n\t\tfprintf(stderr, \"                     specify the mean, standard deviation (10%% of the mean if absent), max\\n\");\n\t\tfprintf(stderr, \"                     (4 sigma from the mean if absent) and min of the insert size distribution.\\n\");\n\t\tfprintf(stderr, \"                     FR orientation only. [inferred]\\n\");\n\t\tfprintf(stderr, \"       -u            output XB instead of XA; XB is XA with the alignment score and mapping quality added.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Note: Please read the man page for detailed description of the command line and options.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\n\tif (mode) {\n\t\tif (strcmp(mode, \"intractg\") == 0) {\n\t\t\tif (!opt0.o_del) opt->o_del = 16;\n\t\t\tif (!opt0.o_ins) opt->o_ins = 16;\n\t\t\tif (!opt0.b) opt->b = 9;\n\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 5;\n\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 5;\n\t\t} else if (strcmp(mode, \"pacbio\") == 0 || strcmp(mode, \"pbref\") == 0 || strcmp(mode, \"ont2d\") == 0) {\n\t\t\tif (!opt0.o_del) opt->o_del = 1;\n\t\t\tif (!opt0.e_del) opt->e_del = 1;\n\t\t\tif (!opt0.o_ins) opt->o_ins = 1;\n\t\t\tif (!opt0.e_ins) opt->e_ins = 1;\n\t\t\tif (!opt0.b) opt->b = 1;\n\t\t\tif (opt0.split_factor == 0.) opt->split_factor = 10.;\n\t\t\tif (strcmp(mode, \"ont2d\") == 0) {\n\t\t\t\tif (!opt0.min_chain_weight) opt->min_chain_weight = 20;\n\t\t\t\tif (!opt0.min_seed_len) opt->min_seed_len = 14;\n\t\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 0;\n\t\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 0;\n\t\t\t} else {\n\t\t\t\tif (!opt0.min_chain_weight) opt->min_chain_weight = 40;\n\t\t\t\tif (!opt0.min_seed_len) opt->min_seed_len = 17;\n\t\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 0;\n\t\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"[E::%s] unknown read type '%s'\\n\", __func__, mode);\n\t\t\treturn 1; // FIXME memory leak\n\t\t}\n\t} else update_a(opt, &opt0);\n\tbwa_fill_scmat(opt->a, opt->b, opt->mat);\n\n\taux.idx = bwa_idx_load_from_shm(argv[optind]);\n\tif (aux.idx == 0) {\n\t\tif ((aux.idx = bwa_idx_load(argv[optind], BWA_IDX_ALL)) == 0) return 1; // FIXME: memory leak\n\t} else if (bwa_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] load the bwa index from shared memory\\n\", __func__);\n\tif (ignore_alt)\n\t\tfor (i = 0; i < aux.idx->bns->n_seqs; ++i)\n\t\t\taux.idx->bns->anns[i].is_alt = 0;\n\n\tko = kopen(argv[optind + 1], &fd);\n\tif (ko == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to open file `%s'.\\n\", __func__, argv[optind + 1]);\n\t\treturn 1;\n\t}\n\tfp = gzdopen(fd, \"r\");\n\taux.ks = kseq_init(fp);\n\tif (optind + 2 < argc) {\n\t\tif (opt->flag&MEM_F_PE) {\n\t\t\tif (bwa_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[W::%s] when '-p' is in use, the second query file is ignored.\\n\", __func__);\n\t\t} else {\n\t\t\tko2 = kopen(argv[optind + 2], &fd2);\n\t\t\tif (ko2 == 0) {\n\t\t\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to open file `%s'.\\n\", __func__, argv[optind + 2]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfp2 = gzdopen(fd2, \"r\");\n\t\t\taux.ks2 = kseq_init(fp2);\n\t\t\topt->flag |= MEM_F_PE;\n\t\t}\n\t}\n\tbwa_print_sam_hdr(aux.idx->bns, hdr_line);\n\taux.actual_chunk_size = fixed_chunk_size > 0? fixed_chunk_size : opt->chunk_size * opt->n_threads;\n\tkt_pipeline(no_mt_io? 1 : 2, process, &aux, 3);\n\tfree(hdr_line);\n\tfree(opt);\n\tbwa_idx_destroy(aux.idx);\n\tkseq_destroy(aux.ks);\n\terr_gzclose(fp); kclose(ko);\n\tif (aux.ks2) {\n\t\tkseq_destroy(aux.ks2);\n\t\terr_gzclose(fp2); kclose(ko2);\n\t}\n\treturn 0;\n}\n\nint main_fastmap(int argc, char *argv[])\n{\n\tint c, i, min_iwidth = 20, min_len = 17, print_seq = 0, min_intv = 1, max_len = INT_MAX;\n\tuint64_t max_intv = 0;\n\tkseq_t *seq;\n\tbwtint_t k;\n\tgzFile fp;\n\tsmem_i *itr;\n\tconst bwtintv_v *a;\n\tbwaidx_t *idx;\n\n\twhile ((c = getopt(argc, argv, \"w:l:pi:I:L:\")) >= 0) {\n\t\tswitch (c) {\n\t\t\tcase 'p': print_seq = 1; break;\n\t\t\tcase 'w': min_iwidth = atoi(optarg); break;\n\t\t\tcase 'l': min_len = atoi(optarg); break;\n\t\t\tcase 'i': min_intv = atoi(optarg); break;\n\t\t\tcase 'I': max_intv = atol(optarg); break;\n\t\t\tcase 'L': max_len  = atoi(optarg); break;\n\t\t    default: return 1;\n\t\t}\n\t}\n\tif (optind + 1 >= argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa fastmap [options] <idxbase> <in.fq>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -l INT    min SMEM length to output [%d]\\n\", min_len);\n\t\tfprintf(stderr, \"         -w INT    max interval size to find coordiantes [%d]\\n\", min_iwidth);\n\t\tfprintf(stderr, \"         -i INT    min SMEM interval size [%d]\\n\", min_intv);\n\t\tfprintf(stderr, \"         -L INT    max MEM length [%d]\\n\", max_len);\n\t\tfprintf(stderr, \"         -I INT    stop if MEM is longer than -l with a size less than INT [%ld]\\n\", (long)max_intv);\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 1;\n\t}\n\n\tfp = xzopen(argv[optind + 1], \"r\");\n\tseq = kseq_init(fp);\n\tif ((idx = bwa_idx_load(argv[optind], BWA_IDX_BWT|BWA_IDX_BNS)) == 0) return 1;\n\titr = smem_itr_init(idx->bwt);\n\tsmem_config(itr, min_intv, max_len, max_intv);\n\twhile (kseq_read(seq) >= 0) {\n\t\terr_printf(\"SQ\\t%s\\t%ld\", seq->name.s, seq->seq.l);\n\t\tif (print_seq) {\n\t\t\terr_putchar('\\t');\n\t\t\terr_puts(seq->seq.s);\n\t\t} else err_putchar('\\n');\n\t\tfor (i = 0; i < seq->seq.l; ++i)\n\t\t\tseq->seq.s[i] = nst_nt4_table[(int)seq->seq.s[i]];\n\t\tsmem_set_query(itr, seq->seq.l, (uint8_t*)seq->seq.s);\n\t\twhile ((a = smem_next(itr)) != 0) {\n\t\t\tfor (i = 0; i < a->n; ++i) {\n\t\t\t\tbwtintv_t *p = &a->a[i];\n\t\t\t\tif ((uint32_t)p->info - (p->info>>32) < min_len) continue;\n\t\t\t\terr_printf(\"EM\\t%d\\t%d\\t%ld\", (uint32_t)(p->info>>32), (uint32_t)p->info, (long)p->x[2]);\n\t\t\t\tif (p->x[2] <= min_iwidth) {\n\t\t\t\t\tfor (k = 0; k < p->x[2]; ++k) {\n\t\t\t\t\t\tbwtint_t pos;\n\t\t\t\t\t\tint len, is_rev, ref_id;\n\t\t\t\t\t\tlen  = (uint32_t)p->info - (p->info>>32);\n\t\t\t\t\t\tpos = bns_depos(idx->bns, bwt_sa(idx->bwt, p->x[0] + k), &is_rev);\n\t\t\t\t\t\tif (is_rev) pos -= len - 1;\n\t\t\t\t\t\tbns_cnt_ambi(idx->bns, pos, len, &ref_id);\n\t\t\t\t\t\terr_printf(\"\\t%s:%c%ld\", idx->bns->anns[ref_id].name, \"+-\"[is_rev], (long)(pos - idx->bns->anns[ref_id].offset) + 1);\n\t\t\t\t\t}\n\t\t\t\t} else err_puts(\"\\t*\");\n\t\t\t\terr_putchar('\\n');\n\t\t\t}\n\t\t}\n\t\terr_puts(\"//\");\n\t}\n\n\tsmem_itr_destroy(itr);\n\tbwa_idx_destroy(idx);\n\tkseq_destroy(seq);\n\terr_gzclose(fp);\n\treturn 0;\n}\n"
        },
        {
          "name": "is.c",
          "type": "blob",
          "size": 6.517578125,
          "content": "/*\n * sais.c for sais-lite\n * Copyright (c) 2008 Yuta Mori All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdlib.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef unsigned char ubyte_t;\n#define chr(i) (cs == sizeof(int) ? ((const int *)T)[i]:((const unsigned char *)T)[i])\n\n/* find the start or end of each bucket */\nstatic void getCounts(const unsigned char *T, int *C, int n, int k, int cs)\n{\n\tint i;\n\tfor (i = 0; i < k; ++i) C[i] = 0;\n\tfor (i = 0; i < n; ++i) ++C[chr(i)];\n}\nstatic void getBuckets(const int *C, int *B, int k, int end)\n{\n\tint i, sum = 0;\n\tif (end) {\n\t\tfor (i = 0; i < k; ++i) {\n\t\t\tsum += C[i];\n\t\t\tB[i] = sum;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < k; ++i) {\n\t\t\tsum += C[i];\n\t\t\tB[i] = sum - C[i];\n\t\t}\n\t}\n}\n\n/* compute SA */\nstatic void induceSA(const unsigned char *T, int *SA, int *C, int *B, int n, int k, int cs)\n{\n\tint *b, i, j;\n\tint  c0, c1;\n\t/* compute SAl */\n\tif (C == B) getCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 0);\t/* find starts of buckets */\n\tj = n - 1;\n\tb = SA + B[c1 = chr(j)];\n\t*b++ = ((0 < j) && (chr(j - 1) < c1)) ? ~j : j;\n\tfor (i = 0; i < n; ++i) {\n\t\tj = SA[i], SA[i] = ~j;\n\t\tif (0 < j) {\n\t\t\t--j;\n\t\t\tif ((c0 = chr(j)) != c1) {\n\t\t\t\tB[c1] = b - SA;\n\t\t\t\tb = SA + B[c1 = c0];\n\t\t\t}\n\t\t\t*b++ = ((0 < j) && (chr(j - 1) < c1)) ? ~j : j;\n\t\t}\n\t}\n\t/* compute SAs */\n\tif (C == B) getCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = n - 1, b = SA + B[c1 = 0]; 0 <= i; --i) {\n\t\tif (0 < (j = SA[i])) {\n\t\t\t--j;\n\t\t\tif ((c0 = chr(j)) != c1) {\n\t\t\t\tB[c1] = b - SA;\n\t\t\t\tb = SA + B[c1 = c0];\n\t\t\t}\n\t\t\t*--b = ((j == 0) || (chr(j - 1) > c1)) ? ~j : j;\n\t\t} else SA[i] = ~j;\n\t}\n}\n\n/*\n * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working\n * space (excluding T and SA) of at most 2n+O(1) for a constant alphabet\n */\nstatic int sais_main(const unsigned char *T, int *SA, int fs, int n, int k, int cs)\n{\n\tint *C, *B, *RA;\n\tint  i, j, c, m, p, q, plen, qlen, name;\n\tint  c0, c1;\n\tint  diff;\n\n\t/* stage 1: reduce the problem by at least 1/2 sort all the\n\t * S-substrings */\n\tif (k <= fs) {\n\t\tC = SA + n;\n\t\tB = (k <= (fs - k)) ? C + k : C;\n\t} else if ((C = B = (int *) malloc(k * sizeof(int))) == NULL) return -2;\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = 0; i < n; ++i) SA[i] = 0;\n\tfor (i = n - 2, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\telse if (c != 0) SA[--B[c1]] = i + 1, c = 0;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\t/* compact all the sorted substrings into the first m items of SA\n\t * 2*m must be not larger than n (proveable) */\n\tfor (i = 0, m = 0; i < n; ++i) {\n\t\tp = SA[i];\n\t\tif ((0 < p) && (chr(p - 1) > (c0 = chr(p)))) {\n\t\t\tfor (j = p + 1; (j < n) && (c0 == (c1 = chr(j))); ++j);\n\t\t\tif ((j < n) && (c0 < c1)) SA[m++] = p;\n\t\t}\n\t}\n\tfor (i = m; i < n; ++i) SA[i] = 0;\t/* init the name array buffer */\n\t/* store the length of all substrings */\n\tfor (i = n - 2, j = n, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\telse if (c != 0) {\n\t\t\tSA[m + ((i + 1) >> 1)] = j - i - 1;\n\t\t\tj = i + 1;\n\t\t\tc = 0;\n\t\t}\n\t}\n\t/* find the lexicographic names of all substrings */\n\tfor (i = 0, name = 0, q = n, qlen = 0; i < m; ++i) {\n\t\tp = SA[i], plen = SA[m + (p >> 1)], diff = 1;\n\t\tif (plen == qlen) {\n\t\t\tfor (j = 0; (j < plen) && (chr(p + j) == chr(q + j)); j++);\n\t\t\tif (j == plen) diff = 0;\n\t\t}\n\t\tif (diff != 0) ++name, q = p, qlen = plen;\n\t\tSA[m + (p >> 1)] = name;\n\t}\n\n\t/* stage 2: solve the reduced problem recurse if names are not yet\n\t * unique */\n\tif (name < m) {\n\t\tRA = SA + n + fs - m;\n\t\tfor (i = n - 1, j = m - 1; m <= i; --i) {\n\t\t\tif (SA[i] != 0) RA[j--] = SA[i] - 1;\n\t\t}\n\t\tif (sais_main((unsigned char *) RA, SA, fs + n - m * 2, m, name, sizeof(int)) != 0) return -2;\n\t\tfor (i = n - 2, j = m - 1, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\t\telse if (c != 0) RA[j--] = i + 1, c = 0; /* get p1 */\n\t\t}\n\t\tfor (i = 0; i < m; ++i) SA[i] = RA[SA[i]]; /* get index */\n\t}\n\t/* stage 3: induce the result for the original problem */\n\tif (k <= fs) {\n\t\tC = SA + n;\n\t\tB = (k <= (fs - k)) ? C + k : C;\n\t} else if ((C = B = (int *) malloc(k * sizeof(int))) == NULL) return -2;\n\t/* put all left-most S characters into their buckets */\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = m; i < n; ++i) SA[i] = 0; /* init SA[m..n-1] */\n\tfor (i = m - 1; 0 <= i; --i) {\n\t\tj = SA[i], SA[i] = 0;\n\t\tSA[--B[chr(j)]] = j;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\treturn 0;\n}\n\n/**\n * Constructs the suffix array of a given string.\n * @param T[0..n-1] The input string.\n * @param SA[0..n] The output array of suffixes.\n * @param n The length of the given string.\n * @return 0 if no error occurred\n */\nint is_sa(const ubyte_t *T, int *SA, int n)\n{\n\tif ((T == NULL) || (SA == NULL) || (n < 0)) return -1;\n\tSA[0] = n;\n\tif (n <= 1) {\n\t\tif (n == 1) SA[1] = 0;\n\t\treturn 0;\n\t}\n\treturn sais_main(T, SA+1, 0, n, 256, 1);\n}\n\n/**\n * Constructs the burrows-wheeler transformed string of a given string.\n * @param T[0..n-1] The input string.\n * @param n The length of the given string.\n * @return The primary index if no error occurred, -1 or -2 otherwise.\n */\nint is_bwt(ubyte_t *T, int n)\n{\n\tint *SA, i, primary = 0;\n\tSA = (int*)calloc(n+1, sizeof(int));\n\n\tif (is_sa(T, SA, n)) return -1;\n\n\tfor (i = 0; i <= n; ++i) {\n\t\tif (SA[i] == 0) primary = i;\n\t\telse SA[i] = T[SA[i] - 1];\n\t}\n\tfor (i = 0; i < primary; ++i) T[i] = SA[i];\n\tfor (; i < n; ++i) T[i] = SA[i + 1];\n\tfree(SA);\n\treturn primary;\n}\n"
        },
        {
          "name": "kbtree.h",
          "type": "blob",
          "size": 15.5166015625,
          "content": "/*-\n * Copyright 1997-1999, 2001, John-Mark Gurney.\n *           2008-2009, Attractive Chaos <attractor@live.co.uk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef __AC_KBTREE_H\n#define __AC_KBTREE_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef struct {\n\tint32_t is_internal:1, n:31;\n} kbnode_t;\n\n#define\t__KB_KEY(type, x)\t((type*)((char*)x + 4))\n#define __KB_PTR(btr, x)\t((kbnode_t**)((char*)x + btr->off_ptr))\n\n#define __KB_TREE_T(name)\t\t\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\\\n\t\tkbnode_t *root;\t\t\t\t\t\t\t\\\n\t\tint\toff_key, off_ptr, ilen, elen;\t\t\\\n\t\tint\tn, t;\t\t\t\t\t\t\t\t\\\n\t\tint\tn_keys, n_nodes;\t\t\t\t\t\\\n\t} kbtree_##name##_t;\n\n#define __KB_INIT(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tkbtree_##name##_t *kb_init_##name(int size)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbtree_##name##_t *b;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb = (kbtree_##name##_t*)calloc(1, sizeof(kbtree_##name##_t));\t\\\n\t\tb->t = ((size - 4 - sizeof(void*)) / (sizeof(void*) + sizeof(key_t)) + 1) >> 1; \\\n\t\tif (b->t < 2) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(b); return 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb->n = 2 * b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb->off_ptr = 4 + b->n * sizeof(key_t);\t\t\t\t\t\t\t\\\n\t\tb->ilen = (4 + sizeof(void*) + b->n * (sizeof(void*) + sizeof(key_t)) + 3) >> 2 << 2; \\\n\t\tb->elen = (b->off_ptr + 3) >> 2 << 2;\t\t\t\t\t\t\t\\\n\t\tb->root = (kbnode_t*)calloc(1, b->ilen);\t\t\t\t\t\t\\\n\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn b;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __kb_destroy(b) do {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, max = 8;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x, **top, **stack = 0;\t\t\t\t\t\t\t\t\\\n\t\tif (b) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttop = stack = (kbnode_t**)calloc(max, sizeof(kbnode_t*));\t\\\n\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x == 0 || x->is_internal == 0) { free(x); continue; } \\\n\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (top - stack == max) {\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tstack = (kbnode_t**)realloc(stack, max * sizeof(kbnode_t*)); \\\n\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(x);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(b); free(stack);\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __kb_get_first(key_t, b, ret) do {\t\\\n\t\tkbnode_t *__x = (b)->root;\t\t\t\\\n\t\twhile (__KB_PTR(b, __x)[0] != 0)\t\\\n\t\t\t__x = __KB_PTR(b, __x)[0];\t\t\\\n\t\t(ret) = __KB_KEY(key_t, __x)[0];\t\\\n\t} while (0)\n\n#define __KB_GET_AUX0(name, key_t, __cmp)\t\t\t\t\t\t\t\t\\\n\tstatic inline int __kb_get_aux_##name(const kbnode_t * __restrict x, const key_t * __restrict k, int *r) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint tr, *rr, begin, end, n = x->n >> 1;\t\t\t\t\t\t\t\\\n\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (__cmp(*k, __KB_KEY(key_t, x)[n]) < 0) {\t\t\t\t\t\t\\\n\t\t\tbegin = 0; end = n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else { begin = n; end = x->n - 1; }\t\t\t\t\t\t\t\\\n\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tn = end;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (n >= begin && (*rr = __cmp(*k, __KB_KEY(key_t, x)[n])) < 0) --n; \\\n\t\treturn n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_GET_AUX1(name, key_t, __cmp)\t\t\t\t\t\t\t\t\\\n\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, const key_t * __restrict k, int *r) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\\n\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\\n\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (begin < end) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\\n\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\\n\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\\n\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\\n\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_GET(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\\n\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\\n\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_INTERVAL(name, key_t)\t\t\t\t\t\t\t\t\t\t\\\n\tstatic void kb_intervalp_##name(kbtree_##name##_t *b, const key_t * __restrict k, key_t **lower, key_t **upper)\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\\n\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\\n\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\\n\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\\n\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, const key_t k, key_t **lower, key_t **upper) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\\n\t}\n\n#define __KB_PUT(name, key_t, __cmp)\t\t\t\t\t\t\t\t\t\\\n\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\\n\tstatic void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tz = (kbnode_t*)calloc(1, y->is_internal? b->ilen : b->elen);\t\\\n\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\\n\t\tz->n = b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(__KB_KEY(key_t, z), __KB_KEY(key_t, y) + b->t, sizeof(key_t) * (b->t - 1)); \\\n\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), __KB_PTR(b, y) + b->t, sizeof(void*) * b->t); \\\n\t\ty->n = b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemmove(__KB_PTR(b, x) + i + 2, __KB_PTR(b, x) + i + 1, sizeof(void*) * (x->n - i)); \\\n\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemmove(__KB_KEY(key_t, x) + i + 1, __KB_KEY(key_t, x) + i, sizeof(key_t) * (x->n - i)); \\\n\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[b->t - 1];\t\t\t\\\n\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic void __kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\\n\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i + 2, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t__KB_KEY(key_t, x)[i + 1] = *k;\t\t\t\t\t\t\t\t\\\n\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, 0) + 1;\t\t\t\t\t\t\\\n\t\t\tif (__KB_PTR(b, x)[i]->n == 2 * b->t - 1) {\t\t\t\t\t\\\n\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\\n\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic void kb_putp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (r->n == 2 * b->t - 1) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ts = (kbnode_t*)calloc(1, b->ilen);\t\t\t\t\t\t\t\\\n\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\\n\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__kb_split_##name(b, s, 0, r);\t\t\t\t\t\t\t\t\\\n\t\t\tr = s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t__kb_putp_aux_##name(b, r, k);\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void kb_put_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n\n#define __KB_DEL(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, const key_t * __restrict k, int s) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *xp, *y, *z;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\\n\t\t\tr = x->is_internal == 0? 0 : s == 1? 1 : -1;\t\t\t\t\\\n\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\\n\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\\n\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (r == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif ((yn = __KB_PTR(b, x)[i]->n) >= b->t) {\t\t\t\t\t\\\n\t\t\t\txp = __KB_PTR(b, x)[i];\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \\\n\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= b->t) {\t\t\\\n\t\t\t\txp = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\\\n\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \\\n\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (yn == b->t - 1 && zn == b->t - 1) {\t\t\t\t\\\n\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\\n\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, z), z->n * sizeof(key_t)); \\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, z), (z->n + 1) * sizeof(void*)); \\\n\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(z);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\treturn __kb_delp_aux_##name(b, y, k, s);\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif ((xp = __KB_PTR(b, x)[i])->n == b->t - 1) {\t\t\t\t\t\\\n\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= b->t) {\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, xp) + 1, __KB_KEY(key_t, xp), xp->n * sizeof(key_t)); \\\n\t\t\t\tif (xp->is_internal) memmove(__KB_PTR(b, xp) + 1, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \\\n\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\\n\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\\n\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= b->t) { \\\n\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\\n\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\\n\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y), __KB_KEY(key_t, y) + 1, y->n * sizeof(key_t)); \\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), __KB_PTR(b, y) + 1, (y->n + 1) * sizeof(void*)); \\\n\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == b->t - 1) { \\\n\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, xp), xp->n * sizeof(key_t));\t\\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \\\n\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i - 1, __KB_KEY(key_t, x) + i, (x->n - i) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i, __KB_PTR(b, x) + i + 1, (x->n - i) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\txp = y;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == b->t - 1) { \\\n\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, xp) + xp->n, __KB_KEY(key_t, y), y->n * sizeof(key_t));\t\\\n\t\t\t\tif (xp->is_internal) memmove(__KB_PTR(b, xp) + xp->n, __KB_PTR(b, y), (y->n + 1) * sizeof(void*)); \\\n\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn __kb_delp_aux_##name(b, xp, k, s);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t kb_delp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkey_t ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\\n\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\\n\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tb->root = __KB_PTR(b, x)[0];\t\t\t\t\t\t\t\t\\\n\t\t\tfree(x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\\n\t}\n\ntypedef struct {\n\tkbnode_t *x;\n\tint i;\n} __kbstack_t;\n\n#define __kb_traverse(key_t, b, __func) do {\t\t\t\t\t\t\t\\\n\t\tint __kmax = 8;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t__kbstack_t *__kstack, *__kp;\t\t\t\t\t\t\t\t\t\\\n\t\t__kp = __kstack = (__kbstack_t*)calloc(__kmax, sizeof(__kbstack_t)); \\\n\t\t__kp->x = (b)->root; __kp->i = 0;\t\t\t\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\twhile (__kp->x && __kp->i <= __kp->x->n) {\t\t\t\t\t\\\n\t\t\t\tif (__kp - __kstack == __kmax - 1) {\t\t\t\t\t\\\n\t\t\t\t\t__kmax <<= 1;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t__kstack = (__kbstack_t*)realloc(__kstack, __kmax * sizeof(__kbstack_t)); \\\n\t\t\t\t\t__kp = __kstack + (__kmax>>1) - 1;\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(__kp+1)->i = 0; (__kp+1)->x = __kp->x->is_internal? __KB_PTR(b, __kp->x)[__kp->i] : 0; \\\n\t\t\t\t++__kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t--__kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (__kp >= __kstack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__kp->x && __kp->i < __kp->x->n) __func(&__KB_KEY(key_t, __kp->x)[__kp->i]); \\\n\t\t\t\t++__kp->i;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else break;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(__kstack);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define KBTREE_INIT(name, key_t, __cmp)\t\t\t\\\n\t__KB_TREE_T(name)\t\t\t\t\t\t\t\\\n\t__KB_INIT(name, key_t)\t\t\t\t\t\t\\\n\t__KB_GET_AUX1(name, key_t, __cmp)\t\t\t\\\n\t__KB_GET(name, key_t)\t\t\t\t\t\t\\\n\t__KB_INTERVAL(name, key_t)\t\t\t\t\t\\\n\t__KB_PUT(name, key_t, __cmp)\t\t\t\t\\\n\t__KB_DEL(name, key_t)\n\n#define KB_DEFAULT_SIZE 512\n\n#define kbtree_t(name) kbtree_##name##_t\n#define kb_init(name, s) kb_init_##name(s)\n#define kb_destroy(name, b) __kb_destroy(b)\n#define kb_get(name, b, k) kb_get_##name(b, k)\n#define kb_put(name, b, k) kb_put_##name(b, k)\n#define kb_del(name, b, k) kb_del_##name(b, k)\n#define kb_interval(name, b, k, l, u) kb_interval_##name(b, k, l, u)\n#define kb_getp(name, b, k) kb_getp_##name(b, k)\n#define kb_putp(name, b, k) kb_putp_##name(b, k)\n#define kb_delp(name, b, k) kb_delp_##name(b, k)\n#define kb_intervalp(name, b, k, l, u) kb_intervalp_##name(b, k, l, u)\n\n#define kb_size(b) ((b)->n_keys)\n\n#define kb_generic_cmp(a, b) (((b) < (a)) - ((a) < (b)))\n#define kb_str_cmp(a, b) strcmp(a, b)\n\n#endif\n"
        },
        {
          "name": "khash.h",
          "type": "blob",
          "size": 20.3984375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"khash.h\"\nKHASH_MAP_INIT_INT(32, char)\nint main() {\n\tint ret, is_missing;\n\tkhiter_t k;\n\tkhash_t(32) *h = kh_init(32);\n\tk = kh_put(32, h, 5, &ret);\n\tkh_value(h, k) = 10;\n\tk = kh_get(32, h, 10);\n\tis_missing = (k == kh_end(h));\n\tk = kh_get(32, h, 5);\n\tkh_del(32, h, k);\n\tfor (k = kh_begin(h); k != kh_end(h); ++k)\n\t\tif (kh_exist(h, k)) kh_value(h, k) = 1;\n\tkh_destroy(32, h);\n\treturn 0;\n}\n*/\n\n/*\n  2011-12-29 (0.2.7):\n\n    * Minor code clean up; no actual effect.\n\n  2011-09-16 (0.2.6):\n\n\t* The capacity is a power of 2. This seems to dramatically improve the\n\t  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:\n\n\t   - http://code.google.com/p/ulib/\n\t   - http://nothings.org/computer/judy/\n\n\t* Allow to optionally use linear probing which usually has better\n\t  performance for random input. Double hashing is still the default as it\n\t  is more robust to certain non-random input.\n\n\t* Added Wang's integer hash function (not used by default). This hash\n\t  function is more robust to certain non-random input.\n\n  2011-02-14 (0.2.5):\n\n    * Allow to declare global functions.\n\n  2009-09-26 (0.2.4):\n\n    * Improve portability\n\n  2008-09-19 (0.2.3):\n\n\t* Corrected the example\n\t* Improved interfaces\n\n  2008-09-11 (0.2.2):\n\n\t* Improved speed a little in kh_put()\n\n  2008-09-10 (0.2.1):\n\n\t* Added kh_clear()\n\t* Fixed a compiling error\n\n  2008-09-02 (0.2.0):\n\n\t* Changed to token concatenation which increases flexibility.\n\n  2008-08-31 (0.1.2):\n\n\t* Fixed a bug in kh_get(), which has not been tested previously.\n\n  2008-08-31 (0.1.1):\n\n\t* Added destructor\n*/\n\n\n#ifndef __AC_KHASH_H\n#define __AC_KHASH_H\n\n/*!\n  @header\n\n  Generic hash table library.\n */\n\n#define AC_VERSION_KHASH_H \"0.2.6\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n/* compipler specific configuration */\n\n#if UINT_MAX == 0xffffffffu\ntypedef unsigned int khint32_t;\n#elif ULONG_MAX == 0xffffffffu\ntypedef unsigned long khint32_t;\n#endif\n\n#if ULONG_MAX == ULLONG_MAX\ntypedef unsigned long khint64_t;\n#else\ntypedef unsigned long long khint64_t;\n#endif\n\n#ifdef _MSC_VER\n#define kh_inline __inline\n#else\n#define kh_inline inline\n#endif\n\ntypedef khint32_t khint_t;\ntypedef khint_t khiter_t;\n\n#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)\n#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)\n#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)\n#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))\n#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))\n#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))\n#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))\n\n#ifdef KHASH_LINEAR\n#define __ac_inc(k, m) 1\n#else\n#define __ac_inc(k, m) (((k)>>3 ^ (k)<<3) | 1) & (m)\n#endif\n\n#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#ifndef kcalloc\n#define kcalloc(N,Z) calloc(N,Z)\n#endif\n#ifndef kmalloc\n#define kmalloc(Z) malloc(Z)\n#endif\n#ifndef krealloc\n#define krealloc(P,Z) realloc(P,Z)\n#endif\n#ifndef kfree\n#define kfree(P) free(P)\n#endif\n\nstatic const double __ac_HASH_UPPER = 0.77;\n\n#define __KHASH_TYPE(name, khkey_t, khval_t) \\\n\ttypedef struct { \\\n\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\\n\t\tkhint32_t *flags; \\\n\t\tkhkey_t *keys; \\\n\t\tkhval_t *vals; \\\n\t} kh_##name##_t;\n\n#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)\t \t\t\t\t\t\\\n\textern kh_##name##_t *kh_init_##name(void);\t\t\t\t\t\t\t\\\n\textern void kh_destroy_##name(kh_##name##_t *h);\t\t\t\t\t\\\n\textern void kh_clear_##name(kh_##name##_t *h);\t\t\t\t\t\t\\\n\textern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); \t\\\n\textern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \\\n\textern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \\\n\textern void kh_del_##name(kh_##name##_t *h, khint_t x);\n\n#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tSCOPE kh_##name##_t *kh_init_##name(void) {\t\t\t\t\t\t\t\\\n\t\treturn (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_destroy_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree((void *)h->keys); kfree(h->flags);\t\t\t\t\t\\\n\t\t\tkfree((void *)h->vals);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_clear_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h && h->flags) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \\\n\t\t\th->size = h->n_occupied = 0;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_buckets) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t inc, k, i, last, mask;\t\t\t\t\t\t\t\t\\\n\t\t\tmask = h->n_buckets - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\tk = __hash_func(key); i = k & mask;\t\t\t\t\t\t\t\\\n\t\t\tinc = __ac_inc(k, mask); last = i; /* inc==1 for linear probing */ \\\n\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\ti = (i + inc) & mask; \t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (i == last) return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn __ac_iseither(h->flags, i)? h->n_buckets : i;\t\t\\\n\t\t} else return 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \\\n\t{ /* This function uses 0.25*n_bucktes bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \\\n\t\tkhint32_t *new_flags = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t j = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkroundup32(new_n_buckets); \t\t\t\t\t\t\t\t\t\\\n\t\t\tif (new_n_buckets < 4) new_n_buckets = 4;\t\t\t\t\t\\\n\t\t\tif (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;\t/* requested size is too small */ \\\n\t\t\telse { /* hash table size to be changed (shrink or expand); rehash */ \\\n\t\t\t\tnew_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));\t\\\n\t\t\t\tif (!new_flags) return -1;\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \\\n\t\t\t\tif (h->n_buckets < new_n_buckets) {\t/* expand */\t\t\\\n\t\t\t\t\tkhkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\t\tif (!new_keys) return -1;\t\t\t\t\t\t\t\\\n\t\t\t\t\th->keys = new_keys;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tkhval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t\t\t\tif (!new_vals) return -1;\t\t\t\t\t\t\\\n\t\t\t\t\t\th->vals = new_vals;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} /* otherwise shrink */\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (j) { /* rehashing is needed */\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = 0; j != h->n_buckets; ++j) {\t\t\t\t\t\t\\\n\t\t\t\tif (__ac_iseither(h->flags, j) == 0) {\t\t\t\t\t\\\n\t\t\t\t\tkhkey_t key = h->keys[j];\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhval_t val;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhint_t new_mask;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tnew_mask = new_n_buckets - 1; \t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) val = h->vals[j];\t\t\t\t\t\\\n\t\t\t\t\t__ac_set_isdel_true(h->flags, j);\t\t\t\t\t\\\n\t\t\t\t\twhile (1) { /* kick-out process; sort of like in Cuckoo hashing */ \\\n\t\t\t\t\t\tkhint_t inc, k, i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tk = __hash_func(key);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\ti = k & new_mask;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tinc = __ac_inc(k, new_mask);\t\t\t\t\t\\\n\t\t\t\t\t\twhile (!__ac_isempty(new_flags, i)) i = (i + inc) & new_mask; \\\n\t\t\t\t\t\t__ac_set_isempty_false(new_flags, i);\t\t\t\\\n\t\t\t\t\t\tif (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \\\n\t\t\t\t\t\t\t{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \\\n\t\t\t\t\t\t\tif (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \\\n\t\t\t\t\t\t\t__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \\\n\t\t\t\t\t\t} else { /* write the element and jump out of the loop */ \\\n\t\t\t\t\t\t\th->keys[i] = key;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tif (kh_is_map) h->vals[i] = val;\t\t\t\\\n\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\\n\t\t\t\th->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\tif (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h->flags); /* free the working space */\t\t\t\t\\\n\t\t\th->flags = new_flags;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\th->n_buckets = new_n_buckets;\t\t\t\t\t\t\t\t\\\n\t\t\th->n_occupied = h->size;\t\t\t\t\t\t\t\t\t\\\n\t\t\th->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_occupied >= h->upper_bound) { /* update the hash table */ \\\n\t\t\tif (h->n_buckets > (h->size<<1)) {\t\t\t\t\t\t\t\\\n\t\t\t\tif (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear \"deleted\" elements */ \\\n\t\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \\\n\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t inc, k, i, site, last, mask = h->n_buckets - 1;\t\t\\\n\t\t\tx = site = h->n_buckets; k = __hash_func(key); i = k & mask; \\\n\t\t\tif (__ac_isempty(h->flags, i)) x = i; /* for speed up */\t\\\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tinc = __ac_inc(k, mask); last = i;\t\t\t\t\t\t\\\n\t\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\t\tif (__ac_isdel(h->flags, i)) site = i;\t\t\t\t\\\n\t\t\t\t\ti = (i + inc) & mask; \t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (i == last) { x = site; break; }\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x == h->n_buckets) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \\\n\t\t\t\t\telse x = i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (__ac_isempty(h->flags, x)) { /* not present at all */\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size; ++h->n_occupied;\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else if (__ac_isdel(h->flags, x)) { /* deleted */\t\t\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 2;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \\\n\t\treturn x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x != h->n_buckets && !__ac_iseither(h->flags, x)) {\t\t\t\\\n\t\t\t__ac_set_isdel_true(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t--h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)\n\n#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n/* --- BEGIN OF HASH FUNCTIONS --- */\n\n/*! @function\n  @abstract     Integer hash function\n  @param  key   The integer [khint32_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int_hash_func(key) (khint32_t)(key)\n/*! @function\n  @abstract     Integer comparison function\n */\n#define kh_int_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     64-bit integer hash function\n  @param  key   The integer [khint64_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)\n/*! @function\n  @abstract     64-bit integer comparison function\n */\n#define kh_int64_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     const char* hash function\n  @param  s     Pointer to a null terminated string\n  @return       The hash value\n */\nstatic kh_inline khint_t __ac_X31_hash_string(const char *s)\n{\n\tkhint_t h = (khint_t)*s;\n\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;\n\treturn h;\n}\n/*! @function\n  @abstract     Another interface to const char* hash function\n  @param  key   Pointer to a null terminated string [const char*]\n  @return       The hash value [khint_t]\n */\n#define kh_str_hash_func(key) __ac_X31_hash_string(key)\n/*! @function\n  @abstract     Const char* comparison function\n */\n#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)\n\nstatic kh_inline khint_t __ac_Wang_hash(khint_t key)\n{\n    key += ~(key << 15);\n    key ^=  (key >> 10);\n    key +=  (key << 3);\n    key ^=  (key >> 6);\n    key += ~(key << 11);\n    key ^=  (key >> 16);\n    return key;\n}\n#define kh_int_hash_func2(k) __ac_Wang_hash((khint_t)key)\n\n/* --- END OF HASH FUNCTIONS --- */\n\n/* Other convenient macros... */\n\n/*!\n  @abstract Type of the hash table.\n  @param  name  Name of the hash table [symbol]\n */\n#define khash_t(name) kh_##name##_t\n\n/*! @function\n  @abstract     Initiate a hash table.\n  @param  name  Name of the hash table [symbol]\n  @return       Pointer to the hash table [khash_t(name)*]\n */\n#define kh_init(name) kh_init_##name()\n\n/*! @function\n  @abstract     Destroy a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_destroy(name, h) kh_destroy_##name(h)\n\n/*! @function\n  @abstract     Reset a hash table without deallocating memory.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_clear(name, h) kh_clear_##name(h)\n\n/*! @function\n  @abstract     Resize a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  s     New size [khint_t]\n */\n#define kh_resize(name, h, s) kh_resize_##name(h, s)\n\n/*! @function\n  @abstract     Insert a key to the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @param  r     Extra return code: 0 if the key is present in the hash table;\n                1 if the bucket is empty (never used); 2 if the element in\n\t\t\t\tthe bucket has been deleted [int*]\n  @return       Iterator to the inserted element [khint_t]\n */\n#define kh_put(name, h, k, r) kh_put_##name(h, k, r)\n\n/*! @function\n  @abstract     Retrieve a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @return       Iterator to the found element, or kh_end(h) is the element is absent [khint_t]\n */\n#define kh_get(name, h, k) kh_get_##name(h, k)\n\n/*! @function\n  @abstract     Remove a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Iterator to the element to be deleted [khint_t]\n */\n#define kh_del(name, h, k) kh_del_##name(h, k)\n\n/*! @function\n  @abstract     Test whether a bucket contains data.\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       1 if containing data; 0 otherwise [int]\n */\n#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))\n\n/*! @function\n  @abstract     Get key given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Key [type of keys]\n */\n#define kh_key(h, x) ((h)->keys[x])\n\n/*! @function\n  @abstract     Get value given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Value [type of values]\n  @discussion   For hash sets, calling this results in segfault.\n */\n#define kh_val(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Alias of kh_val()\n */\n#define kh_value(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Get the start iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The start iterator [khint_t]\n */\n#define kh_begin(h) (khint_t)(0)\n\n/*! @function\n  @abstract     Get the end iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The end iterator [khint_t]\n */\n#define kh_end(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Get the number of elements in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of elements in the hash table [khint_t]\n */\n#define kh_size(h) ((h)->size)\n\n/*! @function\n  @abstract     Get the number of buckets in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of buckets in the hash table [khint_t]\n */\n#define kh_n_buckets(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Iterate over the entries in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  kvar  Variable to which key will be assigned\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/*! @function\n  @abstract     Iterate over the values in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/* More conenient interfaces */\n\n/*! @function\n  @abstract     Instantiate a hash set containing integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)\n\ntypedef const char *kh_cstr_t;\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_STR(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)\n\n#endif /* __AC_KHASH_H */\n"
        },
        {
          "name": "kopen.c",
          "type": "blob",
          "size": 9.486328125,
          "content": "#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#ifndef _WIN32\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#endif\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#ifdef _WIN32\n#define _KO_NO_NET\n#endif\n\n#ifndef _KO_NO_NET\nstatic int socket_wait(int fd, int is_read)\n{\n\tfd_set fds, *fdr = 0, *fdw = 0;\n\tstruct timeval tv;\n\tint ret;\n\ttv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\tif (is_read) fdr = &fds;\n\telse fdw = &fds;\n\tret = select(fd+1, fdr, fdw, 0, &tv);\n\tif (ret == -1) perror(\"select\");\n\treturn ret;\n}\n\nstatic int socket_connect(const char *host, const char *port)\n{\n#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)\n\n\tint on = 1, fd;\n\tstruct linger lng = { 0, 0 };\n\tstruct addrinfo hints, *res = 0;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(host, port, &hints, &res) != 0) __err_connect(\"getaddrinfo\");\n\tif ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect(\"socket\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect(\"setsockopt\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect(\"setsockopt\");\n\tif (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect(\"connect\");\n\tfreeaddrinfo(res);\n\treturn fd;\n#undef __err_connect\n}\n\nstatic int write_bytes(int fd, const char *buf, size_t len)\n{\n\tssize_t bytes;\n\tdo {\n\t\tbytes = write(fd, buf, len);\n\t\tif (bytes >= 0) {\n\t\t\tlen -= bytes;\n\t\t} else if (errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR) {\n\t\t\treturn -1;\n\t\t}\n\t} while (len > 0);\n\n\treturn 0;\n}\n\nstatic int http_open(const char *fn)\n{\n\tchar *p, *proxy, *q, *http_host, *host, *port, *path, *buf;\n\tint fd, ret, l;\n\tssize_t bytes = 0, bufsz = 0x10000;\n\n\t/* parse URL; adapted from khttp_parse_url() in knetfile.c */\n\tif (strstr(fn, \"http://\") != fn) return 0;\n\t// set ->http_host\n\tfor (p = (char*)fn + 7; *p && *p != '/'; ++p);\n\tl = p - fn - 7;\n\thttp_host = calloc(l + 1, 1);\n\tstrncpy(http_host, fn + 7, l);\n\thttp_host[l] = 0;\n\tfor (q = http_host; *q && *q != ':'; ++q);\n\tif (*q == ':') *q++ = 0;\n\t// get http_proxy\n\tproxy = getenv(\"http_proxy\");\n\t// set host, port and path\n\tif (proxy == 0) {\n\t\thost = strdup(http_host); // when there is no proxy, server name is identical to http_host name.\n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(*p? p : \"/\");\n\t} else {\n\t\thost = (strstr(proxy, \"http://\") == proxy)? strdup(proxy + 7) : strdup(proxy);\n\t\tfor (q = host; *q && *q != ':'; ++q);\n\t\tif (*q == ':') *q++ = 0; \n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(fn);\n\t}\n\n\t/* connect; adapted from khttp_connect() in knetfile.c */\n\tl = 0;\n\tfd = socket_connect(host, port);\n\tbuf = calloc(bufsz, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.\n\tl += snprintf(buf + l, bufsz, \"GET %s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n\t\t\t\t path, http_host);\n\tif (write_bytes(fd, buf, l) != 0) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t\tgoto out;\n\t}\n\tl = 0;\n retry:\n\twhile (l < bufsz && (bytes = read(fd, buf + l, 1)) > 0) { // read HTTP header; FIXME: bad efficiency\n\t\tif (buf[l] == '\\n' && l >= 3)\n\t\t\tif (strncmp(buf + l - 3, \"\\r\\n\\r\\n\", 4) == 0) break;\n\t\t++l;\n\t}\n\tif (bytes < 0 && (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)) goto retry;\n\n\tbuf[l] = 0;\n\tif (bytes < 0 || l < 14) { // prematured header\n\t\tclose(fd);\n\t\tfd = -1;\n\t\tgoto out;\n\t}\n\tret = strtol(buf + 8, &p, 0); // HTTP return code\n\tif (ret != 200) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n out:\n\tfree(buf); free(http_host); free(host); free(port); free(path);\n\treturn fd;\n}\n\ntypedef struct {\n\tint max_response, ctrl_fd;\n\tchar *response;\n} ftpaux_t;\n\nstatic int kftp_get_response(ftpaux_t *aux)\n{\n\tunsigned char c;\n\tint n = 0;\n\tchar *p;\n\tif (socket_wait(aux->ctrl_fd, 1) <= 0) return 0;\n\twhile (read(aux->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O\n\t\tif (n >= aux->max_response) {\n\t\t\taux->max_response = aux->max_response? aux->max_response<<1 : 256;\n\t\t\taux->response = realloc(aux->response, aux->max_response);\n\t\t}\n\t\taux->response[n++] = c;\n\t\tif (c == '\\n') {\n\t\t\tif (n >= 4 && isdigit(aux->response[0]) && isdigit(aux->response[1]) && isdigit(aux->response[2])\n\t\t\t\t&& aux->response[3] != '-') break;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (n < 2) return -1;\n\taux->response[n-2] = 0;\n\treturn strtol(aux->response, &p, 0);\n}\n\nstatic int kftp_send_cmd(ftpaux_t *aux, const char *cmd, int is_get)\n{\n\tif (socket_wait(aux->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing\n\tif (write_bytes(aux->ctrl_fd, cmd, strlen(cmd)) != 0) return -1;\n\treturn is_get? kftp_get_response(aux) : 0;\n}\n\nstatic int ftp_open(const char *fn)\n{\n\tchar *p, *host = 0, *port = 0, *retr = 0;\n\tchar host2[80], port2[10];\n\tint v[6], l, fd = -1, ret, pasv_port, pasv_ip[4];\n\tftpaux_t aux;\n\t\n\t/* parse URL */\n\tif (strstr(fn, \"ftp://\") != fn) return 0;\n\tfor (p = (char*)fn + 6; *p && *p != '/'; ++p);\n\tif (*p != '/') return 0;\n\tl = p - fn - 6;\n\tport = strdup(\"21\");\n\thost = calloc(l + 1, 1);\n\tstrncpy(host, fn + 6, l);\n\tretr = calloc(strlen(p) + 8, 1);\n\tsprintf(retr, \"RETR %s\\r\\n\", p);\n\t\n\t/* connect to ctrl */\n\tmemset(&aux, 0, sizeof(ftpaux_t));\n\taux.ctrl_fd = socket_connect(host, port);\n\tif (aux.ctrl_fd == -1) goto ftp_open_end; /* fail to connect ctrl */\n\n\t/* connect to the data stream */\n\tkftp_get_response(&aux);\n\tkftp_send_cmd(&aux, \"USER anonymous\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASS kopen@\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"TYPE I\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASV\\r\\n\", 1);\n\tfor (p = aux.response; *p && *p != '('; ++p);\n\tif (*p != '(') goto ftp_open_end;\n\t++p;\n\tsscanf(p, \"%d,%d,%d,%d,%d,%d\", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);\n\tmemcpy(pasv_ip, v, 4 * sizeof(int));\n\tpasv_port = (v[4]<<8&0xff00) + v[5];\n\tkftp_send_cmd(&aux, retr, 0);\n\tsprintf(host2, \"%d.%d.%d.%d\", pasv_ip[0], pasv_ip[1], pasv_ip[2], pasv_ip[3]);\n\tsprintf(port2, \"%d\", pasv_port);\n\tfd = socket_connect(host2, port2);\n\tif (fd == -1) goto ftp_open_end;\n\tret = kftp_get_response(&aux);\n\tif (ret != 150) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tclose(aux.ctrl_fd);\n\nftp_open_end:\n\tfree(host); free(port); free(retr); free(aux.response);\n\treturn fd;\n}\n#endif /* !defined(_KO_NO_NET) */\n\nstatic char **cmd2argv(const char *cmd)\n{\n\tint i, beg, end, argc;\n\tchar **argv, *str;\n\tend = strlen(cmd);\n\tfor (i = end - 1; i >= 0; --i)\n\t\tif (!isspace(cmd[i])) break;\n\tend = i + 1;\n\tfor (beg = 0; beg < end; ++beg)\n\t\tif (!isspace(cmd[beg])) break;\n\tif (beg == end) return 0;\n\tfor (i = beg + 1, argc = 0; i < end; ++i)\n\t\tif (isspace(cmd[i]) && !isspace(cmd[i-1]))\n\t\t\t++argc;\n\targv = (char**)calloc(argc + 2, sizeof(void*));\n\targv[0] = str = (char*)calloc(end - beg + 1, 1);\n\tstrncpy(argv[0], cmd + beg, end - beg);\n\tfor (i = argc = 1; i < end - beg; ++i)\n\t\tif (isspace(str[i])) str[i] = 0;\n\t\telse if (str[i] && str[i-1] == 0) argv[argc++] = &str[i];\n\treturn argv;\n}\n\n#define KO_STDIN    1\n#define KO_FILE     2\n#define KO_PIPE     3\n#define KO_HTTP     4\n#define KO_FTP      5\n\ntypedef struct {\n\tint type, fd;\n\tpid_t pid;\n} koaux_t;\n\nvoid *kopen(const char *fn, int *_fd)\n{\n\tkoaux_t *aux = 0;\n\t*_fd = -1;\n\tif (strstr(fn, \"http://\") == fn) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_HTTP;\n\t\taux->fd = http_open(fn);\n\t} else if (strstr(fn, \"ftp://\") == fn) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_FTP;\n\t\taux->fd = ftp_open(fn);\n\t} else if (strcmp(fn, \"-\") == 0) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_STDIN;\n\t\taux->fd = STDIN_FILENO;\n\t} else {\n\t\tconst char *p, *q;\n\t\tfor (p = fn; *p; ++p)\n\t\t\tif (!isspace(*p)) break;\n\t\tif (*p == '<') { // pipe open\n\t\t\tint need_shell, pfd[2];\n\t\t\tpid_t pid;\n\t\t\t// a simple check to see if we need to invoke a shell; not always working\n\t\t\tfor (q = p + 1; *q; ++q)\n\t\t\t\tif (ispunct(*q) && *q != '.' && *q != '_' && *q != '-' && *q != ':')\n\t\t\t\t\tbreak;\n\t\t\tneed_shell = (*q != 0);\n\t\t\tif (pipe(pfd) != 0) return 0;\n\t\t\tpid = vfork();\n\t\t\tif (pid == -1) { /* vfork() error */\n\t\t\t\tclose(pfd[0]); close(pfd[1]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0) { /* the child process */\n\t\t\t\tchar **argv; /* FIXME: I do not know if this will lead to a memory leak */\n\t\t\t\tclose(pfd[0]);\n\t\t\t\tdup2(pfd[1], STDOUT_FILENO);\n\t\t\t\tclose(pfd[1]);\n\t\t\t\tif (!need_shell) {\n\t\t\t\t\targv = cmd2argv(p + 1);\n\t\t\t\t\texecvp(argv[0], argv);\n\t\t\t\t\tfree(argv[0]); free(argv);\n\t\t\t\t} else execl(\"/bin/sh\", \"sh\", \"-c\", p + 1, NULL);\n\t\t\t\texit(1);\n\t\t\t} else { /* parent process */\n\t\t\t\tclose(pfd[1]);\n\t\t\t\taux = calloc(1, sizeof(koaux_t));\n\t\t\t\taux->type = KO_PIPE;\n\t\t\t\taux->fd = pfd[0];\n\t\t\t\taux->pid = pid;\n\t\t\t}\n\t\t} else {\n#ifdef _WIN32\n\t\t\t*_fd = open(fn, O_RDONLY | O_BINARY);\n#else\n\t\t\t*_fd = open(fn, O_RDONLY);\n#endif\n\t\t\tif (*_fd >= 0) {\n\t\t\t\taux = calloc(1, sizeof(koaux_t));\n\t\t\t\taux->type = KO_FILE;\n\t\t\t\taux->fd = *_fd;\n\t\t\t}\n\t\t}\n\t}\n\tif (aux) *_fd = aux->fd;\n\treturn aux;\n}\n\nint kclose(void *a)\n{\n\tkoaux_t *aux = (koaux_t*)a;\n\tif (aux->type == KO_PIPE) {\n\t\tint status;\n\t\tpid_t pid;\n\t\tpid = waitpid(aux->pid, &status, WNOHANG);\n\t\tif (pid != aux->pid) kill(aux->pid, 15);\n\t}\n\tfree(aux);\n\treturn 0;\n}\n\n#ifdef _KO_MAIN\n#define BUF_SIZE 0x10000\nint main(int argc, char *argv[])\n{\n\tvoid *x;\n\tint l, fd;\n\tunsigned char buf[BUF_SIZE];\n\tFILE *fp;\n\tif (argc == 1) {\n\t\tfprintf(stderr, \"Usage: kopen <file>\\n\");\n\t\treturn 1;\n\t}\n\tx = kopen(argv[1], &fd);\n\tfp = fdopen(fd, \"r\");\n\tif (fp == 0) {\n\t\tfprintf(stderr, \"ERROR: fail to open the input\\n\");\n\t\treturn 1;\n\t}\n\tdo {\n\t\tif ((l = fread(buf, 1, BUF_SIZE, fp)) != 0)\n\t\t\tfwrite(buf, 1, l, stdout);\n\t} while (l == BUF_SIZE);\n\tfclose(fp);\n\tkclose(x);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kseq.h",
          "type": "blob",
          "size": 8.6494140625,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Last Modified: 05MAR2012 */\n\n#ifndef AC_KSEQ_H\n#define AC_KSEQ_H\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define KS_SEP_SPACE 0 // isspace(): \\t, \\n, \\v, \\f, \\r\n#define KS_SEP_TAB   1 // isspace() && !' '\n#define KS_SEP_LINE  2 // line separator: \"\\n\" (Unix) or \"\\r\\n\" (Windows)\n#define KS_SEP_MAX   2\n\n#define __KS_TYPE(type_t)\t\t\t\t\t\t\\\n\ttypedef struct __kstream_t {\t\t\t\t\\\n\t\tunsigned char *buf;\t\t\t\t\t\t\\\n\t\tint begin, end, is_eof;\t\t\t\t\t\\\n\t\ttype_t f;\t\t\t\t\t\t\t\t\\\n\t} kstream_t;\n\n#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)\n#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)\n\n#define __KS_BASIC(type_t, __bufsize)\t\t\t\t\t\t\t\t\\\n\tstatic inline kstream_t *ks_init(type_t f)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkstream_t *ks = (kstream_t*)calloc(1, sizeof(kstream_t));\t\\\n\t\tks->f = f;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tks->buf = (unsigned char*)malloc(__bufsize);\t\t\t\t\\\n\t\treturn ks;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void ks_destroy(kstream_t *ks)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (ks) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(ks->buf);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(ks);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KS_GETC(__read, __bufsize)\t\t\t\t\t\t\\\n\tstatic inline int ks_getc(kstream_t *ks)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (ks->is_eof && ks->begin >= ks->end) return -1;\t\\\n\t\tif (ks->begin >= ks->end) {\t\t\t\t\t\t\t\\\n\t\t\tks->begin = 0;\t\t\t\t\t\t\t\t\t\\\n\t\t\tks->end = __read(ks->f, ks->buf, __bufsize);\t\\\n\t\t\tif (ks->end == 0) { ks->is_eof = 1; return -1;}\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn (int)ks->buf[ks->begin++];\t\t\t\t\t\\\n\t}\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#define __KS_GETUNTIL(__read, __bufsize)\t\t\t\t\t\t\t\t\\\n\tstatic int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint gotany = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (dret) *dret = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tstr->l = append? str->l : 0;\t\t\t\t\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tint i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (ks->begin >= ks->end) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (!ks->is_eof) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks->begin = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks->end = __read(ks->f, ks->buf, __bufsize);\t\t\\\n\t\t\t\t\tif (ks->end == 0) { ks->is_eof = 1; break; }\t\t\\\n\t\t\t\t} else break;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (delimiter == KS_SEP_LINE) { \\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i) \\\n\t\t\t\t\tif (ks->buf[i] == '\\n') break; \\\n\t\t\t} else if (delimiter > KS_SEP_MAX) {\t\t\t\t\t\t\\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i)\t\t\t\t\t\\\n\t\t\t\t\tif (ks->buf[i] == delimiter) break;\t\t\t\t\t\\\n\t\t\t} else if (delimiter == KS_SEP_SPACE) {\t\t\t\t\t\t\\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i)\t\t\t\t\t\\\n\t\t\t\t\tif (isspace(ks->buf[i])) break;\t\t\t\t\t\t\\\n\t\t\t} else if (delimiter == KS_SEP_TAB) {\t\t\t\t\t\t\\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i)\t\t\t\t\t\\\n\t\t\t\t\tif (isspace(ks->buf[i]) && ks->buf[i] != ' ') break; \\\n\t\t\t} else i = 0; /* never come to here! */\t\t\t\t\t\t\\\n\t\t\tif (str->m - str->l < (size_t)(i - ks->begin + 1)) {\t\t\\\n\t\t\t\tstr->m = str->l + (i - ks->begin) + 1;\t\t\t\t\t\\\n\t\t\t\tkroundup32(str->m);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tstr->s = (char*)realloc(str->s, str->m);\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tgotany = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemcpy(str->s + str->l, ks->buf + ks->begin, i - ks->begin); \\\n\t\t\tstr->l = str->l + (i - ks->begin);\t\t\t\t\t\t\t\\\n\t\t\tks->begin = i + 1;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (i < ks->end) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (dret) *dret = ks->buf[i];\t\t\t\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (!gotany && ks_eof(ks)) return -1;\t\t\t\t\t\t\t\\\n\t\tif (str->s == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tstr->m = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tstr->s = (char*)calloc(1, 1);\t\t\t\t\t\t\t\t\\\n\t\t} else if (delimiter == KS_SEP_LINE && str->l > 1 && str->s[str->l-1] == '\\r') --str->l; \\\n\t\tstr->s[str->l] = '\\0';\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn str->l;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} \\\n\tstatic inline int ks_getuntil(kstream_t *ks, int delimiter, kstring_t *str, int *dret) \\\n\t{ return ks_getuntil2(ks, delimiter, str, dret, 0); }\n\n#define KSTREAM_INIT(type_t, __read, __bufsize) \\\n\t__KS_TYPE(type_t)\t\t\t\t\t\t\t\\\n\t__KS_BASIC(type_t, __bufsize)\t\t\t\t\\\n\t__KS_GETC(__read, __bufsize)\t\t\t\t\\\n\t__KS_GETUNTIL(__read, __bufsize)\n\n#define kseq_rewind(ks) ((ks)->last_char = (ks)->f->is_eof = (ks)->f->begin = (ks)->f->end = 0)\n\n#define __KSEQ_BASIC(SCOPE, type_t)\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kseq_t *kseq_init(type_t fd)\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkseq_t *s = (kseq_t*)calloc(1, sizeof(kseq_t));\t\t\t\t\t\\\n\t\ts->f = ks_init(fd);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kseq_destroy(kseq_t *ks)\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (!ks) return;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(ks->name.s); free(ks->comment.s); free(ks->seq.s);\tfree(ks->qual.s); \\\n\t\tks_destroy(ks->f);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(ks);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n/* Return value:\n   >=0  length of the sequence (normal)\n   -1   end-of-file\n   -2   truncated quality string\n */\n#define __KSEQ_READ(SCOPE) \\\n\tSCOPE int kseq_read(kseq_t *seq) \\\n\t{ \\\n\t\tint c; \\\n\t\tkstream_t *ks = seq->f; \\\n\t\tif (seq->last_char == 0) { /* then jump to the next header line */ \\\n\t\t\twhile ((c = ks_getc(ks)) != -1 && c != '>' && c != '@'); \\\n\t\t\tif (c == -1) return -1; /* end of file */ \\\n\t\t\tseq->last_char = c; \\\n\t\t} /* else: the first header char has been read in the previous call */ \\\n\t\tseq->comment.l = seq->seq.l = seq->qual.l = 0; /* reset all members */ \\\n\t\tif (ks_getuntil(ks, 0, &seq->name, &c) < 0) return -1; /* normal exit: EOF */ \\\n\t\tif (c != '\\n') ks_getuntil(ks, KS_SEP_LINE, &seq->comment, 0); /* read FASTA/Q comment */ \\\n\t\tif (seq->seq.s == 0) { /* we can do this in the loop below, but that is slower */ \\\n\t\t\tseq->seq.m = 256; \\\n\t\t\tseq->seq.s = (char*)malloc(seq->seq.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) != -1 && c != '>' && c != '+' && c != '@') { \\\n\t\t\tif (c == '\\n') continue; /* skip empty lines */ \\\n\t\t\tseq->seq.s[seq->seq.l++] = c; /* this is safe: we always have enough space for 1 char */ \\\n\t\t\tks_getuntil2(ks, KS_SEP_LINE, &seq->seq, 0, 1); /* read the rest of the line */ \\\n\t\t} \\\n\t\tif (c == '>' || c == '@') seq->last_char = c; /* the first header char has been read */\t\\\n\t\tif (seq->seq.l + 1 >= seq->seq.m) { /* seq->seq.s[seq->seq.l] below may be out of boundary */ \\\n\t\t\tseq->seq.m = seq->seq.l + 2; \\\n\t\t\tkroundup32(seq->seq.m); /* rounded to the next closest 2^k */ \\\n\t\t\tseq->seq.s = (char*)realloc(seq->seq.s, seq->seq.m); \\\n\t\t} \\\n\t\tseq->seq.s[seq->seq.l] = 0;\t/* null terminated string */ \\\n\t\tif (c != '+') return seq->seq.l; /* FASTA */ \\\n\t\tif (seq->qual.m < seq->seq.m) {\t/* allocate memory for qual in case insufficient */ \\\n\t\t\tseq->qual.m = seq->seq.m; \\\n\t\t\tseq->qual.s = (char*)realloc(seq->qual.s, seq->qual.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) != -1 && c != '\\n'); /* skip the rest of '+' line */ \\\n\t\tif (c == -1) return -2; /* error: no quality string */ \\\n\t\twhile (ks_getuntil2(ks, KS_SEP_LINE, &seq->qual, 0, 1) >= 0 && seq->qual.l < seq->seq.l); \\\n\t\tseq->last_char = 0;\t/* we have not come to the next header line */ \\\n\t\tif (seq->seq.l != seq->qual.l) return -2; /* error: qual string is of a different length */ \\\n\t\treturn seq->seq.l; \\\n\t}\n\n#define __KSEQ_TYPE(type_t)\t\t\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\\\n\t\tkstring_t name, comment, seq, qual;\t\t\\\n\t\tint last_char;\t\t\t\t\t\t\t\\\n\t\tkstream_t *f;\t\t\t\t\t\t\t\\\n\t} kseq_t;\n\n#define KSEQ_INIT2(SCOPE, type_t, __read)\t\t\\\n\tKSTREAM_INIT(type_t, __read, 16384)\t\t\t\\\n\t__KSEQ_TYPE(type_t)\t\t\t\t\t\t\t\\\n\t__KSEQ_BASIC(SCOPE, type_t)\t\t\t\t\t\\\n\t__KSEQ_READ(SCOPE)\n\n#define KSEQ_INIT(type_t, __read) KSEQ_INIT2(static, type_t, __read)\n\n#define KSEQ_DECLARE(type_t) \\\n\t__KS_TYPE(type_t) \\\n\t__KSEQ_TYPE(type_t) \\\n\textern kseq_t *kseq_init(type_t fd); \\\n\tvoid kseq_destroy(kseq_t *ks); \\\n\tint kseq_read(kseq_t *seq);\n\n#endif\n"
        },
        {
          "name": "ksort.h",
          "type": "blob",
          "size": 9.490234375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, by Attractive Chaos <attractivechaos@aol.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  2008-11-16 (0.1.4):\n\n    * Fixed a bug in introsort() that happens in rare cases.\n\n  2008-11-05 (0.1.3):\n\n    * Fixed a bug in introsort() for complex comparisons.\n\n\t* Fixed a bug in mergesort(). The previous version is not stable.\n\n  2008-09-15 (0.1.2):\n\n\t* Accelerated introsort. On my Mac (not on another Linux machine),\n\t  my implementation is as fast as std::sort on random input.\n\n\t* Added combsort and in introsort, switch to combsort if the\n\t  recursion is too deep.\n\n  2008-09-13 (0.1.1):\n\n\t* Added k-small algorithm\n\n  2008-09-05 (0.1.0):\n\n\t* Initial version\n\n*/\n\n#ifndef AC_KSORT_H\n#define AC_KSORT_H\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\ntypedef struct {\n\tvoid *left, *right;\n\tint depth;\n} ks_isort_stack_t;\n\n#define KSORT_SWAP(type_t, a, b) { register type_t t=(a); (a)=(b); (b)=t; }\n\n#define KSORT_INIT(name, type_t, __sort_lt)\t\t\t\t\t\t\t\t\\\n\tvoid ks_mergesort_##name(size_t n, type_t array[], type_t temp[])\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *a2[2], *a, *b;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint curr, shift;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ta2[0] = array;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ta2[1] = temp? temp : (type_t*)malloc(sizeof(type_t) * n);\t\\\n\t\tfor (curr = 0, shift = 0; (1ul<<shift) < n; ++shift) {\t\t\t\\\n\t\t\ta = a2[curr]; b = a2[1-curr];\t\t\t\t\t\t\t\t\\\n\t\t\tif (shift == 0) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\ttype_t *p = b, *i, *eb = a + n;\t\t\t\t\t\t\t\\\n\t\t\t\tfor (i = a; i < eb; i += 2) {\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (i == eb - 1) *p++ = *i;\t\t\t\t\t\t\t\\\n\t\t\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (__sort_lt(*(i+1), *i)) {\t\t\t\t\t\\\n\t\t\t\t\t\t\t*p++ = *(i+1); *p++ = *i;\t\t\t\t\t\\\n\t\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t*p++ = *i; *p++ = *(i+1);\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsize_t i, step = 1ul<<shift;\t\t\t\t\t\t\t\\\n\t\t\t\tfor (i = 0; i < n; i += step<<1) {\t\t\t\t\t\t\\\n\t\t\t\t\ttype_t *p, *j, *k, *ea, *eb;\t\t\t\t\t\t\\\n\t\t\t\t\tif (n < i + step) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tea = a + n; eb = a;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tea = a + i + step;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\teb = a + (n < i + (step<<1)? n : i + (step<<1)); \\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tj = a + i; k = a + i + step; p = b + i;\t\t\t\t\\\n\t\t\t\t\twhile (j < ea && k < eb) {\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (__sort_lt(*k, *j)) *p++ = *k++;\t\t\t\t\\\n\t\t\t\t\t\telse *p++ = *j++;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\twhile (j < ea) *p++ = *j++;\t\t\t\t\t\t\t\\\n\t\t\t\t\twhile (k < eb) *p++ = *k++;\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tcurr = 1 - curr;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (curr == 1) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttype_t *p = a2[0], *i = a2[1], *eb = array + n;\t\t\t\t\\\n\t\t\tfor (; p < eb; ++i) *p++ = *i;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (temp == 0) free(a2[1]);\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapadjust_##name(size_t i, size_t n, type_t l[])\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t k = i;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t tmp = l[i];\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile ((k = (k << 1) + 1) < n) {\t\t\t\t\t\t\t\t\\\n\t\t\tif (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k;\t\t\t\t\\\n\t\t\tif (__sort_lt(l[k], tmp)) break;\t\t\t\t\t\t\t\\\n\t\t\tl[i] = l[k]; i = k;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tl[i] = tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapmake_##name(size_t lsize, type_t l[])\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = (lsize >> 1) - 1; i != (size_t)(-1); --i)\t\t\t\t\\\n\t\t\tks_heapadjust_##name(i, lsize, l);\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapsort_##name(size_t lsize, type_t l[])\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = lsize - 1; i > 0; --i) {\t\t\t\t\t\t\t\t\\\n\t\t\ttype_t tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttmp = *l; *l = l[i]; l[i] = tmp; ks_heapadjust_##name(0, i, l); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void __ks_insertsort_##name(type_t *s, type_t *t)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *i, *j, swap_tmp;\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = s + 1; i < t; ++i)\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = i; j > s && __sort_lt(*j, *(j-1)); --j) {\t\t\t\\\n\t\t\t\tswap_tmp = *j; *j = *(j-1); *(j-1) = swap_tmp;\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_combsort_##name(size_t n, type_t a[])\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tconst double shrink_factor = 1.2473309501039786540366528676643; \\\n\t\tint do_swap;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t gap = n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t tmp, *i, *j;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (gap > 2) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tgap = (size_t)(gap / shrink_factor);\t\t\t\t\t\\\n\t\t\t\tif (gap == 9 || gap == 10) gap = 11;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tdo_swap = 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (i = a; i < a + n - gap; ++i) {\t\t\t\t\t\t\t\\\n\t\t\t\tj = i + gap;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*j, *i)) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\ttmp = *i; *i = *j; *j = tmp;\t\t\t\t\t\t\\\n\t\t\t\t\tdo_swap = 1;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while (do_swap || gap > 2);\t\t\t\t\t\t\t\t\t\\\n\t\tif (gap != 1) __ks_insertsort_##name(a, a + n);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_introsort_##name(size_t n, type_t a[])\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tks_isort_stack_t *top, *stack;\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t rp, swap_tmp;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *s, *t, *i, *j, *k;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (n < 1) return;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\telse if (n == 2) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (__sort_lt(a[1], a[0])) { swap_tmp = a[0]; a[0] = a[1]; a[1] = swap_tmp; } \\\n\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (d = 2; 1ul<<d < n; ++d);\t\t\t\t\t\t\t\t\t\\\n\t\tstack = (ks_isort_stack_t*)malloc(sizeof(ks_isort_stack_t) * ((sizeof(size_t)*d)+2)); \\\n\t\ttop = stack; s = a; t = a + (n-1); d <<= 1;\t\t\t\t\t\t\\\n\t\twhile (1) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (s < t) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (--d == 0) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks_combsort_##name(t - s + 1, s);\t\t\t\t\t\\\n\t\t\t\t\tt = s;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\ti = s; j = t; k = i + ((j-i)>>1) + 1;\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*k, *i)) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__sort_lt(*k, *j)) k = j;\t\t\t\t\t\t\\\n\t\t\t\t} else k = __sort_lt(*j, *i)? i : j;\t\t\t\t\t\\\n\t\t\t\trp = *k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (k != t) { swap_tmp = *k; *k = *t; *t = swap_tmp; }\t\\\n\t\t\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tdo ++i; while (__sort_lt(*i, rp));\t\t\t\t\t\\\n\t\t\t\t\tdo --j; while (i <= j && __sort_lt(rp, *j));\t\t\\\n\t\t\t\t\tif (j <= i) break;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tswap_tmp = *i; *i = *j; *j = swap_tmp;\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tswap_tmp = *i; *i = *t; *t = swap_tmp;\t\t\t\t\t\\\n\t\t\t\tif (i-s > t-i) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (i-s > 16) { top->left = s; top->right = i-1; top->depth = d; ++top; } \\\n\t\t\t\t\ts = t-i > 16? i+1 : t;\t\t\t\t\t\t\t\t\\\n\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (t-i > 16) { top->left = i+1; top->right = t; top->depth = d; ++top; } \\\n\t\t\t\t\tt = i-s > 16? i-1 : s;\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (top == stack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tfree(stack);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t__ks_insertsort_##name(a, a+n);\t\t\t\t\t\t\\\n\t\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} else { --top; s = (type_t*)top->left; t = (type_t*)top->right; d = top->depth; } \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t/* This function is adapted from: http://ndevilla.free.fr/median/ */ \\\n\t/* 0 <= kk < n */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\ttype_t ks_ksmall_##name(size_t n, type_t arr[], size_t kk)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *low, *high, *k, *ll, *hh, *mid;\t\t\t\t\t\t\t\\\n\t\tlow = arr; high = arr + n - 1; k = arr + kk;\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high <= low) return *k;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high == low + 1) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\t\treturn *k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmid = low + (high - low) / 2;\t\t\t\t\t\t\t\t\\\n\t\t\tif (__sort_lt(*high, *mid)) KSORT_SWAP(type_t, *mid, *high); \\\n\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\tif (__sort_lt(*low, *mid)) KSORT_SWAP(type_t, *mid, *low);\t\\\n\t\t\tKSORT_SWAP(type_t, *mid, *(low+1));\t\t\t\t\t\t\t\\\n\t\t\tll = low + 1; hh = high;\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tdo ++ll; while (__sort_lt(*ll, *low));\t\t\t\t\t\\\n\t\t\t\tdo --hh; while (__sort_lt(*low, *hh));\t\t\t\t\t\\\n\t\t\t\tif (hh < ll) break;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tKSORT_SWAP(type_t, *ll, *hh);\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tKSORT_SWAP(type_t, *low, *hh);\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh <= k) low = ll;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh >= k) high = hh - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define ks_mergesort(name, n, a, t) ks_mergesort_##name(n, a, t)\n#define ks_introsort(name, n, a) ks_introsort_##name(n, a)\n#define ks_combsort(name, n, a) ks_combsort_##name(n, a)\n#define ks_heapsort(name, n, a) ks_heapsort_##name(n, a)\n#define ks_heapmake(name, n, a) ks_heapmake_##name(n, a)\n#define ks_heapadjust(name, i, n, a) ks_heapadjust_##name(i, n, a)\n#define ks_ksmall(name, n, a, k) ks_ksmall_##name(n, a, k)\n\n#define ks_lt_generic(a, b) ((a) < (b))\n#define ks_lt_str(a, b) (strcmp((a), (b)) < 0)\n\ntypedef const char *ksstr_t;\n\n#define KSORT_INIT_GENERIC(type_t) KSORT_INIT(type_t, type_t, ks_lt_generic)\n#define KSORT_INIT_STR KSORT_INIT(str, ksstr_t, ks_lt_str)\n\n#endif\n"
        },
        {
          "name": "kstring.c",
          "type": "blob",
          "size": 0.6865234375,
          "content": "#include <stdarg.h>\n#include <stdio.h>\n#include \"kstring.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\nint ksprintf(kstring_t *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint l;\n\tva_start(ap, fmt);\n\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);\n\tva_end(ap);\n\tif (l + 1 > s->m - s->l) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t\tva_start(ap, fmt);\n\t\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);\n\t}\n\tva_end(ap);\n\ts->l += l;\n\treturn l;\n}\n\n#ifdef KSTRING_MAIN\n#include <stdio.h>\nint main()\n{\n\tkstring_t *s;\n\ts = (kstring_t*)calloc(1, sizeof(kstring_t));\n\tksprintf(s, \"abcdefg: %d\", 100);\n\tprintf(\"%s\\n\", s->s);\n\tfree(s);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kstring.h",
          "type": "blob",
          "size": 2.27734375,
          "content": "#ifndef KSTRING_H\n#define KSTRING_H\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\nstatic inline void ks_resize(kstring_t *s, size_t size)\n{\n\tif (s->m < size) {\n\t\ts->m = size;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n}\n\nstatic inline int kputsn(const char *p, int l, kstring_t *s)\n{\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tmemcpy(s->s + s->l, p, l);\n\ts->l += l;\n\ts->s[s->l] = 0;\n\treturn l;\n}\n\nstatic inline int kputs(const char *p, kstring_t *s)\n{\n\treturn kputsn(p, strlen(p), s);\n}\n\nstatic inline int kputc(int c, kstring_t *s)\n{\n\tif (s->l + 1 >= s->m) {\n\t\ts->m = s->l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\ts->s[s->l++] = c;\n\ts->s[s->l] = 0;\n\treturn c;\n}\n\nstatic inline int kputw(int c, kstring_t *s)\n{\n\tchar buf[16];\n\tint l, x;\n\tif (c == 0) return kputc('0', s);\n\tfor (l = 0, x = c < 0? -c : c; x > 0; x /= 10) buf[l++] = x%10 + '0';\n\tif (c < 0) buf[l++] = '-';\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tfor (x = l - 1; x >= 0; --x) s->s[s->l++] = buf[x];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\nstatic inline int kputuw(unsigned c, kstring_t *s)\n{\n\tchar buf[16];\n\tint l, i;\n\tunsigned x;\n\tif (c == 0) return kputc('0', s);\n\tfor (l = 0, x = c; x > 0; x /= 10) buf[l++] = x%10 + '0';\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\nstatic inline int kputl(long c, kstring_t *s)\n{\n\tchar buf[32];\n\tlong l, x;\n\tif (c == 0) return kputc('0', s);\n\tfor (l = 0, x = c < 0? -c : c; x > 0; x /= 10) buf[l++] = x%10 + '0';\n\tif (c < 0) buf[l++] = '-';\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tfor (x = l - 1; x >= 0; --x) s->s[s->l++] = buf[x];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\nint ksprintf(kstring_t *s, const char *fmt, ...);\n\n#endif\n"
        },
        {
          "name": "ksw.c",
          "type": "blob",
          "size": 26.5380859375,
          "content": "/* The MIT License\n\n   Copyright (c) 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#if defined __SSE2__\n#include <emmintrin.h>\n#elif defined __ARM_NEON\n#include \"neon_sse.h\"\n#else\n#include \"scalar_sse.h\"\n#endif\n#include \"ksw.h\"\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#ifdef __GNUC__\n#define LIKELY(x) __builtin_expect((x),1)\n#define UNLIKELY(x) __builtin_expect((x),0)\n#else\n#define LIKELY(x) (x)\n#define UNLIKELY(x) (x)\n#endif\n\nconst kswr_t g_defr = { 0, -1, -1, -1, -1, -1, -1 };\n\nstruct _kswq_t {\n\tint qlen, slen;\n\tuint8_t shift, mdiff, max, size;\n\t__m128i *qp, *H0, *H1, *E, *Hmax;\n};\n\n/**\n * Initialize the query data structure\n *\n * @param size   Number of bytes used to store a score; valid valures are 1 or 2\n * @param qlen   Length of the query sequence\n * @param query  Query sequence\n * @param m      Size of the alphabet\n * @param mat    Scoring matrix in a one-dimension array\n *\n * @return       Query data structure\n */\nkswq_t *ksw_qinit(int size, int qlen, const uint8_t *query, int m, const int8_t *mat)\n{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)malloc(sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}\n\n#if defined __ARM_NEON\n// This macro implicitly uses each function's `zero` local variable\n#define _mm_slli_si128(a, n) (vextq_u8(zero, (a), 16 - (n)))\n#endif\n\nkswr_t ksw_u8(kswq_t *q, int tlen, const uint8_t *target, int _o_del, int _e_del, int _o_ins, int _e_ins, int xtra) // the first gap costs -(_o+_e)\n{\n\tint slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;\n\tuint64_t *b;\n\t__m128i zero, oe_del, e_del, oe_ins, e_ins, shift, *H0, *H1, *E, *Hmax;\n\tkswr_t r;\n\n#if defined __SSE2__\n#define __max_16(ret, xx) do { \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 2)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 1)); \\\n    \t(ret) = _mm_extract_epi16((xx), 0) & 0x00ff; \\\n\t} while (0)\n\n// Given entries with arbitrary values, return whether they are all 0x00\n#define allzero_16(xx) (_mm_movemask_epi8(_mm_cmpeq_epi8((xx), zero)) == 0xffff)\n\n#elif defined __ARM_NEON\n#define __max_16(ret, xx) (ret) = vmaxvq_u8((xx))\n#define allzero_16(xx) (vmaxvq_u8((xx)) == 0)\n\n#else\n#define __max_16(ret, xx) (ret) = m128i_max_u8((xx))\n#define allzero_16(xx) (m128i_allzero((xx)))\n#endif\n\n\t// initialization\n\tr = g_defr;\n\tminsc = (xtra&KSW_XSUBO)? xtra&0xffff : 0x10000;\n\tendsc = (xtra&KSW_XSTOP)? xtra&0xffff : 0x10000;\n\tm_b = n_b = 0; b = 0;\n\tzero = _mm_set1_epi32(0);\n\toe_del = _mm_set1_epi8(_o_del + _e_del);\n\te_del = _mm_set1_epi8(_e_del);\n\toe_ins = _mm_set1_epi8(_o_ins + _e_ins);\n\te_ins = _mm_set1_epi8(_e_ins);\n\tshift = _mm_set1_epi8(q->shift);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen;\n\tfor (i = 0; i < slen; ++i) {\n\t\t_mm_store_si128(E + i, zero);\n\t\t_mm_store_si128(H0 + i, zero);\n\t\t_mm_store_si128(Hmax + i, zero);\n\t}\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, imax;\n\t\t__m128i e, h, t, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 1); // h=H(i-1,-1); << instead of >> because x64 is little-endian\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t/* SW cells are computed in the following order:\n\t\t\t *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}\n\t\t\t *   E(i+1,j) = max{H(i,j)-q, E(i,j)-r}\n\t\t\t *   F(i,j+1) = max{H(i,j)-q, F(i,j)-r}\n\t\t\t */\n\t\t\t// compute H'(i,j); note that at the beginning, h=H'(i-1,j-1)\n\t\t\th = _mm_adds_epu8(h, _mm_load_si128(S + j));\n\t\t\th = _mm_subs_epu8(h, shift); // h=H'(i-1,j-1)+S(i,j)\n\t\t\te = _mm_load_si128(E + j); // e=E'(i,j)\n\t\t\th = _mm_max_epu8(h, e);\n\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\tmax = _mm_max_epu8(max, h); // set max\n\t\t\t_mm_store_si128(H1 + j, h); // save to H'(i,j)\n\t\t\t// now compute E'(i+1,j)\n\t\t\te = _mm_subs_epu8(e, e_del); // e=E'(i,j) - e_del\n\t\t\tt = _mm_subs_epu8(h, oe_del); // h=H'(i,j) - o_del - e_del\n\t\t\te = _mm_max_epu8(e, t); // e=E'(i+1,j)\n\t\t\t_mm_store_si128(E + j, e); // save to E'(i+1,j)\n\t\t\t// now compute F'(i,j+1)\n\t\t\tf = _mm_subs_epu8(f, e_ins);\n\t\t\tt = _mm_subs_epu8(h, oe_ins); // h=H'(i,j) - o_ins - e_ins\n\t\t\tf = _mm_max_epu8(f, t);\n\t\t\t// get H'(i-1,j) and prepare for the next j\n\t\t\th = _mm_load_si128(H0 + j); // h=H'(i-1,j)\n\t\t}\n\t\t// NB: we do not need to set E(i,j) as we disallow adjecent insertion and then deletion\n\t\tfor (k = 0; LIKELY(k < 16); ++k) { // this block mimics SWPS3; NB: H(i,j) updated in the lazy-F loop cannot exceed max\n\t\t\tf = _mm_slli_si128(f, 1);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu8(h, oe_ins);\n\t\t\t\tf = _mm_subs_epu8(f, e_ins);\n\t\t\t\tif (UNLIKELY(allzero_16(_mm_subs_epu8(f, h)))) goto end_loop16;\n\t\t\t}\n\t\t}\nend_loop16:\n\t\t//int k;for (k=0;k<16;++k)printf(\"%d \", ((uint8_t*)&max)[k]);printf(\"\\n\");\n\t\t__max_16(imax, max); // imax is the maximum number in max\n\t\tif (imax >= minsc) { // write the b array; this condition adds branching unfornately\n\t\t\tif (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) { // then append\n\t\t\t\tif (n_b == m_b) {\n\t\t\t\t\tm_b = m_b? m_b<<1 : 8;\n\t\t\t\t\tb = (uint64_t*)realloc(b, 8 * m_b);\n\t\t\t\t}\n\t\t\t\tb[n_b++] = (uint64_t)imax<<32 | i;\n\t\t\t} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last\n\t\t}\n\t\tif (imax > gmax) {\n\t\t\tgmax = imax; te = i; // te is the end position on the target\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) // keep the H1 vector\n\t\t\t\t_mm_store_si128(Hmax + j, _mm_load_si128(H1 + j));\n\t\t\tif (gmax + q->shift >= 255 || gmax >= endsc) break;\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S; // swap H0 and H1\n\t}\n\tr.score = gmax + q->shift < 255? gmax : 255;\n\tr.te = te;\n\tif (r.score != 255) { // get a->qe, the end of query match; find the 2nd best score\n\t\tint max = -1, tmp, low, high, qlen = slen * 16;\n\t\tuint8_t *t = (uint8_t*)Hmax;\n\t\tfor (i = 0; i < qlen; ++i, ++t)\n\t\t\tif ((int)*t > max) max = *t, r.qe = i / 16 + i % 16 * slen;\n\t\t\telse if ((int)*t == max && (tmp = i / 16 + i % 16 * slen) < r.qe) r.qe = tmp; \n\t\t//printf(\"%d,%d\\n\", max, gmax);\n\t\tif (b) {\n\t\t\ti = (r.score + q->max - 1) / q->max;\n\t\t\tlow = te - i; high = te + i;\n\t\t\tfor (i = 0; i < n_b; ++i) {\n\t\t\t\tint e = (int32_t)b[i];\n\t\t\t\tif ((e < low || e > high) && (int)(b[i]>>32) > r.score2)\n\t\t\t\t\tr.score2 = b[i]>>32, r.te2 = e;\n\t\t\t}\n\t\t}\n\t}\n\tfree(b);\n\treturn r;\n}\n\nkswr_t ksw_i16(kswq_t *q, int tlen, const uint8_t *target, int _o_del, int _e_del, int _o_ins, int _e_ins, int xtra) // the first gap costs -(_o+_e)\n{\n\tint slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;\n\tuint64_t *b;\n\t__m128i zero, oe_del, e_del, oe_ins, e_ins, *H0, *H1, *E, *Hmax;\n\tkswr_t r;\n\n#if defined __SSE2__\n#define __max_8(ret, xx) do { \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 2)); \\\n    \t(ret) = _mm_extract_epi16((xx), 0); \\\n\t} while (0)\n\n// Given entries all either 0x0000 or 0xffff, return whether they are all 0x0000\n#define allzero_0f_8(xx) (!_mm_movemask_epi8((xx)))\n\n#elif defined __ARM_NEON\n#define __max_8(ret, xx) (ret) = vmaxvq_s16(vreinterpretq_s16_u8((xx)))\n#define allzero_0f_8(xx) (vmaxvq_u16(vreinterpretq_u16_u8((xx))) == 0)\n\n#else\n#define __max_8(ret, xx) (ret) = m128i_max_s16((xx))\n#define allzero_0f_8(xx) (m128i_allzero((xx)))\n#endif\n\n\t// initialization\n\tr = g_defr;\n\tminsc = (xtra&KSW_XSUBO)? xtra&0xffff : 0x10000;\n\tendsc = (xtra&KSW_XSTOP)? xtra&0xffff : 0x10000;\n\tm_b = n_b = 0; b = 0;\n\tzero = _mm_set1_epi32(0);\n\toe_del = _mm_set1_epi16(_o_del + _e_del);\n\te_del = _mm_set1_epi16(_e_del);\n\toe_ins = _mm_set1_epi16(_o_ins + _e_ins);\n\te_ins = _mm_set1_epi16(_e_ins);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen;\n\tfor (i = 0; i < slen; ++i) {\n\t\t_mm_store_si128(E + i, zero);\n\t\t_mm_store_si128(H0 + i, zero);\n\t\t_mm_store_si128(Hmax + i, zero);\n\t}\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, imax;\n\t\t__m128i e, t, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 2);\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\th = _mm_adds_epi16(h, _mm_load_si128(S++));\n\t\t\te = _mm_load_si128(E + j);\n\t\t\th = _mm_max_epi16(h, e);\n\t\t\th = _mm_max_epi16(h, f);\n\t\t\tmax = _mm_max_epi16(max, h);\n\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\te = _mm_subs_epu16(e, e_del);\n\t\t\tt = _mm_subs_epu16(h, oe_del);\n\t\t\te = _mm_max_epi16(e, t);\n\t\t\t_mm_store_si128(E + j, e);\n\t\t\tf = _mm_subs_epu16(f, e_ins);\n\t\t\tt = _mm_subs_epu16(h, oe_ins);\n\t\t\tf = _mm_max_epi16(f, t);\n\t\t\th = _mm_load_si128(H0 + j);\n\t\t}\n\t\tfor (k = 0; LIKELY(k < 16); ++k) {\n\t\t\tf = _mm_slli_si128(f, 2);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epi16(h, f);\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu16(h, oe_ins);\n\t\t\t\tf = _mm_subs_epu16(f, e_ins);\n\t\t\t\tif(UNLIKELY(allzero_0f_8(_mm_cmpgt_epi16(f, h)))) goto end_loop8;\n\t\t\t}\n\t\t}\nend_loop8:\n\t\t__max_8(imax, max);\n\t\tif (imax >= minsc) {\n\t\t\tif (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) {\n\t\t\t\tif (n_b == m_b) {\n\t\t\t\t\tm_b = m_b? m_b<<1 : 8;\n\t\t\t\t\tb = (uint64_t*)realloc(b, 8 * m_b);\n\t\t\t\t}\n\t\t\t\tb[n_b++] = (uint64_t)imax<<32 | i;\n\t\t\t} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last\n\t\t}\n\t\tif (imax > gmax) {\n\t\t\tgmax = imax; te = i;\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j)\n\t\t\t\t_mm_store_si128(Hmax + j, _mm_load_si128(H1 + j));\n\t\t\tif (gmax >= endsc) break;\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S;\n\t}\n\tr.score = gmax; r.te = te;\n\t{\n\t\tint max = -1, tmp, low, high, qlen = slen * 8;\n\t\tuint16_t *t = (uint16_t*)Hmax;\n\t\tfor (i = 0, r.qe = -1; i < qlen; ++i, ++t)\n\t\t\tif ((int)*t > max) max = *t, r.qe = i / 8 + i % 8 * slen;\n\t\t\telse if ((int)*t == max && (tmp = i / 8 + i % 8 * slen) < r.qe) r.qe = tmp; \n\t\tif (b) {\n\t\t\ti = (r.score + q->max - 1) / q->max;\n\t\t\tlow = te - i; high = te + i;\n\t\t\tfor (i = 0; i < n_b; ++i) {\n\t\t\t\tint e = (int32_t)b[i];\n\t\t\t\tif ((e < low || e > high) && (int)(b[i]>>32) > r.score2)\n\t\t\t\t\tr.score2 = b[i]>>32, r.te2 = e;\n\t\t\t}\n\t\t}\n\t}\n\tfree(b);\n\treturn r;\n}\n\nstatic inline void revseq(int l, uint8_t *s)\n{\n\tint i, t;\n\tfor (i = 0; i < l>>1; ++i)\n\t\tt = s[i], s[i] = s[l - 1 - i], s[l - 1 - i] = t;\n}\n\nkswr_t ksw_align2(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int xtra, kswq_t **qry)\n{\n\tint size;\n\tkswq_t *q;\n\tkswr_t r, rr;\n\tkswr_t (*func)(kswq_t*, int, const uint8_t*, int, int, int, int, int);\n\n\tq = (qry && *qry)? *qry : ksw_qinit((xtra&KSW_XBYTE)? 1 : 2, qlen, query, m, mat);\n\tif (qry && *qry == 0) *qry = q;\n\tfunc = q->size == 2? ksw_i16 : ksw_u8;\n\tsize = q->size;\n\tr = func(q, tlen, target, o_del, e_del, o_ins, e_ins, xtra);\n\tif (qry == 0) free(q);\n\tif ((xtra&KSW_XSTART) == 0 || ((xtra&KSW_XSUBO) && r.score < (xtra&0xffff))) return r;\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target); // +1 because qe/te points to the exact end, not the position after the end\n\tq = ksw_qinit(size, r.qe + 1, query, m, mat);\n\trr = func(q, tlen, target, o_del, e_del, o_ins, e_ins, KSW_XSTOP | r.score);\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target);\n\tfree(q);\n\tif (r.score == rr.score)\n\t\tr.tb = r.te - rr.te, r.qb = r.qe - rr.qe;\n\treturn r;\n}\n\nkswr_t ksw_align(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int xtra, kswq_t **qry)\n{\n\treturn ksw_align2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, xtra, qry);\n}\n\n/********************\n *** SW extension ***\n ********************/\n\ntypedef struct {\n\tint32_t h, e;\n} eh_t;\n\nint ksw_extend2(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int w, int end_bonus, int zdrop, int h0, int *_qle, int *_tle, int *_gtle, int *_gscore, int *_max_off)\n{\n\teh_t *eh; // score array\n\tint8_t *qp; // query profile\n\tint i, j, k, oe_del = o_del + e_del, oe_ins = o_ins + e_ins, beg, end, max, max_i, max_j, max_ins, max_del, max_ie, gscore, max_off;\n\tassert(h0 > 0);\n\t// allocate memory\n\tqp = malloc(qlen * m);\n\teh = calloc(qlen + 1, 8);\n\t// generate the query profile\n\tfor (k = i = 0; k < m; ++k) {\n\t\tconst int8_t *p = &mat[k * m];\n\t\tfor (j = 0; j < qlen; ++j) qp[i++] = p[query[j]];\n\t}\n\t// fill the first row\n\teh[0].h = h0; eh[1].h = h0 > oe_ins? h0 - oe_ins : 0;\n\tfor (j = 2; j <= qlen && eh[j-1].h > e_ins; ++j)\n\t\teh[j].h = eh[j-1].h - e_ins;\n\t// adjust $w if it is too large\n\tk = m * m;\n\tfor (i = 0, max = 0; i < k; ++i) // get the max score\n\t\tmax = max > mat[i]? max : mat[i];\n\tmax_ins = (int)((double)(qlen * max + end_bonus - o_ins) / e_ins + 1.);\n\tmax_ins = max_ins > 1? max_ins : 1;\n\tw = w < max_ins? w : max_ins;\n\tmax_del = (int)((double)(qlen * max + end_bonus - o_del) / e_del + 1.);\n\tmax_del = max_del > 1? max_del : 1;\n\tw = w < max_del? w : max_del; // TODO: is this necessary?\n\t// DP loop\n\tmax = h0, max_i = max_j = -1; max_ie = -1, gscore = -1;\n\tmax_off = 0;\n\tbeg = 0, end = qlen;\n\tfor (i = 0; LIKELY(i < tlen); ++i) {\n\t\tint t, f = 0, h1, m = 0, mj = -1;\n\t\tint8_t *q = &qp[target[i] * qlen];\n\t\t// apply the band and the constraint (if provided)\n\t\tif (beg < i - w) beg = i - w;\n\t\tif (end > i + w + 1) end = i + w + 1;\n\t\tif (end > qlen) end = qlen;\n\t\t// compute the first column\n\t\tif (beg == 0) {\n\t\t\th1 = h0 - (o_del + e_del * (i + 1));\n\t\t\tif (h1 < 0) h1 = 0;\n\t\t} else h1 = 0;\n\t\tfor (j = beg; LIKELY(j < end); ++j) {\n\t\t\t// At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)\n\t\t\t// Similar to SSE2-SW, cells are computed in the following order:\n\t\t\t//   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}\n\t\t\t//   E(i+1,j) = max{H(i,j)-gapo, E(i,j)} - gape\n\t\t\t//   F(i,j+1) = max{H(i,j)-gapo, F(i,j)} - gape\n\t\t\teh_t *p = &eh[j];\n\t\t\tint h, M = p->h, e = p->e; // get H(i-1,j-1) and E(i-1,j)\n\t\t\tp->h = h1;          // set H(i,j-1) for the next row\n\t\t\tM = M? M + q[j] : 0;// separating H and M to disallow a cigar like \"100M3I3D20M\"\n\t\t\th = M > e? M : e;   // e and f are guaranteed to be non-negative, so h>=0 even if M<0\n\t\t\th = h > f? h : f;\n\t\t\th1 = h;             // save H(i,j) to h1 for the next column\n\t\t\tmj = m > h? mj : j; // record the position where max score is achieved\n\t\t\tm = m > h? m : h;   // m is stored at eh[mj+1]\n\t\t\tt = M - oe_del;\n\t\t\tt = t > 0? t : 0;\n\t\t\te -= e_del;\n\t\t\te = e > t? e : t;   // computed E(i+1,j)\n\t\t\tp->e = e;           // save E(i+1,j) for the next row\n\t\t\tt = M - oe_ins;\n\t\t\tt = t > 0? t : 0;\n\t\t\tf -= e_ins;\n\t\t\tf = f > t? f : t;   // computed F(i,j+1)\n\t\t}\n\t\teh[end].h = h1; eh[end].e = 0;\n\t\tif (j == qlen) {\n\t\t\tmax_ie = gscore > h1? max_ie : i;\n\t\t\tgscore = gscore > h1? gscore : h1;\n\t\t}\n\t\tif (m == 0) break;\n\t\tif (m > max) {\n\t\t\tmax = m, max_i = i, max_j = mj;\n\t\t\tmax_off = max_off > abs(mj - i)? max_off : abs(mj - i);\n\t\t} else if (zdrop > 0) {\n\t\t\tif (i - max_i > mj - max_j) {\n\t\t\t\tif (max - m - ((i - max_i) - (mj - max_j)) * e_del > zdrop) break;\n\t\t\t} else {\n\t\t\t\tif (max - m - ((mj - max_j) - (i - max_i)) * e_ins > zdrop) break;\n\t\t\t}\n\t\t}\n\t\t// update beg and end for the next round\n\t\tfor (j = beg; LIKELY(j < end) && eh[j].h == 0 && eh[j].e == 0; ++j);\n\t\tbeg = j;\n\t\tfor (j = end; LIKELY(j >= beg) && eh[j].h == 0 && eh[j].e == 0; --j);\n\t\tend = j + 2 < qlen? j + 2 : qlen;\n\t\t//beg = 0; end = qlen; // uncomment this line for debugging\n\t}\n\tfree(eh); free(qp);\n\tif (_qle) *_qle = max_j + 1;\n\tif (_tle) *_tle = max_i + 1;\n\tif (_gtle) *_gtle = max_ie + 1;\n\tif (_gscore) *_gscore = gscore;\n\tif (_max_off) *_max_off = max_off;\n\treturn max;\n}\n\nint ksw_extend(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int end_bonus, int zdrop, int h0, int *qle, int *tle, int *gtle, int *gscore, int *max_off)\n{\n\treturn ksw_extend2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, w, end_bonus, zdrop, h0, qle, tle, gtle, gscore, max_off);\n}\n\n/********************\n * Global alignment *\n ********************/\n\n#define MINUS_INF -0x40000000\n\nstatic inline uint32_t *push_cigar(int *n_cigar, int *m_cigar, uint32_t *cigar, int op, int len)\n{\n\tif (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {\n\t\tif (*n_cigar == *m_cigar) {\n\t\t\t*m_cigar = *m_cigar? (*m_cigar)<<1 : 4;\n\t\t\tcigar = realloc(cigar, (*m_cigar) << 2);\n\t\t}\n\t\tcigar[(*n_cigar)++] = len<<4 | op;\n\t} else cigar[(*n_cigar)-1] += len<<4;\n\treturn cigar;\n}\n\nint ksw_global2(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int w, int *n_cigar_, uint32_t **cigar_)\n{\n\teh_t *eh;\n\tint8_t *qp; // query profile\n\tint i, j, k, oe_del = o_del + e_del, oe_ins = o_ins + e_ins, score, n_col;\n\tuint8_t *z; // backtrack matrix; in each cell: f<<4|e<<2|h; in principle, we can halve the memory, but backtrack will be a little more complex\n\tif (n_cigar_) *n_cigar_ = 0;\n\t// allocate memory\n\tn_col = qlen < 2*w+1? qlen : 2*w+1; // maximum #columns of the backtrack matrix\n\tz = n_cigar_ && cigar_? malloc((long)n_col * tlen) : 0;\n\tqp = malloc(qlen * m);\n\teh = calloc(qlen + 1, 8);\n\t// generate the query profile\n\tfor (k = i = 0; k < m; ++k) {\n\t\tconst int8_t *p = &mat[k * m];\n\t\tfor (j = 0; j < qlen; ++j) qp[i++] = p[query[j]];\n\t}\n\t// fill the first row\n\teh[0].h = 0; eh[0].e = MINUS_INF;\n\tfor (j = 1; j <= qlen && j <= w; ++j)\n\t\teh[j].h = -(o_ins + e_ins * j), eh[j].e = MINUS_INF;\n\tfor (; j <= qlen; ++j) eh[j].h = eh[j].e = MINUS_INF; // everything is -inf outside the band\n\t// DP loop\n\tfor (i = 0; LIKELY(i < tlen); ++i) { // target sequence is in the outer loop\n\t\tint32_t f = MINUS_INF, h1, beg, end, t;\n\t\tint8_t *q = &qp[target[i] * qlen];\n\t\tbeg = i > w? i - w : 0;\n\t\tend = i + w + 1 < qlen? i + w + 1 : qlen; // only loop through [beg,end) of the query sequence\n\t\th1 = beg == 0? -(o_del + e_del * (i + 1)) : MINUS_INF;\n\t\tif (n_cigar_ && cigar_) {\n\t\t\tuint8_t *zi = &z[(long)i * n_col];\n\t\t\tfor (j = beg; LIKELY(j < end); ++j) {\n\t\t\t\t// At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)\n\t\t\t\t// Cells are computed in the following order:\n\t\t\t\t//   M(i,j)   = H(i-1,j-1) + S(i,j)\n\t\t\t\t//   H(i,j)   = max{M(i,j), E(i,j), F(i,j)}\n\t\t\t\t//   E(i+1,j) = max{M(i,j)-gapo, E(i,j)} - gape\n\t\t\t\t//   F(i,j+1) = max{M(i,j)-gapo, F(i,j)} - gape\n\t\t\t\t// We have to separate M(i,j); otherwise the direction may not be recorded correctly.\n\t\t\t\t// However, a CIGAR like \"10M3I3D10M\" allowed by local() is disallowed by global().\n\t\t\t\t// Such a CIGAR may occur, in theory, if mismatch_penalty > 2*gap_ext_penalty + 2*gap_open_penalty/k.\n\t\t\t\t// In practice, this should happen very rarely given a reasonable scoring system.\n\t\t\t\teh_t *p = &eh[j];\n\t\t\t\tint32_t h, m = p->h, e = p->e;\n\t\t\t\tuint8_t d; // direction\n\t\t\t\tp->h = h1;\n\t\t\t\tm += q[j];\n\t\t\t\td = m >= e? 0 : 1;\n\t\t\t\th = m >= e? m : e;\n\t\t\t\td = h >= f? d : 2;\n\t\t\t\th = h >= f? h : f;\n\t\t\t\th1 = h;\n\t\t\t\tt = m - oe_del;\n\t\t\t\te -= e_del;\n\t\t\t\td |= e > t? 1<<2 : 0;\n\t\t\t\te  = e > t? e    : t;\n\t\t\t\tp->e = e;\n\t\t\t\tt = m - oe_ins;\n\t\t\t\tf -= e_ins;\n\t\t\t\td |= f > t? 2<<4 : 0; // if we want to halve the memory, use one bit only, instead of two\n\t\t\t\tf  = f > t? f    : t;\n\t\t\t\tzi[j - beg] = d; // z[i,j] keeps h for the current cell and e/f for the next cell\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = beg; LIKELY(j < end); ++j) {\n\t\t\t\teh_t *p = &eh[j];\n\t\t\t\tint32_t h, m = p->h, e = p->e;\n\t\t\t\tp->h = h1;\n\t\t\t\tm += q[j];\n\t\t\t\th = m >= e? m : e;\n\t\t\t\th = h >= f? h : f;\n\t\t\t\th1 = h;\n\t\t\t\tt = m - oe_del;\n\t\t\t\te -= e_del;\n\t\t\t\te  = e > t? e : t;\n\t\t\t\tp->e = e;\n\t\t\t\tt = m - oe_ins;\n\t\t\t\tf -= e_ins;\n\t\t\t\tf  = f > t? f : t;\n\t\t\t}\n\t\t}\n\t\teh[end].h = h1; eh[end].e = MINUS_INF;\n\t}\n\tscore = eh[qlen].h;\n\tif (n_cigar_ && cigar_) { // backtrack\n\t\tint n_cigar = 0, m_cigar = 0, which = 0;\n\t\tuint32_t *cigar = 0, tmp;\n\t\ti = tlen - 1; k = (i + w + 1 < qlen? i + w + 1 : qlen) - 1; // (i,k) points to the last cell\n\t\twhile (i >= 0 && k >= 0) {\n\t\t\twhich = z[(long)i * n_col + (k - (i > w? i - w : 0))] >> (which<<1) & 3;\n\t\t\tif (which == 0)      cigar = push_cigar(&n_cigar, &m_cigar, cigar, 0, 1), --i, --k;\n\t\t\telse if (which == 1) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, 1), --i;\n\t\t\telse                 cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, 1), --k;\n\t\t}\n\t\tif (i >= 0) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, i + 1);\n\t\tif (k >= 0) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, k + 1);\n\t\tfor (i = 0; i < n_cigar>>1; ++i) // reverse CIGAR\n\t\t\ttmp = cigar[i], cigar[i] = cigar[n_cigar-1-i], cigar[n_cigar-1-i] = tmp;\n\t\t*n_cigar_ = n_cigar, *cigar_ = cigar;\n\t}\n\tfree(eh); free(qp); free(z);\n\treturn score;\n}\n\nint ksw_global(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int *n_cigar_, uint32_t **cigar_)\n{\n\treturn ksw_global2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, w, n_cigar_, cigar_);\n}\n\n/*******************************************\n * Main function (not compiled by default) *\n *******************************************/\n\n#ifdef _KSW_MAIN\n\n#include <unistd.h>\n#include <stdio.h>\n#include <zlib.h>\n#include \"kseq.h\"\nKSEQ_INIT(gzFile, err_gzread)\n\nunsigned char seq_nt4_table[256] = {\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4\n};\n\nint main(int argc, char *argv[])\n{\n\tint c, sa = 1, sb = 3, i, j, k, forward_only = 0, max_rseq = 0;\n\tint8_t mat[25];\n\tint gapo = 5, gape = 2, minsc = 0, xtra = KSW_XSTART;\n\tuint8_t *rseq = 0;\n\tgzFile fpt, fpq;\n\tkseq_t *kst, *ksq;\n\n\t// parse command line\n\twhile ((c = getopt(argc, argv, \"a:b:q:r:ft:1\")) >= 0) {\n\t\tswitch (c) {\n\t\t\tcase 'a': sa = atoi(optarg); break;\n\t\t\tcase 'b': sb = atoi(optarg); break;\n\t\t\tcase 'q': gapo = atoi(optarg); break;\n\t\t\tcase 'r': gape = atoi(optarg); break;\n\t\t\tcase 't': minsc = atoi(optarg); break;\n\t\t\tcase 'f': forward_only = 1; break;\n\t\t\tcase '1': xtra |= KSW_XBYTE; break;\n\t\t}\n\t}\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"Usage: ksw [-1] [-f] [-a%d] [-b%d] [-q%d] [-r%d] [-t%d] <target.fa> <query.fa>\\n\", sa, sb, gapo, gape, minsc);\n\t\treturn 1;\n\t}\n\tif (minsc > 0xffff) minsc = 0xffff;\n\txtra |= KSW_XSUBO | minsc;\n\t// initialize scoring matrix\n\tfor (i = k = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tmat[k++] = i == j? sa : -sb;\n\t\tmat[k++] = 0; // ambiguous base\n\t}\n\tfor (j = 0; j < 5; ++j) mat[k++] = 0;\n\t// open file\n\tfpt = xzopen(argv[optind],   \"r\"); kst = kseq_init(fpt);\n\tfpq = xzopen(argv[optind+1], \"r\"); ksq = kseq_init(fpq);\n\t// all-pair alignment\n\twhile (kseq_read(ksq) > 0) {\n\t\tkswq_t *q[2] = {0, 0};\n\t\tkswr_t r;\n\t\tfor (i = 0; i < (int)ksq->seq.l; ++i) ksq->seq.s[i] = seq_nt4_table[(int)ksq->seq.s[i]];\n\t\tif (!forward_only) { // reverse\n\t\t\tif ((int)ksq->seq.m > max_rseq) {\n\t\t\t\tmax_rseq = ksq->seq.m;\n\t\t\t\trseq = (uint8_t*)realloc(rseq, max_rseq);\n\t\t\t}\n\t\t\tfor (i = 0, j = ksq->seq.l - 1; i < (int)ksq->seq.l; ++i, --j)\n\t\t\t\trseq[j] = ksq->seq.s[i] == 4? 4 : 3 - ksq->seq.s[i];\n\t\t}\n\t\tgzrewind(fpt); kseq_rewind(kst);\n\t\twhile (kseq_read(kst) > 0) {\n\t\t\tfor (i = 0; i < (int)kst->seq.l; ++i) kst->seq.s[i] = seq_nt4_table[(int)kst->seq.s[i]];\n\t\t\tr = ksw_align(ksq->seq.l, (uint8_t*)ksq->seq.s, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[0]);\n\t\t\tif (r.score >= minsc)\n\t\t\t\terr_printf(\"%s\\t%d\\t%d\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", kst->name.s, r.tb, r.te+1, ksq->name.s, r.qb, r.qe+1, r.score, r.score2, r.te2);\n\t\t\tif (rseq) {\n\t\t\t\tr = ksw_align(ksq->seq.l, rseq, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[1]);\n\t\t\t\tif (r.score >= minsc)\n\t\t\t\t\terr_printf(\"%s\\t%d\\t%d\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", kst->name.s, r.tb, r.te+1, ksq->name.s, (int)ksq->seq.l - r.qb, (int)ksq->seq.l - 1 - r.qe, r.score, r.score2, r.te2);\n\t\t\t}\n\t\t}\n\t\tfree(q[0]); free(q[1]);\n\t}\n\tfree(rseq);\n\tkseq_destroy(kst); err_gzclose(fpt);\n\tkseq_destroy(ksq); err_gzclose(fpq);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "ksw.h",
          "type": "blob",
          "size": 4.9716796875,
          "content": "#ifndef __AC_KSW_H\n#define __AC_KSW_H\n\n#include <stdint.h>\n\n#define KSW_XBYTE  0x10000\n#define KSW_XSTOP  0x20000\n#define KSW_XSUBO  0x40000\n#define KSW_XSTART 0x80000\n\nstruct _kswq_t;\ntypedef struct _kswq_t kswq_t;\n\ntypedef struct {\n\tint score; // best score\n\tint te, qe; // target end and query end\n\tint score2, te2; // second best score and ending position on the target\n\tint tb, qb; // target start and query start\n} kswr_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t/**\n\t * Aligning two sequences\n\t *\n\t * @param qlen    length of the query sequence (typically <tlen)\n\t * @param query   query sequence with 0 <= query[i] < m\n\t * @param tlen    length of the target sequence\n\t * @param target  target sequence\n\t * @param m       number of residue types\n\t * @param mat     m*m scoring matrix in one-dimension array\n\t * @param gapo    gap open penalty; a gap of length l cost \"-(gapo+l*gape)\"\n\t * @param gape    gap extension penalty\n\t * @param xtra    extra information (see below)\n\t * @param qry     query profile (see below)\n\t *\n\t * @return        alignment information in a struct; unset values to -1\n\t *\n\t * When xtra==0, ksw_align() uses a signed two-byte integer to store a\n\t * score and only finds the best score and the end positions. The 2nd best\n\t * score or the start positions are not attempted. The default behavior can\n\t * be tuned by setting KSW_X* flags:\n\t *\n\t *   KSW_XBYTE:  use an unsigned byte to store a score. If overflow occurs,\n\t *               kswr_t::score will be set to 255\n\t *\n\t *   KSW_XSUBO:  track the 2nd best score and the ending position on the\n\t *               target if the 2nd best is higher than (xtra&0xffff)\n\t *\n\t *   KSW_XSTOP:  stop if the maximum score is above (xtra&0xffff)\n\t *\n\t *   KSW_XSTART: find the start positions\n\t *\n\t * When *qry==NULL, ksw_align() will compute and allocate the query profile\n\t * and when the function returns, *qry will point to the profile, which can\n\t * be deallocated simply by free(). If one query is aligned against multiple\n\t * target sequences, *qry should be set to NULL during the first call and\n\t * freed after the last call. Note that qry can equal 0. In this case, the\n\t * query profile will be deallocated in ksw_align().\n\t */\n\tkswr_t ksw_align(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int xtra, kswq_t **qry);\n\tkswr_t ksw_align2(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int xtra, kswq_t **qry);\n\n\t/**\n\t * Banded global alignment\n\t *\n\t * @param qlen    query length\n\t * @param query   query sequence with 0 <= query[i] < m\n\t * @param tlen    target length\n\t * @param target  target sequence with 0 <= target[i] < m\n\t * @param m       number of residue types\n\t * @param mat     m*m scoring mattrix in one-dimension array\n\t * @param gapo    gap open penalty; a gap of length l cost \"-(gapo+l*gape)\"\n\t * @param gape    gap extension penalty\n\t * @param w       band width\n\t * @param n_cigar (out) number of CIGAR elements\n\t * @param cigar   (out) BAM-encoded CIGAR; caller need to deallocate with free()\n\t *\n\t * @return        score of the alignment\n\t */\n\tint ksw_global(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int *n_cigar, uint32_t **cigar);\n\tint ksw_global2(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int w, int *n_cigar, uint32_t **cigar);\n\n\t/**\n\t * Extend alignment\n\t *\n\t * The routine aligns $query and $target, assuming their upstream sequences,\n\t * which are not provided, have been aligned with score $h0. In return,\n\t * region [0,*qle) on the query and [0,*tle) on the target sequences are\n\t * aligned together. If *gscore>=0, *gscore keeps the best score such that\n\t * the entire query sequence is aligned; *gtle keeps the position on the\n\t * target where *gscore is achieved. Returning *gscore and *gtle helps the\n\t * caller to decide whether an end-to-end hit or a partial hit is preferred.\n\t *\n\t * The first 9 parameters are identical to those in ksw_global()\n\t *\n\t * @param h0      alignment score of upstream sequences\n\t * @param _qle    (out) length of the query in the alignment\n\t * @param _tle    (out) length of the target in the alignment\n\t * @param _gtle   (out) length of the target if query is fully aligned\n\t * @param _gscore (out) score of the best end-to-end alignment; negative if not found\n\t *\n\t * @return        best semi-local alignment score\n\t */\n\tint ksw_extend(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int end_bonus, int zdrop, int h0, int *qle, int *tle, int *gtle, int *gscore, int *max_off);\n\tint ksw_extend2(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int w, int end_bonus, int zdrop, int h0, int *qle, int *tle, int *gtle, int *gscore, int *max_off);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kthread.c",
          "type": "blob",
          "size": 3.65625,
          "content": "#include <pthread.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <limits.h>\n\n/************\n * kt_for() *\n ************/\n\nstruct kt_for_t;\n\ntypedef struct {\n\tstruct kt_for_t *t;\n\tlong i;\n} ktf_worker_t;\n\ntypedef struct kt_for_t {\n\tint n_threads;\n\tlong n;\n\tktf_worker_t *w;\n\tvoid (*func)(void*,long,int);\n\tvoid *data;\n} kt_for_t;\n\nstatic inline long steal_work(kt_for_t *t)\n{\n\tint i, min_i = -1;\n\tlong k, min = LONG_MAX;\n\tfor (i = 0; i < t->n_threads; ++i)\n\t\tif (min > t->w[i].i) min = t->w[i].i, min_i = i;\n\tk = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);\n\treturn k >= t->n? -1 : k;\n}\n\nstatic void *ktf_worker(void *data)\n{\n\tktf_worker_t *w = (ktf_worker_t*)data;\n\tlong i;\n\tfor (;;) {\n\t\ti = __sync_fetch_and_add(&w->i, w->t->n_threads);\n\t\tif (i >= w->t->n) break;\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\t}\n\twhile ((i = steal_work(w->t)) >= 0)\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\tpthread_exit(0);\n}\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n)\n{\n\tint i;\n\tkt_for_t t;\n\tpthread_t *tid;\n\tt.func = func, t.data = data, t.n_threads = n_threads, t.n = n;\n\tt.w = (ktf_worker_t*)alloca(n_threads * sizeof(ktf_worker_t));\n\ttid = (pthread_t*)alloca(n_threads * sizeof(pthread_t));\n\tfor (i = 0; i < n_threads; ++i)\n\t\tt.w[i].t = &t, t.w[i].i = i;\n\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktf_worker, &t.w[i]);\n\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n}\n\n/*****************\n * kt_pipeline() *\n *****************/\n\nstruct ktp_t;\n\ntypedef struct {\n\tstruct ktp_t *pl;\n\tint64_t index;\n\tint step;\n\tvoid *data;\n} ktp_worker_t;\n\ntypedef struct ktp_t {\n\tvoid *shared;\n\tvoid *(*func)(void*, int, void*);\n\tint64_t index;\n\tint n_workers, n_steps;\n\tktp_worker_t *workers;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cv;\n} ktp_t;\n\nstatic void *ktp_worker(void *data)\n{\n\tktp_worker_t *w = (ktp_worker_t*)data;\n\tktp_t *p = w->pl;\n\twhile (w->step < p->n_steps) {\n\t\t// test whether we can kick off the job with this worker\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tfor (;;) {\n\t\t\tint i;\n\t\t\t// test whether another worker is doing the same step\n\t\t\tfor (i = 0; i < p->n_workers; ++i) {\n\t\t\t\tif (w == &p->workers[i]) continue; // ignore itself\n\t\t\t\tif (p->workers[i].step <= w->step && p->workers[i].index < w->index)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps\n\t\t\tpthread_cond_wait(&p->cv, &p->mutex);\n\t\t}\n\t\tpthread_mutex_unlock(&p->mutex);\n\n\t\t// working on w->step\n\t\tw->data = p->func(p->shared, w->step, w->step? w->data : 0); // for the first step, input is NULL\n\n\t\t// update step and let other workers know\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tw->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;\n\t\tif (w->step == 0) w->index = p->index++;\n\t\tpthread_cond_broadcast(&p->cv);\n\t\tpthread_mutex_unlock(&p->mutex);\n\t}\n\tpthread_exit(0);\n}\n\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps)\n{\n\tktp_t aux;\n\tpthread_t *tid;\n\tint i;\n\n\tif (n_threads < 1) n_threads = 1;\n\taux.n_workers = n_threads;\n\taux.n_steps = n_steps;\n\taux.func = func;\n\taux.shared = shared_data;\n\taux.index = 0;\n\tpthread_mutex_init(&aux.mutex, 0);\n\tpthread_cond_init(&aux.cv, 0);\n\n\taux.workers = (ktp_worker_t*)alloca(n_threads * sizeof(ktp_worker_t));\n\tfor (i = 0; i < n_threads; ++i) {\n\t\tktp_worker_t *w = &aux.workers[i];\n\t\tw->step = 0; w->pl = &aux; w->data = 0;\n\t\tw->index = aux.index++;\n\t}\n\n\ttid = (pthread_t*)alloca(n_threads * sizeof(pthread_t));\n\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);\n\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n\n\tpthread_mutex_destroy(&aux.mutex);\n\tpthread_cond_destroy(&aux.cv);\n}\n"
        },
        {
          "name": "kvec.h",
          "type": "blob",
          "size": 2.87109375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"kvec.h\"\nint main() {\n\tkvec_t(int) array;\n\tkv_init(array);\n\tkv_push(int, array, 10); // append\n\tkv_a(int, array, 20) = 5; // dynamic\n\tkv_A(array, 20) = 4; // static\n\tkv_destroy(array);\n\treturn 0;\n}\n*/\n\n/*\n  2008-09-22 (0.1.0):\n\n\t* The initial version.\n\n*/\n\n#ifndef AC_KVEC_H\n#define AC_KVEC_H\n\n#include <stdlib.h>\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n\n#define kvec_t(type) struct { size_t n, m; type *a; }\n#define kv_init(v) ((v).n = (v).m = 0, (v).a = 0)\n#define kv_destroy(v) free((v).a)\n#define kv_A(v, i) ((v).a[(i)])\n#define kv_pop(v) ((v).a[--(v).n])\n#define kv_size(v) ((v).n)\n#define kv_max(v) ((v).m)\n\n#define kv_resize(type, v, s)  ((v).m = (s), (v).a = (type*)realloc((v).a, sizeof(type) * (v).m))\n\n#define kv_copy(type, v1, v0) do {\t\t\t\t\t\t\t\\\n\t\tif ((v1).m < (v0).n) kv_resize(type, v1, (v0).n);\t\\\n\t\t(v1).n = (v0).n;\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy((v1).a, (v0).a, sizeof(type) * (v0).n);\t\t\\\n\t} while (0)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#define kv_push(type, v, x) do {\t\t\t\t\t\t\t\t\t\\\n\t\tif ((v).n == (v).m) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t(v).m = (v).m? (v).m<<1 : 2;\t\t\t\t\t\t\t\\\n\t\t\t(v).a = (type*)realloc((v).a, sizeof(type) * (v).m); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(v).a[(v).n++] = (x);\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define kv_pushp(type, v) ((((v).n == (v).m)?\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t   ((v).m = ((v).m? (v).m<<1 : 2),\t\t\t\t\\\n\t\t\t\t\t\t\t(v).a = (type*)realloc((v).a, sizeof(type) * (v).m), 0)\t\\\n\t\t\t\t\t\t   : 0), &(v).a[(v).n++])\n\n#define kv_a(type, v, i) (((v).m <= (size_t)(i)? \\\n\t\t\t\t\t\t  ((v).m = (v).n = (i) + 1, kv_roundup32((v).m), \\\n\t\t\t\t\t\t   (v).a = (type*)realloc((v).a, sizeof(type) * (v).m), 0) \\\n\t\t\t\t\t\t  : (v).n <= (size_t)(i)? (v).n = (i) + 1 \\\n\t\t\t\t\t\t  : 0), (v).a[(i)])\n\n#endif\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 5.7333984375,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#include <stdio.h>\n#include <string.h>\n#include \"kstring.h\"\n#include \"utils.h\"\n\n#ifndef PACKAGE_VERSION\n#define PACKAGE_VERSION \"0.7.18-r1243-dirty\"\n#endif\n\nint bwa_fa2pac(int argc, char *argv[]);\nint bwa_pac2bwt(int argc, char *argv[]);\nint bwa_bwtupdate(int argc, char *argv[]);\nint bwa_bwt2sa(int argc, char *argv[]);\nint bwa_index(int argc, char *argv[]);\nint bwt_bwtgen_main(int argc, char *argv[]);\n\nint bwa_aln(int argc, char *argv[]);\nint bwa_sai2sam_se(int argc, char *argv[]);\nint bwa_sai2sam_pe(int argc, char *argv[]);\n\nint bwa_bwtsw2(int argc, char *argv[]);\n\nint main_fastmap(int argc, char *argv[]);\nint main_mem(int argc, char *argv[]);\nint main_shm(int argc, char *argv[]);\n\nint main_pemerge(int argc, char *argv[]);\nint main_maxk(int argc, char *argv[]);\n\t\nstatic int usage()\n{\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Program: bwa (alignment via Burrows-Wheeler transformation)\\n\");\n\tfprintf(stderr, \"Version: %s\\n\", PACKAGE_VERSION);\n\tfprintf(stderr, \"Contact: Heng Li <hli@ds.dfci.harvard.edu>\\n\\n\");\n\tfprintf(stderr, \"Usage:   bwa <command> [options]\\n\\n\");\n\tfprintf(stderr, \"Command: index         index sequences in the FASTA format\\n\");\n\tfprintf(stderr, \"         mem           BWA-MEM algorithm\\n\");\n\tfprintf(stderr, \"         fastmap       identify super-maximal exact matches\\n\");\n\tfprintf(stderr, \"         pemerge       merge overlapping paired ends (EXPERIMENTAL)\\n\");\n\tfprintf(stderr, \"         aln           gapped/ungapped alignment\\n\");\n\tfprintf(stderr, \"         samse         generate alignment (single ended)\\n\");\n\tfprintf(stderr, \"         sampe         generate alignment (paired ended)\\n\");\n\tfprintf(stderr, \"         bwasw         BWA-SW for long queries (DEPRECATED)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"         shm           manage indices in shared memory\\n\");\n\tfprintf(stderr, \"         fa2pac        convert FASTA to PAC format\\n\");\n\tfprintf(stderr, \"         pac2bwt       generate BWT from PAC\\n\");\n\tfprintf(stderr, \"         pac2bwtgen    alternative algorithm for generating BWT\\n\");\n\tfprintf(stderr, \"         bwtupdate     update .bwt to the new format\\n\");\n\tfprintf(stderr, \"         bwt2sa        generate SA from BWT and Occ\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr,\n\"Note: To use BWA, you need to first index the genome with `bwa index'.\\n\"\n\"      There are three alignment algorithms in BWA: `mem', `bwasw', and\\n\"\n\"      `aln/samse/sampe'. If you are not sure which to use, try `bwa mem'\\n\"\n\"      first. Please `man ./bwa.1' for the manual.\\n\\n\");\n\treturn 1;\n}\n\nint main(int argc, char *argv[])\n{\n\textern char *bwa_pg;\n\tint i, ret;\n\tdouble t_real;\n\tkstring_t pg = {0,0,0};\n\tt_real = realtime();\n\tksprintf(&pg, \"@PG\\tID:bwa\\tPN:bwa\\tVN:%s\\tCL:%s\", PACKAGE_VERSION, argv[0]);\n\tfor (i = 1; i < argc; ++i) ksprintf(&pg, \" %s\", argv[i]);\n\tbwa_pg = pg.s;\n\tif (argc < 2) return usage();\n\tif (strcmp(argv[1], \"fa2pac\") == 0) ret = bwa_fa2pac(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pac2bwt\") == 0) ret = bwa_pac2bwt(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pac2bwtgen\") == 0) ret = bwt_bwtgen_main(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwtupdate\") == 0) ret = bwa_bwtupdate(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwt2sa\") == 0) ret = bwa_bwt2sa(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"index\") == 0) ret = bwa_index(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"aln\") == 0) ret = bwa_aln(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"samse\") == 0) ret = bwa_sai2sam_se(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"sampe\") == 0) ret = bwa_sai2sam_pe(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwtsw2\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"dbwtsw\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwasw\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"fastmap\") == 0) ret = main_fastmap(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"mem\") == 0) ret = main_mem(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"shm\") == 0) ret = main_shm(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pemerge\") == 0) ret = main_pemerge(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"maxk\") == 0) ret = main_maxk(argc-1, argv+1);\n\telse {\n\t\tfprintf(stderr, \"[main] unrecognized command '%s'\\n\", argv[1]);\n\t\treturn 1;\n\t}\n\terr_fflush(stdout);\n\terr_fclose(stdout);\n\tif (ret == 0) {\n\t\tfprintf(stderr, \"[%s] Version: %s\\n\", __func__, PACKAGE_VERSION);\n\t\tfprintf(stderr, \"[%s] CMD:\", __func__);\n\t\tfor (i = 0; i < argc; ++i)\n\t\t\tfprintf(stderr, \" %s\", argv[i]);\n\t\tfprintf(stderr, \"\\n[%s] Real time: %.3f sec; CPU: %.3f sec\\n\", __func__, realtime() - t_real, cputime());\n\t}\n\tfree(bwa_pg);\n\treturn ret;\n}\n"
        },
        {
          "name": "malloc_wrap.c",
          "type": "blob",
          "size": 1.4150390625,
          "content": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#ifdef USE_MALLOC_WRAPPERS\n/* Don't wrap ourselves */\n#  undef USE_MALLOC_WRAPPERS\n#endif\n#include \"malloc_wrap.h\"\n\nvoid *wrap_calloc(size_t nmemb, size_t size,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tvoid *p = calloc(nmemb, size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, nmemb * size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}\n\nvoid *wrap_malloc(size_t size,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tvoid *p = malloc(size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}\n\nvoid *wrap_realloc(void *ptr, size_t size,\n\t\t\t\t   const char *file, unsigned int line, const char *func) {\n\tvoid *p = realloc(ptr, size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}\n\nchar *wrap_strdup(const char *s,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tchar *p = strdup(s);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, strlen(s), file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}\n"
        },
        {
          "name": "malloc_wrap.h",
          "type": "blob",
          "size": 1.1552734375,
          "content": "#ifndef MALLOC_WRAP_H\n#define MALLOC_WRAP_H\n\n#include <stdlib.h>  /* Avoid breaking the usual definitions */\n#include <string.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tvoid *wrap_calloc(size_t nmemb, size_t size,\n\t\t\t\t\t  const char *file, unsigned int line, const char *func);\n\tvoid *wrap_malloc(size_t size,\n\t\t\t\t\t  const char *file, unsigned int line, const char *func);\n\tvoid *wrap_realloc(void *ptr, size_t size,\n\t\t\t\t\t   const char *file, unsigned int line, const char *func);\n\tchar *wrap_strdup(const char *s,\n\t\t\t\t\t  const char *file, unsigned int line, const char *func);\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifdef USE_MALLOC_WRAPPERS\n#  ifdef calloc\n#    undef calloc\n#  endif\n#  define calloc(n, s)  wrap_calloc( (n), (s), __FILE__, __LINE__, __func__)\n\n#  ifdef malloc\n#    undef malloc\n#  endif\n#  define malloc(s)     wrap_malloc( (s),      __FILE__, __LINE__, __func__)\n\n#  ifdef realloc\n#    undef realloc\n#  endif\n#  define realloc(p, s) wrap_realloc((p), (s), __FILE__, __LINE__, __func__)\n\n#  ifdef strdup\n#    undef strdup\n#  endif\n#  define strdup(s)     wrap_strdup( (s),      __FILE__, __LINE__, __func__)\n\n#endif /* USE_MALLOC_WRAPPERS */\n\n#endif /* MALLOC_WRAP_H */\n"
        },
        {
          "name": "maxk.c",
          "type": "blob",
          "size": 1.611328125,
          "content": "#include <zlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n#include \"bwa.h\"\n#include \"bwamem.h\"\n#include \"kseq.h\"\nKSEQ_DECLARE(gzFile)\n\nint main_maxk(int argc, char *argv[])\n{\n\tint i, c, self = 0, max_len = 0;\n\tuint8_t *cnt = 0;\n\tuint64_t hist[256];\n\tbwt_t *bwt;\n\tkseq_t *ks;\n\tsmem_i *itr;\n\tgzFile fp;\n\n\twhile ((c = getopt(argc, argv, \"s\")) >= 0) {\n\t\tif (c == 's') self = 1;\n\t}\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"Usage: bwa maxk [-s] <index.prefix> <seq.fa>\\n\");\n\t\treturn 1;\n\t}\n\tfp = strcmp(argv[optind+1], \"-\")? gzopen(argv[optind+1], \"rb\") : gzdopen(fileno(stdin), \"rb\");\n\tks = kseq_init(fp);\n\tbwt = bwt_restore_bwt(argv[optind]);\n\titr = smem_itr_init(bwt);\n\tif (self) smem_config(itr, 2, INT_MAX, 0);\n\tmemset(hist, 0, 8 * 256);\n\n\twhile (kseq_read(ks) >= 0) {\n\t\tconst bwtintv_v *a;\n\t\tif (ks->seq.l > max_len) {\n\t\t\tmax_len = ks->seq.l;\n\t\t\tkroundup32(max_len);\n\t\t\tcnt = realloc(cnt, max_len);\n\t\t}\n\t\tmemset(cnt, 0, ks->seq.l);\n\t\tfor (i = 0; i < ks->seq.l; ++i)\n\t\t\tks->seq.s[i] = nst_nt4_table[(int)ks->seq.s[i]];\n\t\tsmem_set_query(itr, ks->seq.l, (uint8_t*)ks->seq.s);\n\t\twhile ((a = smem_next(itr)) != 0) {\n\t\t\tfor (i = 0; i < a->n; ++i) {\n\t\t\t\tbwtintv_t *p = &a->a[i];\n\t\t\t\tint j, l, start = p->info>>32, end = (uint32_t)p->info;\n\t\t\t\tl = end - start < 255? end - start : 255;\n\t\t\t\tfor (j = start; j < end; ++j)\n\t\t\t\t\tcnt[j] = cnt[j] > l? cnt[j] : l;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < ks->seq.l; ++i) ++hist[cnt[i]];\n\t}\n\tfor (i = 0; i < 256; ++i)\n\t\tprintf(\"%d\\t%lld\\n\", i, (long long)hist[i]);\n\tfree(cnt);\n\n\tsmem_itr_destroy(itr);\n\tbwt_destroy(bwt);\n\tkseq_destroy(ks);\n\tgzclose(fp);\n\treturn 0;\n}\n"
        },
        {
          "name": "neon_sse.h",
          "type": "blob",
          "size": 1.447265625,
          "content": "#ifndef NEON_SSE_H\n#define NEON_SSE_H\n\n#include <arm_neon.h>\n\ntypedef uint8x16_t __m128i;\n\nstatic inline __m128i _mm_load_si128(const __m128i *ptr) { return vld1q_u8((const uint8_t *) ptr); }\nstatic inline __m128i _mm_set1_epi32(int n) { return vreinterpretq_u8_s32(vdupq_n_s32(n)); }\nstatic inline void _mm_store_si128(__m128i *ptr, __m128i a) { vst1q_u8((uint8_t *) ptr, a); }\n\nstatic inline __m128i _mm_adds_epu8(__m128i a, __m128i b) { return vqaddq_u8(a, b); }\nstatic inline __m128i _mm_max_epu8(__m128i a, __m128i b) { return vmaxq_u8(a, b); }\nstatic inline __m128i _mm_set1_epi8(int8_t n) { return vreinterpretq_u8_s8(vdupq_n_s8(n)); }\nstatic inline __m128i _mm_subs_epu8(__m128i a, __m128i b) { return vqsubq_u8(a, b); }\n\n#define M128I(a)  vreinterpretq_u8_s16((a))\n#define UM128I(a) vreinterpretq_u8_u16((a))\n#define S16(a)    vreinterpretq_s16_u8((a))\n#define U16(a)    vreinterpretq_u16_u8((a))\n\nstatic inline __m128i _mm_adds_epi16(__m128i a, __m128i b) { return M128I(vqaddq_s16(S16(a), S16(b))); }\nstatic inline __m128i _mm_cmpgt_epi16(__m128i a, __m128i b) { return UM128I(vcgtq_s16(S16(a), S16(b))); }\nstatic inline __m128i _mm_max_epi16(__m128i a, __m128i b) { return M128I(vmaxq_s16(S16(a), S16(b))); }\nstatic inline __m128i _mm_set1_epi16(int16_t n) { return vreinterpretq_u8_s16(vdupq_n_s16(n)); }\nstatic inline __m128i _mm_subs_epu16(__m128i a, __m128i b) { return UM128I(vqsubq_u16(U16(a), U16(b))); }\n\n#undef M128I\n#undef UM128I\n#undef S16\n#undef U16\n\n#endif\n"
        },
        {
          "name": "pemerge.c",
          "type": "blob",
          "size": 8.6181640625,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <zlib.h>\n#include <pthread.h>\n#include <errno.h>\n#include \"ksw.h\"\n#include \"kseq.h\"\n#include \"kstring.h\"\n#include \"bwa.h\"\n#include \"utils.h\"\nKSEQ_DECLARE(gzFile)\n\n#ifdef USE_MALLOC_WRAPPERS\n#  include \"malloc_wrap.h\"\n#endif\n\n#define MAX_SCORE_RATIO 0.9f\n#define MAX_ERR 8\n\nstatic const char *err_msg[MAX_ERR+1] = {\n\t\"successful merges\",\n\t\"low-scoring pairs\",\n\t\"pairs where the best SW alignment is not an overlap (long left end)\",\n\t\"pairs where the best SW alignment is not an overlap (long right end)\",\n\t\"pairs with large 2nd best SW score\",\n\t\"pairs with gapped overlap\",\n\t\"pairs where the end-to-end alignment is inconsistent with SW\",\n\t\"pairs potentially with tandem overlaps\",\n\t\"pairs with high sum of errors\"\n};\n\ntypedef struct {\n\tint a, b, q, r, w;\n\tint q_def, q_thres;\n\tint T;\n\tint chunk_size;\n\tint n_threads;\n\tint flag; // bit 1: print merged; 2: print unmerged\n\tint8_t mat[25];\n} pem_opt_t;\n\npem_opt_t *pem_opt_init()\n{\n\tpem_opt_t *opt;\n\topt = calloc(1, sizeof(pem_opt_t));\n\topt->a = 5; opt->b = 4; opt->q = 2, opt->r = 17; opt->w = 20;\n\topt->T = opt->a * 10;\n\topt->q_def = 20;\n\topt->q_thres = 70;\n\topt->chunk_size = 10000000;\n\topt->n_threads = 1;\n\topt->flag = 3;\n\tbwa_fill_scmat(opt->a, opt->b, opt->mat);\n\treturn opt;\n}\n\nint bwa_pemerge(const pem_opt_t *opt, bseq1_t x[2])\n{\n\tuint8_t *s[2], *q[2], *seq, *qual;\n\tint i, xtra, l, l_seq, sum_q, ret = 0;\n\tkswr_t r;\n\n\ts[0] = malloc(x[0].l_seq); q[0] = malloc(x[0].l_seq);\n\ts[1] = malloc(x[1].l_seq); q[1] = malloc(x[1].l_seq);\n\tfor (i = 0; i < x[0].l_seq; ++i) {\n\t\tint c = x[0].seq[i];\n\t\ts[0][i] = c < 0 || c > 127? 4 : c <= 4? c : nst_nt4_table[c];\n\t\tq[0][i] = x[0].qual? x[0].qual[i] - 33 : opt->q_def;\n\t}\n\tfor (i = 0; i < x[1].l_seq; ++i) {\n\t\tint c = x[1].seq[x[1].l_seq - 1 - i];\n\t\tc = c < 0 || c > 127? 4 : c < 4? c : nst_nt4_table[c];\n\t\ts[1][i] = c < 4? 3 - c : 4;\n\t\tq[1][i] = x[1].qual? x[1].qual[x[1].l_seq - 1 - i] - 33 : opt->q_def;\n\t}\n\n\txtra = KSW_XSTART | KSW_XSUBO;\n\tr = ksw_align(x[1].l_seq, s[1], x[0].l_seq, s[0], 5, opt->mat, opt->q, opt->r, xtra, 0);\n\t++r.qe; ++r.te; // change to the half-close-half-open coordinates\n\n\tif (r.score < opt->T) { ret = -1; goto pem_ret; } // poor alignment\n\tif (r.tb < r.qb) { ret = -2; goto pem_ret; } // no enough space for the left end\n\tif (x[0].l_seq - r.te > x[1].l_seq - r.qe) { ret = -3; goto pem_ret; } // no enough space for the right end\n\tif ((double)r.score2 / r.score >= MAX_SCORE_RATIO) { ret = -4; goto pem_ret; } // the second best score is too large\n\tif (r.qe - r.qb != r.te - r.tb) { ret = -5; goto pem_ret; } // we do not allow gaps\n\n\t{ // test tandem match; O(n^2)\n\t\tint max_m, max_m2, min_l, max_l, max_l2;\n\t\tmax_m = max_m2 = 0; max_l = max_l2 = 0;\n\t\tmin_l = x[0].l_seq < x[1].l_seq? x[0].l_seq : x[1].l_seq;\n\t\tfor (l = 1; l < min_l; ++l) {\n\t\t\tint m = 0, o = x[0].l_seq - l;\n\t\t\tuint8_t *s0o = &s[0][o], *s1 = s[1];\n\t\t\tfor (i = 0; i < l; ++i) // TODO: in principle, this can be done with SSE2. It is the bottleneck!\n\t\t\t\tm += opt->mat[(s1[i]<<2) + s1[i] + s0o[i]]; // equivalent to s[1][i]*5 + s[0][o+i]\n\t\t\tif (m > max_m) max_m2 = max_m, max_m = m, max_l2 = max_l, max_l = l;\n\t\t\telse if (m > max_m2) max_m2 = m, max_l2 = l;\n\t\t}\n\t\tif (max_m < opt->T || max_l != x[0].l_seq - (r.tb - r.qb)) { ret = -6; goto pem_ret; }\n\t\tif (max_l2 < max_l && max_m2 >= opt->T && (double)(max_m2 + (max_l - max_l2) * opt->a) / max_m >= MAX_SCORE_RATIO) {\n\t\t\tret = -7; goto pem_ret;\n\t\t}\n\t\tif (max_l2 > max_l && (double)max_m2 / max_m >= MAX_SCORE_RATIO) { ret = -7; goto pem_ret; }\n\t}\n\n\tl = x[0].l_seq - (r.tb - r.qb); // length to merge\n\tl_seq = x[0].l_seq + x[1].l_seq - l;\n\tseq = malloc(l_seq + 1);\n\tqual = malloc(l_seq + 1);\n\tmemcpy(seq,  s[0], x[0].l_seq); memcpy(seq  + x[0].l_seq, &s[1][l], x[1].l_seq - l);\n\tmemcpy(qual, q[0], x[0].l_seq); memcpy(qual + x[0].l_seq, &q[1][l], x[1].l_seq - l);\n\tfor (i = 0, sum_q = 0; i < l; ++i) {\n\t\tint k = x[0].l_seq - l + i;\n\t\tif (s[0][k] == 4) { // ambiguous\n\t\t\tseq[k]  = s[1][i];\n\t\t\tqual[k] = q[1][i];\n\t\t} else if (s[1][i] == 4) { // do nothing\n\t\t} else if (s[0][k] == s[1][i]) {\n\t\t\tqual[k] = qual[k] > q[1][i]? qual[k] : q[1][i];\n\t\t} else { // s[0][k] != s[1][i] and neither is N\n\t\t\tint qq = q[0][k] < q[1][i]? q[0][k] : q[1][i];\n\t\t\tsum_q += qq >= 3? qq<<1 : 1;\n\t\t\tseq[k]  = q[0][k] > q[1][i]? s[0][k] : s[1][i];\n\t\t\tqual[k] = abs((int)q[0][k] - (int)q[1][i]);\n\t\t}\n\t}\n\tif (sum_q>>1 > opt->q_thres) { // too many mismatches\n\t\tfree(seq); free(qual);\n\t\tret = -8; goto pem_ret;\n\t}\n\n\tfor (i = 0; i < l_seq; ++i) seq[i] = \"ACGTN\"[(int)seq[i]], qual[i] += 33;\n\tseq[l_seq] = qual[l_seq] = 0;\n\n\tfree(x[1].name); free(x[1].seq); free(x[1].qual); free(x[1].comment);\n\tmemset(&x[1], 0, sizeof(bseq1_t));\n\tfree(x[0].seq); free(x[0].qual);\n\tx[0].l_seq = l_seq; x[0].seq = (char*)seq; x[0].qual = (char*)qual;\n\npem_ret:\n\tfree(s[0]); free(s[1]); free(q[0]); free(q[1]);\n\treturn ret;\n}\n\nstatic inline void print_bseq(const bseq1_t *s, int rn)\n{\n\terr_putchar(s->qual? '@' : '>');\n\terr_fputs(s->name, stdout);\n\tif (rn == 1 || rn == 2) {\n\t\terr_putchar('/'); err_putchar('0' + rn); err_putchar('\\n');\n\t} else err_puts(\" merged\");\n\terr_puts(s->seq);\n\tif (s->qual) {\n\t\terr_puts(\"+\"); err_puts(s->qual);\n\t}\n}\n\ntypedef struct {\n\tint n, start;\n\tbseq1_t *seqs;\n\tint64_t cnt[MAX_ERR+1];\n\tconst pem_opt_t *opt;\n} worker_t;\n\nvoid *worker(void *data)\n{\n\tworker_t *w = (worker_t*)data;\n\tint i;\n\tfor (i = w->start; i < w->n>>1; i += w->opt->n_threads)\n\t\t++w->cnt[-bwa_pemerge(w->opt, &w->seqs[i<<1])];\n\treturn 0;\n}\n\nstatic void process_seqs(const pem_opt_t *opt, int n_, bseq1_t *seqs, int64_t cnt[MAX_ERR+1])\n{\n\tint i, j, n = n_>>1<<1;\n\tworker_t *w;\n\n\tw = calloc(opt->n_threads, sizeof(worker_t));\n\tfor (i = 0; i < opt->n_threads; ++i) {\n\t\tworker_t *p = &w[i];\n\t\tp->start = i; p->n = n;\n\t\tp->opt = opt;\n\t\tp->seqs = seqs;\n\t}\n\tif (opt->n_threads == 1) {\n\t\tworker(w);\n\t} else {\n\t\tpthread_t *tid;\n\t\ttid = (pthread_t*)calloc(opt->n_threads, sizeof(pthread_t));\n\t\tfor (i = 0; i < opt->n_threads; ++i) pthread_create(&tid[i], 0, worker, &w[i]);\n\t\tfor (i = 0; i < opt->n_threads; ++i) pthread_join(tid[i], 0);\n\t\tfree(tid);\n\t}\n\tfor (i = 0; i < opt->n_threads; ++i) {\n\t\tworker_t *p = &w[i];\n\t\tfor (j = 0; j <= MAX_ERR; ++j) cnt[j] += p->cnt[j];\n\t}\n\tfree(w);\n\tfor (i = 0; i < n>>1; ++i) {\n\t\tif (seqs[i<<1|1].l_seq != 0) {\n\t\t\tif (opt->flag&2) {\n\t\t\t\tprint_bseq(&seqs[i<<1|0], 1);\n\t\t\t\tprint_bseq(&seqs[i<<1|1], 2);\n\t\t\t}\n\t\t} else if (opt->flag&1)\n\t\t\tprint_bseq(&seqs[i<<1|0], 0);\n\t}\n\tfor (i = 0; i < n; ++i) {\n\t\tbseq1_t *s = &seqs[i];\n\t\tfree(s->name); free(s->seq); free(s->qual); free(s->comment);\n\t}\n}\n\nint main_pemerge(int argc, char *argv[])\n{\n\tint c, flag = 0, i, n, min_ovlp = 10;\n\tint64_t cnt[MAX_ERR+1];\n\tbseq1_t *bseq;\n\tgzFile fp, fp2 = 0;\n\tkseq_t *ks, *ks2 = 0;\n\tpem_opt_t *opt;\n\n\topt = pem_opt_init();\n\twhile ((c = getopt(argc, argv, \"muQ:t:T:\")) >= 0) {\n\t\tif (c == 'm') flag |= 1;\n\t\telse if (c == 'u') flag |= 2;\n\t\telse if (c == 'Q') opt->q_thres = atoi(optarg);\n\t\telse if (c == 't') opt->n_threads = atoi(optarg);\n\t\telse if (c == 'T') min_ovlp = atoi(optarg);\n\t\telse return 1;\n\t}\n\tif (flag == 0) flag = 3;\n\topt->flag = flag;\n\topt->T = opt->a * min_ovlp;\n\n\tif (optind == argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa pemerge [-mu] <read1.fq> [read2.fq]\\n\\n\");\n\t\tfprintf(stderr, \"Options: -m       output merged reads only\\n\");\n\t\tfprintf(stderr, \"         -u       output unmerged reads only\\n\");\n\t\tfprintf(stderr, \"         -t INT   number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -T INT   minimum end overlap [%d]\\n\", min_ovlp);\n\t\tfprintf(stderr, \"         -Q INT   max sum of errors [%d]\\n\", opt->q_thres);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\n\tfp = strcmp(argv[optind], \"-\")? gzopen(argv[optind], \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (NULL == fp) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\tstrcmp(argv[optind], \"-\") ? argv[optind] : \"stdin\",\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tks = kseq_init(fp);\n\tif (optind + 1 < argc) {\n\t\tfp2 = strcmp(argv[optind+1], \"-\")? gzopen(argv[optind+1], \"r\") : gzdopen(fileno(stdin), \"r\");\n\t\tif (NULL == fp) {\n\t\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\t\tstrcmp(argv[optind+1], \"-\") ? argv[optind+1] : \"stdin\",\n\t\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tks2 = kseq_init(fp2);\n\t}\n\n\tmemset(cnt, 0, 8 * (MAX_ERR+1));\n\twhile ((bseq = bseq_read(opt->n_threads * opt->chunk_size, &n, ks, ks2)) != 0) {\n\t\tprocess_seqs(opt, n, bseq, cnt);\n\t\tfree(bseq);\n\t}\n\n\tfprintf(stderr, \"%12ld %s\\n\", (long)cnt[0], err_msg[0]);\n\tfor (i = 1; i <= MAX_ERR; ++i)\n\t\tfprintf(stderr, \"%12ld %s\\n\", (long)cnt[i], err_msg[i]);\n\tkseq_destroy(ks);\n\terr_gzclose(fp);\n\tif (ks2) {\n\t\tkseq_destroy(ks2);\n\t\terr_gzclose(fp2);\n\t}\n\tfree(opt);\n\n\terr_fflush(stdout);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "qualfa2fq.pl",
          "type": "blob",
          "size": 0.6025390625,
          "content": "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\n\ndie(\"Usage: qualfa2fq.pl <in.fasta> <in.qual>\\n\") if (@ARGV != 2);\n\nmy ($fhs, $fhq, $q);\nopen($fhs, ($ARGV[0] =~ /\\.gz$/)? \"gzip -dc $ARGV[0] |\" : $ARGV[0]) || die;\nopen($fhq, ($ARGV[1] =~ /\\.gz$/)? \"gzip -dc $ARGV[1] |\" : $ARGV[1]) || die;\n\n$/ = \">\"; <$fhs>; <$fhq>; $/ = \"\\n\";\nwhile (<$fhs>) {\n  $q = <$fhq>;\n  print \"\\@$_\";\n  $/ = \">\";\n  $_ = <$fhs>; $q = <$fhq>;\n  chomp; chomp($q);\n  $q =~ s/\\s*(\\d+)\\s*/chr($1+33)/eg;\n  print $_, \"+\\n\";\n  for (my $i = 0; $i < length($q); $i += 60) {\n\tprint substr($q, $i, 60), \"\\n\";\n  }\n  $/ = \"\\n\";\n}\n\nclose($fhs); close($fhq);\n"
        },
        {
          "name": "rle.c",
          "type": "blob",
          "size": 4.7080078125,
          "content": "#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"rle.h\"\n\nconst uint8_t rle_auxtab[8] = { 0x01, 0x11, 0x21, 0x31, 0x03, 0x13, 0x07, 0x17 };\n\n// insert symbol $a after $x symbols in $str; marginal counts added to $cnt; returns the size increase\nint rle_insert_cached(uint8_t *block, int64_t x, int a, int64_t rl, int64_t cnt[6], const int64_t ec[6], int *beg, int64_t bc[6])\n{\n\tuint16_t *nptr = (uint16_t*)block;\n\tint diff;\n\n\tblock += 2; // skip the first 2 counting bytes\n\tif (*nptr == 0) {\n\t\tmemset(cnt, 0, 48);\n\t\tdiff = rle_enc1(block, a, rl);\n\t} else {\n\t\tuint8_t *p, *end = block + *nptr, *q;\n\t\tint64_t pre, z, l = 0, tot, beg_l;\n\t\tint c = -1, n_bytes = 0, n_bytes2, t = 0;\n\t\tuint8_t tmp[24];\n\t\tbeg_l = bc[0] + bc[1] + bc[2] + bc[3] + bc[4] + bc[5];\n\t\ttot   = ec[0] + ec[1] + ec[2] + ec[3] + ec[4] + ec[5];\n\t\tif (x < beg_l) {\n\t\t\tbeg_l = 0, *beg = 0;\n\t\t\tmemset(bc, 0, 48);\n\t\t}\n\t\tif (x == beg_l) {\n\t\t\tp = q = block + (*beg); z = beg_l;\n\t\t\tmemcpy(cnt, bc, 48);\n\t\t} else if (x - beg_l <= ((tot-beg_l)>>1) + ((tot-beg_l)>>3)) { // forward\n\t\t\tz = beg_l; p = block + (*beg);\n\t\t\tmemcpy(cnt, bc, 48);\n\t\t\twhile (z < x) {\n\t\t\t\trle_dec1(p, c, l);\n\t\t\t\tz += l; cnt[c] += l;\n\t\t\t}\n\t\t\tfor (q = p - 1; *q>>6 == 2; --q);\n\t\t} else { // backward\n\t\t\tmemcpy(cnt, ec, 48);\n\t\t\tz = tot; p = end;\n\t\t\twhile (z >= x) {\n\t\t\t\t--p;\n\t\t\t\tif (*p>>6 != 2) {\n\t\t\t\t\tl |= *p>>7? (int64_t)rle_auxtab[*p>>3&7]>>4 << t : *p>>3;\n\t\t\t\t\tz -= l; cnt[*p&7] -= l;\n\t\t\t\t\tl = 0; t = 0;\n\t\t\t\t} else {\n\t\t\t\t\tl |= (*p&0x3fL) << t;\n\t\t\t\t\tt += 6;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = p;\n\t\t\trle_dec1(p, c, l);\n\t\t\tz += l; cnt[c] += l;\n\t\t}\n\t\t*beg = q - block;\n\t\tmemcpy(bc, cnt, 48);\n\t\tbc[c] -= l;\n\t\tn_bytes = p - q;\n\t\tif (x == z && a != c && p < end) { // then try the next run\n\t\t\tint tc;\n\t\t\tint64_t tl;\n\t\t\tq = p;\n\t\t\trle_dec1(q, tc, tl);\n\t\t\tif (a == tc)\n\t\t\t\tc = tc, n_bytes = q - p, l = tl, z += l, p = q, cnt[tc] += tl;\n\t\t}\n\t\tif (z != x) cnt[c] -= z - x;\n\t\tpre = x - (z - l); p -= n_bytes;\n\t\tif (a == c) { // insert to the same run\n\t\t\tn_bytes2 = rle_enc1(tmp, c, l + rl);\n\t\t} else if (x == z) { // at the end; append to the existing run\n\t\t\tp += n_bytes; n_bytes = 0;\n\t\t\tn_bytes2 = rle_enc1(tmp, a, rl);\n\t\t} else { // break the current run\n\t\t\tn_bytes2 = rle_enc1(tmp, c, pre);\n\t\t\tn_bytes2 += rle_enc1(tmp + n_bytes2, a, rl);\n\t\t\tn_bytes2 += rle_enc1(tmp + n_bytes2, c, l - pre);\n\t\t}\n\t\tif (n_bytes != n_bytes2 && end != p + n_bytes) // size changed\n\t\t\tmemmove(p + n_bytes2, p + n_bytes, end - p - n_bytes);\n\t\tmemcpy(p, tmp, n_bytes2);\n\t\tdiff = n_bytes2 - n_bytes;\n\t}\n\treturn (*nptr += diff);\n}\n\nint rle_insert(uint8_t *block, int64_t x, int a, int64_t rl, int64_t cnt[6], const int64_t ec[6])\n{\n\tint beg = 0;\n\tint64_t bc[6];\n\tmemset(bc, 0, 48);\n\treturn rle_insert_cached(block, x, a, rl, cnt, ec, &beg, bc);\n}\n\nvoid rle_split(uint8_t *block, uint8_t *new_block)\n{\n\tint n = *(uint16_t*)block;\n\tuint8_t *end = block + 2 + n, *q = block + 2 + (n>>1);\n\twhile (*q>>6 == 2) --q;\n\tmemcpy(new_block + 2, q, end - q);\n\t*(uint16_t*)new_block = end - q;\n\t*(uint16_t*)block = q - block - 2;\n}\n\nvoid rle_count(const uint8_t *block, int64_t cnt[6])\n{\n\tconst uint8_t *q = block + 2, *end = q + *(uint16_t*)block;\n\twhile (q < end) {\n\t\tint c;\n\t\tint64_t l;\n\t\trle_dec1(q, c, l);\n\t\tcnt[c] += l;\n\t}\n}\n\nvoid rle_print(const uint8_t *block, int expand)\n{\n\tconst uint16_t *p = (const uint16_t*)block;\n\tconst uint8_t *q = block + 2, *end = block + 2 + *p;\n\twhile (q < end) {\n\t\tint c;\n\t\tint64_t l, x;\n\t\trle_dec1(q, c, l);\n\t\tif (expand) for (x = 0; x < l; ++x) putchar(\"$ACGTN\"[c]);\n\t\telse printf(\"%c%ld\", \"$ACGTN\"[c], (long)l);\n\t}\n\tputchar('\\n');\n}\n\nvoid rle_rank2a(const uint8_t *block, int64_t x, int64_t y, int64_t *cx, int64_t *cy, const int64_t ec[6])\n{\n\tint a;\n\tint64_t tot, cnt[6];\n\tconst uint8_t *p;\n\n\ty = y >= x? y : x;\n\ttot = ec[0] + ec[1] + ec[2] + ec[3] + ec[4] + ec[5];\n\tif (tot == 0) return;\n\tif (x <= (tot - y) + (tot>>3)) {\n\t\tint c = 0;\n\t\tint64_t l, z = 0;\n\t\tmemset(cnt, 0, 48);\n\t\tp = block + 2;\n\t\twhile (z < x) {\n\t\t\trle_dec1(p, c, l);\n\t\t\tz += l; cnt[c] += l;\n\t\t}\n\t\tfor (a = 0; a != 6; ++a) cx[a] += cnt[a];\n\t\tcx[c] -= z - x;\n\t\tif (cy) {\n\t\t\twhile (z < y) {\n\t\t\t\trle_dec1(p, c, l);\n\t\t\t\tz += l; cnt[c] += l;\n\t\t\t}\n\t\t\tfor (a = 0; a != 6; ++a) cy[a] += cnt[a];\n\t\t\tcy[c] -= z - y;\n\t\t}\n\t} else {\n#define move_backward(_x) \\\n\t\twhile (z >= (_x)) { \\\n\t\t\t--p; \\\n\t\t\tif (*p>>6 != 2) { \\\n\t\t\t\tl |= *p>>7? (int64_t)rle_auxtab[*p>>3&7]>>4 << t : *p>>3; \\\n\t\t\t\tz -= l; cnt[*p&7] -= l; \\\n\t\t\t\tl = 0; t = 0; \\\n\t\t\t} else { \\\n\t\t\t\tl |= (*p&0x3fL) << t; \\\n\t\t\t\tt += 6; \\\n\t\t\t} \\\n\t\t} \\\n\n\t\tint t = 0;\n\t\tint64_t l = 0, z = tot;\n\t\tmemcpy(cnt, ec, 48);\n\t\tp = block + 2 + *(const uint16_t*)block;\n\t\tif (cy) {\n\t\t\tmove_backward(y)\n\t\t\tfor (a = 0; a != 6; ++a) cy[a] += cnt[a];\n\t\t\tcy[*p&7] += y - z;\n\t\t}\n\t\tmove_backward(x)\n\t\tfor (a = 0; a != 6; ++a) cx[a] += cnt[a];\n\t\tcx[*p&7] += x - z;\n\n#undef move_backward\n\t}\n}\n"
        },
        {
          "name": "rle.h",
          "type": "blob",
          "size": 1.865234375,
          "content": "#ifndef RLE6_H_\n#define RLE6_H_\n\n#include <stdint.h>\n\n#ifdef __GNUC__\n#define LIKELY(x) __builtin_expect((x),1)\n#else\n#define LIKELY(x) (x)\n#endif\n#ifdef __cplusplus\n\nextern \"C\" {\n#endif\n\n\tint rle_insert_cached(uint8_t *block, int64_t x, int a, int64_t rl, int64_t cnt[6], const int64_t ec[6], int *beg, int64_t bc[6]);\n\tint rle_insert(uint8_t *block, int64_t x, int a, int64_t rl, int64_t cnt[6], const int64_t end_cnt[6]);\n\tvoid rle_split(uint8_t *block, uint8_t *new_block);\n\tvoid rle_count(const uint8_t *block, int64_t cnt[6]);\n\tvoid rle_rank2a(const uint8_t *block, int64_t x, int64_t y, int64_t *cx, int64_t *cy, const int64_t ec[6]);\n\t#define rle_rank1a(block, x, cx, ec) rle_rank2a(block, x, -1, cx, 0, ec)\n\n\tvoid rle_print(const uint8_t *block, int expand);\n\n#ifdef __cplusplus\n}\n#endif\n\n/******************\n *** 43+3 codec ***\n ******************/\n\nextern const uint8_t rle_auxtab[8];\n\n#define RLE_MIN_SPACE 18\n#define rle_nptr(block) ((uint16_t*)(block))\n\n// decode one run (c,l) and move the pointer p\n#define rle_dec1(p, c, l) do { \\\n\t\t(c) = *(p) & 7; \\\n\t\tif (LIKELY((*(p)&0x80) == 0)) { \\\n\t\t\t(l) = *(p)++ >> 3; \\\n\t\t} else if (LIKELY(*(p)>>5 == 6)) { \\\n\t\t\t(l) = (*(p)&0x18L)<<3L | ((p)[1]&0x3fL); \\\n\t\t\t(p) += 2; \\\n\t\t} else { \\\n\t\t\tint n = ((*(p)&0x10) >> 2) + 4; \\\n\t\t\t(l) = *(p)++ >> 3 & 1; \\\n\t\t\twhile (--n) (l) = ((l)<<6) | (*(p)++&0x3fL); \\\n\t\t} \\\n\t} while (0)\n\nstatic inline int rle_enc1(uint8_t *p, int c, int64_t l)\n{\n\tif (l < 1LL<<4) {\n\t\t*p = l << 3 | c;\n\t\treturn 1;\n\t} else if (l < 1LL<<8) {\n\t\t*p = 0xC0 | l >> 6 << 3 | c;\n\t\tp[1] = 0x80 | (l & 0x3f);\n\t\treturn 2;\n\t} else if (l < 1LL<<19) {\n\t\t*p = 0xE0 | l >> 18 << 3 | c;\n\t\tp[1] = 0x80 | (l >> 12 & 0x3f);\n\t\tp[2] = 0x80 | (l >> 6 & 0x3f);\n\t\tp[3] = 0x80 | (l & 0x3f);\n\t\treturn 4;\n\t} else {\n\t\tint i, shift = 36;\n\t\t*p = 0xF0 | l >> 42 << 3 | c;\n\t\tfor (i = 1; i < 8; ++i, shift -= 6)\n\t\t\tp[i] = 0x80 | (l>>shift & 0x3f);\n\t\treturn 8;\n\t}\n}\n\n#endif\n"
        },
        {
          "name": "rope.c",
          "type": "blob",
          "size": 8.8076171875,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <zlib.h>\n#include \"rle.h\"\n#include \"rope.h\"\n\n/*******************\n *** Memory Pool ***\n *******************/\n\n#define MP_CHUNK_SIZE 0x100000 // 1MB per chunk\n\ntypedef struct { // memory pool for fast and compact memory allocation (no free)\n\tint size, i, n_elems;\n\tint64_t top, max;\n\tuint8_t **mem;\n} mempool_t;\n\nstatic mempool_t *mp_init(int size)\n{\n\tmempool_t *mp;\n\tmp = calloc(1, sizeof(mempool_t));\n\tmp->size = size;\n\tmp->i = mp->n_elems = MP_CHUNK_SIZE / size;\n\tmp->top = -1;\n\treturn mp;\n}\n\nstatic void mp_destroy(mempool_t *mp)\n{\n\tint64_t i;\n\tfor (i = 0; i <= mp->top; ++i) free(mp->mem[i]);\n\tfree(mp->mem); free(mp);\n}\n\nstatic inline void *mp_alloc(mempool_t *mp)\n{\n\tif (mp->i == mp->n_elems) {\n\t\tif (++mp->top == mp->max) {\n\t\t\tmp->max = mp->max? mp->max<<1 : 1;\n\t\t\tmp->mem = realloc(mp->mem, sizeof(void*) * mp->max);\n\t\t}\n\t\tmp->mem[mp->top] = calloc(mp->n_elems, mp->size);\n\t\tmp->i = 0;\n\t}\n\treturn mp->mem[mp->top] + (mp->i++) * mp->size;\n}\n\n/***************\n *** B+ rope ***\n ***************/\n\nrope_t *rope_init(int max_nodes, int block_len)\n{\n\trope_t *rope;\n\trope = calloc(1, sizeof(rope_t));\n\tif (block_len < 32) block_len = 32;\n\trope->max_nodes = (max_nodes+ 1)>>1<<1;\n\trope->block_len = (block_len + 7) >> 3 << 3;\n\trope->node = mp_init(sizeof(rpnode_t) * rope->max_nodes);\n\trope->leaf = mp_init(rope->block_len);\n\trope->root = mp_alloc(rope->node);\n\trope->root->n = 1;\n\trope->root->is_bottom = 1;\n\trope->root->p = mp_alloc(rope->leaf);\n\treturn rope;\n}\n\nvoid rope_destroy(rope_t *rope)\n{\n\tmp_destroy(rope->node);\n\tmp_destroy(rope->leaf);\n\tfree(rope);\n}\n\nstatic inline rpnode_t *split_node(rope_t *rope, rpnode_t *u, rpnode_t *v)\n{ // split $v's child. $u is the first node in the bucket. $v and $u are in the same bucket. IMPORTANT: there is always enough room in $u\n\tint j, i = v - u;\n\trpnode_t *w; // $w is the sibling of $v\n\tif (u == 0) { // only happens at the root; add a new root\n\t\tu = v = mp_alloc(rope->node);\n\t\tv->n = 1; v->p = rope->root; // the new root has the old root as the only child\n\t\tmemcpy(v->c, rope->c, 48);\n\t\tfor (j = 0; j < 6; ++j) v->l += v->c[j];\n\t\trope->root = v;\n\t}\n\tif (i != u->n - 1) // then make room for a new node\n\t\tmemmove(v + 2, v + 1, sizeof(rpnode_t) * (u->n - i - 1));\n\t++u->n; w = v + 1;\n\tmemset(w, 0, sizeof(rpnode_t));\n\tw->p = mp_alloc(u->is_bottom? rope->leaf : rope->node);\n\tif (u->is_bottom) { // we are at the bottom level; $v->p is a string instead of a node\n\t\tuint8_t *p = (uint8_t*)v->p, *q = (uint8_t*)w->p;\n\t\trle_split(p, q);\n\t\trle_count(q, w->c);\n\t} else { // $v->p is a node, not a string\n\t\trpnode_t *p = v->p, *q = w->p; // $v and $w are siblings and thus $p and $q are cousins\n\t\tp->n -= rope->max_nodes>>1;\n\t\tmemcpy(q, p + p->n, sizeof(rpnode_t) * (rope->max_nodes>>1));\n\t\tq->n = rope->max_nodes>>1; // NB: this line must below memcpy() as $q->n and $q->is_bottom are modified by memcpy()\n\t\tq->is_bottom = p->is_bottom;\n\t\tfor (i = 0; i < q->n; ++i)\n\t\t\tfor (j = 0; j < 6; ++j)\n\t\t\t\tw->c[j] += q[i].c[j];\n\t}\n\tfor (j = 0; j < 6; ++j) // compute $w->l and update $v->c\n\t\tw->l += w->c[j], v->c[j] -= w->c[j];\n\tv->l -= w->l; // update $v->c\n\treturn v;\n}\n\nint64_t rope_insert_run(rope_t *rope, int64_t x, int a, int64_t rl, rpcache_t *cache)\n{ // insert $a after $x symbols in $rope and the returns rank(a, x)\n\trpnode_t *u = 0, *v = 0, *p = rope->root; // $v is the parent of $p; $u and $v are at the same level and $u is the first node in the bucket\n\tint64_t y = 0, z = 0, cnt[6];\n\tint n_runs;\n\tdo { // top-down update. Searching and node splitting are done together in one pass.\n\t\tif (p->n == rope->max_nodes) { // node is full; split\n\t\t\tv = split_node(rope, u, v); // $v points to the parent of $p; when a new root is added, $v points to the root\n\t\t\tif (y + v->l < x) // if $v is not long enough after the split, we need to move both $p and its parent $v\n\t\t\t\ty += v->l, z += v->c[a], ++v, p = v->p;\n\t\t}\n\t\tu = p;\n\t\tif (v && x - y > v->l>>1) { // then search backwardly for the right node to descend\n\t\t\tp += p->n - 1; y += v->l; z += v->c[a];\n\t\t\tfor (; y >= x; --p) y -= p->l, z -= p->c[a];\n\t\t\t++p;\n\t\t} else for (; y + p->l < x; ++p) y += p->l, z += p->c[a]; // then search forwardly\n\t\tassert(p - u < u->n);\n\t\tif (v) v->c[a] += rl, v->l += rl; // we should not change p->c[a] because this may cause troubles when p's child is split\n\t\tv = p; p = p->p; // descend\n\t} while (!u->is_bottom);\n\trope->c[a] += rl; // $rope->c should be updated after the loop as adding a new root needs the old $rope->c counts\n\tif (cache) {\n\t\tif (cache->p != (uint8_t*)p) memset(cache, 0, sizeof(rpcache_t));\n\t\tn_runs = rle_insert_cached((uint8_t*)p, x - y, a, rl, cnt, v->c, &cache->beg, cache->bc);\n\t\tcache->p = (uint8_t*)p;\n\t} else n_runs = rle_insert((uint8_t*)p, x - y, a, rl, cnt, v->c);\n\tz += cnt[a];\n\tv->c[a] += rl; v->l += rl; // this should be after rle_insert(); otherwise rle_insert() won't work\n\tif (n_runs + RLE_MIN_SPACE > rope->block_len) {\n\t\tsplit_node(rope, u, v);\n\t\tif (cache) memset(cache, 0, sizeof(rpcache_t));\n\t}\n\treturn z;\n}\n\nstatic rpnode_t *rope_count_to_leaf(const rope_t *rope, int64_t x, int64_t cx[6], int64_t *rest)\n{\n\trpnode_t *u, *v = 0, *p = rope->root;\n\tint64_t y = 0;\n\tint a;\n\n\tmemset(cx, 0, 48);\n\tdo {\n\t\tu = p;\n\t\tif (v && x - y > v->l>>1) {\n\t\t\tp += p->n - 1; y += v->l;\n\t\t\tfor (a = 0; a != 6; ++a) cx[a] += v->c[a];\n\t\t\tfor (; y >= x; --p) {\n\t\t\t\ty -= p->l;\n\t\t\t\tfor (a = 0; a != 6; ++a) cx[a] -= p->c[a];\n\t\t\t}\n\t\t\t++p;\n\t\t} else {\n\t\t\tfor (; y + p->l < x; ++p) {\n\t\t\t\ty += p->l;\n\t\t\t\tfor (a = 0; a != 6; ++a) cx[a] += p->c[a];\n\t\t\t}\n\t\t}\n\t\tv = p; p = p->p;\n\t} while (!u->is_bottom);\n\t*rest = x - y;\n\treturn v;\n}\n\nvoid rope_rank2a(const rope_t *rope, int64_t x, int64_t y, int64_t *cx, int64_t *cy)\n{\n\trpnode_t *v;\n\tint64_t rest;\n\tv = rope_count_to_leaf(rope, x, cx, &rest);\n\tif (y < x || cy == 0) {\n\t\trle_rank1a((const uint8_t*)v->p, rest, cx, v->c);\n\t} else if (rest + (y - x) <= v->l) {\n\t\tmemcpy(cy, cx, 48);\n\t\trle_rank2a((const uint8_t*)v->p, rest, rest + (y - x), cx, cy, v->c);\n\t} else {\n\t\trle_rank1a((const uint8_t*)v->p, rest, cx, v->c);\n\t\tv = rope_count_to_leaf(rope, y, cy, &rest);\n\t\trle_rank1a((const uint8_t*)v->p, rest, cy, v->c);\n\t}\n}\n\n/*********************\n *** Rope iterator ***\n *********************/\n\nvoid rope_itr_first(const rope_t *rope, rpitr_t *i)\n{\n\tmemset(i, 0, sizeof(rpitr_t));\n\ti->rope = rope;\n\tfor (i->pa[i->d] = rope->root; !i->pa[i->d]->is_bottom;) // descend to the leftmost leaf\n\t\t++i->d, i->pa[i->d] = i->pa[i->d - 1]->p;\n}\n\nconst uint8_t *rope_itr_next_block(rpitr_t *i)\n{\n\tconst uint8_t *ret;\n\tassert(i->d < ROPE_MAX_DEPTH); // a B+ tree should not be that tall\n\tif (i->d < 0) return 0;\n\tret = (uint8_t*)i->pa[i->d][i->ia[i->d]].p;\n\twhile (i->d >= 0 && ++i->ia[i->d] == i->pa[i->d]->n) i->ia[i->d--] = 0; // backtracking\n\tif (i->d >= 0)\n\t\twhile (!i->pa[i->d]->is_bottom) // descend to the leftmost leaf\n\t\t\t++i->d, i->pa[i->d] = i->pa[i->d - 1][i->ia[i->d - 1]].p;\n\treturn ret;\n}\n\n/***********\n *** I/O ***\n ***********/\n\nvoid rope_print_node(const rpnode_t *p)\n{\n\tif (p->is_bottom) {\n\t\tint i;\n\t\tputchar('(');\n\t\tfor (i = 0; i < p->n; ++i) {\n\t\t\tuint8_t *block = (uint8_t*)p[i].p;\n\t\t\tconst uint8_t *q = block + 2, *end = block + 2 + *rle_nptr(block);\n\t\t\tif (i) putchar(',');\n\t\t\twhile (q < end) {\n\t\t\t\tint c = 0;\n\t\t\t\tint64_t j, l;\n\t\t\t\trle_dec1(q, c, l);\n\t\t\t\tfor (j = 0; j < l; ++j) putchar(\"$ACGTN\"[c]);\n\t\t\t}\n\t\t}\n\t\tputchar(')');\n\t} else {\n\t\tint i;\n\t\tputchar('(');\n\t\tfor (i = 0; i < p->n; ++i) {\n\t\t\tif (i) putchar(',');\n\t\t\trope_print_node(p[i].p);\n\t\t}\n\t\tputchar(')');\n\t}\n}\n\nvoid rope_dump_node(const rpnode_t *p, FILE *fp)\n{\n\tint16_t i, n = p->n;\n\tuint8_t is_bottom = p->is_bottom;\n\tfwrite(&is_bottom, 1, 1, fp);\n\tfwrite(&n, 2, 1, fp);\n\tif (is_bottom) {\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfwrite(p[i].c, 8, 6, fp);\n\t\t\tfwrite(p[i].p, 1, *rle_nptr(p[i].p) + 2, fp);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < p->n; ++i)\n\t\t\trope_dump_node(p[i].p, fp);\n\t}\n}\n\nvoid rope_dump(const rope_t *r, FILE *fp)\n{\n\tfwrite(&r->max_nodes, 4, 1, fp);\n\tfwrite(&r->block_len, 4, 1, fp);\n\trope_dump_node(r->root, fp);\n}\n\nrpnode_t *rope_restore_node(const rope_t *r, FILE *fp, int64_t c[6])\n{\n\tuint8_t is_bottom, a;\n\tint16_t i, n;\n\trpnode_t *p;\n\tfread(&is_bottom, 1, 1, fp);\n\tfread(&n, 2, 1, fp);\n\tp = mp_alloc(r->node);\n\tp->is_bottom = is_bottom, p->n = n;\n\tif (is_bottom) {\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tuint16_t *q;\n\t\t\tp[i].p = mp_alloc(r->leaf);\n\t\t\tq = rle_nptr(p[i].p);\n\t\t\tfread(p[i].c, 8, 6, fp);\n\t\t\tfread(q, 2, 1, fp);\n\t\t\tfread(q + 1, 1, *q, fp);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tp[i].p = rope_restore_node(r, fp, p[i].c);\n\t}\n\tmemset(c, 0, 48);\n\tfor (i = 0; i < n; ++i) {\n\t\tp[i].l = 0;\n\t\tfor (a = 0; a < 6; ++a)\n\t\t\tc[a] += p[i].c[a], p[i].l += p[i].c[a];\n\t}\n\treturn p;\n}\n\nrope_t *rope_restore(FILE *fp)\n{\n\trope_t *r;\n\tr = calloc(1, sizeof(rope_t));\n\tfread(&r->max_nodes, 4, 1, fp);\n\tfread(&r->block_len, 4, 1, fp);\n\tr->node = mp_init(sizeof(rpnode_t) * r->max_nodes);\n\tr->leaf = mp_init(r->block_len);\n\tr->root = rope_restore_node(r, fp, r->c);\n\treturn r;\n}\n"
        },
        {
          "name": "rope.h",
          "type": "blob",
          "size": 1.51171875,
          "content": "#ifndef ROPE_H_\n#define ROPE_H_\n\n#include <stdint.h>\n#include <stdio.h>\n\n#define ROPE_MAX_DEPTH 80\n#define ROPE_DEF_MAX_NODES 64\n#define ROPE_DEF_BLOCK_LEN 512\n\ntypedef struct rpnode_s {\n\tstruct rpnode_s *p; // child; at the bottom level, $p points to a string with the first 2 bytes giving the number of runs (#runs)\n\tuint64_t l:54, n:9, is_bottom:1; // $n and $is_bottom are only set for the first node in a bucket\n\tint64_t c[6]; // marginal counts\n} rpnode_t;\n\ntypedef struct {\n\tint32_t max_nodes, block_len; // both MUST BE even numbers\n\tint64_t c[6]; // marginal counts\n\trpnode_t *root;\n\tvoid *node, *leaf; // memory pool\n} rope_t;\n\ntypedef struct {\n\tconst rope_t *rope; // the rope\n\tconst rpnode_t *pa[ROPE_MAX_DEPTH]; // parent nodes\n\tint ia[ROPE_MAX_DEPTH]; // index in the parent nodes\n\tint d; // the current depth in the B+-tree\n} rpitr_t;\n\ntypedef struct {\n\tint beg;\n\tint64_t bc[6];\n\tuint8_t *p;\n} rpcache_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\trope_t *rope_init(int max_nodes, int block_len);\n\tvoid rope_destroy(rope_t *rope);\n\tint64_t rope_insert_run(rope_t *rope, int64_t x, int a, int64_t rl, rpcache_t *cache);\n\tvoid rope_rank2a(const rope_t *rope, int64_t x, int64_t y, int64_t *cx, int64_t *cy);\n\t#define rope_rank1a(rope, x, cx) rope_rank2a(rope, x, -1, cx, 0)\n\n\tvoid rope_itr_first(const rope_t *rope, rpitr_t *i);\n\tconst uint8_t *rope_itr_next_block(rpitr_t *i);\n\n\tvoid rope_print_node(const rpnode_t *p);\n\tvoid rope_dump(const rope_t *r, FILE *fp);\n\trope_t *rope_restore(FILE *fp);\n\t\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "scalar_sse.h",
          "type": "blob",
          "size": 2.5576171875,
          "content": "#ifndef SCALAR_SSE_H\n#define SCALAR_SSE_H\n\n#include <assert.h>\n#include <stdint.h>\n#include <string.h>\n\ntypedef union m128i {\n\tuint8_t u8[16];\n\tint16_t i16[8];\n} __m128i;\n\nstatic inline __m128i _mm_set1_epi32(int32_t n) {\n\tassert(n >= 0 && n <= 255);\n\t__m128i r; memset(&r, n, sizeof r); return r;\n}\n\nstatic inline __m128i _mm_load_si128(const __m128i *ptr) { __m128i r; memcpy(&r, ptr, sizeof r); return r; }\nstatic inline void _mm_store_si128(__m128i *ptr, __m128i a) { memcpy(ptr, &a, sizeof a); }\n\nstatic inline int m128i_allzero(__m128i a) {\n\tstatic const char zero[] = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\treturn memcmp(&a, zero, sizeof a) == 0;\n}\n\nstatic inline __m128i _mm_slli_si128(__m128i a, int n) {\n\tint i;\n\tmemmove(&a.u8[n], &a.u8[0], 16 - n);\n\tfor (i = 0; i < n; i++) a.u8[i] = 0;\n\treturn a;\n}\n\nstatic inline __m128i _mm_adds_epu8(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tuint16_t aa = a.u8[i];\n\t\taa += b.u8[i];\n\t\ta.u8[i] = (aa < 256)? aa : 255;\n\t}\n\treturn a;\n}\n\nstatic inline __m128i _mm_max_epu8(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 16; i++)\n\t\tif (a.u8[i] < b.u8[i]) a.u8[i] = b.u8[i];\n\treturn a;\n}\n\nstatic inline uint8_t m128i_max_u8(__m128i a) {\n\tuint8_t max = 0;\n\tint i;\n\tfor (i = 0; i < 16; i++)\n\t\tif (max < a.u8[i]) max = a.u8[i];\n\treturn max;\n}\n\nstatic inline __m128i _mm_set1_epi8(int8_t n) { __m128i r; memset(&r, n, sizeof r); return r; }\n\nstatic inline __m128i _mm_subs_epu8(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tint16_t aa = a.u8[i];\n\t\taa -= b.u8[i];\n\t\ta.u8[i] = (aa >= 0)? aa : 0;\n\t}\n\treturn a;\n}\n\nstatic inline __m128i _mm_adds_epi16(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tint32_t aa = a.i16[i];\n\t\taa += b.i16[i];\n\t\ta.i16[i] = (aa < 32768)? aa : 32767;\n\t}\n\treturn a;\n}\n\nstatic inline __m128i _mm_cmpgt_epi16(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\ta.i16[i] = (a.i16[i] > b.i16[i])? 0xffff : 0x0000;\n\treturn a;\n}\n\nstatic inline __m128i _mm_max_epi16(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tif (a.i16[i] < b.i16[i]) a.i16[i] = b.i16[i];\n\treturn a;\n}\n\nstatic inline __m128i _mm_set1_epi16(int16_t n) {\n\t__m128i r;\n\tr.i16[0] = r.i16[1] = r.i16[2] = r.i16[3] =\n\tr.i16[4] = r.i16[5] = r.i16[6] = r.i16[7] = n;\n\treturn r;\n}\n\nstatic inline int16_t m128i_max_s16(__m128i a) {\n\tint16_t max = -32768;\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tif (max < a.i16[i]) max = a.i16[i];\n\treturn max;\n}\n\nstatic inline __m128i _mm_subs_epu16(__m128i a, __m128i b) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tint32_t aa = a.i16[i];\n\t\taa -= b.i16[i];\n\t\ta.i16[i] = (aa >= 0)? aa : 0;\n\t}\n\treturn a;\n}\n\n#endif\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 7.0009765625,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#define FSYNC_ON_FLUSH\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <zlib.h>\n#include <errno.h>\n#ifdef FSYNC_ON_FLUSH\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#endif\n#include <sys/resource.h>\n#include <sys/time.h>\n#include \"utils.h\"\n\n#include \"ksort.h\"\n#define pair64_lt(a, b) ((a).x < (b).x || ((a).x == (b).x && (a).y < (b).y))\nKSORT_INIT(128, pair64_t, pair64_lt)\nKSORT_INIT(64,  uint64_t, ks_lt_generic)\n\n#include \"kseq.h\"\nKSEQ_INIT2(, gzFile, err_gzread)\n\n/********************\n * System utilities *\n ********************/\n\nFILE *err_xopen_core(const char *func, const char *fn, const char *mode)\n{\n\tFILE *fp = 0;\n\tif (strcmp(fn, \"-\") == 0)\n\t\treturn (strstr(mode, \"r\"))? stdin : stdout;\n\tif ((fp = fopen(fn, mode)) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, strerror(errno));\n\t}\n\treturn fp;\n}\n\nFILE *err_xreopen_core(const char *func, const char *fn, const char *mode, FILE *fp)\n{\n\tif (freopen(fn, mode, fp) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, strerror(errno));\n\t}\n\treturn fp;\n}\n\ngzFile err_xzopen_core(const char *func, const char *fn, const char *mode)\n{\n\tgzFile fp;\n\tif (strcmp(fn, \"-\") == 0) {\n\t\tfp = gzdopen(fileno((strstr(mode, \"r\"))? stdin : stdout), mode);\n\t\t/* According to zlib.h, this is the only reason gzdopen can fail */\n\t\tif (!fp) err_fatal(func, \"Out of memory\");\n\t\treturn fp;\n\t}\n\tif ((fp = gzopen(fn, mode)) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, errno ? strerror(errno) : \"Out of memory\");\n\t}\n\treturn fp;\n}\n\nvoid err_fatal(const char *header, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfprintf(stderr, \"[%s] \", header);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \"\\n\");\n\tva_end(args);\n\texit(EXIT_FAILURE);\n}\n\nvoid err_fatal_core(const char *header, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfprintf(stderr, \"[%s] \", header);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \" Abort!\\n\");\n\tva_end(args);\n\tabort();\n}\n\nvoid _err_fatal_simple(const char *func, const char *msg)\n{\n\tfprintf(stderr, \"[%s] %s\\n\", func, msg);\n\texit(EXIT_FAILURE);\n}\n\nvoid _err_fatal_simple_core(const char *func, const char *msg)\n{\n\tfprintf(stderr, \"[%s] %s Abort!\\n\", func, msg);\n\tabort();\n}\n\nsize_t err_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t ret = fwrite(ptr, size, nmemb, stream);\n\tif (ret != nmemb) \n\t\t_err_fatal_simple(\"fwrite\", strerror(errno));\n\treturn ret;\n}\n\nsize_t err_fread_noeof(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t ret = fread(ptr, size, nmemb, stream);\n\tif (ret != nmemb)\n\t{\n\t\t_err_fatal_simple(\"fread\", ferror(stream) ? strerror(errno) : \"Unexpected end of file\");\n\t}\n\treturn ret;\n}\n\nint err_gzread(gzFile file, void *ptr, unsigned int len)\n{\n\tint ret = gzread(file, ptr, len);\n\n\tif (ret < 0)\n\t{\n\t\tint errnum = 0;\n\t\tconst char *msg = gzerror(file, &errnum);\n\t\t_err_fatal_simple(\"gzread\", Z_ERRNO == errnum ? strerror(errno) : msg);\n\t}\n\n\treturn ret;\n}\n\nint err_fseek(FILE *stream, long offset, int whence)\n{\n\tint ret = fseek(stream, offset, whence);\n\tif (0 != ret)\n\t{\n\t\t_err_fatal_simple(\"fseek\", strerror(errno));\n\t}\n\treturn ret;\n}\n\nlong err_ftell(FILE *stream)\n{\n\tlong ret = ftell(stream);\n\tif (-1 == ret)\n\t{\n\t\t_err_fatal_simple(\"ftell\", strerror(errno));\n\t}\n\treturn ret;\n}\n\nint err_printf(const char *format, ...) \n{\n\tva_list arg;\n\tint done;\n\tva_start(arg, format);\n\tdone = vfprintf(stdout, format, arg);\n\tint saveErrno = errno;\n\tva_end(arg);\n\tif (done < 0) _err_fatal_simple(\"vfprintf(stdout)\", strerror(saveErrno));\n\treturn done;\n}\n\nint err_fprintf(FILE *stream, const char *format, ...) \n{\n\tva_list arg;\n\tint done;\n\tva_start(arg, format);\n\tdone = vfprintf(stream, format, arg);\n\tint saveErrno = errno;\n\tva_end(arg);\n\tif (done < 0) _err_fatal_simple(\"vfprintf\", strerror(saveErrno));\n\treturn done;\n}\n\nint err_fputc(int c, FILE *stream)\n{\n\tint ret = putc(c, stream);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"fputc\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nint err_fputs(const char *s, FILE *stream)\n{\n\tint ret = fputs(s, stream);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"fputs\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nint err_puts(const char *s)\n{\n\tint ret = puts(s);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"puts\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nint err_fflush(FILE *stream) \n{\n    int ret = fflush(stream);\n    if (ret != 0) _err_fatal_simple(\"fflush\", strerror(errno));\n\n#ifdef FSYNC_ON_FLUSH\n\t/* Calling fflush() ensures that all the data has made it to the\n\t   kernel buffers, but this may not be sufficient for remote filesystems\n\t   (e.g. NFS, lustre) as an error may still occur while the kernel\n\t   is copying the buffered data to the file server.  To be sure of\n\t   catching these errors, we need to call fsync() on the file\n\t   descriptor, but only if it is a regular file.  */\n\t{\n\t\tstruct stat sbuf;\n\t\tif (0 != fstat(fileno(stream), &sbuf))\n\t\t\t_err_fatal_simple(\"fstat\", strerror(errno));\n\t\t\n\t\tif (S_ISREG(sbuf.st_mode))\n\t\t{\n\t\t\tif (0 != fsync(fileno(stream)))\n\t\t\t\t_err_fatal_simple(\"fsync\", strerror(errno));\n\t\t}\n\t}\n#endif\n    return ret;\n}\n\nint err_fclose(FILE *stream) \n{\n\tint ret = fclose(stream);\n\tif (ret != 0) _err_fatal_simple(\"fclose\", strerror(errno));\n\treturn ret;\n}\n\nint err_gzclose(gzFile file)\n{\n\tint ret = gzclose(file);\n\tif (Z_OK != ret)\n\t{\n\t\t_err_fatal_simple(\"gzclose\", Z_ERRNO == ret ? strerror(errno) : zError(ret));\n\t}\n\n\treturn ret;\n}\n\n/*********\n * Timer *\n *********/\n\ndouble cputime(void)\n{\n\tstruct rusage r;\n\tgetrusage(RUSAGE_SELF, &r);\n\treturn r.ru_utime.tv_sec + r.ru_stime.tv_sec + 1e-6 * (r.ru_utime.tv_usec + r.ru_stime.tv_usec);\n}\n\ndouble realtime(void)\n{\n\tstruct timeval tp;\n\tstruct timezone tzp;\n\tgettimeofday(&tp, &tzp);\n\treturn tp.tv_sec + tp.tv_usec * 1e-6;\n}\n\nlong peakrss(void)\n{\n\tstruct rusage r;\n\tgetrusage(RUSAGE_SELF, &r);\n#ifdef __linux__\n\treturn r.ru_maxrss * 1024;\n#else\n\treturn r.ru_maxrss;\n#endif\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 3.82421875,
          "content": "/* The MIT License\n\n   Copyright (c) 2018-     Dana-Farber Cancer Institute\n                 2009-2018 Broad Institute, Inc.\n                 2008-2009 Genome Research Ltd. (GRL)\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n#ifndef LH3_UTILS_H\n#define LH3_UTILS_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <zlib.h>\n\n#ifdef __GNUC__\n// Tell GCC to validate printf format string and args\n#define ATTRIBUTE(list) __attribute__ (list)\n#else\n#define ATTRIBUTE(list)\n#endif\n\n#define err_fatal_simple(msg) _err_fatal_simple(__func__, msg)\n#define err_fatal_simple_core(msg) _err_fatal_simple_core(__func__, msg)\n\n#define xopen(fn, mode) err_xopen_core(__func__, fn, mode)\n#define xreopen(fn, mode, fp) err_xreopen_core(__func__, fn, mode, fp)\n#define xzopen(fn, mode) err_xzopen_core(__func__, fn, mode)\n\n#define xassert(cond, msg) if ((cond) == 0) _err_fatal_simple_core(__func__, msg)\n\ntypedef struct {\n\tuint64_t x, y;\n} pair64_t;\n\ntypedef struct { size_t n, m; uint64_t *a; } uint64_v;\ntypedef struct { size_t n, m; pair64_t *a; } pair64_v;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tvoid err_fatal(const char *header, const char *fmt, ...) ATTRIBUTE((noreturn));\n\tvoid err_fatal_core(const char *header, const char *fmt, ...) ATTRIBUTE((noreturn));\n\tvoid _err_fatal_simple(const char *func, const char *msg) ATTRIBUTE((noreturn));\n\tvoid _err_fatal_simple_core(const char *func, const char *msg) ATTRIBUTE((noreturn));\n\tFILE *err_xopen_core(const char *func, const char *fn, const char *mode);\n\tFILE *err_xreopen_core(const char *func, const char *fn, const char *mode, FILE *fp);\n\tgzFile err_xzopen_core(const char *func, const char *fn, const char *mode);\n    size_t err_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\tsize_t err_fread_noeof(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n\tint err_gzread(gzFile file, void *ptr, unsigned int len);\n\tint err_fseek(FILE *stream, long offset, int whence);\n#define err_rewind(FP) err_fseek((FP), 0, SEEK_SET)\n\tlong err_ftell(FILE *stream);\n\tint err_fprintf(FILE *stream, const char *format, ...)\n        ATTRIBUTE((format(printf, 2, 3)));\n\tint err_printf(const char *format, ...)\n        ATTRIBUTE((format(printf, 1, 2)));\n\tint err_fputc(int c, FILE *stream);\n#define err_putchar(C) err_fputc((C), stdout)\n\tint err_fputs(const char *s, FILE *stream);\n\tint err_puts(const char *s);\n\tint err_fflush(FILE *stream);\n\tint err_fclose(FILE *stream);\n\tint err_gzclose(gzFile file);\n\n\tdouble cputime(void);\n\tdouble realtime(void);\n\tlong peakrss(void);\n\n\tvoid ks_introsort_64 (size_t n, uint64_t *a);\n\tvoid ks_introsort_128(size_t n, pair64_t *a);\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline uint64_t hash_64(uint64_t key)\n{\n\tkey += ~(key << 32);\n\tkey ^= (key >> 22);\n\tkey += ~(key << 13);\n\tkey ^= (key >> 8);\n\tkey += (key << 3);\n\tkey ^= (key >> 15);\n\tkey += ~(key << 27);\n\tkey ^= (key >> 31);\n\treturn key;\n}\n\n#endif\n"
        },
        {
          "name": "xa2multi.pl",
          "type": "blob",
          "size": 0.7138671875,
          "content": "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\n\nwhile (<>) {\n\tif (/\\tXA:Z:(\\S+)/) {\n\t\tmy $l = $1;\n\t\tprint;\n\t\tmy @t = split(\"\\t\");\n\t\twhile ($l =~ /([^,;]+),([-+]\\d+),([^,]+),(\\d+);/g) {\n\t\t\tmy $mchr = ($t[6] eq $1)? '=' : $t[6]; # FIXME: TLEN/ISIZE is not calculated!\n\t\t\tmy $seq = $t[9];\n\t\t\tmy $phred = $t[10];\n\t\t\t# if alternative alignment has other orientation than primary, \n\t\t\t# then print the reverse (complement) of sequence and phred string\n\t\t\tif ((($t[1]&0x10)>0) xor ($2<0)) {\n\t\t\t\t$seq = reverse $seq;\n\t\t\t\t$seq =~ tr/ACGTacgt/TGCAtgca/;\n\t\t\t\t$phred = reverse $phred;\n\t\t\t}\n\t\t\tprint(join(\"\\t\", $t[0], 0x100|($t[1]&0x6e9)|($2<0?0x10:0), $1, abs($2), 0, $3, @t[6..7], 0, $seq, $phred, \"NM:i:$4\"), \"\\n\");\n\t\t}\n\t} else { print; }\n}\n"
        }
      ]
    }
  ]
}