{
  "metadata": {
    "timestamp": 1736710232490,
    "page": 963,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wavestone-cdt/EDRSandblast",
      "stars": 1575,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.986328125,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ll]ogs/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# Ionide (cross platform F# VS Code tools) working folder\n.ionide/\n\n# Exclude downloaded kernels\nOffsets/*.exe\nOffsets/*.dll\n/Offsets/nt\n/Offsets/wd\n\n# Exclude drivers and lsass dumps\n*.sys\nlsass"
        },
        {
          "name": "EDRSandblast.sln",
          "type": "blob",
          "size": 4.07421875,
          "content": "ï»¿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.2.32616.157\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"EDRSandblast_Core\", \"EDRSandblast\\EDRSandblast.vcxproj\", \"{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}\"\nEndProject\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"EDRSandblast_StaticLibrary\", \"EDRSandblast_StaticLibrary\\EDRSandblast_StaticLibrary.vcxproj\", \"{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}\"\nEndProject\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"EDRSandblast_LsassDump\", \"EDRSandblast_LsassDump\\EDRSandblast_LsassDump.vcxproj\", \"{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}\"\n\tProjectSection(ProjectDependencies) = postProject\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23} = {3A2FCB56-01A3-41B3-BDAA-B25F45784B23}\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B} = {7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}\n\tEndProjectSection\nEndProject\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"EDRSandblast_CLI\", \"EDRSandblast_CLI\\EDRSandblast_CLI.vcxproj\", \"{FFA0FDDE-BE70-49E4-97DE-753304EF1113}\"\n\tProjectSection(ProjectDependencies) = postProject\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B} = {7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}\n\tEndProjectSection\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|x64 = Debug|x64\n\t\tDebug|x86 = Debug|x86\n\t\tRelease|x64 = Release|x64\n\t\tRelease|x86 = Release|x86\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x64.Build.0 = Debug|x64\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x86.Build.0 = Debug|Win32\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x64.ActiveCfg = Release|x64\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x64.Build.0 = Release|x64\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x86.ActiveCfg = Release|Win32\n\t\t{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x86.Build.0 = Release|Win32\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x64.Build.0 = Debug|x64\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x86.Build.0 = Debug|Win32\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x64.ActiveCfg = Release|x64\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x64.Build.0 = Release|x64\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x86.ActiveCfg = Release|Win32\n\t\t{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x86.Build.0 = Release|Win32\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x64.Build.0 = Debug|x64\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x86.Build.0 = Debug|Win32\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x64.ActiveCfg = Release|x64\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x64.Build.0 = Release|x64\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x86.ActiveCfg = Release|Win32\n\t\t{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x86.Build.0 = Release|Win32\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x64.Build.0 = Debug|x64\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x86.Build.0 = Debug|Win32\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x64.ActiveCfg = Release|x64\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x64.Build.0 = Release|x64\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x86.ActiveCfg = Release|Win32\n\t\t{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x86.Build.0 = Release|Win32\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {01A85934-E9FB-4355-846F-667848B78EAF}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "EDRSandblast",
          "type": "tree",
          "content": null
        },
        {
          "name": "EDRSandblast_CLI",
          "type": "tree",
          "content": null
        },
        {
          "name": "EDRSandblast_LsassDump",
          "type": "tree",
          "content": null
        },
        {
          "name": "EDRSandblast_StaticLibrary",
          "type": "tree",
          "content": null
        },
        {
          "name": "Offsets",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 47.50390625,
          "content": "# EDRSandBlast\n\n`EDRSandBlast` is a tool written in `C` that weaponize a vulnerable signed\ndriver to bypass EDR detections (Notify Routine callbacks, Object Callbacks\nand `ETW TI` provider) and `LSASS` protections. Multiple userland unhooking\ntechniques are also implemented to evade userland monitoring.\n\nAs of release, combination of userland (`--usermode`) and Kernel-land\n(`--kernelmode`) techniques were used to dump `LSASS` memory under EDR\nscrutiny, without being blocked nor generating \"OS Credential Dumping\"-related\nevents in the product (cloud) console. The tests were performed on 3 distinct\nEDR products and were successful in each case.\n\n## Description\n\n### EDR bypass through Kernel Notify Routines removal\n\nEDR products use Kernel \"Notify Routines\" callbacks on Windows to be notified by the kernel of\nsystem activity, such as process and thread creation and loading of images\n(`exe` / `DLL`).\n\nThese Kernel callbacks are defined from kernel-land, usually from the driver implementing the callbacks, using a number of documented\nAPIs (`nt!PsSetCreateProcessNotifyRoutine`, `nt!PsSetCreateThreadNotifyRoutine`,\netc.). These APIs add driver-supplied callback routines to undocumented\narrays of routines in Kernel-space:\n  - `PspCreateProcessNotifyRoutine` for process creation\n  - `PspCreateThreadNotifyRoutine` for thread creation\n  - `PspLoadImageNotifyRoutine` for image loading\n\n`EDRSandBlast` enumerates the routines defined in those arrays and remove any\ncallback routine linked to a predefined list of EDR drivers (more than 1000\n drivers of security products supported, see the [EDR driver detection section](#edr-drivers-and-processes-detection).\nThe enumeration and removal are made possible through the exploitation of an\narbitrary Kernel memory read / write primitive provided by the exploitation of a vulnerable driver (see [Vulnerable drivers section](#vulnerable-drivers-detection)).\n\nThe offsets of the aforementioned arrays are recovered using multiple techniques, please refer to [Offsets section](#ntoskrnl-and-wdigest-offsets).\n\n### EDR bypass through Object Callbacks removal\nEDR (and even EPP) products often register \"Object callbacks\" through the use of the\n`nt!ObRegisterCallbacks` kernel API. These callbacks allow the security product to\nbe notified at each handle generation on specific object types (Processes, Threads and\nDesktops related object callbacks are now supported by Windows). A handle generation\nmay occur on object opening (call to `OpenProcess`, `OpenThread`, etc.) as well as\nhandle duplication (call to `DuplicateHandle`, etc.).\n\nBy being notified by the kernel on each of these operations, a security product may\nanalyze the legitimacy of the handle creation (*e.g. an unknown process is trying to open\nLSASS*), and even block it if a threat is detected.\n\nAt each callback registration using `ObRegisterCallbacks`, a new item is added to\nthe `CallbackList` double-linked list present in the `_OBJECT_TYPE` object describing\nthe type of object affected by the callback (either a Process, a Thread or a Desktop).\nUnfortunately, these items are described by a structure that is not documented nor\npublished in symbol files by Microsoft. However, studying it from various `ntoskrnl.exe`\nversions seems to indicate that the structure did not change between (at least) Windows\n10 builds 10240 and 22000 (from 2015 to 2022).\n\nThe mentionned structure, representing an object callback registration, is the following:\n```C\ntypedef struct OB_CALLBACK_ENTRY_t {\n    LIST_ENTRY CallbackList; // linked element tied to _OBJECT_TYPE.CallbackList\n    OB_OPERATION Operations; // bitfield : 1 for Creations, 2 for Duplications\n    BOOL Enabled;            // self-explanatory\n    OB_CALLBACK* Entry;      // points to the structure in which it is included\n    POBJECT_TYPE ObjectType; // points to the object type affected by the callback\n    POB_PRE_OPERATION_CALLBACK PreOperation;      // callback function called before each handle operation\n    POB_POST_OPERATION_CALLBACK PostOperation;     // callback function called after each handle operation\n    KSPIN_LOCK Lock;         // lock object used for synchronization\n} OB_CALLBACK_ENTRY;\n```\nThe `OB_CALLBACK` structure mentionned above is also undocumented, and is defined\nby the following:\n```C\ntypedef struct OB_CALLBACK_t {\n    USHORT Version;                           // usually 0x100\n    USHORT OperationRegistrationCount;        // number of registered callbacks\n    PVOID RegistrationContext;                // arbitrary data passed at registration time\n    UNICODE_STRING AltitudeString;            // used to determine callbacks order\n    struct OB_CALLBACK_ENTRY_t EntryItems[1]; // array of OperationRegistrationCount items\n    WCHAR AltitudeBuffer[1];                  // is AltitudeString.MaximumLength bytes long, and pointed by AltitudeString.Buffer\n} OB_CALLBACK;\n```\n\nIn order to disable EDR-registered object callbacks, three techniques are implemented in\n`EDRSandblast`; however only one is enabled for the moment.\n\n#### Using the `Enabled` field of `OB_CALLBACK_ENTRY`\nThis is the default technique enabled in `EDRSandblast`. In order to detect and disable\nEDR-related object callbacks, the `CallbackList` list located in the `_OBJECT_TYPE`\nobjects tied to the *Process* and *Thread* types is browsed. Both `_OBJECT_TYPE`s are\npointed by public global symbols in the kernel, `PsProcessType` and `PsThreadType`.\n\nEach item of the list is assumed to fit the `OB_CALLBACK_ENTRY` structure described above\n(assumption that seems to hold at least in all Windows 10 builds at the time of writing).\nFunctions defined in `PreOperation` and `PostOperation` fields are located to checks\nif they belong to an EDR driver, and if so, callbacks are simply disabled toggling the `Enabled`\nflag.\n\nWhile being a pretty safe technique, it has the inconvenient of relying on an undocumented\nstructure; to reduce the risk of unsafe manipulation of this structure, basic checks are\nperformed to validate that some fields have the expected values :\n* `Enabled` is either `TRUE` or `FALSE` (*don't laugh, a `BOOL` is an `int`, so it could be anything other than `1` or `0`*);\n* `Operations` is `OB_OPERATION_HANDLE_CREATE`,  `OB_OPERATION_HANDLE_DUPLICATE` or both;\n* `ObjectType` points on `PsProcessType` or `PsThreadType`.\n\n#### Unlinking the `CallbackList` of threads and process\nAnother strategy that do not rely on an undocumented structure (and is thus theoretically\nmore robust against NT kernel changes) is the unlinking of the whole `CallbackList`\nfor both processes and threads. The `_OBJECT_TYPE` object is the following:\n```C\nstruct _OBJECT_TYPE {\n\tLIST_ENTRY TypeList;\n\tUNICODE_STRING Name;\n\t[...]\n\t_OBJECT_TYPE_INITIALIZER TypeInfo;\n\t[...]\n\tLIST_ENTRY CallbackList;\n}\n```\nMaking the `Flink` and `Blink` pointers of the `CallbackList` `LIST_ENTRY` point to\nthe `LIST_ENTRY` itself effectively make the list empty. Since the `_OBJECT_TYPE` structure\nis published in the kernel' symbols, the technique does not rely on hardcoded offsets/structures.\nHowever, it has some drawbacks.\n\nThe first being not able to only disable callbacks from EDR; indeed, the technique affects\nall object callbacks that could have been registered by \"legitimate\" software. It should\nnevertheless be noted that object callbacks are not used by any pre-installed component\non Windows 10 (at the time of writing) so disabling them should not affect the machine\nstability (even more so if the disabling is only temporary).\n\nThe second drawback is that process or thread handle operation are really frequent (nearly\ncontinuous) in the normal functioning of the OS. As such, if the kernel write primitive used\ncannot perform a `QWORD` write \"atomically\", there is a good chance that the\n`_OBJECT_TYPE.CallbackList.Flink` pointer will be accessed by the kernel in the middle\nof its overwriting. For instance, the MSI vulnerable driver `RTCore64.sys` can only perform\na `DWORD` write at a time, so 2 distinct IOCTLs will be needed to overwrite the pointer, between\nwhich the kernel has a high probability of using it (resulting in a crash). On the other hand,\nthe vulnerable DELL driver `DBUtil_2_3.sys` can perform writes of arbitrary sizes in one\nIOCTL, so using this method with it does not risk causing a crash.\n\n#### Disabling object callbacks altogether\nOne last technique we found was to disable entirely the object callbacks support for thread\nand processes. Inside the `_OBJECT_TYPE` structure corresponding to the process and\nthread types resides a `TypeInfo` field, following the documented `_OBJECT_TYPE_INITIALIZER`\nstructure. The latter contains a `ObjectTypeFlags` bit field, whose `SupportsObjectCallbacks`\nflag determines if the described object type (Process, Thread, Desktop, Token, File, etc.)\nsupports object callback registering or not. As previously stated, only Process, Thread and\nDesktop object types supports these callbacks on a Windows installation at the time of writing.\n\nSince the `SupportsObjectCallbacks` bit is checked by `ObpCreateHandle` or\n`ObDuplicateObject` before even reading the `CallbackList` (and before executing\ncallbacks, of course), flipping the bit at kernel runtime effectively disable all object callbacks\nexecution.\n\nThe main drawback of the method is simply that *KPP* (\"*PatchGuard*\") monitors the integrity\nof some (all ?) `_OBJECT_TYPE` structures, and triggers a [`0x109 Bug Check`](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption)\nwith parameter 4 being equal to `0x8`, meaning an object type structure has been altered.\n\nHowever, performing the disabling / re-enabling (and \"malicious\" action in-between) quickly\nenough should be enough to \"race\" *PatchGuard* (unless you are unlucky and a periodic\ncheck is performed just at the wrong moment).\n\n### EDR bypass through minifilters' callbacks unlinking\nThe Windows Filter Manager system allows an EDR to load a \"minifilter\" driver and\nregister callbacks in order to be notified of I/O operations, such as file opening,\nreading, writing, etc. \n\nHere is a quick sum-up of different internal structures used by the filter manager:\n- The Filter Manager establishes a \"frame\" (`_FLTP_FRAME`) as its root structure;\n- A \"volume\" structure (`_FLT_VOLUME`) is instanciated for each \"disk\" managed by the\nFilter Manager (can be partitions, shadow copies, or special ones corresponding to\nnamed pipes or remote file systems);\n- To each registered minifilter driver corresponds a \"filter\" structure (`_FLT_FILTER`),\ndescribing various properties such as its supported operations;\n- These minifilters are not all attached to each volume; an \"instance\" (`_FLT_INSTANCE`)\nstructure is created to mark each of the \n\t\tfilter<->volume associations;\n- Minifilters register callback functions that are to be executed before and/or after\n specific operations (file open, write, read, etc.). These callbacks are described in\n`_CALLBACK_NODE` structures, and can be accessed by different ways:\n  - An array of all `_CALLBACK_NODE`s implemented by an instance of a minifilter\n    can be found in the `_FLT_INSTANCE` structure; the array is indexed by the IRP \n    \"major function\" code, a constant representing the operations handled by the \n    callbacks (`IRP_MJ_CREATE`, `IRP_MJ_READ`, etc.).\n  - Also, all `_CALLBACK_NODE`s implemented by instances linked to a specific volume\n  are regrouped in linked lists, stored in the `_FLT_VOLUME.Callbacks.OperationLists`\n  array indexed by IRP major function codes.\n\nThese different structures are browsed by `EDRSandblast` to detect filters that are \nassociated with EDR-related drivers, and the callback nodes containing monitoring \nfunctions are enumerated. To disable their effect, the nodes are unlinked from their \nlists, making them temporarily invisible from the filter manager.\n\nThis way, during a specified period, the EDR can be completely unaware of any file \noperations. A basic example would be the creation of an lsass memory dump file on disk,\nthat would not trigger any analysis from the EDR, and thus no detection based on the \nfile itself.\n\n### EDR bypass through deactivation of the ETW Microsoft-Windows-Threat-Intelligence provider\n\nThe `ETW Microsoft-Windows-Threat-Intelligence` provider logs data about the\nusages of some Windows API commonly used maliciously. This include the\n`nt!MiReadWriteVirtualMemory` API, called by `nt!NtReadVirtualMemory` (which is\nused to dump `LSASS` memory) and monitored by the `nt!EtwTiLogReadWriteVm`\nfunction.\n\nEDR products can consume the logs produced by the `ETW TI` provider through\nservices or processes running as, respectively,\n`SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT` or\n`PS_PROTECTED_ANTIMALWARE_LIGHT`, and associated with an `Early Launch Anti\nMalware (ELAM)` driver.\n\nAs published by\n[`slaeryan` in a `CNO Development Labs` blog post](https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider),\nthe `ETW TI` provider can be disabled altogether by patching, in kernel memory,\nits `ProviderEnableInfo` attribute to `0x0`. Refer to the great aforementioned\nblog post for more information on the technique.\n\nSimilarly to the Kernel callbacks removal, the necessary `ntoskrnl.exe` offsets\n(`nt!EtwThreatIntProvRegHandleOffset`, `_ETW_REG_ENTRY`'s `GuidEntry`, and\n`_ETW_GUID_ENTRY`'s `ProviderEnableInfo`) are computed in the\n`NtoskrnlOffsets.csv` file for a number of the Windows Kernel versions.\n\n### EDR bypass through userland hooking bypass\n#### How userland hooking works\nIn order to easily monitor actions that are performed by processes, EDR products often\ndeploy a mechanism called *userland hooking*. First, EDR products register a kernel\ncallback (usually *image loading* or *process creation* callbacks, see above) that allows\nthem to be notified upon each process start.\n\n\nWhen a process is loaded by Windows, and before it actually starts, the EDR is able to\ninject some custom DLL into the process address space, which contains its monitoring\nlogic. While loading, this DLL injects \"*hooks*\" at the start of every function that is to\nbe monitored by the EDR. At runtime, when the monitored functions are called by the\nprocess under surveillance, these hooks redirect the control flow to some supervision code\npresent in the EDR's DLL, which allows it to inspect arguments and return values of these\ncalls.\n\nMost of the time, monitored functions are system calls (such as `NtReadVirtualMemory`,\n`NtOpenProcess`, etc.), whose implementations reside in `ntdll.dll`. Intercepting calls to\n`Nt*` functions allows products to be as close as possible to the userland / kernel-land\nboundary (while remaining in userland), but functions from some higher-level DLLs may also\nbe monitored as well.\n\nBellow are examples of the same function, before and after beeing hooked by the EDR product:\n```assembly\nNtProtectVirtualMemory   proc near\n\tmov r10, rcx\n\tmov eax, 50h\n\ttest byte ptr ds:7FFE0308h, 1\n\tjnz short loc_18009D1E5\n\tsyscall\n\tretn\nloc_18009D1E5:\n\tint 2Eh\n\tretn\nNtProtectVirtualMemory   endp\t\t\t\n```\n\n```assembly\nNtProtectVirtualMemory proc near\n\tjmp     sub_7FFC74490298     ; --> \"hook\", jump to EDR analysis function\n\tint 3                        ; overwritten instructions\n\tint 3                        ; overwritten instructions\n\tint 3                        ; overwritten instructions\n\ttest byte_7FFE0308, 1        ; <-- execution resumes here after analysis\n\tjnz short loc_7FFCB44AD1E5\n\tsyscall\n\tretn\nloc_7FFCB44AD1E5:\n\tint 2Eh\n\tretn\nNtProtectVirtualMemory   endp\t\t\t\n```\n\n#### Hooks detection\nUserland hooks have the \"weakness\" to be located in userland memory, which means they are\ndirectly observable and modifiable by the process under scrutiny. To automatically detect\nhooks in the process address space, the main idea is to compare the differences between\nthe original DLL on disk and the library residing in memory, that has been potentially\naltered by an EDR. To perform this comparison, the following steps are followed by\nEDRSandblast:\n* The list of all loaded DLLs is enumerated thanks to the `InLoadOrderModuleList` located\n  int the `PEB` (to avoid calling any API that could be monitored and suspicious)\n* For each loaded DLL, its content on disk is read and its headers parsed. The\n  corresponding library, residing in memory, is also parsed to identify sections, exports,\n  etc.\n* Relocations of the DLL are parsed and applied, by taking the base address of the\n  corresponding loaded library into account. This allows the content of both the in-memory\n  library and DLL originating from disk to have the exact same content (on sections where\n  relocations are applied), and thus making the comparison reliable.\n* Exported functions are enumerated and the first bytes of the \"in-memory\" and \"on-disk\"\n  versions are compared. Any difference indicates an alteration that has been made after\n  the DLL was loaded, and thus is very probably an EDR hook.\n\nNote: The process can be generalized to find differences anywhere in non-writable sections\nand not only at the start of exported functions, for example if EDR products start to\napply hooks in the middle of function :) Thus not used by the tool, this has been\nimplemented in `findDiffsInNonWritableSections`.\n\n\nIn order to bypass the monitoring performed by these hooks, multiples techniques are\npossible, and each has benefits and drawbacks.\n\n#### Hook bypass using ... unhooking\nThe most intuitive method to bypass the hook-based monitoring is to remove the\nhooks. Since the hooks are present in memory that is reachable by the process itself, to\nremove a hook, the process can simply:\n* Change the permissions on the page where the hook is located (RX -> RWX or RW)\n* Write the original bytes that are known thanks to the on-disk DLL content\n* Change back the permissions to RX\n\nThis approach is fairly simple, and can be used to remove every detected hook all at\nonce. Performed by an offensive tool at its beginning, this allows the rest of the code to\nbe completely unaware of the hooking mechnanism and perform normally without being\nmonitored.\n\nHowever, it has two main drawbacks. The EDR is probably monitoring the use of\n`NtProtectVirtualMemory`, so using it to change the permissions of the page where the\nhooks have been installed is (at least conceptually) a bad idea. Also, if a thread is\nexecuted by the EDR and periodically check the integrity of the hooks, this could also\ntrigger some detection.\n\nFor implementation details, check the `unhook()` function's code path when `unhook_method` is\n`UNHOOK_WITH_NTPROTECTVIRTUALMEMORY`.\n\n**Important note: for simplicity, this technique is implemented in EDRSandblast as the\nbase technique used to *showcase* the other bypass techniques; each of them demonstrates\nhow to obtain an unmonitored version of `NtProtectVirtualMemory`, but performs the same\noperation afterward (unhooking a specific hook).**\n\n#### Hook bypass using a custom trampoline\nTo bypass a specific hook, it is possible to simply \"jump over\" and execute the rest of\nthe function as is. First, the original bytes of the monitored function, that have been\noverwritten by the EDR to install the hook, must be recovered from the DLL file. In our\nprevious code example, this would be the bytes corresponding to the following\ninstructions:\n\n```assembly\nmov r10, rcx\nmov eax, 50h\n```\n\nIdentifying these bytes is a simple task since we are able to perform a clean *diff* of\nboth the memory and disk versions of the library, as previously described. Then, we\nassemble a jump instruction that is built to redirect the control flow to the code\nfollowing immediately the hook, at address `NtProtectVirtualMemory +\nsizeof(overwritten_instructions)`\n\n```assembly\njmp NtProtectVirtualMemory+8\n```\n\nFinally, we concatenate these opcodes, store them in (newly) executable memory and keep a\npointer to them. This object is called a \"*trampoline*\" and can then be used as a function\npointer, strictly equivalent to the original `NtProtectVirtualMemory` function.\n\nThe main benefit of this technique as for every techniques bellow, is that the hook is\nnever erased, so any integrity check performed on the hooks by the EDR should\npass. However, it requires to allocate writable then executable memory, which is typical\nof a shellcode allocation, thus attracting the EDR's scrutiny.\n\nFor implementation details, check the `unhook()` function's code path when `unhook_method` is\n`UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE`. Please remember the technique is\nonly showcased in our implementation and is, in the end, used to **remove** hooks from\nmemory, as every technique bellow.\n\n#### Hook bypass using the own EDR's trampoline\nThe EDR product, in order for its hook to work, must save somewhere in memory the opcodes\nthat it has removed. Worst (*or \"better\", from the attacker point of view*), to\neffectively use the original instructions the EDR has probably allocated itself a\n*trampoline* somewhere to execute the original function after having intercepted the call.\n\nThis trampoline can be searched for and used as a replacement for the hooked function,\nwithout the need to allocate executable memory, or call any API except `VirtualQuery`,\nwhich is most likely not monitored being an innocuous function.\n\nTo find the trampoline in memory, we browse the whole address space using `VirtualQuery`\nlooking for commited and executable memory. For each such region of memory, we scan it to\nlook for a jump instruction that targets the address following the overwritten\ninstructions (`NtProtectVirtualMemory+8` in our previous example). The trampoline can then\nbe used to call the hooked function without triggering the hook.\n\nThis technique works surprisingly well as it recovers nearly all trampolines on tested\nEDR. For implementation details, check the `unhook()` function's code path when\n`unhook_method` is `UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE`.\n\n\n#### Hook bypass using duplicate DLL\nAnother simple method to get access to an unmonitored version of `NtProtectVirtualMemory`\nfunction is to load a duplicate version of the `ntdll.dll` library into the process address\nspace. Since two identical DLLs can be loaded in the same process, provided they have\ndifferent names, we can simply copy the legitimate `ntdll.dll` file into another location,\nload it using `LoadLibrary` (or reimplement the loading process), and access the function\nusing `GetProcAddress` for example.\n\nThis technique is very simple to understand and implement, and have a decent chance of\nsuccess, since most of EDR products does not re-install hooks on newly loaded DLLs once\nthe process is running. However, the major drawback is that copying Microsoft signed\nbinaries under a different name is often considered as suspicious by EDR products as\nitself.\n\nThis technique is nevertheless implemented in `EDRSandblast`. For implementation details, check\nthe `unhook()` function's code path when `unhook_method` is\n`UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY`.\n\n\n#### Hook bypass using direct syscalls\nIn order to use system calls related functions, one program can reimplement syscalls (in\nassembly) in order to call the corresponding OS features without actually touching the\ncode in `ntdll.dll`, which might be monitored by the EDR.  This completely bypasses any\nuserland hooking done on syscall functions in `ntdll.dll`.\n\nThis nevertheless has some drawbacks. First, this implies being able to know the list of\nsyscall numbers of functions the program needs, which changes for each version of\nWindows. This is nevertheless mitigated by implementing multiple heuristics that are known\nto work in all the past versions of Windows NT (sorting `ntdll`'s' `Zw*` exports, searching\nfor `mov rax, #syscall_number` instruction in the associated `ntdll` function, etc.),\nand checking they all return the same result (see `Syscalls.c` for more details).\n\nAlso, functions that are not technically syscalls\n(e.g. `LoadLibraryX`/`LdrLoadDLL`) could be monitored as well, and cannot simply be\nreimplemented using a syscall.\n\nThe direct syscalls technique is implemented in EDRSandblast. As previously stated, it is only used to\nexecute `NtProtectVirtualMemory` safely, and remove all detected hooks.\n\nFor implementation details, check the `unhook()` function's code path when `unhook_method` is\n`UNHOOK_WITH_DIRECT_SYSCALL`.\n\n### Vulnerable drivers exploitation\nAs previously stated, every action that needs a kernel memory read or write relies on a\nvulnerable driver to give this primitive. In EDRSanblast, adding the support for a new\ndriver providing the read/write primitive can be \"easily\" done, only three functions\nneed to be implemented:\n* A `ReadMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)` function, that copies `Size` bytes from kernel address `Address` to userland buffer `Buffer`;\n* A `WriteMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)` function, that copies `Size` bytes from userland buffer `Buffer` to kernel address `Address`;\n* A `CloseDriverHandle_DRIVERNAME()` that ensures all handles to the driver are closed (needed before uninstall operation which is driver-agnostic, for the moment).\n\nAs an example, two drivers are currently supported by EDRSandblast, `RTCore64.sys`\n(SHA256: `01AA278B07B58DC46C84BD0B1B5C8E9EE4E62EA0BF7A695862444AF32E87F1FD`)\nand `DBUtils_2_3.sys` (SHA256: `0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5`).\nThe following code in `KernelMemoryPrimitives.h` is to be updated if the used\nvulnerable driver needs to be changed, or if a new one implemented.\n\n```C\n#define RTCore 0\n#define DBUtil 1\n// Select the driver to use with the following #define\n#define VULN_DRIVER RTCore\n\n#if VULN_DRIVER == RTCore\n#define DEFAULT_DRIVER_FILE TEXT(\"RTCore64.sys\")\n#define CloseDriverHandle CloseDriverHandle_RTCore\n#define ReadMemoryPrimitive ReadMemoryPrimitive_RTCore\n#define WriteMemoryPrimitive WriteMemoryPrimitive_RTCore\n#elif VULN_DRIVER == DBUtil\n#define DEFAULT_DRIVER_FILE TEXT(\"DBUtil_2_3.sys\")\n#define CloseDriverHandle CloseDriverHandle_DBUtil\n#define ReadMemoryPrimitive ReadMemoryPrimitive_DBUtil\n#define WriteMemoryPrimitive WriteMemoryPrimitive_DBUtil\n#endif\n```\n\n### EDR drivers and processes detection\nMultiple techniques are currently used to determine if a specific driver or process belongs\nto an EDR product or not.\n\nFirst, the name of the driver can simply be used for that purpose. Indeed, Microsoft\nallocates specific numbers called \"Altitudes\" for all drivers that need to insert callbacks\nin the kernel. This allow a deterministic order in callbacks execution, independent from\nthe registering order, but only based on the driver usage. A list of (vendors of) drivers\nthat have reserved specific *altitude* can be found\n[on MSDN](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes).\nAs a consequence, a nearly comprehensive list of security driver names tied to security\nproducts is offered by Microsoft, mainly in the \"FSFilter Anti-Virus\" and \"FSFilter Activity\nMonitor\" lists. These lists of driver names are embedded in EDRSandblast, as well as\nadditional contributions.\n\nMoreover, EDR executables and DLL are more than often digitally signed using the\nvendors signing certificate. Thus, checking the signer of an executable or DLL associated\nto a process may   allow to quickly identify EDR products.\n\nAlso, drivers need to be directly signed by Microsoft to be allowed to be loaded in\nkernel space. While the driver's vendor is not directly the signer of the driver itself,\nit would seam that the vendor's name is still included inside an attribute of the signature;\nthis detection technique is nevertheless yet to be investigated and implemented.\n\nFinally, when facing an EDR unknown to EDRSandblast, the best approach is to run\nthe tool in \"audit\" mode, and check the list of drivers having registered kernel callbacks;\nthen the driver's name can be added to the list, the tool recompiled and re-run.\n\n### RunAsPPL bypass\n\nThe `Local Security Authority (LSA) Protection` mechanism, first introduced\nin Windows 8.1 and Windows Server 2012 R2, leverage the `Protected Process\nLight (PPL)` technology to restrict access to the `LSASS` process. The `PPL`\nprotection regulates and restricts operations, such as memory injection or\nmemory dumping of protected processes, even from a process holding the\n`SeDebugPrivilege` privilege. Under the process protection model, only\nprocesses running with higher protection levels can perform operations on\nprotected processes.\n\nThe `_EPROCESS` structure, used by the Windows kernel to represent a process\nin kernel memory, includes a `_PS_PROTECTION` field defining the protection level\nof a process through its `Type` (`_PS_PROTECTED_TYPE`) and `Signer` (`_PS_PROTECTED_SIGNER`)\nattributes.\n\nBy writing in kernel memory, the EDRSandblast process is able to upgrade its own\nprotection level to `PsProtectedSignerWinTcb-Light`. This level is sufficient to\ndump the `LSASS` process memory, since it \"dominates\" to `PsProtectedSignerLsa-Light`,\n the protection level of the `LSASS` process running with the `RunAsPPL` mechanism.\n\n`EDRSandBlast` implements the self protection as follow:\n  - open a handle to the current process\n  - leak all system handles using `NtQuerySystemInformation` to find the opened\n    handle on the current process, and the address of the current process'\n    `EPROCESS` structure in kernel memory.\n  - use the arbitrary read / write vulnerability of the vulnerable\n    driver to overwrite the `_PS_PROTECTION` field of the current\n    process in kernel memory. The offsets of the `_PS_PROTECTION` field\n    relative to the `EPROCESS` structure (defined by the `ntoskrnl` version in\n    use) are computed in the `NtoskrnlOffsets.csv` file.\n\n### Credential Guard bypass\n\nMicrosoft `Credential Guard` is a virtualization-based isolation technology,\nintroduced in Microsoft's `Windows 10 (Enterprise edition)` which prevents\ndirect access to the credentials stored in the `LSASS` process.\n\nWhen `Credentials Guard` is activated, an `LSAIso` (*LSA Isolated*) process is\ncreated in `Virtual Secure Mode`, a feature that leverages the virtualization\nextensions of the CPU to provide added security of data in memory. Access to\nthe `LSAIso` process are restricted even for an access with the\n`NT AUTHORITY\\SYSTEM` security context. When processing a hash, the `LSA`\nprocess perform a `RPC` call to the `LSAIso` process, and waits for the\n`LSAIso` result to continue. Thus, the `LSASS` process won't contain any\nsecrets and in place will store `LSA Isolated Data`.\n\nAs stated in original research conducted by `N4kedTurtle`: \"`Wdigest` can be\nenabled on a system with Credential Guard by patching the values of\n`g_fParameter_useLogonCredential` and `g_IsCredGuardEnabled` in memory\".\nThe activation of `Wdigest` will result in cleartext credentials being stored\nin `LSASS` memory for any new interactive logons (without requiring a reboot of\nthe system). Refer to the\n[original research blog post](https://teamhydra.blog/2020/08/25/bypassing-credential-guard/)\nfor more details on this technique.\n\n`EDRSandBlast` simply make the original PoC a little more opsec friendly and\nprovide support for a number of `wdigest.dll` versions (through computed\noffsets for `g_fParameter_useLogonCredential` and `g_IsCredGuardEnabled`).\n\n### Offsets retrieval\nIn order to reliably perform kernel monitoring bypass operations, EDRSandblast needs\nto know exactly where to read and write kernel memory. This is done using offsets of\nglobal variables inside the targeted image (ntoskrnl.exe, wdigest.dll), as well as offset\nof specific fields in structures whose definitions are published by Microsoft in symbol\nfiles. These offsets are specific to each build of the targeted images, and must be gathered\nat least once for a specific platform version.\n\nThe choice of using \"hardcoded\" offsets instead of pattern searches to locate the structures\nand variables used by EDRSandblast is justified by the fact that the undocumented APIs\nresponsible for Kernel callbacks addition / removal are subject to change and that any attempt\nto read or write Kernel memory at the wrong address may (and often will) result in a\n`Bug Check` (`Blue Screen of Death`). A machine crash is not acceptable in both\nred-teaming and normal penetration testing scenarios, since a machine that crashes\nis highly visible by defenders, and will lose any credentials that was still in memory at\nthe moment of the attack.\n\nTo retrieve offsets for each specific version of Windows, two approaches are implemented.\n\n#### Manual offset retrieval\nThe required `ntoskrnl.exe` and `wdigest.dll` offsets can be extracted using the\nprovided `ExtractOffsets.py` Python script, that relies on `radare2`  and `r2pipe`\nto download and parse symbols from PDB files, and extracted the needed offsets from\nthem. Offsets are then stored in CSV files for later use by EDRSandblast.\n\nIn order to support out-of-the-box a wide range of Windows builds, many versions of\nthe `ntoskrnl.exe` and `wdigest.dll` binaries are referenced by\n[Winbindex](https://winbindex.m417z.com/) , and can be automatically downloaded\n(and their offsets extracted) by the `ExtractOffsets.py`. This allows to extract offsets\nfrom nearly all files that were ever published in Windows update packages (to date 450+\n`ntoskrnl.exe` and 30+ `wdigest.dll` versions are available and pre-computed).\n\n#### Automatic offsets retrieval and update\nAn additionnal option has been implemented in `EDRSandBlast` to allow the program\nto download the needed `.pdb` files itself from Microsoft Symbol Server, extract the\nrequired offsets, and even update the corresponding `.csv` files if present.\n\nUsing the `--internet` option make the tool execution much simpler, while introducing\nan additionnal OpSec risk, since a `.pdb` file is downloaded and dropped on disk during\nthe process. This is required by the `dbghelp.dll` functions used to parse the symbols\ndatabase ; however, full in-memory PDB parsing might be implemented in the future to\nlift this requirement and reduce the tool's footprint.\n\n## Usage\n\n### Vulnerable drivers\n\nEDRSandblast publicly implements the support of at least 3 vulnerable driver, `gdrv.sys` (default), \n`RTCore64.sys` and `DBUtil_2_3.sys`. The driver actually used is decided before compilation\nof the tool (see `#define VULN_DRIVER <driver name>` in `includes/KernelMemoryPrimitive.h`). A copy \nof the vulnerable driver should be downloaded and provided to EDRSandblast for its kernel operation\nto work.\n\nTested drivers' hashs are mentionned at the start of each `Driver<name>.c` file that implements the\nkernel memory read and write primitives used by EDRSanblast. Using these hashs, drivers samples can be\neasy found on the Internet, especially on `https://www.loldrivers.io`.\n\nHere is the list of the supported vulnerable drivers along with download links:\n\n| Supported driver | Download link                                                                                                        | SHA256                                                           |\n|------------------|----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------|\n| `GDRV.sys`       | [LOLDrivers link](https://github.com/magicsword-io/LOLDrivers/raw/main/drivers/9ab9f3b75a2eb87fafb1b7361be9dfb3.bin) | 31f4cfb4c71da44120752721103a16512444c13c2ac2d857a7e6f13cb679b427 |\n| `RTCore64.sys`   | [LOLDrivers link](https://github.com/magicsword-io/LOLDrivers/raw/main/drivers/2d8e4f38b36c334d0a32a7324832501d.bin) | 01aa278b07b58dc46c84bd0b1b5c8e9ee4e62ea0bf7a695862444af32e87f1fd |\n| `DBUtil_2_3.sys` | [LOLDrivers link](https://github.com/magicsword-io/LOLDrivers/raw/main/drivers/c996d7971c49252c582171d9380360f2.bin) | 0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5 |\n\n\n### Quick usage\n\n```\nUsage: EDRSandblast.exe [-h | --help] [-v | --verbose] <audit | dump | cmd | credguard | firewall | load_unsigned_driver>\n[--usermode] [--unhook-method <N>] [--direct-syscalls] [--add-dll <dll name or path>]*\n[--kernelmode] [--dont-unload-driver] [--no-restore]\n    [--nt-offsets <NtoskrnlOffsets.csv>] [--fltmgr-offsets <FltmgrOffsets.csv>] [--wdigest-offsets <WdigestOffsets.csv>] [--ci-offsets <CiOffsets.csv>] [--internet]\n    [--vuln-driver <RTCore64.sys>] [--vuln-service <SERVICE_NAME>]\n    [--unsigned-driver <evil.sys>] [--unsigned-service <SERVICE_NAME>]\n    [--no-kdp]\n[-o | --dump-output <DUMP_FILE>]\n```\n\n### Options\n\n```\n-h | --help             Show this help message and exit.\n-v | --verbose          Enable a more verbose output.\n\nActions mode:\n\n        audit                     Display the user-land hooks and / or Kernel callbacks without taking actions.\n        dump                      Dump the process specified by --process-name (LSASS process by default), as '<process_name>' in the current directory or at the\n                                  specified file using -o | --output <DUMP_FILE>.\n        cmd                       Open a cmd.exe prompt.\n        credguard                 Patch the LSASS process' memory to enable Wdigest cleartext passwords caching even if\n                                  Credential Guard is enabled on the host. No kernel-land actions required.\n        firewall                  Add Windows firewall rules to block network access for the EDR processes / services.\n        load_unsigned_driver      Load the specified unsigned driver, bypassing Driver Signature Enforcement (DSE).\n                                  WARNING: currently an experimental feature, only works if KDP is not present and enabled.\n\n--usermode              Perform user-land operations (DLL unhooking).\n--kernelmode            Perform kernel-land operations (Kernel callbacks removal and ETW TI disabling).\n\n\nHooking-related options:\n\n--add-dll <dll name or path>            Loads arbitrary libraries into the process' address space, before starting\n                                        anything.This can be useful to audit userland hooking for DLL that are not\n                                        loaded by default by this program. Use this option multiple times to load\n                                        multiple DLLs all at once.\n                                        Example of interesting DLLs to look at: user32.dll, ole32.dll, crypt32.dll,\n                                        samcli.dll, winhttp.dll, urlmon.dll, secur32.dll, shell32.dll...\n\n--unhook-method <N>                     Choose the userland un-hooking technique, from the following:\n\n        0                               Do not perform any unhooking (used for direct syscalls operations).\n        1 (Default)                     Uses the (probably monitored) NtProtectVirtualMemory function in ntdll to remove all\n                                        present userland hooks.\n        2                               Constructs a 'unhooked' (i.e. unmonitored) version of NtProtectVirtualMemory, by                                        allocating an executable trampoline jumping over the hook, and remove all present\n                                        userland hooks.\n        3                               Searches for an existing trampoline allocated by the EDR itself, to get an 'unhooked'\n                                        (i.e. unmonitored) version of NtProtectVirtualMemory, and remove all present userland\n                                        hooks.\n        4                               Loads an additional version of ntdll library into memory, and use the (hopefully                                        unmonitored) version of NtProtectVirtualMemory present in this library to remove all\n                                        present userland hooks.\n        5                               Allocates a shellcode that uses a direct syscall to call NtProtectVirtualMemory,                                        and uses it to remove all detected hooks\n\n--direct-syscalls       Use direct syscalls to dump the selected process memory without unhooking unserland hooks.\n\n\nBYOVD options:\n\n--dont-unload-driver                    Keep the vulnerable driver installed on the host\n                                        Default to automatically unsinstall the driver.\n--no-restore                            Do not restore the EDR drivers' Kernel Callbacks that were removed.\n                                        Default to restore the callbacks.\n--vuln-driver <gdrv.sys>                Path to the vulnerable driver file.\n                                        Default to 'gdrv.sys' in the current directory.\n--vuln-service <SERVICE_NAME>           Name of the vulnerable service to intall / start.\n\n\nDriver sideloading options:\n\n--unsigned-driver <evil.sys>            Path to the unsigned driver file.\n                                        Default to 'evil.sys' in the current directory.\n--unsigned-service <SERVICE_NAME>       Name of the unsigned driver's service to intall / start.\n--no-kdp                                Switch to g_CiOptions patching method for disabling DSE (default is callback swapping).\n\n\nOffset-related options:\n\n--nt-offsets <NtoskrnlOffsets.csv>      Path to the CSV file containing the required ntoskrnl.exe's offsets.\n                                        Default to 'NtoskrnlOffsets.csv' in the current directory.\n--fltmgr-offsets <FltmgrOffsets.csv>    Path to the CSV file containing the required fltmgr.sys's offsets\n                                        Default to 'FltmgrOffsets.csv' in the current directory.\n--wdigest-offsets <WdigestOffsets.csv>  Path to the CSV file containing the required wdigest.dll's offsets\n                                        (only for the 'credguard' mode).\n                                        Default to 'WdigestOffsets.csv' in the current directory.\n--ci-offsets <CiOffsets.csv>            Path to the CSV file containing the required ci.dll's offsets\n                                        (only for the 'load_unsigned_driver' mode).\n                                        Default to 'WdigestOffsets.csv' in the current directory.\n-i | --internet                         Enables automatic symbols download from Microsoft Symbol Server\n                                        If a corresponding *Offsets.csv file exists, appends the downloaded offsets to the file for later use\n                                        OpSec warning: downloads and drops on disk a PDB file for the corresponding image\n\nDump options:\n\n-o | --dump-output <DUMP_FILE>          Output path to the dump file that will be generated by the 'dump' mode.\n                                        Default to 'process_name' in the current directory.\n--process-name <NAME>                   File name of the process to dump (defaults to 'lsass.exe')\n```\n\n### Build\n\n`EDRSandBlast` (x64 only) was built on Visual Studio 2019 (Windows SDK\nVersion: `10.0.19041.0` and Plateform Toolset: `Visual Studio 2019 (v142)`).\n\n### ExtractOffsets.py usage\n\nNote that `ExtractOffsets.py` has only be tested on Windows.\n\n```\n# Installation of Python dependencies\npip.exe install -m .\\requirements.txt\n\n# Script usage\nExtractOffsets.py [-h] -i INPUT [-o OUTPUT] [-d] mode\n\npositional arguments:\n  mode                  ntoskrnl or wdigest. Mode to download and extract offsets for either ntoskrnl or wdigest\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i INPUT, --input INPUT\n                        Single file or directory containing ntoskrnl.exe / wdigest.dll to extract offsets from.\n                        If in download mode, the PE downloaded from MS symbols servers will be placed in this folder.\n  -o OUTPUT, --output OUTPUT\n                        CSV file to write offsets to. If the specified file already exists, only new ntoskrnl versions will be\n                        downloaded / analyzed.\n                        Defaults to NtoskrnlOffsets.csv / WdigestOffsets.csv in the current folder.\n  -d, --download         Flag to download the PE from Microsoft servers using list of versions from winbindex.m417z.com.\n```\n\n\n## Detection\nFrom the defender (EDR vendor, Microsoft, SOC analysts looking at EDR's telemetry, ...) point of view, multiple indicators can be used to detect or prevent this kind of techniques.\n\n### Driver whitelisting\nSince every action performed by the tool in kernel-mode memory relies on a vulnerable driver to read/write arbitrary content, driver loading events should be heaviliy scrutinized by EDR product (or SOC analysts), and raise an alert at any uncommon driver loading, or even block known vulnerable drivers. This latter approach is even [recommended by Microsoft themselves](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-driver-block-rules): any HVCI (*Hypervisor-protected code integrity*) enabled Windows device embeds a drivers blocklist, and this will be progressively become a default behaviour on Windows (it already is on Windows 11).\n\n### Kernel-memory integrity checks\nSince an attacker could still use an unknown vulnerable driver to perform the same actions in memory, the EDR driver could periodically check that its kernel callbacks are still registered, directly by inspecting kernel memory (like this tool does), or simply by triggering events (process creation, thread creation, image loading, etc.) and checking the callback functions are indeed called by the executive kernel.\n\nAs a side note, this type of data structure could be protected via the recent [Kernel Data Protection (KDP)](https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/) mechanism, which relies on Virtual Based Security, in order to make the kernel callbacks array non-writable without calling the right APIs.\n\nThe same logic could apply to sensitive ETW variables such as the `ProviderEnableInfo`, abused by this tool to disable the ETW Threat Intelligence events generation.\n\n### User-mode detection\nThe first indicator that a process is actively trying to evade user-land hooking is the file accesses to each DLL corresponding to loaded modules; in a normal execution, a userland process rarely needs to read DLL files outside of a `LoadLibrary` call, especially `ntdll.dll`.\n\nIn order to protect API hooking from being bypassed, EDR products could periodically check that hooks are not altered in memory, inside each monitored process.\n\nFinally, to detect hooking bypass (abusing a trampoline, using direct syscalls, etc.) that does not imply the hooks removal, EDR products could potentially rely on kernel callbacks associated to the abused syscalls (ex. `PsCreateProcessNotifyRoutine` for `NtCreateProcess` syscall, `ObRegisterCallbacks` for `NtOpenProcess` syscall, etc.), and perform user-mode call-stack analysis in order to determine if the syscall was triggered from a normal path (`kernel32.dll` -> `ntdll.dll` -> syscall) or an abnormal one (ex. `program.exe` -> direct syscall).\n\n\n## Acknowledgements\n\n- Kernel callbacks enumeration and removal:\n  https://github.com/br-sn/CheekyBlinder\n\n- Kernel memory Read / Write primitives through the vulnerable\n  `Micro-Star MSI Afterburner` driver:\n  https://github.com/Barakat/CVE-2019-16098/\n\n- Disabling of the ETW Threat Intelligence provider:\n  https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider\n\n- Driver install / uninstall: https://github.com/gentilkiwi/mimikatz\n\n- Initial list of EDR drivers names:\n  https://github.com/SadProcessor/SomeStuff/blob/master/Invoke-EDRCheck.ps1\n\n- Credential Guard bypass by re-enabling `Wdigest` through `LSASS` memory\n  patching: https://teamhydra.blog/2020/08/25/bypassing-credential-guard/\n\n\n## Authors\n\n[Thomas DIOT (Qazeer)](https://github.com/Qazeer/)\n[Maxime MEIGNAN (themaks)](https://github.com/themaks)\n\n## Thanks to contributors\n- [v1k1ngfr](https://github.com/v1k1ngfr): for Driver Signature Enforcement bypass (via `g_CiOptions` patching) and GDRV.sys driver support\n- [Windy Bug](https://github.com/0mWindyBug): for a KDP-compatible Driver Signature Enforcement bypass (via *callback swapping*) and their major contribution on the minifilter bypass feature\n\n\n## Licence\n\nCC BY 4.0 licence - https://creativecommons.org/licenses/by/4.0/\n"
        }
      ]
    }
  ]
}