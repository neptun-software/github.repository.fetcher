{
  "metadata": {
    "timestamp": 1736710231817,
    "page": 961,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "0x1abin/MultiButton",
      "stars": 1576,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2018 Zibin Zheng\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0615234375,
          "content": "# MultiButton\n\n## 简介\nMultiButton 是一个小巧简单易用的事件驱动型按键驱动模块，可无限量扩展按键，按键事件的回调异步处理方式可以简化你的程序结构，去除冗余的按键处理硬编码，让你的按键业务逻辑更清晰。\n\n## 使用方法\n1.先申请一个按键结构\n\n```c\nstruct Button button1;\n```\n2.初始化按键对象，绑定按键的GPIO电平读取接口**read_button_pin()** ，后一个参数设置有效触发电平\n\n```c\nbutton_init(&button1, read_button_pin, 0, 0);\n```\n3.注册按键事件\n\n```c\nbutton_attach(&button1, SINGLE_CLICK, Callback_SINGLE_CLICK_Handler);\nbutton_attach(&button1, DOUBLE_CLICK, Callback_DOUBLE_Click_Handler);\n...\n```\n4.启动按键\n\n```c\nbutton_start(&button1);\n```\n5.设置一个5ms间隔的定时器循环调用后台处理函数\n\n```c\nwhile(1) {\n    ...\n    if(timer_ticks == 5) {\n        timer_ticks = 0;\n\n        button_ticks();\n    }\n}\n```\n\n## 特性\n\nMultiButton 使用C语言实现，基于面向对象方式设计思路，每个按键对象单独用一份数据结构管理：\n\n```c\nstruct Button {\n\tuint16_t ticks;\n\tuint8_t  repeat: 4;\n\tuint8_t  event : 4;\n\tuint8_t  state : 3;\n\tuint8_t  debounce_cnt : 3;\n\tuint8_t  active_level : 1;\n\tuint8_t  button_level : 1;\n\tuint8_t  button_id;\n\tuint8_t  (*hal_button_Level)(uint8_t  button_id_);\n\tBtnCallback  cb[number_of_event];\n\tstruct Button* next;\n};\n```\n这样每个按键使用单向链表相连，依次进入 button_handler(struct Button* handle) 状态机处理，所以每个按键的状态彼此独立。\n\n\n## 按键事件\n\n事件 | 说明\n---|---\nPRESS_DOWN | 按键按下，每次按下都触发\nPRESS_UP | 按键弹起，每次松开都触发\nPRESS_REPEAT | 重复按下触发，变量repeat计数连击次数\nSINGLE_CLICK | 单击按键事件\nDOUBLE_CLICK | 双击按键事件\nLONG_PRESS_START | 达到长按时间阈值时触发一次\nLONG_PRESS_HOLD | 长按期间一直触发\n\n\n## Examples\n\n```c\n#include \"button.h\"\n\nuint8_t btn1_id = 0;\n\nstruct Button btn1;\n\nuint8_t read_button_GPIO(uint8_t button_id)\n{\n\t// you can share the GPIO read function with multiple Buttons\n\tswitch(button_id)\n\t{\n\t\tcase btn1_id:\n\t\t\treturn HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n}\nvoid BTN1_PRESS_DOWN_Handler(void* btn)\n{\n\t//do something...\n}\n\nvoid BTN1_PRESS_UP_Handler(void* btn)\n{\n\t//do something...\n}\n\n...\n\nint main()\n{\n\tbutton_init(&btn1, read_button_GPIO, 0, btn1_id);\n\tbutton_attach(&btn1, PRESS_DOWN,       BTN1_PRESS_DOWN_Handler);\n\tbutton_attach(&btn1, PRESS_UP,         BTN1_PRESS_UP_Handler);\n\tbutton_attach(&btn1, PRESS_REPEAT,     BTN1_PRESS_REPEAT_Handler);\n\tbutton_attach(&btn1, SINGLE_CLICK,     BTN1_SINGLE_Click_Handler);\n\tbutton_attach(&btn1, DOUBLE_CLICK,     BTN1_DOUBLE_Click_Handler);\n\tbutton_attach(&btn1, LONG_PRESS_START, BTN1_LONG_PRESS_START_Handler);\n\tbutton_attach(&btn1, LONG_PRESS_HOLD,  BTN1_LONG_PRESS_HOLD_Handler);\n\tbutton_start(&btn1);\n\n\t//make the timer invoking the button_ticks() interval 5ms.\n\t//This function is implemented by yourself.\n\t__timer_start(button_ticks, 0, 5);\n\n\twhile(1)\n\t{}\n}\n```\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "multi_button.c",
          "type": "blob",
          "size": 5.26171875,
          "content": "/*\n * Copyright (c) 2016 Zibin Zheng <znbin@qq.com>\n * All rights reserved\n */\n\n#include \"multi_button.h\"\n\n#define EVENT_CB(ev)   if(handle->cb[ev])handle->cb[ev]((void*)handle)\n#define PRESS_REPEAT_MAX_NUM  15 /*!< The maximum value of the repeat counter */\n\n//button handle list head.\nstatic struct Button* head_handle = NULL;\n\nstatic void button_handler(struct Button* handle);\n\n/**\n  * @brief  Initializes the button struct handle.\n  * @param  handle: the button handle struct.\n  * @param  pin_level: read the HAL GPIO of the connected button level.\n  * @param  active_level: pressed GPIO level.\n  * @param  button_id: the button id.\n  * @retval None\n  */\nvoid button_init(struct Button* handle, uint8_t(*pin_level)(uint8_t), uint8_t active_level, uint8_t button_id)\n{\n\tmemset(handle, 0, sizeof(struct Button));\n\thandle->event = (uint8_t)NONE_PRESS;\n\thandle->hal_button_Level = pin_level;\n\thandle->button_level = !active_level;\n\thandle->active_level = active_level;\n\thandle->button_id = button_id;\n}\n\n/**\n  * @brief  Attach the button event callback function.\n  * @param  handle: the button handle struct.\n  * @param  event: trigger event type.\n  * @param  cb: callback function.\n  * @retval None\n  */\nvoid button_attach(struct Button* handle, PressEvent event, BtnCallback cb)\n{\n\thandle->cb[event] = cb;\n}\n\n/**\n  * @brief  Inquire the button event happen.\n  * @param  handle: the button handle struct.\n  * @retval button event.\n  */\nPressEvent get_button_event(struct Button* handle)\n{\n\treturn (PressEvent)(handle->event);\n}\n\n/**\n  * @brief  Button driver core function, driver state machine.\n  * @param  handle: the button handle struct.\n  * @retval None\n  */\nstatic void button_handler(struct Button* handle)\n{\n\tuint8_t read_gpio_level = handle->hal_button_Level(handle->button_id);\n\n\t//ticks counter working..\n\tif((handle->state) > 0) handle->ticks++;\n\n\t/*------------button debounce handle---------------*/\n\tif(read_gpio_level != handle->button_level) { //not equal to prev one\n\t\t//continue read 3 times same new level change\n\t\tif(++(handle->debounce_cnt) >= DEBOUNCE_TICKS) {\n\t\t\thandle->button_level = read_gpio_level;\n\t\t\thandle->debounce_cnt = 0;\n\t\t}\n\t} else { //level not change ,counter reset.\n\t\thandle->debounce_cnt = 0;\n\t}\n\n\t/*-----------------State machine-------------------*/\n\tswitch (handle->state) {\n\tcase 0:\n\t\tif(handle->button_level == handle->active_level) {\t//start press down\n\t\t\thandle->event = (uint8_t)PRESS_DOWN;\n\t\t\tEVENT_CB(PRESS_DOWN);\n\t\t\thandle->ticks = 0;\n\t\t\thandle->repeat = 1;\n\t\t\thandle->state = 1;\n\t\t} else {\n\t\t\thandle->event = (uint8_t)NONE_PRESS;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\tif(handle->button_level != handle->active_level) { //released press up\n\t\t\thandle->event = (uint8_t)PRESS_UP;\n\t\t\tEVENT_CB(PRESS_UP);\n\t\t\thandle->ticks = 0;\n\t\t\thandle->state = 2;\n\t\t} else if(handle->ticks > LONG_TICKS) {\n\t\t\thandle->event = (uint8_t)LONG_PRESS_START;\n\t\t\tEVENT_CB(LONG_PRESS_START);\n\t\t\thandle->state = 5;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tif(handle->button_level == handle->active_level) { //press down again\n\t\t\thandle->event = (uint8_t)PRESS_DOWN;\n\t\t\tEVENT_CB(PRESS_DOWN);\n\t\t\tif(handle->repeat != PRESS_REPEAT_MAX_NUM) {\n\t\t\t\thandle->repeat++;\n\t\t\t}\n\t\t\tEVENT_CB(PRESS_REPEAT); // repeat hit\n\t\t\thandle->ticks = 0;\n\t\t\thandle->state = 3;\n\t\t} else if(handle->ticks > SHORT_TICKS) { //released timeout\n\t\t\tif(handle->repeat == 1) {\n\t\t\t\thandle->event = (uint8_t)SINGLE_CLICK;\n\t\t\t\tEVENT_CB(SINGLE_CLICK);\n\t\t\t} else if(handle->repeat == 2) {\n\t\t\t\thandle->event = (uint8_t)DOUBLE_CLICK;\n\t\t\t\tEVENT_CB(DOUBLE_CLICK); // repeat hit\n\t\t\t}\n\t\t\thandle->state = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif(handle->button_level != handle->active_level) { //released press up\n\t\t\thandle->event = (uint8_t)PRESS_UP;\n\t\t\tEVENT_CB(PRESS_UP);\n\t\t\tif(handle->ticks < SHORT_TICKS) {\n\t\t\t\thandle->ticks = 0;\n\t\t\t\thandle->state = 2; //repeat press\n\t\t\t} else {\n\t\t\t\thandle->state = 0;\n\t\t\t}\n\t\t} else if(handle->ticks > SHORT_TICKS) { // SHORT_TICKS < press down hold time < LONG_TICKS\n\t\t\thandle->state = 1;\n\t\t}\n\t\tbreak;\n\n\tcase 5:\n\t\tif(handle->button_level == handle->active_level) {\n\t\t\t//continue hold trigger\n\t\t\thandle->event = (uint8_t)LONG_PRESS_HOLD;\n\t\t\tEVENT_CB(LONG_PRESS_HOLD);\n\t\t} else { //released\n\t\t\thandle->event = (uint8_t)PRESS_UP;\n\t\t\tEVENT_CB(PRESS_UP);\n\t\t\thandle->state = 0; //reset\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\thandle->state = 0; //reset\n\t\tbreak;\n\t}\n}\n\n/**\n  * @brief  Start the button work, add the handle into work list.\n  * @param  handle: target handle struct.\n  * @retval 0: succeed. -1: already exist.\n  */\nint button_start(struct Button* handle)\n{\n\tstruct Button* target = head_handle;\n\twhile(target) {\n\t\tif(target == handle) return -1;\t//already exist.\n\t\ttarget = target->next;\n\t}\n\thandle->next = head_handle;\n\thead_handle = handle;\n\treturn 0;\n}\n\n/**\n  * @brief  Stop the button work, remove the handle off work list.\n  * @param  handle: target handle struct.\n  * @retval None\n  */\nvoid button_stop(struct Button* handle)\n{\n\tstruct Button** curr;\n\tfor(curr = &head_handle; *curr; ) {\n\t\tstruct Button* entry = *curr;\n\t\tif(entry == handle) {\n\t\t\t*curr = entry->next;\n//\t\t\tfree(entry);\n\t\t\treturn;//glacier add 2021-8-18\n\t\t} else {\n\t\t\tcurr = &entry->next;\n\t\t}\n\t}\n}\n\n/**\n  * @brief  background ticks, timer repeat invoking interval 5ms.\n  * @param  None.\n  * @retval None\n  */\nvoid button_ticks(void)\n{\n\tstruct Button* target;\n\tfor(target=head_handle; target; target=target->next) {\n\t\tbutton_handler(target);\n\t}\n}\n"
        },
        {
          "name": "multi_button.h",
          "type": "blob",
          "size": 1.326171875,
          "content": "/*\n * Copyright (c) 2016 Zibin Zheng <znbin@qq.com>\n * All rights reserved\n */\n\n#ifndef _MULTI_BUTTON_H_\n#define _MULTI_BUTTON_H_\n\n#include <stdint.h>\n#include <string.h>\n\n//According to your need to modify the constants.\n#define TICKS_INTERVAL    5\t//ms\n#define DEBOUNCE_TICKS    3\t//MAX 7 (0 ~ 7)\n#define SHORT_TICKS       (300 /TICKS_INTERVAL)\n#define LONG_TICKS        (1000 /TICKS_INTERVAL)\n\n\ntypedef void (*BtnCallback)(void*);\n\ntypedef enum {\n\tPRESS_DOWN = 0,\n\tPRESS_UP,\n\tPRESS_REPEAT,\n\tSINGLE_CLICK,\n\tDOUBLE_CLICK,\n\tLONG_PRESS_START,\n\tLONG_PRESS_HOLD,\n\tnumber_of_event,\n\tNONE_PRESS\n}PressEvent;\n\ntypedef struct Button {\n\tuint16_t ticks;\n\tuint8_t  repeat : 4;\n\tuint8_t  event : 4;\n\tuint8_t  state : 3;\n\tuint8_t  debounce_cnt : 3;\n\tuint8_t  active_level : 1;\n\tuint8_t  button_level : 1;\n\tuint8_t  button_id;\n\tuint8_t  (*hal_button_Level)(uint8_t button_id_);\n\tBtnCallback  cb[number_of_event];\n\tstruct Button* next;\n}Button;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid button_init(struct Button* handle, uint8_t(*pin_level)(uint8_t), uint8_t active_level, uint8_t button_id);\nvoid button_attach(struct Button* handle, PressEvent event, BtnCallback cb);\nPressEvent get_button_event(struct Button* handle);\nint  button_start(struct Button* handle);\nvoid button_stop(struct Button* handle);\nvoid button_ticks(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        }
      ]
    }
  ]
}