{
  "metadata": {
    "timestamp": 1736710156504,
    "page": 827,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cbsheng/tinyhttpd",
      "stars": 1733,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.083984375,
          "content": "all: httpd\n\nhttpd: httpd.c\n\tgcc -W -Wall -lpthread -o httpd httpd.c\n\nclean:\n\trm httpd\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.671875,
          "content": "  tinyhttpd 是一个简易的 http 服务器，支持CGI。代码量少，非常容易阅读，十分适合网络编程初学者学习的项目。\n  麻雀虽小，五脏俱全。在tinyhttpd中可以学到 linux 上进程的创建，管道的使用。linux 下 socket 编程基本方法和http 协议的最基本结构。\n  在学习过程中本人结合了《The linux programming interface》这本书在代码中做了详细的注释。如果对某些函数不熟悉或未曾见过的话，阅读本注释版是一个提高学习效率很好途径。\n  注释版只对部分重要的代码做注释，其余一切都保留下来，并未做任何的修改，包括源代码的缩进 :)\n  \n  example 文件夹不属于原项目，是本人写的简单示例代码\n\n  以下内容为原来 tinyhttpd 的 README 原版内容。\n\n\n  This software is copyright 1999 by J. David Blackstone.  Permission\nis granted to redistribute and modify this software under the terms of\nthe GNU General Public License, available at http://www.gnu.org/ .\n\n  If you use this software or examine the code, I would appreciate\nknowing and would be overjoyed to hear about it at\njdavidb@sourceforge.net .\n\n  This software is not production quality.  It comes with no warranty\nof any kind, not even an implied warranty of fitness for a particular\npurpose.  I am not responsible for the damage that will likely result\nif you use this software on your computer system.\n\n  I wrote this webserver for an assignment in my networking class in\n1999.  We were told that at a bare minimum the server had to serve\npages, and told that we would get extra credit for doing \"extras.\"\nPerl had introduced me to a whole lot of UNIX functionality (I learned\nsockets and fork from Perl!), and O'Reilly's lion book on UNIX system\ncalls plus O'Reilly's books on CGI and writing web clients in Perl got\nme thinking and I realized I could make my webserver support CGI with\nlittle trouble.\n\n  Now, if you're a member of the Apache core group, you might not be\nimpressed.  But my professor was blown over.  Try the color.cgi sample\nscript and type in \"chartreuse.\"  Made me seem smarter than I am, at\nany rate. :)\n\n  Apache it's not.  But I do hope that this program is a good\neducational tool for those interested in http/socket programming, as\nwell as UNIX system calls.  (There's some textbook uses of pipes,\nenvironment variables, forks, and so on.)\n\n  One last thing: if you look at my webserver or (are you out of\nmind?!?) use it, I would just be overjoyed to hear about it.  Please\nemail me.  I probably won't really be releasing major updates, but if\nI help you learn something, I'd love to know!\n\n  Happy hacking!\n\n                                   J. David Blackstone\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "htdocs",
          "type": "tree",
          "content": null
        },
        {
          "name": "httpd.c",
          "type": "blob",
          "size": 19.74609375,
          "content": "/* J. David's webserver */\n/* This is a simple webserver.\n * Created November 1999 by J. David Blackstone.\n * CSE 4344 (Network concepts), Prof. Zeigler\n * University of Texas at Arlington\n */\n/* This program compiles for Sparc Solaris 2.6.\n * To compile for Linux:\n *  1) Comment out the #include <pthread.h> line.\n *  2) Comment out the line that defines the variable newthread.\n *  3) Comment out the two lines that run pthread_create().\n *  4) Uncomment the line that runs accept_request().\n *  5) Remove -lsocket from the Makefile.\n */\n \n /*\n     代码中除了用到 C 语言标准库的一些函数，也用到了一些与环境有关的函数(例如POSIX标准)\n     具体可以参读《The Linux Programming Interface》，以下简称《TLPI》，页码指示均为英文版\n     \n     注释者： github: cbsheng\n */\n#include <stdio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <strings.h>\n#include <string.h>\n#include <sys/stat.h>\n//#include <pthread.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\n#define ISspace(x) isspace((int)(x))\n\n#define SERVER_STRING \"Server: jdbhttpd/0.1.0\\r\\n\"\n\nvoid accept_request(int);\nvoid bad_request(int);\nvoid cat(int, FILE *);\nvoid cannot_execute(int);\nvoid error_die(const char *);\nvoid execute_cgi(int, const char *, const char *, const char *);\nint get_line(int, char *, int);\nvoid headers(int, const char *);\nvoid not_found(int);\nvoid serve_file(int, const char *);\nint startup(u_short *);\nvoid unimplemented(int);\n\n/**********************************************************************/\n/* A request has caused a call to accept() on the server port to\n * return.  Process the request appropriately.\n * Parameters: the socket connected to the client */\n/**********************************************************************/\nvoid accept_request(int client)\n{\n char buf[1024];\n int numchars;\n char method[255];\n char url[255];\n char path[512];\n size_t i, j;\n struct stat st;\n int cgi = 0;      /* becomes true if server decides this is a CGI\n                    * program */\n char *query_string = NULL;\n\n //读http 请求的第一行数据（request line），把请求方法存进 method 中\n numchars = get_line(client, buf, sizeof(buf));\n i = 0; j = 0;\n while (!ISspace(buf[j]) && (i < sizeof(method) - 1))\n {\n  method[i] = buf[j];\n  i++; j++;\n }\n method[i] = '\\0';\n\n //如果请求的方法不是 GET 或 POST 任意一个的话就直接发送 response 告诉客户端没实现该方法\n if (strcasecmp(method, \"GET\") && strcasecmp(method, \"POST\"))\n {\n  unimplemented(client);\n  return;\n }\n\n //如果是 POST 方法就将 cgi 标志变量置一(true)\n if (strcasecmp(method, \"POST\") == 0)\n  cgi = 1;\n\n i = 0;\n //跳过所有的空白字符(空格)\n while (ISspace(buf[j]) && (j < sizeof(buf))) \n  j++;\n \n //然后把 URL 读出来放到 url 数组中\n while (!ISspace(buf[j]) && (i < sizeof(url) - 1) && (j < sizeof(buf)))\n {\n  url[i] = buf[j];\n  i++; j++;\n }\n url[i] = '\\0';\n\n //如果这个请求是一个 GET 方法的话\n if (strcasecmp(method, \"GET\") == 0)\n {\n  //用一个指针指向 url\n  query_string = url;\n  \n  //去遍历这个 url，跳过字符 ？前面的所有字符，如果遍历完毕也没找到字符 ？则退出循环\n  while ((*query_string != '?') && (*query_string != '\\0'))\n   query_string++;\n  \n  //退出循环后检查当前的字符是 ？还是字符串(url)的结尾\n  if (*query_string == '?')\n  {\n   //如果是 ？ 的话，证明这个请求需要调用 cgi，将 cgi 标志变量置一(true)\n   cgi = 1;\n   //从字符 ？ 处把字符串 url 给分隔会两份\n   *query_string = '\\0';\n   //使指针指向字符 ？后面的那个字符\n   query_string++;\n  }\n }\n\n //将前面分隔两份的前面那份字符串，拼接在字符串htdocs的后面之后就输出存储到数组 path 中。相当于现在 path 中存储着一个字符串\n sprintf(path, \"htdocs%s\", url);\n \n //如果 path 数组中的这个字符串的最后一个字符是以字符 / 结尾的话，就拼接上一个\"index.html\"的字符串。首页的意思\n if (path[strlen(path) - 1] == '/')\n  strcat(path, \"index.html\");\n \n //在系统上去查询该文件是否存在\n if (stat(path, &st) == -1) {\n  //如果不存在，那把这次 http 的请求后续的内容(head 和 body)全部读完并忽略\n  while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n   numchars = get_line(client, buf, sizeof(buf));\n  //然后返回一个找不到文件的 response 给客户端\n  not_found(client);\n }\n else\n {\n  //文件存在，那去跟常量S_IFMT相与，相与之后的值可以用来判断该文件是什么类型的\n  //S_IFMT参读《TLPI》P281，与下面的三个常量一样是包含在<sys/stat.h>\n  if ((st.st_mode & S_IFMT) == S_IFDIR)  \n   //如果这个文件是个目录，那就需要再在 path 后面拼接一个\"/index.html\"的字符串\n   strcat(path, \"/index.html\");\n   \n   //S_IXUSR, S_IXGRP, S_IXOTH三者可以参读《TLPI》P295\n  if ((st.st_mode & S_IXUSR) ||       \n      (st.st_mode & S_IXGRP) ||\n      (st.st_mode & S_IXOTH)    )\n   //如果这个文件是一个可执行文件，不论是属于用户/组/其他这三者类型的，就将 cgi 标志变量置一\n   cgi = 1;\n   \n  if (!cgi)\n   //如果不需要 cgi 机制的话，\n   serve_file(client, path);\n  else\n   //如果需要则调用\n   execute_cgi(client, path, method, query_string);\n }\n\n close(client);\n}\n\n/**********************************************************************/\n/* Inform the client that a request it has made has a problem.\n * Parameters: client socket */\n/**********************************************************************/\nvoid bad_request(int client)\n{\n char buf[1024];\n\n sprintf(buf, \"HTTP/1.0 400 BAD REQUEST\\r\\n\");\n send(client, buf, sizeof(buf), 0);\n sprintf(buf, \"Content-type: text/html\\r\\n\");\n send(client, buf, sizeof(buf), 0);\n sprintf(buf, \"\\r\\n\");\n send(client, buf, sizeof(buf), 0);\n sprintf(buf, \"<P>Your browser sent a bad request, \");\n send(client, buf, sizeof(buf), 0);\n sprintf(buf, \"such as a POST without a Content-Length.\\r\\n\");\n send(client, buf, sizeof(buf), 0);\n}\n\n/**********************************************************************/\n/* Put the entire contents of a file out on a socket.  This function\n * is named after the UNIX \"cat\" command, because it might have been\n * easier just to do something like pipe, fork, and exec(\"cat\").\n * Parameters: the client socket descriptor\n *             FILE pointer for the file to cat */\n/**********************************************************************/\nvoid cat(int client, FILE *resource)\n{\n char buf[1024];\n\n //从文件文件描述符中读取指定内容\n fgets(buf, sizeof(buf), resource);\n while (!feof(resource))\n {\n  send(client, buf, strlen(buf), 0);\n  fgets(buf, sizeof(buf), resource);\n }\n}\n\n/**********************************************************************/\n/* Inform the client that a CGI script could not be executed.\n * Parameter: the client socket descriptor. */\n/**********************************************************************/\nvoid cannot_execute(int client)\n{\n char buf[1024];\n\n sprintf(buf, \"HTTP/1.0 500 Internal Server Error\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"Content-type: text/html\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"<P>Error prohibited CGI execution.\\r\\n\");\n send(client, buf, strlen(buf), 0);\n}\n\n/**********************************************************************/\n/* Print out an error message with perror() (for system errors; based\n * on value of errno, which indicates system call errors) and exit the\n * program indicating an error. */\n/**********************************************************************/\nvoid error_die(const char *sc)\n{\n //包含于<stdio.h>,基于当前的 errno 值，在标准错误上产生一条错误消息。参考《TLPI》P49\n perror(sc); \n exit(1);\n}\n\n/**********************************************************************/\n/* Execute a CGI script.  Will need to set environment variables as\n * appropriate.\n * Parameters: client socket descriptor\n *             path to the CGI script */\n/**********************************************************************/\nvoid execute_cgi(int client, const char *path,\n                 const char *method, const char *query_string)\n{\n char buf[1024];\n int cgi_output[2];\n int cgi_input[2];\n pid_t pid;\n int status;\n int i;\n char c;\n int numchars = 1;\n int content_length = -1;\n \n //往 buf 中填东西以保证能进入下面的 while\n buf[0] = 'A'; buf[1] = '\\0';\n //如果是 http 请求是 GET 方法的话读取并忽略请求剩下的内容\n if (strcasecmp(method, \"GET\") == 0)\n  while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n   numchars = get_line(client, buf, sizeof(buf));\n else    /* POST */\n {\n  //只有 POST 方法才继续读内容\n  numchars = get_line(client, buf, sizeof(buf));\n  //这个循环的目的是读出指示 body 长度大小的参数，并记录 body 的长度大小。其余的 header 里面的参数一律忽略\n  //注意这里只读完 header 的内容，body 的内容没有读\n  while ((numchars > 0) && strcmp(\"\\n\", buf))\n  {\n   buf[15] = '\\0';\n   if (strcasecmp(buf, \"Content-Length:\") == 0)\n    content_length = atoi(&(buf[16])); //记录 body 的长度大小\n   numchars = get_line(client, buf, sizeof(buf));\n  }\n  \n  //如果 http 请求的 header 没有指示 body 长度大小的参数，则报错返回\n  if (content_length == -1) {\n   bad_request(client);\n   return;\n  }\n }\n\n sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n send(client, buf, strlen(buf), 0);\n\n //下面这里创建两个管道，用于两个进程间通信\n if (pipe(cgi_output) < 0) {\n  cannot_execute(client);\n  return;\n }\n if (pipe(cgi_input) < 0) {\n  cannot_execute(client);\n  return;\n }\n\n //创建一个子进程\n if ( (pid = fork()) < 0 ) {\n  cannot_execute(client);\n  return;\n }\n \n //子进程用来执行 cgi 脚本\n if (pid == 0)  /* child: CGI script */\n {\n  char meth_env[255];\n  char query_env[255];\n  char length_env[255];\n\n  //dup2()包含<unistd.h>中，参读《TLPI》P97\n  //将子进程的输出由标准输出重定向到 cgi_ouput 的管道写端上\n  dup2(cgi_output[1], 1);\n  //将子进程的输出由标准输入重定向到 cgi_ouput 的管道读端上\n  dup2(cgi_input[0], 0);\n  //关闭 cgi_ouput 管道的读端与cgi_input 管道的写端\n  close(cgi_output[0]);\n  close(cgi_input[1]);\n  \n  //构造一个环境变量\n  sprintf(meth_env, \"REQUEST_METHOD=%s\", method);\n  //putenv()包含于<stdlib.h>中，参读《TLPI》P128\n  //将这个环境变量加进子进程的运行环境中\n  putenv(meth_env);\n  \n  //根据http 请求的不同方法，构造并存储不同的环境变量\n  if (strcasecmp(method, \"GET\") == 0) {\n   sprintf(query_env, \"QUERY_STRING=%s\", query_string);\n   putenv(query_env);\n  }\n  else {   /* POST */\n   sprintf(length_env, \"CONTENT_LENGTH=%d\", content_length);\n   putenv(length_env);\n  }\n  \n  //execl()包含于<unistd.h>中，参读《TLPI》P567\n  //最后将子进程替换成另一个进程并执行 cgi 脚本\n  execl(path, path, NULL);\n  exit(0);\n  \n } else {    /* parent */\n  //父进程则关闭了 cgi_output管道的写端和 cgi_input 管道的读端\n  close(cgi_output[1]);\n  close(cgi_input[0]);\n  \n  //如果是 POST 方法的话就继续读 body 的内容，并写到 cgi_input 管道里让子进程去读\n  if (strcasecmp(method, \"POST\") == 0)\n   for (i = 0; i < content_length; i++) {\n    recv(client, &c, 1, 0);\n    write(cgi_input[1], &c, 1);\n   }\n   \n  //然后从 cgi_output 管道中读子进程的输出，并发送到客户端去\n  while (read(cgi_output[0], &c, 1) > 0)\n   send(client, &c, 1, 0);\n\n  //关闭管道\n  close(cgi_output[0]);\n  close(cgi_input[1]);\n  //等待子进程的退出\n  waitpid(pid, &status, 0);\n }\n}\n\n/**********************************************************************/\n/* Get a line from a socket, whether the line ends in a newline,\n * carriage return, or a CRLF combination.  Terminates the string read\n * with a null character.  If no newline indicator is found before the\n * end of the buffer, the string is terminated with a null.  If any of\n * the above three line terminators is read, the last character of the\n * string will be a linefeed and the string will be terminated with a\n * null character.\n * Parameters: the socket descriptor\n *             the buffer to save the data in\n *             the size of the buffer\n * Returns: the number of bytes stored (excluding null) */\n/**********************************************************************/\nint get_line(int sock, char *buf, int size)\n{\n int i = 0;\n char c = '\\0';\n int n;\n\n while ((i < size - 1) && (c != '\\n'))\n {\n  //recv()包含于<sys/socket.h>,参读《TLPI》P1259, \n  //读一个字节的数据存放在 c 中\n  n = recv(sock, &c, 1, 0);\n  /* DEBUG printf(\"%02X\\n\", c); */\n  if (n > 0)\n  {\n   if (c == '\\r')\n   {\n    //\n    n = recv(sock, &c, 1, MSG_PEEK);\n    /* DEBUG printf(\"%02X\\n\", c); */\n    if ((n > 0) && (c == '\\n'))\n     recv(sock, &c, 1, 0);\n    else\n     c = '\\n';\n   }\n   buf[i] = c;\n   i++;\n  }\n  else\n   c = '\\n';\n }\n buf[i] = '\\0';\n\n return(i);\n}\n\n/**********************************************************************/\n/* Return the informational HTTP headers about a file. */\n/* Parameters: the socket to print the headers on\n *             the name of the file */\n/**********************************************************************/\nvoid headers(int client, const char *filename)\n{\n char buf[1024];\n (void)filename;  /* could use filename to determine file type */\n\n strcpy(buf, \"HTTP/1.0 200 OK\\r\\n\");\n send(client, buf, strlen(buf), 0);\n strcpy(buf, SERVER_STRING);\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"Content-Type: text/html\\r\\n\");\n send(client, buf, strlen(buf), 0);\n strcpy(buf, \"\\r\\n\");\n send(client, buf, strlen(buf), 0);\n}\n\n/**********************************************************************/\n/* Give a client a 404 not found status message. */\n/**********************************************************************/\nvoid not_found(int client)\n{\n char buf[1024];\n\n sprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, SERVER_STRING);\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"Content-Type: text/html\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"<HTML><TITLE>Not Found</TITLE>\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"<BODY><P>The server could not fulfill\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"your request because the resource specified\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"is unavailable or nonexistent.\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"</BODY></HTML>\\r\\n\");\n send(client, buf, strlen(buf), 0);\n}\n\n/**********************************************************************/\n/* Send a regular file to the client.  Use headers, and report\n * errors to client if they occur.\n * Parameters: a pointer to a file structure produced from the socket\n *              file descriptor\n *             the name of the file to serve */\n/**********************************************************************/\nvoid serve_file(int client, const char *filename)\n{\n FILE *resource = NULL;\n int numchars = 1;\n char buf[1024];\n\n //确保 buf 里面有东西，能进入下面的 while 循环\n buf[0] = 'A'; buf[1] = '\\0';\n //循环作用是读取并忽略掉这个 http 请求后面的所有内容\n while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n  numchars = get_line(client, buf, sizeof(buf));\n\n //打开这个传进来的这个路径所指的文件\n resource = fopen(filename, \"r\");\n if (resource == NULL)\n  not_found(client);\n else\n {\n  //打开成功后，将这个文件的基本信息封装成 response 的头部(header)并返回\n  headers(client, filename);\n  //接着把这个文件的内容读出来作为 response 的 body 发送到客户端\n  cat(client, resource);\n }\n \n fclose(resource);\n}\n\n/**********************************************************************/\n/* This function starts the process of listening for web connections\n * on a specified port.  If the port is 0, then dynamically allocate a\n * port and modify the original port variable to reflect the actual\n * port.\n * Parameters: pointer to variable containing the port to connect on\n * Returns: the socket */\n/**********************************************************************/\nint startup(u_short *port)\n{\n int httpd = 0;\n //sockaddr_in 是 IPV4的套接字地址结构。定义在<netinet/in.h>,参读《TLPI》P1202\n struct sockaddr_in name;\n \n //socket()用于创建一个用于 socket 的描述符，函数包含于<sys/socket.h>。参读《TLPI》P1153\n //这里的PF_INET其实是与 AF_INET同义，具体可以参读《TLPI》P946\n httpd = socket(PF_INET, SOCK_STREAM, 0);\n if (httpd == -1)\n  error_die(\"socket\");\n  \n memset(&name, 0, sizeof(name));\n name.sin_family = AF_INET;\n //htons()，ntohs() 和 htonl()包含于<arpa/inet.h>, 参读《TLPI》P1199\n //将*port 转换成以网络字节序表示的16位整数\n name.sin_port = htons(*port);\n //INADDR_ANY是一个 IPV4通配地址的常量，包含于<netinet/in.h>\n //大多实现都将其定义成了0.0.0.0 参读《TLPI》P1187\n name.sin_addr.s_addr = htonl(INADDR_ANY);\n \n //bind()用于绑定地址与 socket。参读《TLPI》P1153\n //如果传进去的sockaddr结构中的 sin_port 指定为0，这时系统会选择一个临时的端口号\n if (bind(httpd, (struct sockaddr *)&name, sizeof(name)) < 0)\n  error_die(\"bind\");\n  \n //如果调用 bind 后端口号仍然是0，则手动调用getsockname()获取端口号\n if (*port == 0)  /* if dynamically allocating a port */\n {\n  int namelen = sizeof(name);\n  //getsockname()包含于<sys/socker.h>中，参读《TLPI》P1263\n  //调用getsockname()获取系统给 httpd 这个 socket 随机分配的端口号\n  if (getsockname(httpd, (struct sockaddr *)&name, &namelen) == -1)\n   error_die(\"getsockname\");\n  *port = ntohs(name.sin_port);\n }\n \n //最初的 BSD socket 实现中，backlog 的上限是5.参读《TLPI》P1156\n if (listen(httpd, 5) < 0) \n  error_die(\"listen\");\n return(httpd);\n}\n\n/**********************************************************************/\n/* Inform the client that the requested web method has not been\n * implemented.\n * Parameter: the client socket */\n/**********************************************************************/\nvoid unimplemented(int client)\n{\n char buf[1024];\n\n sprintf(buf, \"HTTP/1.0 501 Method Not Implemented\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, SERVER_STRING);\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"Content-Type: text/html\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"<HTML><HEAD><TITLE>Method Not Implemented\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"</TITLE></HEAD>\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"<BODY><P>HTTP request method not supported.\\r\\n\");\n send(client, buf, strlen(buf), 0);\n sprintf(buf, \"</BODY></HTML>\\r\\n\");\n send(client, buf, strlen(buf), 0);\n}\n\n/**********************************************************************/\n\nint main(void)\n{\n int server_sock = -1;\n u_short port = 0;\n int client_sock = -1;\n //sockaddr_in 是 IPV4的套接字地址结构。定义在<netinet/in.h>,参读《TLPI》P1202\n struct sockaddr_in client_name;\n int client_name_len = sizeof(client_name);\n //pthread_t newthread;\n\n server_sock = startup(&port);\n printf(\"httpd running on port %d\\n\", port);\n\n while (1)\n {\n  //阻塞等待客户端的连接，参读《TLPI》P1157\n  client_sock = accept(server_sock,\n                       (struct sockaddr *)&client_name,\n                       &client_name_len);\n  if (client_sock == -1)\n   error_die(\"accept\");\n  accept_request(client_sock);\n /*if (pthread_create(&newthread , NULL, accept_request, client_sock) != 0)\n   perror(\"pthread_create\");*/\n }\n\n close(server_sock);\n\n return(0);\n}\n"
        },
        {
          "name": "simpleclient.c",
          "type": "blob",
          "size": 1.1396484375,
          "content": "#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[])\n{\n int sockfd;\n int len;\n struct sockaddr_in address;\n int result;\n char ch = 'A';\n\n //申请一个流 socket\n sockfd = socket(AF_INET, SOCK_STREAM, 0);\n //填充地址结构，指定服务器的 IP 和 端口\n address.sin_family = AF_INET;\n //inet_addr 可以参考 man inet_addr\n //可以用现代的inet_pton()替代inet_addr(), example 中有参考例子\n address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n address.sin_port = htons(9734);\n len = sizeof(address);\n \n //下面的语句可以输出连接的 IP 地址\n //但是inet_ntoa()是过时的方法，应该改用 inet_ntop(可参考 example)。但很多代码仍然遗留着inet_ntoa.\n //printf(\"%s\\n\", inet_ntoa( address.sin_addr));\n \n result = connect(sockfd, (struct sockaddr *)&address, len);\n\n if (result == -1)\n {\n  perror(\"oops: client1\");\n  exit(1);\n }\n \n //往服务端写一个字节\n write(sockfd, &ch, 1);\n //从服务端读一个字符\n read(sockfd, &ch, 1);\n printf(\"char from server = %c\\n\", ch);\n close(sockfd);\n exit(0);\n}\n"
        }
      ]
    }
  ]
}