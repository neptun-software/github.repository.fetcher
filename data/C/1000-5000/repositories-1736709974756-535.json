{
  "metadata": {
    "timestamp": 1736709974756,
    "page": 535,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mvp/uhubctl",
      "stars": 2263,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.087890625,
          "content": "# Executables\nuhubctl\n\n# Object files\n*.o\n\n# Mac symbols\n*.dSYM\n\n# Patches\n*.patch\n*.diff\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Formula",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.689453125,
          "content": "uhubctl – USB hub per-port power control.\n\nCopyright (c) 2009-2024, Vadim Mikhailov\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, version 2.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1279296875,
          "content": "# uhubctl Makefile\n#\nUNAME_S := $(shell uname -s)\n\nDESTDIR ?=\nprefix  ?= /usr\nsbindir ?= $(prefix)/sbin\n\nINSTALL\t\t:= install\nINSTALL_DIR\t:= $(INSTALL) -m 755 -d\nINSTALL_PROGRAM\t:= $(INSTALL) -m 755\nRM\t\t:= rm -rf\nPKG_CONFIG\t?= pkg-config\n\nCC ?= gcc\nCFLAGS ?= -g -O0\nCFLAGS += -Wall -Wextra -std=c99 -pedantic\nGIT_VERSION := $(shell git describe --match \"v[0-9]*\" --abbrev=8 --dirty --tags | cut -c2-)\nifeq ($(GIT_VERSION),)\n\tGIT_VERSION := $(shell cat VERSION)\nendif\nCFLAGS += -DPROGRAM_VERSION=\\\"$(GIT_VERSION)\\\"\n\n# Use hardening options on Linux\nifeq ($(UNAME_S),Linux)\n\tLDFLAGS += -Wl,-zrelro,-znow\nendif\n\n# Use pkg-config if available\nifneq (,$(shell which $(PKG_CONFIG)))\n\tCFLAGS  += $(shell $(PKG_CONFIG) --cflags libusb-1.0)\n\tLDFLAGS += $(shell $(PKG_CONFIG) --libs libusb-1.0)\nelse\n# But it should still build if pkg-config is not available (e.g. Linux or Mac homebrew)\n\tLDFLAGS += -lusb-1.0\nendif\n\nPROGRAM = uhubctl\n\n$(PROGRAM): $(PROGRAM).c\n\t$(CC) $(CPPFLAGS) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\ninstall:\n\t$(INSTALL_DIR) $(DESTDIR)$(sbindir)\n\t$(INSTALL_PROGRAM) $(PROGRAM) $(DESTDIR)$(sbindir)\n\nclean:\n\t$(RM) $(PROGRAM).o $(PROGRAM).dSYM $(PROGRAM)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 30.10546875,
          "content": "uhubctl\n=======\n\n`uhubctl` is utility to control USB power per-port on smart USB hubs.\nSmart hub is defined as one that implements per-port power switching.\n\nOriginal idea for this code was inspired by hub-ctrl.c by Niibe Yutaka:\nhttps://www.gniibe.org/development/ac-power-control-by-USB-hub\n\n\nCompatible USB hubs\n===================\n\nNote that very few hubs actually support per-port power switching.\nSome of them are no longer manufactured and can be hard to find.\n\nThis is list of known compatible USB hubs:\n\n| Manufacturer       | Product                                              | Ports | USB | VID:PID   | Release | EOL  |\n|:-------------------|:-----------------------------------------------------|:------|:----|:----------|:--------|:-----|\n| Acer               | BE270U monitor ([see](https://tinyurl.com/acer550))  | 4     | 3.0 |`2109:2811`| 2016    |      |\n| AmazonBasics       | HU3641V1 ([RPi issue](https://goo.gl/CLt46M))        | 4     | 3.0 |`2109:2811`| 2013    |      |\n| AmazonBasics       | HU3770V1 ([RPi issue](https://goo.gl/CLt46M))        | 7     | 3.0 |`2109:2811`| 2013    |      |\n| AmazonBasics       | HU9003V1EBL, HUC9003V1EBL                            | 7     | 3.1 |`2109:2817`| 2018    |      |\n| AmazonBasics       | HU9002V1SBL, HU9002V1EBL, HU9002V1ESL ([note](https://bit.ly/3awM2Ei)) | 10    | 3.1 |`2109:2817`| 2018    |      |\n| AmazonBasics       | HUC9002V1SBL, HUC9002V1EBL, HUC9002V1ESL             | 10    | 3.1 |`2109:2817`| 2018    |      |\n| AmazonBasics       | U3-7HUB (only works for 1 charge port)               | 7     | 3.0 |`2109:2813`| 2020    |      |\n| Anker              | AK-68ANHUB-BV7A-0004 ([note](https://git.io/JLnZb))  | 7     | 3.0 |`2109:0812`| 2014    |      |\n| Apple              | Pro Display XDR MWPE2LL/A (internal USB hub)         | 4     | 2.0 |`05AC:9139`| 2019    |      |\n| Apple              | Thunderbolt Display 27\" (internal USB hub)           | 6     | 2.0 |           | 2011    | 2016 |\n| Apple              | USB Keyboard With Numeric Pad (internal USB hub)     | 3     | 2.0 |           | 2011    |      |\n| Asus               | Z77 Sabertooth Motherboard (onboard USB hub)         | 6     | 2.0 |           | 2012    |      |\n| Asus               | Z87-PLUS Motherboard (onboard USB hub)               | 4     | 3.0 |           | 2013    | 2016 |\n| Aukey              | CB-C59                                               | 4     | 3.0 |`2109:2813`| 2017    |      |\n| B+B SmartWorx      | UHR204                                               | 4     | 2.0 |`0856:DB00`| 2013    |      |\n| B+B SmartWorx      | USH304                                               | 4     | 3.0 |`04B4:6506`| 2017    | 2019 |\n| Basler             | 2000036234                                           | 4     | 3.0 |`0451:8046`| 2016    |      |\n| Belkin             | F5U101                                               | 4     | 2.0 |`0451:2046`| 2005    | 2010 |\n| Belkin             | F5U238UKCRL-MOB                                      | 4     | 2.0 |`0409:0059`| 2004    | 2010 |\n| BenQ               | PD2700U 4K Monitor (works only in USB2 mode)         | 4     | 3.0 |`05E3:0610`| 2018    |      |\n| BenQ               | PD3220U                                              | 4     | 3.1 |`05E3:0610`| 2019    |      |\n| Bytecc             | BT-UH340 ([warning](https://bit.ly/35BNi5U))         | 4     | 3.0 |`2109:8110`| 2010    |      |\n| Centech            | CT-USB4HUB ReTRY HUB                                 | 4     | 3.0 |`0424:2744`| 2017    |      |\n| Circuitco          | Beagleboard-xM (internal USB hub)                    | 4     | 2.0 |`0424:9514`| 2010    |      |\n| Club3D             | CSV-3242HD Dual Display Docking Station              | 4     | 3.0 |`2109:2811`| 2015    |      |\n| Coolgear           | USBG-12U2ML                                          | 12    | 2.0 |`05e3:0607`| 2015    |      |\n| Cypress            | CY4608 HX2VL devkit ([note](https://bit.ly/3sMPfpu)) | 4     | 2.0 |`04B4:6570`| 2012    |      |\n| D-Link             | DUB-H4 rev D,E (black). Note: rev A,C,F not supported| 4     | 2.0 |`05E3:0608`| 2012    |      |\n| D-Link             | DUB-H7 rev A (silver)                                | 7     | 2.0 |`2001:F103`| 2005    | 2010 |\n| D-Link             | DUB-H7 rev D,E (black). Rev B,C,F,G not supported    | 7     | 2.0 |`05E3:0608`| 2012    |      |\n| Dell               | P2416D 24\" QHD Monitor ([note](https://git.io/JUAu8))| 4     | 2.0 |           | 2017    |      |\n| Dell               | S2719DGF 27\" WQHD Gaming-Monitor                     | 5     | 3.0 |`0424:5734`| 2018    |      |\n| Dell               | UltraSharp 1704FPT 17\" LCD Monitor                   | 4     | 2.0 |`0424:A700`| 2005    | 2015 |\n| Dell               | UltraSharp U2415 24\" LCD Monitor                     | 5     | 3.0 |           | 2014    |      |\n| Dell               | UltraSharp U3419W 34\" Curved Monitor                 | 6     | 3.0 |           | 2020    |      |\n| Dell               | Wyse 3040 ([-f required](https://tinyurl.com/wyse3k))| 6     | 3.0 |           | 2017    |      |\n| Delock             | 62537                                                | 4     | 3.0 |           | 2017    | 2021 |\n| Delock             | 87445 ([note](https://git.io/Jsuz5))                 | 4     | 2.0 |`05E3:0608`| 2009    | 2013 |\n| Elecom             | U2H-G4S                                              | 4     | 2.0 |           | 2006    | 2011 |\n| Gigabyte           | G27Q monitor ([see](http://tinyurl.com/G27Q551)      | 4     | 3.0 |`2109:0817`| 2020    |      |\n| GlobalScale        | ESPRESSObin SBUD102 V5                               | 1     | 3.0 |`1D6B:0003`| 2017    |      |\n| Hardkernel         | ODROID-C4 ([note](https://git.io/JG0mP))             | 4     | 3.0 |           | 2020    |      |\n| Hawking Technology | UH214                                                | 4     | 2.0 |           | 2003    | 2008 |\n| Hewlett Packard    | USB-C Dock G5 5TW10AA                                | 5     | 3.0 |`03F0:076B`| 2019    |      |\n| Hewlett Packard    | P5Q58UT                                              | 3     | 3.0 |           | 2019    |      |\n| Inateck            | HB2025A ([USB2 only](https://bit.ly/3wXF5UO))        | 4     | 3.1 |`2109:2822`| 2021    |      |\n| IOI                | U3H415E1                                             | 4     | 3.0 |           | 2012    |      |\n| j5create           | JUH377 ([note](https://bit.ly/3Mx9eQI))              | 7     | 3.0 |           | 2016    |      |\n| j5create           | JUH470 ([note](https://bit.ly/3CRWamP))              | 3     | 3.0 |`05E3:0610`| 2014    |      |\n| Juiced Systems     | 6HUB-01                                              | 7     | 3.0 |`0BDA:0411`| 2014    | 2018 |\n| KUNBUS GmbH        | RevPi Connect (+) / S / SE                           | 2     | 2.0 |`0424:9514`| 2018    |      |\n| KUNBUS GmbH        | RevPi Connect 4                                      | 2     | 3.0 |           | 2022    |      |\n| KUNBUS GmbH        | RevPi Core 3 / S / SE                                | 2     | 2.0 |`0424:9514`| 2017    |      |\n| LG Electronics     | 27MD5KL-B monitor                                    | 4     | 3.0 |`043E:9A60`| 2019    |      |\n| LG Electronics     | 27GL850-B monitor                                    | 4     | 3.0 |`0451:8142`| 2019    |      |\n| LG Electronics     | 27UK850-W monitor                                    | 2     | 3.0 |           | 2018    |      |\n| LG Electronics     | 27UN83A-W monitor                                    | 2     | 3.0 |`0451:8142`| 2020    |      |\n| LG Electronics     | 38WK95C-W monitor                                    | 4     | 3.0 |`0451:8142`| 2018    |      |\n| Lenovo             | ThinkPad Ultra Docking Station (40A20090EU)          | 6     | 2.0 |`17EF:100F`| 2015    |      |\n| Lenovo             | ThinkPad Ultra Docking Station (40AJ0135EU)          | 7     | 3.1 |`17EF:3070`| 2018    |      |\n| Lenovo             | ThinkPad X200 Ultrabase 42X4963                      | 3     | 2.0 |`17EF:1005`| 2008    | 2011 |\n| Lenovo             | ThinkPad X6 Ultrabase 42W3107                        | 4     | 2.0 |`17EF:1000`| 2006    | 2009 |\n| Lenovo             | ThinkPlus 4-in-1 USB-C hub 4X90W86497                | 3     | 3.0 |           | 2021    |      |\n| Lenovo             | ThinkVision T24i-10 Monitor                          | 4     | 2.0 |`17EF:0610`| 2018    |      |\n| Lenovo             | USB-C to 4 Port USB-A Hub                            | 4     | 2.0 |`17EF:103A`| 2020    |      |\n| Lindy              | USB serial converter 4 port                          | 4     | 1.1 |`058F:9254`| 2008    |      |\n| Linksys            | USB2HUB4 ([note](https://git.io/JYiDZ))              | 4     | 2.0 |           | 2004    | 2010 |\n| Maplin             | A08CQ                                                | 7     | 2.0 |`0409:0059`| 2008    | 2011 |\n| Metadot            | Das Keyboard 4                                       | 2     | 3.0 |           | 2014    |      |\n| Microchip          | EVB9512                                              | 2     | 2.0 |           | 2009    |      |\n| Microchip          | EVB-USB2517                                          | 7     | 2.0 |           | 2008    |      |\n| Microchip          | EVB-USB2534BC                                        | 4     | 2.0 |           | 2013    |      |\n| Microchip          | EVB-USB5807                                          | 7     | 3.0 |           | 2016    |      |\n| Moxa               | Uport-407                                            | 7     | 2.0 |`110A:0407`| 2009    |      |\n| NVidia             | Jetson Nano B01 ([details](https://git.io/JJaFR))    | 4     | 3.0 |           | 2019    |      |\n| NVidia             | Jetson Xavier NX ([details](https://bit.ly/3PN2DDp)) | 4     | 3.0 |           | 2020    |      |\n| Phidgets           | HUB0003_0                                            | 7     | 2.0 |`1A40:0201`| 2017    |      |\n| Philips            | 346B1C UltraWide 34\" Curved Monitor                  | 4     | 3.0 |`05E3:0610`| 2019    |      |\n| Plugable           | USB3-HUB7BC                                          | 7     | 3.0 |`2109:0813`| 2015    |      |\n| Plugable           | USB3-HUB7C (only works for 2 charge ports)           | 7     | 3.0 |`2109:0813`| 2015    |      |\n| Plugable           | USBC-HUB7BC (works for 6/7 ports, not the rightmost) | 7     | 3.0 |`2109:0817`| 2021    |      |\n| Plugable           | USB3-HUB10-C2 (only works for 2 charge ports)        | 10    | 3.0 |           | 2014    |      |\n| Port Inc           | NWUSB01                                              | 4     | 1.1 |`0451:1446`| 1999    | 2003 |\n| Raspberry Pi       | B+, 2B, 3B ([see below](#raspberry-pi-b2b3b))        | 4     | 2.0 |           | 2011    |      |\n| Raspberry Pi       | 3B+        ([see below](#raspberry-pi-3b))           | 4     | 2.0 |`0424:2514`| 2018    |      |\n| Raspberry Pi       | 4B         ([see below](#raspberry-pi-4b))           | 4     | 3.0 |`2109:3431`| 2019    |      |\n| Raspberry Pi       | 5          ([see below](#raspberry-pi-5))            | 4     | 3.0 |`1d6b:0002`| 2023    |      |\n| Renesas            | uPD720202 PCIe USB 3.0 host controller               | 2     | 3.0 |           | 2013    |      |\n| Rosewill           | RHUB-210                                             | 4     | 2.0 |`0409:005A`| 2011    | 2014 |\n| Rosonway           | RSH-518C ([note](https://bit.ly/3kYZUsA))            | 7     | 3.0 |`2109:0817`| 2021    |      |\n| Rosonway           | RSH-A10 ([see](https://tinyurl.com/2ppyyaj8))        | 10    | 3.0 |`0bda:0411`| 2020    |      |\n| Rosonway           | RSH-A13 ([warning](https://bit.ly/3OToUOL))          | 13    | 3.1 |`2109:2822`| 2021    |      |\n| Rosonway           | RSH-A16 ([note](https://git.io/JTawg), [warning](https://bit.ly/39B0tGS)) | 16    | 3.0 |`0bda:0411`| 2020    |      |\n| Rosonway           | RSH-A104 ([USB2 only](https://bit.ly/3A0qiKF))       | 4     | 3.1 |`2109:2822`| 2022    |      |\n| Rosonway           | RSH-A107 (aka ikuai A107-5)                          | 7     | 3.1 |`0bda:5411`| 2022    |      |\n| Rosonway           | RSH-ST07C ([only 4](https://tinyurl.com/4pjnujrn))   | 7     | 3.0 |`2109:2822`| 2023    |      |\n| Sanwa Supply       | USB-HUB14GPH                                         | 4     | 1.1 |           | 2001    | 2003 |\n| Seagate            | Backup Plus Hub STEL8000100                          | 2     | 3.0 |`0BC2:AB44`| 2016    |      |\n| Seeed Studio       | reTerminal CM4104032                                 | 2     | 2.0 |`0424:2514`| 2021    |      |\n| StarTech           | DKT30CSDHPD3 USB-C Travel Dock                       | 3     | 3.0 |`2109:2817`| 2018    |      |\n| StarTech           | HB30A4AIB ([warning](https://tinyurl.com/ycxravwk))  | 4     | 3.0 |`2109:2817`| 2018    |      |\n| Sunix              | SHB4200MA                                            | 4     | 2.0 |`0409:0058`| 2006    | 2009 |\n| System Talks       | Sugoi USB2-HUB4X                                     | 4     | 2.0 |           | 2007    |      |\n| Targus             | PA095UZ                                              | 2     | 2.0 |           | 2004    |      |\n| Targus             | PAUH212/PAUH212U                                     | 7     | 2.0 |           | 2004    | 2009 |\n| Texas Instruments  | TUSB4041PAPEVM                                       | 4     | 2.1 |`0451:8142`| 2015    |      |\n| UUGear             | MEGA4 (for Raspberry Pi 4B)                          | 4     | 3.0 |`2109:0817`| 2021    |      |\n| VirtualHere        | USB3 4-port hub ([note](https://tinyurl.com/vhusb))  | 4     | 3.0 |           | 2024    |      |\n\nThis table is by no means complete.\nIf your hub works with `uhubctl`, but is not listed above, please report it\nby opening new issue at https://github.com/mvp/uhubctl/issues,\nso we can add it to supported table. In your report, please provide\nexact product model and add output from `uhubctl`\nand please test VBUS off support as described below in FAQ.\n\nNote that quite a few modern motherboards have built-in root hubs that\ndo support this feature - you may not even need to buy any external hub.\n\n\nUSB 3.0 duality note\n====================\nIf you have USB 3.0 hub connected to USB3 upstream port, it will be detected\nas 2 independent virtual hubs: USB2 and USB3, and your USB devices will be connected\nto USB2 or USB3 virtual hub depending on their capabilities and connection speed.\nTo control power for such hubs, it is necessary to turn off/on power on **both** USB2 and USB3\nvirtual hubs for power off/on changes to take effect. `uhubctl` will try to do this automatically\n(unless you disable this behavior with option `-e`).\n\nUnfortunately, while most hubs will cut off data USB connection, some may still not cut off VBUS to port,\nwhich means connected phone may still continue to charge from port that is powered off by `uhubctl`.\n\n\nCompiling\n=========\n\nThis utility was tested to compile and work on Linux\n(Ubuntu/Debian, Redhat/Fedora/CentOS, Arch Linux, Gentoo, openSUSE, Buildroot), FreeBSD, NetBSD, SunOS and MacOS.\n\nWhile `uhubctl` compiles on Windows, USB power switching does not work on Windows because `libusb`\nis using `winusb.sys` driver, which according to Microsoft does not support\n[necessary USB control requests](https://social.msdn.microsoft.com/Forums/sqlserver/en-US/f680b63f-ca4f-4e52-baa9-9e64f8eee101).\nThis may be fixed if `libusb` starts supporting different driver on Windows.\n\nNote that it is highly recommended to have `pkg-config` installed (many platforms provide it by default).\n\nFirst, you need to install library libusb-1.0 (version 1.0.12 or later, 1.0.16 or later is recommended):\n\n* Ubuntu: `sudo apt-get install libusb-1.0-0-dev`\n* Redhat: `sudo yum install libusb1-devel`\n* OpenSUSE: `sudo zypper install libusb-1_0-devel`\n* MacOS: `brew install libusb`, or `sudo port install libusb-devel`\n* FreeBSD: libusb is included by default\n* NetBSD: `sudo pkgin install libusb1 gmake pkg-config`\n* Windows: TBD?\n\nTo fetch uhubctl source and compile it:\n\n    git clone https://github.com/mvp/uhubctl\n    cd uhubctl\n    make\n\nThis should generate `uhubctl` binary.\nYou can install it in your system as `/usr/sbin/uhubctl` using:\n\n    sudo make install\n\nNote that on some OS (e.g. FreeBSD/NetBSD) you need to use `gmake` instead to build.\n\nAlso, on MacOS you can install `uhubctl` with all necessary dependencies in one shot using Homebrew tap:\n\n```\nbrew tap mvp/uhubctl https://github.com/mvp/uhubctl\nbrew install uhubctl\n```\nTo build/install from master branch, use `--HEAD`:\n```\nbrew install uhubctl --HEAD\n```\n\nUsage\n=====\n\n> :warning: On Linux, use `sudo` or configure USB permissions as described below!\n\nTo list all supported hubs:\n\n    uhubctl\n\nYou can control the power on a USB port(s) like this:\n\n    uhubctl -a off -p 2\n\nThis means operate on default smart hub and turn power off (`-a off`, or `-a 0`)\non port 2 (`-p 2`). Supported actions are `off`/`on`/`cycle`/`toggle` (or `0`/`1`/`2`/`3`).\n`cycle` means turn power off, wait some delay (configurable with `-d`) and turn it back on.\nPorts can be comma separated list, and may use `-` for ranges e.g. `2`, or `2,4`, or `2-5`, or `1-2,5-8`.\n\n> :warning: Turning off built-in USB ports may cut off your keyboard or mouse,\nso be careful which ports you are turning off!\n\nIf you have more than one smart USB hub connected, you should choose\nspecific hub to control using `-l` (location) parameter.\nTo find hub locations, simply run `uhubctl` without any parameters.\nHub locations look like `b-x.y.z`, where `b` is USB bus number, and `x`, `y`, `z`...\nare port numbers for all hubs in chain, starting from root hub for a given USB bus.\nThis address is semi-stable - it will not change if you unplug/replug (or turn off/on)\nUSB device into the same physical USB port (this method is also used in Linux kernel).\n\n\nLinux USB permissions\n=====================\n\nOn Linux, you should configure `udev` USB permissions (otherwise you will have to run it as root using `sudo uhubctl`).\n\nStarting with Linux Kernel 6.0 there is a standard interface to turn USB hub ports on or off,\nand `uhubctl` will try to use it (instead of `libusb`) to set the port status.\nThis is why there are additional rules for 6.0+ kernels.\nThere is no harm in having these rules on systems running older kernel versions.\n\nTo fix USB permissions, first run `sudo uhubctl` and note all `vid:pid` for hubs you need to control.\nThen, add udev rules like below to file `/etc/udev/rules.d/52-usb.rules`\n(replace `2001` with your hub vendor id, or completely remove `ATTR{idVendor}` filter to allow any USB hub access):\n\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", MODE=\"0666\", ATTR{idVendor}==\"2001\"\n    # Linux 6.0 or later (its ok to have this block present for older Linux kernels):\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", \\\n      RUN=\"/bin/sh -c \\\"chmod -f 666 $sys$devpath/*-port*/disable || true\\\"\"\n\nNote that for USB3 hubs, some hubs use different vendor ID for USB2 vs USB3 components of the same chip,\nand both need permissions to make uhubctl work properly.\nE.g. for Raspberry Pi 4B, you need to add these 2 lines (or remove idVendor filter):\n\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", MODE=\"0666\", ATTR{idVendor}==\"2109\"\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", MODE=\"0666\", ATTR{idVendor}==\"1d6b\"\n\nIf you don't like wide open mode `0666`, you can restrict access by group like this:\n\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", MODE=\"0664\", GROUP=\"dialout\"\n    # Linux 6.0 or later (its ok to have this block present for older Linux kernels):\n    SUBSYSTEM==\"usb\", DRIVER==\"usb\", \\\n      RUN+=\"/bin/sh -c \\\"chown -f root:dialout $sys$devpath/*-port*/disable || true\\\"\" \\\n      RUN+=\"/bin/sh -c \\\"chmod -f 660 $sys$devpath/*-port*/disable || true\\\"\"\n\nand then add permitted users to `dialout` group:\n\n    sudo usermod -a -G dialout $USER\n\nFor your `udev` rule changes to take effect, reboot or run:\n\n    sudo udevadm trigger --attr-match=subsystem=usb\n\nFor your convenience, ready to use udev rule is provided [here](https://github.com/mvp/uhubctl/blob/master/udev/rules.d/52-usb.rules).\n\n\nFAQ\n===\n\n#### _What is USB per-port power switching?_\n\nAccording to USB 2.0 specification, USB hubs can advertise no power switching,\nganged (all ports at once) power switching or per-port (individual) power switching.\nNote that by default `uhubctl` will only detect USB hubs which support per-port power switching\n(but you can force it to try operating on unsupported hubs with option `-f`).\nYou can find what kind of power switching your hardware supports by using `sudo lsusb -v`:\n\nNo power switching:\n\n    wHubCharacteristic 0x000a\n      No power switching (usb 1.0)\n      Per-port overcurrent protection\n\nGanged power switching:\n\n    wHubCharacteristic 0x0008\n      Ganged power switching\n      Per-port overcurrent protection\n\nPer-port power switching:\n\n    wHubCharacteristic 0x0009\n      Per-port power switching\n      Per-port overcurrent protection\n\n\n#### _How do I check if my USB hub is supported by `uhubctl`?_\n\n1. Run `sudo uhubctl`. If your hub is not listed, it is not supported.\n   Alternatively, you can run `sudo lsusb -v` and check for\n   `Per-port power switching` -  if you cannot see such line in lsusb output,\n   hub is not supported.\n2. Check for VBUS (voltage) off support: plug a phone, USB light\n    or USB fan into USB port of your hub.\n   Try using `uhubctl` to turn power off on that port, and check\n   that phone stops charging, USB light stops shining or USB fan stops spinning.\n   If VBUS doesn't turn off, your hub manufacturer did not include circuitry\n   to actually cut power off. Such hub would still work\n   to cut off USB data connection, but it cannot turn off power,\n   and we do not consider this supported device.\n3. If tests above were successful, please report your hub\n   by opening new issue at https://github.com/mvp/uhubctl/issues,\n   so we can add it to list of supported devices.\n   Please do not report unsupported hubs, unless it is different\n   hardware revision of some already listed supported model.\n\n\n#### _USB devices are not removed after port power down on Linux_\n\nAfter powering down USB port, udev does not get any event, so it keeps the device files around.\nHowever, trying to access the device files will lead to an IO error.\n\nThis is Linux kernel [issue](https://bit.ly/2JzczjZ) and is [fixed](https://github.com/mvp/uhubctl/pull/450)\nsince uhubctl 2.5.0 for systems with Linux kernel 6.0 or later.\n\nIf you are still using Linux 5.x or older, you can use this workaround for this issue:\n\n    sudo uhubctl -a off -l ${location} -p ${port}\n    sudo udevadm trigger --action=remove /sys/bus/usb/devices/${location}.${port}/\n\nDevice file will be removed by udev, but USB device will be still visible in `lsusb`.\nNote that path `/sys/bus/usb/devices/${location}.${port}` will only exist if device was detected on that port.\nWhen you turn power back on, device should re-enumerate properly (no need to call `udevadm` again).\n\n#### _Power comes back on after few seconds on Linux_\n\nSome device drivers in kernel are surprised by USB device being turned off and automatically try to power it back on.\n\nThis is Linux kernel [issue](https://bit.ly/2JzczjZ) and is [fixed](https://github.com/mvp/uhubctl/pull/450)\nsince uhubctl 2.5.0 for systems with Linux kernel 6.0 or later.\n\nIf you are still using Linux 5.x or older:\n\nYou can use option `-r N`, where N is some number from 10 to 1000 to fix this -\n`uhubctl` will try to turn power off many times in quick succession, and it should suppress that.\n\nDisabling USB authorization for device in question before turning power off with `uhubctl` should help:\n\n    echo 0 > sudo tee /sys/bus/usb/devices/${location}.${port}/authorized\n\nIf your device is USB mass storage, invoking `udisksctl` before calling `uhubctl` should help too:\n\n    sudo udisksctl power-off --block-device /dev/disk/...`\n    sudo uhubctl -a off ...\n\n\n#### _Multiple 4-port hubs are detected, but I only have one 7-port hub connected_\n\nMany hub manufacturers build their USB hubs using basic 4 port USB chips.\nE.g. to make 7 port hub, they daisy-chain two 4 port hubs - 1 port is lost to daisy-chaining,\nso it makes it 4+4-1=7 port hub. Similarly, 10 port hub could be built as 3 4-port hubs\ndaisy-chained together, which gives 4+4+4-2=10 usable ports.\n\nNote that you should never try to change power state for ports used to daisy-chain internal hubs together.\nDoing so will confuse internal hub circuitry and will cause unpredictable behavior.\n\n\n#### _Raspberry Pi turns power off on all ports, not just the one I specified_\n\nThis is the limitation of Raspberry Pi hardware design.\nAs a workaround, you can buy any external USB hub from supported list above,\nattach it to any USB port of Raspberry Pi, and control power on its ports independently.\nAlso, there are supported hubs designed specifically for Raspberry Pi, e.g. UUGear MEGA4.\n\nFor reference, supported Raspberry Pi models have following internal USB topology:\n\n##### Raspberry Pi B+,2B,3B\n\n  * Single hub `1-1`, ports 2-5 ganged, all controlled by port `2`:\n\n        uhubctl -l 1-1 -p 2 -a 0\n\n    Trying to control ports `3`,`4`,`5` will not do anything.\n    Port `1` controls power for Ethernet+WiFi.\n\n##### Raspberry Pi 3B+\n\n  * Main hub `1-1`, all 4 ports ganged, all controlled by port `2` (turns off secondary hub ports as well).\n    Port `1` connects hub `1-1.1` below, ports `2` and `3` are wired outside, port `4` not wired.\n\n        uhubctl -l 1-1 -p 2 -a 0\n\n  * Secondary hub `1-1.1` (daisy-chained to main): 3 ports,\n    port `1` is used for Ethernet+WiFi, and ports `2` and `3` are wired outside.\n\n\n##### Raspberry Pi 4B\n\n > :warning: If your VL805 firmware is older than `00137ad` (check with `sudo rpi-eeprom-update`),\nyou have to [update firmware](https://www.raspberrypi.org/documentation/hardware/raspberrypi/booteeprom.md)\nto make power switching work on RPi 4B.\n\n  * USB2 hub `1`, 1 port, only connects hub `1-1` below.\n\n  * USB2 hub `1-1`, 4 ports ganged, dual to USB3 hub `2` below:\n\n        uhubctl -l 1-1 -a 0\n\n  * USB3 hub `2`, 4 ports ganged, dual to USB2 hub `1-1` above:\n\n        uhubctl -l 2 -a 0\n\n  * USB2 hub `3`, 1 port, OTG controller. Power switching is [not supported](https://git.io/JUc5Q).\n\n##### Raspberry Pi 5\n\n  Raspberry Pi 5 has two USB2 ports and two USB3 ports (total 4).\nThese ports are connected to 4 distinct USB hubs `1`,`2`,`3`,`4` in really weird configuration\n(but depending on OS and HW revision hubs of interest can be `2`,`3`,`4`,`5`).\nIf USB3 device is connected to blue socket, it will be detected on USB3 hub `2` or `4`.\nIf USB2 device is connected to any socket or USB3 device connected to black socket,\nit will be detected on USB2 hub `1` or `3`.\nRegardless of USB2/USB3 connection type, blue sockets are always port `1`,\nand black sockets are always port `2`.\n\n  Each of 4 USB onboard hubs advertises as supporting per-port power switching, but this is not true.\nIn reality, Raspberry Pi 5 all 4 ports are ganged together in one group,\ndespite belonging to 4 different logical USB hubs.\n\nTo turn off VBUS power it has to be disabled across all onboard hubs and ports with:\n\n   ```\n   uhubctl -l 2 -a 0\n   uhubctl -l 4 -a 0\n   ```\n\nTo turn it back on:\n\n   ```\n   uhubctl -l 2 -a 1\n   uhubctl -l 4 -a 1\n   ```\n\nNote that VBUS power goes down only if all ports are off -\nenabling any single port enables VBUS back for all 4 ports.\n\nNotable projects using uhubctl\n==============================\n| Project                                                  | Description                                             |\n|:---------------------------------------------------------|:--------------------------------------------------------|\n| [Morse code USB light](https://git.io/fj1F4)             | Flash a message in Morse code with USB light            |\n| [Webcam USB light](https://git.io/fj1FB)                 | Turn on/off LED when webcam is turned on/off            |\n| [Cinema Lightbox](https://goo.gl/fjCvkz)                 | Turn on/off Cinema Lightbox from iOS Home app           |\n| [Build Status Light](https://goo.gl/3GA82o)              | Create a build status light in under 10 minutes         |\n| [Buildenlights](https://git.io/fj1FC)                    | GitLab/GitHub project build status as green/red light   |\n| [Weather Station](https://goo.gl/3b1FzC)                 | Reset Weather Station when it freezes                   |\n| [sysmoQMOD](https://bit.ly/2VtWrVt)                      | Reset cellular modems when necessary                    |\n| [Smog Sensor](https://bit.ly/2EMwgCk)                    | Raspberry Pi based smog sensor power reset              |\n| [Terrible Cluster](https://goo.gl/XjiXFu)                | Power on/off Raspberry Pi cluster nodes as needed       |\n| [Ideal Music Server](https://bit.ly/39MeVFQ)             | Turn off unused USB ports to improve audio quality      |\n| [USB drives with no phantom load](https://goo.gl/qfrmGK) | Power USB drives only when needed to save power         |\n| [USB drive data recovery](https://goo.gl/4MddLr)         | Recover data from failing USB hard drive                |\n| [Control power to 3D printer](https://git.io/fh5Tr)      | OctoPrint web plugin for USB power control              |\n| [USB fan for Raspberry Pi](https://bit.ly/2TRV6sM)       | Control USB fan to avoid Raspberry Pi overheating       |\n| [Raspberry Pi Reboot Router](https://bit.ly/3aNbQqs)     | Automatically reboot router if internet isn't working   |\n| [Control USB Lamp With Voice](https://bit.ly/2VtW2SX)    | Voice Control of USB Lamp using Siri and Raspberry Pi   |\n| [Control USB LED Strip](https://bit.ly/3oVWfeZ)          | Controlling USB powered LED Light Strip                 |\n| [Brew beer with Raspberry Pi](https://git.io/JtbLd)      | Automated beer brewing system using Raspberry Pi        |\n| [Webcam On-Air Sign](https://bit.ly/3witNsa)             | Automatically light up a sign when webcam is in use     |\n| [Do it yourself PPPS](https://git.io/J3lHs)              | Solder wires in your USB hub to support uhubctl         |\n| [Open source PPPS hub](https://tinyurl.com/yckhystt)     | Open source hardware project for uhubctl compatible hub |\n| [Python Wrapper for uhubctl](https://github.com/nbuchwitz/python3-uhubctl) | Module to use uhubctl with Python     |\n| [labgrid](https://github.com/labgrid-project/labgrid)    | Framework for testing embedded Linux on hardware        |\n\n\nCopyright\n=========\n\nCopyright (C) 2009-2024 Vadim Mikhailov\n\nThis file can be distributed under the terms and conditions of the\nGNU General Public License version 2.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "2.6.0\n"
        },
        {
          "name": "udev",
          "type": "tree",
          "content": null
        },
        {
          "name": "uhubctl.c",
          "type": "blob",
          "size": 44.2177734375,
          "content": "/*\n * Copyright (c) 2009-2024 Vadim Mikhailov\n *\n * Utility to turn USB port power on/off\n * for USB hubs that support per-port power switching.\n *\n * This file can be distributed under the terms and conditions of the\n * GNU General Public License version 2.\n *\n */\n\n#define _XOPEN_SOURCE 600\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <getopt.h>\n#include <errno.h>\n#include <ctype.h>\n#include <fcntl.h>\n\n#if defined(_WIN32)\n#include <windows.h>\n#include <io.h>\n#include <process.h>\n#define strcasecmp _stricmp\n#define strncasecmp _strnicmp\n#else\n#include <unistd.h>\n#endif\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(_WIN32)\n#include <libusb.h>\n#else\n#include <libusb-1.0/libusb.h>\n#endif\n\n#if !defined(LIBUSB_API_VERSION) || (LIBUSB_API_VERSION <= 0x01000103)\n#define LIBUSB_DT_SUPERSPEED_HUB 0x2a\n#endif\n\n#if _POSIX_C_SOURCE >= 199309L\n#include <time.h>   /* for nanosleep */\n#endif\n\n\n/* cross-platform sleep function */\n\nvoid sleep_ms(int milliseconds)\n{\n#if defined(_WIN32)\n    Sleep(milliseconds);\n#elif _POSIX_C_SOURCE >= 199309L\n    struct timespec ts;\n    ts.tv_sec = milliseconds / 1000;\n    ts.tv_nsec = (milliseconds % 1000) * 1000000;\n    nanosleep(&ts, NULL);\n#else\n    usleep(milliseconds * 1000);\n#endif\n}\n\n/* Max number of hub ports supported */\n#define MAX_HUB_PORTS            14\n#define ALL_HUB_PORTS            ((1 << MAX_HUB_PORTS) - 1) /* bitmask */\n\n#define USB_CTRL_GET_TIMEOUT     5000\n\n#define USB_PORT_FEAT_POWER      (1 << 3)\n\n#define POWER_KEEP               (-1)\n#define POWER_OFF                0\n#define POWER_ON                 1\n#define POWER_CYCLE              2\n#define POWER_TOGGLE             3\n#define POWER_FLASH              4\n\n#define MAX_HUB_CHAIN            8  /* Per USB 3.0 spec max hub chain is 7 */\n\n/* Partially borrowed from linux/usb/ch11.h */\n\n#pragma pack(push,1)\nstruct usb_hub_descriptor {\n    unsigned char bDescLength;\n    unsigned char bDescriptorType;\n    unsigned char bNbrPorts;\n    unsigned char wHubCharacteristics[2];\n    unsigned char bPwrOn2PwrGood;\n    unsigned char bHubContrCurrent;\n    unsigned char data[1]; /* use 1 to avoid zero-sized array warning */\n};\n#pragma pack(pop)\n\n/*\n * Hub Status and Hub Change results\n * See USB 2.0 spec Table 11-19 and Table 11-20\n */\n#pragma pack(push,1)\nstruct usb_port_status {\n    int16_t wPortStatus;\n    int16_t wPortChange;\n};\n#pragma pack(pop)\n\n/*\n * wPortStatus bit field\n * See USB 2.0 spec Table 11-21\n */\n#define USB_PORT_STAT_CONNECTION        0x0001\n#define USB_PORT_STAT_ENABLE            0x0002\n#define USB_PORT_STAT_SUSPEND           0x0004\n#define USB_PORT_STAT_OVERCURRENT       0x0008\n#define USB_PORT_STAT_RESET             0x0010\n#define USB_PORT_STAT_L1                0x0020\n/* bits 6 to 7 are reserved */\n#define USB_PORT_STAT_POWER             0x0100\n#define USB_PORT_STAT_LOW_SPEED         0x0200\n#define USB_PORT_STAT_HIGH_SPEED        0x0400\n#define USB_PORT_STAT_TEST              0x0800\n#define USB_PORT_STAT_INDICATOR         0x1000\n/* bits 13 to 15 are reserved */\n\n\n#define USB_SS_BCD                      0x0300\n/*\n * Additions to wPortStatus bit field from USB 3.0\n * See USB 3.0 spec Table 10-10\n */\n#define USB_PORT_STAT_LINK_STATE        0x01e0\n#define USB_SS_PORT_STAT_POWER          0x0200\n#define USB_SS_PORT_STAT_SPEED          0x1c00\n#define USB_PORT_STAT_SPEED_5GBPS       0x0000\n/* Valid only if port is enabled */\n/* Bits that are the same from USB 2.0 */\n#define USB_SS_PORT_STAT_MASK (USB_PORT_STAT_CONNECTION  | \\\n                               USB_PORT_STAT_ENABLE      | \\\n                               USB_PORT_STAT_OVERCURRENT | \\\n                               USB_PORT_STAT_RESET)\n\n/*\n * Definitions for PORT_LINK_STATE values\n * (bits 5-8) in wPortStatus\n */\n#define USB_SS_PORT_LS_U0               0x0000\n#define USB_SS_PORT_LS_U1               0x0020\n#define USB_SS_PORT_LS_U2               0x0040\n#define USB_SS_PORT_LS_U3               0x0060\n#define USB_SS_PORT_LS_SS_DISABLED      0x0080\n#define USB_SS_PORT_LS_RX_DETECT        0x00a0\n#define USB_SS_PORT_LS_SS_INACTIVE      0x00c0\n#define USB_SS_PORT_LS_POLLING          0x00e0\n#define USB_SS_PORT_LS_RECOVERY         0x0100\n#define USB_SS_PORT_LS_HOT_RESET        0x0120\n#define USB_SS_PORT_LS_COMP_MOD         0x0140\n#define USB_SS_PORT_LS_LOOPBACK         0x0160\n\n\n/*\n * wHubCharacteristics (masks)\n * See USB 2.0 spec Table 11-13, offset 3\n */\n#define HUB_CHAR_LPSM           0x0003 /* Logical Power Switching Mode mask */\n#define HUB_CHAR_COMMON_LPSM    0x0000 /* All ports at once power switching */\n#define HUB_CHAR_INDV_PORT_LPSM 0x0001 /* Per-port power switching */\n#define HUB_CHAR_NO_LPSM        0x0002 /* No power switching */\n\n#define HUB_CHAR_COMPOUND       0x0004 /* hub is part of a compound device */\n\n#define HUB_CHAR_OCPM           0x0018 /* Over-Current Protection Mode mask */\n#define HUB_CHAR_COMMON_OCPM    0x0000 /* All ports at once over-current protection */\n#define HUB_CHAR_INDV_PORT_OCPM 0x0008 /* Per-port over-current protection */\n#define HUB_CHAR_NO_OCPM        0x0010 /* No over-current protection support */\n\n#define HUB_CHAR_TTTT           0x0060 /* TT Think Time mask */\n#define HUB_CHAR_PORTIND        0x0080 /* per-port indicators (LEDs) */\n\n/* List of all USB devices enumerated by libusb */\nstatic struct libusb_device **usb_devs = NULL;\n\nstruct descriptor_strings {\n    char vendor[64];\n    char product[64];\n    char serial[64];\n    char description[512];\n};\n\nstruct hub_info {\n    struct libusb_device *dev;\n    int bcd_usb;\n    int super_speed; /* 1 if super speed hub, and 0 otherwise */\n    int nports;\n    int lpsm; /* logical power switching mode */\n    int actionable; /* true if this hub is subject to action */\n    char container_id[33]; /* container ID as hex string */\n    char vendor[16];\n    char location[32];\n    uint8_t bus;\n    uint8_t port_numbers[MAX_HUB_CHAIN];\n    int pn_len; /* length of port numbers */\n    struct descriptor_strings ds;\n};\n\n/* Array of all enumerated USB hubs */\n#define MAX_HUBS 128\nstatic struct hub_info hubs[MAX_HUBS];\nstatic int hub_count = 0;\nstatic int hub_phys_count = 0;\n\n/* default options */\nstatic char opt_vendor[16]   = \"\";\nstatic char opt_search[64]   = \"\";     /* Search by attached device description */\nstatic char opt_location[32] = \"\";     /* Hub location a-b.c.d */\nstatic int opt_level = 0;              /* Hub location level (e.g., a-b is level 2, a-b.c is level 3)*/\nstatic int opt_ports  = ALL_HUB_PORTS; /* Bitmask of ports to operate on */\nstatic int opt_action = POWER_KEEP;\nstatic double opt_delay = 2;\nstatic int opt_repeat = 1;\nstatic int opt_wait   = 20; /* wait before repeating in ms */\nstatic int opt_exact  = 0;  /* exact location match - disable USB3 duality handling */\nstatic int opt_reset  = 0;  /* reset hub after operation(s) */\nstatic int opt_force  = 0;  /* force operation even on unsupported hubs */\nstatic int opt_nodesc = 0;  /* skip querying device description */\n#if defined(__gnu_linux__) || defined(__linux__)\nstatic int opt_nosysfs = 0; /* don't use the Linux sysfs port disable interface, even if available */\n#endif\n\n/* For Raspberry Pi detection and workarounds: */\nstatic int is_rpi_4b = 0;\nstatic int is_rpi_5  = 0;\n\nstatic const char short_options[] =\n    \"l:L:n:a:p:d:r:w:s:hvefRN\"\n#if defined(__gnu_linux__) || defined(__linux__)\n    \"S\"\n#endif\n;\n\nstatic const struct option long_options[] = {\n    { \"location\", required_argument, NULL, 'l' },\n    { \"vendor\",   required_argument, NULL, 'n' },\n    { \"search\",   required_argument, NULL, 's' },\n    { \"level\",    required_argument, NULL, 'L' },\n    { \"ports\",    required_argument, NULL, 'p' },\n    { \"action\",   required_argument, NULL, 'a' },\n    { \"delay\",    required_argument, NULL, 'd' },\n    { \"repeat\",   required_argument, NULL, 'r' },\n    { \"wait\",     required_argument, NULL, 'w' },\n    { \"exact\",    no_argument,       NULL, 'e' },\n    { \"force\",    no_argument,       NULL, 'f' },\n    { \"nodesc\",   no_argument,       NULL, 'N' },\n#if defined(__gnu_linux__) || defined(__linux__)\n    { \"nosysfs\",  no_argument,       NULL, 'S' },\n#endif\n    { \"reset\",    no_argument,       NULL, 'R' },\n    { \"version\",  no_argument,       NULL, 'v' },\n    { \"help\",     no_argument,       NULL, 'h' },\n    { 0,          0,                 NULL, 0   },\n};\n\n\nstatic int print_usage(void)\n{\n    printf(\n        \"uhubctl: utility to control USB port power for smart hubs.\\n\"\n        \"Usage: uhubctl [options]\\n\"\n        \"Without options, show status for all smart hubs.\\n\"\n        \"\\n\"\n        \"Options [defaults in brackets]:\\n\"\n        \"--action,   -a - action to off/on/cycle/toggle/flash (0/1/2/3/4) for affected ports.\\n\"\n        \"--ports,    -p - ports to operate on    [all hub ports].\\n\"\n        \"--location, -l - limit hub by location  [all smart hubs].\\n\"\n        \"--level     -L - limit hub by location level (e.g. a-b.c is level 3).\\n\"\n        \"--vendor,   -n - limit hub by vendor id [%s] (partial ok).\\n\"\n        \"--search,   -s - limit hub by attached device description.\\n\"\n        \"--delay,    -d - delay for cycle/flash action [%g sec].\\n\"\n        \"--repeat,   -r - repeat power off count [%d] (some devices need it to turn off).\\n\"\n        \"--exact,    -e - exact location (no USB3 duality handling).\\n\"\n        \"--force,    -f - force operation even on unsupported hubs.\\n\"\n        \"--nodesc,   -N - do not query device description (helpful for unresponsive devices).\\n\"\n#if defined(__gnu_linux__) || defined(__linux__)\n        \"--nosysfs,  -S - do not use the Linux sysfs port disable interface.\\n\"\n#endif\n        \"--reset,    -R - reset hub after each power-on action, causing all devices to reassociate.\\n\"\n        \"--wait,     -w - wait before repeat power off [%d ms].\\n\"\n        \"--version,  -v - print program version.\\n\"\n        \"--help,     -h - print this text.\\n\"\n        \"\\n\"\n        \"Send bugs and requests to: https://github.com/mvp/uhubctl\\n\"\n        \"version: %s\\n\",\n        strlen(opt_vendor) ? opt_vendor : \"any\",\n        opt_delay,\n        opt_repeat,\n        opt_wait,\n        PROGRAM_VERSION\n    );\n    return 0;\n}\n\n\n/* trim trailing spaces from a string */\n\nstatic char* rtrim(char* str)\n{\n    int i;\n    for (i = strlen(str)-1; i>=0 && isspace(str[i]); i--) {\n        str[i] = 0;\n    }\n    return str;\n}\n\n/*\n * Convert port list into bitmap.\n * Following port list specifications are equivalent:\n *   1,3,4,5,11,12,13\n *   1,3-5,11-13\n * Returns: bitmap of specified ports, max port is MAX_HUB_PORTS.\n */\n\nstatic int ports2bitmap(char* const portlist)\n{\n    int ports = 0;\n    char* position = portlist;\n    char* comma;\n    char* dash;\n    int len;\n    int i;\n    while (position) {\n        char buf[8] = {0};\n        comma = strchr(position, ',');\n        len = sizeof(buf) - 1;\n        if (comma) {\n            if (len > comma - position)\n                len = comma - position;\n            strncpy(buf, position, len);\n            position = comma + 1;\n        } else {\n            strncpy(buf, position, len);\n            position = NULL;\n        }\n        /* Check if we have port range, e.g.: a-b */\n        int a=0, b=0;\n        a = atoi(buf);\n        dash = strchr(buf, '-');\n        if (dash) {\n            b = atoi(dash+1);\n        } else {\n            b = a;\n        }\n        if (a > b) {\n            fprintf(stderr, \"Bad port spec %d-%d, first port must be less than last\\n\", a, b);\n            exit(1);\n        }\n        if (a <= 0 || a > MAX_HUB_PORTS || b <= 0 || b > MAX_HUB_PORTS) {\n            fprintf(stderr, \"Bad port spec %d-%d, port numbers must be from 1 to %d\\n\", a, b, MAX_HUB_PORTS);\n            exit(1);\n        }\n        for (i=a; i<=b; i++) {\n            ports |= (1 << (i-1));\n        }\n    }\n    return ports;\n}\n\n/*\n * Get model of the computer we are currently running on.\n * On success return 0 and fill model string (null terminated).\n * If model is not known or error occurred returns -1.\n *\n * Currently this can only return successfully on Linux,\n * but in the future we may need it on other operating systems too.\n */\n\nstatic int get_computer_model(char *model, int len)\n{\n    int fd = open(\"/sys/firmware/devicetree/base/model\", O_RDONLY);\n    if (fd < 0) {\n        return fd;\n    }\n    int bytes_read = read(fd, model, len-1);\n    close(fd);\n    if (bytes_read < 0) {\n        return -1;\n    }\n    model[bytes_read] = 0;\n    return 0;\n}\n\n/*\n * Check if we are running on given computer model using substring match.\n * Returns 1 if yes and 0 otherwise.\n */\n\nstatic int check_computer_model(char *target)\n{\n    char model[256] = \"\";\n    if (get_computer_model(model, sizeof(model)) == 0) {\n        if (strstr(model, target) != NULL) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\n/*\n * Compatibility wrapper around libusb_get_port_numbers()\n */\n\nstatic int get_port_numbers(libusb_device *dev, uint8_t *buf, uint8_t bufsize)\n{\n    int pcount;\n#if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01000102)\n    /*\n     * libusb_get_port_path is deprecated since libusb v1.0.16,\n     * therefore use libusb_get_port_numbers when supported\n     */\n    pcount = libusb_get_port_numbers(dev, buf, bufsize);\n#else\n    pcount = libusb_get_port_path(NULL, dev, buf, bufsize);\n#endif\n    return pcount;\n}\n\n/*\n * get USB hub properties.\n * most hub_info fields are filled, except for description.\n * returns 0 for success and error code for failure.\n */\n\nstatic int get_hub_info(struct libusb_device *dev, struct hub_info *info)\n{\n    int rc = 0;\n    int len = 0;\n    struct libusb_device_handle *devh = NULL;\n    unsigned char buf[LIBUSB_DT_HUB_NONVAR_SIZE + 2 + 3] = {0};\n    struct usb_hub_descriptor *uhd = (struct usb_hub_descriptor *)buf;\n    int minlen = LIBUSB_DT_HUB_NONVAR_SIZE + 2;\n    struct libusb_device_descriptor desc;\n    rc = libusb_get_device_descriptor(dev, &desc);\n    if (rc)\n        return rc;\n    if (desc.bDeviceClass != LIBUSB_CLASS_HUB)\n        return LIBUSB_ERROR_INVALID_PARAM;\n    int bcd_usb = desc.bcdUSB;\n    int desc_type = bcd_usb >= USB_SS_BCD ? LIBUSB_DT_SUPERSPEED_HUB\n                                          : LIBUSB_DT_HUB;\n    rc = libusb_open(dev, &devh);\n    if (rc == 0) {\n        len = libusb_control_transfer(devh,\n            LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS\n                               | LIBUSB_RECIPIENT_DEVICE, /* hub status */\n            LIBUSB_REQUEST_GET_DESCRIPTOR,\n            desc_type << 8,\n            0,\n            buf, sizeof(buf),\n            USB_CTRL_GET_TIMEOUT\n        );\n\n        if (len >= minlen) {\n            info->dev     = dev;\n            info->bcd_usb = bcd_usb;\n            info->super_speed = (bcd_usb >= USB_SS_BCD);\n            info->nports  = uhd->bNbrPorts;\n            snprintf(\n                info->vendor, sizeof(info->vendor),\n                \"%04x:%04x\",\n                desc.idVendor,\n                desc.idProduct\n            );\n\n            /* Convert bus and ports array into USB location string */\n            info->bus = libusb_get_bus_number(dev);\n            snprintf(info->location, sizeof(info->location), \"%d\", info->bus);\n            info->pn_len = get_port_numbers(dev, info->port_numbers, sizeof(info->port_numbers));\n            int k;\n            for (k=0; k < info->pn_len; k++) {\n                char s[8];\n                snprintf(s, sizeof(s), \"%s%d\", k==0 ? \"-\" : \".\", info->port_numbers[k]);\n                strcat(info->location, s);\n            }\n\n            /* Get container_id: */\n            bzero(info->container_id, sizeof(info->container_id));\n            struct libusb_bos_descriptor *bos;\n            rc = libusb_get_bos_descriptor(devh, &bos);\n            if (rc == 0) {\n                int cap;\n#ifdef __FreeBSD__\n                for (cap=0; cap < bos->bNumDeviceCapabilities; cap++) {\n#else\n                for (cap=0; cap < bos->bNumDeviceCaps; cap++) {\n#endif\n                    if (bos->dev_capability[cap]->bDevCapabilityType == LIBUSB_BT_CONTAINER_ID) {\n                        struct libusb_container_id_descriptor *container_id;\n                        rc = libusb_get_container_id_descriptor(NULL, bos->dev_capability[cap], &container_id);\n                        if (rc == 0) {\n                            int i;\n                            for (i=0; i<16; i++) {\n                                sprintf(info->container_id+i*2, \"%02x\", container_id->ContainerID[i]);\n                            }\n                            info->container_id[i*2] = 0;\n                            libusb_free_container_id_descriptor(container_id);\n                        }\n                    }\n                }\n                libusb_free_bos_descriptor(bos);\n\n                /* Raspberry Pi 4B hack for USB3 root hub: */\n                if (is_rpi_4b &&\n                    strlen(info->container_id)==0 &&\n                    strcasecmp(info->vendor, \"1d6b:0003\")==0 &&\n                    info->pn_len==0 &&\n                    info->nports==4 &&\n                    bcd_usb==USB_SS_BCD)\n                {\n                    strcpy(info->container_id, \"5cf3ee30d5074925b001802d79434c30\");\n                }\n            }\n\n            /* Logical Power Switching Mode */\n            int lpsm = uhd->wHubCharacteristics[0] & HUB_CHAR_LPSM;\n            if (lpsm == HUB_CHAR_COMMON_LPSM && info->nports == 1) {\n                /* For 1 port hubs, ganged power switching is the same as per-port: */\n                lpsm = HUB_CHAR_INDV_PORT_LPSM;\n            }\n            /* Raspberry Pi 4B reports inconsistent descriptors, override: */\n            if (is_rpi_4b && lpsm == HUB_CHAR_COMMON_LPSM && strcasecmp(info->vendor, \"2109:3431\")==0) {\n                lpsm = HUB_CHAR_INDV_PORT_LPSM;\n            }\n            info->lpsm = lpsm;\n\n            /* Raspberry Pi 5 hack */\n            if (is_rpi_5 &&\n                strlen(info->container_id)==0 &&\n                info->lpsm==HUB_CHAR_INDV_PORT_LPSM &&\n                info->pn_len==0)\n            {\n                /* USB2 */\n                if (strcasecmp(info->vendor, \"1d6b:0002\")==0 &&\n                    info->nports==2 &&\n                    !info->super_speed)\n                {\n                    strcpy(info->container_id, \"Raspberry Pi 5 Fake Container Id\");\n                }\n                /* USB3 */\n                if (strcasecmp(info->vendor, \"1d6b:0003\")==0 &&\n                    info->nports==1 &&\n                    info->super_speed)\n                {\n                    strcpy(info->container_id, \"Raspberry Pi 5 Fake Container Id\");\n                }\n            }\n            rc = 0;\n        } else {\n            rc = len;\n        }\n        libusb_close(devh);\n    }\n    return rc;\n}\n\n\n/*\n * Assuming that devh is opened device handle for USB hub,\n * return state for given hub port.\n * In case of error, returns -1 (inspect errno for more information).\n */\n\nstatic int get_port_status(struct libusb_device_handle *devh, int port)\n{\n    int rc;\n    struct usb_port_status ust;\n    if (devh == NULL)\n        return -1;\n\n    rc = libusb_control_transfer(devh,\n        LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS\n                           | LIBUSB_RECIPIENT_OTHER, /* port status */\n        LIBUSB_REQUEST_GET_STATUS, 0,\n        port, (unsigned char*)&ust, sizeof(ust),\n        USB_CTRL_GET_TIMEOUT\n    );\n\n    if (rc < 0) {\n        return rc;\n    }\n    return libusb_le16_to_cpu(ust.wPortStatus);\n}\n\n\n#if defined(__gnu_linux__) || defined(__linux__)\n/*\n * Try to use the Linux sysfs interface to power a port off/on.\n * Returns 0 on success.\n */\n\nstatic int set_port_status_linux(struct libusb_device_handle *devh, struct hub_info *hub, int port, int on)\n{\n    int configuration = 0;\n    char disable_path[PATH_MAX];\n\n    int rc = libusb_get_configuration(devh, &configuration);\n    if (rc < 0) {\n        return rc;\n    }\n\n    /*\n     * The \"disable\" sysfs interface is available only starting with kernel version 6.0.\n     * For earlier kernel versions the open() call will fail and we fall back to using libusb.\n     */\n    if (hub->pn_len == 0) {\n      snprintf(disable_path, PATH_MAX,\n          \"/sys/bus/usb/devices/%s-0:%d.0/usb%s-port%i/disable\",\n          hub->location, configuration, hub->location, port\n      );\n    } else {\n      snprintf(disable_path, PATH_MAX,\n          \"/sys/bus/usb/devices/%s:%d.0/%s-port%i/disable\",\n          hub->location, configuration, hub->location, port\n      );\n    }\n\n    int disable_fd = open(disable_path, O_WRONLY);\n    if (disable_fd >= 0) {\n        rc = write(disable_fd, on ? \"0\" : \"1\", 1);\n        close(disable_fd);\n    }\n\n    if (disable_fd < 0 || rc < 0) {\n        /*\n         * ENOENT is the expected error when running on Linux kernel < 6.0 where\n         * sysfs disable interface does not exist yet - no need to report anything in this case.\n         * If the file exists but another error occurs it is most likely a permission issue.\n         * Print an error message mostly geared towards setting up udev.\n         */\n        if (errno != ENOENT) {\n            fprintf(stderr,\n                \"Failed to set port status by writing to %s (%s).\\n\"\n                \"Follow https://git.io/JIB2Z to make sure that udev is set up correctly.\\n\"\n                \"Falling back to libusb based port control.\\n\"\n                \"Use -S to skip trying the sysfs interface and printing this message.\\n\",\n                disable_path, strerror(errno)\n            );\n        }\n\n        return -1;\n    }\n\n    return 0;\n}\n#endif\n\n\n/*\n * Use a control transfer via libusb to turn a port off/on.\n * Returns >= 0 on success.\n */\n\nstatic int set_port_status_libusb(struct libusb_device_handle *devh, int port, int on)\n{\n    int rc = 0;\n    int request = on ? LIBUSB_REQUEST_SET_FEATURE\n                     : LIBUSB_REQUEST_CLEAR_FEATURE;\n    int repeat = on ? 1 : opt_repeat;\n\n    while (repeat-- > 0) {\n        rc = libusb_control_transfer(devh,\n            LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_OTHER,\n            request, USB_PORT_FEAT_POWER,\n            port, NULL, 0, USB_CTRL_GET_TIMEOUT\n        );\n        if (rc < 0) {\n            perror(\"Failed to control port power!\\n\");\n        }\n        if (repeat > 0) {\n            sleep_ms(opt_wait);\n        }\n    }\n\n    return rc;\n}\n\n\n/*\n * Try different methods to power a port off/on.\n * Return >= 0 on success.\n */\n\nstatic int set_port_status(struct libusb_device_handle *devh, struct hub_info *hub, int port, int on)\n{\n#if defined(__gnu_linux__) || defined(__linux__)\n    if (!opt_nosysfs) {\n        if (set_port_status_linux(devh, hub, port, on) == 0) {\n            return 0;\n        }\n    }\n#else\n    (void)hub;\n#endif\n\n    return set_port_status_libusb(devh, port, on);\n}\n\n\n/*\n * Get USB device descriptor strings and summary description.\n *\n * Summary will use following format:\n *\n *    \"<vid:pid> <vendor> <product> <serial>, <USB x.yz, N ports>\"\n *\n * vid:pid will be always present, but vendor, product or serial\n * may be skipped if they are empty or not enough permissions to read them.\n * <USB x.yz, N ports> will be present only for USB hubs.\n *\n * Returns 0 for success and error code for failure.\n * In case of failure return buffer is not altered.\n */\n\nstatic int get_device_description(struct libusb_device * dev, struct descriptor_strings * ds)\n{\n    int rc;\n    int id_vendor  = 0;\n    int id_product = 0;\n    char hub_specific[64] = \"\";\n    struct libusb_device_descriptor desc;\n    struct libusb_device_handle *devh = NULL;\n    rc = libusb_get_device_descriptor(dev, &desc);\n    if (rc)\n        return rc;\n    bzero(ds, sizeof(*ds));\n    id_vendor  = desc.idVendor;\n    id_product = desc.idProduct;\n    rc = libusb_open(dev, &devh);\n    if (rc == 0) {\n        if (!opt_nodesc) {\n            if (desc.iManufacturer) {\n                rc = libusb_get_string_descriptor_ascii(devh,\n                    desc.iManufacturer, (unsigned char*)ds->vendor, sizeof(ds->vendor));\n                rtrim(ds->vendor);\n            }\n            if (rc >= 0 && desc.iProduct) {\n                rc = libusb_get_string_descriptor_ascii(devh,\n                    desc.iProduct, (unsigned char*)ds->product, sizeof(ds->product));\n                rtrim(ds->product);\n            }\n            if (rc >= 0 && desc.iSerialNumber) {\n                rc = libusb_get_string_descriptor_ascii(devh,\n                    desc.iSerialNumber, (unsigned char*)ds->serial, sizeof(ds->serial));\n                rtrim(ds->serial);\n            }\n        }\n        if (desc.bDeviceClass == LIBUSB_CLASS_HUB) {\n            struct hub_info info;\n            bzero(&info, sizeof(info));\n            rc = get_hub_info(dev, &info);\n            if (rc == 0) {\n                const char * lpsm_type;\n                if (info.lpsm == HUB_CHAR_INDV_PORT_LPSM) {\n                    lpsm_type = \"ppps\";\n                } else if (info.lpsm == HUB_CHAR_COMMON_LPSM) {\n                    lpsm_type = \"ganged\";\n                } else {\n                    lpsm_type = \"nops\";\n                }\n                snprintf(hub_specific, sizeof(hub_specific), \", USB %x.%02x, %d ports, %s\",\n                   info.bcd_usb >> 8, info.bcd_usb & 0xFF, info.nports, lpsm_type);\n            }\n        }\n        libusb_close(devh);\n    }\n    snprintf(ds->description, sizeof(ds->description),\n        \"%04x:%04x%s%s%s%s%s%s%s\",\n        id_vendor, id_product,\n        ds->vendor[0]  ? \" \" : \"\", ds->vendor,\n        ds->product[0] ? \" \" : \"\", ds->product,\n        ds->serial[0]  ? \" \" : \"\", ds->serial,\n        hub_specific\n    );\n    return 0;\n}\n\n\n/*\n * show status for hub ports\n * portmask is bitmap of ports to display\n * if portmask is 0, show all ports\n */\n\nstatic int print_port_status(struct hub_info * hub, int portmask)\n{\n    int port_status;\n    struct libusb_device_handle * devh = NULL;\n    int rc = 0;\n    struct libusb_device *dev = hub->dev;\n    rc = libusb_open(dev, &devh);\n    if (rc == 0) {\n        int port;\n        for (port = 1; port <= hub->nports; port++) {\n            if (portmask > 0 && (portmask & (1 << (port-1))) == 0) continue;\n\n            port_status = get_port_status(devh, port);\n            if (port_status == -1) {\n                fprintf(stderr,\n                    \"cannot read port %d status, %s (%d)\\n\",\n                    port, strerror(errno), errno);\n                break;\n            }\n\n            printf(\"  Port %d: %04x\", port, port_status);\n\n            struct descriptor_strings ds;\n            bzero(&ds, sizeof(ds));\n            struct libusb_device * udev;\n            int i = 0;\n            while ((udev = usb_devs[i++]) != NULL) {\n                uint8_t dev_bus;\n                uint8_t dev_pn[MAX_HUB_CHAIN];\n                int dev_plen;\n                dev_bus = libusb_get_bus_number(udev);\n                /* only match devices on the same bus: */\n                if (dev_bus != hub->bus) continue;\n                dev_plen = get_port_numbers(udev, dev_pn, sizeof(dev_pn));\n                if ((dev_plen == hub->pn_len + 1) &&\n                    (memcmp(hub->port_numbers, dev_pn, hub->pn_len) == 0) &&\n                    libusb_get_port_number(udev) == port)\n                {\n                    rc = get_device_description(udev, &ds);\n                    if (rc == 0)\n                        break;\n                }\n            }\n\n            if (!hub->super_speed) {\n                if (port_status == 0) {\n                    printf(\" off\");\n                } else {\n                    if (port_status & USB_PORT_STAT_POWER)        printf(\" power\");\n                    if (port_status & USB_PORT_STAT_INDICATOR)    printf(\" indicator\");\n                    if (port_status & USB_PORT_STAT_TEST)         printf(\" test\");\n                    if (port_status & USB_PORT_STAT_HIGH_SPEED)   printf(\" highspeed\");\n                    if (port_status & USB_PORT_STAT_LOW_SPEED)    printf(\" lowspeed\");\n                    if (port_status & USB_PORT_STAT_SUSPEND)      printf(\" suspend\");\n                }\n            } else {\n                if (!(port_status & USB_SS_PORT_STAT_POWER)) {\n                    printf(\" off\");\n                } else {\n                    int link_state = port_status & USB_PORT_STAT_LINK_STATE;\n                    if (port_status & USB_SS_PORT_STAT_POWER)     printf(\" power\");\n                    if ((port_status & USB_SS_PORT_STAT_SPEED)\n                         == USB_PORT_STAT_SPEED_5GBPS)\n                    {\n                        printf(\" 5gbps\");\n                    }\n                    if (link_state == USB_SS_PORT_LS_U0)          printf(\" U0\");\n                    if (link_state == USB_SS_PORT_LS_U1)          printf(\" U1\");\n                    if (link_state == USB_SS_PORT_LS_U2)          printf(\" U2\");\n                    if (link_state == USB_SS_PORT_LS_U3)          printf(\" U3\");\n                    if (link_state == USB_SS_PORT_LS_SS_DISABLED) printf(\" SS.Disabled\");\n                    if (link_state == USB_SS_PORT_LS_RX_DETECT)   printf(\" Rx.Detect\");\n                    if (link_state == USB_SS_PORT_LS_SS_INACTIVE) printf(\" SS.Inactive\");\n                    if (link_state == USB_SS_PORT_LS_POLLING)     printf(\" Polling\");\n                    if (link_state == USB_SS_PORT_LS_RECOVERY)    printf(\" Recovery\");\n                    if (link_state == USB_SS_PORT_LS_HOT_RESET)   printf(\" HotReset\");\n                    if (link_state == USB_SS_PORT_LS_COMP_MOD)    printf(\" Compliance\");\n                    if (link_state == USB_SS_PORT_LS_LOOPBACK)    printf(\" Loopback\");\n                }\n            }\n            if (port_status & USB_PORT_STAT_RESET)       printf(\" reset\");\n            if (port_status & USB_PORT_STAT_OVERCURRENT) printf(\" oc\");\n            if (port_status & USB_PORT_STAT_ENABLE)      printf(\" enable\");\n            if (port_status & USB_PORT_STAT_CONNECTION)  printf(\" connect\");\n\n            if (port_status & USB_PORT_STAT_CONNECTION)  printf(\" [%s]\", ds.description);\n\n            printf(\"\\n\");\n        }\n        libusb_close(devh);\n    }\n    return 0;\n}\n\n\n/*\n *  Find all USB hubs and fill hubs[] array.\n *  Set actionable to 1 on all hubs that we are going to operate on\n *  (this applies possible constraints like location or vendor).\n *  Returns count of found actionable physical hubs\n *  (USB3 hubs are counted once despite having USB2 dual partner).\n *  In case of error returns negative error code.\n */\n\nstatic int usb_find_hubs(void)\n{\n    struct libusb_device *dev;\n    int perm_ok = 1;\n    int rc = 0;\n    int i = 0;\n    int j = 0;\n    while ((dev = usb_devs[i++]) != NULL) {\n        struct libusb_device_descriptor desc;\n        rc = libusb_get_device_descriptor(dev, &desc);\n        /* only scan for hubs: */\n        if (rc == 0 && desc.bDeviceClass != LIBUSB_CLASS_HUB)\n            continue;\n        struct hub_info info;\n        bzero(&info, sizeof(info));\n        rc = get_hub_info(dev, &info);\n        if (rc) {\n            perm_ok = 0; /* USB permission issue? */\n            continue;\n        }\n        get_device_description(dev, &info.ds);\n        if (info.lpsm != HUB_CHAR_INDV_PORT_LPSM && !opt_force) {\n            continue;\n        }\n        info.actionable = 1;\n        if (strlen(opt_search) > 0) {\n            /* Search by attached device description */\n            info.actionable = 0;\n            struct libusb_device * udev;\n            int k = 0;\n            while ((udev = usb_devs[k++]) != NULL) {\n                uint8_t dev_pn[MAX_HUB_CHAIN];\n                uint8_t dev_bus = libusb_get_bus_number(udev);\n                /* only match devices on the same bus: */\n                if (dev_bus != info.bus) continue;\n                int dev_plen = get_port_numbers(udev, dev_pn, sizeof(dev_pn));\n                if ((dev_plen == info.pn_len + 1) &&\n                    (memcmp(info.port_numbers, dev_pn, info.pn_len) == 0))\n                {\n                    struct descriptor_strings ds;\n                    bzero(&ds, sizeof(ds));\n                    rc = get_device_description(udev, &ds);\n                    if (rc != 0)\n                        break;\n                    if (strstr(ds.description, opt_search)) {\n                        info.actionable = 1;\n                        opt_ports &= 1 << (dev_pn[dev_plen-1] - 1);\n                        break;\n                    }\n                }\n            }\n        }\n        if (strlen(opt_location) > 0) {\n            if (strcasecmp(opt_location, info.location)) {\n                info.actionable = 0;\n            }\n        }\n        if (opt_level > 0) {\n            if (opt_level != info.pn_len + 1) {\n                info.actionable = 0;\n            }\n        }\n        if (strlen(opt_vendor) > 0) {\n            if (strncasecmp(opt_vendor, info.vendor, strlen(opt_vendor))) {\n                info.actionable = 0;\n            }\n        }\n        memcpy(&hubs[hub_count], &info, sizeof(info));\n        if (hub_count < MAX_HUBS) {\n            hub_count++;\n        } else {\n            /* That should be impossible - but we don't want to crash! */\n            fprintf(stderr, \"Too many hubs!\");\n            break;\n        }\n    }\n    if (!opt_exact) {\n        /* Handle USB2/3 duality: */\n        for (i=0; i<hub_count; i++) {\n            /* Check only actionable hubs: */\n            if (hubs[i].actionable != 1)\n                continue;\n            /* Must have non empty container ID: */\n            if (strlen(hubs[i].container_id) == 0)\n                continue;\n            int best_match = -1;\n            int best_score = -1;\n            for (j=0; j<hub_count; j++) {\n                if (i==j)\n                    continue;\n\n                /* Find hub which is USB2/3 dual to the hub above */\n\n                /* Hub and its dual must be different types: one USB2, another USB3: */\n                if (hubs[i].super_speed == hubs[j].super_speed)\n                    continue;\n\n                /* Must have non empty container ID: */\n                if (strlen(hubs[j].container_id) == 0)\n                    continue;\n\n                /* Per USB 3.0 spec chapter 11.2, container IDs must match: */\n                if (strcmp(hubs[i].container_id, hubs[j].container_id) != 0)\n                    continue;\n\n                /* At this point, it should be enough to claim a match.\n                 * However, some devices use hardcoded non-unique container ID.\n                 * We should do few more checks below if multiple such devices are present.\n                 */\n\n                /* Hubs should have the same number of ports */\n                if (hubs[i].nports != hubs[j].nports) {\n                    /* Except for some weird hubs like Apple mini-dock (has 2 usb2 + 1 usb3 ports) */\n                    if (hubs[i].nports + hubs[j].nports > 3) {\n                        continue;\n                    }\n                }\n\n                /* If serial numbers are both present, they must match: */\n                if ((strlen(hubs[i].ds.serial) > 0 && strlen(hubs[j].ds.serial) > 0) &&\n                    strcmp(hubs[i].ds.serial, hubs[j].ds.serial) != 0)\n                {\n                    continue;\n                }\n\n                /* We have first possible candidate, but need to keep looking for better one */\n\n                if (best_score < 1) {\n                    best_score = 1;\n                    best_match = j;\n                }\n\n                /* Checks for various levels of USB2 vs USB3 path similarity... */\n\n                uint8_t* p1 = hubs[i].port_numbers;\n                uint8_t* p2 = hubs[j].port_numbers;\n                int l1 = hubs[i].pn_len;\n                int l2 = hubs[j].pn_len;\n                int s1 = hubs[i].super_speed;\n                int s2 = hubs[j].super_speed;\n\n                /* Check if port path is the same after removing top level (needed for M1 Macs): */\n                if (l1 >= 1 && l1 == l2 && memcmp(p1 + 1, p2 + 1, l1 - 1)==0) {\n                    if (best_score < 2) {\n                        best_score = 2;\n                        best_match = j;\n                    }\n                }\n\n                /* Raspberry Pi 4B hack (USB2 hub is one level deeper than USB3): */\n                if (is_rpi_4b && l1 + s1 == l2 + s2 && l1 >= s2 && memcmp(p1 + s2, p2 + s1, l1 - s2)==0) {\n                    if (best_score < 3) {\n                        best_score = 3;\n                        best_match = j;\n                    }\n                }\n                /* Check if port path is exactly the same: */\n                if (l1 == l2 && memcmp(p1, p2, l1)==0) {\n                    if (best_score < 4) {\n                        best_score = 4;\n                        best_match = j;\n                    }\n                    /* Give even higher priority if `usb2bus + 1 == usb3bus` (Linux specific): */\n                    if (hubs[i].bus - s1 == hubs[j].bus - s2) {\n                        if (best_score < 5) {\n                            best_score = 5;\n                            best_match = j;\n                        }\n                    }\n                }\n            }\n            if (best_match >= 0) {\n                if (!hubs[best_match].actionable) {\n                    /* Use 2 to signify that this is derived dual device */\n                    hubs[best_match].actionable = 2;\n                }\n            }\n        }\n    }\n    hub_phys_count = 0;\n    for (i=0; i<hub_count; i++) {\n        if (!hubs[i].actionable)\n            continue;\n        if (!hubs[i].super_speed || opt_exact) {\n            hub_phys_count++;\n        }\n    }\n    if (perm_ok == 0 && hub_phys_count == 0) {\n#if defined(__gnu_linux__) || defined(__linux__)\n        if (geteuid() != 0) {\n            fprintf(stderr,\n                \"There were permission problems while accessing USB.\\n\"\n                \"Follow https://git.io/JIB2Z for a fix!\\n\"\n            );\n        }\n#endif\n        return LIBUSB_ERROR_ACCESS;\n    }\n    return hub_phys_count;\n}\n\n\nint main(int argc, char *argv[])\n{\n    int rc;\n    int c = 0;\n    int option_index = 0;\n\n    for (;;) {\n        c = getopt_long(argc, argv, short_options, long_options, &option_index);\n        if (c == -1)\n            break;  /* no more options left */\n        switch (c) {\n        case 0:\n            /* If this option set a flag, do nothing else now. */\n            if (long_options[option_index].flag != 0)\n                break;\n            printf(\"option %s\", long_options[option_index].name);\n            if (optarg)\n                printf(\" with arg %s\", optarg);\n            printf(\"\\n\");\n            break;\n        case 'l':\n            snprintf(opt_location, sizeof(opt_location), \"%s\", optarg);\n            break;\n        case 'L':\n            opt_level = atoi(optarg);\n            break;\n        case 'n':\n            snprintf(opt_vendor, sizeof(opt_vendor), \"%s\", optarg);\n            break;\n        case 's':\n            snprintf(opt_search, sizeof(opt_search), \"%s\", optarg);\n            break;\n        case 'p':\n            if (!strcasecmp(optarg, \"all\")) { /* all ports is the default */\n                break;\n            }\n            if (strlen(optarg)) {\n                opt_ports = ports2bitmap(optarg);\n            }\n            break;\n        case 'a':\n            if (!strcasecmp(optarg, \"off\")   || !strcasecmp(optarg, \"0\")) {\n                opt_action = POWER_OFF;\n            }\n            if (!strcasecmp(optarg, \"on\")    || !strcasecmp(optarg, \"1\")) {\n                opt_action = POWER_ON;\n            }\n            if (!strcasecmp(optarg, \"cycle\") || !strcasecmp(optarg, \"2\")) {\n                opt_action = POWER_CYCLE;\n            }\n            if (!strcasecmp(optarg, \"toggle\") || !strcasecmp(optarg, \"3\")) {\n                opt_action = POWER_TOGGLE;\n            }\n            if (!strcasecmp(optarg, \"flash\") || !strcasecmp(optarg, \"4\")) {\n                opt_action = POWER_FLASH;\n            }\n            break;\n        case 'd':\n            opt_delay = atof(optarg);\n            break;\n        case 'r':\n            opt_repeat = atoi(optarg);\n            break;\n        case 'f':\n            opt_force = 1;\n            break;\n        case 'N':\n            opt_nodesc = 1;\n            break;\n#if defined(__gnu_linux__) || defined(__linux__)\n        case 'S':\n            opt_nosysfs = 1;\n            break;\n#endif\n        case 'e':\n            opt_exact = 1;\n            break;\n        case 'R':\n            opt_reset = 1;\n            break;\n        case 'w':\n            opt_wait = atoi(optarg);\n            break;\n        case 'v':\n            printf(\"%s\\n\", PROGRAM_VERSION);\n            exit(0);\n            break;\n        case 'h':\n            print_usage();\n            exit(1);\n            break;\n        case '?':\n            /* getopt_long has already printed an error message here */\n            fprintf(stderr, \"Run with -h to get usage info.\\n\");\n            exit(1);\n            break;\n        default:\n            abort();\n        }\n    }\n    if (optind < argc) {\n        /* non-option parameters are found? */\n        fprintf(stderr, \"Invalid command line syntax!\\n\");\n        fprintf(stderr, \"Run with -h to get usage info.\\n\");\n        exit(1);\n    }\n\n    rc = libusb_init(NULL);\n    if (rc < 0) {\n        fprintf(stderr,\n            \"Error initializing USB!\\n\"\n        );\n        exit(1);\n    }\n\n    rc = libusb_get_device_list(NULL, &usb_devs);\n    if (rc < 0) {\n        fprintf(stderr,\n            \"Cannot enumerate USB devices!\\n\"\n        );\n        rc = 1;\n        goto cleanup;\n    }\n\n    is_rpi_4b = check_computer_model(\"Raspberry Pi 4 Model B\");\n    is_rpi_5  = check_computer_model(\"Raspberry Pi 5\");\n\n    rc = usb_find_hubs();\n    if (rc <= 0) {\n        fprintf(stderr,\n            \"No compatible devices detected%s%s!\\n\"\n            \"Run with -h to get usage info.\\n\",\n            strlen(opt_location) ? \" at location \" : \"\",\n            opt_location\n        );\n        rc = 1;\n        goto cleanup;\n    }\n\n    if (hub_phys_count > 1 && opt_action >= 0) {\n        fprintf(stderr,\n            \"Error: changing port state for multiple hubs at once is not supported.\\n\"\n            \"Use -l to limit operation to one hub!\\n\"\n        );\n        exit(1);\n    }\n    int k; /* k=0 for power OFF, k=1 for power ON */\n    for (k=0; k<2; k++) { /* up to 2 power actions - off/on */\n        if (k == 0 && opt_action == POWER_ON )\n            continue;\n        if (k == 1 && opt_action == POWER_OFF)\n            continue;\n        if (k == 1 && opt_action == POWER_KEEP)\n            continue;\n        /* if toggle requested, do it only once when `k == 0` */\n        if (k == 1 && opt_action == POWER_TOGGLE)\n            continue;\n        int i;\n        for (i=0; i<hub_count; i++) {\n            if (hubs[i].actionable == 0)\n                continue;\n            printf(\"Current status for hub %s [%s]\\n\",\n                hubs[i].location, hubs[i].ds.description\n            );\n            print_port_status(&hubs[i], opt_ports);\n            if (opt_action == POWER_KEEP) { /* no action, show status */\n                continue;\n            }\n            struct libusb_device_handle * devh = NULL;\n            rc = libusb_open(hubs[i].dev, &devh);\n            if (rc == 0) {\n                /* will operate on these ports */\n                int ports = ((1 << hubs[i].nports) - 1) & opt_ports;\n                int should_be_on = k;\n                if (opt_action == POWER_FLASH) {\n                    should_be_on = !should_be_on;\n                }\n\n                int port;\n                for (port=1; port <= hubs[i].nports; port++) {\n                    if ((1 << (port-1)) & ports) {\n                        int port_status = get_port_status(devh, port);\n                        int power_mask = hubs[i].super_speed ? USB_SS_PORT_STAT_POWER\n                                                             : USB_PORT_STAT_POWER;\n                        int is_on = (port_status & power_mask) != 0;\n\n                        if (opt_action == POWER_TOGGLE) {\n                            should_be_on = !is_on;\n                        }\n\n                        if (is_on != should_be_on) {\n                            rc = set_port_status(devh, &hubs[i], port, should_be_on);\n                        }\n                    }\n                }\n                /* USB3 hubs need extra delay to actually turn off: */\n                if (k==0 && hubs[i].super_speed)\n                    sleep_ms(150);\n                printf(\"Sent power %s request\\n\", should_be_on ? \"on\" : \"off\");\n                printf(\"New status for hub %s [%s]\\n\",\n                    hubs[i].location, hubs[i].ds.description\n                );\n                print_port_status(&hubs[i], opt_ports);\n\n                if (k == 1 && opt_reset == 1) {\n                    printf(\"Resetting hub...\\n\");\n                    rc = libusb_reset_device(devh);\n                    if (rc < 0) {\n                        perror(\"Reset failed!\\n\");\n                    } else {\n                        printf(\"Reset successful!\\n\");\n                    }\n                }\n            }\n            libusb_close(devh);\n        }\n        if (k == 0 && (opt_action == POWER_CYCLE || opt_action == POWER_FLASH))\n            sleep_ms((int)(opt_delay * 1000));\n    }\n    rc = 0;\ncleanup:\n    if (usb_devs)\n        libusb_free_device_list(usb_devs, 1);\n    usb_devs = NULL;\n    libusb_exit(NULL);\n    return rc;\n}\n"
        },
        {
          "name": "uhubctl_git.bb",
          "type": "blob",
          "size": 0.5302734375,
          "content": "DESCRIPTION = \"uhubctl - USB hub per-port power control\"\nHOMEPAGE = \"https://github.com/mvp/uhubctl\"\nLICENSE = \"GPLv2\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=b234ee4d69f5fce4486a80fdaf4a4263 \\\n                    file://LICENSE;md5=a79e6a142b69522fe7757fe7313895eb\"\n\nDEPENDS = \"libusb1\"\nRDEPENDS_${PN} = \"libusb1\"\n\nSRC_URI = \"git://github.com/mvp/uhubctl.git\"\nSRCREV = \"${AUTOREV}\"\nPV = \"git\"\nS = \"${WORKDIR}/git\"\n\ndo_install_append () {\n\tinstall -d ${D}${bindir}\n\tinstall -Dm 0755 ${S}/uhubctl ${D}${bindir}/\n}\n\nFILES_${PN}  += \"${bindir}/*\"\n"
        }
      ]
    }
  ]
}