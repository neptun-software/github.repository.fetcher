{
  "metadata": {
    "timestamp": 1736709920830,
    "page": 435,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "panda-re/panda",
      "stars": 2520,
      "defaultBranch": "dev",
      "files": [
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 0.0732421875,
          "content": "((c-mode . ((c-file-style . \"stroustrup\")\n\t    (indent-tabs-mode . nil))))\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.08203125,
          "content": "build\nvenv\nlocal\nDockerfile\npanda/debian\n.*sw*\n.dockerignore\n.github\n.git/FETCH_HEAD"
        },
        {
          "name": ".exrc",
          "type": "blob",
          "size": 0.21484375,
          "content": "\"VIM settings to match QEMU coding style.  They are activated by adding the\n\"following settings (without the \" symbol) as last two lines in $HOME/.vimrc:\n\"set secure\n\"set exrc\nset expandtab\nset shiftwidth=4\nset smarttab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.78515625,
          "content": "venv\n/build\n/config-devices.*\n/config-all-devices.*\n/config-all-disas.*\n/config-host.*\n/config-target.*\n/config.status\n/config-temp\n/trace-events-all\n/trace/generated-events.h\n/trace/generated-events.c\n/trace/generated-helpers-wrappers.h\n/trace/generated-helpers.h\n/trace/generated-helpers.c\n/trace/generated-tcg-tracers.h\n/ui/shader/texture-blit-frag.h\n/ui/shader/texture-blit-vert.h\n*-timestamp\n/*-softmmu\n/*-darwin-user\n/*-linux-user\n/*-bsd-user\n/ivshmem-client\n/ivshmem-server\n/libdis*\n/libuser\n/linux-headers/asm\n/qga/qapi-generated\n/qapi-generated\n/qapi-types.[ch]\n/qapi-visit.[ch]\n/qapi-event.[ch]\n/qmp-commands.h\n/qmp-introspect.[ch]\n/qmp-marshal.c\n/qemu-doc.html\n/qemu-doc.info\n/qemu-doc.txt\n/qemu-img\n/qemu-nbd\n/qemu-options.def\n/qemu-options.texi\n/qemu-img-cmds.texi\n/qemu-img-cmds.h\n/qemu-io\n/qemu-ga\n/qemu-bridge-helper\n/qemu-monitor.texi\n/qemu-monitor-info.texi\n/qemu-version.h\n/qemu-version.h.tmp\n/module_block.h\n/vscclient\n/fsdev/virtfs-proxy-helper\n*.[1-9]\n*.a\n*.aux\n*.cp\n*.exe\n*.msi\n*.dll\n*.so\n*.mo\n*.fn\n*.ky\n*.log\n*.pdf\n*.pod\n*.cps\n*.fns\n*.kys\n*.pg\n*.pyc\n*.toc\n*.tp\n*.vr\n*.d\n!/scripts/qemu-guest-agent/fsfreeze-hook.d\n*.o\n.sdk\n*.gcda\n*.gcno\n*.swp\n.*.sw*\n/pc-bios/bios-pq/status\n/pc-bios/vgabios-pq/status\n/pc-bios/optionrom/linuxboot.asm\n/pc-bios/optionrom/linuxboot.bin\n/pc-bios/optionrom/linuxboot.raw\n/pc-bios/optionrom/linuxboot.img\n/pc-bios/optionrom/linuxboot_dma.asm\n/pc-bios/optionrom/linuxboot_dma.bin\n/pc-bios/optionrom/linuxboot_dma.raw\n/pc-bios/optionrom/linuxboot_dma.img\n/pc-bios/optionrom/multiboot.asm\n/pc-bios/optionrom/multiboot.bin\n/pc-bios/optionrom/multiboot.raw\n/pc-bios/optionrom/multiboot.img\n/pc-bios/optionrom/kvmvapic.asm\n/pc-bios/optionrom/kvmvapic.bin\n/pc-bios/optionrom/kvmvapic.raw\n/pc-bios/optionrom/kvmvapic.img\n/pc-bios/s390-ccw/s390-ccw.elf\n/pc-bios/s390-ccw/s390-ccw.img\n/docs/qemu-ga-qapi.texi\n/docs/qemu-ga-ref.html\n/docs/qemu-ga-ref.info*\n/docs/qemu-ga-ref.txt\n/docs/qemu-qmp-qapi.texi\n/docs/qemu-qmp-ref.html\n/docs/qemu-qmp-ref.info*\n/docs/qemu-qmp-ref.txt\n/docs/version.texi\n/panda/plugins/*/docs/\n/panda/plugins/*/target/\n**/target\n*.tps\n.stgit-*\n.git-submodule-status\ncscope.*\ntags\nTAGS\ndocker-src.*\n*~\n*.plist\n.gdb_history\n*plog.pb-c.c\n*plog.pb-c.h\nplog.proto\nbuild.inc.sh\ntrace.h\ntrace.c\ntrace-ust.h\ntrace-ust.h\ntrace-dtrace.h\ntrace-dtrace.dtrace\ntrace-root.h\ntrace-root.c\ntrace-ust-root.h\ntrace-ust-root.h\ntrace-ust-all.h\ntrace-ust-all.c\ntrace-dtrace-root.h\ntrace-dtrace-root.dtrace\ntrace-ust-all.h\ntrace-ust-all.c\n\n.vscode/\n\n# Pypanda Examples\npwc_log\n\n# Recordings and pandalogs\n*-rr-*\n*.rr2\n*.plog\n\n# Kerenels/qcows\n*.qcow*\nvmlinux*\nzImage*\n\n# PANDALOG dumps\n*.plog\n\n# Test FW\npanda/plugins/syscalls_logger/test/test_fw\n\n# Local files to be gitignored\nlocal\n\n# Workaround for CI to avoid github checkout@v2 actions bug when auto-generating documentation\nauto_pydoc\nauto_pydoc/pandare\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 1.125,
          "content": "[submodule \"roms/vgabios\"]\n\tpath = roms/vgabios\n\turl = https://gitlab.com/qemu-project/vgabios.git\n[submodule \"roms/seabios\"]\n\tpath = roms/seabios\n\turl = https://gitlab.com/qemu-project/seabios.git\n[submodule \"roms/SLOF\"]\n\tpath = roms/SLOF\n\turl = https://gitlab.com/qemu-project/SLOF.git\n[submodule \"roms/ipxe\"]\n\tpath = roms/ipxe\n\turl = https://gitlab.com/qemu-project/ipxe.git\n[submodule \"roms/openbios\"]\n\tpath = roms/openbios\n\turl = https://gitlab.com/qemu-project/openbios.git\n[submodule \"roms/openhackware\"]\n\tpath = roms/openhackware\n\turl = https://gitlab.com/qemu-project/openhackware.git\n[submodule \"roms/qemu-palcode\"]\n\tpath = roms/qemu-palcode\n\turl = https://github.com/rth7680/qemu-palcode.git\n[submodule \"roms/sgabios\"]\n\tpath = roms/sgabios\n\turl = https://gitlab.com/qemu-project/sgabios.git\n[submodule \"pixman\"]\n\tpath = pixman\n\turl = https://github.com/coolkingcole/pixman.git\n[submodule \"dtc\"]\n\tpath = dtc\n\turl = https://github.com/qemu/dtc.git\n[submodule \"roms/u-boot\"]\n\tpath = roms/u-boot\n\turl = https://gitlab.com/qemu-project/u-boot.git\n[submodule \"roms/skiboot\"]\n\tpath = roms/skiboot\n\turl = https://gitlab.com/qemu-project/skiboot.git\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 1.2578125,
          "content": "# This mailmap just translates the weird addresses from the original import into git\n# into proper addresses so that they are counted properly in git shortlog output.\n#\nAndrzej Zaborowski <balrogg@gmail.com> balrog <balrog@c046a42c-6fe2-441c-8c8c-71466251a162>\nAnthony Liguori <anthony@codemonkey.ws> aliguori <aliguori@c046a42c-6fe2-441c-8c8c-71466251a162>\nAnthony Liguori <anthony@codemonkey.ws> Anthony Liguori <aliguori@us.ibm.com>\nAurelien Jarno <aurelien@aurel32.net> aurel32 <aurel32@c046a42c-6fe2-441c-8c8c-71466251a162>\nBlue Swirl <blauwirbel@gmail.com> blueswir1 <blueswir1@c046a42c-6fe2-441c-8c8c-71466251a162>\nEdgar E. Iglesias <edgar.iglesias@gmail.com> edgar_igl <edgar_igl@c046a42c-6fe2-441c-8c8c-71466251a162>\nFabrice Bellard <fabrice@bellard.org> bellard <bellard@c046a42c-6fe2-441c-8c8c-71466251a162>\nJocelyn Mayer <l_indien@magic.fr> j_mayer <j_mayer@c046a42c-6fe2-441c-8c8c-71466251a162>\nPaul Brook <paul@codesourcery.com> pbrook <pbrook@c046a42c-6fe2-441c-8c8c-71466251a162>\nThiemo Seufer <ths@networkno.de> ths <ths@c046a42c-6fe2-441c-8c8c-71466251a162>\nmalc <av1474@comtv.ru> malc <malc@c046a42c-6fe2-441c-8c8c-71466251a162>\n# There is also a:\n#    (no author) <(no author)@c046a42c-6fe2-441c-8c8c-71466251a162>\n# for the cvs2svn initialization commit e63c3dc74bf.\n"
        },
        {
          "name": ".shippable.yml",
          "type": "blob",
          "size": 0.515625,
          "content": "language: c\nenv:\n  matrix:\n    - IMAGE=debian-armhf-cross\n      TARGET_LIST=arm-softmmu,arm-linux-user\n    - IMAGE=debian-arm64-cross\n      TARGET_LIST=aarch64-softmmu,aarch64-linux-user\n    - IMAGE=debian-s390x-cross\n      TARGET_LIST=s390x-softmmu,s390x-linux-user\nbuild:\n  pre_ci:\n    - make docker-image-${IMAGE}\n  pre_ci_boot:\n    image_name: qemu\n    image_tag: ${IMAGE}\n    pull: false\n    options: \"-e HOME=/root\"\n  ci:\n    - unset CC\n    - ./configure ${QEMU_CONFIGURE_OPTS} --target-list=${TARGET_LIST}\n    - make -j2\n"
        },
        {
          "name": "CODING_STYLE",
          "type": "blob",
          "size": 4.48046875,
          "content": "QEMU Coding Style\n=================\n\nPlease use the script checkpatch.pl in the scripts directory to check\npatches before submitting.\n\n1. Whitespace\n\nOf course, the most important aspect in any coding style is whitespace.\nCrusty old coders who have trouble spotting the glasses on their noses\ncan tell the difference between a tab and eight spaces from a distance\nof approximately fifteen parsecs.  Many a flamewar has been fought and\nlost on this issue.\n\nQEMU indents are four spaces.  Tabs are never used, except in Makefiles\nwhere they have been irreversibly coded into the syntax.\nSpaces of course are superior to tabs because:\n\n - You have just one way to specify whitespace, not two.  Ambiguity breeds\n   mistakes.\n - The confusion surrounding 'use tabs to indent, spaces to justify' is gone.\n - Tab indents push your code to the right, making your screen seriously\n   unbalanced.\n - Tabs will be rendered incorrectly on editors who are misconfigured not\n   to use tab stops of eight positions.\n - Tabs are rendered badly in patches, causing off-by-one errors in almost\n   every line.\n - It is the QEMU coding style.\n\nDo not leave whitespace dangling off the ends of lines.\n\n2. Line width\n\nLines should be 80 characters; try not to make them longer.\n\nSometimes it is hard to do, especially when dealing with QEMU subsystems\nthat use long function or symbol names.  Even in that case, do not make\nlines much longer than 80 characters.\n\nRationale:\n - Some people like to tile their 24\" screens with a 6x4 matrix of 80x24\n   xterms and use vi in all of them.  The best way to punish them is to\n   let them keep doing it.\n - Code and especially patches is much more readable if limited to a sane\n   line length.  Eighty is traditional.\n - The four-space indentation makes the most common excuse (\"But look\n   at all that white space on the left!\") moot.\n - It is the QEMU coding style.\n\n3. Naming\n\nVariables are lower_case_with_underscores; easy to type and read.  Structured\ntype names are in CamelCase; harder to type but standing out.  Enum type\nnames and function type names should also be in CamelCase.  Scalar type\nnames are lower_case_with_underscores_ending_with_a_t, like the POSIX\nuint64_t and family.  Note that this last convention contradicts POSIX\nand is therefore likely to be changed.\n\nWhen wrapping standard library functions, use the prefix qemu_ to alert\nreaders that they are seeing a wrapped version; otherwise avoid this prefix.\n\n4. Block structure\n\nEvery indented statement is braced; even if the block contains just one\nstatement.  The opening brace is on the line that contains the control\nflow statement that introduces the new block; the closing brace is on the\nsame line as the else keyword, or on a line by itself if there is no else\nkeyword.  Example:\n\n    if (a == 5) {\n        printf(\"a was 5.\\n\");\n    } else if (a == 6) {\n        printf(\"a was 6.\\n\");\n    } else {\n        printf(\"a was something else entirely.\\n\");\n    }\n\nNote that 'else if' is considered a single statement; otherwise a long if/\nelse if/else if/.../else sequence would need an indent for every else\nstatement.\n\nAn exception is the opening brace for a function; for reasons of tradition\nand clarity it comes on a line by itself:\n\n    void a_function(void)\n    {\n        do_something();\n    }\n\nRationale: a consistent (except for functions...) bracing style reduces\nambiguity and avoids needless churn when lines are added or removed.\nFurthermore, it is the QEMU coding style.\n\n5. Declarations\n\nMixed declarations (interleaving statements and declarations within\nblocks) are generally not allowed; declarations should be at the beginning\nof blocks.\n\nEvery now and then, an exception is made for declarations inside a\n#ifdef or #ifndef block: if the code looks nicer, such declarations can\nbe placed at the top of the block even if there are statements above.\nOn the other hand, however, it's often best to move that #ifdef/#ifndef\nblock to a separate function altogether.\n\n6. Conditional statements\n\nWhen comparing a variable for (in)equality with a constant, list the\nconstant on the right, as in:\n\nif (a == 1) {\n    /* Reads like: \"If a equals 1\" */\n    do_something();\n}\n\nRationale: Yoda conditions (as in 'if (1 == a)') are awkward to read.\nBesides, good compilers already warn users when '==' is mis-typed as '=',\neven when the constant is on the right.\n\n7. Comment style\n\nWe use traditional C-style /* */ comments and avoid // comments.\n\nRationale: The // form is valid in C99, so this is purely a matter of\nconsistency of style. The checkpatch script will warn you about this.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.5703125,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\f\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\f\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\f\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\f\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "COPYING.LIB",
          "type": "blob",
          "size": 25.806640625,
          "content": "\t\t  GNU LESSER GENERAL PUBLIC LICENSE\n\t\t       Version 2.1, February 1999\n\n Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n\t51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it.  You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations below.\n\n  When we speak of free software, we are referring to freedom of use,\nnot price.  Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\n  To protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights.  These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  We protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  To protect each distributor, we want to make it very clear that\nthere is no warranty for the free library.  Also, if the library is\nmodified by someone else and passed on, the recipients should know\nthat what they have is not the original version, so that the original\nauthor's reputation will not be affected by problems that might be\nintroduced by others.\n\f\n  Finally, software patents pose a constant threat to the existence of\nany free program.  We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder.  Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\n  Most GNU software, including some libraries, is covered by the\nordinary GNU General Public License.  This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License.  We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\n  When a program is linked with a library, whether statically or using\na shared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library.  The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom.  The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\n  We call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License.  It also provides other free software developers Less\nof an advantage over competing non-free programs.  These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries.  However, the Lesser license provides advantages in certain\nspecial circumstances.\n\n  For example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it becomes\na de-facto standard.  To achieve this, non-free programs must be\nallowed to use the library.  A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries.  In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\n  In other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software.  For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\n  Although the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\f\n\t\t  GNU LESSER GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\").\nEach licensee is addressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control compilation\nand installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n  \n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Use a suitable shared library mechanism for linking with the\n    Library.  A suitable mechanism is one that (1) uses at run time a\n    copy of the library already present on the user's computer system,\n    rather than copying library functions into the executable, and (2)\n    will operate properly with a modified version of the library, if\n    the user installs one, as long as the modified version is\n    interface-compatible with the version that the work was made with.\n\n    c) Accompany the work with a written offer, valid for at\n    least three years, to give the same user the materials\n    specified in Subsection 6a, above, for a charge no more\n    than the cost of performing this distribution.\n\n    d) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    e) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply,\nand the section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License may add\nan explicit geographical distribution limitation excluding those countries,\nso that distribution is permitted only in or among countries not thus\nexcluded.  In such case, this License incorporates the limitation as if\nwritten in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms of the\nordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.  It is\nsafest to attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the library, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n\n\n"
        },
        {
          "name": "Changelog",
          "type": "blob",
          "size": 22.607421875,
          "content": "This file documents changes for QEMU releases 0.12 and earlier.\nFor changelog information for later releases, see\nhttp://wiki.qemu-project.org/ChangeLog or look at the git history for\nmore detailed information.\n\n\nversion 0.12.0:\n\n  - Update to SeaBIOS 0.5.0\n  - e1000: fix device link status in Linux (Anthony Liguori)\n  - monitor: fix QMP for balloon command (Luiz Capitulino)\n  - QMP: Return an empty dict by default (Luiz Capitulino)\n  - QMP: Only handle converted commands (Luiz Capitulino)\n  - pci: support PCI based option rom loading (Gerd Hoffman/Anthony Liguori)\n  - Fix backcompat for hotplug of SCSI controllers (Daniel P. Berrange)\n  - fdc: fix migration from 0.11 (Juan Quintela)\n  - vmware-vga: fix segv on cursor resize. (Dave Airlie)\n  - vmware-vga: various fixes (Dave Airlie/Anthony Liguori)\n  - qdev: improve property error reporting. (Gerd Hoffmann)\n  - fix vga names in default_list (Gerd Hoffmann)\n  - usb-host: check mon before using it. (Gerd Hoffmann)\n  - usb-net: use qdev for -usbdevice (Gerd Hoffmann)\n  - monitor: Catch printing to non-existent monitor (Luiz Capitulino)\n  - Avoid permanently disabled QEMU monitor when UNIX migration fails (Daniel P. Berrange)\n  - Fix loading of ELF multiboot kernels (Kevin Wolf)\n  - qemu-io: Fix memory leak (Kevin Wolf)\n  - Fix thinko in linuxboot.S (Paolo Bonzini)\n  - target-i386: Fix evaluation of DR7 register (Jan Kiszka)\n  - vnc: hextile: do not generate ForegroundSpecified and SubrectsColoured tiles (Anthony Liguori)\n  - S390: Bail out without KVM (Alexander Graf)\n  - S390: Don't tell guest we're updating config space (Alexander Graf)\n  - target-s390: Fail on unknown instructions (Alexander Graf)\n  - osdep: Fix runtime failure on older Linux kernels (Andre Przywara)\n  - Fix a make -j race (Juergen Lock)\n  - target-alpha: Fix generic ctz64. (Richard Henderson)\n  - s390: Fix buggy assignment (Stefan Weil)\n  - target-mips: fix user-mode emulation startup (Nathan Froyd)\n  - target-i386: Update CPUID feature set for TCG (Andre Przywara)\n  - s390: fix build on 32 bit host (Michael S. Tsirkin)\n\t\nversion 0.12.0-rc2:\n\n  - v2: properly save kvm system time msr registers (Glauber Costa)\n  - convert more monitor commands to qmp (Luiz Capitulino)\n  - vnc: fix capslock tracking logic. (Gerd Hoffmann)\n  - QemuOpts: allow larger option values. (Gerd Hoffmann)\n  - scsi: fix drive hotplug. (Gerd Hoffmann)\n  - pci: don't hw_error() when no slot is available. (Gerd Hoffmann)\n  - pci: don't abort() when trying to hotplug with acpi off. (Gerd Hoffmann)\n  - allow default devices to be implemented in config file (Gerd Hoffman)\n  - vc: colorize chardev title line with blue background. (Gerd Hoffmann)\n  - chardev: make chardevs specified in config file work. (Gerd Hoffmann)\n  - qdev: also match bus name for global properties (Gerd Hoffmann)\n  - qdev: add command line option to set global defaults for properties. (Gerd Hoffmann)\n  - kvm: x86: Save/restore exception_index (Jan Kiszka)\n  - qdev: Replace device names containing whitespace (Markus Armbruster)\n  - fix rtc-td-hack on host without high-res timers (Gleb Natapov)\n  - virtio: verify features on load (Michael S. Tsirkin)\n  - vmware_vga: add rom file so that it boots. (Dave Airlie)\n  - Do not abort on qemu_malloc(0) in production builds (Anthony Liguori)\n  - Fix ARM userspace strex implementation. (Paul Brook)\n  - qemu: delete rule target on error (Michael S. Tsirkin)\n  - QMP: add human-readable description to error response (Markus Armbruster)\n  - convert more monitor commands to QError (Markus Armbruster)\n  - monitor: Fix double-prompt after \"change vnc passwd BLA\" (Markus Armbruster)\n  - monitor: do_cont(): Don't ask for passwords (Luiz Capitulino)\n  - monitor: Introduce 'block_passwd' command (Luiz Capitulino)\n  - pci: interrupt disable bit support (Michael S. Tsirkin)\n  - pci: interrupt status bit implementation (Michael S. Tsirkin)\n  - pci: prepare irq code for interrupt state (Michael S. Tsirkin)\n  - msix: function mask support (Michael S. Tsirkin)\n  - msix: macro rename for function mask support (Michael S. Tsirkin)\n  - cpuid: Fix multicore setup on Intel (Andre Przywara)\n  - kvm: x86: Fix initial kvm_has_msr_star (Jan Kiszka)\n  - Update OpenBIOS images to r640 (Aurelien Jarno)\t\n\nversion 0.10.2:\n\n  - fix savevm/loadvm (Anthony Liguori)\n  - live migration: fix dirty tracking windows (Glauber Costa)\n  - live migration: improve error propagation (Glauber Costa)\n  - qcow2: fix image creation for > ~2TB images (Chris Wright)\n  - hotplug: fix error handling for if= parameter (Eduardo Habkost)\n  - qcow2: fix data corruption (Nolan Leake)\n  - virtio: fix guest oops with 2.6.25 kernels (Rusty Russell)\n  - SH4: add support for -kernel (Takashi Yoshii, Aurelien Jarno)\n  - hotplug: fix closing of char devices (Jan Kiszka)\n  - hotplug: remove incorrect check for device name (Eduardo Habkost)\n  - enable -k on win32 (Herve Poussineau)\n  - configure: use LANG=C for grep (Andreas Faerber)\n  - fix VGA regression (malc)\n\t\nversion 0.10.1:\n\n  - virtio-net: check right return size on sg list (Alex Williamson)\n  - Make qemu_announce_self handle holes (live migration after hotplug)\n    (Marcelo Tosatti)\n  - Revert r6804-r6808 (qcow2 allocation info).  This series of changes added\n    a high cost to startup for large qcow2 images (Anthony Liguori)\n  - qemu-img: fix help message (Aurelien Jarno)\n  - Fix build for non-default installs of SDL (Anthony Liguori)\n  - Fix race condition in env->interrupt_request.  When using TCG and a dynticks\n    host timer, this condition could cause TCG to get stuck in an infinite\n    loop (Aurelien Jarno)\n  - Fix reading encrypted hard disk passwords during early startup (Jan Kiszka)\n  - Fix encrypted disk reporting in 'info block' (Jan Kiszka)\n  - Fix console size with tiny displays (MusicPal) (Jan Kiszka)\n  - Improve error handling in bdrv_open2 (Jan Kiszka)\n  - Avoid leaking data in mux'ed character devices (Jan Kiszka)\n  - Fix initial character device reset (no banner in monitor) (Jan Kiszka)\n  - Fix cpuid KVM crash on i386 host (Lubomir Rintel)\n  - Fix SLES10sp2 installation by adding ISTAT1 register to LSI SCSI emulation\n    (Ryan Harper)\n\nversion 0.10.0:\n\n  - TCG support (No longer requires GCC 3.x)\n  - Kernel Virtual Machine acceleration support\n  - BSD userspace emulation\n  - Bluetooth emulation and host passthrough support\n  - GDB XML register description support\n  - Intel e1000 emulation\n  - HPET emulation\n  - VirtIO paravirtual device support\n  - Marvell 88w8618 / MusicPal emulation\n  - Nokia N-series tablet emulation / OMAP2 processor emulation\n  - PCI hotplug support\n  - Live migration and new save/restore formats\n  - Curses display support\n  - qemu-nbd utility to mount supported block formats\n  - Altivec support in PPC emulation and new firmware (OpenBIOS)\n  - Multiple VNC clients are now supported\n  - TLS encryption is now supported in VNC\n  - MIPS Magnum R4000 machine (Hervé Poussineau)\n  - Braille support (Samuel Thibault)\n  - Freecom MusicPal system emulation (Jan Kiszka)\n  - OMAP242x and Nokia N800, N810 machines (Andrzej Zaborowski)\n  - EsounD audio driver (Frederick Reeve)\n  - Gravis Ultrasound GF1 sound card (Tibor \"TS\" Schütz)\n  - Many, many, bug fixes and new features\n\nversion 0.9.1:\n\n  - TFTP booting from host directory (Anthony Liguori, Erwan Velu)\n  - Tap device emulation for Solaris (Sittichai Palanisong)\n  - Monitor multiplexing to several I/O channels (Jason Wessel)\n  - ds1225y nvram support (Herve Poussineau)\n  - CPU model selection support (J. Mayer, Paul Brook, Herve Poussineau)\n  - Several Sparc fixes (Aurelien Jarno, Blue Swirl, Robert Reif)\n  - MIPS 64-bit FPU support (Thiemo Seufer)\n  - Xscale PDA emulation (Andrzej Zaborowski)\n  - ColdFire system emulation (Paul Brook)\n  - Improved SH4 support (Magnus Damm)\n  - MIPS64 support (Aurelien Jarno, Thiemo Seufer)\n  - Preliminary Alpha guest support (J. Mayer)\n  - Read-only support for Parallels disk images (Alex Beregszaszi)\n  - SVM (x86 virtualization) support (Alexander Graf)\n  - CRIS emulation (Edgar E. Iglesias)\n  - SPARC32PLUS execution support (Blue Swirl)\n  - MIPS mipssim pseudo machine (Thiemo Seufer)\n  - Strace for Linux userland emulation (Stuart Anderson, Thayne Harbaugh)\n  - OMAP310 MPU emulation plus Palm T|E machine (Andrzej Zaborowski)\n  - ARM v6, v7, NEON SIMD and SMP emulation (Paul Brook/CodeSourcery)\n  - Gumstix boards: connex and verdex emulation (Thorsten Zitterell)\n  - Intel mainstone II board emulation (Armin Kuster)\n  - VMware SVGA II graphics card support (Andrzej Zaborowski)\n\nversion 0.9.0:\n\n  - Support for relative paths in backing files for disk images\n  - Async file I/O API\n  - New qcow2 disk image format\n  - Support of multiple VM snapshots\n  - Linux: specific host CDROM and floppy support\n  - SMM support\n  - Moved PCI init, MP table init and ACPI table init to Bochs BIOS\n  - Support for MIPS32 Release 2 instruction set (Thiemo Seufer)\n  - MIPS Malta system emulation (Aurelien Jarno, Stefan Weil)\n  - Darwin userspace emulation (Pierre d'Herbemont)\n  - m68k user support (Paul Brook)\n  - several x86 and x86_64 emulation fixes\n  - Mouse relative offset VNC extension (Anthony Liguori)\n  - PXE boot support (Anthony Liguori)\n  - '-daemonize' option (Anthony Liguori)\n\nversion 0.8.2:\n\n  - ACPI support\n  - PC VGA BIOS fixes\n  - switch to OpenBios for SPARC targets (Blue Swirl)\n  - VNC server fixes\n  - MIPS FPU support (Marius Groeger)\n  - Solaris/SPARC host support (Juergen Keil)\n  - PPC breakpoints and single stepping (Jason Wessel)\n  - USB updates (Paul Brook)\n  - UDP/TCP/telnet character devices (Jason Wessel)\n  - Windows sparse file support (Frediano Ziglio)\n  - RTL8139 NIC TCP segmentation offloading (Igor Kovalenko)\n  - PCNET NIC support (Antony T Curtis)\n  - Support for variable frequency host CPUs\n  - Workaround for win32 SMP hosts\n  - Support for AMD Flash memories (Jocelyn Mayer)\n  - Audio capture to WAV files support (malc)\n\nversion 0.8.1:\n\n  - USB tablet support (Brad Campbell, Anthony Liguori)\n  - win32 host serial support (Kazu)\n  - PC speaker support (Joachim Henke)\n  - IDE LBA48 support (Jens Axboe)\n  - SSE3 support\n  - Solaris port (Juergen Keil)\n  - Preliminary SH4 target (Samuel Tardieu)\n  - VNC server (Anthony Liguori)\n  - slirp fixes (Ed Swierk et al.)\n  - USB fixes\n  - ARM Versatile Platform Baseboard emulation (Paul Brook)\n\nversion 0.8.0:\n\n  - ARM system emulation: Arm Integrator/CP board with an arm1026ej-s\n    cpu (Paul Brook)\n  - SMP support\n  - Mac OS X cocoa improvements (Mike Kronenberg)\n  - Mac OS X CoreAudio driver (Mike Kronenberg)\n  - DirectSound driver (malc)\n  - ALSA audio driver (malc)\n  - new audio options: '-soundhw' and '-audio-help' (malc)\n  - ES1370 PCI audio device (malc)\n  - Initial USB support\n  - Linux host serial port access\n  - Linux host low level parallel port access\n  - New network emulation code supporting VLANs.\n  - MIPS and MIPSel User Linux emulation\n  - MIPS fixes to boot Linux (Daniel Jacobowitz)\n  - NX bit support\n  - Initial SPARC SMP support (Blue Swirl)\n  - Major overhaul of the virtual FAT driver for read/write support\n    (Johannes Schindelin)\n\nversion 0.7.2:\n\n  - x86_64 fixes (Win2000 and Linux 2.6 boot in 32 bit)\n  - merge self modifying code handling in dirty ram page mecanism.\n  - MIPS fixes (Ralf Baechle)\n  - better user net performances\n\nversion 0.7.1:\n\n  - read-only Virtual FAT support (Johannes Schindelin)\n  - Windows 2000 install disk full hack (original idea from Vladimir\n    N. Oleynik)\n  - VMDK disk image creation (Filip Navara)\n  - SPARC64 progress (Blue Swirl)\n  - initial MIPS support (Jocelyn mayer)\n  - MIPS improvements (Ralf Baechle)\n  - 64 bit fixes in user networking (initial patch by Gwenole Beauchesne)\n  - IOAPIC support (Filip Navara)\n\nversion 0.7.0:\n\n  - better BIOS translation and HDD geometry auto-detection\n  - user mode networking bug fix\n  - undocumented FPU ops support\n  - Cirrus VGA: support for 1280x1024x[8,15,16] modes\n  - 'pidfile' option\n  - .dmg disk image format support (Johannes Schindelin)\n  - keymaps support (initial patch by Johannes Schindelin)\n  - big endian ARM support (Lennert Buytenhek)\n  - added generic 64 bit target support\n  - x86_64 target support\n  - initial APIC support\n  - MMX/SSE/SSE2/PNI support\n  - PC parallel port support (Mark Jonckheere)\n  - initial SPARC64 support (Blue Swirl)\n  - SPARC target boots Linux (Blue Swirl)\n  - armv5te user mode support (Paul Brook)\n  - ARM VFP support (Paul Brook)\n  - ARM \"Angel\" semihosting syscalls (Paul Brook)\n  - user mode gdb stub support (Paul Brook)\n  - Samba 3 support\n  - initial Cocoa support (Pierre d'Herbemont)\n  - generic FPU emulation code\n  - Virtual PC read-only disk image support (Alex Beregszaszi)\n\nversion 0.6.1:\n\n  - Mac OS X port (Pierre d'Herbemont)\n  - Virtual console support\n  - Better monitor line edition\n  - New block device layer\n  - New 'qcow' growable disk image support with AES encryption and\n    transparent decompression\n  - VMware 3 and 4 read-only disk image support (untested)\n  - Support for up to 4 serial ports\n  - TFTP server support (Magnus Damm)\n  - Port redirection support in user mode networking\n  - Support for not executable data sections\n  - Compressed loop disk image support (Johannes Schindelin)\n  - Level triggered IRQ fix (aka NE2000 PCI performance fix) (Steve\n    Wormley)\n  - Fixed Fedora Core 2 problems (now you can run qemu without any\n    LD_ASSUME_KERNEL tricks on FC2)\n  - DHCP fix for Windows (accept DHCPREQUEST alone)\n  - SPARC system emulation (Blue Swirl)\n  - Automatic Samba configuration for host file access from Windows.\n  - '-loadvm' and '-full-screen' options\n  - ne2000 savevm support (Johannes Schindelin)\n  - Ctrl-Alt is now the default grab key. Ctrl-Alt-[0-9] switches to\n    the virtual consoles.\n  - BIOS floppy fix for NT4 (Mike Nordell, Derek Fawcus, Volker Ruppert)\n  - Floppy fixes for NT4 and NT5 (Mike Nordell)\n  - NT4 IDE fixes (Ben Pfaf, Mike Nordell)\n  - SDL Audio support and SB16 fixes (malc)\n  - ENTER instruction bug fix (initial patch by Stefan Kisdaroczi)\n  - VGA font change fix\n  - VGA read-only CRTC register fix\n\nversion 0.6.0:\n\n  - minimalist FPU exception support (NetBSD FPU probe fix)\n  - cr0.ET fix (Win95 boot)\n  - *BSD port (Markus Niemisto)\n  - I/O access fix (signaled by Mark Jonckheere)\n  - IDE drives serial number fix (Mike Nordell)\n  - int13 CDROM BIOS fix (aka Solaris x86 install CD fix)\n  - int15, ah=86 BIOS fix (aka Solaris x86 hardware probe hang up fix)\n  - BSR/BSF \"undefined behaviour\" fix\n  - vmdk2raw: convert VMware disk images to raw images\n  - PCI support\n  - NE2K PCI support\n  - dummy VGA PCI support\n  - VGA font selection fix (Daniel Serpell)\n  - PIC reset fix (Hidemi KAWAI)\n  - PIC spurious irq support (aka Solaris install bug)\n  - added '-localtime' option\n  - Cirrus CL-GD54xx VGA support (initial patch by Makoto Suzuki (suzu))\n  - APM and system shutdown support\n  - Fixed system reset\n  - Support for other PC BIOSes\n  - Initial PowerMac hardware emulation\n  - PowerMac/PREP OpenFirmware compatible BIOS (Jocelyn Mayer)\n  - initial IDE BMDMA support (needed for Darwin x86)\n  - Set the default memory size for PC emulation to 128 MB\n\nversion 0.5.5:\n\n  - SDL full screen support (initial patch by malc)\n  - VGA support on PowerPC PREP\n  - VBE fixes (Matthew Mastracci)\n  - PIT fixes (aka Win98 hardware probe and \"VGA slowness\" bug)\n  - IDE master only fixes (aka Win98 CD-ROM probe bug)\n  - ARM load/store half word fix (Ulrich Hecht)\n  - FDC fixes for Win98\n\nversion 0.5.4:\n\n  - qemu-fast fixes\n  - BIOS area protection fix (aka EMM386.EXE fix) (Mike Nordell)\n  - keyboard/mouse fix (Mike Nordell)\n  - IDE fixes (Linux did not recognized slave drivers)\n  - VM86 EIP masking fix (aka NT5 install fix) (Mike Nordell)\n  - QEMU can now boot a PowerPC Linux kernel (Jocelyn Mayer)\n  - User mode network stack\n  - imul imm8 fix + 0x82 opcode support (Hidemi KAWAI)\n  - precise self modifying code (aka BeOS install bug)\n\nversion 0.5.3:\n\n  - added Bochs VESA VBE support\n  - VGA memory map mode 3 access fix (OS/2 install fix)\n  - IDE fixes (Jens Axboe)\n  - CPU interrupt fixes\n  - fixed various TLB invalidation cases (NT install)\n  - fixed cr0.WP semantics (XP install)\n  - direct chaining support for SPARC and PowerPC (faster)\n  - ARM NWFPE support (initial patch by Ulrich Hecht)\n  - added specific x86 to x86 translator (close to native performance\n    in qemu-i386 and qemu-fast)\n  - shm syscalls support (Paul McKerras)\n  - added accurate CR0.MP/ME/TS emulation\n  - fixed DMA memory write access (Win95 boot floppy fix)\n  - graphical x86 linux loader\n  - command line monitor\n  - generic removable device support\n  - support of CD-ROM change\n  - multiple network interface support\n  - initial x86-64 host support (Gwenole Beauchesne)\n  - lret to outer privilege fix (OS/2 install fix)\n  - task switch fixes (SkyOS boot)\n  - VM save/restore commands\n  - new timer API\n  - more precise RTC emulation (periodic timers + time updates)\n  - Win32 port (initial patch by Kazu)\n\nversion 0.5.2:\n\n  - improved soft MMU speed (assembly functions and specializing)\n  - improved multitasking speed by avoiding flushing TBs when\n    switching tasks\n  - improved qemu-fast speed\n  - improved self modifying code handling (big performance gain in\n    softmmu mode).\n  - fixed IO checking\n  - fixed CD-ROM detection (win98 install CD)\n  - fixed addseg real mode bug (GRUB boot fix)\n  - added ROM memory support (win98 boot)\n  - fixed 'call Ev' in case of paging exception\n  - updated the script 'qemu-binfmt-conf.sh' to use QEMU automagically\n    when launching executables for the supported target CPUs.\n  - PowerPC system emulation update (Jocelyn Mayer)\n  - PC floppy emulation and DMA fixes (Jocelyn Mayer)\n  - polled mode for PIC (Jocelyn Mayer)\n  - fixed PTE dirty bit handling\n  - fixed xadd same reg bug\n  - fixed cmpxchg exception safeness\n  - access to virtual memory in gdb stub\n  - task gate and NT flag fixes\n  - eflags optimisation fix for string operations\n\nversion 0.5.1:\n\n  - float access fixes when using soft mmu\n  - PC emulation support on PowerPC\n  - A20 support\n  - IDE CD-ROM emulation\n  - ARM fixes (Ulrich Hecht)\n  - SB16 emulation (malc)\n  - IRET and INT fixes in VM86 mode with IOPL=3\n  - Port I/Os use TSS io map\n  - Full task switching/task gate support\n  - added verr, verw, arpl, fcmovxx\n  - PowerPC target support (Jocelyn Mayer)\n  - Major SPARC target fixes (dynamically linked programs begin to work)\n\nversion 0.5.0:\n\n  - full hardware level VGA emulation\n  - graphical display with SDL\n  - added PS/2 mouse and keyboard emulation\n  - popw (%esp) fix\n  - mov to/from segment data width fix\n  - added real mode support\n  - added Bochs BIOS and LGPL'ed VGA BIOS loader in qemu\n  - m68k host port (Richard Zidlicky)\n  - partial soft MMU support for memory mapped I/Os\n  - multi-target build\n  - fixed: no error code in hardware interrupts\n  - fixed: pop ss, mov ss, x and sti disable hardware irqs for the next insn\n  - correct single stepping through string operations\n  - preliminary SPARC target support (Thomas M. Ogrisegg)\n  - tun-fd option (Rusty Russell)\n  - automatic IDE geometry detection\n  - renamed 'vl' to qemu[-fast] and user qemu to qemu-{cpu}.\n  - added man page\n  - added full soft mmu mode to launch unpatched OSes.\n\nversion 0.4.3:\n\n  - x86 exception fix in case of nop instruction.\n  - gcc 3.2.2 bug workaround (RedHat 9 fix)\n  - sparc and Alpha host fixes\n  - many ARM target fixes: 'ls' and 'bash' can be launched.\n\nversion 0.4.2:\n\n - many exception handling fixes (can compile a Linux kernel inside vl)\n - IDE emulation support\n - initial GDB stub support\n - deferred update support for disk images (Rusty Russell)\n - accept User Mode Linux Copy On Write disk images\n - SMP kernels can at least be booted\n\nversion 0.4.1:\n\n - more accurate timer support in vl.\n - more reliable NE2000 probe in vl.\n - added 2.5.66 kernel in vl-test.\n - added VLTMPDIR environment variable in vl.\n\nversion 0.4:\n\n - initial support for ring 0 x86 processor emulation\n - fixed signal handling for correct dosemu DPMI emulation\n - fast x86 MMU emulation with mmap()\n - fixed popl (%esp) case\n - Linux kernel can be executed by QEMU with the 'vl' command.\n\nversion 0.3:\n\n - initial support for ARM emulation\n - added fnsave, frstor, fnstenv, fldenv FPU instructions\n - added FPU register save in signal emulation\n - initial ARM port\n - Sparc and Alpha ports work on the regression test\n - generic ioctl number conversion\n - fixed ioctl type conversion\n\nversion 0.2:\n\n - PowerPC disassembly and ELF symbols output (Rusty Russell)\n - flock support (Rusty Russell)\n - ugetrlimit support (Rusty Russell)\n - fstat64 fix (Rusty Russell)\n - initial Alpha port (Falk Hueffner)\n - initial IA64 port (Matt Wilson)\n - initial Sparc and Sparc64 port (David S. Miller)\n - added HLT instruction\n - LRET instruction fix.\n - added GPF generation for I/Os.\n - added INT3 and TF flag support.\n - SHL instruction C flag fix.\n - mmap emulation for host page size > 4KB\n - self-modifying code support\n - better VM86 support (dosemu works on non trivial programs)\n - precise exception support (EIP is computed correctly in most cases)\n - more precise LDT/GDT/IDT emulation\n - faster segment load in vm86 mode\n - direct chaining of basic blocks (faster emulation)\n\nversion 0.1.6:\n\n - automatic library search system. QEMU can now work with unpatched\n   ELF dynamic loader and libc (Rusty Russell).\n - ISO C warning fixes (Alistair Strachan)\n - first self-virtualizable version (works only as long as the\n   translation cache is not flushed)\n - RH9 fixes\n\nversion 0.1.5:\n\n - ppc64 support + personality() patch (Rusty Russell)\n - first Alpha CPU patches (Falk Hueffner)\n - removed bfd.h dependency\n - fixed shrd, shld, idivl and divl on PowerPC.\n - fixed buggy glibc PowerPC rint() function (test-i386 passes now on PowerPC).\n\nversion 0.1.4:\n\n - more accurate VM86 emulation (can launch small DOS 16 bit\n   executables in wine).\n - fixed push/pop fs/gs\n - added iret instruction.\n - added times() syscall and SIOCATMARK ioctl.\n\nversion 0.1.3:\n\n - S390 support (Ulrich Weigand)\n - glibc 2.3.x compile fix (Ulrich Weigand)\n - socketcall endian fix (Ulrich Weigand)\n - struct sockaddr endian fix (Ulrich Weigand)\n - sendmsg/recvmsg endian fix (Ulrich Weigand)\n - execve endian fix (Ulrich Weigand)\n - fdset endian fix (Ulrich Weigand)\n - partial setsockopt syscall support (Ulrich Weigand)\n - more accurate pushf/popf emulation\n - first partial vm86() syscall support (can be used with runcom example).\n - added bound, cmpxchg8b, cpuid instructions\n - added 16 bit addressing support/override for string operations\n - poll() fix\n\nversion 0.1.2:\n\n - compile fixes\n - xlat instruction\n - xchg instruction memory lock\n - added simple vm86 example (not working with QEMU yet). The 54 byte\n   DOS executable 'pi_10.com' program was released by Bertram\n   Felgenhauer (more information at http://www.boo.net/~jasonp/pipage.html).\n\nversion 0.1.1:\n\n - glibc 2.2 compilation fixes\n - added -s and -L options\n - binary distribution of x86 glibc and wine\n - big endian fixes in ELF loader and getdents.\n\nversion 0.1:\n\n - initial public release.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 6.8662109375,
          "content": "ARG BASE_IMAGE=\"ubuntu:20.04\"\nARG TARGET_LIST=\"x86_64-softmmu,i386-softmmu,arm-softmmu,aarch64-softmmu,ppc-softmmu,mips-softmmu,mipsel-softmmu,mips64-softmmu,mips64el-softmmu\"\nARG LIBOSI_VERSION=\"v0.1.7\"\n\n### BASE IMAGE\nFROM $BASE_IMAGE as base\nARG BASE_IMAGE\n\n# Copy dependencies lists into container. We copy them all and then do a mv because\n# we need to transform base_image into a windows compatible filename which we can't\n# do in a COPY command.\nCOPY ./panda/dependencies/* /tmp\nRUN mv /tmp/$(echo \"$BASE_IMAGE\" | sed 's/:/_/g')_build.txt /tmp/build_dep.txt && \\\n    mv /tmp/$(echo \"$BASE_IMAGE\" | sed 's/:/_/g')_base.txt /tmp/base_dep.txt\n\n# Base image just needs runtime dependencies\nRUN [ -e /tmp/base_dep.txt ] && \\\n    apt-get -qq update && \\\n    DEBIAN_FRONTEND=noninteractive apt-get -qq install -y --no-install-recommends curl $(cat /tmp/base_dep.txt | grep -o '^[^#]*') && \\\n    apt-get clean\n\n### BUILD IMAGE - STAGE 2\nFROM base AS builder\nARG BASE_IMAGE\nARG TARGET_LIST\nARG LIBOSI_VERSION\n\nRUN [ -e /tmp/build_dep.txt ] && \\\n    apt-get -qq update && \\\n    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends $(cat /tmp/build_dep.txt | grep -o '^[^#]*') && \\\n    apt-get clean && \\\n    python3 -m pip install --upgrade --no-cache-dir pip && \\\n    python3 -m pip install --upgrade --no-cache-dir \"cffi>1.14.3\" && \\\n    python3 -m pip install --upgrade --no-cache-dir \"capstone\" && \\\n    curl https://sh.rustup.rs -sSf | sh -s -- -y --profile minimal\n\n# Then install capstone from source\nRUN cd /tmp && \\\n    git clone https://github.com/capstone-engine/capstone/ -b v5 && \\\n    cd capstone/ && ./make.sh && make install && cd /tmp && \\\n    rm -rf /tmp/capstone && ldconfig\n\nENV PATH=\"/root/.cargo/bin:${PATH}\"\n\n# install libosi\nRUN cd /tmp && curl -LJO https://github.com/panda-re/libosi/releases/download/${LIBOSI_VERSION}/libosi_$(echo \"$BASE_IMAGE\" | awk -F':' '{print $2}').deb && dpkg -i /tmp/libosi_$(echo \"$BASE_IMAGE\" | awk -F':' '{print $2}').deb\n\n# Build and install panda\n# Copy repo root directory to /panda, note we explicitly copy in .git directory\n# Note .dockerignore file keeps us from copying things we don't need\nCOPY . /panda/\nCOPY .git /panda/\n\n# Note we diable NUMA for docker builds because it causes make check to fail in docker\nRUN git -C /panda submodule update --init dtc && \\\n    git -C /panda rev-parse HEAD > /usr/local/panda_commit_hash && \\\n    mkdir  /panda/build && cd /panda/build && \\\n    python3 -m pip install setuptools_scm && \\\n    python3 -m setuptools_scm -r .. --strip-dev 2>/dev/null >/tmp/savedversion && \\\n    /panda/configure \\\n        --target-list=\"${TARGET_LIST}\" \\\n        --prefix=/usr/local \\\n        --disable-numa \\\n        --enable-llvm && \\\n    rm -rf /panda/.git\n    \n\nRUN PRETEND_VERSION=$(cat /tmp/savedversion) make -C /panda/build -j \"$(nproc)\"\n\n#### Develop setup: panda built + pypanda installed (in develop mode) - Stage 3\nFROM builder as developer\nRUN cd /panda/panda/python/core && \\\n    PRETEND_VERSION=$(cat /tmp/savedversion) python3 setup.py develop && \\\n    ldconfig && \\\n    update-alternatives --install /usr/bin/python python /usr/bin/python3 10 && \\\n    cd /panda && \\\n    ( git config --get-regexp http > /dev/null && \\\n    git config --remove-section http.https://github.com/ || true ) && \\\n    git remote set-url origin https://github.com/panda-re/panda\nWORKDIR /panda/\n\n#### Install PANDA + pypanda from builder - Stage 4\nFROM builder as installer\nRUN  make -C /panda/build install && \\\n    rm -r /usr/local/lib/panda/*/cosi \\\n        /usr/local/lib/panda/*/cosi_strace \\\n        /usr/local/lib/panda/*/gdb \\\n        /usr/local/lib/panda/*/snake_hook \\\n        /usr/local/lib/panda/*/rust_skeleton\n\n# Install pypanda\nRUN cd /panda/panda/python/core && \\\n    PRETEND_VERSION=$(cat /tmp/savedversion) python3 setup.py install\nRUN python3 -m pip install --ignore-install pycparser && python3 -m pip install --force-reinstall --no-binary :all: cffi\n# Build a whl too\nRUN cd /panda/panda/python/core && \\\n    PRETEND_VERSION=$(cat /tmp/savedversion) python3 setup.py bdist_wheel\n\n# BUG: PANDA sometimes fails to generate all the necessary files for PyPANDA. This is a temporary fix to detect and fail when this occurs\nRUN ls -alt $(pip show pandare | grep Location: | awk '{print $2}')/pandare/autogen/\nRUN bash -c \"ls $(pip show pandare | grep Location: | awk '{print $2}')/pandare/autogen/panda_{aarch64_64,arm_32,mips64_64,mips_32,mipsel_32,ppc_32,ppc_64,x86_64_64,i386_32}.py\"\n\n# this layer is used to strip shared objects and change python data to be\n# symlinks to the installed panda data directory\nFROM installer as cleanup\nRUN find /usr/local/lib/panda -name \"*.so\" -exec strip {} \\;\nRUN PKG=`pip show pandare | grep Location: | awk '{print $2}'`/pandare/data; \\\n    rm -rf $PKG/pc-bios && ln -s /usr/local/share/panda $PKG/pc-bios; \\\n    for arch in `find $PKG -name \"*-softmmu\" -type d -exec basename {} \\;` ; do \\\n        ARCHP=$PKG/$arch; \\\n        SARCH=`echo $arch | cut -d'-' -f 1`; \\\n        rm $ARCHP/libpanda-$SARCH.so $ARCHP/llvm-helpers-$SARCH.bc; \\\n        ln -s /usr/local/share/panda/llvm-helpers-$SARCH.bc $ARCHP/llvm-helpers-$SARCH.bc1; \\\n        ln -s /usr/local/bin/libpanda-$SARCH.so $ARCHP/libpanda-$SARCH.so; \\ \n        rm -rf $ARCHP/panda/plugins; \\\n        ln -s /usr/local/lib/panda/$SARCH/ $ARCHP/panda/plugins; \\\n    done\n\n### Copy files for panda+pypanda from installer  - Stage 5\nFROM base as panda\n\n# Include dependency lists for packager\nCOPY --from=base /tmp/base_dep.txt /tmp\nCOPY --from=base /tmp/build_dep.txt /tmp\n\n# Copy panda + libcapstone.so* + libosi libraries\nCOPY --from=cleanup /usr/local /usr/local\nCOPY --from=cleanup /usr/lib/libcapstone* /usr/lib/\nCOPY --from=cleanup /lib/libosi.so /lib/libiohal.so /lib/liboffset.so /lib/\n\n# Workaround issue #901 - ensure LD_LIBRARY_PATH contains the panda plugins directories\n#ARG TARGET_LIST=\"x86_64-softmmu,i386-softmmu,arm-softmmu,ppc-softmmu,mips-softmmu,mipsel-softmmu\"\nENV LD_LIBRARY_PATH /usr/local/lib/python3.8/dist-packages/pandare/data/x86_64-softmmu/panda/plugins/:/usr/local/lib/python3.8/dist-packages/pandare/data/i386-softmmu/panda/plugins/:/usr/local/lib/python3.8/dist-packages/pandare/data/arm-softmmu/panda/plugins/:/usr/local/lib/python3.8/dist-packages/pandare/data/ppc-softmmu/panda/plugins/:/usr/local/lib/python3.8/dist-packages/pandare/data/mips-softmmu/panda/plugins/:/usr/local/lib/python3.8/dist-packages/pandare/data/mipsel-softmmu/panda/plugins/\n#PANDA_PATH is used by rust plugins\nENV PANDA_PATH /usr/local/lib/python3.8/dist-packages/pandare/data\n\n\n# Ensure runtime dependencies are installed for our libpanda objects and panda plugins\nRUN ldconfig && \\\n    update-alternatives --install /usr/bin/python python /usr/bin/python3 10 && \\\n    if (ldd /usr/local/lib/python*/dist-packages/pandare/data/*-softmmu/libpanda-*.so | grep 'not found'); then exit 1; fi && \\\n    if (ldd /usr/local/lib/python*/dist-packages/pandare/data/*-softmmu/panda/plugins/*.so | grep 'not found'); then exit 1; fi\n"
        },
        {
          "name": "HACKING",
          "type": "blob",
          "size": 9.9287109375,
          "content": "1. Preprocessor\n\n1.1. Variadic macros\n\nFor variadic macros, stick with this C99-like syntax:\n\n#define DPRINTF(fmt, ...)                                       \\\n    do { printf(\"IRQ: \" fmt, ## __VA_ARGS__); } while (0)\n\n1.2. Include directives\n\nOrder include directives as follows:\n\n#include \"qemu/osdep.h\"  /* Always first... */\n#include <...>           /* then system headers... */\n#include \"...\"           /* and finally QEMU headers. */\n\nThe \"qemu/osdep.h\" header contains preprocessor macros that affect the behavior\nof core system headers like <stdint.h>.  It must be the first include so that\ncore system headers included by external libraries get the preprocessor macros\nthat QEMU depends on.\n\nDo not include \"qemu/osdep.h\" from header files since the .c file will have\nalready included it.\n\n2. C types\n\nIt should be common sense to use the right type, but we have collected\na few useful guidelines here.\n\n2.1. Scalars\n\nIf you're using \"int\" or \"long\", odds are good that there's a better type.\nIf a variable is counting something, it should be declared with an\nunsigned type.\n\nIf it's host memory-size related, size_t should be a good choice (use\nssize_t only if required). Guest RAM memory offsets must use ram_addr_t,\nbut only for RAM, it may not cover whole guest address space.\n\nIf it's file-size related, use off_t.\nIf it's file-offset related (i.e., signed), use off_t.\nIf it's just counting small numbers use \"unsigned int\";\n(on all but oddball embedded systems, you can assume that that\ntype is at least four bytes wide).\n\nIn the event that you require a specific width, use a standard type\nlike int32_t, uint32_t, uint64_t, etc.  The specific types are\nmandatory for VMState fields.\n\nDon't use Linux kernel internal types like u32, __u32 or __le32.\n\nUse hwaddr for guest physical addresses except pcibus_t\nfor PCI addresses.  In addition, ram_addr_t is a QEMU internal address\nspace that maps guest RAM physical addresses into an intermediate\naddress space that can map to host virtual address spaces.  Generally\nspeaking, the size of guest memory can always fit into ram_addr_t but\nit would not be correct to store an actual guest physical address in a\nram_addr_t.\n\nFor CPU virtual addresses there are several possible types.\nvaddr is the best type to use to hold a CPU virtual address in\ntarget-independent code. It is guaranteed to be large enough to hold a\nvirtual address for any target, and it does not change size from target\nto target. It is always unsigned.\ntarget_ulong is a type the size of a virtual address on the CPU; this means\nit may be 32 or 64 bits depending on which target is being built. It should\ntherefore be used only in target-specific code, and in some\nperformance-critical built-per-target core code such as the TLB code.\nThere is also a signed version, target_long.\nabi_ulong is for the *-user targets, and represents a type the size of\n'void *' in that target's ABI. (This may not be the same as the size of a\nfull CPU virtual address in the case of target ABIs which use 32 bit pointers\non 64 bit CPUs, like sparc32plus.) Definitions of structures that must match\nthe target's ABI must use this type for anything that on the target is defined\nto be an 'unsigned long' or a pointer type.\nThere is also a signed version, abi_long.\n\nOf course, take all of the above with a grain of salt.  If you're about\nto use some system interface that requires a type like size_t, pid_t or\noff_t, use matching types for any corresponding variables.\n\nAlso, if you try to use e.g., \"unsigned int\" as a type, and that\nconflicts with the signedness of a related variable, sometimes\nit's best just to use the *wrong* type, if \"pulling the thread\"\nand fixing all related variables would be too invasive.\n\nFinally, while using descriptive types is important, be careful not to\ngo overboard.  If whatever you're doing causes warnings, or requires\ncasts, then reconsider or ask for help.\n\n2.2. Pointers\n\nEnsure that all of your pointers are \"const-correct\".\nUnless a pointer is used to modify the pointed-to storage,\ngive it the \"const\" attribute.  That way, the reader knows\nup-front that this is a read-only pointer.  Perhaps more\nimportantly, if we're diligent about this, when you see a non-const\npointer, you're guaranteed that it is used to modify the storage\nit points to, or it is aliased to another pointer that is.\n\n2.3. Typedefs\nTypedefs are used to eliminate the redundant 'struct' keyword.\n\n2.4. Reserved namespaces in C and POSIX\nUnderscore capital, double underscore, and underscore 't' suffixes should be\navoided.\n\n3. Low level memory management\n\nUse of the malloc/free/realloc/calloc/valloc/memalign/posix_memalign\nAPIs is not allowed in the QEMU codebase. Instead of these routines,\nuse the GLib memory allocation routines g_malloc/g_malloc0/g_new/\ng_new0/g_realloc/g_free or QEMU's qemu_memalign/qemu_blockalign/qemu_vfree\nAPIs.\n\nPlease note that g_malloc will exit on allocation failure, so there\nis no need to test for failure (as you would have to with malloc).\nCalling g_malloc with a zero size is valid and will return NULL.\n\nMemory allocated by qemu_memalign or qemu_blockalign must be freed with\nqemu_vfree, since breaking this will cause problems on Win32.\n\n4. String manipulation\n\nDo not use the strncpy function.  As mentioned in the man page, it does *not*\nguarantee a NULL-terminated buffer, which makes it extremely dangerous to use.\nIt also zeros trailing destination bytes out to the specified length.  Instead,\nuse this similar function when possible, but note its different signature:\nvoid pstrcpy(char *dest, int dest_buf_size, const char *src)\n\nDon't use strcat because it can't check for buffer overflows, but:\nchar *pstrcat(char *buf, int buf_size, const char *s)\n\nThe same limitation exists with sprintf and vsprintf, so use snprintf and\nvsnprintf.\n\nQEMU provides other useful string functions:\nint strstart(const char *str, const char *val, const char **ptr)\nint stristart(const char *str, const char *val, const char **ptr)\nint qemu_strnlen(const char *s, int max_len)\n\nThere are also replacement character processing macros for isxyz and toxyz,\nso instead of e.g. isalnum you should use qemu_isalnum.\n\nBecause of the memory management rules, you must use g_strdup/g_strndup\ninstead of plain strdup/strndup.\n\n5. Printf-style functions\n\nWhenever you add a new printf-style function, i.e., one with a format\nstring argument and following \"...\" in its prototype, be sure to use\ngcc's printf attribute directive in the prototype.\n\nThis makes it so gcc's -Wformat and -Wformat-security options can do\ntheir jobs and cross-check format strings with the number and types\nof arguments.\n\n6. C standard, implementation defined and undefined behaviors\n\nC code in QEMU should be written to the C99 language specification. A copy\nof the final version of the C99 standard with corrigenda TC1, TC2, and TC3\nincluded, formatted as a draft, can be downloaded from:\n http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf\n\nThe C language specification defines regions of undefined behavior and\nimplementation defined behavior (to give compiler authors enough leeway to\nproduce better code).  In general, code in QEMU should follow the language\nspecification and avoid both undefined and implementation defined\nconstructs. (\"It works fine on the gcc I tested it with\" is not a valid\nargument...) However there are a few areas where we allow ourselves to\nassume certain behaviors because in practice all the platforms we care about\nbehave in the same way and writing strictly conformant code would be\npainful. These are:\n * you may assume that integers are 2s complement representation\n * you may assume that right shift of a signed integer duplicates\n   the sign bit (ie it is an arithmetic shift, not a logical shift)\n\nIn addition, QEMU assumes that the compiler does not use the latitude\ngiven in C99 and C11 to treat aspects of signed '<<' as undefined, as\ndocumented in the GNU Compiler Collection manual starting at version 4.0.\n\n7. Error handling and reporting\n\n7.1 Reporting errors to the human user\n\nDo not use printf(), fprintf() or monitor_printf().  Instead, use\nerror_report() or error_vreport() from error-report.h.  This ensures the\nerror is reported in the right place (current monitor or stderr), and in\na uniform format.\n\nUse error_printf() & friends to print additional information.\n\nerror_report() prints the current location.  In certain common cases\nlike command line parsing, the current location is tracked\nautomatically.  To manipulate it manually, use the loc_*() from\nerror-report.h.\n\n7.2 Propagating errors\n\nAn error can't always be reported to the user right where it's detected,\nbut often needs to be propagated up the call chain to a place that can\nhandle it.  This can be done in various ways.\n\nThe most flexible one is Error objects.  See error.h for usage\ninformation.\n\nUse the simplest suitable method to communicate success / failure to\ncallers.  Stick to common methods: non-negative on success / -1 on\nerror, non-negative / -errno, non-null / null, or Error objects.\n\nExample: when a function returns a non-null pointer on success, and it\ncan fail only in one way (as far as the caller is concerned), returning\nnull on failure is just fine, and certainly simpler and a lot easier on\nthe eyes than propagating an Error object through an Error ** parameter.\n\nExample: when a function's callers need to report details on failure\nonly the function really knows, use Error **, and set suitable errors.\n\nDo not report an error to the user when you're also returning an error\nfor somebody else to handle.  Leave the reporting to the place that\nconsumes the error returned.\n\n7.3 Handling errors\n\nCalling exit() is fine when handling configuration errors during\nstartup.  It's problematic during normal operation.  In particular,\nmonitor commands should never exit().\n\nDo not call exit() or abort() to handle an error that can be triggered\nby the guest (e.g., some unimplemented corner case in guest code\ntranslation or device emulation).  Guests should not be able to\nterminate QEMU.\n\nNote that &error_fatal is just another way to exit(1), and &error_abort\nis just another way to abort().\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.8203125,
          "content": "The following points clarify the QEMU license:\n\n1) QEMU as a whole is released under the GNU General Public License,\nversion 2.\n\n2) Parts of QEMU have specific licenses which are compatible with the\nGNU General Public License, version 2. Hence each source file contains\nits own licensing information.  Source files with no licensing information\nare released under the GNU General Public License, version 2 or (at your\noption) any later version.\n\nAs of July 2013, contributions under version 2 of the GNU General Public\nLicense (and no later version) are only accepted for the following files\nor directories: bsd-user/, linux-user/, hw/vfio/, hw/xen/xen_pt*.\n\n3) The Tiny Code Generator (TCG) is released under the BSD license\n   (see license headers in files).\n\n4) QEMU is a trademark of Fabrice Bellard.\n\nFabrice Bellard and the QEMU team\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 36.9912109375,
          "content": "QEMU Maintainers\n================\n\nThe intention of this file is not to establish who owns what portions of the\ncode base, but to provide a set of names that developers can consult when they\nhave a question about a particular subset and also to provide a set of names\nto be CC'd when submitting a patch to obtain appropriate review.\n\nIn general, if you have a question about inclusion of a patch, you should\nconsult qemu-devel and not any specific individual privately.\n\nDescriptions of section entries:\n\n\tM: Mail patches to: FullName <address@domain>\n\tL: Mailing list that is relevant to this area\n\tW: Web-page with status/info\n\tQ: Patchwork web based patch tracking system site\n\tT: SCM tree type and location.  Type is one of: git, hg, quilt, stgit.\n\tS: Status, one of the following:\n\t   Supported:\tSomeone is actually paid to look after this.\n\t   Maintained:\tSomeone actually looks after it.\n\t   Odd Fixes:\tIt has a maintainer but they don't have time to do\n\t\t\tmuch other than throw the odd patch in. See below.\n\t   Orphan:\tNo current maintainer [but maybe you could take the\n\t\t\trole as you write your new code].\n\t   Obsolete:\tOld code. Something tagged obsolete generally means\n\t\t\tit has been replaced by a better system and you\n\t\t\tshould be using that.\n\tF: Files and directories with wildcard patterns.\n\t   A trailing slash includes all files and subdirectory files.\n\t   F:\tdrivers/net/\tall files in and below drivers/net\n\t   F:\tdrivers/net/*\tall files in drivers/net, but not below\n\t   F:\t*/net/*\t\tall files in \"any top level directory\"/net\n\t   One pattern per line.  Multiple F: lines acceptable.\n\tX: Files and directories that are NOT maintained, same rules as F:\n\t   Files exclusions are tested before file matches.\n\t   Can be useful for excluding a specific subdirectory, for instance:\n\t   F:\tnet/\n\t   X:\tnet/ipv6/\n\t   matches all files in and below net excluding net/ipv6/\n\tK: Keyword perl extended regex pattern to match content in a\n\t   patch or file.  For instance:\n\t   K: of_get_profile\n\t      matches patches or files that contain \"of_get_profile\"\n\t   K: \\b(printk|pr_(info|err))\\b\n\t      matches patches or files that contain one or more of the words\n\t      printk, pr_info or pr_err\n\t   One regex pattern per line.  Multiple K: lines acceptable.\n\n\nGeneral Project Administration\n------------------------------\nM: Peter Maydell <peter.maydell@linaro.org>\n\nAll patches CC here\nL: qemu-devel@nongnu.org\nF: *\nF: */\n\nResponsible Disclosure, Reporting Security Issues\n------------------------------\nW: http://wiki.qemu.org/SecurityProcess\nM: Michael S. Tsirkin <mst@redhat.com>\nL: secalert@redhat.com\n\nTrivial patches\n---------------\nTrivial patches\nM: Michael Tokarev <mjt@tls.msk.ru>\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nL: qemu-trivial@nongnu.org\nK: ^Subject:.*(?i)trivial\nT: git git://git.corpit.ru/qemu.git trivial-patches\nT: git git://github.com/vivier/qemu.git trivial-patches\n\nGuest CPU cores (TCG):\n----------------------\nOverall\nL: qemu-devel@nongnu.org\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Peter Crosthwaite <crosthwaite.peter@gmail.com>\nM: Richard Henderson <rth@twiddle.net>\nS: Maintained\nF: cpu-exec.c\nF: cpu-exec-common.c\nF: cpus.c\nF: cputlb.c\nF: exec.c\nF: softmmu_template.h\nF: translate-all.*\nF: translate-common.c\nF: include/exec/cpu*.h\nF: include/exec/exec-all.h\nF: include/exec/helper*.h\nF: include/exec/tb-hash.h\nF: include/sysemu/cpus.h\n\nFPU emulation\nM: Aurelien Jarno <aurelien@aurel32.net>\nM: Peter Maydell <peter.maydell@linaro.org>\nS: Odd Fixes\nF: fpu/\nF: include/fpu/\n\nAlpha\nM: Richard Henderson <rth@twiddle.net>\nS: Maintained\nF: target/alpha/\nF: hw/alpha/\nF: tests/tcg/alpha/\nF: disas/alpha.c\n\nARM\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: target/arm/\nF: hw/arm/\nF: hw/cpu/a*mpcore.c\nF: include/hw/cpu/a*mpcore.h\nF: disas/arm.c\nF: disas/arm-a64.cc\nF: disas/libvixl/\n\nCRIS\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: target/cris/\nF: hw/cris/\nF: include/hw/cris/\nF: tests/tcg/cris/\nF: disas/cris.c\n\nHPPA (PA-RISC)\nM: Richard Henderson <rth@twiddle.net>\nS: Maintained\nF: target/hppa/\nF: disas/hppa.c\n\nLM32\nM: Michael Walle <michael@walle.cc>\nS: Maintained\nF: target/lm32/\nF: disas/lm32.c\nF: hw/lm32/\nF: hw/*/lm32_*\nF: hw/*/milkymist-*\nF: include/hw/char/lm32_juart.h\nF: include/hw/lm32/\nF: tests/tcg/lm32/\n\nM68K\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nF: target/m68k/\nF: disas/m68k.c\n\nMicroBlaze\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: target/microblaze/\nF: hw/microblaze/\nF: disas/microblaze.c\n\nMIPS\nM: Aurelien Jarno <aurelien@aurel32.net>\nM: Yongbok Kim <yongbok.kim@imgtec.com>\nS: Maintained\nF: target/mips/\nF: hw/mips/\nF: hw/misc/mips_*\nF: hw/intc/mips_gic.c\nF: hw/timer/mips_gictimer.c\nF: include/hw/mips/\nF: include/hw/misc/mips_*\nF: include/hw/intc/mips_gic.h\nF: include/hw/timer/mips_gictimer.h\nF: tests/tcg/mips/\nF: disas/mips.c\n\nMoxie\nM: Anthony Green <green@moxielogic.com>\nS: Maintained\nF: target/moxie/\nF: disas/moxie.c\nF: hw/moxie/\nF: default-configs/moxie-softmmu.mak\n\nNiosII\nM: Chris Wulff <crwulff@gmail.com>\nM: Marek Vasut <marex@denx.de>\nS: Maintained\nF: target/nios2/\nF: hw/nios2/\nF: disas/nios2.c\n\nOpenRISC\nM: Jia Liu <proljc@gmail.com>\nS: Maintained\nF: target/openrisc/\nF: hw/openrisc/\nF: tests/tcg/openrisc/\n\nPowerPC\nM: David Gibson <david@gibson.dropbear.id.au>\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: target/ppc/\nF: hw/ppc/\nF: include/hw/ppc/\nF: disas/ppc.c\n\nS390\nM: Richard Henderson <rth@twiddle.net>\nM: Alexander Graf <agraf@suse.de>\nS: Maintained\nF: target/s390x/\nF: hw/s390x/\nF: disas/s390.c\n\nSH4\nM: Aurelien Jarno <aurelien@aurel32.net>\nS: Odd Fixes\nF: target/sh4/\nF: hw/sh4/\nF: disas/sh4.c\nF: include/hw/sh4/\n\nSPARC\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nM: Artyom Tarasenko <atar4qemu@gmail.com>\nS: Maintained\nF: target/sparc/\nF: hw/sparc/\nF: hw/sparc64/\nF: disas/sparc.c\n\nUniCore32\nM: Guan Xuetao <gxt@mprc.pku.edu.cn>\nS: Maintained\nF: target/unicore32/\nF: hw/unicore32/\nF: include/hw/unicore32/\n\nX86\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Richard Henderson <rth@twiddle.net>\nM: Eduardo Habkost <ehabkost@redhat.com>\nS: Maintained\nF: target/i386/\nF: hw/i386/\nF: disas/i386.c\n\nXtensa\nM: Max Filippov <jcmvbkbc@gmail.com>\nW: http://wiki.osll.spb.ru/doku.php?id=etc:users:jcmvbkbc:qemu-target-xtensa\nS: Maintained\nF: target/xtensa/\nF: hw/xtensa/\nF: tests/tcg/xtensa/\n\nTriCore\nM: Bastian Koppelmann <kbastian@mail.uni-paderborn.de>\nS: Maintained\nF: target/tricore/\nF: hw/tricore/\nF: include/hw/tricore/\n\nGuest CPU Cores (KVM):\n----------------------\n\nOverall\nM: Paolo Bonzini <pbonzini@redhat.com>\nL: kvm@vger.kernel.org\nS: Supported\nF: kvm-*\nF: */kvm.*\nF: include/sysemu/kvm*.h\n\nARM\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: target/arm/kvm.c\n\nMIPS\nM: James Hogan <james.hogan@imgtec.com>\nS: Maintained\nF: target/mips/kvm.c\n\nPPC\nM: Alexander Graf <agraf@suse.de>\nS: Maintained\nF: target/ppc/kvm.c\n\nS390\nM: Christian Borntraeger <borntraeger@de.ibm.com>\nM: Cornelia Huck <cornelia.huck@de.ibm.com>\nM: Alexander Graf <agraf@suse.de>\nS: Maintained\nF: target/s390x/kvm.c\nF: target/s390x/ioinst.[ch]\nF: target/s390x/machine.c\nF: hw/intc/s390_flic.c\nF: hw/intc/s390_flic_kvm.c\nF: include/hw/s390x/s390_flic.h\nF: gdb-xml/s390*.xml\nT: git git://github.com/cohuck/qemu.git s390-next\nT: git git://github.com/borntraeger/qemu.git s390-next\n\nX86\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Marcelo Tosatti <mtosatti@redhat.com>\nL: kvm@vger.kernel.org\nS: Supported\nF: target/i386/kvm.c\n\nGuest CPU Cores (Xen):\n----------------------\n\nX86\nM: Stefano Stabellini <sstabellini@kernel.org>\nM: Anthony Perard <anthony.perard@citrix.com>\nL: xen-devel@lists.xenproject.org\nS: Supported\nF: xen-*\nF: */xen*\nF: hw/char/xen_console.c\nF: hw/display/xenfb.c\nF: hw/net/xen_nic.c\nF: hw/block/xen_*\nF: hw/xen/\nF: hw/xenpv/\nF: hw/i386/xen/\nF: include/hw/xen/\nF: include/sysemu/xen-mapcache.h\n\nHosts:\n------\n\nLINUX\nL: qemu-devel@nongnu.org\nS: Maintained\nF: linux-*\nF: linux-headers/\n\nPOSIX\nL: qemu-devel@nongnu.org\nS: Maintained\nF: *posix*\n\nW32, W64\nL: qemu-devel@nongnu.org\nM: Stefan Weil <sw@weilnetz.de>\nS: Maintained\nF: *win32*\nF: */*win32*\nF: include/*/*win32*\nX: qga/*win32*\nF: qemu.nsi\n\nARM Machines\n------------\nAllwinner-a10\nM: Beniamino Galvani <b.galvani@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/allwinner*\nF: include/hw/*/allwinner*\nF: hw/arm/cubieboard.c\n\nARM PrimeCell\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/char/pl011.c\nF: hw/display/pl110*\nF: hw/dma/pl080.c\nF: hw/dma/pl330.c\nF: hw/gpio/pl061.c\nF: hw/input/pl050.c\nF: hw/intc/pl190.c\nF: hw/sd/pl181.c\nF: hw/timer/pl031.c\nF: include/hw/arm/primecell.h\n\nARM cores\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/intc/arm*\nF: hw/intc/gic_internal.h\nF: hw/misc/a9scu.c\nF: hw/misc/arm11scu.c\nF: hw/timer/a9gtimer*\nF: hw/timer/arm_*\nF: include/hw/arm/arm.h\nF: include/hw/intc/arm*\nF: include/hw/misc/a9scu.h\nF: include/hw/misc/arm11scu.h\nF: include/hw/timer/a9gtimer.h\nF: include/hw/timer/arm_mptimer.h\n\nExynos\nM: Igor Mitsyanko <i.mitsyanko@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/exynos*\nF: include/hw/arm/exynos4210.h\n\nCalxeda Highbank\nM: Rob Herring <robh@kernel.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/highbank.c\nF: hw/net/xgmac.c\n\nCanon DIGIC\nM: Antony Pavlov <antonynpavlov@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: include/hw/arm/digic.h\nF: hw/*/digic*\n\nGumstix\nL: qemu-devel@nongnu.org\nL: qemu-arm@nongnu.org\nS: Orphan\nF: hw/arm/gumstix.c\n\ni.MX31\nM: Peter Chubb <peter.chubb@nicta.com.au>\nL: qemu-arm@nongnu.org\nS: Odd fixes\nF: hw/*/imx*\nF: include/hw/*/imx*\nF: hw/arm/kzm.c\nF: include/hw/arm/fsl-imx31.h\n\nIntegrator CP\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/integratorcp.c\nF: hw/misc/arm_integrator_debug.c\n\nMusicpal\nM: Jan Kiszka <jan.kiszka@web.de>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/musicpal.c\n\nnSeries\nM: Andrzej Zaborowski <balrogg@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/nseries.c\n\nPalm\nM: Andrzej Zaborowski <balrogg@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/palm.c\n\nReal View\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/realview*\nF: hw/cpu/realview_mpcore.c\nF: hw/intc/realview_gic.c\nF: include/hw/intc/realview_gic.h\n\nPXA2XX\nM: Andrzej Zaborowski <balrogg@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/mainstone.c\nF: hw/arm/spitz.c\nF: hw/arm/tosa.c\nF: hw/arm/z2.c\nF: hw/*/pxa2xx*\nF: hw/misc/mst_fpga.c\nF: include/hw/arm/pxa.h\n\nStellaris\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/stellaris*\n\nVersatile PB\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/versatile*\n\nXilinx Zynq\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nM: Alistair Francis <alistair.francis@xilinx.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/xilinx_*\nF: hw/*/cadence_*\nF: hw/misc/zynq*\nF: include/hw/misc/zynq*\nX: hw/ssi/xilinx_*\n\nXilinx ZynqMP\nM: Alistair Francis <alistair.francis@xilinx.com>\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/xlnx*.c\nF: include/hw/*/xlnx*.h\n\nARM ACPI Subsystem\nM: Shannon Zhao <zhaoshenglong@huawei.com>\nM: Shannon Zhao <shannon.zhao@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/virt-acpi-build.c\n\nSTM32F205\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/arm/stm32f205_soc.c\nF: hw/misc/stm32f2xx_syscfg.c\nF: hw/char/stm32f2xx_usart.c\nF: hw/timer/stm32f2xx_timer.c\nF: hw/adc/*\nF: hw/ssi/stm32f2xx_spi.c\n\nNetduino 2\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/arm/netduino2.c\n\nCRIS Machines\n-------------\nAxis Dev88\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/cris/axis_dev88.c\nF: hw/*/etraxfs_*.c\n\nLM32 Machines\n-------------\nEVR32 and uclinux BSP\nM: Michael Walle <michael@walle.cc>\nS: Maintained\nF: hw/lm32/lm32_boards.c\n\nmilkymist\nM: Michael Walle <michael@walle.cc>\nS: Maintained\nF: hw/lm32/milkymist.c\n\nM68K Machines\n-------------\nan5206\nM: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: hw/m68k/an5206.c\nF: hw/m68k/mcf5206.c\n\nmcf5208\nM: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: hw/m68k/mcf5208.c\nF: hw/m68k/mcf_intc.c\nF: hw/char/mcf_uart.c\nF: hw/net/mcf_fec.c\nF: include/hw/m68k/mcf*.h\n\nMicroBlaze Machines\n-------------------\npetalogix_s3adsp1800\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/microblaze/petalogix_s3adsp1800_mmu.c\n\npetalogix_ml605\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/microblaze/petalogix_ml605_mmu.c\n\nMIPS Machines\n-------------\nJazz\nM: Hervé Poussineau <hpoussin@reactos.org>\nS: Maintained\nF: hw/mips/mips_jazz.c\n\nMalta\nM: Aurelien Jarno <aurelien@aurel32.net>\nS: Maintained\nF: hw/mips/mips_malta.c\n\nMipssim\nM: Yongbok Kim <yongbok.kim@imgtec.com>\nS: Odd Fixes\nF: hw/mips/mips_mipssim.c\nF: hw/net/mipsnet.c\n\nR4000\nM: Aurelien Jarno <aurelien@aurel32.net>\nS: Maintained\nF: hw/mips/mips_r4k.c\n\nFulong 2E\nM: Yongbok Kim <yongbok.kim@imgtec.com>\nS: Odd Fixes\nF: hw/mips/mips_fulong2e.c\n\nBoston\nM: Paul Burton <paul.burton@imgtec.com>\nS: Maintained\nF: hw/core/loader-fit.c\nF: hw/mips/boston.c\nF: hw/pci-host/xilinx-pcie.c\n\nOpenRISC Machines\n-----------------\nor1k-sim\nM: Jia Liu <proljc@gmail.com>\nS: Maintained\nF: hw/openrisc/openrisc_sim.c\n\nPowerPC Machines\n----------------\n405\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: hw/ppc/ppc405_boards.c\n\nBamboo\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: hw/ppc/ppc440_bamboo.c\n\ne500\nM: Alexander Graf <agraf@suse.de>\nM: Scott Wood <scottwood@freescale.com>\nL: qemu-ppc@nongnu.org\nS: Supported\nF: hw/ppc/e500.[hc]\nF: hw/ppc/e500plat.c\nF: include/hw/ppc/ppc_e500.h\nF: include/hw/pci-host/ppce500.h\nF: pc-bios/u-boot.e500\n\nmpc8544ds\nM: Alexander Graf <agraf@suse.de>\nM: Scott Wood <scottwood@freescale.com>\nL: qemu-ppc@nongnu.org\nS: Supported\nF: hw/ppc/mpc8544ds.c\nF: hw/ppc/mpc8544_guts.c\n\nNew World\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/mac_newworld.c\nF: hw/pci-host/uninorth.c\nF: hw/pci-bridge/dec.[hc]\nF: hw/misc/macio/\nF: include/hw/ppc/mac_dbdma.h\nF: hw/nvram/mac_nvram.c\n\nOld World\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/mac_oldworld.c\nF: hw/pci-host/grackle.c\nF: hw/misc/macio/\nF: hw/intc/heathrow_pic.c\n\nPReP\nM: Hervé Poussineau <hpoussin@reactos.org>\nL: qemu-devel@nongnu.org\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/prep.c\nF: hw/ppc/prep_systemio.c\nF: hw/ppc/rs6000_mc.c\nF: hw/pci-host/prep.[hc]\nF: hw/isa/pc87312.[hc]\nF: pc-bios/ppc_rom.bin\n\nsPAPR\nM: David Gibson <david@gibson.dropbear.id.au>\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Supported\nF: hw/*/spapr*\nF: include/hw/*/spapr*\nF: hw/*/xics*\nF: include/hw/*/xics*\nF: pc-bios/spapr-rtas/*\nF: pc-bios/spapr-rtas.bin\nF: pc-bios/slof.bin\nF: pc-bios/skiboot.lid\nF: docs/specs/ppc-spapr-hcalls.txt\nF: docs/specs/ppc-spapr-hotplug.txt\nF: tests/spapr*\nF: tests/libqos/*spapr*\nF: tests/rtas*\nF: tests/libqos/rtas*\n\nvirtex_ml507\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: hw/ppc/virtex_ml507.c\n\nSH4 Machines\n------------\nR2D\nM: Magnus Damm <magnus.damm@gmail.com>\nS: Maintained\nF: hw/sh4/r2d.c\nF: hw/intc/sh_intc.c\nF: hw/timer/sh_timer.c\n\nShix\nM: Magnus Damm <magnus.damm@gmail.com>\nS: Odd Fixes\nF: hw/sh4/shix.c\n\nSPARC Machines\n--------------\nSun4m\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nS: Maintained\nF: hw/sparc/sun4m.c\nF: hw/dma/sparc32_dma.c\nF: hw/dma/sun4m_iommu.c\nF: hw/misc/eccmemctl.c\nF: hw/misc/slavio_misc.c\nF: include/hw/sparc/sparc32_dma.h\nF: include/hw/sparc/sun4m.h\nF: pc-bios/openbios-sparc32\n\nSun4u\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nS: Maintained\nF: hw/sparc64/sun4u.c\nF: pc-bios/openbios-sparc64\n\nSun4v\nM: Artyom Tarasenko <atar4qemu@gmail.com>\nS: Maintained\nF: hw/sparc64/sun4v.c\nF: hw/timer/sun4v-rtc.c\nF: include/hw/timer/sun4v-rtc.h\n\nLeon3\nM: Fabien Chouteau <chouteau@adacore.com>\nS: Maintained\nF: hw/sparc/leon3.c\nF: hw/*/grlib*\nF: include/hw/sparc/grlib.h\n\nS390 Machines\n-------------\nS390 Virtio-ccw\nM: Cornelia Huck <cornelia.huck@de.ibm.com>\nM: Christian Borntraeger <borntraeger@de.ibm.com>\nM: Alexander Graf <agraf@suse.de>\nS: Supported\nF: hw/char/sclp*.[hc]\nF: hw/s390x/\nF: include/hw/s390x/\nF: pc-bios/s390-ccw/\nF: hw/watchdog/wdt_diag288.c\nF: include/hw/watchdog/wdt_diag288.h\nF: pc-bios/s390-ccw.img\nF: default-configs/s390x-softmmu.mak\nT: git git://github.com/cohuck/qemu.git s390-next\nT: git git://github.com/borntraeger/qemu.git s390-next\n\nUniCore32 Machines\n-------------\nPKUnity-3 SoC initramfs-with-busybox\nM: Guan Xuetao <gxt@mprc.pku.edu.cn>\nS: Maintained\nF: hw/*/puv3*\nF: hw/unicore32/\n\nX86 Machines\n------------\nPC\nM: Michael S. Tsirkin <mst@redhat.com>\nS: Supported\nF: include/hw/i386/\nF: hw/i386/\nF: hw/pci-host/piix.c\nF: hw/pci-host/q35.c\nF: hw/pci-host/pam.c\nF: include/hw/pci-host/q35.h\nF: include/hw/pci-host/pam.h\nF: hw/isa/piix4.c\nF: hw/isa/lpc_ich9.c\nF: hw/i2c/smbus_ich9.c\nF: hw/acpi/piix4.c\nF: hw/acpi/ich9.c\nF: include/hw/acpi/ich9.h\nF: include/hw/acpi/piix4.h\nF: hw/misc/sga.c\n\nPC Chipset\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Support\nF: hw/char/debugcon.c\nF: hw/char/parallel.c\nF: hw/char/serial*\nF: hw/dma/i8257*\nF: hw/i2c/pm_smbus.c\nF: hw/intc/apic*\nF: hw/intc/ioapic*\nF: hw/intc/i8259*\nF: hw/misc/debugexit.c\nF: hw/misc/pc-testdev.c\nF: hw/timer/hpet*\nF: hw/timer/i8254*\nF: hw/timer/mc146818rtc*\nF: include/hw/i2c/pm_smbus.h\nF: include/hw/timer/hpet.h\nF: include/hw/timer/i8254*\nF: include/hw/timer/mc146818rtc*\n\nMachine core\nM: Eduardo Habkost <ehabkost@redhat.com>\nM: Marcel Apfelbaum <marcel@redhat.com>\nS: Supported\nF: hw/core/machine.c\nF: hw/core/null-machine.c\nF: include/hw/boards.h\n\nXtensa Machines\n---------------\nsim\nM: Max Filippov <jcmvbkbc@gmail.com>\nS: Maintained\nF: hw/xtensa/sim.c\n\nXTFPGA (LX60, LX200, ML605, KC705)\nM: Max Filippov <jcmvbkbc@gmail.com>\nS: Maintained\nF: hw/xtensa/xtfpga.c\nF: hw/net/opencores_eth.c\n\nDevices\n-------\nEDU\nM: Jiri Slaby <jslaby@suse.cz>\nS: Maintained\nF: hw/misc/edu.c\n\nIDE\nM: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: include/hw/ide.h\nF: include/hw/ide/\nF: hw/ide/\nF: hw/block/block.c\nF: hw/block/cdrom.c\nF: hw/block/hd-geometry.c\nF: tests/ide-test.c\nF: tests/ahci-test.c\nF: tests/libqos/ahci*\nT: git git://github.com/jnsnow/qemu.git ide\n\nFloppy\nM: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/block/fdc.c\nF: include/hw/block/fdc.h\nF: tests/fdc-test.c\nT: git git://github.com/jnsnow/qemu.git ide\n\nOMAP\nM: Peter Maydell <peter.maydell@linaro.org>\nS: Maintained\nF: hw/*/omap*\nF: include/hw/arm/omap.h\n\nIPack\nM: Alberto Garcia <berto@igalia.com>\nS: Odd Fixes\nF: hw/char/ipoctal232.c\nF: hw/ipack/\n\nPCI\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Marcel Apfelbaum <marcel@redhat.com>\nS: Supported\nF: include/hw/pci/*\nF: hw/misc/pci-testdev.c\nF: hw/pci/*\nF: hw/pci-bridge/*\n\nACPI/SMBIOS\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Igor Mammedov <imammedo@redhat.com>\nS: Supported\nF: include/hw/acpi/*\nF: include/hw/smbios/*\nF: hw/mem/*\nF: hw/acpi/*\nF: hw/smbios/*\nF: hw/i386/acpi-build.[hc]\nF: hw/arm/virt-acpi-build.c\nF: tests/bios-tables-test.c\nF: tests/acpi-utils.[hc]\n\nppc4xx\nM: Alexander Graf <agraf@suse.de>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: hw/ppc/ppc4*.c\nF: include/hw/ppc/ppc4xx.h\n\nppce500\nM: Alexander Graf <agraf@suse.de>\nM: Scott Wood <scottwood@freescale.com>\nL: qemu-ppc@nongnu.org\nS: Supported\nF: hw/ppc/e500*\nF: hw/pci-host/ppce500.c\nF: hw/net/fsl_etsec/\n\nCharacter devices\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Odd Fixes\nF: hw/char/\n\nNetwork devices\nM: Jason Wang <jasowang@redhat.com>\nS: Odd Fixes\nF: hw/net/\nF: tests/virtio-net-test.c\nT: git git://github.com/jasowang/qemu.git net\n\nSCSI\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Supported\nF: include/hw/scsi/*\nF: hw/scsi/*\nF: tests/virtio-scsi-test.c\nT: git git://github.com/bonzini/qemu.git scsi-next\n\nLSI53C895A\nS: Orphan\nF: hw/scsi/lsi53c895a.c\n\nSSI\nM: Peter Crosthwaite <crosthwaite.peter@gmail.com>\nS: Maintained\nF: hw/ssi/*\nF: hw/block/m25p80.c\nX: hw/ssi/xilinx_*\n\nXilinx SPI\nM: Alistair Francis <alistair.francis@xilinx.com>\nM: Peter Crosthwaite <crosthwaite.peter@gmail.com>\nS: Maintained\nF: hw/ssi/xilinx_*\n\nUSB\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: hw/usb/*\nF: tests/usb-*-test.c\nF: docs/usb2.txt\nF: docs/usb-storage.txt\nF: include/hw/usb.h\nF: include/hw/usb/\n\nUSB (serial adapter)\nM: Gerd Hoffmann <kraxel@redhat.com>\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nS: Maintained\nF: hw/usb/dev-serial.c\n\nVFIO\nM: Alex Williamson <alex.williamson@redhat.com>\nS: Supported\nF: hw/vfio/*\nF: include/hw/vfio/\n\nvhost\nM: Michael S. Tsirkin <mst@redhat.com>\nS: Supported\nF: hw/*/*vhost*\n\nvirtio\nM: Michael S. Tsirkin <mst@redhat.com>\nS: Supported\nF: hw/*/virtio*\nF: hw/virtio/Makefile.objs\nF: hw/virtio/trace-events\nF: net/vhost-user.c\nF: include/hw/virtio/\nF: tests/virtio-balloon-test.c\n\nvirtio-9p\nM: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\nM: Greg Kurz <groug@kaod.org>\nS: Supported\nF: hw/9pfs/\nF: fsdev/\nF: tests/virtio-9p-test.c\nT: git git://github.com/kvaneesh/QEMU.git\nT: git git://github.com/gkurz/qemu.git 9p-next\n\nvirtio-blk\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/block/virtio-blk.c\nF: hw/block/dataplane/*\nF: tests/virtio-blk-test.c\nT: git git://github.com/stefanha/qemu.git block\n\nvirtio-ccw\nM: Cornelia Huck <cornelia.huck@de.ibm.com>\nM: Christian Borntraeger <borntraeger@de.ibm.com>\nS: Supported\nF: hw/s390x/virtio-ccw.[hc]\nT: git git://github.com/cohuck/qemu.git s390-next\nT: git git://github.com/borntraeger/qemu.git s390-next\n\nvirtio-input\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: hw/input/virtio-input*.c\nF: include/hw/virtio/virtio-input.h\n\nvirtio-serial\nM: Amit Shah <amit@kernel.org>\nS: Supported\nF: hw/char/virtio-serial-bus.c\nF: hw/char/virtio-console.c\nF: include/hw/virtio/virtio-serial.h\nF: tests/virtio-console-test.c\nF: tests/virtio-serial-test.c\n\nvirtio-rng\nM: Amit Shah <amit@kernel.org>\nS: Supported\nF: hw/virtio/virtio-rng.c\nF: include/hw/virtio/virtio-rng.h\nF: include/sysemu/rng*.h\nF: backends/rng*.c\nF: tests/virtio-rng-test.c\n\nvirtio-crypto\nM: Gonglei <arei.gonglei@huawei.com>\nS: Supported\nF: hw/virtio/virtio-crypto.c\nF: hw/virtio/virtio-crypto-pci.c\nF: include/hw/virtio/virtio-crypto.h\n\nnvme\nM: Keith Busch <keith.busch@intel.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/block/nvme*\nF: tests/nvme-test.c\n\nmegasas\nM: Hannes Reinecke <hare@suse.de>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/scsi/megasas.c\nF: hw/scsi/mfi.h\n\nNetwork packet abstractions\nM: Dmitry Fleytman <dmitry@daynix.com>\nS: Maintained\nF: include/net/eth.h\nF: net/eth.c\nF: hw/net/net_rx_pkt*\nF: hw/net/net_tx_pkt*\n\nVmware\nM: Dmitry Fleytman <dmitry@daynix.com>\nS: Maintained\nF: hw/net/vmxnet*\nF: hw/scsi/vmw_pvscsi*\n\nRocker\nM: Jiri Pirko <jiri@resnulli.us>\nS: Maintained\nF: hw/net/rocker/\nF: tests/rocker/\nF: docs/specs/rocker.txt\n\nNVDIMM\nM: Xiao Guangrong <guangrong.xiao@linux.intel.com>\nS: Maintained\nF: hw/acpi/nvdimm.c\nF: hw/mem/nvdimm.c\nF: include/hw/mem/nvdimm.h\n\ne1000x\nM: Dmitry Fleytman <dmitry@daynix.com>\nS: Maintained\nF: hw/net/e1000x*\n\ne1000e\nM: Dmitry Fleytman <dmitry@daynix.com>\nS: Maintained\nF: hw/net/e1000e*\nF: tests/qtest/fuzz-e1000e-test.c\n\nGeneric Loader\nM: Alistair Francis <alistair.francis@xilinx.com>\nS: Maintained\nF: hw/core/generic-loader.c\nF: include/hw/core/generic-loader.h\n\nCHRP NVRAM\nM: Thomas Huth <thuth@redhat.com>\nS: Maintained\nF: hw/nvram/chrp_nvram.c\nF: include/hw/nvram/chrp_nvram.h\nF: tests/prom-env-test.c\n\nVM Generation ID\nM: Ben Warren <ben@skyportsystems.com>\nS: Maintained\nF: hw/acpi/vmgenid.c\nF: include/hw/acpi/vmgenid.h\nF: docs/specs/vmgenid.txt\nF: tests/vmgenid-test.c\nF: stubs/vmgenid.c\n\nSubsystems\n----------\nAudio\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: audio/\nF: hw/audio/\nF: include/hw/audio/\nF: tests/ac97-test.c\nF: tests/es1370-test.c\nF: tests/intel-hda-test.c\n\nBlock layer core\nM: Kevin Wolf <kwolf@redhat.com>\nM: Max Reitz <mreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block*\nF: block/\nF: hw/block/\nF: include/block/\nF: qemu-img*\nF: qemu-io*\nF: tests/qemu-iotests/\nT: git git://repo.or.cz/qemu/kevin.git block\n\nBlock I/O path\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Fam Zheng <famz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: async.c\nF: aio-*.c\nF: block/io.c\nF: migration/block*\nF: include/block/aio.h\nT: git git://github.com/stefanha/qemu.git block\n\nBlock Jobs\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: blockjob.c\nF: include/block/blockjob.h\nF: block/backup.c\nF: block/commit.c\nF: block/stream.c\nF: block/mirror.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nBlock QAPI, monitor, command line\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: blockdev.c\nF: block/qapi.c\nF: qapi/block*.json\nT: git git://repo.or.cz/qemu/armbru.git block-next\n\nDirty Bitmaps\nM: Fam Zheng <famz@redhat.com>\nM: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: util/hbitmap.c\nF: block/dirty-bitmap.c\nF: include/qemu/hbitmap.h\nF: include/block/dirty-bitmap.h\nF: tests/test-hbitmap.c\nF: docs/bitmaps.md\nT: git git://github.com/famz/qemu.git bitmaps\nT: git git://github.com/jnsnow/qemu.git bitmaps\n\nCharacter device backends\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nS: Maintained\nF: chardev/\nF: backends/msmouse.c\nF: backends/testdev.c\n\nCharacter Devices (Braille)\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nS: Maintained\nF: backends/baum.c\n\nCommand line option argument parsing\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: include/qemu/option.h\nF: tests/test-keyval.c\nF: tests/test-qemu-opts.c\nF: util/keyval.c\nF: util/qemu-option.c\n\nCoverity model\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: scripts/coverity-model.c\n\nCPU\nL: qemu-devel@nongnu.org\nS: Supported\nF: qom/cpu.c\nF: include/qom/cpu.h\n\nDevice Tree\nM: Peter Crosthwaite <crosthwaite.peter@gmail.com>\nM: Alexander Graf <agraf@suse.de>\nS: Maintained\nF: device_tree.c\nF: include/sysemu/device_tree.h\n\nError reporting\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: include/qapi/error.h\nF: include/qemu/error-report.h\nF: util/error.c\nF: util/qemu-error.c\n\nGDB stub\nL: qemu-devel@nongnu.org\nS: Odd Fixes\nF: gdbstub*\nF: gdb-xml/\n\nMemory API\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Supported\nF: include/exec/ioport.h\nF: ioport.c\nF: include/exec/memory.h\nF: include/exec/ram_addr.h\nF: memory.c\nF: include/exec/memory-internal.h\nF: exec.c\n\nSPICE\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Supported\nF: include/ui/qemu-spice.h\nF: include/ui/spice-display.h\nF: ui/spice-*.c\nF: audio/spiceaudio.c\nF: hw/display/qxl*\n\nGraphics\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: ui/\nF: include/ui/\n\nCocoa graphics\nM: Peter Maydell <peter.maydell@linaro.org>\nS: Odd Fixes\nF: ui/cocoa.m\n\nMain loop\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: cpus.c\nF: main-loop.c\nF: qemu-timer.c\nF: vl.c\n\nHuman Monitor (HMP)\nM: Dr. David Alan Gilbert <dgilbert@redhat.com>\nS: Maintained\nF: monitor.c\nF: hmp.[ch]\nF: hmp-commands*.hx\nF: include/monitor/hmp-target.h\n\nNetwork device backends\nM: Jason Wang <jasowang@redhat.com>\nS: Maintained\nF: net/\nF: include/net/\nT: git git://github.com/jasowang/qemu.git net\n\nNetmap network backend\nM: Luigi Rizzo <rizzo@iet.unipi.it>\nM: Giuseppe Lettieri <g.lettieri@iet.unipi.it>\nM: Vincenzo Maffione <v.maffione@gmail.com>\nW: http://info.iet.unipi.it/~luigi/netmap/\nS: Maintained\nF: net/netmap.c\n\nNetwork Block Device (NBD)\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Odd Fixes\nF: block/nbd*\nF: nbd/\nF: include/block/nbd*\nF: qemu-nbd.c\nT: git git://github.com/bonzini/qemu.git nbd-next\n\nNUMA\nM: Eduardo Habkost <ehabkost@redhat.com>\nS: Maintained\nF: numa.c\nF: include/sysemu/numa.h\nT: git git://github.com/ehabkost/qemu.git numa\n\nHost Memory Backends\nM: Eduardo Habkost <ehabkost@redhat.com>\nM: Igor Mammedov <imammedo@redhat.com>\nS: Maintained\nF: backends/hostmem*.c\nF: include/sysemu/hostmem.h\n\nCryptodev Backends\nM: Gonglei <arei.gonglei@huawei.com>\nS: Maintained\nF: include/sysemu/cryptodev*.h\nF: backends/cryptodev*.c\n\nQAPI\nM: Markus Armbruster <armbru@redhat.com>\nM: Michael Roth <mdroth@linux.vnet.ibm.com>\nS: Supported\nF: qapi/\nX: qapi/*.json\nF: include/qapi/\nX: include/qapi/qmp/\nF: include/qapi/qmp/dispatch.h\nF: tests/qapi-schema/\nF: tests/test-*-visitor.c\nF: tests/test-qapi-*.c\nF: tests/test-qmp-*.c\nF: tests/test-visitor-serialization.c\nF: scripts/qapi*\nF: docs/qapi*\nT: git git://repo.or.cz/qemu/armbru.git qapi-next\n\nQAPI Schema\nM: Eric Blake <eblake@redhat.com>\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: qapi-schema.json\nF: qapi/*.json\nT: git git://repo.or.cz/qemu/armbru.git qapi-next\n\nQObject\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: qobject/\nF: include/qapi/qmp/\nX: include/qapi/qmp/dispatch.h\nF: scripts/coccinelle/qobject.cocci\nF: tests/check-qdict.c\nF: tests/check-qfloat.c\nF: tests/check-qint.c\nF: tests/check-qjson.c\nF: tests/check-qlist.c\nF: tests/check-qstring.c\nT: git git://repo.or.cz/qemu/armbru.git qapi-next\n\nQEMU Guest Agent\nM: Michael Roth <mdroth@linux.vnet.ibm.com>\nS: Maintained\nF: qga/\nT: git git://github.com/mdroth/qemu.git qga\n\nQOM\nM: Andreas Färber <afaerber@suse.de>\nS: Supported\nT: git git://github.com/afaerber/qemu-cpu.git qom-next\nF: include/qom/\nX: include/qom/cpu.h\nF: qom/\nX: qom/cpu.c\nF: tests/check-qom-interface.c\nF: tests/check-qom-proplist.c\nF: tests/qom-test.c\n\nQMP\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: qmp.c\nF: monitor.c\nF: docs/*qmp-*\nF: scripts/qmp/\nF: tests/qmp-test.c\nT: git git://repo.or.cz/qemu/armbru.git qapi-next\n\nRegister API\nM: Alistair Francis <alistair.francis@xilinx.com>\nS: Maintained\nF: hw/core/register.c\nF: include/hw/register.h\n\nSLIRP\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nM: Jan Kiszka <jan.kiszka@siemens.com>\nS: Maintained\nF: slirp/\nF: net/slirp.c\nF: include/net/slirp.h\nT: git git://git.kiszka.org/qemu.git queues/slirp\n\nStubs\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: stubs/\n\nTracing\nM: Stefan Hajnoczi <stefanha@redhat.com>\nS: Maintained\nF: trace/\nF: scripts/tracetool.py\nF: scripts/tracetool/\nF: docs/tracing.txt\nT: git git://github.com/stefanha/qemu.git tracing\n\nCheckpatch\nS: Odd Fixes\nF: scripts/checkpatch.pl\n\nMigration\nM: Juan Quintela <quintela@redhat.com>\nM: Dr. David Alan Gilbert <dgilbert@redhat.com>\nS: Maintained\nF: include/migration/\nF: migration/\nF: scripts/vmstate-static-checker.py\nF: tests/vmstate-static-checker-data/\nF: docs/migration.txt\n\nSeccomp\nM: Eduardo Otubo <eduardo.otubo@profitbricks.com>\nS: Supported\nF: qemu-seccomp.c\nF: include/sysemu/seccomp.h\n\nCryptography\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: crypto/\nF: include/crypto/\nF: tests/test-crypto-*\n\nCoroutines\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Kevin Wolf <kwolf@redhat.com>\nF: util/*coroutine*\nF: include/qemu/coroutine*\nF: tests/test-coroutine.c\n\nBuffers\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd fixes\nF: util/buffer.c\nF: include/qemu/buffer.h\n\nI/O Channels\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: io/\nF: include/io/\nF: tests/test-io-*\n\nSockets\nM: Daniel P. Berrange <berrange@redhat.com>\nM: Gerd Hoffmann <kraxel@redhat.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: include/qemu/sockets.h\nF: util/qemu-sockets.c\n\nThrottling infrastructure\nM: Alberto Garcia <berto@igalia.com>\nS: Supported\nF: block/throttle-groups.c\nF: include/block/throttle-groups.h\nF: include/qemu/throttle.h\nF: util/throttle.c\nL: qemu-block@nongnu.org\n\nUUID\nM: Fam Zheng <famz@redhat.com>\nS: Supported\nF: util/uuid.c\nF: include/qemu/uuid.h\nF: tests/test-uuid.c\n\nCOLO Framework\nM: zhanghailiang <zhang.zhanghailiang@huawei.com>\nS: Maintained\nF: migration/colo*\nF: include/migration/colo.h\nF: include/migration/failover.h\nF: docs/COLO-FT.txt\n\nCOLO Proxy\nM: Zhang Chen <zhangchen.fnst@cn.fujitsu.com>\nM: Li Zhijian <lizhijian@cn.fujitsu.com>\nS: Supported\nF: docs/colo-proxy.txt\nF: net/colo*\nF: net/filter-rewriter.c\nF: net/filter-mirror.c\n\nUsermode Emulation\n------------------\nOverall\nM: Riku Voipio <riku.voipio@iki.fi>\nS: Maintained\nF: thunk.c\nF: user-exec.c\nF: user-exec-stub.c\n\nBSD user\nS: Orphan\nF: bsd-user/\nF: default-configs/*-bsd-user.mak\n\nLinux user\nM: Riku Voipio <riku.voipio@iki.fi>\nS: Maintained\nF: linux-user/\nF: default-configs/*-linux-user.mak\n\nTiny Code Generator (TCG)\n-------------------------\nCommon code\nM: Richard Henderson <rth@twiddle.net>\nS: Maintained\nF: tcg/\n\nAArch64 target\nM: Claudio Fontana <claudio.fontana@huawei.com>\nM: Claudio Fontana <claudio.fontana@gmail.com>\nS: Maintained\nL: qemu-arm@nongnu.org\nF: tcg/aarch64/\nF: disas/arm-a64.cc\nF: disas/libvixl/\n\nARM target\nM: Andrzej Zaborowski <balrogg@gmail.com>\nS: Maintained\nL: qemu-arm@nongnu.org\nF: tcg/arm/\nF: disas/arm.c\n\ni386 target\nL: qemu-devel@nongnu.org\nS: Maintained\nF: tcg/i386/\nF: disas/i386.c\n\nMIPS target\nM: Aurelien Jarno <aurelien@aurel32.net>\nS: Maintained\nF: tcg/mips/\nF: disas/mips.c\n\nPPC\nM: Richard Henderson <rth@twiddle.net>\nS: Odd Fixes\nF: tcg/ppc/\nF: disas/ppc.c\n\nS390 target\nM: Alexander Graf <agraf@suse.de>\nM: Richard Henderson <rth@twiddle.net>\nS: Maintained\nF: tcg/s390/\nF: disas/s390.c\n\nSPARC target\nS: Odd Fixes\nF: tcg/sparc/\nF: disas/sparc.c\n\nTCI target\nM: Stefan Weil <sw@weilnetz.de>\nS: Maintained\nF: tcg/tci/\nF: tci.c\nF: disas/tci.c\n\nBlock drivers\n-------------\nVMDK\nM: Fam Zheng <famz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vmdk.c\n\nRBD\nM: Josh Durgin <jdurgin@redhat.com>\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/rbd.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nSheepdog\nM: Hitoshi Mitake <mitake.hitoshi@lab.ntt.co.jp>\nM: Liu Yuan <namei.unix@gmail.com>\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nL: sheepdog@lists.wpkg.org\nS: Supported\nF: block/sheepdog.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nVHDX\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vhdx*\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nVDI\nM: Stefan Weil <sw@weilnetz.de>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/vdi.c\n\niSCSI\nM: Ronnie Sahlberg <ronniesahlberg@gmail.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Peter Lieven <pl@kamp.de>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/iscsi.c\nF: block/iscsi-opts.c\n\nNFS\nM: Jeff Cody <jcody@redhat.com>\nM: Peter Lieven <pl@kamp.de>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/nfs.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nSSH\nM: Richard W.M. Jones <rjones@redhat.com>\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/ssh.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nCURL\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/curl.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nGLUSTER\nM: Jeff Cody <jcody@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/gluster.c\nT: git git://github.com/codyprime/qemu-kvm-jtc.git block\n\nNull Block Driver\nM: Fam Zheng <famz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/null.c\n\nBootdevice\nM: Gonglei <arei.gonglei@huawei.com>\nS: Maintained\nF: bootdevice.c\n\nQuorum\nM: Alberto Garcia <berto@igalia.com>\nS: Supported\nF: block/quorum.c\nL: qemu-block@nongnu.org\n\nblkverify\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/blkverify.c\n\nbochs\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/bochs.c\n\ncloop\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/cloop.c\n\ndmg\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/dmg.c\n\nparallels\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Denis V. Lunev <den@openvz.org>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/parallels.c\nF: docs/specs/parallels.txt\n\nqed\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qed.c\n\nraw\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/linux-aio.c\nF: include/block/raw-aio.h\nF: block/raw-format.c\nF: block/file-posix.c\nF: block/file-win32.c\nF: block/win32-aio.c\n\nqcow2\nM: Kevin Wolf <kwolf@redhat.com>\nM: Max Reitz <mreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qcow2*\n\nqcow\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qcow.c\n\nblkdebug\nM: Kevin Wolf <kwolf@redhat.com>\nM: Max Reitz <mreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/blkdebug.c\n\nvpc\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vpc.c\n\nvvfat\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vvfat.c\n\nImage format fuzzer\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: tests/image-fuzzer/\n\nReplication\nM: Wen Congyang <wency@cn.fujitsu.com>\nM: Changlong Xie <xiecl.fnst@cn.fujitsu.com>\nS: Supported\nF: replication*\nF: block/replication.c\nF: tests/test-replication.c\nF: docs/block-replication.txt\n\nBuild and test automation\n-------------------------\nM: Alex Bennée <alex.bennee@linaro.org>\nM: Fam Zheng <famz@redhat.com>\nL: qemu-devel@nongnu.org\nS: Maintained\nF: .travis.yml\nF: .shippable.yml\nF: tests/docker/\nW: https://travis-ci.org/qemu/qemu\nW: http://patchew.org/QEMU/\n\nDocumentation\n-------------\nBuild system architecture\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: docs/build-system.txt\n\nBuild System\n------------\nGIT submodules\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: scripts/git-submodule.sh\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 31.3349609375,
          "content": "# Makefile for QEMU.\n\n# Always point to the root of the build tree (needs GNU make).\nBUILD_DIR=$(CURDIR)\n\n# Before including a proper config-host.mak, assume we are in the source tree\nSRC_PATH=.\n\nUNCHECKED_GOALS := %clean TAGS cscope ctags docker docker-%\n\n# All following code might depend on configuration variables\nifneq ($(wildcard config-host.mak),)\n# Put the all: rule here so that config-host.mak can contain dependencies.\nall:\ninclude config-host.mak\n\n# Metadata for build\nGIT_VERSION := '$(shell git describe --dirty --always)'\nBUILD_DATE  := '$(shell date)'\nQEMU_CFLAGS  +=-DGIT_VERSION=\\\"$(GIT_VERSION)\\\" -DBUILD_DATE=\\\"$(BUILD_DATE)\\\"\nQEMU_CXXFLAGS+=-DGIT_VERSION=\\\"$(GIT_VERSION)\\\" -DBUILD_DATE=\\\"$(BUILD_DATE)\\\"\nQEMU_CFLAGS += $(call cc-disable-warning, psabi)\n\ngit-submodule-update:\n\n.PHONY: git-submodule-update\n\nifeq (0,$(MAKELEVEL))\n  git_module_status := $(shell \\\n    cd '$(SRC_PATH)' && \\\n    ./scripts/git-submodule.sh status $(GIT_SUBMODULES); \\\n    echo $$?; \\\n  )\n\nifeq (1,$(git_module_status))\ngit-submodule-update:\n\t$(call quiet-command, \\\n          (cd $(SRC_PATH) && ./scripts/git-submodule.sh update $(GIT_SUBMODULES)), \\\n          \"GIT\",\"$(GIT_SUBMODULES)\")\nendif\nendif\n\n.git-submodule-status: git-submodule-update\n\n# Check that we're not trying to do an out-of-tree build from\n# a tree that's been used for an in-tree build.\nifneq ($(realpath $(SRC_PATH)),$(realpath .))\nifneq ($(wildcard $(SRC_PATH)/config-host.mak),)\n$(error This is an out of tree build but your source tree ($(SRC_PATH)) \\\nseems to have been used for an in-tree build. You can fix this by running \\\n\"make distclean && rm -rf *-linux-user *-softmmu\" in your source tree)\nendif\nendif\n\nCONFIG_SOFTMMU := $(if $(filter %-softmmu,$(TARGET_DIRS)),y)\nCONFIG_USER_ONLY := $(if $(filter %-user,$(TARGET_DIRS)),y)\nCONFIG_XEN := $(CONFIG_XEN_BACKEND)\nCONFIG_ALL=y\n-include config-all-devices.mak\n-include config-all-disas.mak\n\nconfig-host.mak: $(SRC_PATH)/configure $(SRC_PATH)/pc-bios\n\t@echo $@ is out-of-date, running configure\n\t@# TODO: The next lines include code which supports a smooth\n\t@# transition from old configurations without config.status.\n\t@# This code can be removed after QEMU 1.7.\n\t@if test -x config.status; then \\\n\t    ./config.status; \\\n        else \\\n\t    sed -n \"/.*Configured with/s/[^:]*: //p\" $@ | sh; \\\n\tfi\nelse\nconfig-host.mak:\nifneq ($(filter-out $(UNCHECKED_GOALS),$(MAKECMDGOALS)),$(if $(MAKECMDGOALS),,fail))\n\t@echo \"Please call configure before running make!\"\n\t@exit 1\nendif\nendif\n\ninclude $(SRC_PATH)/rules.mak\n\nGENERATED_FILES = qemu-version.h config-host.h qemu-options.def\nGENERATED_FILES += qmp-commands.h qapi-types.h qapi-visit.h qapi-event.h\nGENERATED_FILES += qmp-marshal.c qapi-types.c qapi-visit.c qapi-event.c\nGENERATED_FILES += qmp-introspect.h\nGENERATED_FILES += qmp-introspect.c\n\nGENERATED_FILES += trace/generated-tcg-tracers.h\n\nGENERATED_FILES += trace/generated-helpers-wrappers.h\nGENERATED_FILES += trace/generated-helpers.h\nGENERATED_FILES += trace/generated-helpers.c\n\nifdef CONFIG_TRACE_UST\nGENERATED_FILES += trace-ust-all.h\nGENERATED_FILES += trace-ust-all.c\nendif\n\nGENERATED_FILES += module_block.h\n\nTRACE_HEADERS = trace-root.h $(trace-events-subdirs:%=%/trace.h)\nTRACE_SOURCES = trace-root.c $(trace-events-subdirs:%=%/trace.c)\nTRACE_DTRACE =\nifdef CONFIG_TRACE_DTRACE\nTRACE_HEADERS += trace-dtrace-root.h $(trace-events-subdirs:%=%/trace-dtrace.h)\nTRACE_DTRACE += trace-dtrace-root.dtrace $(trace-events-subdirs:%=%/trace-dtrace.dtrace)\nendif\nifdef CONFIG_TRACE_UST\nTRACE_HEADERS += trace-ust-root.h $(trace-events-subdirs:%=%/trace-ust.h)\nendif\n\nGENERATED_FILES += $(TRACE_HEADERS)\nGENERATED_FILES += $(TRACE_SOURCES)\nGENERATED_FILES += $(BUILD_DIR)/trace-events-all\nGENERATED_FILES += .git-submodule-status\n\ntrace-group-name = $(shell dirname $1 | sed -e 's/[^a-zA-Z0-9]/_/g')\n\ntracetool-y = $(SRC_PATH)/scripts/tracetool.py\ntracetool-y += $(shell find $(SRC_PATH)/scripts/tracetool -name \"*.py\")\n\n%/trace.h: %/trace.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\n%/trace.h-timestamp: $(SRC_PATH)/%/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=$(call trace-group-name,$@) \\\n\t\t--format=h \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\n%/trace.c: %/trace.c-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\n%/trace.c-timestamp: $(SRC_PATH)/%/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=$(call trace-group-name,$@) \\\n\t\t--format=c \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\n%/trace-ust.h: %/trace-ust.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\n%/trace-ust.h-timestamp: $(SRC_PATH)/%/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=$(call trace-group-name,$@) \\\n\t\t--format=ust-events-h \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\n%/trace-dtrace.dtrace: %/trace-dtrace.dtrace-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\n%/trace-dtrace.dtrace-timestamp: $(SRC_PATH)/%/trace-events $(BUILD_DIR)/config-host.mak $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=$(call trace-group-name,$@) \\\n\t\t--format=d \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\n%/trace-dtrace.h: %/trace-dtrace.dtrace $(tracetool-y)\n\t$(call quiet-command,dtrace -o $@ -h -s $<, \"GEN\",\"$@\")\n\n%/trace-dtrace.o: %/trace-dtrace.dtrace $(tracetool-y)\n\n\ntrace-root.h: trace-root.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-root.h-timestamp: $(SRC_PATH)/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=root \\\n\t\t--format=h \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-root.c: trace-root.c-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-root.c-timestamp: $(SRC_PATH)/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=root \\\n\t\t--format=c \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-ust-root.h: trace-ust-root.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-ust-root.h-timestamp: $(SRC_PATH)/trace-events $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=root \\\n\t\t--format=ust-events-h \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-ust-all.h: trace-ust-all.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-ust-all.h-timestamp: $(trace-events-files) $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=all \\\n\t\t--format=ust-events-h \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$(trace-events-files) > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-ust-all.c: trace-ust-all.c-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-ust-all.c-timestamp: $(trace-events-files) $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=all \\\n\t\t--format=ust-events-c \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$(trace-events-files) > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-dtrace-root.dtrace: trace-dtrace-root.dtrace-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\ntrace-dtrace-root.dtrace-timestamp: $(SRC_PATH)/trace-events $(BUILD_DIR)/config-host.mak $(tracetool-y)\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=root \\\n\t\t--format=d \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t$< > $@,\"GEN\",\"$(@:%-timestamp=%)\")\n\ntrace-dtrace-root.h: trace-dtrace-root.dtrace\n\t$(call quiet-command,dtrace -o $@ -h -s $<, \"GEN\",\"$@\")\n\ntrace-dtrace-root.o: trace-dtrace-root.dtrace\n\n# Don't try to regenerate Makefile or configure\n# We don't generate any of them\nMakefile: ;\nconfigure: ;\n\n.PHONY: all clean cscope distclean html info install install-doc \\\n\tpdf txt recurse-all speed test dist msi FORCE\n\n$(call set-vpath, $(SRC_PATH))\n\nLIBS+=-lz $(LIBS_TOOLS)\n\nHELPERS-$(CONFIG_LINUX) = panda-bridge-helper$(EXESUF)\n\nifdef BUILD_DOCS\nDOCS=qemu-doc.html qemu-doc.txt qemu.1 qemu-img.1 qemu-nbd.8 qemu-ga.8\nDOCS+=docs/qemu-qmp-ref.html docs/qemu-qmp-ref.txt docs/qemu-qmp-ref.7\nDOCS+=docs/qemu-ga-ref.html docs/qemu-ga-ref.txt docs/qemu-ga-ref.7\nifdef CONFIG_VIRTFS\nDOCS+=fsdev/virtfs-proxy-helper.1\nendif\nelse\nDOCS=\nendif\n\nSUBDIR_MAKEFLAGS=$(if $(V),,--no-print-directory) BUILD_DIR=$(BUILD_DIR)\nSUBDIR_DEVICES_MAK=$(patsubst %, %/config-devices.mak, $(TARGET_DIRS))\nSUBDIR_DEVICES_MAK_DEP=$(patsubst %, %-config-devices.mak.d, $(TARGET_DIRS))\n\nifeq ($(SUBDIR_DEVICES_MAK),)\nconfig-all-devices.mak:\n\t$(call quiet-command,echo '# no devices' > $@,\"GEN\",\"$@\")\nelse\nconfig-all-devices.mak: $(SUBDIR_DEVICES_MAK)\n\t$(call quiet-command, sed -n \\\n             's|^\\([^=]*\\)=\\(.*\\)$$|\\1:=$$(findstring y,$$(\\1)\\2)|p' \\\n             $(SUBDIR_DEVICES_MAK) | sort -u > $@, \\\n             \"GEN\",\"$@\")\nendif\n\n-include $(SUBDIR_DEVICES_MAK_DEP)\n\n%/config-devices.mak: default-configs/%.mak $(SRC_PATH)/scripts/make_device_config.sh\n\t$(call quiet-command, \\\n            $(SHELL) $(SRC_PATH)/scripts/make_device_config.sh $< $*-config-devices.mak.d $@ > $@.tmp,\"GEN\",\"$@.tmp\")\n\t$(call quiet-command, if test -f $@; then \\\n\t  if cmp -s $@.old $@; then \\\n\t    mv $@.tmp $@; \\\n\t    cp -p $@ $@.old; \\\n\t  else \\\n\t    if test -f $@.old; then \\\n\t      echo \"WARNING: $@ (user modified) out of date.\";\\\n\t    else \\\n\t      echo \"WARNING: $@ out of date.\";\\\n\t    fi; \\\n\t    echo \"Run \\\"make defconfig\\\" to regenerate.\"; \\\n\t    rm $@.tmp; \\\n\t  fi; \\\n\t else \\\n\t  mv $@.tmp $@; \\\n\t  cp -p $@ $@.old; \\\n\t fi,\"GEN\",\"$@\");\n\ndefconfig:\n\trm -f config-all-devices.mak $(SUBDIR_DEVICES_MAK)\n\nifneq ($(wildcard config-host.mak),)\ninclude $(SRC_PATH)/Makefile.objs\nendif\n\ndummy := $(call unnest-vars,, \\\n                stub-obj-y \\\n                chardev-obj-y \\\n                util-obj-y \\\n                qga-obj-y \\\n                ivshmem-client-obj-y \\\n                ivshmem-server-obj-y \\\n                libvhost-user-obj-y \\\n                qga-vss-dll-obj-y \\\n                block-obj-y \\\n                block-obj-m \\\n                crypto-obj-y \\\n                crypto-aes-obj-y \\\n                qom-obj-y \\\n                io-obj-y \\\n                common-obj-y \\\n                common-obj-m \\\n                trace-obj-y)\n\nifneq ($(wildcard config-host.mak),)\ninclude $(SRC_PATH)/panda/Makefile.panda\n\ninclude $(SRC_PATH)/tests/Makefile.include\nendif\n\nall: $(DOCS) $(TOOLS) $(HELPERS-y) recurse-all modules\n\nqemu-version.h: FORCE\n\t$(call quiet-command, \\\n\t\t(cd $(SRC_PATH); \\\n\t\tprintf '#define QEMU_PKGVERSION '; \\\n\t\tif test -n \"$(PKGVERSION)\"; then \\\n\t\t\tprintf '\"$(PKGVERSION)\"\\n'; \\\n\t\telse \\\n\t\t\tif test -d .git; then \\\n\t\t\t\tprintf '\" ('; \\\n\t\t\t\tgit describe --match 'v*' 2>/dev/null | tr -d '\\n'; \\\n\t\t\t\tif ! git diff-index --quiet HEAD 2>/dev/null; then \\\n\t\t\t\t\tprintf -- '-dirty'; \\\n\t\t\t\tfi; \\\n\t\t\t\tprintf ')\"\\n'; \\\n\t\t\telse \\\n\t\t\t\tprintf '\"\"\\n'; \\\n\t\t\tfi; \\\n\t\tfi) > $@.tmp)\n\t$(call quiet-command, if ! cmp -s $@ $@.tmp; then \\\n\t  mv $@.tmp $@; \\\n\t else \\\n\t  rm $@.tmp; \\\n\t fi)\n\nconfig-host.h: config-host.h-timestamp\nconfig-host.h-timestamp: config-host.mak\nqemu-options.def: $(SRC_PATH)/qemu-options.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,\"GEN\",\"$@\")\n\nSUBDIR_RULES=$(patsubst %,subdir-%, $(TARGET_DIRS))\nSOFTMMU_SUBDIR_RULES=$(filter %-softmmu,$(SUBDIR_RULES))\n\n$(SOFTMMU_SUBDIR_RULES): $(block-obj-y)\n$(SOFTMMU_SUBDIR_RULES): $(crypto-obj-y)\n$(SOFTMMU_SUBDIR_RULES): $(io-obj-y)\n$(SOFTMMU_SUBDIR_RULES): config-all-devices.mak\n\nsubdir-%:\n\t$(call quiet-command,$(MAKE) $(SUBDIR_MAKEFLAGS) -C $* V=\"$(V)\" TARGET_DIR=\"$*/\" all,)\n\nsubdir-pixman: pixman/Makefile\n\t$(call quiet-command,$(MAKE) $(SUBDIR_MAKEFLAGS) -C pixman V=\"$(V)\" all,)\n\npixman/Makefile: $(SRC_PATH)/pixman/configure\n\t(cd pixman; CFLAGS=\"$(CFLAGS) -fPIC $(extra_cflags) $(extra_ldflags)\" $(SRC_PATH)/pixman/configure $(AUTOCONF_HOST) --disable-gtk --disable-shared --enable-static)\n\n$(SRC_PATH)/pixman/configure:\n\t(cd $(SRC_PATH)/pixman; autoreconf -v --install)\n\nDTC_MAKE_ARGS=-I$(SRC_PATH)/dtc VPATH=$(SRC_PATH)/dtc -C dtc V=\"$(V)\" LIBFDT_srcdir=$(SRC_PATH)/dtc/libfdt\nDTC_CFLAGS=$(CFLAGS) $(QEMU_CFLAGS)\nDTC_CPPFLAGS=-I$(BUILD_DIR)/dtc -I$(SRC_PATH)/dtc -I$(SRC_PATH)/dtc/libfdt\n\nsubdir-dtc: .git-submodule-status dtc/libfdt dtc/tests\n\t$(call quiet-command,$(MAKE) $(DTC_MAKE_ARGS) CPPFLAGS=\"$(DTC_CPPFLAGS)\" CFLAGS=\"$(DTC_CFLAGS)\" LDFLAGS=\"$(LDFLAGS)\" ARFLAGS=\"$(ARFLAGS)\" CC=\"$(CC)\" AR=\"$(AR)\" LD=\"$(LD)\" $(SUBDIR_MAKEFLAGS) libfdt/libfdt.a,)\n\ndtc/%:\n\tmkdir -p $@\n\n$(SUBDIR_RULES): libqemuutil.a libqemustub.a $(common-obj-y) $(chardev-obj-y) \\\n\t$(qom-obj-y) $(crypto-aes-obj-$(CONFIG_USER_ONLY)) $(trace-obj-y)\n\nROMSUBDIR_RULES=$(patsubst %,romsubdir-%, $(ROMS))\n# Only keep -O and -g cflags\nromsubdir-%:\n\t$(call quiet-command,$(MAKE) $(SUBDIR_MAKEFLAGS) -C pc-bios/$* V=\"$(V)\" TARGET_DIR=\"$*/\" CFLAGS=\"$(filter -O% -g%,$(CFLAGS))\",)\n\nALL_SUBDIRS=$(TARGET_DIRS) $(patsubst %,pc-bios/%, $(ROMS))\n\nrecurse-all: $(SUBDIR_RULES) $(ROMSUBDIR_RULES)\n\n$(BUILD_DIR)/version.o: $(SRC_PATH)/version.rc config-host.h\n\t$(call quiet-command,$(WINDRES) -I$(BUILD_DIR) -o $@ $<,\"RC\",\"version.o\")\n\nMakefile: $(version-obj-y)\n\n######################################################################\n# Build libraries\n\nlibqemustub.a: $(stub-obj-y)\nlibqemuutil.a: $(util-obj-y)\n\n######################################################################\n\nCOMMON_LDADDS = $(trace-obj-y) libqemuutil.a libqemustub.a\n\nqemu-img.o: qemu-img-cmds.h\n\nqemu-img$(EXESUF): qemu-img.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)\nqemu-nbd$(EXESUF): qemu-nbd.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)\nqemu-io$(EXESUF): qemu-io.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)\n\npanda-bridge-helper$(EXESUF): panda-bridge-helper.o $(COMMON_LDADDS)\n\nfsdev/virtfs-proxy-helper$(EXESUF): fsdev/virtfs-proxy-helper.o fsdev/9p-marshal.o fsdev/9p-iov-marshal.o $(COMMON_LDADDS)\nfsdev/virtfs-proxy-helper$(EXESUF): LIBS += -lcap\n\nqemu-img-cmds.h: $(SRC_PATH)/qemu-img-cmds.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,\"GEN\",\"$@\")\n\nqemu-ga$(EXESUF): LIBS = $(LIBS_QGA)\nqemu-ga$(EXESUF): QEMU_CFLAGS += -I qga/qapi-generated\n\ngen-out-type = $(subst .,-,$(suffix $@))\n\nqapi-py = $(SRC_PATH)/scripts/qapi.py\n\nqga/qapi-generated/qga-qapi-types.c qga/qapi-generated/qga-qapi-types.h :\\\n$(SRC_PATH)/qga/qapi-schema.json $(SRC_PATH)/scripts/qapi-types.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-types.py \\\n\t\t$(gen-out-type) -o qga/qapi-generated -p \"qga-\" $<, \\\n\t\t\"GEN\",\"$@\")\nqga/qapi-generated/qga-qapi-visit.c qga/qapi-generated/qga-qapi-visit.h :\\\n$(SRC_PATH)/qga/qapi-schema.json $(SRC_PATH)/scripts/qapi-visit.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-visit.py \\\n\t\t$(gen-out-type) -o qga/qapi-generated -p \"qga-\" $<, \\\n\t\t\"GEN\",\"$@\")\nqga/qapi-generated/qga-qmp-commands.h qga/qapi-generated/qga-qmp-marshal.c :\\\n$(SRC_PATH)/qga/qapi-schema.json $(SRC_PATH)/scripts/qapi-commands.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-commands.py \\\n\t\t$(gen-out-type) -o qga/qapi-generated -p \"qga-\" $<, \\\n\t\t\"GEN\",\"$@\")\n\nqapi-modules = $(SRC_PATH)/qapi-schema.json $(SRC_PATH)/qapi/common.json \\\n               $(SRC_PATH)/qapi/block.json $(SRC_PATH)/qapi/block-core.json \\\n               $(SRC_PATH)/qapi/event.json $(SRC_PATH)/qapi/introspect.json \\\n               $(SRC_PATH)/qapi/crypto.json $(SRC_PATH)/qapi/rocker.json \\\n               $(SRC_PATH)/qapi/trace.json\n\nqapi-types.c qapi-types.h :\\\n$(qapi-modules) $(SRC_PATH)/scripts/qapi-types.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-types.py \\\n\t\t$(gen-out-type) -o \".\" -b $<, \\\n\t\t\"GEN\",\"$@\")\nqapi-visit.c qapi-visit.h :\\\n$(qapi-modules) $(SRC_PATH)/scripts/qapi-visit.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-visit.py \\\n\t\t$(gen-out-type) -o \".\" -b $<, \\\n\t\t\"GEN\",\"$@\")\nqapi-event.c qapi-event.h :\\\n$(qapi-modules) $(SRC_PATH)/scripts/qapi-event.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-event.py \\\n\t\t$(gen-out-type) -o \".\" $<, \\\n\t\t\"GEN\",\"$@\")\nqmp-commands.h qmp-marshal.c :\\\n$(qapi-modules) $(SRC_PATH)/scripts/qapi-commands.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-commands.py \\\n\t\t$(gen-out-type) -o \".\" $<, \\\n\t\t\"GEN\",\"$@\")\nqmp-introspect.h qmp-introspect.c :\\\n$(qapi-modules) $(SRC_PATH)/scripts/qapi-introspect.py $(qapi-py)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi-introspect.py \\\n\t\t$(gen-out-type) -o \".\" $<, \\\n\t\t\"GEN\",\"$@\")\n\nQGALIB_GEN=$(addprefix qga/qapi-generated/, qga-qapi-types.h qga-qapi-visit.h qga-qmp-commands.h)\n$(qga-obj-y) qemu-ga.o: $(QGALIB_GEN)\n\nqemu-ga$(EXESUF): $(qga-obj-y) $(COMMON_LDADDS)\n\t$(call LINK, $^)\n\nifdef QEMU_GA_MSI_ENABLED\nQEMU_GA_MSI=qemu-ga-$(ARCH).msi\n\nmsi: $(QEMU_GA_MSI)\n\n$(QEMU_GA_MSI): qemu-ga.exe $(QGA_VSS_PROVIDER)\n\n$(QEMU_GA_MSI): config-host.mak\n\n$(QEMU_GA_MSI):  $(SRC_PATH)/qga/installer/qemu-ga.wxs\n\t$(call quiet-command,QEMU_GA_VERSION=\"$(QEMU_GA_VERSION)\" QEMU_GA_MANUFACTURER=\"$(QEMU_GA_MANUFACTURER)\" QEMU_GA_DISTRO=\"$(QEMU_GA_DISTRO)\" BUILD_DIR=\"$(BUILD_DIR)\" \\\n\twixl -o $@ $(QEMU_GA_MSI_ARCH) $(QEMU_GA_MSI_WITH_VSS) $(QEMU_GA_MSI_MINGW_DLL_PATH) $<,\"WIXL\",\"$@\")\nelse\nmsi:\n\t@echo \"MSI build not configured or dependency resolution failed (reconfigure with --enable-guest-agent-msi option)\"\nendif\n\nifneq ($(EXESUF),)\n.PHONY: qemu-ga\nqemu-ga: qemu-ga$(EXESUF) $(QGA_VSS_PROVIDER) $(QEMU_GA_MSI)\nendif\n\nivshmem-client$(EXESUF): $(ivshmem-client-obj-y) $(COMMON_LDADDS)\n\t$(call LINK, $^)\nivshmem-server$(EXESUF): $(ivshmem-server-obj-y) $(COMMON_LDADDS)\n\t$(call LINK, $^)\n\nmodule_block.h: $(SRC_PATH)/scripts/modules/module_block.py config-host.mak\n\t$(call quiet-command,$(PYTHON) $< $@ \\\n\t$(addprefix $(SRC_PATH)/,$(patsubst %.mo,%.c,$(block-obj-m))), \\\n\t\"GEN\",\"$@\")\n\nclean:\n# avoid old build problems by removing potentially incorrect old files\n\trm -f config.mak op-i386.h opc-i386.h gen-op-i386.h op-arm.h opc-arm.h gen-op-arm.h\n\trm -f qemu-options.def\n\trm -f *.msi\n\tfind . \\( -name '*.so' -o -name '*.dll' -o -name '*.mo' -o -name '*.[oda]' \\) -type f -exec rm {} +\n\trm -f $(filter-out %.tlb,$(TOOLS)) $(HELPERS-y) qemu-ga TAGS cscope.* *.pod *~ */*~\n\trm -f fsdev/*.pod\n\trm -f qemu-img-cmds.h\n\trm -f ui/shader/*-vert.h ui/shader/*-frag.h\n\t@# May not be present in GENERATED_FILES\n\trm -f trace/generated-tracers-dtrace.dtrace*\n\trm -f trace/generated-tracers-dtrace.h*\n\trm -f $(foreach f,$(GENERATED_FILES),$(f) $(f)-timestamp)\n\trm -rf qapi-generated\n\trm -rf qga/qapi-generated\n\tfor d in $(ALL_SUBDIRS); do \\\n\tif test -d $$d; then $(MAKE) -C $$d $@ || exit 1; fi; \\\n\trm -f $$d/qemu-options.def; \\\n        done\n\trm -f $(SUBDIR_DEVICES_MAK) config-all-devices.mak\n\nVERSION ?= $(shell cat VERSION)\n\ndist: qemu-$(VERSION).tar.bz2\n\nqemu-%.tar.bz2:\n\t$(SRC_PATH)/scripts/make-release \"$(SRC_PATH)\" \"$(patsubst qemu-%.tar.bz2,%,$@)\"\n\ndistclean: clean\n\trm -f config-host.mak config-host.h* config-host.ld $(DOCS) qemu-options.texi qemu-img-cmds.texi qemu-monitor.texi qemu-monitor-info.texi\n\trm -f config-all-devices.mak config-all-disas.mak config.status\n\trm -f po/*.mo tests/qemu-iotests/common.env\n\trm -f roms/seabios/config.mak roms/vgabios/config.mak\n\trm -f qemu-doc.info qemu-doc.aux qemu-doc.cp qemu-doc.cps\n\trm -f qemu-doc.fn qemu-doc.fns qemu-doc.info qemu-doc.ky qemu-doc.kys\n\trm -f qemu-doc.log qemu-doc.pdf qemu-doc.pg qemu-doc.toc qemu-doc.tp\n\trm -f qemu-doc.vr qemu-doc.txt\n\trm -f config.log\n\trm -f linux-headers/asm\n\trm -f docs/qemu-ga-qapi.texi docs/qemu-qmp-qapi.texi docs/version.texi\n\trm -f docs/qemu-qmp-ref.7 docs/qemu-ga-ref.7\n\trm -f docs/qemu-qmp-ref.txt docs/qemu-ga-ref.txt\n\trm -f docs/qemu-qmp-ref.pdf docs/qemu-ga-ref.pdf\n\trm -f docs/qemu-qmp-ref.html docs/qemu-ga-ref.html\n\tfor d in $(TARGET_DIRS); do \\\n\trm -rf $$d || exit 1 ; \\\n        done\n\trm -Rf .sdk\n\tif test -f pixman/config.log; then $(MAKE) -C pixman distclean; fi\n\tif test -f dtc/version_gen.h; then $(MAKE) $(DTC_MAKE_ARGS) clean; fi\n\nKEYMAPS=da     en-gb  et  fr     fr-ch  is  lt  modifiers  no  pt-br  sv \\\nar      de     en-us  fi  fr-be  hr     it  lv  nl         pl  ru     th \\\ncommon  de-ch  es     fo  fr-ca  hu     ja  mk  nl-be      pt  sl     tr \\\nbepo    cz\n\nifdef INSTALL_BLOBS\nBLOBS=bios.bin bios-256k.bin sgabios.bin vgabios.bin vgabios-cirrus.bin \\\nvgabios-stdvga.bin vgabios-vmware.bin vgabios-qxl.bin vgabios-virtio.bin \\\nacpi-dsdt.aml \\\nppc_rom.bin openbios-sparc32 openbios-sparc64 openbios-ppc QEMU,tcx.bin QEMU,cgthree.bin \\\npxe-e1000.rom pxe-eepro100.rom pxe-ne2k_pci.rom \\\npxe-pcnet.rom pxe-rtl8139.rom pxe-virtio.rom \\\nefi-e1000.rom efi-eepro100.rom efi-ne2k_pci.rom \\\nefi-pcnet.rom efi-rtl8139.rom efi-virtio.rom \\\nefi-e1000e.rom efi-vmxnet3.rom \\\nqemu-icon.bmp qemu_logo_no_text.svg \\\nbamboo.dtb petalogix-s3adsp1800.dtb petalogix-ml605.dtb \\\nmultiboot.bin linuxboot.bin linuxboot_dma.bin kvmvapic.bin \\\ns390-ccw.img \\\nspapr-rtas.bin slof.bin skiboot.lid \\\npalcode-clipper \\\nu-boot.e500\nelse\nBLOBS=\nendif\n\ninstall-doc: $(DOCS)\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) qemu-doc.html \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) qemu-doc.txt \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) docs/qemu-qmp-ref.html \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) docs/qemu-qmp-ref.txt \"$(DESTDIR)$(qemu_docdir)\"\nifdef CONFIG_POSIX\n\t$(INSTALL_DIR) \"$(DESTDIR)$(mandir)/man1\"\n\t$(INSTALL_DATA) qemu.1 \"$(DESTDIR)$(mandir)/man1\"\n\t$(INSTALL_DIR) \"$(DESTDIR)$(mandir)/man7\"\n\t$(INSTALL_DATA) docs/qemu-qmp-ref.7 \"$(DESTDIR)$(mandir)/man7\"\nifneq ($(TOOLS),)\n\t$(INSTALL_DATA) qemu-img.1 \"$(DESTDIR)$(mandir)/man1\"\n\t$(INSTALL_DIR) \"$(DESTDIR)$(mandir)/man8\"\n\t$(INSTALL_DATA) qemu-nbd.8 \"$(DESTDIR)$(mandir)/man8\"\nendif\nifneq (,$(findstring qemu-ga,$(TOOLS)))\n\t$(INSTALL_DATA) qemu-ga.8 \"$(DESTDIR)$(mandir)/man8\"\n\t$(INSTALL_DATA) docs/qemu-ga-ref.html \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) docs/qemu-ga-ref.txt \"$(DESTDIR)$(qemu_docdir)\"\n\t$(INSTALL_DATA) docs/qemu-ga-ref.7 \"$(DESTDIR)$(mandir)/man7\"\nendif\nendif\nifdef CONFIG_VIRTFS\n\t$(INSTALL_DIR) \"$(DESTDIR)$(mandir)/man1\"\n\t$(INSTALL_DATA) fsdev/virtfs-proxy-helper.1 \"$(DESTDIR)$(mandir)/man1\"\nendif\n\ninstall-datadir:\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_datadir)\"\n\ninstall-localstatedir:\nifdef CONFIG_POSIX\nifneq (,$(findstring qemu-ga,$(TOOLS)))\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_localstatedir)\"/run\nendif\nendif\n\nifneq ($(CONFIG_LINUX),)\n\n# This hack is needed with `make` >=4.3\n# More details can be found in the changelog: https://lwn.net/Articles/810071/\nnumber_sign := \\#\n\n# The install target won't succeed if the RPATH in the .so files is longer than\n# the value need to change it to for installation purposes.  It does not matter\n# which architecture is used for the comparison - it shows up once in both the\n# new and old RPATHs, so the differences cancel out.\n# Calculate length of new RPATH.\nnewrplen=$(shell newrp=\"$(panda_plugindir)/$(ARCH)\" ; eval echo $${$(number_sign)newrp})\n# Fetch current RPATH from an .so file - doesn't matter which plugin/arch it is for.\narchdir=$(lastword $(TARGET_DIRS))\nifeq ($(archdir),)\n$(error Failed to find arch directory ${archdir})\nendif\npwdvar=$(shell pwd)\npathtoso=$(shell echo \"$(pwdvar)/$(archdir)/panda/plugins/panda_stringsearch.so\")\ncpout=$(shell chrpath -l \"$(pathtoso)\")\n# The old RPATH will include a \"RPATH=\" prefix - the size calculation will\n# adjust for that later.\nrppart=$(lastword $(cpout))\nnewtoobig=$(shell oldrp=\"$(rppart)\" ; oldrplen=`expr $${$(number_sign)oldrp} - 6` ; if [ $$oldrplen -lt $(newrplen) ] ; then echo true ; else echo false ; fi)\nendif\n\ninstall: all $(if $(BUILD_DOCS),install-doc) install-datadir install-localstatedir\nifeq ($(newtoobig), false)\nifneq ($(TOOLS),)\n\t$(call install-prog,$(subst qemu-ga,qemu-ga$(EXESUF),$(TOOLS)),$(DESTDIR)$(bindir))\nendif\nifneq ($(CONFIG_MODULES),)\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_moddir)\"\n\tfor s in $(modules-m:.mo=$(DSOSUF)); do \\\n\t\tt=\"$(DESTDIR)$(qemu_moddir)/$$(echo $$s | tr / -)\"; \\\n\t\t$(INSTALL_LIB) $$s \"$$t\"; \\\n\t\ttest -z \"$(STRIP)\" || $(STRIP) \"$$t\"; \\\n\tdone\nendif\nifneq ($(HELPERS-y),)\n\t$(call install-prog,$(HELPERS-y),$(DESTDIR)$(libexecdir))\nendif\nifneq ($(BLOBS),)\n\tset -e; for x in $(BLOBS); do \\\n\t\t$(INSTALL_DATA) $(SRC_PATH)/pc-bios/$$x \"$(DESTDIR)$(qemu_datadir)\"; \\\n\tdone\nendif\nifeq ($(CONFIG_GTK),y)\n\t$(MAKE) -C po $@\nendif\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_datadir)/keymaps\"\n\tset -e; for x in $(KEYMAPS); do \\\n\t\t$(INSTALL_DATA) $(SRC_PATH)/pc-bios/keymaps/$$x \"$(DESTDIR)$(qemu_datadir)/keymaps\"; \\\n\tdone\n\t$(INSTALL_DATA) $(BUILD_DIR)/trace-events-all \"$(DESTDIR)$(qemu_datadir)/trace-events-all\"\n\tfor d in $(TARGET_DIRS); do \\\n\t$(MAKE) $(SUBDIR_MAKEFLAGS) TARGET_DIR=$$d/ -C $$d $@ || exit 1 ; \\\n        done\nelse\n\t$(error new RPATH too long - cannot adjust .so files for installation)\nendif\n\n# various test targets\ntest speed: all\n\t$(MAKE) -C tests/tcg $@\n\n.PHONY: ctags\nctags:\n\trm -f tags\n\tfind \"$(SRC_PATH)\" -name '*.[hc]' -exec ctags --append {} +\n\n.PHONY: TAGS\nTAGS:\n\trm -f TAGS\n\tfind \"$(SRC_PATH)\" -name '*.[hc]' -exec etags --append {} +\n\ncscope:\n\trm -f \"$(SRC_PATH)\"/cscope.*\n\tfind \"$(SRC_PATH)/\" \\( -name \"*.[chsS]\" -o -name '*.cpp' \\) -print | sed 's,^\\./,,' > \"$(SRC_PATH)/cscope.files\"\n\tcscope -b -i\"$(SRC_PATH)/cscope.files\"\n\n# opengl shader programs\nui/shader/%-vert.h: $(SRC_PATH)/ui/shader/%.vert $(SRC_PATH)/scripts/shaderinclude.pl\n\t@mkdir -p $(dir $@)\n\t$(call quiet-command,\\\n\t\tperl $(SRC_PATH)/scripts/shaderinclude.pl $< > $@,\\\n\t\t\"VERT\",\"$@\")\n\nui/shader/%-frag.h: $(SRC_PATH)/ui/shader/%.frag $(SRC_PATH)/scripts/shaderinclude.pl\n\t@mkdir -p $(dir $@)\n\t$(call quiet-command,\\\n\t\tperl $(SRC_PATH)/scripts/shaderinclude.pl $< > $@,\\\n\t\t\"FRAG\",\"$@\")\n\nui/console-gl.o: $(SRC_PATH)/ui/console-gl.c \\\n\tui/shader/texture-blit-vert.h ui/shader/texture-blit-frag.h\n\n# documentation\nMAKEINFO=makeinfo\nMAKEINFOFLAGS=--no-split --number-sections -I docs\nTEXIFLAG=$(if $(V),,--quiet)\n\ndocs/version.texi: $(SRC_PATH)/VERSION\n\t$(call quiet-command,echo \"@set VERSION $(VERSION)\" > $@,\"GEN\",\"$@\")\n\n%.html: %.texi\n\t$(call quiet-command,LC_ALL=C $(MAKEINFO) $(MAKEINFOFLAGS) --no-headers \\\n\t--html $< -o $@,\"GEN\",\"$@\")\n\n%.info: %.texi\n\t$(call quiet-command,$(MAKEINFO) $(MAKEINFOFLAGS) $< -o $@,\"GEN\",\"$@\")\n\n%.txt: %.texi\n\t$(call quiet-command,LC_ALL=C $(MAKEINFO) $(MAKEINFOFLAGS) --no-headers \\\n\t--plaintext $< -o $@,\"GEN\",\"$@\")\n\n%.pdf: %.texi\n\t$(call quiet-command,texi2pdf $(TEXIFLAG) -I $(SRC_PATH) -I docs $< -o $@,\"GEN\",\"$@\")\n\ndocs/qemu-ga-ref.html docs/qemu-ga-ref.info docs/qemu-ga-ref.txt docs/qemu-ga-ref.pdf docs/qemu-ga-ref.7.pod: docs/version.texi\ndocs/qemu-qmp-ref.html docs/qemu-qmp-ref.info docs/qemu-qmp-ref.txt docs/qemu-qmp-ref.pdf docs/qemu-qmp-ref.pod: docs/version.texi\n\nqemu-options.texi: $(SRC_PATH)/qemu-options.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -t < $< > $@,\"GEN\",\"$@\")\n\nqemu-monitor.texi: $(SRC_PATH)/hmp-commands.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -t < $< > $@,\"GEN\",\"$@\")\n\nqemu-monitor-info.texi: $(SRC_PATH)/hmp-commands-info.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -t < $< > $@,\"GEN\",\"$@\")\n\nqemu-img-cmds.texi: $(SRC_PATH)/qemu-img-cmds.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -t < $< > $@,\"GEN\",\"$@\")\n\ndocs/qemu-qmp-qapi.texi docs/qemu-ga-qapi.texi: $(SRC_PATH)/scripts/qapi2texi.py $(qapi-py)\n\ndocs/qemu-qmp-qapi.texi: $(qapi-modules)\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi2texi.py $< > $@,\"GEN\",\"$@\")\n\ndocs/qemu-ga-qapi.texi: $(SRC_PATH)/qga/qapi-schema.json\n\t$(call quiet-command,$(PYTHON) $(SRC_PATH)/scripts/qapi2texi.py $< > $@,\"GEN\",\"$@\")\n\nqemu.1: qemu-doc.texi qemu-options.texi qemu-monitor.texi qemu-monitor-info.texi\nqemu.1: qemu-option-trace.texi\nqemu-img.1: qemu-img.texi qemu-option-trace.texi qemu-img-cmds.texi\nfsdev/virtfs-proxy-helper.1: fsdev/virtfs-proxy-helper.texi\nqemu-nbd.8: qemu-nbd.texi qemu-option-trace.texi\nqemu-ga.8: qemu-ga.texi\n\nhtml: qemu-doc.html docs/qemu-qmp-ref.html docs/qemu-ga-ref.html\ninfo: qemu-doc.info docs/qemu-qmp-ref.info docs/qemu-ga-ref.info\npdf: qemu-doc.pdf docs/qemu-qmp-ref.pdf docs/qemu-ga-ref.pdf\ntxt: qemu-doc.txt docs/qemu-qmp-ref.txt docs/qemu-ga-ref.txt\n\nqemu-doc.html qemu-doc.info qemu-doc.pdf qemu-doc.txt: \\\n\tqemu-img.texi qemu-nbd.texi qemu-options.texi qemu-option-trace.texi \\\n\tqemu-monitor.texi qemu-img-cmds.texi qemu-ga.texi \\\n\tqemu-monitor-info.texi\n\ndocs/qemu-ga-ref.dvi docs/qemu-ga-ref.html docs/qemu-ga-ref.info docs/qemu-ga-ref.pdf docs/qemu-ga-ref.txt docs/qemu-ga-ref.7: \\\ndocs/qemu-ga-ref.texi docs/qemu-ga-qapi.texi\n\ndocs/qemu-qmp-ref.dvi docs/qemu-qmp-ref.html docs/qemu-qmp-ref.info docs/qemu-qmp-ref.pdf docs/qemu-qmp-ref.txt docs/qemu-qmp-ref.7: \\\ndocs/qemu-qmp-ref.texi docs/qemu-qmp-qapi.texi\n\n\nifdef CONFIG_WIN32\n\nINSTALLER = qemu-setup-$(VERSION)$(EXESUF)\n\nnsisflags = -V2 -NOCD\n\nifneq ($(wildcard $(SRC_PATH)/dll),)\nifeq ($(ARCH),x86_64)\n# 64 bit executables\nDLL_PATH = $(SRC_PATH)/dll/w64\nnsisflags += -DW64\nelse\n# 32 bit executables\nDLL_PATH = $(SRC_PATH)/dll/w32\nendif\nendif\n\n.PHONY: installer\ninstaller: $(INSTALLER)\n\nINSTDIR=/tmp/qemu-nsis\n\n$(INSTALLER): $(SRC_PATH)/qemu.nsi\n\t$(MAKE) install prefix=${INSTDIR}\nifdef SIGNCODE\n\t(cd ${INSTDIR}; \\\n         for i in *.exe; do \\\n           $(SIGNCODE) $${i}; \\\n         done \\\n        )\nendif # SIGNCODE\n\t(cd ${INSTDIR}; \\\n         for i in qemu-system-*.exe; do \\\n           arch=$${i%.exe}; \\\n           arch=$${arch#qemu-system-}; \\\n           echo Section \\\"$$arch\\\" Section_$$arch; \\\n           echo SetOutPath \\\"\\$$INSTDIR\\\"; \\\n           echo File \\\"\\$${BINDIR}\\\\$$i\\\"; \\\n           echo SectionEnd; \\\n         done \\\n        ) >${INSTDIR}/system-emulations.nsh\n\tmakensis $(nsisflags) \\\n                $(if $(BUILD_DOCS),-DCONFIG_DOCUMENTATION=\"y\") \\\n                $(if $(CONFIG_GTK),-DCONFIG_GTK=\"y\") \\\n                -DBINDIR=\"${INSTDIR}\" \\\n                $(if $(DLL_PATH),-DDLLDIR=\"$(DLL_PATH)\") \\\n                -DSRCDIR=\"$(SRC_PATH)\" \\\n                -DOUTFILE=\"$(INSTALLER)\" \\\n                -DDISPLAYVERSION=\"$(VERSION)\" \\\n                $(SRC_PATH)/qemu.nsi\n\trm -r ${INSTDIR}\nifdef SIGNCODE\n\t$(SIGNCODE) $(INSTALLER)\nendif # SIGNCODE\nendif # CONFIG_WIN\n\n# Add a dependency on the generated files, so that they are always\n# rebuilt before other object files\nifneq ($(filter-out $(UNCHECKED_GOALS),$(MAKECMDGOALS)),$(if $(MAKECMDGOALS),,fail))\nMakefile: $(GENERATED_FILES)\nendif\n\n.SECONDARY: $(TRACE_HEADERS) $(TRACE_HEADERS:%=%-timestamp) \\\n\t$(TRACE_SOURCES) $(TRACE_SOURCES:%=%-timestamp) \\\n\t$(TRACE_DTRACE) $(TRACE_DTRACE:%=%-timestamp)\n\n# Include automatically generated dependency files\n# Dependencies in Makefile.objs files come from our recursive subdir rules\n-include $(wildcard *.d tests/*.d)\n\ninclude $(SRC_PATH)/tests/docker/Makefile.include\n\n.PHONY: help\nhelp:\n\t@echo  'Generic targets:'\n\t@echo  '  all             - Build all'\n\t@echo  '  dir/file.o      - Build specified target only'\n\t@echo  '  install         - Install QEMU, documentation and tools'\n\t@echo  '  ctags/TAGS      - Generate tags file for editors'\n\t@echo  '  cscope          - Generate cscope index'\n\t@echo  ''\n\t@$(if $(TARGET_DIRS), \\\n\t\techo 'Architecture specific targets:'; \\\n\t\t$(foreach t, $(TARGET_DIRS), \\\n\t\tprintf \"  %-30s - Build for %s\\\\n\" $(patsubst %,subdir-%,$(t)) $(t);) \\\n\t\techo '')\n\t@echo  'Cleaning targets:'\n\t@echo  '  clean           - Remove most generated files but keep the config'\n\t@echo  '  distclean       - Remove all generated files'\n\t@echo  '  dist            - Build a distributable tarball'\n\t@echo  ''\n\t@echo  'Test targets:'\n\t@echo  '  check           - Run all tests (check-help for details)'\n\t@echo  '  docker          - Help about targets running tests inside Docker containers'\n\t@echo  ''\n\t@echo  'Documentation targets:'\n\t@echo  '  html info pdf txt'\n\t@echo  '                  - Build documentation in specified format'\n\t@echo  ''\nifdef CONFIG_WIN32\n\t@echo  'Windows targets:'\n\t@echo  '  installer       - Build NSIS-based installer for QEMU'\nifdef QEMU_GA_MSI_ENABLED\n\t@echo  '  msi             - Build MSI-based installer for qemu-ga'\nendif\n\t@echo  ''\nendif\n\t@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'\n"
        },
        {
          "name": "Makefile.objs",
          "type": "blob",
          "size": 5.3759765625,
          "content": "#######################################################################\n# Common libraries for tools and emulators\nstub-obj-y = stubs/ crypto/\nutil-obj-y = util/ qobject/ qapi/\nutil-obj-y += qmp-introspect.o qapi-types.o qapi-visit.o qapi-event.o\n\nchardev-obj-y = chardev/\n\n#######################################################################\n# block-obj-y is code used by both qemu system emulation and qemu-img\n\nblock-obj-y += nbd/\nblock-obj-y += block.o blockjob.o\nblock-obj-y += block/\nblock-obj-y += qemu-io-cmds.o\nblock-obj-$(CONFIG_REPLICATION) += replication.o\n\nblock-obj-m = block/\n\n#######################################################################\n# crypto-obj-y is code used by both qemu system emulation and qemu-img\n\ncrypto-obj-y = crypto/\ncrypto-aes-obj-y = crypto/\n\n#######################################################################\n# qom-obj-y is code used by both qemu system emulation and qemu-img\n\nqom-obj-y = qom/\n\n#######################################################################\n# io-obj-y is code used by both qemu system emulation and qemu-img\n\nio-obj-y = io/\n\n######################################################################\n# Target independent part of system emulation. The long term path is to\n# suppress *all* target specific code in case of system emulation, i.e. a\n# single QEMU executable should support all CPUs and machines.\n\nifeq ($(CONFIG_SOFTMMU),y)\ncommon-obj-y = blockdev.o blockdev-nbd.o block/\ncommon-obj-y += iothread.o\ncommon-obj-y += net/\ncommon-obj-y += qdev-monitor.o device-hotplug.o\ncommon-obj-$(CONFIG_WIN32) += os-win32.o\ncommon-obj-$(CONFIG_POSIX) += os-posix.o\n\ncommon-obj-$(CONFIG_LINUX) += fsdev/\n\ncommon-obj-y += migration/\ncommon-obj-y += page_cache.o #aio.o\n\ncommon-obj-$(CONFIG_SPICE) += spice-qemu-char.o\n\ncommon-obj-y += audio/\ncommon-obj-y += hw/\ncommon-obj-y += accel.o\n\ncommon-obj-y += replay/\n\ncommon-obj-y += ui/\ncommon-obj-y += bt-host.o bt-vhci.o\nbt-host.o-cflags := $(BLUEZ_CFLAGS)\n\ncommon-obj-y += dma-helpers.o\ncommon-obj-y += vl.o main.o\nvl.o-cflags := $(GPROF_CFLAGS) $(SDL_CFLAGS)\nmain.o-cflags := $(GPROF_CFLAGS) $(SDL_CFLAGS)\ncommon-obj-y += tpm.o\n\ncommon-obj-$(CONFIG_SLIRP) += slirp/\n\ncommon-obj-y += backends/\n\ncommon-obj-$(CONFIG_SECCOMP) += qemu-seccomp.o\n\ncommon-obj-$(CONFIG_FDT) += device_tree.o\n\n######################################################################\n# qapi\n\ncommon-obj-y += qmp-marshal.o\ncommon-obj-y += qmp-introspect.o\ncommon-obj-y += qmp.o hmp.o\nendif\n\n#######################################################################\n# Target-independent parts used in system and user emulation\ncommon-obj-y += cpus-common.o\ncommon-obj-y += hw/\ncommon-obj-y += qom/\ncommon-obj-y += disas/\n\n######################################################################\n# Resource file for Windows executables\nversion-obj-$(CONFIG_WIN32) += $(BUILD_DIR)/version.o\n\n######################################################################\n# tracing\nutil-obj-y +=  trace/\ntarget-obj-y += trace/\n\n######################################################################\n# guest agent\n\n# FIXME: a few definitions from qapi-types.o/qapi-visit.o are needed\n# by libqemuutil.a.  These should be moved to a separate .json schema.\nqga-obj-y = qga/\nqga-vss-dll-obj-y = qga/\n\n######################################################################\n# contrib\nivshmem-client-obj-y = contrib/ivshmem-client/\nivshmem-server-obj-y = contrib/ivshmem-server/\nlibvhost-user-obj-y = contrib/libvhost-user/\n\n######################################################################\ntrace-events-subdirs =\ntrace-events-subdirs += util\ntrace-events-subdirs += crypto\ntrace-events-subdirs += io\ntrace-events-subdirs += migration\ntrace-events-subdirs += block\ntrace-events-subdirs += backends\ntrace-events-subdirs += hw/block\ntrace-events-subdirs += hw/block/dataplane\ntrace-events-subdirs += hw/char\ntrace-events-subdirs += hw/intc\ntrace-events-subdirs += hw/net\ntrace-events-subdirs += hw/virtio\ntrace-events-subdirs += hw/audio\ntrace-events-subdirs += hw/misc\ntrace-events-subdirs += hw/usb\ntrace-events-subdirs += hw/scsi\ntrace-events-subdirs += hw/nvram\ntrace-events-subdirs += hw/display\ntrace-events-subdirs += hw/input\ntrace-events-subdirs += hw/timer\ntrace-events-subdirs += hw/dma\ntrace-events-subdirs += hw/sparc\ntrace-events-subdirs += hw/sd\ntrace-events-subdirs += hw/isa\ntrace-events-subdirs += hw/mem\ntrace-events-subdirs += hw/i386\ntrace-events-subdirs += hw/i386/xen\ntrace-events-subdirs += hw/9pfs\ntrace-events-subdirs += hw/ppc\ntrace-events-subdirs += hw/pci\ntrace-events-subdirs += hw/s390x\ntrace-events-subdirs += hw/vfio\ntrace-events-subdirs += hw/acpi\ntrace-events-subdirs += hw/arm\ntrace-events-subdirs += hw/alpha\ntrace-events-subdirs += hw/xen\ntrace-events-subdirs += ui\ntrace-events-subdirs += audio\ntrace-events-subdirs += net\ntrace-events-subdirs += target/arm\ntrace-events-subdirs += target/i386\ntrace-events-subdirs += target/mips\ntrace-events-subdirs += target/sparc\ntrace-events-subdirs += target/s390x\ntrace-events-subdirs += target/ppc\ntrace-events-subdirs += qom\ntrace-events-subdirs += linux-user\ntrace-events-subdirs += qapi\n\ntrace-events-files = $(SRC_PATH)/trace-events $(trace-events-subdirs:%=$(SRC_PATH)/%/trace-events)\n\ntrace-obj-y = trace-root.o\ntrace-obj-y += $(trace-events-subdirs:%=%/trace.o)\ntrace-obj-$(CONFIG_TRACE_UST) += trace-ust-all.o\ntrace-obj-$(CONFIG_TRACE_DTRACE) += trace-dtrace-root.o\ntrace-obj-$(CONFIG_TRACE_DTRACE) += $(trace-events-subdirs:%=%/trace-dtrace.o)\n"
        },
        {
          "name": "Makefile.target",
          "type": "blob",
          "size": 9.9326171875,
          "content": "# -*- Mode: makefile -*-\n\nBUILD_DIR?=$(CURDIR)/..\n\ninclude ../config-host.mak\ninclude config-target.mak\ninclude config-devices.mak\ninclude $(SRC_PATH)/rules.mak\n\n$(call set-vpath, $(SRC_PATH):$(BUILD_DIR))\nifdef CONFIG_LINUX\nQEMU_CFLAGS += -I../linux-headers\nendif\nQEMU_CFLAGS += -iquote .. -iquote $(SRC_PATH)/target/$(TARGET_BASE_ARCH) -DNEED_CPU_H\n\nQEMU_CFLAGS+=-iquote $(SRC_PATH)/include\n\nifdef CONFIG_USER_ONLY\n# user emulator name\nQEMU_PROG=panda-$(TARGET_NAME)\nQEMU_PROG_BUILD = $(QEMU_PROG)\nelse\n# system emulator name\nQEMU_PROG=panda-system-$(TARGET_NAME)$(EXESUF)\nPANDA_PROG=libpanda-$(TARGET_NAME).so\nPANDA_PROG_NAME=panda-$(TARGET_NAME)\nifneq (,$(findstring -mwindows,$(libs_softmmu)))\n# Terminate program name with a 'w' because the linker builds a windows executable.\nQEMU_PROGW=panda-system-$(TARGET_NAME)w$(EXESUF)\n$(QEMU_PROG): $(QEMU_PROGW)\n\t$(call quiet-command,$(OBJCOPY) --subsystem console $(QEMU_PROGW) $(QEMU_PROG),\"GEN\",\"$(TARGET_DIR)$(QEMU_PROG)\")\nQEMU_PROG_BUILD = $(QEMU_PROGW)\nelse\nQEMU_PROG_BUILD = $(QEMU_PROG)\nendif\nendif\n\nPROGS=$(PANDA_PROG) $(QEMU_PROG) $(QEMU_PROGW)\nSTPFILES=\n\nconfig-target.h: config-target.h-timestamp\nconfig-target.h-timestamp: config-target.mak\n\nifdef CONFIG_TRACE_SYSTEMTAP\nstap: $(QEMU_PROG).stp-installed $(QEMU_PROG).stp $(QEMU_PROG)-simpletrace.stp\n\nifdef CONFIG_USER_ONLY\nTARGET_TYPE=user\nelse\nTARGET_TYPE=system\nendif\n\n$(QEMU_PROG).stp-installed: $(BUILD_DIR)/trace-events-all\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=all \\\n\t\t--format=stap \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t--binary=$(bindir)/$(QEMU_PROG) \\\n\t\t--target-name=$(TARGET_NAME) \\\n\t\t--target-type=$(TARGET_TYPE) \\\n\t\t$< > $@,\"GEN\",\"$(TARGET_DIR)$(QEMU_PROG).stp-installed\")\n\n$(QEMU_PROG).stp: $(BUILD_DIR)/trace-events-all\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=all \\\n\t\t--format=stap \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t--binary=$(realpath .)/$(QEMU_PROG) \\\n\t\t--target-name=$(TARGET_NAME) \\\n\t\t--target-type=$(TARGET_TYPE) \\\n\t\t$< > $@,\"GEN\",\"$(TARGET_DIR)$(QEMU_PROG).stp\")\n\n$(QEMU_PROG)-simpletrace.stp: $(BUILD_DIR)/trace-events-all\n\t$(call quiet-command,$(TRACETOOL) \\\n\t\t--group=all \\\n\t\t--format=simpletrace-stap \\\n\t\t--backends=$(TRACE_BACKENDS) \\\n\t\t--probe-prefix=qemu.$(TARGET_TYPE).$(TARGET_NAME) \\\n\t\t$< > $@,\"GEN\",\"$(TARGET_DIR)$(QEMU_PROG)-simpletrace.stp\")\n\nelse\nstap:\nendif\n.PHONY: stap\n\n#########################################################\n# Panda code\n#########################################################\ninclude $(SRC_PATH)/panda/Makefile.panda.target\n\nall: $(PROGS) stap\n\n# Dummy command so that make thinks it has done something\n\t@true\n\n#########################################################\n# cpu emulator library\nobj-y += exec.o translate-all.o cpu-exec.o\nobj-y += translate-common.o\nobj-y += cpu-exec-common.o\nobj-y += tcg/tcg.o tcg/tcg-op.o tcg/optimize.o\nobj-$(CONFIG_TCG_INTERPRETER) += tci.o\nobj-y += tcg/tcg-common.o\nobj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o\nobj-y += fpu/softfloat.o\nobj-y += target/$(TARGET_BASE_ARCH)/\nobj-y += disas.o\nobj-y += tcg-runtime.o\nobj-$(call notempty,$(TARGET_XML_FILES)) += gdbstub-xml.o\nobj-$(call lnot,$(CONFIG_HAX)) += hax-stub.o\nobj-$(call lnot,$(CONFIG_KVM)) += kvm-stub.o\n\nobj-$(CONFIG_LIBDECNUMBER) += libdecnumber/decContext.o\nobj-$(CONFIG_LIBDECNUMBER) += libdecnumber/decNumber.o\nobj-$(CONFIG_LIBDECNUMBER) += libdecnumber/dpd/decimal32.o\nobj-$(CONFIG_LIBDECNUMBER) += libdecnumber/dpd/decimal64.o\nobj-$(CONFIG_LIBDECNUMBER) += libdecnumber/dpd/decimal128.o\n\n#########################################################\n# Linux user emulator target\n\nifdef CONFIG_LINUX_USER\n\nQEMU_CFLAGS+=-I$(SRC_PATH)/linux-user/$(TARGET_ABI_DIR) \\\n             -I$(SRC_PATH)/linux-user/host/$(ARCH) \\\n             -I$(SRC_PATH)/linux-user\n\nobj-y += linux-user/\nobj-y += gdbstub.o thunk.o user-exec.o user-exec-stub.o\n\nendif #CONFIG_LINUX_USER\n\n#########################################################\n# BSD user emulator target\n\nifdef CONFIG_BSD_USER\n\nQEMU_CFLAGS+=-I$(SRC_PATH)/bsd-user -I$(SRC_PATH)/bsd-user/$(TARGET_ABI_DIR) \\\n\t\t\t -I$(SRC_PATH)/bsd-user/$(HOST_VARIANT_DIR)\n\nobj-y += bsd-user/\nobj-y += gdbstub.o user-exec.o user-exec-stub.o\n\nendif #CONFIG_BSD_USER\n\n#########################################################\n# System emulator target\nifdef CONFIG_SOFTMMU\nobj-y += arch_init.o cpus.o monitor.o gdbstub.o balloon.o ioport.o numa.o\nobj-y += qtest.o bootdevice.o\nobj-y += hw/\nobj-$(CONFIG_KVM) += kvm-all.o\nobj-y += memory.o cputlb.o\nobj-y += memory_mapping.o\nobj-y += dump.o\nobj-y += migration/ram.o migration/savevm.o\nLIBS := $(libs_softmmu) $(LIBS)\n\n# xen support\nobj-$(CONFIG_XEN) += xen-common.o\nobj-$(CONFIG_XEN_I386) += xen-hvm.o xen-mapcache.o\nobj-$(call lnot,$(CONFIG_XEN)) += xen-common-stub.o\nobj-$(call lnot,$(CONFIG_XEN_I386)) += xen-hvm-stub.o\n\n# Hardware support\nifeq ($(TARGET_NAME), sparc64)\nobj-y += hw/sparc64/\nelse\nobj-y += hw/$(TARGET_BASE_ARCH)/\nendif\n\nGENERATED_FILES += hmp-commands.h hmp-commands-info.h\n\nendif # CONFIG_SOFTMMU\n\n# Workaround for http://gcc.gnu.org/PR55489, see configure.\n%/translate.o: QEMU_CFLAGS += $(TRANSLATE_OPT_CFLAGS)\n\ndummy := $(call unnest-vars,,obj-y)\nall-obj-y := $(obj-y)\npanda-all-obj-y := $(obj-y)\n\ntarget-obj-y :=\nblock-obj-y :=\ncommon-obj-y :=\nchardev-obj-y :=\ninclude $(SRC_PATH)/Makefile.objs\ndummy := $(call unnest-vars,,target-obj-y)\ntarget-obj-y-save := $(target-obj-y)\ndummy := $(call unnest-vars,.., \\\n               block-obj-y \\\n               block-obj-m \\\n               chardev-obj-y \\\n               crypto-obj-y \\\n               crypto-aes-obj-y \\\n               qom-obj-y \\\n               io-obj-y \\\n               common-obj-y \\\n               common-obj-m \\\n               trace-obj-y)\ntarget-obj-y := $(target-obj-y-save)\nall-obj-y += $(common-obj-y)\nall-obj-y += $(target-obj-y)\nall-obj-y += $(qom-obj-y)\nall-obj-$(CONFIG_SOFTMMU) += $(block-obj-y) $(chardev-obj-y)\nall-obj-$(CONFIG_USER_ONLY) += $(crypto-aes-obj-y)\nall-obj-$(CONFIG_SOFTMMU) += $(crypto-obj-y)\nall-obj-$(CONFIG_SOFTMMU) += $(io-obj-y)\nall-obj-$(CONFIG_SOFTMMU) += panda/src/panda_api.o\n\nifdef CONFIG_SOFTMMU\npanda-all-obj-y += $(filter-out %main.o, $(common-obj-y))\npanda-all-obj-y += panda/src/panda_api.o\npanda-all-obj-y += $(target-obj-y)\npanda-all-obj-y += $(qom-obj-y)\npanda-all-obj-$(CONFIG_SOFTMMU) += $(block-obj-y) $(chardev-obj-y)\npanda-all-obj-$(CONFIG_SOFTMMU) += $(crypto-obj-y)\npanda-all-obj-$(CONFIG_SOFTMMU) += $(io-obj-y)\nendif #CONFIG_SOFTMMU\n\n$(QEMU_PROG_BUILD): config-devices.mak\n$(PANDA_PROG): config-devices.mak\n\nCOMMON_LDADDS = $(trace-obj-y) ../libqemuutil.a ../libqemustub.a\n\n# build either PROG or PROGW and libpanda.so\n# QEMU_PROG_BUILD is dynamically linked against PANDA_PROG (libpanda) and only contains main.o\n$(QEMU_PROG_BUILD): LDFLAGS+=-L. -l$(PANDA_PROG_NAME) -Wl,-rpath,'$$ORIGIN' -Wl,-rpath='$$ORIGIN/../lib'\n$(QEMU_PROG_BUILD): main.o $(PANDA_PROG)\n\t$(call LINK, $(filter-out %.mak, $^))\n\n$(PANDA_PROG): LDFLAGS+=-shared\n$(PANDA_PROG): $(panda-all-obj-y) $(COMMON_LDADDS)\n\t$(call LINK, $(filter-out %.mak, $^))\nifdef CONFIG_DARWIN\n\t$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/panda.rsrc -o $@,\"REZ\",\"$(TARGET_DIR)$@\")\n\t$(call quiet-command,SetFile -a C $@,\"SETFILE\",\"$(TARGET_DIR)$@\")\nendif\n\ngdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh\n\t$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),\"GEN\",\"$(TARGET_DIR)$@\")\n\nhmp-commands.h: $(SRC_PATH)/hmp-commands.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,\"GEN\",\"$(TARGET_DIR)$@\")\n\nhmp-commands-info.h: $(SRC_PATH)/hmp-commands-info.hx $(SRC_PATH)/scripts/hxtool\n\t$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,\"GEN\",\"$(TARGET_DIR)$@\")\n\nclean: clean-target\n\trm -f *.a *~ $(PROGS)\n\trm -f $(shell find . -name '*.[od]')\n\trm -f hmp-commands.h gdbstub-xml.c\nifdef CONFIG_TRACE_SYSTEMTAP\n\trm -f *.stp\nendif\n\ninstall: all\nifneq ($(PROGS),)\n\t$(call install-prog,$(PROGS),$(DESTDIR)$(bindir))\nendif\nifdef CONFIG_TRACE_SYSTEMTAP\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_datadir)/../systemtap/tapset\"\n\t$(INSTALL_DATA) $(QEMU_PROG).stp-installed \"$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp\"\n\t$(INSTALL_DATA) $(QEMU_PROG)-simpletrace.stp \"$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG)-simpletrace.stp\"\nendif\nifdef CONFIG_LLVM\n\t$(INSTALL_DATA) $(llvmmorph-y) \"$(DESTDIR)$(qemu_datadir)/\"\nendif\n\t# Install into [prefix]/usr/lib/python3/dist-packages which should work with any Python3.x install unlike site-packages which\n\t# contains minor version numbers in the path. See https://stackoverflow.com/a/54239729\n\t$(INSTALL_DIR) \"$(DESTDIR)$(pythondir)\"\n\t$(INSTALL_LIB) plog_pb2.py \"$(DESTDIR)$(pythondir)/\"\n\t$(INSTALL_DIR) \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)\"\n\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_datadir)/scripts\"\n\tfor f in $$(find $(SRC_PATH)/panda/scripts -type f); do \\\n\t\techo $$f; \\\n\t\t$(INSTALL_PROG) $$f \"$(DESTDIR)$(qemu_datadir)/scripts\"; \\\n\tdone\n\t$(INSTALL_DATA) $(SRC_PATH)/docs/qemupciserial.inf \"$(DESTDIR)$(qemu_datadir)/qemupciserial.inf\"\n# N.B. the new rpath must not be longer than the old rpath or chrpath will fail\n\tfor p in $(PANDA_PLUGINS) $(EXTRA_PANDA_PLUGINS); do \\\n\t\techo $$p; \\\n\t\t$(INSTALL_LIB) panda/plugins/panda_$$p.so \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)\"; \\\n\t\tchrpath -r \"$(libdir)/panda/$(TARGET_NAME)\" \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)/panda_$$p.so\" >/dev/null; \\\n\t\tfor f in $$(find panda/plugins/$$p -type f -not -name '*.d' -not -name '*.o' -not -name '*.h' -not -name '*.conf' -not -name '*.ini'); do \\\n\t\t\t$(INSTALL_DIR) \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)/$$p\"; \\\n\t\t\t$(INSTALL_DATA) $$f \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)/$$p\"; \\\n\t\tdone; \\\n\t\tfor f in $$(find panda/plugins/$$p -type f -name '*.conf' -o -name '*.ini'); do \\\n\t\t\t$(INSTALL_DIR) \"$(DESTDIR)$(qemu_confdir)/$$p\"; \\\n\t\t\t$(INSTALL_DATA) $$f \"$(DESTDIR)$(qemu_confdir)/$$p\"; \\\n\t\tdone; \\\n\tdone\n\tfor f in $$(find panda/plugins/ -type f -name 'syscalls2_dso_info_*.so'); do \\\n\t\techo $$f; \\\n\t\t$(INSTALL_LIB) $$f \"$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)\"; \\\n\tdone\n\nGENERATED_FILES += config-target.h plog_pb2.py\nMakefile: $(GENERATED_FILES)\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 3.6044921875,
          "content": "         QEMU README\n         ===========\n\nQEMU is a generic and open source machine & userspace emulator and\nvirtualizer.\n\nQEMU is capable of emulating a complete machine in software without any\nneed for hardware virtualization support. By using dynamic translation,\nit achieves very good performance. QEMU can also integrate with the Xen\nand KVM hypervisors to provide emulated hardware while allowing the\nhypervisor to manage the CPU. With hypervisor support, QEMU can achieve\nnear native performance for CPUs. When QEMU emulates CPUs directly it is\ncapable of running operating systems made for one machine (e.g. an ARMv7\nboard) on a different machine (e.g. an x86_64 PC board).\n\nQEMU is also capable of providing userspace API virtualization for Linux\nand BSD kernel interfaces. This allows binaries compiled against one\narchitecture ABI (e.g. the Linux PPC64 ABI) to be run on a host using a\ndifferent architecture ABI (e.g. the Linux x86_64 ABI). This does not\ninvolve any hardware emulation, simply CPU and syscall emulation.\n\nQEMU aims to fit into a variety of use cases. It can be invoked directly\nby users wishing to have full control over its behaviour and settings.\nIt also aims to facilitate integration into higher level management\nlayers, by providing a stable command line interface and monitor API.\nIt is commonly invoked indirectly via the libvirt library when using\nopen source applications such as oVirt, OpenStack and virt-manager.\n\nQEMU as a whole is released under the GNU General Public License,\nversion 2. For full licensing details, consult the LICENSE file.\n\n\nBuilding\n========\n\nQEMU is multi-platform software intended to be buildable on all modern\nLinux platforms, OS-X, Win32 (via the Mingw64 toolchain) and a variety\nof other UNIX targets. The simple steps to build QEMU are:\n\n  mkdir build\n  cd build\n  ../configure\n  make\n\nAdditional information can also be found online via the QEMU website:\n\n  http://qemu-project.org/Hosts/Linux\n  http://qemu-project.org/Hosts/Mac\n  http://qemu-project.org/Hosts/W32\n\n\nSubmitting patches\n==================\n\nThe QEMU source code is maintained under the GIT version control system.\n\n   git clone git://git.qemu-project.org/qemu.git\n\nWhen submitting patches, the preferred approach is to use 'git\nformat-patch' and/or 'git send-email' to format & send the mail to the\nqemu-devel@nongnu.org mailing list. All patches submitted must contain\na 'Signed-off-by' line from the author. Patches should follow the\nguidelines set out in the HACKING and CODING_STYLE files.\n\nAdditional information on submitting patches can be found online via\nthe QEMU website\n\n  http://qemu-project.org/Contribute/SubmitAPatch\n  http://qemu-project.org/Contribute/TrivialPatches\n\n\nBug reporting\n=============\n\nThe QEMU project uses Launchpad as its primary upstream bug tracker. Bugs\nfound when running code built from QEMU git or upstream released sources\nshould be reported via:\n\n  https://bugs.launchpad.net/qemu/\n\nIf using QEMU via an operating system vendor pre-built binary package, it\nis preferable to report bugs to the vendor's own bug tracker first. If\nthe bug is also known to affect latest upstream code, it can also be\nreported via launchpad.\n\nFor additional information on bug reporting consult:\n\n  http://qemu-project.org/Contribute/ReportABug\n\n\nContact\n=======\n\nThe QEMU community can be contacted in a number of ways, with the two\nmain methods being email and IRC\n\n - qemu-devel@nongnu.org\n   http://lists.nongnu.org/mailman/listinfo/qemu-devel\n - #qemu on irc.oftc.net\n\nInformation on additional methods of contacting the community can be\nfound online via the QEMU website:\n\n  http://qemu-project.org/Contribute/StartHere\n\n-- End\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.583984375,
          "content": "# PANDA\n\n![Test Suite](https://github.com/panda-re/panda/workflows/Parallel%20Tests/badge.svg)\n![Publish Docker Container and Update Pypanda Docs](https://github.com/panda-re/panda/workflows/Build%20and%20Publish%20Docker%20Container%20and%20Pypanda%20Docs/badge.svg)\n\n\nPANDA is an open-source Platform for Architecture-Neutral Dynamic Analysis. It\nis built upon the QEMU whole system emulator, and so analyses have access to all\ncode executing in the guest and all data. PANDA adds the ability to record and\nreplay executions, enabling iterative, deep, whole system analyses. Further, the\nreplay log files are compact and shareable, allowing for repeatable experiments.\nA nine billion instruction boot of FreeBSD, e.g., is represented by only a few\nhundred MB. PANDA leverages QEMU's support of thirteen different CPU\narchitectures to make analyses of those diverse instruction sets possible within\nthe LLVM IR. In this way, PANDA can have a single dynamic taint analysis, for\nexample, that precisely supports many CPUs. PANDA analyses are written in a\nsimple plugin architecture which includes a mechanism to share functionality\nbetween plugins, increasing analysis code re-use and simplifying complex\nanalysis development.\n\nIt is currently being developed in collaboration with MIT Lincoln\nLaboratory, NYU, and Northeastern University. PANDA is released under\nthe [GPLv2 license](LICENSE).\n\n---------------------------------------------------------------------\n\n## Notable Branches\nWe have two primary branches of PANDA: `dev` for development and `stable` for stable+versioned releases. To learn more about the differences between these branches and version numbers, visit [our wiki](https://github.com/panda-re/panda/wiki/PANDA-Branches-&-Versioning). In general, PANDA resources (i.e., docker containers and documentation) are based off the `dev` branch. We recommend using the `stable` branch if you're going to fork the project and later pull in updates.\n\n## Building\n### Quickstart: Docker\nThe latest version of PANDA's `master` branch is automatically built as a two docker images based on Ubuntu 20.04 and published to Docker Hub.\nMost users will want to use the `panda` container which has PANDA and PyPANDA installed along with their runtime dependencies, but no build artifacts or source code to reduce the size of the container.\nDevelopers interested in using Docker should use the `pandadev` container which has PANDA and PyPANDA installed, build and runtime dependencies for both, all build artifacts and source code and the contents of this repository in the `/panda` directory.\n\nTo use the `panda` container you can pull it from Docker Hub:\n```\n$ docker pull pandare/panda\n$ docker run --rm pandare/panda panda-system-i386 --help\n```\nOr build from this repository:\n```\n$ DOCKER_BUILDKIT=1 docker build --target=panda -t panda .\n$ docker run --rm panda panda-system-i386 --help\n```\n\nTo use the `pandadev` container, you can pull it from Docker Hub:\n```\n$ docker pull pandare/pandadev\n$ docker run --rm pandare/pandadev /panda/build/panda-system-i386 --help\n```\nOr build from this repository:\n```\n$ DOCKER_BUILDKIT=1 docker build --target=developer -t pandadev .\n$ docker run --rm pandadev panda-system-i386 --help\n```\n\n### Quickstart: Python pip\nThe Python interface to PANDA (also known as *pypanda*) can be installed from [PIP](https://pypi.org/project/pandare/) by running `pip3 install pandare`. This will install everything you need for python-based PANDA analyses, but not stand-alone PANDA binaries. The distributed binaries are only tested on 64-bit Ubuntu 18.04 and other architectures/versions are unlikely to work. You can also install pypanda by building PANDA and then running `python3 setup.py install` from the directory `panda/panda/python/core`.\n\n###  Debian, Ubuntu\nThe fastest way to install PANDA would be through installing [the debian packages](https://github.com/pandare/panda/releases).\nThere is a debian package for both Ubuntu 20.04 and Ubuntu 22.04, and its corresponding PyPanda package.\nBecause PANDA has a few dependencies, we've encoded the build instructions into\nthe [install\\_ubuntu.sh](panda/scripts/install\\_ubuntu.sh). The script should\nwork on the latest Debian stable/Ubuntu LTS versions.\nIf you wish to build PANDA manually, you can also check the\n[step-by-step instructions](panda/docs/build\\_ubuntu.md) in the documentation\ndirectory.\n\nWe currently only vouch for buildability on the latest Debian stable/Ubuntu LTS, but we welcome pull requests to fix issues with other distros.\nFor other distributions, it should be straightforward to translate the `apt-get`\ncommands into whatever package manager your distribution uses.\n\nNote that if you want to use our LLVM features (mainly the dynamic taint\nsystem), you will need to install LLVM 11 from OS packages or compiled from\nsource. On Ubuntu this should happen automatically via `install_ubuntu.sh`.\nAdditionally, it is **strongly** recommended that you only build PANDA as 64-bit binary.\nCreating a 32-bit build should be possible, but best avoided.\nSee the limitations section for details.\n\n### Arch Linux\nThe [install\\_arch.sh](panda/scripts/install\\_arch.sh) has been contributed\nfor building PANDA on Arch Linux.\nCurrently, the script has only been tested on Arch Linux 4.17.5-1-MANJARO.\nYou can also find\n[step-by-step instructions for building on Arch](panda/docs/build\\_arch.md)\nin the documentation directory.\n\n### MacOS\nBuilding on Mac is less well-tested, but has been known to work. There is a script,\n[install\\_osx.sh](panda/scripts/install\\_osx.sh) to build under OS X.\nThe script uses [homebrew](https://brew.sh) to install the PANDA dependencies.\nAs homebrew is known to be very fast in deprecating support for older versions\nof OS X and supported packages, expect this to be broken.\n\n### Installation\nAfter successfully building PANDA, you can copy the build to a system-wide\nlocation by running `make install`. The default installation path is `/usr/local`.\nYou can specify an alternate installation path through the `prefix` configuration\noption. E.g. `--prefix=/opt/panda`.  Note that your system must have `chrpath`\ninstalled in order for `make install` to succeed.\n\nIf the `bin` directory containing the PANDA binaries is in your `PATH` environment\nvariable, then you can run PANDA similarly to QEMU:\n\n    panda-system-i386 -m 2G -hda guest.img -monitor stdio\n\n---------------------------------------------------------------------\n\n## Limitations\n\n### LLVM Support\nPANDA uses the LLVM architecture from the [S2E project](https://github.com/dslab-epfl/s2e).\nThis allows translating the TCG intermediate code representation used by QEMU,\nto LLVM IR. The latter has the advantages of being easier to work with, as well\nas platform independent. This enables the implementation of complex analyses\nlike the `taint2` plugin.\nThe S2E files used by PANDA to support taint analysis have been updated to work with LLVM 11.\n\n### Cross-architecture record/replay\nGreat effort is put to maintain the PANDA trace format stable so that existing\ntraces remain replayable in the future. Changes that will break existing traces\nare avoided.\nHowever, currently, record/replay is only guaranteed between PANDA builds of the\nsame address length. E.g. you can't replay a trace captured on a 32bit build of\nPANDA on a 64bit of PANDA. The reason for this is that some raw pointers managed\nto creep into the trace format (see headers in `panda/rr`).\n\nGiven the memory limitations of 32bit builds, almost all PANDA users use 64bit.\nAs a result, this issue should affect only a tiny minority of users.\nThis is also supported by the fact that the issue remained unreported for a\nlong time (>3 years). Therefore, when a fix is to be implemented, it may be\nassessed that migrating existing recordings captured by 32bit builds is not\nworth the effort.\n\nFor this, it is **strongly** recommended that you only create and use 64bit\nbuilds of PANDA. If you happen to already have a dataset of traces captured\nby a 32bit build of PANDA, you should contact the community ASAP to discuss\npossible options.\n\n---------------------------------------------------------------------\n\n## Documentation and Support\n\n### PANDA manual\nPANDA currently supports whole-system record/replay execution, as well as\ntime-travel debugging, of x86, x86\\_64, and ARM guests. Other architectures\n(mips, mipsel, ppc) may be run under PANDA without record/replay support.\nDetails about the implementation and use of PANDA can be found in the\n[PANDA manual](panda/docs/manual.md). Some of the topics covered are:\n\n  * [details about record/replay](panda/docs/manual.md#recordreplay-details)\n  * the [architecture-neutral plugin interface](panda/docs/manual.md#plugin-architecture)\n  * the [callbacks provided by PANDA](panda/docs/manual.md#appendix-a-callback-list)\n  * [plugin zoo](panda/docs/manual.md#plugin-zoo)\n  * [python interface](panda/python/README.md)\n\nDocumentation for individual plugins is provided by the `README.md` file\nin the plugin directory. See [panda/plugins](panda/plugins) directory.\n\n### Support\nIf you need help with PANDA, or want to discuss the project, you can request an invite\nto our Slack channel [here](https://panda-re.mit.edu/invite.php) or join the [PANDA mailing\nlist](http://mailman.mit.edu/mailman/listinfo/panda-users).\n\n---------------------------------------------------------------------\n\n## Publications\n\n* [1] B. Dolan-Gavitt, T. Leek, J. Hodosh, W. Lee.  Tappan Zee (North) Bridge:\nMining Memory Accesses for Introspection. 20th ACM Conference on Computer and\nCommunications Security (CCS), Berlin, Germany, November 2013.\n\n* [2] R. Whelan, T. Leek, D. Kaeli.  Architecture-Independent Dynamic\nInformation Flow Tracking. 22nd International Conference on Compiler\nConstruction (CC), Rome, Italy, March 2013.\n\n* [3] B. Dolan-Gavitt, J. Hodosh, P. Hulin, T. Leek, R. Whelan.\nRepeatable Reverse Engineering with PANDA. 5th Program Protection and Reverse\nEngineering Workshop, Los Angeles, California, December 2015.\n\n* [4] M. Stamatogiannakis, P. Groth, H. Bos. Decoupling Provenance\nCapture and Analysis from Execution. 7th USENIX Workshop on the Theory\nand Practice of Provenance, Edinburgh, Scotland, July 2015.\n\n* [5] B. Dolan-Gavitt, P. Hulin, T. Leek, E. Kirda, A. Mambretti,\nW. Robertson, F. Ulrich, R. Whelan. LAVA: Large-scale Automated Vulnerability\nAddition. 37th IEEE Symposium on Security and Privacy, San Jose,\nCalifornia, May 2016.\n\n---------------------------------------------------------------------\n\n## Acknowledgements\n\nThis material is based upon work supported under Air Force Contract No.\nFA8721-05-C-0002 and/or FA8702-15-D-0001. Any opinions, findings,\nconclusions or recommendations expressed in this material are those of\nthe author(s) and do not necessarily reflect the views of the U.S. Air\nForce.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "2.9.1\n"
        },
        {
          "name": "accel.c",
          "type": "blob",
          "size": 4.34765625,
          "content": "/*\n * QEMU System Emulator, accelerator interfaces\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2014 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/accel.h\"\n#include \"hw/boards.h\"\n#include \"qemu-common.h\"\n#include \"sysemu/arch_init.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/qtest.h\"\n#include \"hw/xen/xen.h\"\n#include \"qom/object.h\"\n\nint tcg_tb_size;\nstatic bool tcg_allowed = true;\n\nstatic int tcg_init(MachineState *ms)\n{\n    tcg_exec_init(tcg_tb_size * 1024 * 1024);\n    return 0;\n}\n\nstatic const TypeInfo accel_type = {\n    .name = TYPE_ACCEL,\n    .parent = TYPE_OBJECT,\n    .class_size = sizeof(AccelClass),\n    .instance_size = sizeof(AccelState),\n};\n\n/* Lookup AccelClass from opt_name. Returns NULL if not found */\nstatic AccelClass *accel_find(const char *opt_name)\n{\n    char *class_name = g_strdup_printf(ACCEL_CLASS_NAME(\"%s\"), opt_name);\n    AccelClass *ac = ACCEL_CLASS(object_class_by_name(class_name));\n    g_free(class_name);\n    return ac;\n}\n\nstatic int accel_init_machine(AccelClass *acc, MachineState *ms)\n{\n    ObjectClass *oc = OBJECT_CLASS(acc);\n    const char *cname = object_class_get_name(oc);\n    AccelState *accel = ACCEL(object_new(cname));\n    int ret;\n    ms->accelerator = accel;\n    *(acc->allowed) = true;\n    ret = acc->init_machine(ms);\n    if (ret < 0) {\n        ms->accelerator = NULL;\n        *(acc->allowed) = false;\n        object_unref(OBJECT(accel));\n    }\n    return ret;\n}\n\nvoid configure_accelerator(MachineState *ms)\n{\n    const char *p;\n    char buf[10];\n    int ret;\n    bool accel_initialised = false;\n    bool init_failed = false;\n    AccelClass *acc = NULL;\n\n    p = qemu_opt_get(qemu_get_machine_opts(), \"accel\");\n    if (p == NULL) {\n        /* Use the default \"accelerator\", tcg */\n        p = \"tcg\";\n    }\n\n    while (!accel_initialised && *p != '\\0') {\n        if (*p == ':') {\n            p++;\n        }\n        p = get_opt_name(buf, sizeof(buf), p, ':');\n        acc = accel_find(buf);\n        if (!acc) {\n            fprintf(stderr, \"\\\"%s\\\" accelerator not found.\\n\", buf);\n            continue;\n        }\n        if (acc->available && !acc->available()) {\n            printf(\"%s not supported for this target\\n\",\n                   acc->name);\n            continue;\n        }\n        ret = accel_init_machine(acc, ms);\n        if (ret < 0) {\n            init_failed = true;\n            fprintf(stderr, \"failed to initialize %s: %s\\n\",\n                    acc->name,\n                    strerror(-ret));\n        } else {\n            accel_initialised = true;\n        }\n    }\n\n    if (!accel_initialised) {\n        if (!init_failed) {\n            fprintf(stderr, \"No accelerator found!\\n\");\n        }\n        exit(1);\n    }\n\n    if (init_failed) {\n        fprintf(stderr, \"Back to %s accelerator.\\n\", acc->name);\n    }\n}\n\n\nstatic void tcg_accel_class_init(ObjectClass *oc, void *data)\n{\n    AccelClass *ac = ACCEL_CLASS(oc);\n    ac->name = \"tcg\";\n    ac->init_machine = tcg_init;\n    ac->allowed = &tcg_allowed;\n}\n\n#define TYPE_TCG_ACCEL ACCEL_CLASS_NAME(\"tcg\")\n\nstatic const TypeInfo tcg_accel_type = {\n    .name = TYPE_TCG_ACCEL,\n    .parent = TYPE_ACCEL,\n    .class_init = tcg_accel_class_init,\n};\n\nstatic void register_accel_types(void)\n{\n    type_register_static(&accel_type);\n    type_register_static(&tcg_accel_type);\n}\n\ntype_init(register_accel_types);\n"
        },
        {
          "name": "arch_init.c",
          "type": "blob",
          "size": 6.447265625,
          "content": "/*\n * QEMU System Emulator\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/arch_init.h\"\n#include \"hw/pci/pci.h\"\n#include \"hw/audio/audio.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/error-report.h\"\n#include \"qmp-commands.h\"\n#include \"hw/acpi/acpi.h\"\n#include \"qemu/help_option.h\"\n\n#ifdef TARGET_SPARC\nint graphic_width = 1024;\nint graphic_height = 768;\nint graphic_depth = 8;\n#else\nint graphic_width = 800;\nint graphic_height = 600;\nint graphic_depth = 32;\n#endif\n\n\n#if defined(TARGET_ALPHA)\n#define QEMU_ARCH QEMU_ARCH_ALPHA\n#elif defined(TARGET_ARM)\n#define QEMU_ARCH QEMU_ARCH_ARM\n#elif defined(TARGET_CRIS)\n#define QEMU_ARCH QEMU_ARCH_CRIS\n#elif defined(TARGET_I386)\n#define QEMU_ARCH QEMU_ARCH_I386\n#elif defined(TARGET_M68K)\n#define QEMU_ARCH QEMU_ARCH_M68K\n#elif defined(TARGET_LM32)\n#define QEMU_ARCH QEMU_ARCH_LM32\n#elif defined(TARGET_MICROBLAZE)\n#define QEMU_ARCH QEMU_ARCH_MICROBLAZE\n#elif defined(TARGET_MIPS)\n#define QEMU_ARCH QEMU_ARCH_MIPS\n#elif defined(TARGET_MOXIE)\n#define QEMU_ARCH QEMU_ARCH_MOXIE\n#elif defined(TARGET_NIOS2)\n#define QEMU_ARCH QEMU_ARCH_NIOS2\n#elif defined(TARGET_OPENRISC)\n#define QEMU_ARCH QEMU_ARCH_OPENRISC\n#elif defined(TARGET_PPC)\n#define QEMU_ARCH QEMU_ARCH_PPC\n#elif defined(TARGET_S390X)\n#define QEMU_ARCH QEMU_ARCH_S390X\n#elif defined(TARGET_SH4)\n#define QEMU_ARCH QEMU_ARCH_SH4\n#elif defined(TARGET_SPARC)\n#define QEMU_ARCH QEMU_ARCH_SPARC\n#elif defined(TARGET_XTENSA)\n#define QEMU_ARCH QEMU_ARCH_XTENSA\n#elif defined(TARGET_UNICORE32)\n#define QEMU_ARCH QEMU_ARCH_UNICORE32\n#elif defined(TARGET_TRICORE)\n#define QEMU_ARCH QEMU_ARCH_TRICORE\n#endif\n\nconst uint32_t arch_type = QEMU_ARCH;\n\nstruct soundhw {\n    const char *name;\n    const char *descr;\n    int enabled;\n    int isa;\n    union {\n        int (*init_isa) (ISABus *bus);\n        int (*init_pci) (PCIBus *bus);\n    } init;\n};\n\nstatic struct soundhw soundhw[9];\nstatic int soundhw_count;\n\nvoid isa_register_soundhw(const char *name, const char *descr,\n                          int (*init_isa)(ISABus *bus))\n{\n    assert(soundhw_count < ARRAY_SIZE(soundhw) - 1);\n    soundhw[soundhw_count].name = name;\n    soundhw[soundhw_count].descr = descr;\n    soundhw[soundhw_count].isa = 1;\n    soundhw[soundhw_count].init.init_isa = init_isa;\n    soundhw_count++;\n}\n\nvoid pci_register_soundhw(const char *name, const char *descr,\n                          int (*init_pci)(PCIBus *bus))\n{\n    assert(soundhw_count < ARRAY_SIZE(soundhw) - 1);\n    soundhw[soundhw_count].name = name;\n    soundhw[soundhw_count].descr = descr;\n    soundhw[soundhw_count].isa = 0;\n    soundhw[soundhw_count].init.init_pci = init_pci;\n    soundhw_count++;\n}\n\nvoid select_soundhw(const char *optarg)\n{\n    struct soundhw *c;\n\n    if (is_help_option(optarg)) {\n    show_valid_cards:\n\n        if (soundhw_count) {\n             printf(\"Valid sound card names (comma separated):\\n\");\n             for (c = soundhw; c->name; ++c) {\n                 printf (\"%-11s %s\\n\", c->name, c->descr);\n             }\n             printf(\"\\n-soundhw all will enable all of the above\\n\");\n        } else {\n             printf(\"Machine has no user-selectable audio hardware \"\n                    \"(it may or may not have always-present audio hardware).\\n\");\n        }\n        exit(!is_help_option(optarg));\n    }\n    else {\n        size_t l;\n        const char *p;\n        char *e;\n        int bad_card = 0;\n\n        if (!strcmp(optarg, \"all\")) {\n            for (c = soundhw; c->name; ++c) {\n                c->enabled = 1;\n            }\n            return;\n        }\n\n        p = optarg;\n        while (*p) {\n            e = strchr(p, ',');\n            l = !e ? strlen(p) : (size_t) (e - p);\n\n            for (c = soundhw; c->name; ++c) {\n                if (!strncmp(c->name, p, l) && !c->name[l]) {\n                    c->enabled = 1;\n                    break;\n                }\n            }\n\n            if (!c->name) {\n                if (l > 80) {\n                    error_report(\"Unknown sound card name (too big to show)\");\n                }\n                else {\n                    error_report(\"Unknown sound card name `%.*s'\",\n                                 (int) l, p);\n                }\n                bad_card = 1;\n            }\n            p += l + (e != NULL);\n        }\n\n        if (bad_card) {\n            goto show_valid_cards;\n        }\n    }\n}\n\nvoid audio_init(void)\n{\n    struct soundhw *c;\n    ISABus *isa_bus = (ISABus *) object_resolve_path_type(\"\", TYPE_ISA_BUS, NULL);\n    PCIBus *pci_bus = (PCIBus *) object_resolve_path_type(\"\", TYPE_PCI_BUS, NULL);\n\n    for (c = soundhw; c->name; ++c) {\n        if (c->enabled) {\n            if (c->isa) {\n                if (!isa_bus) {\n                    error_report(\"ISA bus not available for %s\", c->name);\n                    exit(1);\n                }\n                c->init.init_isa(isa_bus);\n            } else {\n                if (!pci_bus) {\n                    error_report(\"PCI bus not available for %s\", c->name);\n                    exit(1);\n                }\n                c->init.init_pci(pci_bus);\n            }\n        }\n    }\n}\n\nint kvm_available(void)\n{\n#ifdef CONFIG_KVM\n    return 1;\n#else\n    return 0;\n#endif\n}\n\nint xen_available(void)\n{\n#ifdef CONFIG_XEN\n    return 1;\n#else\n    return 0;\n#endif\n}\n\n\nTargetInfo *qmp_query_target(Error **errp)\n{\n    TargetInfo *info = g_malloc0(sizeof(*info));\n\n    info->arch = g_strdup(TARGET_NAME);\n\n    return info;\n}\n"
        },
        {
          "name": "atomic_template.h",
          "type": "blob",
          "size": 6.1044921875,
          "content": "/*\n * Atomic helper templates\n * Included from tcg-runtime.c and cputlb.c.\n *\n * Copyright (c) 2016 Red Hat, Inc\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#if DATA_SIZE == 16\n# define SUFFIX     o\n# define DATA_TYPE  Int128\n# define BSWAP      bswap128\n#elif DATA_SIZE == 8\n# define SUFFIX     q\n# define DATA_TYPE  uint64_t\n# define BSWAP      bswap64\n#elif DATA_SIZE == 4\n# define SUFFIX     l\n# define DATA_TYPE  uint32_t\n# define BSWAP      bswap32\n#elif DATA_SIZE == 2\n# define SUFFIX     w\n# define DATA_TYPE  uint16_t\n# define BSWAP      bswap16\n#elif DATA_SIZE == 1\n# define SUFFIX     b\n# define DATA_TYPE  uint8_t\n# define BSWAP\n#else\n# error unsupported data size\n#endif\n\n#if DATA_SIZE >= 4\n# define ABI_TYPE  DATA_TYPE\n#else\n# define ABI_TYPE  uint32_t\n#endif\n\n/* Define host-endian atomic operations.  Note that END is used within\n   the ATOMIC_NAME macro, and redefined below.  */\n#if DATA_SIZE == 1\n# define END\n#elif defined(HOST_WORDS_BIGENDIAN)\n# define END  _be\n#else\n# define END  _le\n#endif\n\nABI_TYPE ATOMIC_NAME(cmpxchg)(CPUArchState *env, target_ulong addr,\n                              ABI_TYPE cmpv, ABI_TYPE newv EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    return atomic_cmpxchg__nocheck(haddr, cmpv, newv);\n}\n\n#if DATA_SIZE >= 16\nABI_TYPE ATOMIC_NAME(ld)(CPUArchState *env, target_ulong addr EXTRA_ARGS)\n{\n    DATA_TYPE val, *haddr = ATOMIC_MMU_LOOKUP;\n    __atomic_load(haddr, &val, __ATOMIC_RELAXED);\n    return val;\n}\n\nvoid ATOMIC_NAME(st)(CPUArchState *env, target_ulong addr,\n                     ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    __atomic_store(haddr, &val, __ATOMIC_RELAXED);\n}\n#else\nABI_TYPE ATOMIC_NAME(xchg)(CPUArchState *env, target_ulong addr,\n                           ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    return atomic_xchg__nocheck(haddr, val);\n}\n\n#define GEN_ATOMIC_HELPER(X)                                        \\\nABI_TYPE ATOMIC_NAME(X)(CPUArchState *env, target_ulong addr,       \\\n                 ABI_TYPE val EXTRA_ARGS)                           \\\n{                                                                   \\\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;                           \\\n    return atomic_##X(haddr, val);                                  \\\n}                                                                   \\\n\nGEN_ATOMIC_HELPER(fetch_add)\nGEN_ATOMIC_HELPER(fetch_and)\nGEN_ATOMIC_HELPER(fetch_or)\nGEN_ATOMIC_HELPER(fetch_xor)\nGEN_ATOMIC_HELPER(add_fetch)\nGEN_ATOMIC_HELPER(and_fetch)\nGEN_ATOMIC_HELPER(or_fetch)\nGEN_ATOMIC_HELPER(xor_fetch)\n\n#undef GEN_ATOMIC_HELPER\n#endif /* DATA SIZE >= 16 */\n\n#undef END\n\n#if DATA_SIZE > 1\n\n/* Define reverse-host-endian atomic operations.  Note that END is used\n   within the ATOMIC_NAME macro.  */\n#ifdef HOST_WORDS_BIGENDIAN\n# define END  _le\n#else\n# define END  _be\n#endif\n\nABI_TYPE ATOMIC_NAME(cmpxchg)(CPUArchState *env, target_ulong addr,\n                              ABI_TYPE cmpv, ABI_TYPE newv EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    return BSWAP(atomic_cmpxchg__nocheck(haddr, BSWAP(cmpv), BSWAP(newv)));\n}\n\n#if DATA_SIZE >= 16\nABI_TYPE ATOMIC_NAME(ld)(CPUArchState *env, target_ulong addr EXTRA_ARGS)\n{\n    DATA_TYPE val, *haddr = ATOMIC_MMU_LOOKUP;\n    __atomic_load(haddr, &val, __ATOMIC_RELAXED);\n    return BSWAP(val);\n}\n\nvoid ATOMIC_NAME(st)(CPUArchState *env, target_ulong addr,\n                     ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    val = BSWAP(val);\n    __atomic_store(haddr, &val, __ATOMIC_RELAXED);\n}\n#else\nABI_TYPE ATOMIC_NAME(xchg)(CPUArchState *env, target_ulong addr,\n                           ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    return BSWAP(atomic_xchg__nocheck(haddr, BSWAP(val)));\n}\n\n#define GEN_ATOMIC_HELPER(X)                                        \\\nABI_TYPE ATOMIC_NAME(X)(CPUArchState *env, target_ulong addr,       \\\n                 ABI_TYPE val EXTRA_ARGS)                           \\\n{                                                                   \\\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;                           \\\n    return BSWAP(atomic_##X(haddr, BSWAP(val)));                    \\\n}\n\nGEN_ATOMIC_HELPER(fetch_and)\nGEN_ATOMIC_HELPER(fetch_or)\nGEN_ATOMIC_HELPER(fetch_xor)\nGEN_ATOMIC_HELPER(and_fetch)\nGEN_ATOMIC_HELPER(or_fetch)\nGEN_ATOMIC_HELPER(xor_fetch)\n\n#undef GEN_ATOMIC_HELPER\n\n/* Note that for addition, we need to use a separate cmpxchg loop instead\n   of bswaps for the reverse-host-endian helpers.  */\nABI_TYPE ATOMIC_NAME(fetch_add)(CPUArchState *env, target_ulong addr,\n                         ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    DATA_TYPE ldo, ldn, ret, sto;\n\n    ldo = atomic_read__nocheck(haddr);\n    while (1) {\n        ret = BSWAP(ldo);\n        sto = BSWAP(ret + val);\n        ldn = atomic_cmpxchg__nocheck(haddr, ldo, sto);\n        if (ldn == ldo) {\n            return ret;\n        }\n        ldo = ldn;\n    }\n}\n\nABI_TYPE ATOMIC_NAME(add_fetch)(CPUArchState *env, target_ulong addr,\n                         ABI_TYPE val EXTRA_ARGS)\n{\n    DATA_TYPE *haddr = ATOMIC_MMU_LOOKUP;\n    DATA_TYPE ldo, ldn, ret, sto;\n\n    ldo = atomic_read__nocheck(haddr);\n    while (1) {\n        ret = BSWAP(ldo) + val;\n        sto = BSWAP(ret);\n        ldn = atomic_cmpxchg__nocheck(haddr, ldo, sto);\n        if (ldn == ldo) {\n            return ret;\n        }\n        ldo = ldn;\n    }\n}\n#endif /* DATA_SIZE >= 16 */\n\n#undef END\n#endif /* DATA_SIZE > 1 */\n\n#undef BSWAP\n#undef ABI_TYPE\n#undef DATA_TYPE\n#undef SUFFIX\n#undef DATA_SIZE\n"
        },
        {
          "name": "audio",
          "type": "tree",
          "content": null
        },
        {
          "name": "backends",
          "type": "tree",
          "content": null
        },
        {
          "name": "balloon.c",
          "type": "blob",
          "size": 3.3505859375,
          "content": "/*\n * Generic Balloon handlers and management\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (C) 2011 Red Hat, Inc.\n * Copyright (C) 2011 Amit Shah <amit.shah@redhat.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"exec/cpu-common.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/balloon.h\"\n#include \"trace-root.h\"\n#include \"qmp-commands.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qjson.h\"\n\nstatic QEMUBalloonEvent *balloon_event_fn;\nstatic QEMUBalloonStatus *balloon_stat_fn;\nstatic void *balloon_opaque;\nstatic bool balloon_inhibited;\n\nbool qemu_balloon_is_inhibited(void)\n{\n    return balloon_inhibited;\n}\n\nvoid qemu_balloon_inhibit(bool state)\n{\n    balloon_inhibited = state;\n}\n\nstatic bool have_balloon(Error **errp)\n{\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n        error_set(errp, ERROR_CLASS_KVM_MISSING_CAP,\n                  \"Using KVM without synchronous MMU, balloon unavailable\");\n        return false;\n    }\n    if (!balloon_event_fn) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n                  \"No balloon device has been activated\");\n        return false;\n    }\n    return true;\n}\n\nint qemu_add_balloon_handler(QEMUBalloonEvent *event_func,\n                             QEMUBalloonStatus *stat_func, void *opaque)\n{\n    if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {\n        /* We're already registered one balloon handler.  How many can\n         * a guest really have?\n         */\n        return -1;\n    }\n    balloon_event_fn = event_func;\n    balloon_stat_fn = stat_func;\n    balloon_opaque = opaque;\n    return 0;\n}\n\nvoid qemu_remove_balloon_handler(void *opaque)\n{\n    if (balloon_opaque != opaque) {\n        return;\n    }\n    balloon_event_fn = NULL;\n    balloon_stat_fn = NULL;\n    balloon_opaque = NULL;\n}\n\nBalloonInfo *qmp_query_balloon(Error **errp)\n{\n    BalloonInfo *info;\n\n    if (!have_balloon(errp)) {\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    balloon_stat_fn(balloon_opaque, info);\n    return info;\n}\n\nvoid qmp_balloon(int64_t target, Error **errp)\n{\n    if (!have_balloon(errp)) {\n        return;\n    }\n\n    if (target <= 0) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"target\", \"a size\");\n        return;\n    }\n\n    trace_balloon_event(balloon_opaque, target);\n    balloon_event_fn(balloon_opaque, target);\n}\n"
        },
        {
          "name": "block.c",
          "type": "blob",
          "size": 137.640625,
          "content": "/*\n * QEMU System Emulator block driver\n *\n * Copyright (c) 2003 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include \"block/trace.h\"\n#include \"block/block_int.h\"\n#include \"block/blockjob.h\"\n#include \"block/nbd.h\"\n#include \"qemu/error-report.h\"\n#include \"module_block.h\"\n#include \"qemu/module.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qbool.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/notify.h\"\n#include \"qemu/coroutine.h\"\n#include \"block/qapi.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/timer.h\"\n#include \"qapi-event.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/id.h\"\n#include \"qapi/util.h\"\n\n#ifdef CONFIG_BSD\n#include <sys/ioctl.h>\n#include <sys/queue.h>\n#ifndef __DragonFly__\n#include <sys/disk.h>\n#endif\n#endif\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\n#define NOT_DONE 0x7fffffff /* used while emulated sync operation in progress */\n\nstatic QTAILQ_HEAD(, BlockDriverState) graph_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(graph_bdrv_states);\n\nstatic QTAILQ_HEAD(, BlockDriverState) all_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(all_bdrv_states);\n\nstatic QLIST_HEAD(, BlockDriver) bdrv_drivers =\n    QLIST_HEAD_INITIALIZER(bdrv_drivers);\n\nstatic BlockDriverState *bdrv_open_inherit(const char *filename,\n                                           const char *reference,\n                                           QDict *options, int flags,\n                                           BlockDriverState *parent,\n                                           const BdrvChildRole *child_role,\n                                           Error **errp);\n\n/* If non-zero, use only whitelisted block drivers */\nstatic int use_bdrv_whitelist;\n\n#ifdef _WIN32\nstatic int is_windows_drive_prefix(const char *filename)\n{\n    return (((filename[0] >= 'a' && filename[0] <= 'z') ||\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n            filename[1] == ':');\n}\n\nint is_windows_drive(const char *filename)\n{\n    if (is_windows_drive_prefix(filename) &&\n        filename[2] == '\\0')\n        return 1;\n    if (strstart(filename, \"\\\\\\\\.\\\\\", NULL) ||\n        strstart(filename, \"//./\", NULL))\n        return 1;\n    return 0;\n}\n#endif\n\nsize_t bdrv_opt_mem_align(BlockDriverState *bs)\n{\n    if (!bs || !bs->drv) {\n        /* page size or 4k (hdd sector size) should be on the safe side */\n        return MAX(4096, getpagesize());\n    }\n\n    return bs->bl.opt_mem_alignment;\n}\n\nsize_t bdrv_min_mem_align(BlockDriverState *bs)\n{\n    if (!bs || !bs->drv) {\n        /* page size or 4k (hdd sector size) should be on the safe side */\n        return MAX(4096, getpagesize());\n    }\n\n    return bs->bl.min_mem_alignment;\n}\n\n/* check if the path starts with \"<protocol>:\" */\nint path_has_protocol(const char *path)\n{\n    const char *p;\n\n#ifdef _WIN32\n    if (is_windows_drive(path) ||\n        is_windows_drive_prefix(path)) {\n        return 0;\n    }\n    p = path + strcspn(path, \":/\\\\\");\n#else\n    p = path + strcspn(path, \":/\");\n#endif\n\n    return *p == ':';\n}\n\nint path_is_absolute(const char *path)\n{\n#ifdef _WIN32\n    /* specific case for names like: \"\\\\.\\d:\" */\n    if (is_windows_drive(path) || is_windows_drive_prefix(path)) {\n        return 1;\n    }\n    return (*path == '/' || *path == '\\\\');\n#else\n    return (*path == '/');\n#endif\n}\n\n/* if filename is absolute, just copy it to dest. Otherwise, build a\n   path to it by considering it is relative to base_path. URL are\n   supported. */\nvoid path_combine(char *dest, int dest_size,\n                  const char *base_path,\n                  const char *filename)\n{\n    const char *p, *p1;\n    int len;\n\n    if (dest_size <= 0)\n        return;\n    if (path_is_absolute(filename)) {\n        pstrcpy(dest, dest_size, filename);\n    } else {\n        p = strchr(base_path, ':');\n        if (p)\n            p++;\n        else\n            p = base_path;\n        p1 = strrchr(base_path, '/');\n#ifdef _WIN32\n        {\n            const char *p2;\n            p2 = strrchr(base_path, '\\\\');\n            if (!p1 || p2 > p1)\n                p1 = p2;\n        }\n#endif\n        if (p1)\n            p1++;\n        else\n            p1 = base_path;\n        if (p1 > p)\n            p = p1;\n        len = p - base_path;\n        if (len > dest_size - 1)\n            len = dest_size - 1;\n        memcpy(dest, base_path, len);\n        dest[len] = '\\0';\n        pstrcat(dest, dest_size, filename);\n    }\n}\n\nvoid bdrv_get_full_backing_filename_from_filename(const char *backed,\n                                                  const char *backing,\n                                                  char *dest, size_t sz,\n                                                  Error **errp)\n{\n    if (backing[0] == '\\0' || path_has_protocol(backing) ||\n        path_is_absolute(backing))\n    {\n        pstrcpy(dest, sz, backing);\n    } else if (backed[0] == '\\0' || strstart(backed, \"json:\", NULL)) {\n        error_setg(errp, \"Cannot use relative backing file names for '%s'\",\n                   backed);\n    } else {\n        path_combine(dest, sz, backed, backing);\n    }\n}\n\nvoid bdrv_get_full_backing_filename(BlockDriverState *bs, char *dest, size_t sz,\n                                    Error **errp)\n{\n    char *backed = bs->exact_filename[0] ? bs->exact_filename : bs->filename;\n\n    bdrv_get_full_backing_filename_from_filename(backed, bs->backing_file,\n                                                 dest, sz, errp);\n}\n\nvoid bdrv_register(BlockDriver *bdrv)\n{\n    QLIST_INSERT_HEAD(&bdrv_drivers, bdrv, list);\n}\n\nBlockDriverState *bdrv_new(void)\n{\n    BlockDriverState *bs;\n    int i;\n\n    bs = g_new0(BlockDriverState, 1);\n    QLIST_INIT(&bs->dirty_bitmaps);\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        QLIST_INIT(&bs->op_blockers[i]);\n    }\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n    bs->refcnt = 1;\n    bs->aio_context = qemu_get_aio_context();\n\n    qemu_co_queue_init(&bs->flush_queue);\n\n    QTAILQ_INSERT_TAIL(&all_bdrv_states, bs, bs_list);\n\n    return bs;\n}\n\nstatic BlockDriver *bdrv_do_find_format(const char *format_name)\n{\n    BlockDriver *drv1;\n\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (!strcmp(drv1->format_name, format_name)) {\n            return drv1;\n        }\n    }\n\n    return NULL;\n}\n\nBlockDriver *bdrv_find_format(const char *format_name)\n{\n    BlockDriver *drv1;\n    int i;\n\n    drv1 = bdrv_do_find_format(format_name);\n    if (drv1) {\n        return drv1;\n    }\n\n    /* The driver isn't registered, maybe we need to load a module */\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); ++i) {\n        if (!strcmp(block_driver_modules[i].format_name, format_name)) {\n            block_module_load_one(block_driver_modules[i].library_name);\n            break;\n        }\n    }\n\n    return bdrv_do_find_format(format_name);\n}\n\nstatic int bdrv_is_whitelisted(BlockDriver *drv, bool read_only)\n{\n    static const char *whitelist_rw[] = {\n        CONFIG_BDRV_RW_WHITELIST\n    };\n    static const char *whitelist_ro[] = {\n        CONFIG_BDRV_RO_WHITELIST\n    };\n    const char **p;\n\n    if (!whitelist_rw[0] && !whitelist_ro[0]) {\n        return 1;               /* no whitelist, anything goes */\n    }\n\n    for (p = whitelist_rw; *p; p++) {\n        if (!strcmp(drv->format_name, *p)) {\n            return 1;\n        }\n    }\n    if (read_only) {\n        for (p = whitelist_ro; *p; p++) {\n            if (!strcmp(drv->format_name, *p)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool bdrv_uses_whitelist(void)\n{\n    return use_bdrv_whitelist;\n}\n\ntypedef struct CreateCo {\n    BlockDriver *drv;\n    char *filename;\n    QemuOpts *opts;\n    int ret;\n    Error *err;\n} CreateCo;\n\nstatic void coroutine_fn bdrv_create_co_entry(void *opaque)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    CreateCo *cco = opaque;\n    assert(cco->drv);\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n    error_propagate(&cco->err, local_err);\n    cco->ret = ret;\n}\n\nint bdrv_create(BlockDriver *drv, const char* filename,\n                QemuOpts *opts, Error **errp)\n{\n    int ret;\n\n    Coroutine *co;\n    CreateCo cco = {\n        .drv = drv,\n        .filename = g_strdup(filename),\n        .opts = opts,\n        .ret = NOT_DONE,\n        .err = NULL,\n    };\n\n    if (!drv->bdrv_create) {\n        error_setg(errp, \"Driver '%s' does not support image creation\", drv->format_name);\n        ret = -ENOTSUP;\n        goto out;\n    }\n\n    if (qemu_in_coroutine()) {\n        /* Fast-path if already in coroutine context */\n        bdrv_create_co_entry(&cco);\n    } else {\n        co = qemu_coroutine_create(bdrv_create_co_entry, &cco);\n        qemu_coroutine_enter(co);\n        while (cco.ret == NOT_DONE) {\n            aio_poll(qemu_get_aio_context(), true);\n        }\n    }\n\n    ret = cco.ret;\n    if (ret < 0) {\n        if (cco.err) {\n            error_propagate(errp, cco.err);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not create image\");\n        }\n    }\n\nout:\n    g_free(cco.filename);\n    return ret;\n}\n\nint bdrv_create_file(const char *filename, QemuOpts *opts, Error **errp)\n{\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    int ret;\n\n    drv = bdrv_find_protocol(filename, true, errp);\n    if (drv == NULL) {\n        return -ENOENT;\n    }\n\n    ret = bdrv_create(drv, filename, opts, &local_err);\n    error_propagate(errp, local_err);\n    return ret;\n}\n\n/**\n * Try to get @bs's logical and physical block size.\n * On success, store them in @bsz struct and return 0.\n * On failure return -errno.\n * @bs must not be empty.\n */\nint bdrv_probe_blocksizes(BlockDriverState *bs, BlockSizes *bsz)\n{\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_probe_blocksizes) {\n        return drv->bdrv_probe_blocksizes(bs, bsz);\n    }\n\n    return -ENOTSUP;\n}\n\n/**\n * Try to get @bs's geometry (cyls, heads, sectors).\n * On success, store them in @geo struct and return 0.\n * On failure return -errno.\n * @bs must not be empty.\n */\nint bdrv_probe_geometry(BlockDriverState *bs, HDGeometry *geo)\n{\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_probe_geometry) {\n        return drv->bdrv_probe_geometry(bs, geo);\n    }\n\n    return -ENOTSUP;\n}\n\n/*\n * Create a uniquely-named empty temporary file.\n * Return 0 upon success, otherwise a negative errno value.\n */\nint get_tmp_filename(char *filename, int size)\n{\n#ifdef _WIN32\n    char temp_dir[MAX_PATH];\n    /* GetTempFileName requires that its output buffer (4th param)\n       have length MAX_PATH or greater.  */\n    assert(size >= MAX_PATH);\n    return (GetTempPath(MAX_PATH, temp_dir)\n            && GetTempFileName(temp_dir, \"qem\", 0, filename)\n            ? 0 : -GetLastError());\n#else\n    int fd;\n    const char *tmpdir;\n    tmpdir = getenv(\"TMPDIR\");\n    if (!tmpdir) {\n        tmpdir = \"/var/tmp\";\n    }\n    if (snprintf(filename, size, \"%s/vl.XXXXXX\", tmpdir) >= size) {\n        return -EOVERFLOW;\n    }\n    fd = mkstemp(filename);\n    if (fd < 0) {\n        return -errno;\n    }\n    if (close(fd) != 0) {\n        unlink(filename);\n        return -errno;\n    }\n    return 0;\n#endif\n}\n\n/*\n * Detect host devices. By convention, /dev/cdrom[N] is always\n * recognized as a host CDROM.\n */\nstatic BlockDriver *find_hdev_driver(const char *filename)\n{\n    int score_max = 0, score;\n    BlockDriver *drv = NULL, *d;\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n        if (d->bdrv_probe_device) {\n            score = d->bdrv_probe_device(filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = d;\n            }\n        }\n    }\n\n    return drv;\n}\n\nstatic BlockDriver *bdrv_do_find_protocol(const char *protocol)\n{\n    BlockDriver *drv1;\n\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (drv1->protocol_name && !strcmp(drv1->protocol_name, protocol)) {\n            return drv1;\n        }\n    }\n\n    return NULL;\n}\n\nBlockDriver *bdrv_find_protocol(const char *filename,\n                                bool allow_protocol_prefix,\n                                Error **errp)\n{\n    BlockDriver *drv1;\n    char protocol[128];\n    int len;\n    const char *p;\n    int i;\n\n    /* TODO Drivers without bdrv_file_open must be specified explicitly */\n\n    /*\n     * XXX(hch): we really should not let host device detection\n     * override an explicit protocol specification, but moving this\n     * later breaks access to device names with colons in them.\n     * Thanks to the brain-dead persistent naming schemes on udev-\n     * based Linux systems those actually are quite common.\n     */\n    drv1 = find_hdev_driver(filename);\n    if (drv1) {\n        return drv1;\n    }\n\n    if (!path_has_protocol(filename) || !allow_protocol_prefix) {\n        return &bdrv_file;\n    }\n\n    p = strchr(filename, ':');\n    assert(p != NULL);\n    len = p - filename;\n    if (len > sizeof(protocol) - 1)\n        len = sizeof(protocol) - 1;\n    memcpy(protocol, filename, len);\n    protocol[len] = '\\0';\n\n    drv1 = bdrv_do_find_protocol(protocol);\n    if (drv1) {\n        return drv1;\n    }\n\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); ++i) {\n        if (block_driver_modules[i].protocol_name &&\n            !strcmp(block_driver_modules[i].protocol_name, protocol)) {\n            block_module_load_one(block_driver_modules[i].library_name);\n            break;\n        }\n    }\n\n    drv1 = bdrv_do_find_protocol(protocol);\n    if (!drv1) {\n        error_setg(errp, \"Unknown protocol '%s'\", protocol);\n    }\n    return drv1;\n}\n\n/*\n * Guess image format by probing its contents.\n * This is not a good idea when your image is raw (CVE-2008-2004), but\n * we do it anyway for backward compatibility.\n *\n * @buf         contains the image's first @buf_size bytes.\n * @buf_size    is the buffer size in bytes (generally BLOCK_PROBE_BUF_SIZE,\n *              but can be smaller if the image file is smaller)\n * @filename    is its filename.\n *\n * For all block drivers, call the bdrv_probe() method to get its\n * probing score.\n * Return the first block driver with the highest probing score.\n */\nBlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,\n                            const char *filename)\n{\n    int score_max = 0, score;\n    BlockDriver *drv = NULL, *d;\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n        if (d->bdrv_probe) {\n            score = d->bdrv_probe(buf, buf_size, filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = d;\n            }\n        }\n    }\n\n    return drv;\n}\n\nstatic int find_image_format(BlockBackend *file, const char *filename,\n                             BlockDriver **pdrv, Error **errp)\n{\n    BlockDriver *drv;\n    uint8_t buf[BLOCK_PROBE_BUF_SIZE];\n    int ret = 0;\n\n    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */\n    if (blk_is_sg(file) || !blk_is_inserted(file) || blk_getlength(file) == 0) {\n        *pdrv = &bdrv_raw;\n        return ret;\n    }\n\n    ret = blk_pread(file, 0, buf, sizeof(buf));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n                         \"format\");\n        *pdrv = NULL;\n        return ret;\n    }\n\n    drv = bdrv_probe_all(buf, ret, filename);\n    if (!drv) {\n        error_setg(errp, \"Could not determine image format: No compatible \"\n                   \"driver found\");\n        ret = -ENOENT;\n    }\n    *pdrv = drv;\n    return ret;\n}\n\n/**\n * Set the current 'total_sectors' value\n * Return 0 on success, -errno on error.\n */\nstatic int refresh_total_sectors(BlockDriverState *bs, int64_t hint)\n{\n    BlockDriver *drv = bs->drv;\n\n    /* Do not attempt drv->bdrv_getlength() on scsi-generic devices */\n    if (bdrv_is_sg(bs))\n        return 0;\n\n    /* query actual device if possible, otherwise just trust the hint */\n    if (drv->bdrv_getlength) {\n        int64_t length = drv->bdrv_getlength(bs);\n        if (length < 0) {\n            return length;\n        }\n        hint = DIV_ROUND_UP(length, BDRV_SECTOR_SIZE);\n    }\n\n    bs->total_sectors = hint;\n    return 0;\n}\n\n/**\n * Combines a QDict of new block driver @options with any missing options taken\n * from @old_options, so that leaving out an option defaults to its old value.\n */\nstatic void bdrv_join_options(BlockDriverState *bs, QDict *options,\n                              QDict *old_options)\n{\n    if (bs->drv && bs->drv->bdrv_join_options) {\n        bs->drv->bdrv_join_options(options, old_options);\n    } else {\n        qdict_join(options, old_options, false);\n    }\n}\n\n/**\n * Set open flags for a given discard mode\n *\n * Return 0 on success, -1 if the discard mode was invalid.\n */\nint bdrv_parse_discard_flags(const char *mode, int *flags)\n{\n    *flags &= ~BDRV_O_UNMAP;\n\n    if (!strcmp(mode, \"off\") || !strcmp(mode, \"ignore\")) {\n        /* do nothing */\n    } else if (!strcmp(mode, \"on\") || !strcmp(mode, \"unmap\")) {\n        *flags |= BDRV_O_UNMAP;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * Set open flags for a given cache mode\n *\n * Return 0 on success, -1 if the cache mode was invalid.\n */\nint bdrv_parse_cache_mode(const char *mode, int *flags, bool *writethrough)\n{\n    *flags &= ~BDRV_O_CACHE_MASK;\n\n    if (!strcmp(mode, \"off\") || !strcmp(mode, \"none\")) {\n        *writethrough = false;\n        *flags |= BDRV_O_NOCACHE;\n    } else if (!strcmp(mode, \"directsync\")) {\n        *writethrough = true;\n        *flags |= BDRV_O_NOCACHE;\n    } else if (!strcmp(mode, \"writeback\")) {\n        *writethrough = false;\n    } else if (!strcmp(mode, \"unsafe\")) {\n        *writethrough = false;\n        *flags |= BDRV_O_NO_FLUSH;\n    } else if (!strcmp(mode, \"writethrough\")) {\n        *writethrough = true;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic char *bdrv_child_get_parent_desc(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n    return g_strdup(bdrv_get_device_or_node_name(parent));\n}\n\nstatic void bdrv_child_cb_drained_begin(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n    bdrv_drained_begin(bs);\n}\n\nstatic void bdrv_child_cb_drained_end(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n    bdrv_drained_end(bs);\n}\n\n/*\n * Returns the options and flags that a temporary snapshot should get, based on\n * the originally requested flags (the originally requested image will have\n * flags like a backing file)\n */\nstatic void bdrv_temp_snapshot_options(int *child_flags, QDict *child_options,\n                                       int parent_flags, QDict *parent_options)\n{\n    *child_flags = (parent_flags & ~BDRV_O_SNAPSHOT) | BDRV_O_TEMPORARY;\n\n    /* For temporary files, unconditional cache=unsafe is fine */\n    qdict_set_default_str(child_options, BDRV_OPT_CACHE_DIRECT, \"off\");\n    qdict_set_default_str(child_options, BDRV_OPT_CACHE_NO_FLUSH, \"on\");\n\n    /* Copy the read-only option from the parent */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_READ_ONLY);\n\n    /* aio=native doesn't work for cache.direct=off, so disable it for the\n     * temporary snapshot */\n    *child_flags &= ~BDRV_O_NATIVE_AIO;\n}\n\n/*\n * Returns the options and flags that bs->file should get if a protocol driver\n * is expected, based on the given options and flags for the parent BDS\n */\nstatic void bdrv_inherited_options(int *child_flags, QDict *child_options,\n                                   int parent_flags, QDict *parent_options)\n{\n    int flags = parent_flags;\n\n    /* Enable protocol handling, disable format probing for bs->file */\n    flags |= BDRV_O_PROTOCOL;\n\n    /* If the cache mode isn't explicitly set, inherit direct and no-flush from\n     * the parent. */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_DIRECT);\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_NO_FLUSH);\n\n    /* Inherit the read-only option from the parent if it's not set */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_READ_ONLY);\n\n    /* Our block drivers take care to send flushes and respect unmap policy,\n     * so we can default to enable both on lower layers regardless of the\n     * corresponding parent options. */\n    qdict_set_default_str(child_options, BDRV_OPT_DISCARD, \"unmap\");\n\n    /* Clear flags that only apply to the top layer */\n    flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_COPY_ON_READ |\n               BDRV_O_NO_IO);\n\n    *child_flags = flags;\n}\n\nconst BdrvChildRole child_file = {\n    .get_parent_desc = bdrv_child_get_parent_desc,\n    .inherit_options = bdrv_inherited_options,\n    .drained_begin   = bdrv_child_cb_drained_begin,\n    .drained_end     = bdrv_child_cb_drained_end,\n};\n\n/*\n * Returns the options and flags that bs->file should get if the use of formats\n * (and not only protocols) is permitted for it, based on the given options and\n * flags for the parent BDS\n */\nstatic void bdrv_inherited_fmt_options(int *child_flags, QDict *child_options,\n                                       int parent_flags, QDict *parent_options)\n{\n    child_file.inherit_options(child_flags, child_options,\n                               parent_flags, parent_options);\n\n    *child_flags &= ~(BDRV_O_PROTOCOL | BDRV_O_NO_IO);\n}\n\nconst BdrvChildRole child_format = {\n    .get_parent_desc = bdrv_child_get_parent_desc,\n    .inherit_options = bdrv_inherited_fmt_options,\n    .drained_begin   = bdrv_child_cb_drained_begin,\n    .drained_end     = bdrv_child_cb_drained_end,\n};\n\nstatic void bdrv_backing_attach(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n    BlockDriverState *backing_hd = c->bs;\n\n    assert(!parent->backing_blocker);\n    error_setg(&parent->backing_blocker,\n               \"node is used as backing hd of '%s'\",\n               bdrv_get_device_or_node_name(parent));\n\n    parent->open_flags &= ~BDRV_O_NO_BACKING;\n    pstrcpy(parent->backing_file, sizeof(parent->backing_file),\n            backing_hd->filename);\n    pstrcpy(parent->backing_format, sizeof(parent->backing_format),\n            backing_hd->drv ? backing_hd->drv->format_name : \"\");\n\n    bdrv_op_block_all(backing_hd, parent->backing_blocker);\n    /* Otherwise we won't be able to commit or stream */\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_COMMIT_TARGET,\n                    parent->backing_blocker);\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_STREAM,\n                    parent->backing_blocker);\n    /*\n     * We do backup in 3 ways:\n     * 1. drive backup\n     *    The target bs is new opened, and the source is top BDS\n     * 2. blockdev backup\n     *    Both the source and the target are top BDSes.\n     * 3. internal backup(used for block replication)\n     *    Both the source and the target are backing file\n     *\n     * In case 1 and 2, neither the source nor the target is the backing file.\n     * In case 3, we will block the top BDS, so there is only one block job\n     * for the top BDS and its backing chain.\n     */\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_BACKUP_SOURCE,\n                    parent->backing_blocker);\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_BACKUP_TARGET,\n                    parent->backing_blocker);\n}\n\nstatic void bdrv_backing_detach(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n\n    assert(parent->backing_blocker);\n    bdrv_op_unblock_all(c->bs, parent->backing_blocker);\n    error_free(parent->backing_blocker);\n    parent->backing_blocker = NULL;\n}\n\n/*\n * Returns the options and flags that bs->backing should get, based on the\n * given options and flags for the parent BDS\n */\nstatic void bdrv_backing_options(int *child_flags, QDict *child_options,\n                                 int parent_flags, QDict *parent_options)\n{\n    int flags = parent_flags;\n\n    /* The cache mode is inherited unmodified for backing files; except WCE,\n     * which is only applied on the top level (BlockBackend) */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_DIRECT);\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_NO_FLUSH);\n\n    /* backing files always opened read-only */\n    qdict_set_default_str(child_options, BDRV_OPT_READ_ONLY, \"on\");\n    flags &= ~BDRV_O_COPY_ON_READ;\n\n    /* snapshot=on is handled on the top layer */\n    flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_TEMPORARY);\n\n    *child_flags = flags;\n}\n\nconst BdrvChildRole child_backing = {\n    .get_parent_desc = bdrv_child_get_parent_desc,\n    .attach          = bdrv_backing_attach,\n    .detach          = bdrv_backing_detach,\n    .inherit_options = bdrv_backing_options,\n    .drained_begin   = bdrv_child_cb_drained_begin,\n    .drained_end     = bdrv_child_cb_drained_end,\n};\n\nstatic int bdrv_open_flags(BlockDriverState *bs, int flags)\n{\n    int open_flags = flags;\n\n    /*\n     * Clear flags that are internal to the block layer before opening the\n     * image.\n     */\n    open_flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_PROTOCOL);\n\n    /*\n     * Snapshots should be writable.\n     */\n    if (flags & BDRV_O_TEMPORARY) {\n        open_flags |= BDRV_O_RDWR;\n    }\n\n    return open_flags;\n}\n\nstatic void update_flags_from_options(int *flags, QemuOpts *opts)\n{\n    *flags &= ~BDRV_O_CACHE_MASK;\n\n    assert(qemu_opt_find(opts, BDRV_OPT_CACHE_NO_FLUSH));\n    if (qemu_opt_get_bool(opts, BDRV_OPT_CACHE_NO_FLUSH, false)) {\n        *flags |= BDRV_O_NO_FLUSH;\n    }\n\n    assert(qemu_opt_find(opts, BDRV_OPT_CACHE_DIRECT));\n    if (qemu_opt_get_bool(opts, BDRV_OPT_CACHE_DIRECT, false)) {\n        *flags |= BDRV_O_NOCACHE;\n    }\n\n    *flags &= ~BDRV_O_RDWR;\n\n    assert(qemu_opt_find(opts, BDRV_OPT_READ_ONLY));\n    if (!qemu_opt_get_bool(opts, BDRV_OPT_READ_ONLY, false)) {\n        *flags |= BDRV_O_RDWR;\n    }\n\n}\n\nstatic void update_options_from_flags(QDict *options, int flags)\n{\n    if (!qdict_haskey(options, BDRV_OPT_CACHE_DIRECT)) {\n        qdict_put_bool(options, BDRV_OPT_CACHE_DIRECT, flags & BDRV_O_NOCACHE);\n    }\n    if (!qdict_haskey(options, BDRV_OPT_CACHE_NO_FLUSH)) {\n        qdict_put_bool(options, BDRV_OPT_CACHE_NO_FLUSH,\n                       flags & BDRV_O_NO_FLUSH);\n    }\n    if (!qdict_haskey(options, BDRV_OPT_READ_ONLY)) {\n        qdict_put_bool(options, BDRV_OPT_READ_ONLY, !(flags & BDRV_O_RDWR));\n    }\n}\n\nstatic void bdrv_assign_node_name(BlockDriverState *bs,\n                                  const char *node_name,\n                                  Error **errp)\n{\n    char *gen_node_name = NULL;\n\n    if (!node_name) {\n        node_name = gen_node_name = id_generate(ID_BLOCK);\n    } else if (!id_wellformed(node_name)) {\n        /*\n         * Check for empty string or invalid characters, but not if it is\n         * generated (generated names use characters not available to the user)\n         */\n        error_setg(errp, \"Invalid node name\");\n        return;\n    }\n\n    /* takes care of avoiding namespaces collisions */\n    if (blk_by_name(node_name)) {\n        error_setg(errp, \"node-name=%s is conflicting with a device id\",\n                   node_name);\n        goto out;\n    }\n\n    /* takes care of avoiding duplicates node names */\n    if (bdrv_find_node(node_name)) {\n        error_setg(errp, \"Duplicate node name\");\n        goto out;\n    }\n\n    /* copy node name into the bs and insert it into the graph list */\n    pstrcpy(bs->node_name, sizeof(bs->node_name), node_name);\n    QTAILQ_INSERT_TAIL(&graph_bdrv_states, bs, node_list);\nout:\n    g_free(gen_node_name);\n}\n\nstatic int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,\n                            const char *node_name, QDict *options,\n                            int open_flags, Error **errp)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    bdrv_assign_node_name(bs, node_name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return -EINVAL;\n    }\n\n    bs->drv = drv;\n    bs->read_only = !(bs->open_flags & BDRV_O_RDWR);\n    bs->opaque = g_malloc0(drv->instance_size);\n\n    if (drv->bdrv_file_open) {\n        assert(!drv->bdrv_needs_filename || bs->filename[0]);\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n    } else if (drv->bdrv_open) {\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n    } else {\n        ret = 0;\n    }\n\n    if (ret < 0) {\n        if (local_err) {\n            error_propagate(errp, local_err);\n        } else if (bs->filename[0]) {\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not open image\");\n        }\n        goto free_and_fail;\n    }\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n        goto free_and_fail;\n    }\n\n    bdrv_refresh_limits(bs, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto free_and_fail;\n    }\n\n    assert(bdrv_opt_mem_align(bs) != 0);\n    assert(bdrv_min_mem_align(bs) != 0);\n    assert(is_power_of_2(bs->bl.request_alignment));\n\n    return 0;\n\nfree_and_fail:\n    /* FIXME Close bs first if already opened*/\n    g_free(bs->opaque);\n    bs->opaque = NULL;\n    bs->drv = NULL;\n    return ret;\n}\n\nBlockDriverState *bdrv_new_open_driver(BlockDriver *drv, const char *node_name,\n                                       int flags, Error **errp)\n{\n    BlockDriverState *bs;\n    int ret;\n\n    bs = bdrv_new();\n    bs->open_flags = flags;\n    bs->explicit_options = qdict_new();\n    bs->options = qdict_new();\n    bs->opaque = NULL;\n\n    update_options_from_flags(bs->options, flags);\n\n    ret = bdrv_open_driver(bs, drv, node_name, bs->options, flags, errp);\n    if (ret < 0) {\n        QDECREF(bs->explicit_options);\n        QDECREF(bs->options);\n        bdrv_unref(bs);\n        return NULL;\n    }\n\n    return bs;\n}\n\nQemuOptsList bdrv_runtime_opts = {\n    .name = \"bdrv_common\",\n    .head = QTAILQ_HEAD_INITIALIZER(bdrv_runtime_opts.head),\n    .desc = {\n        {\n            .name = \"node-name\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Node name of the block device node\",\n        },\n        {\n            .name = \"driver\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Block driver to use for the node\",\n        },\n        {\n            .name = BDRV_OPT_CACHE_DIRECT,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Bypass software writeback cache on the host\",\n        },\n        {\n            .name = BDRV_OPT_CACHE_NO_FLUSH,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Ignore flush requests\",\n        },\n        {\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Node is opened in read-only mode\",\n        },\n        {\n            .name = \"detect-zeroes\",\n            .type = QEMU_OPT_STRING,\n            .help = \"try to optimize zero writes (off, on, unmap)\",\n        },\n        {\n            .name = \"discard\",\n            .type = QEMU_OPT_STRING,\n            .help = \"discard operation (ignore/off, unmap/on)\",\n        },\n        { /* end of list */ }\n    },\n};\n\n/*\n * Common part for opening disk images and files\n *\n * Removes all processed options from *options.\n */\nstatic int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,\n                            QDict *options, Error **errp)\n{\n    int ret, open_flags;\n    const char *filename;\n    const char *driver_name = NULL;\n    const char *node_name = NULL;\n    const char *discard;\n    const char *detect_zeroes;\n    QemuOpts *opts;\n    BlockDriver *drv;\n    Error *local_err = NULL;\n\n    assert(bs->file == NULL);\n    assert(options != NULL && bs->options != options);\n\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    update_flags_from_options(&bs->open_flags, opts);\n\n    driver_name = qemu_opt_get(opts, \"driver\");\n    drv = bdrv_find_format(driver_name);\n    assert(drv != NULL);\n\n    if (file != NULL) {\n        filename = blk_bs(file)->filename;\n    } else {\n        /*\n         * Caution: while qdict_get_try_str() is fine, getting\n         * non-string types would require more care.  When @options\n         * come from -blockdev or blockdev_add, its members are typed\n         * according to the QAPI schema, but when they come from\n         * -drive, they're all QString.\n         */\n        filename = qdict_get_try_str(options, \"filename\");\n    }\n\n    if (drv->bdrv_needs_filename && (!filename || !filename[0])) {\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n                   drv->format_name);\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    trace_bdrv_open_common(bs, filename ?: \"\", bs->open_flags,\n                           drv->format_name);\n\n    bs->read_only = !(bs->open_flags & BDRV_O_RDWR);\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, bs->read_only)) {\n        error_setg(errp,\n                   !bs->read_only && bdrv_is_whitelisted(drv, true)\n                        ? \"Driver '%s' can only be used for read-only devices\"\n                        : \"Driver '%s' is not whitelisted\",\n                   drv->format_name);\n        ret = -ENOTSUP;\n        goto fail_opts;\n    }\n\n    assert(bs->copy_on_read == 0); /* bdrv_new() and bdrv_close() make it so */\n    if (bs->open_flags & BDRV_O_COPY_ON_READ) {\n        if (!bs->read_only) {\n            bdrv_enable_copy_on_read(bs);\n        } else {\n            error_setg(errp, \"Can't use copy-on-read on read-only device\");\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n    }\n\n    discard = qemu_opt_get(opts, \"discard\");\n    if (discard != NULL) {\n        if (bdrv_parse_discard_flags(discard, &bs->open_flags) != 0) {\n            error_setg(errp, \"Invalid discard option\");\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n    }\n\n    detect_zeroes = qemu_opt_get(opts, \"detect-zeroes\");\n    if (detect_zeroes) {\n        BlockdevDetectZeroesOptions value =\n            qapi_enum_parse(BlockdevDetectZeroesOptions_lookup,\n                            detect_zeroes,\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX,\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n                            &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n\n        if (value == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n            !(bs->open_flags & BDRV_O_UNMAP))\n        {\n            error_setg(errp, \"setting detect-zeroes to unmap is not allowed \"\n                             \"without setting discard operation to unmap\");\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n\n        bs->detect_zeroes = value;\n    }\n\n    if (filename != NULL) {\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n    } else {\n        bs->filename[0] = '\\0';\n    }\n    pstrcpy(bs->exact_filename, sizeof(bs->exact_filename), bs->filename);\n\n    /* Open the image, either directly or using a protocol */\n    open_flags = bdrv_open_flags(bs, bs->open_flags);\n    node_name = qemu_opt_get(opts, \"node-name\");\n\n    assert(!drv->bdrv_file_open || file == NULL);\n    ret = bdrv_open_driver(bs, drv, node_name, options, open_flags, errp);\n    if (ret < 0) {\n        goto fail_opts;\n    }\n\n    qemu_opts_del(opts);\n    return 0;\n\nfail_opts:\n    qemu_opts_del(opts);\n    return ret;\n}\n\nstatic QDict *parse_json_filename(const char *filename, Error **errp)\n{\n    QObject *options_obj;\n    QDict *options;\n    int ret;\n\n    ret = strstart(filename, \"json:\", &filename);\n    assert(ret);\n\n    options_obj = qobject_from_json(filename, errp);\n    if (!options_obj) {\n        /* Work around qobject_from_json() lossage TODO fix that */\n        if (errp && !*errp) {\n            error_setg(errp, \"Could not parse the JSON options\");\n            return NULL;\n        }\n        error_prepend(errp, \"Could not parse the JSON options: \");\n        return NULL;\n    }\n\n    options = qobject_to_qdict(options_obj);\n    if (!options) {\n        qobject_decref(options_obj);\n        error_setg(errp, \"Invalid JSON object given\");\n        return NULL;\n    }\n\n    qdict_flatten(options);\n\n    return options;\n}\n\nstatic void parse_json_protocol(QDict *options, const char **pfilename,\n                                Error **errp)\n{\n    QDict *json_options;\n    Error *local_err = NULL;\n\n    /* Parse json: pseudo-protocol */\n    if (!*pfilename || !g_str_has_prefix(*pfilename, \"json:\")) {\n        return;\n    }\n\n    json_options = parse_json_filename(*pfilename, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    /* Options given in the filename have lower priority than options\n     * specified directly */\n    qdict_join(options, json_options, false);\n    QDECREF(json_options);\n    *pfilename = NULL;\n}\n\n/*\n * Fills in default options for opening images and converts the legacy\n * filename/flags pair to option QDict entries.\n * The BDRV_O_PROTOCOL flag in *flags will be set or cleared accordingly if a\n * block driver has been specified explicitly.\n */\nstatic int bdrv_fill_options(QDict **options, const char *filename,\n                             int *flags, Error **errp)\n{\n    const char *drvname;\n    bool protocol = *flags & BDRV_O_PROTOCOL;\n    bool parse_filename = false;\n    BlockDriver *drv = NULL;\n    Error *local_err = NULL;\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    drvname = qdict_get_try_str(*options, \"driver\");\n    if (drvname) {\n        drv = bdrv_find_format(drvname);\n        if (!drv) {\n            error_setg(errp, \"Unknown driver '%s'\", drvname);\n            return -ENOENT;\n        }\n        /* If the user has explicitly specified the driver, this choice should\n         * override the BDRV_O_PROTOCOL flag */\n        protocol = drv->bdrv_file_open;\n    }\n\n    if (protocol) {\n        *flags |= BDRV_O_PROTOCOL;\n    } else {\n        *flags &= ~BDRV_O_PROTOCOL;\n    }\n\n    /* Translate cache options from flags into options */\n    update_options_from_flags(*options, *flags);\n\n    /* Fetch the file name from the options QDict if necessary */\n    if (protocol && filename) {\n        if (!qdict_haskey(*options, \"filename\")) {\n            qdict_put_str(*options, \"filename\", filename);\n            parse_filename = true;\n        } else {\n            error_setg(errp, \"Can't specify 'file' and 'filename' options at \"\n                             \"the same time\");\n            return -EINVAL;\n        }\n    }\n\n    /* Find the right block driver */\n    /* See cautionary note on accessing @options above */\n    filename = qdict_get_try_str(*options, \"filename\");\n\n    if (!drvname && protocol) {\n        if (filename) {\n            drv = bdrv_find_protocol(filename, parse_filename, errp);\n            if (!drv) {\n                return -EINVAL;\n            }\n\n            drvname = drv->format_name;\n            qdict_put_str(*options, \"driver\", drvname);\n        } else {\n            error_setg(errp, \"Must specify either driver or file\");\n            return -EINVAL;\n        }\n    }\n\n    assert(drv || !protocol);\n\n    /* Driver-specific filename parsing */\n    if (drv && drv->bdrv_parse_filename && parse_filename) {\n        drv->bdrv_parse_filename(filename, *options, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return -EINVAL;\n        }\n\n        if (!drv->bdrv_needs_filename) {\n            qdict_del(*options, \"filename\");\n        }\n    }\n\n    return 0;\n}\n\nstatic int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n                                 GSList *ignore_children, Error **errp);\nstatic void bdrv_child_abort_perm_update(BdrvChild *c);\nstatic void bdrv_child_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared);\n\n/*\n * Check whether permissions on this node can be changed in a way that\n * @cumulative_perms and @cumulative_shared_perms are the new cumulative\n * permissions of all its parents. This involves checking whether all necessary\n * permission changes to child nodes can be performed.\n *\n * A call to this function must always be followed by a call to bdrv_set_perm()\n * or bdrv_abort_perm_update().\n */\nstatic int bdrv_check_perm(BlockDriverState *bs, uint64_t cumulative_perms,\n                           uint64_t cumulative_shared_perms,\n                           GSList *ignore_children, Error **errp)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *c;\n    int ret;\n\n    /* Write permissions never work with read-only images */\n    if ((cumulative_perms & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)) &&\n        bdrv_is_read_only(bs))\n    {\n        error_setg(errp, \"Block node is read-only\");\n        return -EPERM;\n    }\n\n    /* Check this node */\n    if (!drv) {\n        return 0;\n    }\n\n    if (drv->bdrv_check_perm) {\n        return drv->bdrv_check_perm(bs, cumulative_perms,\n                                    cumulative_shared_perms, errp);\n    }\n\n    /* Drivers that never have children can omit .bdrv_child_perm() */\n    if (!drv->bdrv_child_perm) {\n        assert(QLIST_EMPTY(&bs->children));\n        return 0;\n    }\n\n    /* Check all children */\n    QLIST_FOREACH(c, &bs->children, next) {\n        uint64_t cur_perm, cur_shared;\n        drv->bdrv_child_perm(bs, c, c->role,\n                             cumulative_perms, cumulative_shared_perms,\n                             &cur_perm, &cur_shared);\n        ret = bdrv_child_check_perm(c, cur_perm, cur_shared, ignore_children,\n                                    errp);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Notifies drivers that after a previous bdrv_check_perm() call, the\n * permission update is not performed and any preparations made for it (e.g.\n * taken file locks) need to be undone.\n *\n * This function recursively notifies all child nodes.\n */\nstatic void bdrv_abort_perm_update(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *c;\n\n    if (!drv) {\n        return;\n    }\n\n    if (drv->bdrv_abort_perm_update) {\n        drv->bdrv_abort_perm_update(bs);\n    }\n\n    QLIST_FOREACH(c, &bs->children, next) {\n        bdrv_child_abort_perm_update(c);\n    }\n}\n\nstatic void bdrv_set_perm(BlockDriverState *bs, uint64_t cumulative_perms,\n                          uint64_t cumulative_shared_perms)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *c;\n\n    if (!drv) {\n        return;\n    }\n\n    /* Update this node */\n    if (drv->bdrv_set_perm) {\n        drv->bdrv_set_perm(bs, cumulative_perms, cumulative_shared_perms);\n    }\n\n    /* Drivers that never have children can omit .bdrv_child_perm() */\n    if (!drv->bdrv_child_perm) {\n        assert(QLIST_EMPTY(&bs->children));\n        return;\n    }\n\n    /* Update all children */\n    QLIST_FOREACH(c, &bs->children, next) {\n        uint64_t cur_perm, cur_shared;\n        drv->bdrv_child_perm(bs, c, c->role,\n                             cumulative_perms, cumulative_shared_perms,\n                             &cur_perm, &cur_shared);\n        bdrv_child_set_perm(c, cur_perm, cur_shared);\n    }\n}\n\nstatic void bdrv_get_cumulative_perm(BlockDriverState *bs, uint64_t *perm,\n                                     uint64_t *shared_perm)\n{\n    BdrvChild *c;\n    uint64_t cumulative_perms = 0;\n    uint64_t cumulative_shared_perms = BLK_PERM_ALL;\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        cumulative_perms |= c->perm;\n        cumulative_shared_perms &= c->shared_perm;\n    }\n\n    *perm = cumulative_perms;\n    *shared_perm = cumulative_shared_perms;\n}\n\nstatic char *bdrv_child_user_desc(BdrvChild *c)\n{\n    if (c->role->get_parent_desc) {\n        return c->role->get_parent_desc(c);\n    }\n\n    return g_strdup(\"another user\");\n}\n\nstatic char *bdrv_perm_names(uint64_t perm)\n{\n    struct perm_name {\n        uint64_t perm;\n        const char *name;\n    } permissions[] = {\n        { BLK_PERM_CONSISTENT_READ, \"consistent read\" },\n        { BLK_PERM_WRITE,           \"write\" },\n        { BLK_PERM_WRITE_UNCHANGED, \"write unchanged\" },\n        { BLK_PERM_RESIZE,          \"resize\" },\n        { BLK_PERM_GRAPH_MOD,       \"change children\" },\n        { 0, NULL }\n    };\n\n    char *result = g_strdup(\"\");\n    struct perm_name *p;\n\n    for (p = permissions; p->name; p++) {\n        if (perm & p->perm) {\n            char *old = result;\n            result = g_strdup_printf(\"%s%s%s\", old, *old ? \", \" : \"\", p->name);\n            g_free(old);\n        }\n    }\n\n    return result;\n}\n\n/*\n * Checks whether a new reference to @bs can be added if the new user requires\n * @new_used_perm/@new_shared_perm as its permissions. If @ignore_children is\n * set, the BdrvChild objects in this list are ignored in the calculations;\n * this allows checking permission updates for an existing reference.\n *\n * Needs to be followed by a call to either bdrv_set_perm() or\n * bdrv_abort_perm_update(). */\nstatic int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n                                  uint64_t new_shared_perm,\n                                  GSList *ignore_children, Error **errp)\n{\n    BdrvChild *c;\n    uint64_t cumulative_perms = new_used_perm;\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (g_slist_find(ignore_children, c)) {\n            continue;\n        }\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n            char *user = bdrv_child_user_desc(c);\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n                             \"allow '%s' on %s\",\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n            g_free(user);\n            g_free(perm_names);\n            return -EPERM;\n        }\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n            char *user = bdrv_child_user_desc(c);\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n                             \"'%s' on %s\",\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n            g_free(user);\n            g_free(perm_names);\n            return -EPERM;\n        }\n\n        cumulative_perms |= c->perm;\n        cumulative_shared_perms &= c->shared_perm;\n    }\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms,\n                           ignore_children, errp);\n}\n\n/* Needs to be followed by a call to either bdrv_child_set_perm() or\n * bdrv_child_abort_perm_update(). */\nstatic int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n                                 GSList *ignore_children, Error **errp)\n{\n    int ret;\n\n    ignore_children = g_slist_prepend(g_slist_copy(ignore_children), c);\n    ret = bdrv_check_update_perm(c->bs, perm, shared, ignore_children, errp);\n    g_slist_free(ignore_children);\n\n    return ret;\n}\n\nstatic void bdrv_child_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared)\n{\n    uint64_t cumulative_perms, cumulative_shared_perms;\n\n    c->perm = perm;\n    c->shared_perm = shared;\n\n    bdrv_get_cumulative_perm(c->bs, &cumulative_perms,\n                             &cumulative_shared_perms);\n    bdrv_set_perm(c->bs, cumulative_perms, cumulative_shared_perms);\n}\n\nstatic void bdrv_child_abort_perm_update(BdrvChild *c)\n{\n    bdrv_abort_perm_update(c->bs);\n}\n\nint bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n                            Error **errp)\n{\n    int ret;\n\n    ret = bdrv_child_check_perm(c, perm, shared, NULL, errp);\n    if (ret < 0) {\n        bdrv_child_abort_perm_update(c);\n        return ret;\n    }\n\n    bdrv_child_set_perm(c, perm, shared);\n\n    return 0;\n}\n\n#define DEFAULT_PERM_PASSTHROUGH (BLK_PERM_CONSISTENT_READ \\\n                                 | BLK_PERM_WRITE \\\n                                 | BLK_PERM_WRITE_UNCHANGED \\\n                                 | BLK_PERM_RESIZE)\n#define DEFAULT_PERM_UNCHANGED (BLK_PERM_ALL & ~DEFAULT_PERM_PASSTHROUGH)\n\nvoid bdrv_filter_default_perms(BlockDriverState *bs, BdrvChild *c,\n                               const BdrvChildRole *role,\n                               uint64_t perm, uint64_t shared,\n                               uint64_t *nperm, uint64_t *nshared)\n{\n    if (c == NULL) {\n        *nperm = perm & DEFAULT_PERM_PASSTHROUGH;\n        *nshared = (shared & DEFAULT_PERM_PASSTHROUGH) | DEFAULT_PERM_UNCHANGED;\n        return;\n    }\n\n    *nperm = (perm & DEFAULT_PERM_PASSTHROUGH) |\n             (c->perm & DEFAULT_PERM_UNCHANGED);\n    *nshared = (shared & DEFAULT_PERM_PASSTHROUGH) |\n               (c->shared_perm & DEFAULT_PERM_UNCHANGED);\n}\n\nvoid bdrv_format_default_perms(BlockDriverState *bs, BdrvChild *c,\n                               const BdrvChildRole *role,\n                               uint64_t perm, uint64_t shared,\n                               uint64_t *nperm, uint64_t *nshared)\n{\n    bool backing = (role == &child_backing);\n    assert(role == &child_backing || role == &child_file);\n\n    if (!backing) {\n        /* Apart from the modifications below, the same permissions are\n         * forwarded and left alone as for filters */\n        bdrv_filter_default_perms(bs, c, role, perm, shared, &perm, &shared);\n\n        /* Format drivers may touch metadata even if the guest doesn't write */\n        if (!bdrv_is_read_only(bs)) {\n            perm |= BLK_PERM_WRITE | BLK_PERM_RESIZE;\n        }\n\n        /* bs->file always needs to be consistent because of the metadata. We\n         * can never allow other users to resize or write to it. */\n        perm |= BLK_PERM_CONSISTENT_READ;\n        shared &= ~(BLK_PERM_WRITE | BLK_PERM_RESIZE);\n    } else {\n        /* We want consistent read from backing files if the parent needs it.\n         * No other operations are performed on backing files. */\n        perm &= BLK_PERM_CONSISTENT_READ;\n\n        /* If the parent can deal with changing data, we're okay with a\n         * writable and resizable backing file. */\n        /* TODO Require !(perm & BLK_PERM_CONSISTENT_READ), too? */\n        if (shared & BLK_PERM_WRITE) {\n            shared = BLK_PERM_WRITE | BLK_PERM_RESIZE;\n        } else {\n            shared = 0;\n        }\n\n        shared |= BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD |\n                  BLK_PERM_WRITE_UNCHANGED;\n    }\n\n    *nperm = perm;\n    *nshared = shared;\n}\n\nstatic void bdrv_replace_child_noperm(BdrvChild *child,\n                                      BlockDriverState *new_bs)\n{\n    BlockDriverState *old_bs = child->bs;\n\n    if (old_bs && new_bs) {\n        assert(bdrv_get_aio_context(old_bs) == bdrv_get_aio_context(new_bs));\n    }\n    if (old_bs) {\n        if (old_bs->quiesce_counter && child->role->drained_end) {\n            child->role->drained_end(child);\n        }\n        if (child->role->detach) {\n            child->role->detach(child);\n        }\n        QLIST_REMOVE(child, next_parent);\n    }\n\n    child->bs = new_bs;\n\n    if (new_bs) {\n        QLIST_INSERT_HEAD(&new_bs->parents, child, next_parent);\n        if (new_bs->quiesce_counter && child->role->drained_begin) {\n            child->role->drained_begin(child);\n        }\n\n        if (child->role->attach) {\n            child->role->attach(child);\n        }\n    }\n}\n\n/*\n * Updates @child to change its reference to point to @new_bs, including\n * checking and applying the necessary permisson updates both to the old node\n * and to @new_bs.\n *\n * NULL is passed as @new_bs for removing the reference before freeing @child.\n *\n * If @new_bs is not NULL, bdrv_check_perm() must be called beforehand, as this\n * function uses bdrv_set_perm() to update the permissions according to the new\n * reference that @new_bs gets.\n */\nstatic void bdrv_replace_child(BdrvChild *child, BlockDriverState *new_bs)\n{\n    BlockDriverState *old_bs = child->bs;\n    uint64_t perm, shared_perm;\n\n    if (old_bs) {\n        /* Update permissions for old node. This is guaranteed to succeed\n         * because we're just taking a parent away, so we're loosening\n         * restrictions. */\n        bdrv_get_cumulative_perm(old_bs, &perm, &shared_perm);\n        bdrv_check_perm(old_bs, perm, shared_perm, NULL, &error_abort);\n        bdrv_set_perm(old_bs, perm, shared_perm);\n    }\n\n    bdrv_replace_child_noperm(child, new_bs);\n\n    if (new_bs) {\n        bdrv_get_cumulative_perm(new_bs, &perm, &shared_perm);\n        bdrv_set_perm(new_bs, perm, shared_perm);\n    }\n}\n\nBdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,\n                                  const char *child_name,\n                                  const BdrvChildRole *child_role,\n                                  uint64_t perm, uint64_t shared_perm,\n                                  void *opaque, Error **errp)\n{\n    BdrvChild *child;\n    int ret;\n\n    ret = bdrv_check_update_perm(child_bs, perm, shared_perm, NULL, errp);\n    if (ret < 0) {\n        bdrv_abort_perm_update(child_bs);\n        return NULL;\n    }\n\n    child = g_new(BdrvChild, 1);\n    *child = (BdrvChild) {\n        .bs             = NULL,\n        .name           = g_strdup(child_name),\n        .role           = child_role,\n        .perm           = perm,\n        .shared_perm    = shared_perm,\n        .opaque         = opaque,\n    };\n\n    /* This performs the matching bdrv_set_perm() for the above check. */\n    bdrv_replace_child(child, child_bs);\n\n    return child;\n}\n\nBdrvChild *bdrv_attach_child(BlockDriverState *parent_bs,\n                             BlockDriverState *child_bs,\n                             const char *child_name,\n                             const BdrvChildRole *child_role,\n                             Error **errp)\n{\n    BdrvChild *child;\n    uint64_t perm, shared_perm;\n\n    bdrv_get_cumulative_perm(parent_bs, &perm, &shared_perm);\n\n    assert(parent_bs->drv);\n    assert(bdrv_get_aio_context(parent_bs) == bdrv_get_aio_context(child_bs));\n    parent_bs->drv->bdrv_child_perm(parent_bs, NULL, child_role,\n                                    perm, shared_perm, &perm, &shared_perm);\n\n    child = bdrv_root_attach_child(child_bs, child_name, child_role,\n                                   perm, shared_perm, parent_bs, errp);\n    if (child == NULL) {\n        return NULL;\n    }\n\n    QLIST_INSERT_HEAD(&parent_bs->children, child, next);\n    return child;\n}\n\nstatic void bdrv_detach_child(BdrvChild *child)\n{\n    if (child->next.le_prev) {\n        QLIST_REMOVE(child, next);\n        child->next.le_prev = NULL;\n    }\n\n    bdrv_replace_child(child, NULL);\n\n    g_free(child->name);\n    g_free(child);\n}\n\nvoid bdrv_root_unref_child(BdrvChild *child)\n{\n    BlockDriverState *child_bs;\n\n    child_bs = child->bs;\n    bdrv_detach_child(child);\n    bdrv_unref(child_bs);\n}\n\nvoid bdrv_unref_child(BlockDriverState *parent, BdrvChild *child)\n{\n    if (child == NULL) {\n        return;\n    }\n\n    if (child->bs->inherits_from == parent) {\n        BdrvChild *c;\n\n        /* Remove inherits_from only when the last reference between parent and\n         * child->bs goes away. */\n        QLIST_FOREACH(c, &parent->children, next) {\n            if (c != child && c->bs == child->bs) {\n                break;\n            }\n        }\n        if (c == NULL) {\n            child->bs->inherits_from = NULL;\n        }\n    }\n\n    bdrv_root_unref_child(child);\n}\n\n\nstatic void bdrv_parent_cb_change_media(BlockDriverState *bs, bool load)\n{\n    BdrvChild *c;\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (c->role->change_media) {\n            c->role->change_media(c, load);\n        }\n    }\n}\n\nstatic void bdrv_parent_cb_resize(BlockDriverState *bs)\n{\n    BdrvChild *c;\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (c->role->resize) {\n            c->role->resize(c);\n        }\n    }\n}\n\n/*\n * Sets the backing file link of a BDS. A new reference is created; callers\n * which don't need their own reference any more must call bdrv_unref().\n */\nvoid bdrv_set_backing_hd(BlockDriverState *bs, BlockDriverState *backing_hd,\n                         Error **errp)\n{\n    if (backing_hd) {\n        bdrv_ref(backing_hd);\n    }\n\n    if (bs->backing) {\n        bdrv_unref_child(bs, bs->backing);\n    }\n\n    if (!backing_hd) {\n        bs->backing = NULL;\n        goto out;\n    }\n\n    bs->backing = bdrv_attach_child(bs, backing_hd, \"backing\", &child_backing,\n                                    errp);\n    if (!bs->backing) {\n        bdrv_unref(backing_hd);\n    }\n\n    bdrv_refresh_filename(bs);\n\nout:\n    bdrv_refresh_limits(bs, NULL);\n}\n\n/*\n * Opens the backing file for a BlockDriverState if not yet open\n *\n * bdref_key specifies the key for the image's BlockdevRef in the options QDict.\n * That QDict has to be flattened; therefore, if the BlockdevRef is a QDict\n * itself, all options starting with \"${bdref_key}.\" are considered part of the\n * BlockdevRef.\n *\n * TODO Can this be unified with bdrv_open_image()?\n */\nint bdrv_open_backing_file(BlockDriverState *bs, QDict *parent_options,\n                           const char *bdref_key, Error **errp)\n{\n    char *backing_filename = g_malloc0(PATH_MAX);\n    char *bdref_key_dot;\n    const char *reference = NULL;\n    int ret = 0;\n    BlockDriverState *backing_hd;\n    QDict *options;\n    QDict *tmp_parent_options = NULL;\n    Error *local_err = NULL;\n\n    if (bs->backing != NULL) {\n        goto free_exit;\n    }\n\n    /* NULL means an empty set of options */\n    if (parent_options == NULL) {\n        tmp_parent_options = qdict_new();\n        parent_options = tmp_parent_options;\n    }\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n    qdict_extract_subqdict(parent_options, &options, bdref_key_dot);\n    g_free(bdref_key_dot);\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @parent_options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    reference = qdict_get_try_str(parent_options, bdref_key);\n    if (reference || qdict_haskey(options, \"file.filename\")) {\n        backing_filename[0] = '\\0';\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n        QDECREF(options);\n        goto free_exit;\n    } else {\n        bdrv_get_full_backing_filename(bs, backing_filename, PATH_MAX,\n                                       &local_err);\n        if (local_err) {\n            ret = -EINVAL;\n            error_propagate(errp, local_err);\n            QDECREF(options);\n            goto free_exit;\n        }\n    }\n\n    if (!bs->drv || !bs->drv->supports_backing) {\n        ret = -EINVAL;\n        error_setg(errp, \"Driver doesn't support backing files\");\n        QDECREF(options);\n        goto free_exit;\n    }\n\n    if (bs->backing_format[0] != '\\0' && !qdict_haskey(options, \"driver\")) {\n        qdict_put_str(options, \"driver\", bs->backing_format);\n    }\n\n    backing_hd = bdrv_open_inherit(*backing_filename ? backing_filename : NULL,\n                                   reference, options, 0, bs, &child_backing,\n                                   errp);\n    if (!backing_hd) {\n        bs->open_flags |= BDRV_O_NO_BACKING;\n        error_prepend(errp, \"Could not open backing file: \");\n        ret = -EINVAL;\n        goto free_exit;\n    }\n\n    /* Hook up the backing file link; drop our reference, bs owns the\n     * backing_hd reference now */\n    bdrv_set_backing_hd(bs, backing_hd, &local_err);\n    bdrv_unref(backing_hd);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto free_exit;\n    }\n\n    qdict_del(parent_options, bdref_key);\n\nfree_exit:\n    g_free(backing_filename);\n    QDECREF(tmp_parent_options);\n    return ret;\n}\n\nstatic BlockDriverState *\nbdrv_open_child_bs(const char *filename, QDict *options, const char *bdref_key,\n                   BlockDriverState *parent, const BdrvChildRole *child_role,\n                   bool allow_none, Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    QDict *image_options;\n    char *bdref_key_dot;\n    const char *reference;\n\n    assert(child_role != NULL);\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n    g_free(bdref_key_dot);\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    reference = qdict_get_try_str(options, bdref_key);\n    if (!filename && !reference && !qdict_size(image_options)) {\n        if (!allow_none) {\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n                       bdref_key);\n        }\n        QDECREF(image_options);\n        goto done;\n    }\n\n    bs = bdrv_open_inherit(filename, reference, image_options, 0,\n                           parent, child_role, errp);\n    if (!bs) {\n        goto done;\n    }\n\ndone:\n    qdict_del(options, bdref_key);\n    return bs;\n}\n\n/*\n * Opens a disk image whose options are given as BlockdevRef in another block\n * device's options.\n *\n * If allow_none is true, no image will be opened if filename is false and no\n * BlockdevRef is given. NULL will be returned, but errp remains unset.\n *\n * bdrev_key specifies the key for the image's BlockdevRef in the options QDict.\n * That QDict has to be flattened; therefore, if the BlockdevRef is a QDict\n * itself, all options starting with \"${bdref_key}.\" are considered part of the\n * BlockdevRef.\n *\n * The BlockdevRef will be removed from the options QDict.\n */\nBdrvChild *bdrv_open_child(const char *filename,\n                           QDict *options, const char *bdref_key,\n                           BlockDriverState *parent,\n                           const BdrvChildRole *child_role,\n                           bool allow_none, Error **errp)\n{\n    BdrvChild *c;\n    BlockDriverState *bs;\n\n    bs = bdrv_open_child_bs(filename, options, bdref_key, parent, child_role,\n                            allow_none, errp);\n    if (bs == NULL) {\n        return NULL;\n    }\n\n    c = bdrv_attach_child(parent, bs, bdref_key, child_role, errp);\n    if (!c) {\n        bdrv_unref(bs);\n        return NULL;\n    }\n\n    return c;\n}\n\nstatic BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *bs,\n                                                   int flags,\n                                                   QDict *snapshot_options,\n                                                   Error **errp)\n{\n    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */\n    char *tmp_filename = g_malloc0(PATH_MAX + 1);\n    int64_t total_size;\n    QemuOpts *opts = NULL;\n    BlockDriverState *bs_snapshot;\n    Error *local_err = NULL;\n    int ret;\n\n    /* if snapshot, we create a temporary backing file and open it\n       instead of opening 'filename' directly */\n\n    /* Get the required size from the image */\n    total_size = bdrv_getlength(bs);\n    if (total_size < 0) {\n        error_setg_errno(errp, -total_size, \"Could not get image size\");\n        goto out;\n    }\n\n    /* Create the temporary image */\n    ret = get_tmp_filename(tmp_filename, PATH_MAX + 1);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not get temporary filename\");\n        goto out;\n    }\n\n    opts = qemu_opts_create(bdrv_qcow2.create_opts, NULL, 0,\n                            &error_abort);\n    qemu_opt_set_number(opts, BLOCK_OPT_SIZE, total_size, &error_abort);\n    ret = bdrv_create(&bdrv_qcow2, tmp_filename, opts, errp);\n    qemu_opts_del(opts);\n    if (ret < 0) {\n        error_prepend(errp, \"Could not create temporary overlay '%s': \",\n                      tmp_filename);\n        goto out;\n    }\n\n    /* Prepare options QDict for the temporary file */\n    qdict_put_str(snapshot_options, \"file.driver\", \"file\");\n    qdict_put_str(snapshot_options, \"file.filename\", tmp_filename);\n    qdict_put_str(snapshot_options, \"driver\", \"qcow2\");\n\n    bs_snapshot = bdrv_open(NULL, NULL, snapshot_options, flags, errp);\n    snapshot_options = NULL;\n    if (!bs_snapshot) {\n        ret = -EINVAL;\n        goto out;\n    }\n\n    /* bdrv_append() consumes a strong reference to bs_snapshot (i.e. it will\n     * call bdrv_unref() on it), so in order to be able to return one, we have\n     * to increase bs_snapshot's refcount here */\n    bdrv_ref(bs_snapshot);\n    bdrv_append(bs_snapshot, bs, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto out;\n    }\n\n    g_free(tmp_filename);\n    return bs_snapshot;\n\nout:\n    QDECREF(snapshot_options);\n    g_free(tmp_filename);\n    return NULL;\n}\n\n/*\n * Opens a disk image (raw, qcow2, vmdk, ...)\n *\n * options is a QDict of options to pass to the block drivers, or NULL for an\n * empty set of options. The reference to the QDict belongs to the block layer\n * after the call (even on failure), so if the caller intends to reuse the\n * dictionary, it needs to use QINCREF() before calling bdrv_open.\n *\n * If *pbs is NULL, a new BDS will be created with a pointer to it stored there.\n * If it is not NULL, the referenced BDS will be reused.\n *\n * The reference parameter may be used to specify an existing block device which\n * should be opened. If specified, neither options nor a filename may be given,\n * nor can an existing BDS be reused (that is, *pbs has to be NULL).\n */\nstatic BlockDriverState *bdrv_open_inherit(const char *filename,\n                                           const char *reference,\n                                           QDict *options, int flags,\n                                           BlockDriverState *parent,\n                                           const BdrvChildRole *child_role,\n                                           Error **errp)\n{\n    int ret;\n    BlockBackend *file = NULL;\n    BlockDriverState *bs;\n    BlockDriver *drv = NULL;\n    const char *drvname;\n    const char *backing;\n    Error *local_err = NULL;\n    QDict *snapshot_options = NULL;\n    int snapshot_flags = 0;\n\n    assert(!child_role || !flags);\n    assert(!child_role == !parent);\n\n    if (reference) {\n        bool options_non_empty = options ? qdict_size(options) : false;\n        QDECREF(options);\n\n        if (filename || options_non_empty) {\n            error_setg(errp, \"Cannot reference an existing block device with \"\n                       \"additional options or a new filename\");\n            return NULL;\n        }\n\n        bs = bdrv_lookup_bs(reference, reference, errp);\n        if (!bs) {\n            return NULL;\n        }\n\n        bdrv_ref(bs);\n        return bs;\n    }\n\n    bs = bdrv_new();\n\n    /* NULL means an empty set of options */\n    if (options == NULL) {\n        options = qdict_new();\n    }\n\n    /* json: syntax counts as explicit options, as if in the QDict */\n    parse_json_protocol(options, &filename, &local_err);\n    if (local_err) {\n        goto fail;\n    }\n\n    bs->explicit_options = qdict_clone_shallow(options);\n\n    if (child_role) {\n        bs->inherits_from = parent;\n        child_role->inherit_options(&flags, options,\n                                    parent->open_flags, parent->options);\n    }\n\n    ret = bdrv_fill_options(&options, filename, &flags, &local_err);\n    if (local_err) {\n        goto fail;\n    }\n\n    /*\n     * Set the BDRV_O_RDWR and BDRV_O_ALLOW_RDWR flags.\n     * Caution: getting a boolean member of @options requires care.\n     * When @options come from -blockdev or blockdev_add, members are\n     * typed according to the QAPI schema, but when they come from\n     * -drive, they're all QString.\n     */\n    if (g_strcmp0(qdict_get_try_str(options, BDRV_OPT_READ_ONLY), \"on\") &&\n        !qdict_get_try_bool(options, BDRV_OPT_READ_ONLY, false)) {\n        flags |= (BDRV_O_RDWR | BDRV_O_ALLOW_RDWR);\n    } else {\n        flags &= ~BDRV_O_RDWR;\n    }\n\n    if (flags & BDRV_O_SNAPSHOT) {\n        snapshot_options = qdict_new();\n        bdrv_temp_snapshot_options(&snapshot_flags, snapshot_options,\n                                   flags, options);\n        /* Let bdrv_backing_options() override \"read-only\" */\n        qdict_del(options, BDRV_OPT_READ_ONLY);\n        bdrv_backing_options(&flags, options, flags, options);\n    }\n\n    bs->open_flags = flags;\n    bs->options = options;\n    options = qdict_clone_shallow(options);\n\n    /* Find the right image format driver */\n    /* See cautionary note on accessing @options above */\n    drvname = qdict_get_try_str(options, \"driver\");\n    if (drvname) {\n        drv = bdrv_find_format(drvname);\n        if (!drv) {\n            error_setg(errp, \"Unknown driver: '%s'\", drvname);\n            goto fail;\n        }\n    }\n\n    assert(drvname || !(flags & BDRV_O_PROTOCOL));\n\n    /* See cautionary note on accessing @options above */\n    backing = qdict_get_try_str(options, \"backing\");\n    if (backing && *backing == '\\0') {\n        flags |= BDRV_O_NO_BACKING;\n        qdict_del(options, \"backing\");\n    }\n\n    /* Open image file without format layer. This BlockBackend is only used for\n     * probing, the block drivers will do their own bdrv_open_child() for the\n     * same BDS, which is why we put the node name back into options. */\n    if ((flags & BDRV_O_PROTOCOL) == 0) {\n        BlockDriverState *file_bs;\n\n        file_bs = bdrv_open_child_bs(filename, options, \"file\", bs,\n                                     &child_file, true, &local_err);\n        if (local_err) {\n            goto fail;\n        }\n        if (file_bs != NULL) {\n            file = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n            blk_insert_bs(file, file_bs, &local_err);\n            bdrv_unref(file_bs);\n            if (local_err) {\n                goto fail;\n            }\n\n            qdict_put_str(options, \"file\", bdrv_get_node_name(file_bs));\n        }\n    }\n\n    /* Image format probing */\n    bs->probed = !drv;\n    if (!drv && file) {\n        ret = find_image_format(file, filename, &drv, &local_err);\n        if (ret < 0) {\n            goto fail;\n        }\n        /*\n         * This option update would logically belong in bdrv_fill_options(),\n         * but we first need to open bs->file for the probing to work, while\n         * opening bs->file already requires the (mostly) final set of options\n         * so that cache mode etc. can be inherited.\n         *\n         * Adding the driver later is somewhat ugly, but it's not an option\n         * that would ever be inherited, so it's correct. We just need to make\n         * sure to update both bs->options (which has the full effective\n         * options for bs) and options (which has file.* already removed).\n         */\n        qdict_put_str(bs->options, \"driver\", drv->format_name);\n        qdict_put_str(options, \"driver\", drv->format_name);\n    } else if (!drv) {\n        error_setg(errp, \"Must specify either driver or file\");\n        goto fail;\n    }\n\n    /* BDRV_O_PROTOCOL must be set iff a protocol BDS is about to be created */\n    assert(!!(flags & BDRV_O_PROTOCOL) == !!drv->bdrv_file_open);\n    /* file must be NULL if a protocol BDS is about to be created\n     * (the inverse results in an error message from bdrv_open_common()) */\n    assert(!(flags & BDRV_O_PROTOCOL) || !file);\n\n    /* Open the image */\n    ret = bdrv_open_common(bs, file, options, &local_err);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (file) {\n        blk_unref(file);\n        file = NULL;\n    }\n\n    /* If there is a backing file, use it */\n    if ((flags & BDRV_O_NO_BACKING) == 0) {\n        ret = bdrv_open_backing_file(bs, options, \"backing\", &local_err);\n        if (ret < 0) {\n            goto close_and_fail;\n        }\n    }\n\n    bdrv_refresh_filename(bs);\n\n    /* Check if any unknown options were used */\n    if (qdict_size(options) != 0) {\n        const QDictEntry *entry = qdict_first(options);\n        if (flags & BDRV_O_PROTOCOL) {\n            error_setg(errp, \"Block protocol '%s' doesn't support the option \"\n                       \"'%s'\", drv->format_name, entry->key);\n        } else {\n            error_setg(errp,\n                       \"Block format '%s' does not support the option '%s'\",\n                       drv->format_name, entry->key);\n        }\n\n        goto close_and_fail;\n    }\n\n    if (!bdrv_key_required(bs)) {\n        bdrv_parent_cb_change_media(bs, true);\n    } else if (!runstate_check(RUN_STATE_PRELAUNCH)\n               && !runstate_check(RUN_STATE_INMIGRATE)\n               && !runstate_check(RUN_STATE_PAUSED)) { /* HACK */\n        error_setg(errp,\n                   \"Guest must be stopped for opening of encrypted image\");\n        goto close_and_fail;\n    }\n\n    QDECREF(options);\n\n    /* For snapshot=on, create a temporary qcow2 overlay. bs points to the\n     * temporary snapshot afterwards. */\n    if (snapshot_flags) {\n        BlockDriverState *snapshot_bs;\n        snapshot_bs = bdrv_append_temp_snapshot(bs, snapshot_flags,\n                                                snapshot_options, &local_err);\n        snapshot_options = NULL;\n        if (local_err) {\n            goto close_and_fail;\n        }\n        /* We are not going to return bs but the overlay on top of it\n         * (snapshot_bs); thus, we have to drop the strong reference to bs\n         * (which we obtained by calling bdrv_new()). bs will not be deleted,\n         * though, because the overlay still has a reference to it. */\n        bdrv_unref(bs);\n        bs = snapshot_bs;\n    }\n\n    return bs;\n\nfail:\n    blk_unref(file);\n    if (bs->file != NULL) {\n        bdrv_unref_child(bs, bs->file);\n    }\n    QDECREF(snapshot_options);\n    QDECREF(bs->explicit_options);\n    QDECREF(bs->options);\n    QDECREF(options);\n    bs->options = NULL;\n    bdrv_unref(bs);\n    error_propagate(errp, local_err);\n    return NULL;\n\nclose_and_fail:\n    bdrv_unref(bs);\n    QDECREF(snapshot_options);\n    QDECREF(options);\n    error_propagate(errp, local_err);\n    return NULL;\n}\n\nBlockDriverState *bdrv_open(const char *filename, const char *reference,\n                            QDict *options, int flags, Error **errp)\n{\n    return bdrv_open_inherit(filename, reference, options, flags, NULL,\n                             NULL, errp);\n}\n\ntypedef struct BlockReopenQueueEntry {\n     bool prepared;\n     BDRVReopenState state;\n     QSIMPLEQ_ENTRY(BlockReopenQueueEntry) entry;\n} BlockReopenQueueEntry;\n\n/*\n * Adds a BlockDriverState to a simple queue for an atomic, transactional\n * reopen of multiple devices.\n *\n * bs_queue can either be an existing BlockReopenQueue that has had QSIMPLE_INIT\n * already performed, or alternatively may be NULL a new BlockReopenQueue will\n * be created and initialized. This newly created BlockReopenQueue should be\n * passed back in for subsequent calls that are intended to be of the same\n * atomic 'set'.\n *\n * bs is the BlockDriverState to add to the reopen queue.\n *\n * options contains the changed options for the associated bs\n * (the BlockReopenQueue takes ownership)\n *\n * flags contains the open flags for the associated bs\n *\n * returns a pointer to bs_queue, which is either the newly allocated\n * bs_queue, or the existing bs_queue being used.\n *\n */\nstatic BlockReopenQueue *bdrv_reopen_queue_child(BlockReopenQueue *bs_queue,\n                                                 BlockDriverState *bs,\n                                                 QDict *options,\n                                                 int flags,\n                                                 const BdrvChildRole *role,\n                                                 QDict *parent_options,\n                                                 int parent_flags)\n{\n    assert(bs != NULL);\n\n    BlockReopenQueueEntry *bs_entry;\n    BdrvChild *child;\n    QDict *old_options, *explicit_options;\n\n    if (bs_queue == NULL) {\n        bs_queue = g_new0(BlockReopenQueue, 1);\n        QSIMPLEQ_INIT(bs_queue);\n    }\n\n    if (!options) {\n        options = qdict_new();\n    }\n\n    /* Check if this BlockDriverState is already in the queue */\n    QSIMPLEQ_FOREACH(bs_entry, bs_queue, entry) {\n        if (bs == bs_entry->state.bs) {\n            break;\n        }\n    }\n\n    /*\n     * Precedence of options:\n     * 1. Explicitly passed in options (highest)\n     * 2. Set in flags (only for top level)\n     * 3. Retained from explicitly set options of bs\n     * 4. Inherited from parent node\n     * 5. Retained from effective options of bs\n     */\n\n    if (!parent_options) {\n        /*\n         * Any setting represented by flags is always updated. If the\n         * corresponding QDict option is set, it takes precedence. Otherwise\n         * the flag is translated into a QDict option. The old setting of bs is\n         * not considered.\n         */\n        update_options_from_flags(options, flags);\n    }\n\n    /* Old explicitly set values (don't overwrite by inherited value) */\n    if (bs_entry) {\n        old_options = qdict_clone_shallow(bs_entry->state.explicit_options);\n    } else {\n        old_options = qdict_clone_shallow(bs->explicit_options);\n    }\n    bdrv_join_options(bs, options, old_options);\n    QDECREF(old_options);\n\n    explicit_options = qdict_clone_shallow(options);\n\n    /* Inherit from parent node */\n    if (parent_options) {\n        assert(!flags);\n        role->inherit_options(&flags, options, parent_flags, parent_options);\n    }\n\n    /* Old values are used for options that aren't set yet */\n    old_options = qdict_clone_shallow(bs->options);\n    bdrv_join_options(bs, options, old_options);\n    QDECREF(old_options);\n\n    /* bdrv_open() masks this flag out */\n    flags &= ~BDRV_O_PROTOCOL;\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        QDict *new_child_options;\n        char *child_key_dot;\n\n        /* reopen can only change the options of block devices that were\n         * implicitly created and inherited options. For other (referenced)\n         * block devices, a syntax like \"backing.foo\" results in an error. */\n        if (child->bs->inherits_from != bs) {\n            continue;\n        }\n\n        child_key_dot = g_strdup_printf(\"%s.\", child->name);\n        qdict_extract_subqdict(options, &new_child_options, child_key_dot);\n        g_free(child_key_dot);\n\n        bdrv_reopen_queue_child(bs_queue, child->bs, new_child_options, 0,\n                                child->role, options, flags);\n    }\n\n    if (!bs_entry) {\n        bs_entry = g_new0(BlockReopenQueueEntry, 1);\n        QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n    } else {\n        QDECREF(bs_entry->state.options);\n        QDECREF(bs_entry->state.explicit_options);\n    }\n\n    bs_entry->state.bs = bs;\n    bs_entry->state.options = options;\n    bs_entry->state.explicit_options = explicit_options;\n    bs_entry->state.flags = flags;\n\n    return bs_queue;\n}\n\nBlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n                                    BlockDriverState *bs,\n                                    QDict *options, int flags)\n{\n    return bdrv_reopen_queue_child(bs_queue, bs, options, flags,\n                                   NULL, NULL, 0);\n}\n\n/*\n * Reopen multiple BlockDriverStates atomically & transactionally.\n *\n * The queue passed in (bs_queue) must have been built up previous\n * via bdrv_reopen_queue().\n *\n * Reopens all BDS specified in the queue, with the appropriate\n * flags.  All devices are prepared for reopen, and failure of any\n * device will cause all device changes to be abandonded, and intermediate\n * data cleaned up.\n *\n * If all devices prepare successfully, then the changes are committed\n * to all devices.\n *\n */\nint bdrv_reopen_multiple(AioContext *ctx, BlockReopenQueue *bs_queue, Error **errp)\n{\n    int ret = -1;\n    BlockReopenQueueEntry *bs_entry, *next;\n    Error *local_err = NULL;\n\n    assert(bs_queue != NULL);\n\n    aio_context_release(ctx);\n    bdrv_drain_all_begin();\n    aio_context_acquire(ctx);\n\n    QSIMPLEQ_FOREACH(bs_entry, bs_queue, entry) {\n        if (bdrv_reopen_prepare(&bs_entry->state, bs_queue, &local_err)) {\n            error_propagate(errp, local_err);\n            goto cleanup;\n        }\n        bs_entry->prepared = true;\n    }\n\n    /* If we reach this point, we have success and just need to apply the\n     * changes\n     */\n    QSIMPLEQ_FOREACH(bs_entry, bs_queue, entry) {\n        bdrv_reopen_commit(&bs_entry->state);\n    }\n\n    ret = 0;\n\ncleanup:\n    QSIMPLEQ_FOREACH_SAFE(bs_entry, bs_queue, entry, next) {\n        if (ret && bs_entry->prepared) {\n            bdrv_reopen_abort(&bs_entry->state);\n        } else if (ret) {\n            QDECREF(bs_entry->state.explicit_options);\n        }\n        QDECREF(bs_entry->state.options);\n        g_free(bs_entry);\n    }\n    g_free(bs_queue);\n\n    bdrv_drain_all_end();\n\n    return ret;\n}\n\n\n/* Reopen a single BlockDriverState with the specified flags. */\nint bdrv_reopen(BlockDriverState *bs, int bdrv_flags, Error **errp)\n{\n    int ret = -1;\n    Error *local_err = NULL;\n    BlockReopenQueue *queue = bdrv_reopen_queue(NULL, bs, NULL, bdrv_flags);\n\n    ret = bdrv_reopen_multiple(bdrv_get_aio_context(bs), queue, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    }\n    return ret;\n}\n\n\n/*\n * Prepares a BlockDriverState for reopen. All changes are staged in the\n * 'opaque' field of the BDRVReopenState, which is used and allocated by\n * the block driver layer .bdrv_reopen_prepare()\n *\n * bs is the BlockDriverState to reopen\n * flags are the new open flags\n * queue is the reopen queue\n *\n * Returns 0 on success, non-zero on error.  On error errp will be set\n * as well.\n *\n * On failure, bdrv_reopen_abort() will be called to clean up any data.\n * It is the responsibility of the caller to then call the abort() or\n * commit() for any other BDS that have been left in a prepare() state\n *\n */\nint bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,\n                        Error **errp)\n{\n    int ret = -1;\n    Error *local_err = NULL;\n    BlockDriver *drv;\n    QemuOpts *opts;\n    const char *value;\n\n    assert(reopen_state != NULL);\n    assert(reopen_state->bs->drv != NULL);\n    drv = reopen_state->bs->drv;\n\n    /* Process generic block layer options */\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, reopen_state->options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto error;\n    }\n\n    update_flags_from_options(&reopen_state->flags, opts);\n\n    /* node-name and driver must be unchanged. Put them back into the QDict, so\n     * that they are checked at the end of this function. */\n    value = qemu_opt_get(opts, \"node-name\");\n    if (value) {\n        qdict_put_str(reopen_state->options, \"node-name\", value);\n    }\n\n    value = qemu_opt_get(opts, \"driver\");\n    if (value) {\n        qdict_put_str(reopen_state->options, \"driver\", value);\n    }\n\n    /* if we are to stay read-only, do not allow permission change\n     * to r/w */\n    if (!(reopen_state->bs->open_flags & BDRV_O_ALLOW_RDWR) &&\n        reopen_state->flags & BDRV_O_RDWR) {\n        error_setg(errp, \"Node '%s' is read only\",\n                   bdrv_get_device_or_node_name(reopen_state->bs));\n        goto error;\n    }\n\n\n    ret = bdrv_flush(reopen_state->bs);\n    if (ret) {\n        error_setg_errno(errp, -ret, \"Error flushing drive\");\n        goto error;\n    }\n\n    if (drv->bdrv_reopen_prepare) {\n        ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);\n        if (ret) {\n            if (local_err != NULL) {\n                error_propagate(errp, local_err);\n            } else {\n                error_setg(errp, \"failed while preparing to reopen image '%s'\",\n                           reopen_state->bs->filename);\n            }\n            goto error;\n        }\n    } else {\n        /* It is currently mandatory to have a bdrv_reopen_prepare()\n         * handler for each supported drv. */\n        error_setg(errp, \"Block format '%s' used by node '%s' \"\n                   \"does not support reopening files\", drv->format_name,\n                   bdrv_get_device_or_node_name(reopen_state->bs));\n        ret = -1;\n        goto error;\n    }\n\n    /* Options that are not handled are only okay if they are unchanged\n     * compared to the old state. It is expected that some options are only\n     * used for the initial open, but not reopen (e.g. filename) */\n    if (qdict_size(reopen_state->options)) {\n        const QDictEntry *entry = qdict_first(reopen_state->options);\n\n        do {\n            QString *new_obj = qobject_to_qstring(entry->value);\n            const char *new = qstring_get_str(new_obj);\n            /*\n             * Caution: while qdict_get_try_str() is fine, getting\n             * non-string types would require more care.  When\n             * bs->options come from -blockdev or blockdev_add, its\n             * members are typed according to the QAPI schema, but\n             * when they come from -drive, they're all QString.\n             */\n            const char *old = qdict_get_try_str(reopen_state->bs->options,\n                                                entry->key);\n\n            if (!old || strcmp(new, old)) {\n                error_setg(errp, \"Cannot change the option '%s'\", entry->key);\n                ret = -EINVAL;\n                goto error;\n            }\n        } while ((entry = qdict_next(reopen_state->options, entry)));\n    }\n\n    ret = 0;\n\nerror:\n    qemu_opts_del(opts);\n    return ret;\n}\n\n/*\n * Takes the staged changes for the reopen from bdrv_reopen_prepare(), and\n * makes them final by swapping the staging BlockDriverState contents into\n * the active BlockDriverState contents.\n */\nvoid bdrv_reopen_commit(BDRVReopenState *reopen_state)\n{\n    BlockDriver *drv;\n\n    assert(reopen_state != NULL);\n    drv = reopen_state->bs->drv;\n    assert(drv != NULL);\n\n    /* If there are any driver level actions to take */\n    if (drv->bdrv_reopen_commit) {\n        drv->bdrv_reopen_commit(reopen_state);\n    }\n\n    /* set BDS specific flags now */\n    QDECREF(reopen_state->bs->explicit_options);\n\n    reopen_state->bs->explicit_options   = reopen_state->explicit_options;\n    reopen_state->bs->open_flags         = reopen_state->flags;\n    reopen_state->bs->read_only = !(reopen_state->flags & BDRV_O_RDWR);\n\n    bdrv_refresh_limits(reopen_state->bs, NULL);\n}\n\n/*\n * Abort the reopen, and delete and free the staged changes in\n * reopen_state\n */\nvoid bdrv_reopen_abort(BDRVReopenState *reopen_state)\n{\n    BlockDriver *drv;\n\n    assert(reopen_state != NULL);\n    drv = reopen_state->bs->drv;\n    assert(drv != NULL);\n\n    if (drv->bdrv_reopen_abort) {\n        drv->bdrv_reopen_abort(reopen_state);\n    }\n\n    QDECREF(reopen_state->explicit_options);\n}\n\n\nstatic void bdrv_close(BlockDriverState *bs)\n{\n    BdrvAioNotifier *ban, *ban_next;\n\n    assert(!bs->job);\n    assert(!bs->refcnt);\n\n    bdrv_drained_begin(bs); /* complete I/O */\n    bdrv_flush(bs);\n    bdrv_drain(bs); /* in case flush left pending I/O */\n\n    bdrv_release_named_dirty_bitmaps(bs);\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n    if (bs->drv) {\n        BdrvChild *child, *next;\n\n        bs->drv->bdrv_close(bs);\n        bs->drv = NULL;\n\n        bdrv_set_backing_hd(bs, NULL, &error_abort);\n\n        if (bs->file != NULL) {\n            bdrv_unref_child(bs, bs->file);\n            bs->file = NULL;\n        }\n\n        QLIST_FOREACH_SAFE(child, &bs->children, next, next) {\n            /* TODO Remove bdrv_unref() from drivers' close function and use\n             * bdrv_unref_child() here */\n            if (child->bs->inherits_from == bs) {\n                child->bs->inherits_from = NULL;\n            }\n            bdrv_detach_child(child);\n        }\n\n        g_free(bs->opaque);\n        bs->opaque = NULL;\n        bs->copy_on_read = 0;\n        bs->backing_file[0] = '\\0';\n        bs->backing_format[0] = '\\0';\n        bs->total_sectors = 0;\n        bs->encrypted = false;\n        bs->valid_key = false;\n        bs->sg = false;\n        QDECREF(bs->options);\n        QDECREF(bs->explicit_options);\n        bs->options = NULL;\n        QDECREF(bs->full_open_options);\n        bs->full_open_options = NULL;\n    }\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n        g_free(ban);\n    }\n    QLIST_INIT(&bs->aio_notifiers);\n    bdrv_drained_end(bs);\n}\n\nvoid bdrv_close_all(void)\n{\n    block_job_cancel_sync_all();\n    nbd_export_close_all();\n\n    /* Drop references from requests still in flight, such as canceled block\n     * jobs whose AIO context has not been polled yet */\n    bdrv_drain_all();\n\n    blk_remove_all_bs();\n    blockdev_close_all_bdrv_states();\n\n    assert(QTAILQ_EMPTY(&all_bdrv_states));\n}\n\nstatic bool should_update_child(BdrvChild *c, BlockDriverState *to)\n{\n    BdrvChild *to_c;\n\n    if (c->role->stay_at_node) {\n        return false;\n    }\n\n    if (c->role == &child_backing) {\n        /* If @from is a backing file of @to, ignore the child to avoid\n         * creating a loop. We only want to change the pointer of other\n         * parents. */\n        QLIST_FOREACH(to_c, &to->children, next) {\n            if (to_c == c) {\n                break;\n            }\n        }\n        if (to_c) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid bdrv_replace_node(BlockDriverState *from, BlockDriverState *to,\n                       Error **errp)\n{\n    BdrvChild *c, *next;\n    GSList *list = NULL, *p;\n    uint64_t old_perm, old_shared;\n    uint64_t perm = 0, shared = BLK_PERM_ALL;\n    int ret;\n\n    assert(!atomic_read(&from->in_flight));\n    assert(!atomic_read(&to->in_flight));\n\n    /* Make sure that @from doesn't go away until we have successfully attached\n     * all of its parents to @to. */\n    bdrv_ref(from);\n\n    /* Put all parents into @list and calculate their cumulative permissions */\n    QLIST_FOREACH_SAFE(c, &from->parents, next_parent, next) {\n        if (!should_update_child(c, to)) {\n            continue;\n        }\n        list = g_slist_prepend(list, c);\n        perm |= c->perm;\n        shared &= c->shared_perm;\n    }\n\n    /* Check whether the required permissions can be granted on @to, ignoring\n     * all BdrvChild in @list so that they can't block themselves. */\n    ret = bdrv_check_update_perm(to, perm, shared, list, errp);\n    if (ret < 0) {\n        bdrv_abort_perm_update(to);\n        goto out;\n    }\n\n    /* Now actually perform the change. We performed the permission check for\n     * all elements of @list at once, so set the permissions all at once at the\n     * very end. */\n    for (p = list; p != NULL; p = p->next) {\n        c = p->data;\n\n        bdrv_ref(to);\n        bdrv_replace_child_noperm(c, to);\n        bdrv_unref(from);\n    }\n\n    bdrv_get_cumulative_perm(to, &old_perm, &old_shared);\n    bdrv_set_perm(to, old_perm | perm, old_shared | shared);\n\nout:\n    g_slist_free(list);\n    bdrv_unref(from);\n}\n\n/*\n * Add new bs contents at the top of an image chain while the chain is\n * live, while keeping required fields on the top layer.\n *\n * This will modify the BlockDriverState fields, and swap contents\n * between bs_new and bs_top. Both bs_new and bs_top are modified.\n *\n * bs_new must not be attached to a BlockBackend.\n *\n * This function does not create any image files.\n *\n * bdrv_append() takes ownership of a bs_new reference and unrefs it because\n * that's what the callers commonly need. bs_new will be referenced by the old\n * parents of bs_top after bdrv_append() returns. If the caller needs to keep a\n * reference of its own, it must call bdrv_ref().\n */\nvoid bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,\n                 Error **errp)\n{\n    Error *local_err = NULL;\n\n    bdrv_set_backing_hd(bs_new, bs_top, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    bdrv_replace_node(bs_top, bs_new, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        bdrv_set_backing_hd(bs_new, NULL, &error_abort);\n        goto out;\n    }\n\n    /* bs_new is now referenced by its new parents, we don't need the\n     * additional reference any more. */\nout:\n    bdrv_unref(bs_new);\n}\n\nstatic void bdrv_delete(BlockDriverState *bs)\n{\n    assert(!bs->job);\n    assert(bdrv_op_blocker_is_empty(bs));\n    assert(!bs->refcnt);\n\n    bdrv_close(bs);\n\n    /* remove from list, if necessary */\n    if (bs->node_name[0] != '\\0') {\n        QTAILQ_REMOVE(&graph_bdrv_states, bs, node_list);\n    }\n    QTAILQ_REMOVE(&all_bdrv_states, bs, bs_list);\n\n    g_free(bs);\n}\n\n/*\n * Run consistency checks on an image\n *\n * Returns 0 if the check could be completed (it doesn't mean that the image is\n * free of errors) or -errno when an internal error occurred. The results of the\n * check are stored in res.\n */\nint bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n{\n    if (bs->drv == NULL) {\n        return -ENOMEDIUM;\n    }\n    if (bs->drv->bdrv_check == NULL) {\n        return -ENOTSUP;\n    }\n\n    memset(res, 0, sizeof(*res));\n    return bs->drv->bdrv_check(bs, res, fix);\n}\n\n/*\n * Return values:\n * 0        - success\n * -EINVAL  - backing format specified, but no file\n * -ENOSPC  - can't update the backing file because no space is left in the\n *            image file header\n * -ENOTSUP - format driver doesn't support changing the backing file\n */\nint bdrv_change_backing_file(BlockDriverState *bs,\n    const char *backing_file, const char *backing_fmt)\n{\n    BlockDriver *drv = bs->drv;\n    int ret;\n\n    /* Backing file format doesn't make sense without a backing file */\n    if (backing_fmt && !backing_file) {\n        return -EINVAL;\n    }\n\n    if (drv->bdrv_change_backing_file != NULL) {\n        ret = drv->bdrv_change_backing_file(bs, backing_file, backing_fmt);\n    } else {\n        ret = -ENOTSUP;\n    }\n\n    if (ret == 0) {\n        pstrcpy(bs->backing_file, sizeof(bs->backing_file), backing_file ?: \"\");\n        pstrcpy(bs->backing_format, sizeof(bs->backing_format), backing_fmt ?: \"\");\n    }\n    return ret;\n}\n\n/*\n * Finds the image layer in the chain that has 'bs' as its backing file.\n *\n * active is the current topmost image.\n *\n * Returns NULL if bs is not found in active's image chain,\n * or if active == bs.\n *\n * Returns the bottommost base image if bs == NULL.\n */\nBlockDriverState *bdrv_find_overlay(BlockDriverState *active,\n                                    BlockDriverState *bs)\n{\n    while (active && bs != backing_bs(active)) {\n        active = backing_bs(active);\n    }\n\n    return active;\n}\n\n/* Given a BDS, searches for the base layer. */\nBlockDriverState *bdrv_find_base(BlockDriverState *bs)\n{\n    return bdrv_find_overlay(bs, NULL);\n}\n\n/*\n * Drops images above 'base' up to and including 'top', and sets the image\n * above 'top' to have base as its backing file.\n *\n * Requires that the overlay to 'top' is opened r/w, so that the backing file\n * information in 'bs' can be properly updated.\n *\n * E.g., this will convert the following chain:\n * bottom <- base <- intermediate <- top <- active\n *\n * to\n *\n * bottom <- base <- active\n *\n * It is allowed for bottom==base, in which case it converts:\n *\n * base <- intermediate <- top <- active\n *\n * to\n *\n * base <- active\n *\n * If backing_file_str is non-NULL, it will be used when modifying top's\n * overlay image metadata.\n *\n * Error conditions:\n *  if active == top, that is considered an error\n *\n */\nint bdrv_drop_intermediate(BlockDriverState *active, BlockDriverState *top,\n                           BlockDriverState *base, const char *backing_file_str)\n{\n    BlockDriverState *new_top_bs = NULL;\n    Error *local_err = NULL;\n    int ret = -EIO;\n\n    if (!top->drv || !base->drv) {\n        goto exit;\n    }\n\n    new_top_bs = bdrv_find_overlay(active, top);\n\n    if (new_top_bs == NULL) {\n        /* we could not find the image above 'top', this is an error */\n        goto exit;\n    }\n\n    /* special case of new_top_bs->backing->bs already pointing to base - nothing\n     * to do, no intermediate images */\n    if (backing_bs(new_top_bs) == base) {\n        ret = 0;\n        goto exit;\n    }\n\n    /* Make sure that base is in the backing chain of top */\n    if (!bdrv_chain_contains(top, base)) {\n        goto exit;\n    }\n\n    /* success - we can delete the intermediate states, and link top->base */\n    backing_file_str = backing_file_str ? backing_file_str : base->filename;\n    ret = bdrv_change_backing_file(new_top_bs, backing_file_str,\n                                   base->drv ? base->drv->format_name : \"\");\n    if (ret) {\n        goto exit;\n    }\n\n    bdrv_set_backing_hd(new_top_bs, base, &local_err);\n    if (local_err) {\n        ret = -EPERM;\n        error_report_err(local_err);\n        goto exit;\n    }\n\n    ret = 0;\nexit:\n    return ret;\n}\n\n/**\n * Truncate file to 'offset' bytes (needed only for file protocols)\n */\nint bdrv_truncate(BdrvChild *child, int64_t offset, Error **errp)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    int ret;\n\n    /* FIXME: Some format block drivers use this function instead of implicitly\n     *        growing their file by writing beyond its end.\n     *        See bdrv_aligned_pwritev() for an explanation why we currently\n     *        cannot assert this permission in that case. */\n    // assert(child->perm & BLK_PERM_RESIZE);\n\n    if (!drv) {\n        error_setg(errp, \"No medium inserted\");\n        return -ENOMEDIUM;\n    }\n    if (!drv->bdrv_truncate) {\n        error_setg(errp, \"Image format driver does not support resize\");\n        return -ENOTSUP;\n    }\n    if (bs->read_only) {\n        error_setg(errp, \"Image is read-only\");\n        return -EACCES;\n    }\n\n    ret = drv->bdrv_truncate(bs, offset);\n    if (ret == 0) {\n        ret = refresh_total_sectors(bs, offset >> BDRV_SECTOR_BITS);\n        bdrv_dirty_bitmap_truncate(bs);\n        bdrv_parent_cb_resize(bs);\n        ++bs->write_gen;\n    } else {\n        error_setg_errno(errp, -ret, \"Failed to resize image\");\n    }\n    return ret;\n}\n\n/**\n * Length of a allocated file in bytes. Sparse files are counted by actual\n * allocated space. Return < 0 if error or unknown.\n */\nint64_t bdrv_get_allocated_file_size(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv) {\n        return -ENOMEDIUM;\n    }\n    if (drv->bdrv_get_allocated_file_size) {\n        return drv->bdrv_get_allocated_file_size(bs);\n    }\n    if (bs->file) {\n        return bdrv_get_allocated_file_size(bs->file->bs);\n    }\n    return -ENOTSUP;\n}\n\n/**\n * Return number of sectors on success, -errno on error.\n */\nint64_t bdrv_nb_sectors(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n        return -ENOMEDIUM;\n\n    if (drv->has_variable_length) {\n        int ret = refresh_total_sectors(bs, bs->total_sectors);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    return bs->total_sectors;\n}\n\n/**\n * Return length in bytes on success, -errno on error.\n * The length is always a multiple of BDRV_SECTOR_SIZE.\n */\nint64_t bdrv_getlength(BlockDriverState *bs)\n{\n    int64_t ret = bdrv_nb_sectors(bs);\n\n    ret = ret > INT64_MAX / BDRV_SECTOR_SIZE ? -EFBIG : ret;\n    return ret < 0 ? ret : ret * BDRV_SECTOR_SIZE;\n}\n\n/* return 0 as number of sectors if no device present or error */\nvoid bdrv_get_geometry(BlockDriverState *bs, uint64_t *nb_sectors_ptr)\n{\n    int64_t nb_sectors = bdrv_nb_sectors(bs);\n\n    *nb_sectors_ptr = nb_sectors < 0 ? 0 : nb_sectors;\n}\n\nbool bdrv_is_read_only(BlockDriverState *bs)\n{\n    return bs->read_only;\n}\n\nbool bdrv_is_sg(BlockDriverState *bs)\n{\n    return bs->sg;\n}\n\nbool bdrv_is_encrypted(BlockDriverState *bs)\n{\n    if (bs->backing && bs->backing->bs->encrypted) {\n        return true;\n    }\n    return bs->encrypted;\n}\n\nbool bdrv_key_required(BlockDriverState *bs)\n{\n    BdrvChild *backing = bs->backing;\n\n    if (backing && backing->bs->encrypted && !backing->bs->valid_key) {\n        return true;\n    }\n    return (bs->encrypted && !bs->valid_key);\n}\n\nint bdrv_set_key(BlockDriverState *bs, const char *key)\n{\n    int ret;\n    if (bs->backing && bs->backing->bs->encrypted) {\n        ret = bdrv_set_key(bs->backing->bs, key);\n        if (ret < 0)\n            return ret;\n        if (!bs->encrypted)\n            return 0;\n    }\n    if (!bs->encrypted) {\n        return -EINVAL;\n    } else if (!bs->drv || !bs->drv->bdrv_set_key) {\n        return -ENOMEDIUM;\n    }\n    ret = bs->drv->bdrv_set_key(bs, key);\n    if (ret < 0) {\n        bs->valid_key = false;\n    } else if (!bs->valid_key) {\n        /* call the change callback now, we skipped it on open */\n        bs->valid_key = true;\n        bdrv_parent_cb_change_media(bs, true);\n    }\n    return ret;\n}\n\n/*\n * Provide an encryption key for @bs.\n * If @key is non-null:\n *     If @bs is not encrypted, fail.\n *     Else if the key is invalid, fail.\n *     Else set @bs's key to @key, replacing the existing key, if any.\n * If @key is null:\n *     If @bs is encrypted and still lacks a key, fail.\n *     Else do nothing.\n * On failure, store an error object through @errp if non-null.\n */\nvoid bdrv_add_key(BlockDriverState *bs, const char *key, Error **errp)\n{\n    if (key) {\n        if (!bdrv_is_encrypted(bs)) {\n            error_setg(errp, \"Node '%s' is not encrypted\",\n                      bdrv_get_device_or_node_name(bs));\n        } else if (bdrv_set_key(bs, key) < 0) {\n            error_setg(errp, QERR_INVALID_PASSWORD);\n        }\n    } else {\n        if (bdrv_key_required(bs)) {\n            error_set(errp, ERROR_CLASS_DEVICE_ENCRYPTED,\n                      \"'%s' (%s) is encrypted\",\n                      bdrv_get_device_or_node_name(bs),\n                      bdrv_get_encrypted_filename(bs));\n        }\n    }\n}\n\nconst char *bdrv_get_format_name(BlockDriverState *bs)\n{\n    return bs->drv ? bs->drv->format_name : NULL;\n}\n\nstatic int qsort_strcmp(const void *a, const void *b)\n{\n    return strcmp(*(char *const *)a, *(char *const *)b);\n}\n\nvoid bdrv_iterate_format(void (*it)(void *opaque, const char *name),\n                         void *opaque)\n{\n    BlockDriver *drv;\n    int count = 0;\n    int i;\n    const char **formats = NULL;\n\n    QLIST_FOREACH(drv, &bdrv_drivers, list) {\n        if (drv->format_name) {\n            bool found = false;\n            int i = count;\n            while (formats && i && !found) {\n                found = !strcmp(formats[--i], drv->format_name);\n            }\n\n            if (!found) {\n                formats = g_renew(const char *, formats, count + 1);\n                formats[count++] = drv->format_name;\n            }\n        }\n    }\n\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); i++) {\n        const char *format_name = block_driver_modules[i].format_name;\n\n        if (format_name) {\n            bool found = false;\n            int j = count;\n\n            while (formats && j && !found) {\n                found = !strcmp(formats[--j], format_name);\n            }\n\n            if (!found) {\n                formats = g_renew(const char *, formats, count + 1);\n                formats[count++] = format_name;\n            }\n        }\n    }\n\n    qsort(formats, count, sizeof(formats[0]), qsort_strcmp);\n\n    for (i = 0; i < count; i++) {\n        it(opaque, formats[i]);\n    }\n\n    g_free(formats);\n}\n\n/* This function is to find a node in the bs graph */\nBlockDriverState *bdrv_find_node(const char *node_name)\n{\n    BlockDriverState *bs;\n\n    assert(node_name);\n\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n        if (!strcmp(node_name, bs->node_name)) {\n            return bs;\n        }\n    }\n    return NULL;\n}\n\n/* Put this QMP function here so it can access the static graph_bdrv_states. */\nBlockDeviceInfoList *bdrv_named_nodes_list(Error **errp)\n{\n    BlockDeviceInfoList *list, *entry;\n    BlockDriverState *bs;\n\n    list = NULL;\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n        BlockDeviceInfo *info = bdrv_block_device_info(NULL, bs, errp);\n        if (!info) {\n            qapi_free_BlockDeviceInfoList(list);\n            return NULL;\n        }\n        entry = g_malloc0(sizeof(*entry));\n        entry->value = info;\n        entry->next = list;\n        list = entry;\n    }\n\n    return list;\n}\n\nBlockDriverState *bdrv_lookup_bs(const char *device,\n                                 const char *node_name,\n                                 Error **errp)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n\n    if (device) {\n        blk = blk_by_name(device);\n\n        if (blk) {\n            bs = blk_bs(blk);\n            if (!bs) {\n                error_setg(errp, \"Device '%s' has no medium\", device);\n            }\n\n            return bs;\n        }\n    }\n\n    if (node_name) {\n        bs = bdrv_find_node(node_name);\n\n        if (bs) {\n            return bs;\n        }\n    }\n\n    error_setg(errp, \"Cannot find device=%s nor node_name=%s\",\n                     device ? device : \"\",\n                     node_name ? node_name : \"\");\n    return NULL;\n}\n\n/* If 'base' is in the same chain as 'top', return true. Otherwise,\n * return false.  If either argument is NULL, return false. */\nbool bdrv_chain_contains(BlockDriverState *top, BlockDriverState *base)\n{\n    while (top && top != base) {\n        top = backing_bs(top);\n    }\n\n    return top != NULL;\n}\n\nBlockDriverState *bdrv_next_node(BlockDriverState *bs)\n{\n    if (!bs) {\n        return QTAILQ_FIRST(&graph_bdrv_states);\n    }\n    return QTAILQ_NEXT(bs, node_list);\n}\n\nconst char *bdrv_get_node_name(const BlockDriverState *bs)\n{\n    return bs->node_name;\n}\n\nconst char *bdrv_get_parent_name(const BlockDriverState *bs)\n{\n    BdrvChild *c;\n    const char *name;\n\n    /* If multiple parents have a name, just pick the first one. */\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (c->role->get_name) {\n            name = c->role->get_name(c);\n            if (name && *name) {\n                return name;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/* TODO check what callers really want: bs->node_name or blk_name() */\nconst char *bdrv_get_device_name(const BlockDriverState *bs)\n{\n    return bdrv_get_parent_name(bs) ?: \"\";\n}\n\n/* This can be used to identify nodes that might not have a device\n * name associated. Since node and device names live in the same\n * namespace, the result is unambiguous. The exception is if both are\n * absent, then this returns an empty (non-null) string. */\nconst char *bdrv_get_device_or_node_name(const BlockDriverState *bs)\n{\n    return bdrv_get_parent_name(bs) ?: bs->node_name;\n}\n\nint bdrv_get_flags(BlockDriverState *bs)\n{\n    return bs->open_flags;\n}\n\nint bdrv_has_zero_init_1(BlockDriverState *bs)\n{\n    return 1;\n}\n\nint bdrv_has_zero_init(BlockDriverState *bs)\n{\n    assert(bs->drv);\n\n    /* If BS is a copy on write image, it is initialized to\n       the contents of the base image, which may not be zeroes.  */\n    if (bs->backing) {\n        return 0;\n    }\n    if (bs->drv->bdrv_has_zero_init) {\n        return bs->drv->bdrv_has_zero_init(bs);\n    }\n\n    /* safe default */\n    return 0;\n}\n\nbool bdrv_unallocated_blocks_are_zero(BlockDriverState *bs)\n{\n    BlockDriverInfo bdi;\n\n    if (bs->backing) {\n        return false;\n    }\n\n    if (bdrv_get_info(bs, &bdi) == 0) {\n        return bdi.unallocated_blocks_are_zero;\n    }\n\n    return false;\n}\n\nbool bdrv_can_write_zeroes_with_unmap(BlockDriverState *bs)\n{\n    BlockDriverInfo bdi;\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n        return false;\n    }\n\n    if (bdrv_get_info(bs, &bdi) == 0) {\n        return bdi.can_write_zeroes_with_unmap;\n    }\n\n    return false;\n}\n\nconst char *bdrv_get_encrypted_filename(BlockDriverState *bs)\n{\n    if (bs->backing && bs->backing->bs->encrypted)\n        return bs->backing_file;\n    else if (bs->encrypted)\n        return bs->filename;\n    else\n        return NULL;\n}\n\nvoid bdrv_get_backing_filename(BlockDriverState *bs,\n                               char *filename, int filename_size)\n{\n    pstrcpy(filename, filename_size, bs->backing_file);\n}\n\nint bdrv_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_get_info)\n        return -ENOTSUP;\n    memset(bdi, 0, sizeof(*bdi));\n    return drv->bdrv_get_info(bs, bdi);\n}\n\nImageInfoSpecific *bdrv_get_specific_info(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    if (drv && drv->bdrv_get_specific_info) {\n        return drv->bdrv_get_specific_info(bs);\n    }\n    return NULL;\n}\n\nvoid bdrv_debug_event(BlockDriverState *bs, BlkdebugEvent event)\n{\n    if (!bs || !bs->drv || !bs->drv->bdrv_debug_event) {\n        return;\n    }\n\n    bs->drv->bdrv_debug_event(bs, event);\n}\n\nint bdrv_debug_breakpoint(BlockDriverState *bs, const char *event,\n                          const char *tag)\n{\n    while (bs && bs->drv && !bs->drv->bdrv_debug_breakpoint) {\n        bs = bs->file ? bs->file->bs : NULL;\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_breakpoint) {\n        return bs->drv->bdrv_debug_breakpoint(bs, event, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nint bdrv_debug_remove_breakpoint(BlockDriverState *bs, const char *tag)\n{\n    while (bs && bs->drv && !bs->drv->bdrv_debug_remove_breakpoint) {\n        bs = bs->file ? bs->file->bs : NULL;\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_remove_breakpoint) {\n        return bs->drv->bdrv_debug_remove_breakpoint(bs, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nint bdrv_debug_resume(BlockDriverState *bs, const char *tag)\n{\n    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {\n        bs = bs->file ? bs->file->bs : NULL;\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {\n        return bs->drv->bdrv_debug_resume(bs, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nbool bdrv_debug_is_suspended(BlockDriverState *bs, const char *tag)\n{\n    while (bs && bs->drv && !bs->drv->bdrv_debug_is_suspended) {\n        bs = bs->file ? bs->file->bs : NULL;\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_is_suspended) {\n        return bs->drv->bdrv_debug_is_suspended(bs, tag);\n    }\n\n    return false;\n}\n\n/* backing_file can either be relative, or absolute, or a protocol.  If it is\n * relative, it must be relative to the chain.  So, passing in bs->filename\n * from a BDS as backing_file should not be done, as that may be relative to\n * the CWD rather than the chain. */\nBlockDriverState *bdrv_find_backing_image(BlockDriverState *bs,\n        const char *backing_file)\n{\n    char *filename_full = NULL;\n    char *backing_file_full = NULL;\n    char *filename_tmp = NULL;\n    int is_protocol = 0;\n    BlockDriverState *curr_bs = NULL;\n    BlockDriverState *retval = NULL;\n    Error *local_error = NULL;\n\n    if (!bs || !bs->drv || !backing_file) {\n        return NULL;\n    }\n\n    filename_full     = g_malloc(PATH_MAX);\n    backing_file_full = g_malloc(PATH_MAX);\n    filename_tmp      = g_malloc(PATH_MAX);\n\n    is_protocol = path_has_protocol(backing_file);\n\n    for (curr_bs = bs; curr_bs->backing; curr_bs = curr_bs->backing->bs) {\n\n        /* If either of the filename paths is actually a protocol, then\n         * compare unmodified paths; otherwise make paths relative */\n        if (is_protocol || path_has_protocol(curr_bs->backing_file)) {\n            if (strcmp(backing_file, curr_bs->backing_file) == 0) {\n                retval = curr_bs->backing->bs;\n                break;\n            }\n            /* Also check against the full backing filename for the image */\n            bdrv_get_full_backing_filename(curr_bs, backing_file_full, PATH_MAX,\n                                           &local_error);\n            if (local_error == NULL) {\n                if (strcmp(backing_file, backing_file_full) == 0) {\n                    retval = curr_bs->backing->bs;\n                    break;\n                }\n            } else {\n                error_free(local_error);\n                local_error = NULL;\n            }\n        } else {\n            /* If not an absolute filename path, make it relative to the current\n             * image's filename path */\n            path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n                         backing_file);\n\n            /* We are going to compare absolute pathnames */\n            if (!realpath(filename_tmp, filename_full)) {\n                continue;\n            }\n\n            /* We need to make sure the backing filename we are comparing against\n             * is relative to the current image filename (or absolute) */\n            path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n                         curr_bs->backing_file);\n\n            if (!realpath(filename_tmp, backing_file_full)) {\n                continue;\n            }\n\n            if (strcmp(backing_file_full, filename_full) == 0) {\n                retval = curr_bs->backing->bs;\n                break;\n            }\n        }\n    }\n\n    g_free(filename_full);\n    g_free(backing_file_full);\n    g_free(filename_tmp);\n    return retval;\n}\n\nvoid bdrv_init(void)\n{\n    module_call_init(MODULE_INIT_BLOCK);\n}\n\nvoid bdrv_init_with_whitelist(void)\n{\n    use_bdrv_whitelist = 1;\n    bdrv_init();\n}\n\nvoid bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n{\n    BdrvChild *child;\n    Error *local_err = NULL;\n    int ret;\n\n    if (!bs->drv)  {\n        return;\n    }\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n        return;\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        bdrv_invalidate_cache(child->bs, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n    if (bs->drv->bdrv_invalidate_cache) {\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n        if (local_err) {\n            bs->open_flags |= BDRV_O_INACTIVE;\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n    if (ret < 0) {\n        bs->open_flags |= BDRV_O_INACTIVE;\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n        return;\n    }\n}\n\nvoid bdrv_invalidate_cache_all(Error **errp)\n{\n    BlockDriverState *bs;\n    Error *local_err = NULL;\n    BdrvNextIterator it;\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n        aio_context_acquire(aio_context);\n        bdrv_invalidate_cache(bs, &local_err);\n        aio_context_release(aio_context);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nstatic int bdrv_inactivate_recurse(BlockDriverState *bs,\n                                   bool setting_flag)\n{\n    BdrvChild *child;\n    int ret;\n\n    if (!setting_flag && bs->drv->bdrv_inactivate) {\n        ret = bs->drv->bdrv_inactivate(bs);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        ret = bdrv_inactivate_recurse(child->bs, setting_flag);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    if (setting_flag) {\n        bs->open_flags |= BDRV_O_INACTIVE;\n    }\n    return 0;\n}\n\nint bdrv_inactivate_all(void)\n{\n    BlockDriverState *bs = NULL;\n    BdrvNextIterator it;\n    int ret = 0;\n    int pass;\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        aio_context_acquire(bdrv_get_aio_context(bs));\n    }\n\n    /* We do two passes of inactivation. The first pass calls to drivers'\n     * .bdrv_inactivate callbacks recursively so all cache is flushed to disk;\n     * the second pass sets the BDRV_O_INACTIVE flag so that no further write\n     * is allowed. */\n    for (pass = 0; pass < 2; pass++) {\n        for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n            ret = bdrv_inactivate_recurse(bs, pass);\n            if (ret < 0) {\n                goto out;\n            }\n        }\n    }\n\nout:\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        aio_context_release(bdrv_get_aio_context(bs));\n    }\n\n    return ret;\n}\n\n/**************************************************************/\n/* removable device support */\n\n/**\n * Return TRUE if the media is present\n */\nbool bdrv_is_inserted(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *child;\n\n    if (!drv) {\n        return false;\n    }\n    if (drv->bdrv_is_inserted) {\n        return drv->bdrv_is_inserted(bs);\n    }\n    QLIST_FOREACH(child, &bs->children, next) {\n        if (!bdrv_is_inserted(child->bs)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Return whether the media changed since the last call to this\n * function, or -ENOTSUP if we don't know.  Most drivers don't know.\n */\nint bdrv_media_changed(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_media_changed) {\n        return drv->bdrv_media_changed(bs);\n    }\n    return -ENOTSUP;\n}\n\n/**\n * If eject_flag is TRUE, eject the media. Otherwise, close the tray\n */\nvoid bdrv_eject(BlockDriverState *bs, bool eject_flag)\n{\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_eject) {\n        drv->bdrv_eject(bs, eject_flag);\n    }\n}\n\n/**\n * Lock or unlock the media (if it is locked, the user won't be able\n * to eject it manually).\n */\nvoid bdrv_lock_medium(BlockDriverState *bs, bool locked)\n{\n    BlockDriver *drv = bs->drv;\n\n    trace_bdrv_lock_medium(bs, locked);\n\n    if (drv && drv->bdrv_lock_medium) {\n        drv->bdrv_lock_medium(bs, locked);\n    }\n}\n\n/* Get a reference to bs */\nvoid bdrv_ref(BlockDriverState *bs)\n{\n    bs->refcnt++;\n}\n\n/* Release a previously grabbed reference to bs.\n * If after releasing, reference count is zero, the BlockDriverState is\n * deleted. */\nvoid bdrv_unref(BlockDriverState *bs)\n{\n    if (!bs) {\n        return;\n    }\n    assert(bs->refcnt > 0);\n    if (--bs->refcnt == 0) {\n        bdrv_delete(bs);\n    }\n}\n\nstruct BdrvOpBlocker {\n    Error *reason;\n    QLIST_ENTRY(BdrvOpBlocker) list;\n};\n\nbool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n{\n    BdrvOpBlocker *blocker;\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n        if (errp) {\n            *errp = error_copy(blocker->reason);\n            error_prepend(errp, \"Node '%s' is busy: \",\n                          bdrv_get_device_or_node_name(bs));\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid bdrv_op_block(BlockDriverState *bs, BlockOpType op, Error *reason)\n{\n    BdrvOpBlocker *blocker;\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    blocker = g_new0(BdrvOpBlocker, 1);\n    blocker->reason = reason;\n    QLIST_INSERT_HEAD(&bs->op_blockers[op], blocker, list);\n}\n\nvoid bdrv_op_unblock(BlockDriverState *bs, BlockOpType op, Error *reason)\n{\n    BdrvOpBlocker *blocker, *next;\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n    QLIST_FOREACH_SAFE(blocker, &bs->op_blockers[op], list, next) {\n        if (blocker->reason == reason) {\n            QLIST_REMOVE(blocker, list);\n            g_free(blocker);\n        }\n    }\n}\n\nvoid bdrv_op_block_all(BlockDriverState *bs, Error *reason)\n{\n    int i;\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        bdrv_op_block(bs, i, reason);\n    }\n}\n\nvoid bdrv_op_unblock_all(BlockDriverState *bs, Error *reason)\n{\n    int i;\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        bdrv_op_unblock(bs, i, reason);\n    }\n}\n\nbool bdrv_op_blocker_is_empty(BlockDriverState *bs)\n{\n    int i;\n\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        if (!QLIST_EMPTY(&bs->op_blockers[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid bdrv_img_create(const char *filename, const char *fmt,\n                     const char *base_filename, const char *base_fmt,\n                     char *options, uint64_t img_size, int flags,\n                     Error **errp, bool quiet)\n{\n    QemuOptsList *create_opts = NULL;\n    QemuOpts *opts = NULL;\n    const char *backing_fmt, *backing_file;\n    int64_t size;\n    BlockDriver *drv, *proto_drv;\n    Error *local_err = NULL;\n    int ret = 0;\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(fmt);\n    if (!drv) {\n        error_setg(errp, \"Unknown file format '%s'\", fmt);\n        return;\n    }\n\n    proto_drv = bdrv_find_protocol(filename, true, errp);\n    if (!proto_drv) {\n        return;\n    }\n\n    if (!drv->create_opts) {\n        error_setg(errp, \"Format driver '%s' does not support image creation\",\n                   drv->format_name);\n        return;\n    }\n\n    if (!proto_drv->create_opts) {\n        error_setg(errp, \"Protocol driver '%s' does not support image creation\",\n                   proto_drv->format_name);\n        return;\n    }\n\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n    /* Create parameter list with default values */\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n    qemu_opt_set_number(opts, BLOCK_OPT_SIZE, img_size, &error_abort);\n\n    /* Parse -o options */\n    if (options) {\n        qemu_opts_do_parse(opts, options, NULL, &local_err);\n        if (local_err) {\n            error_report_err(local_err);\n            local_err = NULL;\n            error_setg(errp, \"Invalid options for file format '%s'\", fmt);\n            goto out;\n        }\n    }\n\n    if (base_filename) {\n        qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename, &local_err);\n        if (local_err) {\n            error_setg(errp, \"Backing file not supported for file format '%s'\",\n                       fmt);\n            goto out;\n        }\n    }\n\n    if (base_fmt) {\n        qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, &local_err);\n        if (local_err) {\n            error_setg(errp, \"Backing file format not supported for file \"\n                             \"format '%s'\", fmt);\n            goto out;\n        }\n    }\n\n    backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n    if (backing_file) {\n        if (!strcmp(filename, backing_file)) {\n            error_setg(errp, \"Error: Trying to create an image with the \"\n                             \"same filename as the backing file\");\n            goto out;\n        }\n    }\n\n    backing_fmt = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n\n    // The size for the image must always be specified, with one exception:\n    // If we are using a backing file, we can obtain the size from there\n    size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, 0);\n    if (size == -1) {\n        if (backing_file) {\n            BlockDriverState *bs;\n            char *full_backing = g_new0(char, PATH_MAX);\n            int64_t size;\n            int back_flags;\n            QDict *backing_options = NULL;\n\n            bdrv_get_full_backing_filename_from_filename(filename, backing_file,\n                                                         full_backing, PATH_MAX,\n                                                         &local_err);\n            if (local_err) {\n                g_free(full_backing);\n                goto out;\n            }\n\n            /* backing files always opened read-only */\n            back_flags = flags;\n            back_flags &= ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING);\n\n            if (backing_fmt) {\n                backing_options = qdict_new();\n                qdict_put_str(backing_options, \"driver\", backing_fmt);\n            }\n\n            bs = bdrv_open(full_backing, NULL, backing_options, back_flags,\n                           &local_err);\n            g_free(full_backing);\n            if (!bs) {\n                goto out;\n            }\n            size = bdrv_getlength(bs);\n            if (size < 0) {\n                error_setg_errno(errp, -size, \"Could not get size of '%s'\",\n                                 backing_file);\n                bdrv_unref(bs);\n                goto out;\n            }\n\n            qemu_opt_set_number(opts, BLOCK_OPT_SIZE, size, &error_abort);\n\n            bdrv_unref(bs);\n        } else {\n            error_setg(errp, \"Image creation needs a size parameter\");\n            goto out;\n        }\n    }\n\n    if (!quiet) {\n        printf(\"Formatting '%s', fmt=%s \", filename, fmt);\n        qemu_opts_print(opts, \" \");\n        puts(\"\");\n    }\n\n    ret = bdrv_create(drv, filename, opts, &local_err);\n\n    if (ret == -EFBIG) {\n        /* This is generally a better message than whatever the driver would\n         * deliver (especially because of the cluster_size_hint), since that\n         * is most probably not much different from \"image too large\". */\n        const char *cluster_size_hint = \"\";\n        if (qemu_opt_get_size(opts, BLOCK_OPT_CLUSTER_SIZE, 0)) {\n            cluster_size_hint = \" (try using a larger cluster size)\";\n        }\n        error_setg(errp, \"The image size is too large for file format '%s'\"\n                   \"%s\", fmt, cluster_size_hint);\n        error_free(local_err);\n        local_err = NULL;\n    }\n\nout:\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    error_propagate(errp, local_err);\n}\n\nAioContext *bdrv_get_aio_context(BlockDriverState *bs)\n{\n    return bs->aio_context;\n}\n\nvoid bdrv_coroutine_enter(BlockDriverState *bs, Coroutine *co)\n{\n    aio_co_enter(bdrv_get_aio_context(bs), co);\n}\n\nstatic void bdrv_do_remove_aio_context_notifier(BdrvAioNotifier *ban)\n{\n    QLIST_REMOVE(ban, list);\n    g_free(ban);\n}\n\nvoid bdrv_detach_aio_context(BlockDriverState *bs)\n{\n    BdrvAioNotifier *baf, *baf_tmp;\n    BdrvChild *child;\n\n    if (!bs->drv) {\n        return;\n    }\n\n    assert(!bs->walking_aio_notifiers);\n    bs->walking_aio_notifiers = true;\n    QLIST_FOREACH_SAFE(baf, &bs->aio_notifiers, list, baf_tmp) {\n        if (baf->deleted) {\n            bdrv_do_remove_aio_context_notifier(baf);\n        } else {\n            baf->detach_aio_context(baf->opaque);\n        }\n    }\n    /* Never mind iterating again to check for ->deleted.  bdrv_close() will\n     * remove remaining aio notifiers if we aren't called again.\n     */\n    bs->walking_aio_notifiers = false;\n\n    if (bs->drv->bdrv_detach_aio_context) {\n        bs->drv->bdrv_detach_aio_context(bs);\n    }\n    QLIST_FOREACH(child, &bs->children, next) {\n        bdrv_detach_aio_context(child->bs);\n    }\n\n    bs->aio_context = NULL;\n}\n\nvoid bdrv_attach_aio_context(BlockDriverState *bs,\n                             AioContext *new_context)\n{\n    BdrvAioNotifier *ban, *ban_tmp;\n    BdrvChild *child;\n\n    if (!bs->drv) {\n        return;\n    }\n\n    bs->aio_context = new_context;\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        bdrv_attach_aio_context(child->bs, new_context);\n    }\n    if (bs->drv->bdrv_attach_aio_context) {\n        bs->drv->bdrv_attach_aio_context(bs, new_context);\n    }\n\n    assert(!bs->walking_aio_notifiers);\n    bs->walking_aio_notifiers = true;\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_tmp) {\n        if (ban->deleted) {\n            bdrv_do_remove_aio_context_notifier(ban);\n        } else {\n            ban->attached_aio_context(new_context, ban->opaque);\n        }\n    }\n    bs->walking_aio_notifiers = false;\n}\n\nvoid bdrv_set_aio_context(BlockDriverState *bs, AioContext *new_context)\n{\n    AioContext *ctx = bdrv_get_aio_context(bs);\n\n    aio_disable_external(ctx);\n    bdrv_parent_drained_begin(bs);\n    bdrv_drain(bs); /* ensure there are no in-flight requests */\n\n    while (aio_poll(ctx, false)) {\n        /* wait for all bottom halves to execute */\n    }\n\n    bdrv_detach_aio_context(bs);\n\n    /* This function executes in the old AioContext so acquire the new one in\n     * case it runs in a different thread.\n     */\n    aio_context_acquire(new_context);\n    bdrv_attach_aio_context(bs, new_context);\n    bdrv_parent_drained_end(bs);\n    aio_enable_external(ctx);\n    aio_context_release(new_context);\n}\n\nvoid bdrv_add_aio_context_notifier(BlockDriverState *bs,\n        void (*attached_aio_context)(AioContext *new_context, void *opaque),\n        void (*detach_aio_context)(void *opaque), void *opaque)\n{\n    BdrvAioNotifier *ban = g_new(BdrvAioNotifier, 1);\n    *ban = (BdrvAioNotifier){\n        .attached_aio_context = attached_aio_context,\n        .detach_aio_context   = detach_aio_context,\n        .opaque               = opaque\n    };\n\n    QLIST_INSERT_HEAD(&bs->aio_notifiers, ban, list);\n}\n\nvoid bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n                                      void (*attached_aio_context)(AioContext *,\n                                                                   void *),\n                                      void (*detach_aio_context)(void *),\n                                      void *opaque)\n{\n    BdrvAioNotifier *ban, *ban_next;\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n        if (ban->attached_aio_context == attached_aio_context &&\n            ban->detach_aio_context   == detach_aio_context   &&\n            ban->opaque               == opaque               &&\n            ban->deleted              == false)\n        {\n            if (bs->walking_aio_notifiers) {\n                ban->deleted = true;\n            } else {\n                bdrv_do_remove_aio_context_notifier(ban);\n            }\n            return;\n        }\n    }\n\n    abort();\n}\n\nint bdrv_amend_options(BlockDriverState *bs, QemuOpts *opts,\n                       BlockDriverAmendStatusCB *status_cb, void *cb_opaque)\n{\n    if (!bs->drv->bdrv_amend_options) {\n        return -ENOTSUP;\n    }\n    return bs->drv->bdrv_amend_options(bs, opts, status_cb, cb_opaque);\n}\n\n/* This function will be called by the bdrv_recurse_is_first_non_filter method\n * of block filter and by bdrv_is_first_non_filter.\n * It is used to test if the given bs is the candidate or recurse more in the\n * node graph.\n */\nbool bdrv_recurse_is_first_non_filter(BlockDriverState *bs,\n                                      BlockDriverState *candidate)\n{\n    /* return false if basic checks fails */\n    if (!bs || !bs->drv) {\n        return false;\n    }\n\n    /* the code reached a non block filter driver -> check if the bs is\n     * the same as the candidate. It's the recursion termination condition.\n     */\n    if (!bs->drv->is_filter) {\n        return bs == candidate;\n    }\n    /* Down this path the driver is a block filter driver */\n\n    /* If the block filter recursion method is defined use it to recurse down\n     * the node graph.\n     */\n    if (bs->drv->bdrv_recurse_is_first_non_filter) {\n        return bs->drv->bdrv_recurse_is_first_non_filter(bs, candidate);\n    }\n\n    /* the driver is a block filter but don't allow to recurse -> return false\n     */\n    return false;\n}\n\n/* This function checks if the candidate is the first non filter bs down it's\n * bs chain. Since we don't have pointers to parents it explore all bs chains\n * from the top. Some filters can choose not to pass down the recursion.\n */\nbool bdrv_is_first_non_filter(BlockDriverState *candidate)\n{\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    /* walk down the bs forest recursively */\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        bool perm;\n\n        /* try to recurse in this top level bs */\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n        /* candidate is the first non filter */\n        if (perm) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nBlockDriverState *check_to_replace_node(BlockDriverState *parent_bs,\n                                        const char *node_name, Error **errp)\n{\n    BlockDriverState *to_replace_bs = bdrv_find_node(node_name);\n    AioContext *aio_context;\n\n    if (!to_replace_bs) {\n        error_setg(errp, \"Node name '%s' not found\", node_name);\n        return NULL;\n    }\n\n    aio_context = bdrv_get_aio_context(to_replace_bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(to_replace_bs, BLOCK_OP_TYPE_REPLACE, errp)) {\n        to_replace_bs = NULL;\n        goto out;\n    }\n\n    /* We don't want arbitrary node of the BDS chain to be replaced only the top\n     * most non filter in order to prevent data corruption.\n     * Another benefit is that this tests exclude backing files which are\n     * blocked by the backing blockers.\n     */\n    if (!bdrv_recurse_is_first_non_filter(parent_bs, to_replace_bs)) {\n        error_setg(errp, \"Only top most non filter can be replaced\");\n        to_replace_bs = NULL;\n        goto out;\n    }\n\nout:\n    aio_context_release(aio_context);\n    return to_replace_bs;\n}\n\nstatic bool append_open_options(QDict *d, BlockDriverState *bs)\n{\n    const QDictEntry *entry;\n    QemuOptDesc *desc;\n    BdrvChild *child;\n    bool found_any = false;\n    const char *p;\n\n    for (entry = qdict_first(bs->options); entry;\n         entry = qdict_next(bs->options, entry))\n    {\n        /* Exclude options for children */\n        QLIST_FOREACH(child, &bs->children, next) {\n            if (strstart(qdict_entry_key(entry), child->name, &p)\n                && (!*p || *p == '.'))\n            {\n                break;\n            }\n        }\n        if (child) {\n            continue;\n        }\n\n        /* And exclude all non-driver-specific options */\n        for (desc = bdrv_runtime_opts.desc; desc->name; desc++) {\n            if (!strcmp(qdict_entry_key(entry), desc->name)) {\n                break;\n            }\n        }\n        if (desc->name) {\n            continue;\n        }\n\n        qobject_incref(qdict_entry_value(entry));\n        qdict_put_obj(d, qdict_entry_key(entry), qdict_entry_value(entry));\n        found_any = true;\n    }\n\n    return found_any;\n}\n\n/* Updates the following BDS fields:\n *  - exact_filename: A filename which may be used for opening a block device\n *                    which (mostly) equals the given BDS (even without any\n *                    other options; so reading and writing must return the same\n *                    results, but caching etc. may be different)\n *  - full_open_options: Options which, when given when opening a block device\n *                       (without a filename), result in a BDS (mostly)\n *                       equalling the given one\n *  - filename: If exact_filename is set, it is copied here. Otherwise,\n *              full_open_options is converted to a JSON object, prefixed with\n *              \"json:\" (for use through the JSON pseudo protocol) and put here.\n */\nvoid bdrv_refresh_filename(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    QDict *opts;\n\n    if (!drv) {\n        return;\n    }\n\n    /* This BDS's file name will most probably depend on its file's name, so\n     * refresh that first */\n    if (bs->file) {\n        bdrv_refresh_filename(bs->file->bs);\n    }\n\n    if (drv->bdrv_refresh_filename) {\n        /* Obsolete information is of no use here, so drop the old file name\n         * information before refreshing it */\n        bs->exact_filename[0] = '\\0';\n        if (bs->full_open_options) {\n            QDECREF(bs->full_open_options);\n            bs->full_open_options = NULL;\n        }\n\n        opts = qdict_new();\n        append_open_options(opts, bs);\n        drv->bdrv_refresh_filename(bs, opts);\n        QDECREF(opts);\n    } else if (bs->file) {\n        /* Try to reconstruct valid information from the underlying file */\n        bool has_open_options;\n\n        bs->exact_filename[0] = '\\0';\n        if (bs->full_open_options) {\n            QDECREF(bs->full_open_options);\n            bs->full_open_options = NULL;\n        }\n\n        opts = qdict_new();\n        has_open_options = append_open_options(opts, bs);\n\n        /* If no specific options have been given for this BDS, the filename of\n         * the underlying file should suffice for this one as well */\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n        }\n        /* Reconstructing the full options QDict is simple for most format block\n         * drivers, as long as the full options are known for the underlying\n         * file BDS. The full options QDict of that file BDS should somehow\n         * contain a representation of the filename, therefore the following\n         * suffices without querying the (exact_)filename of this BDS. */\n        if (bs->file->bs->full_open_options) {\n            qdict_put_str(opts, \"driver\", drv->format_name);\n            QINCREF(bs->file->bs->full_open_options);\n            qdict_put(opts, \"file\", bs->file->bs->full_open_options);\n\n            bs->full_open_options = opts;\n        } else {\n            QDECREF(opts);\n        }\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n         * so the full options QDict should be equal to the options given\n         * specifically for this block device when it was opened (plus the\n         * driver specification).\n         * Because those options don't change, there is no need to update\n         * full_open_options when it's already set. */\n\n        opts = qdict_new();\n        append_open_options(opts, bs);\n        qdict_put_str(opts, \"driver\", drv->format_name);\n\n        if (bs->exact_filename[0]) {\n            /* This may not work for all block protocol drivers (some may\n             * require this filename to be parsed), but we have to find some\n             * default solution here, so just include it. If some block driver\n             * does not support pure options without any filename at all or\n             * needs some special format of the options QDict, it needs to\n             * implement the driver-specific bdrv_refresh_filename() function.\n             */\n            qdict_put_str(opts, \"filename\", bs->exact_filename);\n        }\n\n        bs->full_open_options = opts;\n    }\n\n    if (bs->exact_filename[0]) {\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n    } else if (bs->full_open_options) {\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n                 qstring_get_str(json));\n        QDECREF(json);\n    }\n}\n\n/*\n * Hot add/remove a BDS's child. So the user can take a child offline when\n * it is broken and take a new child online\n */\nvoid bdrv_add_child(BlockDriverState *parent_bs, BlockDriverState *child_bs,\n                    Error **errp)\n{\n\n    if (!parent_bs->drv || !parent_bs->drv->bdrv_add_child) {\n        error_setg(errp, \"The node %s does not support adding a child\",\n                   bdrv_get_device_or_node_name(parent_bs));\n        return;\n    }\n\n    if (!QLIST_EMPTY(&child_bs->parents)) {\n        error_setg(errp, \"The node %s already has a parent\",\n                   child_bs->node_name);\n        return;\n    }\n\n    parent_bs->drv->bdrv_add_child(parent_bs, child_bs, errp);\n}\n\nvoid bdrv_del_child(BlockDriverState *parent_bs, BdrvChild *child, Error **errp)\n{\n    BdrvChild *tmp;\n\n    if (!parent_bs->drv || !parent_bs->drv->bdrv_del_child) {\n        error_setg(errp, \"The node %s does not support removing a child\",\n                   bdrv_get_device_or_node_name(parent_bs));\n        return;\n    }\n\n    QLIST_FOREACH(tmp, &parent_bs->children, next) {\n        if (tmp == child) {\n            break;\n        }\n    }\n\n    if (!tmp) {\n        error_setg(errp, \"The node %s does not have a child named %s\",\n                   bdrv_get_device_or_node_name(parent_bs),\n                   bdrv_get_device_or_node_name(child->bs));\n        return;\n    }\n\n    parent_bs->drv->bdrv_del_child(parent_bs, child, errp);\n}\n"
        },
        {
          "name": "block",
          "type": "tree",
          "content": null
        },
        {
          "name": "blockdev-nbd.c",
          "type": "blob",
          "size": 4.8798828125,
          "content": "/*\n * Serving QEMU block devices via NBD\n *\n * Copyright (c) 2012 Red Hat, Inc.\n *\n * Author: Paolo Bonzini <pbonzini@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or\n * later.  See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/blockdev.h\"\n#include \"sysemu/block-backend.h\"\n#include \"hw/block/block.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qmp-commands.h\"\n#include \"block/nbd.h\"\n#include \"io/channel-socket.h\"\n\ntypedef struct NBDServerData {\n    QIOChannelSocket *listen_ioc;\n    int watch;\n    QCryptoTLSCreds *tlscreds;\n} NBDServerData;\n\nstatic NBDServerData *nbd_server;\n\nstatic void nbd_blockdev_client_closed(NBDClient *client, bool ignored)\n{\n    nbd_client_put(client);\n}\n\nstatic gboolean nbd_accept(QIOChannel *ioc, GIOCondition condition,\n                           gpointer opaque)\n{\n    QIOChannelSocket *cioc;\n\n    if (!nbd_server) {\n        return FALSE;\n    }\n\n    cioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc),\n                                     NULL);\n    if (!cioc) {\n        return TRUE;\n    }\n\n    qio_channel_set_name(QIO_CHANNEL(cioc), \"nbd-server\");\n    nbd_client_new(NULL, cioc,\n                   nbd_server->tlscreds, NULL,\n                   nbd_blockdev_client_closed);\n    object_unref(OBJECT(cioc));\n    return TRUE;\n}\n\n\nstatic void nbd_server_free(NBDServerData *server)\n{\n    if (!server) {\n        return;\n    }\n\n    if (server->watch != -1) {\n        g_source_remove(server->watch);\n    }\n    object_unref(OBJECT(server->listen_ioc));\n    if (server->tlscreds) {\n        object_unref(OBJECT(server->tlscreds));\n    }\n\n    g_free(server);\n}\n\nstatic QCryptoTLSCreds *nbd_get_tls_creds(const char *id, Error **errp)\n{\n    Object *obj;\n    QCryptoTLSCreds *creds;\n\n    obj = object_resolve_path_component(\n        object_get_objects_root(), id);\n    if (!obj) {\n        error_setg(errp, \"No TLS credentials with id '%s'\",\n                   id);\n        return NULL;\n    }\n    creds = (QCryptoTLSCreds *)\n        object_dynamic_cast(obj, TYPE_QCRYPTO_TLS_CREDS);\n    if (!creds) {\n        error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                   id);\n        return NULL;\n    }\n\n    if (creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n        error_setg(errp,\n                   \"Expecting TLS credentials with a server endpoint\");\n        return NULL;\n    }\n    object_ref(obj);\n    return creds;\n}\n\n\nvoid qmp_nbd_server_start(SocketAddress *addr,\n                          bool has_tls_creds, const char *tls_creds,\n                          Error **errp)\n{\n    if (nbd_server) {\n        error_setg(errp, \"NBD server already running\");\n        return;\n    }\n\n    nbd_server = g_new0(NBDServerData, 1);\n    nbd_server->watch = -1;\n    nbd_server->listen_ioc = qio_channel_socket_new();\n    qio_channel_set_name(QIO_CHANNEL(nbd_server->listen_ioc),\n                         \"nbd-listener\");\n    if (qio_channel_socket_listen_sync(\n            nbd_server->listen_ioc, addr, errp) < 0) {\n        goto error;\n    }\n\n    if (has_tls_creds) {\n        nbd_server->tlscreds = nbd_get_tls_creds(tls_creds, errp);\n        if (!nbd_server->tlscreds) {\n            goto error;\n        }\n\n        /* TODO SOCKET_ADDRESS_KIND_FD where fd has AF_INET or AF_INET6 */\n        if (addr->type != SOCKET_ADDRESS_KIND_INET) {\n            error_setg(errp, \"TLS is only supported with IPv4/IPv6\");\n            goto error;\n        }\n    }\n\n    nbd_server->watch = qio_channel_add_watch(\n        QIO_CHANNEL(nbd_server->listen_ioc),\n        G_IO_IN,\n        nbd_accept,\n        NULL,\n        NULL);\n\n    return;\n\n error:\n    nbd_server_free(nbd_server);\n    nbd_server = NULL;\n}\n\nvoid qmp_nbd_server_add(const char *device, bool has_writable, bool writable,\n                        Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    BlockBackend *on_eject_blk;\n    NBDExport *exp;\n\n    if (!nbd_server) {\n        error_setg(errp, \"NBD server not running\");\n        return;\n    }\n\n    if (nbd_export_find(device)) {\n        error_setg(errp, \"NBD server already exporting device '%s'\", device);\n        return;\n    }\n\n    on_eject_blk = blk_by_name(device);\n\n    bs = bdrv_lookup_bs(device, device, errp);\n    if (!bs) {\n        return;\n    }\n\n    if (!has_writable) {\n        writable = false;\n    }\n    if (bdrv_is_read_only(bs)) {\n        writable = false;\n    }\n\n    exp = nbd_export_new(bs, 0, -1, writable ? 0 : NBD_FLAG_READ_ONLY,\n                         NULL, false, on_eject_blk, errp);\n    if (!exp) {\n        return;\n    }\n\n    nbd_export_set_name(exp, device);\n\n    /* The list of named exports has a strong reference to this export now and\n     * our only way of accessing it is through nbd_export_find(), so we can drop\n     * the strong reference that is @exp. */\n    nbd_export_put(exp);\n}\n\nvoid qmp_nbd_server_stop(Error **errp)\n{\n    nbd_export_close_all();\n\n    nbd_server_free(nbd_server);\n    nbd_server = NULL;\n}\n"
        },
        {
          "name": "blockdev.c",
          "type": "blob",
          "size": 119.2236328125,
          "content": "/*\n * QEMU host block devices\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or\n * later.  See the COPYING file in the top-level directory.\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/blockdev.h\"\n#include \"hw/block/block.h\"\n#include \"block/blockjob.h\"\n#include \"block/throttle-groups.h\"\n#include \"monitor/monitor.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n#include \"qapi/qmp/types.h\"\n#include \"qapi-visit.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qobject-output-visitor.h\"\n#include \"qapi/util.h\"\n#include \"sysemu/sysemu.h\"\n#include \"block/block_int.h\"\n#include \"qmp-commands.h\"\n#include \"block/trace.h\"\n#include \"sysemu/arch_init.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/help_option.h\"\n#include \"qemu/throttle-options.h\"\n\nstatic QTAILQ_HEAD(, BlockDriverState) monitor_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(monitor_bdrv_states);\n\nstatic int do_open_tray(const char *blk_name, const char *qdev_id,\n                        bool force, Error **errp);\n\nstatic const char *const if_name[IF_COUNT] = {\n    [IF_NONE] = \"none\",\n    [IF_IDE] = \"ide\",\n    [IF_SCSI] = \"scsi\",\n    [IF_FLOPPY] = \"floppy\",\n    [IF_PFLASH] = \"pflash\",\n    [IF_MTD] = \"mtd\",\n    [IF_SD] = \"sd\",\n    [IF_VIRTIO] = \"virtio\",\n    [IF_XEN] = \"xen\",\n};\n\nstatic int if_max_devs[IF_COUNT] = {\n    /*\n     * Do not change these numbers!  They govern how drive option\n     * index maps to unit and bus.  That mapping is ABI.\n     *\n     * All controllers used to implement if=T drives need to support\n     * if_max_devs[T] units, for any T with if_max_devs[T] != 0.\n     * Otherwise, some index values map to \"impossible\" bus, unit\n     * values.\n     *\n     * For instance, if you change [IF_SCSI] to 255, -drive\n     * if=scsi,index=12 no longer means bus=1,unit=5, but\n     * bus=0,unit=12.  With an lsi53c895a controller (7 units max),\n     * the drive can't be set up.  Regression.\n     */\n    [IF_IDE] = 2,\n    [IF_SCSI] = 7,\n};\n\n/**\n * Boards may call this to offer board-by-board overrides\n * of the default, global values.\n */\nvoid override_max_devs(BlockInterfaceType type, int max_devs)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    if (max_devs <= 0) {\n        return;\n    }\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo->type == type) {\n            fprintf(stderr, \"Cannot override units-per-bus property of\"\n                    \" the %s interface, because a drive of that type has\"\n                    \" already been added.\\n\", if_name[type]);\n            g_assert_not_reached();\n        }\n    }\n\n    if_max_devs[type] = max_devs;\n}\n\n/*\n * We automatically delete the drive when a device using it gets\n * unplugged.  Questionable feature, but we can't just drop it.\n * Device models call blockdev_mark_auto_del() to schedule the\n * automatic deletion, and generic qdev code calls blockdev_auto_del()\n * when deletion is actually safe.\n */\nvoid blockdev_mark_auto_del(BlockBackend *blk)\n{\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n    BlockDriverState *bs = blk_bs(blk);\n    AioContext *aio_context;\n\n    if (!dinfo) {\n        return;\n    }\n\n    if (bs) {\n        aio_context = bdrv_get_aio_context(bs);\n        aio_context_acquire(aio_context);\n\n        if (bs->job) {\n            block_job_cancel(bs->job);\n        }\n\n        aio_context_release(aio_context);\n    }\n\n    dinfo->auto_del = 1;\n}\n\nvoid blockdev_auto_del(BlockBackend *blk)\n{\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n\n    if (dinfo && dinfo->auto_del) {\n        monitor_remove_blk(blk);\n        blk_unref(blk);\n    }\n}\n\n/**\n * Returns the current mapping of how many units per bus\n * a particular interface can support.\n *\n *  A positive integer indicates n units per bus.\n *  0 implies the mapping has not been established.\n * -1 indicates an invalid BlockInterfaceType was given.\n */\nint drive_get_max_devs(BlockInterfaceType type)\n{\n    if (type >= IF_IDE && type < IF_COUNT) {\n        return if_max_devs[type];\n    }\n\n    return -1;\n}\n\nstatic int drive_index_to_bus_id(BlockInterfaceType type, int index)\n{\n    int max_devs = if_max_devs[type];\n    return max_devs ? index / max_devs : 0;\n}\n\nstatic int drive_index_to_unit_id(BlockInterfaceType type, int index)\n{\n    int max_devs = if_max_devs[type];\n    return max_devs ? index % max_devs : index;\n}\n\nQemuOpts *drive_def(const char *optstr)\n{\n    return qemu_opts_parse_noisily(qemu_find_opts(\"drive\"), optstr, false);\n}\n\nQemuOpts *drive_add(BlockInterfaceType type, int index, const char *file,\n                    const char *optstr)\n{\n    QemuOpts *opts;\n\n    opts = drive_def(optstr);\n    if (!opts) {\n        return NULL;\n    }\n    if (type != IF_DEFAULT) {\n        qemu_opt_set(opts, \"if\", if_name[type], &error_abort);\n    }\n    if (index >= 0) {\n        qemu_opt_set_number(opts, \"index\", index, &error_abort);\n    }\n    if (file)\n        qemu_opt_set(opts, \"file\", file, &error_abort);\n    return opts;\n}\n\nDriveInfo *drive_get(BlockInterfaceType type, int bus, int unit)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo && dinfo->type == type\n            && dinfo->bus == bus && dinfo->unit == unit) {\n            return dinfo;\n        }\n    }\n\n    return NULL;\n}\n\nvoid drive_check_orphaned(void)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n    Location loc;\n    bool orphans = false;\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (!blk_get_attached_dev(blk) && !dinfo->is_default &&\n            dinfo->type != IF_NONE) {\n            loc_push_none(&loc);\n            qemu_opts_loc_restore(dinfo->opts);\n            error_report(\"machine type does not support\"\n                         \" if=%s,bus=%d,unit=%d\",\n                         if_name[dinfo->type], dinfo->bus, dinfo->unit);\n            loc_pop(&loc);\n            orphans = true;\n        }\n    }\n\n    if (orphans) {\n        exit(1);\n    }\n}\n\nDriveInfo *drive_get_by_index(BlockInterfaceType type, int index)\n{\n    return drive_get(type,\n                     drive_index_to_bus_id(type, index),\n                     drive_index_to_unit_id(type, index));\n}\n\nint drive_get_max_bus(BlockInterfaceType type)\n{\n    int max_bus;\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    max_bus = -1;\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo && dinfo->type == type && dinfo->bus > max_bus) {\n            max_bus = dinfo->bus;\n        }\n    }\n    return max_bus;\n}\n\n/* Get a block device.  This should only be used for single-drive devices\n   (e.g. SD/Floppy/MTD).  Multi-disk devices (scsi/ide) should use the\n   appropriate bus.  */\nDriveInfo *drive_get_next(BlockInterfaceType type)\n{\n    static int next_block_unit[IF_COUNT];\n\n    return drive_get(type, 0, next_block_unit[type]++);\n}\n\nstatic void bdrv_format_print(void *opaque, const char *name)\n{\n    error_printf(\" %s\", name);\n}\n\ntypedef struct {\n    QEMUBH *bh;\n    BlockDriverState *bs;\n} BDRVPutRefBH;\n\nstatic int parse_block_error_action(const char *buf, bool is_read, Error **errp)\n{\n    if (!strcmp(buf, \"ignore\")) {\n        return BLOCKDEV_ON_ERROR_IGNORE;\n    } else if (!is_read && !strcmp(buf, \"enospc\")) {\n        return BLOCKDEV_ON_ERROR_ENOSPC;\n    } else if (!strcmp(buf, \"stop\")) {\n        return BLOCKDEV_ON_ERROR_STOP;\n    } else if (!strcmp(buf, \"report\")) {\n        return BLOCKDEV_ON_ERROR_REPORT;\n    } else {\n        error_setg(errp, \"'%s' invalid %s error action\",\n                   buf, is_read ? \"read\" : \"write\");\n        return -1;\n    }\n}\n\nstatic bool parse_stats_intervals(BlockAcctStats *stats, QList *intervals,\n                                  Error **errp)\n{\n    const QListEntry *entry;\n    for (entry = qlist_first(intervals); entry; entry = qlist_next(entry)) {\n        switch (qobject_type(entry->value)) {\n\n        case QTYPE_QSTRING: {\n            unsigned long long length;\n            const char *str = qstring_get_str(qobject_to_qstring(entry->value));\n            if (parse_uint_full(str, &length, 10) == 0 &&\n                length > 0 && length <= UINT_MAX) {\n                block_acct_add_interval(stats, (unsigned) length);\n            } else {\n                error_setg(errp, \"Invalid interval length: %s\", str);\n                return false;\n            }\n            break;\n        }\n\n        case QTYPE_QINT: {\n            int64_t length = qint_get_int(qobject_to_qint(entry->value));\n            if (length > 0 && length <= UINT_MAX) {\n                block_acct_add_interval(stats, (unsigned) length);\n            } else {\n                error_setg(errp, \"Invalid interval length: %\" PRId64, length);\n                return false;\n            }\n            break;\n        }\n\n        default:\n            error_setg(errp, \"The specification of stats-intervals is invalid\");\n            return false;\n        }\n    }\n    return true;\n}\n\ntypedef enum { MEDIA_DISK, MEDIA_CDROM } DriveMediaType;\n\n/* All parameters but @opts are optional and may be set to NULL. */\nstatic void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,\n    const char **throttling_group, ThrottleConfig *throttle_cfg,\n    BlockdevDetectZeroesOptions *detect_zeroes, Error **errp)\n{\n    Error *local_error = NULL;\n    const char *aio;\n\n    if (bdrv_flags) {\n        if (qemu_opt_get_bool(opts, \"copy-on-read\", false)) {\n            *bdrv_flags |= BDRV_O_COPY_ON_READ;\n        }\n\n        if ((aio = qemu_opt_get(opts, \"aio\")) != NULL) {\n            if (!strcmp(aio, \"native\")) {\n                *bdrv_flags |= BDRV_O_NATIVE_AIO;\n            } else if (!strcmp(aio, \"threads\")) {\n                /* this is the default */\n            } else {\n               error_setg(errp, \"invalid aio option\");\n               return;\n            }\n        }\n    }\n\n    /* disk I/O throttling */\n    if (throttling_group) {\n        *throttling_group = qemu_opt_get(opts, \"throttling.group\");\n    }\n\n    if (throttle_cfg) {\n        throttle_config_init(throttle_cfg);\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].avg =\n            qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].avg  =\n            qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].avg =\n            qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].max =\n            qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].max  =\n            qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].max =\n            qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].max =\n            qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].max =\n            qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].max =\n            qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].burst_length =\n            qemu_opt_get_number(opts, \"throttling.bps-total-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].burst_length  =\n            qemu_opt_get_number(opts, \"throttling.bps-read-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].burst_length =\n            qemu_opt_get_number(opts, \"throttling.bps-write-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-total-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-read-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-write-max-length\", 1);\n\n        throttle_cfg->op_size =\n            qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n        if (!throttle_is_valid(throttle_cfg, errp)) {\n            return;\n        }\n    }\n\n    if (detect_zeroes) {\n        *detect_zeroes =\n            qapi_enum_parse(BlockdevDetectZeroesOptions_lookup,\n                            qemu_opt_get(opts, \"detect-zeroes\"),\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX,\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n                            &local_error);\n        if (local_error) {\n            error_propagate(errp, local_error);\n            return;\n        }\n    }\n}\n\n/* Takes the ownership of bs_opts */\nstatic BlockBackend *blockdev_init(const char *file, QDict *bs_opts,\n                                   Error **errp)\n{\n    const char *buf;\n    int bdrv_flags = 0;\n    int on_read_error, on_write_error;\n    bool account_invalid, account_failed;\n    bool writethrough, read_only;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    ThrottleConfig cfg;\n    int snapshot = 0;\n    Error *error = NULL;\n    QemuOpts *opts;\n    QDict *interval_dict = NULL;\n    QList *interval_list = NULL;\n    const char *id;\n    BlockdevDetectZeroesOptions detect_zeroes =\n        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n    const char *throttling_group = NULL;\n\n    /* Check common options by copying from bs_opts to opts, all other options\n     * stay in bs_opts for processing by bdrv_open(). */\n    id = qdict_get_try_str(bs_opts, \"id\");\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto err_no_opts;\n    }\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto early_err;\n    }\n\n    if (id) {\n        qdict_del(bs_opts, \"id\");\n    }\n\n    /* extract parameters */\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    account_invalid = qemu_opt_get_bool(opts, \"stats-account-invalid\", true);\n    account_failed = qemu_opt_get_bool(opts, \"stats-account-failed\", true);\n\n    writethrough = !qemu_opt_get_bool(opts, BDRV_OPT_CACHE_WB, true);\n\n    id = qemu_opts_id(opts);\n\n    qdict_extract_subqdict(bs_opts, &interval_dict, \"stats-intervals.\");\n    qdict_array_split(interval_dict, &interval_list);\n\n    if (qdict_size(interval_dict) != 0) {\n        error_setg(errp, \"Invalid option stats-intervals.%s\",\n                   qdict_first(interval_dict)->key);\n        goto early_err;\n    }\n\n    extract_common_blockdev_options(opts, &bdrv_flags, &throttling_group, &cfg,\n                                    &detect_zeroes, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto early_err;\n    }\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n        if (is_help_option(buf)) {\n            error_printf(\"Supported formats:\");\n            bdrv_iterate_format(bdrv_format_print, NULL);\n            error_printf(\"\\n\");\n            goto early_err;\n        }\n\n        if (qdict_haskey(bs_opts, \"driver\")) {\n            error_setg(errp, \"Cannot specify both 'driver' and 'format'\");\n            goto early_err;\n        }\n        qdict_put_str(bs_opts, \"driver\", buf);\n    }\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n        on_write_error = parse_block_error_action(buf, 0, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n        on_read_error = parse_block_error_action(buf, 1, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n\n    if (snapshot) {\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n    }\n\n    read_only = qemu_opt_get_bool(opts, BDRV_OPT_READ_ONLY, false);\n\n    /* init */\n    if ((!file || !*file) && !qdict_size(bs_opts)) {\n        BlockBackendRootState *blk_rs;\n\n        blk = blk_new(0, BLK_PERM_ALL);\n        blk_rs = blk_get_root_state(blk);\n        blk_rs->open_flags    = bdrv_flags;\n        blk_rs->read_only     = read_only;\n        blk_rs->detect_zeroes = detect_zeroes;\n\n        QDECREF(bs_opts);\n    } else {\n        if (file && !*file) {\n            file = NULL;\n        }\n\n        /* bdrv_open() defaults to the values in bdrv_flags (for compatibility\n         * with other callers) rather than what we want as the real defaults.\n         * Apply the defaults here instead. */\n        qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_DIRECT, \"off\");\n        qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_NO_FLUSH, \"off\");\n        qdict_set_default_str(bs_opts, BDRV_OPT_READ_ONLY,\n                              read_only ? \"on\" : \"off\");\n        assert((bdrv_flags & BDRV_O_CACHE_MASK) == 0);\n\n        if (runstate_check(RUN_STATE_INMIGRATE)) {\n            bdrv_flags |= BDRV_O_INACTIVE;\n        }\n\n        blk = blk_new_open(file, NULL, bs_opts, bdrv_flags, errp);\n        if (!blk) {\n            goto err_no_bs_opts;\n        }\n        bs = blk_bs(blk);\n\n        bs->detect_zeroes = detect_zeroes;\n\n        if (bdrv_key_required(bs)) {\n            autostart = 0;\n        }\n\n        block_acct_init(blk_get_stats(blk), account_invalid, account_failed);\n\n        if (!parse_stats_intervals(blk_get_stats(blk), interval_list, errp)) {\n            blk_unref(blk);\n            blk = NULL;\n            goto err_no_bs_opts;\n        }\n    }\n\n    /* disk I/O throttling */\n    if (throttle_enabled(&cfg)) {\n        if (!throttling_group) {\n            throttling_group = id;\n        }\n        blk_io_limits_enable(blk, throttling_group);\n        blk_set_io_limits(blk, &cfg);\n    }\n\n    blk_set_enable_write_cache(blk, !writethrough);\n    blk_set_on_error(blk, on_read_error, on_write_error);\n\n    if (!monitor_add_blk(blk, id, errp)) {\n        blk_unref(blk);\n        blk = NULL;\n        goto err_no_bs_opts;\n    }\n\nerr_no_bs_opts:\n    qemu_opts_del(opts);\n    QDECREF(interval_dict);\n    QDECREF(interval_list);\n    return blk;\n\nearly_err:\n    qemu_opts_del(opts);\n    QDECREF(interval_dict);\n    QDECREF(interval_list);\nerr_no_opts:\n    QDECREF(bs_opts);\n    return NULL;\n}\n\n/* Takes the ownership of bs_opts */\nstatic BlockDriverState *bds_tree_init(QDict *bs_opts, Error **errp)\n{\n    int bdrv_flags = 0;\n\n    /* bdrv_open() defaults to the values in bdrv_flags (for compatibility\n     * with other callers) rather than what we want as the real defaults.\n     * Apply the defaults here instead. */\n    qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_DIRECT, \"off\");\n    qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_NO_FLUSH, \"off\");\n    qdict_set_default_str(bs_opts, BDRV_OPT_READ_ONLY, \"off\");\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        bdrv_flags |= BDRV_O_INACTIVE;\n    }\n\n    return bdrv_open(NULL, NULL, bs_opts, bdrv_flags, errp);\n}\n\nvoid blockdev_close_all_bdrv_states(void)\n{\n    BlockDriverState *bs, *next_bs;\n\n    QTAILQ_FOREACH_SAFE(bs, &monitor_bdrv_states, monitor_list, next_bs) {\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        aio_context_acquire(ctx);\n        bdrv_unref(bs);\n        aio_context_release(ctx);\n    }\n}\n\n/* Iterates over the list of monitor-owned BlockDriverStates */\nBlockDriverState *bdrv_next_monitor_owned(BlockDriverState *bs)\n{\n    return bs ? QTAILQ_NEXT(bs, monitor_list)\n              : QTAILQ_FIRST(&monitor_bdrv_states);\n}\n\nstatic void qemu_opt_rename(QemuOpts *opts, const char *from, const char *to,\n                            Error **errp)\n{\n    const char *value;\n\n    value = qemu_opt_get(opts, from);\n    if (value) {\n        if (qemu_opt_find(opts, to)) {\n            error_setg(errp, \"'%s' and its alias '%s' can't be used at the \"\n                       \"same time\", to, from);\n            return;\n        }\n    }\n\n    /* rename all items in opts */\n    while ((value = qemu_opt_get(opts, from))) {\n        qemu_opt_set(opts, to, value, &error_abort);\n        qemu_opt_unset(opts, from);\n    }\n}\n\nQemuOptsList qemu_legacy_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_legacy_drive_opts.head),\n    .desc = {\n        {\n            .name = \"bus\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"bus number\",\n        },{\n            .name = \"unit\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"unit number (i.e. lun for scsi)\",\n        },{\n            .name = \"index\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"index number\",\n        },{\n            .name = \"media\",\n            .type = QEMU_OPT_STRING,\n            .help = \"media type (disk, cdrom)\",\n        },{\n            .name = \"if\",\n            .type = QEMU_OPT_STRING,\n            .help = \"interface (ide, scsi, sd, mtd, floppy, pflash, virtio)\",\n        },{\n            .name = \"cyls\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"number of cylinders (ide disk geometry)\",\n        },{\n            .name = \"heads\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"number of heads (ide disk geometry)\",\n        },{\n            .name = \"secs\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"number of sectors (ide disk geometry)\",\n        },{\n            .name = \"trans\",\n            .type = QEMU_OPT_STRING,\n            .help = \"chs translation (auto, lba, none)\",\n        },{\n            .name = \"boot\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"(deprecated, ignored)\",\n        },{\n            .name = \"addr\",\n            .type = QEMU_OPT_STRING,\n            .help = \"pci address (virtio only)\",\n        },{\n            .name = \"serial\",\n            .type = QEMU_OPT_STRING,\n            .help = \"disk serial number\",\n        },{\n            .name = \"file\",\n            .type = QEMU_OPT_STRING,\n            .help = \"file name\",\n        },\n\n        /* Options that are passed on, but have special semantics with -drive */\n        {\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"open drive file as read-only\",\n        },{\n            .name = \"rerror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"read error action\",\n        },{\n            .name = \"werror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"write error action\",\n        },{\n            .name = \"copy-on-read\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"copy read data from backing file into image file\",\n        },\n\n        { /* end of list */ }\n    },\n};\n\nDriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n{\n    const char *value;\n    BlockBackend *blk;\n    DriveInfo *dinfo = NULL;\n    QDict *bs_opts;\n    QemuOpts *legacy_opts;\n    DriveMediaType media = MEDIA_DISK;\n    BlockInterfaceType type;\n    int cyls, heads, secs, translation;\n    int max_devs, bus_id, unit_id, index;\n    const char *devaddr;\n    const char *werror, *rerror;\n    bool read_only = false;\n    bool copy_on_read;\n    const char *serial;\n    const char *filename;\n    Error *local_err = NULL;\n    int i;\n\n    /* Change legacy command line options into QMP ones */\n    static const struct {\n        const char *from;\n        const char *to;\n    } opt_renames[] = {\n        { \"iops\",           \"throttling.iops-total\" },\n        { \"iops_rd\",        \"throttling.iops-read\" },\n        { \"iops_wr\",        \"throttling.iops-write\" },\n\n        { \"bps\",            \"throttling.bps-total\" },\n        { \"bps_rd\",         \"throttling.bps-read\" },\n        { \"bps_wr\",         \"throttling.bps-write\" },\n\n        { \"iops_max\",       \"throttling.iops-total-max\" },\n        { \"iops_rd_max\",    \"throttling.iops-read-max\" },\n        { \"iops_wr_max\",    \"throttling.iops-write-max\" },\n\n        { \"bps_max\",        \"throttling.bps-total-max\" },\n        { \"bps_rd_max\",     \"throttling.bps-read-max\" },\n        { \"bps_wr_max\",     \"throttling.bps-write-max\" },\n\n        { \"iops_size\",      \"throttling.iops-size\" },\n\n        { \"group\",          \"throttling.group\" },\n\n        { \"readonly\",       BDRV_OPT_READ_ONLY },\n    };\n\n    for (i = 0; i < ARRAY_SIZE(opt_renames); i++) {\n        qemu_opt_rename(all_opts, opt_renames[i].from, opt_renames[i].to,\n                        &local_err);\n        if (local_err) {\n            error_report_err(local_err);\n            return NULL;\n        }\n    }\n\n    value = qemu_opt_get(all_opts, \"cache\");\n    if (value) {\n        int flags = 0;\n        bool writethrough;\n\n        if (bdrv_parse_cache_mode(value, &flags, &writethrough) != 0) {\n            error_report(\"invalid cache option\");\n            return NULL;\n        }\n\n        /* Specific options take precedence */\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_WB)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_WB,\n                              !writethrough, &error_abort);\n        }\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_DIRECT)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_DIRECT,\n                              !!(flags & BDRV_O_NOCACHE), &error_abort);\n        }\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_NO_FLUSH)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_NO_FLUSH,\n                              !!(flags & BDRV_O_NO_FLUSH), &error_abort);\n        }\n        qemu_opt_unset(all_opts, \"cache\");\n    }\n\n    /* Get a QDict for processing the options */\n    bs_opts = qdict_new();\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n                                   &error_abort);\n    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        goto fail;\n    }\n\n    /* Deprecated option boot=[on|off] */\n    if (qemu_opt_get(legacy_opts, \"boot\") != NULL) {\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n                \"ignored. Future versions will reject this parameter. Please \"\n                \"update your scripts.\\n\");\n    }\n\n    /* Media type */\n    value = qemu_opt_get(legacy_opts, \"media\");\n    if (value) {\n        if (!strcmp(value, \"disk\")) {\n            media = MEDIA_DISK;\n        } else if (!strcmp(value, \"cdrom\")) {\n            media = MEDIA_CDROM;\n            read_only = true;\n        } else {\n            error_report(\"'%s' invalid media\", value);\n            goto fail;\n        }\n    }\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n    read_only |= qemu_opt_get_bool(legacy_opts, BDRV_OPT_READ_ONLY, false);\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n    if (read_only && copy_on_read) {\n        error_report(\"warning: disabling copy-on-read on read-only drive\");\n        copy_on_read = false;\n    }\n\n    qdict_put_str(bs_opts, BDRV_OPT_READ_ONLY, read_only ? \"on\" : \"off\");\n    qdict_put_str(bs_opts, \"copy-on-read\", copy_on_read ? \"on\" : \"off\");\n\n    /* Controller type */\n    value = qemu_opt_get(legacy_opts, \"if\");\n    if (value) {\n        for (type = 0;\n             type < IF_COUNT && strcmp(value, if_name[type]);\n             type++) {\n        }\n        if (type == IF_COUNT) {\n            error_report(\"unsupported bus type '%s'\", value);\n            goto fail;\n        }\n    } else {\n        type = block_default_type;\n    }\n\n    /* Geometry */\n    cyls  = qemu_opt_get_number(legacy_opts, \"cyls\", 0);\n    heads = qemu_opt_get_number(legacy_opts, \"heads\", 0);\n    secs  = qemu_opt_get_number(legacy_opts, \"secs\", 0);\n\n    if (cyls || heads || secs) {\n        if (cyls < 1) {\n            error_report(\"invalid physical cyls number\");\n            goto fail;\n        }\n        if (heads < 1) {\n            error_report(\"invalid physical heads number\");\n            goto fail;\n        }\n        if (secs < 1) {\n            error_report(\"invalid physical secs number\");\n            goto fail;\n        }\n    }\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n    value = qemu_opt_get(legacy_opts, \"trans\");\n    if (value != NULL) {\n        if (!cyls) {\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n                         value);\n            goto fail;\n        }\n        if (!strcmp(value, \"none\")) {\n            translation = BIOS_ATA_TRANSLATION_NONE;\n        } else if (!strcmp(value, \"lba\")) {\n            translation = BIOS_ATA_TRANSLATION_LBA;\n        } else if (!strcmp(value, \"large\")) {\n            translation = BIOS_ATA_TRANSLATION_LARGE;\n        } else if (!strcmp(value, \"rechs\")) {\n            translation = BIOS_ATA_TRANSLATION_RECHS;\n        } else if (!strcmp(value, \"auto\")) {\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n        } else {\n            error_report(\"'%s' invalid translation type\", value);\n            goto fail;\n        }\n    }\n\n    if (media == MEDIA_CDROM) {\n        if (cyls || secs || heads) {\n            error_report(\"CHS can't be set with media=cdrom\");\n            goto fail;\n        }\n    }\n\n    /* Device address specified by bus/unit or index.\n     * If none was specified, try to find the first free one. */\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n    max_devs = if_max_devs[type];\n\n    if (index != -1) {\n        if (bus_id != 0 || unit_id != -1) {\n            error_report(\"index cannot be used with bus and unit\");\n            goto fail;\n        }\n        bus_id = drive_index_to_bus_id(type, index);\n        unit_id = drive_index_to_unit_id(type, index);\n    }\n\n    if (unit_id == -1) {\n       unit_id = 0;\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n           unit_id++;\n           if (max_devs && unit_id >= max_devs) {\n               unit_id -= max_devs;\n               bus_id++;\n           }\n       }\n    }\n\n    if (max_devs && unit_id >= max_devs) {\n        error_report(\"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n        goto fail;\n    }\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n                     bus_id, unit_id, index);\n        goto fail;\n    }\n\n    /* Serial number */\n    serial = qemu_opt_get(legacy_opts, \"serial\");\n\n    /* no id supplied -> create one */\n    if (qemu_opts_id(all_opts) == NULL) {\n        char *new_id;\n        const char *mediastr = \"\";\n        if (type == IF_IDE || type == IF_SCSI) {\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n        }\n        if (max_devs) {\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n                                     mediastr, unit_id);\n        } else {\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n                                     mediastr, unit_id);\n        }\n        qdict_put_str(bs_opts, \"id\", new_id);\n        g_free(new_id);\n    }\n\n    /* Add virtio block device */\n    devaddr = qemu_opt_get(legacy_opts, \"addr\");\n    if (devaddr && type != IF_VIRTIO) {\n        error_report(\"addr is not supported by this bus type\");\n        goto fail;\n    }\n\n    if (type == IF_VIRTIO) {\n        QemuOpts *devopts;\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                   &error_abort);\n        if (arch_type == QEMU_ARCH_S390X) {\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-ccw\", &error_abort);\n        } else {\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\", &error_abort);\n        }\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"),\n                     &error_abort);\n        if (devaddr) {\n            qemu_opt_set(devopts, \"addr\", devaddr, &error_abort);\n        }\n    }\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n    /* Check werror/rerror compatibility with if=... */\n    werror = qemu_opt_get(legacy_opts, \"werror\");\n    if (werror != NULL) {\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&\n            type != IF_NONE) {\n            error_report(\"werror is not supported by this bus type\");\n            goto fail;\n        }\n        qdict_put_str(bs_opts, \"werror\", werror);\n    }\n\n    rerror = qemu_opt_get(legacy_opts, \"rerror\");\n    if (rerror != NULL) {\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&\n            type != IF_NONE) {\n            error_report(\"rerror is not supported by this bus type\");\n            goto fail;\n        }\n        qdict_put_str(bs_opts, \"rerror\", rerror);\n    }\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n    blk = blockdev_init(filename, bs_opts, &local_err);\n    bs_opts = NULL;\n    if (!blk) {\n        if (local_err) {\n            error_report_err(local_err);\n        }\n        goto fail;\n    } else {\n        assert(!local_err);\n    }\n\n    /* Create legacy DriveInfo */\n    dinfo = g_malloc0(sizeof(*dinfo));\n    dinfo->opts = all_opts;\n\n    dinfo->cyls = cyls;\n    dinfo->heads = heads;\n    dinfo->secs = secs;\n    dinfo->trans = translation;\n\n    dinfo->type = type;\n    dinfo->bus = bus_id;\n    dinfo->unit = unit_id;\n    dinfo->devaddr = devaddr;\n    dinfo->serial = g_strdup(serial);\n\n    blk_set_legacy_dinfo(blk, dinfo);\n\n    switch(type) {\n    case IF_IDE:\n    case IF_SCSI:\n    case IF_XEN:\n    case IF_NONE:\n        dinfo->media_cd = media == MEDIA_CDROM;\n        break;\n    default:\n        break;\n    }\n\nfail:\n    qemu_opts_del(legacy_opts);\n    QDECREF(bs_opts);\n    return dinfo;\n}\n\nstatic BlockDriverState *qmp_get_root_bs(const char *name, Error **errp)\n{\n    BlockDriverState *bs;\n\n    bs = bdrv_lookup_bs(name, name, errp);\n    if (bs == NULL) {\n        return NULL;\n    }\n\n    if (!bdrv_is_root_node(bs)) {\n        error_setg(errp, \"Need a root block node\");\n        return NULL;\n    }\n\n    if (!bdrv_is_inserted(bs)) {\n        error_setg(errp, \"Device has no medium\");\n        return NULL;\n    }\n\n    return bs;\n}\n\nstatic BlockBackend *qmp_get_blk(const char *blk_name, const char *qdev_id,\n                                 Error **errp)\n{\n    BlockBackend *blk;\n\n    if (!blk_name == !qdev_id) {\n        error_setg(errp, \"Need exactly one of 'device' and 'id'\");\n        return NULL;\n    }\n\n    if (qdev_id) {\n        blk = blk_by_qdev_id(qdev_id, errp);\n    } else {\n        blk = blk_by_name(blk_name);\n        if (blk == NULL) {\n            error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                      \"Device '%s' not found\", blk_name);\n        }\n    }\n\n    return blk;\n}\n\nvoid hmp_commit(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    BlockBackend *blk;\n    int ret;\n\n    if (!strcmp(device, \"all\")) {\n        ret = blk_commit_all();\n    } else {\n        BlockDriverState *bs;\n        AioContext *aio_context;\n\n        blk = blk_by_name(device);\n        if (!blk) {\n            monitor_printf(mon, \"Device '%s' not found\\n\", device);\n            return;\n        }\n        if (!blk_is_available(blk)) {\n            monitor_printf(mon, \"Device '%s' has no medium\\n\", device);\n            return;\n        }\n\n        bs = blk_bs(blk);\n        aio_context = bdrv_get_aio_context(bs);\n        aio_context_acquire(aio_context);\n\n        ret = bdrv_commit(bs);\n\n        aio_context_release(aio_context);\n    }\n    if (ret < 0) {\n        monitor_printf(mon, \"'commit' error for '%s': %s\\n\", device,\n                       strerror(-ret));\n    }\n}\n\nstatic void blockdev_do_action(TransactionAction *action, Error **errp)\n{\n    TransactionActionList list;\n\n    list.value = action;\n    list.next = NULL;\n    qmp_transaction(&list, false, NULL, errp);\n}\n\nvoid qmp_blockdev_snapshot_sync(bool has_device, const char *device,\n                                bool has_node_name, const char *node_name,\n                                const char *snapshot_file,\n                                bool has_snapshot_node_name,\n                                const char *snapshot_node_name,\n                                bool has_format, const char *format,\n                                bool has_mode, NewImageMode mode, Error **errp)\n{\n    BlockdevSnapshotSync snapshot = {\n        .has_device = has_device,\n        .device = (char *) device,\n        .has_node_name = has_node_name,\n        .node_name = (char *) node_name,\n        .snapshot_file = (char *) snapshot_file,\n        .has_snapshot_node_name = has_snapshot_node_name,\n        .snapshot_node_name = (char *) snapshot_node_name,\n        .has_format = has_format,\n        .format = (char *) format,\n        .has_mode = has_mode,\n        .mode = mode,\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC,\n        .u.blockdev_snapshot_sync.data = &snapshot,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nvoid qmp_blockdev_snapshot(const char *node, const char *overlay,\n                           Error **errp)\n{\n    BlockdevSnapshot snapshot_data = {\n        .node = (char *) node,\n        .overlay = (char *) overlay\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT,\n        .u.blockdev_snapshot.data = &snapshot_data,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nvoid qmp_blockdev_snapshot_internal_sync(const char *device,\n                                         const char *name,\n                                         Error **errp)\n{\n    BlockdevSnapshotInternal snapshot = {\n        .device = (char *) device,\n        .name = (char *) name\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC,\n        .u.blockdev_snapshot_internal_sync.data = &snapshot,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nSnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n                                                         bool has_id,\n                                                         const char *id,\n                                                         bool has_name,\n                                                         const char *name,\n                                                         Error **errp)\n{\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    QEMUSnapshotInfo sn;\n    Error *local_err = NULL;\n    SnapshotInfo *info = NULL;\n    int ret;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return NULL;\n    }\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!has_id) {\n        id = NULL;\n    }\n\n    if (!has_name) {\n        name = NULL;\n    }\n\n    if (!id && !name) {\n        error_setg(errp, \"Name or id must be provided\");\n        goto out_aio_context;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n        goto out_aio_context;\n    }\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out_aio_context;\n    }\n    if (!ret) {\n        error_setg(errp,\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n                   \"device '%s'\",\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n        goto out_aio_context;\n    }\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out_aio_context;\n    }\n\n    aio_context_release(aio_context);\n\n    info = g_new0(SnapshotInfo, 1);\n    info->id = g_strdup(sn.id_str);\n    info->name = g_strdup(sn.name);\n    info->date_nsec = sn.date_nsec;\n    info->date_sec = sn.date_sec;\n    info->vm_state_size = sn.vm_state_size;\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n    return info;\n\nout_aio_context:\n    aio_context_release(aio_context);\n    return NULL;\n}\n\n/**\n * block_dirty_bitmap_lookup:\n * Return a dirty bitmap (if present), after validating\n * the node reference and bitmap names.\n *\n * @node: The name of the BDS node to search for bitmaps\n * @name: The name of the bitmap to search for\n * @pbs: Output pointer for BDS lookup, if desired. Can be NULL.\n * @paio: Output pointer for aio_context acquisition, if desired. Can be NULL.\n * @errp: Output pointer for error information. Can be NULL.\n *\n * @return: A bitmap object on success, or NULL on failure.\n */\nstatic BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n                                                  const char *name,\n                                                  BlockDriverState **pbs,\n                                                  AioContext **paio,\n                                                  Error **errp)\n{\n    BlockDriverState *bs;\n    BdrvDirtyBitmap *bitmap;\n    AioContext *aio_context;\n\n    if (!node) {\n        error_setg(errp, \"Node cannot be NULL\");\n        return NULL;\n    }\n    if (!name) {\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n        return NULL;\n    }\n    bs = bdrv_lookup_bs(node, node, NULL);\n    if (!bs) {\n        error_setg(errp, \"Node '%s' not found\", node);\n        return NULL;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n    if (!bitmap) {\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n        goto fail;\n    }\n\n    if (pbs) {\n        *pbs = bs;\n    }\n    if (paio) {\n        *paio = aio_context;\n    } else {\n        aio_context_release(aio_context);\n    }\n\n    return bitmap;\n\n fail:\n    aio_context_release(aio_context);\n    return NULL;\n}\n\n/* New and old BlockDriverState structs for atomic group operations */\n\ntypedef struct BlkActionState BlkActionState;\n\n/**\n * BlkActionOps:\n * Table of operations that define an Action.\n *\n * @instance_size: Size of state struct, in bytes.\n * @prepare: Prepare the work, must NOT be NULL.\n * @commit: Commit the changes, can be NULL.\n * @abort: Abort the changes on fail, can be NULL.\n * @clean: Clean up resources after all transaction actions have called\n *         commit() or abort(). Can be NULL.\n *\n * Only prepare() may fail. In a single transaction, only one of commit() or\n * abort() will be called. clean() will always be called if it is present.\n */\ntypedef struct BlkActionOps {\n    size_t instance_size;\n    void (*prepare)(BlkActionState *common, Error **errp);\n    void (*commit)(BlkActionState *common);\n    void (*abort)(BlkActionState *common);\n    void (*clean)(BlkActionState *common);\n} BlkActionOps;\n\n/**\n * BlkActionState:\n * Describes one Action's state within a Transaction.\n *\n * @action: QAPI-defined enum identifying which Action to perform.\n * @ops: Table of ActionOps this Action can perform.\n * @block_job_txn: Transaction which this action belongs to.\n * @entry: List membership for all Actions in this Transaction.\n *\n * This structure must be arranged as first member in a subclassed type,\n * assuming that the compiler will also arrange it to the same offsets as the\n * base class.\n */\nstruct BlkActionState {\n    TransactionAction *action;\n    const BlkActionOps *ops;\n    BlockJobTxn *block_job_txn;\n    TransactionProperties *txn_props;\n    QSIMPLEQ_ENTRY(BlkActionState) entry;\n};\n\n/* internal snapshot private data */\ntypedef struct InternalSnapshotState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    QEMUSnapshotInfo sn;\n    bool created;\n} InternalSnapshotState;\n\n\nstatic int action_check_completion_mode(BlkActionState *s, Error **errp)\n{\n    if (s->txn_props->completion_mode != ACTION_COMPLETION_MODE_INDIVIDUAL) {\n        error_setg(errp,\n                   \"Action '%s' does not support Transaction property \"\n                   \"completion-mode = %s\",\n                   TransactionActionKind_lookup[s->action->type],\n                   ActionCompletionMode_lookup[s->txn_props->completion_mode]);\n        return -1;\n    }\n    return 0;\n}\n\nstatic void internal_snapshot_prepare(BlkActionState *common,\n                                      Error **errp)\n{\n    Error *local_err = NULL;\n    const char *device;\n    const char *name;\n    BlockDriverState *bs;\n    QEMUSnapshotInfo old_sn, *sn;\n    bool ret;\n    qemu_timeval tv;\n    BlockdevSnapshotInternal *internal;\n    InternalSnapshotState *state;\n    int ret1;\n\n    g_assert(common->action->type ==\n             TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC);\n    internal = common->action->u.blockdev_snapshot_internal_sync.data;\n    state = DO_UPCAST(InternalSnapshotState, common, common);\n\n    /* 1. parse input */\n    device = internal->device;\n    name = internal->name;\n\n    /* 2. check for validation */\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    /* AioContext is released in .clean() */\n    state->aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(state->aio_context);\n\n    state->bs = bs;\n    bdrv_drained_begin(bs);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT, errp)) {\n        return;\n    }\n\n    if (bdrv_is_read_only(bs)) {\n        error_setg(errp, \"Device '%s' is read only\", device);\n        return;\n    }\n\n    if (!bdrv_can_snapshot(bs)) {\n        error_setg(errp, \"Block format '%s' used by device '%s' \"\n                   \"does not support internal snapshots\",\n                   bs->drv->format_name, device);\n        return;\n    }\n\n    if (!strlen(name)) {\n        error_setg(errp, \"Name is empty\");\n        return;\n    }\n\n    /* check whether a snapshot with name exist */\n    ret = bdrv_snapshot_find_by_id_and_name(bs, NULL, name, &old_sn,\n                                            &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    } else if (ret) {\n        error_setg(errp,\n                   \"Snapshot with name '%s' already exists on device '%s'\",\n                   name, device);\n        return;\n    }\n\n    /* 3. take the snapshot */\n    sn = &state->sn;\n    pstrcpy(sn->name, sizeof(sn->name), name);\n    qemu_gettimeofday(&tv);\n    sn->date_sec = tv.tv_sec;\n    sn->date_nsec = tv.tv_usec * 1000;\n    sn->vm_clock_nsec = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    ret1 = bdrv_snapshot_create(bs, sn);\n    if (ret1 < 0) {\n        error_setg_errno(errp, -ret1,\n                         \"Failed to create snapshot '%s' on device '%s'\",\n                         name, device);\n        return;\n    }\n\n    /* 4. succeed, mark a snapshot is created */\n    state->created = true;\n}\n\nstatic void internal_snapshot_abort(BlkActionState *common)\n{\n    InternalSnapshotState *state =\n                             DO_UPCAST(InternalSnapshotState, common, common);\n    BlockDriverState *bs = state->bs;\n    QEMUSnapshotInfo *sn = &state->sn;\n    Error *local_error = NULL;\n\n    if (!state->created) {\n        return;\n    }\n\n    if (bdrv_snapshot_delete(bs, sn->id_str, sn->name, &local_error) < 0) {\n        error_reportf_err(local_error,\n                          \"Failed to delete snapshot with id '%s' and \"\n                          \"name '%s' on device '%s' in abort: \",\n                          sn->id_str, sn->name,\n                          bdrv_get_device_name(bs));\n    }\n}\n\nstatic void internal_snapshot_clean(BlkActionState *common)\n{\n    InternalSnapshotState *state = DO_UPCAST(InternalSnapshotState,\n                                             common, common);\n\n    if (state->aio_context) {\n        if (state->bs) {\n            bdrv_drained_end(state->bs);\n        }\n        aio_context_release(state->aio_context);\n    }\n}\n\n/* external snapshot private data */\ntypedef struct ExternalSnapshotState {\n    BlkActionState common;\n    BlockDriverState *old_bs;\n    BlockDriverState *new_bs;\n    AioContext *aio_context;\n    bool overlay_appended;\n} ExternalSnapshotState;\n\nstatic void external_snapshot_prepare(BlkActionState *common,\n                                      Error **errp)\n{\n    int flags = 0;\n    QDict *options = NULL;\n    Error *local_err = NULL;\n    /* Device and node name of the image to generate the snapshot from */\n    const char *device;\n    const char *node_name;\n    /* Reference to the new image (for 'blockdev-snapshot') */\n    const char *snapshot_ref;\n    /* File name of the new image (for 'blockdev-snapshot-sync') */\n    const char *new_image_file;\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    TransactionAction *action = common->action;\n\n    /* 'blockdev-snapshot' and 'blockdev-snapshot-sync' have similar\n     * purpose but a different set of parameters */\n    switch (action->type) {\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT:\n        {\n            BlockdevSnapshot *s = action->u.blockdev_snapshot.data;\n            device = s->node;\n            node_name = s->node;\n            new_image_file = NULL;\n            snapshot_ref = s->overlay;\n        }\n        break;\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC:\n        {\n            BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n            device = s->has_device ? s->device : NULL;\n            node_name = s->has_node_name ? s->node_name : NULL;\n            new_image_file = s->snapshot_file;\n            snapshot_ref = NULL;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n\n    /* start processing */\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    state->old_bs = bdrv_lookup_bs(device, node_name, errp);\n    if (!state->old_bs) {\n        return;\n    }\n\n    /* Acquire AioContext now so any threads operating on old_bs stop */\n    state->aio_context = bdrv_get_aio_context(state->old_bs);\n    aio_context_acquire(state->aio_context);\n    bdrv_drained_begin(state->old_bs);\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n        error_setg(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n        return;\n    }\n\n    if (bdrv_op_is_blocked(state->old_bs,\n                           BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT, errp)) {\n        return;\n    }\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n        if (bdrv_flush(state->old_bs)) {\n            error_setg(errp, QERR_IO_ERROR);\n            return;\n        }\n    }\n\n    if (!bdrv_is_first_non_filter(state->old_bs)) {\n        error_setg(errp, QERR_FEATURE_DISABLED, \"snapshot\");\n        return;\n    }\n\n    if (action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC) {\n        BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n        const char *format = s->has_format ? s->format : \"qcow2\";\n        enum NewImageMode mode;\n        const char *snapshot_node_name =\n            s->has_snapshot_node_name ? s->snapshot_node_name : NULL;\n\n        if (node_name && !snapshot_node_name) {\n            error_setg(errp, \"New snapshot node name missing\");\n            return;\n        }\n\n        if (snapshot_node_name &&\n            bdrv_lookup_bs(snapshot_node_name, snapshot_node_name, NULL)) {\n            error_setg(errp, \"New snapshot node name already in use\");\n            return;\n        }\n\n        flags = state->old_bs->open_flags;\n        flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_COPY_ON_READ);\n\n        /* create new image w/backing file */\n        mode = s->has_mode ? s->mode : NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n        if (mode != NEW_IMAGE_MODE_EXISTING) {\n            int64_t size = bdrv_getlength(state->old_bs);\n            if (size < 0) {\n                error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n                return;\n            }\n            bdrv_img_create(new_image_file, format,\n                            state->old_bs->filename,\n                            state->old_bs->drv->format_name,\n                            NULL, size, flags, &local_err, false);\n            if (local_err) {\n                error_propagate(errp, local_err);\n                return;\n            }\n        }\n\n        options = qdict_new();\n        if (s->has_snapshot_node_name) {\n            qdict_put_str(options, \"node-name\", snapshot_node_name);\n        }\n        qdict_put_str(options, \"driver\", format);\n\n        flags |= BDRV_O_NO_BACKING;\n    }\n\n    state->new_bs = bdrv_open(new_image_file, snapshot_ref, options, flags,\n                              errp);\n    /* We will manually add the backing_hd field to the bs later */\n    if (!state->new_bs) {\n        return;\n    }\n\n    if (bdrv_has_blk(state->new_bs)) {\n        error_setg(errp, \"The snapshot is already in use\");\n        return;\n    }\n\n    if (bdrv_op_is_blocked(state->new_bs, BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT,\n                           errp)) {\n        return;\n    }\n\n    if (state->new_bs->backing != NULL) {\n        error_setg(errp, \"The snapshot already has a backing image\");\n        return;\n    }\n\n    if (!state->new_bs->drv->supports_backing) {\n        error_setg(errp, \"The snapshot does not support backing images\");\n        return;\n    }\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n    /* This removes our old bs and adds the new bs. This is an operation that\n     * can fail, so we need to do it in .prepare; undoing it for abort is\n     * always possible. */\n    bdrv_ref(state->new_bs);\n    bdrv_append(state->new_bs, state->old_bs, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    state->overlay_appended = true;\n}\n\nstatic void external_snapshot_commit(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    /* We don't need (or want) to use the transactional\n     * bdrv_reopen_multiple() across all the entries at once, because we\n     * don't want to abort all of them if one of them fails the reopen */\n    if (!state->old_bs->copy_on_read) {\n        bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n                    NULL);\n    }\n}\n\nstatic void external_snapshot_abort(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    if (state->new_bs) {\n        if (state->overlay_appended) {\n            bdrv_replace_node(state->new_bs, state->old_bs, &error_abort);\n        }\n    }\n}\n\nstatic void external_snapshot_clean(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    if (state->aio_context) {\n        bdrv_drained_end(state->old_bs);\n        aio_context_release(state->aio_context);\n        bdrv_unref(state->new_bs);\n    }\n}\n\ntypedef struct DriveBackupState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    BlockJob *job;\n} DriveBackupState;\n\nstatic BlockJob *do_drive_backup(DriveBackup *backup, BlockJobTxn *txn,\n                            Error **errp);\n\nstatic void drive_backup_prepare(BlkActionState *common, Error **errp)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n    BlockDriverState *bs;\n    DriveBackup *backup;\n    Error *local_err = NULL;\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n    backup = common->action->u.drive_backup.data;\n\n    bs = qmp_get_root_bs(backup->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    /* AioContext is released in .clean() */\n    state->aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(state->aio_context);\n    bdrv_drained_begin(bs);\n    state->bs = bs;\n\n    state->job = do_drive_backup(backup, common->block_job_txn, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n}\n\nstatic void drive_backup_commit(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n    assert(state->job);\n    block_job_start(state->job);\n}\n\nstatic void drive_backup_abort(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    if (state->job) {\n        block_job_cancel_sync(state->job);\n    }\n}\n\nstatic void drive_backup_clean(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    if (state->aio_context) {\n        bdrv_drained_end(state->bs);\n        aio_context_release(state->aio_context);\n    }\n}\n\ntypedef struct BlockdevBackupState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    BlockJob *job;\n    AioContext *aio_context;\n} BlockdevBackupState;\n\nstatic BlockJob *do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn,\n                                    Error **errp);\n\nstatic void blockdev_backup_prepare(BlkActionState *common, Error **errp)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n    BlockdevBackup *backup;\n    BlockDriverState *bs, *target;\n    Error *local_err = NULL;\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP);\n    backup = common->action->u.blockdev_backup.data;\n\n    bs = qmp_get_root_bs(backup->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    target = bdrv_lookup_bs(backup->target, backup->target, errp);\n    if (!target) {\n        return;\n    }\n\n    /* AioContext is released in .clean() */\n    state->aio_context = bdrv_get_aio_context(bs);\n    if (state->aio_context != bdrv_get_aio_context(target)) {\n        state->aio_context = NULL;\n        error_setg(errp, \"Backup between two IO threads is not implemented\");\n        return;\n    }\n    aio_context_acquire(state->aio_context);\n    state->bs = bs;\n    bdrv_drained_begin(state->bs);\n\n    state->job = do_blockdev_backup(backup, common->block_job_txn, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n}\n\nstatic void blockdev_backup_commit(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n    assert(state->job);\n    block_job_start(state->job);\n}\n\nstatic void blockdev_backup_abort(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n\n    if (state->job) {\n        block_job_cancel_sync(state->job);\n    }\n}\n\nstatic void blockdev_backup_clean(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n\n    if (state->aio_context) {\n        bdrv_drained_end(state->bs);\n        aio_context_release(state->aio_context);\n    }\n}\n\ntypedef struct BlockDirtyBitmapState {\n    BlkActionState common;\n    BdrvDirtyBitmap *bitmap;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    HBitmap *backup;\n    bool prepared;\n} BlockDirtyBitmapState;\n\nstatic void block_dirty_bitmap_add_prepare(BlkActionState *common,\n                                           Error **errp)\n{\n    Error *local_err = NULL;\n    BlockDirtyBitmapAdd *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_add.data;\n    /* AIO context taken and released within qmp_block_dirty_bitmap_add */\n    qmp_block_dirty_bitmap_add(action->node, action->name,\n                               action->has_granularity, action->granularity,\n                               &local_err);\n\n    if (!local_err) {\n        state->prepared = true;\n    } else {\n        error_propagate(errp, local_err);\n    }\n}\n\nstatic void block_dirty_bitmap_add_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapAdd *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    action = common->action->u.block_dirty_bitmap_add.data;\n    /* Should not be able to fail: IF the bitmap was added via .prepare(),\n     * then the node reference and bitmap name must have been valid.\n     */\n    if (state->prepared) {\n        qmp_block_dirty_bitmap_remove(action->node, action->name, &error_abort);\n    }\n}\n\nstatic void block_dirty_bitmap_clear_prepare(BlkActionState *common,\n                                             Error **errp)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n    BlockDirtyBitmap *action;\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_clear.data;\n    state->bitmap = block_dirty_bitmap_lookup(action->node,\n                                              action->name,\n                                              &state->bs,\n                                              &state->aio_context,\n                                              errp);\n    if (!state->bitmap) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_frozen(state->bitmap)) {\n        error_setg(errp, \"Cannot modify a frozen bitmap\");\n        return;\n    } else if (!bdrv_dirty_bitmap_enabled(state->bitmap)) {\n        error_setg(errp, \"Cannot clear a disabled bitmap\");\n        return;\n    }\n\n    bdrv_clear_dirty_bitmap(state->bitmap, &state->backup);\n    /* AioContext is released in .clean() */\n}\n\nstatic void block_dirty_bitmap_clear_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (state->backup) {\n        bdrv_undo_clear_dirty_bitmap(state->bitmap, state->backup);\n    }\n}\n\nstatic void block_dirty_bitmap_clear_commit(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    hbitmap_free(state->backup);\n}\n\nstatic void block_dirty_bitmap_clear_clean(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (state->aio_context) {\n        aio_context_release(state->aio_context);\n    }\n}\n\nstatic void abort_prepare(BlkActionState *common, Error **errp)\n{\n    error_setg(errp, \"Transaction aborted using Abort action\");\n}\n\nstatic void abort_commit(BlkActionState *common)\n{\n    g_assert_not_reached(); /* this action never succeeds */\n}\n\nstatic const BlkActionOps actions[] = {\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT] = {\n        .instance_size = sizeof(ExternalSnapshotState),\n        .prepare  = external_snapshot_prepare,\n        .commit   = external_snapshot_commit,\n        .abort = external_snapshot_abort,\n        .clean = external_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC] = {\n        .instance_size = sizeof(ExternalSnapshotState),\n        .prepare  = external_snapshot_prepare,\n        .commit   = external_snapshot_commit,\n        .abort = external_snapshot_abort,\n        .clean = external_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_DRIVE_BACKUP] = {\n        .instance_size = sizeof(DriveBackupState),\n        .prepare = drive_backup_prepare,\n        .commit = drive_backup_commit,\n        .abort = drive_backup_abort,\n        .clean = drive_backup_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP] = {\n        .instance_size = sizeof(BlockdevBackupState),\n        .prepare = blockdev_backup_prepare,\n        .commit = blockdev_backup_commit,\n        .abort = blockdev_backup_abort,\n        .clean = blockdev_backup_clean,\n    },\n    [TRANSACTION_ACTION_KIND_ABORT] = {\n        .instance_size = sizeof(BlkActionState),\n        .prepare = abort_prepare,\n        .commit = abort_commit,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC] = {\n        .instance_size = sizeof(InternalSnapshotState),\n        .prepare  = internal_snapshot_prepare,\n        .abort = internal_snapshot_abort,\n        .clean = internal_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_ADD] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_add_prepare,\n        .abort = block_dirty_bitmap_add_abort,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_CLEAR] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_clear_prepare,\n        .commit = block_dirty_bitmap_clear_commit,\n        .abort = block_dirty_bitmap_clear_abort,\n        .clean = block_dirty_bitmap_clear_clean,\n    }\n};\n\n/**\n * Allocate a TransactionProperties structure if necessary, and fill\n * that structure with desired defaults if they are unset.\n */\nstatic TransactionProperties *get_transaction_properties(\n    TransactionProperties *props)\n{\n    if (!props) {\n        props = g_new0(TransactionProperties, 1);\n    }\n\n    if (!props->has_completion_mode) {\n        props->has_completion_mode = true;\n        props->completion_mode = ACTION_COMPLETION_MODE_INDIVIDUAL;\n    }\n\n    return props;\n}\n\n/*\n * 'Atomic' group operations.  The operations are performed as a set, and if\n * any fail then we roll back all operations in the group.\n */\nvoid qmp_transaction(TransactionActionList *dev_list,\n                     bool has_props,\n                     struct TransactionProperties *props,\n                     Error **errp)\n{\n    TransactionActionList *dev_entry = dev_list;\n    BlockJobTxn *block_job_txn = NULL;\n    BlkActionState *state, *next;\n    Error *local_err = NULL;\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkActionState) snap_bdrv_states;\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n    /* Does this transaction get canceled as a group on failure?\n     * If not, we don't really need to make a BlockJobTxn.\n     */\n    props = get_transaction_properties(props);\n    if (props->completion_mode != ACTION_COMPLETION_MODE_INDIVIDUAL) {\n        block_job_txn = block_job_txn_new();\n    }\n\n    /* drain all i/o before any operations */\n    bdrv_drain_all();\n\n    /* We don't do anything in this loop that commits us to the operations */\n    while (NULL != dev_entry) {\n        TransactionAction *dev_info = NULL;\n        const BlkActionOps *ops;\n\n        dev_info = dev_entry->value;\n        dev_entry = dev_entry->next;\n\n        assert(dev_info->type < ARRAY_SIZE(actions));\n\n        ops = &actions[dev_info->type];\n        assert(ops->instance_size > 0);\n\n        state = g_malloc0(ops->instance_size);\n        state->ops = ops;\n        state->action = dev_info;\n        state->block_job_txn = block_job_txn;\n        state->txn_props = props;\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n        state->ops->prepare(state, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            goto delete_and_fail;\n        }\n    }\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n        if (state->ops->commit) {\n            state->ops->commit(state);\n        }\n    }\n\n    /* success */\n    goto exit;\n\ndelete_and_fail:\n    /* failure, and it is all-or-none; roll back all operations */\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n        if (state->ops->abort) {\n            state->ops->abort(state);\n        }\n    }\nexit:\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n        if (state->ops->clean) {\n            state->ops->clean(state);\n        }\n        g_free(state);\n    }\n    if (!has_props) {\n        qapi_free_TransactionProperties(props);\n    }\n    block_job_txn_unref(block_job_txn);\n}\n\nvoid qmp_eject(bool has_device, const char *device,\n               bool has_id, const char *id,\n               bool has_force, bool force, Error **errp)\n{\n    Error *local_err = NULL;\n    int rc;\n\n    if (!has_force) {\n        force = false;\n    }\n\n    rc = do_open_tray(has_device ? device : NULL,\n                      has_id ? id : NULL,\n                      force, &local_err);\n    if (rc && rc != -ENOSYS) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    error_free(local_err);\n\n    qmp_x_blockdev_remove_medium(has_device, device, has_id, id, errp);\n}\n\nvoid qmp_block_passwd(bool has_device, const char *device,\n                      bool has_node_name, const char *node_name,\n                      const char *password, Error **errp)\n{\n    Error *local_err = NULL;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n                        has_node_name ? node_name : NULL,\n                        &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_add_key(bs, password, errp);\n\n    aio_context_release(aio_context);\n}\n\n/*\n * Attempt to open the tray of @device.\n * If @force, ignore its tray lock.\n * Else, if the tray is locked, don't open it, but ask the guest to open it.\n * On error, store an error through @errp and return -errno.\n * If @device does not exist, return -ENODEV.\n * If it has no removable media, return -ENOTSUP.\n * If it has no tray, return -ENOSYS.\n * If the guest was asked to open the tray, return -EINPROGRESS.\n * Else, return 0.\n */\nstatic int do_open_tray(const char *blk_name, const char *qdev_id,\n                        bool force, Error **errp)\n{\n    BlockBackend *blk;\n    const char *device = qdev_id ?: blk_name;\n    bool locked;\n\n    blk = qmp_get_blk(blk_name, qdev_id, errp);\n    if (!blk) {\n        return -ENODEV;\n    }\n\n    if (!blk_dev_has_removable_media(blk)) {\n        error_setg(errp, \"Device '%s' is not removable\", device);\n        return -ENOTSUP;\n    }\n\n    if (!blk_dev_has_tray(blk)) {\n        error_setg(errp, \"Device '%s' does not have a tray\", device);\n        return -ENOSYS;\n    }\n\n    if (blk_dev_is_tray_open(blk)) {\n        return 0;\n    }\n\n    locked = blk_dev_is_medium_locked(blk);\n    if (locked) {\n        blk_dev_eject_request(blk, force);\n    }\n\n    if (!locked || force) {\n        blk_dev_change_media_cb(blk, false, &error_abort);\n    }\n\n    if (locked && !force) {\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n                   \"wait for tray to open and try again\", device);\n        return -EINPROGRESS;\n    }\n\n    return 0;\n}\n\nvoid qmp_blockdev_open_tray(bool has_device, const char *device,\n                            bool has_id, const char *id,\n                            bool has_force, bool force,\n                            Error **errp)\n{\n    Error *local_err = NULL;\n    int rc;\n\n    if (!has_force) {\n        force = false;\n    }\n    rc = do_open_tray(has_device ? device : NULL,\n                      has_id ? id : NULL,\n                      force, &local_err);\n    if (rc && rc != -ENOSYS && rc != -EINPROGRESS) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    error_free(local_err);\n}\n\nvoid qmp_blockdev_close_tray(bool has_device, const char *device,\n                             bool has_id, const char *id,\n                             Error **errp)\n{\n    BlockBackend *blk;\n    Error *local_err = NULL;\n\n    device = has_device ? device : NULL;\n    id = has_id ? id : NULL;\n\n    blk = qmp_get_blk(device, id, errp);\n    if (!blk) {\n        return;\n    }\n\n    if (!blk_dev_has_removable_media(blk)) {\n        error_setg(errp, \"Device '%s' is not removable\", device ?: id);\n        return;\n    }\n\n    if (!blk_dev_has_tray(blk)) {\n        /* Ignore this command on tray-less devices */\n        return;\n    }\n\n    if (!blk_dev_is_tray_open(blk)) {\n        return;\n    }\n\n    blk_dev_change_media_cb(blk, true, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n}\n\nvoid qmp_x_blockdev_remove_medium(bool has_device, const char *device,\n                                  bool has_id, const char *id, Error **errp)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    bool has_attached_device;\n\n    device = has_device ? device : NULL;\n    id = has_id ? id : NULL;\n\n    blk = qmp_get_blk(device, id, errp);\n    if (!blk) {\n        return;\n    }\n\n    /* For BBs without a device, we can exchange the BDS tree at will */\n    has_attached_device = blk_get_attached_dev(blk);\n\n    if (has_attached_device && !blk_dev_has_removable_media(blk)) {\n        error_setg(errp, \"Device '%s' is not removable\", device ?: id);\n        return;\n    }\n\n    if (has_attached_device && blk_dev_has_tray(blk) &&\n        !blk_dev_is_tray_open(blk))\n    {\n        error_setg(errp, \"Tray of device '%s' is not open\", device ?: id);\n        return;\n    }\n\n    bs = blk_bs(blk);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_EJECT, errp)) {\n        goto out;\n    }\n\n    blk_remove_bs(blk);\n\n    if (!blk_dev_has_tray(blk)) {\n        /* For tray-less devices, blockdev-open-tray is a no-op (or may not be\n         * called at all); therefore, the medium needs to be ejected here.\n         * Do it after blk_remove_bs() so blk_is_inserted(blk) returns the @load\n         * value passed here (i.e. false). */\n        blk_dev_change_media_cb(blk, false, &error_abort);\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic void qmp_blockdev_insert_anon_medium(BlockBackend *blk,\n                                            BlockDriverState *bs, Error **errp)\n{\n    Error *local_err = NULL;\n    bool has_device;\n    int ret;\n\n    /* For BBs without a device, we can exchange the BDS tree at will */\n    has_device = blk_get_attached_dev(blk);\n\n    if (has_device && !blk_dev_has_removable_media(blk)) {\n        error_setg(errp, \"Device is not removable\");\n        return;\n    }\n\n    if (has_device && blk_dev_has_tray(blk) && !blk_dev_is_tray_open(blk)) {\n        error_setg(errp, \"Tray of the device is not open\");\n        return;\n    }\n\n    if (blk_bs(blk)) {\n        error_setg(errp, \"There already is a medium in the device\");\n        return;\n    }\n\n    ret = blk_insert_bs(blk, bs, errp);\n    if (ret < 0) {\n        return;\n    }\n\n    if (!blk_dev_has_tray(blk)) {\n        /* For tray-less devices, blockdev-close-tray is a no-op (or may not be\n         * called at all); therefore, the medium needs to be pushed into the\n         * slot here.\n         * Do it after blk_insert_bs() so blk_is_inserted(blk) returns the @load\n         * value passed here (i.e. true). */\n        blk_dev_change_media_cb(blk, true, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            blk_remove_bs(blk);\n            return;\n        }\n    }\n}\n\nvoid qmp_x_blockdev_insert_medium(bool has_device, const char *device,\n                                  bool has_id, const char *id,\n                                  const char *node_name, Error **errp)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n\n    blk = qmp_get_blk(has_device ? device : NULL,\n                      has_id ? id : NULL,\n                      errp);\n    if (!blk) {\n        return;\n    }\n\n    bs = bdrv_find_node(node_name);\n    if (!bs) {\n        error_setg(errp, \"Node '%s' not found\", node_name);\n        return;\n    }\n\n    if (bdrv_has_blk(bs)) {\n        error_setg(errp, \"Node '%s' is already in use\", node_name);\n        return;\n    }\n\n    qmp_blockdev_insert_anon_medium(blk, bs, errp);\n}\n\nvoid qmp_blockdev_change_medium(bool has_device, const char *device,\n                                bool has_id, const char *id,\n                                const char *filename,\n                                bool has_format, const char *format,\n                                bool has_read_only,\n                                BlockdevChangeReadOnlyMode read_only,\n                                Error **errp)\n{\n    BlockBackend *blk;\n    BlockDriverState *medium_bs = NULL;\n    int bdrv_flags;\n    bool detect_zeroes;\n    int rc;\n    QDict *options = NULL;\n    Error *err = NULL;\n\n    blk = qmp_get_blk(has_device ? device : NULL,\n                      has_id ? id : NULL,\n                      errp);\n    if (!blk) {\n        goto fail;\n    }\n\n    if (blk_bs(blk)) {\n        blk_update_root_state(blk);\n    }\n\n    bdrv_flags = blk_get_open_flags_from_root_state(blk);\n    bdrv_flags &= ~(BDRV_O_TEMPORARY | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING |\n        BDRV_O_PROTOCOL);\n\n    if (!has_read_only) {\n        read_only = BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN;\n    }\n\n    switch (read_only) {\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN:\n        break;\n\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_READ_ONLY:\n        bdrv_flags &= ~BDRV_O_RDWR;\n        break;\n\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_READ_WRITE:\n        bdrv_flags |= BDRV_O_RDWR;\n        break;\n\n    default:\n        abort();\n    }\n\n    options = qdict_new();\n    detect_zeroes = blk_get_detect_zeroes_from_root_state(blk);\n    qdict_put_str(options, \"detect-zeroes\", detect_zeroes ? \"on\" : \"off\");\n\n    if (has_format) {\n        qdict_put_str(options, \"driver\", format);\n    }\n\n    medium_bs = bdrv_open(filename, NULL, options, bdrv_flags, errp);\n    if (!medium_bs) {\n        goto fail;\n    }\n\n    bdrv_add_key(medium_bs, NULL, &err);\n    if (err) {\n        error_propagate(errp, err);\n        goto fail;\n    }\n\n    rc = do_open_tray(has_device ? device : NULL,\n                      has_id ? id : NULL,\n                      false, &err);\n    if (rc && rc != -ENOSYS) {\n        error_propagate(errp, err);\n        goto fail;\n    }\n    error_free(err);\n    err = NULL;\n\n    qmp_x_blockdev_remove_medium(has_device, device, has_id, id, &err);\n    if (err) {\n        error_propagate(errp, err);\n        goto fail;\n    }\n\n    qmp_blockdev_insert_anon_medium(blk, medium_bs, &err);\n    if (err) {\n        error_propagate(errp, err);\n        goto fail;\n    }\n\n    qmp_blockdev_close_tray(has_device, device, has_id, id, errp);\n\nfail:\n    /* If the medium has been inserted, the device has its own reference, so\n     * ours must be relinquished; and if it has not been inserted successfully,\n     * the reference must be relinquished anyway */\n    bdrv_unref(medium_bs);\n}\n\n/* throttling disk I/O limits */\nvoid qmp_block_set_io_throttle(BlockIOThrottle *arg, Error **errp)\n{\n    ThrottleConfig cfg;\n    BlockDriverState *bs;\n    BlockBackend *blk;\n    AioContext *aio_context;\n\n    blk = qmp_get_blk(arg->has_device ? arg->device : NULL,\n                      arg->has_id ? arg->id : NULL,\n                      errp);\n    if (!blk) {\n        return;\n    }\n\n    aio_context = blk_get_aio_context(blk);\n    aio_context_acquire(aio_context);\n\n    bs = blk_bs(blk);\n    if (!bs) {\n        error_setg(errp, \"Device has no medium\");\n        goto out;\n    }\n\n    throttle_config_init(&cfg);\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg = arg->bps;\n    cfg.buckets[THROTTLE_BPS_READ].avg  = arg->bps_rd;\n    cfg.buckets[THROTTLE_BPS_WRITE].avg = arg->bps_wr;\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg = arg->iops;\n    cfg.buckets[THROTTLE_OPS_READ].avg  = arg->iops_rd;\n    cfg.buckets[THROTTLE_OPS_WRITE].avg = arg->iops_wr;\n\n    if (arg->has_bps_max) {\n        cfg.buckets[THROTTLE_BPS_TOTAL].max = arg->bps_max;\n    }\n    if (arg->has_bps_rd_max) {\n        cfg.buckets[THROTTLE_BPS_READ].max = arg->bps_rd_max;\n    }\n    if (arg->has_bps_wr_max) {\n        cfg.buckets[THROTTLE_BPS_WRITE].max = arg->bps_wr_max;\n    }\n    if (arg->has_iops_max) {\n        cfg.buckets[THROTTLE_OPS_TOTAL].max = arg->iops_max;\n    }\n    if (arg->has_iops_rd_max) {\n        cfg.buckets[THROTTLE_OPS_READ].max = arg->iops_rd_max;\n    }\n    if (arg->has_iops_wr_max) {\n        cfg.buckets[THROTTLE_OPS_WRITE].max = arg->iops_wr_max;\n    }\n\n    if (arg->has_bps_max_length) {\n        cfg.buckets[THROTTLE_BPS_TOTAL].burst_length = arg->bps_max_length;\n    }\n    if (arg->has_bps_rd_max_length) {\n        cfg.buckets[THROTTLE_BPS_READ].burst_length = arg->bps_rd_max_length;\n    }\n    if (arg->has_bps_wr_max_length) {\n        cfg.buckets[THROTTLE_BPS_WRITE].burst_length = arg->bps_wr_max_length;\n    }\n    if (arg->has_iops_max_length) {\n        cfg.buckets[THROTTLE_OPS_TOTAL].burst_length = arg->iops_max_length;\n    }\n    if (arg->has_iops_rd_max_length) {\n        cfg.buckets[THROTTLE_OPS_READ].burst_length = arg->iops_rd_max_length;\n    }\n    if (arg->has_iops_wr_max_length) {\n        cfg.buckets[THROTTLE_OPS_WRITE].burst_length = arg->iops_wr_max_length;\n    }\n\n    if (arg->has_iops_size) {\n        cfg.op_size = arg->iops_size;\n    }\n\n    if (!throttle_is_valid(&cfg, errp)) {\n        goto out;\n    }\n\n    if (throttle_enabled(&cfg)) {\n        /* Enable I/O limits if they're not enabled yet, otherwise\n         * just update the throttling group. */\n        if (!blk_get_public(blk)->throttle_state) {\n            blk_io_limits_enable(blk,\n                                 arg->has_group ? arg->group :\n                                 arg->has_device ? arg->device :\n                                 arg->id);\n        } else if (arg->has_group) {\n            blk_io_limits_update_group(blk, arg->group);\n        }\n        /* Set the new throttling configuration */\n        blk_set_io_limits(blk, &cfg);\n    } else if (blk_get_public(blk)->throttle_state) {\n        /* If all throttling settings are set to 0, disable I/O limits */\n        blk_io_limits_disable(blk);\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_dirty_bitmap_add(const char *node, const char *name,\n                                bool has_granularity, uint32_t granularity,\n                                Error **errp)\n{\n    AioContext *aio_context;\n    BlockDriverState *bs;\n\n    if (!name || name[0] == '\\0') {\n        error_setg(errp, \"Bitmap name cannot be empty\");\n        return;\n    }\n\n    bs = bdrv_lookup_bs(node, node, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (has_granularity) {\n        if (granularity < 512 || !is_power_of_2(granularity)) {\n            error_setg(errp, \"Granularity must be power of 2 \"\n                             \"and at least 512\");\n            goto out;\n        }\n    } else {\n        /* Default to cluster size, if available: */\n        granularity = bdrv_get_default_bitmap_granularity(bs);\n    }\n\n    bdrv_create_dirty_bitmap(bs, granularity, name, errp);\n\n out:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_dirty_bitmap_remove(const char *node, const char *name,\n                                   Error **errp)\n{\n    AioContext *aio_context;\n    BlockDriverState *bs;\n    BdrvDirtyBitmap *bitmap;\n\n    bitmap = block_dirty_bitmap_lookup(node, name, &bs, &aio_context, errp);\n    if (!bitmap || !bs) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_frozen(bitmap)) {\n        error_setg(errp,\n                   \"Bitmap '%s' is currently frozen and cannot be removed\",\n                   name);\n        goto out;\n    }\n    bdrv_dirty_bitmap_make_anon(bitmap);\n    bdrv_release_dirty_bitmap(bs, bitmap);\n\n out:\n    aio_context_release(aio_context);\n}\n\n/**\n * Completely clear a bitmap, for the purposes of synchronizing a bitmap\n * immediately after a full backup operation.\n */\nvoid qmp_block_dirty_bitmap_clear(const char *node, const char *name,\n                                  Error **errp)\n{\n    AioContext *aio_context;\n    BdrvDirtyBitmap *bitmap;\n    BlockDriverState *bs;\n\n    bitmap = block_dirty_bitmap_lookup(node, name, &bs, &aio_context, errp);\n    if (!bitmap || !bs) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_frozen(bitmap)) {\n        error_setg(errp,\n                   \"Bitmap '%s' is currently frozen and cannot be modified\",\n                   name);\n        goto out;\n    } else if (!bdrv_dirty_bitmap_enabled(bitmap)) {\n        error_setg(errp,\n                   \"Bitmap '%s' is currently disabled and cannot be cleared\",\n                   name);\n        goto out;\n    }\n\n    bdrv_clear_dirty_bitmap(bitmap, NULL);\n\n out:\n    aio_context_release(aio_context);\n}\n\nvoid hmp_drive_del(Monitor *mon, const QDict *qdict)\n{\n    const char *id = qdict_get_str(qdict, \"id\");\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n\n    bs = bdrv_find_node(id);\n    if (bs) {\n        qmp_blockdev_del(id, &local_err);\n        if (local_err) {\n            error_report_err(local_err);\n        }\n        return;\n    }\n\n    blk = blk_by_name(id);\n    if (!blk) {\n        error_report(\"Device '%s' not found\", id);\n        return;\n    }\n\n    if (!blk_legacy_dinfo(blk)) {\n        error_report(\"Deleting device added with blockdev-add\"\n                     \" is not supported\");\n        return;\n    }\n\n    aio_context = blk_get_aio_context(blk);\n    aio_context_acquire(aio_context);\n\n    bs = blk_bs(blk);\n    if (bs) {\n        if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_DRIVE_DEL, &local_err)) {\n            error_report_err(local_err);\n            aio_context_release(aio_context);\n            return;\n        }\n\n        blk_remove_bs(blk);\n    }\n\n    /* Make the BlockBackend and the attached BlockDriverState anonymous */\n    monitor_remove_blk(blk);\n\n    /* If this BlockBackend has a device attached to it, its refcount will be\n     * decremented when the device is removed; otherwise we have to do so here.\n     */\n    if (blk_get_attached_dev(blk)) {\n        /* Further I/O must not pause the guest */\n        blk_set_on_error(blk, BLOCKDEV_ON_ERROR_REPORT,\n                         BLOCKDEV_ON_ERROR_REPORT);\n    } else {\n        blk_unref(blk);\n    }\n\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_resize(bool has_device, const char *device,\n                      bool has_node_name, const char *node_name,\n                      int64_t size, Error **errp)\n{\n    Error *local_err = NULL;\n    BlockBackend *blk = NULL;\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    int ret;\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n                        has_node_name ? node_name : NULL,\n                        &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!bdrv_is_first_non_filter(bs)) {\n        error_setg(errp, QERR_FEATURE_DISABLED, \"resize\");\n        goto out;\n    }\n\n    if (size < 0) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n        goto out;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_RESIZE, NULL)) {\n        error_setg(errp, QERR_DEVICE_IN_USE, device);\n        goto out;\n    }\n\n    blk = blk_new(BLK_PERM_RESIZE, BLK_PERM_ALL);\n    ret = blk_insert_bs(blk, bs, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    bdrv_drained_begin(bs);\n    ret = blk_truncate(blk, size, errp);\n    bdrv_drained_end(bs);\n\nout:\n    blk_unref(blk);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n                      bool has_base, const char *base,\n                      bool has_base_node, const char *base_node,\n                      bool has_backing_file, const char *backing_file,\n                      bool has_speed, int64_t speed,\n                      bool has_on_error, BlockdevOnError on_error,\n                      Error **errp)\n{\n    BlockDriverState *bs, *iter;\n    BlockDriverState *base_bs = NULL;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n    const char *base_name = NULL;\n\n    if (!has_on_error) {\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n\n    bs = bdrv_lookup_bs(device, device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (has_base && has_base_node) {\n        error_setg(errp, \"'base' and 'base-node' cannot be specified \"\n                   \"at the same time\");\n        goto out;\n    }\n\n    if (has_base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n            goto out;\n        }\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n        base_name = base;\n    }\n\n    if (has_base_node) {\n        base_bs = bdrv_lookup_bs(NULL, base_node, errp);\n        if (!base_bs) {\n            goto out;\n        }\n        if (bs == base_bs || !bdrv_chain_contains(bs, base_bs)) {\n            error_setg(errp, \"Node '%s' is not a backing image of '%s'\",\n                       base_node, device);\n            goto out;\n        }\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n        base_name = base_bs->filename;\n    }\n\n    /* Check for op blockers in the whole chain between bs and base */\n    for (iter = bs; iter && iter != base_bs; iter = backing_bs(iter)) {\n        if (bdrv_op_is_blocked(iter, BLOCK_OP_TYPE_STREAM, errp)) {\n            goto out;\n        }\n    }\n\n    /* if we are streaming the entire chain, the result will have no backing\n     * file, and specifying one is therefore an error */\n    if (base_bs == NULL && has_backing_file) {\n        error_setg(errp, \"backing file specified, but streaming the \"\n                         \"entire chain\");\n        goto out;\n    }\n\n    /* backing_file string overrides base bs filename */\n    base_name = has_backing_file ? backing_file : base_name;\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n                 has_speed ? speed : 0, on_error, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    trace_qmp_block_stream(bs, bs->job);\n\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_commit(bool has_job_id, const char *job_id, const char *device,\n                      bool has_base, const char *base,\n                      bool has_top, const char *top,\n                      bool has_backing_file, const char *backing_file,\n                      bool has_speed, int64_t speed,\n                      bool has_filter_node_name, const char *filter_node_name,\n                      Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *iter;\n    BlockDriverState *base_bs, *top_bs;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n    /* This will be part of the QMP command, if/when the\n     * BlockdevOnError change for blkmirror makes it in\n     */\n    BlockdevOnError on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if (!has_speed) {\n        speed = 0;\n    }\n    if (!has_filter_node_name) {\n        filter_node_name = NULL;\n    }\n\n    /* Important Note:\n     *  libvirt relies on the DeviceNotFound error class in order to probe for\n     *  live commit feature versions; for this to work, we must make sure to\n     *  perform the device lookup before any generic errors that may occur in a\n     *  scenario in which all optional arguments are omitted. */\n    bs = qmp_get_root_bs(device, &local_err);\n    if (!bs) {\n        bs = bdrv_lookup_bs(device, device, NULL);\n        if (!bs) {\n            error_free(local_err);\n            error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                      \"Device '%s' not found\", device);\n        } else {\n            error_propagate(errp, local_err);\n        }\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT_SOURCE, errp)) {\n        goto out;\n    }\n\n    /* default top_bs is the active layer */\n    top_bs = bs;\n\n    if (has_top && top) {\n        if (strcmp(bs->filename, top) != 0) {\n            top_bs = bdrv_find_backing_image(bs, top);\n        }\n    }\n\n    if (top_bs == NULL) {\n        error_setg(errp, \"Top image file %s not found\", top ? top : \"NULL\");\n        goto out;\n    }\n\n    assert(bdrv_get_aio_context(top_bs) == aio_context);\n\n    if (has_base && base) {\n        base_bs = bdrv_find_backing_image(top_bs, base);\n    } else {\n        base_bs = bdrv_find_base(top_bs);\n    }\n\n    if (base_bs == NULL) {\n        error_setg(errp, QERR_BASE_NOT_FOUND, base ? base : \"NULL\");\n        goto out;\n    }\n\n    assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n    for (iter = top_bs; iter != backing_bs(base_bs); iter = backing_bs(iter)) {\n        if (bdrv_op_is_blocked(iter, BLOCK_OP_TYPE_COMMIT_TARGET, errp)) {\n            goto out;\n        }\n    }\n\n    /* Do not allow attempts to commit an image into itself */\n    if (top_bs == base_bs) {\n        error_setg(errp, \"cannot commit an image into itself\");\n        goto out;\n    }\n\n    if (top_bs == bs) {\n        if (has_backing_file) {\n            error_setg(errp, \"'backing-file' specified,\"\n                             \" but 'top' is the active layer\");\n            goto out;\n        }\n        commit_active_start(has_job_id ? job_id : NULL, bs, base_bs,\n                            BLOCK_JOB_DEFAULT, speed, on_error,\n                            filter_node_name, NULL, NULL, &local_err, false);\n    } else {\n        BlockDriverState *overlay_bs = bdrv_find_overlay(bs, top_bs);\n        if (bdrv_op_is_blocked(overlay_bs, BLOCK_OP_TYPE_COMMIT_TARGET, errp)) {\n            goto out;\n        }\n        commit_start(has_job_id ? job_id : NULL, bs, base_bs, top_bs, speed,\n                     on_error, has_backing_file ? backing_file : NULL,\n                     filter_node_name, &local_err);\n    }\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic BlockJob *do_drive_backup(DriveBackup *backup, BlockJobTxn *txn,\n                                 Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    BlockDriverState *source = NULL;\n    BlockJob *job = NULL;\n    BdrvDirtyBitmap *bmap = NULL;\n    AioContext *aio_context;\n    QDict *options = NULL;\n    Error *local_err = NULL;\n    int flags;\n    int64_t size;\n    bool set_backing_hd = false;\n\n    if (!backup->has_speed) {\n        backup->speed = 0;\n    }\n    if (!backup->has_on_source_error) {\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_on_target_error) {\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_mode) {\n        backup->mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n    }\n    if (!backup->has_job_id) {\n        backup->job_id = NULL;\n    }\n    if (!backup->has_compress) {\n        backup->compress = false;\n    }\n\n    bs = qmp_get_root_bs(backup->device, errp);\n    if (!bs) {\n        return NULL;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!backup->has_format) {\n        backup->format = backup->mode == NEW_IMAGE_MODE_EXISTING ?\n                         NULL : (char*) bs->drv->format_name;\n    }\n\n    /* Early check to avoid creating target */\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n        goto out;\n    }\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n    /* See if we have a backing HD we can use to create our new image\n     * on top of. */\n    if (backup->sync == MIRROR_SYNC_MODE_TOP) {\n        source = backing_bs(bs);\n        if (!source) {\n            backup->sync = MIRROR_SYNC_MODE_FULL;\n        }\n    }\n    if (backup->sync == MIRROR_SYNC_MODE_NONE) {\n        source = bs;\n        flags |= BDRV_O_NO_BACKING;\n        set_backing_hd = true;\n    }\n\n    size = bdrv_getlength(bs);\n    if (size < 0) {\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n        goto out;\n    }\n\n    if (backup->mode != NEW_IMAGE_MODE_EXISTING) {\n        assert(backup->format);\n        if (source) {\n            bdrv_img_create(backup->target, backup->format, source->filename,\n                            source->drv->format_name, NULL,\n                            size, flags, &local_err, false);\n        } else {\n            bdrv_img_create(backup->target, backup->format, NULL, NULL, NULL,\n                            size, flags, &local_err, false);\n        }\n    }\n\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    if (backup->format) {\n        if (!options) {\n            options = qdict_new();\n        }\n        qdict_put_str(options, \"driver\", backup->format);\n    }\n\n    target_bs = bdrv_open(backup->target, NULL, options, flags, errp);\n    if (!target_bs) {\n        goto out;\n    }\n\n    bdrv_set_aio_context(target_bs, aio_context);\n\n    if (set_backing_hd) {\n        bdrv_set_backing_hd(target_bs, source, &local_err);\n        if (local_err) {\n            bdrv_unref(target_bs);\n            goto out;\n        }\n    }\n\n    if (backup->has_bitmap) {\n        bmap = bdrv_find_dirty_bitmap(bs, backup->bitmap);\n        if (!bmap) {\n            error_setg(errp, \"Bitmap '%s' could not be found\", backup->bitmap);\n            bdrv_unref(target_bs);\n            goto out;\n        }\n    }\n\n    job = backup_job_create(backup->job_id, bs, target_bs, backup->speed,\n                            backup->sync, bmap, backup->compress,\n                            backup->on_source_error, backup->on_target_error,\n                            BLOCK_JOB_DEFAULT, NULL, NULL, txn, &local_err);\n    bdrv_unref(target_bs);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\nout:\n    aio_context_release(aio_context);\n    return job;\n}\n\nvoid qmp_drive_backup(DriveBackup *arg, Error **errp)\n{\n\n    BlockJob *job;\n    job = do_drive_backup(arg, NULL, errp);\n    if (job) {\n        block_job_start(job);\n    }\n}\n\nBlockDeviceInfoList *qmp_query_named_block_nodes(Error **errp)\n{\n    return bdrv_named_nodes_list(errp);\n}\n\nBlockJob *do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn,\n                             Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    Error *local_err = NULL;\n    AioContext *aio_context;\n    BlockJob *job = NULL;\n\n    if (!backup->has_speed) {\n        backup->speed = 0;\n    }\n    if (!backup->has_on_source_error) {\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_on_target_error) {\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_job_id) {\n        backup->job_id = NULL;\n    }\n    if (!backup->has_compress) {\n        backup->compress = false;\n    }\n\n    bs = qmp_get_root_bs(backup->device, errp);\n    if (!bs) {\n        return NULL;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);\n    if (!target_bs) {\n        goto out;\n    }\n\n    if (bdrv_get_aio_context(target_bs) != aio_context) {\n        if (!bdrv_has_blk(target_bs)) {\n            /* The target BDS is not attached, we can safely move it to another\n             * AioContext. */\n            bdrv_set_aio_context(target_bs, aio_context);\n        } else {\n            error_setg(errp, \"Target is attached to a different thread from \"\n                             \"source.\");\n            goto out;\n        }\n    }\n    job = backup_job_create(backup->job_id, bs, target_bs, backup->speed,\n                            backup->sync, NULL, backup->compress,\n                            backup->on_source_error, backup->on_target_error,\n                            BLOCK_JOB_DEFAULT, NULL, NULL, txn, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    }\nout:\n    aio_context_release(aio_context);\n    return job;\n}\n\nvoid qmp_blockdev_backup(BlockdevBackup *arg, Error **errp)\n{\n    BlockJob *job;\n    job = do_blockdev_backup(arg, NULL, errp);\n    if (job) {\n        block_job_start(job);\n    }\n}\n\n/* Parameter check and block job starting for drive mirroring.\n * Caller should hold @device and @target's aio context (must be the same).\n **/\nstatic void blockdev_mirror_common(const char *job_id, BlockDriverState *bs,\n                                   BlockDriverState *target,\n                                   bool has_replaces, const char *replaces,\n                                   enum MirrorSyncMode sync,\n                                   BlockMirrorBackingMode backing_mode,\n                                   bool has_speed, int64_t speed,\n                                   bool has_granularity, uint32_t granularity,\n                                   bool has_buf_size, int64_t buf_size,\n                                   bool has_on_source_error,\n                                   BlockdevOnError on_source_error,\n                                   bool has_on_target_error,\n                                   BlockdevOnError on_target_error,\n                                   bool has_unmap, bool unmap,\n                                   bool has_filter_node_name,\n                                   const char *filter_node_name,\n                                   Error **errp)\n{\n\n    if (!has_speed) {\n        speed = 0;\n    }\n    if (!has_on_source_error) {\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!has_on_target_error) {\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!has_granularity) {\n        granularity = 0;\n    }\n    if (!has_buf_size) {\n        buf_size = 0;\n    }\n    if (!has_unmap) {\n        unmap = true;\n    }\n    if (!has_filter_node_name) {\n        filter_node_name = NULL;\n    }\n\n    if (granularity != 0 && (granularity < 512 || granularity > 1048576 * 64)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"granularity\",\n                   \"a value in range [512B, 64MB]\");\n        return;\n    }\n    if (granularity & (granularity - 1)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"granularity\",\n                   \"power of 2\");\n        return;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_MIRROR_SOURCE, errp)) {\n        return;\n    }\n    if (bdrv_op_is_blocked(target, BLOCK_OP_TYPE_MIRROR_TARGET, errp)) {\n        return;\n    }\n\n    if (!bs->backing && sync == MIRROR_SYNC_MODE_TOP) {\n        sync = MIRROR_SYNC_MODE_FULL;\n    }\n\n    /* pass the node name to replace to mirror start since it's loose coupling\n     * and will allow to check whether the node still exist at mirror completion\n     */\n    mirror_start(job_id, bs, target,\n                 has_replaces ? replaces : NULL,\n                 speed, granularity, buf_size, sync, backing_mode,\n                 on_source_error, on_target_error, unmap, filter_node_name,\n                 errp);\n}\n\nvoid qmp_drive_mirror(DriveMirror *arg, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *source, *target_bs;\n    AioContext *aio_context;\n    BlockMirrorBackingMode backing_mode;\n    Error *local_err = NULL;\n    QDict *options = NULL;\n    int flags;\n    int64_t size;\n    const char *format = arg->format;\n\n    bs = qmp_get_root_bs(arg->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!arg->has_mode) {\n        arg->mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n    }\n\n    if (!arg->has_format) {\n        format = (arg->mode == NEW_IMAGE_MODE_EXISTING\n                  ? NULL : bs->drv->format_name);\n    }\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n    source = backing_bs(bs);\n    if (!source && arg->sync == MIRROR_SYNC_MODE_TOP) {\n        arg->sync = MIRROR_SYNC_MODE_FULL;\n    }\n    if (arg->sync == MIRROR_SYNC_MODE_NONE) {\n        source = bs;\n    }\n\n    size = bdrv_getlength(bs);\n    if (size < 0) {\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n        goto out;\n    }\n\n    if (arg->has_replaces) {\n        BlockDriverState *to_replace_bs;\n        AioContext *replace_aio_context;\n        int64_t replace_size;\n\n        if (!arg->has_node_name) {\n            error_setg(errp, \"a node-name must be provided when replacing a\"\n                             \" named node of the graph\");\n            goto out;\n        }\n\n        to_replace_bs = check_to_replace_node(bs, arg->replaces, &local_err);\n\n        if (!to_replace_bs) {\n            error_propagate(errp, local_err);\n            goto out;\n        }\n\n        replace_aio_context = bdrv_get_aio_context(to_replace_bs);\n        aio_context_acquire(replace_aio_context);\n        replace_size = bdrv_getlength(to_replace_bs);\n        aio_context_release(replace_aio_context);\n\n        if (size != replace_size) {\n            error_setg(errp, \"cannot replace image with a mirror image of \"\n                             \"different size\");\n            goto out;\n        }\n    }\n\n    if (arg->mode == NEW_IMAGE_MODE_ABSOLUTE_PATHS) {\n        backing_mode = MIRROR_SOURCE_BACKING_CHAIN;\n    } else {\n        backing_mode = MIRROR_OPEN_BACKING_CHAIN;\n    }\n\n    if ((arg->sync == MIRROR_SYNC_MODE_FULL || !source)\n        && arg->mode != NEW_IMAGE_MODE_EXISTING)\n    {\n        /* create new image w/o backing file */\n        assert(format);\n        bdrv_img_create(arg->target, format,\n                        NULL, NULL, NULL, size, flags, &local_err, false);\n    } else {\n        switch (arg->mode) {\n        case NEW_IMAGE_MODE_EXISTING:\n            break;\n        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:\n            /* create new image with backing file */\n            bdrv_img_create(arg->target, format,\n                            source->filename,\n                            source->drv->format_name,\n                            NULL, size, flags, &local_err, false);\n            break;\n        default:\n            abort();\n        }\n    }\n\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    options = qdict_new();\n    if (arg->has_node_name) {\n        qdict_put_str(options, \"node-name\", arg->node_name);\n    }\n    if (format) {\n        qdict_put_str(options, \"driver\", format);\n    }\n\n    /* Mirroring takes care of copy-on-write using the source's backing\n     * file.\n     */\n    target_bs = bdrv_open(arg->target, NULL, options,\n                          flags | BDRV_O_NO_BACKING, errp);\n    if (!target_bs) {\n        goto out;\n    }\n\n    bdrv_set_aio_context(target_bs, aio_context);\n\n    blockdev_mirror_common(arg->has_job_id ? arg->job_id : NULL, bs, target_bs,\n                           arg->has_replaces, arg->replaces, arg->sync,\n                           backing_mode, arg->has_speed, arg->speed,\n                           arg->has_granularity, arg->granularity,\n                           arg->has_buf_size, arg->buf_size,\n                           arg->has_on_source_error, arg->on_source_error,\n                           arg->has_on_target_error, arg->on_target_error,\n                           arg->has_unmap, arg->unmap,\n                           false, NULL,\n                           &local_err);\n    bdrv_unref(target_bs);\n    error_propagate(errp, local_err);\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_blockdev_mirror(bool has_job_id, const char *job_id,\n                         const char *device, const char *target,\n                         bool has_replaces, const char *replaces,\n                         MirrorSyncMode sync,\n                         bool has_speed, int64_t speed,\n                         bool has_granularity, uint32_t granularity,\n                         bool has_buf_size, int64_t buf_size,\n                         bool has_on_source_error,\n                         BlockdevOnError on_source_error,\n                         bool has_on_target_error,\n                         BlockdevOnError on_target_error,\n                         bool has_filter_node_name,\n                         const char *filter_node_name,\n                         Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    AioContext *aio_context;\n    BlockMirrorBackingMode backing_mode = MIRROR_LEAVE_BACKING_CHAIN;\n    Error *local_err = NULL;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    target_bs = bdrv_lookup_bs(target, target, errp);\n    if (!target_bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_set_aio_context(target_bs, aio_context);\n\n    blockdev_mirror_common(has_job_id ? job_id : NULL, bs, target_bs,\n                           has_replaces, replaces, sync, backing_mode,\n                           has_speed, speed,\n                           has_granularity, granularity,\n                           has_buf_size, buf_size,\n                           has_on_source_error, on_source_error,\n                           has_on_target_error, on_target_error,\n                           true, true,\n                           has_filter_node_name, filter_node_name,\n                           &local_err);\n    error_propagate(errp, local_err);\n\n    aio_context_release(aio_context);\n}\n\n/* Get a block job using its ID and acquire its AioContext */\nstatic BlockJob *find_block_job(const char *id, AioContext **aio_context,\n                                Error **errp)\n{\n    BlockJob *job;\n\n    assert(id != NULL);\n\n    *aio_context = NULL;\n\n    job = block_job_get(id);\n\n    if (!job) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n                  \"Block job '%s' not found\", id);\n        return NULL;\n    }\n\n    *aio_context = blk_get_aio_context(job->blk);\n    aio_context_acquire(*aio_context);\n\n    return job;\n}\n\nvoid qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    block_job_set_speed(job, speed, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_cancel(const char *device,\n                          bool has_force, bool force, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    if (!has_force) {\n        force = false;\n    }\n\n    if (block_job_user_paused(job) && !force) {\n        error_setg(errp, \"The block job for device '%s' is currently paused\",\n                   device);\n        goto out;\n    }\n\n    trace_qmp_block_job_cancel(job);\n    block_job_cancel(job);\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_pause(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job || block_job_user_paused(job)) {\n        return;\n    }\n\n    trace_qmp_block_job_pause(job);\n    block_job_user_pause(job);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_resume(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job || !block_job_user_paused(job)) {\n        return;\n    }\n\n    trace_qmp_block_job_resume(job);\n    block_job_iostatus_reset(job);\n    block_job_user_resume(job);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_complete(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_block_job_complete(job);\n    block_job_complete(job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_change_backing_file(const char *device,\n                             const char *image_node_name,\n                             const char *backing_file,\n                             Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    AioContext *aio_context;\n    BlockDriverState *image_bs = NULL;\n    Error *local_err = NULL;\n    bool ro;\n    int open_flags;\n    int ret;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    image_bs = bdrv_lookup_bs(NULL, image_node_name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    if (!image_bs) {\n        error_setg(errp, \"image file not found\");\n        goto out;\n    }\n\n    if (bdrv_find_base(image_bs) == image_bs) {\n        error_setg(errp, \"not allowing backing file change on an image \"\n                         \"without a backing file\");\n        goto out;\n    }\n\n    /* even though we are not necessarily operating on bs, we need it to\n     * determine if block ops are currently prohibited on the chain */\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_CHANGE, errp)) {\n        goto out;\n    }\n\n    /* final sanity check */\n    if (!bdrv_chain_contains(bs, image_bs)) {\n        error_setg(errp, \"'%s' and image file are not in the same chain\",\n                   device);\n        goto out;\n    }\n\n    /* if not r/w, reopen to make r/w */\n    open_flags = image_bs->open_flags;\n    ro = bdrv_is_read_only(image_bs);\n\n    if (ro) {\n        bdrv_reopen(image_bs, open_flags | BDRV_O_RDWR, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            goto out;\n        }\n    }\n\n    ret = bdrv_change_backing_file(image_bs, backing_file,\n                               image_bs->drv ? image_bs->drv->format_name : \"\");\n\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not change backing file to '%s'\",\n                         backing_file);\n        /* don't exit here, so we can try to restore open flags if\n         * appropriate */\n    }\n\n    if (ro) {\n        bdrv_reopen(image_bs, open_flags, &local_err);\n        error_propagate(errp, local_err);\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\nvoid hmp_drive_add_node(Monitor *mon, const char *optstr)\n{\n    QemuOpts *opts;\n    QDict *qdict;\n    Error *local_err = NULL;\n\n    opts = qemu_opts_parse_noisily(&qemu_drive_opts, optstr, false);\n    if (!opts) {\n        return;\n    }\n\n    qdict = qemu_opts_to_qdict(opts, NULL);\n\n    if (!qdict_get_try_str(qdict, \"node-name\")) {\n        QDECREF(qdict);\n        error_report(\"'node-name' needs to be specified\");\n        goto out;\n    }\n\n    BlockDriverState *bs = bds_tree_init(qdict, &local_err);\n    if (!bs) {\n        error_report_err(local_err);\n        goto out;\n    }\n\n    QTAILQ_INSERT_TAIL(&monitor_bdrv_states, bs, monitor_list);\n\nout:\n    qemu_opts_del(opts);\n}\n\nvoid qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n{\n    BlockDriverState *bs;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n    QDict *qdict;\n    Error *local_err = NULL;\n\n    visit_type_BlockdevOptions(v, NULL, &options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto fail;\n    }\n\n    visit_complete(v, &obj);\n    qdict = qobject_to_qdict(obj);\n\n    qdict_flatten(qdict);\n\n    if (!qdict_get_try_str(qdict, \"node-name\")) {\n        error_setg(errp, \"'node-name' must be specified for the root node\");\n        goto fail;\n    }\n\n    bs = bds_tree_init(qdict, errp);\n    if (!bs) {\n        goto fail;\n    }\n\n    QTAILQ_INSERT_TAIL(&monitor_bdrv_states, bs, monitor_list);\n\n    if (bs && bdrv_key_required(bs)) {\n        QTAILQ_REMOVE(&monitor_bdrv_states, bs, monitor_list);\n        bdrv_unref(bs);\n        error_setg(errp, \"blockdev-add doesn't support encrypted devices\");\n        goto fail;\n    }\n\nfail:\n    visit_free(v);\n}\n\nvoid qmp_blockdev_del(const char *node_name, Error **errp)\n{\n    AioContext *aio_context;\n    BlockDriverState *bs;\n\n    bs = bdrv_find_node(node_name);\n    if (!bs) {\n        error_setg(errp, \"Cannot find node %s\", node_name);\n        return;\n    }\n    if (bdrv_has_blk(bs)) {\n        error_setg(errp, \"Node %s is in use\", node_name);\n        return;\n    }\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_DRIVE_DEL, errp)) {\n        goto out;\n    }\n\n    if (!bs->monitor_list.tqe_prev) {\n        error_setg(errp, \"Node %s is not owned by the monitor\",\n                   bs->node_name);\n        goto out;\n    }\n\n    if (bs->refcnt > 1) {\n        error_setg(errp, \"Block device %s is in use\",\n                   bdrv_get_device_or_node_name(bs));\n        goto out;\n    }\n\n    QTAILQ_REMOVE(&monitor_bdrv_states, bs, monitor_list);\n    bdrv_unref(bs);\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic BdrvChild *bdrv_find_child(BlockDriverState *parent_bs,\n                                  const char *child_name)\n{\n    BdrvChild *child;\n\n    QLIST_FOREACH(child, &parent_bs->children, next) {\n        if (strcmp(child->name, child_name) == 0) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\nvoid qmp_x_blockdev_change(const char *parent, bool has_child,\n                           const char *child, bool has_node,\n                           const char *node, Error **errp)\n{\n    BlockDriverState *parent_bs, *new_bs = NULL;\n    BdrvChild *p_child;\n\n    parent_bs = bdrv_lookup_bs(parent, parent, errp);\n    if (!parent_bs) {\n        return;\n    }\n\n    if (has_child == has_node) {\n        if (has_child) {\n            error_setg(errp, \"The parameters child and node are in conflict\");\n        } else {\n            error_setg(errp, \"Either child or node must be specified\");\n        }\n        return;\n    }\n\n    if (has_child) {\n        p_child = bdrv_find_child(parent_bs, child);\n        if (!p_child) {\n            error_setg(errp, \"Node '%s' does not have child '%s'\",\n                       parent, child);\n            return;\n        }\n        bdrv_del_child(parent_bs, p_child, errp);\n    }\n\n    if (has_node) {\n        new_bs = bdrv_find_node(node);\n        if (!new_bs) {\n            error_setg(errp, \"Node '%s' not found\", node);\n            return;\n        }\n        bdrv_add_child(parent_bs, new_bs, errp);\n    }\n}\n\nBlockJobInfoList *qmp_query_block_jobs(Error **errp)\n{\n    BlockJobInfoList *head = NULL, **p_next = &head;\n    BlockJob *job;\n\n    for (job = block_job_next(NULL); job; job = block_job_next(job)) {\n        BlockJobInfoList *elem;\n        AioContext *aio_context;\n\n        if (block_job_is_internal(job)) {\n            continue;\n        }\n        elem = g_new0(BlockJobInfoList, 1);\n        aio_context = blk_get_aio_context(job->blk);\n        aio_context_acquire(aio_context);\n        elem->value = block_job_query(job, errp);\n        aio_context_release(aio_context);\n        if (!elem->value) {\n            g_free(elem);\n            qapi_free_BlockJobInfoList(head);\n            return NULL;\n        }\n        *p_next = elem;\n        p_next = &elem->next;\n    }\n\n    return head;\n}\n\nQemuOptsList qemu_common_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_common_drive_opts.head),\n    .desc = {\n        {\n            .name = \"snapshot\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"enable/disable snapshot mode\",\n        },{\n            .name = \"aio\",\n            .type = QEMU_OPT_STRING,\n            .help = \"host AIO implementation (threads, native)\",\n        },{\n            .name = BDRV_OPT_CACHE_WB,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Enable writeback mode\",\n        },{\n            .name = \"format\",\n            .type = QEMU_OPT_STRING,\n            .help = \"disk format (raw, qcow2, ...)\",\n        },{\n            .name = \"rerror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"read error action\",\n        },{\n            .name = \"werror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"write error action\",\n        },{\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"open drive file as read-only\",\n        },\n\n        THROTTLE_OPTS,\n\n        {\n            .name = \"throttling.group\",\n            .type = QEMU_OPT_STRING,\n            .help = \"name of the block throttling group\",\n        },{\n            .name = \"copy-on-read\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"copy read data from backing file into image file\",\n        },{\n            .name = \"detect-zeroes\",\n            .type = QEMU_OPT_STRING,\n            .help = \"try to optimize zero writes (off, on, unmap)\",\n        },{\n            .name = \"stats-account-invalid\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"whether to account for invalid I/O operations \"\n                    \"in the statistics\",\n        },{\n            .name = \"stats-account-failed\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"whether to account for failed I/O operations \"\n                    \"in the statistics\",\n        },\n        { /* end of list */ }\n    },\n};\n\nQemuOptsList qemu_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_drive_opts.head),\n    .desc = {\n        /*\n         * no elements => accept any params\n         * validation will happen later\n         */\n        { /* end of list */ }\n    },\n};\n"
        },
        {
          "name": "blockjob.c",
          "type": "blob",
          "size": 22.0458984375,
          "content": "/*\n * QEMU System Emulator block driver\n *\n * Copyright (c) 2011 IBM Corp.\n * Copyright (c) 2012 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"block/block.h\"\n#include \"block/blockjob_int.h\"\n#include \"block/block_int.h\"\n#include \"sysemu/block-backend.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qemu/coroutine.h\"\n#include \"qemu/id.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/timer.h\"\n#include \"qapi-event.h\"\n\nstatic void block_job_event_cancelled(BlockJob *job);\nstatic void block_job_event_completed(BlockJob *job, const char *msg);\n\n/* Transactional group of block jobs */\nstruct BlockJobTxn {\n\n    /* Is this txn being cancelled? */\n    bool aborting;\n\n    /* List of jobs */\n    QLIST_HEAD(, BlockJob) jobs;\n\n    /* Reference count */\n    int refcnt;\n};\n\nstatic QLIST_HEAD(, BlockJob) block_jobs = QLIST_HEAD_INITIALIZER(block_jobs);\n\nstatic char *child_job_get_parent_desc(BdrvChild *c)\n{\n    BlockJob *job = c->opaque;\n    return g_strdup_printf(\"%s job '%s'\",\n                           BlockJobType_lookup[job->driver->job_type],\n                           job->id);\n}\n\nstatic const BdrvChildRole child_job = {\n    .get_parent_desc    = child_job_get_parent_desc,\n    .stay_at_node       = true,\n};\n\nstatic void block_job_drained_begin(void *opaque)\n{\n    BlockJob *job = opaque;\n    block_job_pause(job);\n}\n\nstatic void block_job_drained_end(void *opaque)\n{\n    BlockJob *job = opaque;\n    block_job_resume(job);\n}\n\nstatic const BlockDevOps block_job_dev_ops = {\n    .drained_begin = block_job_drained_begin,\n    .drained_end = block_job_drained_end,\n};\n\nBlockJob *block_job_next(BlockJob *job)\n{\n    if (!job) {\n        return QLIST_FIRST(&block_jobs);\n    }\n    return QLIST_NEXT(job, job_list);\n}\n\nBlockJob *block_job_get(const char *id)\n{\n    BlockJob *job;\n\n    QLIST_FOREACH(job, &block_jobs, job_list) {\n        if (job->id && !strcmp(id, job->id)) {\n            return job;\n        }\n    }\n\n    return NULL;\n}\n\nstatic void block_job_attached_aio_context(AioContext *new_context,\n                                           void *opaque)\n{\n    BlockJob *job = opaque;\n\n    if (job->driver->attached_aio_context) {\n        job->driver->attached_aio_context(job, new_context);\n    }\n\n    block_job_resume(job);\n}\n\nstatic void block_job_drain(BlockJob *job)\n{\n    /* If job is !job->busy this kicks it into the next pause point. */\n    block_job_enter(job);\n\n    blk_drain(job->blk);\n    if (job->driver->drain) {\n        job->driver->drain(job);\n    }\n}\n\nstatic void block_job_detach_aio_context(void *opaque)\n{\n    BlockJob *job = opaque;\n\n    /* In case the job terminates during aio_poll()... */\n    block_job_ref(job);\n\n    block_job_pause(job);\n\n    while (!job->paused && !job->completed) {\n        block_job_drain(job);\n    }\n\n    block_job_unref(job);\n}\n\nvoid block_job_remove_all_bdrv(BlockJob *job)\n{\n    GSList *l;\n    for (l = job->nodes; l; l = l->next) {\n        BdrvChild *c = l->data;\n        bdrv_op_unblock_all(c->bs, job->blocker);\n        bdrv_root_unref_child(c);\n    }\n    g_slist_free(job->nodes);\n    job->nodes = NULL;\n}\n\nint block_job_add_bdrv(BlockJob *job, const char *name, BlockDriverState *bs,\n                       uint64_t perm, uint64_t shared_perm, Error **errp)\n{\n    BdrvChild *c;\n\n    c = bdrv_root_attach_child(bs, name, &child_job, perm, shared_perm,\n                               job, errp);\n    if (c == NULL) {\n        return -EPERM;\n    }\n\n    job->nodes = g_slist_prepend(job->nodes, c);\n    bdrv_ref(bs);\n    bdrv_op_block_all(bs, job->blocker);\n\n    return 0;\n}\n\nvoid *block_job_create(const char *job_id, const BlockJobDriver *driver,\n                       BlockDriverState *bs, uint64_t perm,\n                       uint64_t shared_perm, int64_t speed, int flags,\n                       BlockCompletionFunc *cb, void *opaque, Error **errp)\n{\n    BlockBackend *blk;\n    BlockJob *job;\n    int ret;\n\n    if (bs->job) {\n        error_setg(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));\n        return NULL;\n    }\n\n    if (job_id == NULL && !(flags & BLOCK_JOB_INTERNAL)) {\n        job_id = bdrv_get_device_name(bs);\n        if (!*job_id) {\n            error_setg(errp, \"An explicit job ID is required for this node\");\n            return NULL;\n        }\n    }\n\n    if (job_id) {\n        if (flags & BLOCK_JOB_INTERNAL) {\n            error_setg(errp, \"Cannot specify job ID for internal block job\");\n            return NULL;\n        }\n\n        if (!id_wellformed(job_id)) {\n            error_setg(errp, \"Invalid job ID '%s'\", job_id);\n            return NULL;\n        }\n\n        if (block_job_get(job_id)) {\n            error_setg(errp, \"Job ID '%s' already in use\", job_id);\n            return NULL;\n        }\n    }\n\n    blk = blk_new(perm, shared_perm);\n    ret = blk_insert_bs(blk, bs, errp);\n    if (ret < 0) {\n        blk_unref(blk);\n        return NULL;\n    }\n\n    job = g_malloc0(driver->instance_size);\n    job->driver        = driver;\n    job->id            = g_strdup(job_id);\n    job->blk           = blk;\n    job->cb            = cb;\n    job->opaque        = opaque;\n    job->busy          = false;\n    job->paused        = true;\n    job->pause_count   = 1;\n    job->refcnt        = 1;\n\n    error_setg(&job->blocker, \"block device is in use by block job: %s\",\n               BlockJobType_lookup[driver->job_type]);\n    block_job_add_bdrv(job, \"main node\", bs, 0, BLK_PERM_ALL, &error_abort);\n    bs->job = job;\n\n    blk_set_dev_ops(blk, &block_job_dev_ops, job);\n    bdrv_op_unblock(bs, BLOCK_OP_TYPE_DATAPLANE, job->blocker);\n\n    QLIST_INSERT_HEAD(&block_jobs, job, job_list);\n\n    blk_add_aio_context_notifier(blk, block_job_attached_aio_context,\n                                 block_job_detach_aio_context, job);\n\n    /* Only set speed when necessary to avoid NotSupported error */\n    if (speed != 0) {\n        Error *local_err = NULL;\n\n        block_job_set_speed(job, speed, &local_err);\n        if (local_err) {\n            block_job_unref(job);\n            error_propagate(errp, local_err);\n            return NULL;\n        }\n    }\n    return job;\n}\n\nbool block_job_is_internal(BlockJob *job)\n{\n    return (job->id == NULL);\n}\n\nstatic bool block_job_started(BlockJob *job)\n{\n    return job->co;\n}\n\n/**\n * All jobs must allow a pause point before entering their job proper. This\n * ensures that jobs can be paused prior to being started, then resumed later.\n */\nstatic void coroutine_fn block_job_co_entry(void *opaque)\n{\n    BlockJob *job = opaque;\n\n    assert(job && job->driver && job->driver->start);\n    block_job_pause_point(job);\n    job->driver->start(job);\n}\n\nvoid block_job_start(BlockJob *job)\n{\n    assert(job && !block_job_started(job) && job->paused &&\n           job->driver && job->driver->start);\n    job->co = qemu_coroutine_create(block_job_co_entry, job);\n    job->pause_count--;\n    job->busy = true;\n    job->paused = false;\n    bdrv_coroutine_enter(blk_bs(job->blk), job->co);\n}\n\nvoid block_job_ref(BlockJob *job)\n{\n    ++job->refcnt;\n}\n\nvoid block_job_unref(BlockJob *job)\n{\n    if (--job->refcnt == 0) {\n        BlockDriverState *bs = blk_bs(job->blk);\n        bs->job = NULL;\n        block_job_remove_all_bdrv(job);\n        blk_remove_aio_context_notifier(job->blk,\n                                        block_job_attached_aio_context,\n                                        block_job_detach_aio_context, job);\n        blk_unref(job->blk);\n        error_free(job->blocker);\n        g_free(job->id);\n        QLIST_REMOVE(job, job_list);\n        g_free(job);\n    }\n}\n\nstatic void block_job_completed_single(BlockJob *job)\n{\n    if (!job->ret) {\n        if (job->driver->commit) {\n            job->driver->commit(job);\n        }\n    } else {\n        if (job->driver->abort) {\n            job->driver->abort(job);\n        }\n    }\n    if (job->driver->clean) {\n        job->driver->clean(job);\n    }\n\n    if (job->cb) {\n        job->cb(job->opaque, job->ret);\n    }\n\n    /* Emit events only if we actually started */\n    if (block_job_started(job)) {\n        if (block_job_is_cancelled(job)) {\n            block_job_event_cancelled(job);\n        } else {\n            const char *msg = NULL;\n            if (job->ret < 0) {\n                msg = strerror(-job->ret);\n            }\n            block_job_event_completed(job, msg);\n        }\n    }\n\n    if (job->txn) {\n        QLIST_REMOVE(job, txn_list);\n        block_job_txn_unref(job->txn);\n    }\n    block_job_unref(job);\n}\n\nstatic void block_job_completed_txn_abort(BlockJob *job)\n{\n    AioContext *ctx;\n    BlockJobTxn *txn = job->txn;\n    BlockJob *other_job, *next;\n\n    if (txn->aborting) {\n        /*\n         * We are cancelled by another job, which will handle everything.\n         */\n        return;\n    }\n    txn->aborting = true;\n    /* We are the first failed job. Cancel other jobs. */\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n        ctx = blk_get_aio_context(other_job->blk);\n        aio_context_acquire(ctx);\n    }\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n        if (other_job == job || other_job->completed) {\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n             * them; this job, however, may or may not be cancelled, depending\n             * on the caller, so leave it. */\n            if (other_job != job) {\n                other_job->cancelled = true;\n            }\n            continue;\n        }\n        block_job_cancel_sync(other_job);\n        assert(other_job->completed);\n    }\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n        ctx = blk_get_aio_context(other_job->blk);\n        block_job_completed_single(other_job);\n        aio_context_release(ctx);\n    }\n}\n\nstatic void block_job_completed_txn_success(BlockJob *job)\n{\n    AioContext *ctx;\n    BlockJobTxn *txn = job->txn;\n    BlockJob *other_job, *next;\n    /*\n     * Successful completion, see if there are other running jobs in this\n     * txn.\n     */\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n        if (!other_job->completed) {\n            return;\n        }\n    }\n    /* We are the last completed job, commit the transaction. */\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n        ctx = blk_get_aio_context(other_job->blk);\n        aio_context_acquire(ctx);\n        assert(other_job->ret == 0);\n        block_job_completed_single(other_job);\n        aio_context_release(ctx);\n    }\n}\n\nvoid block_job_completed(BlockJob *job, int ret)\n{\n    assert(blk_bs(job->blk)->job == job);\n    assert(!job->completed);\n    job->completed = true;\n    job->ret = ret;\n    if (!job->txn) {\n        block_job_completed_single(job);\n    } else if (ret < 0 || block_job_is_cancelled(job)) {\n        block_job_completed_txn_abort(job);\n    } else {\n        block_job_completed_txn_success(job);\n    }\n}\n\nvoid block_job_set_speed(BlockJob *job, int64_t speed, Error **errp)\n{\n    Error *local_err = NULL;\n\n    if (!job->driver->set_speed) {\n        error_setg(errp, QERR_UNSUPPORTED);\n        return;\n    }\n    job->driver->set_speed(job, speed, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    job->speed = speed;\n}\n\nvoid block_job_complete(BlockJob *job, Error **errp)\n{\n    /* Should not be reachable via external interface for internal jobs */\n    assert(job->id);\n    if (job->pause_count || job->cancelled ||\n        !block_job_started(job) || !job->driver->complete) {\n        error_setg(errp, \"The active block job '%s' cannot be completed\",\n                   job->id);\n        return;\n    }\n\n    job->driver->complete(job, errp);\n}\n\nvoid block_job_pause(BlockJob *job)\n{\n    job->pause_count++;\n}\n\nvoid block_job_user_pause(BlockJob *job)\n{\n    job->user_paused = true;\n    block_job_pause(job);\n}\n\nstatic bool block_job_should_pause(BlockJob *job)\n{\n    return job->pause_count > 0;\n}\n\nbool block_job_user_paused(BlockJob *job)\n{\n    return job ? job->user_paused : 0;\n}\n\nvoid coroutine_fn block_job_pause_point(BlockJob *job)\n{\n    assert(job && block_job_started(job));\n\n    if (!block_job_should_pause(job)) {\n        return;\n    }\n    if (block_job_is_cancelled(job)) {\n        return;\n    }\n\n    if (job->driver->pause) {\n        job->driver->pause(job);\n    }\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n        job->paused = true;\n        job->busy = false;\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n        job->busy = true;\n        job->paused = false;\n    }\n\n    if (job->driver->resume) {\n        job->driver->resume(job);\n    }\n}\n\nvoid block_job_resume(BlockJob *job)\n{\n    assert(job->pause_count > 0);\n    job->pause_count--;\n    if (job->pause_count) {\n        return;\n    }\n    block_job_enter(job);\n}\n\nvoid block_job_user_resume(BlockJob *job)\n{\n    if (job && job->user_paused && job->pause_count > 0) {\n        job->user_paused = false;\n        block_job_resume(job);\n    }\n}\n\nvoid block_job_enter(BlockJob *job)\n{\n    if (job->co && !job->busy) {\n        bdrv_coroutine_enter(blk_bs(job->blk), job->co);\n    }\n}\n\nvoid block_job_cancel(BlockJob *job)\n{\n    if (block_job_started(job)) {\n        job->cancelled = true;\n        block_job_iostatus_reset(job);\n        block_job_enter(job);\n    } else {\n        block_job_completed(job, -ECANCELED);\n    }\n}\n\nbool block_job_is_cancelled(BlockJob *job)\n{\n    return job->cancelled;\n}\n\nvoid block_job_iostatus_reset(BlockJob *job)\n{\n    job->iostatus = BLOCK_DEVICE_IO_STATUS_OK;\n    if (job->driver->iostatus_reset) {\n        job->driver->iostatus_reset(job);\n    }\n}\n\nstatic int block_job_finish_sync(BlockJob *job,\n                                 void (*finish)(BlockJob *, Error **errp),\n                                 Error **errp)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    assert(blk_bs(job->blk)->job == job);\n\n    block_job_ref(job);\n\n    finish(job, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        block_job_unref(job);\n        return -EBUSY;\n    }\n    /* block_job_drain calls block_job_enter, and it should be enough to\n     * induce progress until the job completes or moves to the main thread.\n    */\n    while (!job->deferred_to_main_loop && !job->completed) {\n        block_job_drain(job);\n    }\n    while (!job->completed) {\n        aio_poll(qemu_get_aio_context(), true);\n    }\n    ret = (job->cancelled && job->ret == 0) ? -ECANCELED : job->ret;\n    block_job_unref(job);\n    return ret;\n}\n\n/* A wrapper around block_job_cancel() taking an Error ** parameter so it may be\n * used with block_job_finish_sync() without the need for (rather nasty)\n * function pointer casts there. */\nstatic void block_job_cancel_err(BlockJob *job, Error **errp)\n{\n    block_job_cancel(job);\n}\n\nint block_job_cancel_sync(BlockJob *job)\n{\n    return block_job_finish_sync(job, &block_job_cancel_err, NULL);\n}\n\nvoid block_job_cancel_sync_all(void)\n{\n    BlockJob *job;\n    AioContext *aio_context;\n\n    while ((job = QLIST_FIRST(&block_jobs))) {\n        aio_context = blk_get_aio_context(job->blk);\n        aio_context_acquire(aio_context);\n        block_job_cancel_sync(job);\n        aio_context_release(aio_context);\n    }\n}\n\nint block_job_complete_sync(BlockJob *job, Error **errp)\n{\n    return block_job_finish_sync(job, &block_job_complete, errp);\n}\n\nvoid block_job_sleep_ns(BlockJob *job, QEMUClockType type, int64_t ns)\n{\n    assert(job->busy);\n\n    /* Check cancellation *before* setting busy = false, too!  */\n    if (block_job_is_cancelled(job)) {\n        return;\n    }\n\n    job->busy = false;\n    if (!block_job_should_pause(job)) {\n        co_aio_sleep_ns(blk_get_aio_context(job->blk), type, ns);\n    }\n    job->busy = true;\n\n    block_job_pause_point(job);\n}\n\nvoid block_job_yield(BlockJob *job)\n{\n    assert(job->busy);\n\n    /* Check cancellation *before* setting busy = false, too!  */\n    if (block_job_is_cancelled(job)) {\n        return;\n    }\n\n    job->busy = false;\n    if (!block_job_should_pause(job)) {\n        qemu_coroutine_yield();\n    }\n    job->busy = true;\n\n    block_job_pause_point(job);\n}\n\nBlockJobInfo *block_job_query(BlockJob *job, Error **errp)\n{\n    BlockJobInfo *info;\n\n    if (block_job_is_internal(job)) {\n        error_setg(errp, \"Cannot query QEMU internal jobs\");\n        return NULL;\n    }\n    info = g_new0(BlockJobInfo, 1);\n    info->type      = g_strdup(BlockJobType_lookup[job->driver->job_type]);\n    info->device    = g_strdup(job->id);\n    info->len       = job->len;\n    info->busy      = job->busy;\n    info->paused    = job->pause_count > 0;\n    info->offset    = job->offset;\n    info->speed     = job->speed;\n    info->io_status = job->iostatus;\n    info->ready     = job->ready;\n    return info;\n}\n\nstatic void block_job_iostatus_set_err(BlockJob *job, int error)\n{\n    if (job->iostatus == BLOCK_DEVICE_IO_STATUS_OK) {\n        job->iostatus = error == ENOSPC ? BLOCK_DEVICE_IO_STATUS_NOSPACE :\n                                          BLOCK_DEVICE_IO_STATUS_FAILED;\n    }\n}\n\nstatic void block_job_event_cancelled(BlockJob *job)\n{\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    qapi_event_send_block_job_cancelled(job->driver->job_type,\n                                        job->id,\n                                        job->len,\n                                        job->offset,\n                                        job->speed,\n                                        &error_abort);\n}\n\nstatic void block_job_event_completed(BlockJob *job, const char *msg)\n{\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    qapi_event_send_block_job_completed(job->driver->job_type,\n                                        job->id,\n                                        job->len,\n                                        job->offset,\n                                        job->speed,\n                                        !!msg,\n                                        msg,\n                                        &error_abort);\n}\n\nvoid block_job_event_ready(BlockJob *job)\n{\n    job->ready = true;\n\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    qapi_event_send_block_job_ready(job->driver->job_type,\n                                    job->id,\n                                    job->len,\n                                    job->offset,\n                                    job->speed, &error_abort);\n}\n\nBlockErrorAction block_job_error_action(BlockJob *job, BlockdevOnError on_err,\n                                        int is_read, int error)\n{\n    BlockErrorAction action;\n\n    switch (on_err) {\n    case BLOCKDEV_ON_ERROR_ENOSPC:\n    case BLOCKDEV_ON_ERROR_AUTO:\n        action = (error == ENOSPC) ?\n                 BLOCK_ERROR_ACTION_STOP : BLOCK_ERROR_ACTION_REPORT;\n        break;\n    case BLOCKDEV_ON_ERROR_STOP:\n        action = BLOCK_ERROR_ACTION_STOP;\n        break;\n    case BLOCKDEV_ON_ERROR_REPORT:\n        action = BLOCK_ERROR_ACTION_REPORT;\n        break;\n    case BLOCKDEV_ON_ERROR_IGNORE:\n        action = BLOCK_ERROR_ACTION_IGNORE;\n        break;\n    default:\n        abort();\n    }\n    if (!block_job_is_internal(job)) {\n        qapi_event_send_block_job_error(job->id,\n                                        is_read ? IO_OPERATION_TYPE_READ :\n                                        IO_OPERATION_TYPE_WRITE,\n                                        action, &error_abort);\n    }\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n        /* make the pause user visible, which will be resumed from QMP. */\n        block_job_user_pause(job);\n        block_job_iostatus_set_err(job, error);\n    }\n    return action;\n}\n\ntypedef struct {\n    BlockJob *job;\n    AioContext *aio_context;\n    BlockJobDeferToMainLoopFn *fn;\n    void *opaque;\n} BlockJobDeferToMainLoopData;\n\nstatic void block_job_defer_to_main_loop_bh(void *opaque)\n{\n    BlockJobDeferToMainLoopData *data = opaque;\n    AioContext *aio_context;\n\n    /* Prevent race with block_job_defer_to_main_loop() */\n    aio_context_acquire(data->aio_context);\n\n    /* Fetch BDS AioContext again, in case it has changed */\n    aio_context = blk_get_aio_context(data->job->blk);\n    if (aio_context != data->aio_context) {\n        aio_context_acquire(aio_context);\n    }\n\n    data->job->deferred_to_main_loop = false;\n    data->fn(data->job, data->opaque);\n\n    if (aio_context != data->aio_context) {\n        aio_context_release(aio_context);\n    }\n\n    aio_context_release(data->aio_context);\n\n    g_free(data);\n}\n\nvoid block_job_defer_to_main_loop(BlockJob *job,\n                                  BlockJobDeferToMainLoopFn *fn,\n                                  void *opaque)\n{\n    BlockJobDeferToMainLoopData *data = g_malloc(sizeof(*data));\n    data->job = job;\n    data->aio_context = blk_get_aio_context(job->blk);\n    data->fn = fn;\n    data->opaque = opaque;\n    job->deferred_to_main_loop = true;\n\n    aio_bh_schedule_oneshot(qemu_get_aio_context(),\n                            block_job_defer_to_main_loop_bh, data);\n}\n\nBlockJobTxn *block_job_txn_new(void)\n{\n    BlockJobTxn *txn = g_new0(BlockJobTxn, 1);\n    QLIST_INIT(&txn->jobs);\n    txn->refcnt = 1;\n    return txn;\n}\n\nstatic void block_job_txn_ref(BlockJobTxn *txn)\n{\n    txn->refcnt++;\n}\n\nvoid block_job_txn_unref(BlockJobTxn *txn)\n{\n    if (txn && --txn->refcnt == 0) {\n        g_free(txn);\n    }\n}\n\nvoid block_job_txn_add_job(BlockJobTxn *txn, BlockJob *job)\n{\n    if (!txn) {\n        return;\n    }\n\n    assert(!job->txn);\n    job->txn = txn;\n\n    QLIST_INSERT_HEAD(&txn->jobs, job, txn_list);\n    block_job_txn_ref(txn);\n}\n"
        },
        {
          "name": "bootdevice.c",
          "type": "blob",
          "size": 9.2080078125,
          "content": "/*\n * QEMU Boot Device Implement\n *\n * Copyright (c) 2014 HUAWEI TECHNOLOGIES CO., LTD.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qapi/visitor.h\"\n#include \"qemu/error-report.h\"\n#include \"hw/hw.h\"\n#include \"hw/qdev-core.h\"\n\ntypedef struct FWBootEntry FWBootEntry;\n\nstruct FWBootEntry {\n    QTAILQ_ENTRY(FWBootEntry) link;\n    int32_t bootindex;\n    DeviceState *dev;\n    char *suffix;\n};\n\nstatic QTAILQ_HEAD(, FWBootEntry) fw_boot_order =\n    QTAILQ_HEAD_INITIALIZER(fw_boot_order);\nstatic QEMUBootSetHandler *boot_set_handler;\nstatic void *boot_set_opaque;\n\nvoid qemu_register_boot_set(QEMUBootSetHandler *func, void *opaque)\n{\n    boot_set_handler = func;\n    boot_set_opaque = opaque;\n}\n\nvoid qemu_boot_set(const char *boot_order, Error **errp)\n{\n    Error *local_err = NULL;\n\n    if (!boot_set_handler) {\n        error_setg(errp, \"no function defined to set boot device list for\"\n                         \" this architecture\");\n        return;\n    }\n\n    validate_bootdevices(boot_order, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    boot_set_handler(boot_set_opaque, boot_order, errp);\n}\n\nvoid validate_bootdevices(const char *devices, Error **errp)\n{\n    /* We just do some generic consistency checks */\n    const char *p;\n    int bitmap = 0;\n\n    for (p = devices; *p != '\\0'; p++) {\n        /* Allowed boot devices are:\n         * a-b: floppy disk drives\n         * c-f: IDE disk drives\n         * g-m: machine implementation dependent drives\n         * n-p: network devices\n         * It's up to each machine implementation to check if the given boot\n         * devices match the actual hardware implementation and firmware\n         * features.\n         */\n        if (*p < 'a' || *p > 'p') {\n            error_setg(errp, \"Invalid boot device '%c'\", *p);\n            return;\n        }\n        if (bitmap & (1 << (*p - 'a'))) {\n            error_setg(errp, \"Boot device '%c' was given twice\", *p);\n            return;\n        }\n        bitmap |= 1 << (*p - 'a');\n    }\n}\n\nvoid restore_boot_order(void *opaque)\n{\n    char *normal_boot_order = opaque;\n    static int first = 1;\n\n    /* Restore boot order and remove ourselves after the first boot */\n    if (first) {\n        first = 0;\n        return;\n    }\n\n    if (boot_set_handler) {\n        qemu_boot_set(normal_boot_order, &error_abort);\n    }\n\n    qemu_unregister_reset(restore_boot_order, normal_boot_order);\n    g_free(normal_boot_order);\n}\n\nvoid check_boot_index(int32_t bootindex, Error **errp)\n{\n    FWBootEntry *i;\n\n    if (bootindex >= 0) {\n        QTAILQ_FOREACH(i, &fw_boot_order, link) {\n            if (i->bootindex == bootindex) {\n                error_setg(errp, \"The bootindex %d has already been used\",\n                           bootindex);\n                return;\n            }\n        }\n    }\n}\n\nvoid del_boot_device_path(DeviceState *dev, const char *suffix)\n{\n    FWBootEntry *i;\n\n    if (dev == NULL) {\n        return;\n    }\n\n    QTAILQ_FOREACH(i, &fw_boot_order, link) {\n        if ((!suffix || !g_strcmp0(i->suffix, suffix)) &&\n             i->dev == dev) {\n            QTAILQ_REMOVE(&fw_boot_order, i, link);\n            g_free(i->suffix);\n            g_free(i);\n\n            break;\n        }\n    }\n}\n\nvoid add_boot_device_path(int32_t bootindex, DeviceState *dev,\n                          const char *suffix)\n{\n    FWBootEntry *node, *i;\n\n    if (bootindex < 0) {\n        del_boot_device_path(dev, suffix);\n        return;\n    }\n\n    assert(dev != NULL || suffix != NULL);\n\n    del_boot_device_path(dev, suffix);\n\n    node = g_malloc0(sizeof(FWBootEntry));\n    node->bootindex = bootindex;\n    node->suffix = g_strdup(suffix);\n    node->dev = dev;\n\n    QTAILQ_FOREACH(i, &fw_boot_order, link) {\n        if (i->bootindex == bootindex) {\n            error_report(\"Two devices with same boot index %d\", bootindex);\n            exit(1);\n        } else if (i->bootindex < bootindex) {\n            continue;\n        }\n        QTAILQ_INSERT_BEFORE(i, node, link);\n        return;\n    }\n    QTAILQ_INSERT_TAIL(&fw_boot_order, node, link);\n}\n\nDeviceState *get_boot_device(uint32_t position)\n{\n    uint32_t counter = 0;\n    FWBootEntry *i = NULL;\n    DeviceState *res = NULL;\n\n    if (!QTAILQ_EMPTY(&fw_boot_order)) {\n        QTAILQ_FOREACH(i, &fw_boot_order, link) {\n            if (counter == position) {\n                res = i->dev;\n                break;\n            }\n            counter++;\n        }\n    }\n    return res;\n}\n\n/*\n * This function returns null terminated string that consist of new line\n * separated device paths.\n *\n * memory pointed by \"size\" is assigned total length of the array in bytes\n *\n */\nchar *get_boot_devices_list(size_t *size, bool ignore_suffixes)\n{\n    FWBootEntry *i;\n    size_t total = 0;\n    char *list = NULL;\n\n    QTAILQ_FOREACH(i, &fw_boot_order, link) {\n        char *devpath = NULL,  *suffix = NULL;\n        char *bootpath;\n        char *d;\n        size_t len;\n\n        if (i->dev) {\n            devpath = qdev_get_fw_dev_path(i->dev);\n            assert(devpath);\n        }\n\n        if (!ignore_suffixes) {\n            if (i->dev) {\n                d = qdev_get_own_fw_dev_path_from_handler(i->dev->parent_bus,\n                                                          i->dev);\n                if (d) {\n                    assert(!i->suffix);\n                    suffix = d;\n                } else {\n                    suffix = g_strdup(i->suffix);\n                }\n            } else {\n                suffix = g_strdup(i->suffix);\n            }\n        }\n\n        bootpath = g_strdup_printf(\"%s%s\",\n                                   devpath ? devpath : \"\",\n                                   suffix ? suffix : \"\");\n        g_free(devpath);\n        g_free(suffix);\n\n        if (total) {\n            list[total-1] = '\\n';\n        }\n        len = strlen(bootpath) + 1;\n        list = g_realloc(list, total + len);\n        memcpy(&list[total], bootpath, len);\n        total += len;\n        g_free(bootpath);\n    }\n\n    *size = total;\n\n    if (boot_strict && *size > 0) {\n        list[total-1] = '\\n';\n        list = g_realloc(list, total + 5);\n        memcpy(&list[total], \"HALT\", 5);\n        *size = total + 5;\n    }\n    return list;\n}\n\ntypedef struct {\n    int32_t *bootindex;\n    const char *suffix;\n    DeviceState *dev;\n} BootIndexProperty;\n\nstatic void device_get_bootindex(Object *obj, Visitor *v, const char *name,\n                                 void *opaque, Error **errp)\n{\n    BootIndexProperty *prop = opaque;\n    visit_type_int32(v, name, prop->bootindex, errp);\n}\n\nstatic void device_set_bootindex(Object *obj, Visitor *v, const char *name,\n                                 void *opaque, Error **errp)\n{\n    BootIndexProperty *prop = opaque;\n    int32_t boot_index;\n    Error *local_err = NULL;\n\n    visit_type_int32(v, name, &boot_index, &local_err);\n    if (local_err) {\n        goto out;\n    }\n    /* check whether bootindex is present in fw_boot_order list  */\n    check_boot_index(boot_index, &local_err);\n    if (local_err) {\n        goto out;\n    }\n    /* change bootindex to a new one */\n    *prop->bootindex = boot_index;\n\n    add_boot_device_path(*prop->bootindex, prop->dev, prop->suffix);\n\nout:\n    error_propagate(errp, local_err);\n}\n\nstatic void property_release_bootindex(Object *obj, const char *name,\n                                       void *opaque)\n\n{\n    BootIndexProperty *prop = opaque;\n\n    del_boot_device_path(prop->dev, prop->suffix);\n    g_free(prop);\n}\n\nvoid device_add_bootindex_property(Object *obj, int32_t *bootindex,\n                                   const char *name, const char *suffix,\n                                   DeviceState *dev, Error **errp)\n{\n    Error *local_err = NULL;\n    BootIndexProperty *prop = g_malloc0(sizeof(*prop));\n\n    prop->bootindex = bootindex;\n    prop->suffix = suffix;\n    prop->dev = dev;\n\n    object_property_add(obj, name, \"int32\",\n                        device_get_bootindex,\n                        device_set_bootindex,\n                        property_release_bootindex,\n                        prop, &local_err);\n\n    if (local_err) {\n        error_propagate(errp, local_err);\n        g_free(prop);\n        return;\n    }\n    /* initialize devices' bootindex property to -1 */\n    object_property_set_int(obj, -1, name, NULL);\n}\n"
        },
        {
          "name": "bsd-user",
          "type": "tree",
          "content": null
        },
        {
          "name": "bt-host.c",
          "type": "blob",
          "size": 5.17578125,
          "content": "/*\n * Wrap a host Bluetooth HCI socket in a struct HCIInfo.\n *\n * Copyright (C) 2008 Andrzej Zaborowski  <balrog@zabor.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 or\n * (at your option) version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"sysemu/bt.h\"\n#include \"qemu/main-loop.h\"\n\n#ifndef _WIN32\n# include <sys/ioctl.h>\n# include <sys/uio.h>\n# ifdef CONFIG_BLUEZ\n#  include <bluetooth/bluetooth.h>\n#  include <bluetooth/hci.h>\n#  include <bluetooth/hci_lib.h>\n# else\n#  include \"hw/bt.h\"\n#  define HCI_MAX_FRAME_SIZE\t1028\n# endif\n\nstruct bt_host_hci_s {\n    struct HCIInfo hci;\n    int fd;\n\n    uint8_t hdr[HCI_MAX_FRAME_SIZE];\n    int len;\n};\n\nstatic void bt_host_send(struct HCIInfo *hci,\n                int type, const uint8_t *data, int len)\n{\n    struct bt_host_hci_s *s = (struct bt_host_hci_s *) hci;\n    uint8_t pkt = type;\n    struct iovec iv[2];\n\n    iv[0].iov_base = (void *)&pkt;\n    iv[0].iov_len  = 1;\n    iv[1].iov_base = (void *) data;\n    iv[1].iov_len  = len;\n\n    while (writev(s->fd, iv, 2) < 0) {\n        if (errno != EAGAIN && errno != EINTR) {\n            fprintf(stderr, \"qemu: error %i writing bluetooth packet.\\n\",\n                            errno);\n            return;\n        }\n    }\n}\n\nstatic void bt_host_cmd(struct HCIInfo *hci, const uint8_t *data, int len)\n{\n    bt_host_send(hci, HCI_COMMAND_PKT, data, len);\n}\n\nstatic void bt_host_acl(struct HCIInfo *hci, const uint8_t *data, int len)\n{\n    bt_host_send(hci, HCI_ACLDATA_PKT, data, len);\n}\n\nstatic void bt_host_sco(struct HCIInfo *hci, const uint8_t *data, int len)\n{\n    bt_host_send(hci, HCI_SCODATA_PKT, data, len);\n}\n\nstatic void bt_host_read(void *opaque)\n{\n    struct bt_host_hci_s *s = (struct bt_host_hci_s *) opaque;\n    uint8_t *pkt;\n    int pktlen;\n\n    /* Seems that we can't read only the header first and then the amount\n     * of data indicated in the header because Linux will discard everything\n     * that's not been read in one go.  */\n    s->len = read(s->fd, s->hdr, sizeof(s->hdr));\n\n    if (s->len < 0) {\n        fprintf(stderr, \"qemu: error %i reading HCI frame\\n\", errno);\n        return;\n    }\n\n    pkt = s->hdr;\n    while (s->len --)\n        switch (*pkt ++) {\n        case HCI_EVENT_PKT:\n            if (s->len < 2)\n                goto bad_pkt;\n\n            pktlen = MIN(pkt[1] + 2, s->len);\n            s->hci.evt_recv(s->hci.opaque, pkt, pktlen);\n            s->len -= pktlen;\n            pkt += pktlen;\n\n            /* TODO: if this is an Inquiry Result event, it's also\n             * interpreted by Linux kernel before we received it, possibly\n             * we should clean the kernel Inquiry cache through\n             * ioctl(s->fd, HCI_INQUIRY, ...).  */\n            break;\n\n        case HCI_ACLDATA_PKT:\n            if (s->len < 4)\n                goto bad_pkt;\n\n            pktlen = MIN(((pkt[3] << 8) | pkt[2]) + 4, s->len);\n            s->hci.acl_recv(s->hci.opaque, pkt, pktlen);\n            s->len -= pktlen;\n            pkt += pktlen;\n            break;\n\n        case HCI_SCODATA_PKT:\n            if (s->len < 3)\n                goto bad_pkt;\n\n            pktlen = MIN(pkt[2] + 3, s->len);\n            s->len -= pktlen;\n            pkt += pktlen;\n            break;\n\n        default:\n        bad_pkt:\n            fprintf(stderr, \"qemu: bad HCI packet type %02x\\n\", pkt[-1]);\n        }\n}\n\nstatic int bt_host_bdaddr_set(struct HCIInfo *hci, const uint8_t *bd_addr)\n{\n    return -ENOTSUP;\n}\n\nstruct HCIInfo *bt_host_hci(const char *id)\n{\n    struct bt_host_hci_s *s;\n    int fd = -1;\n# ifdef CONFIG_BLUEZ\n    int dev_id = hci_devid(id);\n    struct hci_filter flt;\n\n    if (dev_id < 0) {\n        fprintf(stderr, \"qemu: `%s' not available\\n\", id);\n        return 0;\n    }\n\n    fd = hci_open_dev(dev_id);\n\n    /* XXX: can we ensure nobody else has the device opened?  */\n# endif\n\n    if (fd < 0) {\n        fprintf(stderr, \"qemu: Can't open `%s': %s (%i)\\n\",\n                        id, strerror(errno), errno);\n        return NULL;\n    }\n\n# ifdef CONFIG_BLUEZ\n    hci_filter_clear(&flt);\n    hci_filter_all_ptypes(&flt);\n    hci_filter_all_events(&flt);\n\n    if (qemu_setsockopt(fd, SOL_HCI, HCI_FILTER, &flt, sizeof(flt)) < 0) {\n        fprintf(stderr, \"qemu: Can't set HCI filter on socket (%i)\\n\", errno);\n        return 0;\n    }\n# endif\n\n    s = g_malloc0(sizeof(struct bt_host_hci_s));\n    s->fd = fd;\n    s->hci.cmd_send = bt_host_cmd;\n    s->hci.sco_send = bt_host_sco;\n    s->hci.acl_send = bt_host_acl;\n    s->hci.bdaddr_set = bt_host_bdaddr_set;\n\n    qemu_set_fd_handler(s->fd, bt_host_read, NULL, s);\n\n    return &s->hci;\n}\n#else\nstruct HCIInfo *bt_host_hci(const char *id)\n{\n    fprintf(stderr, \"qemu: bluetooth passthrough not supported (yet)\\n\");\n\n    return 0;\n}\n#endif\n"
        },
        {
          "name": "bt-vhci.c",
          "type": "blob",
          "size": 4.4921875,
          "content": "/*\n * Support for host VHCIs inside qemu scatternets.\n *\n * Copyright (C) 2008 Andrzej Zaborowski  <balrog@zabor.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 or\n * (at your option) version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"sysemu/bt.h\"\n#include \"hw/bt.h\"\n#include \"qemu/main-loop.h\"\n\n#define VHCI_DEV\t\"/dev/vhci\"\n#define VHCI_UDEV\t\"/dev/hci_vhci\"\n\nstruct bt_vhci_s {\n    int fd;\n    struct HCIInfo *info;\n\n    uint8_t hdr[4096];\n    int len;\n};\n\nstatic void vhci_read(void *opaque)\n{\n    struct bt_vhci_s *s = (struct bt_vhci_s *) opaque;\n    uint8_t *pkt;\n    int pktlen;\n\n    /* Seems that we can't read only the header first and then the amount\n     * of data indicated in the header because Linux will discard everything\n     * that's not been read in one go.  */\n    s->len = read(s->fd, s->hdr, sizeof(s->hdr));\n\n    if (s->len < 0) {\n        fprintf(stderr, \"qemu: error %i reading the PDU\\n\", errno);\n        return;\n    }\n\n    pkt = s->hdr;\n    while (s->len --)\n        switch (*pkt ++) {\n        case HCI_COMMAND_PKT:\n            if (s->len < 3)\n                goto bad_pkt;\n\n            pktlen = MIN(pkt[2] + 3, s->len);\n            s->info->cmd_send(s->info, pkt, pktlen);\n            s->len -= pktlen;\n            pkt += pktlen;\n            break;\n\n        case HCI_ACLDATA_PKT:\n            if (s->len < 4)\n                goto bad_pkt;\n\n            pktlen = MIN(((pkt[3] << 8) | pkt[2]) + 4, s->len);\n            s->info->acl_send(s->info, pkt, pktlen);\n            s->len -= pktlen;\n            pkt += pktlen;\n            break;\n\n        case HCI_SCODATA_PKT:\n            if (s->len < 3)\n                goto bad_pkt;\n\n            pktlen = MIN(pkt[2] + 3, s->len);\n            s->info->sco_send(s->info, pkt, pktlen);\n            s->len -= pktlen;\n            pkt += pktlen;\n            break;\n\n        default:\n        bad_pkt:\n            fprintf(stderr, \"qemu: bad HCI packet type %02x\\n\", pkt[-1]);\n        }\n}\n\nstatic void vhci_host_send(void *opaque,\n                int type, const uint8_t *data, int len)\n{\n    struct bt_vhci_s *s = (struct bt_vhci_s *) opaque;\n#if 0\n    uint8_t pkt = type;\n    struct iovec iv[2];\n\n    iv[0].iov_base = &pkt;\n    iv[0].iov_len  = 1;\n    iv[1].iov_base = (void *) data;\n    iv[1].iov_len  = len;\n\n    while (writev(s->fd, iv, 2) < 0)\n        if (errno != EAGAIN && errno != EINTR) {\n            fprintf(stderr, \"qemu: error %i writing bluetooth packet.\\n\",\n                            errno);\n            return;\n        }\n#else\n    /* Apparently VHCI wants us to write everything in one chunk :-(  */\n    static uint8_t buf[4096];\n\n    buf[0] = type;\n    memcpy(buf + 1, data, len);\n\n    while (write(s->fd, buf, len + 1) < 0)\n        if (errno != EAGAIN && errno != EINTR) {\n            fprintf(stderr, \"qemu: error %i writing bluetooth packet.\\n\",\n                            errno);\n            return;\n        }\n#endif\n}\n\nstatic void vhci_out_hci_packet_event(void *opaque,\n                const uint8_t *data, int len)\n{\n    vhci_host_send(opaque, HCI_EVENT_PKT, data, len);\n}\n\nstatic void vhci_out_hci_packet_acl(void *opaque,\n                const uint8_t *data, int len)\n{\n    vhci_host_send(opaque, HCI_ACLDATA_PKT, data, len);\n}\n\nvoid bt_vhci_init(struct HCIInfo *info)\n{\n    struct bt_vhci_s *s;\n    int err[2];\n    int fd;\n\n    fd = open(VHCI_DEV, O_RDWR);\n    err[0] = errno;\n    if (fd < 0) {\n        fd = open(VHCI_UDEV, O_RDWR);\n        err[1] = errno;\n    }\n\n    if (fd < 0) {\n        fprintf(stderr, \"qemu: Can't open `%s': %s (%i)\\n\",\n                        VHCI_DEV, strerror(err[0]), err[0]);\n        fprintf(stderr, \"qemu: Can't open `%s': %s (%i)\\n\",\n                        VHCI_UDEV, strerror(err[1]), err[1]);\n        exit(-1);\n    }\n\n    s = g_malloc0(sizeof(struct bt_vhci_s));\n    s->fd = fd;\n    s->info = info ?: qemu_next_hci();\n    s->info->opaque = s;\n    s->info->evt_recv = vhci_out_hci_packet_event;\n    s->info->acl_recv = vhci_out_hci_packet_acl;\n\n    qemu_set_fd_handler(s->fd, vhci_read, NULL, s);\n}\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 5.310546875,
          "content": "#!/bin/bash\n# Usage ./build.sh [--python]  [architectures] [Configure flags...]\n# example: ./build.sh i386-softmmu,arm-softmmu\n#          ./build.sh --python i386-softmmu,arm-softmmu\n#          ./build.sh small # small = i386-softmmu\n#          LLVM_CONFIG_BINARY=llvm-config-11-64 ./build.sh small # set custom llvm-config path\n\n# Note the --python flag installs using `pip -e` which leaves files in a local\n# directory (panda/python/core) instead of installing to your system.\n# This allows you to edit those scripts, but means you can't delete the directory\n# and still use pypanda.\n\n# printf wrapper - messages sent to stderr\nmsg() {\n    local fmt=$1\n    shift\n    printf \"%s: $fmt\\n\" build.sh $* >&2\n}\n\n# Default targets to build. Change with argument. small = i386-softmmu\nTARGET_LIST=\"x86_64-softmmu,i386-softmmu,arm-softmmu,aarch64-softmmu,ppc-softmmu,mips-softmmu,mipsel-softmmu,mips64-softmmu,mips64el-softmmu\"\nLLVM_CONFIG_BINARY=\"${LLVM_CONFIG_BINARY:-llvm-config-11}\"\n\npypanda=\"\"\n# Check if first argument is --python\nif [ $# -ge 1 ]; then\n    if [ \"$1\" = \"--python\" ]; then\n        echo \"Installing PyPANDA\"\n        pypanda=\"yes\"\n        shift\n    fi\nfi\n\n# If there are more arguments, the first arg is target list or 'small'. subsequent args are passed to configure\nif [ $# -ge 1 ]; then if [ \"$1\" = \"small\" ]; then\n        TARGET_LIST=\"i386-softmmu\"\n    else\n        if [[ \"$1\" == *\"-softmmu\" ]]; then\n            TARGET_LIST=\"$1\"\n        else\n            TARGET_LIST=\"$1-softmmu\"\n        fi\n    fi\n    echo \"Building PANDA for target(s): $TARGET_LIST\"\n    shift\nfi\n\necho \"Build arguments: $@\"\n\n# Prefer greadlink over readlink if present. Important for OSX (incompatible readlink).\nif type greadlink >/dev/null 2>&1; then\n    READLINK=greadlink\nelse\n    READLINK=readlink\nfi\n\n# Set source path variables.\nPANDA_DIR_REL=\"$(dirname $0)\"\nPANDA_DIR=\"$(\"$READLINK\" -f \"${PANDA_DIR_REL}\")\"\n\n# Number of concurrent make jobs.\nPANDA_NPROC=${PANDA_NPROC:-$(nproc || sysctl -n hw.ncpu)}\n\n# stop on any error\nset -e\n\n### Check gcc/g++ versions: 7.1-9.3.0 are supported. If you want to build with clang, you might need to disable this\ngcc --version | awk '/gcc/ && ($3+0)<7.1{print \"Fatal error: GCC too old\"; exit 1}' || exit 1\ng++ --version | awk '/g\\+\\+/ && ($3+0)<7.1{print \"Fatal error: G++ too old\"; exit 1}' || exit 1\n\n# Untested GCC - it's probably going to have some warnings - Just disable Werror and hope it works\nCOMPILER_CONFIG=\"\"\ngcc --version | awk '/gcc/   && ($3+0)>11.2{print \"WARNING: Your GCC is too new: disabling -Werror and hoping this builds\"; exit 1}' || COMPILER_CONFIG+=\"--extra-cflags=-Wno-error\"\ng++ --version | awk '/g\\+\\+/ && ($3+0)>11.2{print \"WARNING: Your G++ is too new: disabling -Werror and hoping this builds\"; exit 1}' ||  COMPILER_CONFIG+=\" --extra-cxxflags=-Wno-error\"\n\n### Check for protobuf v2.\nif ! pkg-config --exists protobuf; then\n    msg \"No pkg-config for protobuf. Continuing anyway...\"\nelif pkg-config --exists protobuf \"protobuf >= 2\"; then\n    msg \"Using protobuf $(pkg-config --modversion protobuf).\"\nelse\n    msg \"Found incompatible protobuf $(pkg-config --modversion protobuf) -- ABORTING\"\n    msg \"See panda/docs/compile.md for instructions on building protobuf v2.\"\n    exit 1\nfi\n\n### Set LLVM_CONFIG to be used with the configure script.\n# No LLVM binary: Disable LLVM\nif ! command -v $LLVM_CONFIG_BINARY &> /dev/null; then\n    echo \"LLVM 11 not installed. LLVM SUPPORT IS DISABLED.\"\n    LLVM_CONFIG=\"\"\nfi\n# OSX: Disable LLVM\nif [ $(getconf LONG_BIT) = 32 ]; then\n    msg \"Running on a 32bit OS -- LLVM SUPPORT IS DISABLED\"\n    LLVM_CONFIG=\"\"\nfi\n\n## Use system LLVM-11\nif $LLVM_CONFIG_BINARY --version >/dev/null 2>/dev/null; then\n    msg \"Found LLVM on $($LLVM_CONFIG_BINARY --prefix) -- LLVM SUPPORT IS ENABLED\"\n    LLVM_CONFIG=\"--enable-llvm --with-llvm=$($LLVM_CONFIG_BINARY --prefix)\"\nelse\n    msg \"No suitable LLVM found -- LLVM SUPPORT IS DISABLED\"\n    LLVM_CONFIG=\"\"\nfi\n\n### Ensure Rust version is up to date\nif ! command -v cargo &> /dev/null\nthen\n    msg \"\"\n    msg \"\"\n    msg \"Rust could not be found. Install it using the following command:\"\n    msg \"\"\n    msg \"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\"\n    msg \"\"\n\n    exit 1\nfi\n\nRUST_VERSION=\"$(cargo --version | grep -o -E '1\\.[0-9]+' | cut -c 3-)\"\n\nif [[ \"$RUST_VERSION\" -lt \"64\" ]]; then\n    echo \"Rust version 1.$RUST_VERSION is not compatible! Updating to latest.\"\n    rustup update stable\n    rustup default stable\nfi\n\n### Force QEMU options definitions to be regenerated.\nrm -f \"${PANDA_DIR}/qemu-options.def\"\n\n### Include any local build configurations options.\nBUILD_LOCAL=\"${PANDA_DIR}/build.inc.sh\"\nif [ -f \"$BUILD_LOCAL\" ]; then\n    msg \"Including local configuration from $BUILD_LOCAL.\"\n    . \"$BUILD_LOCAL\"\nfi\n\n# will install to $(pwd)/install UNLESS $prefix is set when script is run\nif [ -z \"$prefix\" ]; then\n    # prefix=\"/usr/local\"\n    prefix=\"$(pwd)/install\"\n    echo \"Using default prefix: $prefix\"\nelse\n    echo \"Using specified prefix: $prefix\"\nfi\n\n## Configure/compile/test.\nmsg \"Configuring PANDA...\"\nset -x\n\"${PANDA_DIR_REL}/configure\" \\\n    --target-list=$TARGET_LIST \\\n    --prefix=$prefix \\\n    $COMPILER_CONFIG \\\n    $LLVM_CONFIG \\\n    \"$@\"\nset +x\n\nmsg \"Compiling PANDA...\"\nmake -j ${PANDA_NPROC}\n\nif [ -n \"$pypanda\" ]; then\n    msg \"Installing PyPANDA (developer mode)...\"\n    pip install -e ../panda/python/core\nfi\n\n# vim: set et ts=4 sts=4 sw=4 ai ft=sh :\n"
        },
        {
          "name": "chardev",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 178.5146484375,
          "content": "#!/bin/sh\n#\n# qemu configure script (c) 2003 Fabrice Bellard\n#\n\n# Unset some variables known to interfere with behavior of common tools,\n# just as autoconf does.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n# Don't allow CCACHE, if present, to use cached results of compile tests!\nexport CCACHE_RECACHE=yes\n\n# Temporary directory used for files created while\n# configure runs. Since it is in the build directory\n# we can safely blow away any previous version of it\n# (and we need not jump through hoops to try to delete\n# it when configure exits.)\nTMPDIR1=\"config-temp\"\nrm -rf \"${TMPDIR1}\"\nmkdir -p \"${TMPDIR1}\"\nif [ $? -ne 0 ]; then\n    echo \"ERROR: failed to create temporary directory\"\n    exit 1\nfi\n\nTMPB=\"qemu-conf\"\nTMPC=\"${TMPDIR1}/${TMPB}.c\"\nTMPO=\"${TMPDIR1}/${TMPB}.o\"\nTMPCXX=\"${TMPDIR1}/${TMPB}.cxx\"\nTMPE=\"${TMPDIR1}/${TMPB}.exe\"\nTMPMO=\"${TMPDIR1}/${TMPB}.mo\"\n\nrm -f config.log\n\n# Print a helpful header at the top of config.log\necho \"# QEMU configure log $(date)\" >> config.log\nprintf \"# Configured with:\" >> config.log\nprintf \" '%s'\" \"$0\" \"$@\" >> config.log\necho >> config.log\necho \"#\" >> config.log\n\nerror_exit() {\n    echo\n    echo \"ERROR: $1\"\n    while test -n \"$2\"; do\n        echo \"       $2\"\n        shift\n    done\n    echo\n    exit 1\n}\n\ndo_compiler() {\n    # Run the compiler, capturing its output to the log. First argument\n    # is compiler binary to execute.\n    local compiler=\"$1\"\n    shift\n    echo $compiler \"$@\" >> config.log\n    $compiler \"$@\" >> config.log 2>&1 || return $?\n    # Test passed. If this is an --enable-werror build, rerun\n    # the test with -Werror and bail out if it fails. This\n    # makes warning-generating-errors in configure test code\n    # obvious to developers.\n    if test \"$werror\" != \"yes\"; then\n        return 0\n    fi\n    # Don't bother rerunning the compile if we were already using -Werror\n    case \"$*\" in\n        *-Werror*)\n           return 0\n        ;;\n    esac\n    echo $compiler -Werror \"$@\" >> config.log\n    $compiler -Werror \"$@\" >> config.log 2>&1 && return $?\n    error_exit \"configure test passed without -Werror but failed with -Werror.\" \\\n        \"This is probably a bug in the configure script. The failing command\" \\\n        \"will be at the bottom of config.log.\" \\\n        \"You can run configure with --disable-werror to bypass this check.\"\n}\n\ndo_cc() {\n    do_compiler \"$cc\" \"$@\"\n}\n\ndo_cxx() {\n    do_compiler \"$cxx\" \"$@\"\n}\n\nupdate_cxxflags() {\n    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those\n    # options which some versions of GCC's C++ compiler complain about\n    # because they only make sense for C programs.\n    # -Wall is also excluded because it resets any warnings we have\n    # previously hushed. QEMU_CXXFLAGS set -Wall seperately.\n    QEMU_CXXFLAGS=\"$QEMU_CXXFLAGS -D__STDC_LIMIT_MACROS\"\n\n    for arg in $QEMU_CFLAGS; do\n        case $arg in\n            -std=*|-Wall|\\\n            -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\\\n            -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)\n                ;;\n            *)\n                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg\n                ;;\n        esac\n    done\n}\n\nupdate_clangxxflags() {\n    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those\n    # options which some versions of clang++ compiler complain about\n    # because they don't understand.\n    # -Wall is also excluded because it resets any warnings we have\n    # previously hushed. QEMU_CXXFLAGS set -Wall seperately.\n    QEMU_CXXFLAGS=\"$QEMU_CXXFLAGS -D__STDC_LIMIT_MACROS\"\n\n    for arg in $QEMU_CFLAGS; do\n        case $arg in\n            -std=*|-Wall|\\\n            -Wold-style-declaration)\n                ;;\n            *)\n                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg\n                ;;\n        esac\n    done\n\n    # Finally filter-out flags only understood by g++.\n    local QEMU_CXXFLAGSL=\"\"\n    for arg in $QEMU_CXXFLAGS; do\n        case $arg in\n            -Wno-shift-negative-value)\n                ;;\n            *)\n                QEMU_CXXFLAGSL=${QEMU_CXXFLAGSL:+$QEMU_CXXFLAGSL }$arg\n                ;;\n        esac\n    done\n    QEMU_CXXFLAGS=\"$QEMU_CXXFLAGSL\"\n}\n\nupdate_clangldflags() {\n    local LDFLAGSL=\"\"\n    for arg in $LDFLAGS; do\n        case $arg in\n            -fprofile-arcs|-ftest-coverage)\n                ;;\n            *)\n                LDFLAGSL=${LDFLAGSL:+$LDFLAGSL }$arg\n                ;;\n        esac\n    done\n    LDFLAGS=\"$LDFLAGSL\"\n}\n\ncompile_object() {\n  local_cflags=\"$1\"\n  do_cc $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC\n}\n\ncompile_prog() {\n  local_cflags=\"$1\"\n  local_ldflags=\"$2\"\n  do_cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags\n}\n\ncompile_prog_cxx() {\n  local_cxxflags=\"$1\"\n  local_ldflags=\"$2\"\n  local qemu_cxxflags_bak=\"$QEMU_CXXFLAGS\"\n  local ret=0\n\n  update_cxxflags\n  do_cxx $QEMU_CXXFLAGS $local_cxxflags -o $TMPE $TMPCXX $LDFLAGS $local_ldflags\n  ret=$?\n\n  QEMU_CXXFLAGS=\"$qemu_cxxflags_bak\"\n  return $ret\n}\n\ncompile_prog_clangxx() {\n  local_cxxflags=\"$1\"\n  local_ldflags=\"$2\"\n  local cxx_bak=\"$cxx\"\n  local qemu_cxxflags_bak=\"$QEMU_CXXFLAGS\"\n  local ldflags_bak=\"$LDFLAGS\"\n  local ret=0\n\n  update_clangxxflags\n  update_clangldflags\n  cxx=\"${clangxx:-clang++}\"\n  do_cxx $QEMU_CXXFLAGS $local_cxxflags -o $TMPE $TMPCXX $LDFLAGS $local_ldflags\n  ret=$?\n\n  cxx=\"$cxx_bak\"\n  QEMU_CXXFLAGS=\"$qemu_cxxflags_bak\"\n  LDFLAGS=\"$ldflags_bak\"\n  return $ret\n}\n\n# symbolically link $1 to $2.  Portable version of \"ln -sf\".\nsymlink() {\n  rm -rf \"$2\"\n  mkdir -p \"$(dirname \"$2\")\"\n  ln -s \"$1\" \"$2\"\n}\n\n# check whether a command is available to this shell (may be either an\n# executable or a builtin)\nhas() {\n    type \"$1\" >/dev/null 2>&1\n}\n\n# search for an executable in PATH\npath_of() {\n    local_command=\"$1\"\n    local_ifs=\"$IFS\"\n    local_dir=\"\"\n\n    # pathname has a dir component?\n    if [ \"${local_command#*/}\" != \"$local_command\" ]; then\n        if [ -x \"$local_command\" ] && [ ! -d \"$local_command\" ]; then\n            echo \"$local_command\"\n            return 0\n        fi\n    fi\n    if [ -z \"$local_command\" ]; then\n        return 1\n    fi\n\n    IFS=:\n    for local_dir in $PATH; do\n        if [ -x \"$local_dir/$local_command\" ] && [ ! -d \"$local_dir/$local_command\" ]; then\n            echo \"$local_dir/$local_command\"\n            IFS=\"${local_ifs:-$(printf ' \\t\\n')}\"\n            return 0\n        fi\n    done\n    # not found\n    IFS=\"${local_ifs:-$(printf ' \\t\\n')}\"\n    return 1\n}\n\nhave_backend () {\n    echo \"$trace_backends\" | grep \"$1\" >/dev/null\n}\n\n# default parameters\nsource_path=$(dirname \"$0\")\ncpu=\"\"\niasl=\"iasl\"\ninterp_prefix=\"/usr/gnemul/qemu-%M\"\nstatic=\"no\"\ncross_prefix=\"\"\naudio_drv_list=\"\"\nblock_drv_rw_whitelist=\"\"\nblock_drv_ro_whitelist=\"\"\nhost_cc=\"cc\"\nlibs_softmmu=\"\"\nlibs_tools=\"\"\naudio_pt_int=\"\"\naudio_win_int=\"\"\ncc_i386=i386-pc-linux-gnu-gcc\nlibs_qga=\"\"\ndebug_info=\"yes\"\nstack_protector=\"\"\ngit_submodules=\"\"\nprotobuf=\"yes\"\nllvm=\"no\"\nllvmdir=\"/usr/lib/llvm-11\" # Default to try if unspecified\nllvmver=\"11\"\n\n# Don't accept a target_list environment variable.\nunset target_list\n\n# Default value for a variable defining feature \"foo\".\n#  * foo=\"no\"  feature will only be used if --enable-foo arg is given\n#  * foo=\"\"    feature will be searched for, and if found, will be used\n#              unless --disable-foo is given\n#  * foo=\"yes\" this value will only be set by --enable-foo flag.\n#              feature will searched for,\n#              if not found, configure exits with error\n#\n# Always add --enable-foo and --disable-foo command line args.\n# Distributions want to ensure that several features are compiled in, and it\n# is impossible without a --enable-foo that exits if a feature is not found.\n\nbluez=\"\"\nbrlapi=\"\"\ncurl=\"\"\ncurses=\"\"\ndocs=\"no\"\nfdt=\"\"\nnetmap=\"no\"\npixman=\"\"\nsdl=\"\"\nsdlabi=\"\"\nvirtfs=\"\"\nvnc=\"yes\"\nsparse=\"no\"\nvde=\"\"\nvnc_sasl=\"\"\nvnc_jpeg=\"\"\nvnc_png=\"\"\nxen=\"no\" # Disabled for PANDA\nxen_ctrl_version=\"\"\nxen_pv_domain_build=\"no\"\nxen_pci_passthrough=\"\"\nlinux_aio=\"\"\ncap_ng=\"\"\nattr=\"\"\nlibattr=\"\"\nxfs=\"\"\n\nvhost_net=\"no\"\nvhost_scsi=\"no\"\nvhost_vsock=\"no\"\nkvm=\"no\"\nhax=\"no\"\nrdma=\"\"\ngprof=\"no\"\ndebug_tcg=\"no\"\ndebug=\"no\"\nfortify_source=\"\"\nstrip_opt=\"yes\"\ntcg_interpreter=\"no\"\nbigendian=\"no\"\nmingw32=\"no\"\ngcov=\"no\"\ngcov_tool=\"gcov\"\nEXESUF=\"\"\nDSOSUF=\".so\"\nLDFLAGS_SHARED=\"-shared\"\nLDFLAGS=\"-rdynamic $LDFLAGS\"\nmodules=\"no\"\nprefix=\"/usr/local\"\nmandir=\"\\${prefix}/share/man\"\ndatadir=\"\\${prefix}/share\"\nqemu_docdir=\"\\${prefix}/share/doc/qemu\"\nbindir=\"\\${prefix}/bin\"\npythondir=\"\\${prefix}/lib/python3/dist-packages\"\nlibdir=\"\\${prefix}/lib\"\nlibexecdir=\"\\${prefix}/libexec\"\nincludedir=\"\\${prefix}/include\"\nsysconfdir=\"\\${prefix}/etc\"\nlocal_statedir=\"\\${prefix}/var\"\nconfsuffix=\"/panda\"\nslirp=\"yes\"\noss_lib=\"\"\nbsd=\"no\"\nlinux=\"no\"\nsolaris=\"no\"\nprofiler=\"no\"\ncocoa=\"no\"\nsoftmmu=\"yes\"\nlinux_user=\"no\"\nbsd_user=\"no\"\nblobs=\"yes\"\npkgversion=\"\"\npie=\"\"\nqom_cast_debug=\"yes\"\ntrace_backends=\"log\"\ntrace_file=\"trace\"\nspice=\"\"\nrbd=\"\"\nsmartcard=\"\"\nlibusb=\"\"\nusb_redir=\"\"\nopengl=\"\"\nopengl_dmabuf=\"no\"\ncpuid_h=\"no\"\navx2_opt=\"no\"\nzlib=\"yes\"\ncapstone=\"yes\"\nlzo=\"\"\nsnappy=\"\"\nbzip2=\"\"\nguest_agent=\"no\"\nguest_agent_with_vss=\"no\"\nguest_agent_ntddscsi=\"no\"\nguest_agent_msi=\"\"\nvss_win32_sdk=\"\"\nwin_sdk=\"no\"\nwant_tools=\"yes\"\nlibiscsi=\"\"\nlibnfs=\"\"\ncoroutine=\"\"\ncoroutine_pool=\"\"\ndebug_stack_usage=\"no\"\nseccomp=\"\"\nglusterfs=\"\"\nglusterfs_xlator_opt=\"no\"\nglusterfs_discard=\"no\"\nglusterfs_zerofill=\"no\"\nglusterfs_ftruncate_has_stat=\"no\"\nglusterfs_iocb_has_stat=\"no\"\ngtk=\"\"\ngtkabi=\"\"\ngtk_gl=\"no\"\ntls_priority=\"NORMAL\"\ngnutls=\"\"\ngnutls_rnd=\"\"\nnettle=\"\"\nnettle_kdf=\"no\"\ngcrypt=\"\"\ngcrypt_hmac=\"no\"\ngcrypt_kdf=\"no\"\nvte=\"\"\nvirglrenderer=\"\"\ntpm=\"yes\"\nlibssh2=\"\"\nnuma=\"\"\ntcmalloc=\"no\"\njemalloc=\"no\"\nreplication=\"yes\"\n#AVATAR\npyperipheral2=\"no\"\npyperipheral3=\"no\"\n\n\nsupported_cpu=\"no\"\nsupported_os=\"no\"\nbogus_os=\"no\"\n\n# parse CC options first\nfor opt do\n  optarg=$(expr \"x$opt\" : 'x[^=]*=\\(.*\\)')\n  case \"$opt\" in\n  --cross-prefix=*) cross_prefix=\"$optarg\"\n  ;;\n  --cc=*) CC=\"$optarg\"\n  ;;\n  --cxx=*) CXX=\"$optarg\"\n  ;;\n  --source-path=*) source_path=\"$optarg\"\n  ;;\n  --cpu=*) cpu=\"$optarg\"\n  ;;\n  --extra-cflags=*) QEMU_CFLAGS=\"$QEMU_CFLAGS $optarg\"\n  ;;\n  --extra-cxxflags=*) QEMU_CXXFLAGS=\"$QEMU_CXXFLAGS $optarg\"\n  ;;\n  --extra-ldflags=*) LDFLAGS=\"$LDFLAGS $optarg\"\n                     EXTRA_LDFLAGS=\"$optarg\"\n  ;;\n  --enable-debug-info) debug_info=\"yes\"\n  ;;\n  --disable-debug-info) debug_info=\"no\"\n  ;;\n  esac\ndone\n# OS specific\n# Using uname is really, really broken.  Once we have the right set of checks\n# we can eliminate its usage altogether.\n\n# Preferred compiler:\n#  ${CC} (if set)\n#  ${cross_prefix}gcc (if cross-prefix specified)\n#  system compiler\nif test -z \"${CC}${cross_prefix}\"; then\n  cc=\"$host_cc\"\nelse\n  cc=\"${CC-${cross_prefix}gcc}\"\nfi\n\nif test -z \"${CXX}${cross_prefix}\"; then\n  cxx=\"c++\"\nelse\n  cxx=\"${CXX-${cross_prefix}g++}\"\nfi\n\nar=\"${AR-${cross_prefix}ar}\"\nas=\"${AS-${cross_prefix}as}\"\nccas=\"${CCAS-$cc}\"\ncpp=\"${CPP-$cc -E}\"\nobjcopy=\"${OBJCOPY-${cross_prefix}objcopy}\"\nld=\"${LD-${cross_prefix}ld}\"\nnm=\"${NM-${cross_prefix}nm}\"\nstrip=\"${STRIP-${cross_prefix}strip}\"\nwindres=\"${WINDRES-${cross_prefix}windres}\"\npkg_config_exe=\"${PKG_CONFIG-${cross_prefix}pkg-config}\"\nquery_pkg_config() {\n    \"${pkg_config_exe}\" ${QEMU_PKG_CONFIG_FLAGS} \"$@\"\n}\npkg_config=query_pkg_config\nsdl_config=\"${SDL_CONFIG-${cross_prefix}sdl-config}\"\nsdl2_config=\"${SDL2_CONFIG-${cross_prefix}sdl2-config}\"\n\n# If the user hasn't specified ARFLAGS, default to 'rv', just as make does.\nARFLAGS=\"${ARFLAGS-rv}\"\n\n# default flags for all hosts\n# We use -fwrapv to tell the compiler that we require a C dialect where\n# left shift of signed integers is well defined and has the expected\n# 2s-complement style results. (Both clang and gcc agree that it\n# provides these semantics.)\nQEMU_CFLAGS=\"-fPIC -fno-strict-aliasing -fno-common -fwrapv $QEMU_CFLAGS\"\nQEMU_CFLAGS=\"-Wall -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS\"\nQEMU_CFLAGS=\"-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS\"\nQEMU_CFLAGS=\"-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS\"\n\nif pkg-config --exists --atleast-version 4.9 xencontrol; then\n    ## Enable xencontrol compat API for libxen-4.9 (Ubuntu 18.04LTS).\n    QEMU_CFLAGS=\"-DXC_WANT_COMPAT_DEVICEMODEL_API $QEMU_CFLAGS\"\nfi\n\nQEMU_INCLUDES=\"-iquote . -iquote \\$(SRC_PATH) -iquote \\$(SRC_PATH)/include\"\nQEMU_CXXFLAGS=\"-Wall $QEMU_CXXFLAGS\"\nif test \"$debug_info\" = \"yes\"; then\n    CFLAGS=\"-g $CFLAGS\"\n    LDFLAGS=\"-g $LDFLAGS\"\nfi\n\n# make source path absolute\nsource_path=$(cd \"$source_path\"; pwd)\n\n# running configure in the source tree?\n# we know that's the case if configure is there.\nif test -f \"./configure\"; then\n    pwd_is_source_path=\"y\"\nelse\n    pwd_is_source_path=\"n\"\nfi\n\ncheck_define() {\ncat > $TMPC <<EOF\n#if !defined($1)\n#error $1 not defined\n#endif\nint main(void) { return 0; }\nEOF\n  compile_object\n}\n\ncheck_include() {\ncat > $TMPC <<EOF\n#include <$1>\nint main(void) { return 0; }\nEOF\n  compile_object\n}\n\nwrite_c_skeleton() {\n    cat > $TMPC <<EOF\nint main(void) { return 0; }\nEOF\n}\n\nif check_define __linux__ ; then\n  targetos=\"Linux\"\nelif check_define _WIN32 ; then\n  targetos='MINGW32'\nelif check_define __OpenBSD__ ; then\n  targetos='OpenBSD'\nelif check_define __sun__ ; then\n  targetos='SunOS'\nelif check_define __HAIKU__ ; then\n  targetos='Haiku'\nelif check_define __FreeBSD__ ; then\n  targetos='FreeBSD'\nelif check_define __FreeBSD_kernel__ && check_define __GLIBC__; then\n  targetos='GNU/kFreeBSD'\nelif check_define __DragonFly__ ; then\n  targetos='DragonFly'\nelif check_define __NetBSD__; then\n  targetos='NetBSD'\nelif check_define __APPLE__; then\n  targetos='Darwin'\nelse\n  # This is a fatal error, but don't report it yet, because we\n  # might be going to just print the --help text, or it might\n  # be the result of a missing compiler.\n  targetos='bogus'\n  bogus_os='yes'\nfi\n\n# Some host OSes need non-standard checks for which CPU to use.\n# Note that these checks are broken for cross-compilation: if you're\n# cross-compiling to one of these OSes then you'll need to specify\n# the correct CPU with the --cpu option.\ncase $targetos in\nDarwin)\n  # on Leopard most of the system is 32-bit, so we have to ask the kernel if we can\n  # run 64-bit userspace code.\n  # If the user didn't specify a CPU explicitly and the kernel says this is\n  # 64 bit hw, then assume x86_64. Otherwise fall through to the usual detection code.\n  if test -z \"$cpu\" && test \"$(sysctl -n hw.optional.x86_64)\" = \"1\"; then\n    cpu=\"x86_64\"\n  fi\n  ;;\nSunOS)\n  # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo\n  if test -z \"$cpu\" && test \"$(isainfo -k)\" = \"amd64\"; then\n    cpu=\"x86_64\"\n  fi\nesac\n\nif test ! -z \"$cpu\" ; then\n  # command line argument\n  :\nelif check_define __i386__ ; then\n  cpu=\"i386\"\nelif check_define __x86_64__ ; then\n  if check_define __ILP32__ ; then\n    cpu=\"x32\"\n  else\n    cpu=\"x86_64\"\n  fi\nelif check_define __sparc__ ; then\n  if check_define __arch64__ ; then\n    cpu=\"sparc64\"\n  else\n    cpu=\"sparc\"\n  fi\nelif check_define _ARCH_PPC ; then\n  if check_define _ARCH_PPC64 ; then\n    cpu=\"ppc64\"\n  else\n    cpu=\"ppc\"\n  fi\nelif check_define __mips__ ; then\n  cpu=\"mips\"\nelif check_define __s390__ ; then\n  if check_define __s390x__ ; then\n    cpu=\"s390x\"\n  else\n    cpu=\"s390\"\n  fi\nelif check_define __arm__ ; then\n  cpu=\"arm\"\nelif check_define __aarch64__ ; then\n  cpu=\"aarch64\"\nelse\n  cpu=$(uname -m)\nfi\n\nARCH=\n# Normalise host CPU name and set ARCH.\n# Note that this case should only have supported host CPUs, not guests.\ncase \"$cpu\" in\n  ppc|ppc64|s390|s390x|sparc64|x32)\n    cpu=\"$cpu\"\n    supported_cpu=\"yes\"\n  ;;\n  i386|i486|i586|i686|i86pc|BePC)\n    cpu=\"i386\"\n    supported_cpu=\"yes\"\n  ;;\n  x86_64|amd64)\n    cpu=\"x86_64\"\n    supported_cpu=\"yes\"\n  ;;\n  armv*b|armv*l|arm)\n    cpu=\"arm\"\n    supported_cpu=\"yes\"\n  ;;\n  aarch64)\n    cpu=\"aarch64\"\n    supported_cpu=\"yes\"\n  ;;\n  mips|mipsel)\n    cpu=\"mips\"\n    supported_cpu=\"yes\"\n  ;;\n  sparc|sun4[cdmuv])\n    cpu=\"sparc\"\n    supported_cpu=\"yes\"\n  ;;\n  *)\n    # This will result in either an error or falling back to TCI later\n    ARCH=unknown\n  ;;\nesac\nif test -z \"$ARCH\"; then\n  ARCH=\"$cpu\"\nfi\n\n# OS specific\n\n# host *BSD for user mode\nHOST_VARIANT_DIR=\"\"\n\ncase $targetos in\nMINGW32*)\n  mingw32=\"yes\"\n  hax=\"yes\"\n  audio_possible_drivers=\"dsound sdl\"\n  if check_include dsound.h; then\n    audio_drv_list=\"dsound\"\n  else\n    audio_drv_list=\"\"\n  fi\n  supported_os=\"yes\"\n;;\nGNU/kFreeBSD)\n  bsd=\"yes\"\n  audio_drv_list=\"oss\"\n  audio_possible_drivers=\"oss sdl pa\"\n;;\nFreeBSD)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n  audio_drv_list=\"oss\"\n  audio_possible_drivers=\"oss sdl pa\"\n  # needed for kinfo_getvmmap(3) in libutil.h\n  LIBS=\"-lutil $LIBS\"\n  # needed for kinfo_getproc\n  libs_qga=\"-lutil $libs_qga\"\n  netmap=\"\"  # enable netmap autodetect\n  HOST_VARIANT_DIR=\"freebsd\"\n  supported_os=\"yes\"\n;;\nDragonFly)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n  audio_drv_list=\"oss\"\n  audio_possible_drivers=\"oss sdl pa\"\n  HOST_VARIANT_DIR=\"dragonfly\"\n;;\nNetBSD)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n  audio_drv_list=\"oss\"\n  audio_possible_drivers=\"oss sdl\"\n  oss_lib=\"-lossaudio\"\n  HOST_VARIANT_DIR=\"netbsd\"\n;;\nOpenBSD)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n  audio_drv_list=\"sdl\"\n  audio_possible_drivers=\"sdl\"\n  HOST_VARIANT_DIR=\"openbsd\"\n;;\nDarwin)\n  bsd=\"yes\"\n  darwin=\"yes\"\n  hax=\"yes\"\n  LDFLAGS_SHARED=\"-bundle -undefined dynamic_lookup\"\n  if [ \"$cpu\" = \"x86_64\" ] ; then\n    QEMU_CFLAGS=\"-arch x86_64 $QEMU_CFLAGS\"\n    LDFLAGS=\"-arch x86_64 $LDFLAGS\"\n  fi\n  cocoa=\"yes\"\n  audio_drv_list=\"coreaudio\"\n  audio_possible_drivers=\"coreaudio sdl\"\n  LDFLAGS=\"-framework CoreFoundation -framework IOKit $LDFLAGS\"\n  libs_softmmu=\"-F/System/Library/Frameworks -framework Cocoa -framework IOKit $libs_softmmu\"\n  # Disable attempts to use ObjectiveC features in os/object.h since they\n  # won't work when we're compiling with gcc as a C compiler.\n  QEMU_CFLAGS=\"-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS\"\n  # Hush clang warnings. Appended because QEMU_CFLAGS includes -Wall.\n  #   -Wno-extern-c-compat -> for start_init_save/end_init_save dummy markers in cpu.h\n  #   -Wno-address-of-packed-member ->\n  #   -Wno-unused-private-field -> unused private fields for classes in tcg-llvm.h\n  #   -Wno-availability -> warnings generated by system's zlib.h (WTF Apple?)\n  QEMU_CFLAGS=\"$QEMU_CFLAGS -Wno-extern-c-compat -Wno-address-of-packed-member -Wno-unused-private-field -Wno-availability\"\n  HOST_VARIANT_DIR=\"darwin\"\n  supported_os=\"yes\"\n;;\nSunOS)\n  solaris=\"yes\"\n  make=\"${MAKE-gmake}\"\n  install=\"${INSTALL-ginstall}\"\n  smbd=\"${SMBD-/usr/sfw/sbin/smbd}\"\n  if test -f /usr/include/sys/soundcard.h ; then\n    audio_drv_list=\"oss\"\n  fi\n  audio_possible_drivers=\"oss sdl\"\n# needed for CMSG_ macros in sys/socket.h\n  QEMU_CFLAGS=\"-D_XOPEN_SOURCE=600 $QEMU_CFLAGS\"\n# needed for TIOCWIN* defines in termios.h\n  QEMU_CFLAGS=\"-D__EXTENSIONS__ $QEMU_CFLAGS\"\n  QEMU_CFLAGS=\"-std=gnu99 $QEMU_CFLAGS\"\n  solarisnetlibs=\"-lsocket -lnsl -lresolv\"\n  LIBS=\"$solarisnetlibs $LIBS\"\n  libs_qga=\"$solarisnetlibs $libs_qga\"\n;;\nHaiku)\n  haiku=\"yes\"\n  QEMU_CFLAGS=\"-DB_USE_POSITIVE_POSIX_ERRORS $QEMU_CFLAGS\"\n  LIBS=\"-lposix_error_mapper -lnetwork $LIBS\"\n;;\nLinux)\n  audio_drv_list=\"oss\"\n  audio_possible_drivers=\"oss alsa sdl pa\"\n  linux=\"yes\"\n  linux_user=\"yes\"\n  kvm=\"yes\"\n  vhost_net=\"no\" # Disabled for PANDA\n  vhost_scsi=\"yes\"\n  vhost_vsock=\"yes\"\n  vhost_user=\"yes\"\n  QEMU_INCLUDES=\"-I\\$(SRC_PATH)/linux-headers -I$(pwd)/linux-headers $QEMU_INCLUDES\"\n  supported_os=\"yes\"\n  LIBS=\"-ldl $LIBS\"\n;;\nesac\n\nif [ \"$bsd\" = \"yes\" ] ; then\n  if [ \"$darwin\" != \"yes\" ] ; then\n    bsd_user=\"yes\"\n  fi\nfi\n\n: ${make=${MAKE-make}}\n: ${install=${INSTALL-install}}\n# We prefer python 3.x. A bare 'python' is traditionally\n# python 2.x, but some distros have it as python 3.x, so\n# we check that before python2\npython=\nfor binary in \"${PYTHON-python3}\" python python2\ndo\n    if has \"$binary\"\n    then\n        python=\"$binary\"\n        break\n    fi\ndone\n: ${smbd=${SMBD-/usr/sbin/smbd}}\n\n# Default objcc to clang if available, otherwise use CC\nif has clang; then\n  objcc=clang\nelse\n  objcc=\"$cc\"\nfi\n\nif test \"$mingw32\" = \"yes\" ; then\n  EXESUF=\".exe\"\n  DSOSUF=\".dll\"\n  QEMU_CFLAGS=\"-DWIN32_LEAN_AND_MEAN -DWINVER=0x501 $QEMU_CFLAGS\"\n  # enable C99/POSIX format strings (needs mingw32-runtime 3.15 or later)\n  QEMU_CFLAGS=\"-D__USE_MINGW_ANSI_STDIO=1 $QEMU_CFLAGS\"\n  # MinGW needs -mthreads for TLS and macro _MT.\n  QEMU_CFLAGS=\"-mthreads $QEMU_CFLAGS\"\n  LIBS=\"-lwinmm -lws2_32 -liphlpapi $LIBS\"\n  write_c_skeleton;\n  if compile_prog \"\" \"-liberty\" ; then\n    LIBS=\"-liberty $LIBS\"\n  fi\n  prefix=\"c:/Program Files/QEMU\"\n  mandir=\"\\${prefix}\"\n  datadir=\"\\${prefix}\"\n  qemu_docdir=\"\\${prefix}\"\n  bindir=\"\\${prefix}\"\n  sysconfdir=\"\\${prefix}\"\n  local_statedir=\n  confsuffix=\"\"\n  libs_qga=\"-lws2_32 -lwinmm -lpowrprof -liphlpapi -lnetapi32 $libs_qga\"\nfi\n\nwerror=\"\"\n\nfor opt do\n  optarg=$(expr \"x$opt\" : 'x[^=]*=\\(.*\\)')\n  case \"$opt\" in\n  --help|-h) show_help=yes\n  ;;\n  --version|-V) exec cat $source_path/VERSION\n  ;;\n  --prefix=*) prefix=\"$optarg\"\n  ;;\n  --interp-prefix=*) interp_prefix=\"$optarg\"\n  ;;\n  --source-path=*)\n  ;;\n  --cross-prefix=*)\n  ;;\n  --cc=*)\n  ;;\n  --host-cc=*) host_cc=\"$optarg\"\n  ;;\n  --cxx=*)\n  ;;\n  --iasl=*) iasl=\"$optarg\"\n  ;;\n  --objcc=*) objcc=\"$optarg\"\n  ;;\n  --make=*) make=\"$optarg\"\n  ;;\n  --install=*) install=\"$optarg\"\n  ;;\n  --python=*) python=\"$optarg\"\n  ;;\n  --gcov=*) gcov_tool=\"$optarg\"\n  ;;\n  --smbd=*) smbd=\"$optarg\"\n  ;;\n  --extra-cflags=*)\n  ;;\n  --extra-cxxflags=*)\n  ;;\n  --extra-ldflags=*)\n  ;;\n  --enable-debug-info)\n  ;;\n  --disable-debug-info)\n  ;;\n  --enable-modules)\n      modules=\"yes\"\n  ;;\n  --disable-modules)\n      modules=\"no\"\n  ;;\n  --cpu=*)\n  ;;\n  --target-list=*) target_list=\"$optarg\"\n  ;;\n  --enable-trace-backends=*) trace_backends=\"$optarg\"\n  ;;\n  # XXX: backwards compatibility\n  --enable-trace-backend=*) trace_backends=\"$optarg\"\n  ;;\n  --with-trace-file=*) trace_file=\"$optarg\"\n  ;;\n  --enable-gprof) gprof=\"yes\"\n  ;;\n  --enable-gcov) gcov=\"yes\"\n  ;;\n  --static)\n    static=\"yes\"\n    LDFLAGS=\"-static $LDFLAGS\"\n    QEMU_PKG_CONFIG_FLAGS=\"--static $QEMU_PKG_CONFIG_FLAGS\"\n  ;;\n  --mandir=*) mandir=\"$optarg\"\n  ;;\n  --bindir=*) bindir=\"$optarg\"\n  ;;\n  --libdir=*) libdir=\"$optarg\"\n  ;;\n  --pythondir=*) pythondir=\"$optarg\"\n  ;;\n  --libexecdir=*) libexecdir=\"$optarg\"\n  ;;\n  --includedir=*) includedir=\"$optarg\"\n  ;;\n  --datadir=*) datadir=\"$optarg\"\n  ;;\n  --with-confsuffix=*) confsuffix=\"$optarg\"\n  ;;\n  --docdir=*) qemu_docdir=\"$optarg\"\n  ;;\n  --sysconfdir=*) sysconfdir=\"$optarg\"\n  ;;\n  --localstatedir=*) local_statedir=\"$optarg\"\n  ;;\n  --sbindir=*|--sharedstatedir=*|\\\n  --oldincludedir=*|--datarootdir=*|--infodir=*|--localedir=*|\\\n  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)\n    # These switches are silently ignored, for compatibility with\n    # autoconf-generated configure scripts. This allows QEMU's\n    # configure to be used by RPM and similar macros that set\n    # lots of directory switches by default.\n  ;;\n  --with-system-pixman) pixman=\"system\"\n  ;;\n  --without-system-pixman) pixman=\"internal\"\n  ;;\n  --without-pixman) pixman=\"none\"\n  ;;\n  --disable-sdl) sdl=\"no\"\n  ;;\n  --enable-sdl) sdl=\"yes\"\n  ;;\n  --with-sdlabi=*) sdlabi=\"$optarg\"\n  ;;\n  --disable-qom-cast-debug) qom_cast_debug=\"no\"\n  ;;\n  --enable-qom-cast-debug) qom_cast_debug=\"yes\"\n  ;;\n  --disable-virtfs) virtfs=\"no\"\n  ;;\n  --enable-virtfs) virtfs=\"yes\"\n  ;;\n  --disable-vnc) vnc=\"no\"\n  ;;\n  --enable-vnc) vnc=\"yes\"\n  ;;\n  --oss-lib=*) oss_lib=\"$optarg\"\n  ;;\n  --audio-drv-list=*) audio_drv_list=\"$optarg\"\n  ;;\n  --block-drv-rw-whitelist=*|--block-drv-whitelist=*) block_drv_rw_whitelist=$(echo \"$optarg\" | sed -e 's/,/ /g')\n  ;;\n  --block-drv-ro-whitelist=*) block_drv_ro_whitelist=$(echo \"$optarg\" | sed -e 's/,/ /g')\n  ;;\n  --enable-debug-tcg) debug_tcg=\"yes\"\n  ;;\n  --disable-debug-tcg) debug_tcg=\"no\"\n  ;;\n  --enable-debug)\n      # Enable debugging options that aren't excessively noisy\n      debug_tcg=\"yes\"\n      debug=\"yes\"\n      strip_opt=\"no\"\n      fortify_source=\"no\"\n  ;;\n  --enable-sparse) sparse=\"yes\"\n  ;;\n  --disable-sparse) sparse=\"no\"\n  ;;\n  --disable-strip) strip_opt=\"no\"\n  ;;\n  --disable-vnc-sasl) vnc_sasl=\"no\"\n  ;;\n  --enable-vnc-sasl) vnc_sasl=\"yes\"\n  ;;\n  --disable-vnc-jpeg) vnc_jpeg=\"no\"\n  ;;\n  --enable-vnc-jpeg) vnc_jpeg=\"yes\"\n  ;;\n  --disable-vnc-png) vnc_png=\"no\"\n  ;;\n  --enable-vnc-png) vnc_png=\"yes\"\n  ;;\n  --disable-slirp) slirp=\"no\"\n  ;;\n  --disable-vde) vde=\"no\"\n  ;;\n  --enable-vde) vde=\"yes\"\n  ;;\n  --disable-netmap) netmap=\"no\"\n  ;;\n  --enable-netmap) netmap=\"yes\"\n  ;;\n  --disable-xen) xen=\"no\"\n  ;;\n  --enable-xen) xen=\"yes\"\n  ;;\n  --disable-xen-pci-passthrough) xen_pci_passthrough=\"no\"\n  ;;\n  --enable-xen-pci-passthrough) xen_pci_passthrough=\"yes\"\n  ;;\n  --disable-xen-pv-domain-build) xen_pv_domain_build=\"no\"\n  ;;\n  --enable-xen-pv-domain-build) xen_pv_domain_build=\"yes\"\n  ;;\n  --disable-brlapi) brlapi=\"no\"\n  ;;\n  --enable-brlapi) brlapi=\"yes\"\n  ;;\n  --disable-bluez) bluez=\"no\"\n  ;;\n  --enable-bluez) bluez=\"yes\"\n  ;;\n  --disable-kvm) kvm=\"no\"\n  ;;\n  --enable-kvm) kvm=\"yes\"\n  ;;\n  --disable-hax) hax=\"no\"\n  ;;\n  --enable-hax) hax=\"yes\"\n  ;;\n  --disable-tcg-interpreter) tcg_interpreter=\"no\"\n  ;;\n  --enable-tcg-interpreter) tcg_interpreter=\"yes\"\n  ;;\n  --disable-cap-ng)  cap_ng=\"no\"\n  ;;\n  --enable-cap-ng) cap_ng=\"yes\"\n  ;;\n  --disable-spice) spice=\"no\"\n  ;;\n  --enable-spice) spice=\"yes\"\n  ;;\n  --disable-libiscsi) libiscsi=\"no\"\n  ;;\n  --enable-libiscsi) libiscsi=\"yes\"\n  ;;\n  --disable-libnfs) libnfs=\"no\"\n  ;;\n  --enable-libnfs) libnfs=\"yes\"\n  ;;\n  --enable-profiler) profiler=\"yes\"\n  ;;\n  --disable-cocoa) cocoa=\"no\"\n  ;;\n  --enable-cocoa)\n      cocoa=\"yes\" ;\n      audio_drv_list=\"coreaudio $(echo $audio_drv_list | sed s,coreaudio,,g)\"\n  ;;\n  --disable-system) softmmu=\"no\"\n  ;;\n  --enable-system) softmmu=\"yes\"\n  ;;\n  --disable-user)\n      linux_user=\"no\" ;\n      bsd_user=\"no\" ;\n  ;;\n  --enable-user) ;;\n  --disable-linux-user) linux_user=\"no\"\n  ;;\n  --enable-linux-user) linux_user=\"yes\"\n  ;;\n  --disable-bsd-user) bsd_user=\"no\"\n  ;;\n  --enable-bsd-user) bsd_user=\"yes\"\n  ;;\n  --enable-pie) pie=\"yes\"\n  ;;\n  --disable-pie) pie=\"no\"\n  ;;\n  --enable-werror) werror=\"yes\"\n  ;;\n  --disable-werror) werror=\"no\"\n  ;;\n  --enable-stack-protector) stack_protector=\"yes\"\n  ;;\n  --disable-stack-protector) stack_protector=\"no\"\n  ;;\n  --disable-curses) curses=\"no\"\n  ;;\n  --enable-curses) curses=\"yes\"\n  ;;\n  --disable-curl) curl=\"no\"\n  ;;\n  --enable-curl) curl=\"yes\"\n  ;;\n  --disable-fdt) fdt=\"no\"\n  ;;\n  --enable-fdt) fdt=\"yes\"\n  ;;\n  --disable-linux-aio) linux_aio=\"no\"\n  ;;\n  --enable-linux-aio) linux_aio=\"yes\"\n  ;;\n  --disable-attr) attr=\"no\"\n  ;;\n  --enable-attr) attr=\"yes\"\n  ;;\n  --disable-blobs) blobs=\"no\"\n  ;;\n  --with-pkgversion=*) pkgversion=\" ($optarg)\"\n  ;;\n  --with-coroutine=*) coroutine=\"$optarg\"\n  ;;\n  --disable-coroutine-pool) coroutine_pool=\"no\"\n  ;;\n  --enable-coroutine-pool) coroutine_pool=\"yes\"\n  ;;\n  --enable-debug-stack-usage) debug_stack_usage=\"yes\"\n  ;;\n  --disable-docs) docs=\"no\"\n  ;;\n  --enable-docs) docs=\"yes\"\n  ;;\n  --disable-vhost-net) vhost_net=\"no\"\n  ;;\n  --enable-vhost-net) vhost_net=\"yes\"\n  ;;\n  --disable-vhost-scsi) vhost_scsi=\"no\"\n  ;;\n  --enable-vhost-scsi) vhost_scsi=\"yes\"\n  ;;\n  --disable-vhost-vsock) vhost_vsock=\"no\"\n  ;;\n  --enable-vhost-vsock) vhost_vsock=\"yes\"\n  ;;\n  --disable-opengl) opengl=\"no\"\n  ;;\n  --enable-opengl) opengl=\"yes\"\n  ;;\n  --disable-rbd) rbd=\"no\"\n  ;;\n  --enable-rbd) rbd=\"yes\"\n  ;;\n  --disable-xfsctl) xfs=\"no\"\n  ;;\n  --enable-xfsctl) xfs=\"yes\"\n  ;;\n  --disable-smartcard) smartcard=\"no\"\n  ;;\n  --enable-smartcard) smartcard=\"yes\"\n  ;;\n  --disable-libusb) libusb=\"no\"\n  ;;\n  --enable-libusb) libusb=\"yes\"\n  ;;\n  --disable-usb-redir) usb_redir=\"no\"\n  ;;\n  --enable-usb-redir) usb_redir=\"yes\"\n  ;;\n  --disable-zlib-test) zlib=\"no\"\n  ;;\n  --disable-lzo) lzo=\"no\"\n  ;;\n  --enable-lzo) lzo=\"yes\"\n  ;;\n  --disable-snappy) snappy=\"no\"\n  ;;\n  --enable-snappy) snappy=\"yes\"\n  ;;\n  --disable-bzip2) bzip2=\"no\"\n  ;;\n  --enable-bzip2) bzip2=\"yes\"\n  ;;\n  --enable-guest-agent) guest_agent=\"yes\"\n  ;;\n  --disable-guest-agent) guest_agent=\"no\"\n  ;;\n  --enable-guest-agent-msi) guest_agent_msi=\"yes\"\n  ;;\n  --disable-guest-agent-msi) guest_agent_msi=\"no\"\n  ;;\n  --with-vss-sdk) vss_win32_sdk=\"\"\n  ;;\n  --with-vss-sdk=*) vss_win32_sdk=\"$optarg\"\n  ;;\n  --without-vss-sdk) vss_win32_sdk=\"no\"\n  ;;\n  --with-win-sdk) win_sdk=\"\"\n  ;;\n  --with-win-sdk=*) win_sdk=\"$optarg\"\n  ;;\n  --without-win-sdk) win_sdk=\"no\"\n  ;;\n  --enable-tools) want_tools=\"yes\"\n  ;;\n  --disable-tools) want_tools=\"no\"\n  ;;\n  --enable-seccomp) seccomp=\"yes\"\n  ;;\n  --disable-seccomp) seccomp=\"no\"\n  ;;\n  --disable-glusterfs) glusterfs=\"no\"\n  ;;\n  --enable-glusterfs) glusterfs=\"yes\"\n  ;;\n  --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)\n      echo \"$0: $opt is obsolete, virtio-blk data-plane is always on\" >&2\n  ;;\n  --enable-vhdx|--disable-vhdx)\n      echo \"$0: $opt is obsolete, VHDX driver is always built\" >&2\n  ;;\n  --enable-uuid|--disable-uuid)\n      echo \"$0: $opt is obsolete, UUID support is always built\" >&2\n  ;;\n  --disable-gtk) gtk=\"no\"\n  ;;\n  --enable-gtk) gtk=\"yes\"\n  ;;\n  --tls-priority=*) tls_priority=\"$optarg\"\n  ;;\n  --disable-gnutls) gnutls=\"no\"\n  ;;\n  --enable-gnutls) gnutls=\"yes\"\n  ;;\n  --disable-nettle) nettle=\"no\"\n  ;;\n  --enable-nettle) nettle=\"yes\"\n  ;;\n  --disable-gcrypt) gcrypt=\"no\"\n  ;;\n  --enable-gcrypt) gcrypt=\"yes\"\n  ;;\n  --enable-rdma) rdma=\"yes\"\n  ;;\n  --disable-rdma) rdma=\"no\"\n  ;;\n  --with-gtkabi=*) gtkabi=\"$optarg\"\n  ;;\n  --disable-vte) vte=\"no\"\n  ;;\n  --enable-vte) vte=\"yes\"\n  ;;\n  --disable-virglrenderer) virglrenderer=\"no\"\n  ;;\n  --enable-virglrenderer) virglrenderer=\"yes\"\n  ;;\n  --disable-tpm) tpm=\"no\"\n  ;;\n  --enable-tpm) tpm=\"yes\"\n  ;;\n  --disable-libssh2) libssh2=\"no\"\n  ;;\n  --enable-libssh2) libssh2=\"yes\"\n  ;;\n  --disable-numa) numa=\"no\"\n  ;;\n  --enable-numa) numa=\"yes\"\n  ;;\n  --disable-tcmalloc) tcmalloc=\"no\"\n  ;;\n  --enable-tcmalloc) tcmalloc=\"yes\"\n  ;;\n  --disable-jemalloc) jemalloc=\"no\"\n  ;;\n  --enable-jemalloc) jemalloc=\"yes\"\n  ;;\n  --disable-replication) replication=\"no\"\n  ;;\n  --enable-replication) replication=\"yes\"\n  ;;\n  --disable-capstone) capstone=\"no\"\n  ;;\n  --enable-capstone) capstone=\"yes\"\n  ;;\n  --enable-capstone=git) capstone=\"git\"\n  ;;\n  --enable-capstone=system) capstone=\"system\"\n  ;;\n  --enable-llvm) llvm=\"yes\"\n  ;;\n  --with-llvm=*) llvmdir=\"$optarg\"\n  ;;\n  --extra-plugins-path=*) extra_plugins_path=\"$optarg\"\n  ;;\n  --disable-pyperipheral2) pyperipheral2=\"no\"\n  ;;\n  --enable-pyperipheral2) pyperipheral2=\"yes\"\n      pyperipheral3=\"no\"\n  ;;\n  --disable-pyperipheral3) pyperipheral3=\"no\"\n  ;;\n  --enable-pyperipheral3) pyperipheral3=\"yes\"\n      pyperipheral2=\"no\"\n  ;;\n  *)\n      echo \"ERROR: unknown option $opt\"\n      echo \"Try '$0 --help' for more information\"\n      exit 1\n  ;;\n  esac\ndone\n\ncase \"$cpu\" in\n    ppc)\n           CPU_CFLAGS=\"-m32\"\n           LDFLAGS=\"-m32 $LDFLAGS\"\n           ;;\n    ppc64)\n           CPU_CFLAGS=\"-m64\"\n           LDFLAGS=\"-m64 $LDFLAGS\"\n           ;;\n    sparc)\n           LDFLAGS=\"-m32 $LDFLAGS\"\n           CPU_CFLAGS=\"-m32 -mcpu=ultrasparc\"\n           ;;\n    sparc64)\n           LDFLAGS=\"-m64 $LDFLAGS\"\n           CPU_CFLAGS=\"-m64 -mcpu=ultrasparc\"\n           ;;\n    s390)\n           CPU_CFLAGS=\"-m31\"\n           LDFLAGS=\"-m31 $LDFLAGS\"\n           ;;\n    s390x)\n           CPU_CFLAGS=\"-m64\"\n           LDFLAGS=\"-m64 $LDFLAGS\"\n           ;;\n    i386)\n           CPU_CFLAGS=\"-m32\"\n           LDFLAGS=\"-m32 $LDFLAGS\"\n           cc_i386='$(CC) -m32'\n           ;;\n    x86_64)\n           # ??? Only extremely old AMD cpus do not have cmpxchg16b.\n           # If we truly care, we should simply detect this case at\n           # runtime and generate the fallback to serial emulation.\n           CPU_CFLAGS=\"-m64 -mcx16\"\n           LDFLAGS=\"-m64 $LDFLAGS\"\n           cc_i386='$(CC) -m32'\n           ;;\n    x32)\n           CPU_CFLAGS=\"-mx32\"\n           LDFLAGS=\"-mx32 $LDFLAGS\"\n           cc_i386='$(CC) -m32'\n           ;;\n    # No special flags required for other host CPUs\nesac\n\nQEMU_CFLAGS=\"$CPU_CFLAGS $QEMU_CFLAGS\"\n\n# For user-mode emulation the host arch has to be one we explicitly\n# support, even if we're using TCI.\nif [ \"$ARCH\" = \"unknown\" ]; then\n  bsd_user=\"no\"\n  linux_user=\"no\"\nfi\n\ndefault_target_list=\"\"\n\nmak_wilds=\"\"\n\nif [ \"$softmmu\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/default-configs/*-softmmu.mak\"\nfi\nif [ \"$linux_user\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/default-configs/*-linux-user.mak\"\nfi\nif [ \"$bsd_user\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/default-configs/*-bsd-user.mak\"\nfi\n\nfor config in $mak_wilds; do\n    default_target_list=\"${default_target_list} $(basename \"$config\" .mak)\"\ndone\n\nif test x\"$show_help\" = x\"yes\" ; then\ncat << EOF\n\nUsage: configure [options]\nOptions: [defaults in brackets after descriptions]\n\nStandard options:\n  --help                   print this message\n  --prefix=PREFIX          install in PREFIX [$prefix]\n  --interp-prefix=PREFIX   where to find shared libraries, etc.\n                           use %M for cpu name [$interp_prefix]\n  --target-list=LIST       set target list (default: build everything)\n$(echo Available targets: $default_target_list | \\\n  fold -s -w 53 | sed -e 's/^/                           /')\n\nAdvanced options (experts only):\n  --source-path=PATH       path of source code [$source_path]\n  --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]\n  --cc=CC                  use C compiler CC [$cc]\n  --iasl=IASL              use ACPI compiler IASL [$iasl]\n  --host-cc=CC             use C compiler CC [$host_cc] for code run at\n                           build time\n  --cxx=CXX                use C++ compiler CXX [$cxx]\n  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]\n  --extra-cflags=CFLAGS    append extra C compiler flags QEMU_CFLAGS\n  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags QEMU_CXXFLAGS\n  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS\n  --make=MAKE              use specified make [$make]\n  --install=INSTALL        use specified install [$install]\n  --python=PYTHON          use specified python [$python]\n  --smbd=SMBD              use specified smbd [$smbd]\n  --static                 enable static build [$static]\n  --mandir=PATH            install man pages in PATH\n  --datadir=PATH           install firmware in PATH$confsuffix\n  --docdir=PATH            install documentation in PATH$confsuffix\n  --bindir=PATH            install binaries in PATH\n  --libdir=PATH            install libraries in PATH\n  --pythondir=PATH         install python packages to PATH\n  --sysconfdir=PATH        install config in PATH$confsuffix\n  --localstatedir=PATH     install local state in PATH (set at runtime on win32)\n  --with-confsuffix=SUFFIX suffix for QEMU data inside datadir/libdir/sysconfdir [$confsuffix]\n  --enable-debug           enable common debug build options\n  --disable-strip          disable stripping binaries\n  --disable-werror         disable compilation abort on warning\n  --disable-stack-protector disable compiler-provided stack protection\n  --audio-drv-list=LIST    set audio drivers list:\n                           Available drivers: $audio_possible_drivers\n  --block-drv-whitelist=L  Same as --block-drv-rw-whitelist=L\n  --block-drv-rw-whitelist=L\n                           set block driver read-write whitelist\n                           (affects only QEMU, not qemu-img)\n  --block-drv-ro-whitelist=L\n                           set block driver read-only whitelist\n                           (affects only QEMU, not qemu-img)\n  --enable-trace-backends=B Set trace backend\n                           Available backends: $($python $source_path/scripts/tracetool.py --list-backends)\n  --with-trace-file=NAME   Full PATH,NAME of file to store traces\n                           Default:trace-<pid>\n  --disable-slirp          disable SLIRP userspace network connectivity\n  --enable-tcg-interpreter enable TCG with bytecode interpreter (TCI)\n  --oss-lib                path to OSS library\n  --cpu=CPU                Build for host CPU [$cpu]\n  --with-coroutine=BACKEND coroutine backend. Supported options:\n                           gthread, ucontext, sigaltstack, windows\n  --enable-gcov            enable test coverage analysis with gcov\n  --gcov=GCOV              use specified gcov [$gcov_tool]\n  --disable-blobs          disable installing provided firmware blobs\n  --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent\n  --with-win-sdk=SDK-path  path to Windows Platform SDK (to build VSS .tlb)\n  --tls-priority           default TLS protocol/cipher priority string\n  --enable-gprof           QEMU profiling with gprof\n  --enable-profiler        profiler support\n  --enable-xen-pv-domain-build\n                           xen pv domain builder\n  --enable-debug-stack-usage\n                           track the maximum stack usage of stacks created by qemu_alloc_stack\n\nPANDA related options:\n  --enable-llvm                enable LLVM support (for all targets)\n  --with-llvm=PATH             LLVM path (PATH/bin/llvm-config must exist)\n  --extra-plugins-path=PATH    also compile plugins at this PATH\n\nOptional features, enabled with --enable-FEATURE and\ndisabled with --disable-FEATURE, default is enabled if available:\n\n  system          all system emulation targets\n  user            supported user emulation targets\n  linux-user      all linux usermode emulation targets\n  bsd-user        all BSD usermode emulation targets\n  docs            build documentation\n  guest-agent     build the QEMU Guest Agent\n  guest-agent-msi build guest agent Windows MSI installation package\n  pie             Position Independent Executables\n  modules         modules support\n  debug-tcg       TCG debugging (default is disabled)\n  debug-info      debugging information\n  sparse          sparse checker\n\n  gnutls          GNUTLS cryptography support\n  nettle          nettle cryptography support\n  gcrypt          libgcrypt cryptography support\n  sdl             SDL UI\n  --with-sdlabi     select preferred SDL ABI 1.2 or 2.0\n  gtk             gtk UI\n  --with-gtkabi     select preferred GTK ABI 2.0 or 3.0\n  vte             vte support for the gtk UI\n  curses          curses UI\n  vnc             VNC UI support\n  vnc-sasl        SASL encryption for VNC server\n  vnc-jpeg        JPEG lossy compression for VNC server\n  vnc-png         PNG compression for VNC server\n  cocoa           Cocoa UI (Mac OS X only)\n  virtfs          VirtFS\n  xen             xen backend driver support\n  xen-pci-passthrough\n  brlapi          BrlAPI (Braile)\n  curl            curl connectivity\n  fdt             fdt device tree\n  bluez           bluez stack connectivity\n  kvm             KVM acceleration support\n  hax             HAX acceleration support\n  rdma            RDMA-based migration support\n  vde             support for vde network\n  netmap          support for netmap network\n  linux-aio       Linux AIO support\n  cap-ng          libcap-ng support\n  attr            attr and xattr support\n  vhost-net       vhost-net acceleration support\n  spice           spice\n  rbd             rados block device (rbd)\n  libiscsi        iscsi support\n  libnfs          nfs support\n  smartcard       smartcard support (libcacard)\n  libusb          libusb (for usb passthrough)\n  usb-redir       usb network redirection support\n  lzo             support of lzo compression library\n  snappy          support of snappy compression library\n  bzip2           support of bzip2 compression library\n                  (for reading bzip2-compressed dmg images)\n  seccomp         seccomp support\n  coroutine-pool  coroutine freelist (better performance)\n  glusterfs       GlusterFS backend\n  tpm             TPM support\n  libssh2         ssh block device support\n  numa            libnuma support\n  tcmalloc        tcmalloc support\n  jemalloc        jemalloc support\n  replication     replication support\n  vhost-vsock     virtio sockets device support\n  opengl          opengl support\n  virglrenderer   virgl rendering support\n  xfsctl          xfsctl support\n  qom-cast-debug  cast debugging support\n  tools           build qemu-io, qemu-nbd and qemu-image tools\n  capstone        capstone disassembler support\n  pyperipheral2   avatar's python peripheral (based on python2.7)\n  pyperipheral3   avatar's python peripheral (based on python3.x)\n\nNOTE: The object files are built at the place where configure is launched\nEOF\nexit 0\nfi\n\nif test -z \"$python\"\nthen\n    error_exit \"Python not found. Use --python=/path/to/python\"\nfi\n\n# Note that if the Python conditional here evaluates True we will exit\n# with status 1 which is a shell 'false' value.\nif ! $python -c 'import sys; sys.exit(sys.version_info < (2,6))'; then\n  error_exit \"Cannot use '$python', Python 2 >= 2.6 or Python 3 is required.\" \\\n      \"Use --python=/path/to/python to specify a supported Python.\"\nfi\n\n# Suppress writing compiled files\npython=\"$python -B\"\n\n# Check that the C compiler works. Doing this here before testing\n# the host CPU ensures that we had a valid CC to autodetect the\n# $cpu var (and we should bail right here if that's not the case).\n# It also allows the help message to be printed without a CC.\nwrite_c_skeleton;\nif compile_object ; then\n  : C compiler works ok\nelse\n    error_exit \"\\\"$cc\\\" either does not exist or does not work\"\nfi\nif ! compile_prog ; then\n    error_exit \"\\\"$cc\\\" cannot build an executable (is your linker broken?)\"\nfi\n\n# Now we have handled --enable-tcg-interpreter and know we're not just\n# printing the help message, bail out if the host CPU isn't supported.\nif test \"$ARCH\" = \"unknown\"; then\n    if test \"$tcg_interpreter\" = \"yes\" ; then\n        echo \"Unsupported CPU = $cpu, will use TCG with TCI (experimental)\"\n    else\n        error_exit \"Unsupported CPU = $cpu, try --enable-tcg-interpreter\"\n    fi\nfi\n\n# Consult white-list to determine whether to enable werror\n# by default.  Only enable by default for git builds\nif test -z \"$werror\" ; then\n    if test -d \"$source_path/.git\" -a \\\n        \\( \"$linux\" = \"yes\" -o \"$mingw32\" = \"yes\" \\) ; then\n        werror=\"yes\"\n    else\n        werror=\"no\"\n    fi\nfi\n\n# check that the C compiler works.\nwrite_c_skeleton;\nif compile_object ; then\n  : C compiler works ok\nelse\n    error_exit \"\\\"$cc\\\" either does not exist or does not work\"\nfi\nif ! compile_prog ; then\n    error_exit \"\\\"$cc\\\" cannot build an executable (is your linker broken?)\"\nfi\n\nif test \"$bogus_os\" = \"yes\"; then\n    # Now that we know that we're not printing the help and that\n    # the compiler works (so the results of the check_defines we used\n    # to identify the OS are reliable), if we didn't recognize the\n    # host OS we should stop now.\n    error_exit \"Unrecognized host OS (uname -s reports '$(uname -s)')\"\nfi\n\ngcc_flags=\"-Wold-style-declaration -Wold-style-definition -Wtype-limits\"\ngcc_flags=\"-Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers $gcc_flags\"\ngcc_flags=\"-Wno-missing-include-dirs -Wempty-body -Wnested-externs $gcc_flags\"\ngcc_flags=\"-Wendif-labels -Wno-shift-negative-value $gcc_flags\"\ngcc_flags=\"-Wno-initializer-overrides $gcc_flags\"\ngcc_flags=\"-Wno-string-plus-int $gcc_flags\"\ngcc_flags=\"-Wno-error=address-of-packed-member $gcc_flags\"\n# Note that we do not add -Werror to gcc_flags here, because that would\n# enable it for all configure tests. If a configure test failed due\n# to -Werror this would just silently disable some features,\n# so it's too error prone.\n\ncc_has_warning_flag() {\n    write_c_skeleton;\n\n    # Use the positive sense of the flag when testing for -Wno-wombat\n    # support (gcc will happily accept the -Wno- form of unknown\n    # warning options).\n    optflag=\"$(echo $1 | sed -e 's/^-Wno-/-W/')\"\n    compile_prog \"-Werror $optflag\" \"\"\n}\n\nfor flag in $gcc_flags; do\n    if cc_has_warning_flag $flag ; then\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n    fi\ndone\n\nif test \"$stack_protector\" != \"no\"; then\n  cat > $TMPC << EOF\nint main(int argc, char *argv[])\n{\n    char arr[64], *p = arr, *c = argv[0];\n    while (*c) {\n        *p++ = *c++;\n    }\n    return 0;\n}\nEOF\n  gcc_flags=\"-fstack-protector-strong -fstack-protector-all\"\n  sp_on=0\n  for flag in $gcc_flags; do\n    # We need to check both a compile and a link, since some compiler\n    # setups fail only on a .c->.o compile and some only at link time\n    if do_cc $QEMU_CFLAGS -Werror $flag -c -o $TMPO $TMPC &&\n       compile_prog \"-Werror $flag\" \"\"; then\n      QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n      sp_on=1\n      break\n    fi\n  done\n  if test \"$stack_protector\" = yes; then\n    if test $sp_on = 0; then\n      error_exit \"Stack protector not supported\"\n    fi\n  fi\nfi\n\n# Workaround for http://gcc.gnu.org/PR55489.  Happens with -fPIE/-fPIC and\n# large functions that use global variables.  The bug is in all releases of\n# GCC, but it became particularly acute in 4.6.x and 4.7.x.  It is fixed in\n# 4.7.3 and 4.8.0.  We should be able to delete this at the end of 2013.\ncat > $TMPC << EOF\n#if __GNUC__ == 4 && (__GNUC_MINOR__ == 6 || (__GNUC_MINOR__ == 7 && __GNUC_PATCHLEVEL__ <= 2))\nint main(void) { return 0; }\n#else\n#error No bug in this compiler.\n#endif\nEOF\nif compile_prog \"-Werror -fno-gcse\" \"\" ; then\n  TRANSLATE_OPT_CFLAGS=-fno-gcse\nfi\n\nif test \"$static\" = \"yes\" ; then\n  if test \"$modules\" = \"yes\" ; then\n    error_exit \"static and modules are mutually incompatible\"\n  fi\n  if test \"$pie\" = \"yes\" ; then\n    error_exit \"static and pie are mutually incompatible\"\n  else\n    pie=\"no\"\n  fi\nfi\n\n# Unconditional check for compiler __thread support\n  cat > $TMPC << EOF\nstatic __thread int tls_var;\nint main(void) { return tls_var; }\nEOF\n\nif ! compile_prog \"-Werror\" \"\" ; then\n    error_exit \"Your compiler does not support the __thread specifier for \" \\\n\t\"Thread-Local Storage (TLS). Please upgrade to a version that does.\"\nfi\n\nif test \"$pie\" = \"\"; then\n  case \"$cpu-$targetos\" in\n    i386-Linux|x86_64-Linux|x32-Linux|i386-OpenBSD|x86_64-OpenBSD)\n      ;;\n    *)\n      pie=\"no\"\n      ;;\n  esac\nfi\n\nif test \"$pie\" != \"no\" ; then\n  cat > $TMPC << EOF\n\n#ifdef __linux__\n#  define THREAD __thread\n#else\n#  define THREAD\n#endif\n\nstatic THREAD int tls_var;\n\nint main(void) { return tls_var; }\n\nEOF\n  if compile_prog \"-fPIE -DPIE\" \"-pie\"; then\n    QEMU_CFLAGS=\"-fPIE -DPIE $QEMU_CFLAGS\"\n    LDFLAGS=\"-pie $LDFLAGS\"\n    pie=\"yes\"\n    if compile_prog \"\" \"-Wl,-z,relro -Wl,-z,now\" ; then\n      LDFLAGS=\"-Wl,-z,relro -Wl,-z,now $LDFLAGS\"\n    fi\n  else\n    if test \"$pie\" = \"yes\"; then\n      error_exit \"PIE not available due to missing toolchain support\"\n    else\n      echo \"Disabling PIE due to missing toolchain support\"\n      pie=\"no\"\n    fi\n  fi\n\n  if compile_prog \"-Werror -fno-pie\" \"-nopie\"; then\n    CFLAGS_NOPIE=\"-fno-pie\"\n    LDFLAGS_NOPIE=\"-nopie\"\n  fi\nfi\n\n##########################################\n# __sync_fetch_and_and requires at least -march=i486. Many toolchains\n# use i686 as default anyway, but for those that don't, an explicit\n# specification is necessary\n\nif test \"$cpu\" = \"i386\"; then\n  cat > $TMPC << EOF\nstatic int sfaa(int *ptr)\n{\n  return __sync_fetch_and_and(ptr, 0);\n}\n\nint main(void)\n{\n  int val = 42;\n  val = __sync_val_compare_and_swap(&val, 0, 1);\n  sfaa(&val);\n  return val;\n}\nEOF\n  if ! compile_prog \"\" \"\" ; then\n    QEMU_CFLAGS=\"-march=i486 $QEMU_CFLAGS\"\n  fi\nfi\n\n#########################################\n# Solaris specific configure tool chain decisions\n\nif test \"$solaris\" = \"yes\" ; then\n  if has $install; then\n    :\n  else\n    error_exit \"Solaris install program not found. Use --install=/usr/ucb/install or\" \\\n        \"install fileutils from www.blastwave.org using pkg-get -i fileutils\" \\\n        \"to get ginstall which is used by default (which lives in /opt/csw/bin)\"\n  fi\n  if test \"$(path_of $install)\" = \"/usr/sbin/install\" ; then\n    error_exit \"Solaris /usr/sbin/install is not an appropriate install program.\" \\\n        \"try ginstall from the GNU fileutils available from www.blastwave.org\" \\\n        \"using pkg-get -i fileutils, or use --install=/usr/ucb/install\"\n  fi\n  if has ar; then\n    :\n  else\n    if test -f /usr/ccs/bin/ar ; then\n      error_exit \"No path includes ar\" \\\n          \"Add /usr/ccs/bin to your path and rerun configure\"\n    fi\n    error_exit \"No path includes ar\"\n  fi\nfi\n\nif test -z \"${target_list+xxx}\" ; then\n    target_list=\"i386-softmmu x86_64-softmmu arm-softmmu ppc-softmmu mipsel-softmmu mips-softmmu\"\nelse\n    target_list=$(echo \"$target_list\" | sed -e 's/,/ /g')\nfi\n\n# Check that we recognised the target name; this allows a more\n# friendly error message than if we let it fall through.\nfor target in $target_list; do\n    case \" $default_target_list \" in\n        *\" $target \"*)\n            ;;\n        *)\n            error_exit \"Unknown target name '$target'\"\n            ;;\n    esac\ndone\n\n# see if system emulation was really requested\ncase \" $target_list \" in\n  *\"-softmmu \"*) softmmu=yes\n  ;;\n  *) softmmu=no\n  ;;\nesac\n\nfeature_not_found() {\n  feature=$1\n  remedy=$2\n\n  error_exit \"User requested feature $feature\" \\\n      \"configure was not able to find it.\" \\\n      \"$remedy\"\n}\n\n# ---\n# big/little endian test\ncat > $TMPC << EOF\nshort big_endian[] = { 0x4269, 0x4765, 0x4e64, 0x4961, 0x4e00, 0, };\nshort little_endian[] = { 0x694c, 0x7454, 0x654c, 0x6e45, 0x6944, 0x6e41, 0, };\nextern int foo(short *, short *);\nint main(int argc, char *argv[]) {\n    return foo(big_endian, little_endian);\n}\nEOF\n\nif compile_object ; then\n    if grep -q BiGeNdIaN $TMPO ; then\n        bigendian=\"yes\"\n    elif grep -q LiTtLeEnDiAn $TMPO ; then\n        bigendian=\"no\"\n    else\n        echo big/little test failed\n    fi\nelse\n    echo big/little test failed\nfi\n\n##########################################\n# cocoa implies not SDL or GTK\n# (the cocoa UI code currently assumes it is always the active UI\n# and doesn't interact well with other UI frontend code)\nif test \"$cocoa\" = \"yes\"; then\n    if test \"$sdl\" = \"yes\"; then\n        error_exit \"Cocoa and SDL UIs cannot both be enabled at once\"\n    fi\n    if test \"$gtk\" = \"yes\"; then\n        error_exit \"Cocoa and GTK UIs cannot both be enabled at once\"\n    fi\n    gtk=no\n    sdl=no\nfi\n\n# Some versions of Mac OS X incorrectly define SIZE_MAX\ncat > $TMPC << EOF\n#include <stdint.h>\n#include <stdio.h>\nint main(int argc, char *argv[]) {\n    return printf(\"%zu\", SIZE_MAX);\n}\nEOF\nhave_broken_size_max=no\nif ! compile_object -Werror ; then\n    have_broken_size_max=yes\nfi\n\n##########################################\n# L2TPV3 probe\n\ncat > $TMPC <<EOF\n#include <sys/socket.h>\n#include <linux/ip.h>\nint main(void) { return sizeof(struct mmsghdr); }\nEOF\nif compile_prog \"\" \"\" ; then\n  l2tpv3=yes\nelse\n  l2tpv3=no\nfi\n\n##########################################\n# MinGW / Mingw-w64 localtime_r/gmtime_r check\n\nif test \"$mingw32\" = \"yes\"; then\n    # Some versions of MinGW / Mingw-w64 lack localtime_r\n    # and gmtime_r entirely.\n    #\n    # Some versions of Mingw-w64 define a macro for\n    # localtime_r/gmtime_r.\n    #\n    # Some versions of Mingw-w64 will define functions\n    # for localtime_r/gmtime_r, but only if you have\n    # _POSIX_THREAD_SAFE_FUNCTIONS defined. For fun\n    # though, unistd.h and pthread.h both define\n    # that for you.\n    #\n    # So this #undef localtime_r and #include <unistd.h>\n    # are not in fact redundant.\ncat > $TMPC << EOF\n#include <unistd.h>\n#include <time.h>\n#undef localtime_r\nint main(void) { localtime_r(NULL, NULL); return 0; }\nEOF\n    if compile_prog \"\" \"\" ; then\n        localtime_r=\"yes\"\n    else\n        localtime_r=\"no\"\n    fi\nfi\n\n##########################################\n# pkg-config probe\n\nif ! has \"$pkg_config_exe\"; then\n  error_exit \"pkg-config binary '$pkg_config_exe' not found\"\nfi\n\n##########################################\n# NPTL probe\n\nif test \"$linux_user\" = \"yes\"; then\n  cat > $TMPC <<EOF\n#include <sched.h>\n#include <linux/futex.h>\nint main(void) {\n#if !defined(CLONE_SETTLS) || !defined(FUTEX_WAIT)\n#error bork\n#endif\n  return 0;\n}\nEOF\n  if ! compile_object ; then\n    feature_not_found \"nptl\" \"Install glibc and linux kernel headers.\"\n  fi\nfi\n\n#########################################\n# zlib check\n\nif test \"$zlib\" != \"no\" ; then\n    cat > $TMPC << EOF\n#include <zlib.h>\nint main(void) { zlibVersion(); return 0; }\nEOF\n    if compile_prog \"\" \"-lz\" ; then\n        :\n    else\n        error_exit \"zlib check failed\" \\\n            \"Make sure to have the zlib libs and headers installed.\"\n    fi\nfi\nLIBS=\"$LIBS -lz\"\n\n##########################################\n# lzo check\n\nif test \"$lzo\" != \"no\" ; then\n    cat > $TMPC << EOF\n#include <lzo/lzo1x.h>\nint main(void) { lzo_version(); return 0; }\nEOF\n    if compile_prog \"\" \"-llzo2\" ; then\n        libs_softmmu=\"$libs_softmmu -llzo2\"\n        lzo=\"yes\"\n    else\n        if test \"$lzo\" = \"yes\"; then\n            feature_not_found \"liblzo2\" \"Install liblzo2 devel\"\n        fi\n        lzo=\"no\"\n    fi\nfi\n\n##########################################\n# snappy check\n\nif test \"$snappy\" != \"no\" ; then\n    cat > $TMPC << EOF\n#include <snappy-c.h>\nint main(void) { snappy_max_compressed_length(4096); return 0; }\nEOF\n    if compile_prog \"\" \"-lsnappy\" ; then\n        libs_softmmu=\"$libs_softmmu -lsnappy\"\n        snappy=\"yes\"\n    else\n        if test \"$snappy\" = \"yes\"; then\n            feature_not_found \"libsnappy\" \"Install libsnappy devel\"\n        fi\n        snappy=\"no\"\n    fi\nfi\n\n##########################################\n# bzip2 check\n\nif test \"$bzip2\" != \"no\" ; then\n    cat > $TMPC << EOF\n#include <bzlib.h>\nint main(void) { BZ2_bzlibVersion(); return 0; }\nEOF\n    if compile_prog \"\" \"-lbz2\" ; then\n        bzip2=\"yes\"\n    else\n        if test \"$bzip2\" = \"yes\"; then\n            feature_not_found \"libbzip2\" \"Install libbzip2 devel\"\n        fi\n        bzip2=\"no\"\n    fi\nfi\n\n##########################################\n# libseccomp check\n\nif test \"$seccomp\" != \"no\" ; then\n    case \"$cpu\" in\n    i386|x86_64)\n        libseccomp_minver=\"2.1.0\"\n        ;;\n    mips)\n        libseccomp_minver=\"2.2.0\"\n        ;;\n    arm|aarch64)\n        libseccomp_minver=\"2.2.3\"\n        ;;\n    ppc|ppc64)\n        libseccomp_minver=\"2.3.0\"\n        ;;\n    *)\n        libseccomp_minver=\"\"\n        ;;\n    esac\n\n    if test \"$libseccomp_minver\" != \"\" &&\n       $pkg_config --atleast-version=$libseccomp_minver libseccomp ; then\n        libs_softmmu=\"$libs_softmmu $($pkg_config --libs libseccomp)\"\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $($pkg_config --cflags libseccomp)\"\n        seccomp=\"yes\"\n    else\n        if test \"$seccomp\" = \"yes\" ; then\n            if test \"$libseccomp_minver\" != \"\" ; then\n                feature_not_found \"libseccomp\" \\\n                    \"Install libseccomp devel >= $libseccomp_minver\"\n            else\n                feature_not_found \"libseccomp\" \\\n                    \"libseccomp is not supported for host cpu $cpu\"\n            fi\n        fi\n        seccomp=\"no\"\n    fi\nfi\n##########################################\n# xen probe\n\nif test \"$xen\" != \"no\" ; then\n  xen_libs=\"-lxenstore -lxenctrl -lxenguest\"\n  xen_stable_libs=\"-lxenforeignmemory -lxengnttab -lxenevtchn\"\n\n  # First we test whether Xen headers and libraries are available.\n  # If no, we are done and there is no Xen support.\n  # If yes, more tests are run to detect the Xen version.\n\n  # Xen (any)\n  cat > $TMPC <<EOF\n#include <xenctrl.h>\nint main(void) {\n  return 0;\n}\nEOF\n  if ! compile_prog \"\" \"$xen_libs\" ; then\n    # Xen not found\n    if test \"$xen\" = \"yes\" ; then\n      feature_not_found \"xen\" \"Install xen devel\"\n    fi\n    xen=no\n\n  # Xen unstable\n  elif\n      cat > $TMPC <<EOF &&\n/*\n * If we have stable libs the we don't want the libxc compat\n * layers, regardless of what CFLAGS we may have been given.\n *\n * Also, check if xengnttab_grant_copy_segment_t is defined and\n * grant copy operation is implemented.\n */\n#undef XC_WANT_COMPAT_EVTCHN_API\n#undef XC_WANT_COMPAT_GNTTAB_API\n#undef XC_WANT_COMPAT_MAP_FOREIGN_API\n#include <xenctrl.h>\n#include <xenstore.h>\n#include <xenevtchn.h>\n#include <xengnttab.h>\n#include <xenforeignmemory.h>\n#include <stdint.h>\n#include <xen/hvm/hvm_info_table.h>\n#if !defined(HVM_MAX_VCPUS)\n# error HVM_MAX_VCPUS not defined\n#endif\nint main(void) {\n  xc_interface *xc = NULL;\n  xenforeignmemory_handle *xfmem;\n  xenevtchn_handle *xe;\n  xengnttab_handle *xg;\n  xen_domain_handle_t handle;\n  xengnttab_grant_copy_segment_t* seg = NULL;\n\n  xs_daemon_open();\n\n  xc = xc_interface_open(0, 0, 0);\n  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);\n  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);\n  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);\n  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);\n  xc_domain_create(xc, 0, handle, 0, NULL, NULL);\n\n  xfmem = xenforeignmemory_open(0, 0);\n  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);\n\n  xe = xenevtchn_open(0, 0);\n  xenevtchn_fd(xe);\n\n  xg = xengnttab_open(0, 0);\n  xengnttab_grant_copy(xg, 0, seg);\n\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs $xen_stable_libs\"\n    then\n    xen_ctrl_version=480\n    xen=yes\n  elif\n      cat > $TMPC <<EOF &&\n/*\n * If we have stable libs the we don't want the libxc compat\n * layers, regardless of what CFLAGS we may have been given.\n */\n#undef XC_WANT_COMPAT_EVTCHN_API\n#undef XC_WANT_COMPAT_GNTTAB_API\n#undef XC_WANT_COMPAT_MAP_FOREIGN_API\n#include <xenctrl.h>\n#include <xenstore.h>\n#include <xenevtchn.h>\n#include <xengnttab.h>\n#include <xenforeignmemory.h>\n#include <stdint.h>\n#include <xen/hvm/hvm_info_table.h>\n#if !defined(HVM_MAX_VCPUS)\n# error HVM_MAX_VCPUS not defined\n#endif\nint main(void) {\n  xc_interface *xc = NULL;\n  xenforeignmemory_handle *xfmem;\n  xenevtchn_handle *xe;\n  xengnttab_handle *xg;\n  xen_domain_handle_t handle;\n\n  xs_daemon_open();\n\n  xc = xc_interface_open(0, 0, 0);\n  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);\n  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);\n  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);\n  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);\n  xc_domain_create(xc, 0, handle, 0, NULL, NULL);\n\n  xfmem = xenforeignmemory_open(0, 0);\n  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);\n\n  xe = xenevtchn_open(0, 0);\n  xenevtchn_fd(xe);\n\n  xg = xengnttab_open(0, 0);\n  xengnttab_map_grant_ref(xg, 0, 0, 0);\n\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs $xen_stable_libs\"\n    then\n    xen_ctrl_version=471\n    xen=yes\n  elif\n      cat > $TMPC <<EOF &&\n#include <xenctrl.h>\n#include <stdint.h>\nint main(void) {\n  xc_interface *xc = NULL;\n  xen_domain_handle_t handle;\n  xc_domain_create(xc, 0, handle, 0, NULL, NULL);\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs\"\n    then\n    xen_ctrl_version=470\n    xen=yes\n\n  # Xen 4.6\n  elif\n      cat > $TMPC <<EOF &&\n#include <xenctrl.h>\n#include <xenstore.h>\n#include <stdint.h>\n#include <xen/hvm/hvm_info_table.h>\n#if !defined(HVM_MAX_VCPUS)\n# error HVM_MAX_VCPUS not defined\n#endif\nint main(void) {\n  xc_interface *xc;\n  xs_daemon_open();\n  xc = xc_interface_open(0, 0, 0);\n  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);\n  xc_gnttab_open(NULL, 0);\n  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);\n  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);\n  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);\n  xc_reserved_device_memory_map(xc, 0, 0, 0, 0, NULL, 0);\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs\"\n    then\n    xen_ctrl_version=460\n    xen=yes\n\n  # Xen 4.5\n  elif\n      cat > $TMPC <<EOF &&\n#include <xenctrl.h>\n#include <xenstore.h>\n#include <stdint.h>\n#include <xen/hvm/hvm_info_table.h>\n#if !defined(HVM_MAX_VCPUS)\n# error HVM_MAX_VCPUS not defined\n#endif\nint main(void) {\n  xc_interface *xc;\n  xs_daemon_open();\n  xc = xc_interface_open(0, 0, 0);\n  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);\n  xc_gnttab_open(NULL, 0);\n  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);\n  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);\n  xc_hvm_create_ioreq_server(xc, 0, 0, NULL);\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs\"\n    then\n    xen_ctrl_version=450\n    xen=yes\n\n  elif\n      cat > $TMPC <<EOF &&\n#include <xenctrl.h>\n#include <xenstore.h>\n#include <stdint.h>\n#include <xen/hvm/hvm_info_table.h>\n#if !defined(HVM_MAX_VCPUS)\n# error HVM_MAX_VCPUS not defined\n#endif\nint main(void) {\n  xc_interface *xc;\n  xs_daemon_open();\n  xc = xc_interface_open(0, 0, 0);\n  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);\n  xc_gnttab_open(NULL, 0);\n  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);\n  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);\n  return 0;\n}\nEOF\n      compile_prog \"\" \"$xen_libs\"\n    then\n    xen_ctrl_version=420\n    xen=yes\n\n  else\n    if test \"$xen\" = \"yes\" ; then\n      feature_not_found \"xen (unsupported version)\" \\\n                        \"Install a supported xen (xen 4.2 or newer)\"\n    fi\n    xen=no\n  fi\n\n  if test \"$xen\" = yes; then\n    if test $xen_ctrl_version -ge 471  ; then\n      libs_softmmu=\"$xen_stable_libs $libs_softmmu\"\n    fi\n    libs_softmmu=\"$xen_libs $libs_softmmu\"\n  fi\nfi\n\nif test \"$xen_pci_passthrough\" != \"no\"; then\n  if test \"$xen\" = \"yes\" && test \"$linux\" = \"yes\"; then\n    xen_pci_passthrough=yes\n  else\n    if test \"$xen_pci_passthrough\" = \"yes\"; then\n      error_exit \"User requested feature Xen PCI Passthrough\" \\\n          \" but this feature requires /sys from Linux\"\n    fi\n    xen_pci_passthrough=no\n  fi\nfi\n\nif test \"$xen_pv_domain_build\" = \"yes\" &&\n   test \"$xen\" != \"yes\"; then\n    error_exit \"User requested Xen PV domain builder support\" \\\n\t       \"which requires Xen support.\"\nfi\n\n##########################################\n# Sparse probe\nif test \"$sparse\" != \"no\" ; then\n  if has cgcc; then\n    sparse=yes\n  else\n    if test \"$sparse\" = \"yes\" ; then\n      feature_not_found \"sparse\" \"Install sparse binary\"\n    fi\n    sparse=no\n  fi\nfi\n\n##########################################\n# X11 probe\nx11_cflags=\nx11_libs=-lX11\nif $pkg_config --exists \"x11\"; then\n    x11_cflags=$($pkg_config --cflags x11)\n    x11_libs=$($pkg_config --libs x11)\nfi\n\n##########################################\n# GTK probe\n\nif test \"$gtkabi\" = \"\"; then\n    # The GTK ABI was not specified explicitly, so try whether 2.0 is available.\n    # Use 3.0 as a fallback if that is available.\n    if $pkg_config --exists \"gtk+-2.0 >= 2.18.0\"; then\n        gtkabi=2.0\n    elif $pkg_config --exists \"gtk+-3.0 >= 3.0.0\"; then\n        gtkabi=3.0\n    else\n        gtkabi=2.0\n    fi\nfi\n\nif test \"$gtk\" != \"no\"; then\n    gtkpackage=\"gtk+-$gtkabi\"\n    gtkx11package=\"gtk+-x11-$gtkabi\"\n    if test \"$gtkabi\" = \"3.0\" ; then\n      gtkversion=\"3.0.0\"\n    else\n      gtkversion=\"2.18.0\"\n    fi\n    if $pkg_config --exists \"$gtkpackage >= $gtkversion\"; then\n        gtk_cflags=$($pkg_config --cflags $gtkpackage)\n        gtk_libs=$($pkg_config --libs $gtkpackage)\n        gtk_version=$($pkg_config --modversion $gtkpackage)\n        if $pkg_config --exists \"$gtkx11package >= $gtkversion\"; then\n            gtk_cflags=\"$gtk_cflags $x11_cflags\"\n            gtk_libs=\"$gtk_libs $x11_libs\"\n        fi\n        libs_softmmu=\"$gtk_libs $libs_softmmu\"\n        gtk=\"yes\"\n    elif test \"$gtk\" = \"yes\"; then\n        feature_not_found \"gtk\" \"Install gtk2 or gtk3 devel\"\n    else\n        gtk=\"no\"\n    fi\nfi\n\n\n##########################################\n# GNUTLS probe\n\ngnutls_works() {\n    # Unfortunately some distros have bad pkg-config information for gnutls\n    # such that it claims to exist but you get a compiler error if you try\n    # to use the options returned by --libs. Specifically, Ubuntu for --static\n    # builds doesn't work:\n    # https://bugs.launchpad.net/ubuntu/+source/gnutls26/+bug/1478035\n    #\n    # So sanity check the cflags/libs before assuming gnutls can be used.\n    if ! $pkg_config --exists \"gnutls\"; then\n        return 1\n    fi\n\n    write_c_skeleton\n    compile_prog \"$($pkg_config --cflags gnutls)\" \"$($pkg_config --libs gnutls)\"\n}\n\ngnutls_gcrypt=no\ngnutls_nettle=no\nif test \"$gnutls\" != \"no\"; then\n    if gnutls_works; then\n        gnutls_cflags=$($pkg_config --cflags gnutls)\n        gnutls_libs=$($pkg_config --libs gnutls)\n        libs_softmmu=\"$gnutls_libs $libs_softmmu\"\n        libs_tools=\"$gnutls_libs $libs_tools\"\n\tQEMU_CFLAGS=\"$QEMU_CFLAGS $gnutls_cflags\"\n        gnutls=\"yes\"\n\n\t# gnutls_rnd requires >= 2.11.0\n\tif $pkg_config --exists \"gnutls >= 2.11.0\"; then\n\t    gnutls_rnd=\"yes\"\n\telse\n\t    gnutls_rnd=\"no\"\n\tfi\n\n\tif $pkg_config --exists 'gnutls >= 3.0'; then\n\t    gnutls_gcrypt=no\n\t    gnutls_nettle=yes\n\telif $pkg_config --exists 'gnutls >= 2.12'; then\n\t    case $($pkg_config --libs --static gnutls) in\n\t\t*gcrypt*)\n\t\t    gnutls_gcrypt=yes\n\t\t    gnutls_nettle=no\n\t\t    ;;\n\t\t*nettle*)\n\t\t    gnutls_gcrypt=no\n\t\t    gnutls_nettle=yes\n\t\t    ;;\n\t\t*)\n\t\t    gnutls_gcrypt=yes\n\t\t    gnutls_nettle=no\n\t\t    ;;\n\t    esac\n\telse\n\t    gnutls_gcrypt=yes\n\t    gnutls_nettle=no\n\tfi\n    elif test \"$gnutls\" = \"yes\"; then\n\tfeature_not_found \"gnutls\" \"Install gnutls devel\"\n    else\n        gnutls=\"no\"\n        gnutls_rnd=\"no\"\n    fi\nelse\n    gnutls_rnd=\"no\"\nfi\n\n\n# If user didn't give a --disable/enable-gcrypt flag,\n# then mark as disabled if user requested nettle\n# explicitly, or if gnutls links to nettle\nif test -z \"$gcrypt\"\nthen\n    if test \"$nettle\" = \"yes\" || test \"$gnutls_nettle\" = \"yes\"\n    then\n        gcrypt=\"no\"\n    fi\nfi\n\n# If user didn't give a --disable/enable-nettle flag,\n# then mark as disabled if user requested gcrypt\n# explicitly, or if gnutls links to gcrypt\nif test -z \"$nettle\"\nthen\n    if test \"$gcrypt\" = \"yes\" || test \"$gnutls_gcrypt\" = \"yes\"\n    then\n        nettle=\"no\"\n    fi\nfi\n\nhas_libgcrypt_config() {\n    if ! has \"libgcrypt-config\"\n    then\n\treturn 1\n    fi\n\n    if test -n \"$cross_prefix\"\n    then\n\thost=$(libgcrypt-config --host)\n\tif test \"$host-\" != $cross_prefix\n\tthen\n\t    return 1\n\tfi\n    fi\n\n    return 0\n}\n\nif test \"$gcrypt\" != \"no\"; then\n    if has_libgcrypt_config; then\n        gcrypt_cflags=$(libgcrypt-config --cflags)\n        gcrypt_libs=$(libgcrypt-config --libs)\n        # Debian has remove -lgpg-error from libgcrypt-config\n        # as it \"spreads unnecessary dependencies\" which in\n        # turn breaks static builds...\n        if test \"$static\" = \"yes\"\n        then\n            gcrypt_libs=\"$gcrypt_libs -lgpg-error\"\n        fi\n        libs_softmmu=\"$gcrypt_libs $libs_softmmu\"\n        libs_tools=\"$gcrypt_libs $libs_tools\"\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $gcrypt_cflags\"\n        gcrypt=\"yes\"\n        if test -z \"$nettle\"; then\n           nettle=\"no\"\n        fi\n\n        cat > $TMPC << EOF\n#include <gcrypt.h>\nint main(void) {\n  gcry_kdf_derive(NULL, 0, GCRY_KDF_PBKDF2,\n                  GCRY_MD_SHA256,\n                  NULL, 0, 0, 0, NULL);\n return 0;\n}\nEOF\n        if compile_prog \"$gcrypt_cflags\" \"$gcrypt_libs\" ; then\n            gcrypt_kdf=yes\n        fi\n\n        cat > $TMPC << EOF\n#include <gcrypt.h>\nint main(void) {\n  gcry_mac_hd_t handle;\n  gcry_mac_open(&handle, GCRY_MAC_HMAC_MD5,\n                GCRY_MAC_FLAG_SECURE, NULL);\n  return 0;\n}\nEOF\n        if compile_prog \"$gcrypt_cflags\" \"$gcrypt_libs\" ; then\n            gcrypt_hmac=yes\n        fi\n    else\n        if test \"$gcrypt\" = \"yes\"; then\n            feature_not_found \"gcrypt\" \"Install gcrypt devel\"\n        else\n            gcrypt=\"no\"\n        fi\n    fi\nfi\n\n\nif test \"$nettle\" != \"no\"; then\n    if $pkg_config --exists \"nettle\"; then\n        nettle_cflags=$($pkg_config --cflags nettle)\n        nettle_libs=$($pkg_config --libs nettle)\n        nettle_version=$($pkg_config --modversion nettle)\n        libs_softmmu=\"$nettle_libs $libs_softmmu\"\n        libs_tools=\"$nettle_libs $libs_tools\"\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $nettle_cflags\"\n        nettle=\"yes\"\n\n        cat > $TMPC << EOF\n#include <stddef.h>\n#include <nettle/pbkdf2.h>\nint main(void) {\n     pbkdf2_hmac_sha256(8, NULL, 1000, 8, NULL, 8, NULL);\n     return 0;\n}\nEOF\n        if compile_prog \"$nettle_cflags\" \"$nettle_libs\" ; then\n            nettle_kdf=yes\n        fi\n    else\n        if test \"$nettle\" = \"yes\"; then\n            feature_not_found \"nettle\" \"Install nettle devel\"\n        else\n            nettle=\"no\"\n        fi\n    fi\nfi\n\nif test \"$gcrypt\" = \"yes\" && test \"$nettle\" = \"yes\"\nthen\n    error_exit \"Only one of gcrypt & nettle can be enabled\"\nfi\n\n##########################################\n# libtasn1 - only for the TLS creds/session test suite\n\ntasn1=yes\ntasn1_cflags=\"\"\ntasn1_libs=\"\"\nif $pkg_config --exists \"libtasn1\"; then\n    tasn1_cflags=$($pkg_config --cflags libtasn1)\n    tasn1_libs=$($pkg_config --libs libtasn1)\nelse\n    tasn1=no\nfi\n\n\n##########################################\n# getifaddrs (for tests/test-io-channel-socket )\n\nhave_ifaddrs_h=yes\nif ! check_include \"ifaddrs.h\" ; then\n  have_ifaddrs_h=no\nfi\n\n##########################################\n# VTE probe\n\nif test \"$vte\" != \"no\"; then\n    if test \"$gtkabi\" = \"3.0\"; then\n      vteminversion=\"0.32.0\"\n      if $pkg_config --exists \"vte-2.91\"; then\n        vtepackage=\"vte-2.91\"\n      else\n        vtepackage=\"vte-2.90\"\n      fi\n    else\n      vtepackage=\"vte\"\n      vteminversion=\"0.24.0\"\n    fi\n    if $pkg_config --exists \"$vtepackage >= $vteminversion\"; then\n        vte_cflags=$($pkg_config --cflags $vtepackage)\n        vte_libs=$($pkg_config --libs $vtepackage)\n        vteversion=$($pkg_config --modversion $vtepackage)\n        libs_softmmu=\"$vte_libs $libs_softmmu\"\n        vte=\"yes\"\n    elif test \"$vte\" = \"yes\"; then\n        if test \"$gtkabi\" = \"3.0\"; then\n            feature_not_found \"vte\" \"Install libvte-2.90/2.91 devel\"\n        else\n            feature_not_found \"vte\" \"Install libvte devel\"\n        fi\n    else\n        vte=\"no\"\n    fi\nfi\n\n##########################################\n# SDL probe\n\n# Look for sdl configuration program (pkg-config or sdl-config).  Try\n# sdl-config even without cross prefix, and favour pkg-config over sdl-config.\n\nif test \"$sdlabi\" = \"\"; then\n    if $pkg_config --exists \"sdl\"; then\n        sdlabi=1.2\n    elif $pkg_config --exists \"sdl2\"; then\n        sdlabi=2.0\n    else\n        sdlabi=1.2\n    fi\nfi\n\nif test $sdlabi = \"2.0\"; then\n    sdl_config=$sdl2_config\n    sdlname=sdl2\n    sdlconfigname=sdl2_config\nelif test $sdlabi = \"1.2\"; then\n    sdlname=sdl\n    sdlconfigname=sdl_config\nelse\n    error_exit \"Unknown sdlabi $sdlabi, must be 1.2 or 2.0\"\nfi\n\nif test \"$(basename $sdl_config)\" != $sdlconfigname && ! has ${sdl_config}; then\n  sdl_config=$sdlconfigname\nfi\n\nif $pkg_config $sdlname --exists; then\n  sdlconfig=\"$pkg_config $sdlname\"\n  sdlversion=$($sdlconfig --modversion 2>/dev/null)\nelif has ${sdl_config}; then\n  sdlconfig=\"$sdl_config\"\n  sdlversion=$($sdlconfig --version)\nelse\n  if test \"$sdl\" = \"yes\" ; then\n    feature_not_found \"sdl\" \"Install SDL devel\"\n  fi\n  sdl=no\nfi\nif test -n \"$cross_prefix\" && test \"$(basename \"$sdlconfig\")\" = sdl-config; then\n  echo warning: using \"\\\"$sdlconfig\\\"\" to detect cross-compiled sdl >&2\nfi\n\nsdl_too_old=no\nif test \"$sdl\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <SDL.h>\n#undef main /* We don't want SDL to override our main() */\nint main( void ) { return SDL_Init (SDL_INIT_VIDEO); }\nEOF\n  sdl_cflags=$($sdlconfig --cflags 2>/dev/null)\n  if test \"$static\" = \"yes\" ; then\n    sdl_libs=$($sdlconfig --static-libs 2>/dev/null)\n  else\n    sdl_libs=$($sdlconfig --libs 2>/dev/null)\n  fi\n  if compile_prog \"$sdl_cflags\" \"$sdl_libs\" ; then\n    if test $(echo $sdlversion | sed 's/[^0-9]//g') -lt 121 ; then\n      sdl_too_old=yes\n    else\n      sdl=yes\n    fi\n\n    # static link with sdl ? (note: sdl.pc's --static --libs is broken)\n    if test \"$sdl\" = \"yes\" -a \"$static\" = \"yes\" ; then\n      if test $? = 0 && echo $sdl_libs | grep -- -laa > /dev/null; then\n         sdl_libs=\"$sdl_libs $(aalib-config --static-libs 2>/dev/null)\"\n         sdl_cflags=\"$sdl_cflags $(aalib-config --cflags 2>/dev/null)\"\n      fi\n      if compile_prog \"$sdl_cflags\" \"$sdl_libs\" ; then\n\t:\n      else\n        sdl=no\n      fi\n    fi # static link\n  else # sdl not found\n    if test \"$sdl\" = \"yes\" ; then\n      feature_not_found \"sdl\" \"Install SDL devel\"\n    fi\n    sdl=no\n  fi # sdl compile test\nfi\n\nif test \"$sdl\" = \"yes\" ; then\n  cat > $TMPC <<EOF\n#include <SDL.h>\n#if defined(SDL_VIDEO_DRIVER_X11)\n#include <X11/XKBlib.h>\n#else\n#error No x11 support\n#endif\nint main(void) { return 0; }\nEOF\n  if compile_prog \"$sdl_cflags $x11_cflags\" \"$sdl_libs $x11_libs\" ; then\n    sdl_cflags=\"$sdl_cflags $x11_cflags\"\n    sdl_libs=\"$sdl_libs $x11_libs\"\n  fi\n  libs_softmmu=\"$sdl_libs $libs_softmmu\"\nfi\n\n##########################################\n# RDMA needs OpenFabrics libraries\nif test \"$rdma\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <rdma/rdma_cma.h>\nint main(void) { return 0; }\nEOF\n  rdma_libs=\"-lrdmacm -libverbs\"\n  if compile_prog \"\" \"$rdma_libs\" ; then\n    rdma=\"yes\"\n    libs_softmmu=\"$libs_softmmu $rdma_libs\"\n  else\n    if test \"$rdma\" = \"yes\" ; then\n        error_exit \\\n            \" OpenFabrics librdmacm/libibverbs not present.\" \\\n            \" Your options:\" \\\n            \"  (1) Fast: Install infiniband packages from your distro.\" \\\n            \"  (2) Cleanest: Install libraries from www.openfabrics.org\" \\\n            \"  (3) Also: Install softiwarp if you don't have RDMA hardware\"\n    fi\n    rdma=\"no\"\n  fi\nfi\n\n\n##########################################\n# VNC SASL detection\nif test \"$vnc\" = \"yes\" -a \"$vnc_sasl\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <sasl/sasl.h>\n#include <stdio.h>\nint main(void) { sasl_server_init(NULL, \"qemu\"); return 0; }\nEOF\n  # Assuming Cyrus-SASL installed in /usr prefix\n  vnc_sasl_cflags=\"\"\n  vnc_sasl_libs=\"-lsasl2\"\n  if compile_prog \"$vnc_sasl_cflags\" \"$vnc_sasl_libs\" ; then\n    vnc_sasl=yes\n    libs_softmmu=\"$vnc_sasl_libs $libs_softmmu\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $vnc_sasl_cflags\"\n  else\n    if test \"$vnc_sasl\" = \"yes\" ; then\n      feature_not_found \"vnc-sasl\" \"Install Cyrus SASL devel\"\n    fi\n    vnc_sasl=no\n  fi\nfi\n\n##########################################\n# VNC JPEG detection\nif test \"$vnc\" = \"yes\" -a \"$vnc_jpeg\" != \"no\" ; then\ncat > $TMPC <<EOF\n#include <stdio.h>\n#include <jpeglib.h>\nint main(void) { struct jpeg_compress_struct s; jpeg_create_compress(&s); return 0; }\nEOF\n    vnc_jpeg_cflags=\"\"\n    vnc_jpeg_libs=\"-ljpeg\"\n  if compile_prog \"$vnc_jpeg_cflags\" \"$vnc_jpeg_libs\" ; then\n    vnc_jpeg=yes\n    libs_softmmu=\"$vnc_jpeg_libs $libs_softmmu\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $vnc_jpeg_cflags\"\n  else\n    if test \"$vnc_jpeg\" = \"yes\" ; then\n      feature_not_found \"vnc-jpeg\" \"Install libjpeg-turbo devel\"\n    fi\n    vnc_jpeg=no\n  fi\nfi\n\n##########################################\n# VNC PNG detection\nif test \"$vnc\" = \"yes\" -a \"$vnc_png\" != \"no\" ; then\ncat > $TMPC <<EOF\n//#include <stdio.h>\n#include <png.h>\n#include <stddef.h>\nint main(void) {\n    png_structp png_ptr;\n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    return png_ptr != 0;\n}\nEOF\n  if $pkg_config libpng --exists; then\n    vnc_png_cflags=$($pkg_config libpng --cflags)\n    vnc_png_libs=$($pkg_config libpng --libs)\n  else\n    vnc_png_cflags=\"\"\n    vnc_png_libs=\"-lpng\"\n  fi\n  if compile_prog \"$vnc_png_cflags\" \"$vnc_png_libs\" ; then\n    vnc_png=yes\n    libs_softmmu=\"$vnc_png_libs $libs_softmmu\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $vnc_png_cflags\"\n  else\n    if test \"$vnc_png\" = \"yes\" ; then\n      feature_not_found \"vnc-png\" \"Install libpng devel\"\n    fi\n    vnc_png=no\n  fi\nfi\n\n##########################################\n# fnmatch() probe, used for ACL routines\nfnmatch=\"no\"\ncat > $TMPC << EOF\n#include <fnmatch.h>\nint main(void)\n{\n    fnmatch(\"foo\", \"foo\", 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n   fnmatch=\"yes\"\nfi\n\n##########################################\n# xfsctl() probe, used for file-posix.c\nif test \"$xfs\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <stddef.h>  /* NULL */\n#include <xfs/xfs.h>\nint main(void)\n{\n    xfsctl(NULL, 0, 0, NULL);\n    return 0;\n}\nEOF\n  if compile_prog \"\" \"\" ; then\n    xfs=\"yes\"\n  else\n    if test \"$xfs\" = \"yes\" ; then\n      feature_not_found \"xfs\" \"Instal xfsprogs/xfslibs devel\"\n    fi\n    xfs=no\n  fi\nfi\n\n##########################################\n# vde libraries probe\nif test \"$vde\" != \"no\" ; then\n  vde_libs=\"-lvdeplug\"\n  cat > $TMPC << EOF\n#include <libvdeplug.h>\nint main(void)\n{\n    struct vde_open_args a = {0, 0, 0};\n    char s[] = \"\";\n    vde_open(s, s, &a);\n    return 0;\n}\nEOF\n  if compile_prog \"\" \"$vde_libs\" ; then\n    vde=yes\n    libs_softmmu=\"$vde_libs $libs_softmmu\"\n    libs_tools=\"$vde_libs $libs_tools\"\n  else\n    if test \"$vde\" = \"yes\" ; then\n      feature_not_found \"vde\" \"Install vde (Virtual Distributed Ethernet) devel\"\n    fi\n    vde=no\n  fi\nfi\n\n##########################################\n# netmap support probe\n# Apart from looking for netmap headers, we make sure that the host API version\n# supports the netmap backend (>=11). The upper bound (15) is meant to simulate\n# a minor/major version number. Minor new features will be marked with values up\n# to 15, and if something happens that requires a change to the backend we will\n# move above 15, submit the backend fixes and modify this two bounds.\nif test \"$netmap\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <inttypes.h>\n#include <net/if.h>\n#include <net/netmap.h>\n#include <net/netmap_user.h>\n#if (NETMAP_API < 11) || (NETMAP_API > 15)\n#error\n#endif\nint main(void) { return 0; }\nEOF\n  if compile_prog \"\" \"\" ; then\n    netmap=yes\n  else\n    if test \"$netmap\" = \"yes\" ; then\n      feature_not_found \"netmap\"\n    fi\n    netmap=no\n  fi\nfi\n\n##########################################\n# libcap-ng library probe\nif test \"$cap_ng\" != \"no\" ; then\n  cap_libs=\"-lcap-ng\"\n  cat > $TMPC << EOF\n#include <cap-ng.h>\nint main(void)\n{\n    capng_capability_to_name(CAPNG_EFFECTIVE);\n    return 0;\n}\nEOF\n  if compile_prog \"\" \"$cap_libs\" ; then\n    cap_ng=yes\n    libs_tools=\"$cap_libs $libs_tools\"\n  else\n    if test \"$cap_ng\" = \"yes\" ; then\n      feature_not_found \"cap_ng\" \"Install libcap-ng devel\"\n    fi\n    cap_ng=no\n  fi\nfi\n\n##########################################\n# Sound support libraries probe\n\naudio_drv_probe()\n{\n    drv=$1\n    hdr=$2\n    lib=$3\n    exp=$4\n    cfl=$5\n        cat > $TMPC << EOF\n#include <$hdr>\nint main(void) { $exp }\nEOF\n    if compile_prog \"$cfl\" \"$lib\" ; then\n        :\n    else\n        error_exit \"$drv check failed\" \\\n            \"Make sure to have the $drv libs and headers installed.\"\n    fi\n}\n\naudio_drv_list=$(echo \"$audio_drv_list\" | sed -e 's/,/ /g')\nfor drv in $audio_drv_list; do\n    case $drv in\n    alsa)\n    audio_drv_probe $drv alsa/asoundlib.h -lasound \\\n        \"return snd_pcm_close((snd_pcm_t *)0);\"\n    libs_softmmu=\"-lasound $libs_softmmu\"\n    ;;\n\n    pa)\n    audio_drv_probe $drv pulse/pulseaudio.h \"-lpulse\" \\\n        \"pa_context_set_source_output_volume(NULL, 0, NULL, NULL, NULL); return 0;\"\n    libs_softmmu=\"-lpulse $libs_softmmu\"\n    audio_pt_int=\"yes\"\n    ;;\n\n    sdl)\n    if test \"$sdl\" = \"no\"; then\n        error_exit \"sdl not found or disabled, can not use sdl audio driver\"\n    fi\n    ;;\n\n    coreaudio)\n      libs_softmmu=\"-framework CoreAudio $libs_softmmu\"\n    ;;\n\n    dsound)\n      libs_softmmu=\"-lole32 -ldxguid $libs_softmmu\"\n      audio_win_int=\"yes\"\n    ;;\n\n    oss)\n      libs_softmmu=\"$oss_lib $libs_softmmu\"\n    ;;\n\n    wav)\n    # XXX: Probes for CoreAudio, DirectSound\n    ;;\n\n    *)\n    echo \"$audio_possible_drivers\" | grep -q \"\\<$drv\\>\" || {\n        error_exit \"Unknown driver '$drv' selected\" \\\n            \"Possible drivers are: $audio_possible_drivers\"\n    }\n    ;;\n    esac\ndone\n\n##########################################\n# BrlAPI probe\n\nif test \"$brlapi\" != \"no\" ; then\n  brlapi_libs=\"-lbrlapi\"\n  cat > $TMPC << EOF\n#include <brlapi.h>\n#include <stddef.h>\nint main( void ) { return brlapi__openConnection (NULL, NULL, NULL); }\nEOF\n  if compile_prog \"\" \"$brlapi_libs\" ; then\n    brlapi=yes\n    libs_softmmu=\"$brlapi_libs $libs_softmmu\"\n  else\n    if test \"$brlapi\" = \"yes\" ; then\n      feature_not_found \"brlapi\" \"Install brlapi devel\"\n    fi\n    brlapi=no\n  fi\nfi\n\n##########################################\n# curses probe\nif test \"$curses\" != \"no\" ; then\n  if test \"$mingw32\" = \"yes\" ; then\n    curses_inc_list=\"$($pkg_config --cflags ncurses 2>/dev/null):\"\n    curses_lib_list=\"$($pkg_config --libs ncurses 2>/dev/null):-lpdcurses\"\n  else\n    curses_inc_list=\"$($pkg_config --cflags ncursesw 2>/dev/null):-I/usr/include/ncursesw:\"\n    curses_lib_list=\"$($pkg_config --libs ncursesw 2>/dev/null):-lncursesw:-lcursesw\"\n  fi\n  curses_found=no\n  cat > $TMPC << EOF\n#include <locale.h>\n#include <curses.h>\n#include <wchar.h>\nint main(void) {\n  wchar_t wch = L'w';\n  setlocale(LC_ALL, \"\");\n  resize_term(0, 0);\n  addwstr(L\"wide chars\\n\");\n  addnwstr(&wch, 1);\n  add_wch(WACS_DEGREE);\n  return 0;\n}\nEOF\n  IFS=:\n  for curses_inc in $curses_inc_list; do\n    # Make sure we get the wide character prototypes\n    curses_inc=\"-DNCURSES_WIDECHAR $curses_inc\"\n    IFS=:\n    for curses_lib in $curses_lib_list; do\n      unset IFS\n      if compile_prog \"$curses_inc\" \"$curses_lib\" ; then\n        curses_found=yes\n        QEMU_CFLAGS=\"$curses_inc $QEMU_CFLAGS\"\n        libs_softmmu=\"$curses_lib $libs_softmmu\"\n        break\n      fi\n    done\n    if test \"$curses_found\" = yes ; then\n      break\n    fi\n  done\n  unset IFS\n  if test \"$curses_found\" = \"yes\" ; then\n    curses=yes\n  else\n    if test \"$curses\" = \"yes\" ; then\n      feature_not_found \"curses\" \"Install ncurses devel\"\n    fi\n    curses=no\n  fi\nfi\n\n##########################################\n# curl probe\nif test \"$curl\" != \"no\" ; then\n  if $pkg_config libcurl --exists; then\n    curlconfig=\"$pkg_config libcurl\"\n  else\n    curlconfig=curl-config\n  fi\n  cat > $TMPC << EOF\n#include <curl/curl.h>\nint main(void) { curl_easy_init(); curl_multi_setopt(0, 0, 0); return 0; }\nEOF\n  curl_cflags=$($curlconfig --cflags 2>/dev/null)\n  curl_libs=$($curlconfig --libs 2>/dev/null)\n  if compile_prog \"$curl_cflags\" \"$curl_libs\" ; then\n    curl=yes\n  else\n    if test \"$curl\" = \"yes\" ; then\n      feature_not_found \"curl\" \"Install libcurl devel\"\n    fi\n    curl=no\n  fi\nfi # test \"$curl\"\n\n##########################################\n# bluez support probe\nif test \"$bluez\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <bluetooth/bluetooth.h>\nint main(void) { return bt_error(0); }\nEOF\n  bluez_cflags=$($pkg_config --cflags bluez 2>/dev/null)\n  bluez_libs=$($pkg_config --libs bluez 2>/dev/null)\n  if compile_prog \"$bluez_cflags\" \"$bluez_libs\" ; then\n    bluez=yes\n    libs_softmmu=\"$bluez_libs $libs_softmmu\"\n  else\n    if test \"$bluez\" = \"yes\" ; then\n      feature_not_found \"bluez\" \"Install bluez-libs/libbluetooth devel\"\n    fi\n    bluez=\"no\"\n  fi\nfi\n\n##########################################\n# glib support probe\n\nif test \"$mingw32\" = yes; then\n    glib_req_ver=2.30\nelse\n    glib_req_ver=2.22\nfi\nglib_modules=gthread-2.0\nif test \"$modules\" = yes; then\n    glib_modules=\"$glib_modules gmodule-2.0\"\nfi\n\n# This workaround is required due to a bug in pkg-config file for glib as it\n# doesn't define GLIB_STATIC_COMPILATION for pkg-config --static\n\nif test \"$static\" = yes -a \"$mingw32\" = yes; then\n    QEMU_CFLAGS=\"-DGLIB_STATIC_COMPILATION $QEMU_CFLAGS\"\nfi\n\nfor i in $glib_modules; do\n    if $pkg_config --atleast-version=$glib_req_ver $i; then\n        glib_cflags=$($pkg_config --cflags $i)\n        glib_libs=$($pkg_config --libs $i)\n        QEMU_CFLAGS=\"$glib_cflags $QEMU_CFLAGS\"\n        LIBS=\"$glib_libs $LIBS\"\n        libs_qga=\"$glib_libs $libs_qga\"\n    else\n        error_exit \"glib-$glib_req_ver $i is required to compile QEMU\"\n    fi\ndone\n\n# Sanity check that the current size_t matches the\n# size that glib thinks it should be. This catches\n# problems on multi-arch where people try to build\n# 32-bit QEMU while pointing at 64-bit glib headers\ncat > $TMPC <<EOF\n#include <glib.h>\n#include <unistd.h>\n\n#define QEMU_BUILD_BUG_ON(x) \\\n  typedef char qemu_build_bug_on[(x)?-1:1] __attribute__((unused));\n\nint main(void) {\n   QEMU_BUILD_BUG_ON(sizeof(size_t) != GLIB_SIZEOF_SIZE_T);\n   return 0;\n}\nEOF\n\nif ! compile_prog \"$CFLAGS\" \"$LIBS\" ; then\n    error_exit \"sizeof(size_t) doesn't match GLIB_SIZEOF_SIZE_T.\"\\\n               \"You probably need to set PKG_CONFIG_LIBDIR\"\\\n\t       \"to point to the right pkg-config files for your\"\\\n\t       \"build target\"\nfi\n\n# g_test_trap_subprocess added in 2.38. Used by some tests.\nglib_subprocess=yes\nif ! $pkg_config --atleast-version=2.38 glib-2.0; then\n    glib_subprocess=no\nfi\n\n# Silence clang 3.5.0 warnings about glib attribute __alloc_size__ usage\ncat > $TMPC << EOF\n#include <glib.h>\nint main(void) { return 0; }\nEOF\nif ! compile_prog \"$glib_cflags -Werror\" \"$glib_libs\" ; then\n    if cc_has_warning_flag \"-Wno-unknown-attributes\"; then\n        glib_cflags=\"-Wno-unknown-attributes $glib_cflags\"\n        CFLAGS=\"-Wno-unknown-attributes $CFLAGS\"\n    fi\nfi\n\n##########################################\n# libarchive support probe\nif $pkg_config --modversion libarchive > /dev/null 2>&1 ; then\n    archive_libs=`$pkg_config --libs libarchive`\n    LIBS=\"$archive_libs $LIBS\"\nelse\n    echo \"libarchive is required to compile PANDA\"\n    exit 1\nfi\n\n##########################################\n# openssl support probe\nif $pkg_config --modversion libssl > /dev/null 2>&1; then\n    if $pkg_config --modversion libcrypto > /dev/null 2>&1; then\n        ssl_libs=`$pkg_config --libs libssl libcrypto`\n        LIBS=\"$ssl_libs $LIBS\"\n    else\n        echo \"libcrypto is required to compile PANDA\"\n        exit1\n    fi\nelse\n    echo \"libssl (openssl) is required to compile PANDA\"\n    exit 1\nfi\n\n##########################################\n# SHA command probe for modules\nif test \"$modules\" = yes; then\n    shacmd_probe=\"sha1sum sha1 shasum\"\n    for c in $shacmd_probe; do\n        if has $c; then\n            shacmd=\"$c\"\n            break\n        fi\n    done\n    if test \"$shacmd\" = \"\"; then\n        error_exit \"one of the checksum commands is required to enable modules: $shacmd_probe\"\n    fi\nfi\n\n##########################################\n# pixman support probe\n\nif test \"$pixman\" = \"\"; then\n  if test \"$want_tools\" = \"no\" -a \"$softmmu\" = \"no\"; then\n    pixman=\"none\"\n  elif $pkg_config --atleast-version=0.21.8 pixman-1 > /dev/null 2>&1; then\n    pixman=\"system\"\n  else\n    pixman=\"internal\"\n  fi\nfi\nif test \"$pixman\" = \"none\"; then\n  if test \"$want_tools\" != \"no\" -o \"$softmmu\" != \"no\"; then\n    error_exit \"pixman disabled but system emulation or tools build\" \\\n        \"enabled.  You can turn off pixman only if you also\" \\\n        \"disable all system emulation targets and the tools\" \\\n        \"build with '--disable-tools --disable-system'.\"\n  fi\n  pixman_cflags=\n  pixman_libs=\nelif test \"$pixman\" = \"system\"; then\n  # pixman version has been checked above\n  pixman_cflags=$($pkg_config --cflags pixman-1)\n  pixman_libs=$($pkg_config --libs pixman-1)\nelse\n  if test ! -d ${source_path}/pixman/pixman; then\n    error_exit \"pixman >= 0.21.8 not present. Your options:\" \\\n        \"  (1) Preferred: Install the pixman devel package (any recent\" \\\n        \"      distro should have packages as Xorg needs pixman too).\" \\\n        \"  (2) Fetch the pixman submodule, using:\" \\\n        \"      git submodule update --init pixman\"\n  fi\n  mkdir -p pixman/pixman\n  pixman_cflags=\"-I\\$(SRC_PATH)/pixman/pixman -I\\$(BUILD_DIR)/pixman/pixman\"\n  pixman_libs=\"-L\\$(BUILD_DIR)/pixman/pixman/.libs -lpixman-1\"\nfi\n\n##########################################\n# llvm components probe - final test for llvm at the end\n\nif test \"$llvm\" != \"no\" ; then\n  if [ -x \"$llvmdir/bin/llvm-config\" ] ; then\n    : llvm_config found\n    llvm_config=\"$llvmdir/bin/llvm-config\"\n  elif [ -x \"$llvmdir/bin/llvm-config-$llvmver\" ]; then\n    : llvm_config found\n    llvm_config=\"$llvmdir/bin/llvm-config-$llvmver\"\n  elif llvm-config --version >/dev/null 2>&1; then\n    : llvm_config found\n    llvm_config=\"llvm-config\"\n  elif llvm-config-\"$llvmver\" --version >/dev/null 2>&1; then\n    : llvm_config found\n    llvm_config=\"llvm-config-$llvmver\"\n  elif test \"$llvm\" = \"yes\"; then\n    feature_not_found \"llvm-link (required for --enable-llvm)\"\n    exit 1\n  else\n    llvm=\"no\"\n  fi\n  \"$llvm_config\" --version >> config.log 2>&1\nfi\n\nif test \"$llvm\" != \"no\" ; then\n  if [ -x \"$llvmdir/bin/clang\" ]; then\n    : clang found\n    clang=\"$llvmdir/bin/clang\"\n  elif [ -x \"$llvmdir/bin/clang-$llvmver\" ] ; then\n    : clang found\n    clang=\"$llvmdir/bin/clang-$llvmver\"\n  elif clang-\"$llvmver\" --version >/dev/null 2>&1; then\n    : clang found\n    clang=\"clang-$llvmver\"\n  elif clang --version >/dev/null 2>&1; then\n    : clang found\n    clang=\"clang\"\n  elif test \"$llvm\" = \"yes\"; then\n    feature_not_found \"clang (required for --enable-llvm)\"\n    exit 1\n  else\n    llvm=\"no\"\n  fi\n  \"$clang\" --version >> config.log 2>&1\nfi\n\nif test \"$llvm\" != \"no\" ; then\n  if [ -x \"$llvmdir/bin/clang++\" ]; then\n    : clang++ found\n    clangxx=\"$llvmdir/bin/clang++\"\n  elif [ -x \"$llvmdir/bin/clang++-$llvmver\" ] ; then\n    : clang++ found\n    clang=\"$llvmdir/bin/clang++-$llvmver\"\n  elif clang++ --version >/dev/null 2>&1; then\n    : clang++ found\n    clangxx=\"clang++\"\n  elif clang++-\"$llvmver\" --version >/dev/null 2>&1; then\n    : clang++ found\n    clangxx=\"clang++-$llvmver\"\n  elif test \"$llvm\" = \"yes\"; then\n    feature_not_found \"clang++ (required for --enable-llvm)\"\n    exit 1\n  else\n    llvm=\"no\"\n  fi\n  \"$clangxx\" --version >> config.log 2>&1\nfi\n\nif test \"$llvm\" != \"no\" ; then\n  if [ -x \"$llvmdir/bin/llvm-link\" ] ; then\n    : llvm_link found\n    llvm_link=\"$llvmdir/bin/llvm-link\"\n  elif [ -x \"$llvmdir/bin/llvm-link-$llvmver\" ] ; then\n    : llvm_link found\n    llvm_link=\"$llvmdir/bin/llvm-link-$llvmver\"\n  elif llvm-link --version >/dev/null 2>&1; then\n    : llvm_link found\n    llvm_link=\"llvm-link\"\n  elif llvm-link-\"$llvmver\" --version >/dev/null 2>&1; then\n    : llvm_link found\n    llvm_link=\"llvm-link-$llvmver\"\n  elif test \"$llvm\" = \"yes\"; then\n    feature_not_found \"llvm-link (required for --enable-llvm)\"\n    exit 1\n  else\n    llvm=\"no\"\n  fi\nfi\n\n##########################################\n# pycparser probe\n\nif ! $python <<EOF\nimport sys\nimport pycparser\nversion = [int(x) for x in pycparser.__version__.split(\".\")]\nif version[0] < 2 or (version[0] == 2 and version[1] < 10):\n  sys.exit(1)\nelse:\n  sys.exit(0)\nEOF\nthen\n  feature_not_found \"pycparser (required for PANDA plugin APIs)\"\nfi\n\n##########################################\n# libcap probe\n\nif test \"$cap\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <stdio.h>\n#include <sys/capability.h>\nint main(void) { cap_t caps; caps = cap_init(); return caps != NULL; }\nEOF\n  if compile_prog \"\" \"-lcap\" ; then\n    cap=yes\n  else\n    cap=no\n  fi\nfi\n\n##########################################\n# pthread probe\nPTHREADLIBS_LIST=\"-pthread -lpthread -lpthreadGC2\"\n\npthread=no\ncat > $TMPC << EOF\n#include <pthread.h>\nstatic void *f(void *p) { return NULL; }\nint main(void) {\n  pthread_t thread;\n  pthread_create(&thread, 0, f, 0);\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  pthread=yes\nelse\n  for pthread_lib in $PTHREADLIBS_LIST; do\n    if compile_prog \"\" \"$pthread_lib\" ; then\n      pthread=yes\n      found=no\n      for lib_entry in $LIBS; do\n        if test \"$lib_entry\" = \"$pthread_lib\"; then\n          found=yes\n          break\n        fi\n      done\n      if test \"$found\" = \"no\"; then\n        LIBS=\"$pthread_lib $LIBS\"\n      fi\n      PTHREAD_LIB=\"$pthread_lib\"\n      break\n    fi\n  done\nfi\n\nif test \"$mingw32\" != yes -a \"$pthread\" = no; then\n  error_exit \"pthread check failed\" \\\n      \"Make sure to have the pthread libs and headers installed.\"\nfi\n\n# check for pthread_setname_np\npthread_setname_np=no\ncat > $TMPC << EOF\n#include <pthread.h>\n\nstatic void *f(void *p) { return NULL; }\nint main(void)\n{\n    pthread_t thread;\n    pthread_create(&thread, 0, f, 0);\n    pthread_setname_np(thread, \"QEMU\");\n    return 0;\n}\nEOF\nif compile_prog \"\" \"$pthread_lib\" ; then\n  pthread_setname_np=yes\nfi\n\n##########################################\n# rbd probe\nif test \"$rbd\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <stdio.h>\n#include <rbd/librbd.h>\nint main(void) {\n    rados_t cluster;\n    rados_create(&cluster, NULL);\n    return 0;\n}\nEOF\n  rbd_libs=\"-lrbd -lrados\"\n  if compile_prog \"\" \"$rbd_libs\" ; then\n    rbd=yes\n  else\n    if test \"$rbd\" = \"yes\" ; then\n      feature_not_found \"rados block device\" \"Install librbd/ceph devel\"\n    fi\n    rbd=no\n  fi\nfi\n\n##########################################\n# libssh2 probe\nmin_libssh2_version=1.2.8\nif test \"$libssh2\" != \"no\" ; then\n  if $pkg_config --atleast-version=$min_libssh2_version libssh2; then\n    libssh2_cflags=$($pkg_config libssh2 --cflags)\n    libssh2_libs=$($pkg_config libssh2 --libs)\n    libssh2=yes\n  else\n    if test \"$libssh2\" = \"yes\" ; then\n      error_exit \"libssh2 >= $min_libssh2_version required for --enable-libssh2\"\n    fi\n    libssh2=no\n  fi\nfi\n\n##########################################\n# libssh2_sftp_fsync probe\n\nif test \"$libssh2\" = \"yes\"; then\n  cat > $TMPC <<EOF\n#include <stdio.h>\n#include <libssh2.h>\n#include <libssh2_sftp.h>\nint main(void) {\n    LIBSSH2_SESSION *session;\n    LIBSSH2_SFTP *sftp;\n    LIBSSH2_SFTP_HANDLE *sftp_handle;\n    session = libssh2_session_init ();\n    sftp = libssh2_sftp_init (session);\n    sftp_handle = libssh2_sftp_open (sftp, \"/\", 0, 0);\n    libssh2_sftp_fsync (sftp_handle);\n    return 0;\n}\nEOF\n  # libssh2_cflags/libssh2_libs defined in previous test.\n  if compile_prog \"$libssh2_cflags\" \"$libssh2_libs\" ; then\n    QEMU_CFLAGS=\"-DHAS_LIBSSH2_SFTP_FSYNC $QEMU_CFLAGS\"\n  fi\nfi\n\n##########################################\n# linux-aio probe\n\nif test \"$linux_aio\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <libaio.h>\n#include <sys/eventfd.h>\n#include <stddef.h>\nint main(void) { io_setup(0, NULL); io_set_eventfd(NULL, 0); eventfd(0, 0); return 0; }\nEOF\n  if compile_prog \"\" \"-laio\" ; then\n    linux_aio=yes\n  else\n    if test \"$linux_aio\" = \"yes\" ; then\n      feature_not_found \"linux AIO\" \"Install libaio devel\"\n    fi\n    linux_aio=no\n  fi\nfi\n\n##########################################\n# TPM passthrough is only on x86 Linux\n\nif test \"$targetos\" = Linux && test \"$cpu\" = i386 -o \"$cpu\" = x86_64; then\n  tpm_passthrough=$tpm\nelse\n  tpm_passthrough=no\nfi\n\n##########################################\n# attr probe\n\nif test \"$attr\" != \"no\" ; then\n  cat > $TMPC <<EOF\n#include <stdio.h>\n#include <sys/types.h>\n#ifdef CONFIG_LIBATTR\n#include <attr/xattr.h>\n#else\n#include <sys/xattr.h>\n#endif\nint main(void) { getxattr(NULL, NULL, NULL, 0); setxattr(NULL, NULL, NULL, 0, 0); return 0; }\nEOF\n  if compile_prog \"\" \"\" ; then\n    attr=yes\n  # Older distros have <attr/xattr.h>, and need -lattr:\n  elif compile_prog \"-DCONFIG_LIBATTR\" \"-lattr\" ; then\n    attr=yes\n    LIBS=\"-lattr $LIBS\"\n    libattr=yes\n  else\n    if test \"$attr\" = \"yes\" ; then\n      feature_not_found \"ATTR\" \"Install libc6 or libattr devel\"\n    fi\n    attr=no\n  fi\nfi\n\n##########################################\n# iovec probe\ncat > $TMPC <<EOF\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\nint main(void) { return sizeof(struct iovec); }\nEOF\niovec=no\nif compile_prog \"\" \"\" ; then\n  iovec=yes\nfi\n\n##########################################\n# preadv probe\ncat > $TMPC <<EOF\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\nint main(void) { return preadv(0, 0, 0, 0); }\nEOF\npreadv=no\nif compile_prog \"\" \"\" ; then\n  preadv=yes\nfi\n\n##########################################\n# fdt probe\n# fdt support is mandatory for at least some target architectures,\n# so insist on it if we're building those system emulators.\nfdt_required=no\nfor target in $target_list; do\n  case $target in\n    aarch64*-softmmu|arm*-softmmu|ppc*-softmmu|microblaze*-softmmu|mips64el-softmmu)\n      fdt_required=yes\n    ;;\n  esac\ndone\n\nif test \"$fdt_required\" = \"yes\"; then\n  if test \"$fdt\" = \"no\"; then\n    error_exit \"fdt disabled but some requested targets require it.\" \\\n      \"You can turn off fdt only if you also disable all the system emulation\" \\\n      \"targets which need it (by specifying a cut down --target-list).\"\n  fi\n  fdt=yes\nfi\n\nif test \"$fdt\" != \"no\" ; then\n  fdt_libs=\"-lfdt\"\n  # explicitly check for libfdt_env.h as it is missing in some stable installs\n  # and test for required functions to make sure we are on a version >= 1.4.2\n  cat > $TMPC << EOF\n#include <libfdt.h>\n#include <libfdt_env.h>\nint main(void) { fdt_first_subnode(0, 0); return 0; }\nEOF\n  if compile_prog \"\" \"$fdt_libs\" ; then\n    # system DTC is good - use it\n    fdt=yes\n  else\n      # have GIT checkout, so activate dtc submodule\n      if test -e \"${source_path}/.git\" ; then\n          git_submodules=\"${git_submodules} dtc\"\n      fi\n      if test -d \"${source_path}/dtc/libfdt\" || test -e \"${source_path}/.git\" ; then\n          fdt=yes\n          dtc_internal=\"yes\"\n          mkdir -p dtc\n          if [ \"$pwd_is_source_path\" != \"y\" ] ; then\n              symlink \"$source_path/dtc/Makefile\" \"dtc/Makefile\"\n              symlink \"$source_path/dtc/scripts\" \"dtc/scripts\"\n          fi\n          fdt_cflags=\"-I\\$(SRC_PATH)/dtc/libfdt\"\n          fdt_ldflags=\"-L\\$(BUILD_DIR)/dtc/libfdt\"\n          fdt_libs=\"$fdt_libs\"\n      elif test \"$fdt\" = \"yes\" ; then\n          # Not a git build & no libfdt found, prompt for system install\n          error_exit \"DTC (libfdt) version >= 1.4.2 not present.\" \\\n                     \"Please install the DTC (libfdt) devel package\"\n      else\n          # don't have and don't want\n          fdt_libs=\n          fdt=no\n      fi\n  fi\nfi\n\nlibs_softmmu=\"$libs_softmmu $fdt_libs\"\n\n##########################################\n# opengl probe (for sdl2, gtk, milkymist-tmu2)\n\nif test \"$opengl\" != \"no\" ; then\n  opengl_pkgs=\"epoxy libdrm gbm\"\n  if $pkg_config $opengl_pkgs x11; then\n    opengl_cflags=\"$($pkg_config --cflags $opengl_pkgs) $x11_cflags\"\n    opengl_libs=\"$($pkg_config --libs $opengl_pkgs) $x11_libs\"\n    opengl=yes\n    if test \"$gtk\" = \"yes\" && $pkg_config --exists \"$gtkpackage >= 3.16\"; then\n        gtk_gl=\"yes\"\n    fi\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $opengl_cflags\"\n  else\n    if test \"$opengl\" = \"yes\" ; then\n      feature_not_found \"opengl\" \"Please install opengl (mesa) devel pkgs: $opengl_pkgs\"\n    fi\n    opengl_cflags=\"\"\n    opengl_libs=\"\"\n    opengl=no\n  fi\nfi\n\nif test \"$opengl\" = \"yes\"; then\n  cat > $TMPC << EOF\n#include <epoxy/egl.h>\n#ifndef EGL_MESA_image_dma_buf_export\n# error mesa/epoxy lacks support for dmabufs (mesa 10.6+)\n#endif\nint main(void) { return 0; }\nEOF\n  if compile_prog \"\" \"\" ; then\n    opengl_dmabuf=yes\n  fi\nfi\n\n\n##########################################\n# glusterfs probe\nif test \"$glusterfs\" != \"no\" ; then\n  if $pkg_config --atleast-version=3 glusterfs-api; then\n    glusterfs=\"yes\"\n    glusterfs_cflags=$($pkg_config --cflags glusterfs-api)\n    glusterfs_libs=$($pkg_config --libs glusterfs-api)\n    if $pkg_config --atleast-version=4 glusterfs-api; then\n      glusterfs_xlator_opt=\"yes\"\n    fi\n    if $pkg_config --atleast-version=5 glusterfs-api; then\n      glusterfs_discard=\"yes\"\n    fi\n    if $pkg_config --atleast-version=6 glusterfs-api; then\n      glusterfs_zerofill=\"yes\"\n    fi\n    cat > $TMPC << EOF\n#include <glusterfs/api/glfs.h>\n\nint\nmain(void)\n{\n\t/* new glfs_ftruncate() passes two additional args */\n\treturn glfs_ftruncate(NULL, 0, NULL, NULL);\n}\nEOF\n    if compile_prog \"$glusterfs_cflags\" \"$glusterfs_libs\" ; then\n      glusterfs_ftruncate_has_stat=\"yes\"\n    fi\n    cat > $TMPC << EOF\n#include <glusterfs/api/glfs.h>\n\n/* new glfs_io_cbk() passes two additional glfs_stat structs */\nstatic void\nglusterfs_iocb(glfs_fd_t *fd, ssize_t ret, struct glfs_stat *prestat, struct glfs_stat *poststat, void *data)\n{}\n\nint\nmain(void)\n{\n\tglfs_io_cbk iocb = &glusterfs_iocb;\n\tiocb(NULL, 0 , NULL, NULL, NULL);\n\treturn 0;\n}\nEOF\n    if compile_prog \"$glusterfs_cflags\" \"$glusterfs_libs\" ; then\n      glusterfs_iocb_has_stat=\"yes\"\n    fi\n  else\n    if test \"$glusterfs\" = \"yes\" ; then\n      feature_not_found \"GlusterFS backend support\" \\\n          \"Install glusterfs-api devel >= 3\"\n    fi\n    glusterfs=\"no\"\n  fi\nfi\n\n# Check for inotify functions when we are building linux-user\n# emulator.  This is done because older glibc versions don't\n# have syscall stubs for these implemented.  In that case we\n# don't provide them even if kernel supports them.\n#\ninotify=no\ncat > $TMPC << EOF\n#include <sys/inotify.h>\n\nint\nmain(void)\n{\n\t/* try to start inotify */\n\treturn inotify_init();\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  inotify=yes\nfi\n\ninotify1=no\ncat > $TMPC << EOF\n#include <sys/inotify.h>\n\nint\nmain(void)\n{\n    /* try to start inotify */\n    return inotify_init1(0);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  inotify1=yes\nfi\n\n# check if utimensat and futimens are supported\nutimens=no\ncat > $TMPC << EOF\n#define _ATFILE_SOURCE\n#include <stddef.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\nint main(void)\n{\n    utimensat(AT_FDCWD, \"foo\", NULL, 0);\n    futimens(0, NULL);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  utimens=yes\nfi\n\n# check if pipe2 is there\npipe2=no\ncat > $TMPC << EOF\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(void)\n{\n    int pipefd[2];\n    return pipe2(pipefd, O_CLOEXEC);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  pipe2=yes\nfi\n\n# check if accept4 is there\naccept4=no\ncat > $TMPC << EOF\n#include <sys/socket.h>\n#include <stddef.h>\n\nint main(void)\n{\n    accept4(0, NULL, NULL, SOCK_CLOEXEC);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  accept4=yes\nfi\n\n# check if tee/splice is there. vmsplice was added same time.\nsplice=no\ncat > $TMPC << EOF\n#include <unistd.h>\n#include <fcntl.h>\n#include <limits.h>\n\nint main(void)\n{\n    int len, fd = 0;\n    len = tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX, SPLICE_F_NONBLOCK);\n    splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  splice=yes\nfi\n\n##########################################\n# libnuma probe\n\nif test \"$numa\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <numa.h>\nint main(void) { return numa_available(); }\nEOF\n\n  if compile_prog \"\" \"-lnuma\" ; then\n    numa=yes\n    libs_softmmu=\"-lnuma $libs_softmmu\"\n  else\n    if test \"$numa\" = \"yes\" ; then\n      feature_not_found \"numa\" \"install numactl devel\"\n    fi\n    numa=no\n  fi\nfi\n\nif test \"$tcmalloc\" = \"yes\" && test \"$jemalloc\" = \"yes\" ; then\n    echo \"ERROR: tcmalloc && jemalloc can't be used at the same time\"\n    exit 1\nfi\n\n##########################################\n# tcmalloc probe\n\nif test \"$tcmalloc\" = \"yes\" ; then\n  cat > $TMPC << EOF\n#include <stdlib.h>\nint main(void) { malloc(1); return 0; }\nEOF\n\n  if compile_prog \"\" \"-ltcmalloc\" ; then\n    LIBS=\"-ltcmalloc $LIBS\"\n  else\n    feature_not_found \"tcmalloc\" \"install gperftools devel\"\n  fi\nfi\n\n##########################################\n# jemalloc probe\n\nif test \"$jemalloc\" = \"yes\" ; then\n  cat > $TMPC << EOF\n#include <stdlib.h>\nint main(void) { malloc(1); return 0; }\nEOF\n\n  if compile_prog \"\" \"-ljemalloc\" ; then\n    LIBS=\"-ljemalloc $LIBS\"\n  else\n    feature_not_found \"jemalloc\" \"install jemalloc devel\"\n  fi\nfi\n\n##########################################\n# signalfd probe\nsignalfd=\"no\"\ncat > $TMPC << EOF\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <signal.h>\nint main(void) { return syscall(SYS_signalfd, -1, NULL, _NSIG / 8); }\nEOF\n\nif compile_prog \"\" \"\" ; then\n  signalfd=yes\nfi\n\n# check if eventfd is supported\neventfd=no\ncat > $TMPC << EOF\n#include <sys/eventfd.h>\n\nint main(void)\n{\n    return eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  eventfd=yes\nfi\n\n# check if memfd is supported\nmemfd=no\ncat > $TMPC << EOF\n#include <sys/mman.h>\n\nint main(void)\n{\n    return memfd_create(\"foo\", MFD_ALLOW_SEALING);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  memfd=yes\nfi\n\n\n\n# check for fallocate\nfallocate=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n\nint main(void)\n{\n    fallocate(0, 0, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  fallocate=yes\nfi\n\n# check for fallocate hole punching\nfallocate_punch_hole=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n#include <linux/falloc.h>\n\nint main(void)\n{\n    fallocate(0, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  fallocate_punch_hole=yes\nfi\n\n# check that fallocate supports range zeroing inside the file\nfallocate_zero_range=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n#include <linux/falloc.h>\n\nint main(void)\n{\n    fallocate(0, FALLOC_FL_ZERO_RANGE, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  fallocate_zero_range=yes\nfi\n\n# check for posix_fallocate\nposix_fallocate=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n\nint main(void)\n{\n    posix_fallocate(0, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    posix_fallocate=yes\nfi\n\n# check for sync_file_range\nsync_file_range=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n\nint main(void)\n{\n    sync_file_range(0, 0, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  sync_file_range=yes\nfi\n\n# check for linux/fiemap.h and FS_IOC_FIEMAP\nfiemap=no\ncat > $TMPC << EOF\n#include <sys/ioctl.h>\n#include <linux/fs.h>\n#include <linux/fiemap.h>\n\nint main(void)\n{\n    ioctl(0, FS_IOC_FIEMAP, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  fiemap=yes\nfi\n\n# check for dup3\ndup3=no\ncat > $TMPC << EOF\n#include <unistd.h>\n\nint main(void)\n{\n    dup3(0, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  dup3=yes\nfi\n\n# check for ppoll support\nppoll=no\ncat > $TMPC << EOF\n#include <poll.h>\n\nint main(void)\n{\n    struct pollfd pfd = { .fd = 0, .events = 0, .revents = 0 };\n    ppoll(&pfd, 1, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  ppoll=yes\nfi\n\n# check for prctl(PR_SET_TIMERSLACK , ... ) support\nprctl_pr_set_timerslack=no\ncat > $TMPC << EOF\n#include <sys/prctl.h>\n\nint main(void)\n{\n    prctl(PR_SET_TIMERSLACK, 1, 0, 0, 0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  prctl_pr_set_timerslack=yes\nfi\n\n# check for epoll support\nepoll=no\ncat > $TMPC << EOF\n#include <sys/epoll.h>\n\nint main(void)\n{\n    epoll_create(0);\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  epoll=yes\nfi\n\n# epoll_create1 is a later addition\n# so we must check separately for its presence\nepoll_create1=no\ncat > $TMPC << EOF\n#include <sys/epoll.h>\n\nint main(void)\n{\n    /* Note that we use epoll_create1 as a value, not as\n     * a function being called. This is necessary so that on\n     * old SPARC glibc versions where the function was present in\n     * the library but not declared in the header file we will\n     * fail the configure check. (Otherwise we will get a compiler\n     * warning but not an error, and will proceed to fail the\n     * qemu compile where we compile with -Werror.)\n     */\n    return (int)(uintptr_t)&epoll_create1;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  epoll_create1=yes\nfi\n\n# check for sendfile support\nsendfile=no\ncat > $TMPC << EOF\n#include <sys/sendfile.h>\n\nint main(void)\n{\n    return sendfile(0, 0, 0, 0);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  sendfile=yes\nfi\n\n# check for timerfd support (glibc 2.8 and newer)\ntimerfd=no\ncat > $TMPC << EOF\n#include <sys/timerfd.h>\n\nint main(void)\n{\n    return(timerfd_create(CLOCK_REALTIME, 0));\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  timerfd=yes\nfi\n\n# check for setns and unshare support\nsetns=no\ncat > $TMPC << EOF\n#include <sched.h>\n\nint main(void)\n{\n    int ret;\n    ret = setns(0, 0);\n    ret = unshare(0);\n    return ret;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  setns=yes\nfi\n\n# clock_adjtime probe\nclock_adjtime=no\ncat > $TMPC <<EOF\n#include <time.h>\n\nint main(void)\n{\n    return clock_adjtime(0, 0);\n}\nEOF\nclock_adjtime=no\nif compile_prog \"\" \"\" ; then\n  clock_adjtime=yes\nfi\n\n# syncfs probe\nsyncfs=no\ncat > $TMPC <<EOF\n#include <unistd.h>\n\nint main(void)\n{\n    return syncfs(0);\n}\nEOF\nsyncfs=no\nif compile_prog \"\" \"\" ; then\n  syncfs=yes\nfi\n\n# Check if tools are available to build documentation.\nif test \"$docs\" != \"no\" ; then\n  if has makeinfo && has pod2man; then\n    docs=yes\n  else\n    if test \"$docs\" = \"yes\" ; then\n      feature_not_found \"docs\" \"Install texinfo and Perl/perl-podlators\"\n    fi\n    docs=no\n  fi\nfi\n\n# Search for bswap_32 function\nbyteswap_h=no\ncat > $TMPC << EOF\n#include <byteswap.h>\nint main(void) { return bswap_32(0); }\nEOF\nif compile_prog \"\" \"\" ; then\n    # disabling bc this breaks our llvm\n    # byteswap_h=yes\n    true\nfi\n\n# Search for bswap32 function\nbswap_h=no\ncat > $TMPC << EOF\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <machine/bswap.h>\nint main(void) { return bswap32(0); }\nEOF\nif compile_prog \"\" \"\" ; then\n    # disabling bc this breaks our llvm\n    # bswap_h=no\n    true\nfi\n\n##########################################\n# Do we have libiscsi >= 1.9.0\nif test \"$libiscsi\" != \"no\" ; then\n  if $pkg_config --atleast-version=1.9.0 libiscsi; then\n    libiscsi=\"yes\"\n    libiscsi_cflags=$($pkg_config --cflags libiscsi)\n    libiscsi_libs=$($pkg_config --libs libiscsi)\n  else\n    if test \"$libiscsi\" = \"yes\" ; then\n      feature_not_found \"libiscsi\" \"Install libiscsi >= 1.9.0\"\n    fi\n    libiscsi=\"no\"\n  fi\nfi\n\n##########################################\n# Do we need libm\ncat > $TMPC << EOF\n#include <math.h>\nint main(int argc, char **argv) { return isnan(sin((double)argc)); }\nEOF\nif compile_prog \"\" \"\" ; then\n  :\nelif compile_prog \"\" \"-lm\" ; then\n  LIBS=\"-lm $LIBS\"\n  libs_qga=\"-lm $libs_qga\"\nelse\n  error_exit \"libm check failed\"\nfi\n\n##########################################\n# Do we need librt\n# uClibc provides 2 versions of clock_gettime(), one with realtime\n# support and one without. This means that the clock_gettime() don't\n# need -lrt. We still need it for timer_create() so we check for this\n# function in addition.\ncat > $TMPC <<EOF\n#include <signal.h>\n#include <time.h>\nint main(void) {\n  timer_create(CLOCK_REALTIME, NULL, NULL);\n  return clock_gettime(CLOCK_REALTIME, NULL);\n}\nEOF\n\nif compile_prog \"\" \"\" ; then\n  :\n# we need pthread for static linking. use previous pthread test result\nelif compile_prog \"\" \"$pthread_lib -lrt\" ; then\n  LIBS=\"$LIBS -lrt\"\n  libs_qga=\"$libs_qga -lrt\"\nfi\n\nif test \"$darwin\" != \"yes\" -a \"$mingw32\" != \"yes\" -a \"$solaris\" != yes -a \\\n        \"$haiku\" != \"yes\" ; then\n    libs_softmmu=\"-lutil $libs_softmmu\"\nfi\n\n##########################################\n# spice probe\nif test \"$spice\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <spice.h>\nint main(void) { spice_server_new(); return 0; }\nEOF\n  spice_cflags=$($pkg_config --cflags spice-protocol spice-server 2>/dev/null)\n  spice_libs=$($pkg_config --libs spice-protocol spice-server 2>/dev/null)\n  if $pkg_config --atleast-version=0.12.0 spice-server && \\\n     $pkg_config --atleast-version=0.12.3 spice-protocol && \\\n     compile_prog \"$spice_cflags\" \"$spice_libs\" ; then\n    spice=\"yes\"\n    libs_softmmu=\"$libs_softmmu $spice_libs\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $spice_cflags\"\n    spice_protocol_version=$($pkg_config --modversion spice-protocol)\n    spice_server_version=$($pkg_config --modversion spice-server)\n  else\n    if test \"$spice\" = \"yes\" ; then\n      feature_not_found \"spice\" \\\n          \"Install spice-server(>=0.12.0) and spice-protocol(>=0.12.3) devel\"\n    fi\n    spice=\"no\"\n  fi\nfi\n\n# check for smartcard support\nsmartcard_cflags=\"\"\nif test \"$smartcard\" != \"no\"; then\n    if $pkg_config libcacard; then\n        libcacard_cflags=$($pkg_config --cflags libcacard)\n        libcacard_libs=$($pkg_config --libs libcacard)\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $libcacard_cflags\"\n        libs_softmmu=\"$libs_softmmu $libcacard_libs\"\n        smartcard=\"yes\"\n    else\n        if test \"$smartcard\" = \"yes\"; then\n            feature_not_found \"smartcard\" \"Install libcacard devel\"\n        fi\n        smartcard=\"no\"\n    fi\nfi\n\n# check for libusb\nif test \"$libusb\" != \"no\" ; then\n    if $pkg_config --atleast-version=1.0.13 libusb-1.0; then\n        libusb=\"yes\"\n        libusb_cflags=$($pkg_config --cflags libusb-1.0)\n        libusb_libs=$($pkg_config --libs libusb-1.0)\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $libusb_cflags\"\n        libs_softmmu=\"$libs_softmmu $libusb_libs\"\n    else\n        if test \"$libusb\" = \"yes\"; then\n            feature_not_found \"libusb\" \"Install libusb devel >= 1.0.13\"\n        fi\n        libusb=\"no\"\n    fi\nfi\n\n# check for usbredirparser for usb network redirection support\nif test \"$usb_redir\" != \"no\" ; then\n    if $pkg_config --atleast-version=0.6 libusbredirparser-0.5; then\n        usb_redir=\"yes\"\n        usb_redir_cflags=$($pkg_config --cflags libusbredirparser-0.5)\n        usb_redir_libs=$($pkg_config --libs libusbredirparser-0.5)\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $usb_redir_cflags\"\n        libs_softmmu=\"$libs_softmmu $usb_redir_libs\"\n    else\n        if test \"$usb_redir\" = \"yes\"; then\n            feature_not_found \"usb-redir\" \"Install usbredir devel\"\n        fi\n        usb_redir=\"no\"\n    fi\nfi\n\n##########################################\n# check if we have VSS SDK headers for win\n\nif test \"$mingw32\" = \"yes\" -a \"$guest_agent\" != \"no\" -a \"$vss_win32_sdk\" != \"no\" ; then\n  case \"$vss_win32_sdk\" in\n    \"\")   vss_win32_include=\"-isystem $source_path\" ;;\n    *\\ *) # The SDK is installed in \"Program Files\" by default, but we cannot\n          # handle path with spaces. So we symlink the headers into \".sdk/vss\".\n          vss_win32_include=\"-isystem $source_path/.sdk/vss\"\n\t  symlink \"$vss_win32_sdk/inc\" \"$source_path/.sdk/vss/inc\"\n\t  ;;\n    *)    vss_win32_include=\"-isystem $vss_win32_sdk\"\n  esac\n  cat > $TMPC << EOF\n#define __MIDL_user_allocate_free_DEFINED__\n#include <inc/win2003/vss.h>\nint main(void) { return VSS_CTX_BACKUP; }\nEOF\n  if compile_prog \"$vss_win32_include\" \"\" ; then\n    guest_agent_with_vss=\"yes\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $vss_win32_include\"\n    libs_qga=\"-lole32 -loleaut32 -lshlwapi -lstdc++ -Wl,--enable-stdcall-fixup $libs_qga\"\n    qga_vss_provider=\"qga/vss-win32/qga-vss.dll qga/vss-win32/qga-vss.tlb\"\n  else\n    if test \"$vss_win32_sdk\" != \"\" ; then\n      echo \"ERROR: Please download and install Microsoft VSS SDK:\"\n      echo \"ERROR:   http://www.microsoft.com/en-us/download/details.aspx?id=23490\"\n      echo \"ERROR: On POSIX-systems, you can extract the SDK headers by:\"\n      echo \"ERROR:   scripts/extract-vsssdk-headers setup.exe\"\n      echo \"ERROR: The headers are extracted in the directory \\`inc'.\"\n      feature_not_found \"VSS support\"\n    fi\n    guest_agent_with_vss=\"no\"\n  fi\nfi\n\n##########################################\n# lookup Windows platform SDK (if not specified)\n# The SDK is needed only to build .tlb (type library) file of guest agent\n# VSS provider from the source. It is usually unnecessary because the\n# pre-compiled .tlb file is included.\n\nif test \"$mingw32\" = \"yes\" -a \"$guest_agent\" != \"no\" -a \"$guest_agent_with_vss\" = \"yes\" ; then\n  if test -z \"$win_sdk\"; then\n    programfiles=\"$PROGRAMFILES\"\n    test -n \"$PROGRAMW6432\" && programfiles=\"$PROGRAMW6432\"\n    if test -n \"$programfiles\"; then\n      win_sdk=$(ls -d \"$programfiles/Microsoft SDKs/Windows/v\"* | tail -1) 2>/dev/null\n    else\n      feature_not_found \"Windows SDK\"\n    fi\n  elif test \"$win_sdk\" = \"no\"; then\n    win_sdk=\"\"\n  fi\nfi\n\n##########################################\n# check if mingw environment provides a recent ntddscsi.h\nif test \"$mingw32\" = \"yes\" -a \"$guest_agent\" != \"no\"; then\n  cat > $TMPC << EOF\n#include <windows.h>\n#include <ntddscsi.h>\nint main(void) {\n#if !defined(IOCTL_SCSI_GET_ADDRESS)\n#error Missing required ioctl definitions\n#endif\n  SCSI_ADDRESS addr = { .Lun = 0, .TargetId = 0, .PathId = 0 };\n  return addr.Lun;\n}\nEOF\n  if compile_prog \"\" \"\" ; then\n    guest_agent_ntddscsi=yes\n    libs_qga=\"-lsetupapi $libs_qga\"\n  fi\nfi\n\n##########################################\n# virgl renderer probe\n\nif test \"$virglrenderer\" != \"no\" ; then\n  cat > $TMPC << EOF\n#include <virglrenderer.h>\nint main(void) { virgl_renderer_poll(); return 0; }\nEOF\n  virgl_cflags=$($pkg_config --cflags virglrenderer 2>/dev/null)\n  virgl_libs=$($pkg_config --libs virglrenderer 2>/dev/null)\n  if $pkg_config virglrenderer >/dev/null 2>&1 && \\\n     compile_prog \"$virgl_cflags\" \"$virgl_libs\" ; then\n    virglrenderer=\"yes\"\n  else\n    if test \"$virglrenderer\" = \"yes\" ; then\n      feature_not_found \"virglrenderer\"\n    fi\n    virglrenderer=\"no\"\n  fi\nfi\n\n##########################################\n# protobuf probe\n\nif test \"$protobuf\" != \"no\"; then\n  if $pkg_config --exists libprotobuf-c protobuf; then\n    protobuf=\"yes\"\n    protobuf_libs=$($pkg_config --libs libprotobuf-c protobuf)\n    protobuf_cflags=$($pkg_config --cflags libprotobuf-c protobuf)\n    libs_softmmu=\"$libs_softmmu $protobuf_libs\"\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $protobuf_cflags\"\n  else\n    protobuf=\"no\"\n    if test \"$protobuf\" = \"yes\" ; then\n      feature_not_found \"protobuf\" \"Please install protobuf and protobuf-c\"\n    fi\n  fi\nfi\n\n##########################################\n# capstone\n\ncase \"$capstone\" in\n  \"\" | yes)\n    if $pkg_config capstone; then\n      capstone=system\n    elif test -e \"${source_path}/.git\" ; then\n      capstone=git\n    elif test -e \"${source_path}/capstone/Makefile\" ; then\n      capstone=internal\n    elif test -z \"$capstone\" ; then\n      capstone=no\n    else\n      feature_not_found \"capstone\" \"Install capstone devel or git submodule\"\n    fi\n    ;;\n\n  system)\n    if ! $pkg_config capstone; then\n      feature_not_found \"capstone\" \"Install capstone devel\"\n    fi\n    ;;\nesac\n\ncase \"$capstone\" in\n  git | internal)\n    if test \"$capstone\" = git; then\n      git_submodules=\"${git_submodules} capstone\"\n    fi\n    mkdir -p capstone\n    QEMU_CFLAGS=\"$QEMU_CFLAGS -I\\$(SRC_PATH)/capstone/include\"\n    if test \"$mingw32\" = \"yes\"; then\n      LIBCAPSTONE=capstone.lib\n    else\n      LIBCAPSTONE=libcapstone.a\n    fi\n    LIBS=\"-L\\$(BUILD_DIR)/capstone -lcapstone $LIBS\"\n    ;;\n\n  system)\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $($pkg_config --cflags capstone)\"\n    LIBS=\"$($pkg_config --libs capstone) $LIBS\"\n    ;;\n\n  no)\n    ;;\n  *)\n    error_exit \"Unknown state for capstone: $capstone\"\n    ;;\nesac\n\n##########################################\n# check if we have fdatasync\n\nfdatasync=no\ncat > $TMPC << EOF\n#include <unistd.h>\nint main(void) {\n#if defined(_POSIX_SYNCHRONIZED_IO) && _POSIX_SYNCHRONIZED_IO > 0\nreturn fdatasync(0);\n#else\n#error Not supported\n#endif\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    fdatasync=yes\nfi\n\n##########################################\n# check if we have madvise\n\nmadvise=no\ncat > $TMPC << EOF\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <stddef.h>\nint main(void) { return madvise(NULL, 0, MADV_DONTNEED); }\nEOF\nif compile_prog \"\" \"\" ; then\n    madvise=yes\nfi\n\n##########################################\n# check if we have posix_madvise\n\nposix_madvise=no\ncat > $TMPC << EOF\n#include <sys/mman.h>\n#include <stddef.h>\nint main(void) { return posix_madvise(NULL, 0, POSIX_MADV_DONTNEED); }\nEOF\nif compile_prog \"\" \"\" ; then\n    posix_madvise=yes\nfi\n\n##########################################\n# check if we have posix_syslog\n\nposix_syslog=no\ncat > $TMPC << EOF\n#include <syslog.h>\nint main(void) { openlog(\"qemu\", LOG_PID, LOG_DAEMON); syslog(LOG_INFO, \"configure\"); return 0; }\nEOF\nif compile_prog \"\" \"\" ; then\n    posix_syslog=yes\nfi\n\n##########################################\n# check if trace backend exists\n\n$python \"$source_path/scripts/tracetool.py\" \"--backends=$trace_backends\" --check-backends  > /dev/null 2> /dev/null\nif test \"$?\" -ne 0 ; then\n  error_exit \"invalid trace backends\" \\\n      \"Please choose supported trace backends.\"\nfi\n\n##########################################\n# For 'ust' backend, test if ust headers are present\nif have_backend \"ust\"; then\n  cat > $TMPC << EOF\n#include <lttng/tracepoint.h>\nint main(void) { return 0; }\nEOF\n  if compile_prog \"\" \"-Wl,--no-as-needed -ldl\" ; then\n    if $pkg_config lttng-ust --exists; then\n      lttng_ust_libs=$($pkg_config --libs lttng-ust)\n    else\n      lttng_ust_libs=\"-llttng-ust -ldl\"\n    fi\n    if $pkg_config liburcu-bp --exists; then\n      urcu_bp_libs=$($pkg_config --libs liburcu-bp)\n    else\n      urcu_bp_libs=\"-lurcu-bp\"\n    fi\n\n    LIBS=\"$lttng_ust_libs $urcu_bp_libs $LIBS\"\n    libs_qga=\"$lttng_ust_libs $urcu_bp_libs $libs_qga\"\n  else\n    error_exit \"Trace backend 'ust' missing lttng-ust header files\"\n  fi\nfi\n\n##########################################\n# For 'dtrace' backend, test if 'dtrace' command is present\nif have_backend \"dtrace\"; then\n  if ! has 'dtrace' ; then\n    error_exit \"dtrace command is not found in PATH $PATH\"\n  fi\n  trace_backend_stap=\"no\"\n  if has 'stap' ; then\n    trace_backend_stap=\"yes\"\n  fi\nfi\n\n##########################################\n# check and set a backend for coroutine\n\n# We prefer ucontext, but it's not always possible. The fallback\n# is sigcontext. gthread is not selectable except explicitly, because\n# it is not functional enough to run QEMU proper. (It is occasionally\n# useful for debugging purposes.)  On Windows the only valid backend\n# is the Windows-specific one.\n\nucontext_works=no\nif test \"$darwin\" != \"yes\"; then\n  cat > $TMPC << EOF\n#include <ucontext.h>\n#ifdef __stub_makecontext\n#error Ignoring glibc stub makecontext which will always fail\n#endif\nint main(void) { makecontext(0, 0, 0); return 0; }\nEOF\n  if compile_prog \"\" \"\" ; then\n    ucontext_works=yes\n  fi\nfi\n\nif test \"$coroutine\" = \"\"; then\n  if test \"$mingw32\" = \"yes\"; then\n    coroutine=win32\n  elif test \"$ucontext_works\" = \"yes\"; then\n    coroutine=ucontext\n  else\n    coroutine=sigaltstack\n  fi\nelse\n  case $coroutine in\n  windows)\n    if test \"$mingw32\" != \"yes\"; then\n      error_exit \"'windows' coroutine backend only valid for Windows\"\n    fi\n    # Unfortunately the user visible backend name doesn't match the\n    # coroutine-*.c filename for this case, so we have to adjust it here.\n    coroutine=win32\n    ;;\n  ucontext)\n    if test \"$ucontext_works\" != \"yes\"; then\n      feature_not_found \"ucontext\"\n    fi\n    ;;\n  gthread|sigaltstack)\n    if test \"$mingw32\" = \"yes\"; then\n      error_exit \"only the 'windows' coroutine backend is valid for Windows\"\n    fi\n    ;;\n  *)\n    error_exit \"unknown coroutine backend $coroutine\"\n    ;;\n  esac\nfi\n\nif test \"$coroutine_pool\" = \"\"; then\n  if test \"$coroutine\" = \"gthread\"; then\n    coroutine_pool=no\n  else\n    coroutine_pool=yes\n  fi\nfi\nif test \"$coroutine\" = \"gthread\" -a \"$coroutine_pool\" = \"yes\"; then\n  error_exit \"'gthread' coroutine backend does not support pool (use --disable-coroutine-pool)\"\nfi\n\nif test \"$debug_stack_usage\" = \"yes\"; then\n  if test \"$coroutine_pool\" = \"yes\"; then\n    echo \"WARN: disabling coroutine pool for stack usage debugging\"\n    coroutine_pool=no\n  fi\nfi\n\n\n##########################################\n# check if we have open_by_handle_at\n\nopen_by_handle_at=no\ncat > $TMPC << EOF\n#include <fcntl.h>\n#if !defined(AT_EMPTY_PATH)\n# error missing definition\n#else\nint main(void) { struct file_handle fh; return open_by_handle_at(0, &fh, 0); }\n#endif\nEOF\nif compile_prog \"\" \"\" ; then\n    open_by_handle_at=yes\nfi\n\n########################################\n# check if we have linux/magic.h\n\nlinux_magic_h=no\ncat > $TMPC << EOF\n#include <linux/magic.h>\nint main(void) {\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    linux_magic_h=yes\nfi\n\n########################################\n# check whether we can disable warning option with a pragma (this is needed\n# to silence warnings in the headers of some versions of external libraries).\n# This test has to be compiled with -Werror as otherwise an unknown pragma is\n# only a warning.\n#\n# If we can't selectively disable warning in the code, disable -Werror so that\n# the build doesn't fail anyway.\n\npragma_disable_unused_but_set=no\ncat > $TMPC << EOF\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-prototypes\"\n#pragma GCC diagnostic pop\n\nint main(void) {\n    return 0;\n}\nEOF\nif compile_prog \"-Werror\" \"\" ; then\n    pragma_diagnostic_available=yes\nelse\n    werror=no\nfi\n\n########################################\n# check if we have valgrind/valgrind.h\n\nvalgrind_h=no\ncat > $TMPC << EOF\n#include <valgrind/valgrind.h>\nint main(void) {\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    valgrind_h=yes\nfi\n\n########################################\n# check if environ is declared\n\nhas_environ=no\ncat > $TMPC << EOF\n#include <unistd.h>\nint main(void) {\n    environ = 0;\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    has_environ=yes\nfi\n\n########################################\n# check if cpuid.h is usable.\n\ncat > $TMPC << EOF\n#include <cpuid.h>\nint main(void) {\n    unsigned a, b, c, d;\n    int max = __get_cpuid_max(0, 0);\n\n    if (max >= 1) {\n        __cpuid(1, a, b, c, d);\n    }\n\n    if (max >= 7) {\n        __cpuid_count(7, 0, a, b, c, d);\n    }\n\n    return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    cpuid_h=yes\nfi\n\n##########################################\n# avx2 optimization requirement check\n#\n# There is no point enabling this if cpuid.h is not usable,\n# since we won't be able to select the new routines.\n\nif test $cpuid_h = yes; then\n  cat > $TMPC << EOF\n#pragma GCC push_options\n#pragma GCC target(\"avx2\")\n#include <cpuid.h>\n#include <immintrin.h>\nstatic int bar(void *a) {\n    __m256i x = *(__m256i *)a;\n    return _mm256_testz_si256(x, x);\n}\nint main(int argc, char *argv[]) { return bar(argv[0]); }\nEOF\n  if compile_object \"\" ; then\n    avx2_opt=\"yes\"\n  fi\nfi\n\n########################################\n# check if __[u]int128_t is usable.\n\nint128=no\ncat > $TMPC << EOF\n#if defined(__clang_major__) && defined(__clang_minor__)\n# if ((__clang_major__ < 3) || (__clang_major__ == 3) && (__clang_minor__ < 2))\n#  error __int128_t does not work in CLANG before 3.2\n# endif\n#endif\n__int128_t a;\n__uint128_t b;\nint main (void) {\n  a = a + b;\n  b = a * b;\n  a = a * a;\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    int128=yes\nfi\n\n#########################################\n# See if 128-bit atomic operations are supported.\n\natomic128=no\nif test \"$int128\" = \"yes\"; then\n  cat > $TMPC << EOF\nint main(void)\n{\n  unsigned __int128 x = 0, y = 0;\n  y = __atomic_load_16(&x, 0);\n  __atomic_store_16(&x, y, 0);\n  __atomic_compare_exchange_16(&x, &y, x, 0, 0, 0);\n  return 0;\n}\nEOF\n  if compile_prog \"\" \"\" ; then\n    atomic128=yes\n  fi\nfi\n\n#########################################\n# See if 64-bit atomic operations are supported.\n# Note that without __atomic builtins, we can only\n# assume atomic loads/stores max at pointer size.\n\ncat > $TMPC << EOF\n#include <stdint.h>\nint main(void)\n{\n  uint64_t x = 0, y = 0;\n#ifdef __ATOMIC_RELAXED\n  y = __atomic_load_8(&x, 0);\n  __atomic_store_8(&x, y, 0);\n  __atomic_compare_exchange_8(&x, &y, x, 0, 0, 0);\n  __atomic_exchange_8(&x, y, 0);\n  __atomic_fetch_add_8(&x, y, 0);\n#else\n  typedef char is_host64[sizeof(void *) >= sizeof(uint64_t) ? 1 : -1];\n  __sync_lock_test_and_set(&x, y);\n  __sync_val_compare_and_swap(&x, y, 0);\n  __sync_fetch_and_add(&x, y);\n#endif\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n  atomic64=yes\nfi\n\n########################################\n# check if getauxval is available.\n\ngetauxval=no\ncat > $TMPC << EOF\n#include <sys/auxv.h>\nint main(void) {\n  return getauxval(AT_HWCAP) == 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    getauxval=yes\nfi\n\n########################################\n# check if ccache is interfering with\n# semantic analysis of macros\n\nunset CCACHE_CPP2\nccache_cpp2=no\ncat > $TMPC << EOF\nstatic const int Z = 1;\n#define fn() ({ Z; })\n#define TAUT(X) ((X) == Z)\n#define PAREN(X, Y) (X == Y)\n#define ID(X) (X)\nint main(int argc, char *argv[])\n{\n    int x = 0, y = 0;\n    x = ID(x);\n    x = fn();\n    fn();\n    if (PAREN(x, y)) return 0;\n    if (TAUT(Z)) return 0;\n    return 0;\n}\nEOF\n\nif ! compile_object \"-Werror\"; then\n    ccache_cpp2=yes\nfi\n\n#################################################\n# clang does not support glibc + FORTIFY_SOURCE.\n\nif test \"$fortify_source\" != \"no\"; then\n  if echo | $cc -dM -E - | grep __clang__ > /dev/null 2>&1 ; then\n    fortify_source=\"no\";\n  elif test -n \"$cxx\" &&\n       echo | $cxx -dM -E - | grep __clang__ >/dev/null 2>&1 ; then\n    fortify_source=\"no\";\n  else\n    fortify_source=\"yes\"\n  fi\nfi\n\n##########################################\n# check if struct fsxattr is available via linux/fs.h\n\nhave_fsxattr=no\ncat > $TMPC << EOF\n#include <linux/fs.h>\nstruct fsxattr foo;\nint main(void) {\n  return 0;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    have_fsxattr=yes\nfi\n\n##########################################\n# check if rtnetlink.h exists and is useful\nhave_rtnetlink=no\ncat > $TMPC << EOF\n#include <linux/rtnetlink.h>\nint main(void) {\n  return IFLA_PROTO_DOWN;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    have_rtnetlink=yes\nfi\n\n##########################################\n# check for usable AF_VSOCK environment\nhave_af_vsock=no\ncat > $TMPC << EOF\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#if !defined(AF_VSOCK)\n# error missing AF_VSOCK flag\n#endif\n#include <linux/vm_sockets.h>\nint main(void) {\n    int sock, ret;\n    struct sockaddr_vm svm;\n    socklen_t len = sizeof(svm);\n    sock = socket(AF_VSOCK, SOCK_STREAM, 0);\n    ret = getpeername(sock, (struct sockaddr *)&svm, &len);\n    if ((ret == -1) && (errno == ENOTCONN)) {\n        return 0;\n    }\n    return -1;\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    have_af_vsock=yes\nfi\n\n#################################################\n# Sparc implicitly links with --relax, which is\n# incompatible with -r, so --no-relax should be\n# given. It does no harm to give it on other\n# platforms too.\n\n# Note: the prototype is needed since QEMU_CFLAGS\n#       contains -Wmissing-prototypes\ncat > $TMPC << EOF\nextern int foo(void);\nint foo(void) { return 0; }\nEOF\nif ! compile_object \"\"; then\n  error_exit \"Failed to compile object file for LD_REL_FLAGS test\"\nfi\nfor i in '-Wl,-r -Wl,--no-relax' -Wl,-r -r; do\n  if do_cc -nostdlib $i -o $TMPMO $TMPO; then\n    LD_REL_FLAGS=$i\n    break\n  fi\ndone\nif test \"$modules\" = \"yes\" && test \"$LD_REL_FLAGS\" = \"\"; then\n  feature_not_found \"modules\" \"Cannot find how to build relocatable objects\"\nfi\n\n##########################################\n# check for sysmacros.h\n\nhave_sysmacros=no\ncat > $TMPC << EOF\n#include <sys/sysmacros.h>\nint main(void) {\n    return makedev(0, 0);\n}\nEOF\nif compile_prog \"\" \"\" ; then\n    have_sysmacros=yes\nfi\n\n##########################################\n# End of CC checks\n# After here, no more $cc or $ld runs\n\nif test \"$gcov\" = \"yes\" ; then\n  CFLAGS=\"-fprofile-arcs -ftest-coverage -g $CFLAGS\"\n  LDFLAGS=\"-fprofile-arcs -ftest-coverage $LDFLAGS\"\nelif test \"$fortify_source\" = \"yes\" ; then\n  CFLAGS=\"-O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $CFLAGS\"\nelif test \"$debug\" = \"no\"; then\n  CFLAGS=\"-O2 $CFLAGS\"\nfi\n\n##########################################\n# Do we have libnfs\nif test \"$libnfs\" != \"no\" ; then\n  if $pkg_config --atleast-version=1.9.3 libnfs; then\n    libnfs=\"yes\"\n    libnfs_libs=$($pkg_config --libs libnfs)\n  else\n    if test \"$libnfs\" = \"yes\" ; then\n      feature_not_found \"libnfs\" \"Install libnfs devel >= 1.9.3\"\n    fi\n    libnfs=\"no\"\n  fi\nfi\n\n# Now we've finished running tests it's OK to add -Werror to the compiler flags\nif test \"$werror\" = \"yes\"; then\n    QEMU_CFLAGS=\"-Werror $QEMU_CFLAGS\"\nfi\n\nif test \"$solaris\" = \"no\" ; then\n    if $ld --version 2>/dev/null | grep \"GNU ld\" >/dev/null 2>/dev/null ; then\n        LDFLAGS=\"-Wl,--warn-common $LDFLAGS\"\n    fi\nfi\n\n# test if pod2man has --utf8 option\nif pod2man --help | grep -q utf8; then\n    POD2MAN=\"pod2man --utf8\"\nelse\n    POD2MAN=\"pod2man\"\nfi\n\n# Use ASLR, no-SEH and DEP if available\nif test \"$mingw32\" = \"yes\" ; then\n    for flag in --dynamicbase --no-seh --nxcompat; do\n        if $ld --help 2>/dev/null | grep \".$flag\" >/dev/null 2>/dev/null ; then\n            LDFLAGS=\"-Wl,$flag $LDFLAGS\"\n        fi\n    done\nfi\n\nqemu_confdir=$sysconfdir$confsuffix\nqemu_moddir=$libdir$confsuffix\nqemu_datadir=$datadir$confsuffix\nqemu_localedir=\"$datadir/locale\"\npanda_plugindir=\"$libdir/panda\"\n\ntools=\"\"\nif test \"$want_tools\" = \"yes\" ; then\n  tools=\"qemu-img\\$(EXESUF) qemu-io\\$(EXESUF) $tools\"\n  if [ \"$linux\" = \"yes\" -o \"$bsd\" = \"yes\" -o \"$solaris\" = \"yes\" ] ; then\n    tools=\"qemu-nbd\\$(EXESUF) $tools\"\n    tools=\"ivshmem-client\\$(EXESUF) ivshmem-server\\$(EXESUF) $tools\"\n  fi\nfi\nif test \"$softmmu\" = yes ; then\n  if test \"$virtfs\" != no ; then\n    if test \"$cap\" = yes && test \"$linux\" = yes && test \"$attr\" = yes ; then\n      virtfs=yes\n      tools=\"$tools fsdev/virtfs-proxy-helper\\$(EXESUF)\"\n    else\n      if test \"$virtfs\" = yes; then\n        error_exit \"VirtFS is supported only on Linux and requires libcap devel and libattr devel\"\n      fi\n      virtfs=no\n    fi\n  fi\nfi\n\n# Probe for guest agent support/options\n\nif [ \"$guest_agent\" != \"no\" ]; then\n  if [ \"$linux\" = \"yes\" -o \"$bsd\" = \"yes\" -o \"$solaris\" = \"yes\" -o \"$mingw32\" = \"yes\" ] ; then\n      tools=\"qemu-ga $tools\"\n      guest_agent=yes\n  elif [ \"$guest_agent\" != yes ]; then\n      guest_agent=no\n  else\n      error_exit \"Guest agent is not supported on this platform\"\n  fi\nfi\n\n# Guest agent Window MSI  package\n\nif test \"$guest_agent\" != yes; then\n  if test \"$guest_agent_msi\" = yes; then\n    error_exit \"MSI guest agent package requires guest agent enabled\"\n  fi\n  guest_agent_msi=no\nelif test \"$mingw32\" != \"yes\"; then\n  if test \"$guest_agent_msi\" = \"yes\"; then\n    error_exit \"MSI guest agent package is available only for MinGW Windows cross-compilation\"\n  fi\n  guest_agent_msi=no\nelif ! has wixl; then\n  if test \"$guest_agent_msi\" = \"yes\"; then\n    error_exit \"MSI guest agent package requires wixl tool installed ( usually from msitools package )\"\n  fi\n  guest_agent_msi=no\nelse\n  # we support qemu-ga, mingw32, and wixl: default to MSI enabled if it wasn't\n  # disabled explicitly\n  if test \"$guest_agent_msi\" != \"no\"; then\n    guest_agent_msi=yes\n  fi\nfi\n\nif test \"$guest_agent_msi\" = \"yes\"; then\n  if test \"$guest_agent_with_vss\" = \"yes\"; then\n    QEMU_GA_MSI_WITH_VSS=\"-D InstallVss\"\n  fi\n\n  if test \"$QEMU_GA_MANUFACTURER\" = \"\"; then\n    QEMU_GA_MANUFACTURER=QEMU\n  fi\n\n  if test \"$QEMU_GA_DISTRO\" = \"\"; then\n    QEMU_GA_DISTRO=Linux\n  fi\n\n  if test \"$QEMU_GA_VERSION\" = \"\"; then\n      QEMU_GA_VERSION=$(cat $source_path/VERSION)\n  fi\n\n  QEMU_GA_MSI_MINGW_DLL_PATH=\"-D Mingw_dlls=$($pkg_config --variable=prefix glib-2.0)/bin\"\n\n  case \"$cpu\" in\n  x86_64)\n    QEMU_GA_MSI_ARCH=\"-a x64 -D Arch=64\"\n    ;;\n  i386)\n    QEMU_GA_MSI_ARCH=\"-D Arch=32\"\n    ;;\n  *)\n    error_exit \"CPU $cpu not supported for building installation package\"\n    ;;\n  esac\nfi\n\n# Mac OS X ships with a broken assembler\nroms=\nif test \\( \"$cpu\" = \"i386\" -o \"$cpu\" = \"x86_64\" \\) -a \\\n        \"$targetos\" != \"Darwin\" -a \"$targetos\" != \"SunOS\" -a \\\n        \"$softmmu\" = yes ; then\n    # Different host OS linkers have different ideas about the name of the ELF\n    # emulation. Linux and OpenBSD use 'elf_i386'; FreeBSD uses the _fbsd\n    # variant; and Windows uses i386pe.\n    for emu in elf_i386 elf_i386_fbsd i386pe; do\n        if \"$ld\" -verbose 2>&1 | grep -q \"^[[:space:]]*$emu[[:space:]]*$\"; then\n            ld_i386_emulation=\"$emu\"\n            roms=\"optionrom\"\n            break\n        fi\n    done\nfi\nif test \"$cpu\" = \"ppc64\" -a \"$targetos\" != \"Darwin\" ; then\n  roms=\"$roms spapr-rtas\"\nfi\n\nif test \"$cpu\" = \"s390x\" ; then\n  roms=\"$roms s390-ccw\"\nfi\n\n# Probe for the need for relocating the user-only binary.\nif ( [ \"$linux_user\" = yes ] || [ \"$bsd_user\" = yes ] ) && [ \"$pie\" = no ]; then\n  textseg_addr=\n  case \"$cpu\" in\n    arm | i386 | ppc* | s390* | sparc* | x86_64 | x32)\n      # ??? Rationale for choosing this address\n      textseg_addr=0x60000000\n      ;;\n    mips)\n      # A 256M aligned address, high in the address space, with enough\n      # room for the code_gen_buffer above it before the stack.\n      textseg_addr=0x60000000\n      ;;\n  esac\n  if [ -n \"$textseg_addr\" ]; then\n    cat > $TMPC <<EOF\n    int main(void) { return 0; }\nEOF\n    textseg_ldflags=\"-Wl,-Ttext-segment=$textseg_addr\"\n    if ! compile_prog \"\" \"$textseg_ldflags\"; then\n      # In case ld does not support -Ttext-segment, edit the default linker\n      # script via sed to set the .text start addr.  This is needed on FreeBSD\n      # at least.\n      if ! $ld --verbose >/dev/null 2>&1; then\n        error_exit \\\n            \"We need to link the QEMU user mode binaries at a\" \\\n            \"specific text address. Unfortunately your linker\" \\\n            \"doesn't support either the -Ttext-segment option or\" \\\n            \"printing the default linker script with --verbose.\" \\\n            \"If you don't want the user mode binaries, pass the\" \\\n            \"--disable-user option to configure.\"\n      fi\n\n      $ld --verbose | sed \\\n        -e '1,/==================================================/d' \\\n        -e '/==================================================/,$d' \\\n        -e \"s/[.] = [0-9a-fx]* [+] SIZEOF_HEADERS/. = $textseg_addr + SIZEOF_HEADERS/\" \\\n        -e \"s/__executable_start = [0-9a-fx]*/__executable_start = $textseg_addr/\" > config-host.ld\n      textseg_ldflags=\"-Wl,-T../config-host.ld\"\n    fi\n  fi\nfi\n\n# Check that the C++ compiler exists and works with the C compiler.\n# All the QEMU_CXXFLAGS are based on QEMU_CFLAGS. Keep this at the end to don't miss any other that could be added.\nif has $cxx; then\n    cat > $TMPC <<EOF\nint c_function(void);\nint main(void) { return c_function(); }\nEOF\n\n    compile_object\n\n    cat > $TMPCXX <<EOF\nextern \"C\" {\n   int c_function(void);\n}\nint c_function(void) { return 42; }\nEOF\n\n    update_cxxflags\n\n    if do_cxx $QEMU_CXXFLAGS -o $TMPE $TMPCXX $TMPO $LDFLAGS; then\n        # C++ compiler $cxx works ok with C compiler $cc\n        :\n    else\n        echo \"C++ compiler $cxx does not work with C compiler $cc\"\n        echo \"Disabling C++ specific optional code\"\n        cxx=\n    fi\nelse\n    echo \"No C++ compiler available; disabling C++ specific optional code\"\n    cxx=\nfi\n\n# Check that the llvm C++ compiler exists and works with the C compiler.\n# Any QEMU_CXXFLAGS/QEMU_CFLAGS are used by compile_prog_clangxx.\n# Keep this at the end to don't miss any other that could be added.\nif test \"$llvm\" != \"no\"; then\n  cat > $TMPCXX <<-EOF\n\t#include <llvm/IR/LLVMContext.h>\n    int main(void) { llvm::LLVMContext c; return 0; }\n\tEOF\n\n  llvm_components=\"\"\n  llvm_cxxflags=$($llvm_config $llvm_components --cxxflags 2> /dev/null)\n  llvm_ldflags=$($llvm_config $llvm_components --ldflags 2> /dev/null)\n  llvm_libs=$($llvm_config $llvm_components --libs 2> /dev/null)\n\n  if compile_prog_clangxx \"$llvm_cxxflags -Wno-unused-variable\" \"$llvm_libs $llvm_ldflags\" ; then\n    : LLVM found\n  elif test \"$llvm\" = \"yes\"; then\n    feature_not_found \"llvm (required for --enable-llvm)\"\n    exit 1\n  else\n    llvm=\"no\"\n  fi\nfi\n\nif test \"$llvm\" != \"no\" ; then\n  llvm=\"yes\"\n  LIBS=\"$llvm_libs $LIBS $llvm_ldflags\"\n  linker=\"$cxx\"\nfi\n\necho_version() {\n    if test \"$1\" = \"yes\" ; then\n        echo \"($2)\"\n    fi\n}\n\n# prepend pixman and ftd flags after all config tests are done\nQEMU_CFLAGS=\"$pixman_cflags $fdt_cflags $QEMU_CFLAGS\"\nQEMU_LDFLAGS=\"$fdt_ldflags $QEMU_LDFLAGS\"\nlibs_softmmu=\"$pixman_libs $libs_softmmu\"\n\necho \"Install prefix    $prefix\"\necho \"BIOS directory    $(eval echo $qemu_datadir)\"\necho \"binary directory  $(eval echo $bindir)\"\necho \"library directory $(eval echo $libdir)\"\necho \"python directory  $(eval echo $pythondir)\"\necho \"module directory  $(eval echo $qemu_moddir)\"\necho \"libexec directory $(eval echo $libexecdir)\"\necho \"include directory $(eval echo $includedir)\"\necho \"config directory  $(eval echo $sysconfdir)\"\nif test \"$mingw32\" = \"no\" ; then\necho \"local state directory   $(eval echo $local_statedir)\"\necho \"Manual directory  $(eval echo $mandir)\"\necho \"ELF interp prefix $interp_prefix\"\nelse\necho \"local state directory   queried at runtime\"\necho \"Windows SDK       $win_sdk\"\nfi\necho \"Source path       $source_path\"\necho \"GIT submodules    $git_submodules\"\necho \"C compiler        $cc\"\necho \"Host C compiler   $host_cc\"\necho \"C++ compiler      $cxx\"\necho \"Objective-C compiler $objcc\"\necho \"ARFLAGS           $ARFLAGS\"\necho \"CFLAGS            $CFLAGS\"\necho \"QEMU_CFLAGS       $QEMU_CFLAGS\"\necho \"LDFLAGS           $LDFLAGS\"\necho \"QEMU_LDFLAGS      $QEMU_LDFLAGS\"\necho \"make              $make\"\necho \"install           $install\"\necho \"python            $python\"\nif test \"$slirp\" = \"yes\" ; then\n    echo \"smbd              $smbd\"\nfi\necho \"module support    $modules\"\necho \"host CPU          $cpu\"\necho \"host big endian   $bigendian\"\necho \"target list       $target_list\"\necho \"tcg debug enabled $debug_tcg\"\necho \"gprof enabled     $gprof\"\necho \"sparse enabled    $sparse\"\necho \"strip binaries    $strip_opt\"\necho \"profiler          $profiler\"\necho \"static build      $static\"\nif test \"$darwin\" = \"yes\" ; then\n    echo \"Cocoa support     $cocoa\"\nfi\necho \"pixman            $pixman\"\necho \"SDL support       $sdl $(echo_version $sdl $sdlversion)\"\necho \"GTK support       $gtk $(echo_version $gtk $gtk_version)\"\necho \"GTK GL support    $gtk_gl\"\necho \"VTE support       $vte $(echo_version $vte $vteversion)\"\necho \"TLS priority      $tls_priority\"\necho \"GNUTLS support    $gnutls\"\necho \"GNUTLS rnd        $gnutls_rnd\"\necho \"libgcrypt         $gcrypt\"\necho \"libgcrypt kdf     $gcrypt_kdf\"\necho \"nettle            $nettle $(echo_version $nettle $nettle_version)\"\necho \"nettle kdf        $nettle_kdf\"\necho \"libtasn1          $tasn1\"\necho \"curses support    $curses\"\necho \"virgl support     $virglrenderer\"\necho \"curl support      $curl\"\necho \"mingw32 support   $mingw32\"\necho \"Audio drivers     $audio_drv_list\"\necho \"Block whitelist (rw) $block_drv_rw_whitelist\"\necho \"Block whitelist (ro) $block_drv_ro_whitelist\"\necho \"VirtFS support    $virtfs\"\necho \"VNC support       $vnc\"\nif test \"$vnc\" = \"yes\" ; then\n    echo \"VNC SASL support  $vnc_sasl\"\n    echo \"VNC JPEG support  $vnc_jpeg\"\n    echo \"VNC PNG support   $vnc_png\"\nfi\nif test -n \"$sparc_cpu\"; then\n    echo \"Target Sparc Arch $sparc_cpu\"\nfi\necho \"xen support       $xen\"\nif test \"$xen\" = \"yes\" ; then\n  echo \"xen ctrl version  $xen_ctrl_version\"\n  echo \"pv dom build      $xen_pv_domain_build\"\nfi\necho \"brlapi support    $brlapi\"\necho \"bluez  support    $bluez\"\necho \"Documentation     $docs\"\necho \"PIE               $pie\"\necho \"vde support       $vde\"\necho \"netmap support    $netmap\"\necho \"Linux AIO support $linux_aio\"\necho \"ATTR/XATTR support $attr\"\necho \"Install blobs     $blobs\"\necho \"KVM support       $kvm\"\necho \"HAX support       $hax\"\necho \"RDMA support      $rdma\"\necho \"LLVM support      $llvm\"\necho \"TCG interpreter   $tcg_interpreter\"\necho \"fdt support       $fdt\"\necho \"preadv support    $preadv\"\necho \"protobuf support  $protobuf\"\necho \"fdatasync         $fdatasync\"\necho \"madvise           $madvise\"\necho \"posix_madvise     $posix_madvise\"\necho \"libcap-ng support $cap_ng\"\necho \"vhost-net support $vhost_net\"\necho \"vhost-scsi support $vhost_scsi\"\necho \"vhost-vsock support $vhost_vsock\"\necho \"Trace backends    $trace_backends\"\nif have_backend \"simple\"; then\necho \"Trace output file $trace_file-<pid>\"\nfi\necho \"spice support     $spice $(echo_version $spice $spice_protocol_version/$spice_server_version)\"\necho \"rbd support       $rbd\"\necho \"xfsctl support    $xfs\"\necho \"smartcard support $smartcard\"\necho \"libusb            $libusb\"\necho \"usb net redir     $usb_redir\"\necho \"OpenGL support    $opengl\"\necho \"OpenGL dmabufs    $opengl_dmabuf\"\necho \"libiscsi support  $libiscsi\"\necho \"libnfs support    $libnfs\"\necho \"build guest agent $guest_agent\"\necho \"QGA VSS support   $guest_agent_with_vss\"\necho \"QGA w32 disk info $guest_agent_ntddscsi\"\necho \"QGA MSI support   $guest_agent_msi\"\necho \"seccomp support   $seccomp\"\necho \"coroutine backend $coroutine\"\necho \"coroutine pool    $coroutine_pool\"\necho \"debug stack usage $debug_stack_usage\"\necho \"GlusterFS support $glusterfs\"\necho \"gcov              $gcov_tool\"\necho \"gcov enabled      $gcov\"\necho \"TPM support       $tpm\"\necho \"libssh2 support   $libssh2\"\necho \"TPM passthrough   $tpm_passthrough\"\necho \"QOM debugging     $qom_cast_debug\"\necho \"lzo support       $lzo\"\necho \"snappy support    $snappy\"\necho \"bzip2 support     $bzip2\"\necho \"NUMA host support $numa\"\necho \"tcmalloc support  $tcmalloc\"\necho \"jemalloc support  $jemalloc\"\necho \"avx2 optimization $avx2_opt\"\necho \"replication support $replication\"\necho \"capstone          $capstone\"\necho \"LLVM support      $llvm\"\necho \"extra plugins path $extra_plugins_path\"\n\nif test \"$sdl_too_old\" = \"yes\"; then\necho \"-> Your SDL version is too old - please upgrade to have SDL support\"\nfi\n\nif test \"$supported_cpu\" = \"no\"; then\n    echo\n    echo \"WARNING: SUPPORT FOR THIS HOST CPU WILL GO AWAY IN FUTURE RELEASES!\"\n    echo\n    echo \"CPU host architecture $cpu support is not currently maintained.\"\n    echo \"The QEMU project intends to remove support for this host CPU in\"\n    echo \"a future release if nobody volunteers to maintain it and to\"\n    echo \"provide a build host for our continuous integration setup.\"\n    echo \"configure has succeeded and you can continue to build, but\"\n    echo \"if you care about QEMU on this platform you should contact\"\n    echo \"us upstream at qemu-devel@nongnu.org.\"\nfi\n\nif test \"$supported_os\" = \"no\"; then\n    echo\n    echo \"WARNING: SUPPORT FOR THIS HOST OS WILL GO AWAY IN FUTURE RELEASES!\"\n    echo\n    echo \"Host OS $targetos support is not currently maintained.\"\n    echo \"The QEMU project intends to remove support for this host OS in\"\n    echo \"a future release if nobody volunteers to maintain it and to\"\n    echo \"provide a build host for our continuous integration setup.\"\n    echo \"configure has succeeded and you can continue to build, but\"\n    echo \"if you care about QEMU on this platform you should contact\"\n    echo \"us upstream at qemu-devel@nongnu.org.\"\nfi\n\nconfig_host_mak=\"config-host.mak\"\n\necho \"# Automatically generated by configure - do not modify\" >config-all-disas.mak\n\necho \"# Automatically generated by configure - do not modify\" > $config_host_mak\necho >> $config_host_mak\n\necho all: >> $config_host_mak\necho \"prefix=$prefix\" >> $config_host_mak\necho \"bindir=$bindir\" >> $config_host_mak\necho \"libdir=$libdir\" >> $config_host_mak\necho \"pythondir=$pythondir\" >> $config_host_mak\necho \"libexecdir=$libexecdir\" >> $config_host_mak\necho \"includedir=$includedir\" >> $config_host_mak\necho \"mandir=$mandir\" >> $config_host_mak\necho \"sysconfdir=$sysconfdir\" >> $config_host_mak\necho \"qemu_confdir=$qemu_confdir\" >> $config_host_mak\necho \"qemu_datadir=$qemu_datadir\" >> $config_host_mak\necho \"qemu_docdir=$qemu_docdir\" >> $config_host_mak\necho \"qemu_moddir=$qemu_moddir\" >> $config_host_mak\necho \"panda_plugindir=$panda_plugindir\" >> $config_host_mak\nif test \"$mingw32\" = \"no\" ; then\n  echo \"qemu_localstatedir=$local_statedir\" >> $config_host_mak\nfi\necho \"qemu_helperdir=$libexecdir\" >> $config_host_mak\necho \"qemu_localedir=$qemu_localedir\" >> $config_host_mak\necho \"libs_softmmu=$libs_softmmu\" >> $config_host_mak\necho \"GIT_SUBMODULES=$git_submodules\" >> $config_host_mak\n\necho \"ARCH=$ARCH\" >> $config_host_mak\n\nif test \"$debug_tcg\" = \"yes\" ; then\n  echo \"CONFIG_DEBUG_TCG=y\" >> $config_host_mak\nfi\nif test \"$strip_opt\" = \"yes\" ; then\n  echo \"STRIP=${strip}\" >> $config_host_mak\nfi\nif test \"$bigendian\" = \"yes\" ; then\n  echo \"HOST_WORDS_BIGENDIAN=y\" >> $config_host_mak\nfi\nif test \"$mingw32\" = \"yes\" ; then\n  echo \"CONFIG_WIN32=y\" >> $config_host_mak\n  rc_version=$(cat $source_path/VERSION)\n  version_major=${rc_version%%.*}\n  rc_version=${rc_version#*.}\n  version_minor=${rc_version%%.*}\n  rc_version=${rc_version#*.}\n  version_subminor=${rc_version%%.*}\n  version_micro=0\n  echo \"CONFIG_FILEVERSION=$version_major,$version_minor,$version_subminor,$version_micro\" >> $config_host_mak\n  echo \"CONFIG_PRODUCTVERSION=$version_major,$version_minor,$version_subminor,$version_micro\" >> $config_host_mak\n  if test \"$guest_agent_with_vss\" = \"yes\" ; then\n    echo \"CONFIG_QGA_VSS=y\" >> $config_host_mak\n    echo \"QGA_VSS_PROVIDER=$qga_vss_provider\" >> $config_host_mak\n    echo \"WIN_SDK=\\\"$win_sdk\\\"\" >> $config_host_mak\n  fi\n  if test \"$guest_agent_ntddscsi\" = \"yes\" ; then\n    echo \"CONFIG_QGA_NTDDDISK=y\" >> $config_host_mak\n  fi\n  if test \"$guest_agent_msi\" = \"yes\"; then\n    echo \"QEMU_GA_MSI_ENABLED=yes\" >> $config_host_mak  \n    echo \"QEMU_GA_MSI_MINGW_DLL_PATH=${QEMU_GA_MSI_MINGW_DLL_PATH}\" >> $config_host_mak\n    echo \"QEMU_GA_MSI_WITH_VSS=${QEMU_GA_MSI_WITH_VSS}\" >> $config_host_mak\n    echo \"QEMU_GA_MSI_ARCH=${QEMU_GA_MSI_ARCH}\" >> $config_host_mak\n    echo \"QEMU_GA_MANUFACTURER=${QEMU_GA_MANUFACTURER}\" >> $config_host_mak\n    echo \"QEMU_GA_DISTRO=${QEMU_GA_DISTRO}\" >> $config_host_mak\n    echo \"QEMU_GA_VERSION=${QEMU_GA_VERSION}\" >> $config_host_mak\n  fi\nelse\n  echo \"CONFIG_POSIX=y\" >> $config_host_mak\nfi\n\nif test \"$linux\" = \"yes\" ; then\n  echo \"CONFIG_LINUX=y\" >> $config_host_mak\nfi\n\nif test \"$darwin\" = \"yes\" ; then\n  echo \"CONFIG_DARWIN=y\" >> $config_host_mak\nfi\n\nif test \"$solaris\" = \"yes\" ; then\n  echo \"CONFIG_SOLARIS=y\" >> $config_host_mak\nfi\nif test \"$haiku\" = \"yes\" ; then\n  echo \"CONFIG_HAIKU=y\" >> $config_host_mak\nfi\nif test \"$static\" = \"yes\" ; then\n  echo \"CONFIG_STATIC=y\" >> $config_host_mak\nfi\nif test \"$profiler\" = \"yes\" ; then\n  echo \"CONFIG_PROFILER=y\" >> $config_host_mak\nfi\nif test \"$slirp\" = \"yes\" ; then\n  echo \"CONFIG_SLIRP=y\" >> $config_host_mak\n  echo \"CONFIG_SMBD_COMMAND=\\\"$smbd\\\"\" >> $config_host_mak\nfi\nif test \"$vde\" = \"yes\" ; then\n  echo \"CONFIG_VDE=y\" >> $config_host_mak\nfi\nif test \"$netmap\" = \"yes\" ; then\n  echo \"CONFIG_NETMAP=y\" >> $config_host_mak\nfi\nif test \"$l2tpv3\" = \"yes\" ; then\n  echo \"CONFIG_L2TPV3=y\" >> $config_host_mak\nfi\nif test \"$cap_ng\" = \"yes\" ; then\n  echo \"CONFIG_LIBCAP=y\" >> $config_host_mak\nfi\necho \"CONFIG_AUDIO_DRIVERS=$audio_drv_list\" >> $config_host_mak\nfor drv in $audio_drv_list; do\n    def=CONFIG_$(echo $drv | LC_ALL=C tr '[a-z]' '[A-Z]')\n    echo \"$def=y\" >> $config_host_mak\ndone\nif test \"$audio_pt_int\" = \"yes\" ; then\n  echo \"CONFIG_AUDIO_PT_INT=y\" >> $config_host_mak\nfi\nif test \"$audio_win_int\" = \"yes\" ; then\n  echo \"CONFIG_AUDIO_WIN_INT=y\" >> $config_host_mak\nfi\necho \"CONFIG_BDRV_RW_WHITELIST=$block_drv_rw_whitelist\" >> $config_host_mak\necho \"CONFIG_BDRV_RO_WHITELIST=$block_drv_ro_whitelist\" >> $config_host_mak\nif test \"$vnc\" = \"yes\" ; then\n  echo \"CONFIG_VNC=y\" >> $config_host_mak\nfi\nif test \"$vnc_sasl\" = \"yes\" ; then\n  echo \"CONFIG_VNC_SASL=y\" >> $config_host_mak\nfi\nif test \"$vnc_jpeg\" = \"yes\" ; then\n  echo \"CONFIG_VNC_JPEG=y\" >> $config_host_mak\nfi\nif test \"$vnc_png\" = \"yes\" ; then\n  echo \"CONFIG_VNC_PNG=y\" >> $config_host_mak\nfi\nif test \"$fnmatch\" = \"yes\" ; then\n  echo \"CONFIG_FNMATCH=y\" >> $config_host_mak\nfi\nif test \"$xfs\" = \"yes\" ; then\n  echo \"CONFIG_XFS=y\" >> $config_host_mak\nfi\nqemu_version=$(head $source_path/VERSION)\necho \"VERSION=$qemu_version\" >>$config_host_mak\necho \"PKGVERSION=$pkgversion\" >>$config_host_mak\necho \"SRC_PATH=$source_path\" >> $config_host_mak\nif test ! -z \"$extra_plugins_path\"; then\n  echo \"EXTRA_PLUGINS_PATH=$extra_plugins_path\" >> $config_host_mak\nfi\necho \"TARGET_DIRS=$target_list\" >> $config_host_mak\nif [ \"$docs\" = \"yes\" ] ; then\n  echo \"BUILD_DOCS=yes\" >> $config_host_mak\nfi\nif test \"$modules\" = \"yes\"; then\n  # $shacmd can generate a hash started with digit, which the compiler doesn't\n  # like as an symbol. So prefix it with an underscore\n  echo \"CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\\ )\" >> $config_host_mak\n  echo \"CONFIG_MODULES=y\" >> $config_host_mak\nfi\nif test \"$sdl\" = \"yes\" ; then\n  echo \"CONFIG_SDL=y\" >> $config_host_mak\n  echo \"CONFIG_SDLABI=$sdlabi\" >> $config_host_mak\n  echo \"SDL_CFLAGS=$sdl_cflags\" >> $config_host_mak\nfi\nif test \"$cocoa\" = \"yes\" ; then\n  echo \"CONFIG_COCOA=y\" >> $config_host_mak\nfi\nif test \"$curses\" = \"yes\" ; then\n  echo \"CONFIG_CURSES=y\" >> $config_host_mak\nfi\nif test \"$utimens\" = \"yes\" ; then\n  echo \"CONFIG_UTIMENSAT=y\" >> $config_host_mak\nfi\nif test \"$pipe2\" = \"yes\" ; then\n  echo \"CONFIG_PIPE2=y\" >> $config_host_mak\nfi\nif test \"$accept4\" = \"yes\" ; then\n  echo \"CONFIG_ACCEPT4=y\" >> $config_host_mak\nfi\nif test \"$splice\" = \"yes\" ; then\n  echo \"CONFIG_SPLICE=y\" >> $config_host_mak\nfi\nif test \"$eventfd\" = \"yes\" ; then\n  echo \"CONFIG_EVENTFD=y\" >> $config_host_mak\nfi\nif test \"$memfd\" = \"yes\" ; then\n  echo \"CONFIG_MEMFD=y\" >> $config_host_mak\nfi\nif test \"$fallocate\" = \"yes\" ; then\n  echo \"CONFIG_FALLOCATE=y\" >> $config_host_mak\nfi\nif test \"$fallocate_punch_hole\" = \"yes\" ; then\n  echo \"CONFIG_FALLOCATE_PUNCH_HOLE=y\" >> $config_host_mak\nfi\nif test \"$fallocate_zero_range\" = \"yes\" ; then\n  echo \"CONFIG_FALLOCATE_ZERO_RANGE=y\" >> $config_host_mak\nfi\nif test \"$posix_fallocate\" = \"yes\" ; then\n  echo \"CONFIG_POSIX_FALLOCATE=y\" >> $config_host_mak\nfi\nif test \"$sync_file_range\" = \"yes\" ; then\n  echo \"CONFIG_SYNC_FILE_RANGE=y\" >> $config_host_mak\nfi\nif test \"$fiemap\" = \"yes\" ; then\n  echo \"CONFIG_FIEMAP=y\" >> $config_host_mak\nfi\nif test \"$dup3\" = \"yes\" ; then\n  echo \"CONFIG_DUP3=y\" >> $config_host_mak\nfi\nif test \"$ppoll\" = \"yes\" ; then\n  echo \"CONFIG_PPOLL=y\" >> $config_host_mak\nfi\nif test \"$prctl_pr_set_timerslack\" = \"yes\" ; then\n  echo \"CONFIG_PRCTL_PR_SET_TIMERSLACK=y\" >> $config_host_mak\nfi\nif test \"$epoll\" = \"yes\" ; then\n  echo \"CONFIG_EPOLL=y\" >> $config_host_mak\nfi\nif test \"$epoll_create1\" = \"yes\" ; then\n  echo \"CONFIG_EPOLL_CREATE1=y\" >> $config_host_mak\nfi\nif test \"$sendfile\" = \"yes\" ; then\n  echo \"CONFIG_SENDFILE=y\" >> $config_host_mak\nfi\nif test \"$timerfd\" = \"yes\" ; then\n  echo \"CONFIG_TIMERFD=y\" >> $config_host_mak\nfi\nif test \"$setns\" = \"yes\" ; then\n  echo \"CONFIG_SETNS=y\" >> $config_host_mak\nfi\nif test \"$clock_adjtime\" = \"yes\" ; then\n  echo \"CONFIG_CLOCK_ADJTIME=y\" >> $config_host_mak\nfi\nif test \"$syncfs\" = \"yes\" ; then\n  echo \"CONFIG_SYNCFS=y\" >> $config_host_mak\nfi\nif test \"$inotify\" = \"yes\" ; then\n  echo \"CONFIG_INOTIFY=y\" >> $config_host_mak\nfi\nif test \"$inotify1\" = \"yes\" ; then\n  echo \"CONFIG_INOTIFY1=y\" >> $config_host_mak\nfi\nif test \"$byteswap_h\" = \"yes\" ; then\n  echo \"CONFIG_BYTESWAP_H=y\" >> $config_host_mak\nfi\nif test \"$bswap_h\" = \"yes\" ; then\n  echo \"CONFIG_MACHINE_BSWAP_H=y\" >> $config_host_mak\nfi\nif test \"$curl\" = \"yes\" ; then\n  echo \"CONFIG_CURL=m\" >> $config_host_mak\n  echo \"CURL_CFLAGS=$curl_cflags\" >> $config_host_mak\n  echo \"CURL_LIBS=$curl_libs\" >> $config_host_mak\nfi\nif test \"$brlapi\" = \"yes\" ; then\n  echo \"CONFIG_BRLAPI=y\" >> $config_host_mak\nfi\nif test \"$bluez\" = \"yes\" ; then\n  echo \"CONFIG_BLUEZ=y\" >> $config_host_mak\n  echo \"BLUEZ_CFLAGS=$bluez_cflags\" >> $config_host_mak\nfi\nif test \"$glib_subprocess\" = \"yes\" ; then\n  echo \"CONFIG_HAS_GLIB_SUBPROCESS_TESTS=y\" >> $config_host_mak\nfi\nif test \"$gtk\" = \"yes\" ; then\n  echo \"CONFIG_GTK=y\" >> $config_host_mak\n  echo \"CONFIG_GTKABI=$gtkabi\" >> $config_host_mak\n  echo \"GTK_CFLAGS=$gtk_cflags\" >> $config_host_mak\n  echo \"GTK_LIBS=$gtk_libs\" >> $config_host_mak\n  if test \"$gtk_gl\" = \"yes\" ; then\n    echo \"CONFIG_GTK_GL=y\" >> $config_host_mak\n  fi\nfi\necho \"CONFIG_TLS_PRIORITY=\\\"$tls_priority\\\"\" >> $config_host_mak\nif test \"$gnutls\" = \"yes\" ; then\n  echo \"CONFIG_GNUTLS=y\" >> $config_host_mak\nfi\nif test \"$gnutls_rnd\" = \"yes\" ; then\n  echo \"CONFIG_GNUTLS_RND=y\" >> $config_host_mak\nfi\nif test \"$gcrypt\" = \"yes\" ; then\n  echo \"CONFIG_GCRYPT=y\" >> $config_host_mak\n  if test \"$gcrypt_hmac\" = \"yes\" ; then\n    echo \"CONFIG_GCRYPT_HMAC=y\" >> $config_host_mak\n  fi\n  if test \"$gcrypt_kdf\" = \"yes\" ; then\n    echo \"CONFIG_GCRYPT_KDF=y\" >> $config_host_mak\n  fi\nfi\nif test \"$nettle\" = \"yes\" ; then\n  echo \"CONFIG_NETTLE=y\" >> $config_host_mak\n  echo \"CONFIG_NETTLE_VERSION_MAJOR=${nettle_version%%.*}\" >> $config_host_mak\n  if test \"$nettle_kdf\" = \"yes\" ; then\n    echo \"CONFIG_NETTLE_KDF=y\" >> $config_host_mak\n  fi\nfi\nif test \"$tasn1\" = \"yes\" ; then\n  echo \"CONFIG_TASN1=y\" >> $config_host_mak\nfi\nif test \"$have_ifaddrs_h\" = \"yes\" ; then\n    echo \"HAVE_IFADDRS_H=y\" >> $config_host_mak\nfi\nif test \"$have_broken_size_max\" = \"yes\" ; then\n    echo \"HAVE_BROKEN_SIZE_MAX=y\" >> $config_host_mak\nfi\n\n# Work around a system header bug with some kernel/XFS header\n# versions where they both try to define 'struct fsxattr':\n# xfs headers will not try to redefine structs from linux headers\n# if this macro is set.\nif test \"$have_fsxattr\" = \"yes\" ; then\n    echo \"HAVE_FSXATTR=y\" >> $config_host_mak\nfi\nif test \"$vte\" = \"yes\" ; then\n  echo \"CONFIG_VTE=y\" >> $config_host_mak\n  echo \"VTE_CFLAGS=$vte_cflags\" >> $config_host_mak\nfi\nif test \"$virglrenderer\" = \"yes\" ; then\n  echo \"CONFIG_VIRGL=y\" >> $config_host_mak\n  echo \"VIRGL_CFLAGS=$virgl_cflags\" >> $config_host_mak\n  echo \"VIRGL_LIBS=$virgl_libs\" >> $config_host_mak\nfi\n\nif test \"$llvm\" = \"yes\" ; then\n    FILTERFLAGS=\"-pedantic\"\n  if test \"$debug\" = \"yes\" ; then\n     FILTERFLAGS=\"$FILTERFLAGS -O2 -O1 -O3 -fomit-frame-pointer\"\n  fi\n\n  echo \"CLANG_CXXFLAGS:=$clang_cxxflags\" >> $config_host_mak\n  echo \"LLVMCC:=$clang\" >> $config_host_mak\n  echo \"LLVMCXX:=$clangxx\" >> $config_host_mak\n  echo \"LLVM_LINK:=$llvm_link\" >> $config_host_mak\n  echo \"CONFIG_LLVM=y\" >> $config_host_mak\n  echo \"LLVM_CXXFLAGS=\\$(filter-out $FILTERFLAGS,$llvm_cxxflags)\" >> $config_host_mak\n  echo \"LLVMDIR=$llvmdir\" >> $config_host_mak\nfi\n\nif test \"$xen\" = \"yes\" ; then\n  echo \"CONFIG_XEN_BACKEND=y\" >> $config_host_mak\n  echo \"CONFIG_XEN_CTRL_INTERFACE_VERSION=$xen_ctrl_version\" >> $config_host_mak\n  if test \"$xen_pv_domain_build\" = \"yes\" ; then\n    echo \"CONFIG_XEN_PV_DOMAIN_BUILD=y\" >> $config_host_mak\n  fi\nfi\nif test \"$linux_aio\" = \"yes\" ; then\n  echo \"CONFIG_LINUX_AIO=y\" >> $config_host_mak\nfi\nif test \"$attr\" = \"yes\" ; then\n  echo \"CONFIG_ATTR=y\" >> $config_host_mak\nfi\nif test \"$libattr\" = \"yes\" ; then\n  echo \"CONFIG_LIBATTR=y\" >> $config_host_mak\nfi\nif test \"$virtfs\" = \"yes\" ; then\n  echo \"CONFIG_VIRTFS=y\" >> $config_host_mak\nfi\nif test \"$vhost_scsi\" = \"yes\" ; then\n  echo \"CONFIG_VHOST_SCSI=y\" >> $config_host_mak\nfi\nif test \"$vhost_net\" = \"yes\" ; then\n  echo \"CONFIG_VHOST_NET_USED=y\" >> $config_host_mak\nfi\nif test \"$vhost_vsock\" = \"yes\" ; then\n  echo \"CONFIG_VHOST_VSOCK=y\" >> $config_host_mak\nfi\nif test \"$vhost_user\" = \"yes\" ; then\n  echo \"CONFIG_VHOST_USER_VSOCK=y\" >> $config_host_mak\nfi\nif test \"$blobs\" = \"yes\" ; then\n  echo \"INSTALL_BLOBS=yes\" >> $config_host_mak\nfi\nif test \"$iovec\" = \"yes\" ; then\n  echo \"CONFIG_IOVEC=y\" >> $config_host_mak\nfi\nif test \"$preadv\" = \"yes\" ; then\n  echo \"CONFIG_PREADV=y\" >> $config_host_mak\nfi\nif test \"$fdt\" = \"yes\" ; then\n  echo \"CONFIG_FDT=y\" >> $config_host_mak\nfi\nif test \"$signalfd\" = \"yes\" ; then\n  echo \"CONFIG_SIGNALFD=y\" >> $config_host_mak\nfi\nif test \"$tcg_interpreter\" = \"yes\" ; then\n  echo \"CONFIG_TCG_INTERPRETER=y\" >> $config_host_mak\nfi\nif test \"$protobuf\" = \"yes\" ; then\n  echo \"CONFIG_PROTOBUF=y\" >> $config_host_mak\nfi\nif test \"$fdatasync\" = \"yes\" ; then\n  echo \"CONFIG_FDATASYNC=y\" >> $config_host_mak\nfi\nif test \"$madvise\" = \"yes\" ; then\n  echo \"CONFIG_MADVISE=y\" >> $config_host_mak\nfi\nif test \"$posix_madvise\" = \"yes\" ; then\n  echo \"CONFIG_POSIX_MADVISE=y\" >> $config_host_mak\nfi\n\nif test \"$spice\" = \"yes\" ; then\n  echo \"CONFIG_SPICE=y\" >> $config_host_mak\nfi\n\nif test \"$smartcard\" = \"yes\" ; then\n  echo \"CONFIG_SMARTCARD=y\" >> $config_host_mak\nfi\n\nif test \"$libusb\" = \"yes\" ; then\n  echo \"CONFIG_USB_LIBUSB=y\" >> $config_host_mak\nfi\n\nif test \"$usb_redir\" = \"yes\" ; then\n  echo \"CONFIG_USB_REDIR=y\" >> $config_host_mak\nfi\n\nif test \"$opengl\" = \"yes\" ; then\n  echo \"CONFIG_OPENGL=y\" >> $config_host_mak\n  echo \"OPENGL_LIBS=$opengl_libs\" >> $config_host_mak\n  if test \"$opengl_dmabuf\" = \"yes\" ; then\n    echo \"CONFIG_OPENGL_DMABUF=y\" >> $config_host_mak\n  fi\nfi\n\nif test \"$avx2_opt\" = \"yes\" ; then\n  echo \"CONFIG_AVX2_OPT=y\" >> $config_host_mak\nfi\n\nif test \"$lzo\" = \"yes\" ; then\n  echo \"CONFIG_LZO=y\" >> $config_host_mak\nfi\n\nif test \"$snappy\" = \"yes\" ; then\n  echo \"CONFIG_SNAPPY=y\" >> $config_host_mak\nfi\n\nif test \"$bzip2\" = \"yes\" ; then\n  echo \"CONFIG_BZIP2=y\" >> $config_host_mak\n  echo \"BZIP2_LIBS=-lbz2\" >> $config_host_mak\nfi\n\nif test \"$libiscsi\" = \"yes\" ; then\n  echo \"CONFIG_LIBISCSI=m\" >> $config_host_mak\n  echo \"LIBISCSI_CFLAGS=$libiscsi_cflags\" >> $config_host_mak\n  echo \"LIBISCSI_LIBS=$libiscsi_libs\" >> $config_host_mak\nfi\n\nif test \"$libnfs\" = \"yes\" ; then\n  echo \"CONFIG_LIBNFS=m\" >> $config_host_mak\n  echo \"LIBNFS_LIBS=$libnfs_libs\" >> $config_host_mak\nfi\n\nif test \"$seccomp\" = \"yes\"; then\n  echo \"CONFIG_SECCOMP=y\" >> $config_host_mak\nfi\n\n# XXX: suppress that\nif [ \"$bsd\" = \"yes\" ] ; then\n  echo \"CONFIG_BSD=y\" >> $config_host_mak\nfi\n\nif test \"$localtime_r\" = \"yes\" ; then\n  echo \"CONFIG_LOCALTIME_R=y\" >> $config_host_mak\nfi\nif test \"$qom_cast_debug\" = \"yes\" ; then\n  echo \"CONFIG_QOM_CAST_DEBUG=y\" >> $config_host_mak\nfi\nif test \"$rbd\" = \"yes\" ; then\n  echo \"CONFIG_RBD=m\" >> $config_host_mak\n  echo \"RBD_CFLAGS=$rbd_cflags\" >> $config_host_mak\n  echo \"RBD_LIBS=$rbd_libs\" >> $config_host_mak\nfi\n\necho \"CONFIG_COROUTINE_BACKEND=$coroutine\" >> $config_host_mak\nif test \"$coroutine_pool\" = \"yes\" ; then\n  echo \"CONFIG_COROUTINE_POOL=1\" >> $config_host_mak\nelse\n  echo \"CONFIG_COROUTINE_POOL=0\" >> $config_host_mak\nfi\n\nif test \"$debug_stack_usage\" = \"yes\" ; then\n  echo \"CONFIG_DEBUG_STACK_USAGE=y\" >> $config_host_mak\nfi\n\nif test \"$open_by_handle_at\" = \"yes\" ; then\n  echo \"CONFIG_OPEN_BY_HANDLE=y\" >> $config_host_mak\nfi\n\nif test \"$linux_magic_h\" = \"yes\" ; then\n  echo \"CONFIG_LINUX_MAGIC_H=y\" >> $config_host_mak\nfi\n\nif test \"$pragma_diagnostic_available\" = \"yes\" ; then\n  echo \"CONFIG_PRAGMA_DIAGNOSTIC_AVAILABLE=y\" >> $config_host_mak\nfi\n\nif test \"$valgrind_h\" = \"yes\" ; then\n  echo \"CONFIG_VALGRIND_H=y\" >> $config_host_mak\nfi\n\nif test \"$has_environ\" = \"yes\" ; then\n  echo \"CONFIG_HAS_ENVIRON=y\" >> $config_host_mak\nfi\n\nif test \"$cpuid_h\" = \"yes\" ; then\n  echo \"CONFIG_CPUID_H=y\" >> $config_host_mak\nfi\n\nif test \"$int128\" = \"yes\" ; then\n  echo \"CONFIG_INT128=y\" >> $config_host_mak\nfi\n\nif test \"$atomic128\" = \"yes\" ; then\n  echo \"CONFIG_ATOMIC128=y\" >> $config_host_mak\nfi\n\nif test \"$atomic64\" = \"yes\" ; then\n  echo \"CONFIG_ATOMIC64=y\" >> $config_host_mak\nfi\n\nif test \"$getauxval\" = \"yes\" ; then\n  echo \"CONFIG_GETAUXVAL=y\" >> $config_host_mak\nfi\n\nif test \"$glusterfs\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS=m\" >> $config_host_mak\n  echo \"GLUSTERFS_CFLAGS=$glusterfs_cflags\" >> $config_host_mak\n  echo \"GLUSTERFS_LIBS=$glusterfs_libs\" >> $config_host_mak\nfi\n\nif test \"$glusterfs_xlator_opt\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS_XLATOR_OPT=y\" >> $config_host_mak\nfi\n\nif test \"$glusterfs_discard\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS_DISCARD=y\" >> $config_host_mak\nfi\n\nif test \"$glusterfs_zerofill\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS_ZEROFILL=y\" >> $config_host_mak\nfi\n\nif test \"$glusterfs_ftruncate_has_stat\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS_FTRUNCATE_HAS_STAT=y\" >> $config_host_mak\nfi\n\nif test \"$glusterfs_iocb_has_stat\" = \"yes\" ; then\n  echo \"CONFIG_GLUSTERFS_IOCB_HAS_STAT=y\" >> $config_host_mak\nfi\n\nif test \"$libssh2\" = \"yes\" ; then\n  echo \"CONFIG_LIBSSH2=m\" >> $config_host_mak\n  echo \"LIBSSH2_CFLAGS=$libssh2_cflags\" >> $config_host_mak\n  echo \"LIBSSH2_LIBS=$libssh2_libs\" >> $config_host_mak\nfi\n\n# USB host support\nif test \"$libusb\" = \"yes\"; then\n  echo \"HOST_USB=libusb legacy\" >> $config_host_mak\nelse\n  echo \"HOST_USB=stub\" >> $config_host_mak\nfi\n\n# TPM passthrough support?\nif test \"$tpm\" = \"yes\"; then\n  echo 'CONFIG_TPM=$(CONFIG_SOFTMMU)' >> $config_host_mak\n  if test \"$tpm_passthrough\" = \"yes\"; then\n    echo \"CONFIG_TPM_PASSTHROUGH=y\" >> $config_host_mak\n  fi\nfi\n\necho \"TRACE_BACKENDS=$trace_backends\" >> $config_host_mak\nif have_backend \"nop\"; then\n  echo \"CONFIG_TRACE_NOP=y\" >> $config_host_mak\nfi\nif have_backend \"simple\"; then\n  echo \"CONFIG_TRACE_SIMPLE=y\" >> $config_host_mak\n  # Set the appropriate trace file.\n  trace_file=\"\\\"$trace_file-\\\" FMT_pid\"\nfi\nif have_backend \"log\"; then\n  echo \"CONFIG_TRACE_LOG=y\" >> $config_host_mak\nfi\nif have_backend \"ust\"; then\n  echo \"CONFIG_TRACE_UST=y\" >> $config_host_mak\nfi\nif have_backend \"dtrace\"; then\n  echo \"CONFIG_TRACE_DTRACE=y\" >> $config_host_mak\n  if test \"$trace_backend_stap\" = \"yes\" ; then\n    echo \"CONFIG_TRACE_SYSTEMTAP=y\" >> $config_host_mak\n  fi\nfi\nif have_backend \"ftrace\"; then\n  if test \"$linux\" = \"yes\" ; then\n    echo \"CONFIG_TRACE_FTRACE=y\" >> $config_host_mak\n  else\n    feature_not_found \"ftrace(trace backend)\" \"ftrace requires Linux\"\n  fi\nfi\nif have_backend \"syslog\"; then\n  if test \"$posix_syslog\" = \"yes\" ; then\n    echo \"CONFIG_TRACE_SYSLOG=y\" >> $config_host_mak\n  else\n    feature_not_found \"syslog(trace backend)\" \"syslog not available\"\n  fi\nfi\necho \"CONFIG_TRACE_FILE=$trace_file\" >> $config_host_mak\n\nif test \"$rdma\" = \"yes\" ; then\n  echo \"CONFIG_RDMA=y\" >> $config_host_mak\nfi\n\nif test \"$have_rtnetlink\" = \"yes\" ; then\n  echo \"CONFIG_RTNETLINK=y\" >> $config_host_mak\nfi\n\nif test \"$replication\" = \"yes\" ; then\n  echo \"CONFIG_REPLICATION=y\" >> $config_host_mak\nfi\n\nif test \"$pyperipheral2\" = \"yes\" ; then\n  QEMU_INCLUDES=\"`pkg-config --cflags-only-I python2` $QEMU_INCLUDES\"\n  LIBS=\"`pkg-config --libs python2` $LIBS\"\nfi\n\nif test \"$pyperipheral3\" = \"yes\" ; then\n  QEMU_INCLUDES=\"`pkg-config --cflags-only-I python3` $QEMU_INCLUDES\"\n  LIBS=\"`pkg-config --libs python3` $LIBS\"\nfi\n\n\n\nif test \"$have_af_vsock\" = \"yes\" ; then\n  echo \"CONFIG_AF_VSOCK=y\" >> $config_host_mak\nfi\n\nif test \"$have_sysmacros\" = \"yes\" ; then\n  echo \"CONFIG_SYSMACROS=y\" >> $config_host_mak\nfi\n\nif test \"$capstone\" = \"yes\" ; then\n  echo \"CONFIG_CAPSTONE=y\" >> $config_host_mak\nfi\n\n# Hold two types of flag:\n#   CONFIG_THREAD_SETNAME_BYTHREAD  - we've got a way of setting the name on\n#                                     a thread we have a handle to\n#   CONFIG_PTHREAD_SETNAME_NP       - A way of doing it on a particular\n#                                     platform\nif test \"$pthread_setname_np\" = \"yes\" ; then\n  echo \"CONFIG_THREAD_SETNAME_BYTHREAD=y\" >> $config_host_mak\n  echo \"CONFIG_PTHREAD_SETNAME_NP=y\" >> $config_host_mak\nfi\n\nif test \"$tcg_interpreter\" = \"yes\"; then\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/tci $QEMU_INCLUDES\"\nelif test \"$ARCH\" = \"sparc64\" ; then\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/sparc $QEMU_INCLUDES\"\nelif test \"$ARCH\" = \"s390x\" ; then\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/s390 $QEMU_INCLUDES\"\nelif test \"$ARCH\" = \"x86_64\" -o \"$ARCH\" = \"x32\" ; then\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/i386 $QEMU_INCLUDES\"\nelif test \"$ARCH\" = \"ppc64\" ; then\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/ppc $QEMU_INCLUDES\"\nelse\n  QEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg/\\$(ARCH) $QEMU_INCLUDES\"\nfi\nQEMU_INCLUDES=\"-iquote \\$(SRC_PATH)/tcg $QEMU_INCLUDES\"\n\necho \"TOOLS=$tools\" >> $config_host_mak\necho \"ROMS=$roms\" >> $config_host_mak\necho \"MAKE=$make\" >> $config_host_mak\necho \"INSTALL=$install\" >> $config_host_mak\necho \"INSTALL_DIR=$install -d -m 0755\" >> $config_host_mak\necho \"INSTALL_DATA=$install -c -m 0644\" >> $config_host_mak\necho \"INSTALL_PROG=$install -c -m 0755\" >> $config_host_mak\necho \"INSTALL_LIB=$install -c -m 0644\" >> $config_host_mak\necho \"PYTHON=$python\" >> $config_host_mak\necho \"CC=$cc\" >> $config_host_mak\nif $iasl -h > /dev/null 2>&1; then\n  echo \"IASL=$iasl\" >> $config_host_mak\nfi\necho \"CC_I386=$cc_i386\" >> $config_host_mak\necho \"HOST_CC=$host_cc\" >> $config_host_mak\necho \"CXX=$cxx\" >> $config_host_mak\necho \"OBJCC=$objcc\" >> $config_host_mak\necho \"AR=$ar\" >> $config_host_mak\necho \"ARFLAGS=$ARFLAGS\" >> $config_host_mak\necho \"AS=$as\" >> $config_host_mak\necho \"CCAS=$ccas\" >> $config_host_mak\necho \"CPP=$cpp\" >> $config_host_mak\necho \"OBJCOPY=$objcopy\" >> $config_host_mak\necho \"LD=$ld\" >> $config_host_mak\necho \"NM=$nm\" >> $config_host_mak\necho \"WINDRES=$windres\" >> $config_host_mak\necho \"CFLAGS=$CFLAGS\" >> $config_host_mak\necho \"CFLAGS_NOPIE=$CFLAGS_NOPIE\" >> $config_host_mak\necho \"QEMU_CFLAGS=$QEMU_CFLAGS\" >> $config_host_mak\necho \"QEMU_CXXFLAGS=$QEMU_CXXFLAGS\" >> $config_host_mak\necho \"QEMU_INCLUDES=$QEMU_INCLUDES\" >> $config_host_mak\nif test \"$sparse\" = \"yes\" ; then\n  echo \"CC           := REAL_CC=\\\"\\$(CC)\\\" cgcc\"       >> $config_host_mak\n  echo \"CPP          := REAL_CC=\\\"\\$(CPP)\\\" cgcc\"      >> $config_host_mak\n  echo \"CXX          := REAL_CC=\\\"\\$(CXX)\\\" cgcc\"      >> $config_host_mak\n  echo \"HOST_CC      := REAL_CC=\\\"\\$(HOST_CC)\\\" cgcc\"  >> $config_host_mak\n  echo \"QEMU_CFLAGS  += -Wbitwise -Wno-transparent-union -Wno-old-initializer -Wno-non-pointer-null\" >> $config_host_mak\nfi\nif test \"$cross_prefix\" != \"\"; then\n  echo \"AUTOCONF_HOST := --host=${cross_prefix%-}\"     >> $config_host_mak\nelse\n  echo \"AUTOCONF_HOST := \"                             >> $config_host_mak\nfi\necho \"LDFLAGS=$LDFLAGS\" >> $config_host_mak\necho \"LDFLAGS_NOPIE=$LDFLAGS_NOPIE\" >> $config_host_mak\necho \"QEMU_LDFLAGS=$QEMU_LDFLAGS\" >> $config_host_mak\necho \"LD_REL_FLAGS=$LD_REL_FLAGS\" >> $config_host_mak\necho \"LD_I386_EMULATION=$ld_i386_emulation\" >> $config_host_mak\necho \"LIBS+=$LIBS\" >> $config_host_mak\necho \"LIBS_TOOLS+=$libs_tools\" >> $config_host_mak\necho \"PTHREAD_LIB=$PTHREAD_LIB\" >> $config_host_mak\necho \"EXESUF=$EXESUF\" >> $config_host_mak\necho \"DSOSUF=$DSOSUF\" >> $config_host_mak\necho \"LDFLAGS_SHARED=$LDFLAGS_SHARED\" >> $config_host_mak\necho \"LIBS_QGA+=$libs_qga\" >> $config_host_mak\necho \"TASN1_LIBS=$tasn1_libs\" >> $config_host_mak\necho \"TASN1_CFLAGS=$tasn1_cflags\" >> $config_host_mak\necho \"POD2MAN=$POD2MAN\" >> $config_host_mak\necho \"TRANSLATE_OPT_CFLAGS=$TRANSLATE_OPT_CFLAGS\" >> $config_host_mak\nif test \"$gcov\" = \"yes\" ; then\n  echo \"CONFIG_GCOV=y\" >> $config_host_mak\n  echo \"GCOV=$gcov_tool\" >> $config_host_mak\nfi\n\n# use included Linux headers\nif test \"$linux\" = \"yes\" ; then\n  mkdir -p linux-headers\n  case \"$cpu\" in\n  i386|x86_64|x32)\n    linux_arch=x86\n    ;;\n  ppcemb|ppc|ppc64)\n    linux_arch=powerpc\n    ;;\n  s390x)\n    linux_arch=s390\n    ;;\n  aarch64)\n    linux_arch=arm64\n    ;;\n  mips64)\n    linux_arch=mips\n    ;;\n  *)\n    # For most CPUs the kernel architecture name and QEMU CPU name match.\n    linux_arch=\"$cpu\"\n    ;;\n  esac\n    # For non-KVM architectures we will not have asm headers\n    if [ -e \"$source_path/linux-headers/asm-$linux_arch\" ]; then\n      symlink \"$source_path/linux-headers/asm-$linux_arch\" linux-headers/asm\n    fi\nfi\n\nfor target in $target_list; do\ntarget_dir=\"$target\"\nconfig_target_mak=$target_dir/config-target.mak\ntarget_name=$(echo $target | cut -d '-' -f 1)\ntarget_bigendian=\"no\"\n\ncase \"$target_name\" in\n  armeb|hppa|lm32|m68k|microblaze|mips|mipsn32|mips64|moxie|or1k|ppc|ppcemb|ppc64|ppc64abi32|s390x|sh4eb|sparc|sparc64|sparc32plus|xtensaeb)\n  target_bigendian=yes\n  ;;\nesac\ntarget_softmmu=\"no\"\ntarget_user_only=\"no\"\ntarget_linux_user=\"no\"\ntarget_bsd_user=\"no\"\ncase \"$target\" in\n  ${target_name}-softmmu)\n    target_softmmu=\"yes\"\n    ;;\n  ${target_name}-linux-user)\n    if test \"$linux\" != \"yes\" ; then\n      error_exit \"Target '$target' is only available on a Linux host\"\n    fi\n    target_user_only=\"yes\"\n    target_linux_user=\"yes\"\n    ;;\n  ${target_name}-bsd-user)\n    if test \"$bsd\" != \"yes\" ; then\n      error_exit \"Target '$target' is only available on a BSD host\"\n    fi\n    target_user_only=\"yes\"\n    target_bsd_user=\"yes\"\n    ;;\n  *)\n    error_exit \"Target '$target' not recognised\"\n    exit 1\n    ;;\nesac\n\nmkdir -p $target_dir\necho \"# Automatically generated by configure - do not modify\" > $config_target_mak\n\nbflt=\"no\"\nmttcg=\"no\"\ninterp_prefix1=$(echo \"$interp_prefix\" | sed \"s/%M/$target_name/g\")\ngdb_xml_files=\"\"\n\nTARGET_ARCH=\"$target_name\"\nTARGET_BASE_ARCH=\"\"\nTARGET_ABI_DIR=\"\"\n\ncase \"$target_name\" in\n  i386)\n    gdb_xml_files=\"i386-32bit-core.xml\"\n  ;;\n  x86_64)\n    TARGET_BASE_ARCH=i386\n    gdb_xml_files=\"i386-64bit-core.xml\"\n  ;;\n  alpha)\n    mttcg=\"yes\"\n  ;;\n  arm|armeb)\n    TARGET_ARCH=arm\n    bflt=\"yes\"\n    mttcg=\"yes\"\n    gdb_xml_files=\"arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml arm-banked.xml\"\n  ;;\n  aarch64)\n    TARGET_BASE_ARCH=arm\n    bflt=\"yes\"\n    mttcg=\"yes\"\n    gdb_xml_files=\"aarch64-core.xml aarch64-fpu.xml arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml\"\n  ;;\n  cris)\n  ;;\n  hppa)\n  ;;\n  lm32)\n  ;;\n  m68k)\n    bflt=\"yes\"\n    gdb_xml_files=\"cf-core.xml cf-fp.xml\"\n  ;;\n  microblaze|microblazeel)\n    TARGET_ARCH=microblaze\n    bflt=\"yes\"\n  ;;\n  mips|mipsel)\n    TARGET_ARCH=mips\n    echo \"TARGET_ABI_MIPSO32=y\" >> $config_target_mak\n  ;;\n  mipsn32|mipsn32el)\n    TARGET_ARCH=mips64\n    TARGET_BASE_ARCH=mips\n    echo \"TARGET_ABI_MIPSN32=y\" >> $config_target_mak\n    echo \"TARGET_ABI32=y\" >> $config_target_mak\n  ;;\n  mips64|mips64el)\n    TARGET_ARCH=mips64\n    TARGET_BASE_ARCH=mips\n    echo \"TARGET_ABI_MIPSN64=y\" >> $config_target_mak\n  ;;\n  moxie)\n  ;;\n  nios2)\n  ;;\n  or1k)\n    TARGET_ARCH=openrisc\n    TARGET_BASE_ARCH=openrisc\n  ;;\n  ppc)\n    gdb_xml_files=\"power-core.xml power-fpu.xml power-altivec.xml power-spe.xml\"\n  ;;\n  ppcemb)\n    TARGET_BASE_ARCH=ppc\n    TARGET_ABI_DIR=ppc\n    gdb_xml_files=\"power-core.xml power-fpu.xml power-altivec.xml power-spe.xml\"\n  ;;\n  ppc64)\n    TARGET_BASE_ARCH=ppc\n    TARGET_ABI_DIR=ppc\n    gdb_xml_files=\"power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml power-vsx.xml\"\n  ;;\n  ppc64le)\n    TARGET_ARCH=ppc64\n    TARGET_BASE_ARCH=ppc\n    TARGET_ABI_DIR=ppc\n    gdb_xml_files=\"power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml power-vsx.xml\"\n  ;;\n  ppc64abi32)\n    TARGET_ARCH=ppc64\n    TARGET_BASE_ARCH=ppc\n    TARGET_ABI_DIR=ppc\n    echo \"TARGET_ABI32=y\" >> $config_target_mak\n    gdb_xml_files=\"power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml power-vsx.xml\"\n  ;;\n  sh4|sh4eb)\n    TARGET_ARCH=sh4\n    bflt=\"yes\"\n  ;;\n  sparc)\n  ;;\n  sparc64)\n    TARGET_BASE_ARCH=sparc\n  ;;\n  sparc32plus)\n    TARGET_ARCH=sparc64\n    TARGET_BASE_ARCH=sparc\n    TARGET_ABI_DIR=sparc\n    echo \"TARGET_ABI32=y\" >> $config_target_mak\n  ;;\n  s390x)\n    gdb_xml_files=\"s390x-core64.xml s390-acr.xml s390-fpr.xml s390-vx.xml s390-cr.xml s390-virt.xml\"\n  ;;\n  tilegx)\n  ;;\n  tricore)\n  ;;\n  unicore32)\n  ;;\n  xtensa|xtensaeb)\n    TARGET_ARCH=xtensa\n  ;;\n  *)\n    error_exit \"Unsupported target CPU\"\n  ;;\nesac\n# TARGET_BASE_ARCH needs to be defined after TARGET_ARCH\nif [ \"$TARGET_BASE_ARCH\" = \"\" ]; then\n  TARGET_BASE_ARCH=$TARGET_ARCH\nfi\n\nsymlink \"$source_path/Makefile.target\" \"$target_dir/Makefile\"\n\nupper() {\n    echo \"$@\"| LC_ALL=C tr '[a-z]' '[A-Z]'\n}\n\ntarget_arch_name=\"$(upper $TARGET_ARCH)\"\necho \"TARGET_$target_arch_name=y\" >> $config_target_mak\necho \"TARGET_NAME=$target_name\" >> $config_target_mak\necho \"TARGET_BASE_ARCH=$TARGET_BASE_ARCH\" >> $config_target_mak\nif [ \"$TARGET_ABI_DIR\" = \"\" ]; then\n  TARGET_ABI_DIR=$TARGET_ARCH\nfi\necho \"TARGET_ABI_DIR=$TARGET_ABI_DIR\" >> $config_target_mak\nif [ \"$HOST_VARIANT_DIR\" != \"\" ]; then\n    echo \"HOST_VARIANT_DIR=$HOST_VARIANT_DIR\" >> $config_target_mak\nfi\ncase \"$target_name\" in\n  i386|x86_64)\n    if test \"$xen\" = \"yes\" -a \"$target_softmmu\" = \"yes\" ; then\n      echo \"CONFIG_XEN=y\" >> $config_target_mak\n      if test \"$xen_pci_passthrough\" = yes; then\n        echo \"CONFIG_XEN_PCI_PASSTHROUGH=y\" >> \"$config_target_mak\"\n      fi\n    fi\n    ;;\n  *)\nesac\ncase \"$target_name\" in\n  aarch64|arm|i386|x86_64|ppcemb|ppc|ppc64|s390x|mipsel|mips)\n    # Make sure the target and host cpus are compatible\n    if test \"$kvm\" = \"yes\" -a \"$target_softmmu\" = \"yes\" -a \\\n      \\( \"$target_name\" = \"$cpu\" -o \\\n      \\( \"$target_name\" = \"ppcemb\" -a \"$cpu\" = \"ppc\" \\) -o \\\n      \\( \"$target_name\" = \"ppc64\"  -a \"$cpu\" = \"ppc\" \\) -o \\\n      \\( \"$target_name\" = \"ppc\"    -a \"$cpu\" = \"ppc64\" \\) -o \\\n      \\( \"$target_name\" = \"ppcemb\" -a \"$cpu\" = \"ppc64\" \\) -o \\\n      \\( \"$target_name\" = \"mipsel\" -a \"$cpu\" = \"mips\" \\) -o \\\n      \\( \"$target_name\" = \"x86_64\" -a \"$cpu\" = \"i386\"   \\) -o \\\n      \\( \"$target_name\" = \"i386\"   -a \"$cpu\" = \"x86_64\" \\) -o \\\n      \\( \"$target_name\" = \"x86_64\" -a \"$cpu\" = \"x32\"   \\) -o \\\n      \\( \"$target_name\" = \"i386\"   -a \"$cpu\" = \"x32\" \\) \\) ; then\n      echo \"CONFIG_KVM=y\" >> $config_target_mak\n      if test \"$vhost_net\" = \"yes\" ; then\n        echo \"CONFIG_VHOST_NET=y\" >> $config_target_mak\n        echo \"CONFIG_VHOST_NET_TEST_$target_name=y\" >> $config_host_mak\n      fi\n    fi\nesac\nif test \"$hax\" = \"yes\" ; then\n  if test \"$target_softmmu\" = \"yes\" ; then\n    case \"$target_name\" in\n    i386|x86_64)\n      echo \"CONFIG_HAX=y\" >> $config_target_mak\n    ;;\n    esac\n  fi\nfi\nif test \"$target_bigendian\" = \"yes\" ; then\n  echo \"TARGET_WORDS_BIGENDIAN=y\" >> $config_target_mak\nfi\nif test \"$target_softmmu\" = \"yes\" ; then\n  echo \"CONFIG_SOFTMMU=y\" >> $config_target_mak\n  if test \"$mttcg\" = \"yes\" ; then\n    echo \"TARGET_SUPPORTS_MTTCG=y\" >> $config_target_mak\n  fi\nfi\nif test \"$target_user_only\" = \"yes\" ; then\n  echo \"CONFIG_USER_ONLY=y\" >> $config_target_mak\n  echo \"CONFIG_QEMU_INTERP_PREFIX=\\\"$interp_prefix1\\\"\" >> $config_target_mak\nfi\nif test \"$target_linux_user\" = \"yes\" ; then\n  echo \"CONFIG_LINUX_USER=y\" >> $config_target_mak\nfi\n\nif [ \"$llvm\" = \"yes\" ]; then\n   echo \"LIBS:=$llvm_libs $llvm_ldflags \\$(LIBS)\" >> $config_target_mak\nfi\n\nlist=\"\"\nif test ! -z \"$gdb_xml_files\" ; then\n  for x in $gdb_xml_files; do\n    list=\"$list $source_path/gdb-xml/$x\"\n  done\n  echo \"TARGET_XML_FILES=$list\" >> $config_target_mak\nfi\n\nif test \"$target_user_only\" = \"yes\" -a \"$bflt\" = \"yes\"; then\n  echo \"TARGET_HAS_BFLT=y\" >> $config_target_mak\nfi\nif test \"$target_bsd_user\" = \"yes\" ; then\n  echo \"CONFIG_BSD_USER=y\" >> $config_target_mak\nfi\n\n# generate QEMU_CFLAGS/LDFLAGS for targets\n\ncflags=\"\"\nldflags=\"\"\n\ndisas_config() {\n  echo \"CONFIG_${1}_DIS=y\" >> $config_target_mak\n  echo \"CONFIG_${1}_DIS=y\" >> config-all-disas.mak\n}\n\nfor i in $ARCH $TARGET_BASE_ARCH ; do\n  case \"$i\" in\n  alpha)\n    disas_config \"ALPHA\"\n  ;;\n  aarch64)\n    if test -n \"${cxx}\"; then\n      disas_config \"ARM_A64\"\n    fi\n  ;;\n  arm)\n    disas_config \"ARM\"\n    if test -n \"${cxx}\"; then\n      disas_config \"ARM_A64\"\n    fi\n  ;;\n  cris)\n    disas_config \"CRIS\"\n  ;;\n  hppa)\n    disas_config \"HPPA\"\n  ;;\n  i386|x86_64|x32)\n    disas_config \"I386\"\n  ;;\n  lm32)\n    disas_config \"LM32\"\n  ;;\n  m68k)\n    disas_config \"M68K\"\n  ;;\n  microblaze*)\n    disas_config \"MICROBLAZE\"\n  ;;\n  mips*)\n    disas_config \"MIPS\"\n  ;;\n  moxie*)\n    disas_config \"MOXIE\"\n  ;;\n  nios2)\n    disas_config \"NIOS2\"\n  ;;\n  or1k)\n    disas_config \"OPENRISC\"\n  ;;\n  ppc*)\n    disas_config \"PPC\"\n  ;;\n  s390*)\n    disas_config \"S390\"\n  ;;\n  sh4)\n    disas_config \"SH4\"\n  ;;\n  sparc*)\n    disas_config \"SPARC\"\n  ;;\n  xtensa*)\n    disas_config \"XTENSA\"\n  ;;\n  esac\ndone\nif test \"$tcg_interpreter\" = \"yes\" ; then\n  disas_config \"TCI\"\nfi\n\ncase \"$ARCH\" in\nalpha)\n  # Ensure there's only a single GP\n  cflags=\"-msmall-data $cflags\"\n;;\nesac\n\nif test \"$gprof\" = \"yes\" ; then\n  echo \"TARGET_GPROF=yes\" >> $config_target_mak\n  if test \"$target_linux_user\" = \"yes\" ; then\n    cflags=\"-p $cflags\"\n    ldflags=\"-p $ldflags\"\n  fi\n  if test \"$target_softmmu\" = \"yes\" ; then\n    ldflags=\"-p $ldflags\"\n    echo \"GPROF_CFLAGS=-p\" >> $config_target_mak\n  fi\nfi\n\nif test \"$target_linux_user\" = \"yes\" -o \"$target_bsd_user\" = \"yes\" ; then\n  ldflags=\"$ldflags $textseg_ldflags\"\nfi\n\necho \"LDFLAGS+=$ldflags\" >> $config_target_mak\necho \"QEMU_CFLAGS+=$cflags\" >> $config_target_mak\n\ndone # for target in $targets\n\nif [ \"$pixman\" = \"internal\" ]; then\n  echo \"config-host.h: subdir-pixman\" >> $config_host_mak\nfi\n\nif [ \"$dtc_internal\" = \"yes\" ]; then\n  echo \"config-host.h: subdir-dtc\" >> $config_host_mak\nfi\n\nif test \"$numa\" = \"yes\"; then\n  echo \"CONFIG_NUMA=y\" >> $config_host_mak\nfi\n\nif test \"$ccache_cpp2\" = \"yes\"; then\n  echo \"export CCACHE_CPP2=y\" >> $config_host_mak\nfi\n\n\nif test \"$pyperipheral2\" = \"yes\" || test \"$pyperipheral3\" = \"yes\" ; then\n  echo \"CONFIG_PYPERIPHERAL=y\" >> $config_target_mak\n\n  if test \"$pyperipheral3\" = \"yes\" ; then\n    # Need to update libraries and ldflags to link against python.\n    # Python >3.8 should generate these flags with --embed, but that's not backwards\n    # compatable, so we use this grep to detect failures (since it exits cleanly\n    # and prints an error to stdout).\n    echo \"libs_softmmu+=$(python3-config --libs    --embed | grep -v Usage || python3-config --libs)\"     >> $config_host_mak\n    echo      \"LDFLAGS+=$(python3-config --ldflags --embed | grep -v Usage || python3-config --ldflags )\" >> $config_host_mak\n  else\n    # TODO: how should this link? Python2-config? Can we just remove?\n    echo \"WARNING: python2 pyperipheral is likely missing required LDFLAGS\"\n  fi\n\nfi\n\n# build tree in object directory in case the source is not in the current directory\nDIRS=\"tests tests/tcg tests/tcg/cris tests/tcg/lm32 tests/libqos tests/qapi-schema tests/tcg/xtensa tests/qemu-iotests\"\nDIRS=\"$DIRS docs fsdev\"\nDIRS=\"$DIRS pc-bios/optionrom pc-bios/spapr-rtas pc-bios/s390-ccw\"\nDIRS=\"$DIRS roms/seabios roms/vgabios\"\nDIRS=\"$DIRS qapi-generated\"\nFILES=\"Makefile tests/tcg/Makefile qdict-test-data.txt\"\nFILES=\"$FILES tests/tcg/cris/Makefile tests/tcg/cris/.gdbinit\"\nFILES=\"$FILES tests/tcg/lm32/Makefile tests/tcg/xtensa/Makefile po/Makefile\"\nFILES=\"$FILES pc-bios/optionrom/Makefile pc-bios/keymaps\"\nFILES=\"$FILES pc-bios/spapr-rtas/Makefile\"\nFILES=\"$FILES pc-bios/s390-ccw/Makefile\"\nFILES=\"$FILES roms/seabios/Makefile roms/vgabios/Makefile\"\nFILES=\"$FILES pc-bios/qemu-icon.bmp\"\nfor bios_file in \\\n    $source_path/pc-bios/*.bin \\\n    $source_path/pc-bios/*.lid \\\n    $source_path/pc-bios/*.aml \\\n    $source_path/pc-bios/*.rom \\\n    $source_path/pc-bios/*.dtb \\\n    $source_path/pc-bios/*.img \\\n    $source_path/pc-bios/openbios-* \\\n    $source_path/pc-bios/u-boot.* \\\n    $source_path/pc-bios/palcode-*\ndo\n    FILES=\"$FILES pc-bios/$(basename $bios_file)\"\ndone\nfor test_file in $(find $source_path/tests/acpi-test-data -type f)\ndo\n    FILES=\"$FILES tests/acpi-test-data$(echo $test_file | sed -e 's/.*acpi-test-data//')\"\ndone\nmkdir -p $DIRS\nfor f in $FILES ; do\n    if [ -e \"$source_path/$f\" ] && [ \"$pwd_is_source_path\" != \"y\" ]; then\n        symlink \"$source_path/$f\" \"$f\"\n    fi\ndone\n\n# temporary config to build submodules\nfor rom in seabios vgabios ; do\n    config_mak=roms/$rom/config.mak\n    echo \"# Automatically generated by configure - do not modify\" > $config_mak\n    echo \"SRC_PATH=$source_path/roms/$rom\" >> $config_mak\n    echo \"AS=$as\" >> $config_mak\n    echo \"CCAS=$ccas\" >> $config_mak\n    echo \"CC=$cc\" >> $config_mak\n    echo \"BCC=bcc\" >> $config_mak\n    echo \"CPP=$cpp\" >> $config_mak\n    echo \"OBJCOPY=objcopy\" >> $config_mak\n    echo \"IASL=$iasl\" >> $config_mak\n    echo \"LD=$ld\" >> $config_mak\ndone\n\n# set up tests data directory\nif [ ! -e tests/data ]; then\n    symlink \"$source_path/tests/data\" tests/data\nfi\n\n# set up qemu-iotests in this build directory\niotests_common_env=\"tests/qemu-iotests/common.env\"\niotests_check=\"tests/qemu-iotests/check\"\n\necho \"# Automatically generated by configure - do not modify\" > \"$iotests_common_env\"\necho >> \"$iotests_common_env\"\necho \"export PYTHON='$python'\" >> \"$iotests_common_env\"\n\nif [ ! -e \"$iotests_check\" ]; then\n    symlink \"$source_path/$iotests_check\" \"$iotests_check\"\nfi\n\n# Save the configure command line for later reuse.\ncat <<EOD >config.status\n#!/bin/sh\n# Generated by configure.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\nEOD\n\npreserve_env() {\n    envname=$1\n\n    eval envval=\\$$envname\n\n    if test -n \"$envval\"\n    then\n\techo \"$envname='$envval'\" >> config.status\n\techo \"export $envname\" >> config.status\n    else\n\techo \"unset $envname\" >> config.status\n    fi\n}\n\n# Preserve various env variables that influence what\n# features/build target configure will detect\npreserve_env AR\npreserve_env AS\npreserve_env CC\npreserve_env CPP\npreserve_env CXX\npreserve_env INSTALL\npreserve_env LD\npreserve_env LD_LIBRARY_PATH\npreserve_env LIBTOOL\npreserve_env MAKE\npreserve_env NM\npreserve_env OBJCOPY\npreserve_env PATH\npreserve_env PKG_CONFIG\npreserve_env PKG_CONFIG_LIBDIR\npreserve_env PKG_CONFIG_PATH\npreserve_env PYTHON\npreserve_env SDL_CONFIG\npreserve_env SDL2_CONFIG\npreserve_env SMBD\npreserve_env STRIP\npreserve_env WINDRES\n\nprintf \"exec\" >>config.status\nprintf \" '%s'\" \"$0\" \"$@\" >>config.status\necho ' \"$@\"' >>config.status\nchmod +x config.status\n\nrm -r \"$TMPDIR1\"\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpu-exec-common.c",
          "type": "blob",
          "size": 2.8115234375,
          "content": "/*\n *  emulator main execution loop\n *\n *  Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"cpu.h\"\n#include \"sysemu/cpus.h\"\n#include \"exec/exec-all.h\"\n#include \"exec/memory-internal.h\"\n\n/* exit the current TB, but without causing any exception to be raised */\nvoid cpu_loop_exit_noexc(CPUState *cpu)\n{\n    /* XXX: restore cpu registers saved in host registers */\n\n    cpu->exception_index = -1;\n    siglongjmp(cpu->jmp_env, 1);\n}\n\n#if defined(CONFIG_SOFTMMU)\nvoid cpu_reloading_memory_map(void)\n{\n    if (qemu_in_vcpu_thread() && current_cpu->running) {\n        /* The guest can in theory prolong the RCU critical section as long\n         * as it feels like. The major problem with this is that because it\n         * can do multiple reconfigurations of the memory map within the\n         * critical section, we could potentially accumulate an unbounded\n         * collection of memory data structures awaiting reclamation.\n         *\n         * Because the only thing we're currently protecting with RCU is the\n         * memory data structures, it's sufficient to break the critical section\n         * in this callback, which we know will get called every time the\n         * memory map is rearranged.\n         *\n         * (If we add anything else in the system that uses RCU to protect\n         * its data structures, we will need to implement some other mechanism\n         * to force TCG CPUs to exit the critical section, at which point this\n         * part of this callback might become unnecessary.)\n         *\n         * This pair matches cpu_exec's rcu_read_lock()/rcu_read_unlock(), which\n         * only protects cpu->as->dispatch. Since we know our caller is about\n         * to reload it, it's safe to split the critical section.\n         */\n        rcu_read_unlock();\n        rcu_read_lock();\n    }\n}\n#endif\n\nvoid cpu_loop_exit(CPUState *cpu)\n{\n    siglongjmp(cpu->jmp_env, 1);\n}\n\nvoid cpu_loop_exit_restore(CPUState *cpu, uintptr_t pc)\n{\n    if (pc) {\n        cpu_restore_state(cpu, pc);\n    }\n    siglongjmp(cpu->jmp_env, 1);\n}\n\nvoid cpu_loop_exit_atomic(CPUState *cpu, uintptr_t pc)\n{\n    cpu->exception_index = EXCP_ATOMIC;\n    cpu_loop_exit_restore(cpu, pc);\n}\n"
        },
        {
          "name": "cpu-exec.c",
          "type": "blob",
          "size": 27.3759765625,
          "content": "/*\n *  emulator main execution loop\n *\n *  Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"qemu/osdep.h\"\n#include \"cpu.h\"\n#include \"trace-root.h\"\n#include \"disas/disas.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg.h\"\n#include \"qemu/atomic.h\"\n#include \"sysemu/qtest.h\"\n#include \"qemu/timer.h\"\n#include \"exec/address-spaces.h\"\n#include \"qemu/rcu.h\"\n#include \"exec/tb-hash.h\"\n#include \"exec/log.h\"\n#if defined(TARGET_I386) && !defined(CONFIG_USER_ONLY)\n#include \"hw/i386/apic.h\"\n#endif\n#include \"sysemu/cpus.h\"\n#include \"sysemu/replay.h\"\n#include \"sysemu/sysemu.h\"\n#include \"panda/rr/rr_log.h\"\n#include \"panda/callbacks/cb-support.h\"\n#include \"panda/common.h\"\n\n#ifdef CONFIG_LLVM\n#include \"panda/tcg-llvm.h\"\nconst int has_llvm_engine = 1;\n#endif\n\nint generate_llvm = 0;\nint execute_llvm = 0;\nextern bool panda_tb_chaining;\n\n/* -icount align implementation. */\n\ntypedef struct SyncClocks {\n    int64_t diff_clk;\n    int64_t last_cpu_icount;\n    int64_t realtime_clock;\n} SyncClocks;\n\n#if !defined(CONFIG_USER_ONLY)\n/* Allow the guest to have a max 3ms advance.\n * The difference between the 2 clocks could therefore\n * oscillate around 0.\n */\n#define VM_CLOCK_ADVANCE 3000000\n#define THRESHOLD_REDUCE 1.5\n#define MAX_DELAY_PRINT_RATE 2000000000LL\n#define MAX_NB_PRINTS 100\n\n// Needed to prevent before_block_exec_invalidate_opt from \n// running more than once\nbool panda_bb_invalidate_done = false;\n\n// Whether or not a block has actually run since cpu_exec was last entered\nbool ranBlockSinceEnter = false;\n\nstatic void align_clocks(SyncClocks *sc, const CPUState *cpu)\n{\n    int64_t cpu_icount;\n\n    if (!icount_align_option) {\n        return;\n    }\n\n    cpu_icount = cpu->icount_extra + cpu->icount_decr.u16.low;\n    sc->diff_clk += cpu_icount_to_ns(sc->last_cpu_icount - cpu_icount);\n    sc->last_cpu_icount = cpu_icount;\n\n    if (sc->diff_clk > VM_CLOCK_ADVANCE) {\n#ifndef _WIN32\n        struct timespec sleep_delay, rem_delay;\n        sleep_delay.tv_sec = sc->diff_clk / 1000000000LL;\n        sleep_delay.tv_nsec = sc->diff_clk % 1000000000LL;\n        if (nanosleep(&sleep_delay, &rem_delay) < 0) {\n            sc->diff_clk = rem_delay.tv_sec * 1000000000LL + rem_delay.tv_nsec;\n        } else {\n            sc->diff_clk = 0;\n        }\n#else\n        Sleep(sc->diff_clk / SCALE_MS);\n        sc->diff_clk = 0;\n#endif\n    }\n}\n\nstatic void print_delay(const SyncClocks *sc)\n{\n    static float threshold_delay;\n    static int64_t last_realtime_clock;\n    static int nb_prints;\n\n    if (icount_align_option &&\n        sc->realtime_clock - last_realtime_clock >= MAX_DELAY_PRINT_RATE &&\n        nb_prints < MAX_NB_PRINTS) {\n        if ((-sc->diff_clk / (float)1000000000LL > threshold_delay) ||\n            (-sc->diff_clk / (float)1000000000LL <\n             (threshold_delay - THRESHOLD_REDUCE))) {\n            threshold_delay = (-sc->diff_clk / 1000000000LL) + 1;\n            printf(\"Warning: The guest is now late by %.1f to %.1f seconds\\n\",\n                   threshold_delay - 1,\n                   threshold_delay);\n            nb_prints++;\n            last_realtime_clock = sc->realtime_clock;\n        }\n    }\n}\n\nstatic void init_delay_params(SyncClocks *sc,\n                              const CPUState *cpu)\n{\n    if (!icount_align_option) {\n        return;\n    }\n    sc->realtime_clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);\n    sc->diff_clk = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - sc->realtime_clock;\n    sc->last_cpu_icount = cpu->icount_extra + cpu->icount_decr.u16.low;\n    if (sc->diff_clk < max_delay) {\n        max_delay = sc->diff_clk;\n    }\n    if (sc->diff_clk > max_advance) {\n        max_advance = sc->diff_clk;\n    }\n\n    /* Print every 2s max if the guest is late. We limit the number\n       of printed messages to NB_PRINT_MAX(currently 100) */\n    print_delay(sc);\n}\n#else\nstatic void align_clocks(SyncClocks *sc, const CPUState *cpu)\n{\n}\n\nstatic void init_delay_params(SyncClocks *sc, const CPUState *cpu)\n{\n}\n#endif /* CONFIG USER ONLY */\n\n/* Execute a TB, and fix up the CPU state afterwards if necessary */\nstatic inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)\n{\n    CPUArchState *env = cpu->env_ptr;\n    uintptr_t ret;\n    TranslationBlock *last_tb;\n    int tb_exit;\n    uint8_t exitCode;\n    uint8_t *tb_ptr = itb->tc_ptr;\n\n    qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,\n                           \"Trace %p [%d: \" TARGET_FMT_lx \"] %s\\n\",\n                           itb->tc_ptr, cpu->cpu_index, itb->pc,\n                           lookup_symbol(itb->pc));\n\n#if defined(DEBUG_DISAS)\n    if (qemu_loglevel_mask(CPU_LOG_TB_CPU)\n        && qemu_log_in_addr_range(itb->pc)) {\n        qemu_log_lock();\n#if defined(TARGET_I386)\n        log_cpu_state(cpu, CPU_DUMP_CCOP);\n#else\n        log_cpu_state(cpu, 0);\n#endif\n        qemu_log_unlock();\n    }\n#endif /* DEBUG_DISAS */\n\n    cpu->can_do_io = !use_icount;\n\n    if (!panda_exit_loop)\n        panda_callbacks_before_block_exec(cpu, itb);\n\n    // If there has been a request to break the CPU\n    // loop, return now. Before we execute the block\n    if (panda_exit_loop) {\n        cpu->can_do_io = 1;\n        // tcg_exit_req is likely already 0, but make sure it's\n        // cleared now before we resume execution later\n        atomic_set(&cpu->tcg_exit_req, 0);\n        return TB_EXIT_REQUESTED;\n    }\n\n    // NB: This is where we did this in panda1\n    panda_bb_invalidate_done = false;\n\n#if defined(CONFIG_LLVM)\n    if (execute_llvm) {\n        assert(itb->llvm_tc_ptr);\n        ret = tcg_llvm_qemu_tb_exec(env, itb);\n    } else {\n        assert(tb_ptr);\n        ret = tcg_qemu_tb_exec(env, tb_ptr);\n    }\n#else\n    ret = tcg_qemu_tb_exec(env, tb_ptr);\n#endif // CONFIG_LLVM\n\n    cpu->can_do_io = 1;\n    last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n    ranBlockSinceEnter = true;\n\n    tb_exit = ret & TB_EXIT_MASK;\n\n    /* force into variable of known size */\n    exitCode = (uint8_t)tb_exit;\n    panda_callbacks_after_block_exec(cpu, itb, exitCode);\n\n    trace_exec_tb_exit(last_tb, tb_exit);\n\n    if (tb_exit > TB_EXIT_IDX1) {\n        /* We didn't start executing this TB (eg because the instruction\n         * counter hit zero); we must restore the guest PC to the address\n         * of the start of the TB.\n         */\n        CPUClass *cc = CPU_GET_CLASS(cpu);\n        qemu_log_mask_and_addr(CPU_LOG_EXEC, last_tb->pc,\n                               \"Stopped execution of TB chain before %p [\"\n                               TARGET_FMT_lx \"] %s\\n\",\n                               last_tb->tc_ptr, last_tb->pc,\n                               lookup_symbol(last_tb->pc));\n        if (cc->synchronize_from_tb) {\n            cc->synchronize_from_tb(cpu, last_tb);\n        } else {\n            assert(cc->set_pc);\n            cc->set_pc(cpu, last_tb->pc);\n        }\n    }\n    if (tb_exit == TB_EXIT_REQUESTED) {\n        /* We were asked to stop executing TBs (probably a pending\n         * interrupt. We've now stopped, so clear the flag.\n         */\n        atomic_set(&cpu->tcg_exit_req, 0);\n    }\n    return ret;\n}\n\n#ifndef CONFIG_USER_ONLY\n/* Execute the code without caching the generated code. An interpreter\n   could be used if available. */\nstatic void cpu_exec_nocache(CPUState *cpu, int max_cycles,\n                             TranslationBlock *orig_tb, bool ignore_icount)\n{\n    TranslationBlock *tb;\n\n    /* Should never happen.\n       We only end up here when an existing TB is too long.  */\n    if (max_cycles > CF_COUNT_MASK)\n        max_cycles = CF_COUNT_MASK;\n\n    tb_lock();\n    tb = tb_gen_code(cpu, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n                     max_cycles | CF_NOCACHE\n                         | (ignore_icount ? CF_IGNORE_ICOUNT : 0));\n    tb->orig_tb = orig_tb;\n    tb_unlock();\n\n    /* execute the generated code */\n    trace_exec_tb_nocache(tb, tb->pc);\n    cpu_tb_exec(cpu, tb);\n\n    tb_lock();\n    tb_phys_invalidate(tb, -1);\n    tb_free(tb);\n    tb_unlock();\n}\n#endif\n\nstatic void cpu_exec_step(CPUState *cpu)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n    TranslationBlock *tb;\n    target_ulong cs_base, pc;\n    uint32_t flags;\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n    if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n        mmap_lock();\n        tb_lock();\n        tb = tb_gen_code(cpu, pc, cs_base, flags,\n                         1 | CF_NOCACHE | CF_IGNORE_ICOUNT);\n        tb->orig_tb = NULL;\n        tb_unlock();\n        mmap_unlock();\n\n        cc->cpu_exec_enter(cpu);\n        /* execute the generated code */\n        trace_exec_tb_nocache(tb, pc);\n        cpu_tb_exec(cpu, tb);\n        cc->cpu_exec_exit(cpu);\n\n        tb_lock();\n        tb_phys_invalidate(tb, -1);\n        tb_free(tb);\n        tb_unlock();\n    } else {\n        /* We may have exited due to another problem here, so we need\n         * to reset any tb_locks we may have taken but didn't release.\n         * The mmap_lock is dropped by tb_gen_code if it runs out of\n         * memory.\n         */\n#ifndef CONFIG_SOFTMMU\n        tcg_debug_assert(!have_mmap_lock());\n#endif\n        tb_lock_reset();\n    }\n}\n\nvoid cpu_exec_step_atomic(CPUState *cpu)\n{\n    start_exclusive();\n\n    /* Since we got here, we know that parallel_cpus must be true.  */\n    parallel_cpus = false;\n    cpu_exec_step(cpu);\n    parallel_cpus = true;\n\n    end_exclusive();\n}\n\nstruct tb_desc {\n    target_ulong pc;\n    target_ulong cs_base;\n    CPUArchState *env;\n    tb_page_addr_t phys_page1;\n    uint32_t flags;\n};\n\nstatic bool tb_cmp(const void *p, const void *d)\n{\n    const TranslationBlock *tb = p;\n    const struct tb_desc *desc = d;\n\n    if (tb->pc == desc->pc &&\n        tb->page_addr[0] == desc->phys_page1 &&\n        tb->cs_base == desc->cs_base &&\n        tb->flags == desc->flags &&\n        !atomic_read(&tb->invalid)) {\n        /* check next page if needed */\n        if (tb->page_addr[1] == -1) {\n            return true;\n        } else {\n            tb_page_addr_t phys_page2;\n            target_ulong virt_page2;\n\n            virt_page2 = (desc->pc & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n            phys_page2 = get_page_addr_code(desc->env, virt_page2);\n            if (tb->page_addr[1] == phys_page2) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstatic TranslationBlock *tb_htable_lookup(CPUState *cpu,\n                                          target_ulong pc,\n                                          target_ulong cs_base,\n                                          uint32_t flags)\n{\n    tb_page_addr_t phys_pc;\n    struct tb_desc desc;\n    uint32_t h;\n\n    desc.env = (CPUArchState *)cpu->env_ptr;\n    desc.cs_base = cs_base;\n    desc.flags = flags;\n    desc.pc = pc;\n    phys_pc = get_page_addr_code(desc.env, pc);\n    desc.phys_page1 = phys_pc & TARGET_PAGE_MASK;\n    h = tb_hash_func(phys_pc, pc, flags);\n    return qht_lookup(&tcg_ctx.tb_ctx.htable, tb_cmp, &desc, h);\n}\n\nstatic inline TranslationBlock *tb_find(CPUState *cpu,\n                                        TranslationBlock *last_tb,\n                                        int tb_exit)\n{\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n    TranslationBlock *tb;\n    target_ulong cs_base, pc;\n    uint32_t flags;\n    bool have_tb_lock = false;\n\n    /* we record a subset of the CPU state. It will\n       always be the same before a given translated block\n       is executed. */\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n                 tb->flags != flags)) {\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n        if (!tb) {\n\n            /* mmap_lock is needed by tb_gen_code, and mmap_lock must be\n             * taken outside tb_lock. As system emulation is currently\n             * single threaded the locks are NOPs.\n             */\n            mmap_lock();\n            tb_lock();\n            have_tb_lock = true;\n\n            /* There's a chance that our desired tb has been translated while\n             * taking the locks so we check again inside the lock.\n             */\n            tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n            if (!tb) {\n                panda_callbacks_before_block_translate(cpu, pc);\n                /* if no translated code available, then translate it now */\n                tb = tb_gen_code(cpu, pc, cs_base, flags, 0);\n                panda_callbacks_after_block_translate(cpu, tb);\n            }\n\n            mmap_unlock();\n        }\n\n        /* We add the TB in the virtual pc hash table for the fast lookup */\n        atomic_set(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);\n    }\n#ifndef CONFIG_USER_ONLY\n    /* We don't take care of direct jumps when address mapping changes in\n     * system emulation. So it's not safe to make a direct jump to a TB\n     * spanning two pages because the mapping for the second page can change.\n     */\n    if (tb->page_addr[1] != -1) {\n        last_tb = NULL;\n    }\n#endif\n    /* See if we can patch the calling TB. */\n#ifdef CONFIG_SOFTMMU\n    if (!rr_in_replay() && panda_tb_chaining) {\n#endif\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n        if (!have_tb_lock) {\n            tb_lock();\n            have_tb_lock = true;\n        }\n        if (!tb->invalid) {\n            tb_add_jump(last_tb, tb_exit, tb);\n        }\n    }\n#ifdef CONFIG_SOFTMMU\n    }\n#endif\n    if (have_tb_lock) {\n        tb_unlock();\n    }\n    return tb;\n}\n\nstatic inline bool cpu_handle_halt(CPUState *cpu)\n{\n    if (cpu->halted) {\n#if defined(TARGET_I386) && !defined(CONFIG_USER_ONLY)\n        if ((cpu->interrupt_request & CPU_INTERRUPT_POLL)\n            && replay_interrupt()) {\n            X86CPU *x86_cpu = X86_CPU(cpu);\n            apic_poll_irq(x86_cpu->apic_state);\n            cpu_reset_interrupt(cpu, CPU_INTERRUPT_POLL);\n        }\n#endif\n        if (!cpu_has_work(cpu) && !rr_in_replay()) {\n            current_cpu = NULL;\n            return true;\n        }\n\n        cpu->halted = 0;\n    }\n\n    return false;\n}\n\nstatic inline void cpu_handle_debug_exception(CPUState *cpu)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUWatchpoint *wp;\n\n    if (!cpu->watchpoint_hit) {\n        QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n        }\n    }\n\n    cc->debug_excp_handler(cpu);\n}\n\nstatic inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n{\n\n    // If we finished a reverse-step, clear the most recent breakpoint\n    if ((cpu->reverse_flags & (GDB_RSTEP | GDB_RDONE)) == (GDB_RSTEP | GDB_RDONE)) {\n        // Remove the breakpoint we just hit\n        // And clear the reverse_flags\n        cpu_breakpoint_remove_by_instr(cpu, cpu->last_gdb_instr-1, BP_GDB);\n        cpu->reverse_flags = 0;\n    }\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n            /* exit request from the cpu execution loop */\n            *ret = cpu->exception_index;\n            if (*ret == EXCP_DEBUG) {\n                cpu_handle_debug_exception(cpu);\n            }\n            cpu->exception_index = -1;\n            return true;\n        } else {\n            int32_t exception = cpu->exception_index;\n\n            cpu->exception_index = panda_callbacks_before_handle_exception(cpu, cpu->exception_index);\n\n            if (exception != cpu->exception_index){\n                return cpu_handle_exception(cpu, ret);\n            }\n\n#if defined(CONFIG_USER_ONLY)\n            /* if user mode only, we simulate a fake exception\n               which will be handled outside the cpu execution\n               loop */\n#if defined(TARGET_I386)\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n            cc->do_interrupt(cpu);\n#endif\n            *ret = cpu->exception_index;\n            cpu->exception_index = -1;\n            return true;\n#else\n            if (replay_exception()) {\n#ifdef TARGET_PPC\n                rr_exception_index_at(RR_CALLSITE_CPU_EXCEPTION_INDEX, &cpu->exception_index);\n#endif\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n                cc->do_interrupt(cpu);\n                cpu->exception_index = -1;\n            } else if (!replay_has_interrupt()) {\n                /* give a chance to iothread in replay mode */\n                *ret = EXCP_INTERRUPT;\n                return true;\n            }\n#endif\n        }\n#ifndef CONFIG_USER_ONLY\n    } else if (replay_has_exception()\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n        /* try to cause an exception pending in the log */\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n        *ret = -1;\n        return true;\n#endif\n    }\n\n    return false;\n}\n\nstatic inline bool cpu_handle_interrupt(CPUState *cpu,\n                                        TranslationBlock **last_tb)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int interrupt_request = cpu->interrupt_request;\n\n#ifdef CONFIG_SOFTMMU\n    //mz Record and Replay.\n    //mz it is important to do this in the order written, as\n    //during record env->interrupt_request can be changed at any\n    //time via a signal.  Thus, we want to make sure that we\n    //record the same value in the log as the one being used in\n    //these decisions.\n    rr_skipped_callsite_location = RR_CALLSITE_CPU_HANDLE_INTERRUPT_BEFORE;\n    rr_interrupt_request(&interrupt_request);\n\n    if (rr_in_replay()) {\n        cpu->interrupt_request = interrupt_request;\n    }\n#endif\n    if (unlikely(interrupt_request)) {\n        if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n            /* Mask out external interrupts for this step. */\n            interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n        }\n        if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n            cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n            cpu->exception_index = EXCP_DEBUG;\n            return true;\n        }\n        if (replay_mode == REPLAY_MODE_PLAY && !replay_has_interrupt()) {\n            /* Do nothing */\n        } else if (interrupt_request & CPU_INTERRUPT_HALT) {\n            replay_interrupt();\n            cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n            cpu->halted = 1;\n            cpu->exception_index = EXCP_HLT;\n            return true;\n        }\n#if defined(TARGET_I386)\n        else if (interrupt_request & CPU_INTERRUPT_INIT) {\n            X86CPU *x86_cpu = X86_CPU(cpu);\n            CPUArchState *env = &x86_cpu->env;\n            replay_interrupt();\n            cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0, 0);\n            do_cpu_init(x86_cpu);\n            cpu->exception_index = EXCP_HALTED;\n            return true;\n        }\n#else\n        else if (interrupt_request & CPU_INTERRUPT_RESET) {\n            replay_interrupt();\n            cpu_reset(cpu);\n            return true;\n        }\n#endif\n        /* The target hook has 3 exit conditions:\n           False when the interrupt isn't processed,\n           True when it is, and we should restart on a new TB,\n           and via longjmp via cpu_loop_exit.  */\n        else {\n            if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n                replay_interrupt();\n                *last_tb = NULL;\n            }\n            /* The target hook may have updated the 'cpu->interrupt_request';\n             * reload the 'interrupt_request' value */\n            interrupt_request = cpu->interrupt_request;\n        }\n#ifdef CONFIG_SOFTMMU\n        //mz record the value again in case do_interrupt has set EXITTB flag\n        rr_skipped_callsite_location = RR_CALLSITE_CPU_HANDLE_INTERRUPT_AFTER;\n        rr_interrupt_request((int *)&cpu->interrupt_request);\n        if (rr_in_replay()) {\n            interrupt_request = cpu->interrupt_request;\n        }\n#endif\n        if (interrupt_request & CPU_INTERRUPT_EXITTB) {\n            cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n            /* ensure that no TB jump will be modified as\n               the program flow was changed */\n            *last_tb = NULL;\n        }\n    }\n    if (unlikely(atomic_read(&cpu->exit_request) || replay_has_interrupt())) {\n        atomic_set(&cpu->exit_request, 0);\n        cpu->exception_index = EXCP_INTERRUPT;\n        return true;\n    }\n\n    return false;\n}\n\nstatic inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n                                    TranslationBlock **last_tb, int *tb_exit,\n                                    SyncClocks *sc)\n{\n    uintptr_t ret;\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n        return;\n    }\n\n    trace_exec_tb(tb, tb->pc);\n    ret = cpu_tb_exec(cpu, tb);\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n    *tb_exit = ret & TB_EXIT_MASK;\n    switch (*tb_exit) {\n    case TB_EXIT_REQUESTED:\n        /* Something asked us to stop executing chained TBs; just\n         * continue round the main loop. Whatever requested the exit\n         * will also have set something else (eg interrupt_request)\n         * which we will handle next time around the loop.  But we\n         * need to ensure the tcg_exit_req read in generated code\n         * comes before the next read of cpu->exit_request or\n         * cpu->interrupt_request.\n         */\n        smp_mb();\n        *last_tb = NULL;\n        break;\n    case TB_EXIT_ICOUNT_EXPIRED:\n    {\n        /* Instruction counter expired.  */\n#ifdef CONFIG_USER_ONLY\n        abort();\n#else\n        int insns_left = cpu->icount_decr.u32;\n        *last_tb = NULL;\n        if (cpu->icount_extra && insns_left >= 0) {\n            /* Refill decrementer and continue execution.  */\n            cpu->icount_extra += insns_left;\n            insns_left = MIN(0xffff, cpu->icount_extra);\n            cpu->icount_extra -= insns_left;\n            cpu->icount_decr.u16.low = insns_left;\n        } else {\n            if (insns_left > 0) {\n                /* Execute remaining instructions.  */\n                cpu_exec_nocache(cpu, insns_left, tb, false);\n                align_clocks(sc, cpu);\n            }\n            cpu->exception_index = EXCP_INTERRUPT;\n            cpu_loop_exit(cpu);\n        }\n        break;\n#endif\n    }\n    default:\n        *last_tb = tb;\n        break;\n    }\n}\n\n#ifdef CONFIG_DEBUG_TCG\nuint64_t counter_128k = 0;\nvoid debug_counter(void);\nvoid debug_counter(void) {\n        counter_128k++;\n}\n#endif\n\n__attribute__((always_inline)) static inline void debug_checkpoint(CPUState *cpu) {\n#ifdef CONFIG_DEBUG_TCG\n    if (rr_on() && cpu->rr_guest_instr_count >> 17 > counter_128k) {\n        debug_counter();\n    }\n#endif\n}\n\n__attribute__((always_inline)) static inline void detect_infinite_loops(void) {\n    if (!rr_in_replay()) return;\n\n    static uint64_t last_instr_count = 0;\n    static unsigned loop_tries = 0;\n    if (last_instr_count == rr_get_guest_instr_count()) {\n        loop_tries++;\n        if (loop_tries > 20) {\n            fprintf(stderr, \"rr_guest_instr_count = %\" PRIu64 \"\\n\",\n                    rr_get_guest_instr_count());\n            assert(false);\n        }\n    } else {\n        loop_tries = 0;\n        last_instr_count = rr_get_guest_instr_count();\n    }\n}\n\n/* main execution loop */\n\nint cpu_exec(CPUState *cpu)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    int ret = -1;\n    SyncClocks sc;\n\n    /* replay_interrupt may need current_cpu */\n    current_cpu = cpu;\n\n    if (cpu_handle_halt(cpu)) {\n        return EXCP_HALTED;\n    }\n\n    rcu_read_lock();\n\n    ranBlockSinceEnter = false;\n    cc->cpu_exec_enter(cpu);\n    panda_callbacks_after_cpu_exec_enter(cpu);\n\n    /* Calculate difference between guest clock and host clock.\n     * This delay includes the delay of the last cycle, so\n     * what we have to do is sleep until it is 0. As for the\n     * advance/delay we gain here, we try to fix it next time.\n     */\n    init_delay_params(&sc, cpu);\n\n    /* prepare setjmp context for exception handling */\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n        /* Some compilers wrongly smash all local variables after\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n         * Reload essential local variables here for those compilers.\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n        cpu = current_cpu;\n        cc = CPU_GET_CLASS(cpu);\n#else /* buggy compiler */\n        /* Assert that the compiler does not smash local variables. */\n        g_assert(cpu == current_cpu);\n        g_assert(cc == CPU_GET_CLASS(cpu));\n#endif /* buggy compiler */\n        cpu->can_do_io = 1;\n        tb_lock_reset();\n    }\n\n    /* if an exception is pending, we execute it here */\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        if (panda_exit_loop) {\n            printf (\"Exiting cpu_handle_execption loop\\n\");\n            break;\n        }\n\n        TranslationBlock *last_tb = NULL;\n        int tb_exit = 0;\n\n        /* Note: We usually break out of the loop manually and\n         * not because panda_exit_loop is true. */\n        while (likely(!panda_exit_loop)) {\n            bool panda_invalidate_tb = false;\n            debug_checkpoint(cpu);\n            detect_infinite_loops();\n            rr_maybe_progress();\n\n            /* Replay skipped calls from the I/O thread here. */\n            if (rr_in_replay()) {\n                rr_skipped_callsite_location = RR_CALLSITE_MAIN_LOOP_WAIT;\n                rr_replay_skipped_calls();\n            }\n\n            if (cpu_handle_interrupt(cpu, &last_tb)) {\n                break;\n            }\n\n            panda_callbacks_before_find_fast();\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n            panda_bb_invalidate_done = panda_callbacks_after_find_fast(\n                    cpu, tb, panda_bb_invalidate_done, &panda_invalidate_tb);\n        \n            if (unlikely(cpu->temp_rr_bp_instr) && rr_get_guest_instr_count() > cpu->temp_rr_bp_instr) {\n                // Restore rr breakpoint if one was disabled for continue\n                cpu_rr_breakpoint_insert(cpu, cpu->temp_rr_bp_instr, BP_GDB, NULL);\n                cpu->temp_rr_bp_instr = 0;\n            }\n\n            qemu_log_rr(tb->pc);\n\n#ifdef CONFIG_SOFTMMU\n            uint64_t until_interrupt = rr_num_instr_before_next_interrupt();\n            if (panda_invalidate_tb\n                    || (rr_in_replay() && until_interrupt > 0\n                        && tb->icount > until_interrupt)) {\n                /* Retranslate so that basic block boundary matches\n                 * record & replay for interrupt delivery. */\n                tb_lock();\n                tb_phys_invalidate(tb, -1);\n                tb_unlock();\n                continue;\n            }\n#endif // CONFIG_SOFTMMU\n            if (rr_in_replay() && rr_replay_finished()) {\n                rr_do_end_replay(0);\n                qemu_cpu_kick(cpu);\n                panda_exit_loop = true;\n                break;\n            }\n\n            if (!rr_in_replay() || until_interrupt > 0) {\n                cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n                /* Try to align the host and virtual clocks\n                   if the guest is in advance */\n                align_clocks(&sc, cpu);\n            }\n        }\n    }\n\n    panda_callbacks_before_cpu_exec_exit(cpu, ranBlockSinceEnter);\n    cc->cpu_exec_exit(cpu);\n    rcu_read_unlock();\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n    current_cpu = NULL;\n\n    return ret;\n}\n"
        },
        {
          "name": "cpus-common.c",
          "type": "blob",
          "size": 10.0986328125,
          "content": "/*\n * CPU thread main loop - common bits for user and system mode emulation\n *\n *  Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/main-loop.h\"\n#include \"exec/cpu-common.h\"\n#include \"qom/cpu.h\"\n#include \"sysemu/cpus.h\"\n\nstatic QemuMutex qemu_cpu_list_lock;\nstatic QemuCond exclusive_cond;\nstatic QemuCond exclusive_resume;\nstatic QemuCond qemu_work_cond;\n\n/* >= 1 if a thread is inside start_exclusive/end_exclusive.  Written\n * under qemu_cpu_list_lock, read with atomic operations.\n */\nstatic int pending_cpus;\n\nvoid qemu_init_cpu_list(void)\n{\n    /* This is needed because qemu_init_cpu_list is also called by the\n     * child process in a fork.  */\n    pending_cpus = 0;\n\n    qemu_mutex_init(&qemu_cpu_list_lock);\n    qemu_cond_init(&exclusive_cond);\n    qemu_cond_init(&exclusive_resume);\n    qemu_cond_init(&qemu_work_cond);\n}\n\nvoid cpu_list_lock(void)\n{\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n}\n\nvoid cpu_list_unlock(void)\n{\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\nstatic bool cpu_index_auto_assigned;\n\nstatic int cpu_get_free_index(void)\n{\n    CPUState *some_cpu;\n    int cpu_index = 0;\n\n    cpu_index_auto_assigned = true;\n    CPU_FOREACH(some_cpu) {\n        cpu_index++;\n    }\n    return cpu_index;\n}\n\nstatic void finish_safe_work(CPUState *cpu)\n{\n    cpu_exec_start(cpu);\n    cpu_exec_end(cpu);\n}\n\nvoid cpu_list_add(CPUState *cpu)\n{\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    if (cpu->cpu_index == UNASSIGNED_CPU_INDEX) {\n        cpu->cpu_index = cpu_get_free_index();\n        assert(cpu->cpu_index != UNASSIGNED_CPU_INDEX);\n    } else {\n        assert(!cpu_index_auto_assigned);\n    }\n    QTAILQ_INSERT_TAIL(&cpus, cpu, node);\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n\n    finish_safe_work(cpu);\n}\n\nvoid cpu_list_remove(CPUState *cpu)\n{\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    if (!QTAILQ_IN_USE(cpu, node)) {\n        /* there is nothing to undo since cpu_exec_init() hasn't been called */\n        qemu_mutex_unlock(&qemu_cpu_list_lock);\n        return;\n    }\n\n    assert(!(cpu_index_auto_assigned && cpu != QTAILQ_LAST(&cpus, CPUTailQ)));\n\n    QTAILQ_REMOVE(&cpus, cpu, node);\n    cpu->cpu_index = UNASSIGNED_CPU_INDEX;\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\nstruct qemu_work_item {\n    struct qemu_work_item *next;\n    run_on_cpu_func func;\n    run_on_cpu_data data;\n    bool free, exclusive, done;\n};\n\nstatic void queue_work_on_cpu(CPUState *cpu, struct qemu_work_item *wi)\n{\n    qemu_mutex_lock(&cpu->work_mutex);\n    if (cpu->queued_work_first == NULL) {\n        cpu->queued_work_first = wi;\n    } else {\n        cpu->queued_work_last->next = wi;\n    }\n    cpu->queued_work_last = wi;\n    wi->next = NULL;\n    wi->done = false;\n    qemu_mutex_unlock(&cpu->work_mutex);\n\n    qemu_cpu_kick(cpu);\n}\n\nvoid do_run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data,\n                   QemuMutex *mutex)\n{\n    struct qemu_work_item wi;\n\n    if (qemu_cpu_is_self(cpu)) {\n        func(cpu, data);\n        return;\n    }\n\n    wi.func = func;\n    wi.data = data;\n    wi.done = false;\n    wi.free = false;\n    wi.exclusive = false;\n\n    queue_work_on_cpu(cpu, &wi);\n    while (!atomic_mb_read(&wi.done)) {\n        CPUState *self_cpu = current_cpu;\n\n        qemu_cond_wait(&qemu_work_cond, mutex);\n        current_cpu = self_cpu;\n    }\n}\n\nvoid async_run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data)\n{\n    struct qemu_work_item *wi;\n\n    wi = g_malloc0(sizeof(struct qemu_work_item));\n    wi->func = func;\n    wi->data = data;\n    wi->free = true;\n\n    queue_work_on_cpu(cpu, wi);\n}\n\n/* Wait for pending exclusive operations to complete.  The CPU list lock\n   must be held.  */\nstatic inline void exclusive_idle(void)\n{\n    while (pending_cpus) {\n        qemu_cond_wait(&exclusive_resume, &qemu_cpu_list_lock);\n    }\n}\n\n/* Start an exclusive operation.\n   Must only be called from outside cpu_exec.  */\nvoid start_exclusive(void)\n{\n    CPUState *other_cpu;\n    int running_cpus;\n\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    exclusive_idle();\n\n    /* Make all other cpus stop executing.  */\n    atomic_set(&pending_cpus, 1);\n\n    /* Write pending_cpus before reading other_cpu->running.  */\n    smp_mb();\n    running_cpus = 0;\n    CPU_FOREACH(other_cpu) {\n        if (atomic_read(&other_cpu->running)) {\n            other_cpu->has_waiter = true;\n            running_cpus++;\n            qemu_cpu_kick(other_cpu);\n        }\n    }\n\n    atomic_set(&pending_cpus, running_cpus + 1);\n    while (pending_cpus > 1) {\n        qemu_cond_wait(&exclusive_cond, &qemu_cpu_list_lock);\n    }\n\n    /* Can release mutex, no one will enter another exclusive\n     * section until end_exclusive resets pending_cpus to 0.\n     */\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\n/* Finish an exclusive operation.  */\nvoid end_exclusive(void)\n{\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    atomic_set(&pending_cpus, 0);\n    qemu_cond_broadcast(&exclusive_resume);\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\n/* Wait for exclusive ops to finish, and begin cpu execution.  */\nvoid cpu_exec_start(CPUState *cpu)\n{\n    atomic_set(&cpu->running, true);\n\n    /* Write cpu->running before reading pending_cpus.  */\n    smp_mb();\n\n    /* 1. start_exclusive saw cpu->running == true and pending_cpus >= 1.\n     * After taking the lock we'll see cpu->has_waiter == true and run---not\n     * for long because start_exclusive kicked us.  cpu_exec_end will\n     * decrement pending_cpus and signal the waiter.\n     *\n     * 2. start_exclusive saw cpu->running == false but pending_cpus >= 1.\n     * This includes the case when an exclusive item is running now.\n     * Then we'll see cpu->has_waiter == false and wait for the item to\n     * complete.\n     *\n     * 3. pending_cpus == 0.  Then start_exclusive is definitely going to\n     * see cpu->running == true, and it will kick the CPU.\n     */\n    if (unlikely(atomic_read(&pending_cpus))) {\n        qemu_mutex_lock(&qemu_cpu_list_lock);\n        if (!cpu->has_waiter) {\n            /* Not counted in pending_cpus, let the exclusive item\n             * run.  Since we have the lock, just set cpu->running to true\n             * while holding it; no need to check pending_cpus again.\n             */\n            atomic_set(&cpu->running, false);\n            exclusive_idle();\n            /* Now pending_cpus is zero.  */\n            atomic_set(&cpu->running, true);\n        } else {\n            /* Counted in pending_cpus, go ahead and release the\n             * waiter at cpu_exec_end.\n             */\n        }\n        qemu_mutex_unlock(&qemu_cpu_list_lock);\n    }\n}\n\n/* Mark cpu as not executing, and release pending exclusive ops.  */\nvoid cpu_exec_end(CPUState *cpu)\n{\n    atomic_set(&cpu->running, false);\n\n    /* Write cpu->running before reading pending_cpus.  */\n    smp_mb();\n\n    /* 1. start_exclusive saw cpu->running == true.  Then it will increment\n     * pending_cpus and wait for exclusive_cond.  After taking the lock\n     * we'll see cpu->has_waiter == true.\n     *\n     * 2. start_exclusive saw cpu->running == false but here pending_cpus >= 1.\n     * This includes the case when an exclusive item started after setting\n     * cpu->running to false and before we read pending_cpus.  Then we'll see\n     * cpu->has_waiter == false and not touch pending_cpus.  The next call to\n     * cpu_exec_start will run exclusive_idle if still necessary, thus waiting\n     * for the item to complete.\n     *\n     * 3. pending_cpus == 0.  Then start_exclusive is definitely going to\n     * see cpu->running == false, and it can ignore this CPU until the\n     * next cpu_exec_start.\n     */\n    if (unlikely(atomic_read(&pending_cpus))) {\n        qemu_mutex_lock(&qemu_cpu_list_lock);\n        if (cpu->has_waiter) {\n            cpu->has_waiter = false;\n            atomic_set(&pending_cpus, pending_cpus - 1);\n            if (pending_cpus == 1) {\n                qemu_cond_signal(&exclusive_cond);\n            }\n        }\n        qemu_mutex_unlock(&qemu_cpu_list_lock);\n    }\n}\n\nvoid async_safe_run_on_cpu(CPUState *cpu, run_on_cpu_func func,\n                           run_on_cpu_data data)\n{\n    struct qemu_work_item *wi;\n\n    wi = g_malloc0(sizeof(struct qemu_work_item));\n    wi->func = func;\n    wi->data = data;\n    wi->free = true;\n    wi->exclusive = true;\n\n    queue_work_on_cpu(cpu, wi);\n}\n\nvoid process_queued_cpu_work(CPUState *cpu)\n{\n    struct qemu_work_item *wi;\n\n    if (cpu->queued_work_first == NULL) {\n        return;\n    }\n\n    qemu_mutex_lock(&cpu->work_mutex);\n    while (cpu->queued_work_first != NULL) {\n        wi = cpu->queued_work_first;\n        cpu->queued_work_first = wi->next;\n        if (!cpu->queued_work_first) {\n            cpu->queued_work_last = NULL;\n        }\n        qemu_mutex_unlock(&cpu->work_mutex);\n        if (wi->exclusive) {\n            /* Running work items outside the BQL avoids the following deadlock:\n             * 1) start_exclusive() is called with the BQL taken while another\n             * CPU is running; 2) cpu_exec in the other CPU tries to takes the\n             * BQL, so it goes to sleep; start_exclusive() is sleeping too, so\n             * neither CPU can proceed.\n             */\n            qemu_mutex_unlock_iothread();\n            start_exclusive();\n            wi->func(cpu, wi->data);\n            end_exclusive();\n            qemu_mutex_lock_iothread();\n        } else {\n            wi->func(cpu, wi->data);\n        }\n        qemu_mutex_lock(&cpu->work_mutex);\n        if (wi->free) {\n            g_free(wi);\n        } else {\n            atomic_mb_set(&wi->done, true);\n        }\n    }\n    qemu_mutex_unlock(&cpu->work_mutex);\n    qemu_cond_broadcast(&qemu_work_cond);\n}\n"
        },
        {
          "name": "cpus.c",
          "type": "blob",
          "size": 50.1259765625,
          "content": "/*\n * QEMU System Emulator\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/* Needed early for CONFIG_BSD etc. */\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"qemu/config-file.h\"\n#include \"cpu.h\"\n#include \"monitor/monitor.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qemu/error-report.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/block-backend.h\"\n#include \"exec/gdbstub.h\"\n#include \"sysemu/dma.h\"\n#include \"sysemu/hw_accel.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/hax.h\"\n#include \"qmp-commands.h\"\n#include \"exec/exec-all.h\"\n\n#include \"qemu/thread.h\"\n#include \"sysemu/cpus.h\"\n#include \"sysemu/qtest.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/bitmap.h\"\n#include \"qemu/seqlock.h\"\n#include \"tcg.h\"\n#include \"qapi-event.h\"\n#include \"hw/nmi.h\"\n#include \"sysemu/replay.h\"\n\n#include \"panda/rr/rr_log.h\"\n#include \"panda/callbacks/cb-support.h\"\n\n#ifdef CONFIG_LINUX\n\n#include <sys/prctl.h>\n\n#ifndef PR_MCE_KILL\n#define PR_MCE_KILL 33\n#endif\n\n#ifndef PR_MCE_KILL_SET\n#define PR_MCE_KILL_SET 1\n#endif\n\n#ifndef PR_MCE_KILL_EARLY\n#define PR_MCE_KILL_EARLY 1\n#endif\n\n#endif /* CONFIG_LINUX */\n\nint64_t max_delay;\nint64_t max_advance;\n\n/* vcpu throttling controls */\nstatic QEMUTimer *throttle_timer;\nstatic unsigned int throttle_percentage;\n\n#define CPU_THROTTLE_PCT_MIN 1\n#define CPU_THROTTLE_PCT_MAX 99\n#define CPU_THROTTLE_TIMESLICE_NS 10000000\n\nextern bool rr_replay_complete;\nextern bool panda_exit_loop;\n\nbool cpu_is_stopped(CPUState *cpu)\n{\n    return cpu->stopped || !runstate_is_running();\n}\n\nstatic bool cpu_thread_is_idle(CPUState *cpu)\n{\n    if (cpu->stop || cpu->queued_work_first) {\n        return false;\n    }\n    if (cpu_is_stopped(cpu)) {\n        return true;\n    }\n    if (!cpu->halted || cpu_has_work(cpu) ||\n        kvm_halt_in_kernel()) {\n        return false;\n    }\n    return true;\n}\n\nstatic bool all_cpu_threads_idle(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (!cpu_thread_is_idle(cpu)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/***********************************************************/\n/* guest cycle counter */\n\n/* Protected by TimersState seqlock */\n\nstatic bool icount_sleep = true;\nstatic int64_t vm_clock_warp_start = -1;\n/* Conversion factor from emulated instructions to virtual clock ticks.  */\nstatic int icount_time_shift;\n/* Arbitrarily pick 1MIPS as the minimum allowable speed.  */\n#define MAX_ICOUNT_SHIFT 10\n\nstatic QEMUTimer *icount_rt_timer;\nstatic QEMUTimer *icount_vm_timer;\nstatic QEMUTimer *icount_warp_timer;\n\ntypedef struct TimersState {\n    /* Protected by BQL.  */\n    int64_t cpu_ticks_prev;\n    int64_t cpu_ticks_offset;\n\n    /* cpu_clock_offset can be read out of BQL, so protect it with\n     * this lock.\n     */\n    QemuSeqLock vm_clock_seqlock;\n    int64_t cpu_clock_offset;\n    int32_t cpu_ticks_enabled;\n    int64_t dummy;\n\n    /* Compensate for varying guest execution speed.  */\n    int64_t qemu_icount_bias;\n    /* Only written by TCG thread */\n    int64_t qemu_icount;\n} TimersState;\n\nstatic TimersState timers_state;\nbool mttcg_enabled;\n\n/*\n * We default to false if we know other options have been enabled\n * which are currently incompatible with MTTCG. Otherwise when each\n * guest (target) has been updated to support:\n *   - atomic instructions\n *   - memory ordering primitives (barriers)\n * they can set the appropriate CONFIG flags in ${target}-softmmu.mak\n *\n * Once a guest architecture has been converted to the new primitives\n * there are two remaining limitations to check.\n *\n * - The guest can't be oversized (e.g. 64 bit guest on 32 bit host)\n * - The host must have a stronger memory order than the guest\n *\n * It may be possible in future to support strong guests on weak hosts\n * but that will require tagging all load/stores in a guest with their\n * implicit memory order requirements which would likely slow things\n * down a lot.\n */\n\nstatic bool check_tcg_memory_orders_compatible(void)\n{\n#if defined(TCG_GUEST_DEFAULT_MO) && defined(TCG_TARGET_DEFAULT_MO)\n    return (TCG_GUEST_DEFAULT_MO & ~TCG_TARGET_DEFAULT_MO) == 0;\n#else\n    return false;\n#endif\n}\n\nstatic bool default_mttcg_enabled(void)\n{\n    if (use_icount || TCG_OVERSIZED_GUEST) {\n        return false;\n    } else {\n#ifdef TARGET_SUPPORTS_MTTCG\n        return check_tcg_memory_orders_compatible();\n#else\n        return false;\n#endif\n    }\n}\n\nvoid qemu_tcg_configure(QemuOpts *opts, Error **errp)\n{\n    const char *t = qemu_opt_get(opts, \"thread\");\n    if (t) {\n        if (strcmp(t, \"multi\") == 0) {\n            if (TCG_OVERSIZED_GUEST) {\n                error_setg(errp, \"No MTTCG when guest word size > hosts\");\n            } else if (use_icount) {\n                error_setg(errp, \"No MTTCG when icount is enabled\");\n            } else {\n#ifndef TARGET_SUPPORTS_MTTCG\n                error_report(\"Guest not yet converted to MTTCG - \"\n                             \"you may get unexpected results\");\n#endif\n                if (!check_tcg_memory_orders_compatible()) {\n                    error_report(\"Guest expects a stronger memory ordering \"\n                                 \"than the host provides\");\n                    error_printf(\"This may cause strange/hard to debug errors\\n\");\n                }\n                mttcg_enabled = true;\n            }\n        } else if (strcmp(t, \"single\") == 0) {\n            mttcg_enabled = false;\n        } else {\n            error_setg(errp, \"Invalid 'thread' setting %s\", t);\n        }\n    } else {\n        mttcg_enabled = default_mttcg_enabled();\n    }\n}\n\nint64_t cpu_get_icount_raw(void)\n{\n    int64_t icount;\n    CPUState *cpu = current_cpu;\n\n    icount = timers_state.qemu_icount;\n    if (cpu) {\n        if (!cpu->can_do_io) {\n            fprintf(stderr, \"Bad icount read\\n\");\n            exit(1);\n        }\n        icount -= (cpu->icount_decr.u16.low + cpu->icount_extra);\n    }\n    return icount;\n}\n\n/* Return the virtual CPU time, based on the instruction counter.  */\nstatic int64_t cpu_get_icount_locked(void)\n{\n    int64_t icount = cpu_get_icount_raw();\n    return timers_state.qemu_icount_bias + cpu_icount_to_ns(icount);\n}\n\nint64_t cpu_get_icount(void)\n{\n    int64_t icount;\n    unsigned start;\n\n    do {\n        start = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n        icount = cpu_get_icount_locked();\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, start));\n\n    return icount;\n}\n\nint64_t cpu_icount_to_ns(int64_t icount)\n{\n    return icount << icount_time_shift;\n}\n\n/* return the time elapsed in VM between vm_start and vm_stop.  Unless\n * icount is active, cpu_get_ticks() uses units of the host CPU cycle\n * counter.\n *\n * Caller must hold the BQL\n */\nint64_t cpu_get_ticks(void)\n{\n    int64_t ticks;\n\n    if (use_icount) {\n        return cpu_get_icount();\n    }\n\n    ticks = timers_state.cpu_ticks_offset;\n    if (timers_state.cpu_ticks_enabled) {\n        ticks += cpu_get_host_ticks();\n    }\n\n    if (timers_state.cpu_ticks_prev > ticks) {\n        /* Note: non increasing ticks may happen if the host uses\n           software suspend */\n        timers_state.cpu_ticks_offset += timers_state.cpu_ticks_prev - ticks;\n        ticks = timers_state.cpu_ticks_prev;\n    }\n\n    timers_state.cpu_ticks_prev = ticks;\n    return ticks;\n}\n\nstatic int64_t cpu_get_clock_locked(void)\n{\n    int64_t time;\n\n    time = timers_state.cpu_clock_offset;\n    if (timers_state.cpu_ticks_enabled) {\n        time += get_clock();\n    }\n\n    return time;\n}\n\n/* Return the monotonic time elapsed in VM, i.e.,\n * the time between vm_start and vm_stop\n */\nint64_t cpu_get_clock(void)\n{\n    int64_t ti;\n    unsigned start;\n\n    do {\n        start = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n        ti = cpu_get_clock_locked();\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, start));\n\n    return ti;\n}\n\n/* enable cpu_get_ticks()\n * Caller must hold BQL which serves as mutex for vm_clock_seqlock.\n */\nvoid cpu_enable_ticks(void)\n{\n    /* Here, the really thing protected by seqlock is cpu_clock_offset. */\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n    if (!timers_state.cpu_ticks_enabled) {\n        timers_state.cpu_ticks_offset -= cpu_get_host_ticks();\n        timers_state.cpu_clock_offset -= get_clock();\n        timers_state.cpu_ticks_enabled = 1;\n    }\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n}\n\n/* disable cpu_get_ticks() : the clock is stopped. You must not call\n * cpu_get_ticks() after that.\n * Caller must hold BQL which serves as mutex for vm_clock_seqlock.\n */\nvoid cpu_disable_ticks(void)\n{\n    /* Here, the really thing protected by seqlock is cpu_clock_offset. */\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n    if (timers_state.cpu_ticks_enabled) {\n        timers_state.cpu_ticks_offset += cpu_get_host_ticks();\n        timers_state.cpu_clock_offset = cpu_get_clock_locked();\n        timers_state.cpu_ticks_enabled = 0;\n    }\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n}\n\n/* Correlation between real and virtual time is always going to be\n   fairly approximate, so ignore small variation.\n   When the guest is idle real and virtual time will be aligned in\n   the IO wait loop.  */\n#define ICOUNT_WOBBLE (NANOSECONDS_PER_SECOND / 10)\n\nstatic void icount_adjust(void)\n{\n    int64_t cur_time;\n    int64_t cur_icount;\n    int64_t delta;\n\n    /* Protected by TimersState mutex.  */\n    static int64_t last_delta;\n\n    /* If the VM is not running, then do nothing.  */\n    if (!runstate_is_running()) {\n        return;\n    }\n\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n    cur_time = cpu_get_clock_locked();\n    cur_icount = cpu_get_icount_locked();\n\n    delta = cur_icount - cur_time;\n    /* FIXME: This is a very crude algorithm, somewhat prone to oscillation.  */\n    if (delta > 0\n        && last_delta + ICOUNT_WOBBLE < delta * 2\n        && icount_time_shift > 0) {\n        /* The guest is getting too far ahead.  Slow time down.  */\n        icount_time_shift--;\n    }\n    if (delta < 0\n        && last_delta - ICOUNT_WOBBLE > delta * 2\n        && icount_time_shift < MAX_ICOUNT_SHIFT) {\n        /* The guest is getting too far behind.  Speed time up.  */\n        icount_time_shift++;\n    }\n    last_delta = delta;\n    timers_state.qemu_icount_bias = cur_icount\n                              - (timers_state.qemu_icount << icount_time_shift);\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n}\n\nstatic void icount_adjust_rt(void *opaque)\n{\n    timer_mod(icount_rt_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL_RT) + 1000);\n    icount_adjust();\n}\n\nstatic void icount_adjust_vm(void *opaque)\n{\n    timer_mod(icount_vm_timer,\n                   qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n                   NANOSECONDS_PER_SECOND / 10);\n    icount_adjust();\n}\n\nstatic int64_t qemu_icount_round(int64_t count)\n{\n    return (count + (1 << icount_time_shift) - 1) >> icount_time_shift;\n}\n\nstatic void icount_warp_rt(void)\n{\n    unsigned seq;\n    int64_t warp_start;\n\n    /* The icount_warp_timer is rescheduled soon after vm_clock_warp_start\n     * changes from -1 to another value, so the race here is okay.\n     */\n    do {\n        seq = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n        warp_start = vm_clock_warp_start;\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, seq));\n\n    if (warp_start == -1) {\n        return;\n    }\n\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n    if (runstate_is_running()) {\n        int64_t clock = REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT,\n                                     cpu_get_clock_locked());\n        int64_t warp_delta;\n\n        warp_delta = clock - vm_clock_warp_start;\n        if (use_icount == 2) {\n            /*\n             * In adaptive mode, do not let QEMU_CLOCK_VIRTUAL run too\n             * far ahead of real time.\n             */\n            int64_t cur_icount = cpu_get_icount_locked();\n            int64_t delta = clock - cur_icount;\n            warp_delta = MIN(warp_delta, delta);\n        }\n        timers_state.qemu_icount_bias += warp_delta;\n    }\n    vm_clock_warp_start = -1;\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n\n    if (qemu_clock_expired(QEMU_CLOCK_VIRTUAL)) {\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n    }\n}\n\nstatic void icount_timer_cb(void *opaque)\n{\n    /* No need for a checkpoint because the timer already synchronizes\n     * with CHECKPOINT_CLOCK_VIRTUAL_RT.\n     */\n    icount_warp_rt();\n}\n\nvoid qtest_clock_warp(int64_t dest)\n{\n    int64_t clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    AioContext *aio_context;\n    assert(qtest_enabled());\n    aio_context = qemu_get_aio_context();\n    while (clock < dest) {\n        int64_t deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n        int64_t warp = qemu_soonest_timeout(dest - clock, deadline);\n\n        seqlock_write_begin(&timers_state.vm_clock_seqlock);\n        timers_state.qemu_icount_bias += warp;\n        seqlock_write_end(&timers_state.vm_clock_seqlock);\n\n        qemu_clock_run_timers(QEMU_CLOCK_VIRTUAL);\n        timerlist_run_timers(aio_context->tlg.tl[QEMU_CLOCK_VIRTUAL]);\n        clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    }\n    qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n}\n\nvoid qemu_start_warp_timer(void)\n{\n    int64_t clock;\n    int64_t deadline;\n\n    if (!use_icount) {\n        return;\n    }\n\n    /* Nothing to do if the VM is stopped: QEMU_CLOCK_VIRTUAL timers\n     * do not fire, so computing the deadline does not make sense.\n     */\n    if (!runstate_is_running()) {\n        return;\n    }\n\n    /* warp clock deterministically in record/replay mode */\n    if (!replay_checkpoint(CHECKPOINT_CLOCK_WARP_START)) {\n        return;\n    }\n\n    if (!all_cpu_threads_idle()) {\n        return;\n    }\n\n    if (qtest_enabled()) {\n        /* When testing, qtest commands advance icount.  */\n        return;\n    }\n\n    /* We want to use the earliest deadline from ALL vm_clocks */\n    clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);\n    deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n    if (deadline < 0) {\n        static bool notified;\n        if (!icount_sleep && !notified) {\n            error_report(\"WARNING: icount sleep disabled and no active timers\");\n            notified = true;\n        }\n        return;\n    }\n\n    if (deadline > 0) {\n        /*\n         * Ensure QEMU_CLOCK_VIRTUAL proceeds even when the virtual CPU goes to\n         * sleep.  Otherwise, the CPU might be waiting for a future timer\n         * interrupt to wake it up, but the interrupt never comes because\n         * the vCPU isn't running any insns and thus doesn't advance the\n         * QEMU_CLOCK_VIRTUAL.\n         */\n        if (!icount_sleep) {\n            /*\n             * We never let VCPUs sleep in no sleep icount mode.\n             * If there is a pending QEMU_CLOCK_VIRTUAL timer we just advance\n             * to the next QEMU_CLOCK_VIRTUAL event and notify it.\n             * It is useful when we want a deterministic execution time,\n             * isolated from host latencies.\n             */\n            seqlock_write_begin(&timers_state.vm_clock_seqlock);\n            timers_state.qemu_icount_bias += deadline;\n            seqlock_write_end(&timers_state.vm_clock_seqlock);\n            qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n        } else {\n            /*\n             * We do stop VCPUs and only advance QEMU_CLOCK_VIRTUAL after some\n             * \"real\" time, (related to the time left until the next event) has\n             * passed. The QEMU_CLOCK_VIRTUAL_RT clock will do this.\n             * This avoids that the warps are visible externally; for example,\n             * you will not be sending network packets continuously instead of\n             * every 100ms.\n             */\n            seqlock_write_begin(&timers_state.vm_clock_seqlock);\n            if (vm_clock_warp_start == -1 || vm_clock_warp_start > clock) {\n                vm_clock_warp_start = clock;\n            }\n            seqlock_write_end(&timers_state.vm_clock_seqlock);\n            timer_mod_anticipate(icount_warp_timer, clock + deadline);\n        }\n    } else if (deadline == 0) {\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n    }\n}\n\nstatic void qemu_account_warp_timer(void)\n{\n    if (!use_icount || !icount_sleep) {\n        return;\n    }\n\n    /* Nothing to do if the VM is stopped: QEMU_CLOCK_VIRTUAL timers\n     * do not fire, so computing the deadline does not make sense.\n     */\n    if (!runstate_is_running()) {\n        return;\n    }\n\n    /* warp clock deterministically in record/replay mode */\n    if (!replay_checkpoint(CHECKPOINT_CLOCK_WARP_ACCOUNT)) {\n        return;\n    }\n\n    timer_del(icount_warp_timer);\n    icount_warp_rt();\n}\n\nstatic bool icount_state_needed(void *opaque)\n{\n    return use_icount;\n}\n\n/*\n * This is a subsection for icount migration.\n */\nstatic const VMStateDescription icount_vmstate_timers = {\n    .name = \"timer/icount\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .needed = icount_state_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_INT64(qemu_icount_bias, TimersState),\n        VMSTATE_INT64(qemu_icount, TimersState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic const VMStateDescription vmstate_timers = {\n    .name = \"timer\",\n    .version_id = 2,\n    .minimum_version_id = 1,\n    .fields = (VMStateField[]) {\n        VMSTATE_INT64(cpu_ticks_offset, TimersState),\n        VMSTATE_INT64(dummy, TimersState),\n        VMSTATE_INT64_V(cpu_clock_offset, TimersState, 2),\n        VMSTATE_END_OF_LIST()\n    },\n    .subsections = (const VMStateDescription*[]) {\n        &icount_vmstate_timers,\n        NULL\n    }\n};\n\nstatic void cpu_throttle_thread(CPUState *cpu, run_on_cpu_data opaque)\n{\n    double pct;\n    double throttle_ratio;\n    long sleeptime_ns;\n\n    if (!cpu_throttle_get_percentage()) {\n        return;\n    }\n\n    pct = (double)cpu_throttle_get_percentage()/100;\n    throttle_ratio = pct / (1 - pct);\n    sleeptime_ns = (long)(throttle_ratio * CPU_THROTTLE_TIMESLICE_NS);\n\n    qemu_mutex_unlock_iothread();\n    atomic_set(&cpu->throttle_thread_scheduled, 0);\n    g_usleep(sleeptime_ns / 1000); /* Convert ns to us for usleep call */\n    qemu_mutex_lock_iothread();\n}\n\nstatic void cpu_throttle_timer_tick(void *opaque)\n{\n    CPUState *cpu;\n    double pct;\n\n    /* Stop the timer if needed */\n    if (!cpu_throttle_get_percentage()) {\n        return;\n    }\n    CPU_FOREACH(cpu) {\n        if (!atomic_xchg(&cpu->throttle_thread_scheduled, 1)) {\n            async_run_on_cpu(cpu, cpu_throttle_thread,\n                             RUN_ON_CPU_NULL);\n        }\n    }\n\n    pct = (double)cpu_throttle_get_percentage()/100;\n    timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +\n                                   CPU_THROTTLE_TIMESLICE_NS / (1-pct));\n}\n\nvoid cpu_throttle_set(int new_throttle_pct)\n{\n    /* Ensure throttle percentage is within valid range */\n    new_throttle_pct = MIN(new_throttle_pct, CPU_THROTTLE_PCT_MAX);\n    new_throttle_pct = MAX(new_throttle_pct, CPU_THROTTLE_PCT_MIN);\n\n    atomic_set(&throttle_percentage, new_throttle_pct);\n\n    timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +\n                                       CPU_THROTTLE_TIMESLICE_NS);\n}\n\nvoid cpu_throttle_stop(void)\n{\n    atomic_set(&throttle_percentage, 0);\n}\n\nbool cpu_throttle_active(void)\n{\n    return (cpu_throttle_get_percentage() != 0);\n}\n\nint cpu_throttle_get_percentage(void)\n{\n    return atomic_read(&throttle_percentage);\n}\n\nvoid cpu_ticks_init(void)\n{\n    seqlock_init(&timers_state.vm_clock_seqlock);\n    vmstate_register(NULL, 0, &vmstate_timers, &timers_state);\n    throttle_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL_RT,\n                                           cpu_throttle_timer_tick, NULL);\n}\n\nvoid configure_icount(QemuOpts *opts, Error **errp)\n{\n    const char *option;\n    char *rem_str = NULL;\n\n    option = qemu_opt_get(opts, \"shift\");\n    if (!option) {\n        if (qemu_opt_get(opts, \"align\") != NULL) {\n            error_setg(errp, \"Please specify shift option when using align\");\n        }\n        return;\n    }\n\n    icount_sleep = qemu_opt_get_bool(opts, \"sleep\", true);\n    if (icount_sleep) {\n        icount_warp_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL_RT,\n                                         icount_timer_cb, NULL);\n    }\n\n    icount_align_option = qemu_opt_get_bool(opts, \"align\", false);\n\n    if (icount_align_option && !icount_sleep) {\n        error_setg(errp, \"align=on and sleep=off are incompatible\");\n    }\n    if (strcmp(option, \"auto\") != 0) {\n        errno = 0;\n        icount_time_shift = strtol(option, &rem_str, 0);\n        if (errno != 0 || *rem_str != '\\0' || !strlen(option)) {\n            error_setg(errp, \"icount: Invalid shift value\");\n        }\n        use_icount = 1;\n        return;\n    } else if (icount_align_option) {\n        error_setg(errp, \"shift=auto and align=on are incompatible\");\n    } else if (!icount_sleep) {\n        error_setg(errp, \"shift=auto and sleep=off are incompatible\");\n    }\n\n    use_icount = 2;\n\n    /* 125MIPS seems a reasonable initial guess at the guest speed.\n       It will be corrected fairly quickly anyway.  */\n    icount_time_shift = 3;\n\n    /* Have both realtime and virtual time triggers for speed adjustment.\n       The realtime trigger catches emulated time passing too slowly,\n       the virtual time trigger catches emulated time passing too fast.\n       Realtime triggers occur even when idle, so use them less frequently\n       than VM triggers.  */\n    icount_rt_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL_RT,\n                                   icount_adjust_rt, NULL);\n    timer_mod(icount_rt_timer,\n                   qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL_RT) + 1000);\n    icount_vm_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                                        icount_adjust_vm, NULL);\n    timer_mod(icount_vm_timer,\n                   qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n                   NANOSECONDS_PER_SECOND / 10);\n}\n\n/***********************************************************/\n/* TCG vCPU kick timer\n *\n * The kick timer is responsible for moving single threaded vCPU\n * emulation on to the next vCPU. If more than one vCPU is running a\n * timer event with force a cpu->exit so the next vCPU can get\n * scheduled.\n *\n * The timer is removed if all vCPUs are idle and restarted again once\n * idleness is complete.\n */\n\nstatic QEMUTimer *tcg_kick_vcpu_timer;\nstatic CPUState *tcg_current_rr_cpu;\n\n#define TCG_KICK_PERIOD (NANOSECONDS_PER_SECOND / 10)\n\nstatic inline int64_t qemu_tcg_next_kick(void)\n{\n    return qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + TCG_KICK_PERIOD;\n}\n\n/* Kick the currently round-robin scheduled vCPU */\nstatic void qemu_cpu_kick_rr_cpu(void)\n{\n    CPUState *cpu;\n    do {\n        cpu = atomic_mb_read(&tcg_current_rr_cpu);\n        if (cpu) {\n            cpu_exit(cpu);\n        }\n    } while (cpu != atomic_mb_read(&tcg_current_rr_cpu));\n}\n\nvoid qemu_timer_notify_cb(void *opaque, QEMUClockType type)\n{\n    qemu_notify_event();\n}\n\nstatic void kick_tcg_thread(void *opaque)\n{\n    timer_mod(tcg_kick_vcpu_timer, qemu_tcg_next_kick());\n    qemu_cpu_kick_rr_cpu();\n}\n\nstatic void start_tcg_kick_timer(void)\n{\n    if (!tcg_kick_vcpu_timer && CPU_NEXT(first_cpu)) {\n        tcg_kick_vcpu_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                                           kick_tcg_thread, NULL);\n        timer_mod(tcg_kick_vcpu_timer, qemu_tcg_next_kick());\n    }\n}\n\nstatic void stop_tcg_kick_timer(void)\n{\n    if (tcg_kick_vcpu_timer) {\n        timer_del(tcg_kick_vcpu_timer);\n        tcg_kick_vcpu_timer = NULL;\n    }\n}\n\n/***********************************************************/\nvoid hw_error(const char *fmt, ...)\n{\n    va_list ap;\n    CPUState *cpu;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"qemu: hardware error: \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \"\\n\");\n    CPU_FOREACH(cpu) {\n        fprintf(stderr, \"CPU #%d:\\n\", cpu->cpu_index);\n        cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_FPU);\n    }\n    va_end(ap);\n    abort();\n}\n\nvoid cpu_synchronize_all_states(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        cpu_synchronize_state(cpu);\n    }\n}\n\nvoid cpu_synchronize_all_post_reset(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        cpu_synchronize_post_reset(cpu);\n    }\n}\n\nvoid cpu_synchronize_all_post_init(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        cpu_synchronize_post_init(cpu);\n    }\n}\n\nint do_vm_stop(RunState state)\n{\n    int ret = 0;\n\n    if (runstate_is_running()) {\n        cpu_disable_ticks();\n        pause_all_vcpus();\n        runstate_set(state);\n        vm_state_notify(0, state);\n        qapi_event_send_stop(&error_abort);\n    }\n\n    bdrv_drain_all();\n    replay_disable_events();\n    ret = bdrv_flush_all();\n\n    return ret;\n}\n\nstatic bool cpu_can_run(CPUState *cpu)\n{\n    if (cpu->stop) {\n        return false;\n    }\n    if (cpu_is_stopped(cpu)) {\n        return false;\n    }\n    return true;\n}\n\nstatic void cpu_handle_guest_debug(CPUState *cpu)\n{\n    gdb_set_stop_cpu(cpu);\n    qemu_system_debug_request();\n    cpu->stopped = true;\n}\n\n#ifdef CONFIG_LINUX\nstatic void sigbus_reraise(void)\n{\n    sigset_t set;\n    struct sigaction action;\n\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = SIG_DFL;\n    if (!sigaction(SIGBUS, &action, NULL)) {\n        raise(SIGBUS);\n        sigemptyset(&set);\n        sigaddset(&set, SIGBUS);\n        pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n    }\n    perror(\"Failed to re-raise SIGBUS!\\n\");\n    abort();\n}\n\nstatic void sigbus_handler(int n, siginfo_t *siginfo, void *ctx)\n{\n    if (siginfo->si_code != BUS_MCEERR_AO && siginfo->si_code != BUS_MCEERR_AR) {\n        sigbus_reraise();\n    }\n\n    if (current_cpu) {\n        /* Called asynchronously in VCPU thread.  */\n        if (kvm_on_sigbus_vcpu(current_cpu, siginfo->si_code, siginfo->si_addr)) {\n            sigbus_reraise();\n        }\n    } else {\n        /* Called synchronously (via signalfd) in main thread.  */\n        if (kvm_on_sigbus(siginfo->si_code, siginfo->si_addr)) {\n            sigbus_reraise();\n        }\n    }\n}\n\nstatic void qemu_init_sigbus(void)\n{\n    struct sigaction action;\n\n    memset(&action, 0, sizeof(action));\n    action.sa_flags = SA_SIGINFO;\n    action.sa_sigaction = sigbus_handler;\n    sigaction(SIGBUS, &action, NULL);\n\n    prctl(PR_MCE_KILL, PR_MCE_KILL_SET, PR_MCE_KILL_EARLY, 0, 0);\n}\n#else /* !CONFIG_LINUX */\nstatic void qemu_init_sigbus(void)\n{\n}\n#endif /* !CONFIG_LINUX */\n\nstatic QemuMutex qemu_global_mutex;\nstatic QemuCond qemu_io_proceeded_cond;\nstatic unsigned iothread_requesting_mutex;\n\nstatic QemuThread io_thread;\n\n/* cpu creation */\nstatic QemuCond qemu_cpu_cond;\n/* system init */\nstatic QemuCond qemu_pause_cond;\n\nvoid qemu_init_cpu_loop(void)\n{\n    qemu_init_sigbus();\n    qemu_cond_init(&qemu_cpu_cond);\n    qemu_cond_init(&qemu_pause_cond);\n    qemu_cond_init(&qemu_io_proceeded_cond);\n    qemu_mutex_init(&qemu_global_mutex);\n\n    qemu_thread_get_self(&io_thread);\n}\n\nvoid run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data)\n{\n    do_run_on_cpu(cpu, func, data, &qemu_global_mutex);\n}\n\nstatic void qemu_kvm_destroy_vcpu(CPUState *cpu)\n{\n    if (kvm_destroy_vcpu(cpu) < 0) {\n        error_report(\"kvm_destroy_vcpu failed\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void qemu_tcg_destroy_vcpu(CPUState *cpu)\n{\n}\n\nstatic void qemu_wait_io_event_common(CPUState *cpu)\n{\n    if (cpu->stop) {\n        cpu->stop = false;\n        cpu->stopped = true;\n        qemu_cond_broadcast(&qemu_pause_cond);\n    }\n    process_queued_cpu_work(cpu);\n    cpu->thread_kicked = false;\n}\n\nstatic void qemu_tcg_wait_io_event(CPUState *cpu)\n{\n    while (all_cpu_threads_idle()) {\n        // We're in replay, so replay the interrupt!\n        // Otherwise e.g. if the CPU has HLTd it will just sit here forever.\n        if (rr_in_replay() && rr_num_instr_before_next_interrupt() == 0) break;\n\n        stop_tcg_kick_timer();\n        qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);\n    }\n\n    start_tcg_kick_timer();\n\n    while (iothread_requesting_mutex) {\n        qemu_cond_wait(&qemu_io_proceeded_cond, &qemu_global_mutex);\n    }\n\n    CPU_FOREACH(cpu) {\n        qemu_wait_io_event_common(cpu);\n    }\n}\n\nstatic void qemu_kvm_wait_io_event(CPUState *cpu)\n{\n    while (cpu_thread_is_idle(cpu)) {\n        qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);\n    }\n\n    qemu_wait_io_event_common(cpu);\n}\n\nstatic void *qemu_kvm_cpu_thread_fn(void *arg)\n{\n    CPUState *cpu = arg;\n    int r;\n\n    rcu_register_thread();\n\n    qemu_mutex_lock_iothread();\n    qemu_thread_get_self(cpu->thread);\n    cpu->thread_id = qemu_get_thread_id();\n    cpu->can_do_io = 1;\n    current_cpu = cpu;\n\n    r = kvm_init_vcpu(cpu);\n    if (r < 0) {\n        fprintf(stderr, \"kvm_init_vcpu failed: %s\\n\", strerror(-r));\n        exit(1);\n    }\n\n    kvm_init_cpu_signals(cpu);\n\n    /* signal CPU creation */\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n\n    do {\n        if (cpu_can_run(cpu)) {\n            r = kvm_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n        qemu_kvm_wait_io_event(cpu);\n    } while (!cpu->unplug || cpu_can_run(cpu));\n\n    qemu_kvm_destroy_vcpu(cpu);\n    cpu->created = false;\n    qemu_cond_signal(&qemu_cpu_cond);\n    qemu_mutex_unlock_iothread();\n    return NULL;\n}\n\nstatic void *qemu_dummy_cpu_thread_fn(void *arg)\n{\n#ifdef _WIN32\n    fprintf(stderr, \"qtest is not supported under Windows\\n\");\n    exit(1);\n#else\n    CPUState *cpu = arg;\n    sigset_t waitset;\n    int r;\n\n    rcu_register_thread();\n\n    qemu_mutex_lock_iothread();\n    qemu_thread_get_self(cpu->thread);\n    cpu->thread_id = qemu_get_thread_id();\n    cpu->can_do_io = 1;\n\n    sigemptyset(&waitset);\n    sigaddset(&waitset, SIG_IPI);\n\n    /* signal CPU creation */\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n\n    current_cpu = cpu;\n    while (1) {\n        current_cpu = NULL;\n        qemu_mutex_unlock_iothread();\n        do {\n            int sig;\n            r = sigwait(&waitset, &sig);\n        } while (r == -1 && (errno == EAGAIN || errno == EINTR));\n        if (r == -1) {\n            perror(\"sigwait\");\n            exit(1);\n        }\n        qemu_mutex_lock_iothread();\n        current_cpu = cpu;\n        qemu_wait_io_event_common(cpu);\n    }\n\n    return NULL;\n#endif\n}\n\nstatic int64_t tcg_get_icount_limit(void)\n{\n    int64_t deadline;\n\n    if (replay_mode != REPLAY_MODE_PLAY) {\n        deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n\n        /* Maintain prior (possibly buggy) behaviour where if no deadline\n         * was set (as there is no QEMU_CLOCK_VIRTUAL timer) or it is more than\n         * INT32_MAX nanoseconds ahead, we still use INT32_MAX\n         * nanoseconds.\n         */\n        if ((deadline < 0) || (deadline > INT32_MAX)) {\n            deadline = INT32_MAX;\n        }\n\n        return qemu_icount_round(deadline);\n    } else {\n        return replay_get_instructions();\n    }\n}\n\nstatic void handle_icount_deadline(void)\n{\n    if (use_icount) {\n        int64_t deadline =\n            qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n\n        if (deadline == 0) {\n            qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n        }\n    }\n}\n\nstatic int tcg_cpu_exec(CPUState *cpu)\n{\n    int ret;\n#ifdef CONFIG_PROFILER\n    int64_t ti;\n#endif\n\n#ifdef CONFIG_PROFILER\n    ti = profile_getclock();\n#endif\n    if (use_icount) {\n        int64_t count;\n        int decr;\n        timers_state.qemu_icount -= (cpu->icount_decr.u16.low\n                                    + cpu->icount_extra);\n        cpu->icount_decr.u16.low = 0;\n        cpu->icount_extra = 0;\n        count = tcg_get_icount_limit();\n        timers_state.qemu_icount += count;\n        decr = (count > 0xffff) ? 0xffff : count;\n        count -= decr;\n        cpu->icount_decr.u16.low = decr;\n        cpu->icount_extra = count;\n    }\n    cpu_exec_start(cpu);\n    ret = cpu_exec(cpu);\n    cpu_exec_end(cpu);\n#ifdef CONFIG_PROFILER\n    tcg_time += profile_getclock() - ti;\n#endif\n    if (use_icount) {\n        /* Fold pending instructions back into the\n           instruction counter, and clear the interrupt flag.  */\n        timers_state.qemu_icount -= (cpu->icount_decr.u16.low\n                        + cpu->icount_extra);\n        cpu->icount_decr.u32 = 0;\n        cpu->icount_extra = 0;\n        replay_account_executed_instructions();\n    }\n    return ret;\n}\n\n/* Destroy any remaining vCPUs which have been unplugged and have\n * finished running\n */\nstatic void deal_with_unplugged_cpus(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu->unplug && !cpu_can_run(cpu)) {\n            qemu_tcg_destroy_vcpu(cpu);\n            cpu->created = false;\n            qemu_cond_signal(&qemu_cpu_cond);\n            break;\n        }\n    }\n}\n\n/* Single-threaded TCG\n *\n * In the single-threaded case each vCPU is simulated in turn. If\n * there is more than a single vCPU we create a simple timer to kick\n * the vCPU and ensure we don't get stuck in a tight loop in one vCPU.\n * This is done explicitly rather than relying on side-effects\n * elsewhere.\n */\n\nstatic void *qemu_tcg_cpu_thread_fn(void *arg)\n{\n    CPUState *cpu = arg;\n\n    rcu_register_thread();\n\n    qemu_mutex_lock_iothread();\n    qemu_thread_get_self(cpu->thread);\n\n    CPU_FOREACH(cpu) {\n        cpu->thread_id = qemu_get_thread_id();\n        cpu->created = true;\n        cpu->can_do_io = 1;\n    }\n    qemu_cond_signal(&qemu_cpu_cond);\n\n    /* wait for initial kick-off after machine start */\n    while (first_cpu->stopped) {\n        qemu_cond_wait(first_cpu->halt_cond, &qemu_global_mutex);\n\n        /* process any pending work */\n        CPU_FOREACH(cpu) {\n            qemu_wait_io_event_common(cpu);\n        }\n    }\n\n    start_tcg_kick_timer();\n\n    cpu = first_cpu;\n\n    /* process any pending work */\n    cpu->exit_request = 1;\n\n    while (1) {\n\n        if (!rr_replay_complete) {\n            panda_callbacks_top_loop(cpu);\n        }\n\n        /* Account partial waits to QEMU_CLOCK_VIRTUAL.  */\n        qemu_account_warp_timer();\n\n        if (!cpu) {\n            cpu = first_cpu;\n        }\n\n        while (cpu && !cpu->queued_work_first && !cpu->exit_request) {\n\n            atomic_mb_set(&tcg_current_rr_cpu, cpu);\n\n            qemu_clock_enable(QEMU_CLOCK_VIRTUAL,\n                              (cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);\n\n            if (cpu_can_run(cpu)) {\n                int r;\n                r = tcg_cpu_exec(cpu);\n                if (r == EXCP_DEBUG) {\n                    cpu_handle_guest_debug(cpu);\n                    break;\n                }\n            } else if (cpu->stop || cpu->stopped) {\n                if (cpu->unplug) {\n                    cpu = CPU_NEXT(cpu);\n                }\n                break;\n            }\n\n            cpu = CPU_NEXT(cpu);\n\n            if (panda_exit_loop) { // If we have a request to break, do so and\n                                   // unset panda_exit_loop\n                panda_exit_loop = false;\n                //atomic_mb_set(&cpu->exit_request, 1); // XXX: Should we set an exit request?\n                break;\n            }\n\n        } /* while (cpu && !cpu->exit_request).. */\n\n        /* Does not need atomic_mb_set because a spurious wakeup is okay.  */\n        atomic_set(&tcg_current_rr_cpu, NULL);\n\n        if (cpu && cpu->exit_request) {\n            atomic_mb_set(&cpu->exit_request, 0);\n        }\n\n        handle_icount_deadline();\n\n        qemu_tcg_wait_io_event(QTAILQ_FIRST(&cpus));\n        deal_with_unplugged_cpus();\n\n    }\n\n    return NULL;\n}\n\nstatic void *qemu_hax_cpu_thread_fn(void *arg)\n{\n    CPUState *cpu = arg;\n    int r;\n\n    qemu_mutex_lock_iothread();\n    qemu_thread_get_self(cpu->thread);\n\n    cpu->thread_id = qemu_get_thread_id();\n    cpu->created = true;\n    cpu->halted = 0;\n    current_cpu = cpu;\n\n    hax_init_vcpu(cpu);\n    qemu_cond_signal(&qemu_cpu_cond);\n\n    while (1) {\n        if (cpu_can_run(cpu)) {\n            r = hax_smp_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n\n        while (cpu_thread_is_idle(cpu)) {\n            qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);\n        }\n#ifdef _WIN32\n        SleepEx(0, TRUE);\n#endif\n        qemu_wait_io_event_common(cpu);\n    }\n    return NULL;\n}\n\n#ifdef _WIN32\nstatic void CALLBACK dummy_apc_func(ULONG_PTR unused)\n{\n}\n#endif\n\nstatic void qemu_cpu_kick_thread(CPUState *cpu)\n{\n#ifndef _WIN32\n    int err;\n\n    if (cpu->thread_kicked) {\n        return;\n    }\n    cpu->thread_kicked = true;\n    err = pthread_kill(cpu->thread->thread, SIG_IPI);\n    if (err) {\n        fprintf(stderr, \"qemu:%s: %s\", __func__, strerror(err));\n        exit(1);\n    }\n#else /* _WIN32 */\n    if (!qemu_cpu_is_self(cpu)) {\n        if (!QueueUserAPC(dummy_apc_func, cpu->hThread, 0)) {\n            fprintf(stderr, \"%s: QueueUserAPC failed with error %lu\\n\",\n                    __func__, GetLastError());\n            exit(1);\n        }\n    }\n#endif\n}\n\nvoid qemu_cpu_kick(CPUState *cpu)\n{\n    qemu_cond_broadcast(cpu->halt_cond);\n    if (tcg_enabled()) {\n        cpu_exit(cpu);\n        /* Also ensure current RR cpu is kicked */\n        qemu_cpu_kick_rr_cpu();\n    } else {\n        if (hax_enabled()) {\n            /*\n             * FIXME: race condition with the exit_request check in\n             * hax_vcpu_hax_exec\n             */\n            cpu->exit_request = 1;\n        }\n        qemu_cpu_kick_thread(cpu);\n    }\n}\n\nvoid qemu_cpu_kick_self(void)\n{\n    assert(current_cpu);\n    qemu_cpu_kick_thread(current_cpu);\n}\n\nbool qemu_cpu_is_self(CPUState *cpu)\n{\n    return qemu_thread_is_self(cpu->thread);\n}\n\nbool qemu_in_vcpu_thread(void)\n{\n    return current_cpu && qemu_cpu_is_self(current_cpu);\n}\n\nstatic __thread bool iothread_locked = false;\n\nbool qemu_mutex_iothread_locked(void)\n{\n    return iothread_locked;\n}\n\nvoid qemu_mutex_lock_iothread(void)\n{\n    atomic_inc(&iothread_requesting_mutex);\n    /* In the simple case there is no need to bump the VCPU thread out of\n     * TCG code execution.\n     */\n    if (!tcg_enabled() || qemu_in_vcpu_thread() ||\n        !first_cpu || !first_cpu->created) {\n        qemu_mutex_lock(&qemu_global_mutex);\n        atomic_dec(&iothread_requesting_mutex);\n    } else {\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n            qemu_cpu_kick_rr_cpu();\n            qemu_mutex_lock(&qemu_global_mutex);\n        }\n        atomic_dec(&iothread_requesting_mutex);\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n    }\n    iothread_locked = true;\n}\n\nvoid qemu_mutex_unlock_iothread(void)\n{\n    iothread_locked = false;\n    qemu_mutex_unlock(&qemu_global_mutex);\n}\n\nstatic bool all_vcpus_paused(void)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (!cpu->stopped) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid pause_all_vcpus(void)\n{\n    CPUState *cpu;\n\n    qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);\n    CPU_FOREACH(cpu) {\n        cpu->stop = true;\n        qemu_cpu_kick(cpu);\n    }\n\n    if (qemu_in_vcpu_thread()) {\n        cpu_stop_current();\n        if (!kvm_enabled()) {\n            CPU_FOREACH(cpu) {\n                cpu->stop = false;\n                cpu->stopped = true;\n            }\n            return;\n        }\n    }\n\n    while (!all_vcpus_paused()) {\n        qemu_cond_wait(&qemu_pause_cond, &qemu_global_mutex);\n        CPU_FOREACH(cpu) {\n            qemu_cpu_kick(cpu);\n        }\n    }\n}\n\nvoid cpu_resume(CPUState *cpu)\n{\n    cpu->stop = false;\n    cpu->stopped = false;\n    qemu_cpu_kick(cpu);\n}\n\nvoid resume_all_vcpus(void)\n{\n    CPUState *cpu;\n\n    qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);\n    CPU_FOREACH(cpu) {\n        cpu_resume(cpu);\n    }\n}\n\nvoid cpu_remove(CPUState *cpu)\n{\n    cpu->stop = true;\n    cpu->unplug = true;\n    qemu_cpu_kick(cpu);\n}\n\nvoid cpu_remove_sync(CPUState *cpu)\n{\n    cpu_remove(cpu);\n    while (cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n}\n\n/* For temporary buffers for forming a name */\n#define VCPU_THREAD_NAME_SIZE 16\n\nstatic void qemu_tcg_init_vcpu(CPUState *cpu)\n{\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n    static QemuCond *tcg_halt_cond;\n    static QemuThread *tcg_cpu_thread;\n\n    /* share a single thread for all cpus with TCG */\n    if (!tcg_cpu_thread) {\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n        qemu_cond_init(cpu->halt_cond);\n        tcg_halt_cond = cpu->halt_cond;\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n                 cpu->cpu_index);\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n                           cpu, QEMU_THREAD_JOINABLE);\n#ifdef _WIN32\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n#endif\n        while (!cpu->created) {\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n        }\n        tcg_cpu_thread = cpu->thread;\n    } else {\n        cpu->thread = tcg_cpu_thread;\n        cpu->halt_cond = tcg_halt_cond;\n    }\n}\n\nstatic void qemu_hax_start_vcpu(CPUState *cpu)\n{\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    cpu->thread = g_malloc0(sizeof(QemuThread));\n    cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n    qemu_cond_init(cpu->halt_cond);\n\n    snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/HAX\",\n             cpu->cpu_index);\n    qemu_thread_create(cpu->thread, thread_name, qemu_hax_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n#ifdef _WIN32\n    cpu->hThread = qemu_thread_get_handle(cpu->thread);\n#endif\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n}\n\nstatic void qemu_kvm_start_vcpu(CPUState *cpu)\n{\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    cpu->thread = g_malloc0(sizeof(QemuThread));\n    cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n    qemu_cond_init(cpu->halt_cond);\n    snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/KVM\",\n             cpu->cpu_index);\n    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n}\n\nstatic void qemu_dummy_start_vcpu(CPUState *cpu)\n{\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    cpu->thread = g_malloc0(sizeof(QemuThread));\n    cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n    qemu_cond_init(cpu->halt_cond);\n    snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/DUMMY\",\n             cpu->cpu_index);\n    qemu_thread_create(cpu->thread, thread_name, qemu_dummy_cpu_thread_fn, cpu,\n                       QEMU_THREAD_JOINABLE);\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n}\n\nvoid qemu_init_vcpu(CPUState *cpu)\n{\n    cpu->nr_cores = smp_cores;\n    cpu->nr_threads = smp_threads;\n    cpu->stopped = true;\n\n    if (!cpu->as) {\n        /* If the target cpu hasn't set up any address spaces itself,\n         * give it the default one.\n         */\n        AddressSpace *as = address_space_init_shareable(cpu->memory,\n                                                        \"cpu-memory\");\n        cpu->num_ases = 1;\n        cpu_address_space_init(cpu, as, 0);\n    }\n\n    if (kvm_enabled()) {\n        qemu_kvm_start_vcpu(cpu);\n    } else if (hax_enabled()) {\n        qemu_hax_start_vcpu(cpu);\n    } else if (tcg_enabled()) {\n        qemu_tcg_init_vcpu(cpu);\n    } else {\n        qemu_dummy_start_vcpu(cpu);\n    }\n}\n\nvoid cpu_stop_current(void)\n{\n    if (current_cpu) {\n        current_cpu->stop = false;\n        current_cpu->stopped = true;\n        cpu_exit(current_cpu);\n        qemu_cond_broadcast(&qemu_pause_cond);\n    }\n}\n\nint vm_stop(RunState state)\n{\n    if (qemu_in_vcpu_thread()) {\n        qemu_system_vmstop_request_prepare();\n        qemu_system_vmstop_request(state);\n        /*\n         * FIXME: should not return to device code in case\n         * vm_stop() has been requested.\n         */\n        cpu_stop_current();\n        return 0;\n    }\n\n    return do_vm_stop(state);\n}\n\n/**\n * Prepare for (re)starting the VM.\n * Returns -1 if the vCPUs are not to be restarted (e.g. if they are already\n * running or in case of an error condition), 0 otherwise.\n */\nint vm_prepare_start(void)\n{\n    RunState requested;\n    int res = 0;\n\n    qemu_vmstop_requested(&requested);\n    if (runstate_is_running() && requested == RUN_STATE__MAX) {\n        return -1;\n    }\n\n    /* Ensure that a STOP/RESUME pair of events is emitted if a\n     * vmstop request was pending.  The BLOCK_IO_ERROR event, for\n     * example, according to documentation is always followed by\n     * the STOP event.\n     */\n    if (runstate_is_running()) {\n        qapi_event_send_stop(&error_abort);\n        res = -1;\n    } else {\n        replay_enable_events();\n        cpu_enable_ticks();\n        runstate_set(RUN_STATE_RUNNING);\n        vm_state_notify(1, RUN_STATE_RUNNING);\n    }\n\n    /* We are sending this now, but the CPUs will be resumed shortly later */\n    qapi_event_send_resume(&error_abort);\n    return res;\n}\n\nvoid vm_start(void)\n{\n    if (!vm_prepare_start()) {\n        resume_all_vcpus();\n    }\n}\n\n/* does a state transition even if the VM is already stopped,\n   current state is forgotten forever */\nint vm_stop_force_state(RunState state)\n{\n    if (runstate_is_running()) {\n        return vm_stop(state);\n    } else {\n        runstate_set(state);\n\n        bdrv_drain_all();\n        /* Make sure to return an error if the flush in a previous vm_stop()\n         * failed. */\n        return bdrv_flush_all();\n    }\n}\n\nvoid list_cpus(FILE *f, fprintf_function cpu_fprintf, const char *optarg)\n{\n    /* XXX: implement xxx_cpu_list for targets that still miss it */\n#if defined(cpu_list)\n    cpu_list(f, cpu_fprintf);\n#endif\n}\n\nCpuInfoList *qmp_query_cpus(Error **errp)\n{\n    CpuInfoList *head = NULL, *cur_item = NULL;\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        CpuInfoList *info;\n#if defined(TARGET_I386)\n        X86CPU *x86_cpu = X86_CPU(cpu);\n        CPUX86State *env = &x86_cpu->env;\n#elif defined(TARGET_PPC)\n        PowerPCCPU *ppc_cpu = POWERPC_CPU(cpu);\n        CPUPPCState *env = &ppc_cpu->env;\n#elif defined(TARGET_SPARC)\n        SPARCCPU *sparc_cpu = SPARC_CPU(cpu);\n        CPUSPARCState *env = &sparc_cpu->env;\n#elif defined(TARGET_MIPS)\n        MIPSCPU *mips_cpu = MIPS_CPU(cpu);\n        CPUMIPSState *env = &mips_cpu->env;\n#elif defined(TARGET_TRICORE)\n        TriCoreCPU *tricore_cpu = TRICORE_CPU(cpu);\n        CPUTriCoreState *env = &tricore_cpu->env;\n#endif\n\n        cpu_synchronize_state(cpu);\n\n        info = g_malloc0(sizeof(*info));\n        info->value = g_malloc0(sizeof(*info->value));\n        info->value->CPU = cpu->cpu_index;\n        info->value->current = (cpu == first_cpu);\n        info->value->halted = cpu->halted;\n        info->value->qom_path = object_get_canonical_path(OBJECT(cpu));\n        info->value->thread_id = cpu->thread_id;\n#if defined(TARGET_I386)\n        info->value->arch = CPU_INFO_ARCH_X86;\n        info->value->u.x86.pc = env->eip + env->segs[R_CS].base;\n#elif defined(TARGET_PPC)\n        info->value->arch = CPU_INFO_ARCH_PPC;\n        info->value->u.ppc.nip = env->nip;\n#elif defined(TARGET_SPARC)\n        info->value->arch = CPU_INFO_ARCH_SPARC;\n        info->value->u.q_sparc.pc = env->pc;\n        info->value->u.q_sparc.npc = env->npc;\n#elif defined(TARGET_MIPS)\n        info->value->arch = CPU_INFO_ARCH_MIPS;\n        info->value->u.q_mips.PC = env->active_tc.PC;\n#elif defined(TARGET_TRICORE)\n        info->value->arch = CPU_INFO_ARCH_TRICORE;\n        info->value->u.tricore.PC = env->PC;\n#else\n        info->value->arch = CPU_INFO_ARCH_OTHER;\n#endif\n\n        /* XXX: waiting for the qapi to support GSList */\n        if (!cur_item) {\n            head = cur_item = info;\n        } else {\n            cur_item->next = info;\n            cur_item = info;\n        }\n    }\n\n    return head;\n}\n\nvoid qmp_memsave(int64_t addr, int64_t size, const char *filename,\n                 bool has_cpu, int64_t cpu_index, Error **errp)\n{\n    FILE *f;\n    uint32_t l;\n    CPUState *cpu;\n    uint8_t buf[1024];\n    int64_t orig_addr = addr, orig_size = size;\n\n    if (!has_cpu) {\n        cpu_index = 0;\n    }\n\n    cpu = qemu_get_cpu(cpu_index);\n    if (cpu == NULL) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cpu-index\",\n                   \"a CPU number\");\n        return;\n    }\n\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        error_setg_file_open(errp, errno, filename);\n        return;\n    }\n\n    while (size != 0) {\n        l = sizeof(buf);\n        if (l > size)\n            l = size;\n        if (cpu_memory_rw_debug(cpu, addr, buf, l, 0) != 0) {\n            error_setg(errp, \"Invalid addr 0x%016\" PRIx64 \"/size %\" PRId64\n                             \" specified\", orig_addr, orig_size);\n            goto exit;\n        }\n        if (fwrite(buf, 1, l, f) != l) {\n            error_setg(errp, QERR_IO_ERROR);\n            goto exit;\n        }\n        addr += l;\n        size -= l;\n    }\n\nexit:\n    fclose(f);\n}\n\nvoid qmp_pmemsave(int64_t addr, int64_t size, const char *filename,\n                  Error **errp)\n{\n    FILE *f;\n    uint32_t l;\n    uint8_t buf[1024];\n\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        error_setg_file_open(errp, errno, filename);\n        return;\n    }\n\n    while (size != 0) {\n        l = sizeof(buf);\n        if (l > size)\n            l = size;\n        cpu_physical_memory_read(addr, buf, l);\n        if (fwrite(buf, 1, l, f) != l) {\n            error_setg(errp, QERR_IO_ERROR);\n            goto exit;\n        }\n        addr += l;\n        size -= l;\n    }\n\nexit:\n    fclose(f);\n}\n\nvoid qmp_inject_nmi(Error **errp)\n{\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n}\n\nvoid dump_drift_info(FILE *f, fprintf_function cpu_fprintf)\n{\n    if (!use_icount) {\n        return;\n    }\n\n    cpu_fprintf(f, \"Host - Guest clock  %\"PRIi64\" ms\\n\",\n                (cpu_get_clock() - cpu_get_icount())/SCALE_MS);\n    if (icount_align_option) {\n        cpu_fprintf(f, \"Max guest delay     %\"PRIi64\" ms\\n\", -max_delay/SCALE_MS);\n        cpu_fprintf(f, \"Max guest advance   %\"PRIi64\" ms\\n\", max_advance/SCALE_MS);\n    } else {\n        cpu_fprintf(f, \"Max guest delay     NA\\n\");\n        cpu_fprintf(f, \"Max guest advance   NA\\n\");\n    }\n}\n"
        },
        {
          "name": "cputlb.c",
          "type": "blob",
          "size": 34.3818359375,
          "content": "/*\n *  Common CPU TLB handling\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"cpu.h\"\n#include \"exec/exec-all.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n#include \"exec/cpu_ldst.h\"\n#include \"exec/cputlb.h\"\n#include \"exec/memory-internal.h\"\n#include \"exec/ram_addr.h\"\n#include \"tcg/tcg.h\"\n#include \"qemu/error-report.h\"\n#include \"exec/log.h\"\n#include \"exec/helper-proto.h\"\n#include \"qemu/atomic.h\"\n\n#include \"panda/rr/rr_log_all.h\"\n#include \"panda/rr/rr_log.h\"\n#include \"panda/callbacks/cb-support.h\"\n\n// less frustrating than importing common.h\nextern target_ulong panda_current_pc(CPUState *cpu);\n\n/* DEBUG defines, enable DEBUG_TLB_LOG to log to the CPU_LOG_MMU target */\n/* #define DEBUG_TLB */\n/* #define DEBUG_TLB_LOG */\n\n#ifdef DEBUG_TLB\n# define DEBUG_TLB_GATE 1\n# ifdef DEBUG_TLB_LOG\n#  define DEBUG_TLB_LOG_GATE 1\n# else\n#  define DEBUG_TLB_LOG_GATE 0\n# endif\n#else\n# define DEBUG_TLB_GATE 0\n# define DEBUG_TLB_LOG_GATE 0\n#endif\n\n#define tlb_debug(fmt, ...) do { \\\n    if (DEBUG_TLB_LOG_GATE) { \\\n        qemu_log_mask(CPU_LOG_MMU, \"%s: \" fmt, __func__, \\\n                      ## __VA_ARGS__); \\\n    } else if (DEBUG_TLB_GATE) { \\\n        fprintf(stderr, \"%s: \" fmt, __func__, ## __VA_ARGS__); \\\n    } \\\n} while (0)\n\n#define assert_cpu_is_self(this_cpu) do {                         \\\n        if (DEBUG_TLB_GATE) {                                     \\\n            g_assert(!cpu->created || qemu_cpu_is_self(cpu));     \\\n        }                                                         \\\n    } while (0)\n\n/* run_on_cpu_data.target_ptr should always be big enough for a\n * target_ulong even on 32 bit builds */\nQEMU_BUILD_BUG_ON(sizeof(target_ulong) > sizeof(run_on_cpu_data));\n\n/* We currently can't handle more than 16 bits in the MMUIDX bitmask.\n */\nQEMU_BUILD_BUG_ON(NB_MMU_MODES > 16);\n#define ALL_MMUIDX_BITS ((1 << NB_MMU_MODES) - 1)\n\n/* flush_all_helper: run fn across all cpus\n *\n * If the wait flag is set then the src cpu's helper will be queued as\n * \"safe\" work and the loop exited creating a synchronisation point\n * where all queued work will be finished before execution starts\n * again.\n */\nstatic void flush_all_helper(CPUState *src, run_on_cpu_func fn,\n                             run_on_cpu_data d)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu != src) {\n            async_run_on_cpu(cpu, fn, d);\n        }\n    }\n}\n\n/* statistics */\nint tlb_flush_count;\n\n/* This is OK because CPU architectures generally permit an\n * implementation to drop entries from the TLB at any time, so\n * flushing more entries than required is only an efficiency issue,\n * not a correctness issue.\n */\nstatic void tlb_flush_nocheck(CPUState *cpu)\n{\n    CPUArchState *env = cpu->env_ptr;\n\n    /* The QOM tests will trigger tlb_flushes without setting up TCG\n     * so we bug out here in that case.\n     */\n    if (!tcg_enabled()) {\n        return;\n    }\n\n    assert_cpu_is_self(cpu);\n    tlb_debug(\"(count: %d)\\n\", tlb_flush_count++);\n\n    tb_lock();\n\n    memset(env->tlb_table, -1, sizeof(env->tlb_table));\n    memset(env->tlb_v_table, -1, sizeof(env->tlb_v_table));\n    memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));\n\n    env->vtlb_index = 0;\n    env->tlb_flush_addr = -1;\n    env->tlb_flush_mask = 0;\n\n    tb_unlock();\n\n    atomic_mb_set(&cpu->pending_tlb_flush, 0);\n}\n\nstatic void tlb_flush_global_async_work(CPUState *cpu, run_on_cpu_data data)\n{\n    tlb_flush_nocheck(cpu);\n}\n\nvoid tlb_flush(CPUState *cpu)\n{\n    if (cpu->created && !qemu_cpu_is_self(cpu)) {\n        if (atomic_mb_read(&cpu->pending_tlb_flush) != ALL_MMUIDX_BITS) {\n            atomic_mb_set(&cpu->pending_tlb_flush, ALL_MMUIDX_BITS);\n            async_run_on_cpu(cpu, tlb_flush_global_async_work,\n                             RUN_ON_CPU_NULL);\n        }\n    } else {\n        tlb_flush_nocheck(cpu);\n    }\n}\n\nvoid tlb_flush_all_cpus(CPUState *src_cpu)\n{\n    const run_on_cpu_func fn = tlb_flush_global_async_work;\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_NULL);\n    fn(src_cpu, RUN_ON_CPU_NULL);\n}\n\nvoid tlb_flush_all_cpus_synced(CPUState *src_cpu)\n{\n    const run_on_cpu_func fn = tlb_flush_global_async_work;\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_NULL);\n    async_safe_run_on_cpu(src_cpu, fn, RUN_ON_CPU_NULL);\n}\n\nstatic void tlb_flush_by_mmuidx_async_work(CPUState *cpu, run_on_cpu_data data)\n{\n    CPUArchState *env = cpu->env_ptr;\n    unsigned long mmu_idx_bitmask = data.host_int;\n    int mmu_idx;\n\n    assert_cpu_is_self(cpu);\n\n    tb_lock();\n\n    tlb_debug(\"start: mmu_idx:0x%04lx\\n\", mmu_idx_bitmask);\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        if (test_bit(mmu_idx, &mmu_idx_bitmask)) {\n            tlb_debug(\"%d\\n\", mmu_idx);\n\n            memset(env->tlb_table[mmu_idx], -1, sizeof(env->tlb_table[0]));\n            memset(env->tlb_v_table[mmu_idx], -1, sizeof(env->tlb_v_table[0]));\n        }\n    }\n\n    memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));\n\n    tlb_debug(\"done\\n\");\n\n    tb_unlock();\n}\n\nvoid tlb_flush_by_mmuidx(CPUState *cpu, uint16_t idxmap)\n{\n    tlb_debug(\"mmu_idx: 0x%\" PRIx16 \"\\n\", idxmap);\n\n    if (!qemu_cpu_is_self(cpu)) {\n        uint16_t pending_flushes = idxmap;\n        pending_flushes &= ~atomic_mb_read(&cpu->pending_tlb_flush);\n\n        if (pending_flushes) {\n            tlb_debug(\"reduced mmu_idx: 0x%\" PRIx16 \"\\n\", pending_flushes);\n\n            atomic_or(&cpu->pending_tlb_flush, pending_flushes);\n            async_run_on_cpu(cpu, tlb_flush_by_mmuidx_async_work,\n                             RUN_ON_CPU_HOST_INT(pending_flushes));\n        }\n    } else {\n        tlb_flush_by_mmuidx_async_work(cpu,\n                                       RUN_ON_CPU_HOST_INT(idxmap));\n    }\n}\n\nvoid tlb_flush_by_mmuidx_all_cpus(CPUState *src_cpu, uint16_t idxmap)\n{\n    const run_on_cpu_func fn = tlb_flush_by_mmuidx_async_work;\n\n    tlb_debug(\"mmu_idx: 0x%\"PRIx16\"\\n\", idxmap);\n\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_HOST_INT(idxmap));\n    fn(src_cpu, RUN_ON_CPU_HOST_INT(idxmap));\n}\n\nvoid tlb_flush_by_mmuidx_all_cpus_synced(CPUState *src_cpu,\n                                                       uint16_t idxmap)\n{\n    const run_on_cpu_func fn = tlb_flush_by_mmuidx_async_work;\n\n    tlb_debug(\"mmu_idx: 0x%\"PRIx16\"\\n\", idxmap);\n\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_HOST_INT(idxmap));\n    async_safe_run_on_cpu(src_cpu, fn, RUN_ON_CPU_HOST_INT(idxmap));\n}\n\n\n\nstatic inline void tlb_flush_entry(CPUTLBEntry *tlb_entry, target_ulong addr)\n{\n    if (addr == (tlb_entry->addr_read &\n                 (TARGET_PAGE_MASK | TLB_INVALID_MASK)) ||\n        addr == (tlb_entry->addr_write &\n                 (TARGET_PAGE_MASK | TLB_INVALID_MASK)) ||\n        addr == (tlb_entry->addr_code &\n                 (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        memset(tlb_entry, -1, sizeof(*tlb_entry));\n    }\n}\n\nstatic void tlb_flush_page_async_work(CPUState *cpu, run_on_cpu_data data)\n{\n    CPUArchState *env = cpu->env_ptr;\n    target_ulong addr = (target_ulong) data.target_ptr;\n    int i;\n    int mmu_idx;\n\n    assert_cpu_is_self(cpu);\n\n    tlb_debug(\"page :\" TARGET_FMT_lx \"\\n\", addr);\n\n    /* Check if we need to flush due to large pages.  */\n    if ((addr & env->tlb_flush_mask) == env->tlb_flush_addr) {\n        tlb_debug(\"forcing full flush (\"\n                  TARGET_FMT_lx \"/\" TARGET_FMT_lx \")\\n\",\n                  env->tlb_flush_addr, env->tlb_flush_mask);\n\n        tlb_flush(cpu);\n        return;\n    }\n\n    addr &= TARGET_PAGE_MASK;\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        tlb_flush_entry(&env->tlb_table[mmu_idx][i], addr);\n    }\n\n    /* check whether there are entries that need to be flushed in the vtlb */\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        int k;\n        for (k = 0; k < CPU_VTLB_SIZE; k++) {\n            tlb_flush_entry(&env->tlb_v_table[mmu_idx][k], addr);\n        }\n    }\n\n    tb_flush_jmp_cache(cpu, addr);\n}\n\nvoid tlb_flush_page(CPUState *cpu, target_ulong addr)\n{\n    tlb_debug(\"page :\" TARGET_FMT_lx \"\\n\", addr);\n\n    if (!qemu_cpu_is_self(cpu)) {\n        async_run_on_cpu(cpu, tlb_flush_page_async_work,\n                         RUN_ON_CPU_TARGET_PTR(addr));\n    } else {\n        tlb_flush_page_async_work(cpu, RUN_ON_CPU_TARGET_PTR(addr));\n    }\n}\n\n/* As we are going to hijack the bottom bits of the page address for a\n * mmuidx bit mask we need to fail to build if we can't do that\n */\nQEMU_BUILD_BUG_ON(NB_MMU_MODES > TARGET_PAGE_BITS_MIN);\n\nstatic void tlb_flush_page_by_mmuidx_async_work(CPUState *cpu,\n                                                run_on_cpu_data data)\n{\n    CPUArchState *env = cpu->env_ptr;\n    target_ulong addr_and_mmuidx = (target_ulong) data.target_ptr;\n    target_ulong addr = addr_and_mmuidx & TARGET_PAGE_MASK;\n    unsigned long mmu_idx_bitmap = addr_and_mmuidx & ALL_MMUIDX_BITS;\n    int page = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    int mmu_idx;\n    int i;\n\n    assert_cpu_is_self(cpu);\n\n    tlb_debug(\"page:%d addr:\"TARGET_FMT_lx\" mmu_idx:0x%lx\\n\",\n              page, addr, mmu_idx_bitmap);\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        if (test_bit(mmu_idx, &mmu_idx_bitmap)) {\n            tlb_flush_entry(&env->tlb_table[mmu_idx][page], addr);\n\n            /* check whether there are vltb entries that need to be flushed */\n            for (i = 0; i < CPU_VTLB_SIZE; i++) {\n                tlb_flush_entry(&env->tlb_v_table[mmu_idx][i], addr);\n            }\n        }\n    }\n\n    tb_flush_jmp_cache(cpu, addr);\n}\n\nstatic void tlb_check_page_and_flush_by_mmuidx_async_work(CPUState *cpu,\n                                                          run_on_cpu_data data)\n{\n    CPUArchState *env = cpu->env_ptr;\n    target_ulong addr_and_mmuidx = (target_ulong) data.target_ptr;\n    target_ulong addr = addr_and_mmuidx & TARGET_PAGE_MASK;\n    unsigned long mmu_idx_bitmap = addr_and_mmuidx & ALL_MMUIDX_BITS;\n\n    tlb_debug(\"addr:\"TARGET_FMT_lx\" mmu_idx: %04lx\\n\", addr, mmu_idx_bitmap);\n\n    /* Check if we need to flush due to large pages.  */\n    if ((addr & env->tlb_flush_mask) == env->tlb_flush_addr) {\n        tlb_debug(\"forced full flush (\"\n                  TARGET_FMT_lx \"/\" TARGET_FMT_lx \")\\n\",\n                  env->tlb_flush_addr, env->tlb_flush_mask);\n\n        tlb_flush_by_mmuidx_async_work(cpu,\n                                       RUN_ON_CPU_HOST_INT(mmu_idx_bitmap));\n    } else {\n        tlb_flush_page_by_mmuidx_async_work(cpu, data);\n    }\n}\n\nvoid tlb_flush_page_by_mmuidx(CPUState *cpu, target_ulong addr, uint16_t idxmap)\n{\n    target_ulong addr_and_mmu_idx;\n\n    tlb_debug(\"addr: \"TARGET_FMT_lx\" mmu_idx:%\" PRIx16 \"\\n\", addr, idxmap);\n\n    /* This should already be page aligned */\n    addr_and_mmu_idx = addr & TARGET_PAGE_MASK;\n    addr_and_mmu_idx |= idxmap;\n\n    if (!qemu_cpu_is_self(cpu)) {\n        async_run_on_cpu(cpu, tlb_check_page_and_flush_by_mmuidx_async_work,\n                         RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n    } else {\n        tlb_check_page_and_flush_by_mmuidx_async_work(\n            cpu, RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n    }\n}\n\nvoid tlb_flush_page_by_mmuidx_all_cpus(CPUState *src_cpu, target_ulong addr,\n                                       uint16_t idxmap)\n{\n    const run_on_cpu_func fn = tlb_check_page_and_flush_by_mmuidx_async_work;\n    target_ulong addr_and_mmu_idx;\n\n    tlb_debug(\"addr: \"TARGET_FMT_lx\" mmu_idx:%\"PRIx16\"\\n\", addr, idxmap);\n\n    /* This should already be page aligned */\n    addr_and_mmu_idx = addr & TARGET_PAGE_MASK;\n    addr_and_mmu_idx |= idxmap;\n\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n    fn(src_cpu, RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n}\n\nvoid tlb_flush_page_by_mmuidx_all_cpus_synced(CPUState *src_cpu,\n                                                            target_ulong addr,\n                                                            uint16_t idxmap)\n{\n    const run_on_cpu_func fn = tlb_check_page_and_flush_by_mmuidx_async_work;\n    target_ulong addr_and_mmu_idx;\n\n    tlb_debug(\"addr: \"TARGET_FMT_lx\" mmu_idx:%\"PRIx16\"\\n\", addr, idxmap);\n\n    /* This should already be page aligned */\n    addr_and_mmu_idx = addr & TARGET_PAGE_MASK;\n    addr_and_mmu_idx |= idxmap;\n\n    flush_all_helper(src_cpu, fn, RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n    async_safe_run_on_cpu(src_cpu, fn, RUN_ON_CPU_TARGET_PTR(addr_and_mmu_idx));\n}\n\nvoid tlb_flush_page_all_cpus(CPUState *src, target_ulong addr)\n{\n    const run_on_cpu_func fn = tlb_flush_page_async_work;\n\n    flush_all_helper(src, fn, RUN_ON_CPU_TARGET_PTR(addr));\n    fn(src, RUN_ON_CPU_TARGET_PTR(addr));\n}\n\nvoid tlb_flush_page_all_cpus_synced(CPUState *src,\n                                                  target_ulong addr)\n{\n    const run_on_cpu_func fn = tlb_flush_page_async_work;\n\n    flush_all_helper(src, fn, RUN_ON_CPU_TARGET_PTR(addr));\n    async_safe_run_on_cpu(src, fn, RUN_ON_CPU_TARGET_PTR(addr));\n}\n\n/* update the TLBs so that writes to code in the virtual page 'addr'\n   can be detected */\nvoid tlb_protect_code(ram_addr_t ram_addr)\n{\n    cpu_physical_memory_test_and_clear_dirty(ram_addr, TARGET_PAGE_SIZE,\n                                             DIRTY_MEMORY_CODE);\n}\n\n/* update the TLB so that writes in physical page 'phys_addr' are no longer\n   tested for self modifying code */\nvoid tlb_unprotect_code(ram_addr_t ram_addr)\n{\n    cpu_physical_memory_set_dirty_flag(ram_addr, DIRTY_MEMORY_CODE);\n}\n\n\n/*\n * Dirty write flag handling\n *\n * When the TCG code writes to a location it looks up the address in\n * the TLB and uses that data to compute the final address. If any of\n * the lower bits of the address are set then the slow path is forced.\n * There are a number of reasons to do this but for normal RAM the\n * most usual is detecting writes to code regions which may invalidate\n * generated code.\n *\n * Because we want other vCPUs to respond to changes straight away we\n * update the te->addr_write field atomically. If the TLB entry has\n * been changed by the vCPU in the mean time we skip the update.\n *\n * As this function uses atomic accesses we also need to ensure\n * updates to tlb_entries follow the same access rules. We don't need\n * to worry about this for oversized guests as MTTCG is disabled for\n * them.\n */\n\nstatic void tlb_reset_dirty_range(CPUTLBEntry *tlb_entry, uintptr_t start,\n                           uintptr_t length)\n{\n#if TCG_OVERSIZED_GUEST\n    uintptr_t addr = tlb_entry->addr_write;\n\n    if ((addr & (TLB_INVALID_MASK | TLB_MMIO | TLB_NOTDIRTY)) == 0) {\n        addr &= TARGET_PAGE_MASK;\n        addr += tlb_entry->addend;\n        if ((addr - start) < length) {\n            tlb_entry->addr_write |= TLB_NOTDIRTY;\n        }\n    }\n#else\n    /* paired with atomic_mb_set in tlb_set_page_with_attrs */\n    uintptr_t orig_addr = atomic_mb_read(&tlb_entry->addr_write);\n    uintptr_t addr = orig_addr;\n\n    if ((addr & (TLB_INVALID_MASK | TLB_MMIO | TLB_NOTDIRTY)) == 0) {\n        addr &= TARGET_PAGE_MASK;\n        addr += atomic_read(&tlb_entry->addend);\n        if ((addr - start) < length) {\n            uintptr_t notdirty_addr = orig_addr | TLB_NOTDIRTY;\n            atomic_cmpxchg(&tlb_entry->addr_write, orig_addr, notdirty_addr);\n        }\n    }\n#endif\n}\n\n/* For atomic correctness when running MTTCG we need to use the right\n * primitives when copying entries */\nstatic inline void copy_tlb_helper(CPUTLBEntry *d, CPUTLBEntry *s,\n                                   bool atomic_set)\n{\n#if TCG_OVERSIZED_GUEST\n    *d = *s;\n#else\n    if (atomic_set) {\n        d->addr_read = s->addr_read;\n        d->addr_code = s->addr_code;\n        atomic_set(&d->addend, atomic_read(&s->addend));\n        /* Pairs with flag setting in tlb_reset_dirty_range */\n        atomic_mb_set(&d->addr_write, atomic_read(&s->addr_write));\n    } else {\n        d->addr_read = s->addr_read;\n        d->addr_write = atomic_read(&s->addr_write);\n        d->addr_code = s->addr_code;\n        d->addend = atomic_read(&s->addend);\n    }\n#endif\n}\n\n/* This is a cross vCPU call (i.e. another vCPU resetting the flags of\n * the target vCPU). As such care needs to be taken that we don't\n * dangerously race with another vCPU update. The only thing actually\n * updated is the target TLB entry ->addr_write flags.\n */\nvoid tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n{\n    CPUArchState *env;\n\n    int mmu_idx;\n\n    env = cpu->env_ptr;\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        unsigned int i;\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n                                  start1, length);\n        }\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n                                  start1, length);\n        }\n    }\n}\n\nstatic inline void tlb_set_dirty1(CPUTLBEntry *tlb_entry, target_ulong vaddr)\n{\n    if (tlb_entry->addr_write == (vaddr | TLB_NOTDIRTY)) {\n        tlb_entry->addr_write = vaddr;\n    }\n}\n\n/* update the TLB corresponding to virtual page vaddr\n   so that it is no longer dirty */\nvoid tlb_set_dirty(CPUState *cpu, target_ulong vaddr)\n{\n    CPUArchState *env = cpu->env_ptr;\n    int i;\n    int mmu_idx;\n\n    assert_cpu_is_self(cpu);\n\n    vaddr &= TARGET_PAGE_MASK;\n    i = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        tlb_set_dirty1(&env->tlb_table[mmu_idx][i], vaddr);\n    }\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        int k;\n        for (k = 0; k < CPU_VTLB_SIZE; k++) {\n            tlb_set_dirty1(&env->tlb_v_table[mmu_idx][k], vaddr);\n        }\n    }\n}\n\n/* Our TLB does not support large pages, so remember the area covered by\n   large pages and trigger a full TLB flush if these are invalidated.  */\nstatic void tlb_add_large_page(CPUArchState *env, target_ulong vaddr,\n                               target_ulong size)\n{\n    target_ulong mask = ~(size - 1);\n\n    if (env->tlb_flush_addr == (target_ulong)-1) {\n        env->tlb_flush_addr = vaddr & mask;\n        env->tlb_flush_mask = mask;\n        return;\n    }\n    /* Extend the existing region to include the new page.\n       This is a compromise between unnecessary flushes and the cost\n       of maintaining a full variable size TLB.  */\n    mask &= env->tlb_flush_mask;\n    while (((env->tlb_flush_addr ^ vaddr) & mask) != 0) {\n        mask <<= 1;\n    }\n    env->tlb_flush_addr &= mask;\n    env->tlb_flush_mask = mask;\n}\n\n/* Add a new TLB entry. At most one entry for a given virtual address\n * is permitted. Only a single TARGET_PAGE_SIZE region is mapped, the\n * supplied size is only used by tlb_flush_page.\n *\n * Called from TCG-generated code, which is under an RCU read-side\n * critical section.\n */\nvoid tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n                             int mmu_idx, target_ulong size)\n{\n    CPUArchState *env = cpu->env_ptr;\n    MemoryRegionSection *section;\n    unsigned int index;\n    target_ulong address;\n    target_ulong code_address;\n    uintptr_t addend;\n    CPUTLBEntry *te, *tv, tn;\n    hwaddr iotlb, xlat, sz;\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n    assert_cpu_is_self(cpu);\n    assert(size >= TARGET_PAGE_SIZE);\n    if (size != TARGET_PAGE_SIZE) {\n        tlb_add_large_page(env, vaddr, size);\n    }\n\n    sz = size;\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n    assert(sz >= TARGET_PAGE_SIZE);\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n              \" prot=%x idx=%d\\n\",\n              vaddr, paddr, prot, mmu_idx);\n\n    address = vaddr;\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n        /* IO memory case */\n        address |= TLB_MMIO;\n        addend = 0;\n    } else {\n        /* TLB_MMIO for rom/romd handled below */\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n    }\n\n    code_address = address;\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n                                            prot, &address);\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    te = &env->tlb_table[mmu_idx][index];\n    /* do not discard the translation in te, evict it into a victim tlb */\n    tv = &env->tlb_v_table[mmu_idx][vidx];\n\n    /* addr_write can race with tlb_reset_dirty_range */\n    copy_tlb_helper(tv, te, true);\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n    /* refill the tlb */\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    /* Now calculate the new entry */\n    tn.addend = addend - vaddr;\n    if (prot & PAGE_READ) {\n        tn.addr_read = address;\n    } else {\n        tn.addr_read = -1;\n    }\n\n    if (prot & PAGE_EXEC) {\n        tn.addr_code = code_address;\n    } else {\n        tn.addr_code = -1;\n    }\n\n    tn.addr_write = -1;\n    if (prot & PAGE_WRITE) {\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n            || memory_region_is_romd(section->mr)) {\n            /* Write access calls the I/O callback.  */\n            tn.addr_write = address | TLB_MMIO;\n        } else if (memory_region_is_ram(section->mr)\n                   && cpu_physical_memory_is_clean(\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n            tn.addr_write = address | TLB_NOTDIRTY;\n        } else {\n            tn.addr_write = address;\n        }\n    }\n\n    /* Pairs with flag setting in tlb_reset_dirty_range */\n    copy_tlb_helper(te, &tn, true);\n    /* atomic_mb_set(&te->addr_write, write_address); */\n}\n\n/* Add a new TLB entry, but without specifying the memory\n * transaction attributes to be used.\n */\nvoid tlb_set_page(CPUState *cpu, target_ulong vaddr,\n                  hwaddr paddr, int prot,\n                  int mmu_idx, target_ulong size)\n{\n    tlb_set_page_with_attrs(cpu, vaddr, paddr, MEMTXATTRS_UNSPECIFIED,\n                            prot, mmu_idx, size);\n}\n\nstatic void report_bad_exec(CPUState *cpu, target_ulong addr)\n{\n    /* Accidentally executing outside RAM or ROM is quite common for\n     * several user-error situations, so report it in a way that\n     * makes it clear that this isn't a QEMU bug and provide suggestions\n     * about what a user could do to fix things.\n     */\n    error_report(\"Trying to execute code outside RAM or ROM at 0x\"\n                 TARGET_FMT_lx, addr);\n    error_printf(\"This usually means one of the following happened:\\n\\n\"\n                 \"(1) You told QEMU to execute a kernel for the wrong machine \"\n                 \"type, and it crashed on startup (eg trying to run a \"\n                 \"raspberry pi kernel on a versatilepb QEMU machine)\\n\"\n                 \"(2) You didn't give QEMU a kernel or BIOS filename at all, \"\n                 \"and QEMU executed a ROM full of no-op instructions until \"\n                 \"it fell off the end\\n\"\n                 \"(3) Your guest kernel has a bug and crashed by jumping \"\n                 \"off into nowhere\\n\\n\"\n                 \"This is almost always one of the first two, so check your \"\n                 \"command line and that you are using the right type of kernel \"\n                 \"for this machine.\\n\"\n                 \"If you think option (3) is likely then you can try debugging \"\n                 \"your guest with the -d debug options; in particular \"\n                 \"-d guest_errors will cause the log to include a dump of the \"\n                 \"guest register state at this point.\\n\\n\"\n                 \"Execution cannot continue; stopping here.\\n\\n\");\n\n    /* Report also to the logs, with more detail including register dump */\n    qemu_log_mask(LOG_GUEST_ERROR, \"qemu: fatal: Trying to execute code \"\n                  \"outside RAM or ROM at 0x\" TARGET_FMT_lx \"\\n\", addr);\n    log_cpu_state_mask(LOG_GUEST_ERROR, cpu, CPU_DUMP_FPU | CPU_DUMP_CCOP);\n}\n\nstatic inline ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n{\n    ram_addr_t ram_addr;\n\n    ram_addr = qemu_ram_addr_from_host(ptr);\n    if (ram_addr == RAM_ADDR_INVALID) {\n        error_report(\"Bad ram pointer %p\", ptr);\n        abort();\n    }\n    return ram_addr;\n}\n\n/* NOTE: this function can trigger an exception */\n/* NOTE2: the returned address is not exactly the physical address: it\n * is actually a ram_addr_t (in system mode; the user mode emulation\n * version of this function returns a guest virtual address).\n */\ntb_page_addr_t get_page_addr_code(CPUArchState *env1, target_ulong addr)\n{\n    int mmu_idx, page_index, pd;\n    void *p;\n    MemoryRegion *mr;\n    CPUState *cpu = ENV_GET_CPU(env1);\n    CPUIOTLBEntry *iotlbentry;\n\n    page_index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    mmu_idx = cpu_mmu_index(env1, true);\n    if (unlikely(env1->tlb_table[mmu_idx][page_index].addr_code !=\n                 (addr & TARGET_PAGE_MASK))) {\n        cpu_ldub_code(env1, addr);\n    }\n    iotlbentry = &env1->iotlb[mmu_idx][page_index];\n    pd = iotlbentry->addr & ~TARGET_PAGE_MASK;\n    mr = iotlb_to_region(cpu, pd, iotlbentry->attrs);\n    if (memory_region_is_unassigned(mr)) {\n        cpu_unassigned_access(cpu, addr, false, true, 0, 4);\n        /* The CPU's unassigned access hook might have longjumped out\n         * with an exception. If it didn't (or there was no hook) then\n         * we can't proceed further.\n         */\n        report_bad_exec(cpu, addr);\n        exit(1);\n    }\n    p = (void *)((uintptr_t)addr + env1->tlb_table[mmu_idx][page_index].addend);\n    return qemu_ram_addr_from_host_nofail(p);\n}\n\nstatic uint64_t io_readx(CPUArchState *env, CPUIOTLBEntry *iotlbentry,\n                         target_ulong addr, uintptr_t retaddr, int size)\n{\n    CPUState *cpu = ENV_GET_CPU(env);\n    hwaddr physaddr = iotlbentry->addr;\n    MemoryRegion *mr = iotlb_to_region(cpu, physaddr, iotlbentry->attrs);\n    uint64_t val;\n\n    physaddr = (physaddr & TARGET_PAGE_MASK) + addr;\n    cpu->mem_io_pc = retaddr;\n    if (mr != &io_mem_rom && mr != &io_mem_notdirty && !cpu->can_do_io) {\n        cpu_io_recompile(cpu, retaddr);\n    }\n\n    cpu->mem_io_vaddr = addr;\n    if (mr->name && !strcmp(mr->name, \"watch\")){\n        memory_region_dispatch_read(mr, physaddr, &val, size, iotlbentry->attrs);\n        return val;\n    }\n\n    RR_DO_RECORD_OR_REPLAY(\n        /* action= */\n        memory_region_dispatch_read(mr, physaddr, &val, size, iotlbentry->attrs),\n        /* record= */ rr_input_8(&val),\n        /* replay= */ rr_input_8(&val),\n        /* location= */ RR_CALLSITE_IO_READ_ALL);\n\n    panda_callbacks_mmio_after_read(cpu, physaddr, addr, size, &val);\n\n    return val;\n}\n\nstatic void io_writex(CPUArchState *env, CPUIOTLBEntry *iotlbentry,\n                      uint64_t val, target_ulong addr,\n                      uintptr_t retaddr, int size)\n{\n    CPUState *cpu = ENV_GET_CPU(env);\n    hwaddr physaddr = iotlbentry->addr;\n    MemoryRegion *mr = iotlb_to_region(cpu, physaddr, iotlbentry->attrs);\n\n    physaddr = (physaddr & TARGET_PAGE_MASK) + addr;\n    if (mr != &io_mem_rom && mr != &io_mem_notdirty && !cpu->can_do_io) {\n        cpu_io_recompile(cpu, retaddr);\n    }\n\n    cpu->mem_io_vaddr = addr;\n    cpu->mem_io_pc = retaddr;\n\n    panda_callbacks_mmio_before_write(cpu, physaddr, addr, size, &val);\n\n    if (mr->name && !strcmp(mr->name, \"watch\")){\n        memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs);\n        return;\n    }\n\n    if (mr != &io_mem_rom && mr != &io_mem_notdirty) {\n        RR_DO_RECORD_OR_REPLAY(\n            /* action= */\n            memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs),\n            /* record= */ RR_NO_ACTION,\n            /* replay= */ RR_NO_ACTION,\n            /* location= */ RR_CALLSITE_IO_WRITE_ALL);\n    } else {\n        memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs);\n    }\n}\n\n/* Return true if ADDR is present in the victim tlb, and has been copied\n   back to the main tlb.  */\nstatic bool victim_tlb_hit(CPUArchState *env, size_t mmu_idx, size_t index,\n                           size_t elt_ofs, target_ulong page)\n{\n    size_t vidx;\n    for (vidx = 0; vidx < CPU_VTLB_SIZE; ++vidx) {\n        CPUTLBEntry *vtlb = &env->tlb_v_table[mmu_idx][vidx];\n        target_ulong cmp = *(target_ulong *)((uintptr_t)vtlb + elt_ofs);\n\n        if (cmp == page) {\n            /* Found entry in victim tlb, swap tlb and iotlb.  */\n            CPUTLBEntry tmptlb, *tlb = &env->tlb_table[mmu_idx][index];\n\n            copy_tlb_helper(&tmptlb, tlb, false);\n            copy_tlb_helper(tlb, vtlb, true);\n            copy_tlb_helper(vtlb, &tmptlb, true);\n\n            CPUIOTLBEntry tmpio, *io = &env->iotlb[mmu_idx][index];\n            CPUIOTLBEntry *vio = &env->iotlb_v[mmu_idx][vidx];\n            tmpio = *io; *io = *vio; *vio = tmpio;\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Macro to call the above, with local variables from the use context.  */\n#define VICTIM_TLB_HIT(TY, ADDR) \\\n  victim_tlb_hit(env, mmu_idx, index, offsetof(CPUTLBEntry, TY), \\\n                 (ADDR) & TARGET_PAGE_MASK)\n\n/* Probe for whether the specified guest write access is permitted.\n * If it is not permitted then an exception will be taken in the same\n * way as if this were a real write access (and we will not return).\n * Otherwise the function will return, and there will be a valid\n * entry in the TLB for this access.\n */\nvoid probe_write(CPUArchState *env, target_ulong addr, int mmu_idx,\n                 uintptr_t retaddr)\n{\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n\n    if ((addr & TARGET_PAGE_MASK)\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        /* TLB entry is for a different page */\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n        }\n    }\n}\n\n/* Probe for a read-modify-write atomic operation.  Do not allow unaligned\n * operations, or io operations to proceed.  Return the host address.  */\nstatic void *atomic_mmu_lookup(CPUArchState *env, target_ulong addr,\n                               TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    size_t mmu_idx = get_mmuidx(oi);\n    size_t index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    CPUTLBEntry *tlbe = &env->tlb_table[mmu_idx][index];\n    target_ulong tlb_addr = tlbe->addr_write;\n    TCGMemOp mop = get_memop(oi);\n    int a_bits = get_alignment_bits(mop);\n    int s_bits = mop & MO_SIZE;\n\n    /* Adjust the given return address.  */\n    retaddr -= GETPC_ADJ;\n\n    /* Enforce guest required alignment.  */\n    if (unlikely(a_bits > 0 && (addr & ((1 << a_bits) - 1)))) {\n        /* ??? Maybe indicate atomic op to cpu_unaligned_access */\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, MMU_DATA_STORE,\n                             mmu_idx, retaddr);\n    }\n\n    /* Enforce qemu required alignment.  */\n    if (unlikely(addr & ((1 << s_bits) - 1))) {\n        /* We get here if guest alignment was not requested,\n           or was not enforced by cpu_unaligned_access above.\n           We might widen the access and emulate, but for now\n           mark an exception and exit the cpu loop.  */\n        goto stop_the_world;\n    }\n\n    /* Check TLB entry and enforce page permissions.  */\n    if ((addr & TARGET_PAGE_MASK)\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n        }\n        tlb_addr = tlbe->addr_write;\n    }\n\n    /* Notice an IO access, or a notdirty page.  */\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n        /* There's really nothing that can be done to\n           support this apart from stop-the-world.  */\n        goto stop_the_world;\n    }\n\n    /* Let the guest notice RMW on a write-only page.  */\n    if (unlikely(tlbe->addr_read != tlb_addr)) {\n        tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_LOAD, mmu_idx, retaddr);\n        /* Since we don't support reads and writes to different addresses,\n           and we do have the proper page loaded for write, this shouldn't\n           ever return.  But just in case, handle via stop-the-world.  */\n        goto stop_the_world;\n    }\n\n    return (void *)((uintptr_t)addr + tlbe->addend);\n\n stop_the_world:\n    cpu_loop_exit_atomic(ENV_GET_CPU(env), retaddr);\n}\n\n#ifdef TARGET_WORDS_BIGENDIAN\n# define TGT_BE(X)  (X)\n# define TGT_LE(X)  BSWAP(X)\n#else\n# define TGT_BE(X)  BSWAP(X)\n# define TGT_LE(X)  (X)\n#endif\n\n#define MMUSUFFIX _mmu\n\n#define DATA_SIZE 1\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 2\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 4\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 8\n#include \"softmmu_template.h\"\n\n/* First set of helpers allows passing in of OI and RETADDR.  This makes\n   them callable from other helpers.  */\n\n#define EXTRA_ARGS     , TCGMemOpIdx oi, uintptr_t retaddr\n#define ATOMIC_NAME(X) \\\n    HELPER(glue(glue(glue(atomic_ ## X, SUFFIX), END), _mmu))\n#define ATOMIC_MMU_LOOKUP  atomic_mmu_lookup(env, addr, oi, retaddr)\n\n#define DATA_SIZE 1\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 2\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 4\n#include \"atomic_template.h\"\n\n#ifdef CONFIG_ATOMIC64\n#define DATA_SIZE 8\n#include \"atomic_template.h\"\n#endif\n\n#ifdef CONFIG_ATOMIC128\n#define DATA_SIZE 16\n#include \"atomic_template.h\"\n#endif\n\n/* Second set of helpers are directly callable from TCG as helpers.  */\n\n#undef EXTRA_ARGS\n#undef ATOMIC_NAME\n#undef ATOMIC_MMU_LOOKUP\n#define EXTRA_ARGS         , TCGMemOpIdx oi\n#define ATOMIC_NAME(X)     HELPER(glue(glue(atomic_ ## X, SUFFIX), END))\n#define ATOMIC_MMU_LOOKUP  atomic_mmu_lookup(env, addr, oi, GETPC())\n\n#define DATA_SIZE 1\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 2\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 4\n#include \"atomic_template.h\"\n\n#ifdef CONFIG_ATOMIC64\n#define DATA_SIZE 8\n#include \"atomic_template.h\"\n#endif\n\n/* Code access functions.  */\n\n#undef MMUSUFFIX\n#define MMUSUFFIX _cmmu\n#undef GETPC\n#define GETPC() ((uintptr_t)0)\n#define SOFTMMU_CODE_ACCESS\n\n#define DATA_SIZE 1\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 2\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 4\n#include \"softmmu_template.h\"\n\n#define DATA_SIZE 8\n#include \"softmmu_template.h\"\n"
        },
        {
          "name": "crypto",
          "type": "tree",
          "content": null
        },
        {
          "name": "default-configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "device-hotplug.c",
          "type": "blob",
          "size": 2.5517578125,
          "content": "/*\n * QEMU device hotplug helpers\n *\n * Copyright (c) 2004 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"hw/hw.h\"\n#include \"hw/boards.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/blockdev.h\"\n#include \"qemu/config-file.h\"\n#include \"sysemu/sysemu.h\"\n#include \"monitor/monitor.h\"\n#include \"block/block_int.h\"\n\nstatic DriveInfo *add_init_drive(const char *optstr)\n{\n    DriveInfo *dinfo;\n    QemuOpts *opts;\n    MachineClass *mc;\n\n    opts = drive_def(optstr);\n    if (!opts)\n        return NULL;\n\n    mc = MACHINE_GET_CLASS(current_machine);\n    dinfo = drive_new(opts, mc->block_default_type);\n    if (!dinfo) {\n        qemu_opts_del(opts);\n        return NULL;\n    }\n\n    return dinfo;\n}\n\nvoid hmp_drive_add(Monitor *mon, const QDict *qdict)\n{\n    DriveInfo *dinfo = NULL;\n    const char *opts = qdict_get_str(qdict, \"opts\");\n    bool node = qdict_get_try_bool(qdict, \"node\", false);\n\n    if (node) {\n        hmp_drive_add_node(mon, opts);\n        return;\n    }\n\n    dinfo = add_init_drive(opts);\n    if (!dinfo) {\n        goto err;\n    }\n    if (dinfo->devaddr) {\n        monitor_printf(mon, \"Parameter addr not supported\\n\");\n        goto err;\n    }\n\n    switch (dinfo->type) {\n    case IF_NONE:\n        monitor_printf(mon, \"OK\\n\");\n        break;\n    default:\n        monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n        goto err;\n    }\n    return;\n\nerr:\n    if (dinfo) {\n        BlockBackend *blk = blk_by_legacy_dinfo(dinfo);\n        monitor_remove_blk(blk);\n        blk_unref(blk);\n    }\n}\n"
        },
        {
          "name": "device_tree.c",
          "type": "blob",
          "size": 12.8544921875,
          "content": "/*\n * Functions to help device tree manipulation using libfdt.\n * It also provides functions to read entries from device tree proc\n * interface.\n *\n * Copyright 2008 IBM Corporation.\n * Authors: Jerone Young <jyoung5@us.ibm.com>\n *          Hollis Blanchard <hollisb@us.ibm.com>\n *\n * This work is licensed under the GNU GPL license version 2 or later.\n *\n */\n\n#include \"qemu/osdep.h\"\n\n#ifdef CONFIG_LINUX\n#include <dirent.h>\n#endif\n\n#include \"qapi/error.h\"\n#include \"qemu-common.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/bswap.h\"\n#include \"sysemu/device_tree.h\"\n#include \"sysemu/sysemu.h\"\n#include \"hw/loader.h\"\n#include \"hw/boards.h\"\n#include \"qemu/config-file.h\"\n\n#include <libfdt.h>\n\n#define FDT_MAX_SIZE  0x10000\n\nvoid *create_device_tree(int *sizep)\n{\n    void *fdt;\n    int ret;\n\n    *sizep = FDT_MAX_SIZE;\n    fdt = g_malloc0(FDT_MAX_SIZE);\n    ret = fdt_create(fdt, FDT_MAX_SIZE);\n    if (ret < 0) {\n        goto fail;\n    }\n    ret = fdt_finish_reservemap(fdt);\n    if (ret < 0) {\n        goto fail;\n    }\n    ret = fdt_begin_node(fdt, \"\");\n    if (ret < 0) {\n        goto fail;\n    }\n    ret = fdt_end_node(fdt);\n    if (ret < 0) {\n        goto fail;\n    }\n    ret = fdt_finish(fdt);\n    if (ret < 0) {\n        goto fail;\n    }\n    ret = fdt_open_into(fdt, fdt, *sizep);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        exit(1);\n    }\n\n    return fdt;\nfail:\n    error_report(\"%s Couldn't create dt: %s\", __func__, fdt_strerror(ret));\n    exit(1);\n}\n\nvoid *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n    /* First allocate space in qemu for device tree */\n    fdt = g_malloc0(dt_size);\n\n    dt_file_load_size = load_image(filename_path, fdt);\n    if (dt_file_load_size < 0) {\n        error_report(\"Unable to open device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n\n#ifdef CONFIG_LINUX\n\n#define SYSFS_DT_BASEDIR \"/proc/device-tree\"\n\n/**\n * read_fstree: this function is inspired from dtc read_fstree\n * @fdt: preallocated fdt blob buffer, to be populated\n * @dirname: directory to scan under SYSFS_DT_BASEDIR\n * the search is recursive and the tree is searched down to the\n * leaves (property files).\n *\n * the function asserts in case of error\n */\nstatic void read_fstree(void *fdt, const char *dirname)\n{\n    DIR *d;\n    struct dirent *de;\n    struct stat st;\n    const char *root_dir = SYSFS_DT_BASEDIR;\n    const char *parent_node;\n\n    if (strstr(dirname, root_dir) != dirname) {\n        error_setg(&error_fatal, \"%s: %s must be searched within %s\",\n                   __func__, dirname, root_dir);\n    }\n    parent_node = &dirname[strlen(SYSFS_DT_BASEDIR)];\n\n    d = opendir(dirname);\n    if (!d) {\n        error_setg(&error_fatal, \"%s cannot open %s\", __func__, dirname);\n    }\n\n    while ((de = readdir(d)) != NULL) {\n        char *tmpnam;\n\n        if (!g_strcmp0(de->d_name, \".\")\n            || !g_strcmp0(de->d_name, \"..\")) {\n            continue;\n        }\n\n        tmpnam = g_strdup_printf(\"%s/%s\", dirname, de->d_name);\n\n        if (lstat(tmpnam, &st) < 0) {\n            error_setg(&error_fatal, \"%s cannot lstat %s\", __func__, tmpnam);\n        }\n\n        if (S_ISREG(st.st_mode)) {\n            gchar *val;\n            gsize len;\n\n            if (!g_file_get_contents(tmpnam, &val, &len, NULL)) {\n                error_setg(&error_fatal, \"%s not able to extract info from %s\",\n                           __func__, tmpnam);\n            }\n\n            if (strlen(parent_node) > 0) {\n                qemu_fdt_setprop(fdt, parent_node,\n                                 de->d_name, val, len);\n            } else {\n                qemu_fdt_setprop(fdt, \"/\", de->d_name, val, len);\n            }\n            g_free(val);\n        } else if (S_ISDIR(st.st_mode)) {\n            char *node_name;\n\n            node_name = g_strdup_printf(\"%s/%s\",\n                                        parent_node, de->d_name);\n            qemu_fdt_add_subnode(fdt, node_name);\n            g_free(node_name);\n            read_fstree(fdt, tmpnam);\n        }\n\n        g_free(tmpnam);\n    }\n\n    closedir(d);\n}\n\n/* load_device_tree_from_sysfs: extract the dt blob from host sysfs */\nvoid *load_device_tree_from_sysfs(void)\n{\n    void *host_fdt;\n    int host_fdt_size;\n\n    host_fdt = create_device_tree(&host_fdt_size);\n    read_fstree(host_fdt, SYSFS_DT_BASEDIR);\n    if (fdt_check_header(host_fdt)) {\n        error_setg(&error_fatal,\n                   \"%s host device tree extracted into memory is invalid\",\n                   __func__);\n    }\n    return host_fdt;\n}\n\n#endif /* CONFIG_LINUX */\n\nstatic int findnode_nofail(void *fdt, const char *node_path)\n{\n    int offset;\n\n    offset = fdt_path_offset(fdt, node_path);\n    if (offset < 0) {\n        error_report(\"%s Couldn't find node %s: %s\", __func__, node_path,\n                     fdt_strerror(offset));\n        exit(1);\n    }\n\n    return offset;\n}\n\nchar **qemu_fdt_node_path(void *fdt, const char *name, char *compat,\n                          Error **errp)\n{\n    int offset, len, ret;\n    const char *iter_name;\n    unsigned int path_len = 16, n = 0;\n    GSList *path_list = NULL, *iter;\n    char **path_array;\n\n    offset = fdt_node_offset_by_compatible(fdt, -1, compat);\n\n    while (offset >= 0) {\n        iter_name = fdt_get_name(fdt, offset, &len);\n        if (!iter_name) {\n            offset = len;\n            break;\n        }\n        if (!strcmp(iter_name, name)) {\n            char *path;\n\n            path = g_malloc(path_len);\n            while ((ret = fdt_get_path(fdt, offset, path, path_len))\n                  == -FDT_ERR_NOSPACE) {\n                path_len += 16;\n                path = g_realloc(path, path_len);\n            }\n            path_list = g_slist_prepend(path_list, path);\n            n++;\n        }\n        offset = fdt_node_offset_by_compatible(fdt, offset, compat);\n    }\n\n    if (offset < 0 && offset != -FDT_ERR_NOTFOUND) {\n        error_setg(errp, \"%s: abort parsing dt for %s/%s: %s\",\n                   __func__, name, compat, fdt_strerror(offset));\n        for (iter = path_list; iter; iter = iter->next) {\n            g_free(iter->data);\n        }\n        g_slist_free(path_list);\n        return NULL;\n    }\n\n    path_array = g_new(char *, n + 1);\n    path_array[n--] = NULL;\n\n    for (iter = path_list; iter; iter = iter->next) {\n        path_array[n--] = iter->data;\n    }\n\n    g_slist_free(path_list);\n\n    return path_array;\n}\n\nint qemu_fdt_setprop(void *fdt, const char *node_path,\n                     const char *property, const void *val, int size)\n{\n    int r;\n\n    r = fdt_setprop(fdt, findnode_nofail(fdt, node_path), property, val, size);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s: %s\", __func__, node_path,\n                     property, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n\nint qemu_fdt_setprop_cell(void *fdt, const char *node_path,\n                          const char *property, uint32_t val)\n{\n    int r;\n\n    r = fdt_setprop_cell(fdt, findnode_nofail(fdt, node_path), property, val);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %#08x: %s\", __func__,\n                     node_path, property, val, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n\nint qemu_fdt_setprop_u64(void *fdt, const char *node_path,\n                         const char *property, uint64_t val)\n{\n    val = cpu_to_be64(val);\n    return qemu_fdt_setprop(fdt, node_path, property, &val, sizeof(val));\n}\n\nint qemu_fdt_setprop_string(void *fdt, const char *node_path,\n                            const char *property, const char *string)\n{\n    int r;\n\n    r = fdt_setprop_string(fdt, findnode_nofail(fdt, node_path), property, string);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %s: %s\", __func__,\n                     node_path, property, string, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n\nconst void *qemu_fdt_getprop(void *fdt, const char *node_path,\n                             const char *property, int *lenp, Error **errp)\n{\n    int len;\n    const void *r;\n\n    if (!lenp) {\n        lenp = &len;\n    }\n    r = fdt_getprop(fdt, findnode_nofail(fdt, node_path), property, lenp);\n    if (!r) {\n        error_setg(errp, \"%s: Couldn't get %s/%s: %s\", __func__,\n                  node_path, property, fdt_strerror(*lenp));\n    }\n    return r;\n}\n\nuint32_t qemu_fdt_getprop_cell(void *fdt, const char *node_path,\n                               const char *property, int *lenp, Error **errp)\n{\n    int len;\n    const uint32_t *p;\n\n    if (!lenp) {\n        lenp = &len;\n    }\n    p = qemu_fdt_getprop(fdt, node_path, property, lenp, errp);\n    if (!p) {\n        return 0;\n    } else if (*lenp != 4) {\n        error_setg(errp, \"%s: %s/%s not 4 bytes long (not a cell?)\",\n                   __func__, node_path, property);\n        *lenp = -EINVAL;\n        return 0;\n    }\n    return be32_to_cpu(*p);\n}\n\nuint32_t qemu_fdt_get_phandle(void *fdt, const char *path)\n{\n    uint32_t r;\n\n    r = fdt_get_phandle(fdt, findnode_nofail(fdt, path));\n    if (r == 0) {\n        error_report(\"%s: Couldn't get phandle for %s: %s\", __func__,\n                     path, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n\nint qemu_fdt_setprop_phandle(void *fdt, const char *node_path,\n                             const char *property,\n                             const char *target_node_path)\n{\n    uint32_t phandle = qemu_fdt_get_phandle(fdt, target_node_path);\n    return qemu_fdt_setprop_cell(fdt, node_path, property, phandle);\n}\n\nuint32_t qemu_fdt_alloc_phandle(void *fdt)\n{\n    static int phandle = 0x0;\n\n    /*\n     * We need to find out if the user gave us special instruction at\n     * which phandle id to start allocating phandles.\n     */\n    if (!phandle) {\n        phandle = machine_phandle_start(current_machine);\n    }\n\n    if (!phandle) {\n        /*\n         * None or invalid phandle given on the command line, so fall back to\n         * default starting point.\n         */\n        phandle = 0x8000;\n    }\n\n    return phandle++;\n}\n\nint qemu_fdt_nop_node(void *fdt, const char *node_path)\n{\n    int r;\n\n    r = fdt_nop_node(fdt, findnode_nofail(fdt, node_path));\n    if (r < 0) {\n        error_report(\"%s: Couldn't nop node %s: %s\", __func__, node_path,\n                     fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n\nint qemu_fdt_add_subnode(void *fdt, const char *name)\n{\n    char *dupname = g_strdup(name);\n    char *basename = strrchr(dupname, '/');\n    int retval;\n    int parent = 0;\n\n    if (!basename) {\n        g_free(dupname);\n        return -1;\n    }\n\n    basename[0] = '\\0';\n    basename++;\n\n    if (dupname[0]) {\n        parent = findnode_nofail(fdt, dupname);\n    }\n\n    retval = fdt_add_subnode(fdt, parent, basename);\n    if (retval < 0) {\n        error_report(\"FDT: Failed to create subnode %s: %s\", name,\n                     fdt_strerror(retval));\n        exit(1);\n    }\n\n    g_free(dupname);\n    return retval;\n}\n\nvoid qemu_fdt_dumpdtb(void *fdt, int size)\n{\n    const char *dumpdtb = qemu_opt_get(qemu_get_machine_opts(), \"dumpdtb\");\n\n    if (dumpdtb) {\n        /* Dump the dtb to a file and quit */\n        exit(g_file_set_contents(dumpdtb, fdt, size, NULL) ? 0 : 1);\n    }\n}\n\nint qemu_fdt_setprop_sized_cells_from_array(void *fdt,\n                                            const char *node_path,\n                                            const char *property,\n                                            int numvalues,\n                                            uint64_t *values)\n{\n    uint32_t *propcells;\n    uint64_t value;\n    int cellnum, vnum, ncells;\n    uint32_t hival;\n    int ret;\n\n    propcells = g_new0(uint32_t, numvalues * 2);\n\n    cellnum = 0;\n    for (vnum = 0; vnum < numvalues; vnum++) {\n        ncells = values[vnum * 2];\n        if (ncells != 1 && ncells != 2) {\n            ret = -1;\n            goto out;\n        }\n        value = values[vnum * 2 + 1];\n        hival = cpu_to_be32(value >> 32);\n        if (ncells > 1) {\n            propcells[cellnum++] = hival;\n        } else if (hival != 0) {\n            ret = -1;\n            goto out;\n        }\n        propcells[cellnum++] = cpu_to_be32(value);\n    }\n\n    ret = qemu_fdt_setprop(fdt, node_path, property, propcells,\n                           cellnum * sizeof(uint32_t));\nout:\n    g_free(propcells);\n    return ret;\n}\n"
        },
        {
          "name": "disas.c",
          "type": "blob",
          "size": 16.2412109375,
          "content": "/* General \"disassemble this chunk\" code.  Used for debugging. */\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"disas/bfd.h\"\n#include \"elf.h\"\n\n#include \"cpu.h\"\n#include \"disas/disas.h\"\n#include \"disas/capstone.h\"\n\ntypedef struct CPUDebug {\n    struct disassemble_info info;\n    CPUState *cpu;\n} CPUDebug;\n\n/* Filled in by elfload.c.  Simplistic, but will do for now. */\nstruct syminfo *syminfos = NULL;\n\n/* Get LENGTH bytes from info's buffer, at target address memaddr.\n   Transfer them to myaddr.  */\nint\nbuffer_read_memory(bfd_vma memaddr, bfd_byte *myaddr, int length,\n                   struct disassemble_info *info)\n{\n    if (memaddr < info->buffer_vma\n        || memaddr + length > info->buffer_vma + info->buffer_length)\n        /* Out of bounds.  Use EIO because GDB uses it.  */\n        return EIO;\n    memcpy (myaddr, info->buffer + (memaddr - info->buffer_vma), length);\n    return 0;\n}\n\n/* Get LENGTH bytes from info's buffer, at target address memaddr.\n   Transfer them to myaddr.  */\nstatic int\ntarget_read_memory (bfd_vma memaddr,\n                    bfd_byte *myaddr,\n                    int length,\n                    struct disassemble_info *info)\n{\n    CPUDebug *s = container_of(info, CPUDebug, info);\n\n    cpu_memory_rw_debug(s->cpu, memaddr, myaddr, length, 0);\n    return 0;\n}\n\n/* Print an error message.  We can assume that this is in response to\n   an error return from buffer_read_memory.  */\nvoid\nperror_memory (int status, bfd_vma memaddr, struct disassemble_info *info)\n{\n  if (status != EIO)\n    /* Can't happen.  */\n    (*info->fprintf_func) (info->stream, \"Unknown error %d\\n\", status);\n  else\n    /* Actually, address between memaddr and memaddr + len was\n       out of bounds.  */\n    (*info->fprintf_func) (info->stream,\n\t\t\t   \"Address 0x%\" PRIx64 \" is out of bounds.\\n\", memaddr);\n}\n\n/* This could be in a separate file, to save minuscule amounts of space\n   in statically linked executables.  */\n\n/* Just print the address is hex.  This is included for completeness even\n   though both GDB and objdump provide their own (to print symbolic\n   addresses).  */\n\nvoid\ngeneric_print_address (bfd_vma addr, struct disassemble_info *info)\n{\n    (*info->fprintf_func) (info->stream, \"0x%\" PRIx64, addr);\n}\n\n/* Print address in hex, truncated to the width of a host virtual address. */\nstatic void\ngeneric_print_host_address(bfd_vma addr, struct disassemble_info *info)\n{\n    uint64_t mask = ~0ULL >> (64 - (sizeof(void *) * 8));\n    generic_print_address(addr & mask, info);\n}\n\n/* Just return the given address.  */\n\nint\ngeneric_symbol_at_address (bfd_vma addr, struct disassemble_info *info)\n{\n  return 1;\n}\n\nbfd_vma bfd_getl64 (const bfd_byte *addr)\n{\n  unsigned long long v;\n\n  v = (unsigned long long) addr[0];\n  v |= (unsigned long long) addr[1] << 8;\n  v |= (unsigned long long) addr[2] << 16;\n  v |= (unsigned long long) addr[3] << 24;\n  v |= (unsigned long long) addr[4] << 32;\n  v |= (unsigned long long) addr[5] << 40;\n  v |= (unsigned long long) addr[6] << 48;\n  v |= (unsigned long long) addr[7] << 56;\n  return (bfd_vma) v;\n}\n\nbfd_vma bfd_getl32 (const bfd_byte *addr)\n{\n  unsigned long v;\n\n  v = (unsigned long) addr[0];\n  v |= (unsigned long) addr[1] << 8;\n  v |= (unsigned long) addr[2] << 16;\n  v |= (unsigned long) addr[3] << 24;\n  return (bfd_vma) v;\n}\n\nbfd_vma bfd_getb32 (const bfd_byte *addr)\n{\n  unsigned long v;\n\n  v = (unsigned long) addr[0] << 24;\n  v |= (unsigned long) addr[1] << 16;\n  v |= (unsigned long) addr[2] << 8;\n  v |= (unsigned long) addr[3];\n  return (bfd_vma) v;\n}\n\nbfd_vma bfd_getl16 (const bfd_byte *addr)\n{\n  unsigned long v;\n\n  v = (unsigned long) addr[0];\n  v |= (unsigned long) addr[1] << 8;\n  return (bfd_vma) v;\n}\n\nbfd_vma bfd_getb16 (const bfd_byte *addr)\n{\n  unsigned long v;\n\n  v = (unsigned long) addr[0] << 24;\n  v |= (unsigned long) addr[1] << 16;\n  return (bfd_vma) v;\n}\n\nstatic int print_insn_objdump(bfd_vma pc, disassemble_info *info,\n                              const char *prefix)\n{\n    int i, n = info->buffer_length;\n    uint8_t *buf = g_malloc(n);\n\n    info->read_memory_func(pc, buf, n, info);\n\n    for (i = 0; i < n; ++i) {\n        if (i % 32 == 0) {\n            info->fprintf_func(info->stream, \"\\n%s: \", prefix);\n        }\n        info->fprintf_func(info->stream, \"%02x\", buf[i]);\n    }\n\n    g_free(buf);\n    return n;\n}\n\nstatic int print_insn_od_host(bfd_vma pc, disassemble_info *info)\n{\n    return print_insn_objdump(pc, info, \"OBJD-H\");\n}\n\nstatic int print_insn_od_target(bfd_vma pc, disassemble_info *info)\n{\n    return print_insn_objdump(pc, info, \"OBJD-T\");\n}\n\n#ifdef CONFIG_CAPSTONE\n/* Temporary storage for the capstone library.  This will be alloced via\n   malloc with a size private to the library; thus there's no reason not\n   to share this across calls and across host vs target disassembly.  */\nstatic __thread cs_insn *cap_insn;\n\n/* Initialize the Capstone library.  */\n/* ??? It would be nice to cache this.  We would need one handle for the\n   host and one for the target.  For most targets we can reset specific\n   parameters via cs_option(CS_OPT_MODE, new_mode), but we cannot change\n   CS_ARCH_* in this way.  Thus we would need to be able to close and\n   re-open the target handle with a different arch for the target in order\n   to handle AArch64 vs AArch32 mode switching.  */\nstatic cs_err cap_disas_start(disassemble_info *info, csh *handle)\n{\n    cs_mode cap_mode = info->cap_mode;\n    cs_err err;\n\n    cap_mode += (info->endian == BFD_ENDIAN_BIG ? CS_MODE_BIG_ENDIAN\n                 : CS_MODE_LITTLE_ENDIAN);\n\n    err = cs_open(info->cap_arch, cap_mode, handle);\n    if (err != CS_ERR_OK) {\n        return err;\n    }\n\n    /* ??? There probably ought to be a better place to put this.  */\n    if (info->cap_arch == CS_ARCH_X86) {\n        /* We don't care about errors (if for some reason the library\n           is compiled without AT&T syntax); the user will just have\n           to deal with the Intel syntax.  */\n        cs_option(*handle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);\n    }\n\n    /* \"Disassemble\" unknown insns as \".byte W,X,Y,Z\".  */\n    cs_option(*handle, CS_OPT_SKIPDATA, CS_OPT_ON);\n\n    /* Allocate temp space for cs_disasm_iter.  */\n    if (cap_insn == NULL) {\n        cap_insn = cs_malloc(*handle);\n        if (cap_insn == NULL) {\n            cs_close(handle);\n            return CS_ERR_MEM;\n        }\n    }\n    return CS_ERR_OK;\n}\n\n/* Disassemble SIZE bytes at PC for the target.  */\nstatic bool cap_disas_target(disassemble_info *info, uint64_t pc, size_t size)\n{\n    uint8_t cap_buf[1024];\n    csh handle;\n    cs_insn *insn;\n    size_t csize = 0;\n\n    if (cap_disas_start(info, &handle) != CS_ERR_OK) {\n        return false;\n    }\n    insn = cap_insn;\n\n    while (1) {\n        size_t tsize = MIN(sizeof(cap_buf) - csize, size);\n        const uint8_t *cbuf = cap_buf;\n\n        target_read_memory(pc + csize, cap_buf + csize, tsize, info);\n        csize += tsize;\n        size -= tsize;\n\n        while (cs_disasm_iter(handle, &cbuf, &csize, &pc, insn)) {\n            (*info->fprintf_func)(info->stream,\n                                  \"0x%08\" PRIx64 \":  %-12s %s\\n\",\n                                  insn->address, insn->mnemonic,\n                                  insn->op_str);\n        }\n\n        /* If the target memory is not consumed, go back for more... */\n        if (size != 0) {\n            /* ... taking care to move any remaining fractional insn\n               to the beginning of the buffer.  */\n            if (csize != 0) {\n                memmove(cap_buf, cbuf, csize);\n            }\n            continue;\n        }\n\n        /* Since the target memory is consumed, we should not have\n           a remaining fractional insn.  */\n        if (csize != 0) {\n            (*info->fprintf_func)(info->stream,\n                \"Disassembler disagrees with translator \"\n                \"over instruction decoding\\n\"\n                \"Please report this to qemu-devel@nongnu.org\\n\");\n        }\n        break;\n    }\n\n    cs_close(&handle);\n    return true;\n}\n\n/* Disassemble SIZE bytes at CODE for the host.  */\nstatic bool cap_disas_host(disassemble_info *info, void *code, size_t size)\n{\n    csh handle;\n    const uint8_t *cbuf;\n    cs_insn *insn;\n    uint64_t pc;\n\n    if (cap_disas_start(info, &handle) != CS_ERR_OK) {\n        return false;\n    }\n    insn = cap_insn;\n\n    cbuf = code;\n    pc = (uintptr_t)code;\n\n    while (cs_disasm_iter(handle, &cbuf, &size, &pc, insn)) {\n        (*info->fprintf_func)(info->stream,\n                              \"0x%08\" PRIx64 \":  %-12s %s\\n\",\n                              insn->address, insn->mnemonic,\n                              insn->op_str);\n    }\n    if (size != 0) {\n        (*info->fprintf_func)(info->stream,\n            \"Disassembler disagrees with TCG over instruction encoding\\n\"\n            \"Please report this to qemu-devel@nongnu.org\\n\");\n    }\n\n    cs_close(&handle);\n    return true;\n}\n\n#if !defined(CONFIG_USER_ONLY)\n/* Disassemble COUNT insns at PC for the target.  */\nstatic bool cap_disas_monitor(disassemble_info *info, uint64_t pc, int count)\n{\n    uint8_t cap_buf[32];\n    csh handle;\n    cs_insn *insn;\n    size_t csize = 0;\n\n    if (cap_disas_start(info, &handle) != CS_ERR_OK) {\n        return false;\n    }\n    insn = cap_insn;\n\n    while (1) {\n        /* We want to read memory for one insn, but generically we do not\n           know how much memory that is.  We have a small buffer which is\n           known to be sufficient for all supported targets.  Try to not\n           read beyond the page, Just In Case.  For even more simplicity,\n           ignore the actual target page size and use a 1k boundary.  If\n           that turns out to be insufficient, we'll come back around the\n           loop and read more.  */\n        uint64_t epc = QEMU_ALIGN_UP(pc + csize + 1, 1024);\n        size_t tsize = MIN(sizeof(cap_buf) - csize, epc - pc);\n        const uint8_t *cbuf = cap_buf;\n\n        /* Make certain that we can make progress.  */\n        assert(tsize != 0);\n        info->read_memory_func(pc, cap_buf + csize, tsize, info);\n        csize += tsize;\n\n        if (cs_disasm_iter(handle, &cbuf, &csize, &pc, insn)) {\n            (*info->fprintf_func)(info->stream,\n                                  \"0x%08\" PRIx64 \":  %-12s %s\\n\",\n                                  insn->address, insn->mnemonic,\n                                  insn->op_str);\n            if (--count <= 0) {\n                break;\n            }\n        }\n        memmove(cap_buf, cbuf, csize);\n    }\n\n    cs_close(&handle);\n    return true;\n}\n#endif /* !CONFIG_USER_ONLY */\n#else\n# define cap_disas_target(i, p, s)  false\n# define cap_disas_host(i, p, s)  false\n# define cap_disas_monitor(i, p, c)  false\n#endif /* CONFIG_CAPSTONE */\n\n/* Disassemble this for me please... (debugging). 'flags' has the following\n   values:\n    i386 - 1 means 16 bit code, 2 means 64 bit code\n    ppc  - bits 0:15 specify (optionally) the machine instruction set;\n           bit 16 indicates little endian.\n    other targets - unused\n */\nvoid target_disas(FILE *out, CPUState *cpu, target_ulong code,\n                  target_ulong size, int flags)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    target_ulong pc;\n    int count;\n    CPUDebug s;\n\n    INIT_DISASSEMBLE_INFO(s.info, out, fprintf);\n\n    s.cpu = cpu;\n    s.info.read_memory_func = target_read_memory;\n    s.info.read_memory_inner_func = NULL;\n    s.info.buffer_vma = code;\n    s.info.buffer_length = size;\n    s.info.print_address_func = generic_print_address;\n    s.info.cap_arch = -1;\n    s.info.cap_mode = 0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n    s.info.endian = BFD_ENDIAN_BIG;\n#else\n    s.info.endian = BFD_ENDIAN_LITTLE;\n#endif\n\n    if (cc->disas_set_info) {\n        cc->disas_set_info(cpu, &s.info);\n    }\n\n    if (s.info.cap_arch >= 0 && cap_disas_target(&s.info, code, size)) {\n        return;\n    }\n\n    if (s.info.print_insn == NULL) {\n        s.info.print_insn = print_insn_od_target;\n    }\n\n    for (pc = code; size > 0; pc += count, size -= count) {\n\tfprintf(out, \"0x\" TARGET_FMT_lx \":  \", pc);\n\tcount = s.info.print_insn(pc, &s.info);\n\tfprintf(out, \"\\n\");\n\tif (count < 0)\n\t    break;\n        if (size < count) {\n            fprintf(out,\n                    \"Disassembler disagrees with translator over instruction \"\n                    \"decoding\\n\"\n                    \"Please report this to qemu-devel@nongnu.org\\n\");\n            break;\n        }\n    }\n}\n\n/* Disassemble this for me please... (debugging). */\nvoid disas(FILE *out, void *code, unsigned long size)\n{\n    uintptr_t pc;\n    int count;\n    CPUDebug s;\n    int (*print_insn)(bfd_vma pc, disassemble_info *info) = NULL;\n\n    INIT_DISASSEMBLE_INFO(s.info, out, fprintf);\n    s.info.print_address_func = generic_print_host_address;\n\n    s.info.buffer = code;\n    s.info.buffer_vma = (uintptr_t)code;\n    s.info.buffer_length = size;\n    s.info.cap_arch = -1;\n    s.info.cap_mode = 0;\n\n#ifdef HOST_WORDS_BIGENDIAN\n    s.info.endian = BFD_ENDIAN_BIG;\n#else\n    s.info.endian = BFD_ENDIAN_LITTLE;\n#endif\n#if defined(CONFIG_TCG_INTERPRETER)\n    print_insn = print_insn_tci;\n#elif defined(__i386__)\n    s.info.mach = bfd_mach_i386_i386;\n    print_insn = print_insn_i386;\n#elif defined(__x86_64__)\n    s.info.mach = bfd_mach_x86_64;\n    print_insn = print_insn_i386;\n#elif defined(_ARCH_PPC)\n    s.info.disassembler_options = (char *)\"any\";\n    print_insn = print_insn_ppc;\n    s.info.cap_arch = CS_ARCH_PPC;\n# ifdef _ARCH_PPC64\n    s.info.cap_mode = CS_MODE_64;\n# endif\n#elif defined(__aarch64__) && defined(CONFIG_ARM_A64_DIS)\n    print_insn = print_insn_arm_a64;\n#elif defined(__alpha__)\n    print_insn = print_insn_alpha;\n#elif defined(__sparc__)\n    print_insn = print_insn_sparc;\n    s.info.mach = bfd_mach_sparc_v9b;\n#elif defined(__arm__)\n    print_insn = print_insn_arm;\n#elif defined(__MIPSEB__)\n    print_insn = print_insn_big_mips;\n#elif defined(__MIPSEL__)\n    print_insn = print_insn_little_mips;\n#elif defined(__m68k__)\n    print_insn = print_insn_m68k;\n#elif defined(__s390__)\n    print_insn = print_insn_s390;\n#elif defined(__hppa__)\n    print_insn = print_insn_hppa;\n#endif\n\n    if (s.info.cap_arch >= 0 && cap_disas_host(&s.info, code, size)) {\n        return;\n    }\n\n    if (print_insn == NULL) {\n        print_insn = print_insn_od_host;\n    }\n    for (pc = (uintptr_t)code; size > 0; pc += count, size -= count) {\n        fprintf(out, \"0x%08\" PRIxPTR \":  \", pc);\n        count = print_insn(pc, &s.info);\n\tfprintf(out, \"\\n\");\n\tif (count < 0)\n\t    break;\n    }\n}\n\n/* Look up symbol for debugging purpose.  Returns \"\" if unknown. */\nconst char *lookup_symbol(target_ulong orig_addr)\n{\n    const char *symbol = \"\";\n    struct syminfo *s;\n\n    for (s = syminfos; s; s = s->next) {\n        symbol = s->lookup_symbol(s, orig_addr);\n        if (symbol[0] != '\\0') {\n            break;\n        }\n    }\n\n    return symbol;\n}\n\n#if !defined(CONFIG_USER_ONLY)\n\n#include \"monitor/monitor.h\"\n\nstatic int monitor_disas_is_physical;\n\nstatic int\nmonitor_read_memory (bfd_vma memaddr, bfd_byte *myaddr, int length,\n                     struct disassemble_info *info)\n{\n    CPUDebug *s = container_of(info, CPUDebug, info);\n\n    if (monitor_disas_is_physical) {\n        cpu_physical_memory_read(memaddr, myaddr, length);\n    } else {\n        cpu_memory_rw_debug(s->cpu, memaddr, myaddr, length, 0);\n    }\n    return 0;\n}\n\n/* Disassembler for the monitor.\n   See target_disas for a description of flags. */\nvoid monitor_disas(Monitor *mon, CPUState *cpu,\n                   target_ulong pc, int nb_insn, int is_physical, int flags)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    int count, i;\n    CPUDebug s;\n\n    INIT_DISASSEMBLE_INFO(s.info, (FILE *)mon, monitor_fprintf);\n\n    s.cpu = cpu;\n    monitor_disas_is_physical = is_physical;\n    s.info.read_memory_func = monitor_read_memory;\n    s.info.print_address_func = generic_print_address;\n    s.info.buffer_vma = pc;\n    s.info.cap_arch = -1;\n    s.info.cap_mode = 0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n    s.info.endian = BFD_ENDIAN_BIG;\n#else\n    s.info.endian = BFD_ENDIAN_LITTLE;\n#endif\n\n    if (cc->disas_set_info) {\n        cc->disas_set_info(cpu, &s.info);\n    }\n\n    if (s.info.cap_arch >= 0 && cap_disas_monitor(&s.info, pc, nb_insn)) {\n        return;\n    }\n\n    if (!s.info.print_insn) {\n        monitor_printf(mon, \"0x\" TARGET_FMT_lx\n                       \": Asm output not supported on this arch\\n\", pc);\n        return;\n    }\n\n    for(i = 0; i < nb_insn; i++) {\n\tmonitor_printf(mon, \"0x\" TARGET_FMT_lx \":  \", pc);\n        count = s.info.print_insn(pc, &s.info);\n\tmonitor_printf(mon, \"\\n\");\n\tif (count < 0)\n\t    break;\n        pc += count;\n    }\n}\n#endif\n"
        },
        {
          "name": "disas",
          "type": "tree",
          "content": null
        },
        {
          "name": "dma-helpers.c",
          "type": "blob",
          "size": 7.8837890625,
          "content": "/*\n * DMA helper functions\n *\n * Copyright (c) 2009 Red Hat\n *\n * This work is licensed under the terms of the GNU General Public License\n * (GNU GPL), version 2 or later.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/dma.h\"\n#include \"trace-root.h\"\n#include \"qemu/thread.h\"\n#include \"qemu/main-loop.h\"\n\n/* #define DEBUG_IOMMU */\n\nint dma_memory_set(AddressSpace *as, dma_addr_t addr, uint8_t c, dma_addr_t len)\n{\n    dma_barrier(as, DMA_DIRECTION_FROM_DEVICE);\n\n#define FILLBUF_SIZE 512\n    uint8_t fillbuf[FILLBUF_SIZE];\n    int l;\n    bool error = false;\n\n    memset(fillbuf, c, FILLBUF_SIZE);\n    while (len > 0) {\n        l = len < FILLBUF_SIZE ? len : FILLBUF_SIZE;\n        error |= address_space_rw(as, addr, MEMTXATTRS_UNSPECIFIED,\n                                  fillbuf, l, true);\n        len -= l;\n        addr += l;\n    }\n\n    return error;\n}\n\nvoid qemu_sglist_init(QEMUSGList *qsg, DeviceState *dev, int alloc_hint,\n                      AddressSpace *as)\n{\n    qsg->sg = g_malloc(alloc_hint * sizeof(ScatterGatherEntry));\n    qsg->nsg = 0;\n    qsg->nalloc = alloc_hint;\n    qsg->size = 0;\n    qsg->as = as;\n    qsg->dev = dev;\n    object_ref(OBJECT(dev));\n}\n\nvoid qemu_sglist_add(QEMUSGList *qsg, dma_addr_t base, dma_addr_t len)\n{\n    if (qsg->nsg == qsg->nalloc) {\n        qsg->nalloc = 2 * qsg->nalloc + 1;\n        qsg->sg = g_realloc(qsg->sg, qsg->nalloc * sizeof(ScatterGatherEntry));\n    }\n    qsg->sg[qsg->nsg].base = base;\n    qsg->sg[qsg->nsg].len = len;\n    qsg->size += len;\n    ++qsg->nsg;\n}\n\nvoid qemu_sglist_destroy(QEMUSGList *qsg)\n{\n    object_unref(OBJECT(qsg->dev));\n    g_free(qsg->sg);\n    memset(qsg, 0, sizeof(*qsg));\n}\n\ntypedef struct {\n    BlockAIOCB common;\n    AioContext *ctx;\n    BlockAIOCB *acb;\n    QEMUSGList *sg;\n    uint32_t align;\n    uint64_t offset;\n    DMADirection dir;\n    int sg_cur_index;\n    dma_addr_t sg_cur_byte;\n    QEMUIOVector iov;\n    QEMUBH *bh;\n    DMAIOFunc *io_func;\n    void *io_func_opaque;\n} DMAAIOCB;\n\nstatic void dma_blk_cb(void *opaque, int ret);\n\nstatic void reschedule_dma(void *opaque)\n{\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    qemu_bh_delete(dbs->bh);\n    dbs->bh = NULL;\n    dma_blk_cb(dbs, 0);\n}\n\nstatic void dma_blk_unmap(DMAAIOCB *dbs)\n{\n    int i;\n\n    for (i = 0; i < dbs->iov.niov; ++i) {\n        dma_memory_unmap(dbs->sg->as, dbs->iov.iov[i].iov_base,\n                         dbs->iov.iov[i].iov_len, dbs->dir,\n                         dbs->iov.iov[i].iov_len);\n    }\n    qemu_iovec_reset(&dbs->iov);\n}\n\nstatic void dma_complete(DMAAIOCB *dbs, int ret)\n{\n    trace_dma_complete(dbs, ret, dbs->common.cb);\n\n    dma_blk_unmap(dbs);\n    if (dbs->common.cb) {\n        dbs->common.cb(dbs->common.opaque, ret);\n    }\n    qemu_iovec_destroy(&dbs->iov);\n    if (dbs->bh) {\n        qemu_bh_delete(dbs->bh);\n        dbs->bh = NULL;\n    }\n    qemu_aio_unref(dbs);\n}\n\nstatic void dma_blk_cb(void *opaque, int ret)\n{\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n    dma_addr_t cur_addr, cur_len;\n    void *mem;\n\n    trace_dma_blk_cb(dbs, ret);\n\n    dbs->acb = NULL;\n    dbs->offset += dbs->iov.size;\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n        dma_complete(dbs, ret);\n        return;\n    }\n    dma_blk_unmap(dbs);\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);\n        if (!mem)\n            break;\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n        dbs->sg_cur_byte += cur_len;\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n            dbs->sg_cur_byte = 0;\n            ++dbs->sg_cur_index;\n        }\n    }\n\n    if (dbs->iov.size == 0) {\n        trace_dma_map_wait(dbs);\n        dbs->bh = aio_bh_new(dbs->ctx, reschedule_dma, dbs);\n        cpu_register_map_client(dbs->bh);\n        return;\n    }\n\n    if (!QEMU_IS_ALIGNED(dbs->iov.size, dbs->align)) {\n        qemu_iovec_discard_back(&dbs->iov,\n                                QEMU_ALIGN_DOWN(dbs->iov.size, dbs->align));\n    }\n\n    aio_context_acquire(dbs->ctx);\n    dbs->acb = dbs->io_func(dbs->offset, &dbs->iov,\n                            dma_blk_cb, dbs, dbs->io_func_opaque);\n    aio_context_release(dbs->ctx);\n    assert(dbs->acb);\n}\n\nstatic void dma_aio_cancel(BlockAIOCB *acb)\n{\n    DMAAIOCB *dbs = container_of(acb, DMAAIOCB, common);\n\n    trace_dma_aio_cancel(dbs);\n\n    if (dbs->acb) {\n        blk_aio_cancel_async(dbs->acb);\n    }\n    if (dbs->bh) {\n        cpu_unregister_map_client(dbs->bh);\n        qemu_bh_delete(dbs->bh);\n        dbs->bh = NULL;\n    }\n}\n\nstatic AioContext *dma_get_aio_context(BlockAIOCB *acb)\n{\n    DMAAIOCB *dbs = container_of(acb, DMAAIOCB, common);\n\n    return dbs->ctx;\n}\n\nstatic const AIOCBInfo dma_aiocb_info = {\n    .aiocb_size         = sizeof(DMAAIOCB),\n    .cancel_async       = dma_aio_cancel,\n    .get_aio_context    = dma_get_aio_context,\n};\n\nBlockAIOCB *dma_blk_io(AioContext *ctx,\n    QEMUSGList *sg, uint64_t offset, uint32_t align,\n    DMAIOFunc *io_func, void *io_func_opaque,\n    BlockCompletionFunc *cb,\n    void *opaque, DMADirection dir)\n{\n    DMAAIOCB *dbs = qemu_aio_get(&dma_aiocb_info, NULL, cb, opaque);\n\n    trace_dma_blk_io(dbs, io_func_opaque, offset, (dir == DMA_DIRECTION_TO_DEVICE));\n\n    dbs->acb = NULL;\n    dbs->sg = sg;\n    dbs->ctx = ctx;\n    dbs->offset = offset;\n    dbs->align = align;\n    dbs->sg_cur_index = 0;\n    dbs->sg_cur_byte = 0;\n    dbs->dir = dir;\n    dbs->io_func = io_func;\n    dbs->io_func_opaque = io_func_opaque;\n    dbs->bh = NULL;\n    qemu_iovec_init(&dbs->iov, sg->nsg);\n    dma_blk_cb(dbs, 0);\n    return &dbs->common;\n}\n\n\nstatic\nBlockAIOCB *dma_blk_read_io_func(int64_t offset, QEMUIOVector *iov,\n                                 BlockCompletionFunc *cb, void *cb_opaque,\n                                 void *opaque)\n{\n    BlockBackend *blk = opaque;\n    return blk_aio_preadv(blk, offset, iov, 0, cb, cb_opaque);\n}\n\nBlockAIOCB *dma_blk_read(BlockBackend *blk,\n                         QEMUSGList *sg, uint64_t offset, uint32_t align,\n                         void (*cb)(void *opaque, int ret), void *opaque)\n{\n    return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,\n                      dma_blk_read_io_func, blk, cb, opaque,\n                      DMA_DIRECTION_FROM_DEVICE);\n}\n\nstatic\nBlockAIOCB *dma_blk_write_io_func(int64_t offset, QEMUIOVector *iov,\n                                  BlockCompletionFunc *cb, void *cb_opaque,\n                                  void *opaque)\n{\n    BlockBackend *blk = opaque;\n    return blk_aio_pwritev(blk, offset, iov, 0, cb, cb_opaque);\n}\n\nBlockAIOCB *dma_blk_write(BlockBackend *blk,\n                          QEMUSGList *sg, uint64_t offset, uint32_t align,\n                          void (*cb)(void *opaque, int ret), void *opaque)\n{\n    return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,\n                      dma_blk_write_io_func, blk, cb, opaque,\n                      DMA_DIRECTION_TO_DEVICE);\n}\n\n\nstatic uint64_t dma_buf_rw(uint8_t *ptr, int32_t len, QEMUSGList *sg,\n                           DMADirection dir)\n{\n    uint64_t resid;\n    int sg_cur_index;\n\n    resid = sg->size;\n    sg_cur_index = 0;\n    len = MIN(len, resid);\n    while (len > 0) {\n        ScatterGatherEntry entry = sg->sg[sg_cur_index++];\n        int32_t xfer = MIN(len, entry.len);\n        dma_memory_rw(sg->as, entry.base, ptr, xfer, dir);\n        ptr += xfer;\n        len -= xfer;\n        resid -= xfer;\n    }\n\n    return resid;\n}\n\nuint64_t dma_buf_read(uint8_t *ptr, int32_t len, QEMUSGList *sg)\n{\n    return dma_buf_rw(ptr, len, sg, DMA_DIRECTION_FROM_DEVICE);\n}\n\nuint64_t dma_buf_write(uint8_t *ptr, int32_t len, QEMUSGList *sg)\n{\n    return dma_buf_rw(ptr, len, sg, DMA_DIRECTION_TO_DEVICE);\n}\n\nvoid dma_acct_start(BlockBackend *blk, BlockAcctCookie *cookie,\n                    QEMUSGList *sg, enum BlockAcctType type)\n{\n    block_acct_start(blk_get_stats(blk), cookie, sg->size, type);\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dtc",
          "type": "commit",
          "content": null
        },
        {
          "name": "dump.c",
          "type": "blob",
          "size": 53.181640625,
          "content": "/*\n * QEMU dump\n *\n * Copyright Fujitsu, Corp. 2011, 2012\n *\n * Authors:\n *     Wen Congyang <wency@cn.fujitsu.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/cutils.h\"\n#include \"elf.h\"\n#include \"cpu.h\"\n#include \"exec/cpu-all.h\"\n#include \"exec/hwaddr.h\"\n#include \"monitor/monitor.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/dump.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/memory_mapping.h\"\n#include \"sysemu/cpus.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qmp-commands.h\"\n#include \"qapi-event.h\"\n\n#include <zlib.h>\n#ifdef CONFIG_LZO\n#include <lzo/lzo1x.h>\n#endif\n#ifdef CONFIG_SNAPPY\n#include <snappy-c.h>\n#endif\n#ifndef ELF_MACHINE_UNAME\n#define ELF_MACHINE_UNAME \"Unknown\"\n#endif\n\nuint16_t cpu_to_dump16(DumpState *s, uint16_t val)\n{\n    if (s->dump_info.d_endian == ELFDATA2LSB) {\n        val = cpu_to_le16(val);\n    } else {\n        val = cpu_to_be16(val);\n    }\n\n    return val;\n}\n\nuint32_t cpu_to_dump32(DumpState *s, uint32_t val)\n{\n    if (s->dump_info.d_endian == ELFDATA2LSB) {\n        val = cpu_to_le32(val);\n    } else {\n        val = cpu_to_be32(val);\n    }\n\n    return val;\n}\n\nuint64_t cpu_to_dump64(DumpState *s, uint64_t val)\n{\n    if (s->dump_info.d_endian == ELFDATA2LSB) {\n        val = cpu_to_le64(val);\n    } else {\n        val = cpu_to_be64(val);\n    }\n\n    return val;\n}\n\nstatic int dump_cleanup(DumpState *s)\n{\n    guest_phys_blocks_free(&s->guest_phys_blocks);\n    memory_mapping_list_free(&s->list);\n    close(s->fd);\n    if (s->resume) {\n        vm_start();\n    }\n\n    return 0;\n}\n\nstatic int fd_write_vmcore(const void *buf, size_t size, void *opaque)\n{\n    DumpState *s = opaque;\n    size_t written_size;\n\n    written_size = qemu_write_full(s->fd, buf, size);\n    if (written_size != size) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void write_elf64_header(DumpState *s, Error **errp)\n{\n    Elf64_Ehdr elf_header;\n    int ret;\n\n    memset(&elf_header, 0, sizeof(Elf64_Ehdr));\n    memcpy(&elf_header, ELFMAG, SELFMAG);\n    elf_header.e_ident[EI_CLASS] = ELFCLASS64;\n    elf_header.e_ident[EI_DATA] = s->dump_info.d_endian;\n    elf_header.e_ident[EI_VERSION] = EV_CURRENT;\n    elf_header.e_type = cpu_to_dump16(s, ET_CORE);\n    elf_header.e_machine = cpu_to_dump16(s, s->dump_info.d_machine);\n    elf_header.e_version = cpu_to_dump32(s, EV_CURRENT);\n    elf_header.e_ehsize = cpu_to_dump16(s, sizeof(elf_header));\n    elf_header.e_phoff = cpu_to_dump64(s, sizeof(Elf64_Ehdr));\n    elf_header.e_phentsize = cpu_to_dump16(s, sizeof(Elf64_Phdr));\n    elf_header.e_phnum = cpu_to_dump16(s, s->phdr_num);\n    if (s->have_section) {\n        uint64_t shoff = sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr) * s->sh_info;\n\n        elf_header.e_shoff = cpu_to_dump64(s, shoff);\n        elf_header.e_shentsize = cpu_to_dump16(s, sizeof(Elf64_Shdr));\n        elf_header.e_shnum = cpu_to_dump16(s, 1);\n    }\n\n    ret = fd_write_vmcore(&elf_header, sizeof(elf_header), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write elf header\");\n    }\n}\n\nstatic void write_elf32_header(DumpState *s, Error **errp)\n{\n    Elf32_Ehdr elf_header;\n    int ret;\n\n    memset(&elf_header, 0, sizeof(Elf32_Ehdr));\n    memcpy(&elf_header, ELFMAG, SELFMAG);\n    elf_header.e_ident[EI_CLASS] = ELFCLASS32;\n    elf_header.e_ident[EI_DATA] = s->dump_info.d_endian;\n    elf_header.e_ident[EI_VERSION] = EV_CURRENT;\n    elf_header.e_type = cpu_to_dump16(s, ET_CORE);\n    elf_header.e_machine = cpu_to_dump16(s, s->dump_info.d_machine);\n    elf_header.e_version = cpu_to_dump32(s, EV_CURRENT);\n    elf_header.e_ehsize = cpu_to_dump16(s, sizeof(elf_header));\n    elf_header.e_phoff = cpu_to_dump32(s, sizeof(Elf32_Ehdr));\n    elf_header.e_phentsize = cpu_to_dump16(s, sizeof(Elf32_Phdr));\n    elf_header.e_phnum = cpu_to_dump16(s, s->phdr_num);\n    if (s->have_section) {\n        uint32_t shoff = sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr) * s->sh_info;\n\n        elf_header.e_shoff = cpu_to_dump32(s, shoff);\n        elf_header.e_shentsize = cpu_to_dump16(s, sizeof(Elf32_Shdr));\n        elf_header.e_shnum = cpu_to_dump16(s, 1);\n    }\n\n    ret = fd_write_vmcore(&elf_header, sizeof(elf_header), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write elf header\");\n    }\n}\n\nstatic void write_elf64_load(DumpState *s, MemoryMapping *memory_mapping,\n                             int phdr_index, hwaddr offset,\n                             hwaddr filesz, Error **errp)\n{\n    Elf64_Phdr phdr;\n    int ret;\n\n    memset(&phdr, 0, sizeof(Elf64_Phdr));\n    phdr.p_type = cpu_to_dump32(s, PT_LOAD);\n    phdr.p_offset = cpu_to_dump64(s, offset);\n    phdr.p_paddr = cpu_to_dump64(s, memory_mapping->phys_addr);\n    phdr.p_filesz = cpu_to_dump64(s, filesz);\n    phdr.p_memsz = cpu_to_dump64(s, memory_mapping->length);\n    phdr.p_vaddr = cpu_to_dump64(s, memory_mapping->virt_addr);\n\n    assert(memory_mapping->length >= filesz);\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write program header table\");\n    }\n}\n\nstatic void write_elf32_load(DumpState *s, MemoryMapping *memory_mapping,\n                             int phdr_index, hwaddr offset,\n                             hwaddr filesz, Error **errp)\n{\n    Elf32_Phdr phdr;\n    int ret;\n\n    memset(&phdr, 0, sizeof(Elf32_Phdr));\n    phdr.p_type = cpu_to_dump32(s, PT_LOAD);\n    phdr.p_offset = cpu_to_dump32(s, offset);\n    phdr.p_paddr = cpu_to_dump32(s, memory_mapping->phys_addr);\n    phdr.p_filesz = cpu_to_dump32(s, filesz);\n    phdr.p_memsz = cpu_to_dump32(s, memory_mapping->length);\n    phdr.p_vaddr = cpu_to_dump32(s, memory_mapping->virt_addr);\n\n    assert(memory_mapping->length >= filesz);\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write program header table\");\n    }\n}\n\nstatic void write_elf64_note(DumpState *s, Error **errp)\n{\n    Elf64_Phdr phdr;\n    hwaddr begin = s->memory_offset - s->note_size;\n    int ret;\n\n    memset(&phdr, 0, sizeof(Elf64_Phdr));\n    phdr.p_type = cpu_to_dump32(s, PT_NOTE);\n    phdr.p_offset = cpu_to_dump64(s, begin);\n    phdr.p_paddr = 0;\n    phdr.p_filesz = cpu_to_dump64(s, s->note_size);\n    phdr.p_memsz = cpu_to_dump64(s, s->note_size);\n    phdr.p_vaddr = 0;\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write program header table\");\n    }\n}\n\nstatic inline int cpu_index(CPUState *cpu)\n{\n    return cpu->cpu_index + 1;\n}\n\nstatic void write_elf64_notes(WriteCoreDumpFunction f, DumpState *s,\n                              Error **errp)\n{\n    CPUState *cpu;\n    int ret;\n    int id;\n\n    CPU_FOREACH(cpu) {\n        id = cpu_index(cpu);\n        ret = cpu_write_elf64_note(f, cpu, id, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to write elf notes\");\n            return;\n        }\n    }\n\n    CPU_FOREACH(cpu) {\n        ret = cpu_write_elf64_qemunote(f, cpu, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to write CPU status\");\n            return;\n        }\n    }\n}\n\nstatic void write_elf32_note(DumpState *s, Error **errp)\n{\n    hwaddr begin = s->memory_offset - s->note_size;\n    Elf32_Phdr phdr;\n    int ret;\n\n    memset(&phdr, 0, sizeof(Elf32_Phdr));\n    phdr.p_type = cpu_to_dump32(s, PT_NOTE);\n    phdr.p_offset = cpu_to_dump32(s, begin);\n    phdr.p_paddr = 0;\n    phdr.p_filesz = cpu_to_dump32(s, s->note_size);\n    phdr.p_memsz = cpu_to_dump32(s, s->note_size);\n    phdr.p_vaddr = 0;\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write program header table\");\n    }\n}\n\nstatic void write_elf32_notes(WriteCoreDumpFunction f, DumpState *s,\n                              Error **errp)\n{\n    CPUState *cpu;\n    int ret;\n    int id;\n\n    CPU_FOREACH(cpu) {\n        id = cpu_index(cpu);\n        ret = cpu_write_elf32_note(f, cpu, id, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to write elf notes\");\n            return;\n        }\n    }\n\n    CPU_FOREACH(cpu) {\n        ret = cpu_write_elf32_qemunote(f, cpu, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to write CPU status\");\n            return;\n        }\n    }\n}\n\nstatic void write_elf_section(DumpState *s, int type, Error **errp)\n{\n    Elf32_Shdr shdr32;\n    Elf64_Shdr shdr64;\n    int shdr_size;\n    void *shdr;\n    int ret;\n\n    if (type == 0) {\n        shdr_size = sizeof(Elf32_Shdr);\n        memset(&shdr32, 0, shdr_size);\n        shdr32.sh_info = cpu_to_dump32(s, s->sh_info);\n        shdr = &shdr32;\n    } else {\n        shdr_size = sizeof(Elf64_Shdr);\n        memset(&shdr64, 0, shdr_size);\n        shdr64.sh_info = cpu_to_dump32(s, s->sh_info);\n        shdr = &shdr64;\n    }\n\n    ret = fd_write_vmcore(&shdr, shdr_size, s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write section header table\");\n    }\n}\n\nstatic void write_data(DumpState *s, void *buf, int length, Error **errp)\n{\n    int ret;\n\n    ret = fd_write_vmcore(buf, length, s);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to save memory\");\n    } else {\n        s->written_size += length;\n    }\n}\n\n/* write the memory to vmcore. 1 page per I/O. */\nstatic void write_memory(DumpState *s, GuestPhysBlock *block, ram_addr_t start,\n                         int64_t size, Error **errp)\n{\n    int64_t i;\n    Error *local_err = NULL;\n\n    for (i = 0; i < size / s->dump_info.page_size; i++) {\n        write_data(s, block->host_addr + start + i * s->dump_info.page_size,\n                   s->dump_info.page_size, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n\n    if ((size % s->dump_info.page_size) != 0) {\n        write_data(s, block->host_addr + start + i * s->dump_info.page_size,\n                   size % s->dump_info.page_size, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\n/* get the memory's offset and size in the vmcore */\nstatic void get_offset_range(hwaddr phys_addr,\n                             ram_addr_t mapping_length,\n                             DumpState *s,\n                             hwaddr *p_offset,\n                             hwaddr *p_filesz)\n{\n    GuestPhysBlock *block;\n    hwaddr offset = s->memory_offset;\n    int64_t size_in_block, start;\n\n    /* When the memory is not stored into vmcore, offset will be -1 */\n    *p_offset = -1;\n    *p_filesz = 0;\n\n    if (s->has_filter) {\n        if (phys_addr < s->begin || phys_addr >= s->begin + s->length) {\n            return;\n        }\n    }\n\n    QTAILQ_FOREACH(block, &s->guest_phys_blocks.head, next) {\n        if (s->has_filter) {\n            if (block->target_start >= s->begin + s->length ||\n                block->target_end <= s->begin) {\n                /* This block is out of the range */\n                continue;\n            }\n\n            if (s->begin <= block->target_start) {\n                start = block->target_start;\n            } else {\n                start = s->begin;\n            }\n\n            size_in_block = block->target_end - start;\n            if (s->begin + s->length < block->target_end) {\n                size_in_block -= block->target_end - (s->begin + s->length);\n            }\n        } else {\n            start = block->target_start;\n            size_in_block = block->target_end - block->target_start;\n        }\n\n        if (phys_addr >= start && phys_addr < start + size_in_block) {\n            *p_offset = phys_addr - start + offset;\n\n            /* The offset range mapped from the vmcore file must not spill over\n             * the GuestPhysBlock, clamp it. The rest of the mapping will be\n             * zero-filled in memory at load time; see\n             * <http://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html>.\n             */\n            *p_filesz = phys_addr + mapping_length <= start + size_in_block ?\n                        mapping_length :\n                        size_in_block - (phys_addr - start);\n            return;\n        }\n\n        offset += size_in_block;\n    }\n}\n\nstatic void write_elf_loads(DumpState *s, Error **errp)\n{\n    hwaddr offset, filesz;\n    MemoryMapping *memory_mapping;\n    uint32_t phdr_index = 1;\n    uint32_t max_index;\n    Error *local_err = NULL;\n\n    if (s->have_section) {\n        max_index = s->sh_info;\n    } else {\n        max_index = s->phdr_num;\n    }\n\n    QTAILQ_FOREACH(memory_mapping, &s->list.head, next) {\n        get_offset_range(memory_mapping->phys_addr,\n                         memory_mapping->length,\n                         s, &offset, &filesz);\n        if (s->dump_info.d_class == ELFCLASS64) {\n            write_elf64_load(s, memory_mapping, phdr_index++, offset,\n                             filesz, &local_err);\n        } else {\n            write_elf32_load(s, memory_mapping, phdr_index++, offset,\n                             filesz, &local_err);\n        }\n\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n        if (phdr_index >= max_index) {\n            break;\n        }\n    }\n}\n\n/* write elf header, PT_NOTE and elf note to vmcore. */\nstatic void dump_begin(DumpState *s, Error **errp)\n{\n    Error *local_err = NULL;\n\n    /*\n     * the vmcore's format is:\n     *   --------------\n     *   |  elf header |\n     *   --------------\n     *   |  PT_NOTE    |\n     *   --------------\n     *   |  PT_LOAD    |\n     *   --------------\n     *   |  ......     |\n     *   --------------\n     *   |  PT_LOAD    |\n     *   --------------\n     *   |  sec_hdr    |\n     *   --------------\n     *   |  elf note   |\n     *   --------------\n     *   |  memory     |\n     *   --------------\n     *\n     * we only know where the memory is saved after we write elf note into\n     * vmcore.\n     */\n\n    /* write elf header to vmcore */\n    if (s->dump_info.d_class == ELFCLASS64) {\n        write_elf64_header(s, &local_err);\n    } else {\n        write_elf32_header(s, &local_err);\n    }\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    if (s->dump_info.d_class == ELFCLASS64) {\n        /* write PT_NOTE to vmcore */\n        write_elf64_note(s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n        /* write all PT_LOAD to vmcore */\n        write_elf_loads(s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n        /* write section to vmcore */\n        if (s->have_section) {\n            write_elf_section(s, 1, &local_err);\n            if (local_err) {\n                error_propagate(errp, local_err);\n                return;\n            }\n        }\n\n        /* write notes to vmcore */\n        write_elf64_notes(fd_write_vmcore, s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    } else {\n        /* write PT_NOTE to vmcore */\n        write_elf32_note(s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n        /* write all PT_LOAD to vmcore */\n        write_elf_loads(s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n        /* write section to vmcore */\n        if (s->have_section) {\n            write_elf_section(s, 0, &local_err);\n            if (local_err) {\n                error_propagate(errp, local_err);\n                return;\n            }\n        }\n\n        /* write notes to vmcore */\n        write_elf32_notes(fd_write_vmcore, s, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nstatic int get_next_block(DumpState *s, GuestPhysBlock *block)\n{\n    while (1) {\n        block = QTAILQ_NEXT(block, next);\n        if (!block) {\n            /* no more block */\n            return 1;\n        }\n\n        s->start = 0;\n        s->next_block = block;\n        if (s->has_filter) {\n            if (block->target_start >= s->begin + s->length ||\n                block->target_end <= s->begin) {\n                /* This block is out of the range */\n                continue;\n            }\n\n            if (s->begin > block->target_start) {\n                s->start = s->begin - block->target_start;\n            }\n        }\n\n        return 0;\n    }\n}\n\n/* write all memory to vmcore */\nstatic void dump_iterate(DumpState *s, Error **errp)\n{\n    GuestPhysBlock *block;\n    int64_t size;\n    Error *local_err = NULL;\n\n    do {\n        block = s->next_block;\n\n        size = block->target_end - block->target_start;\n        if (s->has_filter) {\n            size -= s->start;\n            if (s->begin + s->length < block->target_end) {\n                size -= block->target_end - (s->begin + s->length);\n            }\n        }\n        write_memory(s, block, s->start, size, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n\n    } while (!get_next_block(s, block));\n}\n\nstatic void create_vmcore(DumpState *s, Error **errp)\n{\n    Error *local_err = NULL;\n\n    dump_begin(s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    dump_iterate(s, errp);\n}\n\nstatic int write_start_flat_header(int fd)\n{\n    MakedumpfileHeader *mh;\n    int ret = 0;\n\n    QEMU_BUILD_BUG_ON(sizeof *mh > MAX_SIZE_MDF_HEADER);\n    mh = g_malloc0(MAX_SIZE_MDF_HEADER);\n\n    memcpy(mh->signature, MAKEDUMPFILE_SIGNATURE,\n           MIN(sizeof mh->signature, sizeof MAKEDUMPFILE_SIGNATURE));\n\n    mh->type = cpu_to_be64(TYPE_FLAT_HEADER);\n    mh->version = cpu_to_be64(VERSION_FLAT_HEADER);\n\n    size_t written_size;\n    written_size = qemu_write_full(fd, mh, MAX_SIZE_MDF_HEADER);\n    if (written_size != MAX_SIZE_MDF_HEADER) {\n        ret = -1;\n    }\n\n    g_free(mh);\n    return ret;\n}\n\nstatic int write_end_flat_header(int fd)\n{\n    MakedumpfileDataHeader mdh;\n\n    mdh.offset = END_FLAG_FLAT_HEADER;\n    mdh.buf_size = END_FLAG_FLAT_HEADER;\n\n    size_t written_size;\n    written_size = qemu_write_full(fd, &mdh, sizeof(mdh));\n    if (written_size != sizeof(mdh)) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int write_buffer(int fd, off_t offset, const void *buf, size_t size)\n{\n    size_t written_size;\n    MakedumpfileDataHeader mdh;\n\n    mdh.offset = cpu_to_be64(offset);\n    mdh.buf_size = cpu_to_be64(size);\n\n    written_size = qemu_write_full(fd, &mdh, sizeof(mdh));\n    if (written_size != sizeof(mdh)) {\n        return -1;\n    }\n\n    written_size = qemu_write_full(fd, buf, size);\n    if (written_size != size) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int buf_write_note(const void *buf, size_t size, void *opaque)\n{\n    DumpState *s = opaque;\n\n    /* note_buf is not enough */\n    if (s->note_buf_offset + size > s->note_size) {\n        return -1;\n    }\n\n    memcpy(s->note_buf + s->note_buf_offset, buf, size);\n\n    s->note_buf_offset += size;\n\n    return 0;\n}\n\n/* write common header, sub header and elf note to vmcore */\nstatic void create_header32(DumpState *s, Error **errp)\n{\n    DiskDumpHeader32 *dh = NULL;\n    KdumpSubHeader32 *kh = NULL;\n    size_t size;\n    uint32_t block_size;\n    uint32_t sub_hdr_size;\n    uint32_t bitmap_blocks;\n    uint32_t status = 0;\n    uint64_t offset_note;\n    Error *local_err = NULL;\n\n    /* write common header, the version of kdump-compressed format is 6th */\n    size = sizeof(DiskDumpHeader32);\n    dh = g_malloc0(size);\n\n    memcpy(dh->signature, KDUMP_SIGNATURE, SIG_LEN);\n    dh->header_version = cpu_to_dump32(s, 6);\n    block_size = s->dump_info.page_size;\n    dh->block_size = cpu_to_dump32(s, block_size);\n    sub_hdr_size = sizeof(struct KdumpSubHeader32) + s->note_size;\n    sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size);\n    dh->sub_hdr_size = cpu_to_dump32(s, sub_hdr_size);\n    /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */\n    dh->max_mapnr = cpu_to_dump32(s, MIN(s->max_mapnr, UINT_MAX));\n    dh->nr_cpus = cpu_to_dump32(s, s->nr_cpus);\n    bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2;\n    dh->bitmap_blocks = cpu_to_dump32(s, bitmap_blocks);\n    strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n\n    if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) {\n        status |= DUMP_DH_COMPRESSED_ZLIB;\n    }\n#ifdef CONFIG_LZO\n    if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) {\n        status |= DUMP_DH_COMPRESSED_LZO;\n    }\n#endif\n#ifdef CONFIG_SNAPPY\n    if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) {\n        status |= DUMP_DH_COMPRESSED_SNAPPY;\n    }\n#endif\n    dh->status = cpu_to_dump32(s, status);\n\n    if (write_buffer(s->fd, 0, dh, size) < 0) {\n        error_setg(errp, \"dump: failed to write disk dump header\");\n        goto out;\n    }\n\n    /* write sub header */\n    size = sizeof(KdumpSubHeader32);\n    kh = g_malloc0(size);\n\n    /* 64bit max_mapnr_64 */\n    kh->max_mapnr_64 = cpu_to_dump64(s, s->max_mapnr);\n    kh->phys_base = cpu_to_dump32(s, s->dump_info.phys_base);\n    kh->dump_level = cpu_to_dump32(s, DUMP_LEVEL);\n\n    offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size;\n    kh->offset_note = cpu_to_dump64(s, offset_note);\n    kh->note_size = cpu_to_dump32(s, s->note_size);\n\n    if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS *\n                     block_size, kh, size) < 0) {\n        error_setg(errp, \"dump: failed to write kdump sub header\");\n        goto out;\n    }\n\n    /* write note */\n    s->note_buf = g_malloc0(s->note_size);\n    s->note_buf_offset = 0;\n\n    /* use s->note_buf to store notes temporarily */\n    write_elf32_notes(buf_write_note, s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n    if (write_buffer(s->fd, offset_note, s->note_buf,\n                     s->note_size) < 0) {\n        error_setg(errp, \"dump: failed to write notes\");\n        goto out;\n    }\n\n    /* get offset of dump_bitmap */\n    s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) *\n                             block_size;\n\n    /* get offset of page */\n    s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) *\n                     block_size;\n\nout:\n    g_free(dh);\n    g_free(kh);\n    g_free(s->note_buf);\n}\n\n/* write common header, sub header and elf note to vmcore */\nstatic void create_header64(DumpState *s, Error **errp)\n{\n    DiskDumpHeader64 *dh = NULL;\n    KdumpSubHeader64 *kh = NULL;\n    size_t size;\n    uint32_t block_size;\n    uint32_t sub_hdr_size;\n    uint32_t bitmap_blocks;\n    uint32_t status = 0;\n    uint64_t offset_note;\n    Error *local_err = NULL;\n\n    /* write common header, the version of kdump-compressed format is 6th */\n    size = sizeof(DiskDumpHeader64);\n    dh = g_malloc0(size);\n\n    memcpy(dh->signature, KDUMP_SIGNATURE, SIG_LEN);\n    dh->header_version = cpu_to_dump32(s, 6);\n    block_size = s->dump_info.page_size;\n    dh->block_size = cpu_to_dump32(s, block_size);\n    sub_hdr_size = sizeof(struct KdumpSubHeader64) + s->note_size;\n    sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size);\n    dh->sub_hdr_size = cpu_to_dump32(s, sub_hdr_size);\n    /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */\n    dh->max_mapnr = cpu_to_dump32(s, MIN(s->max_mapnr, UINT_MAX));\n    dh->nr_cpus = cpu_to_dump32(s, s->nr_cpus);\n    bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2;\n    dh->bitmap_blocks = cpu_to_dump32(s, bitmap_blocks);\n    strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n\n    if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) {\n        status |= DUMP_DH_COMPRESSED_ZLIB;\n    }\n#ifdef CONFIG_LZO\n    if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) {\n        status |= DUMP_DH_COMPRESSED_LZO;\n    }\n#endif\n#ifdef CONFIG_SNAPPY\n    if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) {\n        status |= DUMP_DH_COMPRESSED_SNAPPY;\n    }\n#endif\n    dh->status = cpu_to_dump32(s, status);\n\n    if (write_buffer(s->fd, 0, dh, size) < 0) {\n        error_setg(errp, \"dump: failed to write disk dump header\");\n        goto out;\n    }\n\n    /* write sub header */\n    size = sizeof(KdumpSubHeader64);\n    kh = g_malloc0(size);\n\n    /* 64bit max_mapnr_64 */\n    kh->max_mapnr_64 = cpu_to_dump64(s, s->max_mapnr);\n    kh->phys_base = cpu_to_dump64(s, s->dump_info.phys_base);\n    kh->dump_level = cpu_to_dump32(s, DUMP_LEVEL);\n\n    offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size;\n    kh->offset_note = cpu_to_dump64(s, offset_note);\n    kh->note_size = cpu_to_dump64(s, s->note_size);\n\n    if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS *\n                     block_size, kh, size) < 0) {\n        error_setg(errp, \"dump: failed to write kdump sub header\");\n        goto out;\n    }\n\n    /* write note */\n    s->note_buf = g_malloc0(s->note_size);\n    s->note_buf_offset = 0;\n\n    /* use s->note_buf to store notes temporarily */\n    write_elf64_notes(buf_write_note, s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    if (write_buffer(s->fd, offset_note, s->note_buf,\n                     s->note_size) < 0) {\n        error_setg(errp, \"dump: failed to write notes\");\n        goto out;\n    }\n\n    /* get offset of dump_bitmap */\n    s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) *\n                             block_size;\n\n    /* get offset of page */\n    s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) *\n                     block_size;\n\nout:\n    g_free(dh);\n    g_free(kh);\n    g_free(s->note_buf);\n}\n\nstatic void write_dump_header(DumpState *s, Error **errp)\n{\n     Error *local_err = NULL;\n\n    if (s->dump_info.d_class == ELFCLASS32) {\n        create_header32(s, &local_err);\n    } else {\n        create_header64(s, &local_err);\n    }\n    error_propagate(errp, local_err);\n}\n\nstatic size_t dump_bitmap_get_bufsize(DumpState *s)\n{\n    return s->dump_info.page_size;\n}\n\n/*\n * set dump_bitmap sequencely. the bit before last_pfn is not allowed to be\n * rewritten, so if need to set the first bit, set last_pfn and pfn to 0.\n * set_dump_bitmap will always leave the recently set bit un-sync. And setting\n * (last bit + sizeof(buf) * 8) to 0 will do flushing the content in buf into\n * vmcore, ie. synchronizing un-sync bit into vmcore.\n */\nstatic int set_dump_bitmap(uint64_t last_pfn, uint64_t pfn, bool value,\n                           uint8_t *buf, DumpState *s)\n{\n    off_t old_offset, new_offset;\n    off_t offset_bitmap1, offset_bitmap2;\n    uint32_t byte, bit;\n    size_t bitmap_bufsize = dump_bitmap_get_bufsize(s);\n    size_t bits_per_buf = bitmap_bufsize * CHAR_BIT;\n\n    /* should not set the previous place */\n    assert(last_pfn <= pfn);\n\n    /*\n     * if the bit needed to be set is not cached in buf, flush the data in buf\n     * to vmcore firstly.\n     * making new_offset be bigger than old_offset can also sync remained data\n     * into vmcore.\n     */\n    old_offset = bitmap_bufsize * (last_pfn / bits_per_buf);\n    new_offset = bitmap_bufsize * (pfn / bits_per_buf);\n\n    while (old_offset < new_offset) {\n        /* calculate the offset and write dump_bitmap */\n        offset_bitmap1 = s->offset_dump_bitmap + old_offset;\n        if (write_buffer(s->fd, offset_bitmap1, buf,\n                         bitmap_bufsize) < 0) {\n            return -1;\n        }\n\n        /* dump level 1 is chosen, so 1st and 2nd bitmap are same */\n        offset_bitmap2 = s->offset_dump_bitmap + s->len_dump_bitmap +\n                         old_offset;\n        if (write_buffer(s->fd, offset_bitmap2, buf,\n                         bitmap_bufsize) < 0) {\n            return -1;\n        }\n\n        memset(buf, 0, bitmap_bufsize);\n        old_offset += bitmap_bufsize;\n    }\n\n    /* get the exact place of the bit in the buf, and set it */\n    byte = (pfn % bits_per_buf) / CHAR_BIT;\n    bit = (pfn % bits_per_buf) % CHAR_BIT;\n    if (value) {\n        buf[byte] |= 1u << bit;\n    } else {\n        buf[byte] &= ~(1u << bit);\n    }\n\n    return 0;\n}\n\nstatic uint64_t dump_paddr_to_pfn(DumpState *s, uint64_t addr)\n{\n    int target_page_shift = ctz32(s->dump_info.page_size);\n\n    return (addr >> target_page_shift) - ARCH_PFN_OFFSET;\n}\n\nstatic uint64_t dump_pfn_to_paddr(DumpState *s, uint64_t pfn)\n{\n    int target_page_shift = ctz32(s->dump_info.page_size);\n\n    return (pfn + ARCH_PFN_OFFSET) << target_page_shift;\n}\n\n/*\n * exam every page and return the page frame number and the address of the page.\n * bufptr can be NULL. note: the blocks here is supposed to reflect guest-phys\n * blocks, so block->target_start and block->target_end should be interal\n * multiples of the target page size.\n */\nstatic bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n                          uint8_t **bufptr, DumpState *s)\n{\n    GuestPhysBlock *block = *blockptr;\n    hwaddr addr, target_page_mask = ~((hwaddr)s->dump_info.page_size - 1);\n    uint8_t *buf;\n\n    /* block == NULL means the start of the iteration */\n    if (!block) {\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n        *blockptr = block;\n        assert((block->target_start & ~target_page_mask) == 0);\n        assert((block->target_end & ~target_page_mask) == 0);\n        *pfnptr = dump_paddr_to_pfn(s, block->target_start);\n        if (bufptr) {\n            *bufptr = block->host_addr;\n        }\n        return true;\n    }\n\n    *pfnptr = *pfnptr + 1;\n    addr = dump_pfn_to_paddr(s, *pfnptr);\n\n    if ((addr >= block->target_start) &&\n        (addr + s->dump_info.page_size <= block->target_end)) {\n        buf = block->host_addr + (addr - block->target_start);\n    } else {\n        /* the next page is in the next block */\n        block = QTAILQ_NEXT(block, next);\n        *blockptr = block;\n        if (!block) {\n            return false;\n        }\n        assert((block->target_start & ~target_page_mask) == 0);\n        assert((block->target_end & ~target_page_mask) == 0);\n        *pfnptr = dump_paddr_to_pfn(s, block->target_start);\n        buf = block->host_addr;\n    }\n\n    if (bufptr) {\n        *bufptr = buf;\n    }\n\n    return true;\n}\n\nstatic void write_dump_bitmap(DumpState *s, Error **errp)\n{\n    int ret = 0;\n    uint64_t last_pfn, pfn;\n    void *dump_bitmap_buf;\n    size_t num_dumpable;\n    GuestPhysBlock *block_iter = NULL;\n    size_t bitmap_bufsize = dump_bitmap_get_bufsize(s);\n    size_t bits_per_buf = bitmap_bufsize * CHAR_BIT;\n\n    /* dump_bitmap_buf is used to store dump_bitmap temporarily */\n    dump_bitmap_buf = g_malloc0(bitmap_bufsize);\n\n    num_dumpable = 0;\n    last_pfn = 0;\n\n    /*\n     * exam memory page by page, and set the bit in dump_bitmap corresponded\n     * to the existing page.\n     */\n    while (get_next_page(&block_iter, &pfn, NULL, s)) {\n        ret = set_dump_bitmap(last_pfn, pfn, true, dump_bitmap_buf, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to set dump_bitmap\");\n            goto out;\n        }\n\n        last_pfn = pfn;\n        num_dumpable++;\n    }\n\n    /*\n     * set_dump_bitmap will always leave the recently set bit un-sync. Here we\n     * set the remaining bits from last_pfn to the end of the bitmap buffer to\n     * 0. With those set, the un-sync bit will be synchronized into the vmcore.\n     */\n    if (num_dumpable > 0) {\n        ret = set_dump_bitmap(last_pfn, last_pfn + bits_per_buf, false,\n                              dump_bitmap_buf, s);\n        if (ret < 0) {\n            error_setg(errp, \"dump: failed to sync dump_bitmap\");\n            goto out;\n        }\n    }\n\n    /* number of dumpable pages that will be dumped later */\n    s->num_dumpable = num_dumpable;\n\nout:\n    g_free(dump_bitmap_buf);\n}\n\nstatic void prepare_data_cache(DataCache *data_cache, DumpState *s,\n                               off_t offset)\n{\n    data_cache->fd = s->fd;\n    data_cache->data_size = 0;\n    data_cache->buf_size = 4 * dump_bitmap_get_bufsize(s);\n    data_cache->buf = g_malloc0(data_cache->buf_size);\n    data_cache->offset = offset;\n}\n\nstatic int write_cache(DataCache *dc, const void *buf, size_t size,\n                       bool flag_sync)\n{\n    /*\n     * dc->buf_size should not be less than size, otherwise dc will never be\n     * enough\n     */\n    assert(size <= dc->buf_size);\n\n    /*\n     * if flag_sync is set, synchronize data in dc->buf into vmcore.\n     * otherwise check if the space is enough for caching data in buf, if not,\n     * write the data in dc->buf to dc->fd and reset dc->buf\n     */\n    if ((!flag_sync && dc->data_size + size > dc->buf_size) ||\n        (flag_sync && dc->data_size > 0)) {\n        if (write_buffer(dc->fd, dc->offset, dc->buf, dc->data_size) < 0) {\n            return -1;\n        }\n\n        dc->offset += dc->data_size;\n        dc->data_size = 0;\n    }\n\n    if (!flag_sync) {\n        memcpy(dc->buf + dc->data_size, buf, size);\n        dc->data_size += size;\n    }\n\n    return 0;\n}\n\nstatic void free_data_cache(DataCache *data_cache)\n{\n    g_free(data_cache->buf);\n}\n\nstatic size_t get_len_buf_out(size_t page_size, uint32_t flag_compress)\n{\n    switch (flag_compress) {\n    case DUMP_DH_COMPRESSED_ZLIB:\n        return compressBound(page_size);\n\n    case DUMP_DH_COMPRESSED_LZO:\n        /*\n         * LZO will expand incompressible data by a little amount. Please check\n         * the following URL to see the expansion calculation:\n         * http://www.oberhumer.com/opensource/lzo/lzofaq.php\n         */\n        return page_size + page_size / 16 + 64 + 3;\n\n#ifdef CONFIG_SNAPPY\n    case DUMP_DH_COMPRESSED_SNAPPY:\n        return snappy_max_compressed_length(page_size);\n#endif\n    }\n    return 0;\n}\n\n/*\n * check if the page is all 0\n */\nstatic inline bool is_zero_page(const uint8_t *buf, size_t page_size)\n{\n    return buffer_is_zero(buf, page_size);\n}\n\nstatic void write_dump_pages(DumpState *s, Error **errp)\n{\n    int ret = 0;\n    DataCache page_desc, page_data;\n    size_t len_buf_out, size_out;\n#ifdef CONFIG_LZO\n    lzo_bytep wrkmem = NULL;\n#endif\n    uint8_t *buf_out = NULL;\n    off_t offset_desc, offset_data;\n    PageDescriptor pd, pd_zero;\n    uint8_t *buf;\n    GuestPhysBlock *block_iter = NULL;\n    uint64_t pfn_iter;\n\n    /* get offset of page_desc and page_data in dump file */\n    offset_desc = s->offset_page;\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n    prepare_data_cache(&page_data, s, offset_data);\n\n    /* prepare buffer to store compressed data */\n    len_buf_out = get_len_buf_out(s->dump_info.page_size, s->flag_compress);\n    assert(len_buf_out != 0);\n\n#ifdef CONFIG_LZO\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n#endif\n\n    buf_out = g_malloc(len_buf_out);\n\n    /*\n     * init zero page's page_desc and page_data, because every zero page\n     * uses the same page_data\n     */\n    pd_zero.size = cpu_to_dump32(s, s->dump_info.page_size);\n    pd_zero.flags = cpu_to_dump32(s, 0);\n    pd_zero.offset = cpu_to_dump64(s, offset_data);\n    pd_zero.page_flags = cpu_to_dump64(s, 0);\n    buf = g_malloc0(s->dump_info.page_size);\n    ret = write_cache(&page_data, buf, s->dump_info.page_size, false);\n    g_free(buf);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write page data (zero page)\");\n        goto out;\n    }\n\n    offset_data += s->dump_info.page_size;\n\n    /*\n     * dump memory to vmcore page by page. zero page will all be resided in the\n     * first page of page section\n     */\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n        /* check zero page */\n        if (is_zero_page(buf, s->dump_info.page_size)) {\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n                              false);\n            if (ret < 0) {\n                error_setg(errp, \"dump: failed to write page desc\");\n                goto out;\n            }\n        } else {\n            /*\n             * not zero page, then:\n             * 1. compress the page\n             * 2. write the compressed page into the cache of page_data\n             * 3. get page desc of the compressed page and write it into the\n             *    cache of page_desc\n             *\n             * only one compression format will be used here, for\n             * s->flag_compress is set. But when compression fails to work,\n             * we fall back to save in plaintext.\n             */\n             size_out = len_buf_out;\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n                    (compress2(buf_out, (uLongf *)&size_out, buf,\n                               s->dump_info.page_size, Z_BEST_SPEED) == Z_OK) &&\n                    (size_out < s->dump_info.page_size)) {\n                pd.flags = cpu_to_dump32(s, DUMP_DH_COMPRESSED_ZLIB);\n                pd.size  = cpu_to_dump32(s, size_out);\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n                if (ret < 0) {\n                    error_setg(errp, \"dump: failed to write page data\");\n                    goto out;\n                }\n#ifdef CONFIG_LZO\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n                    (lzo1x_1_compress(buf, s->dump_info.page_size, buf_out,\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n                    (size_out < s->dump_info.page_size)) {\n                pd.flags = cpu_to_dump32(s, DUMP_DH_COMPRESSED_LZO);\n                pd.size  = cpu_to_dump32(s, size_out);\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n                if (ret < 0) {\n                    error_setg(errp, \"dump: failed to write page data\");\n                    goto out;\n                }\n#endif\n#ifdef CONFIG_SNAPPY\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n                    (snappy_compress((char *)buf, s->dump_info.page_size,\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n                    (size_out < s->dump_info.page_size)) {\n                pd.flags = cpu_to_dump32(s, DUMP_DH_COMPRESSED_SNAPPY);\n                pd.size  = cpu_to_dump32(s, size_out);\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n                if (ret < 0) {\n                    error_setg(errp, \"dump: failed to write page data\");\n                    goto out;\n                }\n#endif\n            } else {\n                /*\n                 * fall back to save in plaintext, size_out should be\n                 * assigned the target's page size\n                 */\n                pd.flags = cpu_to_dump32(s, 0);\n                size_out = s->dump_info.page_size;\n                pd.size = cpu_to_dump32(s, size_out);\n\n                ret = write_cache(&page_data, buf,\n                                  s->dump_info.page_size, false);\n                if (ret < 0) {\n                    error_setg(errp, \"dump: failed to write page data\");\n                    goto out;\n                }\n            }\n\n            /* get and write page desc here */\n            pd.page_flags = cpu_to_dump64(s, 0);\n            pd.offset = cpu_to_dump64(s, offset_data);\n            offset_data += size_out;\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n            if (ret < 0) {\n                error_setg(errp, \"dump: failed to write page desc\");\n                goto out;\n            }\n        }\n        s->written_size += s->dump_info.page_size;\n    }\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to sync cache for page_desc\");\n        goto out;\n    }\n    ret = write_cache(&page_data, NULL, 0, true);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to sync cache for page_data\");\n        goto out;\n    }\n\nout:\n    free_data_cache(&page_desc);\n    free_data_cache(&page_data);\n\n#ifdef CONFIG_LZO\n    g_free(wrkmem);\n#endif\n\n    g_free(buf_out);\n}\n\nstatic void create_kdump_vmcore(DumpState *s, Error **errp)\n{\n    int ret;\n    Error *local_err = NULL;\n\n    /*\n     * the kdump-compressed format is:\n     *                                               File offset\n     *  +------------------------------------------+ 0x0\n     *  |    main header (struct disk_dump_header) |\n     *  |------------------------------------------+ block 1\n     *  |    sub header (struct kdump_sub_header)  |\n     *  |------------------------------------------+ block 2\n     *  |            1st-dump_bitmap               |\n     *  |------------------------------------------+ block 2 + X blocks\n     *  |            2nd-dump_bitmap               | (aligned by block)\n     *  |------------------------------------------+ block 2 + 2 * X blocks\n     *  |  page desc for pfn 0 (struct page_desc)  | (aligned by block)\n     *  |  page desc for pfn 1 (struct page_desc)  |\n     *  |                    :                     |\n     *  |------------------------------------------| (not aligned by block)\n     *  |         page data (pfn 0)                |\n     *  |         page data (pfn 1)                |\n     *  |                    :                     |\n     *  +------------------------------------------+\n     */\n\n    ret = write_start_flat_header(s->fd);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write start flat header\");\n        return;\n    }\n\n    write_dump_header(s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    write_dump_bitmap(s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    write_dump_pages(s, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    ret = write_end_flat_header(s->fd);\n    if (ret < 0) {\n        error_setg(errp, \"dump: failed to write end flat header\");\n        return;\n    }\n}\n\nstatic ram_addr_t get_start_block(DumpState *s)\n{\n    GuestPhysBlock *block;\n\n    if (!s->has_filter) {\n        s->next_block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n        return 0;\n    }\n\n    QTAILQ_FOREACH(block, &s->guest_phys_blocks.head, next) {\n        if (block->target_start >= s->begin + s->length ||\n            block->target_end <= s->begin) {\n            /* This block is out of the range */\n            continue;\n        }\n\n        s->next_block = block;\n        if (s->begin > block->target_start) {\n            s->start = s->begin - block->target_start;\n        } else {\n            s->start = 0;\n        }\n        return s->start;\n    }\n\n    return -1;\n}\n\nstatic void get_max_mapnr(DumpState *s)\n{\n    GuestPhysBlock *last_block;\n\n    last_block = QTAILQ_LAST(&s->guest_phys_blocks.head, GuestPhysBlockHead);\n    s->max_mapnr = dump_paddr_to_pfn(s, last_block->target_end);\n}\n\nstatic DumpState dump_state_global = { .status = DUMP_STATUS_NONE };\n\nstatic void dump_state_prepare(DumpState *s)\n{\n    /* zero the struct, setting status to active */\n    *s = (DumpState) { .status = DUMP_STATUS_ACTIVE };\n}\n\nbool dump_in_progress(void)\n{\n    DumpState *state = &dump_state_global;\n    return (atomic_read(&state->status) == DUMP_STATUS_ACTIVE);\n}\n\n/* calculate total size of memory to be dumped (taking filter into\n * acoount.) */\nstatic int64_t dump_calculate_size(DumpState *s)\n{\n    GuestPhysBlock *block;\n    int64_t size = 0, total = 0, left = 0, right = 0;\n\n    QTAILQ_FOREACH(block, &s->guest_phys_blocks.head, next) {\n        if (s->has_filter) {\n            /* calculate the overlapped region. */\n            left = MAX(s->begin, block->target_start);\n            right = MIN(s->begin + s->length, block->target_end);\n            size = right - left;\n            size = size > 0 ? size : 0;\n        } else {\n            /* count the whole region in */\n            size = (block->target_end - block->target_start);\n        }\n        total += size;\n    }\n\n    return total;\n}\n\nstatic void dump_init(DumpState *s, int fd, bool has_format,\n                      DumpGuestMemoryFormat format, bool paging, bool has_filter,\n                      int64_t begin, int64_t length, Error **errp)\n{\n    CPUState *cpu;\n    int nr_cpus;\n    Error *err = NULL;\n    int ret;\n\n    s->has_format = has_format;\n    s->format = format;\n    s->written_size = 0;\n\n    /* kdump-compressed is conflict with paging and filter */\n    if (has_format && format != DUMP_GUEST_MEMORY_FORMAT_ELF) {\n        assert(!paging && !has_filter);\n    }\n\n    if (runstate_is_running()) {\n        vm_stop(RUN_STATE_SAVE_VM);\n        s->resume = true;\n    } else {\n        s->resume = false;\n    }\n\n    /* If we use KVM, we should synchronize the registers before we get dump\n     * info or physmap info.\n     */\n    cpu_synchronize_all_states();\n    nr_cpus = 0;\n    CPU_FOREACH(cpu) {\n        nr_cpus++;\n    }\n\n    s->fd = fd;\n    s->has_filter = has_filter;\n    s->begin = begin;\n    s->length = length;\n\n    memory_mapping_list_init(&s->list);\n\n    guest_phys_blocks_init(&s->guest_phys_blocks);\n    guest_phys_blocks_append(&s->guest_phys_blocks);\n    s->total_size = dump_calculate_size(s);\n#ifdef DEBUG_DUMP_GUEST_MEMORY\n    fprintf(stderr, \"DUMP: total memory to dump: %lu\\n\", s->total_size);\n#endif\n\n    s->start = get_start_block(s);\n    if (s->start == -1) {\n        error_setg(errp, QERR_INVALID_PARAMETER, \"begin\");\n        goto cleanup;\n    }\n\n    /* get dump info: endian, class and architecture.\n     * If the target architecture is not supported, cpu_get_dump_info() will\n     * return -1.\n     */\n    ret = cpu_get_dump_info(&s->dump_info, &s->guest_phys_blocks);\n    if (ret < 0) {\n        error_setg(errp, QERR_UNSUPPORTED);\n        goto cleanup;\n    }\n\n    if (!s->dump_info.page_size) {\n        s->dump_info.page_size = TARGET_PAGE_SIZE;\n    }\n\n    s->note_size = cpu_get_note_size(s->dump_info.d_class,\n                                     s->dump_info.d_machine, nr_cpus);\n    if (s->note_size < 0) {\n        error_setg(errp, QERR_UNSUPPORTED);\n        goto cleanup;\n    }\n\n    /* get memory mapping */\n    if (paging) {\n        qemu_get_guest_memory_mapping(&s->list, &s->guest_phys_blocks, &err);\n        if (err != NULL) {\n            error_propagate(errp, err);\n            goto cleanup;\n        }\n    } else {\n        qemu_get_guest_simple_memory_mapping(&s->list, &s->guest_phys_blocks);\n    }\n\n    s->nr_cpus = nr_cpus;\n\n    get_max_mapnr(s);\n\n    uint64_t tmp;\n    tmp = DIV_ROUND_UP(DIV_ROUND_UP(s->max_mapnr, CHAR_BIT),\n                       s->dump_info.page_size);\n    s->len_dump_bitmap = tmp * s->dump_info.page_size;\n\n    /* init for kdump-compressed format */\n    if (has_format && format != DUMP_GUEST_MEMORY_FORMAT_ELF) {\n        switch (format) {\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_ZLIB:\n            s->flag_compress = DUMP_DH_COMPRESSED_ZLIB;\n            break;\n\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_LZO:\n#ifdef CONFIG_LZO\n            if (lzo_init() != LZO_E_OK) {\n                error_setg(errp, \"failed to initialize the LZO library\");\n                goto cleanup;\n            }\n#endif\n            s->flag_compress = DUMP_DH_COMPRESSED_LZO;\n            break;\n\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_SNAPPY:\n            s->flag_compress = DUMP_DH_COMPRESSED_SNAPPY;\n            break;\n\n        default:\n            s->flag_compress = 0;\n        }\n\n        return;\n    }\n\n    if (s->has_filter) {\n        memory_mapping_filter(&s->list, s->begin, s->length);\n    }\n\n    /*\n     * calculate phdr_num\n     *\n     * the type of ehdr->e_phnum is uint16_t, so we should avoid overflow\n     */\n    s->phdr_num = 1; /* PT_NOTE */\n    if (s->list.num < UINT16_MAX - 2) {\n        s->phdr_num += s->list.num;\n        s->have_section = false;\n    } else {\n        s->have_section = true;\n        s->phdr_num = PN_XNUM;\n        s->sh_info = 1; /* PT_NOTE */\n\n        /* the type of shdr->sh_info is uint32_t, so we should avoid overflow */\n        if (s->list.num <= UINT32_MAX - 1) {\n            s->sh_info += s->list.num;\n        } else {\n            s->sh_info = UINT32_MAX;\n        }\n    }\n\n    if (s->dump_info.d_class == ELFCLASS64) {\n        if (s->have_section) {\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n                               sizeof(Elf64_Phdr) * s->sh_info +\n                               sizeof(Elf64_Shdr) + s->note_size;\n        } else {\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n                               sizeof(Elf64_Phdr) * s->phdr_num + s->note_size;\n        }\n    } else {\n        if (s->have_section) {\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n                               sizeof(Elf32_Phdr) * s->sh_info +\n                               sizeof(Elf32_Shdr) + s->note_size;\n        } else {\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n                               sizeof(Elf32_Phdr) * s->phdr_num + s->note_size;\n        }\n    }\n\n    return;\n\ncleanup:\n    dump_cleanup(s);\n}\n\n/* this operation might be time consuming. */\nstatic void dump_process(DumpState *s, Error **errp)\n{\n    Error *local_err = NULL;\n    DumpQueryResult *result = NULL;\n\n    if (s->has_format && s->format != DUMP_GUEST_MEMORY_FORMAT_ELF) {\n        create_kdump_vmcore(s, &local_err);\n    } else {\n        create_vmcore(s, &local_err);\n    }\n\n    /* make sure status is written after written_size updates */\n    smp_wmb();\n    atomic_set(&s->status,\n               (local_err ? DUMP_STATUS_FAILED : DUMP_STATUS_COMPLETED));\n\n    /* send DUMP_COMPLETED message (unconditionally) */\n    result = qmp_query_dump(NULL);\n    /* should never fail */\n    assert(result);\n    qapi_event_send_dump_completed(result, !!local_err, (local_err ? \\\n                                   error_get_pretty(local_err) : NULL),\n                                   &error_abort);\n    qapi_free_DumpQueryResult(result);\n\n    error_propagate(errp, local_err);\n    dump_cleanup(s);\n}\n\nstatic void *dump_thread(void *data)\n{\n    Error *err = NULL;\n    DumpState *s = (DumpState *)data;\n    dump_process(s, &err);\n    error_free(err);\n    return NULL;\n}\n\nDumpQueryResult *qmp_query_dump(Error **errp)\n{\n    DumpQueryResult *result = g_new(DumpQueryResult, 1);\n    DumpState *state = &dump_state_global;\n    result->status = atomic_read(&state->status);\n    /* make sure we are reading status and written_size in order */\n    smp_rmb();\n    result->completed = state->written_size;\n    result->total = state->total_size;\n    return result;\n}\n\nvoid qmp_dump_guest_memory(bool paging, const char *file,\n                           bool has_detach, bool detach,\n                           bool has_begin, int64_t begin, bool has_length,\n                           int64_t length, bool has_format,\n                           DumpGuestMemoryFormat format, Error **errp)\n{\n    const char *p;\n    int fd = -1;\n    DumpState *s;\n    Error *local_err = NULL;\n    bool detach_p = false;\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        error_setg(errp, \"Dump not allowed during incoming migration.\");\n        return;\n    }\n\n    /* if there is a dump in background, we should wait until the dump\n     * finished */\n    if (dump_in_progress()) {\n        error_setg(errp, \"There is a dump in process, please wait.\");\n        return;\n    }\n\n    /*\n     * kdump-compressed format need the whole memory dumped, so paging or\n     * filter is not supported here.\n     */\n    if ((has_format && format != DUMP_GUEST_MEMORY_FORMAT_ELF) &&\n        (paging || has_begin || has_length)) {\n        error_setg(errp, \"kdump-compressed format doesn't support paging or \"\n                         \"filter\");\n        return;\n    }\n    if (has_begin && !has_length) {\n        error_setg(errp, QERR_MISSING_PARAMETER, \"length\");\n        return;\n    }\n    if (!has_begin && has_length) {\n        error_setg(errp, QERR_MISSING_PARAMETER, \"begin\");\n        return;\n    }\n    if (has_detach) {\n        detach_p = detach;\n    }\n\n    /* check whether lzo/snappy is supported */\n#ifndef CONFIG_LZO\n    if (has_format && format == DUMP_GUEST_MEMORY_FORMAT_KDUMP_LZO) {\n        error_setg(errp, \"kdump-lzo is not available now\");\n        return;\n    }\n#endif\n\n#ifndef CONFIG_SNAPPY\n    if (has_format && format == DUMP_GUEST_MEMORY_FORMAT_KDUMP_SNAPPY) {\n        error_setg(errp, \"kdump-snappy is not available now\");\n        return;\n    }\n#endif\n\n#if !defined(WIN32)\n    if (strstart(file, \"fd:\", &p)) {\n        fd = monitor_get_fd(cur_mon, p, errp);\n        if (fd == -1) {\n            return;\n        }\n    }\n#endif\n\n    if  (strstart(file, \"file:\", &p)) {\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n        if (fd < 0) {\n            error_setg_file_open(errp, errno, p);\n            return;\n        }\n    }\n\n    if (fd == -1) {\n        error_setg(errp, QERR_INVALID_PARAMETER, \"protocol\");\n        return;\n    }\n\n    s = &dump_state_global;\n    dump_state_prepare(s);\n\n    dump_init(s, fd, has_format, format, paging, has_begin,\n              begin, length, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        atomic_set(&s->status, DUMP_STATUS_FAILED);\n        return;\n    }\n\n    if (detach_p) {\n        /* detached dump */\n        qemu_thread_create(&s->dump_thread, \"dump_thread\", dump_thread,\n                           s, QEMU_THREAD_DETACHED);\n    } else {\n        /* sync dump */\n        dump_process(s, errp);\n    }\n}\n\nDumpGuestMemoryCapability *qmp_query_dump_guest_memory_capability(Error **errp)\n{\n    DumpGuestMemoryFormatList *item;\n    DumpGuestMemoryCapability *cap =\n                                  g_malloc0(sizeof(DumpGuestMemoryCapability));\n\n    /* elf is always available */\n    item = g_malloc0(sizeof(DumpGuestMemoryFormatList));\n    cap->formats = item;\n    item->value = DUMP_GUEST_MEMORY_FORMAT_ELF;\n\n    /* kdump-zlib is always available */\n    item->next = g_malloc0(sizeof(DumpGuestMemoryFormatList));\n    item = item->next;\n    item->value = DUMP_GUEST_MEMORY_FORMAT_KDUMP_ZLIB;\n\n    /* add new item if kdump-lzo is available */\n#ifdef CONFIG_LZO\n    item->next = g_malloc0(sizeof(DumpGuestMemoryFormatList));\n    item = item->next;\n    item->value = DUMP_GUEST_MEMORY_FORMAT_KDUMP_LZO;\n#endif\n\n    /* add new item if kdump-snappy is available */\n#ifdef CONFIG_SNAPPY\n    item->next = g_malloc0(sizeof(DumpGuestMemoryFormatList));\n    item = item->next;\n    item->value = DUMP_GUEST_MEMORY_FORMAT_KDUMP_SNAPPY;\n#endif\n\n    return cap;\n}\n"
        },
        {
          "name": "exec.c",
          "type": "blob",
          "size": 108.080078125,
          "content": "/*\n *  Virtual page mapping\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#ifndef _WIN32\n#endif\n\n#include \"qemu/cutils.h\"\n#include \"cpu.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg.h\"\n#include \"hw/qdev-core.h\"\n#if !defined(CONFIG_USER_ONLY)\n#include \"hw/boards.h\"\n#include \"hw/xen/xen.h\"\n#endif\n#include \"sysemu/kvm.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/error-report.h\"\n#if defined(CONFIG_USER_ONLY)\n#include \"qemu.h\"\n#else /* !CONFIG_USER_ONLY */\n#include \"hw/hw.h\"\n#include \"exec/memory.h\"\n#include \"exec/ioport.h\"\n#include \"sysemu/dma.h\"\n#include \"sysemu/numa.h\"\n#include \"sysemu/hw_accel.h\"\n#include \"exec/address-spaces.h\"\n#include \"sysemu/xen-mapcache.h\"\n#include \"trace-root.h\"\n\n#include \"panda/rr/rr_log.h\"\n\n#ifdef CONFIG_FALLOCATE_PUNCH_HOLE\n#include <fcntl.h>\n#include <linux/falloc.h>\n#endif\n\n#endif\n#include \"exec/cpu-all.h\"\n#include \"qemu/rcu_queue.h\"\n#include \"qemu/main-loop.h\"\n#include \"translate-all.h\"\n#include \"sysemu/replay.h\"\n\n#include \"exec/memory-internal.h\"\n#include \"exec/ram_addr.h\"\n#include \"exec/log.h\"\n\n#include \"migration/vmstate.h\"\n\n#include \"qemu/range.h\"\n#ifndef _WIN32\n#include \"qemu/mmap-alloc.h\"\n#endif\n\n#include <zlib.h>\n#include \"panda/callbacks/cb-support.h\"\n#include \"panda/checkpoint.h\"\n\n//#define DEBUG_SUBPAGE\n\n#if !defined(CONFIG_USER_ONLY)\n/* ram_list is read under rcu_read_lock()/rcu_read_unlock().  Writes\n * are protected by the ramlist lock.\n */\nRAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };\n\nstatic MemoryRegion *system_memory;\nstatic MemoryRegion *system_io;\n\nAddressSpace address_space_io;\nAddressSpace address_space_memory;\n\nMemoryRegion io_mem_rom, io_mem_notdirty;\nstatic MemoryRegion io_mem_unassigned;\n\n/* RAM is pre-allocated and passed into qemu_ram_alloc_from_ptr */\n#define RAM_PREALLOC   (1 << 0)\n\n/* RAM is mmap-ed with MAP_SHARED */\n#define RAM_SHARED     (1 << 1)\n\n/* Only a portion of RAM (used_length) is actually used, and migrated.\n * This used_length size can change across reboots.\n */\n#define RAM_RESIZEABLE (1 << 2)\n\n#endif\n\n#ifdef TARGET_PAGE_BITS_VARY\nint target_page_bits;\nbool target_page_bits_decided;\n#endif\n\nstruct CPUTailQ cpus = QTAILQ_HEAD_INITIALIZER(cpus);\n/* current CPU in the current thread. It is only valid inside\n   cpu_exec() */\n__thread CPUState *current_cpu;\n/* 0 = Do not count executed instructions.\n   1 = Precise instruction counting.\n   2 = Adaptive rate instruction counting.  */\nint use_icount;\n\nbool set_preferred_target_page_bits(int bits)\n{\n    /* The target page size is the lowest common denominator for all\n     * the CPUs in the system, so we can only make it smaller, never\n     * larger. And we can't make it smaller once we've committed to\n     * a particular size.\n     */\n#ifdef TARGET_PAGE_BITS_VARY\n    assert(bits >= TARGET_PAGE_BITS_MIN);\n    if (target_page_bits == 0 || target_page_bits > bits) {\n        if (target_page_bits_decided) {\n            return false;\n        }\n        target_page_bits = bits;\n    }\n#endif\n    return true;\n}\n\n#if !defined(CONFIG_USER_ONLY)\n\nstatic void finalize_target_page_bits(void)\n{\n#ifdef TARGET_PAGE_BITS_VARY\n    if (target_page_bits == 0) {\n        target_page_bits = TARGET_PAGE_BITS_MIN;\n    }\n    target_page_bits_decided = true;\n#endif\n}\n\ntypedef struct PhysPageEntry PhysPageEntry;\n\nstruct PhysPageEntry {\n    /* How many bits skip to next level (in units of L2_SIZE). 0 for a leaf. */\n    uint32_t skip : 6;\n     /* index into phys_sections (!skip) or phys_map_nodes (skip) */\n    uint32_t ptr : 26;\n};\n\n#define PHYS_MAP_NODE_NIL (((uint32_t)~0) >> 6)\n\n/* Size of the L2 (and L3, etc) page tables.  */\n#define ADDR_SPACE_BITS 64\n\n#define P_L2_BITS 9\n#define P_L2_SIZE (1 << P_L2_BITS)\n\n#define P_L2_LEVELS (((ADDR_SPACE_BITS - TARGET_PAGE_BITS - 1) / P_L2_BITS) + 1)\n\ntypedef PhysPageEntry Node[P_L2_SIZE];\n\ntypedef struct PhysPageMap {\n    struct rcu_head rcu;\n\n    unsigned sections_nb;\n    unsigned sections_nb_alloc;\n    unsigned nodes_nb;\n    unsigned nodes_nb_alloc;\n    Node *nodes;\n    MemoryRegionSection *sections;\n} PhysPageMap;\n\nstruct AddressSpaceDispatch {\n    struct rcu_head rcu;\n\n    MemoryRegionSection *mru_section;\n    /* This is a multi-level map on the physical address space.\n     * The bottom level has pointers to MemoryRegionSections.\n     */\n    PhysPageEntry phys_map;\n    PhysPageMap map;\n    AddressSpace *as;\n};\n\n#define SUBPAGE_IDX(addr) ((addr) & ~TARGET_PAGE_MASK)\ntypedef struct subpage_t {\n    MemoryRegion iomem;\n    AddressSpace *as;\n    hwaddr base;\n    uint16_t sub_section[];\n} subpage_t;\n\n#define PHYS_SECTION_UNASSIGNED 0\n#define PHYS_SECTION_NOTDIRTY 1\n#define PHYS_SECTION_ROM 2\n#define PHYS_SECTION_WATCH 3\n\nstatic void io_mem_init(void);\nstatic void memory_map_init(void);\nstatic void tcg_commit(MemoryListener *listener);\n\nstatic MemoryRegion io_mem_watch;\n\n/**\n * CPUAddressSpace: all the information a CPU needs about an AddressSpace\n * @cpu: the CPU whose AddressSpace this is\n * @as: the AddressSpace itself\n * @memory_dispatch: its dispatch pointer (cached, RCU protected)\n * @tcg_as_listener: listener for tracking changes to the AddressSpace\n */\nstruct CPUAddressSpace {\n    CPUState *cpu;\n    AddressSpace *as;\n    struct AddressSpaceDispatch *memory_dispatch;\n    MemoryListener tcg_as_listener;\n};\n\n#endif\n\n#if !defined(CONFIG_USER_ONLY)\n\nstatic void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)\n{\n    static unsigned alloc_hint = 16;\n    if (map->nodes_nb + nodes > map->nodes_nb_alloc) {\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, alloc_hint);\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);\n        map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);\n        alloc_hint = map->nodes_nb_alloc;\n    }\n}\n\nstatic uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)\n{\n    unsigned i;\n    uint32_t ret;\n    PhysPageEntry e;\n    PhysPageEntry *p;\n\n    ret = map->nodes_nb++;\n    p = map->nodes[ret];\n    assert(ret != PHYS_MAP_NODE_NIL);\n    assert(ret != map->nodes_nb_alloc);\n\n    e.skip = leaf ? 0 : 1;\n    e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;\n    for (i = 0; i < P_L2_SIZE; ++i) {\n        memcpy(&p[i], &e, sizeof(e));\n    }\n    return ret;\n}\n\nstatic void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,\n                                hwaddr *index, hwaddr *nb, uint16_t leaf,\n                                int level)\n{\n    PhysPageEntry *p;\n    hwaddr step = (hwaddr)1 << (level * P_L2_BITS);\n\n    if (lp->skip && lp->ptr == PHYS_MAP_NODE_NIL) {\n        lp->ptr = phys_map_node_alloc(map, level == 0);\n    }\n    p = map->nodes[lp->ptr];\n    lp = &p[(*index >> (level * P_L2_BITS)) & (P_L2_SIZE - 1)];\n\n    while (*nb && lp < &p[P_L2_SIZE]) {\n        if ((*index & (step - 1)) == 0 && *nb >= step) {\n            lp->skip = 0;\n            lp->ptr = leaf;\n            *index += step;\n            *nb -= step;\n        } else {\n            phys_page_set_level(map, lp, index, nb, leaf, level - 1);\n        }\n        ++lp;\n    }\n}\n\nstatic void phys_page_set(AddressSpaceDispatch *d,\n                          hwaddr index, hwaddr nb,\n                          uint16_t leaf)\n{\n    /* Wildly overreserve - it doesn't matter much. */\n    phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);\n\n    phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n}\n\n/* Compact a non leaf page entry. Simply detect that the entry has a single child,\n * and update our entry so we can skip it and go directly to the destination.\n */\nstatic void phys_page_compact(PhysPageEntry *lp, Node *nodes)\n{\n    unsigned valid_ptr = P_L2_SIZE;\n    int valid = 0;\n    PhysPageEntry *p;\n    int i;\n\n    if (lp->ptr == PHYS_MAP_NODE_NIL) {\n        return;\n    }\n\n    p = nodes[lp->ptr];\n    for (i = 0; i < P_L2_SIZE; i++) {\n        if (p[i].ptr == PHYS_MAP_NODE_NIL) {\n            continue;\n        }\n\n        valid_ptr = i;\n        valid++;\n        if (p[i].skip) {\n            phys_page_compact(&p[i], nodes);\n        }\n    }\n\n    /* We can only compress if there's only one child. */\n    if (valid != 1) {\n        return;\n    }\n\n    assert(valid_ptr < P_L2_SIZE);\n\n    /* Don't compress if it won't fit in the # of bits we have. */\n    if (lp->skip + p[valid_ptr].skip >= (1 << 3)) {\n        return;\n    }\n\n    lp->ptr = p[valid_ptr].ptr;\n    if (!p[valid_ptr].skip) {\n        /* If our only child is a leaf, make this a leaf. */\n        /* By design, we should have made this node a leaf to begin with so we\n         * should never reach here.\n         * But since it's so simple to handle this, let's do it just in case we\n         * change this rule.\n         */\n        lp->skip = 0;\n    } else {\n        lp->skip += p[valid_ptr].skip;\n    }\n}\n\nstatic void phys_page_compact_all(AddressSpaceDispatch *d, int nodes_nb)\n{\n    if (d->phys_map.skip) {\n        phys_page_compact(&d->phys_map, d->map.nodes);\n    }\n}\n\nstatic inline bool section_covers_addr(const MemoryRegionSection *section,\n                                       hwaddr addr)\n{\n    /* Memory topology clips a memory region to [0, 2^64); size.hi > 0 means\n     * the section must cover the entire address space.\n     */\n    return int128_gethi(section->size) ||\n           range_covers_byte(section->offset_within_address_space,\n                             int128_getlo(section->size), addr);\n}\n\nstatic MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr addr,\n                                           Node *nodes, MemoryRegionSection *sections)\n{\n    PhysPageEntry *p;\n    hwaddr index = addr >> TARGET_PAGE_BITS;\n    int i;\n\n    for (i = P_L2_LEVELS; lp.skip && (i -= lp.skip) >= 0;) {\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n            return &sections[PHYS_SECTION_UNASSIGNED];\n        }\n        p = nodes[lp.ptr];\n        lp = p[(index >> (i * P_L2_BITS)) & (P_L2_SIZE - 1)];\n    }\n\n    if (section_covers_addr(&sections[lp.ptr], addr)) {\n        return &sections[lp.ptr];\n    } else {\n        return &sections[PHYS_SECTION_UNASSIGNED];\n    }\n}\n\nbool memory_region_is_unassigned(MemoryRegion *mr)\n{\n    return mr != &io_mem_rom && mr != &io_mem_notdirty && !mr->rom_device\n        && mr != &io_mem_watch;\n}\n\n/* Called from RCU critical section */\nstatic MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,\n                                                        hwaddr addr,\n                                                        bool resolve_subpage)\n{\n    MemoryRegionSection *section = atomic_read(&d->mru_section);\n    subpage_t *subpage;\n    bool update;\n\n    if (section && section != &d->map.sections[PHYS_SECTION_UNASSIGNED] &&\n        section_covers_addr(section, addr)) {\n        update = false;\n    } else {\n        section = phys_page_find(d->phys_map, addr, d->map.nodes,\n                                 d->map.sections);\n        update = true;\n    }\n    if (resolve_subpage && section->mr->subpage) {\n        subpage = container_of(section->mr, subpage_t, iomem);\n        section = &d->map.sections[subpage->sub_section[SUBPAGE_IDX(addr)]];\n    }\n    if (update) {\n        atomic_set(&d->mru_section, section);\n    }\n    return section;\n}\n\n/* Called from RCU critical section */\nstatic MemoryRegionSection *\naddress_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    MemoryRegion *mr;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    /* Compute offset within MemoryRegionSection */\n    addr -= section->offset_within_address_space;\n\n    /* Compute offset within MemoryRegion */\n    *xlat = addr + section->offset_within_region;\n\n    mr = section->mr;\n\n    /* MMIO registers can be expected to perform full-width accesses based only\n     * on their address, without considering adjacent registers that could\n     * decode to completely different MemoryRegions.  When such registers\n     * exist (e.g. I/O ports 0xcf8 and 0xcf9 on most PC chipsets), MMIO\n     * regions overlap wildly.  For this reason we cannot clamp the accesses\n     * here.\n     *\n     * If the length is small (as is the case for address_space_ldl/stl),\n     * everything works fine.  If the incoming length is large, however,\n     * the caller really has to do the clamping through memory_access_size.\n     */\n    if (memory_region_is_ram(mr)) {\n        diff = int128_sub(section->size, int128_make64(addr));\n        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    }\n    return section;\n}\n\n/* Called from RCU critical section */\nIOMMUTLBEntry address_space_get_iotlb_entry(AddressSpace *as, hwaddr addr,\n                                            bool is_write)\n{\n    IOMMUTLBEntry iotlb = {0};\n    MemoryRegionSection *section;\n    MemoryRegion *mr;\n\n    for (;;) {\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n        section = address_space_lookup_region(d, addr, false);\n        addr = addr - section->offset_within_address_space\n               + section->offset_within_region;\n        mr = section->mr;\n\n        if (!mr->iommu_ops) {\n            break;\n        }\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n        if (!(iotlb.perm & (1 << is_write))) {\n            iotlb.target_as = NULL;\n            break;\n        }\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        as = iotlb.target_as;\n    }\n\n    return iotlb;\n}\n\n/* Called from RCU critical section */\nMemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n                                      hwaddr *xlat, hwaddr *plen,\n                                      bool is_write)\n{\n    IOMMUTLBEntry iotlb;\n    MemoryRegionSection *section;\n    MemoryRegion *mr;\n\n    for (;;) {\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n        section = address_space_translate_internal(d, addr, &addr, plen, true);\n        mr = section->mr;\n\n        if (!mr->iommu_ops) {\n            break;\n        }\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n        if (!(iotlb.perm & (1 << is_write))) {\n            mr = &io_mem_unassigned;\n            break;\n        }\n\n        as = iotlb.target_as;\n    }\n\n    if (xen_enabled() && memory_access_is_direct(mr, is_write)) {\n        hwaddr page = ((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr;\n        *plen = MIN(page, *plen);\n    }\n\n    *xlat = addr;\n    return mr;\n}\n\n/* Called from RCU critical section */\nMemoryRegionSection *\naddress_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen)\n{\n    MemoryRegionSection *section;\n    AddressSpaceDispatch *d = atomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n\n    section = address_space_translate_internal(d, addr, xlat, plen, false);\n\n    assert(!section->mr->iommu_ops);\n    return section;\n}\n#endif\n\n#if !defined(CONFIG_USER_ONLY)\n\nstatic int cpu_common_post_load(void *opaque, int version_id)\n{\n    CPUState *cpu = opaque;\n\n    /* 0x01 was CPU_INTERRUPT_EXIT. This line can be removed when the\n       version_id is increased. */\n    cpu->interrupt_request &= ~0x01;\n    tlb_flush(cpu);\n\n    return 0;\n}\n\nstatic int cpu_common_pre_load(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    cpu->exception_index = -1;\n\n    return 0;\n}\n\nstatic bool cpu_common_exception_index_needed(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    return tcg_enabled() && cpu->exception_index != -1;\n}\n\nstatic const VMStateDescription vmstate_cpu_common_exception_index = {\n    .name = \"cpu_common/exception_index\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .needed = cpu_common_exception_index_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_INT32(exception_index, CPUState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic bool cpu_common_crash_occurred_needed(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    return cpu->crash_occurred;\n}\n\nstatic const VMStateDescription vmstate_cpu_common_crash_occurred = {\n    .name = \"cpu_common/crash_occurred\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .needed = cpu_common_crash_occurred_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_BOOL(crash_occurred, CPUState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nconst VMStateDescription vmstate_cpu_common = {\n    .name = \"cpu_common\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .pre_load = cpu_common_pre_load,\n    .post_load = cpu_common_post_load,\n    .fields = (VMStateField[]) {\n        VMSTATE_UINT32(halted, CPUState),\n        VMSTATE_UINT32(interrupt_request, CPUState),\n        VMSTATE_END_OF_LIST()\n    },\n    .subsections = (const VMStateDescription*[]) {\n        &vmstate_cpu_common_exception_index,\n        &vmstate_cpu_common_crash_occurred,\n        NULL\n    }\n};\n\n#endif\n\nCPUState *qemu_get_cpu(int index)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu->cpu_index == index) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\n#if !defined(CONFIG_USER_ONLY)\n\nMemoryListener rr_listener;\n\nstatic RR_mem_type rr_mem_region_type(MemoryRegion* mr) {\n    RR_mem_type mtype = RR_MEM_UNKNOWN;\n    if (!(memory_region_is_ram(mr) || memory_region_is_romd(mr))) {\n        mtype = RR_MEM_IO;\n    } else if (memory_region_is_ram(mr)) {\n        mtype = RR_MEM_RAM;\n    }\n    return mtype;\n}\n\nstatic void rr_mem_region_added_cb(MemoryListener *listener, MemoryRegionSection *section) {\n    if (!rr_in_record()) return;\n    RR_mem_type mtype = rr_mem_region_type(section->mr);\n\n    rr_mem_region_change_record(section->offset_within_address_space, int128_get64(section->size),\n                                section->mr->name, mtype, true);\n}\n\nstatic void rr_mem_region_deleted_cb(MemoryListener *listener, MemoryRegionSection *section) {\n    if (!rr_in_record()) return;\n    RR_mem_type mtype = rr_mem_region_type(section->mr);\n    rr_mem_region_change_record(section->offset_within_address_space, int128_get64(section->size),\n                                section->mr->name, mtype, false);\n}\n\nvoid cpu_address_space_init(CPUState *cpu, AddressSpace *as, int asidx)\n{\n    CPUAddressSpace *newas;\n\n    /* Target code should have set num_ases before calling us */\n    assert(asidx < cpu->num_ases);\n\n    if (asidx == 0) {\n        /* address space 0 gets the convenience alias */\n        cpu->as = as;\n    }\n\n    /* KVM cannot currently support multiple address spaces. */\n    assert(asidx == 0 || !kvm_enabled());\n\n    if (!cpu->cpu_ases) {\n        cpu->cpu_ases = g_new0(CPUAddressSpace, cpu->num_ases);\n    }\n\n    newas = &cpu->cpu_ases[asidx];\n    newas->cpu = cpu;\n    newas->as = as;\n    if (tcg_enabled()) {\n        newas->tcg_as_listener.commit = tcg_commit;\n        memory_listener_register(&newas->tcg_as_listener, as);\n\n        // PANDA Record and Replay\n        if (asidx == 0) {\n            rr_listener.region_add = rr_mem_region_added_cb;\n            rr_listener.region_del = rr_mem_region_deleted_cb;\n            memory_listener_register(&rr_listener, as);\n        }\n    }\n}\n\nAddressSpace *cpu_get_address_space(CPUState *cpu, int asidx)\n{\n    /* Return the AddressSpace corresponding to the specified index */\n    return cpu->cpu_ases[asidx].as;\n}\n#endif\n\nvoid cpu_exec_unrealizefn(CPUState *cpu)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    cpu_list_remove(cpu);\n\n    if (cc->vmsd != NULL) {\n        vmstate_unregister(NULL, cc->vmsd, cpu);\n    }\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n        vmstate_unregister(NULL, &vmstate_cpu_common, cpu);\n    }\n}\n\nvoid cpu_exec_initfn(CPUState *cpu)\n{\n    cpu->as = NULL;\n    cpu->num_ases = 0;\n\n#ifndef CONFIG_USER_ONLY\n    cpu->thread_id = qemu_get_thread_id();\n\n    /* This is a softmmu CPU object, so create a property for it\n     * so users can wire up its memory. (This can't go in qom/cpu.c\n     * because that file is compiled only once for both user-mode\n     * and system builds.) The default if no link is set up is to use\n     * the system address space.\n     */\n    object_property_add_link(OBJECT(cpu), \"memory\", TYPE_MEMORY_REGION,\n                             (Object **)&cpu->memory,\n                             qdev_prop_allow_set_link_before_realize,\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n                             &error_abort);\n    cpu->memory = system_memory;\n    object_ref(OBJECT(cpu->memory));\n#endif\n}\n\nvoid cpu_exec_realizefn(CPUState *cpu, Error **errp)\n{\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n    cpu_list_add(cpu);\n\n#ifndef CONFIG_USER_ONLY\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n    }\n    if (cc->vmsd != NULL) {\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n    }\n#endif\n}\n\nstatic void breakpoint_invalidate(CPUState *cpu, target_ulong pc)\n{\n    /* Flush the whole TB as this will not have race conditions\n     * even if we don't have proper locking yet.\n     * Ideally we would just invalidate the TBs for the\n     * specified PC.\n     */\n    tb_flush(cpu);\n}\n\n#if defined(CONFIG_USER_ONLY)\nvoid cpu_watchpoint_remove_all(CPUState *cpu, int mask)\n\n{\n}\n\nint cpu_watchpoint_remove(CPUState *cpu, vaddr addr, vaddr len,\n                          int flags)\n{\n    return -ENOSYS;\n}\n\nvoid cpu_watchpoint_remove_by_ref(CPUState *cpu, CPUWatchpoint *watchpoint)\n{\n}\n\nint cpu_watchpoint_insert(CPUState *cpu, vaddr addr, vaddr len,\n                          int flags, CPUWatchpoint **watchpoint)\n{\n    return -ENOSYS;\n}\n#else\n\n\n/* Add a watchpoint.  */\nint cpu_watchpoint_insert(CPUState *cpu, vaddr addr, vaddr len,\n                          int flags, CPUWatchpoint **watchpoint)\n{\n    CPUWatchpoint *wp;\n\n    /* forbid ranges which are empty or run off the end of the address space */\n    if (len == 0 || (addr + len - 1) < addr) {\n        error_report(\"tried to set invalid watchpoint at %\"\n                     VADDR_PRIx \", len=%\" VADDR_PRIu, addr, len);\n        return -EINVAL;\n    }\n    wp = g_malloc(sizeof(*wp));\n\n    wp->virtaddr = addr;\n    wp->len = len;\n    wp->flags = flags;\n\n    /* keep all GDB-injected watchpoints in front */\n    if (flags & BP_GDB) {\n        QTAILQ_INSERT_HEAD(&cpu->watchpoints, wp, entry);\n    } else {\n        QTAILQ_INSERT_TAIL(&cpu->watchpoints, wp, entry);\n    }\n\n    tlb_flush_page(cpu, addr);\n\n    if (watchpoint)\n        *watchpoint = wp;\n    return 0;\n}\n\n/* Remove a specific watchpoint.  */\nint cpu_watchpoint_remove(CPUState *cpu, vaddr addr, vaddr len,\n                          int flags)\n{\n    CPUWatchpoint *wp;\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n        if (addr == wp->virtaddr && len == wp->len\n                && flags == (wp->flags & ~BP_WATCHPOINT_HIT)) {\n            cpu_watchpoint_remove_by_ref(cpu, wp);\n            return 0;\n        }\n    }\n    return -ENOENT;\n}\n\n/* Remove a specific watchpoint by reference.  */\nvoid cpu_watchpoint_remove_by_ref(CPUState *cpu, CPUWatchpoint *watchpoint)\n{\n    QTAILQ_REMOVE(&cpu->watchpoints, watchpoint, entry);\n\n    tlb_flush_page(cpu, watchpoint->virtaddr);\n\n    g_free(watchpoint);\n}\n\n/* Remove all matching watchpoints.  */\nvoid cpu_watchpoint_remove_all(CPUState *cpu, int mask)\n{\n    CPUWatchpoint *wp, *next;\n\n    QTAILQ_FOREACH_SAFE(wp, &cpu->watchpoints, entry, next) {\n        if (wp->flags & mask) {\n            cpu_watchpoint_remove_by_ref(cpu, wp);\n        }\n    }\n}\n\n/* Return true if this watchpoint address matches the specified\n * access (ie the address range covered by the watchpoint overlaps\n * partially or completely with the address range covered by the\n * access).\n */\nstatic inline bool cpu_watchpoint_address_matches(CPUWatchpoint *wp,\n                                                  vaddr addr,\n                                                  vaddr len)\n{\n    /* We know the lengths are non-zero, but a little caution is\n     * required to avoid errors in the case where the range ends\n     * exactly at the top of the address space and so addr + len\n     * wraps round to zero.\n     */\n    vaddr wpend = wp->virtaddr + wp->len - 1;\n    vaddr addrend = addr + len - 1;\n\n    return !(addr > wpend || wp->virtaddr > addrend);\n}\n\n#endif\n\n/* Add a breakpoint.  */\nint cpu_breakpoint_insert(CPUState *cpu, vaddr pc, int flags,\n                          CPUBreakpoint **breakpoint)\n{\n    CPUBreakpoint *bp;\n\n    bp = g_malloc(sizeof(*bp));\n\n    bp->pc = pc;\n    bp->rr_instr_count = 0;\n    bp->flags = flags;\n\n    /* keep all GDB-injected breakpoints in front */\n    if (flags & BP_GDB) {\n        QTAILQ_INSERT_HEAD(&cpu->breakpoints, bp, entry);\n    } else {\n        QTAILQ_INSERT_TAIL(&cpu->breakpoints, bp, entry);\n    }\n\n    breakpoint_invalidate(cpu, pc);\n\n    if (breakpoint) {\n        *breakpoint = bp;\n    }\n    return 0;\n}\n\nint cpu_rr_breakpoint_insert(CPUState *cpu, uint64_t rr_instr_count, int flags,\n                          CPUBreakpoint **breakpoint)\n{\n    CPUBreakpoint *bp;\n\n    bp = g_malloc(sizeof(*bp));\n\n    bp->pc = 0;\n    bp->rr_instr_count = rr_instr_count;\n    bp->flags = flags;\n\n    /* keep all GDB-injected breakpoints in front */\n    if (flags & BP_GDB) {\n        QTAILQ_INSERT_HEAD(&cpu->breakpoints, bp, entry);\n    } else {\n        QTAILQ_INSERT_TAIL(&cpu->breakpoints, bp, entry);\n    }\n\n    //breakpoint_invalidate(cpu, pc);\n    tb_flush(cpu);\n    \n    printf(\"Inserted bp @ instr count %\" PRIu64 \"\\n\", rr_instr_count);\n\n    if (breakpoint) {\n        *breakpoint = bp;\n    }\n    return 0;\n}\n\n/* Remove a specific breakpoint.  */\nint cpu_breakpoint_remove(CPUState *cpu, vaddr pc, int flags)\n{\n    CPUBreakpoint *bp;\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n        if (bp->pc == pc && bp->flags == flags) {\n            cpu_breakpoint_remove_by_ref(cpu, bp);\n            return 0;\n        }\n    }\n    return -ENOENT;\n}\n\n/* Remove a specific breakpoint by rr instr count.  */\nint cpu_breakpoint_remove_by_instr(CPUState *cpu, uint64_t rr_instr_count, int flags)\n{\n    CPUBreakpoint *bp;\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n        if (bp->rr_instr_count == rr_instr_count && bp->flags == flags) {\n            cpu_breakpoint_remove_by_ref(cpu, bp);\n            return 0;\n        }\n    }\n    return -ENOENT;\n}\n\n/* Remove a specific breakpoint by reference.  */\nvoid cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n{\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n    //breakpoint_invalidate(cpu, breakpoint->pc);\n\n    g_free(breakpoint);\n}\n\n/* Remove all matching breakpoints. */\nvoid cpu_breakpoint_remove_all(CPUState *cpu, int mask)\n{\n    CPUBreakpoint *bp, *next;\n\n    QTAILQ_FOREACH_SAFE(bp, &cpu->breakpoints, entry, next) {\n        if (bp->flags & mask) {\n            cpu_breakpoint_remove_by_ref(cpu, bp);\n        }\n    }\n}\n\n/*\n * rw: Handles reverse-continue logic. Checks whether we are in first or second pass\n * and whether we've finished scanning an entire checkpoint\n */\nvoid cpu_rcont_check_restore(CPUState* cpu, uint64_t rr_instr_count){\n    \n    if (unlikely(cpu->reverse_flags & GDB_RCONT)) {\n        // If we've reached the end of this checkpoint region\n        if (rr_instr_count >= cpu->last_gdb_instr-1) {\n             int closest_num;\n             if ((closest_num = get_closest_checkpoint_num(cpu->last_gdb_instr-1)) < 0) {\n                fprintf(stderr, \"get_closest_checkpoint_num %d\\n\", closest_num); \n                abort();\n             }\n\n            if (cpu->last_bp_hit_instr == 0) {\n                // let's restart from the previous checkpoint\n\n                 if (closest_num == 1) {\n                    // No more checkpoints before this one! Insert bp at beginning\n                    cpu_rr_breakpoint_insert(cpu, 1, BP_GDB, NULL);\n                    cpu->reverse_flags = 0;\n                    panda_restore_by_num(1);\n                 }\n\n                 Checkpoint* prev_checkpoint;\n                 if ((prev_checkpoint = get_checkpoint(closest_num-1)) == NULL) {\n                     fprintf(stderr, \"gen_intmed_code: get_checkpoint fail\\n\");\n                     abort();\n                 }\n\n                 cpu->last_gdb_instr = get_checkpoint(closest_num)->guest_instr_count;\n                 tb_flush(cpu);\n                 tlb_flush(cpu);\n                 panda_restore(prev_checkpoint);\n            } else {\n                // Re-run from checkpoint to latest breakpoint!\n                cpu->reverse_flags = GDB_RCONT_BREAK;\n                panda_restore_by_num(closest_num);\n            }\n        }\n    }\n}\n\n/* enable or disable single step mode. EXCP_DEBUG is returned by the\n   CPU loop after each instruction */\nvoid cpu_single_step(CPUState *cpu, int enabled)\n{\n    if (cpu->singlestep_enabled != enabled) {\n        cpu->singlestep_enabled = enabled;\n        if (kvm_enabled()) {\n            kvm_update_guest_debug(cpu, 0);\n        } else {\n            /* must flush all the translated code to avoid inconsistencies */\n            /* XXX: only flush what is necessary */\n            tb_flush(cpu);\n        }\n    }\n}\n\nvoid cpu_abort(CPUState *cpu, const char *fmt, ...)\n{\n    va_list ap;\n    va_list ap2;\n\n    va_start(ap, fmt);\n    va_copy(ap2, ap);\n    fprintf(stderr, \"qemu: fatal: \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \"\\n\");\n    cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_FPU | CPU_DUMP_CCOP);\n    if (qemu_log_separate()) {\n        qemu_log_lock();\n        qemu_log(\"qemu: fatal: \");\n        qemu_log_vprintf(fmt, ap2);\n        qemu_log(\"\\n\");\n        log_cpu_state(cpu, CPU_DUMP_FPU | CPU_DUMP_CCOP);\n        qemu_log_flush();\n        qemu_log_unlock();\n        qemu_log_close();\n    }\n    va_end(ap2);\n    va_end(ap);\n    replay_finish();\n#if defined(CONFIG_USER_ONLY)\n    {\n        struct sigaction act;\n        sigfillset(&act.sa_mask);\n        act.sa_handler = SIG_DFL;\n        sigaction(SIGABRT, &act, NULL);\n    }\n#endif\n    abort();\n}\n\n#if !defined(CONFIG_USER_ONLY)\n/* Called from RCU critical section */\nstatic RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n{\n    RAMBlock *block;\n\n    block = atomic_rcu_read(&ram_list.mru_block);\n    if (block && addr - block->offset < block->max_length) {\n        return block;\n    }\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        if (addr - block->offset < block->max_length) {\n            goto found;\n        }\n    }\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n    abort();\n\nfound:\n    /* It is safe to write mru_block outside the iothread lock.  This\n     * is what happens:\n     *\n     *     mru_block = xxx\n     *     rcu_read_unlock()\n     *                                        xxx removed from list\n     *                  rcu_read_lock()\n     *                  read mru_block\n     *                                        mru_block = NULL;\n     *                                        call_rcu(reclaim_ramblock, xxx);\n     *                  rcu_read_unlock()\n     *\n     * atomic_rcu_set is not needed here.  The block was already published\n     * when it was placed into the list.  Here we're just making an extra\n     * copy of the pointer.\n     */\n    ram_list.mru_block = block;\n    return block;\n}\n\nstatic void tlb_reset_dirty_range_all(ram_addr_t start, ram_addr_t length)\n{\n    CPUState *cpu;\n    ram_addr_t start1;\n    RAMBlock *block;\n    ram_addr_t end;\n\n    end = TARGET_PAGE_ALIGN(start + length);\n    start &= TARGET_PAGE_MASK;\n\n    rcu_read_lock();\n    block = qemu_get_ram_block(start);\n    assert(block == qemu_get_ram_block(end - 1));\n    start1 = (uintptr_t)ramblock_ptr(block, start - block->offset);\n    CPU_FOREACH(cpu) {\n        tlb_reset_dirty(cpu, start1, length);\n    }\n    rcu_read_unlock();\n}\n\n/* Note: start and end must be within the same ram block.  */\nbool cpu_physical_memory_test_and_clear_dirty(ram_addr_t start,\n                                              ram_addr_t length,\n                                              unsigned client)\n{\n    DirtyMemoryBlocks *blocks;\n    unsigned long end, page;\n    bool dirty = false;\n\n    if (length == 0) {\n        return false;\n    }\n\n    end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;\n    page = start >> TARGET_PAGE_BITS;\n\n    rcu_read_lock();\n\n    blocks = atomic_rcu_read(&ram_list.dirty_memory[client]);\n\n    while (page < end) {\n        unsigned long idx = page / DIRTY_MEMORY_BLOCK_SIZE;\n        unsigned long offset = page % DIRTY_MEMORY_BLOCK_SIZE;\n        unsigned long num = MIN(end - page, DIRTY_MEMORY_BLOCK_SIZE - offset);\n\n        dirty |= bitmap_test_and_clear_atomic(blocks->blocks[idx],\n                                              offset, num);\n        page += num;\n    }\n\n    rcu_read_unlock();\n\n    if (dirty && tcg_enabled()) {\n        tlb_reset_dirty_range_all(start, length);\n    }\n\n    return dirty;\n}\n\n/* Called from RCU critical section */\nhwaddr memory_region_section_get_iotlb(CPUState *cpu,\n                                       MemoryRegionSection *section,\n                                       target_ulong vaddr,\n                                       hwaddr paddr, hwaddr xlat,\n                                       int prot,\n                                       target_ulong *address)\n{\n    hwaddr iotlb;\n    CPUWatchpoint *wp;\n\n    if (memory_region_is_ram(section->mr)) {\n        /* Normal RAM.  */\n        iotlb = memory_region_get_ram_addr(section->mr) + xlat;\n        if (!section->readonly) {\n            iotlb |= PHYS_SECTION_NOTDIRTY;\n        } else {\n            iotlb |= PHYS_SECTION_ROM;\n        }\n    } else {\n        AddressSpaceDispatch *d;\n\n        d = atomic_rcu_read(&section->address_space->dispatch);\n        iotlb = section - d->map.sections;\n        iotlb += xlat;\n    }\n\n    /* Make accesses to pages with watchpoints go via the\n       watchpoint trap routines.  */\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n        if (cpu_watchpoint_address_matches(wp, vaddr, TARGET_PAGE_SIZE)) {\n            /* Avoid trapping reads of pages with a write breakpoint. */\n            if ((prot & PAGE_WRITE) || (wp->flags & BP_MEM_READ)) {\n                iotlb = PHYS_SECTION_WATCH + paddr;\n                *address |= TLB_MMIO;\n                break;\n            }\n        }\n    }\n\n    return iotlb;\n}\n#endif /* defined(CONFIG_USER_ONLY) */\n\n#if !defined(CONFIG_USER_ONLY)\n\nstatic int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,\n                             uint16_t section);\nstatic subpage_t *subpage_init(AddressSpace *as, hwaddr base);\n\nstatic void *(*phys_mem_alloc)(size_t size, uint64_t *align) =\n                               qemu_anon_ram_alloc;\n\n/*\n * Set a custom physical guest memory alloator.\n * Accelerators with unusual needs may need this.  Hopefully, we can\n * get rid of it eventually.\n */\nvoid phys_mem_set_alloc(void *(*alloc)(size_t, uint64_t *align))\n{\n    phys_mem_alloc = alloc;\n}\n\nstatic uint16_t phys_section_add(PhysPageMap *map,\n                                 MemoryRegionSection *section)\n{\n    /* The physical section number is ORed with a page-aligned\n     * pointer to produce the iotlb entries.  Thus it should\n     * never overflow into the page-aligned value.\n     */\n    assert(map->sections_nb < TARGET_PAGE_SIZE);\n\n    if (map->sections_nb == map->sections_nb_alloc) {\n        map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);\n        map->sections = g_renew(MemoryRegionSection, map->sections,\n                                map->sections_nb_alloc);\n    }\n    map->sections[map->sections_nb] = *section;\n    memory_region_ref(section->mr);\n    return map->sections_nb++;\n}\n\nstatic void phys_section_destroy(MemoryRegion *mr)\n{\n    bool have_sub_page = mr->subpage;\n\n    memory_region_unref(mr);\n\n    if (have_sub_page) {\n        subpage_t *subpage = container_of(mr, subpage_t, iomem);\n        object_unref(OBJECT(&subpage->iomem));\n        g_free(subpage);\n    }\n}\n\nstatic void phys_sections_free(PhysPageMap *map)\n{\n    while (map->sections_nb > 0) {\n        MemoryRegionSection *section = &map->sections[--map->sections_nb];\n        phys_section_destroy(section->mr);\n    }\n    g_free(map->sections);\n    g_free(map->nodes);\n}\n\nstatic void register_subpage(AddressSpaceDispatch *d, MemoryRegionSection *section)\n{\n    subpage_t *subpage;\n    hwaddr base = section->offset_within_address_space\n        & TARGET_PAGE_MASK;\n    MemoryRegionSection *existing = phys_page_find(d->phys_map, base,\n                                                   d->map.nodes, d->map.sections);\n    MemoryRegionSection subsection = {\n        .offset_within_address_space = base,\n        .size = int128_make64(TARGET_PAGE_SIZE),\n    };\n    hwaddr start, end;\n\n    assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);\n\n    if (!(existing->mr->subpage)) {\n        subpage = subpage_init(d->as, base);\n        subsection.address_space = d->as;\n        subsection.mr = &subpage->iomem;\n        phys_page_set(d, base >> TARGET_PAGE_BITS, 1,\n                      phys_section_add(&d->map, &subsection));\n    } else {\n        subpage = container_of(existing->mr, subpage_t, iomem);\n    }\n    start = section->offset_within_address_space & ~TARGET_PAGE_MASK;\n    end = start + int128_get64(section->size) - 1;\n    subpage_register(subpage, start, end,\n                     phys_section_add(&d->map, section));\n}\n\n\nstatic void register_multipage(AddressSpaceDispatch *d,\n                               MemoryRegionSection *section)\n{\n    hwaddr start_addr = section->offset_within_address_space;\n    uint16_t section_index = phys_section_add(&d->map, section);\n    uint64_t num_pages = int128_get64(int128_rshift(section->size,\n                                                    TARGET_PAGE_BITS));\n\n    assert(num_pages);\n    phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);\n}\n\nstatic void mem_add(MemoryListener *listener, MemoryRegionSection *section)\n{\n    AddressSpace *as = container_of(listener, AddressSpace, dispatch_listener);\n    AddressSpaceDispatch *d = as->next_dispatch;\n    MemoryRegionSection now = *section, remain = *section;\n    Int128 page_size = int128_make64(TARGET_PAGE_SIZE);\n\n    if (now.offset_within_address_space & ~TARGET_PAGE_MASK) {\n        uint64_t left = TARGET_PAGE_ALIGN(now.offset_within_address_space)\n                       - now.offset_within_address_space;\n\n        now.size = int128_min(int128_make64(left), now.size);\n        register_subpage(d, &now);\n    } else {\n        now.size = int128_zero();\n    }\n    while (int128_ne(remain.size, now.size)) {\n        remain.size = int128_sub(remain.size, now.size);\n        remain.offset_within_address_space += int128_get64(now.size);\n        remain.offset_within_region += int128_get64(now.size);\n        now = remain;\n        if (int128_lt(remain.size, page_size)) {\n            register_subpage(d, &now);\n        } else if (remain.offset_within_address_space & ~TARGET_PAGE_MASK) {\n            now.size = page_size;\n            register_subpage(d, &now);\n        } else {\n            now.size = int128_and(now.size, int128_neg(page_size));\n            register_multipage(d, &now);\n        }\n    }\n}\n\nvoid qemu_flush_coalesced_mmio_buffer(void)\n{\n    if (kvm_enabled())\n        kvm_flush_coalesced_mmio_buffer();\n}\n\nvoid qemu_mutex_lock_ramlist(void)\n{\n    qemu_mutex_lock(&ram_list.mutex);\n}\n\nvoid qemu_mutex_unlock_ramlist(void)\n{\n    qemu_mutex_unlock(&ram_list.mutex);\n}\n\n#ifdef __linux__\n/*\n * FIXME TOCTTOU: this iterates over memory backends' mem-path, which\n * may or may not name the same files / on the same filesystem now as\n * when we actually open and map them.  Iterate over the file\n * descriptors instead, and use qemu_fd_getpagesize().\n */\nstatic int find_max_supported_pagesize(Object *obj, void *opaque)\n{\n    char *mem_path;\n    long *hpsize_min = opaque;\n\n    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {\n        mem_path = object_property_get_str(obj, \"mem-path\", NULL);\n        if (mem_path) {\n            long hpsize = qemu_mempath_getpagesize(mem_path);\n            if (hpsize < *hpsize_min) {\n                *hpsize_min = hpsize;\n            }\n        } else {\n            *hpsize_min = getpagesize();\n        }\n    }\n\n    return 0;\n}\n\nlong qemu_getrampagesize(void)\n{\n    long hpsize = LONG_MAX;\n    long mainrampagesize;\n    Object *memdev_root;\n\n    if (mem_path) {\n        mainrampagesize = qemu_mempath_getpagesize(mem_path);\n    } else {\n        mainrampagesize = getpagesize();\n    }\n\n    /* it's possible we have memory-backend objects with\n     * hugepage-backed RAM. these may get mapped into system\n     * address space via -numa parameters or memory hotplug\n     * hooks. we want to take these into account, but we\n     * also want to make sure these supported hugepage\n     * sizes are applicable across the entire range of memory\n     * we may boot from, so we take the min across all\n     * backends, and assume normal pages in cases where a\n     * backend isn't backed by hugepages.\n     */\n    memdev_root = object_resolve_path(\"/objects\", NULL);\n    if (memdev_root) {\n        object_child_foreach(memdev_root, find_max_supported_pagesize, &hpsize);\n    }\n    if (hpsize == LONG_MAX) {\n        /* No additional memory regions found ==> Report main RAM page size */\n        return mainrampagesize;\n    }\n\n    /* If NUMA is disabled or the NUMA nodes are not backed with a\n     * memory-backend, then there is at least one node using \"normal\" RAM,\n     * so if its page size is smaller we have got to report that size instead.\n     */\n    if (hpsize > mainrampagesize &&\n        (nb_numa_nodes == 0 || numa_info[0].node_memdev == NULL)) {\n        static bool warned;\n        if (!warned) {\n            error_report(\"Huge page support disabled (n/a for main memory).\");\n            warned = true;\n        }\n        return mainrampagesize;\n    }\n\n    return hpsize;\n}\n#else\nlong qemu_getrampagesize(void)\n{\n    return getpagesize();\n}\n#endif\n\n#ifdef __linux__\nstatic int64_t get_file_size(int fd)\n{\n    int64_t size = lseek(fd, 0, SEEK_END);\n    if (size < 0) {\n        return -errno;\n    }\n    return size;\n}\n\nstatic void *file_ram_alloc(RAMBlock *block,\n                            ram_addr_t memory,\n                            const char *path,\n                            Error **errp)\n{\n    bool unlink_on_error = false;\n    char *filename;\n    char *sanitized_name;\n    char *c;\n    void *area = MAP_FAILED;\n    int fd = -1;\n    int64_t file_size;\n\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n        error_setg(errp,\n                   \"host lacks kvm mmu notifiers, -mem-path unsupported\");\n        return NULL;\n    }\n\n    for (;;) {\n        fd = open(path, O_RDWR);\n        if (fd >= 0) {\n            /* @path names an existing file, use it */\n            break;\n        }\n        if (errno == ENOENT) {\n            /* @path names a file that doesn't exist, create it */\n            fd = open(path, O_RDWR | O_CREAT | O_EXCL, 0644);\n            if (fd >= 0) {\n                unlink_on_error = true;\n                break;\n            }\n        } else if (errno == EISDIR) {\n            /* @path names a directory, create a file there */\n            /* Make name safe to use with mkstemp by replacing '/' with '_'. */\n            sanitized_name = g_strdup(memory_region_name(block->mr));\n            for (c = sanitized_name; *c != '\\0'; c++) {\n                if (*c == '/') {\n                    *c = '_';\n                }\n            }\n\n            filename = g_strdup_printf(\"%s/qemu_back_mem.%s.XXXXXX\", path,\n                                       sanitized_name);\n            g_free(sanitized_name);\n\n            fd = mkstemp(filename);\n            if (fd >= 0) {\n                unlink(filename);\n                g_free(filename);\n                break;\n            }\n            g_free(filename);\n        }\n        if (errno != EEXIST && errno != EINTR) {\n            error_setg_errno(errp, errno,\n                             \"can't open backing store %s for guest RAM\",\n                             path);\n            goto error;\n        }\n        /*\n         * Try again on EINTR and EEXIST.  The latter happens when\n         * something else creates the file between our two open().\n         */\n    }\n\n    block->page_size = qemu_fd_getpagesize(fd);\n    block->mr->align = block->page_size;\n#if defined(__s390x__)\n    if (kvm_enabled()) {\n        block->mr->align = MAX(block->mr->align, QEMU_VMALLOC_ALIGN);\n    }\n#endif\n\n    file_size = get_file_size(fd);\n\n    if (memory < block->page_size) {\n        error_setg(errp, \"memory size 0x\" RAM_ADDR_FMT \" must be equal to \"\n                   \"or larger than page size 0x%zx\",\n                   memory, block->page_size);\n        goto error;\n    }\n\n    if (file_size > 0 && file_size < memory) {\n        error_setg(errp, \"backing store %s size 0x%\" PRIx64\n                   \" does not match 'size' option 0x\" RAM_ADDR_FMT,\n                   path, file_size, memory);\n        goto error;\n    }\n\n    memory = ROUND_UP(memory, block->page_size);\n\n    /*\n     * ftruncate is not supported by hugetlbfs in older\n     * hosts, so don't bother bailing out on errors.\n     * If anything goes wrong with it under other filesystems,\n     * mmap will fail.\n     *\n     * Do not truncate the non-empty backend file to avoid corrupting\n     * the existing data in the file. Disabling shrinking is not\n     * enough. For example, the current vNVDIMM implementation stores\n     * the guest NVDIMM labels at the end of the backend file. If the\n     * backend file is later extended, QEMU will not be able to find\n     * those labels. Therefore, extending the non-empty backend file\n     * is disabled as well.\n     */\n    if (!file_size && ftruncate(fd, memory)) {\n        perror(\"ftruncate\");\n    }\n\n    area = qemu_ram_mmap(fd, memory, block->mr->align,\n                         block->flags & RAM_SHARED);\n    if (area == MAP_FAILED) {\n        error_setg_errno(errp, errno,\n                         \"unable to map backing store for guest RAM\");\n        goto error;\n    }\n\n    if (mem_prealloc) {\n        os_mem_prealloc(fd, area, memory, smp_cpus, errp);\n        if (errp && *errp) {\n            goto error;\n        }\n    }\n\n    block->fd = fd;\n    return area;\n\nerror:\n    if (area != MAP_FAILED) {\n        qemu_ram_munmap(area, memory);\n    }\n    if (unlink_on_error) {\n        unlink(path);\n    }\n    if (fd != -1) {\n        close(fd);\n    }\n    return NULL;\n}\n#endif\n\n/* Called with the ramlist lock held.  */\nstatic ram_addr_t find_ram_offset(ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n    if (QLIST_EMPTY_RCU(&ram_list.blocks)) {\n        return 0;\n    }\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n        end = block->offset + block->max_length;\n\n        QLIST_FOREACH_RCU(next_block, &ram_list.blocks, next) {\n            if (next_block->offset >= end) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - end >= size && next - end < mingap) {\n            offset = end;\n            mingap = next - end;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}\n\nram_addr_t last_ram_offset(void)\n{\n    RAMBlock *block;\n    ram_addr_t last = 0;\n\n    rcu_read_lock();\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        last = MAX(last, block->offset + block->max_length);\n    }\n    rcu_read_unlock();\n    return last;\n}\n\nstatic void qemu_ram_setup_dump(void *addr, ram_addr_t size)\n{\n    int ret;\n\n    /* Use MADV_DONTDUMP, if user doesn't want the guest memory in the core */\n    if (!machine_dump_guest_core(current_machine)) {\n        ret = qemu_madvise(addr, size, QEMU_MADV_DONTDUMP);\n        if (ret) {\n            perror(\"qemu_madvise\");\n            fprintf(stderr, \"madvise doesn't support MADV_DONTDUMP, \"\n                            \"but dump_guest_core=off specified\\n\");\n        }\n    }\n}\n\nconst char *qemu_ram_get_idstr(RAMBlock *rb)\n{\n    return rb->idstr;\n}\n\nbool qemu_ram_is_shared(RAMBlock *rb)\n{\n    return rb->flags & RAM_SHARED;\n}\n\n/* Called with iothread lock held.  */\nvoid qemu_ram_set_idstr(RAMBlock *new_block, const char *name, DeviceState *dev)\n{\n    RAMBlock *block;\n\n    assert(new_block);\n    assert(!new_block->idstr[0]);\n\n    if (dev) {\n        char *id = qdev_get_dev_path(dev);\n        if (id) {\n            snprintf(new_block->idstr, sizeof(new_block->idstr), \"%s/\", id);\n            g_free(id);\n        }\n    }\n    pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n\n    rcu_read_lock();\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        if (block != new_block &&\n            !strcmp(block->idstr, new_block->idstr)) {\n            fprintf(stderr, \"RAMBlock \\\"%s\\\" already registered, abort!\\n\",\n                    new_block->idstr);\n            abort();\n        }\n    }\n    rcu_read_unlock();\n}\n\n/* Called with iothread lock held.  */\nvoid qemu_ram_unset_idstr(RAMBlock *block)\n{\n    /* FIXME: arch_init.c assumes that this is not called throughout\n     * migration.  Ignore the problem since hot-unplug during migration\n     * does not work anyway.\n     */\n    if (block) {\n        memset(block->idstr, 0, sizeof(block->idstr));\n    }\n}\n\nsize_t qemu_ram_pagesize(RAMBlock *rb)\n{\n    return rb->page_size;\n}\n\n/* Returns the largest size of page in use */\nsize_t qemu_ram_pagesize_largest(void)\n{\n    RAMBlock *block;\n    size_t largest = 0;\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        largest = MAX(largest, qemu_ram_pagesize(block));\n    }\n\n    return largest;\n}\n\nstatic int memory_try_enable_merging(void *addr, size_t len)\n{\n    if (!machine_mem_merge(current_machine)) {\n        /* disabled by the user */\n        return 0;\n    }\n\n    return qemu_madvise(addr, len, QEMU_MADV_MERGEABLE);\n}\n\n/* Only legal before guest might have detected the memory size: e.g. on\n * incoming migration, or right after reset.\n *\n * As memory core doesn't know how is memory accessed, it is up to\n * resize callback to update device state and/or add assertions to detect\n * misuse, if necessary.\n */\nint qemu_ram_resize(RAMBlock *block, ram_addr_t newsize, Error **errp)\n{\n    assert(block);\n\n    newsize = HOST_PAGE_ALIGN(newsize);\n\n    if (block->used_length == newsize) {\n        return 0;\n    }\n\n    if (!(block->flags & RAM_RESIZEABLE)) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                         \" in != 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->used_length);\n        return -EINVAL;\n    }\n\n    if (block->max_length < newsize) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length too large: %s: 0x\" RAM_ADDR_FMT\n                         \" > 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->max_length);\n        return -EINVAL;\n    }\n\n    cpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\n    block->used_length = newsize;\n    cpu_physical_memory_set_dirty_range(block->offset, block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n    memory_region_set_size(block->mr, newsize);\n    if (block->resized) {\n        block->resized(block->idstr, newsize, block->host);\n    }\n    return 0;\n}\n\n/* Called with ram_list.mutex held */\nstatic void dirty_memory_extend(ram_addr_t old_ram_size,\n                                ram_addr_t new_ram_size)\n{\n    ram_addr_t old_num_blocks = DIV_ROUND_UP(old_ram_size,\n                                             DIRTY_MEMORY_BLOCK_SIZE);\n    ram_addr_t new_num_blocks = DIV_ROUND_UP(new_ram_size,\n                                             DIRTY_MEMORY_BLOCK_SIZE);\n    int i;\n\n    /* Only need to extend if block count increased */\n    if (new_num_blocks <= old_num_blocks) {\n        return;\n    }\n\n    for (i = 0; i < DIRTY_MEMORY_NUM; i++) {\n        DirtyMemoryBlocks *old_blocks;\n        DirtyMemoryBlocks *new_blocks;\n        int j;\n\n        old_blocks = atomic_rcu_read(&ram_list.dirty_memory[i]);\n        new_blocks = g_malloc(sizeof(*new_blocks) +\n                              sizeof(new_blocks->blocks[0]) * new_num_blocks);\n\n        if (old_num_blocks) {\n            memcpy(new_blocks->blocks, old_blocks->blocks,\n                   old_num_blocks * sizeof(old_blocks->blocks[0]));\n        }\n\n        for (j = old_num_blocks; j < new_num_blocks; j++) {\n            new_blocks->blocks[j] = bitmap_new(DIRTY_MEMORY_BLOCK_SIZE);\n        }\n\n        atomic_rcu_set(&ram_list.dirty_memory[i], new_blocks);\n\n        if (old_blocks) {\n            g_free_rcu(old_blocks, rcu);\n        }\n    }\n}\n\nstatic void ram_block_add(RAMBlock *new_block, Error **errp)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    ram_addr_t old_ram_size, new_ram_size;\n    Error *err = NULL;\n\n    old_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;\n\n    qemu_mutex_lock_ramlist();\n    new_block->offset = find_ram_offset(new_block->max_length);\n\n    if (!new_block->host) {\n        if (xen_enabled()) {\n            xen_ram_alloc(new_block->offset, new_block->max_length,\n                          new_block->mr, &err);\n            if (err) {\n                error_propagate(errp, err);\n                qemu_mutex_unlock_ramlist();\n                return;\n            }\n        } else {\n            new_block->host = phys_mem_alloc(new_block->max_length,\n                                             &new_block->mr->align);\n            if (!new_block->host) {\n                error_setg_errno(errp, errno,\n                                 \"cannot set up guest memory '%s'\",\n                                 memory_region_name(new_block->mr));\n                qemu_mutex_unlock_ramlist();\n                return;\n            }\n            memory_try_enable_merging(new_block->host, new_block->max_length);\n        }\n    }\n\n    new_ram_size = MAX(old_ram_size,\n              (new_block->offset + new_block->max_length) >> TARGET_PAGE_BITS);\n    if (new_ram_size > old_ram_size) {\n        migration_bitmap_extend(old_ram_size, new_ram_size);\n        dirty_memory_extend(old_ram_size, new_ram_size);\n    }\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);\n    }\n    ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    smp_wmb();\n    ram_list.version++;\n    qemu_mutex_unlock_ramlist();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n    if (new_block->host) {\n        qemu_ram_setup_dump(new_block->host, new_block->max_length);\n        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_HUGEPAGE);\n        /* MADV_DONTFORK is also needed by KVM in absence of synchronous MMU */\n        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_DONTFORK);\n        ram_block_notify_add(new_block->host, new_block->max_length);\n    }\n}\n\n#ifdef __linux__\nRAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,\n                                   bool share, const char *mem_path,\n                                   Error **errp)\n{\n    RAMBlock *new_block;\n    Error *local_err = NULL;\n\n    if (xen_enabled()) {\n        error_setg(errp, \"-mem-path not supported with Xen\");\n        return NULL;\n    }\n\n    if (phys_mem_alloc != qemu_anon_ram_alloc) {\n        /*\n         * file_ram_alloc() needs to allocate just like\n         * phys_mem_alloc, but we haven't bothered to provide\n         * a hook there.\n         */\n        error_setg(errp,\n                   \"-mem-path not supported with this accelerator\");\n        return NULL;\n    }\n\n    size = HOST_PAGE_ALIGN(size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = size;\n    new_block->flags = share ? RAM_SHARED : 0;\n    new_block->host = file_ram_alloc(new_block, size,\n                                     mem_path, errp);\n    if (!new_block->host) {\n        g_free(new_block);\n        return NULL;\n    }\n\n    ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return NULL;\n    }\n    return new_block;\n}\n#endif\n\nstatic\nRAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n                                  void (*resized)(const char*,\n                                                  uint64_t length,\n                                                  void *host),\n                                  void *host, bool resizeable,\n                                  MemoryRegion *mr, Error **errp)\n{\n    RAMBlock *new_block;\n    Error *local_err = NULL;\n\n    size = HOST_PAGE_ALIGN(size);\n    max_size = HOST_PAGE_ALIGN(max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->resized = resized;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->fd = -1;\n    new_block->page_size = getpagesize();\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    if (resizeable) {\n        new_block->flags |= RAM_RESIZEABLE;\n    }\n    ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return NULL;\n    }\n    return new_block;\n}\n\nRAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n                                   MemoryRegion *mr, Error **errp)\n{\n    return qemu_ram_alloc_internal(size, size, NULL, host, false, mr, errp);\n}\n\nRAMBlock *qemu_ram_alloc(ram_addr_t size, MemoryRegion *mr, Error **errp)\n{\n    return qemu_ram_alloc_internal(size, size, NULL, NULL, false, mr, errp);\n}\n\nRAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,\n                                     void (*resized)(const char*,\n                                                     uint64_t length,\n                                                     void *host),\n                                     MemoryRegion *mr, Error **errp)\n{\n    return qemu_ram_alloc_internal(size, maxsz, resized, NULL, true, mr, errp);\n}\n\nstatic void reclaim_ramblock(RAMBlock *block)\n{\n    if (block->flags & RAM_PREALLOC) {\n        ;\n    } else if (xen_enabled()) {\n        xen_invalidate_map_cache_entry(block->host);\n#ifndef _WIN32\n    } else if (block->fd >= 0) {\n        qemu_ram_munmap(block->host, block->max_length);\n        close(block->fd);\n#endif\n    } else {\n        qemu_anon_ram_free(block->host, block->max_length);\n    }\n    g_free(block);\n}\n\nvoid qemu_ram_free(RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    if (block->host) {\n        ram_block_notify_remove(block->host, block->max_length);\n    }\n\n    qemu_mutex_lock_ramlist();\n    QLIST_REMOVE_RCU(block, next);\n    ram_list.mru_block = NULL;\n    /* Write list before version */\n    smp_wmb();\n    ram_list.version++;\n    call_rcu(block, reclaim_ramblock, rcu);\n    qemu_mutex_unlock_ramlist();\n}\n\n#ifndef _WIN32\nvoid qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n{\n    RAMBlock *block;\n    ram_addr_t offset;\n    int flags;\n    void *area, *vaddr;\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        offset = addr - block->offset;\n        if (offset < block->max_length) {\n            vaddr = ramblock_ptr(block, offset);\n            if (block->flags & RAM_PREALLOC) {\n                ;\n            } else if (xen_enabled()) {\n                abort();\n            } else {\n                flags = MAP_FIXED;\n                if (block->fd >= 0) {\n                    flags |= (block->flags & RAM_SHARED ?\n                              MAP_SHARED : MAP_PRIVATE);\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n                                flags, block->fd, offset);\n                } else {\n                    /*\n                     * Remap needs to match alloc.  Accelerators that\n                     * set phys_mem_alloc never remap.  If they did,\n                     * we'd need a remap hook here.\n                     */\n                    assert(phys_mem_alloc == qemu_anon_ram_alloc);\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n                                flags, -1, 0);\n                }\n                if (area != vaddr) {\n                    fprintf(stderr, \"Could not remap addr: \"\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n                            length, addr);\n                    exit(1);\n                }\n                memory_try_enable_merging(vaddr, length);\n                qemu_ram_setup_dump(vaddr, length);\n            }\n        }\n    }\n}\n#endif /* !_WIN32 */\n\n/* Return a host pointer to ram allocated with qemu_ram_alloc.\n * This should not be used for general purpose DMA.  Use address_space_map\n * or address_space_rw instead. For local memory (e.g. video ram) that the\n * device owns, use memory_region_get_ram_ptr.\n *\n * Called within RCU critical section.\n */\nvoid *qemu_map_ram_ptr(RAMBlock *ram_block, ram_addr_t addr)\n{\n    RAMBlock *block = ram_block;\n\n    if (block == NULL) {\n        block = qemu_get_ram_block(addr);\n        addr -= block->offset;\n    }\n\n    if (xen_enabled() && block->host == NULL) {\n        /* We need to check if the requested address is in the RAM\n         * because we don't want to map the entire memory in QEMU.\n         * In that case just map until the end of the page.\n         */\n        if (block->offset == 0) {\n            return xen_map_cache(addr, 0, 0, false);\n        }\n\n        block->host = xen_map_cache(block->offset, block->max_length, 1, false);\n    }\n    return ramblock_ptr(block, addr);\n}\n\n/* Return a host pointer to guest's ram. Similar to qemu_map_ram_ptr\n * but takes a size argument.\n *\n * Called within RCU critical section.\n */\nstatic void *qemu_ram_ptr_length(RAMBlock *ram_block, ram_addr_t addr,\n                                 hwaddr *size, bool lock)\n{\n    RAMBlock *block = ram_block;\n    if (*size == 0) {\n        return NULL;\n    }\n\n    if (block == NULL) {\n        block = qemu_get_ram_block(addr);\n        addr -= block->offset;\n    }\n    *size = MIN(*size, block->max_length - addr);\n\n    if (xen_enabled() && block->host == NULL) {\n        /* We need to check if the requested address is in the RAM\n         * because we don't want to map the entire memory in QEMU.\n         * In that case just map the requested area.\n         */\n        if (block->offset == 0) {\n            return xen_map_cache(addr, *size, lock, lock);\n        }\n\n        block->host = xen_map_cache(block->offset, block->max_length, 1, lock);\n    }\n\n    return ramblock_ptr(block, addr);\n}\n\n/*\n * Translates a host ptr back to a RAMBlock, a ram_addr and an offset\n * in that RAMBlock.\n *\n * ptr: Host pointer to look up\n * round_offset: If true round the result offset down to a page boundary\n * *ram_addr: set to result ram_addr\n * *offset: set to result offset within the RAMBlock\n *\n * Returns: RAMBlock (or NULL if not found)\n *\n * By the time this function returns, the returned pointer is not protected\n * by RCU anymore.  If the caller is not within an RCU critical section and\n * does not hold the iothread lock, it must have other means of protecting the\n * pointer, such as a reference to the region that includes the incoming\n * ram_addr_t.\n */\nRAMBlock *qemu_ram_block_from_host(void *ptr, bool round_offset,\n                                   ram_addr_t *offset)\n{\n    RAMBlock *block;\n    uint8_t *host = ptr;\n\n    if (xen_enabled()) {\n        ram_addr_t ram_addr;\n        rcu_read_lock();\n        ram_addr = xen_ram_addr_from_mapcache(ptr);\n        block = qemu_get_ram_block(ram_addr);\n        if (block) {\n            *offset = ram_addr - block->offset;\n        }\n        rcu_read_unlock();\n        return block;\n    }\n\n    rcu_read_lock();\n    block = atomic_rcu_read(&ram_list.mru_block);\n    if (block && block->host && host - block->host < block->max_length) {\n        goto found;\n    }\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        /* This case append when the block is not mapped. */\n        if (block->host == NULL) {\n            continue;\n        }\n        if (host - block->host < block->max_length) {\n            goto found;\n        }\n    }\n\n    rcu_read_unlock();\n    return NULL;\n\nfound:\n    *offset = (host - block->host);\n    if (round_offset) {\n        *offset &= TARGET_PAGE_MASK;\n    }\n    rcu_read_unlock();\n    return block;\n}\n\n/*\n * Finds the named RAMBlock\n *\n * name: The name of RAMBlock to find\n *\n * Returns: RAMBlock (or NULL if not found)\n */\nRAMBlock *qemu_ram_block_by_name(const char *name)\n{\n    RAMBlock *block;\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        if (!strcmp(name, block->idstr)) {\n            return block;\n        }\n    }\n\n    return NULL;\n}\n\n/* Some of the softmmu routines need to translate from a host pointer\n   (typically a TLB entry) back to a ram offset.  */\nram_addr_t qemu_ram_addr_from_host(void *ptr)\n{\n    RAMBlock *block;\n    ram_addr_t offset;\n\n    block = qemu_ram_block_from_host(ptr, false, &offset);\n    if (!block) {\n        return RAM_ADDR_INVALID;\n    }\n\n    return block->offset + offset;\n}\n\n/* Called within RCU critical section.  */\nstatic void notdirty_mem_write(void *opaque, hwaddr ram_addr,\n                               uint64_t val, unsigned size)\n{\n    bool locked = false;\n\n    if (!cpu_physical_memory_get_dirty_flag(ram_addr, DIRTY_MEMORY_CODE)) {\n        locked = true;\n        tb_lock();\n        tb_invalidate_phys_page_fast(ram_addr, size);\n    }\n    switch (size) {\n    case 1:\n        stb_p(qemu_map_ram_ptr(NULL, ram_addr), val);\n        break;\n    case 2:\n        stw_p(qemu_map_ram_ptr(NULL, ram_addr), val);\n        break;\n    case 4:\n        stl_p(qemu_map_ram_ptr(NULL, ram_addr), val);\n        break;\n    default:\n        abort();\n    }\n\n    if (locked) {\n        tb_unlock();\n    }\n\n    /* Set both VGA and migration bits for simplicity and to remove\n     * the notdirty callback faster.\n     */\n    cpu_physical_memory_set_dirty_range(ram_addr, size,\n                                        DIRTY_CLIENTS_NOCODE);\n    /* we remove the notdirty callback only if the code has been\n       flushed */\n    if (!cpu_physical_memory_is_clean(ram_addr)) {\n        tlb_set_dirty(current_cpu, current_cpu->mem_io_vaddr);\n    }\n}\n\nstatic bool notdirty_mem_accepts(void *opaque, hwaddr addr,\n                                 unsigned size, bool is_write)\n{\n    return is_write;\n}\n\nstatic const MemoryRegionOps notdirty_mem_ops = {\n    .write = notdirty_mem_write,\n    .valid.accepts = notdirty_mem_accepts,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\n/* Generate a debug exception if a watchpoint has been hit.  */\nstatic void check_watchpoint(int offset, int len, MemTxAttrs attrs, int flags)\n{\n    CPUState *cpu = current_cpu;\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = cpu->env_ptr;\n    target_ulong pc, cs_base;\n    target_ulong vaddr;\n    CPUWatchpoint *wp;\n    uint32_t cpu_flags;\n\n    uint64_t rr_instr_count = rr_get_guest_instr_count();\n\n    // If we disabled watchpoints in gdbstub for a step or continue, reenable\n    if (cpu->watchpoints_disabled){\n        cpu->watchpoints_disabled = false;\n        return;\n    }\n\n    // Handle reverse-continue action and possibly restore checkpoint\n    cpu_rcont_check_restore(cpu, rr_instr_count);\n\n    if (cpu->watchpoint_hit) {\n        /* We re-entered the check after replacing the TB. Now raise\n         * the debug interrupt so that is will trigger after the\n         * current instruction. */\n        cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);\n        return;\n    }\n\n    vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n    vaddr = cc->adjust_watchpoint_address(cpu, vaddr, len);\n    \n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n        if (cpu_watchpoint_address_matches(wp, vaddr, len)\n            && (wp->flags & flags)) {\n            if (flags == BP_MEM_READ) {\n                wp->flags |= BP_WATCHPOINT_HIT_READ;\n            } else {\n                wp->flags |= BP_WATCHPOINT_HIT_WRITE;\n            }\n            wp->hitaddr = vaddr;\n            wp->hitattrs = attrs;\n\n            if (unlikely(cpu->reverse_flags & GDB_RCONT)) {\n                // first pass of reverse-continue\n                // skip this watchpoint and record it\n                cpu->last_bp_hit_instr = rr_instr_count;\n                return;\n            }  else if (cpu->reverse_flags & GDB_RCONT_BREAK) {\n                // We are doing second pass of reverse-continue\n                // break on latest breakpoint/watchpoint \n                if (rr_instr_count > cpu->last_bp_hit_instr) {\n                    fprintf(stderr, \"GDB_RCONT_BREAK went too far\");\n                    abort();\n                }\n\n                if  (!(rr_instr_count == cpu->last_bp_hit_instr)) {\n                    // if we're reverse-continuing to a certain point, ignore all other bps except the last one\n                    return;\n                }\n            }\n\n            if (!cpu->watchpoint_hit) {\n                if (wp->flags & BP_CPU &&\n                    !cc->debug_check_watchpoint(cpu, wp)) {\n                    wp->flags &= ~BP_WATCHPOINT_HIT;\n                    continue;\n                }\n                cpu->watchpoint_hit = wp;\n\n                /* The tb_lock will be reset when cpu_loop_exit or\n                 * cpu_loop_exit_noexc longjmp back into the cpu_exec\n                 * main loop.\n                 */\n                tb_lock();\n                tb_check_watchpoint(cpu);\n\n                // We're done with reverse-continue, clear the flag\n                cpu->reverse_flags = 0;\n\n                // rw: Let's just break before access if we're in RR replay\n                if (wp->flags & BP_STOP_BEFORE_ACCESS || rr_in_replay()) {\n                    cpu->exception_index = EXCP_DEBUG;\n                    cpu->rr_guest_instr_count -= 1;\n                    cpu_loop_exit(cpu);\n                } else {\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n                    tb_gen_code(cpu, pc, cs_base, cpu_flags, 1);\n                    cpu_loop_exit_noexc(cpu);\n                }\n            }\n        } else {\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n        }\n    }\n}\n\n/* Watchpoint access routines.  Watchpoints are inserted using TLB tricks,\n   so these check for a hit then pass through to the normal out-of-line\n   phys routines.  */\nstatic MemTxResult watch_mem_read(void *opaque, hwaddr addr, uint64_t *pdata,\n                                  unsigned size, MemTxAttrs attrs)\n{\n    MemTxResult res;\n    uint64_t data;\n    int asidx = cpu_asidx_from_attrs(current_cpu, attrs);\n    AddressSpace *as = current_cpu->cpu_ases[asidx].as;\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, attrs, BP_MEM_READ);\n    switch (size) {\n    case 1:\n        data = address_space_ldub(as, addr, attrs, &res);\n        break;\n    case 2:\n        data = address_space_lduw(as, addr, attrs, &res);\n        break;\n    case 4:\n        data = address_space_ldl(as, addr, attrs, &res);\n        break;\n    default: abort();\n    }\n    *pdata = data;\n    return res;\n}\n\nstatic MemTxResult watch_mem_write(void *opaque, hwaddr addr,\n                                   uint64_t val, unsigned size,\n                                   MemTxAttrs attrs)\n{\n    MemTxResult res;\n    int asidx = cpu_asidx_from_attrs(current_cpu, attrs);\n    AddressSpace *as = current_cpu->cpu_ases[asidx].as;\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, attrs, BP_MEM_WRITE);\n    switch (size) {\n    case 1:\n        address_space_stb(as, addr, val, attrs, &res);\n        break;\n    case 2:\n        address_space_stw(as, addr, val, attrs, &res);\n        break;\n    case 4:\n        address_space_stl(as, addr, val, attrs, &res);\n        break;\n    default: abort();\n    }\n    return res;\n}\n\nstatic const MemoryRegionOps watch_mem_ops = {\n    .read_with_attrs = watch_mem_read,\n    .write_with_attrs = watch_mem_write,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nstatic MemTxResult subpage_read(void *opaque, hwaddr addr, uint64_t *data,\n                                unsigned len, MemTxAttrs attrs)\n{\n    subpage_t *subpage = opaque;\n    uint8_t buf[8];\n    MemTxResult res;\n\n#if defined(DEBUG_SUBPAGE)\n    printf(\"%s: subpage %p len %u addr \" TARGET_FMT_plx \"\\n\", __func__,\n           subpage, len, addr);\n#endif\n    res = address_space_read(subpage->as, addr + subpage->base,\n                             attrs, buf, len);\n    if (res) {\n        return res;\n    }\n    switch (len) {\n    case 1:\n        *data = ldub_p(buf);\n        return MEMTX_OK;\n    case 2:\n        *data = lduw_p(buf);\n        return MEMTX_OK;\n    case 4:\n        *data = ldl_p(buf);\n        return MEMTX_OK;\n    case 8:\n        *data = ldq_p(buf);\n        return MEMTX_OK;\n    default:\n        abort();\n    }\n}\n\nstatic MemTxResult subpage_write(void *opaque, hwaddr addr,\n                                 uint64_t value, unsigned len, MemTxAttrs attrs)\n{\n    subpage_t *subpage = opaque;\n    uint8_t buf[8];\n\n#if defined(DEBUG_SUBPAGE)\n    printf(\"%s: subpage %p len %u addr \" TARGET_FMT_plx\n           \" value %\"PRIx64\"\\n\",\n           __func__, subpage, len, addr, value);\n#endif\n    switch (len) {\n    case 1:\n        stb_p(buf, value);\n        break;\n    case 2:\n        stw_p(buf, value);\n        break;\n    case 4:\n        stl_p(buf, value);\n        break;\n    case 8:\n        stq_p(buf, value);\n        break;\n    default:\n        abort();\n    }\n    return address_space_write(subpage->as, addr + subpage->base,\n                               attrs, buf, len);\n}\n\nstatic bool subpage_accepts(void *opaque, hwaddr addr,\n                            unsigned len, bool is_write)\n{\n    subpage_t *subpage = opaque;\n#if defined(DEBUG_SUBPAGE)\n    printf(\"%s: subpage %p %c len %u addr \" TARGET_FMT_plx \"\\n\",\n           __func__, subpage, is_write ? 'w' : 'r', len, addr);\n#endif\n\n    return address_space_access_valid(subpage->as, addr + subpage->base,\n                                      len, is_write);\n}\n\nstatic const MemoryRegionOps subpage_ops = {\n    .read_with_attrs = subpage_read,\n    .write_with_attrs = subpage_write,\n    .impl.min_access_size = 1,\n    .impl.max_access_size = 8,\n    .valid.min_access_size = 1,\n    .valid.max_access_size = 8,\n    .valid.accepts = subpage_accepts,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nstatic int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,\n                             uint16_t section)\n{\n    int idx, eidx;\n\n    if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)\n        return -1;\n    idx = SUBPAGE_IDX(start);\n    eidx = SUBPAGE_IDX(end);\n#if defined(DEBUG_SUBPAGE)\n    printf(\"%s: %p start %08x end %08x idx %08x eidx %08x section %d\\n\",\n           __func__, mmio, start, end, idx, eidx, section);\n#endif\n    for (; idx <= eidx; idx++) {\n        mmio->sub_section[idx] = section;\n    }\n\n    return 0;\n}\n\nstatic subpage_t *subpage_init(AddressSpace *as, hwaddr base)\n{\n    subpage_t *mmio;\n\n    mmio = g_malloc0(sizeof(subpage_t) + TARGET_PAGE_SIZE * sizeof(uint16_t));\n    mmio->as = as;\n    mmio->base = base;\n    memory_region_init_io(&mmio->iomem, NULL, &subpage_ops, mmio,\n                          NULL, TARGET_PAGE_SIZE);\n    mmio->iomem.subpage = true;\n#if defined(DEBUG_SUBPAGE)\n    printf(\"%s: %p base \" TARGET_FMT_plx \" len %08x\\n\", __func__,\n           mmio, base, TARGET_PAGE_SIZE);\n#endif\n    subpage_register(mmio, 0, TARGET_PAGE_SIZE-1, PHYS_SECTION_UNASSIGNED);\n\n    return mmio;\n}\n\nstatic uint16_t dummy_section(PhysPageMap *map, AddressSpace *as,\n                              MemoryRegion *mr)\n{\n    assert(as);\n    MemoryRegionSection section = {\n        .address_space = as,\n        .mr = mr,\n        .offset_within_address_space = 0,\n        .offset_within_region = 0,\n        .size = int128_2_64(),\n    };\n\n    return phys_section_add(map, &section);\n}\n\nMemoryRegion *iotlb_to_region(CPUState *cpu, hwaddr index, MemTxAttrs attrs)\n{\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n    CPUAddressSpace *cpuas = &cpu->cpu_ases[asidx];\n    AddressSpaceDispatch *d = atomic_rcu_read(&cpuas->memory_dispatch);\n    MemoryRegionSection *sections = d->map.sections;\n\n    return sections[index & ~TARGET_PAGE_MASK].mr;\n}\n\nstatic void io_mem_init(void)\n{\n    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, \"rom\", UINT64_MAX);\n    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,\n                          \"unassigned\", UINT64_MAX);\n    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,\n                          \"notdirty\", UINT64_MAX);\n    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,\n                          \"watch\", UINT64_MAX);\n}\n\nstatic void mem_begin(MemoryListener *listener)\n{\n    AddressSpace *as = container_of(listener, AddressSpace, dispatch_listener);\n    AddressSpaceDispatch *d = g_new0(AddressSpaceDispatch, 1);\n    uint16_t n;\n\n    n = dummy_section(&d->map, as, &io_mem_unassigned);\n    assert(n == PHYS_SECTION_UNASSIGNED);\n    n = dummy_section(&d->map, as, &io_mem_notdirty);\n    assert(n == PHYS_SECTION_NOTDIRTY);\n    n = dummy_section(&d->map, as, &io_mem_rom);\n    assert(n == PHYS_SECTION_ROM);\n    n = dummy_section(&d->map, as, &io_mem_watch);\n    assert(n == PHYS_SECTION_WATCH);\n\n    d->phys_map  = (PhysPageEntry) { .ptr = PHYS_MAP_NODE_NIL, .skip = 1 };\n    d->as = as;\n    as->next_dispatch = d;\n}\n\nstatic void address_space_dispatch_free(AddressSpaceDispatch *d)\n{\n    phys_sections_free(&d->map);\n    g_free(d);\n}\n\nstatic void mem_commit(MemoryListener *listener)\n{\n    AddressSpace *as = container_of(listener, AddressSpace, dispatch_listener);\n    AddressSpaceDispatch *cur = as->dispatch;\n    AddressSpaceDispatch *next = as->next_dispatch;\n\n    phys_page_compact_all(next, next->map.nodes_nb);\n\n    atomic_rcu_set(&as->dispatch, next);\n    if (cur) {\n        call_rcu(cur, address_space_dispatch_free, rcu);\n    }\n}\n\nstatic void tcg_commit(MemoryListener *listener)\n{\n    CPUAddressSpace *cpuas;\n    AddressSpaceDispatch *d;\n\n    /* since each CPU stores ram addresses in its TLB cache, we must\n       reset the modified entries */\n    cpuas = container_of(listener, CPUAddressSpace, tcg_as_listener);\n    cpu_reloading_memory_map();\n    /* The CPU and TLB are protected by the iothread lock.\n     * We reload the dispatch pointer now because cpu_reloading_memory_map()\n     * may have split the RCU critical section.\n     */\n    d = atomic_rcu_read(&cpuas->as->dispatch);\n    atomic_rcu_set(&cpuas->memory_dispatch, d);\n    tlb_flush(cpuas->cpu);\n}\n\nvoid address_space_init_dispatch(AddressSpace *as)\n{\n    as->dispatch = NULL;\n    as->dispatch_listener = (MemoryListener) {\n        .begin = mem_begin,\n        .commit = mem_commit,\n        .region_add = mem_add,\n        .region_nop = mem_add,\n        .priority = 0,\n    };\n    memory_listener_register(&as->dispatch_listener, as);\n}\n\nvoid address_space_unregister(AddressSpace *as)\n{\n    memory_listener_unregister(&as->dispatch_listener);\n}\n\nvoid address_space_destroy_dispatch(AddressSpace *as)\n{\n    AddressSpaceDispatch *d = as->dispatch;\n\n    atomic_rcu_set(&as->dispatch, NULL);\n    if (d) {\n        call_rcu(d, address_space_dispatch_free, rcu);\n    }\n}\n\nstatic void memory_map_init(void)\n{\n    system_memory = g_malloc(sizeof(*system_memory));\n\n    memory_region_init(system_memory, NULL, \"system\", UINT64_MAX);\n    address_space_init(&address_space_memory, system_memory, \"memory\");\n\n    system_io = g_malloc(sizeof(*system_io));\n    memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, \"io\",\n                          65536);\n    address_space_init(&address_space_io, system_io, \"I/O\");\n}\n\nMemoryRegion *get_system_memory(void)\n{\n    return system_memory;\n}\n\nMemoryRegion *get_system_io(void)\n{\n    return system_io;\n}\n\n#endif /* !defined(CONFIG_USER_ONLY) */\n\n/* physical memory access (slow version, mainly for debug) */\n#if defined(CONFIG_USER_ONLY)\nint cpu_memory_rw_debug(CPUState *cpu, target_ulong addr,\n                        uint8_t *buf, int len, int is_write)\n{\n    int l, flags;\n    target_ulong page;\n    void * p;\n\n    while (len > 0) {\n        page = addr & TARGET_PAGE_MASK;\n        l = (page + TARGET_PAGE_SIZE) - addr;\n        if (l > len)\n            l = len;\n        flags = page_get_flags(page);\n        if (!(flags & PAGE_VALID))\n            return -1;\n        if (is_write) {\n            if (!(flags & PAGE_WRITE))\n                return -1;\n            /* XXX: this code should not depend on lock_user */\n            if (!(p = lock_user(VERIFY_WRITE, addr, l, 0)))\n                return -1;\n            memcpy(p, buf, l);\n            unlock_user(p, addr, l);\n        } else {\n            if (!(flags & PAGE_READ))\n                return -1;\n            /* XXX: this code should not depend on lock_user */\n            if (!(p = lock_user(VERIFY_READ, addr, l, 1)))\n                return -1;\n            memcpy(buf, p, l);\n            unlock_user(p, addr, 0);\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n    }\n    return 0;\n}\n\n#else\n\nstatic void invalidate_and_set_dirty(MemoryRegion *mr, hwaddr addr,\n                                     hwaddr length)\n{\n    uint8_t dirty_log_mask = memory_region_get_dirty_log_mask(mr);\n    addr += memory_region_get_ram_addr(mr);\n\n    /* No early return if dirty_log_mask is or becomes 0, because\n     * cpu_physical_memory_set_dirty_range will still call\n     * xen_modified_memory.\n     */\n    if (dirty_log_mask) {\n        dirty_log_mask =\n            cpu_physical_memory_range_includes_clean(addr, length, dirty_log_mask);\n    }\n    if (dirty_log_mask & (1 << DIRTY_MEMORY_CODE)) {\n        tb_lock();\n        tb_invalidate_phys_range(addr, addr + length);\n        tb_unlock();\n        dirty_log_mask &= ~(1 << DIRTY_MEMORY_CODE);\n    }\n    cpu_physical_memory_set_dirty_range(addr, length, dirty_log_mask);\n}\n\nstatic int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n{\n    unsigned access_size_max = mr->ops->valid.max_access_size;\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n       otherwise specified.  */\n    if (access_size_max == 0) {\n        access_size_max = 4;\n    }\n\n    /* Bound the maximum access by the alignment of the address.  */\n    if (!mr->ops->impl.unaligned) {\n        unsigned align_size_max = addr & -addr;\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n            access_size_max = align_size_max;\n        }\n    }\n\n    /* Don't attempt accesses larger than the maximum.  */\n    if (l > access_size_max) {\n        l = access_size_max;\n    }\n    l = pow2floor(l);\n\n    return l;\n}\n\nstatic bool prepare_mmio_access(MemoryRegion *mr)\n{\n    bool unlocked = !qemu_mutex_iothread_locked();\n    bool release_lock = false;\n\n    if (unlocked && mr->global_locking) {\n        qemu_mutex_lock_iothread();\n        unlocked = false;\n        release_lock = true;\n    }\n    if (mr->flush_coalesced_mmio) {\n        if (unlocked) {\n            qemu_mutex_lock_iothread();\n        }\n        qemu_flush_coalesced_mmio_buffer();\n        if (unlocked) {\n            qemu_mutex_unlock_iothread();\n        }\n    }\n\n    return release_lock;\n}\n\n\n/* Called within RCU critical section.  */\nstatic MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n                                                MemTxAttrs attrs,\n                                                const uint8_t *buf,\n                                                int len, hwaddr addr1,\n                                                hwaddr l, MemoryRegion *mr)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemTxResult result = MEMTX_OK;\n    bool release_lock = false;\n\n    for (;;) {\n        if (!memory_access_is_direct(mr, true)) {\n            release_lock |= prepare_mmio_access(mr);\n            l = memory_access_size(mr, l, addr1);\n            /* XXX: could force current_cpu to NULL to avoid\n               potential bugs */\n            /* Maybe we want to record the value of result in this switch statement */\n            switch (l) {\n            case 8:\n                /* 64 bit write access */\n                val = ldq_p(buf);\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n                                                       attrs),\n                /*record=*/RR_NO_ACTION,\n                /*replay=*/RR_NO_ACTION,\n                /*location=*/RR_CALLSITE_WRITE_8);\n                break;\n            case 4:\n                /* 32 bit write access */\n                val = (uint32_t)ldl_p(buf);\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n                                                       attrs),\n                /*record=*/RR_NO_ACTION,\n                /*replay=*/RR_NO_ACTION,\n                /*location=*/RR_CALLSITE_WRITE_4);\n                break;\n            case 2:\n                /* 16 bit write access */\n                val = lduw_p(buf);\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n                                                       attrs),\n                /*record=*/RR_NO_ACTION,\n                /*replay=*/RR_NO_ACTION,\n                /*location=*/RR_CALLSITE_WRITE_2);\n                break;\n            case 1:\n                /* 8 bit write access */\n                val = ldub_p(buf);\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n                                                       attrs),\n                /*record=*/RR_NO_ACTION,\n                /*replay=*/RR_NO_ACTION,\n                /*location=*/RR_CALLSITE_WRITE_1);\n                break;\n            default:\n                abort();\n            }\n        } else {\n            /* RAM case */\n            ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);\n            if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {\n                // We should record the memory address relative to the address space, not physical memory.\n                // During replay, this address will be translated into the physical address.\n                rr_device_mem_rw_call_record(addr, buf, l, /*is_write*/1);\n            }\n            panda_callbacks_replay_before_dma(first_cpu, buf, addr1, l, true);\n            memcpy(ptr, buf, l);\n            panda_callbacks_replay_after_dma(first_cpu, buf, addr1, l, true);\n            invalidate_and_set_dirty(mr, addr1, l);\n        }\n\n        if (release_lock) {\n            qemu_mutex_unlock_iothread();\n            release_lock = false;\n        }\n\n        len -= l;\n        buf += l;\n        addr += l;\n\n        if (!len) {\n            break;\n        }\n\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n    }\n\n    return result;\n}\n\nMemTxResult address_space_write(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,\n                                const uint8_t *buf, int len)\n{\n    hwaddr l;\n    hwaddr addr1;\n    MemoryRegion *mr;\n    MemTxResult result = MEMTX_OK;\n\n    if (len > 0) {\n        rcu_read_lock();\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n        result = address_space_write_continue(as, addr, attrs, buf, len,\n                                              addr1, l, mr);\n        rcu_read_unlock();\n    }\n\n    return result;\n}\n\n/* Called within RCU critical section.  */\nMemTxResult address_space_read_continue(AddressSpace *as, hwaddr addr,\n                                        MemTxAttrs attrs, uint8_t *buf,\n                                        int len, hwaddr addr1, hwaddr l,\n                                        MemoryRegion *mr)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemTxResult result = MEMTX_OK;\n    bool release_lock = false;\n    _Static_assert(sizeof(MemTxResult) == 4, \"Unexpected size of MemTxResult (does not match rr_input_4)\");\n    for (;;) {\n        if (!memory_access_is_direct(mr, false)) {\n            /* I/O case */\n            release_lock |= prepare_mmio_access(mr);\n            l = memory_access_size(mr, l, addr1);\n            switch (l) {\n            case 8:\n                /* 64 bit read access */\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 8,\n                                                      attrs),\n                /*record=*/rr_input_4(&result); rr_input_8(&val),\n                /*replay=*/rr_input_4(&result); rr_input_8(&val),\n                /*location=*/RR_CALLSITE_READ_8);\n                stq_p(buf, val);\n                break;\n            case 4:\n                /* 32 bit read access */\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 4,\n                                                      attrs),\n                /*record=*/rr_input_4(&result); rr_input_8(&val),\n                /*replay=*/rr_input_4(&result); rr_input_8(&val),\n                /*location=*/RR_CALLSITE_READ_4);\n                stl_p(buf, val);\n                break;\n            case 2:\n                /* 16 bit read access */\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 2,\n                                                      attrs),\n                /*record=*/rr_input_4(&result); rr_input_8(&val),\n                /*replay=*/rr_input_4(&result); rr_input_8(&val),\n                /*location=*/RR_CALLSITE_READ_2);\n                stw_p(buf, val);\n                break;\n            case 1:\n                /* 8 bit read access */\n                RR_DO_RECORD_OR_REPLAY(\n                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 1,\n                                                      attrs),\n                /*record=*/rr_input_4(&result); rr_input_8(&val),\n                /*replay=*/rr_input_4(&result); rr_input_8(&val),\n                /*location=*/RR_CALLSITE_READ_1);\n                stb_p(buf, val);\n                break;\n            default:\n                abort();\n            }\n        } else {\n            /* RAM case */\n            ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);\n            panda_callbacks_replay_before_dma(first_cpu, buf, addr1, l, false);\n            memcpy(buf, ptr, l);\n            panda_callbacks_replay_after_dma(first_cpu, buf, addr1, l, false);\n        }\n\n        if (release_lock) {\n            qemu_mutex_unlock_iothread();\n            release_lock = false;\n        }\n\n        len -= l;\n        buf += l;\n        addr += l;\n\n        if (!len) {\n            break;\n        }\n\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, false);\n    }\n\n    return result;\n}\n\nMemTxResult address_space_read_full(AddressSpace *as, hwaddr addr,\n                                    MemTxAttrs attrs, uint8_t *buf, int len)\n{\n    hwaddr l;\n    hwaddr addr1;\n    MemoryRegion *mr;\n    MemTxResult result = MEMTX_OK;\n\n    if (len > 0) {\n        rcu_read_lock();\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, false);\n        result = address_space_read_continue(as, addr, attrs, buf, len,\n                                             addr1, l, mr);\n        rcu_read_unlock();\n    }\n\n    return result;\n}\n\nMemTxResult address_space_rw(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,\n                             uint8_t *buf, int len, bool is_write)\n{\n    if (is_write) {\n        return address_space_write(as, addr, attrs, (uint8_t *)buf, len);\n    } else {\n        return address_space_read(as, addr, attrs, (uint8_t *)buf, len);\n    }\n}\n\n\nvoid cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,\n                            int len, int is_write)\n{\n    address_space_rw(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED,\n                            buf, len, is_write);\n\n}\n\n// if safe == true that means we want this to fail for IO mem\nMemTxResult cpu_physical_memory_rw_ex(hwaddr addr, uint8_t *buf,\n                                     int len, int is_write, bool safe) {\n    hwaddr l = len;\n    hwaddr addr1;\n    MemoryRegion *mr = address_space_translate(&address_space_memory, addr, &addr1, &l, is_write);\n    if (safe && !memory_access_is_direct(mr, is_write)) {\n        return MEMTX_ERROR;\n    }\n    return address_space_rw(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED,\n                            buf, len, is_write);\n}\n\n\nenum write_rom_type {\n    WRITE_DATA,\n    FLUSH_CACHE,\n};\n\nstatic inline void cpu_physical_memory_write_rom_internal(AddressSpace *as,\n    hwaddr addr, const uint8_t *buf, int len, enum write_rom_type type)\n{\n    hwaddr l;\n    uint8_t *ptr;\n    hwaddr addr1;\n    MemoryRegion *mr;\n\n    rcu_read_lock();\n    while (len > 0) {\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n\n        if (!(memory_region_is_ram(mr) ||\n              memory_region_is_romd(mr))) {\n            l = memory_access_size(mr, l, addr1);\n        } else {\n            /* ROM/RAM case */\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n            switch (type) {\n            case WRITE_DATA:\n                if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {\n                    rr_device_mem_rw_call_record(addr1, buf, l, 1);\n                }\n                memcpy(ptr, buf, l);\n                invalidate_and_set_dirty(mr, addr1, l);\n                break;\n            case FLUSH_CACHE:\n                flush_icache_range((uintptr_t)ptr, (uintptr_t)ptr + l);\n                break;\n            }\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n    }\n    rcu_read_unlock();\n}\n\n/* used for ROM loading : can write in RAM and ROM */\nvoid cpu_physical_memory_write_rom(AddressSpace *as, hwaddr addr,\n                                   const uint8_t *buf, int len)\n{\n    cpu_physical_memory_write_rom_internal(as, addr, buf, len, WRITE_DATA);\n}\n\nvoid cpu_flush_icache_range(hwaddr start, int len)\n{\n    /*\n     * This function should do the same thing as an icache flush that was\n     * triggered from within the guest. For TCG we are always cache coherent,\n     * so there is no need to flush anything. For KVM / Xen we need to flush\n     * the host's instruction cache at least.\n     */\n    if (tcg_enabled()) {\n        return;\n    }\n\n    cpu_physical_memory_write_rom_internal(&address_space_memory,\n                                           start, NULL, len, FLUSH_CACHE);\n}\n\ntypedef struct {\n    MemoryRegion *mr;\n    void *buffer;\n    hwaddr addr;\n    hwaddr len;\n    bool in_use;\n} BounceBuffer;\n\nstatic BounceBuffer bounce;\n\ntypedef struct MapClient {\n    QEMUBH *bh;\n    QLIST_ENTRY(MapClient) link;\n} MapClient;\n\nQemuMutex map_client_list_lock;\nstatic QLIST_HEAD(map_client_list, MapClient) map_client_list\n    = QLIST_HEAD_INITIALIZER(map_client_list);\n\nstatic void cpu_unregister_map_client_do(MapClient *client)\n{\n    QLIST_REMOVE(client, link);\n    g_free(client);\n}\n\nstatic void cpu_notify_map_clients_locked(void)\n{\n    MapClient *client;\n\n    while (!QLIST_EMPTY(&map_client_list)) {\n        client = QLIST_FIRST(&map_client_list);\n        qemu_bh_schedule(client->bh);\n        cpu_unregister_map_client_do(client);\n    }\n}\n\nvoid cpu_register_map_client(QEMUBH *bh)\n{\n    MapClient *client = g_malloc(sizeof(*client));\n\n    qemu_mutex_lock(&map_client_list_lock);\n    client->bh = bh;\n    QLIST_INSERT_HEAD(&map_client_list, client, link);\n    if (!atomic_read(&bounce.in_use)) {\n        cpu_notify_map_clients_locked();\n    }\n    qemu_mutex_unlock(&map_client_list_lock);\n}\n\nvoid cpu_exec_init_all(void)\n{\n    qemu_mutex_init(&ram_list.mutex);\n    /* The data structures we set up here depend on knowing the page size,\n     * so no more changes can be made after this point.\n     * In an ideal world, nothing we did before we had finished the\n     * machine setup would care about the target page size, and we could\n     * do this much later, rather than requiring board models to state\n     * up front what their requirements are.\n     */\n    finalize_target_page_bits();\n    io_mem_init();\n    memory_map_init();\n    qemu_mutex_init(&map_client_list_lock);\n}\n\nvoid cpu_unregister_map_client(QEMUBH *bh)\n{\n    MapClient *client;\n\n    qemu_mutex_lock(&map_client_list_lock);\n    QLIST_FOREACH(client, &map_client_list, link) {\n        if (client->bh == bh) {\n            cpu_unregister_map_client_do(client);\n            break;\n        }\n    }\n    qemu_mutex_unlock(&map_client_list_lock);\n}\n\nstatic void cpu_notify_map_clients(void)\n{\n    qemu_mutex_lock(&map_client_list_lock);\n    cpu_notify_map_clients_locked();\n    qemu_mutex_unlock(&map_client_list_lock);\n}\n\nbool address_space_access_valid(AddressSpace *as, hwaddr addr, int len, bool is_write)\n{\n    MemoryRegion *mr;\n    hwaddr l, xlat;\n\n    rcu_read_lock();\n    while (len > 0) {\n        l = len;\n        mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (!memory_access_is_direct(mr, is_write)) {\n            l = memory_access_size(mr, l, addr);\n            if (!memory_region_access_valid(mr, xlat, l, is_write)) {\n                rcu_read_unlock();\n                return false;\n            }\n        }\n\n        len -= l;\n        addr += l;\n    }\n    rcu_read_unlock();\n    return true;\n}\n\nstatic hwaddr\naddress_space_extend_translation(AddressSpace *as, hwaddr addr, hwaddr target_len,\n                                 MemoryRegion *mr, hwaddr base, hwaddr len,\n                                 bool is_write)\n{\n    hwaddr done = 0;\n    hwaddr xlat;\n    MemoryRegion *this_mr;\n\n    for (;;) {\n        target_len -= len;\n        addr += len;\n        done += len;\n        if (target_len == 0) {\n            return done;\n        }\n\n        len = target_len;\n        this_mr = address_space_translate(as, addr, &xlat, &len, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            return done;\n        }\n    }\n}\n\nQLIST_HEAD(rr_map_list, RR_MapList) rr_map_list\n    = QLIST_HEAD_INITIALIZER(rr_map_list);\n\n/* Map a physical memory region into a host virtual address.\n * May map a subset of the requested range, given by and returned in *plen.\n * May return NULL if resources needed to perform the mapping are exhausted.\n * Use only for reads OR writes - not for read-modify-write operations.\n * Use cpu_register_map_client() to know when retrying the map operation is\n * likely to succeed.\n */\nvoid *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr l, xlat;\n    MemoryRegion *mr;\n    void *ptr;\n\n    if (len == 0) {\n        return NULL;\n    }\n\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        /* Avoid unbounded allocations */\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n\n\n    memory_region_ref(mr);\n    *plen = address_space_extend_translation(as, addr, len, mr, xlat, l, is_write);\n    ptr = qemu_ram_ptr_length(mr->ram_block, xlat, plen, true);\n    rcu_read_unlock();\n\n    if (!rr_in_replay()) {\n        // Keep a list of these so we can find out when they change\n        RR_MapList *region = g_malloc(sizeof(*region));\n        region->addr = addr;\n        region->len = *plen; // can't use len because it was modified\n        region->ptr = ptr;\n        region->crc = crc32(crc32(0, Z_NULL, 0), region->ptr, region->len);\n        QLIST_INSERT_HEAD(&rr_map_list, region, link);\n    }\n\n    return ptr;\n}\n\n/* Unmaps a memory region previously mapped by address_space_map().\n * Will also mark the memory as dirty if is_write == 1.  access_len gives\n * the amount of memory that was actually read or written by the caller.\n */\nvoid address_space_unmap(AddressSpace *as, void *buffer, hwaddr len,\n                         int is_write, hwaddr access_len)\n{\n    if (buffer != bounce.buffer) {\n        MemoryRegion *mr;\n        ram_addr_t addr1;\n\n        mr = memory_region_from_host(buffer, &addr1);\n        assert(mr != NULL);\n        if (is_write) {\n            //bdg Save addr1,access_len,buffer contents\n            if (rr_in_record()) {\n                rr_device_mem_unmap_call_record(addr1, buffer, access_len, is_write);\n            }\n            invalidate_and_set_dirty(mr, addr1, access_len);\n        }\n        if (xen_enabled()) {\n            xen_invalidate_map_cache_entry(buffer);\n        }\n        memory_region_unref(mr);\n\n        // Remove it from the tracked map regions for rec/replay\n        if (!rr_in_replay()) {\n            RR_MapList *region;\n            bool found = false;\n            QLIST_FOREACH(region, &rr_map_list, link) {\n                if (region->ptr == buffer && region->len == len) {\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                QLIST_REMOVE(region, link);\n                g_free(region);\n            }\n        }\n\n        return;\n    }\n    if (is_write) {\n        address_space_write(as, bounce.addr, MEMTXATTRS_UNSPECIFIED,\n                            bounce.buffer, access_len);\n    }\n    qemu_vfree(bounce.buffer);\n    bounce.buffer = NULL;\n    memory_region_unref(bounce.mr);\n    atomic_mb_set(&bounce.in_use, false);\n    cpu_notify_map_clients();\n}\n\nvoid *cpu_physical_memory_map(hwaddr addr,\n                              hwaddr *plen,\n                              int is_write)\n{\n    return address_space_map(&address_space_memory, addr, plen, is_write);\n}\n\nvoid cpu_physical_memory_unmap(void *buffer, hwaddr len,\n                               int is_write, hwaddr access_len)\n{\n    return address_space_unmap(&address_space_memory, buffer, len, is_write, access_len);\n}\n\n#define ARG1_DECL                AddressSpace *as\n#define ARG1                     as\n#define SUFFIX\n#define TRANSLATE(...)           address_space_translate(as, __VA_ARGS__)\n#define IS_DIRECT(mr, is_write)  memory_access_is_direct(mr, is_write)\n#define MAP_RAM(mr, ofs)         qemu_map_ram_ptr((mr)->ram_block, ofs)\n#define INVALIDATE(mr, ofs, len) invalidate_and_set_dirty(mr, ofs, len)\n#define RCU_READ_LOCK(...)       rcu_read_lock()\n#define RCU_READ_UNLOCK(...)     rcu_read_unlock()\n#include \"memory_ldst.inc.c\"\n\nint64_t address_space_cache_init(MemoryRegionCache *cache,\n                                 AddressSpace *as,\n                                 hwaddr addr,\n                                 hwaddr len,\n                                 bool is_write)\n{\n    cache->len = len;\n    cache->as = as;\n    cache->xlat = addr;\n    return len;\n}\n\nvoid address_space_cache_invalidate(MemoryRegionCache *cache,\n                                    hwaddr addr,\n                                    hwaddr access_len)\n{\n}\n\nvoid address_space_cache_destroy(MemoryRegionCache *cache)\n{\n    cache->as = NULL;\n}\n\n#define ARG1_DECL                MemoryRegionCache *cache\n#define ARG1                     cache\n#define SUFFIX                   _cached\n#define TRANSLATE(addr, ...)     \\\n    address_space_translate(cache->as, cache->xlat + (addr), __VA_ARGS__)\n#define IS_DIRECT(mr, is_write)  true\n#define MAP_RAM(mr, ofs)         qemu_map_ram_ptr((mr)->ram_block, ofs)\n#define INVALIDATE(mr, ofs, len) invalidate_and_set_dirty(mr, ofs, len)\n#define RCU_READ_LOCK()          rcu_read_lock()\n#define RCU_READ_UNLOCK()        rcu_read_unlock()\n#include \"memory_ldst.inc.c\"\n\n/* virtual memory access for debug (includes writing to ROM) */\nint cpu_memory_rw_debug(CPUState *cpu, target_ulong addr,\n                        uint8_t *buf, int len, int is_write)\n{\n    int l;\n    hwaddr phys_addr;\n    target_ulong page;\n\n    cpu_synchronize_state(cpu);\n    while (len > 0) {\n        int asidx;\n        MemTxAttrs attrs;\n\n        page = addr & TARGET_PAGE_MASK;\n        phys_addr = cpu_get_phys_page_attrs_debug(cpu, page, &attrs);\n        asidx = cpu_asidx_from_attrs(cpu, attrs);\n        /* if no physical page mapped, return an error */\n        if (phys_addr == -1)\n            return -1;\n        l = (page + TARGET_PAGE_SIZE) - addr;\n        if (l > len)\n            l = len;\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n        if (is_write) {\n            cpu_physical_memory_write_rom(cpu->cpu_ases[asidx].as,\n                                          phys_addr, buf, l);\n        } else {\n            address_space_rw(cpu->cpu_ases[asidx].as, phys_addr,\n                             MEMTXATTRS_UNSPECIFIED,\n                             buf, l, 0);\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n    }\n    return 0;\n}\n\n/*\n * Allows code that needs to deal with migration bitmaps etc to still be built\n * target independent.\n */\nsize_t qemu_target_page_bits(void)\n{\n    return TARGET_PAGE_BITS;\n}\n\n#endif\n\n/*\n * A helper function for the _utterly broken_ virtio device model to find out if\n * it's running on a big endian machine. Don't do this at home kids!\n */\nbool target_words_bigendian(void);\nbool target_words_bigendian(void)\n{\n#if defined(TARGET_WORDS_BIGENDIAN)\n    return true;\n#else\n    return false;\n#endif\n}\n\n#ifndef CONFIG_USER_ONLY\nbool cpu_physical_memory_is_io(hwaddr phys_addr)\n{\n    MemoryRegion*mr;\n    hwaddr l = 1;\n    bool res;\n\n    rcu_read_lock();\n    mr = address_space_translate(&address_space_memory,\n                                 phys_addr, &phys_addr, &l, false);\n\n    res = !(memory_region_is_ram(mr) || memory_region_is_romd(mr));\n    rcu_read_unlock();\n    return res;\n}\n\nint qemu_ram_foreach_block(RAMBlockIterFunc func, void *opaque)\n{\n    RAMBlock *block;\n    int ret = 0;\n\n    rcu_read_lock();\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        ret = func(block->idstr, block->host, block->offset,\n                   block->used_length, opaque);\n        if (ret) {\n            break;\n        }\n    }\n    rcu_read_unlock();\n    return ret;\n}\n\n/*\n * Unmap pages of memory from start to start+length such that\n * they a) read as 0, b) Trigger whatever fault mechanism\n * the OS provides for postcopy.\n * The pages must be unmapped by the end of the function.\n * Returns: 0 on success, none-0 on failure\n *\n */\nint ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length)\n{\n    int ret = -1;\n\n    uint8_t *host_startaddr = rb->host + start;\n\n    if ((uintptr_t)host_startaddr & (rb->page_size - 1)) {\n        error_report(\"ram_block_discard_range: Unaligned start address: %p\",\n                     host_startaddr);\n        goto err;\n    }\n\n    if ((start + length) <= rb->used_length) {\n        uint8_t *host_endaddr = host_startaddr + length;\n        if ((uintptr_t)host_endaddr & (rb->page_size - 1)) {\n            error_report(\"ram_block_discard_range: Unaligned end address: %p\",\n                         host_endaddr);\n            goto err;\n        }\n\n        errno = ENOTSUP; /* If we are missing MADVISE etc */\n\n        if (rb->page_size == qemu_host_page_size) {\n#if defined(CONFIG_MADVISE)\n            /* Note: We need the madvise MADV_DONTNEED behaviour of definitely\n             * freeing the page.\n             */\n            ret = madvise(host_startaddr, length, MADV_DONTNEED);\n#endif\n        } else {\n            /* Huge page case  - unfortunately it can't do DONTNEED, but\n             * it can do the equivalent by FALLOC_FL_PUNCH_HOLE in the\n             * huge page file.\n             */\n#ifdef CONFIG_FALLOCATE_PUNCH_HOLE\n            ret = fallocate(rb->fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n                            start, length);\n#endif\n        }\n        if (ret) {\n            ret = -errno;\n            error_report(\"ram_block_discard_range: Failed to discard range \"\n                         \"%s:%\" PRIx64 \" +%zx (%d)\",\n                         rb->idstr, start, length, ret);\n        }\n    } else {\n        error_report(\"ram_block_discard_range: Overrun block '%s' (%\" PRIu64\n                     \"/%zx/\" RAM_ADDR_FMT\")\",\n                     rb->idstr, start, length, rb->used_length);\n    }\n\nerr:\n    return ret;\n}\n\n#endif\n"
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 0.9541015625,
          "content": "{\n  \"nodes\": {\n    \"libosi-src\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1693574302,\n        \"narHash\": \"sha256-rHbfp1llyVEvHw+sz+rCmx9DrR/e1nnJYRidhPM3jZY=\",\n        \"owner\": \"panda-re\",\n        \"repo\": \"libosi\",\n        \"rev\": \"c68bafdb7e2a4d83128ae6ba0f5f70e28318eda0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"panda-re\",\n        \"repo\": \"libosi\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1699725108,\n        \"narHash\": \"sha256-NTiPW4jRC+9puakU4Vi8WpFEirhp92kTOSThuZke+FA=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"911ad1e67f458b6bcf0278fa85e33bb9924fed7e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"id\": \"nixpkgs\",\n        \"type\": \"indirect\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"libosi-src\": \"libosi-src\",\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 5.3779296875,
          "content": "{\n  description = \"PANDA: Platform for Architecture-Neutral Dynamic Analysis\";\n\n  inputs = {\n    libosi-src = {\n      url = \"github:panda-re/libosi\";\n      flake = false;\n    };\n  };\n\n  outputs = { self, nixpkgs, libosi-src }: {\n\n    packages.x86_64-linux.default = let\n\n      pkgs = import nixpkgs {\n        system = \"x86_64-linux\";\n        config.permittedInsecurePackages = [ \"libdwarf-20210528\" ];\n      };\n\n      pyPkgs = pkgs.python3Packages;\n\n      # We need to use an older version of wireshark, since 2.5.1 breaks the network plugin\n      wireshark = (import (pkgs.fetchFromGitHub {\n        owner = \"NixOS\";\n        repo = \"nixpkgs\";\n        rev = \"a7e0fb6ffcae252bdd0c85928f179c74c3492a89\";\n        hash = \"sha256-RdXz/U0JJvsABkGWhF4Cukl4KuZvOJvkci7EuizKid0=\";\n      }) { localSystem.system = \"x86_64-linux\"; }).wireshark-cli.overrideAttrs\n        (prev: {\n          outputs = [ \"out\" \"dev\" ];\n          postInstall = ''\n            ${prev.postInstall}\n\n            # Install headers\n            mkdir $dev/include/wireshark/{epan/{wmem,ftypes,dfilter},wsutil,wiretap} -pv\n            cp config.h $dev/include/wireshark\n            cp ../ws_*.h $dev/include/wireshark\n            cp ../epan/*.h $dev/include/wireshark/epan/\n            cp ../epan/wmem/*.h $dev/include/wireshark/epan/wmem/\n            cp ../epan/ftypes/*.h $dev/include/wireshark/epan/ftypes/\n            cp ../epan/dfilter/*.h $dev/include/wireshark/epan/dfilter/\n            cp ../wsutil/*.h $dev/include/wireshark/wsutil/\n            cp ../wiretap/*.h $dev/include/wireshark/wiretap\n          '';\n        });\n\n      libosi = pkgs.stdenv.mkDerivation {\n        name = \"libosi\";\n        src = libosi-src;\n        buildInputs = with pkgs; [ cmake pkg-config glib ];\n      };\n\n      default = pkgs.stdenv.mkDerivation {\n        name = \"panda\";\n        src = ./.;\n        cargoRoot = \"panda/plugins\";\n        cargoDeps = pkgs.rustPlatform.importCargoLock {\n          lockFile = ./panda/plugins/Cargo.lock;\n        };\n        buildInputs = (with pkgs; [\n          pkg-config\n          python3\n          zlib\n          glib\n          libarchive\n          openssl\n          pixman\n          capstone\n          protobufc\n          protobuf\n          cargo\n          curl\n          libdwarf_20210528\n          zip\n          libelf\n          jsoncpp\n        ]) ++ [ wireshark libosi ]\n          ++ (with pyPkgs; [ pycparser libfdt setuptools ]);\n        nativeBuildInputs = [ pkgs.rustPlatform.cargoSetupHook ];\n        propagatedBuildInputs = with pyPkgs; [ cffi colorama ];\n        enableParallelBuilding = true;\n        patches = [\n          (pkgs.writeText \"fix-rpath-error.patch\" ''\n            diff --git a/Makefile b/Makefile\n            index cc2064de42..8b357e9a9a 100644\n            --- a/Makefile\n            +++ b/Makefile\n            @@ -653,7 +653,6 @@ newtoobig=$(shell oldrp=\"$(rppart)\" ; oldrplen=`expr $''${$(number_sign)oldrp} - 6\n             endif\n\n             install: all $(if $(BUILD_DOCS),install-doc) install-datadir install-localstatedir\n            -ifeq ($(newtoobig), false)\n             ifneq ($(TOOLS),)\n             \t$(call install-prog,$(subst qemu-ga,qemu-ga$(EXESUF),$(TOOLS)),$(DESTDIR)$(bindir))\n             endif\n            @@ -684,9 +683,6 @@ endif\n             \tfor d in $(TARGET_DIRS); do \\\n             \t$(MAKE) $(SUBDIR_MAKEFLAGS) TARGET_DIR=$$d/ -C $$d $@ || exit 1 ; \\\n                     done\n            -else\n            -\t$(error new RPATH too long - cannot adjust .so files for installation)\n            -endif\n\n             # various test targets\n             test speed: all\n          '')\n        ];\n        postPatch = ''\n          patchShebangs .\n          substituteInPlace rules.mak \\\n            --replace 'std=c++11' 'std=c++17'\n          substituteInPlace panda/plugins/network/Makefile \\\n            --replace '/usr/include/wireshark' '${wireshark.dev}/include/wireshark'\n          substituteInPlace panda/plugins/pri_dwarf/*.{h,cpp} \\\n            --replace '<libdwarf/' '<'\n          substituteInPlace panda/python/core/pandare/utils.py \\\n            --replace \\\n            'pjoin(python_package, arch_dir), pjoin(local_build, arch_dir)' \\\n            'realpath(pjoin(dirname(__file__), \"../../../../bin\"))'\n          substituteInPlace panda/python/core/pandare/panda.py \\\n            --replace 'self.plugin_path = plugin_path' \"self.plugin_path = plugin_path or pjoin('$out', 'lib/panda', arch)\" \\\n            --replace 'if libpanda_path:' 'if True:' \\\n            --replace '= libpanda_path' \"= libpanda_path or pjoin('$out', 'bin', f'libpanda-{arch}.so')\" \\\n            --replace 'realpath(pjoin(self.get_build_dir(), \"pc-bios\"))' \"pjoin('$out', 'share/panda')\"\n        '';\n        preConfigure = \"mkdir build && cd build\";\n        configureScript = \"../configure\";\n        configureFlags = [\n          \"--target-list=${\n            builtins.concatStringsSep \",\" [\n              \"x86_64-softmmu\"\n              \"i386-softmmu\"\n              \"arm-softmmu\"\n              \"aarch64-softmmu\"\n              \"ppc-softmmu\"\n              \"mips-softmmu\"\n              \"mipsel-softmmu\"\n              \"mips64-softmmu\"\n            ]\n          }\"\n          \"--disable-numa\"\n          # TODO: \"--enable-llvm\"\n        ];\n        postInstall = ''\n          rm -r $out/lib/panda/*/{cosi,cosi_strace,gdb,snake_hook,rust_skeleton}\n          (\n            cd ../panda/python/core\n            python3 setup.py install --prefix \"$out\"\n          )\n        '';\n      };\n\n    in default;\n\n  };\n}\n"
        },
        {
          "name": "fpu",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsdev",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdb-xml",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdbstub.c",
          "type": "blob",
          "size": 55.2958984375,
          "content": "/*\n * gdb server stub\n *\n * Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/cutils.h\"\n#include \"cpu.h\"\n#ifdef CONFIG_USER_ONLY\n#include \"qemu.h\"\n#else\n#include \"monitor/monitor.h\"\n#include \"sysemu/char.h\"\n#include \"sysemu/sysemu.h\"\n#include \"exec/gdbstub.h\"\n#endif\n\n#define MAX_PACKET_LENGTH 4096\n\n#include \"qemu/sockets.h\"\n#include \"sysemu/hw_accel.h\"\n#include \"sysemu/kvm.h\"\n#include \"exec/semihost.h\"\n#include \"exec/exec-all.h\"\n#include \"panda/checkpoint.h\"\n\n#ifdef CONFIG_USER_ONLY\n#define GDB_ATTACHED \"0\"\n#else\n#define GDB_ATTACHED \"1\"\n#endif\nstatic inline int target_memory_rw_debug(CPUState *cpu, target_ulong addr, uint8_t *buf, int len, bool is_write)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    if (cc->memory_rw_debug) {\n        return cc->memory_rw_debug(cpu, addr, buf, len, is_write);\n    }\n    return cpu_memory_rw_debug(cpu, addr, buf, len, is_write);\n}\n\nenum {\n    GDB_SIGNAL_0 = 0,\n    GDB_SIGNAL_INT = 2,\n    GDB_SIGNAL_QUIT = 3,\n    GDB_SIGNAL_TRAP = 5,\n    GDB_SIGNAL_ABRT = 6,\n    GDB_SIGNAL_ALRM = 14,\n    GDB_SIGNAL_IO = 23,\n    GDB_SIGNAL_XCPU = 24,\n    GDB_SIGNAL_UNKNOWN = 143\n};\n\n#ifdef CONFIG_USER_ONLY\n\n/* Map target signal numbers to GDB protocol signal numbers and vice\n * versa.  For user emulation's currently supported systems, we can\n * assume most signals are defined.\n */\n\nstatic int gdb_signal_table[] = {\n    0,\n    TARGET_SIGHUP,\n    TARGET_SIGINT,\n    TARGET_SIGQUIT,\n    TARGET_SIGILL,\n    TARGET_SIGTRAP,\n    TARGET_SIGABRT,\n    -1, /* SIGEMT */\n    TARGET_SIGFPE,\n    TARGET_SIGKILL,\n    TARGET_SIGBUS,\n    TARGET_SIGSEGV,\n    TARGET_SIGSYS,\n    TARGET_SIGPIPE,\n    TARGET_SIGALRM,\n    TARGET_SIGTERM,\n    TARGET_SIGURG,\n    TARGET_SIGSTOP,\n    TARGET_SIGTSTP,\n    TARGET_SIGCONT,\n    TARGET_SIGCHLD,\n    TARGET_SIGTTIN,\n    TARGET_SIGTTOU,\n    TARGET_SIGIO,\n    TARGET_SIGXCPU,\n    TARGET_SIGXFSZ,\n    TARGET_SIGVTALRM,\n    TARGET_SIGPROF,\n    TARGET_SIGWINCH,\n    -1, /* SIGLOST */\n    TARGET_SIGUSR1,\n    TARGET_SIGUSR2,\n#ifdef TARGET_SIGPWR\n    TARGET_SIGPWR,\n#else\n    -1,\n#endif\n    -1, /* SIGPOLL */\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n#ifdef __SIGRTMIN\n    __SIGRTMIN + 1,\n    __SIGRTMIN + 2,\n    __SIGRTMIN + 3,\n    __SIGRTMIN + 4,\n    __SIGRTMIN + 5,\n    __SIGRTMIN + 6,\n    __SIGRTMIN + 7,\n    __SIGRTMIN + 8,\n    __SIGRTMIN + 9,\n    __SIGRTMIN + 10,\n    __SIGRTMIN + 11,\n    __SIGRTMIN + 12,\n    __SIGRTMIN + 13,\n    __SIGRTMIN + 14,\n    __SIGRTMIN + 15,\n    __SIGRTMIN + 16,\n    __SIGRTMIN + 17,\n    __SIGRTMIN + 18,\n    __SIGRTMIN + 19,\n    __SIGRTMIN + 20,\n    __SIGRTMIN + 21,\n    __SIGRTMIN + 22,\n    __SIGRTMIN + 23,\n    __SIGRTMIN + 24,\n    __SIGRTMIN + 25,\n    __SIGRTMIN + 26,\n    __SIGRTMIN + 27,\n    __SIGRTMIN + 28,\n    __SIGRTMIN + 29,\n    __SIGRTMIN + 30,\n    __SIGRTMIN + 31,\n    -1, /* SIGCANCEL */\n    __SIGRTMIN,\n    __SIGRTMIN + 32,\n    __SIGRTMIN + 33,\n    __SIGRTMIN + 34,\n    __SIGRTMIN + 35,\n    __SIGRTMIN + 36,\n    __SIGRTMIN + 37,\n    __SIGRTMIN + 38,\n    __SIGRTMIN + 39,\n    __SIGRTMIN + 40,\n    __SIGRTMIN + 41,\n    __SIGRTMIN + 42,\n    __SIGRTMIN + 43,\n    __SIGRTMIN + 44,\n    __SIGRTMIN + 45,\n    __SIGRTMIN + 46,\n    __SIGRTMIN + 47,\n    __SIGRTMIN + 48,\n    __SIGRTMIN + 49,\n    __SIGRTMIN + 50,\n    __SIGRTMIN + 51,\n    __SIGRTMIN + 52,\n    __SIGRTMIN + 53,\n    __SIGRTMIN + 54,\n    __SIGRTMIN + 55,\n    __SIGRTMIN + 56,\n    __SIGRTMIN + 57,\n    __SIGRTMIN + 58,\n    __SIGRTMIN + 59,\n    __SIGRTMIN + 60,\n    __SIGRTMIN + 61,\n    __SIGRTMIN + 62,\n    __SIGRTMIN + 63,\n    __SIGRTMIN + 64,\n    __SIGRTMIN + 65,\n    __SIGRTMIN + 66,\n    __SIGRTMIN + 67,\n    __SIGRTMIN + 68,\n    __SIGRTMIN + 69,\n    __SIGRTMIN + 70,\n    __SIGRTMIN + 71,\n    __SIGRTMIN + 72,\n    __SIGRTMIN + 73,\n    __SIGRTMIN + 74,\n    __SIGRTMIN + 75,\n    __SIGRTMIN + 76,\n    __SIGRTMIN + 77,\n    __SIGRTMIN + 78,\n    __SIGRTMIN + 79,\n    __SIGRTMIN + 80,\n    __SIGRTMIN + 81,\n    __SIGRTMIN + 82,\n    __SIGRTMIN + 83,\n    __SIGRTMIN + 84,\n    __SIGRTMIN + 85,\n    __SIGRTMIN + 86,\n    __SIGRTMIN + 87,\n    __SIGRTMIN + 88,\n    __SIGRTMIN + 89,\n    __SIGRTMIN + 90,\n    __SIGRTMIN + 91,\n    __SIGRTMIN + 92,\n    __SIGRTMIN + 93,\n    __SIGRTMIN + 94,\n    __SIGRTMIN + 95,\n    -1, /* SIGINFO */\n    -1, /* UNKNOWN */\n    -1, /* DEFAULT */\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n#endif\n};\n#else\n/* In system mode we only need SIGINT and SIGTRAP; other signals\n   are not yet supported.  */\n\nenum {\n    TARGET_SIGINT = 2,\n    TARGET_SIGTRAP = 5\n};\n\nstatic int gdb_signal_table[] = {\n    -1,\n    -1,\n    TARGET_SIGINT,\n    -1,\n    -1,\n    TARGET_SIGTRAP\n};\n#endif\n\n#ifdef CONFIG_USER_ONLY\nstatic int target_signal_to_gdb (int sig)\n{\n    int i;\n    for (i = 0; i < ARRAY_SIZE (gdb_signal_table); i++)\n        if (gdb_signal_table[i] == sig)\n            return i;\n    return GDB_SIGNAL_UNKNOWN;\n}\n#endif\n\nstatic int gdb_signal_to_target (int sig)\n{\n    if (sig < ARRAY_SIZE (gdb_signal_table))\n        return gdb_signal_table[sig];\n    else\n        return -1;\n}\n\n/*#define DEBUG_GDB*/\n\ntypedef struct GDBRegisterState {\n    int base_reg;\n    int num_regs;\n    gdb_reg_cb get_reg;\n    gdb_reg_cb set_reg;\n    const char *xml;\n    struct GDBRegisterState *next;\n} GDBRegisterState;\n\nenum RSState {\n    RS_INACTIVE,\n    RS_IDLE,\n    RS_GETLINE,\n    RS_CHKSUM1,\n    RS_CHKSUM2,\n};\ntypedef struct GDBState {\n    CPUState *c_cpu; /* current CPU for step/continue ops */\n    CPUState *g_cpu; /* current CPU for other ops */\n    CPUState *query_cpu; /* for q{f|s}ThreadInfo */\n    enum RSState state; /* parsing state */\n    char line_buf[MAX_PACKET_LENGTH];\n    int line_buf_index;\n    int line_csum;\n    uint8_t last_packet[MAX_PACKET_LENGTH + 4];\n    int last_packet_len;\n    int signal;\n#ifdef CONFIG_USER_ONLY\n    int fd;\n    int running_state;\n#else\n    CharBackend chr;\n    Chardev *mon_chr;\n#endif\n    char syscall_buf[256];\n    gdb_syscall_complete_cb current_syscall_cb;\n} GDBState;\n\n/* By default use no IRQs and no timers while single stepping so as to\n * make single stepping like an ICE HW step.\n */\nstatic int sstep_flags = SSTEP_ENABLE|SSTEP_NOIRQ|SSTEP_NOTIMER;\n\nstatic GDBState *gdbserver_state;\n\nbool gdb_has_xml;\n\n#ifdef CONFIG_USER_ONLY\n/* XXX: This is not thread safe.  Do we care?  */\nstatic int gdbserver_fd = -1;\n\nstatic int get_char(GDBState *s)\n{\n    uint8_t ch;\n    int ret;\n\n    for(;;) {\n        ret = qemu_recv(s->fd, &ch, 1, 0);\n        if (ret < 0) {\n            if (errno == ECONNRESET)\n                s->fd = -1;\n            if (errno != EINTR)\n                return -1;\n        } else if (ret == 0) {\n            close(s->fd);\n            s->fd = -1;\n            return -1;\n        } else {\n            break;\n        }\n    }\n    return ch;\n}\n#endif\n\nstatic enum {\n    GDB_SYS_UNKNOWN,\n    GDB_SYS_ENABLED,\n    GDB_SYS_DISABLED,\n} gdb_syscall_mode;\n\n/* Decide if either remote gdb syscalls or native file IO should be used. */\nint use_gdb_syscalls(void)\n{\n    SemihostingTarget target = semihosting_get_target();\n    if (target == SEMIHOSTING_TARGET_NATIVE) {\n        /* -semihosting-config target=native */\n        return false;\n    } else if (target == SEMIHOSTING_TARGET_GDB) {\n        /* -semihosting-config target=gdb */\n        return true;\n    }\n\n    /* -semihosting-config target=auto */\n    /* On the first call check if gdb is connected and remember. */\n    if (gdb_syscall_mode == GDB_SYS_UNKNOWN) {\n        gdb_syscall_mode = (gdbserver_state ? GDB_SYS_ENABLED\n                                            : GDB_SYS_DISABLED);\n    }\n    return gdb_syscall_mode == GDB_SYS_ENABLED;\n}\n\n/* Resume execution.  */\nstatic inline void gdb_continue(GDBState *s)\n{\n#ifdef CONFIG_USER_ONLY\n    s->running_state = 1;\n#else\n    if (!runstate_needs_reset()) {\n        vm_start();\n    }\n#endif\n}\n\nstatic void disable_cur_rr_bp_and_wp(CPUState* cpu) {\n\tCPUBreakpoint* bp;\n\tQTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\t\tif (bp->rr_instr_count != 0 && rr_get_guest_instr_count() == bp->rr_instr_count) {\n\t\t\tprintf(\"temp removing bp at rr instr %\" PRIu64 \"\\n\", bp->rr_instr_count);\n\t\t\tcpu_breakpoint_remove_by_instr(cpu, bp->rr_instr_count, BP_GDB);\n\t\t\tcpu->temp_rr_bp_instr = bp->rr_instr_count;\n\t\t}\n\t}\n\n\t// If we are currently broken at watchpoint, disable it until we get past it\n\t// reenabled in exec.c: check_watchpoint\n\tcpu->watchpoints_disabled = true;\n}\n\n/*\n * Resume execution, per CPU actions. For user-mode emulation it's\n * equivalent to gdb_continue.\n */\nstatic int gdb_continue_partial(GDBState *s, char *newstates)\n{\n    CPUState *cpu;\n    int res = 0;\n#ifdef CONFIG_USER_ONLY\n    /*\n     * This is not exactly accurate, but it's an improvement compared to the\n     * previous situation, where only one CPU would be single-stepped.\n     */\n    CPU_FOREACH(cpu) {\n        if (newstates[cpu->cpu_index] == 's') {\n            cpu_single_step(cpu, sstep_flags);\n        }\n    }\n    s->running_state = 1;\n#else\n    int flag = 0;\n\n    if (!runstate_needs_reset()) {\n        if (vm_prepare_start()) {\n            return 0;\n        }\n\n        CPU_FOREACH(cpu) {\n            switch (newstates[cpu->cpu_index]) {\n            case 0:\n            case 1:\n                break; /* nothing to do here */\n            case 's':\n                cpu_single_step(cpu, sstep_flags);\n                cpu_resume(cpu);\n                \n\t\t\t\t// If we are broken at an rr breakpoint, disable it before continuing\n                // and reenable it after we get past the instruction\n\t\t\t\tdisable_cur_rr_bp_and_wp(cpu);\n                flag = 1;\n                break;\n            case 'c':\n                cpu_resume(cpu);\n\t\t\t\t\n\t\t\t\t// If we are broken at an rr breakpoint, disable it before continuing\n                // and reenable it after we get past the instruction\n\t\t\t\tdisable_cur_rr_bp_and_wp(cpu);\n                flag = 1;\n                break;\n            default:\n                res = -1;\n                break;\n            }\n        }\n    }\n    if (flag) {\n        qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);\n    }\n#endif\n    return res;\n}\n\n\nstatic void put_buffer(GDBState *s, const uint8_t *buf, int len)\n{\n#ifdef CONFIG_USER_ONLY\n    int ret;\n\n    while (len > 0) {\n        ret = send(s->fd, buf, len, 0);\n        if (ret < 0) {\n            if (errno != EINTR)\n                return;\n        } else {\n            buf += ret;\n            len -= ret;\n        }\n    }\n#else\n    /* XXX this blocks entire thread. Rewrite to use\n     * qemu_chr_fe_write and background I/O callbacks */\n    qemu_chr_fe_write_all(&s->chr, buf, len);\n#endif\n}\n\nstatic inline int fromhex(int v)\n{\n    if (v >= '0' && v <= '9')\n        return v - '0';\n    else if (v >= 'A' && v <= 'F')\n        return v - 'A' + 10;\n    else if (v >= 'a' && v <= 'f')\n        return v - 'a' + 10;\n    else\n        return 0;\n}\n\nstatic inline int tohex(int v)\n{\n    if (v < 10)\n        return v + '0';\n    else\n        return v - 10 + 'a';\n}\n\nstatic void memtohex(char *buf, const uint8_t *mem, int len)\n{\n    int i, c;\n    char *q;\n    q = buf;\n    for(i = 0; i < len; i++) {\n        c = mem[i];\n        *q++ = tohex(c >> 4);\n        *q++ = tohex(c & 0xf);\n    }\n    *q = '\\0';\n}\n\nstatic void hextomem(uint8_t *mem, const char *buf, int len)\n{\n    int i;\n\n    for(i = 0; i < len; i++) {\n        mem[i] = (fromhex(buf[0]) << 4) | fromhex(buf[1]);\n        buf += 2;\n    }\n}\n\n/* return -1 if error, 0 if OK */\nstatic int put_packet_binary(GDBState *s, const char *buf, int len)\n{\n    int csum, i;\n    uint8_t *p;\n\n    for(;;) {\n        p = s->last_packet;\n        *(p++) = '$';\n        memcpy(p, buf, len);\n        p += len;\n        csum = 0;\n        for(i = 0; i < len; i++) {\n            csum += buf[i];\n        }\n        *(p++) = '#';\n        *(p++) = tohex((csum >> 4) & 0xf);\n        *(p++) = tohex((csum) & 0xf);\n\n        s->last_packet_len = p - s->last_packet;\n        put_buffer(s, (uint8_t *)s->last_packet, s->last_packet_len);\n\n#ifdef CONFIG_USER_ONLY\n        i = get_char(s);\n        if (i < 0)\n            return -1;\n        if (i == '+')\n            break;\n#else\n        break;\n#endif\n    }\n    return 0;\n}\n\n/* return -1 if error, 0 if OK */\nstatic int put_packet(GDBState *s, const char *buf)\n{\n#ifdef DEBUG_GDB\n    printf(\"reply='%s'\\n\", buf);\n#endif\n\n    return put_packet_binary(s, buf, strlen(buf));\n}\n\n/* Encode data using the encoding for 'x' packets.  */\nstatic int memtox(char *buf, const char *mem, int len)\n{\n    char *p = buf;\n    char c;\n\n    while (len--) {\n        c = *(mem++);\n        switch (c) {\n        case '#': case '$': case '*': case '}':\n            *(p++) = '}';\n            *(p++) = c ^ 0x20;\n            break;\n        default:\n            *(p++) = c;\n            break;\n        }\n    }\n    return p - buf;\n}\n\nstatic const char *get_feature_xml(const char *p, const char **newp,\n                                   CPUClass *cc)\n{\n    size_t len;\n    int i;\n    const char *name;\n    static char target_xml[1024];\n\n    len = 0;\n    while (p[len] && p[len] != ':')\n        len++;\n    *newp = p + len;\n\n    name = NULL;\n    if (strncmp(p, \"target.xml\", len) == 0) {\n        /* Generate the XML description for this CPU.  */\n        if (!target_xml[0]) {\n            GDBRegisterState *r;\n            CPUState *cpu = first_cpu;\n\n            pstrcat(target_xml, sizeof(target_xml),\n                    \"<?xml version=\\\"1.0\\\"?>\"\n                    \"<!DOCTYPE target SYSTEM \\\"gdb-target.dtd\\\">\"\n                    \"<target>\");\n            if (cc->gdb_arch_name) {\n                gchar *arch = cc->gdb_arch_name(cpu);\n                pstrcat(target_xml, sizeof(target_xml), \"<architecture>\");\n                pstrcat(target_xml, sizeof(target_xml), arch);\n                pstrcat(target_xml, sizeof(target_xml), \"</architecture>\");\n                g_free(arch);\n            }\n            pstrcat(target_xml, sizeof(target_xml), \"<xi:include href=\\\"\");\n            pstrcat(target_xml, sizeof(target_xml), cc->gdb_core_xml_file);\n            pstrcat(target_xml, sizeof(target_xml), \"\\\"/>\");\n            for (r = cpu->gdb_regs; r; r = r->next) {\n                pstrcat(target_xml, sizeof(target_xml), \"<xi:include href=\\\"\");\n                pstrcat(target_xml, sizeof(target_xml), r->xml);\n                pstrcat(target_xml, sizeof(target_xml), \"\\\"/>\");\n            }\n            pstrcat(target_xml, sizeof(target_xml), \"</target>\");\n        }\n        return target_xml;\n    }\n    for (i = 0; ; i++) {\n        name = xml_builtin[i][0];\n        if (!name || (strncmp(name, p, len) == 0 && strlen(name) == len))\n            break;\n    }\n    return name ? xml_builtin[i][1] : NULL;\n}\n\nstatic int gdb_read_register(CPUState *cpu, uint8_t *mem_buf, int reg)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = cpu->env_ptr;\n    GDBRegisterState *r;\n\n    if (reg < cc->gdb_num_core_regs) {\n        return cc->gdb_read_register(cpu, mem_buf, reg);\n    }\n\n    for (r = cpu->gdb_regs; r; r = r->next) {\n        if (r->base_reg <= reg && reg < r->base_reg + r->num_regs) {\n            return r->get_reg(env, mem_buf, reg - r->base_reg);\n        }\n    }\n    return 0;\n}\n\nint gdb_write_register(CPUState *cpu, uint8_t *mem_buf, int reg)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = cpu->env_ptr;\n    GDBRegisterState *r;\n    int ret = 0;\n\n\n    if (reg < cc->gdb_num_core_regs) {\n        ret = cc->gdb_write_register(cpu, mem_buf, reg);\n    }\n\n    for (r = cpu->gdb_regs; r; r = r->next) {\n        if (r->base_reg <= reg && reg < r->base_reg + r->num_regs) {\n            ret = r->set_reg(env, mem_buf, reg - r->base_reg);\n        }\n    }\n    if (rr_in_record()) {\n        /* mm: to play along with the gdb rsp, the return value of \n         * gdb_write_register *should* return the size of the register, which\n         * give us insight about the expected size of mem_buf */\n        rr_cpu_reg_write_call_record(cpu->cpu_index, mem_buf, reg, ret);\n    }\n    return ret;\n}\n\n/* Register a supplemental set of CPU registers.  If g_pos is nonzero it\n   specifies the first register number and these registers are included in\n   a standard \"g\" packet.  Direction is relative to gdb, i.e. get_reg is\n   gdb reading a CPU register, and set_reg is gdb modifying a CPU register.\n */\n\nvoid gdb_register_coprocessor(CPUState *cpu,\n                              gdb_reg_cb get_reg, gdb_reg_cb set_reg,\n                              int num_regs, const char *xml, int g_pos)\n{\n    GDBRegisterState *s;\n    GDBRegisterState **p;\n\n    p = &cpu->gdb_regs;\n    while (*p) {\n        /* Check for duplicates.  */\n        if (strcmp((*p)->xml, xml) == 0)\n            return;\n        p = &(*p)->next;\n    }\n\n    s = g_new0(GDBRegisterState, 1);\n    s->base_reg = cpu->gdb_num_regs;\n    s->num_regs = num_regs;\n    s->get_reg = get_reg;\n    s->set_reg = set_reg;\n    s->xml = xml;\n\n    /* Add to end of list.  */\n    cpu->gdb_num_regs += num_regs;\n    *p = s;\n    if (g_pos) {\n        if (g_pos != s->base_reg) {\n            error_report(\"Error: Bad gdb register numbering for '%s', \"\n                         \"expected %d got %d\", xml, g_pos, s->base_reg);\n        } else {\n            cpu->gdb_num_g_regs = cpu->gdb_num_regs;\n        }\n    }\n}\n\n#ifndef CONFIG_USER_ONLY\n/* Translate GDB watchpoint type to a flags value for cpu_watchpoint_* */\nstatic inline int xlat_gdb_type(CPUState *cpu, int gdbtype)\n{\n    static const int xlat[] = {\n        [GDB_WATCHPOINT_WRITE]  = BP_GDB | BP_MEM_WRITE,\n        [GDB_WATCHPOINT_READ]   = BP_GDB | BP_MEM_READ,\n        [GDB_WATCHPOINT_ACCESS] = BP_GDB | BP_MEM_ACCESS,\n    };\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    int cputype = xlat[gdbtype];\n\n    if (cc->gdb_stop_before_watchpoint) {\n        cputype |= BP_STOP_BEFORE_ACCESS;\n    }\n    return cputype;\n}\n#endif\n\nstatic int gdb_rr_breakpoint_insert(uint64_t instr_count, int type) {\n    CPUState* cpu;\n    int err = 0;\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_rr_breakpoint_insert(cpu, instr_count, BP_GDB, NULL);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n//#ifndef CONFIG_USER_ONLY\n    //case GDB_WATCHPOINT_WRITE:\n    //case GDB_WATCHPOINT_READ:\n    //case GDB_WATCHPOINT_ACCESS:\n        //CPU_FOREACH(cpu) {\n            //err = cpu_rrwatchpoint_insert(cpu, addr, len,\n                                        //xlat_gdb_type(cpu, type), NULL);\n            //if (err) {\n                //break;\n            //}\n        //}\n        //return err;\n//#endif\n    default:\n        return -ENOSYS;\n    }\n}\n\nstatic int gdb_breakpoint_insert(target_ulong addr, target_ulong len, int type)\n{\n    CPUState *cpu;\n    int err = 0;\n\n    if (kvm_enabled()) {\n        return kvm_insert_breakpoint(gdbserver_state->c_cpu, addr, len, type);\n    }\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_breakpoint_insert(cpu, addr, BP_GDB, NULL);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#ifndef CONFIG_USER_ONLY\n    case GDB_WATCHPOINT_WRITE:\n    case GDB_WATCHPOINT_READ:\n    case GDB_WATCHPOINT_ACCESS:\n        CPU_FOREACH(cpu) {\n            err = cpu_watchpoint_insert(cpu, addr, len,\n                                        xlat_gdb_type(cpu, type), NULL);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#endif\n    default:\n        return -ENOSYS;\n    }\n}\n\nstatic int gdb_rr_breakpoint_remove(uint64_t instr, int type) {\n    CPUState *cpu;\n    int err = 0;\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_breakpoint_remove_by_instr(cpu, instr, BP_GDB);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n//#ifndef CONFIG_USER_ONLY\n    //case GDB_WATCHPOINT_WRITE:\n    //case GDB_WATCHPOINT_READ:\n    //case GDB_WATCHPOINT_ACCESS:\n        //CPU_FOREACH(cpu) {\n            //err = cpu_watchpoint_remove(cpu, addr, len,\n                                        //xlat_gdb_type(cpu, type));\n            //if (err)\n                //break;\n\t\t/*}*/\n\t\t/*return err;*/\n//#endif\n    default:\n        return -ENOSYS;\n    }\n\t\n}\n\nstatic int gdb_breakpoint_remove(target_ulong addr, target_ulong len, int type)\n{\n    CPUState *cpu;\n    int err = 0;\n\n    if (kvm_enabled()) {\n        return kvm_remove_breakpoint(gdbserver_state->c_cpu, addr, len, type);\n    }\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_breakpoint_remove(cpu, addr, BP_GDB);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#ifndef CONFIG_USER_ONLY\n    case GDB_WATCHPOINT_WRITE:\n    case GDB_WATCHPOINT_READ:\n    case GDB_WATCHPOINT_ACCESS:\n        CPU_FOREACH(cpu) {\n            err = cpu_watchpoint_remove(cpu, addr, len,\n                                        xlat_gdb_type(cpu, type));\n            if (err)\n                break;\n        }\n        return err;\n#endif\n    default:\n        return -ENOSYS;\n    }\n}\n\nstatic void gdb_breakpoint_remove_all(void)\n{\n    CPUState *cpu;\n\n    if (kvm_enabled()) {\n        kvm_remove_all_breakpoints(gdbserver_state->c_cpu);\n        return;\n    }\n\n    CPU_FOREACH(cpu) {\n        cpu_breakpoint_remove_all(cpu, BP_GDB);\n#ifndef CONFIG_USER_ONLY\n        cpu_watchpoint_remove_all(cpu, BP_GDB);\n#endif\n    }\n}\n\nstatic void gdb_set_cpu_pc(GDBState *s, target_ulong pc)\n{\n    CPUState *cpu = s->c_cpu;\n\n    cpu_synchronize_state(cpu);\n    cpu_set_pc(cpu, pc);\n}\n\nstatic CPUState *find_cpu(uint32_t thread_id)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu_index(cpu) == thread_id) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\nstatic int is_query_packet(const char *p, const char *query, char separator)\n{\n    unsigned int query_len = strlen(query);\n\n    return strncmp(p, query, query_len) == 0 &&\n        (p[query_len] == '\\0' || p[query_len] == separator);\n}\n\n/**\n * gdb_handle_vcont - Parses and handles a vCont packet.\n * returns -ENOTSUP if a command is unsupported, -EINVAL or -ERANGE if there is\n *         a format error, 0 on success.\n */\nstatic int gdb_handle_vcont(GDBState *s, const char *p)\n{\n    int res, idx, signal = 0;\n    char cur_action;\n    char *newstates;\n    unsigned long tmp;\n    CPUState *cpu;\n#ifdef CONFIG_USER_ONLY\n    int max_cpus = 1; /* global variable max_cpus exists only in system mode */\n\n    CPU_FOREACH(cpu) {\n        max_cpus = max_cpus <= cpu->cpu_index ? cpu->cpu_index + 1 : max_cpus;\n    }\n#endif\n    /* uninitialised CPUs stay 0 */\n    newstates = g_new0(char, max_cpus);\n\n    /* mark valid CPUs with 1 */\n    CPU_FOREACH(cpu) {\n        newstates[cpu->cpu_index] = 1;\n    }\n\n    /*\n     * res keeps track of what error we are returning, with -ENOTSUP meaning\n     * that the command is unknown or unsupported, thus returning an empty\n     * packet, while -EINVAL and -ERANGE cause an E22 packet, due to invalid,\n     *  or incorrect parameters passed.\n     */\n    res = 0;\n    while (*p) {\n        if (*p++ != ';') {\n            res = -ENOTSUP;\n            goto out;\n        }\n\n        cur_action = *p++;\n        if (cur_action == 'C' || cur_action == 'S') {\n            cur_action = tolower(cur_action);\n            res = qemu_strtoul(p + 1, &p, 16, &tmp);\n            if (res) {\n                goto out;\n            }\n            signal = gdb_signal_to_target(tmp);\n        } else if (cur_action != 'c' && cur_action != 's') {\n            /* unknown/invalid/unsupported command */\n            res = -ENOTSUP;\n            goto out;\n        }\n        /* thread specification. special values: (none), -1 = all; 0 = any */\n        if ((p[0] == ':' && p[1] == '-' && p[2] == '1') || (p[0] != ':')) {\n            if (*p == ':') {\n                p += 3;\n            }\n            for (idx = 0; idx < max_cpus; idx++) {\n                if (newstates[idx] == 1) {\n                    newstates[idx] = cur_action;\n                }\n            }\n        } else if (*p == ':') {\n            p++;\n            res = qemu_strtoul(p, &p, 16, &tmp);\n            if (res) {\n                goto out;\n            }\n            idx = tmp;\n            /* 0 means any thread, so we pick the first valid CPU */\n            if (!idx) {\n                idx = cpu_index(first_cpu);\n            }\n\n            /*\n             * If we are in user mode, the thread specified is actually a\n             * thread id, and not an index. We need to find the actual\n             * CPU first, and only then we can use its index.\n             */\n            cpu = find_cpu(idx);\n            /* invalid CPU/thread specified */\n            if (!idx || !cpu) {\n                res = -EINVAL;\n                goto out;\n            }\n            /* only use if no previous match occourred */\n            if (newstates[cpu->cpu_index] == 1) {\n                newstates[cpu->cpu_index] = cur_action;\n            }\n        }\n    }\n    s->signal = signal;\n    gdb_continue_partial(s, newstates);\n\nout:\n    g_free(newstates);\n\n    return res;\n}\n\nstatic void gdb_handle_reverse(GDBState *s, const char *p) {\n\tuint64_t cur_instr_count = rr_get_guest_instr_count();\n\n\tif (*p == 's') {\n\t\t// Reverse step\n\t\tint res = gdb_rr_breakpoint_insert(cur_instr_count-1, GDB_BREAKPOINT_SW);\n\t\tif (res < 0) {\n\t\t\tput_packet(s, \"E22\");\n\t\t\treturn;\n\t\t}\n\t\ts->c_cpu->reverse_flags = GDB_RSTEP;\n\t\ts->c_cpu->last_gdb_instr = cur_instr_count; \n\t} else if (*p == 'c') {\n\t\t// Reverse continue\n\t\ts->c_cpu->reverse_flags = GDB_RCONT ;\n\t\ts->c_cpu->last_gdb_instr = cur_instr_count; \n\t\ts->c_cpu->last_bp_hit_instr = 0;\n\t}\n\n\t// revert to most recent checkpoint \n\tint closest_num;\n\tif ((closest_num = get_closest_checkpoint_num(cur_instr_count)) < 0) {\n\t\tfprintf(stderr, \"gdb_handle_reverse: get_closest_checkpoint_num %d\\n\", closest_num); \n\t\tabort();\n\t}\n\n\ttb_flush(s->c_cpu);\n\ttlb_flush(s->c_cpu);\n\tpanda_restore_by_num(closest_num);\n\tgdb_continue(s);\n}\n\nstatic void gdb_handle_panda_cmd(GDBState *s, const char* p) {\n    char buf[MAX_PACKET_LENGTH] = {0};\n\tchar membuf[MAX_PACKET_LENGTH] = {0};\n\n    int chars_written;\n    if (!strncmp(p, \"when\", 4)) {\n        snprintf(membuf, sizeof(membuf), \"%\" PRIu64, rr_get_guest_instr_count());\n\t\t\n\t\tmemtohex(buf, (uint8_t*)membuf, strlen(membuf));\n        put_packet(s, buf);\n    } else if (!strncmp(p, \"rrbreakpoint\", 12)) {\n        p+=12;\n        int membufsize = 0;\n        const char msg[] = \"Added breakpoints at instructions\";\n        snprintf(membuf, sizeof(membuf), msg); \n        membufsize += sizeof(msg)-1;\n        while (*p == ':') {\n            p++;\n            uint64_t bpinstr = strtoull(p, (char **)&p, 10);\n            chars_written = snprintf(membuf+membufsize, sizeof(membuf), \" %\" PRIu64 \",\", bpinstr); \n            membufsize += chars_written;\n            gdb_rr_breakpoint_insert(bpinstr, GDB_BREAKPOINT_SW);\n        }\n\n\t\tif (membufsize > MAX_PACKET_LENGTH/2)\n\t\t\tmembufsize = MAX_PACKET_LENGTH/2;\n        \n\t\tmemtohex(buf, (uint8_t*)membuf, membufsize);\n        put_packet(s, buf);\n    } else if (!strncmp(p, \"rrdelete\", 8)) {\n\t\t// delete rr instr breakpoint\n\t\tp += 8;\n        int membufsize = 0;\n        const char msg[] = \"Deleted breakpoints at instructions\";\n        snprintf(membuf, sizeof(membuf), msg); \n        membufsize += sizeof(msg)-1;\n\n        while (*p == ':') {\n            p++;\n            uint64_t bpinstr = strtoull(p, (char **)&p, 10);\n            chars_written = snprintf(membuf+membufsize, sizeof(membuf), \" %\" PRIu64 \",\", bpinstr); \n            membufsize += chars_written;\n            gdb_rr_breakpoint_remove(bpinstr, GDB_BREAKPOINT_SW);\n        }\n\n\t\tif (membufsize > MAX_PACKET_LENGTH/2)\n\t\t\tmembufsize = MAX_PACKET_LENGTH/2;\n        \n\t\tmemtohex(buf, (uint8_t*)membuf, membufsize);\n        put_packet(s, buf);\n\t} else if (!strncmp(p, \"rrlist\", 6)) {\n\t\tCPUBreakpoint *bp;\n        int membufsize = 0;\n        const char msg[] = \"rr breakpoints: \\n\";\n        snprintf(membuf, sizeof(membuf), msg); \n        membufsize += sizeof(msg)-1;\n\n        QTAILQ_FOREACH(bp, &s->c_cpu->breakpoints, entry) {\n           if (bp->rr_instr_count != 0) {\n\t\t\t\tchars_written = snprintf(membuf+membufsize, sizeof(membuf), \"%\" PRIu64 \"\\n\", bp->rr_instr_count);\n\t\t\t\tmembufsize += chars_written;\n            }\n\t\t}\n        \n\t\tif (membufsize > MAX_PACKET_LENGTH/2)\n\t\t\tmembufsize = MAX_PACKET_LENGTH/2;\n        \n\t\tmemtohex(buf, (uint8_t*)membuf, membufsize);\n        put_packet(s, buf);\n\t}\n}\n\nstatic int gdb_handle_packet(GDBState *s, const char *line_buf)\n{\n    CPUState *cpu;\n    CPUClass *cc;\n    const char *p;\n    uint32_t thread;\n    int ch, reg_size, type, res;\n    char buf[MAX_PACKET_LENGTH];\n    uint8_t mem_buf[MAX_PACKET_LENGTH];\n    uint8_t *registers;\n    target_ulong addr, len;\n\n#ifdef DEBUG_GDB\n    printf(\"command='%s'\\n\", line_buf);\n#endif\n    p = line_buf;\n    ch = *p++;\n    switch(ch) {\n    case 'b':\n        gdb_handle_reverse(s, p);\n\t\tput_packet(s, \"OK\");\n        break;\n    case '?':\n        /* TODO: Make this return the correct value for user-mode.  */\n        snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", GDB_SIGNAL_TRAP,\n                 cpu_index(s->c_cpu));\n        put_packet(s, buf);\n        /* Remove all the breakpoints when this query is issued,\n         * because gdb is doing and initial connect and the state\n         * should be cleaned up.\n         */\n        gdb_breakpoint_remove_all();\n        break;\n    case 'c':\n        if (*p != '\\0') {\n            addr = strtoull(p, (char **)&p, 16);\n            gdb_set_cpu_pc(s, addr);\n        }\n        s->signal = 0;\n        gdb_continue(s);\n\treturn RS_IDLE;\n    case 'C':\n        s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n        if (s->signal == -1)\n            s->signal = 0;\n        gdb_continue(s);\n        return RS_IDLE;\n    case 'v':\n        if (strncmp(p, \"Cont\", 4) == 0) {\n            p += 4;\n            if (*p == '?') {\n                put_packet(s, \"vCont;c;C;s;S\");\n                break;\n            }\n\n            res = gdb_handle_vcont(s, p);\n\n            if (res) {\n                if ((res == -EINVAL) || (res == -ERANGE)) {\n                    put_packet(s, \"E22\");\n                    break;\n                }\n                goto unknown_command;\n            }\n            break;\n        } else {\n            goto unknown_command;\n        }\n    case 'k':\n        /* Kill the target */\n        error_report(\"QEMU: Terminated via GDBstub\");\n        exit(0);\n    case 'D':\n        /* Detach packet */\n        gdb_breakpoint_remove_all();\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n        gdb_continue(s);\n        put_packet(s, \"OK\");\n        break;\n    case 's':\n        if (*p != '\\0') {\n            addr = strtoull(p, (char **)&p, 16);\n            gdb_set_cpu_pc(s, addr);\n        }\n        cpu_single_step(s->c_cpu, sstep_flags);\n        gdb_continue(s);\n\treturn RS_IDLE;\n    case 'F':\n        {\n            target_ulong ret;\n            target_ulong err;\n\n            ret = strtoull(p, (char **)&p, 16);\n            if (*p == ',') {\n                p++;\n                err = strtoull(p, (char **)&p, 16);\n            } else {\n                err = 0;\n            }\n            if (*p == ',')\n                p++;\n            type = *p;\n            if (s->current_syscall_cb) {\n                s->current_syscall_cb(s->c_cpu, ret, err);\n                s->current_syscall_cb = NULL;\n            }\n            if (type == 'C') {\n                put_packet(s, \"T02\");\n            } else {\n                gdb_continue(s);\n            }\n        }\n        break;\n    case 'g':\n        cpu_synchronize_state(s->g_cpu);\n        len = 0;\n        for (addr = 0; addr < s->g_cpu->gdb_num_g_regs; addr++) {\n            reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n            len += reg_size;\n        }\n        memtohex(buf, mem_buf, len);\n        put_packet(s, buf);\n        break;\n    case 'G':\n        cpu_synchronize_state(s->g_cpu);\n        registers = mem_buf;\n        len = strlen(p) / 2;\n        hextomem((uint8_t *)registers, p, len);\n        for (addr = 0; addr < s->g_cpu->gdb_num_g_regs && len > 0; addr++) {\n            reg_size = gdb_write_register(s->g_cpu, registers, addr);\n            len -= reg_size;\n            registers += reg_size;\n        }\n        put_packet(s, \"OK\");\n        break;\n    case 'm':\n        addr = strtoull(p, (char **)&p, 16);\n        if (*p == ',')\n            p++;\n        len = strtoull(p, NULL, 16);\n\n        /* memtohex() doubles the required space */\n        if (len > MAX_PACKET_LENGTH / 2) {\n            put_packet (s, \"E22\");\n            break;\n        }\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, false) != 0) {\n            put_packet (s, \"E14\");\n        } else {\n            memtohex(buf, mem_buf, len);\n            put_packet(s, buf);\n        }\n        break;\n    case 'M':\n        addr = strtoull(p, (char **)&p, 16);\n        if (*p == ',')\n            p++;\n        len = strtoull(p, (char **)&p, 16);\n        if (*p == ':')\n            p++;\n\n        /* hextomem() reads 2*len bytes */\n        if (len > strlen(p) / 2) {\n            put_packet (s, \"E22\");\n            break;\n        }\n        hextomem(mem_buf, p, len);\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len,\n                                   true) != 0) {\n            put_packet(s, \"E14\");\n        } else {\n            put_packet(s, \"OK\");\n        }\n        break;\n    case 'p':\n        /* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n           This works, but can be very slow.  Anything new enough to\n           understand XML also knows how to use this properly.  */\n        if (!gdb_has_xml)\n            goto unknown_command;\n        addr = strtoull(p, (char **)&p, 16);\n        reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n        if (reg_size) {\n            memtohex(buf, mem_buf, reg_size);\n            put_packet(s, buf);\n        } else {\n            put_packet(s, \"E14\");\n        }\n        break;\n    case 'P':\n        if (!gdb_has_xml)\n            goto unknown_command;\n        addr = strtoull(p, (char **)&p, 16);\n        if (*p == '=')\n            p++;\n        reg_size = strlen(p) / 2;\n        hextomem(mem_buf, p, reg_size);\n        gdb_write_register(s->g_cpu, mem_buf, addr);\n        put_packet(s, \"OK\");\n        break;\n    case 'Z':\n    case 'z':\n        type = strtoul(p, (char **)&p, 16);\n        if (*p == ',')\n            p++;\n        addr = strtoull(p, (char **)&p, 16);\n        if (*p == ',')\n            p++;\n        len = strtoull(p, (char **)&p, 16);\n        if (ch == 'Z')\n            res = gdb_breakpoint_insert(addr, len, type);\n        else\n            res = gdb_breakpoint_remove(addr, len, type);\n        if (res >= 0)\n             put_packet(s, \"OK\");\n        else if (res == -ENOSYS)\n            put_packet(s, \"\");\n        else\n            put_packet(s, \"E22\");\n        break;\n    case 'H':\n        type = *p++;\n        thread = strtoull(p, (char **)&p, 16);\n        if (thread == -1 || thread == 0) {\n            put_packet(s, \"OK\");\n            break;\n        }\n        cpu = find_cpu(thread);\n        if (cpu == NULL) {\n            put_packet(s, \"E22\");\n            break;\n        }\n        switch (type) {\n        case 'c':\n            s->c_cpu = cpu;\n            put_packet(s, \"OK\");\n            break;\n        case 'g':\n            s->g_cpu = cpu;\n            put_packet(s, \"OK\");\n            break;\n        default:\n             put_packet(s, \"E22\");\n             break;\n        }\n        break;\n    case 'T':\n        thread = strtoull(p, (char **)&p, 16);\n        cpu = find_cpu(thread);\n\n        if (cpu != NULL) {\n            put_packet(s, \"OK\");\n        } else {\n            put_packet(s, \"E22\");\n        }\n        break;\n    case 'q':\n    case 'Q':\n        /* parse any 'q' packets here */\n        if (!strncmp(p, \"PandaCmd:\", 9)) {\n            p += 9;\n            gdb_handle_panda_cmd(s, p);\n            break;\n        } else if (!strcmp(p,\"qemu.sstepbits\")) {\n            /* Query Breakpoint bit definitions */\n            snprintf(buf, sizeof(buf), \"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n                     SSTEP_ENABLE,\n                     SSTEP_NOIRQ,\n                     SSTEP_NOTIMER);\n            put_packet(s, buf);\n            break;\n        } else if (is_query_packet(p, \"qemu.sstep\", '=')) {\n            /* Display or change the sstep_flags */\n            p += 10;\n            if (*p != '=') {\n                /* Display current setting */\n                snprintf(buf, sizeof(buf), \"0x%x\", sstep_flags);\n                put_packet(s, buf);\n                break;\n            }\n            p++;\n            type = strtoul(p, (char **)&p, 16);\n            sstep_flags = type;\n            put_packet(s, \"OK\");\n            break;\n        } else if (strcmp(p,\"C\") == 0) {\n            /* \"Current thread\" remains vague in the spec, so always return\n             *  the first CPU (gdb returns the first thread). */\n            put_packet(s, \"QC1\");\n            break;\n        } else if (strcmp(p,\"fThreadInfo\") == 0) {\n            s->query_cpu = first_cpu;\n            goto report_cpuinfo;\n        } else if (strcmp(p,\"sThreadInfo\") == 0) {\n        report_cpuinfo:\n            if (s->query_cpu) {\n                snprintf(buf, sizeof(buf), \"m%x\", cpu_index(s->query_cpu));\n                put_packet(s, buf);\n                s->query_cpu = CPU_NEXT(s->query_cpu);\n            } else\n                put_packet(s, \"l\");\n            break;\n        } else if (strncmp(p,\"ThreadExtraInfo,\", 16) == 0) {\n            thread = strtoull(p+16, (char **)&p, 16);\n            cpu = find_cpu(thread);\n            if (cpu != NULL) {\n                cpu_synchronize_state(cpu);\n                /* memtohex() doubles the required space */\n                len = snprintf((char *)mem_buf, sizeof(buf) / 2,\n                               \"CPU#%d [%s]\", cpu->cpu_index,\n                               cpu->halted ? \"halted \" : \"running\");\n                memtohex(buf, mem_buf, len);\n                put_packet(s, buf);\n            }\n            break;\n        }\n#ifdef CONFIG_USER_ONLY\n        else if (strcmp(p, \"Offsets\") == 0) {\n            TaskState *ts = s->c_cpu->opaque;\n\n            snprintf(buf, sizeof(buf),\n                     \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n                     \";Bss=\" TARGET_ABI_FMT_lx,\n                     ts->info->code_offset,\n                     ts->info->data_offset,\n                     ts->info->data_offset);\n            put_packet(s, buf);\n            break;\n        }\n#else /* !CONFIG_USER_ONLY */\n        else if (strncmp(p, \"Rcmd,\", 5) == 0) {\n            int len = strlen(p + 5);\n\n            if ((len % 2) != 0) {\n                put_packet(s, \"E01\");\n                break;\n            }\n            len = len / 2;\n            hextomem(mem_buf, p + 5, len);\n            mem_buf[len++] = 0;\n            qemu_chr_be_write(s->mon_chr, mem_buf, len);\n            put_packet(s, \"OK\");\n            break;\n        }\n#endif /* !CONFIG_USER_ONLY */\n        if (is_query_packet(p, \"Supported\", ':')) {\n            snprintf(buf, sizeof(buf), \"PacketSize=%x;ReverseContinue+;ReverseStep+\", MAX_PACKET_LENGTH);\n            cc = CPU_GET_CLASS(first_cpu);\n            if (cc->gdb_core_xml_file != NULL) {\n                pstrcat(buf, sizeof(buf), \";qXfer:features:read+\");\n            }\n            put_packet(s, buf);\n            break;\n        }\n        if (strncmp(p, \"Xfer:features:read:\", 19) == 0) {\n            const char *xml;\n            target_ulong total_len;\n\n            cc = CPU_GET_CLASS(first_cpu);\n            if (cc->gdb_core_xml_file == NULL) {\n                goto unknown_command;\n            }\n\n            gdb_has_xml = true;\n            p += 19;\n            xml = get_feature_xml(p, &p, cc);\n            if (!xml) {\n                snprintf(buf, sizeof(buf), \"E00\");\n                put_packet(s, buf);\n                break;\n            }\n\n            if (*p == ':')\n                p++;\n            addr = strtoul(p, (char **)&p, 16);\n            if (*p == ',')\n                p++;\n            len = strtoul(p, (char **)&p, 16);\n\n            total_len = strlen(xml);\n            if (addr > total_len) {\n                snprintf(buf, sizeof(buf), \"E00\");\n                put_packet(s, buf);\n                break;\n            }\n            if (len > (MAX_PACKET_LENGTH - 5) / 2)\n                len = (MAX_PACKET_LENGTH - 5) / 2;\n            if (len < total_len - addr) {\n                buf[0] = 'm';\n                len = memtox(buf + 1, xml + addr, len);\n            } else {\n                buf[0] = 'l';\n                len = memtox(buf + 1, xml + addr, total_len - addr);\n            }\n            put_packet_binary(s, buf, len + 1);\n            break;\n        }\n        if (is_query_packet(p, \"Attached\", ':')) {\n            put_packet(s, GDB_ATTACHED);\n            break;\n        }\n        /* Unrecognised 'q' command.  */\n        goto unknown_command;\n\n    default:\n    unknown_command:\n        /* put empty packet */\n        buf[0] = '\\0';\n        put_packet(s, buf);\n        break;\n    }\n    return RS_IDLE;\n}\n\nvoid gdb_set_stop_cpu(CPUState *cpu)\n{\n    gdbserver_state->c_cpu = cpu;\n    gdbserver_state->g_cpu = cpu;\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void gdb_vm_state_change(void *opaque, int running, RunState state)\n{\n    GDBState *s = gdbserver_state;\n    CPUState *cpu = s->c_cpu;\n    char buf[256];\n    const char *type;\n    int ret;\n\n    if (running || s->state == RS_INACTIVE) {\n        return;\n    }\n    /* Is there a GDB syscall waiting to be sent?  */\n    if (s->current_syscall_cb) {\n        put_packet(s, s->syscall_buf);\n        return;\n    }\n    switch (state) {\n    case RUN_STATE_DEBUG:\n        if (cpu->watchpoint_hit) {\n            switch (cpu->watchpoint_hit->flags & BP_MEM_ACCESS) {\n            case BP_MEM_READ:\n                type = \"r\";\n                break;\n            case BP_MEM_ACCESS:\n                type = \"a\";\n                break;\n            default:\n                type = \"\";\n                break;\n            }\n            snprintf(buf, sizeof(buf),\n                     \"T%02xthread:%02x;%swatch:\" TARGET_FMT_lx \";\",\n                     GDB_SIGNAL_TRAP, cpu_index(cpu), type,\n                     (target_ulong)cpu->watchpoint_hit->virtaddr);\n            cpu->watchpoint_hit = NULL;\n            goto send_packet;\n        }\n        tb_flush(cpu);\n        ret = GDB_SIGNAL_TRAP;\n        break;\n    case RUN_STATE_PAUSED:\n        ret = GDB_SIGNAL_INT;\n        break;\n    case RUN_STATE_SHUTDOWN:\n        ret = GDB_SIGNAL_QUIT;\n        break;\n    case RUN_STATE_IO_ERROR:\n        ret = GDB_SIGNAL_IO;\n        break;\n    case RUN_STATE_WATCHDOG:\n        ret = GDB_SIGNAL_ALRM;\n        break;\n    case RUN_STATE_INTERNAL_ERROR:\n        ret = GDB_SIGNAL_ABRT;\n        break;\n    case RUN_STATE_SAVE_VM:\n    case RUN_STATE_RESTORE_VM:\n        return;\n    case RUN_STATE_FINISH_MIGRATE:\n        ret = GDB_SIGNAL_XCPU;\n        break;\n    default:\n        ret = GDB_SIGNAL_UNKNOWN;\n        break;\n    }\n    gdb_set_stop_cpu(cpu);\n    snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", ret, cpu_index(cpu));\n\nsend_packet:\n    put_packet(s, buf);\n\n    /* disable single step if it was enabled */\n    cpu_single_step(cpu, 0);\n}\n#endif\n\n/* Send a gdb syscall request.\n   This accepts limited printf-style format specifiers, specifically:\n    %x  - target_ulong argument printed in hex.\n    %lx - 64-bit argument printed in hex.\n    %s  - string pointer (target_ulong) and length (int) pair.  */\nvoid gdb_do_syscallv(gdb_syscall_complete_cb cb, const char *fmt, va_list va)\n{\n    char *p;\n    char *p_end;\n    target_ulong addr;\n    uint64_t i64;\n    GDBState *s;\n\n    s = gdbserver_state;\n    if (!s)\n        return;\n    s->current_syscall_cb = cb;\n#ifndef CONFIG_USER_ONLY\n    vm_stop(RUN_STATE_DEBUG);\n#endif\n    p = s->syscall_buf;\n    p_end = &s->syscall_buf[sizeof(s->syscall_buf)];\n    *(p++) = 'F';\n    while (*fmt) {\n        if (*fmt == '%') {\n            fmt++;\n            switch (*fmt++) {\n            case 'x':\n                addr = va_arg(va, target_ulong);\n                p += snprintf(p, p_end - p, TARGET_FMT_lx, addr);\n                break;\n            case 'l':\n                if (*(fmt++) != 'x')\n                    goto bad_format;\n                i64 = va_arg(va, uint64_t);\n                p += snprintf(p, p_end - p, \"%\" PRIx64, i64);\n                break;\n            case 's':\n                addr = va_arg(va, target_ulong);\n                p += snprintf(p, p_end - p, TARGET_FMT_lx \"/%x\",\n                              addr, va_arg(va, int));\n                break;\n            default:\n            bad_format:\n                error_report(\"gdbstub: Bad syscall format string '%s'\",\n                             fmt - 1);\n                break;\n            }\n        } else {\n            *(p++) = *(fmt++);\n        }\n    }\n    *p = 0;\n#ifdef CONFIG_USER_ONLY\n    put_packet(s, s->syscall_buf);\n    gdb_handlesig(s->c_cpu, 0);\n#else\n    /* In this case wait to send the syscall packet until notification that\n       the CPU has stopped.  This must be done because if the packet is sent\n       now the reply from the syscall request could be received while the CPU\n       is still in the running state, which can cause packets to be dropped\n       and state transition 'T' packets to be sent while the syscall is still\n       being processed.  */\n    qemu_cpu_kick(s->c_cpu);\n#endif\n}\n\nvoid gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n{\n    va_list va;\n\n    va_start(va, fmt);\n    gdb_do_syscallv(cb, fmt, va);\n    va_end(va);\n}\n\nstatic void gdb_read_byte(GDBState *s, int ch)\n{\n    int i, csum;\n    uint8_t reply;\n\n#ifndef CONFIG_USER_ONLY\n    if (s->last_packet_len) {\n        /* Waiting for a response to the last packet.  If we see the start\n           of a new command then abandon the previous response.  */\n        if (ch == '-') {\n#ifdef DEBUG_GDB\n            printf(\"Got NACK, retransmitting\\n\");\n#endif\n            put_buffer(s, (uint8_t *)s->last_packet, s->last_packet_len);\n        }\n#ifdef DEBUG_GDB\n        else if (ch == '+')\n            printf(\"Got ACK\\n\");\n        else\n            printf(\"Got '%c' when expecting ACK/NACK\\n\", ch);\n#endif\n        if (ch == '+' || ch == '$')\n            s->last_packet_len = 0;\n        if (ch != '$')\n            return;\n    }\n    if (runstate_is_running()) {\n        /* when the CPU is running, we cannot do anything except stop\n           it when receiving a char */\n        vm_stop(RUN_STATE_PAUSED);\n    } else\n#endif\n    {\n        switch(s->state) {\n        case RS_IDLE:\n            if (ch == '$') {\n                s->line_buf_index = 0;\n                s->state = RS_GETLINE;\n            }\n            break;\n        case RS_GETLINE:\n            if (ch == '#') {\n            s->state = RS_CHKSUM1;\n            } else if (s->line_buf_index >= sizeof(s->line_buf) - 1) {\n                s->state = RS_IDLE;\n            } else {\n            s->line_buf[s->line_buf_index++] = ch;\n            }\n            break;\n        case RS_CHKSUM1:\n            s->line_buf[s->line_buf_index] = '\\0';\n            s->line_csum = fromhex(ch) << 4;\n            s->state = RS_CHKSUM2;\n            break;\n        case RS_CHKSUM2:\n            s->line_csum |= fromhex(ch);\n            csum = 0;\n            for(i = 0; i < s->line_buf_index; i++) {\n                csum += s->line_buf[i];\n            }\n            if (s->line_csum != (csum & 0xff)) {\n                reply = '-';\n                put_buffer(s, &reply, 1);\n                s->state = RS_IDLE;\n            } else {\n                reply = '+';\n                put_buffer(s, &reply, 1);\n                s->state = gdb_handle_packet(s, s->line_buf);\n            }\n            break;\n        default:\n            abort();\n        }\n    }\n}\n\n/* Tell the remote gdb that the process has exited.  */\nvoid gdb_exit(CPUArchState *env, int code)\n{\n  GDBState *s;\n  char buf[4];\n#ifndef CONFIG_USER_ONLY\n  Chardev *chr;\n#endif\n\n  s = gdbserver_state;\n  if (!s) {\n      return;\n  }\n#ifdef CONFIG_USER_ONLY\n  if (gdbserver_fd < 0 || s->fd < 0) {\n      return;\n  }\n#else\n  chr = qemu_chr_fe_get_driver(&s->chr);\n  if (!chr) {\n      return;\n  }\n#endif\n\n  snprintf(buf, sizeof(buf), \"W%02x\", (uint8_t)code);\n  put_packet(s, buf);\n\n#ifndef CONFIG_USER_ONLY\n  qemu_chr_fe_deinit(&s->chr);\n  qemu_chr_delete(chr);\n#endif\n}\n\n#ifdef CONFIG_USER_ONLY\nint\ngdb_handlesig(CPUState *cpu, int sig)\n{\n    GDBState *s;\n    char buf[256];\n    int n;\n\n    s = gdbserver_state;\n    if (gdbserver_fd < 0 || s->fd < 0) {\n        return sig;\n    }\n\n    /* disable single step if it was enabled */\n    cpu_single_step(cpu, 0);\n    tb_flush(cpu);\n\n    if (sig != 0) {\n        snprintf(buf, sizeof(buf), \"S%02x\", target_signal_to_gdb(sig));\n        put_packet(s, buf);\n    }\n    /* put_packet() might have detected that the peer terminated the\n       connection.  */\n    if (s->fd < 0) {\n        return sig;\n    }\n\n    sig = 0;\n    s->state = RS_IDLE;\n    s->running_state = 0;\n    while (s->running_state == 0) {\n        n = read(s->fd, buf, 256);\n        if (n > 0) {\n            int i;\n\n            for (i = 0; i < n; i++) {\n                gdb_read_byte(s, buf[i]);\n            }\n        } else {\n            /* XXX: Connection closed.  Should probably wait for another\n               connection before continuing.  */\n            if (n == 0) {\n                close(s->fd);\n            }\n            s->fd = -1;\n            return sig;\n        }\n    }\n    sig = s->signal;\n    s->signal = 0;\n    return sig;\n}\n\n/* Tell the remote gdb that the process has exited due to SIG.  */\nvoid gdb_signalled(CPUArchState *env, int sig)\n{\n    GDBState *s;\n    char buf[4];\n\n    s = gdbserver_state;\n    if (gdbserver_fd < 0 || s->fd < 0) {\n        return;\n    }\n\n    snprintf(buf, sizeof(buf), \"X%02x\", target_signal_to_gdb(sig));\n    put_packet(s, buf);\n}\n\nstatic void gdb_accept(void)\n{\n    GDBState *s;\n    struct sockaddr_in sockaddr;\n    socklen_t len;\n    int fd;\n\n    for(;;) {\n        len = sizeof(sockaddr);\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n        if (fd < 0 && errno != EINTR) {\n            perror(\"accept\");\n            return;\n        } else if (fd >= 0) {\n#ifndef _WIN32\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n#endif\n            break;\n        }\n    }\n\n    /* set short latency */\n    socket_set_nodelay(fd);\n\n    s = g_malloc0(sizeof(GDBState));\n    s->c_cpu = first_cpu;\n    s->g_cpu = first_cpu;\n    s->fd = fd;\n    gdb_has_xml = false;\n\n    gdbserver_state = s;\n}\n\nstatic int gdbserver_open(int port)\n{\n    struct sockaddr_in sockaddr;\n    int fd, ret;\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        return -1;\n    }\n#ifndef _WIN32\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n    socket_set_fast_reuse(fd);\n\n    sockaddr.sin_family = AF_INET;\n    sockaddr.sin_port = htons(port);\n    sockaddr.sin_addr.s_addr = 0;\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n    if (ret < 0) {\n        perror(\"bind\");\n        close(fd);\n        return -1;\n    }\n    ret = listen(fd, 1);\n    if (ret < 0) {\n        perror(\"listen\");\n        close(fd);\n        return -1;\n    }\n    return fd;\n}\n\nint gdbserver_start(int port)\n{\n    gdbserver_fd = gdbserver_open(port);\n    if (gdbserver_fd < 0)\n        return -1;\n    /* accept connections */\n    gdb_accept();\n    return 0;\n}\n\n/* Disable gdb stub for child processes.  */\nvoid gdbserver_fork(CPUState *cpu)\n{\n    GDBState *s = gdbserver_state;\n\n    if (gdbserver_fd < 0 || s->fd < 0) {\n        return;\n    }\n    close(s->fd);\n    s->fd = -1;\n    cpu_breakpoint_remove_all(cpu, BP_GDB);\n    cpu_watchpoint_remove_all(cpu, BP_GDB);\n}\n#else\nstatic int gdb_chr_can_receive(void *opaque)\n{\n  /* We can handle an arbitrarily large amount of data.\n   Pick the maximum packet size, which is as good as anything.  */\n  return MAX_PACKET_LENGTH;\n}\n\nstatic void gdb_chr_receive(void *opaque, const uint8_t *buf, int size)\n{\n    int i;\n\n    for (i = 0; i < size; i++) {\n        gdb_read_byte(gdbserver_state, buf[i]);\n    }\n}\n\nstatic void gdb_chr_event(void *opaque, int event)\n{\n    switch (event) {\n    case CHR_EVENT_OPENED:\n        vm_stop(RUN_STATE_PAUSED);\n        gdb_has_xml = false;\n        break;\n    default:\n        break;\n    }\n}\n\nstatic void gdb_monitor_output(GDBState *s, const char *msg, int len)\n{\n    char buf[MAX_PACKET_LENGTH];\n\n    buf[0] = 'O';\n    if (len > (MAX_PACKET_LENGTH/2) - 1)\n        len = (MAX_PACKET_LENGTH/2) - 1;\n    memtohex(buf + 1, (uint8_t *)msg, len);\n    put_packet(s, buf);\n}\n\nstatic int gdb_monitor_write(Chardev *chr, const uint8_t *buf, int len)\n{\n    const char *p = (const char *)buf;\n    int max_sz;\n\n    max_sz = (sizeof(gdbserver_state->last_packet) - 2) / 2;\n    for (;;) {\n        if (len <= max_sz) {\n            gdb_monitor_output(gdbserver_state, p, len);\n            break;\n        }\n        gdb_monitor_output(gdbserver_state, p, max_sz);\n        p += max_sz;\n        len -= max_sz;\n    }\n    return len;\n}\n\n#ifndef _WIN32\nstatic void gdb_sigterm_handler(int signal)\n{\n    if (runstate_is_running()) {\n        vm_stop(RUN_STATE_PAUSED);\n    }\n}\n#endif\n\nstatic void gdb_monitor_open(Chardev *chr, ChardevBackend *backend,\n                             bool *be_opened, Error **errp)\n{\n    *be_opened = false;\n}\n\nstatic void char_gdb_class_init(ObjectClass *oc, void *data)\n{\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n    cc->internal = true;\n    cc->open = gdb_monitor_open;\n    cc->chr_write = gdb_monitor_write;\n}\n\n#define TYPE_CHARDEV_GDB \"chardev-gdb\"\n\nstatic const TypeInfo char_gdb_type_info = {\n    .name = TYPE_CHARDEV_GDB,\n    .parent = TYPE_CHARDEV,\n    .class_init = char_gdb_class_init,\n};\n\nint gdbserver_start(const char *device)\n{\n    GDBState *s;\n    char gdbstub_device_name[128];\n    Chardev *chr = NULL;\n    Chardev *mon_chr;\n\n    if (!first_cpu) {\n        error_report(\"gdbstub: meaningless to attach gdb to a \"\n                     \"machine without any CPU.\");\n        return -1;\n    }\n\n    if (!device)\n        return -1;\n    if (strcmp(device, \"none\") != 0) {\n        if (strstart(device, \"tcp:\", NULL)) {\n            /* enforce required TCP attributes */\n            snprintf(gdbstub_device_name, sizeof(gdbstub_device_name),\n                     \"%s,nowait,nodelay,server\", device);\n            device = gdbstub_device_name;\n        }\n#ifndef _WIN32\n        else if (strcmp(device, \"stdio\") == 0) {\n            struct sigaction act;\n\n            memset(&act, 0, sizeof(act));\n            act.sa_handler = gdb_sigterm_handler;\n            sigaction(SIGINT, &act, NULL);\n        }\n#endif\n        chr = qemu_chr_new_noreplay(\"gdb\", device);\n        if (!chr)\n            return -1;\n    }\n\n    s = gdbserver_state;\n    if (!s) {\n        s = g_malloc0(sizeof(GDBState));\n        gdbserver_state = s;\n\n        qemu_add_vm_change_state_handler(gdb_vm_state_change, NULL);\n\n        /* Initialize a monitor terminal for gdb */\n        mon_chr = qemu_chardev_new(NULL, TYPE_CHARDEV_GDB,\n                                   NULL, &error_abort);\n        monitor_init(mon_chr, 0);\n    } else {\n        if (qemu_chr_fe_get_driver(&s->chr)) {\n            qemu_chr_delete(qemu_chr_fe_get_driver(&s->chr));\n        }\n        mon_chr = s->mon_chr;\n        memset(s, 0, sizeof(GDBState));\n        s->mon_chr = mon_chr;\n    }\n    s->c_cpu = first_cpu;\n    s->g_cpu = first_cpu;\n    if (chr) {\n        qemu_chr_fe_init(&s->chr, chr, &error_abort);\n        qemu_chr_fe_set_handlers(&s->chr, gdb_chr_can_receive, gdb_chr_receive,\n                                 gdb_chr_event, NULL, NULL, true);\n    }\n    s->state = chr ? RS_IDLE : RS_INACTIVE;\n    s->mon_chr = mon_chr;\n    s->current_syscall_cb = NULL;\n\n    return 0;\n}\n\nstatic void register_types(void)\n{\n    type_register_static(&char_gdb_type_info);\n}\n\ntype_init(register_types);\n#endif\n"
        },
        {
          "name": "hax-stub.c",
          "type": "blob",
          "size": 0.6123046875,
          "content": "/*\n * QEMU HAXM support\n *\n * Copyright (c) 2015, Intel Corporation\n *\n * Copyright 2016 Google, Inc.\n *\n * This software is licensed under the terms of the GNU General Public\n * License version 2, as published by the Free Software Foundation, and\n * may be copied, distributed, and modified under those terms.\n *\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"sysemu/hax.h\"\n\nint hax_sync_vcpus(void)\n{\n    return 0;\n}\n\nint hax_init_vcpu(CPUState *cpu)\n{\n    return -ENOSYS;\n}\n\nint hax_smp_cpu_exec(CPUState *cpu)\n{\n    return -ENOSYS;\n}\n"
        },
        {
          "name": "hmp-commands-info.hx",
          "type": "blob",
          "size": 16.2177734375,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and texi\nHXCOMM Text between STEXI and ETEXI are copied to texi version and\nHXCOMM discarded from C version\nHXCOMM DEF(command, args, callback, arg_string, help) is used to construct\nHXCOMM monitor info commands\nHXCOMM HXCOMM can be used for comments, discarded from both texi and C\n\nSTEXI\n@table @option\n@item info @var{subcommand}\n@findex info\nShow various information about the system state.\n@table @option\nETEXI\n\n    {\n        .name       = \"version\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the version of QEMU\",\n        .cmd        = hmp_info_version,\n    },\n\nSTEXI\n@item info version\n@findex version\nShow the version of QEMU.\nETEXI\n\n    {\n        .name       = \"network\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the network state\",\n        .cmd        = hmp_info_network,\n    },\n\nSTEXI\n@item info network\n@findex network\nShow the network state.\nETEXI\n\n    {\n        .name       = \"chardev\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the character devices\",\n        .cmd        = hmp_info_chardev,\n    },\n\nSTEXI\n@item info chardev\n@findex chardev\nShow the character devices.\nETEXI\n\n    {\n        .name       = \"block\",\n        .args_type  = \"nodes:-n,verbose:-v,device:B?\",\n        .params     = \"[-n] [-v] [device]\",\n        .help       = \"show info of one block device or all block devices \"\n                      \"(-n: show named nodes; -v: show details)\",\n        .cmd        = hmp_info_block,\n    },\n\nSTEXI\n@item info block\n@findex block\nShow info of one block device or all block devices.\nETEXI\n\n    {\n        .name       = \"blockstats\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show block device statistics\",\n        .cmd        = hmp_info_blockstats,\n    },\n\nSTEXI\n@item info blockstats\n@findex blockstats\nShow block device statistics.\nETEXI\n\n    {\n        .name       = \"block-jobs\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show progress of ongoing block device operations\",\n        .cmd        = hmp_info_block_jobs,\n    },\n\nSTEXI\n@item info block-jobs\n@findex block-jobs\nShow progress of ongoing block device operations.\nETEXI\n\n    {\n        .name       = \"registers\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the cpu registers\",\n        .cmd        = hmp_info_registers,\n    },\n\nSTEXI\n@item info registers\n@findex registers\nShow the cpu registers.\nETEXI\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"lapic\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show local apic state\",\n        .cmd        = hmp_info_local_apic,\n    },\n#endif\n\nSTEXI\n@item info lapic\n@findex lapic\nShow local APIC state\nETEXI\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"ioapic\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show io apic state\",\n        .cmd        = hmp_info_io_apic,\n    },\n#endif\n\nSTEXI\n@item info ioapic\n@findex ioapic\nShow io APIC state\nETEXI\n\n    {\n        .name       = \"cpus\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show infos for each CPU\",\n        .cmd        = hmp_info_cpus,\n    },\n\nSTEXI\n@item info cpus\n@findex cpus\nShow infos for each CPU.\nETEXI\n\n    {\n        .name       = \"history\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the command line history\",\n        .cmd        = hmp_info_history,\n    },\n\nSTEXI\n@item info history\n@findex history\nShow the command line history.\nETEXI\n\n    {\n        .name       = \"irq\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the interrupts statistics (if available)\",\n        .cmd        = hmp_info_irq,\n    },\n\nSTEXI\n@item info irq\n@findex irq\nShow the interrupts statistics (if available).\nETEXI\n\n    {\n        .name       = \"pic\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show PIC state\",\n        .cmd        = hmp_info_pic,\n    },\n\nSTEXI\n@item info pic\n@findex pic\nShow i8259 (PIC) state.\nETEXI\n\n    {\n        .name       = \"pci\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show PCI info\",\n        .cmd        = hmp_info_pci,\n    },\n\nSTEXI\n@item info pci\n@findex pci\nShow PCI information.\nETEXI\n\n#if defined(TARGET_I386) || defined(TARGET_SH4) || defined(TARGET_SPARC) || \\\n    defined(TARGET_PPC) || defined(TARGET_XTENSA)\n    {\n        .name       = \"tlb\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show virtual to physical memory mappings\",\n        .cmd        = hmp_info_tlb,\n    },\n#endif\n\nSTEXI\n@item info tlb\n@findex tlb\nShow virtual to physical memory mappings.\nETEXI\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"mem\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the active virtual memory mappings\",\n        .cmd        = hmp_info_mem,\n    },\n#endif\n\nSTEXI\n@item info mem\n@findex mem\nShow the active virtual memory mappings.\nETEXI\n\n    {\n        .name       = \"mtree\",\n        .args_type  = \"flatview:-f\",\n        .params     = \"[-f]\",\n        .help       = \"show memory tree (-f: dump flat view for address spaces)\",\n        .cmd        = hmp_info_mtree,\n    },\n\nSTEXI\n@item info mtree\n@findex mtree\nShow memory tree.\nETEXI\n\n    {\n        .name       = \"jit\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dynamic compiler info\",\n        .cmd        = hmp_info_jit,\n    },\n\nSTEXI\n@item info jit\n@findex jit\nShow dynamic compiler info.\nETEXI\n\n    {\n        .name       = \"opcount\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dynamic compiler opcode counters\",\n        .cmd        = hmp_info_opcount,\n    },\n\nSTEXI\n@item info opcount\n@findex opcount\nShow dynamic compiler opcode counters\nETEXI\n\n    {\n        .name       = \"kvm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show KVM information\",\n        .cmd        = hmp_info_kvm,\n    },\n\nSTEXI\n@item info kvm\n@findex kvm\nShow KVM information.\nETEXI\n\n    {\n        .name       = \"numa\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show NUMA information\",\n        .cmd        = hmp_info_numa,\n    },\n\nSTEXI\n@item info numa\n@findex numa\nShow NUMA information.\nETEXI\n\n    {\n        .name       = \"usb\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show guest USB devices\",\n        .cmd        = hmp_info_usb,\n    },\n\nSTEXI\n@item info usb\n@findex usb\nShow guest USB devices.\nETEXI\n\n    {\n        .name       = \"usbhost\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show host USB devices\",\n        .cmd        = hmp_info_usbhost,\n    },\n\nSTEXI\n@item info usbhost\n@findex usbhost\nShow host USB devices.\nETEXI\n\n    {\n        .name       = \"profile\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show profiling information\",\n        .cmd        = hmp_info_profile,\n    },\n\nSTEXI\n@item info profile\n@findex profile\nShow profiling information.\nETEXI\n\n    {\n        .name       = \"capture\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show capture information\",\n        .cmd        = hmp_info_capture,\n    },\n\nSTEXI\n@item info capture\n@findex capture\nShow capture information.\nETEXI\n\n    {\n        .name       = \"snapshots\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the currently saved VM snapshots\",\n        .cmd        = hmp_info_snapshots,\n    },\n\nSTEXI\n@item info snapshots\n@findex snapshots\nShow the currently saved VM snapshots.\nETEXI\n\n    {\n        .name       = \"status\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM status (running|paused)\",\n        .cmd        = hmp_info_status,\n    },\n\nSTEXI\n@item info status\n@findex status\nShow the current VM status (running|paused).\nETEXI\n\n    {\n        .name       = \"mice\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show which guest mouse is receiving events\",\n        .cmd        = hmp_info_mice,\n    },\n\nSTEXI\n@item info mice\n@findex mice\nShow which guest mouse is receiving events.\nETEXI\n\n    {\n        .name       = \"vnc\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the vnc server status\",\n        .cmd        = hmp_info_vnc,\n    },\n\nSTEXI\n@item info vnc\n@findex vnc\nShow the vnc server status.\nETEXI\n\n#if defined(CONFIG_SPICE)\n    {\n        .name       = \"spice\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the spice server status\",\n        .cmd        = hmp_info_spice,\n    },\n#endif\n\nSTEXI\n@item info spice\n@findex spice\nShow the spice server status.\nETEXI\n\n    {\n        .name       = \"name\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM name\",\n        .cmd        = hmp_info_name,\n    },\n\nSTEXI\n@item info name\n@findex name\nShow the current VM name.\nETEXI\n\n    {\n        .name       = \"uuid\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM UUID\",\n        .cmd        = hmp_info_uuid,\n    },\n\nSTEXI\n@item info uuid\n@findex uuid\nShow the current VM UUID.\nETEXI\n\n    {\n        .name       = \"cpustats\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show CPU statistics\",\n        .cmd        = hmp_info_cpustats,\n    },\n\nSTEXI\n@item info cpustats\n@findex cpustats\nShow CPU statistics.\nETEXI\n\n#if defined(CONFIG_SLIRP)\n    {\n        .name       = \"usernet\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show user network stack connection states\",\n        .cmd        = hmp_info_usernet,\n    },\n#endif\n\nSTEXI\n@item info usernet\n@findex usernet\nShow user network stack connection states.\nETEXI\n\n    {\n        .name       = \"migrate\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show migration status\",\n        .cmd        = hmp_info_migrate,\n    },\n\nSTEXI\n@item info migrate\n@findex migrate\nShow migration status.\nETEXI\n\n    {\n        .name       = \"migrate_capabilities\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show current migration capabilities\",\n        .cmd        = hmp_info_migrate_capabilities,\n    },\n\nSTEXI\n@item info migrate_capabilities\n@findex migrate_capabilities\nShow current migration capabilities.\nETEXI\n\n    {\n        .name       = \"migrate_parameters\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show current migration parameters\",\n        .cmd        = hmp_info_migrate_parameters,\n    },\n\nSTEXI\n@item info migrate_parameters\n@findex migrate_parameters\nShow current migration parameters.\nETEXI\n\n    {\n        .name       = \"migrate_cache_size\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show current migration xbzrle cache size\",\n        .cmd        = hmp_info_migrate_cache_size,\n    },\n\nSTEXI\n@item info migrate_cache_size\n@findex migrate_cache_size\nShow current migration xbzrle cache size.\nETEXI\n\n    {\n        .name       = \"balloon\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show balloon information\",\n        .cmd        = hmp_info_balloon,\n    },\n\nSTEXI\n@item info balloon\n@findex balloon\nShow balloon information.\nETEXI\n\n    {\n        .name       = \"qtree\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show device tree\",\n        .cmd        = hmp_info_qtree,\n    },\n\nSTEXI\n@item info qtree\n@findex qtree\nShow device tree.\nETEXI\n\n    {\n        .name       = \"qdm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show qdev device model list\",\n        .cmd        = hmp_info_qdm,\n    },\n\nSTEXI\n@item info qdm\n@findex qdm\nShow qdev device model list.\nETEXI\n\n    {\n        .name       = \"qom-tree\",\n        .args_type  = \"path:s?\",\n        .params     = \"[path]\",\n        .help       = \"show QOM composition tree\",\n        .cmd        = hmp_info_qom_tree,\n    },\n\nSTEXI\n@item info qom-tree\n@findex qom-tree\nShow QOM composition tree.\nETEXI\n\n    {\n        .name       = \"roms\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show roms\",\n        .cmd        = hmp_info_roms,\n    },\n\nSTEXI\n@item info roms\n@findex roms\nShow roms.\nETEXI\n\n    {\n        .name       = \"trace-events\",\n        .args_type  = \"name:s?,vcpu:i?\",\n        .params     = \"[name] [vcpu]\",\n        .help       = \"show available trace-events & their state \"\n                      \"(name: event name pattern; vcpu: vCPU to query, default is any)\",\n        .cmd = hmp_info_trace_events,\n        .command_completion = info_trace_events_completion,\n    },\n\nSTEXI\n@item info trace-events\n@findex trace-events\nShow available trace-events & their state.\nETEXI\n\n    {\n        .name       = \"tpm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the TPM device\",\n        .cmd        = hmp_info_tpm,\n    },\n\nSTEXI\n@item info tpm\n@findex tpm\nShow the TPM device.\nETEXI\n\n    {\n        .name       = \"memdev\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show memory backends\",\n        .cmd        = hmp_info_memdev,\n    },\n\nSTEXI\n@item info memdev\n@findex memdev\nShow memory backends\nETEXI\n\n    {\n        .name       = \"memory-devices\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show memory devices\",\n        .cmd        = hmp_info_memory_devices,\n    },\n\nSTEXI\n@item info memory-devices\n@findex memory-devices\nShow memory devices.\nETEXI\n\n    {\n        .name       = \"iothreads\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show iothreads\",\n        .cmd        = hmp_info_iothreads,\n    },\n\nSTEXI\n@item info iothreads\n@findex iothreads\nShow iothread's identifiers.\nETEXI\n\n    {\n        .name       = \"rocker\",\n        .args_type  = \"name:s\",\n        .params     = \"name\",\n        .help       = \"Show rocker switch\",\n        .cmd        = hmp_rocker,\n    },\n\nSTEXI\n@item info rocker @var{name}\n@findex rocker\nShow rocker switch.\nETEXI\n\n    {\n        .name       = \"rocker-ports\",\n        .args_type  = \"name:s\",\n        .params     = \"name\",\n        .help       = \"Show rocker ports\",\n        .cmd        = hmp_rocker_ports,\n    },\n\nSTEXI\n@item info rocker_ports @var{name}-ports\n@findex ocker-ports\nShow rocker ports.\nETEXI\n\n    {\n        .name       = \"rocker-of-dpa-flows\",\n        .args_type  = \"name:s,tbl_id:i?\",\n        .params     = \"name [tbl_id]\",\n        .help       = \"Show rocker OF-DPA flow tables\",\n        .cmd        = hmp_rocker_of_dpa_flows,\n    },\n\nSTEXI\n@item info rocker_of_dpa_flows @var{name} [@var{tbl_id}]\n@findex rocker-of-dpa-flows\nShow rocker OF-DPA flow tables.\nETEXI\n\n    {\n        .name       = \"rocker-of-dpa-groups\",\n        .args_type  = \"name:s,type:i?\",\n        .params     = \"name [type]\",\n        .help       = \"Show rocker OF-DPA groups\",\n        .cmd        = hmp_rocker_of_dpa_groups,\n    },\n\nSTEXI\n@item info rocker-of-dpa-groups @var{name} [@var{type}]\n@findex rocker-of-dpa-groups\nShow rocker OF-DPA groups.\nETEXI\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"skeys\",\n        .args_type  = \"addr:l\",\n        .params     = \"address\",\n        .help       = \"Display the value of a storage key\",\n        .cmd        = hmp_info_skeys,\n    },\n#endif\n\nSTEXI\n@item info skeys @var{address}\n@findex skeys\nDisplay the value of a storage key (s390 only)\nETEXI\n\n    {\n        .name       = \"dump\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Display the latest dump status\",\n        .cmd        = hmp_info_dump,\n    },\n\nSTEXI\n@item info dump\n@findex dump\nDisplay the latest dump status.\nETEXI\n\n    {\n        .name       = \"hotpluggable-cpus\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Show information about hotpluggable CPUs\",\n        .cmd        = hmp_hotpluggable_cpus,\n    },\n\nSTEXI\n@item info hotpluggable-cpus\n@findex hotpluggable-cpus\nShow information about hotpluggable CPUs\nETEXI\n\nSTEXI\n@item info vm-generation-id\n@findex vm-generation-id\nShow Virtual Machine Generation ID\nETEXI\n\n    {\n        .name       = \"vm-generation-id\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Show Virtual Machine Generation ID\",\n        .cmd = hmp_info_vm_generation_id,\n    },\n\nSTEXI\n@end table\nETEXI\n\nSTEXI\n@end table\nETEXI\n"
        },
        {
          "name": "hmp-commands.hx",
          "type": "blob",
          "size": 52.1220703125,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and texi\nHXCOMM Text between STEXI and ETEXI are copied to texi version and\nHXCOMM discarded from C version\nHXCOMM DEF(command, args, callback, arg_string, help) is used to construct\nHXCOMM monitor commands\nHXCOMM HXCOMM can be used for comments, discarded from both texi and C\n\nSTEXI\n@table @option\nETEXI\n\n    {\n        .name       = \"help|?\",\n        .args_type  = \"name:S?\",\n        .params     = \"[cmd]\",\n        .help       = \"show the help\",\n        .cmd        = do_help_cmd,\n    },\n\nSTEXI\n@item help or ? [@var{cmd}]\n@findex help\nShow the help for all commands or just for command @var{cmd}.\nETEXI\n\n    {\n        .name       = \"commit\",\n        .args_type  = \"device:B\",\n        .params     = \"device|all\",\n        .help       = \"commit changes to the disk images (if -snapshot is used) or backing files\",\n        .cmd        = hmp_commit,\n    },\n\nSTEXI\n@item commit\n@findex commit\nCommit changes to the disk images (if -snapshot is used) or backing files.\nIf the backing file is smaller than the snapshot, then the backing file will be\nresized to be the same size as the snapshot.  If the snapshot is smaller than\nthe backing file, the backing file will not be truncated.  If you want the\nbacking file to match the size of the smaller snapshot, you can safely truncate\nit yourself once the commit operation successfully completes.\nETEXI\n\n    {\n        .name       = \"q|quit\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"quit the emulator\",\n        .cmd        = hmp_quit,\n    },\n\nSTEXI\n@item q or quit\n@findex quit\nQuit the emulator.\nETEXI\n\n    {\n        .name       = \"block_resize\",\n        .args_type  = \"device:B,size:o\",\n        .params     = \"device size\",\n        .help       = \"resize a block image\",\n        .cmd        = hmp_block_resize,\n    },\n\nSTEXI\n@item block_resize\n@findex block_resize\nResize a block image while a guest is running.  Usually requires guest\naction to see the updated size.  Resize to a lower size is supported,\nbut should be used with extreme caution.  Note that this command only\nresizes image files, it can not resize block devices like LVM volumes.\nETEXI\n\n    {\n        .name       = \"block_stream\",\n        .args_type  = \"device:B,speed:o?,base:s?\",\n        .params     = \"device [speed [base]]\",\n        .help       = \"copy data from a backing file into a block device\",\n        .cmd        = hmp_block_stream,\n    },\n\nSTEXI\n@item block_stream\n@findex block_stream\nCopy data from a backing file into a block device.\nETEXI\n\n    {\n        .name       = \"block_job_set_speed\",\n        .args_type  = \"device:B,speed:o\",\n        .params     = \"device speed\",\n        .help       = \"set maximum speed for a background block operation\",\n        .cmd        = hmp_block_job_set_speed,\n    },\n\nSTEXI\n@item block_job_set_speed\n@findex block_job_set_speed\nSet maximum speed for a background block operation.\nETEXI\n\n    {\n        .name       = \"block_job_cancel\",\n        .args_type  = \"force:-f,device:B\",\n        .params     = \"[-f] device\",\n        .help       = \"stop an active background block operation (use -f\"\n                      \"\\n\\t\\t\\t if the operation is currently paused)\",\n        .cmd        = hmp_block_job_cancel,\n    },\n\nSTEXI\n@item block_job_cancel\n@findex block_job_cancel\nStop an active background block operation (streaming, mirroring).\nETEXI\n\n    {\n        .name       = \"block_job_complete\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"stop an active background block operation\",\n        .cmd        = hmp_block_job_complete,\n    },\n\nSTEXI\n@item block_job_complete\n@findex block_job_complete\nManually trigger completion of an active background block operation.\nFor mirroring, this will switch the device to the destination path.\nETEXI\n\n    {\n        .name       = \"block_job_pause\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"pause an active background block operation\",\n        .cmd        = hmp_block_job_pause,\n    },\n\nSTEXI\n@item block_job_pause\n@findex block_job_pause\nPause an active block streaming operation.\nETEXI\n\n    {\n        .name       = \"block_job_resume\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"resume a paused background block operation\",\n        .cmd        = hmp_block_job_resume,\n    },\n\nSTEXI\n@item block_job_resume\n@findex block_job_resume\nResume a paused block streaming operation.\nETEXI\n\n    {\n        .name       = \"eject\",\n        .args_type  = \"force:-f,device:B\",\n        .params     = \"[-f] device\",\n        .help       = \"eject a removable medium (use -f to force it)\",\n        .cmd        = hmp_eject,\n    },\n\nSTEXI\n@item eject [-f] @var{device}\n@findex eject\nEject a removable medium (use -f to force it).\nETEXI\n\n    {\n        .name       = \"drive_del\",\n        .args_type  = \"id:B\",\n        .params     = \"device\",\n        .help       = \"remove host block device\",\n        .cmd        = hmp_drive_del,\n    },\n\nSTEXI\n@item drive_del @var{device}\n@findex drive_del\nRemove host block device.  The result is that guest generated IO is no longer\nsubmitted against the host device underlying the disk.  Once a drive has\nbeen deleted, the QEMU Block layer returns -EIO which results in IO\nerrors in the guest for applications that are reading/writing to the device.\nThese errors are always reported to the guest, regardless of the drive's error\nactions (drive options rerror, werror).\nETEXI\n\n    {\n        .name       = \"change\",\n        .args_type  = \"device:B,target:F,arg:s?,read-only-mode:s?\",\n        .params     = \"device filename [format [read-only-mode]]\",\n        .help       = \"change a removable medium, optional format\",\n        .cmd        = hmp_change,\n    },\n\nSTEXI\n@item change @var{device} @var{setting}\n@findex change\nChange the configuration of a device.\n\n@table @option\n@item change @var{diskdevice} @var{filename} [@var{format} [@var{read-only-mode}]]\nChange the medium for a removable disk device to point to @var{filename}. eg\n\n@example\n(qemu) change ide1-cd0 /path/to/some.iso\n@end example\n\n@var{format} is optional.\n\n@var{read-only-mode} may be used to change the read-only status of the device.\nIt accepts the following values:\n\n@table @var\n@item retain\nRetains the current status; this is the default.\n\n@item read-only\nMakes the device read-only.\n\n@item read-write\nMakes the device writable.\n@end table\n\n@item change vnc @var{display},@var{options}\nChange the configuration of the VNC server. The valid syntax for @var{display}\nand @var{options} are described at @ref{sec_invocation}. eg\n\n@example\n(qemu) change vnc localhost:1\n@end example\n\n@item change vnc password [@var{password}]\n\nChange the password associated with the VNC server. If the new password is not\nsupplied, the monitor will prompt for it to be entered. VNC passwords are only\nsignificant up to 8 letters. eg\n\n@example\n(qemu) change vnc password\nPassword: ********\n@end example\n\n@end table\nETEXI\n\n    {\n        .name       = \"screendump\",\n        .args_type  = \"filename:F\",\n        .params     = \"filename\",\n        .help       = \"save screen into PPM image 'filename'\",\n        .cmd        = hmp_screendump,\n    },\n\nSTEXI\n@item screendump @var{filename}\n@findex screendump\nSave screen into PPM image @var{filename}.\nETEXI\n\n    {\n        .name       = \"logfile\",\n        .args_type  = \"filename:F\",\n        .params     = \"filename\",\n        .help       = \"output logs to 'filename'\",\n        .cmd        = hmp_logfile,\n    },\n\nSTEXI\n@item logfile @var{filename}\n@findex logfile\nOutput logs to @var{filename}.\nETEXI\n\n    {\n        .name       = \"trace-event\",\n        .args_type  = \"name:s,option:b,vcpu:i?\",\n        .params     = \"name on|off [vcpu]\",\n        .help       = \"changes status of a specific trace event \"\n                      \"(vcpu: vCPU to set, default is all)\",\n        .cmd = hmp_trace_event,\n        .command_completion = trace_event_completion,\n    },\n\nSTEXI\n@item trace-event\n@findex trace-event\nchanges status of a trace event\nETEXI\n\n#if defined(CONFIG_TRACE_SIMPLE)\n    {\n        .name       = \"trace-file\",\n        .args_type  = \"op:s?,arg:F?\",\n        .params     = \"on|off|flush|set [arg]\",\n        .help       = \"open, close, or flush trace file, or set a new file name\",\n        .cmd        = hmp_trace_file,\n    },\n\nSTEXI\n@item trace-file on|off|flush\n@findex trace-file\nOpen, close, or flush the trace file.  If no argument is given, the status of the trace file is displayed.\nETEXI\n#endif\n\n    {\n        .name       = \"log\",\n        .args_type  = \"items:s\",\n        .params     = \"item1[,...]\",\n        .help       = \"activate logging of the specified items\",\n        .cmd        = hmp_log,\n    },\n\nSTEXI\n@item log @var{item1}[,...]\n@findex log\nActivate logging of the specified items.\nETEXI\n\n    {\n        .name       = \"savevm\",\n        .args_type  = \"name:s?\",\n        .params     = \"[tag|id]\",\n        .help       = \"save a VM snapshot. If no tag or id are provided, a new snapshot is created\",\n        .cmd        = hmp_savevm,\n    },\n\nSTEXI\n@item savevm [@var{tag}|@var{id}]\n@findex savevm\nCreate a snapshot of the whole virtual machine. If @var{tag} is\nprovided, it is used as human readable identifier. If there is already\na snapshot with the same tag or ID, it is replaced. More info at\n@ref{vm_snapshots}.\nETEXI\n\n    {\n        .name       = \"loadvm\",\n        .args_type  = \"name:s\",\n        .params     = \"tag|id\",\n        .help       = \"restore a VM snapshot from its tag or id\",\n        .cmd        = hmp_loadvm,\n        .command_completion = loadvm_completion,\n    },\n\nSTEXI\n@item loadvm @var{tag}|@var{id}\n@findex loadvm\nSet the whole virtual machine to the snapshot identified by the tag\n@var{tag} or the unique snapshot ID @var{id}.\nETEXI\n\n    {\n        .name       = \"delvm\",\n        .args_type  = \"name:s\",\n        .params     = \"tag|id\",\n        .help       = \"delete a VM snapshot from its tag or id\",\n        .cmd        = hmp_delvm,\n        .command_completion = delvm_completion,\n    },\n\nSTEXI\n@item delvm @var{tag}|@var{id}\n@findex delvm\nDelete the snapshot identified by @var{tag} or @var{id}.\nETEXI\n\n    {\n        .name       = \"singlestep\",\n        .args_type  = \"option:s?\",\n        .params     = \"[on|off]\",\n        .help       = \"run emulation in singlestep mode or switch to normal mode\",\n        .cmd        = hmp_singlestep,\n    },\n\nSTEXI\n@item singlestep [off]\n@findex singlestep\nRun the emulation in single step mode.\nIf called with option off, the emulation returns to normal mode.\nETEXI\n\n    {\n        .name       = \"stop\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"stop emulation\",\n        .cmd        = hmp_stop,\n    },\n\nSTEXI\n@item stop\n@findex stop\nStop emulation.\nETEXI\n\n    {\n        .name       = \"c|cont\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"resume emulation\",\n        .cmd        = hmp_cont,\n    },\n\nSTEXI\n@item c or cont\n@findex cont\nResume emulation.\nETEXI\n\n    {\n        .name       = \"system_wakeup\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"wakeup guest from suspend\",\n        .cmd        = hmp_system_wakeup,\n    },\n\nSTEXI\n@item system_wakeup\n@findex system_wakeup\nWakeup guest from suspend.\nETEXI\n\n    {\n        .name       = \"gdbserver\",\n        .args_type  = \"device:s?\",\n        .params     = \"[device]\",\n        .help       = \"start gdbserver on given device (default 'tcp::1234'), stop with 'none'\",\n        .cmd        = hmp_gdbserver,\n    },\n\nSTEXI\n@item gdbserver [@var{port}]\n@findex gdbserver\nStart gdbserver session (default @var{port}=1234)\nETEXI\n\n    {\n        .name       = \"x\",\n        .args_type  = \"fmt:/,addr:l\",\n        .params     = \"/fmt addr\",\n        .help       = \"virtual memory dump starting at 'addr'\",\n        .cmd        = hmp_memory_dump,\n    },\n\nSTEXI\n@item x/fmt @var{addr}\n@findex x\nVirtual memory dump starting at @var{addr}.\nETEXI\n\n    {\n        .name       = \"xp\",\n        .args_type  = \"fmt:/,addr:l\",\n        .params     = \"/fmt addr\",\n        .help       = \"physical memory dump starting at 'addr'\",\n        .cmd        = hmp_physical_memory_dump,\n    },\n\nSTEXI\n@item xp /@var{fmt} @var{addr}\n@findex xp\nPhysical memory dump starting at @var{addr}.\n\n@var{fmt} is a format which tells the command how to format the\ndata. Its syntax is: @option{/@{count@}@{format@}@{size@}}\n\n@table @var\n@item count\nis the number of items to be dumped.\n\n@item format\ncan be x (hex), d (signed decimal), u (unsigned decimal), o (octal),\nc (char) or i (asm instruction).\n\n@item size\ncan be b (8 bits), h (16 bits), w (32 bits) or g (64 bits). On x86,\n@code{h} or @code{w} can be specified with the @code{i} format to\nrespectively select 16 or 32 bit code instruction size.\n\n@end table\n\nExamples:\n@itemize\n@item\nDump 10 instructions at the current instruction pointer:\n@example\n(qemu) x/10i $eip\n0x90107063:  ret\n0x90107064:  sti\n0x90107065:  lea    0x0(%esi,1),%esi\n0x90107069:  lea    0x0(%edi,1),%edi\n0x90107070:  ret\n0x90107071:  jmp    0x90107080\n0x90107073:  nop\n0x90107074:  nop\n0x90107075:  nop\n0x90107076:  nop\n@end example\n\n@item\nDump 80 16 bit values at the start of the video memory.\n@smallexample\n(qemu) xp/80hx 0xb8000\n0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42\n0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41\n0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72\n0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73\n0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20\n0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720\n0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n@end smallexample\n@end itemize\nETEXI\n\n    {\n        .name       = \"p|print\",\n        .args_type  = \"fmt:/,val:l\",\n        .params     = \"/fmt expr\",\n        .help       = \"print expression value (use $reg for CPU register access)\",\n        .cmd        = do_print,\n    },\n\nSTEXI\n@item p or print/@var{fmt} @var{expr}\n@findex print\nPrint expression value. Only the @var{format} part of @var{fmt} is\nused.\nETEXI\n\n    {\n        .name       = \"i\",\n        .args_type  = \"fmt:/,addr:i,index:i.\",\n        .params     = \"/fmt addr\",\n        .help       = \"I/O port read\",\n        .cmd        = hmp_ioport_read,\n    },\n\nSTEXI\n@item i/@var{fmt} @var{addr} [.@var{index}]\n@findex i\nRead I/O port.\nETEXI\n\n    {\n        .name       = \"o\",\n        .args_type  = \"fmt:/,addr:i,val:i\",\n        .params     = \"/fmt addr value\",\n        .help       = \"I/O port write\",\n        .cmd        = hmp_ioport_write,\n    },\n\nSTEXI\n@item o/@var{fmt} @var{addr} @var{val}\n@findex o\nWrite to I/O port.\nETEXI\n\n    {\n        .name       = \"sendkey\",\n        .args_type  = \"keys:s,hold-time:i?\",\n        .params     = \"keys [hold_ms]\",\n        .help       = \"send keys to the VM (e.g. 'sendkey ctrl-alt-f1', default hold time=100 ms)\",\n        .cmd        = hmp_sendkey,\n        .command_completion = sendkey_completion,\n    },\n\nSTEXI\n@item sendkey @var{keys}\n@findex sendkey\nSend @var{keys} to the guest. @var{keys} could be the name of the\nkey or the raw value in hexadecimal format. Use @code{-} to press\nseveral keys simultaneously. Example:\n@example\nsendkey ctrl-alt-f1\n@end example\n\nThis command is useful to send keys that your graphical user interface\nintercepts at low level, such as @code{ctrl-alt-f1} in X Window.\nETEXI\n\n    {\n        .name       = \"system_reset\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"reset the system\",\n        .cmd        = hmp_system_reset,\n    },\n\nSTEXI\n@item system_reset\n@findex system_reset\nReset the system.\nETEXI\n\n    {\n        .name       = \"system_powerdown\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"send system power down event\",\n        .cmd        = hmp_system_powerdown,\n    },\n\nSTEXI\n@item system_powerdown\n@findex system_powerdown\nPower down the system (if supported).\nETEXI\n\n    {\n        .name       = \"sum\",\n        .args_type  = \"start:i,size:i\",\n        .params     = \"addr size\",\n        .help       = \"compute the checksum of a memory region\",\n        .cmd        = hmp_sum,\n    },\n\nSTEXI\n@item sum @var{addr} @var{size}\n@findex sum\nCompute the checksum of a memory region.\nETEXI\n\n    {\n        .name       = \"usb_add\",\n        .args_type  = \"devname:s\",\n        .params     = \"device\",\n        .help       = \"add USB device (e.g. 'host:bus.addr' or 'host:vendor_id:product_id')\",\n        .cmd        = hmp_usb_add,\n    },\n\nSTEXI\n@item usb_add @var{devname}\n@findex usb_add\nAdd the USB device @var{devname}.  For details of available devices see\n@ref{usb_devices}\nETEXI\n\n    {\n        .name       = \"usb_del\",\n        .args_type  = \"devname:s\",\n        .params     = \"device\",\n        .help       = \"remove USB device 'bus.addr'\",\n        .cmd        = hmp_usb_del,\n    },\n\nSTEXI\n@item usb_del @var{devname}\n@findex usb_del\nRemove the USB device @var{devname} from the QEMU virtual USB\nhub. @var{devname} has the syntax @code{bus.addr}. Use the monitor\ncommand @code{info usb} to see the devices you can remove.\nETEXI\n\n    {\n        .name       = \"device_add\",\n        .args_type  = \"device:O\",\n        .params     = \"driver[,prop=value][,...]\",\n        .help       = \"add device, like -device on the command line\",\n        .cmd        = hmp_device_add,\n        .command_completion = device_add_completion,\n    },\n\nSTEXI\n@item device_add @var{config}\n@findex device_add\nAdd device.\nETEXI\n\n    {\n        .name       = \"device_del\",\n        .args_type  = \"id:s\",\n        .params     = \"device\",\n        .help       = \"remove device\",\n        .cmd        = hmp_device_del,\n        .command_completion = device_del_completion,\n    },\n\nSTEXI\n@item device_del @var{id}\n@findex device_del\nRemove device @var{id}. @var{id} may be a short ID\nor a QOM object path.\nETEXI\n\n    {\n        .name       = \"cpu\",\n        .args_type  = \"index:i\",\n        .params     = \"index\",\n        .help       = \"set the default CPU\",\n        .cmd        = hmp_cpu,\n    },\n\nSTEXI\n@item cpu @var{index}\n@findex cpu\nSet the default CPU.\nETEXI\n\n    {\n        .name       = \"mouse_move\",\n        .args_type  = \"dx_str:s,dy_str:s,dz_str:s?\",\n        .params     = \"dx dy [dz]\",\n        .help       = \"send mouse move events\",\n        .cmd        = hmp_mouse_move,\n    },\n\nSTEXI\n@item mouse_move @var{dx} @var{dy} [@var{dz}]\n@findex mouse_move\nMove the active mouse to the specified coordinates @var{dx} @var{dy}\nwith optional scroll axis @var{dz}.\nETEXI\n\n    {\n        .name       = \"mouse_button\",\n        .args_type  = \"button_state:i\",\n        .params     = \"state\",\n        .help       = \"change mouse button state (1=L, 2=M, 4=R)\",\n        .cmd        = hmp_mouse_button,\n    },\n\nSTEXI\n@item mouse_button @var{val}\n@findex mouse_button\nChange the active mouse button state @var{val} (1=L, 2=M, 4=R).\nETEXI\n\n    {\n        .name       = \"mouse_set\",\n        .args_type  = \"index:i\",\n        .params     = \"index\",\n        .help       = \"set which mouse device receives events\",\n        .cmd        = hmp_mouse_set,\n    },\n\nSTEXI\n@item mouse_set @var{index}\n@findex mouse_set\nSet which mouse device receives events at given @var{index}, index\ncan be obtained with\n@example\ninfo mice\n@end example\nETEXI\n\n    {\n        .name       = \"wavcapture\",\n        .args_type  = \"path:F,freq:i?,bits:i?,nchannels:i?\",\n        .params     = \"path [frequency [bits [channels]]]\",\n        .help       = \"capture audio to a wave file (default frequency=44100 bits=16 channels=2)\",\n        .cmd        = hmp_wavcapture,\n    },\nSTEXI\n@item wavcapture @var{filename} [@var{frequency} [@var{bits} [@var{channels}]]]\n@findex wavcapture\nCapture audio into @var{filename}. Using sample rate @var{frequency}\nbits per sample @var{bits} and number of channels @var{channels}.\n\nDefaults:\n@itemize @minus\n@item Sample rate = 44100 Hz - CD quality\n@item Bits = 16\n@item Number of channels = 2 - Stereo\n@end itemize\nETEXI\n\n    {\n        .name       = \"stopcapture\",\n        .args_type  = \"n:i\",\n        .params     = \"capture index\",\n        .help       = \"stop capture\",\n        .cmd        = hmp_stopcapture,\n    },\nSTEXI\n@item stopcapture @var{index}\n@findex stopcapture\nStop capture with a given @var{index}, index can be obtained with\n@example\ninfo capture\n@end example\nETEXI\n\n    {\n        .name       = \"memsave\",\n        .args_type  = \"val:l,size:i,filename:s\",\n        .params     = \"addr size file\",\n        .help       = \"save to disk virtual memory dump starting at 'addr' of size 'size'\",\n        .cmd        = hmp_memsave,\n    },\n\nSTEXI\n@item memsave @var{addr} @var{size} @var{file}\n@findex memsave\nsave to disk virtual memory dump starting at @var{addr} of size @var{size}.\nETEXI\n\n    {\n        .name       = \"pmemsave\",\n        .args_type  = \"val:l,size:i,filename:s\",\n        .params     = \"addr size file\",\n        .help       = \"save to disk physical memory dump starting at 'addr' of size 'size'\",\n        .cmd        = hmp_pmemsave,\n    },\n\nSTEXI\n@item pmemsave @var{addr} @var{size} @var{file}\n@findex pmemsave\nsave to disk physical memory dump starting at @var{addr} of size @var{size}.\nETEXI\n\n    {\n        .name       = \"boot_set\",\n        .args_type  = \"bootdevice:s\",\n        .params     = \"bootdevice\",\n        .help       = \"define new values for the boot device list\",\n        .cmd        = hmp_boot_set,\n    },\n\nSTEXI\n@item boot_set @var{bootdevicelist}\n@findex boot_set\nDefine new values for the boot device list. Those values will override\nthe values specified on the command line through the @code{-boot} option.\n\nThe values that can be specified here depend on the machine type, but are\nthe same that can be specified in the @code{-boot} command line option.\nETEXI\n\n    {\n        .name       = \"nmi\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"inject an NMI\",\n        .cmd        = hmp_nmi,\n    },\nSTEXI\n@item nmi @var{cpu}\n@findex nmi\nInject an NMI on the default CPU (x86/s390) or all CPUs (ppc64).\n\nETEXI\n\n    {\n        .name       = \"ringbuf_write\",\n        .args_type  = \"device:s,data:s\",\n        .params     = \"device data\",\n        .help       = \"Write to a ring buffer character device\",\n        .cmd        = hmp_ringbuf_write,\n        .command_completion = ringbuf_write_completion,\n    },\n\nSTEXI\n@item ringbuf_write @var{device} @var{data}\n@findex ringbuf_write\nWrite @var{data} to ring buffer character device @var{device}.\n@var{data} must be a UTF-8 string.\n\nETEXI\n\n    {\n        .name       = \"ringbuf_read\",\n        .args_type  = \"device:s,size:i\",\n        .params     = \"device size\",\n        .help       = \"Read from a ring buffer character device\",\n        .cmd        = hmp_ringbuf_read,\n        .command_completion = ringbuf_write_completion,\n    },\n\nSTEXI\n@item ringbuf_read @var{device}\n@findex ringbuf_read\nRead and print up to @var{size} bytes from ring buffer character\ndevice @var{device}.\nCertain non-printable characters are printed \\uXXXX, where XXXX is the\ncharacter code in hexadecimal.  Character \\ is printed \\\\.\nBug: can screw up when the buffer contains invalid UTF-8 sequences,\nNUL characters, after the ring buffer lost data, and when reading\nstops because the size limit is reached.\n\nETEXI\n\n    {\n        .name       = \"migrate\",\n        .args_type  = \"detach:-d,blk:-b,inc:-i,uri:s\",\n        .params     = \"[-d] [-b] [-i] uri\",\n        .help       = \"migrate to URI (using -d to not wait for completion)\"\n\t\t      \"\\n\\t\\t\\t -b for migration without shared storage with\"\n\t\t      \" full copy of disk\\n\\t\\t\\t -i for migration without \"\n\t\t      \"shared storage with incremental copy of disk \"\n\t\t      \"(base image shared between src and destination)\",\n        .cmd        = hmp_migrate,\n    },\n\n\nSTEXI\n@item migrate [-d] [-b] [-i] @var{uri}\n@findex migrate\nMigrate to @var{uri} (using -d to not wait for completion).\n\t-b for migration with full copy of disk\n\t-i for migration with incremental copy of disk (base image is shared)\nETEXI\n\n    {\n        .name       = \"migrate_cancel\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"cancel the current VM migration\",\n        .cmd        = hmp_migrate_cancel,\n    },\n\nSTEXI\n@item migrate_cancel\n@findex migrate_cancel\nCancel the current VM migration.\n\nETEXI\n\n    {\n        .name       = \"migrate_incoming\",\n        .args_type  = \"uri:s\",\n        .params     = \"uri\",\n        .help       = \"Continue an incoming migration from an -incoming defer\",\n        .cmd        = hmp_migrate_incoming,\n    },\n\nSTEXI\n@item migrate_incoming @var{uri}\n@findex migrate_incoming\nContinue an incoming migration using the @var{uri} (that has the same syntax\nas the -incoming option).\n\nETEXI\n\n    {\n        .name       = \"migrate_set_cache_size\",\n        .args_type  = \"value:o\",\n        .params     = \"value\",\n        .help       = \"set cache size (in bytes) for XBZRLE migrations,\"\n                      \"the cache size will be rounded down to the nearest \"\n                      \"power of 2.\\n\"\n                      \"The cache size affects the number of cache misses.\"\n                      \"In case of a high cache miss ratio you need to increase\"\n                      \" the cache size\",\n        .cmd        = hmp_migrate_set_cache_size,\n    },\n\nSTEXI\n@item migrate_set_cache_size @var{value}\n@findex migrate_set_cache_size\nSet cache size to @var{value} (in bytes) for xbzrle migrations.\nETEXI\n\n    {\n        .name       = \"migrate_set_speed\",\n        .args_type  = \"value:o\",\n        .params     = \"value\",\n        .help       = \"set maximum speed (in bytes) for migrations. \"\n\t\"Defaults to MB if no size suffix is specified, ie. B/K/M/G/T\",\n        .cmd        = hmp_migrate_set_speed,\n    },\n\nSTEXI\n@item migrate_set_speed @var{value}\n@findex migrate_set_speed\nSet maximum speed to @var{value} (in bytes) for migrations.\nETEXI\n\n    {\n        .name       = \"migrate_set_downtime\",\n        .args_type  = \"value:T\",\n        .params     = \"value\",\n        .help       = \"set maximum tolerated downtime (in seconds) for migrations\",\n        .cmd        = hmp_migrate_set_downtime,\n    },\n\nSTEXI\n@item migrate_set_downtime @var{second}\n@findex migrate_set_downtime\nSet maximum tolerated downtime (in seconds) for migration.\nETEXI\n\n    {\n        .name       = \"migrate_set_capability\",\n        .args_type  = \"capability:s,state:b\",\n        .params     = \"capability state\",\n        .help       = \"Enable/Disable the usage of a capability for migration\",\n        .cmd        = hmp_migrate_set_capability,\n        .command_completion = migrate_set_capability_completion,\n    },\n\nSTEXI\n@item migrate_set_capability @var{capability} @var{state}\n@findex migrate_set_capability\nEnable/Disable the usage of a capability @var{capability} for migration.\nETEXI\n\n    {\n        .name       = \"migrate_set_parameter\",\n        .args_type  = \"parameter:s,value:s\",\n        .params     = \"parameter value\",\n        .help       = \"Set the parameter for migration\",\n        .cmd        = hmp_migrate_set_parameter,\n        .command_completion = migrate_set_parameter_completion,\n    },\n\nSTEXI\n@item migrate_set_parameter @var{parameter} @var{value}\n@findex migrate_set_parameter\nSet the parameter @var{parameter} for migration.\nETEXI\n\n    {\n        .name       = \"migrate_start_postcopy\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Followup to a migration command to switch the migration\"\n                      \" to postcopy mode. The postcopy-ram capability must \"\n                      \"be set before the original migration command.\",\n        .cmd        = hmp_migrate_start_postcopy,\n    },\n\nSTEXI\n@item migrate_start_postcopy\n@findex migrate_start_postcopy\nSwitch in-progress migration to postcopy mode. Ignored after the end of\nmigration (or once already in postcopy).\nETEXI\n\n    {\n        .name       = \"x_colo_lost_heartbeat\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Tell COLO that heartbeat is lost,\\n\\t\\t\\t\"\n                      \"a failover or takeover is needed.\",\n        .cmd = hmp_x_colo_lost_heartbeat,\n    },\n\nSTEXI\n@item x_colo_lost_heartbeat\n@findex x_colo_lost_heartbeat\nTell COLO that heartbeat is lost, a failover or takeover is needed.\nETEXI\n\n    {\n        .name       = \"client_migrate_info\",\n        .args_type  = \"protocol:s,hostname:s,port:i?,tls-port:i?,cert-subject:s?\",\n        .params     = \"protocol hostname port tls-port cert-subject\",\n        .help       = \"set migration information for remote display\",\n        .cmd        = hmp_client_migrate_info,\n    },\n\nSTEXI\n@item client_migrate_info @var{protocol} @var{hostname} @var{port} @var{tls-port} @var{cert-subject}\n@findex client_migrate_info\nSet migration information for remote display.  This makes the server\nask the client to automatically reconnect using the new parameters\nonce migration finished successfully.  Only implemented for SPICE.\nETEXI\n\n    {\n        .name       = \"dump-guest-memory\",\n        .args_type  = \"paging:-p,detach:-d,zlib:-z,lzo:-l,snappy:-s,filename:F,begin:i?,length:i?\",\n        .params     = \"[-p] [-d] [-z|-l|-s] filename [begin length]\",\n        .help       = \"dump guest memory into file 'filename'.\\n\\t\\t\\t\"\n                      \"-p: do paging to get guest's memory mapping.\\n\\t\\t\\t\"\n                      \"-d: return immediately (do not wait for completion).\\n\\t\\t\\t\"\n                      \"-z: dump in kdump-compressed format, with zlib compression.\\n\\t\\t\\t\"\n                      \"-l: dump in kdump-compressed format, with lzo compression.\\n\\t\\t\\t\"\n                      \"-s: dump in kdump-compressed format, with snappy compression.\\n\\t\\t\\t\"\n                      \"begin: the starting physical address.\\n\\t\\t\\t\"\n                      \"length: the memory size, in bytes.\",\n        .cmd        = hmp_dump_guest_memory,\n    },\n\n\nSTEXI\n@item dump-guest-memory [-p] @var{filename} @var{begin} @var{length}\n@item dump-guest-memory [-z|-l|-s] @var{filename}\n@findex dump-guest-memory\nDump guest memory to @var{protocol}. The file can be processed with crash or\ngdb. Without -z|-l|-s, the dump format is ELF.\n        -p: do paging to get guest's memory mapping.\n        -z: dump in kdump-compressed format, with zlib compression.\n        -l: dump in kdump-compressed format, with lzo compression.\n        -s: dump in kdump-compressed format, with snappy compression.\n  filename: dump file name.\n     begin: the starting physical address. It's optional, and should be\n            specified together with length.\n    length: the memory size, in bytes. It's optional, and should be specified\n            together with begin.\nETEXI\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"dump-skeys\",\n        .args_type  = \"filename:F\",\n        .params     = \"\",\n        .help       = \"Save guest storage keys into file 'filename'.\\n\",\n        .cmd        = hmp_dump_skeys,\n    },\n#endif\n\nSTEXI\n@item dump-skeys @var{filename}\n@findex dump-skeys\nSave guest storage keys to a file.\nETEXI\n\n    {\n        .name       = \"snapshot_blkdev\",\n        .args_type  = \"reuse:-n,device:B,snapshot-file:s?,format:s?\",\n        .params     = \"[-n] device [new-image-file] [format]\",\n        .help       = \"initiates a live snapshot\\n\\t\\t\\t\"\n                      \"of device. If a new image file is specified, the\\n\\t\\t\\t\"\n                      \"new image file will become the new root image.\\n\\t\\t\\t\"\n                      \"If format is specified, the snapshot file will\\n\\t\\t\\t\"\n                      \"be created in that format.\\n\\t\\t\\t\"\n                      \"The default format is qcow2.  The -n flag requests QEMU\\n\\t\\t\\t\"\n                      \"to reuse the image found in new-image-file, instead of\\n\\t\\t\\t\"\n                      \"recreating it from scratch.\",\n        .cmd        = hmp_snapshot_blkdev,\n    },\n\nSTEXI\n@item snapshot_blkdev\n@findex snapshot_blkdev\nSnapshot device, using snapshot file as target if provided\nETEXI\n\n    {\n        .name       = \"snapshot_blkdev_internal\",\n        .args_type  = \"device:B,name:s\",\n        .params     = \"device name\",\n        .help       = \"take an internal snapshot of device.\\n\\t\\t\\t\"\n                      \"The format of the image used by device must\\n\\t\\t\\t\"\n                      \"support it, such as qcow2.\\n\\t\\t\\t\",\n        .cmd        = hmp_snapshot_blkdev_internal,\n    },\n\nSTEXI\n@item snapshot_blkdev_internal\n@findex snapshot_blkdev_internal\nTake an internal snapshot on device if it support\nETEXI\n\n    {\n        .name       = \"snapshot_delete_blkdev_internal\",\n        .args_type  = \"device:B,name:s,id:s?\",\n        .params     = \"device name [id]\",\n        .help       = \"delete an internal snapshot of device.\\n\\t\\t\\t\"\n                      \"If id is specified, qemu will try delete\\n\\t\\t\\t\"\n                      \"the snapshot matching both id and name.\\n\\t\\t\\t\"\n                      \"The format of the image used by device must\\n\\t\\t\\t\"\n                      \"support it, such as qcow2.\\n\\t\\t\\t\",\n        .cmd        = hmp_snapshot_delete_blkdev_internal,\n    },\n\nSTEXI\n@item snapshot_delete_blkdev_internal\n@findex snapshot_delete_blkdev_internal\nDelete an internal snapshot on device if it support\nETEXI\n\n    {\n        .name       = \"drive_mirror\",\n        .args_type  = \"reuse:-n,full:-f,device:B,target:s,format:s?\",\n        .params     = \"[-n] [-f] device target [format]\",\n        .help       = \"initiates live storage\\n\\t\\t\\t\"\n                      \"migration for a device. The device's contents are\\n\\t\\t\\t\"\n                      \"copied to the new image file, including data that\\n\\t\\t\\t\"\n                      \"is written after the command is started.\\n\\t\\t\\t\"\n                      \"The -n flag requests QEMU to reuse the image found\\n\\t\\t\\t\"\n                      \"in new-image-file, instead of recreating it from scratch.\\n\\t\\t\\t\"\n                      \"The -f flag requests QEMU to copy the whole disk,\\n\\t\\t\\t\"\n                      \"so that the result does not need a backing file.\\n\\t\\t\\t\",\n        .cmd        = hmp_drive_mirror,\n    },\nSTEXI\n@item drive_mirror\n@findex drive_mirror\nStart mirroring a block device's writes to a new destination,\nusing the specified target.\nETEXI\n\n    {\n        .name       = \"drive_backup\",\n        .args_type  = \"reuse:-n,full:-f,compress:-c,device:B,target:s,format:s?\",\n        .params     = \"[-n] [-f] [-c] device target [format]\",\n        .help       = \"initiates a point-in-time\\n\\t\\t\\t\"\n                      \"copy for a device. The device's contents are\\n\\t\\t\\t\"\n                      \"copied to the new image file, excluding data that\\n\\t\\t\\t\"\n                      \"is written after the command is started.\\n\\t\\t\\t\"\n                      \"The -n flag requests QEMU to reuse the image found\\n\\t\\t\\t\"\n                      \"in new-image-file, instead of recreating it from scratch.\\n\\t\\t\\t\"\n                      \"The -f flag requests QEMU to copy the whole disk,\\n\\t\\t\\t\"\n                      \"so that the result does not need a backing file.\\n\\t\\t\\t\"\n                      \"The -c flag requests QEMU to compress backup data\\n\\t\\t\\t\"\n                      \"(if the target format supports it).\\n\\t\\t\\t\",\n        .cmd        = hmp_drive_backup,\n    },\nSTEXI\n@item drive_backup\n@findex drive_backup\nStart a point-in-time copy of a block device to a specificed target.\nETEXI\n\n    {\n        .name       = \"drive_add\",\n        .args_type  = \"node:-n,pci_addr:s,opts:s\",\n        .params     = \"[-n] [[<domain>:]<bus>:]<slot>\\n\"\n                      \"[file=file][,if=type][,bus=n]\\n\"\n                      \"[,unit=m][,media=d][,index=i]\\n\"\n                      \"[,cyls=c,heads=h,secs=s[,trans=t]]\\n\"\n                      \"[,snapshot=on|off][,cache=on|off]\\n\"\n                      \"[,readonly=on|off][,copy-on-read=on|off]\",\n        .help       = \"add drive to PCI storage controller\",\n        .cmd        = hmp_drive_add,\n    },\n\nSTEXI\n@item drive_add\n@findex drive_add\nAdd drive to PCI storage controller.\nETEXI\n\n    {\n        .name       = \"pcie_aer_inject_error\",\n        .args_type  = \"advisory_non_fatal:-a,correctable:-c,\"\n\t              \"id:s,error_status:s,\"\n\t              \"header0:i?,header1:i?,header2:i?,header3:i?,\"\n\t              \"prefix0:i?,prefix1:i?,prefix2:i?,prefix3:i?\",\n        .params     = \"[-a] [-c] id \"\n                      \"<error_status> [<tlp header> [<tlp header prefix>]]\",\n        .help       = \"inject pcie aer error\\n\\t\\t\\t\"\n\t              \" -a for advisory non fatal error\\n\\t\\t\\t\"\n\t              \" -c for correctable error\\n\\t\\t\\t\"\n                      \"<id> = qdev device id\\n\\t\\t\\t\"\n                      \"<error_status> = error string or 32bit\\n\\t\\t\\t\"\n                      \"<tlb header> = 32bit x 4\\n\\t\\t\\t\"\n                      \"<tlb header prefix> = 32bit x 4\",\n        .cmd        = hmp_pcie_aer_inject_error,\n    },\n\nSTEXI\n@item pcie_aer_inject_error\n@findex pcie_aer_inject_error\nInject PCIe AER error\nETEXI\n\n    {\n        .name       = \"host_net_add\",\n        .args_type  = \"device:s,opts:s?\",\n        .params     = \"tap|user|socket|vde|netmap|bridge|vhost-user|dump [options]\",\n        .help       = \"add host VLAN client\",\n        .cmd        = hmp_host_net_add,\n        .command_completion = host_net_add_completion,\n    },\n\nSTEXI\n@item host_net_add\n@findex host_net_add\nAdd host VLAN client.\nETEXI\n\n    {\n        .name       = \"host_net_remove\",\n        .args_type  = \"vlan_id:i,device:s\",\n        .params     = \"vlan_id name\",\n        .help       = \"remove host VLAN client\",\n        .cmd        = hmp_host_net_remove,\n        .command_completion = host_net_remove_completion,\n    },\n\nSTEXI\n@item host_net_remove\n@findex host_net_remove\nRemove host VLAN client.\nETEXI\n\n    {\n        .name       = \"netdev_add\",\n        .args_type  = \"netdev:O\",\n        .params     = \"[user|tap|socket|vde|bridge|hubport|netmap|vhost-user],id=str[,prop=value][,...]\",\n        .help       = \"add host network device\",\n        .cmd        = hmp_netdev_add,\n        .command_completion = netdev_add_completion,\n    },\n\nSTEXI\n@item netdev_add\n@findex netdev_add\nAdd host network device.\nETEXI\n\n    {\n        .name       = \"netdev_del\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"remove host network device\",\n        .cmd        = hmp_netdev_del,\n        .command_completion = netdev_del_completion,\n    },\n\nSTEXI\n@item netdev_del\n@findex netdev_del\nRemove host network device.\nETEXI\n\n    {\n        .name       = \"object_add\",\n        .args_type  = \"object:O\",\n        .params     = \"[qom-type=]type,id=str[,prop=value][,...]\",\n        .help       = \"create QOM object\",\n        .cmd        = hmp_object_add,\n        .command_completion = object_add_completion,\n    },\n\nSTEXI\n@item object_add\n@findex object_add\nCreate QOM object.\nETEXI\n\n    {\n        .name       = \"object_del\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"destroy QOM object\",\n        .cmd        = hmp_object_del,\n        .command_completion = object_del_completion,\n    },\n\nSTEXI\n@item object_del\n@findex object_del\nDestroy QOM object.\nETEXI\n\n#ifdef CONFIG_SLIRP\n    {\n        .name       = \"hostfwd_add\",\n        .args_type  = \"arg1:s,arg2:s?,arg3:s?\",\n        .params     = \"[vlan_id name] [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\",\n        .help       = \"redirect TCP or UDP connections from host to guest (requires -net user)\",\n        .cmd        = hmp_hostfwd_add,\n    },\n#endif\nSTEXI\n@item hostfwd_add\n@findex hostfwd_add\nRedirect TCP or UDP connections from host to guest (requires -net user).\nETEXI\n\n#ifdef CONFIG_SLIRP\n    {\n        .name       = \"hostfwd_remove\",\n        .args_type  = \"arg1:s,arg2:s?,arg3:s?\",\n        .params     = \"[vlan_id name] [tcp|udp]:[hostaddr]:hostport\",\n        .help       = \"remove host-to-guest TCP or UDP redirection\",\n        .cmd        = hmp_hostfwd_remove,\n    },\n\n#endif\nSTEXI\n@item hostfwd_remove\n@findex hostfwd_remove\nRemove host-to-guest TCP or UDP redirection.\nETEXI\n\n    {\n        .name       = \"balloon\",\n        .args_type  = \"value:M\",\n        .params     = \"target\",\n        .help       = \"request VM to change its memory allocation (in MB)\",\n        .cmd        = hmp_balloon,\n    },\n\nSTEXI\n@item balloon @var{value}\n@findex balloon\nRequest VM to change its memory allocation to @var{value} (in MB).\nETEXI\n\n    {\n        .name       = \"set_link\",\n        .args_type  = \"name:s,up:b\",\n        .params     = \"name on|off\",\n        .help       = \"change the link status of a network adapter\",\n        .cmd        = hmp_set_link,\n        .command_completion = set_link_completion,\n    },\n\nSTEXI\n@item set_link @var{name} [on|off]\n@findex set_link\nSwitch link @var{name} on (i.e. up) or off (i.e. down).\nETEXI\n\n    {\n        .name       = \"watchdog_action\",\n        .args_type  = \"action:s\",\n        .params     = \"[reset|shutdown|poweroff|pause|debug|none]\",\n        .help       = \"change watchdog action\",\n        .cmd        = hmp_watchdog_action,\n        .command_completion = watchdog_action_completion,\n    },\n\nSTEXI\n@item watchdog_action\n@findex watchdog_action\nChange watchdog action.\nETEXI\n\n    {\n        .name       = \"acl_show\",\n        .args_type  = \"aclname:s\",\n        .params     = \"aclname\",\n        .help       = \"list rules in the access control list\",\n        .cmd        = hmp_acl_show,\n    },\n\nSTEXI\n@item acl_show @var{aclname}\n@findex acl_show\nList all the matching rules in the access control list, and the default\npolicy. There are currently two named access control lists,\n@var{vnc.x509dname} and @var{vnc.username} matching on the x509 client\ncertificate distinguished name, and SASL username respectively.\nETEXI\n\n    {\n        .name       = \"acl_policy\",\n        .args_type  = \"aclname:s,policy:s\",\n        .params     = \"aclname allow|deny\",\n        .help       = \"set default access control list policy\",\n        .cmd        = hmp_acl_policy,\n    },\n\nSTEXI\n@item acl_policy @var{aclname} @code{allow|deny}\n@findex acl_policy\nSet the default access control list policy, used in the event that\nnone of the explicit rules match. The default policy at startup is\nalways @code{deny}.\nETEXI\n\n    {\n        .name       = \"acl_add\",\n        .args_type  = \"aclname:s,match:s,policy:s,index:i?\",\n        .params     = \"aclname match allow|deny [index]\",\n        .help       = \"add a match rule to the access control list\",\n        .cmd        = hmp_acl_add,\n    },\n\nSTEXI\n@item acl_add @var{aclname} @var{match} @code{allow|deny} [@var{index}]\n@findex acl_add\nAdd a match rule to the access control list, allowing or denying access.\nThe match will normally be an exact username or x509 distinguished name,\nbut can optionally include wildcard globs. eg @code{*@@EXAMPLE.COM} to\nallow all users in the @code{EXAMPLE.COM} kerberos realm. The match will\nnormally be appended to the end of the ACL, but can be inserted\nearlier in the list if the optional @var{index} parameter is supplied.\nETEXI\n\n    {\n        .name       = \"acl_remove\",\n        .args_type  = \"aclname:s,match:s\",\n        .params     = \"aclname match\",\n        .help       = \"remove a match rule from the access control list\",\n        .cmd        = hmp_acl_remove,\n    },\n\nSTEXI\n@item acl_remove @var{aclname} @var{match}\n@findex acl_remove\nRemove the specified match rule from the access control list.\nETEXI\n\n    {\n        .name       = \"acl_reset\",\n        .args_type  = \"aclname:s\",\n        .params     = \"aclname\",\n        .help       = \"reset the access control list\",\n        .cmd        = hmp_acl_reset,\n    },\n\nSTEXI\n@item acl_reset @var{aclname}\n@findex acl_reset\nRemove all matches from the access control list, and set the default\npolicy back to @code{deny}.\nETEXI\n\n    {\n        .name       = \"nbd_server_start\",\n        .args_type  = \"all:-a,writable:-w,uri:s\",\n        .params     = \"nbd_server_start [-a] [-w] host:port\",\n        .help       = \"serve block devices on the given host and port\",\n        .cmd        = hmp_nbd_server_start,\n    },\nSTEXI\n@item nbd_server_start @var{host}:@var{port}\n@findex nbd_server_start\nStart an NBD server on the given host and/or port.  If the @option{-a}\noption is included, all of the virtual machine's block devices that\nhave an inserted media on them are automatically exported; in this case,\nthe @option{-w} option makes the devices writable too.\nETEXI\n\n    {\n        .name       = \"nbd_server_add\",\n        .args_type  = \"writable:-w,device:B\",\n        .params     = \"nbd_server_add [-w] device\",\n        .help       = \"export a block device via NBD\",\n        .cmd        = hmp_nbd_server_add,\n    },\nSTEXI\n@item nbd_server_add @var{device}\n@findex nbd_server_add\nExport a block device through QEMU's NBD server, which must be started\nbeforehand with @command{nbd_server_start}.  The @option{-w} option makes the\nexported device writable too.\nETEXI\n\n    {\n        .name       = \"nbd_server_stop\",\n        .args_type  = \"\",\n        .params     = \"nbd_server_stop\",\n        .help       = \"stop serving block devices using the NBD protocol\",\n        .cmd        = hmp_nbd_server_stop,\n    },\nSTEXI\n@item nbd_server_stop\n@findex nbd_server_stop\nStop the QEMU embedded NBD server.\nETEXI\n\n\n#if defined(TARGET_I386)\n\n    {\n        .name       = \"mce\",\n        .args_type  = \"broadcast:-b,cpu_index:i,bank:i,status:l,mcg_status:l,addr:l,misc:l\",\n        .params     = \"[-b] cpu bank status mcgstatus addr misc\",\n        .help       = \"inject a MCE on the given CPU [and broadcast to other CPUs with -b option]\",\n        .cmd        = hmp_mce,\n    },\n\n#endif\nSTEXI\n@item mce @var{cpu} @var{bank} @var{status} @var{mcgstatus} @var{addr} @var{misc}\n@findex mce (x86)\nInject an MCE on the given CPU (x86 only).\nETEXI\n\n    {\n        .name       = \"getfd\",\n        .args_type  = \"fdname:s\",\n        .params     = \"getfd name\",\n        .help       = \"receive a file descriptor via SCM rights and assign it a name\",\n        .cmd        = hmp_getfd,\n    },\n\nSTEXI\n@item getfd @var{fdname}\n@findex getfd\nIf a file descriptor is passed alongside this command using the SCM_RIGHTS\nmechanism on unix sockets, it is stored using the name @var{fdname} for\nlater use by other monitor commands.\nETEXI\n\n    {\n        .name       = \"closefd\",\n        .args_type  = \"fdname:s\",\n        .params     = \"closefd name\",\n        .help       = \"close a file descriptor previously passed via SCM rights\",\n        .cmd        = hmp_closefd,\n    },\n\nSTEXI\n@item closefd @var{fdname}\n@findex closefd\nClose the file descriptor previously assigned to @var{fdname} using the\n@code{getfd} command. This is only needed if the file descriptor was never\nused by another monitor command.\nETEXI\n\n    {\n        .name       = \"block_passwd\",\n        .args_type  = \"device:B,password:s\",\n        .params     = \"block_passwd device password\",\n        .help       = \"set the password of encrypted block devices\",\n        .cmd        = hmp_block_passwd,\n    },\n\nSTEXI\n@item block_passwd @var{device} @var{password}\n@findex block_passwd\nSet the encrypted device @var{device} password to @var{password}\nETEXI\n\n    {\n        .name       = \"block_set_io_throttle\",\n        .args_type  = \"device:B,bps:l,bps_rd:l,bps_wr:l,iops:l,iops_rd:l,iops_wr:l\",\n        .params     = \"device bps bps_rd bps_wr iops iops_rd iops_wr\",\n        .help       = \"change I/O throttle limits for a block drive\",\n        .cmd        = hmp_block_set_io_throttle,\n    },\n\nSTEXI\n@item block_set_io_throttle @var{device} @var{bps} @var{bps_rd} @var{bps_wr} @var{iops} @var{iops_rd} @var{iops_wr}\n@findex block_set_io_throttle\nChange I/O throttle limits for a block drive to @var{bps} @var{bps_rd} @var{bps_wr} @var{iops} @var{iops_rd} @var{iops_wr}\nETEXI\n\n    {\n        .name       = \"set_password\",\n        .args_type  = \"protocol:s,password:s,connected:s?\",\n        .params     = \"protocol password action-if-connected\",\n        .help       = \"set spice/vnc password\",\n        .cmd        = hmp_set_password,\n    },\n\nSTEXI\n@item set_password [ vnc | spice ] password [ action-if-connected ]\n@findex set_password\nChange spice/vnc password.  Use zero to make the password stay valid\nforever.  @var{action-if-connected} specifies what should happen in\ncase a connection is established: @var{fail} makes the password change\nfail.  @var{disconnect} changes the password and disconnects the\nclient.  @var{keep} changes the password and keeps the connection up.\n@var{keep} is the default.\nETEXI\n\n    {\n        .name       = \"expire_password\",\n        .args_type  = \"protocol:s,time:s\",\n        .params     = \"protocol time\",\n        .help       = \"set spice/vnc password expire-time\",\n        .cmd        = hmp_expire_password,\n    },\n\nSTEXI\n@item expire_password [ vnc | spice ] expire-time\n@findex expire_password\nSpecify when a password for spice/vnc becomes\ninvalid. @var{expire-time} accepts:\n\n@table @var\n@item now\nInvalidate password instantly.\n\n@item never\nPassword stays valid forever.\n\n@item +nsec\nPassword stays valid for @var{nsec} seconds starting now.\n\n@item nsec\nPassword is invalidated at the given time.  @var{nsec} are the seconds\npassed since 1970, i.e. unix epoch.\n\n@end table\nETEXI\n\n    {\n        .name       = \"chardev-add\",\n        .args_type  = \"args:s\",\n        .params     = \"args\",\n        .help       = \"add chardev\",\n        .cmd        = hmp_chardev_add,\n        .command_completion = chardev_add_completion,\n    },\n\nSTEXI\n@item chardev-add args\n@findex chardev-add\nchardev_add accepts the same parameters as the -chardev command line switch.\n\nETEXI\n\n    {\n        .name       = \"chardev-remove\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"remove chardev\",\n        .cmd        = hmp_chardev_remove,\n        .command_completion = chardev_remove_completion,\n    },\n\nSTEXI\n@item chardev-remove id\n@findex chardev-remove\nRemoves the chardev @var{id}.\n\nETEXI\n\n    {\n        .name       = \"qemu-io\",\n        .args_type  = \"device:B,command:s\",\n        .params     = \"[device] \\\"[command]\\\"\",\n        .help       = \"run a qemu-io command on a block device\",\n        .cmd        = hmp_qemu_io,\n    },\n\nSTEXI\n@item qemu-io @var{device} @var{command}\n@findex qemu-io\nExecutes a qemu-io command on the given block device.\n\nETEXI\n\n    {\n        .name       = \"cpu-add\",\n        .args_type  = \"id:i\",\n        .params     = \"id\",\n        .help       = \"add cpu\",\n        .cmd        = hmp_cpu_add,\n    },\n\nSTEXI\n@item cpu-add @var{id}\n@findex cpu-add\nAdd CPU with id @var{id}\nETEXI\n\n    {\n        .name       = \"qom-list\",\n        .args_type  = \"path:s?\",\n        .params     = \"path\",\n        .help       = \"list QOM properties\",\n        .cmd        = hmp_qom_list,\n    },\n\nSTEXI\n@item qom-list [@var{path}]\nPrint QOM properties of object at location @var{path}\nETEXI\n\n    {\n        .name       = \"qom-set\",\n        .args_type  = \"path:s,property:s,value:s\",\n        .params     = \"path property value\",\n        .help       = \"set QOM property\",\n        .cmd        = hmp_qom_set,\n    },\n\nSTEXI\n@item qom-set @var{path} @var{property} @var{value}\nSet QOM property @var{property} of object at location @var{path} to value @var{value}\nETEXI\n\n    {\n        .name       = \"info\",\n        .args_type  = \"item:s?\",\n        .params     = \"[subcommand]\",\n        .help       = \"show various information about the system state\",\n        .cmd        = hmp_info_help,\n        .sub_table  = info_cmds,\n    },\n\n    {\n        .name       = \"begin_record\",\n        .args_type  = \"file_name:s\",\n        .params     = \"[file_name]\",\n        .help       = \"begin recording for later replay\",\n        .cmd = hmp_begin_record,\n    },\n\n    {\n        .name       = \"begin_record_from\",\n        .args_type  = \"snapshot:s,file_name:s\",\n        .params     = \"[snapshot] [file_name]\",\n        .help       = \"begin recording from given snapshot for later replay\",\n        .cmd = hmp_begin_record_from,\n    },\n\n    {\n        .name       = \"end_record\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"end recording for later replay\",\n        .cmd = hmp_end_record,\n    },\n\n    {\n        .name       = \"begin_replay\",\n        .args_type  = \"file_name:s\",\n        .params     = \"[file_name]\",\n        .help       = \"begin to replay a record\",\n        .cmd = hmp_begin_replay,\n    },\n\n    {\n        .name       = \"load_plugin\",\n        .args_type  = \"plugin_name:s,plugin_args:s?\",\n        .params     = \"plugin_name [plugin_args]\",\n        .help       = \"Load a panda plugin\",\n        .cmd = hmp_panda_load_plugin,\n    },\n\n    {\n        .name       = \"unload_plugin\",\n        .args_type  = \"index:i\",\n        .params     = \"index\",\n        .help       = \"Unload a panda plugin\",\n        .cmd = hmp_panda_unload_plugin,\n    },\n\n    {\n        .name       = \"list_plugins\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"list the loaded plugins\",\n        .cmd = hmp_panda_list_plugins,\n    },\n\n    {\n        .name       = \"end_replay\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"end replay\",\n        .cmd = hmp_end_replay,\n    },\n\n    {\n        .name       = \"plugin_cmd\",\n        .args_type  = \"cmd:s\",\n        .params     = \"cmd\",\n        .help       = \"Execute a plugin monitor command\",\n        .cmd        = hmp_panda_plugin_cmd,\n    },\n\nSTEXI\n@end table\nETEXI\n"
        },
        {
          "name": "hmp.c",
          "type": "blob",
          "size": 80.08984375,
          "content": "/*\n * Human Monitor Interface\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n *  Anthony Liguori   <aliguori@us.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n#include \"hmp.h\"\n#include \"net/net.h\"\n#include \"net/eth.h\"\n#include \"sysemu/char.h\"\n#include \"sysemu/block-backend.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/option.h\"\n#include \"qemu/timer.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/sockets.h\"\n#include \"monitor/monitor.h\"\n#include \"monitor/qdev.h\"\n#include \"qapi/opts-visitor.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/string-output-visitor.h\"\n#include \"qapi/util.h\"\n#include \"qapi-visit.h\"\n#include \"qom/object_interfaces.h\"\n#include \"ui/console.h\"\n#include \"block/qapi.h\"\n#include \"qemu-io.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/error-report.h\"\n#include \"hw/intc/intc.h\"\n\n#ifdef CONFIG_SPICE\n#include <spice/enums.h>\n#endif\n\nstatic void hmp_handle_error(Monitor *mon, Error **errp)\n{\n    assert(errp);\n    if (*errp) {\n        error_report_err(*errp);\n    }\n}\n\nvoid hmp_info_name(Monitor *mon, const QDict *qdict)\n{\n    NameInfo *info;\n\n    info = qmp_query_name(NULL);\n    if (info->has_name) {\n        monitor_printf(mon, \"%s\\n\", info->name);\n    }\n    qapi_free_NameInfo(info);\n}\n\nvoid hmp_info_version(Monitor *mon, const QDict *qdict)\n{\n    VersionInfo *info;\n\n    info = qmp_query_version(NULL);\n\n    monitor_printf(mon, \"%\" PRId64 \".%\" PRId64 \".%\" PRId64 \"%s\\n\",\n                   info->qemu->major, info->qemu->minor, info->qemu->micro,\n                   info->package);\n\n    qapi_free_VersionInfo(info);\n}\n\nvoid hmp_info_kvm(Monitor *mon, const QDict *qdict)\n{\n    KvmInfo *info;\n\n    info = qmp_query_kvm(NULL);\n    monitor_printf(mon, \"kvm support: \");\n    if (info->present) {\n        monitor_printf(mon, \"%s\\n\", info->enabled ? \"enabled\" : \"disabled\");\n    } else {\n        monitor_printf(mon, \"not compiled\\n\");\n    }\n\n    qapi_free_KvmInfo(info);\n}\n\nvoid hmp_info_status(Monitor *mon, const QDict *qdict)\n{\n    StatusInfo *info;\n\n    info = qmp_query_status(NULL);\n\n    monitor_printf(mon, \"VM status: %s%s\",\n                   info->running ? \"running\" : \"paused\",\n                   info->singlestep ? \" (single step mode)\" : \"\");\n\n    if (!info->running && info->status != RUN_STATE_PAUSED) {\n        monitor_printf(mon, \" (%s)\", RunState_lookup[info->status]);\n    }\n\n    monitor_printf(mon, \"\\n\");\n\n    qapi_free_StatusInfo(info);\n}\n\nvoid hmp_info_uuid(Monitor *mon, const QDict *qdict)\n{\n    UuidInfo *info;\n\n    info = qmp_query_uuid(NULL);\n    monitor_printf(mon, \"%s\\n\", info->UUID);\n    qapi_free_UuidInfo(info);\n}\n\nvoid hmp_info_chardev(Monitor *mon, const QDict *qdict)\n{\n    ChardevInfoList *char_info, *info;\n\n    char_info = qmp_query_chardev(NULL);\n    for (info = char_info; info; info = info->next) {\n        monitor_printf(mon, \"%s: filename=%s\\n\", info->value->label,\n                                                 info->value->filename);\n    }\n\n    qapi_free_ChardevInfoList(char_info);\n}\n\nvoid hmp_info_mice(Monitor *mon, const QDict *qdict)\n{\n    MouseInfoList *mice_list, *mouse;\n\n    mice_list = qmp_query_mice(NULL);\n    if (!mice_list) {\n        monitor_printf(mon, \"No mouse devices connected\\n\");\n        return;\n    }\n\n    for (mouse = mice_list; mouse; mouse = mouse->next) {\n        monitor_printf(mon, \"%c Mouse #%\" PRId64 \": %s%s\\n\",\n                       mouse->value->current ? '*' : ' ',\n                       mouse->value->index, mouse->value->name,\n                       mouse->value->absolute ? \" (absolute)\" : \"\");\n    }\n\n    qapi_free_MouseInfoList(mice_list);\n}\n\nvoid hmp_info_migrate(Monitor *mon, const QDict *qdict)\n{\n    MigrationInfo *info;\n    MigrationCapabilityStatusList *caps, *cap;\n\n    info = qmp_query_migrate(NULL);\n    caps = qmp_query_migrate_capabilities(NULL);\n\n    /* do not display parameters during setup */\n    if (info->has_status && caps) {\n        monitor_printf(mon, \"capabilities: \");\n        for (cap = caps; cap; cap = cap->next) {\n            monitor_printf(mon, \"%s: %s \",\n                           MigrationCapability_lookup[cap->value->capability],\n                           cap->value->state ? \"on\" : \"off\");\n        }\n        monitor_printf(mon, \"\\n\");\n    }\n\n    if (info->has_status) {\n        monitor_printf(mon, \"Migration status: %s\",\n                       MigrationStatus_lookup[info->status]);\n        if (info->status == MIGRATION_STATUS_FAILED &&\n            info->has_error_desc) {\n            monitor_printf(mon, \" (%s)\\n\", info->error_desc);\n        } else {\n            monitor_printf(mon, \"\\n\");\n        }\n\n        monitor_printf(mon, \"total time: %\" PRIu64 \" milliseconds\\n\",\n                       info->total_time);\n        if (info->has_expected_downtime) {\n            monitor_printf(mon, \"expected downtime: %\" PRIu64 \" milliseconds\\n\",\n                           info->expected_downtime);\n        }\n        if (info->has_downtime) {\n            monitor_printf(mon, \"downtime: %\" PRIu64 \" milliseconds\\n\",\n                           info->downtime);\n        }\n        if (info->has_setup_time) {\n            monitor_printf(mon, \"setup: %\" PRIu64 \" milliseconds\\n\",\n                           info->setup_time);\n        }\n    }\n\n    if (info->has_ram) {\n        monitor_printf(mon, \"transferred ram: %\" PRIu64 \" kbytes\\n\",\n                       info->ram->transferred >> 10);\n        monitor_printf(mon, \"throughput: %0.2f mbps\\n\",\n                       info->ram->mbps);\n        monitor_printf(mon, \"remaining ram: %\" PRIu64 \" kbytes\\n\",\n                       info->ram->remaining >> 10);\n        monitor_printf(mon, \"total ram: %\" PRIu64 \" kbytes\\n\",\n                       info->ram->total >> 10);\n        monitor_printf(mon, \"duplicate: %\" PRIu64 \" pages\\n\",\n                       info->ram->duplicate);\n        monitor_printf(mon, \"skipped: %\" PRIu64 \" pages\\n\",\n                       info->ram->skipped);\n        monitor_printf(mon, \"normal: %\" PRIu64 \" pages\\n\",\n                       info->ram->normal);\n        monitor_printf(mon, \"normal bytes: %\" PRIu64 \" kbytes\\n\",\n                       info->ram->normal_bytes >> 10);\n        monitor_printf(mon, \"dirty sync count: %\" PRIu64 \"\\n\",\n                       info->ram->dirty_sync_count);\n        if (info->ram->dirty_pages_rate) {\n            monitor_printf(mon, \"dirty pages rate: %\" PRIu64 \" pages\\n\",\n                           info->ram->dirty_pages_rate);\n        }\n        if (info->ram->postcopy_requests) {\n            monitor_printf(mon, \"postcopy request count: %\" PRIu64 \"\\n\",\n                           info->ram->postcopy_requests);\n        }\n    }\n\n    if (info->has_disk) {\n        monitor_printf(mon, \"transferred disk: %\" PRIu64 \" kbytes\\n\",\n                       info->disk->transferred >> 10);\n        monitor_printf(mon, \"remaining disk: %\" PRIu64 \" kbytes\\n\",\n                       info->disk->remaining >> 10);\n        monitor_printf(mon, \"total disk: %\" PRIu64 \" kbytes\\n\",\n                       info->disk->total >> 10);\n    }\n\n    if (info->has_xbzrle_cache) {\n        monitor_printf(mon, \"cache size: %\" PRIu64 \" bytes\\n\",\n                       info->xbzrle_cache->cache_size);\n        monitor_printf(mon, \"xbzrle transferred: %\" PRIu64 \" kbytes\\n\",\n                       info->xbzrle_cache->bytes >> 10);\n        monitor_printf(mon, \"xbzrle pages: %\" PRIu64 \" pages\\n\",\n                       info->xbzrle_cache->pages);\n        monitor_printf(mon, \"xbzrle cache miss: %\" PRIu64 \"\\n\",\n                       info->xbzrle_cache->cache_miss);\n        monitor_printf(mon, \"xbzrle cache miss rate: %0.2f\\n\",\n                       info->xbzrle_cache->cache_miss_rate);\n        monitor_printf(mon, \"xbzrle overflow : %\" PRIu64 \"\\n\",\n                       info->xbzrle_cache->overflow);\n    }\n\n    if (info->has_cpu_throttle_percentage) {\n        monitor_printf(mon, \"cpu throttle percentage: %\" PRIu64 \"\\n\",\n                       info->cpu_throttle_percentage);\n    }\n\n    qapi_free_MigrationInfo(info);\n    qapi_free_MigrationCapabilityStatusList(caps);\n}\n\nvoid hmp_info_migrate_capabilities(Monitor *mon, const QDict *qdict)\n{\n    MigrationCapabilityStatusList *caps, *cap;\n\n    caps = qmp_query_migrate_capabilities(NULL);\n\n    if (caps) {\n        monitor_printf(mon, \"capabilities: \");\n        for (cap = caps; cap; cap = cap->next) {\n            monitor_printf(mon, \"%s: %s \",\n                           MigrationCapability_lookup[cap->value->capability],\n                           cap->value->state ? \"on\" : \"off\");\n        }\n        monitor_printf(mon, \"\\n\");\n    }\n\n    qapi_free_MigrationCapabilityStatusList(caps);\n}\n\nvoid hmp_info_migrate_parameters(Monitor *mon, const QDict *qdict)\n{\n    MigrationParameters *params;\n\n    params = qmp_query_migrate_parameters(NULL);\n\n    if (params) {\n        monitor_printf(mon, \"parameters:\");\n        assert(params->has_compress_level);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_COMPRESS_LEVEL],\n            params->compress_level);\n        assert(params->has_compress_threads);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_COMPRESS_THREADS],\n            params->compress_threads);\n        assert(params->has_decompress_threads);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_DECOMPRESS_THREADS],\n            params->decompress_threads);\n        assert(params->has_cpu_throttle_initial);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_CPU_THROTTLE_INITIAL],\n            params->cpu_throttle_initial);\n        assert(params->has_cpu_throttle_increment);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_CPU_THROTTLE_INCREMENT],\n            params->cpu_throttle_increment);\n        monitor_printf(mon, \" %s: '%s'\",\n            MigrationParameter_lookup[MIGRATION_PARAMETER_TLS_CREDS],\n            params->has_tls_creds ? params->tls_creds : \"\");\n        monitor_printf(mon, \" %s: '%s'\",\n            MigrationParameter_lookup[MIGRATION_PARAMETER_TLS_HOSTNAME],\n            params->has_tls_hostname ? params->tls_hostname : \"\");\n        assert(params->has_max_bandwidth);\n        monitor_printf(mon, \" %s: %\" PRId64 \" bytes/second\",\n            MigrationParameter_lookup[MIGRATION_PARAMETER_MAX_BANDWIDTH],\n            params->max_bandwidth);\n        assert(params->has_downtime_limit);\n        monitor_printf(mon, \" %s: %\" PRId64 \" milliseconds\",\n            MigrationParameter_lookup[MIGRATION_PARAMETER_DOWNTIME_LIMIT],\n            params->downtime_limit);\n        assert(params->has_x_checkpoint_delay);\n        monitor_printf(mon, \" %s: %\" PRId64,\n            MigrationParameter_lookup[MIGRATION_PARAMETER_X_CHECKPOINT_DELAY],\n            params->x_checkpoint_delay);\n        monitor_printf(mon, \"\\n\");\n    }\n\n    qapi_free_MigrationParameters(params);\n}\n\nvoid hmp_info_migrate_cache_size(Monitor *mon, const QDict *qdict)\n{\n    monitor_printf(mon, \"xbzrel cache size: %\" PRId64 \" kbytes\\n\",\n                   qmp_query_migrate_cache_size(NULL) >> 10);\n}\n\nvoid hmp_info_cpus(Monitor *mon, const QDict *qdict)\n{\n    CpuInfoList *cpu_list, *cpu;\n\n    cpu_list = qmp_query_cpus(NULL);\n\n    for (cpu = cpu_list; cpu; cpu = cpu->next) {\n        int active = ' ';\n\n        if (cpu->value->CPU == monitor_get_cpu_index()) {\n            active = '*';\n        }\n\n        monitor_printf(mon, \"%c CPU #%\" PRId64 \":\", active, cpu->value->CPU);\n\n        switch (cpu->value->arch) {\n        case CPU_INFO_ARCH_X86:\n            monitor_printf(mon, \" pc=0x%016\" PRIx64, cpu->value->u.x86.pc);\n            break;\n        case CPU_INFO_ARCH_PPC:\n            monitor_printf(mon, \" nip=0x%016\" PRIx64, cpu->value->u.ppc.nip);\n            break;\n        case CPU_INFO_ARCH_SPARC:\n            monitor_printf(mon, \" pc=0x%016\" PRIx64,\n                           cpu->value->u.q_sparc.pc);\n            monitor_printf(mon, \" npc=0x%016\" PRIx64,\n                           cpu->value->u.q_sparc.npc);\n            break;\n        case CPU_INFO_ARCH_MIPS:\n            monitor_printf(mon, \" PC=0x%016\" PRIx64, cpu->value->u.q_mips.PC);\n            break;\n        case CPU_INFO_ARCH_TRICORE:\n            monitor_printf(mon, \" PC=0x%016\" PRIx64, cpu->value->u.tricore.PC);\n            break;\n        default:\n            break;\n        }\n\n        if (cpu->value->halted) {\n            monitor_printf(mon, \" (halted)\");\n        }\n\n        monitor_printf(mon, \" thread_id=%\" PRId64 \"\\n\", cpu->value->thread_id);\n    }\n\n    qapi_free_CpuInfoList(cpu_list);\n}\n\nstatic void print_block_info(Monitor *mon, BlockInfo *info,\n                             BlockDeviceInfo *inserted, bool verbose)\n{\n    ImageInfo *image_info;\n\n    assert(!info || !info->has_inserted || info->inserted == inserted);\n\n    if (info) {\n        monitor_printf(mon, \"%s\", info->device);\n        if (inserted && inserted->has_node_name) {\n            monitor_printf(mon, \" (%s)\", inserted->node_name);\n        }\n    } else {\n        assert(inserted);\n        monitor_printf(mon, \"%s\",\n                       inserted->has_node_name\n                       ? inserted->node_name\n                       : \"<anonymous>\");\n    }\n\n    if (inserted) {\n        monitor_printf(mon, \": %s (%s%s%s)\\n\",\n                       inserted->file,\n                       inserted->drv,\n                       inserted->ro ? \", read-only\" : \"\",\n                       inserted->encrypted ? \", encrypted\" : \"\");\n    } else {\n        monitor_printf(mon, \": [not inserted]\\n\");\n    }\n\n    if (info) {\n        if (info->has_io_status && info->io_status != BLOCK_DEVICE_IO_STATUS_OK) {\n            monitor_printf(mon, \"    I/O status:       %s\\n\",\n                           BlockDeviceIoStatus_lookup[info->io_status]);\n        }\n\n        if (info->removable) {\n            monitor_printf(mon, \"    Removable device: %slocked, tray %s\\n\",\n                           info->locked ? \"\" : \"not \",\n                           info->tray_open ? \"open\" : \"closed\");\n        }\n    }\n\n\n    if (!inserted) {\n        return;\n    }\n\n    monitor_printf(mon, \"    Cache mode:       %s%s%s\\n\",\n                   inserted->cache->writeback ? \"writeback\" : \"writethrough\",\n                   inserted->cache->direct ? \", direct\" : \"\",\n                   inserted->cache->no_flush ? \", ignore flushes\" : \"\");\n\n    if (inserted->has_backing_file) {\n        monitor_printf(mon,\n                       \"    Backing file:     %s \"\n                       \"(chain depth: %\" PRId64 \")\\n\",\n                       inserted->backing_file,\n                       inserted->backing_file_depth);\n    }\n\n    if (inserted->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF) {\n        monitor_printf(mon, \"    Detect zeroes:    %s\\n\",\n                       BlockdevDetectZeroesOptions_lookup[inserted->detect_zeroes]);\n    }\n\n    if (inserted->bps  || inserted->bps_rd  || inserted->bps_wr  ||\n        inserted->iops || inserted->iops_rd || inserted->iops_wr)\n    {\n        monitor_printf(mon, \"    I/O throttling:   bps=%\" PRId64\n                        \" bps_rd=%\" PRId64  \" bps_wr=%\" PRId64\n                        \" bps_max=%\" PRId64\n                        \" bps_rd_max=%\" PRId64\n                        \" bps_wr_max=%\" PRId64\n                        \" iops=%\" PRId64 \" iops_rd=%\" PRId64\n                        \" iops_wr=%\" PRId64\n                        \" iops_max=%\" PRId64\n                        \" iops_rd_max=%\" PRId64\n                        \" iops_wr_max=%\" PRId64\n                        \" iops_size=%\" PRId64\n                        \" group=%s\\n\",\n                        inserted->bps,\n                        inserted->bps_rd,\n                        inserted->bps_wr,\n                        inserted->bps_max,\n                        inserted->bps_rd_max,\n                        inserted->bps_wr_max,\n                        inserted->iops,\n                        inserted->iops_rd,\n                        inserted->iops_wr,\n                        inserted->iops_max,\n                        inserted->iops_rd_max,\n                        inserted->iops_wr_max,\n                        inserted->iops_size,\n                        inserted->group);\n    }\n\n    if (verbose) {\n        monitor_printf(mon, \"\\nImages:\\n\");\n        image_info = inserted->image;\n        while (1) {\n                bdrv_image_info_dump((fprintf_function)monitor_printf,\n                                     mon, image_info);\n            if (image_info->has_backing_image) {\n                image_info = image_info->backing_image;\n            } else {\n                break;\n            }\n        }\n    }\n}\n\nvoid hmp_info_block(Monitor *mon, const QDict *qdict)\n{\n    BlockInfoList *block_list, *info;\n    BlockDeviceInfoList *blockdev_list, *blockdev;\n    const char *device = qdict_get_try_str(qdict, \"device\");\n    bool verbose = qdict_get_try_bool(qdict, \"verbose\", false);\n    bool nodes = qdict_get_try_bool(qdict, \"nodes\", false);\n    bool printed = false;\n\n    /* Print BlockBackend information */\n    if (!nodes) {\n        block_list = qmp_query_block(NULL);\n    } else {\n        block_list = NULL;\n    }\n\n    for (info = block_list; info; info = info->next) {\n        if (device && strcmp(device, info->value->device)) {\n            continue;\n        }\n\n        if (info != block_list) {\n            monitor_printf(mon, \"\\n\");\n        }\n\n        print_block_info(mon, info->value, info->value->has_inserted\n                                           ? info->value->inserted : NULL,\n                         verbose);\n        printed = true;\n    }\n\n    qapi_free_BlockInfoList(block_list);\n\n    if ((!device && !nodes) || printed) {\n        return;\n    }\n\n    /* Print node information */\n    blockdev_list = qmp_query_named_block_nodes(NULL);\n    for (blockdev = blockdev_list; blockdev; blockdev = blockdev->next) {\n        assert(blockdev->value->has_node_name);\n        if (device && strcmp(device, blockdev->value->node_name)) {\n            continue;\n        }\n\n        if (blockdev != blockdev_list) {\n            monitor_printf(mon, \"\\n\");\n        }\n\n        print_block_info(mon, NULL, blockdev->value, verbose);\n    }\n    qapi_free_BlockDeviceInfoList(blockdev_list);\n}\n\nvoid hmp_info_blockstats(Monitor *mon, const QDict *qdict)\n{\n    BlockStatsList *stats_list, *stats;\n\n    stats_list = qmp_query_blockstats(false, false, NULL);\n\n    for (stats = stats_list; stats; stats = stats->next) {\n        if (!stats->value->has_device) {\n            continue;\n        }\n\n        monitor_printf(mon, \"%s:\", stats->value->device);\n        monitor_printf(mon, \" rd_bytes=%\" PRId64\n                       \" wr_bytes=%\" PRId64\n                       \" rd_operations=%\" PRId64\n                       \" wr_operations=%\" PRId64\n                       \" flush_operations=%\" PRId64\n                       \" wr_total_time_ns=%\" PRId64\n                       \" rd_total_time_ns=%\" PRId64\n                       \" flush_total_time_ns=%\" PRId64\n                       \" rd_merged=%\" PRId64\n                       \" wr_merged=%\" PRId64\n                       \" idle_time_ns=%\" PRId64\n                       \"\\n\",\n                       stats->value->stats->rd_bytes,\n                       stats->value->stats->wr_bytes,\n                       stats->value->stats->rd_operations,\n                       stats->value->stats->wr_operations,\n                       stats->value->stats->flush_operations,\n                       stats->value->stats->wr_total_time_ns,\n                       stats->value->stats->rd_total_time_ns,\n                       stats->value->stats->flush_total_time_ns,\n                       stats->value->stats->rd_merged,\n                       stats->value->stats->wr_merged,\n                       stats->value->stats->idle_time_ns);\n    }\n\n    qapi_free_BlockStatsList(stats_list);\n}\n\nvoid hmp_info_vnc(Monitor *mon, const QDict *qdict)\n{\n    VncInfo *info;\n    Error *err = NULL;\n    VncClientInfoList *client;\n\n    info = qmp_query_vnc(&err);\n    if (err) {\n        error_report_err(err);\n        return;\n    }\n\n    if (!info->enabled) {\n        monitor_printf(mon, \"Server: disabled\\n\");\n        goto out;\n    }\n\n    monitor_printf(mon, \"Server:\\n\");\n    if (info->has_host && info->has_service) {\n        monitor_printf(mon, \"     address: %s:%s\\n\", info->host, info->service);\n    }\n    if (info->has_auth) {\n        monitor_printf(mon, \"        auth: %s\\n\", info->auth);\n    }\n\n    if (!info->has_clients || info->clients == NULL) {\n        monitor_printf(mon, \"Client: none\\n\");\n    } else {\n        for (client = info->clients; client; client = client->next) {\n            monitor_printf(mon, \"Client:\\n\");\n            monitor_printf(mon, \"     address: %s:%s\\n\",\n                           client->value->host,\n                           client->value->service);\n            monitor_printf(mon, \"  x509_dname: %s\\n\",\n                           client->value->x509_dname ?\n                           client->value->x509_dname : \"none\");\n            monitor_printf(mon, \"    username: %s\\n\",\n                           client->value->has_sasl_username ?\n                           client->value->sasl_username : \"none\");\n        }\n    }\n\nout:\n    qapi_free_VncInfo(info);\n}\n\n#ifdef CONFIG_SPICE\nvoid hmp_info_spice(Monitor *mon, const QDict *qdict)\n{\n    SpiceChannelList *chan;\n    SpiceInfo *info;\n    const char *channel_name;\n    const char * const channel_names[] = {\n        [SPICE_CHANNEL_MAIN] = \"main\",\n        [SPICE_CHANNEL_DISPLAY] = \"display\",\n        [SPICE_CHANNEL_INPUTS] = \"inputs\",\n        [SPICE_CHANNEL_CURSOR] = \"cursor\",\n        [SPICE_CHANNEL_PLAYBACK] = \"playback\",\n        [SPICE_CHANNEL_RECORD] = \"record\",\n        [SPICE_CHANNEL_TUNNEL] = \"tunnel\",\n        [SPICE_CHANNEL_SMARTCARD] = \"smartcard\",\n        [SPICE_CHANNEL_USBREDIR] = \"usbredir\",\n        [SPICE_CHANNEL_PORT] = \"port\",\n#if 0\n        /* minimum spice-protocol is 0.12.3, webdav was added in 0.12.7,\n         * no easy way to #ifdef (SPICE_CHANNEL_* is a enum).  Disable\n         * as quick fix for build failures with older versions. */\n        [SPICE_CHANNEL_WEBDAV] = \"webdav\",\n#endif\n    };\n\n    info = qmp_query_spice(NULL);\n\n    if (!info->enabled) {\n        monitor_printf(mon, \"Server: disabled\\n\");\n        goto out;\n    }\n\n    monitor_printf(mon, \"Server:\\n\");\n    if (info->has_port) {\n        monitor_printf(mon, \"     address: %s:%\" PRId64 \"\\n\",\n                       info->host, info->port);\n    }\n    if (info->has_tls_port) {\n        monitor_printf(mon, \"     address: %s:%\" PRId64 \" [tls]\\n\",\n                       info->host, info->tls_port);\n    }\n    monitor_printf(mon, \"    migrated: %s\\n\",\n                   info->migrated ? \"true\" : \"false\");\n    monitor_printf(mon, \"        auth: %s\\n\", info->auth);\n    monitor_printf(mon, \"    compiled: %s\\n\", info->compiled_version);\n    monitor_printf(mon, \"  mouse-mode: %s\\n\",\n                   SpiceQueryMouseMode_lookup[info->mouse_mode]);\n\n    if (!info->has_channels || info->channels == NULL) {\n        monitor_printf(mon, \"Channels: none\\n\");\n    } else {\n        for (chan = info->channels; chan; chan = chan->next) {\n            monitor_printf(mon, \"Channel:\\n\");\n            monitor_printf(mon, \"     address: %s:%s%s\\n\",\n                           chan->value->host, chan->value->port,\n                           chan->value->tls ? \" [tls]\" : \"\");\n            monitor_printf(mon, \"     session: %\" PRId64 \"\\n\",\n                           chan->value->connection_id);\n            monitor_printf(mon, \"     channel: %\" PRId64 \":%\" PRId64 \"\\n\",\n                           chan->value->channel_type, chan->value->channel_id);\n\n            channel_name = \"unknown\";\n            if (chan->value->channel_type > 0 &&\n                chan->value->channel_type < ARRAY_SIZE(channel_names) &&\n                channel_names[chan->value->channel_type]) {\n                channel_name = channel_names[chan->value->channel_type];\n            }\n\n            monitor_printf(mon, \"     channel name: %s\\n\", channel_name);\n        }\n    }\n\nout:\n    qapi_free_SpiceInfo(info);\n}\n#endif\n\nvoid hmp_info_balloon(Monitor *mon, const QDict *qdict)\n{\n    BalloonInfo *info;\n    Error *err = NULL;\n\n    info = qmp_query_balloon(&err);\n    if (err) {\n        error_report_err(err);\n        return;\n    }\n\n    monitor_printf(mon, \"balloon: actual=%\" PRId64 \"\\n\", info->actual >> 20);\n\n    qapi_free_BalloonInfo(info);\n}\n\nstatic void hmp_info_pci_device(Monitor *mon, const PciDeviceInfo *dev)\n{\n    PciMemoryRegionList *region;\n\n    monitor_printf(mon, \"  Bus %2\" PRId64 \", \", dev->bus);\n    monitor_printf(mon, \"device %3\" PRId64 \", function %\" PRId64 \":\\n\",\n                   dev->slot, dev->function);\n    monitor_printf(mon, \"    \");\n\n    if (dev->class_info->has_desc) {\n        monitor_printf(mon, \"%s\", dev->class_info->desc);\n    } else {\n        monitor_printf(mon, \"Class %04\" PRId64, dev->class_info->q_class);\n    }\n\n    monitor_printf(mon, \": PCI device %04\" PRIx64 \":%04\" PRIx64 \"\\n\",\n                   dev->id->vendor, dev->id->device);\n\n    if (dev->has_irq) {\n        monitor_printf(mon, \"      IRQ %\" PRId64 \".\\n\", dev->irq);\n    }\n\n    if (dev->has_pci_bridge) {\n        monitor_printf(mon, \"      BUS %\" PRId64 \".\\n\",\n                       dev->pci_bridge->bus->number);\n        monitor_printf(mon, \"      secondary bus %\" PRId64 \".\\n\",\n                       dev->pci_bridge->bus->secondary);\n        monitor_printf(mon, \"      subordinate bus %\" PRId64 \".\\n\",\n                       dev->pci_bridge->bus->subordinate);\n\n        monitor_printf(mon, \"      IO range [0x%04\"PRIx64\", 0x%04\"PRIx64\"]\\n\",\n                       dev->pci_bridge->bus->io_range->base,\n                       dev->pci_bridge->bus->io_range->limit);\n\n        monitor_printf(mon,\n                       \"      memory range [0x%08\"PRIx64\", 0x%08\"PRIx64\"]\\n\",\n                       dev->pci_bridge->bus->memory_range->base,\n                       dev->pci_bridge->bus->memory_range->limit);\n\n        monitor_printf(mon, \"      prefetchable memory range \"\n                       \"[0x%08\"PRIx64\", 0x%08\"PRIx64\"]\\n\",\n                       dev->pci_bridge->bus->prefetchable_range->base,\n                       dev->pci_bridge->bus->prefetchable_range->limit);\n    }\n\n    for (region = dev->regions; region; region = region->next) {\n        uint64_t addr, size;\n\n        addr = region->value->address;\n        size = region->value->size;\n\n        monitor_printf(mon, \"      BAR%\" PRId64 \": \", region->value->bar);\n\n        if (!strcmp(region->value->type, \"io\")) {\n            monitor_printf(mon, \"I/O at 0x%04\" PRIx64\n                                \" [0x%04\" PRIx64 \"].\\n\",\n                           addr, addr + size - 1);\n        } else {\n            monitor_printf(mon, \"%d bit%s memory at 0x%08\" PRIx64\n                               \" [0x%08\" PRIx64 \"].\\n\",\n                           region->value->mem_type_64 ? 64 : 32,\n                           region->value->prefetch ? \" prefetchable\" : \"\",\n                           addr, addr + size - 1);\n        }\n    }\n\n    monitor_printf(mon, \"      id \\\"%s\\\"\\n\", dev->qdev_id);\n\n    if (dev->has_pci_bridge) {\n        if (dev->pci_bridge->has_devices) {\n            PciDeviceInfoList *cdev;\n            for (cdev = dev->pci_bridge->devices; cdev; cdev = cdev->next) {\n                hmp_info_pci_device(mon, cdev->value);\n            }\n        }\n    }\n}\n\nstatic int hmp_info_irq_foreach(Object *obj, void *opaque)\n{\n    InterruptStatsProvider *intc;\n    InterruptStatsProviderClass *k;\n    Monitor *mon = opaque;\n\n    if (object_dynamic_cast(obj, TYPE_INTERRUPT_STATS_PROVIDER)) {\n        intc = INTERRUPT_STATS_PROVIDER(obj);\n        k = INTERRUPT_STATS_PROVIDER_GET_CLASS(obj);\n        uint64_t *irq_counts;\n        unsigned int nb_irqs, i;\n        if (k->get_statistics &&\n            k->get_statistics(intc, &irq_counts, &nb_irqs)) {\n            if (nb_irqs > 0) {\n                monitor_printf(mon, \"IRQ statistics for %s:\\n\",\n                               object_get_typename(obj));\n                for (i = 0; i < nb_irqs; i++) {\n                    if (irq_counts[i] > 0) {\n                        monitor_printf(mon, \"%2d: %\" PRId64 \"\\n\", i,\n                                       irq_counts[i]);\n                    }\n                }\n            }\n        } else {\n            monitor_printf(mon, \"IRQ statistics not available for %s.\\n\",\n                           object_get_typename(obj));\n        }\n    }\n\n    return 0;\n}\n\nvoid hmp_info_irq(Monitor *mon, const QDict *qdict)\n{\n    object_child_foreach_recursive(object_get_root(),\n                                   hmp_info_irq_foreach, mon);\n}\n\nstatic int hmp_info_pic_foreach(Object *obj, void *opaque)\n{\n    InterruptStatsProvider *intc;\n    InterruptStatsProviderClass *k;\n    Monitor *mon = opaque;\n\n    if (object_dynamic_cast(obj, TYPE_INTERRUPT_STATS_PROVIDER)) {\n        intc = INTERRUPT_STATS_PROVIDER(obj);\n        k = INTERRUPT_STATS_PROVIDER_GET_CLASS(obj);\n        if (k->print_info) {\n            k->print_info(intc, mon);\n        } else {\n            monitor_printf(mon, \"Interrupt controller information not available for %s.\\n\",\n                           object_get_typename(obj));\n        }\n    }\n\n    return 0;\n}\n\nvoid hmp_info_pic(Monitor *mon, const QDict *qdict)\n{\n    object_child_foreach_recursive(object_get_root(),\n                                   hmp_info_pic_foreach, mon);\n}\n\nvoid hmp_info_pci(Monitor *mon, const QDict *qdict)\n{\n    PciInfoList *info_list, *info;\n    Error *err = NULL;\n\n    info_list = qmp_query_pci(&err);\n    if (err) {\n        monitor_printf(mon, \"PCI devices not supported\\n\");\n        error_free(err);\n        return;\n    }\n\n    for (info = info_list; info; info = info->next) {\n        PciDeviceInfoList *dev;\n\n        for (dev = info->value->devices; dev; dev = dev->next) {\n            hmp_info_pci_device(mon, dev->value);\n        }\n    }\n\n    qapi_free_PciInfoList(info_list);\n}\n\nvoid hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n\n    qapi_free_BlockJobInfoList(list);\n}\n\nvoid hmp_info_tpm(Monitor *mon, const QDict *qdict)\n{\n    TPMInfoList *info_list, *info;\n    Error *err = NULL;\n    unsigned int c = 0;\n    TPMPassthroughOptions *tpo;\n\n    info_list = qmp_query_tpm(&err);\n    if (err) {\n        monitor_printf(mon, \"TPM device not supported\\n\");\n        error_free(err);\n        return;\n    }\n\n    if (info_list) {\n        monitor_printf(mon, \"TPM device:\\n\");\n    }\n\n    for (info = info_list; info; info = info->next) {\n        TPMInfo *ti = info->value;\n        monitor_printf(mon, \" tpm%d: model=%s\\n\",\n                       c, TpmModel_lookup[ti->model]);\n\n        monitor_printf(mon, \"  \\\\ %s: type=%s\",\n                       ti->id, TpmTypeOptionsKind_lookup[ti->options->type]);\n\n        switch (ti->options->type) {\n        case TPM_TYPE_OPTIONS_KIND_PASSTHROUGH:\n            tpo = ti->options->u.passthrough.data;\n            monitor_printf(mon, \"%s%s%s%s\",\n                           tpo->has_path ? \",path=\" : \"\",\n                           tpo->has_path ? tpo->path : \"\",\n                           tpo->has_cancel_path ? \",cancel-path=\" : \"\",\n                           tpo->has_cancel_path ? tpo->cancel_path : \"\");\n            break;\n        case TPM_TYPE_OPTIONS_KIND__MAX:\n            break;\n        }\n        monitor_printf(mon, \"\\n\");\n        c++;\n    }\n    qapi_free_TPMInfoList(info_list);\n}\n\nvoid hmp_quit(Monitor *mon, const QDict *qdict)\n{\n    monitor_suspend(mon);\n    qmp_quit(NULL);\n}\n\nvoid hmp_stop(Monitor *mon, const QDict *qdict)\n{\n    qmp_stop(NULL);\n}\n\nvoid hmp_system_reset(Monitor *mon, const QDict *qdict)\n{\n    qmp_system_reset(NULL);\n}\n\nvoid hmp_system_powerdown(Monitor *mon, const QDict *qdict)\n{\n    qmp_system_powerdown(NULL);\n}\n\nvoid hmp_cpu(Monitor *mon, const QDict *qdict)\n{\n    int64_t cpu_index;\n\n    /* XXX: drop the monitor_set_cpu() usage when all HMP commands that\n            use it are converted to the QAPI */\n    cpu_index = qdict_get_int(qdict, \"index\");\n    if (monitor_set_cpu(cpu_index) < 0) {\n        monitor_printf(mon, \"invalid CPU index\\n\");\n    }\n}\n\nvoid hmp_memsave(Monitor *mon, const QDict *qdict)\n{\n    uint32_t size = qdict_get_int(qdict, \"size\");\n    const char *filename = qdict_get_str(qdict, \"filename\");\n    uint64_t addr = qdict_get_int(qdict, \"val\");\n    Error *err = NULL;\n    int cpu_index = monitor_get_cpu_index();\n\n    if (cpu_index < 0) {\n        monitor_printf(mon, \"No CPU available\\n\");\n        return;\n    }\n\n    qmp_memsave(addr, size, filename, true, cpu_index, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_pmemsave(Monitor *mon, const QDict *qdict)\n{\n    uint32_t size = qdict_get_int(qdict, \"size\");\n    const char *filename = qdict_get_str(qdict, \"filename\");\n    uint64_t addr = qdict_get_int(qdict, \"val\");\n    Error *err = NULL;\n\n    qmp_pmemsave(addr, size, filename, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_ringbuf_write(Monitor *mon, const QDict *qdict)\n{\n    const char *chardev = qdict_get_str(qdict, \"device\");\n    const char *data = qdict_get_str(qdict, \"data\");\n    Error *err = NULL;\n\n    qmp_ringbuf_write(chardev, data, false, 0, &err);\n\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_ringbuf_read(Monitor *mon, const QDict *qdict)\n{\n    uint32_t size = qdict_get_int(qdict, \"size\");\n    const char *chardev = qdict_get_str(qdict, \"device\");\n    char *data;\n    Error *err = NULL;\n    int i;\n\n    data = qmp_ringbuf_read(chardev, size, false, 0, &err);\n    if (err) {\n        error_report_err(err);\n        return;\n    }\n\n    for (i = 0; data[i]; i++) {\n        unsigned char ch = data[i];\n\n        if (ch == '\\\\') {\n            monitor_printf(mon, \"\\\\\\\\\");\n        } else if ((ch < 0x20 && ch != '\\n' && ch != '\\t') || ch == 0x7F) {\n            monitor_printf(mon, \"\\\\u%04X\", ch);\n        } else {\n            monitor_printf(mon, \"%c\", ch);\n        }\n\n    }\n    monitor_printf(mon, \"\\n\");\n    g_free(data);\n}\n\nstatic void hmp_cont_cb(void *opaque, int err)\n{\n    if (!err) {\n        qmp_cont(NULL);\n    }\n}\n\nstatic bool key_is_missing(const BlockInfo *bdev)\n{\n    return (bdev->inserted && bdev->inserted->encryption_key_missing);\n}\n\nvoid hmp_cont(Monitor *mon, const QDict *qdict)\n{\n    BlockInfoList *bdev_list, *bdev;\n    Error *err = NULL;\n\n    bdev_list = qmp_query_block(NULL);\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n        if (key_is_missing(bdev->value)) {\n            monitor_read_block_device_key(mon, bdev->value->device,\n                                          hmp_cont_cb, NULL);\n            goto out;\n        }\n    }\n\n    qmp_cont(&err);\n    hmp_handle_error(mon, &err);\n\nout:\n    qapi_free_BlockInfoList(bdev_list);\n}\n\nvoid hmp_system_wakeup(Monitor *mon, const QDict *qdict)\n{\n    qmp_system_wakeup(NULL);\n}\n\nvoid hmp_nmi(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n\n    qmp_inject_nmi(&err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_set_link(Monitor *mon, const QDict *qdict)\n{\n    const char *name = qdict_get_str(qdict, \"name\");\n    bool up = qdict_get_bool(qdict, \"up\");\n    Error *err = NULL;\n\n    qmp_set_link(name, up, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_block_passwd(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *password = qdict_get_str(qdict, \"password\");\n    Error *err = NULL;\n\n    qmp_block_passwd(true, device, false, NULL, password, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_balloon(Monitor *mon, const QDict *qdict)\n{\n    int64_t value = qdict_get_int(qdict, \"value\");\n    Error *err = NULL;\n\n    qmp_balloon(value, &err);\n    if (err) {\n        error_report_err(err);\n    }\n}\n\nvoid hmp_block_resize(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    int64_t size = qdict_get_int(qdict, \"size\");\n    Error *err = NULL;\n\n    qmp_block_resize(true, device, false, NULL, size, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_drive_mirror(Monitor *mon, const QDict *qdict)\n{\n    const char *filename = qdict_get_str(qdict, \"target\");\n    const char *format = qdict_get_try_str(qdict, \"format\");\n    bool reuse = qdict_get_try_bool(qdict, \"reuse\", false);\n    bool full = qdict_get_try_bool(qdict, \"full\", false);\n    Error *err = NULL;\n    DriveMirror mirror = {\n        .device = (char *)qdict_get_str(qdict, \"device\"),\n        .target = (char *)filename,\n        .has_format = !!format,\n        .format = (char *)format,\n        .sync = full ? MIRROR_SYNC_MODE_FULL : MIRROR_SYNC_MODE_TOP,\n        .has_mode = true,\n        .mode = reuse ? NEW_IMAGE_MODE_EXISTING : NEW_IMAGE_MODE_ABSOLUTE_PATHS,\n        .unmap = true,\n    };\n\n    if (!filename) {\n        error_setg(&err, QERR_MISSING_PARAMETER, \"target\");\n        hmp_handle_error(mon, &err);\n        return;\n    }\n    qmp_drive_mirror(&mirror, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_drive_backup(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *filename = qdict_get_str(qdict, \"target\");\n    const char *format = qdict_get_try_str(qdict, \"format\");\n    bool reuse = qdict_get_try_bool(qdict, \"reuse\", false);\n    bool full = qdict_get_try_bool(qdict, \"full\", false);\n    bool compress = qdict_get_try_bool(qdict, \"compress\", false);\n    Error *err = NULL;\n    DriveBackup backup = {\n        .device = (char *)device,\n        .target = (char *)filename,\n        .has_format = !!format,\n        .format = (char *)format,\n        .sync = full ? MIRROR_SYNC_MODE_FULL : MIRROR_SYNC_MODE_TOP,\n        .has_mode = true,\n        .mode = reuse ? NEW_IMAGE_MODE_EXISTING : NEW_IMAGE_MODE_ABSOLUTE_PATHS,\n        .has_compress = !!compress,\n        .compress = compress,\n    };\n\n    if (!filename) {\n        error_setg(&err, QERR_MISSING_PARAMETER, \"target\");\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    qmp_drive_backup(&backup, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_snapshot_blkdev(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *filename = qdict_get_try_str(qdict, \"snapshot-file\");\n    const char *format = qdict_get_try_str(qdict, \"format\");\n    bool reuse = qdict_get_try_bool(qdict, \"reuse\", false);\n    enum NewImageMode mode;\n    Error *err = NULL;\n\n    if (!filename) {\n        /* In the future, if 'snapshot-file' is not specified, the snapshot\n           will be taken internally. Today it's actually required. */\n        error_setg(&err, QERR_MISSING_PARAMETER, \"snapshot-file\");\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    mode = reuse ? NEW_IMAGE_MODE_EXISTING : NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n    qmp_blockdev_snapshot_sync(true, device, false, NULL,\n                               filename, false, NULL,\n                               !!format, format,\n                               true, mode, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_snapshot_blkdev_internal(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *name = qdict_get_str(qdict, \"name\");\n    Error *err = NULL;\n\n    qmp_blockdev_snapshot_internal_sync(device, name, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_snapshot_delete_blkdev_internal(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *name = qdict_get_str(qdict, \"name\");\n    const char *id = qdict_get_try_str(qdict, \"id\");\n    Error *err = NULL;\n\n    qmp_blockdev_snapshot_delete_internal_sync(device, !!id, id,\n                                               true, name, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_migrate_cancel(Monitor *mon, const QDict *qdict)\n{\n    qmp_migrate_cancel(NULL);\n}\n\nvoid hmp_migrate_incoming(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    const char *uri = qdict_get_str(qdict, \"uri\");\n\n    qmp_migrate_incoming(uri, &err);\n\n    hmp_handle_error(mon, &err);\n}\n\n/* Kept for backwards compatibility */\nvoid hmp_migrate_set_downtime(Monitor *mon, const QDict *qdict)\n{\n    double value = qdict_get_double(qdict, \"value\");\n    qmp_migrate_set_downtime(value, NULL);\n}\n\nvoid hmp_migrate_set_cache_size(Monitor *mon, const QDict *qdict)\n{\n    int64_t value = qdict_get_int(qdict, \"value\");\n    Error *err = NULL;\n\n    qmp_migrate_set_cache_size(value, &err);\n    if (err) {\n        error_report_err(err);\n        return;\n    }\n}\n\n/* Kept for backwards compatibility */\nvoid hmp_migrate_set_speed(Monitor *mon, const QDict *qdict)\n{\n    int64_t value = qdict_get_int(qdict, \"value\");\n    qmp_migrate_set_speed(value, NULL);\n}\n\nvoid hmp_migrate_set_capability(Monitor *mon, const QDict *qdict)\n{\n    const char *cap = qdict_get_str(qdict, \"capability\");\n    bool state = qdict_get_bool(qdict, \"state\");\n    Error *err = NULL;\n    MigrationCapabilityStatusList *caps = g_malloc0(sizeof(*caps));\n    int i;\n\n    for (i = 0; i < MIGRATION_CAPABILITY__MAX; i++) {\n        if (strcmp(cap, MigrationCapability_lookup[i]) == 0) {\n            caps->value = g_malloc0(sizeof(*caps->value));\n            caps->value->capability = i;\n            caps->value->state = state;\n            caps->next = NULL;\n            qmp_migrate_set_capabilities(caps, &err);\n            break;\n        }\n    }\n\n    if (i == MIGRATION_CAPABILITY__MAX) {\n        error_setg(&err, QERR_INVALID_PARAMETER, cap);\n    }\n\n    qapi_free_MigrationCapabilityStatusList(caps);\n\n    if (err) {\n        error_report_err(err);\n    }\n}\n\nvoid hmp_migrate_set_parameter(Monitor *mon, const QDict *qdict)\n{\n    const char *param = qdict_get_str(qdict, \"parameter\");\n    const char *valuestr = qdict_get_str(qdict, \"value\");\n    uint64_t valuebw = 0;\n    long valueint = 0;\n    Error *err = NULL;\n    bool use_int_value = false;\n    int i, ret;\n\n    for (i = 0; i < MIGRATION_PARAMETER__MAX; i++) {\n        if (strcmp(param, MigrationParameter_lookup[i]) == 0) {\n            MigrationParameters p = { 0 };\n            switch (i) {\n            case MIGRATION_PARAMETER_COMPRESS_LEVEL:\n                p.has_compress_level = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_COMPRESS_THREADS:\n                p.has_compress_threads = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_DECOMPRESS_THREADS:\n                p.has_decompress_threads = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_CPU_THROTTLE_INITIAL:\n                p.has_cpu_throttle_initial = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_CPU_THROTTLE_INCREMENT:\n                p.has_cpu_throttle_increment = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_TLS_CREDS:\n                p.has_tls_creds = true;\n                p.tls_creds = (char *) valuestr;\n                break;\n            case MIGRATION_PARAMETER_TLS_HOSTNAME:\n                p.has_tls_hostname = true;\n                p.tls_hostname = (char *) valuestr;\n                break;\n            case MIGRATION_PARAMETER_MAX_BANDWIDTH:\n                p.has_max_bandwidth = true;\n                ret = qemu_strtosz_MiB(valuestr, NULL, &valuebw);\n                if (ret < 0 || valuebw > INT64_MAX\n                    || (size_t)valuebw != valuebw) {\n                    error_setg(&err, \"Invalid size %s\", valuestr);\n                    goto cleanup;\n                }\n                p.max_bandwidth = valuebw;\n                break;\n            case MIGRATION_PARAMETER_DOWNTIME_LIMIT:\n                p.has_downtime_limit = true;\n                use_int_value = true;\n                break;\n            case MIGRATION_PARAMETER_X_CHECKPOINT_DELAY:\n                p.has_x_checkpoint_delay = true;\n                use_int_value = true;\n                break;\n            }\n\n            if (use_int_value) {\n                if (qemu_strtol(valuestr, NULL, 10, &valueint) < 0) {\n                    error_setg(&err, \"Unable to parse '%s' as an int\",\n                               valuestr);\n                    goto cleanup;\n                }\n                /* Set all integers; only one has_FOO will be set, and\n                 * the code ignores the remaining values */\n                p.compress_level = valueint;\n                p.compress_threads = valueint;\n                p.decompress_threads = valueint;\n                p.cpu_throttle_initial = valueint;\n                p.cpu_throttle_increment = valueint;\n                p.downtime_limit = valueint;\n                p.x_checkpoint_delay = valueint;\n            }\n\n            qmp_migrate_set_parameters(&p, &err);\n            break;\n        }\n    }\n\n    if (i == MIGRATION_PARAMETER__MAX) {\n        error_setg(&err, QERR_INVALID_PARAMETER, param);\n    }\n\n cleanup:\n    if (err) {\n        error_report_err(err);\n    }\n}\n\nvoid hmp_client_migrate_info(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    const char *protocol = qdict_get_str(qdict, \"protocol\");\n    const char *hostname = qdict_get_str(qdict, \"hostname\");\n    bool has_port        = qdict_haskey(qdict, \"port\");\n    int port             = qdict_get_try_int(qdict, \"port\", -1);\n    bool has_tls_port    = qdict_haskey(qdict, \"tls-port\");\n    int tls_port         = qdict_get_try_int(qdict, \"tls-port\", -1);\n    const char *cert_subject = qdict_get_try_str(qdict, \"cert-subject\");\n\n    qmp_client_migrate_info(protocol, hostname,\n                            has_port, port, has_tls_port, tls_port,\n                            !!cert_subject, cert_subject, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_migrate_start_postcopy(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    qmp_migrate_start_postcopy(&err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_x_colo_lost_heartbeat(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n\n    qmp_x_colo_lost_heartbeat(&err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_set_password(Monitor *mon, const QDict *qdict)\n{\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n    const char *password  = qdict_get_str(qdict, \"password\");\n    const char *connected = qdict_get_try_str(qdict, \"connected\");\n    Error *err = NULL;\n\n    qmp_set_password(protocol, password, !!connected, connected, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_expire_password(Monitor *mon, const QDict *qdict)\n{\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n    const char *whenstr = qdict_get_str(qdict, \"time\");\n    Error *err = NULL;\n\n    qmp_expire_password(protocol, whenstr, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_eject(Monitor *mon, const QDict *qdict)\n{\n    bool force = qdict_get_try_bool(qdict, \"force\", false);\n    const char *device = qdict_get_str(qdict, \"device\");\n    Error *err = NULL;\n\n    qmp_eject(true, device, false, NULL, true, force, &err);\n    hmp_handle_error(mon, &err);\n}\n\nstatic void hmp_change_read_arg(void *opaque, const char *password,\n                                void *readline_opaque)\n{\n    qmp_change_vnc_password(password, NULL);\n    monitor_read_command(opaque, 1);\n}\n\nvoid hmp_change(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *target = qdict_get_str(qdict, \"target\");\n    const char *arg = qdict_get_try_str(qdict, \"arg\");\n    const char *read_only = qdict_get_try_str(qdict, \"read-only-mode\");\n    BlockdevChangeReadOnlyMode read_only_mode = 0;\n    Error *err = NULL;\n\n    if (strcmp(device, \"vnc\") == 0) {\n        if (read_only) {\n            monitor_printf(mon,\n                           \"Parameter 'read-only-mode' is invalid for VNC\\n\");\n            return;\n        }\n        if (strcmp(target, \"passwd\") == 0 ||\n            strcmp(target, \"password\") == 0) {\n            if (!arg) {\n                monitor_read_password(mon, hmp_change_read_arg, NULL);\n                return;\n            }\n        }\n        qmp_change(\"vnc\", target, !!arg, arg, &err);\n    } else {\n        if (read_only) {\n            read_only_mode =\n                qapi_enum_parse(BlockdevChangeReadOnlyMode_lookup,\n                                read_only, BLOCKDEV_CHANGE_READ_ONLY_MODE__MAX,\n                                BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN, &err);\n            if (err) {\n                hmp_handle_error(mon, &err);\n                return;\n            }\n        }\n\n        qmp_blockdev_change_medium(true, device, false, NULL, target,\n                                   !!arg, arg, !!read_only, read_only_mode,\n                                   &err);\n        if (err &&\n            error_get_class(err) == ERROR_CLASS_DEVICE_ENCRYPTED) {\n            error_free(err);\n            monitor_read_block_device_key(mon, device, NULL, NULL);\n            return;\n        }\n    }\n\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    BlockIOThrottle throttle = {\n        .has_device = true,\n        .device = (char *) qdict_get_str(qdict, \"device\"),\n        .bps = qdict_get_int(qdict, \"bps\"),\n        .bps_rd = qdict_get_int(qdict, \"bps_rd\"),\n        .bps_wr = qdict_get_int(qdict, \"bps_wr\"),\n        .iops = qdict_get_int(qdict, \"iops\"),\n        .iops_rd = qdict_get_int(qdict, \"iops_rd\"),\n        .iops_wr = qdict_get_int(qdict, \"iops_wr\"),\n    };\n\n    qmp_block_set_io_throttle(&throttle, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_block_stream(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n    const char *base = qdict_get_try_str(qdict, \"base\");\n    int64_t speed = qdict_get_try_int(qdict, \"speed\", 0);\n\n    qmp_block_stream(true, device, device, base != NULL, base, false, NULL,\n                     false, NULL, qdict_haskey(qdict, \"speed\"), speed,\n                     true, BLOCKDEV_ON_ERROR_REPORT, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\nvoid hmp_block_job_set_speed(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n    int64_t value = qdict_get_int(qdict, \"speed\");\n\n    qmp_block_job_set_speed(device, value, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\nvoid hmp_block_job_cancel(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n    bool force = qdict_get_try_bool(qdict, \"force\", false);\n\n    qmp_block_job_cancel(device, true, force, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\nvoid hmp_block_job_pause(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    qmp_block_job_pause(device, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\nvoid hmp_block_job_resume(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    qmp_block_job_resume(device, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\nvoid hmp_block_job_complete(Monitor *mon, const QDict *qdict)\n{\n    Error *error = NULL;\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    qmp_block_job_complete(device, &error);\n\n    hmp_handle_error(mon, &error);\n}\n\ntypedef struct HMPMigrationStatus\n{\n    QEMUTimer *timer;\n    Monitor *mon;\n    bool is_block_migration;\n} HMPMigrationStatus;\n\nstatic void hmp_migrate_status_cb(void *opaque)\n{\n    HMPMigrationStatus *status = opaque;\n    MigrationInfo *info;\n\n    info = qmp_query_migrate(NULL);\n    if (!info->has_status || info->status == MIGRATION_STATUS_ACTIVE ||\n        info->status == MIGRATION_STATUS_SETUP) {\n        if (info->has_disk) {\n            int progress;\n\n            if (info->disk->remaining) {\n                progress = info->disk->transferred * 100 / info->disk->total;\n            } else {\n                progress = 100;\n            }\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n            monitor_flush(status->mon);\n        }\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n    } else {\n        if (status->is_block_migration) {\n            monitor_printf(status->mon, \"\\n\");\n        }\n        if (info->has_error_desc) {\n            error_report(\"%s\", info->error_desc);\n        }\n        monitor_resume(status->mon);\n        timer_del(status->timer);\n        g_free(status);\n    }\n\n    qapi_free_MigrationInfo(info);\n}\n\nvoid hmp_migrate(Monitor *mon, const QDict *qdict)\n{\n    bool detach = qdict_get_try_bool(qdict, \"detach\", false);\n    bool blk = qdict_get_try_bool(qdict, \"blk\", false);\n    bool inc = qdict_get_try_bool(qdict, \"inc\", false);\n    const char *uri = qdict_get_str(qdict, \"uri\");\n    Error *err = NULL;\n\n    qmp_migrate(uri, !!blk, blk, !!inc, inc, false, false, &err);\n    if (err) {\n        error_report_err(err);\n        return;\n    }\n\n    if (!detach) {\n        HMPMigrationStatus *status;\n\n        if (monitor_suspend(mon) < 0) {\n            monitor_printf(mon, \"terminal does not allow synchronous \"\n                           \"migration, continuing detached\\n\");\n            return;\n        }\n\n        status = g_malloc0(sizeof(*status));\n        status->mon = mon;\n        status->is_block_migration = blk || inc;\n        status->timer = timer_new_ms(QEMU_CLOCK_REALTIME, hmp_migrate_status_cb,\n                                          status);\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));\n    }\n}\n\nvoid hmp_device_add(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n\n    qmp_device_add((QDict *)qdict, NULL, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_device_del(Monitor *mon, const QDict *qdict)\n{\n    const char *id = qdict_get_str(qdict, \"id\");\n    Error *err = NULL;\n\n    qmp_device_del(id, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_dump_guest_memory(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    bool paging = qdict_get_try_bool(qdict, \"paging\", false);\n    bool zlib = qdict_get_try_bool(qdict, \"zlib\", false);\n    bool lzo = qdict_get_try_bool(qdict, \"lzo\", false);\n    bool snappy = qdict_get_try_bool(qdict, \"snappy\", false);\n    const char *file = qdict_get_str(qdict, \"filename\");\n    bool has_begin = qdict_haskey(qdict, \"begin\");\n    bool has_length = qdict_haskey(qdict, \"length\");\n    bool has_detach = qdict_haskey(qdict, \"detach\");\n    int64_t begin = 0;\n    int64_t length = 0;\n    bool detach = false;\n    enum DumpGuestMemoryFormat dump_format = DUMP_GUEST_MEMORY_FORMAT_ELF;\n    char *prot;\n\n    if (zlib + lzo + snappy > 1) {\n        error_setg(&err, \"only one of '-z|-l|-s' can be set\");\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    if (zlib) {\n        dump_format = DUMP_GUEST_MEMORY_FORMAT_KDUMP_ZLIB;\n    }\n\n    if (lzo) {\n        dump_format = DUMP_GUEST_MEMORY_FORMAT_KDUMP_LZO;\n    }\n\n    if (snappy) {\n        dump_format = DUMP_GUEST_MEMORY_FORMAT_KDUMP_SNAPPY;\n    }\n\n    if (has_begin) {\n        begin = qdict_get_int(qdict, \"begin\");\n    }\n    if (has_length) {\n        length = qdict_get_int(qdict, \"length\");\n    }\n    if (has_detach) {\n        detach = qdict_get_bool(qdict, \"detach\");\n    }\n\n    prot = g_strconcat(\"file:\", file, NULL);\n\n    qmp_dump_guest_memory(paging, prot, true, detach, has_begin, begin,\n                          has_length, length, true, dump_format, &err);\n    hmp_handle_error(mon, &err);\n    g_free(prot);\n}\n\nvoid hmp_netdev_add(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    QemuOpts *opts;\n\n    opts = qemu_opts_from_qdict(qemu_find_opts(\"netdev\"), qdict, &err);\n    if (err) {\n        goto out;\n    }\n\n    netdev_add(opts, &err);\n    if (err) {\n        qemu_opts_del(opts);\n    }\n\nout:\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_netdev_del(Monitor *mon, const QDict *qdict)\n{\n    const char *id = qdict_get_str(qdict, \"id\");\n    Error *err = NULL;\n\n    qmp_netdev_del(id, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_object_add(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    QemuOpts *opts;\n    Object *obj = NULL;\n\n    opts = qemu_opts_from_qdict(qemu_find_opts(\"object\"), qdict, &err);\n    if (err) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    obj = user_creatable_add_opts(opts, &err);\n    qemu_opts_del(opts);\n\n    if (err) {\n        hmp_handle_error(mon, &err);\n    }\n    if (obj) {\n        object_unref(obj);\n    }\n}\n\nvoid hmp_getfd(Monitor *mon, const QDict *qdict)\n{\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n    Error *err = NULL;\n\n    qmp_getfd(fdname, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_closefd(Monitor *mon, const QDict *qdict)\n{\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n    Error *err = NULL;\n\n    qmp_closefd(fdname, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_sendkey(Monitor *mon, const QDict *qdict)\n{\n    const char *keys = qdict_get_str(qdict, \"keys\");\n    KeyValueList *keylist, *head = NULL, *tmp = NULL;\n    int has_hold_time = qdict_haskey(qdict, \"hold-time\");\n    int hold_time = qdict_get_try_int(qdict, \"hold-time\", -1);\n    Error *err = NULL;\n    char *separator;\n    int keyname_len;\n\n    while (1) {\n        separator = strchr(keys, '-');\n        keyname_len = separator ? separator - keys : strlen(keys);\n\n        /* Be compatible with old interface, convert user inputted \"<\" */\n        if (keys[0] == '<' && keyname_len == 1) {\n            keys = \"less\";\n            keyname_len = 4;\n        }\n\n        keylist = g_malloc0(sizeof(*keylist));\n        keylist->value = g_malloc0(sizeof(*keylist->value));\n\n        if (!head) {\n            head = keylist;\n        }\n        if (tmp) {\n            tmp->next = keylist;\n        }\n        tmp = keylist;\n\n        if (strstart(keys, \"0x\", NULL)) {\n            char *endp;\n            int value = strtoul(keys, &endp, 0);\n            assert(endp <= keys + keyname_len);\n            if (endp != keys + keyname_len) {\n                goto err_out;\n            }\n            keylist->value->type = KEY_VALUE_KIND_NUMBER;\n            keylist->value->u.number.data = value;\n        } else {\n            int idx = index_from_key(keys, keyname_len);\n            if (idx == Q_KEY_CODE__MAX) {\n                goto err_out;\n            }\n            keylist->value->type = KEY_VALUE_KIND_QCODE;\n            keylist->value->u.qcode.data = idx;\n        }\n\n        if (!separator) {\n            break;\n        }\n        keys = separator + 1;\n    }\n\n    qmp_send_key(head, has_hold_time, hold_time, &err);\n    hmp_handle_error(mon, &err);\n\nout:\n    qapi_free_KeyValueList(head);\n    return;\n\nerr_out:\n    monitor_printf(mon, \"invalid parameter: %.*s\\n\", keyname_len, keys);\n    goto out;\n}\n\nvoid hmp_screendump(Monitor *mon, const QDict *qdict)\n{\n    const char *filename = qdict_get_str(qdict, \"filename\");\n    Error *err = NULL;\n\n    qmp_screendump(filename, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_nbd_server_start(Monitor *mon, const QDict *qdict)\n{\n    const char *uri = qdict_get_str(qdict, \"uri\");\n    bool writable = qdict_get_try_bool(qdict, \"writable\", false);\n    bool all = qdict_get_try_bool(qdict, \"all\", false);\n    Error *local_err = NULL;\n    BlockInfoList *block_list, *info;\n    SocketAddress *addr;\n\n    if (writable && !all) {\n        error_setg(&local_err, \"-w only valid together with -a\");\n        goto exit;\n    }\n\n    /* First check if the address is valid and start the server.  */\n    addr = socket_parse(uri, &local_err);\n    if (local_err != NULL) {\n        goto exit;\n    }\n\n    qmp_nbd_server_start(addr, false, NULL, &local_err);\n    qapi_free_SocketAddress(addr);\n    if (local_err != NULL) {\n        goto exit;\n    }\n\n    if (!all) {\n        return;\n    }\n\n    /* Then try adding all block devices.  If one fails, close all and\n     * exit.\n     */\n    block_list = qmp_query_block(NULL);\n\n    for (info = block_list; info; info = info->next) {\n        if (!info->value->has_inserted) {\n            continue;\n        }\n\n        qmp_nbd_server_add(info->value->device, true, writable, &local_err);\n\n        if (local_err != NULL) {\n            qmp_nbd_server_stop(NULL);\n            break;\n        }\n    }\n\n    qapi_free_BlockInfoList(block_list);\n\nexit:\n    hmp_handle_error(mon, &local_err);\n}\n\nvoid hmp_nbd_server_add(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_str(qdict, \"device\");\n    bool writable = qdict_get_try_bool(qdict, \"writable\", false);\n    Error *local_err = NULL;\n\n    qmp_nbd_server_add(device, true, writable, &local_err);\n\n    if (local_err != NULL) {\n        hmp_handle_error(mon, &local_err);\n    }\n}\n\nvoid hmp_nbd_server_stop(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n\n    qmp_nbd_server_stop(&err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_cpu_add(Monitor *mon, const QDict *qdict)\n{\n    int cpuid;\n    Error *err = NULL;\n\n    cpuid = qdict_get_int(qdict, \"id\");\n    qmp_cpu_add(cpuid, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_chardev_add(Monitor *mon, const QDict *qdict)\n{\n    const char *args = qdict_get_str(qdict, \"args\");\n    Error *err = NULL;\n    QemuOpts *opts;\n\n    opts = qemu_opts_parse_noisily(qemu_find_opts(\"chardev\"), args, true);\n    if (opts == NULL) {\n        error_setg(&err, \"Parsing chardev args failed\");\n    } else {\n        qemu_chr_new_from_opts(opts, &err);\n        qemu_opts_del(opts);\n    }\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_chardev_remove(Monitor *mon, const QDict *qdict)\n{\n    Error *local_err = NULL;\n\n    qmp_chardev_remove(qdict_get_str(qdict, \"id\"), &local_err);\n    hmp_handle_error(mon, &local_err);\n}\n\nvoid hmp_qemu_io(Monitor *mon, const QDict *qdict)\n{\n    BlockBackend *blk;\n    BlockBackend *local_blk = NULL;\n    AioContext *aio_context;\n    const char* device = qdict_get_str(qdict, \"device\");\n    const char* command = qdict_get_str(qdict, \"command\");\n    Error *err = NULL;\n    int ret;\n\n    blk = blk_by_name(device);\n    if (!blk) {\n        BlockDriverState *bs = bdrv_lookup_bs(NULL, device, &err);\n        if (bs) {\n            blk = local_blk = blk_new(0, BLK_PERM_ALL);\n            ret = blk_insert_bs(blk, bs, &err);\n            if (ret < 0) {\n                goto fail;\n            }\n        } else {\n            goto fail;\n        }\n    }\n\n    aio_context = blk_get_aio_context(blk);\n    aio_context_acquire(aio_context);\n\n    /*\n     * Notably absent: Proper permission management. This is sad, but it seems\n     * almost impossible to achieve without changing the semantics and thereby\n     * limiting the use cases of the qemu-io HMP command.\n     *\n     * In an ideal world we would unconditionally create a new BlockBackend for\n     * qemuio_command(), but we have commands like 'reopen' and want them to\n     * take effect on the exact BlockBackend whose name the user passed instead\n     * of just on a temporary copy of it.\n     *\n     * Another problem is that deleting the temporary BlockBackend involves\n     * draining all requests on it first, but some qemu-iotests cases want to\n     * issue multiple aio_read/write requests and expect them to complete in\n     * the background while the monitor has already returned.\n     *\n     * This is also what prevents us from saving the original permissions and\n     * restoring them later: We can't revoke permissions until all requests\n     * have completed, and we don't know when that is nor can we really let\n     * anything else run before we have revoken them to avoid race conditions.\n     *\n     * What happens now is that command() in qemu-io-cmds.c can extend the\n     * permissions if necessary for the qemu-io command. And they simply stay\n     * extended, possibly resulting in a read-only guest device keeping write\n     * permissions. Ugly, but it appears to be the lesser evil.\n     */\n    qemuio_command(blk, command);\n\n    aio_context_release(aio_context);\n\nfail:\n    blk_unref(local_blk);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_object_del(Monitor *mon, const QDict *qdict)\n{\n    const char *id = qdict_get_str(qdict, \"id\");\n    Error *err = NULL;\n\n    user_creatable_del(id, &err);\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_info_memdev(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    MemdevList *memdev_list = qmp_query_memdev(&err);\n    MemdevList *m = memdev_list;\n    Visitor *v;\n    char *str;\n\n    while (m) {\n        v = string_output_visitor_new(false, &str);\n        visit_type_uint16List(v, NULL, &m->value->host_nodes, NULL);\n        monitor_printf(mon, \"memory backend: %s\\n\", m->value->id);\n        monitor_printf(mon, \"  size:  %\" PRId64 \"\\n\", m->value->size);\n        monitor_printf(mon, \"  merge: %s\\n\",\n                       m->value->merge ? \"true\" : \"false\");\n        monitor_printf(mon, \"  dump: %s\\n\",\n                       m->value->dump ? \"true\" : \"false\");\n        monitor_printf(mon, \"  prealloc: %s\\n\",\n                       m->value->prealloc ? \"true\" : \"false\");\n        monitor_printf(mon, \"  policy: %s\\n\",\n                       HostMemPolicy_lookup[m->value->policy]);\n        visit_complete(v, &str);\n        monitor_printf(mon, \"  host nodes: %s\\n\", str);\n\n        g_free(str);\n        visit_free(v);\n        m = m->next;\n    }\n\n    monitor_printf(mon, \"\\n\");\n\n    qapi_free_MemdevList(memdev_list);\n}\n\nvoid hmp_info_memory_devices(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    MemoryDeviceInfoList *info_list = qmp_query_memory_devices(&err);\n    MemoryDeviceInfoList *info;\n    MemoryDeviceInfo *value;\n    PCDIMMDeviceInfo *di;\n\n    for (info = info_list; info; info = info->next) {\n        value = info->value;\n\n        if (value) {\n            switch (value->type) {\n            case MEMORY_DEVICE_INFO_KIND_DIMM:\n                di = value->u.dimm.data;\n\n                monitor_printf(mon, \"Memory device [%s]: \\\"%s\\\"\\n\",\n                               MemoryDeviceInfoKind_lookup[value->type],\n                               di->id ? di->id : \"\");\n                monitor_printf(mon, \"  addr: 0x%\" PRIx64 \"\\n\", di->addr);\n                monitor_printf(mon, \"  slot: %\" PRId64 \"\\n\", di->slot);\n                monitor_printf(mon, \"  node: %\" PRId64 \"\\n\", di->node);\n                monitor_printf(mon, \"  size: %\" PRIu64 \"\\n\", di->size);\n                monitor_printf(mon, \"  memdev: %s\\n\", di->memdev);\n                monitor_printf(mon, \"  hotplugged: %s\\n\",\n                               di->hotplugged ? \"true\" : \"false\");\n                monitor_printf(mon, \"  hotpluggable: %s\\n\",\n                               di->hotpluggable ? \"true\" : \"false\");\n                break;\n            default:\n                break;\n            }\n        }\n    }\n\n    qapi_free_MemoryDeviceInfoList(info_list);\n}\n\nvoid hmp_info_iothreads(Monitor *mon, const QDict *qdict)\n{\n    IOThreadInfoList *info_list = qmp_query_iothreads(NULL);\n    IOThreadInfoList *info;\n    IOThreadInfo *value;\n\n    for (info = info_list; info; info = info->next) {\n        value = info->value;\n        monitor_printf(mon, \"%s:\\n\", value->id);\n        monitor_printf(mon, \"  thread_id=%\" PRId64 \"\\n\", value->thread_id);\n        monitor_printf(mon, \"  poll-max-ns=%\" PRId64 \"\\n\", value->poll_max_ns);\n        monitor_printf(mon, \"  poll-grow=%\" PRId64 \"\\n\", value->poll_grow);\n        monitor_printf(mon, \"  poll-shrink=%\" PRId64 \"\\n\", value->poll_shrink);\n    }\n\n    qapi_free_IOThreadInfoList(info_list);\n}\n\nvoid hmp_qom_list(Monitor *mon, const QDict *qdict)\n{\n    const char *path = qdict_get_try_str(qdict, \"path\");\n    ObjectPropertyInfoList *list;\n    Error *err = NULL;\n\n    if (path == NULL) {\n        monitor_printf(mon, \"/\\n\");\n        return;\n    }\n\n    list = qmp_qom_list(path, &err);\n    if (err == NULL) {\n        ObjectPropertyInfoList *start = list;\n        while (list != NULL) {\n            ObjectPropertyInfo *value = list->value;\n\n            monitor_printf(mon, \"%s (%s)\\n\",\n                           value->name, value->type);\n            list = list->next;\n        }\n        qapi_free_ObjectPropertyInfoList(start);\n    }\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_qom_set(Monitor *mon, const QDict *qdict)\n{\n    const char *path = qdict_get_str(qdict, \"path\");\n    const char *property = qdict_get_str(qdict, \"property\");\n    const char *value = qdict_get_str(qdict, \"value\");\n    Error *err = NULL;\n    bool ambiguous = false;\n    Object *obj;\n\n    obj = object_resolve_path(path, &ambiguous);\n    if (obj == NULL) {\n        error_set(&err, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", path);\n    } else {\n        if (ambiguous) {\n            monitor_printf(mon, \"Warning: Path '%s' is ambiguous\\n\", path);\n        }\n        object_property_parse(obj, value, property, &err);\n    }\n    hmp_handle_error(mon, &err);\n}\n\nvoid hmp_rocker(Monitor *mon, const QDict *qdict)\n{\n    const char *name = qdict_get_str(qdict, \"name\");\n    RockerSwitch *rocker;\n    Error *err = NULL;\n\n    rocker = qmp_query_rocker(name, &err);\n    if (err != NULL) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    monitor_printf(mon, \"name: %s\\n\", rocker->name);\n    monitor_printf(mon, \"id: 0x%\" PRIx64 \"\\n\", rocker->id);\n    monitor_printf(mon, \"ports: %d\\n\", rocker->ports);\n\n    qapi_free_RockerSwitch(rocker);\n}\n\nvoid hmp_rocker_ports(Monitor *mon, const QDict *qdict)\n{\n    RockerPortList *list, *port;\n    const char *name = qdict_get_str(qdict, \"name\");\n    Error *err = NULL;\n\n    list = qmp_query_rocker_ports(name, &err);\n    if (err != NULL) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    monitor_printf(mon, \"            ena/    speed/ auto\\n\");\n    monitor_printf(mon, \"      port  link    duplex neg?\\n\");\n\n    for (port = list; port; port = port->next) {\n        monitor_printf(mon, \"%10s  %-4s   %-3s  %2s  %-3s\\n\",\n                       port->value->name,\n                       port->value->enabled ? port->value->link_up ?\n                       \"up\" : \"down\" : \"!ena\",\n                       port->value->speed == 10000 ? \"10G\" : \"??\",\n                       port->value->duplex ? \"FD\" : \"HD\",\n                       port->value->autoneg ? \"Yes\" : \"No\");\n    }\n\n    qapi_free_RockerPortList(list);\n}\n\nvoid hmp_rocker_of_dpa_flows(Monitor *mon, const QDict *qdict)\n{\n    RockerOfDpaFlowList *list, *info;\n    const char *name = qdict_get_str(qdict, \"name\");\n    uint32_t tbl_id = qdict_get_try_int(qdict, \"tbl_id\", -1);\n    Error *err = NULL;\n\n    list = qmp_query_rocker_of_dpa_flows(name, tbl_id != -1, tbl_id, &err);\n    if (err != NULL) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    monitor_printf(mon, \"prio tbl hits key(mask) --> actions\\n\");\n\n    for (info = list; info; info = info->next) {\n        RockerOfDpaFlow *flow = info->value;\n        RockerOfDpaFlowKey *key = flow->key;\n        RockerOfDpaFlowMask *mask = flow->mask;\n        RockerOfDpaFlowAction *action = flow->action;\n\n        if (flow->hits) {\n            monitor_printf(mon, \"%-4d %-3d %-4\" PRIu64,\n                           key->priority, key->tbl_id, flow->hits);\n        } else {\n            monitor_printf(mon, \"%-4d %-3d     \",\n                           key->priority, key->tbl_id);\n        }\n\n        if (key->has_in_pport) {\n            monitor_printf(mon, \" pport %d\", key->in_pport);\n            if (mask->has_in_pport) {\n                monitor_printf(mon, \"(0x%x)\", mask->in_pport);\n            }\n        }\n\n        if (key->has_vlan_id) {\n            monitor_printf(mon, \" vlan %d\",\n                           key->vlan_id & VLAN_VID_MASK);\n            if (mask->has_vlan_id) {\n                monitor_printf(mon, \"(0x%x)\", mask->vlan_id);\n            }\n        }\n\n        if (key->has_tunnel_id) {\n            monitor_printf(mon, \" tunnel %d\", key->tunnel_id);\n            if (mask->has_tunnel_id) {\n                monitor_printf(mon, \"(0x%x)\", mask->tunnel_id);\n            }\n        }\n\n        if (key->has_eth_type) {\n            switch (key->eth_type) {\n            case 0x0806:\n                monitor_printf(mon, \" ARP\");\n                break;\n            case 0x0800:\n                monitor_printf(mon, \" IP\");\n                break;\n            case 0x86dd:\n                monitor_printf(mon, \" IPv6\");\n                break;\n            case 0x8809:\n                monitor_printf(mon, \" LACP\");\n                break;\n            case 0x88cc:\n                monitor_printf(mon, \" LLDP\");\n                break;\n            default:\n                monitor_printf(mon, \" eth type 0x%04x\", key->eth_type);\n                break;\n            }\n        }\n\n        if (key->has_eth_src) {\n            if ((strcmp(key->eth_src, \"01:00:00:00:00:00\") == 0) &&\n                (mask->has_eth_src) &&\n                (strcmp(mask->eth_src, \"01:00:00:00:00:00\") == 0)) {\n                monitor_printf(mon, \" src <any mcast/bcast>\");\n            } else if ((strcmp(key->eth_src, \"00:00:00:00:00:00\") == 0) &&\n                (mask->has_eth_src) &&\n                (strcmp(mask->eth_src, \"01:00:00:00:00:00\") == 0)) {\n                monitor_printf(mon, \" src <any ucast>\");\n            } else {\n                monitor_printf(mon, \" src %s\", key->eth_src);\n                if (mask->has_eth_src) {\n                    monitor_printf(mon, \"(%s)\", mask->eth_src);\n                }\n            }\n        }\n\n        if (key->has_eth_dst) {\n            if ((strcmp(key->eth_dst, \"01:00:00:00:00:00\") == 0) &&\n                (mask->has_eth_dst) &&\n                (strcmp(mask->eth_dst, \"01:00:00:00:00:00\") == 0)) {\n                monitor_printf(mon, \" dst <any mcast/bcast>\");\n            } else if ((strcmp(key->eth_dst, \"00:00:00:00:00:00\") == 0) &&\n                (mask->has_eth_dst) &&\n                (strcmp(mask->eth_dst, \"01:00:00:00:00:00\") == 0)) {\n                monitor_printf(mon, \" dst <any ucast>\");\n            } else {\n                monitor_printf(mon, \" dst %s\", key->eth_dst);\n                if (mask->has_eth_dst) {\n                    monitor_printf(mon, \"(%s)\", mask->eth_dst);\n                }\n            }\n        }\n\n        if (key->has_ip_proto) {\n            monitor_printf(mon, \" proto %d\", key->ip_proto);\n            if (mask->has_ip_proto) {\n                monitor_printf(mon, \"(0x%x)\", mask->ip_proto);\n            }\n        }\n\n        if (key->has_ip_tos) {\n            monitor_printf(mon, \" TOS %d\", key->ip_tos);\n            if (mask->has_ip_tos) {\n                monitor_printf(mon, \"(0x%x)\", mask->ip_tos);\n            }\n        }\n\n        if (key->has_ip_dst) {\n            monitor_printf(mon, \" dst %s\", key->ip_dst);\n        }\n\n        if (action->has_goto_tbl || action->has_group_id ||\n            action->has_new_vlan_id) {\n            monitor_printf(mon, \" -->\");\n        }\n\n        if (action->has_new_vlan_id) {\n            monitor_printf(mon, \" apply new vlan %d\",\n                           ntohs(action->new_vlan_id));\n        }\n\n        if (action->has_group_id) {\n            monitor_printf(mon, \" write group 0x%08x\", action->group_id);\n        }\n\n        if (action->has_goto_tbl) {\n            monitor_printf(mon, \" goto tbl %d\", action->goto_tbl);\n        }\n\n        monitor_printf(mon, \"\\n\");\n    }\n\n    qapi_free_RockerOfDpaFlowList(list);\n}\n\nvoid hmp_rocker_of_dpa_groups(Monitor *mon, const QDict *qdict)\n{\n    RockerOfDpaGroupList *list, *g;\n    const char *name = qdict_get_str(qdict, \"name\");\n    uint8_t type = qdict_get_try_int(qdict, \"type\", 9);\n    Error *err = NULL;\n    bool set = false;\n\n    list = qmp_query_rocker_of_dpa_groups(name, type != 9, type, &err);\n    if (err != NULL) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    monitor_printf(mon, \"id (decode) --> buckets\\n\");\n\n    for (g = list; g; g = g->next) {\n        RockerOfDpaGroup *group = g->value;\n\n        monitor_printf(mon, \"0x%08x\", group->id);\n\n        monitor_printf(mon, \" (type %s\", group->type == 0 ? \"L2 interface\" :\n                                         group->type == 1 ? \"L2 rewrite\" :\n                                         group->type == 2 ? \"L3 unicast\" :\n                                         group->type == 3 ? \"L2 multicast\" :\n                                         group->type == 4 ? \"L2 flood\" :\n                                         group->type == 5 ? \"L3 interface\" :\n                                         group->type == 6 ? \"L3 multicast\" :\n                                         group->type == 7 ? \"L3 ECMP\" :\n                                         group->type == 8 ? \"L2 overlay\" :\n                                         \"unknown\");\n\n        if (group->has_vlan_id) {\n            monitor_printf(mon, \" vlan %d\", group->vlan_id);\n        }\n\n        if (group->has_pport) {\n            monitor_printf(mon, \" pport %d\", group->pport);\n        }\n\n        if (group->has_index) {\n            monitor_printf(mon, \" index %d\", group->index);\n        }\n\n        monitor_printf(mon, \") -->\");\n\n        if (group->has_set_vlan_id && group->set_vlan_id) {\n            set = true;\n            monitor_printf(mon, \" set vlan %d\",\n                           group->set_vlan_id & VLAN_VID_MASK);\n        }\n\n        if (group->has_set_eth_src) {\n            if (!set) {\n                set = true;\n                monitor_printf(mon, \" set\");\n            }\n            monitor_printf(mon, \" src %s\", group->set_eth_src);\n        }\n\n        if (group->has_set_eth_dst) {\n            if (!set) {\n                set = true;\n                monitor_printf(mon, \" set\");\n            }\n            monitor_printf(mon, \" dst %s\", group->set_eth_dst);\n        }\n\n        set = false;\n\n        if (group->has_ttl_check && group->ttl_check) {\n            monitor_printf(mon, \" check TTL\");\n        }\n\n        if (group->has_group_id && group->group_id) {\n            monitor_printf(mon, \" group id 0x%08x\", group->group_id);\n        }\n\n        if (group->has_pop_vlan && group->pop_vlan) {\n            monitor_printf(mon, \" pop vlan\");\n        }\n\n        if (group->has_out_pport) {\n            monitor_printf(mon, \" out pport %d\", group->out_pport);\n        }\n\n        if (group->has_group_ids) {\n            struct uint32List *id;\n\n            monitor_printf(mon, \" groups [\");\n            for (id = group->group_ids; id; id = id->next) {\n                monitor_printf(mon, \"0x%08x\", id->value);\n                if (id->next) {\n                    monitor_printf(mon, \",\");\n                }\n            }\n            monitor_printf(mon, \"]\");\n        }\n\n        monitor_printf(mon, \"\\n\");\n    }\n\n    qapi_free_RockerOfDpaGroupList(list);\n}\n\nvoid hmp_info_dump(Monitor *mon, const QDict *qdict)\n{\n    DumpQueryResult *result = qmp_query_dump(NULL);\n\n    assert(result && result->status < DUMP_STATUS__MAX);\n    monitor_printf(mon, \"Status: %s\\n\", DumpStatus_lookup[result->status]);\n\n    if (result->status == DUMP_STATUS_ACTIVE) {\n        float percent = 0;\n        assert(result->total != 0);\n        percent = 100.0 * result->completed / result->total;\n        monitor_printf(mon, \"Finished: %.2f %%\\n\", percent);\n    }\n\n    qapi_free_DumpQueryResult(result);\n}\n\nvoid hmp_hotpluggable_cpus(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    HotpluggableCPUList *l = qmp_query_hotpluggable_cpus(&err);\n    HotpluggableCPUList *saved = l;\n    CpuInstanceProperties *c;\n\n    if (err != NULL) {\n        hmp_handle_error(mon, &err);\n        return;\n    }\n\n    monitor_printf(mon, \"Hotpluggable CPUs:\\n\");\n    while (l) {\n        monitor_printf(mon, \"  type: \\\"%s\\\"\\n\", l->value->type);\n        monitor_printf(mon, \"  vcpus_count: \\\"%\" PRIu64 \"\\\"\\n\",\n                       l->value->vcpus_count);\n        if (l->value->has_qom_path) {\n            monitor_printf(mon, \"  qom_path: \\\"%s\\\"\\n\", l->value->qom_path);\n        }\n\n        c = l->value->props;\n        monitor_printf(mon, \"  CPUInstance Properties:\\n\");\n        if (c->has_node_id) {\n            monitor_printf(mon, \"    node-id: \\\"%\" PRIu64 \"\\\"\\n\", c->node_id);\n        }\n        if (c->has_socket_id) {\n            monitor_printf(mon, \"    socket-id: \\\"%\" PRIu64 \"\\\"\\n\", c->socket_id);\n        }\n        if (c->has_core_id) {\n            monitor_printf(mon, \"    core-id: \\\"%\" PRIu64 \"\\\"\\n\", c->core_id);\n        }\n        if (c->has_thread_id) {\n            monitor_printf(mon, \"    thread-id: \\\"%\" PRIu64 \"\\\"\\n\", c->thread_id);\n        }\n\n        l = l->next;\n    }\n\n    qapi_free_HotpluggableCPUList(saved);\n}\n\nvoid hmp_info_vm_generation_id(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    GuidInfo *info = qmp_query_vm_generation_id(&err);\n    if (info) {\n        monitor_printf(mon, \"%s\\n\", info->guid);\n    }\n    hmp_handle_error(mon, &err);\n    qapi_free_GuidInfo(info);\n}\n"
        },
        {
          "name": "hmp.h",
          "type": "blob",
          "size": 7.9833984375,
          "content": "/*\n * Human Monitor Interface\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n *  Anthony Liguori   <aliguori@us.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#ifndef HMP_H\n#define HMP_H\n\n#include \"qemu-common.h\"\n#include \"qemu/readline.h\"\n#include \"qapi-types.h\"\n#include \"qapi/qmp/qdict.h\"\n\nvoid hmp_info_name(Monitor *mon, const QDict *qdict);\nvoid hmp_info_version(Monitor *mon, const QDict *qdict);\nvoid hmp_info_kvm(Monitor *mon, const QDict *qdict);\nvoid hmp_info_status(Monitor *mon, const QDict *qdict);\nvoid hmp_info_uuid(Monitor *mon, const QDict *qdict);\nvoid hmp_info_chardev(Monitor *mon, const QDict *qdict);\nvoid hmp_info_mice(Monitor *mon, const QDict *qdict);\nvoid hmp_info_migrate(Monitor *mon, const QDict *qdict);\nvoid hmp_info_migrate_capabilities(Monitor *mon, const QDict *qdict);\nvoid hmp_info_migrate_parameters(Monitor *mon, const QDict *qdict);\nvoid hmp_info_migrate_cache_size(Monitor *mon, const QDict *qdict);\nvoid hmp_info_cpus(Monitor *mon, const QDict *qdict);\nvoid hmp_info_block(Monitor *mon, const QDict *qdict);\nvoid hmp_info_blockstats(Monitor *mon, const QDict *qdict);\nvoid hmp_info_vnc(Monitor *mon, const QDict *qdict);\nvoid hmp_info_spice(Monitor *mon, const QDict *qdict);\nvoid hmp_info_balloon(Monitor *mon, const QDict *qdict);\nvoid hmp_info_irq(Monitor *mon, const QDict *qdict);\nvoid hmp_info_pic(Monitor *mon, const QDict *qdict);\nvoid hmp_info_pci(Monitor *mon, const QDict *qdict);\nvoid hmp_info_block_jobs(Monitor *mon, const QDict *qdict);\nvoid hmp_info_tpm(Monitor *mon, const QDict *qdict);\nvoid hmp_info_iothreads(Monitor *mon, const QDict *qdict);\nvoid hmp_quit(Monitor *mon, const QDict *qdict);\nvoid hmp_stop(Monitor *mon, const QDict *qdict);\nvoid hmp_system_reset(Monitor *mon, const QDict *qdict);\nvoid hmp_system_powerdown(Monitor *mon, const QDict *qdict);\nvoid hmp_cpu(Monitor *mon, const QDict *qdict);\nvoid hmp_memsave(Monitor *mon, const QDict *qdict);\nvoid hmp_pmemsave(Monitor *mon, const QDict *qdict);\nvoid hmp_ringbuf_write(Monitor *mon, const QDict *qdict);\nvoid hmp_ringbuf_read(Monitor *mon, const QDict *qdict);\nvoid hmp_cont(Monitor *mon, const QDict *qdict);\nvoid hmp_system_wakeup(Monitor *mon, const QDict *qdict);\nvoid hmp_nmi(Monitor *mon, const QDict *qdict);\nvoid hmp_set_link(Monitor *mon, const QDict *qdict);\nvoid hmp_block_passwd(Monitor *mon, const QDict *qdict);\nvoid hmp_balloon(Monitor *mon, const QDict *qdict);\nvoid hmp_block_resize(Monitor *mon, const QDict *qdict);\nvoid hmp_snapshot_blkdev(Monitor *mon, const QDict *qdict);\nvoid hmp_snapshot_blkdev_internal(Monitor *mon, const QDict *qdict);\nvoid hmp_snapshot_delete_blkdev_internal(Monitor *mon, const QDict *qdict);\nvoid hmp_drive_mirror(Monitor *mon, const QDict *qdict);\nvoid hmp_drive_backup(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_cancel(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_incoming(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_set_downtime(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_set_speed(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_set_capability(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_set_parameter(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_set_cache_size(Monitor *mon, const QDict *qdict);\nvoid hmp_client_migrate_info(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate_start_postcopy(Monitor *mon, const QDict *qdict);\nvoid hmp_x_colo_lost_heartbeat(Monitor *mon, const QDict *qdict);\nvoid hmp_set_password(Monitor *mon, const QDict *qdict);\nvoid hmp_expire_password(Monitor *mon, const QDict *qdict);\nvoid hmp_eject(Monitor *mon, const QDict *qdict);\nvoid hmp_change(Monitor *mon, const QDict *qdict);\nvoid hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict);\nvoid hmp_block_stream(Monitor *mon, const QDict *qdict);\nvoid hmp_block_job_set_speed(Monitor *mon, const QDict *qdict);\nvoid hmp_block_job_cancel(Monitor *mon, const QDict *qdict);\nvoid hmp_block_job_pause(Monitor *mon, const QDict *qdict);\nvoid hmp_block_job_resume(Monitor *mon, const QDict *qdict);\nvoid hmp_block_job_complete(Monitor *mon, const QDict *qdict);\nvoid hmp_migrate(Monitor *mon, const QDict *qdict);\nvoid hmp_device_add(Monitor *mon, const QDict *qdict);\nvoid hmp_device_del(Monitor *mon, const QDict *qdict);\nvoid hmp_dump_guest_memory(Monitor *mon, const QDict *qdict);\nvoid hmp_netdev_add(Monitor *mon, const QDict *qdict);\nvoid hmp_netdev_del(Monitor *mon, const QDict *qdict);\nvoid hmp_getfd(Monitor *mon, const QDict *qdict);\nvoid hmp_closefd(Monitor *mon, const QDict *qdict);\nvoid hmp_sendkey(Monitor *mon, const QDict *qdict);\nvoid hmp_screendump(Monitor *mon, const QDict *qdict);\nvoid hmp_nbd_server_start(Monitor *mon, const QDict *qdict);\nvoid hmp_nbd_server_add(Monitor *mon, const QDict *qdict);\nvoid hmp_nbd_server_stop(Monitor *mon, const QDict *qdict);\nvoid hmp_chardev_add(Monitor *mon, const QDict *qdict);\nvoid hmp_chardev_remove(Monitor *mon, const QDict *qdict);\nvoid hmp_qemu_io(Monitor *mon, const QDict *qdict);\nvoid hmp_cpu_add(Monitor *mon, const QDict *qdict);\nvoid hmp_object_add(Monitor *mon, const QDict *qdict);\nvoid hmp_object_del(Monitor *mon, const QDict *qdict);\nvoid hmp_info_memdev(Monitor *mon, const QDict *qdict);\nvoid hmp_info_memory_devices(Monitor *mon, const QDict *qdict);\nvoid hmp_qom_list(Monitor *mon, const QDict *qdict);\nvoid hmp_qom_set(Monitor *mon, const QDict *qdict);\nvoid object_add_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid object_del_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid device_add_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid device_del_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid sendkey_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid chardev_remove_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid chardev_add_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid set_link_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid netdev_add_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid netdev_del_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid ringbuf_write_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid info_trace_events_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid trace_event_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid watchdog_action_completion(ReadLineState *rs, int nb_args,\n                                const char *str);\nvoid migrate_set_capability_completion(ReadLineState *rs, int nb_args,\n                                       const char *str);\nvoid migrate_set_parameter_completion(ReadLineState *rs, int nb_args,\n                                      const char *str);\nvoid host_net_add_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid host_net_remove_completion(ReadLineState *rs, int nb_args,\n                                const char *str);\nvoid delvm_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid loadvm_completion(ReadLineState *rs, int nb_args, const char *str);\nvoid hmp_rocker(Monitor *mon, const QDict *qdict);\nvoid hmp_rocker_ports(Monitor *mon, const QDict *qdict);\nvoid hmp_rocker_of_dpa_flows(Monitor *mon, const QDict *qdict);\nvoid hmp_rocker_of_dpa_groups(Monitor *mon, const QDict *qdict);\nvoid hmp_info_dump(Monitor *mon, const QDict *qdict);\nvoid hmp_hotpluggable_cpus(Monitor *mon, const QDict *qdict);\nvoid hmp_info_vm_generation_id(Monitor *mon, const QDict *qdict);\n\n// PANDA Record/Replay HMP\nvoid hmp_begin_record(Monitor *mon, const QDict *qdict);\nvoid hmp_begin_record_from(Monitor *mon, const QDict *qdict);\nvoid hmp_begin_replay(Monitor *mon, const QDict *qdict);\nvoid hmp_end_record(Monitor *mon, const QDict *qdict);\nvoid hmp_end_replay(Monitor *mon, const QDict *qdict);\n\n// PANDA Plugins\nvoid hmp_panda_load_plugin(Monitor *mon, const QDict *qdict);\nvoid hmp_panda_unload_plugin(Monitor *mon, const QDict *qdict);\nvoid hmp_panda_list_plugins(Monitor *mon, const QDict *qdict);\nvoid hmp_panda_plugin_cmd(Monitor *mon, const QDict *qdict);\n\n#endif\n"
        },
        {
          "name": "hw",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "io",
          "type": "tree",
          "content": null
        },
        {
          "name": "ioport.c",
          "type": "blob",
          "size": 8.982421875,
          "content": "/*\n * QEMU System Emulator\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/*\n * splitted out ioport related stuffs from vl.c.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"exec/ioport.h\"\n#include \"trace-root.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n\ntypedef struct MemoryRegionPortioList {\n    MemoryRegion mr;\n    void *portio_opaque;\n    MemoryRegionPortio ports[];\n} MemoryRegionPortioList;\n\nstatic uint64_t unassigned_io_read(void *opaque, hwaddr addr, unsigned size)\n{\n    return -1ULL;\n}\n\nstatic void unassigned_io_write(void *opaque, hwaddr addr, uint64_t val,\n                                unsigned size)\n{\n}\n\nconst MemoryRegionOps unassigned_io_ops = {\n    .read = unassigned_io_read,\n    .write = unassigned_io_write,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nvoid cpu_outb(uint32_t addr, uint8_t val)\n{\n    trace_cpu_out(addr, 'b', val);\n    address_space_write(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED,\n                        &val, 1);\n}\n\nvoid cpu_outw(uint32_t addr, uint16_t val)\n{\n    uint8_t buf[2];\n\n    trace_cpu_out(addr, 'w', val);\n    stw_p(buf, val);\n    address_space_write(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED,\n                        buf, 2);\n}\n\nvoid cpu_outl(uint32_t addr, uint32_t val)\n{\n    uint8_t buf[4];\n\n    trace_cpu_out(addr, 'l', val);\n    stl_p(buf, val);\n    address_space_write(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED,\n                        buf, 4);\n}\n\nuint8_t cpu_inb(uint32_t addr)\n{\n    uint8_t val;\n\n    address_space_read(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED,\n                       &val, 1);\n    trace_cpu_in(addr, 'b', val);\n    return val;\n}\n\nuint16_t cpu_inw(uint32_t addr)\n{\n    uint8_t buf[2];\n    uint16_t val;\n\n    address_space_read(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED, buf, 2);\n    val = lduw_p(buf);\n    trace_cpu_in(addr, 'w', val);\n    return val;\n}\n\nuint32_t cpu_inl(uint32_t addr)\n{\n    uint8_t buf[4];\n    uint32_t val;\n\n    address_space_read(&address_space_io, addr, MEMTXATTRS_UNSPECIFIED, buf, 4);\n    val = ldl_p(buf);\n    trace_cpu_in(addr, 'l', val);\n    return val;\n}\n\nvoid portio_list_init(PortioList *piolist,\n                      Object *owner,\n                      const MemoryRegionPortio *callbacks,\n                      void *opaque, const char *name)\n{\n    unsigned n = 0;\n\n    while (callbacks[n].size) {\n        ++n;\n    }\n\n    piolist->ports = callbacks;\n    piolist->nr = 0;\n    piolist->regions = g_new0(MemoryRegion *, n);\n    piolist->address_space = NULL;\n    piolist->opaque = opaque;\n    piolist->owner = owner;\n    piolist->name = name;\n    piolist->flush_coalesced_mmio = false;\n}\n\nvoid portio_list_set_flush_coalesced(PortioList *piolist)\n{\n    piolist->flush_coalesced_mmio = true;\n}\n\nvoid portio_list_destroy(PortioList *piolist)\n{\n    MemoryRegionPortioList *mrpio;\n    unsigned i;\n\n    for (i = 0; i < piolist->nr; ++i) {\n        mrpio = container_of(piolist->regions[i], MemoryRegionPortioList, mr);\n        object_unparent(OBJECT(&mrpio->mr));\n        g_free(mrpio);\n    }\n    g_free(piolist->regions);\n}\n\nstatic const MemoryRegionPortio *find_portio(MemoryRegionPortioList *mrpio,\n                                             uint64_t offset, unsigned size,\n                                             bool write)\n{\n    const MemoryRegionPortio *mrp;\n\n    for (mrp = mrpio->ports; mrp->size; ++mrp) {\n        if (offset >= mrp->offset && offset < mrp->offset + mrp->len &&\n            size == mrp->size &&\n            (write ? (bool)mrp->write : (bool)mrp->read)) {\n            return mrp;\n        }\n    }\n    return NULL;\n}\n\nstatic uint64_t portio_read(void *opaque, hwaddr addr, unsigned size)\n{\n    MemoryRegionPortioList *mrpio = opaque;\n    const MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, false);\n    uint64_t data;\n\n    data = ((uint64_t)1 << (size * 8)) - 1;\n    if (mrp) {\n        data = mrp->read(mrpio->portio_opaque, mrp->base + addr);\n    } else if (size == 2) {\n        mrp = find_portio(mrpio, addr, 1, false);\n        if (mrp) {\n            data = mrp->read(mrpio->portio_opaque, mrp->base + addr);\n            if (addr + 1 < mrp->offset + mrp->len) {\n                data |= mrp->read(mrpio->portio_opaque, mrp->base + addr + 1) << 8;\n            } else {\n                data |= 0xff00;\n            }\n        }\n    }\n    return data;\n}\n\nstatic void portio_write(void *opaque, hwaddr addr, uint64_t data,\n                         unsigned size)\n{\n    MemoryRegionPortioList *mrpio = opaque;\n    const MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, true);\n\n    if (mrp) {\n        mrp->write(mrpio->portio_opaque, mrp->base + addr, data);\n    } else if (size == 2) {\n        mrp = find_portio(mrpio, addr, 1, true);\n        if (mrp) {\n            mrp->write(mrpio->portio_opaque, mrp->base + addr, data & 0xff);\n            if (addr + 1 < mrp->offset + mrp->len) {\n                mrp->write(mrpio->portio_opaque, mrp->base + addr + 1, data >> 8);\n            }\n        }\n    }\n}\n\nstatic const MemoryRegionOps portio_ops = {\n    .read = portio_read,\n    .write = portio_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .valid.unaligned = true,\n    .impl.unaligned = true,\n};\n\nstatic void portio_list_add_1(PortioList *piolist,\n                              const MemoryRegionPortio *pio_init,\n                              unsigned count, unsigned start,\n                              unsigned off_low, unsigned off_high)\n{\n    MemoryRegionPortioList *mrpio;\n    unsigned i;\n\n    /* Copy the sub-list and null-terminate it.  */\n    mrpio = g_malloc0(sizeof(MemoryRegionPortioList) +\n                      sizeof(MemoryRegionPortio) * (count + 1));\n    mrpio->portio_opaque = piolist->opaque;\n    memcpy(mrpio->ports, pio_init, sizeof(MemoryRegionPortio) * count);\n    memset(mrpio->ports + count, 0, sizeof(MemoryRegionPortio));\n\n    /* Adjust the offsets to all be zero-based for the region.  */\n    for (i = 0; i < count; ++i) {\n        mrpio->ports[i].offset -= off_low;\n        mrpio->ports[i].base = start + off_low;\n    }\n\n    memory_region_init_io(&mrpio->mr, piolist->owner, &portio_ops, mrpio,\n                          piolist->name, off_high - off_low);\n    if (piolist->flush_coalesced_mmio) {\n        memory_region_set_flush_coalesced(&mrpio->mr);\n    }\n    memory_region_add_subregion(piolist->address_space,\n                                start + off_low, &mrpio->mr);\n    piolist->regions[piolist->nr] = &mrpio->mr;\n    ++piolist->nr;\n}\n\nvoid portio_list_add(PortioList *piolist,\n                     MemoryRegion *address_space,\n                     uint32_t start)\n{\n    const MemoryRegionPortio *pio, *pio_start = piolist->ports;\n    unsigned int off_low, off_high, off_last, count;\n\n    piolist->address_space = address_space;\n\n    /* Handle the first entry specially.  */\n    off_last = off_low = pio_start->offset;\n    off_high = off_low + pio_start->len + pio_start->size - 1;\n    count = 1;\n\n    for (pio = pio_start + 1; pio->size != 0; pio++, count++) {\n        /* All entries must be sorted by offset.  */\n        assert(pio->offset >= off_last);\n        off_last = pio->offset;\n\n        /* If we see a hole, break the region.  */\n        if (off_last > off_high) {\n            portio_list_add_1(piolist, pio_start, count, start, off_low,\n                              off_high);\n            /* ... and start collecting anew.  */\n            pio_start = pio;\n            off_low = off_last;\n            off_high = off_low + pio->len + pio_start->size - 1;\n            count = 0;\n        } else if (off_last + pio->len > off_high) {\n            off_high = off_last + pio->len + pio_start->size - 1;\n        }\n    }\n\n    /* There will always be an open sub-list.  */\n    portio_list_add_1(piolist, pio_start, count, start, off_low, off_high);\n}\n\nvoid portio_list_del(PortioList *piolist)\n{\n    MemoryRegionPortioList *mrpio;\n    unsigned i;\n\n    for (i = 0; i < piolist->nr; ++i) {\n        mrpio = container_of(piolist->regions[i], MemoryRegionPortioList, mr);\n        memory_region_del_subregion(piolist->address_space, &mrpio->mr);\n    }\n}\n"
        },
        {
          "name": "iothread.c",
          "type": "blob",
          "size": 8.478515625,
          "content": "/*\n * Event loop thread\n *\n * Copyright Red Hat Inc., 2013\n *\n * Authors:\n *  Stefan Hajnoczi   <stefanha@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qom/object.h\"\n#include \"qom/object_interfaces.h\"\n#include \"qemu/module.h\"\n#include \"block/aio.h\"\n#include \"block/block.h\"\n#include \"sysemu/iothread.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/rcu.h\"\n#include \"qemu/main-loop.h\"\n\ntypedef ObjectClass IOThreadClass;\n\n#define IOTHREAD_GET_CLASS(obj) \\\n   OBJECT_GET_CLASS(IOThreadClass, obj, TYPE_IOTHREAD)\n#define IOTHREAD_CLASS(klass) \\\n   OBJECT_CLASS_CHECK(IOThreadClass, klass, TYPE_IOTHREAD)\n\n/* Benchmark results from 2016 on NVMe SSD drives show max polling times around\n * 16-32 microseconds yield IOPS improvements for both iodepth=1 and iodepth=32\n * workloads.\n */\n#define IOTHREAD_POLL_MAX_NS_DEFAULT 32768ULL\n\nstatic __thread IOThread *my_iothread;\n\nAioContext *qemu_get_current_aio_context(void)\n{\n    return my_iothread ? my_iothread->ctx : qemu_get_aio_context();\n}\n\nstatic void *iothread_run(void *opaque)\n{\n    IOThread *iothread = opaque;\n\n    rcu_register_thread();\n\n    my_iothread = iothread;\n    qemu_mutex_lock(&iothread->init_done_lock);\n    iothread->thread_id = qemu_get_thread_id();\n    qemu_cond_signal(&iothread->init_done_cond);\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n    while (!atomic_read(&iothread->stopping)) {\n        aio_poll(iothread->ctx, true);\n    }\n\n    rcu_unregister_thread();\n    return NULL;\n}\n\nstatic int iothread_stop(Object *object, void *opaque)\n{\n    IOThread *iothread;\n\n    iothread = (IOThread *)object_dynamic_cast(object, TYPE_IOTHREAD);\n    if (!iothread || !iothread->ctx) {\n        return 0;\n    }\n    iothread->stopping = true;\n    aio_notify(iothread->ctx);\n    qemu_thread_join(&iothread->thread);\n    return 0;\n}\n\nstatic void iothread_instance_init(Object *obj)\n{\n    IOThread *iothread = IOTHREAD(obj);\n\n    iothread->poll_max_ns = IOTHREAD_POLL_MAX_NS_DEFAULT;\n}\n\nstatic void iothread_instance_finalize(Object *obj)\n{\n    IOThread *iothread = IOTHREAD(obj);\n\n    iothread_stop(obj, NULL);\n    qemu_cond_destroy(&iothread->init_done_cond);\n    qemu_mutex_destroy(&iothread->init_done_lock);\n    if (!iothread->ctx) {\n        return;\n    }\n    aio_context_unref(iothread->ctx);\n}\n\nstatic void iothread_complete(UserCreatable *obj, Error **errp)\n{\n    Error *local_error = NULL;\n    IOThread *iothread = IOTHREAD(obj);\n    char *name, *thread_name;\n\n    iothread->stopping = false;\n    iothread->thread_id = -1;\n    iothread->ctx = aio_context_new(&local_error);\n    if (!iothread->ctx) {\n        error_propagate(errp, local_error);\n        return;\n    }\n\n    aio_context_set_poll_params(iothread->ctx,\n                                iothread->poll_max_ns,\n                                iothread->poll_grow,\n                                iothread->poll_shrink,\n                                &local_error);\n    if (local_error) {\n        error_propagate(errp, local_error);\n        aio_context_unref(iothread->ctx);\n        iothread->ctx = NULL;\n        return;\n    }\n\n    qemu_mutex_init(&iothread->init_done_lock);\n    qemu_cond_init(&iothread->init_done_cond);\n\n    /* This assumes we are called from a thread with useful CPU affinity for us\n     * to inherit.\n     */\n    name = object_get_canonical_path_component(OBJECT(obj));\n    thread_name = g_strdup_printf(\"IO %s\", name);\n    qemu_thread_create(&iothread->thread, thread_name, iothread_run,\n                       iothread, QEMU_THREAD_JOINABLE);\n    g_free(thread_name);\n    g_free(name);\n\n    /* Wait for initialization to complete */\n    qemu_mutex_lock(&iothread->init_done_lock);\n    while (iothread->thread_id == -1) {\n        qemu_cond_wait(&iothread->init_done_cond,\n                       &iothread->init_done_lock);\n    }\n    qemu_mutex_unlock(&iothread->init_done_lock);\n}\n\ntypedef struct {\n    const char *name;\n    ptrdiff_t offset; /* field's byte offset in IOThread struct */\n} PollParamInfo;\n\nstatic PollParamInfo poll_max_ns_info = {\n    \"poll-max-ns\", offsetof(IOThread, poll_max_ns),\n};\nstatic PollParamInfo poll_grow_info = {\n    \"poll-grow\", offsetof(IOThread, poll_grow),\n};\nstatic PollParamInfo poll_shrink_info = {\n    \"poll-shrink\", offsetof(IOThread, poll_shrink),\n};\n\nstatic void iothread_get_poll_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(obj);\n    PollParamInfo *info = opaque;\n    int64_t *field = (void *)iothread + info->offset;\n\n    visit_type_int64(v, name, field, errp);\n}\n\nstatic void iothread_set_poll_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(obj);\n    PollParamInfo *info = opaque;\n    int64_t *field = (void *)iothread + info->offset;\n    Error *local_err = NULL;\n    int64_t value;\n\n    visit_type_int64(v, name, &value, &local_err);\n    if (local_err) {\n        goto out;\n    }\n\n    if (value < 0) {\n        error_setg(&local_err, \"%s value must be in range [0, %\"PRId64\"]\",\n                   info->name, INT64_MAX);\n        goto out;\n    }\n\n    *field = value;\n\n    if (iothread->ctx) {\n        aio_context_set_poll_params(iothread->ctx,\n                                    iothread->poll_max_ns,\n                                    iothread->poll_grow,\n                                    iothread->poll_shrink,\n                                    &local_err);\n    }\n\nout:\n    error_propagate(errp, local_err);\n}\n\nstatic void iothread_class_init(ObjectClass *klass, void *class_data)\n{\n    UserCreatableClass *ucc = USER_CREATABLE_CLASS(klass);\n    ucc->complete = iothread_complete;\n\n    object_class_property_add(klass, \"poll-max-ns\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_max_ns_info, &error_abort);\n    object_class_property_add(klass, \"poll-grow\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_grow_info, &error_abort);\n    object_class_property_add(klass, \"poll-shrink\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_shrink_info, &error_abort);\n}\n\nstatic const TypeInfo iothread_info = {\n    .name = TYPE_IOTHREAD,\n    .parent = TYPE_OBJECT,\n    .class_init = iothread_class_init,\n    .instance_size = sizeof(IOThread),\n    .instance_init = iothread_instance_init,\n    .instance_finalize = iothread_instance_finalize,\n    .interfaces = (InterfaceInfo[]) {\n        {TYPE_USER_CREATABLE},\n        {}\n    },\n};\n\nstatic void iothread_register_types(void)\n{\n    type_register_static(&iothread_info);\n}\n\ntype_init(iothread_register_types)\n\nchar *iothread_get_id(IOThread *iothread)\n{\n    return object_get_canonical_path_component(OBJECT(iothread));\n}\n\nAioContext *iothread_get_aio_context(IOThread *iothread)\n{\n    return iothread->ctx;\n}\n\nstatic int query_one_iothread(Object *object, void *opaque)\n{\n    IOThreadInfoList ***prev = opaque;\n    IOThreadInfoList *elem;\n    IOThreadInfo *info;\n    IOThread *iothread;\n\n    iothread = (IOThread *)object_dynamic_cast(object, TYPE_IOTHREAD);\n    if (!iothread) {\n        return 0;\n    }\n\n    info = g_new0(IOThreadInfo, 1);\n    info->id = iothread_get_id(iothread);\n    info->thread_id = iothread->thread_id;\n    info->poll_max_ns = iothread->poll_max_ns;\n    info->poll_grow = iothread->poll_grow;\n    info->poll_shrink = iothread->poll_shrink;\n\n    elem = g_new0(IOThreadInfoList, 1);\n    elem->value = info;\n    elem->next = NULL;\n\n    **prev = elem;\n    *prev = &elem->next;\n    return 0;\n}\n\nIOThreadInfoList *qmp_query_iothreads(Error **errp)\n{\n    IOThreadInfoList *head = NULL;\n    IOThreadInfoList **prev = &head;\n    Object *container = object_get_objects_root();\n\n    object_child_foreach(container, query_one_iothread, &prev);\n    return head;\n}\n\nvoid iothread_stop_all(void)\n{\n    Object *container = object_get_objects_root();\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        AioContext *ctx = bdrv_get_aio_context(bs);\n        if (ctx == qemu_get_aio_context()) {\n            continue;\n        }\n        aio_context_acquire(ctx);\n        bdrv_set_aio_context(bs, qemu_get_aio_context());\n        aio_context_release(ctx);\n    }\n\n    object_child_foreach(container, iothread_stop, NULL);\n}\n"
        },
        {
          "name": "kvm-all.c",
          "type": "blob",
          "size": 68.0048828125,
          "content": "/*\n * QEMU KVM support\n *\n * Copyright IBM, Corp. 2008\n *           Red Hat, Inc. 2008\n *\n * Authors:\n *  Anthony Liguori   <aliguori@us.ibm.com>\n *  Glauber Costa     <gcosta@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include <sys/ioctl.h>\n\n#include <linux/kvm.h>\n\n#include \"qemu-common.h\"\n#include \"qemu/atomic.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/error-report.h\"\n#include \"hw/hw.h\"\n#include \"hw/pci/msi.h\"\n#include \"hw/pci/msix.h\"\n#include \"hw/s390x/adapter.h\"\n#include \"exec/gdbstub.h\"\n#include \"sysemu/kvm_int.h\"\n#include \"sysemu/cpus.h\"\n#include \"qemu/bswap.h\"\n#include \"exec/memory.h\"\n#include \"exec/ram_addr.h\"\n#include \"exec/address-spaces.h\"\n#include \"qemu/event_notifier.h\"\n#include \"trace-root.h\"\n#include \"hw/irq.h\"\n\n#include \"hw/boards.h\"\n\n/* This check must be after config-host.h is included */\n#ifdef CONFIG_EVENTFD\n#include <sys/eventfd.h>\n#endif\n\n/* KVM uses PAGE_SIZE in its definition of KVM_COALESCED_MMIO_MAX. We\n * need to use the real host PAGE_SIZE, as that's what KVM will use.\n */\n#define PAGE_SIZE getpagesize()\n\n//#define DEBUG_KVM\n\n#ifdef DEBUG_KVM\n#define DPRINTF(fmt, ...) \\\n    do { fprintf(stderr, fmt, ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) \\\n    do { } while (0)\n#endif\n\n#define KVM_MSI_HASHTAB_SIZE    256\n\nstruct KVMParkedVcpu {\n    unsigned long vcpu_id;\n    int kvm_fd;\n    QLIST_ENTRY(KVMParkedVcpu) node;\n};\n\nstruct KVMState\n{\n    AccelState parent_obj;\n\n    int nr_slots;\n    int fd;\n    int vmfd;\n    int coalesced_mmio;\n    struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;\n    bool coalesced_flush_in_progress;\n    int broken_set_mem_region;\n    int vcpu_events;\n    int robust_singlestep;\n    int debugregs;\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n    struct kvm_sw_breakpoint_head kvm_sw_breakpoints;\n#endif\n    int many_ioeventfds;\n    int intx_set_mask;\n    /* The man page (and posix) say ioctl numbers are signed int, but\n     * they're not.  Linux, glibc and *BSD all treat ioctl numbers as\n     * unsigned, and treating them as signed here can break things */\n    unsigned irq_set_ioctl;\n    unsigned int sigmask_len;\n    GHashTable *gsimap;\n#ifdef KVM_CAP_IRQ_ROUTING\n    struct kvm_irq_routing *irq_routes;\n    int nr_allocated_irq_routes;\n    unsigned long *used_gsi_bitmap;\n    unsigned int gsi_count;\n    QTAILQ_HEAD(msi_hashtab, KVMMSIRoute) msi_hashtab[KVM_MSI_HASHTAB_SIZE];\n#endif\n    KVMMemoryListener memory_listener;\n    QLIST_HEAD(, KVMParkedVcpu) kvm_parked_vcpus;\n};\n\nKVMState *kvm_state;\nbool kvm_kernel_irqchip;\nbool kvm_split_irqchip;\nbool kvm_async_interrupts_allowed;\nbool kvm_halt_in_kernel_allowed;\nbool kvm_eventfds_allowed;\nbool kvm_irqfds_allowed;\nbool kvm_resamplefds_allowed;\nbool kvm_msi_via_irqfd_allowed;\nbool kvm_gsi_routing_allowed;\nbool kvm_gsi_direct_mapping;\nbool kvm_allowed;\nbool kvm_readonly_mem_allowed;\nbool kvm_vm_attributes_allowed;\nbool kvm_direct_msi_allowed;\nbool kvm_ioeventfd_any_length_allowed;\nbool kvm_msi_use_devid;\nstatic bool kvm_immediate_exit;\n\nstatic const KVMCapabilityInfo kvm_required_capabilites[] = {\n    KVM_CAP_INFO(USER_MEMORY),\n    KVM_CAP_INFO(DESTROY_MEMORY_REGION_WORKS),\n    KVM_CAP_LAST_INFO\n};\n\nint kvm_get_max_memslots(void)\n{\n    KVMState *s = KVM_STATE(current_machine->accelerator);\n\n    return s->nr_slots;\n}\n\nstatic KVMSlot *kvm_get_free_slot(KVMMemoryListener *kml)\n{\n    KVMState *s = kvm_state;\n    int i;\n\n    for (i = 0; i < s->nr_slots; i++) {\n        if (kml->slots[i].memory_size == 0) {\n            return &kml->slots[i];\n        }\n    }\n\n    return NULL;\n}\n\nbool kvm_has_free_slot(MachineState *ms)\n{\n    KVMState *s = KVM_STATE(ms->accelerator);\n\n    return kvm_get_free_slot(&s->memory_listener);\n}\n\nstatic KVMSlot *kvm_alloc_slot(KVMMemoryListener *kml)\n{\n    KVMSlot *slot = kvm_get_free_slot(kml);\n\n    if (slot) {\n        return slot;\n    }\n\n    fprintf(stderr, \"%s: no free slot available\\n\", __func__);\n    abort();\n}\n\nstatic KVMSlot *kvm_lookup_matching_slot(KVMMemoryListener *kml,\n                                         hwaddr start_addr,\n                                         hwaddr end_addr)\n{\n    KVMState *s = kvm_state;\n    int i;\n\n    for (i = 0; i < s->nr_slots; i++) {\n        KVMSlot *mem = &kml->slots[i];\n\n        if (start_addr == mem->start_addr &&\n            end_addr == mem->start_addr + mem->memory_size) {\n            return mem;\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * Find overlapping slot with lowest start address\n */\nstatic KVMSlot *kvm_lookup_overlapping_slot(KVMMemoryListener *kml,\n                                            hwaddr start_addr,\n                                            hwaddr end_addr)\n{\n    KVMState *s = kvm_state;\n    KVMSlot *found = NULL;\n    int i;\n\n    for (i = 0; i < s->nr_slots; i++) {\n        KVMSlot *mem = &kml->slots[i];\n\n        if (mem->memory_size == 0 ||\n            (found && found->start_addr < mem->start_addr)) {\n            continue;\n        }\n\n        if (end_addr > mem->start_addr &&\n            start_addr < mem->start_addr + mem->memory_size) {\n            found = mem;\n        }\n    }\n\n    return found;\n}\n\nint kvm_physical_memory_addr_from_host(KVMState *s, void *ram,\n                                       hwaddr *phys_addr)\n{\n    KVMMemoryListener *kml = &s->memory_listener;\n    int i;\n\n    for (i = 0; i < s->nr_slots; i++) {\n        KVMSlot *mem = &kml->slots[i];\n\n        if (ram >= mem->ram && ram < mem->ram + mem->memory_size) {\n            *phys_addr = mem->start_addr + (ram - mem->ram);\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nstatic int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot)\n{\n    KVMState *s = kvm_state;\n    struct kvm_userspace_memory_region mem;\n\n    mem.slot = slot->slot | (kml->as_id << 16);\n    mem.guest_phys_addr = slot->start_addr;\n    mem.userspace_addr = (unsigned long)slot->ram;\n    mem.flags = slot->flags;\n\n    if (slot->memory_size && mem.flags & KVM_MEM_READONLY) {\n        /* Set the slot size to 0 before setting the slot to the desired\n         * value. This is needed based on KVM commit 75d61fbc. */\n        mem.memory_size = 0;\n        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n    }\n    mem.memory_size = slot->memory_size;\n    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n}\n\nint kvm_destroy_vcpu(CPUState *cpu)\n{\n    KVMState *s = kvm_state;\n    long mmap_size;\n    struct KVMParkedVcpu *vcpu = NULL;\n    int ret = 0;\n\n    DPRINTF(\"kvm_destroy_vcpu\\n\");\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n    if (mmap_size < 0) {\n        ret = mmap_size;\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n        goto err;\n    }\n\n    ret = munmap(cpu->kvm_run, mmap_size);\n    if (ret < 0) {\n        goto err;\n    }\n\n    vcpu = g_malloc0(sizeof(*vcpu));\n    vcpu->vcpu_id = kvm_arch_vcpu_id(cpu);\n    vcpu->kvm_fd = cpu->kvm_fd;\n    QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);\nerr:\n    return ret;\n}\n\nstatic int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)\n{\n    struct KVMParkedVcpu *cpu;\n\n    QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {\n        if (cpu->vcpu_id == vcpu_id) {\n            int kvm_fd;\n\n            QLIST_REMOVE(cpu, node);\n            kvm_fd = cpu->kvm_fd;\n            g_free(cpu);\n            return kvm_fd;\n        }\n    }\n\n    return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);\n}\n\nint kvm_init_vcpu(CPUState *cpu)\n{\n    KVMState *s = kvm_state;\n    long mmap_size;\n    int ret;\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n    ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu));\n    if (ret < 0) {\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n        goto err;\n    }\n\n    cpu->kvm_fd = ret;\n    cpu->kvm_state = s;\n    cpu->kvm_vcpu_dirty = true;\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n    if (mmap_size < 0) {\n        ret = mmap_size;\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n        goto err;\n    }\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n                        cpu->kvm_fd, 0);\n    if (cpu->kvm_run == MAP_FAILED) {\n        ret = -errno;\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n        goto err;\n    }\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n        s->coalesced_mmio_ring =\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n    }\n\n    ret = kvm_arch_init_vcpu(cpu);\nerr:\n    return ret;\n}\n\n/*\n * dirty pages logging control\n */\n\nstatic int kvm_mem_flags(MemoryRegion *mr)\n{\n    bool readonly = mr->readonly || memory_region_is_romd(mr);\n    int flags = 0;\n\n    if (memory_region_get_dirty_log_mask(mr) != 0) {\n        flags |= KVM_MEM_LOG_DIRTY_PAGES;\n    }\n    if (readonly && kvm_readonly_mem_allowed) {\n        flags |= KVM_MEM_READONLY;\n    }\n    return flags;\n}\n\nstatic int kvm_slot_update_flags(KVMMemoryListener *kml, KVMSlot *mem,\n                                 MemoryRegion *mr)\n{\n    int old_flags;\n\n    old_flags = mem->flags;\n    mem->flags = kvm_mem_flags(mr);\n\n    /* If nothing changed effectively, no need to issue ioctl */\n    if (mem->flags == old_flags) {\n        return 0;\n    }\n\n    return kvm_set_user_memory_region(kml, mem);\n}\n\nstatic int kvm_section_update_flags(KVMMemoryListener *kml,\n                                    MemoryRegionSection *section)\n{\n    hwaddr phys_addr = section->offset_within_address_space;\n    ram_addr_t size = int128_get64(section->size);\n    KVMSlot *mem = kvm_lookup_matching_slot(kml, phys_addr, phys_addr + size);\n\n    if (mem == NULL)  {\n        return 0;\n    } else {\n        return kvm_slot_update_flags(kml, mem, section->mr);\n    }\n}\n\nstatic void kvm_log_start(MemoryListener *listener,\n                          MemoryRegionSection *section,\n                          int old, int new)\n{\n    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);\n    int r;\n\n    if (old != 0) {\n        return;\n    }\n\n    r = kvm_section_update_flags(kml, section);\n    if (r < 0) {\n        abort();\n    }\n}\n\nstatic void kvm_log_stop(MemoryListener *listener,\n                          MemoryRegionSection *section,\n                          int old, int new)\n{\n    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);\n    int r;\n\n    if (new != 0) {\n        return;\n    }\n\n    r = kvm_section_update_flags(kml, section);\n    if (r < 0) {\n        abort();\n    }\n}\n\n/* get kvm's dirty pages bitmap and update qemu's */\nstatic int kvm_get_dirty_pages_log_range(MemoryRegionSection *section,\n                                         unsigned long *bitmap)\n{\n    ram_addr_t start = section->offset_within_region +\n                       memory_region_get_ram_addr(section->mr);\n    ram_addr_t pages = int128_get64(section->size) / getpagesize();\n\n    cpu_physical_memory_set_dirty_lebitmap(bitmap, start, pages);\n    return 0;\n}\n\n#define ALIGN(x, y)  (((x)+(y)-1) & ~((y)-1))\n\n/**\n * kvm_physical_sync_dirty_bitmap - Grab dirty bitmap from kernel space\n * This function updates qemu's dirty bitmap using\n * memory_region_set_dirty().  This means all bits are set\n * to dirty.\n *\n * @start_add: start of logged region.\n * @end_addr: end of logged region.\n */\nstatic int kvm_physical_sync_dirty_bitmap(KVMMemoryListener *kml,\n                                          MemoryRegionSection *section)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    struct kvm_dirty_log d = {};\n    KVMSlot *mem;\n    int ret = 0;\n    hwaddr start_addr = section->offset_within_address_space;\n    hwaddr end_addr = start_addr + int128_get64(section->size);\n\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(kml, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n\n        /* XXX bad kernel interface alert\n         * For dirty bitmap, kernel allocates array of size aligned to\n         * bits-per-long.  But for case when the kernel is 64bits and\n         * the userspace is 32bits, userspace can't align to the same\n         * bits-per-long, since sizeof(long) is different between kernel\n         * and user space.  This way, userspace will provide buffer which\n         * may be 4 bytes less than the kernel will use, resulting in\n         * userspace memory corruption (which is not detectable by valgrind\n         * too, in most cases).\n         * So for now, let's align to 64 instead of HOST_LONG_BITS here, in\n         * a hope that sizeof(long) won't become >8 any time soon.\n         */\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS),\n                     /*HOST_LONG_BITS*/ 64) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = g_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = g_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n        d.slot = mem->slot | (kml->as_id << 16);\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n\n        kvm_get_dirty_pages_log_range(section, d.dirty_bitmap);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    g_free(d.dirty_bitmap);\n\n    return ret;\n}\n\nstatic void kvm_coalesce_mmio_region(MemoryListener *listener,\n                                     MemoryRegionSection *secion,\n                                     hwaddr start, hwaddr size)\n{\n    KVMState *s = kvm_state;\n\n    if (s->coalesced_mmio) {\n        struct kvm_coalesced_mmio_zone zone;\n\n        zone.addr = start;\n        zone.size = size;\n        zone.pad = 0;\n\n        (void)kvm_vm_ioctl(s, KVM_REGISTER_COALESCED_MMIO, &zone);\n    }\n}\n\nstatic void kvm_uncoalesce_mmio_region(MemoryListener *listener,\n                                       MemoryRegionSection *secion,\n                                       hwaddr start, hwaddr size)\n{\n    KVMState *s = kvm_state;\n\n    if (s->coalesced_mmio) {\n        struct kvm_coalesced_mmio_zone zone;\n\n        zone.addr = start;\n        zone.size = size;\n        zone.pad = 0;\n\n        (void)kvm_vm_ioctl(s, KVM_UNREGISTER_COALESCED_MMIO, &zone);\n    }\n}\n\nint kvm_check_extension(KVMState *s, unsigned int extension)\n{\n    int ret;\n\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, extension);\n    if (ret < 0) {\n        ret = 0;\n    }\n\n    return ret;\n}\n\nint kvm_vm_check_extension(KVMState *s, unsigned int extension)\n{\n    int ret;\n\n    ret = kvm_vm_ioctl(s, KVM_CHECK_EXTENSION, extension);\n    if (ret < 0) {\n        /* VM wide version not implemented, use global one instead */\n        ret = kvm_check_extension(s, extension);\n    }\n\n    return ret;\n}\n\nstatic uint32_t adjust_ioeventfd_endianness(uint32_t val, uint32_t size)\n{\n#if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)\n    /* The kernel expects ioeventfd values in HOST_WORDS_BIGENDIAN\n     * endianness, but the memory core hands them in target endianness.\n     * For example, PPC is always treated as big-endian even if running\n     * on KVM and on PPC64LE.  Correct here.\n     */\n    switch (size) {\n    case 2:\n        val = bswap16(val);\n        break;\n    case 4:\n        val = bswap32(val);\n        break;\n    }\n#endif\n    return val;\n}\n\nstatic int kvm_set_ioeventfd_mmio(int fd, hwaddr addr, uint32_t val,\n                                  bool assign, uint32_t size, bool datamatch)\n{\n    int ret;\n    struct kvm_ioeventfd iofd = {\n        .datamatch = datamatch ? adjust_ioeventfd_endianness(val, size) : 0,\n        .addr = addr,\n        .len = size,\n        .flags = 0,\n        .fd = fd,\n    };\n\n    if (!kvm_enabled()) {\n        return -ENOSYS;\n    }\n\n    if (datamatch) {\n        iofd.flags |= KVM_IOEVENTFD_FLAG_DATAMATCH;\n    }\n    if (!assign) {\n        iofd.flags |= KVM_IOEVENTFD_FLAG_DEASSIGN;\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &iofd);\n\n    if (ret < 0) {\n        return -errno;\n    }\n\n    return 0;\n}\n\nstatic int kvm_set_ioeventfd_pio(int fd, uint16_t addr, uint16_t val,\n                                 bool assign, uint32_t size, bool datamatch)\n{\n    struct kvm_ioeventfd kick = {\n        .datamatch = datamatch ? adjust_ioeventfd_endianness(val, size) : 0,\n        .addr = addr,\n        .flags = KVM_IOEVENTFD_FLAG_PIO,\n        .len = size,\n        .fd = fd,\n    };\n    int r;\n    if (!kvm_enabled()) {\n        return -ENOSYS;\n    }\n    if (datamatch) {\n        kick.flags |= KVM_IOEVENTFD_FLAG_DATAMATCH;\n    }\n    if (!assign) {\n        kick.flags |= KVM_IOEVENTFD_FLAG_DEASSIGN;\n    }\n    r = kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &kick);\n    if (r < 0) {\n        return r;\n    }\n    return 0;\n}\n\n\nstatic int kvm_check_many_ioeventfds(void)\n{\n    /* Userspace can use ioeventfd for io notification.  This requires a host\n     * that supports eventfd(2) and an I/O thread; since eventfd does not\n     * support SIGIO it cannot interrupt the vcpu.\n     *\n     * Older kernels have a 6 device limit on the KVM io bus.  Find out so we\n     * can avoid creating too many ioeventfds.\n     */\n#if defined(CONFIG_EVENTFD)\n    int ioeventfds[7];\n    int i, ret = 0;\n    for (i = 0; i < ARRAY_SIZE(ioeventfds); i++) {\n        ioeventfds[i] = eventfd(0, EFD_CLOEXEC);\n        if (ioeventfds[i] < 0) {\n            break;\n        }\n        ret = kvm_set_ioeventfd_pio(ioeventfds[i], 0, i, true, 2, true);\n        if (ret < 0) {\n            close(ioeventfds[i]);\n            break;\n        }\n    }\n\n    /* Decide whether many devices are supported or not */\n    ret = i == ARRAY_SIZE(ioeventfds);\n\n    while (i-- > 0) {\n        kvm_set_ioeventfd_pio(ioeventfds[i], 0, i, false, 2, true);\n        close(ioeventfds[i]);\n    }\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const KVMCapabilityInfo *\nkvm_check_extension_list(KVMState *s, const KVMCapabilityInfo *list)\n{\n    while (list->name) {\n        if (!kvm_check_extension(s, list->value)) {\n            return list;\n        }\n        list++;\n    }\n    return NULL;\n}\n\nstatic void kvm_set_phys_mem(KVMMemoryListener *kml,\n                             MemoryRegionSection *section, bool add)\n{\n    KVMState *s = kvm_state;\n    KVMSlot *mem, old;\n    int err;\n    MemoryRegion *mr = section->mr;\n    bool writeable = !mr->readonly && !mr->rom_device;\n    hwaddr start_addr = section->offset_within_address_space;\n    ram_addr_t size = int128_get64(section->size);\n    void *ram = NULL;\n    unsigned delta;\n\n    /* kvm works in page size chunks, but the function may be called\n       with sub-page size and unaligned start address. Pad the start\n       address to next and truncate size to previous page boundary. */\n    delta = qemu_real_host_page_size - (start_addr & ~qemu_real_host_page_mask);\n    delta &= ~qemu_real_host_page_mask;\n    if (delta > size) {\n        return;\n    }\n    start_addr += delta;\n    size -= delta;\n    size &= qemu_real_host_page_mask;\n    if (!size || (start_addr & ~qemu_real_host_page_mask)) {\n        return;\n    }\n\n    if (!memory_region_is_ram(mr)) {\n        if (writeable || !kvm_readonly_mem_allowed) {\n            return;\n        } else if (!mr->romd_mode) {\n            /* If the memory device is not in romd_mode, then we actually want\n             * to remove the kvm memory slot so all accesses will trap. */\n            add = false;\n        }\n    }\n\n    ram = memory_region_get_ram_ptr(mr) + section->offset_within_region + delta;\n\n    while (1) {\n        mem = kvm_lookup_overlapping_slot(kml, start_addr, start_addr + size);\n        if (!mem) {\n            break;\n        }\n\n        if (add && start_addr >= mem->start_addr &&\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n            (ram - start_addr == mem->ram - mem->start_addr)) {\n            /* The new slot fits into the existing one and comes with\n             * identical parameters - update flags and done. */\n            kvm_slot_update_flags(kml, mem, mr);\n            return;\n        }\n\n        old = *mem;\n\n        if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {\n            kvm_physical_sync_dirty_bitmap(kml, section);\n        }\n\n        /* unregister the overlapping slot */\n        mem->memory_size = 0;\n        err = kvm_set_user_memory_region(kml, mem);\n        if (err) {\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n                    __func__, strerror(-err));\n            abort();\n        }\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n         * unregistering the previous ones and then registering the larger\n         * slot. We have to maintain the existing fragmentation. Sigh.\n         *\n         * This workaround assumes that the new slot starts at the same\n         * address as the first existing one. If not or if some overlapping\n         * slot comes around later, we will fail (not seen in practice so far)\n         * - and actually require a recent KVM version. */\n        if (s->broken_set_mem_region &&\n            old.start_addr == start_addr && old.memory_size < size && add) {\n            mem = kvm_alloc_slot(kml);\n            mem->memory_size = old.memory_size;\n            mem->start_addr = old.start_addr;\n            mem->ram = old.ram;\n            mem->flags = kvm_mem_flags(mr);\n\n            err = kvm_set_user_memory_region(kml, mem);\n            if (err) {\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n                        strerror(-err));\n                abort();\n            }\n\n            start_addr += old.memory_size;\n            ram += old.memory_size;\n            size -= old.memory_size;\n            continue;\n        }\n\n        /* register prefix slot */\n        if (old.start_addr < start_addr) {\n            mem = kvm_alloc_slot(kml);\n            mem->memory_size = start_addr - old.start_addr;\n            mem->start_addr = old.start_addr;\n            mem->ram = old.ram;\n            mem->flags =  kvm_mem_flags(mr);\n\n            err = kvm_set_user_memory_region(kml, mem);\n            if (err) {\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n                        __func__, strerror(-err));\n#ifdef TARGET_PPC\n                fprintf(stderr, \"%s: This is probably because your kernel's \" \\\n                                \"PAGE_SIZE is too big. Please try to use 4k \" \\\n                                \"PAGE_SIZE!\\n\", __func__);\n#endif\n                abort();\n            }\n        }\n\n        /* register suffix slot */\n        if (old.start_addr + old.memory_size > start_addr + size) {\n            ram_addr_t size_delta;\n\n            mem = kvm_alloc_slot(kml);\n            mem->start_addr = start_addr + size;\n            size_delta = mem->start_addr - old.start_addr;\n            mem->memory_size = old.memory_size - size_delta;\n            mem->ram = old.ram + size_delta;\n            mem->flags = kvm_mem_flags(mr);\n\n            err = kvm_set_user_memory_region(kml, mem);\n            if (err) {\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n                        __func__, strerror(-err));\n                abort();\n            }\n        }\n    }\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n    if (!size) {\n        return;\n    }\n    if (!add) {\n        return;\n    }\n    mem = kvm_alloc_slot(kml);\n    mem->memory_size = size;\n    mem->start_addr = start_addr;\n    mem->ram = ram;\n    mem->flags = kvm_mem_flags(mr);\n\n    err = kvm_set_user_memory_region(kml, mem);\n    if (err) {\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n                strerror(-err));\n        abort();\n    }\n}\n\nstatic void kvm_region_add(MemoryListener *listener,\n                           MemoryRegionSection *section)\n{\n    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);\n\n    memory_region_ref(section->mr);\n    kvm_set_phys_mem(kml, section, true);\n}\n\nstatic void kvm_region_del(MemoryListener *listener,\n                           MemoryRegionSection *section)\n{\n    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);\n\n    kvm_set_phys_mem(kml, section, false);\n    memory_region_unref(section->mr);\n}\n\nstatic void kvm_log_sync(MemoryListener *listener,\n                         MemoryRegionSection *section)\n{\n    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);\n    int r;\n\n    r = kvm_physical_sync_dirty_bitmap(kml, section);\n    if (r < 0) {\n        abort();\n    }\n}\n\nstatic void kvm_mem_ioeventfd_add(MemoryListener *listener,\n                                  MemoryRegionSection *section,\n                                  bool match_data, uint64_t data,\n                                  EventNotifier *e)\n{\n    int fd = event_notifier_get_fd(e);\n    int r;\n\n    r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space,\n                               data, true, int128_get64(section->size),\n                               match_data);\n    if (r < 0) {\n        fprintf(stderr, \"%s: error adding ioeventfd: %s\\n\",\n                __func__, strerror(-r));\n        abort();\n    }\n}\n\nstatic void kvm_mem_ioeventfd_del(MemoryListener *listener,\n                                  MemoryRegionSection *section,\n                                  bool match_data, uint64_t data,\n                                  EventNotifier *e)\n{\n    int fd = event_notifier_get_fd(e);\n    int r;\n\n    r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space,\n                               data, false, int128_get64(section->size),\n                               match_data);\n    if (r < 0) {\n        abort();\n    }\n}\n\nstatic void kvm_io_ioeventfd_add(MemoryListener *listener,\n                                 MemoryRegionSection *section,\n                                 bool match_data, uint64_t data,\n                                 EventNotifier *e)\n{\n    int fd = event_notifier_get_fd(e);\n    int r;\n\n    r = kvm_set_ioeventfd_pio(fd, section->offset_within_address_space,\n                              data, true, int128_get64(section->size),\n                              match_data);\n    if (r < 0) {\n        fprintf(stderr, \"%s: error adding ioeventfd: %s\\n\",\n                __func__, strerror(-r));\n        abort();\n    }\n}\n\nstatic void kvm_io_ioeventfd_del(MemoryListener *listener,\n                                 MemoryRegionSection *section,\n                                 bool match_data, uint64_t data,\n                                 EventNotifier *e)\n\n{\n    int fd = event_notifier_get_fd(e);\n    int r;\n\n    r = kvm_set_ioeventfd_pio(fd, section->offset_within_address_space,\n                              data, false, int128_get64(section->size),\n                              match_data);\n    if (r < 0) {\n        abort();\n    }\n}\n\nvoid kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml,\n                                  AddressSpace *as, int as_id)\n{\n    int i;\n\n    kml->slots = g_malloc0(s->nr_slots * sizeof(KVMSlot));\n    kml->as_id = as_id;\n\n    for (i = 0; i < s->nr_slots; i++) {\n        kml->slots[i].slot = i;\n    }\n\n    kml->listener.region_add = kvm_region_add;\n    kml->listener.region_del = kvm_region_del;\n    kml->listener.log_start = kvm_log_start;\n    kml->listener.log_stop = kvm_log_stop;\n    kml->listener.log_sync = kvm_log_sync;\n    kml->listener.priority = 10;\n\n    memory_listener_register(&kml->listener, as);\n}\n\nstatic MemoryListener kvm_io_listener = {\n    .eventfd_add = kvm_io_ioeventfd_add,\n    .eventfd_del = kvm_io_ioeventfd_del,\n    .priority = 10,\n};\n\nstatic void kvm_handle_interrupt(CPUState *cpu, int mask)\n{\n    cpu->interrupt_request |= mask;\n\n    if (!qemu_cpu_is_self(cpu)) {\n        qemu_cpu_kick(cpu);\n    }\n}\n\nint kvm_set_irq(KVMState *s, int irq, int level)\n{\n    struct kvm_irq_level event;\n    int ret;\n\n    assert(kvm_async_interrupts_enabled());\n\n    event.level = level;\n    event.irq = irq;\n    ret = kvm_vm_ioctl(s, s->irq_set_ioctl, &event);\n    if (ret < 0) {\n        perror(\"kvm_set_irq\");\n        abort();\n    }\n\n    return (s->irq_set_ioctl == KVM_IRQ_LINE) ? 1 : event.status;\n}\n\n#ifdef KVM_CAP_IRQ_ROUTING\ntypedef struct KVMMSIRoute {\n    struct kvm_irq_routing_entry kroute;\n    QTAILQ_ENTRY(KVMMSIRoute) entry;\n} KVMMSIRoute;\n\nstatic void set_gsi(KVMState *s, unsigned int gsi)\n{\n    set_bit(gsi, s->used_gsi_bitmap);\n}\n\nstatic void clear_gsi(KVMState *s, unsigned int gsi)\n{\n    clear_bit(gsi, s->used_gsi_bitmap);\n}\n\nvoid kvm_init_irq_routing(KVMState *s)\n{\n    int gsi_count, i;\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING) - 1;\n    if (gsi_count > 0) {\n        /* Round up so we can search ints using ffs */\n        s->used_gsi_bitmap = bitmap_new(gsi_count);\n        s->gsi_count = gsi_count;\n    }\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n    s->nr_allocated_irq_routes = 0;\n\n    if (!kvm_direct_msi_allowed) {\n        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {\n            QTAILQ_INIT(&s->msi_hashtab[i]);\n        }\n    }\n\n    kvm_arch_init_irq_routing(s);\n}\n\nvoid kvm_irqchip_commit_routes(KVMState *s)\n{\n    int ret;\n\n    if (kvm_gsi_direct_mapping()) {\n        return;\n    }\n\n    if (!kvm_gsi_routing_enabled()) {\n        return;\n    }\n\n    s->irq_routes->flags = 0;\n    trace_kvm_irqchip_commit_routes();\n    ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);\n    assert(ret == 0);\n}\n\nstatic void kvm_add_routing_entry(KVMState *s,\n                                  struct kvm_irq_routing_entry *entry)\n{\n    struct kvm_irq_routing_entry *new;\n    int n, size;\n\n    if (s->irq_routes->nr == s->nr_allocated_irq_routes) {\n        n = s->nr_allocated_irq_routes * 2;\n        if (n < 64) {\n            n = 64;\n        }\n        size = sizeof(struct kvm_irq_routing);\n        size += n * sizeof(*new);\n        s->irq_routes = g_realloc(s->irq_routes, size);\n        s->nr_allocated_irq_routes = n;\n    }\n    n = s->irq_routes->nr++;\n    new = &s->irq_routes->entries[n];\n\n    *new = *entry;\n\n    set_gsi(s, entry->gsi);\n}\n\nstatic int kvm_update_routing_entry(KVMState *s,\n                                    struct kvm_irq_routing_entry *new_entry)\n{\n    struct kvm_irq_routing_entry *entry;\n    int n;\n\n    for (n = 0; n < s->irq_routes->nr; n++) {\n        entry = &s->irq_routes->entries[n];\n        if (entry->gsi != new_entry->gsi) {\n            continue;\n        }\n\n        if(!memcmp(entry, new_entry, sizeof *entry)) {\n            return 0;\n        }\n\n        *entry = *new_entry;\n\n        return 0;\n    }\n\n    return -ESRCH;\n}\n\nvoid kvm_irqchip_add_irq_route(KVMState *s, int irq, int irqchip, int pin)\n{\n    struct kvm_irq_routing_entry e = {};\n\n    assert(pin < s->gsi_count);\n\n    e.gsi = irq;\n    e.type = KVM_IRQ_ROUTING_IRQCHIP;\n    e.flags = 0;\n    e.u.irqchip.irqchip = irqchip;\n    e.u.irqchip.pin = pin;\n    kvm_add_routing_entry(s, &e);\n}\n\nvoid kvm_irqchip_release_virq(KVMState *s, int virq)\n{\n    struct kvm_irq_routing_entry *e;\n    int i;\n\n    if (kvm_gsi_direct_mapping()) {\n        return;\n    }\n\n    for (i = 0; i < s->irq_routes->nr; i++) {\n        e = &s->irq_routes->entries[i];\n        if (e->gsi == virq) {\n            s->irq_routes->nr--;\n            *e = s->irq_routes->entries[s->irq_routes->nr];\n        }\n    }\n    clear_gsi(s, virq);\n    kvm_arch_release_virq_post(virq);\n}\n\nstatic unsigned int kvm_hash_msi(uint32_t data)\n{\n    /* This is optimized for IA32 MSI layout. However, no other arch shall\n     * repeat the mistake of not providing a direct MSI injection API. */\n    return data & 0xff;\n}\n\nstatic void kvm_flush_dynamic_msi_routes(KVMState *s)\n{\n    KVMMSIRoute *route, *next;\n    unsigned int hash;\n\n    for (hash = 0; hash < KVM_MSI_HASHTAB_SIZE; hash++) {\n        QTAILQ_FOREACH_SAFE(route, &s->msi_hashtab[hash], entry, next) {\n            kvm_irqchip_release_virq(s, route->kroute.gsi);\n            QTAILQ_REMOVE(&s->msi_hashtab[hash], route, entry);\n            g_free(route);\n        }\n    }\n}\n\nstatic int kvm_irqchip_get_virq(KVMState *s)\n{\n    int next_virq;\n\n    /*\n     * PIC and IOAPIC share the first 16 GSI numbers, thus the available\n     * GSI numbers are more than the number of IRQ route. Allocating a GSI\n     * number can succeed even though a new route entry cannot be added.\n     * When this happens, flush dynamic MSI entries to free IRQ route entries.\n     */\n    if (!kvm_direct_msi_allowed && s->irq_routes->nr == s->gsi_count) {\n        kvm_flush_dynamic_msi_routes(s);\n    }\n\n    /* Return the lowest unused GSI in the bitmap */\n    next_virq = find_first_zero_bit(s->used_gsi_bitmap, s->gsi_count);\n    if (next_virq >= s->gsi_count) {\n        return -ENOSPC;\n    } else {\n        return next_virq;\n    }\n}\n\nstatic KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)\n{\n    unsigned int hash = kvm_hash_msi(msg.data);\n    KVMMSIRoute *route;\n\n    QTAILQ_FOREACH(route, &s->msi_hashtab[hash], entry) {\n        if (route->kroute.u.msi.address_lo == (uint32_t)msg.address &&\n            route->kroute.u.msi.address_hi == (msg.address >> 32) &&\n            route->kroute.u.msi.data == le32_to_cpu(msg.data)) {\n            return route;\n        }\n    }\n    return NULL;\n}\n\nint kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)\n{\n    struct kvm_msi msi;\n    KVMMSIRoute *route;\n\n    if (kvm_direct_msi_allowed) {\n        msi.address_lo = (uint32_t)msg.address;\n        msi.address_hi = msg.address >> 32;\n        msi.data = le32_to_cpu(msg.data);\n        msi.flags = 0;\n        memset(msi.pad, 0, sizeof(msi.pad));\n\n        return kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &msi);\n    }\n\n    route = kvm_lookup_msi_route(s, msg);\n    if (!route) {\n        int virq;\n\n        virq = kvm_irqchip_get_virq(s);\n        if (virq < 0) {\n            return virq;\n        }\n\n        route = g_malloc0(sizeof(KVMMSIRoute));\n        route->kroute.gsi = virq;\n        route->kroute.type = KVM_IRQ_ROUTING_MSI;\n        route->kroute.flags = 0;\n        route->kroute.u.msi.address_lo = (uint32_t)msg.address;\n        route->kroute.u.msi.address_hi = msg.address >> 32;\n        route->kroute.u.msi.data = le32_to_cpu(msg.data);\n\n        kvm_add_routing_entry(s, &route->kroute);\n        kvm_irqchip_commit_routes(s);\n\n        QTAILQ_INSERT_TAIL(&s->msi_hashtab[kvm_hash_msi(msg.data)], route,\n                           entry);\n    }\n\n    assert(route->kroute.type == KVM_IRQ_ROUTING_MSI);\n\n    return kvm_set_irq(s, route->kroute.gsi, 1);\n}\n\nint kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)\n{\n    struct kvm_irq_routing_entry kroute = {};\n    int virq;\n    MSIMessage msg = {0, 0};\n\n    if (dev) {\n        msg = pci_get_msi_message(dev, vector);\n    }\n\n    if (kvm_gsi_direct_mapping()) {\n        return kvm_arch_msi_data_to_gsi(msg.data);\n    }\n\n    if (!kvm_gsi_routing_enabled()) {\n        return -ENOSYS;\n    }\n\n    virq = kvm_irqchip_get_virq(s);\n    if (virq < 0) {\n        return virq;\n    }\n\n    kroute.gsi = virq;\n    kroute.type = KVM_IRQ_ROUTING_MSI;\n    kroute.flags = 0;\n    kroute.u.msi.address_lo = (uint32_t)msg.address;\n    kroute.u.msi.address_hi = msg.address >> 32;\n    kroute.u.msi.data = le32_to_cpu(msg.data);\n    if (kvm_msi_devid_required()) {\n        kroute.flags = KVM_MSI_VALID_DEVID;\n        kroute.u.msi.devid = pci_requester_id(dev);\n    }\n    if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {\n        kvm_irqchip_release_virq(s, virq);\n        return -EINVAL;\n    }\n\n    trace_kvm_irqchip_add_msi_route(virq);\n\n    kvm_add_routing_entry(s, &kroute);\n    kvm_arch_add_msi_route_post(&kroute, vector, dev);\n    kvm_irqchip_commit_routes(s);\n\n    return virq;\n}\n\nint kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,\n                                 PCIDevice *dev)\n{\n    struct kvm_irq_routing_entry kroute = {};\n\n    if (kvm_gsi_direct_mapping()) {\n        return 0;\n    }\n\n    if (!kvm_irqchip_in_kernel()) {\n        return -ENOSYS;\n    }\n\n    kroute.gsi = virq;\n    kroute.type = KVM_IRQ_ROUTING_MSI;\n    kroute.flags = 0;\n    kroute.u.msi.address_lo = (uint32_t)msg.address;\n    kroute.u.msi.address_hi = msg.address >> 32;\n    kroute.u.msi.data = le32_to_cpu(msg.data);\n    if (kvm_msi_devid_required()) {\n        kroute.flags = KVM_MSI_VALID_DEVID;\n        kroute.u.msi.devid = pci_requester_id(dev);\n    }\n    if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {\n        return -EINVAL;\n    }\n\n    trace_kvm_irqchip_update_msi_route(virq);\n\n    return kvm_update_routing_entry(s, &kroute);\n}\n\nstatic int kvm_irqchip_assign_irqfd(KVMState *s, int fd, int rfd, int virq,\n                                    bool assign)\n{\n    struct kvm_irqfd irqfd = {\n        .fd = fd,\n        .gsi = virq,\n        .flags = assign ? 0 : KVM_IRQFD_FLAG_DEASSIGN,\n    };\n\n    if (rfd != -1) {\n        irqfd.flags |= KVM_IRQFD_FLAG_RESAMPLE;\n        irqfd.resamplefd = rfd;\n    }\n\n    if (!kvm_irqfds_enabled()) {\n        return -ENOSYS;\n    }\n\n    return kvm_vm_ioctl(s, KVM_IRQFD, &irqfd);\n}\n\nint kvm_irqchip_add_adapter_route(KVMState *s, AdapterInfo *adapter)\n{\n    struct kvm_irq_routing_entry kroute = {};\n    int virq;\n\n    if (!kvm_gsi_routing_enabled()) {\n        return -ENOSYS;\n    }\n\n    virq = kvm_irqchip_get_virq(s);\n    if (virq < 0) {\n        return virq;\n    }\n\n    kroute.gsi = virq;\n    kroute.type = KVM_IRQ_ROUTING_S390_ADAPTER;\n    kroute.flags = 0;\n    kroute.u.adapter.summary_addr = adapter->summary_addr;\n    kroute.u.adapter.ind_addr = adapter->ind_addr;\n    kroute.u.adapter.summary_offset = adapter->summary_offset;\n    kroute.u.adapter.ind_offset = adapter->ind_offset;\n    kroute.u.adapter.adapter_id = adapter->adapter_id;\n\n    kvm_add_routing_entry(s, &kroute);\n\n    return virq;\n}\n\nint kvm_irqchip_add_hv_sint_route(KVMState *s, uint32_t vcpu, uint32_t sint)\n{\n    struct kvm_irq_routing_entry kroute = {};\n    int virq;\n\n    if (!kvm_gsi_routing_enabled()) {\n        return -ENOSYS;\n    }\n    if (!kvm_check_extension(s, KVM_CAP_HYPERV_SYNIC)) {\n        return -ENOSYS;\n    }\n    virq = kvm_irqchip_get_virq(s);\n    if (virq < 0) {\n        return virq;\n    }\n\n    kroute.gsi = virq;\n    kroute.type = KVM_IRQ_ROUTING_HV_SINT;\n    kroute.flags = 0;\n    kroute.u.hv_sint.vcpu = vcpu;\n    kroute.u.hv_sint.sint = sint;\n\n    kvm_add_routing_entry(s, &kroute);\n    kvm_irqchip_commit_routes(s);\n\n    return virq;\n}\n\n#else /* !KVM_CAP_IRQ_ROUTING */\n\nvoid kvm_init_irq_routing(KVMState *s)\n{\n}\n\nvoid kvm_irqchip_release_virq(KVMState *s, int virq)\n{\n}\n\nint kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)\n{\n    abort();\n}\n\nint kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)\n{\n    return -ENOSYS;\n}\n\nint kvm_irqchip_add_adapter_route(KVMState *s, AdapterInfo *adapter)\n{\n    return -ENOSYS;\n}\n\nint kvm_irqchip_add_hv_sint_route(KVMState *s, uint32_t vcpu, uint32_t sint)\n{\n    return -ENOSYS;\n}\n\nstatic int kvm_irqchip_assign_irqfd(KVMState *s, int fd, int virq, bool assign)\n{\n    abort();\n}\n\nint kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg)\n{\n    return -ENOSYS;\n}\n#endif /* !KVM_CAP_IRQ_ROUTING */\n\nint kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,\n                                       EventNotifier *rn, int virq)\n{\n    return kvm_irqchip_assign_irqfd(s, event_notifier_get_fd(n),\n           rn ? event_notifier_get_fd(rn) : -1, virq, true);\n}\n\nint kvm_irqchip_remove_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,\n                                          int virq)\n{\n    return kvm_irqchip_assign_irqfd(s, event_notifier_get_fd(n), -1, virq,\n           false);\n}\n\nint kvm_irqchip_add_irqfd_notifier(KVMState *s, EventNotifier *n,\n                                   EventNotifier *rn, qemu_irq irq)\n{\n    gpointer key, gsi;\n    gboolean found = g_hash_table_lookup_extended(s->gsimap, irq, &key, &gsi);\n\n    if (!found) {\n        return -ENXIO;\n    }\n    return kvm_irqchip_add_irqfd_notifier_gsi(s, n, rn, GPOINTER_TO_INT(gsi));\n}\n\nint kvm_irqchip_remove_irqfd_notifier(KVMState *s, EventNotifier *n,\n                                      qemu_irq irq)\n{\n    gpointer key, gsi;\n    gboolean found = g_hash_table_lookup_extended(s->gsimap, irq, &key, &gsi);\n\n    if (!found) {\n        return -ENXIO;\n    }\n    return kvm_irqchip_remove_irqfd_notifier_gsi(s, n, GPOINTER_TO_INT(gsi));\n}\n\nvoid kvm_irqchip_set_qemuirq_gsi(KVMState *s, qemu_irq irq, int gsi)\n{\n    g_hash_table_insert(s->gsimap, irq, GINT_TO_POINTER(gsi));\n}\n\nstatic void kvm_irqchip_create(MachineState *machine, KVMState *s)\n{\n    int ret;\n\n    if (kvm_check_extension(s, KVM_CAP_IRQCHIP)) {\n        ;\n    } else if (kvm_check_extension(s, KVM_CAP_S390_IRQCHIP)) {\n        ret = kvm_vm_enable_cap(s, KVM_CAP_S390_IRQCHIP, 0);\n        if (ret < 0) {\n            fprintf(stderr, \"Enable kernel irqchip failed: %s\\n\", strerror(-ret));\n            exit(1);\n        }\n    } else {\n        return;\n    }\n\n    /* First probe and see if there's a arch-specific hook to create the\n     * in-kernel irqchip for us */\n    ret = kvm_arch_irqchip_create(machine, s);\n    if (ret == 0) {\n        if (machine_kernel_irqchip_split(machine)) {\n            perror(\"Split IRQ chip mode not supported.\");\n            exit(1);\n        } else {\n            ret = kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP);\n        }\n    }\n    if (ret < 0) {\n        fprintf(stderr, \"Create kernel irqchip failed: %s\\n\", strerror(-ret));\n        exit(1);\n    }\n\n    kvm_kernel_irqchip = true;\n    /* If we have an in-kernel IRQ chip then we must have asynchronous\n     * interrupt delivery (though the reverse is not necessarily true)\n     */\n    kvm_async_interrupts_allowed = true;\n    kvm_halt_in_kernel_allowed = true;\n\n    kvm_init_irq_routing(s);\n\n    s->gsimap = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n\n/* Find number of supported CPUs using the recommended\n * procedure from the kernel API documentation to cope with\n * older kernels that may be missing capabilities.\n */\nstatic int kvm_recommended_vcpus(KVMState *s)\n{\n    int ret = kvm_check_extension(s, KVM_CAP_NR_VCPUS);\n    return (ret) ? ret : 4;\n}\n\nstatic int kvm_max_vcpus(KVMState *s)\n{\n    int ret = kvm_check_extension(s, KVM_CAP_MAX_VCPUS);\n    return (ret) ? ret : kvm_recommended_vcpus(s);\n}\n\nstatic int kvm_max_vcpu_id(KVMState *s)\n{\n    int ret = kvm_check_extension(s, KVM_CAP_MAX_VCPU_ID);\n    return (ret) ? ret : kvm_max_vcpus(s);\n}\n\nbool kvm_vcpu_id_is_valid(int vcpu_id)\n{\n    KVMState *s = KVM_STATE(current_machine->accelerator);\n    return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);\n}\n\nstatic int kvm_init(MachineState *ms)\n{\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n    static const char upgrade_note[] =\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n    struct {\n        const char *name;\n        int num;\n    } num_cpus[] = {\n        { \"SMP\",          smp_cpus },\n        { \"hotpluggable\", max_cpus },\n        { NULL, }\n    }, *nc = num_cpus;\n    int soft_vcpus_limit, hard_vcpus_limit;\n    KVMState *s;\n    const KVMCapabilityInfo *missing_cap;\n    int ret;\n    int type = 0;\n    const char *kvm_type;\n\n    s = KVM_STATE(ms->accelerator);\n\n    /*\n     * On systems where the kernel can support different base page\n     * sizes, host page size may be different from TARGET_PAGE_SIZE,\n     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum\n     * page size for the system though.\n     */\n    assert(TARGET_PAGE_SIZE <= getpagesize());\n\n    s->sigmask_len = 8;\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n#endif\n    QLIST_INIT(&s->kvm_parked_vcpus);\n    s->vmfd = -1;\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n        if (ret >= 0) {\n            ret = -EINVAL;\n        }\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n\n    kvm_immediate_exit = kvm_check_extension(s, KVM_CAP_IMMEDIATE_EXIT);\n    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);\n\n    /* If unspecified, use the default value */\n    if (!s->nr_slots) {\n        s->nr_slots = 32;\n    }\n\n    /* check the vcpu limits */\n    soft_vcpus_limit = kvm_recommended_vcpus(s);\n    hard_vcpus_limit = kvm_max_vcpus(s);\n\n    while (nc->name) {\n        if (nc->num > soft_vcpus_limit) {\n            fprintf(stderr,\n                    \"Warning: Number of %s cpus requested (%d) exceeds \"\n                    \"the recommended cpus supported by KVM (%d)\\n\",\n                    nc->name, nc->num, soft_vcpus_limit);\n\n            if (nc->num > hard_vcpus_limit) {\n                fprintf(stderr, \"Number of %s cpus requested (%d) exceeds \"\n                        \"the maximum cpus supported by KVM (%d)\\n\",\n                        nc->name, nc->num, hard_vcpus_limit);\n                exit(1);\n            }\n        }\n        nc++;\n    }\n\n    kvm_type = qemu_opt_get(qemu_get_machine_opts(), \"kvm-type\");\n    if (mc->kvm_type) {\n        type = mc->kvm_type(kvm_type);\n    } else if (kvm_type) {\n        ret = -EINVAL;\n        fprintf(stderr, \"Invalid argument kvm-type=%s\\n\", kvm_type);\n        goto err;\n    }\n\n    do {\n        ret = kvm_ioctl(s, KVM_CREATE_VM, type);\n    } while (ret == -EINTR);\n\n    if (ret < 0) {\n        fprintf(stderr, \"ioctl(KVM_CREATE_VM) failed: %d %s\\n\", -ret,\n                strerror(-ret));\n\n#ifdef TARGET_S390X\n        if (ret == -EINVAL) {\n            fprintf(stderr,\n                    \"Host kernel setup problem detected. Please verify:\\n\");\n            fprintf(stderr, \"- for kernels supporting the switch_amode or\"\n                    \" user_mode parameters, whether\\n\");\n            fprintf(stderr,\n                    \"  user space is running in primary address space\\n\");\n            fprintf(stderr,\n                    \"- for kernels supporting the vm.allocate_pgste sysctl, \"\n                    \"whether it is enabled\\n\");\n        }\n#endif\n        goto err;\n    }\n\n    s->vmfd = ret;\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n    if (!missing_cap) {\n        missing_cap =\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n    }\n    if (missing_cap) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n                missing_cap->name, upgrade_note);\n        goto err;\n    }\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n    s->broken_set_mem_region = 1;\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n    if (ret > 0) {\n        s->broken_set_mem_region = 0;\n    }\n\n#ifdef KVM_CAP_VCPU_EVENTS\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n#endif\n\n    s->robust_singlestep =\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n#ifdef KVM_CAP_DEBUGREGS\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n#endif\n\n#ifdef KVM_CAP_IRQ_ROUTING\n    kvm_direct_msi_allowed = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);\n#endif\n\n    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);\n\n    s->irq_set_ioctl = KVM_IRQ_LINE;\n    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {\n        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;\n    }\n\n#ifdef KVM_CAP_READONLY_MEM\n    kvm_readonly_mem_allowed =\n        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);\n#endif\n\n    kvm_eventfds_allowed =\n        (kvm_check_extension(s, KVM_CAP_IOEVENTFD) > 0);\n\n    kvm_irqfds_allowed =\n        (kvm_check_extension(s, KVM_CAP_IRQFD) > 0);\n\n    kvm_resamplefds_allowed =\n        (kvm_check_extension(s, KVM_CAP_IRQFD_RESAMPLE) > 0);\n\n    kvm_vm_attributes_allowed =\n        (kvm_check_extension(s, KVM_CAP_VM_ATTRIBUTES) > 0);\n\n    kvm_ioeventfd_any_length_allowed =\n        (kvm_check_extension(s, KVM_CAP_IOEVENTFD_ANY_LENGTH) > 0);\n\n    ret = kvm_arch_init(ms, s);\n    if (ret < 0) {\n        goto err;\n    }\n\n    if (machine_kernel_irqchip_allowed(ms)) {\n        kvm_irqchip_create(ms, s);\n    }\n\n    kvm_state = s;\n\n    if (kvm_eventfds_allowed) {\n        s->memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add;\n        s->memory_listener.listener.eventfd_del = kvm_mem_ioeventfd_del;\n    }\n    s->memory_listener.listener.coalesced_mmio_add = kvm_coalesce_mmio_region;\n    s->memory_listener.listener.coalesced_mmio_del = kvm_uncoalesce_mmio_region;\n\n    kvm_memory_listener_register(s, &s->memory_listener,\n                                 &address_space_memory, 0);\n    memory_listener_register(&kvm_io_listener,\n                             &address_space_io);\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n    return 0;\n\nerr:\n    assert(ret < 0);\n    if (s->vmfd >= 0) {\n        close(s->vmfd);\n    }\n    if (s->fd != -1) {\n        close(s->fd);\n    }\n    g_free(s->memory_listener.slots);\n\n    return ret;\n}\n\nvoid kvm_set_sigmask_len(KVMState *s, unsigned int sigmask_len)\n{\n    s->sigmask_len = sigmask_len;\n}\n\nstatic void kvm_handle_io(uint16_t port, MemTxAttrs attrs, void *data, int direction,\n                          int size, uint32_t count)\n{\n    int i;\n    uint8_t *ptr = data;\n\n    for (i = 0; i < count; i++) {\n        address_space_rw(&address_space_io, port, attrs,\n                         ptr, size,\n                         direction == KVM_EXIT_IO_OUT);\n        ptr += size;\n    }\n}\n\nstatic int kvm_handle_internal_error(CPUState *cpu, struct kvm_run *run)\n{\n    fprintf(stderr, \"KVM internal error. Suberror: %d\\n\",\n            run->internal.suberror);\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_INTERNAL_ERROR_DATA)) {\n        int i;\n\n        for (i = 0; i < run->internal.ndata; ++i) {\n            fprintf(stderr, \"extra data[%d]: %\"PRIx64\"\\n\",\n                    i, (uint64_t)run->internal.data[i]);\n        }\n    }\n    if (run->internal.suberror == KVM_INTERNAL_ERROR_EMULATION) {\n        fprintf(stderr, \"emulation failure\\n\");\n        if (!kvm_arch_stop_on_emulation_error(cpu)) {\n            cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);\n            return EXCP_INTERRUPT;\n        }\n    }\n    /* FIXME: Should trigger a qmp message to let management know\n     * something went wrong.\n     */\n    return -1;\n}\n\nvoid kvm_flush_coalesced_mmio_buffer(void)\n{\n    KVMState *s = kvm_state;\n\n    if (s->coalesced_flush_in_progress) {\n        return;\n    }\n\n    s->coalesced_flush_in_progress = true;\n\n    if (s->coalesced_mmio_ring) {\n        struct kvm_coalesced_mmio_ring *ring = s->coalesced_mmio_ring;\n        while (ring->first != ring->last) {\n            struct kvm_coalesced_mmio *ent;\n\n            ent = &ring->coalesced_mmio[ring->first];\n\n            cpu_physical_memory_write(ent->phys_addr, ent->data, ent->len);\n            smp_wmb();\n            ring->first = (ring->first + 1) % KVM_COALESCED_MMIO_MAX;\n        }\n    }\n\n    s->coalesced_flush_in_progress = false;\n}\n\nstatic void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)\n{\n    if (!cpu->kvm_vcpu_dirty) {\n        kvm_arch_get_registers(cpu);\n        cpu->kvm_vcpu_dirty = true;\n    }\n}\n\nvoid kvm_cpu_synchronize_state(CPUState *cpu)\n{\n    if (!cpu->kvm_vcpu_dirty) {\n        run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);\n    }\n}\n\nstatic void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)\n{\n    kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);\n    cpu->kvm_vcpu_dirty = false;\n}\n\nvoid kvm_cpu_synchronize_post_reset(CPUState *cpu)\n{\n    run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);\n}\n\nstatic void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)\n{\n    kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);\n    cpu->kvm_vcpu_dirty = false;\n}\n\nvoid kvm_cpu_synchronize_post_init(CPUState *cpu)\n{\n    run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);\n}\n\n#ifdef KVM_HAVE_MCE_INJECTION\nstatic __thread void *pending_sigbus_addr;\nstatic __thread int pending_sigbus_code;\nstatic __thread bool have_sigbus_pending;\n#endif\n\nstatic void kvm_cpu_kick(CPUState *cpu)\n{\n    atomic_set(&cpu->kvm_run->immediate_exit, 1);\n}\n\nstatic void kvm_cpu_kick_self(void)\n{\n    if (kvm_immediate_exit) {\n        kvm_cpu_kick(current_cpu);\n    } else {\n        qemu_cpu_kick_self();\n    }\n}\n\nstatic void kvm_eat_signals(CPUState *cpu)\n{\n    struct timespec ts = { 0, 0 };\n    siginfo_t siginfo;\n    sigset_t waitset;\n    sigset_t chkset;\n    int r;\n\n    if (kvm_immediate_exit) {\n        atomic_set(&cpu->kvm_run->immediate_exit, 0);\n        /* Write kvm_run->immediate_exit before the cpu->exit_request\n         * write in kvm_cpu_exec.\n         */\n        smp_wmb();\n        return;\n    }\n\n    sigemptyset(&waitset);\n    sigaddset(&waitset, SIG_IPI);\n\n    do {\n        r = sigtimedwait(&waitset, &siginfo, &ts);\n        if (r == -1 && !(errno == EAGAIN || errno == EINTR)) {\n            perror(\"sigtimedwait\");\n            exit(1);\n        }\n\n        r = sigpending(&chkset);\n        if (r == -1) {\n            perror(\"sigpending\");\n            exit(1);\n        }\n    } while (sigismember(&chkset, SIG_IPI));\n}\n\nint kvm_cpu_exec(CPUState *cpu)\n{\n    struct kvm_run *run = cpu->kvm_run;\n    int ret, run_ret;\n\n    DPRINTF(\"kvm_cpu_exec()\\n\");\n\n    if (kvm_arch_process_async_events(cpu)) {\n        atomic_set(&cpu->exit_request, 0);\n        return EXCP_HLT;\n    }\n\n    qemu_mutex_unlock_iothread();\n\n    do {\n        MemTxAttrs attrs;\n\n        if (cpu->kvm_vcpu_dirty) {\n            kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);\n            cpu->kvm_vcpu_dirty = false;\n        }\n\n        kvm_arch_pre_run(cpu, run);\n        if (atomic_read(&cpu->exit_request)) {\n            DPRINTF(\"interrupt exit requested\\n\");\n            /*\n             * KVM requires us to reenter the kernel after IO exits to complete\n             * instruction emulation. This self-signal will ensure that we\n             * leave ASAP again.\n             */\n            kvm_cpu_kick_self();\n        }\n\n        /* Read cpu->exit_request before KVM_RUN reads run->immediate_exit.\n         * Matching barrier in kvm_eat_signals.\n         */\n        smp_rmb();\n\n        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);\n\n        attrs = kvm_arch_post_run(cpu, run);\n\n#ifdef KVM_HAVE_MCE_INJECTION\n        if (unlikely(have_sigbus_pending)) {\n            qemu_mutex_lock_iothread();\n            kvm_arch_on_sigbus_vcpu(cpu, pending_sigbus_code,\n                                    pending_sigbus_addr);\n            have_sigbus_pending = false;\n            qemu_mutex_unlock_iothread();\n        }\n#endif\n\n        if (run_ret < 0) {\n            if (run_ret == -EINTR || run_ret == -EAGAIN) {\n                DPRINTF(\"io window exit\\n\");\n                kvm_eat_signals(cpu);\n                ret = EXCP_INTERRUPT;\n                break;\n            }\n            fprintf(stderr, \"error: kvm run failed %s\\n\",\n                    strerror(-run_ret));\n#ifdef TARGET_PPC\n            if (run_ret == -EBUSY) {\n                fprintf(stderr,\n                        \"This is probably because your SMT is enabled.\\n\"\n                        \"VCPU can only run on primary threads with all \"\n                        \"secondary threads offline.\\n\");\n            }\n#endif\n            ret = -1;\n            break;\n        }\n\n        trace_kvm_run_exit(cpu->cpu_index, run->exit_reason);\n        switch (run->exit_reason) {\n        case KVM_EXIT_IO:\n            DPRINTF(\"handle_io\\n\");\n            /* Called outside BQL */\n            kvm_handle_io(run->io.port, attrs,\n                          (uint8_t *)run + run->io.data_offset,\n                          run->io.direction,\n                          run->io.size,\n                          run->io.count);\n            ret = 0;\n            break;\n        case KVM_EXIT_MMIO:\n            DPRINTF(\"handle_mmio\\n\");\n            /* Called outside BQL */\n            address_space_rw(&address_space_memory,\n                             run->mmio.phys_addr, attrs,\n                             run->mmio.data,\n                             run->mmio.len,\n                             run->mmio.is_write);\n            ret = 0;\n            break;\n        case KVM_EXIT_IRQ_WINDOW_OPEN:\n            DPRINTF(\"irq_window_open\\n\");\n            ret = EXCP_INTERRUPT;\n            break;\n        case KVM_EXIT_SHUTDOWN:\n            DPRINTF(\"shutdown\\n\");\n            qemu_system_reset_request();\n            ret = EXCP_INTERRUPT;\n            break;\n        case KVM_EXIT_UNKNOWN:\n            fprintf(stderr, \"KVM: unknown exit, hardware reason %\" PRIx64 \"\\n\",\n                    (uint64_t)run->hw.hardware_exit_reason);\n            ret = -1;\n            break;\n        case KVM_EXIT_INTERNAL_ERROR:\n            ret = kvm_handle_internal_error(cpu, run);\n            break;\n        case KVM_EXIT_SYSTEM_EVENT:\n            switch (run->system_event.type) {\n            case KVM_SYSTEM_EVENT_SHUTDOWN:\n                qemu_system_shutdown_request();\n                ret = EXCP_INTERRUPT;\n                break;\n            case KVM_SYSTEM_EVENT_RESET:\n                qemu_system_reset_request();\n                ret = EXCP_INTERRUPT;\n                break;\n            case KVM_SYSTEM_EVENT_CRASH:\n                kvm_cpu_synchronize_state(cpu);\n                qemu_mutex_lock_iothread();\n                qemu_system_guest_panicked(cpu_get_crash_info(cpu));\n                qemu_mutex_unlock_iothread();\n                ret = 0;\n                break;\n            default:\n                DPRINTF(\"kvm_arch_handle_exit\\n\");\n                ret = kvm_arch_handle_exit(cpu, run);\n                break;\n            }\n            break;\n        default:\n            DPRINTF(\"kvm_arch_handle_exit\\n\");\n            ret = kvm_arch_handle_exit(cpu, run);\n            break;\n        }\n    } while (ret == 0);\n\n    qemu_mutex_lock_iothread();\n\n    if (ret < 0) {\n        cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);\n        vm_stop(RUN_STATE_INTERNAL_ERROR);\n    }\n\n    atomic_set(&cpu->exit_request, 0);\n    return ret;\n}\n\nint kvm_ioctl(KVMState *s, int type, ...)\n{\n    int ret;\n    void *arg;\n    va_list ap;\n\n    va_start(ap, type);\n    arg = va_arg(ap, void *);\n    va_end(ap);\n\n    trace_kvm_ioctl(type, arg);\n    ret = ioctl(s->fd, type, arg);\n    if (ret == -1) {\n        ret = -errno;\n    }\n    return ret;\n}\n\nint kvm_vm_ioctl(KVMState *s, int type, ...)\n{\n    int ret;\n    void *arg;\n    va_list ap;\n\n    va_start(ap, type);\n    arg = va_arg(ap, void *);\n    va_end(ap);\n\n    trace_kvm_vm_ioctl(type, arg);\n    ret = ioctl(s->vmfd, type, arg);\n    if (ret == -1) {\n        ret = -errno;\n    }\n    return ret;\n}\n\nint kvm_vcpu_ioctl(CPUState *cpu, int type, ...)\n{\n    int ret;\n    void *arg;\n    va_list ap;\n\n    va_start(ap, type);\n    arg = va_arg(ap, void *);\n    va_end(ap);\n\n    trace_kvm_vcpu_ioctl(cpu->cpu_index, type, arg);\n    ret = ioctl(cpu->kvm_fd, type, arg);\n    if (ret == -1) {\n        ret = -errno;\n    }\n    return ret;\n}\n\nint kvm_device_ioctl(int fd, int type, ...)\n{\n    int ret;\n    void *arg;\n    va_list ap;\n\n    va_start(ap, type);\n    arg = va_arg(ap, void *);\n    va_end(ap);\n\n    trace_kvm_device_ioctl(fd, type, arg);\n    ret = ioctl(fd, type, arg);\n    if (ret == -1) {\n        ret = -errno;\n    }\n    return ret;\n}\n\nint kvm_vm_check_attr(KVMState *s, uint32_t group, uint64_t attr)\n{\n    int ret;\n    struct kvm_device_attr attribute = {\n        .group = group,\n        .attr = attr,\n    };\n\n    if (!kvm_vm_attributes_allowed) {\n        return 0;\n    }\n\n    ret = kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attribute);\n    /* kvm returns 0 on success for HAS_DEVICE_ATTR */\n    return ret ? 0 : 1;\n}\n\nint kvm_device_check_attr(int dev_fd, uint32_t group, uint64_t attr)\n{\n    struct kvm_device_attr attribute = {\n        .group = group,\n        .attr = attr,\n        .flags = 0,\n    };\n\n    return kvm_device_ioctl(dev_fd, KVM_HAS_DEVICE_ATTR, &attribute) ? 0 : 1;\n}\n\nvoid kvm_device_access(int fd, int group, uint64_t attr,\n                       void *val, bool write)\n{\n    struct kvm_device_attr kvmattr;\n    int err;\n\n    kvmattr.flags = 0;\n    kvmattr.group = group;\n    kvmattr.attr = attr;\n    kvmattr.addr = (uintptr_t)val;\n\n    err = kvm_device_ioctl(fd,\n                           write ? KVM_SET_DEVICE_ATTR : KVM_GET_DEVICE_ATTR,\n                           &kvmattr);\n    if (err < 0) {\n        error_report(\"KVM_%s_DEVICE_ATTR failed: %s\",\n                     write ? \"SET\" : \"GET\", strerror(-err));\n        error_printf(\"Group %d attr 0x%016\" PRIx64 \"\\n\", group, attr);\n        abort();\n    }\n}\n\n/* Return 1 on success, 0 on failure */\nint kvm_has_sync_mmu(void)\n{\n    return kvm_check_extension(kvm_state, KVM_CAP_SYNC_MMU);\n}\n\nint kvm_has_vcpu_events(void)\n{\n    return kvm_state->vcpu_events;\n}\n\nint kvm_has_robust_singlestep(void)\n{\n    return kvm_state->robust_singlestep;\n}\n\nint kvm_has_debugregs(void)\n{\n    return kvm_state->debugregs;\n}\n\nint kvm_has_many_ioeventfds(void)\n{\n    if (!kvm_enabled()) {\n        return 0;\n    }\n    return kvm_state->many_ioeventfds;\n}\n\nint kvm_has_gsi_routing(void)\n{\n#ifdef KVM_CAP_IRQ_ROUTING\n    return kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING);\n#else\n    return false;\n#endif\n}\n\nint kvm_has_intx_set_mask(void)\n{\n    return kvm_state->intx_set_mask;\n}\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\nstruct kvm_sw_breakpoint *kvm_find_sw_breakpoint(CPUState *cpu,\n                                                 target_ulong pc)\n{\n    struct kvm_sw_breakpoint *bp;\n\n    QTAILQ_FOREACH(bp, &cpu->kvm_state->kvm_sw_breakpoints, entry) {\n        if (bp->pc == pc) {\n            return bp;\n        }\n    }\n    return NULL;\n}\n\nint kvm_sw_breakpoints_active(CPUState *cpu)\n{\n    return !QTAILQ_EMPTY(&cpu->kvm_state->kvm_sw_breakpoints);\n}\n\nstruct kvm_set_guest_debug_data {\n    struct kvm_guest_debug dbg;\n    int err;\n};\n\nstatic void kvm_invoke_set_guest_debug(CPUState *cpu, run_on_cpu_data data)\n{\n    struct kvm_set_guest_debug_data *dbg_data =\n        (struct kvm_set_guest_debug_data *) data.host_ptr;\n\n    dbg_data->err = kvm_vcpu_ioctl(cpu, KVM_SET_GUEST_DEBUG,\n                                   &dbg_data->dbg);\n}\n\nint kvm_update_guest_debug(CPUState *cpu, unsigned long reinject_trap)\n{\n    struct kvm_set_guest_debug_data data;\n\n    data.dbg.control = reinject_trap;\n\n    if (cpu->singlestep_enabled) {\n        data.dbg.control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP;\n    }\n    kvm_arch_update_guest_debug(cpu, &data.dbg);\n\n    run_on_cpu(cpu, kvm_invoke_set_guest_debug,\n               RUN_ON_CPU_HOST_PTR(&data));\n    return data.err;\n}\n\nint kvm_insert_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    struct kvm_sw_breakpoint *bp;\n    int err;\n\n    if (type == GDB_BREAKPOINT_SW) {\n        bp = kvm_find_sw_breakpoint(cpu, addr);\n        if (bp) {\n            bp->use_count++;\n            return 0;\n        }\n\n        bp = g_malloc(sizeof(struct kvm_sw_breakpoint));\n        bp->pc = addr;\n        bp->use_count = 1;\n        err = kvm_arch_insert_sw_breakpoint(cpu, bp);\n        if (err) {\n            g_free(bp);\n            return err;\n        }\n\n        QTAILQ_INSERT_HEAD(&cpu->kvm_state->kvm_sw_breakpoints, bp, entry);\n    } else {\n        err = kvm_arch_insert_hw_breakpoint(addr, len, type);\n        if (err) {\n            return err;\n        }\n    }\n\n    CPU_FOREACH(cpu) {\n        err = kvm_update_guest_debug(cpu, 0);\n        if (err) {\n            return err;\n        }\n    }\n    return 0;\n}\n\nint kvm_remove_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    struct kvm_sw_breakpoint *bp;\n    int err;\n\n    if (type == GDB_BREAKPOINT_SW) {\n        bp = kvm_find_sw_breakpoint(cpu, addr);\n        if (!bp) {\n            return -ENOENT;\n        }\n\n        if (bp->use_count > 1) {\n            bp->use_count--;\n            return 0;\n        }\n\n        err = kvm_arch_remove_sw_breakpoint(cpu, bp);\n        if (err) {\n            return err;\n        }\n\n        QTAILQ_REMOVE(&cpu->kvm_state->kvm_sw_breakpoints, bp, entry);\n        g_free(bp);\n    } else {\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n        if (err) {\n            return err;\n        }\n    }\n\n    CPU_FOREACH(cpu) {\n        err = kvm_update_guest_debug(cpu, 0);\n        if (err) {\n            return err;\n        }\n    }\n    return 0;\n}\n\nvoid kvm_remove_all_breakpoints(CPUState *cpu)\n{\n    struct kvm_sw_breakpoint *bp, *next;\n    KVMState *s = cpu->kvm_state;\n    CPUState *tmpcpu;\n\n    QTAILQ_FOREACH_SAFE(bp, &s->kvm_sw_breakpoints, entry, next) {\n        if (kvm_arch_remove_sw_breakpoint(cpu, bp) != 0) {\n            /* Try harder to find a CPU that currently sees the breakpoint. */\n            CPU_FOREACH(tmpcpu) {\n                if (kvm_arch_remove_sw_breakpoint(tmpcpu, bp) == 0) {\n                    break;\n                }\n            }\n        }\n        QTAILQ_REMOVE(&s->kvm_sw_breakpoints, bp, entry);\n        g_free(bp);\n    }\n    kvm_arch_remove_all_hw_breakpoints();\n\n    CPU_FOREACH(cpu) {\n        kvm_update_guest_debug(cpu, 0);\n    }\n}\n\n#else /* !KVM_CAP_SET_GUEST_DEBUG */\n\nint kvm_update_guest_debug(CPUState *cpu, unsigned long reinject_trap)\n{\n    return -EINVAL;\n}\n\nint kvm_insert_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    return -EINVAL;\n}\n\nint kvm_remove_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    return -EINVAL;\n}\n\nvoid kvm_remove_all_breakpoints(CPUState *cpu)\n{\n}\n#endif /* !KVM_CAP_SET_GUEST_DEBUG */\n\nstatic int kvm_set_signal_mask(CPUState *cpu, const sigset_t *sigset)\n{\n    KVMState *s = kvm_state;\n    struct kvm_signal_mask *sigmask;\n    int r;\n\n    sigmask = g_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n    sigmask->len = s->sigmask_len;\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n    r = kvm_vcpu_ioctl(cpu, KVM_SET_SIGNAL_MASK, sigmask);\n    g_free(sigmask);\n\n    return r;\n}\n\nstatic void kvm_ipi_signal(int sig)\n{\n    if (current_cpu) {\n        assert(kvm_immediate_exit);\n        kvm_cpu_kick(current_cpu);\n    }\n}\n\nvoid kvm_init_cpu_signals(CPUState *cpu)\n{\n    int r;\n    sigset_t set;\n    struct sigaction sigact;\n\n    memset(&sigact, 0, sizeof(sigact));\n    sigact.sa_handler = kvm_ipi_signal;\n    sigaction(SIG_IPI, &sigact, NULL);\n\n    pthread_sigmask(SIG_BLOCK, NULL, &set);\n#if defined KVM_HAVE_MCE_INJECTION\n    sigdelset(&set, SIGBUS);\n    pthread_sigmask(SIG_SETMASK, &set, NULL);\n#endif\n    sigdelset(&set, SIG_IPI);\n    if (kvm_immediate_exit) {\n        r = pthread_sigmask(SIG_SETMASK, &set, NULL);\n    } else {\n        r = kvm_set_signal_mask(cpu, &set);\n    }\n    if (r) {\n        fprintf(stderr, \"kvm_set_signal_mask: %s\\n\", strerror(-r));\n        exit(1);\n    }\n}\n\n/* Called asynchronously in VCPU thread.  */\nint kvm_on_sigbus_vcpu(CPUState *cpu, int code, void *addr)\n{\n#ifdef KVM_HAVE_MCE_INJECTION\n    if (have_sigbus_pending) {\n        return 1;\n    }\n    have_sigbus_pending = true;\n    pending_sigbus_addr = addr;\n    pending_sigbus_code = code;\n    atomic_set(&cpu->exit_request, 1);\n    return 0;\n#else\n    return 1;\n#endif\n}\n\n/* Called synchronously (via signalfd) in main thread.  */\nint kvm_on_sigbus(int code, void *addr)\n{\n#ifdef KVM_HAVE_MCE_INJECTION\n    /* Action required MCE kills the process if SIGBUS is blocked.  Because\n     * that's what happens in the I/O thread, where we handle MCE via signalfd,\n     * we can only get action optional here.\n     */\n    assert(code != BUS_MCEERR_AR);\n    kvm_arch_on_sigbus_vcpu(first_cpu, code, addr);\n    return 0;\n#else\n    return 1;\n#endif\n}\n\nint kvm_create_device(KVMState *s, uint64_t type, bool test)\n{\n    int ret;\n    struct kvm_create_device create_dev;\n\n    create_dev.type = type;\n    create_dev.fd = -1;\n    create_dev.flags = test ? KVM_CREATE_DEVICE_TEST : 0;\n\n    if (!kvm_check_extension(s, KVM_CAP_DEVICE_CTRL)) {\n        return -ENOTSUP;\n    }\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_DEVICE, &create_dev);\n    if (ret) {\n        return ret;\n    }\n\n    return test ? 0 : create_dev.fd;\n}\n\nbool kvm_device_supported(int vmfd, uint64_t type)\n{\n    struct kvm_create_device create_dev = {\n        .type = type,\n        .fd = -1,\n        .flags = KVM_CREATE_DEVICE_TEST,\n    };\n\n    if (ioctl(vmfd, KVM_CHECK_EXTENSION, KVM_CAP_DEVICE_CTRL) <= 0) {\n        return false;\n    }\n\n    return (ioctl(vmfd, KVM_CREATE_DEVICE, &create_dev) >= 0);\n}\n\nint kvm_set_one_reg(CPUState *cs, uint64_t id, void *source)\n{\n    struct kvm_one_reg reg;\n    int r;\n\n    reg.id = id;\n    reg.addr = (uintptr_t) source;\n    r = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n    if (r) {\n        trace_kvm_failed_reg_set(id, strerror(-r));\n    }\n    return r;\n}\n\nint kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)\n{\n    struct kvm_one_reg reg;\n    int r;\n\n    reg.id = id;\n    reg.addr = (uintptr_t) target;\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n    if (r) {\n        trace_kvm_failed_reg_get(id, strerror(-r));\n    }\n    return r;\n}\n\nstatic void kvm_accel_class_init(ObjectClass *oc, void *data)\n{\n    AccelClass *ac = ACCEL_CLASS(oc);\n    ac->name = \"KVM\";\n    ac->init_machine = kvm_init;\n    ac->allowed = &kvm_allowed;\n}\n\nstatic const TypeInfo kvm_accel_type = {\n    .name = TYPE_KVM_ACCEL,\n    .parent = TYPE_ACCEL,\n    .class_init = kvm_accel_class_init,\n    .instance_size = sizeof(KVMState),\n};\n\nstatic void kvm_type_init(void)\n{\n    type_register_static(&kvm_accel_type);\n}\n\ntype_init(kvm_type_init);\n"
        },
        {
          "name": "kvm-stub.c",
          "type": "blob",
          "size": 2.6953125,
          "content": "/*\n * QEMU KVM stub\n *\n * Copyright Red Hat, Inc. 2010\n *\n * Author: Paolo Bonzini     <pbonzini@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"sysemu/kvm.h\"\n\n#ifndef CONFIG_USER_ONLY\n#include \"hw/pci/msi.h\"\n#endif\n\nKVMState *kvm_state;\nbool kvm_kernel_irqchip;\nbool kvm_async_interrupts_allowed;\nbool kvm_eventfds_allowed;\nbool kvm_irqfds_allowed;\nbool kvm_resamplefds_allowed;\nbool kvm_msi_via_irqfd_allowed;\nbool kvm_gsi_routing_allowed;\nbool kvm_gsi_direct_mapping;\nbool kvm_allowed;\nbool kvm_readonly_mem_allowed;\nbool kvm_ioeventfd_any_length_allowed;\nbool kvm_msi_use_devid;\n\nint kvm_destroy_vcpu(CPUState *cpu)\n{\n    return -ENOSYS;\n}\n\nint kvm_init_vcpu(CPUState *cpu)\n{\n    return -ENOSYS;\n}\n\nvoid kvm_flush_coalesced_mmio_buffer(void)\n{\n}\n\nvoid kvm_cpu_synchronize_state(CPUState *cpu)\n{\n}\n\nvoid kvm_cpu_synchronize_post_reset(CPUState *cpu)\n{\n}\n\nvoid kvm_cpu_synchronize_post_init(CPUState *cpu)\n{\n}\n\nint kvm_cpu_exec(CPUState *cpu)\n{\n    abort();\n}\n\nint kvm_has_sync_mmu(void)\n{\n    return 0;\n}\n\nint kvm_has_many_ioeventfds(void)\n{\n    return 0;\n}\n\nint kvm_update_guest_debug(CPUState *cpu, unsigned long reinject_trap)\n{\n    return -ENOSYS;\n}\n\nint kvm_insert_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    return -EINVAL;\n}\n\nint kvm_remove_breakpoint(CPUState *cpu, target_ulong addr,\n                          target_ulong len, int type)\n{\n    return -EINVAL;\n}\n\nvoid kvm_remove_all_breakpoints(CPUState *cpu)\n{\n}\n\nint kvm_on_sigbus_vcpu(CPUState *cpu, int code, void *addr)\n{\n    return 1;\n}\n\nint kvm_on_sigbus(int code, void *addr)\n{\n    return 1;\n}\n\n#ifndef CONFIG_USER_ONLY\nint kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)\n{\n    return -ENOSYS;\n}\n\nvoid kvm_init_irq_routing(KVMState *s)\n{\n}\n\nvoid kvm_irqchip_release_virq(KVMState *s, int virq)\n{\n}\n\nint kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,\n                                 PCIDevice *dev)\n{\n    return -ENOSYS;\n}\n\nvoid kvm_irqchip_commit_routes(KVMState *s)\n{\n}\n\nint kvm_irqchip_add_adapter_route(KVMState *s, AdapterInfo *adapter)\n{\n    return -ENOSYS;\n}\n\nint kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,\n                                       EventNotifier *rn, int virq)\n{\n    return -ENOSYS;\n}\n\nint kvm_irqchip_remove_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,\n                                          int virq)\n{\n    return -ENOSYS;\n}\n\nbool kvm_has_free_slot(MachineState *ms)\n{\n    return false;\n}\n\nvoid kvm_init_cpu_signals(CPUState *cpu)\n{\n    abort();\n}\n#endif\n"
        },
        {
          "name": "libdecnumber",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux-headers",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux-user",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 0.1162109375,
          "content": "#include \"vl.h\"\n\nint main(int argc, char **argv, char **envp) {\n    return main_aux(argc, argv, envp, PANDA_NORMAL);\n}\n"
        },
        {
          "name": "memory.c",
          "type": "blob",
          "size": 85.1474609375,
          "content": "/*\n * Physical memory management\n *\n * Copyright 2011 Red Hat, Inc. and/or its affiliates\n *\n * Authors:\n *  Avi Kivity <avi@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n#include \"exec/ioport.h\"\n#include \"qapi/visitor.h\"\n#include \"qemu/bitops.h\"\n#include \"qemu/error-report.h\"\n#include \"qom/object.h\"\n#include \"trace-root.h\"\n\n#include \"exec/memory-internal.h\"\n#include \"exec/ram_addr.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/sysemu.h\"\n\n#include \"panda/rr/rr_log_all.h\"\n#include \"panda/callbacks/cb-support.h\"\n\n// less annoying than importing all common.h\nextern target_ulong panda_current_pc(CPUState *cpu);\n\nstatic unsigned memory_region_transaction_depth;\nstatic bool memory_region_update_pending;\nstatic bool ioeventfd_update_pending;\nstatic bool global_dirty_log = false;\n\nstatic QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners\n    = QTAILQ_HEAD_INITIALIZER(memory_listeners);\n\nstatic QTAILQ_HEAD(, AddressSpace) address_spaces\n    = QTAILQ_HEAD_INITIALIZER(address_spaces);\n\ntypedef struct AddrRange AddrRange;\n\n/*\n * Note that signed integers are needed for negative offsetting in aliases\n * (large MemoryRegion::alias_offset).\n */\nstruct AddrRange {\n    Int128 start;\n    Int128 size;\n};\n\nstatic AddrRange addrrange_make(Int128 start, Int128 size)\n{\n    return (AddrRange) { start, size };\n}\n\nstatic bool addrrange_equal(AddrRange r1, AddrRange r2)\n{\n    return int128_eq(r1.start, r2.start) && int128_eq(r1.size, r2.size);\n}\n\nstatic Int128 addrrange_end(AddrRange r)\n{\n    return int128_add(r.start, r.size);\n}\n\nstatic AddrRange addrrange_shift(AddrRange range, Int128 delta)\n{\n    int128_addto(&range.start, delta);\n    return range;\n}\n\nstatic bool addrrange_contains(AddrRange range, Int128 addr)\n{\n    return int128_ge(addr, range.start)\n        && int128_lt(addr, addrrange_end(range));\n}\n\nstatic bool addrrange_intersects(AddrRange r1, AddrRange r2)\n{\n    return addrrange_contains(r1, r2.start)\n        || addrrange_contains(r2, r1.start);\n}\n\nstatic AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n{\n    Int128 start = int128_max(r1.start, r2.start);\n    Int128 end = int128_min(addrrange_end(r1), addrrange_end(r2));\n    return addrrange_make(start, int128_sub(end, start));\n}\n\nenum ListenerDirection { Forward, Reverse };\n\n#define MEMORY_LISTENER_CALL_GLOBAL(_callback, _direction, _args...)    \\\n    do {                                                                \\\n        MemoryListener *_listener;                                      \\\n                                                                        \\\n        switch (_direction) {                                           \\\n        case Forward:                                                   \\\n            QTAILQ_FOREACH(_listener, &memory_listeners, link) {        \\\n                if (_listener->_callback) {                             \\\n                    _listener->_callback(_listener, ##_args);           \\\n                }                                                       \\\n            }                                                           \\\n            break;                                                      \\\n        case Reverse:                                                   \\\n            QTAILQ_FOREACH_REVERSE(_listener, &memory_listeners,        \\\n                                   memory_listeners, link) {            \\\n                if (_listener->_callback) {                             \\\n                    _listener->_callback(_listener, ##_args);           \\\n                }                                                       \\\n            }                                                           \\\n            break;                                                      \\\n        default:                                                        \\\n            abort();                                                    \\\n        }                                                               \\\n    } while (0)\n\n#define MEMORY_LISTENER_CALL(_as, _callback, _direction, _section, _args...) \\\n    do {                                                                \\\n        MemoryListener *_listener;                                      \\\n        struct memory_listeners_as *list = &(_as)->listeners;           \\\n                                                                        \\\n        switch (_direction) {                                           \\\n        case Forward:                                                   \\\n            QTAILQ_FOREACH(_listener, list, link_as) {                  \\\n                if (_listener->_callback) {                             \\\n                    _listener->_callback(_listener, _section, ##_args); \\\n                }                                                       \\\n            }                                                           \\\n            break;                                                      \\\n        case Reverse:                                                   \\\n            QTAILQ_FOREACH_REVERSE(_listener, list, memory_listeners_as, \\\n                                   link_as) {                           \\\n                if (_listener->_callback) {                             \\\n                    _listener->_callback(_listener, _section, ##_args); \\\n                }                                                       \\\n            }                                                           \\\n            break;                                                      \\\n        default:                                                        \\\n            abort();                                                    \\\n        }                                                               \\\n    } while (0)\n\n/* No need to ref/unref .mr, the FlatRange keeps it alive.  */\n#define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \\\n    do {                                                                \\\n        MemoryRegionSection mrs = section_from_flat_range(fr, as);      \\\n        MEMORY_LISTENER_CALL(as, callback, dir, &mrs, ##_args);         \\\n    } while(0)\n\nstruct CoalescedMemoryRange {\n    AddrRange addr;\n    QTAILQ_ENTRY(CoalescedMemoryRange) link;\n};\n\nstruct MemoryRegionIoeventfd {\n    AddrRange addr;\n    bool match_data;\n    uint64_t data;\n    EventNotifier *e;\n};\n\nstatic bool memory_region_ioeventfd_before(MemoryRegionIoeventfd a,\n                                           MemoryRegionIoeventfd b)\n{\n    if (int128_lt(a.addr.start, b.addr.start)) {\n        return true;\n    } else if (int128_gt(a.addr.start, b.addr.start)) {\n        return false;\n    } else if (int128_lt(a.addr.size, b.addr.size)) {\n        return true;\n    } else if (int128_gt(a.addr.size, b.addr.size)) {\n        return false;\n    } else if (a.match_data < b.match_data) {\n        return true;\n    } else  if (a.match_data > b.match_data) {\n        return false;\n    } else if (a.match_data) {\n        if (a.data < b.data) {\n            return true;\n        } else if (a.data > b.data) {\n            return false;\n        }\n    }\n    if (a.e < b.e) {\n        return true;\n    } else if (a.e > b.e) {\n        return false;\n    }\n    return false;\n}\n\nstatic bool memory_region_ioeventfd_equal(MemoryRegionIoeventfd a,\n                                          MemoryRegionIoeventfd b)\n{\n    return !memory_region_ioeventfd_before(a, b)\n        && !memory_region_ioeventfd_before(b, a);\n}\n\ntypedef struct FlatRange FlatRange;\ntypedef struct FlatView FlatView;\n\n/* Range of memory in the global map.  Addresses are absolute. */\nstruct FlatRange {\n    MemoryRegion *mr;\n    hwaddr offset_in_region;\n    AddrRange addr;\n    uint8_t dirty_log_mask;\n    bool romd_mode;\n    bool readonly;\n};\n\n/* Flattened global view of current active memory hierarchy.  Kept in sorted\n * order.\n */\nstruct FlatView {\n    struct rcu_head rcu;\n    unsigned ref;\n    FlatRange *ranges;\n    unsigned nr;\n    unsigned nr_allocated;\n};\n\ntypedef struct AddressSpaceOps AddressSpaceOps;\n\n#define FOR_EACH_FLAT_RANGE(var, view)          \\\n    for (var = (view)->ranges; var < (view)->ranges + (view)->nr; ++var)\n\nstatic inline MemoryRegionSection\nsection_from_flat_range(FlatRange *fr, AddressSpace *as)\n{\n    return (MemoryRegionSection) {\n        .mr = fr->mr,\n        .address_space = as,\n        .offset_within_region = fr->offset_in_region,\n        .size = fr->addr.size,\n        .offset_within_address_space = int128_get64(fr->addr.start),\n        .readonly = fr->readonly,\n    };\n}\n\nstatic bool flatrange_equal(FlatRange *a, FlatRange *b)\n{\n    return a->mr == b->mr\n        && addrrange_equal(a->addr, b->addr)\n        && a->offset_in_region == b->offset_in_region\n        && a->romd_mode == b->romd_mode\n        && a->readonly == b->readonly;\n}\n\nstatic void flatview_init(FlatView *view)\n{\n    view->ref = 1;\n    view->ranges = NULL;\n    view->nr = 0;\n    view->nr_allocated = 0;\n}\n\n/* Insert a range into a given position.  Caller is responsible for maintaining\n * sorting order.\n */\nstatic void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)\n{\n    if (view->nr == view->nr_allocated) {\n        view->nr_allocated = MAX(2 * view->nr, 10);\n        view->ranges = g_realloc(view->ranges,\n                                    view->nr_allocated * sizeof(*view->ranges));\n    }\n    memmove(view->ranges + pos + 1, view->ranges + pos,\n            (view->nr - pos) * sizeof(FlatRange));\n    view->ranges[pos] = *range;\n    memory_region_ref(range->mr);\n    ++view->nr;\n}\n\nstatic void flatview_destroy(FlatView *view)\n{\n    int i;\n\n    for (i = 0; i < view->nr; i++) {\n        memory_region_unref(view->ranges[i].mr);\n    }\n    g_free(view->ranges);\n    g_free(view);\n}\n\nstatic void flatview_ref(FlatView *view)\n{\n    atomic_inc(&view->ref);\n}\n\nstatic void flatview_unref(FlatView *view)\n{\n    if (atomic_fetch_dec(&view->ref) == 1) {\n        flatview_destroy(view);\n    }\n}\n\nstatic bool can_merge(FlatRange *r1, FlatRange *r2)\n{\n    return int128_eq(addrrange_end(r1->addr), r2->addr.start)\n        && r1->mr == r2->mr\n        && int128_eq(int128_add(int128_make64(r1->offset_in_region),\n                                r1->addr.size),\n                     int128_make64(r2->offset_in_region))\n        && r1->dirty_log_mask == r2->dirty_log_mask\n        && r1->romd_mode == r2->romd_mode\n        && r1->readonly == r2->readonly;\n}\n\n/* Attempt to simplify a view by merging adjacent ranges */\nstatic void flatview_simplify(FlatView *view)\n{\n    unsigned i, j;\n\n    i = 0;\n    while (i < view->nr) {\n        j = i + 1;\n        while (j < view->nr\n               && can_merge(&view->ranges[j-1], &view->ranges[j])) {\n            int128_addto(&view->ranges[i].addr.size, view->ranges[j].addr.size);\n            ++j;\n        }\n        ++i;\n        memmove(&view->ranges[i], &view->ranges[j],\n                (view->nr - j) * sizeof(view->ranges[j]));\n        view->nr -= j - i;\n    }\n}\n\nstatic bool memory_region_big_endian(MemoryRegion *mr)\n{\n#ifdef TARGET_WORDS_BIGENDIAN\n    return mr->ops->endianness != DEVICE_LITTLE_ENDIAN;\n#else\n    return mr->ops->endianness == DEVICE_BIG_ENDIAN;\n#endif\n}\n\nstatic bool memory_region_wrong_endianness(MemoryRegion *mr)\n{\n#ifdef TARGET_WORDS_BIGENDIAN\n    return mr->ops->endianness == DEVICE_LITTLE_ENDIAN;\n#else\n    return mr->ops->endianness == DEVICE_BIG_ENDIAN;\n#endif\n}\n\nstatic void adjust_endianness(MemoryRegion *mr, uint64_t *data, unsigned size)\n{\n    if (memory_region_wrong_endianness(mr)) {\n        switch (size) {\n        case 1:\n            break;\n        case 2:\n            *data = bswap16(*data);\n            break;\n        case 4:\n            *data = bswap32(*data);\n            break;\n        case 8:\n            *data = bswap64(*data);\n            break;\n        default:\n            abort();\n        }\n    }\n}\n\nstatic hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)\n{\n    MemoryRegion *root;\n    hwaddr abs_addr = offset;\n\n    abs_addr += mr->addr;\n    for (root = mr; root->container; ) {\n        root = root->container;\n        abs_addr += root->addr;\n    }\n\n    return abs_addr;\n}\n\nstatic int get_cpu_index(void)\n{\n    if (current_cpu) {\n        return current_cpu->cpu_index;\n    }\n    return -1;\n}\n\nstatic MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr,\n                                                       hwaddr addr,\n                                                       uint64_t *value,\n                                                       unsigned size,\n                                                       unsigned shift,\n                                                       uint64_t mask,\n                                                       MemTxAttrs attrs)\n{\n    uint64_t tmp;\n\n    tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr);\n    if (mr->subpage) {\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_read(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    *value |= (tmp & mask) << shift;\n    return MEMTX_OK;\n}\n\nstatic MemTxResult  memory_region_read_accessor(MemoryRegion *mr,\n                                                hwaddr addr,\n                                                uint64_t *value,\n                                                unsigned size,\n                                                unsigned shift,\n                                                uint64_t mask,\n                                                MemTxAttrs attrs)\n{\n    uint64_t tmp;\n\n    tmp = mr->ops->read(mr->opaque, addr, size);\n    if (mr->subpage) {\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_read(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    *value |= (tmp & mask) << shift;\n    return MEMTX_OK;\n}\n\nstatic MemTxResult memory_region_read_with_attrs_accessor(MemoryRegion *mr,\n                                                          hwaddr addr,\n                                                          uint64_t *value,\n                                                          unsigned size,\n                                                          unsigned shift,\n                                                          uint64_t mask,\n                                                          MemTxAttrs attrs)\n{\n    uint64_t tmp = 0;\n    MemTxResult r;\n\n    r = mr->ops->read_with_attrs(mr->opaque, addr, &tmp, size, attrs);\n    if (mr->subpage) {\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_read(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    *value |= (tmp & mask) << shift;\n    return r;\n}\n\nstatic MemTxResult memory_region_oldmmio_write_accessor(MemoryRegion *mr,\n                                                        hwaddr addr,\n                                                        uint64_t *value,\n                                                        unsigned size,\n                                                        unsigned shift,\n                                                        uint64_t mask,\n                                                        MemTxAttrs attrs)\n{\n    uint64_t tmp;\n\n    tmp = (*value >> shift) & mask;\n    if (mr->subpage) {\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_write(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    mr->ops->old_mmio.write[ctz32(size)](mr->opaque, addr, tmp);\n    return MEMTX_OK;\n}\n\nstatic MemTxResult memory_region_write_accessor(MemoryRegion *mr,\n                                                hwaddr addr,\n                                                uint64_t *value,\n                                                unsigned size,\n                                                unsigned shift,\n                                                uint64_t mask,\n                                                MemTxAttrs attrs)\n{\n    uint64_t tmp;\n\n    tmp = (*value >> shift) & mask;\n    if (mr->subpage) {\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_write(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    mr->ops->write(mr->opaque, addr, tmp, size);\n    return MEMTX_OK;\n}\n\nstatic MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,\n                                                           hwaddr addr,\n                                                           uint64_t *value,\n                                                           unsigned size,\n                                                           unsigned shift,\n                                                           uint64_t mask,\n                                                           MemTxAttrs attrs)\n{\n    uint64_t tmp;\n\n    tmp = (*value >> shift) & mask;\n    if (mr->subpage) {\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n    } else if (mr == &io_mem_notdirty) {\n        /* Accesses to code which has previously been translated into a TB show\n         * up in the MMIO path, as accesses to the io_mem_notdirty\n         * MemoryRegion. */\n        trace_memory_region_tb_write(get_cpu_index(), addr, tmp, size);\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n    }\n    return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);\n}\n\nstatic MemTxResult access_with_adjusted_size(hwaddr addr,\n                                      uint64_t *value,\n                                      unsigned size,\n                                      unsigned access_size_min,\n                                      unsigned access_size_max,\n                                      MemTxResult (*access)(MemoryRegion *mr,\n                                                            hwaddr addr,\n                                                            uint64_t *value,\n                                                            unsigned size,\n                                                            unsigned shift,\n                                                            uint64_t mask,\n                                                            MemTxAttrs attrs),\n                                      MemoryRegion *mr,\n                                      MemTxAttrs attrs)\n{\n    uint64_t access_mask;\n    unsigned access_size;\n    unsigned i;\n    MemTxResult r = MEMTX_OK;\n\n    if (!access_size_min) {\n        access_size_min = 1;\n    }\n    if (!access_size_max) {\n        access_size_max = 4;\n    }\n\n    /* FIXME: support unaligned access? */\n    access_size = MAX(MIN(size, access_size_max), access_size_min);\n    access_mask = -1ULL >> (64 - access_size * 8);\n    if (memory_region_big_endian(mr)) {\n        for (i = 0; i < size; i += access_size) {\n            r |= access(mr, addr + i, value, access_size,\n                        (size - access_size - i) * 8, access_mask, attrs);\n        }\n    } else {\n        for (i = 0; i < size; i += access_size) {\n            r |= access(mr, addr + i, value, access_size, i * 8,\n                        access_mask, attrs);\n        }\n    }\n    return r;\n}\n\nstatic AddressSpace *memory_region_to_address_space(MemoryRegion *mr)\n{\n    AddressSpace *as;\n\n    while (mr->container) {\n        mr = mr->container;\n    }\n    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n        if (mr == as->root) {\n            return as;\n        }\n    }\n    return NULL;\n}\n\n/* Render a memory region into the global view.  Ranges in @view obscure\n * ranges in @mr.\n */\nstatic void render_memory_region(FlatView *view,\n                                 MemoryRegion *mr,\n                                 Int128 base,\n                                 AddrRange clip,\n                                 bool readonly)\n{\n    MemoryRegion *subregion;\n    unsigned i;\n    hwaddr offset_in_region;\n    Int128 remain;\n    Int128 now;\n    FlatRange fr;\n    AddrRange tmp;\n\n    if (!mr->enabled) {\n        return;\n    }\n\n    int128_addto(&base, int128_make64(mr->addr));\n    readonly |= mr->readonly;\n\n    tmp = addrrange_make(base, mr->size);\n\n    if (!addrrange_intersects(tmp, clip)) {\n        return;\n    }\n\n    clip = addrrange_intersection(tmp, clip);\n\n    if (mr->alias) {\n        int128_subfrom(&base, int128_make64(mr->alias->addr));\n        int128_subfrom(&base, int128_make64(mr->alias_offset));\n        render_memory_region(view, mr->alias, base, clip, readonly);\n        return;\n    }\n\n    /* Render subregions in priority order. */\n    QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {\n        render_memory_region(view, subregion, base, clip, readonly);\n    }\n\n    if (!mr->terminates) {\n        return;\n    }\n\n    offset_in_region = int128_get64(int128_sub(clip.start, base));\n    base = clip.start;\n    remain = clip.size;\n\n    fr.mr = mr;\n    fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);\n    fr.romd_mode = mr->romd_mode;\n    fr.readonly = readonly;\n\n    /* Render the region itself into any gaps left by the current view. */\n    for (i = 0; i < view->nr && int128_nz(remain); ++i) {\n        if (int128_ge(base, addrrange_end(view->ranges[i].addr))) {\n            continue;\n        }\n        if (int128_lt(base, view->ranges[i].addr.start)) {\n            now = int128_min(remain,\n                             int128_sub(view->ranges[i].addr.start, base));\n            fr.offset_in_region = offset_in_region;\n            fr.addr = addrrange_make(base, now);\n            flatview_insert(view, i, &fr);\n            ++i;\n            int128_addto(&base, now);\n            offset_in_region += int128_get64(now);\n            int128_subfrom(&remain, now);\n        }\n        now = int128_sub(int128_min(int128_add(base, remain),\n                                    addrrange_end(view->ranges[i].addr)),\n                         base);\n        int128_addto(&base, now);\n        offset_in_region += int128_get64(now);\n        int128_subfrom(&remain, now);\n    }\n    if (int128_nz(remain)) {\n        fr.offset_in_region = offset_in_region;\n        fr.addr = addrrange_make(base, remain);\n        flatview_insert(view, i, &fr);\n    }\n}\n\n/* Render a memory topology into a list of disjoint absolute ranges. */\nstatic FlatView *generate_memory_topology(MemoryRegion *mr)\n{\n    FlatView *view;\n\n    view = g_new(FlatView, 1);\n    flatview_init(view);\n\n    if (mr) {\n        render_memory_region(view, mr, int128_zero(),\n                             addrrange_make(int128_zero(), int128_2_64()), false);\n    }\n    flatview_simplify(view);\n\n    return view;\n}\n\nstatic void address_space_add_del_ioeventfds(AddressSpace *as,\n                                             MemoryRegionIoeventfd *fds_new,\n                                             unsigned fds_new_nb,\n                                             MemoryRegionIoeventfd *fds_old,\n                                             unsigned fds_old_nb)\n{\n    unsigned iold, inew;\n    MemoryRegionIoeventfd *fd;\n    MemoryRegionSection section;\n\n    /* Generate a symmetric difference of the old and new fd sets, adding\n     * and deleting as necessary.\n     */\n\n    iold = inew = 0;\n    while (iold < fds_old_nb || inew < fds_new_nb) {\n        if (iold < fds_old_nb\n            && (inew == fds_new_nb\n                || memory_region_ioeventfd_before(fds_old[iold],\n                                                  fds_new[inew]))) {\n            fd = &fds_old[iold];\n            section = (MemoryRegionSection) {\n                .address_space = as,\n                .offset_within_address_space = int128_get64(fd->addr.start),\n                .size = fd->addr.size,\n            };\n            MEMORY_LISTENER_CALL(as, eventfd_del, Forward, &section,\n                                 fd->match_data, fd->data, fd->e);\n            ++iold;\n        } else if (inew < fds_new_nb\n                   && (iold == fds_old_nb\n                       || memory_region_ioeventfd_before(fds_new[inew],\n                                                         fds_old[iold]))) {\n            fd = &fds_new[inew];\n            section = (MemoryRegionSection) {\n                .address_space = as,\n                .offset_within_address_space = int128_get64(fd->addr.start),\n                .size = fd->addr.size,\n            };\n            MEMORY_LISTENER_CALL(as, eventfd_add, Reverse, &section,\n                                 fd->match_data, fd->data, fd->e);\n            ++inew;\n        } else {\n            ++iold;\n            ++inew;\n        }\n    }\n}\n\nstatic FlatView *address_space_get_flatview(AddressSpace *as)\n{\n    FlatView *view;\n\n    rcu_read_lock();\n    view = atomic_rcu_read(&as->current_map);\n    flatview_ref(view);\n    rcu_read_unlock();\n    return view;\n}\n\nstatic void address_space_update_ioeventfds(AddressSpace *as)\n{\n    FlatView *view;\n    FlatRange *fr;\n    unsigned ioeventfd_nb = 0;\n    MemoryRegionIoeventfd *ioeventfds = NULL;\n    AddrRange tmp;\n    unsigned i;\n\n    view = address_space_get_flatview(as);\n    FOR_EACH_FLAT_RANGE(fr, view) {\n        for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {\n            tmp = addrrange_shift(fr->mr->ioeventfds[i].addr,\n                                  int128_sub(fr->addr.start,\n                                             int128_make64(fr->offset_in_region)));\n            if (addrrange_intersects(fr->addr, tmp)) {\n                ++ioeventfd_nb;\n                ioeventfds = g_realloc(ioeventfds,\n                                          ioeventfd_nb * sizeof(*ioeventfds));\n                ioeventfds[ioeventfd_nb-1] = fr->mr->ioeventfds[i];\n                ioeventfds[ioeventfd_nb-1].addr = tmp;\n            }\n        }\n    }\n\n    address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,\n                                     as->ioeventfds, as->ioeventfd_nb);\n\n    g_free(as->ioeventfds);\n    as->ioeventfds = ioeventfds;\n    as->ioeventfd_nb = ioeventfd_nb;\n    flatview_unref(view);\n}\n\nstatic void address_space_update_topology_pass(AddressSpace *as,\n                                               const FlatView *old_view,\n                                               const FlatView *new_view,\n                                               bool adding)\n{\n    unsigned iold, inew;\n    FlatRange *frold, *frnew;\n\n    /* Generate a symmetric difference of the old and new memory maps.\n     * Kill ranges in the old map, and instantiate ranges in the new map.\n     */\n    iold = inew = 0;\n    while (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frnew->dirty_log_mask & ~frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start,\n                                                  frold->dirty_log_mask,\n                                                  frnew->dirty_log_mask);\n                }\n                if (frold->dirty_log_mask & ~frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop,\n                                                  frold->dirty_log_mask,\n                                                  frnew->dirty_log_mask);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n            }\n\n            ++inew;\n        }\n    }\n}\n\n\nstatic void address_space_update_topology(AddressSpace *as)\n{\n    FlatView *old_view = address_space_get_flatview(as);\n    FlatView *new_view = generate_memory_topology(as->root);\n\n    address_space_update_topology_pass(as, old_view, new_view, false);\n    address_space_update_topology_pass(as, old_view, new_view, true);\n\n    /* Writes are protected by the BQL.  */\n    atomic_rcu_set(&as->current_map, new_view);\n    call_rcu(old_view, flatview_unref, rcu);\n\n    /* Note that all the old MemoryRegions are still alive up to this\n     * point.  This relieves most MemoryListeners from the need to\n     * ref/unref the MemoryRegions they get---unless they use them\n     * outside the iothread mutex, in which case precise reference\n     * counting is necessary.\n     */\n    flatview_unref(old_view);\n\n    address_space_update_ioeventfds(as);\n}\n\nvoid memory_region_transaction_begin(void)\n{\n    qemu_flush_coalesced_mmio_buffer();\n    ++memory_region_transaction_depth;\n}\n\nvoid memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            memory_region_update_pending = false;\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n            ioeventfd_update_pending = false;\n        }\n   }\n}\n\nstatic void memory_region_destructor_none(MemoryRegion *mr)\n{\n}\n\nstatic void memory_region_destructor_ram(MemoryRegion *mr)\n{\n    qemu_ram_free(mr->ram_block);\n}\n\nstatic bool memory_region_need_escape(char c)\n{\n    return c == '/' || c == '[' || c == '\\\\' || c == ']';\n}\n\nstatic char *memory_region_escape_name(const char *name)\n{\n    const char *p;\n    char *escaped, *q;\n    uint8_t c;\n    size_t bytes = 0;\n\n    for (p = name; *p; p++) {\n        bytes += memory_region_need_escape(*p) ? 4 : 1;\n    }\n    if (bytes == p - name) {\n       return g_memdup(name, bytes + 1);\n    }\n\n    escaped = g_malloc(bytes + 1);\n    for (p = name, q = escaped; *p; p++) {\n        c = *p;\n        if (unlikely(memory_region_need_escape(c))) {\n            *q++ = '\\\\';\n            *q++ = 'x';\n            *q++ = \"0123456789abcdef\"[c >> 4];\n            c = \"0123456789abcdef\"[c & 15];\n        }\n        *q++ = c;\n    }\n    *q = 0;\n    return escaped;\n}\n\nvoid memory_region_init(MemoryRegion *mr,\n                        Object *owner,\n                        const char *name,\n                        uint64_t size)\n{\n    object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);\n    mr->size = int128_make64(size);\n    if (size == UINT64_MAX) {\n        mr->size = int128_2_64();\n    }\n    mr->name = g_strdup(name);\n    mr->owner = owner;\n    mr->ram_block = NULL;\n\n    if (name) {\n        char *escaped_name = memory_region_escape_name(name);\n        char *name_array = g_strdup_printf(\"%s[*]\", escaped_name);\n\n        if (!owner) {\n            owner = container_get(qdev_get_machine(), \"/unattached\");\n        }\n\n        object_property_add_child(owner, name_array, OBJECT(mr), &error_abort);\n        object_unref(OBJECT(mr));\n        g_free(name_array);\n        g_free(escaped_name);\n    }\n}\n\nstatic void memory_region_get_addr(Object *obj, Visitor *v, const char *name,\n                                   void *opaque, Error **errp)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n    uint64_t value = mr->addr;\n\n    visit_type_uint64(v, name, &value, errp);\n}\n\nstatic void memory_region_get_container(Object *obj, Visitor *v,\n                                        const char *name, void *opaque,\n                                        Error **errp)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n    gchar *path = (gchar *)\"\";\n\n    if (mr->container) {\n        path = object_get_canonical_path(OBJECT(mr->container));\n    }\n    visit_type_str(v, name, &path, errp);\n    if (mr->container) {\n        g_free(path);\n    }\n}\n\nstatic Object *memory_region_resolve_container(Object *obj, void *opaque,\n                                               const char *part)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n\n    return OBJECT(mr->container);\n}\n\nstatic void memory_region_get_priority(Object *obj, Visitor *v,\n                                       const char *name, void *opaque,\n                                       Error **errp)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n    int32_t value = mr->priority;\n\n    visit_type_int32(v, name, &value, errp);\n}\n\nstatic void memory_region_get_size(Object *obj, Visitor *v, const char *name,\n                                   void *opaque, Error **errp)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n    uint64_t value = memory_region_size(mr);\n\n    visit_type_uint64(v, name, &value, errp);\n}\n\nstatic void memory_region_initfn(Object *obj)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n    ObjectProperty *op;\n\n    mr->ops = &unassigned_mem_ops;\n    mr->enabled = true;\n    mr->romd_mode = true;\n    mr->global_locking = true;\n    mr->destructor = memory_region_destructor_none;\n    QTAILQ_INIT(&mr->subregions);\n    QTAILQ_INIT(&mr->coalesced);\n\n    op = object_property_add(OBJECT(mr), \"container\",\n                             \"link<\" TYPE_MEMORY_REGION \">\",\n                             memory_region_get_container,\n                             NULL, /* memory_region_set_container */\n                             NULL, NULL, &error_abort);\n    op->resolve = memory_region_resolve_container;\n\n    object_property_add(OBJECT(mr), \"addr\", \"uint64\",\n                        memory_region_get_addr,\n                        NULL, /* memory_region_set_addr */\n                        NULL, NULL, &error_abort);\n    object_property_add(OBJECT(mr), \"priority\", \"uint32\",\n                        memory_region_get_priority,\n                        NULL, /* memory_region_set_priority */\n                        NULL, NULL, &error_abort);\n    object_property_add(OBJECT(mr), \"size\", \"uint64\",\n                        memory_region_get_size,\n                        NULL, /* memory_region_set_size, */\n                        NULL, NULL, &error_abort);\n}\n\nstatic uint64_t _unassigned_mem_read(void *opaque, hwaddr addr,\n                                    size_t size, bool* changed)\n{\n    // We want to read size bytes from addr. Size must be <= 8 to fit into uint64_t\n\n#ifdef DEBUG_UNASSIGNED\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n#endif\n\n    uint64_t val;\n\n    if (current_cpu != NULL) {\n        // PANDA callback may create a value. If so, avoid error-handling code\n        if (panda_callbacks_unassigned_io_read(current_cpu,\n                    panda_current_pc(current_cpu), addr, size, &val)) { // Modifies val\n            *changed = true; // Indicates a callback has changed the value\n            return val;\n        }\n        // No callback changed the value. Continue with error-processing code\n        *changed = false;\n        cpu_unassigned_access(current_cpu, addr, false, false, 0, size);\n    }\n\n    return 0;\n}\n\nstatic bool _unassigned_mem_write(void *opaque, hwaddr addr,\n                                 uint64_t val, size_t size)\n{\n    // Write to unassigned memory. PANDA callback may handle this\n    // and decide to silence the error\n    // return true if error should be silenced\n\n#ifdef DEBUG_UNASSIGNED\n    printf(\"Unassigned mem write to \" TARGET_FMT_plx \"\\n\", addr);\n#endif\n\n    if (current_cpu != NULL) {\n        if (panda_callbacks_unassigned_io_write(current_cpu, panda_current_pc(current_cpu), addr, size, val)) {\n            // A plugin has decided to make this write look like it's valid\n            return true;\n        }\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n    }else{\n      // This case is run a bunch during make check so I guess it's normal behavior.\n      // No need to spam the output\n      // printf(\"WARNING: Unassigned memory write with no CPU\\n\");\n    }\n    return false;\n}\n\nstatic bool unassigned_mem_accepts(void *opaque, hwaddr addr,\n                                   unsigned size, bool is_write)\n{\n    return false;\n}\n\nconst MemoryRegionOps unassigned_mem_ops = {\n    .valid.accepts = unassigned_mem_accepts,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nstatic uint64_t memory_region_ram_device_read(void *opaque,\n                                              hwaddr addr, unsigned size)\n{\n    MemoryRegion *mr = opaque;\n    uint64_t data = (uint64_t)~0;\n\n    switch (size) {\n    case 1:\n        data = *(uint8_t *)(mr->ram_block->host + addr);\n        break;\n    case 2:\n        data = *(uint16_t *)(mr->ram_block->host + addr);\n        break;\n    case 4:\n        data = *(uint32_t *)(mr->ram_block->host + addr);\n        break;\n    case 8:\n        data = *(uint64_t *)(mr->ram_block->host + addr);\n        break;\n    }\n\n    trace_memory_region_ram_device_read(get_cpu_index(), mr, addr, data, size);\n\n    return data;\n}\n\nstatic void memory_region_ram_device_write(void *opaque, hwaddr addr,\n                                           uint64_t data, unsigned size)\n{\n    MemoryRegion *mr = opaque;\n\n    trace_memory_region_ram_device_write(get_cpu_index(), mr, addr, data, size);\n\n    switch (size) {\n    case 1:\n        *(uint8_t *)(mr->ram_block->host + addr) = (uint8_t)data;\n        break;\n    case 2:\n        *(uint16_t *)(mr->ram_block->host + addr) = (uint16_t)data;\n        break;\n    case 4:\n        *(uint32_t *)(mr->ram_block->host + addr) = (uint32_t)data;\n        break;\n    case 8:\n        *(uint64_t *)(mr->ram_block->host + addr) = data;\n        break;\n    }\n}\n\nstatic const MemoryRegionOps ram_device_mem_ops = {\n    .read = memory_region_ram_device_read,\n    .write = memory_region_ram_device_write,\n    .endianness = DEVICE_HOST_ENDIAN,\n    .valid = {\n        .min_access_size = 1,\n        .max_access_size = 8,\n        .unaligned = true,\n    },\n    .impl = {\n        .min_access_size = 1,\n        .max_access_size = 8,\n        .unaligned = true,\n    },\n};\n\nbool memory_region_access_valid(MemoryRegion *mr,\n                                hwaddr addr,\n                                unsigned size,\n                                bool is_write)\n{\n    int access_size_min, access_size_max;\n    int access_size, i;\n\n    if (!mr->ops->valid.unaligned && (addr & (size - 1))) {\n        return false;\n    }\n\n    if (!mr->ops->valid.accepts) {\n        return true;\n    }\n\n    access_size_min = mr->ops->valid.min_access_size;\n    if (!mr->ops->valid.min_access_size) {\n        access_size_min = 1;\n    }\n\n    access_size_max = mr->ops->valid.max_access_size;\n    if (!mr->ops->valid.max_access_size) {\n        access_size_max = 4;\n    }\n\n    access_size = MAX(MIN(size, access_size_max), access_size_min);\n    for (i = 0; i < size; i += access_size) {\n        if (!mr->ops->valid.accepts(mr->opaque, addr + i, access_size,\n                                    is_write)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic MemTxResult memory_region_dispatch_read1(MemoryRegion *mr,\n                                                hwaddr addr,\n                                                uint64_t *pval,\n                                                unsigned size,\n                                                MemTxAttrs attrs)\n{\n    *pval = 0;\n\n    MemTxResult result;\n    if (mr->ops->read) {\n        result = access_with_adjusted_size(addr, pval, size,\n                                         mr->ops->impl.min_access_size,\n                                         mr->ops->impl.max_access_size,\n                                         memory_region_read_accessor,\n                                         mr, attrs);\n    } else if (mr->ops->read_with_attrs) {\n        result = access_with_adjusted_size(addr, pval, size,\n                                         mr->ops->impl.min_access_size,\n                                         mr->ops->impl.max_access_size,\n                                         memory_region_read_with_attrs_accessor,\n                                         mr, attrs);\n    } else {\n        result = access_with_adjusted_size(addr, pval, size, 1, 4,\n                                         memory_region_oldmmio_read_accessor,\n                                         mr, attrs);\n    }\n\n\n    return result;\n\n}\n\nMemTxResult memory_region_dispatch_read(MemoryRegion *mr,\n                                        hwaddr addr,\n                                        uint64_t *pval,\n                                        unsigned size,\n                                        MemTxAttrs attrs)\n{\n    MemTxResult r;\n\n    if (!memory_region_access_valid(mr, addr, size, false)) {\n        // Some part of (addr) through (addr+size) is invalid.\n        // May trigger PANDA callbacks which may produce a value.\n        // If so, return MEMTX_OK despite the invalid access\n        // Either way, assign pval to the result (seems strange, but otherwise tests fail)\n\n        bool changed = false;\n        *pval = _unassigned_mem_read(mr, addr, size, &changed);\n\n        if (changed) {\n            // Some PANDA callback created a value, \n            // fix endianness (similar to a normal read)\n            // and return OK\n            adjust_endianness(mr, pval, size);\n            return MEMTX_OK;\n        } else {\n            // No plugin created a value, so return error code\n            return MEMTX_DECODE_ERROR;\n        }\n    }\n\n    r = memory_region_dispatch_read1(mr, addr, pval, size, attrs);\n    adjust_endianness(mr, pval, size);\n    return r;\n}\n\n/* Return true if an eventfd was signalled */\nstatic bool memory_region_dispatch_write_eventfds(MemoryRegion *mr,\n                                                    hwaddr addr,\n                                                    uint64_t data,\n                                                    unsigned size,\n                                                    MemTxAttrs attrs)\n{\n    MemoryRegionIoeventfd ioeventfd = {\n        .addr = addrrange_make(int128_make64(addr), int128_make64(size)),\n        .data = data,\n    };\n    unsigned i;\n\n    for (i = 0; i < mr->ioeventfd_nb; i++) {\n        ioeventfd.match_data = mr->ioeventfds[i].match_data;\n        ioeventfd.e = mr->ioeventfds[i].e;\n\n        if (memory_region_ioeventfd_equal(ioeventfd, mr->ioeventfds[i])) {\n            event_notifier_set(ioeventfd.e);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nMemTxResult memory_region_dispatch_write(MemoryRegion *mr,\n                                         hwaddr addr,\n                                         uint64_t data,\n                                         unsigned size,\n                                         MemTxAttrs attrs)\n{\n    if (!memory_region_access_valid(mr, addr, size, true)) {\n        if (_unassigned_mem_write(mr, addr, data, size)) {\n            // A PANDA callback wants to pretend this write is OK\n            return MEMTX_OK;\n        } else { // No callback requested a change - normal behavior (fail)\n            return MEMTX_DECODE_ERROR;\n        }\n    }\n\n    adjust_endianness(mr, &data, size);\n\n    if ((!kvm_eventfds_enabled()) &&\n        memory_region_dispatch_write_eventfds(mr, addr, data, size, attrs)) {\n        return MEMTX_OK;\n    }\n\n    if (mr->ops->write) {\n        return access_with_adjusted_size(addr, &data, size,\n                                         mr->ops->impl.min_access_size,\n                                         mr->ops->impl.max_access_size,\n                                         memory_region_write_accessor, mr,\n                                         attrs);\n    } else if (mr->ops->write_with_attrs) {\n        return\n            access_with_adjusted_size(addr, &data, size,\n                                      mr->ops->impl.min_access_size,\n                                      mr->ops->impl.max_access_size,\n                                      memory_region_write_with_attrs_accessor,\n                                      mr, attrs);\n    } else {\n        return access_with_adjusted_size(addr, &data, size, 1, 4,\n                                         memory_region_oldmmio_write_accessor,\n                                         mr, attrs);\n    }\n}\n\nvoid memory_region_init_io(MemoryRegion *mr,\n                           Object *owner,\n                           const MemoryRegionOps *ops,\n                           void *opaque,\n                           const char *name,\n                           uint64_t size)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ops = ops ? ops : &unassigned_mem_ops;\n    mr->opaque = opaque;\n    mr->terminates = true;\n}\n\nvoid memory_region_init_ram(MemoryRegion *mr,\n                            Object *owner,\n                            const char *name,\n                            uint64_t size,\n                            Error **errp)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ram = true;\n    mr->terminates = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->ram_block = qemu_ram_alloc(size, mr, errp);\n    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;\n}\n\nvoid memory_region_init_resizeable_ram(MemoryRegion *mr,\n                                       Object *owner,\n                                       const char *name,\n                                       uint64_t size,\n                                       uint64_t max_size,\n                                       void (*resized)(const char*,\n                                                       uint64_t length,\n                                                       void *host),\n                                       Error **errp)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ram = true;\n    mr->terminates = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,\n                                              mr, errp);\n    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;\n}\n\n#ifdef __linux__\nvoid memory_region_init_ram_from_file(MemoryRegion *mr,\n                                      struct Object *owner,\n                                      const char *name,\n                                      uint64_t size,\n                                      bool share,\n                                      const char *path,\n                                      Error **errp)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ram = true;\n    mr->terminates = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->ram_block = qemu_ram_alloc_from_file(size, mr, share, path, errp);\n    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;\n}\n#endif\n\nvoid memory_region_init_ram_ptr(MemoryRegion *mr,\n                                Object *owner,\n                                const char *name,\n                                uint64_t size,\n                                void *ptr)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ram = true;\n    mr->terminates = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;\n\n    /* qemu_ram_alloc_from_ptr cannot fail with ptr != NULL.  */\n    assert(ptr != NULL);\n    mr->ram_block = qemu_ram_alloc_from_ptr(size, ptr, mr, &error_fatal);\n}\n\nvoid memory_region_init_ram_device_ptr(MemoryRegion *mr,\n                                       Object *owner,\n                                       const char *name,\n                                       uint64_t size,\n                                       void *ptr)\n{\n    memory_region_init_ram_ptr(mr, owner, name, size, ptr);\n    mr->ram_device = true;\n    mr->ops = &ram_device_mem_ops;\n    mr->opaque = mr;\n}\n\nvoid memory_region_init_alias(MemoryRegion *mr,\n                              Object *owner,\n                              const char *name,\n                              MemoryRegion *orig,\n                              hwaddr offset,\n                              uint64_t size)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->alias = orig;\n    mr->alias_offset = offset;\n}\n\nvoid memory_region_init_rom(MemoryRegion *mr,\n                            struct Object *owner,\n                            const char *name,\n                            uint64_t size,\n                            Error **errp)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->ram = true;\n    mr->readonly = true;\n    mr->terminates = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->ram_block = qemu_ram_alloc(size, mr, errp);\n    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;\n}\n\nvoid memory_region_init_rom_device(MemoryRegion *mr,\n                                   Object *owner,\n                                   const MemoryRegionOps *ops,\n                                   void *opaque,\n                                   const char *name,\n                                   uint64_t size,\n                                   Error **errp)\n{\n    assert(ops);\n    memory_region_init(mr, owner, name, size);\n    mr->ops = ops;\n    mr->opaque = opaque;\n    mr->terminates = true;\n    mr->rom_device = true;\n    mr->destructor = memory_region_destructor_ram;\n    mr->ram_block = qemu_ram_alloc(size, mr, errp);\n}\n\nvoid memory_region_init_iommu(MemoryRegion *mr,\n                              Object *owner,\n                              const MemoryRegionIOMMUOps *ops,\n                              const char *name,\n                              uint64_t size)\n{\n    memory_region_init(mr, owner, name, size);\n    mr->iommu_ops = ops,\n    mr->terminates = true;  /* then re-forwards */\n    QLIST_INIT(&mr->iommu_notify);\n    mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;\n}\n\nstatic void memory_region_finalize(Object *obj)\n{\n    MemoryRegion *mr = MEMORY_REGION(obj);\n\n    assert(!mr->container);\n\n    /* We know the region is not visible in any address space (it\n     * does not have a container and cannot be a root either because\n     * it has no references, so we can blindly clear mr->enabled.\n     * memory_region_set_enabled instead could trigger a transaction\n     * and cause an infinite loop.\n     */\n    mr->enabled = false;\n    memory_region_transaction_begin();\n    while (!QTAILQ_EMPTY(&mr->subregions)) {\n        MemoryRegion *subregion = QTAILQ_FIRST(&mr->subregions);\n        memory_region_del_subregion(mr, subregion);\n    }\n    memory_region_transaction_commit();\n\n    mr->destructor(mr);\n    memory_region_clear_coalescing(mr);\n    g_free((char *)mr->name);\n    g_free(mr->ioeventfds);\n}\n\nObject *memory_region_owner(MemoryRegion *mr)\n{\n    Object *obj = OBJECT(mr);\n    return obj->parent;\n}\n\nvoid memory_region_ref(MemoryRegion *mr)\n{\n    /* MMIO callbacks most likely will access data that belongs\n     * to the owner, hence the need to ref/unref the owner whenever\n     * the memory region is in use.\n     *\n     * The memory region is a child of its owner.  As long as the\n     * owner doesn't call unparent itself on the memory region,\n     * ref-ing the owner will also keep the memory region alive.\n     * Memory regions without an owner are supposed to never go away;\n     * we do not ref/unref them because it slows down DMA sensibly.\n     */\n    if (mr && mr->owner) {\n        object_ref(mr->owner);\n    }\n}\n\nvoid memory_region_unref(MemoryRegion *mr)\n{\n    if (mr && mr->owner) {\n        object_unref(mr->owner);\n    }\n}\n\nuint64_t memory_region_size(MemoryRegion *mr)\n{\n    if (int128_eq(mr->size, int128_2_64())) {\n        return UINT64_MAX;\n    }\n    return int128_get64(mr->size);\n}\n\nconst char *memory_region_name(const MemoryRegion *mr)\n{\n    if (!mr->name) {\n        ((MemoryRegion *)mr)->name =\n            object_get_canonical_path_component(OBJECT(mr));\n    }\n    return mr->name;\n}\n\nbool memory_region_is_ram_device(MemoryRegion *mr)\n{\n    return mr->ram_device;\n}\n\nuint8_t memory_region_get_dirty_log_mask(MemoryRegion *mr)\n{\n    uint8_t mask = mr->dirty_log_mask;\n    if (global_dirty_log && mr->ram_block) {\n        mask |= (1 << DIRTY_MEMORY_MIGRATION);\n    }\n    return mask;\n}\n\nbool memory_region_is_logging(MemoryRegion *mr, uint8_t client)\n{\n    return memory_region_get_dirty_log_mask(mr) & (1 << client);\n}\n\nstatic void memory_region_update_iommu_notify_flags(MemoryRegion *mr)\n{\n    IOMMUNotifierFlag flags = IOMMU_NOTIFIER_NONE;\n    IOMMUNotifier *iommu_notifier;\n\n    QLIST_FOREACH(iommu_notifier, &mr->iommu_notify, node) {\n        flags |= iommu_notifier->notifier_flags;\n    }\n\n    if (flags != mr->iommu_notify_flags &&\n        mr->iommu_ops->notify_flag_changed) {\n        mr->iommu_ops->notify_flag_changed(mr, mr->iommu_notify_flags,\n                                           flags);\n    }\n\n    mr->iommu_notify_flags = flags;\n}\n\nvoid memory_region_register_iommu_notifier(MemoryRegion *mr,\n                                           IOMMUNotifier *n)\n{\n    if (mr->alias) {\n        memory_region_register_iommu_notifier(mr->alias, n);\n        return;\n    }\n\n    /* We need to register for at least one bitfield */\n    assert(n->notifier_flags != IOMMU_NOTIFIER_NONE);\n    QLIST_INSERT_HEAD(&mr->iommu_notify, n, node);\n    memory_region_update_iommu_notify_flags(mr);\n}\n\nuint64_t memory_region_iommu_get_min_page_size(MemoryRegion *mr)\n{\n    assert(memory_region_is_iommu(mr));\n    if (mr->iommu_ops && mr->iommu_ops->get_min_page_size) {\n        return mr->iommu_ops->get_min_page_size(mr);\n    }\n    return TARGET_PAGE_SIZE;\n}\n\nvoid memory_region_iommu_replay(MemoryRegion *mr, IOMMUNotifier *n,\n                                bool is_write)\n{\n    hwaddr addr, granularity;\n    IOMMUTLBEntry iotlb;\n\n    granularity = memory_region_iommu_get_min_page_size(mr);\n\n    for (addr = 0; addr < memory_region_size(mr); addr += granularity) {\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n        if (iotlb.perm != IOMMU_NONE) {\n            n->notify(n, &iotlb);\n        }\n\n        /* if (2^64 - MR size) < granularity, it's possible to get an\n         * infinite loop here.  This should catch such a wraparound */\n        if ((addr + granularity) < addr) {\n            break;\n        }\n    }\n}\n\nvoid memory_region_unregister_iommu_notifier(MemoryRegion *mr,\n                                             IOMMUNotifier *n)\n{\n    if (mr->alias) {\n        memory_region_unregister_iommu_notifier(mr->alias, n);\n        return;\n    }\n    QLIST_REMOVE(n, node);\n    memory_region_update_iommu_notify_flags(mr);\n}\n\nvoid memory_region_notify_iommu(MemoryRegion *mr,\n                                IOMMUTLBEntry entry)\n{\n    IOMMUNotifier *iommu_notifier;\n    IOMMUNotifierFlag request_flags;\n\n    assert(memory_region_is_iommu(mr));\n\n    if (entry.perm & IOMMU_RW) {\n        request_flags = IOMMU_NOTIFIER_MAP;\n    } else {\n        request_flags = IOMMU_NOTIFIER_UNMAP;\n    }\n\n    QLIST_FOREACH(iommu_notifier, &mr->iommu_notify, node) {\n        if (iommu_notifier->notifier_flags & request_flags) {\n            iommu_notifier->notify(iommu_notifier, &entry);\n        }\n    }\n}\n\nvoid memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)\n{\n    uint8_t mask = 1 << client;\n    uint8_t old_logging;\n\n    assert(client == DIRTY_MEMORY_VGA);\n    old_logging = mr->vga_logging_count;\n    mr->vga_logging_count += log ? 1 : -1;\n    if (!!old_logging == !!mr->vga_logging_count) {\n        return;\n    }\n\n    memory_region_transaction_begin();\n    mr->dirty_log_mask = (mr->dirty_log_mask & ~mask) | (log * mask);\n    memory_region_update_pending |= mr->enabled;\n    memory_region_transaction_commit();\n}\n\nbool memory_region_get_dirty(MemoryRegion *mr, hwaddr addr,\n                             hwaddr size, unsigned client)\n{\n    assert(mr->ram_block);\n    return cpu_physical_memory_get_dirty(memory_region_get_ram_addr(mr) + addr,\n                                         size, client);\n}\n\nvoid memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n                             hwaddr size)\n{\n    assert(mr->ram_block);\n    cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,\n                                        size,\n                                        memory_region_get_dirty_log_mask(mr));\n}\n\nbool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n                                        hwaddr size, unsigned client)\n{\n    assert(mr->ram_block);\n    return cpu_physical_memory_test_and_clear_dirty(\n                memory_region_get_ram_addr(mr) + addr, size, client);\n}\n\n\nvoid memory_region_sync_dirty_bitmap(MemoryRegion *mr)\n{\n    MemoryListener *listener;\n    AddressSpace *as;\n    FlatView *view;\n    FlatRange *fr;\n\n    /* If the same address space has multiple log_sync listeners, we\n     * visit that address space's FlatView multiple times.  But because\n     * log_sync listeners are rare, it's still cheaper than walking each\n     * address space once.\n     */\n    QTAILQ_FOREACH(listener, &memory_listeners, link) {\n        if (!listener->log_sync) {\n            continue;\n        }\n        as = listener->address_space;\n        view = address_space_get_flatview(as);\n        FOR_EACH_FLAT_RANGE(fr, view) {\n            if (fr->mr == mr) {\n                MemoryRegionSection mrs = section_from_flat_range(fr, as);\n                listener->log_sync(listener, &mrs);\n            }\n        }\n        flatview_unref(view);\n    }\n}\n\nvoid memory_region_set_readonly(MemoryRegion *mr, bool readonly)\n{\n    if (mr->readonly != readonly) {\n        memory_region_transaction_begin();\n        mr->readonly = readonly;\n        memory_region_update_pending |= mr->enabled;\n        memory_region_transaction_commit();\n    }\n}\n\nvoid memory_region_rom_device_set_romd(MemoryRegion *mr, bool romd_mode)\n{\n    if (mr->romd_mode != romd_mode) {\n        memory_region_transaction_begin();\n        mr->romd_mode = romd_mode;\n        memory_region_update_pending |= mr->enabled;\n        memory_region_transaction_commit();\n    }\n}\n\nvoid memory_region_reset_dirty(MemoryRegion *mr, hwaddr addr,\n                               hwaddr size, unsigned client)\n{\n    assert(mr->ram_block);\n    cpu_physical_memory_test_and_clear_dirty(\n        memory_region_get_ram_addr(mr) + addr, size, client);\n}\n\nint memory_region_get_fd(MemoryRegion *mr)\n{\n    int fd;\n\n    rcu_read_lock();\n    while (mr->alias) {\n        mr = mr->alias;\n    }\n    fd = mr->ram_block->fd;\n    rcu_read_unlock();\n\n    return fd;\n}\n\nvoid memory_region_set_fd(MemoryRegion *mr, int fd)\n{\n    rcu_read_lock();\n    while (mr->alias) {\n        mr = mr->alias;\n    }\n    mr->ram_block->fd = fd;\n    rcu_read_unlock();\n}\n\nvoid *memory_region_get_ram_ptr(MemoryRegion *mr)\n{\n    void *ptr;\n    uint64_t offset = 0;\n\n    rcu_read_lock();\n    while (mr->alias) {\n        offset += mr->alias_offset;\n        mr = mr->alias;\n    }\n    assert(mr->ram_block);\n    ptr = qemu_map_ram_ptr(mr->ram_block, offset);\n    rcu_read_unlock();\n\n    return ptr;\n}\n\nMemoryRegion *memory_region_from_host(void *ptr, ram_addr_t *offset)\n{\n    RAMBlock *block;\n\n    block = qemu_ram_block_from_host(ptr, false, offset);\n    if (!block) {\n        return NULL;\n    }\n\n    return block->mr;\n}\n\nram_addr_t memory_region_get_ram_addr(MemoryRegion *mr)\n{\n    return mr->ram_block ? mr->ram_block->offset : RAM_ADDR_INVALID;\n}\n\nvoid memory_region_ram_resize(MemoryRegion *mr, ram_addr_t newsize, Error **errp)\n{\n    assert(mr->ram_block);\n\n    qemu_ram_resize(mr->ram_block, newsize, errp);\n}\n\nstatic void memory_region_update_coalesced_range_as(MemoryRegion *mr, AddressSpace *as)\n{\n    FlatView *view;\n    FlatRange *fr;\n    CoalescedMemoryRange *cmr;\n    AddrRange tmp;\n    MemoryRegionSection section;\n\n    view = address_space_get_flatview(as);\n    FOR_EACH_FLAT_RANGE(fr, view) {\n        if (fr->mr == mr) {\n            section = (MemoryRegionSection) {\n                .address_space = as,\n                .offset_within_address_space = int128_get64(fr->addr.start),\n                .size = fr->addr.size,\n            };\n\n            MEMORY_LISTENER_CALL(as, coalesced_mmio_del, Reverse, &section,\n                                 int128_get64(fr->addr.start),\n                                 int128_get64(fr->addr.size));\n            QTAILQ_FOREACH(cmr, &mr->coalesced, link) {\n                tmp = addrrange_shift(cmr->addr,\n                                      int128_sub(fr->addr.start,\n                                                 int128_make64(fr->offset_in_region)));\n                if (!addrrange_intersects(tmp, fr->addr)) {\n                    continue;\n                }\n                tmp = addrrange_intersection(tmp, fr->addr);\n                MEMORY_LISTENER_CALL(as, coalesced_mmio_add, Forward, &section,\n                                     int128_get64(tmp.start),\n                                     int128_get64(tmp.size));\n            }\n        }\n    }\n    flatview_unref(view);\n}\n\nstatic void memory_region_update_coalesced_range(MemoryRegion *mr)\n{\n    AddressSpace *as;\n\n    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n        memory_region_update_coalesced_range_as(mr, as);\n    }\n}\n\nvoid memory_region_set_coalescing(MemoryRegion *mr)\n{\n    memory_region_clear_coalescing(mr);\n    memory_region_add_coalescing(mr, 0, int128_get64(mr->size));\n}\n\nvoid memory_region_add_coalescing(MemoryRegion *mr,\n                                  hwaddr offset,\n                                  uint64_t size)\n{\n    CoalescedMemoryRange *cmr = g_malloc(sizeof(*cmr));\n\n    cmr->addr = addrrange_make(int128_make64(offset), int128_make64(size));\n    QTAILQ_INSERT_TAIL(&mr->coalesced, cmr, link);\n    memory_region_update_coalesced_range(mr);\n    memory_region_set_flush_coalesced(mr);\n}\n\nvoid memory_region_clear_coalescing(MemoryRegion *mr)\n{\n    CoalescedMemoryRange *cmr;\n    bool updated = false;\n\n    qemu_flush_coalesced_mmio_buffer();\n    mr->flush_coalesced_mmio = false;\n\n    while (!QTAILQ_EMPTY(&mr->coalesced)) {\n        cmr = QTAILQ_FIRST(&mr->coalesced);\n        QTAILQ_REMOVE(&mr->coalesced, cmr, link);\n        g_free(cmr);\n        updated = true;\n    }\n\n    if (updated) {\n        memory_region_update_coalesced_range(mr);\n    }\n}\n\nvoid memory_region_set_flush_coalesced(MemoryRegion *mr)\n{\n    mr->flush_coalesced_mmio = true;\n}\n\nvoid memory_region_clear_flush_coalesced(MemoryRegion *mr)\n{\n    qemu_flush_coalesced_mmio_buffer();\n    if (QTAILQ_EMPTY(&mr->coalesced)) {\n        mr->flush_coalesced_mmio = false;\n    }\n}\n\nvoid memory_region_set_global_locking(MemoryRegion *mr)\n{\n    mr->global_locking = true;\n}\n\nvoid memory_region_clear_global_locking(MemoryRegion *mr)\n{\n    mr->global_locking = false;\n}\n\nstatic bool userspace_eventfd_warning;\n\nvoid memory_region_add_eventfd(MemoryRegion *mr,\n                               hwaddr addr,\n                               unsigned size,\n                               bool match_data,\n                               uint64_t data,\n                               EventNotifier *e)\n{\n    MemoryRegionIoeventfd mrfd = {\n        .addr.start = int128_make64(addr),\n        .addr.size = int128_make64(size),\n        .match_data = match_data,\n        .data = data,\n        .e = e,\n    };\n    unsigned i;\n\n    if (kvm_enabled() && (!(kvm_eventfds_enabled() ||\n                            userspace_eventfd_warning))) {\n        userspace_eventfd_warning = true;\n        error_report(\"Using eventfd without MMIO binding in KVM. \"\n                     \"Suboptimal performance expected\");\n    }\n\n    if (size) {\n        adjust_endianness(mr, &mrfd.data, size);\n    }\n    memory_region_transaction_begin();\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n            break;\n        }\n    }\n    ++mr->ioeventfd_nb;\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n    mr->ioeventfds[i] = mrfd;\n    ioeventfd_update_pending |= mr->enabled;\n    memory_region_transaction_commit();\n}\n\nvoid memory_region_del_eventfd(MemoryRegion *mr,\n                               hwaddr addr,\n                               unsigned size,\n                               bool match_data,\n                               uint64_t data,\n                               EventNotifier *e)\n{\n    MemoryRegionIoeventfd mrfd = {\n        .addr.start = int128_make64(addr),\n        .addr.size = int128_make64(size),\n        .match_data = match_data,\n        .data = data,\n        .e = e,\n    };\n    unsigned i;\n\n    if (size) {\n        adjust_endianness(mr, &mrfd.data, size);\n    }\n    memory_region_transaction_begin();\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n        if (memory_region_ioeventfd_equal(mrfd, mr->ioeventfds[i])) {\n            break;\n        }\n    }\n    assert(i != mr->ioeventfd_nb);\n    memmove(&mr->ioeventfds[i], &mr->ioeventfds[i+1],\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));\n    --mr->ioeventfd_nb;\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n                                  sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);\n    ioeventfd_update_pending |= mr->enabled;\n    memory_region_transaction_commit();\n}\n\nstatic void memory_region_update_container_subregions(MemoryRegion *subregion)\n{\n    MemoryRegion *mr = subregion->container;\n    MemoryRegion *other;\n\n    memory_region_transaction_begin();\n\n    memory_region_ref(subregion);\n    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {\n        if (subregion->priority >= other->priority) {\n            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);\n            goto done;\n        }\n    }\n    QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);\ndone:\n    memory_region_update_pending |= mr->enabled && subregion->enabled;\n    memory_region_transaction_commit();\n}\n\nstatic void memory_region_add_subregion_common(MemoryRegion *mr,\n                                               hwaddr offset,\n                                               MemoryRegion *subregion)\n{\n    assert(!subregion->container);\n    subregion->container = mr;\n    subregion->addr = offset;\n    memory_region_update_container_subregions(subregion);\n}\n\nvoid memory_region_add_subregion(MemoryRegion *mr,\n                                 hwaddr offset,\n                                 MemoryRegion *subregion)\n{\n    subregion->priority = 0;\n    memory_region_add_subregion_common(mr, offset, subregion);\n}\n\nvoid memory_region_add_subregion_overlap(MemoryRegion *mr,\n                                         hwaddr offset,\n                                         MemoryRegion *subregion,\n                                         int priority)\n{\n    subregion->priority = priority;\n    memory_region_add_subregion_common(mr, offset, subregion);\n}\n\nvoid memory_region_del_subregion(MemoryRegion *mr,\n                                 MemoryRegion *subregion)\n{\n    memory_region_transaction_begin();\n    assert(subregion->container == mr);\n    subregion->container = NULL;\n    QTAILQ_REMOVE(&mr->subregions, subregion, subregions_link);\n    memory_region_unref(subregion);\n    memory_region_update_pending |= mr->enabled && subregion->enabled;\n    memory_region_transaction_commit();\n}\n\nvoid memory_region_set_enabled(MemoryRegion *mr, bool enabled)\n{\n    if (enabled == mr->enabled) {\n        return;\n    }\n    memory_region_transaction_begin();\n    mr->enabled = enabled;\n    memory_region_update_pending = true;\n    memory_region_transaction_commit();\n}\n\nvoid memory_region_set_size(MemoryRegion *mr, uint64_t size)\n{\n    Int128 s = int128_make64(size);\n\n    if (size == UINT64_MAX) {\n        s = int128_2_64();\n    }\n    if (int128_eq(s, mr->size)) {\n        return;\n    }\n    memory_region_transaction_begin();\n    mr->size = s;\n    memory_region_update_pending = true;\n    memory_region_transaction_commit();\n}\n\nstatic void memory_region_readd_subregion(MemoryRegion *mr)\n{\n    MemoryRegion *container = mr->container;\n\n    if (container) {\n        memory_region_transaction_begin();\n        memory_region_ref(mr);\n        memory_region_del_subregion(container, mr);\n        mr->container = container;\n        memory_region_update_container_subregions(mr);\n        memory_region_unref(mr);\n        memory_region_transaction_commit();\n    }\n}\n\nvoid memory_region_set_address(MemoryRegion *mr, hwaddr addr)\n{\n    if (addr != mr->addr) {\n        mr->addr = addr;\n        memory_region_readd_subregion(mr);\n    }\n}\n\nvoid memory_region_set_alias_offset(MemoryRegion *mr, hwaddr offset)\n{\n    assert(mr->alias);\n\n    if (offset == mr->alias_offset) {\n        return;\n    }\n\n    memory_region_transaction_begin();\n    mr->alias_offset = offset;\n    memory_region_update_pending |= mr->enabled;\n    memory_region_transaction_commit();\n}\n\nuint64_t memory_region_get_alignment(const MemoryRegion *mr)\n{\n    return mr->align;\n}\n\nstatic int cmp_flatrange_addr(const void *addr_, const void *fr_)\n{\n    const AddrRange *addr = addr_;\n    const FlatRange *fr = fr_;\n\n    if (int128_le(addrrange_end(*addr), fr->addr.start)) {\n        return -1;\n    } else if (int128_ge(addr->start, addrrange_end(fr->addr))) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic FlatRange *flatview_lookup(FlatView *view, AddrRange addr)\n{\n    return bsearch(&addr, view->ranges, view->nr,\n                   sizeof(FlatRange), cmp_flatrange_addr);\n}\n\nbool memory_region_is_mapped(MemoryRegion *mr)\n{\n    return mr->container ? true : false;\n}\n\n/* Same as memory_region_find, but it does not add a reference to the\n * returned region.  It must be called from an RCU critical section.\n */\nstatic MemoryRegionSection memory_region_find_rcu(MemoryRegion *mr,\n                                                  hwaddr addr, uint64_t size)\n{\n    MemoryRegionSection ret = { .mr = NULL };\n    MemoryRegion *root;\n    AddressSpace *as;\n    AddrRange range;\n    FlatView *view;\n    FlatRange *fr;\n\n    addr += mr->addr;\n    for (root = mr; root->container; ) {\n        root = root->container;\n        addr += root->addr;\n    }\n\n    as = memory_region_to_address_space(root);\n    if (!as) {\n        return ret;\n    }\n    range = addrrange_make(int128_make64(addr), int128_make64(size));\n\n    view = atomic_rcu_read(&as->current_map);\n    fr = flatview_lookup(view, range);\n    if (!fr) {\n        return ret;\n    }\n\n    while (fr > view->ranges && addrrange_intersects(fr[-1].addr, range)) {\n        --fr;\n    }\n\n    ret.mr = fr->mr;\n    ret.address_space = as;\n    range = addrrange_intersection(range, fr->addr);\n    ret.offset_within_region = fr->offset_in_region;\n    ret.offset_within_region += int128_get64(int128_sub(range.start,\n                                                        fr->addr.start));\n    ret.size = range.size;\n    ret.offset_within_address_space = int128_get64(range.start);\n    ret.readonly = fr->readonly;\n    return ret;\n}\n\nMemoryRegionSection memory_region_find(MemoryRegion *mr,\n                                       hwaddr addr, uint64_t size)\n{\n    MemoryRegionSection ret;\n    rcu_read_lock();\n    ret = memory_region_find_rcu(mr, addr, size);\n    if (ret.mr) {\n        memory_region_ref(ret.mr);\n    }\n    rcu_read_unlock();\n    return ret;\n}\n\nbool memory_region_present(MemoryRegion *container, hwaddr addr)\n{\n    MemoryRegion *mr;\n\n    rcu_read_lock();\n    mr = memory_region_find_rcu(container, addr, 1).mr;\n    rcu_read_unlock();\n    return mr && mr != container;\n}\n\nvoid memory_global_dirty_log_sync(void)\n{\n    MemoryListener *listener;\n    AddressSpace *as;\n    FlatView *view;\n    FlatRange *fr;\n\n    QTAILQ_FOREACH(listener, &memory_listeners, link) {\n        if (!listener->log_sync) {\n            continue;\n        }\n        as = listener->address_space;\n        view = address_space_get_flatview(as);\n        FOR_EACH_FLAT_RANGE(fr, view) {\n            if (fr->dirty_log_mask) {\n                MemoryRegionSection mrs = section_from_flat_range(fr, as);\n                listener->log_sync(listener, &mrs);\n            }\n        }\n        flatview_unref(view);\n    }\n}\n\nvoid memory_global_dirty_log_start(void)\n{\n    global_dirty_log = true;\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_start, Forward);\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n    memory_region_transaction_begin();\n    memory_region_update_pending = true;\n    memory_region_transaction_commit();\n}\n\nvoid memory_global_dirty_log_stop(void)\n{\n    global_dirty_log = false;\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n    memory_region_transaction_begin();\n    memory_region_update_pending = true;\n    memory_region_transaction_commit();\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n}\n\nstatic void listener_add_address_space(MemoryListener *listener,\n                                       AddressSpace *as)\n{\n    FlatView *view;\n    FlatRange *fr;\n\n    if (listener->begin) {\n        listener->begin(listener);\n    }\n    if (global_dirty_log) {\n        if (listener->log_global_start) {\n            listener->log_global_start(listener);\n        }\n    }\n\n    view = address_space_get_flatview(as);\n    FOR_EACH_FLAT_RANGE(fr, view) {\n        MemoryRegionSection section = {\n            .mr = fr->mr,\n            .address_space = as,\n            .offset_within_region = fr->offset_in_region,\n            .size = fr->addr.size,\n            .offset_within_address_space = int128_get64(fr->addr.start),\n            .readonly = fr->readonly,\n        };\n        if (fr->dirty_log_mask && listener->log_start) {\n            listener->log_start(listener, &section, 0, fr->dirty_log_mask);\n        }\n        if (listener->region_add) {\n            listener->region_add(listener, &section);\n        }\n    }\n    if (listener->commit) {\n        listener->commit(listener);\n    }\n    flatview_unref(view);\n}\n\nvoid memory_listener_register(MemoryListener *listener, AddressSpace *as)\n{\n    MemoryListener *other = NULL;\n\n    listener->address_space = as;\n    if (QTAILQ_EMPTY(&memory_listeners)\n        || listener->priority >= QTAILQ_LAST(&memory_listeners,\n                                             memory_listeners)->priority) {\n        QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);\n    } else {\n        QTAILQ_FOREACH(other, &memory_listeners, link) {\n            if (listener->priority < other->priority) {\n                break;\n            }\n        }\n        QTAILQ_INSERT_BEFORE(other, listener, link);\n    }\n\n    if (QTAILQ_EMPTY(&as->listeners)\n        || listener->priority >= QTAILQ_LAST(&as->listeners,\n                                             memory_listeners)->priority) {\n        QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);\n    } else {\n        QTAILQ_FOREACH(other, &as->listeners, link_as) {\n            if (listener->priority < other->priority) {\n                break;\n            }\n        }\n        QTAILQ_INSERT_BEFORE(other, listener, link_as);\n    }\n\n    listener_add_address_space(listener, as);\n}\n\nvoid memory_listener_unregister(MemoryListener *listener)\n{\n    if (!listener->address_space) {\n        return;\n    }\n\n    QTAILQ_REMOVE(&memory_listeners, listener, link);\n    QTAILQ_REMOVE(&listener->address_space->listeners, listener, link_as);\n    listener->address_space = NULL;\n}\n\nvoid address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)\n{\n    memory_region_ref(root);\n    memory_region_transaction_begin();\n    as->ref_count = 1;\n    as->root = root;\n    as->malloced = false;\n    as->current_map = g_new(FlatView, 1);\n    flatview_init(as->current_map);\n    as->ioeventfd_nb = 0;\n    as->ioeventfds = NULL;\n    QTAILQ_INIT(&as->listeners);\n    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);\n    as->name = g_strdup(name ? name : \"anonymous\");\n    address_space_init_dispatch(as);\n    memory_region_update_pending |= root->enabled;\n    memory_region_transaction_commit();\n}\n\nstatic void do_address_space_destroy(AddressSpace *as)\n{\n    bool do_free = as->malloced;\n\n    address_space_destroy_dispatch(as);\n    assert(QTAILQ_EMPTY(&as->listeners));\n\n    flatview_unref(as->current_map);\n    g_free(as->name);\n    g_free(as->ioeventfds);\n    memory_region_unref(as->root);\n    if (do_free) {\n        g_free(as);\n    }\n}\n\nAddressSpace *address_space_init_shareable(MemoryRegion *root, const char *name)\n{\n    AddressSpace *as;\n\n    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n        if (root == as->root && as->malloced) {\n            as->ref_count++;\n            return as;\n        }\n    }\n\n    as = g_malloc0(sizeof *as);\n    address_space_init(as, root, name);\n    as->malloced = true;\n    return as;\n}\n\nvoid address_space_destroy(AddressSpace *as)\n{\n    MemoryRegion *root = as->root;\n\n    as->ref_count--;\n    if (as->ref_count) {\n        return;\n    }\n    /* Flush out anything from MemoryListeners listening in on this */\n    memory_region_transaction_begin();\n    as->root = NULL;\n    memory_region_transaction_commit();\n    QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);\n    address_space_unregister(as);\n\n    /* At this point, as->dispatch and as->current_map are dummy\n     * entries that the guest should never use.  Wait for the old\n     * values to expire before freeing the data.\n     */\n    as->root = root;\n    call_rcu(as, do_address_space_destroy, rcu);\n}\n\nstatic const char *memory_region_type(MemoryRegion *mr)\n{\n    if (memory_region_is_ram_device(mr)) {\n        return \"ramd\";\n    } else if (memory_region_is_romd(mr)) {\n        return \"romd\";\n    } else if (memory_region_is_rom(mr)) {\n        return \"rom\";\n    } else if (memory_region_is_ram(mr)) {\n        return \"ram\";\n    } else {\n        return \"i/o\";\n    }\n}\n\ntypedef struct MemoryRegionList MemoryRegionList;\n\nstruct MemoryRegionList {\n    const MemoryRegion *mr;\n    QTAILQ_ENTRY(MemoryRegionList) queue;\n};\n\ntypedef QTAILQ_HEAD(queue, MemoryRegionList) MemoryRegionListHead;\n\n#define MR_SIZE(size) (int128_nz(size) ? (hwaddr)int128_get64( \\\n                           int128_sub((size), int128_one())) : 0)\n#define MTREE_INDENT \"  \"\n\nstatic void mtree_print_mr(fprintf_function mon_printf, void *f,\n                           const MemoryRegion *mr, unsigned int level,\n                           hwaddr base,\n                           MemoryRegionListHead *alias_print_queue)\n{\n    MemoryRegionList *new_ml, *ml, *next_ml;\n    MemoryRegionListHead submr_print_queue;\n    const MemoryRegion *submr;\n    unsigned int i;\n    hwaddr cur_start, cur_end;\n\n    if (!mr) {\n        return;\n    }\n\n    for (i = 0; i < level; i++) {\n        mon_printf(f, MTREE_INDENT);\n    }\n\n    cur_start = base + mr->addr;\n    cur_end = cur_start + MR_SIZE(mr->size);\n\n    /*\n     * Try to detect overflow of memory region. This should never\n     * happen normally. When it happens, we dump something to warn the\n     * user who is observing this.\n     */\n    if (cur_start < base || cur_end < cur_start) {\n        mon_printf(f, \"[DETECTED OVERFLOW!] \");\n    }\n\n    if (mr->alias) {\n        MemoryRegionList *ml;\n        bool found = false;\n\n        /* check if the alias is already in the queue */\n        QTAILQ_FOREACH(ml, alias_print_queue, queue) {\n            if (ml->mr == mr->alias) {\n                found = true;\n            }\n        }\n\n        if (!found) {\n            ml = g_new(MemoryRegionList, 1);\n            ml->mr = mr->alias;\n            QTAILQ_INSERT_TAIL(alias_print_queue, ml, queue);\n        }\n        mon_printf(f, TARGET_FMT_plx \"-\" TARGET_FMT_plx\n                   \" (prio %d, %s): alias %s @%s \" TARGET_FMT_plx\n                   \"-\" TARGET_FMT_plx \"%s\\n\",\n                   cur_start, cur_end,\n                   mr->priority,\n                   memory_region_type((MemoryRegion *)mr),\n                   memory_region_name(mr),\n                   memory_region_name(mr->alias),\n                   mr->alias_offset,\n                   mr->alias_offset + MR_SIZE(mr->size),\n                   mr->enabled ? \"\" : \" [disabled]\");\n    } else {\n        mon_printf(f,\n                   TARGET_FMT_plx \"-\" TARGET_FMT_plx \" (prio %d, %s): %s%s\\n\",\n                   cur_start, cur_end,\n                   mr->priority,\n                   memory_region_type((MemoryRegion *)mr),\n                   memory_region_name(mr),\n                   mr->enabled ? \"\" : \" [disabled]\");\n    }\n\n    QTAILQ_INIT(&submr_print_queue);\n\n    QTAILQ_FOREACH(submr, &mr->subregions, subregions_link) {\n        new_ml = g_new(MemoryRegionList, 1);\n        new_ml->mr = submr;\n        QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n            if (new_ml->mr->addr < ml->mr->addr ||\n                (new_ml->mr->addr == ml->mr->addr &&\n                 new_ml->mr->priority > ml->mr->priority)) {\n                QTAILQ_INSERT_BEFORE(ml, new_ml, queue);\n                new_ml = NULL;\n                break;\n            }\n        }\n        if (new_ml) {\n            QTAILQ_INSERT_TAIL(&submr_print_queue, new_ml, queue);\n        }\n    }\n\n    QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n        mtree_print_mr(mon_printf, f, ml->mr, level + 1, cur_start,\n                       alias_print_queue);\n    }\n\n    QTAILQ_FOREACH_SAFE(ml, &submr_print_queue, queue, next_ml) {\n        g_free(ml);\n    }\n}\n\nstatic void mtree_print_flatview(fprintf_function p, void *f,\n                                 AddressSpace *as)\n{\n    FlatView *view = address_space_get_flatview(as);\n    FlatRange *range = &view->ranges[0];\n    MemoryRegion *mr;\n    int n = view->nr;\n\n    if (n <= 0) {\n        p(f, MTREE_INDENT \"No rendered FlatView for \"\n          \"address space '%s'\\n\", as->name);\n        flatview_unref(view);\n        return;\n    }\n\n    while (n--) {\n        mr = range->mr;\n        if (range->offset_in_region) {\n            p(f, MTREE_INDENT TARGET_FMT_plx \"-\"\n              TARGET_FMT_plx \" (prio %d, %s): %s @\" TARGET_FMT_plx \"\\n\",\n              int128_get64(range->addr.start),\n              int128_get64(range->addr.start) + MR_SIZE(range->addr.size),\n              mr->priority,\n              range->readonly ? \"rom\" : memory_region_type(mr),\n              memory_region_name(mr),\n              range->offset_in_region);\n        } else {\n            p(f, MTREE_INDENT TARGET_FMT_plx \"-\"\n              TARGET_FMT_plx \" (prio %d, %s): %s\\n\",\n              int128_get64(range->addr.start),\n              int128_get64(range->addr.start) + MR_SIZE(range->addr.size),\n              mr->priority,\n              range->readonly ? \"rom\" : memory_region_type(mr),\n              memory_region_name(mr));\n        }\n        range++;\n    }\n\n    flatview_unref(view);\n}\n\nvoid mtree_info(fprintf_function mon_printf, void *f, bool flatview)\n{\n    MemoryRegionListHead ml_head;\n    MemoryRegionList *ml, *ml2;\n    AddressSpace *as;\n\n    if (flatview) {\n        QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n            mon_printf(f, \"address-space (flat view): %s\\n\", as->name);\n            mtree_print_flatview(mon_printf, f, as);\n            mon_printf(f, \"\\n\");\n        }\n        return;\n    }\n\n    QTAILQ_INIT(&ml_head);\n\n    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n        mon_printf(f, \"address-space: %s\\n\", as->name);\n        mtree_print_mr(mon_printf, f, as->root, 1, 0, &ml_head);\n        mon_printf(f, \"\\n\");\n    }\n\n    /* print aliased regions */\n    QTAILQ_FOREACH(ml, &ml_head, queue) {\n        mon_printf(f, \"memory-region: %s\\n\", memory_region_name(ml->mr));\n        mtree_print_mr(mon_printf, f, ml->mr, 1, 0, &ml_head);\n        mon_printf(f, \"\\n\");\n    }\n\n    QTAILQ_FOREACH_SAFE(ml, &ml_head, queue, ml2) {\n        g_free(ml);\n    }\n}\n\nstatic const TypeInfo memory_region_info = {\n    .parent             = TYPE_OBJECT,\n    .name               = TYPE_MEMORY_REGION,\n    .instance_size      = sizeof(MemoryRegion),\n    .instance_init      = memory_region_initfn,\n    .instance_finalize  = memory_region_finalize,\n};\n\nstatic void memory_register_types(void)\n{\n    type_register_static(&memory_region_info);\n}\n\ntype_init(memory_register_types)\n"
        },
        {
          "name": "memory_ldst.inc.c",
          "type": "blob",
          "size": 22.421875,
          "content": "/*\n *  Physical memory access templates\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *  Copyright (c) 2015 Linaro, Inc.\n *  Copyright (c) 2016 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/* warning: addr must be aligned */\nstatic inline uint32_t glue(address_space_ldl_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false);\n    if (l < 4 || !IS_DIRECT(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        RR_DO_RECORD_OR_REPLAY(\n            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 4, attrs),\n            /*record*/   rr_input_4(&r); rr_input_8(&val),\n            /*replay*/   rr_input_4(&r); rr_input_8(&val),\n            /*location*/ RR_CALLSITE_READ_4);\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap32(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap32(val);\n        }\n#endif\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = ldl_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = ldl_be_p(ptr);\n            break;\n        default:\n            val = ldl_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint32_t glue(address_space_ldl, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_NATIVE_ENDIAN);\n}\n\nuint32_t glue(address_space_ldl_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_LITTLE_ENDIAN);\n}\n\nuint32_t glue(address_space_ldl_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_BIG_ENDIAN);\n}\n\nuint32_t glue(ldl_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldl, SUFFIX)(ARG1, addr,\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint32_t glue(ldl_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldl_le, SUFFIX)(ARG1, addr,\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint32_t glue(ldl_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldl_be, SUFFIX)(ARG1, addr,\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n/* warning: addr must be aligned */\nstatic inline uint64_t glue(address_space_ldq_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 8;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false);\n    if (l < 8 || !IS_DIRECT(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        RR_DO_RECORD_OR_REPLAY(\n            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 8, attrs),\n            /*record*/   rr_input_4(&r); rr_input_8(&val),\n            /*replay*/   rr_input_4(&r); rr_input_8(&val),\n            /*location*/ RR_CALLSITE_READ_8);\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap64(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap64(val);\n        }\n#endif\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = ldq_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = ldq_be_p(ptr);\n            break;\n        default:\n            val = ldq_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint64_t glue(address_space_ldq, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_NATIVE_ENDIAN);\n}\n\nuint64_t glue(address_space_ldq_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_LITTLE_ENDIAN);\n}\n\nuint64_t glue(address_space_ldq_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_BIG_ENDIAN);\n}\n\nuint64_t glue(ldq_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldq, SUFFIX)(ARG1, addr,\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint64_t glue(ldq_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldq_le, SUFFIX)(ARG1, addr,\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint64_t glue(ldq_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldq_be, SUFFIX)(ARG1, addr,\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint32_t glue(address_space_ldub, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false);\n    if (!IS_DIRECT(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        RR_DO_RECORD_OR_REPLAY(\n            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 1, attrs),\n            /*record*/   rr_input_4(&r); rr_input_8(&val),\n            /*replay*/   rr_input_4(&r); rr_input_8(&val),\n            /*location*/ RR_CALLSITE_READ_1);\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        val = ldub_p(ptr);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint32_t glue(ldub_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_ldub, SUFFIX)(ARG1, addr,\n                                            MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n/* warning: addr must be aligned */\nstatic inline uint32_t glue(address_space_lduw_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 2;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false);\n    if (l < 2 || !IS_DIRECT(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        RR_DO_RECORD_OR_REPLAY(\n            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 2, attrs),\n            /*record*/   rr_input_4(&r); rr_input_8(&val),\n            /*replay*/   rr_input_4(&r); rr_input_8(&val),\n            /*location*/ RR_CALLSITE_READ_2);\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap16(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap16(val);\n        }\n#endif\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = lduw_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = lduw_be_p(ptr);\n            break;\n        default:\n            val = lduw_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint32_t glue(address_space_lduw, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                     DEVICE_NATIVE_ENDIAN);\n}\n\nuint32_t glue(address_space_lduw_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                     DEVICE_LITTLE_ENDIAN);\n}\n\nuint32_t glue(address_space_lduw_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                       DEVICE_BIG_ENDIAN);\n}\n\nuint32_t glue(lduw_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_lduw, SUFFIX)(ARG1, addr,\n                                            MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint32_t glue(lduw_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_lduw_le, SUFFIX)(ARG1, addr,\n                                               MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nuint32_t glue(lduw_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)\n{\n    return glue(address_space_lduw_be, SUFFIX)(ARG1, addr,\n                                               MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n/* warning: addr must be aligned. The ram page is not masked as dirty\n   and the code inside is not invalidated. It is useful if the dirty\n   bits are used to track modified PTEs */\nvoid glue(address_space_stl_notdirty, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    uint8_t dirty_log_mask;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true);\n    if (l < 4 || !IS_DIRECT(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        RR_DO_RECORD_OR_REPLAY(\n        /*action=*/\n        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs),\n        /*record=*/RR_NO_ACTION,\n        /*replay=*/r = MEMTX_OK,\n        /*location=*/RR_CALLSITE_WRITE_4);\n    } else {\n        ptr = MAP_RAM(mr, addr1);\n        stl_p(ptr, val);\n\n        dirty_log_mask = memory_region_get_dirty_log_mask(mr);\n        dirty_log_mask &= ~(1 << DIRTY_MEMORY_CODE);\n        cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,\n                                            4, dirty_log_mask);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(stl_phys_notdirty, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stl_notdirty, SUFFIX)(ARG1, addr, val,\n                                             MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n/* warning: addr must be aligned */\nstatic inline void glue(address_space_stl_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true);\n    if (l < 4 || !IS_DIRECT(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap32(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap32(val);\n        }\n#endif\n        /* Because is_direct is false, these are accesses to an area other\n         * than RAM. That means we want to throw it away on replay. All paths\n         * to this function from guest code don't request a result, so we don't\n         * have to record the result of the memory_region_dispatch_write. The\n         * paths from device code shouldn't happen during replay.\n         */\n        RR_DO_RECORD_OR_REPLAY(\n        /*action=*/\n        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs),\n        /*record=*/RR_NO_ACTION,\n        /*replay=*/r = MEMTX_OK,\n        /*location=*/RR_CALLSITE_WRITE_4);\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stl_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stl_be_p(ptr, val);\n            break;\n        default:\n            stl_p(ptr, val);\n            break;\n        }\n        if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {\n            rr_device_mem_rw_call_record(addr1, ptr, l, /*is_write*/1);\n        }\n        INVALIDATE(mr, addr1, 4);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stl, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stl_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stl_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_BIG_ENDIAN);\n}\n\nvoid glue(stl_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stl, SUFFIX)(ARG1, addr, val,\n                                    MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stl_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stl_le, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stl_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stl_be, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(address_space_stb, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true);\n    if (!IS_DIRECT(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n        RR_DO_RECORD_OR_REPLAY(\n        /*action=*/\n        r = memory_region_dispatch_write(mr, addr1, val, 1, attrs),\n        /*record=*/RR_NO_ACTION,\n        /*replay=*/r = MEMTX_OK,\n        /*location=*/RR_CALLSITE_WRITE_1);\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        stb_p(ptr, val);\n        INVALIDATE(mr, addr1, 1);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(stb_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stb, SUFFIX)(ARG1, addr, val,\n                                    MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n/* warning: addr must be aligned */\nstatic inline void glue(address_space_stw_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 2;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true);\n    if (l < 2 || !IS_DIRECT(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap16(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap16(val);\n        }\n#endif\n        /* See comment in address_space_stl_internal. */\n        RR_DO_RECORD_OR_REPLAY(\n        /*action=*/\n        r = memory_region_dispatch_write(mr, addr1, val, 2, attrs),\n        /*record=*/RR_NO_ACTION,\n        /*replay=*/r = MEMTX_OK,\n        /*location=*/RR_CALLSITE_WRITE_2);\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stw_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stw_be_p(ptr, val);\n            break;\n        default:\n            stw_p(ptr, val);\n            break;\n        }\n        INVALIDATE(mr, addr1, 2);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stw, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stw_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stw_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                               DEVICE_BIG_ENDIAN);\n}\n\nvoid glue(stw_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stw, SUFFIX)(ARG1, addr, val,\n                                    MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stw_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stw_le, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stw_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)\n{\n    glue(address_space_stw_be, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nstatic void glue(address_space_stq_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 8;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true);\n    if (l < 8 || !IS_DIRECT(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n            val = bswap64(val);\n        }\n#else\n        if (endian == DEVICE_BIG_ENDIAN) {\n            val = bswap64(val);\n        }\n#endif\n        /* See comment in address_space_stl_internal. */\n        RR_DO_RECORD_OR_REPLAY(\n        /*action=*/\n        r = memory_region_dispatch_write(mr, addr1, val, 8, attrs),\n        /*record=*/RR_NO_ACTION,\n        /*replay=*/r = MEMTX_OK,\n        /*location=*/RR_CALLSITE_WRITE_8);\n    } else {\n        /* RAM case */\n        ptr = MAP_RAM(mr, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stq_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stq_be_p(ptr, val);\n            break;\n        default:\n            stq_p(ptr, val);\n            break;\n        }\n        INVALIDATE(mr, addr1, 8);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stq, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stq_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stq_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_BIG_ENDIAN);\n}\n\nvoid glue(stq_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)\n{\n    glue(address_space_stq, SUFFIX)(ARG1, addr, val,\n                                    MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stq_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)\n{\n    glue(address_space_stq_le, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\nvoid glue(stq_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)\n{\n    glue(address_space_stq_be, SUFFIX)(ARG1, addr, val,\n                                       MEMTXATTRS_UNSPECIFIED, NULL);\n}\n\n#undef ARG1_DECL\n#undef ARG1\n#undef SUFFIX\n#undef TRANSLATE\n#undef IS_DIRECT\n#undef MAP_RAM\n#undef INVALIDATE\n#undef RCU_READ_LOCK\n#undef RCU_READ_UNLOCK\n"
        },
        {
          "name": "memory_mapping.c",
          "type": "blob",
          "size": 10.521484375,
          "content": "/*\n * QEMU memory mapping\n *\n * Copyright Fujitsu, Corp. 2011, 2012\n *\n * Authors:\n *     Wen Congyang <wency@cn.fujitsu.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"sysemu/memory_mapping.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n\n//#define DEBUG_GUEST_PHYS_REGION_ADD\n\nstatic void memory_mapping_list_add_mapping_sorted(MemoryMappingList *list,\n                                                   MemoryMapping *mapping)\n{\n    MemoryMapping *p;\n\n    QTAILQ_FOREACH(p, &list->head, next) {\n        if (p->phys_addr >= mapping->phys_addr) {\n            QTAILQ_INSERT_BEFORE(p, mapping, next);\n            return;\n        }\n    }\n    QTAILQ_INSERT_TAIL(&list->head, mapping, next);\n}\n\nstatic void create_new_memory_mapping(MemoryMappingList *list,\n                                      hwaddr phys_addr,\n                                      hwaddr virt_addr,\n                                      ram_addr_t length)\n{\n    MemoryMapping *memory_mapping;\n\n    memory_mapping = g_malloc(sizeof(MemoryMapping));\n    memory_mapping->phys_addr = phys_addr;\n    memory_mapping->virt_addr = virt_addr;\n    memory_mapping->length = length;\n    list->last_mapping = memory_mapping;\n    list->num++;\n    memory_mapping_list_add_mapping_sorted(list, memory_mapping);\n}\n\nstatic inline bool mapping_contiguous(MemoryMapping *map,\n                                      hwaddr phys_addr,\n                                      hwaddr virt_addr)\n{\n    return phys_addr == map->phys_addr + map->length &&\n           virt_addr == map->virt_addr + map->length;\n}\n\n/*\n * [map->phys_addr, map->phys_addr + map->length) and\n * [phys_addr, phys_addr + length) have intersection?\n */\nstatic inline bool mapping_have_same_region(MemoryMapping *map,\n                                            hwaddr phys_addr,\n                                            ram_addr_t length)\n{\n    return !(phys_addr + length < map->phys_addr ||\n             phys_addr >= map->phys_addr + map->length);\n}\n\n/*\n * [map->phys_addr, map->phys_addr + map->length) and\n * [phys_addr, phys_addr + length) have intersection. The virtual address in the\n * intersection are the same?\n */\nstatic inline bool mapping_conflict(MemoryMapping *map,\n                                    hwaddr phys_addr,\n                                    hwaddr virt_addr)\n{\n    return virt_addr - map->virt_addr != phys_addr - map->phys_addr;\n}\n\n/*\n * [map->virt_addr, map->virt_addr + map->length) and\n * [virt_addr, virt_addr + length) have intersection. And the physical address\n * in the intersection are the same.\n */\nstatic inline void mapping_merge(MemoryMapping *map,\n                                 hwaddr virt_addr,\n                                 ram_addr_t length)\n{\n    if (virt_addr < map->virt_addr) {\n        map->length += map->virt_addr - virt_addr;\n        map->virt_addr = virt_addr;\n    }\n\n    if ((virt_addr + length) >\n        (map->virt_addr + map->length)) {\n        map->length = virt_addr + length - map->virt_addr;\n    }\n}\n\nvoid memory_mapping_list_add_merge_sorted(MemoryMappingList *list,\n                                          hwaddr phys_addr,\n                                          hwaddr virt_addr,\n                                          ram_addr_t length)\n{\n    MemoryMapping *memory_mapping, *last_mapping;\n\n    if (QTAILQ_EMPTY(&list->head)) {\n        create_new_memory_mapping(list, phys_addr, virt_addr, length);\n        return;\n    }\n\n    last_mapping = list->last_mapping;\n    if (last_mapping) {\n        if (mapping_contiguous(last_mapping, phys_addr, virt_addr)) {\n            last_mapping->length += length;\n            return;\n        }\n    }\n\n    QTAILQ_FOREACH(memory_mapping, &list->head, next) {\n        if (mapping_contiguous(memory_mapping, phys_addr, virt_addr)) {\n            memory_mapping->length += length;\n            list->last_mapping = memory_mapping;\n            return;\n        }\n\n        if (phys_addr + length < memory_mapping->phys_addr) {\n            /* create a new region before memory_mapping */\n            break;\n        }\n\n        if (mapping_have_same_region(memory_mapping, phys_addr, length)) {\n            if (mapping_conflict(memory_mapping, phys_addr, virt_addr)) {\n                continue;\n            }\n\n            /* merge this region into memory_mapping */\n            mapping_merge(memory_mapping, virt_addr, length);\n            list->last_mapping = memory_mapping;\n            return;\n        }\n    }\n\n    /* this region can not be merged into any existed memory mapping. */\n    create_new_memory_mapping(list, phys_addr, virt_addr, length);\n}\n\nvoid memory_mapping_list_free(MemoryMappingList *list)\n{\n    MemoryMapping *p, *q;\n\n    QTAILQ_FOREACH_SAFE(p, &list->head, next, q) {\n        QTAILQ_REMOVE(&list->head, p, next);\n        g_free(p);\n    }\n\n    list->num = 0;\n    list->last_mapping = NULL;\n}\n\nvoid memory_mapping_list_init(MemoryMappingList *list)\n{\n    list->num = 0;\n    list->last_mapping = NULL;\n    QTAILQ_INIT(&list->head);\n}\n\nvoid guest_phys_blocks_free(GuestPhysBlockList *list)\n{\n    GuestPhysBlock *p, *q;\n\n    QTAILQ_FOREACH_SAFE(p, &list->head, next, q) {\n        QTAILQ_REMOVE(&list->head, p, next);\n        memory_region_unref(p->mr);\n        g_free(p);\n    }\n    list->num = 0;\n}\n\nvoid guest_phys_blocks_init(GuestPhysBlockList *list)\n{\n    list->num = 0;\n    QTAILQ_INIT(&list->head);\n}\n\ntypedef struct GuestPhysListener {\n    GuestPhysBlockList *list;\n    MemoryListener listener;\n} GuestPhysListener;\n\nstatic void guest_phys_blocks_region_add(MemoryListener *listener,\n                                         MemoryRegionSection *section)\n{\n    GuestPhysListener *g;\n    uint64_t section_size;\n    hwaddr target_start, target_end;\n    uint8_t *host_addr;\n    GuestPhysBlock *predecessor;\n\n    /* we only care about RAM */\n    if (!memory_region_is_ram(section->mr) ||\n        memory_region_is_ram_device(section->mr)) {\n        return;\n    }\n\n    g            = container_of(listener, GuestPhysListener, listener);\n    section_size = int128_get64(section->size);\n    target_start = section->offset_within_address_space;\n    target_end   = target_start + section_size;\n    host_addr    = memory_region_get_ram_ptr(section->mr) +\n                   section->offset_within_region;\n    predecessor  = NULL;\n\n    /* find continuity in guest physical address space */\n    if (!QTAILQ_EMPTY(&g->list->head)) {\n        hwaddr predecessor_size;\n\n        predecessor = QTAILQ_LAST(&g->list->head, GuestPhysBlockHead);\n        predecessor_size = predecessor->target_end - predecessor->target_start;\n\n        /* the memory API guarantees monotonically increasing traversal */\n        g_assert(predecessor->target_end <= target_start);\n\n        /* we want continuity in both guest-physical and host-virtual memory */\n        if (predecessor->target_end < target_start ||\n            predecessor->host_addr + predecessor_size != host_addr) {\n            predecessor = NULL;\n        }\n    }\n\n    if (predecessor == NULL) {\n        /* isolated mapping, allocate it and add it to the list */\n        GuestPhysBlock *block = g_malloc0(sizeof *block);\n\n        block->target_start = target_start;\n        block->target_end   = target_end;\n        block->host_addr    = host_addr;\n        block->mr           = section->mr;\n        memory_region_ref(section->mr);\n\n        QTAILQ_INSERT_TAIL(&g->list->head, block, next);\n        ++g->list->num;\n    } else {\n        /* expand predecessor until @target_end; predecessor's start doesn't\n         * change\n         */\n        predecessor->target_end = target_end;\n    }\n\n#ifdef DEBUG_GUEST_PHYS_REGION_ADD\n    fprintf(stderr, \"%s: target_start=\" TARGET_FMT_plx \" target_end=\"\n            TARGET_FMT_plx \": %s (count: %u)\\n\", __FUNCTION__, target_start,\n            target_end, predecessor ? \"joined\" : \"added\", g->list->num);\n#endif\n}\n\nvoid guest_phys_blocks_append(GuestPhysBlockList *list)\n{\n    GuestPhysListener g = { 0 };\n\n    g.list = list;\n    g.listener.region_add = &guest_phys_blocks_region_add;\n    memory_listener_register(&g.listener, &address_space_memory);\n    memory_listener_unregister(&g.listener);\n}\n\nstatic CPUState *find_paging_enabled_cpu(CPUState *start_cpu)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu_paging_enabled(cpu)) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\nvoid qemu_get_guest_memory_mapping(MemoryMappingList *list,\n                                   const GuestPhysBlockList *guest_phys_blocks,\n                                   Error **errp)\n{\n    CPUState *cpu, *first_paging_enabled_cpu;\n    GuestPhysBlock *block;\n    ram_addr_t offset, length;\n\n    first_paging_enabled_cpu = find_paging_enabled_cpu(first_cpu);\n    if (first_paging_enabled_cpu) {\n        for (cpu = first_paging_enabled_cpu; cpu != NULL;\n             cpu = CPU_NEXT(cpu)) {\n            Error *err = NULL;\n            cpu_get_memory_mapping(cpu, list, &err);\n            if (err) {\n                error_propagate(errp, err);\n                return;\n            }\n        }\n        return;\n    }\n\n    /*\n     * If the guest doesn't use paging, the virtual address is equal to physical\n     * address.\n     */\n    QTAILQ_FOREACH(block, &guest_phys_blocks->head, next) {\n        offset = block->target_start;\n        length = block->target_end - block->target_start;\n        create_new_memory_mapping(list, offset, offset, length);\n    }\n}\n\nvoid qemu_get_guest_simple_memory_mapping(MemoryMappingList *list,\n                                   const GuestPhysBlockList *guest_phys_blocks)\n{\n    GuestPhysBlock *block;\n\n    QTAILQ_FOREACH(block, &guest_phys_blocks->head, next) {\n        create_new_memory_mapping(list, block->target_start, 0,\n                                  block->target_end - block->target_start);\n    }\n}\n\nvoid memory_mapping_filter(MemoryMappingList *list, int64_t begin,\n                           int64_t length)\n{\n    MemoryMapping *cur, *next;\n\n    QTAILQ_FOREACH_SAFE(cur, &list->head, next, next) {\n        if (cur->phys_addr >= begin + length ||\n            cur->phys_addr + cur->length <= begin) {\n            QTAILQ_REMOVE(&list->head, cur, next);\n            list->num--;\n            continue;\n        }\n\n        if (cur->phys_addr < begin) {\n            cur->length -= begin - cur->phys_addr;\n            if (cur->virt_addr) {\n                cur->virt_addr += begin - cur->phys_addr;\n            }\n            cur->phys_addr = begin;\n        }\n\n        if (cur->phys_addr + cur->length > begin + length) {\n            cur->length -= cur->phys_addr + cur->length - begin - length;\n        }\n    }\n}\n"
        },
        {
          "name": "migration",
          "type": "tree",
          "content": null
        },
        {
          "name": "module-common.c",
          "type": "blob",
          "size": 0.1103515625,
          "content": "#include \"qemu/osdep.h\"\n#include \"qemu/module.h\"\n\nvoid qemu_module_dummy(void)\n{\n}\n\nvoid DSO_STAMP_FUN(void)\n{\n}\n"
        },
        {
          "name": "monitor.c",
          "type": "blob",
          "size": 112.0869140625,
          "content": "/*\n * QEMU monitor\n *\n * Copyright (c) 2003-2004 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include <dirent.h>\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"hw/hw.h\"\n#include \"monitor/qdev.h\"\n#include \"hw/usb.h\"\n#include \"hw/i386/pc.h\"\n#include \"hw/pci/pci.h\"\n#include \"sysemu/watchdog.h\"\n#include \"hw/loader.h\"\n#include \"exec/gdbstub.h\"\n#include \"net/net.h\"\n#include \"net/slirp.h\"\n#include \"sysemu/char.h\"\n#include \"ui/qemu-spice.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/numa.h\"\n#include \"monitor/monitor.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/readline.h\"\n#include \"ui/console.h\"\n#include \"ui/input.h\"\n#include \"sysemu/blockdev.h\"\n#include \"sysemu/block-backend.h\"\n#include \"audio/audio.h\"\n#include \"disas/disas.h\"\n#include \"sysemu/balloon.h\"\n#include \"qemu/timer.h\"\n#include \"migration/migration.h\"\n#include \"sysemu/hw_accel.h\"\n#include \"qemu/acl.h\"\n#include \"sysemu/tpm.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/types.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qapi/qmp/json-streamer.h\"\n#include \"qapi/qmp/json-parser.h\"\n#include \"qom/object_interfaces.h\"\n#include \"trace-root.h\"\n#include \"trace/control.h\"\n#include \"monitor/hmp-target.h\"\n#ifdef CONFIG_TRACE_SIMPLE\n#include \"trace/simple.h\"\n#endif\n#include \"exec/memory.h\"\n#include \"exec/exec-all.h\"\n#include \"qemu/log.h\"\n#include \"qmp-commands.h\"\n#include \"hmp.h\"\n#include \"qemu/thread.h\"\n#include \"block/qapi.h\"\n#include \"qapi/qmp-event.h\"\n#include \"qapi-event.h\"\n#include \"qmp-introspect.h\"\n#include \"sysemu/qtest.h\"\n#include \"sysemu/cpus.h\"\n#include \"qemu/cutils.h\"\n#include \"qapi/qmp/dispatch.h\"\n#include \"chardev/char-panda.h\"\n\n#if defined(TARGET_S390X)\n#include \"hw/s390x/storage-keys.h\"\n#endif\n\n/*\n * Supported types:\n *\n * 'F'          filename\n * 'B'          block device name\n * 's'          string (accept optional quote)\n * 'S'          it just appends the rest of the string (accept optional quote)\n * 'O'          option string of the form NAME=VALUE,...\n *              parsed according to QemuOptsList given by its name\n *              Example: 'device:O' uses qemu_device_opts.\n *              Restriction: only lists with empty desc are supported\n *              TODO lift the restriction\n * 'i'          32 bit integer\n * 'l'          target long (32 or 64 bit)\n * 'M'          Non-negative target long (32 or 64 bit), in user mode the\n *              value is multiplied by 2^20 (think Mebibyte)\n * 'o'          octets (aka bytes)\n *              user mode accepts an optional E, e, P, p, T, t, G, g, M, m,\n *              K, k suffix, which multiplies the value by 2^60 for suffixes E\n *              and e, 2^50 for suffixes P and p, 2^40 for suffixes T and t,\n *              2^30 for suffixes G and g, 2^20 for M and m, 2^10 for K and k\n * 'T'          double\n *              user mode accepts an optional ms, us, ns suffix,\n *              which divides the value by 1e3, 1e6, 1e9, respectively\n * '/'          optional gdb-like print format (like \"/10x\")\n *\n * '?'          optional type (for all types, except '/')\n * '.'          other form of optional type (for 'i' and 'l')\n * 'b'          boolean\n *              user mode accepts \"on\" or \"off\"\n * '-'          optional parameter (eg. '-f')\n *\n */\n\ntypedef struct mon_cmd_t {\n    const char *name;\n    const char *args_type;\n    const char *params;\n    const char *help;\n    void (*cmd)(Monitor *mon, const QDict *qdict);\n    /* @sub_table is a list of 2nd level of commands. If it does not exist,\n     * cmd should be used. If it exists, sub_table[?].cmd should be\n     * used, and cmd of 1st level plays the role of help function.\n     */\n    struct mon_cmd_t *sub_table;\n    void (*command_completion)(ReadLineState *rs, int nb_args, const char *str);\n} mon_cmd_t;\n\n/* file descriptors passed via SCM_RIGHTS */\ntypedef struct mon_fd_t mon_fd_t;\nstruct mon_fd_t {\n    char *name;\n    int fd;\n    QLIST_ENTRY(mon_fd_t) next;\n};\n\n/* file descriptor associated with a file descriptor set */\ntypedef struct MonFdsetFd MonFdsetFd;\nstruct MonFdsetFd {\n    int fd;\n    bool removed;\n    char *opaque;\n    QLIST_ENTRY(MonFdsetFd) next;\n};\n\n/* file descriptor set containing fds passed via SCM_RIGHTS */\ntypedef struct MonFdset MonFdset;\nstruct MonFdset {\n    int64_t id;\n    QLIST_HEAD(, MonFdsetFd) fds;\n    QLIST_HEAD(, MonFdsetFd) dup_fds;\n    QLIST_ENTRY(MonFdset) next;\n};\n\ntypedef struct {\n    JSONMessageParser parser;\n    /*\n     * When a client connects, we're in capabilities negotiation mode.\n     * When command qmp_capabilities succeeds, we go into command\n     * mode.\n     */\n    QmpCommandList *commands;\n} MonitorQMP;\n\n/*\n * To prevent flooding clients, events can be throttled. The\n * throttling is calculated globally, rather than per-Monitor\n * instance.\n */\ntypedef struct MonitorQAPIEventState {\n    QAPIEvent event;    /* Throttling state for this event type and... */\n    QDict *data;        /* ... data, see qapi_event_throttle_equal() */\n    QEMUTimer *timer;   /* Timer for handling delayed events */\n    QDict *qdict;       /* Delayed event (if any) */\n} MonitorQAPIEventState;\n\ntypedef struct {\n    int64_t rate;       /* Minimum time (in ns) between two events */\n} MonitorQAPIEventConf;\n\nstruct Monitor {\n    CharBackend chr;\n    int reset_seen;\n    int flags;\n    int suspend_cnt;\n    bool skip_flush;\n\n    QemuMutex out_lock;\n    QString *outbuf;\n    guint out_watch;\n\n    /* Read under either BQL or out_lock, written with BQL+out_lock.  */\n    int mux_out;\n\n    ReadLineState *rs;\n    MonitorQMP qmp;\n    CPUState *mon_cpu;\n    BlockCompletionFunc *password_completion_cb;\n    void *password_opaque;\n    mon_cmd_t *cmd_table;\n    QLIST_HEAD(,mon_fd_t) fds;\n    QLIST_ENTRY(Monitor) entry;\n};\n\n/* QMP checker flags */\n#define QMP_ACCEPT_UNKNOWNS 1\n\n/* Protects mon_list, monitor_event_state.  */\nstatic QemuMutex monitor_lock;\n\nstatic QLIST_HEAD(mon_list, Monitor) mon_list;\nstatic QLIST_HEAD(mon_fdsets, MonFdset) mon_fdsets;\nstatic int mon_refcount;\n\nstatic mon_cmd_t mon_cmds[];\nstatic mon_cmd_t info_cmds[];\n\nQmpCommandList qmp_commands, qmp_cap_negotiation_commands;\n\nMonitor *cur_mon = NULL;\n\n// global vars for panda monitor and chardev\nPandaChardev *panda_chr = NULL;\nMonitor *panda_mon = NULL;\n\nstatic QEMUClockType event_clock_type = QEMU_CLOCK_REALTIME;\n\nstatic void monitor_command_cb(void *opaque, const char *cmdline,\n                               void *readline_opaque);\n\n/**\n * Is @mon a QMP monitor?\n */\nstatic inline bool monitor_is_qmp(const Monitor *mon)\n{\n    return (mon->flags & MONITOR_USE_CONTROL);\n}\n\n/**\n * Is the current monitor, if any, a QMP monitor?\n */\nbool monitor_cur_is_qmp(void)\n{\n    return cur_mon && monitor_is_qmp(cur_mon);\n}\n\nvoid monitor_read_command(Monitor *mon, int show_prompt)\n{\n    if (!mon->rs)\n        return;\n\n    readline_start(mon->rs, \"(qemu) \", 0, monitor_command_cb, NULL);\n    if (show_prompt)\n        readline_show_prompt(mon->rs);\n}\n\nint monitor_read_password(Monitor *mon, ReadLineFunc *readline_func,\n                          void *opaque)\n{\n    if (mon->rs) {\n        readline_start(mon->rs, \"Password: \", 1, readline_func, opaque);\n        /* prompt is printed on return from the command handler */\n        return 0;\n    } else {\n        monitor_printf(mon, \"terminal does not support password prompting\\n\");\n        return -ENOTTY;\n    }\n}\n\nstatic void monitor_flush_locked(Monitor *mon);\n\nstatic gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n                                  void *opaque)\n{\n    Monitor *mon = opaque;\n\n    qemu_mutex_lock(&mon->out_lock);\n    mon->out_watch = 0;\n    monitor_flush_locked(mon);\n    qemu_mutex_unlock(&mon->out_lock);\n    return FALSE;\n}\n\n/* Called with mon->out_lock held.  */\nstatic void monitor_flush_locked(Monitor *mon)\n{\n    int rc;\n    size_t len;\n    const char *buf;\n\n    if (mon->skip_flush) {\n        return;\n    }\n\n    buf = qstring_get_str(mon->outbuf);\n    len = qstring_get_length(mon->outbuf);\n\n    if (len && !mon->mux_out) {\n        rc = qemu_chr_fe_write(&mon->chr, (const uint8_t *) buf, len);\n        if ((rc < 0 && errno != EAGAIN) || (rc == len)) {\n            /* all flushed or error */\n            QDECREF(mon->outbuf);\n            mon->outbuf = qstring_new();\n            return;\n        }\n        if (rc > 0) {\n            /* partial write */\n            QString *tmp = qstring_from_str(buf + rc);\n            QDECREF(mon->outbuf);\n            mon->outbuf = tmp;\n        }\n        if (mon->out_watch == 0) {\n            mon->out_watch =\n                qemu_chr_fe_add_watch(&mon->chr, G_IO_OUT | G_IO_HUP,\n                                      monitor_unblocked, mon);\n        }\n    }\n}\n\nvoid monitor_flush(Monitor *mon)\n{\n    qemu_mutex_lock(&mon->out_lock);\n    monitor_flush_locked(mon);\n    qemu_mutex_unlock(&mon->out_lock);\n}\n\n/* flush at every end of line */\nstatic void monitor_puts(Monitor *mon, const char *str)\n{\n    char c;\n\n    qemu_mutex_lock(&mon->out_lock);\n    for(;;) {\n        c = *str++;\n        if (c == '\\0')\n            break;\n        if (c == '\\n') {\n            qstring_append_chr(mon->outbuf, '\\r');\n        }\n        qstring_append_chr(mon->outbuf, c);\n        if (c == '\\n') {\n            monitor_flush_locked(mon);\n        }\n    }\n    qemu_mutex_unlock(&mon->out_lock);\n}\n\nvoid monitor_vprintf(Monitor *mon, const char *fmt, va_list ap)\n{\n    char *buf;\n\n    if (!mon)\n        return;\n\n    if (monitor_is_qmp(mon)) {\n        return;\n    }\n\n    buf = g_strdup_vprintf(fmt, ap);\n    monitor_puts(mon, buf);\n    g_free(buf);\n}\n\nvoid monitor_printf(Monitor *mon, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    monitor_vprintf(mon, fmt, ap);\n    va_end(ap);\n}\n\nint monitor_fprintf(FILE *stream, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    monitor_vprintf((Monitor *)stream, fmt, ap);\n    va_end(ap);\n    return 0;\n}\n\nstatic void monitor_json_emitter(Monitor *mon, const QObject *data)\n{\n    QString *json;\n\n    json = mon->flags & MONITOR_USE_PRETTY ? qobject_to_json_pretty(data) :\n                                             qobject_to_json(data);\n    assert(json != NULL);\n\n    qstring_append_chr(json, '\\n');\n    monitor_puts(mon, qstring_get_str(json));\n\n    QDECREF(json);\n}\n\nstatic MonitorQAPIEventConf monitor_qapi_event_conf[QAPI_EVENT__MAX] = {\n    /* Limit guest-triggerable events to 1 per second */\n    [QAPI_EVENT_RTC_CHANGE]        = { 1000 * SCALE_MS },\n    [QAPI_EVENT_WATCHDOG]          = { 1000 * SCALE_MS },\n    [QAPI_EVENT_BALLOON_CHANGE]    = { 1000 * SCALE_MS },\n    [QAPI_EVENT_QUORUM_REPORT_BAD] = { 1000 * SCALE_MS },\n    [QAPI_EVENT_QUORUM_FAILURE]    = { 1000 * SCALE_MS },\n    [QAPI_EVENT_VSERPORT_CHANGE]   = { 1000 * SCALE_MS },\n};\n\nGHashTable *monitor_qapi_event_state;\n\n/*\n * Emits the event to every monitor instance, @event is only used for trace\n * Called with monitor_lock held.\n */\nstatic void monitor_qapi_event_emit(QAPIEvent event, QDict *qdict)\n{\n    Monitor *mon;\n\n    trace_monitor_protocol_event_emit(event, qdict);\n    QLIST_FOREACH(mon, &mon_list, entry) {\n        if (monitor_is_qmp(mon)\n            && mon->qmp.commands != &qmp_cap_negotiation_commands) {\n            monitor_json_emitter(mon, QOBJECT(qdict));\n        }\n    }\n}\n\nstatic void monitor_qapi_event_handler(void *opaque);\n\n/*\n * Queue a new event for emission to Monitor instances,\n * applying any rate limiting if required.\n */\nstatic void\nmonitor_qapi_event_queue(QAPIEvent event, QDict *qdict, Error **errp)\n{\n    MonitorQAPIEventConf *evconf;\n    MonitorQAPIEventState *evstate;\n\n    assert(event < QAPI_EVENT__MAX);\n    evconf = &monitor_qapi_event_conf[event];\n    trace_monitor_protocol_event_queue(event, qdict, evconf->rate);\n\n    qemu_mutex_lock(&monitor_lock);\n\n    if (!evconf->rate) {\n        /* Unthrottled event */\n        monitor_qapi_event_emit(event, qdict);\n    } else {\n        QDict *data = qobject_to_qdict(qdict_get(qdict, \"data\"));\n        MonitorQAPIEventState key = { .event = event, .data = data };\n\n        evstate = g_hash_table_lookup(monitor_qapi_event_state, &key);\n        assert(!evstate || timer_pending(evstate->timer));\n\n        if (evstate) {\n            /*\n             * Timer is pending for (at least) evconf->rate ns after\n             * last send.  Store event for sending when timer fires,\n             * replacing a prior stored event if any.\n             */\n            QDECREF(evstate->qdict);\n            evstate->qdict = qdict;\n            QINCREF(evstate->qdict);\n        } else {\n            /*\n             * Last send was (at least) evconf->rate ns ago.\n             * Send immediately, and arm the timer to call\n             * monitor_qapi_event_handler() in evconf->rate ns.  Any\n             * events arriving before then will be delayed until then.\n             */\n            int64_t now = qemu_clock_get_ns(event_clock_type);\n\n            monitor_qapi_event_emit(event, qdict);\n\n            evstate = g_new(MonitorQAPIEventState, 1);\n            evstate->event = event;\n            evstate->data = data;\n            QINCREF(evstate->data);\n            evstate->qdict = NULL;\n            evstate->timer = timer_new_ns(event_clock_type,\n                                          monitor_qapi_event_handler,\n                                          evstate);\n            g_hash_table_add(monitor_qapi_event_state, evstate);\n            timer_mod_ns(evstate->timer, now + evconf->rate);\n        }\n    }\n\n    qemu_mutex_unlock(&monitor_lock);\n}\n\n/*\n * This function runs evconf->rate ns after sending a throttled\n * event.\n * If another event has since been stored, send it.\n */\nstatic void monitor_qapi_event_handler(void *opaque)\n{\n    MonitorQAPIEventState *evstate = opaque;\n    MonitorQAPIEventConf *evconf = &monitor_qapi_event_conf[evstate->event];\n\n    trace_monitor_protocol_event_handler(evstate->event, evstate->qdict);\n    qemu_mutex_lock(&monitor_lock);\n\n    if (evstate->qdict) {\n        int64_t now = qemu_clock_get_ns(event_clock_type);\n\n        monitor_qapi_event_emit(evstate->event, evstate->qdict);\n        QDECREF(evstate->qdict);\n        evstate->qdict = NULL;\n        timer_mod_ns(evstate->timer, now + evconf->rate);\n    } else {\n        g_hash_table_remove(monitor_qapi_event_state, evstate);\n        QDECREF(evstate->data);\n        timer_free(evstate->timer);\n        g_free(evstate);\n    }\n\n    qemu_mutex_unlock(&monitor_lock);\n}\n\nstatic unsigned int qapi_event_throttle_hash(const void *key)\n{\n    const MonitorQAPIEventState *evstate = key;\n    unsigned int hash = evstate->event * 255;\n\n    if (evstate->event == QAPI_EVENT_VSERPORT_CHANGE) {\n        hash += g_str_hash(qdict_get_str(evstate->data, \"id\"));\n    }\n\n    if (evstate->event == QAPI_EVENT_QUORUM_REPORT_BAD) {\n        hash += g_str_hash(qdict_get_str(evstate->data, \"node-name\"));\n    }\n\n    return hash;\n}\n\nstatic gboolean qapi_event_throttle_equal(const void *a, const void *b)\n{\n    const MonitorQAPIEventState *eva = a;\n    const MonitorQAPIEventState *evb = b;\n\n    if (eva->event != evb->event) {\n        return FALSE;\n    }\n\n    if (eva->event == QAPI_EVENT_VSERPORT_CHANGE) {\n        return !strcmp(qdict_get_str(eva->data, \"id\"),\n                       qdict_get_str(evb->data, \"id\"));\n    }\n\n    if (eva->event == QAPI_EVENT_QUORUM_REPORT_BAD) {\n        return !strcmp(qdict_get_str(eva->data, \"node-name\"),\n                       qdict_get_str(evb->data, \"node-name\"));\n    }\n\n    return TRUE;\n}\n\nstatic void monitor_qapi_event_init(void)\n{\n    if (qtest_enabled()) {\n        event_clock_type = QEMU_CLOCK_VIRTUAL;\n    }\n\n    monitor_qapi_event_state = g_hash_table_new(qapi_event_throttle_hash,\n                                                qapi_event_throttle_equal);\n    qmp_event_set_func_emit(monitor_qapi_event_queue);\n}\n\nstatic void handle_hmp_command(Monitor *mon, const char *cmdline);\n\nstatic void monitor_data_init(Monitor *mon)\n{\n    memset(mon, 0, sizeof(Monitor));\n    qemu_mutex_init(&mon->out_lock);\n    mon->outbuf = qstring_new();\n    /* Use *mon_cmds by default. */\n    mon->cmd_table = mon_cmds;\n}\n\nstatic void monitor_data_destroy(Monitor *mon)\n{\n    qemu_chr_fe_deinit(&mon->chr);\n    if (monitor_is_qmp(mon)) {\n        json_message_parser_destroy(&mon->qmp.parser);\n    }\n    g_free(mon->rs);\n    QDECREF(mon->outbuf);\n    qemu_mutex_destroy(&mon->out_lock);\n}\n\nchar *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,\n                                int64_t cpu_index, Error **errp)\n{\n    char *output = NULL;\n    Monitor *old_mon, hmp;\n\n    monitor_data_init(&hmp);\n    hmp.skip_flush = true;\n\n    old_mon = cur_mon;\n    cur_mon = &hmp;\n\n    if (has_cpu_index) {\n        int ret = monitor_set_cpu(cpu_index);\n        if (ret < 0) {\n            cur_mon = old_mon;\n            error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cpu-index\",\n                       \"a CPU number\");\n            goto out;\n        }\n    }\n\n    handle_hmp_command(&hmp, command_line);\n    cur_mon = old_mon;\n\n    qemu_mutex_lock(&hmp.out_lock);\n    if (qstring_get_length(hmp.outbuf) > 0) {\n        output = g_strdup(qstring_get_str(hmp.outbuf));\n    } else {\n        output = g_strdup(\"\");\n    }\n    qemu_mutex_unlock(&hmp.out_lock);\n\nout:\n    monitor_data_destroy(&hmp);\n    return output;\n}\n\nstatic int compare_cmd(const char *name, const char *list)\n{\n    const char *p, *pstart;\n    int len;\n    len = strlen(name);\n    p = list;\n    for(;;) {\n        pstart = p;\n        p = strchr(p, '|');\n        if (!p)\n            p = pstart + strlen(pstart);\n        if ((p - pstart) == len && !memcmp(pstart, name, len))\n            return 1;\n        if (*p == '\\0')\n            break;\n        p++;\n    }\n    return 0;\n}\n\nstatic int get_str(char *buf, int buf_size, const char **pp)\n{\n    const char *p;\n    char *q;\n    int c;\n\n    q = buf;\n    p = *pp;\n    while (qemu_isspace(*p)) {\n        p++;\n    }\n    if (*p == '\\0') {\n    fail:\n        *q = '\\0';\n        *pp = p;\n        return -1;\n    }\n    if (*p == '\\\"') {\n        p++;\n        while (*p != '\\0' && *p != '\\\"') {\n            if (*p == '\\\\') {\n                p++;\n                c = *p++;\n                switch (c) {\n                case 'n':\n                    c = '\\n';\n                    break;\n                case 'r':\n                    c = '\\r';\n                    break;\n                case '\\\\':\n                case '\\'':\n                case '\\\"':\n                    break;\n                default:\n                    printf(\"unsupported escape code: '\\\\%c'\\n\", c);\n                    goto fail;\n                }\n                if ((q - buf) < buf_size - 1) {\n                    *q++ = c;\n                }\n            } else {\n                if ((q - buf) < buf_size - 1) {\n                    *q++ = *p;\n                }\n                p++;\n            }\n        }\n        if (*p != '\\\"') {\n            printf(\"unterminated string\\n\");\n            goto fail;\n        }\n        p++;\n    } else {\n        while (*p != '\\0' && !qemu_isspace(*p)) {\n            if ((q - buf) < buf_size - 1) {\n                *q++ = *p;\n            }\n            p++;\n        }\n    }\n    *q = '\\0';\n    *pp = p;\n    return 0;\n}\n\n#define MAX_ARGS 16\n\nstatic void free_cmdline_args(char **args, int nb_args)\n{\n    int i;\n\n    assert(nb_args <= MAX_ARGS);\n\n    for (i = 0; i < nb_args; i++) {\n        g_free(args[i]);\n    }\n\n}\n\n/*\n * Parse the command line to get valid args.\n * @cmdline: command line to be parsed.\n * @pnb_args: location to store the number of args, must NOT be NULL.\n * @args: location to store the args, which should be freed by caller, must\n *        NOT be NULL.\n *\n * Returns 0 on success, negative on failure.\n *\n * NOTE: this parser is an approximate form of the real command parser. Number\n *       of args have a limit of MAX_ARGS. If cmdline contains more, it will\n *       return with failure.\n */\nstatic int parse_cmdline(const char *cmdline,\n                         int *pnb_args, char **args)\n{\n    const char *p;\n    int nb_args, ret;\n    char buf[1024];\n\n    p = cmdline;\n    nb_args = 0;\n    for (;;) {\n        while (qemu_isspace(*p)) {\n            p++;\n        }\n        if (*p == '\\0') {\n            break;\n        }\n        if (nb_args >= MAX_ARGS) {\n            goto fail;\n        }\n        ret = get_str(buf, sizeof(buf), &p);\n        if (ret < 0) {\n            goto fail;\n        }\n        args[nb_args] = g_strdup(buf);\n        nb_args++;\n    }\n    *pnb_args = nb_args;\n    return 0;\n\n fail:\n    free_cmdline_args(args, nb_args);\n    return -1;\n}\n\nstatic void help_cmd_dump_one(Monitor *mon,\n                              const mon_cmd_t *cmd,\n                              char **prefix_args,\n                              int prefix_args_nb)\n{\n    int i;\n\n    for (i = 0; i < prefix_args_nb; i++) {\n        monitor_printf(mon, \"%s \", prefix_args[i]);\n    }\n    monitor_printf(mon, \"%s %s -- %s\\n\", cmd->name, cmd->params, cmd->help);\n}\n\n/* @args[@arg_index] is the valid command need to find in @cmds */\nstatic void help_cmd_dump(Monitor *mon, const mon_cmd_t *cmds,\n                          char **args, int nb_args, int arg_index)\n{\n    const mon_cmd_t *cmd;\n\n    /* No valid arg need to compare with, dump all in *cmds */\n    if (arg_index >= nb_args) {\n        for (cmd = cmds; cmd->name != NULL; cmd++) {\n            help_cmd_dump_one(mon, cmd, args, arg_index);\n        }\n        return;\n    }\n\n    /* Find one entry to dump */\n    for (cmd = cmds; cmd->name != NULL; cmd++) {\n        if (compare_cmd(args[arg_index], cmd->name)) {\n            if (cmd->sub_table) {\n                /* continue with next arg */\n                help_cmd_dump(mon, cmd->sub_table,\n                              args, nb_args, arg_index + 1);\n            } else {\n                help_cmd_dump_one(mon, cmd, args, arg_index);\n            }\n            break;\n        }\n    }\n}\n\nstatic void help_cmd(Monitor *mon, const char *name)\n{\n    char *args[MAX_ARGS];\n    int nb_args = 0;\n\n    /* 1. parse user input */\n    if (name) {\n        /* special case for log, directly dump and return */\n        if (!strcmp(name, \"log\")) {\n            const QEMULogItem *item;\n            monitor_printf(mon, \"Log items (comma separated):\\n\");\n            monitor_printf(mon, \"%-10s %s\\n\", \"none\", \"remove all logs\");\n            for (item = qemu_log_items; item->mask != 0; item++) {\n                monitor_printf(mon, \"%-10s %s\\n\", item->name, item->help);\n            }\n            return;\n        }\n\n        if (parse_cmdline(name, &nb_args, args) < 0) {\n            return;\n        }\n    }\n\n    /* 2. dump the contents according to parsed args */\n    help_cmd_dump(mon, mon->cmd_table, args, nb_args, 0);\n\n    free_cmdline_args(args, nb_args);\n}\n\nstatic void do_help_cmd(Monitor *mon, const QDict *qdict)\n{\n    help_cmd(mon, qdict_get_try_str(qdict, \"name\"));\n}\n\nstatic void hmp_trace_event(Monitor *mon, const QDict *qdict)\n{\n    const char *tp_name = qdict_get_str(qdict, \"name\");\n    bool new_state = qdict_get_bool(qdict, \"option\");\n    bool has_vcpu = qdict_haskey(qdict, \"vcpu\");\n    int vcpu = qdict_get_try_int(qdict, \"vcpu\", 0);\n    Error *local_err = NULL;\n\n    if (vcpu < 0) {\n        monitor_printf(mon, \"argument vcpu must be positive\");\n        return;\n    }\n\n    qmp_trace_event_set_state(tp_name, new_state, true, true, has_vcpu, vcpu, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n    }\n}\n\n#ifdef CONFIG_TRACE_SIMPLE\nstatic void hmp_trace_file(Monitor *mon, const QDict *qdict)\n{\n    const char *op = qdict_get_try_str(qdict, \"op\");\n    const char *arg = qdict_get_try_str(qdict, \"arg\");\n\n    if (!op) {\n        st_print_trace_file_status((FILE *)mon, &monitor_fprintf);\n    } else if (!strcmp(op, \"on\")) {\n        st_set_trace_file_enabled(true);\n    } else if (!strcmp(op, \"off\")) {\n        st_set_trace_file_enabled(false);\n    } else if (!strcmp(op, \"flush\")) {\n        st_flush_trace_buffer();\n    } else if (!strcmp(op, \"set\")) {\n        if (arg) {\n            st_set_trace_file(arg);\n        }\n    } else {\n        monitor_printf(mon, \"unexpected argument \\\"%s\\\"\\n\", op);\n        help_cmd(mon, \"trace-file\");\n    }\n}\n#endif\n\nstatic void hmp_info_help(Monitor *mon, const QDict *qdict)\n{\n    help_cmd(mon, \"info\");\n}\n\nstatic void query_commands_cb(QmpCommand *cmd, void *opaque)\n{\n    CommandInfoList *info, **list = opaque;\n\n    if (!cmd->enabled) {\n        return;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    info->value = g_malloc0(sizeof(*info->value));\n    info->value->name = g_strdup(cmd->name);\n    info->next = *list;\n    *list = info;\n}\n\nCommandInfoList *qmp_query_commands(Error **errp)\n{\n    CommandInfoList *list = NULL;\n\n    qmp_for_each_command(cur_mon->qmp.commands, query_commands_cb, &list);\n\n    return list;\n}\n\nEventInfoList *qmp_query_events(Error **errp)\n{\n    EventInfoList *info, *ev_list = NULL;\n    QAPIEvent e;\n\n    for (e = 0 ; e < QAPI_EVENT__MAX ; e++) {\n        const char *event_name = QAPIEvent_lookup[e];\n        assert(event_name != NULL);\n        info = g_malloc0(sizeof(*info));\n        info->value = g_malloc0(sizeof(*info->value));\n        info->value->name = g_strdup(event_name);\n\n        info->next = ev_list;\n        ev_list = info;\n    }\n\n    return ev_list;\n}\n\n/*\n * Minor hack: generated marshalling suppressed for this command\n * ('gen': false in the schema) so we can parse the JSON string\n * directly into QObject instead of first parsing it with\n * visit_type_SchemaInfoList() into a SchemaInfoList, then marshal it\n * to QObject with generated output marshallers, every time.  Instead,\n * we do it in test-qobject-input-visitor.c, just to make sure\n * qapi-introspect.py's output actually conforms to the schema.\n */\nstatic void qmp_query_qmp_schema(QDict *qdict, QObject **ret_data,\n                                 Error **errp)\n{\n    *ret_data = qobject_from_json(qmp_schema_json, &error_abort);\n}\n\n/*\n * We used to define commands in qmp-commands.hx in addition to the\n * QAPI schema.  This permitted defining some of them only in certain\n * configurations.  query-commands has always reflected that (good,\n * because it lets QMP clients figure out what's actually available),\n * while query-qmp-schema never did (not so good).  This function is a\n * hack to keep the configuration-specific commands defined exactly as\n * before, even though qmp-commands.hx is gone.\n *\n * FIXME Educate the QAPI schema on configuration-specific commands,\n * and drop this hack.\n */\nstatic void qmp_unregister_commands_hack(void)\n{\n#ifndef CONFIG_SPICE\n    qmp_unregister_command(&qmp_commands, \"query-spice\");\n#endif\n#ifndef CONFIG_REPLICATION\n    qmp_unregister_command(&qmp_commands, \"xen-set-replication\");\n    qmp_unregister_command(&qmp_commands, \"query-xen-replication-status\");\n    qmp_unregister_command(&qmp_commands, \"xen-colo-do-checkpoint\");\n#endif\n#ifndef TARGET_I386\n    qmp_unregister_command(&qmp_commands, \"rtc-reset-reinjection\");\n#endif\n#ifndef TARGET_S390X\n    qmp_unregister_command(&qmp_commands, \"dump-skeys\");\n#endif\n#ifndef TARGET_ARM\n    qmp_unregister_command(&qmp_commands, \"query-gic-capabilities\");\n#endif\n#if !defined(TARGET_S390X) && !defined(TARGET_I386)\n    qmp_unregister_command(&qmp_commands, \"query-cpu-model-expansion\");\n#endif\n#if !defined(TARGET_S390X)\n    qmp_unregister_command(&qmp_commands, \"query-cpu-model-baseline\");\n    qmp_unregister_command(&qmp_commands, \"query-cpu-model-comparison\");\n#endif\n#if !defined(TARGET_PPC) && !defined(TARGET_ARM) && !defined(TARGET_I386) \\\n    && !defined(TARGET_S390X)\n    qmp_unregister_command(&qmp_commands, \"query-cpu-definitions\");\n#endif\n}\n\nvoid monitor_init_qmp_commands(void)\n{\n    /*\n     * Two command lists:\n     * - qmp_commands contains all QMP commands\n     * - qmp_cap_negotiation_commands contains just\n     *   \"qmp_capabilities\", to enforce capability negotiation\n     */\n\n    qmp_init_marshal(&qmp_commands);\n\n    qmp_register_command(&qmp_commands, \"query-qmp-schema\",\n                         qmp_query_qmp_schema,\n                         QCO_NO_OPTIONS);\n    qmp_register_command(&qmp_commands, \"device_add\", qmp_device_add,\n                         QCO_NO_OPTIONS);\n    qmp_register_command(&qmp_commands, \"netdev_add\", qmp_netdev_add,\n                         QCO_NO_OPTIONS);\n\n    qmp_unregister_commands_hack();\n\n    QTAILQ_INIT(&qmp_cap_negotiation_commands);\n    qmp_register_command(&qmp_cap_negotiation_commands, \"qmp_capabilities\",\n                         qmp_marshal_qmp_capabilities, QCO_NO_OPTIONS);\n}\n\nvoid qmp_qmp_capabilities(Error **errp)\n{\n    if (cur_mon->qmp.commands == &qmp_commands) {\n        error_set(errp, ERROR_CLASS_COMMAND_NOT_FOUND,\n                  \"Capabilities negotiation is already complete, command \"\n                  \"ignored\");\n        return;\n    }\n\n    cur_mon->qmp.commands = &qmp_commands;\n}\n\n/* set the current CPU defined by the user */\nint monitor_set_cpu(int cpu_index)\n{\n    CPUState *cpu;\n\n    cpu = qemu_get_cpu(cpu_index);\n    if (cpu == NULL) {\n        return -1;\n    }\n    cur_mon->mon_cpu = cpu;\n    return 0;\n}\n\nCPUState *mon_get_cpu(void)\n{\n    if (!cur_mon->mon_cpu) {\n        if (!first_cpu) {\n            return NULL;\n        }\n        monitor_set_cpu(first_cpu->cpu_index);\n    }\n    cpu_synchronize_state(cur_mon->mon_cpu);\n    return cur_mon->mon_cpu;\n}\n\nCPUArchState *mon_get_cpu_env(void)\n{\n    CPUState *cs = mon_get_cpu();\n\n    return cs ? cs->env_ptr : NULL;\n}\n\nint monitor_get_cpu_index(void)\n{\n    CPUState *cs = mon_get_cpu();\n\n    return cs ? cs->cpu_index : UNASSIGNED_CPU_INDEX;\n}\n\nstatic void hmp_info_registers(Monitor *mon, const QDict *qdict)\n{\n    CPUState *cs = mon_get_cpu();\n\n    if (!cs) {\n        monitor_printf(mon, \"No CPU available\\n\");\n        return;\n    }\n    cpu_dump_state(cs, (FILE *)mon, monitor_fprintf, CPU_DUMP_FPU);\n}\n\nstatic void hmp_info_jit(Monitor *mon, const QDict *qdict)\n{\n    if (!tcg_enabled()) {\n        error_report(\"JIT information is only available with accel=tcg\");\n        return;\n    }\n\n    dump_exec_info((FILE *)mon, monitor_fprintf);\n    dump_drift_info((FILE *)mon, monitor_fprintf);\n}\n\nstatic void hmp_info_opcount(Monitor *mon, const QDict *qdict)\n{\n    dump_opcount_info((FILE *)mon, monitor_fprintf);\n}\n\nstatic void hmp_info_history(Monitor *mon, const QDict *qdict)\n{\n    int i;\n    const char *str;\n\n    if (!mon->rs)\n        return;\n    i = 0;\n    for(;;) {\n        str = readline_get_history(mon->rs, i);\n        if (!str)\n            break;\n        monitor_printf(mon, \"%d: '%s'\\n\", i, str);\n        i++;\n    }\n}\n\nstatic void hmp_info_cpustats(Monitor *mon, const QDict *qdict)\n{\n    CPUState *cs = mon_get_cpu();\n\n    if (!cs) {\n        monitor_printf(mon, \"No CPU available\\n\");\n        return;\n    }\n    cpu_dump_statistics(cs, (FILE *)mon, &monitor_fprintf, 0);\n}\n\nstatic void hmp_info_trace_events(Monitor *mon, const QDict *qdict)\n{\n    const char *name = qdict_get_try_str(qdict, \"name\");\n    bool has_vcpu = qdict_haskey(qdict, \"vcpu\");\n    int vcpu = qdict_get_try_int(qdict, \"vcpu\", 0);\n    TraceEventInfoList *events;\n    TraceEventInfoList *elem;\n    Error *local_err = NULL;\n\n    if (name == NULL) {\n        name = \"*\";\n    }\n    if (vcpu < 0) {\n        monitor_printf(mon, \"argument vcpu must be positive\");\n        return;\n    }\n\n    events = qmp_trace_event_get_state(name, has_vcpu, vcpu, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return;\n    }\n\n    for (elem = events; elem != NULL; elem = elem->next) {\n        monitor_printf(mon, \"%s : state %u\\n\",\n                       elem->value->name,\n                       elem->value->state == TRACE_EVENT_STATE_ENABLED ? 1 : 0);\n    }\n    qapi_free_TraceEventInfoList(events);\n}\n\nvoid qmp_client_migrate_info(const char *protocol, const char *hostname,\n                             bool has_port, int64_t port,\n                             bool has_tls_port, int64_t tls_port,\n                             bool has_cert_subject, const char *cert_subject,\n                             Error **errp)\n{\n    if (strcmp(protocol, \"spice\") == 0) {\n        if (!qemu_using_spice(errp)) {\n            return;\n        }\n\n        if (!has_port && !has_tls_port) {\n            error_setg(errp, QERR_MISSING_PARAMETER, \"port/tls-port\");\n            return;\n        }\n\n        if (qemu_spice_migrate_info(hostname,\n                                    has_port ? port : -1,\n                                    has_tls_port ? tls_port : -1,\n                                    cert_subject)) {\n            error_setg(errp, QERR_UNDEFINED_ERROR);\n            return;\n        }\n        return;\n    }\n\n    error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"protocol\", \"spice\");\n}\n\nstatic void hmp_logfile(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n\n    qemu_set_log_filename(qdict_get_str(qdict, \"filename\"), &err);\n    if (err) {\n        error_report_err(err);\n    }\n}\n\nstatic void hmp_log(Monitor *mon, const QDict *qdict)\n{\n    int mask;\n    const char *items = qdict_get_str(qdict, \"items\");\n\n    if (!strcmp(items, \"none\")) {\n        mask = 0;\n    } else {\n        mask = qemu_str_to_log_mask(items);\n        if (!mask) {\n            help_cmd(mon, \"log\");\n            return;\n        }\n    }\n    qemu_set_log(mask);\n}\n\nstatic void hmp_singlestep(Monitor *mon, const QDict *qdict)\n{\n    const char *option = qdict_get_try_str(qdict, \"option\");\n    if (!option || !strcmp(option, \"on\")) {\n        singlestep = 1;\n    } else if (!strcmp(option, \"off\")) {\n        singlestep = 0;\n    } else {\n        monitor_printf(mon, \"unexpected option %s\\n\", option);\n    }\n}\n\nstatic void hmp_gdbserver(Monitor *mon, const QDict *qdict)\n{\n    const char *device = qdict_get_try_str(qdict, \"device\");\n    if (!device)\n        device = \"tcp::\" DEFAULT_GDBSTUB_PORT;\n    if (gdbserver_start(device) < 0) {\n        monitor_printf(mon, \"Could not open gdbserver on device '%s'\\n\",\n                       device);\n    } else if (strcmp(device, \"none\") == 0) {\n        monitor_printf(mon, \"Disabled gdbserver\\n\");\n    } else {\n        monitor_printf(mon, \"Waiting for gdb connection on device '%s'\\n\",\n                       device);\n    }\n}\n\nstatic void hmp_watchdog_action(Monitor *mon, const QDict *qdict)\n{\n    const char *action = qdict_get_str(qdict, \"action\");\n    if (select_watchdog_action(action) == -1) {\n        monitor_printf(mon, \"Unknown watchdog action '%s'\\n\", action);\n    }\n}\n\nstatic void monitor_printc(Monitor *mon, int c)\n{\n    monitor_printf(mon, \"'\");\n    switch(c) {\n    case '\\'':\n        monitor_printf(mon, \"\\\\'\");\n        break;\n    case '\\\\':\n        monitor_printf(mon, \"\\\\\\\\\");\n        break;\n    case '\\n':\n        monitor_printf(mon, \"\\\\n\");\n        break;\n    case '\\r':\n        monitor_printf(mon, \"\\\\r\");\n        break;\n    default:\n        if (c >= 32 && c <= 126) {\n            monitor_printf(mon, \"%c\", c);\n        } else {\n            monitor_printf(mon, \"\\\\x%02x\", c);\n        }\n        break;\n    }\n    monitor_printf(mon, \"'\");\n}\n\nstatic void memory_dump(Monitor *mon, int count, int format, int wsize,\n                        hwaddr addr, int is_physical)\n{\n    int l, line_size, i, max_digits, len;\n    uint8_t buf[16];\n    uint64_t v;\n    CPUState *cs = mon_get_cpu();\n\n    if (!cs && (format == 'i' || !is_physical)) {\n        monitor_printf(mon, \"Can not dump without CPU\\n\");\n        return;\n    }\n\n    if (format == 'i') {\n        int flags = 0;\n#ifdef TARGET_I386\n        CPUArchState *env = mon_get_cpu_env();\n        if (wsize == 2) {\n            flags = 1;\n        } else if (wsize == 4) {\n            flags = 0;\n        } else {\n            /* as default we use the current CS size */\n            flags = 0;\n            if (env) {\n#ifdef TARGET_X86_64\n                if ((env->efer & MSR_EFER_LMA) &&\n                    (env->segs[R_CS].flags & DESC_L_MASK))\n                    flags = 2;\n                else\n#endif\n                if (!(env->segs[R_CS].flags & DESC_B_MASK))\n                    flags = 1;\n            }\n        }\n#endif\n#ifdef TARGET_PPC\n        CPUArchState *env = mon_get_cpu_env();\n        flags = msr_le << 16;\n        flags |= env->bfd_mach;\n#endif\n        monitor_disas(mon, cs, addr, count, is_physical, flags);\n        return;\n    }\n\n    len = wsize * count;\n    if (wsize == 1)\n        line_size = 8;\n    else\n        line_size = 16;\n    max_digits = 0;\n\n    switch(format) {\n    case 'o':\n        max_digits = (wsize * 8 + 2) / 3;\n        break;\n    default:\n    case 'x':\n        max_digits = (wsize * 8) / 4;\n        break;\n    case 'u':\n    case 'd':\n        max_digits = (wsize * 8 * 10 + 32) / 33;\n        break;\n    case 'c':\n        wsize = 1;\n        break;\n    }\n\n    while (len > 0) {\n        if (is_physical)\n            monitor_printf(mon, TARGET_FMT_plx \":\", addr);\n        else\n            monitor_printf(mon, TARGET_FMT_lx \":\", (target_ulong)addr);\n        l = len;\n        if (l > line_size)\n            l = line_size;\n        if (is_physical) {\n            cpu_physical_memory_read(addr, buf, l);\n        } else {\n            if (cpu_memory_rw_debug(cs, addr, buf, l, 0) < 0) {\n                monitor_printf(mon, \" Cannot access memory\\n\");\n                break;\n            }\n        }\n        i = 0;\n        while (i < l) {\n            switch(wsize) {\n            default:\n            case 1:\n                v = ldub_p(buf + i);\n                break;\n            case 2:\n                v = lduw_p(buf + i);\n                break;\n            case 4:\n                v = (uint32_t)ldl_p(buf + i);\n                break;\n            case 8:\n                v = ldq_p(buf + i);\n                break;\n            }\n            monitor_printf(mon, \" \");\n            switch(format) {\n            case 'o':\n                monitor_printf(mon, \"%#*\" PRIo64, max_digits, v);\n                break;\n            case 'x':\n                monitor_printf(mon, \"0x%0*\" PRIx64, max_digits, v);\n                break;\n            case 'u':\n                monitor_printf(mon, \"%*\" PRIu64, max_digits, v);\n                break;\n            case 'd':\n                monitor_printf(mon, \"%*\" PRId64, max_digits, v);\n                break;\n            case 'c':\n                monitor_printc(mon, v);\n                break;\n            }\n            i += wsize;\n        }\n        monitor_printf(mon, \"\\n\");\n        addr += l;\n        len -= l;\n    }\n}\n\nstatic void hmp_memory_dump(Monitor *mon, const QDict *qdict)\n{\n    int count = qdict_get_int(qdict, \"count\");\n    int format = qdict_get_int(qdict, \"format\");\n    int size = qdict_get_int(qdict, \"size\");\n    target_long addr = qdict_get_int(qdict, \"addr\");\n\n    memory_dump(mon, count, format, size, addr, 0);\n}\n\nstatic void hmp_physical_memory_dump(Monitor *mon, const QDict *qdict)\n{\n    int count = qdict_get_int(qdict, \"count\");\n    int format = qdict_get_int(qdict, \"format\");\n    int size = qdict_get_int(qdict, \"size\");\n    hwaddr addr = qdict_get_int(qdict, \"addr\");\n\n    memory_dump(mon, count, format, size, addr, 1);\n}\n\nstatic void do_print(Monitor *mon, const QDict *qdict)\n{\n    int format = qdict_get_int(qdict, \"format\");\n    hwaddr val = qdict_get_int(qdict, \"val\");\n\n    switch(format) {\n    case 'o':\n        monitor_printf(mon, \"%#\" HWADDR_PRIo, val);\n        break;\n    case 'x':\n        monitor_printf(mon, \"%#\" HWADDR_PRIx, val);\n        break;\n    case 'u':\n        monitor_printf(mon, \"%\" HWADDR_PRIu, val);\n        break;\n    default:\n    case 'd':\n        monitor_printf(mon, \"%\" HWADDR_PRId, val);\n        break;\n    case 'c':\n        monitor_printc(mon, val);\n        break;\n    }\n    monitor_printf(mon, \"\\n\");\n}\n\nstatic void hmp_sum(Monitor *mon, const QDict *qdict)\n{\n    uint32_t addr;\n    uint16_t sum;\n    uint32_t start = qdict_get_int(qdict, \"start\");\n    uint32_t size = qdict_get_int(qdict, \"size\");\n\n    sum = 0;\n    for(addr = start; addr < (start + size); addr++) {\n        uint8_t val = address_space_ldub(&address_space_memory, addr,\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n        /* BSD sum algorithm ('sum' Unix command) */\n        sum = (sum >> 1) | (sum << 15);\n        sum += val;\n    }\n    monitor_printf(mon, \"%05d\\n\", sum);\n}\n\nstatic int mouse_button_state;\n\nstatic void hmp_mouse_move(Monitor *mon, const QDict *qdict)\n{\n    int dx, dy, dz, button;\n    const char *dx_str = qdict_get_str(qdict, \"dx_str\");\n    const char *dy_str = qdict_get_str(qdict, \"dy_str\");\n    const char *dz_str = qdict_get_try_str(qdict, \"dz_str\");\n\n    dx = strtol(dx_str, NULL, 0);\n    dy = strtol(dy_str, NULL, 0);\n    qemu_input_queue_rel(NULL, INPUT_AXIS_X, dx);\n    qemu_input_queue_rel(NULL, INPUT_AXIS_Y, dy);\n\n    if (dz_str) {\n        dz = strtol(dz_str, NULL, 0);\n        if (dz != 0) {\n            button = (dz > 0) ? INPUT_BUTTON_WHEEL_UP : INPUT_BUTTON_WHEEL_DOWN;\n            qemu_input_queue_btn(NULL, button, true);\n            qemu_input_event_sync();\n            qemu_input_queue_btn(NULL, button, false);\n        }\n    }\n    qemu_input_event_sync();\n}\n\nstatic void hmp_mouse_button(Monitor *mon, const QDict *qdict)\n{\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n        [INPUT_BUTTON_LEFT]       = MOUSE_EVENT_LBUTTON,\n        [INPUT_BUTTON_MIDDLE]     = MOUSE_EVENT_MBUTTON,\n        [INPUT_BUTTON_RIGHT]      = MOUSE_EVENT_RBUTTON,\n    };\n    int button_state = qdict_get_int(qdict, \"button_state\");\n\n    if (mouse_button_state == button_state) {\n        return;\n    }\n    qemu_input_update_buttons(NULL, bmap, mouse_button_state, button_state);\n    qemu_input_event_sync();\n    mouse_button_state = button_state;\n}\n\nstatic void hmp_ioport_read(Monitor *mon, const QDict *qdict)\n{\n    int size = qdict_get_int(qdict, \"size\");\n    int addr = qdict_get_int(qdict, \"addr\");\n    int has_index = qdict_haskey(qdict, \"index\");\n    uint32_t val;\n    int suffix;\n\n    if (has_index) {\n        int index = qdict_get_int(qdict, \"index\");\n        cpu_outb(addr & IOPORTS_MASK, index & 0xff);\n        addr++;\n    }\n    addr &= 0xffff;\n\n    switch(size) {\n    default:\n    case 1:\n        val = cpu_inb(addr);\n        suffix = 'b';\n        break;\n    case 2:\n        val = cpu_inw(addr);\n        suffix = 'w';\n        break;\n    case 4:\n        val = cpu_inl(addr);\n        suffix = 'l';\n        break;\n    }\n    monitor_printf(mon, \"port%c[0x%04x] = %#0*x\\n\",\n                   suffix, addr, size * 2, val);\n}\n\nstatic void hmp_ioport_write(Monitor *mon, const QDict *qdict)\n{\n    int size = qdict_get_int(qdict, \"size\");\n    int addr = qdict_get_int(qdict, \"addr\");\n    int val = qdict_get_int(qdict, \"val\");\n\n    addr &= IOPORTS_MASK;\n\n    switch (size) {\n    default:\n    case 1:\n        cpu_outb(addr, val);\n        break;\n    case 2:\n        cpu_outw(addr, val);\n        break;\n    case 4:\n        cpu_outl(addr, val);\n        break;\n    }\n}\n\nstatic void hmp_boot_set(Monitor *mon, const QDict *qdict)\n{\n    Error *local_err = NULL;\n    const char *bootdevice = qdict_get_str(qdict, \"bootdevice\");\n\n    qemu_boot_set(bootdevice, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n    } else {\n        monitor_printf(mon, \"boot device list now set to %s\\n\", bootdevice);\n    }\n}\n\nstatic void hmp_info_mtree(Monitor *mon, const QDict *qdict)\n{\n    bool flatview = qdict_get_try_bool(qdict, \"flatview\", false);\n\n    mtree_info((fprintf_function)monitor_printf, mon, flatview);\n}\n\nstatic void hmp_info_numa(Monitor *mon, const QDict *qdict)\n{\n    int i;\n    CPUState *cpu;\n    uint64_t *node_mem;\n\n    node_mem = g_new0(uint64_t, nb_numa_nodes);\n    query_numa_node_mem(node_mem);\n    monitor_printf(mon, \"%d nodes\\n\", nb_numa_nodes);\n    for (i = 0; i < nb_numa_nodes; i++) {\n        monitor_printf(mon, \"node %d cpus:\", i);\n        CPU_FOREACH(cpu) {\n            if (cpu->numa_node == i) {\n                monitor_printf(mon, \" %d\", cpu->cpu_index);\n            }\n        }\n        monitor_printf(mon, \"\\n\");\n        monitor_printf(mon, \"node %d size: %\" PRId64 \" MB\\n\", i,\n                       node_mem[i] >> 20);\n    }\n    g_free(node_mem);\n}\n\n#ifdef CONFIG_PROFILER\n\nint64_t tcg_time;\nint64_t dev_time;\n\nstatic void hmp_info_profile(Monitor *mon, const QDict *qdict)\n{\n    monitor_printf(mon, \"async time  %\" PRId64 \" (%0.3f)\\n\",\n                   dev_time, dev_time / (double)NANOSECONDS_PER_SECOND);\n    monitor_printf(mon, \"qemu time   %\" PRId64 \" (%0.3f)\\n\",\n                   tcg_time, tcg_time / (double)NANOSECONDS_PER_SECOND);\n    tcg_time = 0;\n    dev_time = 0;\n}\n#else\nstatic void hmp_info_profile(Monitor *mon, const QDict *qdict)\n{\n    monitor_printf(mon, \"Internal profiler not compiled\\n\");\n}\n#endif\n\n/* Capture support */\nstatic QLIST_HEAD (capture_list_head, CaptureState) capture_head;\n\nstatic void hmp_info_capture(Monitor *mon, const QDict *qdict)\n{\n    int i;\n    CaptureState *s;\n\n    for (s = capture_head.lh_first, i = 0; s; s = s->entries.le_next, ++i) {\n        monitor_printf(mon, \"[%d]: \", i);\n        s->ops.info (s->opaque);\n    }\n}\n\nstatic void hmp_stopcapture(Monitor *mon, const QDict *qdict)\n{\n    int i;\n    int n = qdict_get_int(qdict, \"n\");\n    CaptureState *s;\n\n    for (s = capture_head.lh_first, i = 0; s; s = s->entries.le_next, ++i) {\n        if (i == n) {\n            s->ops.destroy (s->opaque);\n            QLIST_REMOVE (s, entries);\n            g_free (s);\n            return;\n        }\n    }\n}\n\nstatic void hmp_wavcapture(Monitor *mon, const QDict *qdict)\n{\n    const char *path = qdict_get_str(qdict, \"path\");\n    int has_freq = qdict_haskey(qdict, \"freq\");\n    int freq = qdict_get_try_int(qdict, \"freq\", -1);\n    int has_bits = qdict_haskey(qdict, \"bits\");\n    int bits = qdict_get_try_int(qdict, \"bits\", -1);\n    int has_channels = qdict_haskey(qdict, \"nchannels\");\n    int nchannels = qdict_get_try_int(qdict, \"nchannels\", -1);\n    CaptureState *s;\n\n    s = g_malloc0 (sizeof (*s));\n\n    freq = has_freq ? freq : 44100;\n    bits = has_bits ? bits : 16;\n    nchannels = has_channels ? nchannels : 2;\n\n    if (wav_start_capture (s, path, freq, bits, nchannels)) {\n        monitor_printf(mon, \"Failed to add wave capture\\n\");\n        g_free (s);\n        return;\n    }\n    QLIST_INSERT_HEAD (&capture_head, s, entries);\n}\n\nstatic qemu_acl *find_acl(Monitor *mon, const char *name)\n{\n    qemu_acl *acl = qemu_acl_find(name);\n\n    if (!acl) {\n        monitor_printf(mon, \"acl: unknown list '%s'\\n\", name);\n    }\n    return acl;\n}\n\nstatic void hmp_acl_show(Monitor *mon, const QDict *qdict)\n{\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n    qemu_acl *acl = find_acl(mon, aclname);\n    qemu_acl_entry *entry;\n    int i = 0;\n\n    if (acl) {\n        monitor_printf(mon, \"policy: %s\\n\",\n                       acl->defaultDeny ? \"deny\" : \"allow\");\n        QTAILQ_FOREACH(entry, &acl->entries, next) {\n            i++;\n            monitor_printf(mon, \"%d: %s %s\\n\", i,\n                           entry->deny ? \"deny\" : \"allow\", entry->match);\n        }\n    }\n}\n\nstatic void hmp_acl_reset(Monitor *mon, const QDict *qdict)\n{\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n    qemu_acl *acl = find_acl(mon, aclname);\n\n    if (acl) {\n        qemu_acl_reset(acl);\n        monitor_printf(mon, \"acl: removed all rules\\n\");\n    }\n}\n\nstatic void hmp_acl_policy(Monitor *mon, const QDict *qdict)\n{\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n    const char *policy = qdict_get_str(qdict, \"policy\");\n    qemu_acl *acl = find_acl(mon, aclname);\n\n    if (acl) {\n        if (strcmp(policy, \"allow\") == 0) {\n            acl->defaultDeny = 0;\n            monitor_printf(mon, \"acl: policy set to 'allow'\\n\");\n        } else if (strcmp(policy, \"deny\") == 0) {\n            acl->defaultDeny = 1;\n            monitor_printf(mon, \"acl: policy set to 'deny'\\n\");\n        } else {\n            monitor_printf(mon, \"acl: unknown policy '%s', \"\n                           \"expected 'deny' or 'allow'\\n\", policy);\n        }\n    }\n}\n\nstatic void hmp_acl_add(Monitor *mon, const QDict *qdict)\n{\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n    const char *match = qdict_get_str(qdict, \"match\");\n    const char *policy = qdict_get_str(qdict, \"policy\");\n    int has_index = qdict_haskey(qdict, \"index\");\n    int index = qdict_get_try_int(qdict, \"index\", -1);\n    qemu_acl *acl = find_acl(mon, aclname);\n    int deny, ret;\n\n    if (acl) {\n        if (strcmp(policy, \"allow\") == 0) {\n            deny = 0;\n        } else if (strcmp(policy, \"deny\") == 0) {\n            deny = 1;\n        } else {\n            monitor_printf(mon, \"acl: unknown policy '%s', \"\n                           \"expected 'deny' or 'allow'\\n\", policy);\n            return;\n        }\n        if (has_index)\n            ret = qemu_acl_insert(acl, deny, match, index);\n        else\n            ret = qemu_acl_append(acl, deny, match);\n        if (ret < 0)\n            monitor_printf(mon, \"acl: unable to add acl entry\\n\");\n        else\n            monitor_printf(mon, \"acl: added rule at position %d\\n\", ret);\n    }\n}\n\nstatic void hmp_acl_remove(Monitor *mon, const QDict *qdict)\n{\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n    const char *match = qdict_get_str(qdict, \"match\");\n    qemu_acl *acl = find_acl(mon, aclname);\n    int ret;\n\n    if (acl) {\n        ret = qemu_acl_remove(acl, match);\n        if (ret < 0)\n            monitor_printf(mon, \"acl: no matching acl entry\\n\");\n        else\n            monitor_printf(mon, \"acl: removed rule at position %d\\n\", ret);\n    }\n}\n\nvoid qmp_getfd(const char *fdname, Error **errp)\n{\n    mon_fd_t *monfd;\n    int fd;\n\n    fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);\n    if (fd == -1) {\n        error_setg(errp, QERR_FD_NOT_SUPPLIED);\n        return;\n    }\n\n    if (qemu_isdigit(fdname[0])) {\n        close(fd);\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n                   \"a name not starting with a digit\");\n        return;\n    }\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n        if (strcmp(monfd->name, fdname) != 0) {\n            continue;\n        }\n\n        close(monfd->fd);\n        monfd->fd = fd;\n        return;\n    }\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n    monfd->name = g_strdup(fdname);\n    monfd->fd = fd;\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n}\n\nvoid qmp_closefd(const char *fdname, Error **errp)\n{\n    mon_fd_t *monfd;\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n        if (strcmp(monfd->name, fdname) != 0) {\n            continue;\n        }\n\n        QLIST_REMOVE(monfd, next);\n        close(monfd->fd);\n        g_free(monfd->name);\n        g_free(monfd);\n        return;\n    }\n\n    error_setg(errp, QERR_FD_NOT_FOUND, fdname);\n}\n\nstatic void hmp_loadvm(Monitor *mon, const QDict *qdict)\n{\n    int saved_vm_running  = runstate_is_running();\n    const char *name = qdict_get_str(qdict, \"name\");\n\n    vm_stop(RUN_STATE_RESTORE_VM);\n\n    if (load_vmstate(name) == 0 && saved_vm_running) {\n        vm_start();\n    }\n}\n\nint monitor_get_fd(Monitor *mon, const char *fdname, Error **errp)\n{\n    mon_fd_t *monfd;\n\n    QLIST_FOREACH(monfd, &mon->fds, next) {\n        int fd;\n\n        if (strcmp(monfd->name, fdname) != 0) {\n            continue;\n        }\n\n        fd = monfd->fd;\n\n        /* caller takes ownership of fd */\n        QLIST_REMOVE(monfd, next);\n        g_free(monfd->name);\n        g_free(monfd);\n\n        return fd;\n    }\n\n    error_setg(errp, \"File descriptor named '%s' has not been found\", fdname);\n    return -1;\n}\n\nstatic void monitor_fdset_cleanup(MonFdset *mon_fdset)\n{\n    MonFdsetFd *mon_fdset_fd;\n    MonFdsetFd *mon_fdset_fd_next;\n\n    QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {\n        if ((mon_fdset_fd->removed ||\n                (QLIST_EMPTY(&mon_fdset->dup_fds) && mon_refcount == 0)) &&\n                runstate_is_running()) {\n            close(mon_fdset_fd->fd);\n            g_free(mon_fdset_fd->opaque);\n            QLIST_REMOVE(mon_fdset_fd, next);\n            g_free(mon_fdset_fd);\n        }\n    }\n\n    if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {\n        QLIST_REMOVE(mon_fdset, next);\n        g_free(mon_fdset);\n    }\n}\n\nstatic void monitor_fdsets_cleanup(void)\n{\n    MonFdset *mon_fdset;\n    MonFdset *mon_fdset_next;\n\n    QLIST_FOREACH_SAFE(mon_fdset, &mon_fdsets, next, mon_fdset_next) {\n        monitor_fdset_cleanup(mon_fdset);\n    }\n}\n\nAddfdInfo *qmp_add_fd(bool has_fdset_id, int64_t fdset_id, bool has_opaque,\n                      const char *opaque, Error **errp)\n{\n    int fd;\n    Monitor *mon = cur_mon;\n    AddfdInfo *fdinfo;\n\n    fd = qemu_chr_fe_get_msgfd(&mon->chr);\n    if (fd == -1) {\n        error_setg(errp, QERR_FD_NOT_SUPPLIED);\n        goto error;\n    }\n\n    fdinfo = monitor_fdset_add_fd(fd, has_fdset_id, fdset_id,\n                                  has_opaque, opaque, errp);\n    if (fdinfo) {\n        return fdinfo;\n    }\n\nerror:\n    if (fd != -1) {\n        close(fd);\n    }\n    return NULL;\n}\n\nvoid qmp_remove_fd(int64_t fdset_id, bool has_fd, int64_t fd, Error **errp)\n{\n    MonFdset *mon_fdset;\n    MonFdsetFd *mon_fdset_fd;\n    char fd_str[60];\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n        if (mon_fdset->id != fdset_id) {\n            continue;\n        }\n        QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {\n            if (has_fd) {\n                if (mon_fdset_fd->fd != fd) {\n                    continue;\n                }\n                mon_fdset_fd->removed = true;\n                break;\n            } else {\n                mon_fdset_fd->removed = true;\n            }\n        }\n        if (has_fd && !mon_fdset_fd) {\n            goto error;\n        }\n        monitor_fdset_cleanup(mon_fdset);\n        return;\n    }\n\nerror:\n    if (has_fd) {\n        snprintf(fd_str, sizeof(fd_str), \"fdset-id:%\" PRId64 \", fd:%\" PRId64,\n                 fdset_id, fd);\n    } else {\n        snprintf(fd_str, sizeof(fd_str), \"fdset-id:%\" PRId64, fdset_id);\n    }\n    error_setg(errp, QERR_FD_NOT_FOUND, fd_str);\n}\n\nFdsetInfoList *qmp_query_fdsets(Error **errp)\n{\n    MonFdset *mon_fdset;\n    MonFdsetFd *mon_fdset_fd;\n    FdsetInfoList *fdset_list = NULL;\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n        FdsetInfoList *fdset_info = g_malloc0(sizeof(*fdset_info));\n        FdsetFdInfoList *fdsetfd_list = NULL;\n\n        fdset_info->value = g_malloc0(sizeof(*fdset_info->value));\n        fdset_info->value->fdset_id = mon_fdset->id;\n\n        QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {\n            FdsetFdInfoList *fdsetfd_info;\n\n            fdsetfd_info = g_malloc0(sizeof(*fdsetfd_info));\n            fdsetfd_info->value = g_malloc0(sizeof(*fdsetfd_info->value));\n            fdsetfd_info->value->fd = mon_fdset_fd->fd;\n            if (mon_fdset_fd->opaque) {\n                fdsetfd_info->value->has_opaque = true;\n                fdsetfd_info->value->opaque = g_strdup(mon_fdset_fd->opaque);\n            } else {\n                fdsetfd_info->value->has_opaque = false;\n            }\n\n            fdsetfd_info->next = fdsetfd_list;\n            fdsetfd_list = fdsetfd_info;\n        }\n\n        fdset_info->value->fds = fdsetfd_list;\n\n        fdset_info->next = fdset_list;\n        fdset_list = fdset_info;\n    }\n\n    return fdset_list;\n}\n\nAddfdInfo *monitor_fdset_add_fd(int fd, bool has_fdset_id, int64_t fdset_id,\n                                bool has_opaque, const char *opaque,\n                                Error **errp)\n{\n    MonFdset *mon_fdset = NULL;\n    MonFdsetFd *mon_fdset_fd;\n    AddfdInfo *fdinfo;\n\n    if (has_fdset_id) {\n        QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n            /* Break if match found or match impossible due to ordering by ID */\n            if (fdset_id <= mon_fdset->id) {\n                if (fdset_id < mon_fdset->id) {\n                    mon_fdset = NULL;\n                }\n                break;\n            }\n        }\n    }\n\n    if (mon_fdset == NULL) {\n        int64_t fdset_id_prev = -1;\n        MonFdset *mon_fdset_cur = QLIST_FIRST(&mon_fdsets);\n\n        if (has_fdset_id) {\n            if (fdset_id < 0) {\n                error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"fdset-id\",\n                           \"a non-negative value\");\n                return NULL;\n            }\n            /* Use specified fdset ID */\n            QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n                mon_fdset_cur = mon_fdset;\n                if (fdset_id < mon_fdset_cur->id) {\n                    break;\n                }\n            }\n        } else {\n            /* Use first available fdset ID */\n            QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n                mon_fdset_cur = mon_fdset;\n                if (fdset_id_prev == mon_fdset_cur->id - 1) {\n                    fdset_id_prev = mon_fdset_cur->id;\n                    continue;\n                }\n                break;\n            }\n        }\n\n        mon_fdset = g_malloc0(sizeof(*mon_fdset));\n        if (has_fdset_id) {\n            mon_fdset->id = fdset_id;\n        } else {\n            mon_fdset->id = fdset_id_prev + 1;\n        }\n\n        /* The fdset list is ordered by fdset ID */\n        if (!mon_fdset_cur) {\n            QLIST_INSERT_HEAD(&mon_fdsets, mon_fdset, next);\n        } else if (mon_fdset->id < mon_fdset_cur->id) {\n            QLIST_INSERT_BEFORE(mon_fdset_cur, mon_fdset, next);\n        } else {\n            QLIST_INSERT_AFTER(mon_fdset_cur, mon_fdset, next);\n        }\n    }\n\n    mon_fdset_fd = g_malloc0(sizeof(*mon_fdset_fd));\n    mon_fdset_fd->fd = fd;\n    mon_fdset_fd->removed = false;\n    if (has_opaque) {\n        mon_fdset_fd->opaque = g_strdup(opaque);\n    }\n    QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);\n\n    fdinfo = g_malloc0(sizeof(*fdinfo));\n    fdinfo->fdset_id = mon_fdset->id;\n    fdinfo->fd = mon_fdset_fd->fd;\n\n    return fdinfo;\n}\n\nint monitor_fdset_get_fd(int64_t fdset_id, int flags)\n{\n#ifndef _WIN32\n    MonFdset *mon_fdset;\n    MonFdsetFd *mon_fdset_fd;\n    int mon_fd_flags;\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n        if (mon_fdset->id != fdset_id) {\n            continue;\n        }\n        QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {\n            mon_fd_flags = fcntl(mon_fdset_fd->fd, F_GETFL);\n            if (mon_fd_flags == -1) {\n                return -1;\n            }\n\n            if ((flags & O_ACCMODE) == (mon_fd_flags & O_ACCMODE)) {\n                return mon_fdset_fd->fd;\n            }\n        }\n        errno = EACCES;\n        return -1;\n    }\n#endif\n\n    errno = ENOENT;\n    return -1;\n}\n\nint monitor_fdset_dup_fd_add(int64_t fdset_id, int dup_fd)\n{\n    MonFdset *mon_fdset;\n    MonFdsetFd *mon_fdset_fd_dup;\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n        if (mon_fdset->id != fdset_id) {\n            continue;\n        }\n        QLIST_FOREACH(mon_fdset_fd_dup, &mon_fdset->dup_fds, next) {\n            if (mon_fdset_fd_dup->fd == dup_fd) {\n                return -1;\n            }\n        }\n        mon_fdset_fd_dup = g_malloc0(sizeof(*mon_fdset_fd_dup));\n        mon_fdset_fd_dup->fd = dup_fd;\n        QLIST_INSERT_HEAD(&mon_fdset->dup_fds, mon_fdset_fd_dup, next);\n        return 0;\n    }\n    return -1;\n}\n\nstatic int monitor_fdset_dup_fd_find_remove(int dup_fd, bool remove)\n{\n    MonFdset *mon_fdset;\n    MonFdsetFd *mon_fdset_fd_dup;\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n        QLIST_FOREACH(mon_fdset_fd_dup, &mon_fdset->dup_fds, next) {\n            if (mon_fdset_fd_dup->fd == dup_fd) {\n                if (remove) {\n                    QLIST_REMOVE(mon_fdset_fd_dup, next);\n                    if (QLIST_EMPTY(&mon_fdset->dup_fds)) {\n                        monitor_fdset_cleanup(mon_fdset);\n                    }\n                    return -1;\n                } else {\n                    return mon_fdset->id;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint monitor_fdset_dup_fd_find(int dup_fd)\n{\n    return monitor_fdset_dup_fd_find_remove(dup_fd, false);\n}\n\nvoid monitor_fdset_dup_fd_remove(int dup_fd)\n{\n    monitor_fdset_dup_fd_find_remove(dup_fd, true);\n}\n\nint monitor_fd_param(Monitor *mon, const char *fdname, Error **errp)\n{\n    int fd;\n    Error *local_err = NULL;\n\n    if (!qemu_isdigit(fdname[0]) && mon) {\n        fd = monitor_get_fd(mon, fdname, &local_err);\n    } else {\n        fd = qemu_parse_fd(fdname);\n        if (fd == -1) {\n            error_setg(&local_err, \"Invalid file descriptor number '%s'\",\n                       fdname);\n        }\n    }\n    if (local_err) {\n        error_propagate(errp, local_err);\n        assert(fd == -1);\n    } else {\n        assert(fd != -1);\n    }\n\n    return fd;\n}\n\n/* Please update hmp-commands.hx when adding or changing commands */\nstatic mon_cmd_t info_cmds[] = {\n#include \"hmp-commands-info.h\"\n    { NULL, NULL, },\n};\n\n/* mon_cmds and info_cmds would be sorted at runtime */\nstatic mon_cmd_t mon_cmds[] = {\n#include \"hmp-commands.h\"\n    { NULL, NULL, },\n};\n\n/*******************************************************************/\n\nstatic const char *pch;\nstatic sigjmp_buf expr_env;\n\n\nstatic void GCC_FMT_ATTR(2, 3) QEMU_NORETURN\nexpr_error(Monitor *mon, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    monitor_vprintf(mon, fmt, ap);\n    monitor_printf(mon, \"\\n\");\n    va_end(ap);\n    siglongjmp(expr_env, 1);\n}\n\n/* return 0 if OK, -1 if not found */\nstatic int get_monitor_def(target_long *pval, const char *name)\n{\n    const MonitorDef *md = target_monitor_defs();\n    CPUState *cs = mon_get_cpu();\n    void *ptr;\n    uint64_t tmp = 0;\n    int ret;\n\n    if (cs == NULL || md == NULL) {\n        return -1;\n    }\n\n    for(; md->name != NULL; md++) {\n        if (compare_cmd(name, md->name)) {\n            if (md->get_value) {\n                *pval = md->get_value(md, md->offset);\n            } else {\n                CPUArchState *env = mon_get_cpu_env();\n                ptr = (uint8_t *)env + md->offset;\n                switch(md->type) {\n                case MD_I32:\n                    *pval = *(int32_t *)ptr;\n                    break;\n                case MD_TLONG:\n                    *pval = *(target_long *)ptr;\n                    break;\n                default:\n                    *pval = 0;\n                    break;\n                }\n            }\n            return 0;\n        }\n    }\n\n    ret = target_get_monitor_def(cs, name, &tmp);\n    if (!ret) {\n        *pval = (target_long) tmp;\n    }\n\n    return ret;\n}\n\nstatic void next(void)\n{\n    if (*pch != '\\0') {\n        pch++;\n        while (qemu_isspace(*pch))\n            pch++;\n    }\n}\n\nstatic int64_t expr_sum(Monitor *mon);\n\nstatic int64_t expr_unary(Monitor *mon)\n{\n    int64_t n;\n    char *p;\n    int ret;\n\n    switch(*pch) {\n    case '+':\n        next();\n        n = expr_unary(mon);\n        break;\n    case '-':\n        next();\n        n = -expr_unary(mon);\n        break;\n    case '~':\n        next();\n        n = ~expr_unary(mon);\n        break;\n    case '(':\n        next();\n        n = expr_sum(mon);\n        if (*pch != ')') {\n            expr_error(mon, \"')' expected\");\n        }\n        next();\n        break;\n    case '\\'':\n        pch++;\n        if (*pch == '\\0')\n            expr_error(mon, \"character constant expected\");\n        n = *pch;\n        pch++;\n        if (*pch != '\\'')\n            expr_error(mon, \"missing terminating \\' character\");\n        next();\n        break;\n    case '$':\n        {\n            char buf[128], *q;\n            target_long reg=0;\n\n            pch++;\n            q = buf;\n            while ((*pch >= 'a' && *pch <= 'z') ||\n                   (*pch >= 'A' && *pch <= 'Z') ||\n                   (*pch >= '0' && *pch <= '9') ||\n                   *pch == '_' || *pch == '.') {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = *pch;\n                pch++;\n            }\n            while (qemu_isspace(*pch))\n                pch++;\n            *q = 0;\n            ret = get_monitor_def(&reg, buf);\n            if (ret < 0)\n                expr_error(mon, \"unknown register\");\n            n = reg;\n        }\n        break;\n    case '\\0':\n        expr_error(mon, \"unexpected end of expression\");\n        n = 0;\n        break;\n    default:\n        errno = 0;\n        n = strtoull(pch, &p, 0);\n        if (errno == ERANGE) {\n            expr_error(mon, \"number too large\");\n        }\n        if (pch == p) {\n            expr_error(mon, \"invalid char '%c' in expression\", *p);\n        }\n        pch = p;\n        while (qemu_isspace(*pch))\n            pch++;\n        break;\n    }\n    return n;\n}\n\n\nstatic int64_t expr_prod(Monitor *mon)\n{\n    int64_t val, val2;\n    int op;\n\n    val = expr_unary(mon);\n    for(;;) {\n        op = *pch;\n        if (op != '*' && op != '/' && op != '%')\n            break;\n        next();\n        val2 = expr_unary(mon);\n        switch(op) {\n        default:\n        case '*':\n            val *= val2;\n            break;\n        case '/':\n        case '%':\n            if (val2 == 0)\n                expr_error(mon, \"division by zero\");\n            if (op == '/')\n                val /= val2;\n            else\n                val %= val2;\n            break;\n        }\n    }\n    return val;\n}\n\nstatic int64_t expr_logic(Monitor *mon)\n{\n    int64_t val, val2;\n    int op;\n\n    val = expr_prod(mon);\n    for(;;) {\n        op = *pch;\n        if (op != '&' && op != '|' && op != '^')\n            break;\n        next();\n        val2 = expr_prod(mon);\n        switch(op) {\n        default:\n        case '&':\n            val &= val2;\n            break;\n        case '|':\n            val |= val2;\n            break;\n        case '^':\n            val ^= val2;\n            break;\n        }\n    }\n    return val;\n}\n\nstatic int64_t expr_sum(Monitor *mon)\n{\n    int64_t val, val2;\n    int op;\n\n    val = expr_logic(mon);\n    for(;;) {\n        op = *pch;\n        if (op != '+' && op != '-')\n            break;\n        next();\n        val2 = expr_logic(mon);\n        if (op == '+')\n            val += val2;\n        else\n            val -= val2;\n    }\n    return val;\n}\n\nstatic int get_expr(Monitor *mon, int64_t *pval, const char **pp)\n{\n    pch = *pp;\n    if (sigsetjmp(expr_env, 0)) {\n        *pp = pch;\n        return -1;\n    }\n    while (qemu_isspace(*pch))\n        pch++;\n    *pval = expr_sum(mon);\n    *pp = pch;\n    return 0;\n}\n\nstatic int get_double(Monitor *mon, double *pval, const char **pp)\n{\n    const char *p = *pp;\n    char *tailp;\n    double d;\n\n    d = strtod(p, &tailp);\n    if (tailp == p) {\n        monitor_printf(mon, \"Number expected\\n\");\n        return -1;\n    }\n    if (d != d || d - d != 0) {\n        /* NaN or infinity */\n        monitor_printf(mon, \"Bad number\\n\");\n        return -1;\n    }\n    *pval = d;\n    *pp = tailp;\n    return 0;\n}\n\n/*\n * Store the command-name in cmdname, and return a pointer to\n * the remaining of the command string.\n */\nstatic const char *get_command_name(const char *cmdline,\n                                    char *cmdname, size_t nlen)\n{\n    size_t len;\n    const char *p, *pstart;\n\n    p = cmdline;\n    while (qemu_isspace(*p))\n        p++;\n    if (*p == '\\0')\n        return NULL;\n    pstart = p;\n    while (*p != '\\0' && *p != '/' && !qemu_isspace(*p))\n        p++;\n    len = p - pstart;\n    if (len > nlen - 1)\n        len = nlen - 1;\n    memcpy(cmdname, pstart, len);\n    cmdname[len] = '\\0';\n    return p;\n}\n\n/**\n * Read key of 'type' into 'key' and return the current\n * 'type' pointer.\n */\nstatic char *key_get_info(const char *type, char **key)\n{\n    size_t len;\n    char *p, *str;\n\n    if (*type == ',')\n        type++;\n\n    p = strchr(type, ':');\n    if (!p) {\n        *key = NULL;\n        return NULL;\n    }\n    len = p - type;\n\n    str = g_malloc(len + 1);\n    memcpy(str, type, len);\n    str[len] = '\\0';\n\n    *key = str;\n    return ++p;\n}\n\nstatic int default_fmt_format = 'x';\nstatic int default_fmt_size = 4;\n\nstatic int is_valid_option(const char *c, const char *typestr)\n{\n    char option[3];\n  \n    option[0] = '-';\n    option[1] = *c;\n    option[2] = '\\0';\n  \n    typestr = strstr(typestr, option);\n    return (typestr != NULL);\n}\n\nstatic const mon_cmd_t *search_dispatch_table(const mon_cmd_t *disp_table,\n                                              const char *cmdname)\n{\n    const mon_cmd_t *cmd;\n\n    for (cmd = disp_table; cmd->name != NULL; cmd++) {\n        if (compare_cmd(cmdname, cmd->name)) {\n            return cmd;\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * Parse command name from @cmdp according to command table @table.\n * If blank, return NULL.\n * Else, if no valid command can be found, report to @mon, and return\n * NULL.\n * Else, change @cmdp to point right behind the name, and return its\n * command table entry.\n * Do not assume the return value points into @table!  It doesn't when\n * the command is found in a sub-command table.\n */\nstatic const mon_cmd_t *monitor_parse_command(Monitor *mon,\n                                              const char **cmdp,\n                                              mon_cmd_t *table)\n{\n    const char *p;\n    const mon_cmd_t *cmd;\n    char cmdname[256];\n\n    /* extract the command name */\n    p = get_command_name(*cmdp, cmdname, sizeof(cmdname));\n    if (!p)\n        return NULL;\n\n    cmd = search_dispatch_table(table, cmdname);\n    if (!cmd) {\n        monitor_printf(mon, \"unknown command: '%.*s'\\n\",\n                       (int)(p - *cmdp), *cmdp);\n        return NULL;\n    }\n\n    /* filter out following useless space */\n    while (qemu_isspace(*p)) {\n        p++;\n    }\n\n    *cmdp = p;\n    /* search sub command */\n    if (cmd->sub_table != NULL && *p != '\\0') {\n        return monitor_parse_command(mon, cmdp, cmd->sub_table);\n    }\n\n    return cmd;\n}\n\n/*\n * Parse arguments for @cmd.\n * If it can't be parsed, report to @mon, and return NULL.\n * Else, insert command arguments into a QDict, and return it.\n * Note: On success, caller has to free the QDict structure.\n */\n\nstatic QDict *monitor_parse_arguments(Monitor *mon,\n                                      const char **endp,\n                                      const mon_cmd_t *cmd)\n{\n    const char *typestr;\n    char *key;\n    int c;\n    const char *p = *endp;\n    char buf[1024];\n    QDict *qdict = qdict_new();\n\n    /* parse the parameters */\n    typestr = cmd->args_type;\n    for(;;) {\n        typestr = key_get_info(typestr, &key);\n        if (!typestr)\n            break;\n        c = *typestr;\n        typestr++;\n        switch(c) {\n        case 'F':\n        case 'B':\n        case 's':\n            {\n                int ret;\n\n                while (qemu_isspace(*p))\n                    p++;\n                if (*typestr == '?') {\n                    typestr++;\n                    if (*p == '\\0') {\n                        /* no optional string: NULL argument */\n                        break;\n                    }\n                }\n                ret = get_str(buf, sizeof(buf), &p);\n                if (ret < 0) {\n                    switch(c) {\n                    case 'F':\n                        monitor_printf(mon, \"%s: filename expected\\n\",\n                                       cmd->name);\n                        break;\n                    case 'B':\n                        monitor_printf(mon, \"%s: block device name expected\\n\",\n                                       cmd->name);\n                        break;\n                    default:\n                        monitor_printf(mon, \"%s: string expected\\n\", cmd->name);\n                        break;\n                    }\n                    goto fail;\n                }\n                qdict_put_str(qdict, key, buf);\n            }\n            break;\n        case 'O':\n            {\n                QemuOptsList *opts_list;\n                QemuOpts *opts;\n\n                opts_list = qemu_find_opts(key);\n                if (!opts_list || opts_list->desc->name) {\n                    goto bad_type;\n                }\n                while (qemu_isspace(*p)) {\n                    p++;\n                }\n                if (!*p)\n                    break;\n                if (get_str(buf, sizeof(buf), &p) < 0) {\n                    goto fail;\n                }\n                opts = qemu_opts_parse_noisily(opts_list, buf, true);\n                if (!opts) {\n                    goto fail;\n                }\n                qemu_opts_to_qdict(opts, qdict);\n                qemu_opts_del(opts);\n            }\n            break;\n        case '/':\n            {\n                int count, format, size;\n\n                while (qemu_isspace(*p))\n                    p++;\n                if (*p == '/') {\n                    /* format found */\n                    p++;\n                    count = 1;\n                    if (qemu_isdigit(*p)) {\n                        count = 0;\n                        while (qemu_isdigit(*p)) {\n                            count = count * 10 + (*p - '0');\n                            p++;\n                        }\n                    }\n                    size = -1;\n                    format = -1;\n                    for(;;) {\n                        switch(*p) {\n                        case 'o':\n                        case 'd':\n                        case 'u':\n                        case 'x':\n                        case 'i':\n                        case 'c':\n                            format = *p++;\n                            break;\n                        case 'b':\n                            size = 1;\n                            p++;\n                            break;\n                        case 'h':\n                            size = 2;\n                            p++;\n                            break;\n                        case 'w':\n                            size = 4;\n                            p++;\n                            break;\n                        case 'g':\n                        case 'L':\n                            size = 8;\n                            p++;\n                            break;\n                        default:\n                            goto next;\n                        }\n                    }\n                next:\n                    if (*p != '\\0' && !qemu_isspace(*p)) {\n                        monitor_printf(mon, \"invalid char in format: '%c'\\n\",\n                                       *p);\n                        goto fail;\n                    }\n                    if (format < 0)\n                        format = default_fmt_format;\n                    if (format != 'i') {\n                        /* for 'i', not specifying a size gives -1 as size */\n                        if (size < 0)\n                            size = default_fmt_size;\n                        default_fmt_size = size;\n                    }\n                    default_fmt_format = format;\n                } else {\n                    count = 1;\n                    format = default_fmt_format;\n                    if (format != 'i') {\n                        size = default_fmt_size;\n                    } else {\n                        size = -1;\n                    }\n                }\n                qdict_put_int(qdict, \"count\", count);\n                qdict_put_int(qdict, \"format\", format);\n                qdict_put_int(qdict, \"size\", size);\n            }\n            break;\n        case 'i':\n        case 'l':\n        case 'M':\n            {\n                int64_t val;\n\n                while (qemu_isspace(*p))\n                    p++;\n                if (*typestr == '?' || *typestr == '.') {\n                    if (*typestr == '?') {\n                        if (*p == '\\0') {\n                            typestr++;\n                            break;\n                        }\n                    } else {\n                        if (*p == '.') {\n                            p++;\n                            while (qemu_isspace(*p))\n                                p++;\n                        } else {\n                            typestr++;\n                            break;\n                        }\n                    }\n                    typestr++;\n                }\n                if (get_expr(mon, &val, &p))\n                    goto fail;\n                /* Check if 'i' is greater than 32-bit */\n                if ((c == 'i') && ((val >> 32) & 0xffffffff)) {\n                    monitor_printf(mon, \"\\'%s\\' has failed: \", cmd->name);\n                    monitor_printf(mon, \"integer is for 32-bit values\\n\");\n                    goto fail;\n                } else if (c == 'M') {\n                    if (val < 0) {\n                        monitor_printf(mon, \"enter a positive value\\n\");\n                        goto fail;\n                    }\n                    val <<= 20;\n                }\n                qdict_put_int(qdict, key, val);\n            }\n            break;\n        case 'o':\n            {\n                int ret;\n                uint64_t val;\n                char *end;\n\n                while (qemu_isspace(*p)) {\n                    p++;\n                }\n                if (*typestr == '?') {\n                    typestr++;\n                    if (*p == '\\0') {\n                        break;\n                    }\n                }\n                ret = qemu_strtosz_MiB(p, &end, &val);\n                if (ret < 0 || val > INT64_MAX) {\n                    monitor_printf(mon, \"invalid size\\n\");\n                    goto fail;\n                }\n                qdict_put_int(qdict, key, val);\n                p = end;\n            }\n            break;\n        case 'T':\n            {\n                double val;\n\n                while (qemu_isspace(*p))\n                    p++;\n                if (*typestr == '?') {\n                    typestr++;\n                    if (*p == '\\0') {\n                        break;\n                    }\n                }\n                if (get_double(mon, &val, &p) < 0) {\n                    goto fail;\n                }\n                if (p[0] && p[1] == 's') {\n                    switch (*p) {\n                    case 'm':\n                        val /= 1e3; p += 2; break;\n                    case 'u':\n                        val /= 1e6; p += 2; break;\n                    case 'n':\n                        val /= 1e9; p += 2; break;\n                    }\n                }\n                if (*p && !qemu_isspace(*p)) {\n                    monitor_printf(mon, \"Unknown unit suffix\\n\");\n                    goto fail;\n                }\n                qdict_put(qdict, key, qfloat_from_double(val));\n            }\n            break;\n        case 'b':\n            {\n                const char *beg;\n                bool val;\n\n                while (qemu_isspace(*p)) {\n                    p++;\n                }\n                beg = p;\n                while (qemu_isgraph(*p)) {\n                    p++;\n                }\n                if (p - beg == 2 && !memcmp(beg, \"on\", p - beg)) {\n                    val = true;\n                } else if (p - beg == 3 && !memcmp(beg, \"off\", p - beg)) {\n                    val = false;\n                } else {\n                    monitor_printf(mon, \"Expected 'on' or 'off'\\n\");\n                    goto fail;\n                }\n                qdict_put_bool(qdict, key, val);\n            }\n            break;\n        case '-':\n            {\n                const char *tmp = p;\n                int skip_key = 0;\n                /* option */\n\n                c = *typestr++;\n                if (c == '\\0')\n                    goto bad_type;\n                while (qemu_isspace(*p))\n                    p++;\n                if (*p == '-') {\n                    p++;\n                    if(c != *p) {\n                        if(!is_valid_option(p, typestr)) {\n                  \n                            monitor_printf(mon, \"%s: unsupported option -%c\\n\",\n                                           cmd->name, *p);\n                            goto fail;\n                        } else {\n                            skip_key = 1;\n                        }\n                    }\n                    if(skip_key) {\n                        p = tmp;\n                    } else {\n                        /* has option */\n                        p++;\n                        qdict_put_bool(qdict, key, true);\n                    }\n                }\n            }\n            break;\n        case 'S':\n            {\n                /* package all remaining string */\n                int len;\n\n                while (qemu_isspace(*p)) {\n                    p++;\n                }\n                if (*typestr == '?') {\n                    typestr++;\n                    if (*p == '\\0') {\n                        /* no remaining string: NULL argument */\n                        break;\n                    }\n                }\n                len = strlen(p);\n                if (len <= 0) {\n                    monitor_printf(mon, \"%s: string expected\\n\",\n                                   cmd->name);\n                    goto fail;\n                }\n                qdict_put_str(qdict, key, p);\n                p += len;\n            }\n            break;\n        default:\n        bad_type:\n            monitor_printf(mon, \"%s: unknown type '%c'\\n\", cmd->name, c);\n            goto fail;\n        }\n        g_free(key);\n        key = NULL;\n    }\n    /* check that all arguments were parsed */\n    while (qemu_isspace(*p))\n        p++;\n    if (*p != '\\0') {\n        monitor_printf(mon, \"%s: extraneous characters at the end of line\\n\",\n                       cmd->name);\n        goto fail;\n    }\n\n    return qdict;\n\nfail:\n    QDECREF(qdict);\n    g_free(key);\n    return NULL;\n}\n\nstatic void handle_hmp_command(Monitor *mon, const char *cmdline)\n{\n    QDict *qdict;\n    const mon_cmd_t *cmd;\n\n    cmd = monitor_parse_command(mon, &cmdline, mon->cmd_table);\n    if (!cmd) {\n        return;\n    }\n\n    qdict = monitor_parse_arguments(mon, &cmdline, cmd);\n    if (!qdict) {\n        monitor_printf(mon, \"Try \\\"help %s\\\" for more information\\n\",\n                       cmd->name);\n        return;\n    }\n\n    cmd->cmd(mon, qdict);\n    QDECREF(qdict);\n}\n\nstatic void cmd_completion(Monitor *mon, const char *name, const char *list)\n{\n    const char *p, *pstart;\n    char cmd[128];\n    int len;\n\n    p = list;\n    for(;;) {\n        pstart = p;\n        p = strchr(p, '|');\n        if (!p)\n            p = pstart + strlen(pstart);\n        len = p - pstart;\n        if (len > sizeof(cmd) - 2)\n            len = sizeof(cmd) - 2;\n        memcpy(cmd, pstart, len);\n        cmd[len] = '\\0';\n        if (name[0] == '\\0' || !strncmp(name, cmd, strlen(name))) {\n            readline_add_completion(mon->rs, cmd);\n        }\n        if (*p == '\\0')\n            break;\n        p++;\n    }\n}\n\nstatic void file_completion(Monitor *mon, const char *input)\n{\n    DIR *ffs;\n    struct dirent *d;\n    char path[1024];\n    char file[1024], file_prefix[1024];\n    int input_path_len;\n    const char *p;\n\n    p = strrchr(input, '/');\n    if (!p) {\n        input_path_len = 0;\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n        pstrcpy(path, sizeof(path), \".\");\n    } else {\n        input_path_len = p - input + 1;\n        memcpy(path, input, input_path_len);\n        if (input_path_len > sizeof(path) - 1)\n            input_path_len = sizeof(path) - 1;\n        path[input_path_len] = '\\0';\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n    }\n\n    ffs = opendir(path);\n    if (!ffs)\n        return;\n    for(;;) {\n        struct stat sb;\n        d = readdir(ffs);\n        if (!d)\n            break;\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n            memcpy(file, input, input_path_len);\n            if (input_path_len < sizeof(file))\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n                        d->d_name);\n            /* stat the file to find out if it's a directory.\n             * In that case add a slash to speed up typing long paths\n             */\n            if (stat(file, &sb) == 0 && S_ISDIR(sb.st_mode)) {\n                pstrcat(file, sizeof(file), \"/\");\n            }\n            readline_add_completion(mon->rs, file);\n        }\n    }\n    closedir(ffs);\n}\n\nstatic const char *next_arg_type(const char *typestr)\n{\n    const char *p = strchr(typestr, ':');\n    return (p != NULL ? ++p : typestr);\n}\n\nstatic void add_completion_option(ReadLineState *rs, const char *str,\n                                  const char *option)\n{\n    if (!str || !option) {\n        return;\n    }\n    if (!strncmp(option, str, strlen(str))) {\n        readline_add_completion(rs, option);\n    }\n}\n\nvoid chardev_add_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n    ChardevBackendInfoList *list, *start;\n\n    if (nb_args != 2) {\n        return;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n\n    start = list = qmp_query_chardev_backends(NULL);\n    while (list) {\n        const char *chr_name = list->value->name;\n\n        if (!strncmp(chr_name, str, len)) {\n            readline_add_completion(rs, chr_name);\n        }\n        list = list->next;\n    }\n    qapi_free_ChardevBackendInfoList(start);\n}\n\nvoid netdev_add_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n    int i;\n\n    if (nb_args != 2) {\n        return;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    for (i = 0; NetClientDriver_lookup[i]; i++) {\n        add_completion_option(rs, str, NetClientDriver_lookup[i]);\n    }\n}\n\nvoid device_add_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    GSList *list, *elt;\n    size_t len;\n\n    if (nb_args != 2) {\n        return;\n    }\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    list = elt = object_class_get_list(TYPE_DEVICE, false);\n    while (elt) {\n        const char *name;\n        DeviceClass *dc = OBJECT_CLASS_CHECK(DeviceClass, elt->data,\n                                             TYPE_DEVICE);\n        name = object_class_get_name(OBJECT_CLASS(dc));\n\n        if (dc->user_creatable\n            && !strncmp(name, str, len)) {\n            readline_add_completion(rs, name);\n        }\n        elt = elt->next;\n    }\n    g_slist_free(list);\n}\n\nvoid object_add_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    GSList *list, *elt;\n    size_t len;\n\n    if (nb_args != 2) {\n        return;\n    }\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    list = elt = object_class_get_list(TYPE_USER_CREATABLE, false);\n    while (elt) {\n        const char *name;\n\n        name = object_class_get_name(OBJECT_CLASS(elt->data));\n        if (!strncmp(name, str, len) && strcmp(name, TYPE_USER_CREATABLE)) {\n            readline_add_completion(rs, name);\n        }\n        elt = elt->next;\n    }\n    g_slist_free(list);\n}\n\nstatic void peripheral_device_del_completion(ReadLineState *rs,\n                                             const char *str, size_t len)\n{\n    Object *peripheral = container_get(qdev_get_machine(), \"/peripheral\");\n    GSList *list, *item;\n\n    list = qdev_build_hotpluggable_device_list(peripheral);\n    if (!list) {\n        return;\n    }\n\n    for (item = list; item; item = g_slist_next(item)) {\n        DeviceState *dev = item->data;\n\n        if (dev->id && !strncmp(str, dev->id, len)) {\n            readline_add_completion(rs, dev->id);\n        }\n    }\n\n    g_slist_free(list);\n}\n\nvoid chardev_remove_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n    ChardevInfoList *list, *start;\n\n    if (nb_args != 2) {\n        return;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n\n    start = list = qmp_query_chardev(NULL);\n    while (list) {\n        ChardevInfo *chr = list->value;\n\n        if (!strncmp(chr->label, str, len)) {\n            readline_add_completion(rs, chr->label);\n        }\n        list = list->next;\n    }\n    qapi_free_ChardevInfoList(start);\n}\n\nstatic void ringbuf_completion(ReadLineState *rs, const char *str)\n{\n    size_t len;\n    ChardevInfoList *list, *start;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n\n    start = list = qmp_query_chardev(NULL);\n    while (list) {\n        ChardevInfo *chr_info = list->value;\n\n        if (!strncmp(chr_info->label, str, len)) {\n            Chardev *chr = qemu_chr_find(chr_info->label);\n            if (chr && CHARDEV_IS_RINGBUF(chr)) {\n                readline_add_completion(rs, chr_info->label);\n            }\n        }\n        list = list->next;\n    }\n    qapi_free_ChardevInfoList(start);\n}\n\nvoid ringbuf_write_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    if (nb_args != 2) {\n        return;\n    }\n    ringbuf_completion(rs, str);\n}\n\nvoid device_del_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n\n    if (nb_args != 2) {\n        return;\n    }\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    peripheral_device_del_completion(rs, str, len);\n}\n\nvoid object_del_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    ObjectPropertyInfoList *list, *start;\n    size_t len;\n\n    if (nb_args != 2) {\n        return;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n\n    start = list = qmp_qom_list(\"/objects\", NULL);\n    while (list) {\n        ObjectPropertyInfo *info = list->value;\n\n        if (!strncmp(info->type, \"child<\", 5)\n            && !strncmp(info->name, str, len)) {\n            readline_add_completion(rs, info->name);\n        }\n        list = list->next;\n    }\n    qapi_free_ObjectPropertyInfoList(start);\n}\n\nvoid sendkey_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    int i;\n    char *sep;\n    size_t len;\n\n    if (nb_args != 2) {\n        return;\n    }\n    sep = strrchr(str, '-');\n    if (sep) {\n        str = sep + 1;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    for (i = 0; i < Q_KEY_CODE__MAX; i++) {\n        if (!strncmp(str, QKeyCode_lookup[i], len)) {\n            readline_add_completion(rs, QKeyCode_lookup[i]);\n        }\n    }\n}\n\nvoid set_link_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        NetClientState *ncs[MAX_QUEUE_NUM];\n        int count, i;\n        count = qemu_find_net_clients_except(NULL, ncs,\n                                             NET_CLIENT_DRIVER_NONE,\n                                             MAX_QUEUE_NUM);\n        for (i = 0; i < MIN(count, MAX_QUEUE_NUM); i++) {\n            const char *name = ncs[i]->name;\n            if (!strncmp(str, name, len)) {\n                readline_add_completion(rs, name);\n            }\n        }\n    } else if (nb_args == 3) {\n        add_completion_option(rs, str, \"on\");\n        add_completion_option(rs, str, \"off\");\n    }\n}\n\nvoid netdev_del_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    int len, count, i;\n    NetClientState *ncs[MAX_QUEUE_NUM];\n\n    if (nb_args != 2) {\n        return;\n    }\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    count = qemu_find_net_clients_except(NULL, ncs, NET_CLIENT_DRIVER_NIC,\n                                         MAX_QUEUE_NUM);\n    for (i = 0; i < MIN(count, MAX_QUEUE_NUM); i++) {\n        QemuOpts *opts;\n        const char *name = ncs[i]->name;\n        if (strncmp(str, name, len)) {\n            continue;\n        }\n        opts = qemu_opts_find(qemu_find_opts_err(\"netdev\", NULL), name);\n        if (opts) {\n            readline_add_completion(rs, name);\n        }\n    }\n}\n\nvoid info_trace_events_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        TraceEventIter iter;\n        TraceEvent *ev;\n        char *pattern = g_strdup_printf(\"%s*\", str);\n        trace_event_iter_init(&iter, pattern);\n        while ((ev = trace_event_iter_next(&iter)) != NULL) {\n            readline_add_completion(rs, trace_event_get_name(ev));\n        }\n        g_free(pattern);\n    }\n}\n\nvoid trace_event_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    size_t len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        TraceEventIter iter;\n        TraceEvent *ev;\n        char *pattern = g_strdup_printf(\"%s*\", str);\n        trace_event_iter_init(&iter, pattern);\n        while ((ev = trace_event_iter_next(&iter)) != NULL) {\n            readline_add_completion(rs, trace_event_get_name(ev));\n        }\n        g_free(pattern);\n    } else if (nb_args == 3) {\n        add_completion_option(rs, str, \"on\");\n        add_completion_option(rs, str, \"off\");\n    }\n}\n\nvoid watchdog_action_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    int i;\n\n    if (nb_args != 2) {\n        return;\n    }\n    readline_set_completion_index(rs, strlen(str));\n    for (i = 0; WatchdogExpirationAction_lookup[i]; i++) {\n        add_completion_option(rs, str, WatchdogExpirationAction_lookup[i]);\n    }\n}\n\nvoid migrate_set_capability_completion(ReadLineState *rs, int nb_args,\n                                       const char *str)\n{\n    size_t len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        int i;\n        for (i = 0; i < MIGRATION_CAPABILITY__MAX; i++) {\n            const char *name = MigrationCapability_lookup[i];\n            if (!strncmp(str, name, len)) {\n                readline_add_completion(rs, name);\n            }\n        }\n    } else if (nb_args == 3) {\n        add_completion_option(rs, str, \"on\");\n        add_completion_option(rs, str, \"off\");\n    }\n}\n\nvoid migrate_set_parameter_completion(ReadLineState *rs, int nb_args,\n                                      const char *str)\n{\n    size_t len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        int i;\n        for (i = 0; i < MIGRATION_PARAMETER__MAX; i++) {\n            const char *name = MigrationParameter_lookup[i];\n            if (!strncmp(str, name, len)) {\n                readline_add_completion(rs, name);\n            }\n        }\n    }\n}\n\nvoid host_net_add_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    int i;\n    size_t len;\n    if (nb_args != 2) {\n        return;\n    }\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    for (i = 0; host_net_devices[i]; i++) {\n        if (!strncmp(host_net_devices[i], str, len)) {\n            readline_add_completion(rs, host_net_devices[i]);\n        }\n    }\n}\n\nvoid host_net_remove_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    NetClientState *ncs[MAX_QUEUE_NUM];\n    int count, i, len;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n    if (nb_args == 2) {\n        count = qemu_find_net_clients_except(NULL, ncs,\n                                             NET_CLIENT_DRIVER_NONE,\n                                             MAX_QUEUE_NUM);\n        for (i = 0; i < MIN(count, MAX_QUEUE_NUM); i++) {\n            int id;\n            char name[16];\n\n            if (net_hub_id_for_client(ncs[i], &id)) {\n                continue;\n            }\n            snprintf(name, sizeof(name), \"%d\", id);\n            if (!strncmp(str, name, len)) {\n                readline_add_completion(rs, name);\n            }\n        }\n        return;\n    } else if (nb_args == 3) {\n        count = qemu_find_net_clients_except(NULL, ncs,\n                                             NET_CLIENT_DRIVER_NIC,\n                                             MAX_QUEUE_NUM);\n        for (i = 0; i < MIN(count, MAX_QUEUE_NUM); i++) {\n            int id;\n            const char *name;\n\n            if (ncs[i]->info->type == NET_CLIENT_DRIVER_HUBPORT ||\n                net_hub_id_for_client(ncs[i], &id)) {\n                continue;\n            }\n            name = ncs[i]->name;\n            if (!strncmp(str, name, len)) {\n                readline_add_completion(rs, name);\n            }\n        }\n        return;\n    }\n}\n\nstatic void vm_completion(ReadLineState *rs, const char *str)\n{\n    size_t len;\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    len = strlen(str);\n    readline_set_completion_index(rs, len);\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        SnapshotInfoList *snapshots, *snapshot;\n        AioContext *ctx = bdrv_get_aio_context(bs);\n        bool ok = false;\n\n        aio_context_acquire(ctx);\n        if (bdrv_can_snapshot(bs)) {\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n        }\n        aio_context_release(ctx);\n        if (!ok) {\n            continue;\n        }\n\n        snapshot = snapshots;\n        while (snapshot) {\n            char *completion = snapshot->value->name;\n            if (!strncmp(str, completion, len)) {\n                readline_add_completion(rs, completion);\n            }\n            completion = snapshot->value->id;\n            if (!strncmp(str, completion, len)) {\n                readline_add_completion(rs, completion);\n            }\n            snapshot = snapshot->next;\n        }\n        qapi_free_SnapshotInfoList(snapshots);\n    }\n\n}\n\nvoid delvm_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    if (nb_args == 2) {\n        vm_completion(rs, str);\n    }\n}\n\nvoid loadvm_completion(ReadLineState *rs, int nb_args, const char *str)\n{\n    if (nb_args == 2) {\n        vm_completion(rs, str);\n    }\n}\n\nstatic void monitor_find_completion_by_table(Monitor *mon,\n                                             const mon_cmd_t *cmd_table,\n                                             char **args,\n                                             int nb_args)\n{\n    const char *cmdname;\n    int i;\n    const char *ptype, *str, *name;\n    const mon_cmd_t *cmd;\n    BlockBackend *blk = NULL;\n\n    if (nb_args <= 1) {\n        /* command completion */\n        if (nb_args == 0)\n            cmdname = \"\";\n        else\n            cmdname = args[0];\n        readline_set_completion_index(mon->rs, strlen(cmdname));\n        for (cmd = cmd_table; cmd->name != NULL; cmd++) {\n            cmd_completion(mon, cmdname, cmd->name);\n        }\n    } else {\n        /* find the command */\n        for (cmd = cmd_table; cmd->name != NULL; cmd++) {\n            if (compare_cmd(args[0], cmd->name)) {\n                break;\n            }\n        }\n        if (!cmd->name) {\n            return;\n        }\n\n        if (cmd->sub_table) {\n            /* do the job again */\n            monitor_find_completion_by_table(mon, cmd->sub_table,\n                                             &args[1], nb_args - 1);\n            return;\n        }\n        if (cmd->command_completion) {\n            cmd->command_completion(mon->rs, nb_args, args[nb_args - 1]);\n            return;\n        }\n\n        ptype = next_arg_type(cmd->args_type);\n        for(i = 0; i < nb_args - 2; i++) {\n            if (*ptype != '\\0') {\n                ptype = next_arg_type(ptype);\n                while (*ptype == '?')\n                    ptype = next_arg_type(ptype);\n            }\n        }\n        str = args[nb_args - 1];\n        while (*ptype == '-' && ptype[1] != '\\0') {\n            ptype = next_arg_type(ptype);\n        }\n        switch(*ptype) {\n        case 'F':\n            /* file completion */\n            readline_set_completion_index(mon->rs, strlen(str));\n            file_completion(mon, str);\n            break;\n        case 'B':\n            /* block device name completion */\n            readline_set_completion_index(mon->rs, strlen(str));\n            while ((blk = blk_next(blk)) != NULL) {\n                name = blk_name(blk);\n                if (str[0] == '\\0' ||\n                    !strncmp(name, str, strlen(str))) {\n                    readline_add_completion(mon->rs, name);\n                }\n            }\n            break;\n        case 's':\n        case 'S':\n            if (!strcmp(cmd->name, \"help|?\")) {\n                monitor_find_completion_by_table(mon, cmd_table,\n                                                 &args[1], nb_args - 1);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nstatic void monitor_find_completion(void *opaque,\n                                    const char *cmdline)\n{\n    Monitor *mon = opaque;\n    char *args[MAX_ARGS];\n    int nb_args, len;\n\n    /* 1. parse the cmdline */\n    if (parse_cmdline(cmdline, &nb_args, args) < 0) {\n        return;\n    }\n\n    /* if the line ends with a space, it means we want to complete the\n       next arg */\n    len = strlen(cmdline);\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n        if (nb_args >= MAX_ARGS) {\n            goto cleanup;\n        }\n        args[nb_args++] = g_strdup(\"\");\n    }\n\n    /* 2. auto complete according to args */\n    monitor_find_completion_by_table(mon, mon->cmd_table, args, nb_args);\n\ncleanup:\n    free_cmdline_args(args, nb_args);\n}\n\nstatic int monitor_can_read(void *opaque)\n{\n    Monitor *mon = opaque;\n\n    return (mon->suspend_cnt == 0) ? 1 : 0;\n}\n\nstatic void handle_qmp_command(JSONMessageParser *parser, GQueue *tokens)\n{\n    QObject *req, *rsp = NULL, *id = NULL;\n    QDict *qdict = NULL;\n    Monitor *mon = cur_mon;\n    Error *err = NULL;\n\n    req = json_parser_parse_err(tokens, NULL, &err);\n    if (!req && !err) {\n        /* json_parser_parse_err() sucks: can fail without setting @err */\n        error_setg(&err, QERR_JSON_PARSING);\n    }\n    if (err) {\n        goto err_out;\n    }\n\n    qdict = qobject_to_qdict(req);\n    if (qdict) {\n        id = qdict_get(qdict, \"id\");\n        qobject_incref(id);\n        qdict_del(qdict, \"id\");\n    } /* else will fail qmp_dispatch() */\n\n    rsp = qmp_dispatch(cur_mon->qmp.commands, req);\n\n    if (mon->qmp.commands == &qmp_cap_negotiation_commands) {\n        qdict = qdict_get_qdict(qobject_to_qdict(rsp), \"error\");\n        if (qdict\n            && !g_strcmp0(qdict_get_try_str(qdict, \"class\"),\n                    QapiErrorClass_lookup[ERROR_CLASS_COMMAND_NOT_FOUND])) {\n            /* Provide a more useful error message */\n            qdict_del(qdict, \"desc\");\n            qdict_put_str(qdict, \"desc\", \"Expecting capabilities negotiation\"\n                          \" with 'qmp_capabilities'\");\n        }\n    }\n\nerr_out:\n    if (err) {\n        qdict = qdict_new();\n        qdict_put_obj(qdict, \"error\", qmp_build_error_object(err));\n        error_free(err);\n        rsp = QOBJECT(qdict);\n    }\n\n    if (rsp) {\n        if (id) {\n            qdict_put_obj(qobject_to_qdict(rsp), \"id\", id);\n            id = NULL;\n        }\n\n        monitor_json_emitter(mon, rsp);\n    }\n\n    qobject_decref(id);\n    qobject_decref(rsp);\n    qobject_decref(req);\n}\n\nstatic void monitor_qmp_read(void *opaque, const uint8_t *buf, int size)\n{\n    Monitor *old_mon = cur_mon;\n\n    cur_mon = opaque;\n\n    json_message_parser_feed(&cur_mon->qmp.parser, (const char *) buf, size);\n\n    cur_mon = old_mon;\n}\n\nstatic void monitor_read(void *opaque, const uint8_t *buf, int size)\n{\n    Monitor *old_mon = cur_mon;\n    int i;\n\n    cur_mon = opaque;\n\n    if (cur_mon->rs) {\n        for (i = 0; i < size; i++)\n            readline_handle_byte(cur_mon->rs, buf[i]);\n    } else {\n        if (size == 0 || buf[size - 1] != 0)\n            monitor_printf(cur_mon, \"corrupted command\\n\");\n        else\n            handle_hmp_command(cur_mon, (char *)buf);\n    }\n\n    cur_mon = old_mon;\n}\n\nstatic void monitor_command_cb(void *opaque, const char *cmdline,\n                               void *readline_opaque)\n{\n    Monitor *mon = opaque;\n\n    monitor_suspend(mon);\n    handle_hmp_command(mon, cmdline);\n    monitor_resume(mon);\n}\n\nint monitor_suspend(Monitor *mon)\n{\n    if (!mon->rs)\n        return -ENOTTY;\n    mon->suspend_cnt++;\n    return 0;\n}\n\nvoid monitor_resume(Monitor *mon)\n{\n    if (!mon->rs)\n        return;\n    if (--mon->suspend_cnt == 0)\n        readline_show_prompt(mon->rs);\n}\n\nstatic QObject *get_qmp_greeting(void)\n{\n    QObject *ver = NULL;\n\n    qmp_marshal_query_version(NULL, &ver, NULL);\n\n    return qobject_from_jsonf(\"{'QMP': {'version': %p, 'capabilities': []}}\",\n                              ver);\n}\n\nstatic void monitor_qmp_event(void *opaque, int event)\n{\n    QObject *data;\n    Monitor *mon = opaque;\n\n    switch (event) {\n    case CHR_EVENT_OPENED:\n        mon->qmp.commands = &qmp_cap_negotiation_commands;\n        data = get_qmp_greeting();\n        monitor_json_emitter(mon, data);\n        qobject_decref(data);\n        mon_refcount++;\n        break;\n    case CHR_EVENT_CLOSED:\n        json_message_parser_destroy(&mon->qmp.parser);\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n        mon_refcount--;\n        monitor_fdsets_cleanup();\n        break;\n    }\n}\n\nstatic void monitor_event(void *opaque, int event)\n{\n    Monitor *mon = opaque;\n\n    switch (event) {\n    case CHR_EVENT_MUX_IN:\n        qemu_mutex_lock(&mon->out_lock);\n        mon->mux_out = 0;\n        qemu_mutex_unlock(&mon->out_lock);\n        if (mon->reset_seen) {\n            readline_restart(mon->rs);\n            monitor_resume(mon);\n            monitor_flush(mon);\n        } else {\n            mon->suspend_cnt = 0;\n        }\n        break;\n\n    case CHR_EVENT_MUX_OUT:\n        if (mon->reset_seen) {\n            if (mon->suspend_cnt == 0) {\n                monitor_printf(mon, \"\\n\");\n            }\n            monitor_flush(mon);\n            monitor_suspend(mon);\n        } else {\n            mon->suspend_cnt++;\n        }\n        qemu_mutex_lock(&mon->out_lock);\n        mon->mux_out = 1;\n        qemu_mutex_unlock(&mon->out_lock);\n        break;\n\n    case CHR_EVENT_OPENED:\n        monitor_printf(mon, \"QEMU %s monitor - type 'help' for more \"\n                       \"information\\n\", QEMU_VERSION);\n        if (!mon->mux_out) {\n            readline_restart(mon->rs);\n            readline_show_prompt(mon->rs);\n        }\n        mon->reset_seen = 1;\n        mon_refcount++;\n        break;\n\n    case CHR_EVENT_CLOSED:\n        mon_refcount--;\n        monitor_fdsets_cleanup();\n        break;\n    }\n}\n\nstatic int\ncompare_mon_cmd(const void *a, const void *b)\n{\n    return strcmp(((const mon_cmd_t *)a)->name,\n            ((const mon_cmd_t *)b)->name);\n}\n\nstatic void sortcmdlist(void)\n{\n    int array_num;\n    int elem_size = sizeof(mon_cmd_t);\n\n    array_num = sizeof(mon_cmds)/elem_size-1;\n    qsort((void *)mon_cmds, array_num, elem_size, compare_mon_cmd);\n\n    array_num = sizeof(info_cmds)/elem_size-1;\n    qsort((void *)info_cmds, array_num, elem_size, compare_mon_cmd);\n}\n\n/* These functions just adapt the readline interface in a typesafe way.  We\n * could cast function pointers but that discards compiler checks.\n */\nstatic void GCC_FMT_ATTR(2, 3) monitor_readline_printf(void *opaque,\n                                                       const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    monitor_vprintf(opaque, fmt, ap);\n    va_end(ap);\n}\n\nstatic void monitor_readline_flush(void *opaque)\n{\n    monitor_flush(opaque);\n}\n\n/*\n * Print to current monitor if we have one, else to stderr.\n * TODO should return int, so callers can calculate width, but that\n * requires surgery to monitor_vprintf().  Left for another day.\n */\nvoid error_vprintf(const char *fmt, va_list ap)\n{\n    if (cur_mon && !monitor_cur_is_qmp()) {\n        monitor_vprintf(cur_mon, fmt, ap);\n    } else {\n        vfprintf(stderr, fmt, ap);\n    }\n}\n\nvoid error_vprintf_unless_qmp(const char *fmt, va_list ap)\n{\n    if (cur_mon && !monitor_cur_is_qmp()) {\n        monitor_vprintf(cur_mon, fmt, ap);\n    } else if (!cur_mon) {\n        vfprintf(stderr, fmt, ap);\n    }\n}\n\nstatic void error_printf_internal(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    error_vprintf(fmt, ap);\n    va_end(ap);\n}\n\nstatic void __attribute__((constructor)) monitor_lock_init(void)\n{\n    qemu_mutex_init(&monitor_lock);\n}\n\n// Create a panda chardev and monitor to interact with (panda_chr and panda_mon)\nvoid panda_init_monitor(void) {\n  if (panda_mon != NULL) {\n    return;\n  }\n  Chardev* chr;\n  chr = qemu_chardev_new(NULL, TYPE_CHARDEV_PANDA,\n        NULL, &error_abort);\n\n  // Modified version of logic from monitor_init\n  int flags=0;\n  panda_mon = g_malloc(sizeof(*panda_mon));\n  monitor_data_init(panda_mon);\n\n  qemu_chr_fe_init(&panda_mon->chr, chr, &error_abort);\n  panda_mon->flags = flags;\n  qemu_chr_fe_set_handlers(&panda_mon->chr, monitor_can_read, monitor_read,\n      monitor_event, panda_mon, NULL, true);\n\n  qemu_mutex_lock(&monitor_lock);\n  QLIST_INSERT_HEAD(&mon_list, panda_mon, entry);\n  qemu_mutex_unlock(&monitor_lock);\n\n  panda_chr = PANDA_CHARDEV(chr);\n\n  // Initialize cur_mon\n  cur_mon = panda_mon;\n}\n\nchar* panda_monitor_run(char * cmdline)\n{\n    if (panda_mon == NULL) {\n      panda_init_monitor();\n    }\n\n    assert(panda_mon != NULL);\n\n    Monitor *mon = panda_mon;\n\n    panda_chr->buf = NULL;\n\n    monitor_suspend(mon);\n    handle_hmp_command(mon, cmdline);\n    monitor_resume(mon);\n\n    // Wait for result. Must not be called from the thread that's processing\n    // the hmp command!\n    int i=0;\n    while (panda_chr->buf == NULL) {\n      if (i++ > 10000) {\n        error_printf_internal(\"PANDA monitor got no result after 10,000 iterations\\n\");\n        break;\n      }\n    }\n    return panda_chr->buf;\n}\n\n\n\nvoid monitor_init(Chardev *chr, int flags)\n{\n    static int is_first_init = 1;\n    Monitor *mon;\n\n    if (is_first_init) {\n        monitor_qapi_event_init();\n        sortcmdlist();\n        is_first_init = 0;\n    }\n\n    mon = g_malloc(sizeof(*mon));\n    monitor_data_init(mon);\n\n    qemu_chr_fe_init(&mon->chr, chr, &error_abort);\n    mon->flags = flags;\n    if (flags & MONITOR_USE_READLINE) {\n        mon->rs = readline_init(monitor_readline_printf,\n                                monitor_readline_flush,\n                                mon,\n                                monitor_find_completion);\n        monitor_read_command(mon, 0);\n    }\n\n    if (monitor_is_qmp(mon)) {\n        qemu_chr_fe_set_handlers(&mon->chr, monitor_can_read, monitor_qmp_read,\n                                 monitor_qmp_event, mon, NULL, true);\n        qemu_chr_fe_set_echo(&mon->chr, true);\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n    } else {\n        qemu_chr_fe_set_handlers(&mon->chr, monitor_can_read, monitor_read,\n                                 monitor_event, mon, NULL, true);\n    }\n\n    qemu_mutex_lock(&monitor_lock);\n    QLIST_INSERT_HEAD(&mon_list, mon, entry);\n    qemu_mutex_unlock(&monitor_lock);\n}\n\nvoid monitor_cleanup(void)\n{\n    Monitor *mon, *next;\n\n    qemu_mutex_lock(&monitor_lock);\n    QLIST_FOREACH_SAFE(mon, &mon_list, entry, next) {\n        QLIST_REMOVE(mon, entry);\n        monitor_data_destroy(mon);\n        g_free(mon);\n    }\n    qemu_mutex_unlock(&monitor_lock);\n}\n\nstatic void bdrv_password_cb(void *opaque, const char *password,\n                             void *readline_opaque)\n{\n    Monitor *mon = opaque;\n    BlockDriverState *bs = readline_opaque;\n    int ret = 0;\n    Error *local_err = NULL;\n\n    bdrv_add_key(bs, password, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        ret = -EPERM;\n    }\n    if (mon->password_completion_cb)\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n    monitor_read_command(mon, 1);\n}\n\nint monitor_read_bdrv_key_start(Monitor *mon, BlockDriverState *bs,\n                                BlockCompletionFunc *completion_cb,\n                                void *opaque)\n{\n    int err;\n\n    monitor_printf(mon, \"%s (%s) is encrypted.\\n\", bdrv_get_device_name(bs),\n                   bdrv_get_encrypted_filename(bs));\n\n    mon->password_completion_cb = completion_cb;\n    mon->password_opaque = opaque;\n\n    err = monitor_read_password(mon, bdrv_password_cb, bs);\n\n    if (err && completion_cb)\n        completion_cb(opaque, err);\n\n    return err;\n}\n\nint monitor_read_block_device_key(Monitor *mon, const char *device,\n                                  BlockCompletionFunc *completion_cb,\n                                  void *opaque)\n{\n    Error *err = NULL;\n    BlockBackend *blk;\n\n    blk = blk_by_name(device);\n    if (!blk) {\n        monitor_printf(mon, \"Device not found %s\\n\", device);\n        return -1;\n    }\n    if (!blk_bs(blk)) {\n        monitor_printf(mon, \"Device '%s' has no medium\\n\", device);\n        return -1;\n    }\n\n    bdrv_add_key(blk_bs(blk), NULL, &err);\n    if (err) {\n        error_free(err);\n        return monitor_read_bdrv_key_start(mon, blk_bs(blk), completion_cb, opaque);\n    }\n\n    if (completion_cb) {\n        completion_cb(opaque, 0);\n    }\n    return 0;\n}\n\nQemuOptsList qemu_mon_opts = {\n    .name = \"mon\",\n    .implied_opt_name = \"chardev\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_mon_opts.head),\n    .desc = {\n        {\n            .name = \"mode\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"chardev\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"default\",  /* deprecated */\n            .type = QEMU_OPT_BOOL,\n        },{\n            .name = \"pretty\",\n            .type = QEMU_OPT_BOOL,\n        },\n        { /* end of list */ }\n    },\n};\n\n#ifndef TARGET_I386\nvoid qmp_rtc_reset_reinjection(Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"rtc-reset-reinjection\");\n}\n#endif\n\n#ifndef TARGET_S390X\nvoid qmp_dump_skeys(const char *filename, Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"dump-skeys\");\n}\n#endif\n\n#ifndef TARGET_ARM\nGICCapabilityList *qmp_query_gic_capabilities(Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"query-gic-capabilities\");\n    return NULL;\n}\n#endif\n\nHotpluggableCPUList *qmp_query_hotpluggable_cpus(Error **errp)\n{\n    MachineState *ms = MACHINE(qdev_get_machine());\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    if (!mc->has_hotpluggable_cpus) {\n        error_setg(errp, QERR_FEATURE_DISABLED, \"query-hotpluggable-cpus\");\n        return NULL;\n    }\n\n    return machine_query_hotpluggable_cpus(ms);\n}\n"
        },
        {
          "name": "nbd",
          "type": "tree",
          "content": null
        },
        {
          "name": "net",
          "type": "tree",
          "content": null
        },
        {
          "name": "numa.c",
          "type": "blob",
          "size": 17.3095703125,
          "content": "/*\n * NUMA parameter parsing routines\n *\n * Copyright (c) 2014 Fujitsu Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/numa.h\"\n#include \"exec/cpu-common.h\"\n#include \"exec/ramlist.h\"\n#include \"qemu/bitmap.h\"\n#include \"qom/cpu.h\"\n#include \"qemu/error-report.h\"\n#include \"include/exec/cpu-common.h\" /* for RAM_ADDR_FMT */\n#include \"qapi-visit.h\"\n#include \"qapi/opts-visitor.h\"\n#include \"hw/boards.h\"\n#include \"sysemu/hostmem.h\"\n#include \"qmp-commands.h\"\n#include \"hw/mem/pc-dimm.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n\nQemuOptsList qemu_numa_opts = {\n    .name = \"numa\",\n    .implied_opt_name = \"type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_numa_opts.head),\n    .desc = { { 0 } } /* validated with OptsVisitor */\n};\n\nstatic int have_memdevs = -1;\nstatic int max_numa_nodeid; /* Highest specified NUMA node ID, plus one.\n                             * For all nodes, nodeid < max_numa_nodeid\n                             */\nint nb_numa_nodes;\nNodeInfo numa_info[MAX_NODES];\n\nvoid numa_set_mem_node_id(ram_addr_t addr, uint64_t size, uint32_t node)\n{\n    struct numa_addr_range *range;\n\n    /*\n     * Memory-less nodes can come here with 0 size in which case,\n     * there is nothing to do.\n     */\n    if (!size) {\n        return;\n    }\n\n    range = g_malloc0(sizeof(*range));\n    range->mem_start = addr;\n    range->mem_end = addr + size - 1;\n    QLIST_INSERT_HEAD(&numa_info[node].addr, range, entry);\n}\n\nvoid numa_unset_mem_node_id(ram_addr_t addr, uint64_t size, uint32_t node)\n{\n    struct numa_addr_range *range, *next;\n\n    QLIST_FOREACH_SAFE(range, &numa_info[node].addr, entry, next) {\n        if (addr == range->mem_start && (addr + size - 1) == range->mem_end) {\n            QLIST_REMOVE(range, entry);\n            g_free(range);\n            return;\n        }\n    }\n}\n\nstatic void numa_set_mem_ranges(void)\n{\n    int i;\n    ram_addr_t mem_start = 0;\n\n    /*\n     * Deduce start address of each node and use it to store\n     * the address range info in numa_info address range list\n     */\n    for (i = 0; i < nb_numa_nodes; i++) {\n        numa_set_mem_node_id(mem_start, numa_info[i].node_mem, i);\n        mem_start += numa_info[i].node_mem;\n    }\n}\n\n/*\n * Check if @addr falls under NUMA @node.\n */\nstatic bool numa_addr_belongs_to_node(ram_addr_t addr, uint32_t node)\n{\n    struct numa_addr_range *range;\n\n    QLIST_FOREACH(range, &numa_info[node].addr, entry) {\n        if (addr >= range->mem_start && addr <= range->mem_end) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*\n * Given an address, return the index of the NUMA node to which the\n * address belongs to.\n */\nuint32_t numa_get_node(ram_addr_t addr, Error **errp)\n{\n    uint32_t i;\n\n    /* For non NUMA configurations, check if the addr falls under node 0 */\n    if (!nb_numa_nodes) {\n        if (numa_addr_belongs_to_node(addr, 0)) {\n            return 0;\n        }\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n        if (numa_addr_belongs_to_node(addr, i)) {\n            return i;\n        }\n    }\n\n    error_setg(errp, \"Address 0x\" RAM_ADDR_FMT \" doesn't belong to any \"\n                \"NUMA node\", addr);\n    return -1;\n}\n\nstatic void numa_node_parse(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n{\n    uint16_t nodenr;\n    uint16List *cpus = NULL;\n\n    if (node->has_nodeid) {\n        nodenr = node->nodeid;\n    } else {\n        nodenr = nb_numa_nodes;\n    }\n\n    if (nodenr >= MAX_NODES) {\n        error_setg(errp, \"Max number of NUMA nodes reached: %\"\n                   PRIu16 \"\", nodenr);\n        return;\n    }\n\n    if (numa_info[nodenr].present) {\n        error_setg(errp, \"Duplicate NUMA nodeid: %\" PRIu16, nodenr);\n        return;\n    }\n\n    for (cpus = node->cpus; cpus; cpus = cpus->next) {\n        if (cpus->value >= max_cpus) {\n            error_setg(errp,\n                       \"CPU index (%\" PRIu16 \")\"\n                       \" should be smaller than maxcpus (%d)\",\n                       cpus->value, max_cpus);\n            return;\n        }\n        bitmap_set(numa_info[nodenr].node_cpu, cpus->value, 1);\n    }\n\n    if (node->has_mem && node->has_memdev) {\n        error_setg(errp, \"qemu: cannot specify both mem= and memdev=\");\n        return;\n    }\n\n    if (have_memdevs == -1) {\n        have_memdevs = node->has_memdev;\n    }\n    if (node->has_memdev != have_memdevs) {\n        error_setg(errp, \"qemu: memdev option must be specified for either \"\n                   \"all or no nodes\");\n        return;\n    }\n\n    if (node->has_mem) {\n        uint64_t mem_size = node->mem;\n        const char *mem_str = qemu_opt_get(opts, \"mem\");\n        /* Fix up legacy suffix-less format */\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n            mem_size <<= 20;\n        }\n        numa_info[nodenr].node_mem = mem_size;\n    }\n    if (node->has_memdev) {\n        Object *o;\n        o = object_resolve_path_type(node->memdev, TYPE_MEMORY_BACKEND, NULL);\n        if (!o) {\n            error_setg(errp, \"memdev=%s is ambiguous\", node->memdev);\n            return;\n        }\n\n        object_ref(o);\n        numa_info[nodenr].node_mem = object_property_get_int(o, \"size\", NULL);\n        numa_info[nodenr].node_memdev = MEMORY_BACKEND(o);\n    }\n    numa_info[nodenr].present = true;\n    max_numa_nodeid = MAX(max_numa_nodeid, nodenr + 1);\n}\n\nstatic int parse_numa(void *opaque, QemuOpts *opts, Error **errp)\n{\n    NumaOptions *object = NULL;\n    Error *err = NULL;\n\n    {\n        Visitor *v = opts_visitor_new(opts);\n        visit_type_NumaOptions(v, NULL, &object, &err);\n        visit_free(v);\n    }\n\n    if (err) {\n        goto end;\n    }\n\n    switch (object->type) {\n    case NUMA_OPTIONS_TYPE_NODE:\n        numa_node_parse(&object->u.node, opts, &err);\n        if (err) {\n            goto end;\n        }\n        nb_numa_nodes++;\n        break;\n    default:\n        abort();\n    }\n\nend:\n    qapi_free_NumaOptions(object);\n    if (err) {\n        error_report_err(err);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n{\n    int cpu;\n    bool first = true;\n    GString *s = g_string_new(NULL);\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n        cpu < max_cpus;\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n        first = false;\n    }\n    return g_string_free(s, FALSE);\n}\n\nstatic void validate_numa_cpus(void)\n{\n    int i;\n    unsigned long *seen_cpus = bitmap_new(max_cpus);\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n        if (bitmap_intersects(seen_cpus, numa_info[i].node_cpu, max_cpus)) {\n            bitmap_and(seen_cpus, seen_cpus,\n                       numa_info[i].node_cpu, max_cpus);\n            error_report(\"CPU(s) present in multiple NUMA nodes: %s\",\n                         enumerate_cpus(seen_cpus, max_cpus));\n            g_free(seen_cpus);\n            exit(EXIT_FAILURE);\n        }\n        bitmap_or(seen_cpus, seen_cpus,\n                  numa_info[i].node_cpu, max_cpus);\n    }\n\n    if (!bitmap_full(seen_cpus, max_cpus)) {\n        char *msg;\n        bitmap_complement(seen_cpus, seen_cpus, max_cpus);\n        msg = enumerate_cpus(seen_cpus, max_cpus);\n        error_report(\"warning: CPU(s) not present in any NUMA nodes: %s\", msg);\n        error_report(\"warning: All CPU(s) up to maxcpus should be described \"\n                     \"in NUMA config\");\n        g_free(msg);\n    }\n    g_free(seen_cpus);\n}\n\nvoid parse_numa_opts(MachineClass *mc)\n{\n    int i;\n\n    for (i = 0; i < MAX_NODES; i++) {\n        numa_info[i].node_cpu = bitmap_new(max_cpus);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"numa\"), parse_numa, NULL, NULL)) {\n        exit(1);\n    }\n\n    assert(max_numa_nodeid <= MAX_NODES);\n\n    /* No support for sparse NUMA node IDs yet: */\n    for (i = max_numa_nodeid - 1; i >= 0; i--) {\n        /* Report large node IDs first, to make mistakes easier to spot */\n        if (!numa_info[i].present) {\n            error_report(\"numa: Node ID missing: %d\", i);\n            exit(1);\n        }\n    }\n\n    /* This must be always true if all nodes are present: */\n    assert(nb_numa_nodes == max_numa_nodeid);\n\n    if (nb_numa_nodes > 0) {\n        uint64_t numa_total;\n\n        if (nb_numa_nodes > MAX_NODES) {\n            nb_numa_nodes = MAX_NODES;\n        }\n\n        /* If no memory size is given for any node, assume the default case\n         * and distribute the available memory equally across all nodes\n         */\n        for (i = 0; i < nb_numa_nodes; i++) {\n            if (numa_info[i].node_mem != 0) {\n                break;\n            }\n        }\n        if (i == nb_numa_nodes) {\n            uint64_t usedmem = 0;\n\n            /* Align each node according to the alignment\n             * requirements of the machine class\n             */\n            for (i = 0; i < nb_numa_nodes - 1; i++) {\n                numa_info[i].node_mem = (ram_size / nb_numa_nodes) &\n                                        ~((1 << mc->numa_mem_align_shift) - 1);\n                usedmem += numa_info[i].node_mem;\n            }\n            numa_info[i].node_mem = ram_size - usedmem;\n        }\n\n        numa_total = 0;\n        for (i = 0; i < nb_numa_nodes; i++) {\n            numa_total += numa_info[i].node_mem;\n        }\n        if (numa_total != ram_size) {\n            error_report(\"total memory for NUMA nodes (0x%\" PRIx64 \")\"\n                         \" should equal RAM size (0x\" RAM_ADDR_FMT \")\",\n                         numa_total, ram_size);\n            exit(1);\n        }\n\n        for (i = 0; i < nb_numa_nodes; i++) {\n            QLIST_INIT(&numa_info[i].addr);\n        }\n\n        numa_set_mem_ranges();\n\n        for (i = 0; i < nb_numa_nodes; i++) {\n            if (!bitmap_empty(numa_info[i].node_cpu, max_cpus)) {\n                break;\n            }\n        }\n        /* Historically VCPUs were assigned in round-robin order to NUMA\n         * nodes. However it causes issues with guest not handling it nice\n         * in case where cores/threads from a multicore CPU appear on\n         * different nodes. So allow boards to override default distribution\n         * rule grouping VCPUs by socket so that VCPUs from the same socket\n         * would be on the same node.\n         */\n        if (i == nb_numa_nodes) {\n            for (i = 0; i < max_cpus; i++) {\n                unsigned node_id = i % nb_numa_nodes;\n                if (mc->cpu_index_to_socket_id) {\n                    node_id = mc->cpu_index_to_socket_id(i) % nb_numa_nodes;\n                }\n\n                set_bit(i, numa_info[node_id].node_cpu);\n            }\n        }\n\n        validate_numa_cpus();\n    } else {\n        numa_set_mem_node_id(0, ram_size, 0);\n    }\n}\n\nvoid numa_post_machine_init(void)\n{\n    CPUState *cpu;\n    int i;\n\n    CPU_FOREACH(cpu) {\n        for (i = 0; i < nb_numa_nodes; i++) {\n            assert(cpu->cpu_index < max_cpus);\n            if (test_bit(cpu->cpu_index, numa_info[i].node_cpu)) {\n                cpu->numa_node = i;\n            }\n        }\n    }\n}\n\nstatic void allocate_system_memory_nonnuma(MemoryRegion *mr, Object *owner,\n                                           const char *name,\n                                           uint64_t ram_size)\n{\n    if (mem_path) {\n#ifdef __linux__\n        Error *err = NULL;\n        memory_region_init_ram_from_file(mr, owner, name, ram_size, false,\n                                         mem_path, &err);\n        if (err) {\n            error_report_err(err);\n            if (mem_prealloc) {\n                exit(1);\n            }\n\n            /* Legacy behavior: if allocation failed, fall back to\n             * regular RAM allocation.\n             */\n            memory_region_init_ram(mr, owner, name, ram_size, &error_fatal);\n        }\n#else\n        fprintf(stderr, \"-mem-path not supported on this host\\n\");\n        exit(1);\n#endif\n    } else {\n        memory_region_init_ram(mr, owner, name, ram_size, &error_fatal);\n    }\n    vmstate_register_ram_global(mr);\n}\n\nvoid memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,\n                                          const char *name,\n                                          uint64_t ram_size)\n{\n    uint64_t addr = 0;\n    int i;\n\n    if (nb_numa_nodes == 0 || !have_memdevs) {\n        allocate_system_memory_nonnuma(mr, owner, name, ram_size);\n        return;\n    }\n\n    memory_region_init(mr, owner, name, ram_size);\n    for (i = 0; i < MAX_NODES; i++) {\n        uint64_t size = numa_info[i].node_mem;\n        HostMemoryBackend *backend = numa_info[i].node_memdev;\n        if (!backend) {\n            continue;\n        }\n        MemoryRegion *seg = host_memory_backend_get_memory(backend,\n                                                           &error_fatal);\n\n        if (memory_region_is_mapped(seg)) {\n            char *path = object_get_canonical_path_component(OBJECT(backend));\n            error_report(\"memory backend %s is used multiple times. Each \"\n                         \"-numa option must use a different memdev value.\",\n                         path);\n            exit(1);\n        }\n\n        host_memory_backend_set_mapped(backend, true);\n        memory_region_add_subregion(mr, addr, seg);\n        vmstate_register_ram_global(seg);\n        addr += size;\n    }\n}\n\nstatic void numa_stat_memory_devices(uint64_t node_mem[])\n{\n    MemoryDeviceInfoList *info_list = NULL;\n    MemoryDeviceInfoList **prev = &info_list;\n    MemoryDeviceInfoList *info;\n\n    qmp_pc_dimm_device_list(qdev_get_machine(), &prev);\n    for (info = info_list; info; info = info->next) {\n        MemoryDeviceInfo *value = info->value;\n\n        if (value) {\n            switch (value->type) {\n            case MEMORY_DEVICE_INFO_KIND_DIMM:\n                node_mem[value->u.dimm.data->node] += value->u.dimm.data->size;\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    qapi_free_MemoryDeviceInfoList(info_list);\n}\n\nvoid query_numa_node_mem(uint64_t node_mem[])\n{\n    int i;\n\n    if (nb_numa_nodes <= 0) {\n        return;\n    }\n\n    numa_stat_memory_devices(node_mem);\n    for (i = 0; i < nb_numa_nodes; i++) {\n        node_mem[i] += numa_info[i].node_mem;\n    }\n}\n\nstatic int query_memdev(Object *obj, void *opaque)\n{\n    MemdevList **list = opaque;\n    MemdevList *m = NULL;\n\n    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {\n        m = g_malloc0(sizeof(*m));\n\n        m->value = g_malloc0(sizeof(*m->value));\n\n        m->value->id = object_property_get_str(obj, \"id\", NULL);\n        m->value->has_id = !!m->value->id;\n\n        m->value->size = object_property_get_int(obj, \"size\",\n                                                 &error_abort);\n        m->value->merge = object_property_get_bool(obj, \"merge\",\n                                                   &error_abort);\n        m->value->dump = object_property_get_bool(obj, \"dump\",\n                                                  &error_abort);\n        m->value->prealloc = object_property_get_bool(obj,\n                                                      \"prealloc\",\n                                                      &error_abort);\n        m->value->policy = object_property_get_enum(obj,\n                                                    \"policy\",\n                                                    \"HostMemPolicy\",\n                                                    &error_abort);\n        object_property_get_uint16List(obj, \"host-nodes\",\n                                       &m->value->host_nodes,\n                                       &error_abort);\n\n        m->next = *list;\n        *list = m;\n    }\n\n    return 0;\n}\n\nMemdevList *qmp_query_memdev(Error **errp)\n{\n    Object *obj = object_get_objects_root();\n    MemdevList *list = NULL;\n\n    object_child_foreach(obj, query_memdev, &list);\n    return list;\n}\n\nint numa_get_node_for_cpu(int idx)\n{\n    int i;\n\n    assert(idx < max_cpus);\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n        if (test_bit(idx, numa_info[i].node_cpu)) {\n            break;\n        }\n    }\n    return i;\n}\n\nvoid ram_block_notifier_add(RAMBlockNotifier *n)\n{\n    QLIST_INSERT_HEAD(&ram_list.ramblock_notifiers, n, next);\n}\n\nvoid ram_block_notifier_remove(RAMBlockNotifier *n)\n{\n    QLIST_REMOVE(n, next);\n}\n\nvoid ram_block_notify_add(void *host, size_t size)\n{\n    RAMBlockNotifier *notifier;\n\n    QLIST_FOREACH(notifier, &ram_list.ramblock_notifiers, next) {\n        notifier->ram_block_added(notifier, host, size);\n    }\n}\n\nvoid ram_block_notify_remove(void *host, size_t size)\n{\n    RAMBlockNotifier *notifier;\n\n    QLIST_FOREACH(notifier, &ram_list.ramblock_notifiers, next) {\n        notifier->ram_block_removed(notifier, host, size);\n    }\n}\n"
        },
        {
          "name": "os-posix.c",
          "type": "blob",
          "size": 8.5595703125,
          "content": "/*\n * os-posix.c\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2010 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include <sys/wait.h>\n/*needed for MAP_POPULATE before including qemu-options.h */\n#include <pwd.h>\n#include <grp.h>\n#include <libgen.h>\n\n/* Needed early for CONFIG_BSD etc. */\n#include \"sysemu/sysemu.h\"\n#include \"net/slirp.h\"\n#include \"qemu-options.h\"\n#include \"qemu/rcu.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/log.h\"\n#include \"qemu/cutils.h\"\n\n#ifdef CONFIG_LINUX\n#include <sys/prctl.h>\n#endif\n\nstatic struct passwd *user_pwd;\nstatic const char *chroot_dir;\nstatic int daemonize;\nstatic int daemon_pipe;\n\nextern void (*panda_external_signal_handler)(int, siginfo_t*,void*);\n\nvoid os_setup_early_signal_handling(void)\n{\n    struct sigaction act;\n    \n    if (panda_external_signal_handler != NULL){\n        // don't set up signal handling if we already initialized it\n        return;\n    }\n\n    sigfillset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &act, NULL);\n}\n\nstatic void termsig_handler(int signal, siginfo_t *info, void *c)\n{\n    qemu_system_killed(info->si_signo, info->si_pid);\n}\n\nvoid os_setup_signal_handling(void)\n{\n    struct sigaction act;\n\n    void (*handler)(int,siginfo_t*, void*) = termsig_handler;\n\n    if (panda_external_signal_handler != NULL){\n        /* Here we go ahead and set the handler to the previously set handler\n         * in case it needs to be reinitialized for a different thread.\n         */\n        handler = panda_external_signal_handler;\n    }\n    memset(&act, 0, sizeof(act));\n    act.sa_sigaction = handler;\n    act.sa_flags = SA_SIGINFO;\n    sigaction(SIGINT,  &act, NULL);\n    sigaction(SIGHUP,  &act, NULL);\n    sigaction(SIGTERM, &act, NULL);\n}\n\n/* Find a likely location for support files using the location of the binary.\n   For installed binaries this will be \"$bindir/../share/qemu\".  When\n   running from the build tree this will be \"$bindir/../pc-bios\".  */\n#define SHARE_SUFFIX \"/share/panda\"\n#define BUILD_SUFFIX \"/pc-bios\"\nchar *os_find_datadir(void)\n{\n    char *dir, *exec_dir;\n    char *res;\n    size_t max_len;\n\n    exec_dir = qemu_get_exec_dir();\n    if (exec_dir == NULL) {\n        return NULL;\n    }\n    dir = g_path_get_dirname(exec_dir);\n\n    max_len = strlen(dir) +\n        MAX(strlen(SHARE_SUFFIX), strlen(BUILD_SUFFIX)) + 1;\n    res = g_malloc0(max_len);\n    snprintf(res, max_len, \"%s%s\", dir, SHARE_SUFFIX);\n    if (access(res, R_OK)) {\n        snprintf(res, max_len, \"%s%s\", dir, BUILD_SUFFIX);\n        if (access(res, R_OK)) {\n            g_free(res);\n            res = NULL;\n        }\n    }\n\n    g_free(dir);\n    g_free(exec_dir);\n    return res;\n}\n#undef SHARE_SUFFIX\n#undef BUILD_SUFFIX\n\nvoid os_set_proc_name(const char *s)\n{\n#if defined(PR_SET_NAME)\n    char name[16];\n    if (!s)\n        return;\n    pstrcpy(name, sizeof(name), s);\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n       This simple way is enough for `top'. */\n    if (prctl(PR_SET_NAME, name)) {\n        perror(\"unable to change process name\");\n        exit(1);\n    }\n#else\n    fprintf(stderr, \"Change of process name not supported by your OS\\n\");\n    exit(1);\n#endif\n}\n\n/*\n * Parse OS specific command line options.\n * return 0 if option handled, -1 otherwise\n */\nvoid os_parse_cmd_args(int index, const char *optarg)\n{\n    switch (index) {\n#ifdef CONFIG_SLIRP\n    case QEMU_OPTION_smb:\n        error_report(\"The -smb option is deprecated. \"\n                     \"Please use '-netdev user,smb=...' instead.\");\n        if (net_slirp_smb(optarg) < 0)\n            exit(1);\n        break;\n#endif\n    case QEMU_OPTION_runas:\n        user_pwd = getpwnam(optarg);\n        if (!user_pwd) {\n            fprintf(stderr, \"User \\\"%s\\\" doesn't exist\\n\", optarg);\n            exit(1);\n        }\n        break;\n    case QEMU_OPTION_chroot:\n        chroot_dir = optarg;\n        break;\n    case QEMU_OPTION_daemonize:\n        daemonize = 1;\n        break;\n#if defined(CONFIG_LINUX)\n    case QEMU_OPTION_enablefips:\n        fips_set_state(true);\n        break;\n#endif\n    }\n}\n\nstatic void change_process_uid(void)\n{\n    if (user_pwd) {\n        if (setgid(user_pwd->pw_gid) < 0) {\n            fprintf(stderr, \"Failed to setgid(%d)\\n\", user_pwd->pw_gid);\n            exit(1);\n        }\n        if (initgroups(user_pwd->pw_name, user_pwd->pw_gid) < 0) {\n            fprintf(stderr, \"Failed to initgroups(\\\"%s\\\", %d)\\n\",\n                    user_pwd->pw_name, user_pwd->pw_gid);\n            exit(1);\n        }\n        if (setuid(user_pwd->pw_uid) < 0) {\n            fprintf(stderr, \"Failed to setuid(%d)\\n\", user_pwd->pw_uid);\n            exit(1);\n        }\n        if (setuid(0) != -1) {\n            fprintf(stderr, \"Dropping privileges failed\\n\");\n            exit(1);\n        }\n    }\n}\n\nstatic void change_root(void)\n{\n    if (chroot_dir) {\n        if (chroot(chroot_dir) < 0) {\n            fprintf(stderr, \"chroot failed\\n\");\n            exit(1);\n        }\n        if (chdir(\"/\")) {\n            perror(\"not able to chdir to /\");\n            exit(1);\n        }\n    }\n\n}\n\nvoid os_daemonize(void)\n{\n    if (daemonize) {\n        pid_t pid;\n        int fds[2];\n\n        if (pipe(fds) == -1) {\n            exit(1);\n        }\n\n        pid = fork();\n        if (pid > 0) {\n            uint8_t status;\n            ssize_t len;\n\n            close(fds[1]);\n\n            do {\n                len = read(fds[0], &status, 1);\n            } while (len < 0 && errno == EINTR);\n\n            /* only exit successfully if our child actually wrote\n             * a one-byte zero to our pipe, upon successful init */\n            exit(len == 1 && status == 0 ? 0 : 1);\n\n        } else if (pid < 0) {\n            exit(1);\n        }\n\n        close(fds[0]);\n        daemon_pipe = fds[1];\n        qemu_set_cloexec(daemon_pipe);\n\n        setsid();\n\n        pid = fork();\n        if (pid > 0) {\n            exit(0);\n        } else if (pid < 0) {\n            exit(1);\n        }\n        umask(027);\n\n        signal(SIGTSTP, SIG_IGN);\n        signal(SIGTTOU, SIG_IGN);\n        signal(SIGTTIN, SIG_IGN);\n        rcu_after_fork();\n    }\n}\n\nvoid os_setup_post(void)\n{\n    int fd = 0;\n\n    if (daemonize) {\n        if (chdir(\"/\")) {\n            perror(\"not able to chdir to /\");\n            exit(1);\n        }\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n        if (fd == -1) {\n            exit(1);\n        }\n    }\n\n    change_root();\n    change_process_uid();\n\n    if (daemonize) {\n        uint8_t status = 0;\n        ssize_t len;\n\n        dup2(fd, 0);\n        dup2(fd, 1);\n        /* In case -D is given do not redirect stderr to /dev/null */\n        if (!qemu_logfile) {\n            dup2(fd, 2);\n        }\n\n        close(fd);\n\n        do {        \n            len = write(daemon_pipe, &status, 1);\n        } while (len < 0 && errno == EINTR);\n        if (len != 1) {\n            exit(1);\n        }\n    }\n}\n\nvoid os_set_line_buffering(void)\n{\n    setvbuf(stdout, NULL, _IOLBF, 0);\n}\n\nint qemu_create_pidfile(const char *filename)\n{\n    char buffer[128];\n    int len;\n    int fd;\n\n    fd = qemu_open(filename, O_RDWR | O_CREAT, 0600);\n    if (fd == -1) {\n        return -1;\n    }\n    if (lockf(fd, F_TLOCK, 0) == -1) {\n        close(fd);\n        return -1;\n    }\n    len = snprintf(buffer, sizeof(buffer), FMT_pid \"\\n\", getpid());\n    if (write(fd, buffer, len) != len) {\n        close(fd);\n        return -1;\n    }\n\n    /* keep pidfile open & locked forever */\n    return 0;\n}\n\nbool is_daemonized(void)\n{\n    return daemonize;\n}\n\nint os_mlock(void)\n{\n    int ret = 0;\n\n    ret = mlockall(MCL_CURRENT | MCL_FUTURE);\n    if (ret < 0) {\n        perror(\"mlockall\");\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "os-win32.c",
          "type": "blob",
          "size": 3.62890625,
          "content": "/*\n * os-win32.c\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2010 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include <windows.h>\n#include <mmsystem.h>\n#include \"sysemu/sysemu.h\"\n#include \"qemu-options.h\"\n\n/***********************************************************/\n/* Functions missing in mingw */\n\nint setenv(const char *name, const char *value, int overwrite)\n{\n    int result = 0;\n    if (overwrite || !getenv(name)) {\n        size_t length = strlen(name) + strlen(value) + 2;\n        char *string = g_malloc(length);\n        snprintf(string, length, \"%s=%s\", name, value);\n        result = putenv(string);\n\n        /* Windows takes a copy and does not continue to use our string.\n         * Therefore it can be safely freed on this platform.  POSIX code\n         * typically has to leak the string because according to the spec it\n         * becomes part of the environment.\n         */\n        g_free(string);\n    }\n    return result;\n}\n\nstatic BOOL WINAPI qemu_ctrl_handler(DWORD type)\n{\n    qemu_system_shutdown_request();\n    /* Windows 7 kills application when the function returns.\n       Sleep here to give QEMU a try for closing.\n       Sleep period is 10000ms because Windows kills the program\n       after 10 seconds anyway. */\n    Sleep(10000);\n\n    return TRUE;\n}\n\nstatic TIMECAPS mm_tc;\n\nstatic void os_undo_timer_resolution(void)\n{\n    timeEndPeriod(mm_tc.wPeriodMin);\n}\n\nvoid os_setup_early_signal_handling(void)\n{\n    SetConsoleCtrlHandler(qemu_ctrl_handler, TRUE);\n    timeGetDevCaps(&mm_tc, sizeof(mm_tc));\n    timeBeginPeriod(mm_tc.wPeriodMin);\n    atexit(os_undo_timer_resolution);\n}\n\n/* Look for support files in the same directory as the executable.  */\nchar *os_find_datadir(void)\n{\n    return qemu_get_exec_dir();\n}\n\nvoid os_set_line_buffering(void)\n{\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n}\n\n/*\n * Parse OS specific command line options.\n * return 0 if option handled, -1 otherwise\n */\nvoid os_parse_cmd_args(int index, const char *optarg)\n{\n    return;\n}\n\nint qemu_create_pidfile(const char *filename)\n{\n    char buffer[128];\n    int len;\n    HANDLE file;\n    OVERLAPPED overlap;\n    BOOL ret;\n    memset(&overlap, 0, sizeof(overlap));\n\n    file = CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n                      OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (file == INVALID_HANDLE_VALUE) {\n        return -1;\n    }\n    len = snprintf(buffer, sizeof(buffer), \"%d\\n\", getpid());\n    ret = WriteFile(file, (LPCVOID)buffer, (DWORD)len,\n                    NULL, &overlap);\n    CloseHandle(file);\n    if (ret == 0) {\n        return -1;\n    }\n    return 0;\n}\n"
        },
        {
          "name": "page_cache.c",
          "type": "blob",
          "size": 5.7138671875,
          "content": "/*\n * Page cache for QEMU\n * The cache is base on a hash of the page address\n *\n * Copyright 2012 Red Hat, Inc. and/or its affiliates\n *\n * Authors:\n *  Orit Wasserman  <owasserm@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n\n#include \"qemu-common.h\"\n#include \"qemu/host-utils.h\"\n#include \"migration/page_cache.h\"\n\n#ifdef DEBUG_CACHE\n#define DPRINTF(fmt, ...) \\\n    do { fprintf(stdout, \"cache: \" fmt, ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) \\\n    do { } while (0)\n#endif\n\n/* the page in cache will not be replaced in two cycles */\n#define CACHED_PAGE_LIFETIME 2\n\ntypedef struct CacheItem CacheItem;\n\nstruct CacheItem {\n    uint64_t it_addr;\n    uint64_t it_age;\n    uint8_t *it_data;\n};\n\nstruct PageCache {\n    CacheItem *page_cache;\n    unsigned int page_size;\n    int64_t max_num_items;\n    uint64_t max_item_age;\n    int64_t num_items;\n};\n\nPageCache *cache_init(int64_t num_pages, unsigned int page_size)\n{\n    int64_t i;\n\n    PageCache *cache;\n\n    if (num_pages <= 0) {\n        DPRINTF(\"invalid number of pages\\n\");\n        return NULL;\n    }\n\n    /* We prefer not to abort if there is no memory */\n    cache = g_try_malloc(sizeof(*cache));\n    if (!cache) {\n        DPRINTF(\"Failed to allocate cache\\n\");\n        return NULL;\n    }\n    /* round down to the nearest power of 2 */\n    if (!is_power_of_2(num_pages)) {\n        num_pages = pow2floor(num_pages);\n        DPRINTF(\"rounding down to %\" PRId64 \"\\n\", num_pages);\n    }\n    cache->page_size = page_size;\n    cache->num_items = 0;\n    cache->max_item_age = 0;\n    cache->max_num_items = num_pages;\n\n    DPRINTF(\"Setting cache buckets to %\" PRId64 \"\\n\", cache->max_num_items);\n\n    /* We prefer not to abort if there is no memory */\n    cache->page_cache = g_try_malloc((cache->max_num_items) *\n                                     sizeof(*cache->page_cache));\n    if (!cache->page_cache) {\n        DPRINTF(\"Failed to allocate cache->page_cache\\n\");\n        g_free(cache);\n        return NULL;\n    }\n\n    for (i = 0; i < cache->max_num_items; i++) {\n        cache->page_cache[i].it_data = NULL;\n        cache->page_cache[i].it_age = 0;\n        cache->page_cache[i].it_addr = -1;\n    }\n\n    return cache;\n}\n\nvoid cache_fini(PageCache *cache)\n{\n    int64_t i;\n\n    g_assert(cache);\n    g_assert(cache->page_cache);\n\n    for (i = 0; i < cache->max_num_items; i++) {\n        g_free(cache->page_cache[i].it_data);\n    }\n\n    g_free(cache->page_cache);\n    cache->page_cache = NULL;\n    g_free(cache);\n}\n\nstatic size_t cache_get_cache_pos(const PageCache *cache,\n                                  uint64_t address)\n{\n    g_assert(cache->max_num_items);\n    return (address / cache->page_size) & (cache->max_num_items - 1);\n}\n\nstatic CacheItem *cache_get_by_addr(const PageCache *cache, uint64_t addr)\n{\n    size_t pos;\n\n    g_assert(cache);\n    g_assert(cache->page_cache);\n\n    pos = cache_get_cache_pos(cache, addr);\n\n    return &cache->page_cache[pos];\n}\n\nuint8_t *get_cached_data(const PageCache *cache, uint64_t addr)\n{\n    return cache_get_by_addr(cache, addr)->it_data;\n}\n\nbool cache_is_cached(const PageCache *cache, uint64_t addr,\n                     uint64_t current_age)\n{\n    CacheItem *it;\n\n    it = cache_get_by_addr(cache, addr);\n\n    if (it->it_addr == addr) {\n        /* update the it_age when the cache hit */\n        it->it_age = current_age;\n        return true;\n    }\n    return false;\n}\n\nint cache_insert(PageCache *cache, uint64_t addr, const uint8_t *pdata,\n                 uint64_t current_age)\n{\n\n    CacheItem *it;\n\n    /* actual update of entry */\n    it = cache_get_by_addr(cache, addr);\n\n    if (it->it_data && it->it_addr != addr &&\n        it->it_age + CACHED_PAGE_LIFETIME > current_age) {\n        /* the cache page is fresh, don't replace it */\n        return -1;\n    }\n    /* allocate page */\n    if (!it->it_data) {\n        it->it_data = g_try_malloc(cache->page_size);\n        if (!it->it_data) {\n            DPRINTF(\"Error allocating page\\n\");\n            return -1;\n        }\n        cache->num_items++;\n    }\n\n    memcpy(it->it_data, pdata, cache->page_size);\n\n    it->it_age = current_age;\n    it->it_addr = addr;\n\n    return 0;\n}\n\nint64_t cache_resize(PageCache *cache, int64_t new_num_pages)\n{\n    PageCache *new_cache;\n    int64_t i;\n\n    CacheItem *old_it, *new_it;\n\n    g_assert(cache);\n\n    /* cache was not inited */\n    if (cache->page_cache == NULL) {\n        return -1;\n    }\n\n    /* same size */\n    if (pow2floor(new_num_pages) == cache->max_num_items) {\n        return cache->max_num_items;\n    }\n\n    new_cache = cache_init(new_num_pages, cache->page_size);\n    if (!(new_cache)) {\n        DPRINTF(\"Error creating new cache\\n\");\n        return -1;\n    }\n\n    /* move all data from old cache */\n    for (i = 0; i < cache->max_num_items; i++) {\n        old_it = &cache->page_cache[i];\n        if (old_it->it_addr != -1) {\n            /* check for collision, if there is, keep MRU page */\n            new_it = cache_get_by_addr(new_cache, old_it->it_addr);\n            if (new_it->it_data && new_it->it_age >= old_it->it_age) {\n                /* keep the MRU page */\n                g_free(old_it->it_data);\n            } else {\n                if (!new_it->it_data) {\n                    new_cache->num_items++;\n                }\n                g_free(new_it->it_data);\n                new_it->it_data = old_it->it_data;\n                new_it->it_age = old_it->it_age;\n                new_it->it_addr = old_it->it_addr;\n            }\n        }\n    }\n\n    g_free(cache->page_cache);\n    cache->page_cache = new_cache->page_cache;\n    cache->max_num_items = new_cache->max_num_items;\n    cache->num_items = new_cache->num_items;\n\n    g_free(new_cache);\n\n    return cache->max_num_items;\n}\n"
        },
        {
          "name": "panda-bridge-helper.c",
          "type": "blob",
          "size": 10.9990234375,
          "content": "/*\n * QEMU Bridge Helper\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n * Anthony Liguori   <aliguori@us.ibm.com>\n * Richa Marwaha     <rmarwah@linux.vnet.ibm.com>\n * Corey Bryant      <coreyb@linux.vnet.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n\n\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/prctl.h>\n\n#include <net/if.h>\n\n#include <linux/sockios.h>\n\n#ifndef SIOCBRADDIF\n#include <linux/if_bridge.h>\n#endif\n\n#include \"qemu/queue.h\"\n\n#include \"net/tap-linux.h\"\n\n#ifdef CONFIG_LIBCAP\n#include <cap-ng.h>\n#endif\n\n#define DEFAULT_ACL_FILE CONFIG_QEMU_CONFDIR \"/bridge.conf\"\n\nenum {\n    ACL_ALLOW = 0,\n    ACL_ALLOW_ALL,\n    ACL_DENY,\n    ACL_DENY_ALL,\n};\n\ntypedef struct ACLRule {\n    int type;\n    char iface[IFNAMSIZ];\n    QSIMPLEQ_ENTRY(ACLRule) entry;\n} ACLRule;\n\ntypedef QSIMPLEQ_HEAD(ACLList, ACLRule) ACLList;\n\nstatic void usage(void)\n{\n    fprintf(stderr,\n            \"Usage: panda-bridge-helper [--use-vnet] --br=bridge --fd=unixfd\\n\");\n}\n\nstatic int parse_acl_file(const char *filename, ACLList *acl_list)\n{\n    FILE *f;\n    char line[4096];\n    ACLRule *acl_rule;\n\n    f = fopen(filename, \"r\");\n    if (f == NULL) {\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), f) != NULL) {\n        char *ptr = line;\n        char *cmd, *arg, *argend;\n\n        while (isspace(*ptr)) {\n            ptr++;\n        }\n\n        /* skip comments and empty lines */\n        if (*ptr == '#' || *ptr == 0) {\n            continue;\n        }\n\n        cmd = ptr;\n        arg = strchr(cmd, ' ');\n        if (arg == NULL) {\n            arg = strchr(cmd, '\\t');\n        }\n\n        if (arg == NULL) {\n            fprintf(stderr, \"Invalid config line:\\n  %s\\n\", line);\n            fclose(f);\n            errno = EINVAL;\n            return -1;\n        }\n\n        *arg = 0;\n        arg++;\n        while (isspace(*arg)) {\n            arg++;\n        }\n\n        argend = arg + strlen(arg);\n        while (arg != argend && isspace(*(argend - 1))) {\n            argend--;\n        }\n        *argend = 0;\n\n        if (strcmp(cmd, \"deny\") == 0) {\n            acl_rule = g_malloc(sizeof(*acl_rule));\n            if (strcmp(arg, \"all\") == 0) {\n                acl_rule->type = ACL_DENY_ALL;\n            } else {\n                acl_rule->type = ACL_DENY;\n                snprintf(acl_rule->iface, IFNAMSIZ, \"%s\", arg);\n            }\n            QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry);\n        } else if (strcmp(cmd, \"allow\") == 0) {\n            acl_rule = g_malloc(sizeof(*acl_rule));\n            if (strcmp(arg, \"all\") == 0) {\n                acl_rule->type = ACL_ALLOW_ALL;\n            } else {\n                acl_rule->type = ACL_ALLOW;\n                snprintf(acl_rule->iface, IFNAMSIZ, \"%s\", arg);\n            }\n            QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry);\n        } else if (strcmp(cmd, \"include\") == 0) {\n            /* ignore errors */\n            parse_acl_file(arg, acl_list);\n        } else {\n            fprintf(stderr, \"Unknown command `%s'\\n\", cmd);\n            fclose(f);\n            errno = EINVAL;\n            return -1;\n        }\n    }\n\n    fclose(f);\n\n    return 0;\n}\n\nstatic bool has_vnet_hdr(int fd)\n{\n    unsigned int features = 0;\n\n    if (ioctl(fd, TUNGETFEATURES, &features) == -1) {\n        return false;\n    }\n\n    if (!(features & IFF_VNET_HDR)) {\n        return false;\n    }\n\n    return true;\n}\n\nstatic void prep_ifreq(struct ifreq *ifr, const char *ifname)\n{\n    memset(ifr, 0, sizeof(*ifr));\n    snprintf(ifr->ifr_name, IFNAMSIZ, \"%s\", ifname);\n}\n\nstatic int send_fd(int c, int fd)\n{\n    char msgbuf[CMSG_SPACE(sizeof(fd))];\n    struct msghdr msg = {\n        .msg_control = msgbuf,\n        .msg_controllen = sizeof(msgbuf),\n    };\n    struct cmsghdr *cmsg;\n    struct iovec iov;\n    char req[1] = { 0x00 };\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    iov.iov_base = req;\n    iov.iov_len = sizeof(req);\n\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n\n    return sendmsg(c, &msg, 0);\n}\n\n#ifdef CONFIG_LIBCAP\nstatic int drop_privileges(void)\n{\n    /* clear all capabilities */\n    capng_clear(CAPNG_SELECT_BOTH);\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE | CAPNG_PERMITTED,\n                     CAP_NET_ADMIN) < 0) {\n        return -1;\n    }\n\n    /* change to calling user's real uid and gid, retaining supplemental\n     * groups and CAP_NET_ADMIN */\n    if (capng_change_id(getuid(), getgid(), CAPNG_CLEAR_BOUNDING)) {\n        return -1;\n    }\n\n    return 0;\n}\n#endif\n\nint main(int argc, char **argv)\n{\n    struct ifreq ifr;\n#ifndef SIOCBRADDIF\n    unsigned long ifargs[4];\n#endif\n    int ifindex;\n    int fd = -1, ctlfd = -1, unixfd = -1;\n    int use_vnet = 0;\n    int mtu;\n    const char *bridge = NULL;\n    char iface[IFNAMSIZ];\n    int index;\n    ACLRule *acl_rule;\n    ACLList acl_list;\n    int access_allowed, access_denied;\n    int ret = EXIT_SUCCESS;\n\n#ifdef CONFIG_LIBCAP\n    /* if we're run from an suid binary, immediately drop privileges preserving\n     * cap_net_admin */\n    if (geteuid() == 0 && getuid() != geteuid()) {\n        if (drop_privileges() == -1) {\n            fprintf(stderr, \"failed to drop privileges\\n\");\n            return 1;\n        }\n    }\n#endif\n\n    /* parse arguments */\n    for (index = 1; index < argc; index++) {\n        if (strcmp(argv[index], \"--use-vnet\") == 0) {\n            use_vnet = 1;\n        } else if (strncmp(argv[index], \"--br=\", 5) == 0) {\n            bridge = &argv[index][5];\n        } else if (strncmp(argv[index], \"--fd=\", 5) == 0) {\n            unixfd = atoi(&argv[index][5]);\n        } else {\n            usage();\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (bridge == NULL || unixfd == -1) {\n        usage();\n        return EXIT_FAILURE;\n    }\n\n    /* parse default acl file */\n    QSIMPLEQ_INIT(&acl_list);\n    if (parse_acl_file(DEFAULT_ACL_FILE, &acl_list) == -1) {\n        fprintf(stderr, \"failed to parse default acl file `%s'\\n\",\n                DEFAULT_ACL_FILE);\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* validate bridge against acl -- default policy is to deny\n     * according acl policy if we have a deny and allow both\n     * then deny should always win over allow\n     */\n    access_allowed = 0;\n    access_denied = 0;\n    QSIMPLEQ_FOREACH(acl_rule, &acl_list, entry) {\n        switch (acl_rule->type) {\n        case ACL_ALLOW_ALL:\n            access_allowed = 1;\n            break;\n        case ACL_ALLOW:\n            if (strcmp(bridge, acl_rule->iface) == 0) {\n                access_allowed = 1;\n            }\n            break;\n        case ACL_DENY_ALL:\n            access_denied = 1;\n            break;\n        case ACL_DENY:\n            if (strcmp(bridge, acl_rule->iface) == 0) {\n                access_denied = 1;\n            }\n            break;\n        }\n    }\n\n    if ((access_allowed == 0) || (access_denied == 1)) {\n        fprintf(stderr, \"access denied by acl file\\n\");\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* open a socket to use to control the network interfaces */\n    ctlfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (ctlfd == -1) {\n        fprintf(stderr, \"failed to open control socket: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* open the tap device */\n    fd = open(\"/dev/net/tun\", O_RDWR);\n    if (fd == -1) {\n        fprintf(stderr, \"failed to open /dev/net/tun: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* request a tap device, disable PI, and add vnet header support if\n     * requested and it's available. */\n    prep_ifreq(&ifr, \"tap%d\");\n    ifr.ifr_flags = IFF_TAP|IFF_NO_PI;\n    if (use_vnet && has_vnet_hdr(fd)) {\n        ifr.ifr_flags |= IFF_VNET_HDR;\n    }\n\n    if (ioctl(fd, TUNSETIFF, &ifr) == -1) {\n        fprintf(stderr, \"failed to create tun device: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* save tap device name */\n    snprintf(iface, sizeof(iface), \"%s\", ifr.ifr_name);\n\n    /* get the mtu of the bridge */\n    prep_ifreq(&ifr, bridge);\n    if (ioctl(ctlfd, SIOCGIFMTU, &ifr) == -1) {\n        fprintf(stderr, \"failed to get mtu of bridge `%s': %s\\n\",\n                bridge, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* save mtu */\n    mtu = ifr.ifr_mtu;\n\n    /* set the mtu of the interface based on the bridge */\n    prep_ifreq(&ifr, iface);\n    ifr.ifr_mtu = mtu;\n    if (ioctl(ctlfd, SIOCSIFMTU, &ifr) == -1) {\n        fprintf(stderr, \"failed to set mtu of device `%s' to %d: %s\\n\",\n                iface, mtu, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* Linux uses the lowest enslaved MAC address as the MAC address of\n     * the bridge.  Set MAC address to a high value so that it doesn't\n     * affect the MAC address of the bridge.\n     */\n    if (ioctl(ctlfd, SIOCGIFHWADDR, &ifr) < 0) {\n        fprintf(stderr, \"failed to get MAC address of device `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n    ifr.ifr_hwaddr.sa_data[0] = 0xFE;\n    if (ioctl(ctlfd, SIOCSIFHWADDR, &ifr) < 0) {\n        fprintf(stderr, \"failed to set MAC address of device `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* add the interface to the bridge */\n    prep_ifreq(&ifr, bridge);\n    ifindex = if_nametoindex(iface);\n#ifndef SIOCBRADDIF\n    ifargs[0] = BRCTL_ADD_IF;\n    ifargs[1] = ifindex;\n    ifargs[2] = 0;\n    ifargs[3] = 0;\n    ifr.ifr_data = (void *)ifargs;\n    ret = ioctl(ctlfd, SIOCDEVPRIVATE, &ifr);\n#else\n    ifr.ifr_ifindex = ifindex;\n    ret = ioctl(ctlfd, SIOCBRADDIF, &ifr);\n#endif\n    if (ret == -1) {\n        fprintf(stderr, \"failed to add interface `%s' to bridge `%s': %s\\n\",\n                iface, bridge, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* bring the interface up */\n    prep_ifreq(&ifr, iface);\n    if (ioctl(ctlfd, SIOCGIFFLAGS, &ifr) == -1) {\n        fprintf(stderr, \"failed to get interface flags for `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    ifr.ifr_flags |= IFF_UP;\n    if (ioctl(ctlfd, SIOCSIFFLAGS, &ifr) == -1) {\n        fprintf(stderr, \"failed to bring up interface `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* write fd to the domain socket */\n    if (send_fd(unixfd, fd) == -1) {\n        fprintf(stderr, \"failed to write fd to unix socket: %s\\n\",\n                strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* ... */\n\n    /* profit! */\n\ncleanup:\n    if (fd >= 0) {\n        close(fd);\n    }\n    if (ctlfd >= 0) {\n        close(ctlfd);\n    }\n    while ((acl_rule = QSIMPLEQ_FIRST(&acl_list)) != NULL) {\n        QSIMPLEQ_REMOVE_HEAD(&acl_list, entry);\n        g_free(acl_rule);\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "panda",
          "type": "tree",
          "content": null
        },
        {
          "name": "pc-bios",
          "type": "tree",
          "content": null
        },
        {
          "name": "pixman",
          "type": "commit",
          "content": null
        },
        {
          "name": "po",
          "type": "tree",
          "content": null
        },
        {
          "name": "qapi-schema.json",
          "type": "blob",
          "size": 164.451171875,
          "content": "# -*- Mode: Python -*-\n##\n# = Introduction\n#\n# This document describes all commands currently supported by QMP.\n#\n# Most of the time their usage is exactly the same as in the user Monitor, this\n# means that any other document which also describe commands (the manpage,\n# QEMU's manual, etc) can and should be consulted.\n#\n# QMP has two types of commands: regular and query commands. Regular commands\n# usually change the Virtual Machine's state someway, while query commands just\n# return information. The sections below are divided accordingly.\n#\n# It's important to observe that all communication examples are formatted in\n# a reader-friendly way, so that they're easier to understand. However, in real\n# protocol usage, they're emitted as a single line.\n#\n# Also, the following notation is used to denote data flow:\n#\n# Example:\n#\n# | -> data issued by the Client\n# | <- Server data response\n#\n# Please, refer to the QMP specification (docs/qmp-spec.txt) for\n# detailed information on the Server command and response formats.\n#\n# = Stability Considerations\n#\n# The current QMP command set (described in this file) may be useful for a\n# number of use cases, however it's limited and several commands have bad\n# defined semantics, specially with regard to command completion.\n#\n# These problems are going to be solved incrementally in the next QEMU releases\n# and we're going to establish a deprecation policy for badly defined commands.\n#\n# If you're planning to adopt QMP, please observe the following:\n#\n#     1. The deprecation policy will take effect and be documented soon, please\n#        check the documentation of each used command as soon as a new release of\n#        QEMU is available\n#\n#     2. DO NOT rely on anything which is not explicit documented\n#\n#     3. Errors, in special, are not documented. Applications should NOT check\n#        for specific errors classes or data (it's strongly recommended to only\n#        check for the \"error\" key)\n#\n##\n\n{ 'pragma': { 'doc-required': true } }\n\n# Whitelists to permit QAPI rule violations; think twice before you\n# add to them!\n{ 'pragma': {\n    # Commands allowed to return a non-dictionary:\n    'returns-whitelist': [\n        'human-monitor-command',\n        'qom-get',\n        'query-migrate-cache-size',\n        'query-tpm-models',\n        'query-tpm-types',\n        'ringbuf-read' ],\n    'name-case-whitelist': [\n        'ACPISlotType',         # DIMM, visible through query-acpi-ospm-status\n        'CpuInfoMIPS',          # PC, visible through query-cpu\n        'CpuInfoTricore',       # PC, visible through query-cpu\n        'QapiErrorClass',       # all members, visible through errors\n        'UuidInfo',             # UUID, visible through query-uuid\n        'X86CPURegister32',     # all members, visible indirectly through qom-get\n        'q_obj_CpuInfo-base'    # CPU, visible through query-cpu\n    ] } }\n\n# QAPI common definitions\n{ 'include': 'qapi/common.json' }\n\n# QAPI crypto definitions\n{ 'include': 'qapi/crypto.json' }\n\n# QAPI block definitions\n{ 'include': 'qapi/block.json' }\n\n# QAPI event definitions\n{ 'include': 'qapi/event.json' }\n\n# Tracing commands\n{ 'include': 'qapi/trace.json' }\n\n# QAPI introspection\n{ 'include': 'qapi/introspect.json' }\n\n##\n# = QMP commands\n##\n\n##\n# @qmp_capabilities:\n#\n# Enable QMP capabilities.\n#\n# Arguments: None.\n#\n# Example:\n#\n# -> { \"execute\": \"qmp_capabilities\" }\n# <- { \"return\": {} }\n#\n# Notes: This command is valid exactly when first connecting: it must be\n# issued before any other command will be accepted, and will fail once the\n# monitor is accepting other commands. (see qemu docs/qmp-spec.txt)\n#\n# Since: 0.13\n#\n##\n{ 'command': 'qmp_capabilities' }\n\n##\n# @LostTickPolicy:\n#\n# Policy for handling lost ticks in timer devices.\n#\n# @discard: throw away the missed tick(s) and continue with future injection\n#           normally.  Guest time may be delayed, unless the OS has explicit\n#           handling of lost ticks\n#\n# @delay: continue to deliver ticks at the normal rate.  Guest time will be\n#         delayed due to the late tick\n#\n# @merge: merge the missed tick(s) into one tick and inject.  Guest time\n#         may be delayed, depending on how the OS reacts to the merging\n#         of ticks\n#\n# @slew: deliver ticks at a higher rate to catch up with the missed tick. The\n#        guest time should not be delayed once catchup is complete.\n#\n# Since: 2.0\n##\n{ 'enum': 'LostTickPolicy',\n  'data': ['discard', 'delay', 'merge', 'slew' ] }\n\n##\n# @add_client:\n#\n# Allow client connections for VNC, Spice and socket based\n# character devices to be passed in to QEMU via SCM_RIGHTS.\n#\n# @protocol: protocol name. Valid names are \"vnc\", \"spice\" or the\n#            name of a character device (eg. from -chardev id=XXXX)\n#\n# @fdname: file descriptor name previously passed via 'getfd' command\n#\n# @skipauth: whether to skip authentication. Only applies\n#            to \"vnc\" and \"spice\" protocols\n#\n# @tls: whether to perform TLS. Only applies to the \"spice\"\n#       protocol\n#\n# Returns: nothing on success.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"add_client\", \"arguments\": { \"protocol\": \"vnc\",\n#                                              \"fdname\": \"myclient\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'add_client',\n  'data': { 'protocol': 'str', 'fdname': 'str', '*skipauth': 'bool',\n            '*tls': 'bool' } }\n\n##\n# @NameInfo:\n#\n# Guest name information.\n#\n# @name: The name of the guest\n#\n# Since: 0.14.0\n##\n{ 'struct': 'NameInfo', 'data': {'*name': 'str'} }\n\n##\n# @query-name:\n#\n# Return the name information of a guest.\n#\n# Returns: @NameInfo of the guest\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-name\" }\n# <- { \"return\": { \"name\": \"qemu-name\" } }\n#\n##\n{ 'command': 'query-name', 'returns': 'NameInfo' }\n\n##\n# @KvmInfo:\n#\n# Information about support for KVM acceleration\n#\n# @enabled: true if KVM acceleration is active\n#\n# @present: true if KVM acceleration is built into this executable\n#\n# Since: 0.14.0\n##\n{ 'struct': 'KvmInfo', 'data': {'enabled': 'bool', 'present': 'bool'} }\n\n##\n# @query-kvm:\n#\n# Returns information about KVM acceleration\n#\n# Returns: @KvmInfo\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-kvm\" }\n# <- { \"return\": { \"enabled\": true, \"present\": true } }\n#\n##\n{ 'command': 'query-kvm', 'returns': 'KvmInfo' }\n\n##\n# @RunState:\n#\n# An enumeration of VM run states.\n#\n# @debug: QEMU is running on a debugger\n#\n# @finish-migrate: guest is paused to finish the migration process\n#\n# @inmigrate: guest is paused waiting for an incoming migration.  Note\n# that this state does not tell whether the machine will start at the\n# end of the migration.  This depends on the command-line -S option and\n# any invocation of 'stop' or 'cont' that has happened since QEMU was\n# started.\n#\n# @internal-error: An internal error that prevents further guest execution\n# has occurred\n#\n# @io-error: the last IOP has failed and the device is configured to pause\n# on I/O errors\n#\n# @paused: guest has been paused via the 'stop' command\n#\n# @postmigrate: guest is paused following a successful 'migrate'\n#\n# @prelaunch: QEMU was started with -S and guest has not started\n#\n# @restore-vm: guest is paused to restore VM state\n#\n# @running: guest is actively running\n#\n# @save-vm: guest is paused to save the VM state\n#\n# @shutdown: guest is shut down (and -no-shutdown is in use)\n#\n# @suspended: guest is suspended (ACPI S3)\n#\n# @watchdog: the watchdog action is configured to pause and has been triggered\n#\n# @guest-panicked: guest has been panicked as a result of guest OS panic\n#\n# @colo: guest is paused to save/restore VM state under colo checkpoint,\n#        VM can not get into this state unless colo capability is enabled\n#        for migration. (since 2.8)\n##\n{ 'enum': 'RunState',\n  'data': [ 'debug', 'inmigrate', 'internal-error', 'io-error', 'paused',\n            'postmigrate', 'prelaunch', 'finish-migrate', 'restore-vm',\n            'running', 'save-vm', 'shutdown', 'suspended', 'watchdog',\n            'guest-panicked', 'colo' ] }\n\n##\n# @StatusInfo:\n#\n# Information about VCPU run state\n#\n# @running: true if all VCPUs are runnable, false if not runnable\n#\n# @singlestep: true if VCPUs are in single-step mode\n#\n# @status: the virtual machine @RunState\n#\n# Since:  0.14.0\n#\n# Notes: @singlestep is enabled through the GDB stub\n##\n{ 'struct': 'StatusInfo',\n  'data': {'running': 'bool', 'singlestep': 'bool', 'status': 'RunState'} }\n\n##\n# @query-status:\n#\n# Query the run status of all VCPUs\n#\n# Returns: @StatusInfo reflecting all VCPUs\n#\n# Since:  0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-status\" }\n# <- { \"return\": { \"running\": true,\n#                  \"singlestep\": false,\n#                  \"status\": \"running\" } }\n#\n##\n{ 'command': 'query-status', 'returns': 'StatusInfo' }\n\n##\n# @UuidInfo:\n#\n# Guest UUID information (Universally Unique Identifier).\n#\n# @UUID: the UUID of the guest\n#\n# Since: 0.14.0\n#\n# Notes: If no UUID was specified for the guest, a null UUID is returned.\n##\n{ 'struct': 'UuidInfo', 'data': {'UUID': 'str'} }\n\n##\n# @query-uuid:\n#\n# Query the guest UUID information.\n#\n# Returns: The @UuidInfo for the guest\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-uuid\" }\n# <- { \"return\": { \"UUID\": \"550e8400-e29b-41d4-a716-446655440000\" } }\n#\n##\n{ 'command': 'query-uuid', 'returns': 'UuidInfo' }\n\n##\n# @ChardevInfo:\n#\n# Information about a character device.\n#\n# @label: the label of the character device\n#\n# @filename: the filename of the character device\n#\n# @frontend-open: shows whether the frontend device attached to this backend\n#                 (eg. with the chardev=... option) is in open or closed state\n#                 (since 2.1)\n#\n# Notes: @filename is encoded using the QEMU command line character device\n#        encoding.  See the QEMU man page for details.\n#\n# Since: 0.14.0\n##\n{ 'struct': 'ChardevInfo', 'data': {'label': 'str',\n                                  'filename': 'str',\n                                  'frontend-open': 'bool'} }\n\n##\n# @query-chardev:\n#\n# Returns information about current character devices.\n#\n# Returns: a list of @ChardevInfo\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-chardev\" }\n# <- {\n#       \"return\": [\n#          {\n#             \"label\": \"charchannel0\",\n#             \"filename\": \"unix:/var/lib/libvirt/qemu/seabios.rhel6.agent,server\",\n#             \"frontend-open\": false\n#          },\n#          {\n#             \"label\": \"charmonitor\",\n#             \"filename\": \"unix:/var/lib/libvirt/qemu/seabios.rhel6.monitor,server\",\n#             \"frontend-open\": true\n#          },\n#          {\n#             \"label\": \"charserial0\",\n#             \"filename\": \"pty:/dev/pts/2\",\n#             \"frontend-open\": true\n#          }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-chardev', 'returns': ['ChardevInfo'] }\n\n##\n# @ChardevBackendInfo:\n#\n# Information about a character device backend\n#\n# @name: The backend name\n#\n# Since: 2.0\n##\n{ 'struct': 'ChardevBackendInfo', 'data': {'name': 'str'} }\n\n##\n# @query-chardev-backends:\n#\n# Returns information about character device backends.\n#\n# Returns: a list of @ChardevBackendInfo\n#\n# Since: 2.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-chardev-backends\" }\n# <- {\n#       \"return\":[\n#          {\n#             \"name\":\"udp\"\n#          },\n#          {\n#             \"name\":\"tcp\"\n#          },\n#          {\n#             \"name\":\"unix\"\n#          },\n#          {\n#             \"name\":\"spiceport\"\n#          }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-chardev-backends', 'returns': ['ChardevBackendInfo'] }\n\n##\n# @DataFormat:\n#\n# An enumeration of data format.\n#\n# @utf8: Data is a UTF-8 string (RFC 3629)\n#\n# @base64: Data is Base64 encoded binary (RFC 3548)\n#\n# Since: 1.4\n##\n{ 'enum': 'DataFormat',\n  'data': [ 'utf8', 'base64' ] }\n\n##\n# @ringbuf-write:\n#\n# Write to a ring buffer character device.\n#\n# @device: the ring buffer character device name\n#\n# @data: data to write\n#\n# @format: data encoding (default 'utf8').\n#          - base64: data must be base64 encoded text.  Its binary\n#            decoding gets written.\n#          - utf8: data's UTF-8 encoding is written\n#          - data itself is always Unicode regardless of format, like\n#            any other string.\n#\n# Returns: Nothing on success\n#\n# Since: 1.4\n#\n# Example:\n#\n# -> { \"execute\": \"ringbuf-write\",\n#      \"arguments\": { \"device\": \"foo\",\n#                     \"data\": \"abcdefgh\",\n#                     \"format\": \"utf8\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'ringbuf-write',\n  'data': {'device': 'str', 'data': 'str',\n           '*format': 'DataFormat'} }\n\n##\n# @ringbuf-read:\n#\n# Read from a ring buffer character device.\n#\n# @device: the ring buffer character device name\n#\n# @size: how many bytes to read at most\n#\n# @format: data encoding (default 'utf8').\n#          - base64: the data read is returned in base64 encoding.\n#          - utf8: the data read is interpreted as UTF-8.\n#            Bug: can screw up when the buffer contains invalid UTF-8\n#            sequences, NUL characters, after the ring buffer lost\n#            data, and when reading stops because the size limit is\n#            reached.\n#          - The return value is always Unicode regardless of format,\n#            like any other string.\n#\n# Returns: data read from the device\n#\n# Since: 1.4\n#\n# Example:\n#\n# -> { \"execute\": \"ringbuf-read\",\n#      \"arguments\": { \"device\": \"foo\",\n#                     \"size\": 1000,\n#                     \"format\": \"utf8\" } }\n# <- { \"return\": \"abcdefgh\" }\n#\n##\n{ 'command': 'ringbuf-read',\n  'data': {'device': 'str', 'size': 'int', '*format': 'DataFormat'},\n  'returns': 'str' }\n\n##\n# @EventInfo:\n#\n# Information about a QMP event\n#\n# @name: The event name\n#\n# Since: 1.2.0\n##\n{ 'struct': 'EventInfo', 'data': {'name': 'str'} }\n\n##\n# @query-events:\n#\n# Return a list of supported QMP events by this server\n#\n# Returns: A list of @EventInfo for all supported events\n#\n# Since: 1.2.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-events\" }\n# <- {\n#      \"return\": [\n#          {\n#             \"name\":\"SHUTDOWN\"\n#          },\n#          {\n#             \"name\":\"RESET\"\n#          }\n#       ]\n#    }\n#\n# Note: This example has been shortened as the real response is too long.\n#\n##\n{ 'command': 'query-events', 'returns': ['EventInfo'] }\n\n##\n# @MigrationStats:\n#\n# Detailed migration status.\n#\n# @transferred: amount of bytes already transferred to the target VM\n#\n# @remaining: amount of bytes remaining to be transferred to the target VM\n#\n# @total: total amount of bytes involved in the migration process\n#\n# @duplicate: number of duplicate (zero) pages (since 1.2)\n#\n# @skipped: number of skipped zero pages (since 1.5)\n#\n# @normal: number of normal pages (since 1.2)\n#\n# @normal-bytes: number of normal bytes sent (since 1.2)\n#\n# @dirty-pages-rate: number of pages dirtied by second by the\n#        guest (since 1.3)\n#\n# @mbps: throughput in megabits/sec. (since 1.6)\n#\n# @dirty-sync-count: number of times that dirty ram was synchronized (since 2.1)\n#\n# @postcopy-requests: The number of page requests received from the destination\n#        (since 2.7)\n#\n# Since: 0.14.0\n##\n{ 'struct': 'MigrationStats',\n  'data': {'transferred': 'int', 'remaining': 'int', 'total': 'int' ,\n           'duplicate': 'int', 'skipped': 'int', 'normal': 'int',\n           'normal-bytes': 'int', 'dirty-pages-rate' : 'int',\n           'mbps' : 'number', 'dirty-sync-count' : 'int',\n           'postcopy-requests' : 'int' } }\n\n##\n# @XBZRLECacheStats:\n#\n# Detailed XBZRLE migration cache statistics\n#\n# @cache-size: XBZRLE cache size\n#\n# @bytes: amount of bytes already transferred to the target VM\n#\n# @pages: amount of pages transferred to the target VM\n#\n# @cache-miss: number of cache miss\n#\n# @cache-miss-rate: rate of cache miss (since 2.1)\n#\n# @overflow: number of overflows\n#\n# Since: 1.2\n##\n{ 'struct': 'XBZRLECacheStats',\n  'data': {'cache-size': 'int', 'bytes': 'int', 'pages': 'int',\n           'cache-miss': 'int', 'cache-miss-rate': 'number',\n           'overflow': 'int' } }\n\n##\n# @MigrationStatus:\n#\n# An enumeration of migration status.\n#\n# @none: no migration has ever happened.\n#\n# @setup: migration process has been initiated.\n#\n# @cancelling: in the process of cancelling migration.\n#\n# @cancelled: cancelling migration is finished.\n#\n# @active: in the process of doing migration.\n#\n# @postcopy-active: like active, but now in postcopy mode. (since 2.5)\n#\n# @completed: migration is finished.\n#\n# @failed: some error occurred during migration process.\n#\n# @colo: VM is in the process of fault tolerance, VM can not get into this\n#        state unless colo capability is enabled for migration. (since 2.8)\n#\n# Since: 2.3\n#\n##\n{ 'enum': 'MigrationStatus',\n  'data': [ 'none', 'setup', 'cancelling', 'cancelled',\n            'active', 'postcopy-active', 'completed', 'failed', 'colo' ] }\n\n##\n# @MigrationInfo:\n#\n# Information about current migration process.\n#\n# @status: @MigrationStatus describing the current migration status.\n#          If this field is not returned, no migration process\n#          has been initiated\n#\n# @ram: @MigrationStats containing detailed migration\n#       status, only returned if status is 'active' or\n#       'completed'(since 1.2)\n#\n# @disk: @MigrationStats containing detailed disk migration\n#        status, only returned if status is 'active' and it is a block\n#        migration\n#\n# @xbzrle-cache: @XBZRLECacheStats containing detailed XBZRLE\n#                migration statistics, only returned if XBZRLE feature is on and\n#                status is 'active' or 'completed' (since 1.2)\n#\n# @total-time: total amount of milliseconds since migration started.\n#        If migration has ended, it returns the total migration\n#        time. (since 1.2)\n#\n# @downtime: only present when migration finishes correctly\n#        total downtime in milliseconds for the guest.\n#        (since 1.3)\n#\n# @expected-downtime: only present while migration is active\n#        expected downtime in milliseconds for the guest in last walk\n#        of the dirty bitmap. (since 1.3)\n#\n# @setup-time: amount of setup time in milliseconds _before_ the\n#        iterations begin but _after_ the QMP command is issued. This is designed\n#        to provide an accounting of any activities (such as RDMA pinning) which\n#        may be expensive, but do not actually occur during the iterative\n#        migration rounds themselves. (since 1.6)\n#\n# @cpu-throttle-percentage: percentage of time guest cpus are being\n#        throttled during auto-converge. This is only present when auto-converge\n#        has started throttling guest cpus. (Since 2.7)\n#\n# @error-desc: the human readable error description string, when\n#              @status is 'failed'. Clients should not attempt to parse the\n#              error strings. (Since 2.7)\n#\n# Since: 0.14.0\n##\n{ 'struct': 'MigrationInfo',\n  'data': {'*status': 'MigrationStatus', '*ram': 'MigrationStats',\n           '*disk': 'MigrationStats',\n           '*xbzrle-cache': 'XBZRLECacheStats',\n           '*total-time': 'int',\n           '*expected-downtime': 'int',\n           '*downtime': 'int',\n           '*setup-time': 'int',\n           '*cpu-throttle-percentage': 'int',\n           '*error-desc': 'str'} }\n\n##\n# @query-migrate:\n#\n# Returns information about current migration process. If migration\n# is active there will be another json-object with RAM migration\n# status and if block migration is active another one with block\n# migration status.\n#\n# Returns: @MigrationInfo\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# 1. Before the first migration\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- { \"return\": {} }\n#\n# 2. Migration is done and has succeeded\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- { \"return\": {\n#         \"status\": \"completed\",\n#         \"ram\":{\n#           \"transferred\":123,\n#           \"remaining\":123,\n#           \"total\":246,\n#           \"total-time\":12345,\n#           \"setup-time\":12345,\n#           \"downtime\":12345,\n#           \"duplicate\":123,\n#           \"normal\":123,\n#           \"normal-bytes\":123456,\n#           \"dirty-sync-count\":15\n#         }\n#      }\n#    }\n#\n# 3. Migration is done and has failed\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- { \"return\": { \"status\": \"failed\" } }\n#\n# 4. Migration is being performed and is not a block migration:\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- {\n#       \"return\":{\n#          \"status\":\"active\",\n#          \"ram\":{\n#             \"transferred\":123,\n#             \"remaining\":123,\n#             \"total\":246,\n#             \"total-time\":12345,\n#             \"setup-time\":12345,\n#             \"expected-downtime\":12345,\n#             \"duplicate\":123,\n#             \"normal\":123,\n#             \"normal-bytes\":123456,\n#             \"dirty-sync-count\":15\n#          }\n#       }\n#    }\n#\n# 5. Migration is being performed and is a block migration:\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- {\n#       \"return\":{\n#          \"status\":\"active\",\n#          \"ram\":{\n#             \"total\":1057024,\n#             \"remaining\":1053304,\n#             \"transferred\":3720,\n#             \"total-time\":12345,\n#             \"setup-time\":12345,\n#             \"expected-downtime\":12345,\n#             \"duplicate\":123,\n#             \"normal\":123,\n#             \"normal-bytes\":123456,\n#             \"dirty-sync-count\":15\n#          },\n#          \"disk\":{\n#             \"total\":20971520,\n#             \"remaining\":20880384,\n#             \"transferred\":91136\n#          }\n#       }\n#    }\n#\n# 6. Migration is being performed and XBZRLE is active:\n#\n# -> { \"execute\": \"query-migrate\" }\n# <- {\n#       \"return\":{\n#          \"status\":\"active\",\n#          \"capabilities\" : [ { \"capability\": \"xbzrle\", \"state\" : true } ],\n#          \"ram\":{\n#             \"total\":1057024,\n#             \"remaining\":1053304,\n#             \"transferred\":3720,\n#             \"total-time\":12345,\n#             \"setup-time\":12345,\n#             \"expected-downtime\":12345,\n#             \"duplicate\":10,\n#             \"normal\":3333,\n#             \"normal-bytes\":3412992,\n#             \"dirty-sync-count\":15\n#          },\n#          \"xbzrle-cache\":{\n#             \"cache-size\":67108864,\n#             \"bytes\":20971520,\n#             \"pages\":2444343,\n#             \"cache-miss\":2244,\n#             \"cache-miss-rate\":0.123,\n#             \"overflow\":34434\n#          }\n#       }\n#    }\n#\n##\n{ 'command': 'query-migrate', 'returns': 'MigrationInfo' }\n\n##\n# @MigrationCapability:\n#\n# Migration capabilities enumeration\n#\n# @xbzrle: Migration supports xbzrle (Xor Based Zero Run Length Encoding).\n#          This feature allows us to minimize migration traffic for certain work\n#          loads, by sending compressed difference of the pages\n#\n# @rdma-pin-all: Controls whether or not the entire VM memory footprint is\n#          mlock()'d on demand or all at once. Refer to docs/rdma.txt for usage.\n#          Disabled by default. (since 2.0)\n#\n# @zero-blocks: During storage migration encode blocks of zeroes efficiently. This\n#          essentially saves 1MB of zeroes per block on the wire. Enabling requires\n#          source and target VM to support this feature. To enable it is sufficient\n#          to enable the capability on the source VM. The feature is disabled by\n#          default. (since 1.6)\n#\n# @compress: Use multiple compression threads to accelerate live migration.\n#          This feature can help to reduce the migration traffic, by sending\n#          compressed pages. Please note that if compress and xbzrle are both\n#          on, compress only takes effect in the ram bulk stage, after that,\n#          it will be disabled and only xbzrle takes effect, this can help to\n#          minimize migration traffic. The feature is disabled by default.\n#          (since 2.4 )\n#\n# @events: generate events for each migration state change\n#          (since 2.4 )\n#\n# @auto-converge: If enabled, QEMU will automatically throttle down the guest\n#          to speed up convergence of RAM migration. (since 1.6)\n#\n# @postcopy-ram: Start executing on the migration target before all of RAM has\n#          been migrated, pulling the remaining pages along as needed. NOTE: If\n#          the migration fails during postcopy the VM will fail.  (since 2.6)\n#\n# @x-colo: If enabled, migration will never end, and the state of the VM on the\n#        primary side will be migrated continuously to the VM on secondary\n#        side, this process is called COarse-Grain LOck Stepping (COLO) for\n#        Non-stop Service. (since 2.8)\n#\n# @release-ram: if enabled, qemu will free the migrated ram pages on the source\n#        during postcopy-ram migration. (since 2.9)\n#\n# Since: 1.2\n##\n{ 'enum': 'MigrationCapability',\n  'data': ['xbzrle', 'rdma-pin-all', 'auto-converge', 'zero-blocks',\n           'compress', 'events', 'postcopy-ram', 'x-colo', 'release-ram'] }\n\n##\n# @MigrationCapabilityStatus:\n#\n# Migration capability information\n#\n# @capability: capability enum\n#\n# @state: capability state bool\n#\n# Since: 1.2\n##\n{ 'struct': 'MigrationCapabilityStatus',\n  'data': { 'capability' : 'MigrationCapability', 'state' : 'bool' } }\n\n##\n# @migrate-set-capabilities:\n#\n# Enable/Disable the following migration capabilities (like xbzrle)\n#\n# @capabilities: json array of capability modifications to make\n#\n# Since: 1.2\n#\n# Example:\n#\n# -> { \"execute\": \"migrate-set-capabilities\" , \"arguments\":\n#      { \"capabilities\": [ { \"capability\": \"xbzrle\", \"state\": true } ] } }\n#\n##\n{ 'command': 'migrate-set-capabilities',\n  'data': { 'capabilities': ['MigrationCapabilityStatus'] } }\n\n##\n# @query-migrate-capabilities:\n#\n# Returns information about the current migration capabilities status\n#\n# Returns: @MigrationCapabilitiesStatus\n#\n# Since: 1.2\n#\n# Example:\n#\n# -> { \"execute\": \"query-migrate-capabilities\" }\n# <- { \"return\": [\n#       {\"state\": false, \"capability\": \"xbzrle\"},\n#       {\"state\": false, \"capability\": \"rdma-pin-all\"},\n#       {\"state\": false, \"capability\": \"auto-converge\"},\n#       {\"state\": false, \"capability\": \"zero-blocks\"},\n#       {\"state\": false, \"capability\": \"compress\"},\n#       {\"state\": true, \"capability\": \"events\"},\n#       {\"state\": false, \"capability\": \"postcopy-ram\"},\n#       {\"state\": false, \"capability\": \"x-colo\"}\n#    ]}\n#\n##\n{ 'command': 'query-migrate-capabilities', 'returns':   ['MigrationCapabilityStatus']}\n\n##\n# @MigrationParameter:\n#\n# Migration parameters enumeration\n#\n# @compress-level: Set the compression level to be used in live migration,\n#          the compression level is an integer between 0 and 9, where 0 means\n#          no compression, 1 means the best compression speed, and 9 means best\n#          compression ratio which will consume more CPU.\n#\n# @compress-threads: Set compression thread count to be used in live migration,\n#          the compression thread count is an integer between 1 and 255.\n#\n# @decompress-threads: Set decompression thread count to be used in live\n#          migration, the decompression thread count is an integer between 1\n#          and 255. Usually, decompression is at least 4 times as fast as\n#          compression, so set the decompress-threads to the number about 1/4\n#          of compress-threads is adequate.\n#\n# @cpu-throttle-initial: Initial percentage of time guest cpus are throttled\n#                        when migration auto-converge is activated. The\n#                        default value is 20. (Since 2.7)\n#\n# @cpu-throttle-increment: throttle percentage increase each time\n#                          auto-converge detects that migration is not making\n#                          progress. The default value is 10. (Since 2.7)\n#\n# @tls-creds: ID of the 'tls-creds' object that provides credentials for\n#             establishing a TLS connection over the migration data channel.\n#             On the outgoing side of the migration, the credentials must\n#             be for a 'client' endpoint, while for the incoming side the\n#             credentials must be for a 'server' endpoint. Setting this\n#             will enable TLS for all migrations. The default is unset,\n#             resulting in unsecured migration at the QEMU level. (Since 2.7)\n#\n# @tls-hostname: hostname of the target host for the migration. This is\n#                required when using x509 based TLS credentials and the\n#                migration URI does not already include a hostname. For\n#                example if using fd: or exec: based migration, the\n#                hostname must be provided so that the server's x509\n#                certificate identity can be validated. (Since 2.7)\n#\n# @max-bandwidth: to set maximum speed for migration. maximum speed in\n#                 bytes per second. (Since 2.8)\n#\n# @downtime-limit: set maximum tolerated downtime for migration. maximum\n#                  downtime in milliseconds (Since 2.8)\n#\n# @x-checkpoint-delay: The delay time (in ms) between two COLO checkpoints in\n#          periodic mode. (Since 2.8)\n#\n# Since: 2.4\n##\n{ 'enum': 'MigrationParameter',\n  'data': ['compress-level', 'compress-threads', 'decompress-threads',\n           'cpu-throttle-initial', 'cpu-throttle-increment',\n           'tls-creds', 'tls-hostname', 'max-bandwidth',\n           'downtime-limit', 'x-checkpoint-delay' ] }\n\n##\n# @migrate-set-parameters:\n#\n# Set various migration parameters.\n#\n# Since: 2.4\n#\n# Example:\n#\n# -> { \"execute\": \"migrate-set-parameters\" ,\n#      \"arguments\": { \"compress-level\": 1 } }\n#\n##\n{ 'command': 'migrate-set-parameters', 'boxed': true,\n  'data': 'MigrationParameters' }\n\n##\n# @MigrationParameters:\n#\n# Optional members can be omitted on input ('migrate-set-parameters')\n# but most members will always be present on output\n# ('query-migrate-parameters'), with the exception of tls-creds and\n# tls-hostname.\n#\n# @compress-level: compression level\n#\n# @compress-threads: compression thread count\n#\n# @decompress-threads: decompression thread count\n#\n# @cpu-throttle-initial: Initial percentage of time guest cpus are\n#                        throttledwhen migration auto-converge is activated.\n#                        The default value is 20. (Since 2.7)\n#\n# @cpu-throttle-increment: throttle percentage increase each time\n#                          auto-converge detects that migration is not making\n#                          progress. The default value is 10. (Since 2.7)\n#\n# @tls-creds: ID of the 'tls-creds' object that provides credentials\n#             for establishing a TLS connection over the migration data\n#             channel. On the outgoing side of the migration, the credentials\n#             must be for a 'client' endpoint, while for the incoming side the\n#             credentials must be for a 'server' endpoint. Setting this\n#             will enable TLS for all migrations. The default is unset,\n#             resulting in unsecured migration at the QEMU level. (Since 2.7)\n#             An empty string means that QEMU will use plain text mode for\n#             migration, rather than TLS (Since 2.9)\n#\n# @tls-hostname: hostname of the target host for the migration. This\n#                is required when using x509 based TLS credentials and the\n#                migration URI does not already include a hostname. For\n#                example if using fd: or exec: based migration, the\n#                hostname must be provided so that the server's x509\n#                certificate identity can be validated. (Since 2.7)\n#                An empty string means that QEMU will use the hostname\n#                associated with the migration URI, if any. (Since 2.9)\n#\n# @max-bandwidth: to set maximum speed for migration. maximum speed in\n#                 bytes per second. (Since 2.8)\n#\n# @downtime-limit: set maximum tolerated downtime for migration. maximum\n#                  downtime in milliseconds (Since 2.8)\n#\n# @x-checkpoint-delay: the delay time between two COLO checkpoints. (Since 2.8)\n#\n# Since: 2.4\n##\n{ 'struct': 'MigrationParameters',\n  'data': { '*compress-level': 'int',\n            '*compress-threads': 'int',\n            '*decompress-threads': 'int',\n            '*cpu-throttle-initial': 'int',\n            '*cpu-throttle-increment': 'int',\n            '*tls-creds': 'str',\n            '*tls-hostname': 'str',\n            '*max-bandwidth': 'int',\n            '*downtime-limit': 'int',\n            '*x-checkpoint-delay': 'int'} }\n\n##\n# @query-migrate-parameters:\n#\n# Returns information about the current migration parameters\n#\n# Returns: @MigrationParameters\n#\n# Since: 2.4\n#\n# Example:\n#\n# -> { \"execute\": \"query-migrate-parameters\" }\n# <- { \"return\": {\n#          \"decompress-threads\": 2,\n#          \"cpu-throttle-increment\": 10,\n#          \"compress-threads\": 8,\n#          \"compress-level\": 1,\n#          \"cpu-throttle-initial\": 20,\n#          \"max-bandwidth\": 33554432,\n#          \"downtime-limit\": 300\n#       }\n#    }\n#\n##\n{ 'command': 'query-migrate-parameters',\n  'returns': 'MigrationParameters' }\n\n##\n# @client_migrate_info:\n#\n# Set migration information for remote display.  This makes the server\n# ask the client to automatically reconnect using the new parameters\n# once migration finished successfully.  Only implemented for SPICE.\n#\n# @protocol:     must be \"spice\"\n# @hostname:     migration target hostname\n# @port:         spice tcp port for plaintext channels\n# @tls-port:     spice tcp port for tls-secured channels\n# @cert-subject: server certificate subject\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"client_migrate_info\",\n#      \"arguments\": { \"protocol\": \"spice\",\n#                     \"hostname\": \"virt42.lab.kraxel.org\",\n#                     \"port\": 1234 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'client_migrate_info',\n  'data': { 'protocol': 'str', 'hostname': 'str', '*port': 'int',\n            '*tls-port': 'int', '*cert-subject': 'str' } }\n\n##\n# @migrate-start-postcopy:\n#\n# Followup to a migration command to switch the migration to postcopy mode.\n# The postcopy-ram capability must be set before the original migration\n# command.\n#\n# Since: 2.5\n#\n# Example:\n#\n# -> { \"execute\": \"migrate-start-postcopy\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate-start-postcopy' }\n\n##\n# @COLOMessage:\n#\n# The message transmission between Primary side and Secondary side.\n#\n# @checkpoint-ready: Secondary VM (SVM) is ready for checkpointing\n#\n# @checkpoint-request: Primary VM (PVM) tells SVM to prepare for checkpointing\n#\n# @checkpoint-reply: SVM gets PVM's checkpoint request\n#\n# @vmstate-send: VM's state will be sent by PVM.\n#\n# @vmstate-size: The total size of VMstate.\n#\n# @vmstate-received: VM's state has been received by SVM.\n#\n# @vmstate-loaded: VM's state has been loaded by SVM.\n#\n# Since: 2.8\n##\n{ 'enum': 'COLOMessage',\n  'data': [ 'checkpoint-ready', 'checkpoint-request', 'checkpoint-reply',\n            'vmstate-send', 'vmstate-size', 'vmstate-received',\n            'vmstate-loaded' ] }\n\n##\n# @COLOMode:\n#\n# The colo mode\n#\n# @unknown: unknown mode\n#\n# @primary: master side\n#\n# @secondary: slave side\n#\n# Since: 2.8\n##\n{ 'enum': 'COLOMode',\n  'data': [ 'unknown', 'primary', 'secondary'] }\n\n##\n# @FailoverStatus:\n#\n# An enumeration of COLO failover status\n#\n# @none: no failover has ever happened\n#\n# @require: got failover requirement but not handled\n#\n# @active: in the process of doing failover\n#\n# @completed: finish the process of failover\n#\n# @relaunch: restart the failover process, from 'none' -> 'completed' (Since 2.9)\n#\n# Since: 2.8\n##\n{ 'enum': 'FailoverStatus',\n  'data': [ 'none', 'require', 'active', 'completed', 'relaunch' ] }\n\n##\n# @x-colo-lost-heartbeat:\n#\n# Tell qemu that heartbeat is lost, request it to do takeover procedures.\n# If this command is sent to the PVM, the Primary side will exit COLO mode.\n# If sent to the Secondary, the Secondary side will run failover work,\n# then takes over server operation to become the service VM.\n#\n# Since: 2.8\n#\n# Example:\n#\n# -> { \"execute\": \"x-colo-lost-heartbeat\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'x-colo-lost-heartbeat' }\n\n##\n# @MouseInfo:\n#\n# Information about a mouse device.\n#\n# @name: the name of the mouse device\n#\n# @index: the index of the mouse device\n#\n# @current: true if this device is currently receiving mouse events\n#\n# @absolute: true if this device supports absolute coordinates as input\n#\n# Since: 0.14.0\n##\n{ 'struct': 'MouseInfo',\n  'data': {'name': 'str', 'index': 'int', 'current': 'bool',\n           'absolute': 'bool'} }\n\n##\n# @query-mice:\n#\n# Returns information about each active mouse device\n#\n# Returns: a list of @MouseInfo for each device\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-mice\" }\n# <- { \"return\": [\n#          {\n#             \"name\":\"QEMU Microsoft Mouse\",\n#             \"index\":0,\n#             \"current\":false,\n#             \"absolute\":false\n#          },\n#          {\n#             \"name\":\"QEMU PS/2 Mouse\",\n#             \"index\":1,\n#             \"current\":true,\n#             \"absolute\":true\n#          }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-mice', 'returns': ['MouseInfo'] }\n\n##\n# @CpuInfoArch:\n#\n# An enumeration of cpu types that enable additional information during\n# @query-cpus.\n#\n# Since: 2.6\n##\n{ 'enum': 'CpuInfoArch',\n  'data': ['x86', 'sparc', 'ppc', 'mips', 'tricore', 'other' ] }\n\n##\n# @CpuInfo:\n#\n# Information about a virtual CPU\n#\n# @CPU: the index of the virtual CPU\n#\n# @current: this only exists for backwards compatibility and should be ignored\n#\n# @halted: true if the virtual CPU is in the halt state.  Halt usually refers\n#          to a processor specific low power mode.\n#\n# @qom_path: path to the CPU object in the QOM tree (since 2.4)\n#\n# @thread_id: ID of the underlying host thread\n#\n# @arch: architecture of the cpu, which determines which additional fields\n#        will be listed (since 2.6)\n#\n# Since: 0.14.0\n#\n# Notes: @halted is a transient state that changes frequently.  By the time the\n#        data is sent to the client, the guest may no longer be halted.\n##\n{ 'union': 'CpuInfo',\n  'base': {'CPU': 'int', 'current': 'bool', 'halted': 'bool',\n           'qom_path': 'str', 'thread_id': 'int', 'arch': 'CpuInfoArch' },\n  'discriminator': 'arch',\n  'data': { 'x86': 'CpuInfoX86',\n            'sparc': 'CpuInfoSPARC',\n            'ppc': 'CpuInfoPPC',\n            'mips': 'CpuInfoMIPS',\n            'tricore': 'CpuInfoTricore',\n            'other': 'CpuInfoOther' } }\n\n##\n# @CpuInfoX86:\n#\n# Additional information about a virtual i386 or x86_64 CPU\n#\n# @pc: the 64-bit instruction pointer\n#\n# Since: 2.6\n##\n{ 'struct': 'CpuInfoX86', 'data': { 'pc': 'int' } }\n\n##\n# @CpuInfoSPARC:\n#\n# Additional information about a virtual SPARC CPU\n#\n# @pc: the PC component of the instruction pointer\n#\n# @npc: the NPC component of the instruction pointer\n#\n# Since: 2.6\n##\n{ 'struct': 'CpuInfoSPARC', 'data': { 'pc': 'int', 'npc': 'int' } }\n\n##\n# @CpuInfoPPC:\n#\n# Additional information about a virtual PPC CPU\n#\n# @nip: the instruction pointer\n#\n# Since: 2.6\n##\n{ 'struct': 'CpuInfoPPC', 'data': { 'nip': 'int' } }\n\n##\n# @CpuInfoMIPS:\n#\n# Additional information about a virtual MIPS CPU\n#\n# @PC: the instruction pointer\n#\n# Since: 2.6\n##\n{ 'struct': 'CpuInfoMIPS', 'data': { 'PC': 'int' } }\n\n##\n# @CpuInfoTricore:\n#\n# Additional information about a virtual Tricore CPU\n#\n# @PC: the instruction pointer\n#\n# Since: 2.6\n##\n{ 'struct': 'CpuInfoTricore', 'data': { 'PC': 'int' } }\n\n##\n# @CpuInfoOther:\n#\n# No additional information is available about the virtual CPU\n#\n# Since: 2.6\n#\n##\n{ 'struct': 'CpuInfoOther', 'data': { } }\n\n##\n# @query-cpus:\n#\n# Returns a list of information about each virtual CPU.\n#\n# Returns: a list of @CpuInfo for each virtual CPU\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-cpus\" }\n# <- { \"return\": [\n#          {\n#             \"CPU\":0,\n#             \"current\":true,\n#             \"halted\":false,\n#             \"qom_path\":\"/machine/unattached/device[0]\",\n#             \"arch\":\"x86\",\n#             \"pc\":3227107138,\n#             \"thread_id\":3134\n#          },\n#          {\n#             \"CPU\":1,\n#             \"current\":false,\n#             \"halted\":true,\n#             \"qom_path\":\"/machine/unattached/device[2]\",\n#             \"arch\":\"x86\",\n#             \"pc\":7108165,\n#             \"thread_id\":3135\n#          }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-cpus', 'returns': ['CpuInfo'] }\n\n##\n# @IOThreadInfo:\n#\n# Information about an iothread\n#\n# @id: the identifier of the iothread\n#\n# @thread-id: ID of the underlying host thread\n#\n# @poll-max-ns: maximum polling time in ns, 0 means polling is disabled\n#               (since 2.9)\n#\n# @poll-grow: how many ns will be added to polling time, 0 means that it's not\n#             configured (since 2.9)\n#\n# @poll-shrink: how many ns will be removed from polling time, 0 means that\n#               it's not configured (since 2.9)\n#\n# Since: 2.0\n##\n{ 'struct': 'IOThreadInfo',\n  'data': {'id': 'str',\n           'thread-id': 'int',\n           'poll-max-ns': 'int',\n           'poll-grow': 'int',\n           'poll-shrink': 'int' } }\n\n##\n# @query-iothreads:\n#\n# Returns a list of information about each iothread.\n#\n# Note: this list excludes the QEMU main loop thread, which is not declared\n# using the -object iothread command-line option.  It is always the main thread\n# of the process.\n#\n# Returns: a list of @IOThreadInfo for each iothread\n#\n# Since: 2.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-iothreads\" }\n# <- { \"return\": [\n#          {\n#             \"id\":\"iothread0\",\n#             \"thread-id\":3134\n#          },\n#          {\n#             \"id\":\"iothread1\",\n#             \"thread-id\":3135\n#          }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-iothreads', 'returns': ['IOThreadInfo'] }\n\n##\n# @NetworkAddressFamily:\n#\n# The network address family\n#\n# @ipv4: IPV4 family\n#\n# @ipv6: IPV6 family\n#\n# @unix: unix socket\n#\n# @vsock: vsock family (since 2.8)\n#\n# @unknown: otherwise\n#\n# Since: 2.1\n##\n{ 'enum': 'NetworkAddressFamily',\n  'data': [ 'ipv4', 'ipv6', 'unix', 'vsock', 'unknown' ] }\n\n##\n# @VncBasicInfo:\n#\n# The basic information for vnc network connection\n#\n# @host: IP address\n#\n# @service: The service name of the vnc port. This may depend on the host\n#           system's service database so symbolic names should not be relied\n#           on.\n#\n# @family: address family\n#\n# @websocket: true in case the socket is a websocket (since 2.3).\n#\n# Since: 2.1\n##\n{ 'struct': 'VncBasicInfo',\n  'data': { 'host': 'str',\n            'service': 'str',\n            'family': 'NetworkAddressFamily',\n            'websocket': 'bool' } }\n\n##\n# @VncServerInfo:\n#\n# The network connection information for server\n#\n# @auth: authentication method used for\n#        the plain (non-websocket) VNC server\n#\n# Since: 2.1\n##\n{ 'struct': 'VncServerInfo',\n  'base': 'VncBasicInfo',\n  'data': { '*auth': 'str' } }\n\n##\n# @VncClientInfo:\n#\n# Information about a connected VNC client.\n#\n# @x509_dname: If x509 authentication is in use, the Distinguished\n#              Name of the client.\n#\n# @sasl_username: If SASL authentication is in use, the SASL username\n#                 used for authentication.\n#\n# Since: 0.14.0\n##\n{ 'struct': 'VncClientInfo',\n  'base': 'VncBasicInfo',\n  'data': { '*x509_dname': 'str', '*sasl_username': 'str' } }\n\n##\n# @VncInfo:\n#\n# Information about the VNC session.\n#\n# @enabled: true if the VNC server is enabled, false otherwise\n#\n# @host: The hostname the VNC server is bound to.  This depends on\n#        the name resolution on the host and may be an IP address.\n#\n# @family: 'ipv6' if the host is listening for IPv6 connections\n#                    'ipv4' if the host is listening for IPv4 connections\n#                    'unix' if the host is listening on a unix domain socket\n#                    'unknown' otherwise\n#\n# @service: The service name of the server's port.  This may depends\n#           on the host system's service database so symbolic names should not\n#           be relied on.\n#\n# @auth: the current authentication type used by the server\n#        'none' if no authentication is being used\n#        'vnc' if VNC authentication is being used\n#        'vencrypt+plain' if VEncrypt is used with plain text authentication\n#        'vencrypt+tls+none' if VEncrypt is used with TLS and no authentication\n#        'vencrypt+tls+vnc' if VEncrypt is used with TLS and VNC authentication\n#        'vencrypt+tls+plain' if VEncrypt is used with TLS and plain text auth\n#        'vencrypt+x509+none' if VEncrypt is used with x509 and no auth\n#        'vencrypt+x509+vnc' if VEncrypt is used with x509 and VNC auth\n#        'vencrypt+x509+plain' if VEncrypt is used with x509 and plain text auth\n#        'vencrypt+tls+sasl' if VEncrypt is used with TLS and SASL auth\n#        'vencrypt+x509+sasl' if VEncrypt is used with x509 and SASL auth\n#\n# @clients: a list of @VncClientInfo of all currently connected clients\n#\n# Since: 0.14.0\n##\n{ 'struct': 'VncInfo',\n  'data': {'enabled': 'bool', '*host': 'str',\n           '*family': 'NetworkAddressFamily',\n           '*service': 'str', '*auth': 'str', '*clients': ['VncClientInfo']} }\n\n##\n# @VncPrimaryAuth:\n#\n# vnc primary authentication method.\n#\n# Since: 2.3\n##\n{ 'enum': 'VncPrimaryAuth',\n  'data': [ 'none', 'vnc', 'ra2', 'ra2ne', 'tight', 'ultra',\n            'tls', 'vencrypt', 'sasl' ] }\n\n##\n# @VncVencryptSubAuth:\n#\n# vnc sub authentication method with vencrypt.\n#\n# Since: 2.3\n##\n{ 'enum': 'VncVencryptSubAuth',\n  'data': [ 'plain',\n            'tls-none',  'x509-none',\n            'tls-vnc',   'x509-vnc',\n            'tls-plain', 'x509-plain',\n            'tls-sasl',  'x509-sasl' ] }\n\n\n##\n# @VncServerInfo2:\n#\n# The network connection information for server\n#\n# @auth: The current authentication type used by the servers\n#\n# @vencrypt: The vencrypt sub authentication type used by the\n#            servers, only specified in case auth == vencrypt.\n#\n# Since: 2.9\n##\n{ 'struct': 'VncServerInfo2',\n  'base': 'VncBasicInfo',\n  'data': { 'auth'      : 'VncPrimaryAuth',\n            '*vencrypt' : 'VncVencryptSubAuth' } }\n\n\n##\n# @VncInfo2:\n#\n# Information about a vnc server\n#\n# @id: vnc server name.\n#\n# @server: A list of @VncBasincInfo describing all listening sockets.\n#          The list can be empty (in case the vnc server is disabled).\n#          It also may have multiple entries: normal + websocket,\n#          possibly also ipv4 + ipv6 in the future.\n#\n# @clients: A list of @VncClientInfo of all currently connected clients.\n#           The list can be empty, for obvious reasons.\n#\n# @auth: The current authentication type used by the non-websockets servers\n#\n# @vencrypt: The vencrypt authentication type used by the servers,\n#            only specified in case auth == vencrypt.\n#\n# @display: The display device the vnc server is linked to.\n#\n# Since: 2.3\n##\n{ 'struct': 'VncInfo2',\n  'data': { 'id'        : 'str',\n            'server'    : ['VncServerInfo2'],\n            'clients'   : ['VncClientInfo'],\n            'auth'      : 'VncPrimaryAuth',\n            '*vencrypt' : 'VncVencryptSubAuth',\n            '*display'  : 'str' } }\n\n##\n# @query-vnc:\n#\n# Returns information about the current VNC server\n#\n# Returns: @VncInfo\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-vnc\" }\n# <- { \"return\": {\n#          \"enabled\":true,\n#          \"host\":\"0.0.0.0\",\n#          \"service\":\"50402\",\n#          \"auth\":\"vnc\",\n#          \"family\":\"ipv4\",\n#          \"clients\":[\n#             {\n#                \"host\":\"127.0.0.1\",\n#                \"service\":\"50401\",\n#                \"family\":\"ipv4\"\n#             }\n#          ]\n#       }\n#    }\n#\n##\n{ 'command': 'query-vnc', 'returns': 'VncInfo' }\n\n##\n# @query-vnc-servers:\n#\n# Returns a list of vnc servers.  The list can be empty.\n#\n# Returns: a list of @VncInfo2\n#\n# Since: 2.3\n##\n{ 'command': 'query-vnc-servers', 'returns': ['VncInfo2'] }\n\n##\n# @SpiceBasicInfo:\n#\n# The basic information for SPICE network connection\n#\n# @host: IP address\n#\n# @port: port number\n#\n# @family: address family\n#\n# Since: 2.1\n##\n{ 'struct': 'SpiceBasicInfo',\n  'data': { 'host': 'str',\n            'port': 'str',\n            'family': 'NetworkAddressFamily' } }\n\n##\n# @SpiceServerInfo:\n#\n# Information about a SPICE server\n#\n# @auth: authentication method\n#\n# Since: 2.1\n##\n{ 'struct': 'SpiceServerInfo',\n  'base': 'SpiceBasicInfo',\n  'data': { '*auth': 'str' } }\n\n##\n# @SpiceChannel:\n#\n# Information about a SPICE client channel.\n#\n# @connection-id: SPICE connection id number.  All channels with the same id\n#                 belong to the same SPICE session.\n#\n# @channel-type: SPICE channel type number.  \"1\" is the main control\n#                channel, filter for this one if you want to track spice\n#                sessions only\n#\n# @channel-id: SPICE channel ID number.  Usually \"0\", might be different when\n#              multiple channels of the same type exist, such as multiple\n#              display channels in a multihead setup\n#\n# @tls: true if the channel is encrypted, false otherwise.\n#\n# Since: 0.14.0\n##\n{ 'struct': 'SpiceChannel',\n  'base': 'SpiceBasicInfo',\n  'data': {'connection-id': 'int', 'channel-type': 'int', 'channel-id': 'int',\n           'tls': 'bool'} }\n\n##\n# @SpiceQueryMouseMode:\n#\n# An enumeration of Spice mouse states.\n#\n# @client: Mouse cursor position is determined by the client.\n#\n# @server: Mouse cursor position is determined by the server.\n#\n# @unknown: No information is available about mouse mode used by\n#           the spice server.\n#\n# Note: spice/enums.h has a SpiceMouseMode already, hence the name.\n#\n# Since: 1.1\n##\n{ 'enum': 'SpiceQueryMouseMode',\n  'data': [ 'client', 'server', 'unknown' ] }\n\n##\n# @SpiceInfo:\n#\n# Information about the SPICE session.\n#\n# @enabled: true if the SPICE server is enabled, false otherwise\n#\n# @migrated: true if the last guest migration completed and spice\n#            migration had completed as well. false otherwise. (since 1.4)\n#\n# @host: The hostname the SPICE server is bound to.  This depends on\n#        the name resolution on the host and may be an IP address.\n#\n# @port: The SPICE server's port number.\n#\n# @compiled-version: SPICE server version.\n#\n# @tls-port: The SPICE server's TLS port number.\n#\n# @auth: the current authentication type used by the server\n#        'none'  if no authentication is being used\n#        'spice' uses SASL or direct TLS authentication, depending on command\n#                line options\n#\n# @mouse-mode: The mode in which the mouse cursor is displayed currently. Can\n#              be determined by the client or the server, or unknown if spice\n#              server doesn't provide this information. (since: 1.1)\n#\n# @channels: a list of @SpiceChannel for each active spice channel\n#\n# Since: 0.14.0\n##\n{ 'struct': 'SpiceInfo',\n  'data': {'enabled': 'bool', 'migrated': 'bool', '*host': 'str', '*port': 'int',\n           '*tls-port': 'int', '*auth': 'str', '*compiled-version': 'str',\n           'mouse-mode': 'SpiceQueryMouseMode', '*channels': ['SpiceChannel']} }\n\n##\n# @query-spice:\n#\n# Returns information about the current SPICE server\n#\n# Returns: @SpiceInfo\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-spice\" }\n# <- { \"return\": {\n#          \"enabled\": true,\n#          \"auth\": \"spice\",\n#          \"port\": 5920,\n#          \"tls-port\": 5921,\n#          \"host\": \"0.0.0.0\",\n#          \"channels\": [\n#             {\n#                \"port\": \"54924\",\n#                \"family\": \"ipv4\",\n#                \"channel-type\": 1,\n#                \"connection-id\": 1804289383,\n#                \"host\": \"127.0.0.1\",\n#                \"channel-id\": 0,\n#                \"tls\": true\n#             },\n#             {\n#                \"port\": \"36710\",\n#                \"family\": \"ipv4\",\n#                \"channel-type\": 4,\n#                \"connection-id\": 1804289383,\n#                \"host\": \"127.0.0.1\",\n#                \"channel-id\": 0,\n#                \"tls\": false\n#             },\n#             [ ... more channels follow ... ]\n#          ]\n#       }\n#    }\n#\n##\n{ 'command': 'query-spice', 'returns': 'SpiceInfo' }\n\n##\n# @BalloonInfo:\n#\n# Information about the guest balloon device.\n#\n# @actual: the number of bytes the balloon currently contains\n#\n# Since: 0.14.0\n#\n##\n{ 'struct': 'BalloonInfo', 'data': {'actual': 'int' } }\n\n##\n# @query-balloon:\n#\n# Return information about the balloon device.\n#\n# Returns: @BalloonInfo on success\n#\n#          If the balloon driver is enabled but not functional because the KVM\n#          kernel module cannot support it, KvmMissingCap\n#\n#          If no balloon device is present, DeviceNotActive\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-balloon\" }\n# <- { \"return\": {\n#          \"actual\": 1073741824,\n#       }\n#    }\n#\n##\n{ 'command': 'query-balloon', 'returns': 'BalloonInfo' }\n\n##\n# @PciMemoryRange:\n#\n# A PCI device memory region\n#\n# @base: the starting address (guest physical)\n#\n# @limit: the ending address (guest physical)\n#\n# Since: 0.14.0\n##\n{ 'struct': 'PciMemoryRange', 'data': {'base': 'int', 'limit': 'int'} }\n\n##\n# @PciMemoryRegion:\n#\n# Information about a PCI device I/O region.\n#\n# @bar: the index of the Base Address Register for this region\n#\n# @type: 'io' if the region is a PIO region\n#        'memory' if the region is a MMIO region\n#\n# @size: memory size\n#\n# @prefetch: if @type is 'memory', true if the memory is prefetchable\n#\n# @mem_type_64: if @type is 'memory', true if the BAR is 64-bit\n#\n# Since: 0.14.0\n##\n{ 'struct': 'PciMemoryRegion',\n  'data': {'bar': 'int', 'type': 'str', 'address': 'int', 'size': 'int',\n           '*prefetch': 'bool', '*mem_type_64': 'bool' } }\n\n##\n# @PciBusInfo:\n#\n# Information about a bus of a PCI Bridge device\n#\n# @number: primary bus interface number.  This should be the number of the\n#          bus the device resides on.\n#\n# @secondary: secondary bus interface number.  This is the number of the\n#             main bus for the bridge\n#\n# @subordinate: This is the highest number bus that resides below the\n#               bridge.\n#\n# @io_range: The PIO range for all devices on this bridge\n#\n# @memory_range: The MMIO range for all devices on this bridge\n#\n# @prefetchable_range: The range of prefetchable MMIO for all devices on\n#                      this bridge\n#\n# Since: 2.4\n##\n{ 'struct': 'PciBusInfo',\n  'data': {'number': 'int', 'secondary': 'int', 'subordinate': 'int',\n           'io_range': 'PciMemoryRange',\n           'memory_range': 'PciMemoryRange',\n           'prefetchable_range': 'PciMemoryRange' } }\n\n##\n# @PciBridgeInfo:\n#\n# Information about a PCI Bridge device\n#\n# @bus: information about the bus the device resides on\n#\n# @devices: a list of @PciDeviceInfo for each device on this bridge\n#\n# Since: 0.14.0\n##\n{ 'struct': 'PciBridgeInfo',\n  'data': {'bus': 'PciBusInfo', '*devices': ['PciDeviceInfo']} }\n\n##\n# @PciDeviceClass:\n#\n# Information about the Class of a PCI device\n#\n# @desc: a string description of the device's class\n#\n# @class: the class code of the device\n#\n# Since: 2.4\n##\n{ 'struct': 'PciDeviceClass',\n  'data': {'*desc': 'str', 'class': 'int'} }\n\n##\n# @PciDeviceId:\n#\n# Information about the Id of a PCI device\n#\n# @device: the PCI device id\n#\n# @vendor: the PCI vendor id\n#\n# Since: 2.4\n##\n{ 'struct': 'PciDeviceId',\n  'data': {'device': 'int', 'vendor': 'int'} }\n\n##\n# @PciDeviceInfo:\n#\n# Information about a PCI device\n#\n# @bus: the bus number of the device\n#\n# @slot: the slot the device is located in\n#\n# @function: the function of the slot used by the device\n#\n# @class_info: the class of the device\n#\n# @id: the PCI device id\n#\n# @irq: if an IRQ is assigned to the device, the IRQ number\n#\n# @qdev_id: the device name of the PCI device\n#\n# @pci_bridge: if the device is a PCI bridge, the bridge information\n#\n# @regions: a list of the PCI I/O regions associated with the device\n#\n# Notes: the contents of @class_info.desc are not stable and should only be\n#        treated as informational.\n#\n# Since: 0.14.0\n##\n{ 'struct': 'PciDeviceInfo',\n  'data': {'bus': 'int', 'slot': 'int', 'function': 'int',\n           'class_info': 'PciDeviceClass', 'id': 'PciDeviceId',\n           '*irq': 'int', 'qdev_id': 'str', '*pci_bridge': 'PciBridgeInfo',\n           'regions': ['PciMemoryRegion']} }\n\n##\n# @PciInfo:\n#\n# Information about a PCI bus\n#\n# @bus: the bus index\n#\n# @devices: a list of devices on this bus\n#\n# Since: 0.14.0\n##\n{ 'struct': 'PciInfo', 'data': {'bus': 'int', 'devices': ['PciDeviceInfo']} }\n\n##\n# @query-pci:\n#\n# Return information about the PCI bus topology of the guest.\n#\n# Returns: a list of @PciInfo for each PCI bus. Each bus is\n# represented by a json-object, which has a key with a json-array of\n# all PCI devices attached to it. Each device is represented by a\n# json-object.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-pci\" }\n# <- { \"return\": [\n#          {\n#             \"bus\": 0,\n#             \"devices\": [\n#                {\n#                   \"bus\": 0,\n#                   \"qdev_id\": \"\",\n#                   \"slot\": 0,\n#                   \"class_info\": {\n#                      \"class\": 1536,\n#                      \"desc\": \"Host bridge\"\n#                   },\n#                   \"id\": {\n#                      \"device\": 32902,\n#                      \"vendor\": 4663\n#                   },\n#                   \"function\": 0,\n#                   \"regions\": [\n#                   ]\n#                },\n#                {\n#                   \"bus\": 0,\n#                   \"qdev_id\": \"\",\n#                   \"slot\": 1,\n#                   \"class_info\": {\n#                      \"class\": 1537,\n#                      \"desc\": \"ISA bridge\"\n#                   },\n#                   \"id\": {\n#                      \"device\": 32902,\n#                      \"vendor\": 28672\n#                   },\n#                   \"function\": 0,\n#                   \"regions\": [\n#                   ]\n#                },\n#                {\n#                   \"bus\": 0,\n#                   \"qdev_id\": \"\",\n#                   \"slot\": 1,\n#                   \"class_info\": {\n#                      \"class\": 257,\n#                      \"desc\": \"IDE controller\"\n#                   },\n#                   \"id\": {\n#                      \"device\": 32902,\n#                      \"vendor\": 28688\n#                   },\n#                   \"function\": 1,\n#                   \"regions\": [\n#                      {\n#                         \"bar\": 4,\n#                         \"size\": 16,\n#                         \"address\": 49152,\n#                         \"type\": \"io\"\n#                      }\n#                   ]\n#                },\n#                {\n#                   \"bus\": 0,\n#                   \"qdev_id\": \"\",\n#                   \"slot\": 2,\n#                   \"class_info\": {\n#                      \"class\": 768,\n#                      \"desc\": \"VGA controller\"\n#                   },\n#                   \"id\": {\n#                      \"device\": 4115,\n#                      \"vendor\": 184\n#                   },\n#                   \"function\": 0,\n#                   \"regions\": [\n#                      {\n#                         \"prefetch\": true,\n#                         \"mem_type_64\": false,\n#                         \"bar\": 0,\n#                         \"size\": 33554432,\n#                         \"address\": 4026531840,\n#                         \"type\": \"memory\"\n#                      },\n#                      {\n#                         \"prefetch\": false,\n#                         \"mem_type_64\": false,\n#                         \"bar\": 1,\n#                         \"size\": 4096,\n#                         \"address\": 4060086272,\n#                         \"type\": \"memory\"\n#                      },\n#                      {\n#                         \"prefetch\": false,\n#                         \"mem_type_64\": false,\n#                         \"bar\": 6,\n#                         \"size\": 65536,\n#                         \"address\": -1,\n#                         \"type\": \"memory\"\n#                      }\n#                   ]\n#                },\n#                {\n#                   \"bus\": 0,\n#                   \"qdev_id\": \"\",\n#                   \"irq\": 11,\n#                   \"slot\": 4,\n#                   \"class_info\": {\n#                      \"class\": 1280,\n#                      \"desc\": \"RAM controller\"\n#                   },\n#                   \"id\": {\n#                      \"device\": 6900,\n#                      \"vendor\": 4098\n#                   },\n#                   \"function\": 0,\n#                   \"regions\": [\n#                      {\n#                         \"bar\": 0,\n#                         \"size\": 32,\n#                         \"address\": 49280,\n#                         \"type\": \"io\"\n#                      }\n#                   ]\n#                }\n#             ]\n#          }\n#       ]\n#    }\n#\n# Note: This example has been shortened as the real response is too long.\n#\n##\n{ 'command': 'query-pci', 'returns': ['PciInfo'] }\n\n##\n# @quit:\n#\n# This command will cause the QEMU process to exit gracefully.  While every\n# attempt is made to send the QMP response before terminating, this is not\n# guaranteed.  When using this interface, a premature EOF would not be\n# unexpected.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"quit\" }\n# <- { \"return\": {} }\n##\n{ 'command': 'quit' }\n\n##\n# @stop:\n#\n# Stop all guest VCPU execution.\n#\n# Since:  0.14.0\n#\n# Notes:  This function will succeed even if the guest is already in the stopped\n#         state.  In \"inmigrate\" state, it will ensure that the guest\n#         remains paused once migration finishes, as if the -S option was\n#         passed on the command line.\n#\n# Example:\n#\n# -> { \"execute\": \"stop\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'stop' }\n\n##\n# @system_reset:\n#\n# Performs a hard reset of a guest.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"system_reset\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'system_reset' }\n\n##\n# @system_powerdown:\n#\n# Requests that a guest perform a powerdown operation.\n#\n# Since: 0.14.0\n#\n# Notes: A guest may or may not respond to this command.  This command\n#        returning does not indicate that a guest has accepted the request or\n#        that it has shut down.  Many guests will respond to this command by\n#        prompting the user in some way.\n# Example:\n#\n# -> { \"execute\": \"system_powerdown\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'system_powerdown' }\n\n##\n# @cpu:\n#\n# This command is a nop that is only provided for the purposes of compatibility.\n#\n# Since: 0.14.0\n#\n# Notes: Do not use this command.\n##\n{ 'command': 'cpu', 'data': {'index': 'int'} }\n\n##\n# @cpu-add:\n#\n# Adds CPU with specified ID\n#\n# @id: ID of CPU to be created, valid values [0..max_cpus)\n#\n# Returns: Nothing on success\n#\n# Since: 1.5\n#\n# Example:\n#\n# -> { \"execute\": \"cpu-add\", \"arguments\": { \"id\": 2 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'cpu-add', 'data': {'id': 'int'} }\n\n##\n# @memsave:\n#\n# Save a portion of guest memory to a file.\n#\n# @val: the virtual address of the guest to start from\n#\n# @size: the size of memory region to save\n#\n# @filename: the file to save the memory to as binary data\n#\n# @cpu-index: the index of the virtual CPU to use for translating the\n#                       virtual address (defaults to CPU 0)\n#\n# Returns: Nothing on success\n#\n# Since: 0.14.0\n#\n# Notes: Errors were not reliably returned until 1.1\n#\n# Example:\n#\n# -> { \"execute\": \"memsave\",\n#      \"arguments\": { \"val\": 10,\n#                     \"size\": 100,\n#                     \"filename\": \"/tmp/virtual-mem-dump\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'memsave',\n  'data': {'val': 'int', 'size': 'int', 'filename': 'str', '*cpu-index': 'int'} }\n\n##\n# @pmemsave:\n#\n# Save a portion of guest physical memory to a file.\n#\n# @val: the physical address of the guest to start from\n#\n# @size: the size of memory region to save\n#\n# @filename: the file to save the memory to as binary data\n#\n# Returns: Nothing on success\n#\n# Since: 0.14.0\n#\n# Notes: Errors were not reliably returned until 1.1\n#\n# Example:\n#\n# -> { \"execute\": \"pmemsave\",\n#      \"arguments\": { \"val\": 10,\n#                     \"size\": 100,\n#                     \"filename\": \"/tmp/physical-mem-dump\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'pmemsave',\n  'data': {'val': 'int', 'size': 'int', 'filename': 'str'} }\n\n##\n# @cont:\n#\n# Resume guest VCPU execution.\n#\n# Since:  0.14.0\n#\n# Returns:  If successful, nothing\n#           If QEMU was started with an encrypted block device and a key has\n#              not yet been set, DeviceEncrypted.\n#\n# Notes:  This command will succeed if the guest is currently running.  It\n#         will also succeed if the guest is in the \"inmigrate\" state; in\n#         this case, the effect of the command is to make sure the guest\n#         starts once migration finishes, removing the effect of the -S\n#         command line option if it was passed.\n#\n# Example:\n#\n# -> { \"execute\": \"cont\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'cont' }\n\n##\n# @system_wakeup:\n#\n# Wakeup guest from suspend.  Does nothing in case the guest isn't suspended.\n#\n# Since:  1.1\n#\n# Returns:  nothing.\n#\n# Example:\n#\n# -> { \"execute\": \"system_wakeup\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'system_wakeup' }\n\n##\n# @inject-nmi:\n#\n# Injects a Non-Maskable Interrupt into the default CPU (x86/s390) or all CPUs (ppc64).\n# The command fails when the guest doesn't support injecting.\n#\n# Returns:  If successful, nothing\n#\n# Since:  0.14.0\n#\n# Note: prior to 2.1, this command was only supported for x86 and s390 VMs\n#\n# Example:\n#\n# -> { \"execute\": \"inject-nmi\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'inject-nmi' }\n\n##\n# @set_link:\n#\n# Sets the link status of a virtual network adapter.\n#\n# @name: the device name of the virtual network adapter\n#\n# @up: true to set the link status to be up\n#\n# Returns: Nothing on success\n#          If @name is not a valid network device, DeviceNotFound\n#\n# Since: 0.14.0\n#\n# Notes: Not all network adapters support setting link status.  This command\n#        will succeed even if the network adapter does not support link status\n#        notification.\n#\n# Example:\n#\n# -> { \"execute\": \"set_link\",\n#      \"arguments\": { \"name\": \"e1000.0\", \"up\": false } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'set_link', 'data': {'name': 'str', 'up': 'bool'} }\n\n##\n# @balloon:\n#\n# Request the balloon driver to change its balloon size.\n#\n# @value: the target size of the balloon in bytes\n#\n# Returns: Nothing on success\n#          If the balloon driver is enabled but not functional because the KVM\n#            kernel module cannot support it, KvmMissingCap\n#          If no balloon device is present, DeviceNotActive\n#\n# Notes: This command just issues a request to the guest.  When it returns,\n#        the balloon size may not have changed.  A guest can change the balloon\n#        size independent of this command.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"balloon\", \"arguments\": { \"value\": 536870912 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'balloon', 'data': {'value': 'int'} }\n\n##\n# @Abort:\n#\n# This action can be used to test transaction failure.\n#\n# Since: 1.6\n##\n{ 'struct': 'Abort',\n  'data': { } }\n\n##\n# @ActionCompletionMode:\n#\n# An enumeration of Transactional completion modes.\n#\n# @individual: Do not attempt to cancel any other Actions if any Actions fail\n#              after the Transaction request succeeds. All Actions that\n#              can complete successfully will do so without waiting on others.\n#              This is the default.\n#\n# @grouped: If any Action fails after the Transaction succeeds, cancel all\n#           Actions. Actions do not complete until all Actions are ready to\n#           complete. May be rejected by Actions that do not support this\n#           completion mode.\n#\n# Since: 2.5\n##\n{ 'enum': 'ActionCompletionMode',\n  'data': [ 'individual', 'grouped' ] }\n\n##\n# @TransactionAction:\n#\n# A discriminated record of operations that can be performed with\n# @transaction. Action @type can be:\n#\n# - @abort: since 1.6\n# - @block-dirty-bitmap-add: since 2.5\n# - @block-dirty-bitmap-clear: since 2.5\n# - @blockdev-backup: since 2.3\n# - @blockdev-snapshot: since 2.5\n# - @blockdev-snapshot-internal-sync: since 1.7\n# - @blockdev-snapshot-sync: since 1.1\n# - @drive-backup: since 1.6\n#\n# Since: 1.1\n##\n{ 'union': 'TransactionAction',\n  'data': {\n       'abort': 'Abort',\n       'block-dirty-bitmap-add': 'BlockDirtyBitmapAdd',\n       'block-dirty-bitmap-clear': 'BlockDirtyBitmap',\n       'blockdev-backup': 'BlockdevBackup',\n       'blockdev-snapshot': 'BlockdevSnapshot',\n       'blockdev-snapshot-internal-sync': 'BlockdevSnapshotInternal',\n       'blockdev-snapshot-sync': 'BlockdevSnapshotSync',\n       'drive-backup': 'DriveBackup'\n   } }\n\n##\n# @TransactionProperties:\n#\n# Optional arguments to modify the behavior of a Transaction.\n#\n# @completion-mode: Controls how jobs launched asynchronously by\n#                   Actions will complete or fail as a group.\n#                   See @ActionCompletionMode for details.\n#\n# Since: 2.5\n##\n{ 'struct': 'TransactionProperties',\n  'data': {\n       '*completion-mode': 'ActionCompletionMode'\n  }\n}\n\n##\n# @transaction:\n#\n# Executes a number of transactionable QMP commands atomically. If any\n# operation fails, then the entire set of actions will be abandoned and the\n# appropriate error returned.\n#\n# For external snapshots, the dictionary contains the device, the file to use for\n# the new snapshot, and the format.  The default format, if not specified, is\n# qcow2.\n#\n# Each new snapshot defaults to being created by QEMU (wiping any\n# contents if the file already exists), but it is also possible to reuse\n# an externally-created file.  In the latter case, you should ensure that\n# the new image file has the same contents as the current one; QEMU cannot\n# perform any meaningful check.  Typically this is achieved by using the\n# current image file as the backing file for the new image.\n#\n# On failure, the original disks pre-snapshot attempt will be used.\n#\n# For internal snapshots, the dictionary contains the device and the snapshot's\n# name.  If an internal snapshot matching name already exists, the request will\n# be rejected.  Only some image formats support it, for example, qcow2, rbd,\n# and sheepdog.\n#\n# On failure, qemu will try delete the newly created internal snapshot in the\n# transaction.  When an I/O error occurs during deletion, the user needs to fix\n# it later with qemu-img or other command.\n#\n# @actions: List of @TransactionAction;\n#           information needed for the respective operations.\n#\n# @properties: structure of additional options to control the\n#              execution of the transaction. See @TransactionProperties\n#              for additional detail.\n#\n# Returns: nothing on success\n#\n#          Errors depend on the operations of the transaction\n#\n# Note: The transaction aborts on the first failure.  Therefore, there will be\n# information on only one failed operation returned in an error condition, and\n# subsequent actions will not have been attempted.\n#\n# Since: 1.1\n#\n# Example:\n#\n# -> { \"execute\": \"transaction\",\n#      \"arguments\": { \"actions\": [\n#          { \"type\": \"blockdev-snapshot-sync\", \"data\" : { \"device\": \"ide-hd0\",\n#                                      \"snapshot-file\": \"/some/place/my-image\",\n#                                      \"format\": \"qcow2\" } },\n#          { \"type\": \"blockdev-snapshot-sync\", \"data\" : { \"node-name\": \"myfile\",\n#                                      \"snapshot-file\": \"/some/place/my-image2\",\n#                                      \"snapshot-node-name\": \"node3432\",\n#                                      \"mode\": \"existing\",\n#                                      \"format\": \"qcow2\" } },\n#          { \"type\": \"blockdev-snapshot-sync\", \"data\" : { \"device\": \"ide-hd1\",\n#                                      \"snapshot-file\": \"/some/place/my-image2\",\n#                                      \"mode\": \"existing\",\n#                                      \"format\": \"qcow2\" } },\n#          { \"type\": \"blockdev-snapshot-internal-sync\", \"data\" : {\n#                                      \"device\": \"ide-hd2\",\n#                                      \"name\": \"snapshot0\" } } ] } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'transaction',\n  'data': { 'actions': [ 'TransactionAction' ],\n            '*properties': 'TransactionProperties'\n          }\n}\n\n##\n# @human-monitor-command:\n#\n# Execute a command on the human monitor and return the output.\n#\n# @command-line: the command to execute in the human monitor\n#\n# @cpu-index: The CPU to use for commands that require an implicit CPU\n#\n# Returns: the output of the command as a string\n#\n# Since: 0.14.0\n#\n# Notes: This command only exists as a stop-gap.  Its use is highly\n#        discouraged.  The semantics of this command are not\n#        guaranteed: this means that command names, arguments and\n#        responses can change or be removed at ANY time.  Applications\n#        that rely on long term stability guarantees should NOT\n#        use this command.\n#\n#        Known limitations:\n#\n#        * This command is stateless, this means that commands that depend\n#          on state information (such as getfd) might not work\n#\n#        * Commands that prompt the user for data (eg. 'cont' when the block\n#          device is encrypted) don't currently work\n#\n# Example:\n#\n# -> { \"execute\": \"human-monitor-command\",\n#      \"arguments\": { \"command-line\": \"info kvm\" } }\n# <- { \"return\": \"kvm support: enabled\\r\\n\" }\n#\n##\n{ 'command': 'human-monitor-command',\n  'data': {'command-line': 'str', '*cpu-index': 'int'},\n  'returns': 'str' }\n\n##\n# @migrate_cancel:\n#\n# Cancel the current executing migration process.\n#\n# Returns: nothing on success\n#\n# Notes: This command succeeds even if there is no migration process running.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"migrate_cancel\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate_cancel' }\n\n##\n# @migrate_set_downtime:\n#\n# Set maximum tolerated downtime for migration.\n#\n# @value: maximum downtime in seconds\n#\n# Returns: nothing on success\n#\n# Notes: This command is deprecated in favor of 'migrate-set-parameters'\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"migrate_set_downtime\", \"arguments\": { \"value\": 0.1 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate_set_downtime', 'data': {'value': 'number'} }\n\n##\n# @migrate_set_speed:\n#\n# Set maximum speed for migration.\n#\n# @value: maximum speed in bytes per second.\n#\n# Returns: nothing on success\n#\n# Notes: This command is deprecated in favor of 'migrate-set-parameters'\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"migrate_set_speed\", \"arguments\": { \"value\": 1024 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate_set_speed', 'data': {'value': 'int'} }\n\n##\n# @migrate-set-cache-size:\n#\n# Set cache size to be used by XBZRLE migration\n#\n# @value: cache size in bytes\n#\n# The size will be rounded down to the nearest power of 2.\n# The cache size can be modified before and during ongoing migration\n#\n# Returns: nothing on success\n#\n# Since: 1.2\n#\n# Example:\n#\n# -> { \"execute\": \"migrate-set-cache-size\",\n#      \"arguments\": { \"value\": 536870912 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate-set-cache-size', 'data': {'value': 'int'} }\n\n##\n# @query-migrate-cache-size:\n#\n# Query migration XBZRLE cache size\n#\n# Returns: XBZRLE cache size in bytes\n#\n# Since: 1.2\n#\n# Example:\n#\n# -> { \"execute\": \"query-migrate-cache-size\" }\n# <- { \"return\": 67108864 }\n#\n##\n{ 'command': 'query-migrate-cache-size', 'returns': 'int' }\n\n##\n# @ObjectPropertyInfo:\n#\n# @name: the name of the property\n#\n# @type: the type of the property.  This will typically come in one of four\n#        forms:\n#\n#        1) A primitive type such as 'u8', 'u16', 'bool', 'str', or 'double'.\n#           These types are mapped to the appropriate JSON type.\n#\n#        2) A child type in the form 'child<subtype>' where subtype is a qdev\n#           device type name.  Child properties create the composition tree.\n#\n#        3) A link type in the form 'link<subtype>' where subtype is a qdev\n#           device type name.  Link properties form the device model graph.\n#\n# Since: 1.2\n##\n{ 'struct': 'ObjectPropertyInfo',\n  'data': { 'name': 'str', 'type': 'str' } }\n\n##\n# @qom-list:\n#\n# This command will list any properties of a object given a path in the object\n# model.\n#\n# @path: the path within the object model.  See @qom-get for a description of\n#        this parameter.\n#\n# Returns: a list of @ObjectPropertyInfo that describe the properties of the\n#          object.\n#\n# Since: 1.2\n##\n{ 'command': 'qom-list',\n  'data': { 'path': 'str' },\n  'returns': [ 'ObjectPropertyInfo' ] }\n\n##\n# @qom-get:\n#\n# This command will get a property from a object model path and return the\n# value.\n#\n# @path: The path within the object model.  There are two forms of supported\n#        paths--absolute and partial paths.\n#\n#        Absolute paths are derived from the root object and can follow child<>\n#        or link<> properties.  Since they can follow link<> properties, they\n#        can be arbitrarily long.  Absolute paths look like absolute filenames\n#        and are prefixed  with a leading slash.\n#\n#        Partial paths look like relative filenames.  They do not begin\n#        with a prefix.  The matching rules for partial paths are subtle but\n#        designed to make specifying objects easy.  At each level of the\n#        composition tree, the partial path is matched as an absolute path.\n#        The first match is not returned.  At least two matches are searched\n#        for.  A successful result is only returned if only one match is\n#        found.  If more than one match is found, a flag is return to\n#        indicate that the match was ambiguous.\n#\n# @property: The property name to read\n#\n# Returns: The property value.  The type depends on the property\n#          type. child<> and link<> properties are returned as #str\n#          pathnames.  All integer property types (u8, u16, etc) are\n#          returned as #int.\n#\n# Since: 1.2\n##\n{ 'command': 'qom-get',\n  'data': { 'path': 'str', 'property': 'str' },\n  'returns': 'any' }\n\n##\n# @qom-set:\n#\n# This command will set a property from a object model path.\n#\n# @path: see @qom-get for a description of this parameter\n#\n# @property: the property name to set\n#\n# @value: a value who's type is appropriate for the property type.  See @qom-get\n#         for a description of type mapping.\n#\n# Since: 1.2\n##\n{ 'command': 'qom-set',\n  'data': { 'path': 'str', 'property': 'str', 'value': 'any' } }\n\n##\n# @set_password:\n#\n# Sets the password of a remote display session.\n#\n# @protocol: `vnc' to modify the VNC server password\n#            `spice' to modify the Spice server password\n#\n# @password: the new password\n#\n# @connected: how to handle existing clients when changing the\n#                       password.  If nothing is specified, defaults to `keep'\n#                       `fail' to fail the command if clients are connected\n#                       `disconnect' to disconnect existing clients\n#                       `keep' to maintain existing clients\n#\n# Returns: Nothing on success\n#          If Spice is not enabled, DeviceNotFound\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"set_password\", \"arguments\": { \"protocol\": \"vnc\",\n#                                                \"password\": \"secret\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'set_password',\n  'data': {'protocol': 'str', 'password': 'str', '*connected': 'str'} }\n\n##\n# @expire_password:\n#\n# Expire the password of a remote display server.\n#\n# @protocol: the name of the remote display protocol `vnc' or `spice'\n#\n# @time: when to expire the password.\n#        `now' to expire the password immediately\n#        `never' to cancel password expiration\n#        `+INT' where INT is the number of seconds from now (integer)\n#        `INT' where INT is the absolute time in seconds\n#\n# Returns: Nothing on success\n#          If @protocol is `spice' and Spice is not active, DeviceNotFound\n#\n# Since: 0.14.0\n#\n# Notes: Time is relative to the server and currently there is no way to\n#        coordinate server time with client time.  It is not recommended to\n#        use the absolute time version of the @time parameter unless you're\n#        sure you are on the same machine as the QEMU instance.\n#\n# Example:\n#\n# -> { \"execute\": \"expire_password\", \"arguments\": { \"protocol\": \"vnc\",\n#                                                   \"time\": \"+60\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'expire_password', 'data': {'protocol': 'str', 'time': 'str'} }\n\n##\n# @change-vnc-password:\n#\n# Change the VNC server password.\n#\n# @password:  the new password to use with VNC authentication\n#\n# Since: 1.1\n#\n# Notes:  An empty password in this command will set the password to the empty\n#         string.  Existing clients are unaffected by executing this command.\n##\n{ 'command': 'change-vnc-password', 'data': {'password': 'str'} }\n\n##\n# @change:\n#\n# This command is multiple commands multiplexed together.\n#\n# @device: This is normally the name of a block device but it may also be 'vnc'.\n#          when it's 'vnc', then sub command depends on @target\n#\n# @target: If @device is a block device, then this is the new filename.\n#          If @device is 'vnc', then if the value 'password' selects the vnc\n#          change password command.   Otherwise, this specifies a new server URI\n#          address to listen to for VNC connections.\n#\n# @arg:    If @device is a block device, then this is an optional format to open\n#          the device with.\n#          If @device is 'vnc' and @target is 'password', this is the new VNC\n#          password to set.  If this argument is an empty string, then no future\n#          logins will be allowed.\n#\n# Returns: Nothing on success.\n#          If @device is not a valid block device, DeviceNotFound\n#          If the new block device is encrypted, DeviceEncrypted.  Note that\n#          if this error is returned, the device has been opened successfully\n#          and an additional call to @block_passwd is required to set the\n#          device's password.  The behavior of reads and writes to the block\n#          device between when these calls are executed is undefined.\n#\n# Notes:  This interface is deprecated, and it is strongly recommended that you\n#         avoid using it.  For changing block devices, use\n#         blockdev-change-medium; for changing VNC parameters, use\n#         change-vnc-password.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# 1. Change a removable medium\n#\n# -> { \"execute\": \"change\",\n#      \"arguments\": { \"device\": \"ide1-cd0\",\n#                     \"target\": \"/srv/images/Fedora-12-x86_64-DVD.iso\" } }\n# <- { \"return\": {} }\n#\n# 2. Change VNC password\n#\n# -> { \"execute\": \"change\",\n#      \"arguments\": { \"device\": \"vnc\", \"target\": \"password\",\n#                     \"arg\": \"foobar1\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'change',\n  'data': {'device': 'str', 'target': 'str', '*arg': 'str'} }\n\n##\n# @ObjectTypeInfo:\n#\n# This structure describes a search result from @qom-list-types\n#\n# @name: the type name found in the search\n#\n# Since: 1.1\n#\n# Notes: This command is experimental and may change syntax in future releases.\n##\n{ 'struct': 'ObjectTypeInfo',\n  'data': { 'name': 'str' } }\n\n##\n# @qom-list-types:\n#\n# This command will return a list of types given search parameters\n#\n# @implements: if specified, only return types that implement this type name\n#\n# @abstract: if true, include abstract types in the results\n#\n# Returns: a list of @ObjectTypeInfo or an empty list if no results are found\n#\n# Since: 1.1\n##\n{ 'command': 'qom-list-types',\n  'data': { '*implements': 'str', '*abstract': 'bool' },\n  'returns': [ 'ObjectTypeInfo' ] }\n\n##\n# @DevicePropertyInfo:\n#\n# Information about device properties.\n#\n# @name: the name of the property\n# @type: the typename of the property\n# @description: if specified, the description of the property.\n#               (since 2.2)\n#\n# Since: 1.2\n##\n{ 'struct': 'DevicePropertyInfo',\n  'data': { 'name': 'str', 'type': 'str', '*description': 'str' } }\n\n##\n# @device-list-properties:\n#\n# List properties associated with a device.\n#\n# @typename: the type name of a device\n#\n# Returns: a list of DevicePropertyInfo describing a devices properties\n#\n# Since: 1.2\n##\n{ 'command': 'device-list-properties',\n  'data': { 'typename': 'str'},\n  'returns': [ 'DevicePropertyInfo' ] }\n\n##\n# @migrate:\n#\n# Migrates the current running guest to another Virtual Machine.\n#\n# @uri: the Uniform Resource Identifier of the destination VM\n#\n# @blk: do block migration (full disk copy)\n#\n# @inc: incremental disk copy migration\n#\n# @detach: this argument exists only for compatibility reasons and\n#          is ignored by QEMU\n#\n# Returns: nothing on success\n#\n# Since: 0.14.0\n#\n# Notes:\n#\n# 1. The 'query-migrate' command should be used to check migration's progress\n#    and final result (this information is provided by the 'status' member)\n#\n# 2. All boolean arguments default to false\n#\n# 3. The user Monitor's \"detach\" argument is invalid in QMP and should not\n#    be used\n#\n# Example:\n#\n# -> { \"execute\": \"migrate\", \"arguments\": { \"uri\": \"tcp:0:4446\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate',\n  'data': {'uri': 'str', '*blk': 'bool', '*inc': 'bool', '*detach': 'bool' } }\n\n##\n# @migrate-incoming:\n#\n# Start an incoming migration, the qemu must have been started\n# with -incoming defer\n#\n# @uri: The Uniform Resource Identifier identifying the source or\n#       address to listen on\n#\n# Returns: nothing on success\n#\n# Since: 2.3\n#\n# Notes:\n#\n# 1. It's a bad idea to use a string for the uri, but it needs to stay\n#    compatible with -incoming and the format of the uri is already exposed\n#    above libvirt.\n#\n# 2. QEMU must be started with -incoming defer to allow migrate-incoming to\n#    be used.\n#\n# 3. The uri format is the same as for -incoming\n#\n# Example:\n#\n# -> { \"execute\": \"migrate-incoming\",\n#      \"arguments\": { \"uri\": \"tcp::4446\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'migrate-incoming', 'data': {'uri': 'str' } }\n\n##\n# @xen-save-devices-state:\n#\n# Save the state of all devices to file. The RAM and the block devices\n# of the VM are not saved by this command.\n#\n# @filename: the file to save the state of the devices to as binary\n# data. See xen-save-devices-state.txt for a description of the binary\n# format.\n#\n# Returns: Nothing on success\n#\n# Since: 1.1\n#\n# Example:\n#\n# -> { \"execute\": \"xen-save-devices-state\",\n#      \"arguments\": { \"filename\": \"/tmp/save\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'xen-save-devices-state', 'data': {'filename': 'str'} }\n\n##\n# @xen-set-global-dirty-log:\n#\n# Enable or disable the global dirty log mode.\n#\n# @enable: true to enable, false to disable.\n#\n# Returns: nothing\n#\n# Since: 1.3\n#\n# Example:\n#\n# -> { \"execute\": \"xen-set-global-dirty-log\",\n#      \"arguments\": { \"enable\": true } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'xen-set-global-dirty-log', 'data': { 'enable': 'bool' } }\n\n##\n# @device_add:\n#\n# @driver: the name of the new device's driver\n#\n# @bus: the device's parent bus (device tree path)\n#\n# @id: the device's ID, must be unique\n#\n# Additional arguments depend on the type.\n#\n# Add a device.\n#\n# Notes:\n# 1. For detailed information about this command, please refer to the\n#    'docs/qdev-device-use.txt' file.\n#\n# 2. It's possible to list device properties by running QEMU with the\n#    \"-device DEVICE,help\" command-line argument, where DEVICE is the\n#    device's name\n#\n# Example:\n#\n# -> { \"execute\": \"device_add\",\n#      \"arguments\": { \"driver\": \"e1000\", \"id\": \"net1\",\n#                     \"bus\": \"pci.0\",\n#                     \"mac\": \"52:54:00:12:34:56\" } }\n# <- { \"return\": {} }\n#\n# TODO: This command effectively bypasses QAPI completely due to its\n# \"additional arguments\" business.  It shouldn't have been added to\n# the schema in this form.  It should be qapified properly, or\n# replaced by a properly qapified command.\n#\n# Since: 0.13\n##\n{ 'command': 'device_add',\n  'data': {'driver': 'str', '*bus': 'str', '*id': 'str'},\n  'gen': false } # so we can get the additional arguments\n\n##\n# @device_del:\n#\n# Remove a device from a guest\n#\n# @id: the device's ID or QOM path\n#\n# Returns: Nothing on success\n#          If @id is not a valid device, DeviceNotFound\n#\n# Notes: When this command completes, the device may not be removed from the\n#        guest.  Hot removal is an operation that requires guest cooperation.\n#        This command merely requests that the guest begin the hot removal\n#        process.  Completion of the device removal process is signaled with a\n#        DEVICE_DELETED event. Guest reset will automatically complete removal\n#        for all devices.\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"device_del\",\n#      \"arguments\": { \"id\": \"net1\" } }\n# <- { \"return\": {} }\n#\n# -> { \"execute\": \"device_del\",\n#      \"arguments\": { \"id\": \"/machine/peripheral-anon/device[0]\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'device_del', 'data': {'id': 'str'} }\n\n##\n# @DumpGuestMemoryFormat:\n#\n# An enumeration of guest-memory-dump's format.\n#\n# @elf: elf format\n#\n# @kdump-zlib: kdump-compressed format with zlib-compressed\n#\n# @kdump-lzo: kdump-compressed format with lzo-compressed\n#\n# @kdump-snappy: kdump-compressed format with snappy-compressed\n#\n# Since: 2.0\n##\n{ 'enum': 'DumpGuestMemoryFormat',\n  'data': [ 'elf', 'kdump-zlib', 'kdump-lzo', 'kdump-snappy' ] }\n\n##\n# @dump-guest-memory:\n#\n# Dump guest's memory to vmcore. It is a synchronous operation that can take\n# very long depending on the amount of guest memory.\n#\n# @paging: if true, do paging to get guest's memory mapping. This allows\n#          using gdb to process the core file.\n#\n#          IMPORTANT: this option can make QEMU allocate several gigabytes\n#                     of RAM. This can happen for a large guest, or a\n#                     malicious guest pretending to be large.\n#\n#          Also, paging=true has the following limitations:\n#\n#             1. The guest may be in a catastrophic state or can have corrupted\n#                memory, which cannot be trusted\n#             2. The guest can be in real-mode even if paging is enabled. For\n#                example, the guest uses ACPI to sleep, and ACPI sleep state\n#                goes in real-mode\n#             3. Currently only supported on i386 and x86_64.\n#\n# @protocol: the filename or file descriptor of the vmcore. The supported\n#            protocols are:\n#\n#            1. file: the protocol starts with \"file:\", and the following\n#               string is the file's path.\n#            2. fd: the protocol starts with \"fd:\", and the following string\n#               is the fd's name.\n#\n# @detach: if true, QMP will return immediately rather than\n#          waiting for the dump to finish. The user can track progress\n#          using \"query-dump\". (since 2.6).\n#\n# @begin: if specified, the starting physical address.\n#\n# @length: if specified, the memory size, in bytes. If you don't\n#          want to dump all guest's memory, please specify the start @begin\n#          and @length\n#\n# @format: if specified, the format of guest memory dump. But non-elf\n#          format is conflict with paging and filter, ie. @paging, @begin and\n#          @length is not allowed to be specified with non-elf @format at the\n#          same time (since 2.0)\n#\n# Note: All boolean arguments default to false\n#\n# Returns: nothing on success\n#\n# Since: 1.2\n#\n# Example:\n#\n# -> { \"execute\": \"dump-guest-memory\",\n#      \"arguments\": { \"protocol\": \"fd:dump\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'dump-guest-memory',\n  'data': { 'paging': 'bool', 'protocol': 'str', '*detach': 'bool',\n            '*begin': 'int', '*length': 'int',\n            '*format': 'DumpGuestMemoryFormat'} }\n\n##\n# @DumpStatus:\n#\n# Describe the status of a long-running background guest memory dump.\n#\n# @none: no dump-guest-memory has started yet.\n#\n# @active: there is one dump running in background.\n#\n# @completed: the last dump has finished successfully.\n#\n# @failed: the last dump has failed.\n#\n# Since: 2.6\n##\n{ 'enum': 'DumpStatus',\n  'data': [ 'none', 'active', 'completed', 'failed' ] }\n\n##\n# @DumpQueryResult:\n#\n# The result format for 'query-dump'.\n#\n# @status: enum of @DumpStatus, which shows current dump status\n#\n# @completed: bytes written in latest dump (uncompressed)\n#\n# @total: total bytes to be written in latest dump (uncompressed)\n#\n# Since: 2.6\n##\n{ 'struct': 'DumpQueryResult',\n  'data': { 'status': 'DumpStatus',\n            'completed': 'int',\n            'total': 'int' } }\n\n##\n# @query-dump:\n#\n# Query latest dump status.\n#\n# Returns: A @DumpStatus object showing the dump status.\n#\n# Since: 2.6\n#\n# Example:\n#\n# -> { \"execute\": \"query-dump\" }\n# <- { \"return\": { \"status\": \"active\", \"completed\": 1024000,\n#                  \"total\": 2048000 } }\n#\n##\n{ 'command': 'query-dump', 'returns': 'DumpQueryResult' }\n\n##\n# @DumpGuestMemoryCapability:\n#\n# A list of the available formats for dump-guest-memory\n#\n# Since: 2.0\n##\n{ 'struct': 'DumpGuestMemoryCapability',\n  'data': {\n      'formats': ['DumpGuestMemoryFormat'] } }\n\n##\n# @query-dump-guest-memory-capability:\n#\n# Returns the available formats for dump-guest-memory\n#\n# Returns:  A @DumpGuestMemoryCapability object listing available formats for\n#           dump-guest-memory\n#\n# Since: 2.0\n#\n# Example:\n#\n# -> { \"execute\": \"query-dump-guest-memory-capability\" }\n# <- { \"return\": { \"formats\":\n#                  [\"elf\", \"kdump-zlib\", \"kdump-lzo\", \"kdump-snappy\"] }\n#\n##\n{ 'command': 'query-dump-guest-memory-capability',\n  'returns': 'DumpGuestMemoryCapability' }\n\n##\n# @dump-skeys:\n#\n# Dump guest's storage keys\n#\n# @filename: the path to the file to dump to\n#\n# This command is only supported on s390 architecture.\n#\n# Since: 2.5\n#\n# Example:\n#\n# -> { \"execute\": \"dump-skeys\",\n#      \"arguments\": { \"filename\": \"/tmp/skeys\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'dump-skeys',\n  'data': { 'filename': 'str' } }\n\n##\n# @netdev_add:\n#\n# Add a network backend.\n#\n# @type: the type of network backend.  Current valid values are 'user', 'tap',\n#        'vde', 'socket', 'dump' and 'bridge'\n#\n# @id: the name of the new network backend\n#\n# Additional arguments depend on the type.\n#\n# TODO: This command effectively bypasses QAPI completely due to its\n# \"additional arguments\" business.  It shouldn't have been added to\n# the schema in this form.  It should be qapified properly, or\n# replaced by a properly qapified command.\n#\n# Since: 0.14.0\n#\n# Returns: Nothing on success\n#          If @type is not a valid network backend, DeviceNotFound\n#\n# Example:\n#\n# -> { \"execute\": \"netdev_add\",\n#      \"arguments\": { \"type\": \"user\", \"id\": \"netdev1\",\n#                     \"dnssearch\": \"example.org\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'netdev_add',\n  'data': {'type': 'str', 'id': 'str'},\n  'gen': false }                # so we can get the additional arguments\n\n##\n# @netdev_del:\n#\n# Remove a network backend.\n#\n# @id: the name of the network backend to remove\n#\n# Returns: Nothing on success\n#          If @id is not a valid network backend, DeviceNotFound\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"netdev_del\", \"arguments\": { \"id\": \"netdev1\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'netdev_del', 'data': {'id': 'str'} }\n\n##\n# @object-add:\n#\n# Create a QOM object.\n#\n# @qom-type: the class name for the object to be created\n#\n# @id: the name of the new object\n#\n# @props: a dictionary of properties to be passed to the backend\n#\n# Returns: Nothing on success\n#          Error if @qom-type is not a valid class name\n#\n# Since: 2.0\n#\n# Example:\n#\n# -> { \"execute\": \"object-add\",\n#      \"arguments\": { \"qom-type\": \"rng-random\", \"id\": \"rng1\",\n#                     \"props\": { \"filename\": \"/dev/hwrng\" } } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'object-add',\n  'data': {'qom-type': 'str', 'id': 'str', '*props': 'any'} }\n\n##\n# @object-del:\n#\n# Remove a QOM object.\n#\n# @id: the name of the QOM object to remove\n#\n# Returns: Nothing on success\n#          Error if @id is not a valid id for a QOM object\n#\n# Since: 2.0\n#\n# Example:\n#\n# -> { \"execute\": \"object-del\", \"arguments\": { \"id\": \"rng1\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'object-del', 'data': {'id': 'str'} }\n\n##\n# @NetdevNoneOptions:\n#\n# Use it alone to have zero network devices.\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevNoneOptions',\n  'data': { } }\n\n##\n# @NetLegacyNicOptions:\n#\n# Create a new Network Interface Card.\n#\n# @netdev: id of -netdev to connect to\n#\n# @macaddr: MAC address\n#\n# @model: device model (e1000, rtl8139, virtio etc.)\n#\n# @addr: PCI device address\n#\n# @vectors: number of MSI-x vectors, 0 to disable MSI-X\n#\n# Since: 1.2\n##\n{ 'struct': 'NetLegacyNicOptions',\n  'data': {\n    '*netdev':  'str',\n    '*macaddr': 'str',\n    '*model':   'str',\n    '*addr':    'str',\n    '*vectors': 'uint32' } }\n\n##\n# @String:\n#\n# A fat type wrapping 'str', to be embedded in lists.\n#\n# Since: 1.2\n##\n{ 'struct': 'String',\n  'data': {\n    'str': 'str' } }\n\n##\n# @NetdevUserOptions:\n#\n# Use the user mode network stack which requires no administrator privilege to\n# run.\n#\n# @hostname: client hostname reported by the builtin DHCP server\n#\n# @restrict: isolate the guest from the host\n#\n# @ipv4: whether to support IPv4, default true for enabled\n#        (since 2.6)\n#\n# @ipv6: whether to support IPv6, default true for enabled\n#        (since 2.6)\n#\n# @ip: legacy parameter, use net= instead\n#\n# @net: IP network address that the guest will see, in the\n#       form addr[/netmask] The netmask is optional, and can be\n#       either in the form a.b.c.d or as a number of valid top-most\n#       bits. Default is 10.0.2.0/24.\n#\n# @host: guest-visible address of the host\n#\n# @tftp: root directory of the built-in TFTP server\n#\n# @bootfile: BOOTP filename, for use with tftp=\n#\n# @dhcpstart: the first of the 16 IPs the built-in DHCP server can\n#             assign\n#\n# @dns: guest-visible address of the virtual nameserver\n#\n# @dnssearch: list of DNS suffixes to search, passed as DHCP option\n#             to the guest\n#\n# @ipv6-prefix: IPv6 network prefix (default is fec0::) (since\n#               2.6). The network prefix is given in the usual\n#               hexadecimal IPv6 address notation.\n#\n# @ipv6-prefixlen: IPv6 network prefix length (default is 64)\n#                  (since 2.6)\n#\n# @ipv6-host: guest-visible IPv6 address of the host (since 2.6)\n#\n# @ipv6-dns: guest-visible IPv6 address of the virtual\n#            nameserver (since 2.6)\n#\n# @smb: root directory of the built-in SMB server\n#\n# @smbserver: IP address of the built-in SMB server\n#\n# @hostfwd: redirect incoming TCP or UDP host connections to guest\n#           endpoints\n#\n# @guestfwd: forward guest TCP connections\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevUserOptions',\n  'data': {\n    '*hostname':  'str',\n    '*restrict':  'bool',\n    '*ipv4':      'bool',\n    '*ipv6':      'bool',\n    '*ip':        'str',\n    '*net':       'str',\n    '*host':      'str',\n    '*tftp':      'str',\n    '*bootfile':  'str',\n    '*dhcpstart': 'str',\n    '*dns':       'str',\n    '*dnssearch': ['String'],\n    '*ipv6-prefix':      'str',\n    '*ipv6-prefixlen':   'int',\n    '*ipv6-host':        'str',\n    '*ipv6-dns':         'str',\n    '*smb':       'str',\n    '*smbserver': 'str',\n    '*hostfwd':   ['String'],\n    '*guestfwd':  ['String'] } }\n\n##\n# @NetdevTapOptions:\n#\n# Connect the host TAP network interface name to the VLAN.\n#\n# @ifname: interface name\n#\n# @fd: file descriptor of an already opened tap\n#\n# @fds: multiple file descriptors of already opened multiqueue capable\n# tap\n#\n# @script: script to initialize the interface\n#\n# @downscript: script to shut down the interface\n#\n# @br: bridge name (since 2.8)\n#\n# @helper: command to execute to configure bridge\n#\n# @sndbuf: send buffer limit. Understands [TGMKkb] suffixes.\n#\n# @vnet_hdr: enable the IFF_VNET_HDR flag on the tap interface\n#\n# @vhost: enable vhost-net network accelerator\n#\n# @vhostfd: file descriptor of an already opened vhost net device\n#\n# @vhostfds: file descriptors of multiple already opened vhost net\n# devices\n#\n# @vhostforce: vhost on for non-MSIX virtio guests\n#\n# @queues: number of queues to be created for multiqueue capable tap\n#\n# @poll-us: maximum number of microseconds that could\n# be spent on busy polling for tap (since 2.7)\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevTapOptions',\n  'data': {\n    '*ifname':     'str',\n    '*fd':         'str',\n    '*fds':        'str',\n    '*script':     'str',\n    '*downscript': 'str',\n    '*br':         'str',\n    '*helper':     'str',\n    '*sndbuf':     'size',\n    '*vnet_hdr':   'bool',\n    '*vhost':      'bool',\n    '*vhostfd':    'str',\n    '*vhostfds':   'str',\n    '*vhostforce': 'bool',\n    '*queues':     'uint32',\n    '*poll-us':    'uint32'} }\n\n##\n# @NetdevSocketOptions:\n#\n# Connect the VLAN to a remote VLAN in another QEMU virtual machine using a TCP\n# socket connection.\n#\n# @fd: file descriptor of an already opened socket\n#\n# @listen: port number, and optional hostname, to listen on\n#\n# @connect: port number, and optional hostname, to connect to\n#\n# @mcast: UDP multicast address and port number\n#\n# @localaddr: source address and port for multicast and udp packets\n#\n# @udp: UDP unicast address and port number\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevSocketOptions',\n  'data': {\n    '*fd':        'str',\n    '*listen':    'str',\n    '*connect':   'str',\n    '*mcast':     'str',\n    '*localaddr': 'str',\n    '*udp':       'str' } }\n\n##\n# @NetdevL2TPv3Options:\n#\n# Connect the VLAN to Ethernet over L2TPv3 Static tunnel\n#\n# @src: source address\n#\n# @dst: destination address\n#\n# @srcport: source port - mandatory for udp, optional for ip\n#\n# @dstport: destination port - mandatory for udp, optional for ip\n#\n# @ipv6: force the use of ipv6\n#\n# @udp: use the udp version of l2tpv3 encapsulation\n#\n# @cookie64: use 64 bit coookies\n#\n# @counter: have sequence counter\n#\n# @pincounter: pin sequence counter to zero -\n#              workaround for buggy implementations or\n#              networks with packet reorder\n#\n# @txcookie: 32 or 64 bit transmit cookie\n#\n# @rxcookie: 32 or 64 bit receive cookie\n#\n# @txsession: 32 bit transmit session\n#\n# @rxsession: 32 bit receive session - if not specified\n#             set to the same value as transmit\n#\n# @offset: additional offset - allows the insertion of\n#          additional application-specific data before the packet payload\n#\n# Since: 2.1\n##\n{ 'struct': 'NetdevL2TPv3Options',\n  'data': {\n    'src':          'str',\n    'dst':          'str',\n    '*srcport':     'str',\n    '*dstport':     'str',\n    '*ipv6':        'bool',\n    '*udp':         'bool',\n    '*cookie64':    'bool',\n    '*counter':     'bool',\n    '*pincounter':  'bool',\n    '*txcookie':    'uint64',\n    '*rxcookie':    'uint64',\n    'txsession':    'uint32',\n    '*rxsession':   'uint32',\n    '*offset':      'uint32' } }\n\n##\n# @NetdevVdeOptions:\n#\n# Connect the VLAN to a vde switch running on the host.\n#\n# @sock: socket path\n#\n# @port: port number\n#\n# @group: group owner of socket\n#\n# @mode: permissions for socket\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevVdeOptions',\n  'data': {\n    '*sock':  'str',\n    '*port':  'uint16',\n    '*group': 'str',\n    '*mode':  'uint16' } }\n\n##\n# @NetdevDumpOptions:\n#\n# Dump VLAN network traffic to a file.\n#\n# @len: per-packet size limit (64k default). Understands [TGMKkb]\n# suffixes.\n#\n# @file: dump file path (default is qemu-vlan0.pcap)\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevDumpOptions',\n  'data': {\n    '*len':  'size',\n    '*file': 'str' } }\n\n##\n# @NetdevBridgeOptions:\n#\n# Connect a host TAP network interface to a host bridge device.\n#\n# @br: bridge name\n#\n# @helper: command to execute to configure bridge\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevBridgeOptions',\n  'data': {\n    '*br':     'str',\n    '*helper': 'str' } }\n\n##\n# @NetdevHubPortOptions:\n#\n# Connect two or more net clients through a software hub.\n#\n# @hubid: hub identifier number\n#\n# Since: 1.2\n##\n{ 'struct': 'NetdevHubPortOptions',\n  'data': {\n    'hubid':     'int32' } }\n\n##\n# @NetdevNetmapOptions:\n#\n# Connect a client to a netmap-enabled NIC or to a VALE switch port\n#\n# @ifname: Either the name of an existing network interface supported by\n#          netmap, or the name of a VALE port (created on the fly).\n#          A VALE port name is in the form 'valeXXX:YYY', where XXX and\n#          YYY are non-negative integers. XXX identifies a switch and\n#          YYY identifies a port of the switch. VALE ports having the\n#          same XXX are therefore connected to the same switch.\n#\n# @devname: path of the netmap device (default: '/dev/netmap').\n#\n# Since: 2.0\n##\n{ 'struct': 'NetdevNetmapOptions',\n  'data': {\n    'ifname':     'str',\n    '*devname':    'str' } }\n\n##\n# @NetdevVhostUserOptions:\n#\n# Vhost-user network backend\n#\n# @chardev: name of a unix socket chardev\n#\n# @vhostforce: vhost on for non-MSIX virtio guests (default: false).\n#\n# @queues: number of queues to be created for multiqueue vhost-user\n#          (default: 1) (Since 2.5)\n#\n# Since: 2.1\n##\n{ 'struct': 'NetdevVhostUserOptions',\n  'data': {\n    'chardev':        'str',\n    '*vhostforce':    'bool',\n    '*queues':        'int' } }\n\n##\n# @NetClientDriver:\n#\n# Available netdev drivers.\n#\n# Since: 2.7\n##\n{ 'enum': 'NetClientDriver',\n  'data': [ 'none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde', 'dump',\n            'bridge', 'hubport', 'netmap', 'vhost-user' ] }\n\n##\n# @Netdev:\n#\n# Captures the configuration of a network device.\n#\n# @id: identifier for monitor commands.\n#\n# @type: Specify the driver used for interpreting remaining arguments.\n#\n# Since: 1.2\n#\n# 'l2tpv3' - since 2.1\n##\n{ 'union': 'Netdev',\n  'base': { 'id': 'str', 'type': 'NetClientDriver' },\n  'discriminator': 'type',\n  'data': {\n    'none':     'NetdevNoneOptions',\n    'nic':      'NetLegacyNicOptions',\n    'user':     'NetdevUserOptions',\n    'tap':      'NetdevTapOptions',\n    'l2tpv3':   'NetdevL2TPv3Options',\n    'socket':   'NetdevSocketOptions',\n    'vde':      'NetdevVdeOptions',\n    'dump':     'NetdevDumpOptions',\n    'bridge':   'NetdevBridgeOptions',\n    'hubport':  'NetdevHubPortOptions',\n    'netmap':   'NetdevNetmapOptions',\n    'vhost-user': 'NetdevVhostUserOptions' } }\n\n##\n# @NetLegacy:\n#\n# Captures the configuration of a network device; legacy.\n#\n# @vlan: vlan number\n#\n# @id: identifier for monitor commands\n#\n# @name: identifier for monitor commands, ignored if @id is present\n#\n# @opts: device type specific properties (legacy)\n#\n# Since: 1.2\n##\n{ 'struct': 'NetLegacy',\n  'data': {\n    '*vlan': 'int32',\n    '*id':   'str',\n    '*name': 'str',\n    'opts':  'NetLegacyOptions' } }\n\n##\n# @NetLegacyOptionsType:\n#\n# Since: 1.2\n##\n{ 'enum': 'NetLegacyOptionsType',\n  'data': ['none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde',\n           'dump', 'bridge', 'netmap', 'vhost-user'] }\n\n##\n# @NetLegacyOptions:\n#\n# Like Netdev, but for use only by the legacy command line options\n#\n# Since: 1.2\n##\n{ 'union': 'NetLegacyOptions',\n  'base': { 'type': 'NetLegacyOptionsType' },\n  'discriminator': 'type',\n  'data': {\n    'none':     'NetdevNoneOptions',\n    'nic':      'NetLegacyNicOptions',\n    'user':     'NetdevUserOptions',\n    'tap':      'NetdevTapOptions',\n    'l2tpv3':   'NetdevL2TPv3Options',\n    'socket':   'NetdevSocketOptions',\n    'vde':      'NetdevVdeOptions',\n    'dump':     'NetdevDumpOptions',\n    'bridge':   'NetdevBridgeOptions',\n    'netmap':   'NetdevNetmapOptions',\n    'vhost-user': 'NetdevVhostUserOptions' } }\n\n##\n# @NetFilterDirection:\n#\n# Indicates whether a netfilter is attached to a netdev's transmit queue or\n# receive queue or both.\n#\n# @all: the filter is attached both to the receive and the transmit\n#       queue of the netdev (default).\n#\n# @rx: the filter is attached to the receive queue of the netdev,\n#      where it will receive packets sent to the netdev.\n#\n# @tx: the filter is attached to the transmit queue of the netdev,\n#      where it will receive packets sent by the netdev.\n#\n# Since: 2.5\n##\n{ 'enum': 'NetFilterDirection',\n  'data': [ 'all', 'rx', 'tx' ] }\n\n##\n# @InetSocketAddressBase:\n#\n# @host: host part of the address\n# @port: port part of the address\n##\n{ 'struct': 'InetSocketAddressBase',\n  'data': {\n    'host': 'str',\n    'port': 'str' } }\n\n##\n# @InetSocketAddress:\n#\n# Captures a socket address or address range in the Internet namespace.\n#\n# @numeric: true if the host/port are guaranteed to be numeric,\n#           false if name resolution should be attempted. Defaults to false.\n#           (Since 2.9)\n#\n# @to: If present, this is range of possible addresses, with port\n#      between @port and @to.\n#\n# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6\n#\n# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6\n#\n# Since: 1.3\n##\n{ 'struct': 'InetSocketAddress',\n  'base': 'InetSocketAddressBase',\n  'data': {\n    '*numeric':  'bool',\n    '*to': 'uint16',\n    '*ipv4': 'bool',\n    '*ipv6': 'bool' } }\n\n##\n# @UnixSocketAddress:\n#\n# Captures a socket address in the local (\"Unix socket\") namespace.\n#\n# @path: filesystem path to use\n#\n# Since: 1.3\n##\n{ 'struct': 'UnixSocketAddress',\n  'data': {\n    'path': 'str' } }\n\n##\n# @VsockSocketAddress:\n#\n# Captures a socket address in the vsock namespace.\n#\n# @cid: unique host identifier\n# @port: port\n#\n# Note: string types are used to allow for possible future hostname or\n# service resolution support.\n#\n# Since: 2.8\n##\n{ 'struct': 'VsockSocketAddress',\n  'data': {\n    'cid': 'str',\n    'port': 'str' } }\n\n##\n# @SocketAddress:\n#\n# Captures the address of a socket, which could also be a named file descriptor\n#\n# Since: 1.3\n##\n{ 'union': 'SocketAddress',\n  'data': {\n    'inet': 'InetSocketAddress',\n    'unix': 'UnixSocketAddress',\n    'vsock': 'VsockSocketAddress',\n    'fd': 'String' } }\n\n##\n# @SocketAddressFlatType:\n#\n# Available SocketAddressFlat types\n#\n# @inet:  Internet address\n#\n# @unix:  Unix domain socket\n#\n# Since: 2.9\n##\n{ 'enum': 'SocketAddressFlatType',\n  'data': [ 'inet', 'unix', 'vsock', 'fd' ] }\n\n##\n# @SocketAddressFlat:\n#\n# Captures the address of a socket\n#\n# @type:       Transport type\n#\n# This is just like SocketAddress, except it's a flat union rather\n# than a simple union.  Nicer because it avoids nesting on the wire,\n# i.e. this form has fewer {}.\n#\n# Since: 2.9\n##\n{ 'union': 'SocketAddressFlat',\n  'base': { 'type': 'SocketAddressFlatType' },\n  'discriminator': 'type',\n  'data': { 'inet': 'InetSocketAddress',\n            'unix': 'UnixSocketAddress',\n            'vsock': 'VsockSocketAddress',\n            'fd': 'String' } }\n\n##\n# @getfd:\n#\n# Receive a file descriptor via SCM rights and assign it a name\n#\n# @fdname: file descriptor name\n#\n# Returns: Nothing on success\n#\n# Since: 0.14.0\n#\n# Notes: If @fdname already exists, the file descriptor assigned to\n#        it will be closed and replaced by the received file\n#        descriptor.\n#\n#        The 'closefd' command can be used to explicitly close the\n#        file descriptor when it is no longer needed.\n#\n# Example:\n#\n# -> { \"execute\": \"getfd\", \"arguments\": { \"fdname\": \"fd1\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'getfd', 'data': {'fdname': 'str'} }\n\n##\n# @closefd:\n#\n# Close a file descriptor previously passed via SCM rights\n#\n# @fdname: file descriptor name\n#\n# Returns: Nothing on success\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"closefd\", \"arguments\": { \"fdname\": \"fd1\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'closefd', 'data': {'fdname': 'str'} }\n\n##\n# @MachineInfo:\n#\n# Information describing a machine.\n#\n# @name: the name of the machine\n#\n# @alias: an alias for the machine name\n#\n# @is-default: whether the machine is default\n#\n# @cpu-max: maximum number of CPUs supported by the machine type\n#           (since 1.5.0)\n#\n# @hotpluggable-cpus: cpu hotplug via -device is supported (since 2.7.0)\n#\n# Since: 1.2.0\n##\n{ 'struct': 'MachineInfo',\n  'data': { 'name': 'str', '*alias': 'str',\n            '*is-default': 'bool', 'cpu-max': 'int',\n            'hotpluggable-cpus': 'bool'} }\n\n##\n# @query-machines:\n#\n# Return a list of supported machines\n#\n# Returns: a list of MachineInfo\n#\n# Since: 1.2.0\n##\n{ 'command': 'query-machines', 'returns': ['MachineInfo'] }\n\n##\n# @CpuDefinitionInfo:\n#\n# Virtual CPU definition.\n#\n# @name: the name of the CPU definition\n#\n# @migration-safe: whether a CPU definition can be safely used for\n#                  migration in combination with a QEMU compatibility machine\n#                  when migrating between different QMU versions and between\n#                  hosts with different sets of (hardware or software)\n#                  capabilities. If not provided, information is not available\n#                  and callers should not assume the CPU definition to be\n#                  migration-safe. (since 2.8)\n#\n# @static: whether a CPU definition is static and will not change depending on\n#          QEMU version, machine type, machine options and accelerator options.\n#          A static model is always migration-safe. (since 2.8)\n#\n# @unavailable-features: List of properties that prevent\n#                        the CPU model from running in the current\n#                        host. (since 2.8)\n# @typename: Type name that can be used as argument to @device-list-properties,\n#            to introspect properties configurable using -cpu or -global.\n#            (since 2.9)\n#\n# @unavailable-features is a list of QOM property names that\n# represent CPU model attributes that prevent the CPU from running.\n# If the QOM property is read-only, that means there's no known\n# way to make the CPU model run in the current host. Implementations\n# that choose not to provide specific information return the\n# property name \"type\".\n# If the property is read-write, it means that it MAY be possible\n# to run the CPU model in the current host if that property is\n# changed. Management software can use it as hints to suggest or\n# choose an alternative for the user, or just to generate meaningful\n# error messages explaining why the CPU model can't be used.\n# If @unavailable-features is an empty list, the CPU model is\n# runnable using the current host and machine-type.\n# If @unavailable-features is not present, runnability\n# information for the CPU is not available.\n#\n# Since: 1.2.0\n##\n{ 'struct': 'CpuDefinitionInfo',\n  'data': { 'name': 'str', '*migration-safe': 'bool', 'static': 'bool',\n            '*unavailable-features': [ 'str' ], 'typename': 'str' } }\n\n##\n# @query-cpu-definitions:\n#\n# Return a list of supported virtual CPU definitions\n#\n# Returns: a list of CpuDefInfo\n#\n# Since: 1.2.0\n##\n{ 'command': 'query-cpu-definitions', 'returns': ['CpuDefinitionInfo'] }\n\n##\n# @CpuModelInfo:\n#\n# Virtual CPU model.\n#\n# A CPU model consists of the name of a CPU definition, to which\n# delta changes are applied (e.g. features added/removed). Most magic values\n# that an architecture might require should be hidden behind the name.\n# However, if required, architectures can expose relevant properties.\n#\n# @name: the name of the CPU definition the model is based on\n# @props: a dictionary of QOM properties to be applied\n#\n# Since: 2.8.0\n##\n{ 'struct': 'CpuModelInfo',\n  'data': { 'name': 'str',\n            '*props': 'any' } }\n\n##\n# @CpuModelExpansionType:\n#\n# An enumeration of CPU model expansion types.\n#\n# @static: Expand to a static CPU model, a combination of a static base\n#          model name and property delta changes. As the static base model will\n#          never change, the expanded CPU model will be the same, independant of\n#          independent of QEMU version, machine type, machine options, and\n#          accelerator options. Therefore, the resulting model can be used by\n#          tooling without having to specify a compatibility machine - e.g. when\n#          displaying the \"host\" model. static CPU models are migration-safe.\n#\n# @full: Expand all properties. The produced model is not guaranteed to be\n#        migration-safe, but allows tooling to get an insight and work with\n#        model details.\n#\n# Note: When a non-migration-safe CPU model is expanded in static mode, some\n# features enabled by the CPU model may be omitted, because they can't be\n# implemented by a static CPU model definition (e.g. cache info passthrough and\n# PMU passthrough in x86). If you need an accurate representation of the\n# features enabled by a non-migration-safe CPU model, use @full. If you need a\n# static representation that will keep ABI compatibility even when changing QEMU\n# version or machine-type, use @static (but keep in mind that some features may\n# be omitted).\n#\n# Since: 2.8.0\n##\n{ 'enum': 'CpuModelExpansionType',\n  'data': [ 'static', 'full' ] }\n\n\n##\n# @CpuModelExpansionInfo:\n#\n# The result of a cpu model expansion.\n#\n# @model: the expanded CpuModelInfo.\n#\n# Since: 2.8.0\n##\n{ 'struct': 'CpuModelExpansionInfo',\n  'data': { 'model': 'CpuModelInfo' } }\n\n\n##\n# @query-cpu-model-expansion:\n#\n# Expands a given CPU model (or a combination of CPU model + additional options)\n# to different granularities, allowing tooling to get an understanding what a\n# specific CPU model looks like in QEMU under a certain configuration.\n#\n# This interface can be used to query the \"host\" CPU model.\n#\n# The data returned by this command may be affected by:\n#\n# * QEMU version: CPU models may look different depending on the QEMU version.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine-type: CPU model  may look different depending on the machine-type.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine options (including accelerator): in some architectures, CPU models\n#   may look different depending on machine and accelerator options. (Except for\n#   CPU models reported as \"static\" in query-cpu-definitions.)\n# * \"-cpu\" arguments and global properties: arguments to the -cpu option and\n#   global properties may affect expansion of CPU models. Using\n#   query-cpu-model-expansion while using these is not advised.\n#\n# Some architectures may not support all expansion types. s390x supports\n# \"full\" and \"static\".\n#\n# Returns: a CpuModelExpansionInfo. Returns an error if expanding CPU models is\n#          not supported, if the model cannot be expanded, if the model contains\n#          an unknown CPU definition name, unknown properties or properties\n#          with a wrong type. Also returns an error if an expansion type is\n#          not supported.\n#\n# Since: 2.8.0\n##\n{ 'command': 'query-cpu-model-expansion',\n  'data': { 'type': 'CpuModelExpansionType',\n            'model': 'CpuModelInfo' },\n  'returns': 'CpuModelExpansionInfo' }\n\n##\n# @CpuModelCompareResult:\n#\n# An enumeration of CPU model comparation results. The result is usually\n# calculated using e.g. CPU features or CPU generations.\n#\n# @incompatible: If model A is incompatible to model B, model A is not\n#                guaranteed to run where model B runs and the other way around.\n#\n# @identical: If model A is identical to model B, model A is guaranteed to run\n#             where model B runs and the other way around.\n#\n# @superset: If model A is a superset of model B, model B is guaranteed to run\n#            where model A runs. There are no guarantees about the other way.\n#\n# @subset: If model A is a subset of model B, model A is guaranteed to run\n#          where model B runs. There are no guarantees about the other way.\n#\n# Since: 2.8.0\n##\n{ 'enum': 'CpuModelCompareResult',\n  'data': [ 'incompatible', 'identical', 'superset', 'subset' ] }\n\n##\n# @CpuModelCompareInfo:\n#\n# The result of a CPU model comparison.\n#\n# @result: The result of the compare operation.\n# @responsible-properties: List of properties that led to the comparison result\n#                          not being identical.\n#\n# @responsible-properties is a list of QOM property names that led to\n# both CPUs not being detected as identical. For identical models, this\n# list is empty.\n# If a QOM property is read-only, that means there's no known way to make the\n# CPU models identical. If the special property name \"type\" is included, the\n# models are by definition not identical and cannot be made identical.\n#\n# Since: 2.8.0\n##\n{ 'struct': 'CpuModelCompareInfo',\n  'data': {'result': 'CpuModelCompareResult',\n           'responsible-properties': ['str']\n          }\n}\n\n##\n# @query-cpu-model-comparison:\n#\n# Compares two CPU models, returning how they compare in a specific\n# configuration. The results indicates how both models compare regarding\n# runnability. This result can be used by tooling to make decisions if a\n# certain CPU model will run in a certain configuration or if a compatible\n# CPU model has to be created by baselining.\n#\n# Usually, a CPU model is compared against the maximum possible CPU model\n# of a certain configuration (e.g. the \"host\" model for KVM). If that CPU\n# model is identical or a subset, it will run in that configuration.\n#\n# The result returned by this command may be affected by:\n#\n# * QEMU version: CPU models may look different depending on the QEMU version.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine-type: CPU model may look different depending on the machine-type.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine options (including accelerator): in some architectures, CPU models\n#   may look different depending on machine and accelerator options. (Except for\n#   CPU models reported as \"static\" in query-cpu-definitions.)\n# * \"-cpu\" arguments and global properties: arguments to the -cpu option and\n#   global properties may affect expansion of CPU models. Using\n#   query-cpu-model-expansion while using these is not advised.\n#\n# Some architectures may not support comparing CPU models. s390x supports\n# comparing CPU models.\n#\n# Returns: a CpuModelBaselineInfo. Returns an error if comparing CPU models is\n#          not supported, if a model cannot be used, if a model contains\n#          an unknown cpu definition name, unknown properties or properties\n#          with wrong types.\n#\n# Since: 2.8.0\n##\n{ 'command': 'query-cpu-model-comparison',\n  'data': { 'modela': 'CpuModelInfo', 'modelb': 'CpuModelInfo' },\n  'returns': 'CpuModelCompareInfo' }\n\n##\n# @CpuModelBaselineInfo:\n#\n# The result of a CPU model baseline.\n#\n# @model: the baselined CpuModelInfo.\n#\n# Since: 2.8.0\n##\n{ 'struct': 'CpuModelBaselineInfo',\n  'data': { 'model': 'CpuModelInfo' } }\n\n##\n# @query-cpu-model-baseline:\n#\n# Baseline two CPU models, creating a compatible third model. The created\n# model will always be a static, migration-safe CPU model (see \"static\"\n# CPU model expansion for details).\n#\n# This interface can be used by tooling to create a compatible CPU model out\n# two CPU models. The created CPU model will be identical to or a subset of\n# both CPU models when comparing them. Therefore, the created CPU model is\n# guaranteed to run where the given CPU models run.\n#\n# The result returned by this command may be affected by:\n#\n# * QEMU version: CPU models may look different depending on the QEMU version.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine-type: CPU model may look different depending on the machine-type.\n#   (Except for CPU models reported as \"static\" in query-cpu-definitions.)\n# * machine options (including accelerator): in some architectures, CPU models\n#   may look different depending on machine and accelerator options. (Except for\n#   CPU models reported as \"static\" in query-cpu-definitions.)\n# * \"-cpu\" arguments and global properties: arguments to the -cpu option and\n#   global properties may affect expansion of CPU models. Using\n#   query-cpu-model-expansion while using these is not advised.\n#\n# Some architectures may not support baselining CPU models. s390x supports\n# baselining CPU models.\n#\n# Returns: a CpuModelBaselineInfo. Returns an error if baselining CPU models is\n#          not supported, if a model cannot be used, if a model contains\n#          an unknown cpu definition name, unknown properties or properties\n#          with wrong types.\n#\n# Since: 2.8.0\n##\n{ 'command': 'query-cpu-model-baseline',\n  'data': { 'modela': 'CpuModelInfo',\n            'modelb': 'CpuModelInfo' },\n  'returns': 'CpuModelBaselineInfo' }\n\n##\n# @AddfdInfo:\n#\n# Information about a file descriptor that was added to an fd set.\n#\n# @fdset-id: The ID of the fd set that @fd was added to.\n#\n# @fd: The file descriptor that was received via SCM rights and\n#      added to the fd set.\n#\n# Since: 1.2.0\n##\n{ 'struct': 'AddfdInfo', 'data': {'fdset-id': 'int', 'fd': 'int'} }\n\n##\n# @add-fd:\n#\n# Add a file descriptor, that was passed via SCM rights, to an fd set.\n#\n# @fdset-id: The ID of the fd set to add the file descriptor to.\n#\n# @opaque: A free-form string that can be used to describe the fd.\n#\n# Returns: @AddfdInfo on success\n#\n#          If file descriptor was not received, FdNotSupplied\n#\n#          If @fdset-id is a negative value, InvalidParameterValue\n#\n# Notes: The list of fd sets is shared by all monitor connections.\n#\n#        If @fdset-id is not specified, a new fd set will be created.\n#\n# Since: 1.2.0\n#\n# Example:\n#\n# -> { \"execute\": \"add-fd\", \"arguments\": { \"fdset-id\": 1 } }\n# <- { \"return\": { \"fdset-id\": 1, \"fd\": 3 } }\n#\n##\n{ 'command': 'add-fd', 'data': {'*fdset-id': 'int', '*opaque': 'str'},\n  'returns': 'AddfdInfo' }\n\n##\n# @remove-fd:\n#\n# Remove a file descriptor from an fd set.\n#\n# @fdset-id: The ID of the fd set that the file descriptor belongs to.\n#\n# @fd: The file descriptor that is to be removed.\n#\n# Returns: Nothing on success\n#          If @fdset-id or @fd is not found, FdNotFound\n#\n# Since: 1.2.0\n#\n# Notes: The list of fd sets is shared by all monitor connections.\n#\n#        If @fd is not specified, all file descriptors in @fdset-id\n#        will be removed.\n#\n# Example:\n#\n# -> { \"execute\": \"remove-fd\", \"arguments\": { \"fdset-id\": 1, \"fd\": 3 } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'remove-fd', 'data': {'fdset-id': 'int', '*fd': 'int'} }\n\n##\n# @FdsetFdInfo:\n#\n# Information about a file descriptor that belongs to an fd set.\n#\n# @fd: The file descriptor value.\n#\n# @opaque: A free-form string that can be used to describe the fd.\n#\n# Since: 1.2.0\n##\n{ 'struct': 'FdsetFdInfo',\n  'data': {'fd': 'int', '*opaque': 'str'} }\n\n##\n# @FdsetInfo:\n#\n# Information about an fd set.\n#\n# @fdset-id: The ID of the fd set.\n#\n# @fds: A list of file descriptors that belong to this fd set.\n#\n# Since: 1.2.0\n##\n{ 'struct': 'FdsetInfo',\n  'data': {'fdset-id': 'int', 'fds': ['FdsetFdInfo']} }\n\n##\n# @query-fdsets:\n#\n# Return information describing all fd sets.\n#\n# Returns: A list of @FdsetInfo\n#\n# Since: 1.2.0\n#\n# Note: The list of fd sets is shared by all monitor connections.\n#\n# Example:\n#\n# -> { \"execute\": \"query-fdsets\" }\n# <- { \"return\": [\n#        {\n#          \"fds\": [\n#            {\n#              \"fd\": 30,\n#              \"opaque\": \"rdonly:/path/to/file\"\n#            },\n#            {\n#              \"fd\": 24,\n#              \"opaque\": \"rdwr:/path/to/file\"\n#            }\n#          ],\n#          \"fdset-id\": 1\n#        },\n#        {\n#          \"fds\": [\n#            {\n#              \"fd\": 28\n#            },\n#            {\n#              \"fd\": 29\n#            }\n#          ],\n#          \"fdset-id\": 0\n#        }\n#      ]\n#    }\n#\n##\n{ 'command': 'query-fdsets', 'returns': ['FdsetInfo'] }\n\n##\n# @TargetInfo:\n#\n# Information describing the QEMU target.\n#\n# @arch: the target architecture (eg \"x86_64\", \"i386\", etc)\n#\n# Since: 1.2.0\n##\n{ 'struct': 'TargetInfo',\n  'data': { 'arch': 'str' } }\n\n##\n# @query-target:\n#\n# Return information about the target for this QEMU\n#\n# Returns: TargetInfo\n#\n# Since: 1.2.0\n##\n{ 'command': 'query-target', 'returns': 'TargetInfo' }\n\n##\n# @QKeyCode:\n#\n# An enumeration of key name.\n#\n# This is used by the @send-key command.\n#\n# @unmapped: since 2.0\n# @pause: since 2.0\n# @ro: since 2.4\n# @kp_comma: since 2.4\n# @kp_equals: since 2.6\n# @power: since 2.6\n# @hiragana: since 2.9\n# @henkan: since 2.9\n# @yen: since 2.9\n#\n# Since: 1.3.0\n#\n##\n{ 'enum': 'QKeyCode',\n  'data': [ 'unmapped',\n            'shift', 'shift_r', 'alt', 'alt_r', 'altgr', 'altgr_r', 'ctrl',\n            'ctrl_r', 'menu', 'esc', '1', '2', '3', '4', '5', '6', '7', '8',\n            '9', '0', 'minus', 'equal', 'backspace', 'tab', 'q', 'w', 'e',\n            'r', 't', 'y', 'u', 'i', 'o', 'p', 'bracket_left', 'bracket_right',\n            'ret', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'semicolon',\n            'apostrophe', 'grave_accent', 'backslash', 'z', 'x', 'c', 'v', 'b',\n            'n', 'm', 'comma', 'dot', 'slash', 'asterisk', 'spc', 'caps_lock',\n            'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10',\n            'num_lock', 'scroll_lock', 'kp_divide', 'kp_multiply',\n            'kp_subtract', 'kp_add', 'kp_enter', 'kp_decimal', 'sysrq', 'kp_0',\n            'kp_1', 'kp_2', 'kp_3', 'kp_4', 'kp_5', 'kp_6', 'kp_7', 'kp_8',\n            'kp_9', 'less', 'f11', 'f12', 'print', 'home', 'pgup', 'pgdn', 'end',\n            'left', 'up', 'down', 'right', 'insert', 'delete', 'stop', 'again',\n            'props', 'undo', 'front', 'copy', 'open', 'paste', 'find', 'cut',\n            'lf', 'help', 'meta_l', 'meta_r', 'compose', 'pause',\n            'ro', 'hiragana', 'henkan', 'yen',\n            'kp_comma', 'kp_equals', 'power' ] }\n\n##\n# @KeyValue:\n#\n# Represents a keyboard key.\n#\n# Since: 1.3.0\n##\n{ 'union': 'KeyValue',\n  'data': {\n    'number': 'int',\n    'qcode': 'QKeyCode' } }\n\n##\n# @send-key:\n#\n# Send keys to guest.\n#\n# @keys: An array of @KeyValue elements. All @KeyValues in this array are\n#        simultaneously sent to the guest. A @KeyValue.number value is sent\n#        directly to the guest, while @KeyValue.qcode must be a valid\n#        @QKeyCode value\n#\n# @hold-time: time to delay key up events, milliseconds. Defaults\n#             to 100\n#\n# Returns: Nothing on success\n#          If key is unknown or redundant, InvalidParameter\n#\n# Since: 1.3.0\n#\n# Example:\n#\n# -> { \"execute\": \"send-key\",\n#      \"arguments\": { \"keys\": [ { \"type\": \"qcode\", \"data\": \"ctrl\" },\n#                               { \"type\": \"qcode\", \"data\": \"alt\" },\n#                               { \"type\": \"qcode\", \"data\": \"delete\" } ] } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'send-key',\n  'data': { 'keys': ['KeyValue'], '*hold-time': 'int' } }\n\n##\n# @screendump:\n#\n# Write a PPM of the VGA screen to a file.\n#\n# @filename: the path of a new PPM file to store the image\n#\n# Returns: Nothing on success\n#\n# Since: 0.14.0\n#\n# Example:\n#\n# -> { \"execute\": \"screendump\",\n#      \"arguments\": { \"filename\": \"/tmp/image\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'screendump', 'data': {'filename': 'str'} }\n\n\n##\n# @ChardevCommon:\n#\n# Configuration shared across all chardev backends\n#\n# @logfile: The name of a logfile to save output\n# @logappend: true to append instead of truncate\n#             (default to false to truncate)\n#\n# Since: 2.6\n##\n{ 'struct': 'ChardevCommon', 'data': { '*logfile': 'str',\n                                       '*logappend': 'bool' } }\n\n##\n# @ChardevFile:\n#\n# Configuration info for file chardevs.\n#\n# @in:  The name of the input file\n# @out: The name of the output file\n# @append: Open the file in append mode (default false to\n#          truncate) (Since 2.6)\n#\n# Since: 1.4\n##\n{ 'struct': 'ChardevFile', 'data': { '*in' : 'str',\n                                   'out' : 'str',\n                                   '*append': 'bool' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevHostdev:\n#\n# Configuration info for device and pipe chardevs.\n#\n# @device: The name of the special file for the device,\n#          i.e. /dev/ttyS0 on Unix or COM1: on Windows\n#\n# Since: 1.4\n##\n{ 'struct': 'ChardevHostdev', 'data': { 'device' : 'str' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevSocket:\n#\n# Configuration info for (stream) socket chardevs.\n#\n# @addr: socket address to listen on (server=true)\n#        or connect to (server=false)\n# @tls-creds: the ID of the TLS credentials object (since 2.6)\n# @server: create server socket (default: true)\n# @wait: wait for incoming connection on server\n#        sockets (default: false).\n# @nodelay: set TCP_NODELAY socket option (default: false)\n# @telnet: enable telnet protocol on server\n#          sockets (default: false)\n# @reconnect: For a client socket, if a socket is disconnected,\n#          then attempt a reconnect after the given number of seconds.\n#          Setting this to zero disables this function. (default: 0)\n#          (Since: 2.2)\n#\n# Since: 1.4\n##\n{ 'struct': 'ChardevSocket', 'data': { 'addr'       : 'SocketAddress',\n                                     '*tls-creds'  : 'str',\n                                     '*server'    : 'bool',\n                                     '*wait'      : 'bool',\n                                     '*nodelay'   : 'bool',\n                                     '*telnet'    : 'bool',\n                                     '*reconnect' : 'int' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevUdp:\n#\n# Configuration info for datagram socket chardevs.\n#\n# @remote: remote address\n# @local: local address\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevUdp', 'data': { 'remote' : 'SocketAddress',\n                                  '*local' : 'SocketAddress' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevMux:\n#\n# Configuration info for mux chardevs.\n#\n# @chardev: name of the base chardev.\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevMux', 'data': { 'chardev' : 'str' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevStdio:\n#\n# Configuration info for stdio chardevs.\n#\n# @signal: Allow signals (such as SIGINT triggered by ^C)\n#          be delivered to qemu.  Default: true in -nographic mode,\n#          false otherwise.\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevStdio', 'data': { '*signal' : 'bool' },\n  'base': 'ChardevCommon' }\n\n\n##\n# @ChardevSpiceChannel:\n#\n# Configuration info for spice vm channel chardevs.\n#\n# @type: kind of channel (for example vdagent).\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevSpiceChannel', 'data': { 'type'  : 'str' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevSpicePort:\n#\n# Configuration info for spice port chardevs.\n#\n# @fqdn: name of the channel (see docs/spice-port-fqdn.txt)\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevSpicePort', 'data': { 'fqdn'  : 'str' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevVC:\n#\n# Configuration info for virtual console chardevs.\n#\n# @width:  console width,  in pixels\n# @height: console height, in pixels\n# @cols:   console width,  in chars\n# @rows:   console height, in chars\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevVC', 'data': { '*width'  : 'int',\n                                 '*height' : 'int',\n                                 '*cols'   : 'int',\n                                 '*rows'   : 'int' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevRingbuf:\n#\n# Configuration info for ring buffer chardevs.\n#\n# @size: ring buffer size, must be power of two, default is 65536\n#\n# Since: 1.5\n##\n{ 'struct': 'ChardevRingbuf', 'data': { '*size'  : 'int' },\n  'base': 'ChardevCommon' }\n\n##\n# @ChardevBackend:\n#\n# Configuration info for the new chardev backend.\n#\n# Since: 1.4 (testdev since 2.2, wctablet since 2.9)\n##\n{ 'union': 'ChardevBackend', 'data': { 'file'   : 'ChardevFile',\n                                       'serial' : 'ChardevHostdev',\n                                       'parallel': 'ChardevHostdev',\n                                       'pipe'   : 'ChardevHostdev',\n                                       'socket' : 'ChardevSocket',\n                                       'udp'    : 'ChardevUdp',\n                                       'pty'    : 'ChardevCommon',\n                                       'null'   : 'ChardevCommon',\n                                       'mux'    : 'ChardevMux',\n                                       'msmouse': 'ChardevCommon',\n                                       'wctablet' : 'ChardevCommon',\n                                       'braille': 'ChardevCommon',\n                                       'testdev': 'ChardevCommon',\n                                       'stdio'  : 'ChardevStdio',\n                                       'console': 'ChardevCommon',\n                                       'spicevmc' : 'ChardevSpiceChannel',\n                                       'spiceport' : 'ChardevSpicePort',\n                                       'vc'     : 'ChardevVC',\n                                       'ringbuf': 'ChardevRingbuf',\n                                       # next one is just for compatibility\n                                       'memory' : 'ChardevRingbuf' } }\n\n##\n# @ChardevReturn:\n#\n# Return info about the chardev backend just created.\n#\n# @pty: name of the slave pseudoterminal device, present if\n#       and only if a chardev of type 'pty' was created\n#\n# Since: 1.4\n##\n{ 'struct' : 'ChardevReturn', 'data': { '*pty' : 'str' } }\n\n##\n# @chardev-add:\n#\n# Add a character device backend\n#\n# @id: the chardev's ID, must be unique\n# @backend: backend type and parameters\n#\n# Returns: ChardevReturn.\n#\n# Since: 1.4\n#\n# Example:\n#\n# -> { \"execute\" : \"chardev-add\",\n#      \"arguments\" : { \"id\" : \"foo\",\n#                      \"backend\" : { \"type\" : \"null\", \"data\" : {} } } }\n# <- { \"return\": {} }\n#\n# -> { \"execute\" : \"chardev-add\",\n#      \"arguments\" : { \"id\" : \"bar\",\n#                      \"backend\" : { \"type\" : \"file\",\n#                                    \"data\" : { \"out\" : \"/tmp/bar.log\" } } } }\n# <- { \"return\": {} }\n#\n# -> { \"execute\" : \"chardev-add\",\n#      \"arguments\" : { \"id\" : \"baz\",\n#                      \"backend\" : { \"type\" : \"pty\", \"data\" : {} } } }\n# <- { \"return\": { \"pty\" : \"/dev/pty/42\" } }\n#\n##\n{ 'command': 'chardev-add', 'data': {'id'      : 'str',\n                                     'backend' : 'ChardevBackend' },\n  'returns': 'ChardevReturn' }\n\n##\n# @chardev-remove:\n#\n# Remove a character device backend\n#\n# @id: the chardev's ID, must exist and not be in use\n#\n# Returns: Nothing on success\n#\n# Since: 1.4\n#\n# Example:\n#\n# -> { \"execute\": \"chardev-remove\", \"arguments\": { \"id\" : \"foo\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'chardev-remove', 'data': {'id': 'str'} }\n\n##\n# @TpmModel:\n#\n# An enumeration of TPM models\n#\n# @tpm-tis: TPM TIS model\n#\n# Since: 1.5\n##\n{ 'enum': 'TpmModel', 'data': [ 'tpm-tis' ] }\n\n##\n# @query-tpm-models:\n#\n# Return a list of supported TPM models\n#\n# Returns: a list of TpmModel\n#\n# Since: 1.5\n#\n# Example:\n#\n# -> { \"execute\": \"query-tpm-models\" }\n# <- { \"return\": [ \"tpm-tis\" ] }\n#\n##\n{ 'command': 'query-tpm-models', 'returns': ['TpmModel'] }\n\n##\n# @TpmType:\n#\n# An enumeration of TPM types\n#\n# @passthrough: TPM passthrough type\n#\n# Since: 1.5\n##\n{ 'enum': 'TpmType', 'data': [ 'passthrough' ] }\n\n##\n# @query-tpm-types:\n#\n# Return a list of supported TPM types\n#\n# Returns: a list of TpmType\n#\n# Since: 1.5\n#\n# Example:\n#\n# -> { \"execute\": \"query-tpm-types\" }\n# <- { \"return\": [ \"passthrough\" ] }\n#\n##\n{ 'command': 'query-tpm-types', 'returns': ['TpmType'] }\n\n##\n# @TPMPassthroughOptions:\n#\n# Information about the TPM passthrough type\n#\n# @path: string describing the path used for accessing the TPM device\n#\n# @cancel-path: string showing the TPM's sysfs cancel file\n#               for cancellation of TPM commands while they are executing\n#\n# Since: 1.5\n##\n{ 'struct': 'TPMPassthroughOptions', 'data': { '*path' : 'str',\n                                             '*cancel-path' : 'str'} }\n\n##\n# @TpmTypeOptions:\n#\n# A union referencing different TPM backend types' configuration options\n#\n# @type: 'passthrough' The configuration options for the TPM passthrough type\n#\n# Since: 1.5\n##\n{ 'union': 'TpmTypeOptions',\n   'data': { 'passthrough' : 'TPMPassthroughOptions' } }\n\n##\n# @TPMInfo:\n#\n# Information about the TPM\n#\n# @id: The Id of the TPM\n#\n# @model: The TPM frontend model\n#\n# @options: The TPM (backend) type configuration options\n#\n# Since: 1.5\n##\n{ 'struct': 'TPMInfo',\n  'data': {'id': 'str',\n           'model': 'TpmModel',\n           'options': 'TpmTypeOptions' } }\n\n##\n# @query-tpm:\n#\n# Return information about the TPM device\n#\n# Returns: @TPMInfo on success\n#\n# Since: 1.5\n#\n# Example:\n#\n# -> { \"execute\": \"query-tpm\" }\n# <- { \"return\":\n#      [\n#        { \"model\": \"tpm-tis\",\n#          \"options\":\n#            { \"type\": \"passthrough\",\n#              \"data\":\n#                { \"cancel-path\": \"/sys/class/misc/tpm0/device/cancel\",\n#                  \"path\": \"/dev/tpm0\"\n#                }\n#            },\n#          \"id\": \"tpm0\"\n#        }\n#      ]\n#    }\n#\n##\n{ 'command': 'query-tpm', 'returns': ['TPMInfo'] }\n\n##\n# @AcpiTableOptions:\n#\n# Specify an ACPI table on the command line to load.\n#\n# At most one of @file and @data can be specified. The list of files specified\n# by any one of them is loaded and concatenated in order. If both are omitted,\n# @data is implied.\n#\n# Other fields / optargs can be used to override fields of the generic ACPI\n# table header; refer to the ACPI specification 5.0, section 5.2.6 System\n# Description Table Header. If a header field is not overridden, then the\n# corresponding value from the concatenated blob is used (in case of @file), or\n# it is filled in with a hard-coded value (in case of @data).\n#\n# String fields are copied into the matching ACPI member from lowest address\n# upwards, and silently truncated / NUL-padded to length.\n#\n# @sig: table signature / identifier (4 bytes)\n#\n# @rev: table revision number (dependent on signature, 1 byte)\n#\n# @oem_id: OEM identifier (6 bytes)\n#\n# @oem_table_id: OEM table identifier (8 bytes)\n#\n# @oem_rev: OEM-supplied revision number (4 bytes)\n#\n# @asl_compiler_id: identifier of the utility that created the table\n#                   (4 bytes)\n#\n# @asl_compiler_rev: revision number of the utility that created the\n#                    table (4 bytes)\n#\n# @file: colon (:) separated list of pathnames to load and\n#        concatenate as table data. The resultant binary blob is expected to\n#        have an ACPI table header. At least one file is required. This field\n#        excludes @data.\n#\n# @data: colon (:) separated list of pathnames to load and\n#        concatenate as table data. The resultant binary blob must not have an\n#        ACPI table header. At least one file is required. This field excludes\n#        @file.\n#\n# Since: 1.5\n##\n{ 'struct': 'AcpiTableOptions',\n  'data': {\n    '*sig':               'str',\n    '*rev':               'uint8',\n    '*oem_id':            'str',\n    '*oem_table_id':      'str',\n    '*oem_rev':           'uint32',\n    '*asl_compiler_id':   'str',\n    '*asl_compiler_rev':  'uint32',\n    '*file':              'str',\n    '*data':              'str' }}\n\n##\n# @CommandLineParameterType:\n#\n# Possible types for an option parameter.\n#\n# @string: accepts a character string\n#\n# @boolean: accepts \"on\" or \"off\"\n#\n# @number: accepts a number\n#\n# @size: accepts a number followed by an optional suffix (K)ilo,\n#        (M)ega, (G)iga, (T)era\n#\n# Since: 1.5\n##\n{ 'enum': 'CommandLineParameterType',\n  'data': ['string', 'boolean', 'number', 'size'] }\n\n##\n# @CommandLineParameterInfo:\n#\n# Details about a single parameter of a command line option.\n#\n# @name: parameter name\n#\n# @type: parameter @CommandLineParameterType\n#\n# @help: human readable text string, not suitable for parsing.\n#\n# @default: default value string (since 2.1)\n#\n# Since: 1.5\n##\n{ 'struct': 'CommandLineParameterInfo',\n  'data': { 'name': 'str',\n            'type': 'CommandLineParameterType',\n            '*help': 'str',\n            '*default': 'str' } }\n\n##\n# @CommandLineOptionInfo:\n#\n# Details about a command line option, including its list of parameter details\n#\n# @option: option name\n#\n# @parameters: an array of @CommandLineParameterInfo\n#\n# Since: 1.5\n##\n{ 'struct': 'CommandLineOptionInfo',\n  'data': { 'option': 'str', 'parameters': ['CommandLineParameterInfo'] } }\n\n##\n# @query-command-line-options:\n#\n# Query command line option schema.\n#\n# @option: option name\n#\n# Returns: list of @CommandLineOptionInfo for all options (or for the given\n#          @option).  Returns an error if the given @option doesn't exist.\n#\n# Since: 1.5\n#\n# Example:\n#\n# -> { \"execute\": \"query-command-line-options\",\n#      \"arguments\": { \"option\": \"option-rom\" } }\n# <- { \"return\": [\n#         {\n#             \"parameters\": [\n#                 {\n#                     \"name\": \"romfile\",\n#                     \"type\": \"string\"\n#                 },\n#                 {\n#                     \"name\": \"bootindex\",\n#                     \"type\": \"number\"\n#                 }\n#             ],\n#             \"option\": \"option-rom\"\n#         }\n#      ]\n#    }\n#\n##\n{'command': 'query-command-line-options', 'data': { '*option': 'str' },\n 'returns': ['CommandLineOptionInfo'] }\n\n##\n# @X86CPURegister32:\n#\n# A X86 32-bit register\n#\n# Since: 1.5\n##\n{ 'enum': 'X86CPURegister32',\n  'data': [ 'EAX', 'EBX', 'ECX', 'EDX', 'ESP', 'EBP', 'ESI', 'EDI' ] }\n\n##\n# @X86CPUFeatureWordInfo:\n#\n# Information about a X86 CPU feature word\n#\n# @cpuid-input-eax: Input EAX value for CPUID instruction for that feature word\n#\n# @cpuid-input-ecx: Input ECX value for CPUID instruction for that\n#                   feature word\n#\n# @cpuid-register: Output register containing the feature bits\n#\n# @features: value of output register, containing the feature bits\n#\n# Since: 1.5\n##\n{ 'struct': 'X86CPUFeatureWordInfo',\n  'data': { 'cpuid-input-eax': 'int',\n            '*cpuid-input-ecx': 'int',\n            'cpuid-register': 'X86CPURegister32',\n            'features': 'int' } }\n\n##\n# @DummyForceArrays:\n#\n# Not used by QMP; hack to let us use X86CPUFeatureWordInfoList internally\n#\n# Since: 2.5\n##\n{ 'struct': 'DummyForceArrays',\n  'data': { 'unused': ['X86CPUFeatureWordInfo'] } }\n\n\n##\n# @RxState:\n#\n# Packets receiving state\n#\n# @normal: filter assigned packets according to the mac-table\n#\n# @none: don't receive any assigned packet\n#\n# @all: receive all assigned packets\n#\n# Since: 1.6\n##\n{ 'enum': 'RxState', 'data': [ 'normal', 'none', 'all' ] }\n\n##\n# @RxFilterInfo:\n#\n# Rx-filter information for a NIC.\n#\n# @name: net client name\n#\n# @promiscuous: whether promiscuous mode is enabled\n#\n# @multicast: multicast receive state\n#\n# @unicast: unicast receive state\n#\n# @vlan: vlan receive state (Since 2.0)\n#\n# @broadcast-allowed: whether to receive broadcast\n#\n# @multicast-overflow: multicast table is overflowed or not\n#\n# @unicast-overflow: unicast table is overflowed or not\n#\n# @main-mac: the main macaddr string\n#\n# @vlan-table: a list of active vlan id\n#\n# @unicast-table: a list of unicast macaddr string\n#\n# @multicast-table: a list of multicast macaddr string\n#\n# Since: 1.6\n##\n{ 'struct': 'RxFilterInfo',\n  'data': {\n    'name':               'str',\n    'promiscuous':        'bool',\n    'multicast':          'RxState',\n    'unicast':            'RxState',\n    'vlan':               'RxState',\n    'broadcast-allowed':  'bool',\n    'multicast-overflow': 'bool',\n    'unicast-overflow':   'bool',\n    'main-mac':           'str',\n    'vlan-table':         ['int'],\n    'unicast-table':      ['str'],\n    'multicast-table':    ['str'] }}\n\n##\n# @query-rx-filter:\n#\n# Return rx-filter information for all NICs (or for the given NIC).\n#\n# @name: net client name\n#\n# Returns: list of @RxFilterInfo for all NICs (or for the given NIC).\n#          Returns an error if the given @name doesn't exist, or given\n#          NIC doesn't support rx-filter querying, or given net client\n#          isn't a NIC.\n#\n# Since: 1.6\n#\n# Example:\n#\n# -> { \"execute\": \"query-rx-filter\", \"arguments\": { \"name\": \"vnet0\" } }\n# <- { \"return\": [\n#         {\n#             \"promiscuous\": true,\n#             \"name\": \"vnet0\",\n#             \"main-mac\": \"52:54:00:12:34:56\",\n#             \"unicast\": \"normal\",\n#             \"vlan\": \"normal\",\n#             \"vlan-table\": [\n#                 4,\n#                 0\n#             ],\n#             \"unicast-table\": [\n#             ],\n#             \"multicast\": \"normal\",\n#             \"multicast-overflow\": false,\n#             \"unicast-overflow\": false,\n#             \"multicast-table\": [\n#                 \"01:00:5e:00:00:01\",\n#                 \"33:33:00:00:00:01\",\n#                 \"33:33:ff:12:34:56\"\n#             ],\n#             \"broadcast-allowed\": false\n#         }\n#       ]\n#    }\n#\n##\n{ 'command': 'query-rx-filter', 'data': { '*name': 'str' },\n  'returns': ['RxFilterInfo'] }\n\n##\n# @InputButton:\n#\n# Button of a pointer input device (mouse, tablet).\n#\n# @side: front side button of a 5-button mouse (since 2.9)\n#\n# @extra: rear side button of a 5-button mouse (since 2.9)\n#\n# Since: 2.0\n##\n{ 'enum'  : 'InputButton',\n  'data'  : [ 'left', 'middle', 'right', 'wheel-up', 'wheel-down', 'side',\n  'extra' ] }\n\n##\n# @InputAxis:\n#\n# Position axis of a pointer input device (mouse, tablet).\n#\n# Since: 2.0\n##\n{ 'enum'  : 'InputAxis',\n  'data'  : [ 'x', 'y' ] }\n\n##\n# @InputKeyEvent:\n#\n# Keyboard input event.\n#\n# @key:    Which key this event is for.\n# @down:   True for key-down and false for key-up events.\n#\n# Since: 2.0\n##\n{ 'struct'  : 'InputKeyEvent',\n  'data'  : { 'key'     : 'KeyValue',\n              'down'    : 'bool' } }\n\n##\n# @InputBtnEvent:\n#\n# Pointer button input event.\n#\n# @button: Which button this event is for.\n# @down:   True for key-down and false for key-up events.\n#\n# Since: 2.0\n##\n{ 'struct'  : 'InputBtnEvent',\n  'data'  : { 'button'  : 'InputButton',\n              'down'    : 'bool' } }\n\n##\n# @InputMoveEvent:\n#\n# Pointer motion input event.\n#\n# @axis:   Which axis is referenced by @value.\n# @value:  Pointer position.  For absolute coordinates the\n#          valid range is 0 -> 0x7ffff\n#\n# Since: 2.0\n##\n{ 'struct'  : 'InputMoveEvent',\n  'data'  : { 'axis'    : 'InputAxis',\n              'value'   : 'int' } }\n\n##\n# @InputEvent:\n#\n# Input event union.\n#\n# @type: the input type, one of:\n#  - 'key': Input event of Keyboard\n#  - 'btn': Input event of pointer buttons\n#  - 'rel': Input event of relative pointer motion\n#  - 'abs': Input event of absolute pointer motion\n#\n# Since: 2.0\n##\n{ 'union' : 'InputEvent',\n  'data'  : { 'key'     : 'InputKeyEvent',\n              'btn'     : 'InputBtnEvent',\n              'rel'     : 'InputMoveEvent',\n              'abs'     : 'InputMoveEvent' } }\n\n##\n# @input-send-event:\n#\n# Send input event(s) to guest.\n#\n# @device: display device to send event(s) to.\n# @head: head to send event(s) to, in case the\n#        display device supports multiple scanouts.\n# @events: List of InputEvent union.\n#\n# Returns: Nothing on success.\n#\n# The @device and @head parameters can be used to send the input event\n# to specific input devices in case (a) multiple input devices of the\n# same kind are added to the virtual machine and (b) you have\n# configured input routing (see docs/multiseat.txt) for those input\n# devices.  The parameters work exactly like the device and head\n# properties of input devices.  If @device is missing, only devices\n# that have no input routing config are admissible.  If @device is\n# specified, both input devices with and without input routing config\n# are admissible, but devices with input routing config take\n# precedence.\n#\n# Since: 2.6\n#\n# Note: The consoles are visible in the qom tree, under\n# /backend/console[$index]. They have a device link and head property,\n# so it is possible to map which console belongs to which device and\n# display.\n#\n# Example:\n#\n# 1. Press left mouse button.\n#\n# -> { \"execute\": \"input-send-event\",\n#     \"arguments\": { \"device\": \"video0\",\n#                    \"events\": [ { \"type\": \"btn\",\n#                    \"data\" : { \"down\": true, \"button\": \"left\" } } ] } }\n# <- { \"return\": {} }\n#\n# -> { \"execute\": \"input-send-event\",\n#     \"arguments\": { \"device\": \"video0\",\n#                    \"events\": [ { \"type\": \"btn\",\n#                    \"data\" : { \"down\": false, \"button\": \"left\" } } ] } }\n# <- { \"return\": {} }\n#\n# 2. Press ctrl-alt-del.\n#\n# -> { \"execute\": \"input-send-event\",\n#      \"arguments\": { \"events\": [\n#         { \"type\": \"key\", \"data\" : { \"down\": true,\n#           \"key\": {\"type\": \"qcode\", \"data\": \"ctrl\" } } },\n#         { \"type\": \"key\", \"data\" : { \"down\": true,\n#           \"key\": {\"type\": \"qcode\", \"data\": \"alt\" } } },\n#         { \"type\": \"key\", \"data\" : { \"down\": true,\n#           \"key\": {\"type\": \"qcode\", \"data\": \"delete\" } } } ] } }\n# <- { \"return\": {} }\n#\n# 3. Move mouse pointer to absolute coordinates (20000, 400).\n#\n# -> { \"execute\": \"input-send-event\" ,\n#   \"arguments\": { \"events\": [\n#                { \"type\": \"abs\", \"data\" : { \"axis\": \"x\", \"value\" : 20000 } },\n#                { \"type\": \"abs\", \"data\" : { \"axis\": \"y\", \"value\" : 400 } } ] } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'input-send-event',\n  'data': { '*device': 'str',\n            '*head'  : 'int',\n            'events' : [ 'InputEvent' ] } }\n\n##\n# @NumaOptionsType:\n#\n# Since: 2.1\n##\n{ 'enum': 'NumaOptionsType',\n  'data': [ 'node' ] }\n\n##\n# @NumaOptions:\n#\n# A discriminated record of NUMA options. (for OptsVisitor)\n#\n# Since: 2.1\n##\n{ 'union': 'NumaOptions',\n  'base': { 'type': 'NumaOptionsType' },\n  'discriminator': 'type',\n  'data': {\n    'node': 'NumaNodeOptions' }}\n\n##\n# @NumaNodeOptions:\n#\n# Create a guest NUMA node. (for OptsVisitor)\n#\n# @nodeid: NUMA node ID (increase by 1 from 0 if omitted)\n#\n# @cpus: VCPUs belonging to this node (assign VCPUS round-robin\n#         if omitted)\n#\n# @mem: memory size of this node; mutually exclusive with @memdev.\n#       Equally divide total memory among nodes if both @mem and @memdev are\n#       omitted.\n#\n# @memdev: memory backend object.  If specified for one node,\n#          it must be specified for all nodes.\n#\n# Since: 2.1\n##\n{ 'struct': 'NumaNodeOptions',\n  'data': {\n   '*nodeid': 'uint16',\n   '*cpus':   ['uint16'],\n   '*mem':    'size',\n   '*memdev': 'str' }}\n\n##\n# @HostMemPolicy:\n#\n# Host memory policy types\n#\n# @default: restore default policy, remove any nondefault policy\n#\n# @preferred: set the preferred host nodes for allocation\n#\n# @bind: a strict policy that restricts memory allocation to the\n#        host nodes specified\n#\n# @interleave: memory allocations are interleaved across the set\n#              of host nodes specified\n#\n# Since: 2.1\n##\n{ 'enum': 'HostMemPolicy',\n  'data': [ 'default', 'preferred', 'bind', 'interleave' ] }\n\n##\n# @Memdev:\n#\n# Information about memory backend\n#\n# @id: backend's ID if backend has 'id' property (since 2.9)\n#\n# @size: memory backend size\n#\n# @merge: enables or disables memory merge support\n#\n# @dump: includes memory backend's memory in a core dump or not\n#\n# @prealloc: enables or disables memory preallocation\n#\n# @host-nodes: host nodes for its memory policy\n#\n# @policy: memory policy of memory backend\n#\n# Since: 2.1\n##\n{ 'struct': 'Memdev',\n  'data': {\n    '*id':        'str',\n    'size':       'size',\n    'merge':      'bool',\n    'dump':       'bool',\n    'prealloc':   'bool',\n    'host-nodes': ['uint16'],\n    'policy':     'HostMemPolicy' }}\n\n##\n# @query-memdev:\n#\n# Returns information for all memory backends.\n#\n# Returns: a list of @Memdev.\n#\n# Since: 2.1\n#\n# Example:\n#\n# -> { \"execute\": \"query-memdev\" }\n# <- { \"return\": [\n#        {\n#          \"id\": \"mem1\",\n#          \"size\": 536870912,\n#          \"merge\": false,\n#          \"dump\": true,\n#          \"prealloc\": false,\n#          \"host-nodes\": [0, 1],\n#          \"policy\": \"bind\"\n#        },\n#        {\n#          \"size\": 536870912,\n#          \"merge\": false,\n#          \"dump\": true,\n#          \"prealloc\": true,\n#          \"host-nodes\": [2, 3],\n#          \"policy\": \"preferred\"\n#        }\n#      ]\n#    }\n#\n##\n{ 'command': 'query-memdev', 'returns': ['Memdev'] }\n\n##\n# @PCDIMMDeviceInfo:\n#\n# PCDIMMDevice state information\n#\n# @id: device's ID\n#\n# @addr: physical address, where device is mapped\n#\n# @size: size of memory that the device provides\n#\n# @slot: slot number at which device is plugged in\n#\n# @node: NUMA node number where device is plugged in\n#\n# @memdev: memory backend linked with device\n#\n# @hotplugged: true if device was hotplugged\n#\n# @hotpluggable: true if device if could be added/removed while machine is running\n#\n# Since: 2.1\n##\n{ 'struct': 'PCDIMMDeviceInfo',\n  'data': { '*id': 'str',\n            'addr': 'int',\n            'size': 'int',\n            'slot': 'int',\n            'node': 'int',\n            'memdev': 'str',\n            'hotplugged': 'bool',\n            'hotpluggable': 'bool'\n          }\n}\n\n##\n# @MemoryDeviceInfo:\n#\n# Union containing information about a memory device\n#\n# Since: 2.1\n##\n{ 'union': 'MemoryDeviceInfo', 'data': {'dimm': 'PCDIMMDeviceInfo'} }\n\n##\n# @query-memory-devices:\n#\n# Lists available memory devices and their state\n#\n# Since: 2.1\n#\n# Example:\n#\n# -> { \"execute\": \"query-memory-devices\" }\n# <- { \"return\": [ { \"data\":\n#                       { \"addr\": 5368709120,\n#                         \"hotpluggable\": true,\n#                         \"hotplugged\": true,\n#                         \"id\": \"d1\",\n#                         \"memdev\": \"/objects/memX\",\n#                         \"node\": 0,\n#                         \"size\": 1073741824,\n#                         \"slot\": 0},\n#                    \"type\": \"dimm\"\n#                  } ] }\n#\n##\n{ 'command': 'query-memory-devices', 'returns': ['MemoryDeviceInfo'] }\n\n##\n# @ACPISlotType:\n#\n# @DIMM: memory slot\n# @CPU: logical CPU slot (since 2.7)\n##\n{ 'enum': 'ACPISlotType', 'data': [ 'DIMM', 'CPU' ] }\n\n##\n# @ACPIOSTInfo:\n#\n# OSPM Status Indication for a device\n# For description of possible values of @source and @status fields\n# see \"_OST (OSPM Status Indication)\" chapter of ACPI5.0 spec.\n#\n# @device: device ID associated with slot\n#\n# @slot: slot ID, unique per slot of a given @slot-type\n#\n# @slot-type: type of the slot\n#\n# @source: an integer containing the source event\n#\n# @status: an integer containing the status code\n#\n# Since: 2.1\n##\n{ 'struct': 'ACPIOSTInfo',\n  'data'  : { '*device': 'str',\n              'slot': 'str',\n              'slot-type': 'ACPISlotType',\n              'source': 'int',\n              'status': 'int' } }\n\n##\n# @query-acpi-ospm-status:\n#\n# Return a list of ACPIOSTInfo for devices that support status\n# reporting via ACPI _OST method.\n#\n# Since: 2.1\n#\n# Example:\n#\n# -> { \"execute\": \"query-acpi-ospm-status\" }\n# <- { \"return\": [ { \"device\": \"d1\", \"slot\": \"0\", \"slot-type\": \"DIMM\", \"source\": 1, \"status\": 0},\n#                  { \"slot\": \"1\", \"slot-type\": \"DIMM\", \"source\": 0, \"status\": 0},\n#                  { \"slot\": \"2\", \"slot-type\": \"DIMM\", \"source\": 0, \"status\": 0},\n#                  { \"slot\": \"3\", \"slot-type\": \"DIMM\", \"source\": 0, \"status\": 0}\n#    ]}\n#\n##\n{ 'command': 'query-acpi-ospm-status', 'returns': ['ACPIOSTInfo'] }\n\n##\n# @WatchdogExpirationAction:\n#\n# An enumeration of the actions taken when the watchdog device's timer is\n# expired\n#\n# @reset: system resets\n#\n# @shutdown: system shutdown, note that it is similar to @powerdown, which\n#            tries to set to system status and notify guest\n#\n# @poweroff: system poweroff, the emulator program exits\n#\n# @pause: system pauses, similar to @stop\n#\n# @debug: system enters debug state\n#\n# @none: nothing is done\n#\n# @inject-nmi: a non-maskable interrupt is injected into the first VCPU (all\n#              VCPUS on x86) (since 2.4)\n#\n# Since: 2.1\n##\n{ 'enum': 'WatchdogExpirationAction',\n  'data': [ 'reset', 'shutdown', 'poweroff', 'pause', 'debug', 'none',\n            'inject-nmi' ] }\n\n##\n# @IoOperationType:\n#\n# An enumeration of the I/O operation types\n#\n# @read: read operation\n#\n# @write: write operation\n#\n# Since: 2.1\n##\n{ 'enum': 'IoOperationType',\n  'data': [ 'read', 'write' ] }\n\n##\n# @GuestPanicAction:\n#\n# An enumeration of the actions taken when guest OS panic is detected\n#\n# @pause: system pauses\n#\n# Since: 2.1 (poweroff since 2.8)\n##\n{ 'enum': 'GuestPanicAction',\n  'data': [ 'pause', 'poweroff' ] }\n\n##\n# @GuestPanicInformationType:\n#\n# An enumeration of the guest panic information types\n#\n# Since: 2.9\n##\n{ 'enum': 'GuestPanicInformationType',\n  'data': [ 'hyper-v'] }\n\n##\n# @GuestPanicInformation:\n#\n# Information about a guest panic\n#\n# Since: 2.9\n##\n{'union': 'GuestPanicInformation',\n 'base': {'type': 'GuestPanicInformationType'},\n 'discriminator': 'type',\n 'data': { 'hyper-v': 'GuestPanicInformationHyperV' } }\n\n##\n# @GuestPanicInformationHyperV:\n#\n# Hyper-V specific guest panic information (HV crash MSRs)\n#\n# Since: 2.9\n##\n{'struct': 'GuestPanicInformationHyperV',\n 'data': { 'arg1': 'uint64',\n           'arg2': 'uint64',\n           'arg3': 'uint64',\n           'arg4': 'uint64',\n           'arg5': 'uint64' } }\n\n##\n# @rtc-reset-reinjection:\n#\n# This command will reset the RTC interrupt reinjection backlog.\n# Can be used if another mechanism to synchronize guest time\n# is in effect, for example QEMU guest agent's guest-set-time\n# command.\n#\n# Since: 2.1\n#\n# Example:\n#\n# -> { \"execute\": \"rtc-reset-reinjection\" }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'rtc-reset-reinjection' }\n\n# Rocker ethernet network switch\n{ 'include': 'qapi/rocker.json' }\n\n##\n# @ReplayMode:\n#\n# Mode of the replay subsystem.\n#\n# @none: normal execution mode. Replay or record are not enabled.\n#\n# @record: record mode. All non-deterministic data is written into the\n#          replay log.\n#\n# @play: replay mode. Non-deterministic data required for system execution\n#        is read from the log.\n#\n# Since: 2.5\n##\n{ 'enum': 'ReplayMode',\n  'data': [ 'none', 'record', 'play' ] }\n\n##\n# @xen-load-devices-state:\n#\n# Load the state of all devices from file. The RAM and the block devices\n# of the VM are not loaded by this command.\n#\n# @filename: the file to load the state of the devices from as binary\n# data. See xen-save-devices-state.txt for a description of the binary\n# format.\n#\n# Since: 2.7\n#\n# Example:\n#\n# -> { \"execute\": \"xen-load-devices-state\",\n#      \"arguments\": { \"filename\": \"/tmp/resume\" } }\n# <- { \"return\": {} }\n#\n##\n{ 'command': 'xen-load-devices-state', 'data': {'filename': 'str'} }\n\n##\n# @xen-set-replication:\n#\n# Enable or disable replication.\n#\n# @enable: true to enable, false to disable.\n#\n# @primary: true for primary or false for secondary.\n#\n# @failover: true to do failover, false to stop. but cannot be\n#            specified if 'enable' is true. default value is false.\n#\n# Returns: nothing.\n#\n# Example:\n#\n# -> { \"execute\": \"xen-set-replication\",\n#      \"arguments\": {\"enable\": true, \"primary\": false} }\n# <- { \"return\": {} }\n#\n# Since: 2.9\n##\n{ 'command': 'xen-set-replication',\n  'data': { 'enable': 'bool', 'primary': 'bool', '*failover' : 'bool' } }\n\n##\n# @ReplicationStatus:\n#\n# The result format for 'query-xen-replication-status'.\n#\n# @error: true if an error happened, false if replication is normal.\n#\n# @desc: the human readable error description string, when\n#        @error is 'true'.\n#\n# Since: 2.9\n##\n{ 'struct': 'ReplicationStatus',\n  'data': { 'error': 'bool', '*desc': 'str' } }\n\n##\n# @query-xen-replication-status:\n#\n# Query replication status while the vm is running.\n#\n# Returns: A @ReplicationResult object showing the status.\n#\n# Example:\n#\n# -> { \"execute\": \"query-xen-replication-status\" }\n# <- { \"return\": { \"error\": false } }\n#\n# Since: 2.9\n##\n{ 'command': 'query-xen-replication-status',\n  'returns': 'ReplicationStatus' }\n\n##\n# @xen-colo-do-checkpoint:\n#\n# Xen uses this command to notify replication to trigger a checkpoint.\n#\n# Returns: nothing.\n#\n# Example:\n#\n# -> { \"execute\": \"xen-colo-do-checkpoint\" }\n# <- { \"return\": {} }\n#\n# Since: 2.9\n##\n{ 'command': 'xen-colo-do-checkpoint' }\n\n##\n# @GICCapability:\n#\n# The struct describes capability for a specific GIC (Generic\n# Interrupt Controller) version. These bits are not only decided by\n# QEMU/KVM software version, but also decided by the hardware that\n# the program is running upon.\n#\n# @version:  version of GIC to be described. Currently, only 2 and 3\n#            are supported.\n#\n# @emulated: whether current QEMU/hardware supports emulated GIC\n#            device in user space.\n#\n# @kernel:   whether current QEMU/hardware supports hardware\n#            accelerated GIC device in kernel.\n#\n# Since: 2.6\n##\n{ 'struct': 'GICCapability',\n  'data': { 'version': 'int',\n            'emulated': 'bool',\n            'kernel': 'bool' } }\n\n##\n# @query-gic-capabilities:\n#\n# This command is ARM-only. It will return a list of GICCapability\n# objects that describe its capability bits.\n#\n# Returns: a list of GICCapability objects.\n#\n# Since: 2.6\n#\n# Example:\n#\n# -> { \"execute\": \"query-gic-capabilities\" }\n# <- { \"return\": [{ \"version\": 2, \"emulated\": true, \"kernel\": false },\n#                 { \"version\": 3, \"emulated\": false, \"kernel\": true } ] }\n#\n##\n{ 'command': 'query-gic-capabilities', 'returns': ['GICCapability'] }\n\n##\n# @CpuInstanceProperties:\n#\n# List of properties to be used for hotplugging a CPU instance,\n# it should be passed by management with device_add command when\n# a CPU is being hotplugged.\n#\n# @node-id: NUMA node ID the CPU belongs to\n# @socket-id: socket number within node/board the CPU belongs to\n# @core-id: core number within socket the CPU belongs to\n# @thread-id: thread number within core the CPU belongs to\n#\n# Note: currently there are 4 properties that could be present\n# but management should be prepared to pass through other\n# properties with device_add command to allow for future\n# interface extension. This also requires the filed names to be kept in\n# sync with the properties passed to -device/device_add.\n#\n# Since: 2.7\n##\n{ 'struct': 'CpuInstanceProperties',\n  'data': { '*node-id': 'int',\n            '*socket-id': 'int',\n            '*core-id': 'int',\n            '*thread-id': 'int'\n  }\n}\n\n##\n# @HotpluggableCPU:\n#\n# @type: CPU object type for usage with device_add command\n# @props: list of properties to be used for hotplugging CPU\n# @vcpus-count: number of logical VCPU threads @HotpluggableCPU provides\n# @qom-path: link to existing CPU object if CPU is present or\n#            omitted if CPU is not present.\n#\n# Since: 2.7\n##\n{ 'struct': 'HotpluggableCPU',\n  'data': { 'type': 'str',\n            'vcpus-count': 'int',\n            'props': 'CpuInstanceProperties',\n            '*qom-path': 'str'\n          }\n}\n\n##\n# @query-hotpluggable-cpus:\n#\n# Returns: a list of HotpluggableCPU objects.\n#\n# Since: 2.7\n#\n# Example:\n#\n# For pseries machine type started with -smp 2,cores=2,maxcpus=4 -cpu POWER8:\n#\n# -> { \"execute\": \"query-hotpluggable-cpus\" }\n# <- {\"return\": [\n#      { \"props\": { \"core\": 8 }, \"type\": \"POWER8-spapr-cpu-core\",\n#        \"vcpus-count\": 1 },\n#      { \"props\": { \"core\": 0 }, \"type\": \"POWER8-spapr-cpu-core\",\n#        \"vcpus-count\": 1, \"qom-path\": \"/machine/unattached/device[0]\"}\n#    ]}'\n#\n# For pc machine type started with -smp 1,maxcpus=2:\n#\n# -> { \"execute\": \"query-hotpluggable-cpus\" }\n# <- {\"return\": [\n#      {\n#         \"type\": \"qemu64-x86_64-cpu\", \"vcpus-count\": 1,\n#         \"props\": {\"core-id\": 0, \"socket-id\": 1, \"thread-id\": 0}\n#      },\n#      {\n#         \"qom-path\": \"/machine/unattached/device[0]\",\n#         \"type\": \"qemu64-x86_64-cpu\", \"vcpus-count\": 1,\n#         \"props\": {\"core-id\": 0, \"socket-id\": 0, \"thread-id\": 0}\n#      }\n#    ]}\n#\n##\n{ 'command': 'query-hotpluggable-cpus', 'returns': ['HotpluggableCPU'] }\n\n##\n# @GuidInfo:\n#\n# GUID information.\n#\n# @guid: the globally unique identifier\n#\n# Since: 2.9\n##\n{ 'struct': 'GuidInfo', 'data': {'guid': 'str'} }\n\n##\n# @query-vm-generation-id:\n#\n# Show Virtual Machine Generation ID\n#\n# Since 2.9\n##\n{ 'command': 'query-vm-generation-id', 'returns': 'GuidInfo' }\n\n##\n# @begin_record:\n#\n# Requests that we begin recording for later replay\n# \n# TRL 20120501\n##\n{ 'command': 'begin_record', 'data': { 'file_name': 'str' } }\n\n##\n# @begin_record_from:\n#\n# Requests that we revert to a snapshot and begin recording for later replay\n#\n##\n{ 'command': 'begin_record_from', 'data': { 'snapshot': 'str', 'file_name': 'str' } }\n\n##\n# @end_record:\n#\n# Requests that we begin recording for later replay\n# \n# TRL 20120501\n##\n{ 'command': 'end_record' }\n\n##\n# @begin_replay:\n#\n# Requests that we begin replaying\n# \n# TRL 20120501\n##\n{ 'command': 'begin_replay', 'data': { 'file_name': 'str' } }\n\n##\n# @end_replay:\n#\n# Requests that we end replaying \n# \n# TRL 20120501\n##\n{ 'command': 'end_replay' } \n\n##\n# @load_plugin:\n#\n# Loads a PANDA plugin\n# \n# BDG 20120821\n##\n{ 'command': 'load_plugin', 'data': { '*file_name': 'str', 'plugin_name': 'str',\n                                      '*plugin_args': 'str'} }\n\n##\n# @unload_plugin:\n#\n# Unloads a PANDA plugin\n# \n# BDG 20120821\n##\n{ 'command': 'unload_plugin', 'data': { 'index': 'int' } }\n\n\n##\n# @PandaPluginInfo:\n#\n# Structure holding the information of a PANDA plugin\n##\n{ 'struct': 'PandaPluginInfo', 'data': {'index': 'int', 'name': 'str', 'address': 'int'} }\n\n##\n# @list_plugins:\n#\n# List loaded PANDA plugins\n# \n# BDG 20120821\n##\n{ 'command': 'list_plugins', 'returns': ['PandaPluginInfo']}\n\n##\n# @plugin_cmd:\n#\n# Send a command to a loaded PANDA plugin\n# \n# BDG 20120822\n##\n{ 'command': 'plugin_cmd', 'data': { 'cmd': 'str' } }\n"
        },
        {
          "name": "qapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "qdev-monitor.c",
          "type": "blob",
          "size": 25.1953125,
          "content": "/*\n *  Dynamic device configuration and creation.\n *\n *  Copyright (c) 2009 CodeSourcery\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"hw/qdev.h\"\n#include \"hw/sysbus.h\"\n#include \"monitor/monitor.h\"\n#include \"monitor/qdev.h\"\n#include \"qmp-commands.h\"\n#include \"sysemu/arch_init.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/help_option.h\"\n#include \"sysemu/block-backend.h\"\n\n/*\n * Aliases were a bad idea from the start.  Let's keep them\n * from spreading further.\n */\ntypedef struct QDevAlias\n{\n    const char *typename;\n    const char *alias;\n    uint32_t arch_mask;\n} QDevAlias;\n\n/* Please keep this table sorted by typename. */\nstatic const QDevAlias qdev_alias_table[] = {\n    { \"e1000\", \"e1000-82540em\" },\n    { \"ich9-ahci\", \"ahci\" },\n    { \"kvm-pci-assign\", \"pci-assign\" },\n    { \"lsi53c895a\", \"lsi\" },\n    { \"virtio-9p-ccw\", \"virtio-9p\", QEMU_ARCH_S390X },\n    { \"virtio-9p-pci\", \"virtio-9p\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-balloon-ccw\", \"virtio-balloon\", QEMU_ARCH_S390X },\n    { \"virtio-balloon-pci\", \"virtio-balloon\",\n            QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-blk-ccw\", \"virtio-blk\", QEMU_ARCH_S390X },\n    { \"virtio-blk-pci\", \"virtio-blk\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-gpu-ccw\", \"virtio-gpu\", QEMU_ARCH_S390X },\n    { \"virtio-gpu-pci\", \"virtio-gpu\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-input-host-ccw\", \"virtio-input-host\", QEMU_ARCH_S390X },\n    { \"virtio-input-host-pci\", \"virtio-input-host\",\n            QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-keyboard-ccw\", \"virtio-keyboard\", QEMU_ARCH_S390X },\n    { \"virtio-keyboard-pci\", \"virtio-keyboard\",\n            QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-mouse-ccw\", \"virtio-mouse\", QEMU_ARCH_S390X },\n    { \"virtio-mouse-pci\", \"virtio-mouse\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-net-ccw\", \"virtio-net\", QEMU_ARCH_S390X },\n    { \"virtio-net-pci\", \"virtio-net\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-rng-ccw\", \"virtio-rng\", QEMU_ARCH_S390X },\n    { \"virtio-rng-pci\", \"virtio-rng\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-scsi-ccw\", \"virtio-scsi\", QEMU_ARCH_S390X },\n    { \"virtio-scsi-pci\", \"virtio-scsi\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-serial-ccw\", \"virtio-serial\", QEMU_ARCH_S390X },\n    { \"virtio-serial-pci\", \"virtio-serial\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { \"virtio-tablet-ccw\", \"virtio-tablet\", QEMU_ARCH_S390X },\n    { \"virtio-tablet-pci\", \"virtio-tablet\", QEMU_ARCH_ALL & ~QEMU_ARCH_S390X },\n    { }\n};\n\nstatic const char *qdev_class_get_alias(DeviceClass *dc)\n{\n    const char *typename = object_class_get_name(OBJECT_CLASS(dc));\n    int i;\n\n    for (i = 0; qdev_alias_table[i].typename; i++) {\n        if (qdev_alias_table[i].arch_mask &&\n            !(qdev_alias_table[i].arch_mask & arch_type)) {\n            continue;\n        }\n\n        if (strcmp(qdev_alias_table[i].typename, typename) == 0) {\n            return qdev_alias_table[i].alias;\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool qdev_class_has_alias(DeviceClass *dc)\n{\n    return (qdev_class_get_alias(dc) != NULL);\n}\n\nstatic void qdev_print_devinfo(DeviceClass *dc)\n{\n    error_printf(\"name \\\"%s\\\"\", object_class_get_name(OBJECT_CLASS(dc)));\n    if (dc->bus_type) {\n        error_printf(\", bus %s\", dc->bus_type);\n    }\n    if (qdev_class_has_alias(dc)) {\n        error_printf(\", alias \\\"%s\\\"\", qdev_class_get_alias(dc));\n    }\n    if (dc->desc) {\n        error_printf(\", desc \\\"%s\\\"\", dc->desc);\n    }\n    if (!dc->user_creatable) {\n        error_printf(\", no-user\");\n    }\n    error_printf(\"\\n\");\n}\n\nstatic gint devinfo_cmp(gconstpointer a, gconstpointer b)\n{\n    return strcasecmp(object_class_get_name((ObjectClass *)a),\n                      object_class_get_name((ObjectClass *)b));\n}\n\nstatic void qdev_print_devinfos(bool show_no_user)\n{\n    static const char *cat_name[DEVICE_CATEGORY_MAX + 1] = {\n        [DEVICE_CATEGORY_BRIDGE]  = \"Controller/Bridge/Hub\",\n        [DEVICE_CATEGORY_USB]     = \"USB\",\n        [DEVICE_CATEGORY_STORAGE] = \"Storage\",\n        [DEVICE_CATEGORY_NETWORK] = \"Network\",\n        [DEVICE_CATEGORY_INPUT]   = \"Input\",\n        [DEVICE_CATEGORY_DISPLAY] = \"Display\",\n        [DEVICE_CATEGORY_SOUND]   = \"Sound\",\n        [DEVICE_CATEGORY_MISC]    = \"Misc\",\n        [DEVICE_CATEGORY_CPU]     = \"CPU\",\n        [DEVICE_CATEGORY_MAX]     = \"Uncategorized\",\n    };\n    GSList *list, *elt;\n    int i;\n    bool cat_printed;\n\n    list = g_slist_sort(object_class_get_list(TYPE_DEVICE, false),\n                        devinfo_cmp);\n\n    for (i = 0; i <= DEVICE_CATEGORY_MAX; i++) {\n        cat_printed = false;\n        for (elt = list; elt; elt = elt->next) {\n            DeviceClass *dc = OBJECT_CLASS_CHECK(DeviceClass, elt->data,\n                                                 TYPE_DEVICE);\n            if ((i < DEVICE_CATEGORY_MAX\n                 ? !test_bit(i, dc->categories)\n                 : !bitmap_empty(dc->categories, DEVICE_CATEGORY_MAX))\n                || (!show_no_user\n                    && !dc->user_creatable)) {\n                continue;\n            }\n            if (!cat_printed) {\n                error_printf(\"%s%s devices:\\n\", i ? \"\\n\" : \"\",\n                             cat_name[i]);\n                cat_printed = true;\n            }\n            qdev_print_devinfo(dc);\n        }\n    }\n\n    g_slist_free(list);\n}\n\nstatic int set_property(void *opaque, const char *name, const char *value,\n                        Error **errp)\n{\n    Object *obj = opaque;\n    Error *err = NULL;\n\n    if (strcmp(name, \"driver\") == 0)\n        return 0;\n    if (strcmp(name, \"bus\") == 0)\n        return 0;\n\n    object_property_parse(obj, value, name, &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        return -1;\n    }\n    return 0;\n}\n\nstatic const char *find_typename_by_alias(const char *alias)\n{\n    int i;\n\n    for (i = 0; qdev_alias_table[i].alias; i++) {\n        if (qdev_alias_table[i].arch_mask &&\n            !(qdev_alias_table[i].arch_mask & arch_type)) {\n            continue;\n        }\n\n        if (strcmp(qdev_alias_table[i].alias, alias) == 0) {\n            return qdev_alias_table[i].typename;\n        }\n    }\n\n    return NULL;\n}\n\nstatic DeviceClass *qdev_get_device_class(const char **driver, Error **errp)\n{\n    ObjectClass *oc;\n    DeviceClass *dc;\n    const char *original_name = *driver;\n\n    oc = object_class_by_name(*driver);\n    if (!oc) {\n        const char *typename = find_typename_by_alias(*driver);\n\n        if (typename) {\n            *driver = typename;\n            oc = object_class_by_name(*driver);\n        }\n    }\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n        if (*driver != original_name) {\n            error_setg(errp, \"'%s' (alias '%s') is not a valid device model\"\n                       \" name\", original_name, *driver);\n        } else {\n            error_setg(errp, \"'%s' is not a valid device model name\", *driver);\n        }\n        return NULL;\n    }\n\n    if (object_class_is_abstract(oc)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"driver\",\n                   \"non-abstract device type\");\n        return NULL;\n    }\n\n    dc = DEVICE_CLASS(oc);\n    if (!dc->user_creatable ||\n        (qdev_hotplug && !dc->hotpluggable)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"driver\",\n                   \"pluggable device type\");\n        return NULL;\n    }\n\n    return dc;\n}\n\n\nint qdev_device_help(QemuOpts *opts)\n{\n    Error *local_err = NULL;\n    const char *driver;\n    DevicePropertyInfoList *prop_list;\n    DevicePropertyInfoList *prop;\n\n    driver = qemu_opt_get(opts, \"driver\");\n    if (driver && is_help_option(driver)) {\n        qdev_print_devinfos(false);\n        return 1;\n    }\n\n    if (!driver || !qemu_opt_has_help_opt(opts)) {\n        return 0;\n    }\n\n    if (!object_class_by_name(driver)) {\n        const char *typename = find_typename_by_alias(driver);\n\n        if (typename) {\n            driver = typename;\n        }\n    }\n\n    prop_list = qmp_device_list_properties(driver, &local_err);\n    if (local_err) {\n        goto error;\n    }\n\n    for (prop = prop_list; prop; prop = prop->next) {\n        error_printf(\"%s.%s=%s\", driver,\n                     prop->value->name,\n                     prop->value->type);\n        if (prop->value->has_description) {\n            error_printf(\" (%s)\\n\", prop->value->description);\n        } else {\n            error_printf(\"\\n\");\n        }\n    }\n\n    qapi_free_DevicePropertyInfoList(prop_list);\n    return 1;\n\nerror:\n    error_report_err(local_err);\n    return 1;\n}\n\nstatic Object *qdev_get_peripheral(void)\n{\n    static Object *dev;\n\n    if (dev == NULL) {\n        dev = container_get(qdev_get_machine(), \"/peripheral\");\n    }\n\n    return dev;\n}\n\nstatic Object *qdev_get_peripheral_anon(void)\n{\n    static Object *dev;\n\n    if (dev == NULL) {\n        dev = container_get(qdev_get_machine(), \"/peripheral-anon\");\n    }\n\n    return dev;\n}\n\nstatic void qbus_list_bus(DeviceState *dev, Error **errp)\n{\n    BusState *child;\n    const char *sep = \" \";\n\n    error_append_hint(errp, \"child buses at \\\"%s\\\":\",\n                      dev->id ? dev->id : object_get_typename(OBJECT(dev)));\n    QLIST_FOREACH(child, &dev->child_bus, sibling) {\n        error_append_hint(errp, \"%s\\\"%s\\\"\", sep, child->name);\n        sep = \", \";\n    }\n    error_append_hint(errp, \"\\n\");\n}\n\nstatic void qbus_list_dev(BusState *bus, Error **errp)\n{\n    BusChild *kid;\n    const char *sep = \" \";\n\n    error_append_hint(errp, \"devices at \\\"%s\\\":\", bus->name);\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        error_append_hint(errp, \"%s\\\"%s\\\"\", sep,\n                          object_get_typename(OBJECT(dev)));\n        if (dev->id) {\n            error_append_hint(errp, \"/\\\"%s\\\"\", dev->id);\n        }\n        sep = \", \";\n    }\n    error_append_hint(errp, \"\\n\");\n}\n\nstatic BusState *qbus_find_bus(DeviceState *dev, char *elem)\n{\n    BusState *child;\n\n    QLIST_FOREACH(child, &dev->child_bus, sibling) {\n        if (strcmp(child->name, elem) == 0) {\n            return child;\n        }\n    }\n    return NULL;\n}\n\nstatic DeviceState *qbus_find_dev(BusState *bus, char *elem)\n{\n    BusChild *kid;\n\n    /*\n     * try to match in order:\n     *   (1) instance id, if present\n     *   (2) driver name\n     *   (3) driver alias, if present\n     */\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        if (dev->id  &&  strcmp(dev->id, elem) == 0) {\n            return dev;\n        }\n    }\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        if (strcmp(object_get_typename(OBJECT(dev)), elem) == 0) {\n            return dev;\n        }\n    }\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n        if (qdev_class_has_alias(dc) &&\n            strcmp(qdev_class_get_alias(dc), elem) == 0) {\n            return dev;\n        }\n    }\n    return NULL;\n}\n\nstatic inline bool qbus_is_full(BusState *bus)\n{\n    BusClass *bus_class = BUS_GET_CLASS(bus);\n    return bus_class->max_dev && bus->max_index >= bus_class->max_dev;\n}\n\n/*\n * Search the tree rooted at @bus for a bus.\n * If @name, search for a bus with that name.  Note that bus names\n * need not be unique.  Yes, that's screwed up.\n * Else search for a bus that is a subtype of @bus_typename.\n * If more than one exists, prefer one that can take another device.\n * Return the bus if found, else %NULL.\n */\nstatic BusState *qbus_find_recursive(BusState *bus, const char *name,\n                                     const char *bus_typename)\n{\n    BusChild *kid;\n    BusState *pick, *child, *ret;\n    bool match;\n\n    assert(name || bus_typename);\n    if (name) {\n        match = !strcmp(bus->name, name);\n    } else {\n        match = !!object_dynamic_cast(OBJECT(bus), bus_typename);\n    }\n\n    if (match && !qbus_is_full(bus)) {\n        return bus;             /* root matches and isn't full */\n    }\n\n    pick = match ? bus : NULL;\n\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        QLIST_FOREACH(child, &dev->child_bus, sibling) {\n            ret = qbus_find_recursive(child, name, bus_typename);\n            if (ret && !qbus_is_full(ret)) {\n                return ret;     /* a descendant matches and isn't full */\n            }\n            if (ret && !pick) {\n                pick = ret;\n            }\n        }\n    }\n\n    /* root or a descendant matches, but is full */\n    return pick;\n}\n\nstatic BusState *qbus_find(const char *path, Error **errp)\n{\n    DeviceState *dev;\n    BusState *bus;\n    char elem[128];\n    int pos, len;\n\n    /* find start element */\n    if (path[0] == '/') {\n        bus = sysbus_get_default();\n        pos = 0;\n    } else {\n        if (sscanf(path, \"%127[^/]%n\", elem, &len) != 1) {\n            assert(!path[0]);\n            elem[0] = len = 0;\n        }\n        bus = qbus_find_recursive(sysbus_get_default(), elem, NULL);\n        if (!bus) {\n            error_setg(errp, \"Bus '%s' not found\", elem);\n            return NULL;\n        }\n        pos = len;\n    }\n\n    for (;;) {\n        assert(path[pos] == '/' || !path[pos]);\n        while (path[pos] == '/') {\n            pos++;\n        }\n        if (path[pos] == '\\0') {\n            break;\n        }\n\n        /* find device */\n        if (sscanf(path+pos, \"%127[^/]%n\", elem, &len) != 1) {\n            g_assert_not_reached();\n            elem[0] = len = 0;\n        }\n        pos += len;\n        dev = qbus_find_dev(bus, elem);\n        if (!dev) {\n            error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                      \"Device '%s' not found\", elem);\n            qbus_list_dev(bus, errp);\n            return NULL;\n        }\n\n        assert(path[pos] == '/' || !path[pos]);\n        while (path[pos] == '/') {\n            pos++;\n        }\n        if (path[pos] == '\\0') {\n            /* last specified element is a device.  If it has exactly\n             * one child bus accept it nevertheless */\n            if (dev->num_child_bus == 1) {\n                bus = QLIST_FIRST(&dev->child_bus);\n                break;\n            }\n            if (dev->num_child_bus) {\n                error_setg(errp, \"Device '%s' has multiple child buses\",\n                           elem);\n                qbus_list_bus(dev, errp);\n            } else {\n                error_setg(errp, \"Device '%s' has no child bus\", elem);\n            }\n            return NULL;\n        }\n\n        /* find bus */\n        if (sscanf(path+pos, \"%127[^/]%n\", elem, &len) != 1) {\n            g_assert_not_reached();\n            elem[0] = len = 0;\n        }\n        pos += len;\n        bus = qbus_find_bus(dev, elem);\n        if (!bus) {\n            error_setg(errp, \"Bus '%s' not found\", elem);\n            qbus_list_bus(dev, errp);\n            return NULL;\n        }\n    }\n\n    if (qbus_is_full(bus)) {\n        error_setg(errp, \"Bus '%s' is full\", path);\n        return NULL;\n    }\n    return bus;\n}\n\nvoid qdev_set_id(DeviceState *dev, const char *id)\n{\n    if (id) {\n        dev->id = id;\n    }\n\n    if (dev->id) {\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n                                  OBJECT(dev), NULL);\n    } else {\n        static int anon_count;\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n                                  OBJECT(dev), NULL);\n        g_free(name);\n    }\n}\n\nDeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n{\n    DeviceClass *dc;\n    const char *driver, *path;\n    DeviceState *dev;\n    BusState *bus = NULL;\n    Error *err = NULL;\n\n    driver = qemu_opt_get(opts, \"driver\");\n    if (!driver) {\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n        return NULL;\n    }\n\n    /* find driver */\n    dc = qdev_get_device_class(&driver, errp);\n    if (!dc) {\n        return NULL;\n    }\n\n    /* find bus */\n    path = qemu_opt_get(opts, \"bus\");\n    if (path != NULL) {\n        bus = qbus_find(path, errp);\n        if (!bus) {\n            return NULL;\n        }\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n                       driver, object_get_typename(OBJECT(bus)));\n            return NULL;\n        }\n    } else if (dc->bus_type != NULL) {\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n        if (!bus || qbus_is_full(bus)) {\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n                       dc->bus_type, driver);\n            return NULL;\n        }\n    }\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n        return NULL;\n    }\n\n    /* create device */\n    dev = DEVICE(object_new(driver));\n\n    if (bus) {\n        qdev_set_parent_bus(dev, bus);\n    }\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n    /* set properties */\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n        error_propagate(errp, err);\n        object_unparent(OBJECT(dev));\n        object_unref(OBJECT(dev));\n        return NULL;\n    }\n\n    dev->opts = opts;\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        dev->opts = NULL;\n        object_unparent(OBJECT(dev));\n        object_unref(OBJECT(dev));\n        return NULL;\n    }\n    return dev;\n}\n\n\n#define qdev_printf(fmt, ...) monitor_printf(mon, \"%*s\" fmt, indent, \"\", ## __VA_ARGS__)\nstatic void qbus_print(Monitor *mon, BusState *bus, int indent);\n\nstatic void qdev_print_props(Monitor *mon, DeviceState *dev, Property *props,\n                             int indent)\n{\n    if (!props)\n        return;\n    for (; props->name; props++) {\n        Error *err = NULL;\n        char *value;\n        char *legacy_name = g_strdup_printf(\"legacy-%s\", props->name);\n        if (object_property_get_type(OBJECT(dev), legacy_name, NULL)) {\n            value = object_property_get_str(OBJECT(dev), legacy_name, &err);\n        } else {\n            value = object_property_print(OBJECT(dev), props->name, true, &err);\n        }\n        g_free(legacy_name);\n\n        if (err) {\n            error_free(err);\n            continue;\n        }\n        qdev_printf(\"%s = %s\\n\", props->name,\n                    value && *value ? value : \"<null>\");\n        g_free(value);\n    }\n}\n\nstatic void bus_print_dev(BusState *bus, Monitor *mon, DeviceState *dev, int indent)\n{\n    BusClass *bc = BUS_GET_CLASS(bus);\n\n    if (bc->print_dev) {\n        bc->print_dev(mon, dev, indent);\n    }\n}\n\nstatic void qdev_print(Monitor *mon, DeviceState *dev, int indent)\n{\n    ObjectClass *class;\n    BusState *child;\n    NamedGPIOList *ngl;\n\n    qdev_printf(\"dev: %s, id \\\"%s\\\"\\n\", object_get_typename(OBJECT(dev)),\n                dev->id ? dev->id : \"\");\n    indent += 2;\n    QLIST_FOREACH(ngl, &dev->gpios, node) {\n        if (ngl->num_in) {\n            qdev_printf(\"gpio-in \\\"%s\\\" %d\\n\", ngl->name ? ngl->name : \"\",\n                        ngl->num_in);\n        }\n        if (ngl->num_out) {\n            qdev_printf(\"gpio-out \\\"%s\\\" %d\\n\", ngl->name ? ngl->name : \"\",\n                        ngl->num_out);\n        }\n    }\n    class = object_get_class(OBJECT(dev));\n    do {\n        qdev_print_props(mon, dev, DEVICE_CLASS(class)->props, indent);\n        class = object_class_get_parent(class);\n    } while (class != object_class_by_name(TYPE_DEVICE));\n    bus_print_dev(dev->parent_bus, mon, dev, indent);\n    QLIST_FOREACH(child, &dev->child_bus, sibling) {\n        qbus_print(mon, child, indent);\n    }\n}\n\nstatic void qbus_print(Monitor *mon, BusState *bus, int indent)\n{\n    BusChild *kid;\n\n    qdev_printf(\"bus: %s\\n\", bus->name);\n    indent += 2;\n    qdev_printf(\"type %s\\n\", object_get_typename(OBJECT(bus)));\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n        DeviceState *dev = kid->child;\n        qdev_print(mon, dev, indent);\n    }\n}\n#undef qdev_printf\n\nvoid hmp_info_qtree(Monitor *mon, const QDict *qdict)\n{\n    if (sysbus_get_default())\n        qbus_print(mon, sysbus_get_default(), 0);\n}\n\nvoid hmp_info_qdm(Monitor *mon, const QDict *qdict)\n{\n    qdev_print_devinfos(true);\n}\n\ntypedef struct QOMCompositionState {\n    Monitor *mon;\n    int indent;\n} QOMCompositionState;\n\nstatic void print_qom_composition(Monitor *mon, Object *obj, int indent);\n\nstatic int print_qom_composition_child(Object *obj, void *opaque)\n{\n    QOMCompositionState *s = opaque;\n\n    print_qom_composition(s->mon, obj, s->indent);\n\n    return 0;\n}\n\nstatic void print_qom_composition(Monitor *mon, Object *obj, int indent)\n{\n    QOMCompositionState s = {\n        .mon = mon,\n        .indent = indent + 2,\n    };\n    char *name;\n\n    if (obj == object_get_root()) {\n        name = g_strdup(\"\");\n    } else {\n        name = object_get_canonical_path_component(obj);\n    }\n    monitor_printf(mon, \"%*s/%s (%s)\\n\", indent, \"\", name,\n                   object_get_typename(obj));\n    g_free(name);\n    object_child_foreach(obj, print_qom_composition_child, &s);\n}\n\nvoid hmp_info_qom_tree(Monitor *mon, const QDict *dict)\n{\n    const char *path = qdict_get_try_str(dict, \"path\");\n    Object *obj;\n    bool ambiguous = false;\n\n    if (path) {\n        obj = object_resolve_path(path, &ambiguous);\n        if (!obj) {\n            monitor_printf(mon, \"Path '%s' could not be resolved.\\n\", path);\n            return;\n        }\n        if (ambiguous) {\n            monitor_printf(mon, \"Warning: Path '%s' is ambiguous.\\n\", path);\n            return;\n        }\n    } else {\n        obj = qdev_get_machine();\n    }\n    print_qom_composition(mon, obj, 0);\n}\n\nvoid qmp_device_add(QDict *qdict, QObject **ret_data, Error **errp)\n{\n    Error *local_err = NULL;\n    QemuOpts *opts;\n    DeviceState *dev;\n\n    opts = qemu_opts_from_qdict(qemu_find_opts(\"device\"), qdict, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n    if (!monitor_cur_is_qmp() && qdev_device_help(opts)) {\n        qemu_opts_del(opts);\n        return;\n    }\n    dev = qdev_device_add(opts, &local_err);\n    if (!dev) {\n        error_propagate(errp, local_err);\n        qemu_opts_del(opts);\n        return;\n    }\n    object_unref(OBJECT(dev));\n}\n\nstatic DeviceState *find_device_state(const char *id, Error **errp)\n{\n    Object *obj;\n\n    if (id[0] == '/') {\n        obj = object_resolve_path(id, NULL);\n    } else {\n        char *root_path = object_get_canonical_path(qdev_get_peripheral());\n        char *path = g_strdup_printf(\"%s/%s\", root_path, id);\n\n        g_free(root_path);\n        obj = object_resolve_path_type(path, TYPE_DEVICE, NULL);\n        g_free(path);\n    }\n\n    if (!obj) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", id);\n        return NULL;\n    }\n\n    if (!object_dynamic_cast(obj, TYPE_DEVICE)) {\n        error_setg(errp, \"%s is not a hotpluggable device\", id);\n        return NULL;\n    }\n\n    return DEVICE(obj);\n}\n\nvoid qmp_device_del(const char *id, Error **errp)\n{\n    DeviceState *dev = find_device_state(id, errp);\n    if (dev != NULL) {\n        qdev_unplug(dev, errp);\n    }\n}\n\nBlockBackend *blk_by_qdev_id(const char *id, Error **errp)\n{\n    DeviceState *dev;\n    BlockBackend *blk;\n\n    dev = find_device_state(id, errp);\n    if (dev == NULL) {\n        return NULL;\n    }\n\n    blk = blk_by_dev(dev);\n    if (!blk) {\n        error_setg(errp, \"Device does not have a block device backend\");\n    }\n    return blk;\n}\n\nvoid qdev_machine_init(void)\n{\n    qdev_get_peripheral_anon();\n    qdev_get_peripheral();\n}\n\nQemuOptsList qemu_device_opts = {\n    .name = \"device\",\n    .implied_opt_name = \"driver\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_device_opts.head),\n    .desc = {\n        /*\n         * no elements => accept any\n         * sanity checking will happen later\n         * when setting device properties\n         */\n        { /* end of list */ }\n    },\n};\n\nQemuOptsList qemu_global_opts = {\n    .name = \"global\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_global_opts.head),\n    .desc = {\n        {\n            .name = \"driver\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"property\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"value\",\n            .type = QEMU_OPT_STRING,\n        },\n        { /* end of list */ }\n    },\n};\n\nint qemu_global_option(const char *str)\n{\n    char driver[64], property[64];\n    QemuOpts *opts;\n    int rc, offset;\n\n    rc = sscanf(str, \"%63[^.=].%63[^=]%n\", driver, property, &offset);\n    if (rc == 2 && str[offset] == '=') {\n        opts = qemu_opts_create(&qemu_global_opts, NULL, 0, &error_abort);\n        qemu_opt_set(opts, \"driver\", driver, &error_abort);\n        qemu_opt_set(opts, \"property\", property, &error_abort);\n        qemu_opt_set(opts, \"value\", str + offset + 1, &error_abort);\n        return 0;\n    }\n\n    opts = qemu_opts_parse_noisily(&qemu_global_opts, str, false);\n    if (!opts) {\n        return -1;\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "qdict-test-data.txt",
          "type": "blob",
          "size": 88.4453125,
          "content": "00-INDEX: 333\n07: 4096\n1040.bin.ihex: 92633\n11d.c: 17874\n11d.h: 2386\n1200.bin.ihex: 14717\n12160.bin.ihex: 77829\n1232ea962bbaf0e909365f4964f6cceb2ba8ce: 298\n1280.bin.ihex: 88220\n15562512ca6cf14c1b8f08e09d5907118deaf0: 297\n17: 4096\n1d: 4096\n1.Intro: 14968\n21142.c: 8591\n21285.c: 11721\n2860_main_dev.c: 33854\n2860_rtmp_init.c: 26170\n2870_main_dev.c: 39352\n2870_rtmp_init.c: 51247\n2.Process: 22356\n300vtbl.h: 43771\n310vtbl.h: 59655\n3270.ChangeLog: 1889\n3270.txt: 10964\n3550.bin.ihex: 13916\n3780i.c: 21485\n3780i.h: 14180\n38C0800.bin.ihex: 14772\n38C1600.bin.ihex: 17504\n3C359.bin.ihex: 69044\n3c359.c: 60161\n3c359.h: 7264\n3c359.txt: 2463\n3c501.c: 23869\n3c501.h: 2623\n3c503.c: 22491\n3c503.h: 3880\n3c505.c: 48605\n3c505.h: 6535\n3c505.txt: 1831\n3c507.c: 28758\n3c509.c: 42879\n3c509.txt: 9006\n3c515.c: 49671\n3c523.c: 39251\n3c523.h: 11169\n3c527.c: 43065\n3c527.h: 1482\n3c574_cs.c: 35859\n3c589_cs.c: 30110\n3c59x.c: 103272\n3CCFEM556.cis.ihex: 469\n3com: 4096\n3CXEM556.cis.ihex: 463\n3.Early-stage: 9993\n3w-9xxx.c: 77318\n3w-9xxx.h: 26357\n3w-xxxx.c: 85227\n3w-xxxx.h: 16846\n40x: 4096\n40x_mmu.c: 4082\n42: 4096\n44x: 4096\n44x.c: 3615\n44x_emulate.c: 4512\n44x.h: 448\n44x_mmu.c: 2966\n44x_tlb.c: 13997\n44x_tlb.h: 2465\n4.Coding: 20212\n4level-fixup.h: 1028\n4xx: 4096\n4xx.c: 16297\n4xx.h: 1174\n512x: 4096\n5206: 4096\n5206e: 4096\n520x: 4096\n523x: 4096\n5249: 4096\n5272: 4096\n527x: 4096\n528x: 4096\n52xx: 4096\n5307: 4096\n532x: 4096\n53c700.c: 71188\n53c700_d.h_shipped: 28887\n53c700.h: 16652\n53c700.scr: 10894\n53c700.txt: 5042\n5407: 4096\n57xx_iscsi_constants.h: 7004\n57xx_iscsi_hsi.h: 36895\n5d: 4096\n5.Posting: 15211\n66b00c9dc3e1e071bde0ebfeadc40bbc1e8316: 298\n68328: 4096\n68328fb.c: 13570\n68328serial.c: 35841\n68328serial.h: 6237\n68360: 4096\n68360serial.c: 76262\n68EZ328: 4096\n68VZ328: 4096\n6c5e45fe4f1c83df9429b7c2668b41446baac2: 297\n6.Followthrough: 11745\n6pack.c: 24715\n6pack.txt: 7940\n6xx-suspend.S: 1086\n712_defconfig: 25531\n7206: 4096\n73: 4096\n7343: 4096\n770x: 4096\n7721: 4096\n7722: 4096\n7724: 4096\n7751: 4096\n7780: 4096\n7990.c: 22036\n7990.h: 10421\n7.AdvancedTopics: 9648\n7c: 4096\n7segled.c: 2698\n802: 4096\n80211core: 4096\n80211hdr.h: 12326\n80211mgr.c: 28179\n80211mgr.h: 23006\n8021q: 4096\n8139cp.c: 56138\n8139too.c: 71384\n8250_accent.c: 1071\n8250_acorn.c: 3194\n8250_boca.c: 1301\n8250.c: 83003\n8250_early.c: 6636\n8250_exar_st16c554.c: 1191\n8250_fourport.c: 1216\n8250_gsc.c: 3620\n8250.h: 2432\n8250_hp300.c: 7797\n8250_hub6.c: 1224\n8250_mca.c: 1375\n8250_pci.c: 93521\n8250_pci.h: 999\n8250-platform.c: 1091\n8250_pnp.c: 14783\n8253.h: 10999\n8253pit.h: 48\n8255.c: 10692\n8255.h: 1805\n82571.c: 48377\n82596.c: 41209\n82xx: 4096\n8390.c: 2094\n8390.h: 9629\n8390p.c: 2248\n83xx: 4096\n83xx-512x-pci.txt: 1323\n85xx: 4096\n86xx: 4096\n87: 4096\n8b: 4096\n8.Conclusion: 3137\n8xx: 4096\n8xx_immap.h: 14089\n8xxx_gpio.txt: 1343\n941a7798a5169ee0dd69a9e8d5c40ceb702023: 298\n9600.bin.ihex: 14715\n9p: 4096\n9p.h: 13443\n9p.txt: 5113\na100u2w.c: 36919\na100u2w.h: 16936\na2065.c: 20730\na2065.h: 5135\na2091.c: 6445\na2091.h: 1712\na20.c: 3548\na20r.c: 5261\na3000.c: 6528\na3000.h: 1807\na3d.c: 11335\na4000t.c: 3579\na500_defconfig: 31440\na800.c: 5950\naachba.c: 84424\naaci.c: 27297\naaci.h: 7022\naacraid: 4096\naacraid.h: 53671\naacraid.txt: 6849\naaec2000.h: 8936\naaed2000.c: 2298\naaed2000.h: 1354\naaed2000_kbd.c: 5059\naarp.c: 25379\nab3100-core.c: 22600\nab3100.h: 3510\nabdac.c: 15469\nABI: 4096\nabi.h: 782\nabituguru: 3731\nabituguru3: 2493\nabituguru3.c: 41974\nabituguru.c: 53440\nabituguru-datasheet: 12294\nabi.txt: 1413\nABI.txt: 1413\nablkcipher.c: 9484\nabort-ev4.S: 882\nabort-ev4t.S: 913\nabort-ev5tj.S: 987\nabort-ev5t.S: 912\nabort-ev6.S: 1320\nabort-ev7.S: 774\nabort-lv4t.S: 6546\nabort-macro.S: 1144\nabort-nommu.S: 462\nabs_addr.h: 1800\nabspath.c: 2808\nabs.S: 238\nabyss.c: 11197\nabyss.h: 1550\nac3200.c: 11838\nac97: 4096\nac97_bus.c: 1681\nac97.c: 4489\nac97c.c: 26095\nac97c.h: 2045\nac97_codec.c: 36925\nac97_codec.h: 15115\nac97.h: 507\nac97_id.h: 2422\nac97_local.h: 1689\nac97_patch.c: 128568\nac97_patch.h: 4386\nac97_pcm.c: 21244\nac97_proc.c: 18243\nacadia_defconfig: 23272\nacadia.dts: 5188\nac.c: 9202\naccel.c: 8625\naccel.h: 5627\naccess.c: 10521\naccessibility: 4096\naccess_ok.h: 1305\naccommon.h: 2825\nacconfig.h: 7688\naccounting: 4096\nacct.c: 17700\nacct.h: 5949\nacdebug.h: 6836\nacdispat.h: 10988\nacecad.c: 7982\nacenic: 4096\nacenic.c: 88166\nacenic.h: 16029\nacenv.h: 11821\nacerhdf.c: 14909\nacer-wmi.c: 30530\nacer-wmi.txt: 6480\nacevents.h: 6692\nacexcep.h: 12764\nacgcc.h: 2843\nacglobal.h: 14485\nachware.h: 4355\nacinterp.h: 16329\nackvec.c: 12985\nackvec.h: 3426\nacl7225b.c: 3794\nacl.c: 5321\nacl.h: 1548\naclinux.h: 5049\naclocal.h: 34614\nacmacros.h: 22966\nacm.txt: 4974\nacnames.h: 3482\nacnamesp.h: 10211\nacobject.h: 16573\nacopcode.h: 22365\nacorn.c: 12206\nacornfb.c: 35783\nacornfb.h: 4809\nacorn.h: 623\nacornscsi.c: 87770\nacornscsi.h: 9694\nacornscsi-io.S: 3320\nacoutput.h: 10925\nacparser.h: 7436\nacpi: 4096\nacpi_bus.h: 11195\nacpi.c: 6529\nacpica: 12288\nacpi-cpufreq.c: 21588\nacpi_drivers.h: 5322\nacpi-ext.c: 2774\nacpi-ext.h: 590\nacpi.h: 4768\nacpi_memhotplug.c: 14832\nacpi_numa.h: 471\nacpiosxf.h: 7880\nacpi_pcihp.c: 14898\nacpiphp_core.c: 10949\nacpiphp_glue.c: 44065\nacpiphp.h: 6325\nacpiphp_ibm.c: 14740\nacpi_pm.c: 6723\nacpi_pmtmr.h: 672\nacpi-processor.c: 1893\nacpixf.h: 12045\nacpredef.h: 18909\nacquirewdt.c: 8920\nacresrc.h: 11064\nacrestyp.h: 11267\nacs5k_defconfig: 28786\nacs5k_tiny_defconfig: 21413\nacstruct.h: 7738\nact2000: 4096\nact2000.h: 6271\nact2000_isa.c: 11978\nact2000_isa.h: 7615\nact200l-sir.c: 7142\nactables.h: 3945\nact_api.c: 23712\nact_api.h: 4195\nactbl1.h: 35761\nactbl.h: 15492\nact_gact.c: 5493\naction.c: 40\naction.h: 40\nact_ipt.c: 7564\nactisys-sir.c: 7692\nactive_mm.txt: 3805\nact_mirred.c: 6285\nact_nat.c: 7265\nact_pedit.c: 6148\nact_police.c: 9833\nact_simple.c: 5238\nact_skbedit.c: 5510\nactypes.h: 34263\nacutils.h: 16898\nacx.c: 16590\nacx.h: 33552\nad1816a: 4096\nad1816a.c: 8825\nad1816a.h: 5363\nad1816a_lib.c: 30656\nad1843.c: 16402\nad1843.h: 1516\nad1848: 4096\nad1848.c: 75959\nad1848.h: 982\nad1848_mixer.h: 10957\nad1889.c: 27048\nad1889.h: 8073\nad1980.c: 8427\nad1980.h: 468\nad73311.c: 2765\nad73311.h: 2404\nad7414.c: 7164\nad7418.c: 8304\nad7877.c: 20856\nad7877.h: 796\nad7879.c: 19019\nad7879.h: 1004\nadaptec: 4096\nadapter.h: 400\nadb.c: 19706\nadb.h: 2770\nadbhid.c: 35627\nadb-iop.c: 6325\nadb_iop.h: 1081\nadc.c: 8573\nadc.h: 886\nADC-LH7-Touchscreen: 2187\nadcxx.c: 8256\nadder875.c: 3142\nadder875_defconfig: 21956\nadder875-redboot.dts: 4102\nadder875-uboot.dts: 4072\naddi_amcc_S5920.c: 7563\naddi_amcc_S5920.h: 1016\naddi_amcc_s5933.h: 13296\naddi_apci_035.c: 128\naddi_apci_1032.c: 63\naddi_apci_1500.c: 63\naddi_apci_1516.c: 63\naddi_apci_1564.c: 63\naddi_apci_16xx.c: 63\naddi_apci_1710.c: 63\naddi_apci_2016.c: 63\naddi_apci_2032.c: 63\naddi_apci_2200.c: 63\naddi_apci_3001.c: 63\naddi_apci_3120.c: 63\naddi_apci_3200.c: 63\naddi_apci_3300.c: 63\naddi_apci_3501.c: 63\naddi_apci_3xxx.c: 63\naddi_apci_all.c: 468\naddi_common.c: 57084\naddi_common.h: 15536\naddi-data: 4096\naddi_eeprom.c: 35657\naddinitrd.c: 3837\naddnote.c: 5117\naddon_cpuid_features.c: 3269\naddRamDisk.c: 9120\naddr.c: 13176\naddrconf.c: 112491\naddrconf_core.c: 2484\naddrconf.h: 7261\naddress.c: 10451\naddr.h: 615\naddrlabel.c: 14012\naddr-map.c: 3725\naddr-map.h: 1054\naddrs.h: 14810\naddrspace.h: 4233\nadfs: 4096\nadfs_fs.h: 1337\nadfs.h: 5064\nadfs.txt: 1816\nadi.c: 14310\nadlib.c: 3006\nadl_pci6208.c: 11803\nadl_pci7296.c: 4671\nadl_pci7432.c: 5617\nadl_pci8164.c: 9991\nadl_pci9111.c: 38266\nadl_pci9118.c: 69079\nadm1021: 4184\nadm1021.c: 14057\nadm1025: 2364\nadm1025.c: 19865\nadm1026: 4578\nadm1026.c: 60096\nadm1029.c: 13774\nadm1031: 1193\nadm1031.c: 31209\nadm8211.c: 56115\nadm8211.h: 18093\nadm9240: 6804\nadm9240.c: 24112\nadma.c: 5497\nadma.h: 13803\nadq12b.c: 12147\nads7828: 1146\nads7828.c: 8084\nads7846.c: 31008\nads7846.h: 1844\nADSBitsy: 1396\nadssphere.c: 1810\nadt7462: 2515\nadt7462.c: 60645\nadt7470: 2759\nadt7470.c: 42397\nadt7473: 2757\nadt7473.c: 35779\nadt7475: 2578\nadt7475.c: 35318\nadummy.c: 3035\nadutux.c: 25427\nadv7170.c: 9645\nadv7175.c: 10457\nadv7343.c: 12608\nadv7343.h: 730\nadv7343_regs.h: 5764\nadvansys: 4096\nadvansys.c: 382572\nadvansys.txt: 9492\nadvantechwdt.c: 8222\nadv_pci1710.c: 46220\nadv_pci1723.c: 12975\nadv_pci_dio.c: 34130\nae7400074d449189d41fceb6d6f871490d7842: 298\naead.c: 12873\naead.h: 2027\naec62xx.c: 9392\naedsp16.c: 36369\nael1002.c: 41054\naer: 4096\naerdrv_acpi.c: 1347\naerdrv.c: 8935\naerdrv_core.c: 22958\naerdrv_errprint.c: 5915\naerdrv.h: 3468\naer.h: 773\naer_inject.c: 10715\naes.c: 11973\naes_ccm.c: 3589\naes_ccm.h: 810\naes_ccmp.c: 14024\naes_ccmp.h: 1469\naes_cmac.c: 2737\naes_cmac.h: 587\naes_generic.c: 63316\naes_glue.c: 1691\naes.h: 279\naes-i586-asm_32.S: 10637\naesni-intel_asm.S: 21991\naesni-intel_glue.c: 19525\naes_s390.c: 13814\naes-x86_64-asm_64.S: 4820\naf802154.h: 1271\naf9005.c: 28215\naf9005-fe.c: 36514\naf9005.h: 120579\naf9005-remote.c: 4403\naf9005-script.h: 5193\naf9013.c: 38083\naf9013.h: 3095\naf9013_priv.h: 21508\naf9015.c: 43153\naf9015.h: 28439\naf_ax25.c: 45160\naf_bluetooth.c: 10089\naf_can.c: 23294\naf_can.h: 4053\naf_decnet.c: 54945\nafeb9260_defconfig: 29783\naf_econet.c: 25853\naffs: 4096\naffs.h: 10590\naffs_hardblocks.h: 1481\naffs.txt: 8188\naf_ieee802154.c: 8683\naf_ieee802154.h: 1620\naf_inet6.c: 29847\naf_inet.c: 40041\naf_ipx.c: 50967\naf_irda.c: 67827\naf_irda.h: 2964\naf_iucv.c: 41285\naf_iucv.h: 2495\naf_key.c: 102229\naf_llc.c: 29863\naf_netlink.c: 46590\naf_netrom.c: 33634\naf_packet.c: 55964\naf_phonet.c: 10845\naf_rds.c: 14309\naf_rose.c: 39337\naf_rxrpc.c: 20908\naf_rxrpc.h: 2017\nafs: 4096\nafs.c: 6434\nafs_cm.h: 1213\nafs_fs.h: 2342\nafs.h: 6110\nafs.txt: 7976\nafs_vl.h: 3680\naf_unix.c: 53673\naf_unix.h: 1891\naf_x25.c: 38538\nagent.c: 6214\nagent.h: 2106\nagg-rx.c: 10061\nagg-tx.c: 19983\nagnx: 4096\nagnx.h: 4414\nagp: 4096\nagp_backend.h: 909\nagpgart.h: 6567\nagp.h: 11594\nah4.c: 7802\nah6.c: 13438\naha152x.c: 100462\naha152x_core.c: 61\naha152x.h: 10175\naha152x_stub.c: 7843\naha152x.txt: 6540\naha1542.c: 50376\naha1542.h: 4776\naha1740.c: 19608\naha1740.h: 4954\nahash.c: 5607\nahb.c: 4740\nah.c: 3493\nahci.c: 82058\nah.h: 894\naic7770.c: 9851\naic7770_osm.c: 4437\naic79xx_core.c: 299904\naic79xx.h: 46803\naic79xx_inline.h: 5997\naic79xx_osm.c: 79947\naic79xx_osm.h: 21300\naic79xx_osm_pci.c: 10626\naic79xx_pci.c: 27694\naic79xx_pci.h: 3106\naic79xx_proc.c: 10559\naic79xx.reg: 73912\naic79xx_reg.h_shipped: 71718\naic79xx_reg_print.c_shipped: 19691\naic79xx.seq: 72735\naic79xx_seq.h_shipped: 29327\naic79xx.txt: 24091\naic7xxx: 4096\naic7xxx_93cx6.c: 9761\naic7xxx_93cx6.h: 3670\naic7xxx_core.c: 216583\naic7xxx.h: 42160\naic7xxx_inline.h: 3774\naic7xxx_old: 4096\naic7xxx_old.c: 366880\naic7xxx_old.txt: 24500\naic7xxx_osm.c: 73118\naic7xxx_osm.h: 21353\naic7xxx_osm_pci.c: 12355\naic7xxx_pci.c: 61842\naic7xxx_pci.h: 5296\naic7xxx_proc.c: 10950\naic7xxx.reg: 38137\naic7xxx_reg.h: 15305\naic7xxx_reg.h_shipped: 23099\naic7xxx_reg_print.c_shipped: 10818\naic7xxx.seq: 70499\naic7xxx_seq.c: 20747\naic7xxx_seq.h_shipped: 32908\naic7xxx.txt: 19701\naic94xx: 4096\naic94xx_dev.c: 11236\naic94xx_dump.c: 36929\naic94xx_dump.h: 1451\naic94xx.h: 3007\naic94xx_hwi.c: 38875\naic94xx_hwi.h: 10646\naic94xx_init.c: 28607\naic94xx_reg.c: 10895\naic94xx_reg_def.h: 74147\naic94xx_reg.h: 10470\naic94xx_sas.h: 22044\naic94xx_scb.c: 27220\naic94xx_sds.c: 37304\naic94xx_sds.h: 4644\naic94xx_seq.c: 47415\naic94xx_seq.h: 2011\naic94xx_task.c: 17414\naic94xx_tmf.c: 20129\naica.c: 18912\naica.h: 2322\naicasm: 4096\naicasm.c: 20235\naicasm_gram.y: 41937\naicasm.h: 3213\naicasm_insformat.h: 5394\naicasm_macro_gram.y: 4072\naicasm_macro_scan.l: 4166\naicasm_scan.l: 15538\naicasm_symbol.c: 16089\naicasm_symbol.h: 4889\naiclib.c: 1599\naiclib.h: 6327\naio_abi.h: 3060\naio_aio12_8.c: 5597\naio.c: 9345\naio.h: 530\naio_iiro_16.c: 4521\naiptek.c: 63719\naircable.c: 16905\nairo.c: 224549\nairo_cs.c: 16214\nairo.h: 272\naironet.c: 38\naironet.h: 31\nairport.c: 6741\nairq.c: 3567\nairq.h: 530\nak4104.c: 8783\nak4104.h: 143\nak4114.c: 18943\nak4114.h: 10191\nak4117.c: 16871\nak4117.h: 9193\nak4396.h: 1065\nak4531_codec.c: 17543\nak4531_codec.h: 3161\nak4535.c: 18361\nak4535.h: 1042\nak4xxx-adda.c: 25308\nak4xxx-adda.h: 3333\nak4xxx.c: 5039\naki3068net: 4096\nalauda.c: 34485\nalaw_main.csp.ihex: 3714\nalchemy: 4096\nalchemy-flash.c: 4191\nalgapi.c: 16668\nalgapi.h: 8721\nalgboss.c: 6296\nalgos: 4096\nali14xx.c: 6564\nali5451: 4096\nali5451.c: 59400\nali-agp.c: 10369\nalias.c: 1447\naliasing-test.c: 6103\naliasing.txt: 8753\nalias.txt: 1181\nalign.c: 24429\nalignment.c: 23757\nalign.S: 11650\nali-ircc.c: 57570\nali-ircc.h: 7748\nalim1535_wdt.c: 10224\nalim15x3.c: 14978\nalim7101_wdt.c: 11048\nallocator.c: 10151\nalloc.c: 10261\nalloc.h: 9219\nallocpercpu.c: 4150\nalpaca.h: 1209\nalpha: 4096\nalpha-agp.c: 5476\nalpha_ksyms.c: 2696\nalphatrack.c: 23326\nalphatrack.h: 2005\nalps.c: 15813\nalps.h: 1047\nALS: 3770\nals100.c: 9384\nals300.c: 23789\nals4000.c: 32136\nalsa: 4096\nalsa.c: 2430\nALSA-Configuration.txt: 75006\nalsa-driver-api.tmpl: 3216\nalsa.h: 370\nalternative-asm.h: 289\nalternative.c: 14237\nalternative.h: 5895\naltpciechdma: 4096\naltpciechdma.c: 37598\nam200epd.c: 9652\nam200epdkit_defconfig: 26949\nam300epd.c: 6564\nam79c961a.c: 18502\nam79c961a.h: 3109\nam9513.h: 1940\namba: 4096\namba-clcd.c: 12494\nambakmi.c: 4554\namba-pl010.c: 19490\namba-pl011.c: 21509\namba-pl022.c: 53346\nambassador.c: 68387\nambassador.h: 16192\namcc: 4096\namcc_s5933_58.h: 14263\namcc_s5933.h: 6603\namd5536udc.c: 86854\namd5536udc.h: 17276\namd64-agp.c: 20128\namd64_edac.c: 98492\namd64_edac_dbg.c: 5401\namd64_edac_err_types.c: 3628\namd64_edac.h: 19221\namd64_edac_inj.c: 4304\namd74xx.c: 10198\namd76x_edac.c: 9371\namd76xrom.c: 9404\namd7930.c: 31102\namd7930_fn.c: 23626\namd7930_fn.h: 1162\namd8111e.c: 53690\namd8111_edac.c: 16756\namd8111_edac.h: 4244\namd8111e.h: 21006\namd8131_edac.c: 10985\namd8131_edac.h: 3772\namd_bus.c: 13843\namd.c: 3180\namd_iommu.c: 52618\namd_iommu.h: 1421\namd_iommu_init.c: 34814\namd_iommu_types.h: 13377\namd-k7-agp.c: 15673\namd-powernow.txt: 1673\namd-rng.c: 3458\namifb.c: 103212\namifd.h: 1995\namifdreg.h: 2674\namiflop.c: 46962\namiga: 4096\namiga.c: 3445\namiga_defconfig: 28613\namigaffs.c: 11549\namigaffs.h: 2927\namiga.h: 116\namigahw.h: 11232\namigaints.h: 3583\namigaone: 4096\namigaone_defconfig: 40433\namigaone.dts: 4189\namigayle.h: 3135\namiints.c: 6489\namijoy.c: 4591\namijoy.txt: 7701\namikbd.c: 6468\namimouse.c: 3296\namipcmcia.h: 2568\namiserial.c: 54254\namisound.c: 2828\namix86.c: 23331\namlcode.h: 18976\naml_nfw.c: 5630\namlresrc.h: 9975\namon.h: 141\namp.c: 2736\namp.h: 1594\namplc_dio200.c: 38731\namplc_pc236.c: 16962\namplc_pc263.c: 11680\namplc_pci224.c: 44174\namplc_pci230.c: 92910\nams: 4096\nams-core.c: 6046\nams-delta.c: 5974\nams_delta_defconfig: 28481\namsdu.c: 5428\nams.h: 1354\nams-i2c.c: 6365\nams-input.c: 3542\namso1100: 4096\nams-pmu.c: 4469\nanalog.c: 20366\nanchor.h: 3882\nanchors.txt: 2625\nandroid: 4096\nani.c: 23441\nani.h: 4062\nanode.c: 14491\nanomaly.h: 11228\nanon_inodes.c: 5477\nanon_inodes.h: 312\nansi_cprng.c: 10011\nansidecl.h: 4393\nans-lcd.c: 3847\nans-lcd.h: 206\nanubis.c: 28484\nanubis-cpld.h: 652\nanubis-irq.h: 596\nanubis-map.h: 1219\nanycast.c: 11884\nanysee.c: 15434\nanysee.h: 14174\naoa: 4096\naoa-gpio.h: 2434\naoa.h: 3816\naoe: 4096\naoeblk.c: 7321\naoechr.c: 6092\naoecmd.c: 23023\naoedev.c: 5392\naoe.h: 4748\naoemain.c: 2032\naoenet.c: 3237\naoe.txt: 4600\naops.c: 49318\naops.h: 4017\na.out-core.h: 2444\na.out.h: 2438\nap325rxa_defconfig: 31462\napanel.c: 8043\napb.h: 1043\nap_bus.c: 45317\nap_bus.h: 6091\napc.c: 4412\napc.h: 1682\nAPCI1710_82x54.c: 55614\nAPCI1710_82x54.h: 2408\nAPCI1710_Chrono.c: 75530\nAPCI1710_Chrono.h: 2397\nAPCI1710_Dig_io.c: 35243\nAPCI1710_Dig_io.h: 1437\nAPCI1710_INCCPT.c: 206966\nAPCI1710_INCCPT.h: 10615\nAPCI1710_Inp_cpt.c: 32511\nAPCI1710_Inp_cpt.h: 1414\nAPCI1710_Pwm.c: 110859\nAPCI1710_Pwm.h: 2722\nAPCI1710_Ssi.c: 30348\nAPCI1710_Ssi.h: 1343\nAPCI1710_Tor.c: 70692\nAPCI1710_Tor.h: 1684\nAPCI1710_Ttl.c: 35072\nAPCI1710_Ttl.h: 1338\napdbg.c: 12729\naperture_64.c: 13850\nap.h: 26\napic: 4096\napi.c: 4766\napic.c: 56323\napicdef.h: 10790\napic_flat_64.c: 9680\napic.h: 48\napicnum.h: 229\nAPI.html: 738\napi-intro.txt: 6569\napm_32.c: 71310\napm-acpi.txt: 1541\napm_bios.h: 5647\napm.c: 1961\napm_emu.c: 3225\napm-emulation.c: 17959\napm-emulation.h: 1575\napm.h: 1722\napm_power.c: 10334\napm-power.c: 2659\napne.c: 17115\napollo: 4096\napollo_defconfig: 25574\napollodma.h: 9409\napollohw.h: 2876\nappldata: 4096\nappldata_base.c: 16414\nappldata.h: 2269\nappldata_mem.c: 4196\nappldata_net_sum.c: 4240\nappldata_os.c: 6134\nappledisplay.c: 9793\napplesmc.c: 46139\nappletalk: 4096\nappletouch.c: 25051\nappletouch.txt: 3199\napplicom.c: 24465\napplicom.h: 2558\napplying-patches.txt: 19961\napplypatch-msg.sample: 452\naq100x.c: 8974\nar7: 4096\nar7_defconfig: 29419\nar7.h: 4432\nar7part.c: 4186\nar7_wdt.c: 8576\nar9170: 4096\nar9170.h: 7335\nar-accept.c: 12406\nar-ack.c: 33274\narbiter.c: 11549\narbiter.h: 607\narc: 4096\narc4.c: 2066\nar-call.c: 21724\narc_con.c: 973\narcdevice.h: 12708\narcfb.c: 16908\narcfb.h: 150\narch: 4096\narch_checks.c: 3045\narches_defconfig: 19397\narches.dts: 7694\narch.h: 1650\narch-kev7a400.c: 2933\narch-lpd7a40x.c: 10208\narchparam.h: 246\narchsetjmp.h: 363\narch-v10: 4096\narch-v32: 4096\narcmsr: 4096\narcmsr_attr.c: 12953\narcmsr.h: 22540\narcmsr_hba.c: 68471\narcmsr_spec.txt: 22891\narcnet: 4096\narcnet.c: 30476\narcnet-hardware.txt: 112635\narcnet.txt: 23983\narcofi.c: 3664\narcofi.h: 721\nar-connection.c: 23383\nar-connevent.c: 9295\narc-rawmode.c: 5274\narc-rimi.c: 10949\nar-error.c: 5949\nargv_split.c: 1893\nariadne.c: 24224\nariadne.h: 15566\nar-input.c: 20380\nar-internal.h: 28881\nark3116.c: 12365\nar-key.c: 8236\narkfb.c: 31427\narkfb.txt: 2024\narlan.h: 16773\narlan-main.c: 51969\narlan-proc.c: 30009\nar-local.c: 7670\narm: 4096\narmadillo5x0.c: 7149\nARM-gcc.h: 4503\narmksyms.c: 4758\narm_timer.h: 576\nar-output.c: 18343\narp.c: 35296\nar-peer.c: 7599\narp.h: 1028\nar-proc.c: 5159\narptable_filter.c: 3496\narp_tables.c: 47085\narp_tables.h: 8551\narpt_mangle.c: 2391\narpt_mangle.h: 547\narray.c: 13244\narrayRCU.txt: 4475\nar-recvmsg.c: 11003\nar-security.c: 5588\nar-skbuff.c: 3506\narthur.c: 2275\nartpec_3_defconfig: 13781\nar-transport.c: 7196\narv.c: 22235\narxescsi.c: 9967\nasb100: 2093\nasb100.c: 29220\nasb2303_defconfig: 13559\nasciidoc.conf: 2238\nasequencer.h: 24733\nashiftrt.S: 3468\nashldi3.c: 1516\n__ashldi3.S: 1340\nashldi3.S: 1594\nashlsi3.S: 3814\nashrdi3.c: 1578\n__ashrdi3.S: 1359\nashrdi3.S: 1594\nashrsi3.S: 3765\nashxdi3.S: 5014\nasic3.c: 23429\nasic3.h: 11966\nasids-debugfs.c: 1875\nasi.h: 13855\nasiliantfb.c: 17057\nas-iosched.c: 39676\nas-iosched.txt: 8697\nasix.c: 39119\nas-layout.h: 1666\nasl.c: 9101\nasm: 4096\nasm-compat.h: 1951\nasm-generic: 4096\nasm.h: 9481\nasmmacro-32.h: 4815\nasmmacro-64.h: 3961\nasmmacro.h: 2767\nasm-offsets_32.c: 5194\nasm-offsets_64.c: 3637\nasm-offsets.c: 4611\nasmregs.h: 3115\nasn1.c: 15700\nasoundef.h: 14263\nasound_fm.h: 4313\nasound.h: 39901\nasp8347_defconfig: 35011\nasp834x.c: 2108\nasp834x-redboot.dts: 6941\nasp.c: 3631\naspenite.c: 2671\nasp.h: 608\naspm.c: 25790\nAssabet: 9201\nassabet.c: 11283\nassabet_defconfig: 17595\nassabet.h: 4477\nassembler.h: 2834\nassembly.h: 12972\nassoc.c: 36\nassoc.h: 408\nassociation.h: 4661\nassociola.c: 43957\nast.c: 3630\nast.h: 878\nasus_acpi.c: 39676\nasus_atk0110.c: 24097\nasuscom.c: 11573\nasus-laptop.c: 36214\nasus_oled: 4096\nasus_oled.c: 18945\nasync.c: 11128\nasyncdata.c: 15045\nasync.h: 973\nasync_memcpy.c: 3227\nasync_memset.c: 2994\nasync-thread.c: 13350\nasync-thread.h: 3400\nasync_tx: 4096\nasync-tx-api.txt: 8950\nasync_tx.c: 8062\nasync_tx.h: 5062\nasync_xor.c: 9790\nat1700.c: 25461\nat24.c: 17172\nat24.h: 1084\nat25.c: 10286\nat32ap700x.c: 54284\nat32ap700x.h: 9017\nat32ap700x_wdt.c: 10216\nat32psif.c: 8545\nat73c213.c: 28442\nat73c213.h: 3187\nat76c50x-usb.c: 69577\nat76c50x-usb.h: 11556\nat76_usb: 4096\nat76_usb.c: 159931\nat76_usb.h: 18785\nat91_adc.h: 2447\nat91_aic.h: 2578\nat91cap9adk_defconfig: 28118\nat91cap9.c: 9260\nat91cap9_ddrsdr.h: 4803\nat91cap9_devices.c: 32852\nat91cap9.h: 5120\nat91cap9_matrix.h: 8438\nat91_cf.c: 10319\nat91_dbgu.h: 2878\nat91_ether.c: 37656\nat91_ether.h: 3116\nat91_ide.c: 10538\nat91_mci.c: 31894\nat91_mci.h: 5220\nat91_pio.h: 2085\nat91_pit.h: 1189\nat91_pmc.h: 6822\nat91rm9200.c: 8544\nat91rm9200_devices.c: 32118\nat91rm9200dk_defconfig: 19334\nat91rm9200ek_defconfig: 19319\nat91rm9200_emac.h: 6334\nat91rm9200.h: 4634\nat91rm9200_mc.h: 7552\nat91rm9200_time.c: 6137\nat91rm9200_wdt.c: 6655\nat91_rstc.h: 1684\nat91_rtc.h: 3381\nat91_rtt.h: 1335\nat91sam9260.c: 9719\nat91sam9260_devices.c: 28830\nat91sam9260ek_defconfig: 23675\nat91sam9260.h: 5601\nat91sam9260_matrix.h: 4360\nat91sam9261.c: 7811\nat91sam9261_devices.c: 27547\nat91sam9261ek_defconfig: 27131\nat91sam9261.h: 3985\nat91sam9261_matrix.h: 3171\nat91sam9263.c: 8693\nat91sam9263_devices.c: 36564\nat91sam9263ek_defconfig: 27888\nat91sam9263.h: 5088\nat91sam9263_matrix.h: 7531\nat91sam926x_time.c: 4812\nat91sam9g20ek_defconfig: 26082\nat91sam9rl.c: 8144\nat91sam9rl_devices.c: 28643\nat91sam9rlek_defconfig: 21184\nat91sam9rl.h: 4332\nat91sam9rl_matrix.h: 5086\nat91sam9_sdramc.h: 3914\nat91sam9_smc.h: 3570\nat91sam9_wdt.c: 7764\nat91_shdwc.h: 1497\nat91_spi.h: 3738\nat91_ssc.h: 4846\nat91_st.h: 1983\nat91_tc.h: 6897\nat91_twi.h: 3075\nat91_udc.c: 48229\nat91_udc.h: 6283\nat91_wdt.h: 1464\nat91x40.c: 1914\nat91x40.h: 2025\nat91x40_time.c: 2547\nat93c.c: 2613\nat93c.h: 292\nata: 12288\nata.c: 4208\nata_defs_asm.h: 8736\nata_defs.h: 6434\natafb.c: 91174\natafb.h: 1708\natafb_iplan2p2.c: 6818\natafb_iplan2p4.c: 7301\natafb_iplan2p8.c: 8377\natafb_mfb.c: 2554\natafb_utils.h: 11235\natafd.h: 261\natafdreg.h: 2704\nataflop.c: 52286\nata_generic.c: 6543\natags.c: 1588\natags.h: 132\nata.h: 787\nataints.c: 14727\natakbd.c: 6402\natakeyb.c: 15982\natalk.h: 5240\natalk_proc.c: 7290\nata_piix.c: 45848\nata_platform.h: 910\natari: 4096\natari.c: 3911\natari_defconfig: 26788\natari.h: 1077\natarihw.h: 20620\natariints.h: 5520\natari_joystick.h: 418\natarikbd.txt: 26109\natarikb.h: 1514\natarilance.c: 34168\natarimouse.c: 3865\natari_NCR5380.c: 92608\natari_scsi.c: 35928\natari_scsi.h: 5820\natari_stdma.h: 458\natari_stram.h: 429\natasound.c: 2705\nateb9200_defconfig: 26557\naten2011.c: 65277\naten.c: 3343\nath: 4096\nath5k: 4096\nath5k.h: 45994\nath9k: 4096\nath9k.h: 20541\nath9k_platform.h: 1116\nathr_common.h: 4056\nati-agp.c: 14653\nati_ids.h: 8172\natiixp.c: 5592\natiixp_modem.c: 36739\nati_pcigart.c: 5516\nati_remote2.c: 23391\nati_remote.c: 27913\natkbd.c: 40410\natl1c: 4096\natl1.c: 101403\natl1c_ethtool.c: 9188\natl1c.h: 20395\natl1c_hw.c: 13975\natl1c_hw.h: 31069\natl1c_main.c: 77505\natl1e: 4096\natl1e_ethtool.c: 11679\natl1e.h: 17562\natl1e_hw.c: 16680\natl1e_hw.h: 38581\natl1e_main.c: 71172\natl1e_param.c: 7245\natl1.h: 24023\natl2.c: 82456\natl2.h: 16349\natlas_btns.c: 4752\natlx: 4096\natlx.c: 7198\natlx.h: 18176\natm: 4096\natmapi.h: 889\natmarp.h: 1233\natmbr2684.h: 3208\natmclip.h: 513\natmdev.h: 16681\natmel: 4096\natmel-abdac.h: 626\natmel-ac97c.h: 1409\natmel.c: 132756\natmel_cs.c: 17914\natmel.h: 1533\natmel_lcdc.h: 7265\natmel_lcdfb.c: 31305\natmel-mci.c: 43139\natmel-mci.h: 1269\natmel-mci-regs.h: 6476\natmel_nand.c: 15137\natmel_nand_ecc.h: 1412\natmel_pci.c: 2533\natmel-pcm.c: 14083\natmel-pcm.h: 2987\natmel_pdc.h: 1410\natmel-pwm-bl.c: 6152\natmel-pwm-bl.h: 1550\natmel_pwm.c: 9359\natmel_pwm.h: 2724\natmel_read_eeprom.c: 3671\natmel_read_eeprom.h: 2413\natmel_serial.c: 40894\natmel_serial.h: 6087\natmel_spi.c: 23923\natmel_spi.h: 4446\natmel-ssc.c: 3605\natmel_ssc_dai.c: 20632\natmel_ssc_dai.h: 3265\natmel-ssc.h: 9369\natmel_tc.h: 11075\natmel_tclib.c: 3626\natmel_tsadcc.c: 10816\natmel_usba_udc.c: 50940\natmel_usba_udc.h: 10031\natmel-wm97xx.c: 11848\natm_eni.h: 585\natm.h: 7995\natm_he.h: 343\natm_idt77105.h: 892\natmioc.h: 1583\natmlec.h: 2561\natm_misc.c: 2638\natmmpc.h: 4163\natm_nicstar.h: 1215\natmppp.h: 576\natmsap.h: 4907\natmsar11.HEX: 19191\natm_suni.h: 253\natmsvc.h: 1790\natm_sysfs.c: 3945\natmtcp.c: 11650\natm_tcp.h: 1768\natm.txt: 426\natm_zatm.h: 1606\natngw100: 4096\natngw100_defconfig: 28242\natngw100_evklcd100_defconfig: 29353\natngw100_evklcd101_defconfig: 29353\natngw100_mrmt_defconfig: 33751\natombios_crtc.c: 23254\natombios.h: 221852\natom-bits.h: 1882\natom.c: 29689\natom.h: 4494\natomic32.c: 2859\natomic_32.h: 11086\natomic_32.S: 2663\natomic64.c: 3863\natomic_64.h: 10903\natomic64.h: 1840\natomic64-ops.S: 4827\natomic_64.S: 2925\natomic-grb.h: 4642\natomic.h: 7333\natomic-irq.h: 1375\natomic-llsc.h: 2813\natomic-long.h: 5244\natomic_mm.h: 4061\natomic_no.h: 3556\natomic-ops.S: 5339\natomic_ops.txt: 19503\natomic-ops.txt: 4632\natomic.S: 15917\natom-names.h: 4758\natom-types.h: 1430\natp870u.c: 86512\natp870u.h: 1487\natp.c: 29816\natp.h: 8737\natstk1000: 4096\natstk1000.h: 535\natstk1002.c: 8012\natstk1002_defconfig: 30107\natstk1003.c: 3765\natstk1003_defconfig: 25774\natstk1004.c: 3756\natstk1004_defconfig: 15379\natstk1006_defconfig: 32583\nattach.c: 9647\nattr.c: 2666\nattrib.c: 91896\nattrib.h: 4321\nattribute_container.c: 12242\nattribute_container.h: 2530\natxp1.c: 9417\naty: 4096\naty128fb.c: 67277\naty128fb.txt: 2119\naty128.h: 13554\natyfb_base.c: 111634\natyfb.h: 8973\nau0828: 4096\nau0828-cards.c: 9773\nau0828-cards.h: 1060\nau0828-core.c: 7629\nau0828-dvb.c: 11151\nau0828.h: 7385\nau0828-i2c.c: 9287\nau0828-reg.h: 2134\nau0828-video.c: 41940\nau1000_db1x00.c: 7294\nau1000_dma.h: 11212\nau1000_eth.c: 33708\nau1000_eth.h: 3012\nau1000_generic.c: 14674\nau1000_generic.h: 4280\nau1000.h: 53188\nau1000_ircc.h: 3758\nau1000_pb1x00.c: 9234\nau1000_xxs1500.c: 4378\nau1100fb.c: 20752\nau1100fb.h: 14620\nau1100_mmc.h: 5888\nau1200fb.c: 52491\nau1200fb.h: 18704\nau1550_ac97.c: 51655\nau1550nd.c: 14821\nau1550_spi.c: 26531\nau1550_spi.h: 433\nau1k_ir.c: 20249\nau1x: 4096\nau1x00.c: 19173\nau1xmmc.c: 28453\nau1xxx_dbdma.h: 13134\nau1xxx.h: 1723\nau1xxx-ide.c: 15369\nau1xxx_ide.h: 6491\nAU1xxx_IDE.README: 4039\nau1xxx_psc.h: 15895\nau6610.c: 6091\nau6610.h: 1286\nau8522_decoder.c: 27416\nau8522_dig.c: 21506\nau8522.h: 2387\nau8522_priv.h: 17128\nau8810.c: 379\nau8810.h: 7007\nau8820.c: 331\nau8820.h: 6479\nau8830.c: 404\nau8830.h: 8629\nau88x0: 4096\nau88x0_a3d.c: 25257\nau88x0_a3ddata.c: 2908\nau88x0_a3d.h: 4336\nau88x0.c: 10316\nau88x0_core.c: 78891\nau88x0_eq.c: 23045\nau88x0_eqdata.c: 3952\nau88x0_eq.h: 1287\nau88x0_game.c: 3655\nau88x0.h: 8929\nau88x0_mixer.c: 773\nau88x0_mpu401.c: 3619\nau88x0_pcm.c: 15858\nau88x0_synth.c: 11076\nau88x0_wt.h: 2347\nau88x0_xtalk.c: 23426\nau88x0_xtalk.h: 2304\nAudigy-mixer.txt: 13956\naudio.c: 7519\nAudioExcelDSP16: 3886\naudio.h: 525\nAudiophile-Usb.txt: 17915\naudit_64.c: 1870\naudit.c: 1888\naudit_change_attr.h: 320\naudit_dir_write.h: 238\nauditfilter.c: 34110\naudit.h: 394\naudit_read.h: 127\nauditsc.c: 67706\naudit_signal.h: 36\naudit_tree.c: 22256\naudit_watch.c: 14765\naudit_write.h: 255\naureon.c: 64017\naureon.h: 2419\nautcpu12.c: 5831\nautcpu12.h: 2590\nautcpu12-nvram.c: 3124\nauth.c: 35\nauthenc.c: 13429\nauthenc.h: 609\nauth_generic.c: 4800\nauth_gss: 4096\nauth_gss.c: 40950\nauth_gss.h: 2256\nauth.h: 540\nauth_null.c: 2607\nauthorization.txt: 2640\nauthors: 38\nAUTHORS: 38\nauth_rsp.c: 39\nauth_unix.c: 5607\nauto_dev-ioctl.h: 5186\nautofs: 4096\nautofs4: 4096\nauto_fs4.h: 4095\nautofs4-mount-control.txt: 17706\nauto_fs.h: 2467\nautofs_i.h: 7355\nautoload.c: 967\nautoload.sh: 339\nautomount-support.txt: 4694\nautoprobe.c: 4772\nauxdisplay: 4096\nauxio_32.c: 3721\nauxio_32.h: 2622\nauxio_64.c: 3214\nauxio_64.h: 3266\nauxio.h: 176\naux_reg.h: 646\nauxvec.h: 60\nav7110: 4096\nav7110_av.c: 40033\nav7110_av.h: 1214\nav7110.c: 82729\nav7110_ca.c: 9180\nav7110_ca.h: 441\nav7110.h: 7155\nav7110_hw.c: 31995\nav7110_hw.h: 12512\nav7110_ipack.c: 7991\nav7110_ipack.h: 402\nav7110_ir.c: 11196\nav7110_v4l.c: 27884\navc.c: 24534\navc.h: 3102\navc_ss.h: 617\navermedia.txt: 13922\navila.h: 917\navila-pci.c: 1817\navila-setup.c: 4610\nav_inherit.h: 1693\navm: 4096\navm_a1.c: 8303\navma1_cs.c: 9468\navm_a1p.c: 7146\navmcard.h: 13933\navm_cs.c: 9107\navm_pci.c: 23187\nav_permissions.h: 53693\nav_perm_to_string.h: 10893\navr32: 4096\n__avr32_asr64.S: 560\navr32_ksyms.c: 1843\n__avr32_lsl64.S: 559\n__avr32_lsr64.S: 559\navtab.c: 12842\navtab.h: 2874\naw2: 4096\naw2-alsa.c: 22536\naw2-saa7146.c: 12816\naw2-saa7146.h: 3650\naw2-tsl.c: 4092\nawacs.c: 32895\nawacs.h: 8192\nax25: 4096\nax25_addr.c: 6217\nax25_dev.c: 4867\nax25_ds_in.c: 7261\nax25_ds_subr.c: 5218\nax25_ds_timer.c: 5960\nax25.h: 2752\nax25_iface.c: 5067\nax25_in.c: 10789\nax25_ip.c: 5405\nax25_out.c: 8933\nax25_route.c: 11432\nax25_std_in.c: 11343\nax25_std_subr.c: 2329\nax25_std_timer.c: 4335\nax25_subr.c: 7113\nax25_timer.c: 5261\nax25.txt: 610\nax25_uid.c: 5032\nax88796.c: 25354\nax88796.h: 751\naxisflashmap.c: 11854\naxisflashmap.h: 1932\naxnet_cs.c: 55656\naxon_msi.c: 11768\naxonram.c: 9510\nazt2320.c: 9995\nazt3328.c: 74771\nazt3328.h: 16466\nb128ops.h: 2471\nb180_defconfig: 30806\nb1.c: 20917\nb1dma.c: 24682\nb1isa.c: 6013\nb1lli.h: 1654\nb1pci.c: 10903\nb1pcmcia.c: 5718\nb1pcmcia.h: 666\nb2: 4096\nb2c2: 4096\nb3dfg: 4096\nb3dfg.c: 29136\nb43: 4096\nb43.h: 34564\nb43legacy: 4096\nb43legacy.h: 26792\nb43_pci_bridge.c: 1563\nb44.c: 58926\nb44.h: 17577\nba_action.c: 43\nbaboon.c: 2869\nbackchannel_rqst.c: 9002\nbackend-api.txt: 23417\nbackend.c: 8969\nbackground.c: 4246\nbacking-dev.c: 7753\nbacking-dev.h: 7625\nbacking_ops.c: 11152\nbacklight: 4096\nbacklight.c: 8488\nbacklight.h: 1076\nbackoff.h: 514\nbacktrace.c: 2048\nbacktrace.S: 3769\nbacktracetest.c: 2135\nbadge4.c: 7278\nbadge4_defconfig: 25237\nbadge4.h: 2530\nbad_inode.c: 8103\nbad_memory.txt: 1113\nbalance: 5103\nballoc.c: 28466\nballoon.c: 15823\nbamboo.c: 1219\nbamboo_defconfig: 23088\nbamboo.dts: 7833\nbarrier.h: 751\nbarrier.txt: 10841\nbase: 4096\nbaseband.c: 69836\nbaseband.h: 5142\nbase.c: 17017\nbase.h: 5692\nbase.S: 2976\nbas-gigaset.c: 70245\nbasic: 4096\nbasic-pm-debugging.txt: 10323\nbasic_profiling.txt: 1707\nbasler: 4096\nbast-cpld.h: 1556\nbast-ide.c: 2522\nbast-irq.c: 3575\nbast-irq.h: 842\nbast-map.h: 5001\nbast-pmu.h: 1140\nbattery.c: 26147\nbaycom_epp.c: 34930\nbaycom.h: 820\nbaycom_par.c: 16899\nbaycom_ser_fdx.c: 21220\nbaycom_ser_hdx.c: 21005\nbaycom.txt: 7038\nbbc_envctrl.c: 15825\nbbc.h: 9957\nbbc_i2c.c: 9865\nbbc_i2c.h: 1987\nbbm.h: 4408\nbcache.h: 1450\nbcast.c: 21337\nbcast.h: 5594\nbcd.c: 257\nbcd.h: 195\nbcm1480: 4096\nbcm1480_int.h: 18356\nbcm1480_l2c.h: 8696\nbcm1480_mc.h: 51843\nbcm1480_regs.h: 42338\nbcm1480_scd.h: 15457\nbcm203x.c: 7066\nbcm3510.c: 21894\nbcm3510.h: 1667\nbcm3510_priv.h: 9194\nbcm47xx: 4096\nbcm47xx_defconfig: 44162\nbcm47xx.h: 914\nbcm47xx_wdt.c: 6278\nbcm5974.c: 22743\nbcm5974.txt: 2275\nbcm.c: 39855\nbcm.h: 2057\nbcom_ata_task.c: 1873\nbcom_fec_rx_task.c: 2688\nbcom_fec_tx_task.c: 3548\nbcom_gen_bd_rx_task.c: 1901\nbcom_gen_bd_tx_task.c: 2118\nbc_svc.c: 2387\nbcu.c: 5507\nbc_xprt.h: 1873\nbdx.bin.ihex: 117765\nbeacon.c: 16577\nbearer.c: 17977\nbearer.h: 6277\nbeat.c: 5680\nbeat.h: 1477\nbeat_htab.c: 12023\nbeat_hvCall.S: 4654\nbeat_interrupt.c: 7398\nbeat_interrupt.h: 1147\nbeat_iommu.c: 3142\nbeat_smp.c: 2934\nbeat_spu_priv1.c: 5295\nbeat_syscall.h: 9338\nbeat_udbg.c: 2419\nbeat_wrapper.h: 7284\nbe_byteshift.h: 1424\nbe_cmds.c: 28134\nbe_cmds.h: 21092\nbeep.c: 7937\nbe_ethtool.c: 10213\nbefs: 4096\nbefs_fs_types.h: 5040\nbefs.h: 3265\nbefs.txt: 3636\nbe.h: 9794\nbe_hw.h: 6736\nbelkin_sa.c: 17581\nbelkin_sa.h: 5114\nbe_main.c: 53536\nbe_memmove.h: 770\nBenchmark.h: 14912\nbenet: 4096\nberry_charge.c: 5094\nbestcomm: 4096\nbestcomm.c: 13444\nbestcomm.h: 5696\nbestcomm_priv.h: 10178\nbe_struct.h: 749\nBF518F-EZBRD_defconfig: 30487\nbf518.h: 3233\nBF526-EZBRD_defconfig: 37925\nBF527-EZKIT_defconfig: 39344\nbf527.h: 3368\nBF533-EZKIT_defconfig: 27699\nbf533.h: 3987\nBF533-STAMP_defconfig: 31991\nbf537.h: 3679\nBF537-STAMP_defconfig: 33322\nBF538-EZKIT_defconfig: 31824\nbf538.h: 3110\nBF548-EZKIT_defconfig: 41918\nbf548.h: 3408\nbf54x-keys.c: 10383\nbf54x_keys.h: 373\nbf54x-lq043fb.c: 19521\nbf54x-lq043.h: 486\nBF561-EZKIT_defconfig: 27483\nbf561.h: 5899\nbf5xx-ac97.c: 10719\nbf5xx-ac97.h: 1698\nbf5xx-ac97-pcm.c: 13449\nbf5xx-ac97-pcm.h: 595\nbf5xx-ad1980.c: 3043\nbf5xx-ad73311.c: 6491\nbf5xx-i2s.c: 8397\nbf5xx-i2s.h: 321\nbf5xx-i2s-pcm.c: 7810\nbf5xx-i2s-pcm.h: 591\nbf5xx_nand.c: 19911\nbf5xx-sport.c: 26015\nbf5xx-sport.h: 5191\nbf5xx-ssm2602.c: 4846\nbfin_5xx.c: 37574\nbfin5xx_spi.h: 3282\nbfin-async-flash.c: 5961\nbfin_cf_pcmcia.c: 8045\nbfind.c: 4484\nbfin_dma_5xx.c: 13838\nbfin-global.h: 3579\nbfin_gpio.c: 31670\nbfin-gpio-notes.txt: 2459\nbfin_jtag_comm.c: 9699\nbfin_ksyms.c: 3302\nbfin_mac.c: 29136\nbfin_mac.h: 1654\nbfin_oprofile.c: 303\nbfin-otp.c: 4874\nbfin_sdh.h: 273\nbfin_serial_5xx.h: 5124\nbfin_simple_timer.h: 446\nbfin_sir.c: 18943\nbfin_sir.h: 5300\nbfin_sport.h: 3839\nbfin_sport_uart.c: 16463\nbfin_sport_uart.h: 3726\nbfin-t350mcqb-fb.c: 16570\nbfin_wdt.c: 11813\nbfrom.h: 3443\nbfs: 4096\nbfs_fs.h: 1830\nbfs.h: 1424\nbfs.txt: 2118\nbfusb.c: 17036\nbif_core_defs_asm.h: 15240\nbif_core_defs.h: 9672\nbif_dma_defs_asm.h: 22539\nbif_dma_defs.h: 14998\nbif_slave_defs_asm.h: 11664\nbif_slave_defs.h: 8256\nbig_endian.h: 3729\nbig-endian.S: 304\nBIG.FAT.WARNING: 234\nbigsmp_32.c: 6414\nbigsur_defconfig: 32018\nbigsur.h: 1540\nbin2c.c: 702\nbin2hex.c: 755\nbin.c: 11164\nbind_addr.c: 13678\nbind.c: 7327\nbindec.S: 28113\nbinder.c: 105864\nbinder.h: 9073\nbind.h: 1305\nbinding.txt: 3687\nbinfmt_aout.c: 13156\nbinfmt_elf32.c: 3565\nbinfmt_elf.c: 55465\nbinfmt_elf_fdpic.c: 48887\nbinfmt_elfn32.c: 3368\nbinfmt_elfo32.c: 4508\nbinfmt_em86.c: 2848\nbinfmt_flat.c: 27410\nbinfmt_loader.c: 1116\nbinfmt_misc.c: 15436\nbinfmt_misc.txt: 6108\nbinfmt_script.c: 2829\nbinfmts.h: 4146\nbinfmt_som.c: 7567\nbinoffset.c: 4039\nbinstr.S: 4302\nbio.c: 39950\nbiodoc.txt: 55452\nbio.h: 20583\nbio-integrity.c: 21385\nbios32.c: 17673\nbios.c: 2953\nbioscall.S: 1566\nbioscalls.c: 13235\nbios_ebda.h: 794\nbios.h: 3282\nbios_uv.c: 4629\nbitblit.c: 10909\nbitext.c: 2979\nbitext.h: 613\nbitfield.h: 19835\nbitmap.c: 45202\nbitmap.h: 10515\nbit_operations.h: 5627\nbitops: 4096\nbitops_32.h: 2988\nbitops_64.h: 2428\nbitops.c: 1091\nbitops-grb.h: 6325\nbitops.h: 3153\nbitops-llsc.h: 2819\nbitops_mm.h: 11048\nbitops_no.h: 8097\nbitops-op32.h: 3832\nbitops.S: 2667\nbitrev.c: 2157\nbitrev.h: 270\nbits.h: 2634\nbitsperlong.h: 37\nbit_spinlock.h: 2210\nbitstream.bin.ihex: 33395\nbitstream.HEX: 192281\nbkm_a4t.c: 9149\nbkm_a8.c: 11765\nbkm_ax.h: 4575\nblackfin: 4096\nblackfin.c: 7552\nblackfin.h: 1089\nblackfin_sram.h: 1207\nblacklist.c: 8658\nblacklist.h: 108\nblackstamp.c: 9838\nBlackStamp_defconfig: 27434\nblinken.h: 617\nblizzard.c: 41338\nblizzard.h: 249\nblk-barrier.c: 9923\nblkcipher.c: 19013\nblk-core.c: 65533\nblkdev.h: 38233\nblk-exec.c: 2683\nblk.h: 4565\nblkif.h: 3398\nblk-integrity.c: 10137\nblk-ioc.c: 4083\nblk-map.c: 8314\nblk-merge.c: 9996\nblkpg.h: 1569\nblk-settings.c: 21842\nblk-softirq.c: 4192\nblk-sysfs.c: 12022\nblk-tag.c: 10090\nblk-timeout.c: 5850\nblktrace_api.h: 7347\nblktrace.c: 40749\nblktrans.h: 1935\nbloat-o-meter: 1711\nblock: 4096\nblock2mtd.c: 10757\nblock.c: 15974\nblockcheck.c: 16817\nblockcheck.h: 3928\nblockdev: 4096\nblock_dev.c: 37737\nblockgroup_lock.h: 1164\nblock.h: 12870\nblockops.S: 2573\nblock_validity.c: 6187\nblowfish.c: 17890\nbluecard_cs.c: 21854\nbluetooth: 4096\nbluetooth.h: 4823\nbmac.c: 42545\nbmac.h: 8220\nbmap.c: 17082\nbmap.h: 8896\nbmap_union.h: 1274\nbnep: 4096\nbnep.h: 4313\nbnode.c: 15448\nbnx2: 4096\nbnx2.c: 204472\nbnx2_fw.h: 2909\nbnx2.h: 328128\nbnx2i: 4096\nbnx2i.h: 23900\nbnx2i_hwi.c: 73780\nbnx2i_init.c: 11868\nbnx2i_iscsi.c: 56395\nbnx2i_sysfs.c: 3632\nbnx2-mips-06-4.6.16.fw.ihex: 255140\nbnx2-mips-09-4.6.17.fw.ihex: 255536\nbnx2-rv2p-06-4.6.16.fw.ihex: 19256\nbnx2-rv2p-09-4.6.15.fw.ihex: 21444\nbnx2x_dump.h: 28960\nbnx2x-e1-4.8.53.0.fw.ihex: 455912\nbnx2x-e1h-4.8.53.0.fw.ihex: 529144\nbnx2x_fw_defs.h: 15968\nbnx2x_fw_file_hdr.h: 1226\nbnx2x.h: 36495\nbnx2x_hsi.h: 87970\nbnx2x_init.h: 12172\nbnx2x_init_ops.h: 12435\nbnx2x_link.c: 162411\nbnx2x_link.h: 6119\nbnx2x_main.c: 321334\nbnx2x_reg.h: 308654\nboard-1arm.c: 2699\nboard-2430sdp.c: 5365\nboard-3430sdp.c: 12788\nboard-4430sdp.c: 2343\nboard-a9m9750dev.c: 3624\nboard-a9m9750dev.h: 478\nboard-acs5k.c: 5495\nboard-afeb-9260v1.c: 5234\nboard-ams-delta.c: 6109\nboard-ams-delta.h: 3023\nboard-ap325rxa.c: 13583\nboard-apollon.c: 8566\nboard-armadillo5x0.h: 564\nboard.c: 3934\nboard-cam60.c: 4681\nboard-cap9adk.c: 9718\nboard-carmeva.c: 4435\nboard-csb337.c: 6265\nboard-csb637.c: 3642\nboard-dk.c: 5862\nboard-dm355-evm.c: 7541\nboard-dm355-leopard.c: 7584\nboard-dm644x-evm.c: 17303\nboard-dm646x-evm.c: 5912\nboard-dsm320.c: 2919\nboard-eb01.c: 1385\nboard-eb9200.c: 3461\nboard-eb.h: 3843\nboard-ecbat91.c: 4404\nboard-edosk7760.c: 4611\nboard-ek.c: 5054\nboardergo.c: 16200\nboardergo.h: 4069\nboard-espt.c: 2426\nboard-fsample.c: 8474\nboard-generic.c: 1918\nboard.h: 3611\nboard-h2.c: 10497\nboard-h2.h: 1585\nboard-h2-mmc.c: 1862\nboard-h3.c: 9698\nboard-h3.h: 1550\nboard-h3-mmc.c: 1668\nboard-h4.c: 9524\nboard-halibut.c: 2112\nboard-innovator.c: 10872\nboard-jscc9p9360.c: 457\nboard-jscc9p9360.h: 390\nboard-kafa.c: 2778\nboard-kb9202.c: 3738\nboard-ldp.c: 9161\nboard-magicpanelr2.c: 11382\nboard-micrel.c: 1450\nboard-mx21ads.h: 1998\nboard-mx27ads.h: 10858\nboard-mx27lite.h: 544\nboard-mx27pdk.h: 541\nboard-mx31ads.h: 3850\nboard-mx31lilly.h: 1430\nboard-mx31lite.h: 508\nboard-mx31moboard.h: 1408\nboard-mx31pdk.h: 2120\nboard-mx35pdk.h: 1062\nboard-neocore926.c: 9196\nboard-nokia770.c: 9780\nboard-omap3beagle.c: 10647\nboard-omap3evm.c: 7649\nboard-omap3pandora.c: 10350\nboard-osk.c: 15556\nboard-overo.c: 11768\nboard-palmte.c: 9495\nboard-palmtt.c: 7148\nboard-palmz71.c: 8139\nboard-pb1176.h: 3534\nboard-pb11mp.h: 3933\nboard-pba8.h: 3279\nboard-pbx.h: 4735\nboard-pcm037.h: 1039\nboard-pcm038.h: 1428\nboard-pcm043.h: 1039\nboard-perseus2.c: 7106\nboard-picotux200.c: 4544\nboard-polaris.c: 3273\nboard-qil-a9260.c: 6417\nboard-qong.h: 590\nboard-rut1xx.c: 2111\nboard-rx51.c: 2237\nboard-rx51-peripherals.c: 9630\nboards: 4096\nboard-sam9260ek.c: 8166\nboard-sam9261ek.c: 14425\nboard-sam9263ek.c: 10154\nboard-sam9g20ek.c: 7036\nboard-sam9-l9260.c: 5065\nboard-sam9rlek.c: 5294\nboards.c: 9634\nboard-se7619.c: 368\nboard_setup.c: 991\nboard-sffsdr.c: 5298\nboards.h: 874\nboard-sh7785lcr.c: 8051\nboard-shmin.c: 715\nboard-sx1.c: 10319\nboard-sx1.h: 1472\nboard-sx1-mmc.c: 1614\nboard.txt: 1400\nboard-urquell.c: 4834\nboard-usb-a9260.c: 5382\nboard-usb-a9263.c: 5692\nboard-voiceblue.c: 6718\nboard-voiceblue.h: 552\nboard-yl-9200.c: 19259\nboard-zoom2.c: 2568\nboard-zoom-debugboard.c: 3833\nbond_3ad.c: 81880\nbond_3ad.h: 9440\nbond_alb.c: 45790\nbond_alb.h: 4802\nbonding: 4096\nbonding.h: 10602\nbonding.txt: 98243\nbond_ipv6.c: 5432\nbond_main.c: 137243\nbond_sysfs.c: 42050\nbonito64.h: 16247\nbonito-irq.c: 2465\nbooke.c: 16034\nbooke_emulate.c: 6991\nbooke.h: 2429\nbooke_interrupts.S: 11644\nbooke_wdt.c: 4745\nboot: 4096\nboot2.H16: 14566\nboot.c: 8143\nbootcode.bin.ihex: 604\nboot-elf: 4096\nbootflag.c: 1698\nbootgraph.pl: 5753\nboot.h: 1195\nboot.H16: 14980\nboot_head.S: 4023\nbootinfo.h: 3250\nBooting: 4704\nbooting.txt: 5755\nbooting-without-of.txt: 61721\nboot.ld: 812\nboot.lds.S: 927\nbootloader.c: 3823\nbootloader.lds: 501\nbootlogo.h: 236895\nbootlogo.pl: 165\nbootmem.c: 19242\nbootmem.h: 4841\nboot-options.txt: 12803\nbootp: 4096\nbootparam.h: 1530\nbootp.c: 5689\nbootp.lds: 695\nbootpz.c: 13415\nboot-redboot: 4096\nBoot.S: 2820\nbootstd.h: 4709\nbootstr_32.c: 1207\nbootstr_64.c: 1055\nbootstrap.asm: 2924\nbootstrap.bin.ihex: 1080\nbootstrap.S: 4829\nboot.txt: 35058\nbootwrapper.txt: 7768\nbootx.h: 5211\nbootx_init.c: 16762\nbottom_half.h: 224\nbounce.c: 6616\nbounds.c: 526\nbpa10x.c: 10967\nbpck6.c: 6457\nbpck.c: 9505\nbpqether.c: 14923\nbpqether.h: 952\nbq24022.c: 4006\nbq24022.h: 728\nbq27x00_battery.c: 8343\nbr2684.c: 20774\nbraille: 4096\nbraille_console.c: 8194\nbraille-console.txt: 1458\nbranch.c: 5609\nbranches: 4096\nbranch.h: 794\nbr.c: 2297\nbrcmphy.h: 277\nbrd.c: 13994\nbr_device.c: 4305\nbreak.h: 1512\nbreak.S: 20777\nbrec.c: 13153\nbr_fdb.c: 10129\nbr_forward.c: 3296\nbrg.txt: 450\nbridge: 4096\nbridge.h: 29862\nbridge-regs.h: 1121\nbridge.txt: 382\nbr_if.c: 9454\nbr_input.c: 4146\nbr_ioctl.c: 9353\nbriq_panel.c: 5383\nbrl_emu.c: 5592\nbr_netfilter.c: 28764\nbr_netlink.c: 4931\nbr_notify.c: 2202\nbroadcom.c: 17870\nbroadsheetfb.c: 13698\nbroadsheetfb.h: 1727\nbr_private.h: 7906\nbr_private_stp.h: 1654\nbr_stp_bpdu.c: 5251\nbr_stp.c: 11134\nbr_stp_if.c: 7340\nbr_stp_timer.c: 4651\nbr_sysfs_br.c: 12447\nbr_sysfs_if.c: 6540\nBrutus: 1927\nbsbe1.h: 3346\nbsd_comp.c: 29587\nbsg.c: 23964\nbsg.h: 3096\nbsr.c: 8971\nbsru6.h: 3855\nbssdb.c: 59681\nbssdb.h: 9978\nbt3c_cs.c: 16786\nbt431.h: 5854\nbt455.h: 2096\nbt819.c: 14549\nbt819.h: 1082\nbt848.h: 11788\nbt856.c: 7085\nbt866.c: 6222\nbt878.c: 16114\nbt878.h: 4113\nbt87x.c: 30530\nBt87x.txt: 2597\nbt8xx: 4096\nbt8xxgpio.c: 8476\nbt8xxgpio.txt: 4402\nbt8xx.txt: 3940\nbtaudio: 3104\nbtcx-risc.c: 6470\nbtcx-risc.h: 863\nbte.c: 12913\nbte_error.c: 7665\nbte.h: 7765\nbtext.c: 38463\nbtext.h: 858\nbtfixup.c: 10268\nbtfixup.h: 7304\nbtfixupprep.c: 11589\nbtnode.c: 8474\nbtnode.h: 2067\nbtree.c: 8032\nbtree.h: 5488\nbtrfs: 4096\nbtrfs_inode.h: 4339\nbtrfs.txt: 2918\nbtsdio.c: 8446\nbttv: 4096\nbttv-audio-hook.c: 9617\nbttv-audio-hook.h: 1126\nbttv-cards.c: 151213\nbttv-driver.c: 121604\nbttv-gpio.c: 4858\nbttv.h: 14877\nbttv-i2c.c: 10677\nbttv-if.c: 2894\nbttv-input.c: 10597\nbttvp.h: 14108\nbttv-risc.c: 25965\nbttv-vbi.c: 12835\nbtuart_cs.c: 15857\nbtusb.c: 24625\nbuddha.c: 5673\nbudget-av.c: 45832\nbudget.c: 23026\nbudget-ci.c: 46442\nbudget-core.c: 17319\nbudget.h: 3030\nbudget-patch.c: 20598\nbuffer.c: 3308\nbuffer-format.txt: 4606\nbuffer_head.h: 11463\nbuffer_head_io.c: 10961\nbuffer_head_io.h: 2416\nbuffer_icap.c: 10726\nbuffer_icap.h: 2297\nbuffer_sync.c: 13744\nbuffer_sync.h: 432\nbug.c: 423\nbugfix.S: 14062\nbug.h: 400\nBUG-HUNTING: 8326\nBUGS: 235\nbugs_64.c: 778\nbugs.c: 1893\nbugs.h: 451\nBUGS-parport: 319\nbuild.c: 39439\nbuilddeb: 5872\nbuildtar: 2659\nbuiltin-annotate.c: 29512\nbuiltin.h: 1035\nbuiltin-help.c: 11520\nbuiltin-list.c: 408\nbuiltin-record.c: 14786\nbuiltin-report.c: 35243\nbuiltin-stat.c: 13788\nbuiltin-top.c: 17061\nbunzip2.h: 258\nburgundy.c: 25045\nburgundy.h: 4105\nbus.c: 8958\nbusctl-regs.h: 2071\nbus.h: 950\nBusLogic.c: 151498\nBusLogic.h: 40976\nBusLogic.txt: 26440\nbus-osm.c: 4125\nbusses: 4096\nbust_spinlocks.c: 636\nbus.txt: 4536\nbus_watcher.c: 7864\nbutterfly: 2990\nbutton.c: 12060\nbuttons.c: 1516\nbvme6000: 4096\nbvme6000_defconfig: 24611\nbvme6000hw.h: 3490\nbvme6000_scsi.c: 3343\nbw2.c: 9440\nbw-qcam.c: 25715\nbw-qcam.h: 2049\nbyteorder: 4096\nbyteorder.h: 277\nbzero.S: 3581\nc101.c: 11218\nc16e9e8bb74f14f4504305957e4346e7fc46ea: 296\nc2_ae.c: 9166\nc2_ae.h: 3338\nc2_alloc.c: 4106\nc2.c: 33727\nc2_cm.c: 9984\nc2_cq.c: 10526\nc2.h: 13957\nc2_intr.c: 5630\nc2k.c: 3705\nc2k_defconfig: 48649\nc2k.dts: 8777\nc2_mm.c: 8862\nc2_mq.c: 4622\nc2_mq.h: 3238\nc2p_core.h: 2688\nc2_pd.c: 3012\nc2p.h: 631\nc2p_iplan2.c: 3576\nc2port: 4096\nc2port-duramar2150.c: 3241\nc2port.h: 1788\nc2port.txt: 2848\nc2p_planar.c: 3697\nc2_provider.c: 21747\nc2_provider.h: 4101\nc2_qp.c: 25022\nc2_rnic.c: 16782\nc2_status.h: 5103\nc2_user.h: 2415\nc2_vq.c: 7741\nc2_vq.h: 2530\nc2_wr.h: 35475\nc3000_defconfig: 37418\nc4.c: 33871\nc67x00: 4096\nc67x00-drv.c: 6069\nc67x00.h: 9392\nc67x00-hcd.c: 10012\nc67x00-hcd.h: 4298\nc67x00-ll-hpi.c: 12221\nc67x00-sched.c: 30459\nc6xdigio.c: 13668\nca0106: 4096\nca0106.h: 37992\nca0106_main.c: 59396\nca0106_mixer.c: 27767\nca0106_proc.c: 14457\ncacheasm.h: 3274\ncache.c: 10301\ncache-c.c: 733\ncachectl.h: 752\ncache-debugfs.c: 3861\ncache-fa.S: 5726\ncachefeatures.txt: 1538\ncache-feroceon-l2.c: 8394\ncache-feroceon-l2.h: 358\ncachefiles: 4096\ncachefiles.txt: 17132\ncacheflush_32.h: 3544\ncacheflush_64.h: 2543\ncacheflush.h: 7154\ncacheflush_mm.h: 4194\ncache-flush-mn10300.S: 5528\ncacheflush_no.h: 2672\ncacheflush.S: 1897\ncache.h: 4660\ncacheinfo.c: 20221\ncacheinfo.h: 240\ncacheinit.c: 1960\ncache-l2x0.c: 3064\ncache-l2x0.h: 1931\ncache-lock.txt: 1222\ncache-mn10300.S: 6477\ncacheops.h: 2183\ncache-page.c: 1964\ncache.S: 2858\ncache-sh2a.c: 3241\ncache-sh2.c: 2044\ncache-sh3.c: 2486\ncache-sh4.c: 20825\ncache-sh5.c: 27270\ncache-sh7705.c: 5050\ncachetlb.txt: 16265\ncachetype.h: 1643\ncache-v3.S: 3174\ncache-v4.S: 3364\ncache-v4wb.S: 5731\ncache-v4wt.S: 4411\ncache-v6.S: 6450\ncache-v7.S: 7015\ncache-xsc3l2.c: 5806\ncaching: 4096\ncafe_ccic: 2424\ncafe_ccic.c: 53700\ncafe_ccic-regs.h: 6845\ncafe_nand.c: 25500\ncagg.c: 110445\ncagg.h: 15067\nca.h: 3022\ncaiaq: 4096\ncaleb.c: 3138\ncaleb.h: 636\ncalgary.h: 2452\ncalib.c: 28905\ncalib.h: 3835\ncalibrate.c: 5121\ncallback.c: 9965\ncallback.h: 2994\ncallback_proc.c: 6012\ncallbacks.c: 7878\ncallbacks.h: 1495\ncallback_srm.S: 2840\ncallbacks.txt: 4860\ncallback_xdr.c: 18050\ncallc.c: 48919\ncallchain.c: 3746\ncallchain.h: 711\ncall_hpt.h: 3078\ncalling.h: 5596\ncall_o32.S: 2534\ncall_pci.h: 7934\ncall_sm.h: 1270\ncalls.S: 10619\ncam60_defconfig: 28038\ncamellia.c: 35950\ncamera.h: 1504\ncam.h: 4590\nca_midi.c: 8689\nca_midi.h: 2024\ncan: 4096\ncan.h: 3326\ncan.txt: 35254\ncanyonlands_defconfig: 25711\ncanyonlands.dts: 14369\ncapability.c: 8203\ncapability.h: 17864\ncapability.txt: 618\ncapcella_defconfig: 18424\ncapcella.h: 1486\ncapi: 4096\ncapi20.h: 29357\ncapi.c: 33038\ncapicmd.h: 4663\ncapidrv.c: 64650\ncapidrv.h: 4862\ncapidtmf.c: 26932\ncapidtmf.h: 3726\ncapifs.c: 5266\ncapifs.h: 360\ncapifunc.c: 31377\ncapifunc.h: 903\ncapi.h: 10360\ncapilib.c: 4606\ncapilli.h: 3567\ncapimain.c: 3336\ncapiutil.c: 30023\ncapiutil.h: 14649\ncapmode.c: 8041\ncaps.c: 5160\ncapture.c: 9562\ncapture.h: 702\ncard: 4096\ncardbus.c: 6323\ncard.c: 10228\ncard.h: 4366\nCARDLIST.au0828: 527\nCARDLIST.bttv: 9061\nCARDLIST.cx23885: 1693\nCARDLIST.cx88: 5876\nCARDLIST.em28xx: 4880\nCARDLIST.ivtv: 1163\nCARDLIST.saa7134: 9829\nCARDLIST.tuner: 2995\nCARDLIST.usbvision: 4940\nCards: 26708\ncards.txt: 4752\ncardtype.h: 39894\ncarmel.h: 1969\ncarmeva_defconfig: 13180\ncarminefb.c: 22690\ncarminefb.h: 2251\ncarminefb_regs.h: 6940\ncarta_random.S: 1032\ncasio-e55: 4096\ncassini.bin.ihex: 6246\ncassini.c: 145494\ncassini.h: 125724\ncast5.c: 34939\ncast6.c: 22021\ncatalog.c: 10749\ncatas.c: 4281\ncatc.c: 24085\ncats-hw.c: 2052\ncats-pci.c: 1313\ncavium-octeon: 4096\ncavium-octeon_defconfig: 22786\ncayman_defconfig: 31979\ncb710: 4096\ncb710.h: 6584\ncb710-mmc.c: 22406\ncb710-mmc.h: 3337\ncbaf.c: 20405\ncbc.c: 7621\ncb_das16_cs.c: 25977\ncbe_cpufreq.c: 4980\ncbe_cpufreq.h: 578\ncbe_cpufreq_pervasive.c: 2924\ncbe_cpufreq_pmi.c: 3695\ncbe_powerbutton.c: 3019\ncbe_regs.c: 6692\ncbe_thermal.c: 10724\ncb_pcidas64.c: 122559\ncb_pcidas.c: 54058\ncb_pcidda.c: 24298\ncb_pcidio.c: 9309\ncb_pcimdas.c: 14161\ncb_pcimdda.c: 15282\ncchips: 4096\nccid2.c: 21699\nccid2.h: 2480\nccid3.c: 29348\nccid3.h: 6401\nccid.c: 5450\nccid.h: 7568\nccids: 4096\nccio-dma.c: 48900\nccio-rm-dma.c: 5203\ncciss.c: 121676\ncciss_cmd.h: 8834\ncciss.h: 7343\ncciss_ioctl.h: 6805\ncciss_scsi.c: 49769\ncciss_scsi.h: 3184\ncciss.txt: 6396\nccm.c: 22059\nccmd.c: 47173\nccwdev.h: 6880\nccwgroup.c: 16375\nccwgroup.h: 2479\ncd1400.h: 7059\ncd1865.h: 13309\ncd32.txt: 535\ncda2df87ba4ecc7988be7a45d01645e11c9f4c: 307\ncdb89712.c: 5870\ncdc2.c: 6912\ncdc-acm.c: 43081\ncdc-acm.h: 3737\ncdc_eem.c: 9394\ncdc_ether.c: 17432\ncdc.h: 7100\ncdc_subset.c: 10970\ncdc-wdm.c: 19634\ncdefBF512.h: 1386\ncdefBF514.h: 5819\ncdefBF516.h: 16666\ncdefBF518.h: 16668\ncdefBF51x_base.h: 71524\ncdefBF522.h: 1386\ncdefBF525.h: 26762\ncdefBF527.h: 37609\ncdefBF52x_base.h: 71524\ncdefBF532.h: 48301\ncdefBF534.h: 124785\ncdefBF537.h: 13187\ncdefBF538.h: 148152\ncdefBF539.h: 16826\ncdefBF542.h: 35078\ncdefBF544.h: 59758\ncdefBF547.h: 48769\ncdefBF548.h: 98262\ncdefBF549.h: 115636\ncdefBF54x_base.h: 169306\ncdefBF561.h: 117485\ncdef_LPBlackfin.h: 20055\ncdev.c: 25135\ncdev.h: 677\ncdk.h: 12770\ncdrom: 4096\ncdrom.c: 99243\ncdrom.h: 36224\ncdrom-standard.tex: 51371\ncdrom.txt: 19223\ncds.txt: 21022\nce6230.c: 8126\nce6230.h: 2306\nceiva.c: 7563\ncell: 4096\ncell.c: 9326\ncell_defconfig: 37867\ncelleb_defconfig: 32091\ncelleb_pci.c: 12369\ncelleb_pci.h: 1402\ncelleb_scc_epci.c: 10052\ncelleb_scc.h: 7871\ncelleb_scc_pciex.c: 15023\ncelleb_scc_sio.c: 2600\ncelleb_scc_uhc.c: 2518\ncelleb_setup.c: 6097\ncell_edac.c: 7394\ncell-pmu.h: 4133\ncell-regs.h: 9211\ncentaur.c: 5432\ncentral.c: 6181\nCERF: 1215\ncerf.c: 3449\ncerfcube_defconfig: 17978\ncerf.h: 810\ncerr-sb1.c: 16742\ncevt-bcm1480.c: 4444\ncevt-ds1287.c: 2833\ncevt-gt641xx.c: 3662\ncevt-r4k.c: 5115\ncevt-r4k.h: 1421\ncevt-sb1250.c: 4380\ncevt-smtc.c: 8920\ncevt-txx9.c: 5694\ncex-gen.S: 1009\ncex-oct.S: 1574\ncex-sb1.S: 4707\ncfag12864b: 3173\ncfag12864b.c: 8350\ncfag12864b-example.c: 5897\ncfag12864bfb.c: 4656\ncfag12864b.h: 2147\ncfbcopyarea.c: 11312\ncfbfillrect.c: 8940\ncfbimgblt.c: 8396\ncfe: 4096\ncfe_api.c: 11219\ncfe_api.h: 3833\ncfe_api_int.h: 4031\ncfe.c: 8423\ncfe_console.c: 1737\ncfe_error.h: 2197\ncfg80211.c: 10563\ncfg80211.h: 1079\ncfg.c: 35379\ncfg.h: 155\ncfi_cmdset_0001.c: 73671\ncfi_cmdset_0002.c: 53117\ncfi_cmdset_0020.c: 38615\ncfi_endian.h: 1238\ncfi_flagadm.c: 3947\ncfi.h: 13714\ncfi_probe.c: 11670\ncfi_util.c: 5934\ncfm.c: 16482\ncfq-iosched.c: 65456\ncfunc.c: 33674\ncfunc.h: 23021\ncg14.c: 15044\ncg3.c: 11707\ncg6.c: 22284\ncgroup.c: 95997\ncgroup_debug.c: 2057\ncgroup_freezer.c: 9146\ncgroup.h: 15604\ncgroups: 4096\ncgroupstats.h: 2155\ncgroupstats.txt: 1307\ncgroups.txt: 21831\ncgroup_subsys.h: 697\nch341.c: 15479\nch9.h: 24667\nchafsr.h: 9671\nchainiv.c: 8763\nchangebit.S: 617\nChangeLog: 18049\nCHANGELOG: 18049\nChangeLog.1992-1997: 59954\nChangeLog.arcmsr: 6754\nChangeLog.history: 25741\nChangeLog.ide-cd.1994-2004: 15586\nChangeLog.ide-floppy.1996-2002: 4068\nChangeLog.ide-tape.1995-2002: 16249\nChangeLog.ips: 5304\nChangeLog.lpfc: 89671\nChangeLog.megaraid: 23975\nChangeLog.megaraid_sas: 12624\nChangeLog.ncr53c8xx: 22786\nChangeLog.sym53c8xx: 29464\nChangeLog.sym53c8xx_2: 6011\nChanges: 4725\nCHANGES: 4725\nchan_kern.c: 13142\nchan_kern.h: 1587\nchan_user.c: 7101\nchan_user.h: 1710\nchar: 4096\nchar_dev.c: 13712\nchb.c: 5975\nch.c: 24601\ncheck-all.sh: 434\ncheck.c: 3835\ncheck-gas: 277\ncheck-gas-asm.S: 37\ncheck.h: 551\ncheckincludes.pl: 529\ncheckkconfigsymbols.sh: 1851\nchecklist.c: 8211\nchecklist.txt: 14315\ncheck-lxdialog.sh: 1653\ncheck-model.c: 47\ncheckpatch.pl: 70566\ncheckpoint.c: 21921\nchecks.c: 15663\ncheck-segrel.lds: 203\ncheck-segrel.S: 45\ncheck-serialize.S: 41\ncheck.sh: 214\ncheck_signature.c: 599\ncheckstack.pl: 5332\nchecksum_32.h: 4895\nchecksum_32.S: 4739\nchecksum_64.h: 5349\nchecksum_64.S: 6192\nchecksum.c: 4610\nchecksumcopy.S: 2455\nchecksum.h: 6169\nchecksum_mm.h: 3391\nchecksum_no.h: 3074\nchecksum.S: 9073\nchecksyscalls.sh: 5661\ncheck-text-align.S: 69\ncheckversion.pl: 1867\nchelsio: 4096\ncherrs.S: 15233\nchio.h: 5287\nchip.c: 15518\nchip.h: 5099\nchipram.c: 3350\nchipreg.c: 2405\nchips: 4096\nchipsfb.c: 12752\nchlist.h: 30\nchmc.c: 20666\nchmctrl.h: 8057\nchp.c: 17406\nchp.h: 1489\nchpid.h: 1040\nchrp: 4096\nchrp32_defconfig: 40160\nchrp.h: 308\nchsc.c: 22534\nchsc.h: 2470\nchsc_sch.c: 19838\nchsc_sch.h: 179\nchunk.c: 8172\nci13xxx_udc.c: 69484\nci13xxx_udc.h: 6227\ncia.c: 4343\ncicada.c: 3994\ncic.c: 14355\ncifs: 4096\ncif.S: 1000\ncifsacl.c: 21375\ncifsacl.h: 2405\ncifs_debug.c: 21856\ncifs_debug.h: 2329\ncifs_dfs_ref.c: 9982\ncifsencrypt.c: 12795\ncifsencrypt.h: 1256\ncifsfs.c: 31585\ncifsfs.h: 4854\ncifs_fs_sb.h: 2432\ncifsglob.h: 23265\ncifspdu.h: 81322\ncifsproto.h: 16968\ncifssmb.c: 173618\ncifs_spnego.c: 4357\ncifs_spnego.h: 1628\ncifs.txt: 2406\ncifs_unicode.c: 7190\ncifs_unicode.h: 8878\ncifs_uniupr.h: 12874\ncimax2.c: 11227\ncimax2.h: 1921\ncinergyT2-core.c: 6717\ncinergyT2-fe.c: 8456\ncinergyT2.h: 3001\ncinit.c: 59044\ncio: 4096\ncio.c: 27748\ncio_debug.h: 849\ncio.h: 4879\ncipher.c: 7783\ncipso_ipv4.c: 64343\ncipso_ipv4.h: 7616\ncipso_ipv4.txt: 2252\ncirc_buf.h: 1000\ncirrusfb.c: 77607\ncirrusfb.txt: 1934\ncirrus.h: 8939\ncis: 4096\nciscode.h: 3364\ncisreg.h: 2804\ncistpl.c: 38770\ncistpl.h: 14596\nci.txt: 6753\nck804xrom.c: 10948\nclass: 4096\nclass.c: 12662\nclass_to_string.h: 1508\nclass.txt: 4758\nclaw.c: 115821\nclaw.h: 14619\nclcd.c: 5668\nclcd.h: 6601\ncleanfile: 3492\ncleanpatch: 5132\ncleanup.c: 28008\nclearbit.S: 613\nclear_page_64.S: 969\nclear_page.S: 401\nclear_user.S: 2687\nclep7312.c: 1478\nclient.c: 45575\nclient.h: 7071\nclinkage.h: 27\nclip.c: 24997\nclk.c: 774\nclkdev.c: 3488\nclkdev.h: 122\nclkgen_defs_asm.h: 7393\nclkgen_defs.h: 5421\nclk.h: 4465\nclk_interface.h: 683\nclksupport.h: 844\nclk.txt: 1173\nclnt.c: 42336\nclnt.h: 5095\nclntlock.c: 6865\nclntproc.c: 21263\nclock24xx.c: 22943\nclock24xx.h: 82888\nclock34xx.c: 31225\nclock34xx.h: 84973\nclock-7x01a.c: 4770\nclock.c: 6387\nclockchips.h: 4535\nclock-cpg.c: 5839\nclock-dclk.c: 4423\nclockdomain.c: 16366\nclockdomain.h: 3231\nclockdomains.h: 9108\nclockevents.c: 6244\nclock_getres.S: 1020\nclock_gettime.S: 2948\nclock.h: 1320\nclock_imx21.c: 23302\nclock_imx27.c: 22042\nclock-imx35.c: 13016\nclocking.txt: 1582\nclocks.c: 2153\nclocks.h: 2092\nclock-sh3.c: 2204\nclock-sh4-202.c: 3818\nclock-sh4.c: 1967\nclock-sh5.c: 1848\nclock-sh7201.c: 1982\nclock-sh7203.c: 1936\nclock-sh7206.c: 1931\nclock-sh7343.c: 6574\nclock-sh7366.c: 6500\nclock-sh7619.c: 1741\nclock-sh7705.c: 2140\nclock-sh7706.c: 2055\nclock-sh7709.c: 2302\nclock-sh7710.c: 1874\nclock-sh7712.c: 1592\nclock-sh7722.c: 5683\nclock-sh7723.c: 7223\nclock-sh7724.c: 7654\nclock-sh7763.c: 2503\nclock-sh7770.c: 1749\nclock-sh7780.c: 2630\nclock-sh7785.c: 3792\nclock-sh7786.c: 3252\nclock-shx3.c: 2959\nclocks-init.c: 2524\nclocksource: 4096\nclocksource.c: 16881\nclocksource.h: 11531\nclock.txt: 2443\nclone.c: 1295\nclps7111.h: 5605\nclps711x.c: 13340\nclps711xfb.c: 10751\ncls_api.c: 14078\ncls_basic.c: 6522\ncls_cgroup.c: 6506\ncls_flow.c: 15621\ncls_fw.c: 8499\ncls_route.c: 12482\ncls_rsvp6.c: 768\ncls_rsvp.c: 761\ncls_rsvp.h: 14927\ncls_tcindex.c: 11961\ncls_u32.c: 16562\ncluster: 4096\ncluster.c: 14916\ncluster.h: 3649\nclut_vga16.ppm: 230\ncm109.c: 24186\ncm4000_cs.c: 50839\ncm4000_cs.h: 1822\ncm4040_cs.c: 17240\ncm4040_cs.h: 1435\ncm5200_defconfig: 30374\ncm5200.dts: 5770\ncm9780.h: 1648\ncma.c: 76031\ncmap_xfbdev.txt: 1927\ncm_bf527.c: 24357\nCM-BF527_defconfig: 33449\ncm_bf533.c: 10441\nCM-BF533_defconfig: 17784\ncm_bf537.c: 15825\nCM-BF537E_defconfig: 22519\nCM-BF537U_defconfig: 18739\ncm_bf548.c: 20079\nCM-BF548_defconfig: 31514\ncm_bf561.c: 11463\nCM-BF561_defconfig: 19376\ncmb.h: 2128\ncm.c: 108467\ncmd640.c: 22942\ncmd64x.c: 13588\ncmdblk.h: 1843\ncmd.c: 12040\ncmd.h: 3292\ncmdline.c: 774\ncmdlinepart.c: 9405\ncmdpkt.h: 4387\ncmdresp.c: 16004\ncmf.c: 34004\ncm.h: 3735\nCMI8330: 3229\ncmi8330.c: 22466\ncmipci.c: 104710\nCMIPCI.txt: 9357\ncmmap.c: 75502\ncmm.c: 74564\ncmm_data_2860.c: 34802\ncmm_data_2870.c: 28944\ncmm_data.c: 42\ncmm_info.c: 42\ncmm_sanity.c: 44\ncm_msgs.h: 21469\ncmmsta.c: 182636\ncmm_sync.c: 42\ncmm_wpa.c: 41\ncmode.S: 4744\ncmpdi2.c: 435\ncmp.h: 486\ncmpxchg_32.h: 9438\ncmpxchg_64.h: 4582\ncmpxchg.c: 1500\ncmpxchg-grb.h: 2053\ncmpxchg.h: 3173\ncmpxchg-irq.h: 796\ncmpxchg-llsc.h: 1420\ncmpxchg-local.h: 1369\ncm-regbits-24xx.h: 14321\ncm-regbits-34xx.h: 26454\ncm_sbs.c: 3007\ncmservice.c: 13501\ncmtdef.h: 23113\ncmt.h: 1786\ncmtp: 4096\ncmtp.h: 3099\ncmu.c: 5791\ncm-x255.c: 5295\ncm-x270.c: 7295\ncmx270_nand.c: 6063\ncm-x2xx.c: 11698\ncm_x2xx_defconfig: 48725\ncm-x2xx-pci.c: 5404\ncm-x2xx-pci.h: 460\ncm-x300.c: 11712\ncm_x300_defconfig: 39363\ncn_cifs.h: 1323\ncnic.c: 66079\ncnic_defs.h: 16086\ncnic.h: 7097\ncnic_if.h: 7270\ncnode.c: 4219\ncn_proc.c: 7019\ncn_proc.h: 3206\ncn_queue.c: 6122\ncnt32_to_63.h: 3193\ncn_test.c: 4483\ncnv_float.h: 13001\ncoalesced_mmio.c: 3435\ncoalesced_mmio.h: 652\ncobalt: 4096\ncobalt_btns.c: 4645\ncobalt_defconfig: 29161\ncobalt.h: 614\ncobalt_lcdfb.c: 7871\ncobra.c: 6747\nc-octeon.c: 7206\ncoda: 4096\ncoda_cache.h: 673\ncoda_fs_i.h: 1700\ncoda.h: 17708\ncoda_int.h: 434\ncoda_linux.c: 5125\ncoda_linux.h: 2883\ncoda_psdev.h: 3200\ncoda.txt: 49725\ncode16gcc.h: 388\ncodecs: 12288\ncodec.txt: 5826\ncode-patching.c: 12715\ncode-patching.h: 1744\nCodingStyle: 29820\ncoff.h: 12413\ncoh901327_wdt.c: 14160\ncoid.c: 75657\ncoldfire: 4096\ncoldfire.h: 1492\ncolibri.h: 1059\ncolibri-pxa270.c: 3375\ncolibri_pxa270_defconfig: 42182\ncolibri-pxa300.c: 4795\ncolibri_pxa300_defconfig: 27217\ncolibri-pxa320.c: 4735\ncolibri-pxa3xx.c: 3817\ncollate.c: 3675\ncollate.h: 1705\ncollie.c: 7329\ncollie_defconfig: 18902\ncollie.h: 3779\ncolor.c: 4817\ncolor.h: 1187\ncom20020.c: 10296\ncom20020_cs.c: 10301\ncom20020.h: 3624\ncom20020-isa.c: 5185\ncom20020-pci.c: 5701\ncom90io.c: 11118\ncom90xx.c: 18469\ncomedi: 4096\ncomedi_bond.c: 17048\ncomedi_compat32.c: 17423\ncomedi_compat32.h: 1861\ncomedidev.h: 16882\ncomedi_fc.c: 3317\ncomedi_fc.h: 2462\ncomedi_fops.c: 60764\ncomedi_fops.h: 191\ncomedi.h: 29999\ncomedi_ksyms.c: 2407\ncomedilib.h: 7998\ncomedi_parport.c: 9181\ncomedi_pci.h: 1605\ncomedi_test.c: 14760\ncommand.c: 8449\ncommand.h: 8829\ncommand-list.txt: 288\ncommands.c: 25775\ncommands.h: 11936\ncomm.c: 4950\ncommctrl.c: 23882\ncomminit.c: 13072\ncommit.c: 32855\ncommit-msg.sample: 894\ncommon: 4096\ncommon.c: 25712\ncommoncap.c: 27617\ncommon_defconfig: 11971\ncommon.h: 12299\nCommonIO: 4651\ncommon.lds.S: 2212\ncommon-offsets.h: 1451\ncommon-pci.c: 12979\ncommon_perm_to_string.h: 1100\ncommon-smdk.c: 4474\ncommon-smdk.h: 451\ncommproc.c: 8070\ncommproc.h: 25607\ncommsup.c: 51665\nCompactFlash: 1735\ncompal-laptop.c: 8886\ncomparator.h: 5271\ncompartmentalisation.txt: 1944\ncompat_audit.c: 664\ncompat_binfmt_elf.c: 3496\ncompat.c: 2196\ncompat_exec_domain.c: 741\ncompat.h: 369\ncompatibility-list.txt: 1345\ncompat_ioctl.c: 7581\ncompat_ioctl.h: 4449\ncompat_linux.c: 21127\ncompat_linux.h: 7320\ncompatmac.h: 332\ncompat_mq.c: 4132\ncompat_ptrace.h: 2572\ncompat_rt_sigframe.h: 1846\ncompat_signal.c: 17351\ncompat_signal.h: 57\ncompat-signal.h: 2664\ncompat_ucontext.h: 552\ncompat_wrapper.S: 48644\ncompiler-gcc3.h: 823\ncompiler-gcc4.h: 1407\ncompiler-gcc.h: 3118\ncompiler.h: 4524\ncompiler-intel.h: 746\ncompletion.h: 3226\ncomposite.c: 30121\ncomposite.h: 14982\ncompr.c: 10363\ncompress.c: 1839\ncompressed: 4096\ncompress.h: 974\ncompression.c: 18461\ncompression.h: 1742\ncompr.h: 3025\ncompr_lzo.c: 2312\ncompr_rtime.c: 2867\ncompr_rubin.c: 8932\ncompr_zlib.c: 5850\ncomputone.txt: 17570\ncomstats.h: 3120\ncon3215.c: 30319\ncon3270.c: 15947\nconcap.h: 3778\nconcat.h: 454\nconditional.c: 11225\nconditional.h: 617\nconex.c: 32880\nconf.c: 11969\nconfdata.c: 19322\nconfig: 2695\nconfig3270.sh: 2009\nconfig.c: 24033\nconfig.c.in: 496\nconfig_defs_asm.h: 5405\nconfig_defs.h: 4370\nconfigfs: 4096\nconfigfs_example_explicit.c: 12619\nconfigfs_example_macros.c: 11555\nconfigfs.h: 8837\nconfigfs_internal.h: 5080\nconfigfs.txt: 21464\nconfig.h: 1142\nconfig.mk: 7917\nconfig-osm.c: 2170\nconfig_roms.c: 4579\nconfig_roms.h: 588\nconfigs: 4096\nconfigs.c: 2818\nconfiguring.txt: 4139\ncong.c: 12223\nconmakehash.c: 6121\nconnect.c: 38\nconnection.c: 13263\nconnector: 4096\nconnector.c: 11327\nconnector.h: 4405\nconnector.txt: 6503\nconntrack.h: 810\nconsistent.c: 3927\nconsole: 4096\nconsole_32.c: 2071\nconsole_64.c: 1575\nconsole.c: 7199\nconsole.h: 2080\nconsolemap.c: 22885\nconsolemap.h: 1029\nconsole_struct.h: 5109\nconsole.txt: 5814\nconstants.c: 49479\nconstants.h: 2939\nconst.h: 596\nconstraint.h: 2093\nconsumer.h: 8894\nconsumer.txt: 6869\ncontainer.c: 7095\ncontainer.h: 198\ncontec_pci_dio.c: 5763\ncontext.c: 1678\ncontext.h: 3703\ncontext.S: 6412\ncontig.c: 7791\ncontregs.h: 3351\nCONTRIBUTORS: 495\ncontributors.txt: 3035\ncontrol.c: 43620\ncontrol_compat.c: 11584\ncontrolfb.c: 27775\ncontrolfb.h: 4696\ncontrol.h: 9928\nControlNames.txt: 2085\ncontrol_w.h: 1820\ncookie.c: 13149\ncoprocessor.h: 5194\ncoprocessor.S: 7277\ncoproc.h: 362\ncops.c: 29453\ncops_ffdrv.h: 21384\ncops.h: 1400\ncops_ltdrv.h: 9491\ncops.txt: 2768\ncopy_32.S: 9822\ncopy.c: 2883\ncopy_from_user.S: 1986\nCOPYING: 18693\nCOPYING.LIB: 25265\ncopy_in_user.S: 1659\ncopy_page_64.S: 2337\ncopypage_64.S: 2011\ncopypage-fa.c: 2349\ncopypage-feroceon.c: 3145\ncopy_page_mck.S: 5871\ncopy_page.S: 532\ncopypage-v3.c: 2110\ncopypage-v4mc.c: 3649\ncopypage-v4wb.c: 2820\ncopypage-v4wt.c: 2403\ncopypage-v6.c: 3822\ncopypage-xsc3.c: 2840\ncopypage-xscale.c: 3881\ncopy.S: 1321\ncopy_template.S: 5586\ncopy_to_user.S: 2016\ncopy_user_64.S: 5420\ncopyuser_64.S: 9936\ncopy_user_memcpy.S: 5245\ncopy_user_nocache_64.S: 2468\ncopy_user.S: 2573\ncore: 4096\ncore_apecs.c: 10176\ncore_apecs.h: 17281\ncoreb.c: 1844\ncore.c: 24656\ncore-card.c: 15330\ncore-cdev.c: 37224\ncore_cia.c: 33365\ncore_cia.h: 15760\ncore-device.c: 32375\ncoredump.c: 5613\ncore.h: 5921\ncore_irongate.c: 10486\ncore_irongate.h: 6754\ncore-iso.c: 8971\ncore_lca.c: 14096\ncore_lca.h: 11596\ncore_locking.txt: 4081\ncore_marvel.c: 25082\ncore_marvel.h: 9350\ncore_mcpcia.c: 16238\ncore_mcpcia.h: 11691\ncore_polaris.c: 4523\ncore_polaris.h: 2948\ncore_priv.h: 1817\ncore_t2.c: 16416\ncore_t2.h: 20353\ncoretemp: 1672\ncoretemp.c: 11947\ncore_titan.c: 20020\ncore_titan.h: 11455\ncore-topology.c: 15332\ncore-transaction.c: 27218\ncore_tsunami.c: 13148\ncore_tsunami.h: 8469\ncore.txt: 804\ncore_wildfire.c: 17607\ncore_wildfire.h: 8616\ncorgi.c: 9471\ncorgi_defconfig: 47365\ncorgi.h: 4831\ncorgikbd.c: 12406\ncorgi_lcd.c: 16845\ncorgi_lcd.h: 421\ncorgi_pm.c: 7155\ncorgi_ssp.c: 7384\ncorgi_ts.c: 9648\ncosa.c: 59334\ncosa.h: 4349\ncountry.h: 4726\ncow.h: 1883\ncow_sys.h: 692\ncow_user.c: 12166\ncoyote.h: 949\ncoyote-pci.c: 1459\ncoyote-setup.c: 3158\ncp1emu.c: 28793\ncp210x.c: 24866\ncp437.uni: 4426\ncp6.c: 1398\ncpc925_edac.c: 30540\ncpc.h: 16904\ncpci_hotplug_core.c: 17267\ncpci_hotplug.h: 3193\ncpci_hotplug_pci.c: 7823\ncpcihp_generic.c: 6519\ncpcihp_zt5550.c: 8619\ncpcihp_zt5550.h: 2730\ncpc_int.h: 2284\ncpcmd.c: 3087\ncpcmd.h: 1259\ncpc-usb: 4096\ncpc-usb_drv.c: 28935\ncpcusb.h: 2856\ncpfile.c: 24964\ncpfile.h: 1680\ncphy.h: 6427\ncpia2: 4096\ncpia2_core.c: 77737\ncpia2dev.h: 1919\ncpia2.h: 13192\ncpia2_overview.txt: 2357\ncpia2_registers.h: 17890\ncpia2_usb.c: 25426\ncpia2_v4l.c: 50779\ncpia.c: 114212\ncpia.h: 11791\ncpia_pp.c: 22139\ncpia_usb.c: 16084\ncp_intc.c: 3984\ncp_intc.h: 2302\ncpl5_cmd.h: 12577\ncplb.h: 4597\ncplbinfo.c: 3920\ncplbinit.c: 3353\ncplbinit.h: 2491\ncplbmgr.c: 9975\ncplb-mpu: 4096\ncplb-nompu: 4096\ncpm: 4096\ncpm1.c: 19027\ncpm1.h: 23000\ncpm2.c: 8657\ncpm2.h: 51335\ncpm2_pic.c: 7028\ncpm2_pic.h: 177\ncpmac.c: 35475\ncpm_common.c: 8715\ncpm.h: 3601\ncpm_qe: 4096\ncpm-serial.c: 5276\ncpm.txt: 2279\ncpm_uart: 4096\ncpm_uart_core.c: 34184\ncpm_uart_cpm1.c: 4062\ncpm_uart_cpm1.h: 630\ncpm_uart_cpm2.c: 4728\ncpm_uart_cpm2.h: 692\ncpm_uart.h: 3846\ncppi_dma.c: 44672\ncppi_dma.h: 3257\ncpqarray.c: 48267\ncpqarray.h: 3023\ncpqarray.txt: 2224\ncpqphp_core.c: 37277\ncpqphp_ctrl.c: 77860\ncpqphp.h: 22122\ncpqphp_nvram.c: 13820\ncpqphp_nvram.h: 1534\ncpqphp_pci.c: 39788\ncpqphp_sysfs.c: 5682\ncprecomp.h: 1072\ncpsmgr.c: 18525\ncpu: 4096\ncpu5wdt.c: 6940\ncpuacct.txt: 1941\ncpu_buffer.c: 11402\ncpu_buffer.h: 2876\ncpu-bugs64.c: 7627\ncpu.c: 5945\ncpucheck.c: 6054\ncpu-common: 4096\ncpudata_32.h: 574\ncpudata_64.h: 1041\ncpudata.h: 184\ncpu_debug.c: 17937\ncpu_debug.h: 3759\ncpu-drivers.txt: 7387\ncpufeature.h: 13827\ncpu-feature-overrides.h: 1176\ncpu-features.h: 7307\ncpu_features.txt: 2681\ncpufreq: 4096\ncpu-freq: 4096\ncpufreq_32.c: 18804\ncpufreq_64.c: 20116\ncpufreq.c: 49742\ncpufreq_conservative.c: 18026\ncpu-freq.h: 2392\ncpufreq.h: 12164\ncpufreq-nforce2.c: 9537\ncpufreq-nforce2.txt: 597\ncpufreq_ondemand.c: 19342\ncpufreq_performance.c: 1553\ncpufreq_powersave.c: 1625\ncpufreq-pxa2xx.c: 14833\ncpufreq-pxa3xx.c: 6493\ncpufreq_spudemand.c: 4449\ncpufreq_stats.c: 9729\ncpufreq-stats.txt: 5021\ncpufreq_userspace.c: 6109\ncpu.h: 1297\ncpu-h7201.c: 1510\ncpu-h7202.c: 5243\ncpu_hotplug.c: 2052\ncpu-hotplug-spec: 1155\ncpu-hotplug.txt: 14935\ncpuid.c: 5549\ncpuid.h: 617\ncpuidle: 4096\ncpuidle.c: 8664\ncpuidle.h: 1058\ncpu_imx27.c: 1739\ncpuinfo.c: 2141\ncpu-info.h: 2924\ncpuinfo.h: 2135\ncpuinfo-pvr-full.c: 2822\ncpuinfo-static.c: 4940\ncpu-irqs.h: 2654\ncpu-load.txt: 3110\ncpumap.c: 10894\ncpumap.h: 320\ncpumask.c: 4643\ncpumask.h: 381\ncpu-multi32.h: 1743\ncpu-omap.c: 4053\ncpu-probe.c: 23180\ncpu-regs.h: 14601\ncpu-sa1100.c: 7866\ncpu-sa1110.c: 9518\ncpuset.c: 72697\ncpuset.h: 4740\ncpusets.txt: 36191\ncpu_setup_44x.S: 1639\ncpu_setup_6xx.S: 11167\ncpu_setup_fsl_booke.S: 1766\ncpu_setup_pa6t.S: 1218\ncpu_setup_ppc970.S: 3704\ncpu-sh2: 4096\ncpu-sh2a: 4096\ncpu-sh3: 4096\ncpu-sh4: 4096\ncpu-sh5: 4096\ncpu-single.h: 1429\ncputable.c: 57765\ncputable.h: 19753\ncputhreads.h: 1572\ncputime.h: 118\ncputopology.txt: 3013\ncputype.h: 840\ncpu_vect.h: 1321\ncp_vers.h: 933\ncpwd.c: 16512\ncq.c: 20469\nc-qcam.c: 19812\nCQcam.txt: 7069\ncq_desc.h: 2507\ncq_enet_desc.h: 6342\ncq_exch_desc.h: 5837\ncq.h: 4130\nc-r3k.c: 8056\nc-r4k.c: 37720\ncramfs: 4096\ncramfs_fs.h: 2930\ncramfs_fs_sb.h: 343\ncramfs.txt: 2599\ncrash.c: 9898\ncrash_dump_32.c: 2149\ncrash_dump_64.c: 1417\ncrash_dump.c: 3851\ncrash_dump.h: 2002\ncr_bllcd.c: 7402\ncrc16.c: 2838\ncrc16.h: 622\ncrc32.c: 15299\ncrc32c.c: 8200\ncrc32c.h: 254\ncrc32c-intel.c: 4975\ncrc32defs.h: 1072\ncrc32.h: 880\ncrc32hash.c: 654\ncrc7.c: 2329\ncrc7.h: 272\ncrc-ccitt.c: 3052\ncrc-ccitt.h: 330\ncrc.h: 880\ncrc-itu-t.c: 2892\ncrc-itu-t.h: 615\ncrc-t10dif.c: 2965\ncrc-t10dif.h: 140\ncred.c: 14888\ncredentials.txt: 20932\ncred.h: 10905\ncred-internals.h: 559\nCREDITS: 603\ncrime.c: 2833\ncrime.h: 5271\ncris: 4096\ncris_defs_asm.h: 3805\ncrisksyms.c: 472\ncris_supp_reg.h: 198\ncrisv10.c: 129158\ncrisv10.h: 4289\ncrm_regs.h: 1700\ncr_pll.c: 4842\ncrt0_ram.S: 2152\ncrt0_rom.S: 3157\ncrt0.S: 1979\ncrtsavres.S: 6123\ncrunch-bits.S: 8521\ncrunch.c: 2001\ncrw.c: 4007\ncrw.h: 2025\ncryptd.c: 16974\ncryptd.h: 650\ncrypto: 4096\ncrypto4xx_alg.c: 8383\ncrypto4xx_core.c: 34847\ncrypto4xx_core.h: 5634\ncrypto4xx_reg_def.h: 7646\ncrypto4xx_sa.c: 2984\ncrypto4xx_sa.h: 5742\ncrypto.c: 16089\ncrypto_compat.h: 2294\ncryptocop.c: 111134\ncryptocop.h: 7614\ncrypto_des.h: 516\ncrypto.h: 35141\ncryptohash.h: 264\ncryptoloop.c: 5005\ncrypto_null.c: 5051\ncrypto_wq.c: 896\ncrypto_wq.h: 122\ncrypt_s390.h: 10190\ncs4231.c: 6021\ncs4231-regs.h: 8547\ncs4236.c: 22848\ncs4236_lib.c: 35470\ncs423x: 4096\ncs4270.c: 26832\ncs4270.h: 804\ncs4281.c: 66411\ncs4362a.h: 2039\ncs4398.h: 1968\ncs461x.txt: 2184\ncs46xx: 4096\ncs46xx.c: 5301\ncs46xx_dsp_scb_types.h: 28137\ncs46xx_dsp_spos.h: 6198\ncs46xx_dsp_task_types.h: 7293\ncs46xx.h: 73681\ncs46xx_image.h: 155782\ncs46xx_lib.c: 107227\ncs46xx_lib.h: 8586\ncs5345.c: 5839\ncs5345.h: 1210\ncs53l32a.c: 5932\ncs53l32a.h: 1196\ncs5520.c: 4777\ncs5530.c: 8332\ncs5535audio: 4096\ncs5535audio.c: 10538\ncs5535audio.h: 4162\ncs5535audio_olpc.c: 4595\ncs5535audio_pcm.c: 13419\ncs5535audio_pm.c: 4043\ncs5535.c: 6298\ncs5535_gpio.c: 6000\ncs5536.c: 7861\ncs553x_nand.c: 10268\ncs8403.h: 8833\ncs8420.h: 1681\ncs8427.c: 18610\ncs8427.h: 10572\ncs89712.h: 1848\ncs89x0.c: 59868\ncs89x0.h: 16242\ncs89x0.txt: 25508\ncsb337_defconfig: 28177\ncsb637_defconfig: 29026\ncsb701.c: 1321\ncsb726.c: 7527\ncsb726.h: 658\ncs.c: 21706\ncscanmgr.c: 14014\ncs.h: 6099\ncs_internal.h: 7245\ncsr1212.c: 38810\ncsr1212.h: 14571\ncsr.c: 26430\ncsrc-bcm1480.c: 1705\ncsrc-ioasic.c: 1796\ncsrc-octeon.c: 1473\ncsrc-r4k.c: 885\ncsrc-sb1250.c: 2176\ncsr.h: 2690\ncss.c: 26134\ncss.h: 4460\ncstate.c: 4904\ncs_types.h: 934\ncsum-copy_64.S: 4160\ncsum_copy_from_user.S: 439\ncsum_copy.S: 7018\ncsum_copy_to_user.S: 431\ncsumcpfruser.S: 1663\ncsum_ipv6_magic.S: 2885\ncsumipv6.S: 696\ncsum-partial_64.c: 3530\ncsum_partial_copy.c: 8909\ncsum_partial_copy_generic.S: 1729\ncsumpartialcopygeneric.S: 6850\ncsumpartialcopy.S: 1151\ncsumpartialcopyuser.S: 2378\ncsum_partial.S: 16737\ncsumpartial.S: 3126\ncsum-wrappers_64.c: 3926\nct20k1reg.h: 20603\nct20k2reg.h: 3088\nct82c710.c: 6778\nctamixer.c: 10033\nctamixer.h: 2795\nctatc.c: 42227\nctatc.h: 5058\nctcm_dbug.c: 1932\nctcm_dbug.h: 3316\nctcm_fsms.c: 75291\nctcm_fsms.h: 8271\nctcm_main.c: 45768\nctcm_main.h: 6938\nctcm_mpc.c: 59919\nctcm_mpc.h: 5324\nctcm_sysfs.c: 5171\nctdaio.c: 17904\nctdaio.h: 3291\ncthardware.c: 1688\ncthardware.h: 7286\ncthw20k1.c: 49680\ncthw20k1.h: 598\ncthw20k2.c: 49114\ncthw20k2.h: 598\nctimap.c: 2516\nctimap.h: 1167\nctkip.c: 17399\nctl_unnumbered.txt: 962\nctmixer.c: 28786\nctmixer.h: 1691\nctpcm.c: 11244\nctpcm.h: 612\nctr.c: 11026\nctree.c: 111552\nctree.h: 75158\nctresource.c: 5825\nctresource.h: 2267\nctr.h: 524\nctrlchar.c: 1752\nctrlchar.h: 484\ncts.c: 10045\nctsrc.c: 19870\nctsrc.h: 4527\ncttimer.c: 11342\ncttimer.h: 686\nctvmem.c: 5666\nctvmem.h: 1787\nc-tx39.c: 10852\nctxfi: 4096\nctxrx.c: 147975\nctype.c: 1041\nctype.h: 1399\ncu3088.c: 3577\ncu3088.h: 848\ncuboot-52xx.c: 1660\ncuboot-824x.c: 1224\ncuboot-83xx.c: 1525\ncuboot-85xx.c: 1673\ncuboot-85xx-cpm2.c: 1764\ncuboot-8xx.c: 1149\ncuboot-acadia.c: 4964\ncuboot-amigaone.c: 868\ncuboot-bamboo.c: 689\ncuboot.c: 944\ncuboot-c2k.c: 4884\ncuboot-ebony.c: 782\ncuboot.h: 365\ncuboot-katmai.c: 1294\ncuboot-mpc7448hpc2.c: 1279\ncuboot-pq2.c: 7138\ncuboot-rainier.c: 1453\ncuboot-sam440ep.c: 1254\ncuboot-sequoia.c: 1453\ncuboot-taishan.c: 1361\ncuboot-warp.c: 916\ncuboot-yosemite.c: 1095\ncuda.h: 978\ncumana_1.c: 7960\ncumana_2.c: 14690\ncurrent.h: 677\ncuse.c: 14893\ncvisionppc.h: 1577\ncvmx-address.h: 8499\ncvmx-asm.h: 4526\ncvmx-asxx-defs.h: 14223\ncvmx-bootinfo.h: 9081\ncvmx-bootmem.c: 20524\ncvmx-bootmem.h: 12982\ncvmx-ciu-defs.h: 39090\ncvmx-cmd-queue.c: 9400\ncvmx-cmd-queue.h: 18993\ncvmx-config.h: 6486\ncvmx-dbg-defs.h: 2123\ncvmx-fau.h: 19011\ncvmx-fpa.c: 4975\ncvmx-fpa-defs.h: 11938\ncvmx-fpa.h: 8284\ncvmx-gmxx-defs.h: 79305\ncvmx-gpio-defs.h: 6346\ncvmx.h: 14240\ncvmx-helper-board.c: 21950\ncvmx-helper-board.h: 6656\ncvmx-helper.c: 32770\ncvmx-helper-errata.c: 2592\ncvmx-helper-errata.h: 1277\ncvmx-helper-fpa.c: 7545\ncvmx-helper-fpa.h: 2360\ncvmx-helper.h: 7482\ncvmx-helper-jtag.c: 4203\ncvmx-helper-jtag.h: 1530\ncvmx-helper-loop.c: 2679\ncvmx-helper-loop.h: 1901\ncvmx-helper-npi.c: 3413\ncvmx-helper-npi.h: 1897\ncvmx-helper-rgmii.c: 17448\ncvmx-helper-rgmii.h: 3560\ncvmx-helper-sgmii.c: 17037\ncvmx-helper-sgmii.h: 3417\ncvmx-helper-spi.c: 6088\ncvmx-helper-spi.h: 2785\ncvmx-helper-util.c: 12555\ncvmx-helper-util.h: 6164\ncvmx-helper-xaui.c: 11997\ncvmx-helper-xaui.h: 3409\ncvmx-interrupt-decodes.c: 13959\ncvmx-interrupt-rsl.c: 3787\ncvmx-iob-defs.h: 16589\ncvmx-ipd-defs.h: 27302\ncvmx-ipd.h: 10763\ncvmx-l2c.c: 19669\ncvmx-l2c-defs.h: 23395\ncvmx-l2c.h: 10068\ncvmx-l2d-defs.h: 9721\ncvmx-l2t-defs.h: 3720\ncvmx-led-defs.h: 6731\ncvmx-mdio.h: 13085\ncvmx-mio-defs.h: 54538\ncvmx-npei-defs.h: 61528\ncvmx-npi-defs.h: 46348\ncvmx-packet.h: 1964\ncvmx-pci-defs.h: 40401\ncvmx-pcieep-defs.h: 32743\ncvmx-pciercx-defs.h: 36139\ncvmx-pcsx-defs.h: 11497\ncvmx-pcsxx-defs.h: 9562\ncvmx-pescx-defs.h: 11439\ncvmx-pexp-defs.h: 9365\ncvmx-pip-defs.h: 34993\ncvmx-pip.h: 16579\ncvmx-pko.c: 14987\ncvmx-pko-defs.h: 31966\ncvmx-pko.h: 18946\ncvmx-pow-defs.h: 19069\ncvmx-pow.h: 59817\ncvmx-scratch.h: 3875\ncvmx-smix-defs.h: 5173\ncvmx-spi.c: 22343\ncvmx-spi.h: 9516\ncvmx-spinlock.h: 6516\ncvmx-spxx-defs.h: 9687\ncvmx-srxx-defs.h: 3849\ncvmx-stxx-defs.h: 8491\ncvmx-sysinfo.c: 3570\ncvmx-sysinfo.h: 4893\ncvmx-wqe.h: 11943\ncwc4630.h: 15478\ncwcasync.h: 7969\ncwcbinhack.h: 1566\ncwcdma.asp: 4526\ncwcdma.h: 2174\ncwcsnoop.h: 1513\ncwep.c: 9662\ncwm.c: 3787\ncwm.h: 2421\ncx18: 4096\ncx18-audio.c: 2589\ncx18-audio.h: 905\ncx18-av-audio.c: 14932\ncx18-av-core.c: 41048\ncx18-av-core.h: 13381\ncx18-av-firmware.c: 7225\ncx18-av-vbi.c: 9043\ncx18-cards.c: 16165\ncx18-cards.h: 4838\ncx18-controls.c: 9435\ncx18-controls.h: 1257\ncx18-driver.c: 35409\ncx18-driver.h: 23311\ncx18-dvb.c: 9950\ncx18-dvb.h: 946\ncx18-fileops.c: 21082\ncx18-fileops.h: 1421\ncx18-firmware.c: 14987\ncx18-firmware.h: 1001\ncx18-gpio.c: 9268\ncx18-gpio.h: 1226\ncx18-i2c.c: 8776\ncx18-i2c.h: 1083\ncx18-io.c: 2807\ncx18-ioctl.c: 27533\ncx18-ioctl.h: 1423\ncx18-io.h: 4951\ncx18-irq.c: 2319\ncx18-irq.h: 1417\ncx18-mailbox.c: 21623\ncx18-mailbox.h: 3643\ncx18-queue.c: 6955\ncx18-queue.h: 2294\ncx18-scb.c: 5787\ncx18-scb.h: 7441\ncx18-streams.c: 21499\ncx18-streams.h: 1889\ncx18.txt: 811\ncx18-vbi.c: 7419\ncx18-vbi.h: 1031\ncx18-version.h: 1319\ncx18-video.c: 1080\ncx18-video.h: 875\ncx22700.c: 11029\ncx22700.h: 1488\ncx22702.c: 14516\ncx22702.h: 1673\ncx231xx: 4096\ncx231xx-audio.c: 14952\ncx231xx-avcore.c: 77231\ncx231xx-cards.c: 23257\ncx231xx-conf-reg.h: 25445\ncx231xx-core.c: 30779\ncx231xx-dvb.c: 13339\ncx231xx.h: 22018\ncx231xx-i2c.c: 12912\ncx231xx-input.c: 6423\ncx231xx-pcb-cfg.c: 20991\ncx231xx-pcb-cfg.h: 6456\ncx231xx-reg.h: 67462\ncx231xx-vbi.c: 17757\ncx231xx-vbi.h: 2261\ncx231xx-video.c: 58825\ncx23418.h: 17951\ncx2341x: 4096\ncx2341x.c: 38287\ncx2341x.h: 7383\ncx23885: 4096\ncx23885-417.c: 48981\ncx23885-cards.c: 25645\ncx23885-core.c: 54422\ncx23885-dvb.c: 26635\ncx23885.h: 16143\ncx23885-i2c.c: 9910\ncx23885-reg.h: 12999\ncx23885-vbi.c: 6762\ncx23885-video.c: 40258\ncx24110.c: 20853\ncx24110.h: 1810\ncx24113.c: 14661\ncx24113.h: 1673\ncx24116.c: 40768\ncx24116.h: 1706\ncx24123.c: 30243\ncx24123.h: 1979\ncx25840: 4096\ncx25840-audio.c: 11073\ncx25840-core.c: 45706\ncx25840-core.h: 3605\ncx25840-firmware.c: 3889\ncx25840.h: 3250\ncx25840-vbi.c: 7108\ncx88: 4096\ncx88-alsa.c: 23036\ncx88-blackbird.c: 39031\ncx88-cards.c: 89130\ncx88-core.c: 31343\ncx88-dsp.c: 8787\ncx88-dvb.c: 39095\ncx88.h: 22857\ncx88-i2c.c: 5568\ncx88-input.c: 14002\ncx88-mpeg.c: 24270\ncx88-reg.h: 34334\ncx88-tvaudio.c: 28674\ncx88-vbi.c: 6438\ncx88-video.c: 56637\ncx88-vp3054-i2c.c: 4322\ncx88-vp3054-i2c.h: 1559\ncxacru.c: 37008\ncxacru.txt: 2325\ncxgb2.c: 38481\ncxgb3: 4096\ncxgb3_ctl_defs.h: 5067\ncxgb3_defs.h: 3489\ncxgb3i: 4096\ncxgb3i_ddp.c: 20593\ncxgb3i_ddp.h: 8254\ncxgb3i.h: 4401\ncxgb3i_init.c: 3040\ncxgb3i_iscsi.c: 27545\ncxgb3_ioctl.h: 3847\ncxgb3i_offload.c: 50331\ncxgb3i_offload.h: 7277\ncxgb3i_pdu.c: 12368\ncxgb3i_pdu.h: 1710\ncxgb3i.txt: 3295\ncxgb3_main.c: 84313\ncxgb3_offload.c: 37599\ncxgb3_offload.h: 6272\ncxgb.txt: 13829\ncxio_dbg.c: 5114\ncxio_hal.c: 38094\ncxio_hal.h: 7482\ncxio_resource.c: 9188\ncxio_resource.h: 3116\ncxio_wr.h: 20826\ncxusb.c: 48202\ncxusb.h: 724\ncy82c693.c: 10524\ncyber2000fb.c: 43356\ncyber2000fb.h: 16008\ncyberjack.c: 14547\ncyclades.c: 158213\ncyclades.h: 24974\ncyclomx.h: 2544\ncyclone.c: 3125\ncyclone.h: 403\ncycx_cfm.h: 2926\ncycx_drv.c: 15649\ncycx_drv.h: 2183\ncycx_main.c: 9413\ncycx_x25.c: 45814\ncycx_x25.h: 3727\ncylinder.c: 5848\ncypress_atacb.c: 8391\ncypress_cy7c63.c: 7689\ncypress.h: 2856\ncypress_m8.c: 47071\ncypress_m8.h: 2367\ncyrix.c: 5962\ncytherm.c: 11260\nd101m_ucode.bin.ihex: 1675\nd101s_ucode.bin.ihex: 1675\nd102e_ucode.bin.ihex: 1675\nda9030_battery.c: 16256\nda9034-ts.c: 9057\nda903x_bl.c: 4988\nda903x.c: 13455\nda903x.h: 7048\ndabusb: 4096\ndabusb.c: 22084\ndabusb.h: 1873\nDAC960.c: 265715\nDAC960.h: 151800\ndaca.c: 7036\ndac.h: 752\ndadapter.c: 14853\ndadapter.h: 1070\ndaemon.c: 16879\ndaemon.h: 8435\ndaemon_kern.c: 2419\ndaemon_user.c: 4368\ndaisy.c: 12538\nDAI.txt: 2270\ndapm.txt: 10267\ndaqboard2000.c: 25750\ndarla20.c: 2889\ndarla20_dsp.c: 3479\ndarla24.c: 3153\ndarla24_dsp.c: 3845\ndart.h: 2235\ndart_iommu.c: 10816\ndas08.c: 26325\ndas08_cs.c: 14893\ndas08.h: 2561\ndas16.c: 44853\ndas16m1.c: 21006\ndas1800.c: 48894\ndas6402.c: 8510\ndas800.c: 24454\nDASD: 3388\ndasd_3990_erp.c: 68376\ndasd_alias.c: 26580\ndasd.c: 72767\ndasd_devmap.c: 29631\ndasd_diag.c: 17829\ndasd_diag.h: 2628\ndasd_eckd.c: 95322\ndasd_eckd.h: 11295\ndasd_eer.c: 20468\ndasd_erp.c: 4866\ndasd_fba.c: 17801\ndasd_fba.h: 1816\ndasd_genhd.c: 4783\ndasd.h: 11124\ndasd_int.h: 21917\ndasd_ioctl.c: 11160\ndasd_proc.c: 9802\ndata.c: 2497\ndatafab.c: 20690\ndatagram.c: 4449\ndata-integrity.txt: 13815\ndatalink.h: 482\ndatapage.S: 2018\ndatarate.c: 12551\ndatarate.h: 2494\ndatastream.c: 15931\ndatastream.h: 514\ndat.c: 11476\ndat.h: 2048\ndavicom.c: 4985\ndavinci: 4096\ndavinci_all_defconfig: 43899\ndavinci.c: 13768\ndavinci_emac.c: 84968\ndavinci-evm.c: 6719\ndavinci.h: 3430\ndavinci-i2s.c: 17146\ndavinci-i2s.h: 495\ndavinci_nand.c: 23119\ndavinci-pcm.c: 10560\ndavinci-pcm.h: 783\ndavinci-sffsdr.c: 4374\ndavinci_wdt.c: 6690\ndb1000_defconfig: 23355\ndb1100_defconfig: 23611\ndb1200_defconfig: 25180\ndb1200.h: 6115\ndb1500_defconfig: 30453\ndb1550_defconfig: 26655\ndb1x00: 4096\ndb1x00.h: 5353\ndb78x00-bp-setup.c: 2591\ndb88f5281-setup.c: 9805\ndb88f6281-bp-setup.c: 2227\ndb9.c: 21255\ndbdma2.c: 10987\ndbdma.c: 29134\ndbdma.h: 3834\ndbell.c: 1075\ndbell.h: 1308\ndbg.c: 7231\ndbg_current.S: 402\ndbg.h: 144\ndbg_io.c: 5088\ndbg_stackcheck.S: 427\ndbg_stackkill.S: 575\ndbl_float.h: 36770\ndbox2-flash.c: 2719\ndbri.c: 80387\ndbus_contexts: 195\ndc21285.c: 5936\ndc21285-timer.c: 1332\ndc232b: 4096\ndc395x.c: 145696\ndc395x.h: 25842\ndc395x.txt: 3337\ndca: 4096\ndcache.c: 60424\ndcache.h: 2009\ndca-core.c: 6864\ndca.h: 2530\ndca-sysfs.c: 2700\ndcb: 4096\ndcbnl.c: 29597\ndcbnl.h: 11558\ndccp: 4096\ndccp.h: 15873\ndccp.txt: 7484\ndcdbas.c: 16163\ndcdbas.h: 2821\ndcdbas.txt: 3709\ndcookies.c: 6936\ndcookies.h: 1289\ndcore.c: 21748\ndcr.c: 6132\ndcr-generic.h: 1621\ndcr.h: 6308\ndcr-low.S: 983\ndcr-mmio.h: 1838\ndcr-native.h: 4500\ndcr-regs.h: 5140\ndcssblk.c: 27372\ndcu.h: 1481\ndd.c: 9413\nddp.c: 49018\nddr2_defs_asm.h: 11790\nddr2_defs.h: 9835\nddr.h: 4564\nde2104x.c: 54503\nde4x5.c: 169230\nde4x5.h: 49229\nde4x5.txt: 8677\nde600.c: 13275\nde600.h: 5588\nde620.c: 26654\nde620.h: 4970\ndeadline-iosched.c: 11700\ndeadline-iosched.txt: 2841\ndebug-8250.S: 719\ndebug.c: 7221\ndebug-cmd.h: 1653\ndebug-devices.c: 1975\ndebugfs: 4096\ndebug_fs.c: 16621\ndebugfs.c: 6192\ndebugfs.h: 2563\ndebugfs_key.c: 9097\ndebugfs_key.h: 1348\ndebugfs-kmemtrace: 2769\ndebugfs_netdev.c: 14895\ndebugfs_netdev.h: 739\ndebugfs-pktcdvd: 448\ndebugfs_sta.c: 7063\ndebugfs_sta.h: 427\ndebugfs.txt: 7128\ndebugging: 1594\nDebugging390.txt: 97243\ndebugging-modules.txt: 954\ndebugging-via-ohci1394.txt: 7635\ndebug.h: 1195\nDebug.h: 1195\ndebug_if.h: 3572\ndebug-leds.c: 7120\ndebug-levels.h: 1482\ndebuglib.c: 4523\ndebuglib.h: 11740\ndebug_locks.c: 1127\ndebug_locks.h: 1663\ndebug-macro.S: 619\ndebugobjects.c: 24352\ndebugobjects.h: 2960\ndebugobjects.tmpl: 14144\ndebug-pagealloc.c: 2607\ndebug-pl01x.S: 693\ndebugport.c: 12453\ndebugreg.h: 2904\ndebug.S: 2650\ndebug-stub.c: 6089\ndebugtraps.S: 1210\ndebug.txt: 5755\ndec: 4096\ndec21285.h: 5572\ndec_and_lock.c: 809\ndecbin.S: 15728\ndeclance.c: 35842\ndecl.h: 2409\ndecnet: 4096\ndecnet.txt: 10805\ndecodecode: 1702\ndecode_exc.c: 11585\ndecode_rs.c: 6959\ndecompress: 4096\ndecompress_bunzip2.c: 23556\ndecompress.c: 1126\ndecompress_inflate.c: 3544\ndecompress_unlzma.c: 15528\ndecompress_v10.lds: 342\ndecompress_v32.lds: 337\ndecstation_defconfig: 17956\ndectypes.h: 427\ndefault_defconfig: 39014\ndefBF512.h: 1271\ndefBF514.h: 13406\ndefBF516.h: 46402\ndefBF518.h: 48358\ndefBF51x_base.h: 113540\ndefBF522.h: 1271\ndefBF525.h: 44639\ndefBF527.h: 77635\ndefBF52x_base.h: 116393\ndefBF532.h: 74150\ndefBF534.h: 189790\ndefBF537.h: 35002\ndefBF539.h: 212777\ndefBF542.h: 58060\ndefBF544.h: 57371\ndefBF547.h: 78333\ndefBF548.h: 117603\ndefBF549.h: 180941\ndefBF54x_base.h: 251535\ndefBF561.h: 109277\ndefconfig: 20414\ndeferred_io.txt: 3031\ndefines.h: 5063\ndefine_trace.h: 1988\ndefkeymap.c: 6243\ndefkeymap.c_shipped: 11007\ndefkeymap.map: 12183\ndeflate.c: 5615\ndeflate_syms.c: 377\ndef_LPBlackfin.h: 29239\ndefpalo.conf: 789\ndefs.h: 12522\ndeftree.c: 40510\ndefutil.h: 11891\ndefxx.c: 116343\ndefxx.h: 54496\ndelay_32.h: 882\ndelay_64.h: 378\ndelay-accounting.txt: 3837\ndelayacct.c: 5038\ndelayacct.h: 4108\ndelay.c: 581\ndelayed-ref.c: 24860\ndelayed-ref.h: 6619\ndelay.h: 1166\ndelay_mm.h: 1362\ndelay_no.h: 2314\ndelay.S: 1279\ndelay.txt: 694\ndelegation.c: 14100\ndelegation.h: 2261\ndelkin_cb.c: 4687\ndell-laptop.c: 9519\ndell_rbu.c: 19420\ndell_rbu.txt: 4973\ndell-wmi.c: 6724\ndelta.c: 23513\ndelta.h: 5823\ndemo_main.c: 29367\ndemux.h: 8791\ndenormal.c: 3335\ndentry.c: 2934\ndentry-locking.txt: 8359\ndepca.c: 61475\ndepca.h: 6823\ndepca.txt: 1245\ndesc.c: 19546\ndesc_defs.h: 2385\ndesc.h: 20526\ndes_check_key.c: 4011\ndescore-readme.txt: 17200\ndescription: 73\ndes_generic.c: 36210\ndes.h: 403\ndesign_notes.txt: 4626\ndesign.txt: 17558\ndes_s390.c: 17966\ndev-audio.c: 1656\ndevboards: 4096\ndev.c: 16990\ndevconnect.c: 33409\ndevdma.c: 2008\ndevdma.h: 271\ndevelopment-process: 4096\ndev-fb.c: 1681\ndevfs: 459\ndev.h: 9111\ndev-hsmmc1.c: 1647\ndev-hsmmc.c: 1640\ndev-i2c0.c: 1622\ndev-i2c1.c: 1587\ndevice.c: 3904\ndevice_cfg.h: 2924\ndevice_cgroup.c: 12005\ndevice_cgroup.h: 380\ndevice-drivers.tmpl: 13872\ndevice_fsm.c: 34071\ndevice.h: 31245\ndevice_handler: 4096\ndevice_id.c: 8750\ndevice_id.h: 9158\ndevice-init.c: 23541\ndeviceiobook.tmpl: 11288\ndevice_main.c: 128828\ndevice-mapper: 4096\ndevice-mapper.h: 10956\ndevice_ops.c: 22502\ndevice_pgid.c: 16031\ndevices: 4096\ndevices.c: 19482\ndevices.h: 918\ndevices-rsk7203.c: 2587\ndevice_status.c: 12596\ndevices.txt: 118144\ndevicetable.txt: 1298\ndevice.txt: 6393\ndevinet.c: 40642\ndev-interface: 8905\ndevio.c: 45517\ndev-ioctl.c: 18582\ndevmap.c: 1464\ndev_mcast.c: 5650\ndevops_32.c: 1879\ndevops_64.c: 1006\ndevpts: 4096\ndevpts_fs.h: 1454\ndevpts.txt: 5085\ndevres.c: 16191\ndevres.txt: 7761\ndevs.c: 9766\ndevs.h: 1960\ndev-sysfs.c: 3852\ndev_table.c: 5563\ndev_table.h: 10908\ndevtree.c: 8324\ndev-uart.c: 3521\ndev-usb.c: 1134\ndev-usb-hsotg.c: 992\ndfadd.c: 15801\ndfcmp.c: 5306\ndfdiv.c: 12636\ndfifo.h: 2160\ndfmpy.c: 11736\ndfrem.c: 8997\ndfs.c: 37\ndfs.h: 27\ndfsqrt.c: 5530\ndfsub.c: 15897\ndfu: 4096\ndfu.c: 6025\ndgram.c: 8393\ndiag.c: 1739\ndiag.h: 1050\ndialog.h: 6696\ndib0070.c: 13441\ndib0070.h: 1691\ndib0700_core.c: 11979\ndib0700_devices.c: 54526\ndib0700.h: 2680\ndib07x0.h: 266\ndib3000.h: 1813\ndib3000mb.c: 23970\ndib3000mb_priv.h: 16232\ndib3000mc.c: 26706\ndib3000mc.h: 2337\ndib7000m.c: 40754\ndib7000m.h: 2102\ndib7000p.c: 40757\ndib7000p.h: 2849\ndibusb-common.c: 12123\ndibusb.h: 3337\ndibusb-mb.c: 14485\ndibusb-mc.c: 5124\ndibx000_common.c: 4156\ndibx000_common.h: 2896\ndi.c: 31214\ndi_dbg.h: 1102\ndiddfunc.c: 2703\ndi_defs.h: 8217\ndid_vers.h: 933\ndiffconfig: 3642\ndig: 4096\ndigest.c: 2574\ndigi1.h: 3665\ndigi_acceleport.c: 58641\ndigiepca.txt: 3789\ndigiFep1.h: 1928\ndigiPCI.h: 1382\ndigitv.c: 9329\ndigitv.h: 1457\ndigsy_mtc.dts: 5933\ndi.h: 4386\ndilnetpc.c: 13589\ndino.c: 31503\ndio: 4096\ndio.c: 8573\ndio-driver.c: 3552\ndio.h: 11200\ndio-sysfs.c: 2250\ndir.c: 25683\ndirect.c: 6527\ndirect.h: 1640\ndirect-io.c: 35225\ndirectory.c: 7736\ndirectory-locking: 5153\ndirent.h: 177\ndir_f.c: 10085\ndir_f.h: 1267\ndir_fplus.c: 4598\ndir_fplus.h: 1014\ndir.h: 1246\ndirhash.c: 6496\ndir-item.c: 11583\ndisable-tsc-ctxt-sw-stress-test.c: 1724\ndisable-tsc-on-off-stress-test.c: 1717\ndisable-tsc-test.c: 2121\ndis-asm.h: 895\ndisassemble.c: 19044\ndisassemble.h: 1766\ndis.c: 41703\ndiscontig.c: 1271\ndiscover.c: 9895\ndiscover.h: 2378\ndiscovery.c: 12785\ndiscovery.h: 3572\ndisk-io.c: 67604\ndisk-io.h: 4751\ndiskonchip.c: 50636\ndisk-shock-protection.txt: 6881\ndispc.c: 37465\ndispc.h: 1183\ndisplay: 4096\ndisplay7seg.c: 6503\ndisplay7seg.h: 1882\ndisplay.c: 1573\ndisplay_gx1.c: 6318\ndisplay_gx1.h: 4598\ndisplay_gx.c: 4945\ndisplay.h: 2117\ndisplay-sysfs.c: 6099\ndiu.txt: 470\ndiv64.c: 3889\ndiv64-generic.c: 283\ndiv64.h: 371\ndiv64.S: 3866\ndiva.c: 34488\ndivacapi.h: 50994\ndiva_didd.c: 3571\ndiva_dma.c: 2843\ndiva_dma.h: 1993\ndiva.h: 1010\ndivamnt.c: 5616\ndiva_pci.h: 631\ndivasfunc.c: 5512\ndivasi.c: 12379\ndivasmain.c: 21787\ndivasproc.c: 10764\ndivasync.h: 20126\ndivdi3.S: 6280\ndivert: 4096\ndivert_init.c: 2399\ndivert_procfs.c: 8581\ndivide.S: 4293\ndivsi3.S: 6392\ndiv_small.S: 1546\ndiv_Xsig.S: 10096\ndl2k.c: 48901\ndl2k.h: 14949\ndl2k.txt: 9387\ndlci.c: 11723\nDLINK.txt: 7386\ndlm: 4096\ndlmapi.h: 9492\ndlmast.c: 13019\ndlmcommon.h: 29686\ndlmconstants.h: 5013\ndlmconvert.c: 15590\ndlmconvert.h: 1218\ndlmdebug.c: 28761\ndlmdebug.h: 2109\ndlm_device.h: 2536\ndlmdomain.c: 49292\ndlmdomain.h: 1165\ndlmfs.c: 15242\ndlmfs.txt: 4319\ndlmfsver.c: 1211\ndlmfsver.h: 997\ndlmglue.c: 110475\ndlmglue.h: 5587\ndlm.h: 5602\ndlm_internal.h: 16633\ndlmlock.c: 19997\ndlmmaster.c: 96511\ndlm_netlink.h: 1064\ndlm_plock.h: 1135\ndlmrecovery.c: 85132\ndlmthread.c: 21013\ndlmunlock.c: 19250\ndlmver.c: 1203\ndlmver.h: 991\ndm1105: 4096\ndm1105.c: 22399\ndm355.c: 17263\ndm355evm_keys.c: 8928\ndm355evm_msp.c: 10717\ndm355evm_msp.h: 2879\ndm355.h: 586\ndm644x.c: 14946\ndm644x.h: 1316\ndm646x.c: 15438\ndm646x.h: 757\ndm9000.c: 34291\ndm9000.h: 4167\ndm9000.txt: 5137\ndm9601.c: 15941\ndma: 4096\ndma-alloc.c: 4571\ndma-api.c: 9315\nDMA-API.txt: 28886\nDMA-attributes.txt: 1376\ndma-attrs.h: 1758\ndmabounce.c: 14340\ndmabrg.c: 5279\ndmabrg.h: 497\ndmabuf.c: 35686\ndma.c: 6328\ndmac.c: 4805\ndmac.h: 11517\ndma-coherence.h: 1492\ndma-coherent.c: 3667\ndma-coherent.h: 891\ndmacopy.c: 909\ndma-core.h: 639\ndmactl-regs.h: 4663\ndma-debug.c: 31988\ndma-debug.h: 4915\ndma-default.c: 8575\ndma_defs_asm.h: 14594\ndma_defs.h: 14110\ndmaengine.c: 28040\ndmaengine.h: 15831\ndmaengine.txt: 42\ndma-g2.c: 4776\ndma.h: 2547\ndma-iommu.c: 3128\ndma-isa.c: 5163\nDMA-ISA-LPC.txt: 5333\ndma_lib.c: 16254\ndma-m2p.c: 9922\ndma-mapping-broken.h: 2488\ndma-mapping.c: 5434\ndma-mapping-common.h: 5646\ndma-mapping.h: 4368\nDMA-mapping.txt: 27929\ndma_mm.h: 455\ndma-mx1-mx2.c: 23615\ndma-mx1-mx2.h: 2711\ndma_no.h: 16955\ndma-noncoherent.c: 10156\ndma-octeon.c: 10532\ndma-plat.h: 2025\ndmapool.c: 13226\ndmapool.h: 923\ndma-pvr2.c: 2423\ndmar.c: 31385\ndma_remapping.h: 988\ndmar.h: 6143\ndmascc.c: 37724\ndma-sh4a.h: 2469\ndma-sh7760.c: 10216\ndma-sh.c: 7913\ndma-sh.h: 2862\ndmasound: 4096\ndmasound_atari.c: 42606\ndmasound_core.c: 44456\ndmasound.h: 8131\ndmasound_paula.c: 19160\ndmasound_q40.c: 14354\ndma-swiotlb.c: 4748\ndma-sysfs.c: 4348\ndmatest.c: 15129\ndma_timer.c: 2282\ndma.txt: 6352\nDMA.txt: 6352\ndma_v.h: 1177\ndm-bio-record.h: 1629\ndm.c: 60780\ndm-crypt.c: 32243\ndm-crypt.txt: 1485\ndm-delay.c: 8567\ndm-dirty-log.h: 3944\ndme1737: 11748\ndme1737.c: 74868\ndmesg.c: 1657\ndm-exception-store.c: 6745\ndm-exception-store.h: 4659\ndmfe.c: 60351\ndmfe.txt: 2168\ndm.h: 3933\ndmi.h: 411\ndmi-id.c: 6586\ndm-io.c: 11366\ndm-ioctl.c: 33212\ndm-ioctl.h: 9109\ndm-io.h: 2051\ndm-io.txt: 3298\ndmi_scan.c: 15130\ndm-kcopyd.c: 14244\ndm-kcopyd.h: 1335\ndm-linear.c: 3614\ndm-log.c: 19367\ndm-log.txt: 2397\ndm-log-userspace-base.c: 16497\ndm-log-userspace.h: 12944\ndm-log-userspace-transfer.c: 6936\ndm-log-userspace-transfer.h: 452\ndmm32at.c: 30666\ndm-mpath.c: 37626\ndm-mpath.h: 415\ndm-path-selector.c: 2473\ndm-path-selector.h: 2533\ndm-queue-length.c: 5495\ndm-queue-length.txt: 1218\ndm-raid1.c: 32159\ndm-region-hash.c: 18043\ndm-region-hash.h: 3217\ndm-round-robin.c: 4673\ndm-service-time.c: 8360\ndm-service-time.txt: 3243\ndm-snap.c: 33940\ndm-snap-persistent.c: 17550\ndm-snap-transient.c: 3687\ndm-stripe.c: 8013\ndm-sysfs.c: 2204\ndm-table.c: 27836\ndm-target.c: 2600\ndmtimer.c: 22824\ndmtimer.h: 3450\ndm-uevent.c: 5482\ndm-uevent.h: 1678\ndm-uevent.txt: 2650\ndmv182.c: 3833\ndmx3191d.c: 4547\ndmxdev.c: 28366\ndmxdev.h: 2409\ndmx.h: 3848\ndm-zero.c: 1495\ndn_dev.c: 33824\ndn_dev.h: 5493\ndnet.c: 25715\ndnet.h: 7221\ndnfb.c: 8139\ndn_fib.c: 18396\ndn_fib.h: 4894\ndn.h: 4527\ndn_ints.c: 1049\ndn_neigh.c: 15875\ndn_neigh.h: 824\ndn_nsp.h: 6229\ndn_nsp_in.c: 21566\ndn_nsp_out.c: 17942\ndnode.c: 30235\ndnotify: 4096\ndnotify.c: 12385\ndnotify.h: 978\ndnotify.txt: 3565\ndn_route.c: 44768\ndn_route.h: 4165\ndn_rtmsg.c: 3778\ndn_rules.c: 5755\ndns323-setup.c: 10831\ndns_resolve.c: 3678\ndns_resolve.h: 1294\ndn_table.c: 20482\ndn_timer.c: 3167\ndo_balan.c: 58466\ndoc2000.c: 32664\ndoc2000.h: 5486\ndoc2001.c: 25107\ndoc2001plus.c: 31825\nDocBook: 4096\ndocecc.c: 15968\ndock.c: 31358\ndocprobe.c: 10340\ndocproc.c: 11716\ndo_csum.S: 2991\nDocumentation: 4096\ndo_func.S: 13813\ndomain.c: 29471\ndomain.h: 2107\ndo_mounts.c: 9465\ndo_mounts.h: 1396\ndo_mounts_initrd.c: 3256\ndo_mounts_md.c: 8071\ndo_mounts_rd.c: 8166\ndonauboe.c: 48207\ndonauboe.h: 14213\ndontdiff: 1964\ndoorbell.c: 2900\ndoorbell.h: 2894\ndot11d.c: 5434\ndot11d.h: 2916\ndot_command.c: 4062\ndot_command.h: 2259\ndot.gdbinit: 5372\ndot.gdbinit_200MHz_16MB: 5763\ndot.gdbinit_300MHz_32MB: 5763\ndot.gdbinit_400MHz_32MB: 5764\ndot.gdbinit.nommu: 3891\ndot.gdbinit.smp: 8938\ndot.gdbinit.vdec2: 5442\ndo_timer.h: 349\ndouble_cpdo.c: 4122\ndoublefault_32.c: 1732\ndouble.h: 6303\ndown2.H16: 33610\ndown3.bin.ihex: 35892\ndown.H16: 36678\ndp_add.c: 4700\ndpc.c: 58689\ndpc.h: 1771\ndp_cmp.c: 1842\ndpcsup.c: 9553\ndp_div.c: 4369\ndp_fint.c: 1932\ndp_flong.c: 1912\ndp_frexp.c: 1450\ndp_fsp.c: 1879\ndp_logb.c: 1446\ndpmc.c: 3024\ndpmc.h: 1247\ndpmc_modes.S: 14539\ndp_modf.c: 2064\ndp_mul.c: 4812\ndp_scalb.c: 1508\ndp_simple.c: 2057\ndp_sqrt.c: 4372\ndp_sub.c: 4977\ndpt: 4096\ndpt_i2o.c: 96500\ndpti.h: 11787\ndpti_i2o.h: 13449\ndpti_ioctl.h: 5365\ndp_tint.c: 3021\ndpti.txt: 3614\ndp_tlong.c: 3061\ndptsig.h: 14986\ndqblk_qtree.h: 2108\ndqblk_v1.h: 342\ndqblk_v2.h: 367\ndqblk_xfs.h: 6607\ndqueue.c: 2180\ndqueue.h: 1007\ndquot.c: 72530\ndraft-ietf-cipso-ipsecurity-01.txt: 28638\ndram_init.S: 3913\ndraw_functrace.py: 3560\ndreamcast_defconfig: 25856\ndriver: 11995\ndriver.c: 54722\ndriver-changes.txt: 4022\ndriver_chipcommon.c: 13262\ndriver_chipcommon_pmu.c: 17510\ndriver_extif.c: 3829\ndriver_gige.c: 7415\ndriver.h: 4405\ndriver_mipscore.c: 6999\ndriver-model: 4096\ndriver-model.txt: 10127\ndriver-ops.h: 5035\ndriver_pcicore.c: 16619\ndrivers: 4096\ndrivers.c: 22567\ndrivers-testing.txt: 2173\ndriver.txt: 8049\ndrm: 4096\ndrm_agpsupport.c: 13149\ndrm_auth.c: 5698\ndrm_bufs.c: 44350\ndrm_cache.c: 2119\ndrm_context.c: 11821\ndrm_core.h: 1468\ndrm_crtc.c: 63999\ndrm_crtc.h: 25347\ndrm_crtc_helper.c: 29207\ndrm_crtc_helper.h: 4951\ndrm_debugfs.c: 6275\ndrm_dma.c: 4147\ndrm_drawable.c: 5166\ndrm_drv.c: 16709\ndrm_edid.c: 24730\ndrm_edid.h: 5722\ndrm_fops.c: 14460\ndrm_gem.c: 14905\ndrm.h: 23018\ndrm_hashtab.c: 5440\ndrm_hashtab.h: 2589\ndrm_info.c: 9606\ndrm_ioc32.c: 33632\ndrm_ioctl.c: 9402\ndrm_irq.c: 17068\ndrm_lock.c: 11107\ndrm_memory.c: 5012\ndrm_memory.h: 1936\ndrm_mm.c: 9213\ndrm_mm.h: 3301\ndrm_mode.h: 6855\ndrm_modes.c: 14802\ndrm_os_linux.h: 4047\ndrm_pci.c: 3839\ndrm_pciids.h: 40171\ndrmP.h: 49714\ndrm_proc.c: 6339\ndrm_sarea.h: 2655\ndrm_scatter.c: 5431\ndrm_sman.c: 8782\ndrm_sman.h: 5975\ndrm_stub.c: 13017\ndrm_sysfs.c: 13561\ndrm_vm.c: 18670\ndrop_caches.c: 1684\ndrop_monitor.c: 8677\ndrp-avail.c: 8822\ndrp.c: 24684\ndrp-ie.c: 9743\ndrv.c: 22503\ndrvfbi.c: 12647\ndrx397xD.c: 30335\ndrx397xD_fw.h: 1525\ndrx397xD.h: 3015\nds1286.h: 1223\nds1287.h: 1019\nds1302.c: 7604\nds1305.h: 1068\nds1603.c: 3162\nds1603.h: 566\nds1620.c: 8486\nds1621: 2670\nds1621.c: 9932\nds1682.c: 7160\nds17287rtc.h: 2676\nds1_ctrl.fw.ihex: 33804\nds1_dsp.fw.ihex: 364\nds1e_ctrl.fw.ihex: 33804\nds1wm.c: 11691\nds1wm.h: 114\nds2482: 743\nds2482.c: 14041\nds2490: 3576\nds2490.c: 24260\nds2760_battery.c: 13485\ndsa: 4096\ndsa.c: 9418\ndsa.h: 1617\ndsa_priv.h: 4060\ndsbr100.c: 17605\nds.c: 38706\ndsc.c: 1195\ndscc4.c: 55052\ndsdt-override.txt: 247\ndsemul.c: 4501\ndsfield.c: 19154\ndsfield.h: 1127\nds.h: 8003\ndsinit.c: 6745\ndsmethod.c: 19169\ndsmg600.h: 1216\ndsmg600-pci.c: 1898\ndsmg600-setup.c: 7030\ndsmthdat.c: 21585\ndsobject.c: 23900\ndsopcode.c: 39305\ndsp56k: 4096\ndsp56k.c: 12404\ndsp56k.h: 1269\ndsp_audio.c: 11056\ndsp_biquad.h: 1622\ndsp_blowfish.c: 23738\ndspbootcode.bin.ihex: 36048\ndsp_cmx.c: 52826\ndsp_common.h: 1309\ndsp_core.c: 33551\ndsp_defs.h: 12149\ndspdids.h: 2695\ndsp_dtmf.c: 7570\ndsp_ecdis.h: 3527\ndsp.h: 7893\ndsp_hwec.c: 3049\ndsp_hwec.h: 242\ndsp_pipeline.c: 8348\ndsp_spos.c: 55617\ndsp_spos.h: 7631\ndsp_spos_scb_lib.c: 49424\ndsp_tones.c: 17264\ndsp_tst.h: 1486\ndsrv4bri.h: 1644\ndsrv_bri.h: 1178\ndsrv_pri.h: 1247\nds_selftest.c: 9393\nds_selftest.h: 363\ndst: 4096\ndst.c: 49967\ndst_ca.c: 21634\ndst_ca.h: 1591\ndst_common.h: 4277\ndst.h: 14556\ndst_priv.h: 598\ndstr.c: 5143\ndsutils.c: 25450\ndswexec.c: 19731\ndswload.c: 31066\ndswscope.c: 6750\ndswstate.c: 21428\ndt019x.c: 9062\ndt2801.c: 15251\ndt2811.c: 14680\ndt2814.c: 8589\ndt2815.c: 7337\ndt2817.c: 4517\ndt282x.c: 35248\ndt3000.c: 23494\ndt9812.c: 28480\ndtc: 4096\ndt.c: 16907\ndtc2278.c: 3867\ndtc3x80.txt: 1952\ndtc.c: 13348\ndtc.h: 2644\ndtc-lexer.l: 6979\ndtc-lexer.lex.c_shipped: 57920\ndtc-parser.tab.c_shipped: 55472\ndtc-parser.tab.h_shipped: 3233\ndtc-parser.y: 6540\ndtc-src: 4096\ndtl1_cs.c: 14325\ndtlb_miss.S: 747\ndtlb_prot.S: 1267\ndtl.c: 6493\ndtlk.c: 16644\ndtlk.h: 3768\ndts: 4096\ndts-bindings: 4096\ndtt200u.c: 9848\ndtt200u-fe.c: 5300\ndtt200u.h: 1606\ndtv5100.c: 5845\ndtv5100.h: 1534\ndum.h: 7581\ndummy.c: 3850\ndummycon.c: 1805\ndummy_hcd.c: 50629\ndump_pagetables.c: 8879\ndumprequest.c: 3343\ndumprequest.h: 2117\ndumpstack_32.c: 3323\ndumpstack_64.c: 7276\ndump_stack.c: 290\ndumpstack.c: 8067\ndumpstack.h: 1003\ndump_tlb.c: 2643\ndv1394: 390\ndv1394.c: 74226\ndv1394.h: 10409\ndv1394-private.h: 17471\ndvb: 4096\ndvb-bt8xx.c: 28096\ndvb-bt8xx.h: 1816\ndvb_ca_en50221.c: 45737\ndvb_ca_en50221.h: 4082\ndvb-core: 4096\ndvb_demux.c: 30507\ndvb_demux.h: 3579\ndvbdev.c: 11761\ndvbdev.h: 4065\ndvb_dummy_fe.c: 7049\ndvb_dummy_fe.h: 1698\ndvb_filter.c: 12922\ndvb_filter.h: 6064\ndvb_frontend.c: 54720\ndvb_frontend.h: 11618\ndvb_math.c: 5423\ndvb_math.h: 1974\ndvb_net.c: 42892\ndvb_net.h: 1379\ndvb-pll.c: 17175\ndvb-pll.h: 1617\ndvb_ringbuffer.c: 7188\ndvb_ringbuffer.h: 6340\ndvb-ttusb-budget.c: 44105\ndvb-usb: 12288\ndvb-usb-common.h: 2150\ndvb-usb-dvb.c: 5850\ndvb-usb-firmware.c: 3956\ndvb-usb.h: 12194\ndvb-usb-i2c.c: 1061\ndvb-usb-ids.h: 11042\ndvb-usb-init.c: 8477\ndvb-usb-remote.c: 5519\ndvb-usb-urb.c: 2585\ndvi.c: 18260\ndvi.h: 2461\ndvma.c: 1265\ndvma.h: 9864\ndvo_ch7017.c: 14698\ndvo_ch7xxx.c: 9179\ndvo.h: 4860\ndvo_ivch.c: 10628\ndvo_sil164.c: 7534\ndvo_tfp410.c: 8848\ndw2102.c: 27129\ndw2102.h: 240\ndwarf2.h: 2393\ndw_dmac.c: 37849\ndw_dmac.h: 3078\ndw_dmac_regs.h: 6137\ndynamic_debug.c: 18386\ndynamic_debug.h: 2666\ndynamic-debug-howto.txt: 8633\ndyn.lds.S: 5092\ndz.c: 23133\ndz.h: 5439\ne00154b8e949bf4b89ac198aef9a247532ac2d: 297\ne100: 4096\ne1000: 4096\ne1000_82575.c: 42179\ne1000_82575.h: 8176\ne1000_defines.h: 28796\ne1000e: 4096\ne1000_ethtool.c: 56605\n"
        },
        {
          "name": "qemu-doc.texi",
          "type": "blob",
          "size": 92.76953125,
          "content": "\\input texinfo @c -*- texinfo -*-\n@c %**start of header\n@setfilename qemu-doc.info\n\n@documentlanguage en\n@documentencoding UTF-8\n\n@settitle QEMU Emulator User Documentation\n@exampleindent 0\n@paragraphindent 0\n@c %**end of header\n\n@ifinfo\n@direntry\n* QEMU: (qemu-doc).    The QEMU Emulator User Documentation.\n@end direntry\n@end ifinfo\n\n@iftex\n@titlepage\n@sp 7\n@center @titlefont{QEMU Emulator}\n@sp 1\n@center @titlefont{User Documentation}\n@sp 3\n@end titlepage\n@end iftex\n\n@ifnottex\n@node Top\n@top\n\n@menu\n* Introduction::\n* QEMU PC System emulator::\n* QEMU System emulator for non PC targets::\n* QEMU User space emulator::\n* Implementation notes::\n* License::\n* Index::\n@end menu\n@end ifnottex\n\n@contents\n\n@node Introduction\n@chapter Introduction\n\n@menu\n* intro_features:: Features\n@end menu\n\n@node intro_features\n@section Features\n\nQEMU is a FAST! processor emulator using dynamic translation to\nachieve good emulation speed.\n\n@cindex operating modes\nQEMU has two operating modes:\n\n@itemize\n@cindex system emulation\n@item Full system emulation. In this mode, QEMU emulates a full system (for\nexample a PC), including one or several processors and various\nperipherals. It can be used to launch different Operating Systems\nwithout rebooting the PC or to debug system code.\n\n@cindex user mode emulation\n@item User mode emulation. In this mode, QEMU can launch\nprocesses compiled for one CPU on another CPU. It can be used to\nlaunch the Wine Windows API emulator (@url{http://www.winehq.org}) or\nto ease cross-compilation and cross-debugging.\n\n@end itemize\n\nQEMU has the following features:\n\n@itemize\n@item QEMU can run without a host kernel driver and yet gives acceptable\nperformance.  It uses dynamic translation to native code for reasonable speed,\nwith support for self-modifying code and precise exceptions.\n\n@item It is portable to several operating systems (GNU/Linux, *BSD, Mac OS X,\nWindows) and architectures.\n\n@item It performs accurate software emulation of the FPU.\n@end itemize\n\nQEMU user mode emulation has the following features:\n@itemize\n@item Generic Linux system call converter, including most ioctls.\n\n@item clone() emulation using native CPU clone() to use Linux scheduler for threads.\n\n@item Accurate signal handling by remapping host signals to target signals.\n@end itemize\n\nQEMU full system emulation has the following features:\n@itemize\n@item\nQEMU uses a full software MMU for maximum portability.\n\n@item\nQEMU can optionally use an in-kernel accelerator, like kvm. The accelerators \nexecute most of the guest code natively, while\ncontinuing to emulate the rest of the machine.\n\n@item\nVarious hardware devices can be emulated and in some cases, host\ndevices (e.g. serial and parallel ports, USB, drives) can be used\ntransparently by the guest Operating System. Host device passthrough\ncan be used for talking to external physical peripherals (e.g. a\nwebcam, modem or tape drive).\n\n@item\nSymmetric multiprocessing (SMP) support.  Currently, an in-kernel\naccelerator is required to use more than one host CPU for emulation.\n\n@end itemize\n\n\n@node QEMU PC System emulator\n@chapter QEMU PC System emulator\n@cindex system emulation (PC)\n\n@menu\n* pcsys_introduction:: Introduction\n* pcsys_quickstart::   Quick Start\n* sec_invocation::     Invocation\n* pcsys_keys::         Keys in the graphical frontends\n* mux_keys::           Keys in the character backend multiplexer\n* pcsys_monitor::      QEMU Monitor\n* disk_images::        Disk Images\n* pcsys_network::      Network emulation\n* pcsys_other_devs::   Other Devices\n* direct_linux_boot::  Direct Linux Boot\n* pcsys_usb::          USB emulation\n* vnc_security::       VNC security\n* gdb_usage::          GDB usage\n* pcsys_os_specific::  Target OS specific information\n@end menu\n\n@node pcsys_introduction\n@section Introduction\n\n@c man begin DESCRIPTION\n\nThe QEMU PC System emulator simulates the\nfollowing peripherals:\n\n@itemize @minus\n@item\ni440FX host PCI bridge and PIIX3 PCI to ISA bridge\n@item\nCirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA\nextensions (hardware level, including all non standard modes).\n@item\nPS/2 mouse and keyboard\n@item\n2 PCI IDE interfaces with hard disk and CD-ROM support\n@item\nFloppy disk\n@item\nPCI and ISA network adapters\n@item\nSerial ports\n@item\nIPMI BMC, either and internal or external one\n@item\nCreative SoundBlaster 16 sound card\n@item\nENSONIQ AudioPCI ES1370 sound card\n@item\nIntel 82801AA AC97 Audio compatible sound card\n@item\nIntel HD Audio Controller and HDA codec\n@item\nAdlib (OPL2) - Yamaha YM3812 compatible chip\n@item\nGravis Ultrasound GF1 sound card\n@item\nCS4231A compatible sound card\n@item\nPCI UHCI USB controller and a virtual USB hub.\n@end itemize\n\nSMP is supported with up to 255 CPUs.\n\nQEMU uses the PC BIOS from the Seabios project and the Plex86/Bochs LGPL\nVGA BIOS.\n\nQEMU uses YM3812 emulation by Tatsuyuki Satoh.\n\nQEMU uses GUS emulation (GUSEMU32 @url{http://www.deinmeister.de/gusemu/})\nby Tibor \"TS\" Schütz.\n\nNote that, by default, GUS shares IRQ(7) with parallel ports and so\nQEMU must be told to not have parallel ports to have working GUS.\n\n@example\nqemu-system-i386 dos.img -soundhw gus -parallel none\n@end example\n\nAlternatively:\n@example\nqemu-system-i386 dos.img -device gus,irq=5\n@end example\n\nOr some other unclaimed IRQ.\n\nCS4231A is the chip used in Windows Sound System and GUSMAX products\n\n@c man end\n\n@node pcsys_quickstart\n@section Quick Start\n@cindex quick start\n\nDownload and uncompress the linux image (@file{linux.img}) and type:\n\n@example\nqemu-system-i386 linux.img\n@end example\n\nLinux should boot and give you a prompt.\n\n@node sec_invocation\n@section Invocation\n\n@example\n@c man begin SYNOPSIS\n@command{qemu-system-i386} [@var{options}] [@var{disk_image}]\n@c man end\n@end example\n\n@c man begin OPTIONS\n@var{disk_image} is a raw hard disk image for IDE hard disk 0. Some\ntargets do not need a disk image.\n\n@include qemu-options.texi\n\n@c man end\n\n@node pcsys_keys\n@section Keys in the graphical frontends\n\n@c man begin OPTIONS\n\nDuring the graphical emulation, you can use special key combinations to change\nmodes. The default key mappings are shown below, but if you use @code{-alt-grab}\nthen the modifier is Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use\n@code{-ctrl-grab} then the modifier is the right Ctrl key (instead of Ctrl-Alt):\n\n@table @key\n@item Ctrl-Alt-f\n@kindex Ctrl-Alt-f\nToggle full screen\n\n@item Ctrl-Alt-+\n@kindex Ctrl-Alt-+\nEnlarge the screen\n\n@item Ctrl-Alt--\n@kindex Ctrl-Alt--\nShrink the screen\n\n@item Ctrl-Alt-u\n@kindex Ctrl-Alt-u\nRestore the screen's un-scaled dimensions\n\n@item Ctrl-Alt-n\n@kindex Ctrl-Alt-n\nSwitch to virtual console 'n'. Standard console mappings are:\n@table @emph\n@item 1\nTarget system display\n@item 2\nMonitor\n@item 3\nSerial port\n@end table\n\n@item Ctrl-Alt\n@kindex Ctrl-Alt\nToggle mouse and keyboard grab.\n@end table\n\n@kindex Ctrl-Up\n@kindex Ctrl-Down\n@kindex Ctrl-PageUp\n@kindex Ctrl-PageDown\nIn the virtual consoles, you can use @key{Ctrl-Up}, @key{Ctrl-Down},\n@key{Ctrl-PageUp} and @key{Ctrl-PageDown} to move in the back log.\n\n@c man end\n\n@node mux_keys\n@section Keys in the character backend multiplexer\n\n@c man begin OPTIONS\n\nDuring emulation, if you are using a character backend multiplexer\n(which is the default if you are using @option{-nographic}) then\nseveral commands are available via an escape sequence. These\nkey sequences all start with an escape character, which is @key{Ctrl-a}\nby default, but can be changed with @option{-echr}. The list below assumes\nyou're using the default.\n\n@table @key\n@item Ctrl-a h\n@kindex Ctrl-a h\nPrint this help\n@item Ctrl-a x\n@kindex Ctrl-a x\nExit emulator\n@item Ctrl-a s\n@kindex Ctrl-a s\nSave disk data back to file (if -snapshot)\n@item Ctrl-a t\n@kindex Ctrl-a t\nToggle console timestamps\n@item Ctrl-a b\n@kindex Ctrl-a b\nSend break (magic sysrq in Linux)\n@item Ctrl-a c\n@kindex Ctrl-a c\nRotate between the frontends connected to the multiplexer (usually\nthis switches between the monitor and the console)\n@item Ctrl-a Ctrl-a\n@kindex Ctrl-a Ctrl-a\nSend the escape character to the frontend\n@end table\n@c man end\n\n@ignore\n\n@c man begin SEEALSO\nThe HTML documentation of QEMU for more precise information and Linux\nuser mode emulator invocation.\n@c man end\n\n@c man begin AUTHOR\nFabrice Bellard\n@c man end\n\n@end ignore\n\n@node pcsys_monitor\n@section QEMU Monitor\n@cindex QEMU monitor\n\nThe QEMU monitor is used to give complex commands to the QEMU\nemulator. You can use it to:\n\n@itemize @minus\n\n@item\nRemove or insert removable media images\n(such as CD-ROM or floppies).\n\n@item\nFreeze/unfreeze the Virtual Machine (VM) and save or restore its state\nfrom a disk file.\n\n@item Inspect the VM state without an external debugger.\n\n@end itemize\n\n@subsection Commands\n\nThe following commands are available:\n\n@include qemu-monitor.texi\n\n@include qemu-monitor-info.texi\n\n@subsection Integer expressions\n\nThe monitor understands integers expressions for every integer\nargument. You can use register names to get the value of specifics\nCPU registers by prefixing them with @emph{$}.\n\n@node disk_images\n@section Disk Images\n\nSince version 0.6.1, QEMU supports many disk image formats, including\ngrowable disk images (their size increase as non empty sectors are\nwritten), compressed and encrypted disk images. Version 0.8.3 added\nthe new qcow2 disk image format which is essential to support VM\nsnapshots.\n\n@menu\n* disk_images_quickstart::    Quick start for disk image creation\n* disk_images_snapshot_mode:: Snapshot mode\n* vm_snapshots::              VM snapshots\n* qemu_img_invocation::       qemu-img Invocation\n* qemu_nbd_invocation::       qemu-nbd Invocation\n* qemu_ga_invocation::        qemu-ga Invocation\n* disk_images_formats::       Disk image file formats\n* host_drives::               Using host drives\n* disk_images_fat_images::    Virtual FAT disk images\n* disk_images_nbd::           NBD access\n* disk_images_sheepdog::      Sheepdog disk images\n* disk_images_iscsi::         iSCSI LUNs\n* disk_images_gluster::       GlusterFS disk images\n* disk_images_ssh::           Secure Shell (ssh) disk images\n@end menu\n\n@node disk_images_quickstart\n@subsection Quick start for disk image creation\n\nYou can create a disk image with the command:\n@example\nqemu-img create myimage.img mysize\n@end example\nwhere @var{myimage.img} is the disk image filename and @var{mysize} is its\nsize in kilobytes. You can add an @code{M} suffix to give the size in\nmegabytes and a @code{G} suffix for gigabytes.\n\nSee @ref{qemu_img_invocation} for more information.\n\n@node disk_images_snapshot_mode\n@subsection Snapshot mode\n\nIf you use the option @option{-snapshot}, all disk images are\nconsidered as read only. When sectors in written, they are written in\na temporary file created in @file{/tmp}. You can however force the\nwrite back to the raw disk images by using the @code{commit} monitor\ncommand (or @key{C-a s} in the serial console).\n\n@node vm_snapshots\n@subsection VM snapshots\n\nVM snapshots are snapshots of the complete virtual machine including\nCPU state, RAM, device state and the content of all the writable\ndisks. In order to use VM snapshots, you must have at least one non\nremovable and writable block device using the @code{qcow2} disk image\nformat. Normally this device is the first virtual hard drive.\n\nUse the monitor command @code{savevm} to create a new VM snapshot or\nreplace an existing one. A human readable name can be assigned to each\nsnapshot in addition to its numerical ID.\n\nUse @code{loadvm} to restore a VM snapshot and @code{delvm} to remove\na VM snapshot. @code{info snapshots} lists the available snapshots\nwith their associated information:\n\n@example\n(qemu) info snapshots\nSnapshot devices: hda\nSnapshot list (from hda):\nID        TAG                 VM SIZE                DATE       VM CLOCK\n1         start                   41M 2006-08-06 12:38:02   00:00:14.954\n2                                 40M 2006-08-06 12:43:29   00:00:18.633\n3         msys                    40M 2006-08-06 12:44:04   00:00:23.514\n@end example\n\nA VM snapshot is made of a VM state info (its size is shown in\n@code{info snapshots}) and a snapshot of every writable disk image.\nThe VM state info is stored in the first @code{qcow2} non removable\nand writable block device. The disk image snapshots are stored in\nevery disk image. The size of a snapshot in a disk image is difficult\nto evaluate and is not shown by @code{info snapshots} because the\nassociated disk sectors are shared among all the snapshots to save\ndisk space (otherwise each snapshot would need a full copy of all the\ndisk images).\n\nWhen using the (unrelated) @code{-snapshot} option\n(@ref{disk_images_snapshot_mode}), you can always make VM snapshots,\nbut they are deleted as soon as you exit QEMU.\n\nVM snapshots currently have the following known limitations:\n@itemize\n@item\nThey cannot cope with removable devices if they are removed or\ninserted after a snapshot is done.\n@item\nA few device drivers still have incomplete snapshot support so their\nstate is not saved or restored properly (in particular USB).\n@end itemize\n\n@node qemu_img_invocation\n@subsection @code{qemu-img} Invocation\n\n@include qemu-img.texi\n\n@node qemu_nbd_invocation\n@subsection @code{qemu-nbd} Invocation\n\n@include qemu-nbd.texi\n\n@node qemu_ga_invocation\n@subsection @code{qemu-ga} Invocation\n\n@include qemu-ga.texi\n\n@node disk_images_formats\n@subsection Disk image file formats\n\nQEMU supports many image file formats that can be used with VMs as well as with\nany of the tools (like @code{qemu-img}). This includes the preferred formats\nraw and qcow2 as well as formats that are supported for compatibility with\nolder QEMU versions or other hypervisors.\n\nDepending on the image format, different options can be passed to\n@code{qemu-img create} and @code{qemu-img convert} using the @code{-o} option.\nThis section describes each format and the options that are supported for it.\n\n@table @option\n@item raw\n\nRaw disk image format. This format has the advantage of\nbeing simple and easily exportable to all other emulators. If your\nfile system supports @emph{holes} (for example in ext2 or ext3 on\nLinux or NTFS on Windows), then only the written sectors will reserve\nspace. Use @code{qemu-img info} to know the real size used by the\nimage or @code{ls -ls} on Unix/Linux.\n\nSupported options:\n@table @code\n@item preallocation\nPreallocation mode (allowed values: @code{off}, @code{falloc}, @code{full}).\n@code{falloc} mode preallocates space for image by calling posix_fallocate().\n@code{full} mode preallocates space for image by writing zeros to underlying\nstorage.\n@end table\n\n@item qcow2\nQEMU image format, the most versatile format. Use it to have smaller\nimages (useful if your filesystem does not supports holes, for example\non Windows), zlib based compression and support of multiple VM\nsnapshots.\n\nSupported options:\n@table @code\n@item compat\nDetermines the qcow2 version to use. @code{compat=0.10} uses the\ntraditional image format that can be read by any QEMU since 0.10.\n@code{compat=1.1} enables image format extensions that only QEMU 1.1 and\nnewer understand (this is the default). Amongst others, this includes\nzero clusters, which allow efficient copy-on-read for sparse images.\n\n@item backing_file\nFile name of a base image (see @option{create} subcommand)\n@item backing_fmt\nImage format of the base image\n@item encryption\nIf this option is set to @code{on}, the image is encrypted with 128-bit AES-CBC.\n\nThe use of encryption in qcow and qcow2 images is considered to be flawed by\nmodern cryptography standards, suffering from a number of design problems:\n\n@itemize @minus\n@item The AES-CBC cipher is used with predictable initialization vectors based\non the sector number. This makes it vulnerable to chosen plaintext attacks\nwhich can reveal the existence of encrypted data.\n@item The user passphrase is directly used as the encryption key. A poorly\nchosen or short passphrase will compromise the security of the encryption.\n@item In the event of the passphrase being compromised there is no way to\nchange the passphrase to protect data in any qcow images. The files must\nbe cloned, using a different encryption passphrase in the new file. The\noriginal file must then be securely erased using a program like shred,\nthough even this is ineffective with many modern storage technologies.\n@end itemize\n\nUse of qcow / qcow2 encryption with QEMU is deprecated, and support for\nit will go away in a future release.  Users are recommended to use an\nalternative encryption technology such as the Linux dm-crypt / LUKS\nsystem.\n\n@item cluster_size\nChanges the qcow2 cluster size (must be between 512 and 2M). Smaller cluster\nsizes can improve the image file size whereas larger cluster sizes generally\nprovide better performance.\n\n@item preallocation\nPreallocation mode (allowed values: @code{off}, @code{metadata}, @code{falloc},\n@code{full}). An image with preallocated metadata is initially larger but can\nimprove performance when the image needs to grow. @code{falloc} and @code{full}\npreallocations are like the same options of @code{raw} format, but sets up\nmetadata also.\n\n@item lazy_refcounts\nIf this option is set to @code{on}, reference count updates are postponed with\nthe goal of avoiding metadata I/O and improving performance. This is\nparticularly interesting with @option{cache=writethrough} which doesn't batch\nmetadata updates. The tradeoff is that after a host crash, the reference count\ntables must be rebuilt, i.e. on the next open an (automatic) @code{qemu-img\ncheck -r all} is required, which may take some time.\n\nThis option can only be enabled if @code{compat=1.1} is specified.\n\n@item nocow\nIf this option is set to @code{on}, it will turn off COW of the file. It's only\nvalid on btrfs, no effect on other file systems.\n\nBtrfs has low performance when hosting a VM image file, even more when the guest\non the VM also using btrfs as file system. Turning off COW is a way to mitigate\nthis bad performance. Generally there are two ways to turn off COW on btrfs:\na) Disable it by mounting with nodatacow, then all newly created files will be\nNOCOW. b) For an empty file, add the NOCOW file attribute. That's what this option\ndoes.\n\nNote: this option is only valid to new or empty files. If there is an existing\nfile which is COW and has data blocks already, it couldn't be changed to NOCOW\nby setting @code{nocow=on}. One can issue @code{lsattr filename} to check if\nthe NOCOW flag is set or not (Capital 'C' is NOCOW flag).\n\n@end table\n\n@item qed\nOld QEMU image format with support for backing files and compact image files\n(when your filesystem or transport medium does not support holes).\n\nWhen converting QED images to qcow2, you might want to consider using the\n@code{lazy_refcounts=on} option to get a more QED-like behaviour.\n\nSupported options:\n@table @code\n@item backing_file\nFile name of a base image (see @option{create} subcommand).\n@item backing_fmt\nImage file format of backing file (optional).  Useful if the format cannot be\nautodetected because it has no header, like some vhd/vpc files.\n@item cluster_size\nChanges the cluster size (must be power-of-2 between 4K and 64K). Smaller\ncluster sizes can improve the image file size whereas larger cluster sizes\ngenerally provide better performance.\n@item table_size\nChanges the number of clusters per L1/L2 table (must be power-of-2 between 1\nand 16).  There is normally no need to change this value but this option can be\nused for performance benchmarking.\n@end table\n\n@item qcow\nOld QEMU image format with support for backing files, compact image files,\nencryption and compression.\n\nSupported options:\n@table @code\n@item backing_file\nFile name of a base image (see @option{create} subcommand)\n@item encryption\nIf this option is set to @code{on}, the image is encrypted.\n@end table\n\n@item vdi\nVirtualBox 1.1 compatible image format.\nSupported options:\n@table @code\n@item static\nIf this option is set to @code{on}, the image is created with metadata\npreallocation.\n@end table\n\n@item vmdk\nVMware 3 and 4 compatible image format.\n\nSupported options:\n@table @code\n@item backing_file\nFile name of a base image (see @option{create} subcommand).\n@item compat6\nCreate a VMDK version 6 image (instead of version 4)\n@item hwversion\nSpecify vmdk virtual hardware version. Compat6 flag cannot be enabled\nif hwversion is specified.\n@item subformat\nSpecifies which VMDK subformat to use. Valid options are\n@code{monolithicSparse} (default),\n@code{monolithicFlat},\n@code{twoGbMaxExtentSparse},\n@code{twoGbMaxExtentFlat} and\n@code{streamOptimized}.\n@end table\n\n@item vpc\nVirtualPC compatible image format (VHD).\nSupported options:\n@table @code\n@item subformat\nSpecifies which VHD subformat to use. Valid options are\n@code{dynamic} (default) and @code{fixed}.\n@end table\n\n@item VHDX\nHyper-V compatible image format (VHDX).\nSupported options:\n@table @code\n@item subformat\nSpecifies which VHDX subformat to use. Valid options are\n@code{dynamic} (default) and @code{fixed}.\n@item block_state_zero\nForce use of payload blocks of type 'ZERO'.  Can be set to @code{on} (default)\nor @code{off}.  When set to @code{off}, new blocks will be created as\n@code{PAYLOAD_BLOCK_NOT_PRESENT}, which means parsers are free to return\narbitrary data for those blocks.  Do not set to @code{off} when using\n@code{qemu-img convert} with @code{subformat=dynamic}.\n@item block_size\nBlock size; min 1 MB, max 256 MB.  0 means auto-calculate based on image size.\n@item log_size\nLog size; min 1 MB.\n@end table\n@end table\n\n@subsubsection Read-only formats\nMore disk image file formats are supported in a read-only mode.\n@table @option\n@item bochs\nBochs images of @code{growing} type.\n@item cloop\nLinux Compressed Loop image, useful only to reuse directly compressed\nCD-ROM images present for example in the Knoppix CD-ROMs.\n@item dmg\nApple disk image.\n@item parallels\nParallels disk image format.\n@end table\n\n\n@node host_drives\n@subsection Using host drives\n\nIn addition to disk image files, QEMU can directly access host\ndevices. We describe here the usage for QEMU version >= 0.8.3.\n\n@subsubsection Linux\n\nOn Linux, you can directly use the host device filename instead of a\ndisk image filename provided you have enough privileges to access\nit. For example, use @file{/dev/cdrom} to access to the CDROM.\n\n@table @code\n@item CD\nYou can specify a CDROM device even if no CDROM is loaded. QEMU has\nspecific code to detect CDROM insertion or removal. CDROM ejection by\nthe guest OS is supported. Currently only data CDs are supported.\n@item Floppy\nYou can specify a floppy device even if no floppy is loaded. Floppy\nremoval is currently not detected accurately (if you change floppy\nwithout doing floppy access while the floppy is not loaded, the guest\nOS will think that the same floppy is loaded).\nUse of the host's floppy device is deprecated, and support for it will\nbe removed in a future release.\n@item Hard disks\nHard disks can be used. Normally you must specify the whole disk\n(@file{/dev/hdb} instead of @file{/dev/hdb1}) so that the guest OS can\nsee it as a partitioned disk. WARNING: unless you know what you do, it\nis better to only make READ-ONLY accesses to the hard disk otherwise\nyou may corrupt your host data (use the @option{-snapshot} command\nline option or modify the device permissions accordingly).\n@end table\n\n@subsubsection Windows\n\n@table @code\n@item CD\nThe preferred syntax is the drive letter (e.g. @file{d:}). The\nalternate syntax @file{\\\\.\\d:} is supported. @file{/dev/cdrom} is\nsupported as an alias to the first CDROM drive.\n\nCurrently there is no specific code to handle removable media, so it\nis better to use the @code{change} or @code{eject} monitor commands to\nchange or eject media.\n@item Hard disks\nHard disks can be used with the syntax: @file{\\\\.\\PhysicalDrive@var{N}}\nwhere @var{N} is the drive number (0 is the first hard disk).\n\nWARNING: unless you know what you do, it is better to only make\nREAD-ONLY accesses to the hard disk otherwise you may corrupt your\nhost data (use the @option{-snapshot} command line so that the\nmodifications are written in a temporary file).\n@end table\n\n\n@subsubsection Mac OS X\n\n@file{/dev/cdrom} is an alias to the first CDROM.\n\nCurrently there is no specific code to handle removable media, so it\nis better to use the @code{change} or @code{eject} monitor commands to\nchange or eject media.\n\n@node disk_images_fat_images\n@subsection Virtual FAT disk images\n\nQEMU can automatically create a virtual FAT disk image from a\ndirectory tree. In order to use it, just type:\n\n@example\nqemu-system-i386 linux.img -hdb fat:/my_directory\n@end example\n\nThen you access access to all the files in the @file{/my_directory}\ndirectory without having to copy them in a disk image or to export\nthem via SAMBA or NFS. The default access is @emph{read-only}.\n\nFloppies can be emulated with the @code{:floppy:} option:\n\n@example\nqemu-system-i386 linux.img -fda fat:floppy:/my_directory\n@end example\n\nA read/write support is available for testing (beta stage) with the\n@code{:rw:} option:\n\n@example\nqemu-system-i386 linux.img -fda fat:floppy:rw:/my_directory\n@end example\n\nWhat you should @emph{never} do:\n@itemize\n@item use non-ASCII filenames ;\n@item use \"-snapshot\" together with \":rw:\" ;\n@item expect it to work when loadvm'ing ;\n@item write to the FAT directory on the host system while accessing it with the guest system.\n@end itemize\n\n@node disk_images_nbd\n@subsection NBD access\n\nQEMU can access directly to block device exported using the Network Block Device\nprotocol.\n\n@example\nqemu-system-i386 linux.img -hdb nbd://my_nbd_server.mydomain.org:1024/\n@end example\n\nIf the NBD server is located on the same host, you can use an unix socket instead\nof an inet socket:\n\n@example\nqemu-system-i386 linux.img -hdb nbd+unix://?socket=/tmp/my_socket\n@end example\n\nIn this case, the block device must be exported using qemu-nbd:\n\n@example\nqemu-nbd --socket=/tmp/my_socket my_disk.qcow2\n@end example\n\nThe use of qemu-nbd allows sharing of a disk between several guests:\n@example\nqemu-nbd --socket=/tmp/my_socket --share=2 my_disk.qcow2\n@end example\n\n@noindent\nand then you can use it with two guests:\n@example\nqemu-system-i386 linux1.img -hdb nbd+unix://?socket=/tmp/my_socket\nqemu-system-i386 linux2.img -hdb nbd+unix://?socket=/tmp/my_socket\n@end example\n\nIf the nbd-server uses named exports (supported since NBD 2.9.18, or with QEMU's\nown embedded NBD server), you must specify an export name in the URI:\n@example\nqemu-system-i386 -cdrom nbd://localhost/debian-500-ppc-netinst\nqemu-system-i386 -cdrom nbd://localhost/openSUSE-11.1-ppc-netinst\n@end example\n\nThe URI syntax for NBD is supported since QEMU 1.3.  An alternative syntax is\nalso available.  Here are some example of the older syntax:\n@example\nqemu-system-i386 linux.img -hdb nbd:my_nbd_server.mydomain.org:1024\nqemu-system-i386 linux2.img -hdb nbd:unix:/tmp/my_socket\nqemu-system-i386 -cdrom nbd:localhost:10809:exportname=debian-500-ppc-netinst\n@end example\n\n@node disk_images_sheepdog\n@subsection Sheepdog disk images\n\nSheepdog is a distributed storage system for QEMU.  It provides highly\navailable block level storage volumes that can be attached to\nQEMU-based virtual machines.\n\nYou can create a Sheepdog disk image with the command:\n@example\nqemu-img create sheepdog:///@var{image} @var{size}\n@end example\nwhere @var{image} is the Sheepdog image name and @var{size} is its\nsize.\n\nTo import the existing @var{filename} to Sheepdog, you can use a\nconvert command.\n@example\nqemu-img convert @var{filename} sheepdog:///@var{image}\n@end example\n\nYou can boot from the Sheepdog disk image with the command:\n@example\nqemu-system-i386 sheepdog:///@var{image}\n@end example\n\nYou can also create a snapshot of the Sheepdog image like qcow2.\n@example\nqemu-img snapshot -c @var{tag} sheepdog:///@var{image}\n@end example\nwhere @var{tag} is a tag name of the newly created snapshot.\n\nTo boot from the Sheepdog snapshot, specify the tag name of the\nsnapshot.\n@example\nqemu-system-i386 sheepdog:///@var{image}#@var{tag}\n@end example\n\nYou can create a cloned image from the existing snapshot.\n@example\nqemu-img create -b sheepdog:///@var{base}#@var{tag} sheepdog:///@var{image}\n@end example\nwhere @var{base} is a image name of the source snapshot and @var{tag}\nis its tag name.\n\nYou can use an unix socket instead of an inet socket:\n\n@example\nqemu-system-i386 sheepdog+unix:///@var{image}?socket=@var{path}\n@end example\n\nIf the Sheepdog daemon doesn't run on the local host, you need to\nspecify one of the Sheepdog servers to connect to.\n@example\nqemu-img create sheepdog://@var{hostname}:@var{port}/@var{image} @var{size}\nqemu-system-i386 sheepdog://@var{hostname}:@var{port}/@var{image}\n@end example\n\n@node disk_images_iscsi\n@subsection iSCSI LUNs\n\niSCSI is a popular protocol used to access SCSI devices across a computer\nnetwork.\n\nThere are two different ways iSCSI devices can be used by QEMU.\n\nThe first method is to mount the iSCSI LUN on the host, and make it appear as\nany other ordinary SCSI device on the host and then to access this device as a\n/dev/sd device from QEMU. How to do this differs between host OSes.\n\nThe second method involves using the iSCSI initiator that is built into\nQEMU. This provides a mechanism that works the same way regardless of which\nhost OS you are running QEMU on. This section will describe this second method\nof using iSCSI together with QEMU.\n\nIn QEMU, iSCSI devices are described using special iSCSI URLs\n\n@example\nURL syntax:\niscsi://[<username>[%<password>]@@]<host>[:<port>]/<target-iqn-name>/<lun>\n@end example\n\nUsername and password are optional and only used if your target is set up\nusing CHAP authentication for access control.\nAlternatively the username and password can also be set via environment\nvariables to have these not show up in the process list\n\n@example\nexport LIBISCSI_CHAP_USERNAME=<username>\nexport LIBISCSI_CHAP_PASSWORD=<password>\niscsi://<host>/<target-iqn-name>/<lun>\n@end example\n\nVarious session related parameters can be set via special options, either\nin a configuration file provided via '-readconfig' or directly on the\ncommand line.\n\nIf the initiator-name is not specified qemu will use a default name\nof 'iqn.2008-11.org.linux-kvm[:<name>'] where <name> is the name of the\nvirtual machine.\n\n\n@example\nSetting a specific initiator name to use when logging in to the target\n-iscsi initiator-name=iqn.qemu.test:my-initiator\n@end example\n\n@example\nControlling which type of header digest to negotiate with the target\n-iscsi header-digest=CRC32C|CRC32C-NONE|NONE-CRC32C|NONE\n@end example\n\nThese can also be set via a configuration file\n@example\n[iscsi]\n  user = \"CHAP username\"\n  password = \"CHAP password\"\n  initiator-name = \"iqn.qemu.test:my-initiator\"\n  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE\n  header-digest = \"CRC32C\"\n@end example\n\n\nSetting the target name allows different options for different targets\n@example\n[iscsi \"iqn.target.name\"]\n  user = \"CHAP username\"\n  password = \"CHAP password\"\n  initiator-name = \"iqn.qemu.test:my-initiator\"\n  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE\n  header-digest = \"CRC32C\"\n@end example\n\n\nHowto use a configuration file to set iSCSI configuration options:\n@example\ncat >iscsi.conf <<EOF\n[iscsi]\n  user = \"me\"\n  password = \"my password\"\n  initiator-name = \"iqn.qemu.test:my-initiator\"\n  header-digest = \"CRC32C\"\nEOF\n\nqemu-system-i386 -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \\\n    -readconfig iscsi.conf\n@end example\n\n\nHowto set up a simple iSCSI target on loopback and accessing it via QEMU:\n@example\nThis example shows how to set up an iSCSI target with one CDROM and one DISK\nusing the Linux STGT software target. This target is available on Red Hat based\nsystems as the package 'scsi-target-utils'.\n\ntgtd --iscsi portal=127.0.0.1:3260\ntgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.qemu.test\ntgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 \\\n    -b /IMAGES/disk.img --device-type=disk\ntgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 \\\n    -b /IMAGES/cd.iso --device-type=cd\ntgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL\n\nqemu-system-i386 -iscsi initiator-name=iqn.qemu.test:my-initiator \\\n    -boot d -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \\\n    -cdrom iscsi://127.0.0.1/iqn.qemu.test/2\n@end example\n\n@node disk_images_gluster\n@subsection GlusterFS disk images\n\nGlusterFS is a user space distributed file system.\n\nYou can boot from the GlusterFS disk image with the command:\n@example\nURI:\nqemu-system-x86_64 -drive file=gluster[+@var{type}]://[@var{host}[:@var{port}]]/@var{volume}/@var{path}\n                               [?socket=...][,file.debug=9][,file.logfile=...]\n\nJSON:\nqemu-system-x86_64 'json:@{\"driver\":\"qcow2\",\n                           \"file\":@{\"driver\":\"gluster\",\n                                    \"volume\":\"testvol\",\"path\":\"a.img\",\"debug\":9,\"logfile\":\"...\",\n                                    \"server\":[@{\"type\":\"tcp\",\"host\":\"...\",\"port\":\"...\"@},\n                                              @{\"type\":\"unix\",\"socket\":\"...\"@}]@}@}'\n@end example\n\n@var{gluster} is the protocol.\n\n@var{type} specifies the transport type used to connect to gluster\nmanagement daemon (glusterd). Valid transport types are\ntcp and unix. In the URI form, if a transport type isn't specified,\nthen tcp type is assumed.\n\n@var{host} specifies the server where the volume file specification for\nthe given volume resides. This can be either a hostname or an ipv4 address.\nIf transport type is unix, then @var{host} field should not be specified.\nInstead @var{socket} field needs to be populated with the path to unix domain\nsocket.\n\n@var{port} is the port number on which glusterd is listening. This is optional\nand if not specified, it defaults to port 24007. If the transport type is unix,\nthen @var{port} should not be specified.\n\n@var{volume} is the name of the gluster volume which contains the disk image.\n\n@var{path} is the path to the actual disk image that resides on gluster volume.\n\n@var{debug} is the logging level of the gluster protocol driver. Debug levels\nare 0-9, with 9 being the most verbose, and 0 representing no debugging output.\nThe default level is 4. The current logging levels defined in the gluster source\nare 0 - None, 1 - Emergency, 2 - Alert, 3 - Critical, 4 - Error, 5 - Warning,\n6 - Notice, 7 - Info, 8 - Debug, 9 - Trace\n\n@var{logfile} is a commandline option to mention log file path which helps in\nlogging to the specified file and also help in persisting the gfapi logs. The\ndefault is stderr.\n\n\n\n\nYou can create a GlusterFS disk image with the command:\n@example\nqemu-img create gluster://@var{host}/@var{volume}/@var{path} @var{size}\n@end example\n\nExamples\n@example\nqemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img\nqemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4/testvol/a.img\nqemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4:24007/testvol/dir/a.img\nqemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]/testvol/dir/a.img\nqemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]:24007/testvol/dir/a.img\nqemu-system-x86_64 -drive file=gluster+tcp://server.domain.com:24007/testvol/dir/a.img\nqemu-system-x86_64 -drive file=gluster+unix:///testvol/dir/a.img?socket=/tmp/glusterd.socket\nqemu-system-x86_64 -drive file=gluster+rdma://1.2.3.4:24007/testvol/a.img\nqemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img,file.debug=9,file.logfile=/var/log/qemu-gluster.log\nqemu-system-x86_64 'json:@{\"driver\":\"qcow2\",\n                           \"file\":@{\"driver\":\"gluster\",\n                                    \"volume\":\"testvol\",\"path\":\"a.img\",\n                                    \"debug\":9,\"logfile\":\"/var/log/qemu-gluster.log\",\n                                    \"server\":[@{\"type\":\"tcp\",\"host\":\"1.2.3.4\",\"port\":24007@},\n                                              @{\"type\":\"unix\",\"socket\":\"/var/run/glusterd.socket\"@}]@}@}'\nqemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,\n                                       file.debug=9,file.logfile=/var/log/qemu-gluster.log,\n                                       file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,\n                                       file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket\n@end example\n\n@node disk_images_ssh\n@subsection Secure Shell (ssh) disk images\n\nYou can access disk images located on a remote ssh server\nby using the ssh protocol:\n\n@example\nqemu-system-x86_64 -drive file=ssh://[@var{user}@@]@var{server}[:@var{port}]/@var{path}[?host_key_check=@var{host_key_check}]\n@end example\n\nAlternative syntax using properties:\n\n@example\nqemu-system-x86_64 -drive file.driver=ssh[,file.user=@var{user}],file.host=@var{server}[,file.port=@var{port}],file.path=@var{path}[,file.host_key_check=@var{host_key_check}]\n@end example\n\n@var{ssh} is the protocol.\n\n@var{user} is the remote user.  If not specified, then the local\nusername is tried.\n\n@var{server} specifies the remote ssh server.  Any ssh server can be\nused, but it must implement the sftp-server protocol.  Most Unix/Linux\nsystems should work without requiring any extra configuration.\n\n@var{port} is the port number on which sshd is listening.  By default\nthe standard ssh port (22) is used.\n\n@var{path} is the path to the disk image.\n\nThe optional @var{host_key_check} parameter controls how the remote\nhost's key is checked.  The default is @code{yes} which means to use\nthe local @file{.ssh/known_hosts} file.  Setting this to @code{no}\nturns off known-hosts checking.  Or you can check that the host key\nmatches a specific fingerprint:\n@code{host_key_check=md5:78:45:8e:14:57:4f:d5:45:83:0a:0e:f3:49:82:c9:c8}\n(@code{sha1:} can also be used as a prefix, but note that OpenSSH\ntools only use MD5 to print fingerprints).\n\nCurrently authentication must be done using ssh-agent.  Other\nauthentication methods may be supported in future.\n\nNote: Many ssh servers do not support an @code{fsync}-style operation.\nThe ssh driver cannot guarantee that disk flush requests are\nobeyed, and this causes a risk of disk corruption if the remote\nserver or network goes down during writes.  The driver will\nprint a warning when @code{fsync} is not supported:\n\nwarning: ssh server @code{ssh.example.com:22} does not support fsync\n\nWith sufficiently new versions of libssh2 and OpenSSH, @code{fsync} is\nsupported.\n\n@node pcsys_network\n@section Network emulation\n\nQEMU can simulate several network cards (PCI or ISA cards on the PC\ntarget) and can connect them to an arbitrary number of Virtual Local\nArea Networks (VLANs). Host TAP devices can be connected to any QEMU\nVLAN. VLAN can be connected between separate instances of QEMU to\nsimulate large networks. For simpler usage, a non privileged user mode\nnetwork stack can replace the TAP device to have a basic network\nconnection.\n\n@subsection VLANs\n\nQEMU simulates several VLANs. A VLAN can be symbolised as a virtual\nconnection between several network devices. These devices can be for\nexample QEMU virtual Ethernet cards or virtual Host ethernet devices\n(TAP devices).\n\n@subsection Using TAP network interfaces\n\nThis is the standard way to connect QEMU to a real network. QEMU adds\na virtual network device on your host (called @code{tapN}), and you\ncan then configure it as if it was a real ethernet card.\n\n@subsubsection Linux host\n\nAs an example, you can download the @file{linux-test-xxx.tar.gz}\narchive and copy the script @file{qemu-ifup} in @file{/etc} and\nconfigure properly @code{sudo} so that the command @code{ifconfig}\ncontained in @file{qemu-ifup} can be executed as root. You must verify\nthat your host kernel supports the TAP network interfaces: the\ndevice @file{/dev/net/tun} must be present.\n\nSee @ref{sec_invocation} to have examples of command lines using the\nTAP network interfaces.\n\n@subsubsection Windows host\n\nThere is a virtual ethernet driver for Windows 2000/XP systems, called\nTAP-Win32. But it is not included in standard QEMU for Windows,\nso you will need to get it separately. It is part of OpenVPN package,\nso download OpenVPN from : @url{http://openvpn.net/}.\n\n@subsection Using the user mode network stack\n\nBy using the option @option{-net user} (default configuration if no\n@option{-net} option is specified), QEMU uses a completely user mode\nnetwork stack (you don't need root privilege to use the virtual\nnetwork). The virtual network configuration is the following:\n\n@example\n\n         QEMU VLAN      <------>  Firewall/DHCP server <-----> Internet\n                           |          (10.0.2.2)\n                           |\n                           ---->  DNS server (10.0.2.3)\n                           |\n                           ---->  SMB server (10.0.2.4)\n@end example\n\nThe QEMU VM behaves as if it was behind a firewall which blocks all\nincoming connections. You can use a DHCP client to automatically\nconfigure the network in the QEMU VM. The DHCP server assign addresses\nto the hosts starting from 10.0.2.15.\n\nIn order to check that the user mode network is working, you can ping\nthe address 10.0.2.2 and verify that you got an address in the range\n10.0.2.x from the QEMU virtual DHCP server.\n\nNote that ICMP traffic in general does not work with user mode networking.\n@code{ping}, aka. ICMP echo, to the local router (10.0.2.2) shall work,\nhowever. If you're using QEMU on Linux >= 3.0, it can use unprivileged ICMP\nping sockets to allow @code{ping} to the Internet. The host admin has to set\nthe ping_group_range in order to grant access to those sockets. To allow ping\nfor GID 100 (usually users group):\n\n@example\necho 100 100 > /proc/sys/net/ipv4/ping_group_range\n@end example\n\nWhen using the built-in TFTP server, the router is also the TFTP\nserver.\n\nWhen using the @option{'-netdev user,hostfwd=...'} option, TCP or UDP\nconnections can be redirected from the host to the guest. It allows for\nexample to redirect X11, telnet or SSH connections.\n\n@subsection Connecting VLANs between QEMU instances\n\nUsing the @option{-net socket} option, it is possible to make VLANs\nthat span several QEMU instances. See @ref{sec_invocation} to have a\nbasic example.\n\n@node pcsys_other_devs\n@section Other Devices\n\n@subsection Inter-VM Shared Memory device\n\nOn Linux hosts, a shared memory device is available.  The basic syntax\nis:\n\n@example\nqemu-system-x86_64 -device ivshmem-plain,memdev=@var{hostmem}\n@end example\n\nwhere @var{hostmem} names a host memory backend.  For a POSIX shared\nmemory backend, use something like\n\n@example\n-object memory-backend-file,size=1M,share,mem-path=/dev/shm/ivshmem,id=@var{hostmem}\n@end example\n\nIf desired, interrupts can be sent between guest VMs accessing the same shared\nmemory region.  Interrupt support requires using a shared memory server and\nusing a chardev socket to connect to it.  The code for the shared memory server\nis qemu.git/contrib/ivshmem-server.  An example syntax when using the shared\nmemory server is:\n\n@example\n# First start the ivshmem server once and for all\nivshmem-server -p @var{pidfile} -S @var{path} -m @var{shm-name} -l @var{shm-size} -n @var{vectors}\n\n# Then start your qemu instances with matching arguments\nqemu-system-x86_64 -device ivshmem-doorbell,vectors=@var{vectors},chardev=@var{id}\n                 -chardev socket,path=@var{path},id=@var{id}\n@end example\n\nWhen using the server, the guest will be assigned a VM ID (>=0) that allows guests\nusing the same server to communicate via interrupts.  Guests can read their\nVM ID from a device register (see ivshmem-spec.txt).\n\n@subsubsection Migration with ivshmem\n\nWith device property @option{master=on}, the guest will copy the shared\nmemory on migration to the destination host.  With @option{master=off},\nthe guest will not be able to migrate with the device attached.  In the\nlatter case, the device should be detached and then reattached after\nmigration using the PCI hotplug support.\n\nAt most one of the devices sharing the same memory can be master.  The\nmaster must complete migration before you plug back the other devices.\n\n@subsubsection ivshmem and hugepages\n\nInstead of specifying the <shm size> using POSIX shm, you may specify\na memory backend that has hugepage support:\n\n@example\nqemu-system-x86_64 -object memory-backend-file,size=1G,mem-path=/dev/hugepages/my-shmem-file,share,id=mb1\n                 -device ivshmem-plain,memdev=mb1\n@end example\n\nivshmem-server also supports hugepages mount points with the\n@option{-m} memory path argument.\n\n@node direct_linux_boot\n@section Direct Linux Boot\n\nThis section explains how to launch a Linux kernel inside QEMU without\nhaving to make a full bootable image. It is very useful for fast Linux\nkernel testing.\n\nThe syntax is:\n@example\nqemu-system-i386 -kernel arch/i386/boot/bzImage -hda root-2.4.20.img -append \"root=/dev/hda\"\n@end example\n\nUse @option{-kernel} to provide the Linux kernel image and\n@option{-append} to give the kernel command line arguments. The\n@option{-initrd} option can be used to provide an INITRD image.\n\nWhen using the direct Linux boot, a disk image for the first hard disk\n@file{hda} is required because its boot sector is used to launch the\nLinux kernel.\n\nIf you do not need graphical output, you can disable it and redirect\nthe virtual serial port and the QEMU monitor to the console with the\n@option{-nographic} option. The typical command line is:\n@example\nqemu-system-i386 -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \\\n                 -append \"root=/dev/hda console=ttyS0\" -nographic\n@end example\n\nUse @key{Ctrl-a c} to switch between the serial console and the\nmonitor (@pxref{pcsys_keys}).\n\n@node pcsys_usb\n@section USB emulation\n\nQEMU emulates a PCI UHCI USB controller. You can virtually plug\nvirtual USB devices or real host USB devices (experimental, works only\non Linux hosts).  QEMU will automatically create and connect virtual USB hubs\nas necessary to connect multiple USB devices.\n\n@menu\n* usb_devices::\n* host_usb_devices::\n@end menu\n@node usb_devices\n@subsection Connecting USB devices\n\nUSB devices can be connected with the @option{-usbdevice} commandline option\nor the @code{usb_add} monitor command.  Available devices are:\n\n@table @code\n@item mouse\nVirtual Mouse.  This will override the PS/2 mouse emulation when activated.\n@item tablet\nPointer device that uses absolute coordinates (like a touchscreen).\nThis means QEMU is able to report the mouse position without having\nto grab the mouse.  Also overrides the PS/2 mouse emulation when activated.\n@item disk:@var{file}\nMass storage device based on @var{file} (@pxref{disk_images})\n@item host:@var{bus.addr}\nPass through the host device identified by @var{bus.addr}\n(Linux only)\n@item host:@var{vendor_id:product_id}\nPass through the host device identified by @var{vendor_id:product_id}\n(Linux only)\n@item wacom-tablet\nVirtual Wacom PenPartner tablet.  This device is similar to the @code{tablet}\nabove but it can be used with the tslib library because in addition to touch\ncoordinates it reports touch pressure.\n@item keyboard\nStandard USB keyboard.  Will override the PS/2 keyboard (if present).\n@item serial:[vendorid=@var{vendor_id}][,product_id=@var{product_id}]:@var{dev}\nSerial converter. This emulates an FTDI FT232BM chip connected to host character\ndevice @var{dev}. The available character devices are the same as for the\n@code{-serial} option. The @code{vendorid} and @code{productid} options can be\nused to override the default 0403:6001. For instance,\n@example\nusb_add serial:productid=FA00:tcp:192.168.0.2:4444\n@end example\nwill connect to tcp port 4444 of ip 192.168.0.2, and plug that to the virtual\nserial converter, faking a Matrix Orbital LCD Display (USB ID 0403:FA00).\n@item braille\nBraille device.  This will use BrlAPI to display the braille output on a real\nor fake device.\n@item net:@var{options}\nNetwork adapter that supports CDC ethernet and RNDIS protocols.  @var{options}\nspecifies NIC options as with @code{-net nic,}@var{options} (see description).\nFor instance, user-mode networking can be used with\n@example\nqemu-system-i386 [...OPTIONS...] -net user,vlan=0 -usbdevice net:vlan=0\n@end example\nCurrently this cannot be used in machines that support PCI NICs.\n@item bt[:@var{hci-type}]\nBluetooth dongle whose type is specified in the same format as with\nthe @option{-bt hci} option, @pxref{bt-hcis,,allowed HCI types}.  If\nno type is given, the HCI logic corresponds to @code{-bt hci,vlan=0}.\nThis USB device implements the USB Transport Layer of HCI.  Example\nusage:\n@example\n@command{qemu-system-i386} [...@var{OPTIONS}...] @option{-usbdevice} bt:hci,vlan=3 @option{-bt} device:keyboard,vlan=3\n@end example\n@end table\n\n@node host_usb_devices\n@subsection Using host USB devices on a Linux host\n\nWARNING: this is an experimental feature. QEMU will slow down when\nusing it. USB devices requiring real time streaming (i.e. USB Video\nCameras) are not supported yet.\n\n@enumerate\n@item If you use an early Linux 2.4 kernel, verify that no Linux driver\nis actually using the USB device. A simple way to do that is simply to\ndisable the corresponding kernel module by renaming it from @file{mydriver.o}\nto @file{mydriver.o.disabled}.\n\n@item Verify that @file{/proc/bus/usb} is working (most Linux distributions should enable it by default). You should see something like that:\n@example\nls /proc/bus/usb\n001  devices  drivers\n@end example\n\n@item Since only root can access to the USB devices directly, you can either launch QEMU as root or change the permissions of the USB devices you want to use. For testing, the following suffices:\n@example\nchown -R myuid /proc/bus/usb\n@end example\n\n@item Launch QEMU and do in the monitor:\n@example\ninfo usbhost\n  Device 1.2, speed 480 Mb/s\n    Class 00: USB device 1234:5678, USB DISK\n@end example\nYou should see the list of the devices you can use (Never try to use\nhubs, it won't work).\n\n@item Add the device in QEMU by using:\n@example\nusb_add host:1234:5678\n@end example\n\nNormally the guest OS should report that a new USB device is\nplugged. You can use the option @option{-usbdevice} to do the same.\n\n@item Now you can try to use the host USB device in QEMU.\n\n@end enumerate\n\nWhen relaunching QEMU, you may have to unplug and plug again the USB\ndevice to make it work again (this is a bug).\n\n@node vnc_security\n@section VNC security\n\nThe VNC server capability provides access to the graphical console\nof the guest VM across the network. This has a number of security\nconsiderations depending on the deployment scenarios.\n\n@menu\n* vnc_sec_none::\n* vnc_sec_password::\n* vnc_sec_certificate::\n* vnc_sec_certificate_verify::\n* vnc_sec_certificate_pw::\n* vnc_sec_sasl::\n* vnc_sec_certificate_sasl::\n* vnc_generate_cert::\n* vnc_setup_sasl::\n@end menu\n@node vnc_sec_none\n@subsection Without passwords\n\nThe simplest VNC server setup does not include any form of authentication.\nFor this setup it is recommended to restrict it to listen on a UNIX domain\nsocket only. For example\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc unix:/home/joebloggs/.qemu-myvm-vnc\n@end example\n\nThis ensures that only users on local box with read/write access to that\npath can access the VNC server. To securely access the VNC server from a\nremote machine, a combination of netcat+ssh can be used to provide a secure\ntunnel.\n\n@node vnc_sec_password\n@subsection With passwords\n\nThe VNC protocol has limited support for password based authentication. Since\nthe protocol limits passwords to 8 characters it should not be considered\nto provide high security. The password can be fairly easily brute-forced by\na client making repeat connections. For this reason, a VNC server using password\nauthentication should be restricted to only listen on the loopback interface\nor UNIX domain sockets. Password authentication is not supported when operating\nin FIPS 140-2 compliance mode as it requires the use of the DES cipher. Password\nauthentication is requested with the @code{password} option, and then once QEMU\nis running the password is set with the monitor. Until the monitor is used to\nset the password all clients will be rejected.\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,password -monitor stdio\n(qemu) change vnc password\nPassword: ********\n(qemu)\n@end example\n\n@node vnc_sec_certificate\n@subsection With x509 certificates\n\nThe QEMU VNC server also implements the VeNCrypt extension allowing use of\nTLS for encryption of the session, and x509 certificates for authentication.\nThe use of x509 certificates is strongly recommended, because TLS on its\nown is susceptible to man-in-the-middle attacks. Basic x509 certificate\nsupport provides a secure session, but no authentication. This allows any\nclient to connect, and provides an encrypted session.\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509=/etc/pki/qemu -monitor stdio\n@end example\n\nIn the above example @code{/etc/pki/qemu} should contain at least three files,\n@code{ca-cert.pem}, @code{server-cert.pem} and @code{server-key.pem}. Unprivileged\nusers will want to use a private directory, for example @code{$HOME/.pki/qemu}.\nNB the @code{server-key.pem} file should be protected with file mode 0600 to\nonly be readable by the user owning it.\n\n@node vnc_sec_certificate_verify\n@subsection With x509 certificates and client verification\n\nCertificates can also provide a means to authenticate the client connecting.\nThe server will request that the client provide a certificate, which it will\nthen validate against the CA certificate. This is a good choice if deploying\nin an environment with a private internal certificate authority.\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509verify=/etc/pki/qemu -monitor stdio\n@end example\n\n\n@node vnc_sec_certificate_pw\n@subsection With x509 certificates, client verification and passwords\n\nFinally, the previous method can be combined with VNC password authentication\nto provide two layers of authentication for clients.\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,password,tls,x509verify=/etc/pki/qemu -monitor stdio\n(qemu) change vnc password\nPassword: ********\n(qemu)\n@end example\n\n\n@node vnc_sec_sasl\n@subsection With SASL authentication\n\nThe SASL authentication method is a VNC extension, that provides an\neasily extendable, pluggable authentication method. This allows for\nintegration with a wide range of authentication mechanisms, such as\nPAM, GSSAPI/Kerberos, LDAP, SQL databases, one-time keys and more.\nThe strength of the authentication depends on the exact mechanism\nconfigured. If the chosen mechanism also provides a SSF layer, then\nit will encrypt the datastream as well.\n\nRefer to the later docs on how to choose the exact SASL mechanism\nused for authentication, but assuming use of one supporting SSF,\nthen QEMU can be launched with:\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,sasl -monitor stdio\n@end example\n\n@node vnc_sec_certificate_sasl\n@subsection With x509 certificates and SASL authentication\n\nIf the desired SASL authentication mechanism does not supported\nSSF layers, then it is strongly advised to run it in combination\nwith TLS and x509 certificates. This provides securely encrypted\ndata stream, avoiding risk of compromising of the security\ncredentials. This can be enabled, by combining the 'sasl' option\nwith the aforementioned TLS + x509 options:\n\n@example\nqemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509,sasl -monitor stdio\n@end example\n\n\n@node vnc_generate_cert\n@subsection Generating certificates for VNC\n\nThe GNU TLS packages provides a command called @code{certtool} which can\nbe used to generate certificates and keys in PEM format. At a minimum it\nis necessary to setup a certificate authority, and issue certificates to\neach server. If using certificates for authentication, then each client\nwill also need to be issued a certificate. The recommendation is for the\nserver to keep its certificates in either @code{/etc/pki/qemu} or for\nunprivileged users in @code{$HOME/.pki/qemu}.\n\n@menu\n* vnc_generate_ca::\n* vnc_generate_server::\n* vnc_generate_client::\n@end menu\n@node vnc_generate_ca\n@subsubsection Setup the Certificate Authority\n\nThis step only needs to be performed once per organization / organizational\nunit. First the CA needs a private key. This key must be kept VERY secret\nand secure. If this key is compromised the entire trust chain of the certificates\nissued with it is lost.\n\n@example\n# certtool --generate-privkey > ca-key.pem\n@end example\n\nA CA needs to have a public certificate. For simplicity it can be a self-signed\ncertificate, or one issue by a commercial certificate issuing authority. To\ngenerate a self-signed certificate requires one core piece of information, the\nname of the organization.\n\n@example\n# cat > ca.info <<EOF\ncn = Name of your organization\nca\ncert_signing_key\nEOF\n# certtool --generate-self-signed \\\n           --load-privkey ca-key.pem\n           --template ca.info \\\n           --outfile ca-cert.pem\n@end example\n\nThe @code{ca-cert.pem} file should be copied to all servers and clients wishing to utilize\nTLS support in the VNC server. The @code{ca-key.pem} must not be disclosed/copied at all.\n\n@node vnc_generate_server\n@subsubsection Issuing server certificates\n\nEach server (or host) needs to be issued with a key and certificate. When connecting\nthe certificate is sent to the client which validates it against the CA certificate.\nThe core piece of information for a server certificate is the hostname. This should\nbe the fully qualified hostname that the client will connect with, since the client\nwill typically also verify the hostname in the certificate. On the host holding the\nsecure CA private key:\n\n@example\n# cat > server.info <<EOF\norganization = Name  of your organization\ncn = server.foo.example.com\ntls_www_server\nencryption_key\nsigning_key\nEOF\n# certtool --generate-privkey > server-key.pem\n# certtool --generate-certificate \\\n           --load-ca-certificate ca-cert.pem \\\n           --load-ca-privkey ca-key.pem \\\n           --load-privkey server-key.pem \\\n           --template server.info \\\n           --outfile server-cert.pem\n@end example\n\nThe @code{server-key.pem} and @code{server-cert.pem} files should now be securely copied\nto the server for which they were generated. The @code{server-key.pem} is security\nsensitive and should be kept protected with file mode 0600 to prevent disclosure.\n\n@node vnc_generate_client\n@subsubsection Issuing client certificates\n\nIf the QEMU VNC server is to use the @code{x509verify} option to validate client\ncertificates as its authentication mechanism, each client also needs to be issued\na certificate. The client certificate contains enough metadata to uniquely identify\nthe client, typically organization, state, city, building, etc. On the host holding\nthe secure CA private key:\n\n@example\n# cat > client.info <<EOF\ncountry = GB\nstate = London\nlocality = London\norganization = Name of your organization\ncn = client.foo.example.com\ntls_www_client\nencryption_key\nsigning_key\nEOF\n# certtool --generate-privkey > client-key.pem\n# certtool --generate-certificate \\\n           --load-ca-certificate ca-cert.pem \\\n           --load-ca-privkey ca-key.pem \\\n           --load-privkey client-key.pem \\\n           --template client.info \\\n           --outfile client-cert.pem\n@end example\n\nThe @code{client-key.pem} and @code{client-cert.pem} files should now be securely\ncopied to the client for which they were generated.\n\n\n@node vnc_setup_sasl\n\n@subsection Configuring SASL mechanisms\n\nThe following documentation assumes use of the Cyrus SASL implementation on a\nLinux host, but the principals should apply to any other SASL impl. When SASL\nis enabled, the mechanism configuration will be loaded from system default\nSASL service config /etc/sasl2/qemu.conf. If running QEMU as an\nunprivileged user, an environment variable SASL_CONF_PATH can be used\nto make it search alternate locations for the service config.\n\nThe default configuration might contain\n\n@example\nmech_list: digest-md5\nsasldb_path: /etc/qemu/passwd.db\n@end example\n\nThis says to use the 'Digest MD5' mechanism, which is similar to the HTTP\nDigest-MD5 mechanism. The list of valid usernames & passwords is maintained\nin the /etc/qemu/passwd.db file, and can be updated using the saslpasswd2\ncommand. While this mechanism is easy to configure and use, it is not\nconsidered secure by modern standards, so only suitable for developers /\nad-hoc testing.\n\nA more serious deployment might use Kerberos, which is done with the 'gssapi'\nmechanism\n\n@example\nmech_list: gssapi\nkeytab: /etc/qemu/krb5.tab\n@end example\n\nFor this to work the administrator of your KDC must generate a Kerberos\nprincipal for the server, with a name of  'qemu/somehost.example.com@@EXAMPLE.COM'\nreplacing 'somehost.example.com' with the fully qualified host name of the\nmachine running QEMU, and 'EXAMPLE.COM' with the Kerberos Realm.\n\nOther configurations will be left as an exercise for the reader. It should\nbe noted that only Digest-MD5 and GSSAPI provides a SSF layer for data\nencryption. For all other mechanisms, VNC should always be configured to\nuse TLS and x509 certificates to protect security credentials from snooping.\n\n@node gdb_usage\n@section GDB usage\n\nQEMU has a primitive support to work with gdb, so that you can do\n'Ctrl-C' while the virtual machine is running and inspect its state.\n\nIn order to use gdb, launch QEMU with the '-s' option. It will wait for a\ngdb connection:\n@example\nqemu-system-i386 -s -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \\\n                    -append \"root=/dev/hda\"\nConnected to host network interface: tun0\nWaiting gdb connection on port 1234\n@end example\n\nThen launch gdb on the 'vmlinux' executable:\n@example\n> gdb vmlinux\n@end example\n\nIn gdb, connect to QEMU:\n@example\n(gdb) target remote localhost:1234\n@end example\n\nThen you can use gdb normally. For example, type 'c' to launch the kernel:\n@example\n(gdb) c\n@end example\n\nHere are some useful tips in order to use gdb on system code:\n\n@enumerate\n@item\nUse @code{info reg} to display all the CPU registers.\n@item\nUse @code{x/10i $eip} to display the code at the PC position.\n@item\nUse @code{set architecture i8086} to dump 16 bit code. Then use\n@code{x/10i $cs*16+$eip} to dump the code at the PC position.\n@end enumerate\n\nAdvanced debugging options:\n\nThe default single stepping behavior is step with the IRQs and timer service routines off.  It is set this way because when gdb executes a single step it expects to advance beyond the current instruction.  With the IRQs and timer service routines on, a single step might jump into the one of the interrupt or exception vectors instead of executing the current instruction. This means you may hit the same breakpoint a number of times before executing the instruction gdb wants to have executed.  Because there are rare circumstances where you want to single step into an interrupt vector the behavior can be controlled from GDB.  There are three commands you can query and set the single step behavior:\n@table @code\n@item maintenance packet qqemu.sstepbits\n\nThis will display the MASK bits used to control the single stepping IE:\n@example\n(gdb) maintenance packet qqemu.sstepbits\nsending: \"qqemu.sstepbits\"\nreceived: \"ENABLE=1,NOIRQ=2,NOTIMER=4\"\n@end example\n@item maintenance packet qqemu.sstep\n\nThis will display the current value of the mask used when single stepping IE:\n@example\n(gdb) maintenance packet qqemu.sstep\nsending: \"qqemu.sstep\"\nreceived: \"0x7\"\n@end example\n@item maintenance packet Qqemu.sstep=HEX_VALUE\n\nThis will change the single step mask, so if wanted to enable IRQs on the single step, but not timers, you would use:\n@example\n(gdb) maintenance packet Qqemu.sstep=0x5\nsending: \"qemu.sstep=0x5\"\nreceived: \"OK\"\n@end example\n@end table\n\n@node pcsys_os_specific\n@section Target OS specific information\n\n@subsection Linux\n\nTo have access to SVGA graphic modes under X11, use the @code{vesa} or\nthe @code{cirrus} X11 driver. For optimal performances, use 16 bit\ncolor depth in the guest and the host OS.\n\nWhen using a 2.6 guest Linux kernel, you should add the option\n@code{clock=pit} on the kernel command line because the 2.6 Linux\nkernels make very strict real time clock checks by default that QEMU\ncannot simulate exactly.\n\nWhen using a 2.6 guest Linux kernel, verify that the 4G/4G patch is\nnot activated because QEMU is slower with this patch. The QEMU\nAccelerator Module is also much slower in this case. Earlier Fedora\nCore 3 Linux kernel (< 2.6.9-1.724_FC3) were known to incorporate this\npatch by default. Newer kernels don't have it.\n\n@subsection Windows\n\nIf you have a slow host, using Windows 95 is better as it gives the\nbest speed. Windows 2000 is also a good choice.\n\n@subsubsection SVGA graphic modes support\n\nQEMU emulates a Cirrus Logic GD5446 Video\ncard. All Windows versions starting from Windows 95 should recognize\nand use this graphic card. For optimal performances, use 16 bit color\ndepth in the guest and the host OS.\n\nIf you are using Windows XP as guest OS and if you want to use high\nresolution modes which the Cirrus Logic BIOS does not support (i.e. >=\n1280x1024x16), then you should use the VESA VBE virtual graphic card\n(option @option{-std-vga}).\n\n@subsubsection CPU usage reduction\n\nWindows 9x does not correctly use the CPU HLT\ninstruction. The result is that it takes host CPU cycles even when\nidle. You can install the utility from\n@url{http://www.user.cityline.ru/~maxamn/amnhltm.zip} to solve this\nproblem. Note that no such tool is needed for NT, 2000 or XP.\n\n@subsubsection Windows 2000 disk full problem\n\nWindows 2000 has a bug which gives a disk full problem during its\ninstallation. When installing it, use the @option{-win2k-hack} QEMU\noption to enable a specific workaround. After Windows 2000 is\ninstalled, you no longer need this option (this option slows down the\nIDE transfers).\n\n@subsubsection Windows 2000 shutdown\n\nWindows 2000 cannot automatically shutdown in QEMU although Windows 98\ncan. It comes from the fact that Windows 2000 does not automatically\nuse the APM driver provided by the BIOS.\n\nIn order to correct that, do the following (thanks to Struan\nBartlett): go to the Control Panel => Add/Remove Hardware & Next =>\nAdd/Troubleshoot a device => Add a new device & Next => No, select the\nhardware from a list & Next => NT Apm/Legacy Support & Next => Next\n(again) a few times. Now the driver is installed and Windows 2000 now\ncorrectly instructs QEMU to shutdown at the appropriate moment.\n\n@subsubsection Share a directory between Unix and Windows\n\nSee @ref{sec_invocation} about the help of the option\n@option{'-netdev user,smb=...'}.\n\n@subsubsection Windows XP security problem\n\nSome releases of Windows XP install correctly but give a security\nerror when booting:\n@example\nA problem is preventing Windows from accurately checking the\nlicense for this computer. Error code: 0x800703e6.\n@end example\n\nThe workaround is to install a service pack for XP after a boot in safe\nmode. Then reboot, and the problem should go away. Since there is no\nnetwork while in safe mode, its recommended to download the full\ninstallation of SP1 or SP2 and transfer that via an ISO or using the\nvvfat block device (\"-hdb fat:directory_which_holds_the_SP\").\n\n@subsection MS-DOS and FreeDOS\n\n@subsubsection CPU usage reduction\n\nDOS does not correctly use the CPU HLT instruction. The result is that\nit takes host CPU cycles even when idle. You can install the utility\nfrom @url{http://www.vmware.com/software/dosidle210.zip} to solve this\nproblem.\n\n@node QEMU System emulator for non PC targets\n@chapter QEMU System emulator for non PC targets\n\nQEMU is a generic emulator and it emulates many non PC\nmachines. Most of the options are similar to the PC emulator. The\ndifferences are mentioned in the following sections.\n\n@menu\n* PowerPC System emulator::\n* Sparc32 System emulator::\n* Sparc64 System emulator::\n* MIPS System emulator::\n* ARM System emulator::\n* ColdFire System emulator::\n* Cris System emulator::\n* Microblaze System emulator::\n* SH4 System emulator::\n* Xtensa System emulator::\n@end menu\n\n@node PowerPC System emulator\n@section PowerPC System emulator\n@cindex system emulation (PowerPC)\n\nUse the executable @file{qemu-system-ppc} to simulate a complete PREP\nor PowerMac PowerPC system.\n\nQEMU emulates the following PowerMac peripherals:\n\n@itemize @minus\n@item\nUniNorth or Grackle PCI Bridge\n@item\nPCI VGA compatible card with VESA Bochs Extensions\n@item\n2 PMAC IDE interfaces with hard disk and CD-ROM support\n@item\nNE2000 PCI adapters\n@item\nNon Volatile RAM\n@item\nVIA-CUDA with ADB keyboard and mouse.\n@end itemize\n\nQEMU emulates the following PREP peripherals:\n\n@itemize @minus\n@item\nPCI Bridge\n@item\nPCI VGA compatible card with VESA Bochs Extensions\n@item\n2 IDE interfaces with hard disk and CD-ROM support\n@item\nFloppy disk\n@item\nNE2000 network adapters\n@item\nSerial port\n@item\nPREP Non Volatile RAM\n@item\nPC compatible keyboard and mouse.\n@end itemize\n\nQEMU uses the Open Hack'Ware Open Firmware Compatible BIOS available at\n@url{http://perso.magic.fr/l_indien/OpenHackWare/index.htm}.\n\nSince version 0.9.1, QEMU uses OpenBIOS @url{http://www.openbios.org/}\nfor the g3beige and mac99 PowerMac machines. OpenBIOS is a free (GPL\nv2) portable firmware implementation. The goal is to implement a 100%\nIEEE 1275-1994 (referred to as Open Firmware) compliant firmware.\n\n@c man begin OPTIONS\n\nThe following options are specific to the PowerPC emulation:\n\n@table @option\n\n@item -g @var{W}x@var{H}[x@var{DEPTH}]\n\nSet the initial VGA graphic mode. The default is 800x600x32.\n\n@item -prom-env @var{string}\n\nSet OpenBIOS variables in NVRAM, for example:\n\n@example\nqemu-system-ppc -prom-env 'auto-boot?=false' \\\n -prom-env 'boot-device=hd:2,\\yaboot' \\\n -prom-env 'boot-args=conf=hd:2,\\yaboot.conf'\n@end example\n\nThese variables are not used by Open Hack'Ware.\n\n@end table\n\n@c man end\n\n\nMore information is available at\n@url{http://perso.magic.fr/l_indien/qemu-ppc/}.\n\n@node Sparc32 System emulator\n@section Sparc32 System emulator\n@cindex system emulation (Sparc32)\n\nUse the executable @file{qemu-system-sparc} to simulate the following\nSun4m architecture machines:\n@itemize @minus\n@item\nSPARCstation 4\n@item\nSPARCstation 5\n@item\nSPARCstation 10\n@item\nSPARCstation 20\n@item\nSPARCserver 600MP\n@item\nSPARCstation LX\n@item\nSPARCstation Voyager\n@item\nSPARCclassic\n@item\nSPARCbook\n@end itemize\n\nThe emulation is somewhat complete. SMP up to 16 CPUs is supported,\nbut Linux limits the number of usable CPUs to 4.\n\nQEMU emulates the following sun4m peripherals:\n\n@itemize @minus\n@item\nIOMMU\n@item\nTCX or cgthree Frame buffer\n@item\nLance (Am7990) Ethernet\n@item\nNon Volatile RAM M48T02/M48T08\n@item\nSlave I/O: timers, interrupt controllers, Zilog serial ports, keyboard\nand power/reset logic\n@item\nESP SCSI controller with hard disk and CD-ROM support\n@item\nFloppy drive (not on SS-600MP)\n@item\nCS4231 sound device (only on SS-5, not working yet)\n@end itemize\n\nThe number of peripherals is fixed in the architecture.  Maximum\nmemory size depends on the machine type, for SS-5 it is 256MB and for\nothers 2047MB.\n\nSince version 0.8.2, QEMU uses OpenBIOS\n@url{http://www.openbios.org/}. OpenBIOS is a free (GPL v2) portable\nfirmware implementation. The goal is to implement a 100% IEEE\n1275-1994 (referred to as Open Firmware) compliant firmware.\n\nA sample Linux 2.6 series kernel and ram disk image are available on\nthe QEMU web site. There are still issues with NetBSD and OpenBSD, but\nmost kernel versions work. Please note that currently older Solaris kernels\ndon't work probably due to interface issues between OpenBIOS and\nSolaris.\n\n@c man begin OPTIONS\n\nThe following options are specific to the Sparc32 emulation:\n\n@table @option\n\n@item -g @var{W}x@var{H}x[x@var{DEPTH}]\n\nSet the initial graphics mode. For TCX, the default is 1024x768x8 with the\noption of 1024x768x24. For cgthree, the default is 1024x768x8 with the option\nof 1152x900x8 for people who wish to use OBP.\n\n@item -prom-env @var{string}\n\nSet OpenBIOS variables in NVRAM, for example:\n\n@example\nqemu-system-sparc -prom-env 'auto-boot?=false' \\\n -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'\n@end example\n\n@item -M [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic] [|SPARCbook]\n\nSet the emulated machine type. Default is SS-5.\n\n@end table\n\n@c man end\n\n@node Sparc64 System emulator\n@section Sparc64 System emulator\n@cindex system emulation (Sparc64)\n\nUse the executable @file{qemu-system-sparc64} to simulate a Sun4u\n(UltraSPARC PC-like machine), Sun4v (T1 PC-like machine), or generic\nNiagara (T1) machine. The Sun4u emulator is mostly complete, being\nable to run Linux, NetBSD and OpenBSD in headless (-nographic) mode. The\nSun4v emulator is still a work in progress.\n\nThe Niagara T1 emulator makes use of firmware and OS binaries supplied in the S10image/ directory\nof the OpenSPARC T1 project @url{http://download.oracle.com/technetwork/systems/opensparc/OpenSPARCT1_Arch.1.5.tar.bz2}\nand is able to boot the disk.s10hw2 Solaris image.\n@example\nqemu-system-sparc64 -M niagara -L /path-to/S10image/ \\\n                    -nographic -m 256 \\\n                    -drive if=pflash,readonly=on,file=/S10image/disk.s10hw2\n@end example\n\n\nQEMU emulates the following peripherals:\n\n@itemize @minus\n@item\nUltraSparc IIi APB PCI Bridge\n@item\nPCI VGA compatible card with VESA Bochs Extensions\n@item\nPS/2 mouse and keyboard\n@item\nNon Volatile RAM M48T59\n@item\nPC-compatible serial ports\n@item\n2 PCI IDE interfaces with hard disk and CD-ROM support\n@item\nFloppy disk\n@end itemize\n\n@c man begin OPTIONS\n\nThe following options are specific to the Sparc64 emulation:\n\n@table @option\n\n@item -prom-env @var{string}\n\nSet OpenBIOS variables in NVRAM, for example:\n\n@example\nqemu-system-sparc64 -prom-env 'auto-boot?=false'\n@end example\n\n@item -M [sun4u|sun4v|niagara]\n\nSet the emulated machine type. The default is sun4u.\n\n@end table\n\n@c man end\n\n@node MIPS System emulator\n@section MIPS System emulator\n@cindex system emulation (MIPS)\n\nFour executables cover simulation of 32 and 64-bit MIPS systems in\nboth endian options, @file{qemu-system-mips}, @file{qemu-system-mipsel}\n@file{qemu-system-mips64} and @file{qemu-system-mips64el}.\nFive different machine types are emulated:\n\n@itemize @minus\n@item\nA generic ISA PC-like machine \"mips\"\n@item\nThe MIPS Malta prototype board \"malta\"\n@item\nAn ACER Pica \"pica61\". This machine needs the 64-bit emulator.\n@item\nMIPS emulator pseudo board \"mipssim\"\n@item\nA MIPS Magnum R4000 machine \"magnum\". This machine needs the 64-bit emulator.\n@end itemize\n\nThe generic emulation is supported by Debian 'Etch' and is able to\ninstall Debian into a virtual disk image. The following devices are\nemulated:\n\n@itemize @minus\n@item\nA range of MIPS CPUs, default is the 24Kf\n@item\nPC style serial port\n@item\nPC style IDE disk\n@item\nNE2000 network card\n@end itemize\n\nThe Malta emulation supports the following devices:\n\n@itemize @minus\n@item\nCore board with MIPS 24Kf CPU and Galileo system controller\n@item\nPIIX4 PCI/USB/SMbus controller\n@item\nThe Multi-I/O chip's serial device\n@item\nPCI network cards (PCnet32 and others)\n@item\nMalta FPGA serial device\n@item\nCirrus (default) or any other PCI VGA graphics card\n@end itemize\n\nThe ACER Pica emulation supports:\n\n@itemize @minus\n@item\nMIPS R4000 CPU\n@item\nPC-style IRQ and DMA controllers\n@item\nPC Keyboard\n@item\nIDE controller\n@end itemize\n\nThe mipssim pseudo board emulation provides an environment similar\nto what the proprietary MIPS emulator uses for running Linux.\nIt supports:\n\n@itemize @minus\n@item\nA range of MIPS CPUs, default is the 24Kf\n@item\nPC style serial port\n@item\nMIPSnet network emulation\n@end itemize\n\nThe MIPS Magnum R4000 emulation supports:\n\n@itemize @minus\n@item\nMIPS R4000 CPU\n@item\nPC-style IRQ controller\n@item\nPC Keyboard\n@item\nSCSI controller\n@item\nG364 framebuffer\n@end itemize\n\n\n@node ARM System emulator\n@section ARM System emulator\n@cindex system emulation (ARM)\n\nUse the executable @file{qemu-system-arm} to simulate a ARM\nmachine. The ARM Integrator/CP board is emulated with the following\ndevices:\n\n@itemize @minus\n@item\nARM926E, ARM1026E, ARM946E, ARM1136 or Cortex-A8 CPU\n@item\nTwo PL011 UARTs\n@item\nSMC 91c111 Ethernet adapter\n@item\nPL110 LCD controller\n@item\nPL050 KMI with PS/2 keyboard and mouse.\n@item\nPL181 MultiMedia Card Interface with SD card.\n@end itemize\n\nThe ARM Versatile baseboard is emulated with the following devices:\n\n@itemize @minus\n@item\nARM926E, ARM1136 or Cortex-A8 CPU\n@item\nPL190 Vectored Interrupt Controller\n@item\nFour PL011 UARTs\n@item\nSMC 91c111 Ethernet adapter\n@item\nPL110 LCD controller\n@item\nPL050 KMI with PS/2 keyboard and mouse.\n@item\nPCI host bridge.  Note the emulated PCI bridge only provides access to\nPCI memory space.  It does not provide access to PCI IO space.\nThis means some devices (eg. ne2k_pci NIC) are not usable, and others\n(eg. rtl8139 NIC) are only usable when the guest drivers use the memory\nmapped control registers.\n@item\nPCI OHCI USB controller.\n@item\nLSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices.\n@item\nPL181 MultiMedia Card Interface with SD card.\n@end itemize\n\nSeveral variants of the ARM RealView baseboard are emulated,\nincluding the EB, PB-A8 and PBX-A9.  Due to interactions with the\nbootloader, only certain Linux kernel configurations work out\nof the box on these boards.\n\nKernels for the PB-A8 board should have CONFIG_REALVIEW_HIGH_PHYS_OFFSET\nenabled in the kernel, and expect 512M RAM.  Kernels for The PBX-A9 board\nshould have CONFIG_SPARSEMEM enabled, CONFIG_REALVIEW_HIGH_PHYS_OFFSET\ndisabled and expect 1024M RAM.\n\nThe following devices are emulated:\n\n@itemize @minus\n@item\nARM926E, ARM1136, ARM11MPCore, Cortex-A8 or Cortex-A9 MPCore CPU\n@item\nARM AMBA Generic/Distributed Interrupt Controller\n@item\nFour PL011 UARTs\n@item\nSMC 91c111 or SMSC LAN9118 Ethernet adapter\n@item\nPL110 LCD controller\n@item\nPL050 KMI with PS/2 keyboard and mouse\n@item\nPCI host bridge\n@item\nPCI OHCI USB controller\n@item\nLSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices\n@item\nPL181 MultiMedia Card Interface with SD card.\n@end itemize\n\nThe XScale-based clamshell PDA models (\"Spitz\", \"Akita\", \"Borzoi\"\nand \"Terrier\") emulation includes the following peripherals:\n\n@itemize @minus\n@item\nIntel PXA270 System-on-chip (ARM V5TE core)\n@item\nNAND Flash memory\n@item\nIBM/Hitachi DSCM microdrive in a PXA PCMCIA slot - not in \"Akita\"\n@item\nOn-chip OHCI USB controller\n@item\nOn-chip LCD controller\n@item\nOn-chip Real Time Clock\n@item\nTI ADS7846 touchscreen controller on SSP bus\n@item\nMaxim MAX1111 analog-digital converter on I@math{^2}C bus\n@item\nGPIO-connected keyboard controller and LEDs\n@item\nSecure Digital card connected to PXA MMC/SD host\n@item\nThree on-chip UARTs\n@item\nWM8750 audio CODEC on I@math{^2}C and I@math{^2}S busses\n@end itemize\n\nThe Palm Tungsten|E PDA (codename \"Cheetah\") emulation includes the\nfollowing elements:\n\n@itemize @minus\n@item\nTexas Instruments OMAP310 System-on-chip (ARM 925T core)\n@item\nROM and RAM memories (ROM firmware image can be loaded with -option-rom)\n@item\nOn-chip LCD controller\n@item\nOn-chip Real Time Clock\n@item\nTI TSC2102i touchscreen controller / analog-digital converter / Audio\nCODEC, connected through MicroWire and I@math{^2}S busses\n@item\nGPIO-connected matrix keypad\n@item\nSecure Digital card connected to OMAP MMC/SD host\n@item\nThree on-chip UARTs\n@end itemize\n\nNokia N800 and N810 internet tablets (known also as RX-34 and RX-44 / 48)\nemulation supports the following elements:\n\n@itemize @minus\n@item\nTexas Instruments OMAP2420 System-on-chip (ARM 1136 core)\n@item\nRAM and non-volatile OneNAND Flash memories\n@item\nDisplay connected to EPSON remote framebuffer chip and OMAP on-chip\ndisplay controller and a LS041y3 MIPI DBI-C controller\n@item\nTI TSC2301 (in N800) and TI TSC2005 (in N810) touchscreen controllers\ndriven through SPI bus\n@item\nNational Semiconductor LM8323-controlled qwerty keyboard driven\nthrough I@math{^2}C bus\n@item\nSecure Digital card connected to OMAP MMC/SD host\n@item\nThree OMAP on-chip UARTs and on-chip STI debugging console\n@item\nA Bluetooth(R) transceiver and HCI connected to an UART\n@item\nMentor Graphics \"Inventra\" dual-role USB controller embedded in a TI\nTUSB6010 chip - only USB host mode is supported\n@item\nTI TMP105 temperature sensor driven through I@math{^2}C bus\n@item\nTI TWL92230C power management companion with an RTC on I@math{^2}C bus\n@item\nNokia RETU and TAHVO multi-purpose chips with an RTC, connected\nthrough CBUS\n@end itemize\n\nThe Luminary Micro Stellaris LM3S811EVB emulation includes the following\ndevices:\n\n@itemize @minus\n@item\nCortex-M3 CPU core.\n@item\n64k Flash and 8k SRAM.\n@item\nTimers, UARTs, ADC and I@math{^2}C interface.\n@item\nOSRAM Pictiva 96x16 OLED with SSD0303 controller on I@math{^2}C bus.\n@end itemize\n\nThe Luminary Micro Stellaris LM3S6965EVB emulation includes the following\ndevices:\n\n@itemize @minus\n@item\nCortex-M3 CPU core.\n@item\n256k Flash and 64k SRAM.\n@item\nTimers, UARTs, ADC, I@math{^2}C and SSI interfaces.\n@item\nOSRAM Pictiva 128x64 OLED with SSD0323 controller connected via SSI.\n@end itemize\n\nThe Freecom MusicPal internet radio emulation includes the following\nelements:\n\n@itemize @minus\n@item\nMarvell MV88W8618 ARM core.\n@item\n32 MB RAM, 256 KB SRAM, 8 MB flash.\n@item\nUp to 2 16550 UARTs\n@item\nMV88W8xx8 Ethernet controller\n@item\nMV88W8618 audio controller, WM8750 CODEC and mixer\n@item\n128×64 display with brightness control\n@item\n2 buttons, 2 navigation wheels with button function\n@end itemize\n\nThe Siemens SX1 models v1 and v2 (default) basic emulation.\nThe emulation includes the following elements:\n\n@itemize @minus\n@item\nTexas Instruments OMAP310 System-on-chip (ARM 925T core)\n@item\nROM and RAM memories (ROM firmware image can be loaded with -pflash)\nV1\n1 Flash of 16MB and 1 Flash of 8MB\nV2\n1 Flash of 32MB\n@item\nOn-chip LCD controller\n@item\nOn-chip Real Time Clock\n@item\nSecure Digital card connected to OMAP MMC/SD host\n@item\nThree on-chip UARTs\n@end itemize\n\nA Linux 2.6 test image is available on the QEMU web site. More\ninformation is available in the QEMU mailing-list archive.\n\n@c man begin OPTIONS\n\nThe following options are specific to the ARM emulation:\n\n@table @option\n\n@item -semihosting\nEnable semihosting syscall emulation.\n\nOn ARM this implements the \"Angel\" interface.\n\nNote that this allows guest direct access to the host filesystem,\nso should only be used with trusted guest OS.\n\n@end table\n\n@node ColdFire System emulator\n@section ColdFire System emulator\n@cindex system emulation (ColdFire)\n@cindex system emulation (M68K)\n\nUse the executable @file{qemu-system-m68k} to simulate a ColdFire machine.\nThe emulator is able to boot a uClinux kernel.\n\nThe M5208EVB emulation includes the following devices:\n\n@itemize @minus\n@item\nMCF5208 ColdFire V2 Microprocessor (ISA A+ with EMAC).\n@item\nThree Two on-chip UARTs.\n@item\nFast Ethernet Controller (FEC)\n@end itemize\n\nThe AN5206 emulation includes the following devices:\n\n@itemize @minus\n@item\nMCF5206 ColdFire V2 Microprocessor.\n@item\nTwo on-chip UARTs.\n@end itemize\n\n@c man begin OPTIONS\n\nThe following options are specific to the ColdFire emulation:\n\n@table @option\n\n@item -semihosting\nEnable semihosting syscall emulation.\n\nOn M68K this implements the \"ColdFire GDB\" interface used by libgloss.\n\nNote that this allows guest direct access to the host filesystem,\nso should only be used with trusted guest OS.\n\n@end table\n\n@node Cris System emulator\n@section Cris System emulator\n@cindex system emulation (Cris)\n\nTODO\n\n@node Microblaze System emulator\n@section Microblaze System emulator\n@cindex system emulation (Microblaze)\n\nTODO\n\n@node SH4 System emulator\n@section SH4 System emulator\n@cindex system emulation (SH4)\n\nTODO\n\n@node Xtensa System emulator\n@section Xtensa System emulator\n@cindex system emulation (Xtensa)\n\nTwo executables cover simulation of both Xtensa endian options,\n@file{qemu-system-xtensa} and @file{qemu-system-xtensaeb}.\nTwo different machine types are emulated:\n\n@itemize @minus\n@item\nXtensa emulator pseudo board \"sim\"\n@item\nAvnet LX60/LX110/LX200 board\n@end itemize\n\nThe sim pseudo board emulation provides an environment similar\nto one provided by the proprietary Tensilica ISS.\nIt supports:\n\n@itemize @minus\n@item\nA range of Xtensa CPUs, default is the DC232B\n@item\nConsole and filesystem access via semihosting calls\n@end itemize\n\nThe Avnet LX60/LX110/LX200 emulation supports:\n\n@itemize @minus\n@item\nA range of Xtensa CPUs, default is the DC232B\n@item\n16550 UART\n@item\nOpenCores 10/100 Mbps Ethernet MAC\n@end itemize\n\n@c man begin OPTIONS\n\nThe following options are specific to the Xtensa emulation:\n\n@table @option\n\n@item -semihosting\nEnable semihosting syscall emulation.\n\nXtensa semihosting provides basic file IO calls, such as open/read/write/seek/select.\nTensilica baremetal libc for ISS and linux platform \"sim\" use this interface.\n\nNote that this allows guest direct access to the host filesystem,\nso should only be used with trusted guest OS.\n\n@end table\n@node QEMU User space emulator\n@chapter QEMU User space emulator\n\n@menu\n* Supported Operating Systems ::\n* Features::\n* Linux User space emulator::\n* BSD User space emulator ::\n@end menu\n\n@node Supported Operating Systems\n@section Supported Operating Systems\n\nThe following OS are supported in user space emulation:\n\n@itemize @minus\n@item\nLinux (referred as qemu-linux-user)\n@item\nBSD (referred as qemu-bsd-user)\n@end itemize\n\n@node Features\n@section Features\n\nQEMU user space emulation has the following notable features:\n\n@table @strong\n@item System call translation:\nQEMU includes a generic system call translator.  This means that\nthe parameters of the system calls can be converted to fix\nendianness and 32/64-bit mismatches between hosts and targets.\nIOCTLs can be converted too.\n\n@item POSIX signal handling:\nQEMU can redirect to the running program all signals coming from\nthe host (such as @code{SIGALRM}), as well as synthesize signals from\nvirtual CPU exceptions (for example @code{SIGFPE} when the program\nexecutes a division by zero).\n\nQEMU relies on the host kernel to emulate most signal system\ncalls, for example to emulate the signal mask.  On Linux, QEMU\nsupports both normal and real-time signals.\n\n@item Threading:\nOn Linux, QEMU can emulate the @code{clone} syscall and create a real\nhost thread (with a separate virtual CPU) for each emulated thread.\nNote that not all targets currently emulate atomic operations correctly.\nx86 and ARM use a global lock in order to preserve their semantics.\n@end table\n\nQEMU was conceived so that ultimately it can emulate itself. Although\nit is not very useful, it is an important test to show the power of the\nemulator.\n\n@node Linux User space emulator\n@section Linux User space emulator\n\n@menu\n* Quick Start::\n* Wine launch::\n* Command line options::\n* Other binaries::\n@end menu\n\n@node Quick Start\n@subsection Quick Start\n\nIn order to launch a Linux process, QEMU needs the process executable\nitself and all the target (x86) dynamic libraries used by it.\n\n@itemize\n\n@item On x86, you can just try to launch any process by using the native\nlibraries:\n\n@example\nqemu-i386 -L / /bin/ls\n@end example\n\n@code{-L /} tells that the x86 dynamic linker must be searched with a\n@file{/} prefix.\n\n@item Since QEMU is also a linux process, you can launch QEMU with\nQEMU (NOTE: you can only do that if you compiled QEMU from the sources):\n\n@example\nqemu-i386 -L / qemu-i386 -L / /bin/ls\n@end example\n\n@item On non x86 CPUs, you need first to download at least an x86 glibc\n(@file{qemu-runtime-i386-XXX-.tar.gz} on the QEMU web page). Ensure that\n@code{LD_LIBRARY_PATH} is not set:\n\n@example\nunset LD_LIBRARY_PATH\n@end example\n\nThen you can launch the precompiled @file{ls} x86 executable:\n\n@example\nqemu-i386 tests/i386/ls\n@end example\nYou can look at @file{scripts/qemu-binfmt-conf.sh} so that\nQEMU is automatically launched by the Linux kernel when you try to\nlaunch x86 executables. It requires the @code{binfmt_misc} module in the\nLinux kernel.\n\n@item The x86 version of QEMU is also included. You can try weird things such as:\n@example\nqemu-i386 /usr/local/qemu-i386/bin/qemu-i386 \\\n          /usr/local/qemu-i386/bin/ls-i386\n@end example\n\n@end itemize\n\n@node Wine launch\n@subsection Wine launch\n\n@itemize\n\n@item Ensure that you have a working QEMU with the x86 glibc\ndistribution (see previous section). In order to verify it, you must be\nable to do:\n\n@example\nqemu-i386 /usr/local/qemu-i386/bin/ls-i386\n@end example\n\n@item Download the binary x86 Wine install\n(@file{qemu-XXX-i386-wine.tar.gz} on the QEMU web page).\n\n@item Configure Wine on your account. Look at the provided script\n@file{/usr/local/qemu-i386/@/bin/wine-conf.sh}. Your previous\n@code{$@{HOME@}/.wine} directory is saved to @code{$@{HOME@}/.wine.org}.\n\n@item Then you can try the example @file{putty.exe}:\n\n@example\nqemu-i386 /usr/local/qemu-i386/wine/bin/wine \\\n          /usr/local/qemu-i386/wine/c/Program\\ Files/putty.exe\n@end example\n\n@end itemize\n\n@node Command line options\n@subsection Command line options\n\n@example\n@command{qemu-i386} [@option{-h]} [@option{-d]} [@option{-L} @var{path}] [@option{-s} @var{size}] [@option{-cpu} @var{model}] [@option{-g} @var{port}] [@option{-B} @var{offset}] [@option{-R} @var{size}] @var{program} [@var{arguments}...]\n@end example\n\n@table @option\n@item -h\nPrint the help\n@item -L path\nSet the x86 elf interpreter prefix (default=/usr/local/qemu-i386)\n@item -s size\nSet the x86 stack size in bytes (default=524288)\n@item -cpu model\nSelect CPU model (-cpu help for list and additional feature selection)\n@item -E @var{var}=@var{value}\nSet environment @var{var} to @var{value}.\n@item -U @var{var}\nRemove @var{var} from the environment.\n@item -B offset\nOffset guest address by the specified number of bytes.  This is useful when\nthe address region required by guest applications is reserved on the host.\nThis option is currently only supported on some hosts.\n@item -R size\nPre-allocate a guest virtual address space of the given size (in bytes).\n\"G\", \"M\", and \"k\" suffixes may be used when specifying the size.\n@end table\n\nDebug options:\n\n@table @option\n@item -d item1,...\nActivate logging of the specified items (use '-d help' for a list of log items)\n@item -p pagesize\nAct as if the host page size was 'pagesize' bytes\n@item -g port\nWait gdb connection to port\n@item -singlestep\nRun the emulation in single step mode.\n@end table\n\nEnvironment variables:\n\n@table @env\n@item QEMU_STRACE\nPrint system calls and arguments similar to the 'strace' program\n(NOTE: the actual 'strace' program will not work because the user\nspace emulator hasn't implemented ptrace).  At the moment this is\nincomplete.  All system calls that don't have a specific argument\nformat are printed with information for six arguments.  Many\nflag-style arguments don't have decoders and will show up as numbers.\n@end table\n\n@node Other binaries\n@subsection Other binaries\n\n@cindex user mode (Alpha)\n@command{qemu-alpha} TODO.\n\n@cindex user mode (ARM)\n@command{qemu-armeb} TODO.\n\n@cindex user mode (ARM)\n@command{qemu-arm} is also capable of running ARM \"Angel\" semihosted ELF\nbinaries (as implemented by the arm-elf and arm-eabi Newlib/GDB\nconfigurations), and arm-uclinux bFLT format binaries.\n\n@cindex user mode (ColdFire)\n@cindex user mode (M68K)\n@command{qemu-m68k} is capable of running semihosted binaries using the BDM\n(m5xxx-ram-hosted.ld) or m68k-sim (sim.ld) syscall interfaces, and\ncoldfire uClinux bFLT format binaries.\n\nThe binary format is detected automatically.\n\n@cindex user mode (Cris)\n@command{qemu-cris} TODO.\n\n@cindex user mode (i386)\n@command{qemu-i386} TODO.\n@command{qemu-x86_64} TODO.\n\n@cindex user mode (Microblaze)\n@command{qemu-microblaze} TODO.\n\n@cindex user mode (MIPS)\n@command{qemu-mips} TODO.\n@command{qemu-mipsel} TODO.\n\n@cindex user mode (NiosII)\n@command{qemu-nios2} TODO.\n\n@cindex user mode (PowerPC)\n@command{qemu-ppc64abi32} TODO.\n@command{qemu-ppc64} TODO.\n@command{qemu-ppc} TODO.\n\n@cindex user mode (SH4)\n@command{qemu-sh4eb} TODO.\n@command{qemu-sh4} TODO.\n\n@cindex user mode (SPARC)\n@command{qemu-sparc} can execute Sparc32 binaries (Sparc32 CPU, 32 bit ABI).\n\n@command{qemu-sparc32plus} can execute Sparc32 and SPARC32PLUS binaries\n(Sparc64 CPU, 32 bit ABI).\n\n@command{qemu-sparc64} can execute some Sparc64 (Sparc64 CPU, 64 bit ABI) and\nSPARC32PLUS binaries (Sparc64 CPU, 32 bit ABI).\n\n@node BSD User space emulator\n@section BSD User space emulator\n\n@menu\n* BSD Status::\n* BSD Quick Start::\n* BSD Command line options::\n@end menu\n\n@node BSD Status\n@subsection BSD Status\n\n@itemize @minus\n@item\ntarget Sparc64 on Sparc64: Some trivial programs work.\n@end itemize\n\n@node BSD Quick Start\n@subsection Quick Start\n\nIn order to launch a BSD process, QEMU needs the process executable\nitself and all the target dynamic libraries used by it.\n\n@itemize\n\n@item On Sparc64, you can just try to launch any process by using the native\nlibraries:\n\n@example\nqemu-sparc64 /bin/ls\n@end example\n\n@end itemize\n\n@node BSD Command line options\n@subsection Command line options\n\n@example\n@command{qemu-sparc64} [@option{-h]} [@option{-d]} [@option{-L} @var{path}] [@option{-s} @var{size}] [@option{-bsd} @var{type}] @var{program} [@var{arguments}...]\n@end example\n\n@table @option\n@item -h\nPrint the help\n@item -L path\nSet the library root path (default=/)\n@item -s size\nSet the stack size in bytes (default=524288)\n@item -ignore-environment\nStart with an empty environment. Without this option,\nthe initial environment is a copy of the caller's environment.\n@item -E @var{var}=@var{value}\nSet environment @var{var} to @var{value}.\n@item -U @var{var}\nRemove @var{var} from the environment.\n@item -bsd type\nSet the type of the emulated BSD Operating system. Valid values are\nFreeBSD, NetBSD and OpenBSD (default).\n@end table\n\nDebug options:\n\n@table @option\n@item -d item1,...\nActivate logging of the specified items (use '-d help' for a list of log items)\n@item -p pagesize\nAct as if the host page size was 'pagesize' bytes\n@item -singlestep\nRun the emulation in single step mode.\n@end table\n\n\n@include qemu-tech.texi\n\n@node License\n@appendix License\n\nQEMU is a trademark of Fabrice Bellard.\n\nQEMU is released under the GNU General Public License (TODO: add link).\nParts of QEMU have specific licenses, see file LICENSE.\n\nTODO (refer to file LICENSE, include it, include the GPL?)\n\n@node Index\n@appendix Index\n@menu\n* Concept Index::\n* Function Index::\n* Keystroke Index::\n* Program Index::\n* Data Type Index::\n* Variable Index::\n@end menu\n\n@node Concept Index\n@section Concept Index\nThis is the main index. Should we combine all keywords in one index? TODO\n@printindex cp\n\n@node Function Index\n@section Function Index\nThis index could be used for command line options and monitor functions.\n@printindex fn\n\n@node Keystroke Index\n@section Keystroke Index\n\nThis is a list of all keystrokes which have a special function\nin system emulation.\n\n@printindex ky\n\n@node Program Index\n@section Program Index\n@printindex pg\n\n@node Data Type Index\n@section Data Type Index\n\nThis index could be used for qdev device names and options.\n\n@printindex tp\n\n@node Variable Index\n@section Variable Index\n@printindex vr\n\n@bye\n"
        },
        {
          "name": "qemu-ga.texi",
          "type": "blob",
          "size": 3.2060546875,
          "content": "@example\n@c man begin SYNOPSIS\n@command{qemu-ga} [@var{OPTIONS}]\n@c man end\n@end example\n\n@c man begin DESCRIPTION\n\nThe QEMU Guest Agent is a daemon intended to be run within virtual\nmachines. It allows the hypervisor host to perform various operations\nin the guest, such as:\n\n@itemize\n@item\nget information from the guest\n@item\nset the guest's system time\n@item\nread/write a file\n@item\nsync and freeze the filesystems\n@item\nsuspend the guest\n@item\nreconfigure guest local processors\n@item\nset user's password\n@item\n...\n@end itemize\n\nqemu-ga will read a system configuration file on startup (located at\n@file{/etc/qemu/qemu-ga.conf} by default), then parse remaining\nconfiguration options on the command line. For the same key, the last\noption wins, but the lists accumulate (see below for configuration\nfile format).\n\n@c man end\n\n@c man begin OPTIONS\n@table @option\n@item -m, --method=@var{method}\n  Transport method: one of @samp{unix-listen}, @samp{virtio-serial}, or\n  @samp{isa-serial} (@samp{virtio-serial} is the default).\n\n@item -p, --path=@var{path}\n  Device/socket path (the default for virtio-serial is\n  @samp{/dev/virtio-ports/org.qemu.guest_agent.0},\n  the default for isa-serial is @samp{/dev/ttyS0})\n\n@item -l, --logfile=@var{path}\n  Set log file path (default is stderr).\n\n@item -f, --pidfile=@var{path}\n  Specify pid file (default is @samp{/var/run/qemu-ga.pid}).\n\n@item -F, --fsfreeze-hook=@var{path}\n  Enable fsfreeze hook. Accepts an optional argument that specifies\n  script to run on freeze/thaw. Script will be called with\n  'freeze'/'thaw' arguments accordingly (default is\n  @samp{/etc/qemu/fsfreeze-hook}). If using -F with an argument, do\n  not follow -F with a space (for example:\n  @samp{-F/var/run/fsfreezehook.sh}).\n\n@item -t, --statedir=@var{path}\n  Specify the directory to store state information (absolute paths only,\n  default is @samp{/var/run}).\n\n@item -v, --verbose\n  Log extra debugging information.\n\n@item -V, --version\n  Print version information and exit.\n\n@item -d, --daemon\n  Daemonize after startup (detach from terminal).\n\n@item -b, --blacklist=@var{list}\n  Comma-separated list of RPCs to disable (no spaces, @samp{?} to list\n  available RPCs).\n\n@item -D, --dump-conf\n  Dump the configuration in a format compatible with @file{qemu-ga.conf}\n  and exit.\n\n@item -h, --help\n  Display this help and exit.\n@end table\n\n@c man end\n\n@c man begin FILES\n\nThe syntax of the @file{qemu-ga.conf} configuration file follows the\nDesktop Entry Specification, here is a quick summary: it consists of\ngroups of key-value pairs, interspersed with comments.\n\n@example\n# qemu-ga configuration sample\n[general]\ndaemonize = 0\npidfile = /var/run/qemu-ga.pid\nverbose = 0\nmethod = virtio-serial\npath = /dev/virtio-ports/org.qemu.guest_agent.0\nstatedir = /var/run\n@end example\n\nThe list of keys follows the command line options:\n@table @option\n@item daemon= boolean\n@item method= string\n@item path= string\n@item logfile= string\n@item pidfile= string\n@item fsfreeze-hook= string\n@item statedir= string\n@item verbose= boolean\n@item blacklist= string list\n@end table\n\n@c man end\n\n@ignore\n\n@setfilename qemu-ga\n@settitle QEMU Guest Agent\n\n@c man begin AUTHOR\nMichael Roth <mdroth@linux.vnet.ibm.com>\n@c man end\n\n@c man begin SEEALSO\nqemu(1)\n@c man end\n\n@end ignore\n"
        },
        {
          "name": "qemu-img-cmds.hx",
          "type": "blob",
          "size": 4.4375,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and texi\nHXCOMM Text between STEXI and ETEXI are copied to texi version and\nHXCOMM discarded from C version\nHXCOMM DEF(command, callback, arg_string) is used to construct\nHXCOMM command structures and help message.\nHXCOMM HXCOMM can be used for comments, discarded from both texi and C\n\nSTEXI\n@table @option\nETEXI\n\nDEF(\"bench\", img_bench,\n    \"bench [-c count] [-d depth] [-f fmt] [--flush-interval=flush_interval] [-n] [--no-drain] [-o offset] [--pattern=pattern] [-q] [-s buffer_size] [-S step_size] [-t cache] [-w] filename\")\nSTEXI\n@item bench [-c @var{count}] [-d @var{depth}] [-f @var{fmt}] [--flush-interval=@var{flush_interval}] [-n] [--no-drain] [-o @var{offset}] [--pattern=@var{pattern}] [-q] [-s @var{buffer_size}] [-S @var{step_size}] [-t @var{cache}] [-w] @var{filename}\nETEXI\n\nDEF(\"check\", img_check,\n    \"check [-q] [--object objectdef] [--image-opts] [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T src_cache] filename\")\nSTEXI\n@item check [--object @var{objectdef}] [--image-opts] [-q] [-f @var{fmt}] [--output=@var{ofmt}] [-r [leaks | all]] [-T @var{src_cache}] @var{filename}\nETEXI\n\nDEF(\"create\", img_create,\n    \"create [-q] [--object objectdef] [-f fmt] [-o options] filename [size]\")\nSTEXI\n@item create [--object @var{objectdef}] [-q] [-f @var{fmt}] [-o @var{options}] @var{filename} [@var{size}]\nETEXI\n\nDEF(\"commit\", img_commit,\n    \"commit [-q] [--object objectdef] [--image-opts] [-f fmt] [-t cache] [-b base] [-d] [-p] filename\")\nSTEXI\n@item commit [--object @var{objectdef}] [--image-opts] [-q] [-f @var{fmt}] [-t @var{cache}] [-b @var{base}] [-d] [-p] @var{filename}\nETEXI\n\nDEF(\"compare\", img_compare,\n    \"compare [--object objectdef] [--image-opts] [-f fmt] [-F fmt] [-T src_cache] [-p] [-q] [-s] filename1 filename2\")\nSTEXI\n@item compare [--object @var{objectdef}] [--image-opts] [-f @var{fmt}] [-F @var{fmt}] [-T @var{src_cache}] [-p] [-q] [-s] @var{filename1} @var{filename2}\nETEXI\n\nDEF(\"convert\", img_convert,\n    \"convert [--object objectdef] [--image-opts] [-c] [-p] [-q] [-n] [-f fmt] [-t cache] [-T src_cache] [-O output_fmt] [-o options] [-s snapshot_id_or_name] [-l snapshot_param] [-S sparse_size] [-m num_coroutines] [-W] filename [filename2 [...]] output_filename\")\nSTEXI\n@item convert [--object @var{objectdef}] [--image-opts] [-c] [-p] [-q] [-n] [-f @var{fmt}] [-t @var{cache}] [-T @var{src_cache}] [-O @var{output_fmt}] [-o @var{options}] [-s @var{snapshot_id_or_name}] [-l @var{snapshot_param}] [-S @var{sparse_size}] [-m @var{num_coroutines}] [-W] @var{filename} [@var{filename2} [...]] @var{output_filename}\nETEXI\n\nDEF(\"dd\", img_dd,\n    \"dd [--image-opts] [-f fmt] [-O output_fmt] [bs=block_size] [count=blocks] [skip=blocks] if=input of=output\")\nSTEXI\n@item dd [--image-opts] [-f @var{fmt}] [-O @var{output_fmt}] [bs=@var{block_size}] [count=@var{blocks}] [skip=@var{blocks}] if=@var{input} of=@var{output}\nETEXI\n\nDEF(\"info\", img_info,\n    \"info [--object objectdef] [--image-opts] [-f fmt] [--output=ofmt] [--backing-chain] filename\")\nSTEXI\n@item info [--object @var{objectdef}] [--image-opts] [-f @var{fmt}] [--output=@var{ofmt}] [--backing-chain] @var{filename}\nETEXI\n\nDEF(\"map\", img_map,\n    \"map [--object objectdef] [--image-opts] [-f fmt] [--output=ofmt] filename\")\nSTEXI\n@item map [--object @var{objectdef}] [--image-opts] [-f @var{fmt}] [--output=@var{ofmt}] @var{filename}\nETEXI\n\nDEF(\"snapshot\", img_snapshot,\n    \"snapshot [--object objectdef] [--image-opts] [-q] [-l | -a snapshot | -c snapshot | -d snapshot] filename\")\nSTEXI\n@item snapshot [--object @var{objectdef}] [--image-opts] [-q] [-l | -a @var{snapshot} | -c @var{snapshot} | -d @var{snapshot}] @var{filename}\nETEXI\n\nDEF(\"rebase\", img_rebase,\n    \"rebase [--object objectdef] [--image-opts] [-q] [-f fmt] [-t cache] [-T src_cache] [-p] [-u] -b backing_file [-F backing_fmt] filename\")\nSTEXI\n@item rebase [--object @var{objectdef}] [--image-opts] [-q] [-f @var{fmt}] [-t @var{cache}] [-T @var{src_cache}] [-p] [-u] -b @var{backing_file} [-F @var{backing_fmt}] @var{filename}\nETEXI\n\nDEF(\"resize\", img_resize,\n    \"resize [--object objectdef] [--image-opts] [-q] filename [+ | -]size\")\nSTEXI\n@item resize [--object @var{objectdef}] [--image-opts] [-q] @var{filename} [+ | -]@var{size}\nETEXI\n\nDEF(\"amend\", img_amend,\n    \"amend [--object objectdef] [--image-opts] [-p] [-q] [-f fmt] [-t cache] -o options filename\")\nSTEXI\n@item amend [--object @var{objectdef}] [--image-opts] [-p] [-q] [-f @var{fmt}] [-t @var{cache}] -o @var{options} @var{filename}\n@end table\nETEXI\n"
        },
        {
          "name": "qemu-img.c",
          "type": "blob",
          "size": 127.3935546875,
          "content": "/*\n * QEMU disk image utility\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include \"qemu-version.h\"\n#include \"qapi/error.h\"\n#include \"qapi-visit.h\"\n#include \"qapi/qobject-output-visitor.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/option.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/log.h\"\n#include \"qom/object_interfaces.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block_int.h\"\n#include \"block/blockjob.h\"\n#include \"block/qapi.h\"\n#include \"crypto/init.h\"\n#include \"trace/control.h\"\n#include <getopt.h>\n\n#define QEMU_IMG_VERSION \"qemu-img version \" QEMU_VERSION QEMU_PKGVERSION \\\n                          \"\\n\" QEMU_COPYRIGHT \"\\n\"\n\ntypedef struct img_cmd_t {\n    const char *name;\n    int (*handler)(int argc, char **argv);\n} img_cmd_t;\n\nenum {\n    OPTION_OUTPUT = 256,\n    OPTION_BACKING_CHAIN = 257,\n    OPTION_OBJECT = 258,\n    OPTION_IMAGE_OPTS = 259,\n    OPTION_PATTERN = 260,\n    OPTION_FLUSH_INTERVAL = 261,\n    OPTION_NO_DRAIN = 262,\n};\n\ntypedef enum OutputFormat {\n    OFORMAT_JSON,\n    OFORMAT_HUMAN,\n} OutputFormat;\n\n/* Default to cache=writeback as data integrity is not important for qemu-img */\n#define BDRV_DEFAULT_CACHE \"writeback\"\n\nstatic void format_print(void *opaque, const char *name)\n{\n    printf(\" %s\", name);\n}\n\nstatic void QEMU_NORETURN GCC_FMT_ATTR(1, 2) error_exit(const char *fmt, ...)\n{\n    va_list ap;\n\n    error_printf(\"qemu-img: \");\n\n    va_start(ap, fmt);\n    error_vprintf(fmt, ap);\n    va_end(ap);\n\n    error_printf(\"\\nTry 'qemu-img --help' for more information\\n\");\n    exit(EXIT_FAILURE);\n}\n\nstatic void QEMU_NORETURN missing_argument(const char *option)\n{\n    error_exit(\"missing argument for option '%s'\", option);\n}\n\nstatic void QEMU_NORETURN unrecognized_option(const char *option)\n{\n    error_exit(\"unrecognized option '%s'\", option);\n}\n\n/* Please keep in synch with qemu-img.texi */\nstatic void QEMU_NORETURN help(void)\n{\n    const char *help_msg =\n           QEMU_IMG_VERSION\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n           \"QEMU disk image utility\\n\"\n           \"\\n\"\n           \"    '-h', '--help'       display this help and exit\\n\"\n           \"    '-V', '--version'    output version information and exit\\n\"\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n           \"                         specify tracing options\\n\"\n           \"\\n\"\n           \"Command syntax:\\n\"\n#define DEF(option, callback, arg_string)        \\\n           \"  \" arg_string \"\\n\"\n#include \"qemu-img-cmds.h\"\n#undef DEF\n#undef GEN_DOCS\n           \"\\n\"\n           \"Command parameters:\\n\"\n           \"  'filename' is a disk image filename\\n\"\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n           \"    manual page for a description of the object properties. The most common\\n\"\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n           \"    encryption keys.\\n\"\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n           \"    options are the same as for the 'cache' option\\n\"\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n           \"    supported. 'b' is ignored.\\n\"\n           \"  'output_filename' is the destination disk image filename\\n\"\n           \"  'output_fmt' is the destination format\\n\"\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n           \"    used format\\n\"\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n           \"    '[ID_OR_NAME]'\\n\"\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n           \"    instead\\n\"\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n           \"  '-p' show progress of command (only certain commands)\\n\"\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n           \"       fully allocated\\n\"\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n           \"       prior to running qemu-img)\\n\"\n           \"\\n\"\n           \"Parameters to check subcommand:\\n\"\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n           \"       hiding corruption that has already occurred.\\n\"\n           \"\\n\"\n           \"Parameters to convert subcommand:\\n\"\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n           \"       process (defaults to 8)\\n\"\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n           \"\\n\"\n           \"Parameters to snapshot subcommand:\\n\"\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n           \"  '-c' creates a snapshot\\n\"\n           \"  '-d' deletes a snapshot\\n\"\n           \"  '-l' lists all snapshots in the given image\\n\"\n           \"\\n\"\n           \"Parameters to compare subcommand:\\n\"\n           \"  '-f' first image format\\n\"\n           \"  '-F' second image format\\n\"\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n           \"\\n\"\n           \"Parameters to dd subcommand:\\n\"\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n           \"(default: 512)\\n\"\n           \"  'count=N' copy only N input blocks\\n\"\n           \"  'if=FILE' read from FILE\\n\"\n           \"  'of=FILE' write to FILE\\n\"\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n    bdrv_iterate_format(format_print, NULL);\n    printf(\"\\n\");\n    exit(EXIT_SUCCESS);\n}\n\nstatic QemuOptsList qemu_object_opts = {\n    .name = \"object\",\n    .implied_opt_name = \"qom-type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_object_opts.head),\n    .desc = {\n        { }\n    },\n};\n\nstatic QemuOptsList qemu_source_opts = {\n    .name = \"source\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_source_opts.head),\n    .desc = {\n        { }\n    },\n};\n\nstatic int GCC_FMT_ATTR(2, 3) qprintf(bool quiet, const char *fmt, ...)\n{\n    int ret = 0;\n    if (!quiet) {\n        va_list args;\n        va_start(args, fmt);\n        ret = vprintf(fmt, args);\n        va_end(args);\n    }\n    return ret;\n}\n\n\nstatic int print_block_option_help(const char *filename, const char *fmt)\n{\n    BlockDriver *drv, *proto_drv;\n    QemuOptsList *create_opts = NULL;\n    Error *local_err = NULL;\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(fmt);\n    if (!drv) {\n        error_report(\"Unknown file format '%s'\", fmt);\n        return 1;\n    }\n\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    if (filename) {\n        proto_drv = bdrv_find_protocol(filename, true, &local_err);\n        if (!proto_drv) {\n            error_report_err(local_err);\n            qemu_opts_free(create_opts);\n            return 1;\n        }\n        create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n    }\n\n    qemu_opts_print_help(create_opts);\n    qemu_opts_free(create_opts);\n    return 0;\n}\n\n\nstatic int img_open_password(BlockBackend *blk, const char *filename,\n                             int flags, bool quiet)\n{\n    BlockDriverState *bs;\n    char password[256];\n\n    bs = blk_bs(blk);\n    if (bdrv_is_encrypted(bs) && bdrv_key_required(bs) &&\n        !(flags & BDRV_O_NO_IO)) {\n        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n            error_report(\"No password given\");\n            return -1;\n        }\n        if (bdrv_set_key(bs, password) < 0) {\n            error_report(\"invalid password\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\nstatic BlockBackend *img_open_opts(const char *optstr,\n                                   QemuOpts *opts, int flags, bool writethrough,\n                                   bool quiet)\n{\n    QDict *options;\n    Error *local_err = NULL;\n    BlockBackend *blk;\n    options = qemu_opts_to_qdict(opts, NULL);\n    blk = blk_new_open(NULL, NULL, options, flags, &local_err);\n    if (!blk) {\n        error_reportf_err(local_err, \"Could not open '%s': \", optstr);\n        return NULL;\n    }\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    if (img_open_password(blk, optstr, flags, quiet) < 0) {\n        blk_unref(blk);\n        return NULL;\n    }\n    return blk;\n}\n\nstatic BlockBackend *img_open_file(const char *filename,\n                                   const char *fmt, int flags,\n                                   bool writethrough, bool quiet)\n{\n    BlockBackend *blk;\n    Error *local_err = NULL;\n    QDict *options = NULL;\n\n    if (fmt) {\n        options = qdict_new();\n        qdict_put_str(options, \"driver\", fmt);\n    }\n\n    blk = blk_new_open(filename, NULL, options, flags, &local_err);\n    if (!blk) {\n        error_reportf_err(local_err, \"Could not open '%s': \", filename);\n        return NULL;\n    }\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    if (img_open_password(blk, filename, flags, quiet) < 0) {\n        blk_unref(blk);\n        return NULL;\n    }\n    return blk;\n}\n\n\nstatic BlockBackend *img_open(bool image_opts,\n                              const char *filename,\n                              const char *fmt, int flags, bool writethrough,\n                              bool quiet)\n{\n    BlockBackend *blk;\n    if (image_opts) {\n        QemuOpts *opts;\n        if (fmt) {\n            error_report(\"--image-opts and --format are mutually exclusive\");\n            return NULL;\n        }\n        opts = qemu_opts_parse_noisily(qemu_find_opts(\"source\"),\n                                       filename, true);\n        if (!opts) {\n            return NULL;\n        }\n        blk = img_open_opts(filename, opts, flags, writethrough, quiet);\n    } else {\n        blk = img_open_file(filename, fmt, flags, writethrough, quiet);\n    }\n    return blk;\n}\n\n\nstatic int add_old_style_options(const char *fmt, QemuOpts *opts,\n                                 const char *base_filename,\n                                 const char *base_fmt)\n{\n    Error *err = NULL;\n\n    if (base_filename) {\n        qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename, &err);\n        if (err) {\n            error_report(\"Backing file not supported for file format '%s'\",\n                         fmt);\n            error_free(err);\n            return -1;\n        }\n    }\n    if (base_fmt) {\n        qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, &err);\n        if (err) {\n            error_report(\"Backing file format not supported for file \"\n                         \"format '%s'\", fmt);\n            error_free(err);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int64_t cvtnum(const char *s)\n{\n    int err;\n    uint64_t value;\n\n    err = qemu_strtosz(s, NULL, &value);\n    if (err < 0) {\n        return err;\n    }\n    if (value > INT64_MAX) {\n        return -ERANGE;\n    }\n    return value;\n}\n\nstatic int img_create(int argc, char **argv)\n{\n    int c;\n    uint64_t img_size = -1;\n    const char *fmt = \"raw\";\n    const char *base_fmt = NULL;\n    const char *filename;\n    const char *base_filename = NULL;\n    char *options = NULL;\n    Error *local_err = NULL;\n    bool quiet = false;\n\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":F:b:f:he6o:q\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'F':\n            base_fmt = optarg;\n            break;\n        case 'b':\n            base_filename = optarg;\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'e':\n            error_report(\"option -e is deprecated, please use \\'-o \"\n                  \"encryption\\' instead!\");\n            goto fail;\n        case '6':\n            error_report(\"option -6 is deprecated, please use \\'-o \"\n                  \"compat6\\' instead!\");\n            goto fail;\n        case 'o':\n            if (!is_valid_option_list(optarg)) {\n                error_report(\"Invalid option list: %s\", optarg);\n                goto fail;\n            }\n            if (!options) {\n                options = g_strdup(optarg);\n            } else {\n                char *old_options = options;\n                options = g_strdup_printf(\"%s,%s\", options, optarg);\n                g_free(old_options);\n            }\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                goto fail;\n            }\n        }   break;\n        }\n    }\n\n    /* Get the filename */\n    filename = (optind < argc) ? argv[optind] : NULL;\n    if (options && has_help_option(options)) {\n        g_free(options);\n        return print_block_option_help(filename, fmt);\n    }\n\n    if (optind >= argc) {\n        error_exit(\"Expecting image file name\");\n    }\n    optind++;\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        goto fail;\n    }\n\n    /* Get image size, if specified */\n    if (optind < argc) {\n        int64_t sval;\n\n        sval = cvtnum(argv[optind++]);\n        if (sval < 0) {\n            if (sval == -ERANGE) {\n                error_report(\"Image size must be less than 8 EiB!\");\n            } else {\n                error_report(\"Invalid image size specified! You may use k, M, \"\n                      \"G, T, P or E suffixes for \");\n                error_report(\"kilobytes, megabytes, gigabytes, terabytes, \"\n                             \"petabytes and exabytes.\");\n            }\n            goto fail;\n        }\n        img_size = (uint64_t)sval;\n    }\n    if (optind != argc) {\n        error_exit(\"Unexpected argument: %s\", argv[optind]);\n    }\n\n    bdrv_img_create(filename, fmt, base_filename, base_fmt,\n                    options, img_size, 0, &local_err, quiet);\n    if (local_err) {\n        error_reportf_err(local_err, \"%s: \", filename);\n        goto fail;\n    }\n\n    g_free(options);\n    return 0;\n\nfail:\n    g_free(options);\n    return 1;\n}\n\nstatic void dump_json_image_check(ImageCheck *check, bool quiet)\n{\n    QString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageCheck(v, NULL, &check, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj);\n    assert(str != NULL);\n    qprintf(quiet, \"%s\\n\", qstring_get_str(str));\n    qobject_decref(obj);\n    visit_free(v);\n    QDECREF(str);\n}\n\nstatic void dump_human_image_check(ImageCheck *check, bool quiet)\n{\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n        qprintf(quiet, \"No errors were found on the image.\\n\");\n    } else {\n        if (check->corruptions) {\n            qprintf(quiet, \"\\n%\" PRId64 \" errors were found on the image.\\n\"\n                    \"Data may be corrupted, or further writes to the image \"\n                    \"may corrupt it.\\n\",\n                    check->corruptions);\n        }\n\n        if (check->leaks) {\n            qprintf(quiet,\n                    \"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n                    \"This means waste of disk space, but no harm to data.\\n\",\n                    check->leaks);\n        }\n\n        if (check->check_errors) {\n            qprintf(quiet,\n                    \"\\n%\" PRId64\n                    \" internal errors have occurred during the check.\\n\",\n                    check->check_errors);\n        }\n    }\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n        qprintf(quiet, \"%\" PRId64 \"/%\" PRId64 \" = %0.2f%% allocated, \"\n                \"%0.2f%% fragmented, %0.2f%% compressed clusters\\n\",\n                check->allocated_clusters, check->total_clusters,\n                check->allocated_clusters * 100.0 / check->total_clusters,\n                check->fragmented_clusters * 100.0 / check->allocated_clusters,\n                check->compressed_clusters * 100.0 /\n                check->allocated_clusters);\n    }\n\n    if (check->image_end_offset) {\n        qprintf(quiet,\n                \"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n    }\n}\n\nstatic int collect_image_check(BlockDriverState *bs,\n                   ImageCheck *check,\n                   const char *filename,\n                   const char *fmt,\n                   int fix)\n{\n    int ret;\n    BdrvCheckResult result;\n\n    ret = bdrv_check(bs, &result, fix);\n    if (ret < 0) {\n        return ret;\n    }\n\n    check->filename                 = g_strdup(filename);\n    check->format                   = g_strdup(bdrv_get_format_name(bs));\n    check->check_errors             = result.check_errors;\n    check->corruptions              = result.corruptions;\n    check->has_corruptions          = result.corruptions != 0;\n    check->leaks                    = result.leaks;\n    check->has_leaks                = result.leaks != 0;\n    check->corruptions_fixed        = result.corruptions_fixed;\n    check->has_corruptions_fixed    = result.corruptions != 0;\n    check->leaks_fixed              = result.leaks_fixed;\n    check->has_leaks_fixed          = result.leaks != 0;\n    check->image_end_offset         = result.image_end_offset;\n    check->has_image_end_offset     = result.image_end_offset != 0;\n    check->total_clusters           = result.bfi.total_clusters;\n    check->has_total_clusters       = result.bfi.total_clusters != 0;\n    check->allocated_clusters       = result.bfi.allocated_clusters;\n    check->has_allocated_clusters   = result.bfi.allocated_clusters != 0;\n    check->fragmented_clusters      = result.bfi.fragmented_clusters;\n    check->has_fragmented_clusters  = result.bfi.fragmented_clusters != 0;\n    check->compressed_clusters      = result.bfi.compressed_clusters;\n    check->has_compressed_clusters  = result.bfi.compressed_clusters != 0;\n\n    return 0;\n}\n\n/*\n * Checks an image for consistency. Exit codes:\n *\n *  0 - Check completed, image is good\n *  1 - Check not completed because of internal errors\n *  2 - Check completed, image is corrupted\n *  3 - Check completed, image has leaked clusters, but is good otherwise\n * 63 - Checks are not supported by the image format\n */\nstatic int img_check(int argc, char **argv)\n{\n    int c, ret;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    const char *filename, *fmt, *output, *cache;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    int fix = 0;\n    int flags = BDRV_O_CHECK;\n    bool writethrough;\n    ImageCheck *check;\n    bool quiet = false;\n    bool image_opts = false;\n\n    fmt = NULL;\n    output = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n\n    for(;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"repair\", required_argument, 0, 'r'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:r:T:q\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'r':\n            flags |= BDRV_O_RDWR;\n\n            if (!strcmp(optarg, \"leaks\")) {\n                fix = BDRV_FIX_LEAKS;\n            } else if (!strcmp(optarg, \"all\")) {\n                fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS;\n            } else {\n                error_exit(\"Unknown option value for -r \"\n                           \"(expecting 'leaks' or 'all'): %s\", optarg);\n            }\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case 'T':\n            cache = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", cache);\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    check = g_new0(ImageCheck, 1);\n    ret = collect_image_check(bs, check, filename, fmt, fix);\n\n    if (ret == -ENOTSUP) {\n        error_report(\"This image format does not support checks\");\n        ret = 63;\n        goto fail;\n    }\n\n    if (check->corruptions_fixed || check->leaks_fixed) {\n        int corruptions_fixed, leaks_fixed;\n\n        leaks_fixed         = check->leaks_fixed;\n        corruptions_fixed   = check->corruptions_fixed;\n\n        if (output_format == OFORMAT_HUMAN) {\n            qprintf(quiet,\n                    \"The following inconsistencies were found and repaired:\\n\\n\"\n                    \"    %\" PRId64 \" leaked clusters\\n\"\n                    \"    %\" PRId64 \" corruptions\\n\\n\"\n                    \"Double checking the fixed image now...\\n\",\n                    check->leaks_fixed,\n                    check->corruptions_fixed);\n        }\n\n        ret = collect_image_check(bs, check, filename, fmt, 0);\n\n        check->leaks_fixed          = leaks_fixed;\n        check->corruptions_fixed    = corruptions_fixed;\n    }\n\n    if (!ret) {\n        switch (output_format) {\n        case OFORMAT_HUMAN:\n            dump_human_image_check(check, quiet);\n            break;\n        case OFORMAT_JSON:\n            dump_json_image_check(check, quiet);\n            break;\n        }\n    }\n\n    if (ret || check->check_errors) {\n        if (ret) {\n            error_report(\"Check failed: %s\", strerror(-ret));\n        } else {\n            error_report(\"Check failed\");\n        }\n        ret = 1;\n        goto fail;\n    }\n\n    if (check->corruptions) {\n        ret = 2;\n    } else if (check->leaks) {\n        ret = 3;\n    } else {\n        ret = 0;\n    }\n\nfail:\n    qapi_free_ImageCheck(check);\n    blk_unref(blk);\n    return ret;\n}\n\ntypedef struct CommonBlockJobCBInfo {\n    BlockDriverState *bs;\n    Error **errp;\n} CommonBlockJobCBInfo;\n\nstatic void common_block_job_cb(void *opaque, int ret)\n{\n    CommonBlockJobCBInfo *cbi = opaque;\n\n    if (ret < 0) {\n        error_setg_errno(cbi->errp, -ret, \"Block job failed\");\n    }\n}\n\nstatic void run_block_job(BlockJob *job, Error **errp)\n{\n    AioContext *aio_context = blk_get_aio_context(job->blk);\n\n    /* FIXME In error cases, the job simply goes away and we access a dangling\n     * pointer below. */\n    aio_context_acquire(aio_context);\n    do {\n        aio_poll(aio_context, true);\n        qemu_progress_print(job->len ?\n                            ((float)job->offset / job->len * 100.f) : 0.0f, 0);\n    } while (!job->ready);\n\n    block_job_complete_sync(job, errp);\n    aio_context_release(aio_context);\n\n    /* A block job may finish instantaneously without publishing any progress,\n     * so just signal completion here */\n    qemu_progress_print(100.f, 0);\n}\n\nstatic int img_commit(int argc, char **argv)\n{\n    int c, ret, flags;\n    const char *filename, *fmt, *cache, *base;\n    BlockBackend *blk;\n    BlockDriverState *bs, *base_bs;\n    BlockJob *job;\n    bool progress = false, quiet = false, drop = false;\n    bool writethrough;\n    Error *local_err = NULL;\n    CommonBlockJobCBInfo cbi;\n    bool image_opts = false;\n    AioContext *aio_context;\n\n    fmt = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n    base = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:ht:b:dpq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'b':\n            base = optarg;\n            /* -b implies -d */\n            drop = true;\n            break;\n        case 'd':\n            drop = true;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    /* Progress is not shown in Quiet mode */\n    if (quiet) {\n        progress = false;\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    qemu_progress_init(progress, 1.f);\n    qemu_progress_print(0.f, 100);\n\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (!base_bs) {\n            error_setg(&local_err,\n                       \"Did not find '%s' in the backing chain of '%s'\",\n                       base, filename);\n            goto done;\n        }\n    } else {\n        /* This is different from QMP, which by default uses the deepest file in\n         * the backing chain (i.e., the very base); however, the traditional\n         * behavior of qemu-img commit is using the immediate backing file. */\n        base_bs = backing_bs(bs);\n        if (!base_bs) {\n            error_setg(&local_err, \"Image does not have a backing file\");\n            goto done;\n        }\n    }\n\n    cbi = (CommonBlockJobCBInfo){\n        .errp = &local_err,\n        .bs   = bs,\n    };\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n                        BLOCKDEV_ON_ERROR_REPORT, NULL, common_block_job_cb,\n                        &cbi, &local_err, false);\n    aio_context_release(aio_context);\n    if (local_err) {\n        goto done;\n    }\n\n    /* When the block job completes, the BlockBackend reference will point to\n     * the old backing file. In order to avoid that the top image is already\n     * deleted, so we can still empty it afterwards, increment the reference\n     * counter here preemptively. */\n    if (!drop) {\n        bdrv_ref(bs);\n    }\n\n    job = block_job_get(\"commit\");\n    run_block_job(job, &local_err);\n    if (local_err) {\n        goto unref_backing;\n    }\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n        ret = bs->drv->bdrv_make_empty(bs);\n        if (ret) {\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n                             filename);\n            goto unref_backing;\n        }\n    }\n\nunref_backing:\n    if (!drop) {\n        bdrv_unref(bs);\n    }\n\ndone:\n    qemu_progress_end();\n\n    blk_unref(blk);\n\n    if (local_err) {\n        error_report_err(local_err);\n        return 1;\n    }\n\n    qprintf(quiet, \"Image committed.\\n\");\n    return 0;\n}\n\n/*\n * Returns true iff the first sector pointed to by 'buf' contains at least\n * a non-NUL byte.\n *\n * 'pnum' is set to the number of sectors (including and immediately following\n * the first one) that are known to be in the same allocated/unallocated state.\n */\nstatic int is_allocated_sectors(const uint8_t *buf, int n, int *pnum)\n{\n    bool is_zero;\n    int i;\n\n    if (n <= 0) {\n        *pnum = 0;\n        return 0;\n    }\n    is_zero = buffer_is_zero(buf, 512);\n    for(i = 1; i < n; i++) {\n        buf += 512;\n        if (is_zero != buffer_is_zero(buf, 512)) {\n            break;\n        }\n    }\n    *pnum = i;\n    return !is_zero;\n}\n\n/*\n * Like is_allocated_sectors, but if the buffer starts with a used sector,\n * up to 'min' consecutive sectors containing zeros are ignored. This avoids\n * breaking up write requests for only small sparse areas.\n */\nstatic int is_allocated_sectors_min(const uint8_t *buf, int n, int *pnum,\n    int min)\n{\n    int ret;\n    int num_checked, num_used;\n\n    if (n < min) {\n        min = n;\n    }\n\n    ret = is_allocated_sectors(buf, n, pnum);\n    if (!ret) {\n        return ret;\n    }\n\n    num_used = *pnum;\n    buf += BDRV_SECTOR_SIZE * *pnum;\n    n -= *pnum;\n    num_checked = num_used;\n\n    while (n > 0) {\n        ret = is_allocated_sectors(buf, n, pnum);\n\n        buf += BDRV_SECTOR_SIZE * *pnum;\n        n -= *pnum;\n        num_checked += *pnum;\n        if (ret) {\n            num_used = num_checked;\n        } else if (*pnum >= min) {\n            break;\n        }\n    }\n\n    *pnum = num_used;\n    return 1;\n}\n\n/*\n * Compares two buffers sector by sector. Returns 0 if the first sector of both\n * buffers matches, non-zero otherwise.\n *\n * pnum is set to the number of sectors (including and immediately following\n * the first one) that are known to have the same comparison result\n */\nstatic int compare_sectors(const uint8_t *buf1, const uint8_t *buf2, int n,\n    int *pnum)\n{\n    bool res;\n    int i;\n\n    if (n <= 0) {\n        *pnum = 0;\n        return 0;\n    }\n\n    res = !!memcmp(buf1, buf2, 512);\n    for(i = 1; i < n; i++) {\n        buf1 += 512;\n        buf2 += 512;\n\n        if (!!memcmp(buf1, buf2, 512) != res) {\n            break;\n        }\n    }\n\n    *pnum = i;\n    return res;\n}\n\n#define IO_BUF_SIZE (2 * 1024 * 1024)\n\nstatic int64_t sectors_to_bytes(int64_t sectors)\n{\n    return sectors << BDRV_SECTOR_BITS;\n}\n\nstatic int64_t sectors_to_process(int64_t total, int64_t from)\n{\n    return MIN(total - from, IO_BUF_SIZE >> BDRV_SECTOR_BITS);\n}\n\n/*\n * Check if passed sectors are empty (not allocated or contain only 0 bytes)\n *\n * Returns 0 in case sectors are filled with 0, 1 if sectors contain non-zero\n * data and negative value on error.\n *\n * @param blk:  BlockBackend for the image\n * @param sect_num: Number of first sector to check\n * @param sect_count: Number of sectors to check\n * @param filename: Name of disk file we are checking (logging purpose)\n * @param buffer: Allocated buffer for storing read data\n * @param quiet: Flag for quiet mode\n */\nstatic int check_empty_sectors(BlockBackend *blk, int64_t sect_num,\n                               int sect_count, const char *filename,\n                               uint8_t *buffer, bool quiet)\n{\n    int pnum, ret = 0;\n    ret = blk_pread(blk, sect_num << BDRV_SECTOR_BITS, buffer,\n                    sect_count << BDRV_SECTOR_BITS);\n    if (ret < 0) {\n        error_report(\"Error while reading offset %\" PRId64 \" of %s: %s\",\n                     sectors_to_bytes(sect_num), filename, strerror(-ret));\n        return ret;\n    }\n    ret = is_allocated_sectors(buffer, sect_count, &pnum);\n    if (ret || pnum != sect_count) {\n        qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n                sectors_to_bytes(ret ? sect_num : sect_num + pnum));\n        return 1;\n    }\n\n    return 0;\n}\n\n/*\n * Compares two images. Exit codes:\n *\n * 0 - Images are identical\n * 1 - Images differ\n * >1 - Error occurred\n */\nstatic int img_compare(int argc, char **argv)\n{\n    const char *fmt1 = NULL, *fmt2 = NULL, *cache, *filename1, *filename2;\n    BlockBackend *blk1, *blk2;\n    BlockDriverState *bs1, *bs2;\n    int64_t total_sectors1, total_sectors2;\n    uint8_t *buf1 = NULL, *buf2 = NULL;\n    int pnum1, pnum2;\n    int allocated1, allocated2;\n    int ret = 0; /* return value - 0 Ident, 1 Different, >1 Error */\n    bool progress = false, quiet = false, strict = false;\n    int flags;\n    bool writethrough;\n    int64_t total_sectors;\n    int64_t sector_num = 0;\n    int64_t nb_sectors;\n    int c, pnum;\n    uint64_t progress_base;\n    bool image_opts = false;\n\n    cache = BDRV_DEFAULT_CACHE;\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:F:T:pqs\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt1 = optarg;\n            break;\n        case 'F':\n            fmt2 = optarg;\n            break;\n        case 'T':\n            cache = optarg;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 's':\n            strict = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                ret = 2;\n                goto out4;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    /* Progress is not shown in Quiet mode */\n    if (quiet) {\n        progress = false;\n    }\n\n\n    if (optind != argc - 2) {\n        error_exit(\"Expecting two image file names\");\n    }\n    filename1 = argv[optind++];\n    filename2 = argv[optind++];\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        ret = 2;\n        goto out4;\n    }\n\n    /* Initialize before goto out */\n    qemu_progress_init(progress, 2.0);\n\n    flags = 0;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", cache);\n        ret = 2;\n        goto out3;\n    }\n\n    blk1 = img_open(image_opts, filename1, fmt1, flags, writethrough, quiet);\n    if (!blk1) {\n        ret = 2;\n        goto out3;\n    }\n\n    blk2 = img_open(image_opts, filename2, fmt2, flags, writethrough, quiet);\n    if (!blk2) {\n        ret = 2;\n        goto out2;\n    }\n    bs1 = blk_bs(blk1);\n    bs2 = blk_bs(blk2);\n\n    buf1 = blk_blockalign(blk1, IO_BUF_SIZE);\n    buf2 = blk_blockalign(blk2, IO_BUF_SIZE);\n    total_sectors1 = blk_nb_sectors(blk1);\n    if (total_sectors1 < 0) {\n        error_report(\"Can't get size of %s: %s\",\n                     filename1, strerror(-total_sectors1));\n        ret = 4;\n        goto out;\n    }\n    total_sectors2 = blk_nb_sectors(blk2);\n    if (total_sectors2 < 0) {\n        error_report(\"Can't get size of %s: %s\",\n                     filename2, strerror(-total_sectors2));\n        ret = 4;\n        goto out;\n    }\n    total_sectors = MIN(total_sectors1, total_sectors2);\n    progress_base = MAX(total_sectors1, total_sectors2);\n\n    qemu_progress_print(0, 100);\n\n    if (strict && total_sectors1 != total_sectors2) {\n        ret = 1;\n        qprintf(quiet, \"Strict mode: Image size mismatch!\\n\");\n        goto out;\n    }\n\n    for (;;) {\n        int64_t status1, status2;\n        BlockDriverState *file;\n\n        nb_sectors = sectors_to_process(total_sectors, sector_num);\n        if (nb_sectors <= 0) {\n            break;\n        }\n        status1 = bdrv_get_block_status_above(bs1, NULL, sector_num,\n                                              total_sectors1 - sector_num,\n                                              &pnum1, &file);\n        if (status1 < 0) {\n            ret = 3;\n            error_report(\"Sector allocation test failed for %s\", filename1);\n            goto out;\n        }\n        allocated1 = status1 & BDRV_BLOCK_ALLOCATED;\n\n        status2 = bdrv_get_block_status_above(bs2, NULL, sector_num,\n                                              total_sectors2 - sector_num,\n                                              &pnum2, &file);\n        if (status2 < 0) {\n            ret = 3;\n            error_report(\"Sector allocation test failed for %s\", filename2);\n            goto out;\n        }\n        allocated2 = status2 & BDRV_BLOCK_ALLOCATED;\n        if (pnum1) {\n            nb_sectors = MIN(nb_sectors, pnum1);\n        }\n        if (pnum2) {\n            nb_sectors = MIN(nb_sectors, pnum2);\n        }\n\n        if (strict) {\n            if ((status1 & ~BDRV_BLOCK_OFFSET_MASK) !=\n                (status2 & ~BDRV_BLOCK_OFFSET_MASK)) {\n                ret = 1;\n                qprintf(quiet, \"Strict mode: Offset %\" PRId64\n                        \" block status mismatch!\\n\",\n                        sectors_to_bytes(sector_num));\n                goto out;\n            }\n        }\n        if ((status1 & BDRV_BLOCK_ZERO) && (status2 & BDRV_BLOCK_ZERO)) {\n            nb_sectors = MIN(pnum1, pnum2);\n        } else if (allocated1 == allocated2) {\n            if (allocated1) {\n                ret = blk_pread(blk1, sector_num << BDRV_SECTOR_BITS, buf1,\n                                nb_sectors << BDRV_SECTOR_BITS);\n                if (ret < 0) {\n                    error_report(\"Error while reading offset %\" PRId64 \" of %s:\"\n                                 \" %s\", sectors_to_bytes(sector_num), filename1,\n                                 strerror(-ret));\n                    ret = 4;\n                    goto out;\n                }\n                ret = blk_pread(blk2, sector_num << BDRV_SECTOR_BITS, buf2,\n                                nb_sectors << BDRV_SECTOR_BITS);\n                if (ret < 0) {\n                    error_report(\"Error while reading offset %\" PRId64\n                                 \" of %s: %s\", sectors_to_bytes(sector_num),\n                                 filename2, strerror(-ret));\n                    ret = 4;\n                    goto out;\n                }\n                ret = compare_sectors(buf1, buf2, nb_sectors, &pnum);\n                if (ret || pnum != nb_sectors) {\n                    qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n                            sectors_to_bytes(\n                                ret ? sector_num : sector_num + pnum));\n                    ret = 1;\n                    goto out;\n                }\n            }\n        } else {\n\n            if (allocated1) {\n                ret = check_empty_sectors(blk1, sector_num, nb_sectors,\n                                          filename1, buf1, quiet);\n            } else {\n                ret = check_empty_sectors(blk2, sector_num, nb_sectors,\n                                          filename2, buf1, quiet);\n            }\n            if (ret) {\n                if (ret < 0) {\n                    error_report(\"Error while reading offset %\" PRId64 \": %s\",\n                                 sectors_to_bytes(sector_num), strerror(-ret));\n                    ret = 4;\n                }\n                goto out;\n            }\n        }\n        sector_num += nb_sectors;\n        qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n    }\n\n    if (total_sectors1 != total_sectors2) {\n        BlockBackend *blk_over;\n        int64_t total_sectors_over;\n        const char *filename_over;\n\n        qprintf(quiet, \"Warning: Image size mismatch!\\n\");\n        if (total_sectors1 > total_sectors2) {\n            total_sectors_over = total_sectors1;\n            blk_over = blk1;\n            filename_over = filename1;\n        } else {\n            total_sectors_over = total_sectors2;\n            blk_over = blk2;\n            filename_over = filename2;\n        }\n\n        for (;;) {\n            nb_sectors = sectors_to_process(total_sectors_over, sector_num);\n            if (nb_sectors <= 0) {\n                break;\n            }\n            ret = bdrv_is_allocated_above(blk_bs(blk_over), NULL, sector_num,\n                                          nb_sectors, &pnum);\n            if (ret < 0) {\n                ret = 3;\n                error_report(\"Sector allocation test failed for %s\",\n                             filename_over);\n                goto out;\n\n            }\n            nb_sectors = pnum;\n            if (ret) {\n                ret = check_empty_sectors(blk_over, sector_num, nb_sectors,\n                                          filename_over, buf1, quiet);\n                if (ret) {\n                    if (ret < 0) {\n                        error_report(\"Error while reading offset %\" PRId64\n                                     \" of %s: %s\", sectors_to_bytes(sector_num),\n                                     filename_over, strerror(-ret));\n                        ret = 4;\n                    }\n                    goto out;\n                }\n            }\n            sector_num += nb_sectors;\n            qemu_progress_print(((float) nb_sectors / progress_base)*100, 100);\n        }\n    }\n\n    qprintf(quiet, \"Images are identical.\\n\");\n    ret = 0;\n\nout:\n    qemu_vfree(buf1);\n    qemu_vfree(buf2);\n    blk_unref(blk2);\nout2:\n    blk_unref(blk1);\nout3:\n    qemu_progress_end();\nout4:\n    return ret;\n}\n\nenum ImgConvertBlockStatus {\n    BLK_DATA,\n    BLK_ZERO,\n    BLK_BACKING_FILE,\n};\n\n#define MAX_COROUTINES 16\n\ntypedef struct ImgConvertState {\n    BlockBackend **src;\n    int64_t *src_sectors;\n    int src_num;\n    int64_t total_sectors;\n    int64_t allocated_sectors;\n    int64_t allocated_done;\n    int64_t sector_num;\n    int64_t wr_offs;\n    enum ImgConvertBlockStatus status;\n    int64_t sector_next_status;\n    BlockBackend *target;\n    bool has_zero_init;\n    bool compressed;\n    bool target_has_backing;\n    bool wr_in_order;\n    int min_sparse;\n    size_t cluster_sectors;\n    size_t buf_sectors;\n    int num_coroutines;\n    int running_coroutines;\n    Coroutine *co[MAX_COROUTINES];\n    int64_t wait_sector_num[MAX_COROUTINES];\n    CoMutex lock;\n    int ret;\n} ImgConvertState;\n\nstatic void convert_select_part(ImgConvertState *s, int64_t sector_num,\n                                int *src_cur, int64_t *src_cur_offset)\n{\n    *src_cur = 0;\n    *src_cur_offset = 0;\n    while (sector_num - *src_cur_offset >= s->src_sectors[*src_cur]) {\n        *src_cur_offset += s->src_sectors[*src_cur];\n        (*src_cur)++;\n        assert(*src_cur < s->src_num);\n    }\n}\n\nstatic int convert_iteration_sectors(ImgConvertState *s, int64_t sector_num)\n{\n    int64_t ret, src_cur_offset;\n    int n, src_cur;\n\n    convert_select_part(s, sector_num, &src_cur, &src_cur_offset);\n\n    assert(s->total_sectors > sector_num);\n    n = MIN(s->total_sectors - sector_num, BDRV_REQUEST_MAX_SECTORS);\n\n    if (s->sector_next_status <= sector_num) {\n        BlockDriverState *file;\n        ret = bdrv_get_block_status(blk_bs(s->src[src_cur]),\n                                    sector_num - src_cur_offset,\n                                    n, &n, &file);\n        if (ret < 0) {\n            return ret;\n        }\n\n        if (ret & BDRV_BLOCK_ZERO) {\n            s->status = BLK_ZERO;\n        } else if (ret & BDRV_BLOCK_DATA) {\n            s->status = BLK_DATA;\n        } else if (!s->target_has_backing) {\n            /* Without a target backing file we must copy over the contents of\n             * the backing file as well. */\n            /* Check block status of the backing file chain to avoid\n             * needlessly reading zeroes and limiting the iteration to the\n             * buffer size */\n            ret = bdrv_get_block_status_above(blk_bs(s->src[src_cur]), NULL,\n                                              sector_num - src_cur_offset,\n                                              n, &n, &file);\n            if (ret < 0) {\n                return ret;\n            }\n\n            if (ret & BDRV_BLOCK_ZERO) {\n                s->status = BLK_ZERO;\n            } else {\n                s->status = BLK_DATA;\n            }\n        } else {\n            s->status = BLK_BACKING_FILE;\n        }\n\n        s->sector_next_status = sector_num + n;\n    }\n\n    n = MIN(n, s->sector_next_status - sector_num);\n    if (s->status == BLK_DATA) {\n        n = MIN(n, s->buf_sectors);\n    }\n\n    /* We need to write complete clusters for compressed images, so if an\n     * unallocated area is shorter than that, we must consider the whole\n     * cluster allocated. */\n    if (s->compressed) {\n        if (n < s->cluster_sectors) {\n            n = MIN(s->cluster_sectors, s->total_sectors - sector_num);\n            s->status = BLK_DATA;\n        } else {\n            n = QEMU_ALIGN_DOWN(n, s->cluster_sectors);\n        }\n    }\n\n    return n;\n}\n\nstatic int coroutine_fn convert_co_read(ImgConvertState *s, int64_t sector_num,\n                                        int nb_sectors, uint8_t *buf)\n{\n    int n, ret;\n    QEMUIOVector qiov;\n    struct iovec iov;\n\n    assert(nb_sectors <= s->buf_sectors);\n    while (nb_sectors > 0) {\n        BlockBackend *blk;\n        int src_cur;\n        int64_t bs_sectors, src_cur_offset;\n\n        /* In the case of compression with multiple source files, we can get a\n         * nb_sectors that spreads into the next part. So we must be able to\n         * read across multiple BDSes for one convert_read() call. */\n        convert_select_part(s, sector_num, &src_cur, &src_cur_offset);\n        blk = s->src[src_cur];\n        bs_sectors = s->src_sectors[src_cur];\n\n        n = MIN(nb_sectors, bs_sectors - (sector_num - src_cur_offset));\n        iov.iov_base = buf;\n        iov.iov_len = n << BDRV_SECTOR_BITS;\n        qemu_iovec_init_external(&qiov, &iov, 1);\n\n        ret = blk_co_preadv(\n                blk, (sector_num - src_cur_offset) << BDRV_SECTOR_BITS,\n                n << BDRV_SECTOR_BITS, &qiov, 0);\n        if (ret < 0) {\n            return ret;\n        }\n\n        sector_num += n;\n        nb_sectors -= n;\n        buf += n * BDRV_SECTOR_SIZE;\n    }\n\n    return 0;\n}\n\n\nstatic int coroutine_fn convert_co_write(ImgConvertState *s, int64_t sector_num,\n                                         int nb_sectors, uint8_t *buf,\n                                         enum ImgConvertBlockStatus status)\n{\n    int ret;\n    QEMUIOVector qiov;\n    struct iovec iov;\n\n    while (nb_sectors > 0) {\n        int n = nb_sectors;\n        switch (status) {\n        case BLK_BACKING_FILE:\n            /* If we have a backing file, leave clusters unallocated that are\n             * unallocated in the source image, so that the backing file is\n             * visible at the respective offset. */\n            assert(s->target_has_backing);\n            break;\n\n        case BLK_DATA:\n            /* We must always write compressed clusters as a whole, so don't\n             * try to find zeroed parts in the buffer. We can only save the\n             * write if the buffer is completely zeroed and we're allowed to\n             * keep the target sparse. */\n            if (s->compressed) {\n                if (s->has_zero_init && s->min_sparse &&\n                    buffer_is_zero(buf, n * BDRV_SECTOR_SIZE))\n                {\n                    assert(!s->target_has_backing);\n                    break;\n                }\n\n                iov.iov_base = buf;\n                iov.iov_len = n << BDRV_SECTOR_BITS;\n                qemu_iovec_init_external(&qiov, &iov, 1);\n\n                ret = blk_co_pwritev(s->target, sector_num << BDRV_SECTOR_BITS,\n                                     n << BDRV_SECTOR_BITS, &qiov,\n                                     BDRV_REQ_WRITE_COMPRESSED);\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n            }\n\n            /* If there is real non-zero data or we're told to keep the target\n             * fully allocated (-S 0), we must write it. Otherwise we can treat\n             * it as zero sectors. */\n            if (!s->min_sparse ||\n                is_allocated_sectors_min(buf, n, &n, s->min_sparse))\n            {\n                iov.iov_base = buf;\n                iov.iov_len = n << BDRV_SECTOR_BITS;\n                qemu_iovec_init_external(&qiov, &iov, 1);\n\n                ret = blk_co_pwritev(s->target, sector_num << BDRV_SECTOR_BITS,\n                                     n << BDRV_SECTOR_BITS, &qiov, 0);\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n            }\n            /* fall-through */\n\n        case BLK_ZERO:\n            if (s->has_zero_init) {\n                break;\n            }\n            ret = blk_co_pwrite_zeroes(s->target,\n                                       sector_num << BDRV_SECTOR_BITS,\n                                       n << BDRV_SECTOR_BITS, 0);\n            if (ret < 0) {\n                return ret;\n            }\n            break;\n        }\n\n        sector_num += n;\n        nb_sectors -= n;\n        buf += n * BDRV_SECTOR_SIZE;\n    }\n\n    return 0;\n}\n\nstatic void coroutine_fn convert_co_do_copy(void *opaque)\n{\n    ImgConvertState *s = opaque;\n    uint8_t *buf = NULL;\n    int ret, i;\n    int index = -1;\n\n    for (i = 0; i < s->num_coroutines; i++) {\n        if (s->co[i] == qemu_coroutine_self()) {\n            index = i;\n            break;\n        }\n    }\n    assert(index >= 0);\n\n    s->running_coroutines++;\n    buf = blk_blockalign(s->target, s->buf_sectors * BDRV_SECTOR_SIZE);\n\n    while (1) {\n        int n;\n        int64_t sector_num;\n        enum ImgConvertBlockStatus status;\n\n        qemu_co_mutex_lock(&s->lock);\n        if (s->ret != -EINPROGRESS || s->sector_num >= s->total_sectors) {\n            qemu_co_mutex_unlock(&s->lock);\n            break;\n        }\n        n = convert_iteration_sectors(s, s->sector_num);\n        if (n < 0) {\n            qemu_co_mutex_unlock(&s->lock);\n            s->ret = n;\n            break;\n        }\n        /* save current sector and allocation status to local variables */\n        sector_num = s->sector_num;\n        status = s->status;\n        if (!s->min_sparse && s->status == BLK_ZERO) {\n            n = MIN(n, s->buf_sectors);\n        }\n        /* increment global sector counter so that other coroutines can\n         * already continue reading beyond this request */\n        s->sector_num += n;\n        qemu_co_mutex_unlock(&s->lock);\n\n        if (status == BLK_DATA || (!s->min_sparse && status == BLK_ZERO)) {\n            s->allocated_done += n;\n            qemu_progress_print(100.0 * s->allocated_done /\n                                        s->allocated_sectors, 0);\n        }\n\n        if (status == BLK_DATA) {\n            ret = convert_co_read(s, sector_num, n, buf);\n            if (ret < 0) {\n                error_report(\"error while reading sector %\" PRId64\n                             \": %s\", sector_num, strerror(-ret));\n                s->ret = ret;\n            }\n        } else if (!s->min_sparse && status == BLK_ZERO) {\n            status = BLK_DATA;\n            memset(buf, 0x00, n * BDRV_SECTOR_SIZE);\n        }\n\n        if (s->wr_in_order) {\n            /* keep writes in order */\n            while (s->wr_offs != sector_num && s->ret == -EINPROGRESS) {\n                s->wait_sector_num[index] = sector_num;\n                qemu_coroutine_yield();\n            }\n            s->wait_sector_num[index] = -1;\n        }\n\n        if (s->ret == -EINPROGRESS) {\n            ret = convert_co_write(s, sector_num, n, buf, status);\n            if (ret < 0) {\n                error_report(\"error while writing sector %\" PRId64\n                             \": %s\", sector_num, strerror(-ret));\n                s->ret = ret;\n            }\n        }\n\n        if (s->wr_in_order) {\n            /* reenter the coroutine that might have waited\n             * for this write to complete */\n            s->wr_offs = sector_num + n;\n            for (i = 0; i < s->num_coroutines; i++) {\n                if (s->co[i] && s->wait_sector_num[i] == s->wr_offs) {\n                    /*\n                     * A -> B -> A cannot occur because A has\n                     * s->wait_sector_num[i] == -1 during A -> B.  Therefore\n                     * B will never enter A during this time window.\n                     */\n                    qemu_coroutine_enter(s->co[i]);\n                    break;\n                }\n            }\n        }\n    }\n\n    qemu_vfree(buf);\n    s->co[index] = NULL;\n    s->running_coroutines--;\n    if (!s->running_coroutines && s->ret == -EINPROGRESS) {\n        /* the convert job finished successfully */\n        s->ret = 0;\n    }\n}\n\nstatic int convert_do_copy(ImgConvertState *s)\n{\n    int ret, i, n;\n    int64_t sector_num = 0;\n\n    /* Check whether we have zero initialisation or can get it efficiently */\n    s->has_zero_init = s->min_sparse && !s->target_has_backing\n                     ? bdrv_has_zero_init(blk_bs(s->target))\n                     : false;\n\n    if (!s->has_zero_init && !s->target_has_backing &&\n        bdrv_can_write_zeroes_with_unmap(blk_bs(s->target)))\n    {\n        ret = blk_make_zero(s->target, BDRV_REQ_MAY_UNMAP);\n        if (ret == 0) {\n            s->has_zero_init = true;\n        }\n    }\n\n    /* Allocate buffer for copied data. For compressed images, only one cluster\n     * can be copied at a time. */\n    if (s->compressed) {\n        if (s->cluster_sectors <= 0 || s->cluster_sectors > s->buf_sectors) {\n            error_report(\"invalid cluster size\");\n            return -EINVAL;\n        }\n        s->buf_sectors = s->cluster_sectors;\n    }\n\n    while (sector_num < s->total_sectors) {\n        n = convert_iteration_sectors(s, sector_num);\n        if (n < 0) {\n            return n;\n        }\n        if (s->status == BLK_DATA || (!s->min_sparse && s->status == BLK_ZERO))\n        {\n            s->allocated_sectors += n;\n        }\n        sector_num += n;\n    }\n\n    /* Do the copy */\n    s->sector_next_status = 0;\n    s->ret = -EINPROGRESS;\n\n    qemu_co_mutex_init(&s->lock);\n    for (i = 0; i < s->num_coroutines; i++) {\n        s->co[i] = qemu_coroutine_create(convert_co_do_copy, s);\n        s->wait_sector_num[i] = -1;\n        qemu_coroutine_enter(s->co[i]);\n    }\n\n    while (s->running_coroutines) {\n        main_loop_wait(false);\n    }\n\n    if (s->compressed && !s->ret) {\n        /* signal EOF to align */\n        ret = blk_pwrite_compressed(s->target, 0, NULL, 0);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    return s->ret;\n}\n\nstatic int img_convert(int argc, char **argv)\n{\n    int c, bs_n, bs_i, compress, cluster_sectors, skip_create;\n    int64_t ret = 0;\n    int progress = 0, flags, src_flags;\n    bool writethrough, src_writethrough;\n    const char *fmt, *out_fmt, *cache, *src_cache, *out_baseimg, *out_filename;\n    BlockDriver *drv, *proto_drv;\n    BlockBackend **blk = NULL, *out_blk = NULL;\n    BlockDriverState **bs = NULL, *out_bs = NULL;\n    int64_t total_sectors;\n    int64_t *bs_sectors = NULL;\n    size_t bufsectors = IO_BUF_SIZE / BDRV_SECTOR_SIZE;\n    BlockDriverInfo bdi;\n    QemuOpts *opts = NULL;\n    QemuOptsList *create_opts = NULL;\n    const char *out_baseimg_param;\n    char *options = NULL;\n    const char *snapshot_name = NULL;\n    int min_sparse = 8; /* Need at least 4k of zeros for sparse detection */\n    bool quiet = false;\n    Error *local_err = NULL;\n    QemuOpts *sn_opts = NULL;\n    ImgConvertState state;\n    bool image_opts = false;\n    bool wr_in_order = true;\n    long num_coroutines = 8;\n\n    fmt = NULL;\n    out_fmt = \"raw\";\n    cache = \"unsafe\";\n    src_cache = BDRV_DEFAULT_CACHE;\n    out_baseimg = NULL;\n    compress = 0;\n    skip_create = 0;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:O:B:ce6o:s:l:S:pt:T:qnm:W\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'O':\n            out_fmt = optarg;\n            break;\n        case 'B':\n            out_baseimg = optarg;\n            break;\n        case 'c':\n            compress = 1;\n            break;\n        case 'e':\n            error_report(\"option -e is deprecated, please use \\'-o \"\n                  \"encryption\\' instead!\");\n            ret = -1;\n            goto fail_getopt;\n        case '6':\n            error_report(\"option -6 is deprecated, please use \\'-o \"\n                  \"compat6\\' instead!\");\n            ret = -1;\n            goto fail_getopt;\n        case 'o':\n            if (!is_valid_option_list(optarg)) {\n                error_report(\"Invalid option list: %s\", optarg);\n                ret = -1;\n                goto fail_getopt;\n            }\n            if (!options) {\n                options = g_strdup(optarg);\n            } else {\n                char *old_options = options;\n                options = g_strdup_printf(\"%s,%s\", options, optarg);\n                g_free(old_options);\n            }\n            break;\n        case 's':\n            snapshot_name = optarg;\n            break;\n        case 'l':\n            if (strstart(optarg, SNAPSHOT_OPT_BASE, NULL)) {\n                sn_opts = qemu_opts_parse_noisily(&internal_snapshot_opts,\n                                                  optarg, false);\n                if (!sn_opts) {\n                    error_report(\"Failed in parsing snapshot param '%s'\",\n                                 optarg);\n                    ret = -1;\n                    goto fail_getopt;\n                }\n            } else {\n                snapshot_name = optarg;\n            }\n            break;\n        case 'S':\n        {\n            int64_t sval;\n\n            sval = cvtnum(optarg);\n            if (sval < 0) {\n                error_report(\"Invalid minimum zero buffer size for sparse output specified\");\n                ret = -1;\n                goto fail_getopt;\n            }\n\n            min_sparse = sval / BDRV_SECTOR_SIZE;\n            break;\n        }\n        case 'p':\n            progress = 1;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'T':\n            src_cache = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 'n':\n            skip_create = 1;\n            break;\n        case 'm':\n            if (qemu_strtol(optarg, NULL, 0, &num_coroutines) ||\n                num_coroutines < 1 || num_coroutines > MAX_COROUTINES) {\n                error_report(\"Invalid number of coroutines. Allowed number of\"\n                             \" coroutines is between 1 and %d\", MAX_COROUTINES);\n                ret = -1;\n                goto fail_getopt;\n            }\n            break;\n        case 'W':\n            wr_in_order = false;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *object_opts;\n            object_opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                                  optarg, true);\n            if (!object_opts) {\n                ret = -1;\n                goto fail_getopt;\n            }\n            break;\n        }\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        ret = -1;\n        goto fail_getopt;\n    }\n\n    if (!wr_in_order && compress) {\n        error_report(\"Out of order write and compress are mutually exclusive\");\n        ret = -1;\n        goto fail_getopt;\n    }\n\n    /* Initialize before goto out */\n    if (quiet) {\n        progress = 0;\n    }\n    qemu_progress_init(progress, 1.0);\n\n    bs_n = argc - optind - 1;\n    out_filename = bs_n >= 1 ? argv[argc - 1] : NULL;\n\n    if (options && has_help_option(options)) {\n        ret = print_block_option_help(out_filename, out_fmt);\n        goto out;\n    }\n\n    if (bs_n < 1) {\n        error_exit(\"Must specify image file name\");\n    }\n\n\n    src_flags = 0;\n    ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", src_cache);\n        goto out;\n    }\n\n    qemu_progress_print(0, 100);\n\n    blk = g_new0(BlockBackend *, bs_n);\n    bs = g_new0(BlockDriverState *, bs_n);\n    bs_sectors = g_new(int64_t, bs_n);\n\n    total_sectors = 0;\n    for (bs_i = 0; bs_i < bs_n; bs_i++) {\n        blk[bs_i] = img_open(image_opts, argv[optind + bs_i],\n                             fmt, src_flags, src_writethrough, quiet);\n        if (!blk[bs_i]) {\n            ret = -1;\n            goto out;\n        }\n        bs[bs_i] = blk_bs(blk[bs_i]);\n        bs_sectors[bs_i] = blk_nb_sectors(blk[bs_i]);\n        if (bs_sectors[bs_i] < 0) {\n            error_report(\"Could not get size of %s: %s\",\n                         argv[optind + bs_i], strerror(-bs_sectors[bs_i]));\n            ret = -1;\n            goto out;\n        }\n        total_sectors += bs_sectors[bs_i];\n    }\n\n    if (sn_opts) {\n        bdrv_snapshot_load_tmp(bs[0],\n                               qemu_opt_get(sn_opts, SNAPSHOT_OPT_ID),\n                               qemu_opt_get(sn_opts, SNAPSHOT_OPT_NAME),\n                               &local_err);\n    } else if (snapshot_name != NULL) {\n        if (bs_n > 1) {\n            error_report(\"No support for concatenating multiple snapshot\");\n            ret = -1;\n            goto out;\n        }\n\n        bdrv_snapshot_load_tmp_by_id_or_name(bs[0], snapshot_name, &local_err);\n    }\n    if (local_err) {\n        error_reportf_err(local_err, \"Failed to load snapshot: \");\n        ret = -1;\n        goto out;\n    }\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(out_fmt);\n    if (!drv) {\n        error_report(\"Unknown file format '%s'\", out_fmt);\n        ret = -1;\n        goto out;\n    }\n\n    proto_drv = bdrv_find_protocol(out_filename, true, &local_err);\n    if (!proto_drv) {\n        error_report_err(local_err);\n        ret = -1;\n        goto out;\n    }\n\n    if (!skip_create) {\n        if (!drv->create_opts) {\n            error_report(\"Format driver '%s' does not support image creation\",\n                         drv->format_name);\n            ret = -1;\n            goto out;\n        }\n\n        if (!proto_drv->create_opts) {\n            error_report(\"Protocol driver '%s' does not support image creation\",\n                         proto_drv->format_name);\n            ret = -1;\n            goto out;\n        }\n\n        create_opts = qemu_opts_append(create_opts, drv->create_opts);\n        create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n        opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n        if (options) {\n            qemu_opts_do_parse(opts, options, NULL, &local_err);\n            if (local_err) {\n                error_report_err(local_err);\n                ret = -1;\n                goto out;\n            }\n        }\n\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE, total_sectors * 512,\n                            &error_abort);\n        ret = add_old_style_options(out_fmt, opts, out_baseimg, NULL);\n        if (ret < 0) {\n            goto out;\n        }\n    }\n\n    /* Get backing file name if -o backing_file was used */\n    out_baseimg_param = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n    if (out_baseimg_param) {\n        out_baseimg = out_baseimg_param;\n    }\n\n    if (bs_n > 1 && out_baseimg) {\n        error_report(\"Having a backing file for the target makes no sense when \"\n                     \"concatenating multiple input images\");\n        ret = -1;\n        goto out;\n    }\n\n    /* Check if compression is supported */\n    if (compress) {\n        bool encryption =\n            qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT, false);\n        const char *preallocation =\n            qemu_opt_get(opts, BLOCK_OPT_PREALLOC);\n\n        if (!drv->bdrv_co_pwritev_compressed) {\n            error_report(\"Compression not supported for this file format\");\n            ret = -1;\n            goto out;\n        }\n\n        if (encryption) {\n            error_report(\"Compression and encryption not supported at \"\n                         \"the same time\");\n            ret = -1;\n            goto out;\n        }\n\n        if (preallocation\n            && strcmp(preallocation, \"off\"))\n        {\n            error_report(\"Compression and preallocation not supported at \"\n                         \"the same time\");\n            ret = -1;\n            goto out;\n        }\n    }\n\n    if (!skip_create) {\n        /* Create the new image */\n        ret = bdrv_create(drv, out_filename, opts, &local_err);\n        if (ret < 0) {\n            error_reportf_err(local_err, \"%s: error while converting %s: \",\n                              out_filename, out_fmt);\n            goto out;\n        }\n    }\n\n    flags = min_sparse ? (BDRV_O_RDWR | BDRV_O_UNMAP) : BDRV_O_RDWR;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    /* XXX we should allow --image-opts to trigger use of\n     * img_open() here, but then we have trouble with\n     * the bdrv_create() call which takes different params.\n     * Not critical right now, so fix can wait...\n     */\n    out_blk = img_open_file(out_filename, out_fmt, flags, writethrough, quiet);\n    if (!out_blk) {\n        ret = -1;\n        goto out;\n    }\n    out_bs = blk_bs(out_blk);\n\n    /* increase bufsectors from the default 4096 (2M) if opt_transfer\n     * or discard_alignment of the out_bs is greater. Limit to 32768 (16MB)\n     * as maximum. */\n    bufsectors = MIN(32768,\n                     MAX(bufsectors,\n                         MAX(out_bs->bl.opt_transfer >> BDRV_SECTOR_BITS,\n                             out_bs->bl.pdiscard_alignment >>\n                             BDRV_SECTOR_BITS)));\n\n    if (skip_create) {\n        int64_t output_sectors = blk_nb_sectors(out_blk);\n        if (output_sectors < 0) {\n            error_report(\"unable to get output image length: %s\",\n                         strerror(-output_sectors));\n            ret = -1;\n            goto out;\n        } else if (output_sectors < total_sectors) {\n            error_report(\"output file is smaller than input file\");\n            ret = -1;\n            goto out;\n        }\n    }\n\n    cluster_sectors = 0;\n    ret = bdrv_get_info(out_bs, &bdi);\n    if (ret < 0) {\n        if (compress) {\n            error_report(\"could not get block driver info\");\n            goto out;\n        }\n    } else {\n        compress = compress || bdi.needs_compressed_writes;\n        cluster_sectors = bdi.cluster_size / BDRV_SECTOR_SIZE;\n    }\n\n    state = (ImgConvertState) {\n        .src                = blk,\n        .src_sectors        = bs_sectors,\n        .src_num            = bs_n,\n        .total_sectors      = total_sectors,\n        .target             = out_blk,\n        .compressed         = compress,\n        .target_has_backing = (bool) out_baseimg,\n        .min_sparse         = min_sparse,\n        .cluster_sectors    = cluster_sectors,\n        .buf_sectors        = bufsectors,\n        .wr_in_order        = wr_in_order,\n        .num_coroutines     = num_coroutines,\n    };\n    ret = convert_do_copy(&state);\n\nout:\n    if (!ret) {\n        qemu_progress_print(100, 0);\n    }\n    qemu_progress_end();\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    qemu_opts_del(sn_opts);\n    blk_unref(out_blk);\n    g_free(bs);\n    if (blk) {\n        for (bs_i = 0; bs_i < bs_n; bs_i++) {\n            blk_unref(blk[bs_i]);\n        }\n        g_free(blk);\n    }\n    g_free(bs_sectors);\nfail_getopt:\n    g_free(options);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\n\nstatic void dump_snapshots(BlockDriverState *bs)\n{\n    QEMUSnapshotInfo *sn_tab, *sn;\n    int nb_sns, i;\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n    if (nb_sns <= 0)\n        return;\n    printf(\"Snapshot list:\\n\");\n    bdrv_snapshot_dump(fprintf, stdout, NULL);\n    printf(\"\\n\");\n    for(i = 0; i < nb_sns; i++) {\n        sn = &sn_tab[i];\n        bdrv_snapshot_dump(fprintf, stdout, sn);\n        printf(\"\\n\");\n    }\n    g_free(sn_tab);\n}\n\nstatic void dump_json_image_info_list(ImageInfoList *list)\n{\n    QString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageInfoList(v, NULL, &list, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj);\n    assert(str != NULL);\n    printf(\"%s\\n\", qstring_get_str(str));\n    qobject_decref(obj);\n    visit_free(v);\n    QDECREF(str);\n}\n\nstatic void dump_json_image_info(ImageInfo *info)\n{\n    QString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageInfo(v, NULL, &info, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj);\n    assert(str != NULL);\n    printf(\"%s\\n\", qstring_get_str(str));\n    qobject_decref(obj);\n    visit_free(v);\n    QDECREF(str);\n}\n\nstatic void dump_human_image_info_list(ImageInfoList *list)\n{\n    ImageInfoList *elem;\n    bool delim = false;\n\n    for (elem = list; elem; elem = elem->next) {\n        if (delim) {\n            printf(\"\\n\");\n        }\n        delim = true;\n\n        bdrv_image_info_dump(fprintf, stdout, elem->value);\n    }\n}\n\nstatic gboolean str_equal_func(gconstpointer a, gconstpointer b)\n{\n    return strcmp(a, b) == 0;\n}\n\n/**\n * Open an image file chain and return an ImageInfoList\n *\n * @filename: topmost image filename\n * @fmt: topmost image format (may be NULL to autodetect)\n * @chain: true  - enumerate entire backing file chain\n *         false - only topmost image file\n *\n * Returns a list of ImageInfo objects or NULL if there was an error opening an\n * image file.  If there was an error a message will have been printed to\n * stderr.\n */\nstatic ImageInfoList *collect_image_info_list(bool image_opts,\n                                              const char *filename,\n                                              const char *fmt,\n                                              bool chain)\n{\n    ImageInfoList *head = NULL;\n    ImageInfoList **last = &head;\n    GHashTable *filenames;\n    Error *err = NULL;\n\n    filenames = g_hash_table_new_full(g_str_hash, str_equal_func, NULL, NULL);\n\n    while (filename) {\n        BlockBackend *blk;\n        BlockDriverState *bs;\n        ImageInfo *info;\n        ImageInfoList *elem;\n\n        if (g_hash_table_lookup_extended(filenames, filename, NULL, NULL)) {\n            error_report(\"Backing file '%s' creates an infinite loop.\",\n                         filename);\n            goto err;\n        }\n        g_hash_table_insert(filenames, (gpointer)filename, NULL);\n\n        blk = img_open(image_opts, filename, fmt,\n                       BDRV_O_NO_BACKING | BDRV_O_NO_IO, false, false);\n        if (!blk) {\n            goto err;\n        }\n        bs = blk_bs(blk);\n\n        bdrv_query_image_info(bs, &info, &err);\n        if (err) {\n            error_report_err(err);\n            blk_unref(blk);\n            goto err;\n        }\n\n        elem = g_new0(ImageInfoList, 1);\n        elem->value = info;\n        *last = elem;\n        last = &elem->next;\n\n        blk_unref(blk);\n\n        filename = fmt = NULL;\n        if (chain) {\n            if (info->has_full_backing_filename) {\n                filename = info->full_backing_filename;\n            } else if (info->has_backing_filename) {\n                error_report(\"Could not determine absolute backing filename,\"\n                             \" but backing filename '%s' present\",\n                             info->backing_filename);\n                goto err;\n            }\n            if (info->has_backing_filename_format) {\n                fmt = info->backing_filename_format;\n            }\n        }\n    }\n    g_hash_table_destroy(filenames);\n    return head;\n\nerr:\n    qapi_free_ImageInfoList(head);\n    g_hash_table_destroy(filenames);\n    return NULL;\n}\n\nstatic int img_info(int argc, char **argv)\n{\n    int c;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    bool chain = false;\n    const char *filename, *fmt, *output;\n    ImageInfoList *list;\n    bool image_opts = false;\n\n    fmt = NULL;\n    output = NULL;\n    for(;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"backing-chain\", no_argument, 0, OPTION_BACKING_CHAIN},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:h\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case OPTION_BACKING_CHAIN:\n            chain = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    list = collect_image_info_list(image_opts, filename, fmt, chain);\n    if (!list) {\n        return 1;\n    }\n\n    switch (output_format) {\n    case OFORMAT_HUMAN:\n        dump_human_image_info_list(list);\n        break;\n    case OFORMAT_JSON:\n        if (chain) {\n            dump_json_image_info_list(list);\n        } else {\n            dump_json_image_info(list->value);\n        }\n        break;\n    }\n\n    qapi_free_ImageInfoList(list);\n    return 0;\n}\n\nstatic void dump_map_entry(OutputFormat output_format, MapEntry *e,\n                           MapEntry *next)\n{\n    switch (output_format) {\n    case OFORMAT_HUMAN:\n        if (e->data && !e->has_offset) {\n            error_report(\"File contains external, encrypted or compressed clusters.\");\n            exit(1);\n        }\n        if (e->data && !e->zero) {\n            printf(\"%#-16\"PRIx64\"%#-16\"PRIx64\"%#-16\"PRIx64\"%s\\n\",\n                   e->start, e->length,\n                   e->has_offset ? e->offset : 0,\n                   e->has_filename ? e->filename : \"\");\n        }\n        /* This format ignores the distinction between 0, ZERO and ZERO|DATA.\n         * Modify the flags here to allow more coalescing.\n         */\n        if (next && (!next->data || next->zero)) {\n            next->data = false;\n            next->zero = true;\n        }\n        break;\n    case OFORMAT_JSON:\n        printf(\"%s{ \\\"start\\\": %\"PRId64\", \\\"length\\\": %\"PRId64\",\"\n               \" \\\"depth\\\": %\"PRId64\", \\\"zero\\\": %s, \\\"data\\\": %s\",\n               (e->start == 0 ? \"[\" : \",\\n\"),\n               e->start, e->length, e->depth,\n               e->zero ? \"true\" : \"false\",\n               e->data ? \"true\" : \"false\");\n        if (e->has_offset) {\n            printf(\", \\\"offset\\\": %\"PRId64\"\", e->offset);\n        }\n        putchar('}');\n\n        if (!next) {\n            printf(\"]\\n\");\n        }\n        break;\n    }\n}\n\nstatic int get_block_status(BlockDriverState *bs, int64_t sector_num,\n                            int nb_sectors, MapEntry *e)\n{\n    int64_t ret;\n    int depth;\n    BlockDriverState *file;\n    bool has_offset;\n\n    /* As an optimization, we could cache the current range of unallocated\n     * clusters in each file of the chain, and avoid querying the same\n     * range repeatedly.\n     */\n\n    depth = 0;\n    for (;;) {\n        ret = bdrv_get_block_status(bs, sector_num, nb_sectors, &nb_sectors,\n                                    &file);\n        if (ret < 0) {\n            return ret;\n        }\n        assert(nb_sectors);\n        if (ret & (BDRV_BLOCK_ZERO|BDRV_BLOCK_DATA)) {\n            break;\n        }\n        bs = backing_bs(bs);\n        if (bs == NULL) {\n            ret = 0;\n            break;\n        }\n\n        depth++;\n    }\n\n    has_offset = !!(ret & BDRV_BLOCK_OFFSET_VALID);\n\n    *e = (MapEntry) {\n        .start = sector_num * BDRV_SECTOR_SIZE,\n        .length = nb_sectors * BDRV_SECTOR_SIZE,\n        .data = !!(ret & BDRV_BLOCK_DATA),\n        .zero = !!(ret & BDRV_BLOCK_ZERO),\n        .offset = ret & BDRV_BLOCK_OFFSET_MASK,\n        .has_offset = has_offset,\n        .depth = depth,\n        .has_filename = file && has_offset,\n        .filename = file && has_offset ? file->filename : NULL,\n    };\n\n    return 0;\n}\n\nstatic inline bool entry_mergeable(const MapEntry *curr, const MapEntry *next)\n{\n    if (curr->length == 0) {\n        return false;\n    }\n    if (curr->zero != next->zero ||\n        curr->data != next->data ||\n        curr->depth != next->depth ||\n        curr->has_filename != next->has_filename ||\n        curr->has_offset != next->has_offset) {\n        return false;\n    }\n    if (curr->has_filename && strcmp(curr->filename, next->filename)) {\n        return false;\n    }\n    if (curr->has_offset && curr->offset + curr->length != next->offset) {\n        return false;\n    }\n    return true;\n}\n\nstatic int img_map(int argc, char **argv)\n{\n    int c;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    const char *filename, *fmt, *output;\n    int64_t length;\n    MapEntry curr = { .length = 0 }, next;\n    int ret = 0;\n    bool image_opts = false;\n\n    fmt = NULL;\n    output = NULL;\n    for (;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:h\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, 0, false, false);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    if (output_format == OFORMAT_HUMAN) {\n        printf(\"%-16s%-16s%-16s%s\\n\", \"Offset\", \"Length\", \"Mapped to\", \"File\");\n    }\n\n    length = blk_getlength(blk);\n    while (curr.start + curr.length < length) {\n        int64_t nsectors_left;\n        int64_t sector_num;\n        int n;\n\n        sector_num = (curr.start + curr.length) >> BDRV_SECTOR_BITS;\n\n        /* Probe up to 1 GiB at a time.  */\n        nsectors_left = DIV_ROUND_UP(length, BDRV_SECTOR_SIZE) - sector_num;\n        n = MIN(1 << (30 - BDRV_SECTOR_BITS), nsectors_left);\n        ret = get_block_status(bs, sector_num, n, &next);\n\n        if (ret < 0) {\n            error_report(\"Could not read file metadata: %s\", strerror(-ret));\n            goto out;\n        }\n\n        if (entry_mergeable(&curr, &next)) {\n            curr.length += next.length;\n            continue;\n        }\n\n        if (curr.length > 0) {\n            dump_map_entry(output_format, &curr, &next);\n        }\n        curr = next;\n    }\n\n    dump_map_entry(output_format, &curr, NULL);\n\nout:\n    blk_unref(blk);\n    return ret < 0;\n}\n\n#define SNAPSHOT_LIST   1\n#define SNAPSHOT_CREATE 2\n#define SNAPSHOT_APPLY  3\n#define SNAPSHOT_DELETE 4\n\nstatic int img_snapshot(int argc, char **argv)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    QEMUSnapshotInfo sn;\n    char *filename, *snapshot_name = NULL;\n    int c, ret = 0, bdrv_oflags;\n    int action = 0;\n    qemu_timeval tv;\n    bool quiet = false;\n    Error *err = NULL;\n    bool image_opts = false;\n\n    bdrv_oflags = BDRV_O_RDWR;\n    /* Parse commandline parameters */\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":la:c:d:hq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            return 0;\n        case 'l':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_LIST;\n            bdrv_oflags &= ~BDRV_O_RDWR; /* no need for RW */\n            break;\n        case 'a':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_APPLY;\n            snapshot_name = optarg;\n            break;\n        case 'c':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_CREATE;\n            snapshot_name = optarg;\n            break;\n        case 'd':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_DELETE;\n            snapshot_name = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    /* Open the image */\n    blk = img_open(image_opts, filename, NULL, bdrv_oflags, false, quiet);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    /* Perform the requested action */\n    switch(action) {\n    case SNAPSHOT_LIST:\n        dump_snapshots(bs);\n        break;\n\n    case SNAPSHOT_CREATE:\n        memset(&sn, 0, sizeof(sn));\n        pstrcpy(sn.name, sizeof(sn.name), snapshot_name);\n\n        qemu_gettimeofday(&tv);\n        sn.date_sec = tv.tv_sec;\n        sn.date_nsec = tv.tv_usec * 1000;\n\n        ret = bdrv_snapshot_create(bs, &sn);\n        if (ret) {\n            error_report(\"Could not create snapshot '%s': %d (%s)\",\n                snapshot_name, ret, strerror(-ret));\n        }\n        break;\n\n    case SNAPSHOT_APPLY:\n        ret = bdrv_snapshot_goto(bs, snapshot_name);\n        if (ret) {\n            error_report(\"Could not apply snapshot '%s': %d (%s)\",\n                snapshot_name, ret, strerror(-ret));\n        }\n        break;\n\n    case SNAPSHOT_DELETE:\n        bdrv_snapshot_delete_by_id_or_name(bs, snapshot_name, &err);\n        if (err) {\n            error_reportf_err(err, \"Could not delete snapshot '%s': \",\n                              snapshot_name);\n            ret = 1;\n        }\n        break;\n    }\n\n    /* Cleanup */\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int img_rebase(int argc, char **argv)\n{\n    BlockBackend *blk = NULL, *blk_old_backing = NULL, *blk_new_backing = NULL;\n    uint8_t *buf_old = NULL;\n    uint8_t *buf_new = NULL;\n    BlockDriverState *bs = NULL;\n    char *filename;\n    const char *fmt, *cache, *src_cache, *out_basefmt, *out_baseimg;\n    int c, flags, src_flags, ret;\n    bool writethrough, src_writethrough;\n    int unsafe = 0;\n    int progress = 0;\n    bool quiet = false;\n    Error *local_err = NULL;\n    bool image_opts = false;\n\n    /* Parse commandline parameters */\n    fmt = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n    src_cache = BDRV_DEFAULT_CACHE;\n    out_baseimg = NULL;\n    out_basefmt = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:F:b:upt:T:q\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            return 0;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'F':\n            out_basefmt = optarg;\n            break;\n        case 'b':\n            out_baseimg = optarg;\n            break;\n        case 'u':\n            unsafe = 1;\n            break;\n        case 'p':\n            progress = 1;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'T':\n            src_cache = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (quiet) {\n        progress = 0;\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    if (!unsafe && !out_baseimg) {\n        error_exit(\"Must specify backing file (-b) or use unsafe mode (-u)\");\n    }\n    filename = argv[optind++];\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    qemu_progress_init(progress, 2.0);\n    qemu_progress_print(0, 100);\n\n    flags = BDRV_O_RDWR | (unsafe ? BDRV_O_NO_BACKING : 0);\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    src_flags = 0;\n    ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", src_cache);\n        goto out;\n    }\n\n    /* The source files are opened read-only, don't care about WCE */\n    assert((src_flags & BDRV_O_RDWR) == 0);\n    (void) src_writethrough;\n\n    /*\n     * Open the images.\n     *\n     * Ignore the old backing file for unsafe rebase in case we want to correct\n     * the reference to a renamed or moved backing file.\n     */\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n    bs = blk_bs(blk);\n\n    if (out_basefmt != NULL) {\n        if (bdrv_find_format(out_basefmt) == NULL) {\n            error_report(\"Invalid format name: '%s'\", out_basefmt);\n            ret = -1;\n            goto out;\n        }\n    }\n\n    /* For safe rebasing we need to compare old and new backing file */\n    if (!unsafe) {\n        char backing_name[PATH_MAX];\n        QDict *options = NULL;\n\n        if (bs->backing_format[0] != '\\0') {\n            options = qdict_new();\n            qdict_put_str(options, \"driver\", bs->backing_format);\n        }\n\n        bdrv_get_backing_filename(bs, backing_name, sizeof(backing_name));\n        blk_old_backing = blk_new_open(backing_name, NULL,\n                                       options, src_flags, &local_err);\n        if (!blk_old_backing) {\n            error_reportf_err(local_err,\n                              \"Could not open old backing file '%s': \",\n                              backing_name);\n            ret = -1;\n            goto out;\n        }\n\n        if (out_baseimg[0]) {\n            if (out_basefmt) {\n                options = qdict_new();\n                qdict_put_str(options, \"driver\", out_basefmt);\n            } else {\n                options = NULL;\n            }\n\n            blk_new_backing = blk_new_open(out_baseimg, NULL,\n                                           options, src_flags, &local_err);\n            if (!blk_new_backing) {\n                error_reportf_err(local_err,\n                                  \"Could not open new backing file '%s': \",\n                                  out_baseimg);\n                ret = -1;\n                goto out;\n            }\n        }\n    }\n\n    /*\n     * Check each unallocated cluster in the COW file. If it is unallocated,\n     * accesses go to the backing file. We must therefore compare this cluster\n     * in the old and new backing file, and if they differ we need to copy it\n     * from the old backing file into the COW file.\n     *\n     * If qemu-img crashes during this step, no harm is done. The content of\n     * the image is the same as the original one at any time.\n     */\n    if (!unsafe) {\n        int64_t num_sectors;\n        int64_t old_backing_num_sectors;\n        int64_t new_backing_num_sectors = 0;\n        uint64_t sector;\n        int n;\n        float local_progress = 0;\n\n        buf_old = blk_blockalign(blk, IO_BUF_SIZE);\n        buf_new = blk_blockalign(blk, IO_BUF_SIZE);\n\n        num_sectors = blk_nb_sectors(blk);\n        if (num_sectors < 0) {\n            error_report(\"Could not get size of '%s': %s\",\n                         filename, strerror(-num_sectors));\n            ret = -1;\n            goto out;\n        }\n        old_backing_num_sectors = blk_nb_sectors(blk_old_backing);\n        if (old_backing_num_sectors < 0) {\n            char backing_name[PATH_MAX];\n\n            bdrv_get_backing_filename(bs, backing_name, sizeof(backing_name));\n            error_report(\"Could not get size of '%s': %s\",\n                         backing_name, strerror(-old_backing_num_sectors));\n            ret = -1;\n            goto out;\n        }\n        if (blk_new_backing) {\n            new_backing_num_sectors = blk_nb_sectors(blk_new_backing);\n            if (new_backing_num_sectors < 0) {\n                error_report(\"Could not get size of '%s': %s\",\n                             out_baseimg, strerror(-new_backing_num_sectors));\n                ret = -1;\n                goto out;\n            }\n        }\n\n        if (num_sectors != 0) {\n            local_progress = (float)100 /\n                (num_sectors / MIN(num_sectors, IO_BUF_SIZE / 512));\n        }\n\n        for (sector = 0; sector < num_sectors; sector += n) {\n\n            /* How many sectors can we handle with the next read? */\n            if (sector + (IO_BUF_SIZE / 512) <= num_sectors) {\n                n = (IO_BUF_SIZE / 512);\n            } else {\n                n = num_sectors - sector;\n            }\n\n            /* If the cluster is allocated, we don't need to take action */\n            ret = bdrv_is_allocated(bs, sector, n, &n);\n            if (ret < 0) {\n                error_report(\"error while reading image metadata: %s\",\n                             strerror(-ret));\n                goto out;\n            }\n            if (ret) {\n                continue;\n            }\n\n            /*\n             * Read old and new backing file and take into consideration that\n             * backing files may be smaller than the COW image.\n             */\n            if (sector >= old_backing_num_sectors) {\n                memset(buf_old, 0, n * BDRV_SECTOR_SIZE);\n            } else {\n                if (sector + n > old_backing_num_sectors) {\n                    n = old_backing_num_sectors - sector;\n                }\n\n                ret = blk_pread(blk_old_backing, sector << BDRV_SECTOR_BITS,\n                                buf_old, n << BDRV_SECTOR_BITS);\n                if (ret < 0) {\n                    error_report(\"error while reading from old backing file\");\n                    goto out;\n                }\n            }\n\n            if (sector >= new_backing_num_sectors || !blk_new_backing) {\n                memset(buf_new, 0, n * BDRV_SECTOR_SIZE);\n            } else {\n                if (sector + n > new_backing_num_sectors) {\n                    n = new_backing_num_sectors - sector;\n                }\n\n                ret = blk_pread(blk_new_backing, sector << BDRV_SECTOR_BITS,\n                                buf_new, n << BDRV_SECTOR_BITS);\n                if (ret < 0) {\n                    error_report(\"error while reading from new backing file\");\n                    goto out;\n                }\n            }\n\n            /* If they differ, we need to write to the COW file */\n            uint64_t written = 0;\n\n            while (written < n) {\n                int pnum;\n\n                if (compare_sectors(buf_old + written * 512,\n                    buf_new + written * 512, n - written, &pnum))\n                {\n                    ret = blk_pwrite(blk,\n                                     (sector + written) << BDRV_SECTOR_BITS,\n                                     buf_old + written * 512,\n                                     pnum << BDRV_SECTOR_BITS, 0);\n                    if (ret < 0) {\n                        error_report(\"Error while writing to COW image: %s\",\n                            strerror(-ret));\n                        goto out;\n                    }\n                }\n\n                written += pnum;\n            }\n            qemu_progress_print(local_progress, 100);\n        }\n    }\n\n    /*\n     * Change the backing file. All clusters that are different from the old\n     * backing file are overwritten in the COW file now, so the visible content\n     * doesn't change when we switch the backing file.\n     */\n    if (out_baseimg && *out_baseimg) {\n        ret = bdrv_change_backing_file(bs, out_baseimg, out_basefmt);\n    } else {\n        ret = bdrv_change_backing_file(bs, NULL, NULL);\n    }\n\n    if (ret == -ENOSPC) {\n        error_report(\"Could not change the backing file to '%s': No \"\n                     \"space left in the file header\", out_baseimg);\n    } else if (ret < 0) {\n        error_report(\"Could not change the backing file to '%s': %s\",\n            out_baseimg, strerror(-ret));\n    }\n\n    qemu_progress_print(100, 0);\n    /*\n     * TODO At this point it is possible to check if any clusters that are\n     * allocated in the COW file are the same in the backing file. If so, they\n     * could be dropped from the COW file. Don't do this before switching the\n     * backing file, in case of a crash this would lead to corruption.\n     */\nout:\n    qemu_progress_end();\n    /* Cleanup */\n    if (!unsafe) {\n        blk_unref(blk_old_backing);\n        blk_unref(blk_new_backing);\n    }\n    qemu_vfree(buf_old);\n    qemu_vfree(buf_new);\n\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int img_resize(int argc, char **argv)\n{\n    Error *err = NULL;\n    int c, ret, relative;\n    const char *filename, *fmt, *size;\n    int64_t n, total_size;\n    bool quiet = false;\n    BlockBackend *blk = NULL;\n    QemuOpts *param;\n\n    static QemuOptsList resize_options = {\n        .name = \"resize_options\",\n        .head = QTAILQ_HEAD_INITIALIZER(resize_options.head),\n        .desc = {\n            {\n                .name = BLOCK_OPT_SIZE,\n                .type = QEMU_OPT_SIZE,\n                .help = \"Virtual disk size\"\n            }, {\n                /* end of list */\n            }\n        },\n    };\n    bool image_opts = false;\n\n    /* Remove size from argv manually so that negative numbers are not treated\n     * as options by getopt. */\n    if (argc < 3) {\n        error_exit(\"Not enough arguments\");\n        return 1;\n    }\n\n    size = argv[--argc];\n\n    /* Parse getopt arguments */\n    fmt = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:hq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                return 1;\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        return 1;\n    }\n\n    /* Choose grow, shrink, or absolute resize mode */\n    switch (size[0]) {\n    case '+':\n        relative = 1;\n        size++;\n        break;\n    case '-':\n        relative = -1;\n        size++;\n        break;\n    default:\n        relative = 0;\n        break;\n    }\n\n    /* Parse size */\n    param = qemu_opts_create(&resize_options, NULL, 0, &error_abort);\n    qemu_opt_set(param, BLOCK_OPT_SIZE, size, &err);\n    if (err) {\n        error_report_err(err);\n        ret = -1;\n        qemu_opts_del(param);\n        goto out;\n    }\n    n = qemu_opt_get_size(param, BLOCK_OPT_SIZE, 0);\n    qemu_opts_del(param);\n\n    blk = img_open(image_opts, filename, fmt,\n                   BDRV_O_RDWR | BDRV_O_RESIZE, false, quiet);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n\n    if (relative) {\n        total_size = blk_getlength(blk) + n * relative;\n    } else {\n        total_size = n;\n    }\n    if (total_size <= 0) {\n        error_report(\"New image size must be positive\");\n        ret = -1;\n        goto out;\n    }\n\n    ret = blk_truncate(blk, total_size, &err);\n    if (!ret) {\n        qprintf(quiet, \"Image resized.\\n\");\n    } else {\n        error_report_err(err);\n    }\nout:\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic void amend_status_cb(BlockDriverState *bs,\n                            int64_t offset, int64_t total_work_size,\n                            void *opaque)\n{\n    qemu_progress_print(100.f * offset / total_work_size, 0);\n}\n\nstatic int img_amend(int argc, char **argv)\n{\n    Error *err = NULL;\n    int c, ret = 0;\n    char *options = NULL;\n    QemuOptsList *create_opts = NULL;\n    QemuOpts *opts = NULL;\n    const char *fmt = NULL, *filename, *cache;\n    int flags;\n    bool writethrough;\n    bool quiet = false, progress = false;\n    BlockBackend *blk = NULL;\n    BlockDriverState *bs = NULL;\n    bool image_opts = false;\n\n    cache = BDRV_DEFAULT_CACHE;\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":ho:f:t:pq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'o':\n            if (!is_valid_option_list(optarg)) {\n                error_report(\"Invalid option list: %s\", optarg);\n                ret = -1;\n                goto out_no_progress;\n            }\n            if (!options) {\n                options = g_strdup(optarg);\n            } else {\n                char *old_options = options;\n                options = g_strdup_printf(\"%s,%s\", options, optarg);\n                g_free(old_options);\n            }\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT:\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                ret = -1;\n                goto out_no_progress;\n            }\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (!options) {\n        error_exit(\"Must specify options (-o)\");\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        ret = -1;\n        goto out_no_progress;\n    }\n\n    if (quiet) {\n        progress = false;\n    }\n    qemu_progress_init(progress, 1.0);\n\n    filename = (optind == argc - 1) ? argv[argc - 1] : NULL;\n    if (fmt && has_help_option(options)) {\n        /* If a format is explicitly specified (and possibly no filename is\n         * given), print option help here */\n        ret = print_block_option_help(filename, fmt);\n        goto out;\n    }\n\n    if (optind != argc - 1) {\n        error_report(\"Expecting one image file name\");\n        ret = -1;\n        goto out;\n    }\n\n    flags = BDRV_O_RDWR;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n    bs = blk_bs(blk);\n\n    fmt = bs->drv->format_name;\n\n    if (has_help_option(options)) {\n        /* If the format was auto-detected, print option help here */\n        ret = print_block_option_help(filename, fmt);\n        goto out;\n    }\n\n    if (!bs->drv->create_opts) {\n        error_report(\"Format driver '%s' does not support any options to amend\",\n                     fmt);\n        ret = -1;\n        goto out;\n    }\n\n    create_opts = qemu_opts_append(create_opts, bs->drv->create_opts);\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n    qemu_opts_do_parse(opts, options, NULL, &err);\n    if (err) {\n        error_report_err(err);\n        ret = -1;\n        goto out;\n    }\n\n    /* In case the driver does not call amend_status_cb() */\n    qemu_progress_print(0.f, 0);\n    ret = bdrv_amend_options(bs, opts, &amend_status_cb, NULL);\n    qemu_progress_print(100.f, 0);\n    if (ret < 0) {\n        error_report(\"Error while amending options: %s\", strerror(-ret));\n        goto out;\n    }\n\nout:\n    qemu_progress_end();\n\nout_no_progress:\n    blk_unref(blk);\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    g_free(options);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\ntypedef struct BenchData {\n    BlockBackend *blk;\n    uint64_t image_size;\n    bool write;\n    int bufsize;\n    int step;\n    int nrreq;\n    int n;\n    int flush_interval;\n    bool drain_on_flush;\n    uint8_t *buf;\n    QEMUIOVector *qiov;\n\n    int in_flight;\n    bool in_flush;\n    uint64_t offset;\n} BenchData;\n\nstatic void bench_undrained_flush_cb(void *opaque, int ret)\n{\n    if (ret < 0) {\n        error_report(\"Failed flush request: %s\", strerror(-ret));\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void bench_cb(void *opaque, int ret)\n{\n    BenchData *b = opaque;\n    BlockAIOCB *acb;\n\n    if (ret < 0) {\n        error_report(\"Failed request: %s\", strerror(-ret));\n        exit(EXIT_FAILURE);\n    }\n\n    if (b->in_flush) {\n        /* Just finished a flush with drained queue: Start next requests */\n        assert(b->in_flight == 0);\n        b->in_flush = false;\n    } else if (b->in_flight > 0) {\n        int remaining = b->n - b->in_flight;\n\n        b->n--;\n        b->in_flight--;\n\n        /* Time for flush? Drain queue if requested, then flush */\n        if (b->flush_interval && remaining % b->flush_interval == 0) {\n            if (!b->in_flight || !b->drain_on_flush) {\n                BlockCompletionFunc *cb;\n\n                if (b->drain_on_flush) {\n                    b->in_flush = true;\n                    cb = bench_cb;\n                } else {\n                    cb = bench_undrained_flush_cb;\n                }\n\n                acb = blk_aio_flush(b->blk, cb, b);\n                if (!acb) {\n                    error_report(\"Failed to issue flush request\");\n                    exit(EXIT_FAILURE);\n                }\n            }\n            if (b->drain_on_flush) {\n                return;\n            }\n        }\n    }\n\n    while (b->n > b->in_flight && b->in_flight < b->nrreq) {\n        int64_t offset = b->offset;\n        /* blk_aio_* might look for completed I/Os and kick bench_cb\n         * again, so make sure this operation is counted by in_flight\n         * and b->offset is ready for the next submission.\n         */\n        b->in_flight++;\n        b->offset += b->step;\n        b->offset %= b->image_size;\n        if (b->write) {\n            acb = blk_aio_pwritev(b->blk, offset, b->qiov, 0, bench_cb, b);\n        } else {\n            acb = blk_aio_preadv(b->blk, offset, b->qiov, 0, bench_cb, b);\n        }\n        if (!acb) {\n            error_report(\"Failed to issue request\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\nstatic int img_bench(int argc, char **argv)\n{\n    int c, ret = 0;\n    const char *fmt = NULL, *filename;\n    bool quiet = false;\n    bool image_opts = false;\n    bool is_write = false;\n    int count = 75000;\n    int depth = 64;\n    int64_t offset = 0;\n    size_t bufsize = 4096;\n    int pattern = 0;\n    size_t step = 0;\n    int flush_interval = 0;\n    bool drain_on_flush = true;\n    int64_t image_size;\n    BlockBackend *blk = NULL;\n    BenchData data = {};\n    int flags = 0;\n    bool writethrough = false;\n    struct timeval t1, t2;\n    int i;\n\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"flush-interval\", required_argument, 0, OPTION_FLUSH_INTERVAL},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"pattern\", required_argument, 0, OPTION_PATTERN},\n            {\"no-drain\", no_argument, 0, OPTION_NO_DRAIN},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hc:d:f:no:qs:S:t:w\", long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'c':\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid request count specified\");\n                return 1;\n            }\n            count = res;\n            break;\n        }\n        case 'd':\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid queue depth specified\");\n                return 1;\n            }\n            depth = res;\n            break;\n        }\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'n':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 'o':\n        {\n            offset = cvtnum(optarg);\n            if (offset < 0) {\n                error_report(\"Invalid offset specified\");\n                return 1;\n            }\n            break;\n        }\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 's':\n        {\n            int64_t sval;\n\n            sval = cvtnum(optarg);\n            if (sval < 0 || sval > INT_MAX) {\n                error_report(\"Invalid buffer size specified\");\n                return 1;\n            }\n\n            bufsize = sval;\n            break;\n        }\n        case 'S':\n        {\n            int64_t sval;\n\n            sval = cvtnum(optarg);\n            if (sval < 0 || sval > INT_MAX) {\n                error_report(\"Invalid step size specified\");\n                return 1;\n            }\n\n            step = sval;\n            break;\n        }\n        case 't':\n            ret = bdrv_parse_cache_mode(optarg, &flags, &writethrough);\n            if (ret < 0) {\n                error_report(\"Invalid cache mode\");\n                ret = -1;\n                goto out;\n            }\n            break;\n        case 'w':\n            flags |= BDRV_O_RDWR;\n            is_write = true;\n            break;\n        case OPTION_PATTERN:\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > 0xff) {\n                error_report(\"Invalid pattern byte specified\");\n                return 1;\n            }\n            pattern = res;\n            break;\n        }\n        case OPTION_FLUSH_INTERVAL:\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid flush interval specified\");\n                return 1;\n            }\n            flush_interval = res;\n            break;\n        }\n        case OPTION_NO_DRAIN:\n            drain_on_flush = false;\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[argc - 1];\n\n    if (!is_write && flush_interval) {\n        error_report(\"--flush-interval is only available in write tests\");\n        ret = -1;\n        goto out;\n    }\n    if (flush_interval && flush_interval < depth) {\n        error_report(\"Flush interval can't be smaller than depth\");\n        ret = -1;\n        goto out;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n\n    image_size = blk_getlength(blk);\n    if (image_size < 0) {\n        ret = image_size;\n        goto out;\n    }\n\n    data = (BenchData) {\n        .blk            = blk,\n        .image_size     = image_size,\n        .bufsize        = bufsize,\n        .step           = step ?: bufsize,\n        .nrreq          = depth,\n        .n              = count,\n        .offset         = offset,\n        .write          = is_write,\n        .flush_interval = flush_interval,\n        .drain_on_flush = drain_on_flush,\n    };\n    printf(\"Sending %d %s requests, %d bytes each, %d in parallel \"\n           \"(starting at offset %\" PRId64 \", step size %d)\\n\",\n           data.n, data.write ? \"write\" : \"read\", data.bufsize, data.nrreq,\n           data.offset, data.step);\n    if (flush_interval) {\n        printf(\"Sending flush every %d requests\\n\", flush_interval);\n    }\n\n    data.buf = blk_blockalign(blk, data.nrreq * data.bufsize);\n    memset(data.buf, pattern, data.nrreq * data.bufsize);\n\n    data.qiov = g_new(QEMUIOVector, data.nrreq);\n    for (i = 0; i < data.nrreq; i++) {\n        qemu_iovec_init(&data.qiov[i], 1);\n        qemu_iovec_add(&data.qiov[i],\n                       data.buf + i * data.bufsize, data.bufsize);\n    }\n\n    gettimeofday(&t1, NULL);\n    bench_cb(&data, 0);\n\n    while (data.n > 0) {\n        main_loop_wait(false);\n    }\n    gettimeofday(&t2, NULL);\n\n    printf(\"Run completed in %3.3f seconds.\\n\",\n           (t2.tv_sec - t1.tv_sec)\n           + ((double)(t2.tv_usec - t1.tv_usec) / 1000000));\n\nout:\n    qemu_vfree(data.buf);\n    blk_unref(blk);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\n#define C_BS      01\n#define C_COUNT   02\n#define C_IF      04\n#define C_OF      010\n#define C_SKIP    020\n\nstruct DdInfo {\n    unsigned int flags;\n    int64_t count;\n};\n\nstruct DdIo {\n    int bsz;    /* Block size */\n    char *filename;\n    uint8_t *buf;\n    int64_t offset;\n};\n\nstruct DdOpts {\n    const char *name;\n    int (*f)(const char *, struct DdIo *, struct DdIo *, struct DdInfo *);\n    unsigned int flag;\n};\n\nstatic int img_dd_bs(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    int64_t res;\n\n    res = cvtnum(arg);\n\n    if (res <= 0 || res > INT_MAX) {\n        error_report(\"invalid number: '%s'\", arg);\n        return 1;\n    }\n    in->bsz = out->bsz = res;\n\n    return 0;\n}\n\nstatic int img_dd_count(const char *arg,\n                        struct DdIo *in, struct DdIo *out,\n                        struct DdInfo *dd)\n{\n    dd->count = cvtnum(arg);\n\n    if (dd->count < 0) {\n        error_report(\"invalid number: '%s'\", arg);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int img_dd_if(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    in->filename = g_strdup(arg);\n\n    return 0;\n}\n\nstatic int img_dd_of(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    out->filename = g_strdup(arg);\n\n    return 0;\n}\n\nstatic int img_dd_skip(const char *arg,\n                       struct DdIo *in, struct DdIo *out,\n                       struct DdInfo *dd)\n{\n    in->offset = cvtnum(arg);\n\n    if (in->offset < 0) {\n        error_report(\"invalid number: '%s'\", arg);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int img_dd(int argc, char **argv)\n{\n    int ret = 0;\n    char *arg = NULL;\n    char *tmp;\n    BlockDriver *drv = NULL, *proto_drv = NULL;\n    BlockBackend *blk1 = NULL, *blk2 = NULL;\n    QemuOpts *opts = NULL;\n    QemuOptsList *create_opts = NULL;\n    Error *local_err = NULL;\n    bool image_opts = false;\n    int c, i;\n    const char *out_fmt = \"raw\";\n    const char *fmt = NULL;\n    int64_t size = 0;\n    int64_t block_count = 0, out_pos, in_pos;\n    struct DdInfo dd = {\n        .flags = 0,\n        .count = 0,\n    };\n    struct DdIo in = {\n        .bsz = 512, /* Block size is by default 512 bytes */\n        .filename = NULL,\n        .buf = NULL,\n        .offset = 0\n    };\n    struct DdIo out = {\n        .bsz = 512,\n        .filename = NULL,\n        .buf = NULL,\n        .offset = 0\n    };\n\n    const struct DdOpts options[] = {\n        { \"bs\", img_dd_bs, C_BS },\n        { \"count\", img_dd_count, C_COUNT },\n        { \"if\", img_dd_if, C_IF },\n        { \"of\", img_dd_of, C_OF },\n        { \"skip\", img_dd_skip, C_SKIP },\n        { NULL, NULL, 0 }\n    };\n    const struct option long_options[] = {\n        { \"help\", no_argument, 0, 'h'},\n        { \"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n        { 0, 0, 0, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \":hf:O:\", long_options, NULL))) {\n        if (c == EOF) {\n            break;\n        }\n        switch (c) {\n        case 'O':\n            out_fmt = optarg;\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    for (i = optind; i < argc; i++) {\n        int j;\n        arg = g_strdup(argv[i]);\n\n        tmp = strchr(arg, '=');\n        if (tmp == NULL) {\n            error_report(\"unrecognized operand %s\", arg);\n            ret = -1;\n            goto out;\n        }\n\n        *tmp++ = '\\0';\n\n        for (j = 0; options[j].name != NULL; j++) {\n            if (!strcmp(arg, options[j].name)) {\n                break;\n            }\n        }\n        if (options[j].name == NULL) {\n            error_report(\"unrecognized operand %s\", arg);\n            ret = -1;\n            goto out;\n        }\n\n        if (options[j].f(tmp, &in, &out, &dd) != 0) {\n            ret = -1;\n            goto out;\n        }\n        dd.flags |= options[j].flag;\n        g_free(arg);\n        arg = NULL;\n    }\n\n    if (!(dd.flags & C_IF && dd.flags & C_OF)) {\n        error_report(\"Must specify both input and output files\");\n        ret = -1;\n        goto out;\n    }\n    blk1 = img_open(image_opts, in.filename, fmt, 0, false, false);\n\n    if (!blk1) {\n        ret = -1;\n        goto out;\n    }\n\n    drv = bdrv_find_format(out_fmt);\n    if (!drv) {\n        error_report(\"Unknown file format\");\n        ret = -1;\n        goto out;\n    }\n    proto_drv = bdrv_find_protocol(out.filename, true, &local_err);\n\n    if (!proto_drv) {\n        error_report_err(local_err);\n        ret = -1;\n        goto out;\n    }\n    if (!drv->create_opts) {\n        error_report(\"Format driver '%s' does not support image creation\",\n                     drv->format_name);\n        ret = -1;\n        goto out;\n    }\n    if (!proto_drv->create_opts) {\n        error_report(\"Protocol driver '%s' does not support image creation\",\n                     proto_drv->format_name);\n        ret = -1;\n        goto out;\n    }\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n\n    size = blk_getlength(blk1);\n    if (size < 0) {\n        error_report(\"Failed to get size for '%s'\", in.filename);\n        ret = -1;\n        goto out;\n    }\n\n    if (dd.flags & C_COUNT && dd.count <= INT64_MAX / in.bsz &&\n        dd.count * in.bsz < size) {\n        size = dd.count * in.bsz;\n    }\n\n    /* Overflow means the specified offset is beyond input image's size */\n    if (dd.flags & C_SKIP && (in.offset > INT64_MAX / in.bsz ||\n                              size < in.bsz * in.offset)) {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE, 0, &error_abort);\n    } else {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE,\n                            size - in.bsz * in.offset, &error_abort);\n    }\n\n    ret = bdrv_create(drv, out.filename, opts, &local_err);\n    if (ret < 0) {\n        error_reportf_err(local_err,\n                          \"%s: error while creating output image: \",\n                          out.filename);\n        ret = -1;\n        goto out;\n    }\n\n    blk2 = img_open(image_opts, out.filename, out_fmt, BDRV_O_RDWR,\n                    false, false);\n\n    if (!blk2) {\n        ret = -1;\n        goto out;\n    }\n\n    if (dd.flags & C_SKIP && (in.offset > INT64_MAX / in.bsz ||\n                              size < in.offset * in.bsz)) {\n        /* We give a warning if the skip option is bigger than the input\n         * size and create an empty output disk image (i.e. like dd(1)).\n         */\n        error_report(\"%s: cannot skip to specified offset\", in.filename);\n        in_pos = size;\n    } else {\n        in_pos = in.offset * in.bsz;\n    }\n\n    in.buf = g_new(uint8_t, in.bsz);\n\n    for (out_pos = 0; in_pos < size; block_count++) {\n        int in_ret, out_ret;\n\n        if (in_pos + in.bsz > size) {\n            in_ret = blk_pread(blk1, in_pos, in.buf, size - in_pos);\n        } else {\n            in_ret = blk_pread(blk1, in_pos, in.buf, in.bsz);\n        }\n        if (in_ret < 0) {\n            error_report(\"error while reading from input image file: %s\",\n                         strerror(-in_ret));\n            ret = -1;\n            goto out;\n        }\n        in_pos += in_ret;\n\n        out_ret = blk_pwrite(blk2, out_pos, in.buf, in_ret, 0);\n\n        if (out_ret < 0) {\n            error_report(\"error while writing to output image file: %s\",\n                         strerror(-out_ret));\n            ret = -1;\n            goto out;\n        }\n        out_pos += out_ret;\n    }\n\nout:\n    g_free(arg);\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    blk_unref(blk1);\n    blk_unref(blk2);\n    g_free(in.filename);\n    g_free(out.filename);\n    g_free(in.buf);\n    g_free(out.buf);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\n\nstatic const img_cmd_t img_cmds[] = {\n#define DEF(option, callback, arg_string)        \\\n    { option, callback },\n#include \"qemu-img-cmds.h\"\n#undef DEF\n#undef GEN_DOCS\n    { NULL, NULL, },\n};\n\nint main(int argc, char **argv)\n{\n    const img_cmd_t *cmd;\n    const char *cmdname;\n    Error *local_error = NULL;\n    char *trace_file = NULL;\n    int c;\n    static const struct option long_options[] = {\n        {\"help\", no_argument, 0, 'h'},\n        {\"version\", no_argument, 0, 'V'},\n        {\"trace\", required_argument, NULL, 'T'},\n        {0, 0, 0, 0}\n    };\n\n#ifdef CONFIG_POSIX\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n    module_call_init(MODULE_INIT_TRACE);\n    error_set_progname(argv[0]);\n    qemu_init_exec_dir(argv[0]);\n\n    if (qemu_init_main_loop(&local_error)) {\n        error_report_err(local_error);\n        exit(EXIT_FAILURE);\n    }\n\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    bdrv_init();\n    if (argc < 2) {\n        error_exit(\"Not enough arguments\");\n    }\n\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_source_opts);\n    qemu_add_opts(&qemu_trace_opts);\n\n    while ((c = getopt_long(argc, argv, \"+:hVT:\", long_options, NULL)) != -1) {\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            return 0;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            return 0;\n        case 'h':\n            help();\n            return 0;\n        case 'V':\n            printf(QEMU_IMG_VERSION);\n            return 0;\n        case 'T':\n            g_free(trace_file);\n            trace_file = trace_opt_parse(optarg);\n            break;\n        }\n    }\n\n    cmdname = argv[optind];\n\n    /* reset getopt_long scanning */\n    argc -= optind;\n    if (argc < 1) {\n        return 0;\n    }\n    argv += optind;\n    optind = 0;\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file(trace_file);\n    qemu_set_log(LOG_TRACE);\n\n    /* find the command */\n    for (cmd = img_cmds; cmd->name != NULL; cmd++) {\n        if (!strcmp(cmdname, cmd->name)) {\n            return cmd->handler(argc, argv);\n        }\n    }\n\n    /* not found */\n    error_exit(\"Command not found: %s\", cmdname);\n}\n"
        },
        {
          "name": "qemu-img.texi",
          "type": "blob",
          "size": 25.701171875,
          "content": "@example\n@c man begin SYNOPSIS\n@command{qemu-img} [@var{standard} @var{options}] @var{command} [@var{command} @var{options}]\n@c man end\n@end example\n\n@c man begin DESCRIPTION\nqemu-img allows you to create, convert and modify images offline. It can handle\nall image formats supported by QEMU.\n\n@b{Warning:} Never use qemu-img to modify images in use by a running virtual\nmachine or any other process; this may destroy the image. Also, be aware that\nquerying an image that is being modified by another process may encounter\ninconsistent state.\n@c man end\n\n@c man begin OPTIONS\n\nStandard options:\n@table @option\n@item -h, --help\nDisplay this help and exit\n@item -V, --version\nDisplay version information and exit\n@item -T, --trace [[enable=]@var{pattern}][,events=@var{file}][,file=@var{file}]\n@findex --trace\n@include qemu-option-trace.texi\n@end table\n\nThe following commands are supported:\n\n@include qemu-img-cmds.texi\n\nCommand parameters:\n@table @var\n@item filename\n is a disk image filename\n\n@item --object @var{objectdef}\n\nis a QEMU user creatable object definition. See the @code{qemu(1)} manual\npage for a description of the object properties. The most common object\ntype is a @code{secret}, which is used to supply passwords and/or encryption\nkeys.\n\n@item --image-opts\n\nIndicates that the @var{filename} parameter is to be interpreted as a\nfull option string, not a plain filename. This parameter is mutually\nexclusive with the @var{-f} and @var{-F} parameters.\n\n@item fmt\nis the disk image format. It is guessed automatically in most cases. See below\nfor a description of the supported disk formats.\n\n@item --backing-chain\nwill enumerate information about backing files in a disk image chain. Refer\nbelow for further description.\n\n@item size\nis the disk image size in bytes. Optional suffixes @code{k} or @code{K}\n(kilobyte, 1024) @code{M} (megabyte, 1024k) and @code{G} (gigabyte, 1024M)\nand T (terabyte, 1024G) are supported.  @code{b} is ignored.\n\n@item output_filename\nis the destination disk image filename\n\n@item output_fmt\n is the destination format\n@item options\nis a comma separated list of format specific options in a\nname=value format. Use @code{-o ?} for an overview of the options supported\nby the used format or see the format descriptions below for details.\n@item snapshot_param\nis param used for internal snapshot, format is\n'snapshot.id=[ID],snapshot.name=[NAME]' or '[ID_OR_NAME]'\n@item snapshot_id_or_name\nis deprecated, use snapshot_param instead\n\n@item -c\nindicates that target image must be compressed (qcow format only)\n@item -h\nwith or without a command shows help and lists the supported formats\n@item -p\ndisplay progress bar (compare, convert and rebase commands only).\nIf the @var{-p} option is not used for a command that supports it, the\nprogress is reported when the process receives a @code{SIGUSR1} signal.\n@item -q\nQuiet mode - do not print any output (except errors). There's no progress bar\nin case both @var{-q} and @var{-p} options are used.\n@item -S @var{size}\nindicates the consecutive number of bytes that must contain only zeros\nfor qemu-img to create a sparse image during conversion. This value is rounded\ndown to the nearest 512 bytes. You may use the common size suffixes like\n@code{k} for kilobytes.\n@item -t @var{cache}\nspecifies the cache mode that should be used with the (destination) file. See\nthe documentation of the emulator's @code{-drive cache=...} option for allowed\nvalues.\n@item -T @var{src_cache}\nspecifies the cache mode that should be used with the source file(s). See\nthe documentation of the emulator's @code{-drive cache=...} option for allowed\nvalues.\n@end table\n\nParameters to snapshot subcommand:\n\n@table @option\n\n@item snapshot\nis the name of the snapshot to create, apply or delete\n@item -a\napplies a snapshot (revert disk to saved state)\n@item -c\ncreates a snapshot\n@item -d\ndeletes a snapshot\n@item -l\nlists all snapshots in the given image\n@end table\n\nParameters to compare subcommand:\n\n@table @option\n\n@item -f\nFirst image format\n@item -F\nSecond image format\n@item -s\nStrict mode - fail on different image size or sector allocation\n@end table\n\nParameters to convert subcommand:\n\n@table @option\n\n@item -n\nSkip the creation of the target volume\n@item -m\nNumber of parallel coroutines for the convert process\n@item -W\nAllow out-of-order writes to the destination. This option improves performance,\nbut is only recommended for preallocated devices like host devices or other\nraw block devices.\n@end table\n\nParameters to dd subcommand:\n\n@table @option\n\n@item bs=@var{block_size}\ndefines the block size\n@item count=@var{blocks}\nsets the number of input blocks to copy\n@item if=@var{input}\nsets the input file\n@item of=@var{output}\nsets the output file\n@item skip=@var{blocks}\nsets the number of input blocks to skip\n@end table\n\nCommand description:\n\n@table @option\n@item bench [-c @var{count}] [-d @var{depth}] [-f @var{fmt}] [--flush-interval=@var{flush_interval}] [-n] [--no-drain] [-o @var{offset}] [--pattern=@var{pattern}] [-q] [-s @var{buffer_size}] [-S @var{step_size}] [-t @var{cache}] [-w] @var{filename}\n\nRun a simple sequential I/O benchmark on the specified image. If @code{-w} is\nspecified, a write test is performed, otherwise a read test is performed.\n\nA total number of @var{count} I/O requests is performed, each @var{buffer_size}\nbytes in size, and with @var{depth} requests in parallel. The first request\nstarts at the position given by @var{offset}, each following request increases\nthe current position by @var{step_size}. If @var{step_size} is not given,\n@var{buffer_size} is used for its value.\n\nIf @var{flush_interval} is specified for a write test, the request queue is\ndrained and a flush is issued before new writes are made whenever the number of\nremaining requests is a multiple of @var{flush_interval}. If additionally\n@code{--no-drain} is specified, a flush is issued without draining the request\nqueue first.\n\nIf @code{-n} is specified, the native AIO backend is used if possible. On\nLinux, this option only works if @code{-t none} or @code{-t directsync} is\nspecified as well.\n\nFor write tests, by default a buffer filled with zeros is written. This can be\noverridden with a pattern byte specified by @var{pattern}.\n\n@item check [-f @var{fmt}] [--output=@var{ofmt}] [-r [leaks | all]] [-T @var{src_cache}] @var{filename}\n\nPerform a consistency check on the disk image @var{filename}. The command can\noutput in the format @var{ofmt} which is either @code{human} or @code{json}.\n\nIf @code{-r} is specified, qemu-img tries to repair any inconsistencies found\nduring the check. @code{-r leaks} repairs only cluster leaks, whereas\n@code{-r all} fixes all kinds of errors, with a higher risk of choosing the\nwrong fix or hiding corruption that has already occurred.\n\nOnly the formats @code{qcow2}, @code{qed} and @code{vdi} support\nconsistency checks.\n\nIn case the image does not have any inconsistencies, check exits with @code{0}.\nOther exit codes indicate the kind of inconsistency found or if another error\noccurred. The following table summarizes all exit codes of the check subcommand:\n\n@table @option\n\n@item 0\nCheck completed, the image is (now) consistent\n@item 1\nCheck not completed because of internal errors\n@item 2\nCheck completed, image is corrupted\n@item 3\nCheck completed, image has leaked clusters, but is not corrupted\n@item 63\nChecks are not supported by the image format\n\n@end table\n\nIf @code{-r} is specified, exit codes representing the image state refer to the\nstate after (the attempt at) repairing it. That is, a successful @code{-r all}\nwill yield the exit code 0, independently of the image state before.\n\n@item create [-f @var{fmt}] [-o @var{options}] @var{filename} [@var{size}]\n\nCreate the new disk image @var{filename} of size @var{size} and format\n@var{fmt}. Depending on the file format, you can add one or more @var{options}\nthat enable additional features of this format.\n\nIf the option @var{backing_file} is specified, then the image will record\nonly the differences from @var{backing_file}. No size needs to be specified in\nthis case. @var{backing_file} will never be modified unless you use the\n@code{commit} monitor command (or qemu-img commit).\n\nThe size can also be specified using the @var{size} option with @code{-o},\nit doesn't need to be specified separately in this case.\n\n@item commit [-q] [-f @var{fmt}] [-t @var{cache}] [-b @var{base}] [-d] [-p] @var{filename}\n\nCommit the changes recorded in @var{filename} in its base image or backing file.\nIf the backing file is smaller than the snapshot, then the backing file will be\nresized to be the same size as the snapshot.  If the snapshot is smaller than\nthe backing file, the backing file will not be truncated.  If you want the\nbacking file to match the size of the smaller snapshot, you can safely truncate\nit yourself once the commit operation successfully completes.\n\nThe image @var{filename} is emptied after the operation has succeeded. If you do\nnot need @var{filename} afterwards and intend to drop it, you may skip emptying\n@var{filename} by specifying the @code{-d} flag.\n\nIf the backing chain of the given image file @var{filename} has more than one\nlayer, the backing file into which the changes will be committed may be\nspecified as @var{base} (which has to be part of @var{filename}'s backing\nchain). If @var{base} is not specified, the immediate backing file of the top\nimage (which is @var{filename}) will be used. For reasons of consistency,\nexplicitly specifying @var{base} will always imply @code{-d} (since emptying an\nimage after committing to an indirect backing file would lead to different data\nbeing read from the image due to content in the intermediate backing chain\noverruling the commit target).\n\n@item compare [-f @var{fmt}] [-F @var{fmt}] [-T @var{src_cache}] [-p] [-s] [-q] @var{filename1} @var{filename2}\n\nCheck if two images have the same content. You can compare images with\ndifferent format or settings.\n\nThe format is probed unless you specify it by @var{-f} (used for\n@var{filename1}) and/or @var{-F} (used for @var{filename2}) option.\n\nBy default, images with different size are considered identical if the larger\nimage contains only unallocated and/or zeroed sectors in the area after the end\nof the other image. In addition, if any sector is not allocated in one image\nand contains only zero bytes in the second one, it is evaluated as equal. You\ncan use Strict mode by specifying the @var{-s} option. When compare runs in\nStrict mode, it fails in case image size differs or a sector is allocated in\none image and is not allocated in the second one.\n\nBy default, compare prints out a result message. This message displays\ninformation that both images are same or the position of the first different\nbyte. In addition, result message can report different image size in case\nStrict mode is used.\n\nCompare exits with @code{0} in case the images are equal and with @code{1}\nin case the images differ. Other exit codes mean an error occurred during\nexecution and standard error output should contain an error message.\nThe following table sumarizes all exit codes of the compare subcommand:\n\n@table @option\n\n@item 0\nImages are identical\n@item 1\nImages differ\n@item 2\nError on opening an image\n@item 3\nError on checking a sector allocation\n@item 4\nError on reading data\n\n@end table\n\n@item convert [-c] [-p] [-n] [-f @var{fmt}] [-t @var{cache}] [-T @var{src_cache}] [-O @var{output_fmt}] [-o @var{options}] [-s @var{snapshot_id_or_name}] [-l @var{snapshot_param}] [-m @var{num_coroutines}] [-W] [-S @var{sparse_size}] @var{filename} [@var{filename2} [...]] @var{output_filename}\n\nConvert the disk image @var{filename} or a snapshot @var{snapshot_param}(@var{snapshot_id_or_name} is deprecated)\nto disk image @var{output_filename} using format @var{output_fmt}. It can be optionally compressed (@code{-c}\noption) or use any format specific options like encryption (@code{-o} option).\n\nOnly the formats @code{qcow} and @code{qcow2} support compression. The\ncompression is read-only. It means that if a compressed sector is\nrewritten, then it is rewritten as uncompressed data.\n\nImage conversion is also useful to get smaller image when using a\ngrowable format such as @code{qcow}: the empty sectors are detected and\nsuppressed from the destination image.\n\n@var{sparse_size} indicates the consecutive number of bytes (defaults to 4k)\nthat must contain only zeros for qemu-img to create a sparse image during\nconversion. If @var{sparse_size} is 0, the source will not be scanned for\nunallocated or zero sectors, and the destination image will always be\nfully allocated.\n\nYou can use the @var{backing_file} option to force the output image to be\ncreated as a copy on write image of the specified base image; the\n@var{backing_file} should have the same content as the input's base image,\nhowever the path, image format, etc may differ.\n\nIf the @code{-n} option is specified, the target volume creation will be\nskipped. This is useful for formats such as @code{rbd} if the target\nvolume has already been created with site specific options that cannot\nbe supplied through qemu-img.\n\nOut of order writes can be enabled with @code{-W} to improve performance.\nThis is only recommended for preallocated devices like host devices or other\nraw block devices. Out of order write does not work in combination with\ncreating compressed images.\n\n@var{num_coroutines} specifies how many coroutines work in parallel during\nthe convert process (defaults to 8).\n\n@item dd [-f @var{fmt}] [-O @var{output_fmt}] [bs=@var{block_size}] [count=@var{blocks}] [skip=@var{blocks}] if=@var{input} of=@var{output}\n\nDd copies from @var{input} file to @var{output} file converting it from\n@var{fmt} format to @var{output_fmt} format.\n\nThe data is by default read and written using blocks of 512 bytes but can be\nmodified by specifying @var{block_size}. If count=@var{blocks} is specified\ndd will stop reading input after reading @var{blocks} input blocks.\n\nThe size syntax is similar to dd(1)'s size syntax.\n\n@item info [-f @var{fmt}] [--output=@var{ofmt}] [--backing-chain] @var{filename}\n\nGive information about the disk image @var{filename}. Use it in\nparticular to know the size reserved on disk which can be different\nfrom the displayed size. If VM snapshots are stored in the disk image,\nthey are displayed too. The command can output in the format @var{ofmt}\nwhich is either @code{human} or @code{json}.\n\nIf a disk image has a backing file chain, information about each disk image in\nthe chain can be recursively enumerated by using the option @code{--backing-chain}.\n\nFor instance, if you have an image chain like:\n\n@example\nbase.qcow2 <- snap1.qcow2 <- snap2.qcow2\n@end example\n\nTo enumerate information about each disk image in the above chain, starting from top to base, do:\n\n@example\nqemu-img info --backing-chain snap2.qcow2\n@end example\n\n@item map [-f @var{fmt}] [--output=@var{ofmt}] @var{filename}\n\nDump the metadata of image @var{filename} and its backing file chain.\nIn particular, this commands dumps the allocation state of every sector\nof @var{filename}, together with the topmost file that allocates it in\nthe backing file chain.\n\nTwo option formats are possible.  The default format (@code{human})\nonly dumps known-nonzero areas of the file.  Known-zero parts of the\nfile are omitted altogether, and likewise for parts that are not allocated\nthroughout the chain.  @command{qemu-img} output will identify a file\nfrom where the data can be read, and the offset in the file.  Each line\nwill include four fields, the first three of which are hexadecimal\nnumbers.  For example the first line of:\n@example\nOffset          Length          Mapped to       File\n0               0x20000         0x50000         /tmp/overlay.qcow2\n0x100000        0x10000         0x95380000      /tmp/backing.qcow2\n@end example\n@noindent\nmeans that 0x20000 (131072) bytes starting at offset 0 in the image are\navailable in /tmp/overlay.qcow2 (opened in @code{raw} format) starting\nat offset 0x50000 (327680).  Data that is compressed, encrypted, or\notherwise not available in raw format will cause an error if @code{human}\nformat is in use.  Note that file names can include newlines, thus it is\nnot safe to parse this output format in scripts.\n\nThe alternative format @code{json} will return an array of dictionaries\nin JSON format.  It will include similar information in\nthe @code{start}, @code{length}, @code{offset} fields;\nit will also include other more specific information:\n@itemize @minus\n@item\nwhether the sectors contain actual data or not (boolean field @code{data};\nif false, the sectors are either unallocated or stored as optimized\nall-zero clusters);\n\n@item\nwhether the data is known to read as zero (boolean field @code{zero});\n\n@item\nin order to make the output shorter, the target file is expressed as\na @code{depth}; for example, a depth of 2 refers to the backing file\nof the backing file of @var{filename}.\n@end itemize\n\nIn JSON format, the @code{offset} field is optional; it is absent in\ncases where @code{human} format would omit the entry or exit with an error.\nIf @code{data} is false and the @code{offset} field is present, the\ncorresponding sectors in the file are not yet in use, but they are\npreallocated.\n\nFor more information, consult @file{include/block/block.h} in QEMU's\nsource code.\n\n@item snapshot [-l | -a @var{snapshot} | -c @var{snapshot} | -d @var{snapshot} ] @var{filename}\n\nList, apply, create or delete snapshots in image @var{filename}.\n\n@item rebase [-f @var{fmt}] [-t @var{cache}] [-T @var{src_cache}] [-p] [-u] -b @var{backing_file} [-F @var{backing_fmt}] @var{filename}\n\nChanges the backing file of an image. Only the formats @code{qcow2} and\n@code{qed} support changing the backing file.\n\nThe backing file is changed to @var{backing_file} and (if the image format of\n@var{filename} supports this) the backing file format is changed to\n@var{backing_fmt}. If @var{backing_file} is specified as ``'' (the empty\nstring), then the image is rebased onto no backing file (i.e. it will exist\nindependently of any backing file).\n\n@var{cache} specifies the cache mode to be used for @var{filename}, whereas\n@var{src_cache} specifies the cache mode for reading backing files.\n\nThere are two different modes in which @code{rebase} can operate:\n@table @option\n@item Safe mode\nThis is the default mode and performs a real rebase operation. The new backing\nfile may differ from the old one and qemu-img rebase will take care of keeping\nthe guest-visible content of @var{filename} unchanged.\n\nIn order to achieve this, any clusters that differ between @var{backing_file}\nand the old backing file of @var{filename} are merged into @var{filename}\nbefore actually changing the backing file.\n\nNote that the safe mode is an expensive operation, comparable to converting\nan image. It only works if the old backing file still exists.\n\n@item Unsafe mode\nqemu-img uses the unsafe mode if @code{-u} is specified. In this mode, only the\nbacking file name and format of @var{filename} is changed without any checks\non the file contents. The user must take care of specifying the correct new\nbacking file, or the guest-visible content of the image will be corrupted.\n\nThis mode is useful for renaming or moving the backing file to somewhere else.\nIt can be used without an accessible old backing file, i.e. you can use it to\nfix an image whose backing file has already been moved/renamed.\n@end table\n\nYou can use @code{rebase} to perform a ``diff'' operation on two\ndisk images.  This can be useful when you have copied or cloned\na guest, and you want to get back to a thin image on top of a\ntemplate or base image.\n\nSay that @code{base.img} has been cloned as @code{modified.img} by\ncopying it, and that the @code{modified.img} guest has run so there\nare now some changes compared to @code{base.img}.  To construct a thin\nimage called @code{diff.qcow2} that contains just the differences, do:\n\n@example\nqemu-img create -f qcow2 -b modified.img diff.qcow2\nqemu-img rebase -b base.img diff.qcow2\n@end example\n\nAt this point, @code{modified.img} can be discarded, since\n@code{base.img + diff.qcow2} contains the same information.\n\n@item resize @var{filename} [+ | -]@var{size}\n\nChange the disk image as if it had been created with @var{size}.\n\nBefore using this command to shrink a disk image, you MUST use file system and\npartitioning tools inside the VM to reduce allocated file systems and partition\nsizes accordingly.  Failure to do so will result in data loss!\n\nAfter using this command to grow a disk image, you must use file system and\npartitioning tools inside the VM to actually begin using the new space on the\ndevice.\n\n@item amend [-p] [-f @var{fmt}] [-t @var{cache}] -o @var{options} @var{filename}\n\nAmends the image format specific @var{options} for the image file\n@var{filename}. Not all file formats support this operation.\n@end table\n@c man end\n\n@ignore\n@c man begin NOTES\nSupported image file formats:\n\n@table @option\n@item raw\n\nRaw disk image format (default). This format has the advantage of\nbeing simple and easily exportable to all other emulators. If your\nfile system supports @emph{holes} (for example in ext2 or ext3 on\nLinux or NTFS on Windows), then only the written sectors will reserve\nspace. Use @code{qemu-img info} to know the real size used by the\nimage or @code{ls -ls} on Unix/Linux.\n\nSupported options:\n@table @code\n@item preallocation\nPreallocation mode (allowed values: @code{off}, @code{falloc}, @code{full}).\n@code{falloc} mode preallocates space for image by calling posix_fallocate().\n@code{full} mode preallocates space for image by writing zeros to underlying\nstorage.\n@end table\n\n@item qcow2\nQEMU image format, the most versatile format. Use it to have smaller\nimages (useful if your filesystem does not supports holes, for example\non Windows), optional AES encryption, zlib based compression and\nsupport of multiple VM snapshots.\n\nSupported options:\n@table @code\n@item compat\nDetermines the qcow2 version to use. @code{compat=0.10} uses the\ntraditional image format that can be read by any QEMU since 0.10.\n@code{compat=1.1} enables image format extensions that only QEMU 1.1 and\nnewer understand (this is the default). Amongst others, this includes zero\nclusters, which allow efficient copy-on-read for sparse images.\n\n@item backing_file\nFile name of a base image (see @option{create} subcommand)\n@item backing_fmt\nImage format of the base image\n@item encryption\nIf this option is set to @code{on}, the image is encrypted with 128-bit AES-CBC.\n\nThe use of encryption in qcow and qcow2 images is considered to be flawed by\nmodern cryptography standards, suffering from a number of design problems:\n\n@itemize @minus\n@item The AES-CBC cipher is used with predictable initialization vectors based\non the sector number. This makes it vulnerable to chosen plaintext attacks\nwhich can reveal the existence of encrypted data.\n@item The user passphrase is directly used as the encryption key. A poorly\nchosen or short passphrase will compromise the security of the encryption.\n@item In the event of the passphrase being compromised there is no way to\nchange the passphrase to protect data in any qcow images. The files must\nbe cloned, using a different encryption passphrase in the new file. The\noriginal file must then be securely erased using a program like shred,\nthough even this is ineffective with many modern storage technologies.\n@end itemize\n\nUse of qcow / qcow2 encryption is thus strongly discouraged. Users are\nrecommended to use an alternative encryption technology such as the\nLinux dm-crypt / LUKS system.\n\n@item cluster_size\nChanges the qcow2 cluster size (must be between 512 and 2M). Smaller cluster\nsizes can improve the image file size whereas larger cluster sizes generally\nprovide better performance.\n\n@item preallocation\nPreallocation mode (allowed values: @code{off}, @code{metadata}, @code{falloc},\n@code{full}). An image with preallocated metadata is initially larger but can\nimprove performance when the image needs to grow. @code{falloc} and @code{full}\npreallocations are like the same options of @code{raw} format, but sets up\nmetadata also.\n\n@item lazy_refcounts\nIf this option is set to @code{on}, reference count updates are postponed with\nthe goal of avoiding metadata I/O and improving performance. This is\nparticularly interesting with @option{cache=writethrough} which doesn't batch\nmetadata updates. The tradeoff is that after a host crash, the reference count\ntables must be rebuilt, i.e. on the next open an (automatic) @code{qemu-img\ncheck -r all} is required, which may take some time.\n\nThis option can only be enabled if @code{compat=1.1} is specified.\n\n@item nocow\nIf this option is set to @code{on}, it will turn off COW of the file. It's only\nvalid on btrfs, no effect on other file systems.\n\nBtrfs has low performance when hosting a VM image file, even more when the guest\non the VM also using btrfs as file system. Turning off COW is a way to mitigate\nthis bad performance. Generally there are two ways to turn off COW on btrfs:\na) Disable it by mounting with nodatacow, then all newly created files will be\nNOCOW. b) For an empty file, add the NOCOW file attribute. That's what this option\ndoes.\n\nNote: this option is only valid to new or empty files. If there is an existing\nfile which is COW and has data blocks already, it couldn't be changed to NOCOW\nby setting @code{nocow=on}. One can issue @code{lsattr filename} to check if\nthe NOCOW flag is set or not (Capital 'C' is NOCOW flag).\n\n@end table\n\n@item Other\nQEMU also supports various other image file formats for compatibility with\nolder QEMU versions or other hypervisors, including VMDK, VDI, VHD (vpc), VHDX,\nqcow1 and QED. For a full list of supported formats see @code{qemu-img --help}.\nFor a more detailed description of these formats, see the QEMU Emulation User\nDocumentation.\n\nThe main purpose of the block drivers for these formats is image conversion.\nFor running VMs, it is recommended to convert the disk images to either raw or\nqcow2 in order to achieve good performance.\n@end table\n\n\n@c man end\n\n@setfilename qemu-img\n@settitle QEMU disk image utility\n\n@c man begin SEEALSO\nThe HTML documentation of QEMU for more precise information and Linux\nuser mode emulator invocation.\n@c man end\n\n@c man begin AUTHOR\nFabrice Bellard\n@c man end\n\n@end ignore\n"
        },
        {
          "name": "qemu-io-cmds.c",
          "type": "blob",
          "size": 58.6689453125,
          "content": "/*\n * Command line utility to exercise the QEMU I/O path.\n *\n * Copyright (C) 2009-2016 Red Hat, Inc.\n * Copyright (c) 2003-2005 Silicon Graphics, Inc.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu-io.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block.h\"\n#include \"block/block_int.h\" /* for info_f() */\n#include \"block/qapi.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/cutils.h\"\n\n#define CMD_NOFILE_OK   0x01\n\nbool qemuio_misalign;\n\nstatic cmdinfo_t *cmdtab;\nstatic int ncmds;\n\nstatic int compare_cmdname(const void *a, const void *b)\n{\n    return strcmp(((const cmdinfo_t *)a)->name,\n                  ((const cmdinfo_t *)b)->name);\n}\n\nvoid qemuio_add_command(const cmdinfo_t *ci)\n{\n    /* ci->perm assumes a file is open, but the GLOBAL and NOFILE_OK\n     * flags allow it not to be, so that combination is invalid.\n     * Catch it now rather than letting it manifest as a crash if a\n     * particular set of command line options are used.\n     */\n    assert(ci->perm == 0 ||\n           (ci->flags & (CMD_FLAG_GLOBAL | CMD_NOFILE_OK)) == 0);\n    cmdtab = g_renew(cmdinfo_t, cmdtab, ++ncmds);\n    cmdtab[ncmds - 1] = *ci;\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare_cmdname);\n}\n\nint qemuio_command_usage(const cmdinfo_t *ci)\n{\n    printf(\"%s %s -- %s\\n\", ci->name, ci->args, ci->oneline);\n    return 0;\n}\n\nstatic int init_check_command(BlockBackend *blk, const cmdinfo_t *ct)\n{\n    if (ct->flags & CMD_FLAG_GLOBAL) {\n        return 1;\n    }\n    if (!(ct->flags & CMD_NOFILE_OK) && !blk) {\n        fprintf(stderr, \"no file open, try 'help open'\\n\");\n        return 0;\n    }\n    return 1;\n}\n\nstatic int command(BlockBackend *blk, const cmdinfo_t *ct, int argc,\n                   char **argv)\n{\n    char *cmd = argv[0];\n\n    if (!init_check_command(blk, ct)) {\n        return 0;\n    }\n\n    if (argc - 1 < ct->argmin || (ct->argmax != -1 && argc - 1 > ct->argmax)) {\n        if (ct->argmax == -1) {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected at least %d arguments\\n\",\n                    argc-1, cmd, ct->argmin);\n        } else if (ct->argmin == ct->argmax) {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected %d arguments\\n\",\n                    argc-1, cmd, ct->argmin);\n        } else {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected between %d and %d arguments\\n\",\n                    argc-1, cmd, ct->argmin, ct->argmax);\n        }\n        return 0;\n    }\n\n    /* Request additional permissions if necessary for this command. The caller\n     * is responsible for restoring the original permissions afterwards if this\n     * is what it wants. */\n    if (ct->perm && blk_is_available(blk)) {\n        uint64_t orig_perm, orig_shared_perm;\n        blk_get_perm(blk, &orig_perm, &orig_shared_perm);\n\n        if (ct->perm & ~orig_perm) {\n            uint64_t new_perm;\n            Error *local_err = NULL;\n            int ret;\n\n            new_perm = orig_perm | ct->perm;\n\n            ret = blk_set_perm(blk, new_perm, orig_shared_perm, &local_err);\n            if (ret < 0) {\n                error_report_err(local_err);\n                return 0;\n            }\n        }\n    }\n\n    optind = 0;\n    return ct->cfunc(blk, argc, argv);\n}\n\nstatic const cmdinfo_t *find_command(const char *cmd)\n{\n    cmdinfo_t *ct;\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        if (strcmp(ct->name, cmd) == 0 ||\n            (ct->altname && strcmp(ct->altname, cmd) == 0))\n        {\n            return (const cmdinfo_t *)ct;\n        }\n    }\n    return NULL;\n}\n\n/* Invoke fn() for commands with a matching prefix */\nvoid qemuio_complete_command(const char *input,\n                             void (*fn)(const char *cmd, void *opaque),\n                             void *opaque)\n{\n    cmdinfo_t *ct;\n    size_t input_len = strlen(input);\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        if (strncmp(input, ct->name, input_len) == 0) {\n            fn(ct->name, opaque);\n        }\n    }\n}\n\nstatic char **breakline(char *input, int *count)\n{\n    int c = 0;\n    char *p;\n    char **rval = g_new0(char *, 1);\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n        if (!*p) {\n            continue;\n        }\n        c++;\n        rval = g_renew(char *, rval, (c + 1));\n        rval[c - 1] = p;\n        rval[c] = NULL;\n    }\n    *count = c;\n    return rval;\n}\n\nstatic int64_t cvtnum(const char *s)\n{\n    int err;\n    uint64_t value;\n\n    err = qemu_strtosz(s, NULL, &value);\n    if (err < 0) {\n        return err;\n    }\n    if (value > INT64_MAX) {\n        return -ERANGE;\n    }\n    return value;\n}\n\nstatic void print_cvtnum_err(int64_t rc, const char *arg)\n{\n    switch (rc) {\n    case -EINVAL:\n        printf(\"Parsing error: non-numeric argument,\"\n               \" or extraneous/unrecognized suffix -- %s\\n\", arg);\n        break;\n    case -ERANGE:\n        printf(\"Parsing error: argument too large -- %s\\n\", arg);\n        break;\n    default:\n        printf(\"Parsing error: %s\\n\", arg);\n    }\n}\n\n#define EXABYTES(x)     ((long long)(x) << 60)\n#define PETABYTES(x)    ((long long)(x) << 50)\n#define TERABYTES(x)    ((long long)(x) << 40)\n#define GIGABYTES(x)    ((long long)(x) << 30)\n#define MEGABYTES(x)    ((long long)(x) << 20)\n#define KILOBYTES(x)    ((long long)(x) << 10)\n\n#define TO_EXABYTES(x)  ((x) / EXABYTES(1))\n#define TO_PETABYTES(x) ((x) / PETABYTES(1))\n#define TO_TERABYTES(x) ((x) / TERABYTES(1))\n#define TO_GIGABYTES(x) ((x) / GIGABYTES(1))\n#define TO_MEGABYTES(x) ((x) / MEGABYTES(1))\n#define TO_KILOBYTES(x) ((x) / KILOBYTES(1))\n\nstatic void cvtstr(double value, char *str, size_t size)\n{\n    char *trim;\n    const char *suffix;\n\n    if (value >= EXABYTES(1)) {\n        suffix = \" EiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_EXABYTES(value));\n    } else if (value >= PETABYTES(1)) {\n        suffix = \" PiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_PETABYTES(value));\n    } else if (value >= TERABYTES(1)) {\n        suffix = \" TiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_TERABYTES(value));\n    } else if (value >= GIGABYTES(1)) {\n        suffix = \" GiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_GIGABYTES(value));\n    } else if (value >= MEGABYTES(1)) {\n        suffix = \" MiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_MEGABYTES(value));\n    } else if (value >= KILOBYTES(1)) {\n        suffix = \" KiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_KILOBYTES(value));\n    } else {\n        suffix = \" bytes\";\n        snprintf(str, size - 6, \"%f\", value);\n    }\n\n    trim = strstr(str, \".000\");\n    if (trim) {\n        strcpy(trim, suffix);\n    } else {\n        strcat(str, suffix);\n    }\n}\n\n\n\nstatic struct timeval tsub(struct timeval t1, struct timeval t2)\n{\n    t1.tv_usec -= t2.tv_usec;\n    if (t1.tv_usec < 0) {\n        t1.tv_usec += 1000000;\n        t1.tv_sec--;\n    }\n    t1.tv_sec -= t2.tv_sec;\n    return t1;\n}\n\nstatic double tdiv(double value, struct timeval tv)\n{\n    return value / ((double)tv.tv_sec + ((double)tv.tv_usec / 1000000.0));\n}\n\n#define HOURS(sec)      ((sec) / (60 * 60))\n#define MINUTES(sec)    (((sec) % (60 * 60)) / 60)\n#define SECONDS(sec)    ((sec) % 60)\n\nenum {\n    DEFAULT_TIME        = 0x0,\n    TERSE_FIXED_TIME    = 0x1,\n    VERBOSE_FIXED_TIME  = 0x2,\n};\n\nstatic void timestr(struct timeval *tv, char *ts, size_t size, int format)\n{\n    double usec = (double)tv->tv_usec / 1000000.0;\n\n    if (format & TERSE_FIXED_TIME) {\n        if (!HOURS(tv->tv_sec)) {\n            snprintf(ts, size, \"%u:%02u.%02u\",\n                    (unsigned int) MINUTES(tv->tv_sec),\n                    (unsigned int) SECONDS(tv->tv_sec),\n                    (unsigned int) (usec * 100));\n            return;\n        }\n        format |= VERBOSE_FIXED_TIME; /* fallback if hours needed */\n    }\n\n    if ((format & VERBOSE_FIXED_TIME) || tv->tv_sec) {\n        snprintf(ts, size, \"%u:%02u:%02u.%02u\",\n                (unsigned int) HOURS(tv->tv_sec),\n                (unsigned int) MINUTES(tv->tv_sec),\n                (unsigned int) SECONDS(tv->tv_sec),\n                (unsigned int) (usec * 100));\n    } else {\n        snprintf(ts, size, \"0.%04u sec\", (unsigned int) (usec * 10000));\n    }\n}\n\n/*\n * Parse the pattern argument to various sub-commands.\n *\n * Because the pattern is used as an argument to memset it must evaluate\n * to an unsigned integer that fits into a single byte.\n */\nstatic int parse_pattern(const char *arg)\n{\n    char *endptr = NULL;\n    long pattern;\n\n    pattern = strtol(arg, &endptr, 0);\n    if (pattern < 0 || pattern > UCHAR_MAX || *endptr != '\\0') {\n        printf(\"%s is not a valid pattern byte\\n\", arg);\n        return -1;\n    }\n\n    return pattern;\n}\n\n/*\n * Memory allocation helpers.\n *\n * Make sure memory is aligned by default, or purposefully misaligned if\n * that is specified on the command line.\n */\n\n#define MISALIGN_OFFSET     16\nstatic void *qemu_io_alloc(BlockBackend *blk, size_t len, int pattern)\n{\n    void *buf;\n\n    if (qemuio_misalign) {\n        len += MISALIGN_OFFSET;\n    }\n    buf = blk_blockalign(blk, len);\n    memset(buf, pattern, len);\n    if (qemuio_misalign) {\n        buf += MISALIGN_OFFSET;\n    }\n    return buf;\n}\n\nstatic void qemu_io_free(void *p)\n{\n    if (qemuio_misalign) {\n        p -= MISALIGN_OFFSET;\n    }\n    qemu_vfree(p);\n}\n\nstatic void dump_buffer(const void *buffer, int64_t offset, int64_t len)\n{\n    uint64_t i;\n    int j;\n    const uint8_t *p;\n\n    for (i = 0, p = buffer; i < len; i += 16) {\n        const uint8_t *s = p;\n\n        printf(\"%08\" PRIx64 \":  \", offset + i);\n        for (j = 0; j < 16 && i + j < len; j++, p++) {\n            printf(\"%02x \", *p);\n        }\n        printf(\" \");\n        for (j = 0; j < 16 && i + j < len; j++, s++) {\n            if (isalnum(*s)) {\n                printf(\"%c\", *s);\n            } else {\n                printf(\".\");\n            }\n        }\n        printf(\"\\n\");\n    }\n}\n\nstatic void print_report(const char *op, struct timeval *t, int64_t offset,\n                         int64_t count, int64_t total, int cnt, bool Cflag)\n{\n    char s1[64], s2[64], ts[64];\n\n    timestr(t, ts, sizeof(ts), Cflag ? VERBOSE_FIXED_TIME : 0);\n    if (!Cflag) {\n        cvtstr((double)total, s1, sizeof(s1));\n        cvtstr(tdiv((double)total, *t), s2, sizeof(s2));\n        printf(\"%s %\"PRId64\"/%\"PRId64\" bytes at offset %\" PRId64 \"\\n\",\n               op, total, count, offset);\n        printf(\"%s, %d ops; %s (%s/sec and %.4f ops/sec)\\n\",\n               s1, cnt, ts, s2, tdiv((double)cnt, *t));\n    } else {/* bytes,ops,time,bytes/sec,ops/sec */\n        printf(\"%\"PRId64\",%d,%s,%.3f,%.3f\\n\",\n            total, cnt, ts,\n            tdiv((double)total, *t),\n            tdiv((double)cnt, *t));\n    }\n}\n\n/*\n * Parse multiple length statements for vectored I/O, and construct an I/O\n * vector matching it.\n */\nstatic void *\ncreate_iovec(BlockBackend *blk, QEMUIOVector *qiov, char **argv, int nr_iov,\n             int pattern)\n{\n    size_t *sizes = g_new0(size_t, nr_iov);\n    size_t count = 0;\n    void *buf = NULL;\n    void *p;\n    int i;\n\n    for (i = 0; i < nr_iov; i++) {\n        char *arg = argv[i];\n        int64_t len;\n\n        len = cvtnum(arg);\n        if (len < 0) {\n            print_cvtnum_err(len, arg);\n            goto fail;\n        }\n\n        if (len > BDRV_REQUEST_MAX_BYTES) {\n            printf(\"Argument '%s' exceeds maximum size %\" PRIu64 \"\\n\", arg,\n                   (uint64_t)BDRV_REQUEST_MAX_BYTES);\n            goto fail;\n        }\n\n        if (count > BDRV_REQUEST_MAX_BYTES - len) {\n            printf(\"The total number of bytes exceed the maximum size %\" PRIu64\n                   \"\\n\", (uint64_t)BDRV_REQUEST_MAX_BYTES);\n            goto fail;\n        }\n\n        sizes[i] = len;\n        count += len;\n    }\n\n    qemu_iovec_init(qiov, nr_iov);\n\n    buf = p = qemu_io_alloc(blk, count, pattern);\n\n    for (i = 0; i < nr_iov; i++) {\n        qemu_iovec_add(qiov, p, sizes[i]);\n        p += sizes[i];\n    }\n\nfail:\n    g_free(sizes);\n    return buf;\n}\n\nstatic int do_pread(BlockBackend *blk, char *buf, int64_t offset,\n                    int64_t count, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_pread(blk, offset, (uint8_t *)buf, count);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\nstatic int do_pwrite(BlockBackend *blk, char *buf, int64_t offset,\n                     int64_t count, int flags, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_pwrite(blk, offset, (uint8_t *)buf, count, flags);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\ntypedef struct {\n    BlockBackend *blk;\n    int64_t offset;\n    int64_t count;\n    int64_t *total;\n    int flags;\n    int ret;\n    bool done;\n} CoWriteZeroes;\n\nstatic void coroutine_fn co_pwrite_zeroes_entry(void *opaque)\n{\n    CoWriteZeroes *data = opaque;\n\n    data->ret = blk_co_pwrite_zeroes(data->blk, data->offset, data->count,\n                                     data->flags);\n    data->done = true;\n    if (data->ret < 0) {\n        *data->total = data->ret;\n        return;\n    }\n\n    *data->total = data->count;\n}\n\nstatic int do_co_pwrite_zeroes(BlockBackend *blk, int64_t offset,\n                               int64_t count, int flags, int64_t *total)\n{\n    Coroutine *co;\n    CoWriteZeroes data = {\n        .blk    = blk,\n        .offset = offset,\n        .count  = count,\n        .total  = total,\n        .flags  = flags,\n        .done   = false,\n    };\n\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    co = qemu_coroutine_create(co_pwrite_zeroes_entry, &data);\n    bdrv_coroutine_enter(blk_bs(blk), co);\n    while (!data.done) {\n        aio_poll(blk_get_aio_context(blk), true);\n    }\n    if (data.ret < 0) {\n        return data.ret;\n    } else {\n        return 1;\n    }\n}\n\nstatic int do_write_compressed(BlockBackend *blk, char *buf, int64_t offset,\n                               int64_t count, int64_t *total)\n{\n    int ret;\n\n    if (count >> 9 > BDRV_REQUEST_MAX_SECTORS) {\n        return -ERANGE;\n    }\n\n    ret = blk_pwrite_compressed(blk, offset, buf, count);\n    if (ret < 0) {\n        return ret;\n    }\n    *total = count;\n    return 1;\n}\n\nstatic int do_load_vmstate(BlockBackend *blk, char *buf, int64_t offset,\n                           int64_t count, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_load_vmstate(blk, (uint8_t *)buf, offset, count);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\nstatic int do_save_vmstate(BlockBackend *blk, char *buf, int64_t offset,\n                           int64_t count, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_save_vmstate(blk, (uint8_t *)buf, offset, count);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\n#define NOT_DONE 0x7fffffff\nstatic void aio_rw_done(void *opaque, int ret)\n{\n    *(int *)opaque = ret;\n}\n\nstatic int do_aio_readv(BlockBackend *blk, QEMUIOVector *qiov,\n                        int64_t offset, int *total)\n{\n    int async_ret = NOT_DONE;\n\n    blk_aio_preadv(blk, offset, qiov, 0, aio_rw_done, &async_ret);\n    while (async_ret == NOT_DONE) {\n        main_loop_wait(false);\n    }\n\n    *total = qiov->size;\n    return async_ret < 0 ? async_ret : 1;\n}\n\nstatic int do_aio_writev(BlockBackend *blk, QEMUIOVector *qiov,\n                         int64_t offset, int flags, int *total)\n{\n    int async_ret = NOT_DONE;\n\n    blk_aio_pwritev(blk, offset, qiov, flags, aio_rw_done, &async_ret);\n    while (async_ret == NOT_DONE) {\n        main_loop_wait(false);\n    }\n\n    *total = qiov->size;\n    return async_ret < 0 ? async_ret : 1;\n}\n\nstatic void read_help(void)\n{\n    printf(\n\"\\n\"\n\" reads a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'read -v 512 1k' - dumps 1 kilobyte read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" -b, -- read from the VM state rather than the virtual disk\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -l, -- length for pattern verification (only with -P)\\n\"\n\" -p, -- ignored for backwards compatibility\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -s, -- start offset for pattern verification (only with -P)\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\"\\n\");\n}\n\nstatic int read_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t read_cmd = {\n    .name       = \"read\",\n    .altname    = \"r\",\n    .cfunc      = read_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-abCqv] [-P pattern [-s off] [-l len]] off len\",\n    .oneline    = \"reads a number of bytes at a specified offset\",\n    .help       = read_help,\n};\n\nstatic int read_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timeval t1, t2;\n    bool Cflag = false, qflag = false, vflag = false;\n    bool Pflag = false, sflag = false, lflag = false, bflag = false;\n    int c, cnt;\n    char *buf;\n    int64_t offset;\n    int64_t count;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int64_t total = 0;\n    int pattern = 0;\n    int64_t pattern_offset = 0, pattern_count = 0;\n\n    while ((c = getopt(argc, argv, \"bCl:pP:qs:v\")) != -1) {\n        switch (c) {\n        case 'b':\n            bflag = true;\n            break;\n        case 'C':\n            Cflag = true;\n            break;\n        case 'l':\n            lflag = true;\n            pattern_count = cvtnum(optarg);\n            if (pattern_count < 0) {\n                print_cvtnum_err(pattern_count, optarg);\n                return 0;\n            }\n            break;\n        case 'p':\n            /* Ignored for backwards compatibility */\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 's':\n            sflag = true;\n            pattern_offset = cvtnum(optarg);\n            if (pattern_offset < 0) {\n                print_cvtnum_err(pattern_offset, optarg);\n                return 0;\n            }\n            break;\n        case 'v':\n            vflag = true;\n            break;\n        default:\n            return qemuio_command_usage(&read_cmd);\n        }\n    }\n\n    if (optind != argc - 2) {\n        return qemuio_command_usage(&read_cmd);\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return 0;\n    }\n\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        print_cvtnum_err(count, argv[optind]);\n        return 0;\n    } else if (count > BDRV_REQUEST_MAX_BYTES) {\n        printf(\"length cannot exceed %\" PRIu64 \", given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_BYTES, argv[optind]);\n        return 0;\n    }\n\n    if (!Pflag && (lflag || sflag)) {\n        return qemuio_command_usage(&read_cmd);\n    }\n\n    if (!lflag) {\n        pattern_count = count - pattern_offset;\n    }\n\n    if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n        printf(\"pattern verification range exceeds end of read data\\n\");\n        return 0;\n    }\n\n    if (bflag) {\n        if (offset & 0x1ff) {\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n                   offset);\n            return 0;\n        }\n        if (count & 0x1ff) {\n            printf(\"count %\"PRId64\" is not sector aligned\\n\",\n                   count);\n            return 0;\n        }\n    }\n\n    buf = qemu_io_alloc(blk, count, 0xab);\n\n    gettimeofday(&t1, NULL);\n    if (bflag) {\n        cnt = do_load_vmstate(blk, buf, offset, count, &total);\n    } else {\n        cnt = do_pread(blk, buf, offset, count, &total);\n    }\n    gettimeofday(&t2, NULL);\n\n    if (cnt < 0) {\n        printf(\"read failed: %s\\n\", strerror(-cnt));\n        goto out;\n    }\n\n    if (Pflag) {\n        void *cmp_buf = g_malloc(pattern_count);\n        memset(cmp_buf, pattern, pattern_count);\n        if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %\"PRId64\" bytes\\n\",\n                   offset + pattern_offset, pattern_count);\n        }\n        g_free(cmp_buf);\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    if (vflag) {\n        dump_buffer(buf, offset, count);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"read\", &t2, offset, count, total, cnt, Cflag);\n\nout:\n    qemu_io_free(buf);\n\n    return 0;\n}\n\nstatic void readv_help(void)\n{\n    printf(\n\"\\n\"\n\" reads a range of bytes from the given offset into multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'readv -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" Uses multiple iovec buffers if more than one byte range is specified.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int readv_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t readv_cmd = {\n    .name       = \"readv\",\n    .cfunc      = readv_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cqv] [-P pattern] off len [len..]\",\n    .oneline    = \"reads a number of bytes at a specified offset\",\n    .help       = readv_help,\n};\n\nstatic int readv_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timeval t1, t2;\n    bool Cflag = false, qflag = false, vflag = false;\n    int c, cnt;\n    char *buf;\n    int64_t offset;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int total = 0;\n    int nr_iov;\n    QEMUIOVector qiov;\n    int pattern = 0;\n    bool Pflag = false;\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 'v':\n            vflag = true;\n            break;\n        default:\n            return qemuio_command_usage(&readv_cmd);\n        }\n    }\n\n    if (optind > argc - 2) {\n        return qemuio_command_usage(&readv_cmd);\n    }\n\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return 0;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, 0xab);\n    if (buf == NULL) {\n        return 0;\n    }\n\n    gettimeofday(&t1, NULL);\n    cnt = do_aio_readv(blk, &qiov, offset, &total);\n    gettimeofday(&t2, NULL);\n\n    if (cnt < 0) {\n        printf(\"readv failed: %s\\n\", strerror(-cnt));\n        goto out;\n    }\n\n    if (Pflag) {\n        void *cmp_buf = g_malloc(qiov.size);\n        memset(cmp_buf, pattern, qiov.size);\n        if (memcmp(buf, cmp_buf, qiov.size)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %zd bytes\\n\", offset, qiov.size);\n        }\n        g_free(cmp_buf);\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    if (vflag) {\n        dump_buffer(buf, offset, qiov.size);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"read\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n    qemu_iovec_destroy(&qiov);\n    qemu_io_free(buf);\n    return 0;\n}\n\nstatic void write_help(void)\n{\n    printf(\n\"\\n\"\n\" writes a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'write 512 1k' - writes 1 kilobyte at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" -b, -- write to the VM state rather than the virtual disk\\n\"\n\" -c, -- write compressed data with blk_write_compressed\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -p, -- ignored for backwards compatibility\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -u, -- with -z, allow unmapping\\n\"\n\" -z, -- write zeroes using blk_co_pwrite_zeroes\\n\"\n\"\\n\");\n}\n\nstatic int write_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t write_cmd = {\n    .name       = \"write\",\n    .altname    = \"w\",\n    .cfunc      = write_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-bcCfquz] [-P pattern] off len\",\n    .oneline    = \"writes a number of bytes at a specified offset\",\n    .help       = write_help,\n};\n\nstatic int write_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timeval t1, t2;\n    bool Cflag = false, qflag = false, bflag = false;\n    bool Pflag = false, zflag = false, cflag = false;\n    int flags = 0;\n    int c, cnt;\n    char *buf = NULL;\n    int64_t offset;\n    int64_t count;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int64_t total = 0;\n    int pattern = 0xcd;\n\n    while ((c = getopt(argc, argv, \"bcCfpP:quz\")) != -1) {\n        switch (c) {\n        case 'b':\n            bflag = true;\n            break;\n        case 'c':\n            cflag = true;\n            break;\n        case 'C':\n            Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'p':\n            /* Ignored for backwards compatibility */\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 'u':\n            flags |= BDRV_REQ_MAY_UNMAP;\n            break;\n        case 'z':\n            zflag = true;\n            break;\n        default:\n            return qemuio_command_usage(&write_cmd);\n        }\n    }\n\n    if (optind != argc - 2) {\n        return qemuio_command_usage(&write_cmd);\n    }\n\n    if (bflag && zflag) {\n        printf(\"-b and -z cannot be specified at the same time\\n\");\n        return 0;\n    }\n\n    if ((flags & BDRV_REQ_FUA) && (bflag || cflag)) {\n        printf(\"-f and -b or -c cannot be specified at the same time\\n\");\n        return 0;\n    }\n\n    if ((flags & BDRV_REQ_MAY_UNMAP) && !zflag) {\n        printf(\"-u requires -z to be specified\\n\");\n        return 0;\n    }\n\n    if (zflag && Pflag) {\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n        return 0;\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return 0;\n    }\n\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        print_cvtnum_err(count, argv[optind]);\n        return 0;\n    } else if (count > BDRV_REQUEST_MAX_BYTES) {\n        printf(\"length cannot exceed %\" PRIu64 \", given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_BYTES, argv[optind]);\n        return 0;\n    }\n\n    if (bflag || cflag) {\n        if (offset & 0x1ff) {\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n                   offset);\n            return 0;\n        }\n\n        if (count & 0x1ff) {\n            printf(\"count %\"PRId64\" is not sector aligned\\n\",\n                   count);\n            return 0;\n        }\n    }\n\n    if (!zflag) {\n        buf = qemu_io_alloc(blk, count, pattern);\n    }\n\n    gettimeofday(&t1, NULL);\n    if (bflag) {\n        cnt = do_save_vmstate(blk, buf, offset, count, &total);\n    } else if (zflag) {\n        cnt = do_co_pwrite_zeroes(blk, offset, count, flags, &total);\n    } else if (cflag) {\n        cnt = do_write_compressed(blk, buf, offset, count, &total);\n    } else {\n        cnt = do_pwrite(blk, buf, offset, count, flags, &total);\n    }\n    gettimeofday(&t2, NULL);\n\n    if (cnt < 0) {\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n        goto out;\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\nout:\n    if (!zflag) {\n        qemu_io_free(buf);\n    }\n\n    return 0;\n}\n\nstatic void\nwritev_help(void)\n{\n    printf(\n\"\\n\"\n\" writes a range of bytes from the given offset source from multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'writev 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int writev_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t writev_cmd = {\n    .name       = \"writev\",\n    .cfunc      = writev_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cfq] [-P pattern] off len [len..]\",\n    .oneline    = \"writes a number of bytes at a specified offset\",\n    .help       = writev_help,\n};\n\nstatic int writev_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timeval t1, t2;\n    bool Cflag = false, qflag = false;\n    int flags = 0;\n    int c, cnt;\n    char *buf;\n    int64_t offset;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int total = 0;\n    int nr_iov;\n    int pattern = 0xcd;\n    QEMUIOVector qiov;\n\n    while ((c = getopt(argc, argv, \"CfqP:\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        default:\n            return qemuio_command_usage(&writev_cmd);\n        }\n    }\n\n    if (optind > argc - 2) {\n        return qemuio_command_usage(&writev_cmd);\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return 0;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, pattern);\n    if (buf == NULL) {\n        return 0;\n    }\n\n    gettimeofday(&t1, NULL);\n    cnt = do_aio_writev(blk, &qiov, offset, flags, &total);\n    gettimeofday(&t2, NULL);\n\n    if (cnt < 0) {\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n        goto out;\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\nout:\n    qemu_iovec_destroy(&qiov);\n    qemu_io_free(buf);\n    return 0;\n}\n\nstruct aio_ctx {\n    BlockBackend *blk;\n    QEMUIOVector qiov;\n    int64_t offset;\n    char *buf;\n    bool qflag;\n    bool vflag;\n    bool Cflag;\n    bool Pflag;\n    bool zflag;\n    BlockAcctCookie acct;\n    int pattern;\n    struct timeval t1;\n};\n\nstatic void aio_write_done(void *opaque, int ret)\n{\n    struct aio_ctx *ctx = opaque;\n    struct timeval t2;\n\n    gettimeofday(&t2, NULL);\n\n\n    if (ret < 0) {\n        printf(\"aio_write failed: %s\\n\", strerror(-ret));\n        block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);\n        goto out;\n    }\n\n    block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);\n\n    if (ctx->qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, ctx->t1);\n    print_report(\"wrote\", &t2, ctx->offset, ctx->qiov.size,\n                 ctx->qiov.size, 1, ctx->Cflag);\nout:\n    if (!ctx->zflag) {\n        qemu_io_free(ctx->buf);\n        qemu_iovec_destroy(&ctx->qiov);\n    }\n    g_free(ctx);\n}\n\nstatic void aio_read_done(void *opaque, int ret)\n{\n    struct aio_ctx *ctx = opaque;\n    struct timeval t2;\n\n    gettimeofday(&t2, NULL);\n\n    if (ret < 0) {\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n        block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);\n        goto out;\n    }\n\n    if (ctx->Pflag) {\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n        }\n        g_free(cmp_buf);\n    }\n\n    block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);\n\n    if (ctx->qflag) {\n        goto out;\n    }\n\n    if (ctx->vflag) {\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, ctx->t1);\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n                 ctx->qiov.size, 1, ctx->Cflag);\nout:\n    qemu_io_free(ctx->buf);\n    qemu_iovec_destroy(&ctx->qiov);\n    g_free(ctx);\n}\n\nstatic void aio_read_help(void)\n{\n    printf(\n\"\\n\"\n\" asynchronously reads a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'aio_read -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" The read is performed asynchronously and the aio_flush command must be\\n\"\n\" used to ensure all outstanding aio requests have been completed.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -i, -- treat request as invalid, for exercising stats\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int aio_read_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t aio_read_cmd = {\n    .name       = \"aio_read\",\n    .cfunc      = aio_read_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Ciqv] [-P pattern] off len [len..]\",\n    .oneline    = \"asynchronously reads a number of bytes\",\n    .help       = aio_read_help,\n};\n\nstatic int aio_read_f(BlockBackend *blk, int argc, char **argv)\n{\n    int nr_iov, c;\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n    ctx->blk = blk;\n    while ((c = getopt(argc, argv, \"CP:iqv\")) != -1) {\n        switch (c) {\n        case 'C':\n            ctx->Cflag = true;\n            break;\n        case 'P':\n            ctx->Pflag = true;\n            ctx->pattern = parse_pattern(optarg);\n            if (ctx->pattern < 0) {\n                g_free(ctx);\n                return 0;\n            }\n            break;\n        case 'i':\n            printf(\"injecting invalid read request\\n\");\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_READ);\n            g_free(ctx);\n            return 0;\n        case 'q':\n            ctx->qflag = true;\n            break;\n        case 'v':\n            ctx->vflag = true;\n            break;\n        default:\n            g_free(ctx);\n            return qemuio_command_usage(&aio_read_cmd);\n        }\n    }\n\n    if (optind > argc - 2) {\n        g_free(ctx);\n        return qemuio_command_usage(&aio_read_cmd);\n    }\n\n    ctx->offset = cvtnum(argv[optind]);\n    if (ctx->offset < 0) {\n        print_cvtnum_err(ctx->offset, argv[optind]);\n        g_free(ctx);\n        return 0;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov, 0xab);\n    if (ctx->buf == NULL) {\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_READ);\n        g_free(ctx);\n        return 0;\n    }\n\n    gettimeofday(&ctx->t1, NULL);\n    block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n                     BLOCK_ACCT_READ);\n    blk_aio_preadv(blk, ctx->offset, &ctx->qiov, 0, aio_read_done, ctx);\n    return 0;\n}\n\nstatic void aio_write_help(void)\n{\n    printf(\n\"\\n\"\n\" asynchronously writes a range of bytes from the given offset source\\n\"\n\" from multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'aio_write 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" The write is performed asynchronously and the aio_flush command must be\\n\"\n\" used to ensure all outstanding aio requests have been completed.\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -i, -- treat request as invalid, for exercising stats\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -u, -- with -z, allow unmapping\\n\"\n\" -z, -- write zeroes using blk_aio_pwrite_zeroes\\n\"\n\"\\n\");\n}\n\nstatic int aio_write_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t aio_write_cmd = {\n    .name       = \"aio_write\",\n    .cfunc      = aio_write_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cfiquz] [-P pattern] off len [len..]\",\n    .oneline    = \"asynchronously writes a number of bytes\",\n    .help       = aio_write_help,\n};\n\nstatic int aio_write_f(BlockBackend *blk, int argc, char **argv)\n{\n    int nr_iov, c;\n    int pattern = 0xcd;\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n    int flags = 0;\n\n    ctx->blk = blk;\n    while ((c = getopt(argc, argv, \"CfiqP:uz\")) != -1) {\n        switch (c) {\n        case 'C':\n            ctx->Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'q':\n            ctx->qflag = true;\n            break;\n        case 'u':\n            flags |= BDRV_REQ_MAY_UNMAP;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                g_free(ctx);\n                return 0;\n            }\n            break;\n        case 'i':\n            printf(\"injecting invalid write request\\n\");\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n            g_free(ctx);\n            return 0;\n        case 'z':\n            ctx->zflag = true;\n            break;\n        default:\n            g_free(ctx);\n            return qemuio_command_usage(&aio_write_cmd);\n        }\n    }\n\n    if (optind > argc - 2) {\n        g_free(ctx);\n        return qemuio_command_usage(&aio_write_cmd);\n    }\n\n    if (ctx->zflag && optind != argc - 2) {\n        printf(\"-z supports only a single length parameter\\n\");\n        g_free(ctx);\n        return 0;\n    }\n\n    if ((flags & BDRV_REQ_MAY_UNMAP) && !ctx->zflag) {\n        printf(\"-u requires -z to be specified\\n\");\n        g_free(ctx);\n        return 0;\n    }\n\n    if (ctx->zflag && ctx->Pflag) {\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n        g_free(ctx);\n        return 0;\n    }\n\n    ctx->offset = cvtnum(argv[optind]);\n    if (ctx->offset < 0) {\n        print_cvtnum_err(ctx->offset, argv[optind]);\n        g_free(ctx);\n        return 0;\n    }\n    optind++;\n\n    if (ctx->zflag) {\n        int64_t count = cvtnum(argv[optind]);\n        if (count < 0) {\n            print_cvtnum_err(count, argv[optind]);\n            g_free(ctx);\n            return 0;\n        }\n\n        ctx->qiov.size = count;\n        blk_aio_pwrite_zeroes(blk, ctx->offset, count, flags, aio_write_done,\n                              ctx);\n    } else {\n        nr_iov = argc - optind;\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n                                pattern);\n        if (ctx->buf == NULL) {\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n            g_free(ctx);\n            return 0;\n        }\n\n        gettimeofday(&ctx->t1, NULL);\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n                         BLOCK_ACCT_WRITE);\n\n        blk_aio_pwritev(blk, ctx->offset, &ctx->qiov, flags, aio_write_done,\n                        ctx);\n    }\n    return 0;\n}\n\nstatic int aio_flush_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockAcctCookie cookie;\n    block_acct_start(blk_get_stats(blk), &cookie, 0, BLOCK_ACCT_FLUSH);\n    blk_drain_all();\n    block_acct_done(blk_get_stats(blk), &cookie);\n    return 0;\n}\n\nstatic const cmdinfo_t aio_flush_cmd = {\n    .name       = \"aio_flush\",\n    .cfunc      = aio_flush_f,\n    .oneline    = \"completes all outstanding aio requests\"\n};\n\nstatic int flush_f(BlockBackend *blk, int argc, char **argv)\n{\n    blk_flush(blk);\n    return 0;\n}\n\nstatic const cmdinfo_t flush_cmd = {\n    .name       = \"flush\",\n    .altname    = \"f\",\n    .cfunc      = flush_f,\n    .oneline    = \"flush all in-core file state to disk\",\n};\n\nstatic int truncate_f(BlockBackend *blk, int argc, char **argv)\n{\n    Error *local_err = NULL;\n    int64_t offset;\n    int ret;\n\n    offset = cvtnum(argv[1]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[1]);\n        return 0;\n    }\n\n    ret = blk_truncate(blk, offset, &local_err);\n    if (ret < 0) {\n        error_report_err(local_err);\n        return 0;\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t truncate_cmd = {\n    .name       = \"truncate\",\n    .altname    = \"t\",\n    .cfunc      = truncate_f,\n    .perm       = BLK_PERM_WRITE | BLK_PERM_RESIZE,\n    .argmin     = 1,\n    .argmax     = 1,\n    .args       = \"off\",\n    .oneline    = \"truncates the current file at the given offset\",\n};\n\nstatic int length_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t size;\n    char s1[64];\n\n    size = blk_getlength(blk);\n    if (size < 0) {\n        printf(\"getlength: %s\\n\", strerror(-size));\n        return 0;\n    }\n\n    cvtstr(size, s1, sizeof(s1));\n    printf(\"%s\\n\", s1);\n    return 0;\n}\n\n\nstatic const cmdinfo_t length_cmd = {\n    .name   = \"length\",\n    .altname    = \"l\",\n    .cfunc      = length_f,\n    .oneline    = \"gets the length of the current file\",\n};\n\n\nstatic int info_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    BlockDriverInfo bdi;\n    ImageInfoSpecific *spec_info;\n    char s1[64], s2[64];\n    int ret;\n\n    if (bs->drv && bs->drv->format_name) {\n        printf(\"format name: %s\\n\", bs->drv->format_name);\n    }\n    if (bs->drv && bs->drv->protocol_name) {\n        printf(\"format name: %s\\n\", bs->drv->protocol_name);\n    }\n\n    ret = bdrv_get_info(bs, &bdi);\n    if (ret) {\n        return 0;\n    }\n\n    cvtstr(bdi.cluster_size, s1, sizeof(s1));\n    cvtstr(bdi.vm_state_offset, s2, sizeof(s2));\n\n    printf(\"cluster size: %s\\n\", s1);\n    printf(\"vm state offset: %s\\n\", s2);\n\n    spec_info = bdrv_get_specific_info(bs);\n    if (spec_info) {\n        printf(\"Format specific information:\\n\");\n        bdrv_image_info_specific_dump(fprintf, stdout, spec_info);\n        qapi_free_ImageInfoSpecific(spec_info);\n    }\n\n    return 0;\n}\n\n\n\nstatic const cmdinfo_t info_cmd = {\n    .name       = \"info\",\n    .altname    = \"i\",\n    .cfunc      = info_f,\n    .oneline    = \"prints information about the current file\",\n};\n\nstatic void discard_help(void)\n{\n    printf(\n\"\\n\"\n\" discards a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'discard 512 1k' - discards 1 kilobyte from 512 bytes into the file\\n\"\n\"\\n\"\n\" Discards a segment of the currently open file.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int discard_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t discard_cmd = {\n    .name       = \"discard\",\n    .altname    = \"d\",\n    .cfunc      = discard_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cq] off len\",\n    .oneline    = \"discards a number of bytes at a specified offset\",\n    .help       = discard_help,\n};\n\nstatic int discard_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timeval t1, t2;\n    bool Cflag = false, qflag = false;\n    int c, ret;\n    int64_t offset, count;\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        default:\n            return qemuio_command_usage(&discard_cmd);\n        }\n    }\n\n    if (optind != argc - 2) {\n        return qemuio_command_usage(&discard_cmd);\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return 0;\n    }\n\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        print_cvtnum_err(count, argv[optind]);\n        return 0;\n    } else if (count >> BDRV_SECTOR_BITS > BDRV_REQUEST_MAX_SECTORS) {\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_SECTORS << BDRV_SECTOR_BITS,\n               argv[optind]);\n        return 0;\n    }\n\n    gettimeofday(&t1, NULL);\n    ret = blk_pdiscard(blk, offset, count);\n    gettimeofday(&t2, NULL);\n\n    if (ret < 0) {\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    if (!qflag) {\n        t2 = tsub(t2, t1);\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n    }\n\nout:\n    return 0;\n}\n\nstatic int alloc_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    int64_t offset, sector_num, nb_sectors, remaining;\n    char s1[64];\n    int num, ret;\n    int64_t sum_alloc;\n\n    offset = cvtnum(argv[1]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[1]);\n        return 0;\n    } else if (offset & 0x1ff) {\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n               offset);\n        return 0;\n    }\n\n    if (argc == 3) {\n        nb_sectors = cvtnum(argv[2]);\n        if (nb_sectors < 0) {\n            print_cvtnum_err(nb_sectors, argv[2]);\n            return 0;\n        } else if (nb_sectors > INT_MAX) {\n            printf(\"length argument cannot exceed %d, given %s\\n\",\n                   INT_MAX, argv[2]);\n            return 0;\n        }\n    } else {\n        nb_sectors = 1;\n    }\n\n    remaining = nb_sectors;\n    sum_alloc = 0;\n    sector_num = offset >> 9;\n    while (remaining) {\n        ret = bdrv_is_allocated(bs, sector_num, remaining, &num);\n        if (ret < 0) {\n            printf(\"is_allocated failed: %s\\n\", strerror(-ret));\n            return 0;\n        }\n        sector_num += num;\n        remaining -= num;\n        if (ret) {\n            sum_alloc += num;\n        }\n        if (num == 0) {\n            nb_sectors -= remaining;\n            remaining = 0;\n        }\n    }\n\n    cvtstr(offset, s1, sizeof(s1));\n\n    printf(\"%\"PRId64\"/%\"PRId64\" sectors allocated at offset %s\\n\",\n           sum_alloc, nb_sectors, s1);\n    return 0;\n}\n\nstatic const cmdinfo_t alloc_cmd = {\n    .name       = \"alloc\",\n    .altname    = \"a\",\n    .argmin     = 1,\n    .argmax     = 2,\n    .cfunc      = alloc_f,\n    .args       = \"off [sectors]\",\n    .oneline    = \"checks if a sector is present in the file\",\n};\n\n\nstatic int map_is_allocated(BlockDriverState *bs, int64_t sector_num,\n                            int64_t nb_sectors, int64_t *pnum)\n{\n    int num, num_checked;\n    int ret, firstret;\n\n    num_checked = MIN(nb_sectors, INT_MAX);\n    ret = bdrv_is_allocated(bs, sector_num, num_checked, &num);\n    if (ret < 0) {\n        return ret;\n    }\n\n    firstret = ret;\n    *pnum = num;\n\n    while (nb_sectors > 0 && ret == firstret) {\n        sector_num += num;\n        nb_sectors -= num;\n\n        num_checked = MIN(nb_sectors, INT_MAX);\n        ret = bdrv_is_allocated(bs, sector_num, num_checked, &num);\n        if (ret == firstret && num) {\n            *pnum += num;\n        } else {\n            break;\n        }\n    }\n\n    return firstret;\n}\n\nstatic int map_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t offset;\n    int64_t nb_sectors, total_sectors;\n    char s1[64];\n    int64_t num;\n    int ret;\n    const char *retstr;\n\n    offset = 0;\n    total_sectors = blk_nb_sectors(blk);\n    if (total_sectors < 0) {\n        error_report(\"Failed to query image length: %s\",\n                     strerror(-total_sectors));\n        return 0;\n    }\n\n    nb_sectors = total_sectors;\n\n    do {\n        ret = map_is_allocated(blk_bs(blk), offset, nb_sectors, &num);\n        if (ret < 0) {\n            error_report(\"Failed to get allocation status: %s\", strerror(-ret));\n            return 0;\n        } else if (!num) {\n            error_report(\"Unexpected end of image\");\n            return 0;\n        }\n\n        retstr = ret ? \"    allocated\" : \"not allocated\";\n        cvtstr(offset << 9ULL, s1, sizeof(s1));\n        printf(\"[% 24\" PRId64 \"] % 8\" PRId64 \"/% 8\" PRId64 \" sectors %s \"\n               \"at offset %s (%d)\\n\",\n               offset << 9ULL, num, nb_sectors, retstr, s1, ret);\n\n        offset += num;\n        nb_sectors -= num;\n    } while (offset < total_sectors);\n\n    return 0;\n}\n\nstatic const cmdinfo_t map_cmd = {\n       .name           = \"map\",\n       .argmin         = 0,\n       .argmax         = 0,\n       .cfunc          = map_f,\n       .args           = \"\",\n       .oneline        = \"prints the allocated areas of a file\",\n};\n\nstatic void reopen_help(void)\n{\n    printf(\n\"\\n\"\n\" Changes the open options of an already opened image\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'reopen -o lazy-refcounts=on' - activates lazy refcount writeback on a qcow2 image\\n\"\n\"\\n\"\n\" -r, -- Reopen the image read-only\\n\"\n\" -c, -- Change the cache mode to the given value\\n\"\n\" -o, -- Changes block driver options (cf. 'open' command)\\n\"\n\"\\n\");\n}\n\nstatic int reopen_f(BlockBackend *blk, int argc, char **argv);\n\nstatic QemuOptsList reopen_opts = {\n    .name = \"reopen\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(reopen_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic const cmdinfo_t reopen_cmd = {\n       .name           = \"reopen\",\n       .argmin         = 0,\n       .argmax         = -1,\n       .cfunc          = reopen_f,\n       .args           = \"[-r] [-c cache] [-o options]\",\n       .oneline        = \"reopens an image with new options\",\n       .help           = reopen_help,\n};\n\nstatic int reopen_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    QemuOpts *qopts;\n    QDict *opts;\n    int c;\n    int flags = bs->open_flags;\n    bool writethrough = !blk_enable_write_cache(blk);\n\n    BlockReopenQueue *brq;\n    Error *local_err = NULL;\n\n    while ((c = getopt(argc, argv, \"c:o:r\")) != -1) {\n        switch (c) {\n        case 'c':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                return 0;\n            }\n            break;\n        case 'o':\n            if (!qemu_opts_parse_noisily(&reopen_opts, optarg, 0)) {\n                qemu_opts_reset(&reopen_opts);\n                return 0;\n            }\n            break;\n        case 'r':\n            flags &= ~BDRV_O_RDWR;\n            break;\n        default:\n            qemu_opts_reset(&reopen_opts);\n            return qemuio_command_usage(&reopen_cmd);\n        }\n    }\n\n    if (optind != argc) {\n        qemu_opts_reset(&reopen_opts);\n        return qemuio_command_usage(&reopen_cmd);\n    }\n\n    if (writethrough != blk_enable_write_cache(blk) &&\n        blk_get_attached_dev(blk))\n    {\n        error_report(\"Cannot change cache.writeback: Device attached\");\n        qemu_opts_reset(&reopen_opts);\n        return 0;\n    }\n\n    qopts = qemu_opts_find(&reopen_opts, NULL);\n    opts = qopts ? qemu_opts_to_qdict(qopts, NULL) : NULL;\n    qemu_opts_reset(&reopen_opts);\n\n    brq = bdrv_reopen_queue(NULL, bs, opts, flags);\n    bdrv_reopen_multiple(bdrv_get_aio_context(bs), brq, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n    } else {\n        blk_set_enable_write_cache(blk, !writethrough);\n    }\n\n    return 0;\n}\n\nstatic int break_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_breakpoint(blk_bs(blk), argv[1], argv[2]);\n    if (ret < 0) {\n        printf(\"Could not set breakpoint: %s\\n\", strerror(-ret));\n    }\n\n    return 0;\n}\n\nstatic int remove_break_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_remove_breakpoint(blk_bs(blk), argv[1]);\n    if (ret < 0) {\n        printf(\"Could not remove breakpoint %s: %s\\n\", argv[1], strerror(-ret));\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t break_cmd = {\n       .name           = \"break\",\n       .argmin         = 2,\n       .argmax         = 2,\n       .cfunc          = break_f,\n       .args           = \"event tag\",\n       .oneline        = \"sets a breakpoint on event and tags the stopped \"\n                         \"request as tag\",\n};\n\nstatic const cmdinfo_t remove_break_cmd = {\n       .name           = \"remove_break\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = remove_break_f,\n       .args           = \"tag\",\n       .oneline        = \"remove a breakpoint by tag\",\n};\n\nstatic int resume_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_resume(blk_bs(blk), argv[1]);\n    if (ret < 0) {\n        printf(\"Could not resume request: %s\\n\", strerror(-ret));\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t resume_cmd = {\n       .name           = \"resume\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = resume_f,\n       .args           = \"tag\",\n       .oneline        = \"resumes the request tagged as tag\",\n};\n\nstatic int wait_break_f(BlockBackend *blk, int argc, char **argv)\n{\n    while (!bdrv_debug_is_suspended(blk_bs(blk), argv[1])) {\n        aio_poll(blk_get_aio_context(blk), true);\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t wait_break_cmd = {\n       .name           = \"wait_break\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = wait_break_f,\n       .args           = \"tag\",\n       .oneline        = \"waits for the suspension of a request\",\n};\n\nstatic int abort_f(BlockBackend *blk, int argc, char **argv)\n{\n    abort();\n}\n\nstatic const cmdinfo_t abort_cmd = {\n       .name           = \"abort\",\n       .cfunc          = abort_f,\n       .flags          = CMD_NOFILE_OK,\n       .oneline        = \"simulate a program crash using abort(3)\",\n};\n\nstatic void sigraise_help(void)\n{\n    printf(\n\"\\n\"\n\" raises the given signal\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'sigraise %i' - raises SIGTERM\\n\"\n\"\\n\"\n\" Invokes raise(signal), where \\\"signal\\\" is the mandatory integer argument\\n\"\n\" given to sigraise.\\n\"\n\"\\n\", SIGTERM);\n}\n\nstatic int sigraise_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t sigraise_cmd = {\n    .name       = \"sigraise\",\n    .cfunc      = sigraise_f,\n    .argmin     = 1,\n    .argmax     = 1,\n    .flags      = CMD_NOFILE_OK,\n    .args       = \"signal\",\n    .oneline    = \"raises a signal\",\n    .help       = sigraise_help,\n};\n\nstatic int sigraise_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t sig = cvtnum(argv[1]);\n    if (sig < 0) {\n        print_cvtnum_err(sig, argv[1]);\n        return 0;\n    } else if (sig > NSIG) {\n        printf(\"signal argument '%s' is too large to be a valid signal\\n\",\n               argv[1]);\n        return 0;\n    }\n\n    /* Using raise() to kill this process does not necessarily flush all open\n     * streams. At least stdout and stderr (although the latter should be\n     * non-buffered anyway) should be flushed, though. */\n    fflush(stdout);\n    fflush(stderr);\n\n    raise(sig);\n    return 0;\n}\n\nstatic void sleep_cb(void *opaque)\n{\n    bool *expired = opaque;\n    *expired = true;\n}\n\nstatic int sleep_f(BlockBackend *blk, int argc, char **argv)\n{\n    char *endptr;\n    long ms;\n    struct QEMUTimer *timer;\n    bool expired = false;\n\n    ms = strtol(argv[1], &endptr, 0);\n    if (ms < 0 || *endptr != '\\0') {\n        printf(\"%s is not a valid number\\n\", argv[1]);\n        return 0;\n    }\n\n    timer = timer_new_ns(QEMU_CLOCK_HOST, sleep_cb, &expired);\n    timer_mod(timer, qemu_clock_get_ns(QEMU_CLOCK_HOST) + SCALE_MS * ms);\n\n    while (!expired) {\n        main_loop_wait(false);\n    }\n\n    timer_free(timer);\n\n    return 0;\n}\n\nstatic const cmdinfo_t sleep_cmd = {\n       .name           = \"sleep\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = sleep_f,\n       .flags          = CMD_NOFILE_OK,\n       .oneline        = \"waits for the given value in milliseconds\",\n};\n\nstatic void help_oneline(const char *cmd, const cmdinfo_t *ct)\n{\n    if (cmd) {\n        printf(\"%s \", cmd);\n    } else {\n        printf(\"%s \", ct->name ? ct->name : \"(ct->name==NULL!)\");\n        if (ct->altname) {\n            printf(\"(or %s) \", ct->altname);\n        }\n    }\n\n    if (ct->args) {\n        printf(\"%s \", ct->args);\n    }\n    printf(\"-- %s\\n\", ct->oneline);\n}\n\nstatic void help_onecmd(const char *cmd, const cmdinfo_t *ct)\n{\n    help_oneline(cmd, ct);\n    if (ct->help) {\n        ct->help();\n    }\n}\n\nstatic void help_all(void)\n{\n    const cmdinfo_t *ct;\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        help_oneline(ct->name, ct);\n    }\n    printf(\"\\nUse 'help commandname' for extended help.\\n\");\n}\n\nstatic int help_f(BlockBackend *blk, int argc, char **argv)\n{\n    const cmdinfo_t *ct;\n\n    if (argc == 1) {\n        help_all();\n        return 0;\n    }\n\n    ct = find_command(argv[1]);\n    if (ct == NULL) {\n        printf(\"command %s not found\\n\", argv[1]);\n        return 0;\n    }\n\n    help_onecmd(argv[1], ct);\n    return 0;\n}\n\nstatic const cmdinfo_t help_cmd = {\n    .name       = \"help\",\n    .altname    = \"?\",\n    .cfunc      = help_f,\n    .argmin     = 0,\n    .argmax     = 1,\n    .flags      = CMD_FLAG_GLOBAL,\n    .args       = \"[command]\",\n    .oneline    = \"help for one or all commands\",\n};\n\nbool qemuio_command(BlockBackend *blk, const char *cmd)\n{\n    AioContext *ctx;\n    char *input;\n    const cmdinfo_t *ct;\n    char **v;\n    int c;\n    bool done = false;\n\n    input = g_strdup(cmd);\n    v = breakline(input, &c);\n    if (c) {\n        ct = find_command(v[0]);\n        if (ct) {\n            ctx = blk ? blk_get_aio_context(blk) : qemu_get_aio_context();\n            aio_context_acquire(ctx);\n            done = command(blk, ct, c, v);\n            aio_context_release(ctx);\n        } else {\n            fprintf(stderr, \"command \\\"%s\\\" not found\\n\", v[0]);\n        }\n    }\n    g_free(input);\n    g_free(v);\n\n    return done;\n}\n\nstatic void __attribute((constructor)) init_qemuio_commands(void)\n{\n    /* initialize commands */\n    qemuio_add_command(&help_cmd);\n    qemuio_add_command(&read_cmd);\n    qemuio_add_command(&readv_cmd);\n    qemuio_add_command(&write_cmd);\n    qemuio_add_command(&writev_cmd);\n    qemuio_add_command(&aio_read_cmd);\n    qemuio_add_command(&aio_write_cmd);\n    qemuio_add_command(&aio_flush_cmd);\n    qemuio_add_command(&flush_cmd);\n    qemuio_add_command(&truncate_cmd);\n    qemuio_add_command(&length_cmd);\n    qemuio_add_command(&info_cmd);\n    qemuio_add_command(&discard_cmd);\n    qemuio_add_command(&alloc_cmd);\n    qemuio_add_command(&map_cmd);\n    qemuio_add_command(&reopen_cmd);\n    qemuio_add_command(&break_cmd);\n    qemuio_add_command(&remove_break_cmd);\n    qemuio_add_command(&resume_cmd);\n    qemuio_add_command(&wait_break_cmd);\n    qemuio_add_command(&abort_cmd);\n    qemuio_add_command(&sleep_cmd);\n    qemuio_add_command(&sigraise_cmd);\n}\n"
        },
        {
          "name": "qemu-io.c",
          "type": "blob",
          "size": 15.919921875,
          "content": "/*\n * Command line utility to exercise the QEMU I/O path.\n *\n * Copyright (C) 2009 Red Hat, Inc.\n * Copyright (c) 2003-2005 Silicon Graphics, Inc.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n#include \"qemu/osdep.h\"\n#include <getopt.h>\n#include <libgen.h>\n\n#include \"qapi/error.h\"\n#include \"qemu-io.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/readline.h\"\n#include \"qemu/log.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qom/object_interfaces.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block_int.h\"\n#include \"trace/control.h\"\n#include \"crypto/init.h\"\n\n#define CMD_NOFILE_OK   0x01\n\nstatic char *progname;\n\nstatic BlockBackend *qemuio_blk;\n\n/* qemu-io commands passed using -c */\nstatic int ncmdline;\nstatic char **cmdline;\nstatic bool imageOpts;\n\nstatic ReadLineState *readline_state;\n\nstatic int close_f(BlockBackend *blk, int argc, char **argv)\n{\n    blk_unref(qemuio_blk);\n    qemuio_blk = NULL;\n    return 0;\n}\n\nstatic const cmdinfo_t close_cmd = {\n    .name       = \"close\",\n    .altname    = \"c\",\n    .cfunc      = close_f,\n    .oneline    = \"close the current open file\",\n};\n\nstatic int openfile(char *name, int flags, bool writethrough, QDict *opts)\n{\n    Error *local_err = NULL;\n    BlockDriverState *bs;\n\n    if (qemuio_blk) {\n        error_report(\"file open already, try 'help close'\");\n        QDECREF(opts);\n        return 1;\n    }\n\n    qemuio_blk = blk_new_open(name, NULL, opts, flags, &local_err);\n    if (!qemuio_blk) {\n        error_reportf_err(local_err, \"can't open%s%s: \",\n                          name ? \" device \" : \"\", name ?: \"\");\n        return 1;\n    }\n\n    bs = blk_bs(qemuio_blk);\n    if (bdrv_is_encrypted(bs) && bdrv_key_required(bs)) {\n        char password[256];\n        printf(\"Disk image '%s' is encrypted.\\n\", name);\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n            error_report(\"No password given\");\n            goto error;\n        }\n        if (bdrv_set_key(bs, password) < 0) {\n            error_report(\"invalid password\");\n            goto error;\n        }\n    }\n\n    blk_set_enable_write_cache(qemuio_blk, !writethrough);\n\n    return 0;\n\n error:\n    blk_unref(qemuio_blk);\n    qemuio_blk = NULL;\n    return 1;\n}\n\nstatic void open_help(void)\n{\n    printf(\n\"\\n\"\n\" opens a new file in the requested mode\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'open -n -o driver=raw /tmp/data' - opens raw data file read-write, uncached\\n\"\n\"\\n\"\n\" Opens a file for subsequent use by all of the other qemu-io commands.\\n\"\n\" -r, -- open file read-only\\n\"\n\" -s, -- use snapshot file\\n\"\n\" -n, -- disable host cache, short for -t none\\n\"\n\" -k, -- use kernel AIO implementation (on Linux only)\\n\"\n\" -t, -- use the given cache mode for the image\\n\"\n\" -d, -- use the given discard mode for the image\\n\"\n\" -o, -- options to be given to the block driver\"\n\"\\n\");\n}\n\nstatic int open_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t open_cmd = {\n    .name       = \"open\",\n    .altname    = \"o\",\n    .cfunc      = open_f,\n    .argmin     = 1,\n    .argmax     = -1,\n    .flags      = CMD_NOFILE_OK,\n    .args       = \"[-rsnk] [-t cache] [-d discard] [-o options] [path]\",\n    .oneline    = \"open the file specified by path\",\n    .help       = open_help,\n};\n\nstatic QemuOptsList empty_opts = {\n    .name = \"drive\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(empty_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic int open_f(BlockBackend *blk, int argc, char **argv)\n{\n    int flags = BDRV_O_UNMAP;\n    int readonly = 0;\n    bool writethrough = true;\n    int c;\n    QemuOpts *qopts;\n    QDict *opts;\n\n    while ((c = getopt(argc, argv, \"snro:kt:d:\")) != -1) {\n        switch (c) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            flags |= BDRV_O_NOCACHE;\n            writethrough = false;\n            break;\n        case 'r':\n            readonly = 1;\n            break;\n        case 'k':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 't':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                qemu_opts_reset(&empty_opts);\n                return 0;\n            }\n            break;\n        case 'd':\n            if (bdrv_parse_discard_flags(optarg, &flags) < 0) {\n                error_report(\"Invalid discard option: %s\", optarg);\n                qemu_opts_reset(&empty_opts);\n                return 0;\n            }\n            break;\n        case 'o':\n            if (imageOpts) {\n                printf(\"--image-opts and 'open -o' are mutually exclusive\\n\");\n                qemu_opts_reset(&empty_opts);\n                return 0;\n            }\n            if (!qemu_opts_parse_noisily(&empty_opts, optarg, false)) {\n                qemu_opts_reset(&empty_opts);\n                return 0;\n            }\n            break;\n        default:\n            qemu_opts_reset(&empty_opts);\n            return qemuio_command_usage(&open_cmd);\n        }\n    }\n\n    if (!readonly) {\n        flags |= BDRV_O_RDWR;\n    }\n\n    if (imageOpts && (optind == argc - 1)) {\n        if (!qemu_opts_parse_noisily(&empty_opts, argv[optind], false)) {\n            qemu_opts_reset(&empty_opts);\n            return 0;\n        }\n        optind++;\n    }\n\n    qopts = qemu_opts_find(&empty_opts, NULL);\n    opts = qopts ? qemu_opts_to_qdict(qopts, NULL) : NULL;\n    qemu_opts_reset(&empty_opts);\n\n    if (optind == argc - 1) {\n        return openfile(argv[optind], flags, writethrough, opts);\n    } else if (optind == argc) {\n        return openfile(NULL, flags, writethrough, opts);\n    } else {\n        QDECREF(opts);\n        return qemuio_command_usage(&open_cmd);\n    }\n}\n\nstatic int quit_f(BlockBackend *blk, int argc, char **argv)\n{\n    return 1;\n}\n\nstatic const cmdinfo_t quit_cmd = {\n    .name       = \"quit\",\n    .altname    = \"q\",\n    .cfunc      = quit_f,\n    .argmin     = -1,\n    .argmax     = -1,\n    .flags      = CMD_FLAG_GLOBAL,\n    .oneline    = \"exit the program\",\n};\n\nstatic void usage(const char *name)\n{\n    printf(\n\"Usage: %s [OPTIONS]... [-c STRING]... [file]\\n\"\n\"QEMU Disk exerciser\\n\"\n\"\\n\"\n\"  --object OBJECTDEF   define an object such as 'secret' for\\n\"\n\"                       passwords and/or encryption keys\\n\"\n\"  --image-opts         treat file as option string\\n\"\n\"  -c, --cmd STRING     execute command with its arguments\\n\"\n\"                       from the given string\\n\"\n\"  -f, --format FMT     specifies the block driver to use\\n\"\n\"  -r, --read-only      export read-only\\n\"\n\"  -s, --snapshot       use snapshot file\\n\"\n\"  -n, --nocache        disable host cache, short for -t none\\n\"\n\"  -m, --misalign       misalign allocations for O_DIRECT\\n\"\n\"  -k, --native-aio     use kernel AIO implementation (on Linux only)\\n\"\n\"  -t, --cache=MODE     use the given cache mode for the image\\n\"\n\"  -d, --discard=MODE   use the given discard mode for the image\\n\"\n\"  -T, --trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\"                       specify tracing options\\n\"\n\"                       see qemu-img(1) man page for full description\\n\"\n\"  -h, --help           display this help and exit\\n\"\n\"  -V, --version        output version information and exit\\n\"\n\"\\n\"\n\"See '%s -c help' for information on available commands.\"\n\"\\n\",\n    name, name);\n}\n\nstatic char *get_prompt(void)\n{\n    static char prompt[FILENAME_MAX + 2 /*\"> \"*/ + 1 /*\"\\0\"*/ ];\n\n    if (!prompt[0]) {\n        snprintf(prompt, sizeof(prompt), \"%s> \", progname);\n    }\n\n    return prompt;\n}\n\nstatic void GCC_FMT_ATTR(2, 3) readline_printf_func(void *opaque,\n                                                    const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    va_end(ap);\n}\n\nstatic void readline_flush_func(void *opaque)\n{\n    fflush(stdout);\n}\n\nstatic void readline_func(void *opaque, const char *str, void *readline_opaque)\n{\n    char **line = readline_opaque;\n    *line = g_strdup(str);\n}\n\nstatic void completion_match(const char *cmd, void *opaque)\n{\n    readline_add_completion(readline_state, cmd);\n}\n\nstatic void readline_completion_func(void *opaque, const char *str)\n{\n    readline_set_completion_index(readline_state, strlen(str));\n    qemuio_complete_command(str, completion_match, NULL);\n}\n\nstatic char *fetchline_readline(void)\n{\n    char *line = NULL;\n\n    readline_start(readline_state, get_prompt(), 0, readline_func, &line);\n    while (!line) {\n        int ch = getchar();\n        if (ch == EOF) {\n            break;\n        }\n        readline_handle_byte(readline_state, ch);\n    }\n    return line;\n}\n\n#define MAXREADLINESZ 1024\nstatic char *fetchline_fgets(void)\n{\n    char *p, *line = g_malloc(MAXREADLINESZ);\n\n    if (!fgets(line, MAXREADLINESZ, stdin)) {\n        g_free(line);\n        return NULL;\n    }\n\n    p = line + strlen(line);\n    if (p != line && p[-1] == '\\n') {\n        p[-1] = '\\0';\n    }\n\n    return line;\n}\n\nstatic char *fetchline(void)\n{\n    if (readline_state) {\n        return fetchline_readline();\n    } else {\n        return fetchline_fgets();\n    }\n}\n\nstatic void prep_fetchline(void *opaque)\n{\n    int *fetchable = opaque;\n\n    qemu_set_fd_handler(STDIN_FILENO, NULL, NULL, NULL);\n    *fetchable= 1;\n}\n\nstatic void command_loop(void)\n{\n    int i, done = 0, fetchable = 0, prompted = 0;\n    char *input;\n\n    for (i = 0; !done && i < ncmdline; i++) {\n        done = qemuio_command(qemuio_blk, cmdline[i]);\n    }\n    if (cmdline) {\n        g_free(cmdline);\n        return;\n    }\n\n    while (!done) {\n        if (!prompted) {\n            printf(\"%s\", get_prompt());\n            fflush(stdout);\n            qemu_set_fd_handler(STDIN_FILENO, prep_fetchline, NULL, &fetchable);\n            prompted = 1;\n        }\n\n        main_loop_wait(false);\n\n        if (!fetchable) {\n            continue;\n        }\n\n        input = fetchline();\n        if (input == NULL) {\n            break;\n        }\n        done = qemuio_command(qemuio_blk, input);\n        g_free(input);\n\n        prompted = 0;\n        fetchable = 0;\n    }\n    qemu_set_fd_handler(STDIN_FILENO, NULL, NULL, NULL);\n}\n\nstatic void add_user_command(char *optarg)\n{\n    cmdline = g_renew(char *, cmdline, ++ncmdline);\n    cmdline[ncmdline-1] = optarg;\n}\n\nstatic void reenable_tty_echo(void)\n{\n    qemu_set_tty_echo(STDIN_FILENO, true);\n}\n\nenum {\n    OPTION_OBJECT = 256,\n    OPTION_IMAGE_OPTS = 257,\n};\n\nstatic QemuOptsList qemu_object_opts = {\n    .name = \"object\",\n    .implied_opt_name = \"qom-type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_object_opts.head),\n    .desc = {\n        { }\n    },\n};\n\n\nstatic QemuOptsList file_opts = {\n    .name = \"file\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(file_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nint main(int argc, char **argv)\n{\n    int readonly = 0;\n    const char *sopt = \"hVc:d:f:rsnmkt:T:\";\n    const struct option lopt[] = {\n        { \"help\", no_argument, NULL, 'h' },\n        { \"version\", no_argument, NULL, 'V' },\n        { \"cmd\", required_argument, NULL, 'c' },\n        { \"format\", required_argument, NULL, 'f' },\n        { \"read-only\", no_argument, NULL, 'r' },\n        { \"snapshot\", no_argument, NULL, 's' },\n        { \"nocache\", no_argument, NULL, 'n' },\n        { \"misalign\", no_argument, NULL, 'm' },\n        { \"native-aio\", no_argument, NULL, 'k' },\n        { \"discard\", required_argument, NULL, 'd' },\n        { \"cache\", required_argument, NULL, 't' },\n        { \"trace\", required_argument, NULL, 'T' },\n        { \"object\", required_argument, NULL, OPTION_OBJECT },\n        { \"image-opts\", no_argument, NULL, OPTION_IMAGE_OPTS },\n        { NULL, 0, NULL, 0 }\n    };\n    int c;\n    int opt_index = 0;\n    int flags = BDRV_O_UNMAP;\n    bool writethrough = true;\n    Error *local_error = NULL;\n    QDict *opts = NULL;\n    const char *format = NULL;\n    char *trace_file = NULL;\n\n#ifdef CONFIG_POSIX\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n    module_call_init(MODULE_INIT_TRACE);\n    progname = basename(argv[0]);\n    qemu_init_exec_dir(argv[0]);\n\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_trace_opts);\n    bdrv_init();\n\n    while ((c = getopt_long(argc, argv, sopt, lopt, &opt_index)) != -1) {\n        switch (c) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            flags |= BDRV_O_NOCACHE;\n            writethrough = false;\n            break;\n        case 'd':\n            if (bdrv_parse_discard_flags(optarg, &flags) < 0) {\n                error_report(\"Invalid discard option: %s\", optarg);\n                exit(1);\n            }\n            break;\n        case 'f':\n            format = optarg;\n            break;\n        case 'c':\n            add_user_command(optarg);\n            break;\n        case 'r':\n            readonly = 1;\n            break;\n        case 'm':\n            qemuio_misalign = true;\n            break;\n        case 'k':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 't':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                exit(1);\n            }\n            break;\n        case 'T':\n            g_free(trace_file);\n            trace_file = trace_opt_parse(optarg);\n            break;\n        case 'V':\n            printf(\"%s version %s\\n\", progname, QEMU_VERSION);\n            exit(0);\n        case 'h':\n            usage(progname);\n            exit(0);\n        case OPTION_OBJECT: {\n            QemuOpts *qopts;\n            qopts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                            optarg, true);\n            if (!qopts) {\n                exit(1);\n            }\n        }   break;\n        case OPTION_IMAGE_OPTS:\n            imageOpts = true;\n            break;\n        default:\n            usage(progname);\n            exit(1);\n        }\n    }\n\n    if ((argc - optind) > 1) {\n        usage(progname);\n        exit(1);\n    }\n\n    if (format && imageOpts) {\n        error_report(\"--image-opts and -f are mutually exclusive\");\n        exit(1);\n    }\n\n    if (qemu_init_main_loop(&local_error)) {\n        error_report_err(local_error);\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        exit(1);\n    }\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file(trace_file);\n    qemu_set_log(LOG_TRACE);\n\n    /* initialize commands */\n    qemuio_add_command(&quit_cmd);\n    qemuio_add_command(&open_cmd);\n    qemuio_add_command(&close_cmd);\n\n    if (isatty(STDIN_FILENO)) {\n        readline_state = readline_init(readline_printf_func,\n                                       readline_flush_func,\n                                       NULL,\n                                       readline_completion_func);\n        qemu_set_tty_echo(STDIN_FILENO, false);\n        atexit(reenable_tty_echo);\n    }\n\n    /* open the device */\n    if (!readonly) {\n        flags |= BDRV_O_RDWR;\n    }\n\n    if ((argc - optind) == 1) {\n        if (imageOpts) {\n            QemuOpts *qopts = NULL;\n            qopts = qemu_opts_parse_noisily(&file_opts, argv[optind], false);\n            if (!qopts) {\n                exit(1);\n            }\n            opts = qemu_opts_to_qdict(qopts, NULL);\n            if (openfile(NULL, flags, writethrough, opts)) {\n                exit(1);\n            }\n        } else {\n            if (format) {\n                opts = qdict_new();\n                qdict_put_str(opts, \"driver\", format);\n            }\n            if (openfile(argv[optind], flags, writethrough, opts)) {\n                exit(1);\n            }\n        }\n    }\n    command_loop();\n\n    /*\n     * Make sure all outstanding requests complete before the program exits.\n     */\n    bdrv_drain_all();\n\n    blk_unref(qemuio_blk);\n    g_free(readline_state);\n    return 0;\n}\n"
        },
        {
          "name": "qemu-nbd.c",
          "type": "blob",
          "size": 32.984375,
          "content": "/*\n *  Copyright (C) 2005  Anthony Liguori <anthony@codemonkey.ws>\n *\n *  Network Block Device\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; under version 2 of the License.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu-common.h\"\n#include \"qemu/cutils.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block_int.h\"\n#include \"block/nbd.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/bswap.h\"\n#include \"qemu/log.h\"\n#include \"qemu/systemd.h\"\n#include \"block/snapshot.h\"\n#include \"qapi/util.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qom/object_interfaces.h\"\n#include \"io/channel-socket.h\"\n#include \"crypto/init.h\"\n#include \"trace/control.h\"\n\n#include <getopt.h>\n#include <libgen.h>\n#include <pthread.h>\n\n#define SOCKET_PATH                \"/var/lock/panda-nbd-%s\"\n#define QEMU_NBD_OPT_CACHE         256\n#define QEMU_NBD_OPT_AIO           257\n#define QEMU_NBD_OPT_DISCARD       258\n#define QEMU_NBD_OPT_DETECT_ZEROES 259\n#define QEMU_NBD_OPT_OBJECT        260\n#define QEMU_NBD_OPT_TLSCREDS      261\n#define QEMU_NBD_OPT_IMAGE_OPTS    262\n#define QEMU_NBD_OPT_FORK          263\n\n#define MBR_SIZE 512\n\nstatic NBDExport *exp;\nstatic bool newproto;\nstatic int verbose;\nstatic char *srcpath;\nstatic SocketAddress *saddr;\nstatic int persistent = 0;\nstatic enum { RUNNING, TERMINATE, TERMINATING, TERMINATED } state;\nstatic int shared = 1;\nstatic int nb_fds;\nstatic QIOChannelSocket *server_ioc;\nstatic int server_watch = -1;\nstatic QCryptoTLSCreds *tlscreds;\n\nstatic void usage(const char *name)\n{\n    (printf) (\n\"Usage: %s [OPTIONS] FILE\\n\"\n\"QEMU Disk Network Block Device Server\\n\"\n\"\\n\"\n\"  -h, --help                display this help and exit\\n\"\n\"  -V, --version             output version information and exit\\n\"\n\"\\n\"\n\"Connection properties:\\n\"\n\"  -p, --port=PORT           port to listen on (default `%d')\\n\"\n\"  -b, --bind=IFACE          interface to bind to (default `0.0.0.0')\\n\"\n\"  -k, --socket=PATH         path to the unix socket\\n\"\n\"                            (default '\"SOCKET_PATH\"')\\n\"\n\"  -e, --shared=NUM          device can be shared by NUM clients (default '1')\\n\"\n\"  -t, --persistent          don't exit on the last connection\\n\"\n\"  -v, --verbose             display extra debugging information\\n\"\n\"  -x, --export-name=NAME    expose export by name\\n\"\n\"  -D, --description=TEXT    with -x, also export a human-readable description\\n\"\n\"\\n\"\n\"Exposing part of the image:\\n\"\n\"  -o, --offset=OFFSET       offset into the image\\n\"\n\"  -P, --partition=NUM       only expose partition NUM\\n\"\n\"\\n\"\n\"General purpose options:\\n\"\n\"  --object type,id=ID,...   define an object such as 'secret' for providing\\n\"\n\"                            passwords and/or encryption keys\\n\"\n\"  -T, --trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\"                            specify tracing options\\n\"\n\"  --fork                    fork off the server process and exit the parent\\n\"\n\"                            once the server is running\\n\"\n#ifdef __linux__\n\"Kernel NBD client support:\\n\"\n\"  -c, --connect=DEV         connect FILE to the local NBD device DEV\\n\"\n\"  -d, --disconnect          disconnect the specified device\\n\"\n\"\\n\"\n#endif\n\"\\n\"\n\"Block device options:\\n\"\n\"  -f, --format=FORMAT       set image format (raw, qcow2, ...)\\n\"\n\"  -r, --read-only           export read-only\\n\"\n\"  -s, --snapshot            use FILE as an external snapshot, create a temporary\\n\"\n\"                            file with backing_file=FILE, redirect the write to\\n\"\n\"                            the temporary one\\n\"\n\"  -l, --load-snapshot=SNAPSHOT_PARAM\\n\"\n\"                            load an internal snapshot inside FILE and export it\\n\"\n\"                            as an read-only device, SNAPSHOT_PARAM format is\\n\"\n\"                            'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\"                            '[ID_OR_NAME]'\\n\"\n\"  -n, --nocache             disable host cache\\n\"\n\"      --cache=MODE          set cache mode (none, writeback, ...)\\n\"\n\"      --aio=MODE            set AIO mode (native or threads)\\n\"\n\"      --discard=MODE        set discard mode (ignore, unmap)\\n\"\n\"      --detect-zeroes=MODE  set detect-zeroes mode (off, on, unmap)\\n\"\n\"      --image-opts          treat FILE as a full set of image options\\n\"\n\"\\n\"\n\"Report bugs to <qemu-devel@nongnu.org>\\n\"\n    , name, NBD_DEFAULT_PORT, \"DEVICE\");\n}\n\nstatic void version(const char *name)\n{\n    printf(\n\"%s version 0.0.1\\n\"\n\"Written by Anthony Liguori.\\n\"\n\"\\n\"\n\"Copyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>.\\n\"\n\"This is free software; see the source for copying conditions.  There is NO\\n\"\n\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\"\n    , name);\n}\n\nstruct partition_record\n{\n    uint8_t bootable;\n    uint8_t start_head;\n    uint32_t start_cylinder;\n    uint8_t start_sector;\n    uint8_t system;\n    uint8_t end_head;\n    uint8_t end_cylinder;\n    uint8_t end_sector;\n    uint32_t start_sector_abs;\n    uint32_t nb_sectors_abs;\n};\n\nstatic void read_partition(uint8_t *p, struct partition_record *r)\n{\n    r->bootable = p[0];\n    r->start_head = p[1];\n    r->start_cylinder = p[3] | ((p[2] << 2) & 0x0300);\n    r->start_sector = p[2] & 0x3f;\n    r->system = p[4];\n    r->end_head = p[5];\n    r->end_cylinder = p[7] | ((p[6] << 2) & 0x300);\n    r->end_sector = p[6] & 0x3f;\n\n    r->start_sector_abs = ldl_le_p(p + 8);\n    r->nb_sectors_abs   = ldl_le_p(p + 12);\n}\n\nstatic int find_partition(BlockBackend *blk, int partition,\n                          off_t *offset, off_t *size)\n{\n    struct partition_record mbr[4];\n    uint8_t data[MBR_SIZE];\n    int i;\n    int ext_partnum = 4;\n    int ret;\n\n    ret = blk_pread(blk, 0, data, sizeof(data));\n    if (ret < 0) {\n        error_report(\"error while reading: %s\", strerror(-ret));\n        exit(EXIT_FAILURE);\n    }\n\n    if (data[510] != 0x55 || data[511] != 0xaa) {\n        return -EINVAL;\n    }\n\n    for (i = 0; i < 4; i++) {\n        read_partition(&data[446 + 16 * i], &mbr[i]);\n\n        if (!mbr[i].system || !mbr[i].nb_sectors_abs) {\n            continue;\n        }\n\n        if (mbr[i].system == 0xF || mbr[i].system == 0x5) {\n            struct partition_record ext[4];\n            uint8_t data1[MBR_SIZE];\n            int j;\n\n            ret = blk_pread(blk, mbr[i].start_sector_abs * MBR_SIZE,\n                            data1, sizeof(data1));\n            if (ret < 0) {\n                error_report(\"error while reading: %s\", strerror(-ret));\n                exit(EXIT_FAILURE);\n            }\n\n            for (j = 0; j < 4; j++) {\n                read_partition(&data1[446 + 16 * j], &ext[j]);\n                if (!ext[j].system || !ext[j].nb_sectors_abs) {\n                    continue;\n                }\n\n                if ((ext_partnum + j + 1) == partition) {\n                    *offset = (uint64_t)ext[j].start_sector_abs << 9;\n                    *size = (uint64_t)ext[j].nb_sectors_abs << 9;\n                    return 0;\n                }\n            }\n            ext_partnum += 4;\n        } else if ((i + 1) == partition) {\n            *offset = (uint64_t)mbr[i].start_sector_abs << 9;\n            *size = (uint64_t)mbr[i].nb_sectors_abs << 9;\n            return 0;\n        }\n    }\n\n    return -ENOENT;\n}\n\nstatic void termsig_handler(int signum)\n{\n    atomic_cmpxchg(&state, RUNNING, TERMINATE);\n    qemu_notify_event();\n}\n\n\nstatic void *show_parts(void *arg)\n{\n    char *device = arg;\n    int nbd;\n\n    /* linux just needs an open() to trigger\n     * the partition table update\n     * but remember to load the module with max_part != 0 :\n     *     modprobe nbd max_part=63\n     */\n    nbd = open(device, O_RDWR);\n    if (nbd >= 0) {\n        close(nbd);\n    }\n    return NULL;\n}\n\nstatic void *nbd_client_thread(void *arg)\n{\n    char *device = arg;\n    off_t size;\n    uint16_t nbdflags;\n    QIOChannelSocket *sioc;\n    int fd;\n    int ret;\n    pthread_t show_parts_thread;\n    Error *local_error = NULL;\n\n    sioc = qio_channel_socket_new();\n    if (qio_channel_socket_connect_sync(sioc,\n                                        saddr,\n                                        &local_error) < 0) {\n        error_report_err(local_error);\n        goto out;\n    }\n\n    ret = nbd_receive_negotiate(QIO_CHANNEL(sioc), NULL, &nbdflags,\n                                NULL, NULL, NULL,\n                                &size, &local_error);\n    if (ret < 0) {\n        if (local_error) {\n            error_report_err(local_error);\n        }\n        goto out_socket;\n    }\n\n    fd = open(device, O_RDWR);\n    if (fd < 0) {\n        /* Linux-only, we can use %m in printf.  */\n        error_report(\"Failed to open %s: %m\", device);\n        goto out_socket;\n    }\n\n    ret = nbd_init(fd, sioc, nbdflags, size);\n    if (ret < 0) {\n        goto out_fd;\n    }\n\n    /* update partition table */\n    pthread_create(&show_parts_thread, NULL, show_parts, device);\n\n    if (verbose) {\n        fprintf(stderr, \"NBD device %s is now connected to %s\\n\",\n                device, srcpath);\n    } else {\n        /* Close stderr so that the qemu-nbd process exits.  */\n        dup2(STDOUT_FILENO, STDERR_FILENO);\n    }\n\n    ret = nbd_client(fd);\n    if (ret) {\n        goto out_fd;\n    }\n    close(fd);\n    object_unref(OBJECT(sioc));\n    kill(getpid(), SIGTERM);\n    return (void *) EXIT_SUCCESS;\n\nout_fd:\n    close(fd);\nout_socket:\n    object_unref(OBJECT(sioc));\nout:\n    kill(getpid(), SIGTERM);\n    return (void *) EXIT_FAILURE;\n}\n\nstatic int nbd_can_accept(void)\n{\n    return state == RUNNING && nb_fds < shared;\n}\n\nstatic void nbd_export_closed(NBDExport *exp)\n{\n    assert(state == TERMINATING);\n    state = TERMINATED;\n}\n\nstatic void nbd_update_server_watch(void);\n\nstatic void nbd_client_closed(NBDClient *client, bool negotiated)\n{\n    nb_fds--;\n    if (negotiated && nb_fds == 0 && !persistent && state == RUNNING) {\n        state = TERMINATE;\n    }\n    nbd_update_server_watch();\n    nbd_client_put(client);\n}\n\nstatic gboolean nbd_accept(QIOChannel *ioc, GIOCondition cond, gpointer opaque)\n{\n    QIOChannelSocket *cioc;\n\n    cioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc),\n                                     NULL);\n    if (!cioc) {\n        return TRUE;\n    }\n\n    if (state >= TERMINATE) {\n        object_unref(OBJECT(cioc));\n        return TRUE;\n    }\n\n    nb_fds++;\n    nbd_update_server_watch();\n    nbd_client_new(newproto ? NULL : exp, cioc,\n                   tlscreds, NULL, nbd_client_closed);\n    object_unref(OBJECT(cioc));\n\n    return TRUE;\n}\n\nstatic void nbd_update_server_watch(void)\n{\n    if (nbd_can_accept()) {\n        if (server_watch == -1) {\n            server_watch = qio_channel_add_watch(QIO_CHANNEL(server_ioc),\n                                                 G_IO_IN,\n                                                 nbd_accept,\n                                                 NULL, NULL);\n        }\n    } else {\n        if (server_watch != -1) {\n            g_source_remove(server_watch);\n            server_watch = -1;\n        }\n    }\n}\n\n\nstatic SocketAddress *nbd_build_socket_address(const char *sockpath,\n                                               const char *bindto,\n                                               const char *port)\n{\n    SocketAddress *saddr;\n\n    saddr = g_new0(SocketAddress, 1);\n    if (sockpath) {\n        saddr->type = SOCKET_ADDRESS_KIND_UNIX;\n        saddr->u.q_unix.data = g_new0(UnixSocketAddress, 1);\n        saddr->u.q_unix.data->path = g_strdup(sockpath);\n    } else {\n        InetSocketAddress *inet;\n        saddr->type = SOCKET_ADDRESS_KIND_INET;\n        inet = saddr->u.inet.data = g_new0(InetSocketAddress, 1);\n        inet->host = g_strdup(bindto);\n        if (port) {\n            inet->port = g_strdup(port);\n        } else  {\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n        }\n    }\n\n    return saddr;\n}\n\n\nstatic QemuOptsList file_opts = {\n    .name = \"file\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(file_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_object_opts = {\n    .name = \"object\",\n    .implied_opt_name = \"qom-type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_object_opts.head),\n    .desc = {\n        { }\n    },\n};\n\n\n\nstatic QCryptoTLSCreds *nbd_get_tls_creds(const char *id, Error **errp)\n{\n    Object *obj;\n    QCryptoTLSCreds *creds;\n\n    obj = object_resolve_path_component(\n        object_get_objects_root(), id);\n    if (!obj) {\n        error_setg(errp, \"No TLS credentials with id '%s'\",\n                   id);\n        return NULL;\n    }\n    creds = (QCryptoTLSCreds *)\n        object_dynamic_cast(obj, TYPE_QCRYPTO_TLS_CREDS);\n    if (!creds) {\n        error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                   id);\n        return NULL;\n    }\n\n    if (creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n        error_setg(errp,\n                   \"Expecting TLS credentials with a server endpoint\");\n        return NULL;\n    }\n    object_ref(obj);\n    return creds;\n}\n\nstatic void setup_address_and_port(const char **address, const char **port)\n{\n    if (*address == NULL) {\n        *address = \"0.0.0.0\";\n    }\n\n    if (*port == NULL) {\n        *port = stringify(NBD_DEFAULT_PORT);\n    }\n}\n\n/*\n * Check socket parameters compatibility when socket activation is used.\n */\nstatic const char *socket_activation_validate_opts(const char *device,\n                                                   const char *sockpath,\n                                                   const char *address,\n                                                   const char *port)\n{\n    if (device != NULL) {\n        return \"NBD device can't be set when using socket activation\";\n    }\n\n    if (sockpath != NULL) {\n        return \"Unix socket can't be set when using socket activation\";\n    }\n\n    if (address != NULL) {\n        return \"The interface can't be set when using socket activation\";\n    }\n\n    if (port != NULL) {\n        return \"TCP port number can't be set when using socket activation\";\n    }\n\n    return NULL;\n}\n\nint main(int argc, char **argv)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    off_t dev_offset = 0;\n    uint16_t nbdflags = 0;\n    bool disconnect = false;\n    const char *bindto = NULL;\n    const char *port = NULL;\n    char *sockpath = NULL;\n    char *device = NULL;\n    off_t fd_size;\n    QemuOpts *sn_opts = NULL;\n    const char *sn_id_or_name = NULL;\n    const char *sopt = \"hVb:o:p:rsnP:c:dvk:e:f:tl:x:T:D:\";\n    struct option lopt[] = {\n        { \"help\", no_argument, NULL, 'h' },\n        { \"version\", no_argument, NULL, 'V' },\n        { \"bind\", required_argument, NULL, 'b' },\n        { \"port\", required_argument, NULL, 'p' },\n        { \"socket\", required_argument, NULL, 'k' },\n        { \"offset\", required_argument, NULL, 'o' },\n        { \"read-only\", no_argument, NULL, 'r' },\n        { \"partition\", required_argument, NULL, 'P' },\n        { \"connect\", required_argument, NULL, 'c' },\n        { \"disconnect\", no_argument, NULL, 'd' },\n        { \"snapshot\", no_argument, NULL, 's' },\n        { \"load-snapshot\", required_argument, NULL, 'l' },\n        { \"nocache\", no_argument, NULL, 'n' },\n        { \"cache\", required_argument, NULL, QEMU_NBD_OPT_CACHE },\n        { \"aio\", required_argument, NULL, QEMU_NBD_OPT_AIO },\n        { \"discard\", required_argument, NULL, QEMU_NBD_OPT_DISCARD },\n        { \"detect-zeroes\", required_argument, NULL,\n          QEMU_NBD_OPT_DETECT_ZEROES },\n        { \"shared\", required_argument, NULL, 'e' },\n        { \"format\", required_argument, NULL, 'f' },\n        { \"persistent\", no_argument, NULL, 't' },\n        { \"verbose\", no_argument, NULL, 'v' },\n        { \"object\", required_argument, NULL, QEMU_NBD_OPT_OBJECT },\n        { \"export-name\", required_argument, NULL, 'x' },\n        { \"description\", required_argument, NULL, 'D' },\n        { \"tls-creds\", required_argument, NULL, QEMU_NBD_OPT_TLSCREDS },\n        { \"image-opts\", no_argument, NULL, QEMU_NBD_OPT_IMAGE_OPTS },\n        { \"trace\", required_argument, NULL, 'T' },\n        { \"fork\", no_argument, NULL, QEMU_NBD_OPT_FORK },\n        { NULL, 0, NULL, 0 }\n    };\n    int ch;\n    int opt_ind = 0;\n    char *end;\n    int flags = BDRV_O_RDWR;\n    int partition = -1;\n    int ret = 0;\n    bool seen_cache = false;\n    bool seen_discard = false;\n    bool seen_aio = false;\n    pthread_t client_thread;\n    const char *fmt = NULL;\n    Error *local_err = NULL;\n    BlockdevDetectZeroesOptions detect_zeroes = BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n    QDict *options = NULL;\n    const char *export_name = NULL;\n    const char *export_description = NULL;\n    const char *tlscredsid = NULL;\n    bool imageOpts = false;\n    bool writethrough = true;\n    char *trace_file = NULL;\n    bool fork_process = false;\n    int old_stderr = -1;\n    unsigned socket_activation;\n\n    /* The client thread uses SIGTERM to interrupt the server.  A signal\n     * handler ensures that \"qemu-nbd -v -c\" exits with a nice status code.\n     */\n    struct sigaction sa_sigterm;\n    memset(&sa_sigterm, 0, sizeof(sa_sigterm));\n    sa_sigterm.sa_handler = termsig_handler;\n    sigaction(SIGTERM, &sa_sigterm, NULL);\n\n#ifdef CONFIG_POSIX\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n    module_call_init(MODULE_INIT_TRACE);\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_trace_opts);\n    qemu_init_exec_dir(argv[0]);\n\n    while ((ch = getopt_long(argc, argv, sopt, lopt, &opt_ind)) != -1) {\n        switch (ch) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            optarg = (char *) \"none\";\n            /* fallthrough */\n        case QEMU_NBD_OPT_CACHE:\n            if (seen_cache) {\n                error_report(\"-n and --cache can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_cache = true;\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) == -1) {\n                error_report(\"Invalid cache mode `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_AIO:\n            if (seen_aio) {\n                error_report(\"--aio can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_aio = true;\n            if (!strcmp(optarg, \"native\")) {\n                flags |= BDRV_O_NATIVE_AIO;\n            } else if (!strcmp(optarg, \"threads\")) {\n                /* this is the default */\n            } else {\n               error_report(\"invalid aio mode `%s'\", optarg);\n               exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_DISCARD:\n            if (seen_discard) {\n                error_report(\"--discard can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_discard = true;\n            if (bdrv_parse_discard_flags(optarg, &flags) == -1) {\n                error_report(\"Invalid discard mode `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_DETECT_ZEROES:\n            detect_zeroes =\n                qapi_enum_parse(BlockdevDetectZeroesOptions_lookup,\n                                optarg,\n                                BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX,\n                                BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n                                &local_err);\n            if (local_err) {\n                error_reportf_err(local_err,\n                                  \"Failed to parse detect_zeroes mode: \");\n                exit(EXIT_FAILURE);\n            }\n            if (detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n                !(flags & BDRV_O_UNMAP)) {\n                error_report(\"setting detect-zeroes to unmap is not allowed \"\n                             \"without setting discard operation to unmap\");\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'b':\n            bindto = optarg;\n            break;\n        case 'p':\n            port = optarg;\n            break;\n        case 'o':\n                dev_offset = strtoll (optarg, &end, 0);\n            if (*end) {\n                error_report(\"Invalid offset `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            if (dev_offset < 0) {\n                error_report(\"Offset must be positive `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'l':\n            if (strstart(optarg, SNAPSHOT_OPT_BASE, NULL)) {\n                sn_opts = qemu_opts_parse_noisily(&internal_snapshot_opts,\n                                                  optarg, false);\n                if (!sn_opts) {\n                    error_report(\"Failed in parsing snapshot param `%s'\",\n                                 optarg);\n                    exit(EXIT_FAILURE);\n                }\n            } else {\n                sn_id_or_name = optarg;\n            }\n            /* fall through */\n        case 'r':\n            nbdflags |= NBD_FLAG_READ_ONLY;\n            flags &= ~BDRV_O_RDWR;\n            break;\n        case 'P':\n            partition = strtol(optarg, &end, 0);\n            if (*end) {\n                error_report(\"Invalid partition `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            if (partition < 1 || partition > 8) {\n                error_report(\"Invalid partition %d\", partition);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'k':\n            sockpath = optarg;\n            if (sockpath[0] != '/') {\n                error_report(\"socket path must be absolute\");\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'd':\n            disconnect = true;\n            break;\n        case 'c':\n            device = optarg;\n            break;\n        case 'e':\n            shared = strtol(optarg, &end, 0);\n            if (*end) {\n                error_report(\"Invalid shared device number '%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            if (shared < 1) {\n                error_report(\"Shared device number must be greater than 0\");\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            persistent = 1;\n            break;\n        case 'x':\n            export_name = optarg;\n            break;\n        case 'D':\n            export_description = optarg;\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'V':\n            version(argv[0]);\n            exit(0);\n            break;\n        case 'h':\n            usage(argv[0]);\n            exit(0);\n            break;\n        case '?':\n            error_report(\"Try `%s --help' for more information.\", argv[0]);\n            exit(EXIT_FAILURE);\n        case QEMU_NBD_OPT_OBJECT: {\n            QemuOpts *opts;\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n                                           optarg, true);\n            if (!opts) {\n                exit(EXIT_FAILURE);\n            }\n        }   break;\n        case QEMU_NBD_OPT_TLSCREDS:\n            tlscredsid = optarg;\n            break;\n        case QEMU_NBD_OPT_IMAGE_OPTS:\n            imageOpts = true;\n            break;\n        case 'T':\n            g_free(trace_file);\n            trace_file = trace_opt_parse(optarg);\n            break;\n        case QEMU_NBD_OPT_FORK:\n            fork_process = true;\n            break;\n        }\n    }\n\n    if ((argc - optind) != 1) {\n        error_report(\"Invalid number of arguments\");\n        error_printf(\"Try `%s --help' for more information.\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n                          user_creatable_add_opts_foreach,\n                          NULL, NULL)) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file(trace_file);\n    qemu_set_log(LOG_TRACE);\n\n    socket_activation = check_socket_activation();\n    if (socket_activation == 0) {\n        setup_address_and_port(&bindto, &port);\n    } else {\n        /* Using socket activation - check user didn't use -p etc. */\n        const char *err_msg = socket_activation_validate_opts(device, sockpath,\n                                                              bindto, port);\n        if (err_msg != NULL) {\n            error_report(\"%s\", err_msg);\n            exit(EXIT_FAILURE);\n        }\n\n        /* qemu-nbd can only listen on a single socket.  */\n        if (socket_activation > 1) {\n            error_report(\"qemu-nbd does not support socket activation with %s > 1\",\n                         \"LISTEN_FDS\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (tlscredsid) {\n        if (sockpath) {\n            error_report(\"TLS is only supported with IPv4/IPv6\");\n            exit(EXIT_FAILURE);\n        }\n        if (device) {\n            error_report(\"TLS is not supported with a host device\");\n            exit(EXIT_FAILURE);\n        }\n        if (!export_name) {\n            /* Set the default NBD protocol export name, since\n             * we *must* use new style protocol for TLS */\n            export_name = \"\";\n        }\n        tlscreds = nbd_get_tls_creds(tlscredsid, &local_err);\n        if (local_err) {\n            error_report(\"Failed to get TLS creds %s\",\n                         error_get_pretty(local_err));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (disconnect) {\n        int nbdfd = open(argv[optind], O_RDWR);\n        if (nbdfd < 0) {\n            error_report(\"Cannot open %s: %s\", argv[optind],\n                         strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        nbd_disconnect(nbdfd);\n\n        close(nbdfd);\n\n        printf(\"%s disconnected\\n\", argv[optind]);\n\n        return 0;\n    }\n\n    if ((device && !verbose) || fork_process) {\n        int stderr_fd[2];\n        pid_t pid;\n        int ret;\n\n        if (qemu_pipe(stderr_fd) < 0) {\n            error_report(\"Error setting up communication pipe: %s\",\n                         strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n\n        /* Now daemonize, but keep a communication channel open to\n         * print errors and exit with the proper status code.\n         */\n        pid = fork();\n        if (pid < 0) {\n            error_report(\"Failed to fork: %s\", strerror(errno));\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            close(stderr_fd[0]);\n            ret = qemu_daemon(1, 0);\n\n            /* Temporarily redirect stderr to the parent's pipe...  */\n            old_stderr = dup(STDERR_FILENO);\n            dup2(stderr_fd[1], STDERR_FILENO);\n            if (ret < 0) {\n                error_report(\"Failed to daemonize: %s\", strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n\n            /* ... close the descriptor we inherited and go on.  */\n            close(stderr_fd[1]);\n        } else {\n            bool errors = false;\n            char *buf;\n\n            /* In the parent.  Print error messages from the child until\n             * it closes the pipe.\n             */\n            close(stderr_fd[1]);\n            buf = g_malloc(1024);\n            while ((ret = read(stderr_fd[0], buf, 1024)) > 0) {\n                errors = true;\n                ret = qemu_write_full(STDERR_FILENO, buf, ret);\n                if (ret < 0) {\n                    exit(EXIT_FAILURE);\n                }\n            }\n            if (ret < 0) {\n                error_report(\"Cannot read from daemon: %s\",\n                             strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n\n            /* Usually the daemon should not print any message.\n             * Exit with zero status in that case.\n             */\n            exit(errors);\n        }\n    }\n\n    if (device != NULL && sockpath == NULL) {\n        sockpath = g_malloc(128);\n        snprintf(sockpath, 128, SOCKET_PATH, basename(device));\n    }\n\n    if (socket_activation == 0) {\n        server_ioc = qio_channel_socket_new();\n        saddr = nbd_build_socket_address(sockpath, bindto, port);\n        if (qio_channel_socket_listen_sync(server_ioc, saddr, &local_err) < 0) {\n            object_unref(OBJECT(server_ioc));\n            error_report_err(local_err);\n            return 1;\n        }\n    } else {\n        /* See comment in check_socket_activation above. */\n        assert(socket_activation == 1);\n        server_ioc = qio_channel_socket_new_fd(FIRST_SOCKET_ACTIVATION_FD,\n                                               &local_err);\n        if (server_ioc == NULL) {\n            error_report(\"Failed to use socket activation: %s\",\n                         error_get_pretty(local_err));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (qemu_init_main_loop(&local_err)) {\n        error_report_err(local_err);\n        exit(EXIT_FAILURE);\n    }\n    bdrv_init();\n    atexit(bdrv_close_all);\n\n    srcpath = argv[optind];\n    if (imageOpts) {\n        QemuOpts *opts;\n        if (fmt) {\n            error_report(\"--image-opts and -f are mutually exclusive\");\n            exit(EXIT_FAILURE);\n        }\n        opts = qemu_opts_parse_noisily(&file_opts, srcpath, true);\n        if (!opts) {\n            qemu_opts_reset(&file_opts);\n            exit(EXIT_FAILURE);\n        }\n        options = qemu_opts_to_qdict(opts, NULL);\n        qemu_opts_reset(&file_opts);\n        blk = blk_new_open(NULL, NULL, options, flags, &local_err);\n    } else {\n        if (fmt) {\n            options = qdict_new();\n            qdict_put_str(options, \"driver\", fmt);\n        }\n        blk = blk_new_open(srcpath, NULL, options, flags, &local_err);\n    }\n\n    if (!blk) {\n        error_reportf_err(local_err, \"Failed to blk_new_open '%s': \",\n                          argv[optind]);\n        exit(EXIT_FAILURE);\n    }\n    bs = blk_bs(blk);\n\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    if (sn_opts) {\n        ret = bdrv_snapshot_load_tmp(bs,\n                                     qemu_opt_get(sn_opts, SNAPSHOT_OPT_ID),\n                                     qemu_opt_get(sn_opts, SNAPSHOT_OPT_NAME),\n                                     &local_err);\n    } else if (sn_id_or_name) {\n        ret = bdrv_snapshot_load_tmp_by_id_or_name(bs, sn_id_or_name,\n                                                   &local_err);\n    }\n    if (ret < 0) {\n        error_reportf_err(local_err, \"Failed to load snapshot: \");\n        exit(EXIT_FAILURE);\n    }\n\n    bs->detect_zeroes = detect_zeroes;\n    fd_size = blk_getlength(blk);\n    if (fd_size < 0) {\n        error_report(\"Failed to determine the image length: %s\",\n                     strerror(-fd_size));\n        exit(EXIT_FAILURE);\n    }\n\n    if (dev_offset >= fd_size) {\n        error_report(\"Offset (%lld) has to be smaller than the image size \"\n                     \"(%lld)\",\n                     (long long int)dev_offset, (long long int)fd_size);\n        exit(EXIT_FAILURE);\n    }\n    fd_size -= dev_offset;\n\n    if (partition != -1) {\n        ret = find_partition(blk, partition, &dev_offset, &fd_size);\n        if (ret < 0) {\n            error_report(\"Could not find partition %d: %s\", partition,\n                         strerror(-ret));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    exp = nbd_export_new(bs, dev_offset, fd_size, nbdflags, nbd_export_closed,\n                         writethrough, NULL, &local_err);\n    if (!exp) {\n        error_report_err(local_err);\n        exit(EXIT_FAILURE);\n    }\n    if (export_name) {\n        nbd_export_set_name(exp, export_name);\n        nbd_export_set_description(exp, export_description);\n        newproto = true;\n    } else if (export_description) {\n        error_report(\"Export description requires an export name\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (device) {\n        int ret;\n\n        ret = pthread_create(&client_thread, NULL, nbd_client_thread, device);\n        if (ret != 0) {\n            error_report(\"Failed to create client thread: %s\", strerror(ret));\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        /* Shut up GCC warnings.  */\n        memset(&client_thread, 0, sizeof(client_thread));\n    }\n\n    nbd_update_server_watch();\n\n    /* now when the initialization is (almost) complete, chdir(\"/\")\n     * to free any busy filesystems */\n    if (chdir(\"/\") < 0) {\n        error_report(\"Could not chdir to root directory: %s\",\n                     strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (fork_process) {\n        dup2(old_stderr, STDERR_FILENO);\n        close(old_stderr);\n    }\n\n    state = RUNNING;\n    do {\n        main_loop_wait(false);\n        if (state == TERMINATE) {\n            state = TERMINATING;\n            nbd_export_close(exp);\n            nbd_export_put(exp);\n            exp = NULL;\n        }\n    } while (state != TERMINATED);\n\n    blk_unref(blk);\n    if (sockpath) {\n        unlink(sockpath);\n    }\n\n    qemu_opts_del(sn_opts);\n\n    if (device) {\n        void *ret;\n        pthread_join(client_thread, &ret);\n        exit(ret != NULL);\n    } else {\n        exit(EXIT_SUCCESS);\n    }\n}\n"
        },
        {
          "name": "qemu-nbd.texi",
          "type": "blob",
          "size": 4.3095703125,
          "content": "@example\n@c man begin SYNOPSIS\n@command{qemu-nbd} [OPTION]... @var{filename}\n\n@command{qemu-nbd} @option{-d} @var{dev}\n@c man end\n@end example\n\n@c man begin DESCRIPTION\n\nExport a QEMU disk image using the NBD protocol.\n\n@c man end\n\n@c man begin OPTIONS\n@var{filename} is a disk image filename, or a set of block\ndriver options if @var{--image-opts} is specified.\n\n@var{dev} is an NBD device.\n\n@table @option\n@item --object type,id=@var{id},...props...\nDefine a new instance of the @var{type} object class identified by @var{id}.\nSee the @code{qemu(1)} manual page for full details of the properties\nsupported. The common object types that it makes sense to define are the\n@code{secret} object, which is used to supply passwords and/or encryption\nkeys, and the @code{tls-creds} object, which is used to supply TLS\ncredentials for the qemu-nbd server.\n@item -p, --port=@var{port}\nThe TCP port to listen on (default @samp{10809})\n@item -o, --offset=@var{offset}\nThe offset into the image\n@item -b, --bind=@var{iface}\nThe interface to bind to (default @samp{0.0.0.0})\n@item -k, --socket=@var{path}\nUse a unix socket with path @var{path}\n@item --image-opts\nTreat @var{filename} as a set of image options, instead of a plain\nfilename. If this flag is specified, the @var{-f} flag should\nnot be used, instead the '@code{format=}' option should be set.\n@item -f, --format=@var{fmt}\nForce the use of the block driver for format @var{fmt} instead of\nauto-detecting\n@item -r, --read-only\nExport the disk as read-only\n@item -P, --partition=@var{num}\nOnly expose partition @var{num}\n@item -s, --snapshot\nUse @var{filename} as an external snapshot, create a temporary\nfile with backing_file=@var{filename}, redirect the write to\nthe temporary one\n@item -l, --load-snapshot=@var{snapshot_param}\nLoad an internal snapshot inside @var{filename} and export it\nas an read-only device, @var{snapshot_param} format is\n'snapshot.id=[ID],snapshot.name=[NAME]' or '[ID_OR_NAME]'\n@item -n, --nocache\n@itemx --cache=@var{cache}\nThe cache mode to be used with the file.  See the documentation of\nthe emulator's @code{-drive cache=...} option for allowed values.\n@item --aio=@var{aio}\nSet the asynchronous I/O mode between @samp{threads} (the default)\nand @samp{native} (Linux only).\n@item --discard=@var{discard}\nControl whether @dfn{discard} (also known as @dfn{trim} or @dfn{unmap})\nrequests are ignored or passed to the filesystem.  @var{discard} is one of\n@samp{ignore} (or @samp{off}), @samp{unmap} (or @samp{on}).  The default is\n@samp{ignore}.\n@item --detect-zeroes=@var{detect-zeroes}\nControl the automatic conversion of plain zero writes by the OS to\ndriver-specific optimized zero write commands.  @var{detect-zeroes} is one of\n@samp{off}, @samp{on} or @samp{unmap}.  @samp{unmap}\nconverts a zero write to an unmap operation and can only be used if\n@var{discard} is set to @samp{unmap}.  The default is @samp{off}.\n@item -c, --connect=@var{dev}\nConnect @var{filename} to NBD device @var{dev}\n@item -d, --disconnect\nDisconnect the device @var{dev}\n@item -e, --shared=@var{num}\nAllow up to @var{num} clients to share the device (default @samp{1})\n@item -t, --persistent\nDon't exit on the last connection\n@item -x, --export-name=@var{name}\nSet the NBD volume export name. This switches the server to use\nthe new style NBD protocol negotiation\n@item -D, --description=@var{description}\nSet the NBD volume export description, as a human-readable\nstring. Requires the use of @option{-x}\n@item --tls-creds=ID\nEnable mandatory TLS encryption for the server by setting the ID\nof the TLS credentials object previously created with the --object\noption.\n@item --fork\nFork off the server process and exit the parent once the server is running.\n@item -v, --verbose\nDisplay extra debugging information\n@item -h, --help\nDisplay this help and exit\n@item -V, --version\nDisplay version information and exit\n@item -T, --trace [[enable=]@var{pattern}][,events=@var{file}][,file=@var{file}]\n@findex --trace\n@include qemu-option-trace.texi\n@end table\n\n@c man end\n\n@ignore\n\n@setfilename qemu-nbd\n@settitle QEMU Disk Network Block Device Server\n\n@c man begin AUTHOR\nCopyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n@c man end\n\n@c man begin SEEALSO\nqemu(1), qemu-img(1)\n@c man end\n\n@end ignore\n"
        },
        {
          "name": "qemu-option-trace.texi",
          "type": "blob",
          "size": 0.9970703125,
          "content": "Specify tracing options.\n\n@table @option\n@item [enable=]@var{pattern}\nImmediately enable events matching @var{pattern}.\nThe file must contain one event name (as listed in the @file{trace-events-all}\nfile) per line; globbing patterns are accepted too.  This option is only\navailable if QEMU has been compiled with the @var{simple}, @var{log}\nor @var{ftrace} tracing backend.  To specify multiple events or patterns,\nspecify the @option{-trace} option multiple times.\n\nUse @code{-trace help} to print a list of names of trace points.\n\n@item events=@var{file}\nImmediately enable events listed in @var{file}.\nThe file must contain one event name (as listed in the @file{trace-events-all}\nfile) per line; globbing patterns are accepted too.  This option is only\navailable if QEMU has been compiled with the @var{simple}, @var{log} or\n@var{ftrace} tracing backend.\n\n@item file=@var{file}\nLog output traces to @var{file}.\nThis option is only available if QEMU has been compiled with\nthe @var{simple} tracing backend.\n@end table\n"
        },
        {
          "name": "qemu-options-wrapper.h",
          "type": "blob",
          "size": 1.037109375,
          "content": "\n#if defined(QEMU_OPTIONS_GENERATE_ENUM)\n\n#define DEF(option, opt_arg, opt_enum, opt_help, arch_mask)     \\\n    opt_enum,\n#define DEFHEADING(text)\n#define ARCHHEADING(text, arch_mask)\n\n#elif defined(QEMU_OPTIONS_GENERATE_HELP)\n\n#define DEF(option, opt_arg, opt_enum, opt_help, arch_mask)    \\\n    if ((arch_mask) & arch_type)                               \\\n        fputs(opt_help, stdout);\n\n#define ARCHHEADING(text, arch_mask) \\\n    if ((arch_mask) & arch_type)    \\\n        puts(stringify(text) \":\");\n\n#define DEFHEADING(text) ARCHHEADING(text, QEMU_ARCH_ALL)\n\n#elif defined(QEMU_OPTIONS_GENERATE_OPTIONS)\n\n#define DEF(option, opt_arg, opt_enum, opt_help, arch_mask)     \\\n    { option, opt_arg, opt_enum, arch_mask },\n#define DEFHEADING(text)\n#define ARCHHEADING(text, arch_mask)\n\n#else\n#error \"qemu-options-wrapper.h included with no option defined\"\n#endif\n\n#include \"qemu-options.def\"\n\n#undef DEF\n#undef DEFHEADING\n#undef ARCHHEADING\n#undef GEN_DOCS\n\n#undef QEMU_OPTIONS_GENERATE_ENUM\n#undef QEMU_OPTIONS_GENERATE_HELP\n#undef QEMU_OPTIONS_GENERATE_OPTIONS\n"
        },
        {
          "name": "qemu-options.h",
          "type": "blob",
          "size": 1.3681640625,
          "content": "/*\n * qemu-options.h\n *\n * Defines needed for command line argument processing.\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2010 Jes Sorensen <Jes.Sorensen@redhat.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifndef QEMU_OPTIONS_H\n#define QEMU_OPTIONS_H\n\nenum {\n#define QEMU_OPTIONS_GENERATE_ENUM\n#include \"qemu-options-wrapper.h\"\n};\n\n#endif\n"
        },
        {
          "name": "qemu-options.hx",
          "type": "blob",
          "size": 162.4306640625,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and texi\nHXCOMM Text between STEXI and ETEXI are copied to texi version and\nHXCOMM discarded from C version\nHXCOMM DEF(option, HAS_ARG/0, opt_enum, opt_help, arch_mask) is used to\nHXCOMM construct option structures, enums and help message for specified\nHXCOMM architectures.\nHXCOMM HXCOMM can be used for comments, discarded from both texi and C\n\nDEFHEADING(Standard options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"help\", 0, QEMU_OPTION_h,\n    \"-h or -help     display this help and exit\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -h\n@findex -h\nDisplay help and exit\nETEXI\n\nDEF(\"version\", 0, QEMU_OPTION_version,\n    \"-version        display version information and exit\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -version\n@findex -version\nDisplay version information and exit\nETEXI\n\nDEF(\"machine\", HAS_ARG, QEMU_OPTION_machine, \\\n    \"-machine [type=]name[,prop[=value][,...]]\\n\"\n    \"                selects emulated machine ('-machine help' for list)\\n\"\n    \"                property accel=accel1[:accel2[:...]] selects accelerator\\n\"\n    \"                supported accelerators are kvm, xen, tcg (default: tcg)\\n\"\n    \"                kernel_irqchip=on|off|split controls accelerated irqchip support (default=off)\\n\"\n    \"                vmport=on|off|auto controls emulation of vmport (default: auto)\\n\"\n    \"                kvm_shadow_mem=size of KVM shadow MMU in bytes\\n\"\n    \"                dump-guest-core=on|off include guest memory in a core dump (default=on)\\n\"\n    \"                mem-merge=on|off controls memory merge support (default: on)\\n\"\n    \"                igd-passthru=on|off controls IGD GFX passthrough support (default=off)\\n\"\n    \"                aes-key-wrap=on|off controls support for AES key wrapping (default=on)\\n\"\n    \"                dea-key-wrap=on|off controls support for DEA key wrapping (default=on)\\n\"\n    \"                suppress-vmdesc=on|off disables self-describing migration (default=off)\\n\"\n    \"                nvdimm=on|off controls NVDIMM support (default=off)\\n\"\n    \"                enforce-config-section=on|off enforce configuration section migration (default=off)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -machine [type=]@var{name}[,prop=@var{value}[,...]]\n@findex -machine\nSelect the emulated machine by @var{name}. Use @code{-machine help} to list\navailable machines. Supported machine properties are:\n@table @option\n@item accel=@var{accels1}[:@var{accels2}[:...]]\nThis is used to enable an accelerator. Depending on the target architecture,\nkvm, xen, or tcg can be available. By default, tcg is used. If there is more\nthan one accelerator specified, the next one is used if the previous one fails\nto initialize.\n@item kernel_irqchip=on|off\nControls in-kernel irqchip support for the chosen accelerator when available.\n@item gfx_passthru=on|off\nEnables IGD GFX passthrough support for the chosen machine when available.\n@item vmport=on|off|auto\nEnables emulation of VMWare IO port, for vmmouse etc. auto says to select the\nvalue based on accel. For accel=xen the default is off otherwise the default\nis on.\n@item kvm_shadow_mem=size\nDefines the size of the KVM shadow MMU.\n@item dump-guest-core=on|off\nInclude guest memory in a core dump. The default is on.\n@item mem-merge=on|off\nEnables or disables memory merge support. This feature, when supported by\nthe host, de-duplicates identical memory pages among VMs instances\n(enabled by default).\n@item aes-key-wrap=on|off\nEnables or disables AES key wrapping support on s390-ccw hosts. This feature\ncontrols whether AES wrapping keys will be created to allow\nexecution of AES cryptographic functions.  The default is on.\n@item dea-key-wrap=on|off\nEnables or disables DEA key wrapping support on s390-ccw hosts. This feature\ncontrols whether DEA wrapping keys will be created to allow\nexecution of DEA cryptographic functions.  The default is on.\n@item nvdimm=on|off\nEnables or disables NVDIMM support. The default is off.\n@end table\nETEXI\n\nHXCOMM Deprecated by -machine\nDEF(\"M\", HAS_ARG, QEMU_OPTION_M, \"\", QEMU_ARCH_ALL)\n\nDEF(\"cpu\", HAS_ARG, QEMU_OPTION_cpu,\n    \"-cpu cpu        select CPU ('-cpu help' for list)\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -cpu @var{model}\n@findex -cpu\nSelect CPU model (@code{-cpu help} for list and additional feature selection)\nETEXI\n\nDEF(\"accel\", HAS_ARG, QEMU_OPTION_accel,\n    \"-accel [accel=]accelerator[,thread=single|multi]\\n\"\n    \"               select accelerator ('-accel help for list')\\n\"\n    \"               thread=single|multi (enable multi-threaded TCG)\", QEMU_ARCH_ALL)\nSTEXI\n@item -accel @var{name}[,prop=@var{value}[,...]]\n@findex -accel\nThis is used to enable an accelerator. Depending on the target architecture,\nkvm, xen, or tcg can be available. By default, tcg is used. If there is more\nthan one accelerator specified, the next one is used if the previous one fails\nto initialize.\n@table @option\n@item thread=single|multi\nControls number of TCG threads. When the TCG is multi-threaded there will be one\nthread per vCPU therefor taking advantage of additional host cores. The default\nis to enable multi-threading where both the back-end and front-ends support it and\nno incompatible TCG features have been enabled (e.g. icount/replay).\n@end table\nETEXI\n\nDEF(\"smp\", HAS_ARG, QEMU_OPTION_smp,\n    \"-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]\\n\"\n    \"                set the number of CPUs to 'n' [default=1]\\n\"\n    \"                maxcpus= maximum number of total cpus, including\\n\"\n    \"                offline CPUs for hotplug, etc\\n\"\n    \"                cores= number of CPU cores on one socket\\n\"\n    \"                threads= number of threads on one CPU core\\n\"\n    \"                sockets= number of discrete sockets in the system\\n\",\n        QEMU_ARCH_ALL)\nSTEXI\n@item -smp [cpus=]@var{n}[,cores=@var{cores}][,threads=@var{threads}][,sockets=@var{sockets}][,maxcpus=@var{maxcpus}]\n@findex -smp\nSimulate an SMP system with @var{n} CPUs. On the PC target, up to 255\nCPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs\nto 4.\nFor the PC target, the number of @var{cores} per socket, the number\nof @var{threads} per cores and the total number of @var{sockets} can be\nspecified. Missing values will be computed. If any on the three values is\ngiven, the total number of CPUs @var{n} can be omitted. @var{maxcpus}\nspecifies the maximum number of hotpluggable CPUs.\nETEXI\n\nDEF(\"numa\", HAS_ARG, QEMU_OPTION_numa,\n    \"-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node]\\n\"\n    \"-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node]\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -numa node[,mem=@var{size}][,cpus=@var{firstcpu}[-@var{lastcpu}]][,nodeid=@var{node}]\n@itemx -numa node[,memdev=@var{id}][,cpus=@var{firstcpu}[-@var{lastcpu}]][,nodeid=@var{node}]\n@findex -numa\nDefine a NUMA node and assign RAM and VCPUs to it.\n\n@var{firstcpu} and @var{lastcpu} are CPU indexes. Each\n@samp{cpus} option represent a contiguous range of CPU indexes\n(or a single VCPU if @var{lastcpu} is omitted). A non-contiguous\nset of VCPUs can be represented by providing multiple @samp{cpus}\noptions. If @samp{cpus} is omitted on all nodes, VCPUs are automatically\nsplit between them.\n\nFor example, the following option assigns VCPUs 0, 1, 2 and 5 to\na NUMA node:\n@example\n-numa node,cpus=0-2,cpus=5\n@end example\n\n@samp{mem} assigns a given RAM amount to a node. @samp{memdev}\nassigns RAM from a given memory backend device to a node. If\n@samp{mem} and @samp{memdev} are omitted in all nodes, RAM is\nsplit equally between them.\n\n@samp{mem} and @samp{memdev} are mutually exclusive. Furthermore,\nif one node uses @samp{memdev}, all of them have to use it.\n\nNote that the -@option{numa} option doesn't allocate any of the\nspecified resources, it just assigns existing resources to NUMA\nnodes. This means that one still has to use the @option{-m},\n@option{-smp} options to allocate RAM and VCPUs respectively.\n\nETEXI\n\nDEF(\"add-fd\", HAS_ARG, QEMU_OPTION_add_fd,\n    \"-add-fd fd=fd,set=set[,opaque=opaque]\\n\"\n    \"                Add 'fd' to fd 'set'\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -add-fd fd=@var{fd},set=@var{set}[,opaque=@var{opaque}]\n@findex -add-fd\n\nAdd a file descriptor to an fd set.  Valid options are:\n\n@table @option\n@item fd=@var{fd}\nThis option defines the file descriptor of which a duplicate is added to fd set.\nThe file descriptor cannot be stdin, stdout, or stderr.\n@item set=@var{set}\nThis option defines the ID of the fd set to add the file descriptor to.\n@item opaque=@var{opaque}\nThis option defines a free-form string that can be used to describe @var{fd}.\n@end table\n\nYou can open an image using pre-opened file descriptors from an fd set:\n@example\nqemu-system-i386\n-add-fd fd=3,set=2,opaque=\"rdwr:/path/to/file\"\n-add-fd fd=4,set=2,opaque=\"rdonly:/path/to/file\"\n-drive file=/dev/fdset/2,index=0,media=disk\n@end example\nETEXI\n\nDEF(\"set\", HAS_ARG, QEMU_OPTION_set,\n    \"-set group.id.arg=value\\n\"\n    \"                set <arg> parameter for item <id> of type <group>\\n\"\n    \"                i.e. -set drive.$id.file=/path/to/image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -set @var{group}.@var{id}.@var{arg}=@var{value}\n@findex -set\nSet parameter @var{arg} for item @var{id} of type @var{group}\nETEXI\n\nDEF(\"global\", HAS_ARG, QEMU_OPTION_global,\n    \"-global driver.property=value\\n\"\n    \"-global driver=driver,property=property,value=value\\n\"\n    \"                set a global default for a driver property\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -global @var{driver}.@var{prop}=@var{value}\n@itemx -global driver=@var{driver},property=@var{property},value=@var{value}\n@findex -global\nSet default value of @var{driver}'s property @var{prop} to @var{value}, e.g.:\n\n@example\nqemu-system-i386 -global ide-drive.physical_block_size=4096 -drive file=file,if=ide,index=0,media=disk\n@end example\n\nIn particular, you can use this to set driver properties for devices which are \ncreated automatically by the machine model. To create a device which is not \ncreated automatically and set properties on it, use -@option{device}.\n\n-global @var{driver}.@var{prop}=@var{value} is shorthand for -global\ndriver=@var{driver},property=@var{prop},value=@var{value}.  The\nlonghand syntax works even when @var{driver} contains a dot.\nETEXI\n\nDEF(\"boot\", HAS_ARG, QEMU_OPTION_boot,\n    \"-boot [order=drives][,once=drives][,menu=on|off]\\n\"\n    \"      [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]\\n\"\n    \"                'drives': floppy (a), hard disk (c), CD-ROM (d), network (n)\\n\"\n    \"                'sp_name': the file's name that would be passed to bios as logo picture, if menu=on\\n\"\n    \"                'sp_time': the period that splash picture last if menu=on, unit is ms\\n\"\n    \"                'rb_timeout': the timeout before guest reboot when boot failed, unit is ms\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -boot [order=@var{drives}][,once=@var{drives}][,menu=on|off][,splash=@var{sp_name}][,splash-time=@var{sp_time}][,reboot-timeout=@var{rb_timeout}][,strict=on|off]\n@findex -boot\nSpecify boot order @var{drives} as a string of drive letters. Valid\ndrive letters depend on the target architecture. The x86 PC uses: a, b\n(floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot\nfrom network adapter 1-4), hard disk boot is the default. To apply a\nparticular boot order only on the first startup, specify it via\n@option{once}. Note that the @option{order} or @option{once} parameter\nshould not be used together with the @option{bootindex} property of\ndevices, since the firmware implementations normally do not support both\nat the same time.\n\nInteractive boot menus/prompts can be enabled via @option{menu=on} as far\nas firmware/BIOS supports them. The default is non-interactive boot.\n\nA splash picture could be passed to bios, enabling user to show it as logo,\nwhen option splash=@var{sp_name} is given and menu=on, If firmware/BIOS\nsupports them. Currently Seabios for X86 system support it.\nlimitation: The splash file could be a jpeg file or a BMP file in 24 BPP\nformat(true color). The resolution should be supported by the SVGA mode, so\nthe recommended is 320x240, 640x480, 800x640.\n\nA timeout could be passed to bios, guest will pause for @var{rb_timeout} ms\nwhen boot failed, then reboot. If @var{rb_timeout} is '-1', guest will not\nreboot, qemu passes '-1' to bios by default. Currently Seabios for X86\nsystem support it.\n\nDo strict boot via @option{strict=on} as far as firmware/BIOS\nsupports it. This only effects when boot priority is changed by\nbootindex options. The default is non-strict boot.\n\n@example\n# try to boot from network first, then from hard disk\nqemu-system-i386 -boot order=nc\n# boot from CD-ROM first, switch back to default order after reboot\nqemu-system-i386 -boot once=d\n# boot with a splash picture for 5 seconds.\nqemu-system-i386 -boot menu=on,splash=/root/boot.bmp,splash-time=5000\n@end example\n\nNote: The legacy format '-boot @var{drives}' is still supported but its\nuse is discouraged as it may be removed from future versions.\nETEXI\n\nDEF(\"m\", HAS_ARG, QEMU_OPTION_m,\n    \"-m [size=]megs[,slots=n,maxmem=size]\\n\"\n    \"                configure guest RAM\\n\"\n    \"                size: initial amount of guest memory\\n\"\n    \"                slots: number of hotplug slots (default: none)\\n\"\n    \"                maxmem: maximum amount of guest memory (default: none)\\n\"\n    \"NOTE: Some architectures might enforce a specific granularity\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -m [size=]@var{megs}[,slots=n,maxmem=size]\n@findex -m\nSets guest startup RAM size to @var{megs} megabytes. Default is 128 MiB.\nOptionally, a suffix of ``M'' or ``G'' can be used to signify a value in\nmegabytes or gigabytes respectively. Optional pair @var{slots}, @var{maxmem}\ncould be used to set amount of hotpluggable memory slots and maximum amount of\nmemory. Note that @var{maxmem} must be aligned to the page size.\n\nFor example, the following command-line sets the guest startup RAM size to\n1GB, creates 3 slots to hotplug additional memory and sets the maximum\nmemory the guest can reach to 4GB:\n\n@example\nqemu-system-x86_64 -m 1G,slots=3,maxmem=4G\n@end example\n\nIf @var{slots} and @var{maxmem} are not specified, memory hotplug won't\nbe enabled and the guest startup RAM will never increase.\nETEXI\n\nDEF(\"mem-path\", HAS_ARG, QEMU_OPTION_mempath,\n    \"-mem-path FILE  provide backing storage for guest RAM\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -mem-path @var{path}\n@findex -mem-path\nAllocate guest RAM from a temporarily created file in @var{path}.\nETEXI\n\nDEF(\"mem-prealloc\", 0, QEMU_OPTION_mem_prealloc,\n    \"-mem-prealloc   preallocate guest memory (use with -mem-path)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -mem-prealloc\n@findex -mem-prealloc\nPreallocate memory when using -mem-path.\nETEXI\n\nDEF(\"k\", HAS_ARG, QEMU_OPTION_k,\n    \"-k language     use keyboard layout (for example 'fr' for French)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -k @var{language}\n@findex -k\nUse keyboard layout @var{language} (for example @code{fr} for\nFrench). This option is only needed where it is not easy to get raw PC\nkeycodes (e.g. on Macs, with some X11 servers or with a VNC or curses\ndisplay). You don't normally need to use it on PC/Linux or PC/Windows\nhosts.\n\nThe available layouts are:\n@example\nar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv\nda  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th\nde  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr\n@end example\n\nThe default is @code{en-us}.\nETEXI\n\n\nDEF(\"audio-help\", 0, QEMU_OPTION_audio_help,\n    \"-audio-help     print list of audio drivers and their options\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -audio-help\n@findex -audio-help\nWill show the audio subsystem help: list of drivers, tunable\nparameters.\nETEXI\n\nDEF(\"soundhw\", HAS_ARG, QEMU_OPTION_soundhw,\n    \"-soundhw c1,... enable audio support\\n\"\n    \"                and only specified sound cards (comma separated list)\\n\"\n    \"                use '-soundhw help' to get the list of supported cards\\n\"\n    \"                use '-soundhw all' to enable all of them\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -soundhw @var{card1}[,@var{card2},...] or -soundhw all\n@findex -soundhw\nEnable audio and selected sound hardware. Use 'help' to print all\navailable sound hardware.\n\n@example\nqemu-system-i386 -soundhw sb16,adlib disk.img\nqemu-system-i386 -soundhw es1370 disk.img\nqemu-system-i386 -soundhw ac97 disk.img\nqemu-system-i386 -soundhw hda disk.img\nqemu-system-i386 -soundhw all disk.img\nqemu-system-i386 -soundhw help\n@end example\n\nNote that Linux's i810_audio OSS kernel (for AC97) module might\nrequire manually specifying clocking.\n\n@example\nmodprobe i810_audio clocking=48000\n@end example\nETEXI\n\nDEF(\"balloon\", HAS_ARG, QEMU_OPTION_balloon,\n    \"-balloon none   disable balloon device\\n\"\n    \"-balloon virtio[,addr=str]\\n\"\n    \"                enable virtio balloon device (default)\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -balloon none\n@findex -balloon\nDisable balloon device.\n@item -balloon virtio[,addr=@var{addr}]\nEnable virtio balloon device (default), optionally with PCI address\n@var{addr}.\nETEXI\n\nDEF(\"device\", HAS_ARG, QEMU_OPTION_device,\n    \"-device driver[,prop[=value][,...]]\\n\"\n    \"                add device (based on driver)\\n\"\n    \"                prop=value,... sets driver properties\\n\"\n    \"                use '-device help' to print all possible drivers\\n\"\n    \"                use '-device driver,help' to print all possible properties\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -device @var{driver}[,@var{prop}[=@var{value}][,...]]\n@findex -device\nAdd device @var{driver}.  @var{prop}=@var{value} sets driver\nproperties.  Valid properties depend on the driver.  To get help on\npossible drivers and properties, use @code{-device help} and\n@code{-device @var{driver},help}.\n\nSome drivers are:\n@item -device ipmi-bmc-sim,id=@var{id}[,slave_addr=@var{val}]\n\nAdd an IPMI BMC.  This is a simulation of a hardware management\ninterface processor that normally sits on a system.  It provides\na watchdog and the ability to reset and power control the system.\nYou need to connect this to an IPMI interface to make it useful\n\nThe IPMI slave address to use for the BMC.  The default is 0x20.\nThis address is the BMC's address on the I2C network of management\ncontrollers.  If you don't know what this means, it is safe to ignore\nit.\n\n@item -device ipmi-bmc-extern,id=@var{id},chardev=@var{id}[,slave_addr=@var{val}]\n\nAdd a connection to an external IPMI BMC simulator.  Instead of\nlocally emulating the BMC like the above item, instead connect\nto an external entity that provides the IPMI services.\n\nA connection is made to an external BMC simulator.  If you do this, it\nis strongly recommended that you use the \"reconnect=\" chardev option\nto reconnect to the simulator if the connection is lost.  Note that if\nthis is not used carefully, it can be a security issue, as the\ninterface has the ability to send resets, NMIs, and power off the VM.\nIt's best if QEMU makes a connection to an external simulator running\non a secure port on localhost, so neither the simulator nor QEMU is\nexposed to any outside network.\n\nSee the \"lanserv/README.vm\" file in the OpenIPMI library for more\ndetails on the external interface.\n\n@item -device isa-ipmi-kcs,bmc=@var{id}[,ioport=@var{val}][,irq=@var{val}]\n\nAdd a KCS IPMI interafce on the ISA bus.  This also adds a\ncorresponding ACPI and SMBIOS entries, if appropriate.\n\n@table @option\n@item bmc=@var{id}\nThe BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.\n@item ioport=@var{val}\nDefine the I/O address of the interface.  The default is 0xca0 for KCS.\n@item irq=@var{val}\nDefine the interrupt to use.  The default is 5.  To disable interrupts,\nset this to 0.\n@end table\n\n@item -device isa-ipmi-bt,bmc=@var{id}[,ioport=@var{val}][,irq=@var{val}]\n\nLike the KCS interface, but defines a BT interface.  The default port is\n0xe4 and the default interrupt is 5.\n\nETEXI\n\nDEF(\"name\", HAS_ARG, QEMU_OPTION_name,\n    \"-name string1[,process=string2][,debug-threads=on|off]\\n\"\n    \"                set the name of the guest\\n\"\n    \"                string1 sets the window title and string2 the process name (on Linux)\\n\"\n    \"                When debug-threads is enabled, individual threads are given a separate name (on Linux)\\n\"\n    \"                NOTE: The thread names are for debugging and not a stable API.\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -name @var{name}\n@findex -name\nSets the @var{name} of the guest.\nThis name will be displayed in the SDL window caption.\nThe @var{name} will also be used for the VNC server.\nAlso optionally set the top visible process name in Linux.\nNaming of individual threads can also be enabled on Linux to aid debugging.\nETEXI\n\nDEF(\"uuid\", HAS_ARG, QEMU_OPTION_uuid,\n    \"-uuid %08x-%04x-%04x-%04x-%012x\\n\"\n    \"                specify machine UUID\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -uuid @var{uuid}\n@findex -uuid\nSet system UUID.\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Block device options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"fda\", HAS_ARG, QEMU_OPTION_fda,\n    \"-fda/-fdb file  use 'file' as floppy disk 0/1 image\\n\", QEMU_ARCH_ALL)\nDEF(\"fdb\", HAS_ARG, QEMU_OPTION_fdb, \"\", QEMU_ARCH_ALL)\nSTEXI\n@item -fda @var{file}\n@itemx -fdb @var{file}\n@findex -fda\n@findex -fdb\nUse @var{file} as floppy disk 0/1 image (@pxref{disk_images}).\nETEXI\n\nDEF(\"hda\", HAS_ARG, QEMU_OPTION_hda,\n    \"-hda/-hdb file  use 'file' as IDE hard disk 0/1 image\\n\", QEMU_ARCH_ALL)\nDEF(\"hdb\", HAS_ARG, QEMU_OPTION_hdb, \"\", QEMU_ARCH_ALL)\nDEF(\"hdc\", HAS_ARG, QEMU_OPTION_hdc,\n    \"-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image\\n\", QEMU_ARCH_ALL)\nDEF(\"hdd\", HAS_ARG, QEMU_OPTION_hdd, \"\", QEMU_ARCH_ALL)\nSTEXI\n@item -hda @var{file}\n@itemx -hdb @var{file}\n@itemx -hdc @var{file}\n@itemx -hdd @var{file}\n@findex -hda\n@findex -hdb\n@findex -hdc\n@findex -hdd\nUse @var{file} as hard disk 0, 1, 2 or 3 image (@pxref{disk_images}).\nETEXI\n\nDEF(\"cdrom\", HAS_ARG, QEMU_OPTION_cdrom,\n    \"-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -cdrom @var{file}\n@findex -cdrom\nUse @var{file} as CD-ROM image (you cannot use @option{-hdc} and\n@option{-cdrom} at the same time). You can use the host CD-ROM by\nusing @file{/dev/cdrom} as filename (@pxref{host_drives}).\nETEXI\n\nDEF(\"blockdev\", HAS_ARG, QEMU_OPTION_blockdev,\n    \"-blockdev [driver=]driver[,node-name=N][,discard=ignore|unmap]\\n\"\n    \"          [,cache.direct=on|off][,cache.no-flush=on|off]\\n\"\n    \"          [,read-only=on|off][,detect-zeroes=on|off|unmap]\\n\"\n    \"          [,driver specific parameters...]\\n\"\n    \"                configure a block backend\\n\", QEMU_ARCH_ALL)\n\nDEF(\"drive\", HAS_ARG, QEMU_OPTION_drive,\n    \"-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i]\\n\"\n    \"       [,cyls=c,heads=h,secs=s[,trans=t]][,snapshot=on|off]\\n\"\n    \"       [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]\\n\"\n    \"       [,serial=s][,addr=A][,rerror=ignore|stop|report]\\n\"\n    \"       [,werror=ignore|stop|report|enospc][,id=name][,aio=threads|native]\\n\"\n    \"       [,readonly=on|off][,copy-on-read=on|off]\\n\"\n    \"       [,discard=ignore|unmap][,detect-zeroes=on|off|unmap]\\n\"\n    \"       [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]]\\n\"\n    \"       [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]]\\n\"\n    \"       [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]]\\n\"\n    \"       [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]]\\n\"\n    \"       [[,iops_size=is]]\\n\"\n    \"       [[,group=g]]\\n\"\n    \"                use 'file' as a drive image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -drive @var{option}[,@var{option}[,@var{option}[,...]]]\n@findex -drive\n\nDefine a new drive. Valid options are:\n\n@table @option\n@item file=@var{file}\nThis option defines which disk image (@pxref{disk_images}) to use with\nthis drive. If the filename contains comma, you must double it\n(for instance, \"file=my,,file\" to use file \"my,file\").\n\nSpecial files such as iSCSI devices can be specified using protocol\nspecific URLs. See the section for \"Device URL Syntax\" for more information.\n@item if=@var{interface}\nThis option defines on which type on interface the drive is connected.\nAvailable types are: ide, scsi, sd, mtd, floppy, pflash, virtio.\n@item bus=@var{bus},unit=@var{unit}\nThese options define where is connected the drive by defining the bus number and\nthe unit id.\n@item index=@var{index}\nThis option defines where is connected the drive by using an index in the list\nof available connectors of a given interface type.\n@item media=@var{media}\nThis option defines the type of the media: disk or cdrom.\n@item cyls=@var{c},heads=@var{h},secs=@var{s}[,trans=@var{t}]\nThese options have the same definition as they have in @option{-hdachs}.\n@item snapshot=@var{snapshot}\n@var{snapshot} is \"on\" or \"off\" and controls snapshot mode for the given drive\n(see @option{-snapshot}).\n@item cache=@var{cache}\n@var{cache} is \"none\", \"writeback\", \"unsafe\", \"directsync\" or \"writethrough\" and controls how the host cache is used to access block data.\n@item aio=@var{aio}\n@var{aio} is \"threads\", or \"native\" and selects between pthread based disk I/O and native Linux AIO.\n@item discard=@var{discard}\n@var{discard} is one of \"ignore\" (or \"off\") or \"unmap\" (or \"on\") and controls whether @dfn{discard} (also known as @dfn{trim} or @dfn{unmap}) requests are ignored or passed to the filesystem.  Some machine types may not support discard requests.\n@item format=@var{format}\nSpecify which disk @var{format} will be used rather than detecting\nthe format.  Can be used to specify format=raw to avoid interpreting\nan untrusted format header.\n@item serial=@var{serial}\nThis option specifies the serial number to assign to the device.\n@item addr=@var{addr}\nSpecify the controller's PCI address (if=virtio only).\n@item werror=@var{action},rerror=@var{action}\nSpecify which @var{action} to take on write and read errors. Valid actions are:\n\"ignore\" (ignore the error and try to continue), \"stop\" (pause QEMU),\n\"report\" (report the error to the guest), \"enospc\" (pause QEMU only if the\nhost disk is full; report the error to the guest otherwise).\nThe default setting is @option{werror=enospc} and @option{rerror=report}.\n@item readonly\nOpen drive @option{file} as read-only. Guest write attempts will fail.\n@item copy-on-read=@var{copy-on-read}\n@var{copy-on-read} is \"on\" or \"off\" and enables whether to copy read backing\nfile sectors into the image file.\n@item detect-zeroes=@var{detect-zeroes}\n@var{detect-zeroes} is \"off\", \"on\" or \"unmap\" and enables the automatic\nconversion of plain zero writes by the OS to driver specific optimized\nzero write commands. You may even choose \"unmap\" if @var{discard} is set\nto \"unmap\" to allow a zero write to be converted to an UNMAP operation.\n@end table\n\nBy default, the @option{cache=writeback} mode is used. It will report data\nwrites as completed as soon as the data is present in the host page cache.\nThis is safe as long as your guest OS makes sure to correctly flush disk caches\nwhere needed. If your guest OS does not handle volatile disk write caches\ncorrectly and your host crashes or loses power, then the guest may experience\ndata corruption.\n\nFor such guests, you should consider using @option{cache=writethrough}. This\nmeans that the host page cache will be used to read and write data, but write\nnotification will be sent to the guest only after QEMU has made sure to flush\neach write to the disk. Be aware that this has a major impact on performance.\n\nThe host page cache can be avoided entirely with @option{cache=none}.  This will\nattempt to do disk IO directly to the guest's memory.  QEMU may still perform\nan internal copy of the data. Note that this is considered a writeback mode and\nthe guest OS must handle the disk write cache correctly in order to avoid data\ncorruption on host crashes.\n\nThe host page cache can be avoided while only sending write notifications to\nthe guest when the data has been flushed to the disk using\n@option{cache=directsync}.\n\nIn case you don't care about data integrity over host failures, use\n@option{cache=unsafe}. This option tells QEMU that it never needs to write any\ndata to the disk but can instead keep things in cache. If anything goes wrong,\nlike your host losing power, the disk storage getting disconnected accidentally,\netc. your image will most probably be rendered unusable.   When using\nthe @option{-snapshot} option, unsafe caching is always used.\n\nCopy-on-read avoids accessing the same backing file sectors repeatedly and is\nuseful when the backing file is over a slow network.  By default copy-on-read\nis off.\n\nInstead of @option{-cdrom} you can use:\n@example\nqemu-system-i386 -drive file=file,index=2,media=cdrom\n@end example\n\nInstead of @option{-hda}, @option{-hdb}, @option{-hdc}, @option{-hdd}, you can\nuse:\n@example\nqemu-system-i386 -drive file=file,index=0,media=disk\nqemu-system-i386 -drive file=file,index=1,media=disk\nqemu-system-i386 -drive file=file,index=2,media=disk\nqemu-system-i386 -drive file=file,index=3,media=disk\n@end example\n\nYou can open an image using pre-opened file descriptors from an fd set:\n@example\nqemu-system-i386\n-add-fd fd=3,set=2,opaque=\"rdwr:/path/to/file\"\n-add-fd fd=4,set=2,opaque=\"rdonly:/path/to/file\"\n-drive file=/dev/fdset/2,index=0,media=disk\n@end example\n\nYou can connect a CDROM to the slave of ide0:\n@example\nqemu-system-i386 -drive file=file,if=ide,index=1,media=cdrom\n@end example\n\nIf you don't specify the \"file=\" argument, you define an empty drive:\n@example\nqemu-system-i386 -drive if=ide,index=1,media=cdrom\n@end example\n\nInstead of @option{-fda}, @option{-fdb}, you can use:\n@example\nqemu-system-i386 -drive file=file,index=0,if=floppy\nqemu-system-i386 -drive file=file,index=1,if=floppy\n@end example\n\nBy default, @var{interface} is \"ide\" and @var{index} is automatically\nincremented:\n@example\nqemu-system-i386 -drive file=a -drive file=b\"\n@end example\nis interpreted like:\n@example\nqemu-system-i386 -hda a -hdb b\n@end example\nETEXI\n\nDEF(\"mtdblock\", HAS_ARG, QEMU_OPTION_mtdblock,\n    \"-mtdblock file  use 'file' as on-board Flash memory image\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -mtdblock @var{file}\n@findex -mtdblock\nUse @var{file} as on-board Flash memory image.\nETEXI\n\nDEF(\"sd\", HAS_ARG, QEMU_OPTION_sd,\n    \"-sd file        use 'file' as SecureDigital card image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -sd @var{file}\n@findex -sd\nUse @var{file} as SecureDigital card image.\nETEXI\n\nDEF(\"pflash\", HAS_ARG, QEMU_OPTION_pflash,\n    \"-pflash file    use 'file' as a parallel flash image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -pflash @var{file}\n@findex -pflash\nUse @var{file} as a parallel flash image.\nETEXI\n\nDEF(\"snapshot\", 0, QEMU_OPTION_snapshot,\n    \"-snapshot       write to temporary files instead of disk image files\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -snapshot\n@findex -snapshot\nWrite to temporary files instead of disk image files. In this case,\nthe raw disk image you use is not written back. You can however force\nthe write back by pressing @key{C-a s} (@pxref{disk_images}).\nETEXI\n\nDEF(\"hdachs\", HAS_ARG, QEMU_OPTION_hdachs, \\\n    \"-hdachs c,h,s[,t]\\n\" \\\n    \"                force hard disk 0 physical geometry and the optional BIOS\\n\" \\\n    \"                translation (t=none or lba) (usually QEMU can guess them)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -hdachs @var{c},@var{h},@var{s},[,@var{t}]\n@findex -hdachs\nForce hard disk 0 physical geometry (1 <= @var{c} <= 16383, 1 <=\n@var{h} <= 16, 1 <= @var{s} <= 63) and optionally force the BIOS\ntranslation mode (@var{t}=none, lba or auto). Usually QEMU can guess\nall those parameters. This option is useful for old MS-DOS disk\nimages.\nETEXI\n\nDEF(\"fsdev\", HAS_ARG, QEMU_OPTION_fsdev,\n    \"-fsdev fsdriver,id=id[,path=path,][security_model={mapped-xattr|mapped-file|passthrough|none}]\\n\"\n    \" [,writeout=immediate][,readonly][,socket=socket|sock_fd=sock_fd]\\n\"\n    \" [[,throttling.bps-total=b]|[[,throttling.bps-read=r][,throttling.bps-write=w]]]\\n\"\n    \" [[,throttling.iops-total=i]|[[,throttling.iops-read=r][,throttling.iops-write=w]]]\\n\"\n    \" [[,throttling.bps-total-max=bm]|[[,throttling.bps-read-max=rm][,throttling.bps-write-max=wm]]]\\n\"\n    \" [[,throttling.iops-total-max=im]|[[,throttling.iops-read-max=irm][,throttling.iops-write-max=iwm]]]\\n\"\n    \" [[,throttling.iops-size=is]]\\n\",\n    QEMU_ARCH_ALL)\n\nSTEXI\n\n@item -fsdev @var{fsdriver},id=@var{id},path=@var{path},[security_model=@var{security_model}][,writeout=@var{writeout}][,readonly][,socket=@var{socket}|sock_fd=@var{sock_fd}]\n@findex -fsdev\nDefine a new file system device. Valid options are:\n@table @option\n@item @var{fsdriver}\nThis option specifies the fs driver backend to use.\nCurrently \"local\", \"handle\" and \"proxy\" file system drivers are supported.\n@item id=@var{id}\nSpecifies identifier for this device\n@item path=@var{path}\nSpecifies the export path for the file system device. Files under\nthis path will be available to the 9p client on the guest.\n@item security_model=@var{security_model}\nSpecifies the security model to be used for this export path.\nSupported security models are \"passthrough\", \"mapped-xattr\", \"mapped-file\" and \"none\".\nIn \"passthrough\" security model, files are stored using the same\ncredentials as they are created on the guest. This requires QEMU\nto run as root. In \"mapped-xattr\" security model, some of the file\nattributes like uid, gid, mode bits and link target are stored as\nfile attributes. For \"mapped-file\" these attributes are stored in the\nhidden .virtfs_metadata directory. Directories exported by this security model cannot\ninteract with other unix tools. \"none\" security model is same as\npassthrough except the sever won't report failures if it fails to\nset file attributes like ownership. Security model is mandatory\nonly for local fsdriver. Other fsdrivers (like handle, proxy) don't take\nsecurity model as a parameter.\n@item writeout=@var{writeout}\nThis is an optional argument. The only supported value is \"immediate\".\nThis means that host page cache will be used to read and write data but\nwrite notification will be sent to the guest only when the data has been\nreported as written by the storage subsystem.\n@item readonly\nEnables exporting 9p share as a readonly mount for guests. By default\nread-write access is given.\n@item socket=@var{socket}\nEnables proxy filesystem driver to use passed socket file for communicating\nwith virtfs-proxy-helper\n@item sock_fd=@var{sock_fd}\nEnables proxy filesystem driver to use passed socket descriptor for\ncommunicating with virtfs-proxy-helper. Usually a helper like libvirt\nwill create socketpair and pass one of the fds as sock_fd\n@end table\n\n-fsdev option is used along with -device driver \"virtio-9p-pci\".\n@item -device virtio-9p-pci,fsdev=@var{id},mount_tag=@var{mount_tag}\nOptions for virtio-9p-pci driver are:\n@table @option\n@item fsdev=@var{id}\nSpecifies the id value specified along with -fsdev option\n@item mount_tag=@var{mount_tag}\nSpecifies the tag name to be used by the guest to mount this export point\n@end table\n\nETEXI\n\nDEF(\"virtfs\", HAS_ARG, QEMU_OPTION_virtfs,\n    \"-virtfs local,path=path,mount_tag=tag,security_model=[mapped-xattr|mapped-file|passthrough|none]\\n\"\n    \"        [,writeout=immediate][,readonly][,socket=socket|sock_fd=sock_fd]\\n\",\n    QEMU_ARCH_ALL)\n\nSTEXI\n\n@item -virtfs @var{fsdriver}[,path=@var{path}],mount_tag=@var{mount_tag}[,security_model=@var{security_model}][,writeout=@var{writeout}][,readonly][,socket=@var{socket}|sock_fd=@var{sock_fd}]\n@findex -virtfs\n\nThe general form of a Virtual File system pass-through options are:\n@table @option\n@item @var{fsdriver}\nThis option specifies the fs driver backend to use.\nCurrently \"local\", \"handle\" and \"proxy\" file system drivers are supported.\n@item id=@var{id}\nSpecifies identifier for this device\n@item path=@var{path}\nSpecifies the export path for the file system device. Files under\nthis path will be available to the 9p client on the guest.\n@item security_model=@var{security_model}\nSpecifies the security model to be used for this export path.\nSupported security models are \"passthrough\", \"mapped-xattr\", \"mapped-file\" and \"none\".\nIn \"passthrough\" security model, files are stored using the same\ncredentials as they are created on the guest. This requires QEMU\nto run as root. In \"mapped-xattr\" security model, some of the file\nattributes like uid, gid, mode bits and link target are stored as\nfile attributes. For \"mapped-file\" these attributes are stored in the\nhidden .virtfs_metadata directory. Directories exported by this security model cannot\ninteract with other unix tools. \"none\" security model is same as\npassthrough except the sever won't report failures if it fails to\nset file attributes like ownership. Security model is mandatory only\nfor local fsdriver. Other fsdrivers (like handle, proxy) don't take security\nmodel as a parameter.\n@item writeout=@var{writeout}\nThis is an optional argument. The only supported value is \"immediate\".\nThis means that host page cache will be used to read and write data but\nwrite notification will be sent to the guest only when the data has been\nreported as written by the storage subsystem.\n@item readonly\nEnables exporting 9p share as a readonly mount for guests. By default\nread-write access is given.\n@item socket=@var{socket}\nEnables proxy filesystem driver to use passed socket file for\ncommunicating with virtfs-proxy-helper. Usually a helper like libvirt\nwill create socketpair and pass one of the fds as sock_fd\n@item sock_fd\nEnables proxy filesystem driver to use passed 'sock_fd' as the socket\ndescriptor for interfacing with virtfs-proxy-helper\n@end table\nETEXI\n\nDEF(\"virtfs_synth\", 0, QEMU_OPTION_virtfs_synth,\n    \"-virtfs_synth Create synthetic file system image\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -virtfs_synth\n@findex -virtfs_synth\nCreate synthetic file system image\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(USB options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"usb\", 0, QEMU_OPTION_usb,\n    \"-usb            enable the USB driver (will be the default soon)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -usb\n@findex -usb\nEnable the USB driver (will be the default soon)\nETEXI\n\nDEF(\"usbdevice\", HAS_ARG, QEMU_OPTION_usbdevice,\n    \"-usbdevice name add the host or guest USB device 'name'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n\n@item -usbdevice @var{devname}\n@findex -usbdevice\nAdd the USB device @var{devname}. @xref{usb_devices}.\n\n@table @option\n\n@item mouse\nVirtual Mouse. This will override the PS/2 mouse emulation when activated.\n\n@item tablet\nPointer device that uses absolute coordinates (like a touchscreen). This\nmeans QEMU is able to report the mouse position without having to grab the\nmouse. Also overrides the PS/2 mouse emulation when activated.\n\n@item disk:[format=@var{format}]:@var{file}\nMass storage device based on file. The optional @var{format} argument\nwill be used rather than detecting the format. Can be used to specify\n@code{format=raw} to avoid interpreting an untrusted format header.\n\n@item host:@var{bus}.@var{addr}\nPass through the host device identified by @var{bus}.@var{addr} (Linux only).\n\n@item host:@var{vendor_id}:@var{product_id}\nPass through the host device identified by @var{vendor_id}:@var{product_id}\n(Linux only).\n\n@item serial:[vendorid=@var{vendor_id}][,productid=@var{product_id}]:@var{dev}\nSerial converter to host character device @var{dev}, see @code{-serial} for the\navailable devices.\n\n@item braille\nBraille device.  This will use BrlAPI to display the braille output on a real\nor fake device.\n\n@item net:@var{options}\nNetwork adapter that supports CDC ethernet and RNDIS protocols.\n\n@end table\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Display options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"display\", HAS_ARG, QEMU_OPTION_display,\n    \"-display sdl[,frame=on|off][,alt_grab=on|off][,ctrl_grab=on|off]\\n\"\n    \"            [,window_close=on|off][,gl=on|off]\\n\"\n    \"-display gtk[,grab_on_hover=on|off][,gl=on|off]|\\n\"\n    \"-display vnc=<display>[,<optargs>]\\n\"\n    \"-display curses\\n\"\n    \"-display none\"\n    \"                select display type\\n\"\n    \"The default display is equivalent to\\n\"\n#if defined(CONFIG_GTK)\n            \"\\t\\\"-display gtk\\\"\\n\"\n#elif defined(CONFIG_SDL)\n            \"\\t\\\"-display sdl\\\"\\n\"\n#elif defined(CONFIG_COCOA)\n            \"\\t\\\"-display cocoa\\\"\\n\"\n#elif defined(CONFIG_VNC)\n            \"\\t\\\"-vnc localhost:0,to=99,id=default\\\"\\n\"\n#else\n            \"\\t\\\"-display none\\\"\\n\"\n#endif\n    , QEMU_ARCH_ALL)\nSTEXI\n@item -display @var{type}\n@findex -display\nSelect type of display to use. This option is a replacement for the\nold style -sdl/-curses/... options. Valid values for @var{type} are\n@table @option\n@item sdl\nDisplay video output via SDL (usually in a separate graphics\nwindow; see the SDL documentation for other possibilities).\n@item curses\nDisplay video output via curses. For graphics device models which\nsupport a text mode, QEMU can display this output using a\ncurses/ncurses interface. Nothing is displayed when the graphics\ndevice is in graphical mode or if the graphics device does not support\na text mode. Generally only the VGA device models support text mode.\n@item none\nDo not display video output. The guest will still see an emulated\ngraphics card, but its output will not be displayed to the QEMU\nuser. This option differs from the -nographic option in that it\nonly affects what is done with video output; -nographic also changes\nthe destination of the serial and parallel port data.\n@item gtk\nDisplay video output in a GTK window. This interface provides drop-down\nmenus and other UI elements to configure and control the VM during\nruntime.\n@item vnc\nStart a VNC server on display <arg>\n@end table\nETEXI\n\nDEF(\"nographic\", 0, QEMU_OPTION_nographic,\n    \"-nographic      disable graphical output and redirect serial I/Os to console\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -nographic\n@findex -nographic\nNormally, if QEMU is compiled with graphical window support, it displays\noutput such as guest graphics, guest console, and the QEMU monitor in a\nwindow. With this option, you can totally disable graphical output so\nthat QEMU is a simple command line application. The emulated serial port\nis redirected on the console and muxed with the monitor (unless\nredirected elsewhere explicitly). Therefore, you can still use QEMU to\ndebug a Linux kernel with a serial console. Use @key{C-a h} for help on\nswitching between the console and monitor.\nETEXI\n\nDEF(\"curses\", 0, QEMU_OPTION_curses,\n    \"-curses         shorthand for -display curses\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -curses\n@findex -curses\nNormally, if QEMU is compiled with graphical window support, it displays\noutput such as guest graphics, guest console, and the QEMU monitor in a\nwindow. With this option, QEMU can display the VGA output when in text\nmode using a curses/ncurses interface. Nothing is displayed in graphical\nmode.\nETEXI\n\nDEF(\"no-frame\", 0, QEMU_OPTION_no_frame,\n    \"-no-frame       open SDL window without a frame and window decorations\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -no-frame\n@findex -no-frame\nDo not use decorations for SDL windows and start them using the whole\navailable screen space. This makes the using QEMU in a dedicated desktop\nworkspace more convenient.\nETEXI\n\nDEF(\"alt-grab\", 0, QEMU_OPTION_alt_grab,\n    \"-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -alt-grab\n@findex -alt-grab\nUse Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note that this also\naffects the special keys (for fullscreen, monitor-mode switching, etc).\nETEXI\n\nDEF(\"ctrl-grab\", 0, QEMU_OPTION_ctrl_grab,\n    \"-ctrl-grab      use Right-Ctrl to grab mouse (instead of Ctrl-Alt)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -ctrl-grab\n@findex -ctrl-grab\nUse Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note that this also\naffects the special keys (for fullscreen, monitor-mode switching, etc).\nETEXI\n\nDEF(\"no-quit\", 0, QEMU_OPTION_no_quit,\n    \"-no-quit        disable SDL window close capability\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -no-quit\n@findex -no-quit\nDisable SDL window close capability.\nETEXI\n\nDEF(\"sdl\", 0, QEMU_OPTION_sdl,\n    \"-sdl            shorthand for -display sdl\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -sdl\n@findex -sdl\nEnable SDL.\nETEXI\n\nDEF(\"spice\", HAS_ARG, QEMU_OPTION_spice,\n    \"-spice [port=port][,tls-port=secured-port][,x509-dir=<dir>]\\n\"\n    \"       [,x509-key-file=<file>][,x509-key-password=<file>]\\n\"\n    \"       [,x509-cert-file=<file>][,x509-cacert-file=<file>]\\n\"\n    \"       [,x509-dh-key-file=<file>][,addr=addr][,ipv4|ipv6|unix]\\n\"\n    \"       [,tls-ciphers=<list>]\\n\"\n    \"       [,tls-channel=[main|display|cursor|inputs|record|playback]]\\n\"\n    \"       [,plaintext-channel=[main|display|cursor|inputs|record|playback]]\\n\"\n    \"       [,sasl][,password=<secret>][,disable-ticketing]\\n\"\n    \"       [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]]\\n\"\n    \"       [,jpeg-wan-compression=[auto|never|always]]\\n\"\n    \"       [,zlib-glz-wan-compression=[auto|never|always]]\\n\"\n    \"       [,streaming-video=[off|all|filter]][,disable-copy-paste]\\n\"\n    \"       [,disable-agent-file-xfer][,agent-mouse=[on|off]]\\n\"\n    \"       [,playback-compression=[on|off]][,seamless-migration=[on|off]]\\n\"\n    \"       [,gl=[on|off]][,rendernode=<file>]\\n\"\n    \"   enable spice\\n\"\n    \"   at least one of {port, tls-port} is mandatory\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -spice @var{option}[,@var{option}[,...]]\n@findex -spice\nEnable the spice remote desktop protocol. Valid options are\n\n@table @option\n\n@item port=<nr>\nSet the TCP port spice is listening on for plaintext channels.\n\n@item addr=<addr>\nSet the IP address spice is listening on.  Default is any address.\n\n@item ipv4\n@itemx ipv6\n@itemx unix\nForce using the specified IP version.\n\n@item password=<secret>\nSet the password you need to authenticate.\n\n@item sasl\nRequire that the client use SASL to authenticate with the spice.\nThe exact choice of authentication method used is controlled from the\nsystem / user's SASL configuration file for the 'qemu' service. This\nis typically found in /etc/sasl2/qemu.conf. If running QEMU as an\nunprivileged user, an environment variable SASL_CONF_PATH can be used\nto make it search alternate locations for the service config.\nWhile some SASL auth methods can also provide data encryption (eg GSSAPI),\nit is recommended that SASL always be combined with the 'tls' and\n'x509' settings to enable use of SSL and server certificates. This\nensures a data encryption preventing compromise of authentication\ncredentials.\n\n@item disable-ticketing\nAllow client connects without authentication.\n\n@item disable-copy-paste\nDisable copy paste between the client and the guest.\n\n@item disable-agent-file-xfer\nDisable spice-vdagent based file-xfer between the client and the guest.\n\n@item tls-port=<nr>\nSet the TCP port spice is listening on for encrypted channels.\n\n@item x509-dir=<dir>\nSet the x509 file directory. Expects same filenames as -vnc $display,x509=$dir\n\n@item x509-key-file=<file>\n@itemx x509-key-password=<file>\n@itemx x509-cert-file=<file>\n@itemx x509-cacert-file=<file>\n@itemx x509-dh-key-file=<file>\nThe x509 file names can also be configured individually.\n\n@item tls-ciphers=<list>\nSpecify which ciphers to use.\n\n@item tls-channel=[main|display|cursor|inputs|record|playback]\n@itemx plaintext-channel=[main|display|cursor|inputs|record|playback]\nForce specific channel to be used with or without TLS encryption.  The\noptions can be specified multiple times to configure multiple\nchannels.  The special name \"default\" can be used to set the default\nmode.  For channels which are not explicitly forced into one mode the\nspice client is allowed to pick tls/plaintext as he pleases.\n\n@item image-compression=[auto_glz|auto_lz|quic|glz|lz|off]\nConfigure image compression (lossless).\nDefault is auto_glz.\n\n@item jpeg-wan-compression=[auto|never|always]\n@itemx zlib-glz-wan-compression=[auto|never|always]\nConfigure wan image compression (lossy for slow links).\nDefault is auto.\n\n@item streaming-video=[off|all|filter]\nConfigure video stream detection.  Default is off.\n\n@item agent-mouse=[on|off]\nEnable/disable passing mouse events via vdagent.  Default is on.\n\n@item playback-compression=[on|off]\nEnable/disable audio stream compression (using celt 0.5.1).  Default is on.\n\n@item seamless-migration=[on|off]\nEnable/disable spice seamless migration. Default is off.\n\n@item gl=[on|off]\nEnable/disable OpenGL context. Default is off.\n\n@item rendernode=<file>\nDRM render node for OpenGL rendering. If not specified, it will pick\nthe first available. (Since 2.9)\n\n@end table\nETEXI\n\nDEF(\"portrait\", 0, QEMU_OPTION_portrait,\n    \"-portrait       rotate graphical output 90 deg left (only PXA LCD)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -portrait\n@findex -portrait\nRotate graphical output 90 deg left (only PXA LCD).\nETEXI\n\nDEF(\"rotate\", HAS_ARG, QEMU_OPTION_rotate,\n    \"-rotate <deg>   rotate graphical output some deg left (only PXA LCD)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -rotate @var{deg}\n@findex -rotate\nRotate graphical output some deg left (only PXA LCD).\nETEXI\n\nDEF(\"vga\", HAS_ARG, QEMU_OPTION_vga,\n    \"-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]\\n\"\n    \"                select video card type\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -vga @var{type}\n@findex -vga\nSelect type of VGA card to emulate. Valid values for @var{type} are\n@table @option\n@item cirrus\nCirrus Logic GD5446 Video card. All Windows versions starting from\nWindows 95 should recognize and use this graphic card. For optimal\nperformances, use 16 bit color depth in the guest and the host OS.\n(This card was the default before QEMU 2.2)\n@item std\nStandard VGA card with Bochs VBE extensions.  If your guest OS\nsupports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want\nto use high resolution modes (>= 1280x1024x16) then you should use\nthis option. (This card is the default since QEMU 2.2)\n@item vmware\nVMWare SVGA-II compatible adapter. Use it if you have sufficiently\nrecent XFree86/XOrg server or Windows guest with a driver for this\ncard.\n@item qxl\nQXL paravirtual graphic card.  It is VGA compatible (including VESA\n2.0 VBE support).  Works best with qxl guest drivers installed though.\nRecommended choice when using the spice protocol.\n@item tcx\n(sun4m only) Sun TCX framebuffer. This is the default framebuffer for\nsun4m machines and offers both 8-bit and 24-bit colour depths at a\nfixed resolution of 1024x768.\n@item cg3\n(sun4m only) Sun cgthree framebuffer. This is a simple 8-bit framebuffer\nfor sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900 (OBP)\nresolutions aimed at people wishing to run older Solaris versions.\n@item virtio\nVirtio VGA card.\n@item none\nDisable VGA card.\n@end table\nETEXI\n\nDEF(\"full-screen\", 0, QEMU_OPTION_full_screen,\n    \"-full-screen    start in full screen\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -full-screen\n@findex -full-screen\nStart in full screen.\nETEXI\n\nDEF(\"g\", 1, QEMU_OPTION_g ,\n    \"-g WxH[xDEPTH]  Set the initial graphical resolution and depth\\n\",\n    QEMU_ARCH_PPC | QEMU_ARCH_SPARC)\nSTEXI\n@item -g @var{width}x@var{height}[x@var{depth}]\n@findex -g\nSet the initial graphical resolution and depth (PPC, SPARC only).\nETEXI\n\nDEF(\"vnc\", HAS_ARG, QEMU_OPTION_vnc ,\n    \"-vnc <display>  shorthand for -display vnc=<display>\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -vnc @var{display}[,@var{option}[,@var{option}[,...]]]\n@findex -vnc\nNormally, if QEMU is compiled with graphical window support, it displays\noutput such as guest graphics, guest console, and the QEMU monitor in a\nwindow. With this option, you can have QEMU listen on VNC display\n@var{display} and redirect the VGA display over the VNC session. It is\nvery useful to enable the usb tablet device when using this option\n(option @option{-usbdevice tablet}). When using the VNC display, you\nmust use the @option{-k} parameter to set the keyboard layout if you are\nnot using en-us. Valid syntax for the @var{display} is\n\n@table @option\n\n@item to=@var{L}\n\nWith this option, QEMU will try next available VNC @var{display}s, until the\nnumber @var{L}, if the origianlly defined \"-vnc @var{display}\" is not\navailable, e.g. port 5900+@var{display} is already used by another\napplication. By default, to=0.\n\n@item @var{host}:@var{d}\n\nTCP connections will only be allowed from @var{host} on display @var{d}.\nBy convention the TCP port is 5900+@var{d}. Optionally, @var{host} can\nbe omitted in which case the server will accept connections from any host.\n\n@item unix:@var{path}\n\nConnections will be allowed over UNIX domain sockets where @var{path} is the\nlocation of a unix socket to listen for connections on.\n\n@item none\n\nVNC is initialized but not started. The monitor @code{change} command\ncan be used to later start the VNC server.\n\n@end table\n\nFollowing the @var{display} value there may be one or more @var{option} flags\nseparated by commas. Valid options are\n\n@table @option\n\n@item reverse\n\nConnect to a listening VNC client via a ``reverse'' connection. The\nclient is specified by the @var{display}. For reverse network\nconnections (@var{host}:@var{d},@code{reverse}), the @var{d} argument\nis a TCP port number, not a display number.\n\n@item websocket\n\nOpens an additional TCP listening port dedicated to VNC Websocket connections.\nIf a bare @var{websocket} option is given, the Websocket port is\n5700+@var{display}. An alternative port can be specified with the\nsyntax @code{websocket}=@var{port}.\n\nIf @var{host} is specified connections will only be allowed from this host.\nIt is possible to control the websocket listen address independently, using\nthe syntax @code{websocket}=@var{host}:@var{port}.\n\nIf no TLS credentials are provided, the websocket connection runs in\nunencrypted mode. If TLS credentials are provided, the websocket connection\nrequires encrypted client connections.\n\n@item password\n\nRequire that password based authentication is used for client connections.\n\nThe password must be set separately using the @code{set_password} command in\nthe @ref{pcsys_monitor}. The syntax to change your password is:\n@code{set_password <protocol> <password>} where <protocol> could be either\n\"vnc\" or \"spice\".\n\nIf you would like to change <protocol> password expiration, you should use\n@code{expire_password <protocol> <expiration-time>} where expiration time could\nbe one of the following options: now, never, +seconds or UNIX time of\nexpiration, e.g. +60 to make password expire in 60 seconds, or 1335196800\nto make password expire on \"Mon Apr 23 12:00:00 EDT 2012\" (UNIX time for this\ndate and time).\n\nYou can also use keywords \"now\" or \"never\" for the expiration time to\nallow <protocol> password to expire immediately or never expire.\n\n@item tls-creds=@var{ID}\n\nProvides the ID of a set of TLS credentials to use to secure the\nVNC server. They will apply to both the normal VNC server socket\nand the websocket socket (if enabled). Setting TLS credentials\nwill cause the VNC server socket to enable the VeNCrypt auth\nmechanism.  The credentials should have been previously created\nusing the @option{-object tls-creds} argument.\n\nThe @option{tls-creds} parameter obsoletes the @option{tls},\n@option{x509}, and @option{x509verify} options, and as such\nit is not permitted to set both new and old type options at\nthe same time.\n\n@item tls\n\nRequire that client use TLS when communicating with the VNC server. This\nuses anonymous TLS credentials so is susceptible to a man-in-the-middle\nattack. It is recommended that this option be combined with either the\n@option{x509} or @option{x509verify} options.\n\nThis option is now deprecated in favor of using the @option{tls-creds}\nargument.\n\n@item x509=@var{/path/to/certificate/dir}\n\nValid if @option{tls} is specified. Require that x509 credentials are used\nfor negotiating the TLS session. The server will send its x509 certificate\nto the client. It is recommended that a password be set on the VNC server\nto provide authentication of the client when this is used. The path following\nthis option specifies where the x509 certificates are to be loaded from.\nSee the @ref{vnc_security} section for details on generating certificates.\n\nThis option is now deprecated in favour of using the @option{tls-creds}\nargument.\n\n@item x509verify=@var{/path/to/certificate/dir}\n\nValid if @option{tls} is specified. Require that x509 credentials are used\nfor negotiating the TLS session. The server will send its x509 certificate\nto the client, and request that the client send its own x509 certificate.\nThe server will validate the client's certificate against the CA certificate,\nand reject clients when validation fails. If the certificate authority is\ntrusted, this is a sufficient authentication mechanism. You may still wish\nto set a password on the VNC server as a second authentication layer. The\npath following this option specifies where the x509 certificates are to\nbe loaded from. See the @ref{vnc_security} section for details on generating\ncertificates.\n\nThis option is now deprecated in favour of using the @option{tls-creds}\nargument.\n\n@item sasl\n\nRequire that the client use SASL to authenticate with the VNC server.\nThe exact choice of authentication method used is controlled from the\nsystem / user's SASL configuration file for the 'qemu' service. This\nis typically found in /etc/sasl2/qemu.conf. If running QEMU as an\nunprivileged user, an environment variable SASL_CONF_PATH can be used\nto make it search alternate locations for the service config.\nWhile some SASL auth methods can also provide data encryption (eg GSSAPI),\nit is recommended that SASL always be combined with the 'tls' and\n'x509' settings to enable use of SSL and server certificates. This\nensures a data encryption preventing compromise of authentication\ncredentials. See the @ref{vnc_security} section for details on using\nSASL authentication.\n\n@item acl\n\nTurn on access control lists for checking of the x509 client certificate\nand SASL party. For x509 certs, the ACL check is made against the\ncertificate's distinguished name. This is something that looks like\n@code{C=GB,O=ACME,L=Boston,CN=bob}. For SASL party, the ACL check is\nmade against the username, which depending on the SASL plugin, may\ninclude a realm component, eg @code{bob} or @code{bob@@EXAMPLE.COM}.\nWhen the @option{acl} flag is set, the initial access list will be\nempty, with a @code{deny} policy. Thus no one will be allowed to\nuse the VNC server until the ACLs have been loaded. This can be\nachieved using the @code{acl} monitor command.\n\n@item lossy\n\nEnable lossy compression methods (gradient, JPEG, ...). If this\noption is set, VNC client may receive lossy framebuffer updates\ndepending on its encoding settings. Enabling this option can save\na lot of bandwidth at the expense of quality.\n\n@item non-adaptive\n\nDisable adaptive encodings. Adaptive encodings are enabled by default.\nAn adaptive encoding will try to detect frequently updated screen regions,\nand send updates in these regions using a lossy encoding (like JPEG).\nThis can be really helpful to save bandwidth when playing videos. Disabling\nadaptive encodings restores the original static behavior of encodings\nlike Tight.\n\n@item share=[allow-exclusive|force-shared|ignore]\n\nSet display sharing policy.  'allow-exclusive' allows clients to ask\nfor exclusive access.  As suggested by the rfb spec this is\nimplemented by dropping other connections.  Connecting multiple\nclients in parallel requires all clients asking for a shared session\n(vncviewer: -shared switch).  This is the default.  'force-shared'\ndisables exclusive client access.  Useful for shared desktop sessions,\nwhere you don't want someone forgetting specify -shared disconnect\neverybody else.  'ignore' completely ignores the shared flag and\nallows everybody connect unconditionally.  Doesn't conform to the rfb\nspec but is traditional QEMU behavior.\n\n@item key-delay-ms\n\nSet keyboard delay, for key down and key up events, in milliseconds.\nDefault is 10.  Keyboards are low-bandwidth devices, so this slowdown\ncan help the device and guest to keep up and not lose events in case\nevents are arriving in bulk.  Possible causes for the latter are flaky\nnetwork connections, or scripts for automated testing.\n\n@end table\nETEXI\n\nSTEXI\n@end table\nETEXI\nARCHHEADING(, QEMU_ARCH_I386)\n\nARCHHEADING(i386 target only, QEMU_ARCH_I386)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"win2k-hack\", 0, QEMU_OPTION_win2k_hack,\n    \"-win2k-hack     use it when installing Windows 2000 to avoid a disk full bug\\n\",\n    QEMU_ARCH_I386)\nSTEXI\n@item -win2k-hack\n@findex -win2k-hack\nUse it when installing Windows 2000 to avoid a disk full bug. After\nWindows 2000 is installed, you no longer need this option (this option\nslows down the IDE transfers).\nETEXI\n\nHXCOMM Deprecated by -rtc\nDEF(\"rtc-td-hack\", 0, QEMU_OPTION_rtc_td_hack, \"\", QEMU_ARCH_I386)\n\nDEF(\"no-fd-bootchk\", 0, QEMU_OPTION_no_fd_bootchk,\n    \"-no-fd-bootchk  disable boot signature checking for floppy disks\\n\",\n    QEMU_ARCH_I386)\nSTEXI\n@item -no-fd-bootchk\n@findex -no-fd-bootchk\nDisable boot signature checking for floppy disks in BIOS. May\nbe needed to boot from old floppy disks.\nETEXI\n\nDEF(\"no-acpi\", 0, QEMU_OPTION_no_acpi,\n           \"-no-acpi        disable ACPI\\n\", QEMU_ARCH_I386 | QEMU_ARCH_ARM)\nSTEXI\n@item -no-acpi\n@findex -no-acpi\nDisable ACPI (Advanced Configuration and Power Interface) support. Use\nit if your guest OS complains about ACPI problems (PC target machine\nonly).\nETEXI\n\nDEF(\"no-hpet\", 0, QEMU_OPTION_no_hpet,\n    \"-no-hpet        disable HPET\\n\", QEMU_ARCH_I386)\nSTEXI\n@item -no-hpet\n@findex -no-hpet\nDisable HPET support.\nETEXI\n\nDEF(\"acpitable\", HAS_ARG, QEMU_OPTION_acpitable,\n    \"-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n][,asl_compiler_id=str][,asl_compiler_rev=n][,{data|file}=file1[:file2]...]\\n\"\n    \"                ACPI table description\\n\", QEMU_ARCH_I386)\nSTEXI\n@item -acpitable [sig=@var{str}][,rev=@var{n}][,oem_id=@var{str}][,oem_table_id=@var{str}][,oem_rev=@var{n}] [,asl_compiler_id=@var{str}][,asl_compiler_rev=@var{n}][,data=@var{file1}[:@var{file2}]...]\n@findex -acpitable\nAdd ACPI table with specified header fields and context from specified files.\nFor file=, take whole ACPI table from the specified files, including all\nACPI headers (possible overridden by other options).\nFor data=, only data\nportion of the table is used, all header information is specified in the\ncommand line.\nIf a SLIC table is supplied to QEMU, then the SLIC's oem_id and oem_table_id\nfields will override the same in the RSDT and the FADT (a.k.a. FACP), in order\nto ensure the field matches required by the Microsoft SLIC spec and the ACPI\nspec.\nETEXI\n\nDEF(\"smbios\", HAS_ARG, QEMU_OPTION_smbios,\n    \"-smbios file=binary\\n\"\n    \"                load SMBIOS entry from binary file\\n\"\n    \"-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d]\\n\"\n    \"              [,uefi=on|off]\\n\"\n    \"                specify SMBIOS type 0 fields\\n\"\n    \"-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str]\\n\"\n    \"              [,uuid=uuid][,sku=str][,family=str]\\n\"\n    \"                specify SMBIOS type 1 fields\\n\"\n    \"-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str]\\n\"\n    \"              [,asset=str][,location=str]\\n\"\n    \"                specify SMBIOS type 2 fields\\n\"\n    \"-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str]\\n\"\n    \"              [,sku=str]\\n\"\n    \"                specify SMBIOS type 3 fields\\n\"\n    \"-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str]\\n\"\n    \"              [,asset=str][,part=str]\\n\"\n    \"                specify SMBIOS type 4 fields\\n\"\n    \"-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str]\\n\"\n    \"               [,asset=str][,part=str][,speed=%d]\\n\"\n    \"                specify SMBIOS type 17 fields\\n\",\n    QEMU_ARCH_I386 | QEMU_ARCH_ARM)\nSTEXI\n@item -smbios file=@var{binary}\n@findex -smbios\nLoad SMBIOS entry from binary file.\n\n@item -smbios type=0[,vendor=@var{str}][,version=@var{str}][,date=@var{str}][,release=@var{%d.%d}][,uefi=on|off]\nSpecify SMBIOS type 0 fields\n\n@item -smbios type=1[,manufacturer=@var{str}][,product=@var{str}][,version=@var{str}][,serial=@var{str}][,uuid=@var{uuid}][,sku=@var{str}][,family=@var{str}]\nSpecify SMBIOS type 1 fields\n\n@item -smbios type=2[,manufacturer=@var{str}][,product=@var{str}][,version=@var{str}][,serial=@var{str}][,asset=@var{str}][,location=@var{str}][,family=@var{str}]\nSpecify SMBIOS type 2 fields\n\n@item -smbios type=3[,manufacturer=@var{str}][,version=@var{str}][,serial=@var{str}][,asset=@var{str}][,sku=@var{str}]\nSpecify SMBIOS type 3 fields\n\n@item -smbios type=4[,sock_pfx=@var{str}][,manufacturer=@var{str}][,version=@var{str}][,serial=@var{str}][,asset=@var{str}][,part=@var{str}]\nSpecify SMBIOS type 4 fields\n\n@item -smbios type=17[,loc_pfx=@var{str}][,bank=@var{str}][,manufacturer=@var{str}][,serial=@var{str}][,asset=@var{str}][,part=@var{str}][,speed=@var{%d}]\nSpecify SMBIOS type 17 fields\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Network options)\nSTEXI\n@table @option\nETEXI\n\nHXCOMM Legacy slirp options (now moved to -net user):\n#ifdef CONFIG_SLIRP\nDEF(\"tftp\", HAS_ARG, QEMU_OPTION_tftp, \"\", QEMU_ARCH_ALL)\nDEF(\"bootp\", HAS_ARG, QEMU_OPTION_bootp, \"\", QEMU_ARCH_ALL)\nDEF(\"redir\", HAS_ARG, QEMU_OPTION_redir, \"\", QEMU_ARCH_ALL)\n#ifndef _WIN32\nDEF(\"smb\", HAS_ARG, QEMU_OPTION_smb, \"\", QEMU_ARCH_ALL)\n#endif\n#endif\n\nDEF(\"netdev\", HAS_ARG, QEMU_OPTION_netdev,\n#ifdef CONFIG_SLIRP\n    \"-netdev user,id=str[,ipv4[=on|off]][,net=addr[/mask]][,host=addr]\\n\"\n    \"         [,ipv6[=on|off]][,ipv6-net=addr[/int]][,ipv6-host=addr]\\n\"\n    \"         [,restrict=on|off][,hostname=host][,dhcpstart=addr]\\n\"\n    \"         [,dns=addr][,ipv6-dns=addr][,dnssearch=domain][,tftp=dir]\\n\"\n    \"         [,bootfile=f][,hostfwd=rule][,guestfwd=rule]\"\n#ifndef _WIN32\n                                             \"[,smb=dir[,smbserver=addr]]\\n\"\n#endif\n    \"                configure a user mode network backend with ID 'str',\\n\"\n    \"                its DHCP server and optional services\\n\"\n#endif\n#ifdef _WIN32\n    \"-netdev tap,id=str,ifname=name\\n\"\n    \"                configure a host TAP network backend with ID 'str'\\n\"\n#else\n    \"-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile]\\n\"\n    \"         [,br=bridge][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off]\\n\"\n    \"         [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]\\n\"\n    \"         [,poll-us=n]\\n\"\n    \"                configure a host TAP network backend with ID 'str'\\n\"\n    \"                connected to a bridge (default=\" DEFAULT_BRIDGE_INTERFACE \")\\n\"\n    \"                use network scripts 'file' (default=\" DEFAULT_NETWORK_SCRIPT \")\\n\"\n    \"                to configure it and 'dfile' (default=\" DEFAULT_NETWORK_DOWN_SCRIPT \")\\n\"\n    \"                to deconfigure it\\n\"\n    \"                use '[down]script=no' to disable script execution\\n\"\n    \"                use network helper 'helper' (default=\" DEFAULT_BRIDGE_HELPER \") to\\n\"\n    \"                configure it\\n\"\n    \"                use 'fd=h' to connect to an already opened TAP interface\\n\"\n    \"                use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces\\n\"\n    \"                use 'sndbuf=nbytes' to limit the size of the send buffer (the\\n\"\n    \"                default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576')\\n\"\n    \"                use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag\\n\"\n    \"                use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition\\n\"\n    \"                use vhost=on to enable experimental in kernel accelerator\\n\"\n    \"                    (only has effect for virtio guests which use MSIX)\\n\"\n    \"                use vhostforce=on to force vhost on for non-MSIX virtio guests\\n\"\n    \"                use 'vhostfd=h' to connect to an already opened vhost net device\\n\"\n    \"                use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices\\n\"\n    \"                use 'queues=n' to specify the number of queues to be created for multiqueue TAP\\n\"\n    \"                use 'poll-us=n' to speciy the maximum number of microseconds that could be\\n\"\n    \"                spent on busy polling for vhost net\\n\"\n    \"-netdev bridge,id=str[,br=bridge][,helper=helper]\\n\"\n    \"                configure a host TAP network backend with ID 'str' that is\\n\"\n    \"                connected to a bridge (default=\" DEFAULT_BRIDGE_INTERFACE \")\\n\"\n    \"                using the program 'helper (default=\" DEFAULT_BRIDGE_HELPER \")\\n\"\n#endif\n#ifdef __linux__\n    \"-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport]\\n\"\n    \"         [,rxsession=rxsession],txsession=txsession[,ipv6=on/off][,udp=on/off]\\n\"\n    \"         [,cookie64=on/off][,counter][,pincounter][,txcookie=txcookie]\\n\"\n    \"         [,rxcookie=rxcookie][,offset=offset]\\n\"\n    \"                configure a network backend with ID 'str' connected to\\n\"\n    \"                an Ethernet over L2TPv3 pseudowire.\\n\"\n    \"                Linux kernel 3.3+ as well as most routers can talk\\n\"\n    \"                L2TPv3. This transport allows connecting a VM to a VM,\\n\"\n    \"                VM to a router and even VM to Host. It is a nearly-universal\\n\"\n    \"                standard (RFC3391). Note - this implementation uses static\\n\"\n    \"                pre-configured tunnels (same as the Linux kernel).\\n\"\n    \"                use 'src=' to specify source address\\n\"\n    \"                use 'dst=' to specify destination address\\n\"\n    \"                use 'udp=on' to specify udp encapsulation\\n\"\n    \"                use 'srcport=' to specify source udp port\\n\"\n    \"                use 'dstport=' to specify destination udp port\\n\"\n    \"                use 'ipv6=on' to force v6\\n\"\n    \"                L2TPv3 uses cookies to prevent misconfiguration as\\n\"\n    \"                well as a weak security measure\\n\"\n    \"                use 'rxcookie=0x012345678' to specify a rxcookie\\n\"\n    \"                use 'txcookie=0x012345678' to specify a txcookie\\n\"\n    \"                use 'cookie64=on' to set cookie size to 64 bit, otherwise 32\\n\"\n    \"                use 'counter=off' to force a 'cut-down' L2TPv3 with no counter\\n\"\n    \"                use 'pincounter=on' to work around broken counter handling in peer\\n\"\n    \"                use 'offset=X' to add an extra offset between header and data\\n\"\n#endif\n    \"-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port]\\n\"\n    \"                configure a network backend to connect to another network\\n\"\n    \"                using a socket connection\\n\"\n    \"-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]]\\n\"\n    \"                configure a network backend to connect to a multicast maddr and port\\n\"\n    \"                use 'localaddr=addr' to specify the host address to send packets from\\n\"\n    \"-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port]\\n\"\n    \"                configure a network backend to connect to another network\\n\"\n    \"                using an UDP tunnel\\n\"\n#ifdef CONFIG_VDE\n    \"-netdev vde,id=str[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]\\n\"\n    \"                configure a network backend to connect to port 'n' of a vde switch\\n\"\n    \"                running on host and listening for incoming connections on 'socketpath'.\\n\"\n    \"                Use group 'groupname' and mode 'octalmode' to change default\\n\"\n    \"                ownership and permissions for communication port.\\n\"\n#endif\n#ifdef CONFIG_NETMAP\n    \"-netdev netmap,id=str,ifname=name[,devname=nmname]\\n\"\n    \"                attach to the existing netmap-enabled network interface 'name', or to a\\n\"\n    \"                VALE port (created on the fly) called 'name' ('nmname' is name of the \\n\"\n    \"                netmap device, defaults to '/dev/netmap')\\n\"\n#endif\n    \"-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off]\\n\"\n    \"                configure a vhost-user network, backed by a chardev 'dev'\\n\"\n    \"-netdev hubport,id=str,hubid=n\\n\"\n    \"                configure a hub port on QEMU VLAN 'n'\\n\", QEMU_ARCH_ALL)\nDEF(\"net\", HAS_ARG, QEMU_OPTION_net,\n    \"-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]\\n\"\n    \"                old way to create a new NIC and connect it to VLAN 'n'\\n\"\n    \"                (use the '-device devtype,netdev=str' option if possible instead)\\n\"\n    \"-net dump[,vlan=n][,file=f][,len=n]\\n\"\n    \"                dump traffic on vlan 'n' to file 'f' (max n bytes per packet)\\n\"\n    \"-net none       use it alone to have zero network devices. If no -net option\\n\"\n    \"                is provided, the default is '-net nic -net user'\\n\"\n    \"-net [\"\n#ifdef CONFIG_SLIRP\n    \"user|\"\n#endif\n    \"tap|\"\n    \"bridge|\"\n#ifdef CONFIG_VDE\n    \"vde|\"\n#endif\n#ifdef CONFIG_NETMAP\n    \"netmap|\"\n#endif\n    \"socket][,vlan=n][,option][,option][,...]\\n\"\n    \"                old way to initialize a host network interface\\n\"\n    \"                (use the -netdev option if possible instead)\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -net nic[,vlan=@var{n}][,macaddr=@var{mac}][,model=@var{type}] [,name=@var{name}][,addr=@var{addr}][,vectors=@var{v}]\n@findex -net\nCreate a new Network Interface Card and connect it to VLAN @var{n} (@var{n}\n= 0 is the default). The NIC is an e1000 by default on the PC\ntarget. Optionally, the MAC address can be changed to @var{mac}, the\ndevice address set to @var{addr} (PCI cards only),\nand a @var{name} can be assigned for use in monitor commands.\nOptionally, for PCI cards, you can specify the number @var{v} of MSI-X vectors\nthat the card should have; this option currently only affects virtio cards; set\n@var{v} = 0 to disable MSI-X. If no @option{-net} option is specified, a single\nNIC is created.  QEMU can emulate several different models of network card.\nValid values for @var{type} are\n@code{virtio}, @code{i82551}, @code{i82557b}, @code{i82559er},\n@code{ne2k_pci}, @code{ne2k_isa}, @code{pcnet}, @code{rtl8139},\n@code{e1000}, @code{smc91c111}, @code{lance} and @code{mcf_fec}.\nNot all devices are supported on all targets.  Use @code{-net nic,model=help}\nfor a list of available devices for your target.\n\n@item -netdev user,id=@var{id}[,@var{option}][,@var{option}][,...]\n@findex -netdev\n@item -net user[,@var{option}][,@var{option}][,...]\nUse the user mode network stack which requires no administrator\nprivilege to run. Valid options are:\n\n@table @option\n@item vlan=@var{n}\nConnect user mode stack to VLAN @var{n} (@var{n} = 0 is the default).\n\n@item id=@var{id}\n@itemx name=@var{name}\nAssign symbolic name for use in monitor commands.\n\n@option{ipv4} and @option{ipv6} specify that either IPv4 or IPv6 must\nbe enabled.  If neither is specified both protocols are enabled.\n\n@item net=@var{addr}[/@var{mask}]\nSet IP network address the guest will see. Optionally specify the netmask,\neither in the form a.b.c.d or as number of valid top-most bits. Default is\n10.0.2.0/24.\n\n@item host=@var{addr}\nSpecify the guest-visible address of the host. Default is the 2nd IP in the\nguest network, i.e. x.x.x.2.\n\n@item ipv6-net=@var{addr}[/@var{int}]\nSet IPv6 network address the guest will see (default is fec0::/64). The\nnetwork prefix is given in the usual hexadecimal IPv6 address\nnotation. The prefix size is optional, and is given as the number of\nvalid top-most bits (default is 64).\n\n@item ipv6-host=@var{addr}\nSpecify the guest-visible IPv6 address of the host. Default is the 2nd IPv6 in\nthe guest network, i.e. xxxx::2.\n\n@item restrict=on|off\nIf this option is enabled, the guest will be isolated, i.e. it will not be\nable to contact the host and no guest IP packets will be routed over the host\nto the outside. This option does not affect any explicitly set forwarding rules.\n\n@item hostname=@var{name}\nSpecifies the client hostname reported by the built-in DHCP server.\n\n@item dhcpstart=@var{addr}\nSpecify the first of the 16 IPs the built-in DHCP server can assign. Default\nis the 15th to 31st IP in the guest network, i.e. x.x.x.15 to x.x.x.31.\n\n@item dns=@var{addr}\nSpecify the guest-visible address of the virtual nameserver. The address must\nbe different from the host address. Default is the 3rd IP in the guest network,\ni.e. x.x.x.3.\n\n@item ipv6-dns=@var{addr}\nSpecify the guest-visible address of the IPv6 virtual nameserver. The address\nmust be different from the host address. Default is the 3rd IP in the guest\nnetwork, i.e. xxxx::3.\n\n@item dnssearch=@var{domain}\nProvides an entry for the domain-search list sent by the built-in\nDHCP server. More than one domain suffix can be transmitted by specifying\nthis option multiple times. If supported, this will cause the guest to\nautomatically try to append the given domain suffix(es) in case a domain name\ncan not be resolved.\n\nExample:\n@example\nqemu -net user,dnssearch=mgmt.example.org,dnssearch=example.org [...]\n@end example\n\n@item tftp=@var{dir}\nWhen using the user mode network stack, activate a built-in TFTP\nserver. The files in @var{dir} will be exposed as the root of a TFTP server.\nThe TFTP client on the guest must be configured in binary mode (use the command\n@code{bin} of the Unix TFTP client).\n\n@item bootfile=@var{file}\nWhen using the user mode network stack, broadcast @var{file} as the BOOTP\nfilename. In conjunction with @option{tftp}, this can be used to network boot\na guest from a local directory.\n\nExample (using pxelinux):\n@example\nqemu-system-i386 -hda linux.img -boot n -net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0\n@end example\n\n@item smb=@var{dir}[,smbserver=@var{addr}]\nWhen using the user mode network stack, activate a built-in SMB\nserver so that Windows OSes can access to the host files in @file{@var{dir}}\ntransparently. The IP address of the SMB server can be set to @var{addr}. By\ndefault the 4th IP in the guest network is used, i.e. x.x.x.4.\n\nIn the guest Windows OS, the line:\n@example\n10.0.2.4 smbserver\n@end example\nmust be added in the file @file{C:\\WINDOWS\\LMHOSTS} (for windows 9x/Me)\nor @file{C:\\WINNT\\SYSTEM32\\DRIVERS\\ETC\\LMHOSTS} (Windows NT/2000).\n\nThen @file{@var{dir}} can be accessed in @file{\\\\smbserver\\qemu}.\n\nNote that a SAMBA server must be installed on the host OS.\nQEMU was tested successfully with smbd versions from Red Hat 9,\nFedora Core 3 and OpenSUSE 11.x.\n\n@item hostfwd=[tcp|udp]:[@var{hostaddr}]:@var{hostport}-[@var{guestaddr}]:@var{guestport}\nRedirect incoming TCP or UDP connections to the host port @var{hostport} to\nthe guest IP address @var{guestaddr} on guest port @var{guestport}. If\n@var{guestaddr} is not specified, its value is x.x.x.15 (default first address\ngiven by the built-in DHCP server). By specifying @var{hostaddr}, the rule can\nbe bound to a specific host interface. If no connection type is set, TCP is\nused. This option can be given multiple times.\n\nFor example, to redirect host X11 connection from screen 1 to guest\nscreen 0, use the following:\n\n@example\n# on the host\nqemu-system-i386 -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]\n# this host xterm should open in the guest X11 server\nxterm -display :1\n@end example\n\nTo redirect telnet connections from host port 5555 to telnet port on\nthe guest, use the following:\n\n@example\n# on the host\nqemu-system-i386 -net user,hostfwd=tcp::5555-:23 [...]\ntelnet localhost 5555\n@end example\n\nThen when you use on the host @code{telnet localhost 5555}, you\nconnect to the guest telnet server.\n\n@item guestfwd=[tcp]:@var{server}:@var{port}-@var{dev}\n@itemx guestfwd=[tcp]:@var{server}:@var{port}-@var{cmd:command}\nForward guest TCP connections to the IP address @var{server} on port @var{port}\nto the character device @var{dev} or to a program executed by @var{cmd:command}\nwhich gets spawned for each connection. This option can be given multiple times.\n\nYou can either use a chardev directly and have that one used throughout QEMU's\nlifetime, like in the following example:\n\n@example\n# open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever\n# the guest accesses it\nqemu -net user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321 [...]\n@end example\n\nOr you can execute a command on every TCP connection established by the guest,\nso that QEMU behaves similar to an inetd process for that virtual server:\n\n@example\n# call \"netcat 10.10.1.1 4321\" on every TCP connection to 10.0.2.100:1234\n# and connect the TCP stream to its stdin/stdout\nqemu -net 'user,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'\n@end example\n\n@end table\n\nNote: Legacy stand-alone options -tftp, -bootp, -smb and -redir are still\nprocessed and applied to -net user. Mixing them with the new configuration\nsyntax gives undefined results. Their use for new applications is discouraged\nas they will be removed from future versions.\n\n@item -netdev tap,id=@var{id}[,fd=@var{h}][,ifname=@var{name}][,script=@var{file}][,downscript=@var{dfile}][,br=@var{bridge}][,helper=@var{helper}]\n@itemx -net tap[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}][,ifname=@var{name}][,script=@var{file}][,downscript=@var{dfile}][,br=@var{bridge}][,helper=@var{helper}]\nConnect the host TAP network interface @var{name} to VLAN @var{n}.\n\nUse the network script @var{file} to configure it and the network script\n@var{dfile} to deconfigure it. If @var{name} is not provided, the OS\nautomatically provides one. The default network configure script is\n@file{/etc/qemu-ifup} and the default network deconfigure script is\n@file{/etc/qemu-ifdown}. Use @option{script=no} or @option{downscript=no}\nto disable script execution.\n\nIf running QEMU as an unprivileged user, use the network helper\n@var{helper} to configure the TAP interface and attach it to the bridge.\nThe default network helper executable is @file{/path/to/qemu-bridge-helper}\nand the default bridge device is @file{br0}.\n\n@option{fd}=@var{h} can be used to specify the handle of an already\nopened host TAP interface.\n\nExamples:\n\n@example\n#launch a QEMU instance with the default network script\nqemu-system-i386 linux.img -net nic -net tap\n@end example\n\n@example\n#launch a QEMU instance with two NICs, each one connected\n#to a TAP device\nqemu-system-i386 linux.img \\\n                 -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 \\\n                 -net nic,vlan=1 -net tap,vlan=1,ifname=tap1\n@end example\n\n@example\n#launch a QEMU instance with the default network helper to\n#connect a TAP device to bridge br0\nqemu-system-i386 linux.img \\\n                 -net nic -net tap,\"helper=/path/to/qemu-bridge-helper\"\n@end example\n\n@item -netdev bridge,id=@var{id}[,br=@var{bridge}][,helper=@var{helper}]\n@itemx -net bridge[,vlan=@var{n}][,name=@var{name}][,br=@var{bridge}][,helper=@var{helper}]\nConnect a host TAP network interface to a host bridge device.\n\nUse the network helper @var{helper} to configure the TAP interface and\nattach it to the bridge. The default network helper executable is\n@file{/path/to/qemu-bridge-helper} and the default bridge\ndevice is @file{br0}.\n\nExamples:\n\n@example\n#launch a QEMU instance with the default network helper to\n#connect a TAP device to bridge br0\nqemu-system-i386 linux.img -net bridge -net nic,model=virtio\n@end example\n\n@example\n#launch a QEMU instance with the default network helper to\n#connect a TAP device to bridge qemubr0\nqemu-system-i386 linux.img -net bridge,br=qemubr0 -net nic,model=virtio\n@end example\n\n@item -netdev socket,id=@var{id}[,fd=@var{h}][,listen=[@var{host}]:@var{port}][,connect=@var{host}:@var{port}]\n@itemx -net socket[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}] [,listen=[@var{host}]:@var{port}][,connect=@var{host}:@var{port}]\n\nConnect the VLAN @var{n} to a remote VLAN in another QEMU virtual\nmachine using a TCP socket connection. If @option{listen} is\nspecified, QEMU waits for incoming connections on @var{port}\n(@var{host} is optional). @option{connect} is used to connect to\nanother QEMU instance using the @option{listen} option. @option{fd}=@var{h}\nspecifies an already opened TCP socket.\n\nExample:\n@example\n# launch a first QEMU instance\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:56 \\\n                 -net socket,listen=:1234\n# connect the VLAN 0 of this instance to the VLAN 0\n# of the first instance\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:57 \\\n                 -net socket,connect=127.0.0.1:1234\n@end example\n\n@item -netdev socket,id=@var{id}[,fd=@var{h}][,mcast=@var{maddr}:@var{port}[,localaddr=@var{addr}]]\n@itemx -net socket[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}][,mcast=@var{maddr}:@var{port}[,localaddr=@var{addr}]]\n\nCreate a VLAN @var{n} shared with another QEMU virtual\nmachines using a UDP multicast socket, effectively making a bus for\nevery QEMU with same multicast address @var{maddr} and @var{port}.\nNOTES:\n@enumerate\n@item\nSeveral QEMU can be running on different hosts and share same bus (assuming\ncorrect multicast setup for these hosts).\n@item\nmcast support is compatible with User Mode Linux (argument @option{eth@var{N}=mcast}), see\n@url{http://user-mode-linux.sf.net}.\n@item\nUse @option{fd=h} to specify an already opened UDP multicast socket.\n@end enumerate\n\nExample:\n@example\n# launch one QEMU instance\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:56 \\\n                 -net socket,mcast=230.0.0.1:1234\n# launch another QEMU instance on same \"bus\"\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:57 \\\n                 -net socket,mcast=230.0.0.1:1234\n# launch yet another QEMU instance on same \"bus\"\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:58 \\\n                 -net socket,mcast=230.0.0.1:1234\n@end example\n\nExample (User Mode Linux compat.):\n@example\n# launch QEMU instance (note mcast address selected\n# is UML's default)\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:56 \\\n                 -net socket,mcast=239.192.168.1:1102\n# launch UML\n/path/to/linux ubd0=/path/to/root_fs eth0=mcast\n@end example\n\nExample (send packets from host's 1.2.3.4):\n@example\nqemu-system-i386 linux.img \\\n                 -net nic,macaddr=52:54:00:12:34:56 \\\n                 -net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4\n@end example\n\n@item -netdev l2tpv3,id=@var{id},src=@var{srcaddr},dst=@var{dstaddr}[,srcport=@var{srcport}][,dstport=@var{dstport}],txsession=@var{txsession}[,rxsession=@var{rxsession}][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=@var{txcookie}][,rxcookie=@var{rxcookie}][,offset=@var{offset}]\n@itemx -net l2tpv3[,vlan=@var{n}][,name=@var{name}],src=@var{srcaddr},dst=@var{dstaddr}[,srcport=@var{srcport}][,dstport=@var{dstport}],txsession=@var{txsession}[,rxsession=@var{rxsession}][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=@var{txcookie}][,rxcookie=@var{rxcookie}][,offset=@var{offset}]\nConnect VLAN @var{n} to L2TPv3 pseudowire. L2TPv3 (RFC3391) is a popular\nprotocol to transport Ethernet (and other Layer 2) data frames between\ntwo systems. It is present in routers, firewalls and the Linux kernel\n(from version 3.3 onwards).\n\nThis transport allows a VM to communicate to another VM, router or firewall directly.\n\n@item src=@var{srcaddr}\n    source address (mandatory)\n@item dst=@var{dstaddr}\n    destination address (mandatory)\n@item udp\n    select udp encapsulation (default is ip).\n@item srcport=@var{srcport}\n    source udp port.\n@item dstport=@var{dstport}\n    destination udp port.\n@item ipv6\n    force v6, otherwise defaults to v4.\n@item rxcookie=@var{rxcookie}\n@itemx txcookie=@var{txcookie}\n    Cookies are a weak form of security in the l2tpv3 specification.\nTheir function is mostly to prevent misconfiguration. By default they are 32\nbit.\n@item cookie64\n    Set cookie size to 64 bit instead of the default 32\n@item counter=off\n    Force a 'cut-down' L2TPv3 with no counter as in\ndraft-mkonstan-l2tpext-keyed-ipv6-tunnel-00\n@item pincounter=on\n    Work around broken counter handling in peer. This may also help on\nnetworks which have packet reorder.\n@item offset=@var{offset}\n    Add an extra offset between header and data\n\nFor example, to attach a VM running on host 4.3.2.1 via L2TPv3 to the bridge br-lan\non the remote Linux host 1.2.3.4:\n@example\n# Setup tunnel on linux host using raw ip as encapsulation\n# on 1.2.3.4\nip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \\\n    encap udp udp_sport 16384 udp_dport 16384\nip l2tp add session tunnel_id 1 name vmtunnel0 session_id \\\n    0xFFFFFFFF peer_session_id 0xFFFFFFFF\nifconfig vmtunnel0 mtu 1500\nifconfig vmtunnel0 up\nbrctl addif br-lan vmtunnel0\n\n\n# on 4.3.2.1\n# launch QEMU instance - if your network has reorder or is very lossy add ,pincounter\n\nqemu-system-i386 linux.img -net nic -net l2tpv3,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter\n\n\n@end example\n\n@item -netdev vde,id=@var{id}[,sock=@var{socketpath}][,port=@var{n}][,group=@var{groupname}][,mode=@var{octalmode}]\n@itemx -net vde[,vlan=@var{n}][,name=@var{name}][,sock=@var{socketpath}] [,port=@var{n}][,group=@var{groupname}][,mode=@var{octalmode}]\nConnect VLAN @var{n} to PORT @var{n} of a vde switch running on host and\nlistening for incoming connections on @var{socketpath}. Use GROUP @var{groupname}\nand MODE @var{octalmode} to change default ownership and permissions for\ncommunication port. This option is only available if QEMU has been compiled\nwith vde support enabled.\n\nExample:\n@example\n# launch vde switch\nvde_switch -F -sock /tmp/myswitch\n# launch QEMU instance\nqemu-system-i386 linux.img -net nic -net vde,sock=/tmp/myswitch\n@end example\n\n@item -netdev hubport,id=@var{id},hubid=@var{hubid}\n\nCreate a hub port on QEMU \"vlan\" @var{hubid}.\n\nThe hubport netdev lets you connect a NIC to a QEMU \"vlan\" instead of a single\nnetdev.  @code{-net} and @code{-device} with parameter @option{vlan} create the\nrequired hub automatically.\n\n@item -netdev vhost-user,chardev=@var{id}[,vhostforce=on|off][,queues=n]\n\nEstablish a vhost-user netdev, backed by a chardev @var{id}. The chardev should\nbe a unix domain socket backed one. The vhost-user uses a specifically defined\nprotocol to pass vhost ioctl replacement messages to an application on the other\nend of the socket. On non-MSIX guests, the feature can be forced with\n@var{vhostforce}. Use 'queues=@var{n}' to specify the number of queues to\nbe created for multiqueue vhost-user.\n\nExample:\n@example\nqemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \\\n     -numa node,memdev=mem \\\n     -chardev socket,id=chr0,path=/path/to/socket \\\n     -netdev type=vhost-user,id=net0,chardev=chr0 \\\n     -device virtio-net-pci,netdev=net0\n@end example\n\n@item -net dump[,vlan=@var{n}][,file=@var{file}][,len=@var{len}]\nDump network traffic on VLAN @var{n} to file @var{file} (@file{qemu-vlan0.pcap} by default).\nAt most @var{len} bytes (64k by default) per packet are stored. The file format is\nlibpcap, so it can be analyzed with tools such as tcpdump or Wireshark.\nNote: For devices created with '-netdev', use '-object filter-dump,...' instead.\n\n@item -net none\nIndicate that no network devices should be configured. It is used to\noverride the default configuration (@option{-net nic -net user}) which\nis activated if no @option{-net} options are provided.\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Character device options)\nSTEXI\n\nThe general form of a character device option is:\n@table @option\nETEXI\n\nDEF(\"chardev\", HAS_ARG, QEMU_OPTION_chardev,\n    \"-chardev help\\n\"\n    \"-chardev null,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4][,ipv6][,nodelay][,reconnect=seconds]\\n\"\n    \"         [,server][,nowait][,telnet][,reconnect=seconds][,mux=on|off]\\n\"\n    \"         [,logfile=PATH][,logappend=on|off][,tls-creds=ID] (tcp)\\n\"\n    \"-chardev socket,id=id,path=path[,server][,nowait][,telnet][,reconnect=seconds]\\n\"\n    \"         [,mux=on|off][,logfile=PATH][,logappend=on|off] (unix)\\n\"\n    \"-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr]\\n\"\n    \"         [,localport=localport][,ipv4][,ipv6][,mux=on|off]\\n\"\n    \"         [,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev msmouse,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]\\n\"\n    \"         [,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev ringbuf,id=id[,size=size][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev file,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev pipe,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#ifdef _WIN32\n    \"-chardev console,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#else\n    \"-chardev pty,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev stdio,id=id[,mux=on|off][,signal=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#ifdef CONFIG_BRLAPI\n    \"-chardev braille,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(__linux__) || defined(__sun__) || defined(__FreeBSD__) \\\n        || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n    \"-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev tty,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)\n    \"-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev parport,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(CONFIG_SPICE)\n    \"-chardev spicevmc,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev spiceport,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n    , QEMU_ARCH_ALL\n)\n\nSTEXI\n@item -chardev @var{backend} ,id=@var{id} [,mux=on|off] [,@var{options}]\n@findex -chardev\nBackend is one of:\n@option{null},\n@option{socket},\n@option{udp},\n@option{msmouse},\n@option{vc},\n@option{ringbuf},\n@option{file},\n@option{pipe},\n@option{console},\n@option{serial},\n@option{pty},\n@option{stdio},\n@option{braille},\n@option{tty},\n@option{parallel},\n@option{parport},\n@option{spicevmc}.\n@option{spiceport}.\nThe specific backend will determine the applicable options.\n\nUse \"-chardev help\" to print all available chardev backend types.\n\nAll devices must have an id, which can be any string up to 127 characters long.\nIt is used to uniquely identify this device in other command line directives.\n\nA character device may be used in multiplexing mode by multiple front-ends.\nSpecify @option{mux=on} to enable this mode.\nA multiplexer is a \"1:N\" device, and here the \"1\" end is your specified chardev\nbackend, and the \"N\" end is the various parts of QEMU that can talk to a chardev.\nIf you create a chardev with @option{id=myid} and @option{mux=on}, QEMU will\ncreate a multiplexer with your specified ID, and you can then configure multiple\nfront ends to use that chardev ID for their input/output. Up to four different\nfront ends can be connected to a single multiplexed chardev. (Without\nmultiplexing enabled, a chardev can only be used by a single front end.)\nFor instance you could use this to allow a single stdio chardev to be used by\ntwo serial ports and the QEMU monitor:\n\n@example\n-chardev stdio,mux=on,id=char0 \\\n-mon chardev=char0,mode=readline \\\n-serial chardev:char0 \\\n-serial chardev:char0\n@end example\n\nYou can have more than one multiplexer in a system configuration; for instance\nyou could have a TCP port multiplexed between UART 0 and UART 1, and stdio\nmultiplexed between the QEMU monitor and a parallel port:\n\n@example\n-chardev stdio,mux=on,id=char0 \\\n-mon chardev=char0,mode=readline \\\n-parallel chardev:char0 \\\n-chardev tcp,...,mux=on,id=char1 \\\n-serial chardev:char1 \\\n-serial chardev:char1\n@end example\n\nWhen you're using a multiplexed character device, some escape sequences are\ninterpreted in the input. @xref{mux_keys, Keys in the character backend\nmultiplexer}.\n\nNote that some other command line options may implicitly create multiplexed\ncharacter backends; for instance @option{-serial mon:stdio} creates a\nmultiplexed stdio backend connected to the serial port and the QEMU monitor,\nand @option{-nographic} also multiplexes the console and the monitor to\nstdio.\n\nThere is currently no support for multiplexing in the other direction\n(where a single QEMU front end takes input and output from multiple chardevs).\n\nEvery backend supports the @option{logfile} option, which supplies the path\nto a file to record all data transmitted via the backend. The @option{logappend}\noption controls whether the log file will be truncated or appended to when\nopened.\n\nFurther options to each backend are described below.\n\n@item -chardev null ,id=@var{id}\nA void device. This device will not emit any data, and will drop any data it\nreceives. The null backend does not take any options.\n\n@item -chardev socket ,id=@var{id} [@var{TCP options} or @var{unix options}] [,server] [,nowait] [,telnet] [,reconnect=@var{seconds}] [,tls-creds=@var{id}]\n\nCreate a two-way stream socket, which can be either a TCP or a unix socket. A\nunix socket will be created if @option{path} is specified. Behaviour is\nundefined if TCP options are specified for a unix socket.\n\n@option{server} specifies that the socket shall be a listening socket.\n\n@option{nowait} specifies that QEMU should not block waiting for a client to\nconnect to a listening socket.\n\n@option{telnet} specifies that traffic on the socket should interpret telnet\nescape sequences.\n\n@option{reconnect} sets the timeout for reconnecting on non-server sockets when\nthe remote end goes away.  qemu will delay this many seconds and then attempt\nto reconnect.  Zero disables reconnecting, and is the default.\n\n@option{tls-creds} requests enablement of the TLS protocol for encryption,\nand specifies the id of the TLS credentials to use for the handshake. The\ncredentials must be previously created with the @option{-object tls-creds}\nargument.\n\nTCP and unix socket options are given below:\n\n@table @option\n\n@item TCP options: port=@var{port} [,host=@var{host}] [,to=@var{to}] [,ipv4] [,ipv6] [,nodelay]\n\n@option{host} for a listening socket specifies the local address to be bound.\nFor a connecting socket species the remote host to connect to. @option{host} is\noptional for listening sockets. If not specified it defaults to @code{0.0.0.0}.\n\n@option{port} for a listening socket specifies the local port to be bound. For a\nconnecting socket specifies the port on the remote host to connect to.\n@option{port} can be given as either a port number or a service name.\n@option{port} is required.\n\n@option{to} is only relevant to listening sockets. If it is specified, and\n@option{port} cannot be bound, QEMU will attempt to bind to subsequent ports up\nto and including @option{to} until it succeeds. @option{to} must be specified\nas a port number.\n\n@option{ipv4} and @option{ipv6} specify that either IPv4 or IPv6 must be used.\nIf neither is specified the socket may use either protocol.\n\n@option{nodelay} disables the Nagle algorithm.\n\n@item unix options: path=@var{path}\n\n@option{path} specifies the local path of the unix socket. @option{path} is\nrequired.\n\n@end table\n\n@item -chardev udp ,id=@var{id} [,host=@var{host}] ,port=@var{port} [,localaddr=@var{localaddr}] [,localport=@var{localport}] [,ipv4] [,ipv6]\n\nSends all traffic from the guest to a remote host over UDP.\n\n@option{host} specifies the remote host to connect to. If not specified it\ndefaults to @code{localhost}.\n\n@option{port} specifies the port on the remote host to connect to. @option{port}\nis required.\n\n@option{localaddr} specifies the local address to bind to. If not specified it\ndefaults to @code{0.0.0.0}.\n\n@option{localport} specifies the local port to bind to. If not specified any\navailable local port will be used.\n\n@option{ipv4} and @option{ipv6} specify that either IPv4 or IPv6 must be used.\nIf neither is specified the device may use either protocol.\n\n@item -chardev msmouse ,id=@var{id}\n\nForward QEMU's emulated msmouse events to the guest. @option{msmouse} does not\ntake any options.\n\n@item -chardev vc ,id=@var{id} [[,width=@var{width}] [,height=@var{height}]] [[,cols=@var{cols}] [,rows=@var{rows}]]\n\nConnect to a QEMU text console. @option{vc} may optionally be given a specific\nsize.\n\n@option{width} and @option{height} specify the width and height respectively of\nthe console, in pixels.\n\n@option{cols} and @option{rows} specify that the console be sized to fit a text\nconsole with the given dimensions.\n\n@item -chardev ringbuf ,id=@var{id} [,size=@var{size}]\n\nCreate a ring buffer with fixed size @option{size}.\n@var{size} must be a power of two and defaults to @code{64K}.\n\n@item -chardev file ,id=@var{id} ,path=@var{path}\n\nLog all traffic received from the guest to a file.\n\n@option{path} specifies the path of the file to be opened. This file will be\ncreated if it does not already exist, and overwritten if it does. @option{path}\nis required.\n\n@item -chardev pipe ,id=@var{id} ,path=@var{path}\n\nCreate a two-way connection to the guest. The behaviour differs slightly between\nWindows hosts and other hosts:\n\nOn Windows, a single duplex pipe will be created at\n@file{\\\\.pipe\\@option{path}}.\n\nOn other hosts, 2 pipes will be created called @file{@option{path}.in} and\n@file{@option{path}.out}. Data written to @file{@option{path}.in} will be\nreceived by the guest. Data written by the guest can be read from\n@file{@option{path}.out}. QEMU will not create these fifos, and requires them to\nbe present.\n\n@option{path} forms part of the pipe path as described above. @option{path} is\nrequired.\n\n@item -chardev console ,id=@var{id}\n\nSend traffic from the guest to QEMU's standard output. @option{console} does not\ntake any options.\n\n@option{console} is only available on Windows hosts.\n\n@item -chardev serial ,id=@var{id} ,path=@option{path}\n\nSend traffic from the guest to a serial device on the host.\n\nOn Unix hosts serial will actually accept any tty device,\nnot only serial lines.\n\n@option{path} specifies the name of the serial device to open.\n\n@item -chardev pty ,id=@var{id}\n\nCreate a new pseudo-terminal on the host and connect to it. @option{pty} does\nnot take any options.\n\n@option{pty} is not available on Windows hosts.\n\n@item -chardev stdio ,id=@var{id} [,signal=on|off]\nConnect to standard input and standard output of the QEMU process.\n\n@option{signal} controls if signals are enabled on the terminal, that includes\nexiting QEMU with the key sequence @key{Control-c}. This option is enabled by\ndefault, use @option{signal=off} to disable it.\n\n@item -chardev braille ,id=@var{id}\n\nConnect to a local BrlAPI server. @option{braille} does not take any options.\n\n@item -chardev tty ,id=@var{id} ,path=@var{path}\n\n@option{tty} is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and\nDragonFlyBSD hosts.  It is an alias for @option{serial}.\n\n@option{path} specifies the path to the tty. @option{path} is required.\n\n@item -chardev parallel ,id=@var{id} ,path=@var{path}\n@itemx -chardev parport ,id=@var{id} ,path=@var{path}\n\n@option{parallel} is only available on Linux, FreeBSD and DragonFlyBSD hosts.\n\nConnect to a local parallel port.\n\n@option{path} specifies the path to the parallel port device. @option{path} is\nrequired.\n\n@item -chardev spicevmc ,id=@var{id} ,debug=@var{debug}, name=@var{name}\n\n@option{spicevmc} is only available when spice support is built in.\n\n@option{debug} debug level for spicevmc\n\n@option{name} name of spice channel to connect to\n\nConnect to a spice virtual machine channel, such as vdiport.\n\n@item -chardev spiceport ,id=@var{id} ,debug=@var{debug}, name=@var{name}\n\n@option{spiceport} is only available when spice support is built in.\n\n@option{debug} debug level for spicevmc\n\n@option{name} name of spice port to connect to\n\nConnect to a spice port, allowing a Spice client to handle the traffic\nidentified by a name (preferably a fqdn).\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Device URL Syntax)\nSTEXI\n\nIn addition to using normal file images for the emulated storage devices,\nQEMU can also use networked resources such as iSCSI devices. These are\nspecified using a special URL syntax.\n\n@table @option\n@item iSCSI\niSCSI support allows QEMU to access iSCSI resources directly and use as\nimages for the guest storage. Both disk and cdrom images are supported.\n\nSyntax for specifying iSCSI LUNs is\n``iscsi://<target-ip>[:<port>]/<target-iqn>/<lun>''\n\nBy default qemu will use the iSCSI initiator-name\n'iqn.2008-11.org.linux-kvm[:<name>]' but this can also be set from the command\nline or a configuration file.\n\nSince version Qemu 2.4 it is possible to specify a iSCSI request timeout to detect\nstalled requests and force a reestablishment of the session. The timeout\nis specified in seconds. The default is 0 which means no timeout. Libiscsi\n1.15.0 or greater is required for this feature.\n\nExample (without authentication):\n@example\nqemu-system-i386 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \\\n                 -cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \\\n                 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1\n@end example\n\nExample (CHAP username/password via URL):\n@example\nqemu-system-i386 -drive file=iscsi://user%password@@192.0.2.1/iqn.2001-04.com.example/1\n@end example\n\nExample (CHAP username/password via environment variables):\n@example\nLIBISCSI_CHAP_USERNAME=\"user\" \\\nLIBISCSI_CHAP_PASSWORD=\"password\" \\\nqemu-system-i386 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1\n@end example\n\niSCSI support is an optional feature of QEMU and only available when\ncompiled and linked against libiscsi.\nETEXI\nDEF(\"iscsi\", HAS_ARG, QEMU_OPTION_iscsi,\n    \"-iscsi [user=user][,password=password]\\n\"\n    \"       [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE\\n\"\n    \"       [,initiator-name=initiator-iqn][,id=target-iqn]\\n\"\n    \"       [,timeout=timeout]\\n\"\n    \"                iSCSI session parameters\\n\", QEMU_ARCH_ALL)\nSTEXI\n\niSCSI parameters such as username and password can also be specified via\na configuration file. See qemu-doc for more information and examples.\n\n@item NBD\nQEMU supports NBD (Network Block Devices) both using TCP protocol as well\nas Unix Domain Sockets.\n\nSyntax for specifying a NBD device using TCP\n``nbd:<server-ip>:<port>[:exportname=<export>]''\n\nSyntax for specifying a NBD device using Unix Domain Sockets\n``nbd:unix:<domain-socket>[:exportname=<export>]''\n\n\nExample for TCP\n@example\nqemu-system-i386 --drive file=nbd:192.0.2.1:30000\n@end example\n\nExample for Unix Domain Sockets\n@example\nqemu-system-i386 --drive file=nbd:unix:/tmp/nbd-socket\n@end example\n\n@item SSH\nQEMU supports SSH (Secure Shell) access to remote disks.\n\nExamples:\n@example\nqemu-system-i386 -drive file=ssh://user@@host/path/to/disk.img\nqemu-system-i386 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img\n@end example\n\nCurrently authentication must be done using ssh-agent.  Other\nauthentication methods may be supported in future.\n\n@item Sheepdog\nSheepdog is a distributed storage system for QEMU.\nQEMU supports using either local sheepdog devices or remote networked\ndevices.\n\nSyntax for specifying a sheepdog device\n@example\nsheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]\n@end example\n\nExample\n@example\nqemu-system-i386 --drive file=sheepdog://192.0.2.1:30000/MyVirtualMachine\n@end example\n\nSee also @url{https://sheepdog.github.io/sheepdog/}.\n\n@item GlusterFS\nGlusterFS is a user space distributed file system.\nQEMU supports the use of GlusterFS volumes for hosting VM disk images using\nTCP, Unix Domain Sockets and RDMA transport protocols.\n\nSyntax for specifying a VM disk image on GlusterFS volume is\n@example\n\nURI:\ngluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]\n\nJSON:\n'json:@{\"driver\":\"qcow2\",\"file\":@{\"driver\":\"gluster\",\"volume\":\"testvol\",\"path\":\"a.img\",\"debug\":N,\"logfile\":\"...\",\n@                                 \"server\":[@{\"type\":\"tcp\",\"host\":\"...\",\"port\":\"...\"@},\n@                                           @{\"type\":\"unix\",\"socket\":\"...\"@}]@}@}'\n@end example\n\n\nExample\n@example\nURI:\nqemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img,\n@                               file.debug=9,file.logfile=/var/log/qemu-gluster.log\n\nJSON:\nqemu-system-x86_64 'json:@{\"driver\":\"qcow2\",\n@                          \"file\":@{\"driver\":\"gluster\",\n@                                   \"volume\":\"testvol\",\"path\":\"a.img\",\n@                                   \"debug\":9,\"logfile\":\"/var/log/qemu-gluster.log\",\n@                                   \"server\":[@{\"type\":\"tcp\",\"host\":\"1.2.3.4\",\"port\":24007@},\n@                                             @{\"type\":\"unix\",\"socket\":\"/var/run/glusterd.socket\"@}]@}@}'\nqemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,\n@                                      file.debug=9,file.logfile=/var/log/qemu-gluster.log,\n@                                      file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,\n@                                      file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket\n@end example\n\nSee also @url{http://www.gluster.org}.\n\n@item HTTP/HTTPS/FTP/FTPS\nQEMU supports read-only access to files accessed over http(s) and ftp(s).\n\nSyntax using a single filename:\n@example\n<protocol>://[<username>[:<password>]@@]<host>/<path>\n@end example\n\nwhere:\n@table @option\n@item protocol\n'http', 'https', 'ftp', or 'ftps'.\n\n@item username\nOptional username for authentication to the remote server.\n\n@item password\nOptional password for authentication to the remote server.\n\n@item host\nAddress of the remote server.\n\n@item path\nPath on the remote server, including any query string.\n@end table\n\nThe following options are also supported:\n@table @option\n@item url\nThe full URL when passing options to the driver explicitly.\n\n@item readahead\nThe amount of data to read ahead with each range request to the remote server.\nThis value may optionally have the suffix 'T', 'G', 'M', 'K', 'k' or 'b'. If it\ndoes not have a suffix, it will be assumed to be in bytes. The value must be a\nmultiple of 512 bytes. It defaults to 256k.\n\n@item sslverify\nWhether to verify the remote server's certificate when connecting over SSL. It\ncan have the value 'on' or 'off'. It defaults to 'on'.\n\n@item cookie\nSend this cookie (it can also be a list of cookies separated by ';') with\neach outgoing request.  Only supported when using protocols such as HTTP\nwhich support cookies, otherwise ignored.\n\n@item timeout\nSet the timeout in seconds of the CURL connection. This timeout is the time\nthat CURL waits for a response from the remote server to get the size of the\nimage to be downloaded. If not set, the default timeout of 5 seconds is used.\n@end table\n\nNote that when passing options to qemu explicitly, @option{driver} is the value\nof <protocol>.\n\nExample: boot from a remote Fedora 20 live ISO image\n@example\nqemu-system-x86_64 --drive media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly\n\nqemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly\n@end example\n\nExample: boot from a remote Fedora 20 cloud image using a local overlay for\nwrites, copy-on-read, and a readahead of 64k\n@example\nqemu-img create -f qcow2 -o backing_file='json:@{\"file.driver\":\"http\",, \"file.url\":\"https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2\",, \"file.readahead\":\"64k\"@}' /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2\n\nqemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on\n@end example\n\nExample: boot from an image stored on a VMware vSphere server with a self-signed\ncertificate using a local overlay for writes, a readahead of 64k and a timeout\nof 10 seconds.\n@example\nqemu-img create -f qcow2 -o backing_file='json:@{\"file.driver\":\"https\",, \"file.url\":\"https://user:password@@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&dsName=datastore1\",, \"file.sslverify\":\"off\",, \"file.readahead\":\"64k\",, \"file.timeout\":10@}' /tmp/test.qcow2\n\nqemu-system-x86_64 -drive file=/tmp/test.qcow2\n@end example\nETEXI\n\nSTEXI\n@end table\nETEXI\n\nDEFHEADING(Bluetooth(R) options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"bt\", HAS_ARG, QEMU_OPTION_bt, \\\n    \"-bt hci,null    dumb bluetooth HCI - doesn't respond to commands\\n\" \\\n    \"-bt hci,host[:id]\\n\" \\\n    \"                use host's HCI with the given name\\n\" \\\n    \"-bt hci[,vlan=n]\\n\" \\\n    \"                emulate a standard HCI in virtual scatternet 'n'\\n\" \\\n    \"-bt vhci[,vlan=n]\\n\" \\\n    \"                add host computer to virtual scatternet 'n' using VHCI\\n\" \\\n    \"-bt device:dev[,vlan=n]\\n\" \\\n    \"                emulate a bluetooth device 'dev' in scatternet 'n'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -bt hci[...]\n@findex -bt\nDefines the function of the corresponding Bluetooth HCI.  -bt options\nare matched with the HCIs present in the chosen machine type.  For\nexample when emulating a machine with only one HCI built into it, only\nthe first @code{-bt hci[...]} option is valid and defines the HCI's\nlogic.  The Transport Layer is decided by the machine type.  Currently\nthe machines @code{n800} and @code{n810} have one HCI and all other\nmachines have none.\n\n@anchor{bt-hcis}\nThe following three types are recognized:\n\n@table @option\n@item -bt hci,null\n(default) The corresponding Bluetooth HCI assumes no internal logic\nand will not respond to any HCI commands or emit events.\n\n@item -bt hci,host[:@var{id}]\n(@code{bluez} only) The corresponding HCI passes commands / events\nto / from the physical HCI identified by the name @var{id} (default:\n@code{hci0}) on the computer running QEMU.  Only available on @code{bluez}\ncapable systems like Linux.\n\n@item -bt hci[,vlan=@var{n}]\nAdd a virtual, standard HCI that will participate in the Bluetooth\nscatternet @var{n} (default @code{0}).  Similarly to @option{-net}\nVLANs, devices inside a bluetooth network @var{n} can only communicate\nwith other devices in the same network (scatternet).\n@end table\n\n@item -bt vhci[,vlan=@var{n}]\n(Linux-host only) Create a HCI in scatternet @var{n} (default 0) attached\nto the host bluetooth stack instead of to the emulated target.  This\nallows the host and target machines to participate in a common scatternet\nand communicate.  Requires the Linux @code{vhci} driver installed.  Can\nbe used as following:\n\n@example\nqemu-system-i386 [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5\n@end example\n\n@item -bt device:@var{dev}[,vlan=@var{n}]\nEmulate a bluetooth device @var{dev} and place it in network @var{n}\n(default @code{0}).  QEMU can only emulate one type of bluetooth devices\ncurrently:\n\n@table @option\n@item keyboard\nVirtual wireless keyboard implementing the HIDP bluetooth profile.\n@end table\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\n#ifdef CONFIG_TPM\nDEFHEADING(TPM device options)\n\nDEF(\"tpmdev\", HAS_ARG, QEMU_OPTION_tpmdev, \\\n    \"-tpmdev passthrough,id=id[,path=path][,cancel-path=path]\\n\"\n    \"                use path to provide path to a character device; default is /dev/tpm0\\n\"\n    \"                use cancel-path to provide path to TPM's cancel sysfs entry; if\\n\"\n    \"                not provided it will be searched for in /sys/class/misc/tpm?/device\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n\nThe general form of a TPM device option is:\n@table @option\n\n@item -tpmdev @var{backend} ,id=@var{id} [,@var{options}]\n@findex -tpmdev\nBackend type must be:\n@option{passthrough}.\n\nThe specific backend type will determine the applicable options.\nThe @code{-tpmdev} option creates the TPM backend and requires a\n@code{-device} option that specifies the TPM frontend interface model.\n\nOptions to each backend are described below.\n\nUse 'help' to print all available TPM backend types.\n@example\nqemu -tpmdev help\n@end example\n\n@item -tpmdev passthrough, id=@var{id}, path=@var{path}, cancel-path=@var{cancel-path}\n\n(Linux-host only) Enable access to the host's TPM using the passthrough\ndriver.\n\n@option{path} specifies the path to the host's TPM device, i.e., on\na Linux host this would be @code{/dev/tpm0}.\n@option{path} is optional and by default @code{/dev/tpm0} is used.\n\n@option{cancel-path} specifies the path to the host TPM device's sysfs\nentry allowing for cancellation of an ongoing TPM command.\n@option{cancel-path} is optional and by default QEMU will search for the\nsysfs entry to use.\n\nSome notes about using the host's TPM with the passthrough driver:\n\nThe TPM device accessed by the passthrough driver must not be\nused by any other application on the host.\n\nSince the host's firmware (BIOS/UEFI) has already initialized the TPM,\nthe VM's firmware (BIOS/UEFI) will not be able to initialize the\nTPM again and may therefore not show a TPM-specific menu that would\notherwise allow the user to configure the TPM, e.g., allow the user to\nenable/disable or activate/deactivate the TPM.\nFurther, if TPM ownership is released from within a VM then the host's TPM\nwill get disabled and deactivated. To enable and activate the\nTPM again afterwards, the host has to be rebooted and the user is\nrequired to enter the firmware's menu to enable and activate the TPM.\nIf the TPM is left disabled and/or deactivated most TPM commands will fail.\n\nTo create a passthrough TPM use the following two options:\n@example\n-tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0\n@end example\nNote that the @code{-tpmdev} id is @code{tpm0} and is referenced by\n@code{tpmdev=tpm0} in the device option.\n\n@end table\n\nETEXI\n\nDEFHEADING()\n\n#endif\n\nDEFHEADING(Linux/Multiboot boot specific)\nSTEXI\n\nWhen using these options, you can use a given Linux or Multiboot\nkernel without installing it in the disk image. It can be useful\nfor easier testing of various kernels.\n\n@table @option\nETEXI\n\nDEF(\"kernel\", HAS_ARG, QEMU_OPTION_kernel, \\\n    \"-kernel bzImage use 'bzImage' as kernel image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -kernel @var{bzImage}\n@findex -kernel\nUse @var{bzImage} as kernel image. The kernel can be either a Linux kernel\nor in multiboot format.\nETEXI\n\nDEF(\"append\", HAS_ARG, QEMU_OPTION_append, \\\n    \"-append cmdline use 'cmdline' as kernel command line\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -append @var{cmdline}\n@findex -append\nUse @var{cmdline} as kernel command line\nETEXI\n\nDEF(\"initrd\", HAS_ARG, QEMU_OPTION_initrd, \\\n           \"-initrd file    use 'file' as initial ram disk\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -initrd @var{file}\n@findex -initrd\nUse @var{file} as initial ram disk.\n\n@item -initrd \"@var{file1} arg=foo,@var{file2}\"\n\nThis syntax is only available with multiboot.\n\nUse @var{file1} and @var{file2} as modules and pass arg=foo as parameter to the\nfirst module.\nETEXI\n\nDEF(\"dtb\", HAS_ARG, QEMU_OPTION_dtb, \\\n    \"-dtb    file    use 'file' as device tree image\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -dtb @var{file}\n@findex -dtb\nUse @var{file} as a device tree binary (dtb) image and pass it to the kernel\non boot.\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\n\nDEFHEADING(Debug/Expert options)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"fw_cfg\", HAS_ARG, QEMU_OPTION_fwcfg,\n    \"-fw_cfg [name=]<name>,file=<file>\\n\"\n    \"                add named fw_cfg entry with contents from file\\n\"\n    \"-fw_cfg [name=]<name>,string=<str>\\n\"\n    \"                add named fw_cfg entry with contents from string\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n\n@item -fw_cfg [name=]@var{name},file=@var{file}\n@findex -fw_cfg\nAdd named fw_cfg entry with contents from file @var{file}.\n\n@item -fw_cfg [name=]@var{name},string=@var{str}\nAdd named fw_cfg entry with contents from string @var{str}.\n\nThe terminating NUL character of the contents of @var{str} will not be\nincluded as part of the fw_cfg item data. To insert contents with\nembedded NUL characters, you have to use the @var{file} parameter.\n\nThe fw_cfg entries are passed by QEMU through to the guest.\n\nExample:\n@example\n    -fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin\n@end example\ncreates an fw_cfg entry named opt/com.mycompany/blob with contents\nfrom ./my_blob.bin.\n\nETEXI\n\nDEF(\"serial\", HAS_ARG, QEMU_OPTION_serial, \\\n    \"-serial dev     redirect the serial port to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -serial @var{dev}\n@findex -serial\nRedirect the virtual serial port to host character device\n@var{dev}. The default device is @code{vc} in graphical mode and\n@code{stdio} in non graphical mode.\n\nThis option can be used several times to simulate up to 4 serial\nports.\n\nUse @code{-serial none} to disable all serial ports.\n\nAvailable character devices are:\n@table @option\n@item vc[:@var{W}x@var{H}]\nVirtual console. Optionally, a width and height can be given in pixel with\n@example\nvc:800x600\n@end example\nIt is also possible to specify width or height in characters:\n@example\nvc:80Cx24C\n@end example\n@item pty\n[Linux only] Pseudo TTY (a new PTY is automatically allocated)\n@item none\nNo device is allocated.\n@item null\nvoid device\n@item chardev:@var{id}\nUse a named character device defined with the @code{-chardev} option.\n@item /dev/XXX\n[Linux only] Use host tty, e.g. @file{/dev/ttyS0}. The host serial port\nparameters are set according to the emulated ones.\n@item /dev/parport@var{N}\n[Linux only, parallel port only] Use host parallel port\n@var{N}. Currently SPP and EPP parallel port features can be used.\n@item file:@var{filename}\nWrite output to @var{filename}. No character can be read.\n@item stdio\n[Unix only] standard input/output\n@item pipe:@var{filename}\nname pipe @var{filename}\n@item COM@var{n}\n[Windows only] Use host serial port @var{n}\n@item udp:[@var{remote_host}]:@var{remote_port}[@@[@var{src_ip}]:@var{src_port}]\nThis implements UDP Net Console.\nWhen @var{remote_host} or @var{src_ip} are not specified\nthey default to @code{0.0.0.0}.\nWhen not using a specified @var{src_port} a random port is automatically chosen.\n\nIf you just want a simple readonly console you can use @code{netcat} or\n@code{nc}, by starting QEMU with: @code{-serial udp::4555} and nc as:\n@code{nc -u -l -p 4555}. Any time QEMU writes something to that port it\nwill appear in the netconsole session.\n\nIf you plan to send characters back via netconsole or you want to stop\nand start QEMU a lot of times, you should have QEMU use the same\nsource port each time by using something like @code{-serial\nudp::4555@@:4556} to QEMU. Another approach is to use a patched\nversion of netcat which can listen to a TCP port and send and receive\ncharacters via udp.  If you have a patched version of netcat which\nactivates telnet remote echo and single char transfer, then you can\nuse the following options to set up a netcat redirector to allow\ntelnet on port 5555 to access the QEMU port.\n@table @code\n@item QEMU Options:\n-serial udp::4555@@:4556\n@item netcat options:\n-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T\n@item telnet options:\nlocalhost 5555\n@end table\n\n@item tcp:[@var{host}]:@var{port}[,@var{server}][,nowait][,nodelay][,reconnect=@var{seconds}]\nThe TCP Net Console has two modes of operation.  It can send the serial\nI/O to a location or wait for a connection from a location.  By default\nthe TCP Net Console is sent to @var{host} at the @var{port}.  If you use\nthe @var{server} option QEMU will wait for a client socket application\nto connect to the port before continuing, unless the @code{nowait}\noption was specified.  The @code{nodelay} option disables the Nagle buffering\nalgorithm.  The @code{reconnect} option only applies if @var{noserver} is\nset, if the connection goes down it will attempt to reconnect at the\ngiven interval.  If @var{host} is omitted, 0.0.0.0 is assumed. Only\none TCP connection at a time is accepted. You can use @code{telnet} to\nconnect to the corresponding character device.\n@table @code\n@item Example to send tcp console to 192.168.0.2 port 4444\n-serial tcp:192.168.0.2:4444\n@item Example to listen and wait on port 4444 for connection\n-serial tcp::4444,server\n@item Example to not wait and listen on ip 192.168.0.100 port 4444\n-serial tcp:192.168.0.100:4444,server,nowait\n@end table\n\n@item telnet:@var{host}:@var{port}[,server][,nowait][,nodelay]\nThe telnet protocol is used instead of raw tcp sockets.  The options\nwork the same as if you had specified @code{-serial tcp}.  The\ndifference is that the port acts like a telnet server or client using\ntelnet option negotiation.  This will also allow you to send the\nMAGIC_SYSRQ sequence if you use a telnet that supports sending the break\nsequence.  Typically in unix telnet you do it with Control-] and then\ntype \"send break\" followed by pressing the enter key.\n\n@item unix:@var{path}[,server][,nowait][,reconnect=@var{seconds}]\nA unix domain socket is used instead of a tcp socket.  The option works the\nsame as if you had specified @code{-serial tcp} except the unix domain socket\n@var{path} is used for connections.\n\n@item mon:@var{dev_string}\nThis is a special option to allow the monitor to be multiplexed onto\nanother serial port.  The monitor is accessed with key sequence of\n@key{Control-a} and then pressing @key{c}.\n@var{dev_string} should be any one of the serial devices specified\nabove.  An example to multiplex the monitor onto a telnet server\nlistening on port 4444 would be:\n@table @code\n@item -serial mon:telnet::4444,server,nowait\n@end table\nWhen the monitor is multiplexed to stdio in this way, Ctrl+C will not terminate\nQEMU any more but will be passed to the guest instead.\n\n@item braille\nBraille device.  This will use BrlAPI to display the braille output on a real\nor fake device.\n\n@item msmouse\nThree button serial mouse. Configure the guest to use Microsoft protocol.\n@end table\nETEXI\n\nDEF(\"parallel\", HAS_ARG, QEMU_OPTION_parallel, \\\n    \"-parallel dev   redirect the parallel port to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -parallel @var{dev}\n@findex -parallel\nRedirect the virtual parallel port to host device @var{dev} (same\ndevices as the serial port). On Linux hosts, @file{/dev/parportN} can\nbe used to use hardware devices connected on the corresponding host\nparallel port.\n\nThis option can be used several times to simulate up to 3 parallel\nports.\n\nUse @code{-parallel none} to disable all parallel ports.\nETEXI\n\nDEF(\"monitor\", HAS_ARG, QEMU_OPTION_monitor, \\\n    \"-monitor dev    redirect the monitor to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -monitor @var{dev}\n@findex -monitor\nRedirect the monitor to host device @var{dev} (same devices as the\nserial port).\nThe default device is @code{vc} in graphical mode and @code{stdio} in\nnon graphical mode.\nUse @code{-monitor none} to disable the default monitor.\nETEXI\nDEF(\"qmp\", HAS_ARG, QEMU_OPTION_qmp, \\\n    \"-qmp dev        like -monitor but opens in 'control' mode\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -qmp @var{dev}\n@findex -qmp\nLike -monitor but opens in 'control' mode.\nETEXI\nDEF(\"qmp-pretty\", HAS_ARG, QEMU_OPTION_qmp_pretty, \\\n    \"-qmp-pretty dev like -qmp but uses pretty JSON formatting\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -qmp-pretty @var{dev}\n@findex -qmp-pretty\nLike -qmp but uses pretty JSON formatting.\nETEXI\n\nDEF(\"mon\", HAS_ARG, QEMU_OPTION_mon, \\\n    \"-mon [chardev=]name[,mode=readline|control]\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -mon [chardev=]name[,mode=readline|control]\n@findex -mon\nSetup monitor on chardev @var{name}.\nETEXI\n\nDEF(\"debugcon\", HAS_ARG, QEMU_OPTION_debugcon, \\\n    \"-debugcon dev   redirect the debug console to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -debugcon @var{dev}\n@findex -debugcon\nRedirect the debug console to host device @var{dev} (same devices as the\nserial port).  The debug console is an I/O port which is typically port\n0xe9; writing to that I/O port sends output to this device.\nThe default device is @code{vc} in graphical mode and @code{stdio} in\nnon graphical mode.\nETEXI\n\nDEF(\"pidfile\", HAS_ARG, QEMU_OPTION_pidfile, \\\n    \"-pidfile file   write PID to 'file'\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -pidfile @var{file}\n@findex -pidfile\nStore the QEMU process PID in @var{file}. It is useful if you launch QEMU\nfrom a script.\nETEXI\n\nDEF(\"singlestep\", 0, QEMU_OPTION_singlestep, \\\n    \"-singlestep     always run in singlestep mode\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -singlestep\n@findex -singlestep\nRun the emulation in single step mode.\nETEXI\n\nDEF(\"S\", 0, QEMU_OPTION_S, \\\n    \"-S              freeze CPU at startup (use 'c' to start execution)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -S\n@findex -S\nDo not start CPU at startup (you must type 'c' in the monitor).\nETEXI\n\nDEF(\"realtime\", HAS_ARG, QEMU_OPTION_realtime,\n    \"-realtime [mlock=on|off]\\n\"\n    \"                run qemu with realtime features\\n\"\n    \"                mlock=on|off controls mlock support (default: on)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -realtime mlock=on|off\n@findex -realtime\nRun qemu with realtime features.\nmlocking qemu and guest memory can be enabled via @option{mlock=on}\n(enabled by default).\nETEXI\n\nDEF(\"gdb\", HAS_ARG, QEMU_OPTION_gdb, \\\n    \"-gdb dev        wait for gdb connection on 'dev'\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -gdb @var{dev}\n@findex -gdb\nWait for gdb connection on device @var{dev} (@pxref{gdb_usage}). Typical\nconnections will likely be TCP-based, but also UDP, pseudo TTY, or even\nstdio are reasonable use case. The latter is allowing to start QEMU from\nwithin gdb and establish the connection via a pipe:\n@example\n(gdb) target remote | exec qemu-system-i386 -gdb stdio ...\n@end example\nETEXI\n\nDEF(\"s\", 0, QEMU_OPTION_s, \\\n    \"-s              shorthand for -gdb tcp::\" DEFAULT_GDBSTUB_PORT \"\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -s\n@findex -s\nShorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234\n(@pxref{gdb_usage}).\nETEXI\n\nDEF(\"d\", HAS_ARG, QEMU_OPTION_d, \\\n    \"-d item1,...    enable logging of specified items (use '-d help' for a list of log items)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -d @var{item1}[,...]\n@findex -d\nEnable logging of specified items. Use '-d help' for a list of log items.\nETEXI\n\nDEF(\"D\", HAS_ARG, QEMU_OPTION_D, \\\n    \"-D logfile      output log to logfile (default stderr)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -D @var{logfile}\n@findex -D\nOutput log in @var{logfile} instead of to stderr\nETEXI\n\nDEF(\"dfilter\", HAS_ARG, QEMU_OPTION_DFILTER, \\\n    \"-dfilter range,..  filter debug output to range of addresses (useful for -d cpu,exec,etc..)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -dfilter @var{range1}[,...]\n@findex -dfilter\nFilter debug output to that relevant to a range of target addresses. The filter\nspec can be either @var{start}+@var{size}, @var{start}-@var{size} or\n@var{start}..@var{end} where @var{start} @var{end} and @var{size} are the\naddresses and sizes required. For example:\n@example\n    -dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000\n@end example\nWill dump output for any code in the 0x1000 sized block starting at 0x8000 and\nthe 0x200 sized block starting at 0xffffffc000080000 and another 0x1000 sized\nblock starting at 0xffffffc00005f000.\nETEXI\n\nDEF(\"L\", HAS_ARG, QEMU_OPTION_L, \\\n    \"-L path         set the directory for the BIOS, VGA BIOS and keymaps\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -L  @var{path}\n@findex -L\nSet the directory for the BIOS, VGA BIOS and keymaps.\n\nTo list all the data directories, use @code{-L help}.\nETEXI\n\nDEF(\"bios\", HAS_ARG, QEMU_OPTION_bios, \\\n    \"-bios file      set the filename for the BIOS\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -bios @var{file}\n@findex -bios\nSet the filename for the BIOS.\nETEXI\n\nDEF(\"enable-kvm\", 0, QEMU_OPTION_enable_kvm, \\\n    \"-enable-kvm     enable KVM full virtualization support\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -enable-kvm\n@findex -enable-kvm\nEnable KVM full virtualization support. This option is only available\nif KVM support is enabled when compiling.\nETEXI\n\nDEF(\"enable-hax\", 0, QEMU_OPTION_enable_hax, \\\n    \"-enable-hax     enable HAX virtualization support\\n\", QEMU_ARCH_I386)\nSTEXI\n@item -enable-hax\n@findex -enable-hax\nEnable HAX (Hardware-based Acceleration eXecution) support. This option\nis only available if HAX support is enabled when compiling. HAX is only\napplicable to MAC and Windows platform, and thus does not conflict with\nKVM.\nETEXI\n\nDEF(\"xen-domid\", HAS_ARG, QEMU_OPTION_xen_domid,\n    \"-xen-domid id   specify xen guest domain id\\n\", QEMU_ARCH_ALL)\nDEF(\"xen-create\", 0, QEMU_OPTION_xen_create,\n    \"-xen-create     create domain using xen hypercalls, bypassing xend\\n\"\n    \"                warning: should not be used when xend is in use\\n\",\n    QEMU_ARCH_ALL)\nDEF(\"xen-attach\", 0, QEMU_OPTION_xen_attach,\n    \"-xen-attach     attach to existing xen domain\\n\"\n    \"                xend will use this when starting QEMU\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -xen-domid @var{id}\n@findex -xen-domid\nSpecify xen guest domain @var{id} (XEN only).\n@item -xen-create\n@findex -xen-create\nCreate domain using xen hypercalls, bypassing xend.\nWarning: should not be used when xend is in use (XEN only).\n@item -xen-attach\n@findex -xen-attach\nAttach to existing xen domain.\nxend will use this when starting QEMU (XEN only).\nETEXI\n\nDEF(\"no-reboot\", 0, QEMU_OPTION_no_reboot, \\\n    \"-no-reboot      exit instead of rebooting\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -no-reboot\n@findex -no-reboot\nExit instead of rebooting.\nETEXI\n\nDEF(\"no-shutdown\", 0, QEMU_OPTION_no_shutdown, \\\n    \"-no-shutdown    stop before shutdown\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -no-shutdown\n@findex -no-shutdown\nDon't exit QEMU on guest shutdown, but instead only stop the emulation.\nThis allows for instance switching to monitor to commit changes to the\ndisk image.\nETEXI\n\nDEF(\"loadvm\", HAS_ARG, QEMU_OPTION_loadvm, \\\n    \"-loadvm [tag|id]\\n\" \\\n    \"                start right away with a saved state (loadvm in monitor)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -loadvm @var{file}\n@findex -loadvm\nStart right away with a saved state (@code{loadvm} in monitor)\nETEXI\n\n#ifndef _WIN32\nDEF(\"daemonize\", 0, QEMU_OPTION_daemonize, \\\n    \"-daemonize      daemonize QEMU after initializing\\n\", QEMU_ARCH_ALL)\n#endif\nSTEXI\n@item -daemonize\n@findex -daemonize\nDaemonize the QEMU process after initialization.  QEMU will not detach from\nstandard IO until it is ready to receive connections on any of its devices.\nThis option is a useful way for external programs to launch QEMU without having\nto cope with initialization race conditions.\nETEXI\n\nDEF(\"option-rom\", HAS_ARG, QEMU_OPTION_option_rom, \\\n    \"-option-rom rom load a file, rom, into the option ROM space\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -option-rom @var{file}\n@findex -option-rom\nLoad the contents of @var{file} as an option ROM.\nThis option is useful to load things like EtherBoot.\nETEXI\n\nHXCOMM Silently ignored for compatibility\nDEF(\"clock\", HAS_ARG, QEMU_OPTION_clock, \"\", QEMU_ARCH_ALL)\n\nHXCOMM Options deprecated by -rtc\nDEF(\"localtime\", 0, QEMU_OPTION_localtime, \"\", QEMU_ARCH_ALL)\nDEF(\"startdate\", HAS_ARG, QEMU_OPTION_startdate, \"\", QEMU_ARCH_ALL)\n\nDEF(\"rtc\", HAS_ARG, QEMU_OPTION_rtc, \\\n    \"-rtc [base=utc|localtime|date][,clock=host|rt|vm][,driftfix=none|slew]\\n\" \\\n    \"                set the RTC base and clock, enable drift fix for clock ticks (x86 only)\\n\",\n    QEMU_ARCH_ALL)\n\nSTEXI\n\n@item -rtc [base=utc|localtime|@var{date}][,clock=host|vm][,driftfix=none|slew]\n@findex -rtc\nSpecify @option{base} as @code{utc} or @code{localtime} to let the RTC start at the current\nUTC or local time, respectively. @code{localtime} is required for correct date in\nMS-DOS or Windows. To start at a specific point in time, provide @var{date} in the\nformat @code{2006-06-17T16:01:21} or @code{2006-06-17}. The default base is UTC.\n\nBy default the RTC is driven by the host system time. This allows using of the\nRTC as accurate reference clock inside the guest, specifically if the host\ntime is smoothly following an accurate external reference clock, e.g. via NTP.\nIf you want to isolate the guest time from the host, you can set @option{clock}\nto @code{rt} instead.  To even prevent it from progressing during suspension,\nyou can set it to @code{vm}.\n\nEnable @option{driftfix} (i386 targets only) if you experience time drift problems,\nspecifically with Windows' ACPI HAL. This option will try to figure out how\nmany timer interrupts were not processed by the Windows guest and will\nre-inject them.\nETEXI\n\nDEF(\"icount\", HAS_ARG, QEMU_OPTION_icount, \\\n    \"-icount [shift=N|auto][,align=on|off][,sleep=on|off,rr=record|replay,rrfile=<filename>,rrsnapshot=<snapshot>]\\n\" \\\n    \"                enable virtual instruction counter with 2^N clock ticks per\\n\" \\\n    \"                instruction, enable aligning the host and virtual clocks\\n\" \\\n    \"                or disable real time cpu sleeping\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -icount [shift=@var{N}|auto][,rr=record|replay,rrfile=@var{filename},rrsnapshot=@var{snapshot}]\n@findex -icount\nEnable virtual instruction counter.  The virtual cpu will execute one\ninstruction every 2^@var{N} ns of virtual time.  If @code{auto} is specified\nthen the virtual cpu speed will be automatically adjusted to keep virtual\ntime within a few seconds of real time.\n\nWhen the virtual cpu is sleeping, the virtual time will advance at default\nspeed unless @option{sleep=on|off} is specified.\nWith @option{sleep=on|off}, the virtual time will jump to the next timer deadline\ninstantly whenever the virtual cpu goes to sleep mode and will not advance\nif no timer is enabled. This behavior give deterministic execution times from\nthe guest point of view.\n\nNote that while this option can give deterministic behavior, it does not\nprovide cycle accurate emulation.  Modern CPUs contain superscalar out of\norder cores with complex cache hierarchies.  The number of instructions\nexecuted often has little or no correlation with actual performance.\n\n@option{align=on} will activate the delay algorithm which will try\nto synchronise the host clock and the virtual clock. The goal is to\nhave a guest running at the real frequency imposed by the shift option.\nWhenever the guest clock is behind the host clock and if\n@option{align=on} is specified then we print a message to the user\nto inform about the delay.\nCurrently this option does not work when @option{shift} is @code{auto}.\nNote: The sync algorithm will work for those shift values for which\nthe guest clock runs ahead of the host clock. Typically this happens\nwhen the shift value is high (how high depends on the host machine).\n\nWhen @option{rr} option is specified deterministic record/replay is enabled.\nReplay log is written into @var{filename} file in record mode and\nread from this file in replay mode.\n\nOption rrsnapshot is used to create new vm snapshot named @var{snapshot}\nat the start of execution recording. In replay mode this option is used\nto load the initial VM state.\nETEXI\n\nDEF(\"watchdog\", HAS_ARG, QEMU_OPTION_watchdog, \\\n    \"-watchdog model\\n\" \\\n    \"                enable virtual hardware watchdog [default=none]\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -watchdog @var{model}\n@findex -watchdog\nCreate a virtual hardware watchdog device.  Once enabled (by a guest\naction), the watchdog must be periodically polled by an agent inside\nthe guest or else the guest will be restarted. Choose a model for\nwhich your guest has drivers.\n\nThe @var{model} is the model of hardware watchdog to emulate. Use\n@code{-watchdog help} to list available hardware models. Only one\nwatchdog can be enabled for a guest.\n\nThe following models may be available:\n@table @option\n@item ib700\niBASE 700 is a very simple ISA watchdog with a single timer.\n@item i6300esb\nIntel 6300ESB I/O controller hub is a much more featureful PCI-based\ndual-timer watchdog.\n@item diag288\nA virtual watchdog for s390x backed by the diagnose 288 hypercall\n(currently KVM only).\n@end table\nETEXI\n\nDEF(\"watchdog-action\", HAS_ARG, QEMU_OPTION_watchdog_action, \\\n    \"-watchdog-action reset|shutdown|poweroff|pause|debug|none\\n\" \\\n    \"                action when watchdog fires [default=reset]\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -watchdog-action @var{action}\n@findex -watchdog-action\n\nThe @var{action} controls what QEMU will do when the watchdog timer\nexpires.\nThe default is\n@code{reset} (forcefully reset the guest).\nOther possible actions are:\n@code{shutdown} (attempt to gracefully shutdown the guest),\n@code{poweroff} (forcefully poweroff the guest),\n@code{pause} (pause the guest),\n@code{debug} (print a debug message and continue), or\n@code{none} (do nothing).\n\nNote that the @code{shutdown} action requires that the guest responds\nto ACPI signals, which it may not be able to do in the sort of\nsituations where the watchdog would have expired, and thus\n@code{-watchdog-action shutdown} is not recommended for production use.\n\nExamples:\n\n@table @code\n@item -watchdog i6300esb -watchdog-action pause\n@itemx -watchdog ib700\n@end table\nETEXI\n\nDEF(\"echr\", HAS_ARG, QEMU_OPTION_echr, \\\n    \"-echr chr       set terminal escape character instead of ctrl-a\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n\n@item -echr @var{numeric_ascii_value}\n@findex -echr\nChange the escape character used for switching to the monitor when using\nmonitor and serial sharing.  The default is @code{0x01} when using the\n@code{-nographic} option.  @code{0x01} is equal to pressing\n@code{Control-a}.  You can select a different character from the ascii\ncontrol keys where 1 through 26 map to Control-a through Control-z.  For\ninstance you could use the either of the following to change the escape\ncharacter to Control-t.\n@table @code\n@item -echr 0x14\n@itemx -echr 20\n@end table\nETEXI\n\nDEF(\"virtioconsole\", HAS_ARG, QEMU_OPTION_virtiocon, \\\n    \"-virtioconsole c\\n\" \\\n    \"                set virtio console\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -virtioconsole @var{c}\n@findex -virtioconsole\nSet virtio console.\n\nThis option is maintained for backward compatibility.\n\nPlease use @code{-device virtconsole} for the new way of invocation.\nETEXI\n\nDEF(\"show-cursor\", 0, QEMU_OPTION_show_cursor, \\\n    \"-show-cursor    show cursor\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -show-cursor\n@findex -show-cursor\nShow cursor.\nETEXI\n\nDEF(\"tb-size\", HAS_ARG, QEMU_OPTION_tb_size, \\\n    \"-tb-size n      set TB size\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -tb-size @var{n}\n@findex -tb-size\nSet TB size.\nETEXI\n\nDEF(\"incoming\", HAS_ARG, QEMU_OPTION_incoming, \\\n    \"-incoming tcp:[host]:port[,to=maxport][,ipv4][,ipv6]\\n\" \\\n    \"-incoming rdma:host:port[,ipv4][,ipv6]\\n\" \\\n    \"-incoming unix:socketpath\\n\" \\\n    \"                prepare for incoming migration, listen on\\n\" \\\n    \"                specified protocol and socket address\\n\" \\\n    \"-incoming fd:fd\\n\" \\\n    \"-incoming exec:cmdline\\n\" \\\n    \"                accept incoming migration on given file descriptor\\n\" \\\n    \"                or from given external command\\n\" \\\n    \"-incoming defer\\n\" \\\n    \"                wait for the URI to be specified via migrate_incoming\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -incoming tcp:[@var{host}]:@var{port}[,to=@var{maxport}][,ipv4][,ipv6]\n@itemx -incoming rdma:@var{host}:@var{port}[,ipv4][,ipv6]\n@findex -incoming\nPrepare for incoming migration, listen on a given tcp port.\n\n@item -incoming unix:@var{socketpath}\nPrepare for incoming migration, listen on a given unix socket.\n\n@item -incoming fd:@var{fd}\nAccept incoming migration from a given filedescriptor.\n\n@item -incoming exec:@var{cmdline}\nAccept incoming migration as an output from specified external command.\n\n@item -incoming defer\nWait for the URI to be specified via migrate_incoming.  The monitor can\nbe used to change settings (such as migration parameters) prior to issuing\nthe migrate_incoming to allow the migration to begin.\nETEXI\n\nDEF(\"only-migratable\", 0, QEMU_OPTION_only_migratable, \\\n    \"-only-migratable     allow only migratable devices\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -only-migratable\n@findex -only-migratable\nOnly allow migratable devices. Devices will not be allowed to enter an\nunmigratable state.\nETEXI\n\nDEF(\"nodefaults\", 0, QEMU_OPTION_nodefaults, \\\n    \"-nodefaults     don't create default devices\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -nodefaults\n@findex -nodefaults\nDon't create default devices. Normally, QEMU sets the default devices like serial\nport, parallel port, virtual console, monitor device, VGA adapter, floppy and\nCD-ROM drive and others. The @code{-nodefaults} option will disable all those\ndefault devices.\nETEXI\n\n#ifndef _WIN32\nDEF(\"chroot\", HAS_ARG, QEMU_OPTION_chroot, \\\n    \"-chroot dir     chroot to dir just before starting the VM\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSTEXI\n@item -chroot @var{dir}\n@findex -chroot\nImmediately before starting guest execution, chroot to the specified\ndirectory.  Especially useful in combination with -runas.\nETEXI\n\n#ifndef _WIN32\nDEF(\"runas\", HAS_ARG, QEMU_OPTION_runas, \\\n    \"-runas user     change to user id user just before starting the VM\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSTEXI\n@item -runas @var{user}\n@findex -runas\nImmediately before starting guest execution, drop root privileges, switching\nto the specified user.\nETEXI\n\nDEF(\"prom-env\", HAS_ARG, QEMU_OPTION_prom_env,\n    \"-prom-env variable=value\\n\"\n    \"                set OpenBIOS nvram variables\\n\",\n    QEMU_ARCH_PPC | QEMU_ARCH_SPARC)\nSTEXI\n@item -prom-env @var{variable}=@var{value}\n@findex -prom-env\nSet OpenBIOS nvram @var{variable} to given @var{value} (PPC, SPARC only).\nETEXI\nDEF(\"semihosting\", 0, QEMU_OPTION_semihosting,\n    \"-semihosting    semihosting mode\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA | QEMU_ARCH_LM32 |\n    QEMU_ARCH_MIPS)\nSTEXI\n@item -semihosting\n@findex -semihosting\nEnable semihosting mode (ARM, M68K, Xtensa, MIPS only).\nETEXI\nDEF(\"semihosting-config\", HAS_ARG, QEMU_OPTION_semihosting_config,\n    \"-semihosting-config [enable=on|off][,target=native|gdb|auto][,arg=str[,...]]\\n\" \\\n    \"                semihosting configuration\\n\",\nQEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA | QEMU_ARCH_LM32 |\nQEMU_ARCH_MIPS)\nSTEXI\n@item -semihosting-config [enable=on|off][,target=native|gdb|auto][,arg=str[,...]]\n@findex -semihosting-config\nEnable and configure semihosting (ARM, M68K, Xtensa, MIPS only).\n@table @option\n@item target=@code{native|gdb|auto}\nDefines where the semihosting calls will be addressed, to QEMU (@code{native})\nor to GDB (@code{gdb}). The default is @code{auto}, which means @code{gdb}\nduring debug sessions and @code{native} otherwise.\n@item arg=@var{str1},arg=@var{str2},...\nAllows the user to pass input arguments, and can be used multiple times to build\nup a list. The old-style @code{-kernel}/@code{-append} method of passing a\ncommand line is still supported for backward compatibility. If both the\n@code{--semihosting-config arg} and the @code{-kernel}/@code{-append} are\nspecified, the former is passed to semihosting as it always takes precedence.\n@end table\nETEXI\nDEF(\"old-param\", 0, QEMU_OPTION_old_param,\n    \"-old-param      old param mode\\n\", QEMU_ARCH_ARM)\nSTEXI\n@item -old-param\n@findex -old-param (ARM)\nOld param mode (ARM only).\nETEXI\n\nDEF(\"sandbox\", HAS_ARG, QEMU_OPTION_sandbox, \\\n    \"-sandbox <arg>  Enable seccomp mode 2 system call filter (default 'off').\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -sandbox @var{arg}\n@findex -sandbox\nEnable Seccomp mode 2 system call filter. 'on' will enable syscall filtering and 'off' will\ndisable it.  The default is 'off'.\nETEXI\n\nDEF(\"readconfig\", HAS_ARG, QEMU_OPTION_readconfig,\n    \"-readconfig <file>\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -readconfig @var{file}\n@findex -readconfig\nRead device configuration from @var{file}. This approach is useful when you want to spawn\nQEMU process with many command line options but you don't want to exceed the command line\ncharacter limit.\nETEXI\nDEF(\"writeconfig\", HAS_ARG, QEMU_OPTION_writeconfig,\n    \"-writeconfig <file>\\n\"\n    \"                read/write config file\\n\", QEMU_ARCH_ALL)\nSTEXI\n@item -writeconfig @var{file}\n@findex -writeconfig\nWrite device configuration to @var{file}. The @var{file} can be either filename to save\ncommand line and device configuration into file or dash @code{-}) character to print the\noutput to stdout. This can be later used as input file for @code{-readconfig} option.\nETEXI\nDEF(\"nodefconfig\", 0, QEMU_OPTION_nodefconfig,\n    \"-nodefconfig\\n\"\n    \"                do not load default config files at startup\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -nodefconfig\n@findex -nodefconfig\nNormally QEMU loads configuration files from @var{sysconfdir} and @var{datadir} at startup.\nThe @code{-nodefconfig} option will prevent QEMU from loading any of those config files.\nETEXI\nDEF(\"no-user-config\", 0, QEMU_OPTION_nouserconfig,\n    \"-no-user-config\\n\"\n    \"                do not load user-provided config files at startup\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -no-user-config\n@findex -no-user-config\nThe @code{-no-user-config} option makes QEMU not load any of the user-provided\nconfig files on @var{sysconfdir}, but won't make it skip the QEMU-provided config\nfiles from @var{datadir}.\nETEXI\nDEF(\"trace\", HAS_ARG, QEMU_OPTION_trace,\n    \"-trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n    \"                specify tracing options\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\nHXCOMM This line is not accurate, as some sub-options are backend-specific but\nHXCOMM HX does not support conditional compilation of text.\n@item -trace [[enable=]@var{pattern}][,events=@var{file}][,file=@var{file}]\n@findex -trace\n@include qemu-option-trace.texi\nETEXI\n\nHXCOMM Internal use\nDEF(\"qtest\", HAS_ARG, QEMU_OPTION_qtest, \"\", QEMU_ARCH_ALL)\nDEF(\"qtest-log\", HAS_ARG, QEMU_OPTION_qtest_log, \"\", QEMU_ARCH_ALL)\n\n#ifdef __linux__\nDEF(\"enable-fips\", 0, QEMU_OPTION_enablefips,\n    \"-enable-fips    enable FIPS 140-2 compliance\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSTEXI\n@item -enable-fips\n@findex -enable-fips\nEnable FIPS 140-2 compliance mode.\nETEXI\n\nHXCOMM Deprecated by -machine accel=tcg property\nDEF(\"no-kvm\", 0, QEMU_OPTION_no_kvm, \"\", QEMU_ARCH_I386)\n\nHXCOMM Deprecated by kvm-pit driver properties\nDEF(\"no-kvm-pit-reinjection\", 0, QEMU_OPTION_no_kvm_pit_reinjection,\n    \"\", QEMU_ARCH_I386)\n\nHXCOMM Deprecated (ignored)\nDEF(\"no-kvm-pit\", 0, QEMU_OPTION_no_kvm_pit, \"\", QEMU_ARCH_I386)\n\nHXCOMM Deprecated by -machine kernel_irqchip=on|off property\nDEF(\"no-kvm-irqchip\", 0, QEMU_OPTION_no_kvm_irqchip, \"\", QEMU_ARCH_I386)\n\nHXCOMM Deprecated (ignored)\nDEF(\"tdf\", 0, QEMU_OPTION_tdf,\"\", QEMU_ARCH_ALL)\n\nDEF(\"msg\", HAS_ARG, QEMU_OPTION_msg,\n    \"-msg timestamp[=on|off]\\n\"\n    \"                change the format of messages\\n\"\n    \"                on|off controls leading timestamps (default:on)\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -msg timestamp[=on|off]\n@findex -msg\nprepend a timestamp to each log message.(default:on)\nETEXI\n\nDEF(\"dump-vmstate\", HAS_ARG, QEMU_OPTION_dump_vmstate,\n    \"-dump-vmstate <file>\\n\"\n    \"                Output vmstate information in JSON format to file.\\n\"\n    \"                Use the scripts/vmstate-static-checker.py file to\\n\"\n    \"                check for possible regressions in migration code\\n\"\n    \"                by comparing two such vmstate dumps.\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -dump-vmstate @var{file}\n@findex -dump-vmstate\nDump json-encoded vmstate information for current machine type to file\nin @var{file}\nETEXI\n\nSTEXI\n@end table\nETEXI\nDEFHEADING()\nDEFHEADING(Generic object creation)\nSTEXI\n@table @option\nETEXI\n\nDEF(\"object\", HAS_ARG, QEMU_OPTION_object,\n    \"-object TYPENAME[,PROP1=VALUE1,...]\\n\"\n    \"                create a new object of type TYPENAME setting properties\\n\"\n    \"                in the order they are specified.  Note that the 'id'\\n\"\n    \"                property must be set.  These objects are placed in the\\n\"\n    \"                '/objects' path.\\n\",\n    QEMU_ARCH_ALL)\nSTEXI\n@item -object @var{typename}[,@var{prop1}=@var{value1},...]\n@findex -object\nCreate a new object of type @var{typename} setting properties\nin the order they are specified.  Note that the 'id'\nproperty must be set.  These objects are placed in the\n'/objects' path.\n\n@table @option\n\n@item -object memory-backend-file,id=@var{id},size=@var{size},mem-path=@var{dir},share=@var{on|off}\n\nCreates a memory file backend object, which can be used to back\nthe guest RAM with huge pages. The @option{id} parameter is a\nunique ID that will be used to reference this memory region\nwhen configuring the @option{-numa} argument. The @option{size}\noption provides the size of the memory region, and accepts\ncommon suffixes, eg @option{500M}. The @option{mem-path} provides\nthe path to either a shared memory or huge page filesystem mount.\nThe @option{share} boolean option determines whether the memory\nregion is marked as private to QEMU, or shared. The latter allows\na co-operating external process to access the QEMU memory region.\n\n@item -object rng-random,id=@var{id},filename=@var{/dev/random}\n\nCreates a random number generator backend which obtains entropy from\na device on the host. The @option{id} parameter is a unique ID that\nwill be used to reference this entropy backend from the @option{virtio-rng}\ndevice. The @option{filename} parameter specifies which file to obtain\nentropy from and if omitted defaults to @option{/dev/random}.\n\n@item -object rng-egd,id=@var{id},chardev=@var{chardevid}\n\nCreates a random number generator backend which obtains entropy from\nan external daemon running on the host. The @option{id} parameter is\na unique ID that will be used to reference this entropy backend from\nthe @option{virtio-rng} device. The @option{chardev} parameter is\nthe unique ID of a character device backend that provides the connection\nto the RNG daemon.\n\n@item -object tls-creds-anon,id=@var{id},endpoint=@var{endpoint},dir=@var{/path/to/cred/dir},verify-peer=@var{on|off}\n\nCreates a TLS anonymous credentials object, which can be used to provide\nTLS support on network backends. The @option{id} parameter is a unique\nID which network backends will use to access the credentials. The\n@option{endpoint} is either @option{server} or @option{client} depending\non whether the QEMU network backend that uses the credentials will be\nacting as a client or as a server. If @option{verify-peer} is enabled\n(the default) then once the handshake is completed, the peer credentials\nwill be verified, though this is a no-op for anonymous credentials.\n\nThe @var{dir} parameter tells QEMU where to find the credential\nfiles. For server endpoints, this directory may contain a file\n@var{dh-params.pem} providing diffie-hellman parameters to use\nfor the TLS server. If the file is missing, QEMU will generate\na set of DH parameters at startup. This is a computationally\nexpensive operation that consumes random pool entropy, so it is\nrecommended that a persistent set of parameters be generated\nupfront and saved.\n\n@item -object tls-creds-x509,id=@var{id},endpoint=@var{endpoint},dir=@var{/path/to/cred/dir},verify-peer=@var{on|off},passwordid=@var{id}\n\nCreates a TLS anonymous credentials object, which can be used to provide\nTLS support on network backends. The @option{id} parameter is a unique\nID which network backends will use to access the credentials. The\n@option{endpoint} is either @option{server} or @option{client} depending\non whether the QEMU network backend that uses the credentials will be\nacting as a client or as a server. If @option{verify-peer} is enabled\n(the default) then once the handshake is completed, the peer credentials\nwill be verified. With x509 certificates, this implies that the clients\nmust be provided with valid client certificates too.\n\nThe @var{dir} parameter tells QEMU where to find the credential\nfiles. For server endpoints, this directory may contain a file\n@var{dh-params.pem} providing diffie-hellman parameters to use\nfor the TLS server. If the file is missing, QEMU will generate\na set of DH parameters at startup. This is a computationally\nexpensive operation that consumes random pool entropy, so it is\nrecommended that a persistent set of parameters be generated\nupfront and saved.\n\nFor x509 certificate credentials the directory will contain further files\nproviding the x509 certificates. The certificates must be stored\nin PEM format, in filenames @var{ca-cert.pem}, @var{ca-crl.pem} (optional),\n@var{server-cert.pem} (only servers), @var{server-key.pem} (only servers),\n@var{client-cert.pem} (only clients), and @var{client-key.pem} (only clients).\n\nFor the @var{server-key.pem} and @var{client-key.pem} files which\ncontain sensitive private keys, it is possible to use an encrypted\nversion by providing the @var{passwordid} parameter. This provides\nthe ID of a previously created @code{secret} object containing the\npassword for decryption.\n\n@item -object filter-buffer,id=@var{id},netdev=@var{netdevid},interval=@var{t}[,queue=@var{all|rx|tx}][,status=@var{on|off}]\n\nInterval @var{t} can't be 0, this filter batches the packet delivery: all\npackets arriving in a given interval on netdev @var{netdevid} are delayed\nuntil the end of the interval. Interval is in microseconds.\n@option{status} is optional that indicate whether the netfilter is\non (enabled) or off (disabled), the default status for netfilter will be 'on'.\n\nqueue @var{all|rx|tx} is an option that can be applied to any netfilter.\n\n@option{all}: the filter is attached both to the receive and the transmit\n              queue of the netdev (default).\n\n@option{rx}: the filter is attached to the receive queue of the netdev,\n             where it will receive packets sent to the netdev.\n\n@option{tx}: the filter is attached to the transmit queue of the netdev,\n             where it will receive packets sent by the netdev.\n\n@item -object filter-mirror,id=@var{id},netdev=@var{netdevid},outdev=@var{chardevid}[,queue=@var{all|rx|tx}]\n\nfilter-mirror on netdev @var{netdevid},mirror net packet to chardev\n@var{chardevid}\n\n@item -object filter-redirector,id=@var{id},netdev=@var{netdevid},indev=@var{chardevid},\noutdev=@var{chardevid}[,queue=@var{all|rx|tx}]\n\nfilter-redirector on netdev @var{netdevid},redirect filter's net packet to chardev\n@var{chardevid},and redirect indev's packet to filter.\nCreate a filter-redirector we need to differ outdev id from indev id, id can not\nbe the same. we can just use indev or outdev, but at least one of indev or outdev\nneed to be specified.\n\n@item -object filter-rewriter,id=@var{id},netdev=@var{netdevid},rewriter-mode=@var{mode}[,queue=@var{all|rx|tx}]\n\nFilter-rewriter is a part of COLO project.It will rewrite tcp packet to\nsecondary from primary to keep secondary tcp connection,and rewrite\ntcp packet to primary from secondary make tcp packet can be handled by\nclient.\n\nusage:\ncolo secondary:\n-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0\n-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1\n-object filter-rewriter,id=rew0,netdev=hn0,queue=all\n\n@item -object filter-dump,id=@var{id},netdev=@var{dev}[,file=@var{filename}][,maxlen=@var{len}]\n\nDump the network traffic on netdev @var{dev} to the file specified by\n@var{filename}. At most @var{len} bytes (64k by default) per packet are stored.\nThe file format is libpcap, so it can be analyzed with tools such as tcpdump\nor Wireshark.\n\n@item -object colo-compare,id=@var{id},primary_in=@var{chardevid},secondary_in=@var{chardevid},\noutdev=@var{chardevid}\n\nColo-compare gets packet from primary_in@var{chardevid} and secondary_in@var{chardevid}, than compare primary packet with\nsecondary packet. If the packets are same, we will output primary\npacket to outdev@var{chardevid}, else we will notify colo-frame\ndo checkpoint and send primary packet to outdev@var{chardevid}.\n\nwe must use it with the help of filter-mirror and filter-redirector.\n\n@example\n\nprimary:\n-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown\n-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66\n-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server,nowait\n-chardev socket,id=compare1,host=3.3.3.3,port=9004,server,nowait\n-chardev socket,id=compare0,host=3.3.3.3,port=9001,server,nowait\n-chardev socket,id=compare0-0,host=3.3.3.3,port=9001\n-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server,nowait\n-chardev socket,id=compare_out0,host=3.3.3.3,port=9005\n-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0\n-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out\n-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0\n-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0\n\nsecondary:\n-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown\n-device e1000,netdev=hn0,mac=52:a4:00:12:78:66\n-chardev socket,id=red0,host=3.3.3.3,port=9003\n-chardev socket,id=red1,host=3.3.3.3,port=9004\n-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0\n-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1\n\n@end example\n\nIf you want to know the detail of above command line, you can read\nthe colo-compare git log.\n\n@item -object cryptodev-backend-builtin,id=@var{id}[,queues=@var{queues}]\n\nCreates a cryptodev backend which executes crypto opreation from\nthe QEMU cipher APIS. The @var{id} parameter is\na unique ID that will be used to reference this cryptodev backend from\nthe @option{virtio-crypto} device. The @var{queues} parameter is optional,\nwhich specify the queue number of cryptodev backend, the default of\n@var{queues} is 1.\n\n@example\n\n # qemu-system-x86_64 \\\n   [...] \\\n       -object cryptodev-backend-builtin,id=cryptodev0 \\\n       -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \\\n   [...]\n@end example\n\n@item -object secret,id=@var{id},data=@var{string},format=@var{raw|base64}[,keyid=@var{secretid},iv=@var{string}]\n@item -object secret,id=@var{id},file=@var{filename},format=@var{raw|base64}[,keyid=@var{secretid},iv=@var{string}]\n\nDefines a secret to store a password, encryption key, or some other sensitive\ndata. The sensitive data can either be passed directly via the @var{data}\nparameter, or indirectly via the @var{file} parameter. Using the @var{data}\nparameter is insecure unless the sensitive data is encrypted.\n\nThe sensitive data can be provided in raw format (the default), or base64.\nWhen encoded as JSON, the raw format only supports valid UTF-8 characters,\nso base64 is recommended for sending binary data. QEMU will convert from\nwhich ever format is provided to the format it needs internally. eg, an\nRBD password can be provided in raw format, even though it will be base64\nencoded when passed onto the RBD sever.\n\nFor added protection, it is possible to encrypt the data associated with\na secret using the AES-256-CBC cipher. Use of encryption is indicated\nby providing the @var{keyid} and @var{iv} parameters. The @var{keyid}\nparameter provides the ID of a previously defined secret that contains\nthe AES-256 decryption key. This key should be 32-bytes long and be\nbase64 encoded. The @var{iv} parameter provides the random initialization\nvector used for encryption of this particular secret and should be a\nbase64 encrypted string of the 16-byte IV.\n\nThe simplest (insecure) usage is to provide the secret inline\n\n@example\n\n # $QEMU -object secret,id=sec0,data=letmein,format=raw\n\n@end example\n\nThe simplest secure usage is to provide the secret via a file\n\n # echo -n \"letmein\" > mypasswd.txt\n # $QEMU -object secret,id=sec0,file=mypasswd.txt,format=raw\n\nFor greater security, AES-256-CBC should be used. To illustrate usage,\nconsider the openssl command line tool which can encrypt the data. Note\nthat when encrypting, the plaintext must be padded to the cipher block\nsize (32 bytes) using the standard PKCS#5/6 compatible padding algorithm.\n\nFirst a master key needs to be created in base64 encoding:\n\n@example\n # openssl rand -base64 32 > key.b64\n # KEY=$(base64 -d key.b64 | hexdump  -v -e '/1 \"%02X\"')\n@end example\n\nEach secret to be encrypted needs to have a random initialization vector\ngenerated. These do not need to be kept secret\n\n@example\n # openssl rand -base64 16 > iv.b64\n # IV=$(base64 -d iv.b64 | hexdump  -v -e '/1 \"%02X\"')\n@end example\n\nThe secret to be defined can now be encrypted, in this case we're\ntelling openssl to base64 encode the result, but it could be left\nas raw bytes if desired.\n\n@example\n # SECRET=$(echo -n \"letmein\" |\n            openssl enc -aes-256-cbc -a -K $KEY -iv $IV)\n@end example\n\nWhen launching QEMU, create a master secret pointing to @code{key.b64}\nand specify that to be used to decrypt the user password. Pass the\ncontents of @code{iv.b64} to the second secret\n\n@example\n # $QEMU \\\n     -object secret,id=secmaster0,format=base64,file=key.b64 \\\n     -object secret,id=sec0,keyid=secmaster0,format=base64,\\\n         data=$SECRET,iv=$(<iv.b64)\n@end example\n\n@end table\n\nETEXI\n\n#if defined(CONFIG_LLVM)\nDEF(\"llvm\", 0, QEMU_OPTION_execute_llvm,\n    \"-llvm           execute code using LLVM JIT\\n\", QEMU_ARCH_ALL)\nDEF(\"generate-llvm\", 0, QEMU_OPTION_generate_llvm,\n    \"-generate-llvm  translate code into LLVM but don't execute it\\n\", QEMU_ARCH_ALL)\n#endif\n\nDEF(\"record-from\", HAS_ARG, QEMU_OPTION_record_from,\n    \"-record-from <snapshot>:<record-name>\\n\"\n    \"                load snapshot <snapshot> and begin recording\\n\", QEMU_ARCH_ALL)\n\nDEF(\"replay\", HAS_ARG, QEMU_OPTION_replay,\n    \"-replay </path/to/snapshot-prefix>\\n\"\n    \"                replay the recording that starts at <snapshot>\\n\", QEMU_ARCH_ALL)\n\nDEF(\"pandalog\", HAS_ARG, QEMU_OPTION_pandalog,\n    \"-pandalog <filename>\\n\"\n    \"                enable panda logging to file\\n\", QEMU_ARCH_ALL)\n\nDEF(\"panda-plugin\", HAS_ARG, QEMU_OPTION_panda_plugin,\n    \"-panda-plugin <file>\\n\"\n    \"                load PANDA plugin from <file>\\n\", QEMU_ARCH_ALL)\n\nDEF(\"panda-arg\", HAS_ARG, QEMU_OPTION_panda_arg,\n    \"-panda-arg <plugin:opt=val>\\n\"\n    \"                pass <opt=val> to <plugin>\\n\", QEMU_ARCH_ALL)\n\nDEF(\"panda\", HAS_ARG, QEMU_OPTION_panda_plugins,\n    \"-panda <plugin1_name:opt1=val1,opt2=val2;plugin2_name>\\n\"\n    \"               load <plugin1> with <opt1=val1> and <opt2=val2>; load <plugin2>\\n\"\n    \"               uses qemubuilddir/panda_plugins/panda_%s.so by default\\n\", QEMU_ARCH_ALL)\n\nDEF(\"os\", HAS_ARG, QEMU_OPTION_panda_os_name,\n    \"-os os_name\\n\"\n    \"               inform panda about guest operating system\\n\", QEMU_ARCH_ALL)\n\nDEF(\"complete-rr-snapshot\", 0, QEMU_OPTION_complete_rr_snapshot,\n    \"-complete-rr-snapshot\\n\"\n    \"       record all SaveStateEntry in the snapshot when a new recording is created\\n\", QEMU_ARCH_ALL)\n\nHXCOMM This is the last statement. Insert new options before this line!\nSTEXI\n@end table\nETEXI\n"
        },
        {
          "name": "qemu-seccomp.c",
          "type": "blob",
          "size": 8.859375,
          "content": "/*\n * QEMU seccomp mode 2 support with libseccomp\n *\n * Copyright IBM, Corp. 2012\n *\n * Authors:\n *  Eduardo Otubo    <eotubo@br.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n#include \"qemu/osdep.h\"\n#include <seccomp.h>\n#include \"sysemu/seccomp.h\"\n\n/* For some architectures (notably ARM) cacheflush is not supported until\n * libseccomp 2.2.3, but configure enforces that we are using a more recent\n * version on those hosts, so it is OK for this check to be less strict.\n */\n#if SCMP_VER_MAJOR >= 3\n  #define HAVE_CACHEFLUSH\n#elif SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR >= 2\n  #define HAVE_CACHEFLUSH\n#endif\n\nstruct QemuSeccompSyscall {\n    int32_t num;\n    uint8_t priority;\n};\n\nstatic const struct QemuSeccompSyscall seccomp_whitelist[] = {\n    { SCMP_SYS(timer_settime), 255 },\n    { SCMP_SYS(timer_gettime), 254 },\n    { SCMP_SYS(futex), 253 },\n    { SCMP_SYS(select), 252 },\n    { SCMP_SYS(recvfrom), 251 },\n    { SCMP_SYS(sendto), 250 },\n    { SCMP_SYS(socketcall), 250 },\n    { SCMP_SYS(read), 249 },\n    { SCMP_SYS(io_submit), 249 },\n    { SCMP_SYS(brk), 248 },\n    { SCMP_SYS(clone), 247 },\n    { SCMP_SYS(mmap), 247 },\n    { SCMP_SYS(mprotect), 246 },\n    { SCMP_SYS(execve), 245 },\n    { SCMP_SYS(open), 245 },\n    { SCMP_SYS(ioctl), 245 },\n    { SCMP_SYS(socket), 245 },\n    { SCMP_SYS(setsockopt), 245 },\n    { SCMP_SYS(recvmsg), 245 },\n    { SCMP_SYS(sendmsg), 245 },\n    { SCMP_SYS(accept), 245 },\n    { SCMP_SYS(connect), 245 },\n    { SCMP_SYS(socketpair), 245 },\n    { SCMP_SYS(bind), 245 },\n    { SCMP_SYS(listen), 245 },\n    { SCMP_SYS(semget), 245 },\n    { SCMP_SYS(ipc), 245 },\n    { SCMP_SYS(gettimeofday), 245 },\n    { SCMP_SYS(readlink), 245 },\n    { SCMP_SYS(access), 245 },\n    { SCMP_SYS(prctl), 245 },\n    { SCMP_SYS(signalfd), 245 },\n    { SCMP_SYS(getrlimit), 245 },\n    { SCMP_SYS(getrusage), 245 },\n    { SCMP_SYS(set_tid_address), 245 },\n    { SCMP_SYS(statfs), 245 },\n    { SCMP_SYS(unlink), 245 },\n    { SCMP_SYS(wait4), 245 },\n    { SCMP_SYS(fcntl64), 245 },\n    { SCMP_SYS(fstat64), 245 },\n    { SCMP_SYS(stat64), 245 },\n    { SCMP_SYS(getgid32), 245 },\n    { SCMP_SYS(getegid32), 245 },\n    { SCMP_SYS(getuid32), 245 },\n    { SCMP_SYS(geteuid32), 245 },\n    { SCMP_SYS(sigreturn), 245 },\n    { SCMP_SYS(_newselect), 245 },\n    { SCMP_SYS(_llseek), 245 },\n    { SCMP_SYS(mmap2), 245 },\n    { SCMP_SYS(sigprocmask), 245 },\n    { SCMP_SYS(sched_getparam), 245 },\n    { SCMP_SYS(sched_getscheduler), 245 },\n    { SCMP_SYS(fstat), 245 },\n    { SCMP_SYS(clock_getres), 245 },\n    { SCMP_SYS(sched_get_priority_min), 245 },\n    { SCMP_SYS(sched_get_priority_max), 245 },\n    { SCMP_SYS(stat), 245 },\n    { SCMP_SYS(uname), 245 },\n    { SCMP_SYS(eventfd2), 245 },\n    { SCMP_SYS(io_getevents), 245 },\n    { SCMP_SYS(dup), 245 },\n    { SCMP_SYS(dup2), 245 },\n    { SCMP_SYS(dup3), 245 },\n    { SCMP_SYS(gettid), 245 },\n    { SCMP_SYS(getgid), 245 },\n    { SCMP_SYS(getegid), 245 },\n    { SCMP_SYS(getuid), 245 },\n    { SCMP_SYS(geteuid), 245 },\n    { SCMP_SYS(timer_create), 245 },\n    { SCMP_SYS(times), 245 },\n    { SCMP_SYS(exit), 245 },\n    { SCMP_SYS(clock_gettime), 245 },\n    { SCMP_SYS(time), 245 },\n    { SCMP_SYS(restart_syscall), 245 },\n    { SCMP_SYS(pwrite64), 245 },\n    { SCMP_SYS(nanosleep), 245 },\n    { SCMP_SYS(chown), 245 },\n    { SCMP_SYS(openat), 245 },\n    { SCMP_SYS(getdents), 245 },\n    { SCMP_SYS(timer_delete), 245 },\n    { SCMP_SYS(exit_group), 245 },\n    { SCMP_SYS(rt_sigreturn), 245 },\n    { SCMP_SYS(sync), 245 },\n    { SCMP_SYS(pread64), 245 },\n    { SCMP_SYS(madvise), 245 },\n    { SCMP_SYS(set_robust_list), 245 },\n    { SCMP_SYS(lseek), 245 },\n    { SCMP_SYS(pselect6), 245 },\n    { SCMP_SYS(fork), 245 },\n    { SCMP_SYS(rt_sigprocmask), 245 },\n    { SCMP_SYS(write), 244 },\n    { SCMP_SYS(fcntl), 243 },\n    { SCMP_SYS(tgkill), 242 },\n    { SCMP_SYS(kill), 242 },\n    { SCMP_SYS(rt_sigaction), 242 },\n    { SCMP_SYS(pipe2), 242 },\n    { SCMP_SYS(munmap), 242 },\n    { SCMP_SYS(mremap), 242 },\n    { SCMP_SYS(fdatasync), 242 },\n    { SCMP_SYS(close), 242 },\n    { SCMP_SYS(rt_sigpending), 242 },\n    { SCMP_SYS(rt_sigtimedwait), 242 },\n    { SCMP_SYS(readv), 242 },\n    { SCMP_SYS(writev), 242 },\n    { SCMP_SYS(preadv), 242 },\n    { SCMP_SYS(pwritev), 242 },\n    { SCMP_SYS(setrlimit), 242 },\n    { SCMP_SYS(ftruncate), 242 },\n    { SCMP_SYS(lstat), 242 },\n    { SCMP_SYS(pipe), 242 },\n    { SCMP_SYS(umask), 242 },\n    { SCMP_SYS(chdir), 242 },\n    { SCMP_SYS(setitimer), 242 },\n    { SCMP_SYS(setsid), 242 },\n    { SCMP_SYS(poll), 242 },\n    { SCMP_SYS(epoll_create), 242 },\n    { SCMP_SYS(epoll_ctl), 242 },\n    { SCMP_SYS(epoll_wait), 242 },\n    { SCMP_SYS(waitpid), 242 },\n    { SCMP_SYS(getsockname), 242 },\n    { SCMP_SYS(getpeername), 242 },\n    { SCMP_SYS(accept4), 242 },\n    { SCMP_SYS(timerfd_settime), 242 },\n    { SCMP_SYS(newfstatat), 241 },\n    { SCMP_SYS(shutdown), 241 },\n    { SCMP_SYS(getsockopt), 241 },\n    { SCMP_SYS(semop), 241 },\n    { SCMP_SYS(semtimedop), 241 },\n    { SCMP_SYS(epoll_ctl_old), 241 },\n    { SCMP_SYS(epoll_wait_old), 241 },\n    { SCMP_SYS(epoll_pwait), 241 },\n    { SCMP_SYS(epoll_create1), 241 },\n    { SCMP_SYS(ppoll), 241 },\n    { SCMP_SYS(creat), 241 },\n    { SCMP_SYS(link), 241 },\n    { SCMP_SYS(getpid), 241 },\n    { SCMP_SYS(getppid), 241 },\n    { SCMP_SYS(getpgrp), 241 },\n    { SCMP_SYS(getpgid), 241 },\n    { SCMP_SYS(getsid), 241 },\n    { SCMP_SYS(getdents64), 241 },\n    { SCMP_SYS(getresuid), 241 },\n    { SCMP_SYS(getresgid), 241 },\n    { SCMP_SYS(getgroups), 241 },\n    { SCMP_SYS(getresuid32), 241 },\n    { SCMP_SYS(getresgid32), 241 },\n    { SCMP_SYS(getgroups32), 241 },\n    { SCMP_SYS(signal), 241 },\n    { SCMP_SYS(sigaction), 241 },\n    { SCMP_SYS(sigsuspend), 241 },\n    { SCMP_SYS(sigpending), 241 },\n    { SCMP_SYS(truncate64), 241 },\n    { SCMP_SYS(ftruncate64), 241 },\n    { SCMP_SYS(fchown32), 241 },\n    { SCMP_SYS(chown32), 241 },\n    { SCMP_SYS(lchown32), 241 },\n    { SCMP_SYS(statfs64), 241 },\n    { SCMP_SYS(fstatfs64), 241 },\n    { SCMP_SYS(fstatat64), 241 },\n    { SCMP_SYS(lstat64), 241 },\n    { SCMP_SYS(sendfile64), 241 },\n    { SCMP_SYS(ugetrlimit), 241 },\n    { SCMP_SYS(alarm), 241 },\n    { SCMP_SYS(rt_sigsuspend), 241 },\n    { SCMP_SYS(rt_sigqueueinfo), 241 },\n    { SCMP_SYS(rt_tgsigqueueinfo), 241 },\n    { SCMP_SYS(sigaltstack), 241 },\n    { SCMP_SYS(signalfd4), 241 },\n    { SCMP_SYS(truncate), 241 },\n    { SCMP_SYS(fchown), 241 },\n    { SCMP_SYS(lchown), 241 },\n    { SCMP_SYS(fchownat), 241 },\n    { SCMP_SYS(fstatfs), 241 },\n    { SCMP_SYS(getitimer), 241 },\n    { SCMP_SYS(syncfs), 241 },\n    { SCMP_SYS(fsync), 241 },\n    { SCMP_SYS(fchdir), 241 },\n    { SCMP_SYS(msync), 241 },\n    { SCMP_SYS(sched_setparam), 241 },\n    { SCMP_SYS(sched_setscheduler), 241 },\n    { SCMP_SYS(sched_yield), 241 },\n    { SCMP_SYS(sched_rr_get_interval), 241 },\n    { SCMP_SYS(sched_setaffinity), 241 },\n    { SCMP_SYS(sched_getaffinity), 241 },\n    { SCMP_SYS(readahead), 241 },\n    { SCMP_SYS(timer_getoverrun), 241 },\n    { SCMP_SYS(unlinkat), 241 },\n    { SCMP_SYS(readlinkat), 241 },\n    { SCMP_SYS(faccessat), 241 },\n    { SCMP_SYS(get_robust_list), 241 },\n    { SCMP_SYS(splice), 241 },\n    { SCMP_SYS(vmsplice), 241 },\n    { SCMP_SYS(getcpu), 241 },\n    { SCMP_SYS(sendmmsg), 241 },\n    { SCMP_SYS(recvmmsg), 241 },\n    { SCMP_SYS(prlimit64), 241 },\n    { SCMP_SYS(waitid), 241 },\n    { SCMP_SYS(io_cancel), 241 },\n    { SCMP_SYS(io_setup), 241 },\n    { SCMP_SYS(io_destroy), 241 },\n    { SCMP_SYS(arch_prctl), 240 },\n    { SCMP_SYS(mkdir), 240 },\n    { SCMP_SYS(fchmod), 240 },\n    { SCMP_SYS(shmget), 240 },\n    { SCMP_SYS(shmat), 240 },\n    { SCMP_SYS(shmdt), 240 },\n    { SCMP_SYS(timerfd_create), 240 },\n    { SCMP_SYS(shmctl), 240 },\n    { SCMP_SYS(mlockall), 240 },\n    { SCMP_SYS(mlock), 240 },\n    { SCMP_SYS(munlock), 240 },\n    { SCMP_SYS(semctl), 240 },\n    { SCMP_SYS(fallocate), 240 },\n    { SCMP_SYS(fadvise64), 240 },\n    { SCMP_SYS(inotify_init1), 240 },\n    { SCMP_SYS(inotify_add_watch), 240 },\n    { SCMP_SYS(mbind), 240 },\n    { SCMP_SYS(memfd_create), 240 },\n#ifdef HAVE_CACHEFLUSH\n    { SCMP_SYS(cacheflush), 240 },\n#endif\n    { SCMP_SYS(sysinfo), 240 },\n};\n\nint seccomp_start(void)\n{\n    int rc = 0;\n    unsigned int i = 0;\n    scmp_filter_ctx ctx;\n\n    ctx = seccomp_init(SCMP_ACT_KILL);\n    if (ctx == NULL) {\n        rc = -1;\n        goto seccomp_return;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(seccomp_whitelist); i++) {\n        rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, seccomp_whitelist[i].num, 0);\n        if (rc < 0) {\n            goto seccomp_return;\n        }\n        rc = seccomp_syscall_priority(ctx, seccomp_whitelist[i].num,\n                                      seccomp_whitelist[i].priority);\n        if (rc < 0) {\n            goto seccomp_return;\n        }\n    }\n\n    rc = seccomp_load(ctx);\n\n  seccomp_return:\n    seccomp_release(ctx);\n    return rc;\n}\n"
        },
        {
          "name": "qemu-tech.texi",
          "type": "blob",
          "size": 12.34375,
          "content": "@node Implementation notes\n@appendix Implementation notes\n\n@menu\n* CPU emulation::\n* Translator Internals::\n* QEMU compared to other emulators::\n* Bibliography::\n@end menu\n\n@node CPU emulation\n@section CPU emulation\n\n@menu\n* x86::     x86 and x86-64 emulation\n* ARM::     ARM emulation\n* MIPS::    MIPS emulation\n* PPC::     PowerPC emulation\n* SPARC::   Sparc32 and Sparc64 emulation\n* Xtensa::  Xtensa emulation\n@end menu\n\n@node x86\n@subsection x86 and x86-64 emulation\n\nQEMU x86 target features:\n\n@itemize\n\n@item The virtual x86 CPU supports 16 bit and 32 bit addressing with segmentation.\nLDT/GDT and IDT are emulated. VM86 mode is also supported to run\nDOSEMU. There is some support for MMX/3DNow!, SSE, SSE2, SSE3, SSSE3,\nand SSE4 as well as x86-64 SVM.\n\n@item Support of host page sizes bigger than 4KB in user mode emulation.\n\n@item QEMU can emulate itself on x86.\n\n@item An extensive Linux x86 CPU test program is included @file{tests/test-i386}.\nIt can be used to test other x86 virtual CPUs.\n\n@end itemize\n\nCurrent QEMU limitations:\n\n@itemize\n\n@item Limited x86-64 support.\n\n@item IPC syscalls are missing.\n\n@item The x86 segment limits and access rights are not tested at every\nmemory access (yet). Hopefully, very few OSes seem to rely on that for\nnormal use.\n\n@end itemize\n\n@node ARM\n@subsection ARM emulation\n\n@itemize\n\n@item Full ARM 7 user emulation.\n\n@item NWFPE FPU support included in user Linux emulation.\n\n@item Can run most ARM Linux binaries.\n\n@end itemize\n\n@node MIPS\n@subsection MIPS emulation\n\n@itemize\n\n@item The system emulation allows full MIPS32/MIPS64 Release 2 emulation,\nincluding privileged instructions, FPU and MMU, in both little and big\nendian modes.\n\n@item The Linux userland emulation can run many 32 bit MIPS Linux binaries.\n\n@end itemize\n\nCurrent QEMU limitations:\n\n@itemize\n\n@item Self-modifying code is not always handled correctly.\n\n@item 64 bit userland emulation is not implemented.\n\n@item The system emulation is not complete enough to run real firmware.\n\n@item The watchpoint debug facility is not implemented.\n\n@end itemize\n\n@node PPC\n@subsection PowerPC emulation\n\n@itemize\n\n@item Full PowerPC 32 bit emulation, including privileged instructions,\nFPU and MMU.\n\n@item Can run most PowerPC Linux binaries.\n\n@end itemize\n\n@node SPARC\n@subsection Sparc32 and Sparc64 emulation\n\n@itemize\n\n@item Full SPARC V8 emulation, including privileged\ninstructions, FPU and MMU. SPARC V9 emulation includes most privileged\nand VIS instructions, FPU and I/D MMU. Alignment is fully enforced.\n\n@item Can run most 32-bit SPARC Linux binaries, SPARC32PLUS Linux binaries and\nsome 64-bit SPARC Linux binaries.\n\n@end itemize\n\nCurrent QEMU limitations:\n\n@itemize\n\n@item IPC syscalls are missing.\n\n@item Floating point exception support is buggy.\n\n@item Atomic instructions are not correctly implemented.\n\n@item There are still some problems with Sparc64 emulators.\n\n@end itemize\n\n@node Xtensa\n@subsection Xtensa emulation\n\n@itemize\n\n@item Core Xtensa ISA emulation, including most options: code density,\nloop, extended L32R, 16- and 32-bit multiplication, 32-bit division,\nMAC16, miscellaneous operations, boolean, FP coprocessor, coprocessor\ncontext, debug, multiprocessor synchronization,\nconditional store, exceptions, relocatable vectors, unaligned exception,\ninterrupts (including high priority and timer), hardware alignment,\nregion protection, region translation, MMU, windowed registers, thread\npointer, processor ID.\n\n@item Not implemented options: data/instruction cache (including cache\nprefetch and locking), XLMI, processor interface. Also options not\ncovered by the core ISA (e.g. FLIX, wide branches) are not implemented.\n\n@item Can run most Xtensa Linux binaries.\n\n@item New core configuration that requires no additional instructions\nmay be created from overlay with minimal amount of hand-written code.\n\n@end itemize\n\n@node Translator Internals\n@section Translator Internals\n\nQEMU is a dynamic translator. When it first encounters a piece of code,\nit converts it to the host instruction set. Usually dynamic translators\nare very complicated and highly CPU dependent. QEMU uses some tricks\nwhich make it relatively easily portable and simple while achieving good\nperformances.\n\nQEMU's dynamic translation backend is called TCG, for \"Tiny Code\nGenerator\". For more information, please take a look at @code{tcg/README}.\n\nSome notable features of QEMU's dynamic translator are:\n\n@table @strong\n\n@item CPU state optimisations:\nThe target CPUs have many internal states which change the way it\nevaluates instructions. In order to achieve a good speed, the\ntranslation phase considers that some state information of the virtual\nCPU cannot change in it. The state is recorded in the Translation\nBlock (TB). If the state changes (e.g. privilege level), a new TB will\nbe generated and the previous TB won't be used anymore until the state\nmatches the state recorded in the previous TB. The same idea can be applied\nto other aspects of the CPU state.  For example, on x86, if the SS,\nDS and ES segments have a zero base, then the translator does not even\ngenerate an addition for the segment base.\n\n@item Direct block chaining:\nAfter each translated basic block is executed, QEMU uses the simulated\nProgram Counter (PC) and other cpu state information (such as the CS\nsegment base value) to find the next basic block.\n\nIn order to accelerate the most common cases where the new simulated PC\nis known, QEMU can patch a basic block so that it jumps directly to the\nnext one.\n\nThe most portable code uses an indirect jump. An indirect jump makes\nit easier to make the jump target modification atomic. On some host\narchitectures (such as x86 or PowerPC), the @code{JUMP} opcode is\ndirectly patched so that the block chaining has no overhead.\n\n@item Self-modifying code and translated code invalidation:\nSelf-modifying code is a special challenge in x86 emulation because no\ninstruction cache invalidation is signaled by the application when code\nis modified.\n\nUser-mode emulation marks a host page as write-protected (if it is\nnot already read-only) every time translated code is generated for a\nbasic block.  Then, if a write access is done to the page, Linux raises\na SEGV signal. QEMU then invalidates all the translated code in the page\nand enables write accesses to the page.  For system emulation, write\nprotection is achieved through the software MMU.\n\nCorrect translated code invalidation is done efficiently by maintaining\na linked list of every translated block contained in a given page. Other\nlinked lists are also maintained to undo direct block chaining.\n\nOn RISC targets, correctly written software uses memory barriers and\ncache flushes, so some of the protection above would not be\nnecessary. However, QEMU still requires that the generated code always\nmatches the target instructions in memory in order to handle\nexceptions correctly.\n\n@item Exception support:\nlongjmp() is used when an exception such as division by zero is\nencountered.\n\nThe host SIGSEGV and SIGBUS signal handlers are used to get invalid\nmemory accesses.  QEMU keeps a map from host program counter to\ntarget program counter, and looks up where the exception happened\nbased on the host program counter at the exception point.\n\nOn some targets, some bits of the virtual CPU's state are not flushed to the\nmemory until the end of the translation block.  This is done for internal\nemulation state that is rarely accessed directly by the program and/or changes\nvery often throughout the execution of a translation block---this includes\ncondition codes on x86, delay slots on SPARC, conditional execution on\nARM, and so on.  This state is stored for each target instruction, and\nlooked up on exceptions.\n\n@item MMU emulation:\nFor system emulation QEMU uses a software MMU. In that mode, the MMU\nvirtual to physical address translation is done at every memory\naccess.\n\nQEMU uses an address translation cache (TLB) to speed up the translation.\nIn order to avoid flushing the translated code each time the MMU\nmappings change, all caches in QEMU are physically indexed.  This\nmeans that each basic block is indexed with its physical address.\n\nIn order to avoid invalidating the basic block chain when MMU mappings\nchange, chaining is only performed when the destination of the jump\nshares a page with the basic block that is performing the jump.\n\nThe MMU can also distinguish RAM and ROM memory areas from MMIO memory\nareas.  Access is faster for RAM and ROM because the translation cache also\nhosts the offset between guest address and host memory.  Accessing MMIO\nmemory areas instead calls out to C code for device emulation.\nFinally, the MMU helps tracking dirty pages and pages pointed to by\ntranslation blocks.\n@end table\n\n@node QEMU compared to other emulators\n@section QEMU compared to other emulators\n\nLike bochs [1], QEMU emulates an x86 CPU. But QEMU is much faster than\nbochs as it uses dynamic compilation. Bochs is closely tied to x86 PC\nemulation while QEMU can emulate several processors.\n\nLike Valgrind [2], QEMU does user space emulation and dynamic\ntranslation. Valgrind is mainly a memory debugger while QEMU has no\nsupport for it (QEMU could be used to detect out of bound memory\naccesses as Valgrind, but it has no support to track uninitialised data\nas Valgrind does). The Valgrind dynamic translator generates better code\nthan QEMU (in particular it does register allocation) but it is closely\ntied to an x86 host and target and has no support for precise exceptions\nand system emulation.\n\nEM86 [3] is the closest project to user space QEMU (and QEMU still uses\nsome of its code, in particular the ELF file loader). EM86 was limited\nto an alpha host and used a proprietary and slow interpreter (the\ninterpreter part of the FX!32 Digital Win32 code translator [4]).\n\nTWIN from Willows Software was a Windows API emulator like Wine. It is less\naccurate than Wine but includes a protected mode x86 interpreter to launch\nx86 Windows executables. Such an approach has greater potential because most\nof the Windows API is executed natively but it is far more difficult to\ndevelop because all the data structures and function parameters exchanged\nbetween the API and the x86 code must be converted.\n\nUser mode Linux [5] was the only solution before QEMU to launch a\nLinux kernel as a process while not needing any host kernel\npatches. However, user mode Linux requires heavy kernel patches while\nQEMU accepts unpatched Linux kernels. The price to pay is that QEMU is\nslower.\n\nThe Plex86 [6] PC virtualizer is done in the same spirit as the now\nobsolete qemu-fast system emulator. It requires a patched Linux kernel\nto work (you cannot launch the same kernel on your PC), but the\npatches are really small. As it is a PC virtualizer (no emulation is\ndone except for some privileged instructions), it has the potential of\nbeing faster than QEMU. The downside is that a complicated (and\npotentially unsafe) host kernel patch is needed.\n\nThe commercial PC Virtualizers (VMWare [7], VirtualPC [8]) are faster\nthan QEMU (without virtualization), but they all need specific, proprietary\nand potentially unsafe host drivers. Moreover, they are unable to\nprovide cycle exact simulation as an emulator can.\n\nVirtualBox [9], Xen [10] and KVM [11] are based on QEMU. QEMU-SystemC\n[12] uses QEMU to simulate a system where some hardware devices are\ndeveloped in SystemC.\n\n@node Bibliography\n@section Bibliography\n\n@table @asis\n\n@item [1]\n@url{http://bochs.sourceforge.net/}, the Bochs IA-32 Emulator Project,\nby Kevin Lawton et al.\n\n@item [2]\n@url{http://www.valgrind.org/}, Valgrind, an open-source memory debugger\nfor GNU/Linux.\n\n@item [3]\n@url{http://ftp.dreamtime.org/pub/linux/Linux-Alpha/em86/v0.2/docs/em86.html},\nthe EM86 x86 emulator on Alpha-Linux.\n\n@item [4]\n@url{http://www.usenix.org/publications/library/proceedings/usenix-nt97/@/full_papers/chernoff/chernoff.pdf},\nDIGITAL FX!32: Running 32-Bit x86 Applications on Alpha NT, by Anton\nChernoff and Ray Hookway.\n\n@item [5]\n@url{http://user-mode-linux.sourceforge.net/},\nThe User-mode Linux Kernel.\n\n@item [6]\n@url{http://www.plex86.org/},\nThe new Plex86 project.\n\n@item [7]\n@url{http://www.vmware.com/},\nThe VMWare PC virtualizer.\n\n@item [8]\n@url{https://www.microsoft.com/download/details.aspx?id=3702},\nThe VirtualPC PC virtualizer.\n\n@item [9]\n@url{http://virtualbox.org/},\nThe VirtualBox PC virtualizer.\n\n@item [10]\n@url{http://www.xen.org/},\nThe Xen hypervisor.\n\n@item [11]\n@url{http://www.linux-kvm.org/},\nKernel Based Virtual Machine (KVM).\n\n@item [12]\n@url{http://www.greensocs.com/projects/QEMUSystemC},\nQEMU-SystemC, a hardware co-simulator.\n\n@end table\n"
        },
        {
          "name": "qemu.nsi",
          "type": "blob",
          "size": 7.1416015625,
          "content": ";!/usr/bin/makensis\n\n; This NSIS script creates an installer for QEMU on Windows.\n\n; Copyright (C) 2006-2012 Stefan Weil\n;\n; This program is free software: you can redistribute it and/or modify\n; it under the terms of the GNU General Public License as published by\n; the Free Software Foundation, either version 2 of the License, or\n; (at your option) version 3 or any later version.\n;\n; This program is distributed in the hope that it will be useful,\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n; GNU General Public License for more details.\n;\n; You should have received a copy of the GNU General Public License\n; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n; NSIS_WIN32_MAKENSIS\n\n!define PRODUCT \"QEMU\"\n!define URL     \"http://www.qemu-project.org/\"\n\n!define UNINST_EXE \"$INSTDIR\\qemu-uninstall.exe\"\n!define UNINST_KEY \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT}\"\n\n!ifndef BINDIR\n!define BINDIR nsis.tmp\n!endif\n!ifndef SRCDIR\n!define SRCDIR .\n!endif\n!ifndef OUTFILE\n!define OUTFILE \"qemu-setup.exe\"\n!endif\n\n; Optionally install documentation.\n!ifndef CONFIG_DOCUMENTATION\n!define CONFIG_DOCUMENTATION\n!endif\n\n; Use maximum compression.\nSetCompressor /SOLID lzma\n\n!include \"MUI2.nsh\"\n\n; The name of the installer.\nName \"QEMU\"\n\n; The file to write\nOutFile \"${OUTFILE}\"\n\n; The default installation directory.\n!ifdef W64\nInstallDir $PROGRAMFILES64\\qemu\n!else\nInstallDir $PROGRAMFILES\\qemu\n!endif\n\n; Registry key to check for directory (so if you install again, it will\n; overwrite the old one automatically)\n!ifdef W64\nInstallDirRegKey HKLM \"Software\\qemu64\" \"Install_Dir\"\n!else\nInstallDirRegKey HKLM \"Software\\qemu32\" \"Install_Dir\"\n!endif\n\n; Request administrator privileges for Windows Vista.\nRequestExecutionLevel admin\n\n;--------------------------------\n; Interface Settings.\n;!define MUI_HEADERIMAGE \"qemu-nsis.bmp\"\n; !define MUI_SPECIALBITMAP \"qemu.bmp\"\n!define MUI_ICON \"${SRCDIR}\\pc-bios\\qemu-nsis.ico\"\n!define MUI_UNICON \"${SRCDIR}\\pc-bios\\qemu-nsis.ico\"\n!define MUI_WELCOMEFINISHPAGE_BITMAP \"${SRCDIR}\\pc-bios\\qemu-nsis.bmp\"\n; !define MUI_HEADERIMAGE_BITMAP \"qemu-install.bmp\"\n; !define MUI_HEADERIMAGE_UNBITMAP \"qemu-uninstall.bmp\"\n; !define MUI_COMPONENTSPAGE_SMALLDESC\n; !define MUI_WELCOMEPAGE_TEXT \"Insert text here.$\\r$\\n$\\r$\\n$\\r$\\n$_CLICK\"\n\n;--------------------------------\n; Pages.\n\n!insertmacro MUI_PAGE_WELCOME\n!insertmacro MUI_PAGE_LICENSE \"${SRCDIR}\\COPYING\"\n!insertmacro MUI_PAGE_COMPONENTS\n!insertmacro MUI_PAGE_DIRECTORY\n!insertmacro MUI_PAGE_INSTFILES\n!define MUI_FINISHPAGE_LINK \"Visit the QEMU Wiki online!\"\n!define MUI_FINISHPAGE_LINK_LOCATION \"${URL}\"\n!insertmacro MUI_PAGE_FINISH\n\n!insertmacro MUI_UNPAGE_CONFIRM\n!insertmacro MUI_UNPAGE_INSTFILES\n\n;--------------------------------\n; Languages.\n\n!insertmacro MUI_LANGUAGE \"English\"\n!insertmacro MUI_LANGUAGE \"French\"\n!insertmacro MUI_LANGUAGE \"German\"\n\n;--------------------------------\n\n; The stuff to install.\nSection \"${PRODUCT} (required)\"\n\n    SectionIn RO\n\n    ; Set output path to the installation directory.\n    SetOutPath \"$INSTDIR\"\n\n    File \"${SRCDIR}\\Changelog\"\n    File \"${SRCDIR}\\COPYING\"\n    File \"${SRCDIR}\\COPYING.LIB\"\n    File \"${SRCDIR}\\README\"\n    File \"${SRCDIR}\\VERSION\"\n\n    File \"${BINDIR}\\*.bmp\"\n    File \"${BINDIR}\\*.bin\"\n    File \"${BINDIR}\\*.dtb\"\n    File \"${BINDIR}\\*.rom\"\n    File \"${BINDIR}\\openbios-*\"\n\n    File /r \"${BINDIR}\\keymaps\"\n!ifdef CONFIG_GTK\n    File /r \"${BINDIR}\\share\"\n!endif\n\n!ifdef W64\n    SetRegView 64\n!endif\n\n    ; Write the installation path into the registry\n    WriteRegStr HKLM SOFTWARE\\${PRODUCT} \"Install_Dir\" \"$INSTDIR\"\n\n    ; Write the uninstall keys for Windows\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"DisplayName\" \"QEMU\"\n!ifdef DISPLAYVERSION\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"DisplayVersion\" \"${DISPLAYVERSION}\"\n!endif\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"UninstallString\" '\"${UNINST_EXE}\"'\n    WriteRegDWORD HKLM \"${UNINST_KEY}\" \"NoModify\" 1\n    WriteRegDWORD HKLM \"${UNINST_KEY}\" \"NoRepair\" 1\n    WriteUninstaller \"qemu-uninstall.exe\"\nSectionEnd\n\nSection \"Tools\" SectionTools\n    SetOutPath \"$INSTDIR\"\n    File \"${BINDIR}\\qemu-img.exe\"\n    File \"${BINDIR}\\qemu-io.exe\"\nSectionEnd\n\nSectionGroup \"System Emulations\" SectionSystem\n\n!include \"${BINDIR}\\system-emulations.nsh\"\n\nSectionGroupEnd\n\n!ifdef DLLDIR\nSection \"Libraries (DLL)\" SectionDll\n    SetOutPath \"$INSTDIR\"\n    File \"${DLLDIR}\\*.dll\"\nSectionEnd\n!endif\n\n!ifdef CONFIG_DOCUMENTATION\nSection \"Documentation\" SectionDoc\n    SetOutPath \"$INSTDIR\"\n    File \"${BINDIR}\\qemu-doc.html\"\n    CreateDirectory \"$SMPROGRAMS\\${PRODUCT}\"\n    CreateShortCut \"$SMPROGRAMS\\${PRODUCT}\\User Documentation.lnk\" \"$INSTDIR\\qemu-doc.html\" \"\" \"$INSTDIR\\qemu-doc.html\" 0\nSectionEnd\n!endif\n\n; Optional section (can be disabled by the user)\nSection \"Start Menu Shortcuts\" SectionMenu\n    CreateDirectory \"$SMPROGRAMS\\${PRODUCT}\"\n    CreateShortCut \"$SMPROGRAMS\\${PRODUCT}\\Uninstall.lnk\" \"${UNINST_EXE}\" \"\" \"${UNINST_EXE}\" 0\nSectionEnd\n\n;--------------------------------\n\n; Uninstaller\n\nSection \"Uninstall\"\n    ; Remove registry keys\n!ifdef W64\n    SetRegView 64\n!endif\n    DeleteRegKey HKLM \"${UNINST_KEY}\"\n    DeleteRegKey HKLM SOFTWARE\\${PRODUCT}\n\n    ; Remove shortcuts, if any\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\User Documentation.lnk\"\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\Technical Documentation.lnk\"\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\Uninstall.lnk\"\n    RMDir \"$SMPROGRAMS\\${PRODUCT}\"\n\n    ; Remove files and directories used\n    Delete \"$INSTDIR\\Changelog\"\n    Delete \"$INSTDIR\\COPYING\"\n    Delete \"$INSTDIR\\COPYING.LIB\"\n    Delete \"$INSTDIR\\README\"\n    Delete \"$INSTDIR\\VERSION\"\n    Delete \"$INSTDIR\\*.bmp\"\n    Delete \"$INSTDIR\\*.bin\"\n    Delete \"$INSTDIR\\*.dll\"\n    Delete \"$INSTDIR\\*.dtb\"\n    Delete \"$INSTDIR\\*.rom\"\n    Delete \"$INSTDIR\\openbios-*\"\n    Delete \"$INSTDIR\\qemu-img.exe\"\n    Delete \"$INSTDIR\\qemu-io.exe\"\n    Delete \"$INSTDIR\\qemu.exe\"\n    Delete \"$INSTDIR\\qemu-system-*.exe\"\n    Delete \"$INSTDIR\\qemu-doc.html\"\n    RMDir /r \"$INSTDIR\\keymaps\"\n    RMDir /r \"$INSTDIR\\share\"\n    ; Remove generated files\n    Delete \"$INSTDIR\\stderr.txt\"\n    Delete \"$INSTDIR\\stdout.txt\"\n    ; Remove uninstaller\n    Delete \"${UNINST_EXE}\"\n    RMDir \"$INSTDIR\"\nSectionEnd\n\n;--------------------------------\n\n; Descriptions (mouse-over).\n!insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionSystem}  \"System emulation.\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${Section_alpha}  \"Alpha system emulation.\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${Section_alphaw} \"Alpha system emulation (GUI).\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${Section_i386}   \"PC i386 system emulation.\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${Section_i386w}  \"PC i386 system emulation (GUI).\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionTools} \"Tools.\"\n!ifdef DLLDIR\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionDll}   \"Runtime Libraries (DLL).\"\n!endif\n!ifdef CONFIG_DOCUMENTATION\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionDoc}   \"Documentation.\"\n!endif\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionMenu}  \"Menu entries.\"\n!insertmacro MUI_FUNCTION_DESCRIPTION_END\n\n;--------------------------------\n; Functions.\n\nFunction .onInit\n    !insertmacro MUI_LANGDLL_DISPLAY\nFunctionEnd\n"
        },
        {
          "name": "qemu.sasl",
          "type": "blob",
          "size": 1.33203125,
          "content": "# If you want to use the non-TLS socket, then you *must* include\n# the GSSAPI or DIGEST-MD5 mechanisms, because they are the only\n# ones that can offer session encryption as well as authentication.\n#\n# If you're only using TLS, then you can turn on any mechanisms\n# you like for authentication, because TLS provides the encryption\n#\n# Default to a simple username+password mechanism\n# NB digest-md5 is no longer considered secure by current standards\nmech_list: digest-md5\n\n# Before you can use GSSAPI, you need a service principle on the\n# KDC server for libvirt, and that to be exported to the keytab\n# file listed below\n#mech_list: gssapi\n#\n# You can also list many mechanisms at once, then the user can choose\n# by adding  '?auth=sasl.gssapi' to their libvirt URI, eg\n#   qemu+tcp://hostname/system?auth=sasl.gssapi\n#mech_list: digest-md5 gssapi\n\n# Some older builds of MIT kerberos on Linux ignore this option &\n# instead need KRB5_KTNAME env var.\n# For modern Linux, and other OS, this should be sufficient\n#\n# There is no default value here, uncomment if you need this\n#keytab: /etc/qemu/krb5.tab\n\n# If using digest-md5 for username/passwds, then this is the file\n# containing the passwds. Use 'saslpasswd2 -a qemu [username]'\n# to add entries, and 'sasldblistusers2 -f [sasldb_path]' to browse it\nsasldb_path: /etc/qemu/passwd.db\n\n\nauxprop_plugin: sasldb\n\n"
        },
        {
          "name": "qga",
          "type": "tree",
          "content": null
        },
        {
          "name": "qmp.c",
          "type": "blob",
          "size": 19.2880859375,
          "content": "/*\n * QEMU Management Protocol\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n *  Anthony Liguori   <aliguori@us.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-version.h\"\n#include \"qemu/cutils.h\"\n#include \"monitor/monitor.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/uuid.h\"\n#include \"qmp-commands.h\"\n#include \"sysemu/char.h\"\n#include \"ui/qemu-spice.h\"\n#include \"ui/vnc.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/arch_init.h\"\n#include \"hw/qdev.h\"\n#include \"sysemu/blockdev.h\"\n#include \"sysemu/block-backend.h\"\n#include \"qom/qom-qobject.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qobject.h\"\n#include \"qapi/qobject-input-visitor.h\"\n#include \"hw/boards.h\"\n#include \"qom/object_interfaces.h\"\n#include \"hw/mem/pc-dimm.h\"\n#include \"hw/acpi/acpi_dev_interface.h\"\n\nNameInfo *qmp_query_name(Error **errp)\n{\n    NameInfo *info = g_malloc0(sizeof(*info));\n\n    if (qemu_name) {\n        info->has_name = true;\n        info->name = g_strdup(qemu_name);\n    }\n\n    return info;\n}\n\nVersionInfo *qmp_query_version(Error **errp)\n{\n    VersionInfo *info = g_new0(VersionInfo, 1);\n\n    info->qemu = g_new0(VersionTriple, 1);\n    info->qemu->major = QEMU_VERSION_MAJOR;\n    info->qemu->minor = QEMU_VERSION_MINOR;\n    info->qemu->micro = QEMU_VERSION_MICRO;\n    info->package = g_strdup(QEMU_PKGVERSION);\n\n    return info;\n}\n\nKvmInfo *qmp_query_kvm(Error **errp)\n{\n    KvmInfo *info = g_malloc0(sizeof(*info));\n\n    info->enabled = kvm_enabled();\n    info->present = kvm_available();\n\n    return info;\n}\n\nUuidInfo *qmp_query_uuid(Error **errp)\n{\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    info->UUID = qemu_uuid_unparse_strdup(&qemu_uuid);\n    return info;\n}\n\nvoid qmp_quit(Error **errp)\n{\n    no_shutdown = 0;\n    qemu_system_shutdown_request();\n}\n\nvoid qmp_stop(Error **errp)\n{\n    /* if there is a dump in background, we should wait until the dump\n     * finished */\n    if (dump_in_progress()) {\n        error_setg(errp, \"There is a dump in process, please wait.\");\n        return;\n    }\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        autostart = 0;\n    } else {\n        vm_stop(RUN_STATE_PAUSED);\n    }\n}\n\nvoid qmp_system_reset(Error **errp)\n{\n    qemu_system_reset_request();\n}\n\nvoid qmp_system_powerdown(Error **erp)\n{\n    qemu_system_powerdown_request();\n}\n\nvoid qmp_cpu(int64_t index, Error **errp)\n{\n    /* Just do nothing */\n}\n\nvoid qmp_cpu_add(int64_t id, Error **errp)\n{\n    MachineClass *mc;\n\n    mc = MACHINE_GET_CLASS(current_machine);\n    if (mc->hot_add_cpu) {\n        mc->hot_add_cpu(id, errp);\n    } else {\n        error_setg(errp, \"Not supported\");\n    }\n}\n\n#ifndef CONFIG_VNC\n/* If VNC support is enabled, the \"true\" query-vnc command is\n   defined in the VNC subsystem */\nVncInfo *qmp_query_vnc(Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"vnc\");\n    return NULL;\n};\n\nVncInfo2List *qmp_query_vnc_servers(Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"vnc\");\n    return NULL;\n};\n#endif\n\n#ifndef CONFIG_SPICE\n/*\n * qmp-commands.hx ensures that QMP command query-spice exists only\n * #ifdef CONFIG_SPICE.  Necessary for an accurate query-commands\n * result.  However, the QAPI schema is blissfully unaware of that,\n * and the QAPI code generator happily generates a dead\n * qmp_marshal_query_spice() that calls qmp_query_spice().  Provide it\n * one, or else linking fails.  FIXME Educate the QAPI schema on\n * CONFIG_SPICE.\n */\nSpiceInfo *qmp_query_spice(Error **errp)\n{\n    abort();\n};\n#endif\n\nvoid qmp_cont(Error **errp)\n{\n    Error *local_err = NULL;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    /* if there is a dump in background, we should wait until the dump\n     * finished */\n    if (dump_in_progress()) {\n        error_setg(errp, \"There is a dump in process, please wait.\");\n        return;\n    }\n\n    if (runstate_needs_reset()) {\n        error_setg(errp, \"Resetting the Virtual Machine is required\");\n        return;\n    } else if (runstate_check(RUN_STATE_SUSPENDED)) {\n        return;\n    }\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        blk_iostatus_reset(blk);\n    }\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        bdrv_add_key(bs, NULL, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n\n    /* Continuing after completed migration. Images have been inactivated to\n     * allow the destination to take control. Need to get control back now. */\n    if (runstate_check(RUN_STATE_FINISH_MIGRATE) ||\n        runstate_check(RUN_STATE_POSTMIGRATE))\n    {\n        bdrv_invalidate_cache_all(&local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n\n    blk_resume_after_migration(&local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        autostart = 1;\n    } else {\n        vm_start();\n    }\n}\n\nvoid qmp_system_wakeup(Error **errp)\n{\n    qemu_system_wakeup_request(QEMU_WAKEUP_REASON_OTHER);\n}\n\nObjectPropertyInfoList *qmp_qom_list(const char *path, Error **errp)\n{\n    Object *obj;\n    bool ambiguous = false;\n    ObjectPropertyInfoList *props = NULL;\n    ObjectProperty *prop;\n    ObjectPropertyIterator iter;\n\n    obj = object_resolve_path(path, &ambiguous);\n    if (obj == NULL) {\n        if (ambiguous) {\n            error_setg(errp, \"Path '%s' is ambiguous\", path);\n        } else {\n            error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                      \"Device '%s' not found\", path);\n        }\n        return NULL;\n    }\n\n    object_property_iter_init(&iter, obj);\n    while ((prop = object_property_iter_next(&iter))) {\n        ObjectPropertyInfoList *entry = g_malloc0(sizeof(*entry));\n\n        entry->value = g_malloc0(sizeof(ObjectPropertyInfo));\n        entry->next = props;\n        props = entry;\n\n        entry->value->name = g_strdup(prop->name);\n        entry->value->type = g_strdup(prop->type);\n    }\n\n    return props;\n}\n\nvoid qmp_qom_set(const char *path, const char *property, QObject *value,\n                 Error **errp)\n{\n    Object *obj;\n\n    obj = object_resolve_path(path, NULL);\n    if (!obj) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", path);\n        return;\n    }\n\n    object_property_set_qobject(obj, value, property, errp);\n}\n\nQObject *qmp_qom_get(const char *path, const char *property, Error **errp)\n{\n    Object *obj;\n\n    obj = object_resolve_path(path, NULL);\n    if (!obj) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", path);\n        return NULL;\n    }\n\n    return object_property_get_qobject(obj, property, errp);\n}\n\nvoid qmp_set_password(const char *protocol, const char *password,\n                      bool has_connected, const char *connected, Error **errp)\n{\n    int disconnect_if_connected = 0;\n    int fail_if_connected = 0;\n    int rc;\n\n    if (has_connected) {\n        if (strcmp(connected, \"fail\") == 0) {\n            fail_if_connected = 1;\n        } else if (strcmp(connected, \"disconnect\") == 0) {\n            disconnect_if_connected = 1;\n        } else if (strcmp(connected, \"keep\") == 0) {\n            /* nothing */\n        } else {\n            error_setg(errp, QERR_INVALID_PARAMETER, \"connected\");\n            return;\n        }\n    }\n\n    if (strcmp(protocol, \"spice\") == 0) {\n        if (!qemu_using_spice(errp)) {\n            return;\n        }\n        rc = qemu_spice_set_passwd(password, fail_if_connected,\n                                   disconnect_if_connected);\n        if (rc != 0) {\n            error_setg(errp, QERR_SET_PASSWD_FAILED);\n        }\n        return;\n    }\n\n    if (strcmp(protocol, \"vnc\") == 0) {\n        if (fail_if_connected || disconnect_if_connected) {\n            /* vnc supports \"connected=keep\" only */\n            error_setg(errp, QERR_INVALID_PARAMETER, \"connected\");\n            return;\n        }\n        /* Note that setting an empty password will not disable login through\n         * this interface. */\n        rc = vnc_display_password(NULL, password);\n        if (rc < 0) {\n            error_setg(errp, QERR_SET_PASSWD_FAILED);\n        }\n        return;\n    }\n\n    error_setg(errp, QERR_INVALID_PARAMETER, \"protocol\");\n}\n\nvoid qmp_expire_password(const char *protocol, const char *whenstr,\n                         Error **errp)\n{\n    time_t when;\n    int rc;\n\n    if (strcmp(whenstr, \"now\") == 0) {\n        when = 0;\n    } else if (strcmp(whenstr, \"never\") == 0) {\n        when = TIME_MAX;\n    } else if (whenstr[0] == '+') {\n        when = time(NULL) + strtoull(whenstr+1, NULL, 10);\n    } else {\n        when = strtoull(whenstr, NULL, 10);\n    }\n\n    if (strcmp(protocol, \"spice\") == 0) {\n        if (!qemu_using_spice(errp)) {\n            return;\n        }\n        rc = qemu_spice_set_pw_expire(when);\n        if (rc != 0) {\n            error_setg(errp, QERR_SET_PASSWD_FAILED);\n        }\n        return;\n    }\n\n    if (strcmp(protocol, \"vnc\") == 0) {\n        rc = vnc_display_pw_expire(NULL, when);\n        if (rc != 0) {\n            error_setg(errp, QERR_SET_PASSWD_FAILED);\n        }\n        return;\n    }\n\n    error_setg(errp, QERR_INVALID_PARAMETER, \"protocol\");\n}\n\n#ifdef CONFIG_VNC\nvoid qmp_change_vnc_password(const char *password, Error **errp)\n{\n    if (vnc_display_password(NULL, password) < 0) {\n        error_setg(errp, QERR_SET_PASSWD_FAILED);\n    }\n}\n\nstatic void qmp_change_vnc_listen(const char *target, Error **errp)\n{\n    QemuOptsList *olist = qemu_find_opts(\"vnc\");\n    QemuOpts *opts;\n\n    if (strstr(target, \"id=\")) {\n        error_setg(errp, \"id not supported\");\n        return;\n    }\n\n    opts = qemu_opts_find(olist, \"default\");\n    if (opts) {\n        qemu_opts_del(opts);\n    }\n    opts = vnc_parse(target, errp);\n    if (!opts) {\n        return;\n    }\n\n    vnc_display_open(\"default\", errp);\n}\n\nstatic void qmp_change_vnc(const char *target, bool has_arg, const char *arg,\n                           Error **errp)\n{\n    if (strcmp(target, \"passwd\") == 0 || strcmp(target, \"password\") == 0) {\n        if (!has_arg) {\n            error_setg(errp, QERR_MISSING_PARAMETER, \"password\");\n        } else {\n            qmp_change_vnc_password(arg, errp);\n        }\n    } else {\n        qmp_change_vnc_listen(target, errp);\n    }\n}\n#else\nvoid qmp_change_vnc_password(const char *password, Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"vnc\");\n}\nstatic void qmp_change_vnc(const char *target, bool has_arg, const char *arg,\n                           Error **errp)\n{\n    error_setg(errp, QERR_FEATURE_DISABLED, \"vnc\");\n}\n#endif /* !CONFIG_VNC */\n\nvoid qmp_change(const char *device, const char *target,\n                bool has_arg, const char *arg, Error **errp)\n{\n    if (strcmp(device, \"vnc\") == 0) {\n        qmp_change_vnc(target, has_arg, arg, errp);\n    } else {\n        qmp_blockdev_change_medium(true, device, false, NULL, target,\n                                   has_arg, arg, false, 0, errp);\n    }\n}\n\nstatic void qom_list_types_tramp(ObjectClass *klass, void *data)\n{\n    ObjectTypeInfoList *e, **pret = data;\n    ObjectTypeInfo *info;\n\n    info = g_malloc0(sizeof(*info));\n    info->name = g_strdup(object_class_get_name(klass));\n\n    e = g_malloc0(sizeof(*e));\n    e->value = info;\n    e->next = *pret;\n    *pret = e;\n}\n\nObjectTypeInfoList *qmp_qom_list_types(bool has_implements,\n                                       const char *implements,\n                                       bool has_abstract,\n                                       bool abstract,\n                                       Error **errp)\n{\n    ObjectTypeInfoList *ret = NULL;\n\n    object_class_foreach(qom_list_types_tramp, implements, abstract, &ret);\n\n    return ret;\n}\n\n/* Return a DevicePropertyInfo for a qdev property.\n *\n * If a qdev property with the given name does not exist, use the given default\n * type.  If the qdev property info should not be shown, return NULL.\n *\n * The caller must free the return value.\n */\nstatic DevicePropertyInfo *make_device_property_info(ObjectClass *klass,\n                                                     const char *name,\n                                                     const char *default_type,\n                                                     const char *description)\n{\n    DevicePropertyInfo *info;\n    Property *prop;\n\n    do {\n        for (prop = DEVICE_CLASS(klass)->props; prop && prop->name; prop++) {\n            if (strcmp(name, prop->name) != 0) {\n                continue;\n            }\n\n            /*\n             * TODO Properties without a parser are just for dirty hacks.\n             * qdev_prop_ptr is the only such PropertyInfo.  It's marked\n             * for removal.  This conditional should be removed along with\n             * it.\n             */\n            if (!prop->info->set) {\n                return NULL;           /* no way to set it, don't show */\n            }\n\n            info = g_malloc0(sizeof(*info));\n            info->name = g_strdup(prop->name);\n            info->type = g_strdup(prop->info->name);\n            info->has_description = !!prop->info->description;\n            info->description = g_strdup(prop->info->description);\n            return info;\n        }\n        klass = object_class_get_parent(klass);\n    } while (klass != object_class_by_name(TYPE_DEVICE));\n\n    /* Not a qdev property, use the default type */\n    info = g_malloc0(sizeof(*info));\n    info->name = g_strdup(name);\n    info->type = g_strdup(default_type);\n    info->has_description = !!description;\n    info->description = g_strdup(description);\n\n    return info;\n}\n\nDevicePropertyInfoList *qmp_device_list_properties(const char *typename,\n                                                   Error **errp)\n{\n    ObjectClass *klass;\n    Object *obj;\n    ObjectProperty *prop;\n    ObjectPropertyIterator iter;\n    DevicePropertyInfoList *prop_list = NULL;\n\n    klass = object_class_by_name(typename);\n    if (klass == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", typename);\n        return NULL;\n    }\n\n    klass = object_class_dynamic_cast(klass, TYPE_DEVICE);\n    if (klass == NULL) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"typename\", TYPE_DEVICE);\n        return NULL;\n    }\n\n    if (object_class_is_abstract(klass)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"typename\",\n                   \"non-abstract device type\");\n        return NULL;\n    }\n\n    if (DEVICE_CLASS(klass)->cannot_destroy_with_object_finalize_yet) {\n        error_setg(errp, \"Can't list properties of device '%s'\", typename);\n        return NULL;\n    }\n\n    obj = object_new(typename);\n\n    object_property_iter_init(&iter, obj);\n    while ((prop = object_property_iter_next(&iter))) {\n        DevicePropertyInfo *info;\n        DevicePropertyInfoList *entry;\n\n        /* Skip Object and DeviceState properties */\n        if (strcmp(prop->name, \"type\") == 0 ||\n            strcmp(prop->name, \"realized\") == 0 ||\n            strcmp(prop->name, \"hotpluggable\") == 0 ||\n            strcmp(prop->name, \"hotplugged\") == 0 ||\n            strcmp(prop->name, \"parent_bus\") == 0) {\n            continue;\n        }\n\n        /* Skip legacy properties since they are just string versions of\n         * properties that we already list.\n         */\n        if (strstart(prop->name, \"legacy-\", NULL)) {\n            continue;\n        }\n\n        info = make_device_property_info(klass, prop->name, prop->type,\n                                         prop->description);\n        if (!info) {\n            continue;\n        }\n\n        entry = g_malloc0(sizeof(*entry));\n        entry->value = info;\n        entry->next = prop_list;\n        prop_list = entry;\n    }\n\n    object_unref(obj);\n\n    return prop_list;\n}\n\nCpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)\n{\n    return arch_query_cpu_definitions(errp);\n}\n\nCpuModelExpansionInfo *qmp_query_cpu_model_expansion(CpuModelExpansionType type,\n                                                     CpuModelInfo *model,\n                                                     Error **errp)\n{\n    return arch_query_cpu_model_expansion(type, model, errp);\n}\n\nCpuModelCompareInfo *qmp_query_cpu_model_comparison(CpuModelInfo *modela,\n                                                    CpuModelInfo *modelb,\n                                                    Error **errp)\n{\n    return arch_query_cpu_model_comparison(modela, modelb, errp);\n}\n\nCpuModelBaselineInfo *qmp_query_cpu_model_baseline(CpuModelInfo *modela,\n                                                   CpuModelInfo *modelb,\n                                                   Error **errp)\n{\n    return arch_query_cpu_model_baseline(modela, modelb, errp);\n}\n\nvoid qmp_add_client(const char *protocol, const char *fdname,\n                    bool has_skipauth, bool skipauth, bool has_tls, bool tls,\n                    Error **errp)\n{\n    Chardev *s;\n    int fd;\n\n    fd = monitor_get_fd(cur_mon, fdname, errp);\n    if (fd < 0) {\n        return;\n    }\n\n    if (strcmp(protocol, \"spice\") == 0) {\n        if (!qemu_using_spice(errp)) {\n            close(fd);\n            return;\n        }\n        skipauth = has_skipauth ? skipauth : false;\n        tls = has_tls ? tls : false;\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n            error_setg(errp, \"spice failed to add client\");\n            close(fd);\n        }\n        return;\n#ifdef CONFIG_VNC\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n        skipauth = has_skipauth ? skipauth : false;\n        vnc_display_add_client(NULL, fd, skipauth);\n        return;\n#endif\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n        if (qemu_chr_add_client(s, fd) < 0) {\n            error_setg(errp, \"failed to add client\");\n            close(fd);\n            return;\n        }\n        return;\n    }\n\n    error_setg(errp, \"protocol '%s' is invalid\", protocol);\n    close(fd);\n}\n\n\nvoid qmp_object_add(const char *type, const char *id,\n                    bool has_props, QObject *props, Error **errp)\n{\n    QDict *pdict;\n    Visitor *v;\n    Object *obj;\n\n    if (props) {\n        pdict = qobject_to_qdict(props);\n        if (!pdict) {\n            error_setg(errp, QERR_INVALID_PARAMETER_TYPE, \"props\", \"dict\");\n            return;\n        }\n        QINCREF(pdict);\n    } else {\n        pdict = qdict_new();\n    }\n\n    v = qobject_input_visitor_new(QOBJECT(pdict));\n    obj = user_creatable_add_type(type, id, pdict, v, errp);\n    visit_free(v);\n    if (obj) {\n        object_unref(obj);\n    }\n    QDECREF(pdict);\n}\n\nvoid qmp_object_del(const char *id, Error **errp)\n{\n    user_creatable_del(id, errp);\n}\n\nMemoryDeviceInfoList *qmp_query_memory_devices(Error **errp)\n{\n    MemoryDeviceInfoList *head = NULL;\n    MemoryDeviceInfoList **prev = &head;\n\n    qmp_pc_dimm_device_list(qdev_get_machine(), &prev);\n\n    return head;\n}\n\nACPIOSTInfoList *qmp_query_acpi_ospm_status(Error **errp)\n{\n    bool ambig;\n    ACPIOSTInfoList *head = NULL;\n    ACPIOSTInfoList **prev = &head;\n    Object *obj = object_resolve_path_type(\"\", TYPE_ACPI_DEVICE_IF, &ambig);\n\n    if (obj) {\n        AcpiDeviceIfClass *adevc = ACPI_DEVICE_IF_GET_CLASS(obj);\n        AcpiDeviceIf *adev = ACPI_DEVICE_IF(obj);\n\n        adevc->ospm_status(adev, &prev);\n    } else {\n        error_setg(errp, \"command is not supported, missing ACPI device\");\n    }\n\n    return head;\n}\n"
        },
        {
          "name": "qobject",
          "type": "tree",
          "content": null
        },
        {
          "name": "qom",
          "type": "tree",
          "content": null
        },
        {
          "name": "qtest.c",
          "type": "blob",
          "size": 19.6064453125,
          "content": "/*\n * Test Server\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n *  Anthony Liguori   <aliguori@us.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu-common.h\"\n#include \"cpu.h\"\n#include \"sysemu/qtest.h\"\n#include \"hw/qdev.h\"\n#include \"sysemu/char.h\"\n#include \"exec/ioport.h\"\n#include \"exec/memory.h\"\n#include \"hw/irq.h\"\n#include \"sysemu/accel.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/cpus.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/option.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/cutils.h\"\n#ifdef TARGET_PPC64\n#include \"hw/ppc/spapr_rtas.h\"\n#endif\n\n#define MAX_IRQ 256\n\nbool qtest_allowed;\n\nstatic DeviceState *irq_intercept_dev;\nstatic FILE *qtest_log_fp;\nstatic CharBackend qtest_chr;\nstatic GString *inbuf;\nstatic int irq_levels[MAX_IRQ];\nstatic qemu_timeval start_time;\nstatic bool qtest_opened;\n\n#define FMT_timeval \"%ld.%06ld\"\n\n/**\n * QTest Protocol\n *\n * Line based protocol, request/response based.  Server can send async messages\n * so clients should always handle many async messages before the response\n * comes in.\n *\n * Valid requests\n *\n * Clock management:\n *\n * The qtest client is completely in charge of the QEMU_CLOCK_VIRTUAL.  qtest commands\n * let you adjust the value of the clock (monotonically).  All the commands\n * return the current value of the clock in nanoseconds.\n *\n *  > clock_step\n *  < OK VALUE\n *\n *     Advance the clock to the next deadline.  Useful when waiting for\n *     asynchronous events.\n *\n *  > clock_step NS\n *  < OK VALUE\n *\n *     Advance the clock by NS nanoseconds.\n *\n *  > clock_set NS\n *  < OK VALUE\n *\n *     Advance the clock to NS nanoseconds (do nothing if it's already past).\n *\n * PIO and memory access:\n *\n *  > outb ADDR VALUE\n *  < OK\n *\n *  > outw ADDR VALUE\n *  < OK\n *\n *  > outl ADDR VALUE\n *  < OK\n *\n *  > inb ADDR\n *  < OK VALUE\n *\n *  > inw ADDR\n *  < OK VALUE\n *\n *  > inl ADDR\n *  < OK VALUE\n *\n *  > writeb ADDR VALUE\n *  < OK\n *\n *  > writew ADDR VALUE\n *  < OK\n *\n *  > writel ADDR VALUE\n *  < OK\n *\n *  > writeq ADDR VALUE\n *  < OK\n *\n *  > readb ADDR\n *  < OK VALUE\n *\n *  > readw ADDR\n *  < OK VALUE\n *\n *  > readl ADDR\n *  < OK VALUE\n *\n *  > readq ADDR\n *  < OK VALUE\n *\n *  > read ADDR SIZE\n *  < OK DATA\n *\n *  > write ADDR SIZE DATA\n *  < OK\n *\n *  > b64read ADDR SIZE\n *  < OK B64_DATA\n *\n *  > b64write ADDR SIZE B64_DATA\n *  < OK\n *\n *  > memset ADDR SIZE VALUE\n *  < OK\n *\n * ADDR, SIZE, VALUE are all integers parsed with strtoul() with a base of 0.\n * For 'memset' a zero size is permitted and does nothing.\n *\n * DATA is an arbitrarily long hex number prefixed with '0x'.  If it's smaller\n * than the expected size, the value will be zero filled at the end of the data\n * sequence.\n *\n * B64_DATA is an arbitrarily long base64 encoded string.\n * If the sizes do not match, the data will be truncated.\n *\n * IRQ management:\n *\n *  > irq_intercept_in QOM-PATH\n *  < OK\n *\n *  > irq_intercept_out QOM-PATH\n *  < OK\n *\n * Attach to the gpio-in (resp. gpio-out) pins exported by the device at\n * QOM-PATH.  When the pin is triggered, one of the following async messages\n * will be printed to the qtest stream:\n *\n *  IRQ raise NUM\n *  IRQ lower NUM\n *\n * where NUM is an IRQ number.  For the PC, interrupts can be intercepted\n * simply with \"irq_intercept_in ioapic\" (note that IRQ0 comes out with\n * NUM=0 even though it is remapped to GSI 2).\n */\n\nstatic int hex2nib(char ch)\n{\n    if (ch >= '0' && ch <= '9') {\n        return ch - '0';\n    } else if (ch >= 'a' && ch <= 'f') {\n        return 10 + (ch - 'a');\n    } else if (ch >= 'A' && ch <= 'F') {\n        return 10 + (ch - 'A');\n    } else {\n        return -1;\n    }\n}\n\nstatic void qtest_get_time(qemu_timeval *tv)\n{\n    qemu_gettimeofday(tv);\n    tv->tv_sec -= start_time.tv_sec;\n    tv->tv_usec -= start_time.tv_usec;\n    if (tv->tv_usec < 0) {\n        tv->tv_usec += 1000000;\n        tv->tv_sec -= 1;\n    }\n}\n\nstatic void qtest_send_prefix(CharBackend *chr)\n{\n    qemu_timeval tv;\n\n    if (!qtest_log_fp || !qtest_opened) {\n        return;\n    }\n\n    qtest_get_time(&tv);\n    fprintf(qtest_log_fp, \"[S +\" FMT_timeval \"] \",\n            (long) tv.tv_sec, (long) tv.tv_usec);\n}\n\nstatic void GCC_FMT_ATTR(1, 2) qtest_log_send(const char *fmt, ...)\n{\n    va_list ap;\n\n    if (!qtest_log_fp || !qtest_opened) {\n        return;\n    }\n\n    qtest_send_prefix(NULL);\n\n    va_start(ap, fmt);\n    vfprintf(qtest_log_fp, fmt, ap);\n    va_end(ap);\n}\n\nstatic void do_qtest_send(CharBackend *chr, const char *str, size_t len)\n{\n    qemu_chr_fe_write_all(chr, (uint8_t *)str, len);\n    if (qtest_log_fp && qtest_opened) {\n        fprintf(qtest_log_fp, \"%s\", str);\n    }\n}\n\nstatic void qtest_send(CharBackend *chr, const char *str)\n{\n    do_qtest_send(chr, str, strlen(str));\n}\n\nstatic void GCC_FMT_ATTR(2, 3) qtest_sendf(CharBackend *chr,\n                                           const char *fmt, ...)\n{\n    va_list ap;\n    gchar *buffer;\n\n    va_start(ap, fmt);\n    buffer = g_strdup_vprintf(fmt, ap);\n    qtest_send(chr, buffer);\n    g_free(buffer);\n    va_end(ap);\n}\n\nstatic void qtest_irq_handler(void *opaque, int n, int level)\n{\n    qemu_irq old_irq = *(qemu_irq *)opaque;\n    qemu_set_irq(old_irq, level);\n\n    if (irq_levels[n] != level) {\n        CharBackend *chr = &qtest_chr;\n        irq_levels[n] = level;\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"IRQ %s %d\\n\",\n                    level ? \"raise\" : \"lower\", n);\n    }\n}\n\nstatic void qtest_process_command(CharBackend *chr, gchar **words)\n{\n    const gchar *command;\n\n    g_assert(words);\n\n    command = words[0];\n\n    if (qtest_log_fp) {\n        qemu_timeval tv;\n        int i;\n\n        qtest_get_time(&tv);\n        fprintf(qtest_log_fp, \"[R +\" FMT_timeval \"]\",\n                (long) tv.tv_sec, (long) tv.tv_usec);\n        for (i = 0; words[i]; i++) {\n            fprintf(qtest_log_fp, \" %s\", words[i]);\n        }\n        fprintf(qtest_log_fp, \"\\n\");\n    }\n\n    g_assert(command);\n    if (strcmp(words[0], \"irq_intercept_out\") == 0\n        || strcmp(words[0], \"irq_intercept_in\") == 0) {\n        DeviceState *dev;\n        NamedGPIOList *ngl;\n\n        g_assert(words[1]);\n        dev = DEVICE(object_resolve_path(words[1], NULL));\n        if (!dev) {\n            qtest_send_prefix(chr);\n            qtest_send(chr, \"FAIL Unknown device\\n\");\n\t    return;\n        }\n\n        if (irq_intercept_dev) {\n            qtest_send_prefix(chr);\n            if (irq_intercept_dev != dev) {\n                qtest_send(chr, \"FAIL IRQ intercept already enabled\\n\");\n            } else {\n                qtest_send(chr, \"OK\\n\");\n            }\n\t    return;\n        }\n\n        QLIST_FOREACH(ngl, &dev->gpios, node) {\n            /* We don't support intercept of named GPIOs yet */\n            if (ngl->name) {\n                continue;\n            }\n            if (words[0][14] == 'o') {\n                int i;\n                for (i = 0; i < ngl->num_out; ++i) {\n                    qemu_irq *disconnected = g_new0(qemu_irq, 1);\n                    qemu_irq icpt = qemu_allocate_irq(qtest_irq_handler,\n                                                      disconnected, i);\n\n                    *disconnected = qdev_intercept_gpio_out(dev, icpt,\n                                                            ngl->name, i);\n                }\n            } else {\n                qemu_irq_intercept_in(ngl->in, qtest_irq_handler,\n                                      ngl->num_in);\n            }\n        }\n        irq_intercept_dev = dev;\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n\n    } else if (strcmp(words[0], \"outb\") == 0 ||\n               strcmp(words[0], \"outw\") == 0 ||\n               strcmp(words[0], \"outl\") == 0) {\n        unsigned long addr;\n        unsigned long value;\n\n        g_assert(words[1] && words[2]);\n        g_assert(qemu_strtoul(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtoul(words[2], NULL, 0, &value) == 0);\n        g_assert(addr <= 0xffff);\n\n        if (words[0][3] == 'b') {\n            cpu_outb(addr, value);\n        } else if (words[0][3] == 'w') {\n            cpu_outw(addr, value);\n        } else if (words[0][3] == 'l') {\n            cpu_outl(addr, value);\n        }\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n    } else if (strcmp(words[0], \"inb\") == 0 ||\n        strcmp(words[0], \"inw\") == 0 ||\n        strcmp(words[0], \"inl\") == 0) {\n        unsigned long addr;\n        uint32_t value = -1U;\n\n        g_assert(words[1]);\n        g_assert(qemu_strtoul(words[1], NULL, 0, &addr) == 0);\n        g_assert(addr <= 0xffff);\n\n        if (words[0][2] == 'b') {\n            value = cpu_inb(addr);\n        } else if (words[0][2] == 'w') {\n            value = cpu_inw(addr);\n        } else if (words[0][2] == 'l') {\n            value = cpu_inl(addr);\n        }\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK 0x%04x\\n\", value);\n    } else if (strcmp(words[0], \"writeb\") == 0 ||\n               strcmp(words[0], \"writew\") == 0 ||\n               strcmp(words[0], \"writel\") == 0 ||\n               strcmp(words[0], \"writeq\") == 0) {\n        uint64_t addr;\n        uint64_t value;\n\n        g_assert(words[1] && words[2]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &value) == 0);\n\n        if (words[0][5] == 'b') {\n            uint8_t data = value;\n            cpu_physical_memory_write(addr, &data, 1);\n        } else if (words[0][5] == 'w') {\n            uint16_t data = value;\n            tswap16s(&data);\n            cpu_physical_memory_write(addr, &data, 2);\n        } else if (words[0][5] == 'l') {\n            uint32_t data = value;\n            tswap32s(&data);\n            cpu_physical_memory_write(addr, &data, 4);\n        } else if (words[0][5] == 'q') {\n            uint64_t data = value;\n            tswap64s(&data);\n            cpu_physical_memory_write(addr, &data, 8);\n        }\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n    } else if (strcmp(words[0], \"readb\") == 0 ||\n               strcmp(words[0], \"readw\") == 0 ||\n               strcmp(words[0], \"readl\") == 0 ||\n               strcmp(words[0], \"readq\") == 0) {\n        uint64_t addr;\n        uint64_t value = UINT64_C(-1);\n\n        g_assert(words[1]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n\n        if (words[0][4] == 'b') {\n            uint8_t data;\n            cpu_physical_memory_read(addr, &data, 1);\n            value = data;\n        } else if (words[0][4] == 'w') {\n            uint16_t data;\n            cpu_physical_memory_read(addr, &data, 2);\n            value = tswap16(data);\n        } else if (words[0][4] == 'l') {\n            uint32_t data;\n            cpu_physical_memory_read(addr, &data, 4);\n            value = tswap32(data);\n        } else if (words[0][4] == 'q') {\n            cpu_physical_memory_read(addr, &value, 8);\n            tswap64s(&value);\n        }\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK 0x%016\" PRIx64 \"\\n\", value);\n    } else if (strcmp(words[0], \"read\") == 0) {\n        uint64_t addr, len, i;\n        uint8_t *data;\n        char *enc;\n\n        g_assert(words[1] && words[2]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &len) == 0);\n        /* We'd send garbage to libqtest if len is 0 */\n        g_assert(len);\n\n        data = g_malloc(len);\n        cpu_physical_memory_read(addr, data, len);\n\n        enc = g_malloc(2 * len + 1);\n        for (i = 0; i < len; i++) {\n            sprintf(&enc[i * 2], \"%02x\", data[i]);\n        }\n\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK 0x%s\\n\", enc);\n\n        g_free(data);\n        g_free(enc);\n    } else if (strcmp(words[0], \"b64read\") == 0) {\n        uint64_t addr, len;\n        uint8_t *data;\n        gchar *b64_data;\n\n        g_assert(words[1] && words[2]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &len) == 0);\n\n        data = g_malloc(len);\n        cpu_physical_memory_read(addr, data, len);\n        b64_data = g_base64_encode(data, len);\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK %s\\n\", b64_data);\n\n        g_free(data);\n        g_free(b64_data);\n    } else if (strcmp(words[0], \"write\") == 0) {\n        uint64_t addr, len, i;\n        uint8_t *data;\n        size_t data_len;\n\n        g_assert(words[1] && words[2] && words[3]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &len) == 0);\n\n        data_len = strlen(words[3]);\n        if (data_len < 3) {\n            qtest_send(chr, \"ERR invalid argument size\\n\");\n            return;\n        }\n\n        data = g_malloc(len);\n        for (i = 0; i < len; i++) {\n            if ((i * 2 + 4) <= data_len) {\n                data[i] = hex2nib(words[3][i * 2 + 2]) << 4;\n                data[i] |= hex2nib(words[3][i * 2 + 3]);\n            } else {\n                data[i] = 0;\n            }\n        }\n        cpu_physical_memory_write(addr, data, len);\n        g_free(data);\n\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n    } else if (strcmp(words[0], \"memset\") == 0) {\n        uint64_t addr, len;\n        uint8_t *data;\n        unsigned long pattern;\n\n        g_assert(words[1] && words[2] && words[3]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &len) == 0);\n        g_assert(qemu_strtoul(words[3], NULL, 0, &pattern) == 0);\n\n        if (len) {\n            data = g_malloc(len);\n            memset(data, pattern, len);\n            cpu_physical_memory_write(addr, data, len);\n            g_free(data);\n        }\n\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n    }  else if (strcmp(words[0], \"b64write\") == 0) {\n        uint64_t addr, len;\n        uint8_t *data;\n        size_t data_len;\n        gsize out_len;\n\n        g_assert(words[1] && words[2] && words[3]);\n        g_assert(qemu_strtou64(words[1], NULL, 0, &addr) == 0);\n        g_assert(qemu_strtou64(words[2], NULL, 0, &len) == 0);\n\n        data_len = strlen(words[3]);\n        if (data_len < 3) {\n            qtest_send(chr, \"ERR invalid argument size\\n\");\n            return;\n        }\n\n        data = g_base64_decode_inplace(words[3], &out_len);\n        if (out_len != len) {\n            qtest_log_send(\"b64write: data length mismatch (told %\"PRIu64\", \"\n                           \"found %zu)\\n\",\n                           len, out_len);\n            out_len = MIN(out_len, len);\n        }\n\n        cpu_physical_memory_write(addr, data, out_len);\n\n        qtest_send_prefix(chr);\n        qtest_send(chr, \"OK\\n\");\n    } else if (strcmp(words[0], \"endianness\") == 0) {\n        qtest_send_prefix(chr);\n#if defined(TARGET_WORDS_BIGENDIAN)\n        qtest_sendf(chr, \"OK big\\n\");\n#else\n        qtest_sendf(chr, \"OK little\\n\");\n#endif\n#ifdef TARGET_PPC64\n    } else if (strcmp(words[0], \"rtas\") == 0) {\n        uint64_t res, args, ret;\n        unsigned long nargs, nret;\n\n        g_assert(qemu_strtoul(words[2], NULL, 0, &nargs) == 0);\n        g_assert(qemu_strtou64(words[3], NULL, 0, &args) == 0);\n        g_assert(qemu_strtoul(words[4], NULL, 0, &nret) == 0);\n        g_assert(qemu_strtou64(words[5], NULL, 0, &ret) == 0);\n        res = qtest_rtas_call(words[1], nargs, args, nret, ret);\n\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK %\"PRIu64\"\\n\", res);\n#endif\n    } else if (qtest_enabled() && strcmp(words[0], \"clock_step\") == 0) {\n        int64_t ns;\n\n        if (words[1]) {\n            g_assert(qemu_strtoi64(words[1], NULL, 0, &ns) == 0);\n        } else {\n            ns = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n        }\n        qtest_clock_warp(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + ns);\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK %\"PRIi64\"\\n\",\n                    (int64_t)qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n    } else if (qtest_enabled() && strcmp(words[0], \"clock_set\") == 0) {\n        int64_t ns;\n\n        g_assert(words[1]);\n        g_assert(qemu_strtoi64(words[1], NULL, 0, &ns) == 0);\n        qtest_clock_warp(ns);\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"OK %\"PRIi64\"\\n\",\n                    (int64_t)qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n    } else {\n        qtest_send_prefix(chr);\n        qtest_sendf(chr, \"FAIL Unknown command '%s'\\n\", words[0]);\n    }\n}\n\nstatic void qtest_process_inbuf(CharBackend *chr, GString *inbuf)\n{\n    char *end;\n\n    while ((end = strchr(inbuf->str, '\\n')) != NULL) {\n        size_t offset;\n        GString *cmd;\n        gchar **words;\n\n        offset = end - inbuf->str;\n\n        cmd = g_string_new_len(inbuf->str, offset);\n        g_string_erase(inbuf, 0, offset + 1);\n\n        words = g_strsplit(cmd->str, \" \", 0);\n        qtest_process_command(chr, words);\n        g_strfreev(words);\n\n        g_string_free(cmd, TRUE);\n    }\n}\n\nstatic void qtest_read(void *opaque, const uint8_t *buf, int size)\n{\n    CharBackend *chr = opaque;\n\n    g_string_append_len(inbuf, (const gchar *)buf, size);\n    qtest_process_inbuf(chr, inbuf);\n}\n\nstatic int qtest_can_read(void *opaque)\n{\n    return 1024;\n}\n\nstatic void qtest_event(void *opaque, int event)\n{\n    int i;\n\n    switch (event) {\n    case CHR_EVENT_OPENED:\n        /*\n         * We used to call qemu_system_reset() here, hoping we could\n         * use the same process for multiple tests that way.  Never\n         * used.  Injects an extra reset even when it's not used, and\n         * that can mess up tests, e.g. -boot once.\n         */\n        for (i = 0; i < ARRAY_SIZE(irq_levels); i++) {\n            irq_levels[i] = 0;\n        }\n        qemu_gettimeofday(&start_time);\n        qtest_opened = true;\n        if (qtest_log_fp) {\n            fprintf(qtest_log_fp, \"[I \" FMT_timeval \"] OPENED\\n\",\n                    (long) start_time.tv_sec, (long) start_time.tv_usec);\n        }\n        break;\n    case CHR_EVENT_CLOSED:\n        qtest_opened = false;\n        if (qtest_log_fp) {\n            qemu_timeval tv;\n            qtest_get_time(&tv);\n            fprintf(qtest_log_fp, \"[I +\" FMT_timeval \"] CLOSED\\n\",\n                    (long) tv.tv_sec, (long) tv.tv_usec);\n        }\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int qtest_init_accel(MachineState *ms)\n{\n    QemuOpts *opts = qemu_opts_create(qemu_find_opts(\"icount\"), NULL, 0,\n                                      &error_abort);\n    qemu_opt_set(opts, \"shift\", \"0\", &error_abort);\n    configure_icount(opts, &error_abort);\n    qemu_opts_del(opts);\n    return 0;\n}\n\nvoid qtest_init(const char *qtest_chrdev, const char *qtest_log, Error **errp)\n{\n    Chardev *chr;\n\n    chr = qemu_chr_new(\"qtest\", qtest_chrdev);\n\n    if (chr == NULL) {\n        error_setg(errp, \"Failed to initialize device for qtest: \\\"%s\\\"\",\n                   qtest_chrdev);\n        return;\n    }\n\n    if (qtest_log) {\n        if (strcmp(qtest_log, \"none\") != 0) {\n            qtest_log_fp = fopen(qtest_log, \"w+\");\n        }\n    } else {\n        qtest_log_fp = stderr;\n    }\n\n    qemu_chr_fe_init(&qtest_chr, chr, errp);\n    qemu_chr_fe_set_handlers(&qtest_chr, qtest_can_read, qtest_read,\n                             qtest_event, &qtest_chr, NULL, true);\n    qemu_chr_fe_set_echo(&qtest_chr, true);\n\n    inbuf = g_string_new(\"\");\n}\n\nbool qtest_driver(void)\n{\n    return qtest_chr.chr != NULL;\n}\n\nstatic void qtest_accel_class_init(ObjectClass *oc, void *data)\n{\n    AccelClass *ac = ACCEL_CLASS(oc);\n    ac->name = \"QTest\";\n    ac->available = qtest_available;\n    ac->init_machine = qtest_init_accel;\n    ac->allowed = &qtest_allowed;\n}\n\n#define TYPE_QTEST_ACCEL ACCEL_CLASS_NAME(\"qtest\")\n\nstatic const TypeInfo qtest_accel_type = {\n    .name = TYPE_QTEST_ACCEL,\n    .parent = TYPE_ACCEL,\n    .class_init = qtest_accel_class_init,\n};\n\nstatic void qtest_type_init(void)\n{\n    type_register_static(&qtest_accel_type);\n}\n\ntype_init(qtest_type_init);\n"
        },
        {
          "name": "replay",
          "type": "tree",
          "content": null
        },
        {
          "name": "replication.c",
          "type": "blob",
          "size": 2.46484375,
          "content": "/*\n * Replication filter\n *\n * Copyright (c) 2016 HUAWEI TECHNOLOGIES CO., LTD.\n * Copyright (c) 2016 Intel Corporation\n * Copyright (c) 2016 FUJITSU LIMITED\n *\n * Author:\n *   Changlong Xie <xiecl.fnst@cn.fujitsu.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"replication.h\"\n\nstatic QLIST_HEAD(, ReplicationState) replication_states;\n\nReplicationState *replication_new(void *opaque, ReplicationOps *ops)\n{\n    ReplicationState *rs;\n\n    assert(ops != NULL);\n    rs = g_new0(ReplicationState, 1);\n    rs->opaque = opaque;\n    rs->ops = ops;\n    QLIST_INSERT_HEAD(&replication_states, rs, node);\n\n    return rs;\n}\n\nvoid replication_remove(ReplicationState *rs)\n{\n    if (rs) {\n        QLIST_REMOVE(rs, node);\n        g_free(rs);\n    }\n}\n\n/*\n * The caller of the function MUST make sure vm stopped\n */\nvoid replication_start_all(ReplicationMode mode, Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->start) {\n            rs->ops->start(rs, mode, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_do_checkpoint_all(Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->checkpoint) {\n            rs->ops->checkpoint(rs, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_get_error_all(Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->get_error) {\n            rs->ops->get_error(rs, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_stop_all(bool failover, Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->stop) {\n            rs->ops->stop(rs, failover, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n"
        },
        {
          "name": "replication.h",
          "type": "blob",
          "size": 5.171875,
          "content": "/*\n * Replication filter\n *\n * Copyright (c) 2016 HUAWEI TECHNOLOGIES CO., LTD.\n * Copyright (c) 2016 Intel Corporation\n * Copyright (c) 2016 FUJITSU LIMITED\n *\n * Author:\n *   Changlong Xie <xiecl.fnst@cn.fujitsu.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#ifndef REPLICATION_H\n#define REPLICATION_H\n\n#include \"qemu/queue.h\"\n\ntypedef struct ReplicationOps ReplicationOps;\ntypedef struct ReplicationState ReplicationState;\n\n/**\n * SECTION:replication.h\n * @title:Base Replication System\n * @short_description: interfaces for handling replication\n *\n * The Replication Model provides a framework for handling Replication\n *\n * <example>\n *   <title>How to use replication interfaces</title>\n *   <programlisting>\n * #include \"replication.h\"\n *\n * typedef struct BDRVReplicationState {\n *     ReplicationState *rs;\n * } BDRVReplicationState;\n *\n * static void replication_start(ReplicationState *rs, ReplicationMode mode,\n *                               Error **errp);\n * static void replication_do_checkpoint(ReplicationState *rs, Error **errp);\n * static void replication_get_error(ReplicationState *rs, Error **errp);\n * static void replication_stop(ReplicationState *rs, bool failover,\n *                              Error **errp);\n *\n * static ReplicationOps replication_ops = {\n *     .start = replication_start,\n *     .checkpoint = replication_do_checkpoint,\n *     .get_error = replication_get_error,\n *     .stop = replication_stop,\n * }\n *\n * static int replication_open(BlockDriverState *bs, QDict *options,\n *                             int flags, Error **errp)\n * {\n *     BDRVReplicationState *s = bs->opaque;\n *     s->rs = replication_new(bs, &replication_ops);\n *     return 0;\n * }\n *\n * static void replication_close(BlockDriverState *bs)\n * {\n *     BDRVReplicationState *s = bs->opaque;\n *     replication_remove(s->rs);\n * }\n *\n * BlockDriver bdrv_replication = {\n *     .format_name                = \"replication\",\n *     .protocol_name              = \"replication\",\n *     .instance_size              = sizeof(BDRVReplicationState),\n *\n *     .bdrv_open                  = replication_open,\n *     .bdrv_close                 = replication_close,\n * };\n *\n * static void bdrv_replication_init(void)\n * {\n *     bdrv_register(&bdrv_replication);\n * }\n *\n * block_init(bdrv_replication_init);\n *   </programlisting>\n * </example>\n *\n * We create an example about how to use replication interfaces in above.\n * Then in migration, we can use replication_(start/stop/do_checkpoint/\n * get_error)_all to handle all replication operations.\n */\n\n/**\n * ReplicationState:\n * @opaque: opaque pointer value passed to this ReplicationState\n * @ops: replication operation of this ReplicationState\n * @node: node that we will insert into @replication_states QLIST\n */\nstruct ReplicationState {\n    void *opaque;\n    ReplicationOps *ops;\n    QLIST_ENTRY(ReplicationState) node;\n};\n\n/**\n * ReplicationOps:\n * @start: callback to start replication\n * @stop: callback to stop replication\n * @checkpoint: callback to do checkpoint\n * @get_error: callback to check if error occurred during replication\n */\nstruct ReplicationOps {\n    void (*start)(ReplicationState *rs, ReplicationMode mode, Error **errp);\n    void (*stop)(ReplicationState *rs, bool failover, Error **errp);\n    void (*checkpoint)(ReplicationState *rs, Error **errp);\n    void (*get_error)(ReplicationState *rs, Error **errp);\n};\n\n/**\n * replication_new:\n * @opaque: opaque pointer value passed to ReplicationState\n * @ops: replication operation of the new relevant ReplicationState\n *\n * Called to create a new ReplicationState instance, and then insert it\n * into @replication_states QLIST\n *\n * Returns: the new ReplicationState instance\n */\nReplicationState *replication_new(void *opaque, ReplicationOps *ops);\n\n/**\n * replication_remove:\n * @rs: the ReplicationState instance to remove\n *\n * Called to remove a ReplicationState instance, and then delete it from\n * @replication_states QLIST\n */\nvoid replication_remove(ReplicationState *rs);\n\n/**\n * replication_start_all:\n * @mode: replication mode that could be \"primary\" or \"secondary\"\n * @errp: returns an error if this function fails\n *\n * Start replication, called in migration/checkpoint thread\n *\n * Note: the caller of the function MUST make sure vm stopped\n */\nvoid replication_start_all(ReplicationMode mode, Error **errp);\n\n/**\n * replication_do_checkpoint_all:\n * @errp: returns an error if this function fails\n *\n * This interface is called after all VM state is transferred to Secondary QEMU\n */\nvoid replication_do_checkpoint_all(Error **errp);\n\n/**\n * replication_get_error_all:\n * @errp: returns an error if this function fails\n *\n * This interface is called to check if error occurred during replication\n */\nvoid replication_get_error_all(Error **errp);\n\n/**\n * replication_stop_all:\n * @failover: boolean value that indicates if we need do failover or not\n * @errp: returns an error if this function fails\n *\n * It is called on failover. The vm should be stopped before calling it, if you\n * use this API to shutdown the guest, or other things except failover\n */\nvoid replication_stop_all(bool failover, Error **errp);\n\n#endif /* REPLICATION_H */\n"
        },
        {
          "name": "roms",
          "type": "tree",
          "content": null
        },
        {
          "name": "rules.mak",
          "type": "blob",
          "size": 14.4580078125,
          "content": "\nCOMMA := ,\n\n# Don't use implicit rules or variables\n# we have explicit rules for everything\nMAKEFLAGS += -rR\n\n# Files with this suffixes are final, don't try to generate them\n# using implicit rules\n%/trace-events:\n%.hx:\n%.py:\n%.objs:\n%.d:\n%.h:\n%.c:\n%.cc:\n%.cpp:\n%.m:\n%.mak:\nclean-target:\n\n# Additional C++ flags. Note that QEMU_CFLAGS have already been appended by configure.\nQEMU_CXXFLAGS += -Wno-sign-compare -std=c++11 -fPIC -fpermissive\n\n# Flags for dependency generation\nQEMU_DGFLAGS += -MMD -MP -MT $@ -MF $(@D)/$(*F).d\n\n# Compiler searches the source file dir first, but in vpath builds\n# we need to make it search the build dir too, before any other\n# explicit search paths. There are two search locations in the build\n# dir, one absolute and the other relative to the compiler working\n# directory. These are the same for target-independent files, but\n# different for target-dependent ones.\nQEMU_LOCAL_INCLUDES = -iquote $(BUILD_DIR)/$(@D) -iquote $(@D) -iquote $(BUILD_DIR)\n\n# Include PANDA headers.\nQEMU_INCLUDES += -iquote $(SRC_PATH)/target/$(TARGET_BASE_ARCH) -iquote $(SRC_PATH)/panda/include\n\nWL_U := -Wl,-u,\nfind-symbols = $(if $1, $(sort $(shell $(NM) -P -g $1 | $2)))\ndefined-symbols = $(call find-symbols,$1,awk '$$2!=\"U\"{print $$1}')\nundefined-symbols = $(call find-symbols,$1,awk '$$2==\"U\"{print $$1}')\n\n# All the .mo objects in -m variables are also added into corresponding -y\n# variable in unnest-vars, but filtered out here, when LINK is called.\n#\n# The .mo objects are supposed to be linked as a DSO, for module build. So here\n# they are only used as a placeholders to generate those \"archive undefined\"\n# symbol options (-Wl,-u,$symbol_name), which are the archive functions\n# referenced by the code in the DSO.\n#\n# Also the presence in -y variables will also guarantee they are built before\n# linking executables that will load them. So we can look up symbol reference\n# in LINK.\n#\n# This is necessary because the exectuable itself may not use the function, in\n# which case the function would not be linked in. Then the DSO loading will\n# fail because of the missing symbol.\nprocess-archive-undefs = $(filter-out %.a %.mo,$1) \\\n                $(addprefix $(WL_U), \\\n                     $(filter $(call defined-symbols,$(filter %.a, $1)), \\\n                              $(call undefined-symbols,$(filter %.mo,$1)))) \\\n                $(filter %.a,$1)\n\nextract-libs = $(strip $(foreach o,$(filter-out %.mo,$1),$($o-libs)))\nexpand-objs = $(strip $(sort $(filter %.o,$1)) \\\n                  $(foreach o,$(filter %.mo,$1),$($o-objs)) \\\n                  $(filter-out %.o %.mo,$1))\n\n%.o: %.c\n\t$(call quiet-command,$(CC) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \\\n\t       $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \\\n\t       -c -o $@ $<,\"CC\",\"$(TARGET_DIR)$@\")\n%.o: %.rc\n\t$(call quiet-command,$(WINDRES) -I. -o $@ $<,\"RC\",\"$(TARGET_DIR)$@\")\n\n# If we have a CXX we might have some C++ objects, in which case we\n# must link with the C++ compiler, not the plain C compiler.\nLINKPROG = $(or $(CXX),$(CC))\n\nLINK = $(call quiet-command, $(LINKPROG) $(QEMU_LDFLAGS) $(QEMU_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@ \\\n       $(call process-archive-undefs, $1) \\\n       $(version-obj-y) $(call extract-libs,$1) $(LIBS),\"LINK\",\"$(TARGET_DIR)$@\")\n\n%.o: %.S\n\t$(call quiet-command,$(CCAS) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \\\n\t       $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) \\\n\t       -c -o $@ $<,\"CCAS\",\"$(TARGET_DIR)$@\")\n\n%.o: %.cc\n\t$(call quiet-command,$(CXX) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \\\n\t       $(QEMU_CXXFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \\\n\t       -c -o $@ $<,\"CXX\",\"$(TARGET_DIR)$@\")\n\n%.o: %.cpp\n\t$(call quiet-command,$(CXX) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \\\n\t       $(QEMU_CXXFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \\\n\t       -c -o $@ $<,\"CXX\",\"$(TARGET_DIR)$@\")\n\n%.o: %.m\n\t$(call quiet-command,$(OBJCC) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \\\n\t       $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \\\n\t       -c -o $@ $<,\"OBJC\",\"$(TARGET_DIR)$@\")\n\n%.o: %.dtrace\n\t$(call quiet-command,dtrace -o $@ -G -s $<,\"GEN\",\"$(TARGET_DIR)$@\")\n\nDSO_OBJ_CFLAGS := -fPIC -DBUILD_DSO\nmodule-common.o: CFLAGS += $(DSO_OBJ_CFLAGS)\n%$(DSOSUF): LDFLAGS += $(LDFLAGS_SHARED)\n%$(DSOSUF): %.mo\n\t$(call LINK,$^)\n\t@# Copy to build root so modules can be loaded when program started without install\n\t$(if $(findstring /,$@),$(call quiet-command,cp $@ $(subst /,-,$@),\"CP\",\"$(subst /,-,$@)\"))\n\n\nLD_REL := $(CC) -nostdlib $(LD_REL_FLAGS)\n\n%.mo:\n\t$(call quiet-command,$(LD_REL) -o $@ $^,\"LD\",\"$(TARGET_DIR)$@\")\n\n.PHONY: modules\nmodules:\n\n%$(EXESUF): %.o\n\t$(call LINK,$(filter %.o %.a %.mo, $^))\n\n%.a:\n\t$(call quiet-command,rm -f $@ && $(AR) rcs $@ $^,\"AR\",\"$(TARGET_DIR)$@\")\n\n# Usage: $(call quiet-command,command and args,\"NAME\",\"args to print\")\n# This will run \"command and args\", and either:\n#  if V=1 just print the whole command and args\n#  otherwise print the 'quiet' output in the format \"  NAME     args to print\"\n# NAME should be a short name of the command, 7 letters or fewer.\n# If called with only a single argument, will print nothing in quiet mode.\nquiet-command = $(if $(V),$1,$(if $(2),@printf \"  %-7s %s\\n\" $2 $3 && $1, @$1))\n\n# cc-option\n# Usage: CFLAGS+=$(call cc-option, -falign-functions=0, -malign-functions=0)\n\ncc-option = $(if $(shell $(CC) $1 $2 -S -o /dev/null -xc /dev/null \\\n              >/dev/null 2>&1 && echo OK), $2, $3)\ncc-c-option = $(if $(shell $(CC) $1 $2 -c -o /dev/null -xc /dev/null \\\n                >/dev/null 2>&1 && echo OK), $2, $3)\n\nVPATH_SUFFIXES = %.c %.h %.S %.cc %.cpp %.m %.mak %.texi %.sh %.rc\nset-vpath = $(if $1,$(foreach PATTERN,$(VPATH_SUFFIXES),$(eval vpath $(PATTERN) $1)))\n\n# install-prog list, dir\ndefine install-prog\n\t$(INSTALL_DIR) \"$2\"\n\t$(INSTALL_PROG) $1 \"$2\"\n\t$(if $(STRIP),$(STRIP) $(foreach T,$1,\"$2/$(notdir $T)\"),)\nendef\n\n# find-in-path\n# Usage: $(call find-in-path, prog)\n# Looks in the PATH if the argument contains no slash, else only considers one\n# specific directory.  Returns an # empty string if the program doesn't exist\n# there.\nfind-in-path = $(if $(findstring /, $1), \\\n        $(wildcard $1), \\\n        $(wildcard $(patsubst %, %/$1, $(subst :, ,$(PATH)))))\n\n# Logical functions (for operating on y/n values like CONFIG_FOO vars)\n# Inputs to these must be either \"y\" (true) or \"n\" or \"\" (both false)\n# Output is always either \"y\" or \"n\".\n# Usage: $(call land,$(CONFIG_FOO),$(CONFIG_BAR))\n# Logical NOT\nlnot = $(if $(subst n,,$1),n,y)\n# Logical AND\nland = $(if $(findstring yy,$1$2),y,n)\n# Logical OR\nlor = $(if $(findstring y,$1$2),y,n)\n# Logical XOR (note that this is the inverse of leqv)\nlxor = $(if $(filter $(call lnot,$1),$(call lnot,$2)),n,y)\n# Logical equivalence (note that leqv \"\",\"n\" is true)\nleqv = $(if $(filter $(call lnot,$1),$(call lnot,$2)),y,n)\n# Logical if: like make's $(if) but with an leqv-like test\nlif = $(if $(subst n,,$1),$2,$3)\n\n# String testing functions: inputs to these can be any string;\n# the output is always either \"y\" or \"n\". Leading and trailing whitespace\n# is ignored when comparing strings.\n# String equality\neq = $(if $(subst $2,,$1)$(subst $1,,$2),n,y)\n# String inequality\nne = $(if $(subst $2,,$1)$(subst $1,,$2),y,n)\n# Emptiness/non-emptiness tests:\nisempty = $(if $1,n,y)\nnotempty = $(if $1,y,n)\n\n# Generate files with tracetool\nTRACETOOL=$(PYTHON) $(SRC_PATH)/scripts/tracetool.py\n\n# Generate timestamp files for .h include files\n\nconfig-%.h: config-%.h-timestamp\n\t@cmp $< $@ >/dev/null 2>&1 || cp $< $@\n\nconfig-%.h-timestamp: config-%.mak $(SRC_PATH)/scripts/create_config\n\t$(call quiet-command, sh $(SRC_PATH)/scripts/create_config < $< > $@,\"GEN\",\"$(TARGET_DIR)config-$*.h\")\n\n.PHONY: clean-timestamp\nclean-timestamp:\n\trm -f *.timestamp\nclean: clean-timestamp\n\n# will delete the target of a rule if commands exit with a nonzero exit status\n.DELETE_ON_ERROR:\n\n# save-vars\n# Usage: $(call save-vars, vars)\n# Save each variable $v in $vars as save-vars-$v, save their object's\n# variables, then clear $v.  saved-vars-$v contains the variables that\n# where saved for the objects, in order to speedup load-vars.\ndefine save-vars\n    $(foreach v,$1,\n        $(eval save-vars-$v := $(value $v))\n        $(eval saved-vars-$v := $(foreach o,$($v), \\\n            $(if $($o-cflags), $o-cflags $(eval save-vars-$o-cflags := $($o-cflags))$(eval $o-cflags := )) \\\n            $(if $($o-libs), $o-libs $(eval save-vars-$o-libs := $($o-libs))$(eval $o-libs := )) \\\n            $(if $($o-objs), $o-objs $(eval save-vars-$o-objs := $($o-objs))$(eval $o-objs := ))))\n        $(eval $v := ))\nendef\n\n# load-vars\n# Usage: $(call load-vars, vars, add_var)\n# Load the saved value for each variable in @vars, and the per object\n# variables.\n# Append @add_var's current value to the loaded value.\ndefine load-vars\n    $(eval $2-new-value := $(value $2))\n    $(foreach v,$1,\n        $(eval $v := $(value save-vars-$v))\n        $(foreach o,$(saved-vars-$v),\n            $(eval $o := $(save-vars-$o)) $(eval save-vars-$o := ))\n        $(eval save-vars-$v := )\n        $(eval saved-vars-$v := ))\n    $(eval $2 := $(value $2) $($2-new-value))\nendef\n\n# fix-paths\n# Usage: $(call fix-paths, obj_path, src_path, vars)\n# Add prefix @obj_path to all objects in @vars, and add prefix @src_path to all\n# directories in @vars.\ndefine fix-paths\n    $(foreach v,$3,\n        $(foreach o,$($v),\n            $(if $($o-libs),\n                $(eval $1$o-libs := $($o-libs)))\n            $(if $($o-cflags),\n                $(eval $1$o-cflags := $($o-cflags)))\n            $(if $($o-objs),\n                $(eval $1$o-objs := $(addprefix $1,$($o-objs)))))\n        $(eval $v := $(addprefix $1,$(filter-out %/,$($v))) \\\n                     $(addprefix $2,$(filter %/,$($v)))))\nendef\n\n# unnest-var-recursive\n# Usage: $(call unnest-var-recursive, obj_prefix, vars, var)\n#\n# Unnest @var by including subdir Makefile.objs, while protect others in @vars\n# unchanged.\n#\n# @obj_prefix is the starting point of object path prefix.\n#\ndefine unnest-var-recursive\n    $(eval dirs := $(sort $(filter %/,$($3))))\n    $(eval $3 := $(filter-out %/,$($3)))\n    $(foreach d,$(dirs:%/=%),\n            $(call save-vars,$2)\n            $(eval obj := $(if $1,$1/)$d)\n            $(eval -include $(SRC_PATH)/$d/Makefile.objs)\n            $(call fix-paths,$(if $1,$1/)$d/,$d/,$2)\n            $(call load-vars,$2,$3)\n            $(call unnest-var-recursive,$1,$2,$3))\nendef\n\n# unnest-vars\n# Usage: $(call unnest-vars, obj_prefix, vars)\n#\n# @obj_prefix: object path prefix, can be empty, or '..', etc. Don't include\n# ending '/'.\n#\n# @vars: the list of variable names to unnest.\n#\n# This macro will scan subdirectories's Makefile.objs, include them, to build\n# up each variable listed in @vars.\n#\n# Per object and per module cflags and libs are saved with relative path fixed\n# as well, those variables include -libs, -cflags and -objs. Items in -objs are\n# also fixed to relative path against SRC_PATH plus the prefix @obj_prefix.\n#\n# All nested variables postfixed by -m in names are treated as DSO variables,\n# and will be built as modules, if enabled.\n#\n# A simple example of the unnest:\n#\n#     obj_prefix = ..\n#     vars = hot cold\n#     hot  = fire.o sun.o season/\n#     cold = snow.o water/ season/\n#\n# Unnest through a faked source directory structure:\n#\n#     SRC_PATH\n#        ├── water\n#        │   └── Makefile.objs──────────────────┐\n#        │       │ hot += steam.o               │\n#        │       │ cold += ice.mo               │\n#        │       │ ice.mo-libs := -licemaker    │\n#        │       │ ice.mo-objs := ice1.o ice2.o │\n#        │       └──────────────────────────────┘\n#        │\n#        └── season\n#            └── Makefile.objs──────┐\n#                │ hot += summer.o  │\n#                │ cold += winter.o │\n#                └──────────────────┘\n#\n# In the end, the result will be:\n#\n#     hot  = ../fire.o ../sun.o ../season/summer.o\n#     cold = ../snow.o ../water/ice.mo ../season/winter.o\n#     ../water/ice.mo-libs = -licemaker\n#     ../water/ice.mo-objs = ../water/ice1.o ../water/ice2.o\n#\n# Note that 'hot' didn't include 'season/' in the input, so 'summer.o' is not\n# included.\n#\ndefine unnest-vars\n    # In the case of target build (i.e. $1 == ..), fix path for top level\n    # Makefile.objs objects\n    $(if $1,$(call fix-paths,$1/,,$2))\n\n    # Descend and include every subdir Makefile.objs\n    $(foreach v, $2,\n        $(call unnest-var-recursive,$1,$2,$v)\n        # Pass the .mo-cflags and .mo-libs along to its member objects\n        $(foreach o, $(filter %.mo,$($v)),\n            $(foreach p,$($o-objs),\n                $(if $($o-cflags), $(eval $p-cflags += $($o-cflags)))\n                $(if $($o-libs), $(eval $p-libs += $($o-libs))))))\n\n    # For all %.mo objects that are directly added into -y, just expand them\n    $(foreach v,$(filter %-y,$2),\n        $(eval $v := $(foreach o,$($v),$(if $($o-objs),$($o-objs),$o))))\n\n    $(foreach v,$(filter %-m,$2),\n        # All .o found in *-m variables are single object modules, create .mo\n        # for them\n        $(foreach o,$(filter %.o,$($v)),\n            $(eval $(o:%.o=%.mo)-objs := $o))\n        # Now unify .o in -m variable to .mo\n        $(eval $v := $($v:%.o=%.mo))\n        $(eval modules-m += $($v))\n\n        # For module build, build shared libraries during \"make modules\"\n        # For non-module build, add -m to -y\n        $(if $(CONFIG_MODULES),\n             $(foreach o,$($v),\n                   $(eval $($o-objs): CFLAGS += $(DSO_OBJ_CFLAGS))\n                   $(eval $o: $($o-objs)))\n             $(eval $(patsubst %-m,%-y,$v) += $($v))\n             $(eval modules: $($v:%.mo=%$(DSOSUF))),\n             $(eval $(patsubst %-m,%-y,$v) += $(call expand-objs, $($v)))))\n\n    # Post-process all the unnested vars\n    $(foreach v,$2,\n        $(foreach o, $(filter %.mo,$($v)),\n            # Find all the .mo objects in variables and add dependency rules\n            # according to .mo-objs. Report error if not set\n            $(if $($o-objs),\n                $(eval $(o:%.mo=%$(DSOSUF)): module-common.o $($o-objs)),\n                $(error $o added in $v but $o-objs is not set)))\n        $(shell mkdir -p ./ $(sort $(dir $($v))))\n        # Include all the .d files\n        $(eval -include $(patsubst %.o,%.d,$(patsubst %.mo,%.d,$($v))))\n        $(eval $v := $(filter-out %/,$($v))))\nendef\n\nTEXI2MAN = $(call quiet-command, \\\n\tperl -Ww -- $(SRC_PATH)/scripts/texi2pod.pl -I docs $< $@.pod && \\\n\t$(POD2MAN) --section=$(subst .,,$(suffix $@)) --center=\" \" --release=\" \" $@.pod > $@, \\\n\t\"GEN\",\"$@\")\n\n%.1:\n\t$(call TEXI2MAN)\n%.7:\n\t$(call TEXI2MAN)\n%.8:\n\t$(call TEXI2MAN)\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "slirp",
          "type": "tree",
          "content": null
        },
        {
          "name": "softmmu_template.h",
          "type": "blob",
          "size": 19.67578125,
          "content": "/*\n *  Software MMU support\n *\n * Generate helpers used by TCG for qemu_ld/st ops and code load\n * functions.\n *\n * Included from target op helpers and exec.c.\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#if DATA_SIZE == 8\n#define SUFFIX q\n#define LSUFFIX q\n#define SDATA_TYPE  int64_t\n#define DATA_TYPE  uint64_t\n#elif DATA_SIZE == 4\n#define SUFFIX l\n#define LSUFFIX l\n#define SDATA_TYPE  int32_t\n#define DATA_TYPE  uint32_t\n#elif DATA_SIZE == 2\n#define SUFFIX w\n#define LSUFFIX uw\n#define SDATA_TYPE  int16_t\n#define DATA_TYPE  uint16_t\n#elif DATA_SIZE == 1\n#define SUFFIX b\n#define LSUFFIX ub\n#define SDATA_TYPE  int8_t\n#define DATA_TYPE  uint8_t\n#else\n#error unsupported data size\n#endif\n\n\n/* For the benefit of TCG generated code, we want to avoid the complication\n   of ABI-specific return type promotion and always return a value extended\n   to the register size of the host.  This is tcg_target_long, except in the\n   case of a 32-bit host and 64-bit data, and for that we always have\n   uint64_t.  Don't bother with this widened value for SOFTMMU_CODE_ACCESS.  */\n#if defined(SOFTMMU_CODE_ACCESS) || DATA_SIZE == 8\n# define WORD_TYPE  DATA_TYPE\n# define USUFFIX    SUFFIX\n#else\n# define WORD_TYPE  tcg_target_ulong\n# define USUFFIX    glue(u, SUFFIX)\n# define SSUFFIX    glue(s, SUFFIX)\n#endif\n\n#ifdef SOFTMMU_CODE_ACCESS\n#define READ_ACCESS_TYPE MMU_INST_FETCH\n#define ADDR_READ addr_code\n#else\n#define READ_ACCESS_TYPE MMU_DATA_LOAD\n#define ADDR_READ addr_read\n#endif\n\n#if DATA_SIZE == 8\n# define BSWAP(X)  bswap64(X)\n#elif DATA_SIZE == 4\n# define BSWAP(X)  bswap32(X)\n#elif DATA_SIZE == 2\n# define BSWAP(X)  bswap16(X)\n#else\n# define BSWAP(X)  (X)\n#endif\n\n#if DATA_SIZE == 1\n# define helper_le_ld_name  glue(glue(helper_ret_ld, USUFFIX), MMUSUFFIX)\n# define helper_be_ld_name  helper_le_ld_name\n# define helper_le_lds_name glue(glue(helper_ret_ld, SSUFFIX), MMUSUFFIX)\n# define helper_be_lds_name helper_le_lds_name\n# define helper_le_st_name  glue(glue(helper_ret_st, SUFFIX), MMUSUFFIX)\n# define helper_be_st_name  helper_le_st_name\n#else\n# define helper_le_ld_name  glue(glue(helper_le_ld, USUFFIX), MMUSUFFIX)\n# define helper_be_ld_name  glue(glue(helper_be_ld, USUFFIX), MMUSUFFIX)\n# define helper_le_lds_name glue(glue(helper_le_ld, SSUFFIX), MMUSUFFIX)\n# define helper_be_lds_name glue(glue(helper_be_ld, SSUFFIX), MMUSUFFIX)\n# define helper_le_st_name  glue(glue(helper_le_st, SUFFIX), MMUSUFFIX)\n# define helper_be_st_name  glue(glue(helper_be_st, SUFFIX), MMUSUFFIX)\n#endif\n\n#ifndef SOFTMMU_CODE_ACCESS\nstatic inline DATA_TYPE glue(io_read, SUFFIX)(CPUArchState *env,\n                                              size_t mmu_idx, size_t index,\n                                              target_ulong addr,\n                                              uintptr_t retaddr)\n{\n    CPUIOTLBEntry *iotlbentry = &env->iotlb[mmu_idx][index];\n    return io_readx(env, iotlbentry, addr, retaddr, DATA_SIZE);\n}\n#endif\n\nWORD_TYPE helper_le_ld_name(CPUArchState *env, target_ulong addr,\n                            TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;\n    unsigned a_bits = get_alignment_bits(get_memop(oi));\n    uintptr_t haddr;\n    DATA_TYPE res;\n\n    if (addr & ((1 << a_bits) - 1)) {\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, READ_ACCESS_TYPE,\n                             mmu_idx, retaddr);\n    }\n\n    /* If the TLB entry is for a different page, reload and try again.  */\n    if ((addr & TARGET_PAGE_MASK)\n         != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        if (!VICTIM_TLB_HIT(ADDR_READ, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, READ_ACCESS_TYPE,\n                     mmu_idx, retaddr);\n        }\n        tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;\n    }\n\n    /* Handle an IO access.  */\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n        if ((addr & (DATA_SIZE - 1)) != 0) {\n            goto do_unaligned_access;\n        }\n\n        /* ??? Note that the io helpers always read data in the target\n           byte ordering.  We should push the LE/BE request down into io.  */\n        res = glue(io_read, SUFFIX)(env, mmu_idx, index, addr, retaddr);\n        res = TGT_LE(res);\n        return res;\n    }\n\n    /* Handle slow unaligned access (it spans two pages or IO).  */\n    if (DATA_SIZE > 1\n        && unlikely((addr & ~TARGET_PAGE_MASK) + DATA_SIZE - 1\n                    >= TARGET_PAGE_SIZE)) {\n        target_ulong addr1, addr2;\n        DATA_TYPE res1, res2;\n        unsigned shift;\n    do_unaligned_access:\n        addr1 = addr & ~(DATA_SIZE - 1);\n        addr2 = addr1 + DATA_SIZE;\n        res1 = helper_le_ld_name(env, addr1, oi, retaddr);\n        res2 = helper_le_ld_name(env, addr2, oi, retaddr);\n        shift = (addr & (DATA_SIZE - 1)) * 8;\n\n        /* Little-endian combine.  */\n        res = (res1 >> shift) | (res2 << ((DATA_SIZE * 8) - shift));\n        return res;\n    }\n\n    haddr = addr + env->tlb_table[mmu_idx][index].addend;\n#if DATA_SIZE == 1\n    res = glue(glue(ld, LSUFFIX), _p)((uint8_t *)haddr);\n#else\n    res = glue(glue(ld, LSUFFIX), _le_p)((uint8_t *)haddr);\n#endif\n\n    return res;\n}\n\n#if DATA_SIZE > 1\nWORD_TYPE helper_be_ld_name(CPUArchState *env, target_ulong addr,\n                            TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;\n    unsigned a_bits = get_alignment_bits(get_memop(oi));\n    uintptr_t haddr;\n    DATA_TYPE res;\n\n    if (addr & ((1 << a_bits) - 1)) {\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, READ_ACCESS_TYPE,\n                             mmu_idx, retaddr);\n    }\n\n    /* If the TLB entry is for a different page, reload and try again.  */\n    if ((addr & TARGET_PAGE_MASK)\n         != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        if (!VICTIM_TLB_HIT(ADDR_READ, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, READ_ACCESS_TYPE,\n                     mmu_idx, retaddr);\n        }\n        tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;\n    }\n\n    /* Handle an IO access.  */\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n        if ((addr & (DATA_SIZE - 1)) != 0) {\n            goto do_unaligned_access;\n        }\n\n        /* ??? Note that the io helpers always read data in the target\n           byte ordering.  We should push the LE/BE request down into io.  */\n        res = glue(io_read, SUFFIX)(env, mmu_idx, index, addr, retaddr);\n        res = TGT_BE(res);\n        return res;\n    }\n\n    /* Handle slow unaligned access (it spans two pages or IO).  */\n    if (DATA_SIZE > 1\n        && unlikely((addr & ~TARGET_PAGE_MASK) + DATA_SIZE - 1\n                    >= TARGET_PAGE_SIZE)) {\n        target_ulong addr1, addr2;\n        DATA_TYPE res1, res2;\n        unsigned shift;\n    do_unaligned_access:\n        addr1 = addr & ~(DATA_SIZE - 1);\n        addr2 = addr1 + DATA_SIZE;\n        res1 = helper_be_ld_name(env, addr1, oi, retaddr);\n        res2 = helper_be_ld_name(env, addr2, oi, retaddr);\n        shift = (addr & (DATA_SIZE - 1)) * 8;\n\n        /* Big-endian combine.  */\n        res = (res1 << shift) | (res2 >> ((DATA_SIZE * 8) - shift));\n        return res;\n    }\n\n    haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    res = glue(glue(ld, LSUFFIX), _be_p)((uint8_t *)haddr);\n    return res;\n}\n#endif /* DATA_SIZE > 1 */\n\n#ifndef SOFTMMU_CODE_ACCESS\n\n/* Provide signed versions of the load routines as well.  We can of course\n   avoid this for 64-bit data, or for 32-bit data on 32-bit host.  */\n#if DATA_SIZE * 8 < TCG_TARGET_REG_BITS\nWORD_TYPE helper_le_lds_name(CPUArchState *env, target_ulong addr,\n                             TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    return (SDATA_TYPE)helper_le_ld_name(env, addr, oi, retaddr);\n}\n\n# if DATA_SIZE > 1\nWORD_TYPE helper_be_lds_name(CPUArchState *env, target_ulong addr,\n                             TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    return (SDATA_TYPE)helper_be_ld_name(env, addr, oi, retaddr);\n}\n# endif\n#endif\n\nstatic inline void glue(io_write, SUFFIX)(CPUArchState *env,\n                                          size_t mmu_idx, size_t index,\n                                          DATA_TYPE val,\n                                          target_ulong addr,\n                                          uintptr_t retaddr)\n{\n    CPUIOTLBEntry *iotlbentry = &env->iotlb[mmu_idx][index];\n    return io_writex(env, iotlbentry, val, addr, retaddr, DATA_SIZE);\n}\n\nvoid helper_le_st_name(CPUArchState *env, target_ulong addr, DATA_TYPE val,\n                       TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    unsigned a_bits = get_alignment_bits(get_memop(oi));\n    uintptr_t haddr;\n\n    if (addr & ((1 << a_bits) - 1)) {\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, MMU_DATA_STORE,\n                             mmu_idx, retaddr);\n    }\n\n    /* If the TLB entry is for a different page, reload and try again.  */\n    if ((addr & TARGET_PAGE_MASK)\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n        }\n        tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    }\n\n    /* Handle an IO access.  */\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n        if ((addr & (DATA_SIZE - 1)) != 0) {\n            goto do_unaligned_access;\n        }\n\n        /* ??? Note that the io helpers always read data in the target\n           byte ordering.  We should push the LE/BE request down into io.  */\n        val = TGT_LE(val);\n        glue(io_write, SUFFIX)(env, mmu_idx, index, val, addr, retaddr);\n        return;\n    }\n\n    /* Handle slow unaligned access (it spans two pages or IO).  */\n    if (DATA_SIZE > 1\n        && unlikely((addr & ~TARGET_PAGE_MASK) + DATA_SIZE - 1\n                     >= TARGET_PAGE_SIZE)) {\n        int i, index2;\n        target_ulong page2, tlb_addr2;\n    do_unaligned_access:\n        /* Ensure the second page is in the TLB.  Note that the first page\n           is already guaranteed to be filled, and that the second page\n           cannot evict the first.  */\n        page2 = (addr + DATA_SIZE) & TARGET_PAGE_MASK;\n        index2 = (page2 >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n        tlb_addr2 = env->tlb_table[mmu_idx][index2].addr_write;\n        if (page2 != (tlb_addr2 & (TARGET_PAGE_MASK | TLB_INVALID_MASK))\n            && !VICTIM_TLB_HIT(addr_write, page2)) {\n            tlb_fill(ENV_GET_CPU(env), page2, MMU_DATA_STORE,\n                     mmu_idx, retaddr);\n        }\n\n        /* XXX: not efficient, but simple.  */\n        /* This loop must go in the forward direction to avoid issues\n           with self-modifying code in Windows 64-bit.  */\n        for (i = 0; i < DATA_SIZE; ++i) {\n            /* Little-endian extract.  */\n            uint8_t val8 = val >> (i * 8);\n            glue(helper_ret_stb, MMUSUFFIX)(env, addr + i, val8,\n                                            oi, retaddr);\n        }\n        return;\n    }\n\n    haddr = addr + env->tlb_table[mmu_idx][index].addend;\n#if DATA_SIZE == 1\n    glue(glue(st, SUFFIX), _p)((uint8_t *)haddr, val);\n#else\n    glue(glue(st, SUFFIX), _le_p)((uint8_t *)haddr, val);\n#endif\n}\n\n#if DATA_SIZE > 1\nvoid helper_be_st_name(CPUArchState *env, target_ulong addr, DATA_TYPE val,\n                       TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    unsigned a_bits = get_alignment_bits(get_memop(oi));\n    uintptr_t haddr;\n\n    if (addr & ((1 << a_bits) - 1)) {\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, MMU_DATA_STORE,\n                             mmu_idx, retaddr);\n    }\n\n    /* If the TLB entry is for a different page, reload and try again.  */\n    if ((addr & TARGET_PAGE_MASK)\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n        }\n        tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    }\n\n    /* Handle an IO access.  */\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n        if ((addr & (DATA_SIZE - 1)) != 0) {\n            goto do_unaligned_access;\n        }\n\n        /* ??? Note that the io helpers always read data in the target\n           byte ordering.  We should push the LE/BE request down into io.  */\n        val = TGT_BE(val);\n        glue(io_write, SUFFIX)(env, mmu_idx, index, val, addr, retaddr);\n        return;\n    }\n\n    /* Handle slow unaligned access (it spans two pages or IO).  */\n    if (DATA_SIZE > 1\n        && unlikely((addr & ~TARGET_PAGE_MASK) + DATA_SIZE - 1\n                     >= TARGET_PAGE_SIZE)) {\n        int i, index2;\n        target_ulong page2, tlb_addr2;\n    do_unaligned_access:\n        /* Ensure the second page is in the TLB.  Note that the first page\n           is already guaranteed to be filled, and that the second page\n           cannot evict the first.  */\n        page2 = (addr + DATA_SIZE) & TARGET_PAGE_MASK;\n        index2 = (page2 >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n        tlb_addr2 = env->tlb_table[mmu_idx][index2].addr_write;\n        if (page2 != (tlb_addr2 & (TARGET_PAGE_MASK | TLB_INVALID_MASK))\n            && !VICTIM_TLB_HIT(addr_write, page2)) {\n            tlb_fill(ENV_GET_CPU(env), page2, MMU_DATA_STORE,\n                     mmu_idx, retaddr);\n        }\n\n        /* XXX: not efficient, but simple */\n        /* This loop must go in the forward direction to avoid issues\n           with self-modifying code.  */\n        for (i = 0; i < DATA_SIZE; ++i) {\n            /* Big-endian extract.  */\n            uint8_t val8 = val >> (((DATA_SIZE - 1) * 8) - (i * 8));\n            glue(helper_ret_stb, MMUSUFFIX)(env, addr + i, val8,\n                                            oi, retaddr);\n        }\n        return;\n    }\n\n    haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    glue(glue(st, SUFFIX), _be_p)((uint8_t *)haddr, val);\n}\n#endif /* DATA_SIZE > 1 */\n\nWORD_TYPE glue(helper_le_ld_name, _panda)(CPUArchState *env, target_ulong addr,\n                                          TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_read;\n    CPUState *cpu = ENV_GET_CPU(env);\n    uintptr_t haddr = 0;\n\n    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!\n        haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    }\n\n    /*\n     * rwhelan: Hack to deal with the fact that we don't have the retaddr\n     * available at the time when we are translating from TCG, retaddr is\n     * handled in the TCG backend.  We get it here for LLVM.\n     */\n    if (execute_llvm && (retaddr == 0xDEADBEEF)){\n        retaddr = GETPC();\n    }\n\n    panda_callbacks_mem_before_read(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (void *)haddr);\n    WORD_TYPE ret = helper_le_ld_name(env, addr, oi, retaddr);\n    panda_callbacks_mem_after_read(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)ret, (void *)haddr);\n    return ret;\n}\n\nvoid glue(helper_le_st_name, _panda)(CPUArchState *env, target_ulong addr,\n                                     DATA_TYPE val, TCGMemOpIdx oi,\n                                     uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    CPUState *cpu = ENV_GET_CPU(env);\n    uintptr_t haddr = 0;\n\n    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!\n        haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    }\n\n    /*\n     * rwhelan: Hack to deal with the fact that we don't have the retaddr\n     * available at the time when we are translating from TCG, retaddr is\n     * handled in the TCG backend.  We get it here for LLVM.\n     */\n    if (execute_llvm && (retaddr == 0xDEADBEEF)){\n        retaddr = GETPC();\n    }\n\n    panda_callbacks_mem_before_write(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)val, (void *)haddr);\n    helper_le_st_name(env, addr, val, oi, retaddr);\n    panda_callbacks_mem_after_write(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)val, (void *)haddr);\n}\n\n#if DATA_SIZE > 1\nWORD_TYPE glue(helper_be_ld_name, _panda)(CPUArchState *env, target_ulong addr,\n                                          TCGMemOpIdx oi, uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_read;\n    CPUState *cpu = ENV_GET_CPU(env);\n    uintptr_t haddr = 0;\n\n    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!\n        haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    }\n\n    /*\n     * rwhelan: Hack to deal with the fact that we don't have the retaddr\n     * available at the time when we are translating from TCG, retaddr is\n     * handled in the TCG backend.  We get it here for LLVM.\n     */\n    if (execute_llvm && (retaddr == 0xDEADBEEF)){\n        retaddr = GETPC();\n    }\n\n    panda_callbacks_mem_before_read(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (void *)haddr);\n    WORD_TYPE ret = helper_be_ld_name(env, addr, oi, retaddr);\n    panda_callbacks_mem_after_read(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)ret, (void *)haddr);\n    return ret;\n}\n\nvoid glue(helper_be_st_name, _panda)(CPUArchState *env, target_ulong addr,\n                                     DATA_TYPE val, TCGMemOpIdx oi,\n                                     uintptr_t retaddr)\n{\n    unsigned mmu_idx = get_mmuidx(oi);\n    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n    CPUState *cpu = ENV_GET_CPU(env);\n    uintptr_t haddr = 0;\n\n    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!\n        haddr = addr + env->tlb_table[mmu_idx][index].addend;\n    }\n\n    /*\n     * rwhelan: Hack to deal with the fact that we don't have the retaddr\n     * available at the time when we are translating from TCG, retaddr is\n     * handled in the TCG backend.  We get it here for LLVM.\n     */\n    if (execute_llvm && (retaddr == 0xDEADBEEF)){\n        retaddr = GETPC();\n    }\n\n    panda_callbacks_mem_before_write(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)val, (void *)haddr);\n    helper_be_st_name(env, addr, val, oi, retaddr);\n    panda_callbacks_mem_after_write(cpu, panda_current_pc(cpu), addr, DATA_SIZE, (uint64_t)val, (void *)haddr);\n}\n\n#endif /* DATA_SIZE > 1 */\n#endif /* !defined(SOFTMMU_CODE_ACCESS) */\n\n#undef READ_ACCESS_TYPE\n#undef DATA_TYPE\n#undef SUFFIX\n#undef LSUFFIX\n#undef DATA_SIZE\n#undef ADDR_READ\n#undef WORD_TYPE\n#undef SDATA_TYPE\n#undef USUFFIX\n#undef SSUFFIX\n#undef BSWAP\n#undef helper_le_ld_name\n#undef helper_be_ld_name\n#undef helper_le_lds_name\n#undef helper_be_lds_name\n#undef helper_le_st_name\n#undef helper_be_st_name\n"
        },
        {
          "name": "spice-qemu-char.c",
          "type": "blob",
          "size": 10.89453125,
          "content": "#include \"qemu/osdep.h\"\n#include \"trace-root.h\"\n#include \"ui/qemu-spice.h\"\n#include \"sysemu/char.h\"\n#include \"qemu/error-report.h\"\n#include <spice.h>\n#include <spice/protocol.h>\n\n\ntypedef struct SpiceChardev {\n    Chardev               parent;\n\n    SpiceCharDeviceInstance sin;\n    bool                  active;\n    bool                  blocked;\n    const uint8_t         *datapos;\n    int                   datalen;\n    QLIST_ENTRY(SpiceChardev) next;\n} SpiceChardev;\n\n#define TYPE_CHARDEV_SPICE \"chardev-spice\"\n#define TYPE_CHARDEV_SPICEVMC \"chardev-spicevmc\"\n#define TYPE_CHARDEV_SPICEPORT \"chardev-spiceport\"\n\n#define SPICE_CHARDEV(obj) OBJECT_CHECK(SpiceChardev, (obj), TYPE_CHARDEV_SPICE)\n\ntypedef struct SpiceCharSource {\n    GSource               source;\n    SpiceChardev       *scd;\n} SpiceCharSource;\n\nstatic QLIST_HEAD(, SpiceChardev) spice_chars =\n    QLIST_HEAD_INITIALIZER(spice_chars);\n\nstatic int vmc_write(SpiceCharDeviceInstance *sin, const uint8_t *buf, int len)\n{\n    SpiceChardev *scd = container_of(sin, SpiceChardev, sin);\n    Chardev *chr = CHARDEV(scd);\n    ssize_t out = 0;\n    ssize_t last_out;\n    uint8_t* p = (uint8_t*)buf;\n\n    while (len > 0) {\n        int can_write = qemu_chr_be_can_write(chr);\n        last_out = MIN(len, can_write);\n        if (last_out <= 0) {\n            break;\n        }\n        qemu_chr_be_write(chr, p, last_out);\n        out += last_out;\n        len -= last_out;\n        p += last_out;\n    }\n\n    trace_spice_vmc_write(out, len + out);\n    return out;\n}\n\nstatic int vmc_read(SpiceCharDeviceInstance *sin, uint8_t *buf, int len)\n{\n    SpiceChardev *scd = container_of(sin, SpiceChardev, sin);\n    int bytes = MIN(len, scd->datalen);\n\n    if (bytes > 0) {\n        memcpy(buf, scd->datapos, bytes);\n        scd->datapos += bytes;\n        scd->datalen -= bytes;\n        assert(scd->datalen >= 0);\n    }\n    if (scd->datalen == 0) {\n        scd->datapos = 0;\n        scd->blocked = false;\n    }\n    trace_spice_vmc_read(bytes, len);\n    return bytes;\n}\n\n#if SPICE_SERVER_VERSION >= 0x000c02\nstatic void vmc_event(SpiceCharDeviceInstance *sin, uint8_t event)\n{\n    SpiceChardev *scd = container_of(sin, SpiceChardev, sin);\n    Chardev *chr = CHARDEV(scd);\n    int chr_event;\n\n    switch (event) {\n    case SPICE_PORT_EVENT_BREAK:\n        chr_event = CHR_EVENT_BREAK;\n        break;\n    default:\n        return;\n    }\n\n    trace_spice_vmc_event(chr_event);\n    qemu_chr_be_event(chr, chr_event);\n}\n#endif\n\nstatic void vmc_state(SpiceCharDeviceInstance *sin, int connected)\n{\n    SpiceChardev *scd = container_of(sin, SpiceChardev, sin);\n    Chardev *chr = CHARDEV(scd);\n\n    if ((chr->be_open && connected) ||\n        (!chr->be_open && !connected)) {\n        return;\n    }\n\n    qemu_chr_be_event(chr,\n                      connected ? CHR_EVENT_OPENED : CHR_EVENT_CLOSED);\n}\n\nstatic SpiceCharDeviceInterface vmc_interface = {\n    .base.type          = SPICE_INTERFACE_CHAR_DEVICE,\n    .base.description   = \"spice virtual channel char device\",\n    .base.major_version = SPICE_INTERFACE_CHAR_DEVICE_MAJOR,\n    .base.minor_version = SPICE_INTERFACE_CHAR_DEVICE_MINOR,\n    .state              = vmc_state,\n    .write              = vmc_write,\n    .read               = vmc_read,\n#if SPICE_SERVER_VERSION >= 0x000c02\n    .event              = vmc_event,\n#endif\n#if SPICE_SERVER_VERSION >= 0x000c06\n    .flags              = SPICE_CHAR_DEVICE_NOTIFY_WRITABLE,\n#endif\n};\n\n\nstatic void vmc_register_interface(SpiceChardev *scd)\n{\n    if (scd->active) {\n        return;\n    }\n    scd->sin.base.sif = &vmc_interface.base;\n    qemu_spice_add_interface(&scd->sin.base);\n    scd->active = true;\n    trace_spice_vmc_register_interface(scd);\n}\n\nstatic void vmc_unregister_interface(SpiceChardev *scd)\n{\n    if (!scd->active) {\n        return;\n    }\n    spice_server_remove_interface(&scd->sin.base);\n    scd->active = false;\n    trace_spice_vmc_unregister_interface(scd);\n}\n\nstatic gboolean spice_char_source_prepare(GSource *source, gint *timeout)\n{\n    SpiceCharSource *src = (SpiceCharSource *)source;\n\n    *timeout = -1;\n\n    return !src->scd->blocked;\n}\n\nstatic gboolean spice_char_source_check(GSource *source)\n{\n    SpiceCharSource *src = (SpiceCharSource *)source;\n\n    return !src->scd->blocked;\n}\n\nstatic gboolean spice_char_source_dispatch(GSource *source,\n    GSourceFunc callback, gpointer user_data)\n{\n    GIOFunc func = (GIOFunc)callback;\n\n    return func(NULL, G_IO_OUT, user_data);\n}\n\nstatic GSourceFuncs SpiceCharSourceFuncs = {\n    .prepare  = spice_char_source_prepare,\n    .check    = spice_char_source_check,\n    .dispatch = spice_char_source_dispatch,\n};\n\nstatic GSource *spice_chr_add_watch(Chardev *chr, GIOCondition cond)\n{\n    SpiceChardev *scd = SPICE_CHARDEV(chr);\n    SpiceCharSource *src;\n\n    assert(cond & G_IO_OUT);\n\n    src = (SpiceCharSource *)g_source_new(&SpiceCharSourceFuncs,\n                                          sizeof(SpiceCharSource));\n    src->scd = scd;\n\n    return (GSource *)src;\n}\n\nstatic int spice_chr_write(Chardev *chr, const uint8_t *buf, int len)\n{\n    SpiceChardev *s = SPICE_CHARDEV(chr);\n    int read_bytes;\n\n    assert(s->datalen == 0);\n    s->datapos = buf;\n    s->datalen = len;\n    spice_server_char_device_wakeup(&s->sin);\n    read_bytes = len - s->datalen;\n    if (read_bytes != len) {\n        /* We'll get passed in the unconsumed data with the next call */\n        s->datalen = 0;\n        s->datapos = NULL;\n        s->blocked = true;\n    }\n    return read_bytes;\n}\n\nstatic void char_spice_finalize(Object *obj)\n{\n    SpiceChardev *s = SPICE_CHARDEV(obj);\n\n    vmc_unregister_interface(s);\n\n    if (s->next.le_prev) {\n        QLIST_REMOVE(s, next);\n    }\n\n    g_free((char *)s->sin.subtype);\n#if SPICE_SERVER_VERSION >= 0x000c02\n    g_free((char *)s->sin.portname);\n#endif\n}\n\nstatic void spice_vmc_set_fe_open(struct Chardev *chr, int fe_open)\n{\n    SpiceChardev *s = SPICE_CHARDEV(chr);\n    if (fe_open) {\n        vmc_register_interface(s);\n    } else {\n        vmc_unregister_interface(s);\n    }\n}\n\nstatic void spice_port_set_fe_open(struct Chardev *chr, int fe_open)\n{\n#if SPICE_SERVER_VERSION >= 0x000c02\n    SpiceChardev *s = SPICE_CHARDEV(chr);\n\n    if (fe_open) {\n        spice_server_port_event(&s->sin, SPICE_PORT_EVENT_OPENED);\n    } else {\n        spice_server_port_event(&s->sin, SPICE_PORT_EVENT_CLOSED);\n    }\n#endif\n}\n\nstatic void spice_chr_accept_input(struct Chardev *chr)\n{\n    SpiceChardev *s = SPICE_CHARDEV(chr);\n\n    spice_server_char_device_wakeup(&s->sin);\n}\n\nstatic void chr_open(Chardev *chr, const char *subtype)\n{\n    SpiceChardev *s = SPICE_CHARDEV(chr);\n\n    s->active = false;\n    s->sin.subtype = g_strdup(subtype);\n\n    QLIST_INSERT_HEAD(&spice_chars, s, next);\n}\n\nstatic void qemu_chr_open_spice_vmc(Chardev *chr,\n                                    ChardevBackend *backend,\n                                    bool *be_opened,\n                                    Error **errp)\n{\n    ChardevSpiceChannel *spicevmc = backend->u.spicevmc.data;\n    const char *type = spicevmc->type;\n    const char **psubtype = spice_server_char_device_recognized_subtypes();\n\n    for (; *psubtype != NULL; ++psubtype) {\n        if (strcmp(type, *psubtype) == 0) {\n            break;\n        }\n    }\n    if (*psubtype == NULL) {\n        char *subtypes = g_strjoinv(\", \",\n            (gchar **)spice_server_char_device_recognized_subtypes());\n\n        error_setg(errp, \"unsupported type name: %s\", type);\n        error_append_hint(errp, \"allowed spice char type names: %s\\n\",\n                          subtypes);\n\n        g_free(subtypes);\n        return;\n    }\n\n    *be_opened = false;\n    chr_open(chr, type);\n}\n\n#if SPICE_SERVER_VERSION >= 0x000c02\nstatic void qemu_chr_open_spice_port(Chardev *chr,\n                                     ChardevBackend *backend,\n                                     bool *be_opened,\n                                     Error **errp)\n{\n    ChardevSpicePort *spiceport = backend->u.spiceport.data;\n    const char *name = spiceport->fqdn;\n    SpiceChardev *s;\n\n    if (name == NULL) {\n        error_setg(errp, \"missing name parameter\");\n        return;\n    }\n\n    chr_open(chr, \"port\");\n\n    *be_opened = false;\n    s = SPICE_CHARDEV(chr);\n    s->sin.portname = g_strdup(name);\n}\n\nvoid qemu_spice_register_ports(void)\n{\n    SpiceChardev *s;\n\n    QLIST_FOREACH(s, &spice_chars, next) {\n        if (s->sin.portname == NULL) {\n            continue;\n        }\n        vmc_register_interface(s);\n    }\n}\n#endif\n\nstatic void qemu_chr_parse_spice_vmc(QemuOpts *opts, ChardevBackend *backend,\n                                     Error **errp)\n{\n    const char *name = qemu_opt_get(opts, \"name\");\n    ChardevSpiceChannel *spicevmc;\n\n    if (name == NULL) {\n        error_setg(errp, \"chardev: spice channel: no name given\");\n        return;\n    }\n    backend->type = CHARDEV_BACKEND_KIND_SPICEVMC;\n    spicevmc = backend->u.spicevmc.data = g_new0(ChardevSpiceChannel, 1);\n    qemu_chr_parse_common(opts, qapi_ChardevSpiceChannel_base(spicevmc));\n    spicevmc->type = g_strdup(name);\n}\n\nstatic void qemu_chr_parse_spice_port(QemuOpts *opts, ChardevBackend *backend,\n                                      Error **errp)\n{\n    const char *name = qemu_opt_get(opts, \"name\");\n    ChardevSpicePort *spiceport;\n\n    if (name == NULL) {\n        error_setg(errp, \"chardev: spice port: no name given\");\n        return;\n    }\n    backend->type = CHARDEV_BACKEND_KIND_SPICEPORT;\n    spiceport = backend->u.spiceport.data = g_new0(ChardevSpicePort, 1);\n    qemu_chr_parse_common(opts, qapi_ChardevSpicePort_base(spiceport));\n    spiceport->fqdn = g_strdup(name);\n}\n\nstatic void char_spice_class_init(ObjectClass *oc, void *data)\n{\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n    cc->chr_write = spice_chr_write;\n    cc->chr_add_watch = spice_chr_add_watch;\n    cc->chr_accept_input = spice_chr_accept_input;\n}\n\nstatic const TypeInfo char_spice_type_info = {\n    .name = TYPE_CHARDEV_SPICE,\n    .parent = TYPE_CHARDEV,\n    .instance_size = sizeof(SpiceChardev),\n    .instance_finalize = char_spice_finalize,\n    .class_init = char_spice_class_init,\n    .abstract = true,\n};\n\nstatic void char_spicevmc_class_init(ObjectClass *oc, void *data)\n{\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n    cc->parse = qemu_chr_parse_spice_vmc;\n    cc->open = qemu_chr_open_spice_vmc;\n    cc->chr_set_fe_open = spice_vmc_set_fe_open;\n}\n\nstatic const TypeInfo char_spicevmc_type_info = {\n    .name = TYPE_CHARDEV_SPICEVMC,\n    .parent = TYPE_CHARDEV_SPICE,\n    .class_init = char_spicevmc_class_init,\n};\n\nstatic void char_spiceport_class_init(ObjectClass *oc, void *data)\n{\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n    cc->parse = qemu_chr_parse_spice_port;\n    cc->open = qemu_chr_open_spice_port;\n    cc->chr_set_fe_open = spice_port_set_fe_open;\n}\n\nstatic const TypeInfo char_spiceport_type_info = {\n    .name = TYPE_CHARDEV_SPICEPORT,\n    .parent = TYPE_CHARDEV_SPICE,\n    .class_init = char_spiceport_class_init,\n};\n\nstatic void register_types(void)\n{\n    type_register_static(&char_spice_type_info);\n    type_register_static(&char_spicevmc_type_info);\n    type_register_static(&char_spiceport_type_info);\n}\n\ntype_init(register_types);\n"
        },
        {
          "name": "stubs",
          "type": "tree",
          "content": null
        },
        {
          "name": "target",
          "type": "tree",
          "content": null
        },
        {
          "name": "tcg-runtime.c",
          "type": "blob",
          "size": 4.671875,
          "content": "/*\n * Tiny Code Generator for QEMU\n *\n * Copyright (c) 2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include \"qemu/osdep.h\"\n#include \"qemu/host-utils.h\"\n#include \"cpu.h\"\n#include \"exec/helper-proto.h\"\n#include \"exec/cpu_ldst.h\"\n#include \"exec/exec-all.h\"\n\n/* 32-bit helpers */\n\nint32_t HELPER(div_i32)(int32_t arg1, int32_t arg2)\n{\n    return arg1 / arg2;\n}\n\nint32_t HELPER(rem_i32)(int32_t arg1, int32_t arg2)\n{\n    return arg1 % arg2;\n}\n\nuint32_t HELPER(divu_i32)(uint32_t arg1, uint32_t arg2)\n{\n    return arg1 / arg2;\n}\n\nuint32_t HELPER(remu_i32)(uint32_t arg1, uint32_t arg2)\n{\n    return arg1 % arg2;\n}\n\n/* 64-bit helpers */\n\nuint64_t HELPER(shl_i64)(uint64_t arg1, uint64_t arg2)\n{\n    return arg1 << arg2;\n}\n\nuint64_t HELPER(shr_i64)(uint64_t arg1, uint64_t arg2)\n{\n    return arg1 >> arg2;\n}\n\nint64_t HELPER(sar_i64)(int64_t arg1, int64_t arg2)\n{\n    return arg1 >> arg2;\n}\n\nint64_t HELPER(div_i64)(int64_t arg1, int64_t arg2)\n{\n    return arg1 / arg2;\n}\n\nint64_t HELPER(rem_i64)(int64_t arg1, int64_t arg2)\n{\n    return arg1 % arg2;\n}\n\nuint64_t HELPER(divu_i64)(uint64_t arg1, uint64_t arg2)\n{\n    return arg1 / arg2;\n}\n\nuint64_t HELPER(remu_i64)(uint64_t arg1, uint64_t arg2)\n{\n    return arg1 % arg2;\n}\n\nuint64_t HELPER(muluh_i64)(uint64_t arg1, uint64_t arg2)\n{\n    uint64_t l, h;\n    mulu64(&l, &h, arg1, arg2);\n    return h;\n}\n\nint64_t HELPER(mulsh_i64)(int64_t arg1, int64_t arg2)\n{\n    uint64_t l, h;\n    muls64(&l, &h, arg1, arg2);\n    return h;\n}\n\nuint32_t HELPER(clz_i32)(uint32_t arg, uint32_t zero_val)\n{\n    return arg ? clz32(arg) : zero_val;\n}\n\nuint32_t HELPER(ctz_i32)(uint32_t arg, uint32_t zero_val)\n{\n    return arg ? ctz32(arg) : zero_val;\n}\n\nuint64_t HELPER(clz_i64)(uint64_t arg, uint64_t zero_val)\n{\n    return arg ? clz64(arg) : zero_val;\n}\n\nuint64_t HELPER(ctz_i64)(uint64_t arg, uint64_t zero_val)\n{\n    return arg ? ctz64(arg) : zero_val;\n}\n\nuint32_t HELPER(clrsb_i32)(uint32_t arg)\n{\n    return clrsb32(arg);\n}\n\nuint64_t HELPER(clrsb_i64)(uint64_t arg)\n{\n    return clrsb64(arg);\n}\n\nuint32_t HELPER(ctpop_i32)(uint32_t arg)\n{\n    return ctpop32(arg);\n}\n\nuint64_t HELPER(ctpop_i64)(uint64_t arg)\n{\n    return ctpop64(arg);\n}\n\nvoid HELPER(exit_atomic)(CPUArchState *env)\n{\n    cpu_loop_exit_atomic(ENV_GET_CPU(env), GETPC());\n}\n\n#ifndef CONFIG_SOFTMMU\n/* The softmmu versions of these helpers are in cputlb.c.  */\n\n/* Do not allow unaligned operations to proceed.  Return the host address.  */\nstatic void *atomic_mmu_lookup(CPUArchState *env, target_ulong addr,\n                               int size, uintptr_t retaddr)\n{\n    /* Enforce qemu required alignment.  */\n    if (unlikely(addr & (size - 1))) {\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), retaddr);\n    }\n    return g2h(addr);\n}\n\n/* Macro to call the above, with local variables from the use context.  */\n#define ATOMIC_MMU_LOOKUP  atomic_mmu_lookup(env, addr, DATA_SIZE, GETPC())\n\n#define ATOMIC_NAME(X)   HELPER(glue(glue(atomic_ ## X, SUFFIX), END))\n#define EXTRA_ARGS\n\n#define DATA_SIZE 1\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 2\n#include \"atomic_template.h\"\n\n#define DATA_SIZE 4\n#include \"atomic_template.h\"\n\n#ifdef CONFIG_ATOMIC64\n#define DATA_SIZE 8\n#include \"atomic_template.h\"\n#endif\n\n/* The following is only callable from other helpers, and matches up\n   with the softmmu version.  */\n\n#ifdef CONFIG_ATOMIC128\n\n#undef EXTRA_ARGS\n#undef ATOMIC_NAME\n#undef ATOMIC_MMU_LOOKUP\n\n#define EXTRA_ARGS     , TCGMemOpIdx oi, uintptr_t retaddr\n#define ATOMIC_NAME(X) \\\n    HELPER(glue(glue(glue(atomic_ ## X, SUFFIX), END), _mmu))\n#define ATOMIC_MMU_LOOKUP  atomic_mmu_lookup(env, addr, DATA_SIZE, retaddr)\n\n#define DATA_SIZE 16\n#include \"atomic_template.h\"\n#endif /* CONFIG_ATOMIC128 */\n\n#endif /* !CONFIG_SOFTMMU */\n"
        },
        {
          "name": "tcg",
          "type": "tree",
          "content": null
        },
        {
          "name": "tci.c",
          "type": "blob",
          "size": 36.5615234375,
          "content": "/*\n * Tiny Code Interpreter for QEMU\n *\n * Copyright (c) 2009, 2011, 2016 Stefan Weil\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n\n/* Enable TCI assertions only when debugging TCG (and without NDEBUG defined).\n * Without assertions, the interpreter runs much faster. */\n#if defined(CONFIG_DEBUG_TCG)\n# define tci_assert(cond) assert(cond)\n#else\n# define tci_assert(cond) ((void)0)\n#endif\n\n#include \"qemu-common.h\"\n#include \"tcg/tcg.h\"           /* MAX_OPC_PARAM_IARGS */\n#include \"exec/cpu_ldst.h\"\n#include \"tcg-op.h\"\n\n/* Marker for missing code. */\n#define TODO() \\\n    do { \\\n        fprintf(stderr, \"TODO %s:%u: %s()\\n\", \\\n                __FILE__, __LINE__, __func__); \\\n        tcg_abort(); \\\n    } while (0)\n\n#if MAX_OPC_PARAM_IARGS != 5\n# error Fix needed, number of supported input arguments changed!\n#endif\n#if TCG_TARGET_REG_BITS == 32\ntypedef uint64_t (*helper_function)(tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong, tcg_target_ulong);\n#else\ntypedef uint64_t (*helper_function)(tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong, tcg_target_ulong,\n                                    tcg_target_ulong);\n#endif\n\nstatic tcg_target_ulong tci_reg[TCG_TARGET_NB_REGS];\n\nstatic tcg_target_ulong tci_read_reg(TCGReg index)\n{\n    tci_assert(index < ARRAY_SIZE(tci_reg));\n    return tci_reg[index];\n}\n\n#if TCG_TARGET_HAS_ext8s_i32 || TCG_TARGET_HAS_ext8s_i64\nstatic int8_t tci_read_reg8s(TCGReg index)\n{\n    return (int8_t)tci_read_reg(index);\n}\n#endif\n\n#if TCG_TARGET_HAS_ext16s_i32 || TCG_TARGET_HAS_ext16s_i64\nstatic int16_t tci_read_reg16s(TCGReg index)\n{\n    return (int16_t)tci_read_reg(index);\n}\n#endif\n\n#if TCG_TARGET_REG_BITS == 64\nstatic int32_t tci_read_reg32s(TCGReg index)\n{\n    return (int32_t)tci_read_reg(index);\n}\n#endif\n\nstatic uint8_t tci_read_reg8(TCGReg index)\n{\n    return (uint8_t)tci_read_reg(index);\n}\n\nstatic uint16_t tci_read_reg16(TCGReg index)\n{\n    return (uint16_t)tci_read_reg(index);\n}\n\nstatic uint32_t tci_read_reg32(TCGReg index)\n{\n    return (uint32_t)tci_read_reg(index);\n}\n\n#if TCG_TARGET_REG_BITS == 64\nstatic uint64_t tci_read_reg64(TCGReg index)\n{\n    return tci_read_reg(index);\n}\n#endif\n\nstatic void tci_write_reg(TCGReg index, tcg_target_ulong value)\n{\n    tci_assert(index < ARRAY_SIZE(tci_reg));\n    tci_assert(index != TCG_AREG0);\n    tci_assert(index != TCG_REG_CALL_STACK);\n    tci_reg[index] = value;\n}\n\n#if TCG_TARGET_REG_BITS == 64\nstatic void tci_write_reg32s(TCGReg index, int32_t value)\n{\n    tci_write_reg(index, value);\n}\n#endif\n\nstatic void tci_write_reg8(TCGReg index, uint8_t value)\n{\n    tci_write_reg(index, value);\n}\n\nstatic void tci_write_reg32(TCGReg index, uint32_t value)\n{\n    tci_write_reg(index, value);\n}\n\n#if TCG_TARGET_REG_BITS == 32\nstatic void tci_write_reg64(uint32_t high_index, uint32_t low_index,\n                            uint64_t value)\n{\n    tci_write_reg(low_index, value);\n    tci_write_reg(high_index, value >> 32);\n}\n#elif TCG_TARGET_REG_BITS == 64\nstatic void tci_write_reg64(TCGReg index, uint64_t value)\n{\n    tci_write_reg(index, value);\n}\n#endif\n\n#if TCG_TARGET_REG_BITS == 32\n/* Create a 64 bit value from two 32 bit values. */\nstatic uint64_t tci_uint64(uint32_t high, uint32_t low)\n{\n    return ((uint64_t)high << 32) + low;\n}\n#endif\n\n/* Read constant (native size) from bytecode. */\nstatic tcg_target_ulong tci_read_i(uint8_t **tb_ptr)\n{\n    tcg_target_ulong value = *(tcg_target_ulong *)(*tb_ptr);\n    *tb_ptr += sizeof(value);\n    return value;\n}\n\n/* Read unsigned constant (32 bit) from bytecode. */\nstatic uint32_t tci_read_i32(uint8_t **tb_ptr)\n{\n    uint32_t value = *(uint32_t *)(*tb_ptr);\n    *tb_ptr += sizeof(value);\n    return value;\n}\n\n/* Read signed constant (32 bit) from bytecode. */\nstatic int32_t tci_read_s32(uint8_t **tb_ptr)\n{\n    int32_t value = *(int32_t *)(*tb_ptr);\n    *tb_ptr += sizeof(value);\n    return value;\n}\n\n#if TCG_TARGET_REG_BITS == 64\n/* Read constant (64 bit) from bytecode. */\nstatic uint64_t tci_read_i64(uint8_t **tb_ptr)\n{\n    uint64_t value = *(uint64_t *)(*tb_ptr);\n    *tb_ptr += sizeof(value);\n    return value;\n}\n#endif\n\n/* Read indexed register (native size) from bytecode. */\nstatic tcg_target_ulong tci_read_r(uint8_t **tb_ptr)\n{\n    tcg_target_ulong value = tci_read_reg(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n\n/* Read indexed register (8 bit) from bytecode. */\nstatic uint8_t tci_read_r8(uint8_t **tb_ptr)\n{\n    uint8_t value = tci_read_reg8(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n\n#if TCG_TARGET_HAS_ext8s_i32 || TCG_TARGET_HAS_ext8s_i64\n/* Read indexed register (8 bit signed) from bytecode. */\nstatic int8_t tci_read_r8s(uint8_t **tb_ptr)\n{\n    int8_t value = tci_read_reg8s(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n#endif\n\n/* Read indexed register (16 bit) from bytecode. */\nstatic uint16_t tci_read_r16(uint8_t **tb_ptr)\n{\n    uint16_t value = tci_read_reg16(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n\n#if TCG_TARGET_HAS_ext16s_i32 || TCG_TARGET_HAS_ext16s_i64\n/* Read indexed register (16 bit signed) from bytecode. */\nstatic int16_t tci_read_r16s(uint8_t **tb_ptr)\n{\n    int16_t value = tci_read_reg16s(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n#endif\n\n/* Read indexed register (32 bit) from bytecode. */\nstatic uint32_t tci_read_r32(uint8_t **tb_ptr)\n{\n    uint32_t value = tci_read_reg32(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n\n#if TCG_TARGET_REG_BITS == 32\n/* Read two indexed registers (2 * 32 bit) from bytecode. */\nstatic uint64_t tci_read_r64(uint8_t **tb_ptr)\n{\n    uint32_t low = tci_read_r32(tb_ptr);\n    return tci_uint64(tci_read_r32(tb_ptr), low);\n}\n#elif TCG_TARGET_REG_BITS == 64\n/* Read indexed register (32 bit signed) from bytecode. */\nstatic int32_t tci_read_r32s(uint8_t **tb_ptr)\n{\n    int32_t value = tci_read_reg32s(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n\n/* Read indexed register (64 bit) from bytecode. */\nstatic uint64_t tci_read_r64(uint8_t **tb_ptr)\n{\n    uint64_t value = tci_read_reg64(**tb_ptr);\n    *tb_ptr += 1;\n    return value;\n}\n#endif\n\n/* Read indexed register(s) with target address from bytecode. */\nstatic target_ulong tci_read_ulong(uint8_t **tb_ptr)\n{\n    target_ulong taddr = tci_read_r(tb_ptr);\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n    taddr += (uint64_t)tci_read_r(tb_ptr) << 32;\n#endif\n    return taddr;\n}\n\n/* Read indexed register or constant (native size) from bytecode. */\nstatic tcg_target_ulong tci_read_ri(uint8_t **tb_ptr)\n{\n    tcg_target_ulong value;\n    TCGReg r = **tb_ptr;\n    *tb_ptr += 1;\n    if (r == TCG_CONST) {\n        value = tci_read_i(tb_ptr);\n    } else {\n        value = tci_read_reg(r);\n    }\n    return value;\n}\n\n/* Read indexed register or constant (32 bit) from bytecode. */\nstatic uint32_t tci_read_ri32(uint8_t **tb_ptr)\n{\n    uint32_t value;\n    TCGReg r = **tb_ptr;\n    *tb_ptr += 1;\n    if (r == TCG_CONST) {\n        value = tci_read_i32(tb_ptr);\n    } else {\n        value = tci_read_reg32(r);\n    }\n    return value;\n}\n\n#if TCG_TARGET_REG_BITS == 32\n/* Read two indexed registers or constants (2 * 32 bit) from bytecode. */\nstatic uint64_t tci_read_ri64(uint8_t **tb_ptr)\n{\n    uint32_t low = tci_read_ri32(tb_ptr);\n    return tci_uint64(tci_read_ri32(tb_ptr), low);\n}\n#elif TCG_TARGET_REG_BITS == 64\n/* Read indexed register or constant (64 bit) from bytecode. */\nstatic uint64_t tci_read_ri64(uint8_t **tb_ptr)\n{\n    uint64_t value;\n    TCGReg r = **tb_ptr;\n    *tb_ptr += 1;\n    if (r == TCG_CONST) {\n        value = tci_read_i64(tb_ptr);\n    } else {\n        value = tci_read_reg64(r);\n    }\n    return value;\n}\n#endif\n\nstatic tcg_target_ulong tci_read_label(uint8_t **tb_ptr)\n{\n    tcg_target_ulong label = tci_read_i(tb_ptr);\n    tci_assert(label != 0);\n    return label;\n}\n\nstatic bool tci_compare32(uint32_t u0, uint32_t u1, TCGCond condition)\n{\n    bool result = false;\n    int32_t i0 = u0;\n    int32_t i1 = u1;\n    switch (condition) {\n    case TCG_COND_EQ:\n        result = (u0 == u1);\n        break;\n    case TCG_COND_NE:\n        result = (u0 != u1);\n        break;\n    case TCG_COND_LT:\n        result = (i0 < i1);\n        break;\n    case TCG_COND_GE:\n        result = (i0 >= i1);\n        break;\n    case TCG_COND_LE:\n        result = (i0 <= i1);\n        break;\n    case TCG_COND_GT:\n        result = (i0 > i1);\n        break;\n    case TCG_COND_LTU:\n        result = (u0 < u1);\n        break;\n    case TCG_COND_GEU:\n        result = (u0 >= u1);\n        break;\n    case TCG_COND_LEU:\n        result = (u0 <= u1);\n        break;\n    case TCG_COND_GTU:\n        result = (u0 > u1);\n        break;\n    default:\n        TODO();\n    }\n    return result;\n}\n\nstatic bool tci_compare64(uint64_t u0, uint64_t u1, TCGCond condition)\n{\n    bool result = false;\n    int64_t i0 = u0;\n    int64_t i1 = u1;\n    switch (condition) {\n    case TCG_COND_EQ:\n        result = (u0 == u1);\n        break;\n    case TCG_COND_NE:\n        result = (u0 != u1);\n        break;\n    case TCG_COND_LT:\n        result = (i0 < i1);\n        break;\n    case TCG_COND_GE:\n        result = (i0 >= i1);\n        break;\n    case TCG_COND_LE:\n        result = (i0 <= i1);\n        break;\n    case TCG_COND_GT:\n        result = (i0 > i1);\n        break;\n    case TCG_COND_LTU:\n        result = (u0 < u1);\n        break;\n    case TCG_COND_GEU:\n        result = (u0 >= u1);\n        break;\n    case TCG_COND_LEU:\n        result = (u0 <= u1);\n        break;\n    case TCG_COND_GTU:\n        result = (u0 > u1);\n        break;\n    default:\n        TODO();\n    }\n    return result;\n}\n\n#ifdef CONFIG_SOFTMMU\n# define qemu_ld_ub \\\n    helper_ret_ldub_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_leuw \\\n    helper_le_lduw_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_leul \\\n    helper_le_ldul_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_leq \\\n    helper_le_ldq_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_beuw \\\n    helper_be_lduw_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_beul \\\n    helper_be_ldul_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_ld_beq \\\n    helper_be_ldq_mmu(env, taddr, oi, (uintptr_t)tb_ptr)\n# define qemu_st_b(X) \\\n    helper_ret_stb_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_lew(X) \\\n    helper_le_stw_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_lel(X) \\\n    helper_le_stl_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_leq(X) \\\n    helper_le_stq_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_bew(X) \\\n    helper_be_stw_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_bel(X) \\\n    helper_be_stl_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n# define qemu_st_beq(X) \\\n    helper_be_stq_mmu(env, taddr, X, oi, (uintptr_t)tb_ptr)\n#else\n# define qemu_ld_ub      ldub_p(g2h(taddr))\n# define qemu_ld_leuw    lduw_le_p(g2h(taddr))\n# define qemu_ld_leul    (uint32_t)ldl_le_p(g2h(taddr))\n# define qemu_ld_leq     ldq_le_p(g2h(taddr))\n# define qemu_ld_beuw    lduw_be_p(g2h(taddr))\n# define qemu_ld_beul    (uint32_t)ldl_be_p(g2h(taddr))\n# define qemu_ld_beq     ldq_be_p(g2h(taddr))\n# define qemu_st_b(X)    stb_p(g2h(taddr), X)\n# define qemu_st_lew(X)  stw_le_p(g2h(taddr), X)\n# define qemu_st_lel(X)  stl_le_p(g2h(taddr), X)\n# define qemu_st_leq(X)  stq_le_p(g2h(taddr), X)\n# define qemu_st_bew(X)  stw_be_p(g2h(taddr), X)\n# define qemu_st_bel(X)  stl_be_p(g2h(taddr), X)\n# define qemu_st_beq(X)  stq_be_p(g2h(taddr), X)\n#endif\n\n/* Interpret pseudo code in tb. */\nuintptr_t tcg_qemu_tb_exec(CPUArchState *env, uint8_t *tb_ptr)\n{\n    long tcg_temps[CPU_TEMP_BUF_NLONGS];\n    uintptr_t sp_value = (uintptr_t)(tcg_temps + CPU_TEMP_BUF_NLONGS);\n    uintptr_t ret = 0;\n\n    tci_reg[TCG_AREG0] = (tcg_target_ulong)env;\n    tci_reg[TCG_REG_CALL_STACK] = sp_value;\n    tci_assert(tb_ptr);\n\n    for (;;) {\n        TCGOpcode opc = tb_ptr[0];\n#if defined(CONFIG_DEBUG_TCG) && !defined(NDEBUG)\n        uint8_t op_size = tb_ptr[1];\n        uint8_t *old_code_ptr = tb_ptr;\n#endif\n        tcg_target_ulong t0;\n        tcg_target_ulong t1;\n        tcg_target_ulong t2;\n        tcg_target_ulong label;\n        TCGCond condition;\n        target_ulong taddr;\n        uint8_t tmp8;\n        uint16_t tmp16;\n        uint32_t tmp32;\n        uint64_t tmp64;\n#if TCG_TARGET_REG_BITS == 32\n        uint64_t v64;\n#endif\n        TCGMemOpIdx oi;\n\n#if defined(GETPC)\n        tci_tb_ptr = (uintptr_t)tb_ptr;\n#endif\n\n        /* Skip opcode and size entry. */\n        tb_ptr += 2;\n\n        switch (opc) {\n        case INDEX_op_call:\n            t0 = tci_read_ri(&tb_ptr);\n#if TCG_TARGET_REG_BITS == 32\n            tmp64 = ((helper_function)t0)(tci_read_reg(TCG_REG_R0),\n                                          tci_read_reg(TCG_REG_R1),\n                                          tci_read_reg(TCG_REG_R2),\n                                          tci_read_reg(TCG_REG_R3),\n                                          tci_read_reg(TCG_REG_R5),\n                                          tci_read_reg(TCG_REG_R6),\n                                          tci_read_reg(TCG_REG_R7),\n                                          tci_read_reg(TCG_REG_R8),\n                                          tci_read_reg(TCG_REG_R9),\n                                          tci_read_reg(TCG_REG_R10));\n            tci_write_reg(TCG_REG_R0, tmp64);\n            tci_write_reg(TCG_REG_R1, tmp64 >> 32);\n#else\n            tmp64 = ((helper_function)t0)(tci_read_reg(TCG_REG_R0),\n                                          tci_read_reg(TCG_REG_R1),\n                                          tci_read_reg(TCG_REG_R2),\n                                          tci_read_reg(TCG_REG_R3),\n                                          tci_read_reg(TCG_REG_R5));\n            tci_write_reg(TCG_REG_R0, tmp64);\n#endif\n            break;\n        case INDEX_op_br:\n            label = tci_read_label(&tb_ptr);\n            tci_assert(tb_ptr == old_code_ptr + op_size);\n            tb_ptr = (uint8_t *)label;\n            continue;\n        case INDEX_op_setcond_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            condition = *tb_ptr++;\n            tci_write_reg32(t0, tci_compare32(t1, t2, condition));\n            break;\n#if TCG_TARGET_REG_BITS == 32\n        case INDEX_op_setcond2_i32:\n            t0 = *tb_ptr++;\n            tmp64 = tci_read_r64(&tb_ptr);\n            v64 = tci_read_ri64(&tb_ptr);\n            condition = *tb_ptr++;\n            tci_write_reg32(t0, tci_compare64(tmp64, v64, condition));\n            break;\n#elif TCG_TARGET_REG_BITS == 64\n        case INDEX_op_setcond_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            condition = *tb_ptr++;\n            tci_write_reg64(t0, tci_compare64(t1, t2, condition));\n            break;\n#endif\n        case INDEX_op_mov_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n        case INDEX_op_movi_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_i32(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n\n            /* Load/store operations (32 bit). */\n\n        case INDEX_op_ld8u_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg8(t0, *(uint8_t *)(t1 + t2));\n            break;\n        case INDEX_op_ld8s_i32:\n        case INDEX_op_ld16u_i32:\n            TODO();\n            break;\n        case INDEX_op_ld16s_i32:\n            TODO();\n            break;\n        case INDEX_op_ld_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg32(t0, *(uint32_t *)(t1 + t2));\n            break;\n        case INDEX_op_st8_i32:\n            t0 = tci_read_r8(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            *(uint8_t *)(t1 + t2) = t0;\n            break;\n        case INDEX_op_st16_i32:\n            t0 = tci_read_r16(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            *(uint16_t *)(t1 + t2) = t0;\n            break;\n        case INDEX_op_st_i32:\n            t0 = tci_read_r32(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_assert(t1 != sp_value || (int32_t)t2 < 0);\n            *(uint32_t *)(t1 + t2) = t0;\n            break;\n\n            /* Arithmetic operations (32 bit). */\n\n        case INDEX_op_add_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 + t2);\n            break;\n        case INDEX_op_sub_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 - t2);\n            break;\n        case INDEX_op_mul_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 * t2);\n            break;\n#if TCG_TARGET_HAS_div_i32\n        case INDEX_op_div_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, (int32_t)t1 / (int32_t)t2);\n            break;\n        case INDEX_op_divu_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 / t2);\n            break;\n        case INDEX_op_rem_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, (int32_t)t1 % (int32_t)t2);\n            break;\n        case INDEX_op_remu_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 % t2);\n            break;\n#elif TCG_TARGET_HAS_div2_i32\n        case INDEX_op_div2_i32:\n        case INDEX_op_divu2_i32:\n            TODO();\n            break;\n#endif\n        case INDEX_op_and_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 & t2);\n            break;\n        case INDEX_op_or_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 | t2);\n            break;\n        case INDEX_op_xor_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 ^ t2);\n            break;\n\n            /* Shift/rotate operations (32 bit). */\n\n        case INDEX_op_shl_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 << (t2 & 31));\n            break;\n        case INDEX_op_shr_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, t1 >> (t2 & 31));\n            break;\n        case INDEX_op_sar_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, ((int32_t)t1 >> (t2 & 31)));\n            break;\n#if TCG_TARGET_HAS_rot_i32\n        case INDEX_op_rotl_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, rol32(t1, t2 & 31));\n            break;\n        case INDEX_op_rotr_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri32(&tb_ptr);\n            t2 = tci_read_ri32(&tb_ptr);\n            tci_write_reg32(t0, ror32(t1, t2 & 31));\n            break;\n#endif\n#if TCG_TARGET_HAS_deposit_i32\n        case INDEX_op_deposit_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            t2 = tci_read_r32(&tb_ptr);\n            tmp16 = *tb_ptr++;\n            tmp8 = *tb_ptr++;\n            tmp32 = (((1 << tmp8) - 1) << tmp16);\n            tci_write_reg32(t0, (t1 & ~tmp32) | ((t2 << tmp16) & tmp32));\n            break;\n#endif\n        case INDEX_op_brcond_i32:\n            t0 = tci_read_r32(&tb_ptr);\n            t1 = tci_read_ri32(&tb_ptr);\n            condition = *tb_ptr++;\n            label = tci_read_label(&tb_ptr);\n            if (tci_compare32(t0, t1, condition)) {\n                tci_assert(tb_ptr == old_code_ptr + op_size);\n                tb_ptr = (uint8_t *)label;\n                continue;\n            }\n            break;\n#if TCG_TARGET_REG_BITS == 32\n        case INDEX_op_add2_i32:\n            t0 = *tb_ptr++;\n            t1 = *tb_ptr++;\n            tmp64 = tci_read_r64(&tb_ptr);\n            tmp64 += tci_read_r64(&tb_ptr);\n            tci_write_reg64(t1, t0, tmp64);\n            break;\n        case INDEX_op_sub2_i32:\n            t0 = *tb_ptr++;\n            t1 = *tb_ptr++;\n            tmp64 = tci_read_r64(&tb_ptr);\n            tmp64 -= tci_read_r64(&tb_ptr);\n            tci_write_reg64(t1, t0, tmp64);\n            break;\n        case INDEX_op_brcond2_i32:\n            tmp64 = tci_read_r64(&tb_ptr);\n            v64 = tci_read_ri64(&tb_ptr);\n            condition = *tb_ptr++;\n            label = tci_read_label(&tb_ptr);\n            if (tci_compare64(tmp64, v64, condition)) {\n                tci_assert(tb_ptr == old_code_ptr + op_size);\n                tb_ptr = (uint8_t *)label;\n                continue;\n            }\n            break;\n        case INDEX_op_mulu2_i32:\n            t0 = *tb_ptr++;\n            t1 = *tb_ptr++;\n            t2 = tci_read_r32(&tb_ptr);\n            tmp64 = tci_read_r32(&tb_ptr);\n            tci_write_reg64(t1, t0, t2 * tmp64);\n            break;\n#endif /* TCG_TARGET_REG_BITS == 32 */\n#if TCG_TARGET_HAS_ext8s_i32\n        case INDEX_op_ext8s_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r8s(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext16s_i32\n        case INDEX_op_ext16s_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16s(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext8u_i32\n        case INDEX_op_ext8u_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r8(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext16u_i32\n        case INDEX_op_ext16u_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16(&tb_ptr);\n            tci_write_reg32(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_bswap16_i32\n        case INDEX_op_bswap16_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16(&tb_ptr);\n            tci_write_reg32(t0, bswap16(t1));\n            break;\n#endif\n#if TCG_TARGET_HAS_bswap32_i32\n        case INDEX_op_bswap32_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg32(t0, bswap32(t1));\n            break;\n#endif\n#if TCG_TARGET_HAS_not_i32\n        case INDEX_op_not_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg32(t0, ~t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_neg_i32\n        case INDEX_op_neg_i32:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg32(t0, -t1);\n            break;\n#endif\n#if TCG_TARGET_REG_BITS == 64\n        case INDEX_op_mov_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n        case INDEX_op_movi_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_i64(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n\n            /* Load/store operations (64 bit). */\n\n        case INDEX_op_ld8u_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg8(t0, *(uint8_t *)(t1 + t2));\n            break;\n        case INDEX_op_ld8s_i64:\n        case INDEX_op_ld16u_i64:\n        case INDEX_op_ld16s_i64:\n            TODO();\n            break;\n        case INDEX_op_ld32u_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg32(t0, *(uint32_t *)(t1 + t2));\n            break;\n        case INDEX_op_ld32s_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg32s(t0, *(int32_t *)(t1 + t2));\n            break;\n        case INDEX_op_ld_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_write_reg64(t0, *(uint64_t *)(t1 + t2));\n            break;\n        case INDEX_op_st8_i64:\n            t0 = tci_read_r8(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            *(uint8_t *)(t1 + t2) = t0;\n            break;\n        case INDEX_op_st16_i64:\n            t0 = tci_read_r16(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            *(uint16_t *)(t1 + t2) = t0;\n            break;\n        case INDEX_op_st32_i64:\n            t0 = tci_read_r32(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            *(uint32_t *)(t1 + t2) = t0;\n            break;\n        case INDEX_op_st_i64:\n            t0 = tci_read_r64(&tb_ptr);\n            t1 = tci_read_r(&tb_ptr);\n            t2 = tci_read_s32(&tb_ptr);\n            tci_assert(t1 != sp_value || (int32_t)t2 < 0);\n            *(uint64_t *)(t1 + t2) = t0;\n            break;\n\n            /* Arithmetic operations (64 bit). */\n\n        case INDEX_op_add_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 + t2);\n            break;\n        case INDEX_op_sub_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 - t2);\n            break;\n        case INDEX_op_mul_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 * t2);\n            break;\n#if TCG_TARGET_HAS_div_i64\n        case INDEX_op_div_i64:\n        case INDEX_op_divu_i64:\n        case INDEX_op_rem_i64:\n        case INDEX_op_remu_i64:\n            TODO();\n            break;\n#elif TCG_TARGET_HAS_div2_i64\n        case INDEX_op_div2_i64:\n        case INDEX_op_divu2_i64:\n            TODO();\n            break;\n#endif\n        case INDEX_op_and_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 & t2);\n            break;\n        case INDEX_op_or_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 | t2);\n            break;\n        case INDEX_op_xor_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 ^ t2);\n            break;\n\n            /* Shift/rotate operations (64 bit). */\n\n        case INDEX_op_shl_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 << (t2 & 63));\n            break;\n        case INDEX_op_shr_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, t1 >> (t2 & 63));\n            break;\n        case INDEX_op_sar_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, ((int64_t)t1 >> (t2 & 63)));\n            break;\n#if TCG_TARGET_HAS_rot_i64\n        case INDEX_op_rotl_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, rol64(t1, t2 & 63));\n            break;\n        case INDEX_op_rotr_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_ri64(&tb_ptr);\n            t2 = tci_read_ri64(&tb_ptr);\n            tci_write_reg64(t0, ror64(t1, t2 & 63));\n            break;\n#endif\n#if TCG_TARGET_HAS_deposit_i64\n        case INDEX_op_deposit_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            t2 = tci_read_r64(&tb_ptr);\n            tmp16 = *tb_ptr++;\n            tmp8 = *tb_ptr++;\n            tmp64 = (((1ULL << tmp8) - 1) << tmp16);\n            tci_write_reg64(t0, (t1 & ~tmp64) | ((t2 << tmp16) & tmp64));\n            break;\n#endif\n        case INDEX_op_brcond_i64:\n            t0 = tci_read_r64(&tb_ptr);\n            t1 = tci_read_ri64(&tb_ptr);\n            condition = *tb_ptr++;\n            label = tci_read_label(&tb_ptr);\n            if (tci_compare64(t0, t1, condition)) {\n                tci_assert(tb_ptr == old_code_ptr + op_size);\n                tb_ptr = (uint8_t *)label;\n                continue;\n            }\n            break;\n#if TCG_TARGET_HAS_ext8u_i64\n        case INDEX_op_ext8u_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r8(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext8s_i64\n        case INDEX_op_ext8s_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r8s(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext16s_i64\n        case INDEX_op_ext16s_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16s(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext16u_i64\n        case INDEX_op_ext16u_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_ext32s_i64\n        case INDEX_op_ext32s_i64:\n#endif\n        case INDEX_op_ext_i32_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32s(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#if TCG_TARGET_HAS_ext32u_i64\n        case INDEX_op_ext32u_i64:\n#endif\n        case INDEX_op_extu_i32_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg64(t0, t1);\n            break;\n#if TCG_TARGET_HAS_bswap16_i64\n        case INDEX_op_bswap16_i64:\n            TODO();\n            t0 = *tb_ptr++;\n            t1 = tci_read_r16(&tb_ptr);\n            tci_write_reg64(t0, bswap16(t1));\n            break;\n#endif\n#if TCG_TARGET_HAS_bswap32_i64\n        case INDEX_op_bswap32_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r32(&tb_ptr);\n            tci_write_reg64(t0, bswap32(t1));\n            break;\n#endif\n#if TCG_TARGET_HAS_bswap64_i64\n        case INDEX_op_bswap64_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            tci_write_reg64(t0, bswap64(t1));\n            break;\n#endif\n#if TCG_TARGET_HAS_not_i64\n        case INDEX_op_not_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            tci_write_reg64(t0, ~t1);\n            break;\n#endif\n#if TCG_TARGET_HAS_neg_i64\n        case INDEX_op_neg_i64:\n            t0 = *tb_ptr++;\n            t1 = tci_read_r64(&tb_ptr);\n            tci_write_reg64(t0, -t1);\n            break;\n#endif\n#endif /* TCG_TARGET_REG_BITS == 64 */\n\n            /* QEMU specific operations. */\n\n        case INDEX_op_exit_tb:\n            ret = *(uint64_t *)tb_ptr;\n            goto exit;\n            break;\n        case INDEX_op_goto_tb:\n            /* Jump address is aligned */\n            tb_ptr = QEMU_ALIGN_PTR_UP(tb_ptr, 4);\n            t0 = atomic_read((int32_t *)tb_ptr);\n            tb_ptr += sizeof(int32_t);\n            tci_assert(tb_ptr == old_code_ptr + op_size);\n            tb_ptr += (int32_t)t0;\n            continue;\n        case INDEX_op_qemu_ld_i32:\n            t0 = *tb_ptr++;\n            taddr = tci_read_ulong(&tb_ptr);\n            oi = tci_read_i(&tb_ptr);\n            switch (get_memop(oi) & (MO_BSWAP | MO_SSIZE)) {\n            case MO_UB:\n                tmp32 = qemu_ld_ub;\n                break;\n            case MO_SB:\n                tmp32 = (int8_t)qemu_ld_ub;\n                break;\n            case MO_LEUW:\n                tmp32 = qemu_ld_leuw;\n                break;\n            case MO_LESW:\n                tmp32 = (int16_t)qemu_ld_leuw;\n                break;\n            case MO_LEUL:\n                tmp32 = qemu_ld_leul;\n                break;\n            case MO_BEUW:\n                tmp32 = qemu_ld_beuw;\n                break;\n            case MO_BESW:\n                tmp32 = (int16_t)qemu_ld_beuw;\n                break;\n            case MO_BEUL:\n                tmp32 = qemu_ld_beul;\n                break;\n            default:\n                tcg_abort();\n            }\n            tci_write_reg(t0, tmp32);\n            break;\n        case INDEX_op_qemu_ld_i64:\n            t0 = *tb_ptr++;\n            if (TCG_TARGET_REG_BITS == 32) {\n                t1 = *tb_ptr++;\n            }\n            taddr = tci_read_ulong(&tb_ptr);\n            oi = tci_read_i(&tb_ptr);\n            switch (get_memop(oi) & (MO_BSWAP | MO_SSIZE)) {\n            case MO_UB:\n                tmp64 = qemu_ld_ub;\n                break;\n            case MO_SB:\n                tmp64 = (int8_t)qemu_ld_ub;\n                break;\n            case MO_LEUW:\n                tmp64 = qemu_ld_leuw;\n                break;\n            case MO_LESW:\n                tmp64 = (int16_t)qemu_ld_leuw;\n                break;\n            case MO_LEUL:\n                tmp64 = qemu_ld_leul;\n                break;\n            case MO_LESL:\n                tmp64 = (int32_t)qemu_ld_leul;\n                break;\n            case MO_LEQ:\n                tmp64 = qemu_ld_leq;\n                break;\n            case MO_BEUW:\n                tmp64 = qemu_ld_beuw;\n                break;\n            case MO_BESW:\n                tmp64 = (int16_t)qemu_ld_beuw;\n                break;\n            case MO_BEUL:\n                tmp64 = qemu_ld_beul;\n                break;\n            case MO_BESL:\n                tmp64 = (int32_t)qemu_ld_beul;\n                break;\n            case MO_BEQ:\n                tmp64 = qemu_ld_beq;\n                break;\n            default:\n                tcg_abort();\n            }\n            tci_write_reg(t0, tmp64);\n            if (TCG_TARGET_REG_BITS == 32) {\n                tci_write_reg(t1, tmp64 >> 32);\n            }\n            break;\n        case INDEX_op_qemu_st_i32:\n            t0 = tci_read_r(&tb_ptr);\n            taddr = tci_read_ulong(&tb_ptr);\n            oi = tci_read_i(&tb_ptr);\n            switch (get_memop(oi) & (MO_BSWAP | MO_SIZE)) {\n            case MO_UB:\n                qemu_st_b(t0);\n                break;\n            case MO_LEUW:\n                qemu_st_lew(t0);\n                break;\n            case MO_LEUL:\n                qemu_st_lel(t0);\n                break;\n            case MO_BEUW:\n                qemu_st_bew(t0);\n                break;\n            case MO_BEUL:\n                qemu_st_bel(t0);\n                break;\n            default:\n                tcg_abort();\n            }\n            break;\n        case INDEX_op_qemu_st_i64:\n            tmp64 = tci_read_r64(&tb_ptr);\n            taddr = tci_read_ulong(&tb_ptr);\n            oi = tci_read_i(&tb_ptr);\n            switch (get_memop(oi) & (MO_BSWAP | MO_SIZE)) {\n            case MO_UB:\n                qemu_st_b(tmp64);\n                break;\n            case MO_LEUW:\n                qemu_st_lew(tmp64);\n                break;\n            case MO_LEUL:\n                qemu_st_lel(tmp64);\n                break;\n            case MO_LEQ:\n                qemu_st_leq(tmp64);\n                break;\n            case MO_BEUW:\n                qemu_st_bew(tmp64);\n                break;\n            case MO_BEUL:\n                qemu_st_bel(tmp64);\n                break;\n            case MO_BEQ:\n                qemu_st_beq(tmp64);\n                break;\n            default:\n                tcg_abort();\n            }\n            break;\n        case INDEX_op_mb:\n            /* Ensure ordering for all kinds */\n            smp_mb();\n            break;\n        default:\n            TODO();\n            break;\n        }\n        tci_assert(tb_ptr == old_code_ptr + op_size);\n    }\nexit:\n    return ret;\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "thunk.c",
          "type": "blob",
          "size": 9.04296875,
          "content": "/*\n *  Generic thunking code to convert data between host and target CPU\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"qemu/osdep.h\"\n\n#include \"qemu.h\"\n#include \"exec/user/thunk.h\"\n\n//#define DEBUG\n\nstatic unsigned int max_struct_entries;\nStructEntry *struct_entries;\n\nstatic const argtype *thunk_type_next_ptr(const argtype *type_ptr);\n\nstatic inline const argtype *thunk_type_next(const argtype *type_ptr)\n{\n    int type;\n\n    type = *type_ptr++;\n    switch(type) {\n    case TYPE_CHAR:\n    case TYPE_SHORT:\n    case TYPE_INT:\n    case TYPE_LONGLONG:\n    case TYPE_ULONGLONG:\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n    case TYPE_OLDDEVT:\n        return type_ptr;\n    case TYPE_PTR:\n        return thunk_type_next_ptr(type_ptr);\n    case TYPE_ARRAY:\n        return thunk_type_next_ptr(type_ptr + 1);\n    case TYPE_STRUCT:\n        return type_ptr + 1;\n    default:\n        return NULL;\n    }\n}\n\nstatic const argtype *thunk_type_next_ptr(const argtype *type_ptr)\n{\n    return thunk_type_next(type_ptr);\n}\n\nvoid thunk_register_struct(int id, const char *name, const argtype *types)\n{\n    const argtype *type_ptr;\n    StructEntry *se;\n    int nb_fields, offset, max_align, align, size, i, j;\n\n    assert(id < max_struct_entries);\n    se = struct_entries + id;\n\n    /* first we count the number of fields */\n    type_ptr = types;\n    nb_fields = 0;\n    while (*type_ptr != TYPE_NULL) {\n        type_ptr = thunk_type_next(type_ptr);\n        nb_fields++;\n    }\n    se->field_types = types;\n    se->nb_fields = nb_fields;\n    se->name = name;\n#ifdef DEBUG\n    printf(\"struct %s: id=%d nb_fields=%d\\n\",\n           se->name, id, se->nb_fields);\n#endif\n    /* now we can alloc the data */\n\n    for(i = 0;i < 2; i++) {\n        offset = 0;\n        max_align = 1;\n        se->field_offsets[i] = malloc(nb_fields * sizeof(int));\n        type_ptr = se->field_types;\n        for(j = 0;j < nb_fields; j++) {\n            size = thunk_type_size(type_ptr, i);\n            align = thunk_type_align(type_ptr, i);\n            offset = (offset + align - 1) & ~(align - 1);\n            se->field_offsets[i][j] = offset;\n            offset += size;\n            if (align > max_align)\n                max_align = align;\n            type_ptr = thunk_type_next(type_ptr);\n        }\n        offset = (offset + max_align - 1) & ~(max_align - 1);\n        se->size[i] = offset;\n        se->align[i] = max_align;\n#ifdef DEBUG\n        printf(\"%s: size=%d align=%d\\n\",\n               i == THUNK_HOST ? \"host\" : \"target\", offset, max_align);\n#endif\n    }\n}\n\nvoid thunk_register_struct_direct(int id, const char *name,\n                                  const StructEntry *se1)\n{\n    StructEntry *se;\n\n    assert(id < max_struct_entries);\n    se = struct_entries + id;\n    *se = *se1;\n    se->name = name;\n}\n\n\n/* now we can define the main conversion functions */\nconst argtype *thunk_convert(void *dst, const void *src,\n                             const argtype *type_ptr, int to_host)\n{\n    int type;\n\n    type = *type_ptr++;\n    switch(type) {\n    case TYPE_CHAR:\n        *(uint8_t *)dst = *(uint8_t *)src;\n        break;\n    case TYPE_SHORT:\n        *(uint16_t *)dst = tswap16(*(uint16_t *)src);\n        break;\n    case TYPE_INT:\n        *(uint32_t *)dst = tswap32(*(uint32_t *)src);\n        break;\n    case TYPE_LONGLONG:\n    case TYPE_ULONGLONG:\n        *(uint64_t *)dst = tswap64(*(uint64_t *)src);\n        break;\n#if HOST_LONG_BITS == 32 && TARGET_ABI_BITS == 32\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        *(uint32_t *)dst = tswap32(*(uint32_t *)src);\n        break;\n#elif HOST_LONG_BITS == 64 && TARGET_ABI_BITS == 32\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        if (to_host) {\n            if (type == TYPE_LONG) {\n                /* sign extension */\n                *(uint64_t *)dst = (int32_t)tswap32(*(uint32_t *)src);\n            } else {\n                *(uint64_t *)dst = tswap32(*(uint32_t *)src);\n            }\n        } else {\n            *(uint32_t *)dst = tswap32(*(uint64_t *)src & 0xffffffff);\n        }\n        break;\n#elif HOST_LONG_BITS == 64 && TARGET_ABI_BITS == 64\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        *(uint64_t *)dst = tswap64(*(uint64_t *)src);\n        break;\n#elif HOST_LONG_BITS == 32 && TARGET_ABI_BITS == 64\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        if (to_host) {\n            *(uint32_t *)dst = tswap64(*(uint64_t *)src);\n        } else {\n            if (type == TYPE_LONG) {\n                /* sign extension */\n                *(uint64_t *)dst = tswap64(*(int32_t *)src);\n            } else {\n                *(uint64_t *)dst = tswap64(*(uint32_t *)src);\n            }\n        }\n        break;\n#else\n#warning unsupported conversion\n#endif\n    case TYPE_OLDDEVT:\n    {\n        uint64_t val = 0;\n        switch (thunk_type_size(type_ptr - 1, !to_host)) {\n        case 2:\n            val = *(uint16_t *)src;\n            break;\n        case 4:\n            val = *(uint32_t *)src;\n            break;\n        case 8:\n            val = *(uint64_t *)src;\n            break;\n        }\n        switch (thunk_type_size(type_ptr - 1, to_host)) {\n        case 2:\n            *(uint16_t *)dst = tswap16(val);\n            break;\n        case 4:\n            *(uint32_t *)dst = tswap32(val);\n            break;\n        case 8:\n            *(uint64_t *)dst = tswap64(val);\n            break;\n        }\n        break;\n    }\n    case TYPE_ARRAY:\n        {\n            int array_length, i, dst_size, src_size;\n            const uint8_t *s;\n            uint8_t  *d;\n\n            array_length = *type_ptr++;\n            dst_size = thunk_type_size(type_ptr, to_host);\n            src_size = thunk_type_size(type_ptr, 1 - to_host);\n            d = dst;\n            s = src;\n            for(i = 0;i < array_length; i++) {\n                thunk_convert(d, s, type_ptr, to_host);\n                d += dst_size;\n                s += src_size;\n            }\n            type_ptr = thunk_type_next(type_ptr);\n        }\n        break;\n    case TYPE_STRUCT:\n        {\n            int i;\n            const StructEntry *se;\n            const uint8_t *s;\n            uint8_t  *d;\n            const argtype *field_types;\n            const int *dst_offsets, *src_offsets;\n\n            assert(*type_ptr < max_struct_entries);\n            se = struct_entries + *type_ptr++;\n            if (se->convert[0] != NULL) {\n                /* specific conversion is needed */\n                (*se->convert[to_host])(dst, src);\n            } else {\n                /* standard struct conversion */\n                field_types = se->field_types;\n                dst_offsets = se->field_offsets[to_host];\n                src_offsets = se->field_offsets[1 - to_host];\n                d = dst;\n                s = src;\n                for(i = 0;i < se->nb_fields; i++) {\n                    field_types = thunk_convert(d + dst_offsets[i],\n                                                s + src_offsets[i],\n                                                field_types, to_host);\n                }\n            }\n        }\n        break;\n    default:\n        fprintf(stderr, \"Invalid type 0x%x\\n\", type);\n        break;\n    }\n    return type_ptr;\n}\n\n/* from em86 */\n\n/* Utility function: Table-driven functions to translate bitmasks\n * between host and target formats\n */\nunsigned int target_to_host_bitmask(unsigned int target_mask,\n                                    const bitmask_transtbl * trans_tbl)\n{\n    const bitmask_transtbl *btp;\n    unsigned int host_mask = 0;\n\n    for (btp = trans_tbl; btp->target_mask && btp->host_mask; btp++) {\n        if ((target_mask & btp->target_mask) == btp->target_bits) {\n            host_mask |= btp->host_bits;\n        }\n    }\n    return host_mask;\n}\n\nunsigned int host_to_target_bitmask(unsigned int host_mask,\n                                    const bitmask_transtbl * trans_tbl)\n{\n    const bitmask_transtbl *btp;\n    unsigned int target_mask = 0;\n\n    for (btp = trans_tbl; btp->target_mask && btp->host_mask; btp++) {\n        if ((host_mask & btp->host_mask) == btp->host_bits) {\n            target_mask |= btp->target_bits;\n        }\n    }\n    return target_mask;\n}\n\nint thunk_type_size_array(const argtype *type_ptr, int is_host)\n{\n    return thunk_type_size(type_ptr, is_host);\n}\n\nint thunk_type_align_array(const argtype *type_ptr, int is_host)\n{\n    return thunk_type_align(type_ptr, is_host);\n}\n\nvoid thunk_init(unsigned int max_structs)\n{\n    max_struct_entries = max_structs;\n    struct_entries = g_new0(StructEntry, max_structs);\n}\n"
        },
        {
          "name": "tpm.c",
          "type": "blob",
          "size": 7.5439453125,
          "content": "/*\n * TPM configuration\n *\n * Copyright (C) 2011-2013 IBM Corporation\n *\n * Authors:\n *  Stefan Berger    <stefanb@us.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n * Based on net.c\n */\n#include \"qemu/osdep.h\"\n\n#include \"qapi/qmp/qerror.h\"\n#include \"sysemu/tpm_backend.h\"\n#include \"sysemu/tpm.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/error-report.h\"\n#include \"qmp-commands.h\"\n\nstatic QLIST_HEAD(, TPMBackend) tpm_backends =\n    QLIST_HEAD_INITIALIZER(tpm_backends);\n\n\n#define TPM_MAX_MODELS      1\n#define TPM_MAX_DRIVERS     1\n\nstatic TPMDriverOps const *be_drivers[TPM_MAX_DRIVERS] = {\n    NULL,\n};\n\nstatic enum TpmModel tpm_models[TPM_MAX_MODELS] = {\n    TPM_MODEL__MAX,\n};\n\nint tpm_register_model(enum TpmModel model)\n{\n    int i;\n\n    for (i = 0; i < TPM_MAX_MODELS; i++) {\n        if (tpm_models[i] == TPM_MODEL__MAX) {\n            tpm_models[i] = model;\n            return 0;\n        }\n    }\n    error_report(\"Could not register TPM model\");\n    return 1;\n}\n\nstatic bool tpm_model_is_registered(enum TpmModel model)\n{\n    int i;\n\n    for (i = 0; i < TPM_MAX_MODELS; i++) {\n        if (tpm_models[i] == model) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst TPMDriverOps *tpm_get_backend_driver(const char *type)\n{\n    int i;\n\n    for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n        if (!strcmp(TpmType_lookup[be_drivers[i]->type], type)) {\n            return be_drivers[i];\n        }\n    }\n\n    return NULL;\n}\n\n#ifdef CONFIG_TPM\n\nint tpm_register_driver(const TPMDriverOps *tdo)\n{\n    int i;\n\n    for (i = 0; i < TPM_MAX_DRIVERS; i++) {\n        if (!be_drivers[i]) {\n            be_drivers[i] = tdo;\n            return 0;\n        }\n    }\n    error_report(\"Could not register TPM driver\");\n    return 1;\n}\n\n/*\n * Walk the list of available TPM backend drivers and display them on the\n * screen.\n */\nstatic void tpm_display_backend_drivers(void)\n{\n    int i;\n\n    fprintf(stderr, \"Supported TPM types (choose only one):\\n\");\n\n    for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n        fprintf(stderr, \"%12s   %s\\n\",\n                TpmType_lookup[be_drivers[i]->type], be_drivers[i]->desc());\n    }\n    fprintf(stderr, \"\\n\");\n}\n\n/*\n * Find the TPM with the given Id\n */\nTPMBackend *qemu_find_tpm(const char *id)\n{\n    TPMBackend *drv;\n\n    if (id) {\n        QLIST_FOREACH(drv, &tpm_backends, list) {\n            if (!strcmp(drv->id, id)) {\n                return drv;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic int configure_tpm(QemuOpts *opts)\n{\n    const char *value;\n    const char *id;\n    const TPMDriverOps *be;\n    TPMBackend *drv;\n    Error *local_err = NULL;\n\n    if (!QLIST_EMPTY(&tpm_backends)) {\n        error_report(\"Only one TPM is allowed.\");\n        return 1;\n    }\n\n    id = qemu_opts_id(opts);\n    if (id == NULL) {\n        error_report(QERR_MISSING_PARAMETER, \"id\");\n        return 1;\n    }\n\n    value = qemu_opt_get(opts, \"type\");\n    if (!value) {\n        error_report(QERR_MISSING_PARAMETER, \"type\");\n        tpm_display_backend_drivers();\n        return 1;\n    }\n\n    be = tpm_get_backend_driver(value);\n    if (be == NULL) {\n        error_report(QERR_INVALID_PARAMETER_VALUE,\n                     \"type\", \"a TPM backend type\");\n        tpm_display_backend_drivers();\n        return 1;\n    }\n\n    /* validate backend specific opts */\n    qemu_opts_validate(opts, be->opts, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return 1;\n    }\n\n    drv = be->create(opts, id);\n    if (!drv) {\n        return 1;\n    }\n\n    tpm_backend_open(drv, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return 1;\n    }\n\n    QLIST_INSERT_HEAD(&tpm_backends, drv, list);\n\n    return 0;\n}\n\nstatic int tpm_init_tpmdev(void *dummy, QemuOpts *opts, Error **errp)\n{\n    return configure_tpm(opts);\n}\n\n/*\n * Walk the list of TPM backend drivers that are in use and call their\n * destroy function to have them cleaned up.\n */\nvoid tpm_cleanup(void)\n{\n    TPMBackend *drv, *next;\n\n    QLIST_FOREACH_SAFE(drv, &tpm_backends, list, next) {\n        QLIST_REMOVE(drv, list);\n        tpm_backend_destroy(drv);\n    }\n}\n\n/*\n * Initialize the TPM. Process the tpmdev command line options describing the\n * TPM backend.\n */\nint tpm_init(void)\n{\n    if (qemu_opts_foreach(qemu_find_opts(\"tpmdev\"),\n                          tpm_init_tpmdev, NULL, NULL)) {\n        return -1;\n    }\n\n    atexit(tpm_cleanup);\n    return 0;\n}\n\n/*\n * Parse the TPM configuration options.\n * To display all available TPM backends the user may use '-tpmdev help'\n */\nint tpm_config_parse(QemuOptsList *opts_list, const char *optarg)\n{\n    QemuOpts *opts;\n\n    if (!strcmp(optarg, \"help\")) {\n        tpm_display_backend_drivers();\n        return -1;\n    }\n    opts = qemu_opts_parse_noisily(opts_list, optarg, true);\n    if (!opts) {\n        return -1;\n    }\n    return 0;\n}\n\n#endif /* CONFIG_TPM */\n\nstatic const TPMDriverOps *tpm_driver_find_by_type(enum TpmType type)\n{\n    int i;\n\n    for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n        if (be_drivers[i]->type == type) {\n            return be_drivers[i];\n        }\n    }\n    return NULL;\n}\n\nstatic TPMInfo *qmp_query_tpm_inst(TPMBackend *drv)\n{\n    TPMInfo *res = g_new0(TPMInfo, 1);\n    TPMPassthroughOptions *tpo;\n\n    res->id = g_strdup(drv->id);\n    res->model = drv->fe_model;\n    res->options = g_new0(TpmTypeOptions, 1);\n\n    switch (drv->ops->type) {\n    case TPM_TYPE_PASSTHROUGH:\n        res->options->type = TPM_TYPE_OPTIONS_KIND_PASSTHROUGH;\n        tpo = g_new0(TPMPassthroughOptions, 1);\n        res->options->u.passthrough.data = tpo;\n        if (drv->path) {\n            tpo->path = g_strdup(drv->path);\n            tpo->has_path = true;\n        }\n        if (drv->cancel_path) {\n            tpo->cancel_path = g_strdup(drv->cancel_path);\n            tpo->has_cancel_path = true;\n        }\n        break;\n    case TPM_TYPE__MAX:\n        break;\n    }\n\n    return res;\n}\n\n/*\n * Walk the list of active TPM backends and collect information about them\n * following the schema description in qapi-schema.json.\n */\nTPMInfoList *qmp_query_tpm(Error **errp)\n{\n    TPMBackend *drv;\n    TPMInfoList *info, *head = NULL, *cur_item = NULL;\n\n    QLIST_FOREACH(drv, &tpm_backends, list) {\n        if (!tpm_model_is_registered(drv->fe_model)) {\n            continue;\n        }\n        info = g_new0(TPMInfoList, 1);\n        info->value = qmp_query_tpm_inst(drv);\n\n        if (!cur_item) {\n            head = cur_item = info;\n        } else {\n            cur_item->next = info;\n            cur_item = info;\n        }\n    }\n\n    return head;\n}\n\nTpmTypeList *qmp_query_tpm_types(Error **errp)\n{\n    unsigned int i = 0;\n    TpmTypeList *head = NULL, *prev = NULL, *cur_item;\n\n    for (i = 0; i < TPM_TYPE__MAX; i++) {\n        if (!tpm_driver_find_by_type(i)) {\n            continue;\n        }\n        cur_item = g_new0(TpmTypeList, 1);\n        cur_item->value = i;\n\n        if (prev) {\n            prev->next = cur_item;\n        }\n        if (!head) {\n            head = cur_item;\n        }\n        prev = cur_item;\n    }\n\n    return head;\n}\n\nTpmModelList *qmp_query_tpm_models(Error **errp)\n{\n    unsigned int i = 0;\n    TpmModelList *head = NULL, *prev = NULL, *cur_item;\n\n    for (i = 0; i < TPM_MODEL__MAX; i++) {\n        if (!tpm_model_is_registered(i)) {\n            continue;\n        }\n        cur_item = g_new0(TpmModelList, 1);\n        cur_item->value = i;\n\n        if (prev) {\n            prev->next = cur_item;\n        }\n        if (!head) {\n            head = cur_item;\n        }\n        prev = cur_item;\n    }\n\n    return head;\n}\n"
        },
        {
          "name": "trace-events",
          "type": "blob",
          "size": 8.1650390625,
          "content": "# Trace events for debugging and performance instrumentation\n#\n# This file is processed by the tracetool script during the build.\n#\n# To add a new trace event:\n#\n# 1. Choose a name for the trace event.  Declare its arguments and format\n#    string.\n#\n# 2. Call the trace event from code using trace_##name, e.g. multiwrite_cb() ->\n#    trace_multiwrite_cb().  The source file must #include \"trace.h\".\n#\n# Format of a trace event:\n#\n# [disable] <name>(<type1> <arg1>[, <type2> <arg2>] ...) \"<format-string>\"\n#\n# Example: g_malloc(size_t size) \"size %zu\"\n#\n# The \"disable\" keyword will build without the trace event.\n#\n# The <name> must be a valid as a C function name.\n#\n# Types should be standard C types.  Use void * for pointers because the trace\n# system may not have the necessary headers included.\n#\n# The <format-string> should be a sprintf()-compatible format string.\n\n# ioport.c\ncpu_in(unsigned int addr, char size, unsigned int val) \"addr %#x(%c) value %u\"\ncpu_out(unsigned int addr, char size, unsigned int val) \"addr %#x(%c) value %u\"\n\n# balloon.c\n# Since requests are raised via monitor, not many tracepoints are needed.\nballoon_event(void *opaque, unsigned long addr) \"opaque %p addr %lu\"\n\n# vl.c\nvm_state_notify(int running, int reason) \"running %d reason %d\"\nload_file(const char *name, const char *path) \"name %s location %s\"\nrunstate_set(int new_state) \"new state %d\"\nsystem_wakeup_request(int reason) \"reason=%d\"\nqemu_system_shutdown_request(void) \"\"\nqemu_system_powerdown_request(void) \"\"\n\n# spice-qemu-char.c\nspice_vmc_write(ssize_t out, int len) \"spice wrote %zd of requested %d\"\nspice_vmc_read(int bytes, int len) \"spice read %d of requested %d\"\nspice_vmc_register_interface(void *scd) \"spice vmc registered interface %p\"\nspice_vmc_unregister_interface(void *scd) \"spice vmc unregistered interface %p\"\nspice_vmc_event(int event) \"spice vmc event %d\"\n\n# xen-hvm.c\nxen_ram_alloc(unsigned long ram_addr, unsigned long size) \"requested: %#lx, size %#lx\"\nxen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty) \"%#\"PRIx64\" size %#lx, log_dirty %i\"\nhandle_ioreq(void *req, uint32_t type, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size) \"I/O=%p type=%d dir=%d df=%d ptr=%d port=%#\"PRIx64\" data=%#\"PRIx64\" count=%d size=%d\"\nhandle_ioreq_read(void *req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size) \"I/O=%p read type=%d df=%d ptr=%d port=%#\"PRIx64\" data=%#\"PRIx64\" count=%d size=%d\"\nhandle_ioreq_write(void *req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size) \"I/O=%p write type=%d df=%d ptr=%d port=%#\"PRIx64\" data=%#\"PRIx64\" count=%d size=%d\"\ncpu_ioreq_pio(void *req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size) \"I/O=%p pio dir=%d df=%d ptr=%d port=%#\"PRIx64\" data=%#\"PRIx64\" count=%d size=%d\"\ncpu_ioreq_pio_read_reg(void *req, uint64_t data, uint64_t addr, uint32_t size) \"I/O=%p pio read reg data=%#\"PRIx64\" port=%#\"PRIx64\" size=%d\"\ncpu_ioreq_pio_write_reg(void *req, uint64_t data, uint64_t addr, uint32_t size) \"I/O=%p pio write reg data=%#\"PRIx64\" port=%#\"PRIx64\" size=%d\"\ncpu_ioreq_move(void *req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size) \"I/O=%p copy dir=%d df=%d ptr=%d port=%#\"PRIx64\" data=%#\"PRIx64\" count=%d size=%d\"\n\n# xen-mapcache.c\nxen_map_cache(uint64_t phys_addr) \"want %#\"PRIx64\nxen_remap_bucket(uint64_t index) \"index %#\"PRIx64\nxen_map_cache_return(void* ptr) \"%p\"\n\n# monitor.c\nmonitor_protocol_event_handler(uint32_t event, void *qdict) \"event=%d data=%p\"\nmonitor_protocol_event_emit(uint32_t event, void *data) \"event=%d data=%p\"\nmonitor_protocol_event_queue(uint32_t event, void *qdict, uint64_t rate) \"event=%d data=%p rate=%\" PRId64\n\n# dma-helpers.c\ndma_blk_io(void *dbs, void *bs, int64_t offset, bool to_dev) \"dbs=%p bs=%p offset=%\" PRId64 \" to_dev=%d\"\ndma_aio_cancel(void *dbs) \"dbs=%p\"\ndma_complete(void *dbs, int ret, void *cb) \"dbs=%p ret=%d cb=%p\"\ndma_blk_cb(void *dbs, int ret) \"dbs=%p ret=%d\"\ndma_map_wait(void *dbs) \"dbs=%p\"\n\n# kvm-all.c\nkvm_ioctl(int type, void *arg) \"type 0x%x, arg %p\"\nkvm_vm_ioctl(int type, void *arg) \"type 0x%x, arg %p\"\nkvm_vcpu_ioctl(int cpu_index, int type, void *arg) \"cpu_index %d, type 0x%x, arg %p\"\nkvm_run_exit(int cpu_index, uint32_t reason) \"cpu_index %d, reason %d\"\nkvm_device_ioctl(int fd, int type, void *arg) \"dev fd %d, type 0x%x, arg %p\"\nkvm_failed_reg_get(uint64_t id, const char *msg) \"Warning: Unable to retrieve ONEREG %\" PRIu64 \" from KVM: %s\"\nkvm_failed_reg_set(uint64_t id, const char *msg) \"Warning: Unable to set ONEREG %\" PRIu64 \" to KVM: %s\"\nkvm_irqchip_commit_routes(void) \"\"\nkvm_irqchip_add_msi_route(int virq) \"Adding MSI route virq=%d\"\nkvm_irqchip_update_msi_route(int virq) \"Updating MSI route virq=%d\"\n\n# TCG related tracing (mostly disabled by default)\n# cpu-exec.c\ndisable exec_tb(void *tb, uintptr_t pc) \"tb:%p pc=0x%\"PRIxPTR\ndisable exec_tb_nocache(void *tb, uintptr_t pc) \"tb:%p pc=0x%\"PRIxPTR\ndisable exec_tb_exit(void *last_tb, unsigned int flags) \"tb:%p flags=%x\"\n\n# translate-all.c\ntranslate_block(void *tb, uintptr_t pc, uint8_t *tb_code) \"tb:%p, pc:0x%\"PRIxPTR\", tb_code:%p\"\n\n# memory.c\nmemory_region_ops_read(int cpu_index, void *mr, uint64_t addr, uint64_t value, unsigned size) \"cpu %d mr %p addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_ops_write(int cpu_index, void *mr, uint64_t addr, uint64_t value, unsigned size) \"cpu %d mr %p addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_subpage_read(int cpu_index, void *mr, uint64_t offset, uint64_t value, unsigned size) \"cpu %d mr %p offset %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_subpage_write(int cpu_index, void *mr, uint64_t offset, uint64_t value, unsigned size) \"cpu %d mr %p offset %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_tb_read(int cpu_index, uint64_t addr, uint64_t value, unsigned size) \"cpu %d addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_tb_write(int cpu_index, uint64_t addr, uint64_t value, unsigned size) \"cpu %d addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_ram_device_read(int cpu_index, void *mr, uint64_t addr, uint64_t value, unsigned size) \"cpu %d mr %p addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\nmemory_region_ram_device_write(int cpu_index, void *mr, uint64_t addr, uint64_t value, unsigned size) \"cpu %d mr %p addr %#\"PRIx64\" value %#\"PRIx64\" size %u\"\n\n### Guest events, keep at bottom\n\n\n## vCPU\n\n# Hot-plug a new virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_enter(void)\n\n# Hot-unplug a virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_exit(void)\n\n# Reset the state of a virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_reset(void)\n\n# @vaddr: Access' virtual address.\n# @info : Access' information (see below).\n#\n# Start virtual memory access (before any potential access violation).\n#\n# Does not include memory accesses performed by devices.\n#\n# Access information can be parsed as:\n#\n# struct mem_info {\n#     uint8_t size_shift : 2; /* interpreted as \"1 << size_shift\" bytes */\n#     bool    sign_extend: 1; /* sign-extended */\n#     uint8_t endianness : 1; /* 0: little, 1: big */\n#     bool    store      : 1; /* wheter it's a store operation */\n# };\n#\n# Mode: user, softmmu\n# Targets: TCG(all)\ndisable vcpu tcg guest_mem_before(TCGv vaddr, uint8_t info) \"info=%d\", \"vaddr=0x%016\"PRIx64\" info=%d\"\n\n# @num: System call number.\n# @arg*: System call argument value.\n#\n# Start executing a guest system call in syscall emulation mode.\n#\n# Mode: user\n# Targets: TCG(all)\ndisable vcpu guest_user_syscall(uint64_t num, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8) \"num=0x%016\"PRIx64\" arg1=0x%016\"PRIx64\" arg2=0x%016\"PRIx64\" arg3=0x%016\"PRIx64\" arg4=0x%016\"PRIx64\" arg5=0x%016\"PRIx64\" arg6=0x%016\"PRIx64\" arg7=0x%016\"PRIx64\" arg8=0x%016\"PRIx64\n\n# @num: System call number.\n# @ret: System call result value.\n#\n# Finish executing a guest system call in syscall emulation mode.\n#\n# Mode: user\n# Targets: TCG(all)\ndisable vcpu guest_user_syscall_ret(uint64_t num, uint64_t ret) \"num=0x%016\"PRIx64\" ret=0x%016\"PRIx64\n"
        },
        {
          "name": "trace",
          "type": "tree",
          "content": null
        },
        {
          "name": "translate-all.c",
          "type": "blob",
          "size": 68.5537109375,
          "content": "/*\n *  Host code generation\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * The file was modified for S2E Selective Symbolic Execution Framework\n *\n * Copyright (c) 2010, Dependable Systems Laboratory, EPFL\n *\n * Currently maintained by:\n *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>\n *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>\n *\n * All contributors are listed in S2E-AUTHORS file.\n *\n */\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n#include \"qemu/osdep.h\"\n\n\n#include \"qemu-common.h\"\n#define NO_CPU_IO_DEFS\n#include \"cpu.h\"\n#include \"trace-root.h\"\n#include \"disas/disas.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg.h\"\n#if defined(CONFIG_USER_ONLY)\n#include \"qemu.h\"\n#include \"exec/exec-all.h\"\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\n#include <sys/param.h>\n#if __FreeBSD_version >= 700104\n#define HAVE_KINFO_GETVMMAP\n#define sigqueue sigqueue_freebsd  /* avoid redefinition */\n#include <sys/proc.h>\n#include <machine/profile.h>\n#define _KERNEL\n#include <sys/user.h>\n#undef _KERNEL\n#undef sigqueue\n#include <libutil.h>\n#endif\n#endif\n#else\n#include \"exec/address-spaces.h\"\n#endif\n\n#include \"exec/cputlb.h\"\n#include \"exec/tb-hash.h\"\n#include \"translate-all.h\"\n#include \"qemu/bitmap.h\"\n#include \"qemu/timer.h\"\n#include \"exec/log.h\"\n#include \"sysemu/cpus.h\"\n\n#ifdef CONFIG_LLVM\n#include \"panda/tcg-llvm.h\"\n#endif\n\n#include \"panda/rr/rr_log.h\"\n#include \"panda/callbacks/cb-support.h\"\n#include \"panda/tcg-utils.h\"\n\n/* #define DEBUG_TB_INVALIDATE */\n/* #define DEBUG_TB_FLUSH */\n/* make various TB consistency checks */\n/* #define DEBUG_TB_CHECK */\n\n#if !defined(CONFIG_USER_ONLY)\n/* TB consistency checks only implemented for usermode emulation.  */\n#undef DEBUG_TB_CHECK\n#endif\n\n/* Access to the various translations structures need to be serialised via locks\n * for consistency. This is automatic for SoftMMU based system\n * emulation due to its single threaded nature. In user-mode emulation\n * access to the memory related structures are protected with the\n * mmap_lock.\n */\n#ifdef CONFIG_SOFTMMU\n#define assert_memory_lock() tcg_debug_assert(have_tb_lock)\n#else\n#define assert_memory_lock() tcg_debug_assert(have_mmap_lock())\n#endif\n\n#define SMC_BITMAP_USE_THRESHOLD 10\n\ntypedef struct PageDesc {\n    /* list of TBs intersecting this ram page */\n    TranslationBlock *first_tb;\n#ifdef CONFIG_SOFTMMU\n    /* in order to optimize self modifying code, we count the number\n       of lookups we do to a given page to use a bitmap */\n    unsigned int code_write_count;\n    unsigned long *code_bitmap;\n#else\n    unsigned long flags;\n#endif\n} PageDesc;\n\n/* In system mode we want L1_MAP to be based on ram offsets,\n   while in user mode we want it to be based on virtual addresses.  */\n#if !defined(CONFIG_USER_ONLY)\n#if HOST_LONG_BITS < TARGET_PHYS_ADDR_SPACE_BITS\n# define L1_MAP_ADDR_SPACE_BITS  HOST_LONG_BITS\n#else\n# define L1_MAP_ADDR_SPACE_BITS  TARGET_PHYS_ADDR_SPACE_BITS\n#endif\n#else\n# define L1_MAP_ADDR_SPACE_BITS  TARGET_VIRT_ADDR_SPACE_BITS\n#endif\n\n/* Size of the L2 (and L3, etc) page tables.  */\n#define V_L2_BITS 10\n#define V_L2_SIZE (1 << V_L2_BITS)\n\nuintptr_t qemu_host_page_size;\nintptr_t qemu_host_page_mask;\n\n/*\n * L1 Mapping properties\n */\nstatic int v_l1_size;\nstatic int v_l1_shift;\nstatic int v_l2_levels;\n\n/* The bottom level has pointers to PageDesc, and is indexed by\n * anything from 4 to (V_L2_BITS + 3) bits, depending on target page size.\n */\n#define V_L1_MIN_BITS 4\n#define V_L1_MAX_BITS (V_L2_BITS + 3)\n#define V_L1_MAX_SIZE (1 << V_L1_MAX_BITS)\n\nstatic void *l1_map[V_L1_MAX_SIZE];\n\n/* code generation context */\nTCGContext tcg_ctx;\nbool parallel_cpus;\n\n/* translation block context */\n__thread int have_tb_lock;\n\nstatic void page_table_config_init(void)\n{\n    uint32_t v_l1_bits;\n\n    assert(TARGET_PAGE_BITS);\n    /* The bits remaining after N lower levels of page tables.  */\n    v_l1_bits = (L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS) % V_L2_BITS;\n    if (v_l1_bits < V_L1_MIN_BITS) {\n        v_l1_bits += V_L2_BITS;\n    }\n\n    v_l1_size = 1 << v_l1_bits;\n    v_l1_shift = L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS - v_l1_bits;\n    v_l2_levels = v_l1_shift / V_L2_BITS - 1;\n\n    assert(v_l1_bits <= V_L1_MAX_BITS);\n    assert(v_l1_shift % V_L2_BITS == 0);\n    assert(v_l2_levels >= 0);\n}\n\n#define assert_tb_locked() tcg_debug_assert(have_tb_lock)\n#define assert_tb_unlocked() tcg_debug_assert(!have_tb_lock)\n\nvoid tb_lock(void)\n{\n    assert_tb_unlocked();\n    qemu_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n    have_tb_lock++;\n}\n\nvoid tb_unlock(void)\n{\n    assert_tb_locked();\n    have_tb_lock--;\n    qemu_mutex_unlock(&tcg_ctx.tb_ctx.tb_lock);\n}\n\nvoid tb_lock_reset(void)\n{\n    if (have_tb_lock) {\n        qemu_mutex_unlock(&tcg_ctx.tb_ctx.tb_lock);\n        have_tb_lock = 0;\n    }\n}\n\nstatic TranslationBlock *tb_find_pc(uintptr_t tc_ptr);\n\nvoid cpu_gen_init(void)\n{\n    tcg_context_init(&tcg_ctx); \n}\n\n/* Encode VAL as a signed leb128 sequence at P.\n   Return P incremented past the encoded value.  */\nstatic uint8_t *encode_sleb128(uint8_t *p, target_long val)\n{\n    int more, byte;\n\n    do {\n        byte = val & 0x7f;\n        val >>= 7;\n        more = !((val == 0 && (byte & 0x40) == 0)\n                 || (val == -1 && (byte & 0x40) != 0));\n        if (more) {\n            byte |= 0x80;\n        }\n        *p++ = byte;\n    } while (more);\n\n    return p;\n}\n\n/* Decode a signed leb128 sequence at *PP; increment *PP past the\n   decoded value.  Return the decoded value.  */\nstatic target_long decode_sleb128(uint8_t **pp)\n{\n    uint8_t *p = *pp;\n    target_long val = 0;\n    int byte, shift = 0;\n\n    do {\n        byte = *p++;\n        val |= (target_ulong)(byte & 0x7f) << shift;\n        shift += 7;\n    } while (byte & 0x80);\n    if (shift < TARGET_LONG_BITS && (byte & 0x40)) {\n        val |= -(target_ulong)1 << shift;\n    }\n\n    *pp = p;\n    return val;\n}\n\n/* Encode the data collected about the instructions while compiling TB.\n   Place the data at BLOCK, and return the number of bytes consumed.\n\n   The logical table consisits of TARGET_INSN_START_WORDS target_ulong's,\n   which come from the target's insn_start data, followed by a uintptr_t\n   which comes from the host pc of the end of the code implementing the insn.\n\n   Each line of the table is encoded as sleb128 deltas from the previous\n   line.  The seed for the first line is { tb->pc, 0..., tb->tc_ptr }.\n   That is, the first column is seeded with the guest pc, the last column\n   with the host pc, and the middle columns with zeros.  */\n\nstatic int encode_search(TranslationBlock *tb, uint8_t *block)\n{\n    uint8_t *highwater = tcg_ctx.code_gen_highwater;\n    uint8_t *p = block;\n    int i, j, n;\n\n    tb->tc_search = block;\n\n    for (i = 0, n = tb->icount; i < n; ++i) {\n        target_ulong prev;\n\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            if (i == 0) {\n                prev = (j == 0 ? tb->pc : 0);\n            } else {\n                prev = tcg_ctx.gen_insn_data[i - 1][j];\n            }\n            p = encode_sleb128(p, tcg_ctx.gen_insn_data[i][j] - prev);\n        }\n        prev = (i == 0 ? 0 : tcg_ctx.gen_insn_end_off[i - 1]);\n        p = encode_sleb128(p, tcg_ctx.gen_insn_end_off[i] - prev);\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n           one row beginning below the high water mark cannot overrun\n           the buffer completely.  Thus we can test for overflow after\n           encoding a row without having to check during encoding.  */\n        if (unlikely(p > highwater)) {\n            return -1;\n        }\n    }\n\n    return p - block;\n}\n\n/* The cpu state corresponding to 'searched_pc' is restored.\n * Called with tb_lock held.\n */\nstatic int cpu_restore_state_from_tb(CPUState *cpu, TranslationBlock *tb,\n                                     uintptr_t searched_pc)\n{\n    target_ulong data[TARGET_INSN_START_WORDS] = { tb->pc };\n    uintptr_t host_pc = (uintptr_t)tb->tc_ptr;\n    CPUArchState *env = cpu->env_ptr;\n    uint8_t *p = tb->tc_search;\n    int i, j, num_insns = tb->icount;\n#ifdef CONFIG_PROFILER\n    int64_t ti = profile_getclock();\n#endif\n\n    searched_pc -= GETPC_ADJ;\n\n    panda_callbacks_cpu_restore_state(ENV_GET_CPU(env), tb);\n\n#if defined(CONFIG_LLVM)\n    target_ulong guest_pc = cpu->panda_guest_pc;\n    if (execute_llvm) {\n        assert(guest_pc >= tb->pc);\n        assert(guest_pc < tb->pc + tb->size);\n        for (i = 0; i < num_insns; ++i) {\n            for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n                data[j] += decode_sleb128(&p);\n            }\n            decode_sleb128(&p); // throw away value\n            if (data[0] >= guest_pc) {\n                goto found;\n            }\n        }\n        return -1;\n    }\n#endif\n\n    if (searched_pc < host_pc) {\n        return -1;\n    }\n\n    /* Reconstruct the stored insn data while looking for the point at\n       which the end of the insn exceeds the searched_pc.  */\n    for (i = 0; i < num_insns; ++i) {\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            data[j] += decode_sleb128(&p);\n        }\n        host_pc += decode_sleb128(&p);\n        if (host_pc > searched_pc) {\n            goto found;\n        }\n    }\n    return -1;\n\n found:\n    if (tb->cflags & CF_USE_ICOUNT) {\n        assert(use_icount);\n        /* Reset the cycle counter to the start of the block.  */\n        cpu->icount_decr.u16.low += num_insns;\n        /* Clear the IO flag.  */\n        cpu->can_do_io = 0;\n    }\n    cpu->icount_decr.u16.low -= i;\n    restore_state_to_opc(env, tb, data);\n\n#ifdef CONFIG_PROFILER\n    tcg_ctx.restore_time += profile_getclock() - ti;\n    tcg_ctx.restore_count++;\n#endif\n    return 0;\n}\n\nbool cpu_restore_state(CPUState *cpu, uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    bool r = false;\n\n    /* A retaddr of zero is invalid so we really shouldn't have ended\n     * up here. The target code has likely forgotten to check retaddr\n     * != 0 before attempting to restore state. We return early to\n     * avoid blowing up on a recursive tb_lock(). The target must have\n     * previously survived a failed cpu_restore_state because\n     * tb_find_pc(0) would have failed anyway. It still should be\n     * fixed though.\n     */\n\n    if (!retaddr) {\n        return r;\n    }\n\n    tb_lock();\n    tb = tb_find_pc(retaddr);\n    if (tb) {\n        cpu_restore_state_from_tb(cpu, tb, retaddr);\n        if (tb->cflags & CF_NOCACHE) {\n            /* one-shot translation, invalidate it immediately */\n            tb_phys_invalidate(tb, -1);\n            tb_free(tb);\n        }\n        r = true;\n    }\n    tb_unlock();\n\n    return r;\n}\n\nvoid page_size_init(void)\n{\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n       TARGET_PAGE_SIZE */\n    qemu_real_host_page_size = getpagesize();\n    qemu_real_host_page_mask = -(intptr_t)qemu_real_host_page_size;\n    if (qemu_host_page_size == 0) {\n        qemu_host_page_size = qemu_real_host_page_size;\n    }\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n    }\n    qemu_host_page_mask = -(intptr_t)qemu_host_page_size;\n}\n\nstatic void page_init(void)\n{\n    page_size_init();\n    page_table_config_init();\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n    {\n#ifdef HAVE_KINFO_GETVMMAP\n        struct kinfo_vmentry *freep;\n        int i, cnt;\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n        if (freep) {\n            mmap_lock();\n            for (i = 0; i < cnt; i++) {\n                unsigned long startaddr, endaddr;\n\n                startaddr = freep[i].kve_start;\n                endaddr = freep[i].kve_end;\n                if (h2g_valid(startaddr)) {\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n                    if (h2g_valid(endaddr)) {\n                        endaddr = h2g(endaddr);\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n                    } else {\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n                        endaddr = ~0ul;\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n#endif\n                    }\n                }\n            }\n            free(freep);\n            mmap_unlock();\n        }\n#else\n        FILE *f;\n\n        last_brk = (unsigned long)sbrk(0);\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n        if (f) {\n            mmap_lock();\n\n            do {\n                unsigned long startaddr, endaddr;\n                int n;\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n                if (n == 2 && h2g_valid(startaddr)) {\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n                    if (h2g_valid(endaddr)) {\n                        endaddr = h2g(endaddr);\n                    } else {\n                        endaddr = ~0ul;\n                    }\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n                }\n            } while (!feof(f));\n\n            fclose(f);\n            mmap_unlock();\n        }\n#endif\n    }\n#endif\n}\n\n/* If alloc=1:\n * Called with tb_lock held for system emulation.\n * Called with mmap_lock held for user-mode emulation.\n */\nstatic PageDesc *page_find_alloc(tb_page_addr_t index, int alloc)\n{\n    PageDesc *pd;\n    void **lp;\n    int i;\n\n    if (alloc) {\n        assert_memory_lock();\n    }\n\n    /* Level 1.  Always allocated.  */\n    lp = l1_map + ((index >> v_l1_shift) & (v_l1_size - 1));\n\n    /* Level 2..N-1.  */\n    for (i = v_l2_levels; i > 0; i--) {\n        void **p = atomic_rcu_read(lp);\n\n        if (p == NULL) {\n            if (!alloc) {\n                return NULL;\n            }\n            p = g_new0(void *, V_L2_SIZE);\n            atomic_rcu_set(lp, p);\n        }\n\n        lp = p + ((index >> (i * V_L2_BITS)) & (V_L2_SIZE - 1));\n    }\n\n    pd = atomic_rcu_read(lp);\n    if (pd == NULL) {\n        if (!alloc) {\n            return NULL;\n        }\n        pd = g_new0(PageDesc, V_L2_SIZE);\n        atomic_rcu_set(lp, pd);\n    }\n\n    return pd + (index & (V_L2_SIZE - 1));\n}\n\nstatic inline PageDesc *page_find(tb_page_addr_t index)\n{\n    return page_find_alloc(index, 0);\n}\n\n#if defined(CONFIG_USER_ONLY)\n/* Currently it is not recommended to allocate big chunks of data in\n   user mode. It will change when a dedicated libc will be used.  */\n/* ??? 64-bit hosts ought to have no problem mmaping data outside the\n   region in which the guest needs to run.  Revisit this.  */\n#define USE_STATIC_CODE_GEN_BUFFER\n#endif\n\n/* Minimum size of the code gen buffer.  This number is randomly chosen,\n   but not so small that we can't have a fair number of TB's live.  */\n#define MIN_CODE_GEN_BUFFER_SIZE     (1024u * 1024)\n\n/* Maximum size of the code gen buffer we'd like to use.  Unless otherwise\n   indicated, this is constrained by the range of direct branches on the\n   host cpu, as used by the TCG implementation of goto_tb.  */\n#if defined(__x86_64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2ul * 1024 * 1024 * 1024)\n#elif defined(__sparc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2ul * 1024 * 1024 * 1024)\n#elif defined(__powerpc64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2ul * 1024 * 1024 * 1024)\n#elif defined(__powerpc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (32u * 1024 * 1024)\n#elif defined(__aarch64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (128ul * 1024 * 1024)\n#elif defined(__arm__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (16u * 1024 * 1024)\n#elif defined(__s390x__)\n  /* We have a +- 4GB range on the branches; leave some slop.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (3ul * 1024 * 1024 * 1024)\n#elif defined(__mips__)\n  /* We have a 256MB branch region, but leave room to make sure the\n     main executable is also within that region.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (128ul * 1024 * 1024)\n#else\n# define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)\n#endif\n\n#define DEFAULT_CODE_GEN_BUFFER_SIZE_1 (32u * 1024 * 1024)\n\n#define DEFAULT_CODE_GEN_BUFFER_SIZE \\\n  (DEFAULT_CODE_GEN_BUFFER_SIZE_1 < MAX_CODE_GEN_BUFFER_SIZE \\\n   ? DEFAULT_CODE_GEN_BUFFER_SIZE_1 : MAX_CODE_GEN_BUFFER_SIZE)\n\nstatic inline size_t size_code_gen_buffer(size_t tb_size)\n{\n    /* Size the buffer.  */\n    if (tb_size == 0) {\n#ifdef USE_STATIC_CODE_GEN_BUFFER\n        tb_size = DEFAULT_CODE_GEN_BUFFER_SIZE;\n#else\n        /* ??? Needs adjustments.  */\n        /* ??? If we relax the requirement that CONFIG_USER_ONLY use the\n           static buffer, we could size this on RESERVED_VA, on the text\n           segment size of the executable, or continue to use the default.  */\n        tb_size = (unsigned long)(ram_size / 4);\n#endif\n    }\n    if (tb_size < MIN_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MIN_CODE_GEN_BUFFER_SIZE;\n    }\n    if (tb_size > MAX_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MAX_CODE_GEN_BUFFER_SIZE;\n    }\n    return tb_size;\n}\n\n#ifdef __mips__\n/* In order to use J and JAL within the code_gen_buffer, we require\n   that the buffer not cross a 256MB boundary.  */\nstatic inline bool cross_256mb(void *addr, size_t size)\n{\n    return ((uintptr_t)addr ^ ((uintptr_t)addr + size)) & ~0x0ffffffful;\n}\n\n/* We weren't able to allocate a buffer without crossing that boundary,\n   so make do with the larger portion of the buffer that doesn't cross.\n   Returns the new base of the buffer, and adjusts code_gen_buffer_size.  */\nstatic inline void *split_cross_256mb(void *buf1, size_t size1)\n{\n    void *buf2 = (void *)(((uintptr_t)buf1 + size1) & ~0x0ffffffful);\n    size_t size2 = buf1 + size1 - buf2;\n\n    size1 = buf2 - buf1;\n    if (size1 < size2) {\n        size1 = size2;\n        buf1 = buf2;\n    }\n\n    tcg_ctx.code_gen_buffer_size = size1;\n    return buf1;\n}\n#endif\n\n#ifdef USE_STATIC_CODE_GEN_BUFFER\nstatic uint8_t static_code_gen_buffer[DEFAULT_CODE_GEN_BUFFER_SIZE]\n    __attribute__((aligned(CODE_GEN_ALIGN)));\n\n# ifdef _WIN32\nstatic inline void do_protect(void *addr, long size, int prot)\n{\n    DWORD old_protect;\n    VirtualProtect(addr, size, prot, &old_protect);\n}\n\nstatic inline void map_exec(void *addr, long size)\n{\n    do_protect(addr, size, PAGE_EXECUTE_READWRITE);\n}\n\nstatic inline void map_none(void *addr, long size)\n{\n    do_protect(addr, size, PAGE_NOACCESS);\n}\n# else\nstatic inline void do_protect(void *addr, long size, int prot)\n{\n    uintptr_t start, end;\n\n    start = (uintptr_t)addr;\n    start &= qemu_real_host_page_mask;\n\n    end = (uintptr_t)addr + size;\n    end = ROUND_UP(end, qemu_real_host_page_size);\n\n    mprotect((void *)start, end - start, prot);\n}\n\nstatic inline void map_exec(void *addr, long size)\n{\n    do_protect(addr, size, PROT_READ | PROT_WRITE | PROT_EXEC);\n}\n\nstatic inline void map_none(void *addr, long size)\n{\n    do_protect(addr, size, PROT_NONE);\n}\n# endif /* WIN32 */\n\nstatic inline void *alloc_code_gen_buffer(void)\n{\n    void *buf = static_code_gen_buffer;\n    size_t full_size, size;\n\n    /* The size of the buffer, rounded down to end on a page boundary.  */\n    full_size = (((uintptr_t)buf + sizeof(static_code_gen_buffer))\n                 & qemu_real_host_page_mask) - (uintptr_t)buf;\n\n    /* Reserve a guard page.  */\n    size = full_size - qemu_real_host_page_size;\n\n    /* Honor a command-line option limiting the size of the buffer.  */\n    if (size > tcg_ctx.code_gen_buffer_size) {\n        size = (((uintptr_t)buf + tcg_ctx.code_gen_buffer_size)\n                & qemu_real_host_page_mask) - (uintptr_t)buf;\n    }\n    tcg_ctx.code_gen_buffer_size = size;\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        buf = split_cross_256mb(buf, size);\n        size = tcg_ctx.code_gen_buffer_size;\n    }\n#endif\n\n    map_exec(buf, size);\n    map_none(buf + size, qemu_real_host_page_size);\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#elif defined(_WIN32)\nstatic inline void *alloc_code_gen_buffer(void)\n{\n    size_t size = tcg_ctx.code_gen_buffer_size;\n    void *buf1, *buf2;\n\n    /* Perform the allocation in two steps, so that the guard page\n       is reserved but uncommitted.  */\n    buf1 = VirtualAlloc(NULL, size + qemu_real_host_page_size,\n                        MEM_RESERVE, PAGE_NOACCESS);\n    if (buf1 != NULL) {\n        buf2 = VirtualAlloc(buf1, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        assert(buf1 == buf2);\n    }\n\n    return buf1;\n}\n#else\nstatic inline void *alloc_code_gen_buffer(void)\n{\n    int flags = MAP_PRIVATE | MAP_ANONYMOUS;\n    uintptr_t start = 0;\n    size_t size = tcg_ctx.code_gen_buffer_size;\n    void *buf;\n\n    /* Constrain the position of the buffer based on the host cpu.\n       Note that these addresses are chosen in concert with the\n       addresses assigned in the relevant linker script file.  */\n# if defined(__PIE__) || defined(__PIC__)\n    /* Don't bother setting a preferred location if we're building\n       a position-independent executable.  We're more likely to get\n       an address near the main executable if we let the kernel\n       choose the address.  */\n# elif defined(__x86_64__) && defined(MAP_32BIT)\n    /* Force the memory down into low memory with the executable.\n       Leave the choice of exact location with the kernel.  */\n    flags |= MAP_32BIT;\n    /* Cannot expect to map more than 800MB in low memory.  */\n    if (size > 800u * 1024 * 1024) {\n        tcg_ctx.code_gen_buffer_size = size = 800u * 1024 * 1024;\n    }\n# elif defined(__sparc__)\n    start = 0x40000000ul;\n# elif defined(__s390x__)\n    start = 0x90000000ul;\n# elif defined(__mips__)\n#  if _MIPS_SIM == _ABI64\n    start = 0x128000000ul;\n#  else\n    start = 0x08000000ul;\n#  endif\n# endif\n\n    buf = mmap((void *)start, size + qemu_real_host_page_size,\n               PROT_NONE, flags, -1, 0);\n    if (buf == MAP_FAILED) {\n        return NULL;\n    }\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        /* Try again, with the original still mapped, to avoid re-acquiring\n           that 256mb crossing.  This time don't specify an address.  */\n        size_t size2;\n        void *buf2 = mmap(NULL, size + qemu_real_host_page_size,\n                          PROT_NONE, flags, -1, 0);\n        switch ((int)(buf2 != MAP_FAILED)) {\n        case 1:\n            if (!cross_256mb(buf2, size)) {\n                /* Success!  Use the new buffer.  */\n                munmap(buf, size + qemu_real_host_page_size);\n                break;\n            }\n            /* Failure.  Work with what we had.  */\n            munmap(buf2, size + qemu_real_host_page_size);\n            /* fallthru */\n        default:\n            /* Split the original buffer.  Free the smaller half.  */\n            buf2 = split_cross_256mb(buf, size);\n            size2 = tcg_ctx.code_gen_buffer_size;\n            if (buf == buf2) {\n                munmap(buf + size2 + qemu_real_host_page_size, size - size2);\n            } else {\n                munmap(buf, size - size2);\n            }\n            size = size2;\n            break;\n        }\n        buf = buf2;\n    }\n#endif\n\n    /* Make the final buffer accessible.  The guard page at the end\n       will remain inaccessible with PROT_NONE.  */\n    mprotect(buf, size, PROT_WRITE | PROT_READ | PROT_EXEC);\n\n    /* Request large pages for the buffer.  */\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#endif /* USE_STATIC_CODE_GEN_BUFFER, WIN32, POSIX */\n\nstatic inline void code_gen_alloc(size_t tb_size)\n{\n    tcg_ctx.code_gen_buffer_size = size_code_gen_buffer(tb_size);\n    tcg_ctx.code_gen_buffer = alloc_code_gen_buffer();\n    if (tcg_ctx.code_gen_buffer == NULL) {\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n        exit(1);\n    }\n\n    /* Estimate a good size for the number of TBs we can support.  We\n       still haven't deducted the prologue from the buffer size here,\n       but that's minimal and won't affect the estimate much.  */\n    tcg_ctx.code_gen_max_blocks\n        = tcg_ctx.code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE;\n    tcg_ctx.tb_ctx.tbs = g_new(TranslationBlock, tcg_ctx.code_gen_max_blocks);\n\n    qemu_mutex_init(&tcg_ctx.tb_ctx.tb_lock);\n}\n\nstatic void tb_htable_init(void)\n{\n    unsigned int mode = QHT_MODE_AUTO_RESIZE;\n\n    qht_init(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE, mode);\n}\n\n/* Must be called before using the QEMU cpus. 'tb_size' is the size\n   (in bytes) allocated to the translation buffer. Zero means default\n   size. */\nvoid tcg_exec_init(unsigned long tb_size)\n{\n    cpu_gen_init();\n    page_init();\n    tb_htable_init();\n    code_gen_alloc(tb_size);\n#if defined(CONFIG_SOFTMMU)\n    /* There's no guest base to take into account, so go ahead and\n       initialize the prologue now.  */\n    tcg_prologue_init(&tcg_ctx);\n#endif\n}\n\nbool tcg_enabled(void)\n{\n    return tcg_ctx.code_gen_buffer != NULL;\n}\n\n/*\n * Allocate a new translation block. Flush the translation buffer if\n * too many translation blocks or too much generated code.\n *\n * Called with tb_lock held.\n */\nstatic TranslationBlock *tb_alloc(target_ulong pc)\n{\n    TranslationBlock *tb;\n\n    assert_tb_locked();\n\n    if (tcg_ctx.tb_ctx.nb_tbs >= tcg_ctx.code_gen_max_blocks) {\n        return NULL;\n    }\n    tb = &tcg_ctx.tb_ctx.tbs[tcg_ctx.tb_ctx.nb_tbs++];\n    tb->pc = pc;\n    tb->cflags = 0;\n    tb->invalid = false;\n#ifdef CONFIG_LLVM\n    tcg_llvm_tb_alloc(tb);\n#endif\n    return tb;\n}\n\n/* Called with tb_lock held.  */\nvoid tb_free(TranslationBlock *tb)\n{\n    assert_tb_locked();\n\n    /* In practice this is mostly used for single use temporary TB\n       Ignore the hard cases and just back up if this TB happens to\n       be the last one generated.  */\n    if (tcg_ctx.tb_ctx.nb_tbs > 0 &&\n            tb == &tcg_ctx.tb_ctx.tbs[tcg_ctx.tb_ctx.nb_tbs - 1]) {\n        tcg_ctx.code_gen_ptr = tb->tc_ptr;\n#if defined(CONFIG_LLVM)\n        tcg_llvm_tb_free(tb);\n#endif\n        tcg_ctx.tb_ctx.nb_tbs--;\n    }\n}\n\nstatic inline void invalidate_page_bitmap(PageDesc *p)\n{\n#ifdef CONFIG_SOFTMMU\n    g_free(p->code_bitmap);\n    p->code_bitmap = NULL;\n    p->code_write_count = 0;\n#endif\n}\n\n/* Set to NULL all the 'first_tb' fields in all PageDescs. */\nstatic void page_flush_tb_1(int level, void **lp)\n{\n    int i;\n\n    if (*lp == NULL) {\n        return;\n    }\n    if (level == 0) {\n        PageDesc *pd = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            pd[i].first_tb = NULL;\n            invalidate_page_bitmap(pd + i);\n        }\n    } else {\n        void **pp = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            page_flush_tb_1(level - 1, pp + i);\n        }\n    }\n}\n\nstatic void page_flush_tb(void)\n{\n    int i, l1_sz = v_l1_size;\n\n    for (i = 0; i < l1_sz; i++) {\n        page_flush_tb_1(v_l2_levels, l1_map + i);\n    }\n}\n\n/* flush all the translation blocks */\nstatic void do_tb_flush(CPUState *cpu, run_on_cpu_data tb_flush_count)\n{\n    tb_lock();\n\n    /* If it is already been done on request of another CPU,\n     * just retry.\n     */\n    if (tcg_ctx.tb_ctx.tb_flush_count != tb_flush_count.host_int) {\n        goto done;\n    }\n\n#if defined(DEBUG_TB_FLUSH)\n    printf(\"qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\\n\",\n           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),\n           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?\n           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /\n           tcg_ctx.tb_ctx.nb_tbs : 0);\n#endif\n    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)\n        > tcg_ctx.code_gen_buffer_size) {\n        cpu_abort(cpu, \"Internal error: code buffer overflow\\n\");\n    }\n\n#if defined(CONFIG_LLVM)\n    int i2;\n    for(i2 = 0; i2 < tcg_ctx.tb_ctx.nb_tbs; ++i2){\n        tcg_llvm_tb_free(&tcg_ctx.tb_ctx.tbs[i2]);\n    }\n#endif\n\n    CPU_FOREACH(cpu) {\n        int i;\n\n        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {\n            atomic_set(&cpu->tb_jmp_cache[i], NULL);\n        }\n    }\n\n    tcg_ctx.tb_ctx.nb_tbs = 0;\n    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n    page_flush_tb();\n\n    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;\n    /* XXX: flush processor icache at this point if cache flush is\n       expensive */\n    atomic_mb_set(&tcg_ctx.tb_ctx.tb_flush_count,\n                  tcg_ctx.tb_ctx.tb_flush_count + 1);\n\ndone:\n    tb_unlock();\n}\n\nvoid tb_flush(CPUState *cpu)\n{\n    if (tcg_enabled()) {\n        unsigned tb_flush_count = atomic_mb_read(&tcg_ctx.tb_ctx.tb_flush_count);\n        async_safe_run_on_cpu(cpu, do_tb_flush,\n                              RUN_ON_CPU_HOST_INT(tb_flush_count));\n    }\n}\n\n#ifdef DEBUG_TB_CHECK\n\nstatic void\ndo_tb_invalidate_check(struct qht *ht, void *p, uint32_t hash, void *userp)\n{\n    TranslationBlock *tb = p;\n    target_ulong addr = *(target_ulong *)userp;\n\n    if (!(addr + TARGET_PAGE_SIZE <= tb->pc || addr >= tb->pc + tb->size)) {\n        printf(\"ERROR invalidate: address=\" TARGET_FMT_lx\n               \" PC=%08lx size=%04x\\n\", addr, (long)tb->pc, tb->size);\n    }\n}\n\n/* verify that all the pages have correct rights for code\n *\n * Called with tb_lock held.\n */\nstatic void tb_invalidate_check(target_ulong address)\n{\n    address &= TARGET_PAGE_MASK;\n    qht_iter(&tcg_ctx.tb_ctx.htable, do_tb_invalidate_check, &address);\n}\n\nstatic void\ndo_tb_page_check(struct qht *ht, void *p, uint32_t hash, void *userp)\n{\n    TranslationBlock *tb = p;\n    int flags1, flags2;\n\n    flags1 = page_get_flags(tb->pc);\n    flags2 = page_get_flags(tb->pc + tb->size - 1);\n    if ((flags1 & PAGE_WRITE) || (flags2 & PAGE_WRITE)) {\n        printf(\"ERROR page flags: PC=%08lx size=%04x f1=%x f2=%x\\n\",\n               (long)tb->pc, tb->size, flags1, flags2);\n    }\n}\n\n/* verify that all the pages have correct rights for code */\nstatic void tb_page_check(void)\n{\n    qht_iter(&tcg_ctx.tb_ctx.htable, do_tb_page_check, NULL);\n}\n\n#endif\n\nstatic inline void tb_page_remove(TranslationBlock **ptb, TranslationBlock *tb)\n{\n    TranslationBlock *tb1;\n    unsigned int n1;\n\n    for (;;) {\n        tb1 = *ptb;\n        n1 = (uintptr_t)tb1 & 3;\n        tb1 = (TranslationBlock *)((uintptr_t)tb1 & ~3);\n        if (tb1 == tb) {\n            *ptb = tb1->page_next[n1];\n            break;\n        }\n        ptb = &tb1->page_next[n1];\n    }\n}\n\n/* remove the TB from a list of TBs jumping to the n-th jump target of the TB */\nstatic inline void tb_remove_from_jmp_list(TranslationBlock *tb, int n)\n{\n    TranslationBlock *tb1;\n    uintptr_t *ptb, ntb;\n    unsigned int n1;\n\n    ptb = &tb->jmp_list_next[n];\n    if (*ptb) {\n        /* find tb(n) in circular list */\n        for (;;) {\n            ntb = *ptb;\n            n1 = ntb & 3;\n            tb1 = (TranslationBlock *)(ntb & ~3);\n            if (n1 == n && tb1 == tb) {\n                break;\n            }\n            if (n1 == 2) {\n                ptb = &tb1->jmp_list_first;\n            } else {\n                ptb = &tb1->jmp_list_next[n1];\n            }\n        }\n        /* now we can suppress tb(n) from the list */\n        *ptb = tb->jmp_list_next[n];\n\n        tb->jmp_list_next[n] = (uintptr_t)NULL;\n    }\n}\n\n/* reset the jump entry 'n' of a TB so that it is not chained to\n   another TB */\nstatic inline void tb_reset_jump(TranslationBlock *tb, int n)\n{\n    uintptr_t addr = (uintptr_t)(tb->tc_ptr + tb->jmp_reset_offset[n]);\n    tb_set_jmp_target(tb, n, addr);\n#ifdef CONFIG_LLVM\n    tb->llvm_tb_next[n] = NULL;\n#endif\n}\n\n/* remove any jumps to the TB */\nstatic inline void tb_jmp_unlink(TranslationBlock *tb)\n{\n    TranslationBlock *tb1;\n    uintptr_t *ptb, ntb;\n    unsigned int n1;\n\n    ptb = &tb->jmp_list_first;\n    for (;;) {\n        ntb = *ptb;\n        n1 = ntb & 3;\n        tb1 = (TranslationBlock *)(ntb & ~3);\n        if (n1 == 2) {\n            break;\n        }\n        tb_reset_jump(tb1, n1);\n        *ptb = tb1->jmp_list_next[n1];\n        tb1->jmp_list_next[n1] = (uintptr_t)NULL;\n    }\n}\n\n/* invalidate one TB\n *\n * Called with tb_lock held.\n */\nvoid tb_phys_invalidate(TranslationBlock *tb, tb_page_addr_t page_addr)\n{\n    CPUState *cpu;\n    PageDesc *p;\n    uint32_t h;\n    tb_page_addr_t phys_pc;\n\n    assert_tb_locked();\n\n    atomic_set(&tb->invalid, true);\n\n    /* remove the TB from the hash list */\n    phys_pc = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n    h = tb_hash_func(phys_pc, tb->pc, tb->flags);\n    qht_remove(&tcg_ctx.tb_ctx.htable, tb, h);\n\n    /* remove the TB from the page list */\n    if (tb->page_addr[0] != page_addr) {\n        p = page_find(tb->page_addr[0] >> TARGET_PAGE_BITS);\n        tb_page_remove(&p->first_tb, tb);\n        invalidate_page_bitmap(p);\n    }\n    if (tb->page_addr[1] != -1 && tb->page_addr[1] != page_addr) {\n        p = page_find(tb->page_addr[1] >> TARGET_PAGE_BITS);\n        tb_page_remove(&p->first_tb, tb);\n        invalidate_page_bitmap(p);\n    }\n\n    /* remove the TB from the hash list */\n    h = tb_jmp_cache_hash_func(tb->pc);\n    CPU_FOREACH(cpu) {\n        if (atomic_read(&cpu->tb_jmp_cache[h]) == tb) {\n            atomic_set(&cpu->tb_jmp_cache[h], NULL);\n        }\n    }\n\n    /* suppress this TB from the two jump lists */\n    tb_remove_from_jmp_list(tb, 0);\n    tb_remove_from_jmp_list(tb, 1);\n\n    /* suppress any remaining jumps to this TB */\n    tb_jmp_unlink(tb);\n\n    tcg_ctx.tb_ctx.tb_phys_invalidate_count++;\n}\n\n#ifdef CONFIG_SOFTMMU\nstatic void build_page_bitmap(PageDesc *p)\n{\n    int n, tb_start, tb_end;\n    TranslationBlock *tb;\n\n    p->code_bitmap = bitmap_new(TARGET_PAGE_SIZE);\n\n    tb = p->first_tb;\n    while (tb != NULL) {\n        n = (uintptr_t)tb & 3;\n        tb = (TranslationBlock *)((uintptr_t)tb & ~3);\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->pc & ~TARGET_PAGE_MASK;\n            tb_end = tb_start + tb->size;\n            if (tb_end > TARGET_PAGE_SIZE) {\n                tb_end = TARGET_PAGE_SIZE;\n             }\n        } else {\n            tb_start = 0;\n            tb_end = ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        bitmap_set(p->code_bitmap, tb_start, tb_end - tb_start);\n        tb = tb->page_next[n];\n    }\n}\n#endif\n\n/* add the tb in the target page and protect it if necessary\n *\n * Called with mmap_lock held for user-mode emulation.\n */\nstatic inline void tb_alloc_page(TranslationBlock *tb,\n                                 unsigned int n, tb_page_addr_t page_addr)\n{\n    PageDesc *p;\n#ifndef CONFIG_USER_ONLY\n    bool page_already_protected;\n#endif\n\n    assert_memory_lock();\n\n    tb->page_addr[n] = page_addr;\n    p = page_find_alloc(page_addr >> TARGET_PAGE_BITS, 1);\n    tb->page_next[n] = p->first_tb;\n#ifndef CONFIG_USER_ONLY\n    page_already_protected = p->first_tb != NULL;\n#endif\n    p->first_tb = (TranslationBlock *)((uintptr_t)tb | n);\n    invalidate_page_bitmap(p);\n\n#if defined(CONFIG_USER_ONLY)\n    if (p->flags & PAGE_WRITE) {\n        target_ulong addr;\n        PageDesc *p2;\n        int prot;\n\n        /* force the host page as non writable (writes will have a\n           page fault + mprotect overhead) */\n        page_addr &= qemu_host_page_mask;\n        prot = 0;\n        for (addr = page_addr; addr < page_addr + qemu_host_page_size;\n            addr += TARGET_PAGE_SIZE) {\n\n            p2 = page_find(addr >> TARGET_PAGE_BITS);\n            if (!p2) {\n                continue;\n            }\n            prot |= p2->flags;\n            p2->flags &= ~PAGE_WRITE;\n          }\n        mprotect(g2h(page_addr), qemu_host_page_size,\n                 (prot & PAGE_BITS) & ~PAGE_WRITE);\n#ifdef DEBUG_TB_INVALIDATE\n        printf(\"protecting code page: 0x\" TARGET_FMT_lx \"\\n\",\n               page_addr);\n#endif\n    }\n#else\n    /* if some code is already present, then the pages are already\n       protected. So we handle the case where only the first TB is\n       allocated in a physical page */\n    if (!page_already_protected) {\n        tlb_protect_code(page_addr);\n    }\n#endif\n}\n\n/* add a new TB and link it to the physical page tables. phys_page2 is\n * (-1) to indicate that only one page contains the TB.\n *\n * Called with mmap_lock held for user-mode emulation.\n */\nstatic void tb_link_page(TranslationBlock *tb, tb_page_addr_t phys_pc,\n                         tb_page_addr_t phys_page2)\n{\n    uint32_t h;\n\n    assert_memory_lock();\n\n    /* add in the page list */\n    tb_alloc_page(tb, 0, phys_pc & TARGET_PAGE_MASK);\n    if (phys_page2 != -1) {\n        tb_alloc_page(tb, 1, phys_page2);\n    } else {\n        tb->page_addr[1] = -1;\n    }\n\n    /* add in the hash table */\n    h = tb_hash_func(phys_pc, tb->pc, tb->flags);\n    qht_insert(&tcg_ctx.tb_ctx.htable, tb, h);\n\n#ifdef DEBUG_TB_CHECK\n    tb_page_check();\n#endif\n}\n\n/* Called with mmap_lock held for user mode emulation.  */\nTranslationBlock *tb_gen_code(CPUState *cpu,\n                              target_ulong pc, target_ulong cs_base,\n                              uint32_t flags, int cflags)\n{\n    CPUArchState *env = cpu->env_ptr;\n    TranslationBlock *tb;\n    tb_page_addr_t phys_pc, phys_page2;\n    target_ulong virt_page2;\n    tcg_insn_unit *gen_code_buf;\n    int gen_code_size, search_size;\n#ifdef CONFIG_PROFILER\n    int64_t ti;\n#endif\n    assert_memory_lock();\n\n    phys_pc = get_page_addr_code(env, pc);\n    if (use_icount && !(cflags & CF_IGNORE_ICOUNT)) {\n        cflags |= CF_USE_ICOUNT;\n    }\n\n    tb = tb_alloc(pc);\n    if (unlikely(!tb)) {\n buffer_overflow:\n        /* flush must be done */\n        tb_flush(cpu);\n        mmap_unlock();\n        /* Make the execution loop process the flush as soon as possible.  */\n        cpu->exception_index = EXCP_INTERRUPT;\n        cpu_loop_exit(cpu);\n    }\n\n    gen_code_buf = tcg_ctx.code_gen_ptr;\n    tb->tc_ptr = gen_code_buf;\n    tb->cs_base = cs_base;\n    tb->flags = flags;\n    tb->cflags = cflags;\n\n#ifdef CONFIG_PROFILER\n    tcg_ctx.tb_count1++; /* includes aborted translations because of\n                       exceptions */\n    ti = profile_getclock();\n#endif\n\n    tcg_func_start(&tcg_ctx);\n\n    tcg_ctx.cpu = ENV_GET_CPU(env);\n    gen_intermediate_code(env, tb);\n    tcg_ctx.cpu = NULL;\n\n    trace_translate_block(tb, tb->pc, tb->tc_ptr);\n\n    /* generate machine code */\n    tb->jmp_reset_offset[0] = TB_JMP_RESET_OFFSET_INVALID;\n    tb->jmp_reset_offset[1] = TB_JMP_RESET_OFFSET_INVALID;\n    tcg_ctx.tb_jmp_reset_offset = tb->jmp_reset_offset;\n#ifdef USE_DIRECT_JUMP\n    tcg_ctx.tb_jmp_insn_offset = tb->jmp_insn_offset;\n    tcg_ctx.tb_jmp_target_addr = NULL;\n#else\n    tcg_ctx.tb_jmp_insn_offset = NULL;\n    tcg_ctx.tb_jmp_target_addr = tb->jmp_target_addr;\n#endif\n\n#ifdef CONFIG_PROFILER\n    tcg_ctx.tb_count++;\n    tcg_ctx.interm_time += profile_getclock() - ti;\n    tcg_ctx.code_time -= profile_getclock();\n#endif\n\n    /* ??? Overflow could be handled better here.  In particular, we\n       don't need to re-do gen_intermediate_code, nor should we re-do\n       the tcg optimization currently hidden inside tcg_gen_code.  All\n       that should be required is to flush the TBs, allocate a new TB,\n       re-initialize it per above, and re-do the actual code generation.  */\n    panda_callbacks_before_tcg_codegen(first_cpu, tb);\n    panda_install_block_callbacks(first_cpu, tb);\n\n    gen_code_size = tcg_gen_code(&tcg_ctx, tb);\n\n#if defined(CONFIG_LLVM)\n    if (generate_llvm)\n        tcg_llvm_gen_code(tcg_llvm_translator, &tcg_ctx, tb);\n#endif\n\n    if (unlikely(gen_code_size < 0)) {\n        goto buffer_overflow;\n    }\n    search_size = encode_search(tb, (void *)gen_code_buf + gen_code_size);\n    if (unlikely(search_size < 0)) {\n        goto buffer_overflow;\n    }\n\n#ifdef CONFIG_PROFILER\n    tcg_ctx.code_time += profile_getclock();\n    tcg_ctx.code_in_len += tb->size;\n    tcg_ctx.code_out_len += gen_code_size;\n    tcg_ctx.search_out_len += search_size;\n#endif\n\n#if defined(CONFIG_LLVM)\n    if(generate_llvm && qemu_loglevel_mask(CPU_LOG_LLVM_ASM)\n            && tb->llvm_tc_ptr) {\n        ptrdiff_t size = tb->llvm_tc_end - tb->llvm_asm_ptr;\n        qemu_log(\"OUT (LLVM ASM) [size=%ld] (%s)\\n\", size,\n                    tcg_llvm_get_func_name(tb));\n        log_disas((void*) tb->llvm_asm_ptr, size);\n        qemu_log(\"\\n\");\n        qemu_log_flush();\n    }\n#endif\n\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_OUT_ASM) &&\n        qemu_log_in_addr_range(tb->pc)) {\n        qemu_log_lock();\n        qemu_log(\"OUT: [size=%d]\\n\", gen_code_size);\n        log_disas(tb->tc_ptr, gen_code_size);\n        qemu_log(\"\\n\");\n        qemu_log_flush();\n        qemu_log_unlock();\n    }\n#endif\n\n#ifdef CONFIG_LLVM\n    // Sanity check. We had a bug before where we were misrecording\n    // translated code sizes, and so TC blocks appeared to overlap.\n    int i;\n    if (generate_llvm) {\n        for (i = 0; i < tcg_ctx.tb_ctx.nb_tbs; i++) {\n            TranslationBlock *other = &tcg_ctx.tb_ctx.tbs[i];\n            if (tb == other) continue;\n            if (other->llvm_asm_ptr <= tb->llvm_asm_ptr &&\n                    tb->llvm_asm_ptr < other->llvm_tc_end) {\n                assert(false && \"Allocating apparently overlapping blocks!\");\n            } else if (other->llvm_asm_ptr < tb->llvm_tc_end &&\n                    tb->llvm_tc_end <= other->llvm_tc_end) {\n                assert(false && \"Allocating apparently overlapping blocks!\");\n            }\n        }\n    }\n#endif\n\n    tcg_ctx.code_gen_ptr = (void *)\n        ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,\n                 CODE_GEN_ALIGN);\n\n    /* init jump list */\n    assert(((uintptr_t)tb & 3) == 0);\n    tb->jmp_list_first = (uintptr_t)tb | 2;\n    tb->jmp_list_next[0] = (uintptr_t)NULL;\n    tb->jmp_list_next[1] = (uintptr_t)NULL;\n\n    /* init original jump addresses wich has been set during tcg_gen_code() */\n    if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 0);\n    }\n    if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 1);\n    }\n\n    /* check next page if needed */\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n    phys_page2 = -1;\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n        phys_page2 = get_page_addr_code(env, virt_page2);\n    }\n    /* As long as consistency of the TB stuff is provided by tb_lock in user\n     * mode and is implicit in single-threaded softmmu emulation, no explicit\n     * memory barrier is required before tb_link_page() makes the TB visible\n     * through the physical hash table and physical page list.\n     */\n    tb_link_page(tb, phys_pc, phys_page2);\n    return tb;\n}\n\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end may refer to *different* physical pages.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with mmap_lock held for user-mode emulation, grabs tb_lock\n * Called with tb_lock held for system-mode emulation\n */\nstatic void tb_invalidate_phys_range_1(tb_page_addr_t start, tb_page_addr_t end)\n{\n    while (start < end) {\n        tb_invalidate_phys_page_range(start, end, 0);\n        start &= TARGET_PAGE_MASK;\n        start += TARGET_PAGE_SIZE;\n    }\n}\n\n#ifdef CONFIG_SOFTMMU\nvoid tb_invalidate_phys_range(tb_page_addr_t start, tb_page_addr_t end)\n{\n    assert_tb_locked();\n    tb_invalidate_phys_range_1(start, end);\n}\n#else\nvoid tb_invalidate_phys_range(tb_page_addr_t start, tb_page_addr_t end)\n{\n    assert_memory_lock();\n    tb_lock();\n    tb_invalidate_phys_range_1(start, end);\n    tb_unlock();\n}\n#endif\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end must refer to the *same* physical page.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with tb_lock/mmap_lock held for user-mode emulation\n * Called with tb_lock held for system-mode emulation\n */\nvoid tb_invalidate_phys_page_range(tb_page_addr_t start, tb_page_addr_t end,\n                                   int is_cpu_write_access)\n{\n    TranslationBlock *tb, *tb_next;\n#if defined(TARGET_HAS_PRECISE_SMC)\n    CPUState *cpu = current_cpu;\n    CPUArchState *env = NULL;\n#endif\n    tb_page_addr_t tb_start, tb_end;\n    PageDesc *p;\n    int n;\n#ifdef TARGET_HAS_PRECISE_SMC\n    int current_tb_not_found = is_cpu_write_access;\n    TranslationBlock *current_tb = NULL;\n    int current_tb_modified = 0;\n    target_ulong current_pc = 0;\n    target_ulong current_cs_base = 0;\n    uint32_t current_flags = 0;\n#endif /* TARGET_HAS_PRECISE_SMC */\n\n    assert_memory_lock();\n    assert_tb_locked();\n\n    p = page_find(start >> TARGET_PAGE_BITS);\n    if (!p) {\n        return;\n    }\n#if defined(TARGET_HAS_PRECISE_SMC)\n    if (cpu != NULL) {\n        env = cpu->env_ptr;\n    }\n#endif\n\n    /* we remove all the TBs in the range [start, end[ */\n    /* XXX: see if in some cases it could be faster to invalidate all\n       the code */\n    tb = p->first_tb;\n    while (tb != NULL) {\n        n = (uintptr_t)tb & 3;\n        tb = (TranslationBlock *)((uintptr_t)tb & ~3);\n        tb_next = tb->page_next[n];\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n            tb_end = tb_start + tb->size;\n        } else {\n            tb_start = tb->page_addr[1];\n            tb_end = tb_start + ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        if (!(tb_end <= start || tb_start >= end)) {\n#ifdef TARGET_HAS_PRECISE_SMC\n            if (current_tb_not_found) {\n                current_tb_not_found = 0;\n                current_tb = NULL;\n                if (cpu->mem_io_pc) {\n                    /* now we have a real cpu fault */\n                    current_tb = tb_find_pc(cpu->mem_io_pc);\n                }\n            }\n            if (current_tb == tb &&\n                (current_tb->cflags & CF_COUNT_MASK) != 1) {\n                /* If we are modifying the current TB, we must stop\n                its execution. We could be more precise by checking\n                that the modification is after the current PC, but it\n                would require a specialized function to partially\n                restore the CPU state */\n                current_tb_modified = 1;\n                cpu_restore_state_from_tb(cpu, current_tb, cpu->mem_io_pc);\n                cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                                     &current_flags);\n\n                /* this is a hack, but probably a necessary one. fixes\n                double-counting when SMC occurs. long-term fix: count\n                BEFORE instr executes instead of after. */\n                if (rr_on()) {\n                    cpu->rr_guest_instr_count--;\n                }\n            }\n#endif /* TARGET_HAS_PRECISE_SMC */\n            tb_phys_invalidate(tb, -1);\n        }\n        tb = tb_next;\n    }\n#if !defined(CONFIG_USER_ONLY)\n    /* if no code remaining, no need to continue to use slow writes */\n    if (!p->first_tb) {\n        invalidate_page_bitmap(p);\n        tlb_unprotect_code(start);\n    }\n#endif\n#ifdef TARGET_HAS_PRECISE_SMC\n    if (current_tb_modified) {\n        /* we generate a block containing just the instruction\n           modifying the memory. It will ensure that it cannot modify\n           itself */\n        tb_gen_code(cpu, current_pc, current_cs_base, current_flags, 1);\n        cpu_loop_exit_noexc(cpu);\n    }\n#endif\n}\n\n#ifdef CONFIG_SOFTMMU\n/* len must be <= 8 and start must be a multiple of len.\n * Called via softmmu_template.h when code areas are written to with\n * tb_lock held.\n */\nvoid tb_invalidate_phys_page_fast(tb_page_addr_t start, int len)\n{\n    PageDesc *p;\n\n#if 0\n    if (1) {\n        qemu_log(\"modifying code at 0x%x size=%d EIP=%x PC=%08x\\n\",\n                  cpu_single_env->mem_io_vaddr, len,\n                  cpu_single_env->eip,\n                  cpu_single_env->eip +\n                  (intptr_t)cpu_single_env->segs[R_CS].base);\n    }\n#endif\n    assert_memory_lock();\n\n    p = page_find(start >> TARGET_PAGE_BITS);\n    if (!p) {\n        return;\n    }\n    if (!p->code_bitmap &&\n        ++p->code_write_count >= SMC_BITMAP_USE_THRESHOLD) {\n        /* build code bitmap.  FIXME: writes should be protected by\n         * tb_lock, reads by tb_lock or RCU.\n         */\n        build_page_bitmap(p);\n    }\n    if (p->code_bitmap) {\n        unsigned int nr;\n        unsigned long b;\n\n        nr = start & ~TARGET_PAGE_MASK;\n        b = p->code_bitmap[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG - 1));\n        if (b & ((1 << len) - 1)) {\n            goto do_invalidate;\n        }\n    } else {\n    do_invalidate:\n        tb_invalidate_phys_page_range(start, start + len, 1);\n    }\n}\n#else\n/* Called with mmap_lock held. If pc is not 0 then it indicates the\n * host PC of the faulting store instruction that caused this invalidate.\n * Returns true if the caller needs to abort execution of the current\n * TB (because it was modified by this store and the guest CPU has\n * precise-SMC semantics).\n */\nstatic bool tb_invalidate_phys_page(tb_page_addr_t addr, uintptr_t pc)\n{\n    TranslationBlock *tb;\n    PageDesc *p;\n    int n;\n#ifdef TARGET_HAS_PRECISE_SMC\n    TranslationBlock *current_tb = NULL;\n    CPUState *cpu = current_cpu;\n    CPUArchState *env = NULL;\n    int current_tb_modified = 0;\n    target_ulong current_pc = 0;\n    target_ulong current_cs_base = 0;\n    uint32_t current_flags = 0;\n#endif\n\n    assert_memory_lock();\n\n    addr &= TARGET_PAGE_MASK;\n    p = page_find(addr >> TARGET_PAGE_BITS);\n    if (!p) {\n        return false;\n    }\n\n    tb_lock();\n    tb = p->first_tb;\n#ifdef TARGET_HAS_PRECISE_SMC\n    if (tb && pc != 0) {\n        current_tb = tb_find_pc(pc);\n    }\n    if (cpu != NULL) {\n        env = cpu->env_ptr;\n    }\n#endif\n    while (tb != NULL) {\n        n = (uintptr_t)tb & 3;\n        tb = (TranslationBlock *)((uintptr_t)tb & ~3);\n#ifdef TARGET_HAS_PRECISE_SMC\n        if (current_tb == tb &&\n            (current_tb->cflags & CF_COUNT_MASK) != 1) {\n                /* If we are modifying the current TB, we must stop\n                   its execution. We could be more precise by checking\n                   that the modification is after the current PC, but it\n                   would require a specialized function to partially\n                   restore the CPU state */\n\n            current_tb_modified = 1;\n            cpu_restore_state_from_tb(cpu, current_tb, pc);\n            cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                                 &current_flags);\n        }\n#endif /* TARGET_HAS_PRECISE_SMC */\n        tb_phys_invalidate(tb, addr);\n        tb = tb->page_next[n];\n    }\n    p->first_tb = NULL;\n#ifdef TARGET_HAS_PRECISE_SMC\n    if (current_tb_modified) {\n        /* we generate a block containing just the instruction\n           modifying the memory. It will ensure that it cannot modify\n           itself */\n        tb_gen_code(cpu, current_pc, current_cs_base, current_flags, 1);\n        /* tb_lock will be reset after cpu_loop_exit_noexc longjmps\n         * back into the cpu_exec loop. */\n        return true;\n    }\n#endif\n    tb_unlock();\n\n    return false;\n}\n#endif\n\n/* find the TB 'tb' such that tb[0].tc_ptr <= tc_ptr <\n   tb[1].tc_ptr. Return NULL if not found */\nstatic TranslationBlock *tb_find_pc(uintptr_t tc_ptr)\n{\n    int m_min, m_max, m;\n    uintptr_t v;\n    TranslationBlock *tb;\n\n    if (tcg_ctx.tb_ctx.nb_tbs <= 0) {\n        return NULL;\n    }\n\n#ifdef CONFIG_LLVM\n    if (execute_llvm) {\n        /* first check last tb. optimization for coming from generated code. */\n        tb = tcg_llvm_runtime.last_tb;\n        if (tb && tb->llvm_asm_ptr\n                && tc_ptr >= (uintptr_t)tb->llvm_asm_ptr\n                && tc_ptr <  (uintptr_t)tb->llvm_tc_end) {\n            return tb;\n        }\n\n        /* then do linear search. */\n\n        for (m = 0; m < tcg_ctx.tb_ctx.nb_tbs; m++) {\n            tb = &tcg_ctx.tb_ctx.tbs[m];\n            if (tb->llvm_asm_ptr\n                    && tc_ptr >= (uintptr_t)tb->llvm_asm_ptr\n                    && tc_ptr <  (uintptr_t)tb->llvm_tc_end) {\n                return tb;\n            }\n        }\n        return NULL;\n\n    }\n#endif\n\n    if (tc_ptr < (uintptr_t)tcg_ctx.code_gen_buffer ||\n        tc_ptr >= (uintptr_t)tcg_ctx.code_gen_ptr) {\n        return NULL;\n    }\n    /* binary search (cf Knuth) */\n    m_min = 0;\n    m_max = tcg_ctx.tb_ctx.nb_tbs - 1;\n    while (m_min <= m_max) {\n        m = (m_min + m_max) >> 1;\n        tb = &tcg_ctx.tb_ctx.tbs[m];\n        v = (uintptr_t)tb->tc_ptr;\n        if (v == tc_ptr) {\n            return tb;\n        } else if (tc_ptr < v) {\n            m_max = m - 1;\n        } else {\n            m_min = m + 1;\n        }\n    }\n    return &tcg_ctx.tb_ctx.tbs[m_max];\n}\n\n#if !defined(CONFIG_USER_ONLY)\nvoid tb_invalidate_phys_addr(AddressSpace *as, hwaddr addr)\n{\n    ram_addr_t ram_addr;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &addr, &l, false);\n    if (!(memory_region_is_ram(mr)\n          || memory_region_is_romd(mr))) {\n        rcu_read_unlock();\n        return;\n    }\n    ram_addr = memory_region_get_ram_addr(mr) + addr;\n    tb_lock();\n    tb_invalidate_phys_page_range(ram_addr, ram_addr + 1, 0);\n    tb_unlock();\n    rcu_read_unlock();\n}\n#endif /* !defined(CONFIG_USER_ONLY) */\n\n/* Called with tb_lock held.  */\nvoid tb_check_watchpoint(CPUState *cpu)\n{\n    TranslationBlock *tb;\n\n    tb = tb_find_pc(cpu->mem_io_pc);\n    if (tb) {\n        /* We can use retranslation to find the PC.  */\n        cpu_restore_state_from_tb(cpu, tb, cpu->mem_io_pc);\n        tb_phys_invalidate(tb, -1);\n    } else {\n        /* The exception probably happened in a helper.  The CPU state should\n           have been saved before calling it. Fetch the PC from there.  */\n        CPUArchState *env = cpu->env_ptr;\n        target_ulong pc, cs_base;\n        tb_page_addr_t addr;\n        uint32_t flags;\n\n        cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n        addr = get_page_addr_code(env, pc);\n        tb_invalidate_phys_range(addr, addr + 1);\n    }\n}\n\n#ifndef CONFIG_USER_ONLY\n/* in deterministic execution mode, instructions doing device I/Os\n   must be at the end of the TB */\nvoid cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)\n{\n#if defined(TARGET_MIPS) || defined(TARGET_SH4)\n    CPUArchState *env = cpu->env_ptr;\n#endif\n    TranslationBlock *tb;\n    uint32_t n, cflags;\n    target_ulong pc, cs_base;\n    uint32_t flags;\n\n    tb_lock();\n    tb = tb_find_pc(retaddr);\n    if (!tb) {\n        cpu_abort(cpu, \"cpu_io_recompile: could not find TB for pc=%p\",\n                  (void *)retaddr);\n    }\n    n = cpu->icount_decr.u16.low + tb->icount;\n    cpu_restore_state_from_tb(cpu, tb, retaddr);\n    /* Calculate how many instructions had been executed before the fault\n       occurred.  */\n    n = n - cpu->icount_decr.u16.low;\n    /* Generate a new TB ending on the I/O insn.  */\n    n++;\n    /* On MIPS and SH, delay slot instructions can only be restarted if\n       they were already the first instruction in the TB.  If this is not\n       the first instruction in a TB then re-execute the preceding\n       branch.  */\n#if defined(TARGET_MIPS)\n    if ((env->hflags & MIPS_HFLAG_BMASK) != 0 && n > 1) {\n        env->active_tc.PC -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);\n        cpu->icount_decr.u16.low++;\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n    }\n#elif defined(TARGET_SH4)\n    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0\n            && n > 1) {\n        env->pc -= 2;\n        cpu->icount_decr.u16.low++;\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n    }\n#endif\n    /* This should never happen.  */\n    if (n > CF_COUNT_MASK) {\n        cpu_abort(cpu, \"TB too big during recompile\");\n    }\n\n    cflags = n | CF_LAST_IO;\n    pc = tb->pc;\n    cs_base = tb->cs_base;\n    flags = tb->flags;\n    tb_phys_invalidate(tb, -1);\n    if (tb->cflags & CF_NOCACHE) {\n        if (tb->orig_tb) {\n            /* Invalidate original TB if this TB was generated in\n             * cpu_exec_nocache() */\n            tb_phys_invalidate(tb->orig_tb, -1);\n        }\n        tb_free(tb);\n    }\n    /* FIXME: In theory this could raise an exception.  In practice\n       we have already translated the block once so it's probably ok.  */\n    tb_gen_code(cpu, pc, cs_base, flags, cflags);\n\n    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not\n     * the first in the TB) then we end up generating a whole new TB and\n     *  repeating the fault, which is horribly inefficient.\n     *  Better would be to execute just this insn uncached, or generate a\n     *  second new TB.\n     *\n     * cpu_loop_exit_noexc will longjmp back to cpu_exec where the\n     * tb_lock gets reset.\n     */\n    cpu_loop_exit_noexc(cpu);\n}\n\nvoid tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n{\n    unsigned int i;\n\n    /* Discard jump cache entries for any tb which might potentially\n       overlap the flushed page.  */\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n    memset(&cpu->tb_jmp_cache[i], 0,\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n    i = tb_jmp_cache_hash_page(addr);\n    memset(&cpu->tb_jmp_cache[i], 0,\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n}\n\nstatic void print_qht_statistics(FILE *f, fprintf_function cpu_fprintf,\n                                 struct qht_stats hst)\n{\n    uint32_t hgram_opts;\n    size_t hgram_bins;\n    char *hgram;\n\n    if (!hst.head_buckets) {\n        return;\n    }\n    cpu_fprintf(f, \"TB hash buckets     %zu/%zu (%0.2f%% head buckets used)\\n\",\n                hst.used_head_buckets, hst.head_buckets,\n                (double)hst.used_head_buckets / hst.head_buckets * 100);\n\n    hgram_opts =  QDIST_PR_BORDER | QDIST_PR_LABELS;\n    hgram_opts |= QDIST_PR_100X   | QDIST_PR_PERCENT;\n    if (qdist_xmax(&hst.occupancy) - qdist_xmin(&hst.occupancy) == 1) {\n        hgram_opts |= QDIST_PR_NODECIMAL;\n    }\n    hgram = qdist_pr(&hst.occupancy, 10, hgram_opts);\n    cpu_fprintf(f, \"TB hash occupancy   %0.2f%% avg chain occ. Histogram: %s\\n\",\n                qdist_avg(&hst.occupancy) * 100, hgram);\n    g_free(hgram);\n\n    hgram_opts = QDIST_PR_BORDER | QDIST_PR_LABELS;\n    hgram_bins = qdist_xmax(&hst.chain) - qdist_xmin(&hst.chain);\n    if (hgram_bins > 10) {\n        hgram_bins = 10;\n    } else {\n        hgram_bins = 0;\n        hgram_opts |= QDIST_PR_NODECIMAL | QDIST_PR_NOBINRANGE;\n    }\n    hgram = qdist_pr(&hst.chain, hgram_bins, hgram_opts);\n    cpu_fprintf(f, \"TB hash avg chain   %0.3f buckets. Histogram: %s\\n\",\n                qdist_avg(&hst.chain), hgram);\n    g_free(hgram);\n}\n\nvoid dump_exec_info(FILE *f, fprintf_function cpu_fprintf)\n{\n    int i, target_code_size, max_target_code_size;\n    int direct_jmp_count, direct_jmp2_count, cross_page;\n    TranslationBlock *tb;\n    struct qht_stats hst;\n\n    tb_lock();\n\n    target_code_size = 0;\n    max_target_code_size = 0;\n    cross_page = 0;\n    direct_jmp_count = 0;\n    direct_jmp2_count = 0;\n    for (i = 0; i < tcg_ctx.tb_ctx.nb_tbs; i++) {\n        tb = &tcg_ctx.tb_ctx.tbs[i];\n        target_code_size += tb->size;\n        if (tb->size > max_target_code_size) {\n            max_target_code_size = tb->size;\n        }\n        if (tb->page_addr[1] != -1) {\n            cross_page++;\n        }\n        if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n            direct_jmp_count++;\n            if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n                direct_jmp2_count++;\n            }\n        }\n    }\n    /* XXX: avoid using doubles ? */\n    cpu_fprintf(f, \"Translation buffer state:\\n\");\n    cpu_fprintf(f, \"gen code size       %td/%zd\\n\",\n                tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer,\n                tcg_ctx.code_gen_highwater - tcg_ctx.code_gen_buffer);\n    cpu_fprintf(f, \"TB count            %d/%d\\n\",\n            tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.code_gen_max_blocks);\n    cpu_fprintf(f, \"TB avg target size  %d max=%d bytes\\n\",\n            tcg_ctx.tb_ctx.nb_tbs ? target_code_size /\n                    tcg_ctx.tb_ctx.nb_tbs : 0,\n            max_target_code_size);\n    cpu_fprintf(f, \"TB avg host size    %td bytes (expansion ratio: %0.1f)\\n\",\n            tcg_ctx.tb_ctx.nb_tbs ? (tcg_ctx.code_gen_ptr -\n                                     tcg_ctx.code_gen_buffer) /\n                                     tcg_ctx.tb_ctx.nb_tbs : 0,\n                target_code_size ? (double) (tcg_ctx.code_gen_ptr -\n                                             tcg_ctx.code_gen_buffer) /\n                                             target_code_size : 0);\n    cpu_fprintf(f, \"cross page TB count %d (%d%%)\\n\", cross_page,\n            tcg_ctx.tb_ctx.nb_tbs ? (cross_page * 100) /\n                                    tcg_ctx.tb_ctx.nb_tbs : 0);\n    cpu_fprintf(f, \"direct jump count   %d (%d%%) (2 jumps=%d %d%%)\\n\",\n                direct_jmp_count,\n                tcg_ctx.tb_ctx.nb_tbs ? (direct_jmp_count * 100) /\n                        tcg_ctx.tb_ctx.nb_tbs : 0,\n                direct_jmp2_count,\n                tcg_ctx.tb_ctx.nb_tbs ? (direct_jmp2_count * 100) /\n                        tcg_ctx.tb_ctx.nb_tbs : 0);\n\n    qht_statistics_init(&tcg_ctx.tb_ctx.htable, &hst);\n    print_qht_statistics(f, cpu_fprintf, hst);\n    qht_statistics_destroy(&hst);\n\n    cpu_fprintf(f, \"\\nStatistics:\\n\");\n    cpu_fprintf(f, \"TB flush count      %u\\n\",\n            atomic_read(&tcg_ctx.tb_ctx.tb_flush_count));\n    cpu_fprintf(f, \"TB invalidate count %d\\n\",\n            tcg_ctx.tb_ctx.tb_phys_invalidate_count);\n    cpu_fprintf(f, \"TLB flush count     %d\\n\", tlb_flush_count);\n    tcg_dump_info(f, cpu_fprintf);\n\n    tb_unlock();\n}\n\nvoid dump_opcount_info(FILE *f, fprintf_function cpu_fprintf)\n{\n    tcg_dump_op_count(f, cpu_fprintf);\n}\n\n#else /* CONFIG_USER_ONLY */\n\nvoid cpu_interrupt(CPUState *cpu, int mask)\n{\n    cpu->interrupt_request |= mask;\n    cpu->tcg_exit_req = 1;\n}\n\n/*\n * Walks guest process memory \"regions\" one by one\n * and calls callback function 'fn' for each region.\n */\nstruct walk_memory_regions_data {\n    walk_memory_regions_fn fn;\n    void *priv;\n    target_ulong start;\n    int prot;\n};\n\nstatic int walk_memory_regions_end(struct walk_memory_regions_data *data,\n                                   target_ulong end, int new_prot)\n{\n    if (data->start != -1u) {\n        int rc = data->fn(data->priv, data->start, end, data->prot);\n        if (rc != 0) {\n            return rc;\n        }\n    }\n\n    data->start = (new_prot ? end : -1u);\n    data->prot = new_prot;\n\n    return 0;\n}\n\nstatic int walk_memory_regions_1(struct walk_memory_regions_data *data,\n                                 target_ulong base, int level, void **lp)\n{\n    target_ulong pa;\n    int i, rc;\n\n    if (*lp == NULL) {\n        return walk_memory_regions_end(data, base, 0);\n    }\n\n    if (level == 0) {\n        PageDesc *pd = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            int prot = pd[i].flags;\n\n            pa = base | (i << TARGET_PAGE_BITS);\n            if (prot != data->prot) {\n                rc = walk_memory_regions_end(data, pa, prot);\n                if (rc != 0) {\n                    return rc;\n                }\n            }\n        }\n    } else {\n        void **pp = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            pa = base | ((target_ulong)i <<\n                (TARGET_PAGE_BITS + V_L2_BITS * level));\n            rc = walk_memory_regions_1(data, pa, level - 1, pp + i);\n            if (rc != 0) {\n                return rc;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint walk_memory_regions(void *priv, walk_memory_regions_fn fn)\n{\n    struct walk_memory_regions_data data;\n    uintptr_t i, l1_sz = v_l1_size;\n\n    data.fn = fn;\n    data.priv = priv;\n    data.start = -1u;\n    data.prot = 0;\n\n    for (i = 0; i < l1_sz; i++) {\n        target_ulong base = i << (v_l1_shift + TARGET_PAGE_BITS);\n        int rc = walk_memory_regions_1(&data, base, v_l2_levels, l1_map + i);\n        if (rc != 0) {\n            return rc;\n        }\n    }\n\n    return walk_memory_regions_end(&data, 0, 0);\n}\n\nstatic int dump_region(void *priv, target_ulong start,\n    target_ulong end, unsigned long prot)\n{\n    FILE *f = (FILE *)priv;\n\n    (void) fprintf(f, TARGET_FMT_lx\"-\"TARGET_FMT_lx\n        \" \"TARGET_FMT_lx\" %c%c%c\\n\",\n        start, end, end - start,\n        ((prot & PAGE_READ) ? 'r' : '-'),\n        ((prot & PAGE_WRITE) ? 'w' : '-'),\n        ((prot & PAGE_EXEC) ? 'x' : '-'));\n\n    return 0;\n}\n\n/* dump memory mappings */\nvoid page_dump(FILE *f)\n{\n    const int length = sizeof(target_ulong) * 2;\n    (void) fprintf(f, \"%-*s %-*s %-*s %s\\n\",\n            length, \"start\", length, \"end\", length, \"size\", \"prot\");\n    walk_memory_regions(f, dump_region);\n}\n\nint page_get_flags(target_ulong address)\n{\n    PageDesc *p;\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n    if (!p) {\n        return 0;\n    }\n    return p->flags;\n}\n\n/* Modify the flags of a page and invalidate the code if necessary.\n   The flag PAGE_WRITE_ORG is positioned automatically depending\n   on PAGE_WRITE.  The mmap_lock should already be held.  */\nvoid page_set_flags(target_ulong start, target_ulong end, int flags)\n{\n    target_ulong addr, len;\n\n    /* This function should never be called with addresses outside the\n       guest address space.  If this assert fires, it probably indicates\n       a missing call to h2g_valid.  */\n#if TARGET_ABI_BITS > L1_MAP_ADDR_SPACE_BITS\n    assert(end < ((target_ulong)1 << L1_MAP_ADDR_SPACE_BITS));\n#endif\n    assert(start < end);\n    assert_memory_lock();\n\n    start = start & TARGET_PAGE_MASK;\n    end = TARGET_PAGE_ALIGN(end);\n\n    if (flags & PAGE_WRITE) {\n        flags |= PAGE_WRITE_ORG;\n    }\n\n    for (addr = start, len = end - start;\n         len != 0;\n         len -= TARGET_PAGE_SIZE, addr += TARGET_PAGE_SIZE) {\n        PageDesc *p = page_find_alloc(addr >> TARGET_PAGE_BITS, 1);\n\n        /* If the write protection bit is set, then we invalidate\n           the code inside.  */\n        if (!(p->flags & PAGE_WRITE) &&\n            (flags & PAGE_WRITE) &&\n            p->first_tb) {\n            tb_invalidate_phys_page(addr, 0);\n        }\n        p->flags = flags;\n    }\n}\n\nint page_check_range(target_ulong start, target_ulong len, int flags)\n{\n    PageDesc *p;\n    target_ulong end;\n    target_ulong addr;\n\n    /* This function should never be called with addresses outside the\n       guest address space.  If this assert fires, it probably indicates\n       a missing call to h2g_valid.  */\n#if TARGET_ABI_BITS > L1_MAP_ADDR_SPACE_BITS\n    assert(start < ((target_ulong)1 << L1_MAP_ADDR_SPACE_BITS));\n#endif\n\n    if (len == 0) {\n        return 0;\n    }\n    if (start + len - 1 < start) {\n        /* We've wrapped around.  */\n        return -1;\n    }\n\n    /* must do before we loose bits in the next step */\n    end = TARGET_PAGE_ALIGN(start + len);\n    start = start & TARGET_PAGE_MASK;\n\n    for (addr = start, len = end - start;\n         len != 0;\n         len -= TARGET_PAGE_SIZE, addr += TARGET_PAGE_SIZE) {\n        p = page_find(addr >> TARGET_PAGE_BITS);\n        if (!p) {\n            return -1;\n        }\n        if (!(p->flags & PAGE_VALID)) {\n            return -1;\n        }\n\n        if ((flags & PAGE_READ) && !(p->flags & PAGE_READ)) {\n            return -1;\n        }\n        if (flags & PAGE_WRITE) {\n            if (!(p->flags & PAGE_WRITE_ORG)) {\n                return -1;\n            }\n            /* unprotect the page if it was put read-only because it\n               contains translated code */\n            if (!(p->flags & PAGE_WRITE)) {\n                if (!page_unprotect(addr, 0)) {\n                    return -1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n/* called from signal handler: invalidate the code and unprotect the\n * page. Return 0 if the fault was not handled, 1 if it was handled,\n * and 2 if it was handled but the caller must cause the TB to be\n * immediately exited. (We can only return 2 if the 'pc' argument is\n * non-zero.)\n */\nint page_unprotect(target_ulong address, uintptr_t pc)\n{\n    unsigned int prot;\n    bool current_tb_invalidated;\n    PageDesc *p;\n    target_ulong host_start, host_end, addr;\n\n    /* Technically this isn't safe inside a signal handler.  However we\n       know this only ever happens in a synchronous SEGV handler, so in\n       practice it seems to be ok.  */\n    mmap_lock();\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n    if (!p) {\n        mmap_unlock();\n        return 0;\n    }\n\n    /* if the page was really writable, then we change its\n       protection back to writable */\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n        host_start = address & qemu_host_page_mask;\n        host_end = host_start + qemu_host_page_size;\n\n        prot = 0;\n        current_tb_invalidated = false;\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n            p = page_find(addr >> TARGET_PAGE_BITS);\n            p->flags |= PAGE_WRITE;\n            prot |= p->flags;\n\n            /* and since the content will be modified, we must invalidate\n               the corresponding translated code. */\n            current_tb_invalidated |= tb_invalidate_phys_page(addr, pc);\n#ifdef DEBUG_TB_CHECK\n            tb_invalidate_check(addr);\n#endif\n        }\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n                 prot & PAGE_BITS);\n\n        mmap_unlock();\n        /* If current TB was invalidated return to main loop */\n        return current_tb_invalidated ? 2 : 1;\n    }\n    mmap_unlock();\n    return 0;\n}\n#endif /* CONFIG_USER_ONLY */\n"
        },
        {
          "name": "translate-all.h",
          "type": "blob",
          "size": 1.25390625,
          "content": "/*\n *  Translated block handling\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef TRANSLATE_ALL_H\n#define TRANSLATE_ALL_H\n\n#include \"exec/exec-all.h\"\n\n\n/* translate-all.c */\nvoid tb_invalidate_phys_page_fast(tb_page_addr_t start, int len);\nvoid tb_invalidate_phys_page_range(tb_page_addr_t start, tb_page_addr_t end,\n                                   int is_cpu_write_access);\nvoid tb_invalidate_phys_range(tb_page_addr_t start, tb_page_addr_t end);\nvoid tb_check_watchpoint(CPUState *cpu);\n\n#ifdef CONFIG_USER_ONLY\nint page_unprotect(target_ulong address, uintptr_t pc);\n#endif\n\n#endif /* TRANSLATE_ALL_H */\n"
        },
        {
          "name": "translate-common.c",
          "type": "blob",
          "size": 1.6923828125,
          "content": "/*\n *  Host code generation common components\n *\n *  Copyright (c) 2015 Peter Crosthwaite <crosthwaite.peter@gmail.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"qom/cpu.h\"\n#include \"sysemu/cpus.h\"\n\nuintptr_t qemu_real_host_page_size;\nintptr_t qemu_real_host_page_mask;\n\n#ifndef CONFIG_USER_ONLY\n/* mask must never be zero, except for A20 change call */\nstatic void tcg_handle_interrupt(CPUState *cpu, int mask)\n{\n    int old_mask;\n\n    old_mask = cpu->interrupt_request;\n    cpu->interrupt_request |= mask;\n\n    /*\n     * If called from iothread context, wake the target cpu in\n     * case its halted.\n     */\n    if (!qemu_cpu_is_self(cpu)) {\n        qemu_cpu_kick(cpu);\n        return;\n    }\n\n    if (use_icount) {\n        cpu->icount_decr.u16.high = 0xffff;\n        if (!cpu->can_do_io\n            && (mask & ~old_mask) != 0) {\n            cpu_abort(cpu, \"Raised interrupt while not in I/O function\");\n        }\n    } else {\n        cpu->tcg_exit_req = 1;\n    }\n}\n\nCPUInterruptHandler cpu_interrupt_handler = tcg_handle_interrupt;\n#endif\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "user-exec-stub.c",
          "type": "blob",
          "size": 0.4365234375,
          "content": "#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"qom/cpu.h\"\n#include \"sysemu/replay.h\"\n\nvoid cpu_resume(CPUState *cpu)\n{\n}\n\nvoid qemu_init_vcpu(CPUState *cpu)\n{\n}\n\n/* User mode emulation does not support record/replay yet.  */\n\nbool replay_exception(void)\n{\n    return true;\n}\n\nbool replay_has_exception(void)\n{\n    return false;\n}\n\nbool replay_interrupt(void)\n{\n    return true;\n}\n\nbool replay_has_interrupt(void)\n{\n    return false;\n}\n"
        },
        {
          "name": "user-exec.c",
          "type": "blob",
          "size": 17.361328125,
          "content": "/*\n *  User emulator execution\n *\n *  Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"qemu/osdep.h\"\n#include \"cpu.h\"\n#include \"disas/disas.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg.h\"\n#include \"qemu/bitops.h\"\n#include \"exec/cpu_ldst.h\"\n#include \"translate-all.h\"\n\n#undef EAX\n#undef ECX\n#undef EDX\n#undef EBX\n#undef ESP\n#undef EBP\n#undef ESI\n#undef EDI\n#undef EIP\n#ifdef __linux__\n#include <sys/ucontext.h>\n#endif\n\n//#define DEBUG_SIGNAL\n\n/* exit the current TB from a signal handler. The host registers are\n   restored in a state compatible with the CPU emulator\n */\nstatic void cpu_exit_tb_from_sighandler(CPUState *cpu, sigset_t *old_set)\n{\n    /* XXX: use siglongjmp ? */\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n    cpu_loop_exit_noexc(cpu);\n}\n\n/* 'pc' is the host PC at which the exception was raised. 'address' is\n   the effective address of the memory exception. 'is_write' is 1 if a\n   write caused the exception and otherwise 0'. 'old_set' is the\n   signal set which should be restored */\nstatic inline int handle_cpu_signal(uintptr_t pc, unsigned long address,\n                                    int is_write, sigset_t *old_set)\n{\n    CPUState *cpu = current_cpu;\n    CPUClass *cc;\n    int ret;\n\n    /* For synchronous signals we expect to be coming from the vCPU\n     * thread (so current_cpu should be valid) and either from running\n     * code or during translation which can fault as we cross pages.\n     *\n     * If neither is true then something has gone wrong and we should\n     * abort rather than try and restart the vCPU execution.\n     */\n    if (!cpu || !cpu->running) {\n        printf(\"qemu:%s received signal outside vCPU context @ pc=0x%\"\n               PRIxPTR \"\\n\",  __func__, pc);\n        abort();\n    }\n\n#if defined(DEBUG_SIGNAL)\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\",\n           pc, address, is_write, *(unsigned long *)old_set);\n#endif\n    /* XXX: locking issue */\n    if (is_write && h2g_valid(address)) {\n        switch (page_unprotect(h2g(address), pc)) {\n        case 0:\n            /* Fault not caused by a page marked unwritable to protect\n             * cached translations, must be the guest binary's problem\n             */\n            break;\n        case 1:\n            /* Fault caused by protection of cached translation; TBs\n             * invalidated, so resume execution\n             */\n            return 1;\n        case 2:\n            /* Fault caused by protection of cached translation, and the\n             * currently executing TB was modified and must be exited\n             * immediately.\n             */\n            cpu_exit_tb_from_sighandler(cpu, old_set);\n            g_assert_not_reached();\n        default:\n            g_assert_not_reached();\n        }\n    }\n\n    /* Convert forcefully to guest address space, invalid addresses\n       are still valid segv ones */\n    address = h2g_nocheck(address);\n\n    cc = CPU_GET_CLASS(cpu);\n    /* see if it is an MMU fault */\n    g_assert(cc->handle_mmu_fault);\n    ret = cc->handle_mmu_fault(cpu, address, is_write, MMU_USER_IDX);\n    if (ret < 0) {\n        return 0; /* not an MMU fault */\n    }\n    if (ret == 0) {\n        return 1; /* the MMU fault was handled without causing real CPU fault */\n    }\n\n    /* Now we have a real cpu fault.  Since this is the exact location of\n     * the exception, we must undo the adjustment done by cpu_restore_state\n     * for handling call return addresses.  */\n    cpu_restore_state(cpu, pc + GETPC_ADJ);\n\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n    cpu_loop_exit(cpu);\n\n    /* never comes here */\n    return 1;\n}\n\n#if defined(__i386__)\n\n#if defined(__NetBSD__)\n#include <ucontext.h>\n\n#define EIP_sig(context)     ((context)->uc_mcontext.__gregs[_REG_EIP])\n#define TRAP_sig(context)    ((context)->uc_mcontext.__gregs[_REG_TRAPNO])\n#define ERROR_sig(context)   ((context)->uc_mcontext.__gregs[_REG_ERR])\n#define MASK_sig(context)    ((context)->uc_sigmask)\n#elif defined(__FreeBSD__) || defined(__DragonFly__)\n#include <ucontext.h>\n\n#define EIP_sig(context)  (*((unsigned long *)&(context)->uc_mcontext.mc_eip))\n#define TRAP_sig(context)    ((context)->uc_mcontext.mc_trapno)\n#define ERROR_sig(context)   ((context)->uc_mcontext.mc_err)\n#define MASK_sig(context)    ((context)->uc_sigmask)\n#elif defined(__OpenBSD__)\n#define EIP_sig(context)     ((context)->sc_eip)\n#define TRAP_sig(context)    ((context)->sc_trapno)\n#define ERROR_sig(context)   ((context)->sc_err)\n#define MASK_sig(context)    ((context)->sc_mask)\n#else\n#define EIP_sig(context)     ((context)->uc_mcontext.gregs[REG_EIP])\n#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])\n#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])\n#define MASK_sig(context)    ((context)->uc_sigmask)\n#endif\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n    ucontext_t *uc = puc;\n#elif defined(__OpenBSD__)\n    struct sigcontext *uc = puc;\n#else\n    struct ucontext *uc = puc;\n#endif\n    unsigned long pc;\n    int trapno;\n\n#ifndef REG_EIP\n/* for glibc 2.1 */\n#define REG_EIP    EIP\n#define REG_ERR    ERR\n#define REG_TRAPNO TRAPNO\n#endif\n    pc = EIP_sig(uc);\n    trapno = TRAP_sig(uc);\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             trapno == 0xe ?\n                             (ERROR_sig(uc) >> 1) & 1 : 0,\n                             &MASK_sig(uc));\n}\n\n#elif defined(__x86_64__)\n\n#ifdef __NetBSD__\n#define PC_sig(context)       _UC_MACHINE_PC(context)\n#define TRAP_sig(context)     ((context)->uc_mcontext.__gregs[_REG_TRAPNO])\n#define ERROR_sig(context)    ((context)->uc_mcontext.__gregs[_REG_ERR])\n#define MASK_sig(context)     ((context)->uc_sigmask)\n#elif defined(__OpenBSD__)\n#define PC_sig(context)       ((context)->sc_rip)\n#define TRAP_sig(context)     ((context)->sc_trapno)\n#define ERROR_sig(context)    ((context)->sc_err)\n#define MASK_sig(context)     ((context)->sc_mask)\n#elif defined(__FreeBSD__) || defined(__DragonFly__)\n#include <ucontext.h>\n\n#define PC_sig(context)  (*((unsigned long *)&(context)->uc_mcontext.mc_rip))\n#define TRAP_sig(context)     ((context)->uc_mcontext.mc_trapno)\n#define ERROR_sig(context)    ((context)->uc_mcontext.mc_err)\n#define MASK_sig(context)     ((context)->uc_sigmask)\n#else\n#define PC_sig(context)       ((context)->uc_mcontext.gregs[REG_RIP])\n#define TRAP_sig(context)     ((context)->uc_mcontext.gregs[REG_TRAPNO])\n#define ERROR_sig(context)    ((context)->uc_mcontext.gregs[REG_ERR])\n#define MASK_sig(context)     ((context)->uc_sigmask)\n#endif\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n    unsigned long pc;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n    ucontext_t *uc = puc;\n#elif defined(__OpenBSD__)\n    struct sigcontext *uc = puc;\n#else\n    struct ucontext *uc = puc;\n#endif\n\n    pc = PC_sig(uc);\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             TRAP_sig(uc) == 0xe ?\n                             (ERROR_sig(uc) >> 1) & 1 : 0,\n                             &MASK_sig(uc));\n}\n\n#elif defined(_ARCH_PPC)\n\n/***********************************************************************\n * signal context platform-specific definitions\n * From Wine\n */\n#ifdef linux\n/* All Registers access - only for local access */\n#define REG_sig(reg_name, context)              \\\n    ((context)->uc_mcontext.regs->reg_name)\n/* Gpr Registers access  */\n#define GPR_sig(reg_num, context)              REG_sig(gpr[reg_num], context)\n/* Program counter */\n#define IAR_sig(context)                       REG_sig(nip, context)\n/* Machine State Register (Supervisor) */\n#define MSR_sig(context)                       REG_sig(msr, context)\n/* Count register */\n#define CTR_sig(context)                       REG_sig(ctr, context)\n/* User's integer exception register */\n#define XER_sig(context)                       REG_sig(xer, context)\n/* Link register */\n#define LR_sig(context)                        REG_sig(link, context)\n/* Condition register */\n#define CR_sig(context)                        REG_sig(ccr, context)\n\n/* Float Registers access  */\n#define FLOAT_sig(reg_num, context)                                     \\\n    (((double *)((char *)((context)->uc_mcontext.regs + 48 * 4)))[reg_num])\n#define FPSCR_sig(context) \\\n    (*(int *)((char *)((context)->uc_mcontext.regs + (48 + 32 * 2) * 4)))\n/* Exception Registers access */\n#define DAR_sig(context)                       REG_sig(dar, context)\n#define DSISR_sig(context)                     REG_sig(dsisr, context)\n#define TRAP_sig(context)                      REG_sig(trap, context)\n#endif /* linux */\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\n#include <ucontext.h>\n#define IAR_sig(context)               ((context)->uc_mcontext.mc_srr0)\n#define MSR_sig(context)               ((context)->uc_mcontext.mc_srr1)\n#define CTR_sig(context)               ((context)->uc_mcontext.mc_ctr)\n#define XER_sig(context)               ((context)->uc_mcontext.mc_xer)\n#define LR_sig(context)                ((context)->uc_mcontext.mc_lr)\n#define CR_sig(context)                ((context)->uc_mcontext.mc_cr)\n/* Exception Registers access */\n#define DAR_sig(context)               ((context)->uc_mcontext.mc_dar)\n#define DSISR_sig(context)             ((context)->uc_mcontext.mc_dsisr)\n#define TRAP_sig(context)              ((context)->uc_mcontext.mc_exc)\n#endif /* __FreeBSD__|| __FreeBSD_kernel__ */\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\n    ucontext_t *uc = puc;\n#else\n    struct ucontext *uc = puc;\n#endif\n    unsigned long pc;\n    int is_write;\n\n    pc = IAR_sig(uc);\n    is_write = 0;\n#if 0\n    /* ppc 4xx case */\n    if (DSISR_sig(uc) & 0x00800000) {\n        is_write = 1;\n    }\n#else\n    if (TRAP_sig(uc) != 0x400 && (DSISR_sig(uc) & 0x02000000)) {\n        is_write = 1;\n    }\n#endif\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write, &uc->uc_sigmask);\n}\n\n#elif defined(__alpha__)\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                           void *puc)\n{\n    siginfo_t *info = pinfo;\n    struct ucontext *uc = puc;\n    uint32_t *pc = uc->uc_mcontext.sc_pc;\n    uint32_t insn = *pc;\n    int is_write = 0;\n\n    /* XXX: need kernel patch to get write flag faster */\n    switch (insn >> 26) {\n    case 0x0d: /* stw */\n    case 0x0e: /* stb */\n    case 0x0f: /* stq_u */\n    case 0x24: /* stf */\n    case 0x25: /* stg */\n    case 0x26: /* sts */\n    case 0x27: /* stt */\n    case 0x2c: /* stl */\n    case 0x2d: /* stq */\n    case 0x2e: /* stl_c */\n    case 0x2f: /* stq_c */\n        is_write = 1;\n    }\n\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write, &uc->uc_sigmask);\n}\n#elif defined(__sparc__)\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n    int is_write;\n    uint32_t insn;\n#if !defined(__arch64__) || defined(CONFIG_SOLARIS)\n    uint32_t *regs = (uint32_t *)(info + 1);\n    void *sigmask = (regs + 20);\n    /* XXX: is there a standard glibc define ? */\n    unsigned long pc = regs[1];\n#else\n#ifdef __linux__\n    struct sigcontext *sc = puc;\n    unsigned long pc = sc->sigc_regs.tpc;\n    void *sigmask = (void *)sc->sigc_mask;\n#elif defined(__OpenBSD__)\n    struct sigcontext *uc = puc;\n    unsigned long pc = uc->sc_pc;\n    void *sigmask = (void *)(long)uc->sc_mask;\n#elif defined(__NetBSD__)\n    ucontext_t *uc = puc;\n    unsigned long pc = _UC_MACHINE_PC(uc);\n    void *sigmask = (void *)&uc->uc_sigmask;\n#endif\n#endif\n\n    /* XXX: need kernel patch to get write flag faster */\n    is_write = 0;\n    insn = *(uint32_t *)pc;\n    if ((insn >> 30) == 3) {\n        switch ((insn >> 19) & 0x3f) {\n        case 0x05: /* stb */\n        case 0x15: /* stba */\n        case 0x06: /* sth */\n        case 0x16: /* stha */\n        case 0x04: /* st */\n        case 0x14: /* sta */\n        case 0x07: /* std */\n        case 0x17: /* stda */\n        case 0x0e: /* stx */\n        case 0x1e: /* stxa */\n        case 0x24: /* stf */\n        case 0x34: /* stfa */\n        case 0x27: /* stdf */\n        case 0x37: /* stdfa */\n        case 0x26: /* stqf */\n        case 0x36: /* stqfa */\n        case 0x25: /* stfsr */\n        case 0x3c: /* casa */\n        case 0x3e: /* casxa */\n            is_write = 1;\n            break;\n        }\n    }\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write, sigmask);\n}\n\n#elif defined(__arm__)\n\n#if defined(__NetBSD__)\n#include <ucontext.h>\n#endif\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n#if defined(__NetBSD__)\n    ucontext_t *uc = puc;\n#else\n    struct ucontext *uc = puc;\n#endif\n    unsigned long pc;\n    int is_write;\n\n#if defined(__NetBSD__)\n    pc = uc->uc_mcontext.__gregs[_REG_R15];\n#elif defined(__GLIBC__) && (__GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ <= 3))\n    pc = uc->uc_mcontext.gregs[R15];\n#else\n    pc = uc->uc_mcontext.arm_pc;\n#endif\n\n    /* error_code is the FSR value, in which bit 11 is WnR (assuming a v6 or\n     * later processor; on v5 we will always report this as a read).\n     */\n    is_write = extract32(uc->uc_mcontext.error_code, 11, 1);\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write,\n                             &uc->uc_sigmask);\n}\n\n#elif defined(__aarch64__)\n\nint cpu_signal_handler(int host_signum, void *pinfo, void *puc)\n{\n    siginfo_t *info = pinfo;\n    struct ucontext *uc = puc;\n    uintptr_t pc = uc->uc_mcontext.pc;\n    uint32_t insn = *(uint32_t *)pc;\n    bool is_write;\n\n    /* XXX: need kernel patch to get write flag faster.  */\n    is_write = (   (insn & 0xbfff0000) == 0x0c000000   /* C3.3.1 */\n                || (insn & 0xbfe00000) == 0x0c800000   /* C3.3.2 */\n                || (insn & 0xbfdf0000) == 0x0d000000   /* C3.3.3 */\n                || (insn & 0xbfc00000) == 0x0d800000   /* C3.3.4 */\n                || (insn & 0x3f400000) == 0x08000000   /* C3.3.6 */\n                || (insn & 0x3bc00000) == 0x39000000   /* C3.3.13 */\n                || (insn & 0x3fc00000) == 0x3d800000   /* ... 128bit */\n                /* Ingore bits 10, 11 & 21, controlling indexing.  */\n                || (insn & 0x3bc00000) == 0x38000000   /* C3.3.8-12 */\n                || (insn & 0x3fe00000) == 0x3c800000   /* ... 128bit */\n                /* Ignore bits 23 & 24, controlling indexing.  */\n                || (insn & 0x3a400000) == 0x28000000); /* C3.3.7,14-16 */\n\n    return handle_cpu_signal(pc, (uintptr_t)info->si_addr,\n                             is_write, &uc->uc_sigmask);\n}\n\n#elif defined(__s390__)\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n    struct ucontext *uc = puc;\n    unsigned long pc;\n    uint16_t *pinsn;\n    int is_write = 0;\n\n    pc = uc->uc_mcontext.psw.addr;\n\n    /* ??? On linux, the non-rt signal handler has 4 (!) arguments instead\n       of the normal 2 arguments.  The 3rd argument contains the \"int_code\"\n       from the hardware which does in fact contain the is_write value.\n       The rt signal handler, as far as I can tell, does not give this value\n       at all.  Not that we could get to it from here even if it were.  */\n    /* ??? This is not even close to complete, since it ignores all\n       of the read-modify-write instructions.  */\n    pinsn = (uint16_t *)pc;\n    switch (pinsn[0] >> 8) {\n    case 0x50: /* ST */\n    case 0x42: /* STC */\n    case 0x40: /* STH */\n        is_write = 1;\n        break;\n    case 0xc4: /* RIL format insns */\n        switch (pinsn[0] & 0xf) {\n        case 0xf: /* STRL */\n        case 0xb: /* STGRL */\n        case 0x7: /* STHRL */\n            is_write = 1;\n        }\n        break;\n    case 0xe3: /* RXY format insns */\n        switch (pinsn[2] & 0xff) {\n        case 0x50: /* STY */\n        case 0x24: /* STG */\n        case 0x72: /* STCY */\n        case 0x70: /* STHY */\n        case 0x8e: /* STPQ */\n        case 0x3f: /* STRVH */\n        case 0x3e: /* STRV */\n        case 0x2f: /* STRVG */\n            is_write = 1;\n        }\n        break;\n    }\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write, &uc->uc_sigmask);\n}\n\n#elif defined(__mips__)\n\nint cpu_signal_handler(int host_signum, void *pinfo,\n                       void *puc)\n{\n    siginfo_t *info = pinfo;\n    struct ucontext *uc = puc;\n    greg_t pc = uc->uc_mcontext.pc;\n    int is_write;\n\n    /* XXX: compute is_write */\n    is_write = 0;\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n                             is_write, &uc->uc_sigmask);\n}\n\n#else\n\n#error host CPU specific signal handler needed\n\n#endif\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.rc",
          "type": "blob",
          "size": 0.7783203125,
          "content": "#include <winver.h>\n#include \"config-host.h\"\n\nVS_VERSION_INFO VERSIONINFO\nFILEVERSION CONFIG_FILEVERSION\nPRODUCTVERSION CONFIG_PRODUCTVERSION\nFILEFLAGSMASK VS_FFI_FILEFLAGSMASK\nFILEOS VOS_NT_WINDOWS32\nFILETYPE VFT_APP\nFILESUBTYPE VFT2_UNKNOWN\n{\n  BLOCK \"StringFileInfo\"\n  {\n    BLOCK \"040904E4\"\n    {\n      VALUE \"CompanyName\", \"http://www.qemu-project.org\"\n      VALUE \"FileDescription\", \"QEMU machine emulators and tools\"\n      VALUE \"FileVersion\", QEMU_VERSION\n      VALUE \"LegalCopyright\", \"Copyright various authors. Released under the GNU General Public License.\"\n      VALUE \"LegalTrademarks\", \"QEMU is a trademark of Fabrice Bellard.\"\n      VALUE \"ProductName\", \"QEMU\"\n    }\n  }\n  BLOCK \"VarFileInfo\"\n  {\n    VALUE \"Translation\", 0x0409, 1252\n  }\n}\n\nIDI_ICON1 ICON \"pc-bios/qemu-nsis.ico\"\n"
        },
        {
          "name": "vl.c",
          "type": "blob",
          "size": 151.1484375,
          "content": "/*\n * QEMU System Emulator\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*\n * The file was modified for S2E Selective Symbolic Execution Framework\n *\n * Copyright (c) 2010, Dependable Systems Laboratory, EPFL\n *\n * Currently maintained by:\n *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>\n *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>\n *\n * All contributors are listed in S2E-AUTHORS file.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-version.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/help_option.h\"\n#include \"qemu/uuid.h\"\n#include <unistd.h>\n#include <glib.h>\n\n#ifdef CONFIG_SECCOMP\n#include \"sysemu/seccomp.h\"\n#endif\n\n#if defined(CONFIG_VDE)\n#include <libvdeplug.h>\n#endif\n\n#ifdef CONFIG_SDL\n#if defined(__APPLE__) || defined(main)\n#include <SDL.h>\nint qemu_main(int argc, char **argv, char **envp);\nint main(int argc, char **argv)\n{\n    return qemu_main(argc, argv, NULL);\n}\n#undef main\n#define main qemu_main\n#endif\n#endif /* CONFIG_SDL */\n\n#ifdef CONFIG_COCOA\n#undef main\n#define main qemu_main\n#endif /* CONFIG_COCOA */\n\n\n#include \"qemu/error-report.h\"\n#include \"qemu/sockets.h\"\n#include \"hw/hw.h\"\n#include \"hw/boards.h\"\n#include \"sysemu/accel.h\"\n#include \"hw/usb.h\"\n#include \"hw/i386/pc.h\"\n#include \"hw/isa/isa.h\"\n#include \"hw/scsi/scsi.h\"\n#include \"hw/bt.h\"\n#include \"sysemu/watchdog.h\"\n#include \"hw/smbios/smbios.h\"\n#include \"hw/acpi/acpi.h\"\n#include \"hw/xen/xen.h\"\n#include \"hw/qdev.h\"\n#include \"hw/loader.h\"\n#include \"monitor/qdev.h\"\n#include \"sysemu/bt.h\"\n#include \"net/net.h\"\n#include \"net/slirp.h\"\n#include \"monitor/monitor.h\"\n#include \"ui/console.h\"\n#include \"ui/input.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/numa.h\"\n#include \"exec/gdbstub.h\"\n#include \"qemu/timer.h\"\n#include \"sysemu/char.h\"\n#include \"qemu/bitmap.h\"\n#include \"qemu/log.h\"\n#include \"sysemu/blockdev.h\"\n#include \"hw/block/block.h\"\n#include \"migration/block.h\"\n#include \"sysemu/tpm.h\"\n#include \"sysemu/dma.h\"\n#include \"audio/audio.h\"\n#include \"migration/migration.h\"\n#include \"sysemu/cpus.h\"\n#include \"migration/colo.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/hax.h\"\n#include \"qapi/qobject-input-visitor.h\"\n#include \"qapi/qobject-input-visitor.h\"\n#include \"qapi-visit.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu-options.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/main-loop.h\"\n#ifdef CONFIG_VIRTFS\n#include \"fsdev/qemu-fsdev.h\"\n#endif\n#include \"sysemu/qtest.h\"\n\n#include \"disas/disas.h\"\n\n#include \"slirp/libslirp.h\"\n\n#include \"trace-root.h\"\n#include \"trace/control.h\"\n#include \"qemu/queue.h\"\n#include \"sysemu/arch_init.h\"\n\n#include \"ui/qemu-spice.h\"\n#include \"qapi/string-input-visitor.h\"\n#include \"qapi/opts-visitor.h\"\n#include \"qom/object_interfaces.h\"\n#include \"qapi-event.h\"\n#include \"exec/semihost.h\"\n#include \"crypto/init.h\"\n#include \"sysemu/replay.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"sysemu/iothread.h\"\n#include \"migration/savevm.h\"\n\n#include \"vl.h\"\n\nextern void panda_cleanup(void);\nextern bool panda_add_arg(const char *, const char *);\nextern bool panda_load_plugin(const char *, const char *);\nextern void panda_unload_plugins(void);\nextern char *panda_plugin_path(const char *name);\nextern void panda_set_os_name(char *os_name);\nextern void panda_callbacks_after_machine_init(CPUState *);\nextern void panda_callbacks_pre_shutdown(void);\nextern void panda_callbacks_main_loop_wait(void);\nextern void pandalog_cc_init_write(const char * fname);\n\nint pandalog = 0;\nint panda_in_main_loop = 0;\nextern bool panda_abort_requested; // When set, we exit in after printing a help message\nbool panda_break_vl_loop_req = false; // When set, we break the main loop in vl.c\nbool panda_aborted = false; // Set if panda was terminated abnormally (e.g., Ctrl-C)\nint panda_complete_rr_snapshot = 0;\n\nchar *panda_snap_name = NULL;\nconst char* replay_name = NULL;\n\n#include \"panda/debug.h\"\n#include \"panda/rr/rr_log_all.h\"\n\n#ifdef CONFIG_LLVM\nstruct TCGLLVMTranslator;\n\nextern struct TCGLLVMTranslator* tcg_llvm_translator;\nextern int generate_llvm;\nextern int execute_llvm;\nextern const int has_llvm_engine;\n\nvoid tcg_llvm_initialize(void);\nvoid tcg_llvm_destroy(void);\n#endif\n\n#define MAX_VIRTIO_CONSOLES 1\n#define MAX_SCLP_CONSOLES 1\n\nstatic const char *data_dir[16];\nstatic int data_dir_idx;\nconst char *bios_name = NULL;\nenum vga_retrace_method vga_retrace_method = VGA_RETRACE_DUMB;\nint request_opengl = -1;\nint display_opengl;\nconst char* keyboard_layout = NULL;\nram_addr_t ram_size;\nconst char *mem_path = NULL;\nint mem_prealloc = 0; /* force preallocation of physical target memory */\nbool enable_mlock = false;\nint nb_nics;\nNICInfo nd_table[MAX_NICS];\nint autostart;\nstatic int rtc_utc = 1;\nstatic int rtc_date_offset = -1; /* -1 means no change */\nQEMUClockType rtc_clock;\nint vga_interface_type = VGA_NONE;\nstatic int full_screen = 0;\nstatic int no_frame = 0;\nint no_quit = 0;\nstatic bool grab_on_hover;\nChardev *serial_hds[MAX_SERIAL_PORTS];\nChardev *parallel_hds[MAX_PARALLEL_PORTS];\nChardev *virtcon_hds[MAX_VIRTIO_CONSOLES];\nChardev *sclp_hds[MAX_SCLP_CONSOLES];\nint win2k_install_hack = 0;\nint singlestep = 0;\nint smp_cpus = 1;\nint max_cpus = 1;\nint smp_cores = 1;\nint smp_threads = 1;\nint acpi_enabled = 1;\nint no_hpet = 0;\nint fd_bootchk = 1;\nstatic int no_reboot;\nint no_shutdown = 0;\nint cursor_hide = 1;\nint graphic_rotate = 0;\nconst char *watchdog;\nQEMUOptionRom option_rom[MAX_OPTION_ROMS];\nint nb_option_roms;\nint old_param = 0;\nconst char *qemu_name;\nint alt_grab = 0;\nint ctrl_grab = 0;\nunsigned int nb_prom_envs = 0;\nconst char *prom_envs[MAX_PROM_ENVS];\nint boot_menu;\nbool boot_strict;\nuint8_t *boot_splash_filedata;\nsize_t boot_splash_filedata_size;\nuint8_t qemu_extra_params_fw[2];\nint only_migratable; /* turn it off unless user states otherwise */\n\n/* hack to get at the QEMU monitor */\nvoid *qemu_mon = NULL;\n\nint icount_align_option;\n\n/* The bytes in qemu_uuid are in the order specified by RFC4122, _not_ in the\n * little-endian \"wire format\" described in the SMBIOS 2.6 specification.\n */\nQemuUUID qemu_uuid;\nbool qemu_uuid_set;\n\nstatic NotifierList exit_notifiers =\n    NOTIFIER_LIST_INITIALIZER(exit_notifiers);\n\nstatic NotifierList machine_init_done_notifiers =\n    NOTIFIER_LIST_INITIALIZER(machine_init_done_notifiers);\n\nbool xen_allowed;\nuint32_t xen_domid;\nenum xen_mode xen_mode = XEN_EMULATE;\n\nstatic int has_defaults = 1;\nstatic int default_serial = 1;\nstatic int default_parallel = 1;\nstatic int default_virtcon = 1;\nstatic int default_sclp = 1;\nstatic int default_monitor = 1;\nstatic int default_floppy = 1;\nstatic int default_cdrom = 1;\nstatic int default_sdcard = 1;\nstatic int default_vga = 1;\nstatic int default_net = 1;\n\nstatic struct {\n    const char *driver;\n    int *flag;\n} default_list[] = {\n    { .driver = \"isa-serial\",           .flag = &default_serial    },\n    { .driver = \"isa-parallel\",         .flag = &default_parallel  },\n    { .driver = \"isa-fdc\",              .flag = &default_floppy    },\n    { .driver = \"floppy\",               .flag = &default_floppy    },\n    { .driver = \"ide-cd\",               .flag = &default_cdrom     },\n    { .driver = \"ide-hd\",               .flag = &default_cdrom     },\n    { .driver = \"ide-drive\",            .flag = &default_cdrom     },\n    { .driver = \"scsi-cd\",              .flag = &default_cdrom     },\n    { .driver = \"scsi-hd\",              .flag = &default_cdrom     },\n    { .driver = \"virtio-serial-pci\",    .flag = &default_virtcon   },\n    { .driver = \"virtio-serial\",        .flag = &default_virtcon   },\n    { .driver = \"VGA\",                  .flag = &default_vga       },\n    { .driver = \"isa-vga\",              .flag = &default_vga       },\n    { .driver = \"cirrus-vga\",           .flag = &default_vga       },\n    { .driver = \"isa-cirrus-vga\",       .flag = &default_vga       },\n    { .driver = \"vmware-svga\",          .flag = &default_vga       },\n    { .driver = \"qxl-vga\",              .flag = &default_vga       },\n    { .driver = \"virtio-vga\",           .flag = &default_vga       },\n};\n\nstatic QemuOptsList qemu_rtc_opts = {\n    .name = \"rtc\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_rtc_opts.head),\n    .desc = {\n        {\n            .name = \"base\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"clock\",\n            .type = QEMU_OPT_STRING,\n        },{\n            .name = \"driftfix\",\n            .type = QEMU_OPT_STRING,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_sandbox_opts = {\n    .name = \"sandbox\",\n    .implied_opt_name = \"enable\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_sandbox_opts.head),\n    .desc = {\n        {\n            .name = \"enable\",\n            .type = QEMU_OPT_BOOL,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_option_rom_opts = {\n    .name = \"option-rom\",\n    .implied_opt_name = \"romfile\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_option_rom_opts.head),\n    .desc = {\n        {\n            .name = \"bootindex\",\n            .type = QEMU_OPT_NUMBER,\n        }, {\n            .name = \"romfile\",\n            .type = QEMU_OPT_STRING,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_machine_opts = {\n    .name = \"machine\",\n    .implied_opt_name = \"type\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_machine_opts.head),\n    .desc = {\n        /*\n         * no elements => accept any\n         * sanity checking will happen later\n         * when setting machine properties\n         */\n        { }\n    },\n};\n\nstatic QemuOptsList qemu_accel_opts = {\n    .name = \"accel\",\n    .implied_opt_name = \"accel\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_accel_opts.head),\n    .merge_lists = true,\n    .desc = {\n        {\n            .name = \"accel\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Select the type of accelerator\",\n        },\n        {\n            .name = \"thread\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Enable/disable multi-threaded TCG\",\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_boot_opts = {\n    .name = \"boot-opts\",\n    .implied_opt_name = \"order\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_boot_opts.head),\n    .desc = {\n        {\n            .name = \"order\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"once\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"menu\",\n            .type = QEMU_OPT_BOOL,\n        }, {\n            .name = \"splash\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"splash-time\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"reboot-timeout\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"strict\",\n            .type = QEMU_OPT_BOOL,\n        },\n        { /*End of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_add_fd_opts = {\n    .name = \"add-fd\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_add_fd_opts.head),\n    .desc = {\n        {\n            .name = \"fd\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"file descriptor of which a duplicate is added to fd set\",\n        },{\n            .name = \"set\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"ID of the fd set to add fd to\",\n        },{\n            .name = \"opaque\",\n            .type = QEMU_OPT_STRING,\n            .help = \"free-form string used to describe fd\",\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_object_opts = {\n    .name = \"object\",\n    .implied_opt_name = \"qom-type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_object_opts.head),\n    .desc = {\n        { }\n    },\n};\n\nstatic QemuOptsList qemu_tpmdev_opts = {\n    .name = \"tpmdev\",\n    .implied_opt_name = \"type\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_tpmdev_opts.head),\n    .desc = {\n        /* options are defined in the TPM backends */\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_realtime_opts = {\n    .name = \"realtime\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_realtime_opts.head),\n    .desc = {\n        {\n            .name = \"mlock\",\n            .type = QEMU_OPT_BOOL,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_msg_opts = {\n    .name = \"msg\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_msg_opts.head),\n    .desc = {\n        {\n            .name = \"timestamp\",\n            .type = QEMU_OPT_BOOL,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_name_opts = {\n    .name = \"name\",\n    .implied_opt_name = \"guest\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_name_opts.head),\n    .desc = {\n        {\n            .name = \"guest\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Sets the name of the guest.\\n\"\n                    \"This name will be displayed in the SDL window caption.\\n\"\n                    \"The name will also be used for the VNC server\",\n        }, {\n            .name = \"process\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Sets the name of the QEMU process, as shown in top etc\",\n        }, {\n            .name = \"debug-threads\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"When enabled, name the individual threads; defaults off.\\n\"\n                    \"NOTE: The thread names are for debugging and not a\\n\"\n                    \"stable API.\",\n        },\n        { /* End of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_mem_opts = {\n    .name = \"memory\",\n    .implied_opt_name = \"size\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_mem_opts.head),\n    .merge_lists = true,\n    .desc = {\n        {\n            .name = \"size\",\n            .type = QEMU_OPT_SIZE,\n        },\n        {\n            .name = \"slots\",\n            .type = QEMU_OPT_NUMBER,\n        },\n        {\n            .name = \"maxmem\",\n            .type = QEMU_OPT_SIZE,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_icount_opts = {\n    .name = \"icount\",\n    .implied_opt_name = \"shift\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_icount_opts.head),\n    .desc = {\n        {\n            .name = \"shift\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"align\",\n            .type = QEMU_OPT_BOOL,\n        }, {\n            .name = \"sleep\",\n            .type = QEMU_OPT_BOOL,\n        }, {\n            .name = \"rr\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"rrfile\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"rrsnapshot\",\n            .type = QEMU_OPT_STRING,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_semihosting_config_opts = {\n    .name = \"semihosting-config\",\n    .implied_opt_name = \"enable\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_semihosting_config_opts.head),\n    .desc = {\n        {\n            .name = \"enable\",\n            .type = QEMU_OPT_BOOL,\n        }, {\n            .name = \"target\",\n            .type = QEMU_OPT_STRING,\n        }, {\n            .name = \"arg\",\n            .type = QEMU_OPT_STRING,\n        },\n        { /* end of list */ }\n    },\n};\n\nstatic QemuOptsList qemu_fw_cfg_opts = {\n    .name = \"fw_cfg\",\n    .implied_opt_name = \"name\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_fw_cfg_opts.head),\n    .desc = {\n        {\n            .name = \"name\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Sets the fw_cfg name of the blob to be inserted\",\n        }, {\n            .name = \"file\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Sets the name of the file from which\\n\"\n                    \"the fw_cfg blob will be loaded\",\n        }, {\n            .name = \"string\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Sets content of the blob to be inserted from a string\",\n        },\n        { /* end of list */ }\n    },\n};\n\n/**\n * Get machine options\n *\n * Returns: machine options (never null).\n */\nQemuOpts *qemu_get_machine_opts(void)\n{\n    return qemu_find_opts_singleton(\"machine\");\n}\n\nconst char *qemu_get_vm_name(void)\n{\n    return qemu_name;\n}\n\nstatic void res_free(void)\n{\n    g_free(boot_splash_filedata);\n    boot_splash_filedata = NULL;\n}\n\nstatic int default_driver_check(void *opaque, QemuOpts *opts, Error **errp)\n{\n    const char *driver = qemu_opt_get(opts, \"driver\");\n    int i;\n\n    if (!driver)\n        return 0;\n    for (i = 0; i < ARRAY_SIZE(default_list); i++) {\n        if (strcmp(default_list[i].driver, driver) != 0)\n            continue;\n        *(default_list[i].flag) = 0;\n    }\n    return 0;\n}\n\n/***********************************************************/\n/* QEMU state */\n\nstatic RunState current_run_state = RUN_STATE_PRELAUNCH;\n\n/* We use RUN_STATE__MAX but any invalid value will do */\nstatic RunState vmstop_requested = RUN_STATE__MAX;\nstatic QemuMutex vmstop_lock;\n\ntypedef struct {\n    RunState from;\n    RunState to;\n} RunStateTransition;\n\nstatic const RunStateTransition runstate_transitions_def[] = {\n    /*     from      ->     to      */\n    { RUN_STATE_DEBUG, RUN_STATE_RUNNING },\n    { RUN_STATE_DEBUG, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_DEBUG, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_INMIGRATE, RUN_STATE_INTERNAL_ERROR },\n    { RUN_STATE_INMIGRATE, RUN_STATE_IO_ERROR },\n    { RUN_STATE_INMIGRATE, RUN_STATE_PAUSED },\n    { RUN_STATE_INMIGRATE, RUN_STATE_RUNNING },\n    { RUN_STATE_INMIGRATE, RUN_STATE_SHUTDOWN },\n    { RUN_STATE_INMIGRATE, RUN_STATE_SUSPENDED },\n    { RUN_STATE_INMIGRATE, RUN_STATE_WATCHDOG },\n    { RUN_STATE_INMIGRATE, RUN_STATE_GUEST_PANICKED },\n    { RUN_STATE_INMIGRATE, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_INMIGRATE, RUN_STATE_PRELAUNCH },\n    { RUN_STATE_INMIGRATE, RUN_STATE_POSTMIGRATE },\n    { RUN_STATE_INMIGRATE, RUN_STATE_COLO },\n\n    { RUN_STATE_INTERNAL_ERROR, RUN_STATE_PAUSED },\n    { RUN_STATE_INTERNAL_ERROR, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_INTERNAL_ERROR, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_IO_ERROR, RUN_STATE_RUNNING },\n    { RUN_STATE_IO_ERROR, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_IO_ERROR, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_PAUSED, RUN_STATE_RUNNING },\n    { RUN_STATE_PAUSED, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_PAUSED, RUN_STATE_PRELAUNCH },\n    { RUN_STATE_PAUSED, RUN_STATE_COLO},\n\n    { RUN_STATE_POSTMIGRATE, RUN_STATE_RUNNING },\n    { RUN_STATE_POSTMIGRATE, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_POSTMIGRATE, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_PRELAUNCH, RUN_STATE_RUNNING },\n    { RUN_STATE_PRELAUNCH, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_PRELAUNCH, RUN_STATE_INMIGRATE },\n\n    { RUN_STATE_FINISH_MIGRATE, RUN_STATE_RUNNING },\n    { RUN_STATE_FINISH_MIGRATE, RUN_STATE_POSTMIGRATE },\n    { RUN_STATE_FINISH_MIGRATE, RUN_STATE_PRELAUNCH },\n    { RUN_STATE_FINISH_MIGRATE, RUN_STATE_COLO},\n\n    { RUN_STATE_RESTORE_VM, RUN_STATE_RUNNING },\n    { RUN_STATE_RESTORE_VM, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_COLO, RUN_STATE_RUNNING },\n\n    { RUN_STATE_RUNNING, RUN_STATE_DEBUG },\n    { RUN_STATE_RUNNING, RUN_STATE_INTERNAL_ERROR },\n    { RUN_STATE_RUNNING, RUN_STATE_IO_ERROR },\n    { RUN_STATE_RUNNING, RUN_STATE_PAUSED },\n    { RUN_STATE_RUNNING, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_RUNNING, RUN_STATE_RESTORE_VM },\n    { RUN_STATE_RUNNING, RUN_STATE_SAVE_VM },\n    { RUN_STATE_RUNNING, RUN_STATE_SHUTDOWN },\n    { RUN_STATE_RUNNING, RUN_STATE_WATCHDOG },\n    { RUN_STATE_RUNNING, RUN_STATE_GUEST_PANICKED },\n    { RUN_STATE_RUNNING, RUN_STATE_COLO},\n\n    { RUN_STATE_SAVE_VM, RUN_STATE_RUNNING },\n\n    { RUN_STATE_SHUTDOWN, RUN_STATE_PAUSED },\n    { RUN_STATE_SHUTDOWN, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_SHUTDOWN, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE_DEBUG, RUN_STATE_SUSPENDED },\n    { RUN_STATE_RUNNING, RUN_STATE_SUSPENDED },\n    { RUN_STATE_SUSPENDED, RUN_STATE_RUNNING },\n    { RUN_STATE_SUSPENDED, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_SUSPENDED, RUN_STATE_PRELAUNCH },\n    { RUN_STATE_SUSPENDED, RUN_STATE_COLO},\n\n    { RUN_STATE_WATCHDOG, RUN_STATE_RUNNING },\n    { RUN_STATE_WATCHDOG, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_WATCHDOG, RUN_STATE_PRELAUNCH },\n    { RUN_STATE_WATCHDOG, RUN_STATE_COLO},\n\n    { RUN_STATE_GUEST_PANICKED, RUN_STATE_RUNNING },\n    { RUN_STATE_GUEST_PANICKED, RUN_STATE_FINISH_MIGRATE },\n    { RUN_STATE_GUEST_PANICKED, RUN_STATE_PRELAUNCH },\n\n    { RUN_STATE__MAX, RUN_STATE__MAX },\n};\n\nstatic bool runstate_valid_transitions[RUN_STATE__MAX][RUN_STATE__MAX];\n\nbool runstate_check(RunState state)\n{\n    return current_run_state == state;\n}\n\nbool runstate_store(char *str, size_t size)\n{\n    const char *state = RunState_lookup[current_run_state];\n    size_t len = strlen(state) + 1;\n\n    if (len > size) {\n        return false;\n    }\n    memcpy(str, state, len);\n    return true;\n}\n\nstatic void runstate_init(void)\n{\n    const RunStateTransition *p;\n\n    memset(&runstate_valid_transitions, 0, sizeof(runstate_valid_transitions));\n    for (p = &runstate_transitions_def[0]; p->from != RUN_STATE__MAX; p++) {\n        runstate_valid_transitions[p->from][p->to] = true;\n    }\n\n    qemu_mutex_init(&vmstop_lock);\n}\n\n/* This function will abort() on invalid state transitions */\nvoid runstate_set(RunState new_state)\n{\n    assert(new_state < RUN_STATE__MAX);\n\n    if (current_run_state == new_state) {\n        return;\n    }\n\n    if (!runstate_valid_transitions[current_run_state][new_state]) {\n        error_report(\"invalid runstate transition: '%s' -> '%s'\",\n                     RunState_lookup[current_run_state],\n                     RunState_lookup[new_state]);\n        abort();\n    }\n    trace_runstate_set(new_state);\n    current_run_state = new_state;\n}\n\nint runstate_is_running(void)\n{\n    return runstate_check(RUN_STATE_RUNNING);\n}\n\nbool runstate_needs_reset(void)\n{\n    return runstate_check(RUN_STATE_INTERNAL_ERROR) ||\n        runstate_check(RUN_STATE_SHUTDOWN);\n}\n\nStatusInfo *qmp_query_status(Error **errp)\n{\n    StatusInfo *info = g_malloc0(sizeof(*info));\n\n    info->running = runstate_is_running();\n    info->singlestep = singlestep;\n    info->status = current_run_state;\n\n    return info;\n}\n\nbool qemu_vmstop_requested(RunState *r)\n{\n    qemu_mutex_lock(&vmstop_lock);\n    *r = vmstop_requested;\n    vmstop_requested = RUN_STATE__MAX;\n    qemu_mutex_unlock(&vmstop_lock);\n    return *r < RUN_STATE__MAX;\n}\n\nvoid qemu_system_vmstop_request_prepare(void)\n{\n    qemu_mutex_lock(&vmstop_lock);\n}\n\nvoid qemu_system_vmstop_request(RunState state)\n{\n    vmstop_requested = state;\n    qemu_mutex_unlock(&vmstop_lock);\n    qemu_notify_event();\n}\n\n/***********************************************************/\n/* real time host monotonic timer */\n\nstatic time_t qemu_time(void)\n{\n    return qemu_clock_get_ms(QEMU_CLOCK_HOST) / 1000;\n}\n\n/***********************************************************/\n/* host time/date access */\nvoid qemu_get_timedate(struct tm *tm, int offset)\n{\n    time_t ti = qemu_time();\n\n    ti += offset;\n    if (rtc_date_offset == -1) {\n        if (rtc_utc)\n            gmtime_r(&ti, tm);\n        else\n            localtime_r(&ti, tm);\n    } else {\n        ti -= rtc_date_offset;\n        gmtime_r(&ti, tm);\n    }\n}\n\nint qemu_timedate_diff(struct tm *tm)\n{\n    time_t seconds;\n\n    if (rtc_date_offset == -1)\n        if (rtc_utc)\n            seconds = mktimegm(tm);\n        else {\n            struct tm tmp = *tm;\n            tmp.tm_isdst = -1; /* use timezone to figure it out */\n            seconds = mktime(&tmp);\n\t}\n    else\n        seconds = mktimegm(tm) + rtc_date_offset;\n\n    return seconds - qemu_time();\n}\n\nstatic void configure_rtc_date_offset(const char *startdate, int legacy)\n{\n    time_t rtc_start_date;\n    struct tm tm;\n\n    if (!strcmp(startdate, \"now\") && legacy) {\n        rtc_date_offset = -1;\n    } else {\n        if (sscanf(startdate, \"%d-%d-%dT%d:%d:%d\",\n                   &tm.tm_year,\n                   &tm.tm_mon,\n                   &tm.tm_mday,\n                   &tm.tm_hour,\n                   &tm.tm_min,\n                   &tm.tm_sec) == 6) {\n            /* OK */\n        } else if (sscanf(startdate, \"%d-%d-%d\",\n                          &tm.tm_year,\n                          &tm.tm_mon,\n                          &tm.tm_mday) == 3) {\n            tm.tm_hour = 0;\n            tm.tm_min = 0;\n            tm.tm_sec = 0;\n        } else {\n            goto date_fail;\n        }\n        tm.tm_year -= 1900;\n        tm.tm_mon--;\n        rtc_start_date = mktimegm(&tm);\n        if (rtc_start_date == -1) {\n        date_fail:\n            error_report(\"invalid date format\");\n            error_printf(\"valid formats: \"\n                         \"'2006-06-17T16:01:21' or '2006-06-17'\\n\");\n            exit(1);\n        }\n        rtc_date_offset = qemu_time() - rtc_start_date;\n    }\n}\n\nstatic void configure_rtc(QemuOpts *opts)\n{\n    const char *value;\n\n    value = qemu_opt_get(opts, \"base\");\n    if (value) {\n        if (!strcmp(value, \"utc\")) {\n            rtc_utc = 1;\n        } else if (!strcmp(value, \"localtime\")) {\n            Error *blocker = NULL;\n            rtc_utc = 0;\n            error_setg(&blocker, QERR_REPLAY_NOT_SUPPORTED,\n                      \"-rtc base=localtime\");\n            replay_add_blocker(blocker);\n        } else {\n            configure_rtc_date_offset(value, 0);\n        }\n    }\n    value = qemu_opt_get(opts, \"clock\");\n    if (value) {\n        if (!strcmp(value, \"host\")) {\n            rtc_clock = QEMU_CLOCK_HOST;\n        } else if (!strcmp(value, \"rt\")) {\n            rtc_clock = QEMU_CLOCK_REALTIME;\n        } else if (!strcmp(value, \"vm\")) {\n            rtc_clock = QEMU_CLOCK_VIRTUAL;\n        } else {\n            error_report(\"invalid option value '%s'\", value);\n            exit(1);\n        }\n    }\n    value = qemu_opt_get(opts, \"driftfix\");\n    if (value) {\n        if (!strcmp(value, \"slew\")) {\n            static GlobalProperty slew_lost_ticks = {\n                .driver   = \"mc146818rtc\",\n                .property = \"lost_tick_policy\",\n                .value    = \"slew\",\n            };\n\n            qdev_prop_register_global(&slew_lost_ticks);\n        } else if (!strcmp(value, \"none\")) {\n            /* discard is default */\n        } else {\n            error_report(\"invalid option value '%s'\", value);\n            exit(1);\n        }\n    }\n}\n\n/***********************************************************/\n/* Bluetooth support */\nstatic int nb_hcis;\nstatic int cur_hci;\nstatic struct HCIInfo *hci_table[MAX_NICS];\n\nstruct HCIInfo *qemu_next_hci(void)\n{\n    if (cur_hci == nb_hcis)\n        return &null_hci;\n\n    return hci_table[cur_hci++];\n}\n\nstatic int bt_hci_parse(const char *str)\n{\n    struct HCIInfo *hci;\n    bdaddr_t bdaddr;\n\n    if (nb_hcis >= MAX_NICS) {\n        error_report(\"too many bluetooth HCIs (max %i)\", MAX_NICS);\n        return -1;\n    }\n\n    hci = hci_init(str);\n    if (!hci)\n        return -1;\n\n    bdaddr.b[0] = 0x52;\n    bdaddr.b[1] = 0x54;\n    bdaddr.b[2] = 0x00;\n    bdaddr.b[3] = 0x12;\n    bdaddr.b[4] = 0x34;\n    bdaddr.b[5] = 0x56 + nb_hcis;\n    hci->bdaddr_set(hci, bdaddr.b);\n\n    hci_table[nb_hcis++] = hci;\n\n    return 0;\n}\n\nstatic void bt_vhci_add(int vlan_id)\n{\n    struct bt_scatternet_s *vlan = qemu_find_bt_vlan(vlan_id);\n\n    if (!vlan->slave)\n        error_report(\"warning: adding a VHCI to an empty scatternet %i\",\n                     vlan_id);\n\n    bt_vhci_init(bt_new_hci(vlan));\n}\n\nstatic struct bt_device_s *bt_device_add(const char *opt)\n{\n    struct bt_scatternet_s *vlan;\n    int vlan_id = 0;\n    char *endp = strstr(opt, \",vlan=\");\n    int len = (endp ? endp - opt : strlen(opt)) + 1;\n    char devname[10];\n\n    pstrcpy(devname, MIN(sizeof(devname), len), opt);\n\n    if (endp) {\n        vlan_id = strtol(endp + 6, &endp, 0);\n        if (*endp) {\n            error_report(\"unrecognised bluetooth vlan Id\");\n            return 0;\n        }\n    }\n\n    vlan = qemu_find_bt_vlan(vlan_id);\n\n    if (!vlan->slave)\n        error_report(\"warning: adding a slave device to an empty scatternet %i\",\n                     vlan_id);\n\n    if (!strcmp(devname, \"keyboard\"))\n        return bt_keyboard_init(vlan);\n\n    error_report(\"unsupported bluetooth device '%s'\", devname);\n    return 0;\n}\n\nstatic int bt_parse(const char *opt)\n{\n    const char *endp, *p;\n    int vlan;\n\n    if (strstart(opt, \"hci\", &endp)) {\n        if (!*endp || *endp == ',') {\n            if (*endp)\n                if (!strstart(endp, \",vlan=\", 0))\n                    opt = endp + 1;\n\n            return bt_hci_parse(opt);\n       }\n    } else if (strstart(opt, \"vhci\", &endp)) {\n        if (!*endp || *endp == ',') {\n            if (*endp) {\n                if (strstart(endp, \",vlan=\", &p)) {\n                    vlan = strtol(p, (char **) &endp, 0);\n                    if (*endp) {\n                        error_report(\"bad scatternet '%s'\", p);\n                        return 1;\n                    }\n                } else {\n                    error_report(\"bad parameter '%s'\", endp + 1);\n                    return 1;\n                }\n            } else\n                vlan = 0;\n\n            bt_vhci_add(vlan);\n            return 0;\n        }\n    } else if (strstart(opt, \"device:\", &endp))\n        return !bt_device_add(endp);\n\n    error_report(\"bad bluetooth parameter '%s'\", opt);\n    return 1;\n}\n\nstatic int parse_sandbox(void *opaque, QemuOpts *opts, Error **errp)\n{\n    /* FIXME: change this to true for 1.3 */\n    if (qemu_opt_get_bool(opts, \"enable\", false)) {\n#ifdef CONFIG_SECCOMP\n        if (seccomp_start() < 0) {\n            error_report(\"failed to install seccomp syscall filter \"\n                         \"in the kernel\");\n            return -1;\n        }\n#else\n        error_report(\"seccomp support is disabled\");\n        return -1;\n#endif\n    }\n\n    return 0;\n}\n\nstatic int parse_name(void *opaque, QemuOpts *opts, Error **errp)\n{\n    const char *proc_name;\n\n    if (qemu_opt_get(opts, \"debug-threads\")) {\n        qemu_thread_naming(qemu_opt_get_bool(opts, \"debug-threads\", false));\n    }\n    qemu_name = qemu_opt_get(opts, \"guest\");\n\n    proc_name = qemu_opt_get(opts, \"process\");\n    if (proc_name) {\n        os_set_proc_name(proc_name);\n    }\n\n    return 0;\n}\n\nbool defaults_enabled(void)\n{\n    return has_defaults;\n}\n\n#ifndef _WIN32\nstatic int parse_add_fd(void *opaque, QemuOpts *opts, Error **errp)\n{\n    int fd, dupfd, flags;\n    int64_t fdset_id;\n    const char *fd_opaque = NULL;\n    AddfdInfo *fdinfo;\n\n    fd = qemu_opt_get_number(opts, \"fd\", -1);\n    fdset_id = qemu_opt_get_number(opts, \"set\", -1);\n    fd_opaque = qemu_opt_get(opts, \"opaque\");\n\n    if (fd < 0) {\n        error_report(\"fd option is required and must be non-negative\");\n        return -1;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        error_report(\"fd cannot be a standard I/O stream\");\n        return -1;\n    }\n\n    /*\n     * All fds inherited across exec() necessarily have FD_CLOEXEC\n     * clear, while qemu sets FD_CLOEXEC on all other fds used internally.\n     */\n    flags = fcntl(fd, F_GETFD);\n    if (flags == -1 || (flags & FD_CLOEXEC)) {\n        error_report(\"fd is not valid or already in use\");\n        return -1;\n    }\n\n    if (fdset_id < 0) {\n        error_report(\"set option is required and must be non-negative\");\n        return -1;\n    }\n\n#ifdef F_DUPFD_CLOEXEC\n    dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n#else\n    dupfd = dup(fd);\n    if (dupfd != -1) {\n        qemu_set_cloexec(dupfd);\n    }\n#endif\n    if (dupfd == -1) {\n        error_report(\"error duplicating fd: %s\", strerror(errno));\n        return -1;\n    }\n\n    /* add the duplicate fd, and optionally the opaque string, to the fd set */\n    fdinfo = monitor_fdset_add_fd(dupfd, true, fdset_id, !!fd_opaque, fd_opaque,\n                                  &error_abort);\n    g_free(fdinfo);\n\n    return 0;\n}\n\nstatic int cleanup_add_fd(void *opaque, QemuOpts *opts, Error **errp)\n{\n    int fd;\n\n    fd = qemu_opt_get_number(opts, \"fd\", -1);\n    close(fd);\n\n    return 0;\n}\n#endif\n\n/***********************************************************/\n/* QEMU Block devices */\n\n#define HD_OPTS \"media=disk\"\n#define CDROM_OPTS \"media=cdrom\"\n#define FD_OPTS \"\"\n#define PFLASH_OPTS \"\"\n#define MTD_OPTS \"\"\n#define SD_OPTS \"\"\n\nstatic int drive_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    BlockInterfaceType *block_default_type = opaque;\n\n    return drive_new(opts, *block_default_type) == NULL;\n}\n\nstatic int drive_enable_snapshot(void *opaque, QemuOpts *opts, Error **errp)\n{\n    if (qemu_opt_get(opts, \"snapshot\") == NULL) {\n        qemu_opt_set(opts, \"snapshot\", \"on\", &error_abort);\n    }\n    return 0;\n}\n\nstatic void default_drive(int enable, int snapshot, BlockInterfaceType type,\n                          int index, const char *optstr)\n{\n    QemuOpts *opts;\n    DriveInfo *dinfo;\n\n    if (!enable || drive_get_by_index(type, index)) {\n        return;\n    }\n\n    opts = drive_add(type, index, NULL, optstr);\n    if (snapshot) {\n        drive_enable_snapshot(NULL, opts, NULL);\n    }\n\n    dinfo = drive_new(opts, type);\n    if (!dinfo) {\n        exit(1);\n    }\n    dinfo->is_default = true;\n\n}\n\nstatic QemuOptsList qemu_smp_opts = {\n    .name = \"smp-opts\",\n    .implied_opt_name = \"cpus\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_smp_opts.head),\n    .desc = {\n        {\n            .name = \"cpus\",\n            .type = QEMU_OPT_NUMBER,\n        }, {\n            .name = \"sockets\",\n            .type = QEMU_OPT_NUMBER,\n        }, {\n            .name = \"cores\",\n            .type = QEMU_OPT_NUMBER,\n        }, {\n            .name = \"threads\",\n            .type = QEMU_OPT_NUMBER,\n        }, {\n            .name = \"maxcpus\",\n            .type = QEMU_OPT_NUMBER,\n        },\n        { /*End of list */ }\n    },\n};\n\nstatic void smp_parse(QemuOpts *opts)\n{\n    if (opts) {\n        unsigned cpus    = qemu_opt_get_number(opts, \"cpus\", 0);\n        unsigned sockets = qemu_opt_get_number(opts, \"sockets\", 0);\n        unsigned cores   = qemu_opt_get_number(opts, \"cores\", 0);\n        unsigned threads = qemu_opt_get_number(opts, \"threads\", 0);\n\n        /* compute missing values, prefer sockets over cores over threads */\n        if (cpus == 0 || sockets == 0) {\n            sockets = sockets > 0 ? sockets : 1;\n            cores = cores > 0 ? cores : 1;\n            threads = threads > 0 ? threads : 1;\n            if (cpus == 0) {\n                cpus = cores * threads * sockets;\n            }\n        } else if (cores == 0) {\n            threads = threads > 0 ? threads : 1;\n            cores = cpus / (sockets * threads);\n            cores = cores > 0 ? cores : 1;\n        } else if (threads == 0) {\n            threads = cpus / (cores * sockets);\n            threads = threads > 0 ? threads : 1;\n        } else if (sockets * cores * threads < cpus) {\n            error_report(\"cpu topology: \"\n                         \"sockets (%u) * cores (%u) * threads (%u) < \"\n                         \"smp_cpus (%u)\",\n                         sockets, cores, threads, cpus);\n            exit(1);\n        }\n\n        max_cpus = qemu_opt_get_number(opts, \"maxcpus\", cpus);\n\n        if (max_cpus < cpus) {\n            error_report(\"maxcpus must be equal to or greater than smp\");\n            exit(1);\n        }\n\n        if (sockets * cores * threads > max_cpus) {\n            error_report(\"cpu topology: \"\n                         \"sockets (%u) * cores (%u) * threads (%u) > \"\n                         \"maxcpus (%u)\",\n                         sockets, cores, threads, max_cpus);\n            exit(1);\n        }\n\n        smp_cpus = cpus;\n        smp_cores = cores;\n        smp_threads = threads;\n    }\n\n    if (smp_cpus > 1) {\n        Error *blocker = NULL;\n        error_setg(&blocker, QERR_REPLAY_NOT_SUPPORTED, \"smp\");\n        replay_add_blocker(blocker);\n    }\n}\n\nstatic void realtime_init(void)\n{\n    if (enable_mlock) {\n        if (os_mlock() < 0) {\n            error_report(\"locking memory failed\");\n            exit(1);\n        }\n    }\n}\n\n\nstatic void configure_msg(QemuOpts *opts)\n{\n    enable_timestamp_msg = qemu_opt_get_bool(opts, \"timestamp\", true);\n}\n\n/***********************************************************/\n/* Semihosting */\n\ntypedef struct SemihostingConfig {\n    bool enabled;\n    SemihostingTarget target;\n    const char **argv;\n    int argc;\n    const char *cmdline; /* concatenated argv */\n} SemihostingConfig;\n\nstatic SemihostingConfig semihosting;\n\nbool semihosting_enabled(void)\n{\n    return semihosting.enabled;\n}\n\nSemihostingTarget semihosting_get_target(void)\n{\n    return semihosting.target;\n}\n\nconst char *semihosting_get_arg(int i)\n{\n    if (i >= semihosting.argc) {\n        return NULL;\n    }\n    return semihosting.argv[i];\n}\n\nint semihosting_get_argc(void)\n{\n    return semihosting.argc;\n}\n\nconst char *semihosting_get_cmdline(void)\n{\n    if (semihosting.cmdline == NULL && semihosting.argc > 0) {\n        semihosting.cmdline = g_strjoinv(\" \", (gchar **)semihosting.argv);\n    }\n    return semihosting.cmdline;\n}\n\nstatic int add_semihosting_arg(void *opaque,\n                               const char *name, const char *val,\n                               Error **errp)\n{\n    SemihostingConfig *s = opaque;\n    if (strcmp(name, \"arg\") == 0) {\n        s->argc++;\n        /* one extra element as g_strjoinv() expects NULL-terminated array */\n        s->argv = g_realloc(s->argv, (s->argc + 1) * sizeof(void *));\n        s->argv[s->argc - 1] = val;\n        s->argv[s->argc] = NULL;\n    }\n    return 0;\n}\n\n/* Use strings passed via -kernel/-append to initialize semihosting.argv[] */\nstatic inline void semihosting_arg_fallback(const char *file, const char *cmd)\n{\n    char *cmd_token;\n\n    /* argv[0] */\n    add_semihosting_arg(&semihosting, \"arg\", file, NULL);\n\n    /* split -append and initialize argv[1..n] */\n    cmd_token = strtok(g_strdup(cmd), \" \");\n    while (cmd_token) {\n        add_semihosting_arg(&semihosting, \"arg\", cmd_token, NULL);\n        cmd_token = strtok(NULL, \" \");\n    }\n}\n\n/* Now we still need this for compatibility with XEN. */\nbool has_igd_gfx_passthru;\nstatic void igd_gfx_passthru(void)\n{\n    has_igd_gfx_passthru = current_machine->igd_gfx_passthru;\n}\n\n/***********************************************************/\n/* USB devices */\n\nstatic int usb_device_add(const char *devname)\n{\n    USBDevice *dev = NULL;\n#ifndef CONFIG_LINUX\n    const char *p;\n#endif\n\n    if (!machine_usb(current_machine)) {\n        return -1;\n    }\n\n    /* drivers with .usbdevice_name entry in USBDeviceInfo */\n    dev = usbdevice_create(devname);\n    if (dev)\n        goto done;\n\n    /* the other ones */\n#ifndef CONFIG_LINUX\n    /* only the linux version is qdev-ified, usb-bsd still needs this */\n    if (strstart(devname, \"host:\", &p)) {\n        dev = usb_host_device_open(usb_bus_find(-1), p);\n    }\n#endif\n    if (!dev)\n        return -1;\n\ndone:\n    return 0;\n}\n\nstatic int usb_device_del(const char *devname)\n{\n    int bus_num, addr;\n    const char *p;\n\n    if (strstart(devname, \"host:\", &p)) {\n        return -1;\n    }\n\n    if (!machine_usb(current_machine)) {\n        return -1;\n    }\n\n    p = strchr(devname, '.');\n    if (!p)\n        return -1;\n    bus_num = strtoul(devname, NULL, 0);\n    addr = strtoul(p + 1, NULL, 0);\n\n    return usb_device_delete_addr(bus_num, addr);\n}\n\nstatic int usb_parse(const char *cmdline)\n{\n    int r;\n    r = usb_device_add(cmdline);\n    if (r < 0) {\n        error_report(\"could not add USB device '%s'\", cmdline);\n    }\n    return r;\n}\n\nvoid hmp_usb_add(Monitor *mon, const QDict *qdict)\n{\n    const char *devname = qdict_get_str(qdict, \"devname\");\n    if (usb_device_add(devname) < 0) {\n        error_report(\"could not add USB device '%s'\", devname);\n    }\n}\n\nvoid hmp_usb_del(Monitor *mon, const QDict *qdict)\n{\n    const char *devname = qdict_get_str(qdict, \"devname\");\n    if (usb_device_del(devname) < 0) {\n        error_report(\"could not delete USB device '%s'\", devname);\n    }\n}\n\n/***********************************************************/\n/* machine registration */\n\nMachineState *current_machine;\n\nstatic MachineClass *find_machine(const char *name)\n{\n    GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);\n    MachineClass *mc = NULL;\n\n    for (el = machines; el; el = el->next) {\n        MachineClass *temp = el->data;\n\n        if (!strcmp(temp->name, name)) {\n            mc = temp;\n            break;\n        }\n        if (temp->alias &&\n            !strcmp(temp->alias, name)) {\n            mc = temp;\n            break;\n        }\n    }\n\n    g_slist_free(machines);\n    return mc;\n}\n\nMachineClass *find_default_machine(void)\n{\n    GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);\n    MachineClass *mc = NULL;\n\n    for (el = machines; el; el = el->next) {\n        MachineClass *temp = el->data;\n\n        if (temp->is_default) {\n            mc = temp;\n            break;\n        }\n    }\n\n    g_slist_free(machines);\n    return mc;\n}\n\nMachineInfoList *qmp_query_machines(Error **errp)\n{\n    GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);\n    MachineInfoList *mach_list = NULL;\n\n    for (el = machines; el; el = el->next) {\n        MachineClass *mc = el->data;\n        MachineInfoList *entry;\n        MachineInfo *info;\n\n        info = g_malloc0(sizeof(*info));\n        if (mc->is_default) {\n            info->has_is_default = true;\n            info->is_default = true;\n        }\n\n        if (mc->alias) {\n            info->has_alias = true;\n            info->alias = g_strdup(mc->alias);\n        }\n\n        info->name = g_strdup(mc->name);\n        info->cpu_max = !mc->max_cpus ? 1 : mc->max_cpus;\n        info->hotpluggable_cpus = mc->has_hotpluggable_cpus;\n\n        entry = g_malloc0(sizeof(*entry));\n        entry->value = info;\n        entry->next = mach_list;\n        mach_list = entry;\n    }\n\n    g_slist_free(machines);\n    return mach_list;\n}\n\nstatic int machine_help_func(QemuOpts *opts, MachineState *machine)\n{\n    ObjectProperty *prop;\n    ObjectPropertyIterator iter;\n\n    if (!qemu_opt_has_help_opt(opts)) {\n        return 0;\n    }\n\n    object_property_iter_init(&iter, OBJECT(machine));\n    while ((prop = object_property_iter_next(&iter))) {\n        if (!prop->set) {\n            continue;\n        }\n\n        error_printf(\"%s.%s=%s\", MACHINE_GET_CLASS(machine)->name,\n                     prop->name, prop->type);\n        if (prop->description) {\n            error_printf(\" (%s)\\n\", prop->description);\n        } else {\n            error_printf(\"\\n\");\n        }\n    }\n\n    return 1;\n}\n\n/***********************************************************/\n/* main execution loop */\n\nstruct vm_change_state_entry {\n    VMChangeStateHandler *cb;\n    void *opaque;\n    QLIST_ENTRY (vm_change_state_entry) entries;\n};\n\nstatic QLIST_HEAD(vm_change_state_head, vm_change_state_entry) vm_change_state_head;\n\nVMChangeStateEntry *qemu_add_vm_change_state_handler(VMChangeStateHandler *cb,\n                                                     void *opaque)\n{\n    VMChangeStateEntry *e;\n\n    e = g_malloc0(sizeof (*e));\n\n    e->cb = cb;\n    e->opaque = opaque;\n    QLIST_INSERT_HEAD(&vm_change_state_head, e, entries);\n    return e;\n}\n\nvoid qemu_del_vm_change_state_handler(VMChangeStateEntry *e)\n{\n    QLIST_REMOVE (e, entries);\n    g_free (e);\n}\n\nvoid vm_state_notify(int running, RunState state)\n{\n    VMChangeStateEntry *e, *next;\n\n    trace_vm_state_notify(running, state);\n\n    QLIST_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {\n        e->cb(e->opaque, running, state);\n    }\n}\n\nstatic int reset_requested;\nstatic int shutdown_requested, shutdown_signal = -1;\nstatic int panda_exit_code;\nstatic pid_t shutdown_pid;\nstatic int powerdown_requested;\nstatic int debug_requested;\nstatic int suspend_requested;\nstatic WakeupReason wakeup_reason;\nstatic NotifierList powerdown_notifiers =\n    NOTIFIER_LIST_INITIALIZER(powerdown_notifiers);\nstatic NotifierList suspend_notifiers =\n    NOTIFIER_LIST_INITIALIZER(suspend_notifiers);\nstatic NotifierList wakeup_notifiers =\n    NOTIFIER_LIST_INITIALIZER(wakeup_notifiers);\nstatic uint32_t wakeup_reason_mask = ~(1 << QEMU_WAKEUP_REASON_NONE);\n\nint qemu_shutdown_requested_get(void)\n{\n    return shutdown_requested;\n}\n\nint qemu_reset_requested_get(void)\n{\n    return reset_requested;\n}\n\nstatic int qemu_shutdown_requested(void)\n{\n    return atomic_xchg(&shutdown_requested, 0);\n}\n\nstatic void qemu_kill_report(void)\n{\n    if (!qtest_driver() && shutdown_signal != -1) {\n        panda_exit_code = 128 + shutdown_signal;\n        if (shutdown_pid == 0) {\n            /* This happens for eg ^C at the terminal, so it's worth\n             * avoiding printing an odd message in that case.\n             */\n            error_report(\"terminating on signal %d\", shutdown_signal);\n            panda_aborted = true;\n        } else {\n            char *shutdown_cmd = qemu_get_pid_name(shutdown_pid);\n\n            error_report(\"terminating on signal %d from pid \" FMT_pid \" (%s)\",\n                         shutdown_signal, shutdown_pid,\n                         shutdown_cmd ? shutdown_cmd : \"<unknown process>\");\n            g_free(shutdown_cmd);\n        }\n        shutdown_signal = -1;\n    }\n}\n\nstatic int qemu_reset_requested(void)\n{\n    int r = reset_requested;\n    if (r && replay_checkpoint(CHECKPOINT_RESET_REQUESTED)) {\n        reset_requested = 0;\n        return r;\n    }\n    return false;\n}\n\nstatic int qemu_suspend_requested(void)\n{\n    int r = suspend_requested;\n    if (r && replay_checkpoint(CHECKPOINT_SUSPEND_REQUESTED)) {\n        suspend_requested = 0;\n        return r;\n    }\n    return false;\n}\n\nstatic WakeupReason qemu_wakeup_requested(void)\n{\n    return wakeup_reason;\n}\n\nstatic int qemu_powerdown_requested(void)\n{\n    int r = powerdown_requested;\n    powerdown_requested = 0;\n    return r;\n}\n\nstatic int qemu_debug_requested(void)\n{\n    int r = debug_requested;\n    debug_requested = 0;\n    return r;\n}\n\nvoid qemu_system_reset(bool report)\n{\n    MachineClass *mc;\n\n    mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;\n\n    cpu_synchronize_all_states();\n\n    if (mc && mc->reset) {\n        mc->reset();\n    } else {\n        qemu_devices_reset();\n    }\n    if (report) {\n        qapi_event_send_reset(&error_abort);\n    }\n    cpu_synchronize_all_post_reset();\n}\n\nvoid qemu_system_guest_panicked(GuestPanicInformation *info)\n{\n    qemu_log_mask(LOG_GUEST_ERROR, \"Guest crashed\\n\");\n\n    if (current_cpu) {\n        current_cpu->crash_occurred = true;\n    }\n    qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_PAUSE,\n                                   !!info, info, &error_abort);\n    vm_stop(RUN_STATE_GUEST_PANICKED);\n    if (!no_shutdown) {\n        qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_POWEROFF,\n                                       !!info, info, &error_abort);\n        qemu_system_shutdown_request();\n    }\n\n    if (info) {\n        if (info->type == GUEST_PANIC_INFORMATION_TYPE_HYPER_V) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"HV crash parameters: (%#\"PRIx64\n                          \" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\")\\n\",\n                          info->u.hyper_v.arg1,\n                          info->u.hyper_v.arg2,\n                          info->u.hyper_v.arg3,\n                          info->u.hyper_v.arg4,\n                          info->u.hyper_v.arg5);\n        }\n        qapi_free_GuestPanicInformation(info);\n    }\n}\n\nvoid qemu_system_reset_request(void)\n{\n    if (no_reboot) {\n        shutdown_requested = 1;\n    } else {\n        reset_requested = 1;\n    }\n    cpu_stop_current();\n    qemu_notify_event();\n}\n\nstatic void qemu_system_suspend(void)\n{\n    pause_all_vcpus();\n    notifier_list_notify(&suspend_notifiers, NULL);\n    runstate_set(RUN_STATE_SUSPENDED);\n    qapi_event_send_suspend(&error_abort);\n}\n\nvoid qemu_system_suspend_request(void)\n{\n    if (runstate_check(RUN_STATE_SUSPENDED)) {\n        return;\n    }\n    suspend_requested = 1;\n    cpu_stop_current();\n    qemu_notify_event();\n}\n\nvoid qemu_register_suspend_notifier(Notifier *notifier)\n{\n    notifier_list_add(&suspend_notifiers, notifier);\n}\n\nvoid qemu_system_wakeup_request(WakeupReason reason)\n{\n    trace_system_wakeup_request(reason);\n\n    if (!runstate_check(RUN_STATE_SUSPENDED)) {\n        return;\n    }\n    if (!(wakeup_reason_mask & (1 << reason))) {\n        return;\n    }\n    runstate_set(RUN_STATE_RUNNING);\n    wakeup_reason = reason;\n    qemu_notify_event();\n}\n\nvoid qemu_system_wakeup_enable(WakeupReason reason, bool enabled)\n{\n    if (enabled) {\n        wakeup_reason_mask |= (1 << reason);\n    } else {\n        wakeup_reason_mask &= ~(1 << reason);\n    }\n}\n\nvoid qemu_register_wakeup_notifier(Notifier *notifier)\n{\n    notifier_list_add(&wakeup_notifiers, notifier);\n}\n\nvoid qemu_system_killed(int signal, pid_t pid)\n{\n    shutdown_signal = signal;\n    shutdown_pid = pid;\n    no_shutdown = 0;\n\n    /* Cannot call qemu_system_shutdown_request directly because\n     * we are in a signal handler.\n     */\n    shutdown_requested = 1;\n    qemu_notify_event();\n}\n\nvoid qemu_system_shutdown_request(void)\n{\n    trace_qemu_system_shutdown_request();\n    replay_shutdown_request();\n    shutdown_requested = 1;\n    qemu_notify_event();\n}\n\nstatic void qemu_system_powerdown(void)\n{\n    qapi_event_send_powerdown(&error_abort);\n    notifier_list_notify(&powerdown_notifiers, NULL);\n}\n\nvoid qemu_system_powerdown_request(void)\n{\n    trace_qemu_system_powerdown_request();\n    powerdown_requested = 1;\n    qemu_notify_event();\n}\n\nvoid qemu_register_powerdown_notifier(Notifier *notifier)\n{\n    notifier_list_add(&powerdown_notifiers, notifier);\n}\n\nvoid qemu_system_debug_request(void)\n{\n    debug_requested = 1;\n    qemu_notify_event();\n}\n\nstatic bool main_loop_should_exit(void)\n{\n    RunState r;\n    if (qemu_debug_requested()) {\n        vm_stop(RUN_STATE_DEBUG);\n    }\n    if (qemu_suspend_requested()) {\n        qemu_system_suspend();\n    }\n    if (panda_break_vl_loop_req) {\n      panda_break_vl_loop_req = false; // Only break the loop once\n      return true;\n    }\n    if (qemu_shutdown_requested()) {\n        panda_callbacks_pre_shutdown();\n        qemu_kill_report();\n        qapi_event_send_shutdown(&error_abort);\n        if (no_shutdown) {\n            vm_stop(RUN_STATE_SHUTDOWN);\n        } else {\n            return true;\n        }\n    }\n    if (qemu_reset_requested()) {\n        pause_all_vcpus();\n        qemu_system_reset(VMRESET_REPORT);\n        resume_all_vcpus();\n        if (!runstate_check(RUN_STATE_RUNNING) &&\n                !runstate_check(RUN_STATE_INMIGRATE)) {\n            runstate_set(RUN_STATE_PRELAUNCH);\n        }\n    }\n    if (qemu_wakeup_requested()) {\n        pause_all_vcpus();\n        qemu_system_reset(VMRESET_SILENT);\n        notifier_list_notify(&wakeup_notifiers, &wakeup_reason);\n        wakeup_reason = QEMU_WAKEUP_REASON_NONE;\n        resume_all_vcpus();\n        qapi_event_send_wakeup(&error_abort);\n    }\n    if (qemu_powerdown_requested()) {\n        qemu_system_powerdown();\n    }\n    if (qemu_vmstop_requested(&r)) {\n        vm_stop(r);\n    }\n    return false;\n}\n\n#ifdef CONFIG_LLVM\nstatic void tcg_llvm_cleanup(void)\n{\n    if(tcg_llvm_translator) {\n        tcg_llvm_destroy();\n    }\n}\n#endif\n\nvoid main_loop(void)\n{\n    bool nonblocking;\n    int last_io = 0;\n#ifdef CONFIG_PROFILER\n    int64_t ti;\n#endif\n    do {\n        nonblocking = tcg_enabled() && last_io > 0;\n#ifdef CONFIG_PROFILER\n        ti = profile_getclock();\n#endif\n        last_io = main_loop_wait(nonblocking);\n        panda_callbacks_main_loop_wait();\n\n        // rr: check for begin/end record/replay\n        sigset_t blockset, oldset;\n\n        // create a signal set containing just ALARM and USR2\n        sigemptyset(&blockset);\n        sigaddset(&blockset, SIGALRM);\n        sigaddset(&blockset, SIGUSR2);\n        sigaddset(&blockset, SIGIO);\n\n\tif (likely(rr_control.next == RR_NOCHANGE)) {\n\t    // nop\n\t} else if (unlikely(rr_control.next == RR_RECORD)) {\n            //block signals\n            sigprocmask(SIG_BLOCK, &blockset, &oldset);\n            rr_do_begin_record(rr_control.name, first_cpu);\n            rr_control.next = RR_NOCHANGE;\n            //unblock signals\n            sigprocmask(SIG_SETMASK, &oldset, NULL);\n        } else if (unlikely(rr_control.next == RR_REPLAY)) {\n            //block signals\n            sigprocmask(SIG_BLOCK, &blockset, &oldset);\n            if (0 != rr_do_begin_replay(rr_control.name, first_cpu)){\n                printf(\"Failed to start replay\\n\");\n                exit(1);\n            } else { // we have to unblock signals, so we can't just continue on failure\n                qemu_rr_quit_timers();\n                rr_control.next = RR_NOCHANGE;\n            }\n            //unblock signals\n            sigprocmask(SIG_SETMASK, &oldset, NULL);\n        } else if (unlikely((rr_control.next == RR_OFF) && rr_in_record())) {\n\t    //mz 05.2012 We have the global mutex here, so this should be OK.\n            rr_do_end_record();\n            if (NULL != qemu_mon) {\n            \tmonitor_printf(qemu_mon, \"Recording ready for use.\\n\");\n            }\n            rr_reset_state(first_cpu);\n            rr_control.next = RR_NOCHANGE;\n            vm_start();\n        } else if (unlikely((rr_control.next == RR_OFF) && rr_in_replay())) {\n            //mz restore timers\n            qemu_clock_run_all_timers();\n            //mz FIXME this is used in the monitor for do_stop()??\n            rr_do_end_replay(/*is_error=*/0);\n            rr_control.next = RR_NOCHANGE;\n            vm_stop(RUN_STATE_PAUSED);\n        }\n\n#ifdef CONFIG_PROFILER\n        dev_time += profile_getclock() - ti;\n#endif\n    } while (!main_loop_should_exit());\n}\n\nstatic void version(void)\n{\n    printf(\"QEMU emulator version \" QEMU_VERSION QEMU_PKGVERSION \"\\n\"\n            \"Build date \" __DATE__ \"\\n\"\n            QEMU_COPYRIGHT \"\\n\");\n}\n\nstatic void help(int exitcode)\n{\n    version();\n    printf(\"usage: %s [options] [disk_image]\\n\\n\"\n           \"'disk_image' is a raw hard disk image for IDE hard disk 0\\n\\n\",\n            error_get_progname());\n\n#define QEMU_OPTIONS_GENERATE_HELP\n#include \"qemu-options-wrapper.h\"\n\n    printf(\"\\nDuring emulation, the following keys are useful:\\n\"\n           \"ctrl-alt-f      toggle full screen\\n\"\n           \"ctrl-alt-n      switch to virtual console 'n'\\n\"\n           \"ctrl-alt        toggle mouse and keyboard grab\\n\"\n           \"\\n\"\n           \"When using -nographic, press 'ctrl-a h' to get some help.\\n\");\n\n    exit(exitcode);\n}\n\n#define HAS_ARG 0x0001\n\ntypedef struct QEMUOption {\n    const char *name;\n    int flags;\n    int index;\n    uint32_t arch_mask;\n} QEMUOption;\n\nstatic const QEMUOption qemu_options[] = {\n    { \"h\", 0, QEMU_OPTION_h, QEMU_ARCH_ALL },\n#define QEMU_OPTIONS_GENERATE_OPTIONS\n#include \"qemu-options-wrapper.h\"\n    { NULL },\n};\n\ntypedef struct VGAInterfaceInfo {\n    const char *opt_name;    /* option name */\n    const char *name;        /* human-readable name */\n    /* Class names indicating that support is available.\n     * If no class is specified, the interface is always available */\n    const char *class_names[2];\n} VGAInterfaceInfo;\n\nstatic VGAInterfaceInfo vga_interfaces[VGA_TYPE_MAX] = {\n    [VGA_NONE] = {\n        .opt_name = \"none\",\n    },\n    [VGA_STD] = {\n        .opt_name = \"std\",\n        .name = \"standard VGA\",\n        .class_names = { \"VGA\", \"isa-vga\" },\n    },\n    [VGA_CIRRUS] = {\n        .opt_name = \"cirrus\",\n        .name = \"Cirrus VGA\",\n        .class_names = { \"cirrus-vga\", \"isa-cirrus-vga\" },\n    },\n    [VGA_VMWARE] = {\n        .opt_name = \"vmware\",\n        .name = \"VMWare SVGA\",\n        .class_names = { \"vmware-svga\" },\n    },\n    [VGA_VIRTIO] = {\n        .opt_name = \"virtio\",\n        .name = \"Virtio VGA\",\n        .class_names = { \"virtio-vga\" },\n    },\n    [VGA_QXL] = {\n        .opt_name = \"qxl\",\n        .name = \"QXL VGA\",\n        .class_names = { \"qxl-vga\" },\n    },\n    [VGA_TCX] = {\n        .opt_name = \"tcx\",\n        .name = \"TCX framebuffer\",\n        .class_names = { \"SUNW,tcx\" },\n    },\n    [VGA_CG3] = {\n        .opt_name = \"cg3\",\n        .name = \"CG3 framebuffer\",\n        .class_names = { \"cgthree\" },\n    },\n    [VGA_XENFB] = {\n        .opt_name = \"xenfb\",\n    },\n};\n\nstatic bool vga_interface_available(VGAInterfaceType t)\n{\n    VGAInterfaceInfo *ti = &vga_interfaces[t];\n\n    assert(t < VGA_TYPE_MAX);\n    return !ti->class_names[0] ||\n           object_class_by_name(ti->class_names[0]) ||\n           object_class_by_name(ti->class_names[1]);\n}\n\nstatic void select_vgahw(const char *p)\n{\n    const char *opts;\n    int t;\n\n    assert(vga_interface_type == VGA_NONE);\n    for (t = 0; t < VGA_TYPE_MAX; t++) {\n        VGAInterfaceInfo *ti = &vga_interfaces[t];\n        if (ti->opt_name && strstart(p, ti->opt_name, &opts)) {\n            if (!vga_interface_available(t)) {\n                error_report(\"%s not available\", ti->name);\n                exit(1);\n            }\n            vga_interface_type = t;\n            break;\n        }\n    }\n    if (t == VGA_TYPE_MAX) {\n    invalid_vga:\n        error_report(\"unknown vga type: %s\", p);\n        exit(1);\n    }\n    while (*opts) {\n        const char *nextopt;\n\n        if (strstart(opts, \",retrace=\", &nextopt)) {\n            opts = nextopt;\n            if (strstart(opts, \"dumb\", &nextopt))\n                vga_retrace_method = VGA_RETRACE_DUMB;\n            else if (strstart(opts, \"precise\", &nextopt))\n                vga_retrace_method = VGA_RETRACE_PRECISE;\n            else goto invalid_vga;\n        } else goto invalid_vga;\n        opts = nextopt;\n    }\n}\n\ntypedef enum DisplayType {\n    DT_DEFAULT,\n    DT_CURSES,\n    DT_SDL,\n    DT_COCOA,\n    DT_GTK,\n    DT_NONE,\n} DisplayType;\n\nstatic DisplayType select_display(const char *p)\n{\n    const char *opts;\n    DisplayType display = DT_DEFAULT;\n\n    if (strstart(p, \"sdl\", &opts)) {\n#ifdef CONFIG_SDL\n        display = DT_SDL;\n        while (*opts) {\n            const char *nextopt;\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    no_frame = 0;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    no_frame = 1;\n                } else {\n                    goto invalid_sdl_args;\n                }\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    alt_grab = 1;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    alt_grab = 0;\n                } else {\n                    goto invalid_sdl_args;\n                }\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    ctrl_grab = 1;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    ctrl_grab = 0;\n                } else {\n                    goto invalid_sdl_args;\n                }\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    no_quit = 0;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    no_quit = 1;\n                } else {\n                    goto invalid_sdl_args;\n                }\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    request_opengl = 1;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    request_opengl = 0;\n                } else {\n                    goto invalid_sdl_args;\n                }\n            } else {\n            invalid_sdl_args:\n                error_report(\"invalid SDL option string\");\n                exit(1);\n            }\n            opts = nextopt;\n        }\n#else\n        error_report(\"SDL support is disabled\");\n        exit(1);\n#endif\n    } else if (strstart(p, \"vnc\", &opts)) {\n        if (*opts == '=') {\n            vnc_parse(opts + 1, &error_fatal);\n        } else {\n            error_report(\"VNC requires a display argument vnc=<display>\");\n            exit(1);\n        }\n    } else if (strstart(p, \"curses\", &opts)) {\n#ifdef CONFIG_CURSES\n        display = DT_CURSES;\n#else\n        error_report(\"curses support is disabled\");\n        exit(1);\n#endif\n    } else if (strstart(p, \"gtk\", &opts)) {\n#ifdef CONFIG_GTK\n        display = DT_GTK;\n        while (*opts) {\n            const char *nextopt;\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    grab_on_hover = true;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    grab_on_hover = false;\n                } else {\n                    goto invalid_gtk_args;\n                }\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n                opts = nextopt;\n                if (strstart(opts, \"on\", &nextopt)) {\n                    request_opengl = 1;\n                } else if (strstart(opts, \"off\", &nextopt)) {\n                    request_opengl = 0;\n                } else {\n                    goto invalid_gtk_args;\n                }\n            } else {\n            invalid_gtk_args:\n                error_report(\"invalid GTK option string\");\n                exit(1);\n            }\n            opts = nextopt;\n        }\n#else\n        error_report(\"GTK support is disabled\");\n        exit(1);\n#endif\n    } else if (strstart(p, \"none\", &opts)) {\n        display = DT_NONE;\n    } else {\n        error_report(\"unknown display type\");\n        exit(1);\n    }\n\n    return display;\n}\n\nstatic int balloon_parse(const char *arg)\n{\n    QemuOpts *opts;\n\n    if (strcmp(arg, \"none\") == 0) {\n        return 0;\n    }\n\n    if (!strncmp(arg, \"virtio\", 6)) {\n        if (arg[6] == ',') {\n            /* have params -> parse them */\n            opts = qemu_opts_parse_noisily(qemu_find_opts(\"device\"), arg + 7,\n                                           false);\n            if (!opts)\n                return  -1;\n        } else {\n            /* create empty opts */\n            opts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                    &error_abort);\n        }\n        qemu_opt_set(opts, \"driver\", \"virtio-balloon\", &error_abort);\n        return 0;\n    }\n\n    return -1;\n}\n\nchar *qemu_find_file(int type, const char *name)\n{\n    int i;\n    const char *subdir;\n    char *buf;\n\n    /* Try the name as a straight path first */\n    if (access(name, R_OK) == 0) {\n        trace_load_file(name, name);\n        return g_strdup(name);\n    }\n\n    switch (type) {\n    case QEMU_FILE_TYPE_BIOS:\n        subdir = \"\";\n        break;\n    case QEMU_FILE_TYPE_KEYMAP:\n        subdir = \"keymaps/\";\n        break;\n    default:\n        abort();\n    }\n\n    for (i = 0; i < data_dir_idx; i++) {\n        buf = g_strdup_printf(\"%s/%s%s\", data_dir[i], subdir, name);\n        if (access(buf, R_OK) == 0) {\n            trace_load_file(name, buf);\n            return buf;\n        }\n        g_free(buf);\n    }\n    return NULL;\n}\n\nstatic inline bool nonempty_str(const char *str)\n{\n    return str && *str;\n}\n\nstatic int parse_fw_cfg(void *opaque, QemuOpts *opts, Error **errp)\n{\n    gchar *buf;\n    size_t size;\n    const char *name, *file, *str;\n    FWCfgState *fw_cfg = (FWCfgState *) opaque;\n\n    if (fw_cfg == NULL) {\n        error_report(\"fw_cfg device not available\");\n        return -1;\n    }\n    name = qemu_opt_get(opts, \"name\");\n    file = qemu_opt_get(opts, \"file\");\n    str = qemu_opt_get(opts, \"string\");\n\n    /* we need name and either a file or the content string */\n    if (!(nonempty_str(name) && (nonempty_str(file) || nonempty_str(str)))) {\n        error_report(\"invalid argument(s)\");\n        return -1;\n    }\n    if (nonempty_str(file) && nonempty_str(str)) {\n        error_report(\"file and string are mutually exclusive\");\n        return -1;\n    }\n    if (strlen(name) > FW_CFG_MAX_FILE_PATH - 1) {\n        error_report(\"name too long (max. %d char)\", FW_CFG_MAX_FILE_PATH - 1);\n        return -1;\n    }\n    if (strncmp(name, \"opt/\", 4) != 0) {\n        error_report(\"warning: externally provided fw_cfg item names \"\n                     \"should be prefixed with \\\"opt/\\\"\");\n    }\n    if (nonempty_str(str)) {\n        size = strlen(str); /* NUL terminator NOT included in fw_cfg blob */\n        buf = g_memdup(str, size);\n    } else {\n        if (!g_file_get_contents(file, &buf, &size, NULL)) {\n            error_report(\"can't load %s\", file);\n            return -1;\n        }\n    }\n    /* For legacy, keep user files in a specific global order. */\n    fw_cfg_set_order_override(fw_cfg, FW_CFG_ORDER_OVERRIDE_USER);\n    fw_cfg_add_file(fw_cfg, name, buf, size);\n    fw_cfg_reset_order_override(fw_cfg);\n    return 0;\n}\n\nstatic int device_help_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    return qdev_device_help(opts);\n}\n\nstatic int device_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    Error *err = NULL;\n    DeviceState *dev;\n\n    dev = qdev_device_add(opts, &err);\n    if (!dev) {\n        error_report_err(err);\n        return -1;\n    }\n    object_unref(OBJECT(dev));\n    return 0;\n}\n\nstatic int chardev_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    Error *local_err = NULL;\n\n    qemu_chr_new_from_opts(opts, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return -1;\n    }\n    return 0;\n}\n\n#ifdef CONFIG_VIRTFS\nstatic int fsdev_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    return qemu_fsdev_add(opts);\n}\n#endif\n\nstatic int mon_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    Chardev *chr;\n    const char *chardev;\n    const char *mode;\n    int flags;\n\n    mode = qemu_opt_get(opts, \"mode\");\n    if (mode == NULL) {\n        mode = \"readline\";\n    }\n    if (strcmp(mode, \"readline\") == 0) {\n        flags = MONITOR_USE_READLINE;\n    } else if (strcmp(mode, \"control\") == 0) {\n        flags = MONITOR_USE_CONTROL;\n    } else {\n        error_report(\"unknown monitor mode \\\"%s\\\"\", mode);\n        exit(1);\n    }\n\n    if (qemu_opt_get_bool(opts, \"pretty\", 0))\n        flags |= MONITOR_USE_PRETTY;\n\n    if (qemu_opt_get_bool(opts, \"default\", 0)) {\n        error_report(\"option 'default' does nothing and is deprecated\");\n    }\n\n    chardev = qemu_opt_get(opts, \"chardev\");\n    chr = qemu_chr_find(chardev);\n    if (chr == NULL) {\n        error_report(\"chardev \\\"%s\\\" not found\", chardev);\n        exit(1);\n    }\n\n    monitor_init(chr, flags);\n    qemu_mon = chr->be->opaque;\n    return 0;\n}\n\nstatic void monitor_parse(const char *optarg, const char *mode, bool pretty)\n{\n    static int monitor_device_index = 0;\n    QemuOpts *opts;\n    const char *p;\n    char label[32];\n\n    if (strstart(optarg, \"chardev:\", &p)) {\n        snprintf(label, sizeof(label), \"%s\", p);\n    } else {\n        snprintf(label, sizeof(label), \"compat_monitor%d\",\n                 monitor_device_index);\n        opts = qemu_chr_parse_compat(label, optarg);\n        if (!opts) {\n            error_report(\"parse error: %s\", optarg);\n            exit(1);\n        }\n    }\n\n    opts = qemu_opts_create(qemu_find_opts(\"mon\"), label, 1, &error_fatal);\n    qemu_opt_set(opts, \"mode\", mode, &error_abort);\n    qemu_opt_set(opts, \"chardev\", label, &error_abort);\n    qemu_opt_set_bool(opts, \"pretty\", pretty, &error_abort);\n    monitor_device_index++;\n}\n\nstruct device_config {\n    enum {\n        DEV_USB,       /* -usbdevice     */\n        DEV_BT,        /* -bt            */\n        DEV_SERIAL,    /* -serial        */\n        DEV_PARALLEL,  /* -parallel      */\n        DEV_VIRTCON,   /* -virtioconsole */\n        DEV_DEBUGCON,  /* -debugcon */\n        DEV_GDB,       /* -gdb, -s */\n        DEV_SCLP,      /* s390 sclp */\n    } type;\n    const char *cmdline;\n    Location loc;\n    QTAILQ_ENTRY(device_config) next;\n};\n\nstatic QTAILQ_HEAD(, device_config) device_configs =\n    QTAILQ_HEAD_INITIALIZER(device_configs);\n\nstatic void add_device_config(int type, const char *cmdline)\n{\n    struct device_config *conf;\n\n    conf = g_malloc0(sizeof(*conf));\n    conf->type = type;\n    conf->cmdline = cmdline;\n    loc_save(&conf->loc);\n    QTAILQ_INSERT_TAIL(&device_configs, conf, next);\n}\n\nstatic int foreach_device_config(int type, int (*func)(const char *cmdline))\n{\n    struct device_config *conf;\n    int rc;\n\n    QTAILQ_FOREACH(conf, &device_configs, next) {\n        if (conf->type != type)\n            continue;\n        loc_push_restore(&conf->loc);\n        rc = func(conf->cmdline);\n        loc_pop(&conf->loc);\n        if (rc) {\n            return rc;\n        }\n    }\n    return 0;\n}\n\nstatic int serial_parse(const char *devname)\n{\n    static int index = 0;\n    char label[32];\n\n    if (strcmp(devname, \"none\") == 0)\n        return 0;\n    if (index == MAX_SERIAL_PORTS) {\n        error_report(\"too many serial ports\");\n        exit(1);\n    }\n    snprintf(label, sizeof(label), \"serial%d\", index);\n    serial_hds[index] = qemu_chr_new(label, devname);\n    if (!serial_hds[index]) {\n        error_report(\"could not connect serial device\"\n                     \" to character backend '%s'\", devname);\n        return -1;\n    }\n    index++;\n    return 0;\n}\n\nstatic int parallel_parse(const char *devname)\n{\n    static int index = 0;\n    char label[32];\n\n    if (strcmp(devname, \"none\") == 0)\n        return 0;\n    if (index == MAX_PARALLEL_PORTS) {\n        error_report(\"too many parallel ports\");\n        exit(1);\n    }\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n    parallel_hds[index] = qemu_chr_new(label, devname);\n    if (!parallel_hds[index]) {\n        error_report(\"could not connect parallel device\"\n                     \" to character backend '%s'\", devname);\n        return -1;\n    }\n    index++;\n    return 0;\n}\n\nstatic int virtcon_parse(const char *devname)\n{\n    QemuOptsList *device = qemu_find_opts(\"device\");\n    static int index = 0;\n    char label[32];\n    QemuOpts *bus_opts, *dev_opts;\n\n    if (strcmp(devname, \"none\") == 0)\n        return 0;\n    if (index == MAX_VIRTIO_CONSOLES) {\n        error_report(\"too many virtio consoles\");\n        exit(1);\n    }\n\n    bus_opts = qemu_opts_create(device, NULL, 0, &error_abort);\n    qemu_opt_set(bus_opts, \"driver\", \"virtio-serial\", &error_abort);\n\n    dev_opts = qemu_opts_create(device, NULL, 0, &error_abort);\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\", &error_abort);\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n    virtcon_hds[index] = qemu_chr_new(label, devname);\n    if (!virtcon_hds[index]) {\n        error_report(\"could not connect virtio console\"\n                     \" to character backend '%s'\", devname);\n        return -1;\n    }\n    qemu_opt_set(dev_opts, \"chardev\", label, &error_abort);\n\n    index++;\n    return 0;\n}\n\nstatic int sclp_parse(const char *devname)\n{\n    QemuOptsList *device = qemu_find_opts(\"device\");\n    static int index = 0;\n    char label[32];\n    QemuOpts *dev_opts;\n\n    if (strcmp(devname, \"none\") == 0) {\n        return 0;\n    }\n    if (index == MAX_SCLP_CONSOLES) {\n        error_report(\"too many sclp consoles\");\n        exit(1);\n    }\n\n    assert(arch_type == QEMU_ARCH_S390X);\n\n    dev_opts = qemu_opts_create(device, NULL, 0, NULL);\n    qemu_opt_set(dev_opts, \"driver\", \"sclpconsole\", &error_abort);\n\n    snprintf(label, sizeof(label), \"sclpcon%d\", index);\n    sclp_hds[index] = qemu_chr_new(label, devname);\n    if (!sclp_hds[index]) {\n        error_report(\"could not connect sclp console\"\n                     \" to character backend '%s'\", devname);\n        return -1;\n    }\n    qemu_opt_set(dev_opts, \"chardev\", label, &error_abort);\n\n    index++;\n    return 0;\n}\n\nstatic int debugcon_parse(const char *devname)\n{\n    QemuOpts *opts;\n\n    if (!qemu_chr_new(\"debugcon\", devname)) {\n        exit(1);\n    }\n    opts = qemu_opts_create(qemu_find_opts(\"device\"), \"debugcon\", 1, NULL);\n    if (!opts) {\n        error_report(\"already have a debugcon device\");\n        exit(1);\n    }\n    qemu_opt_set(opts, \"driver\", \"isa-debugcon\", &error_abort);\n    qemu_opt_set(opts, \"chardev\", \"debugcon\", &error_abort);\n    return 0;\n}\n\nstatic gint machine_class_cmp(gconstpointer a, gconstpointer b)\n{\n    const MachineClass *mc1 = a, *mc2 = b;\n    int res;\n\n    if (mc1->family == NULL) {\n        if (mc2->family == NULL) {\n            /* Compare standalone machine types against each other; they sort\n             * in increasing order.\n             */\n            return strcmp(object_class_get_name(OBJECT_CLASS(mc1)),\n                          object_class_get_name(OBJECT_CLASS(mc2)));\n        }\n\n        /* Standalone machine types sort after families. */\n        return 1;\n    }\n\n    if (mc2->family == NULL) {\n        /* Families sort before standalone machine types. */\n        return -1;\n    }\n\n    /* Families sort between each other alphabetically increasingly. */\n    res = strcmp(mc1->family, mc2->family);\n    if (res != 0) {\n        return res;\n    }\n\n    /* Within the same family, machine types sort in decreasing order. */\n    return strcmp(object_class_get_name(OBJECT_CLASS(mc2)),\n                  object_class_get_name(OBJECT_CLASS(mc1)));\n}\n\n static MachineClass *machine_parse(const char *name)\n{\n    MachineClass *mc = NULL;\n    GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);\n\n    if (name) {\n        mc = find_machine(name);\n    }\n    if (mc) {\n        g_slist_free(machines);\n        return mc;\n    }\n    if (name && !is_help_option(name)) {\n        error_report(\"unsupported machine type\");\n        error_printf(\"Use -machine help to list supported machines\\n\");\n    } else {\n        printf(\"Supported machines are:\\n\");\n        machines = g_slist_sort(machines, machine_class_cmp);\n        for (el = machines; el; el = el->next) {\n            MachineClass *mc = el->data;\n            if (mc->alias) {\n                printf(\"%-20s %s (alias of %s)\\n\", mc->alias, mc->desc, mc->name);\n            }\n            printf(\"%-20s %s%s\\n\", mc->name, mc->desc,\n                   mc->is_default ? \" (default)\" : \"\");\n        }\n    }\n\n    g_slist_free(machines);\n    exit(!name || !is_help_option(name));\n}\n\nvoid qemu_add_exit_notifier(Notifier *notify)\n{\n    notifier_list_add(&exit_notifiers, notify);\n}\n\nvoid qemu_remove_exit_notifier(Notifier *notify)\n{\n    notifier_remove(notify);\n}\n\nstatic void qemu_run_exit_notifiers(void)\n{\n    notifier_list_notify(&exit_notifiers, NULL);\n}\n\nstatic bool machine_init_done;\n\nvoid qemu_add_machine_init_done_notifier(Notifier *notify)\n{\n    notifier_list_add(&machine_init_done_notifiers, notify);\n    if (machine_init_done) {\n        notify->notify(notify, NULL);\n    }\n}\n\nvoid qemu_remove_machine_init_done_notifier(Notifier *notify)\n{\n    notifier_remove(notify);\n}\n\nstatic void qemu_run_machine_init_done_notifiers(void)\n{\n    notifier_list_notify(&machine_init_done_notifiers, NULL);\n    machine_init_done = true;\n}\n\nstatic const QEMUOption *lookup_opt(int argc, char **argv,\n                                    const char **poptarg, int *poptind)\n{\n    const QEMUOption *popt;\n    int optind = *poptind;\n    char *r = argv[optind];\n    const char *optarg;\n\n    loc_set_cmdline(argv, optind, 1);\n    optind++;\n    /* Treat --foo the same as -foo.  */\n    if (r[1] == '-')\n        r++;\n    popt = qemu_options;\n    for(;;) {\n        if (!popt->name) {\n            error_report(\"invalid option\");\n            exit(1);\n        }\n        if (!strcmp(popt->name, r + 1))\n            break;\n        popt++;\n    }\n    if (popt->flags & HAS_ARG) {\n        if (optind >= argc) {\n            error_report(\"requires an argument\");\n            exit(1);\n        }\n        optarg = argv[optind++];\n        loc_set_cmdline(argv, optind - 2, 2);\n    } else {\n        optarg = NULL;\n    }\n\n    *poptarg = optarg;\n    *poptind = optind;\n\n    return popt;\n}\n\nstatic MachineClass *select_machine(void)\n{\n    MachineClass *machine_class = find_default_machine();\n    const char *optarg;\n    QemuOpts *opts;\n    Location loc;\n\n    loc_push_none(&loc);\n\n    opts = qemu_get_machine_opts();\n    qemu_opts_loc_restore(opts);\n\n    optarg = qemu_opt_get(opts, \"type\");\n    if (optarg) {\n        machine_class = machine_parse(optarg);\n    }\n\n    if (!machine_class) {\n        error_report(\"No machine specified, and there is no default\");\n        error_printf(\"Use -machine help to list supported machines\\n\");\n        exit(1);\n    }\n\n    loc_pop(&loc);\n    return machine_class;\n}\n\nstatic int machine_set_property(void *opaque,\n                                const char *name, const char *value,\n                                Error **errp)\n{\n    Object *obj = OBJECT(opaque);\n    Error *local_err = NULL;\n    char *p, *qom_name;\n\n    if (strcmp(name, \"type\") == 0) {\n        return 0;\n    }\n\n    qom_name = g_strdup(name);\n    for (p = qom_name; *p; p++) {\n        if (*p == '_') {\n            *p = '-';\n        }\n    }\n\n    object_property_parse(obj, value, qom_name, &local_err);\n    g_free(qom_name);\n\n    if (local_err) {\n        error_report_err(local_err);\n        return -1;\n    }\n\n    return 0;\n}\n\n\n/*\n * Initial object creation happens before all other\n * QEMU data types are created. The majority of objects\n * can be created at this point. The rng-egd object\n * cannot be created here, as it depends on the chardev\n * already existing.\n */\nstatic bool object_create_initial(const char *type)\n{\n    if (g_str_equal(type, \"rng-egd\")) {\n        return false;\n    }\n\n    /*\n     * return false for concrete netfilters since\n     * they depend on netdevs already existing\n     */\n    if (g_str_equal(type, \"filter-buffer\") ||\n        g_str_equal(type, \"filter-dump\") ||\n        g_str_equal(type, \"filter-mirror\") ||\n        g_str_equal(type, \"filter-redirector\") ||\n        g_str_equal(type, \"colo-compare\") ||\n        g_str_equal(type, \"filter-rewriter\") ||\n        g_str_equal(type, \"filter-replay\")) {\n        return false;\n    }\n\n    /* Memory allocation by backends needs to be done\n     * after configure_accelerator() (due to the tcg_enabled()\n     * checks at memory_region_init_*()).\n     *\n     * Also, allocation of large amounts of memory may delay\n     * chardev initialization for too long, and trigger timeouts\n     * on software that waits for a monitor socket to be created\n     * (e.g. libvirt).\n     */\n    if (g_str_has_prefix(type, \"memory-backend-\")) {\n        return false;\n    }\n\n    return true;\n}\n\n\n/*\n * The remainder of object creation happens after the\n * creation of chardev, fsdev, net clients and device data types.\n */\nstatic bool object_create_delayed(const char *type)\n{\n    return !object_create_initial(type);\n}\n\n\nstatic void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size,\n                               MachineClass *mc)\n{\n    uint64_t sz;\n    const char *mem_str;\n    const char *maxmem_str, *slots_str;\n    const ram_addr_t default_ram_size = mc->default_ram_size;\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n    Location loc;\n\n    loc_push_none(&loc);\n    qemu_opts_loc_restore(opts);\n\n    sz = 0;\n    mem_str = qemu_opt_get(opts, \"size\");\n    if (mem_str) {\n        if (!*mem_str) {\n            error_report(\"missing 'size' option value\");\n            exit(EXIT_FAILURE);\n        }\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n        /* Fix up legacy suffix-less format */\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n            uint64_t overflow_check = sz;\n\n            sz <<= 20;\n            if ((sz >> 20) != overflow_check) {\n                error_report(\"too large 'size' option value\");\n                exit(EXIT_FAILURE);\n            }\n        }\n    }\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n    if (sz == 0) {\n        sz = default_ram_size;\n    }\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n    ram_size = sz;\n    if (ram_size != sz) {\n        error_report(\"ram size too large\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* store value for the future use */\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n    *maxram_size = ram_size;\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n    slots_str = qemu_opt_get(opts, \"slots\");\n    if (maxmem_str && slots_str) {\n        uint64_t slots;\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n        if (sz < ram_size) {\n            error_report(\"invalid value of -m option maxmem: \"\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n                         sz, ram_size);\n            exit(EXIT_FAILURE);\n        } else if (sz > ram_size) {\n            if (!slots) {\n                error_report(\"invalid value of -m option: maxmem was \"\n                             \"specified, but no hotplug slots were specified\");\n                exit(EXIT_FAILURE);\n            }\n        } else if (slots) {\n            error_report(\"invalid value of -m option maxmem: \"\n                         \"memory slots were specified but maximum memory size \"\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n            exit(EXIT_FAILURE);\n        }\n\n        *maxram_size = sz;\n        *ram_slots = slots;\n    } else if ((!maxmem_str && slots_str) ||\n            (maxmem_str && !slots_str)) {\n        error_report(\"invalid -m option value: missing \"\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n        exit(EXIT_FAILURE);\n    }\n\n    loc_pop(&loc);\n}\n\nconst char *qemu_file = NULL;\n\n// bdg: This is Tim's fault\nchar **gargv;\nint gargc;\n\nstatic int global_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    GlobalProperty *g;\n\n    g = g_malloc0(sizeof(*g));\n    g->driver   = qemu_opt_get(opts, \"driver\");\n    g->property = qemu_opt_get(opts, \"property\");\n    g->value    = qemu_opt_get(opts, \"value\");\n    g->user_provided = true;\n    g->errp = &error_fatal;\n    qdev_prop_register_global(g);\n    return 0;\n}\n\nstatic int qemu_read_default_config_file(void)\n{\n    int ret;\n\n    ret = qemu_read_config_file(CONFIG_QEMU_CONFDIR \"/qemu.conf\");\n    if (ret < 0 && ret != -ENOENT) {\n        return ret;\n    }\n\n    return 0;\n}\n\n// Panda stuff\n\n/** Obtains the full path to the current executable */\nstatic char* this_executable_path(const char* argv0){\n    char buf[PATH_MAX] = {0};\n\n    // readlink method, linux only\n    // should fail at runtime on other posix-compatible systems\n    ssize_t size = readlink(\"/proc/self/exe\", buf, sizeof(buf));\n    if (size > 0 && size < sizeof(buf)) {\n        return strdup(buf);\n    }\n\n    // fallback method (only works when the executable is run directly)\n    return realpath(argv0, NULL);\n}\n\nvoid main_panda_run(void) {\n    panda_in_main_loop = 1;\n    main_loop();\n    panda_in_main_loop = 0;\n}\n\nint main_aux(int argc, char **argv, char **envp, PandaMainMode pmm)\n {\n    if (pmm == PANDA_RUN)    goto PANDA_MAIN_RUN;\n    if (pmm == PANDA_FINISH) goto PANDA_MAIN_FINISH;\n    int i;\n    int snapshot, linux_boot;\n    const char *initrd_filename;\n    const char *kernel_filename, *kernel_cmdline;\n    const char *boot_order = NULL;\n    const char *boot_once = NULL;\n    DisplayState *ds;\n    int cyls, heads, secs, translation;\n    QemuOpts *opts, *machine_opts;\n    QemuOpts *hda_opts = NULL, *icount_opts = NULL, *accel_opts = NULL;\n    QemuOptsList *olist;\n    int optind;\n    const char *optarg;\n    const char *loadvm = NULL;\n    MachineClass *machine_class;\n    const char *cpu_model;\n    const char *vga_model = NULL;\n    const char *qtest_chrdev = NULL;\n    const char *qtest_log = NULL;\n    const char *pid_file = NULL;\n    const char *incoming = NULL;\n    bool defconfig = true;\n    bool userconfig = true;\n    bool nographic = false;\n    DisplayType display_type = DT_DEFAULT;\n    int display_remote = 0;\n    const char *log_mask = NULL;\n    const char *log_file = NULL;\n    char *trace_file = NULL;\n    ram_addr_t maxram_size;\n    uint64_t ram_slots = 0;\n    FILE *vmstate_dump_file = NULL;\n    Error *main_loop_err = NULL;\n    Error *err = NULL;\n    bool list_data_dirs = false;\n    typedef struct BlockdevOptions_queue {\n        BlockdevOptions *bdo;\n        Location loc;\n        QSIMPLEQ_ENTRY(BlockdevOptions_queue) entry;\n    } BlockdevOptions_queue;\n    QSIMPLEQ_HEAD(, BlockdevOptions_queue) bdo_queue\n        = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);\n\n    // PANDA stuff\n    gargv = malloc(argc * sizeof(gargv));\n    int j;\n    for(j=0; j < argc ; ++j )\n    {\n        gargv[j] = strdup(argv[j]);\n    }\n    gargc = argc;\n    if (pmm == PANDA_NORMAL)\n        qemu_file = this_executable_path(argv[0]);\n    else\n        qemu_file = strdup(argv[0]);\n    assert(qemu_file != NULL);\n\n    const char* record_name = NULL;\n    // In order to load PANDA plugins all at once at the end\n    const char * panda_plugin_files[64] = {};\n    const char * panda_plugin_names[64] = {};\n    int nb_panda_plugins = 0;\n\n    module_call_init(MODULE_INIT_TRACE);\n\n    qemu_init_cpu_list();\n    qemu_init_cpu_loop();\n    qemu_mutex_lock_iothread();\n\n    atexit(qemu_run_exit_notifiers);\n    error_set_progname(argv[0]);\n    qemu_init_exec_dir(argv[0]);\n\n    module_call_init(MODULE_INIT_QOM);\n    monitor_init_qmp_commands();\n\n    qemu_add_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&qemu_legacy_drive_opts);\n    qemu_add_drive_opts(&qemu_common_drive_opts);\n    qemu_add_drive_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&bdrv_runtime_opts);\n    qemu_add_opts(&qemu_chardev_opts);\n    qemu_add_opts(&qemu_device_opts);\n    qemu_add_opts(&qemu_netdev_opts);\n    qemu_add_opts(&qemu_net_opts);\n    qemu_add_opts(&qemu_rtc_opts);\n    qemu_add_opts(&qemu_global_opts);\n    qemu_add_opts(&qemu_mon_opts);\n    qemu_add_opts(&qemu_trace_opts);\n    qemu_add_opts(&qemu_option_rom_opts);\n    qemu_add_opts(&qemu_machine_opts);\n    qemu_add_opts(&qemu_accel_opts);\n    qemu_add_opts(&qemu_mem_opts);\n    qemu_add_opts(&qemu_smp_opts);\n    qemu_add_opts(&qemu_boot_opts);\n    qemu_add_opts(&qemu_sandbox_opts);\n    qemu_add_opts(&qemu_add_fd_opts);\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_tpmdev_opts);\n    qemu_add_opts(&qemu_realtime_opts);\n    qemu_add_opts(&qemu_msg_opts);\n    qemu_add_opts(&qemu_name_opts);\n    qemu_add_opts(&qemu_numa_opts);\n    qemu_add_opts(&qemu_icount_opts);\n    qemu_add_opts(&qemu_semihosting_config_opts);\n    qemu_add_opts(&qemu_fw_cfg_opts);\n    module_call_init(MODULE_INIT_OPTS);\n\n    runstate_init();\n\n    if (qcrypto_init(&err) < 0) {\n        error_reportf_err(err, \"cannot initialize crypto: \");\n        exit(1);\n    }\n    rtc_clock = QEMU_CLOCK_HOST;\n\n    QLIST_INIT (&vm_change_state_head);\n    os_setup_early_signal_handling();\n\n    cpu_model = NULL;\n    snapshot = 0;\n    cyls = heads = secs = 0;\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    nb_nics = 0;\n\n    bdrv_init_with_whitelist();\n\n    autostart = 1;\n\n    /* first pass of option parsing */\n    optind = 1;\n    while (optind < argc) {\n        if (argv[optind][0] != '-') {\n            /* disk image */\n            optind++;\n        } else {\n            const QEMUOption *popt;\n\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            switch (popt->index) {\n            case QEMU_OPTION_nodefconfig:\n                defconfig = false;\n                break;\n            case QEMU_OPTION_nouserconfig:\n                userconfig = false;\n                break;\n            }\n        }\n    }\n\n    if (defconfig && userconfig) {\n        if (qemu_read_default_config_file() < 0) {\n            exit(1);\n        }\n    }\n\n    /* second pass of option parsing */\n    optind = 1;\n    for(;;) {\n        if (optind >= argc)\n            break;\n        if (argv[optind][0] != '-') {\n            hda_opts = drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);\n        } else {\n            const QEMUOption *popt;\n\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            if (!(popt->arch_mask & arch_type)) {\n                error_report(\"Option not supported for this target\");\n                exit(1);\n            }\n            switch(popt->index) {\n            case QEMU_OPTION_no_kvm_irqchip: {\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"kernel_irqchip=off\", false);\n                break;\n            }\n            case QEMU_OPTION_cpu:\n                /* hw initialization will check this */\n                cpu_model = optarg;\n                break;\n            case QEMU_OPTION_hda:\n                {\n                    char buf[256];\n                    if (cyls == 0)\n                        snprintf(buf, sizeof(buf), \"%s\", HD_OPTS);\n                    else\n                        snprintf(buf, sizeof(buf),\n                                 \"%s,cyls=%d,heads=%d,secs=%d%s\",\n                                 HD_OPTS , cyls, heads, secs,\n                                 translation == BIOS_ATA_TRANSLATION_LBA ?\n                                 \",trans=lba\" :\n                                 translation == BIOS_ATA_TRANSLATION_NONE ?\n                                 \",trans=none\" : \"\");\n                    drive_add(IF_DEFAULT, 0, optarg, buf);\n                    break;\n                }\n            case QEMU_OPTION_hdb:\n            case QEMU_OPTION_hdc:\n            case QEMU_OPTION_hdd:\n                drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,\n                          HD_OPTS);\n                break;\n            case QEMU_OPTION_blockdev:\n                {\n                    Visitor *v;\n                    BlockdevOptions_queue *bdo;\n\n                    v = qobject_input_visitor_new_str(optarg, \"driver\", &err);\n                    if (!v) {\n                        error_report_err(err);\n                        exit(1);\n                    }\n\n                    bdo = g_new(BlockdevOptions_queue, 1);\n                    visit_type_BlockdevOptions(v, NULL, &bdo->bdo,\n                                               &error_fatal);\n                    visit_free(v);\n                    loc_save(&bdo->loc);\n                    QSIMPLEQ_INSERT_TAIL(&bdo_queue, bdo, entry);\n                    break;\n                }\n            case QEMU_OPTION_drive:\n                if (drive_def(optarg) == NULL) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_set:\n                if (qemu_set_option(optarg) != 0)\n                    exit(1);\n                break;\n            case QEMU_OPTION_global:\n                if (qemu_global_option(optarg) != 0)\n                    exit(1);\n                break;\n            case QEMU_OPTION_mtdblock:\n                drive_add(IF_MTD, -1, optarg, MTD_OPTS);\n                break;\n            case QEMU_OPTION_sd:\n                drive_add(IF_SD, -1, optarg, SD_OPTS);\n                break;\n            case QEMU_OPTION_pflash:\n                drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);\n                break;\n            case QEMU_OPTION_snapshot:\n                snapshot = 1;\n                break;\n            case QEMU_OPTION_hdachs:\n                {\n                    const char *p;\n                    p = optarg;\n                    cyls = strtol(p, (char **)&p, 0);\n                    if (cyls < 1 || cyls > 16383)\n                        goto chs_fail;\n                    if (*p != ',')\n                        goto chs_fail;\n                    p++;\n                    heads = strtol(p, (char **)&p, 0);\n                    if (heads < 1 || heads > 16)\n                        goto chs_fail;\n                    if (*p != ',')\n                        goto chs_fail;\n                    p++;\n                    secs = strtol(p, (char **)&p, 0);\n                    if (secs < 1 || secs > 63)\n                        goto chs_fail;\n                    if (*p == ',') {\n                        p++;\n                        if (!strcmp(p, \"large\")) {\n                            translation = BIOS_ATA_TRANSLATION_LARGE;\n                        } else if (!strcmp(p, \"rechs\")) {\n                            translation = BIOS_ATA_TRANSLATION_RECHS;\n                        } else if (!strcmp(p, \"none\")) {\n                            translation = BIOS_ATA_TRANSLATION_NONE;\n                        } else if (!strcmp(p, \"lba\")) {\n                            translation = BIOS_ATA_TRANSLATION_LBA;\n                        } else if (!strcmp(p, \"auto\")) {\n                            translation = BIOS_ATA_TRANSLATION_AUTO;\n                        } else {\n                            goto chs_fail;\n                        }\n                    } else if (*p != '\\0') {\n                    chs_fail:\n                        error_report(\"invalid physical CHS format\");\n                        exit(1);\n                    }\n                    if (hda_opts != NULL) {\n                        qemu_opt_set_number(hda_opts, \"cyls\", cyls,\n                                            &error_abort);\n                        qemu_opt_set_number(hda_opts, \"heads\", heads,\n                                            &error_abort);\n                        qemu_opt_set_number(hda_opts, \"secs\", secs,\n                                            &error_abort);\n                        if (translation == BIOS_ATA_TRANSLATION_LARGE) {\n                            qemu_opt_set(hda_opts, \"trans\", \"large\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_RECHS) {\n                            qemu_opt_set(hda_opts, \"trans\", \"rechs\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_LBA) {\n                            qemu_opt_set(hda_opts, \"trans\", \"lba\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_NONE) {\n                            qemu_opt_set(hda_opts, \"trans\", \"none\",\n                                         &error_abort);\n                        }\n                    }\n                }\n                break;\n            case QEMU_OPTION_numa:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"numa\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_display:\n                display_type = select_display(optarg);\n                break;\n            case QEMU_OPTION_nographic:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"graphics=off\", false);\n                nographic = true;\n                display_type = DT_NONE;\n                break;\n            case QEMU_OPTION_curses:\n#ifdef CONFIG_CURSES\n                display_type = DT_CURSES;\n#else\n                error_report(\"curses support is disabled\");\n                exit(1);\n#endif\n                break;\n            case QEMU_OPTION_portrait:\n                graphic_rotate = 90;\n                break;\n            case QEMU_OPTION_rotate:\n                graphic_rotate = strtol(optarg, (char **) &optarg, 10);\n                if (graphic_rotate != 0 && graphic_rotate != 90 &&\n                    graphic_rotate != 180 && graphic_rotate != 270) {\n                    error_report(\"only 90, 180, 270 deg rotation is available\");\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_kernel:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"kernel\", optarg,\n                              &error_abort);\n                break;\n            case QEMU_OPTION_initrd:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"initrd\", optarg,\n                              &error_abort);\n                break;\n            case QEMU_OPTION_append:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"append\", optarg,\n                              &error_abort);\n                break;\n            case QEMU_OPTION_dtb:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"dtb\", optarg,\n                              &error_abort);\n                break;\n            case QEMU_OPTION_cdrom:\n                drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);\n                break;\n            case QEMU_OPTION_boot:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"boot-opts\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_fda:\n            case QEMU_OPTION_fdb:\n                drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,\n                          optarg, FD_OPTS);\n                break;\n            case QEMU_OPTION_no_fd_bootchk:\n                fd_bootchk = 0;\n                break;\n            case QEMU_OPTION_netdev:\n                default_net = 0;\n                if (net_client_parse(qemu_find_opts(\"netdev\"), optarg) == -1) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_net:\n                default_net = 0;\n                if (net_client_parse(qemu_find_opts(\"net\"), optarg) == -1) {\n                    exit(1);\n                }\n                break;\n#ifdef CONFIG_LIBISCSI\n            case QEMU_OPTION_iscsi:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"iscsi\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n#endif\n#ifdef CONFIG_SLIRP\n            case QEMU_OPTION_tftp:\n                error_report(\"The -tftp option is deprecated. \"\n                             \"Please use '-netdev user,tftp=...' instead.\");\n                legacy_tftp_prefix = optarg;\n                break;\n            case QEMU_OPTION_bootp:\n                error_report(\"The -bootp option is deprecated. \"\n                             \"Please use '-netdev user,bootfile=...' instead.\");\n                legacy_bootp_filename = optarg;\n                break;\n            case QEMU_OPTION_redir:\n                error_report(\"The -redir option is deprecated. \"\n                             \"Please use '-netdev user,hostfwd=...' instead.\");\n                if (net_slirp_redir(optarg) < 0)\n                    exit(1);\n                break;\n#endif\n            case QEMU_OPTION_bt:\n                add_device_config(DEV_BT, optarg);\n                break;\n            case QEMU_OPTION_audio_help:\n                AUD_help ();\n                exit (0);\n                break;\n            case QEMU_OPTION_soundhw:\n                select_soundhw (optarg);\n                break;\n            case QEMU_OPTION_h:\n                help(0);\n                break;\n            case QEMU_OPTION_version:\n                version();\n                exit(0);\n                break;\n            case QEMU_OPTION_m:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"memory\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(EXIT_FAILURE);\n                }\n                break;\n#ifdef CONFIG_TPM\n            case QEMU_OPTION_tpmdev:\n                if (tpm_config_parse(qemu_find_opts(\"tpmdev\"), optarg) < 0) {\n                    exit(1);\n                }\n                break;\n#endif\n            case QEMU_OPTION_mempath:\n                mem_path = optarg;\n                break;\n            case QEMU_OPTION_mem_prealloc:\n                mem_prealloc = 1;\n                break;\n            case QEMU_OPTION_d:\n                log_mask = optarg;\n                break;\n            case QEMU_OPTION_D:\n                log_file = optarg;\n                break;\n            case QEMU_OPTION_DFILTER:\n                qemu_set_dfilter_ranges(optarg, &error_fatal);\n                break;\n            case QEMU_OPTION_s:\n                add_device_config(DEV_GDB, \"tcp::\" DEFAULT_GDBSTUB_PORT);\n                break;\n            case QEMU_OPTION_gdb:\n                add_device_config(DEV_GDB, optarg);\n                break;\n            case QEMU_OPTION_L:\n                if (is_help_option(optarg)) {\n                    list_data_dirs = true;\n                } else if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n                    data_dir[data_dir_idx++] = optarg;\n                }\n                break;\n            case QEMU_OPTION_bios:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"firmware\", optarg,\n                              &error_abort);\n                break;\n            case QEMU_OPTION_singlestep:\n                singlestep = 1;\n                break;\n            case QEMU_OPTION_S:\n                autostart = 0;\n                break;\n            case QEMU_OPTION_k:\n                keyboard_layout = optarg;\n                break;\n            case QEMU_OPTION_localtime:\n                rtc_utc = 0;\n                break;\n            case QEMU_OPTION_vga:\n                vga_model = optarg;\n                default_vga = 0;\n                break;\n            case QEMU_OPTION_g:\n                {\n                    const char *p;\n                    int w, h, depth;\n                    p = optarg;\n                    w = strtol(p, (char **)&p, 10);\n                    if (w <= 0) {\n                    graphic_error:\n                        error_report(\"invalid resolution or depth\");\n                        exit(1);\n                    }\n                    if (*p != 'x')\n                        goto graphic_error;\n                    p++;\n                    h = strtol(p, (char **)&p, 10);\n                    if (h <= 0)\n                        goto graphic_error;\n                    if (*p == 'x') {\n                        p++;\n                        depth = strtol(p, (char **)&p, 10);\n                        if (depth != 8 && depth != 15 && depth != 16 &&\n                            depth != 24 && depth != 32)\n                            goto graphic_error;\n                    } else if (*p == '\\0') {\n                        depth = graphic_depth;\n                    } else {\n                        goto graphic_error;\n                    }\n\n                    graphic_width = w;\n                    graphic_height = h;\n                    graphic_depth = depth;\n                }\n                break;\n            case QEMU_OPTION_echr:\n                {\n                    char *r;\n                    term_escape_char = strtol(optarg, &r, 0);\n                    if (r == optarg)\n                        printf(\"Bad argument to echr\\n\");\n                    break;\n                }\n            case QEMU_OPTION_monitor:\n                default_monitor = 0;\n                if (strncmp(optarg, \"none\", 4)) {\n                    monitor_parse(optarg, \"readline\", false);\n                }\n                break;\n            case QEMU_OPTION_qmp:\n                monitor_parse(optarg, \"control\", false);\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_qmp_pretty:\n                monitor_parse(optarg, \"control\", true);\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_mon:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"mon\"), optarg,\n                                               true);\n                if (!opts) {\n                    exit(1);\n                }\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_chardev:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"chardev\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_fsdev:\n                olist = qemu_find_opts(\"fsdev\");\n                if (!olist) {\n                    error_report(\"fsdev support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_virtfs: {\n                QemuOpts *fsdev;\n                QemuOpts *device;\n                const char *writeout, *sock_fd, *socket, *path, *security_model;\n\n                olist = qemu_find_opts(\"virtfs\");\n                if (!olist) {\n                    error_report(\"virtfs support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n\n                if (qemu_opt_get(opts, \"fsdriver\") == NULL ||\n                    qemu_opt_get(opts, \"mount_tag\") == NULL) {\n                    error_report(\"Usage: -virtfs fsdriver,mount_tag=tag\");\n                    exit(1);\n                }\n                fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n                                         qemu_opt_get(opts, \"mount_tag\"),\n                                         1, NULL);\n                if (!fsdev) {\n                    error_report(\"duplicate fsdev id: %s\",\n                                 qemu_opt_get(opts, \"mount_tag\"));\n                    exit(1);\n                }\n\n                writeout = qemu_opt_get(opts, \"writeout\");\n                if (writeout) {\n#ifdef CONFIG_SYNC_FILE_RANGE\n                    qemu_opt_set(fsdev, \"writeout\", writeout, &error_abort);\n#else\n                    error_report(\"writeout=immediate not supported \"\n                                 \"on this platform\");\n                    exit(1);\n#endif\n                }\n                qemu_opt_set(fsdev, \"fsdriver\",\n                             qemu_opt_get(opts, \"fsdriver\"), &error_abort);\n                path = qemu_opt_get(opts, \"path\");\n                if (path) {\n                    qemu_opt_set(fsdev, \"path\", path, &error_abort);\n                }\n                security_model = qemu_opt_get(opts, \"security_model\");\n                if (security_model) {\n                    qemu_opt_set(fsdev, \"security_model\", security_model,\n                                 &error_abort);\n                }\n                socket = qemu_opt_get(opts, \"socket\");\n                if (socket) {\n                    qemu_opt_set(fsdev, \"socket\", socket, &error_abort);\n                }\n                sock_fd = qemu_opt_get(opts, \"sock_fd\");\n                if (sock_fd) {\n                    qemu_opt_set(fsdev, \"sock_fd\", sock_fd, &error_abort);\n                }\n\n                qemu_opt_set_bool(fsdev, \"readonly\",\n                                  qemu_opt_get_bool(opts, \"readonly\", 0),\n                                  &error_abort);\n                device = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                          &error_abort);\n                qemu_opt_set(device, \"driver\", \"virtio-9p-pci\", &error_abort);\n                qemu_opt_set(device, \"fsdev\",\n                             qemu_opt_get(opts, \"mount_tag\"), &error_abort);\n                qemu_opt_set(device, \"mount_tag\",\n                             qemu_opt_get(opts, \"mount_tag\"), &error_abort);\n                break;\n            }\n            case QEMU_OPTION_virtfs_synth: {\n                QemuOpts *fsdev;\n                QemuOpts *device;\n\n                fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"), \"v_synth\",\n                                         1, NULL);\n                if (!fsdev) {\n                    error_report(\"duplicate option: %s\", \"virtfs_synth\");\n                    exit(1);\n                }\n                qemu_opt_set(fsdev, \"fsdriver\", \"synth\", &error_abort);\n\n                device = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                          &error_abort);\n                qemu_opt_set(device, \"driver\", \"virtio-9p-pci\", &error_abort);\n                qemu_opt_set(device, \"fsdev\", \"v_synth\", &error_abort);\n                qemu_opt_set(device, \"mount_tag\", \"v_synth\", &error_abort);\n                break;\n            }\n            case QEMU_OPTION_serial:\n                add_device_config(DEV_SERIAL, optarg);\n                default_serial = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n                }\n                break;\n            case QEMU_OPTION_watchdog:\n                if (watchdog) {\n                    error_report(\"only one watchdog option may be given\");\n                    return 1;\n                }\n                watchdog = optarg;\n                break;\n            case QEMU_OPTION_watchdog_action:\n                if (select_watchdog_action(optarg) == -1) {\n                    error_report(\"unknown -watchdog-action parameter\");\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_virtiocon:\n                add_device_config(DEV_VIRTCON, optarg);\n                default_virtcon = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n                }\n                break;\n            case QEMU_OPTION_parallel:\n                add_device_config(DEV_PARALLEL, optarg);\n                default_parallel = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n                }\n                break;\n            case QEMU_OPTION_debugcon:\n                add_device_config(DEV_DEBUGCON, optarg);\n                break;\n            case QEMU_OPTION_loadvm:\n                loadvm = optarg;\n                break;\n            case QEMU_OPTION_full_screen:\n                full_screen = 1;\n                break;\n            case QEMU_OPTION_no_frame:\n                no_frame = 1;\n                break;\n            case QEMU_OPTION_alt_grab:\n                alt_grab = 1;\n                break;\n            case QEMU_OPTION_ctrl_grab:\n                ctrl_grab = 1;\n                break;\n            case QEMU_OPTION_no_quit:\n                no_quit = 1;\n                break;\n            case QEMU_OPTION_sdl:\n#ifdef CONFIG_SDL\n                display_type = DT_SDL;\n                break;\n#else\n                error_report(\"SDL support is disabled\");\n                exit(1);\n#endif\n            case QEMU_OPTION_pidfile:\n                pid_file = optarg;\n                break;\n            case QEMU_OPTION_win2k_hack:\n                win2k_install_hack = 1;\n                break;\n            case QEMU_OPTION_rtc_td_hack: {\n                static GlobalProperty slew_lost_ticks = {\n                    .driver   = \"mc146818rtc\",\n                    .property = \"lost_tick_policy\",\n                    .value    = \"slew\",\n                };\n\n                qdev_prop_register_global(&slew_lost_ticks);\n                break;\n            }\n            case QEMU_OPTION_acpitable:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"acpi\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                acpi_table_add(opts, &error_fatal);\n                break;\n            case QEMU_OPTION_smbios:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"smbios\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                smbios_entry_add(opts, &error_fatal);\n                break;\n            case QEMU_OPTION_fwcfg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"fw_cfg\"),\n                                               optarg, true);\n                if (opts == NULL) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_enable_kvm:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=kvm\", false);\n                break;\n            case QEMU_OPTION_enable_hax:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=hax\", false);\n                break;\n            case QEMU_OPTION_M:\n            case QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n             case QEMU_OPTION_no_kvm:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=tcg\", false);\n                break;\n            case QEMU_OPTION_no_kvm_pit: {\n                error_report(\"warning: ignoring deprecated option\");\n                break;\n            }\n            case QEMU_OPTION_no_kvm_pit_reinjection: {\n                static GlobalProperty kvm_pit_lost_tick_policy = {\n                    .driver   = \"kvm-pit\",\n                    .property = \"lost_tick_policy\",\n                    .value    = \"discard\",\n                };\n\n                error_report(\"warning: deprecated, replaced by \"\n                             \"-global kvm-pit.lost_tick_policy=discard\");\n                qdev_prop_register_global(&kvm_pit_lost_tick_policy);\n                break;\n            }\n            case QEMU_OPTION_accel:\n                accel_opts = qemu_opts_parse_noisily(qemu_find_opts(\"accel\"),\n                                                     optarg, true);\n                optarg = qemu_opt_get(accel_opts, \"accel\");\n\n                olist = qemu_find_opts(\"machine\");\n                if (strcmp(\"kvm\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=kvm\", false);\n                } else if (strcmp(\"xen\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=xen\", false);\n                } else if (strcmp(\"tcg\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=tcg\", false);\n                } else {\n                    if (!is_help_option(optarg)) {\n                        error_printf(\"Unknown accelerator: %s\", optarg);\n                    }\n                    error_printf(\"Supported accelerators: kvm, xen, tcg\\n\");\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_usb:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"usb=on\", false);\n                break;\n            case QEMU_OPTION_usbdevice:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"usb=on\", false);\n                add_device_config(DEV_USB, optarg);\n                break;\n            case QEMU_OPTION_device:\n                if (!qemu_opts_parse_noisily(qemu_find_opts(\"device\"),\n                                             optarg, true)) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_smp:\n                if (!qemu_opts_parse_noisily(qemu_find_opts(\"smp-opts\"),\n                                             optarg, true)) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_vnc:\n                vnc_parse(optarg, &error_fatal);\n                break;\n            case QEMU_OPTION_no_acpi:\n                acpi_enabled = 0;\n                break;\n            case QEMU_OPTION_no_hpet:\n                no_hpet = 1;\n                break;\n            case QEMU_OPTION_balloon:\n                if (balloon_parse(optarg) < 0) {\n                    error_report(\"unknown -balloon argument %s\", optarg);\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_no_reboot:\n                no_reboot = 1;\n                break;\n            case QEMU_OPTION_no_shutdown:\n                no_shutdown = 1;\n                break;\n            case QEMU_OPTION_show_cursor:\n                cursor_hide = 0;\n                break;\n            case QEMU_OPTION_uuid:\n                if (qemu_uuid_parse(optarg, &qemu_uuid) < 0) {\n                    error_report(\"failed to parse UUID string: wrong format\");\n                    exit(1);\n                }\n                qemu_uuid_set = true;\n                break;\n            case QEMU_OPTION_option_rom:\n                if (nb_option_roms >= MAX_OPTION_ROMS) {\n                    error_report(\"too many option ROMs\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"option-rom\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                option_rom[nb_option_roms].name = qemu_opt_get(opts, \"romfile\");\n                option_rom[nb_option_roms].bootindex =\n                    qemu_opt_get_number(opts, \"bootindex\", -1);\n                if (!option_rom[nb_option_roms].name) {\n                    error_report(\"Option ROM file is not specified\");\n                    exit(1);\n                }\n                nb_option_roms++;\n                break;\n            case QEMU_OPTION_semihosting:\n                semihosting.enabled = true;\n                semihosting.target = SEMIHOSTING_TARGET_AUTO;\n                break;\n            case QEMU_OPTION_semihosting_config:\n                semihosting.enabled = true;\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"semihosting-config\"),\n                                               optarg, false);\n                if (opts != NULL) {\n                    semihosting.enabled = qemu_opt_get_bool(opts, \"enable\",\n                                                            true);\n                    const char *target = qemu_opt_get(opts, \"target\");\n                    if (target != NULL) {\n                        if (strcmp(\"native\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_NATIVE;\n                        } else if (strcmp(\"gdb\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_GDB;\n                        } else  if (strcmp(\"auto\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_AUTO;\n                        } else {\n                            error_report(\"unsupported semihosting-config %s\",\n                                         optarg);\n                            exit(1);\n                        }\n                    } else {\n                        semihosting.target = SEMIHOSTING_TARGET_AUTO;\n                    }\n                    /* Set semihosting argument count and vector */\n                    qemu_opt_foreach(opts, add_semihosting_arg,\n                                     &semihosting, NULL);\n                } else {\n                    error_report(\"unsupported semihosting-config %s\", optarg);\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_tdf:\n                error_report(\"warning: ignoring deprecated option\");\n                break;\n            case QEMU_OPTION_name:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"name\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_prom_env:\n                if (nb_prom_envs >= MAX_PROM_ENVS) {\n                    error_report(\"too many prom variables\");\n                    exit(1);\n                }\n                prom_envs[nb_prom_envs] = optarg;\n                nb_prom_envs++;\n                break;\n            case QEMU_OPTION_old_param:\n                old_param = 1;\n                break;\n            case QEMU_OPTION_clock:\n                /* Clock options no longer exist.  Keep this option for\n                 * backward compatibility.\n                 */\n                break;\n            case QEMU_OPTION_startdate:\n                configure_rtc_date_offset(optarg, 1);\n                break;\n            case QEMU_OPTION_rtc:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"rtc\"), optarg,\n                                               false);\n                if (!opts) {\n                    exit(1);\n                }\n                configure_rtc(opts);\n                break;\n            case QEMU_OPTION_tb_size:\n                tcg_tb_size = strtol(optarg, NULL, 0);\n                if (tcg_tb_size < 0) {\n                    tcg_tb_size = 0;\n                }\n                break;\n            case QEMU_OPTION_icount:\n                icount_opts = qemu_opts_parse_noisily(qemu_find_opts(\"icount\"),\n                                                      optarg, true);\n                if (!icount_opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_incoming:\n                if (!incoming) {\n                    runstate_set(RUN_STATE_INMIGRATE);\n                }\n                incoming = optarg;\n                break;\n            case QEMU_OPTION_only_migratable:\n                only_migratable = 1;\n                break;\n            case QEMU_OPTION_nodefaults:\n                has_defaults = 0;\n                break;\n            case QEMU_OPTION_xen_domid:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_domid = atoi(optarg);\n                break;\n            case QEMU_OPTION_xen_create:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_mode = XEN_CREATE;\n                break;\n            case QEMU_OPTION_xen_attach:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_mode = XEN_ATTACH;\n                break;\n            case QEMU_OPTION_trace:\n                g_free(trace_file);\n                trace_file = trace_opt_parse(optarg);\n                break;\n            case QEMU_OPTION_readconfig:\n                {\n                    int ret = qemu_read_config_file(optarg);\n                    if (ret < 0) {\n                        error_report(\"read config %s: %s\", optarg,\n                                     strerror(-ret));\n                        exit(1);\n                    }\n                    break;\n                }\n            case QEMU_OPTION_spice:\n                olist = qemu_find_opts(\"spice\");\n                if (!olist) {\n                    error_report(\"spice support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                display_remote++;\n                break;\n            case QEMU_OPTION_writeconfig:\n                {\n                    FILE *fp;\n                    if (strcmp(optarg, \"-\") == 0) {\n                        fp = stdout;\n                    } else {\n                        fp = fopen(optarg, \"w\");\n                        if (fp == NULL) {\n                            error_report(\"open %s: %s\", optarg,\n                                         strerror(errno));\n                            exit(1);\n                        }\n                    }\n                    qemu_config_write(fp);\n                    if (fp != stdout) {\n                        fclose(fp);\n                    }\n                    break;\n                }\n            case QEMU_OPTION_qtest:\n                qtest_chrdev = optarg;\n                break;\n            case QEMU_OPTION_qtest_log:\n                qtest_log = optarg;\n                break;\n            case QEMU_OPTION_sandbox:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"sandbox\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_add_fd:\n#ifndef _WIN32\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"add-fd\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n#else\n                error_report(\"File descriptor passing is disabled on this \"\n                             \"platform\");\n                exit(1);\n#endif\n                break;\n            case QEMU_OPTION_object:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"object\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_realtime:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"realtime\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                enable_mlock = qemu_opt_get_bool(opts, \"mlock\", true);\n                break;\n            case QEMU_OPTION_msg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"msg\"), optarg,\n                                               false);\n                if (!opts) {\n                    exit(1);\n                }\n                configure_msg(opts);\n                break;\n            case QEMU_OPTION_dump_vmstate:\n                if (vmstate_dump_file) {\n                    error_report(\"only one '-dump-vmstate' \"\n                                 \"option may be given\");\n                    exit(1);\n                }\n                vmstate_dump_file = fopen(optarg, \"w\");\n                if (vmstate_dump_file == NULL) {\n                    error_report(\"open %s: %s\", optarg, strerror(errno));\n                    exit(1);\n                }\n                break;\n#if defined(CONFIG_LLVM)\n            case QEMU_OPTION_execute_llvm:\n                if (!has_llvm_engine) {\n                    fprintf(stderr, \"Cannot execute in LLVM mode (S2E mode present or LLVM mode missing)\\n\");\n                    exit(1);\n                }\n                generate_llvm = 1;\n                execute_llvm = 1;\n                break;\n            case QEMU_OPTION_generate_llvm:\n                if (!has_llvm_engine) {\n                    fprintf(stderr, \"Cannot execute in LLVM mode (S2E mode present or LLVM mode missing)\\n\");\n                    exit(1);\n                }\n                generate_llvm = 1;\n                break;\n#endif\n            case QEMU_OPTION_replay:\n                display_type = DT_NONE;\n                replay_name = optarg;\n                break;\n            case QEMU_OPTION_pandalog:\n                pandalog = 1;\n                pandalog_cc_init_write(optarg);\n                printf (\"pandalogging to [%s]\\n\", optarg);\n                break;\n            case QEMU_OPTION_record_from:\n                record_name = optarg;\n                break;\n            case QEMU_OPTION_panda_arg:\n                // panda_add_arg() currently always return true\n                assert(panda_add_arg(NULL, optarg));\n                break;\n            case QEMU_OPTION_panda_plugin:\n                panda_plugin_files[nb_panda_plugins] = optarg;\n                panda_plugin_names[nb_panda_plugins] = NULL;\n                nb_panda_plugins++;\n                break;\n            case QEMU_OPTION_panda_plugins:\n                {\n                    char *new_optarg = strdup(optarg);\n                    char *plugin_start = new_optarg;\n                    char *plugin_end = new_optarg;\n\n                    while (plugin_end != NULL) {\n                        plugin_end = strchr(plugin_start, ';');\n                        if (plugin_end != NULL) *plugin_end = '\\0';\n\n                        char *opt_list;\n                        if ((opt_list = strchr(plugin_start, ':'))) {\n                            *opt_list = '\\0';\n                            opt_list++;\n\n                            char *opt_start = opt_list, *opt_end = opt_list;\n                            while (opt_end != NULL) {\n                                opt_end = strchr(opt_start, ',');\n                                if (opt_end != NULL) *opt_end = '\\0';\n\n                                // panda_add_arg() currently always return true\n                                assert(panda_add_arg(plugin_start, opt_start));\n                                fprintf(stderr, PANDA_MSG_FMT \"adding argument %s.\\n\", plugin_start, opt_start);\n\n                                opt_start = opt_end + 1;\n                            }\n                        }\n\n                        if (0 == strcmp(\"general\", plugin_start)) {\n                            // not really a plugin -- just used to collect general panda args\n                        }\n                        else {\n                            char *plugin_path = panda_plugin_path((const char *) plugin_start);\n                            if (NULL == plugin_path) {\n                                fprintf(stderr,\n                                        PANDA_MSG_FMT\n                                        \"Failed to resolve path for plugin.\\n\",\n                                        plugin_start);\n                                abort();\n                            }\n                            panda_plugin_files[nb_panda_plugins] = plugin_path;\n                            panda_plugin_names[nb_panda_plugins] = strdup(plugin_start);\n                            nb_panda_plugins++;\n                        }\n\n                        plugin_start = plugin_end + 1;\n                    }\n                    free(new_optarg);\n                    break;\n                }\n            case QEMU_OPTION_panda_os_name:\n            {\n                char *os_name = strdup(optarg);\n                // NB: this will complain if we provide an os name that panda doesnt know about\n                panda_set_os_name(os_name);\n                break;\n            }\n            case QEMU_OPTION_complete_rr_snapshot:\n            {\n                panda_complete_rr_snapshot = 1;\n            }\n            default:\n                os_parse_cmd_args(popt->index, optarg);\n            }\n        }\n    }\n    /*\n     * Clear error location left behind by the loop.\n     * Best done right after the loop.  Do not insert code here!\n     */\n    loc_set_none();\n\n    // Now that all arguments are available, we can load plugins\n    int pp_idx;\n    for (pp_idx = 0; pp_idx < nb_panda_plugins; pp_idx++) {\n      if(!panda_load_plugin(panda_plugin_files[pp_idx], panda_plugin_names[pp_idx])) {\n          fprintf(stderr, \"FAIL: Unable to load plugin `%s'\\n\", panda_plugin_files[pp_idx]);\n          abort();\n      }\n      free((char*)panda_plugin_names[pp_idx]);\n      g_free((gchar*)panda_plugin_files[pp_idx]);\n    }\n\n    // This is to support having a help option in the plugins. If\n    // someone asked for help on a plugin, we don't want to start\n    // anything else.\n    if (panda_abort_requested)\n        exit(0);\n\n    replay_configure(icount_opts);\n\n    machine_class = select_machine();\n\n    set_memory_options(&ram_slots, &maxram_size, machine_class);\n\n    os_daemonize();\n\n    if (pid_file && qemu_create_pidfile(pid_file) != 0) {\n        error_report(\"could not acquire pid file: %s\", strerror(errno));\n        exit(1);\n    }\n\n    if (qemu_init_main_loop(&main_loop_err)) {\n        error_report_err(main_loop_err);\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"sandbox\"),\n                          parse_sandbox, NULL, NULL)) {\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"name\"),\n                          parse_name, NULL, NULL)) {\n        exit(1);\n    }\n\n#ifndef _WIN32\n    if (qemu_opts_foreach(qemu_find_opts(\"add-fd\"),\n                          parse_add_fd, NULL, NULL)) {\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"add-fd\"),\n                          cleanup_add_fd, NULL, NULL)) {\n        exit(1);\n    }\n#endif\n\n    current_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n    if (machine_help_func(qemu_get_machine_opts(), current_machine)) {\n        exit(0);\n    }\n    object_property_add_child(object_get_root(), \"machine\",\n                              OBJECT(current_machine), &error_abort);\n\n    if (machine_class->minimum_page_bits) {\n        if (!set_preferred_target_page_bits(machine_class->minimum_page_bits)) {\n            /* This would be a board error: specifying a minimum smaller than\n             * a target's compile-time fixed setting.\n             */\n            g_assert_not_reached();\n        }\n    }\n\n    cpu_exec_init_all();\n\n    if (machine_class->hw_version) {\n        qemu_set_hw_version(machine_class->hw_version);\n    }\n\n    if (cpu_model && is_help_option(cpu_model)) {\n        list_cpus(stdout, &fprintf, cpu_model);\n        exit(0);\n    }\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file(trace_file);\n\n    /* Open the logfile at this point and set the log mask if necessary.\n     */\n    if (log_file) {\n        qemu_set_log_filename(log_file, &error_fatal);\n    }\n\n    if (log_mask) {\n        int mask;\n        mask = qemu_str_to_log_mask(log_mask);\n        if (!mask) {\n            qemu_print_log_usage(stdout);\n            exit(1);\n        }\n        qemu_set_log(mask);\n    } else {\n        qemu_set_log(0);\n    }\n\n    /* If no data_dir is specified then try to find it relative to the\n       executable path.  */\n    if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n        data_dir[data_dir_idx] = os_find_datadir();\n        if (data_dir[data_dir_idx] != NULL) {\n            data_dir_idx++;\n        }\n    }\n    /* If all else fails use the install path specified when building. */\n    if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n        data_dir[data_dir_idx++] = CONFIG_QEMU_DATADIR;\n    }\n\n#if defined(CONFIG_LLVM)\n    if (generate_llvm || execute_llvm){\n        if (tcg_llvm_translator == NULL){\n            tcg_llvm_initialize();\n        }\n    }\n#endif\n\n    /* -L help lists the data directories and exits. */\n    if (list_data_dirs) {\n        for (i = 0; i < data_dir_idx; i++) {\n            printf(\"%s\\n\", data_dir[i]);\n        }\n        exit(0);\n    }\n\n    smp_parse(qemu_opts_find(qemu_find_opts(\"smp-opts\"), NULL));\n\n    machine_class->max_cpus = machine_class->max_cpus ?: 1; /* Default to UP */\n    if (max_cpus > machine_class->max_cpus) {\n        error_report(\"Number of SMP CPUs requested (%d) exceeds max CPUs \"\n                     \"supported by machine '%s' (%d)\", max_cpus,\n                     machine_class->name, machine_class->max_cpus);\n        exit(1);\n    }\n\n    /*\n     * Get the default machine options from the machine if it is not already\n     * specified either by the configuration file or by the command line.\n     */\n    if (machine_class->default_machine_opts) {\n        qemu_opts_set_defaults(qemu_find_opts(\"machine\"),\n                               machine_class->default_machine_opts, 0);\n    }\n\n    qemu_opts_foreach(qemu_find_opts(\"device\"),\n                      default_driver_check, NULL, NULL);\n    qemu_opts_foreach(qemu_find_opts(\"global\"),\n                      default_driver_check, NULL, NULL);\n\n    if (!vga_model && !default_vga) {\n        vga_interface_type = VGA_DEVICE;\n    }\n    if (!has_defaults || machine_class->no_serial) {\n        default_serial = 0;\n    }\n    if (!has_defaults || machine_class->no_parallel) {\n        default_parallel = 0;\n    }\n    if (!has_defaults || !machine_class->use_virtcon) {\n        default_virtcon = 0;\n    }\n    if (!has_defaults || !machine_class->use_sclp) {\n        default_sclp = 0;\n    }\n    if (!has_defaults || machine_class->no_floppy) {\n        default_floppy = 0;\n    }\n    if (!has_defaults || machine_class->no_cdrom) {\n        default_cdrom = 0;\n    }\n    if (!has_defaults || machine_class->no_sdcard) {\n        default_sdcard = 0;\n    }\n    if (!has_defaults) {\n        default_monitor = 0;\n        default_net = 0;\n        default_vga = 0;\n    }\n\n    if (is_daemonized()) {\n        /* According to documentation and historically, -nographic redirects\n         * serial port, parallel port and monitor to stdio, which does not work\n         * with -daemonize.  We can redirect these to null instead, but since\n         * -nographic is legacy, let's just error out.\n         * We disallow -nographic only if all other ports are not redirected\n         * explicitly, to not break existing legacy setups which uses\n         * -nographic _and_ redirects all ports explicitly - this is valid\n         * usage, -nographic is just a no-op in this case.\n         */\n        if (nographic\n            && (default_parallel || default_serial\n                || default_monitor || default_virtcon)) {\n            error_report(\"-nographic cannot be used with -daemonize\");\n            exit(1);\n        }\n#ifdef CONFIG_CURSES\n        if (display_type == DT_CURSES) {\n            error_report(\"curses display cannot be used with -daemonize\");\n            exit(1);\n        }\n#endif\n    }\n\n    if (nographic) {\n        if (default_parallel)\n            add_device_config(DEV_PARALLEL, \"null\");\n        if (default_serial && default_monitor) {\n            add_device_config(DEV_SERIAL, \"mon:stdio\");\n        } else if (default_virtcon && default_monitor) {\n            add_device_config(DEV_VIRTCON, \"mon:stdio\");\n        } else if (default_sclp && default_monitor) {\n            add_device_config(DEV_SCLP, \"mon:stdio\");\n        } else {\n            if (default_serial)\n                add_device_config(DEV_SERIAL, \"stdio\");\n            if (default_virtcon)\n                add_device_config(DEV_VIRTCON, \"stdio\");\n            if (default_sclp) {\n                add_device_config(DEV_SCLP, \"stdio\");\n            }\n            if (default_monitor)\n                monitor_parse(\"stdio\", \"readline\", false);\n        }\n    } else {\n        if (default_serial)\n            add_device_config(DEV_SERIAL, \"vc:80Cx24C\");\n        if (default_parallel)\n            add_device_config(DEV_PARALLEL, \"vc:80Cx24C\");\n        if (default_monitor)\n            monitor_parse(\"vc:80Cx24C\", \"readline\", false);\n        if (default_virtcon)\n            add_device_config(DEV_VIRTCON, \"vc:80Cx24C\");\n        if (default_sclp) {\n            add_device_config(DEV_SCLP, \"vc:80Cx24C\");\n        }\n    }\n\n#if defined(CONFIG_VNC)\n    if (!QTAILQ_EMPTY(&(qemu_find_opts(\"vnc\")->head))) {\n        display_remote++;\n    }\n#endif\n    if (display_type == DT_DEFAULT && !display_remote) {\n#if defined(CONFIG_GTK)\n        display_type = DT_GTK;\n#elif defined(CONFIG_SDL)\n        display_type = DT_SDL;\n#elif defined(CONFIG_COCOA)\n        display_type = DT_COCOA;\n#elif defined(CONFIG_VNC)\n        vnc_parse(\"localhost:0,to=99,id=default\", &error_abort);\n#else\n        display_type = DT_NONE;\n#endif\n    }\n\n    if ((no_frame || alt_grab || ctrl_grab) && display_type != DT_SDL) {\n        error_report(\"-no-frame, -alt-grab and -ctrl-grab are only valid \"\n                     \"for SDL, ignoring option\");\n    }\n    if (no_quit && (display_type != DT_GTK && display_type != DT_SDL)) {\n        error_report(\"-no-quit is only valid for GTK and SDL, \"\n                     \"ignoring option\");\n    }\n\n    if (display_type == DT_GTK) {\n        early_gtk_display_init(request_opengl);\n    }\n\n    if (display_type == DT_SDL) {\n        sdl_display_early_init(request_opengl);\n    }\n\n    qemu_console_early_init();\n\n    if (request_opengl == 1 && display_opengl == 0) {\n#if defined(CONFIG_OPENGL)\n        error_report(\"OpenGL is not supported by the display\");\n#else\n        error_report(\"OpenGL support is disabled\");\n#endif\n        exit(1);\n    }\n\n    page_size_init();\n    socket_init();\n\n    if (qemu_opts_foreach(qemu_find_opts(\"object\"),\n                          user_creatable_add_opts_foreach,\n                          object_create_initial, NULL)) {\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"chardev\"),\n                          chardev_init_func, NULL, NULL)) {\n        exit(1);\n    }\n\n#ifdef CONFIG_VIRTFS\n    if (qemu_opts_foreach(qemu_find_opts(\"fsdev\"),\n                          fsdev_init_func, NULL, NULL)) {\n        exit(1);\n    }\n#endif\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"),\n                          device_help_func, NULL, NULL)) {\n        exit(0);\n    }\n\n    machine_opts = qemu_get_machine_opts();\n    if (qemu_opt_foreach(machine_opts, machine_set_property, current_machine,\n                         NULL)) {\n        object_unref(OBJECT(current_machine));\n        exit(1);\n    }\n\n    configure_accelerator(current_machine);\n\n    if (qtest_chrdev) {\n        qtest_init(qtest_chrdev, qtest_log, &error_fatal);\n    }\n\n    machine_opts = qemu_get_machine_opts();\n    kernel_filename = qemu_opt_get(machine_opts, \"kernel\");\n    initrd_filename = qemu_opt_get(machine_opts, \"initrd\");\n    kernel_cmdline = qemu_opt_get(machine_opts, \"append\");\n    bios_name = qemu_opt_get(machine_opts, \"firmware\");\n\n    opts = qemu_opts_find(qemu_find_opts(\"boot-opts\"), NULL);\n    if (opts) {\n        boot_order = qemu_opt_get(opts, \"order\");\n        if (boot_order) {\n            validate_bootdevices(boot_order, &error_fatal);\n        }\n\n        boot_once = qemu_opt_get(opts, \"once\");\n        if (boot_once) {\n            validate_bootdevices(boot_once, &error_fatal);\n        }\n\n        boot_menu = qemu_opt_get_bool(opts, \"menu\", boot_menu);\n        boot_strict = qemu_opt_get_bool(opts, \"strict\", false);\n    }\n\n    if (!boot_order) {\n        boot_order = machine_class->default_boot_order;\n    }\n\n    if (!kernel_cmdline) {\n        kernel_cmdline = \"\";\n        current_machine->kernel_cmdline = (char *)kernel_cmdline;\n    }\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (!linux_boot && *kernel_cmdline != '\\0') {\n        error_report(\"-append only allowed with -kernel option\");\n        exit(1);\n    }\n\n    if (!linux_boot && initrd_filename != NULL) {\n        error_report(\"-initrd only allowed with -kernel option\");\n        exit(1);\n    }\n\n    if (semihosting_enabled() && !semihosting_get_argc() && kernel_filename) {\n        /* fall back to the -kernel/-append */\n        semihosting_arg_fallback(kernel_filename, kernel_cmdline);\n    }\n\n    os_set_line_buffering();\n\n    /* spice needs the timers to be initialized by this point */\n    qemu_spice_init();\n\n    cpu_ticks_init();\n    if (icount_opts) {\n        if (!tcg_enabled()) {\n            error_report(\"-icount is not allowed with hardware virtualization\");\n            exit(1);\n        }\n        configure_icount(icount_opts, &error_abort);\n        qemu_opts_del(icount_opts);\n    }\n\n    qemu_tcg_configure(accel_opts, &error_fatal);\n\n    if (default_net) {\n        QemuOptsList *net = qemu_find_opts(\"net\");\n        qemu_opts_set(net, NULL, \"type\", \"nic\", &error_abort);\n#ifdef CONFIG_SLIRP\n        qemu_opts_set(net, NULL, \"type\", \"user\", &error_abort);\n#endif\n    }\n\n    colo_info_init();\n\n    if (net_init_clients() < 0) {\n        exit(1);\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"object\"),\n                          user_creatable_add_opts_foreach,\n                          object_create_delayed, NULL)) {\n        exit(1);\n    }\n\n#ifdef CONFIG_TPM\n    if (tpm_init() < 0) {\n        exit(1);\n    }\n#endif\n\n    /* init the bluetooth world */\n    if (foreach_device_config(DEV_BT, bt_parse))\n        exit(1);\n\n    if (!xen_enabled()) {\n        /* On 32-bit hosts, QEMU is limited by virtual address space */\n        if (ram_size > (2047 << 20) && HOST_LONG_BITS == 32) {\n            error_report(\"at most 2047 MB RAM can be simulated\");\n            exit(1);\n        }\n    }\n\n    blk_mig_init();\n    ram_mig_init();\n\n    /* If the currently selected machine wishes to override the units-per-bus\n     * property of its default HBA interface type, do so now. */\n    if (machine_class->units_per_default_bus) {\n        override_max_devs(machine_class->block_default_type,\n                          machine_class->units_per_default_bus);\n    }\n\n    /* open the virtual block devices */\n    while (!QSIMPLEQ_EMPTY(&bdo_queue)) {\n        BlockdevOptions_queue *bdo = QSIMPLEQ_FIRST(&bdo_queue);\n\n        QSIMPLEQ_REMOVE_HEAD(&bdo_queue, entry);\n        loc_push_restore(&bdo->loc);\n        qmp_blockdev_add(bdo->bdo, &error_fatal);\n        loc_pop(&bdo->loc);\n        qapi_free_BlockdevOptions(bdo->bdo);\n        g_free(bdo);\n    }\n    if (snapshot || replay_mode != REPLAY_MODE_NONE) {\n        qemu_opts_foreach(qemu_find_opts(\"drive\"), drive_enable_snapshot,\n                          NULL, NULL);\n    }\n    if (qemu_opts_foreach(qemu_find_opts(\"drive\"), drive_init_func,\n                          &machine_class->block_default_type, NULL)) {\n        exit(1);\n    }\n\n    default_drive(default_cdrom, snapshot, machine_class->block_default_type, 2,\n                  CDROM_OPTS);\n    default_drive(default_floppy, snapshot, IF_FLOPPY, 0, FD_OPTS);\n    default_drive(default_sdcard, snapshot, IF_SD, 0, SD_OPTS);\n\n    parse_numa_opts(machine_class);\n\n    if (qemu_opts_foreach(qemu_find_opts(\"mon\"),\n                          mon_init_func, NULL, NULL)) {\n        exit(1);\n    }\n\n    if (foreach_device_config(DEV_SERIAL, serial_parse) < 0)\n        exit(1);\n    if (foreach_device_config(DEV_PARALLEL, parallel_parse) < 0)\n        exit(1);\n    if (foreach_device_config(DEV_VIRTCON, virtcon_parse) < 0)\n        exit(1);\n    if (foreach_device_config(DEV_SCLP, sclp_parse) < 0) {\n        exit(1);\n    }\n    if (foreach_device_config(DEV_DEBUGCON, debugcon_parse) < 0)\n        exit(1);\n\n    /* If no default VGA is requested, the default is \"none\".  */\n    if (default_vga) {\n        if (machine_class->default_display) {\n            vga_model = machine_class->default_display;\n        } else if (vga_interface_available(VGA_CIRRUS)) {\n            vga_model = \"cirrus\";\n        } else if (vga_interface_available(VGA_STD)) {\n            vga_model = \"std\";\n        }\n    }\n    if (vga_model) {\n        select_vgahw(vga_model);\n    }\n\n    if (watchdog) {\n        i = select_watchdog(watchdog);\n        if (i > 0)\n            exit (i == 1 ? 1 : 0);\n    }\n\n    machine_register_compat_props(current_machine);\n\n    qemu_opts_foreach(qemu_find_opts(\"global\"),\n                      global_init_func, NULL, NULL);\n\n    /* This checkpoint is required by replay to separate prior clock\n       reading from the other reads, because timer polling functions query\n       clock values from the log. */\n    replay_checkpoint(CHECKPOINT_INIT);\n    qdev_machine_init();\n\n    current_machine->ram_size = ram_size;\n    current_machine->maxram_size = maxram_size;\n    current_machine->ram_slots = ram_slots;\n    current_machine->boot_order = boot_order;\n    current_machine->cpu_model = cpu_model;\n\n    machine_class->init(current_machine);\n\n    realtime_init();\n\n    audio_init();\n\n    if (hax_enabled()) {\n        hax_sync_vcpus();\n    }\n\n    if (qemu_opts_foreach(qemu_find_opts(\"fw_cfg\"),\n                          parse_fw_cfg, fw_cfg_find(), NULL) != 0) {\n        exit(1);\n    }\n\n    /* init USB devices */\n    if (machine_usb(current_machine)) {\n        if (foreach_device_config(DEV_USB, usb_parse) < 0)\n            exit(1);\n    }\n\n    /* Check if IGD GFX passthrough. */\n    igd_gfx_passthru();\n\n    /* init generic devices */\n    rom_set_order_override(FW_CFG_ORDER_OVERRIDE_DEVICE);\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"),\n                          device_init_func, NULL, NULL)) {\n        exit(1);\n    }\n\n    cpu_synchronize_all_post_init();\n\n    numa_post_machine_init();\n\n    rom_reset_order_override();\n\n    /*\n     * Create frontends for -drive if=scsi leftovers.\n     * Normally, frontends for -drive get created by machine\n     * initialization for onboard SCSI HBAs.  However, we create a few\n     * more ever since SCSI qdevification, but this is pretty much an\n     * implementation accident, and deprecated.\n     */\n    scsi_legacy_handle_cmdline();\n\n    /* Did we create any drives that we failed to create a device for? */\n    drive_check_orphaned();\n\n    /* Don't warn about the default network setup that you get if\n     * no command line -net or -netdev options are specified. There\n     * are two cases that we would otherwise complain about:\n     * (1) board doesn't support a NIC but the implicit \"-net nic\"\n     * requested one\n     * (2) CONFIG_SLIRP not set, in which case the implicit \"-net nic\"\n     * sets up a nic that isn't connected to anything.\n     */\n    if (!default_net) {\n        net_check_clients();\n    }\n\n\n    if (boot_once) {\n        qemu_boot_set(boot_once, &error_fatal);\n        qemu_register_reset(restore_boot_order, g_strdup(boot_order));\n    }\n\n    ds = init_displaystate();\n\n    /* init local displays */\n    switch (display_type) {\n    case DT_CURSES:\n        curses_display_init(ds, full_screen);\n        break;\n    case DT_SDL:\n        sdl_display_init(ds, full_screen, no_frame);\n        break;\n    case DT_COCOA:\n        cocoa_display_init(ds, full_screen);\n        break;\n    case DT_GTK:\n        gtk_display_init(ds, full_screen, grab_on_hover);\n        break;\n    default:\n        break;\n    }\n\n    /* must be after terminal init, SDL library changes signal handlers */\n    os_setup_signal_handling();\n\n    /* init remote displays */\n#ifdef CONFIG_VNC\n    qemu_opts_foreach(qemu_find_opts(\"vnc\"),\n                      vnc_init_func, NULL, NULL);\n#endif\n\n    if (using_spice) {\n        qemu_spice_display_init();\n    }\n\n    if (foreach_device_config(DEV_GDB, gdbserver_start) < 0) {\n        exit(1);\n    }\n\n    qdev_machine_creation_done();\n\n    /* TODO: once all bus devices are qdevified, this should be done\n     * when bus is created by qdev.c */\n    qemu_register_reset(qbus_reset_all_fn, sysbus_get_default());\n    qemu_run_machine_init_done_notifiers();\n\n    if (rom_check_and_register_reset() != 0) {\n        error_report(\"rom check and register reset failed\");\n        exit(1);\n    }\n\n    replay_start();\n\n    /* This checkpoint is required by replay to separate prior clock\n       reading from the other reads, because timer polling functions query\n       clock values from the log. */\n    replay_checkpoint(CHECKPOINT_RESET);\n    qemu_system_reset(VMRESET_SILENT);\n    register_global_state();\n\n    if (replay_name) {\n        // rr: check for begin/end record/replay\n        sigset_t blockset, oldset = {0};\n\n        //block signals\n        sigprocmask(SIG_BLOCK, &blockset, &oldset);\n        if (0 != rr_do_begin_replay(replay_name, first_cpu)){\n            printf(\"Failed to start replay\\n\");\n            exit(1);\n        }\n        // ru: qemu_quit_timers() defined by PANDA team to stop timers\n        qemu_rr_quit_timers();\n\n        //unblock signals\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n    }\n\n    if (record_name) {\n        Error *err;\n        char snap_name[256];\n        char rec_name[256];\n        // None of QEMU's built-in parsers seem to be able to do something this simple\n        int s_i = 0;\n        int r_i = 0;\n        int full_i = 0;\n\n        while(record_name[full_i] != '\\0'){\n            if (':' == record_name[full_i]){\n                snap_name[s_i] = '\\0';\n                s_i = -1;\n                full_i++;\n                continue;\n            }\n            if (s_i < 0){\n                rec_name[r_i++] = record_name[full_i++];\n            } else {\n                snap_name[s_i++] = record_name[full_i++];\n            }\n            if (s_i >= 256 || r_i >= 256){\n                // BAIL BAIL BAIL\n                fprintf(stderr,\"snapshots and recordings must have names no longer than 256 characters\\n\");\n                exit(1);\n            }\n            rec_name[r_i] = '\\0';\n        }\n\n        if(*rec_name == '\\0'){\n            fprintf(stderr, \"missing record name, usage: -record-from <snapshot>:<record-name>\\n\");\n            exit(1);\n        }\n\n        qmp_begin_record_from(snap_name,rec_name, &err);\n    }\n\n    if (replay_mode != REPLAY_MODE_NONE) {\n        replay_vmstate_init();\n    } else if (loadvm) {\n        if (replay_name) {\n          fprintf(stderr, \"Ignoring request to loadvm since we're in replay mode\\n\");\n        } else if (load_vmstate(loadvm) < 0) {\n            autostart = 0;\n        }\n    }\n\n    qdev_prop_check_globals();\n    if (vmstate_dump_file) {\n        /* dump and exit */\n        dump_vmstate_json_to_file(vmstate_dump_file);\n        return 0;\n    }\n\n    if (incoming) {\n        Error *local_err = NULL;\n        qemu_start_incoming_migration(incoming, &local_err);\n        if (local_err) {\n            error_reportf_err(local_err, \"-incoming %s: \", incoming);\n            exit(1);\n        }\n    } else if (autostart) {\n        vm_start();\n    }\n\n    os_setup_post();\n\n    // Call PANDA post-machine init hook\n    panda_callbacks_after_machine_init(first_cpu);\n\n    if (pmm == PANDA_INIT) return 0;\n\nPANDA_MAIN_RUN:\n\n\n    panda_in_main_loop = 1;\n    main_loop();\n    panda_in_main_loop = 0;\n\n    if (pmm == PANDA_RUN) return 0;\n\nPANDA_MAIN_FINISH:\n\n    if(rr_in_record()){\n        rr_do_end_record();\n    }\n\n    int x;\n    for(x=0; x < gargc ; ++x )\n    {\n        free(gargv[x]);\n        gargv[x] = NULL;\n    }\n    free(gargv);\n\n    replay_disable_events();\n    iothread_stop_all();\n\n    panda_cleanup();\n\n    pause_all_vcpus();\n    bdrv_close_all();\n    res_free();\n\n    /* vhost-user must be cleaned up before chardevs.  */\n    net_cleanup();\n    audio_cleanup();\n    monitor_cleanup();\n    qemu_chr_cleanup();\n\n#ifdef CONFIG_LLVM\n    if (generate_llvm || execute_llvm){\n        tcg_llvm_cleanup();\n    }\n#endif\n\n    if (qemu_file != NULL){\n        free((void*)qemu_file);\n        qemu_file = NULL;\n    }\n\n\n    return panda_exit_code;\n}\n"
        },
        {
          "name": "vl.h",
          "type": "blob",
          "size": 0.4462890625,
          "content": "\n#ifndef __VL_H__\n#define __VL_H__\n\n#include <stdint.h>\n\ntypedef enum panda_main_mode {\n    PANDA_NORMAL,             // just run panda/qemu as normal\n    PANDA_INIT,               // initialize panda/qemu\n    PANDA_RUN,                // run the emulate machine\n    PANDA_FINISH}             // cleanup and exit\nPandaMainMode;\n\nvoid main_panda_run(void);\n\nvoid main_loop(void);\n\nint main_aux(int argc, char **argv, char **envp, PandaMainMode pmm);\n\n#endif\n"
        },
        {
          "name": "xen-common-stub.c",
          "type": "blob",
          "size": 0.318359375,
          "content": "/*\n * Copyright (C) 2014       Citrix Systems UK Ltd.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"hw/xen/xen.h\"\n\nvoid xenstore_store_pv_console_info(int i, Chardev *chr)\n{\n}\n"
        },
        {
          "name": "xen-common.c",
          "type": "blob",
          "size": 3.7685546875,
          "content": "/*\n * Copyright (C) 2014       Citrix Systems UK Ltd.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n#include \"hw/xen/xen_backend.h\"\n#include \"qmp-commands.h\"\n#include \"sysemu/char.h\"\n#include \"sysemu/accel.h\"\n#include \"migration/migration.h\"\n\n//#define DEBUG_XEN\n\n#ifdef DEBUG_XEN\n#define DPRINTF(fmt, ...) \\\n    do { fprintf(stderr, \"xen: \" fmt, ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) \\\n    do { } while (0)\n#endif\n\nstatic int store_dev_info(int domid, Chardev *cs, const char *string)\n{\n    struct xs_handle *xs = NULL;\n    char *path = NULL;\n    char *newpath = NULL;\n    char *pts = NULL;\n    int ret = -1;\n\n    /* Only continue if we're talking to a pty. */\n    if (strncmp(cs->filename, \"pty:\", 4)) {\n        return 0;\n    }\n    pts = cs->filename + 4;\n\n    /* We now have everything we need to set the xenstore entry. */\n    xs = xs_open(0);\n    if (xs == NULL) {\n        fprintf(stderr, \"Could not contact XenStore\\n\");\n        goto out;\n    }\n\n    path = xs_get_domain_path(xs, domid);\n    if (path == NULL) {\n        fprintf(stderr, \"xs_get_domain_path() error\\n\");\n        goto out;\n    }\n    newpath = realloc(path, (strlen(path) + strlen(string) +\n                strlen(\"/tty\") + 1));\n    if (newpath == NULL) {\n        fprintf(stderr, \"realloc error\\n\");\n        goto out;\n    }\n    path = newpath;\n\n    strcat(path, string);\n    strcat(path, \"/tty\");\n    if (!xs_write(xs, XBT_NULL, path, pts, strlen(pts))) {\n        fprintf(stderr, \"xs_write for '%s' fail\", string);\n        goto out;\n    }\n    ret = 0;\n\nout:\n    free(path);\n    xs_close(xs);\n\n    return ret;\n}\n\nvoid xenstore_store_pv_console_info(int i, Chardev *chr)\n{\n    if (i == 0) {\n        store_dev_info(xen_domid, chr, \"/console\");\n    } else {\n        char buf[32];\n        snprintf(buf, sizeof(buf), \"/device/console/%d\", i);\n        store_dev_info(xen_domid, chr, buf);\n    }\n}\n\n\nstatic void xenstore_record_dm_state(struct xs_handle *xs, const char *state)\n{\n    char path[50];\n\n    if (xs == NULL) {\n        fprintf(stderr, \"xenstore connection not initialized\\n\");\n        exit(1);\n    }\n\n    snprintf(path, sizeof (path), \"device-model/%u/state\", xen_domid);\n    if (!xs_write(xs, XBT_NULL, path, state, strlen(state))) {\n        fprintf(stderr, \"error recording dm state\\n\");\n        exit(1);\n    }\n}\n\n\nstatic void xen_change_state_handler(void *opaque, int running,\n                                     RunState state)\n{\n    if (running) {\n        /* record state running */\n        xenstore_record_dm_state(xenstore, \"running\");\n    }\n}\n\nstatic int xen_init(MachineState *ms)\n{\n    xen_xc = xc_interface_open(0, 0, 0);\n    if (xen_xc == NULL) {\n        xen_pv_printf(NULL, 0, \"can't open xen interface\\n\");\n        return -1;\n    }\n    xen_fmem = xenforeignmemory_open(0, 0);\n    if (xen_fmem == NULL) {\n        xen_pv_printf(NULL, 0, \"can't open xen fmem interface\\n\");\n        xc_interface_close(xen_xc);\n        return -1;\n    }\n    qemu_add_vm_change_state_handler(xen_change_state_handler, NULL);\n\n    global_state_set_optional();\n    savevm_skip_configuration();\n    savevm_skip_section_footers();\n\n    return 0;\n}\n\nstatic void xen_accel_class_init(ObjectClass *oc, void *data)\n{\n    AccelClass *ac = ACCEL_CLASS(oc);\n    ac->name = \"Xen\";\n    ac->init_machine = xen_init;\n    ac->allowed = &xen_allowed;\n}\n\n#define TYPE_XEN_ACCEL ACCEL_CLASS_NAME(\"xen\")\n\nstatic const TypeInfo xen_accel_type = {\n    .name = TYPE_XEN_ACCEL,\n    .parent = TYPE_ACCEL,\n    .class_init = xen_accel_class_init,\n};\n\nstatic void xen_type_init(void)\n{\n    type_register_static(&xen_accel_type);\n}\n\ntype_init(xen_type_init);\n"
        },
        {
          "name": "xen-hvm-stub.c",
          "type": "blob",
          "size": 1.1865234375,
          "content": "/*\n * Copyright (C) 2010       Citrix Ltd.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu-common.h\"\n#include \"hw/xen/xen.h\"\n#include \"exec/memory.h\"\n#include \"qmp-commands.h\"\n\nint xen_pci_slot_get_pirq(PCIDevice *pci_dev, int irq_num)\n{\n    return -1;\n}\n\nvoid xen_piix3_set_irq(void *opaque, int irq_num, int level)\n{\n}\n\nvoid xen_piix_pci_write_config_client(uint32_t address, uint32_t val, int len)\n{\n}\n\nvoid xen_hvm_inject_msi(uint64_t addr, uint32_t data)\n{\n}\n\nint xen_is_pirq_msi(uint32_t msi_data)\n{\n    return 0;\n}\n\nvoid xen_ram_alloc(ram_addr_t ram_addr, ram_addr_t size, MemoryRegion *mr,\n                   Error **errp)\n{\n}\n\nqemu_irq *xen_interrupt_controller_init(void)\n{\n    return NULL;\n}\n\nvoid xen_register_framebuffer(MemoryRegion *mr)\n{\n}\n\nvoid xen_modified_memory(ram_addr_t start, ram_addr_t length)\n{\n}\n\nvoid xen_hvm_init(PCMachineState *pcms, MemoryRegion **ram_memory)\n{\n}\n\nvoid qmp_xen_set_global_dirty_log(bool enable, Error **errp)\n{\n}\n"
        },
        {
          "name": "xen-hvm.c",
          "type": "blob",
          "size": 42.1728515625,
          "content": "/*\n * Copyright (C) 2010       Citrix Ltd.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n\n#include \"cpu.h\"\n#include \"hw/pci/pci.h\"\n#include \"hw/i386/pc.h\"\n#include \"hw/i386/apic-msidef.h\"\n#include \"hw/xen/xen_common.h\"\n#include \"hw/xen/xen_backend.h\"\n#include \"qmp-commands.h\"\n\n#include \"sysemu/char.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/range.h\"\n#include \"sysemu/xen-mapcache.h\"\n#include \"trace-root.h\"\n#include \"exec/address-spaces.h\"\n\n#include <xen/hvm/ioreq.h>\n#include <xen/hvm/params.h>\n#include <xen/hvm/e820.h>\n\n//#define DEBUG_XEN_HVM\n\n#ifdef DEBUG_XEN_HVM\n#define DPRINTF(fmt, ...) \\\n    do { fprintf(stderr, \"xen: \" fmt, ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) \\\n    do { } while (0)\n#endif\n\nstatic MemoryRegion ram_memory, ram_640k, ram_lo, ram_hi;\nstatic MemoryRegion *framebuffer;\nstatic bool xen_in_migration;\n\n/* Compatibility with older version */\n\n/* This allows QEMU to build on a system that has Xen 4.5 or earlier\n * installed.  This here (not in hw/xen/xen_common.h) because xen/hvm/ioreq.h\n * needs to be included before this block and hw/xen/xen_common.h needs to\n * be included before xen/hvm/ioreq.h\n */\n#ifndef IOREQ_TYPE_VMWARE_PORT\n#define IOREQ_TYPE_VMWARE_PORT  3\nstruct vmware_regs {\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebx;\n    uint32_t ecx;\n    uint32_t edx;\n};\ntypedef struct vmware_regs vmware_regs_t;\n\nstruct shared_vmport_iopage {\n    struct vmware_regs vcpu_vmport_regs[1];\n};\ntypedef struct shared_vmport_iopage shared_vmport_iopage_t;\n#endif\n\nstatic inline uint32_t xen_vcpu_eport(shared_iopage_t *shared_page, int i)\n{\n    return shared_page->vcpu_ioreq[i].vp_eport;\n}\nstatic inline ioreq_t *xen_vcpu_ioreq(shared_iopage_t *shared_page, int vcpu)\n{\n    return &shared_page->vcpu_ioreq[vcpu];\n}\n\n#define BUFFER_IO_MAX_DELAY  100\n\ntypedef struct XenPhysmap {\n    hwaddr start_addr;\n    ram_addr_t size;\n    const char *name;\n    hwaddr phys_offset;\n\n    QLIST_ENTRY(XenPhysmap) list;\n} XenPhysmap;\n\ntypedef struct XenIOState {\n    ioservid_t ioservid;\n    shared_iopage_t *shared_page;\n    shared_vmport_iopage_t *shared_vmport_page;\n    buffered_iopage_t *buffered_io_page;\n    QEMUTimer *buffered_io_timer;\n    CPUState **cpu_by_vcpu_id;\n    /* the evtchn port for polling the notification, */\n    evtchn_port_t *ioreq_local_port;\n    /* evtchn local port for buffered io */\n    evtchn_port_t bufioreq_local_port;\n    /* the evtchn fd for polling */\n    xenevtchn_handle *xce_handle;\n    /* which vcpu we are serving */\n    int send_vcpu;\n\n    struct xs_handle *xenstore;\n    MemoryListener memory_listener;\n    MemoryListener io_listener;\n    DeviceListener device_listener;\n    QLIST_HEAD(, XenPhysmap) physmap;\n    hwaddr free_phys_offset;\n    const XenPhysmap *log_for_dirtybit;\n\n    Notifier exit;\n    Notifier suspend;\n    Notifier wakeup;\n} XenIOState;\n\n/* Xen specific function for piix pci */\n\nint xen_pci_slot_get_pirq(PCIDevice *pci_dev, int irq_num)\n{\n    return irq_num + ((pci_dev->devfn >> 3) << 2);\n}\n\nvoid xen_piix3_set_irq(void *opaque, int irq_num, int level)\n{\n    xc_hvm_set_pci_intx_level(xen_xc, xen_domid, 0, 0, irq_num >> 2,\n                              irq_num & 3, level);\n}\n\nvoid xen_piix_pci_write_config_client(uint32_t address, uint32_t val, int len)\n{\n    int i;\n\n    /* Scan for updates to PCI link routes (0x60-0x63). */\n    for (i = 0; i < len; i++) {\n        uint8_t v = (val >> (8 * i)) & 0xff;\n        if (v & 0x80) {\n            v = 0;\n        }\n        v &= 0xf;\n        if (((address + i) >= 0x60) && ((address + i) <= 0x63)) {\n            xc_hvm_set_pci_link_route(xen_xc, xen_domid, address + i - 0x60, v);\n        }\n    }\n}\n\nint xen_is_pirq_msi(uint32_t msi_data)\n{\n    /* If vector is 0, the msi is remapped into a pirq, passed as\n     * dest_id.\n     */\n    return ((msi_data & MSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT) == 0;\n}\n\nvoid xen_hvm_inject_msi(uint64_t addr, uint32_t data)\n{\n    xc_hvm_inject_msi(xen_xc, xen_domid, addr, data);\n}\n\nstatic void xen_suspend_notifier(Notifier *notifier, void *data)\n{\n    xc_set_hvm_param(xen_xc, xen_domid, HVM_PARAM_ACPI_S_STATE, 3);\n}\n\n/* Xen Interrupt Controller */\n\nstatic void xen_set_irq(void *opaque, int irq, int level)\n{\n    xc_hvm_set_isa_irq_level(xen_xc, xen_domid, irq, level);\n}\n\nqemu_irq *xen_interrupt_controller_init(void)\n{\n    return qemu_allocate_irqs(xen_set_irq, NULL, 16);\n}\n\n/* Memory Ops */\n\nstatic void xen_ram_init(PCMachineState *pcms,\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n{\n    MemoryRegion *sysmem = get_system_memory();\n    ram_addr_t block_len;\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n                                                   &error_abort);\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n     * min(xen limit, user limit).\n     */\n    if (!user_lowmem) {\n        user_lowmem = HVM_BELOW_4G_RAM_END; /* default */\n    }\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n    }\n\n    if (ram_size >= user_lowmem) {\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n        pcms->below_4g_mem_size = user_lowmem;\n    } else {\n        pcms->above_4g_mem_size = 0;\n        pcms->below_4g_mem_size = ram_size;\n    }\n    if (!pcms->above_4g_mem_size) {\n        block_len = ram_size;\n    } else {\n        /*\n         * Xen does not allocate the memory continuously, it keeps a\n         * hole of the size computed above or passed in.\n         */\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n    }\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n                           &error_fatal);\n    *ram_memory_p = &ram_memory;\n    vmstate_register_ram_global(&ram_memory);\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n                             &ram_memory, 0, 0xa0000);\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n     * emulated device.\n     *\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n     * the Options ROM, so it is registered here as RAM.\n     */\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n                             &ram_memory, 0xc0000,\n                             pcms->below_4g_mem_size - 0xc0000);\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n    if (pcms->above_4g_mem_size > 0) {\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n                                 &ram_memory, 0x100000000ULL,\n                                 pcms->above_4g_mem_size);\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n    }\n}\n\nvoid xen_ram_alloc(ram_addr_t ram_addr, ram_addr_t size, MemoryRegion *mr,\n                   Error **errp)\n{\n    unsigned long nr_pfn;\n    xen_pfn_t *pfn_list;\n    int i;\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        /* RAM already populated in Xen */\n        fprintf(stderr, \"%s: do not alloc \"RAM_ADDR_FMT\n                \" bytes of ram at \"RAM_ADDR_FMT\" when runstate is INMIGRATE\\n\",\n                __func__, size, ram_addr); \n        return;\n    }\n\n    if (mr == &ram_memory) {\n        return;\n    }\n\n    trace_xen_ram_alloc(ram_addr, size);\n\n    nr_pfn = size >> TARGET_PAGE_BITS;\n    pfn_list = g_malloc(sizeof (*pfn_list) * nr_pfn);\n\n    for (i = 0; i < nr_pfn; i++) {\n        pfn_list[i] = (ram_addr >> TARGET_PAGE_BITS) + i;\n    }\n\n    if (xc_domain_populate_physmap_exact(xen_xc, xen_domid, nr_pfn, 0, 0, pfn_list)) {\n        error_setg(errp, \"xen: failed to populate ram at \" RAM_ADDR_FMT,\n                   ram_addr);\n    }\n\n    g_free(pfn_list);\n}\n\nstatic XenPhysmap *get_physmapping(XenIOState *state,\n                                   hwaddr start_addr, ram_addr_t size)\n{\n    XenPhysmap *physmap = NULL;\n\n    start_addr &= TARGET_PAGE_MASK;\n\n    QLIST_FOREACH(physmap, &state->physmap, list) {\n        if (range_covers_byte(physmap->start_addr, physmap->size, start_addr)) {\n            return physmap;\n        }\n    }\n    return NULL;\n}\n\nstatic hwaddr xen_phys_offset_to_gaddr(hwaddr start_addr,\n                                                   ram_addr_t size, void *opaque)\n{\n    hwaddr addr = start_addr & TARGET_PAGE_MASK;\n    XenIOState *xen_io_state = opaque;\n    XenPhysmap *physmap = NULL;\n\n    QLIST_FOREACH(physmap, &xen_io_state->physmap, list) {\n        if (range_covers_byte(physmap->phys_offset, physmap->size, addr)) {\n            return physmap->start_addr;\n        }\n    }\n\n    return start_addr;\n}\n\nstatic int xen_add_to_physmap(XenIOState *state,\n                              hwaddr start_addr,\n                              ram_addr_t size,\n                              MemoryRegion *mr,\n                              hwaddr offset_within_region)\n{\n    unsigned long i = 0;\n    int rc = 0;\n    XenPhysmap *physmap = NULL;\n    hwaddr pfn, start_gpfn;\n    hwaddr phys_offset = memory_region_get_ram_addr(mr);\n    char path[80], value[17];\n    const char *mr_name;\n\n    if (get_physmapping(state, start_addr, size)) {\n        return 0;\n    }\n    if (size <= 0) {\n        return -1;\n    }\n\n    /* Xen can only handle a single dirty log region for now and we want\n     * the linear framebuffer to be that region.\n     * Avoid tracking any regions that is not videoram and avoid tracking\n     * the legacy vga region. */\n    if (mr == framebuffer && start_addr > 0xbffff) {\n        goto go_physmap;\n    }\n    return -1;\n\ngo_physmap:\n    DPRINTF(\"mapping vram to %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\"\\n\",\n            start_addr, start_addr + size);\n\n    pfn = phys_offset >> TARGET_PAGE_BITS;\n    start_gpfn = start_addr >> TARGET_PAGE_BITS;\n    for (i = 0; i < size >> TARGET_PAGE_BITS; i++) {\n        unsigned long idx = pfn + i;\n        xen_pfn_t gpfn = start_gpfn + i;\n\n        rc = xen_xc_domain_add_to_physmap(xen_xc, xen_domid, XENMAPSPACE_gmfn, idx, gpfn);\n        if (rc) {\n            DPRINTF(\"add_to_physmap MFN %\"PRI_xen_pfn\" to PFN %\"\n                    PRI_xen_pfn\" failed: %d (errno: %d)\\n\", idx, gpfn, rc, errno);\n            return -rc;\n        }\n    }\n\n    mr_name = memory_region_name(mr);\n\n    physmap = g_malloc(sizeof (XenPhysmap));\n\n    physmap->start_addr = start_addr;\n    physmap->size = size;\n    physmap->name = mr_name;\n    physmap->phys_offset = phys_offset;\n\n    QLIST_INSERT_HEAD(&state->physmap, physmap, list);\n\n    xc_domain_pin_memory_cacheattr(xen_xc, xen_domid,\n                                   start_addr >> TARGET_PAGE_BITS,\n                                   (start_addr + size - 1) >> TARGET_PAGE_BITS,\n                                   XEN_DOMCTL_MEM_CACHEATTR_WB);\n\n    snprintf(path, sizeof(path),\n            \"/local/domain/0/device-model/%d/physmap/%\"PRIx64\"/start_addr\",\n            xen_domid, (uint64_t)phys_offset);\n    snprintf(value, sizeof(value), \"%\"PRIx64, (uint64_t)start_addr);\n    if (!xs_write(state->xenstore, 0, path, value, strlen(value))) {\n        return -1;\n    }\n    snprintf(path, sizeof(path),\n            \"/local/domain/0/device-model/%d/physmap/%\"PRIx64\"/size\",\n            xen_domid, (uint64_t)phys_offset);\n    snprintf(value, sizeof(value), \"%\"PRIx64, (uint64_t)size);\n    if (!xs_write(state->xenstore, 0, path, value, strlen(value))) {\n        return -1;\n    }\n    if (mr_name) {\n        snprintf(path, sizeof(path),\n                \"/local/domain/0/device-model/%d/physmap/%\"PRIx64\"/name\",\n                xen_domid, (uint64_t)phys_offset);\n        if (!xs_write(state->xenstore, 0, path, mr_name, strlen(mr_name))) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nstatic int xen_remove_from_physmap(XenIOState *state,\n                                   hwaddr start_addr,\n                                   ram_addr_t size)\n{\n    unsigned long i = 0;\n    int rc = 0;\n    XenPhysmap *physmap = NULL;\n    hwaddr phys_offset = 0;\n\n    physmap = get_physmapping(state, start_addr, size);\n    if (physmap == NULL) {\n        return -1;\n    }\n\n    phys_offset = physmap->phys_offset;\n    size = physmap->size;\n\n    DPRINTF(\"unmapping vram to %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\", at \"\n            \"%\"HWADDR_PRIx\"\\n\", start_addr, start_addr + size, phys_offset);\n\n    size >>= TARGET_PAGE_BITS;\n    start_addr >>= TARGET_PAGE_BITS;\n    phys_offset >>= TARGET_PAGE_BITS;\n    for (i = 0; i < size; i++) {\n        xen_pfn_t idx = start_addr + i;\n        xen_pfn_t gpfn = phys_offset + i;\n\n        rc = xen_xc_domain_add_to_physmap(xen_xc, xen_domid, XENMAPSPACE_gmfn, idx, gpfn);\n        if (rc) {\n            fprintf(stderr, \"add_to_physmap MFN %\"PRI_xen_pfn\" to PFN %\"\n                    PRI_xen_pfn\" failed: %d (errno: %d)\\n\", idx, gpfn, rc, errno);\n            return -rc;\n        }\n    }\n\n    QLIST_REMOVE(physmap, list);\n    if (state->log_for_dirtybit == physmap) {\n        state->log_for_dirtybit = NULL;\n    }\n    g_free(physmap);\n\n    return 0;\n}\n\nstatic void xen_set_memory(struct MemoryListener *listener,\n                           MemoryRegionSection *section,\n                           bool add)\n{\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n    hwaddr start_addr = section->offset_within_address_space;\n    ram_addr_t size = int128_get64(section->size);\n    bool log_dirty = memory_region_is_logging(section->mr, DIRTY_MEMORY_VGA);\n    hvmmem_type_t mem_type;\n\n    if (section->mr == &ram_memory) {\n        return;\n    } else {\n        if (add) {\n            xen_map_memory_section(xen_xc, xen_domid, state->ioservid,\n                                   section);\n        } else {\n            xen_unmap_memory_section(xen_xc, xen_domid, state->ioservid,\n                                     section);\n        }\n    }\n\n    if (!memory_region_is_ram(section->mr)) {\n        return;\n    }\n\n    if (log_dirty != add) {\n        return;\n    }\n\n    trace_xen_client_set_memory(start_addr, size, log_dirty);\n\n    start_addr &= TARGET_PAGE_MASK;\n    size = TARGET_PAGE_ALIGN(size);\n\n    if (add) {\n        if (!memory_region_is_rom(section->mr)) {\n            xen_add_to_physmap(state, start_addr, size,\n                               section->mr, section->offset_within_region);\n        } else {\n            mem_type = HVMMEM_ram_ro;\n            if (xc_hvm_set_mem_type(xen_xc, xen_domid, mem_type,\n                                    start_addr >> TARGET_PAGE_BITS,\n                                    size >> TARGET_PAGE_BITS)) {\n                DPRINTF(\"xc_hvm_set_mem_type error, addr: \"TARGET_FMT_plx\"\\n\",\n                        start_addr);\n            }\n        }\n    } else {\n        if (xen_remove_from_physmap(state, start_addr, size) < 0) {\n            DPRINTF(\"physmapping does not exist at \"TARGET_FMT_plx\"\\n\", start_addr);\n        }\n    }\n}\n\nstatic void xen_region_add(MemoryListener *listener,\n                           MemoryRegionSection *section)\n{\n    memory_region_ref(section->mr);\n    xen_set_memory(listener, section, true);\n}\n\nstatic void xen_region_del(MemoryListener *listener,\n                           MemoryRegionSection *section)\n{\n    xen_set_memory(listener, section, false);\n    memory_region_unref(section->mr);\n}\n\nstatic void xen_io_add(MemoryListener *listener,\n                       MemoryRegionSection *section)\n{\n    XenIOState *state = container_of(listener, XenIOState, io_listener);\n    MemoryRegion *mr = section->mr;\n\n    if (mr->ops == &unassigned_io_ops) {\n        return;\n    }\n\n    memory_region_ref(mr);\n\n    xen_map_io_section(xen_xc, xen_domid, state->ioservid, section);\n}\n\nstatic void xen_io_del(MemoryListener *listener,\n                       MemoryRegionSection *section)\n{\n    XenIOState *state = container_of(listener, XenIOState, io_listener);\n    MemoryRegion *mr = section->mr;\n\n    if (mr->ops == &unassigned_io_ops) {\n        return;\n    }\n\n    xen_unmap_io_section(xen_xc, xen_domid, state->ioservid, section);\n\n    memory_region_unref(mr);\n}\n\nstatic void xen_device_realize(DeviceListener *listener,\n\t\t\t       DeviceState *dev)\n{\n    XenIOState *state = container_of(listener, XenIOState, device_listener);\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n        PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n        xen_map_pcidev(xen_xc, xen_domid, state->ioservid, pci_dev);\n    }\n}\n\nstatic void xen_device_unrealize(DeviceListener *listener,\n\t\t\t\t DeviceState *dev)\n{\n    XenIOState *state = container_of(listener, XenIOState, device_listener);\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n        PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n        xen_unmap_pcidev(xen_xc, xen_domid, state->ioservid, pci_dev);\n    }\n}\n\nstatic void xen_sync_dirty_bitmap(XenIOState *state,\n                                  hwaddr start_addr,\n                                  ram_addr_t size)\n{\n    hwaddr npages = size >> TARGET_PAGE_BITS;\n    const int width = sizeof(unsigned long) * 8;\n    unsigned long bitmap[DIV_ROUND_UP(npages, width)];\n    int rc, i, j;\n    const XenPhysmap *physmap = NULL;\n\n    physmap = get_physmapping(state, start_addr, size);\n    if (physmap == NULL) {\n        /* not handled */\n        return;\n    }\n\n    if (state->log_for_dirtybit == NULL) {\n        state->log_for_dirtybit = physmap;\n    } else if (state->log_for_dirtybit != physmap) {\n        /* Only one range for dirty bitmap can be tracked. */\n        return;\n    }\n\n    rc = xc_hvm_track_dirty_vram(xen_xc, xen_domid,\n                                 start_addr >> TARGET_PAGE_BITS, npages,\n                                 bitmap);\n    if (rc < 0) {\n#ifndef ENODATA\n#define ENODATA  ENOENT\n#endif\n        if (errno == ENODATA) {\n            memory_region_set_dirty(framebuffer, 0, size);\n            DPRINTF(\"xen: track_dirty_vram failed (0x\" TARGET_FMT_plx\n                    \", 0x\" TARGET_FMT_plx \"): %s\\n\",\n                    start_addr, start_addr + size, strerror(errno));\n        }\n        return;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(bitmap); i++) {\n        unsigned long map = bitmap[i];\n        while (map != 0) {\n            j = ctzl(map);\n            map &= ~(1ul << j);\n            memory_region_set_dirty(framebuffer,\n                                    (i * width + j) * TARGET_PAGE_SIZE,\n                                    TARGET_PAGE_SIZE);\n        };\n    }\n}\n\nstatic void xen_log_start(MemoryListener *listener,\n                          MemoryRegionSection *section,\n                          int old, int new)\n{\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n    if (new & ~old & (1 << DIRTY_MEMORY_VGA)) {\n        xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n                              int128_get64(section->size));\n    }\n}\n\nstatic void xen_log_stop(MemoryListener *listener, MemoryRegionSection *section,\n                         int old, int new)\n{\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n    if (old & ~new & (1 << DIRTY_MEMORY_VGA)) {\n        state->log_for_dirtybit = NULL;\n        /* Disable dirty bit tracking */\n        xc_hvm_track_dirty_vram(xen_xc, xen_domid, 0, 0, NULL);\n    }\n}\n\nstatic void xen_log_sync(MemoryListener *listener, MemoryRegionSection *section)\n{\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n                          int128_get64(section->size));\n}\n\nstatic void xen_log_global_start(MemoryListener *listener)\n{\n    if (xen_enabled()) {\n        xen_in_migration = true;\n    }\n}\n\nstatic void xen_log_global_stop(MemoryListener *listener)\n{\n    xen_in_migration = false;\n}\n\nstatic MemoryListener xen_memory_listener = {\n    .region_add = xen_region_add,\n    .region_del = xen_region_del,\n    .log_start = xen_log_start,\n    .log_stop = xen_log_stop,\n    .log_sync = xen_log_sync,\n    .log_global_start = xen_log_global_start,\n    .log_global_stop = xen_log_global_stop,\n    .priority = 10,\n};\n\nstatic MemoryListener xen_io_listener = {\n    .region_add = xen_io_add,\n    .region_del = xen_io_del,\n    .priority = 10,\n};\n\nstatic DeviceListener xen_device_listener = {\n    .realize = xen_device_realize,\n    .unrealize = xen_device_unrealize,\n};\n\n/* get the ioreq packets from share mem */\nstatic ioreq_t *cpu_get_ioreq_from_shared_memory(XenIOState *state, int vcpu)\n{\n    ioreq_t *req = xen_vcpu_ioreq(state->shared_page, vcpu);\n\n    if (req->state != STATE_IOREQ_READY) {\n        DPRINTF(\"I/O request not ready: \"\n                \"%x, ptr: %x, port: %\"PRIx64\", \"\n                \"data: %\"PRIx64\", count: %u, size: %u\\n\",\n                req->state, req->data_is_ptr, req->addr,\n                req->data, req->count, req->size);\n        return NULL;\n    }\n\n    xen_rmb(); /* see IOREQ_READY /then/ read contents of ioreq */\n\n    req->state = STATE_IOREQ_INPROCESS;\n    return req;\n}\n\n/* use poll to get the port notification */\n/* ioreq_vec--out,the */\n/* retval--the number of ioreq packet */\nstatic ioreq_t *cpu_get_ioreq(XenIOState *state)\n{\n    int i;\n    evtchn_port_t port;\n\n    port = xenevtchn_pending(state->xce_handle);\n    if (port == state->bufioreq_local_port) {\n        timer_mod(state->buffered_io_timer,\n                BUFFER_IO_MAX_DELAY + qemu_clock_get_ms(QEMU_CLOCK_REALTIME));\n        return NULL;\n    }\n\n    if (port != -1) {\n        for (i = 0; i < max_cpus; i++) {\n            if (state->ioreq_local_port[i] == port) {\n                break;\n            }\n        }\n\n        if (i == max_cpus) {\n            hw_error(\"Fatal error while trying to get io event!\\n\");\n        }\n\n        /* unmask the wanted port again */\n        xenevtchn_unmask(state->xce_handle, port);\n\n        /* get the io packet from shared memory */\n        state->send_vcpu = i;\n        return cpu_get_ioreq_from_shared_memory(state, i);\n    }\n\n    /* read error or read nothing */\n    return NULL;\n}\n\nstatic uint32_t do_inp(uint32_t addr, unsigned long size)\n{\n    switch (size) {\n        case 1:\n            return cpu_inb(addr);\n        case 2:\n            return cpu_inw(addr);\n        case 4:\n            return cpu_inl(addr);\n        default:\n            hw_error(\"inp: bad size: %04x %lx\", addr, size);\n    }\n}\n\nstatic void do_outp(uint32_t addr,\n        unsigned long size, uint32_t val)\n{\n    switch (size) {\n        case 1:\n            return cpu_outb(addr, val);\n        case 2:\n            return cpu_outw(addr, val);\n        case 4:\n            return cpu_outl(addr, val);\n        default:\n            hw_error(\"outp: bad size: %04x %lx\", addr, size);\n    }\n}\n\n/*\n * Helper functions which read/write an object from/to physical guest\n * memory, as part of the implementation of an ioreq.\n *\n * Equivalent to\n *   cpu_physical_memory_rw(addr + (req->df ? -1 : +1) * req->size * i,\n *                          val, req->size, 0/1)\n * except without the integer overflow problems.\n */\nstatic void rw_phys_req_item(hwaddr addr,\n                             ioreq_t *req, uint32_t i, void *val, int rw)\n{\n    /* Do everything unsigned so overflow just results in a truncated result\n     * and accesses to undesired parts of guest memory, which is up\n     * to the guest */\n    hwaddr offset = (hwaddr)req->size * i;\n    if (req->df) {\n        addr -= offset;\n    } else {\n        addr += offset;\n    }\n    cpu_physical_memory_rw(addr, val, req->size, rw);\n}\n\nstatic inline void read_phys_req_item(hwaddr addr,\n                                      ioreq_t *req, uint32_t i, void *val)\n{\n    rw_phys_req_item(addr, req, i, val, 0);\n}\nstatic inline void write_phys_req_item(hwaddr addr,\n                                       ioreq_t *req, uint32_t i, void *val)\n{\n    rw_phys_req_item(addr, req, i, val, 1);\n}\n\n\nstatic void cpu_ioreq_pio(ioreq_t *req)\n{\n    uint32_t i;\n\n    trace_cpu_ioreq_pio(req, req->dir, req->df, req->data_is_ptr, req->addr,\n                         req->data, req->count, req->size);\n\n    if (req->size > sizeof(uint32_t)) {\n        hw_error(\"PIO: bad size (%u)\", req->size);\n    }\n\n    if (req->dir == IOREQ_READ) {\n        if (!req->data_is_ptr) {\n            req->data = do_inp(req->addr, req->size);\n            trace_cpu_ioreq_pio_read_reg(req, req->data, req->addr,\n                                         req->size);\n        } else {\n            uint32_t tmp;\n\n            for (i = 0; i < req->count; i++) {\n                tmp = do_inp(req->addr, req->size);\n                write_phys_req_item(req->data, req, i, &tmp);\n            }\n        }\n    } else if (req->dir == IOREQ_WRITE) {\n        if (!req->data_is_ptr) {\n            trace_cpu_ioreq_pio_write_reg(req, req->data, req->addr,\n                                          req->size);\n            do_outp(req->addr, req->size, req->data);\n        } else {\n            for (i = 0; i < req->count; i++) {\n                uint32_t tmp = 0;\n\n                read_phys_req_item(req->data, req, i, &tmp);\n                do_outp(req->addr, req->size, tmp);\n            }\n        }\n    }\n}\n\nstatic void cpu_ioreq_move(ioreq_t *req)\n{\n    uint32_t i;\n\n    trace_cpu_ioreq_move(req, req->dir, req->df, req->data_is_ptr, req->addr,\n                         req->data, req->count, req->size);\n\n    if (req->size > sizeof(req->data)) {\n        hw_error(\"MMIO: bad size (%u)\", req->size);\n    }\n\n    if (!req->data_is_ptr) {\n        if (req->dir == IOREQ_READ) {\n            for (i = 0; i < req->count; i++) {\n                read_phys_req_item(req->addr, req, i, &req->data);\n            }\n        } else if (req->dir == IOREQ_WRITE) {\n            for (i = 0; i < req->count; i++) {\n                write_phys_req_item(req->addr, req, i, &req->data);\n            }\n        }\n    } else {\n        uint64_t tmp;\n\n        if (req->dir == IOREQ_READ) {\n            for (i = 0; i < req->count; i++) {\n                read_phys_req_item(req->addr, req, i, &tmp);\n                write_phys_req_item(req->data, req, i, &tmp);\n            }\n        } else if (req->dir == IOREQ_WRITE) {\n            for (i = 0; i < req->count; i++) {\n                read_phys_req_item(req->data, req, i, &tmp);\n                write_phys_req_item(req->addr, req, i, &tmp);\n            }\n        }\n    }\n}\n\nstatic void regs_to_cpu(vmware_regs_t *vmport_regs, ioreq_t *req)\n{\n    X86CPU *cpu;\n    CPUX86State *env;\n\n    cpu = X86_CPU(current_cpu);\n    env = &cpu->env;\n    env->regs[R_EAX] = req->data;\n    env->regs[R_EBX] = vmport_regs->ebx;\n    env->regs[R_ECX] = vmport_regs->ecx;\n    env->regs[R_EDX] = vmport_regs->edx;\n    env->regs[R_ESI] = vmport_regs->esi;\n    env->regs[R_EDI] = vmport_regs->edi;\n}\n\nstatic void regs_from_cpu(vmware_regs_t *vmport_regs)\n{\n    X86CPU *cpu = X86_CPU(current_cpu);\n    CPUX86State *env = &cpu->env;\n\n    vmport_regs->ebx = env->regs[R_EBX];\n    vmport_regs->ecx = env->regs[R_ECX];\n    vmport_regs->edx = env->regs[R_EDX];\n    vmport_regs->esi = env->regs[R_ESI];\n    vmport_regs->edi = env->regs[R_EDI];\n}\n\nstatic void handle_vmport_ioreq(XenIOState *state, ioreq_t *req)\n{\n    vmware_regs_t *vmport_regs;\n\n    assert(state->shared_vmport_page);\n    vmport_regs =\n        &state->shared_vmport_page->vcpu_vmport_regs[state->send_vcpu];\n    QEMU_BUILD_BUG_ON(sizeof(*req) < sizeof(*vmport_regs));\n\n    current_cpu = state->cpu_by_vcpu_id[state->send_vcpu];\n    regs_to_cpu(vmport_regs, req);\n    cpu_ioreq_pio(req);\n    regs_from_cpu(vmport_regs);\n    current_cpu = NULL;\n}\n\nstatic void handle_ioreq(XenIOState *state, ioreq_t *req)\n{\n    trace_handle_ioreq(req, req->type, req->dir, req->df, req->data_is_ptr,\n                       req->addr, req->data, req->count, req->size);\n\n    if (!req->data_is_ptr && (req->dir == IOREQ_WRITE) &&\n            (req->size < sizeof (target_ulong))) {\n        req->data &= ((target_ulong) 1 << (8 * req->size)) - 1;\n    }\n\n    if (req->dir == IOREQ_WRITE)\n        trace_handle_ioreq_write(req, req->type, req->df, req->data_is_ptr,\n                                 req->addr, req->data, req->count, req->size);\n\n    switch (req->type) {\n        case IOREQ_TYPE_PIO:\n            cpu_ioreq_pio(req);\n            break;\n        case IOREQ_TYPE_COPY:\n            cpu_ioreq_move(req);\n            break;\n        case IOREQ_TYPE_VMWARE_PORT:\n            handle_vmport_ioreq(state, req);\n            break;\n        case IOREQ_TYPE_TIMEOFFSET:\n            break;\n        case IOREQ_TYPE_INVALIDATE:\n            xen_invalidate_map_cache();\n            break;\n        case IOREQ_TYPE_PCI_CONFIG: {\n            uint32_t sbdf = req->addr >> 32;\n            uint32_t val;\n\n            /* Fake a write to port 0xCF8 so that\n             * the config space access will target the\n             * correct device model.\n             */\n            val = (1u << 31) |\n                  ((req->addr & 0x0f00) << 16) |\n                  ((sbdf & 0xffff) << 8) |\n                  (req->addr & 0xfc);\n            do_outp(0xcf8, 4, val);\n\n            /* Now issue the config space access via\n             * port 0xCFC\n             */\n            req->addr = 0xcfc | (req->addr & 0x03);\n            cpu_ioreq_pio(req);\n            break;\n        }\n        default:\n            hw_error(\"Invalid ioreq type 0x%x\\n\", req->type);\n    }\n    if (req->dir == IOREQ_READ) {\n        trace_handle_ioreq_read(req, req->type, req->df, req->data_is_ptr,\n                                req->addr, req->data, req->count, req->size);\n    }\n}\n\nstatic int handle_buffered_iopage(XenIOState *state)\n{\n    buffered_iopage_t *buf_page = state->buffered_io_page;\n    buf_ioreq_t *buf_req = NULL;\n    ioreq_t req;\n    int qw;\n\n    if (!buf_page) {\n        return 0;\n    }\n\n    memset(&req, 0x00, sizeof(req));\n    req.state = STATE_IOREQ_READY;\n    req.count = 1;\n    req.dir = IOREQ_WRITE;\n\n    for (;;) {\n        uint32_t rdptr = buf_page->read_pointer, wrptr;\n\n        xen_rmb();\n        wrptr = buf_page->write_pointer;\n        xen_rmb();\n        if (rdptr != buf_page->read_pointer) {\n            continue;\n        }\n        if (rdptr == wrptr) {\n            break;\n        }\n        buf_req = &buf_page->buf_ioreq[rdptr % IOREQ_BUFFER_SLOT_NUM];\n        req.size = 1U << buf_req->size;\n        req.addr = buf_req->addr;\n        req.data = buf_req->data;\n        req.type = buf_req->type;\n        xen_rmb();\n        qw = (req.size == 8);\n        if (qw) {\n            if (rdptr + 1 == wrptr) {\n                hw_error(\"Incomplete quad word buffered ioreq\");\n            }\n            buf_req = &buf_page->buf_ioreq[(rdptr + 1) %\n                                           IOREQ_BUFFER_SLOT_NUM];\n            req.data |= ((uint64_t)buf_req->data) << 32;\n            xen_rmb();\n        }\n\n        handle_ioreq(state, &req);\n\n        /* Only req.data may get updated by handle_ioreq(), albeit even that\n         * should not happen as such data would never make it to the guest (we\n         * can only usefully see writes here after all).\n         */\n        assert(req.state == STATE_IOREQ_READY);\n        assert(req.count == 1);\n        assert(req.dir == IOREQ_WRITE);\n        assert(!req.data_is_ptr);\n\n        atomic_add(&buf_page->read_pointer, qw + 1);\n    }\n\n    return req.count;\n}\n\nstatic void handle_buffered_io(void *opaque)\n{\n    XenIOState *state = opaque;\n\n    if (handle_buffered_iopage(state)) {\n        timer_mod(state->buffered_io_timer,\n                BUFFER_IO_MAX_DELAY + qemu_clock_get_ms(QEMU_CLOCK_REALTIME));\n    } else {\n        timer_del(state->buffered_io_timer);\n        xenevtchn_unmask(state->xce_handle, state->bufioreq_local_port);\n    }\n}\n\nstatic void cpu_handle_ioreq(void *opaque)\n{\n    XenIOState *state = opaque;\n    ioreq_t *req = cpu_get_ioreq(state);\n\n    handle_buffered_iopage(state);\n    if (req) {\n        ioreq_t copy = *req;\n\n        xen_rmb();\n        handle_ioreq(state, &copy);\n        req->data = copy.data;\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n                    req->state, req->data_is_ptr, req->addr,\n                    req->data, req->count, req->size, req->type);\n            destroy_hvm_domain(false);\n            return;\n        }\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n        /*\n         * We do this before we send the response so that the tools\n         * have the opportunity to pick up on the reset before the\n         * guest resumes and does a hlt with interrupts disabled which\n         * causes Xen to powerdown the domain.\n         */\n        if (runstate_is_running()) {\n            if (qemu_shutdown_requested_get()) {\n                destroy_hvm_domain(false);\n            }\n            if (qemu_reset_requested_get()) {\n                qemu_system_reset(VMRESET_REPORT);\n                destroy_hvm_domain(true);\n            }\n        }\n\n        req->state = STATE_IORESP_READY;\n        xenevtchn_notify(state->xce_handle,\n                         state->ioreq_local_port[state->send_vcpu]);\n    }\n}\n\nstatic void xen_main_loop_prepare(XenIOState *state)\n{\n    int evtchn_fd = -1;\n\n    if (state->xce_handle != NULL) {\n        evtchn_fd = xenevtchn_fd(state->xce_handle);\n    }\n\n    state->buffered_io_timer = timer_new_ms(QEMU_CLOCK_REALTIME, handle_buffered_io,\n                                                 state);\n\n    if (evtchn_fd != -1) {\n        CPUState *cpu_state;\n\n        DPRINTF(\"%s: Init cpu_by_vcpu_id\\n\", __func__);\n        CPU_FOREACH(cpu_state) {\n            DPRINTF(\"%s: cpu_by_vcpu_id[%d]=%p\\n\",\n                    __func__, cpu_state->cpu_index, cpu_state);\n            state->cpu_by_vcpu_id[cpu_state->cpu_index] = cpu_state;\n        }\n        qemu_set_fd_handler(evtchn_fd, cpu_handle_ioreq, NULL, state);\n    }\n}\n\n\nstatic void xen_hvm_change_state_handler(void *opaque, int running,\n                                         RunState rstate)\n{\n    XenIOState *state = opaque;\n\n    if (running) {\n        xen_main_loop_prepare(state);\n    }\n\n    xen_set_ioreq_server_state(xen_xc, xen_domid,\n                               state->ioservid,\n                               (rstate == RUN_STATE_RUNNING));\n}\n\nstatic void xen_exit_notifier(Notifier *n, void *data)\n{\n    XenIOState *state = container_of(n, XenIOState, exit);\n\n    xenevtchn_close(state->xce_handle);\n    xs_daemon_close(state->xenstore);\n}\n\nstatic void xen_read_physmap(XenIOState *state)\n{\n    XenPhysmap *physmap = NULL;\n    unsigned int len, num, i;\n    char path[80], *value = NULL;\n    char **entries = NULL;\n\n    snprintf(path, sizeof(path),\n            \"/local/domain/0/device-model/%d/physmap\", xen_domid);\n    entries = xs_directory(state->xenstore, 0, path, &num);\n    if (entries == NULL)\n        return;\n\n    for (i = 0; i < num; i++) {\n        physmap = g_malloc(sizeof (XenPhysmap));\n        physmap->phys_offset = strtoull(entries[i], NULL, 16);\n        snprintf(path, sizeof(path),\n                \"/local/domain/0/device-model/%d/physmap/%s/start_addr\",\n                xen_domid, entries[i]);\n        value = xs_read(state->xenstore, 0, path, &len);\n        if (value == NULL) {\n            g_free(physmap);\n            continue;\n        }\n        physmap->start_addr = strtoull(value, NULL, 16);\n        free(value);\n\n        snprintf(path, sizeof(path),\n                \"/local/domain/0/device-model/%d/physmap/%s/size\",\n                xen_domid, entries[i]);\n        value = xs_read(state->xenstore, 0, path, &len);\n        if (value == NULL) {\n            g_free(physmap);\n            continue;\n        }\n        physmap->size = strtoull(value, NULL, 16);\n        free(value);\n\n        snprintf(path, sizeof(path),\n                \"/local/domain/0/device-model/%d/physmap/%s/name\",\n                xen_domid, entries[i]);\n        physmap->name = xs_read(state->xenstore, 0, path, &len);\n\n        QLIST_INSERT_HEAD(&state->physmap, physmap, list);\n    }\n    free(entries);\n}\n\nstatic void xen_wakeup_notifier(Notifier *notifier, void *data)\n{\n    xc_set_hvm_param(xen_xc, xen_domid, HVM_PARAM_ACPI_S_STATE, 0);\n}\n\nvoid xen_hvm_init(PCMachineState *pcms, MemoryRegion **ram_memory)\n{\n    int i, rc;\n    xen_pfn_t ioreq_pfn;\n    xen_pfn_t bufioreq_pfn;\n    evtchn_port_t bufioreq_evtchn;\n    XenIOState *state;\n\n    state = g_malloc0(sizeof (XenIOState));\n\n    state->xce_handle = xenevtchn_open(NULL, 0);\n    if (state->xce_handle == NULL) {\n        perror(\"xen: event channel open\");\n        goto err;\n    }\n\n    state->xenstore = xs_daemon_open();\n    if (state->xenstore == NULL) {\n        perror(\"xen: xenstore open\");\n        goto err;\n    }\n\n    xen_create_ioreq_server(xen_xc, xen_domid, &state->ioservid);\n\n    state->exit.notify = xen_exit_notifier;\n    qemu_add_exit_notifier(&state->exit);\n\n    state->suspend.notify = xen_suspend_notifier;\n    qemu_register_suspend_notifier(&state->suspend);\n\n    state->wakeup.notify = xen_wakeup_notifier;\n    qemu_register_wakeup_notifier(&state->wakeup);\n\n    rc = xen_get_ioreq_server_info(xen_xc, xen_domid, state->ioservid,\n                                   &ioreq_pfn, &bufioreq_pfn,\n                                   &bufioreq_evtchn);\n    if (rc < 0) {\n        error_report(\"failed to get ioreq server info: error %d handle=%p\",\n                     errno, xen_xc);\n        goto err;\n    }\n\n    DPRINTF(\"shared page at pfn %lx\\n\", ioreq_pfn);\n    DPRINTF(\"buffered io page at pfn %lx\\n\", bufioreq_pfn);\n    DPRINTF(\"buffered io evtchn is %x\\n\", bufioreq_evtchn);\n\n    state->shared_page = xenforeignmemory_map(xen_fmem, xen_domid,\n                                              PROT_READ|PROT_WRITE,\n                                              1, &ioreq_pfn, NULL);\n    if (state->shared_page == NULL) {\n        error_report(\"map shared IO page returned error %d handle=%p\",\n                     errno, xen_xc);\n        goto err;\n    }\n\n    rc = xen_get_vmport_regs_pfn(xen_xc, xen_domid, &ioreq_pfn);\n    if (!rc) {\n        DPRINTF(\"shared vmport page at pfn %lx\\n\", ioreq_pfn);\n        state->shared_vmport_page =\n            xenforeignmemory_map(xen_fmem, xen_domid, PROT_READ|PROT_WRITE,\n                                 1, &ioreq_pfn, NULL);\n        if (state->shared_vmport_page == NULL) {\n            error_report(\"map shared vmport IO page returned error %d handle=%p\",\n                         errno, xen_xc);\n            goto err;\n        }\n    } else if (rc != -ENOSYS) {\n        error_report(\"get vmport regs pfn returned error %d, rc=%d\",\n                     errno, rc);\n        goto err;\n    }\n\n    state->buffered_io_page = xenforeignmemory_map(xen_fmem, xen_domid,\n                                                   PROT_READ|PROT_WRITE,\n                                                   1, &bufioreq_pfn, NULL);\n    if (state->buffered_io_page == NULL) {\n        error_report(\"map buffered IO page returned error %d\", errno);\n        goto err;\n    }\n\n    /* Note: cpus is empty at this point in init */\n    state->cpu_by_vcpu_id = g_malloc0(max_cpus * sizeof(CPUState *));\n\n    rc = xen_set_ioreq_server_state(xen_xc, xen_domid, state->ioservid, true);\n    if (rc < 0) {\n        error_report(\"failed to enable ioreq server info: error %d handle=%p\",\n                     errno, xen_xc);\n        goto err;\n    }\n\n    state->ioreq_local_port = g_malloc0(max_cpus * sizeof (evtchn_port_t));\n\n    /* FIXME: how about if we overflow the page here? */\n    for (i = 0; i < max_cpus; i++) {\n        rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n                                        xen_vcpu_eport(state->shared_page, i));\n        if (rc == -1) {\n            error_report(\"shared evtchn %d bind error %d\", i, errno);\n            goto err;\n        }\n        state->ioreq_local_port[i] = rc;\n    }\n\n    rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n                                    bufioreq_evtchn);\n    if (rc == -1) {\n        error_report(\"buffered evtchn bind error %d\", errno);\n        goto err;\n    }\n    state->bufioreq_local_port = rc;\n\n    /* Init RAM management */\n    xen_map_cache_init(xen_phys_offset_to_gaddr, state);\n    xen_ram_init(pcms, ram_size, ram_memory);\n\n    qemu_add_vm_change_state_handler(xen_hvm_change_state_handler, state);\n\n    state->memory_listener = xen_memory_listener;\n    QLIST_INIT(&state->physmap);\n    memory_listener_register(&state->memory_listener, &address_space_memory);\n    state->log_for_dirtybit = NULL;\n\n    state->io_listener = xen_io_listener;\n    memory_listener_register(&state->io_listener, &address_space_io);\n\n    state->device_listener = xen_device_listener;\n    device_listener_register(&state->device_listener);\n\n    /* Initialize backend core & drivers */\n    if (xen_be_init() != 0) {\n        error_report(\"xen backend core setup failed\");\n        goto err;\n    }\n    xen_be_register_common();\n    xen_read_physmap(state);\n\n    /* Disable ACPI build because Xen handles it */\n    pcms->acpi_build_enabled = false;\n\n    return;\n\nerr:\n    error_report(\"xen hardware virtual machine initialisation failed\");\n    exit(1);\n}\n\nvoid destroy_hvm_domain(bool reboot)\n{\n    xc_interface *xc_handle;\n    int sts;\n\n    xc_handle = xc_interface_open(0, 0, 0);\n    if (xc_handle == NULL) {\n        fprintf(stderr, \"Cannot acquire xenctrl handle\\n\");\n    } else {\n        sts = xc_domain_shutdown(xc_handle, xen_domid,\n                                 reboot ? SHUTDOWN_reboot : SHUTDOWN_poweroff);\n        if (sts != 0) {\n            fprintf(stderr, \"xc_domain_shutdown failed to issue %s, \"\n                    \"sts %d, %s\\n\", reboot ? \"reboot\" : \"poweroff\",\n                    sts, strerror(errno));\n        } else {\n            fprintf(stderr, \"Issued domain %d %s\\n\", xen_domid,\n                    reboot ? \"reboot\" : \"poweroff\");\n        }\n        xc_interface_close(xc_handle);\n    }\n}\n\nvoid xen_register_framebuffer(MemoryRegion *mr)\n{\n    framebuffer = mr;\n}\n\nvoid xen_shutdown_fatal_error(const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    fprintf(stderr, \"Will destroy the domain.\\n\");\n    /* destroy the domain */\n    qemu_system_shutdown_request();\n}\n\nvoid xen_modified_memory(ram_addr_t start, ram_addr_t length)\n{\n    if (unlikely(xen_in_migration)) {\n        int rc;\n        ram_addr_t start_pfn, nb_pages;\n\n        if (length == 0) {\n            length = TARGET_PAGE_SIZE;\n        }\n        start_pfn = start >> TARGET_PAGE_BITS;\n        nb_pages = ((start + length + TARGET_PAGE_SIZE - 1) >> TARGET_PAGE_BITS)\n            - start_pfn;\n        rc = xc_hvm_modified_memory(xen_xc, xen_domid, start_pfn, nb_pages);\n        if (rc) {\n            fprintf(stderr,\n                    \"%s failed for \"RAM_ADDR_FMT\" (\"RAM_ADDR_FMT\"): %i, %s\\n\",\n                    __func__, start, nb_pages, rc, strerror(-rc));\n        }\n    }\n}\n\nvoid qmp_xen_set_global_dirty_log(bool enable, Error **errp)\n{\n    if (enable) {\n        memory_global_dirty_log_start();\n    } else {\n        memory_global_dirty_log_stop();\n    }\n}\n"
        },
        {
          "name": "xen-mapcache.c",
          "type": "blob",
          "size": 13.2734375,
          "content": "/*\n * Copyright (C) 2011       Citrix Ltd.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/osdep.h\"\n\n#include <sys/resource.h>\n\n#include \"hw/xen/xen_backend.h\"\n#include \"sysemu/blockdev.h\"\n#include \"qemu/bitmap.h\"\n\n#include <xen/hvm/params.h>\n\n#include \"sysemu/xen-mapcache.h\"\n#include \"trace-root.h\"\n\n\n//#define MAPCACHE_DEBUG\n\n#ifdef MAPCACHE_DEBUG\n#  define DPRINTF(fmt, ...) do { \\\n    fprintf(stderr, \"xen_mapcache: \" fmt, ## __VA_ARGS__); \\\n} while (0)\n#else\n#  define DPRINTF(fmt, ...) do { } while (0)\n#endif\n\n#if HOST_LONG_BITS == 32\n#  define MCACHE_BUCKET_SHIFT 16\n#  define MCACHE_MAX_SIZE     (1UL<<31) /* 2GB Cap */\n#else\n#  define MCACHE_BUCKET_SHIFT 20\n#  define MCACHE_MAX_SIZE     (1UL<<35) /* 32GB Cap */\n#endif\n#define MCACHE_BUCKET_SIZE (1UL << MCACHE_BUCKET_SHIFT)\n\n/* This is the size of the virtual address space reserve to QEMU that will not\n * be use by MapCache.\n * From empirical tests I observed that qemu use 75MB more than the\n * max_mcache_size.\n */\n#define NON_MCACHE_MEMORY_SIZE (80 * 1024 * 1024)\n\ntypedef struct MapCacheEntry {\n    hwaddr paddr_index;\n    uint8_t *vaddr_base;\n    unsigned long *valid_mapping;\n    uint8_t lock;\n    hwaddr size;\n    struct MapCacheEntry *next;\n} MapCacheEntry;\n\ntypedef struct MapCacheRev {\n    uint8_t *vaddr_req;\n    hwaddr paddr_index;\n    hwaddr size;\n    QTAILQ_ENTRY(MapCacheRev) next;\n    bool dma;\n} MapCacheRev;\n\ntypedef struct MapCache {\n    MapCacheEntry *entry;\n    unsigned long nr_buckets;\n    QTAILQ_HEAD(map_cache_head, MapCacheRev) locked_entries;\n\n    /* For most cases (>99.9%), the page address is the same. */\n    MapCacheEntry *last_entry;\n    unsigned long max_mcache_size;\n    unsigned int mcache_bucket_shift;\n\n    phys_offset_to_gaddr_t phys_offset_to_gaddr;\n    QemuMutex lock;\n    void *opaque;\n} MapCache;\n\nstatic MapCache *mapcache;\n\nstatic inline void mapcache_lock(void)\n{\n    qemu_mutex_lock(&mapcache->lock);\n}\n\nstatic inline void mapcache_unlock(void)\n{\n    qemu_mutex_unlock(&mapcache->lock);\n}\n\nstatic inline int test_bits(int nr, int size, const unsigned long *addr)\n{\n    unsigned long res = find_next_zero_bit(addr, size + nr, nr);\n    if (res >= nr + size)\n        return 1;\n    else\n        return 0;\n}\n\nvoid xen_map_cache_init(phys_offset_to_gaddr_t f, void *opaque)\n{\n    unsigned long size;\n    struct rlimit rlimit_as;\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n    mapcache->phys_offset_to_gaddr = f;\n    mapcache->opaque = opaque;\n    qemu_mutex_init(&mapcache->lock);\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    if (geteuid() == 0) {\n        rlimit_as.rlim_cur = RLIM_INFINITY;\n        rlimit_as.rlim_max = RLIM_INFINITY;\n        mapcache->max_mcache_size = MCACHE_MAX_SIZE;\n    } else {\n        getrlimit(RLIMIT_AS, &rlimit_as);\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n        if (rlimit_as.rlim_max != RLIM_INFINITY) {\n            fprintf(stderr, \"Warning: QEMU's maximum size of virtual\"\n                    \" memory is not infinity.\\n\");\n        }\n        if (rlimit_as.rlim_max < MCACHE_MAX_SIZE + NON_MCACHE_MEMORY_SIZE) {\n            mapcache->max_mcache_size = rlimit_as.rlim_max -\n                NON_MCACHE_MEMORY_SIZE;\n        } else {\n            mapcache->max_mcache_size = MCACHE_MAX_SIZE;\n        }\n    }\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->nr_buckets =\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n            mapcache->nr_buckets, size);\n    mapcache->entry = g_malloc0(size);\n}\n\nstatic void xen_remap_bucket(MapCacheEntry *entry,\n                             hwaddr size,\n                             hwaddr address_index)\n{\n    uint8_t *vaddr_base;\n    xen_pfn_t *pfns;\n    int *err;\n    unsigned int i;\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n    trace_xen_remap_bucket(address_index);\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n    if (entry->vaddr_base != NULL) {\n        ram_block_notify_remove(entry->vaddr_base, entry->size);\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n            perror(\"unmap fails\");\n            exit(-1);\n        }\n    }\n    g_free(entry->valid_mapping);\n    entry->valid_mapping = NULL;\n\n    for (i = 0; i < nb_pfn; i++) {\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n    }\n\n    vaddr_base = xenforeignmemory_map(xen_fmem, xen_domid, PROT_READ|PROT_WRITE,\n                                      nb_pfn, pfns, err);\n    if (vaddr_base == NULL) {\n        perror(\"xenforeignmemory_map\");\n        exit(-1);\n    }\n\n    entry->vaddr_base = vaddr_base;\n    entry->paddr_index = address_index;\n    entry->size = size;\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n    ram_block_notify_add(entry->vaddr_base, entry->size);\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n    for (i = 0; i < nb_pfn; i++) {\n        if (!err[i]) {\n            bitmap_set(entry->valid_mapping, i, 1);\n        }\n    }\n\n    g_free(pfns);\n    g_free(err);\n}\n\nstatic uint8_t *xen_map_cache_unlocked(hwaddr phys_addr, hwaddr size,\n                                       uint8_t lock, bool dma)\n{\n    MapCacheEntry *entry, *pentry = NULL;\n    hwaddr address_index;\n    hwaddr address_offset;\n    hwaddr cache_size = size;\n    hwaddr test_bit_size;\n    bool translated = false;\n\ntryagain:\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n    trace_xen_map_cache(phys_addr);\n\n    /* test_bit_size is always a multiple of XC_PAGE_SIZE */\n    if (size) {\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n        }\n    } else {\n        test_bit_size = XC_PAGE_SIZE;\n    }\n\n    if (mapcache->last_entry != NULL &&\n        mapcache->last_entry->paddr_index == address_index &&\n        !lock && !size &&\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n                  test_bit_size >> XC_PAGE_SHIFT,\n                  mapcache->last_entry->valid_mapping)) {\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n        return mapcache->last_entry->vaddr_base + address_offset;\n    }\n\n    /* size is always a multiple of MCACHE_BUCKET_SIZE */\n    if (size) {\n        cache_size = size + address_offset;\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n        }\n    } else {\n        cache_size = MCACHE_BUCKET_SIZE;\n    }\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n    while (entry && entry->lock && entry->vaddr_base &&\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n                 test_bit_size >> XC_PAGE_SHIFT,\n                 entry->valid_mapping))) {\n        pentry = entry;\n        entry = entry->next;\n    }\n    if (!entry) {\n        entry = g_malloc0(sizeof (MapCacheEntry));\n        pentry->next = entry;\n        xen_remap_bucket(entry, cache_size, address_index);\n    } else if (!entry->lock) {\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n                entry->size != cache_size ||\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n                    test_bit_size >> XC_PAGE_SHIFT,\n                    entry->valid_mapping)) {\n            xen_remap_bucket(entry, cache_size, address_index);\n        }\n    }\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n                test_bit_size >> XC_PAGE_SHIFT,\n                entry->valid_mapping)) {\n        mapcache->last_entry = NULL;\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n            translated = true;\n            goto tryagain;\n        }\n        trace_xen_map_cache_return(NULL);\n        return NULL;\n    }\n\n    mapcache->last_entry = entry;\n    if (lock) {\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n        entry->lock++;\n        reventry->dma = dma;\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n        reventry->size = entry->size;\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n    }\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n    return mapcache->last_entry->vaddr_base + address_offset;\n}\n\nuint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n                       uint8_t lock, bool dma)\n{\n    uint8_t *p;\n\n    mapcache_lock();\n    p = xen_map_cache_unlocked(phys_addr, size, lock, dma);\n    mapcache_unlock();\n    return p;\n}\n\nram_addr_t xen_ram_addr_from_mapcache(void *ptr)\n{\n    MapCacheEntry *entry = NULL;\n    MapCacheRev *reventry;\n    hwaddr paddr_index;\n    hwaddr size;\n    ram_addr_t raddr;\n    int found = 0;\n\n    mapcache_lock();\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n        if (reventry->vaddr_req == ptr) {\n            paddr_index = reventry->paddr_index;\n            size = reventry->size;\n            found = 1;\n            break;\n        }\n    }\n    if (!found) {\n        fprintf(stderr, \"%s, could not find %p\\n\", __func__, ptr);\n        QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n            DPRINTF(\"   \"TARGET_FMT_plx\" -> %p is present\\n\", reventry->paddr_index,\n                    reventry->vaddr_req);\n        }\n        abort();\n        return 0;\n    }\n\n    entry = &mapcache->entry[paddr_index % mapcache->nr_buckets];\n    while (entry && (entry->paddr_index != paddr_index || entry->size != size)) {\n        entry = entry->next;\n    }\n    if (!entry) {\n        DPRINTF(\"Trying to find address %p that is not in the mapcache!\\n\", ptr);\n        raddr = 0;\n    } else {\n        raddr = (reventry->paddr_index << MCACHE_BUCKET_SHIFT) +\n             ((unsigned long) ptr - (unsigned long) entry->vaddr_base);\n    }\n    mapcache_unlock();\n    return raddr;\n}\n\nstatic void xen_invalidate_map_cache_entry_unlocked(uint8_t *buffer)\n{\n    MapCacheEntry *entry = NULL, *pentry = NULL;\n    MapCacheRev *reventry;\n    hwaddr paddr_index;\n    hwaddr size;\n    int found = 0;\n\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n        if (reventry->vaddr_req == buffer) {\n            paddr_index = reventry->paddr_index;\n            size = reventry->size;\n            found = 1;\n            break;\n        }\n    }\n    if (!found) {\n        DPRINTF(\"%s, could not find %p\\n\", __func__, buffer);\n        QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n            DPRINTF(\"   \"TARGET_FMT_plx\" -> %p is present\\n\", reventry->paddr_index, reventry->vaddr_req);\n        }\n        return;\n    }\n    QTAILQ_REMOVE(&mapcache->locked_entries, reventry, next);\n    g_free(reventry);\n\n    if (mapcache->last_entry != NULL &&\n        mapcache->last_entry->paddr_index == paddr_index) {\n        mapcache->last_entry = NULL;\n    }\n\n    entry = &mapcache->entry[paddr_index % mapcache->nr_buckets];\n    while (entry && (entry->paddr_index != paddr_index || entry->size != size)) {\n        pentry = entry;\n        entry = entry->next;\n    }\n    if (!entry) {\n        DPRINTF(\"Trying to unmap address %p that is not in the mapcache!\\n\", buffer);\n        return;\n    }\n    entry->lock--;\n    if (entry->lock > 0 || pentry == NULL) {\n        return;\n    }\n\n    pentry->next = entry->next;\n    ram_block_notify_remove(entry->vaddr_base, entry->size);\n    if (munmap(entry->vaddr_base, entry->size) != 0) {\n        perror(\"unmap fails\");\n        exit(-1);\n    }\n    g_free(entry->valid_mapping);\n    g_free(entry);\n}\n\nvoid xen_invalidate_map_cache_entry(uint8_t *buffer)\n{\n    mapcache_lock();\n    xen_invalidate_map_cache_entry_unlocked(buffer);\n    mapcache_unlock();\n}\n\nvoid xen_invalidate_map_cache(void)\n{\n    unsigned long i;\n    MapCacheRev *reventry;\n\n    /* Flush pending AIO before destroying the mapcache */\n    bdrv_drain_all();\n\n    mapcache_lock();\n\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n        if (!reventry->dma) {\n            continue;\n        }\n        fprintf(stderr, \"Locked DMA mapping while invalidating mapcache!\"\n                \" \"TARGET_FMT_plx\" -> %p is present\\n\",\n                reventry->paddr_index, reventry->vaddr_req);\n    }\n\n    for (i = 0; i < mapcache->nr_buckets; i++) {\n        MapCacheEntry *entry = &mapcache->entry[i];\n\n        if (entry->vaddr_base == NULL) {\n            continue;\n        }\n        if (entry->lock > 0) {\n            continue;\n        }\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n            perror(\"unmap fails\");\n            exit(-1);\n        }\n\n        entry->paddr_index = 0;\n        entry->vaddr_base = NULL;\n        entry->size = 0;\n        g_free(entry->valid_mapping);\n        entry->valid_mapping = NULL;\n    }\n\n    mapcache->last_entry = NULL;\n\n    mapcache_unlock();\n}\n"
        }
      ]
    }
  ]
}