{
  "metadata": {
    "timestamp": 1736710118657,
    "page": 752,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rui314/9cc",
      "stars": 1848,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0615234375,
          "content": "---\nBasedOnStyle: LLVM\nAllowShortFunctionsOnASingleLine: false\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "*~\n*.o\ntmp*\n9cc\na.out\n"
        },
        {
          "name": "9cc.h",
          "type": "blob",
          "size": 7.4375,
          "content": "#define _GNU_SOURCE\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdnoreturn.h>\n#include <string.h>\n\n/// util.c\n\nnoreturn void error(char *fmt, ...) __attribute__((format(printf, 1, 2)));\nchar *format(char *fmt, ...) __attribute__((format(printf, 1, 2)));\n\ntypedef struct {\n  void **data;\n  int capacity;\n  int len;\n} Vector;\n\nVector *new_vec(void);\nvoid vec_push(Vector *v, void *elem);\nvoid vec_pushi(Vector *v, int val);\nvoid *vec_pop(Vector *v);\nvoid *vec_last(Vector *v);\nbool vec_contains(Vector *v, void *elem);\nbool vec_union1(Vector *v, void *elem);\n\ntypedef struct {\n  Vector *keys;\n  Vector *vals;\n} Map;\n\nMap *new_map(void);\nvoid map_put(Map *map, char *key, void *val);\nvoid map_puti(Map *map, char *key, int val);\nvoid *map_get(Map *map, char *key);\nint map_geti(Map *map, char *key, int default_);\nbool map_exists(Map *map, char *key);\n\ntypedef struct {\n  char *data;\n  int capacity;\n  int len;\n} StringBuilder;\n\nStringBuilder *new_sb(void);\nvoid sb_add(StringBuilder *sb, char c);\nvoid sb_append(StringBuilder *sb, char *s);\nvoid sb_append_n(StringBuilder *sb, char *s, int len);\nchar *sb_get(StringBuilder *sb);\n\ntypedef struct Type Type;\n\ntypedef struct Type {\n  int ty;\n  int size;  // sizeof\n  int align; // alignof\n\n  // Pointer\n  Type *ptr_to;\n\n  // Array\n  Type *ary_of;\n  int len;\n\n  // Struct\n  Map *members;\n  int offset;\n\n  // Function\n  Type *returning;\n} Type;\n\nType *ptr_to(Type *base);\nType *ary_of(Type *base, int len);\nType *void_ty();\nType *bool_ty();\nType *char_ty();\nType *int_ty();\nType *func_ty(Type *returning);\nbool same_type(Type *x, Type *y);\nint roundup(int x, int align);\n\n/// util_test.c\n\nvoid util_test();\n\n/// token.c\n\nenum {\n  TK_NUM = 256, // Number literal\n  TK_STR,       // String literal\n  TK_IDENT,     // Identifier\n  TK_ARROW,     // ->\n  TK_EXTERN,    // \"extern\"\n  TK_TYPEDEF,   // \"typedef\"\n  TK_INT,       // \"int\"\n  TK_CHAR,      // \"char\"\n  TK_VOID,      // \"void\"\n  TK_STRUCT,    // \"struct\"\n  TK_BOOL,      // \"_Bool\"\n  TK_IF,        // \"if\"\n  TK_ELSE,      // \"else\"\n  TK_FOR,       // \"for\"\n  TK_DO,        // \"do\"\n  TK_WHILE,     // \"while\"\n  TK_SWITCH,    // \"switch\"\n  TK_CASE,      // \"case\"\n  TK_BREAK,     // \"break\"\n  TK_CONTINUE,  // \"continue\"\n  TK_EQ,        // ==\n  TK_NE,        // !=\n  TK_LE,        // <=\n  TK_GE,        // >=\n  TK_LOGOR,     // ||\n  TK_LOGAND,    // &&\n  TK_SHL,       // <<\n  TK_SHR,       // >>\n  TK_INC,       // ++\n  TK_DEC,       // --\n  TK_MUL_EQ,    // *=\n  TK_DIV_EQ,    // /=\n  TK_MOD_EQ,    // %=\n  TK_ADD_EQ,    // +=\n  TK_SUB_EQ,    // -=\n  TK_SHL_EQ,    // <<=\n  TK_SHR_EQ,    // >>=\n  TK_AND_EQ,    // &=\n  TK_XOR_EQ,    // ^=\n  TK_OR_EQ,     // |=\n  TK_RETURN,    // \"return\"\n  TK_SIZEOF,    // \"sizeof\"\n  TK_ALIGNOF,   // \"_Alignof\"\n  TK_TYPEOF,    // \"typeof\"\n  TK_PARAM,     // Function-like macro parameter\n  TK_EOF,       // End marker\n};\n\n// Token type\ntypedef struct {\n  int ty;     // Token type\n  int val;    // Number literal\n  char *name; // Identifier\n\n  // String literal\n  char *str;\n  char len;\n\n  // For preprocessor\n  bool stringize;\n\n  // For error reporting\n  char *buf;\n  char *path;\n  char *start;\n  char *end;\n} Token;\n\nVector *tokenize(char *path, bool add_eof);\nnoreturn void bad_token(Token *t, char *msg);\nvoid warn_token(Token *t, char *msg);\nint get_line_number(Token *t);\nchar *stringize(Vector *tokens);\n\n/// preprocess.c\n\nVector *preprocess(Vector *tokens);\n\n/// parse.c\n\nextern int nlabel;\n\nenum {\n  ND_NUM = 256, // Number literal\n  ND_STRUCT,    // Struct\n  ND_DECL,      // declaration\n  ND_VARDEF,    // Variable definition\n  ND_VARREF,    // Variable reference\n  ND_CAST,      // Cast\n  ND_IF,        // \"if\"\n  ND_FOR,       // \"for\"\n  ND_DO_WHILE,  // do ... while\n  ND_SWITCH,    // switch\n  ND_CASE,      // case\n  ND_BREAK,     // break\n  ND_CONTINUE,  // continue\n  ND_ADDR,      // address-of operator (\"&\")\n  ND_DEREF,     // pointer dereference (\"*\")\n  ND_DOT,       // Struct member access\n  ND_EQ,        // ==\n  ND_NE,        // !=\n  ND_LE,        // <=\n  ND_LOGAND,    // &&\n  ND_LOGOR,     // ||\n  ND_SHL,       // <<\n  ND_SHR,       // >>\n  ND_MOD,       // %\n  ND_RETURN,    // \"return\"\n  ND_CALL,      // Function call\n  ND_FUNC,      // Function definition\n  ND_COMP_STMT, // Compound statement\n  ND_EXPR_STMT, // Expression statement\n  ND_STMT_EXPR, // Statement expression (GNU extn.)\n  ND_NULL,      // Null statement\n};\n\nenum {\n  VOID = 1,\n  BOOL,\n  CHAR,\n  INT,\n  PTR,\n  ARY,\n  STRUCT,\n  FUNC,\n};\n\ntypedef struct Reg Reg;\n\n// Represents a variable.\ntypedef struct {\n  Type *ty;\n  char *name;\n  bool is_local;\n\n  // Local variables are compiled to offsets from RBP.\n  int offset;\n\n  // Global variables are compiled to labels with optional\n  // initialized data.\n  char *data;\n\n  // For optimization passes.\n  bool address_taken;\n  Reg *promoted;\n} Var;\n\ntypedef struct Node Node;\ntypedef struct BB BB;\n\n// AST node\ntypedef struct Node {\n  int op;        // Node type\n  Type *ty;      // C type\n  Node *lhs;     // left-hand side\n  Node *rhs;     // right-hand side\n  int val;       // Number literal\n  Node *expr;    // \"return\" or expresson stmt\n  Vector *stmts; // Compound statement\n\n  char *name;\n\n  // For ND_VARREF\n  Var *var;\n\n  // \"if\" ( cond ) then \"else\" els\n  // \"for\" ( init; cond; inc ) body\n  // \"while\" ( cond ) body\n  // \"do\" body \"while\" ( cond )\n  // \"switch\" ( cond ) body\n  // \"case\" val \":\" body\n  Node *cond;\n  Node *then;\n  Node *els;\n  Node *init;\n  Node *inc;\n  Node *body;\n\n  // For switch and case\n  Vector *cases;\n  BB *bb;\n\n  // For case, break and continue\n  Node *target;\n  BB *break_;\n  BB *continue_;\n\n  // Function definition\n  Vector *params;\n\n  // Function call\n  Vector *args;\n\n  // For error reporting\n  Token *token;\n} Node;\n\ntypedef struct {\n  char *name;\n  Node *node;\n  Vector *lvars;\n  Vector *bbs;\n} Function;\n\n// Represents toplevel constructs.\ntypedef struct {\n  Vector *gvars;\n  Vector *funcs;\n} Program;\n\nProgram *parse(Vector *tokens);\n\nNode *new_int_node(int val, Token *t);\n\n/// sema.c\n\nType *get_type(Node *node);\nvoid sema(Program *prog);\n\n/// ir_dump.c\n\nvoid dump_ir(Vector *irv);\n\n/// gen_ir.c\n\nenum {\n  IR_ADD = 1,\n  IR_SUB,\n  IR_MUL,\n  IR_DIV,\n  IR_IMM,\n  IR_BPREL,\n  IR_MOV,\n  IR_RETURN,\n  IR_CALL,\n  IR_LABEL_ADDR,\n  IR_EQ,\n  IR_NE,\n  IR_LE,\n  IR_LT,\n  IR_AND,\n  IR_OR,\n  IR_XOR,\n  IR_SHL,\n  IR_SHR,\n  IR_MOD,\n  IR_JMP,\n  IR_BR,\n  IR_LOAD,\n  IR_LOAD_SPILL,\n  IR_STORE,\n  IR_STORE_ARG,\n  IR_STORE_SPILL,\n  IR_NOP,\n};\n\ntypedef struct Reg {\n  int vn; // virtual register number\n  int rn; // real register number\n\n  // For optimizer\n  Reg *promoted;\n\n  // For regalloc\n  int def;\n  int last_use;\n  bool spill;\n  Var *var;\n} Reg;\n\ntypedef struct BB {\n  int label;\n  Vector *ir;\n  Reg *param;\n\n  // For liveness analysis\n  Vector *succ;\n  Vector *pred;\n  Vector *def_regs;\n  Vector *in_regs;\n  Vector *out_regs;\n} BB;\n\ntypedef struct {\n  int op;\n\n  Reg *r0;\n  Reg *r1;\n  Reg *r2;\n\n  int imm;\n  int label;\n  Var *var;\n\n  BB *bb1;\n  BB *bb2;\n\n  // Load/store size in bytes\n  int size;\n\n  // Function call\n  char *name;\n  int nargs;\n  Reg *args[6];\n\n  // For liveness tracking\n  Vector *kill;\n\n  // For SSA\n  Reg *bbarg;\n} IR;\n\nvoid gen_ir(Program *prog);\nReg *new_reg();\n\n/// opt.c\n\nvoid optimize(Program *prog);\n\n/// liveness.c\n\nvoid liveness(Program *prog);\n\n/// liveness.c\n\nvoid liveness(Program *prog);\n\n/// regalloc.c\n\nvoid alloc_regs(Program *prog);\n\n/// gen_x86.c\n\nextern char *regs[];\nextern char *regs8[];\nextern char *regs32[];\nextern int num_regs;\n\nvoid gen_x86(Program *prog);\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2018 Rui Ueyama\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.478515625,
          "content": "CFLAGS=-Wall -std=c11 -g\nSRCS=$(wildcard *.c)\nOBJS=$(SRCS:.c=.o)\n\n9cc: $(OBJS)\n\tcc -o $@ $(OBJS) $(LDFLAGS)\n\n$(OBJS): 9cc.h\n\ntest: 9cc test/test.c\n\t./9cc -test\n\n\t@./9cc test/test.c > tmp-test1.s\n\t@gcc -c -o tmp-test2.o test/gcc.c\n\t@gcc -static -o tmp-test1 tmp-test1.s tmp-test2.o\n\t@./tmp-test1\n\n\t@./9cc test/token.c > tmp-test2.s\n\t@gcc -static -o tmp-test2 tmp-test2.s\n\t@./tmp-test2\n\nclean:\n\trm -f 9cc *.o *~ tmp* a.out test/*~\n\nformat:\n\tclang-format -i *.c *.h\n\n.PHONY: test clean format\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.287109375,
          "content": "9cc C compiler\n==============\n\nNote: 9cc is no longer an active project, and the successor is\n[chibicc](https://github.com/rui314/chibicc).\n\n9cc is a successor of my [8cc](https://github.com/rui314/8cc) C compiler.\nIn this new project, I'm trying to write code that can be understood\nextremely easily while creating a compiler that generates reasonably\nefficient assembly.\n\n9cc has more stages than 8cc. Here is an overview of the internals:\n\n 1. Compiles an input string to abstract syntax trees.\n 2. Runs a semantic analyzer on the trees to add a type to each tree node.\n 3. Converts the trees to intermediate code (IR), which in some degree\n    resembles x86-64 instructions but has an infinite number of registers.\n 4. Maps an infinite number of registers to a finite number of registers.\n 5. Generates x86-64 instructions from the IR.\n\nThere are a few important design choices that I made to keep the code as\nsimple as I can get:\n\n - Like 8cc, no memory management is the memory management policy in 9cc.\n   We allocate memory using malloc() but never call free().\n   I know that people find the policy odd, but this is actually a\n   reasonable design choice for short-lived programs such as compilers.\n   This policy greatly simplifies code and also eliminates use-after-free\n   bugs entirely.\n\n - 9cc's parser is a hand-written recursive descendent parser, so that the\n   compiler doesn't have any blackbox such as lex/yacc.\n\n - I stick with plain old tools such as Make or shell script so that you\n   don't need to learn about new stuff other than the compiler source code\n   itself.\n\n - We use brute force if it makes code simpler. We don't try too hard to\n   implement sophisticated data structures to make the compiler run faster.\n   If the performance becomes a problem, we can fix it at that moment.\n\n - Entire contents are loaded into memory at once if it makes code simpler.\n   We don't use character IO to read from an input file; instead, we read\n   an entire file to a char array in a batch. Likewise, we tokenize a\n   whole file in a batch rather than doing it concurrently with the parser.\n\nOverall, 9cc is still in its very early stage. I hope to continue\nimproving it to the point where 9cc can compile real-world C programs such\nas Linux kernel. That is an ambitious goal, but I believe it's achievable,\nso stay tuned!\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen_ir.c",
          "type": "blob",
          "size": 9.666015625,
          "content": "#include \"9cc.h\"\n\n// 9cc's code generation is two-pass. In the first pass, abstract\n// syntax trees are compiled to IR (intermediate representation).\n//\n// IR resembles the real x86-64 instruction set, but it has infinite\n// number of registers. We don't try too hard to reuse registers in\n// this pass. Instead, we \"kill\" registers to mark them as dead when\n// we are done with them and use new registers.\n//\n// Such infinite number of registers are mapped to a finite registers\n// in a later pass.\n\nstatic Function *fn;\nstatic BB *out;\nstatic int nreg = 1;\n\nstatic BB *new_bb() {\n  BB *bb = calloc(1, sizeof(BB));\n  bb->label = nlabel++;\n  bb->ir = new_vec();\n  bb->succ = new_vec();\n  bb->pred = new_vec();\n  bb->def_regs = new_vec();\n  bb->in_regs = new_vec();\n  bb->out_regs = new_vec();\n  vec_push(fn->bbs, bb);\n  return bb;\n}\n\nstatic IR *new_ir(int op) {\n  IR *ir = calloc(1, sizeof(IR));\n  ir->op = op;\n  vec_push(out->ir, ir);\n  return ir;\n}\n\nReg *new_reg() {\n  Reg *r = calloc(1, sizeof(Reg));\n  r->vn = nreg++;\n  r->rn = -1;\n  return r;\n}\n\nstatic IR *emit(int op, Reg *r0, Reg *r1, Reg *r2) {\n  IR *ir = new_ir(op);\n  ir->r0 = r0;\n  ir->r1 = r1;\n  ir->r2 = r2;\n  return ir;\n}\n\nstatic IR *br(Reg *r, BB *then, BB *els) {\n  IR *ir = new_ir(IR_BR);\n  ir->r2 = r;\n  ir->bb1 = then;\n  ir->bb2 = els;\n  return ir;\n}\n\nstatic IR *jmp(BB *bb) {\n  IR *ir = new_ir(IR_JMP);\n  ir->bb1 = bb;\n  return ir;\n}\n\nstatic IR *jmp_arg(BB *bb, Reg *r) {\n  IR *ir = new_ir(IR_JMP);\n  ir->bb1 = bb;\n  ir->bbarg = r;\n  return ir;\n}\n\nstatic Reg *imm(int imm) {\n  Reg *r = new_reg();\n  IR *ir = new_ir(IR_IMM);\n  ir->r0 = r;\n  ir->imm = imm;\n  return r;\n}\n\nstatic Reg *gen_expr(Node *node);\n\nstatic void load(Node *node, Reg *dst, Reg *src) {\n  IR *ir = emit(IR_LOAD, dst, NULL, src);\n  ir->size = node->ty->size;\n}\n\n// In C, all expressions that can be written on the left-hand side of\n// the '=' operator must have an address in memory. In other words, if\n// you can apply the '&' operator to take an address of some\n// expression E, you can assign E to a new value.\n//\n// Other expressions, such as `1+2`, cannot be written on the lhs of\n// '=', since they are just temporary values that don't have an address.\n//\n// The stuff that can be written on the lhs of '=' is called lvalue.\n// Other values are called rvalue. An lvalue is essentially an address.\n//\n// When lvalues appear on the rvalue context, they are converted to\n// rvalues by loading their values from their addresses. You can think\n// '&' as an operator that suppresses such automatic lvalue-to-rvalue\n// conversion.\n//\n// This function evaluates a given node as an lvalue.\nstatic Reg *gen_lval(Node *node) {\n  if (node->op == ND_DEREF)\n    return gen_expr(node->expr);\n\n  if (node->op == ND_DOT) {\n    Reg *r1 = new_reg();\n    Reg *r2 = gen_lval(node->expr);\n    Reg *r3 = imm(node->ty->offset);\n    emit(IR_ADD, r1, r2, r3);\n    return r1;\n  }\n\n  assert(node->op == ND_VARREF);\n  Var *var = node->var;\n\n  IR *ir;\n  if (var->is_local) {\n    ir = new_ir(IR_BPREL);\n    ir->r0 = new_reg();\n    ir->var = var;\n  } else {\n    ir = new_ir(IR_LABEL_ADDR);\n    ir->r0 = new_reg();\n    ir->name = var->name;\n  }\n  return ir->r0;\n}\n\nstatic Reg *gen_binop(int op, Node *node) {\n  Reg *r1 = new_reg();\n  Reg *r2 = gen_expr(node->lhs);\n  Reg *r3 = gen_expr(node->rhs);\n  emit(op, r1, r2, r3);\n  return r1;\n}\n\nstatic void gen_stmt(Node *node);\n\nstatic Reg *gen_expr(Node *node) {\n  switch (node->op) {\n  case ND_NUM:\n    return imm(node->val);\n  case ND_EQ:\n    return gen_binop(IR_EQ, node);\n  case ND_NE:\n    return gen_binop(IR_NE, node);\n  case ND_LOGAND: {\n    BB *bb = new_bb();\n    BB *set0 = new_bb();\n    BB *set1 = new_bb();\n    BB *last = new_bb();\n\n    br(gen_expr(node->lhs), bb, set0);\n\n    out = bb;\n    br(gen_expr(node->rhs), set1, set0);\n\n    out = set0;\n    jmp_arg(last, imm(0));\n\n    out = set1;\n    jmp_arg(last, imm(1));\n\n    out = last;\n    out->param = new_reg();\n    return out->param;\n  }\n  case ND_LOGOR: {\n    BB *bb = new_bb();\n    BB *set0 = new_bb();\n    BB *set1 = new_bb();\n    BB *last = new_bb();\n\n    Reg *r1 = gen_expr(node->lhs);\n    br(r1, set1, bb);\n\n    out = bb;\n    Reg *r2 = gen_expr(node->rhs);\n    br(r2, set1, set0);\n\n    out = set0;\n    jmp_arg(last, imm(0));\n\n    out = set1;\n    jmp_arg(last, imm(1));\n\n    out = last;\n    out->param = new_reg();\n    return out->param;\n  }\n  case ND_VARREF:\n  case ND_DOT: {\n    Reg *r = new_reg();\n    load(node, r, gen_lval(node));\n    return r;\n  }\n  case ND_CALL: {\n    Reg *args[6];\n    for (int i = 0; i < node->args->len; i++)\n      args[i] = gen_expr(node->args->data[i]);\n\n    IR *ir = new_ir(IR_CALL);\n    ir->r0 = new_reg();\n    ir->name = node->name;\n    ir->nargs = node->args->len;\n    memcpy(ir->args, args, sizeof(args));\n    return ir->r0;\n  }\n  case ND_ADDR:\n    return gen_lval(node->expr);\n  case ND_DEREF: {\n    Reg *r = new_reg();\n    load(node, r, gen_expr(node->expr));\n    return r;\n  }\n  case ND_CAST: {\n    Reg *r1 = gen_expr(node->expr);\n    if (node->ty->ty != BOOL)\n      return r1;\n    Reg *r2 = new_reg();\n    emit(IR_NE, r2, r1, imm(0));\n    return r2;\n  }\n  case ND_STMT_EXPR:\n    for (int i = 0; i < node->stmts->len; i++)\n      gen_stmt(node->stmts->data[i]);\n    return gen_expr(node->expr);\n  case '=': {\n    Reg *r1 = gen_expr(node->rhs);\n    Reg *r2 = gen_lval(node->lhs);\n\n    IR *ir = emit(IR_STORE, NULL, r2, r1);\n    ir->size = node->ty->size;\n    return r1;\n  }\n  case '+':\n    return gen_binop(IR_ADD, node);\n  case '-':\n    return gen_binop(IR_SUB, node);\n  case '*':\n    return gen_binop(IR_MUL, node);\n  case '/':\n    return gen_binop(IR_DIV, node);\n  case '%':\n    return gen_binop(IR_MOD, node);\n  case '<':\n    return gen_binop(IR_LT, node);\n  case ND_LE:\n    return gen_binop(IR_LE, node);\n  case '&':\n    return gen_binop(IR_AND, node);\n  case '|':\n    return gen_binop(IR_OR, node);\n  case '^':\n    return gen_binop(IR_XOR, node);\n  case ND_SHL:\n    return gen_binop(IR_SHL, node);\n  case ND_SHR:\n    return gen_binop(IR_SHR, node);\n  case '~': {\n    Reg *r1 = new_reg();\n    Reg *r2 = gen_expr(node->expr);\n    emit(IR_XOR, r1, r2, imm(-1));\n    return r1;\n  }\n  case ',':\n    gen_expr(node->lhs);\n    return gen_expr(node->rhs);\n  case '?': {\n    BB *then = new_bb();\n    BB *els = new_bb();\n    BB *last = new_bb();\n\n    br(gen_expr(node->cond), then, els);\n\n    out = then;\n    jmp_arg(last, gen_expr(node->then));\n\n    out = els;\n    jmp_arg(last, gen_expr(node->els));\n\n    out = last;\n    out->param = new_reg();\n    return out->param;\n  }\n  case '!': {\n    Reg *r1 = new_reg();\n    Reg *r2 = gen_expr(node->expr);\n    emit(IR_EQ, r1, r2, imm(0));\n    return r1;\n  }\n  default:\n    assert(0 && \"unknown AST type\");\n  }\n}\n\nstatic void gen_stmt(Node *node) {\n  switch (node->op) {\n  case ND_NULL:\n    return;\n  case ND_IF: {\n    BB *then = new_bb();\n    BB *els = new_bb();\n    BB *last = new_bb();\n\n    br(gen_expr(node->cond), then, els);\n\n    out = then;\n    gen_stmt(node->then);\n    jmp(last);\n\n    out = els;\n    if (node->els)\n      gen_stmt(node->els);\n    jmp(last);\n\n    out = last;\n    return;\n  }\n  case ND_FOR: {\n    BB *cond = new_bb();\n    node->continue_ = new_bb();\n    BB *body = new_bb();\n    node->break_ = new_bb();\n\n    if (node->init)\n      gen_stmt(node->init);\n    jmp(cond);\n\n    out = cond;\n    if (node->cond) {\n      Reg *r = gen_expr(node->cond);\n      br(r, body, node->break_);\n    } else {\n      jmp(body);\n    }\n\n    out = body;\n    gen_stmt(node->body);\n    jmp(node->continue_);\n\n    out = node->continue_;\n    if (node->inc)\n      gen_expr(node->inc);\n    jmp(cond);\n\n    out = node->break_;\n    return;\n  }\n  case ND_DO_WHILE: {\n    node->continue_ = new_bb();\n    BB *body = new_bb();\n    node->break_ = new_bb();\n\n    jmp(body);\n\n    out = body;\n    gen_stmt(node->body);\n    jmp(node->continue_);\n\n    out = node->continue_;\n    Reg *r = gen_expr(node->cond);\n    br(r, body, node->break_);\n\n    out = node->break_;\n    return;\n  }\n  case ND_SWITCH: {\n    node->break_ = new_bb();\n    node->continue_ = new_bb();\n\n    Reg *r = gen_expr(node->cond);\n    for (int i = 0; i < node->cases->len; i++) {\n      Node *case_ = node->cases->data[i];\n      case_->bb = new_bb();\n\n      BB *next = new_bb();\n      Reg *r2 = new_reg();\n      emit(IR_EQ, r2, r, imm(case_->val));\n      br(r2, case_->bb, next);\n      out = next;\n    }\n    jmp(node->break_);\n\n    gen_stmt(node->body);\n    jmp(node->break_);\n\n    out = node->break_;\n    return;\n  }\n  case ND_CASE:\n    jmp(node->bb);\n    out = node->bb;\n    gen_stmt(node->body);\n    break;\n  case ND_BREAK:\n    jmp(node->target->break_);\n    out = new_bb();\n    break;\n  case ND_CONTINUE:\n    jmp(node->target->continue_);\n    out = new_bb();\n    break;\n  case ND_RETURN: {\n    Reg *r = gen_expr(node->expr);\n    IR *ir = new_ir(IR_RETURN);\n    ir->r2 = r;\n    out = new_bb();\n    return;\n  }\n  case ND_EXPR_STMT:\n    gen_expr(node->expr);\n    return;\n  case ND_COMP_STMT:\n    for (int i = 0; i < node->stmts->len; i++)\n      gen_stmt(node->stmts->data[i]);\n    return;\n  default:\n    error(\"unknown node: %d\", node->op);\n  }\n}\n\nstatic void gen_param(Var *var, int i) {\n  IR *ir = new_ir(IR_STORE_ARG);\n  ir->var = var;\n  ir->imm = i;\n  ir->size = var->ty->size;\n  var->address_taken = true;\n}\n\nvoid gen_ir(Program *prog) {\n  for (int i = 0; i < prog->funcs->len; i++) {\n    fn = prog->funcs->data[i];\n\n    assert(fn->node->op == ND_FUNC);\n\n    // Add an empty entry BB to make later analysis easy.\n    out = new_bb();\n    BB *bb = new_bb();\n    jmp(bb);\n    out = bb;\n\n    // Emit IR.\n    Vector *params = fn->node->params;\n    for (int i = 0; i < params->len; i++)\n      gen_param(params->data[i], i);\n\n    gen_stmt(fn->node->body);\n\n    // Make it always ends with a return to make later analysis easy.\n    new_ir(IR_RETURN)->r2 = imm(0);\n\n    // Later passes shouldn't need the AST, so make it explicit.\n    fn->node = NULL;\n  }\n}\n"
        },
        {
          "name": "gen_x86.c",
          "type": "blob",
          "size": 6.2021484375,
          "content": "#include \"9cc.h\"\n\n// This pass generates x86-64 assembly from IR.\n\nchar *regs[] = {\"r10\", \"r11\", \"rbx\", \"r12\", \"r13\", \"r14\", \"r15\"};\nchar *regs8[] = {\"r10b\", \"r11b\", \"bl\", \"r12b\", \"r13b\", \"r14b\", \"r15b\"};\nchar *regs32[] = {\"r10d\", \"r11d\", \"ebx\", \"r12d\", \"r13d\", \"r14d\", \"r15d\"};\n\nint num_regs = sizeof(regs) / sizeof(*regs);\n\nstatic char *argregs[] = {\"rdi\", \"rsi\", \"rdx\", \"rcx\", \"r8\", \"r9\"};\nstatic char *argregs8[] = {\"dil\", \"sil\", \"dl\", \"cl\", \"r8b\", \"r9b\"};\nstatic char *argregs32[] = {\"edi\", \"esi\", \"edx\", \"ecx\", \"r8d\", \"r9d\"};\n\n__attribute__((format(printf, 1, 2))) static void p(char *fmt, ...);\n__attribute__((format(printf, 1, 2))) static void emit(char *fmt, ...);\n\nstatic void p(char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  vprintf(fmt, ap);\n  printf(\"\\n\");\n}\n\nstatic void emit(char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  printf(\"\\t\");\n  vprintf(fmt, ap);\n  printf(\"\\n\");\n}\n\nstatic void emit_cmp(char *insn, IR *ir) {\n  int r0 = ir->r0->rn;\n  int r1 = ir->r1->rn;\n  int r2 = ir->r2->rn;\n\n  emit(\"cmp %s, %s\", regs[r1], regs[r2]);\n  emit(\"%s %s\", insn, regs8[r0]);\n  emit(\"movzb %s, %s\", regs[r0], regs8[r0]);\n}\n\nstatic char *reg(int r, int size) {\n  if (size == 1)\n    return regs8[r];\n  if (size == 4)\n    return regs32[r];\n  assert(size == 8);\n  return regs[r];\n}\n\nstatic char *argreg(int r, int size) {\n  if (size == 1)\n    return argregs8[r];\n  if (size == 4)\n    return argregs32[r];\n  assert(size == 8);\n  return argregs[r];\n}\n\nstatic void emit_ir(IR *ir, char *ret) {\n  int r0 = ir->r0 ? ir->r0->rn : 0;\n  int r1 = ir->r1 ? ir->r1->rn : 0;\n  int r2 = ir->r2 ? ir->r2->rn : 0;\n\n  switch (ir->op) {\n  case IR_IMM:\n    emit(\"mov %s, %d\", regs[r0], ir->imm);\n    break;\n  case IR_BPREL:\n    emit(\"lea %s, [rbp%d]\", regs[r0], ir->var->offset);\n    break;\n  case IR_MOV:\n    emit(\"mov %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_RETURN:\n    emit(\"mov rax, %s\", regs[r2]);\n    emit(\"jmp %s\", ret);\n    break;\n  case IR_CALL:\n    for (int i = 0; i < ir->nargs; i++)\n      emit(\"mov %s, %s\", argregs[i], regs[ir->args[i]->rn]);\n\n    emit(\"push r10\");\n    emit(\"push r11\");\n    emit(\"mov rax, 0\");\n    emit(\"call %s\", ir->name);\n    emit(\"pop r11\");\n    emit(\"pop r10\");\n    emit(\"mov %s, rax\", regs[r0]);\n    break;\n  case IR_LABEL_ADDR:\n    emit(\"lea %s, %s\", regs[r0], ir->name);\n    break;\n  case IR_EQ:\n    emit_cmp(\"sete\", ir);\n    break;\n  case IR_NE:\n    emit_cmp(\"setne\", ir);\n    break;\n  case IR_LT:\n    emit_cmp(\"setl\", ir);\n    break;\n  case IR_LE:\n    emit_cmp(\"setle\", ir);\n    break;\n  case IR_AND:\n    emit(\"and %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_OR:\n    emit(\"or %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_XOR:\n    emit(\"xor %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_SHL:\n    emit(\"mov cl, %s\", regs8[r2]);\n    emit(\"shl %s, cl\", regs[r0]);\n    break;\n  case IR_SHR:\n    emit(\"mov cl, %s\", regs8[r2]);\n    emit(\"shr %s, cl\", regs[r0]);\n    break;\n  case IR_JMP:\n    if (ir->bbarg)\n      emit(\"mov %s, %s\", regs[ir->bb1->param->rn], regs[ir->bbarg->rn]);\n    emit(\"jmp .L%d\", ir->bb1->label);\n    break;\n  case IR_BR:\n    emit(\"cmp %s, 0\", regs[r2]);\n    emit(\"jne .L%d\", ir->bb1->label);\n    emit(\"jmp .L%d\", ir->bb2->label);\n    break;\n  case IR_LOAD:\n    emit(\"mov %s, [%s]\", reg(r0, ir->size), regs[r2]);\n    if (ir->size == 1)\n      emit(\"movzb %s, %s\", regs[r0], regs8[r0]);\n    break;\n  case IR_LOAD_SPILL:\n    emit(\"mov %s, [rbp%d]\", regs[r0], ir->var->offset);\n    break;\n  case IR_STORE:\n    emit(\"mov [%s], %s\", regs[r1], reg(r2, ir->size));\n    break;\n  case IR_STORE_ARG:\n    emit(\"mov [rbp%d], %s\", ir->var->offset, argreg(ir->imm, ir->size));\n    break;\n  case IR_STORE_SPILL:\n    emit(\"mov [rbp%d], %s\", ir->var->offset, regs[r1]);\n    break;\n  case IR_ADD:\n    emit(\"add %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_SUB:\n    emit(\"sub %s, %s\", regs[r0], regs[r2]);\n    break;\n  case IR_MUL:\n    emit(\"mov rax, %s\", regs[r2]);\n    emit(\"imul %s\", regs[r0]);\n    emit(\"mov %s, rax\", regs[r0]);\n    break;\n  case IR_DIV:\n    emit(\"mov rax, %s\", regs[r0]);\n    emit(\"cqo\");\n    emit(\"idiv %s\", regs[r2]);\n    emit(\"mov %s, rax\", regs[r0]);\n    break;\n  case IR_MOD:\n    emit(\"mov rax, %s\", regs[r0]);\n    emit(\"cqo\");\n    emit(\"idiv %s\", regs[r2]);\n    emit(\"mov %s, rdx\", regs[r0]);\n    break;\n  case IR_NOP:\n    break;\n  default:\n    assert(0 && \"unknown operator\");\n  }\n}\n\nvoid emit_code(Function *fn) {\n  // Assign an offset from RBP to each local variable.\n  int off = 0;\n  for (int i = 0; i < fn->lvars->len; i++) {\n    Var *var = fn->lvars->data[i];\n    off += var->ty->size;\n    off = roundup(off, var->ty->align);\n    var->offset = -off;\n  }\n\n  // Emit assembly\n  char *ret = format(\".Lend%d\", nlabel++);\n\n  p(\".text\");\n  p(\".global %s\", fn->name);\n  p(\"%s:\", fn->name);\n  emit(\"push rbp\");\n  emit(\"mov rbp, rsp\");\n  emit(\"sub rsp, %d\", roundup(off, 16));\n  emit(\"push r12\");\n  emit(\"push r13\");\n  emit(\"push r14\");\n  emit(\"push r15\");\n\n  for (int i = 0; i < fn->bbs->len; i++) {\n    BB *bb = fn->bbs->data[i];\n    p(\".L%d:\", bb->label);\n    for (int i = 0; i < bb->ir->len; i++) {\n      IR *ir = bb->ir->data[i];\n      emit_ir(ir, ret);\n    }\n  }\n\n  p(\"%s:\", ret);\n  emit(\"pop r15\");\n  emit(\"pop r14\");\n  emit(\"pop r13\");\n  emit(\"pop r12\");\n  emit(\"mov rsp, rbp\");\n  emit(\"pop rbp\");\n  emit(\"ret\");\n}\n\nstatic char *backslash_escape(char *s, int len) {\n  static char escaped[256] = {\n          ['\\b'] = 'b', ['\\f'] = 'f',  ['\\n'] = 'n',  ['\\r'] = 'r',\n          ['\\t'] = 't', ['\\\\'] = '\\\\', ['\\''] = '\\'', ['\"'] = '\"',\n  };\n\n  StringBuilder *sb = new_sb();\n  for (int i = 0; i < len; i++) {\n    uint8_t c = s[i];\n    char esc = escaped[c];\n    if (esc) {\n      sb_add(sb, '\\\\');\n      sb_add(sb, esc);\n    } else if (isgraph(c) || c == ' ') {\n      sb_add(sb, c);\n    } else {\n      sb_append(sb, format(\"\\\\%03o\", c));\n    }\n  }\n  return sb_get(sb);\n}\n\nstatic void emit_data(Var *var) {\n  if (var->data) {\n    p(\".data\");\n    p(\"%s:\", var->name);\n    emit(\".ascii \\\"%s\\\"\", backslash_escape(var->data, var->ty->size));\n    return;\n  }\n\n  p(\".bss\");\n  p(\"%s:\", var->name);\n  emit(\".zero %d\", var->ty->size);\n}\n\nvoid gen_x86(Program *prog) {\n  p(\".intel_syntax noprefix\");\n\n  for (int i = 0; i < prog->gvars->len; i++)\n    emit_data(prog->gvars->data[i]);\n\n  for (int i = 0; i < prog->funcs->len; i++)\n    emit_code(prog->funcs->data[i]);\n}\n"
        },
        {
          "name": "irdump.c",
          "type": "blob",
          "size": 3.78515625,
          "content": "#include \"9cc.h\"\n\nstatic int regno(Reg *r) {\n  if (!r)\n    return 0;\n  if (r->rn != -1)\n    return r->rn;\n  return r->vn;\n}\n\nstatic char *tostr_call(IR *ir) {\n  StringBuilder *sb = new_sb();\n  sb_append(sb, format(\"r%d = %s(\", regno(ir->r0), ir->name));\n  for (int i = 0; i < ir->nargs; i++) {\n    if (i != 0)\n      sb_append(sb, \", \");\n    sb_append(sb, format(\"r%d\", regno(ir->args[i])));\n  }\n  sb_append(sb, \")\");\n  return sb_get(sb);\n}\n\nstatic char *tostr(IR *ir) {\n  int r0 = regno(ir->r0);\n  int r1 = regno(ir->r1);\n  int r2 = regno(ir->r2);\n\n  switch (ir->op) {\n  case IR_ADD:\n    return format(\"r%d = r%d + r%d\", r0, r1, r2);\n  case IR_CALL:\n    return tostr_call(ir);\n  case IR_DIV:\n    return format(\"r%d = r%d / r%d\", r0, r1, r2);\n  case IR_IMM:\n    return format(\"r%d = %d\", r0, ir->imm);\n  case IR_JMP:\n    if (ir->bbarg)\n      return format(\"JMP .L%d (r%d)\", ir->bb1->label, regno(ir->bbarg));\n    return format(\"JMP .L%d\", ir->bb1->label);\n  case IR_LABEL_ADDR:\n    return format(\"r%d = .L%d\", r0, ir->label);\n  case IR_EQ:\n    return format(\"r%d = r%d == r%d\", r0, r1, r2);\n  case IR_NE:\n    return format(\"r%d = r%d != r%d\", r0, r1, r2);\n  case IR_LE:\n    return format(\"r%d = r%d <= r%d\", r0, r1, r2);\n  case IR_LT:\n    return format(\"r%d = r%d < r%d\", r0, r1, r2);\n  case IR_AND:\n    return format(\"r%d = r%d & r%d\", r0, r1, r2);\n  case IR_OR:\n    return format(\"r%d = r%d | r%d\", r0, r1, r2);\n  case IR_XOR:\n    return format(\"r%d = r%d ^ r%d\", r0, r1, r2);\n  case IR_SHL:\n    return format(\"r%d = r%d << r%d\", r0, r1, r2);\n  case IR_SHR:\n    return format(\"r%d = r%d >> r%d\", r0, r1, r2);\n  case IR_LOAD:\n    return format(\"LOAD%d r%d, r%d\", ir->size, r0, r2);\n  case IR_LOAD_SPILL:\n    return format(\"LOAD_SPILL r%d, %d\", r0, ir->imm);\n  case IR_MOD:\n    return format(\"r%d = r%d %% r%d\", r0, r1, r2);\n  case IR_MOV:\n    return format(\"r%d = r%d\", r0, r2);\n  case IR_MUL:\n    return format(\"r%d = r%d * r%d\", r0, r1, r2);\n  case IR_NOP:\n    return \"NOP\";\n  case IR_RETURN:\n    return format(\"RET r%d\", r2);\n  case IR_STORE:\n    return format(\"STORE%d r%d, r%d\", ir->size, r1, r2);\n  case IR_STORE_ARG:\n    return format(\"STORE_ARG%d %d %s (%d)\", ir->size, ir->imm, ir->var->name,\n                  ir->var->offset);\n  case IR_STORE_SPILL:\n    return format(\"STORE_SPILL r%d, %d\", r1, ir->imm);\n  case IR_SUB:\n    return format(\"r%d = r%d - r%d\", r0, r1, r2);\n  case IR_BPREL:\n    return format(\"BPREL r%d %s (%d)\", r0, ir->var->name, ir->var->offset);\n  case IR_BR:\n    return format(\"BR r%d .L%d .L%d\", r2, ir->bb1->label, ir->bb2->label);\n  default:\n    assert(0 && \"unknown op\");\n  }\n}\n\nstatic void print_rel(char *name, Vector *v) {\n  if (v->len == 0)\n    return;\n  fprintf(stderr, \" %s=\", name);\n  for (int i = 0; i < v->len; i++) {\n    BB *bb = v->data[i];\n    if (i > 0)\n      fprintf(stderr, \",\");\n    fprintf(stderr, \".L%d\", bb->label);\n  }\n}\n\nstatic void print_regs(char *name, Vector *v) {\n  if (v->len == 0)\n    return;\n  fprintf(stderr, \" %s=\", name);\n  for (int i = 0; i < v->len; i++) {\n    Reg *r = v->data[i];\n    if (i > 0)\n      fprintf(stderr, \",\");\n    fprintf(stderr, \"r%d\", regno(r));\n  }\n}\n\nstatic void print_bb(BB *bb) {\n  if (bb->param)\n    fprintf(stderr, \".L%d(r%d)\", bb->label, regno(bb->param));\n  else\n    fprintf(stderr, \".L%d\", bb->label);\n\n  print_rel(\"pred\", bb->pred);\n  print_rel(\"succ\", bb->succ);\n  print_regs(\"defs\", bb->def_regs);\n  print_regs(\"in\", bb->in_regs);\n  print_regs(\"out\", bb->out_regs);\n  fprintf(stderr, \"\\n\");\n}\n\nvoid dump_ir(Vector *irv) {\n  for (int i = 0; i < irv->len; i++) {\n    Function *fn = irv->data[i];\n    fprintf(stderr, \"%s:\\n\", fn->name);\n\n    for (int i = 0; i < fn->bbs->len; i++) {\n      BB *bb = fn->bbs->data[i];\n      print_bb(bb);\n\n      for (int i = 0; i < bb->ir->len; i++) {\n        IR *ir = bb->ir->data[i];\n        fprintf(stderr, \"\\t%s\\n\", tostr(ir));\n      }\n    }\n  }\n}\n"
        },
        {
          "name": "liveness.c",
          "type": "blob",
          "size": 2.083984375,
          "content": "// Liveness analysis.\n\n#include \"9cc.h\"\n\n// Fill bb->succ and bb->pred.\nstatic void add_edges(BB *bb) {\n  if (bb->succ->len > 0)\n    return;\n  assert(bb->ir->len);\n\n  IR *ir = bb->ir->data[bb->ir->len - 1];\n\n  if (ir->bb1) {\n    vec_push(bb->succ, ir->bb1);\n    vec_push(ir->bb1->pred, bb);\n    add_edges(ir->bb1);\n  }\n\n  if (ir->bb2) {\n    vec_push(bb->succ, ir->bb2);\n    vec_push(ir->bb2->pred, bb);\n    add_edges(ir->bb2);\n  }\n}\n\n// Initializes bb->def_regs.\nstatic void set_def_regs(BB *bb) {\n  if (bb->param)\n    vec_union1(bb->def_regs, bb->param);\n\n  for (int i = 0; i < bb->ir->len; i++) {\n    IR *ir = bb->ir->data[i];\n    if (ir->r0)\n      vec_union1(bb->def_regs, ir->r0);\n  }\n}\n\n// Back-propagate r in the call flow graph.\nstatic void propagate(BB *bb, Reg *r) {\n  if (!r || vec_contains(bb->def_regs, r))\n    return;\n\n  if (!vec_union1(bb->in_regs, r))\n    return;\n\n  for (int i = 0; i < bb->pred->len; i++) {\n    BB *pred = bb->pred->data[i];\n    if (vec_union1(pred->out_regs, r))\n      propagate(pred, r);\n  }\n}\n\n// Initializes bb->in_regs and bb->out_regs.\nstatic void visit(BB *bb, IR *ir) {\n  propagate(bb, ir->r1);\n  propagate(bb, ir->r2);\n  propagate(bb, ir->bbarg);\n\n  if (ir->op == IR_CALL)\n    for (int i = 0; i < ir->nargs; i++)\n      propagate(bb, ir->args[i]);\n}\n\nvoid liveness(Program *prog) {\n  for (int i = 0; i < prog->funcs->len; i++) {\n    Function *fn = prog->funcs->data[i];\n    add_edges(fn->bbs->data[0]);\n\n    for (int i = 0; i < fn->bbs->len; i++) {\n      BB *bb = fn->bbs->data[i];\n      set_def_regs(bb);\n\n      for (int i = 0; i < bb->ir->len; i++) {\n\tIR *ir = bb->ir->data[i];\n\tvisit(bb, ir);\n      }\n    }\n\n    // Incoming registers of the entry BB correspond to\n    // uninitialized variables in a program.\n    // Add dummy definitions to make later analysis easy.\n    BB *ent = fn->bbs->data[0];\n    for (int i = 0; i < ent->in_regs->len; i++) {\n      Reg *r = ent->in_regs->data[i];\n      IR *ir = calloc(1, sizeof(IR));\n      ir->op = IR_MOV;\n      ir->r0 = r;\n      ir->imm = 0;\n      vec_push(ent->ir, ir);\n      vec_push(ent->def_regs, r);\n    }\n    ent->in_regs = new_vec();\n  }\n}\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 0.8583984375,
          "content": "#include \"9cc.h\"\n\nvoid usage() {\n  error(\"Usage: 9cc [-test] [-dump-ir1] [-dump-ir2] <file>\");\n}\n\nint main(int argc, char **argv) {\n  if (argc == 1)\n    usage();\n\n  if (argc == 2 && !strcmp(argv[1], \"-test\")) {\n    util_test();\n    return 0;\n  }\n\n  char *path;\n  bool dump_ir1 = false;\n  bool dump_ir2 = false;\n\n  if (argc == 3 && !strcmp(argv[1], \"-dump-ir1\")) {\n    dump_ir1 = true;\n    path = argv[2];\n  } else if (argc == 3 && !strcmp(argv[1], \"-dump-ir2\")) {\n    dump_ir2 = true;\n    path = argv[2];\n  } else {\n    if (argc != 2)\n      usage();\n    path = argv[1];\n  }\n\n  // Tokenize and parse.\n  Vector *tokens = tokenize(path, true);\n  Program *prog = parse(tokens);\n  sema(prog);\n  gen_ir(prog);\n\n  if (dump_ir1)\n    dump_ir(prog->funcs);\n\n  optimize(prog);\n  liveness(prog);\n  alloc_regs(prog);\n\n  if (dump_ir2)\n    dump_ir(prog->funcs);\n\n  gen_x86(prog);\n  return 0;\n}\n"
        },
        {
          "name": "opt.c",
          "type": "blob",
          "size": 1.22265625,
          "content": "// Optimization pass. In this pass, we promote all non-address-taken\n// integer variables to register values. As a result, we may have more\n// register values than the number of the physical registers, but\n// that's fine. Regalloc will spill them out to memory.\n\n#include \"9cc.h\"\n\n// Rewrite\n//\n//  BPREL r1, <offset>\n//  STORE r1, r2\n//  LOAD  r3, r1\n//\n// to\n//\n//  NOP\n//  r4 = r2\n//  r3 = r4\nstatic void opt(IR *ir) {\n  if (ir->op == IR_BPREL) {\n    Var *var = ir->var;\n    if (var->address_taken || var->ty->ty != INT)\n      return;\n\n    if (!var->promoted)\n      var->promoted = new_reg();\n\n    ir->op = IR_NOP;\n    ir->r0->promoted = var->promoted;\n    return;\n  }\n\n  if (ir->op == IR_LOAD) {\n    if (!ir->r2->promoted)\n      return;\n    ir->op = IR_MOV;\n    ir->r2 = ir->r2->promoted;\n    return;\n  }\n\n  if (ir->op == IR_STORE) {\n    if (!ir->r1->promoted)\n      return;\n    ir->op = IR_MOV;\n    ir->r0 = ir->r1->promoted;\n    ir->r1 = NULL;\n    return;\n  }\n}\n\nvoid optimize(Program *prog) {\n  for (int i = 0; i < prog->funcs->len; i++) {\n    Function *fn = prog->funcs->data[i];\n    for (int i = 0; i < fn->bbs->len; i++) {\n      BB *bb = fn->bbs->data[i];\n      for (int i = 0; i < bb->ir->len; i++)\n        opt(bb->ir->data[i]);\n    }\n  }\n}\n"
        },
        {
          "name": "parse.c",
          "type": "blob",
          "size": 20.3271484375,
          "content": "#include \"9cc.h\"\n\n// This is a recursive-descendent parser which constructs abstract\n// syntax tree from input tokens.\n//\n// Variable names are resolved at this stage. We create a Var object\n// when we see a variable definition and use it when we see a variable\n// reference.\n//\n// Types are added to variables and literals. For other nodes, Sema\n// will add type for them.\n//\n// Semantic checking is omitted from this parser to make the code in\n// this file closely resemble the C's BNF. Invalid expressions, such\n// as `1+2=3`, are accepted at this stage. Such errors are detected in\n// a later pass.\n\nint nlabel = 1;\n\ntypedef struct Env {\n  Map *vars;\n  Map *typedefs;\n  Map *tags;\n  struct Env *prev;\n} Env;\n\nstatic Program *prog;\nstatic Vector *lvars;\nstatic Vector *breaks;\nstatic Vector *continues;\nstatic Vector *switches;\n\nstatic Vector *tokens;\nstatic int pos;\nstruct Env *env;\n\nstatic Node null_stmt = {ND_NULL};\n\nstatic Env *new_env(Env *prev) {\n  Env *env = calloc(1, sizeof(Env));\n  env->vars = new_map();\n  env->typedefs = new_map();\n  env->tags = new_map();\n  env->prev = prev;\n  return env;\n}\n\nstatic Var *find_var(char *name) {\n  for (Env *e = env; e; e = e->prev) {\n    Var *var = map_get(e->vars, name);\n    if (var)\n      return var;\n  }\n  return NULL;\n}\n\nstatic Type *find_typedef(char *name) {\n  for (Env *e = env; e; e = e->prev) {\n    Type *ty = map_get(e->typedefs, name);\n    if (ty)\n      return ty;\n  }\n  return NULL;\n}\n\nstatic Type *find_tag(char *name) {\n  for (Env *e = env; e; e = e->prev) {\n    Type *ty = map_get(e->tags, name);\n    if (ty)\n      return ty;\n  }\n  return NULL;\n}\n\nstatic Var *add_lvar(Type *ty, char *name) {\n  Var *var = calloc(1, sizeof(Var));\n  var->ty = ty;\n  var->is_local = true;\n  var->name = name;\n  map_put(env->vars, name, var);\n  vec_push(lvars, var);\n  return var;\n}\n\nstatic Var *add_gvar(Type *ty, char *name, char *data, bool is_extern) {\n  Var *var = calloc(1, sizeof(Var));\n  var->ty = ty;\n  var->is_local = false;\n  var->name = name;\n  var->data = data;\n  map_put(env->vars, name, var);\n  if (!is_extern)\n    vec_push(prog->gvars, var);\n  return var;\n}\n\nstatic Node *assign();\nstatic Node *expr();\nstatic Node *stmt();\n\nstatic void expect(int ty) {\n  Token *t = tokens->data[pos];\n  if (t->ty == ty) {\n    pos++;\n    return;\n  }\n\n  if (isprint(ty))\n    bad_token(t, format(\"%c expected\", ty));\n  assert(ty == TK_WHILE);\n  bad_token(t, \"'while' expected\");\n}\n\nstatic bool consume(int ty) {\n  Token *t = tokens->data[pos];\n  if (t->ty != ty)\n    return false;\n  pos++;\n  return true;\n}\n\nstatic bool is_typename() {\n  Token *t = tokens->data[pos];\n  if (t->ty == TK_IDENT)\n    return find_typedef(t->name);\n  return t->ty == TK_INT || t->ty == TK_CHAR || t->ty == TK_VOID ||\n         t->ty == TK_STRUCT || t->ty == TK_TYPEOF || t->ty == TK_BOOL;\n}\n\nstatic Node *declaration_type();\n\nstatic void fix_struct_offsets(Type *ty) {\n  Vector *types = ty->members->vals;\n\n  int off = 0;\n  for (int i = 0; i < types->len; i++) {\n    Type *t2 = types->data[i];\n    off = roundup(off, t2->align);\n    t2->offset = off;\n    off += t2->size;\n\n    if (ty->align < t2->align)\n      ty->align = t2->align;\n  }\n  ty->size = roundup(off, ty->align);\n}\n\nstatic Type *decl_specifiers() {\n  Token *t = tokens->data[pos++];\n\n  if (t->ty == TK_IDENT) {\n    Type *ty = find_typedef(t->name);\n    if (!ty)\n      pos--;\n    return ty;\n  }\n\n  if (t->ty == TK_VOID)\n    return void_ty();\n  if (t->ty == TK_BOOL)\n    return bool_ty();\n  if (t->ty == TK_CHAR)\n    return char_ty();\n  if (t->ty == TK_INT)\n    return int_ty();\n\n  if (t->ty == TK_TYPEOF) {\n    expect('(');\n    Node *node = expr();\n    expect(')');\n    return get_type(node);\n  }\n\n  if (t->ty == TK_STRUCT) {\n    Token *t = tokens->data[pos];\n    Type *ty = NULL;\n    char *tag = NULL;\n\n    if (t->ty == TK_IDENT) {\n      pos++;\n      tag = t->name;\n      ty = find_tag(tag);\n    }\n\n    if (!ty) {\n      ty = calloc(1, sizeof(Type));\n      ty->ty = STRUCT;\n    }\n\n    if (consume('{')) {\n      ty->members = new_map();\n      while (!consume('}')) {\n        Node *node = declaration_type();\n        map_put(ty->members, node->name, node->ty);\n      }\n      fix_struct_offsets(ty);\n    }\n\n    if (!tag && !ty->members)\n      bad_token(t, \"bad struct definition\");\n    if (tag)\n      map_put(env->tags, tag, ty);\n    return ty;\n  }\n\n  bad_token(t, \"typename expected\");\n}\n\nstatic Node *new_node(int op, Token *t) {\n  Node *node = calloc(1, sizeof(Node));\n  node->op = op;\n  node->token = t;\n  return node;\n}\n\nstatic Node *new_binop(int op, Token *t, Node *lhs, Node *rhs) {\n  Node *node = new_node(op, t);\n  node->lhs = lhs;\n  node->rhs = rhs;\n  return node;\n}\n\nstatic Node *new_expr(int op, Token *t, Node *expr) {\n  Node *node = new_node(op, t);\n  node->expr = expr;\n  return node;\n}\n\nstatic Node *new_varref(Token *t, Var *var) {\n  Node *node = new_node(ND_VARREF, t);\n  node->ty = var->ty;\n  node->var = var;\n  return node;\n}\n\nstatic Node *new_deref(Token *t, Var *var) {\n  return new_expr(ND_DEREF, t, new_varref(t, var));\n}\n\nNode *new_int_node(int val, Token *t) {\n  Node *node = new_node(ND_NUM, t);\n  node->ty = int_ty();\n  node->val = val;\n  return node;\n}\n\nstatic Node *compound_stmt();\n\nstatic char *ident() {\n  Token *t = tokens->data[pos++];\n  if (t->ty != TK_IDENT)\n    bad_token(t, \"identifier expected\");\n  return t->name;\n}\n\nstatic Node *string_literal(Token *t) {\n  Type *ty = ary_of(char_ty(), t->len);\n  char *name = format(\".L.str%d\", nlabel++);\n\n  Node *node = new_node(ND_VARREF, t);\n  node->ty = ty;\n  node->var = add_gvar(ty, name, t->str, false);\n  return node;\n}\n\nstatic Node *local_variable(Token *t) {\n  Var *var = find_var(t->name);\n  if (!var)\n    bad_token(t, \"undefined variable\");\n  Node *node = new_node(ND_VARREF, t);\n  node->ty = var->ty;\n  node->name = t->name;\n  node->var = var;\n  return node;\n}\n\nstatic Node *function_call(Token *t) {\n  Var *var = find_var(t->name);\n\n  Node *node = new_node(ND_CALL, t);\n  node->name = t->name;\n  node->args = new_vec();\n\n  if (var && var->ty->ty == FUNC) {\n    node->ty = var->ty;\n  } else {\n    warn_token(t, \"undefined function\");\n    node->ty = func_ty(int_ty());\n  }\n\n  while (!consume(')')) {\n    if (node->args->len > 0)\n      expect(',');\n    vec_push(node->args, assign());\n  }\n  return node;\n}\n\nstatic Node *stmt_expr() {\n  Token *t = tokens->data[pos];\n  Vector *v = new_vec();\n\n  env = new_env(env);\n  do {\n    vec_push(v, stmt());\n  } while (!consume('}'));\n  expect(')');\n  env = env->prev;\n\n  Node *last = vec_pop(v);\n  if (last->op != ND_EXPR_STMT)\n    bad_token(last->token, \"statement expression returning void\");\n\n  Node *node = new_node(ND_STMT_EXPR, t);\n  node->stmts = v;\n  node->expr = last->expr;\n  return node;\n}\n\nstatic Node *primary() {\n  Token *t = tokens->data[pos++];\n\n  if (t->ty == '(') {\n    if (consume('{'))\n      return stmt_expr();\n    Node *node = expr();\n    expect(')');\n    return node;\n  }\n\n  if (t->ty == TK_NUM)\n    return new_int_node(t->val, t);\n\n  if (t->ty == TK_STR)\n    return string_literal(t);\n\n  if (t->ty == TK_IDENT) {\n    if (consume('('))\n      return function_call(t);\n    return local_variable(t);\n  }\n\n  bad_token(t, \"primary expression expected\");\n}\n\nstatic Node *mul();\n\nstatic Node *new_stmt_expr(Token *t, Vector *exprs) {\n  Node *last = vec_pop(exprs);\n\n  Vector *v = new_vec();\n  for (int i = 0; i < exprs->len; i++)\n    vec_push(v, new_expr(ND_EXPR_STMT, t, exprs->data[i]));\n\n  Node *node = new_node(ND_STMT_EXPR, t);\n  node->stmts = v;\n  node->expr = last;\n  return node;\n}\n\n// `x++` where x is of type T is compiled as\n// `({ T *y = &x; T z = *y; *y = *y + 1; *z; })`.\nstatic Node *new_post_inc(Token *t, Node *e, int imm) {\n  Vector *v = new_vec();\n\n  Var *var1 = add_lvar(ptr_to(e->ty), \"tmp\");\n  Var *var2 = add_lvar(e->ty, \"tmp\");\n\n  vec_push(v, new_binop('=', t, new_varref(t, var1), new_expr(ND_ADDR, t, e)));\n  vec_push(v, new_binop('=', t, new_varref(t, var2), new_deref(t, var1)));\n  vec_push(v, new_binop(\n                  '=', t, new_deref(t, var1),\n                  new_binop('+', t, new_deref(t, var1), new_int_node(imm, t))));\n  vec_push(v, new_varref(t, var2));\n  return new_stmt_expr(t, v);\n}\n\nstatic Node *postfix() {\n  Node *lhs = primary();\n\n  for (;;) {\n    Token *t = tokens->data[pos];\n\n    if (consume(TK_INC)) {\n      lhs = new_post_inc(t, lhs, 1);\n      continue;\n    }\n\n    if (consume(TK_DEC)) {\n      lhs = new_post_inc(t, lhs, -1);\n      continue;\n    }\n\n    if (consume('.')) {\n      lhs = new_expr(ND_DOT, t, lhs);\n      lhs->name = ident();\n      continue;\n    }\n\n    if (consume(TK_ARROW)) {\n      lhs = new_expr(ND_DOT, t, new_expr(ND_DEREF, t, lhs));\n      lhs->name = ident();\n      continue;\n    }\n\n    if (consume('[')) {\n      Node *node = new_binop('+', t, lhs, assign());\n      lhs = new_expr(ND_DEREF, t, node);\n      expect(']');\n      continue;\n    }\n    return lhs;\n  }\n}\n\nstatic Node *new_assign_eq(int op, Node *lhs, Node *rhs);\n\nstatic Node *unary() {\n  Token *t = tokens->data[pos];\n\n  if (consume('-'))\n    return new_binop('-', t, new_int_node(0, t), unary());\n  if (consume('*'))\n    return new_expr(ND_DEREF, t, unary());\n  if (consume('&'))\n    return new_expr(ND_ADDR, t, unary());\n  if (consume('!'))\n    return new_expr('!', t, unary());\n  if (consume('~'))\n    return new_expr('~', t, unary());\n  if (consume(TK_SIZEOF))\n    return new_int_node(get_type(unary())->size, t);\n  if (consume(TK_ALIGNOF))\n    return new_int_node(get_type(unary())->align, t);\n  if (consume(TK_INC))\n    return new_assign_eq('+', unary(), new_int_node(1, t));\n  if (consume(TK_DEC))\n    return new_assign_eq('-', unary(), new_int_node(1, t));\n  return postfix();\n}\n\nstatic Node *mul() {\n  Node *lhs = unary();\n  for (;;) {\n    Token *t = tokens->data[pos];\n    if (consume('*'))\n      lhs = new_binop('*', t, lhs, unary());\n    else if (consume('/'))\n      lhs = new_binop('/', t, lhs, unary());\n    else if (consume('%'))\n      lhs = new_binop('%', t, lhs, unary());\n    else\n      return lhs;\n  }\n}\n\nstatic Node *add() {\n  Node *lhs = mul();\n  for (;;) {\n    Token *t = tokens->data[pos];\n    if (consume('+'))\n      lhs = new_binop('+', t, lhs, mul());\n    else if (consume('-'))\n      lhs = new_binop('-', t, lhs, mul());\n    else\n      return lhs;\n  }\n}\n\nstatic Node *shift() {\n  Node *lhs = add();\n  for (;;) {\n    Token *t = tokens->data[pos];\n    if (consume(TK_SHL))\n      lhs = new_binop(ND_SHL, t, lhs, add());\n    else if (consume(TK_SHR))\n      lhs = new_binop(ND_SHR, t, lhs, add());\n    else\n      return lhs;\n  }\n}\n\nstatic Node *relational() {\n  Node *lhs = shift();\n  for (;;) {\n    Token *t = tokens->data[pos];\n    if (consume('<'))\n      lhs = new_binop('<', t, lhs, shift());\n    else if (consume('>'))\n      lhs = new_binop('<', t, shift(), lhs);\n    else if (consume(TK_LE))\n      lhs = new_binop(ND_LE, t, lhs, shift());\n    else if (consume(TK_GE))\n      lhs = new_binop(ND_LE, t, shift(), lhs);\n    else\n      return lhs;\n  }\n}\n\nstatic Node *equality() {\n  Node *lhs = relational();\n  for (;;) {\n    Token *t = tokens->data[pos];\n    if (consume(TK_EQ))\n      lhs = new_binop(ND_EQ, t, lhs, relational());\n    else if (consume(TK_NE))\n      lhs = new_binop(ND_NE, t, lhs, relational());\n    else\n      return lhs;\n  }\n}\n\nstatic Node *bit_and() {\n  Node *lhs = equality();\n  while (consume('&')) {\n    Token *t = tokens->data[pos];\n    lhs = new_binop('&', t, lhs, equality());\n  }\n  return lhs;\n}\n\nstatic Node *bit_xor() {\n  Node *lhs = bit_and();\n  while (consume('^')) {\n    Token *t = tokens->data[pos];\n    lhs = new_binop('^', t, lhs, bit_and());\n  }\n  return lhs;\n}\n\nstatic Node *bit_or() {\n  Node *lhs = bit_xor();\n  while (consume('|')) {\n    Token *t = tokens->data[pos];\n    lhs = new_binop('|', t, lhs, bit_xor());\n  }\n  return lhs;\n}\n\nstatic Node *logand() {\n  Node *lhs = bit_or();\n  while (consume(TK_LOGAND)) {\n    Token *t = tokens->data[pos];\n    lhs = new_binop(ND_LOGAND, t, lhs, bit_or());\n  }\n  return lhs;\n}\n\nstatic Node *logor() {\n  Node *lhs = logand();\n  while (consume(TK_LOGOR)) {\n    Token *t = tokens->data[pos];\n    lhs = new_binop(ND_LOGOR, t, lhs, logand());\n  }\n  return lhs;\n}\n\nstatic Node *conditional() {\n  Node *cond = logor();\n  Token *t = tokens->data[pos];\n  if (!consume('?'))\n    return cond;\n\n  Node *node = new_node('?', t);\n  node->cond = cond;\n  node->then = expr();\n  expect(':');\n  node->els = conditional();\n  return node;\n}\n\n// `x op= y` where x is of type T is compiled as\n// `({ T *z = &x; *z = *z op y; })`.\nstatic Node *new_assign_eq(int op, Node *lhs, Node *rhs) {\n  Vector *v = new_vec();\n  Token *t = lhs->token;\n\n  // T *z = &x\n  Var *var = add_lvar(ptr_to(lhs->ty), \"tmp\");\n  vec_push(v, new_binop('=', t, new_varref(t, var), new_expr(ND_ADDR, t, lhs)));\n\n  // *z = *z op y\n  vec_push(v, new_binop('=', t, new_deref(t, var),\n                        new_binop(op, t, new_deref(t, var), rhs)));\n  return new_stmt_expr(t, v);\n}\n\nstatic Node *assign() {\n  Node *lhs = conditional();\n  Token *t = tokens->data[pos];\n\n  if (consume('='))\n    return new_binop('=', t, lhs, assign());\n  if (consume(TK_MUL_EQ))\n    return new_assign_eq('*', lhs, assign());\n  if (consume(TK_DIV_EQ))\n    return new_assign_eq('/', lhs, assign());\n  if (consume(TK_MOD_EQ))\n    return new_assign_eq('%', lhs, assign());\n  if (consume(TK_ADD_EQ))\n    return new_assign_eq('+', lhs, assign());\n  if (consume(TK_SUB_EQ))\n    return new_assign_eq('-', lhs, assign());\n  if (consume(TK_SHL_EQ))\n    return new_assign_eq(ND_SHL, lhs, assign());\n  if (consume(TK_SHR_EQ))\n    return new_assign_eq(ND_SHR, lhs, assign());\n  if (consume(TK_AND_EQ))\n    return new_assign_eq(ND_LOGAND, lhs, assign());\n  if (consume(TK_XOR_EQ))\n    return new_assign_eq('^', lhs, assign());\n  if (consume(TK_OR_EQ))\n    return new_assign_eq('|', lhs, assign());\n  return lhs;\n}\n\nstatic Node *expr() {\n  Node *lhs = assign();\n  Token *t = tokens->data[pos];\n  if (!consume(','))\n    return lhs;\n  return new_binop(',', t, lhs, expr());\n}\n\nstatic int const_expr() {\n  Token *t = tokens->data[pos];\n  Node *node = expr();\n  if (node->op != ND_NUM)\n    bad_token(t, \"constant expression expected\");\n  return node->val;\n}\n\nstatic Type *read_array(Type *ty) {\n  Vector *v = new_vec();\n\n  while (consume('[')) {\n    if (consume(']')) {\n      vec_pushi(v, -1);\n      continue;\n    }\n    vec_pushi(v, const_expr());\n    expect(']');\n  }\n\n  for (int i = v->len - 1; i >= 0; i--) {\n    int len = (intptr_t)v->data[i];\n    ty = ary_of(ty, len);\n  }\n  return ty;\n}\n\nstatic Node *declarator(Type *ty);\n\nstatic Node *direct_decl(Type *ty) {\n  Token *t = tokens->data[pos];\n  Node *node;\n  Type *placeholder = calloc(1, sizeof(Type));\n\n  if (t->ty == TK_IDENT) {\n    node = new_node(ND_VARDEF, t);\n    node->ty = placeholder;\n    node->name = ident();\n  } else if (consume('(')) {\n    node = declarator(placeholder);\n    expect(')');\n  } else {\n    bad_token(t, \"bad direct-declarator\");\n  }\n\n  // Read the second half of type name (e.g. `[3][5]`).\n  *placeholder = *read_array(ty);\n\n  // Read an initializer.\n  if (consume('='))\n    node->init = assign();\n  return node;\n}\n\nstatic Node *declarator(Type *ty) {\n  while (consume('*'))\n    ty = ptr_to(ty);\n  return direct_decl(ty);\n}\n\nstatic Node *declaration_type() {\n  Type *ty = decl_specifiers();\n  Node *node = declarator(ty);\n  expect(';');\n  return node;\n}\n\nstatic Node *declaration() {\n  Type *ty = decl_specifiers();\n  Node *node = declarator(ty);\n  expect(';');\n  Var *var = add_lvar(node->ty, node->name);\n\n  if (!node->init)\n    return &null_stmt;\n\n  // Convert `T var = init` to `T var; var = init`.\n  Token *t = node->token;\n  Node *lhs = new_varref(t, var);\n  Node *rhs = node->init;\n  node->init = NULL;\n\n  Node *expr = new_binop('=', t, lhs, rhs);\n  return new_expr(ND_EXPR_STMT, t, expr);\n}\n\nstatic Var *param_declaration() {\n  Type *ty = decl_specifiers();\n  Node *node = declarator(ty);\n  ty = node->ty;\n  if (ty->ty == ARY)\n    ty = ptr_to(ty->ary_of);\n  return add_lvar(ty, node->name);\n}\n\nstatic Node *expr_stmt() {\n  Token *t = tokens->data[pos];\n  Node *node = new_expr(ND_EXPR_STMT, t, expr());\n  expect(';');\n  return node;\n}\n\nstatic Node *stmt() {\n  Token *t = tokens->data[pos++];\n\n  switch (t->ty) {\n  case TK_TYPEDEF: {\n    Node *node = declaration_type();\n    assert(node->name);\n    map_put(env->typedefs, node->name, node->ty);\n    return &null_stmt;\n  }\n  case TK_IF: {\n    Node *node = new_node(ND_IF, t);\n    expect('(');\n    node->cond = expr();\n    expect(')');\n\n    node->then = stmt();\n\n    if (consume(TK_ELSE))\n      node->els = stmt();\n    return node;\n  }\n  case TK_FOR: {\n    Node *node = new_node(ND_FOR, t);\n    expect('(');\n    env = new_env(env);\n    vec_push(breaks, node);\n    vec_push(continues, node);\n\n    if (is_typename())\n      node->init = declaration();\n    else if (!consume(';'))\n      node->init = expr_stmt();\n\n    if (!consume(';')) {\n      node->cond = expr();\n      expect(';');\n    }\n\n    if (!consume(')')) {\n      node->inc = expr();\n      expect(')');\n    }\n\n    node->body = stmt();\n\n    vec_pop(breaks);\n    vec_pop(continues);\n    env = env->prev;\n    return node;\n  }\n  case TK_WHILE: {\n    Node *node = new_node(ND_FOR, t);\n    vec_push(breaks, node);\n    vec_push(continues, node);\n\n    expect('(');\n    node->cond = expr();\n    expect(')');\n    node->body = stmt();\n\n    vec_pop(breaks);\n    vec_pop(continues);\n    return node;\n  }\n  case TK_DO: {\n    Node *node = new_node(ND_DO_WHILE, t);\n    vec_push(breaks, node);\n    vec_push(continues, node);\n\n    node->body = stmt();\n    expect(TK_WHILE);\n    expect('(');\n    node->cond = expr();\n    expect(')');\n    expect(';');\n\n    vec_pop(breaks);\n    vec_pop(continues);\n    return node;\n  }\n  case TK_SWITCH: {\n    Node *node = new_node(ND_SWITCH, t);\n    node->cases = new_vec();\n\n    expect('(');\n    node->cond = expr();\n    expect(')');\n\n    vec_push(breaks, node);\n    vec_push(switches, node);\n    node->body = stmt();\n    vec_pop(breaks);\n    vec_pop(switches);\n    return node;\n  }\n  case TK_CASE: {\n    if (switches->len == 0)\n      bad_token(t, \"stray case\");\n    Node *node = new_node(ND_CASE, t);\n    node->val = const_expr();\n    expect(':');\n    node->body = stmt();\n\n    Node *n = vec_last(switches);\n    vec_push(n->cases, node);\n    return node;\n  }\n  case TK_BREAK: {\n    if (breaks->len == 0)\n      bad_token(t, \"stray break\");\n    Node *node = new_node(ND_BREAK, t);\n    node->target = vec_last(breaks);\n    return node;\n  }\n  case TK_CONTINUE: {\n    if (continues->len == 0)\n      bad_token(t, \"stray continue\");\n    Node *node = new_node(ND_CONTINUE, t);\n    node->target = vec_last(breaks);\n    return node;\n  }\n  case TK_RETURN: {\n    Node *node = new_node(ND_RETURN, t);\n    node->expr = expr();\n    expect(';');\n    return node;\n  }\n  case '{':\n    return compound_stmt();\n  case ';':\n    return &null_stmt;\n  default:\n    pos--;\n    if (is_typename())\n      return declaration();\n    return expr_stmt();\n  }\n}\n\nstatic Node *compound_stmt() {\n  Token *t = tokens->data[pos];\n  Node *node = new_node(ND_COMP_STMT, t);\n  node->stmts = new_vec();\n\n  env = new_env(env);\n  while (!consume('}'))\n    vec_push(node->stmts, stmt());\n  env = env->prev;\n  return node;\n}\n\nstatic void toplevel() {\n  bool is_typedef = consume(TK_TYPEDEF);\n  bool is_extern = consume(TK_EXTERN);\n\n  Type *ty = decl_specifiers();\n  while (consume('*'))\n    ty = ptr_to(ty);\n\n  char *name = ident();\n\n  // Function\n  if (consume('(')) {\n    Vector *params = new_vec();\n    while (!consume(')')) {\n      if (params->len > 0)\n        expect(',');\n      vec_push(params, param_declaration());\n    }\n\n    Token *t = tokens->data[pos];\n    Node *node = new_node(ND_DECL, t);\n\n    lvars = new_vec();\n    breaks = new_vec();\n    continues = new_vec();\n    switches = new_vec();\n\n    node->name = name;\n    node->params = params;\n\n    node->ty = calloc(1, sizeof(Type));\n    node->ty->ty = FUNC;\n    node->ty->returning = ty;\n\n    add_lvar(node->ty, name);\n\n    if (consume(';'))\n      return;\n\n    node->op = ND_FUNC;\n    t = tokens->data[pos];\n    expect('{');\n    if (is_typedef)\n      bad_token(t, \"typedef has function definition\");\n    node->body = compound_stmt();\n\n    Function *fn = calloc(1, sizeof(Function));\n    fn->name = name;\n    fn->node = node;\n    fn->lvars = lvars;\n    fn->bbs = new_vec();\n    vec_push(prog->funcs, fn);\n    return;\n  }\n\n  ty = read_array(ty);\n  expect(';');\n\n  if (is_typedef) {\n    map_put(env->typedefs, name, ty);\n    return;\n  }\n\n  // Global variable\n  add_gvar(ty, name, NULL, is_extern);\n}\n\nstatic bool is_eof() {\n  Token *t = tokens->data[pos];\n  return t->ty == TK_EOF;\n}\n\nProgram *parse(Vector *tokens_) {\n  tokens = tokens_;\n  pos = 0;\n  env = new_env(NULL);\n\n  prog = calloc(1, sizeof(Program));\n  prog->gvars = new_vec();\n  prog->funcs = new_vec();\n\n  while (!is_eof())\n    toplevel();\n  return prog;\n}\n"
        },
        {
          "name": "preprocess.c",
          "type": "blob",
          "size": 6.12890625,
          "content": "// C preprocessor\n\n#include \"9cc.h\"\n\nstatic Map *macros;\n\ntypedef struct Env {\n  Vector *input;\n  Vector *output;\n  int pos;\n  struct Env *prev;\n} Env;\n\nstatic Env *env;\n\nstatic Env *new_env(Env *prev, Vector *input) {\n  Env *env = calloc(1, sizeof(Env));\n  env->input = input;\n  env->output = new_vec();\n  env->prev = prev;\n  return env;\n}\n\nenum {\n  OBJLIKE,\n  FUNCLIKE,\n};\n\ntypedef struct Macro {\n  int ty;\n  Vector *tokens;\n  Vector *params;\n} Macro;\n\nstatic Macro *new_macro(int ty, char *name) {\n  Macro *m = calloc(1, sizeof(Macro));\n  m->ty = ty;\n  m->tokens = new_vec();\n  m->params = new_vec();\n  map_put(macros, name, m);\n  return m;\n}\n\nstatic void append(Vector *v) {\n  for (int i = 0; i < v->len; i++)\n    vec_push(env->output, v->data[i]);\n}\n\nstatic void emit(Token *t) {\n  vec_push(env->output, t);\n}\n\nstatic Token *next() {\n  assert(env->pos < env->input->len);\n  return env->input->data[env->pos++];\n}\n\nstatic bool is_eof() {\n  return env->pos == env->input->len;\n}\n\nstatic Token *get(int ty, char *msg) {\n  Token *t = next();\n  if (t->ty != ty)\n    bad_token(t, msg);\n  return t;\n}\n\nstatic char *ident(char *msg) {\n  Token *t = get(TK_IDENT, \"parameter name expected\");\n  return t->name;\n}\n\nstatic Token *peek() {\n  return env->input->data[env->pos];\n}\n\nstatic bool consume(int ty) {\n  if (peek()->ty != ty)\n    return false;\n  env->pos++;\n  return true;\n}\n\nstatic Vector *read_until_eol() {\n  Vector *v = new_vec();\n  while (!is_eof()) {\n    Token *t = next();\n    if (t->ty == '\\n')\n      break;\n    vec_push(v, t);\n  }\n  return v;\n}\n\nstatic Token *new_int(Token *tmpl, int val) {\n  Token *t = calloc(1, sizeof(Token));\n  *t = *tmpl;\n  t->ty = TK_NUM;\n  t->val = val;\n  return t;\n}\n\nstatic Token *new_string(Token *tmpl, char *str, int len) {\n  Token *t = calloc(1, sizeof(Token));\n  *t = *tmpl;\n  t->ty = TK_STR;\n  t->str = str;\n  t->len = len;\n  return t;\n}\n\nstatic Token *new_param(Token *tmpl, int val) {\n  Token *t = calloc(1, sizeof(Token));\n  *t = *tmpl;\n  t->ty = TK_PARAM;\n  t->val = val;\n  return t;\n}\n\nstatic bool is_ident(Token *t, char *s) {\n  return t->ty == TK_IDENT && !strcmp(t->name, s);\n}\n\n// Replaces macro parameter tokens with TK_PARAM tokens.\nstatic void replace_macro_params(Macro *m) {\n  Vector *params = m->params;\n  Vector *tokens = m->tokens;\n\n  Map *map = new_map();\n  for (int i = 0; i < params->len; i++) {\n    char *name = params->data[i];\n    map_puti(map, name, i);\n  }\n\n  for (int i = 0; i < tokens->len; i++) {\n    Token *t = tokens->data[i];\n    if (t->ty != TK_IDENT)\n      continue;\n    int n = map_geti(map, t->name, -1);\n    if (n == -1)\n      continue;\n    tokens->data[i] = new_param(t, n);\n  }\n}\n\n// Replaces '#' followed by a macro parameter with one token.\nstatic void replace_hash_ident(Macro *m) {\n  Vector *tokens = m->tokens;\n  Vector *v = new_vec();\n\n  int i = 0;\n  for (; i < tokens->len - 1; i++) {\n    Token *t1 = tokens->data[i];\n    Token *t2 = tokens->data[i + 1];\n\n    if (t1->ty == '#' && t2->ty == TK_PARAM) {\n      t2->stringize = true;\n      vec_push(v, t2);\n      i++;\n    } else {\n      vec_push(v, t1);\n    }\n  }\n\n  if (i == tokens->len - 1)\n    vec_push(v, tokens->data[i]);\n  m->tokens = v;\n}\n\nstatic Vector *read_one_arg() {\n  Vector *v = new_vec();\n  Token *start = peek();\n  int level = 0;\n\n  while (!is_eof()) {\n    Token *t = peek();\n    if (level == 0)\n      if (t->ty == ')' || t->ty == ',')\n        return v;\n\n    next();\n    if (t->ty == '(')\n      level++;\n    else if (t->ty == ')')\n      level--;\n    vec_push(v, t);\n  }\n  bad_token(start, \"unclosed macro argument\");\n}\n\nstatic Vector *read_args() {\n  Vector *v = new_vec();\n  if (consume(')'))\n    return v;\n  vec_push(v, read_one_arg());\n  while (!consume(')')) {\n    get(',', \"comma expected\");\n    vec_push(v, read_one_arg());\n  }\n  return v;\n}\n\nstatic bool emit_special_macro(Token *t) {\n  if (is_ident(t, \"__LINE__\")) {\n    emit(new_int(t, get_line_number(t)));\n    return true;\n  }\n  return false;\n}\n\nstatic void apply_objlike(Macro *m, Token *start) {\n  for (int i = 0; i < m->tokens->len; i++) {\n    Token *t = m->tokens->data[i];\n    if (emit_special_macro(t))\n      continue;\n    emit(t);\n  }\n}\n\nstatic void apply_funclike(Macro *m, Token *start) {\n  get('(', \"comma expected\");\n\n  Vector *args = read_args();\n  if (m->params->len != args->len)\n    bad_token(start, \"number of parameter does not match\");\n\n  for (int i = 0; i < m->tokens->len; i++) {\n    Token *t = m->tokens->data[i];\n    if (emit_special_macro(t))\n      continue;\n\n    if (t->ty == TK_PARAM) {\n      if (t->stringize) {\n        char *s = stringize(args->data[t->val]);\n        emit(new_string(t, s, strlen(s) + 1));\n      } else {\n        append(args->data[t->val]);\n      }\n      continue;\n    }\n    emit(t);\n  }\n}\n\nstatic void apply(Macro *m, Token *start) {\n  if (m->ty == OBJLIKE)\n    apply_objlike(m, start);\n  else\n    apply_funclike(m, start);\n}\n\nstatic void define_funclike(char *name) {\n  Macro *m = new_macro(FUNCLIKE, name);\n  while (!consume(')')) {\n    if (m->params->len > 0)\n      get(',', \", expected\");\n    vec_push(m->params, ident(\"parameter name expected\"));\n  }\n\n  m->tokens = read_until_eol();\n  replace_macro_params(m);\n  replace_hash_ident(m);\n}\n\nstatic void define_objlike(char *name) {\n  Macro *m = new_macro(OBJLIKE, name);\n  m->tokens = read_until_eol();\n}\n\nstatic void define() {\n  char *name = ident(\"macro name expected\");\n  if (consume('('))\n    return define_funclike(name);\n  return define_objlike(name);\n}\n\nstatic void include() {\n  Token *t = get(TK_STR, \"string expected\");\n  char *path = t->str;\n  get('\\n', \"newline expected\");\n  append(tokenize(path, false));\n}\n\nVector *preprocess(Vector *tokens) {\n  if (!macros)\n    macros = new_map();\n  env = new_env(env, tokens);\n\n  while (!is_eof()) {\n    Token *t = next();\n\n    if (t->ty == TK_IDENT) {\n      Macro *m = map_get(macros, t->name);\n      if (m)\n        apply(m, t);\n      else\n        emit(t);\n      continue;\n    }\n\n    if (t->ty != '#') {\n      emit(t);\n      continue;\n    }\n\n    t = get(TK_IDENT, \"identifier expected\");\n\n    if (!strcmp(t->name, \"define\"))\n      define();\n    else if (!strcmp(t->name, \"include\"))\n      include();\n    else\n      bad_token(t, \"unknown directive\");\n  }\n\n  Vector *v = env->output;\n  env = env->prev;\n  return v;\n}\n"
        },
        {
          "name": "regalloc.c",
          "type": "blob",
          "size": 4.5654296875,
          "content": "// Linear scan register allocator.\n//\n// Before this pass, it is assumed that we have infinite number of\n// registers. This pass maps them to finite number of registers.\n// Here is the algorithm:\n//\n// First, we find the definition and the last use for each register.\n// A register is considered \"live\" in the range. At the definition of\n// some register R, if all physical registers are already allocated,\n// one of them (including R itself) needs to be spilled to the stack.\n// As long as one register is spilled, the algorithm is logically\n// correct. As a heuristic, we spill a register whose last use is\n// furthest.\n//\n// We then insert load and store instructions for spilled registesr.\n// The last register (num_regs-1'th register) is reserved for that\n// purpose.\n\n#include \"9cc.h\"\n\n// Rewrite `A = B op C` to `A = B; A = A op C`.\nstatic void three_to_two(BB *bb) {\n  Vector *v = new_vec();\n\n  for (int i = 0; i < bb->ir->len; i++) {\n    IR *ir = bb->ir->data[i];\n\n    if (!ir->r0 || !ir->r1) {\n      vec_push(v, ir);\n      continue;\n    }\n\n    assert(ir->r0 != ir->r1);\n\n    IR *ir2 = calloc(1, sizeof(IR));\n    ir2->op = IR_MOV;\n    ir2->r0 = ir->r0;\n    ir2->r2 = ir->r1;\n    vec_push(v, ir2);\n\n    ir->r1 = ir->r0;\n    vec_push(v, ir);\n  }\n  bb->ir = v;\n}\n\nstatic void set_last_use(Reg *r, int ic) {\n  if (r && r->last_use < ic)\n    r->last_use = ic;\n}\n\nstatic Vector *collect_regs(Function *fn) {\n  Vector *v = new_vec();\n  int ic = 1; // instruction counter\n\n  for (int i = 0; i < fn->bbs->len; i++) {\n    BB *bb = fn->bbs->data[i];\n\n    if (bb->param) {\n      bb->param->def = ic;\n      vec_push(v, bb->param);\n    }\n\n    for (int i = 0; i < bb->ir->len; i++, ic++) {\n      IR *ir = bb->ir->data[i];\n\n      if (ir->r0 && !ir->r0->def) {\n        ir->r0->def = ic;\n        vec_push(v, ir->r0);\n      }\n\n      set_last_use(ir->r1, ic);\n      set_last_use(ir->r2, ic);\n      set_last_use(ir->bbarg, ic);\n\n      if (ir->op == IR_CALL)\n        for (int i = 0; i < ir->nargs; i++)\n          set_last_use(ir->args[i], ic);\n    }\n\n    for (int i = 0; i < bb->out_regs->len; i++) {\n      Reg *r = bb->out_regs->data[i];\n      set_last_use(r, ic);\n    }\n  }\n\n  return v;\n}\n\nstatic int choose_to_spill(Reg **used) {\n  int k = 0;\n  for (int i = 1; i < num_regs; i++)\n    if (used[k]->last_use < used[i]->last_use)\n      k = i;\n  return k;\n}\n\n// Allocate registers.\nstatic void scan(Vector *regs) {\n  Reg **used = calloc(num_regs, sizeof(Reg *));\n\n  for (int i = 0; i < regs->len; i++) {\n    Reg *r = regs->data[i];\n\n    // Find an unused slot.\n    bool found = false;\n    for (int i = 0; i < num_regs - 1; i++) {\n      if (used[i] && r->def < used[i]->last_use)\n        continue;\n      r->rn = i;\n      used[i] = r;\n      found = true;\n      break;\n    }\n\n    if (found)\n      continue;\n\n    // Choose a register to spill and mark it as \"spilled\".\n    used[num_regs - 1] = r;\n    int k = choose_to_spill(used);\n\n    r->rn = k;\n    used[k]->rn = num_regs - 1;\n    used[k]->spill = true;\n    used[k] = r;\n  }\n}\n\nstatic void spill_store(Vector *v, IR *ir) {\n  Reg *r = ir->r0;\n  if (!r || !r->spill)\n    return;\n\n  IR *ir2 = calloc(1, sizeof(IR));\n  ir2->op = IR_STORE_SPILL;\n  ir2->r1 = r;\n  ir2->var = r->var;\n  vec_push(v, ir2);\n}\n\nstatic void spill_load(Vector *v, IR *ir, Reg *r) {\n  if (!r || !r->spill)\n    return;\n\n  IR *ir2 = calloc(1, sizeof(IR));\n  ir2->op = IR_LOAD_SPILL;\n  ir2->r0 = r;\n  ir2->var = r->var;\n  vec_push(v, ir2);\n}\n\nstatic void emit_spill_code(BB *bb) {\n  Vector *v = new_vec();\n\n  for (int i = 0; i < bb->ir->len; i++) {\n    IR *ir = bb->ir->data[i];\n\n    spill_load(v, ir, ir->r1);\n    spill_load(v, ir, ir->r2);\n    spill_load(v, ir, ir->bbarg);\n    vec_push(v, ir);\n    spill_store(v, ir);\n  }\n  bb->ir = v;\n}\n\nvoid alloc_regs(Program *prog) {\n  for (int i = 0; i < prog->funcs->len; i++) {\n    Function *fn = prog->funcs->data[i];\n\n    // Convert SSA to x86-ish two-address form.\n    for (int i = 0; i < fn->bbs->len; i++) {\n      BB *bb = fn->bbs->data[i];\n      three_to_two(bb);\n    }\n\n    // Allocate registers and decide which registers to spill.\n    Vector *regs = collect_regs(fn);\n    scan(regs);\n\n    // Reserve a stack area for spilled registers.\n    for (int i = 0; i < regs->len; i++) {\n      Reg *r = regs->data[i];\n      if (!r->spill)\n        continue;\n\n      Var *var = calloc(1, sizeof(Var));\n      var->ty = ptr_to(int_ty());\n      var->is_local = true;\n      var->name = \"spill\";\n\n      r->var = var;\n      vec_push(fn->lvars, var);\n    }\n\n    // Convert accesses to spilled registers to loads and stores.\n    for (int i = 0; i < fn->bbs->len; i++) {\n      BB *bb = fn->bbs->data[i];\n      emit_spill_code(bb);\n    }\n  }\n}\n"
        },
        {
          "name": "sema.c",
          "type": "blob",
          "size": 6.337890625,
          "content": "#include \"9cc.h\"\n\n// Semantics analyzer. This pass plays a few important roles as shown\n// below:\n//\n// - Add types to nodes. For example, a tree that represents \"1+2\" is\n//   typed as INT because the result type of an addition of two\n//   integers is integer.\n//\n// - Insert nodes to make array-to-pointer conversion explicit.\n//   Recall that, in C, \"array of T\" is automatically converted to\n//   \"pointer to T\" in most contexts.\n//\n// - Insert nodes for implicit cast so that they are explicitly\n//   represented in AST.\n//\n// - Scales operands for pointer arithmetic. E.g. ptr+1 becomes ptr+4\n//   for integer and becomes ptr+8 for pointer.\n//\n// - Reject bad assignments, such as `1=2+3`.\n\nstatic Node *maybe_decay(Node *base, bool decay) {\n  if (!decay || base->ty->ty != ARY)\n    return base;\n\n  Node *node = calloc(1, sizeof(Node));\n  node->op = ND_ADDR;\n  node->ty = ptr_to(base->ty->ary_of);\n  node->expr = base;\n  node->token = base->token;\n  return node;\n}\n\nnoreturn static void bad_node(Node *node, char *msg) {\n  bad_token(node->token, msg);\n}\n\nstatic void check_lval(Node *node) {\n  int op = node->op;\n  if (op != ND_VARREF && op != ND_DEREF && op != ND_DOT)\n    bad_node(node, \"not an lvalue\");\n}\n\nstatic Node *scale_ptr(int op, Node *base, Type *ty) {\n  Node *node = calloc(1, sizeof(Node));\n  node->op = op;\n  node->lhs = base;\n  node->rhs = new_int_node(ty->ptr_to->size, base->token);\n  node->token = base->token;\n  return node;\n}\n\nstatic Node *cast(Node *base, Type *ty) {\n  Node *node = calloc(1, sizeof(Node));\n  node->op = ND_CAST;\n  node->ty = ty;\n  node->expr = base;\n  node->token = base->token;\n  return node;\n}\n\nstatic void check_int(Node *node) {\n  int t = node->ty->ty;\n  if (t != INT && t != CHAR && t != BOOL)\n    bad_node(node, \"not an integer\");\n}\n\nstatic Node *do_walk(Node *node, bool decay);\n\nstatic Node *walk(Node *node) {\n  return do_walk(node, true);\n}\n\nstatic Node *walk_nodecay(Node *node) {\n  return do_walk(node, false);\n}\n\nstatic Node *do_walk(Node *node, bool decay) {\n  switch (node->op) {\n  case ND_NUM:\n  case ND_NULL:\n  case ND_BREAK:\n  case ND_CONTINUE:\n    return node;\n  case ND_VARREF:\n    return maybe_decay(node, decay);\n  case ND_IF:\n    node->cond = walk(node->cond);\n    node->then = walk(node->then);\n    if (node->els)\n      node->els = walk(node->els);\n    return node;\n  case ND_FOR:\n    if (node->init)\n      node->init = walk(node->init);\n    if (node->cond)\n      node->cond = walk(node->cond);\n    if (node->inc)\n      node->inc = walk(node->inc);\n    node->body = walk(node->body);\n    return node;\n  case ND_DO_WHILE:\n  case ND_SWITCH:\n    node->cond = walk(node->cond);\n    node->body = walk(node->body);\n    return node;\n  case ND_CASE:\n    node->body = walk(node->body);\n    return node;\n  case '+':\n    node->lhs = walk(node->lhs);\n    node->rhs = walk(node->rhs);\n\n    if (node->rhs->ty->ty == PTR) {\n      Node *n = node->lhs;\n      node->lhs = node->rhs;\n      node->rhs = n;\n    }\n    check_int(node->rhs);\n\n    if (node->lhs->ty->ty == PTR) {\n      node->rhs = scale_ptr('*', node->rhs, node->lhs->ty);\n      node->ty = node->lhs->ty;\n    } else {\n      node->ty = int_ty();\n    }\n    return node;\n  case '-': {\n    node->lhs = walk(node->lhs);\n    node->rhs = walk(node->rhs);\n\n    Type *lty = node->lhs->ty;\n    Type *rty = node->rhs->ty;\n\n    if (lty->ty == PTR && rty->ty == PTR) {\n      if (!same_type(rty, lty))\n        bad_node(node, \"incompatible pointer\");\n      node = scale_ptr('/', node, lty);\n      node->ty = lty;\n    } else {\n      node->ty = int_ty();\n    }\n    return node;\n  }\n  case '=':\n    node->lhs = walk_nodecay(node->lhs);\n    check_lval(node->lhs);\n    node->rhs = walk(node->rhs);\n    if (node->lhs->ty->ty == BOOL)\n      node->rhs = cast(node->rhs, bool_ty());\n    node->ty = node->lhs->ty;\n    return node;\n  case ND_DOT: {\n    node->expr = walk(node->expr);\n    if (node->expr->ty->ty != STRUCT)\n      bad_node(node, \"struct expected before '.'\");\n\n    Type *ty = node->expr->ty;\n    if (!ty->members)\n      bad_node(node, \"incomplete type\");\n\n    node->ty = map_get(ty->members, node->name);\n    if (!node->ty)\n      bad_node(node, format(\"member missing: %s\", node->name));\n    return maybe_decay(node, decay);\n  }\n  case '?':\n    node->cond = walk(node->cond);\n    node->then = walk(node->then);\n    node->els = walk(node->els);\n    node->ty = node->then->ty;\n    return node;\n  case '*':\n  case '/':\n  case '%':\n  case '<':\n  case '|':\n  case '^':\n  case '&':\n  case ND_EQ:\n  case ND_NE:\n  case ND_LE:\n  case ND_SHL:\n  case ND_SHR:\n  case ND_LOGAND:\n  case ND_LOGOR:\n    node->lhs = walk(node->lhs);\n    node->rhs = walk(node->rhs);\n    check_int(node->lhs);\n    check_int(node->rhs);\n    node->ty = int_ty();\n    return node;\n  case ',':\n    node->lhs = walk(node->lhs);\n    node->rhs = walk(node->rhs);\n    node->ty = node->rhs->ty;\n    return node;\n  case '!':\n  case '~':\n    node->expr = walk(node->expr);\n    check_int(node->expr);\n    node->ty = int_ty();\n    return node;\n  case ND_ADDR:\n    node->expr = walk(node->expr);\n    check_lval(node->expr);\n    node->ty = ptr_to(node->expr->ty);\n    if (node->expr->op == ND_VARREF)\n      node->expr->var->address_taken = true;\n    return node;\n  case ND_DEREF:\n    node->expr = walk(node->expr);\n\n    if (node->expr->ty->ty != PTR)\n      bad_node(node, \"operand must be a pointer\");\n\n    if (node->expr->ty->ptr_to->ty == VOID)\n      bad_node(node, \"cannot dereference void pointer\");\n\n    node->ty = node->expr->ty->ptr_to;\n    return maybe_decay(node, decay);\n  case ND_RETURN:\n  case ND_EXPR_STMT:\n    node->expr = walk(node->expr);\n    return node;\n  case ND_CALL:\n    for (int i = 0; i < node->args->len; i++)\n      node->args->data[i] = walk(node->args->data[i]);\n    node->ty = node->ty->returning;\n    return node;\n  case ND_COMP_STMT: {\n    for (int i = 0; i < node->stmts->len; i++)\n      node->stmts->data[i] = walk(node->stmts->data[i]);\n    return node;\n  }\n  case ND_STMT_EXPR: {\n    for (int i = 0; i < node->stmts->len; i++)\n      node->stmts->data[i] = walk(node->stmts->data[i]);\n    node->expr = walk(node->expr);\n    node->ty = node->expr->ty;\n    return node;\n  }\n  default:\n    assert(0 && \"unknown node type\");\n  }\n}\n\nType *get_type(Node *node) {\n  return walk_nodecay(node)->ty;\n}\n\nvoid sema(Program *prog) {\n  for (int i = 0; i < prog->funcs->len; i++) {\n    Function *fn = prog->funcs->data[i];\n    Node *node = fn->node;\n    assert(node->op == ND_FUNC);\n    node->body = walk(node->body);\n  }\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "token.c",
          "type": "blob",
          "size": 10.40234375,
          "content": "#include \"9cc.h\"\n\ntypedef struct Env {\n  char *path;\n  char *buf;\n  Vector *tokens;\n  struct Env *prev;\n} Env;\n\nstatic Env *env;\nstatic Map *keywords;\n\nstatic FILE *open_file(char *path) {\n  if (!strcmp(path, \"-\"))\n    return stdin;\n\n  FILE *fp = fopen(path, \"r\");\n  if (!fp) {\n    perror(path);\n    exit(1);\n  }\n  return fp;\n}\n\nstatic char *read_file(FILE *fp) {\n  StringBuilder *sb = new_sb();\n  char buf[4096];\n  for (;;) {\n    int nread = fread(buf, 1, sizeof(buf), fp);\n    if (nread == 0)\n      break;\n    sb_append_n(sb, buf, nread);\n  }\n\n  // We want to make sure that a souce file ends with a newline.\n  // Add not only one but two to protect against a backslash at EOF.\n  sb_append(sb, \"\\n\\n\");\n  return sb_get(sb);\n}\n\nstatic Env *new_env(Env *prev, char *path, char *buf) {\n  Env *env = calloc(1, sizeof(Env));\n  env->path = strcmp(path, \"-\") ? path : \"(stdin)\";\n  env->buf = buf;\n  env->tokens = new_vec();\n  env->prev = prev;\n  return env;\n}\n\n// Returns true if s1 starts with s2.\nstatic bool startswith(char *s1, char *s2) {\n  return !strncmp(s1, s2, strlen(s2));\n}\n\n// Error reporting\n\n// Finds a line pointed by a given pointer from the input file\n// to print it out.\nstatic void print_line(char *buf, char *path, char *pos) {\n  char *start = buf;\n  int line = 0;\n  int col = 0;\n\n  for (char *p = buf; p; p++) {\n    if (*p == '\\n') {\n      start = p + 1;\n      line++;\n      col = 0;\n      continue;\n    }\n\n    if (p != pos) {\n      col++;\n      continue;\n    }\n\n    fprintf(stderr, \"error at %s:%d:%d\\n\\n\", path, line + 1, col + 1);\n\n    // Print out the line containing the error location.\n    int linelen = strchr(p, '\\n') - start;\n    fprintf(stderr, \"%.*s\\n\", linelen, start);\n\n    // Show tabs for tabs and spaces for other characters\n    // so that the column matches.\n    for (int i = 0; i < col; i++)\n      fprintf(stderr, (start[i] == '\\t') ? \"\\t\" : \" \");\n\n    fprintf(stderr, \"^\\n\\n\");\n    return;\n  }\n}\n\nvoid warn_token(Token *t, char *msg) {\n  if (t->start)\n    print_line(t->buf, t->path, t->start);\n  fprintf(stderr, msg);\n  fprintf(stderr, \"\\n\");\n}\n\nnoreturn void bad_token(Token *t, char *msg) {\n  warn_token(t, msg);\n  exit(1);\n}\n\nnoreturn static void bad_position(char *p, char *msg) {\n  print_line(env->buf, env->path, p);\n  error(msg);\n}\n\nint get_line_number(Token *t) {\n  int n = 0;\n  for (char *p = t->buf; p < t->end; p++)\n    if (*p == '\\n')\n      n++;\n  return n;\n}\n\n// Returns true if Token t followed a space or a comment\n// in an original source file.\nstatic bool need_space(Token *t) {\n  char *s = t->start;\n  if (t->buf <= s - 1 && isspace(s[-1]))\n    return true;\n  return t->buf <= s - 2 && startswith(s - 2, \"*/\");\n}\n\n// For C preprocessor.\nchar *stringize(Vector *tokens) {\n  StringBuilder *sb = new_sb();\n\n  for (int i = 0; i < tokens->len; i++) {\n    Token *t = tokens->data[i];\n    if (t->ty == '\\n')\n      continue;\n    if (i > 0 && need_space(t))\n      sb_add(sb, ' ');\n\n    assert(t->start && t->end);\n    sb_append_n(sb, t->start, t->end - t->start);\n  }\n  return sb_get(sb);\n}\n\n// Atomic unit in the grammar is called \"token\".\n// For example, `123`, `\"abc\"` and `while` are tokens.\n// The tokenizer splits an input string into tokens.\n// Spaces and comments are removed by the tokenizer.\n\nstatic Token *add(int ty, char *start) {\n  Token *t = calloc(1, sizeof(Token));\n  t->ty = ty;\n  t->start = start;\n  t->path = env->path;\n  t->buf = env->buf;\n  vec_push(env->tokens, t);\n  return t;\n}\n\nstatic struct {\n  char *name;\n  int ty;\n} symbols[] = {\n    {\"<<=\", TK_SHL_EQ}, {\">>=\", TK_SHR_EQ}, {\"!=\", TK_NE},\n    {\"&&\", TK_LOGAND},  {\"++\", TK_INC},     {\"--\", TK_DEC},\n    {\"->\", TK_ARROW},   {\"<<\", TK_SHL},     {\"<=\", TK_LE},\n    {\"==\", TK_EQ},      {\">=\", TK_GE},      {\">>\", TK_SHR},\n    {\"||\", TK_LOGOR},   {\"*=\", TK_MUL_EQ},  {\"/=\", TK_DIV_EQ},\n    {\"%=\", TK_MOD_EQ},  {\"+=\", TK_ADD_EQ},  {\"-=\", TK_SUB_EQ},\n    {\"&=\", TK_AND_EQ},  {\"^=\", TK_XOR_EQ},  {\"|=\", TK_OR_EQ},\n    {NULL, 0},\n};\n\nstatic Map *keyword_map() {\n  Map *map = new_map();\n  map_puti(map, \"_Alignof\", TK_ALIGNOF);\n  map_puti(map, \"_Bool\", TK_BOOL);\n  map_puti(map, \"break\", TK_BREAK);\n  map_puti(map, \"case\", TK_CASE);\n  map_puti(map, \"char\", TK_CHAR);\n  map_puti(map, \"continue\", TK_CONTINUE);\n  map_puti(map, \"do\", TK_DO);\n  map_puti(map, \"else\", TK_ELSE);\n  map_puti(map, \"extern\", TK_EXTERN);\n  map_puti(map, \"for\", TK_FOR);\n  map_puti(map, \"if\", TK_IF);\n  map_puti(map, \"int\", TK_INT);\n  map_puti(map, \"return\", TK_RETURN);\n  map_puti(map, \"sizeof\", TK_SIZEOF);\n  map_puti(map, \"struct\", TK_STRUCT);\n  map_puti(map, \"switch\", TK_SWITCH);\n  map_puti(map, \"typedef\", TK_TYPEDEF);\n  map_puti(map, \"typeof\", TK_TYPEOF);\n  map_puti(map, \"void\", TK_VOID);\n  map_puti(map, \"while\", TK_WHILE);\n  return map;\n}\n\nstatic char *block_comment(char *pos) {\n  for (char *p = pos + 2; *p; p++)\n    if (startswith(p, \"*/\"))\n      return p + 2;\n  bad_position(pos, \"unclosed comment\");\n}\n\nstatic int isoctal(char c) {\n  return '0' <= c && c <= '7';\n}\n\nstatic int hex(char c) {\n  if ('0' <= c && c <= '9')\n    return c - '0';\n  if ('a' <= c && c <= 'f')\n    return c - 'a' + 10;\n  assert('A' <= c && c <= 'F');\n  return c - 'A' + 10;\n}\n\n// Read a single character in a char or string literal.\nstatic char *c_char(int *res, char *p) {\n  // Nonescaped\n  if (*p != '\\\\') {\n    *res = *p;\n    return p + 1;\n  }\n  p++;\n\n  static char escaped[256] = {\n          ['a'] = '\\a', ['b'] = '\\b',   ['f'] = '\\f',\n          ['n'] = '\\n', ['r'] = '\\r',   ['t'] = '\\t',\n          ['v'] = '\\v', ['e'] = '\\033', ['E'] = '\\033',\n  };\n\n  // Simple (e.g. `\\n` or `\\a`)\n  int esc = escaped[(uint8_t)*p];\n  if (esc) {\n    *res = esc;\n    return p + 1;\n  }\n\n  // Hexadecimal\n  if (*p == 'x') {\n    *res = 0;\n    p++;\n    while (isxdigit(*p))\n      *res = *res * 16 + hex(*p++);\n    return p;\n  }\n\n  // Octal\n  if (isoctal(*p)) {\n    int i = *p++ - '0';\n    if (isoctal(*p))\n      i = i * 8 + *p++ - '0';\n    if (isoctal(*p))\n      i = i * 8 + *p++ - '0';\n    *res = i;\n    return p;\n  }\n\n  *res = *p;\n  return p + 1;\n}\n\nstatic char *char_literal(char *p) {\n  Token *t = add(TK_NUM, p++);\n  p = c_char(&t->val, p);\n  if (*p != '\\'')\n    bad_token(t, \"unclosed character literal\");\n  t->end = p + 1;\n  return p + 1;\n}\n\nstatic char *string_literal(char *p) {\n  Token *t = add(TK_STR, p++);\n  StringBuilder *sb = new_sb();\n\n  while (*p != '\"') {\n    if (!*p)\n      bad_token(t, \"unclosed string literal\");\n    int c;\n    p = c_char(&c, p);\n    sb_add(sb, c);\n  }\n\n  t->str = sb_get(sb);\n  t->len = sb->len;\n  t->end = p + 1;\n  return p + 1;\n}\n\nstatic char *ident(char *p) {\n  int len = 1;\n  while (isalpha(p[len]) || isdigit(p[len]) || p[len] == '_')\n    len++;\n\n  char *name = strndup(p, len);\n  int ty = map_geti(keywords, name, TK_IDENT);\n  Token *t = add(ty, p);\n  t->name = name;\n  t->end = p + len;\n  return p + len;\n}\n\nstatic char *hexadecimal(char *p) {\n  Token *t = add(TK_NUM, p);\n  p += 2;\n\n  if (!isxdigit(*p))\n    bad_token(t, \"bad hexadecimal number\");\n\n  while (isxdigit(*p))\n    t->val = t->val * 16 + hex(*p++);\n  t->end = p;\n  return p;\n}\n\nstatic char *octal(char *p) {\n  Token *t = add(TK_NUM, p++);\n  while (isoctal(*p))\n    t->val = t->val * 8 + *p++ - '0';\n  t->end = p;\n  return p;\n}\n\nstatic char *decimal(char *p) {\n  Token *t = add(TK_NUM, p);\n  while (isdigit(*p))\n    t->val = t->val * 10 + *p++ - '0';\n  t->end = p;\n  return p;\n}\n\nstatic char *number(char *p) {\n  if (startswith(p, \"0x\") || startswith(p, \"0X\"))\n    return hexadecimal(p);\n  if (*p == '0')\n    return octal(p);\n  return decimal(p);\n}\n\nstatic void scan() {\n  char *p = env->buf;\n\nloop:\n  while (*p) {\n    // New line (preprocessor-only token)\n    if (*p == '\\n') {\n      Token *t = add(*p, p);\n      p++;\n      t->end = p;\n      continue;\n    }\n\n    // Whitespace\n    if (isspace(*p)) {\n      p++;\n      continue;\n    }\n\n    // Line comment\n    if (startswith(p, \"//\")) {\n      while (*p && *p != '\\n')\n        p++;\n      continue;\n    }\n\n    // Block comment\n    if (startswith(p, \"/*\")) {\n      p = block_comment(p);\n      continue;\n    }\n\n    // Character literal\n    if (*p == '\\'') {\n      p = char_literal(p);\n      continue;\n    }\n\n    // String literal\n    if (*p == '\"') {\n      p = string_literal(p);\n      continue;\n    }\n\n    // Multi-letter symbol\n    for (int i = 0; symbols[i].name; i++) {\n      char *name = symbols[i].name;\n      if (!startswith(p, name))\n        continue;\n\n      Token *t = add(symbols[i].ty, p);\n      p += strlen(name);\n      t->end = p;\n      goto loop;\n    }\n\n    // Single-letter symbol\n    if (strchr(\"+-*/;=(),{}<>[]&.!?:|^%~#\", *p)) {\n      Token *t = add(*p, p);\n      p++;\n      t->end = p;\n      continue;\n    }\n\n    // Keyword or identifier\n    if (isalpha(*p) || *p == '_') {\n      p = ident(p);\n      continue;\n    }\n\n    // Number\n    if (isdigit(*p)) {\n      p = number(p);\n      continue;\n    }\n\n    bad_position(p, \"cannot tokenize\");\n  }\n}\n\nstatic void replace_crlf(char *p) {\n  for (char *q = p; *q;) {\n    if (startswith(q, \"\\r\\n\"))\n      q++;\n    *p++ = *q++;\n  }\n  *p = '\\0';\n}\n\n// Concatenates continuation lines. We keep the total number of\n// newline characters the same to keep the line counter sane.\nstatic void remove_backslash_newline(char *p) {\n  int cnt = 0;\n  for (char *q = p; *q;) {\n    if (startswith(q, \"\\\\\\n\")) {\n      cnt++;\n      q += 2;\n      continue;\n    }\n    if (*q == '\\n') {\n      for (int i = 0; i < cnt + 1; i++)\n        *p++ = '\\n';\n      q++;\n      cnt = 0;\n      continue;\n    }\n    *p++ = *q++;\n  }\n  *p = '\\0';\n}\n\nstatic Vector *strip_newline_tokens(Vector *tokens) {\n  Vector *v = new_vec();\n  for (int i = 0; i < tokens->len; i++) {\n    Token *t = tokens->data[i];\n    if (t->ty != '\\n')\n      vec_push(v, t);\n  }\n  return v;\n}\n\nstatic void append(Token *x, Token *y) {\n  StringBuilder *sb = new_sb();\n  sb_append_n(sb, x->str, x->len - 1);\n  sb_append_n(sb, y->str, y->len - 1);\n  x->str = sb_get(sb);\n  x->len = sb->len;\n}\n\nstatic Vector *join_string_literals(Vector *tokens) {\n  Vector *v = new_vec();\n  Token *last = NULL;\n\n  for (int i = 0; i < tokens->len; i++) {\n    Token *t = tokens->data[i];\n    if (last && last->ty == TK_STR && t->ty == TK_STR) {\n      append(last, t);\n      continue;\n    }\n\n    last = t;\n    vec_push(v, t);\n  }\n  return v;\n}\n\nVector *tokenize(char *path, bool add_eof) {\n  if (!keywords)\n    keywords = keyword_map();\n\n  FILE *fp = open_file(path);\n  char *buf = read_file(fp);\n  replace_crlf(buf);\n  remove_backslash_newline(buf);\n\n  env = new_env(env, path, buf);\n  scan();\n  if (add_eof)\n    add(TK_EOF, NULL);\n  Vector *v = env->tokens;\n  env = env->prev;\n\n  v = preprocess(v);\n  v = strip_newline_tokens(v);\n  return join_string_literals(v);\n}\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 3.7216796875,
          "content": "#include \"9cc.h\"\n\nnoreturn void error(char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(stderr, fmt, ap);\n  fprintf(stderr, \"\\n\");\n  exit(1);\n}\n\nchar *format(char *fmt, ...) {\n  char buf[2048];\n  va_list ap;\n  va_start(ap, fmt);\n  vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n  return strdup(buf);\n}\n\nVector *new_vec() {\n  Vector *v = malloc(sizeof(Vector));\n  v->data = malloc(sizeof(void *) * 16);\n  v->capacity = 16;\n  v->len = 0;\n  return v;\n}\n\nvoid vec_push(Vector *v, void *elem) {\n  if (v->len == v->capacity) {\n    v->capacity *= 2;\n    v->data = realloc(v->data, sizeof(void *) * v->capacity);\n  }\n  v->data[v->len++] = elem;\n}\n\nvoid vec_pushi(Vector *v, int val) {\n  vec_push(v, (void *)(intptr_t)val);\n}\n\nvoid *vec_pop(Vector *v) {\n  assert(v->len);\n  return v->data[--v->len];\n}\n\nvoid *vec_last(Vector *v) {\n  assert(v->len);\n  return v->data[v->len - 1];\n}\n\nbool vec_contains(Vector *v, void *elem) {\n  for (int i = 0; i < v->len; i++)\n    if (v->data[i] == elem)\n      return true;\n  return false;\n}\n\nbool vec_union1(Vector *v, void *elem) {\n  if (vec_contains(v, elem))\n    return false;\n  vec_push(v, elem);\n  return true;\n}\n\nMap *new_map(void) {\n  Map *map = malloc(sizeof(Map));\n  map->keys = new_vec();\n  map->vals = new_vec();\n  return map;\n}\n\nvoid map_put(Map *map, char *key, void *val) {\n  vec_push(map->keys, key);\n  vec_push(map->vals, val);\n}\n\nvoid map_puti(Map *map, char *key, int val) {\n  map_put(map, key, (void *)(intptr_t)val);\n}\n\nvoid *map_get(Map *map, char *key) {\n  for (int i = map->keys->len - 1; i >= 0; i--)\n    if (!strcmp(map->keys->data[i], key))\n      return map->vals->data[i];\n  return NULL;\n}\n\nint map_geti(Map *map, char *key, int default_) {\n  for (int i = map->keys->len - 1; i >= 0; i--)\n    if (!strcmp(map->keys->data[i], key))\n      return (intptr_t)map->vals->data[i];\n  return default_;\n}\n\nStringBuilder *new_sb(void) {\n  StringBuilder *sb = malloc(sizeof(StringBuilder));\n  sb->data = malloc(8);\n  sb->capacity = 8;\n  sb->len = 0;\n  return sb;\n}\n\nstatic void sb_grow(StringBuilder *sb, int len) {\n  if (sb->len + len <= sb->capacity)\n    return;\n\n  while (sb->len + len > sb->capacity)\n    sb->capacity *= 2;\n  sb->data = realloc(sb->data, sb->capacity);\n}\n\nvoid sb_add(StringBuilder *sb, char c) {\n  sb_grow(sb, 1);\n  sb->data[sb->len++] = c;\n}\n\nvoid sb_append(StringBuilder *sb, char *s) {\n  sb_append_n(sb, s, strlen(s));\n}\n\nvoid sb_append_n(StringBuilder *sb, char *s, int len) {\n  sb_grow(sb, len);\n  memcpy(sb->data + sb->len, s, len);\n  sb->len += len;\n}\n\nchar *sb_get(StringBuilder *sb) {\n  sb_add(sb, '\\0');\n  return sb->data;\n}\n\nint roundup(int x, int align) {\n  return (x + align - 1) & ~(align - 1);\n}\n\nType *ptr_to(Type *base) {\n  Type *ty = calloc(1, sizeof(Type));\n  ty->ty = PTR;\n  ty->size = 8;\n  ty->align = 8;\n  ty->ptr_to = base;\n  return ty;\n}\n\nType *ary_of(Type *base, int len) {\n  Type *ty = calloc(1, sizeof(Type));\n  ty->ty = ARY;\n  ty->size = base->size * len;\n  ty->align = base->align;\n  ty->ary_of = base;\n  ty->len = len;\n  return ty;\n}\n\nstatic Type *new_ty(int ty, int size) {\n  Type *ret = calloc(1, sizeof(Type));\n  ret->ty = ty;\n  ret->size = size;\n  ret->align = size;\n  return ret;\n}\n\nType *void_ty() {\n  return new_ty(VOID, 0);\n}\n\nType *bool_ty() {\n  return new_ty(BOOL, 1);\n}\n\nType *char_ty() {\n  return new_ty(CHAR, 1);\n}\n\nType *int_ty() {\n  return new_ty(INT, 4);\n}\n\nType *func_ty(Type *returning) {\n  Type *ty = calloc(1, sizeof(Type));\n  ty->returning = returning;\n  return ty;\n}\n\nbool same_type(Type *x, Type *y) {\n  if (x->ty != y->ty)\n    return false;\n\n  switch (x->ty) {\n  case PTR:\n    return same_type(x->ptr_to, y->ptr_to);\n  case ARY:\n    return x->size == y->size && same_type(x->ary_of, y->ary_of);\n  case STRUCT:\n  case FUNC:\n    return x == y;\n  default:\n    return true;\n  }\n}\n"
        },
        {
          "name": "util_test.c",
          "type": "blob",
          "size": 1.9736328125,
          "content": "#include \"9cc.h\"\n\n// Unit tests for our data structures.\n//\n// This kind of file is usually built as an independent executable in\n// a common build config, but in 9cc I took a different approach.\n// This file is just a part of the main executable. This scheme greatly\n// simplifies build config.\n//\n// In return for the simplicity, the main executable becomes slightly\n// larger, but that's not a problem for toy programs like 9cc.\n// What is most important is to write tests while keeping everything simple.\n\nstatic void expect(int line, int expected, int actual) {\n  if (expected == actual)\n    return;\n  fprintf(stderr, \"%d: %d expected, but got %d\\n\", line, expected, actual);\n  exit(1);\n}\n\nstatic void vec_test() {\n  Vector *vec = new_vec();\n  expect(__LINE__, 0, vec->len);\n\n  for (int i = 0; i < 100; i++)\n    vec_push(vec, (void *)(intptr_t)i);\n\n  expect(__LINE__, 100, vec->len);\n  expect(__LINE__, 0, (intptr_t)vec->data[0]);\n  expect(__LINE__, 50, (intptr_t)vec->data[50]);\n  expect(__LINE__, 99, (intptr_t)vec->data[99]);\n}\n\nstatic void map_test() {\n  Map *map = new_map();\n  expect(__LINE__, 0, (intptr_t)map_get(map, \"foo\"));\n\n  map_put(map, \"foo\", (void *)2);\n  expect(__LINE__, 2, (intptr_t)map_get(map, \"foo\"));\n\n  map_put(map, \"bar\", (void *)4);\n  expect(__LINE__, 4, (intptr_t)map_get(map, \"bar\"));\n\n  map_put(map, \"foo\", (void *)6);\n  expect(__LINE__, 6, (intptr_t)map_get(map, \"foo\"));\n}\n\nstatic void sb_test() {\n  StringBuilder *sb1 = new_sb();\n  expect(__LINE__, 0, strlen(sb_get(sb1)));\n\n  StringBuilder *sb2 = new_sb();\n  sb_append(sb2, \"foo\");\n  expect(__LINE__, 1, !strcmp(sb_get(sb2), \"foo\"));\n\n  StringBuilder *sb3 = new_sb();\n  sb_append(sb3, \"foo\");\n  sb_append(sb3, \"bar\");\n  expect(__LINE__, 1, !strcmp(sb_get(sb3), \"foobar\"));\n\n  StringBuilder *sb4 = new_sb();\n  sb_append(sb4, \"foo\");\n  sb_append(sb4, \"bar\");\n  sb_append(sb4, \"foo\");\n  sb_append(sb4, \"bar\");\n  expect(__LINE__, 1, !strcmp(sb_get(sb4), \"foobarfoobar\"));\n}\n\nvoid util_test() {\n  vec_test();\n  map_test();\n  sb_test();\n}\n"
        }
      ]
    }
  ]
}