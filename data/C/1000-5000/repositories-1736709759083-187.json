{
  "metadata": {
    "timestamp": 1736709759083,
    "page": 187,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "unbit/uwsgi",
      "stars": 3473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2578125,
          "content": "*.o\n*.py[co]\n*.class\n*.jar\n*~\n*.so\n*.gox\n*.a\n*.dll\n*.key\n*.orig\n*.rej\n\n/uwsgi\n/uwsgibuild.*\n/core/config_py.c\n\n/t/ring/target\n/t/spooler/spooldir/uwsgi_*\n\ncore/dot_h.c\n\n+# coverity\n+/cov-int/\n+uwsgi.tar.xz\n\n/build/\n/dist/\n/uWSGI.egg-info/\ncheck/check_*\n!check/*.c\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.9189453125,
          "content": "- this is a incomplete list of all the contributors of the project -\n\nRoberto De Ioris, Unbit, <roberto@unbit.it>\nRiccardo Magliocchetti\nYann Malet, Lincoln Loop\nSimon Litchfield\nMasahiro Honma, <hiratara@cpan.org>\nŁukasz Wróblewski <admin@nri.pl>\nGiacomo Bagnoli, Asidev\nGuido Notari, Link I.T. S.p.a.\nMarco Beri, Link I.T. S.p.a.\nLeonid Borisenko\nCal Leeming, Simplicity Media Ltd\nLuigi Scarso\nCorey Farwell\nCharles Duffy\nLukas Lalinsky\nSteven Fernandez\nŁukasz Mierzwa\nRoy Marples\nAarni Koskela\nC Anthony Risinger\nStephen Pierce\nMingli Yuan\nNatanael Copa\nRoberto Leandrini\nRyan Petrello\nDanila Shtan <danila@shtan.ru>\nÆvar Arnfjörð Bjarmason\nYu Zhao (getcwd)\nMathieu Dupuy\nMike Kaplinskiy\nAdriano Di Luzio (adriano@unbit.it)\nJames Raspass\nCurtis Maloney (curtis@tinbrain.net)\nVladimir Didenko\nAlexandre Bonnetain\nDarvame Hleran\nSokolov Yura <funny.falcon@gmail.com>\nMarcin Lulek <info@webreactor.eu>\nDerzsi Dániel <daniel@tohka.us>\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 18.19140625,
          "content": "----------------------------------------------------------------------\n\nLINKING EXCEPTION\n\n In addition to the permissions in the GNU General Public License,\n the authors give you unlimited permission to link the compiled\n version of this library into combinations with other programs,\n and to distribute those combinations without any restriction\n coming from the use of this file. (The General Public License\n restrictions do apply in other respects; for example, they cover\n modification of the file, and distribution when not linked into\n a combined executable.)\n\n----------------------------------------------------------------------\n\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.4189453125,
          "content": "PYTHON := python3\n\nall:\n\t$(PYTHON) uwsgiconfig.py --build $(PROFILE)\n\nclean:\n\t$(PYTHON) uwsgiconfig.py --clean\n\tcd unittest && make clean\n\ncheck:\n\t$(PYTHON) uwsgiconfig.py --check\n\nplugin.%:\n\t$(PYTHON) uwsgiconfig.py --plugin plugins/$* $(PROFILE)\n\nunittests:\n\t$(PYTHON) uwsgiconfig.py --build unittest\n\tcd unittest && make test\n\ntests:\n\t$(PYTHON) t/runner\n\n%:\n\t$(PYTHON) uwsgiconfig.py --build $@\n\n.PHONY: all clean check tests\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.482421875,
          "content": "The uWSGI project\n\nFor official documentation check: https://uwsgi-docs.readthedocs.io/en/latest/\n\nNote: The project is in maintenance mode (only bugfixes and updates for new languages apis)\n\nDo not expect quick answers on github issues and/or pull requests (sorry for that)\nA big thanks to all of the users and contributors since 2009.\n\nuWSGI development has been sponsored by:\n\nhttp://unbit.it\nhttps://www.pythonanywhere.com/\nhttps://lincolnloop.com/\nhttps://yourlabs.io/oss\nhttps://fili.com\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 1.2060546875,
          "content": "## How to cut a new stable release\n\nStable releases are tagged from the `uwsgi-2.0` branch. Changes to the `uwsgi-2.0` branch are\ncherry-picked from the `master` branch.\n\nBefore tagging a new release the release notes should be updated and a file named\n`Changelog-2.0.XY.rst` where XY is the number of the release created in\nthe [uwsgi-docs repository](https://github.com/unbit/uwsgi-docs). The newly created changelog file\nshould then be referenced from the `index.rst`. The release should also be updated in the `Download.rst`\npage.\n\nIn order to cut a new release you have to first bump the version and then tag with the same version\nthe last commit in git. All the commands are assumed to be run from the `uwsgi-2.0` branch.\n\nThe the tag should be pushed to git and the source distribution created with the following commands.\nPlease remember to substitute XY with proper version.\n\n```\ngit tag 2.0.XY\ngit push --tags origin HEAD\ngit archive HEAD --prefix uwsgi-2.0.XY/ -o uwsgi-2.0.XY.tar.gz\n```\n\nThen the tarball must be uploaded to pypi with:\n\n```\npython3 -m twine upload uwsgi-2.0.XY.tar.gz\n```\n\nOnce the file is uploaded the `Download.rst` page of [uwsgi-docs repository](https://github.com/unbit/uwsgi-docs)\nshould be updated.\n"
        },
        {
          "name": "apache2",
          "type": "tree",
          "content": null
        },
        {
          "name": "attach.py",
          "type": "blob",
          "size": 0.1806640625,
          "content": "import struct\nimport sys\nimport os\n\nfilename = sys.argv[1]\n\nsize = os.path.getsize(filename)\n\nf = open(filename)\nos.write(1, f.read())\nf.close()\n\nos.write(1, (struct.pack(\"<Q\", size)))\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "buildconf",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 0.5390625,
          "content": "echo \"*** uWSGI installer ***\"\nif [ $# -ne 2 ]\nthen\n  echo \"Usage: install.sh <profile> <binary_path>\"\n  exit 1\nfi\n\nif [ ${2:0:1} != \"/\" ]\nthen\n  echo \"uWSGI binary path must be absolute !!!\"\n  exit 1\nfi\n\necho \"downloading latest uWSGI tarball...\"\ncurl -o uwsgi_latest_from_installer.tar.gz https://projects.unbit.it/downloads/uwsgi-latest.tar.gz\nmkdir uwsgi_latest_from_installer\ntar zvxC uwsgi_latest_from_installer --strip-components=1 -f uwsgi_latest_from_installer.tar.gz\ncd uwsgi_latest_from_installer\nUWSGI_PROFILE=\"$1\" UWSGI_BIN_NAME=\"$2\" make\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "logo_uWSGI.png",
          "type": "blob",
          "size": 5.8310546875,
          "content": null
        },
        {
          "name": "logo_uWSGI.svg",
          "type": "blob",
          "size": 4.044921875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" id=\"Livello_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n   width=\"768px\" height=\"272.667px\" viewBox=\"0 0 768 272.667\" enable-background=\"new 0 0 768 272.667\" xml:space=\"preserve\">\n<g>\n\t<path fill=\"#AEC84D\" d=\"M170.667,41.334\"/>\n\t<path fill=\"#AEC84D\" d=\"M46.167,106.667v92.5c0,0-0.667,52.667,48.5,51.5c7.667-0.333,36,1,43-21c0-0.5,0,17,0,17h34l0.062-140h-34\n\t\tl-0.062,86.5c0,0,1,31-28,29.5s-28.5-27-28.5-27l-0.167-89H46.167z\"/>\n\t<polygon fill=\"#141215\" points=\"227,250.334 241,250.334 286.667,137.334 332.333,250.001 346.333,250.001 403,41.334 \n\t\t368.667,32.667 334.333,161.667 293.667,60.001 279.333,60.001 240,160.667 204.667,32.667 170.667,41.334 \t\"/>\n\t<path fill=\"#141215\" d=\"M402,203c0,0,8.667,26.001,23,35.334s38.666,12.999,50.333,12.666s71.001-1.333,71.667-56.333\n\t\tc5-28-19.333-48.334-26-52.334s-28.334-18-45.667-23s-34.334-16-35.667-24.666s0.001-34,37.334-34.334\n\t\tc26,2.668,27,13.668,31,19.668l7,14.332l28.666-13.332c0,0-11.334-27-14-29.334s-13.333-19-55.333-18.666\n\t\tc-42,0.332-66.666,17.666-68.333,47.666s4.666,44,35.333,62.666c19,10.334,39.001,12.667,59.667,28.334\n\t\tc14.333,11.667,11.334,25.001,11,30.667s-7.334,21.666-36.334,20.333S441,209.668,439,206.334s-9-17-9-17L402,203z\"/>\n\t<rect x=\"710.667\" y=\"36.334\" fill=\"#141215\" width=\"35.333\" height=\"211.333\"/>\n\t<path fill=\"#141215\" d=\"M636.333,135.001v27.666h27.333v56c0,0-8.334,5.001-26.667,4.334s-47.332,1.666-49.666-81.667\n\t\ts37.334-80.667,42-80.667s28,0.334,40,33.334C669.667,94.334,698,80.667,698,80.667s-12.334-50.333-67-47.666\n\t\tc-54.666,2.666-75.666,30.999-78.666,102c-3,71,21.999,117.334,81.666,115s64-7.334,64-7.334l-0.083-107.583L636.333,135.001z\"/>\n\t<g>\n\t\t<circle fill=\"#AEC84D\" cx=\"521.333\" cy=\"71.001\" r=\"11.667\"/>\n\t\t<circle fill=\"#252326\" cx=\"521.333\" cy=\"71.001\" r=\"3.5\"/>\n\t</g>\n\t<g>\n\t\t<path fill=\"none\" d=\"M81.147,185.163L81,106.667H46.167v90.88C56.139,192.016,68.027,187.752,81.147,185.163z\"/>\n\t\t<path fill=\"none\" d=\"M171.729,106.667h-34l-0.057,78.023c12.606,2.254,24.141,6.043,34.017,11.019L171.729,106.667z\"/>\n\t\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M46.167,199.167c0,0-0.667,52.667,48.5,51.5c7.667-0.333,36,1,43-21c0-0.5,0,17,0,17h34\n\t\t\tl0.023-50.958c-9.876-4.976-21.411-8.765-34.017-11.019l-0.006,8.477c0,0,1,31-28,29.5s-28.5-27-28.5-27l-0.02-10.504\n\t\t\tc-13.12,2.589-25.008,6.853-34.98,12.384V199.167z\"/>\n\t</g>\n\t<g>\n\t\t<path fill=\"none\" d=\"M342.89,129.517l-8.557,32.15l-13.896-34.738c-22.89-2.918-44.071-6.524-63.071-10.708L240,160.667\n\t\t\tl-14.526-52.621c-16.399-4.896-30.286-10.312-41.175-16.132L227,250.334h14l45.667-113l45.667,112.667h14l31.898-117.459\n\t\t\tC366.127,131.707,354.33,130.695,342.89,129.517z\"/>\n\t\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M403,41.334l-34.333-8.667l-25.776,96.85c11.44,1.178,23.237,2.19,35.341,3.025L403,41.334z\n\t\t\t\"/>\n\t\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M204.667,32.667l-34,8.667l13.633,50.58c10.889,5.82,24.775,11.236,41.175,16.132\n\t\t\tL204.667,32.667z\"/>\n\t\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M293.667,60.001h-14.333l-21.967,56.22c19,4.185,40.182,7.79,63.071,10.708L293.667,60.001z\n\t\t\t\"/>\n\t</g>\n\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M474.333,33.001c-42,0.332-66.666,17.666-68.333,47.666\n\t\tc-1.409,25.351,2.897,39.276,22.77,54.247c10.646,0.275,21.452,0.419,32.396,0.419c15.9,0,31.514-0.299,46.756-0.872\n\t\tc-9.466-5.486-21.856-12.032-32.589-15.128c-17.333-5-34.334-16-35.667-24.666s0.001-34,37.334-34.334\n\t\tc26,2.668,27,13.668,31,19.668l7,14.332l28.666-13.332c0,0-11.334-27-14-29.334S516.333,32.667,474.333,33.001z\"/>\n\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M631,33.001c-53.87,2.627-75.047,30.182-78.522,98.93c11.947-0.916,23.576-2.007,34.838-3.26\n\t\tc1.845-70.377,37.603-68.004,42.019-68.004c4.666,0,28,0.334,40,33.334C669.667,94.334,698,80.667,698,80.667\n\t\tS685.666,30.334,631,33.001z\"/>\n\t<path opacity=\"0.1\" fill=\"#FFFFFF\" d=\"M710.667,103.59c14.42-5.033,26.342-10.521,35.333-16.36V36.334h-35.333V103.59z\"/>\n</g>\n</svg>\n"
        },
        {
          "name": "mongrel2-uwsgi.conf",
          "type": "blob",
          "size": 0.6494140625,
          "content": "main = Server(\n    uuid=\"f400bf85-4538-4f7a-8908-67e313d515c2\",\n    access_log=\"/logs/access.log\",\n    error_log=\"/logs/error.log\",\n    chroot=\"./\",\n    default_host=\"192.168.173.18\",\n    name=\"test\",\n    pid_file=\"/run/mongrel2.pid\",\n    port=6767,\n    hosts = [\n        Host(name=\"192.168.173.18\", routes={\n            '/': Handler(send_spec='tcp://192.168.173.18:9999',\n                    send_ident='54c6755b-9628-40a4-9a2d-cc82a816345e', \n                    recv_spec='tcp://192.168.173.18:9998', recv_ident='')\n        })\n    ]\n)\n\nsettings = {'upload.temp_store':'tmp/mongrel2.upload.XXXXXX'}\nservers = [main]\n\n\nuwsgi = { 'socket':':3031', 'master':'true'}\n"
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cpyext.py",
          "type": "blob",
          "size": 3.6259765625,
          "content": "# encoding: utf-8\n\n\"\"\"\nThis is a hack allowing you installing\nuWSGI and uwsgidecorators via pip and easy_install\nsince 1.9.11 it automatically detects pypy\n\"\"\"\n\nimport os\nimport sys\nimport errno\nimport shlex\nimport uwsgiconfig\n\nfrom setuptools import setup, Extension\nfrom setuptools.command.build_ext import build_ext\n\n\nclass uWSGIBuildExt(build_ext):\n\n    UWSGI_NAME = 'uwsgi'\n    UWSGI_PLUGIN = 'pyuwsgi'\n\n    def build_extensions(self):\n        self.uwsgi_setup()\n        # XXX: needs uwsgiconfig fix\n        self.uwsgi_build()\n        if 'UWSGI_USE_DISTUTILS' not in os.environ:\n            # XXX: needs uwsgiconfig fix\n            # uwsgiconfig.build_uwsgi(self.uwsgi_config)\n            return\n\n        else:\n            # XXX: needs uwsgiconfig fix\n            os.unlink(self.uwsgi_config.get('bin_name'))\n\n        # FIXME: else build fails :(\n        for baddie in set(self.compiler.compiler_so) & set(('-Wstrict-prototypes',)):\n            self.compiler.compiler_so.remove(baddie)\n\n        build_ext.build_extensions(self)\n\n    def uwsgi_setup(self):\n        default = 'pypy' if '__pypy__' in sys.builtin_module_names else 'default'\n        profile = os.environ.get('UWSGI_PROFILE') or 'buildconf/%s.ini' % default\n\n        if not profile.endswith('.ini'):\n            profile = profile + '.ini'\n        if '/' not in profile:\n            profile = 'buildconf/' + profile\n\n        # FIXME: update uwsgiconfig to properly set _EVERYTHING_!\n        config = uwsgiconfig.uConf(profile)\n        # insert in the beginning so UWSGI_PYTHON_NOLIB is exported\n        # before the python plugin compiles\n        ep = config.get('embedded_plugins').split(',')\n        if self.UWSGI_PLUGIN in ep:\n            ep.remove(self.UWSGI_PLUGIN)\n        ep.insert(0, self.UWSGI_PLUGIN)\n        config.set('embedded_plugins', ','.join(ep))\n        config.set('as_shared_library', 'true')\n        config.set('bin_name', self.get_ext_fullpath(self.UWSGI_NAME))\n        try:\n            os.makedirs(os.path.dirname(config.get('bin_name')))\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        self.uwsgi_profile = profile\n        self.uwsgi_config = config\n\n    def uwsgi_build(self):\n        uwsgiconfig.build_uwsgi(self.uwsgi_config)\n\n        # XXX: merge uwsgi_setup (see other comments)\n        for ext in self.extensions:\n            if ext.name == self.UWSGI_NAME:\n                ext.sources = [s + '.c' for s in self.uwsgi_config.gcc_list]\n                ext.library_dirs = self.uwsgi_config.include_path[:]\n                ext.libraries = list()\n                ext.extra_compile_args = list()\n\n                for x in uwsgiconfig.uniq_warnings(\n                    self.uwsgi_config.ldflags + self.uwsgi_config.libs,\n                ):\n                    for y in shlex.split(x):\n                        if y.startswith('-l'):\n                            ext.libraries.append(y[2:])\n                        elif y.startswith('-L'):\n                            ext.library_dirs.append(y[2:])\n\n                for x in self.uwsgi_config.cflags:\n                    for y in shlex.split(x):\n                        if y:\n                            ext.extra_compile_args.append(y)\n\n\nsetup(\n    name='uWSGI',\n    license='GPL2',\n    version=uwsgiconfig.uwsgi_version,\n    author='Unbit',\n    author_email='info@unbit.it',\n    description='The uWSGI server',\n    cmdclass={\n        'build_ext': uWSGIBuildExt,\n        },\n    py_modules=[\n        'uwsgidecorators',\n        ],\n    ext_modules=[\n        Extension(uWSGIBuildExt.UWSGI_NAME, sources=[]),\n        ],\n    entry_points={\n        'console_scripts': ['uwsgi=%s:run' % uWSGIBuildExt.UWSGI_NAME],\n        },\n    )\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 4.212890625,
          "content": "import os\nimport sys\nimport uwsgiconfig as uc\n\nfrom setuptools import setup\nfrom setuptools.dist import Distribution\nfrom setuptools.command.install import install\nfrom setuptools.command.install_lib import install_lib\nfrom setuptools.command.build_ext import build_ext\n\ntry:\n    from wheel.bdist_wheel import bdist_wheel\n    HAS_WHEEL = True\nexcept ImportError:\n    HAS_WHEEL = False\n\n\"\"\"\nThis is a hack allowing you installing\nuWSGI and uwsgidecorators via pip and easy_install\nsince 1.9.11 it automatically detects pypy\n\"\"\"\n\nuwsgi_compiled = False\n\n\ndef get_profile():\n    is_pypy = False\n    try:\n        import __pypy__  # NOQA\n        is_pypy = True\n    except ImportError:\n        pass\n    if is_pypy:\n        profile = os.environ.get('UWSGI_PROFILE', 'buildconf/pypy.ini')\n    else:\n        profile = os.environ.get('UWSGI_PROFILE', 'buildconf/default.ini')\n    if not profile.endswith('.ini'):\n        profile = \"%s.ini\" % profile\n    if '/' not in profile:\n        profile = \"buildconf/%s\" % profile\n\n    return profile\n\n\ndef patch_bin_path(cmd, conf):\n\n    bin_name = conf.get('bin_name')\n\n    if not os.path.isabs(bin_name):\n        print('Patching \"bin_name\" to properly install_scripts dir')\n        try:\n            if not os.path.exists(cmd.install_scripts):\n                os.makedirs(cmd.install_scripts)\n            conf.set('bin_name',\n                     os.path.join(cmd.install_scripts, conf.get('bin_name')))\n        except Exception:\n            conf.set('bin_name', sys.prefix + '/bin/' + bin_name)\n\n\nclass uWSGIBuilder(build_ext):\n\n    def run(self):\n        global uwsgi_compiled\n        if not uwsgi_compiled:\n            conf = uc.uConf(get_profile())\n            patch_bin_path(self, conf)\n            uc.build_uwsgi(conf)\n            uwsgi_compiled = True\n\n\nclass uWSGIInstall(install):\n\n    def run(self):\n        global uwsgi_compiled\n        if not uwsgi_compiled:\n            conf = uc.uConf(get_profile())\n            patch_bin_path(self, conf)\n            uc.build_uwsgi(conf)\n            uwsgi_compiled = True\n        install.run(self)\n\n\nclass uWSGIInstallLib(install_lib):\n\n    def run(self):\n        global uwsgi_compiled\n        if not uwsgi_compiled:\n            conf = uc.uConf(get_profile())\n            patch_bin_path(self, conf)\n            uc.build_uwsgi(conf)\n            uwsgi_compiled = True\n        install_lib.run(self)\n\n\nif HAS_WHEEL:\n    class uWSGIWheel(bdist_wheel):\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            self.root_is_pure = False\n\n\nclass uWSGIDistribution(Distribution):\n\n    def __init__(self, *attrs):\n        Distribution.__init__(self, *attrs)\n        self.cmdclass['install'] = uWSGIInstall\n        self.cmdclass['install_lib'] = uWSGIInstallLib\n        self.cmdclass['build_ext'] = uWSGIBuilder\n        if HAS_WHEEL:\n            self.cmdclass['bdist_wheel'] = uWSGIWheel\n\n    def is_pure(self):\n        return False\n\n\ndef get_extra_require():\n    req = []\n    conf = uc.uConf(get_profile())\n    plugins = conf.get('main_plugin')\n    if plugins:\n        plugins = plugins.split(',')\n        if 'greenlet' in plugins:\n            req.append('greenlet')\n\n    return req\n\nsetup(\n    name='uWSGI',\n    version=uc.uwsgi_version,\n    description='The uWSGI server',\n    author='Unbit',\n    author_email='info@unbit.it',\n    license='GPLv2+',\n    py_modules=['uwsgidecorators'],\n    distclass=uWSGIDistribution,\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n    ],\n    install_requires=get_extra_require()\n)\n"
        },
        {
          "name": "t",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "unittest",
          "type": "tree",
          "content": null
        },
        {
          "name": "uwsgi.gemspec",
          "type": "blob",
          "size": 0.544921875,
          "content": "Gem::Specification.new do |s|\n  s.name        = 'uwsgi'\n  s.license     = 'GPL-2'\n  s.version     = `python -c \"import uwsgiconfig as uc; print uc.uwsgi_version\"`.sub(/-dev-.*/,'')\n  s.date        = '2014-09-05'\n  s.summary     = \"uWSGI\"\n  s.description = \"The uWSGI server for Ruby/Rack\"\n  s.authors     = [\"Unbit\"]\n  s.email       = 'info@unbit.it'\n  s.extensions  = ['ext/uwsgi/extconf.rb']\n  s.files       = []\n  s.require_paths = ['.']\n  s.executables << 'uwsgi'\n  s.homepage    = 'https://projects.unbit.it/uwsgi'\n  s.add_runtime_dependency 'rack'\nend\n"
        },
        {
          "name": "uwsgi.h",
          "type": "blob",
          "size": 130.9033203125,
          "content": "/* uWSGI */\n\n/* indent -i8 -br -brs -brf -l0 -npsl -nip -npcs -npsl -di1 -il0 */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define UWSGI_PLUGIN_API\t2\n\n#define UWSGI_HAS_OFFLOAD_UBUFS 1\n\n#define UMAX16\t65536\n#define UMAX8\t256\n\n#define UMAX64_STR \"18446744073709551615\"\n#define MAX64_STR \"-9223372036854775808\"\n\n#define UWSGI_END_OF_OPTIONS { NULL, 0, 0, NULL, NULL, NULL, 0},\n\n#define uwsgi_error(x)  uwsgi_log(\"%s: %s [%s line %d]\\n\", x, strerror(errno), __FILE__, __LINE__);\n#define uwsgi_error_realpath(x)  uwsgi_log(\"realpath() of %s failed: %s [%s line %d]\\n\", x, strerror(errno), __FILE__, __LINE__);\n#define uwsgi_log_safe(x)  if (uwsgi.original_log_fd != 2) dup2(uwsgi.original_log_fd, 2) ; uwsgi_log(x);\n#define uwsgi_error_safe(x)  if (uwsgi.original_log_fd != 2) dup2(uwsgi.original_log_fd, 2) ; uwsgi_log(\"%s: %s [%s line %d]\\n\", x, strerror(errno), __FILE__, __LINE__);\n#define uwsgi_log_initial if (!uwsgi.no_initial_output) uwsgi_log\n#define uwsgi_log_alarm(x, ...) uwsgi_log(\"[uwsgi-alarm\" x, __VA_ARGS__)\n#define uwsgi_fatal_error(x) uwsgi_error(x); exit(1);\n#define uwsgi_error_open(x)  uwsgi_log(\"open(\\\"%s\\\"): %s [%s line %d]\\n\", x, strerror(errno), __FILE__, __LINE__);\n#define uwsgi_req_error(x)  if (wsgi_req->uri_len > 0 && wsgi_req->method_len > 0 && wsgi_req->remote_addr_len > 0) uwsgi_log_verbose(\"%s: %s [%s line %d] during %.*s %.*s (%.*s)\\n\", x, strerror(errno), __FILE__, __LINE__,\\\n\t\twsgi_req->method_len, wsgi_req->method, wsgi_req->uri_len, wsgi_req->uri, wsgi_req->remote_addr_len, wsgi_req->remote_addr); else uwsgi_log_verbose(\"%s %s [%s line %d] \\n\",x, strerror(errno), __FILE__, __LINE__);\n#define uwsgi_debug(x, ...) uwsgi_log(\"[uWSGI DEBUG] \" x, __VA_ARGS__);\n#define uwsgi_rawlog(x) if (write(2, x, strlen(x)) != strlen(x)) uwsgi_error(\"write()\")\n#define uwsgi_str(x) uwsgi_concat2(x, (char *)\"\")\n\n#define uwsgi_notify(x) if (uwsgi.notify) uwsgi.notify(x)\n#define uwsgi_notify_ready() uwsgi.shared->ready = 1 ; if (uwsgi.notify_ready) uwsgi.notify_ready()\n\n#define uwsgi_apps uwsgi.workers[uwsgi.mywid].apps\n#define uwsgi_apps_cnt uwsgi.workers[uwsgi.mywid].apps_cnt\n\n#define wsgi_req_time ((wsgi_req->end_of_request-wsgi_req->start_of_request)/1000)\n\n#define thunder_lock if (!uwsgi.is_et) {\\\n                        if (uwsgi.use_thunder_lock) {\\\n                                uwsgi_lock(uwsgi.the_thunder_lock);\\\n                        }\\\n                        else if (uwsgi.threads > 1) {\\\n                                pthread_mutex_lock(&uwsgi.thunder_mutex);\\\n                        }\\\n                    }\n\n#define thunder_unlock if (!uwsgi.is_et) {\\\n                        if (uwsgi.use_thunder_lock) {\\\n                                uwsgi_unlock(uwsgi.the_thunder_lock);\\\n                        }\\\n                        else if (uwsgi.threads > 1) {\\\n                                pthread_mutex_unlock(&uwsgi.thunder_mutex);\\\n                        }\\\n                        }\n\n\n#define uwsgi_n64(x) strtoul(x, NULL, 10)\n\n#define ushared uwsgi.shared\n\n#define UWSGI_OPT_IMMEDIATE\t(1 << 0)\n#define UWSGI_OPT_MASTER\t(1 << 1)\n#define UWSGI_OPT_LOG_MASTER\t(1 << 2)\n#define UWSGI_OPT_THREADS\t(1 << 3)\n#define UWSGI_OPT_CHEAPER\t(1 << 4)\n#define UWSGI_OPT_VHOST\t\t(1 << 5)\n#define UWSGI_OPT_MEMORY\t(1 << 6)\n#define UWSGI_OPT_PROCNAME\t(1 << 7)\n#define UWSGI_OPT_LAZY\t\t(1 << 8)\n#define UWSGI_OPT_NO_INITIAL\t(1 << 9)\n#define UWSGI_OPT_NO_SERVER\t(1 << 10)\n#define UWSGI_OPT_POST_BUFFERING\t(1 << 11)\n#define UWSGI_OPT_CLUSTER\t(1 << 12)\n#define UWSGI_OPT_MIME\t\t(1 << 13)\n#define UWSGI_OPT_REQ_LOG_MASTER\t(1 << 14)\n#define UWSGI_OPT_METRICS\t(1 << 15)\n\n#define MAX_GENERIC_PLUGINS 128\n#define MAX_GATEWAYS 64\n#define MAX_TIMERS 64\n#define MAX_CRONS 64\n\n#define UWSGI_VIA_SENDFILE\t1\n#define UWSGI_VIA_ROUTE\t2\n#define UWSGI_VIA_OFFLOAD\t3\n\n#ifndef UWSGI_LOAD_EMBEDDED_PLUGINS\n#define UWSGI_LOAD_EMBEDDED_PLUGINS\n#endif\n\n#ifndef UWSGI_DECLARE_EMBEDDED_PLUGINS\n#define UWSGI_DECLARE_EMBEDDED_PLUGINS\n#endif\n\n#ifdef UWSGI_EMBED_CONFIG\n\textern char UWSGI_EMBED_CONFIG;\n\textern char UWSGI_EMBED_CONFIG_END;\n#endif\n\n#define UDEP(pname) extern struct uwsgi_plugin pname##_plugin;\n\n#define ULEP(pname)\\\n\tif (pname##_plugin.request) {\\\n\tuwsgi.p[pname##_plugin.modifier1] = &pname##_plugin;\\\n\tif (uwsgi.p[pname##_plugin.modifier1]->on_load)\\\n\t\tuwsgi.p[pname##_plugin.modifier1]->on_load();\\\n\t}\\\n\telse {\\\n\tif (uwsgi.gp_cnt >= MAX_GENERIC_PLUGINS) {\\\n\t\tuwsgi_log(\"you have embedded too much generic plugins !!!\\n\");\\\n\t\texit(1);\\\n\t}\\\n\tuwsgi.gp[uwsgi.gp_cnt] = &pname##_plugin;\\\n\tif (uwsgi.gp[uwsgi.gp_cnt]->on_load)\\\n\t\tuwsgi.gp[uwsgi.gp_cnt]->on_load();\\\n\tuwsgi.gp_cnt++;\\\n\t}\\\n\n\n#define fill_plugin_table(x, up)\\\n\tif (up->request) {\\\n\tuwsgi.p[x] = up;\\\n\t}\\\n\telse {\\\n\tif (uwsgi.gp_cnt >= MAX_GENERIC_PLUGINS) {\\\n\t\tuwsgi_log(\"you have embedded too much generic plugins !!!\\n\");\\\n\t\texit(1);\\\n\t}\\\n\tuwsgi.gp[uwsgi.gp_cnt] = up;\\\n\tuwsgi.gp_cnt++;\\\n\t}\\\n\n#define uwsgi_foreach(x, y) for(x=y;x;x = x->next) \n\n#define uwsgi_foreach_token(x, y, z, w) for(z=strtok_r(x, y, &w);z;z = strtok_r(NULL, y, &w))\n\n\n#ifndef __need_IOV_MAX\n#define __need_IOV_MAX\n#endif\n\n#ifdef __sun__\n#ifndef _XPG4_2\n#define _XPG4_2\n#endif\n#ifndef __EXTENSIONS__\n#define __EXTENSIONS__\n#endif\n#endif\n\n#if defined(__linux__) || defined(__GNUC__)\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <signal.h>\n#include <math.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#ifdef __linux__\n#ifndef MSG_FASTOPEN\n#define MSG_FASTOPEN   0x20000000\n#endif\n#endif\n#include <netinet/in.h>\n\n#include <termios.h>\n\n#ifdef UWSGI_UUID\n#include <uuid/uuid.h>\n#endif\n\n#include <string.h>\n#include <sys/stat.h>\n#include <netinet/tcp.h>\n#ifdef __linux__\n#ifndef TCP_FASTOPEN\n#define TCP_FASTOPEN 23\n#endif\n#endif\n#include <netdb.h>\n\n#if defined(__GNU_kFreeBSD__)\n#include <bsd/unistd.h>\n#endif\n\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n#include <sys/sysctl.h>\n#include <sys/param.h>\n#include <sys/cpuset.h>\n#include <sys/jail.h>\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n#include <jail.h>\n#endif\n#endif\n\n#include <sys/ipc.h>\n#include <sys/sem.h>\n\n#include <stdarg.h>\n#include <errno.h>\n#ifndef __USE_ISOC99\n#define __USE_ISOC99\n#endif\n#include <ctype.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#ifdef UWSGI_HAS_IFADDRS\n#include <ifaddrs.h>\n#endif\n\n\n#include <pwd.h>\n#ifdef __CYGWIN__\n#ifdef _POSIX_C_SOURCE\n#undef _POSIX_C_SOURCE\n#endif\n#endif\n#include <grp.h>\n\n#ifdef __CYGWIN__\nint initgroups(const char *, gid_t);\n#endif\n\n\n#include <sys/utsname.h>\n\n\n#ifdef __linux__\n#include <sched.h>\n#include <sys/prctl.h>\n#include <linux/limits.h>\n#endif\n\n#if defined(__linux) || defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n#include <sys/mount.h>\n#endif\n\n#ifdef __linux__\nextern int pivot_root(const char *new_root, const char *put_old);\n#endif\n\n#include <limits.h>\n\n#include <dirent.h>\n\n#ifndef UWSGI_PLUGIN_BASE\n#define UWSGI_PLUGIN_BASE \"\"\n#endif\n\n#include <arpa/inet.h>\n#include <sys/mman.h>\n#include <sys/file.h>\n\n#include <stdint.h>\n\n#include <sys/wait.h>\n#ifndef WAIT_ANY\n#define WAIT_ANY (-1)\n#endif\n\n#ifdef __APPLE__\n#ifndef MAC_OS_X_VERSION_MIN_REQUIRED\n#define MAC_OS_X_VERSION_MIN_REQUIRED MAC_OS_X_VERSION_10_4\n#endif\n#include <mach-o/dyld.h>\n#include <mach-o/getsect.h>\n#include <mach-o/ldsyms.h>\n#endif\n\n#include <dlfcn.h>\n\n#include <poll.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n\n#include <fcntl.h>\n#include <pthread.h>\n\n#include <sys/resource.h>\n\n#include <getopt.h>\n\n#ifdef __APPLE__\n#include <libkern/OSAtomic.h>\n#include <mach/task.h>\n#include <mach/mach_init.h>\n#endif\n\n#ifdef _POSIX_C_SOURCE\n#undef _POSIX_C_SOURCE\n#endif\n#if defined(__sun__)\n#define WAIT_ANY (-1)\n#include <sys/filio.h>\n#define PRIO_MAX  20\n#endif\n\n#if defined(__HAIKU__) || defined(__CYGWIN__)\n#ifndef WAIT_ANY\n#define WAIT_ANY (-1)\n#endif\n#define PRIO_MAX  20\n#endif\n\n#include <sys/ioctl.h>\n\n#ifdef __linux__\n#include <sys/sendfile.h>\n#include <sys/epoll.h>\n#elif defined(__GNU_kFreeBSD__)\n#include <sys/sendfile.h>\n#include <sys/event.h>\n#elif defined(__sun__)\n#include <sys/sendfile.h>\n#include <sys/devpoll.h>\n#elif defined(__HAIKU__)\n#elif defined(__CYGWIN__)\n#elif defined(__HURD__)\n#else\n#include <sys/event.h>\n#endif\n\n#ifdef UWSGI_CAP\n#include <sys/capability.h>\n#endif\n\n#ifdef __HAIKU__\n#include <kernel/OS.h>\n#endif\n\n#undef _XOPEN_SOURCE\n#ifdef __sun__\n#undef __EXTENSIONS__\n#endif\n#ifdef _GNU_SOURCE\n#undef _GNU_SOURCE\n#endif\n\n#define UWSGI_CACHE_FLAG_UNGETTABLE\t0x01\n#define UWSGI_CACHE_FLAG_UPDATE\t1 << 1\n#define UWSGI_CACHE_FLAG_LOCAL\t1 << 2\n#define UWSGI_CACHE_FLAG_ABSEXPIRE\t1 << 3\n#define UWSGI_CACHE_FLAG_MATH\t1 << 4\n#define UWSGI_CACHE_FLAG_INC\t1 << 5\n#define UWSGI_CACHE_FLAG_DEC\t1 << 6\n#define UWSGI_CACHE_FLAG_MUL\t1 << 7\n#define UWSGI_CACHE_FLAG_DIV\t1 << 8\n#define UWSGI_CACHE_FLAG_FIXEXPIRE\t1 << 9\n\n#ifdef UWSGI_SSL\n#include <openssl/conf.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#define UWSGI_SSL_SESSION_CACHE\n#endif\n#endif\n\n#include <glob.h>\n\n#ifdef __CYGWIN__\n#define __WINCRYPT_H__\n#include <windows.h>\n#ifdef UWSGI_UUID\n#undef uuid_t\n#endif\n#undef CMSG_DATA\n#define CMSG_DATA(cmsg)         \\\n        ((unsigned char *) ((struct cmsghdr *)(cmsg) + 1))\n#endif\n\nstruct uwsgi_buffer {\n\tchar *buf;\n\tsize_t pos;\n\tsize_t len;\n\tsize_t limit;\n#ifdef UWSGI_DEBUG_BUFFER\n\tint freed;\n#endif\n};\n\nstruct uwsgi_string_list {\n\tchar *value;\n\tsize_t len;\n\tuint64_t custom;\n\tuint64_t custom2;\n\tvoid *custom_ptr;\n\tstruct uwsgi_string_list *next;\n};\n\nstruct uwsgi_custom_option {\n\tchar *name;\n\tchar *value;\n\tint has_args;\n\tstruct uwsgi_custom_option *next;\n};\n\nstruct uwsgi_lock_item {\n\tchar *id;\n\tvoid *lock_ptr;\n\tint rw;\n\tpid_t pid;\n\tint can_deadlock;\n\tstruct uwsgi_lock_item *next;\n};\n\n\nstruct uwsgi_lock_ops {\n\tstruct uwsgi_lock_item *(*lock_init) (char *);\n\tpid_t(*lock_check) (struct uwsgi_lock_item *);\n\tvoid (*lock) (struct uwsgi_lock_item *);\n\tvoid (*unlock) (struct uwsgi_lock_item *);\n\n\tstruct uwsgi_lock_item *(*rwlock_init) (char *);\n\tpid_t(*rwlock_check) (struct uwsgi_lock_item *);\n\tvoid (*rlock) (struct uwsgi_lock_item *);\n\tvoid (*wlock) (struct uwsgi_lock_item *);\n\tvoid (*rwunlock) (struct uwsgi_lock_item *);\n};\n\n#define uwsgi_lock_init(x) uwsgi.lock_ops.lock_init(x)\n#define uwsgi_lock_check(x) uwsgi.lock_ops.lock_check(x)\n#define uwsgi_lock(x) uwsgi.lock_ops.lock(x)\n#define uwsgi_unlock(x) uwsgi.lock_ops.unlock(x)\n\n#define uwsgi_rwlock_init(x) uwsgi.lock_ops.rwlock_init(x)\n#define uwsgi_rwlock_check(x) uwsgi.lock_ops.rwlock_check(x)\n#define uwsgi_rlock(x) uwsgi.lock_ops.rlock(x)\n#define uwsgi_wlock(x) uwsgi.lock_ops.wlock(x)\n#define uwsgi_rwunlock(x) uwsgi.lock_ops.rwunlock(x)\n\n#define uwsgi_wait_read_req(x) uwsgi.wait_read_hook(x->fd, uwsgi.socket_timeout) ; x->switches++\n#define uwsgi_wait_write_req(x) uwsgi.wait_write_hook(x->fd, uwsgi.socket_timeout) ; x->switches++\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\n#ifdef UWSGI_PCRE2\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#define PCRE_OVECTOR_BYTESIZE(n) (n+1)*2\n\ntypedef pcre2_code uwsgi_pcre;\n\n#else\n\n#include <pcre.h>\n#define PCRE_OVECTOR_BYTESIZE(n) (n+1)*3\n\ntypedef struct {\n\tpcre *p;\n\tpcre_extra *extra;\n} uwsgi_pcre;\n\n#endif\n#endif\n\nstruct uwsgi_dyn_dict {\n\n\tchar *key;\n\tint keylen;\n\tchar *value;\n\tint vallen;\n\n\tuint64_t hits;\n\tint status;\n\n\tstruct uwsgi_dyn_dict *prev;\n\tstruct uwsgi_dyn_dict *next;\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\n\tuwsgi_pcre *pattern;\n#endif\n\n};\n\nstruct uwsgi_hook {\n\tchar *name;\n\tint (*func)(char *);\n\tstruct uwsgi_hook *next;\n};\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\nstruct uwsgi_regexp_list {\n\n\tuwsgi_pcre *pattern;\n\n\tuint64_t custom;\n\tchar *custom_str;\n\tvoid *custom_ptr;\n\tstruct uwsgi_regexp_list *next;\n};\n#endif\n\nstruct uwsgi_rbtree {\n\tstruct uwsgi_rb_timer *root;\n\tstruct uwsgi_rb_timer *sentinel;\n};\n\nstruct uwsgi_rb_timer {\n\tuint8_t color;\n\tstruct uwsgi_rb_timer *parent;\n\tstruct uwsgi_rb_timer *left;\n\tstruct uwsgi_rb_timer *right;\n\tuint64_t value;\n\tvoid *data;\n};\n\nstruct uwsgi_rbtree *uwsgi_init_rb_timer(void);\nstruct uwsgi_rb_timer *uwsgi_min_rb_timer(struct uwsgi_rbtree *, struct uwsgi_rb_timer *);\nstruct uwsgi_rb_timer *uwsgi_add_rb_timer(struct uwsgi_rbtree *, uint64_t, void *);\nvoid uwsgi_del_rb_timer(struct uwsgi_rbtree *, struct uwsgi_rb_timer *);\n\n\nunion uwsgi_sockaddr {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_un sa_un;\n#ifdef AF_INET6\n\tstruct sockaddr_in6 sa_in6;\n#endif\n};\n\nunion uwsgi_sockaddr_ptr {\n\tstruct sockaddr *sa;\n\tstruct sockaddr_in *sa_in;\n\tstruct sockaddr_un *sa_un;\n#ifdef AF_INET6\n\tstruct sockaddr_in6 *sa_in6;\n#endif\n};\n\n// Gateways are processes (managed by the master) that extends the\n// server core features\n// -- Gateways can prefork or spawn threads --\n\nstruct uwsgi_gateway {\n\n\tchar *name;\n\tchar *fullname;\n\tvoid (*loop) (int, void *);\n\tpid_t pid;\n\tint num;\n\tint use_signals;\n\n\tint internal_subscription_pipe[2];\n\tuint64_t respawns;\n\n\tuid_t uid;\n\tgid_t gid;\n\n\tvoid *data;\n};\n\nstruct uwsgi_gateway_socket {\n\n\tchar *name;\n\tsize_t name_len;\n\tint fd;\n\tchar *zerg;\n\n\tchar *port;\n\tint port_len;\n\n\tint no_defer;\n\n\tvoid *data;\n\tint subscription;\n\tint shared;\n\n\tchar *owner;\n\tstruct uwsgi_gateway *gateway;\n\n\tstruct uwsgi_gateway_socket *next;\n\n\t// could be useful for ssl\n\tvoid *ctx;\n\t// could be useful for plugins\n\tint mode;\n\n};\n\n\n// Daemons are external processes maintained by the master\n\nstruct uwsgi_daemon {\n\tchar *command;\n\tpid_t pid;\n\tuint64_t respawns;\n\ttime_t born;\n\ttime_t last_spawn;\n\tint status;\n\tint registered;\n\n\tint has_daemonized;\n\n\tchar *pidfile;\n\tint daemonize;\n\n\t// this is incremented every time a pidfile is not found\n\tuint64_t pidfile_checks;\n\t// frequency of pidfile checks (default 10 secs)\n\tint freq;\n\n\tint control;\n\tstruct uwsgi_daemon *next;\n\n\tint stop_signal;\n\tint reload_signal;\n\n\tuid_t uid;\n\tuid_t gid;\n\n\tint honour_stdin;\n\n\tstruct uwsgi_string_list *touch;\n\n#ifdef UWSGI_SSL\n\tchar *legion;\n#endif\n\n\tint ns_pid;\n\tint throttle;\n\n\tchar *chdir;\n\n\tint max_throttle;\n\n\tint notifypid;\n};\n\nstruct uwsgi_logger {\n\tchar *name;\n\tchar *id;\n\t ssize_t(*func) (struct uwsgi_logger *, char *, size_t);\n\tint configured;\n\tint fd;\n\tvoid *data;\n\tunion uwsgi_sockaddr addr;\n\tsocklen_t addr_len;\n\tint count;\n\tstruct msghdr msg;\n\tchar *buf;\n\t// used by chosen logger\n\tchar *arg;\n\tstruct uwsgi_logger *next;\n};\n\n#ifdef UWSGI_SSL\nstruct uwsgi_legion_node {\n\tchar *name;\n\tuint16_t name_len;\n\tuint64_t valor;\n\tchar uuid[37];\n\tchar *scroll;\n\tuint16_t scroll_len;\n\tuint64_t checksum;\n\tuint64_t lord_valor;\n\tchar lord_uuid[36];\n\ttime_t last_seen;\n\tstruct uwsgi_legion_node *prev;\n\tstruct uwsgi_legion_node *next;\n};\n\nstruct uwsgi_legion {\n\tchar *legion;\n\tuint16_t legion_len;\n\tuint64_t valor;\n\tchar *addr;\n\tchar *name;\n\tuint16_t name_len;\n\tpid_t pid;\n\tchar uuid[37];\n\tint socket;\n\n\tint quorum;\n\tint changed;\n\t// if set the next packet will be a death-announce\n\tint dead;\n\n\t// set to 1 first time when quorum is reached\n\tint joined;\n\n\tuint64_t checksum;\n\n\tchar *scroll;\n\tuint16_t scroll_len;\n\n\tchar *lord_scroll;\n\tuint16_t lord_scroll_len;\n\tuint16_t lord_scroll_size;\n\n\tchar lord_uuid[36];\n\tuint64_t lord_valor;\n\n\ttime_t i_am_the_lord;\n\n\ttime_t unix_check;\n\n\ttime_t last_warning;\n\n\tstruct uwsgi_lock_item *lock;\n\n\tEVP_CIPHER_CTX *encrypt_ctx;\n\tEVP_CIPHER_CTX *decrypt_ctx;\n\n\tchar *scrolls;\n\tuint64_t scrolls_len;\n\tuint64_t scrolls_max_size;\n\n\t// found nodes dynamic lists\n\tstruct uwsgi_legion_node *nodes_head;\n\tstruct uwsgi_legion_node *nodes_tail;\n\n\t// static list of nodes to send announces to\n\tstruct uwsgi_string_list *nodes;\n\tstruct uwsgi_string_list *lord_hooks;\n\tstruct uwsgi_string_list *unlord_hooks;\n\tstruct uwsgi_string_list *setup_hooks;\n\tstruct uwsgi_string_list *death_hooks;\n\tstruct uwsgi_string_list *join_hooks;\n\tstruct uwsgi_string_list *node_joined_hooks;\n\tstruct uwsgi_string_list *node_left_hooks;\n\n\ttime_t suspended_til;\n\tstruct uwsgi_legion *next;\n};\n\nstruct uwsgi_legion_action {\n\tchar *name;\n\tint (*func) (struct uwsgi_legion *, char *);\n\tchar *log_msg;\n\tstruct uwsgi_legion_action *next;\n};\n#endif\n\nstruct uwsgi_queue_header {\n\tuint64_t pos;\n\tuint64_t pull_pos;\n};\n\nstruct uwsgi_queue_item {\n\tuint64_t size;\n\ttime_t ts;\n};\n\nstruct uwsgi_hash_algo {\n\tchar *name;\n\t uint32_t(*func) (char *, uint64_t);\n\tstruct uwsgi_hash_algo *next;\n};\n\nstruct uwsgi_hash_algo *uwsgi_hash_algo_get(char *);\nvoid uwsgi_hash_algo_register(char *, uint32_t(*)(char *, uint64_t));\nvoid uwsgi_hash_algo_register_all(void);\n\nstruct uwsgi_sharedarea {\n\tint id;\n\tint pages;\n\tint fd;\n\tstruct uwsgi_lock_item *lock;\n\tchar *area;\n\tuint64_t max_pos;\n\tuint64_t updates;\n\tuint64_t hits;\n\tuint8_t honour_used;\n\tuint64_t used;\n\tvoid *obj;\n};\n\n// maintain alignment here !!!\nstruct uwsgi_cache_item {\n\t// item specific flags\n\tuint64_t flags;\n\t// size of the key\n\tuint64_t keysize;\n\t// hash of the key\n\tuint64_t hash;\n\t// size of the value (64bit)\n\tuint64_t valsize;\n\t// block position (in non-bitmap mode maps to the key index)\n\tuint64_t first_block;\n\t// 64bit expiration (0 for immortal)\n\tuint64_t expires;\n\t// 64bit hits\n\tuint64_t hits;\n\t// previous same-hash item\n\tuint64_t prev;\n\t// next same-hash item\n\tuint64_t next;\n\t// previous lru item\n\tuint64_t lru_prev;\n\t// next lru item\n\tuint64_t lru_next;\n\t// key characters follows...\n\tchar key[];\n} __attribute__ ((__packed__));\n\nstruct uwsgi_cache {\n\tchar *name;\n\tuint16_t name_len;\n\n\tuint64_t keysize;\n\tuint64_t blocks;\n\tuint64_t blocksize;\n\n\tstruct uwsgi_hash_algo *hash;\n\tuint64_t *hashtable;\n\tuint32_t hashsize;\n\n\tuint64_t first_available_block;\n\tuint64_t *unused_blocks_stack;\n\tuint64_t unused_blocks_stack_ptr;\n\n\tuint8_t use_blocks_bitmap;\n\tuint8_t *blocks_bitmap;\n\tuint64_t blocks_bitmap_pos;\n\tuint64_t blocks_bitmap_size;\n\n\tuint64_t max_items;\n\tuint64_t max_item_size;\n\tuint64_t n_items;\n\tstruct uwsgi_cache_item *items;\n\n\tuint8_t use_last_modified;\n\ttime_t last_modified_at;\n\n\tvoid *data;\n\n\tuint8_t no_expire;\n\tuint64_t full;\n\tuint64_t hits;\n\tuint64_t miss;\n\n\tchar *store;\n\tuint64_t filesize;\n\tuint64_t store_sync;\n\n\tint64_t math_initial;\n\n\tstruct uwsgi_string_list *nodes;\n\tint udp_node_socket;\n\tstruct uwsgi_string_list *sync_nodes;\n\tstruct uwsgi_string_list *udp_servers;\n\n\tstruct uwsgi_lock_item *lock;\n\n\tstruct uwsgi_cache *next;\n\n\tint ignore_full;\n\n\tuint64_t next_scan;\n\tint purge_lru;\n\tuint64_t lru_head;\n\tuint64_t lru_tail;\n\n\tint store_delete;\n\tint lazy_expire;\n\tuint64_t sweep_on_full;\n\tint clear_on_full;\n};\n\nstruct uwsgi_option {\n\tchar *name;\n\tint type;\n\tint shortcut;\n\tchar *help;\n\tvoid (*func) (char *, char *, void *);\n\tvoid *data;\n\tuint64_t flags;\n};\n\nstruct uwsgi_opt {\n\tchar *key;\n\tchar *value;\n\tint configured;\n};\n\n#define UWSGI_OK\t0\n#define UWSGI_AGAIN\t1\n#define UWSGI_ACCEPTING\t2\n#define UWSGI_PAUSED\t3\n\n#ifdef __linux__\n#include <endian.h>\n#if defined(__BYTE_ORDER__)\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define __BIG_ENDIAN__ 1\n#endif\n#endif\n#elif defined(__sun__)\n#include <sys/byteorder.h>\n#ifdef _BIG_ENDIAN\n#define __BIG_ENDIAN__ 1\n#endif\n#elif defined(__APPLE__)\n#include <libkern/OSByteOrder.h>\n#elif defined(__HAIKU__)\n#elif defined(__HURD__)\n#define PATH_MAX 8192\n#define RTLD_DEFAULT   ((void *) 0)\n#else\n#include <machine/endian.h>\n#endif\n\n#define UWSGI_SPOOLER_EXTERNAL\t\t1\n\n#define UWSGI_MODIFIER_ADMIN_REQUEST\t10\n#define UWSGI_MODIFIER_SPOOL_REQUEST\t17\n#define UWSGI_MODIFIER_EVAL\t\t22\n#define UWSGI_MODIFIER_FASTFUNC\t\t26\n#define UWSGI_MODIFIER_MANAGE_PATH_INFO\t30\n#define UWSGI_MODIFIER_MESSAGE\t\t31\n#define UWSGI_MODIFIER_MESSAGE_ARRAY\t32\n#define UWSGI_MODIFIER_MESSAGE_MARSHAL\t33\n#define UWSGI_MODIFIER_MULTICAST_ANNOUNCE\t73\n#define UWSGI_MODIFIER_MULTICAST\t74\n#define UWSGI_MODIFIER_PING\t\t100\n\n#define UWSGI_MODIFIER_RESPONSE\t\t255\n\n#define NL_SIZE 2\n#define H_SEP_SIZE 2\n\n#define UWSGI_RELOAD_CODE 17\n#define UWSGI_END_CODE 30\n#define UWSGI_EXILE_CODE 26\n#define UWSGI_FAILED_APP_CODE 22\n#define UWSGI_DE_HIJACKED_CODE 173\n#define UWSGI_EXCEPTION_CODE 5\n#define UWSGI_QUIET_CODE 29\n#define UWSGI_BRUTAL_RELOAD_CODE 31\n#define UWSGI_GO_CHEAP_CODE 15\n\n#define MAX_VARS 64\n\nstruct uwsgi_loop {\n\tchar *name;\n\tvoid (*loop) (void);\n\tstruct uwsgi_loop *next;\n};\n\nstruct wsgi_request;\n\nstruct uwsgi_socket {\n\tint fd;\n\tchar *name;\n\tint name_len;\n\tint family;\n\tint bound;\n\tint arg;\n\tvoid *ctx;\n\n\tuint64_t queue;\n\tuint64_t max_queue;\n\tint no_defer;\n\n\tint auto_port;\n\t// true if connection must be initialized for each core\n\tint per_core;\n\n\t// this is the protocol internal name\n\tchar *proto_name;\n\n\t// call that when a request is accepted\n\tint (*proto_accept) (struct wsgi_request *, int);\n\t// call that to parse the request (without the body)\n\tint (*proto) (struct wsgi_request *);\n\t// call that to write response\n\tint (*proto_write) (struct wsgi_request *, char *, size_t);\n\t// call that to write headers (if a special case is needed for them)\n\tint (*proto_write_headers) (struct wsgi_request *, char *, size_t);\n\t// call that when sendfile() is invoked\n\tint (*proto_sendfile) (struct wsgi_request *, int, size_t, size_t);\n\t// call that to read the body of a request (could map to a simple read())\n\tssize_t(*proto_read_body) (struct wsgi_request *, char *, size_t);\n\t// hook to call when a new series of response headers is created\n\tstruct uwsgi_buffer *(*proto_prepare_headers) (struct wsgi_request *, char *, uint16_t);\n\t// hook to call when a header must be added\n\tstruct uwsgi_buffer *(*proto_add_header) (struct wsgi_request *, char *, uint16_t, char *, uint16_t);\n\t// last function to call before sending headers to the client\n\tint (*proto_fix_headers) (struct wsgi_request *);\n\t// hook to call when a request is closed\n\tvoid (*proto_close) (struct wsgi_request *);\n\t// special hook to call (if needed) in multithread mode\n\tvoid (*proto_thread_fixup) (struct uwsgi_socket *, int);\n\t// optimization for vectors\n\tint (*proto_writev) (struct wsgi_request *, struct iovec *, size_t *);\n\n\tint edge_trigger;\n\tint *retry;\n\n\tint can_offload;\n\n\t// this is a special map for having socket->thread mapping\n\tint *fd_threads;\n\n\t// generally used by zeromq handlers\n\tchar uuid[37];\n\tvoid *pub;\n\tvoid *pull;\n\tpthread_key_t key;\n\n\tpthread_mutex_t lock;\n\n\tchar *receiver;\n\n\tint disabled;\n\tint recv_flag;\n\n\tstruct uwsgi_socket *next;\n\tint lazy;\n\tint shared;\n\tint from_shared;\n\n\t// used for avoiding vacuum mess\n\tino_t inode;\n\n#ifdef UWSGI_SSL\n\tSSL_CTX *ssl_ctx;\n#endif\n\n};\n\nstruct uwsgi_protocol {\n        char *name;\n        void (*func)(struct uwsgi_socket *);\n        struct uwsgi_protocol *next;\n};\n\nstruct uwsgi_server;\nstruct uwsgi_instance;\n\nstruct uwsgi_plugin {\n\n\tconst char *name;\n\tconst char *alias;\n\tuint8_t modifier1;\n\tvoid *data;\n\tvoid (*on_load) (void);\n\tint (*init) (void);\n\tvoid (*post_init) (void);\n\tvoid (*post_fork) (void);\n\tstruct uwsgi_option *options;\n\tvoid (*enable_threads) (void);\n\tvoid (*init_thread) (int);\n\tint (*request) (struct wsgi_request *);\n\tvoid (*after_request) (struct wsgi_request *);\n\tvoid (*preinit_apps) (void);\n\tvoid (*init_apps) (void);\n\tvoid (*postinit_apps) (void);\n\tvoid (*fixup) (void);\n\tvoid (*master_fixup) (int);\n\tvoid (*master_cycle) (void);\n\tint (*mount_app) (char *, char *);\n\tint (*manage_udp) (char *, int, char *, int);\n\tvoid (*suspend) (struct wsgi_request *);\n\tvoid (*resume) (struct wsgi_request *);\n\n\tvoid (*harakiri) (int);\n\n\tvoid (*hijack_worker) (void);\n\tvoid (*spooler_init) (void);\n\tvoid (*atexit) (void);\n\n\tint (*magic) (char *, char *);\n\n\tvoid *(*encode_string) (char *);\n\tchar *(*decode_string) (void *);\n\tint (*signal_handler) (uint8_t, void *);\n\tchar *(*code_string) (char *, char *, char *, char *, uint16_t);\n\n\tint (*spooler) (char *, char *, uint16_t, char *, size_t);\n\n\tuint64_t(*rpc) (void *, uint8_t, char **, uint16_t *, char **);\n\n\tvoid (*jail) (int (*)(void *), char **);\n\tvoid (*post_jail) (void);\n\tvoid (*before_privileges_drop) (void);\n\n\tint (*mule) (char *);\n\tint (*mule_msg) (char *, size_t);\n\n\tvoid (*master_cleanup) (void);\n\n\tstruct uwsgi_buffer* (*backtrace)(struct wsgi_request *);\n        struct uwsgi_buffer* (*exception_class)(struct wsgi_request *);\n        struct uwsgi_buffer* (*exception_msg)(struct wsgi_request *);\n        struct uwsgi_buffer* (*exception_repr)(struct wsgi_request *);\n        void (*exception_log)(struct wsgi_request *);\n\n\tvoid (*vassal)(struct uwsgi_instance *);\n\tvoid (*vassal_before_exec)(struct uwsgi_instance *, char **);\n\n\tint (*worker)(void);\n\n\tvoid (*early_post_jail) (void);\n\n\tvoid (*pre_uwsgi_fork) (void);\n\tvoid (*post_uwsgi_fork) (int);\n};\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\nint uwsgi_regexp_build(char *, uwsgi_pcre **);\nint uwsgi_regexp_match(uwsgi_pcre *, const char *, int);\nint uwsgi_regexp_match_ovec(uwsgi_pcre *, const char *, int, int *, int);\nint uwsgi_regexp_ovector(const uwsgi_pcre *);\nchar *uwsgi_regexp_apply_ovec(char *, int, char *, int, int *, int);\n\nint uwsgi_regexp_match_pattern(char *pattern, char *str);\n#endif\n\n\n\nstruct uwsgi_app {\n\n\tuint8_t modifier1;\n\n\tchar mountpoint[0xff];\n\tuint8_t mountpoint_len;\n\n\tvoid *interpreter;\n\tvoid *callable;\n\n\tvoid **args;\n\tvoid **environ;\n\n\tvoid *sendfile;\n\tvoid *input;\n\tvoid *error;\n\tvoid *stream;\n\n\t// custom values you can use for internal purpose\n\tvoid *responder0;\n\tvoid *responder1;\n\tvoid *responder2;\n\n\tvoid *eventfd_read;\n\tvoid *eventfd_write;\n\n\tvoid *(*request_subhandler) (struct wsgi_request *, struct uwsgi_app *);\n\tint (*response_subhandler) (struct wsgi_request *);\n\n\tint argc;\n\tuint64_t requests;\n\tuint64_t exceptions;\n\n\tchar chdir[0xff];\n\tchar touch_reload[0xff];\n\n\ttime_t touch_reload_mtime;\n\n\tvoid *gateway_version;\n\tvoid *uwsgi_version;\n\tvoid *uwsgi_node;\n\n\ttime_t started_at;\n\ttime_t startup_time;\n\n\tuint64_t avg_response_time;\n};\n\nstruct uwsgi_spooler {\n\n\tchar dir[PATH_MAX];\n\tpid_t pid;\n\tuint64_t respawned;\n\tuint64_t tasks;\n\tstruct uwsgi_lock_item *lock;\n\ttime_t harakiri;\n\ttime_t user_harakiri;\n\n\tint mode;\n\n\tint running;\n\n\tint signal_pipe[2];\n\n\tstruct uwsgi_spooler *next;\n\n\ttime_t last_task_managed;\n\n\ttime_t cursed_at;\n\ttime_t no_mercy_at;\n};\n\n#ifdef UWSGI_ROUTING\n\n// go to the next route\n#define UWSGI_ROUTE_NEXT 0\n// continue to the request handler\n#define UWSGI_ROUTE_CONTINUE 1\n// close the request\n#define UWSGI_ROUTE_BREAK 2\n\nstruct uwsgi_route {\n\n\tuwsgi_pcre *pattern;\n\n\tchar *orig_route;\n\t\n\t// one for each core\n\tint *ovn;\n\tint **ovector;\n\tstruct uwsgi_buffer **condition_ub;\n\n\tchar *subject_str;\n\tsize_t subject_str_len;\n\tsize_t subject;\n\tsize_t subject_len;\n\n\tint (*if_func)(struct wsgi_request *, struct uwsgi_route *);\n\tint if_negate;\n\tint if_status;\n\n\tint (*func) (struct wsgi_request *, struct uwsgi_route *);\n\n\tvoid *data;\n\tsize_t data_len;\n\n\tvoid *data2;\n\tsize_t data2_len;\n\n\tvoid *data3;\n\tsize_t data3_len;\n\n\tvoid *data4;\n\tsize_t data4_len;\n\n\t// 64bit value for custom usage\n\tuint64_t custom;\n\n\tuint64_t pos;\n\tchar *label;\n\tsize_t label_len;\n\n\tchar *regexp;\n\tchar *action;\n\n\t// this is used by virtual route to free resources\n\tvoid (*free)(struct uwsgi_route *);\n\n\tstruct uwsgi_route *next;\n\n};\n\nstruct uwsgi_route_condition {\n\tchar *name;\n\tint (*func)(struct wsgi_request *, struct uwsgi_route *);\n\tstruct uwsgi_route_condition *next;\n};\n\nstruct uwsgi_route_var {\n\tchar *name;\n\tuint16_t name_len;\n\tchar *(*func)(struct wsgi_request *, char *, uint16_t, uint16_t *);\n\tint need_free;\n\tstruct uwsgi_route_var *next;\n};\n\nstruct uwsgi_router {\n\tchar *name;\n\tint (*func) (struct uwsgi_route *, char *);\n\tstruct uwsgi_router *next;\n};\n\n#endif\n\nstruct uwsgi_alarm;\nstruct uwsgi_alarm_instance {\n\tchar *name;\n\tchar *arg;\n\tvoid *data_ptr;\n\tuint8_t data8;\n\tuint16_t data16;\n\tuint32_t data32;\n\tuint64_t data64;\n\n\ttime_t last_run;\n\n\tchar *last_msg;\n\tsize_t last_msg_size;\n\n\tstruct uwsgi_alarm *alarm;\n\tstruct uwsgi_alarm_instance *next;\n};\n\nstruct uwsgi_alarm {\n\tchar *name;\n\tvoid (*init) (struct uwsgi_alarm_instance *);\n\tvoid (*func) (struct uwsgi_alarm_instance *, char *, size_t);\n\tstruct uwsgi_alarm *next;\n};\n\nstruct uwsgi_alarm_fd {\n\tint fd;\n\tsize_t buf_len;\n\tvoid *buf;\n\tchar *msg;\n\tsize_t msg_len;\n\tstruct uwsgi_alarm_instance *alarm;\n\tstruct uwsgi_alarm_fd *next;\n};\n\nstruct uwsgi_alarm_fd *uwsgi_add_alarm_fd(int, char *, size_t, char *, size_t);\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\nstruct uwsgi_alarm_ll {\n\tstruct uwsgi_alarm_instance *alarm;\n\tstruct uwsgi_alarm_ll *next;\n};\n\nstruct uwsgi_alarm_log {\n\tuwsgi_pcre *pattern;\n\tint negate;\n\tstruct uwsgi_alarm_ll *alarms;\n\tstruct uwsgi_alarm_log *next;\n};\n#endif\n\nstruct __attribute__ ((packed)) uwsgi_header {\n\tuint8_t modifier1;\n\tuint16_t _pktsize;\n\tuint8_t modifier2;\n};\n\nstruct uwsgi_async_fd {\n\tint fd;\n\tint event;\n\tstruct uwsgi_async_fd *prev;\n\tstruct uwsgi_async_fd *next;\n};\n\nstruct uwsgi_logvar {\n\tchar key[256];\n\tuint8_t keylen;\n\tchar val[256];\n\tuint8_t vallen;\n\tstruct uwsgi_logvar *next;\n};\n\nstruct uwsgi_log_encoder {\n\tchar *name;\n\tchar *(*func)(struct uwsgi_log_encoder *, char *, size_t, size_t *);\n\tint configured;\n\tchar *use_for;\n\tchar *args;\n\tvoid *data;\n\tstruct uwsgi_log_encoder *next;\n};\n\nstruct uwsgi_transformation {\n\tint (*func)(struct wsgi_request *, struct uwsgi_transformation *);\n\tstruct uwsgi_buffer *chunk;\n\tuint8_t can_stream;\n\tuint8_t is_final;\n\tuint8_t flushed;\n\tvoid *data;\n\tuint64_t round;\n\tint fd;\n\tstruct uwsgi_buffer *ub;\n\tuint64_t len;\n\tuint64_t custom64;\n\tstruct uwsgi_transformation *next;\n};\n\nenum uwsgi_range {\n\tUWSGI_RANGE_NOT_PARSED,\n\tUWSGI_RANGE_PARSED,\n\tUWSGI_RANGE_VALID,\n\tUWSGI_RANGE_INVALID,\n};\n\n// avoid name clashes on solaris\n#undef sun\n\nstruct wsgi_request {\n\tint fd;\n\tstruct uwsgi_header *uh;\n\n\tint app_id;\n\tint dynamic;\n\tint parsed;\n\n\tchar *appid;\n\tuint16_t appid_len;\n\n\t// This structure should not be used any more\n\t// in favor of the union client_addr at the end\n\tstruct sockaddr_un c_addr;\n\tint c_len;\n\n\t//iovec\n\tstruct iovec *hvec;\n\n\tuint64_t start_of_request;\n\tuint64_t start_of_request_in_sec;\n\tuint64_t end_of_request;\n\n\tchar *uri;\n\tuint16_t uri_len;\n\tchar *remote_addr;\n\tuint16_t remote_addr_len;\n\tchar *remote_user;\n\tuint16_t remote_user_len;\n\tchar *query_string;\n\tuint16_t query_string_len;\n\tchar *protocol;\n\tuint16_t protocol_len;\n\tchar *method;\n\tuint16_t method_len;\n\tchar *scheme;\n\tuint16_t scheme_len;\n\tchar *https;\n\tuint16_t https_len;\n\tchar *script_name;\n\tuint16_t script_name_len;\n\tint script_name_pos;\n\n\tchar *host;\n\tuint16_t host_len;\n\n\tchar *content_type;\n\tuint16_t content_type_len;\n\n\tchar *document_root;\n\tuint16_t document_root_len;\n\n\tchar *user_agent;\n\tuint16_t user_agent_len;\n\n\tchar *encoding;\n\tuint16_t encoding_len;\n\n\tchar *referer;\n\tuint16_t referer_len;\n\n\tchar *cookie;\n\tuint16_t cookie_len;\n\n\tchar *path_info;\n\tuint16_t path_info_len;\n\tint path_info_pos;\n\n\tchar *authorization;\n\tuint16_t authorization_len;\n\n\tuint16_t via;\n\n\tchar *script;\n\tuint16_t script_len;\n\tchar *module;\n\tuint16_t module_len;\n\tchar *callable;\n\tuint16_t callable_len;\n\tchar *home;\n\tuint16_t home_len;\n\n\tchar *file;\n\tuint16_t file_len;\n\n\tchar *paste;\n\tuint16_t paste_len;\n\n\tchar *chdir;\n\tuint16_t chdir_len;\n\n\tchar *touch_reload;\n\tuint16_t touch_reload_len;\n\n\tchar *cache_get;\n\tuint16_t cache_get_len;\n\n\tchar *if_modified_since;\n\tuint16_t if_modified_since_len;\n\n\tint fd_closed;\n\n\tint sendfile_fd;\n\tsize_t sendfile_fd_chunk;\n\tsize_t sendfile_fd_size;\n\toff_t sendfile_fd_pos;\n\tvoid *sendfile_obj;\n\n\tuint16_t var_cnt;\n\tuint16_t header_cnt;\n\n\tint do_not_log;\n\n\tint do_not_add_to_async_queue;\n\n\tint do_not_account;\n\n\tint status;\n\tstruct uwsgi_buffer *headers;\n\n\tsize_t response_size;\n\tsize_t headers_size;\n\n\tint async_id;\n\tint async_status;\n\n\tint switches;\n\tsize_t write_pos;\n\n\tint async_timed_out;\n\tint async_ready_fd;\n\tint async_last_ready_fd;\n\tstruct uwsgi_rb_timer *async_timeout;\n\tstruct uwsgi_async_fd *waiting_fds;\n\n\tvoid *async_app;\n\tvoid *async_result;\n\tvoid *async_placeholder;\n\tvoid *async_args;\n\tvoid *async_environ;\n\tvoid *async_input;\n\tvoid *async_sendfile;\n\n\tint async_force_again;\n\n\tint async_plagued;\n\n\tint suspended;\n\tuint64_t write_errors;\n\tuint64_t read_errors;\n\n\tint *ovector;\n\tsize_t post_cl;\n\tsize_t post_pos;\n\tsize_t post_readline_size;\n\tsize_t post_readline_pos;\n\tsize_t post_readline_watermark;\n\tFILE *post_file;\n\tchar *post_readline_buf;\n\t// this is used when no post buffering is in place\n\tchar *post_read_buf;\n\tsize_t post_read_buf_size;\n\tchar *post_buffering_buf;\n\t// when set, do not send warnings about bad behaviours\n\tint post_warning;\n\n\t// deprecated fields: size_t is 32bit on 32bit platform\n\tsize_t __range_from;\n\tsize_t __range_to;\n\n\t// current socket mapped to request\n\tstruct uwsgi_socket *socket;\n\n\t// check if headers are already sent\n\tint headers_sent;\n\tint headers_hvec;\n\n\tuint64_t proto_parser_pos;\n\tuint64_t proto_parser_move;\n\tint64_t proto_parser_status;\n\tvoid *proto_parser_buf;\n\tuint64_t proto_parser_buf_size;\n\tvoid *proto_parser_remains_buf;\n\tsize_t proto_parser_remains;\n\n\tchar *buffer;\n\n\tint log_this;\n\n\tint sigwait;\n\tint signal_received;\n\n\tstruct uwsgi_logvar *logvars;\n\tstruct uwsgi_string_list *additional_headers;\n\tstruct uwsgi_string_list *remove_headers;\n\n\tstruct uwsgi_buffer *websocket_buf;\n\tstruct uwsgi_buffer *websocket_send_buf;\n\tsize_t websocket_need;\n\tint websocket_phase;\n\tuint8_t websocket_opcode;\n\tsize_t websocket_has_mask;\n\tsize_t websocket_size;\n\tsize_t websocket_pktsize;\n\ttime_t websocket_last_ping;\n\ttime_t websocket_last_pong;\n\tint websocket_closed;\n\t// websocket specific headers\n\tchar *http_sec_websocket_key;\n\tuint16_t http_sec_websocket_key_len;\n\tchar *http_origin;\n\tuint16_t http_origin_len;\n\tchar *http_sec_websocket_protocol;\n\tuint16_t http_sec_websocket_protocol_len;\n\t\n\n\tstruct uwsgi_buffer *chunked_input_buf;\n\tuint8_t chunked_input_parser_status;\n\tssize_t chunked_input_chunk_len;\n\tsize_t chunked_input_need;\n\tuint8_t chunked_input_complete;\n        size_t chunked_input_decapitate;\n\n\tuint64_t stream_id;\n\n\t// avoid routing loops\n\tint is_routing;\n\tint is_final_routing;\n\tint is_error_routing;\n\tint is_response_routing;\n\tint routes_applied;\n\tint response_routes_applied;\n\t// internal routing vm program counter\n\tuint32_t route_pc;\n\tuint32_t error_route_pc;\n\tuint32_t response_route_pc;\n\tuint32_t final_route_pc;\n\t// internal routing goto instruction\n\tuint32_t route_goto;\n\tuint32_t error_route_goto;\n\tuint32_t response_route_goto;\n\tuint32_t final_route_goto;\n\n\tint ignore_body;\n\n\tstruct uwsgi_transformation *transformations;\n\tchar *transformed_chunk;\n\tsize_t transformed_chunk_len;\n\n\tint is_raw;\n\n#ifdef UWSGI_SSL\n\tSSL *ssl;\n#endif\n\n\t// do not update avg_rt after request\n\tint do_not_account_avg_rt;\n\t// used for protocol parsers requiring EOF signaling\n\tint proto_parser_eof;\n\n\tint body_is_chunked;\n\tstruct uwsgi_buffer *body_chunked_buf;\n\n\t// uWSGI 2.1\n\tuint64_t len;\n\n\t// 64bit range, deprecates size_t __range_from, __range_to\n\tenum uwsgi_range range_parsed;\n\tint64_t range_from;\n\tint64_t range_to;\n\n\t// source address union, deprecates c_addr\n\tunion address {\n\t\tstruct sockaddr_in sin;\n\t\tstruct sockaddr_in6 sin6;\n\t\tstruct sockaddr_un sun;\n\t} client_addr;\n\n\tchar * if_range;\n\tuint16_t if_range_len;\n\n\tuint8_t websocket_is_fin;\n};\n\n\nstruct uwsgi_fmon {\n\tchar filename[0xff];\n\tint fd;\n\tint id;\n\tint registered;\n\tuint8_t sig;\n};\n\nstruct uwsgi_timer {\n\tint value;\n\tint fd;\n\tint id;\n\tint registered;\n\tuint8_t sig;\n\tlong nsvalue;\n};\n\nstruct uwsgi_signal_rb_timer {\n\tint value;\n\tint registered;\n\tint iterations;\n\tint iterations_done;\n\tuint8_t sig;\n\tstruct uwsgi_rb_timer *uwsgi_rb_timer;\n};\n\nstruct uwsgi_cheaper_algo {\n\n\tchar *name;\n\tint (*func) (int);\n\tstruct uwsgi_cheaper_algo *next;\n};\n\nstruct uwsgi_emperor_scanner;\n\nstruct uwsgi_imperial_monitor {\n\tchar *scheme;\n\tvoid (*init) (struct uwsgi_emperor_scanner *);\n\tvoid (*func) (struct uwsgi_emperor_scanner *);\n\tstruct uwsgi_imperial_monitor *next;\n};\n\nstruct uwsgi_clock {\n\tchar *name;\n\ttime_t(*seconds) (void);\n\tuint64_t(*microseconds) (void);\n\tstruct uwsgi_clock *next;\n};\n\nstruct uwsgi_subscribe_slot;\nstruct uwsgi_stats_pusher;\nstruct uwsgi_stats_pusher_instance;\n\n#define UWSGI_PROTO_MIN_CHECK 4\n#define UWSGI_PROTO_MAX_CHECK 28\n\nstruct uwsgi_offload_engine;\n\n// these are the possible states of an instance\nstruct uwsgi_instance_status {\n\tint gracefully_reloading;\n\tint brutally_reloading;\n\tint gracefully_destroying;\n\tint brutally_destroying;\n\tint chain_reloading;\n\tint workers_reloading;\n\tint is_cheap;\n\tint is_cleaning;\n\tint dying_for_need_app;\n};\n\nstruct uwsgi_configurator {\n\tchar *name;\n\tvoid (*func)(char *, char **);\n\tstruct uwsgi_configurator *next;\n};\nstruct uwsgi_configurator *uwsgi_register_configurator(char *, void (*)(char *, char **));\nvoid uwsgi_opt_load_config(char *, char *, void *);\n\n#define uwsgi_instance_is_dying (uwsgi.status.gracefully_destroying || uwsgi.status.brutally_destroying)\n#define uwsgi_instance_is_reloading (uwsgi.status.gracefully_reloading || uwsgi.status.brutally_reloading)\n\n#define exit(x) uwsgi_exit(x)\n\nstruct uwsgi_metric;\n\nstruct uwsgi_logging_options {\n\tint enabled;\n\tint memory_report;\n\tint zero;\n\tint _4xx;\n\tint _5xx;\n\tint sendfile;\n\tint ioerror;\n\tuint32_t slow;\n\tuint64_t big;\n\tint log_x_forwarded_for;\n};\n\nstruct uwsgi_harakiri_options {\n\tint workers;\n\tint spoolers;\n\tint mules;\n};\n\nstruct uwsgi_fsmon {\n\tchar *path;\n\tint fd;\n\tint id;\n\tvoid *data;\n\tvoid (*func)(struct uwsgi_fsmon *);\n\tstruct uwsgi_fsmon *next;\n};\n\nstruct uwsgi_subscription_client;\n\nstruct uwsgi_server {\n\n\t// store the machine hostname\n\tchar hostname[256];\n\tint hostname_len;\n\n\t// used to store the exit code for atexit hooks\n\tint last_exit_code;\n\n\tint (*proto_hooks[UWSGI_PROTO_MAX_CHECK]) (struct wsgi_request *, char *, char *, uint16_t);\n\tstruct uwsgi_configurator *configurators;\n\n\tchar **orig_argv;\n\tchar **argv;\n\tint argc;\n\t// replaced by argv_len + environ_len, kept for ABI compatibility\n\tint max_procname;\n\tint auto_procname;\n\tchar **environ;\n\tchar *procname_prefix;\n\tchar *procname_append;\n\tchar *procname_master;\n\tchar *procname;\n\n\tstruct uwsgi_logging_options logging_options;\n\tstruct uwsgi_harakiri_options harakiri_options;\n\tint socket_timeout;\n\tint reaper;\n\tint cgi_mode;\n\tuint64_t max_requests;\n\tuint64_t min_worker_lifetime;\n\tuint64_t max_worker_lifetime;\n\n\t// daemontools-like envdir\n\tstruct uwsgi_string_list *envdirs;\n\n\tchar *requested_clock;\n\tstruct uwsgi_clock *clocks;\n\tstruct uwsgi_clock *clock;\n\n\tchar *empty;\n\n\t// quiet startup\n\tint no_initial_output;\n\n\tstruct uwsgi_instance_status status;\n\n\tstruct uwsgi_string_list *get_list;\n\n\t// enable threads\n\tint has_threads;\n\tint no_threads_wait;\n\n\t// default app id\n\tint default_app;\n\n\tchar *logto2;\n\tchar *logformat;\n\tint logformat_strftime;\n\tint logformat_vectors;\n\tstruct uwsgi_logchunk *logchunks;\n\tstruct uwsgi_logchunk *registered_logchunks;\n\tvoid (*logit) (struct wsgi_request *);\n\tstruct iovec **logvectors;\n\n\t// autoload plugins\n\tint autoload;\n\tstruct uwsgi_string_list *plugins_dir;\n\tstruct uwsgi_string_list *blacklist;\n\tstruct uwsgi_string_list *whitelist;\n\tchar *blacklist_context;\n\tchar *whitelist_context;\n\n\tunsigned int reloads;\n\n\t// leave master running as root\n\tint master_as_root;\n\t// postpone privileges drop\n\tint drop_after_init;\n\tint drop_after_apps;\n\n\tint master_is_reforked;\n\n\tstruct uwsgi_string_list *master_fifo;\n\tint master_fifo_fd;\n\tint master_fifo_slot;\n\n\n\t// kill the stack on SIGTERM (instead of brutal reloading)\n\tint die_on_term;\n\n\t// force the first gateway without a master\n\tint force_gateway;\n\n\t// disable fd passing on unix socket\n\tint no_fd_passing;\n\n\t// store the current time\n\ttime_t current_time;\n\n\tuint64_t master_cycles;\n\n\tint reuse_port;\n\tint tcp_fast_open;\n\tint tcp_fast_open_client;\n\n\tint enable_proxy_protocol;\n\n\tuint64_t fastcgi_modifier1;\n\tuint64_t fastcgi_modifier2;\n\tuint64_t http_modifier1;\n\tuint64_t http_modifier2;\n\tuint64_t https_modifier1;\n\tuint64_t https_modifier2;\n\tuint64_t scgi_modifier1;\n\tuint64_t scgi_modifier2;\n\tuint64_t raw_modifier1;\n\tuint64_t raw_modifier2;\n\n\t// enable lazy mode\n\tint lazy;\n\t// enable lazy-apps mode\n\tint lazy_apps;\n\t// enable cheaper mode\n\tint cheaper;\n\tchar *requested_cheaper_algo;\n\tstruct uwsgi_cheaper_algo *cheaper_algos;\n\tint (*cheaper_algo) (int);\n\tint cheaper_step;\n\tuint64_t cheaper_overload;\n\t// minimal number of running workers in cheaper mode\n\tint cheaper_count;\n\tint cheaper_initial;\n\t// enable idle mode\n\tint idle;\n\n\t// cheaper mode memory usage limits\n\tuint64_t cheaper_rss_limit_soft;\n\tuint64_t cheaper_rss_limit_hard;\n\n\tint cheaper_fifo_delta;\n\n\t// destroy the stack when idle\n\tint die_on_idle;\n\n\t// store the screen session\n\tchar *screen_session;\n\n\t// true if run under the emperor\n\tint has_emperor;\n\tchar *emperor_procname;\n\tchar *emperor_proxy;\n\tint emperor_fd;\n\tint emperor_fd_proxy;\n\tint emperor_queue;\n\tint emperor_nofollow;\n\tint emperor_tyrant;\n\tint emperor_tyrant_nofollow;\n\tint emperor_fd_config;\n\tint early_emperor;\n\tint emperor_throttle;\n\tint emperor_freq;\n\tint emperor_max_throttle;\n\tint emperor_magic_exec;\n\tint emperor_heartbeat;\n\tint emperor_curse_tolerance;\n\tstruct uwsgi_string_list *emperor_extra_extension;\n\t// search for a file with the specified extension at the same level of the vassal file\n\tchar *emperor_on_demand_extension;\n\t// bind to a unix socket on the specified directory named directory/vassal.socket\n\tchar *emperor_on_demand_directory;\n\t// run a shell script passing the vassal as the only argument, the stdout is used as the socket\n\tchar *emperor_on_demand_exec;\n\n\tint disable_nuclear_blast;\n\n\ttime_t next_heartbeat;\n\tint heartbeat;\n\tstruct uwsgi_string_list *emperor;\n\tstruct uwsgi_imperial_monitor *emperor_monitors;\n\tchar *emperor_absolute_dir;\n\tchar *emperor_pidfile;\n\tpid_t emperor_pid;\n\tint emperor_broodlord;\n\tint emperor_broodlord_count;\n\tuint64_t emperor_broodlord_num;\n\tchar *emperor_stats;\n\tint emperor_stats_fd;\n\tstruct uwsgi_string_list *vassals_templates;\n\tstruct uwsgi_string_list *vassals_includes;\n\tstruct uwsgi_string_list *vassals_templates_before;\n\tstruct uwsgi_string_list *vassals_includes_before;\n\tstruct uwsgi_string_list *vassals_set;\n\t// true if loyal to the emperor\n\tint loyal;\n\n\t// emperor hook (still in development)\n\tchar *vassals_start_hook;\n\tchar *vassals_stop_hook;\n\n\tstruct uwsgi_string_list *additional_headers;\n\tstruct uwsgi_string_list *remove_headers;\n\tstruct uwsgi_string_list *collect_headers;\n\n\t// set cpu affinity\n\tint cpu_affinity;\n\n\tint reload_mercy;\n\tint worker_reload_mercy;\n\t// map reloads to death\n\tint exit_on_reload;\n\n\t// store options\n\tint dirty_config;\n\tint option_index;\n\tint (*logic_opt) (char *, char *);\n\tchar *logic_opt_arg;\n\tchar *logic_opt_data;\n\tint logic_opt_running;\n\tint logic_opt_cycles;\n\tstruct uwsgi_option *options;\n\tstruct option *long_options;\n\tchar *short_options;\n\tstruct uwsgi_opt **exported_opts;\n\tint exported_opts_cnt;\n\tstruct uwsgi_custom_option *custom_options;\n\n\t// dump the whole set of options\n\tint dump_options;\n\t// show ini representation of the current config\n\tint show_config;\n\t// enable strict mode (only registered options can be used)\n\tint strict;\n\n\t// list loaded features\n\tint cheaper_algo_list;\n#ifdef UWSGI_ROUTING\n\tint router_list;\n#endif\n\tint imperial_monitor_list;\n\tint plugins_list;\n\tint loggers_list;\n\tint loop_list;\n\tint clock_list;\n\tint alarms_list;\n\n\tstruct wsgi_request *wsgi_req;\n\n\tchar *remap_modifier;\n\n\t// enable zerg mode\n\tint *zerg;\n\tchar *zerg_server;\n\tstruct uwsgi_string_list *zerg_node;\n\tint zerg_fallback;\n\tint zerg_server_fd;\n\n\t// security\n\tchar *chroot;\n\tgid_t gid;\n\tuid_t uid;\n\tchar *uidname;\n\tchar *gidname;\n\tint no_initgroups;\n\tstruct uwsgi_string_list *additional_gids;\n\n#ifdef UWSGI_CAP\n\tcap_value_t *cap;\n\tint cap_count;\n\tcap_value_t *emperor_cap;\n\tint emperor_cap_count;\n#endif\n\n#ifdef __linux__\n\tint unshare;\n\tint unshare2;\n\tint emperor_clone;\n\tchar *pivot_root;\n\tchar *setns_socket;\n\tstruct uwsgi_string_list *setns_socket_skip;\n\tchar *setns;\n\tint setns_socket_fd;\n\tint setns_preopen;\n\tint setns_fds[64];\n\tint setns_fds_count;\n#endif\n\tchar *emperor_wrapper;\n\n\tint jailed;\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tchar *jail;\n\tstruct uwsgi_string_list *jail_ip4;\n#ifdef AF_INET6\n\tstruct uwsgi_string_list *jail_ip6;\n#endif\n\tstruct uwsgi_string_list *jail2;\n\tchar *jidfile;\n\tchar *jail_attach;\n#endif\n\tint refork;\n\tint refork_as_root;\n\tint refork_post_jail;\n\n\tint ignore_sigpipe;\n\tint ignore_write_errors;\n\tuint64_t write_errors_tolerance;\n\tint write_errors_exception_only;\n\tint disable_write_exception;\n\n\t// still working on it\n\tchar *profiler;\n\n\t// the weight of the instance, used by various cluster/lb components\n\tuint64_t weight;\n\tint auto_weight;\n\n\t// mostly useless\n\tchar *mode;\n\n\t// binary patch the worker image\n\tchar *worker_exec;\n\tchar *worker_exec2;\n\n\t// this must be UN-shared\n\tstruct uwsgi_gateway_socket *gateway_sockets;\n\n\n\tint ignore_script_name;\n\tint manage_script_name;\n\tint reload_on_exception;\n\tint catch_exceptions;\n\tstruct uwsgi_string_list *reload_on_exception_type;\n\tstruct uwsgi_string_list *reload_on_exception_value;\n\tstruct uwsgi_string_list *reload_on_exception_repr;\n\n\tstruct uwsgi_exception_handler *exception_handlers;\n\tstruct uwsgi_string_list *exception_handlers_instance;\n\tstruct uwsgi_thread *exception_handler_thread;\n\tuint64_t exception_handler_msg_size;\n\n\n\tint no_default_app;\n\t// exit if no-app is loaded\n\tint need_app;\n\n\tint forkbomb_delay;\n\n\tint logdate;\n\tint log_micros;\n\tchar *log_strftime;\n\n\tint honour_stdin;\n\tstruct termios termios;\n\tint restore_tc;\n\n\t// honour the HTTP Range header\n\tint honour_range;\n\n\t// route all of the logs to the master process\n\tint req_log_master;\n\tint log_master;\n\tchar *log_master_buf;\n\tsize_t log_master_bufsize;\n\tint log_master_stream;\n\tint log_master_req_stream;\n\n\tint log_reopen;\n\tint log_truncate;\n\tuint64_t log_maxsize;\n\tchar *log_backupname;\n\n\tint original_log_fd;\n\tint req_log_fd;\n\n\t// static file serving\n\tint file_serve_mode;\n\tint build_mime_dict;\n\n\tstruct uwsgi_string_list *mime_file;\n\n\tstruct uwsgi_hook *hooks;\n\n\tstruct uwsgi_string_list *hook_touch;\n\n\tstruct uwsgi_string_list *hook_asap;\n\tstruct uwsgi_string_list *hook_pre_jail;\n        struct uwsgi_string_list *hook_post_jail;\n        struct uwsgi_string_list *hook_in_jail;\n        struct uwsgi_string_list *hook_as_root;\n        struct uwsgi_string_list *hook_as_user;\n        struct uwsgi_string_list *hook_as_user_atexit;\n        struct uwsgi_string_list *hook_pre_app;\n        struct uwsgi_string_list *hook_post_app;\n        struct uwsgi_string_list *hook_accepting;\n        struct uwsgi_string_list *hook_accepting1;\n        struct uwsgi_string_list *hook_accepting_once;\n        struct uwsgi_string_list *hook_accepting1_once;\n\n\tstruct uwsgi_string_list *hook_emperor_start;\n\tstruct uwsgi_string_list *hook_master_start;\n\n\tstruct uwsgi_string_list *hook_emperor_stop;\n\tstruct uwsgi_string_list *hook_emperor_reload;\n\tstruct uwsgi_string_list *hook_emperor_lost;\n\n        struct uwsgi_string_list *hook_as_vassal;\n        struct uwsgi_string_list *hook_as_emperor;\n        struct uwsgi_string_list *hook_as_mule;\n        struct uwsgi_string_list *hook_as_gateway;\n\t\n\n\tstruct uwsgi_string_list *exec_asap;\n\tstruct uwsgi_string_list *exec_pre_jail;\n\tstruct uwsgi_string_list *exec_post_jail;\n\tstruct uwsgi_string_list *exec_in_jail;\n\tstruct uwsgi_string_list *exec_as_root;\n\tstruct uwsgi_string_list *exec_as_user;\n\tstruct uwsgi_string_list *exec_as_user_atexit;\n\tstruct uwsgi_string_list *exec_pre_app;\n\tstruct uwsgi_string_list *exec_post_app;\n\n        struct uwsgi_string_list *exec_as_vassal;\n        struct uwsgi_string_list *exec_as_emperor;\n\n\tstruct uwsgi_string_list *call_asap;\n\tstruct uwsgi_string_list *call_pre_jail;\n        struct uwsgi_string_list *call_post_jail;\n        struct uwsgi_string_list *call_in_jail;\n        struct uwsgi_string_list *call_as_root;\n        struct uwsgi_string_list *call_as_user;\n        struct uwsgi_string_list *call_as_user_atexit;\n        struct uwsgi_string_list *call_pre_app;\n        struct uwsgi_string_list *call_post_app;\n\n        struct uwsgi_string_list *call_as_vassal;\n        struct uwsgi_string_list *call_as_vassal1;\n        struct uwsgi_string_list *call_as_vassal3;\n\n        struct uwsgi_string_list *call_as_emperor;\n        struct uwsgi_string_list *call_as_emperor1;\n        struct uwsgi_string_list *call_as_emperor2;\n        struct uwsgi_string_list *call_as_emperor4;\n\n\tstruct uwsgi_string_list *mount_asap;\n\tstruct uwsgi_string_list *mount_pre_jail;\n        struct uwsgi_string_list *mount_post_jail;\n        struct uwsgi_string_list *mount_in_jail;\n        struct uwsgi_string_list *mount_as_root;\n\n        struct uwsgi_string_list *mount_as_vassal;\n        struct uwsgi_string_list *mount_as_emperor;\n\n\tstruct uwsgi_string_list *umount_asap;\n\tstruct uwsgi_string_list *umount_pre_jail;\n        struct uwsgi_string_list *umount_post_jail;\n        struct uwsgi_string_list *umount_in_jail;\n        struct uwsgi_string_list *umount_as_root;\n\n        struct uwsgi_string_list *umount_as_vassal;\n        struct uwsgi_string_list *umount_as_emperor;\n\n        struct uwsgi_string_list *after_request_hooks;\n\n\tstruct uwsgi_string_list *wait_for_interface;\n\tint wait_for_interface_timeout;\n\n\tchar *privileged_binary_patch;\n\tchar *unprivileged_binary_patch;\n\tchar *privileged_binary_patch_arg;\n\tchar *unprivileged_binary_patch_arg;\n\n\tstruct uwsgi_logger *loggers;\n\tstruct uwsgi_logger *choosen_logger;\n\tstruct uwsgi_logger *choosen_req_logger;\n\tstruct uwsgi_string_list *requested_logger;\n\tstruct uwsgi_string_list *requested_req_logger;\n\n\tstruct uwsgi_log_encoder *log_encoders;\n\tstruct uwsgi_string_list *requested_log_encoders;\n\tstruct uwsgi_string_list *requested_log_req_encoders;\n\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\n\tint pcre_jit;\n\tstruct uwsgi_regexp_list *log_drain_rules;\n\tstruct uwsgi_regexp_list *log_filter_rules;\n\tstruct uwsgi_regexp_list *log_route;\n\tstruct uwsgi_regexp_list *log_req_route;\n#endif\n\n\tint use_abort;\n\n\tint alarm_freq;\n\tuint64_t alarm_msg_size;\n\tstruct uwsgi_string_list *alarm_list;\n\tstruct uwsgi_string_list *alarm_logs_list;\n\tstruct uwsgi_alarm_fd *alarm_fds;\n\tstruct uwsgi_string_list *alarm_fd_list;\n\tstruct uwsgi_string_list *alarm_segfault;\n\tstruct uwsgi_string_list *alarm_backlog;\n\tstruct uwsgi_alarm *alarms;\n\tstruct uwsgi_alarm_instance *alarm_instances;\n\tstruct uwsgi_alarm_log *alarm_logs;\n\tstruct uwsgi_thread *alarm_thread;\n\n\tint threaded_logger;\n\tpthread_mutex_t threaded_logger_lock;\n\n\tint *safe_fds;\n\tint safe_fds_cnt;\n\n\tint daemons_honour_stdin;\n\tstruct uwsgi_daemon *daemons;\n\tint daemons_cnt;\n\n#ifdef UWSGI_SSL\n\tchar *subscriptions_sign_check_dir;\n\tint subscriptions_sign_check_tolerance;\n\tconst EVP_MD *subscriptions_sign_check_md;\n\tstruct uwsgi_string_list *subscriptions_sign_skip_uid;\n#endif\n\n\tstruct uwsgi_string_list *subscriptions_credentials_check_dir;\n\tint subscriptions_use_credentials;\n\n\tstruct uwsgi_dyn_dict *static_maps;\n\tstruct uwsgi_dyn_dict *static_maps2;\n\tstruct uwsgi_dyn_dict *check_static;\n\tstruct uwsgi_dyn_dict *mimetypes;\n\tstruct uwsgi_string_list *static_skip_ext;\n\tstruct uwsgi_string_list *static_index;\n\tstruct uwsgi_string_list *static_safe;\n\n\tstruct uwsgi_hash_algo *hash_algos;\n\tint use_static_cache_paths;\n\tchar *static_cache_paths_name;\n\tstruct uwsgi_cache *static_cache_paths;\n\tint cache_expire_freq;\n\tint cache_report_freed_items;\n\tint cache_no_expire;\n\tuint64_t cache_max_items;\n\tuint64_t cache_blocksize;\n\tchar *cache_store;\n\tint cache_store_sync;\n\tstruct uwsgi_string_list *cache2;\n\tint cache_setup;\n\tint locking_setup;\n\tint cache_use_last_modified;\n\n\tstruct uwsgi_dyn_dict *static_expires_type;\n\tstruct uwsgi_dyn_dict *static_expires_type_mtime;\n\n\tstruct uwsgi_dyn_dict *static_expires;\n\tstruct uwsgi_dyn_dict *static_expires_mtime;\n\n\tstruct uwsgi_dyn_dict *static_expires_uri;\n\tstruct uwsgi_dyn_dict *static_expires_uri_mtime;\n\n\tstruct uwsgi_dyn_dict *static_expires_path_info;\n\tstruct uwsgi_dyn_dict *static_expires_path_info_mtime;\n\n\tint static_gzip_all;\n\tstruct uwsgi_string_list *static_gzip_dir;\n\tstruct uwsgi_string_list *static_gzip_ext;\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\n\tstruct uwsgi_regexp_list *static_gzip;\n#endif\n\n\tstruct uwsgi_offload_engine *offload_engines;\n\tstruct uwsgi_offload_engine *offload_engine_sendfile;\n\tstruct uwsgi_offload_engine *offload_engine_transfer;\n\tstruct uwsgi_offload_engine *offload_engine_memory;\n\tstruct uwsgi_offload_engine *offload_engine_pipe;\n\tint offload_threads;\n\tint offload_threads_events;\n\tstruct uwsgi_thread **offload_thread;\n\n\tint check_static_docroot;\n\tint disable_sendfile;\n\n\tchar *daemonize;\n\tchar *daemonize2;\n\tint do_not_change_umask;\n\tchar *logfile;\n\tint logfile_chown;\n\n\t// enable vhost mode\n\tint vhost;\n\tint vhost_host;\n\n\t// async commodity\n\tstruct wsgi_request **async_waiting_fd_table;\n\tstruct wsgi_request **async_proto_fd_table;\n\tstruct uwsgi_async_request *async_runqueue;\n\tstruct uwsgi_async_request *async_runqueue_last;\n\n\tstruct uwsgi_rbtree *rb_async_timeouts;\n\n\tint async_queue_unused_ptr;\n\tstruct wsgi_request **async_queue_unused;\n\n\n\t// store rlimit\n\tstruct rlimit rl;\n\tstruct rlimit rl_nproc;\n\tsize_t limit_post;\n\n\t// set process priority\n\tint prio;\n\n\t// funny reload systems\n\tint force_get_memusage;\n\trlim_t reload_on_as;\n\trlim_t reload_on_rss;\n\trlim_t evil_reload_on_as;\n\trlim_t evil_reload_on_rss;\n\n\tstruct uwsgi_string_list *reload_on_fd;\n\tstruct uwsgi_string_list *brutal_reload_on_fd;\n\n\tstruct uwsgi_string_list *touch_reload;\n\tstruct uwsgi_string_list *touch_chain_reload;\n\tstruct uwsgi_string_list *touch_workers_reload;\n\tstruct uwsgi_string_list *touch_gracefully_stop;\n\tstruct uwsgi_string_list *touch_logrotate;\n\tstruct uwsgi_string_list *touch_logreopen;\n\tstruct uwsgi_string_list *touch_exec;\n\tstruct uwsgi_string_list *touch_signal;\n\n\tstruct uwsgi_string_list *fs_reload;\n\tstruct uwsgi_string_list *fs_brutal_reload;\n\tstruct uwsgi_string_list *fs_signal;\n\n\tstruct uwsgi_fsmon *fsmon;\n\n\tstruct uwsgi_string_list *signal_timers;\n\tstruct uwsgi_string_list *rb_signal_timers;\n\n\tstruct uwsgi_string_list *mountpoints_check;\n\n\tint propagate_touch;\n\n\t// enable grunt mode\n\tint grunt;\n\n\t// store the binary path\n\tchar *binary_path;\n\n\tint is_a_reload;\n\n\n\tchar *udp_socket;\n\n\tint multicast_ttl;\n\tint multicast_loop;\n\tchar *multicast_group;\n\n\tstruct uwsgi_spooler *spoolers;\n\tint spooler_numproc;\n\tstruct uwsgi_spooler *i_am_a_spooler;\n\tchar *spooler_chdir;\n\tint spooler_max_tasks;\n\tint spooler_ordered;\n\tint spooler_quiet;\n\tint spooler_frequency;\n\n\n\tint snmp;\n\tchar *snmp_addr;\n\tchar *snmp_community;\n\tstruct uwsgi_lock_item *snmp_lock;\n\tint snmp_fd;\n\n\tint udp_fd;\n\n\t// removed in 2.1, here for ABI compatibility\n\tuint16_t __buffer_size;\n\tint signal_bufsize;\n\n\t// post buffering\n\tsize_t post_buffering;\n\tint post_buffering_harakiri;\n\tsize_t post_buffering_bufsize;\n\tsize_t body_read_warning;\n\n\tint master_process;\n\tint master_queue;\n\tint master_interval;\n\n\t// mainly useful for broodlord mode\n\tint vassal_sos_backlog;\n\n\tint no_defer_accept;\n\tint so_keepalive;\n\tint so_send_timeout;\n\tuint64_t so_sndbuf;\n\tuint64_t so_rcvbuf;\n\n\tint page_size;\n\tint cpus;\n\n\tchar *pidfile;\n\tchar *pidfile2;\n\n\tchar *flock2;\n\tchar *flock_wait2;\n\n\tint backtrace_depth;\n\n\tint harakiri_verbose;\n\tint harakiri_graceful_timeout;\n\tint harakiri_graceful_signal;\n\tint harakiri_queue_threshold;\n\tint harakiri_no_arh;\n\n\tint magic_table_first_round;\n\tchar *magic_table[256];\n\n\tint numproc;\n\tint async;\n\tint async_running;\n\tint async_queue;\n\tint async_nevents;\n\n\ttime_t async_queue_is_full;\n\n\tint max_vars;\n\tint vec_size;\n\n\t// shared area\n\tstruct uwsgi_string_list *sharedareas_list;\n\tint sharedareas_cnt;\n\tstruct uwsgi_sharedarea **sharedareas;\n\n\t// avoid thundering herd in threaded modes\n\tpthread_mutex_t thunder_mutex;\n\tpthread_mutex_t lock_static;\n\n\tint use_thunder_lock;\n\tint use_thunder_lock_watchdog;\n\tstruct uwsgi_lock_item *the_thunder_lock;\n\n\t/* the list of workers */\n\tstruct uwsgi_worker *workers;\n\tint max_apps;\n\n\t/* the list of mules */\n\tstruct uwsgi_string_list *mules_patches;\n\tstruct uwsgi_mule *mules;\n\tstruct uwsgi_string_list *farms_list;\n\tstruct uwsgi_farm *farms;\n\tint mule_msg_size;\n\n\tpid_t mypid;\n\tint mywid;\n\n\tint muleid;\n\tint mules_cnt;\n\tint farms_cnt;\n\n\trlim_t requested_max_fd;\n\trlim_t max_fd;\n\n\tstruct timeval start_tv;\n\n\tint abstract_socket;\n#ifdef __linux__\n\tint freebind;\n#endif\n\n\tint chmod_socket;\n\tchar *chown_socket;\n\tmode_t chmod_socket_value;\n\tmode_t chmod_logfile_value;\n\tint listen_queue;\n\n\tchar *fallback_config;\n\n#ifdef UWSGI_ROUTING\n\tstruct uwsgi_router *routers;\n\tstruct uwsgi_route *routes;\n\tstruct uwsgi_route *final_routes;\n\tstruct uwsgi_route *error_routes;\n\tstruct uwsgi_route *response_routes;\n\tstruct uwsgi_route_condition *route_conditions;\n\tstruct uwsgi_route_var *route_vars;\n#endif\n\n\tstruct uwsgi_string_list *error_page_403;\n\tstruct uwsgi_string_list *error_page_404;\n\tstruct uwsgi_string_list *error_page_500;\n\n\tint single_interpreter;\n\n\tstruct uwsgi_shared *shared;\n\n\n\tint no_orphans;\n\tint skip_zero;\n\tint skip_atexit;\n\n\tchar *force_cwd;\n\tchar *chdir;\n\tchar *chdir2;\n\tstruct uwsgi_string_list *binsh;\n\n\tint vacuum;\n\tint no_server;\n\tint command_mode;\n\n\tint xml_round2;\n\n\tchar *cwd;\n\n\t// conditional logging\n\tint log_slow_requests;\n\tint log_zero_headers;\n\tint log_empty_body;\n\tint log_high_memory;\n\n#ifdef __linux__\n\tstruct uwsgi_string_list *cgroup;\n\tstruct uwsgi_string_list *cgroup_opt;\n\tchar *cgroup_dir_mode;\n\tchar *ns;\n\tchar *ns_net;\n\tstruct uwsgi_string_list *ns_keep_mount;\n#endif\n\tstruct uwsgi_string_list *file_write_list;\n\n\tchar *protocol;\n\n\tint signal_socket;\n\tint my_signal_socket;\n\n\tstruct uwsgi_protocol *protocols;\n\tstruct uwsgi_socket *sockets;\n\tstruct uwsgi_socket *shared_sockets;\n\tint is_et;\n\n\tstruct uwsgi_string_list *map_socket;\n\n\tstruct uwsgi_cron *crons;\n\ttime_t cron_harakiri;\n\n\ttime_t respawn_delta;\n\n\tstruct uwsgi_string_list *mounts;\n\n\tint cores;\n\n\tint threads;\n\tpthread_attr_t threads_attr;\n\tsize_t threads_stacksize;\n\n\t//this key old the u_request structure per core / thread\n\tpthread_key_t tur_key;\n\n\n\tstruct wsgi_request *(*current_wsgi_req) (void);\n\n\tvoid (*notify) (char *);\n\tvoid (*notify_ready) (void);\n\tint notification_fd;\n\tvoid *notification_object;\n\n\t// usedby suspend/resume loops\n\tvoid (*schedule_to_main) (struct wsgi_request *);\n\tvoid (*schedule_to_req) (void);\n\tvoid (*schedule_fix) (struct wsgi_request *);\n\n\tvoid (*gbcw_hook) (const char *);\n\n\tint close_on_exec;\n\tint close_on_exec2;\n\n\tint tcp_nodelay;\n\n\tchar *loop;\n\tstruct uwsgi_loop *loops;\n\n\tstruct uwsgi_plugin *p[256];\n\tstruct uwsgi_plugin *gp[MAX_GENERIC_PLUGINS];\n\tint gp_cnt;\n\n\tchar *allowed_modifiers;\n\n\tchar *upload_progress;\n\n\tstruct uwsgi_lock_item *registered_locks;\n\tstruct uwsgi_lock_ops lock_ops;\n\tchar *lock_engine;\n\tchar *ftok;\n\tchar *lock_id;\n\tsize_t lock_size;\n\tsize_t rwlock_size;\n\n\tstruct uwsgi_string_list *add_cache_item;\n\tstruct uwsgi_string_list *load_file_in_cache;\n#ifdef UWSGI_ZLIB\n\tstruct uwsgi_string_list *load_file_in_cache_gzip;\n#endif\n\tchar *use_check_cache;\n\tstruct uwsgi_cache *check_cache;\n\tstruct uwsgi_cache *caches;\n\n\tstruct uwsgi_string_list *cache_udp_server;\n\tstruct uwsgi_string_list *cache_udp_node;\n\n\tchar *cache_sync;\n\n\t// the stats server\n\tchar *stats;\n\tint stats_fd;\n\tint stats_http;\n\tint stats_minified;\n\tstruct uwsgi_string_list *requested_stats_pushers;\n\tstruct uwsgi_stats_pusher *stats_pushers;\n\tstruct uwsgi_stats_pusher_instance *stats_pusher_instances;\n\tint stats_pusher_default_freq;\n\n\tuint64_t queue_size;\n\tuint64_t queue_blocksize;\n\tvoid *queue;\n\tstruct uwsgi_queue_header *queue_header;\n\tchar *queue_store;\n\tsize_t queue_filesize;\n\tint queue_store_sync;\n\n\n\tint locks;\n\tint persistent_ipcsem;\n\n\tstruct uwsgi_lock_item *queue_lock;\n\tstruct uwsgi_lock_item **user_lock;\n\tstruct uwsgi_lock_item *signal_table_lock;\n\tstruct uwsgi_lock_item *fmon_table_lock;\n\tstruct uwsgi_lock_item *timer_table_lock;\n\tstruct uwsgi_lock_item *rb_timer_table_lock;\n\tstruct uwsgi_lock_item *cron_table_lock;\n\tstruct uwsgi_lock_item *rpc_table_lock;\n\tstruct uwsgi_lock_item *sa_lock;\n\tstruct uwsgi_lock_item *metrics_lock;\n\n\t// rpc\n\tuint64_t rpc_max;\n\tstruct uwsgi_rpc *rpc_table;\t\n\n\t// subscription client\n\tint subscriptions_blocked;\n\tint subscribe_freq;\n\tint subscription_tolerance;\n\tint unsubscribe_on_graceful_reload;\n\tstruct uwsgi_string_list *subscriptions;\n\tstruct uwsgi_string_list *subscriptions2;\n\n\tstruct uwsgi_subscribe_node *(*subscription_algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);\n\tint subscription_dotsplit;\n\n\tint never_swap;\n\n#ifdef UWSGI_SSL\n\tint ssl_initialized;\n\tint ssl_verbose;\n\tchar *ssl_sessions_use_cache;\n\tint ssl_sessions_timeout;\n\tstruct uwsgi_cache *ssl_sessions_cache;\n\tchar *ssl_tmp_dir;\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\n\tstruct uwsgi_regexp_list *sni_regexp;\n#endif\n\tstruct uwsgi_string_list *sni;\n\tchar *sni_dir;\n\tchar *sni_dir_ciphers;\n#endif\n\n#ifdef UWSGI_SSL\n\tstruct uwsgi_legion *legions;\n\tstruct uwsgi_legion_action *legion_actions;\n\tint legion_queue;\n\tint legion_freq;\n\tint legion_tolerance;\n\tint legion_skew_tolerance;\n\tuint16_t legion_scroll_max_size;\n\tuint64_t legion_scroll_list_max_size;\n\tint legion_death_on_lord_error;\n#endif\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\tint linux_ksm;\n\tint ksm_buffer_size;\n\tchar *ksm_mappings_last;\n\tchar *ksm_mappings_current;\n\tsize_t ksm_mappings_last_size;\n\tsize_t ksm_mappings_current_size;\n#endif\n#endif\n\n\tstruct uwsgi_buffer *websockets_ping;\n\tstruct uwsgi_buffer *websockets_pong;\n\tstruct uwsgi_buffer *websockets_close;\n\tint websockets_ping_freq;\n\tint websockets_pong_tolerance;\n\tuint64_t websockets_max_size;\n\n\tint chunked_input_timeout;\n\tuint64_t chunked_input_limit;\n\n\tstruct uwsgi_metric *metrics;\n\tstruct uwsgi_metric_collector *metric_collectors;\n\tint has_metrics;\n\tchar *metrics_dir;\n\tint metrics_dir_restore;\n\tuint64_t metrics_cnt;\n\tstruct uwsgi_string_list *additional_metrics;\n\tstruct uwsgi_string_list *metrics_threshold;\n\n\tint (*wait_write_hook) (int, int);\n\tint (*wait_read_hook) (int, int);\n\tint (*wait_milliseconds_hook) (int);\n\tint (*wait_read2_hook) (int, int, int, int *);\n\n\tstruct uwsgi_string_list *schemes;\n\n\t// inject text files (useful for advanced templating)\n        struct uwsgi_string_list *inject_before;\n        struct uwsgi_string_list *inject_after;\n\n\t// this is a unix socket receiving external notifications (like subscription replies)\n\tchar *notify_socket;\n\tint notify_socket_fd;\n\tchar *subscription_notify_socket;\n\n\t//uWSGI 2.0.5\n\n\tint mule_reload_mercy;\n\tint alarm_cheap;\n\tint emperor_no_blacklist;\n\tint metrics_no_cores;\n\tint stats_no_cores;\n\tint stats_no_metrics;\n\n\t// uWSGI 2.0.7\n\tint vassal_sos;\n\n\t// uWSGI 2.0.8\n\tstruct uwsgi_string_list *wait_for_fs;\n\tstruct uwsgi_string_list *wait_for_dir;\n\tstruct uwsgi_string_list *wait_for_file;\n\tint wait_for_fs_timeout;\n\tstruct uwsgi_string_list *wait_for_mountpoint;\n#ifdef UWSGI_SSL\n\tint sslv3;\n\tstruct uwsgi_string_list *ssl_options;\n#endif\n\tstruct uwsgi_string_list *hook_post_fork;\n\n\t// uWSGI 2.0.9\n\tchar *subscribe_with_modifier1;\n\tstruct uwsgi_string_list *pull_headers;\n\n\t// uWSGI 2.0.10\n\tstruct uwsgi_string_list *emperor_wrapper_override;\n\tstruct uwsgi_string_list *emperor_wrapper_fallback;\n\n\t// uWSGI 2.0.11\n\tstruct uwsgi_string_list *wait_for_socket;\n\tint wait_for_socket_timeout;\n\tint mem_collector_freq;\n\n\t// uWSGI 2.0.14\n\tstruct uwsgi_string_list *touch_mules_reload;\n\tstruct uwsgi_string_list *touch_spoolers_reload;\n\tint spooler_reload_mercy;\n\tint skip_atexit_teardown;\n\n\t// uWSGI 2.0.15\n\tint new_argc;\n\tchar **new_argv;\n\t// signal for else\n\tint logic_opt_if_failed;\n\n#ifdef UWSGI_SSL\n\tint ssl_verify_depth;\n#endif\n\n#ifdef UWSGI_SSL\n\tint tlsv1;\n#endif\n\n\t// uWSGI 2.0.19\n\tint emperor_graceful_shutdown;\n\tint is_chrooted;\n\n\tsize_t response_header_limit;\n\t\n\t// uWSGI 2.1\n\tchar *fork_socket;\n\tchar *emperor_use_fork_server;\n\tstruct uwsgi_string_list *vassal_fork_base;\n\tstruct uwsgi_string_list *emperor_collect_attributes;\n\tchar *emperor_fork_server_attr;\n\tchar *emperor_wrapper_attr;\n\tint emperor_subreaper;\n        struct uwsgi_string_list *hook_as_on_demand_vassal;\n\tuint64_t max_requests_delta;\n\tchar *emperor_chdir_attr;\n\tstruct uwsgi_string_list *subscription_algos;\n\tint subscription_mountpoints;\n\tstruct uwsgi_string_list *hook_as_emperor_before_vassal;\n\tstruct uwsgi_string_list *hook_as_vassal_before_drop;\n\tstruct uwsgi_string_list *hook_as_emperor_setns;\n\tint emperor_force_config_pipe;\n\tstruct uwsgi_string_list *hook_as_on_config_vassal;\n\tint async_warn_if_queue_full;\n\tchar *zeus;\n\tuint64_t buffer_size;\n\tint emperor_tyrant_initgroups;\n\tchar *safe_pidfile;\n\tchar *safe_pidfile2;\n\n\tint die_on_no_workers;\n\tint spooler_cheap;\n\tint cheaper_idle;\n\n\tchar *emperor_trigger_socket;\n\tint emperor_trigger_socket_fd;\n\n\tint spooler_signal_as_task;\n\n\tint log_worker;\n\n\t// number of args to consider part of binary_path\n\tint binary_argc;\n\n\tchar *emperor_command_socket;\n\tint emperor_command_socket_fd;\n\tint emperor_wait_for_command;\n\tstruct uwsgi_string_list *emperor_wait_for_command_ignore;\n\tint subscription_vassal_required;\n\tint subscription_clear_on_shutdown;\n\n\tint subscription_tolerance_inactive;\n\n#ifdef __linux__\n\trlim_t reload_on_uss;\n\trlim_t reload_on_pss;\n#endif\n\n\tint mule_msg_recv_size;\n\tchar *mule_msg_recv_buf;\n\n\tint http_path_info_no_decode_slashes;\n\n\tsize_t argv_len;\n\tsize_t environ_len;\n\n\tint dynamic_apps;\n\n\tstruct uwsgi_buffer *websockets_continuation_buffer;\n\n\tuint64_t max_worker_lifetime_delta;\n\t// This pipe is used to stop event_queue_wait() in threaded workers.\n\tint loop_stop_pipe[2];\n};\n\nstruct uwsgi_rpc {\n\tchar name[UMAX8];\n\tvoid *func;\n\tuint8_t args;\n\tuint8_t shared;\n\tstruct uwsgi_plugin *plugin;\n};\n\nstruct uwsgi_signal_entry {\n\tint wid;\n\tuint8_t modifier1;\n\tchar receiver[64];\n\tvoid *handler;\n};\n\n/*\nthey are here for backwards compatibility\n*/\n#define SNMP_COUNTER32 0x41\n#define SNMP_GAUGE 0x42\n#define SNMP_COUNTER64 0x46\n\nstruct uwsgi_snmp_custom_value {\n\tuint8_t type;\n\tuint64_t val;\n};\n\nint uwsgi_setup_snmp(void);\n\nstruct uwsgi_snmp_server_value {\n\tuint8_t type;\n\tuint64_t *val;\n};\n\nstruct uwsgi_cron {\n\n\tint minute;\n\tint hour;\n\tint day;\n\tint month;\n\tint week;\n\n\ttime_t last_job;\n\tuint8_t sig;\n\n\tchar *command;\n\tvoid (*func)(struct uwsgi_cron *, time_t);\n\n\ttime_t started_at;\n\n\t// next harakiri timestamp\n\ttime_t harakiri;\n\t// number of seconds to wait before calling harakiri on cron\n\tint mercy;\n\n\tuint8_t unique;\n\tpid_t pid;\n\n\tstruct uwsgi_cron *next;\n\n#ifdef UWSGI_SSL\n\tchar *legion;\n#endif\n};\n\nstruct uwsgi_shared {\n\n\t//vga 80 x25 specific !\n\tchar warning_message[81];\n\n\toff_t logsize;\n\n\tchar snmp_community[72 + 1];\n\tstruct uwsgi_snmp_server_value snmp_gvalue[100];\n\tstruct uwsgi_snmp_custom_value snmp_value[100];\n\n\tint worker_signal_pipe[2];\n\tint spooler_frequency;\n\tint spooler_signal_pipe[2];\n\tint mule_signal_pipe[2];\n\tint mule_queue_pipe[2];\n\n\t// 256 items * (uwsgi.numproc + 1)\n\tstruct uwsgi_signal_entry *signal_table;\n\n\tstruct uwsgi_fmon files_monitored[64];\n\tint files_monitored_cnt;\n\n\tstruct uwsgi_timer timers[MAX_TIMERS];\n\tint timers_cnt;\n\n\tstruct uwsgi_signal_rb_timer rb_timers[MAX_TIMERS];\n\tint rb_timers_cnt;\n\n\tuint64_t *rpc_count;\n\n\tint worker_log_pipe[2];\n\t// used for request logging\n\tint worker_req_log_pipe[2];\n\n\tuint64_t load;\n\tuint64_t max_load;\n\tstruct uwsgi_cron cron[MAX_CRONS];\n\tint cron_cnt;\n\n\tuint64_t backlog;\n\tuint64_t backlog_errors;\n\n\t// gateways\n\tstruct uwsgi_gateway gateways[MAX_GATEWAYS];\n\tint gateways_cnt;\n\ttime_t gateways_harakiri[MAX_GATEWAYS];\n\n\tuint64_t routed_signals;\n\tuint64_t unrouted_signals;\n\n\tuint64_t busy_workers;\n\tuint64_t idle_workers;\n\tuint64_t overloaded;\n\n\tint ready;\n};\n\nstruct uwsgi_core {\n\n\n\tuint64_t requests;\n\tuint64_t failed_requests;\n\tuint64_t static_requests;\n\tuint64_t routed_requests;\n\tuint64_t offloaded_requests;\n\n\tuint64_t write_errors;\n\tuint64_t read_errors;\n\tuint64_t exceptions;\n\n\tpthread_t thread_id;\n\n\tint offload_rr;\n\n\t// one ts-perapp\n\tvoid **ts;\n\n\tint in_request;\n\n\tchar *buffer;\n\tstruct iovec *hvec;\n\tchar *post_buf;\n\n\tstruct wsgi_request req;\n\n\t// uWSGI 2.1\n\ttime_t harakiri;\n\ttime_t user_harakiri;\n};\n\nstruct uwsgi_worker {\n\tint id;\n\tpid_t pid;\n\n\tuint64_t status;\n\n\ttime_t last_spawn;\n\tuint64_t respawn_count;\n\n\tuint64_t requests;\n\tuint64_t delta_requests;\n\tuint64_t failed_requests;\n\n\t// renamed in 2.1 (was 'harakiri')\n\ttime_t harakiri_unused;\n\t// renamed in 2.1 (was 'user_harakiri')\n\ttime_t user_harakiri_unused;\n\tuint64_t harakiri_count;\n\tint pending_harakiri;\n\n\tuint64_t vsz_size;\n\tuint64_t rss_size;\n\n\tuint64_t running_time;\n\n\tint manage_next_request;\n\n\tint destroy;\n\n\tint apps_cnt;\n\tstruct uwsgi_app *apps;\n\n\tuint64_t tx;\n\n\tint hijacked;\n\tuint64_t hijacked_count;\n\tint cheaped;\n\tint suspended;\n\tint sig;\n\tuint8_t signum;\n\n\ttime_t cursed_at;\n\ttime_t no_mercy_at;\n\n\t// signals managed by this worker\n\tuint64_t signals;\n\n\tint signal_pipe[2];\n\n\tuint64_t avg_response_time;\n\n\tstruct uwsgi_core *cores;\n\n\tint accepting;\n\n\tchar name[0xff];\n\n\tint shutdown_sockets;\n\n\tuint64_t uss_size;\n\tuint64_t pss_size;\n};\n\n\nstruct uwsgi_mule {\n\tint id;\n\tpid_t pid;\n\n\tint signal_pipe[2];\n\tint queue_pipe[2];\n\n\ttime_t last_spawn;\n\tuint64_t respawn_count;\n\n\tchar *patch;\n\n\t// signals managed by this mule\n\tuint64_t signals;\n\tint sig;\n\tuint8_t signum;\n\n\ttime_t harakiri;\n\ttime_t user_harakiri;\n\n\tchar name[0xff];\n\n\ttime_t cursed_at;\n\ttime_t no_mercy_at;\n};\n\nstruct uwsgi_mule_farm {\n\tstruct uwsgi_mule *mule;\n\tstruct uwsgi_mule_farm *next;\n};\n\nstruct uwsgi_farm {\n\tint id;\n\tchar name[0xff];\n\n\tint signal_pipe[2];\n\tint queue_pipe[2];\n\n\tstruct uwsgi_mule_farm *mules;\n\n};\n\n\n\nchar *uwsgi_get_cwd(void);\n\nvoid warn_pipe(void);\nvoid what_i_am_doing(void);\nvoid goodbye_cruel_world(const char *, ...);\nvoid gracefully_kill(int);\nvoid reap_them_all(int);\nvoid kill_them_all(int);\nvoid grace_them_all(int);\nvoid end_me(int);\nint bind_to_unix(char *, int, int, int);\nint bind_to_tcp(char *, int, char *);\nint bind_to_udp(char *, int, int);\nint bind_to_unix_dgram(char *);\nint timed_connect(struct pollfd *, const struct sockaddr *, int, int, int);\nint uwsgi_connect(char *, int, int);\nint uwsgi_connect_udp(char *);\nint uwsgi_connectn(char *, uint16_t, int, int);\n\nvoid daemonize(char *);\nvoid logto(char *);\n\nvoid log_request(struct wsgi_request *);\nvoid get_memusage(uint64_t *, uint64_t *);\n#ifdef __linux__\nvoid get_memusage_extra(uint64_t *, uint64_t *);\n#endif\nvoid harakiri(void);\n\nvoid stats(int);\n\n#ifdef UWSGI_XML\nvoid uwsgi_xml_config(char *, struct wsgi_request *, char *[]);\n#endif\n\nvoid uwsgi_500(struct wsgi_request *);\nvoid uwsgi_403(struct wsgi_request *);\nvoid uwsgi_404(struct wsgi_request *);\nvoid uwsgi_405(struct wsgi_request *);\nvoid uwsgi_redirect_to_slash(struct wsgi_request *);\n\nvoid manage_snmp(int, uint8_t *, int, struct sockaddr_in *);\n\nvoid uwsgi_master_manage_snmp(int);\n\nchar *uwsgi_spool_request(struct wsgi_request *, char *, size_t, char *, size_t);\nvoid spooler(struct uwsgi_spooler *);\npid_t spooler_start(struct uwsgi_spooler *);\n\nint uwsgi_spooler_read_header(char *, int, struct uwsgi_header *);\nint uwsgi_spooler_read_content(int, char *, char **, size_t *, struct uwsgi_header *, struct stat *);\n\n#if defined(_GNU_SOURCE) || defined(__UCLIBC__)\n#define uwsgi_versionsort versionsort\n#else\nint uwsgi_versionsort(const struct dirent **da, const struct dirent **db);\n#endif\n\nvoid uwsgi_curse(int, int);\nvoid uwsgi_curse_mule(int, int);\nvoid uwsgi_destroy_processes(void);\n\nvoid set_harakiri(struct wsgi_request *, int);\nvoid set_user_harakiri(struct wsgi_request *, int);\nvoid set_mule_harakiri(int);\nvoid set_spooler_harakiri(int);\nvoid inc_harakiri(struct wsgi_request *, int);\n\n#ifdef __BIG_ENDIAN__\nuint16_t uwsgi_swap16(uint16_t);\nuint32_t uwsgi_swap32(uint32_t);\nuint64_t uwsgi_swap64(uint64_t);\n#endif\n\nint uwsgi_parse_vars(struct wsgi_request *);\n\nvoid uwsgi_async_init(void);\nvoid async_loop();\nstruct wsgi_request *find_first_available_wsgi_req(void);\nstruct wsgi_request *find_wsgi_req_by_fd(int);\nvoid async_schedule_to_req_green(void);\nvoid async_schedule_to_req(void);\n\nint async_add_fd_write(struct wsgi_request *, int, int);\nint async_add_fd_read(struct wsgi_request *, int, int);\nvoid async_reset_request(struct wsgi_request *);\n\nvoid async_add_timeout(struct wsgi_request *, int);\n\nvoid uwsgi_as_root(void);\n\nvoid uwsgi_close_request(struct wsgi_request *);\n\nvoid wsgi_req_setup(struct wsgi_request *, int, struct uwsgi_socket *);\nint wsgi_req_recv(int, struct wsgi_request *);\nint wsgi_req_async_recv(struct wsgi_request *);\nint wsgi_req_accept(int, struct wsgi_request *);\nint wsgi_req_simple_accept(struct wsgi_request *, int);\n\n#define current_wsgi_req() (*uwsgi.current_wsgi_req)()\n\nvoid sanitize_args(void);\n\nvoid env_to_arg(char *, char *);\nvoid parse_sys_envs(char **);\n\nvoid uwsgi_log(const char *, ...);\nvoid uwsgi_log_verbose(const char *, ...);\nvoid uwsgi_logfile_write(const char *, ...);\n\n\nvoid *uwsgi_load_plugin(int, char *, char *);\n\nint unconfigured_hook(struct wsgi_request *);\n\nvoid uwsgi_ini_config(char *, char *[]);\n\n#ifdef UWSGI_YAML\nvoid uwsgi_yaml_config(char *, char *[]);\n#endif\n\n#ifdef UWSGI_JSON\nvoid uwsgi_json_config(char *, char *[]);\n#endif\n\nint uwsgi_strncmp(char *, int, char *, int);\nint uwsgi_strnicmp(char *, int, char *, int);\nint uwsgi_startswith(char *, char *, int);\n\n\nchar *uwsgi_concat(int, ...);\nchar *uwsgi_concatn(int, ...);\nchar *uwsgi_concat2(char *, char *);\nchar *uwsgi_concat2n(char *, int, char *, int);\nchar *uwsgi_concat2nn(char *, int, char *, int, int *);\nchar *uwsgi_concat3(char *, char *, char *);\nchar *uwsgi_concat3n(char *, int, char *, int, char *, int);\nchar *uwsgi_concat4(char *, char *, char *, char *);\nchar *uwsgi_concat4n(char *, int, char *, int, char *, int, char *, int);\n\n\nint uwsgi_get_app_id(struct wsgi_request *, char *, uint16_t, int);\nchar *uwsgi_strncopy(char *, int);\n\nint master_loop(char **, char **);\n\nint find_worker_id(pid_t);\n\n\nvoid simple_loop();\nvoid *simple_loop_run(void *);\n\nint uwsgi_count_options(struct uwsgi_option *);\n\nstruct wsgi_request *simple_current_wsgi_req(void);\nstruct wsgi_request *threaded_current_wsgi_req(void);\n\nvoid build_options(void);\n\nint uwsgi_postbuffer_do_in_disk(struct wsgi_request *);\nint uwsgi_postbuffer_do_in_mem(struct wsgi_request *);\n\nvoid uwsgi_register_loop(char *, void (*)(void));\nvoid *uwsgi_get_loop(char *);\n\nvoid add_exported_option(char *, char *, int);\nvoid add_exported_option_do(char *, char *, int, int);\n\nint uwsgi_waitfd_event(int, int, int);\n#define uwsgi_waitfd(a, b) uwsgi_waitfd_event(a, b, POLLIN)\n#define uwsgi_waitfd_write(a, b) uwsgi_waitfd_event(a, b, POLLOUT)\n\nint uwsgi_hooked_parse(char *, size_t, void (*)(char *, uint16_t, char *, uint16_t, void *), void *);\nint uwsgi_hooked_parse_array(char *, size_t, void (*) (uint16_t, char *, uint16_t, void *), void *);\n\nchar *generate_socket_name(char *);\n\n#define UMIN(a,b) ((a)>(b)?(b):(a))\n#define UMAX(a,b) ((a)<(b)?(b):(a))\n\nint uwsgi_cache_set2(struct uwsgi_cache *, char *, uint16_t, char *, uint64_t, uint64_t, uint64_t);\nint uwsgi_cache_del2(struct uwsgi_cache *, char *, uint16_t, uint64_t, uint16_t);\nchar *uwsgi_cache_get2(struct uwsgi_cache *, char *, uint16_t, uint64_t *);\nchar *uwsgi_cache_get3(struct uwsgi_cache *, char *, uint16_t, uint64_t *, uint64_t *);\nchar *uwsgi_cache_get4(struct uwsgi_cache *, char *, uint16_t, uint64_t *, uint64_t *);\nuint32_t uwsgi_cache_exists2(struct uwsgi_cache *, char *, uint16_t);\nstruct uwsgi_cache *uwsgi_cache_create(char *);\nstruct uwsgi_cache *uwsgi_cache_by_name(char *);\nstruct uwsgi_cache *uwsgi_cache_by_namelen(char *, uint16_t);\nvoid uwsgi_cache_create_all(void);\nvoid uwsgi_cache_sync_from_nodes(struct uwsgi_cache *);\nvoid uwsgi_cache_setup_nodes(struct uwsgi_cache *);\nint64_t uwsgi_cache_num2(struct uwsgi_cache *, char *, uint16_t);\n\nvoid uwsgi_cache_sync_all(void);\nvoid uwsgi_cache_start_sweepers(void);\nvoid uwsgi_cache_start_sync_servers(void);\n\n\nvoid *uwsgi_malloc(size_t);\nvoid *uwsgi_calloc(size_t);\n\n\nint event_queue_init(void);\nvoid *event_queue_alloc(int);\nint event_queue_add_fd_read(int, int);\nint event_queue_add_fd_write(int, int);\nint event_queue_del_fd(int, int, int);\nint event_queue_wait(int, int, int *);\nint event_queue_wait_multi(int, int, void *, int);\nint event_queue_interesting_fd(void *, int);\nint event_queue_interesting_fd_has_error(void *, int);\nint event_queue_fd_write_to_read(int, int);\nint event_queue_fd_read_to_write(int, int);\nint event_queue_fd_readwrite_to_read(int, int);\nint event_queue_fd_readwrite_to_write(int, int);\nint event_queue_fd_read_to_readwrite(int, int);\nint event_queue_fd_write_to_readwrite(int, int);\nint event_queue_interesting_fd_is_read(void *, int);\nint event_queue_interesting_fd_is_write(void *, int);\n\nint event_queue_add_timer(int, int *, int);\nint event_queue_add_timer_hr(int, int *, int, long);\nstruct uwsgi_timer *event_queue_ack_timer(int);\n\nint event_queue_add_file_monitor(int, char *, int *);\nstruct uwsgi_fmon *event_queue_ack_file_monitor(int, int);\n\n\nint uwsgi_register_signal(uint8_t, char *, void *, uint8_t);\nint uwsgi_add_file_monitor(uint8_t, char *);\nint uwsgi_add_timer(uint8_t, int);\nint uwsgi_add_timer_hr(uint8_t, int, long);\nint uwsgi_signal_add_rb_timer(uint8_t, int, int);\nint uwsgi_signal_handler(struct wsgi_request *, uint8_t);\n\nvoid uwsgi_route_signal(uint8_t);\n\nint uwsgi_start(void *);\n\nint uwsgi_register_rpc(char *, struct uwsgi_plugin *, uint8_t, void *);\nuint64_t uwsgi_rpc(char *, uint8_t, char **, uint16_t *, char **);\nchar *uwsgi_do_rpc(char *, char *, uint8_t, char **, uint16_t *, uint64_t *);\nvoid uwsgi_rpc_init(void);\n\nchar *uwsgi_cheap_string(char *, int);\n\nint uwsgi_parse_array(char *, uint16_t, char **, uint16_t *, uint8_t *);\n\n\nstruct uwsgi_gateway *register_gateway(char *, void (*)(int, void *), void *);\nvoid gateway_respawn(int);\n\nvoid uwsgi_gateway_go_cheap(char *, int, int *);\n\nchar *uwsgi_open_and_read(char *, size_t *, int, char *[]);\nchar *uwsgi_get_last_char(char *, char);\nchar *uwsgi_get_last_charn(char *, size_t, char);\n\nvoid uwsgi_spawn_daemon(struct uwsgi_daemon *);\nvoid uwsgi_detach_daemons();\n\nvoid emperor_loop(void);\nchar *uwsgi_num2str(int);\nchar *uwsgi_float2str(float);\nchar *uwsgi_64bit2str(int64_t);\nchar *uwsgi_size2str(size_t);\n\nchar *magic_sub(char *, size_t, size_t *, char *[]);\nvoid init_magic_table(char *[]);\n\nchar *uwsgi_req_append(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nint uwsgi_req_append_path_info_with_index(struct wsgi_request *, char *, uint16_t);\nint is_unix(char *, int);\nint is_a_number(char *);\n\nchar *uwsgi_resolve_ip(char *);\n\nvoid uwsgi_init_queue(void);\nchar *uwsgi_queue_get(uint64_t, uint64_t *);\nchar *uwsgi_queue_pull(uint64_t *);\nint uwsgi_queue_push(char *, uint64_t);\nchar *uwsgi_queue_pop(uint64_t *);\nint uwsgi_queue_set(uint64_t, char *, uint64_t);\n\n\nstruct uwsgi_subscribe_req {\n\tchar *key;\n\tuint16_t keylen;\n\n\tchar *address;\n\tuint16_t address_len;\n\n\tchar *auth;\n\tuint16_t auth_len;\n\n\tuint8_t modifier1;\n\tuint8_t modifier2;\n\n\tuint64_t cores;\n\tuint64_t load;\n\tuint64_t weight;\n\tchar *sign;\n\tuint16_t sign_len;\n\n\ttime_t unix_check;\n\n\tchar *base;\n\tuint16_t base_len;\n\n\tchar *sni_key;\n\tuint16_t sni_key_len;\n\n\tchar *sni_crt;\n\tuint16_t sni_crt_len;\n\n\tchar *sni_ca;\n\tuint16_t sni_ca_len;\n\n\tpid_t pid;\n\tuid_t uid;\n\tgid_t gid;\n\n\tchar *notify;\n\tuint16_t notify_len;\n\n\tuint64_t backup_level;\n\n\tchar *proto;\n\tuint16_t proto_len;\n\n\tstruct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);\n\n\tchar *vassal;\n\tuint16_t vassal_len;\n\n\tuint8_t clear;\n};\n\nvoid uwsgi_nuclear_blast();\n\nvoid uwsgi_unix_signal(int, void (*)(int));\n\nchar *uwsgi_get_exported_opt(char *);\nchar *uwsgi_manage_placeholder(char *);\n\nint uwsgi_signal_add_cron(uint8_t, int, int, int, int, int);\nint uwsgi_cron_task_needs_execution(struct tm *, int, int, int, int, int);\n\nchar *uwsgi_get_optname_by_index(int);\n\nint uwsgi_list_has_num(char *, int);\n\nint uwsgi_list_has_str(char *, char *);\n\nvoid uwsgi_cache_fix(struct uwsgi_cache *);\n\nstruct uwsgi_async_request {\n\n\tstruct wsgi_request *wsgi_req;\n\tstruct uwsgi_async_request *prev;\n\tstruct uwsgi_async_request *next;\n};\n\nint event_queue_read(void);\nint event_queue_write(void);\n\nvoid uwsgi_help(char *, char *, void *);\nvoid uwsgi_print_sym(char *, char *, void *);\n\nint uwsgi_str2_num(char *);\nint uwsgi_str3_num(char *);\nint uwsgi_str4_num(char *);\n\n#ifdef __linux__\n#if !defined(__ia64__)\nvoid linux_namespace_start(void *);\nvoid linux_namespace_jail(void);\n#endif\nvoid uwsgi_master_manage_setns(int);\nvoid uwsgi_setns(char *);\nvoid uwsgi_setns_preopen(void);\n#endif\n\n\nint uwsgi_amqp_consume_queue(int, char *, char *, char *, char *, char *, char *);\nchar *uwsgi_amqp_consume(int, uint64_t *, char **);\n\nint uwsgi_file_serve(struct wsgi_request *, char *, uint16_t, char *, uint16_t, int);\nint uwsgi_starts_with(char *, int, char *, int);\nint uwsgi_static_want_gzip(struct wsgi_request *, char *, size_t *, struct stat *);\n\n#ifdef __sun__\ntime_t timegm(struct tm *);\n#endif\n\nuint64_t uwsgi_str_num(char *, int);\nsize_t uwsgi_str_occurence(char *, size_t, char);\n\nint uwsgi_proto_base_write(struct wsgi_request *, char *, size_t);\nint uwsgi_proto_base_writev(struct wsgi_request *, struct iovec *, size_t *);\n#ifdef UWSGI_SSL\nint uwsgi_proto_ssl_write(struct wsgi_request *, char *, size_t);\n#endif\nssize_t uwsgi_proto_base_read_body(struct wsgi_request *, char *, size_t);\nssize_t uwsgi_proto_noop_read_body(struct wsgi_request *, char *, size_t);\n#ifdef UWSGI_SSL\nssize_t uwsgi_proto_ssl_read_body(struct wsgi_request *, char *, size_t);\n#endif\n\n\nint uwsgi_proto_base_accept(struct wsgi_request *, int);\nvoid uwsgi_proto_base_close(struct wsgi_request *);\n#ifdef UWSGI_SSL\nint uwsgi_proto_ssl_accept(struct wsgi_request *, int);\nvoid uwsgi_proto_ssl_close(struct wsgi_request *);\n#endif\nuint64_t proto_base_add_uwsgi_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nuint64_t proto_base_add_uwsgi_var(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\n\n// protocols\nvoid uwsgi_proto_uwsgi_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_puwsgi_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_raw_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_http_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_http11_setup(struct uwsgi_socket *);\n#ifdef UWSGI_SSL\nvoid uwsgi_proto_https_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_suwsgi_setup(struct uwsgi_socket *);\n#endif\n#ifdef UWSGI_ZEROMQ\nvoid uwsgi_proto_zmq_setup(struct uwsgi_socket *);\n#endif\nvoid uwsgi_proto_fastcgi_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_fastcgi_nph_setup(struct uwsgi_socket *);\n\nvoid uwsgi_proto_scgi_setup(struct uwsgi_socket *);\nvoid uwsgi_proto_scgi_nph_setup(struct uwsgi_socket *);\n\nint uwsgi_num2str2(int, char *);\n\n\nvoid uwsgi_add_socket_from_fd(struct uwsgi_socket *, int);\n\n\nchar *uwsgi_split3(char *, size_t, char, char **, size_t *, char **, size_t *, char **, size_t *);\nchar *uwsgi_split4(char *, size_t, char, char **, size_t *, char **, size_t *, char **, size_t *, char **, size_t *);\nchar *uwsgi_netstring(char *, size_t, char **, size_t *);\n\nchar *uwsgi_str_split_nget(char *, size_t, char, size_t, size_t *);\n\nint uwsgi_get_socket_num(struct uwsgi_socket *);\nstruct uwsgi_socket *uwsgi_new_socket(char *);\nstruct uwsgi_socket *uwsgi_new_shared_socket(char *);\nstruct uwsgi_socket *uwsgi_del_socket(struct uwsgi_socket *);\n\nvoid uwsgi_close_all_sockets(void);\nvoid uwsgi_close_all_unshared_sockets(void);\nvoid uwsgi_shutdown_all_sockets(void);\n\nstruct uwsgi_string_list *uwsgi_string_new_list(struct uwsgi_string_list **, char *);\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\nstruct uwsgi_regexp_list *uwsgi_regexp_custom_new_list(struct uwsgi_regexp_list **, char *, char *);\n#define uwsgi_regexp_new_list(x, y) uwsgi_regexp_custom_new_list(x, y, NULL);\n#endif\n\nvoid uwsgi_string_del_list(struct uwsgi_string_list **, struct uwsgi_string_list *);\n\nvoid uwsgi_init_all_apps(void);\nvoid uwsgi_init_worker_mount_apps(void);\nvoid uwsgi_socket_nb(int);\nvoid uwsgi_socket_b(int);\nint uwsgi_write_nb(int, char *, size_t, int);\nint uwsgi_read_nb(int, char *, size_t, int);\nssize_t uwsgi_read_true_nb(int, char *, size_t, int);\nint uwsgi_read_whole_true_nb(int, char *, size_t, int);\nint uwsgi_read_uh(int fd, struct uwsgi_header *, int);\nint uwsgi_proxy_nb(struct wsgi_request *, char *, struct uwsgi_buffer *, size_t, int);\n\nint uwsgi_read_with_realloc(int, char **, size_t *, int, uint8_t *, uint8_t *);\nint uwsgi_write_true_nb(int, char *, size_t, int);\n\nvoid uwsgi_destroy_request(struct wsgi_request *);\n\nvoid uwsgi_systemd_init(char *);\n\nvoid uwsgi_sig_pause(void);\n\nvoid uwsgi_ignition(void);\n\nint uwsgi_respawn_worker(int);\n\nsocklen_t socket_to_in_addr(char *, char *, int, struct sockaddr_in *);\nsocklen_t socket_to_un_addr(char *, struct sockaddr_un *);\nsocklen_t socket_to_in_addr6(char *, char *, int, struct sockaddr_in6 *);\n\nint uwsgi_get_shared_socket_fd_by_num(int);\nstruct uwsgi_socket *uwsgi_get_shared_socket_by_num(int);\n\nstruct uwsgi_socket *uwsgi_get_socket_by_num(int);\n\nint uwsgi_get_shared_socket_num(struct uwsgi_socket *);\n\n#ifdef __linux__\nvoid uwsgi_set_cgroup(void);\nlong uwsgi_num_from_file(char *, int);\n#endif\n\nvoid uwsgi_add_sockets_to_queue(int, int);\nvoid uwsgi_del_sockets_from_queue(int);\n\nint uwsgi_run_command_and_wait(char *, char *);\nint uwsgi_run_command_putenv_and_wait(char *, char *, char **, unsigned int);\nint uwsgi_call_symbol(char *);\n\nvoid uwsgi_manage_signal_cron(time_t);\npid_t uwsgi_run_command(char *, int *, int);\n\nvoid uwsgi_manage_command_cron(time_t);\n\nint *uwsgi_attach_fd(int, int *, char *, size_t);\n\nint uwsgi_count_sockets(struct uwsgi_socket *);\nint uwsgi_file_exists(char *);\n\nint uwsgi_signal_registered(uint8_t);\n\nint uwsgi_endswith(char *, char *);\n\n\nvoid uwsgi_chown(char *, char *);\n\nchar *uwsgi_get_binary_path(char *);\n\nchar *uwsgi_lower(char *, size_t);\nint uwsgi_num2str2n(int, char *, int);\nvoid create_logpipe(void);\n\nchar *uwsgi_str_contains(char *, int, char);\n\nint uwsgi_simple_parse_vars(struct wsgi_request *, char *, char *);\n\nvoid uwsgi_build_mime_dict(char *);\nstruct uwsgi_dyn_dict *uwsgi_dyn_dict_new(struct uwsgi_dyn_dict **, char *, int, char *, int);\nvoid uwsgi_dyn_dict_del(struct uwsgi_dyn_dict *);\nvoid uwsgi_dyn_dict_free(struct uwsgi_dyn_dict **);\n\n\nvoid uwsgi_apply_config_pass(char symbol, char *(*)(char *));\n\nvoid uwsgi_mule(int);\n\nchar *uwsgi_string_get_list(struct uwsgi_string_list **, int, size_t *);\n\nvoid uwsgi_fixup_fds(int, int, struct uwsgi_gateway *);\n\nvoid uwsgi_set_processname(char *);\n\nvoid http_url_decode4(char *, uint16_t *, char *, int);\n#define http_url_decode(x, y, z) http_url_decode4(x, y, z, 0)\n\nvoid http_url_encode(char *, uint16_t *, char *);\n\npid_t uwsgi_fork(char *);\n\nstruct uwsgi_mule *get_mule_by_id(int);\nstruct uwsgi_mule_farm *uwsgi_mule_farm_new(struct uwsgi_mule_farm **, struct uwsgi_mule *);\n\nint uwsgi_farm_has_mule(struct uwsgi_farm *, int);\nstruct uwsgi_farm *get_farm_by_name(char *);\n\nstruct uwsgi_subscription_client {\n\tint fd;\n\tunion uwsgi_sockaddr *sockaddr;\n\tchar *cookie;\n};\n\nstruct uwsgi_subscribe_node {\n\n\tchar name[0xff];\n\tuint16_t len;\n\tuint8_t modifier1;\n\tuint8_t modifier2;\n\n\ttime_t last_check;\n\n\t// absolute number of requests\n\tuint64_t requests;\n\t// number of requests since last subscription ping\n\tuint64_t last_requests;\n\n\tuint64_t tx;\n\tuint64_t rx;\n\n\tint death_mark;\n\tuint64_t reference;\n\tuint64_t cores;\n\tuint64_t load;\n\tuint64_t failcnt;\n\n\tuint64_t weight;\n\tuint64_t wrr;\n\n\ttime_t unix_check;\n\n\t// used by unix credentials\n\tpid_t pid;\n\tuid_t uid;\n\tgid_t gid;\n\n\tchar notify[102];\n\n\tstruct uwsgi_subscribe_slot *slot;\n\n\tstruct uwsgi_subscribe_node *next;\n\n\t// uWSGI 2.1\n\tuint64_t backup_level;\n\t//here the solution is a bit hacky, we take the first letter of the proto ('u','\\0' -> uwsgi, 'h' -> http, 'f' -> fastcgi, 's' -> scgi)\n\tchar proto;\n\n\tchar vassal[0xff];\n\tuint16_t vassal_len;\n};\n\nstruct uwsgi_subscribe_slot {\n\n\tchar key[0xff];\n\tuint16_t keylen;\n\n\tuint32_t hash;\n\n\tuint64_t hits;\n\n\tstruct uwsgi_subscribe_node *nodes;\n\n\tstruct uwsgi_subscribe_slot *prev;\n\tstruct uwsgi_subscribe_slot *next;\n\n#ifdef UWSGI_SSL\n\tEVP_PKEY *sign_public_key;\n\tEVP_MD_CTX *sign_ctx;\n\tuint8_t sni_enabled;\n#endif\n\n\t// uWSGI 2.1 (algo is required)\n        struct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);\n\n};\n\nint mule_send_msg(int, char *, size_t);\n\nuint32_t djb33x_hash(char *, uint64_t);\nvoid create_signal_pipe(int *);\nvoid create_msg_pipe(int *, int);\nstruct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slot **, char *, uint16_t);\nstruct uwsgi_subscribe_node *uwsgi_get_subscribe_node_by_name(struct uwsgi_subscribe_slot **, char *, uint16_t, char *, uint16_t);\nstruct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **, char *, uint16_t, struct uwsgi_subscription_client *);\nint uwsgi_remove_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_node *);\nstruct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_req *);\n\nssize_t uwsgi_mule_get_msg(int, int, char *, size_t, int);\n\nint uwsgi_signal_wait(struct wsgi_request *, int);\nstruct uwsgi_app *uwsgi_add_app(int, uint8_t, char *, int, void *, void *);\nint uwsgi_signal_send(int, uint8_t);\nint uwsgi_remote_signal_send(char *, uint8_t);\n\nvoid uwsgi_configure();\n\nint uwsgi_read_response(int, struct uwsgi_header *, int, char **);\nchar *uwsgi_simple_file_read(char *);\n\nvoid uwsgi_send_subscription(char *, char *, size_t, uint8_t, uint8_t, uint8_t, char *, char *, char *, char *, char *);\nvoid uwsgi_send_subscription_from_fd(int, char *, char *, size_t, uint8_t, uint8_t, uint8_t, char *, char *, char *, char *, char *);\n\nvoid uwsgi_subscribe(char *, uint8_t);\nvoid uwsgi_subscribe2(char *, uint8_t);\n\nint uwsgi_is_bad_connection(int);\nint uwsgi_long2str2n(unsigned long long, char *, int);\n\n#ifdef __linux__\nvoid uwsgi_build_unshare(char *, int *);\n#ifdef MADV_MERGEABLE\nvoid uwsgi_linux_ksm_map(void);\n#endif\n#endif\n\n#ifdef UWSGI_CAP\nint uwsgi_build_cap(char *, cap_value_t **);\nvoid uwsgi_apply_cap(cap_value_t *, int);\n#endif\n\nvoid uwsgi_register_logger(char *, ssize_t(*func) (struct uwsgi_logger *, char *, size_t));\nvoid uwsgi_append_logger(struct uwsgi_logger *);\nvoid uwsgi_append_req_logger(struct uwsgi_logger *);\nstruct uwsgi_logger *uwsgi_get_logger(char *);\nstruct uwsgi_logger *uwsgi_get_logger_from_id(char *);\n\nchar *uwsgi_getsockname(int);\nchar *uwsgi_get_var(struct wsgi_request *, char *, uint16_t, uint16_t *);\n\nstruct uwsgi_gateway_socket *uwsgi_new_gateway_socket(char *, char *);\nstruct uwsgi_gateway_socket *uwsgi_new_gateway_socket_from_fd(int, char *);\n\nvoid escape_shell_arg(char *, size_t, char *);\nvoid escape_json(char *, size_t, char *);\n\nvoid *uwsgi_malloc_shared(size_t);\nvoid *uwsgi_calloc_shared(size_t);\n\nstruct uwsgi_spooler *uwsgi_new_spooler(char *);\n\nstruct uwsgi_spooler *uwsgi_get_spooler_by_name(char *, size_t);\n\nint uwsgi_zerg_attach(char *);\n\nint uwsgi_manage_opt(char *, char *);\n\nvoid uwsgi_opt_print(char *, char *, void *);\nvoid uwsgi_opt_true(char *, char *, void *);\nvoid uwsgi_opt_false(char *, char *, void *);\nvoid uwsgi_opt_set_str(char *, char *, void *);\nvoid uwsgi_opt_custom(char *, char *, void *);\nvoid uwsgi_opt_set_null(char *, char *, void *);\nvoid uwsgi_opt_set_logger(char *, char *, void *);\nvoid uwsgi_opt_set_worker_logger(char *, char *, void *);\nvoid uwsgi_opt_set_req_logger(char *, char *, void *);\nvoid uwsgi_opt_set_str_spaced(char *, char *, void *);\nvoid uwsgi_opt_add_string_list(char *, char *, void *);\nvoid uwsgi_opt_add_addr_list(char *, char *, void *);\nvoid uwsgi_opt_add_string_list_custom(char *, char *, void *);\nvoid uwsgi_opt_add_dyn_dict(char *, char *, void *);\nvoid uwsgi_opt_binary_append_data(char *, char *, void *);\n#if defined(UWSGI_PCRE) || defined(UWSGI_PCRE2)\nvoid uwsgi_opt_pcre_jit(char *, char *, void *);\nvoid uwsgi_opt_add_regexp_dyn_dict(char *, char *, void *);\nvoid uwsgi_opt_add_regexp_list(char *, char *, void *);\nvoid uwsgi_opt_add_regexp_custom_list(char *, char *, void *);\n#endif\nvoid uwsgi_opt_set_int(char *, char *, void *);\nvoid uwsgi_opt_uid(char *, char *, void *);\nvoid uwsgi_opt_gid(char *, char *, void *);\nvoid uwsgi_opt_set_rawint(char *, char *, void *);\nvoid uwsgi_opt_set_16bit(char *, char *, void *);\nvoid uwsgi_opt_set_64bit(char *, char *, void *);\nvoid uwsgi_opt_set_megabytes(char *, char *, void *);\nvoid uwsgi_opt_set_placeholder(char *, char *, void *);\nvoid uwsgi_opt_add_shared_socket(char *, char *, void *);\nvoid uwsgi_opt_add_socket(char *, char *, void *);\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_add_ssl_socket(char *, char *, void *);\n#endif\nvoid uwsgi_opt_add_socket_no_defer(char *, char *, void *);\nvoid uwsgi_opt_add_lazy_socket(char *, char *, void *);\nvoid uwsgi_opt_add_cron(char *, char *, void *);\nvoid uwsgi_opt_add_cron2(char *, char *, void *);\nvoid uwsgi_opt_add_unique_cron(char *, char *, void *);\nvoid uwsgi_opt_load_plugin(char *, char *, void *);\nvoid uwsgi_opt_load_dl(char *, char *, void *);\nvoid uwsgi_opt_load(char *, char *, void *);\nvoid uwsgi_opt_safe_fd(char *, char *, void *);\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_add_legion_cron(char *, char *, void *);\nvoid uwsgi_opt_add_unique_legion_cron(char *, char *, void *);\nvoid uwsgi_opt_sni(char *, char *, void *);\nstruct uwsgi_string_list *uwsgi_ssl_add_sni_item(char *, char *, char *, char *, char *);\nvoid uwsgi_ssl_del_sni_item(char *, uint16_t);\nchar *uwsgi_write_pem_to_file(char *, char *, size_t, char *);\n#endif\nvoid uwsgi_opt_flock(char *, char *, void *);\nvoid uwsgi_opt_flock_wait(char *, char *, void *);\nvoid uwsgi_opt_load_ini(char *, char *, void *);\n#ifdef UWSGI_XML\nvoid uwsgi_opt_load_xml(char *, char *, void *);\n#endif\n#ifdef UWSGI_YAML\nvoid uwsgi_opt_load_yml(char *, char *, void *);\n#endif\n#ifdef UWSGI_JSON\nvoid uwsgi_opt_load_json(char *, char *, void *);\n#endif\n\nvoid uwsgi_opt_set_umask(char *, char *, void *);\nvoid uwsgi_opt_add_spooler(char *, char *, void *);\nvoid uwsgi_opt_add_daemon(char *, char *, void *);\nvoid uwsgi_opt_add_daemon2(char *, char *, void *);\nvoid uwsgi_opt_set_uid(char *, char *, void *);\nvoid uwsgi_opt_set_gid(char *, char *, void *);\nvoid uwsgi_opt_set_immediate_uid(char *, char *, void *);\nvoid uwsgi_opt_set_immediate_gid(char *, char *, void *);\nvoid uwsgi_opt_set_env(char *, char *, void *);\nvoid uwsgi_opt_unset_env(char *, char *, void *);\nvoid uwsgi_opt_pidfile_signal(char *, char *, void *);\n\nvoid uwsgi_opt_check_static(char *, char *, void *);\nvoid uwsgi_opt_fileserve_mode(char *, char *, void *);\nvoid uwsgi_opt_static_map(char *, char *, void *);\n\nvoid uwsgi_opt_add_mule(char *, char *, void *);\nvoid uwsgi_opt_add_mules(char *, char *, void *);\nvoid uwsgi_opt_add_farm(char *, char *, void *);\n\nvoid uwsgi_opt_signal(char *, char *, void *);\n\nvoid uwsgi_opt_snmp(char *, char *, void *);\nvoid uwsgi_opt_snmp_community(char *, char *, void *);\n\nvoid uwsgi_opt_logfile_chmod(char *, char *, void *);\n\nvoid uwsgi_opt_log_date(char *, char *, void *);\nvoid uwsgi_opt_chmod_socket(char *, char *, void *);\n\nvoid uwsgi_opt_max_vars(char *, char *, void *);\nvoid uwsgi_opt_deprecated(char *, char *, void *);\n\nvoid uwsgi_opt_noop(char *, char *, void *);\n\nvoid uwsgi_opt_logic(char *, char *, void *);\nint uwsgi_logic_opt_for(char *, char *);\nint uwsgi_logic_opt_for_glob(char *, char *);\nint uwsgi_logic_opt_for_times(char *, char *);\nint uwsgi_logic_opt_for_readline(char *, char *);\nint uwsgi_logic_opt_if_env(char *, char *);\nint uwsgi_logic_opt_if_not_env(char *, char *);\nint uwsgi_logic_opt_if_opt(char *, char *);\nint uwsgi_logic_opt_if_not_opt(char *, char *);\nint uwsgi_logic_opt_if_exists(char *, char *);\nint uwsgi_logic_opt_if_not_exists(char *, char *);\nint uwsgi_logic_opt_if_file(char *, char *);\nint uwsgi_logic_opt_if_not_file(char *, char *);\nint uwsgi_logic_opt_if_dir(char *, char *);\nint uwsgi_logic_opt_if_not_dir(char *, char *);\nint uwsgi_logic_opt_if_reload(char *, char *);\nint uwsgi_logic_opt_if_not_reload(char *, char *);\nint uwsgi_logic_opt_if_plugin(char *, char *);\nint uwsgi_logic_opt_if_not_plugin(char *, char *);\nint uwsgi_logic_opt_if_hostname(char *, char *);\nint uwsgi_logic_opt_if_not_hostname(char *, char *);\nint uwsgi_logic_opt_if_hostname_match(char *, char *);\nint uwsgi_logic_opt_if_not_hostname_match(char *, char *);\nint uwsgi_logic_opt_else(char *, char *);\n\n\nvoid uwsgi_opt_resolve(char *, char *, void *);\n\n#ifdef UWSGI_CAP\nvoid uwsgi_opt_set_cap(char *, char *, void *);\nvoid uwsgi_opt_set_emperor_cap(char *, char *, void *);\n#endif\n#ifdef __linux__\nvoid uwsgi_opt_set_unshare(char *, char *, void *);\n#endif\n\nint uwsgi_tmpfd();\nFILE *uwsgi_tmpfile();\n\n#ifdef UWSGI_ROUTING\nstruct uwsgi_router *uwsgi_register_router(char *, int (*)(struct uwsgi_route *, char *));\nvoid uwsgi_opt_add_route(char *, char *, void *);\nint uwsgi_apply_routes(struct wsgi_request *);\nvoid uwsgi_apply_final_routes(struct wsgi_request *);\nint uwsgi_apply_error_routes(struct wsgi_request *);\nint uwsgi_apply_response_routes(struct wsgi_request *);\nint uwsgi_apply_routes_do(struct uwsgi_route *, struct wsgi_request *, char *, uint16_t);\nvoid uwsgi_register_embedded_routers(void);\nvoid uwsgi_routing_dump();\nstruct uwsgi_buffer *uwsgi_routing_translate(struct wsgi_request *, struct uwsgi_route *, char *, uint16_t, char *, size_t);\nint uwsgi_route_api_func(struct wsgi_request *, char *, char *);\nstruct uwsgi_route_condition *uwsgi_register_route_condition(char *, int (*) (struct wsgi_request *, struct uwsgi_route *));\nvoid uwsgi_fixup_routes(struct uwsgi_route *);\n#endif\n\nvoid uwsgi_reload(char **);\n\nchar *uwsgi_chomp(char *);\nchar *uwsgi_chomp2(char *);\nint uwsgi_file_to_string_list(char *, struct uwsgi_string_list **);\nvoid uwsgi_backtrace(int);\nvoid uwsgi_check_logrotate(void);\nchar *uwsgi_check_touches(struct uwsgi_string_list *);\n\nvoid uwsgi_manage_zerg(int, int, int *);\n\ntime_t uwsgi_now(void);\n\nint uwsgi_calc_cheaper(void);\nint uwsgi_cheaper_algo_spare(int);\nint uwsgi_cheaper_algo_spare2(int);\nint uwsgi_cheaper_algo_backlog(int);\nint uwsgi_cheaper_algo_manual(int);\n\nint uwsgi_master_log(void);\nint uwsgi_master_req_log(void);\nvoid uwsgi_flush_logs(void);\n\nvoid uwsgi_register_cheaper_algo(char *, int (*)(int));\n\nvoid uwsgi_setup_locking(void);\nint uwsgi_fcntl_lock(int);\nint uwsgi_fcntl_is_locked(int);\n\nvoid uwsgi_emulate_cow_for_apps(int);\n\nchar *uwsgi_read_fd(int, size_t *, int);\n\nvoid uwsgi_setup_post_buffering(void);\n\nstruct uwsgi_lock_item *uwsgi_lock_ipcsem_init(char *);\n\nvoid uwsgi_write_pidfile(char *);\nvoid uwsgi_write_pidfile_explicit(char *, pid_t);\nint uwsgi_write_intfile(char *, int);\n\nvoid uwsgi_protected_close(int);\nssize_t uwsgi_protected_read(int, void *, size_t);\nint uwsgi_socket_uniq(struct uwsgi_socket *, struct uwsgi_socket *);\nint uwsgi_socket_is_already_bound(char *name);\n\nchar *uwsgi_expand_path(char *, int, char *);\nint uwsgi_try_autoload(char *);\n\nuint64_t uwsgi_micros(void);\nuint64_t uwsgi_millis(void);\nint uwsgi_is_file(char *);\nint uwsgi_is_file2(char *, struct stat *);\nint uwsgi_is_dir(char *);\nint uwsgi_is_link(char *);\n\nint uwsgi_receive_signal(struct wsgi_request *, int, char *, int);\nvoid uwsgi_exec_atexit(void);\n\nstruct uwsgi_stats {\n\tchar *base;\n\toff_t pos;\n\tsize_t tabs;\n\tsize_t chunk;\n\tsize_t size;\n\tint minified;\n\tint dirty;\n};\n\nstruct uwsgi_stats_pusher_instance;\n\nstruct uwsgi_stats_pusher {\n\tchar *name;\n\tvoid (*func) (struct uwsgi_stats_pusher_instance *, time_t, char *, size_t);\n\tint raw;\n\tstruct uwsgi_stats_pusher *next;\n};\n\nstruct uwsgi_stats_pusher_instance {\n\tstruct uwsgi_stats_pusher *pusher;\n\tchar *arg;\n\tvoid *data;\n\tint raw;\t\n\tint configured;\n\tint freq;\n\ttime_t last_run;\n\t// retries\n\tint needs_retry;\n\tint retries;\n\tint max_retries;\n\tint retry_delay;\n\ttime_t next_retry;\n\n\tstruct uwsgi_stats_pusher_instance *next;\n};\n\nstruct uwsgi_thread;\nvoid uwsgi_stats_pusher_loop(struct uwsgi_thread *);\n\nvoid uwsgi_stats_pusher_setup(void);\nvoid uwsgi_send_stats(int, struct uwsgi_stats *(*func) (void));\nstruct uwsgi_stats *uwsgi_master_generate_stats(void);\nstruct uwsgi_stats_pusher * uwsgi_register_stats_pusher(char *, void (*)(struct uwsgi_stats_pusher_instance *, time_t, char *, size_t));\n\nstruct uwsgi_stats *uwsgi_stats_new(size_t);\nint uwsgi_stats_symbol(struct uwsgi_stats *, char);\nint uwsgi_stats_comma(struct uwsgi_stats *);\nint uwsgi_stats_object_open(struct uwsgi_stats *);\nint uwsgi_stats_object_close(struct uwsgi_stats *);\nint uwsgi_stats_list_open(struct uwsgi_stats *);\nint uwsgi_stats_list_close(struct uwsgi_stats *);\nint uwsgi_stats_keyval(struct uwsgi_stats *, char *, char *);\nint uwsgi_stats_keyval_comma(struct uwsgi_stats *, char *, char *);\nint uwsgi_stats_keyvalnum(struct uwsgi_stats *, char *, char *, unsigned long long);\nint uwsgi_stats_keyvalnum_comma(struct uwsgi_stats *, char *, char *, unsigned long long);\nint uwsgi_stats_keyvaln(struct uwsgi_stats *, char *, char *, int);\nint uwsgi_stats_keyvaln_comma(struct uwsgi_stats *, char *, char *, int);\nint uwsgi_stats_key(struct uwsgi_stats *, char *);\nint uwsgi_stats_keylong(struct uwsgi_stats *, char *, unsigned long long);\nint uwsgi_stats_keylong_comma(struct uwsgi_stats *, char *, unsigned long long);\nint uwsgi_stats_keyslong(struct uwsgi_stats *, char *, long long);\nint uwsgi_stats_keyslong_comma(struct uwsgi_stats *, char *, long long);\nint uwsgi_stats_str(struct uwsgi_stats *, char *);\n\nchar *uwsgi_substitute(char *, char *, char *);\n\nvoid uwsgi_opt_add_custom_option(char *, char *, void *);\nvoid uwsgi_opt_cflags(char *, char *, void *);\nvoid uwsgi_opt_build_plugin(char *, char *, void *);\nvoid uwsgi_opt_dot_h(char *, char *, void *);\nvoid uwsgi_opt_config_py(char *, char *, void *);\nvoid uwsgi_opt_connect_and_read(char *, char *, void *);\nvoid uwsgi_opt_extract(char *, char *, void *);\n\nchar *uwsgi_get_dot_h();\nchar *uwsgi_get_config_py();\nchar *uwsgi_get_cflags();\n\nstruct uwsgi_string_list *uwsgi_string_list_has_item(struct uwsgi_string_list *, char *, size_t);\n\nvoid trigger_harakiri(int);\n\nvoid uwsgi_setup_systemd();\nvoid uwsgi_setup_upstart();\nvoid uwsgi_setup_zerg();\nvoid uwsgi_setup_inherited_sockets();\nvoid uwsgi_setup_emperor();\n\n#ifdef UWSGI_SSL\nvoid uwsgi_ssl_init(void);\nSSL_CTX *uwsgi_ssl_new_server_context(char *, char *, char *, char *, char *);\nchar *uwsgi_rsa_sign(char *, char *, size_t, unsigned int *);\nchar *uwsgi_sanitize_cert_filename(char *, char *, uint16_t);\nvoid uwsgi_opt_scd(char *, char *, void *);\nint uwsgi_subscription_sign_check(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_req *);\n\nchar *uwsgi_sha1(char *, size_t, char *);\nchar *uwsgi_sha1_2n(char *, size_t, char *, size_t, char *);\nchar *uwsgi_md5(char *, size_t, char *);\n#endif\n\nvoid uwsgi_opt_ssa(char *, char *, void *);\n\nint uwsgi_no_subscriptions(struct uwsgi_subscribe_slot **);\nvoid uwsgi_deadlock_check(pid_t);\n\n\nstruct uwsgi_logchunk {\n\tchar *name;\n\tchar *ptr;\n\tsize_t len;\n\tint vec;\n\tlong pos;\n\tlong pos_len;\n\tint type;\n\tint free;\n\tssize_t(*func) (struct wsgi_request *, char **);\n\tstruct uwsgi_logchunk *next;\n};\n\nvoid uwsgi_build_log_format(char *);\n\nvoid uwsgi_add_logchunk(int, int, char *, size_t);\nstruct uwsgi_logchunk *uwsgi_register_logchunk(char *, ssize_t (*)(struct wsgi_request *, char **), int);\n\nvoid uwsgi_logit_simple(struct wsgi_request *);\nvoid uwsgi_logit_lf(struct wsgi_request *);\n\nstruct uwsgi_logvar *uwsgi_logvar_get(struct wsgi_request *, char *, uint8_t);\nvoid uwsgi_logvar_add(struct wsgi_request *, char *, uint8_t, char *, uint8_t);\n\n// scanners are instances of 'imperial_monitor'\nstruct uwsgi_emperor_scanner {\n\tchar *arg;\n\tint fd;\n\tvoid *data;\n\tvoid (*event_func) (struct uwsgi_emperor_scanner *);\n\tstruct uwsgi_imperial_monitor *monitor;\n\tstruct uwsgi_emperor_scanner *next;\n};\n\nvoid uwsgi_register_imperial_monitor(char *, void (*)(struct uwsgi_emperor_scanner *), void (*)(struct uwsgi_emperor_scanner *));\nint uwsgi_emperor_is_valid(char *);\n\n// an instance (called vassal) is a uWSGI stack running\n// it is identified by the name of its config file\n// a vassal is 'loyal' as soon as it manages a request\nstruct uwsgi_instance {\n\tstruct uwsgi_instance *ui_prev;\n\tstruct uwsgi_instance *ui_next;\n\n\tchar name[0xff];\n\tpid_t pid;\n\n\tint status;\n\ttime_t born;\n\ttime_t last_mod;\n\ttime_t last_loyal;\n\ttime_t last_accepting;\n\ttime_t last_ready;\n\n\ttime_t last_run;\n\ttime_t first_run;\n\n\ttime_t last_heartbeat;\n\n\tuint64_t respawns;\n\tint use_config;\n\n\tint pipe[2];\n\tint pipe_config[2];\n\n\tchar *config;\n\tuint32_t config_len;\n\n\tint loyal;\n\n\tint zerg;\n\n\tint ready;\n\tint accepting;\n\n\tstruct uwsgi_emperor_scanner *scanner;\n\n\tuid_t uid;\n\tgid_t gid;\n\n\tint on_demand_fd;\n\tchar *socket_name;\n\ttime_t cursed_at;\n\n\tint adopted;\n\n\t// uWSGI 2.1 (vassal's attributes)\n\tstruct uwsgi_dyn_dict *attrs;\n\n\t// when 1 the instance must be manually activated\n\tint suspended;\n};\n\nstruct uwsgi_instance *emperor_get_by_fd(int);\nstruct uwsgi_instance *emperor_get(char *);\nvoid emperor_stop(struct uwsgi_instance *);\nvoid emperor_curse(struct uwsgi_instance *);\nvoid emperor_respawn(struct uwsgi_instance *, time_t);\nvoid emperor_add(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *);\nvoid emperor_add_with_attrs(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);\nvoid emperor_back_to_ondemand(struct uwsgi_instance *);\n\nvoid uwsgi_exec_command_with_args(char *);\n\nvoid uwsgi_imperial_monitor_glob_init(struct uwsgi_emperor_scanner *);\nvoid uwsgi_imperial_monitor_directory_init(struct uwsgi_emperor_scanner *);\nvoid uwsgi_imperial_monitor_directory(struct uwsgi_emperor_scanner *);\nvoid uwsgi_imperial_monitor_glob(struct uwsgi_emperor_scanner *);\n\nvoid uwsgi_register_clock(struct uwsgi_clock *);\nvoid uwsgi_set_clock(char *name);\n\nvoid uwsgi_init_default(void);\nvoid uwsgi_setup_reload(void);\nvoid uwsgi_autoload_plugins_by_name(char *);\nvoid uwsgi_commandline_config(void);\n\nvoid uwsgi_setup_log(void);\nvoid uwsgi_setup_log_master(void);\n\nvoid uwsgi_setup_shared_sockets(void);\n\nvoid uwsgi_setup_mules_and_farms(void);\n\nvoid uwsgi_setup_workers(void);\nvoid uwsgi_map_sockets(void);\n\nvoid uwsgi_set_cpu_affinity(void);\n\nvoid uwsgi_emperor_start(void);\n\nvoid uwsgi_bind_sockets(void);\nvoid uwsgi_set_sockets_protocols(void);\n\nstruct uwsgi_buffer *uwsgi_buffer_new(size_t);\nint uwsgi_buffer_append(struct uwsgi_buffer *, char *, size_t);\nint uwsgi_buffer_fix(struct uwsgi_buffer *, size_t);\nint uwsgi_buffer_ensure(struct uwsgi_buffer *, size_t);\nvoid uwsgi_buffer_destroy(struct uwsgi_buffer *);\nint uwsgi_buffer_u8(struct uwsgi_buffer *, uint8_t);\nint uwsgi_buffer_byte(struct uwsgi_buffer *, char);\nint uwsgi_buffer_u16le(struct uwsgi_buffer *, uint16_t);\nint uwsgi_buffer_u16be(struct uwsgi_buffer *, uint16_t);\nint uwsgi_buffer_u32be(struct uwsgi_buffer *, uint32_t);\nint uwsgi_buffer_u32le(struct uwsgi_buffer *, uint32_t);\nint uwsgi_buffer_u64le(struct uwsgi_buffer *, uint64_t);\nint uwsgi_buffer_f32be(struct uwsgi_buffer *, float);\nint uwsgi_buffer_u24be(struct uwsgi_buffer *, uint32_t);\nint uwsgi_buffer_u64be(struct uwsgi_buffer *, uint64_t);\nint uwsgi_buffer_f64be(struct uwsgi_buffer *, double);\nint uwsgi_buffer_num64(struct uwsgi_buffer *, int64_t);\nint uwsgi_buffer_append_keyval(struct uwsgi_buffer *, char *, uint16_t, char *, uint16_t);\nint uwsgi_buffer_append_keyval32(struct uwsgi_buffer *, char *, uint32_t, char *, uint32_t);\nint uwsgi_buffer_append_keynum(struct uwsgi_buffer *, char *, uint16_t, int64_t);\nint uwsgi_buffer_append_valnum(struct uwsgi_buffer *, int64_t);\nint uwsgi_buffer_append_ipv4(struct uwsgi_buffer *, void *);\nint uwsgi_buffer_append_keyipv4(struct uwsgi_buffer *, char *, uint16_t, void *);\nint uwsgi_buffer_decapitate(struct uwsgi_buffer *, size_t);\nint uwsgi_buffer_append_base64(struct uwsgi_buffer *, char *, size_t);\nint uwsgi_buffer_insert(struct uwsgi_buffer *, size_t, char *, size_t);\nint uwsgi_buffer_insert_chunked(struct uwsgi_buffer *, size_t, size_t);\nint uwsgi_buffer_append_chunked(struct uwsgi_buffer *, size_t);\nint uwsgi_buffer_append_json(struct uwsgi_buffer *, char *, size_t);\nint uwsgi_buffer_set_uh(struct uwsgi_buffer *, uint8_t, uint8_t);\nvoid uwsgi_buffer_map(struct uwsgi_buffer *, char *, size_t);\nstruct uwsgi_buffer *uwsgi_buffer_from_file(char *);\n\nssize_t uwsgi_buffer_write_simple(struct wsgi_request *, struct uwsgi_buffer *);\n\nstruct uwsgi_buffer *uwsgi_to_http(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nstruct uwsgi_buffer *uwsgi_to_http_dumb(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nstruct uwsgi_buffer *uwsgi_to_fastcgi(struct wsgi_request *, int);\nint http_status_code(char *buf, int len);\n\nssize_t uwsgi_pipe(int, int, int);\nssize_t uwsgi_pipe_sized(int, int, size_t, int);\n\nint uwsgi_buffer_send(struct uwsgi_buffer *, int);\nvoid uwsgi_master_cleanup_hooks(void);\n\npid_t uwsgi_daemonize2();\n\nvoid uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *);\nvoid uwsgi_emperor_simple_do_with_attrs(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);\n\n#if defined(__linux__)\n#define UWSGI_ELF\nchar *uwsgi_elf_section(char *, char *, size_t *);\n#endif\n\nvoid uwsgi_alarm_log_check(char *, size_t);\nvoid uwsgi_alarm_run(struct uwsgi_alarm_instance *, char *, size_t);\nvoid uwsgi_register_alarm(char *, void (*)(struct uwsgi_alarm_instance *), void (*)(struct uwsgi_alarm_instance *, char *, size_t));\nvoid uwsgi_register_embedded_alarms();\nvoid uwsgi_alarms_init();\nvoid uwsgi_alarm_trigger(char *, char *, size_t);\n\nstruct uwsgi_thread {\n\tpthread_t tid;\n\tpthread_attr_t tattr;\n\tint pipe[2];\n\tint queue;\n\tssize_t rlen;\n\tvoid *data;\n\tchar *buf;\n\toff_t pos;\n\tsize_t len;\n\tuint64_t custom0;\n\tuint64_t custom1;\n\tuint64_t custom2;\n\tuint64_t custom3;\n\t// linked list for offloaded requests\n\tstruct uwsgi_offload_request *offload_requests_head;\n\tstruct uwsgi_offload_request *offload_requests_tail;\n\tvoid (*func) (struct uwsgi_thread *);\n};\nstruct uwsgi_thread *uwsgi_thread_new(void (*)(struct uwsgi_thread *));\nstruct uwsgi_thread *uwsgi_thread_new_with_data(void (*)(struct uwsgi_thread *), void *data);\n\nstruct uwsgi_offload_request {\n\t// the request socket\n\tint s;\n\t// the peer\n\tint fd;\n\tint fd2;\n\n\t// if set the current request is expected to end leaving\n\t// the offload thread do its job\n\tuint8_t takeover;\n\n\t// internal state\n\tint status;\n\n\t// a filename, a socket...\n\tchar *name;\n\n\toff_t pos;\n\tchar *buf;\n\toff_t buf_pos;\n\n\tsize_t to_write;\n\tsize_t len;\n\tsize_t written;\n\n\t// a uwsgi_buffer (will be destroyed at the end of the task)\n\tstruct uwsgi_buffer *ubuf;\n\n\tstruct uwsgi_offload_engine *engine;\n\n\t// this pipe is used for notifications\n\tint pipe[2];\n\n\tstruct uwsgi_offload_request *prev;\n\tstruct uwsgi_offload_request *next;\n\n\t// added in 2.1\n\tstruct uwsgi_buffer *ubuf1;\n\tstruct uwsgi_buffer *ubuf2;\n\tstruct uwsgi_buffer *ubuf3;\n\tstruct uwsgi_buffer *ubuf4;\n\tstruct uwsgi_buffer *ubuf5;\n\tstruct uwsgi_buffer *ubuf6;\n\tstruct uwsgi_buffer *ubuf7;\n\tstruct uwsgi_buffer *ubuf8;\n\n\tint64_t custom1;\n\tint64_t custom2;\n\tint64_t custom3;\n\tint64_t custom4;\n\tint64_t custom5;\n\tint64_t custom6;\n\tint64_t custom7;\n\tint64_t custom8;\n\n\tvoid *data;\n\tvoid (*free)(struct uwsgi_offload_request *);\n};\n\nstruct uwsgi_offload_engine {\n\tchar *name;\n\tint (*prepare_func)(struct wsgi_request *, struct uwsgi_offload_request *);\n\tint (*event_func) (struct uwsgi_thread *, struct uwsgi_offload_request *, int);\n\tstruct uwsgi_offload_engine *next;\t\n};\n\nstruct uwsgi_offload_engine *uwsgi_offload_engine_by_name(char *);\nstruct uwsgi_offload_engine *uwsgi_offload_register_engine(char *, int (*)(struct wsgi_request *, struct uwsgi_offload_request *), int (*) (struct uwsgi_thread *, struct uwsgi_offload_request *, int));\n\nvoid uwsgi_offload_setup(struct uwsgi_offload_engine *, struct uwsgi_offload_request *, struct wsgi_request *, uint8_t);\nint uwsgi_offload_run(struct wsgi_request *, struct uwsgi_offload_request *, int *);\nvoid uwsgi_offload_engines_register_all(void);\n\nstruct uwsgi_thread *uwsgi_offload_thread_start(void);\nint uwsgi_offload_request_sendfile_do(struct wsgi_request *, int, size_t, size_t);\nint uwsgi_offload_request_net_do(struct wsgi_request *, char *, struct uwsgi_buffer *);\nint uwsgi_offload_request_memory_do(struct wsgi_request *, char *, size_t);\nint uwsgi_offload_request_pipe_do(struct wsgi_request *, int, size_t);\n\nint uwsgi_simple_sendfile(struct wsgi_request *, int, size_t, size_t);\nint uwsgi_simple_write(struct wsgi_request *, char *, size_t);\n\n\nvoid uwsgi_subscription_set_algo(char *);\nstruct uwsgi_subscribe_slot **uwsgi_subscription_init_ht(void);\n\nint uwsgi_check_pidfile(char *);\nvoid uwsgi_daemons_spawn_all();\n\nint uwsgi_daemon_check_pid_death(pid_t);\nint uwsgi_daemon_check_pid_reload(pid_t);\nvoid uwsgi_daemons_smart_check();\n\nvoid uwsgi_setup_thread_req(long, struct wsgi_request *);\nvoid uwsgi_loop_cores_run(void *(*)(void *));\n\nint uwsgi_kvlist_parse(char *, size_t, char, int, ...);\nint uwsgi_send_http_stats(int);\n\nint uwsgi_plugin_modifier1(char *);\n\nvoid *cache_udp_server_loop(void *);\n\nint uwsgi_user_lock(int);\nint uwsgi_user_unlock(int);\n\nvoid simple_loop_run_int(int);\n\nchar *uwsgi_strip(char *);\n\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_legion(char *, char *, void *);\nvoid uwsgi_opt_legion_mcast(char *, char *, void *);\nstruct uwsgi_legion *uwsgi_legion_register(char *, char *, char *, char *, char *);\nvoid uwsgi_opt_legion_node(char *, char *, void *);\nvoid uwsgi_legion_register_node(struct uwsgi_legion *, char *);\nvoid uwsgi_opt_legion_quorum(char *, char *, void *);\nvoid uwsgi_opt_legion_hook(char *, char *, void *);\nvoid uwsgi_legion_register_hook(struct uwsgi_legion *, char *, char *);\nvoid uwsgi_opt_legion_scroll(char *, char *, void *);\nvoid uwsgi_legion_add(struct uwsgi_legion *);\nvoid uwsgi_legion_announce_death(void);\nchar *uwsgi_ssl_rand(size_t);\nvoid uwsgi_start_legions(void);\nint uwsgi_legion_announce(struct uwsgi_legion *);\nstruct uwsgi_legion *uwsgi_legion_get_by_name(char *);\nstruct uwsgi_legion_action *uwsgi_legion_action_get(char *);\nstruct uwsgi_legion_action *uwsgi_legion_action_register(char *, int (*)(struct uwsgi_legion *, char *));\nint uwsgi_legion_action_call(char *, struct uwsgi_legion *, struct uwsgi_string_list *);\nvoid uwsgi_legion_atexit(void);\n#endif\n\nstruct uwsgi_option *uwsgi_opt_get(char *);\nint uwsgi_opt_exists(char *);\nint uwsgi_valid_fd(int);\nvoid uwsgi_close_all_fds(void);\n\nint check_hex(char *, int);\nvoid uwsgi_uuid(char *);\nint uwsgi_uuid_cmp(char *, char *);\n\nint uwsgi_legion_i_am_the_lord(char *);\nchar *uwsgi_legion_lord_scroll(char *, uint16_t *);\nvoid uwsgi_additional_header_add(struct wsgi_request *, char *, uint16_t);\nvoid uwsgi_remove_header(struct wsgi_request *, char *, uint16_t);\n\nvoid uwsgi_proto_hooks_setup(void);\n\nchar *uwsgi_base64_decode(char *, size_t, size_t *);\nchar *uwsgi_base64_encode(char *, size_t, size_t *);\n\nvoid uwsgi_subscribe_all(uint8_t, int);\n#define uwsgi_unsubscribe_all() uwsgi_subscribe_all(1, 1)\n\nvoid uwsgi_websockets_init(void);\nint uwsgi_websocket_send(struct wsgi_request *, char *, size_t);\nint uwsgi_websocket_send_binary(struct wsgi_request *, char *, size_t);\nstruct uwsgi_buffer *uwsgi_websocket_recv(struct wsgi_request *);\nstruct uwsgi_buffer *uwsgi_websocket_recv_nb(struct wsgi_request *);\n\nchar *uwsgi_chunked_read(struct wsgi_request *, size_t *, int, int);\nstruct uwsgi_buffer *uwsgi_chunked_read_smart(struct wsgi_request *, size_t, int);\n\nuint16_t uwsgi_be16(char *);\nuint32_t uwsgi_be32(char *);\nuint64_t uwsgi_be64(char *);\n\nint uwsgi_websocket_handshake(struct wsgi_request *, char *, uint16_t, char *, uint16_t, char *, uint16_t);\n\nint uwsgi_response_prepare_headers(struct wsgi_request *, char *, uint16_t);\nint uwsgi_response_prepare_headers_int(struct wsgi_request *, int);\nint uwsgi_response_add_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nint uwsgi_response_add_header_force(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nint uwsgi_response_sendfile_do(struct wsgi_request *, int, size_t, size_t);\nint uwsgi_response_sendfile_do_can_close(struct wsgi_request *, int, size_t, size_t, int);\n\nstruct uwsgi_buffer *uwsgi_proto_base_add_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\n\nint uwsgi_simple_wait_write_hook(int, int);\nint uwsgi_simple_wait_read_hook(int, int);\nint uwsgi_simple_wait_read2_hook(int, int, int, int *);\nint uwsgi_simple_wait_milliseconds_hook(int);\nint uwsgi_response_write_headers_do(struct wsgi_request *);\nchar *uwsgi_request_body_read(struct wsgi_request *, ssize_t , ssize_t *);\nchar *uwsgi_request_body_readline(struct wsgi_request *, ssize_t, ssize_t *);\nvoid uwsgi_request_body_seek(struct wsgi_request *, off_t);\n\nstruct uwsgi_buffer *uwsgi_proto_base_prepare_headers(struct wsgi_request *, char *, uint16_t);\nstruct uwsgi_buffer *uwsgi_proto_base_cgi_prepare_headers(struct wsgi_request *, char *, uint16_t);\nint uwsgi_response_write_body_do(struct wsgi_request *, char *, size_t);\nint uwsgi_response_writev_body_do(struct wsgi_request *, struct iovec *, size_t);\n\nint uwsgi_proto_base_sendfile(struct wsgi_request *, int, size_t, size_t);\n#ifdef UWSGI_SSL\nint uwsgi_proto_ssl_sendfile(struct wsgi_request *, int, size_t, size_t);\n#endif\n\nssize_t uwsgi_sendfile_do(int, int, size_t, size_t);\nint uwsgi_proto_base_fix_headers(struct wsgi_request *);\nint uwsgi_response_add_content_length(struct wsgi_request *, uint64_t);\nvoid uwsgi_fix_range_for_size(enum uwsgi_range*, int64_t*, int64_t*, int64_t);\nvoid uwsgi_request_fix_range_for_size(struct wsgi_request *, int64_t);\nint uwsgi_response_add_content_range(struct wsgi_request *, int64_t, int64_t, int64_t);\nint uwsgi_response_add_expires(struct wsgi_request *, uint64_t);\nint uwsgi_response_add_last_modified(struct wsgi_request *, uint64_t);\nint uwsgi_response_add_date(struct wsgi_request *, char *, uint16_t, uint64_t);\n\nconst char *uwsgi_http_status_msg(char *, uint16_t *);\nint uwsgi_stats_dump_vars(struct uwsgi_stats *, struct uwsgi_core *);\nint uwsgi_stats_dump_request(struct uwsgi_stats *, struct uwsgi_core *);\n\nint uwsgi_contains_n(char *, size_t, char *, size_t);\n\nchar *uwsgi_upload_progress_create(struct wsgi_request *, int *);\nint uwsgi_upload_progress_update(struct wsgi_request *, int, size_t);\nvoid uwsgi_upload_progress_destroy(char *, int);\n\nvoid uwsgi_time_bomb(int, int);\nvoid uwsgi_master_manage_emperor(void);\nvoid uwsgi_master_manage_udp(int);\n\nvoid uwsgi_threaded_logger_spawn(void);\nvoid uwsgi_threaded_logger_worker_spawn(void);\n\nvoid uwsgi_master_check_idle(void);\nint uwsgi_master_check_workers_deadline(void);\nint uwsgi_master_check_gateways_deadline(void);\nint uwsgi_master_check_mules_deadline(void);\nint uwsgi_master_check_spoolers_deadline(void);\nint uwsgi_master_check_crons_deadline(void);\nint uwsgi_master_check_spoolers_death(int);\nint uwsgi_master_check_emperor_death(int);\nint uwsgi_master_check_mules_death(int);\nint uwsgi_master_check_gateways_death(int);\nint uwsgi_master_check_daemons_death(int);\n\nvoid uwsgi_master_check_death(void);\nint uwsgi_master_check_reload(char **);\nvoid uwsgi_master_commit_status(void);\nvoid uwsgi_master_check_chain(void);\n\nvoid uwsgi_master_fix_request_counters(void);\nint uwsgi_master_manage_events(int);\n\nvoid uwsgi_block_signal(int);\nvoid uwsgi_unblock_signal(int);\n\nint uwsgi_worker_is_busy(int);\n\nvoid uwsgi_post_accept(struct wsgi_request *);\nvoid uwsgi_tcp_nodelay(int);\n\nstruct uwsgi_exception_handler_instance;\nstruct uwsgi_exception_handler {\n\tchar *name;\n\tint (*func)(struct uwsgi_exception_handler_instance *, char *, size_t);\n\tstruct uwsgi_exception_handler *next;\n};\n\nstruct uwsgi_exception_handler_instance {\n\tstruct uwsgi_exception_handler *handler;\n\tint configured;\n\tchar *arg;\n\tuint32_t custom32;\n\tuint64_t custom64;\n\tvoid *custom_ptr;\n};\n\nvoid uwsgi_exception_setup_handlers(void);\nstruct uwsgi_exception_handler *uwsgi_exception_handler_by_name(char *);\n\nvoid uwsgi_manage_exception(struct wsgi_request *, int);\nint uwsgi_exceptions_catch(struct wsgi_request *);\nuint64_t uwsgi_worker_exceptions(int);\nstruct uwsgi_exception_handler *uwsgi_register_exception_handler(char *, int (*)(struct uwsgi_exception_handler_instance *, char *, size_t));\n\nchar *proxy1_parse(char *ptr, char *watermark, char **src, uint16_t *src_len, char **dst, uint16_t *dst_len,  char **src_port, uint16_t *src_port_len, char **dst_port, uint16_t *dst_port_len);\nvoid uwsgi_async_queue_is_full(time_t);\nchar *uwsgi_get_header(struct wsgi_request *, char *, uint16_t, uint16_t *);\n\nvoid uwsgi_alarm_thread_start(void);\nvoid uwsgi_exceptions_handler_thread_start(void);\n\n#define uwsgi_response_add_connection_close(x) uwsgi_response_add_header(x, (char *)\"Connection\", 10, (char *)\"close\", 5)\n#define uwsgi_response_add_content_type(x, y, z) uwsgi_response_add_header(x, (char *)\"Content-Type\", 12, y, z)\n\nstruct uwsgi_stats_pusher_instance *uwsgi_stats_pusher_add(struct uwsgi_stats_pusher *, char *);\n\nint plugin_already_loaded(const char *);\nstruct uwsgi_plugin *uwsgi_plugin_get(const char *);\n\nstruct uwsgi_cache_magic_context {\n\tchar *cmd;\n\tuint16_t cmd_len;\n\tchar *key;\n\tuint16_t key_len;\n\tuint64_t size;\n\tuint64_t expires;\n\tchar *status;\n\tuint16_t status_len;\n\tchar *cache;\n\tuint16_t cache_len;\n};\n\nchar *uwsgi_cache_magic_get(char *, uint16_t, uint64_t *, uint64_t *, char *);\nint uwsgi_cache_magic_set(char *, uint16_t, char *, uint64_t, uint64_t, uint64_t, char *);\nint uwsgi_cache_magic_del(char *, uint16_t, char *);\nint uwsgi_cache_magic_exists(char *, uint16_t, char *);\nint uwsgi_cache_magic_clear(char *);\nvoid uwsgi_cache_magic_context_hook(char *, uint16_t, char *, uint16_t, void *);\n\nchar *uwsgi_legion_scrolls(char *, uint64_t *);\nint uwsgi_emperor_vassal_start(struct uwsgi_instance *);\n\n#ifdef UWSGI_ZLIB\n#include <zlib.h>\nint uwsgi_deflate_init(z_stream *, char *, size_t);\nint uwsgi_inflate_init(z_stream *, char *, size_t);\nchar *uwsgi_deflate(z_stream *, char *, size_t, size_t *);\nvoid uwsgi_crc32(uint32_t *, char *, size_t);\nstruct uwsgi_buffer *uwsgi_gzip(char *, size_t);\nstruct uwsgi_buffer *uwsgi_zlib_decompress(char *, size_t);\nint uwsgi_gzip_fix(z_stream *, uint32_t, struct uwsgi_buffer *, size_t);\nchar *uwsgi_gzip_chunk(z_stream *, uint32_t *, char *, size_t, size_t *);\nint uwsgi_gzip_prepare(z_stream *, char *, size_t, uint32_t *);\n#endif\n\nchar *uwsgi_get_cookie(struct wsgi_request *, char *, uint16_t, uint16_t *);\nchar *uwsgi_get_qs(struct wsgi_request *, char *, uint16_t, uint16_t *);\n\nstruct uwsgi_route_var *uwsgi_get_route_var(char *, uint16_t);\nstruct uwsgi_route_var *uwsgi_register_route_var(char *, char *(*)(struct wsgi_request *, char *, uint16_t, uint16_t *));\n\nchar *uwsgi_get_mime_type(char *, int, size_t *);\n\nvoid config_magic_table_fill(char *, char *[]);\n\nint uwsgi_blob_to_response(struct wsgi_request *, char *, size_t);\nstruct uwsgi_cron *uwsgi_cron_add(char *);\nint uwsgi_is_full_http(struct uwsgi_buffer *);\n\nint uwsgi_http_date(time_t t, char *);\n\nint uwsgi_apply_transformations(struct wsgi_request *wsgi_req, char *, size_t);\nint uwsgi_apply_final_transformations(struct wsgi_request *);\nvoid uwsgi_free_transformations(struct wsgi_request *);\nstruct uwsgi_transformation *uwsgi_add_transformation(struct wsgi_request *wsgi_req, int (*func)(struct wsgi_request *, struct uwsgi_transformation *), void *);\n\nvoid uwsgi_file_write_do(struct uwsgi_string_list *);\n\nint uwsgi_fd_is_safe(int);\nvoid uwsgi_add_safe_fd(int);\n\nvoid uwsgi_ipcsem_clear(void);\nchar *uwsgi_str_to_hex(char *, size_t);\n\n// this 3 functions have been added 1.9.10 to allow plugins take the control over processes\nvoid uwsgi_worker_run(void);\nvoid uwsgi_mule_run(void);\nvoid uwsgi_spooler_run(void);\nvoid uwsgi_takeover(void);\n\nchar *uwsgi_binary_path(void);\n\nint uwsgi_is_again();\nvoid uwsgi_disconnect(struct wsgi_request *);\nint uwsgi_ready_fd(struct wsgi_request *);\n\nvoid uwsgi_envdir(char *);\nvoid uwsgi_envdirs(struct uwsgi_string_list *);\nvoid uwsgi_opt_envdir(char *, char *, void *);\n\nvoid uwsgi_add_reload_fds();\n\nvoid uwsgi_check_emperor(void);\n#ifdef UWSGI_AS_SHARED_LIBRARY\nint uwsgi_init(int, char **, char **);\n#endif\n\nint uwsgi_master_check_cron_death(int);\nstruct uwsgi_fsmon *uwsgi_register_fsmon(char *, void (*)(struct uwsgi_fsmon *), void *data);\nint uwsgi_fsmon_event(int);\nvoid uwsgi_fsmon_setup();\n\nvoid uwsgi_exit(int) __attribute__ ((__noreturn__));\nvoid uwsgi_fallback_config();\n\nstruct uwsgi_cache_item *uwsgi_cache_keys(struct uwsgi_cache *, uint64_t *, struct uwsgi_cache_item **);\nvoid uwsgi_cache_rlock(struct uwsgi_cache *);\nvoid uwsgi_cache_rwunlock(struct uwsgi_cache *);\nchar *uwsgi_cache_item_key(struct uwsgi_cache_item *);\n\nchar *uwsgi_binsh(void);\nint uwsgi_file_executable(char *);\n\nint uwsgi_mount(char *, char *, char *, char *, char *);\nint uwsgi_umount(char *, char *);\nint uwsgi_mount_hook(char *);\nint uwsgi_umount_hook(char *);\n\nint uwsgi_hooks_run_and_return(struct uwsgi_string_list *, char *, char *, int);\nvoid uwsgi_hooks_run(struct uwsgi_string_list *, char *, int);\nvoid uwsgi_register_hook(char *, int (*)(char *));\nstruct uwsgi_hook *uwsgi_hook_by_name(char *);\nvoid uwsgi_register_base_hooks(void);\n\nvoid uwsgi_setup_log_encoders(void);\nvoid uwsgi_log_encoders_register_embedded(void);\n\nvoid uwsgi_register_log_encoder(char *, char *(*)(struct uwsgi_log_encoder *, char *, size_t, size_t *));\n\nint uwsgi_accept(int);\nvoid suspend_resume_them_all(int);\n\nvoid uwsgi_master_fifo_prepare();\nint uwsgi_master_fifo();\nint uwsgi_master_fifo_manage(int);\n\nvoid uwsgi_log_do_rotate(char *, char *, off_t, int);\nvoid uwsgi_log_rotate();\nvoid uwsgi_log_reopen();\nvoid uwsgi_reload_workers();\nvoid uwsgi_reload_mules();\nvoid uwsgi_reload_spoolers();\nvoid uwsgi_chain_reload();\nvoid uwsgi_refork_master();\nvoid uwsgi_update_pidfiles();\nvoid gracefully_kill_them_all(int);\nvoid uwsgi_brutally_reload_workers();\n\nvoid uwsgi_cheaper_increase();\nvoid uwsgi_cheaper_decrease();\nvoid uwsgi_go_cheap();\n\nchar **uwsgi_split_quoted(char *, size_t, char *, size_t *);\n\nvoid uwsgi_master_manage_emperor_proxy(int, int, int, int);\nstruct uwsgi_string_list *uwsgi_register_scheme(char *, char * (*)(char *, size_t *, int));\nvoid uwsgi_setup_schemes(void);\n\nstruct uwsgi_string_list *uwsgi_check_scheme(char *);\n\nvoid uwsgi_remap_fd(int, char *);\nvoid uwsgi_opt_exit(char *, char *, void *);\nint uwsgi_check_mountpoint(char *);\nvoid uwsgi_master_check_mountpoints(void);\n\nenum {\n\tUWSGI_METRIC_COUNTER,\n\tUWSGI_METRIC_GAUGE,\n\tUWSGI_METRIC_ABSOLUTE,\n\tUWSGI_METRIC_ALIAS,\n};\n\nstruct uwsgi_metric_child;\n\nstruct uwsgi_metric_collector {\n\tchar *name;\n\tint64_t (*func)(struct uwsgi_metric *);\n\tstruct uwsgi_metric_collector *next;\n};\n\nstruct uwsgi_metric_threshold {\n\tint64_t value;\n\tuint8_t reset;\n\tint64_t reset_value;\n\tint32_t rate;\n\tchar *alarm;\n\tchar *msg;\n\tsize_t msg_len;\n\ttime_t last_alarm;\n\tstruct uwsgi_metric_threshold *next;\n};\n\nstruct uwsgi_metric {\n        char *name;\n        char *oid;\n\n\tsize_t name_len;\n\tsize_t oid_len;\n\n        // pre-computed snmp representation\n        char *asn;\n        size_t asn_len;\n\n        // ABSOLUTE/COUNTER/GAUGE\n        uint8_t type;\n\n        // this could be taken from a file storage and must be always added to value by the collector (default 0)\n        int64_t initial_value;\n        // the value of the metric (point to a shared memory area)\n        int64_t *value;\n\n        // a custom blob you can attach to a metric\n        void *custom;\n\n        // the collection frequency\n        uint32_t freq;\n        time_t last_update;\n\n        // run this function to collect the value\n\tstruct uwsgi_metric_collector *collector;\t\n        // take the value from this pointer to a 64bit value\n        int64_t *ptr;\n        // get the initial value from this file, and store each update in it\n        char *filename;\n\n\t// pointer to memory mapped storage\n\tchar *map;\n\n\t// arguments for collectors\n\tchar *arg1;\n\tchar *arg2;\n\tchar *arg3;\n\n\tint64_t arg1n;\n\tint64_t arg2n;\n\tint64_t arg3n;\n\n\tstruct uwsgi_metric_child *children;\n\tstruct uwsgi_metric_threshold *thresholds;\n\n        struct uwsgi_metric *next;\n\n\t// allow to reset metrics after each push\n\tuint8_t reset_after_push;\n};\n\nstruct uwsgi_metric_child {\n\tstruct uwsgi_metric *um;\n\tstruct uwsgi_metric_child *next;\n};\n\nvoid uwsgi_setup_metrics(void);\nvoid uwsgi_metrics_start_collector(void);\n\nint uwsgi_metric_set(char *, char *, int64_t);\nint uwsgi_metric_inc(char *, char *, int64_t);\nint uwsgi_metric_dec(char *, char *, int64_t);\nint uwsgi_metric_mul(char *, char *, int64_t);\nint uwsgi_metric_div(char *, char *, int64_t);\nint64_t uwsgi_metric_get(char *, char *);\nint64_t uwsgi_metric_getn(char *, size_t, char *, size_t);\nint uwsgi_metric_set_max(char *, char *, int64_t);\nint uwsgi_metric_set_min(char *, char *, int64_t);\n\nstruct uwsgi_metric_collector *uwsgi_register_metric_collector(char *, int64_t (*)(struct uwsgi_metric *));\nstruct uwsgi_metric *uwsgi_register_metric(char *, char *, uint8_t, char *, void *, uint32_t, void *);\n\nvoid uwsgi_metrics_collectors_setup(void);\nstruct uwsgi_metric *uwsgi_metric_find_by_name(char *);\nstruct uwsgi_metric *uwsgi_metric_find_by_namen(char *, size_t);\nstruct uwsgi_metric_child *uwsgi_metric_add_child(struct uwsgi_metric *, struct uwsgi_metric *);\n\nstruct uwsgi_metric *uwsgi_metric_find_by_oid(char *);\nstruct uwsgi_metric *uwsgi_metric_find_by_oidn(char *, size_t);\nstruct uwsgi_metric *uwsgi_metric_find_by_asn(char *, size_t);\n\nint uwsgi_base128(struct uwsgi_buffer *, uint64_t, int);\n\nstruct wsgi_request *find_wsgi_req_proto_by_fd(int);\n\nstruct uwsgi_protocol *uwsgi_register_protocol(char *, void (*)(struct uwsgi_socket *));\n\nvoid uwsgi_protocols_register(void);\n\nvoid uwsgi_build_plugin(char *dir);\n\nvoid uwsgi_sharedareas_init();\n\nstruct uwsgi_sharedarea *uwsgi_sharedarea_init(int);\nstruct uwsgi_sharedarea *uwsgi_sharedarea_init_ptr(char *, uint64_t);\nstruct uwsgi_sharedarea *uwsgi_sharedarea_init_fd(int, uint64_t, off_t);\n\nint64_t uwsgi_sharedarea_read(int, uint64_t, char *, uint64_t);\nint uwsgi_sharedarea_write(int, uint64_t, char *, uint64_t);\nint uwsgi_sharedarea_read64(int, uint64_t, int64_t *);\nint uwsgi_sharedarea_write64(int, uint64_t, int64_t *);\nint uwsgi_sharedarea_read8(int, uint64_t, int8_t *);\nint uwsgi_sharedarea_write8(int, uint64_t, int8_t *);\nint uwsgi_sharedarea_read16(int, uint64_t, int16_t *);\nint uwsgi_sharedarea_write16(int, uint64_t, int16_t *);\nint uwsgi_sharedarea_read32(int, uint64_t, int32_t *);\nint uwsgi_sharedarea_write32(int, uint64_t, int32_t *);\nint uwsgi_sharedarea_inc8(int, uint64_t, int8_t);\nint uwsgi_sharedarea_inc16(int, uint64_t, int16_t);\nint uwsgi_sharedarea_inc32(int, uint64_t, int32_t);\nint uwsgi_sharedarea_inc64(int, uint64_t, int64_t);\nint uwsgi_sharedarea_dec8(int, uint64_t, int8_t);\nint uwsgi_sharedarea_dec16(int, uint64_t, int16_t);\nint uwsgi_sharedarea_dec32(int, uint64_t, int32_t);\nint uwsgi_sharedarea_dec64(int, uint64_t, int64_t);\nint uwsgi_sharedarea_wait(int, int, int);\nint uwsgi_sharedarea_unlock(int);\nint uwsgi_sharedarea_rlock(int);\nint uwsgi_sharedarea_wlock(int);\nint uwsgi_sharedarea_update(int);\n\nstruct uwsgi_sharedarea *uwsgi_sharedarea_get_by_id(int, uint64_t);\nint uwsgi_websocket_send_from_sharedarea(struct wsgi_request *, int, uint64_t, uint64_t);\nint uwsgi_websocket_send_binary_from_sharedarea(struct wsgi_request *, int, uint64_t, uint64_t);\n\nvoid uwsgi_register_logchunks(void);\n\nvoid uwsgi_setup(int, char **, char **);\nint uwsgi_run(void);\n\nint uwsgi_is_connected(int);\nint uwsgi_pass_cred(int, char *, size_t);\nint uwsgi_pass_cred2(int, char *, size_t, struct sockaddr *, size_t);\nint uwsgi_recv_cred(int, char *, size_t, pid_t *, uid_t *, gid_t *);\nssize_t uwsgi_recv_cred2(int, char *, size_t, pid_t *, uid_t *, gid_t *);\nint uwsgi_socket_passcred(int);\nint uwsgi_socket_from_addr(union uwsgi_sockaddr *, socklen_t *, char *, int);\n\nvoid uwsgi_dump_worker(int, char *);\nmode_t uwsgi_mode_t(char *, int *);\n\nint uwsgi_notify_socket_manage(int);\nint uwsgi_notify_msg(char *, char *, size_t);\nvoid vassal_sos();\n\nint uwsgi_send_fds_and_body(int, int *, int, char *, size_t);\nssize_t uwsgi_recv_cred_and_fds(int, char *, size_t buf_len, pid_t *, uid_t *, gid_t *, int *, int *);\nvoid uwsgi_fork_server(char *);\n\nvoid uwsgi_emperor_ini_attrs(char *, char *, struct uwsgi_dyn_dict **);\n\nint uwsgi_buffer_httpdate(struct uwsgi_buffer *, time_t);\nint uwsgi_buffer_append_xml(struct uwsgi_buffer *, char *, size_t);\n\nstruct uwsgi_buffer *uwsgi_webdav_multistatus_new();\nint uwsgi_webdav_propfind_item_add(struct uwsgi_buffer *, char *, uint16_t, uint64_t, time_t, char *, uint16_t, char *, uint16_t, char *, uint16_t);\nint uwsgi_webdav_multistatus_close(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_response_new(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_response_close(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_propstat_new(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_propstat_close(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_prop_new(struct uwsgi_buffer *);\nint uwsgi_webdav_multistatus_prop_close(struct uwsgi_buffer *);\n\nstruct uwsgi_subscribe_node *(*uwsgi_subscription_algo_get(char * , size_t))(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);\n\nvoid uwsgi_subscription_init_algos(void);\nvoid uwsgi_register_subscription_algo(char *, struct uwsgi_subscribe_node *(*) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *));\nchar *uwsgi_subscription_algo_name(void *);\n\nint uwsgi_wait_for_fs(char *, int);\nint uwsgi_wait_for_mountpoint(char *);\nint uwsgi_wait_for_socket(char *);\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\nvoid uwsgi_hooks_setns_run(struct uwsgi_string_list *, pid_t, uid_t, gid_t);\n#endif\n\nchar *vassal_attr_get(struct uwsgi_instance *, char *);\nint vassal_attr_get_multi(struct uwsgi_instance *, char *, int (*)(struct uwsgi_instance *, char *, void *), void *);\n\nint uwsgi_zeus_spawn_instance(struct uwsgi_instance *);\n\ntime_t uwsgi_parse_http_date(char *, uint16_t);\nvoid uwsgi_spooler_cheap_check(void);\nchar* uwsgi_getenv_with_default(const char* key);\n\n#define FCGI_BEGIN_REQUEST       1\n#define FCGI_ABORT_REQUEST       2\n#define FCGI_END_REQUEST         3\n#define FCGI_PARAMS              4\n#define FCGI_STDIN               5\n#define FCGI_STDOUT              6\n#define FCGI_STDERR              7\n#define FCGI_DATA                8\n#define FCGI_GET_VALUES          9\n#define FCGI_GET_VALUES_RESULT  10\n\n#define FCGI_KEEP_CONN  \t 1\n\n#define FCGI_RESPONDER  \t 1\n#define FCGI_AUTHORIZER \t 2\n#define FCGI_FILTER     \t 3\n\n#define FCGI_REQUEST_COMPLETE \t 0\n#define FCGI_CANT_MPX_CONN    \t 1\n#define FCGI_OVERLOADED       \t 2\n#define FCGI_UNKNOWN_ROLE     \t 3\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "uwsgi_main.c",
          "type": "blob",
          "size": 0.130859375,
          "content": "int uwsgi_init(int, char **, char **);\n\nint main(int argc, char *argv[], char **environ) {\n\treturn uwsgi_init(argc, argv, environ);\n}\n"
        },
        {
          "name": "uwsgiconfig.py",
          "type": "blob",
          "size": 62.61328125,
          "content": "# uWSGI build system\n\nuwsgi_version = '2.1-dev'\n\nimport os\nimport re\nimport time\nuwsgi_os = os.environ.get('UWSGI_FORCE_OS', os.uname()[0])\nuwsgi_os_k = re.split('[-+_]', os.uname()[2])[0]\nuwsgi_os_v = os.uname()[3]\nuwsgi_cpu = os.uname()[4]\n\nimport sys\nimport subprocess\nimport sysconfig\nfrom threading import Thread, Lock\nfrom optparse import OptionParser\n\ntry:\n    from queue import Queue\nexcept ImportError:\n    from Queue import Queue\n\ntry:\n    import ConfigParser\nexcept ImportError:\n    import configparser as ConfigParser\n\ntry:\n    from shlex import quote\nexcept ImportError:\n    from pipes import quote\n\nPY3 = sys.version_info[0] == 3\n\nif uwsgi_os == 'Darwin':\n    GCC = os.environ.get('CC', 'clang')\nelse:\n    GCC = os.environ.get('CC', sysconfig.get_config_var('CC'))\n    if not GCC:\n        GCC = 'gcc'\n\ndef get_preprocessor():\n    if 'clang' in GCC:\n        return 'clang -xc core/clang_fake.c'\n    return 'cpp'\n\nCPP = os.environ.get('CPP', get_preprocessor())\n\ntry:\n    CPUCOUNT = int(os.environ.get('CPUCOUNT', -1))\nexcept ValueError:\n    CPUCOUNT = -1\n\nif CPUCOUNT < 1:\n    try:\n        import multiprocessing\n        CPUCOUNT = multiprocessing.cpu_count()\n    except (ImportError, NotImplementedError):\n        try:\n            CPUCOUNT = os.sysconf('SC_NPROCESSORS_ONLN')\n        # AttributeError means os.syconf function is not available and\n        # ValueError means the name passed to it is not supported\n        except (AttributeError, ValueError):\n            CPUCOUNT = 1\n\n\n# force single cpu in cygwin mode\nif uwsgi_os.startswith('CYGWIN'):\n    CPUCOUNT = 1\n\nbinary_list = []\n\nstarted_at = time.time()\n\n# this is used for reporting (at the end of the build)\n# the server configuration\nreport = {\n    'kernel': False,\n    'execinfo': False,\n    'ifaddrs': False,\n    'locking': False,\n    'event': False,\n    'timer': False,\n    'filemonitor': False,\n    'pcre': False,\n    'routing': False,\n    'capabilities': False,\n    'yaml': False,\n    'json': False,\n    'ssl': False,\n    'xml': False,\n    'debug': False,\n    'plugin_dir': False,\n    'zlib': False,\n    'ucontext': False,\n}\n\nverbose_build = False\n\n\ndef print_compilation_output(default_str, verbose_str):\n    if verbose_build:\n        print(verbose_str)\n    elif default_str is not None:\n        print(default_str)\n\ncompile_queue = None\nprint_lock = None\nthread_compilers = []\n\n\ndef thread_compiler(num):\n    while True:\n        (objfile, cmdline) = compile_queue.get()\n        if objfile:\n            print_lock.acquire()\n            print_compilation_output(\"[thread %d][%s] %s\" % (num, GCC, objfile), \"[thread %d] %s\" % (num, cmdline))\n            print_lock.release()\n            ret = subprocess.call(cmdline, shell=True)\n            if ret != 0:\n                os._exit(1)\n        elif cmdline:\n            print_lock.acquire()\n            print(cmdline)\n            print_lock.release()\n        else:\n            return\n\n\ndef binarize(name):\n    return name.replace('/', '_').replace('.', '_').replace('-', '_')\n\n\ndef strip_prefix(prefix, string):\n    if string.startswith(prefix):\n        return string[len(prefix):]\n    return string\n\n\ndef spcall(cmd):\n    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=open('uwsgibuild.log', 'w'))\n\n    if p.wait() == 0:\n        if sys.version_info[0] > 2:\n            return p.stdout.read().rstrip().decode()\n        return p.stdout.read().rstrip()\n    else:\n        return None\n\n\n# commodity function to remove -W* duplicates\ndef uniq_warnings(elements):\n    new_elements = []\n    for element in elements:\n        if element.startswith('-W'):\n            if element not in new_elements:\n                new_elements.append(element)\n        else:\n            new_elements.append(element)\n\n    return new_elements\n\nif uwsgi_version.endswith('-dev') and os.path.exists('%s/.git' % os.path.dirname(os.path.abspath(__file__))):\n    try:\n        uwsgi_version += '+%s' % spcall('git rev-parse --short HEAD')\n    except Exception:\n        pass\n\n\ndef spcall2(cmd):\n    p = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE)\n\n    if p.wait() == 0:\n        if sys.version_info[0] > 2:\n            return p.stderr.read().rstrip().decode()\n        return p.stderr.read().rstrip()\n    else:\n        return None\n\n\ndef test_snippet(snippet, CFLAGS=[], LDFLAGS=[], LIBS=[]):\n    \"\"\"Compile a C snippet to see if features are available at build / link time.\"\"\"\n    cflags = \" \".join(CFLAGS)\n    ldflags = \" \".join(LDFLAGS)\n    libs = \" \".join(LIBS)\n    if sys.version_info[0] >= 3 or (sys.version_info[0] == 2 and sys.version_info[1] > 5):\n        if not isinstance(snippet, bytes):\n            if PY3:\n                snippet = bytes(snippet, sys.getdefaultencoding())\n            else:\n                snippet = bytes(snippet)\n        cmd = \"{0} {1} -xc - {2} {3} -o /dev/null\".format(GCC, cflags, ldflags, libs)\n    else:\n        cmd = \" \".join([GCC, cflags, \"-xc -\", ldflags, libs, \"-o /dev/null\"])\n    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    p.communicate(snippet)\n    return p.returncode == 0\n\n\ndef has_usable_ucontext():\n    if uwsgi_os in ('OpenBSD', 'Haiku'):\n        return False\n    if uwsgi_os.startswith('CYGWIN'):\n        return False\n    if uwsgi_os == 'Darwin' and uwsgi_os_k.startswith('8'):\n        return False\n    if uwsgi_cpu[0:3] == 'arm':\n        return False\n    # check for ucontext.h functions definitions, musl has only declarations\n    return test_snippet(\"\"\"#include <ucontext.h>\nint main()\n{\n\tucontext_t uc;\n\tgetcontext(&uc);\n\treturn 0;\n}\"\"\")\n\n\ndef spcall3(cmd):\n    p = subprocess.Popen(cmd, shell=True, stdin=open('/dev/null'), stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    (out, err) = p.communicate()\n\n    if p.returncode == 0:\n        if sys.version_info[0] > 2:\n            return err.rstrip().decode()\n        return err.rstrip()\n    else:\n        return None\n\n\ndef add_o(x):\n    if x == 'uwsgi':\n        x = 'main'\n    elif x.endswith('.a') or x.endswith('.o') or x.startswith('-'):\n        return x\n    x = x + '.o'\n    return x\n\n\ndef push_print(msg):\n    if not compile_queue:\n        print(msg)\n    else:\n        compile_queue.put((None, msg))\n\n\ndef push_command(objfile, cmdline):\n    if not compile_queue:\n        print_compilation_output(\"[%s] %s\" % (GCC, objfile), cmdline)\n        ret = subprocess.call(cmdline, shell=True)\n        if ret != 0:\n            sys.exit(1)\n    else:\n        compile_queue.put((objfile, cmdline))\n\n\ndef uwsgi_compile(cflags, last_cflags_ts, objfile, srcfile):\n    source_stat = os.stat(srcfile)\n    header_stat = os.stat('uwsgi.h')\n    try:\n        if os.environ.get('UWSGI_FORCE_REBUILD', None):\n            raise\n        if source_stat[8] >= last_cflags_ts:\n            raise\n        if header_stat[8] >= last_cflags_ts:\n            raise\n        object_stat = os.stat(objfile)\n        if object_stat[8] <= source_stat[8]:\n            raise\n        if object_stat[8] <= header_stat[8]:\n            raise\n        for profile in os.listdir('buildconf'):\n            profile_stat = os.stat('buildconf/%s' % profile)\n            if object_stat[8] <= profile_stat[8]:\n                raise\n        print(\"%s is up to date\" % objfile)\n        return\n    except Exception:\n        pass\n    cmdline = \"%s -c %s -o %s %s\" % (GCC, cflags, objfile, srcfile)\n    push_command(objfile, cmdline)\n\n\ndef build_uwsgi(uc, print_only=False, gcll=None):\n\n    global print_lock, compile_queue, thread_compilers\n\n    if CPUCOUNT > 1:\n        print_lock = Lock()\n        compile_queue = Queue(maxsize=CPUCOUNT)\n        for i in range(0, CPUCOUNT):\n            t = Thread(target=thread_compiler, args=(i,))\n            t.daemon = True\n            t.start()\n            thread_compilers.append(t)\n\n    if not gcll:\n        gcc_list, cflags, ldflags, libs = uc.get_gcll()\n    else:\n        gcc_list, cflags, ldflags, libs = gcll\n\n    if 'UWSGI_EMBED_PLUGINS' in os.environ:\n        ep = uc.get('embedded_plugins')\n        if ep:\n            uc.set('embedded_plugins', ep + ',' + os.environ['UWSGI_EMBED_PLUGINS'])\n        else:\n            uc.set('embedded_plugins', os.environ['UWSGI_EMBED_PLUGINS'])\n\n    if uc.get('embedded_plugins'):\n        ep = uc.get('embedded_plugins').split(',')\n        epc = \"-DUWSGI_DECLARE_EMBEDDED_PLUGINS=\\\"\"\n        eplc = \"-DUWSGI_LOAD_EMBEDDED_PLUGINS=\\\"\"\n        for item in ep:\n            # allow name=path syntax\n            kv = item.split('=')\n            p = kv[0]\n            p = p.strip()\n            if not p or p == 'None':\n                continue\n            if p == 'ugreen':\n                if not report['ucontext']:\n                    continue\n            epc += \"UDEP(%s);\" % p\n            eplc += \"ULEP(%s);\" % p\n        epc += \"\\\"\"\n        eplc += \"\\\"\"\n\n        cflags.append(epc)\n        cflags.append(eplc)\n\n    if print_only:\n        print(' '.join(cflags))\n        sys.exit(0)\n\n    if 'APPEND_CFLAGS' in os.environ:\n        cflags += os.environ['APPEND_CFLAGS'].split()\n\n    print(\"detected CPU cores: %d\" % CPUCOUNT)\n    print(\"configured CFLAGS: %s\" % ' '.join(cflags))\n\n    if sys.version_info[0] >= 3:\n        import binascii\n        uwsgi_cflags = binascii.b2a_hex(' '.join(cflags).encode('ascii')).decode('ascii')\n    else:\n        uwsgi_cflags = ' '.join(cflags).encode('hex')\n\n    last_cflags_ts = 0\n\n    if os.path.exists('uwsgibuild.lastcflags'):\n        ulc = open('uwsgibuild.lastcflags')\n        last_cflags = ulc.read()\n        ulc.close()\n        if uwsgi_cflags != last_cflags:\n            os.environ['UWSGI_FORCE_REBUILD'] = '1'\n        else:\n            last_cflags_ts = os.stat('uwsgibuild.lastcflags')[8]\n\n    ulc = open('uwsgibuild.lastcflags', 'w')\n    ulc.write(uwsgi_cflags)\n    ulc.close()\n\n    # embed uwsgi.h in the server binary. It increases the binary size, but will be very useful\n    # for various tricks (like cffi integration)\n    # if possible, the blob is compressed\n    if sys.version_info[0] >= 3:\n        uwsgi_dot_h_content = open('uwsgi.h', 'rb').read()\n    else:\n        uwsgi_dot_h_content = open('uwsgi.h').read()\n    if report['zlib']:\n        import zlib\n        # maximum level of compression\n        uwsgi_dot_h_content = zlib.compress(uwsgi_dot_h_content, 9)\n    if sys.version_info[0] >= 3:\n        import binascii\n        uwsgi_dot_h = binascii.b2a_hex(uwsgi_dot_h_content).decode('ascii')\n    else:\n        uwsgi_dot_h = uwsgi_dot_h_content.encode('hex')\n    open('core/dot_h.c', 'w').write('char *uwsgi_dot_h = \"%s\";\\n' % uwsgi_dot_h)\n    gcc_list.append('core/dot_h')\n\n    # embed uwsgiconfig.py in the server binary. It increases the binary size, but will be very useful\n    # if possible, the blob is compressed\n    if sys.version_info[0] >= 3:\n        uwsgi_config_py_content = open('uwsgiconfig.py', 'rb').read()\n    else:\n        uwsgi_config_py_content = open('uwsgiconfig.py').read()\n    if report['zlib']:\n        import zlib\n        # maximum level of compression\n        uwsgi_config_py_content = zlib.compress(uwsgi_config_py_content, 9)\n    if sys.version_info[0] >= 3:\n        import binascii\n        uwsgi_config_py = binascii.b2a_hex(uwsgi_config_py_content).decode('ascii')\n    else:\n        uwsgi_config_py = uwsgi_config_py_content.encode('hex')\n    open('core/config_py.c', 'w').write('char *uwsgi_config_py = \"%s\";\\n' % uwsgi_config_py)\n    gcc_list.append('core/config_py')\n\n    additional_sources = os.environ.get('UWSGI_ADDITIONAL_SOURCES')\n    if not additional_sources:\n        additional_sources = uc.get('additional_sources')\n    if additional_sources:\n        for item in additional_sources.split(','):\n            gcc_list.append(item)\n\n    if uc.filename.endswith('coverity.ini'):\n        cflags.append('-DUWSGI_CFLAGS=\\\\\"\\\\\"')\n    else:\n        cflags.append('-DUWSGI_CFLAGS=\\\\\"%s\\\\\"' % uwsgi_cflags)\n    build_date = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))\n    cflags.append('-DUWSGI_BUILD_DATE=\"\\\\\"%s\\\\\"\"' % time.strftime(\"%d %B %Y %H:%M:%S\", time.gmtime(build_date)))\n\n    post_build = []\n\n    push_print(\"*** uWSGI compiling server core ***\")\n    for file in gcc_list:\n        objfile = file\n        if objfile == 'uwsgi':\n            objfile = 'main'\n        if not objfile.endswith('.a') and not objfile.endswith('.o'):\n            if objfile.endswith('.c') or objfile.endswith('.cc') or objfile.endswith('.m') or objfile.endswith('.go'):\n                if objfile.endswith('.go'):\n                    cflags.append('-Wno-error')\n                uwsgi_compile(' '.join(cflags), last_cflags_ts, objfile + '.o', file)\n                if objfile.endswith('.go'):\n                    cflags.pop()\n            else:\n                if objfile == 'core/dot_h':\n                    cflags.append('-g')\n                uwsgi_compile(' '.join(cflags), last_cflags_ts, objfile + '.o', file + '.c')\n                if objfile == 'core/dot_h':\n                    cflags.pop()\n\n    if uc.get('embedded_plugins'):\n        ep = uc.get('embedded_plugins').split(',')\n\n        if len(ep) > 0:\n            push_print(\"*** uWSGI compiling embedded plugins ***\")\n            for item in ep:\n                # allows name=path syntax\n                kv = item.split('=')\n                if len(kv) > 1:\n                    p = kv[1]\n                    p = p.strip()\n                    if is_remote_plugin(p):\n                        p = get_remote_plugin(p)\n                    path = os.path.abspath(p)\n                else:\n                    p = kv[0]\n                    p = p.strip()\n                    path = 'plugins/%s' % p\n\n                if not p or p == 'None':\n                    continue\n\n                if p == 'ugreen':\n                    if not report['ucontext']:\n                        continue\n\n                path = path.rstrip('/')\n                path, up = get_plugin_up(path)\n\n                p_cflags = cflags[:]\n                p_cflags += up['CFLAGS']\n\n                if uwsgi_os.startswith('CYGWIN'):\n                    try:\n                        p_cflags.remove('-fstack-protector')\n                    except ValueError:\n                        pass\n\n                if GCC in ('clang',):\n                    try:\n                        p_cflags.remove('-fno-fast-math')\n                        p_cflags.remove('-ggdb3')\n                    except ValueError:\n                        pass\n\n                p_cflags_blacklist = (\n                    '-Wdeclaration-after-statement',\n                    '-Werror=declaration-after-statement',\n                    '-Wwrite-strings',\n                    '-Werror=write-strings',\n                )\n                for cflag in p_cflags_blacklist:\n                    try:\n                        p_cflags.remove(cflag)\n                    except ValueError:\n                        pass\n\n                try:\n                    if up['post_build']:\n                        post_build.append(up['post_build'])\n                except Exception:\n                    pass\n\n                for cfile in up['GCC_LIST']:\n                    if cfile.endswith('.a'):\n                        gcc_list.append(cfile)\n                    elif cfile.endswith('.o'):\n                        gcc_list.append('%s/%s' % (path, cfile))\n                    elif not cfile.endswith('.c') and not cfile.endswith('.cc') and not cfile.endswith('.go') and not cfile.endswith('.m'):\n                        uwsgi_compile(' '.join(uniq_warnings(p_cflags)), last_cflags_ts,\n                                path + '/' + cfile + '.o', path + '/' + cfile + '.c')\n                        gcc_list.append('%s/%s' % (path, cfile))\n                    else:\n                        if cfile.endswith('.go'):\n                            p_cflags.append('-Wno-error')\n                        uwsgi_compile(' '.join(uniq_warnings(p_cflags)), last_cflags_ts,\n                                path + '/' + cfile + '.o', path + '/' + cfile)\n                        gcc_list.append('%s/%s' % (path, cfile))\n                for bfile in up.get('BINARY_LIST', []):\n                    try:\n                        binary_link_cmd = \"ld -r -b binary -o %s/%s.o %s/%s\" % (path, bfile[1], path, bfile[1])\n                        print(binary_link_cmd)\n                        if subprocess.call(binary_link_cmd, shell=True) != 0:\n                            raise Exception('unable to link binary file')\n                        for kind in ('start', 'end'):\n                            objcopy_cmd = \"objcopy --redefine-sym _binary_%s_%s=%s_%s %s/%s.o\" % (binarize('%s/%s' % (path, bfile[1])), kind, bfile[0], kind, path, bfile[1])\n                            print(objcopy_cmd)\n                            if subprocess.call(objcopy_cmd, shell=True) != 0:\n                                raise Exception('unable to link binary file')\n                        gcc_list.append('%s/%s.o' % (path, bfile[1]))\n                    except Exception:\n                        if uwsgi_os == 'Darwin':\n                            gcc_list.append('-sectcreate __DATA %s %s/%s' % (strip_prefix('_uwsgi_', bfile[0]), path, bfile[1]))\n\n                libs += up['LIBS']\n\n                if uwsgi_os == 'Darwin':\n                    found_arch = False\n                    sanitized_ldflags = []\n                    for flag in up['LDFLAGS']:\n                        if flag == '-arch':\n                            found_arch = True\n                            continue\n                        if found_arch:\n                            found_arch = False\n                            continue\n                        sanitized_ldflags.append(flag)\n                    ldflags += sanitized_ldflags\n                else:\n                    ldflags += up['LDFLAGS']\n\n    if uc.get('plugins'):\n\n        plugins = uc.get('plugins').split(',')\n        if len(plugins) > 0:\n            push_print(\"*** uWSGI building plugins ***\")\n\n            for p in plugins:\n                p = p.strip()\n                push_print(\"*** building plugin: %s ***\" % p)\n                build_plugin(\"plugins/%s\" % p, uc, cflags, ldflags, libs)\n\n    bin_name = os.environ.get('UWSGI_BIN_NAME', uc.get('bin_name'))\n\n    if uc.embed_config:\n        gcc_list.append(\"%s.o\" % binarize(uc.embed_config))\n    for ef in binary_list:\n        gcc_list.append(\"%s.o\" % ef)\n\n    if compile_queue:\n        for t in thread_compilers:\n            compile_queue.put((None, None))\n        for t in thread_compilers:\n            t.join()\n\n    print(\"*** uWSGI linking ***\")\n    if '--static' in ldflags:\n        ldline = 'ar cru %s %s' % (\n            quote(bin_name),\n            ' '.join(map(add_o, gcc_list))\n        )\n    else:\n        ldline = \"%s -o %s %s %s %s\" % (\n            GCC,\n            quote(bin_name),\n            ' '.join(uniq_warnings(ldflags)),\n            ' '.join(map(add_o, gcc_list)),\n            ' '.join(uniq_warnings(libs))\n        )\n    print(ldline)\n    ret = subprocess.call(ldline, shell=True)\n    if ret != 0:\n        print(\"*** error linking uWSGI ***\")\n        sys.exit(1)\n\n    print(\"################# uWSGI configuration #################\")\n    print(\"\")\n    for report_key in report:\n        print(\"%s = %s\" % (report_key, report[report_key]))\n    print(\"\")\n    print(\"############## end of uWSGI configuration #############\")\n\n    print(\"total build time: %d seconds\" % (time.time() - started_at))\n\n    if bin_name.find(\"/\") < 0:\n        bin_name = './' + bin_name\n    if uc.get('as_shared_library'):\n        print(\"*** uWSGI shared library (%s) is ready, move it to a library directory ***\" % bin_name)\n    else:\n        print(\"*** uWSGI is ready, launch it with %s ***\" % bin_name)\n\n    for pb in post_build:\n        pb(uc)\n\n\ndef open_profile(filename):\n    if filename.startswith('http://') or filename.startswith('https://') or filename.startswith('ftp://'):\n        wrapped = False\n        try:\n            import urllib2\n        except ImportError:\n            import urllib.request\n            wrapped = True\n\n        if wrapped:\n            import io\n            return io.TextIOWrapper(urllib.request.urlopen(filename), encoding='utf-8')\n        return urllib2.urlopen(filename)\n    return open(filename)\n\n\nclass uConf(object):\n\n    def __init__(self, filename, mute=False):\n        global GCC\n\n        self.filename = filename\n        self.config = ConfigParser.ConfigParser()\n        if not mute:\n            print(\"using profile: %s\" % filename)\n\n        if os.path.exists('uwsgibuild.lastprofile'):\n            ulp = open('uwsgibuild.lastprofile')\n            last_profile = ulp.read()\n            ulp.close()\n            if last_profile != filename:\n                os.environ['UWSGI_FORCE_REBUILD'] = '1'\n\n        ulp = open('uwsgibuild.lastprofile', 'w')\n        ulp.write(filename)\n        ulp.close()\n\n        if hasattr(self.config, 'read_file'):\n            self.config.read_file(open_profile(filename))\n        else:\n            self.config.readfp(open_profile(filename))\n        self.gcc_list = [\n            'core/utils', 'core/protocol', 'core/socket', 'core/logging',\n            'core/master', 'core/master_utils', 'core/emperor', 'core/notify',\n            'core/mule', 'core/subscription', 'core/stats', 'core/sendfile',\n            'core/async', 'core/master_checks', 'core/fifo', 'core/offload',\n            'core/io', 'core/static', 'core/websockets', 'core/spooler',\n            'core/snmp', 'core/exceptions', 'core/config', 'core/setup_utils',\n            'core/clock', 'core/init', 'core/buffer', 'core/reader',\n            'core/writer', 'core/alarm', 'core/cron', 'core/hooks',\n            'core/plugins', 'core/lock', 'core/cache', 'core/daemons',\n            'core/errors', 'core/hash', 'core/master_events', 'core/chunked',\n            'core/queue', 'core/event', 'core/signal', 'core/strings',\n            'core/progress', 'core/timebomb', 'core/ini', 'core/fsmon',\n            'core/mount', 'core/metrics', 'core/plugins_builder',\n            'core/sharedarea', 'core/fork_server', 'core/webdav', 'core/zeus',\n            'core/rpc', 'core/gateway', 'core/loop', 'core/cookie',\n            'core/querystring', 'core/rb_timers', 'core/transformations',\n            'core/uwsgi',\n        ]\n        # add protocols\n        self.gcc_list.append('proto/base')\n        self.gcc_list.append('proto/uwsgi')\n        self.gcc_list.append('proto/http')\n        self.gcc_list.append('proto/fastcgi')\n        self.gcc_list.append('proto/scgi')\n        self.gcc_list.append('proto/puwsgi')\n        self.include_path = []\n\n        if 'UWSGI_INCLUDES' in os.environ:\n            self.include_path += os.environ['UWSGI_INCLUDES'].split(',')\n\n        cflags = [\n            '-O2',\n            '-I.',\n            '-Wall',\n            '-Werror',\n            '-Wno-error=deprecated-declarations',\n            '-D_LARGEFILE_SOURCE',\n            '-D_FILE_OFFSET_BITS=64'\n        ]\n        self.cflags = cflags + os.environ.get(\"CFLAGS\", \"\").split() + self.get('cflags', '').split()\n\n        python_venv_include = os.path.join(sys.prefix, 'include', 'site',\n                                           'python{0}.{1}'.format(*sys.version_info))\n\n        if os.path.isdir(python_venv_include):\n            self.cflags += ['-I' + python_venv_include]\n\n        report['kernel'] = uwsgi_os\n\n        if uwsgi_os == 'Linux':\n            if uwsgi_cpu != 'ia64':\n                self.gcc_list.append('lib/linux_ns')\n            try:\n                lk_ver = uwsgi_os_k.split('.')\n                if int(lk_ver[0]) <= 2 and int(lk_ver[1]) <= 6 and int(lk_ver[2]) <= 9:\n                    self.cflags.append('-DOBSOLETE_LINUX_KERNEL')\n                    report['kernel'] = 'Old Linux'\n            except Exception:\n                pass\n\n        if uwsgi_os == 'GNU':\n            self.cflags.append('-D__HURD__')\n\n        gcc_version = spcall(\"%s -dumpfullversion -dumpversion\" % GCC)\n        if not gcc_version and GCC.startswith('gcc'):\n            if uwsgi_os == 'Darwin':\n                GCC = 'llvm-' + GCC\n            else:\n                GCC = 'gcc'\n            gcc_version = spcall(\"%s -dumpfullversion -dumpversion\" % GCC)\n\n        try:\n            add_it = False\n            cpp_include_list = str(spcall3(\"%s -v\" % CPP)).split(\"\\n\")\n            for line in cpp_include_list:\n                if line.startswith('#include <...> search starts here:'):\n                    add_it = True\n                elif line.startswith('End of search list.'):\n                    add_it = False\n                elif add_it:\n                    self.include_path.append(line.strip().split()[0])\n\n            if not self.include_path:\n                raise\n        except Exception:\n            self.include_path = ['/usr/include', '/usr/local/include']\n\n        additional_include_paths = self.get('additional_include_paths')\n        if additional_include_paths:\n            for ipath in additional_include_paths.split():\n                self.include_path.append(ipath)\n\n        if 'UWSGI_REMOVE_INCLUDES' in os.environ:\n            for inc in os.environ['UWSGI_REMOVE_INCLUDES'].split(','):\n                try:\n                    self.include_path.remove(inc)\n                except ValueError:\n                    pass\n\n        if not mute:\n            print(\"detected include path: %s\" % self.include_path)\n\n        try:\n            gcc_version_components = gcc_version.split('.')\n            gcc_major = int(gcc_version_components[0])\n            if len(gcc_version_components) > 1:\n                gcc_minor = int(gcc_version_components[1])\n            else:\n                # gcc 5.0 is represented as simply \"5\"\n                gcc_minor = 0\n        except Exception:\n            raise Exception(\"you need a C compiler to build uWSGI\")\n        # add -fno-strict-aliasing only on python2 and gcc < 4.3\n        if (sys.version_info[0] == 2) or (gcc_major < 4) or (gcc_major == 4 and gcc_minor < 3):\n            self.cflags += ['-fno-strict-aliasing']\n        if gcc_major >= 4:\n            self.cflags += ['-Wextra', '-Wno-unused-parameter', '-Wno-missing-field-initializers']\n        if gcc_major == 4 and gcc_minor < 9:\n            self.cflags.append('-Wno-format -Wno-format-security')\n        if \"gcc\" in GCC and gcc_major >= 5:\n            self.cflags.append('-Wformat-signedness')\n\n        self.ldflags = os.environ.get(\"LDFLAGS\", \"\").split()\n        self.libs = ['-lpthread', '-lm', '-rdynamic']\n        if uwsgi_os in ('Linux', 'GNU', 'GNU/kFreeBSD'):\n            self.libs.append('-ldl')\n        if uwsgi_os == 'GNU/kFreeBSD':\n            self.cflags.append('-D__GNU_kFreeBSD__')\n            self.libs.append('-lbsd')\n\n        # check for inherit option\n        inherit = self.get('inherit')\n        if inherit:\n            if '/' not in inherit:\n                inherit = 'buildconf/%s' % inherit\n\n            if not inherit.endswith('.ini'):\n                inherit = '%s.ini' % inherit\n\n            interpolations = {}\n            for option in self.config.options('uwsgi'):\n                interpolations[option] = self.get(option, default='')\n            iconfig = ConfigParser.ConfigParser(interpolations)\n            if hasattr(self.config, 'read_file'):\n                iconfig.read_file(open_profile(inherit))\n            else:\n                iconfig.readfp(open_profile(inherit))\n\n            for opt in iconfig.options('uwsgi'):\n                if not self.config.has_option('uwsgi', opt):\n                    self.set(opt, iconfig.get('uwsgi', opt))\n                elif self.get(opt):\n                    if self.get(opt).startswith('+'):\n                        self.set(opt, iconfig.get('uwsgi', opt) + self.get(opt)[1:])\n                    elif self.get(opt) == 'null':\n                        self.config.remove_option('uwsgi', opt)\n\n    def set(self, key, value):\n        self.config.set('uwsgi', key, value)\n\n    def get(self, key, default=None):\n        try:\n            value = self.config.get('uwsgi', key)\n            if value == \"\" or value == \"false\":\n                return default\n            return value\n        except Exception:\n            if default is not None:\n                return default\n            return None\n\n    def depends_on(self, what, dep):\n        for d in dep:\n            if not self.get(d):\n                print(\"%s needs %s support.\" % (what, d))\n                sys.exit(1)\n\n    def has_include(self, what):\n        for include in self.include_path:\n            if os.path.exists(\"%s/%s\" % (include, what)):\n                return True\n        return False\n\n    def get_gcll(self):\n\n        global uwsgi_version\n\n        kvm_list = ['FreeBSD', 'OpenBSD', 'NetBSD', 'DragonFly']\n\n        if 'UWSGI_PROFILE_OVERRIDE' in os.environ:\n            for item in os.environ['UWSGI_PROFILE_OVERRIDE'].split(';'):\n                k, v = item.split('=', 1)\n                self.set(k, v)\n\n        if 'UWSGI_AS_LIB' in os.environ:\n            self.set('as_shared_library', 'true')\n            self.set('bin_name', os.environ['UWSGI_AS_LIB'])\n\n        if self.has_include('ifaddrs.h'):\n            self.cflags.append('-DUWSGI_HAS_IFADDRS')\n            report['ifaddrs'] = True\n\n        if uwsgi_os in ('FreeBSD', 'DragonFly', 'OpenBSD'):\n            if self.has_include('execinfo.h') or os.path.exists('/usr/local/include/execinfo.h'):\n                if os.path.exists('/usr/local/include/execinfo.h'):\n                    self.cflags.append('-I/usr/local/include')\n                    self.ldflags.append('-L/usr/local/lib')\n                self.cflags.append('-DUWSGI_HAS_EXECINFO')\n                self.libs.append('-lexecinfo')\n                report['execinfo'] = True\n\n        if uwsgi_os == 'GNU/kFreeBSD':\n            if self.has_include('execinfo.h'):\n                self.cflags.append('-DUWSGI_HAS_EXECINFO')\n                report['execinfo'] = True\n\n        if self.has_include('zlib.h'):\n            self.cflags.append('-DUWSGI_ZLIB')\n            self.libs.append('-lz')\n            self.gcc_list.append('core/zlib')\n            report['zlib'] = True\n\n        if uwsgi_os == 'OpenBSD':\n            try:\n                obsd_major = uwsgi_os_k.split('.')[0]\n                obsd_minor = uwsgi_os_k.split('.')[1]\n                obsd_ver = int(obsd_major + obsd_minor)\n                if obsd_ver > 50:\n                    self.cflags.append('-DUWSGI_NEW_OPENBSD')\n                    report['kernel'] = 'New OpenBSD'\n            except Exception:\n                pass\n\n        if uwsgi_os == 'SunOS':\n            self.libs.append('-lsendfile')\n            self.libs.append('-lrt')\n            self.gcc_list.append('lib/sun_fixes')\n            sunos_major = int(uwsgi_os_k.split('.')[0])\n            sunos_minor = int(uwsgi_os_k.split('.')[1])\n            # solaris < 11 does not have sethostname declared in unistd\n            if not (sunos_major == 5 and sunos_minor > 10):\n                self.cflags.append('-DUWSGI_SUNOS_EXTERN_SETHOSTNAME')\n                self.ldflags.append('-L/lib')\n            if not uwsgi_os_v.startswith('Nexenta'):\n                self.libs.remove('-rdynamic')\n\n        if uwsgi_os == 'GNU/kFreeBSD':\n            if self.has_include('kvm.h'):\n                kvm_list.append('GNU/kFreeBSD')\n\n        if uwsgi_os in kvm_list:\n            self.libs.append('-lkvm')\n\n        if uwsgi_os == 'Haiku':\n            self.libs.remove('-rdynamic')\n            self.libs.remove('-lpthread')\n            self.libs.append('-lroot')\n\n        if uwsgi_os == 'Darwin':\n            if uwsgi_os_k.startswith('8'):\n                self.cflags.append('-DUNSETENV_VOID')\n                self.cflags.append('-DNO_SENDFILE')\n                self.cflags.append('-DNO_EXECINFO')\n                self.cflags.append('-DOLD_REALPATH')\n            darwin_major = int(uwsgi_os_k.split('.')[0])\n            # MacOS High Sierra and above: since XCode 10 there's no libgcc_s.10.5\n            if darwin_major >= 17:\n                self.cflags.append('-mmacosx-version-min=10.9')\n            else:\n                self.cflags.append('-mmacosx-version-min=10.5')\n            if GCC in ('clang',):\n                self.libs.remove('-rdynamic')\n\n        if uwsgi_os.startswith('CYGWIN'):\n            self.libs.remove('-rdynamic')\n\n        # compile extras\n        extras = self.get('extras', None)\n        if extras:\n            for extra in extras.split(','):\n                self.gcc_list.append(extra)\n\n        # check for usable ucontext\n        report['ucontext'] = has_usable_ucontext()\n\n        # set locking subsystem\n        locking_mode = self.get('locking', 'auto')\n\n        if locking_mode == 'auto':\n            if uwsgi_os == 'Linux' or uwsgi_os == 'SunOS':\n                locking_mode = 'pthread_mutex'\n            # FreeBSD umtx is still not ready for process shared locking\n            # starting from FreeBSD 9 posix semaphores can be shared between processes\n            elif uwsgi_os in ('FreeBSD', 'GNU/kFreeBSD'):\n                try:\n                    fbsd_major = int(uwsgi_os_k.split('.')[0])\n                    if fbsd_major >= 9:\n                        locking_mode = 'posix_sem'\n                except Exception:\n                    pass\n            elif uwsgi_os == 'GNU':\n                locking_mode = 'posix_sem'\n            elif uwsgi_os == 'Darwin':\n                locking_mode = 'osx_spinlock'\n            elif uwsgi_os.startswith('CYGWIN'):\n                locking_mode = 'windows_mutex'\n\n        if locking_mode == 'pthread_mutex':\n            self.cflags.append('-DUWSGI_LOCK_USE_MUTEX')\n        # FreeBSD umtx is still not ready for process shared locking\n        elif locking_mode == 'posix_sem':\n            self.cflags.append('-DUWSGI_LOCK_USE_POSIX_SEM')\n        elif locking_mode == 'osx_spinlock':\n            self.cflags.append('-DUWSGI_LOCK_USE_OSX_SPINLOCK')\n        elif locking_mode == 'windows_mutex':\n            self.cflags.append('-DUWSGI_LOCK_USE_WINDOWS_MUTEX')\n        else:\n            self.cflags.append('-DUWSGI_IPCSEM_ATEXIT')\n\n        if locking_mode == 'auto':\n            report['locking'] = 'sysv semaphores'\n        else:\n            report['locking'] = locking_mode\n\n        # set event subsystem\n        event_mode = self.get('event', 'auto')\n\n        if event_mode == 'auto':\n            if uwsgi_os == 'Linux':\n                event_mode = 'epoll'\n            if uwsgi_os == 'SunOS':\n                event_mode = 'devpoll'\n                sun_major, sun_minor = uwsgi_os_k.split('.')\n                if int(sun_major) >= 5:\n                    if int(sun_minor) >= 10:\n                        event_mode = 'port'\n            elif uwsgi_os in ('Darwin', 'FreeBSD', 'GNU/kFreeBSD', 'OpenBSD', 'NetBSD', 'DragonFly'):\n                event_mode = 'kqueue'\n            elif uwsgi_os.startswith('CYGWIN') or uwsgi_os == 'GNU':\n                event_mode = 'poll'\n\n        if event_mode == 'epoll':\n            self.cflags.append('-DUWSGI_EVENT_USE_EPOLL')\n        elif event_mode == 'kqueue':\n            self.cflags.append('-DUWSGI_EVENT_USE_KQUEUE')\n        elif event_mode == 'devpoll':\n            self.cflags.append('-DUWSGI_EVENT_USE_DEVPOLL')\n        elif event_mode == 'port':\n            self.cflags.append('-DUWSGI_EVENT_USE_PORT')\n        elif event_mode == 'poll':\n            self.cflags.append('-DUWSGI_EVENT_USE_POLL')\n\n        report['event'] = event_mode\n\n        # set timer subsystem\n        timer_mode = self.get('timer', 'auto')\n\n        if timer_mode == 'auto':\n            if uwsgi_os == 'Linux':\n                k_all = uwsgi_os_k.split('.')\n                k_base = k_all[0]\n                # k_major = k_all[1]\n                if len(k_all) > 2:\n                    k_minor = k_all[2]\n                else:\n                    k_minor = 0\n                if int(k_base) > 2:\n                    timer_mode = 'timerfd'\n                elif int(k_minor) >= 25:\n                    timer_mode = 'timerfd'\n                else:\n                    timer_mode = 'none'\n\n            elif uwsgi_os == 'SunOS':\n                sun_major, sun_minor = uwsgi_os_k.split('.')\n                if int(sun_major) >= 5:\n                    if int(sun_minor) >= 10:\n                        timer_mode = 'port'\n\n            elif uwsgi_os in ('Darwin', 'FreeBSD', 'GNU/kFreeBSD', 'OpenBSD', 'NetBSD', 'DragonFly'):\n                timer_mode = 'kqueue'\n\n        if timer_mode == 'timerfd':\n            self.cflags.append('-DUWSGI_EVENT_TIMER_USE_TIMERFD')\n            if not self.has_include('sys/timerfd.h'):\n                self.cflags.append('-DUWSGI_EVENT_TIMER_USE_TIMERFD_NOINC')\n        elif timer_mode == 'kqueue':\n            self.cflags.append('-DUWSGI_EVENT_TIMER_USE_KQUEUE')\n        elif timer_mode == 'port':\n            self.cflags.append('-DUWSGI_EVENT_TIMER_USE_PORT')\n        else:\n            self.cflags.append('-DUWSGI_EVENT_TIMER_USE_NONE')\n\n        report['timer'] = timer_mode\n\n        # set filemonitor subsystem\n        filemonitor_mode = self.get('filemonitor', 'auto')\n\n        if filemonitor_mode == 'auto':\n            if uwsgi_os == 'Linux':\n                filemonitor_mode = 'inotify'\n            elif uwsgi_os == 'SunOS':\n                sun_major, sun_minor = uwsgi_os_k.split('.')\n                if int(sun_major) >= 5:\n                    if int(sun_minor) >= 10:\n                        filemonitor_mode = 'port'\n            elif uwsgi_os in ('Darwin', 'FreeBSD', 'GNU/kFreeBSD', 'OpenBSD', 'NetBSD', 'DragonFly'):\n                filemonitor_mode = 'kqueue'\n\n        if filemonitor_mode == 'inotify':\n            self.cflags.append('-DUWSGI_EVENT_FILEMONITOR_USE_INOTIFY')\n        elif filemonitor_mode == 'kqueue':\n            self.cflags.append('-DUWSGI_EVENT_FILEMONITOR_USE_KQUEUE')\n        elif filemonitor_mode == 'port':\n            self.cflags.append('-DUWSGI_EVENT_FILEMONITOR_USE_PORT')\n        else:\n            self.cflags.append('-DUWSGI_EVENT_FILEMONITOR_USE_NONE')\n\n        report['filemonitor'] = filemonitor_mode\n\n        if self.get('malloc_implementation') != 'libc':\n            if self.get('malloc_implementation') == 'tcmalloc':\n                self.libs.append('-ltcmalloc')\n            if self.get('malloc_implementation') == 'jemalloc':\n                self.libs.append('-ljemalloc')\n\n        report['malloc'] = self.get('malloc_implementation')\n\n        if self.get('as_shared_library'):\n            if self.get('as_shared_library') == 'static':\n                self.ldflags.append('--static')\n            else:\n                self.ldflags.append('-shared')\n            # on cygwin we do not need PIC (it is implicit)\n            if not uwsgi_os.startswith('CYGWIN'):\n                self.ldflags.append('-fPIC')\n                self.cflags.append('-fPIC')\n            self.cflags.append('-DUWSGI_AS_SHARED_LIBRARY')\n            if uwsgi_os == 'Darwin':\n                self.ldflags.append('-dynamiclib')\n                self.ldflags.append('-undefined dynamic_lookup')\n\n        if self.get('blacklist'):\n            self.cflags.append('-DUWSGI_BLACKLIST=\"\\\\\"%s\\\\\"\"' % self.get('blacklist'))\n\n        if self.get('whitelist'):\n            self.cflags.append('-DUWSGI_WHITELIST=\"\\\\\"%s\\\\\"\"' % self.get('whitelist'))\n\n        has_pcre = False\n\n        required_pcre = self.get('pcre')\n        if required_pcre:\n            pcre_libs = spcall('pcre2-config --libs8')\n            if pcre_libs:\n                pcre_cflags = spcall(\"pcre2-config --cflags\")\n                pcre_define = \"-DUWSGI_PCRE2\"\n            else:\n                pcre_libs = spcall('pcre-config --libs')\n                pcre_cflags = spcall(\"pcre-config --cflags\")\n                pcre_define = \"-DUWSGI_PCRE\"\n        else:\n            pcre_libs = None\n\n        if required_pcre:\n            if required_pcre != 'auto' and pcre_libs is None:\n                print(\"*** libpcre headers unavailable. uWSGI build is interrupted. You have to install pcre development package or disable pcre\")\n                sys.exit(1)\n\n            if pcre_libs:\n                self.libs.append(pcre_libs)\n                self.cflags.append(pcre_cflags)\n                self.gcc_list.append('core/regexp')\n                self.cflags.append(pcre_define)\n                has_pcre = True\n\n        if has_pcre:\n            report['pcre'] = True\n\n        if self.get('routing'):\n            if self.get('routing') == 'auto':\n                if has_pcre:\n                    self.gcc_list.append('core/routing')\n                    self.cflags.append(\"-DUWSGI_ROUTING\")\n                    report['routing'] = True\n            else:\n                self.gcc_list.append('core/routing')\n                self.cflags.append(\"-DUWSGI_ROUTING\")\n                report['routing'] = True\n\n        if self.has_include('sys/capability.h') and uwsgi_os == 'Linux':\n            self.cflags.append(\"-DUWSGI_CAP\")\n            self.libs.append('-lcap')\n            report['capabilities'] = True\n\n        if self.has_include('uuid/uuid.h') and not self.get('check'):\n            self.cflags.append(\"-DUWSGI_UUID\")\n            if uwsgi_os in ('Linux', 'GNU', 'GNU/kFreeBSD') or uwsgi_os.startswith('CYGWIN') or os.path.exists('/usr/lib/libuuid.so') or os.path.exists('/usr/local/lib/libuuid.so') or os.path.exists('/usr/lib64/libuuid.so') or os.path.exists('/usr/local/lib64/libuuid.so'):\n                self.libs.append('-luuid')\n\n        if self.get('append_version'):\n            if not self.get('append_version').startswith('-'):\n                uwsgi_version += '-'\n            uwsgi_version += self.get('append_version')\n\n        if uwsgi_os in ('FreeBSD', 'GNU/kFreeBSD') and self.has_include('jail.h'):\n            self.cflags.append('-DUWSGI_HAS_FREEBSD_LIBJAIL')\n            self.libs.append('-ljail')\n\n        self.embed_config = None\n\n        if uwsgi_os not in ('Darwin',):\n            self.embed_config = os.environ.get('UWSGI_EMBED_CONFIG')\n            if not self.embed_config:\n                self.embed_config = self.get('embed_config')\n            if self.embed_config:\n                binary_link_cmd = \"ld -r -b binary -o %s.o %s\" % (binarize(self.embed_config), self.embed_config)\n                print(binary_link_cmd)\n                subprocess.call(binary_link_cmd, shell=True)\n                self.cflags.append(\"-DUWSGI_EMBED_CONFIG=_binary_%s_start\" % binarize(self.embed_config))\n                self.cflags.append(\"-DUWSGI_EMBED_CONFIG_END=_binary_%s_end\" % binarize(self.embed_config))\n            embed_files = os.environ.get('UWSGI_EMBED_FILES')\n            if not embed_files:\n                embed_files = self.get('embed_files')\n            if embed_files:\n                for ef in embed_files.split(','):\n                    ef_parts = ef.split('=')\n                    symbase = None\n                    if len(ef_parts) > 1:\n                        ef = ef_parts[1]\n                        symbase = ef_parts[0]\n                    if os.path.isdir(ef):\n                        for directory, directories, files in os.walk(ef):\n                            for f in files:\n                                fname = \"%s/%s\" % (directory, f)\n                                binary_link_cmd = \"ld -r -b binary -o %s.o %s\" % (binarize(fname), fname)\n                                print(binary_link_cmd)\n                                subprocess.call(binary_link_cmd, shell=True)\n                                if symbase:\n                                    for kind in ('start', 'end'):\n                                        objcopy_cmd = \"objcopy --redefine-sym _binary_%s_%s=_binary_%s%s_%s build/%s.o\" % (binarize(fname), kind, binarize(symbase), binarize(fname[len(ef):]), kind, binarize(fname))\n                                        print(objcopy_cmd)\n                                        subprocess.call(objcopy_cmd, shell=True)\n                                binary_list.append(binarize(fname))\n                    else:\n                        binary_link_cmd = \"ld -r -b binary -o %s.o %s\" % (binarize(ef), ef)\n                        print(binary_link_cmd)\n                        subprocess.call(binary_link_cmd, shell=True)\n                        binary_list.append(binarize(ef))\n                        if symbase:\n                            for kind in ('start', 'end'):\n                                objcopy_cmd = \"objcopy --redefine-sym _binary_%s_%s=_binary_%s_%s build/%s.o\" % (binarize(ef), kind, binarize(symbase), kind, binarize(ef))\n                                print(objcopy_cmd)\n                                subprocess.call(objcopy_cmd, shell=True)\n\n        self.cflags.append('-DUWSGI_VERSION=\"\\\\\"' + uwsgi_version + '\\\\\"\"')\n\n        uver_whole = uwsgi_version.split('-', 1)\n        if len(uver_whole) == 1:\n            uver_custom = ''\n        else:\n            uver_custom = uver_whole[1]\n\n        uver_dots = uver_whole[0].split('.')\n\n        uver_base = uver_dots[0]\n        uver_maj = uver_dots[1]\n        uver_min = '0'\n        uver_rev = '0'\n\n        if len(uver_dots) > 2:\n            uver_min = uver_dots[2]\n\n        if len(uver_dots) > 3:\n            uver_rev = uver_dots[3]\n\n        self.cflags.append('-DUWSGI_VERSION_BASE=\"' + uver_base + '\"')\n        self.cflags.append('-DUWSGI_VERSION_MAJOR=\"' + uver_maj + '\"')\n        self.cflags.append('-DUWSGI_VERSION_MINOR=\"' + uver_min + '\"')\n        self.cflags.append('-DUWSGI_VERSION_REVISION=\"' + uver_rev + '\"')\n        self.cflags.append('-DUWSGI_VERSION_CUSTOM=\"\\\\\"' + uver_custom + '\\\\\"\"')\n\n        if self.get('yaml'):\n            self.cflags.append(\"-DUWSGI_YAML\")\n            self.gcc_list.append('core/yaml')\n            report['yaml'] = 'embedded'\n            if self.get('yaml') == 'libyaml':\n                self.cflags.append(\"-DUWSGI_LIBYAML\")\n                self.libs.append('-lyaml')\n                report['yaml'] = 'libyaml'\n\n        if self.get('json'):\n            if self.get('json') in ('auto', 'true'):\n                jsonconf = spcall(\"pkg-config --cflags jansson\")\n                if jsonconf:\n                    self.cflags.append(jsonconf)\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append(spcall(\"pkg-config --libs jansson\"))\n                    report['json'] = 'jansson'\n                elif self.has_include('jansson.h'):\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append('-ljansson')\n                    report['json'] = 'jansson'\n                else:\n                    jsonconf = spcall(\"pkg-config --cflags yajl\")\n                    if jsonconf:\n                        if jsonconf.endswith('include/yajl'):\n                            jsonconf = jsonconf.rstrip('yajl')\n                        self.cflags.append(jsonconf)\n                        self.cflags.append(\"-DUWSGI_JSON\")\n                        self.gcc_list.append('core/json')\n                        self.libs.append(spcall(\"pkg-config --libs yajl\"))\n                        self.cflags.append(\"-DUWSGI_JSON_YAJL\")\n                        report['json'] = 'yajl'\n                    elif self.get('json') == 'true':\n                        print(\"*** jansson and yajl headers unavailable. uWSGI build is interrupted. You have to install jansson or yajl development headers or disable JSON\")\n                        sys.exit(1)\n            elif self.get('json') == 'jansson':\n                jsonconf = spcall(\"pkg-config --cflags jansson\")\n                if jsonconf:\n                    self.cflags.append(jsonconf)\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append(spcall(\"pkg-config --libs jansson\"))\n                    report['json'] = 'jansson'\n                elif self.has_include('jansson.h'):\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append('-ljansson')\n                    report['json'] = 'jansson'\n                else:\n                    print(\"*** jansson headers unavailable. uWSGI build is interrupted. You have to install jansson development package or use yajl or disable JSON\")\n                    sys.exit(1)\n            elif self.get('json') == 'yajl':\n                jsonconf = spcall(\"pkg-config --cflags yajl\")\n                if jsonconf:\n                    self.cflags.append(jsonconf)\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append(spcall(\"pkg-config --libs yajl\"))\n                    self.cflags.append(\"-DUWSGI_JSON_YAJL\")\n                    report['json'] = 'yajl'\n                elif self.has_include('yajl/yajl_tree.h'):\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append('-lyajl')\n                    self.cflags.append(\"-DUWSGI_JSON_YAJL\")\n                    report['json'] = 'yajl'\n                elif self.has_include('yajl/yajl_parse.h'):\n                    self.cflags.append(\"-DUWSGI_JSON\")\n                    self.gcc_list.append('core/json')\n                    self.libs.append('-lyajl')\n                    self.cflags.append(\"-DUWSGI_JSON_YAJL_OLD\")\n                    report['json'] = 'yajl_old'\n                else:\n                    print(\"*** yajl headers unavailable. uWSGI build is interrupted. You have to install yajl development package or use jansson or disable JSON\")\n                    sys.exit(1)\n\n        if self.get('ssl'):\n            if self.get('ssl') == 'auto':\n                if self.has_include('openssl/ssl.h'):\n                    self.cflags.append(\"-DUWSGI_SSL\")\n                    self.libs.append('-lssl')\n                    self.libs.append('-lcrypto')\n                    self.gcc_list.append('core/ssl')\n                    self.gcc_list.append('core/legion')\n                    report['ssl'] = True\n            else:\n                self.cflags.append(\"-DUWSGI_SSL\")\n                self.libs.append('-lssl')\n                self.libs.append('-lcrypto')\n                self.gcc_list.append('core/ssl')\n                self.gcc_list.append('core/legion')\n                report['ssl'] = True\n\n        if self.get('xml'):\n            if self.get('xml') == 'auto':\n                xmlconf = spcall('xml2-config --libs')\n                if xmlconf and uwsgi_os != 'Darwin':\n                    self.libs.append(xmlconf)\n                    xmlconf = spcall(\"xml2-config --cflags\")\n                    self.cflags.append(xmlconf)\n                    self.cflags.append(\"-DUWSGI_XML -DUWSGI_XML_LIBXML2\")\n                    self.gcc_list.append('core/xmlconf')\n                    report['xml'] = 'libxml2'\n                elif self.has_include('expat.h'):\n                    self.cflags.append(\"-DUWSGI_XML -DUWSGI_XML_EXPAT\")\n                    self.libs.append('-lexpat')\n                    self.gcc_list.append('core/xmlconf')\n                    report['xml'] = 'expat'\n            elif self.get('xml') == 'libxml2':\n                xmlconf = spcall('xml2-config --libs')\n                if xmlconf is None:\n                    print(\"*** libxml2 headers unavailable. uWSGI build is interrupted. You have to install libxml2 development package or use libexpat or disable XML\")\n                    sys.exit(1)\n                else:\n                    self.libs.append(xmlconf)\n                    xmlconf = spcall(\"xml2-config --cflags\")\n                    if xmlconf is None:\n                        print(\"*** libxml2 headers unavailable. uWSGI build is interrupted. You have to install libxml2 development package or use libexpat or disable XML\")\n                        sys.exit(1)\n                    else:\n                        self.cflags.append(xmlconf)\n                        self.cflags.append(\"-DUWSGI_XML -DUWSGI_XML_LIBXML2\")\n                        self.gcc_list.append('core/xmlconf')\n                        report['xml'] = 'libxml2'\n            elif self.get('xml') == 'expat':\n                self.cflags.append(\"-DUWSGI_XML -DUWSGI_XML_EXPAT\")\n                self.libs.append('-lexpat')\n                self.gcc_list.append('core/xmlconf')\n                report['xml'] = 'expat'\n\n        if self.get('plugin_dir'):\n            self.cflags.append('-DUWSGI_PLUGIN_DIR=\"\\\\\"%s\\\\\"\"' % self.get('plugin_dir'))\n            report['plugin_dir'] = self.get('plugin_dir')\n\n        if self.get('debug'):\n            self.cflags.append(\"-DUWSGI_DEBUG\")\n            self.cflags.append(\"-g\")\n            report['debug'] = True\n\n        if self.get('unbit'):\n            self.cflags.append(\"-DUNBIT\")\n\n        return self.gcc_list, self.cflags, self.ldflags, self.libs\n\n\ndef is_remote_plugin(path):\n    return any(path.startswith(pfx) for pfx in ('http://', 'https://', 'git://', 'ssh://'))\n\n\ndef get_remote_plugin(path):\n    git_dir = path.split('/').pop()\n    if git_dir.endswith('.git'):\n        git_dir = git_dir[:-4]\n    if not os.path.isdir(git_dir):\n        if subprocess.call(['git', 'clone', path]) != 0:\n            sys.exit(1)\n    else:\n        if subprocess.call(['git', 'pull'], cwd=git_dir) != 0:\n            sys.exit(1)\n    return git_dir\n\n\ntry:\n    execfile\nexcept NameError:\n    def execfile(path, up):\n        with open(path) as py:\n            code = compile(py.read(), path, 'exec')\n        exec(code, up)\n\n\ndef get_plugin_up(path):\n    up = {}\n    if os.path.isfile(path):\n        bname = os.path.basename(path)\n        # override path\n        path = os.path.dirname(path)\n        up['GCC_LIST'] = [bname]\n        up['NAME'] = bname.split('.')[0]\n        if not path:\n            path = '.'\n    elif os.path.isdir(path):\n        execfile('%s/uwsgiplugin.py' % path, up)\n    else:\n        print(\"Error: unable to find directory '%s'\" % path)\n        sys.exit(1)\n\n    if 'CFLAGS' not in up:\n        up['CFLAGS'] = []\n\n    if 'LDFLAGS' not in up:\n        up['LDFLAGS'] = []\n\n    if 'LIBS' not in up:\n        up['LIBS'] = []\n\n    if 'REQUIRES' not in up:\n        up['REQUIRES'] = []\n\n    return (path, up)\n\n\ndef build_plugin(path, uc, cflags, ldflags, libs, name=None):\n    path = path.rstrip('/')\n\n    plugin_started_at = time.time()\n\n    if is_remote_plugin(path):\n        git_dir = get_remote_plugin(path)\n        path = os.path.abspath(git_dir)\n\n    path, up = get_plugin_up(path)\n\n    p_cflags = cflags[:]\n    p_cflags += up['CFLAGS']\n\n    p_ldflags = ldflags[:]\n    p_ldflags += up['LDFLAGS']\n\n    p_libs = up['LIBS']\n\n    requires = up['REQUIRES']\n\n    post_build = None\n    try:\n        post_build = up['post_build']\n    except KeyError:\n        pass\n\n    p_cflags.insert(0, '-I.')\n\n    if name is None:\n        name = up['NAME']\n    else:\n        p_cflags.append(\"-D%s_plugin=%s_plugin\" % (up['NAME'], name))\n\n    try:\n        for opt in uc.config.options(name):\n            p_cflags.append('-DUWSGI_PLUGIN_%s_%s=\"%s\"' % (name.upper(), opt.upper(), uc.config.get(name, opt, '1')))\n    except Exception:\n        pass\n\n    if uc:\n        plugin_dest = uc.get('plugin_build_dir', uc.get('plugin_dir')) + '/' + name + '_plugin'\n    else:\n        plugin_dest = name + '_plugin'\n\n    shared_flag = '-shared'\n\n    gcc_list = []\n\n    if uwsgi_os == 'Darwin':\n        shared_flag = '-dynamiclib -undefined dynamic_lookup'\n\n    for cfile in up['GCC_LIST']:\n        if cfile.endswith('.a'):\n            gcc_list.append(cfile)\n        elif not cfile.endswith('.c') and not cfile.endswith('.cc') and not cfile.endswith('.m') and not cfile.endswith('.go') and not cfile.endswith('.o'):\n            gcc_list.append(path + '/' + cfile + '.c')\n        else:\n            if cfile.endswith('.go'):\n                p_cflags.append('-Wno-error')\n            gcc_list.append(path + '/' + cfile)\n    for bfile in up.get('BINARY_LIST', []):\n        try:\n            binary_link_cmd = \"ld -r -b binary -o %s/%s.o %s/%s\" % (path, bfile[1], path, bfile[1])\n            print(binary_link_cmd)\n            if subprocess.call(binary_link_cmd, shell=True) != 0:\n                raise Exception('unable to link binary file')\n            for kind in ('start', 'end'):\n                objcopy_cmd = \"objcopy --redefine-sym _binary_%s_%s=%s_%s %s/%s.o\" % (\n                    binarize('%s/%s' % (path, bfile[1])),\n                    kind,\n                    bfile[0],\n                    kind,\n                    path,\n                    bfile[1]\n                )\n                print(objcopy_cmd)\n                if subprocess.call(objcopy_cmd, shell=True) != 0:\n                    raise Exception('unable to link binary file')\n            gcc_list.append('%s/%s.o' % (path, bfile[1]))\n        except Exception:\n            if uwsgi_os == 'Darwin':\n                gcc_list.append('-sectcreate __DATA %s %s/%s' % (strip_prefix('_uwsgi_', bfile[0]), path, bfile[1]))\n\n    p_ldflags_blacklist = ('-Wl,--no-undefined',)\n    for ldflag in p_ldflags_blacklist:\n        try:\n            p_ldflags.remove(ldflag)\n        except ValueError:\n            pass\n\n    p_cflags_blacklist = (\n        '-Wdeclaration-after-statement',\n        '-Werror=declaration-after-statement',\n        '-Wwrite-strings',\n        '-Werror=write-strings',\n        '-Winline',\n        '-pie',\n    )\n    for cflag in p_cflags_blacklist:\n        try:\n            p_cflags.remove(cflag)\n        except ValueError:\n            pass\n\n    if GCC in ('clang',):\n        try:\n            p_cflags.remove('-fno-fast-math')\n            p_cflags.remove('-ggdb3')\n        except ValueError:\n            pass\n\n    if uwsgi_os.startswith('CYGWIN'):\n        try:\n            p_cflags.remove('-fstack-protector')\n            p_ldflags.remove('-fstack-protector')\n        except ValueError:\n            pass\n\n    need_pic = ' -fPIC'\n    # on cygwin we do not need PIC\n    if uwsgi_os.startswith('CYGWIN'):\n        need_pic = ' -L. -luwsgi'\n\n    gccline = \"%s%s %s -o %s.so %s %s %s %s\" % (\n        GCC,\n        need_pic,\n        shared_flag,\n        plugin_dest,\n        ' '.join(uniq_warnings(p_cflags)),\n        ' '.join(gcc_list),\n        ' '.join(uniq_warnings(p_ldflags)),\n        ' '.join(uniq_warnings(p_libs))\n    )\n    print_compilation_output(\"[%s] %s.so\" % (GCC, plugin_dest), gccline)\n\n    ret = subprocess.call(gccline, shell=True)\n    if ret != 0:\n        print(\"*** unable to build %s plugin ***\" % name)\n        sys.exit(1)\n\n    try:\n        if requires:\n            f = open('.uwsgi_plugin_section', 'w')\n            for rp in requires:\n                f.write(\"requires=%s\\n\" % rp)\n            f.close()\n            objline = \"objcopy %s.so --add-section uwsgi=.uwsgi_plugin_section %s.so\" % (plugin_dest, plugin_dest)\n            print_compilation_output(None, objline)\n            subprocess.call(objline, shell=True)\n            os.unlink('.uwsgi_plugin_section')\n    except Exception:\n        pass\n\n    if post_build:\n        post_build(uc)\n\n    print(\"build time: %d seconds\" % (time.time() - plugin_started_at))\n    print(\"*** %s plugin built and available in %s ***\" % (name, plugin_dest + '.so'))\n\n\ndef vararg_callback(option, opt_str, value, parser):\n    assert value is None\n    value = []\n    for arg in parser.rargs:\n        # stop on --foo like options\n        if arg[:2] == \"--\" and len(arg) > 2:\n            break\n        # stop on -a, but not on -3 or -3.0\n        if arg[:1] == \"-\" and len(arg) > 1:\n            break\n        value.append(arg)\n\n    del parser.rargs[:len(value)]\n    setattr(parser.values, option.dest, value)\n\nif __name__ == \"__main__\":\n    parser = OptionParser()\n    parser.add_option(\"-b\", \"--build\", action=\"callback\", callback=vararg_callback, dest=\"build\", help=\"build a specific profile if provided or default.ini\", metavar=\"PROFILE\")\n    parser.add_option(\"-f\", \"--cflags\", action=\"callback\", callback=vararg_callback, dest=\"cflags\", help=\"same as --build but less verbose\", metavar=\"PROFILE\")\n    parser.add_option(\"-u\", \"--unbit\", action=\"store_true\", dest=\"unbit\", help=\"build unbit profile\")\n    parser.add_option(\"-p\", \"--plugin\", action=\"callback\", callback=vararg_callback, dest=\"plugin\", help=\"build a plugin as shared library, optionally takes a build profile name\", metavar=\"PLUGIN [PROFILE]\")\n    parser.add_option(\"-x\", \"--extra-plugin\", action=\"callback\", callback=vararg_callback,  dest=\"extra_plugin\", help=\"build an external plugin as shared library, takes an optional include dir\", metavar=\"PLUGIN [NAME]\")\n    parser.add_option(\"-c\", \"--clean\", action=\"store_true\", dest=\"clean\", help=\"clean the build\")\n    parser.add_option(\"-e\", \"--check\", action=\"store_true\", dest=\"check\", help=\"run cppcheck\")\n    parser.add_option(\"-v\", \"--verbose\", action=\"store_true\", dest=\"verbose\", help=\"more verbose build\")\n    parser.add_option(\"-g\", \"--debug\", action=\"store_true\", dest=\"debug\", help=\"build with debug symbols, affects only full build\")\n    parser.add_option(\"-a\", \"--asan\", action=\"store_true\", dest=\"asan\", help=\"build with address sanitizer, it's a debug option and affects only full build\")\n\n    (options, args) = parser.parse_args()\n\n    if options.verbose:\n        verbose_build = True\n\n    add_cflags = []\n    add_ldflags = []\n\n    if options.debug:\n        add_cflags.append('-g')\n        add_ldflags.append('-g')\n\n    if options.asan:\n        add_cflags.extend(['-g', '-fsanitize=address', '-fno-omit-frame-pointer'])\n        add_ldflags.extend(['-g', '-fsanitize=address'])\n\n    if options.build is not None or options.cflags is not None:\n        is_cflags = options.cflags is not None\n        try:\n            if not is_cflags:\n                bconf = options.build[0]\n            else:\n                bconf = options.cflags[0]\n        except Exception:\n            bconf = os.environ.get('UWSGI_PROFILE', 'default.ini')\n        if not bconf.endswith('.ini'):\n            bconf += '.ini'\n        if '/' not in bconf:\n            bconf = 'buildconf/%s' % bconf\n\n        uc = uConf(bconf, is_cflags)\n        if add_cflags or add_ldflags:\n            gcc_list, cflags, ldflags, libs = uc.get_gcll()\n            if add_cflags:\n                cflags.extend(add_cflags)\n            if add_ldflags:\n                ldflags.extend(add_ldflags)\n            gcll = (gcc_list, cflags, ldflags, libs)\n        else:\n            gcll = None\n        build_uwsgi(uc, is_cflags, gcll=gcll)\n    elif options.unbit:\n        build_uwsgi(uConf('buildconf/unbit.ini'))\n    elif options.plugin:\n        try:\n            bconf = options.plugin[1]\n        except Exception:\n            bconf = os.environ.get('UWSGI_PROFILE', 'default.ini')\n        if not bconf.endswith('.ini'):\n            bconf += '.ini'\n        if '/' not in bconf:\n            bconf = 'buildconf/%s' % bconf\n        uc = uConf(bconf)\n        gcc_list, cflags, ldflags, libs = uc.get_gcll()\n        try:\n            name = options.plugin[2]\n        except Exception:\n            name = None\n        print(\"*** uWSGI building and linking plugin %s ***\" % options.plugin[0])\n        build_plugin(options.plugin[0], uc, cflags, ldflags, libs, name)\n    elif options.extra_plugin:\n        print(\"*** uWSGI building and linking plugin from %s ***\" % options.extra_plugin[0])\n        cflags = os.environ['UWSGI_PLUGINS_BUILDER_CFLAGS'].split() + os.environ.get(\"CFLAGS\", \"\").split()\n        cflags.append('-I.uwsgi_plugins_builder/')\n        ldflags = os.environ.get(\"LDFLAGS\", \"\").split()\n        name = None\n        try:\n            name = options.extra_plugin[1]\n        except Exception:\n            pass\n        build_plugin(options.extra_plugin[0], None, cflags, ldflags, None, name)\n    elif options.clean:\n        subprocess.call(\"rm -f core/*.o\", shell=True)\n        subprocess.call(\"rm -f proto/*.o\", shell=True)\n        subprocess.call(\"rm -f lib/*.o\", shell=True)\n        subprocess.call(\"rm -f plugins/*/*.o\", shell=True)\n        subprocess.call(\"rm -f build/*.o\", shell=True)\n        subprocess.call(\"rm -f core/dot_h.c\", shell=True)\n        subprocess.call(\"rm -f core/config_py.c\", shell=True)\n    elif options.check:\n        subprocess.call(\"cppcheck --max-configs=1000 --enable=all -q core/ plugins/ proto/ lib/ apache2/\", shell=True)\n    else:\n        parser.print_help()\n        sys.exit(1)\n"
        },
        {
          "name": "uwsgidecorators.py",
          "type": "blob",
          "size": 10.615234375,
          "content": "from functools import partial\nimport sys\nfrom threading import Thread\n\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\nimport uwsgi\n\nif uwsgi.masterpid() == 0:\n    raise Exception(\n        \"you have to enable the uWSGI master process to use this module\")\n\nspooler_functions = {}\nmule_functions = {}\npostfork_chain = []\n\n\n# Python3 compatibility\ndef _encode1(val):\n    if sys.version_info >= (3, 0) and isinstance(val, str):\n        return val.encode('utf-8')\n    else:\n        return val\n\n\ndef _decode1(val):\n    if sys.version_info >= (3, 0) and isinstance(val, bytes):\n        return val.decode('utf-8')\n    else:\n        return val\n\n\ndef _encode_to_spooler(vars):\n    return dict((_encode1(K), _encode1(V)) for (K, V) in vars.items())\n\n\ndef _decode_from_spooler(vars):\n    return dict((_decode1(K), _decode1(V)) for (K, V) in vars.items())\n\n\ndef get_free_signal():\n    for signum in range(0, 256):\n        if not uwsgi.signal_registered(signum):\n            return signum\n\n    raise Exception(\"No free uwsgi signal available\")\n\n\ndef manage_spool_request(vars):\n    # To check whether 'args' is in vals or not - decode the keys first,\n    # because in python3 all keys in 'vals' are have 'byte' types\n    vars = dict((_decode1(K), V) for (K, V) in vars.items())\n    if 'args' in vars:\n        for k in ('args', 'kwargs'):\n            vars[k] = pickle.loads(vars.pop(k))\n\n    vars = _decode_from_spooler(vars)\n    f = spooler_functions[vars['ud_spool_func']]\n\n    if 'args' in vars:\n        ret = f(*vars['args'], **vars['kwargs'])\n    else:\n        ret = f(vars)\n\n    return int(vars.get('ud_spool_ret', ret))\n\n\ndef postfork_chain_hook():\n    for f in postfork_chain:\n        f()\n\nuwsgi.spooler = manage_spool_request\nuwsgi.post_fork_hook = postfork_chain_hook\n\n\nclass postfork(object):\n\n    def __init__(self, f):\n        if callable(f):\n            self.wid = 0\n            self.f = f\n        else:\n            self.f = None\n            self.wid = f\n        postfork_chain.append(self)\n\n    def __call__(self, *args, **kwargs):\n        if self.f:\n            if self.wid > 0 and self.wid != uwsgi.worker_id():\n                return\n            return self.f()\n        self.f = args[0]\n\n\nclass _spoolraw(object):\n\n    def __call__(self, *args, **kwargs):\n        arguments = self.base_dict.copy()\n        if not self.pass_arguments:\n            if len(args) > 0:\n                arguments.update(args[0])\n            if kwargs:\n                arguments.update(kwargs)\n        else:\n            spooler_args = {}\n            for key in ('message_dict', 'spooler', 'priority', 'at', 'body'):\n                if key in kwargs:\n                    spooler_args.update({key: kwargs.pop(key)})\n            arguments.update(spooler_args)\n            arguments.update(\n                {'args': pickle.dumps(args), 'kwargs': pickle.dumps(kwargs)})\n        return uwsgi.spool(_encode_to_spooler(arguments))\n\n    # For backward compatibility (uWSGI < 1.9.13)\n    def spool(self, *args, **kwargs):\n        return self.__class__.__call__(self, *args, **kwargs)\n\n    def __init__(self, f, pass_arguments):\n        if 'spooler' not in uwsgi.opt:\n            raise Exception(\n                \"you have to enable the uWSGI spooler to use @%s decorator\" % self.__class__.__name__)\n        self.f = f\n        spooler_functions[self.f.__name__] = self.f\n        # For backward compatibility (uWSGI < 1.9.13)\n        self.f.spool = self.__call__\n        self.pass_arguments = pass_arguments\n        self.base_dict = {'ud_spool_func': self.f.__name__}\n\n\nclass _spool(_spoolraw):\n\n    def __call__(self, *args, **kwargs):\n        self.base_dict['ud_spool_ret'] = str(uwsgi.SPOOL_OK)\n        return _spoolraw.__call__(self, *args, **kwargs)\n\n\nclass _spoolforever(_spoolraw):\n\n    def __call__(self, *args, **kwargs):\n        self.base_dict['ud_spool_ret'] = str(uwsgi.SPOOL_RETRY)\n        return _spoolraw.__call__(self, *args, **kwargs)\n\n\ndef spool_decorate(f=None, pass_arguments=False, _class=_spoolraw):\n    if not f:\n        return partial(_class, pass_arguments=pass_arguments)\n    return _class(f, pass_arguments)\n\n\ndef spoolraw(f=None, pass_arguments=False):\n    return spool_decorate(f, pass_arguments)\n\n\ndef spool(f=None, pass_arguments=False):\n    return spool_decorate(f, pass_arguments, _spool)\n\n\ndef spoolforever(f=None, pass_arguments=False):\n    return spool_decorate(f, pass_arguments, _spoolforever)\n\n\nclass mulefunc(object):\n\n    def __init__(self, f):\n        if callable(f):\n            self.fname = f.__name__\n            self.mule = 0\n            mule_functions[f.__name__] = f\n        else:\n            self.mule = f\n            self.fname = None\n\n    def real_call(self, *args, **kwargs):\n        uwsgi.mule_msg(pickle.dumps(\n            {\n                'service': 'uwsgi_mulefunc',\n                'func': self.fname,\n                'args': args,\n                'kwargs': kwargs\n            }\n        ), self.mule)\n\n    def __call__(self, *args, **kwargs):\n        if not self.fname:\n            self.fname = args[0].__name__\n            mule_functions[self.fname] = args[0]\n            return self.real_call\n\n        return self.real_call(*args, **kwargs)\n\n\ndef mule_msg_dispatcher(message):\n    try:\n        msg = pickle.loads(message)\n    except pickle.UnpicklingError:\n        return\n\n    if msg['service'] == 'uwsgi_mulefunc':\n        return mule_functions[msg['func']](*msg['args'], **msg['kwargs'])\n\nuwsgi.install_mule_msg_hook(mule_msg_dispatcher)\n\n\nclass rpc(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, f):\n        uwsgi.register_rpc(self.name, f)\n        return f\n\n\nclass farm_loop(object):\n\n    def __init__(self, f, farm):\n        self.f = f\n        self.farm = farm\n\n    def __call__(self):\n        if uwsgi.mule_id() == 0:\n            return\n        if not uwsgi.in_farm(self.farm):\n            return\n        while True:\n            message = uwsgi.farm_get_msg()\n            if message:\n                self.f(message)\n\n\nclass farm(object):\n\n    def __init__(self, name=None, **kwargs):\n        self.name = name\n\n    def __call__(self, f):\n        postfork_chain.append(farm_loop(f, self.name))\n\n\nclass mule_brain(object):\n\n    def __init__(self, f, num):\n        self.f = f\n        self.num = num\n\n    def __call__(self):\n        if uwsgi.mule_id() == self.num:\n            try:\n                self.f()\n            except BaseException:\n                exc = sys.exc_info()\n                sys.excepthook(exc[0], exc[1], exc[2])\n                sys.exit(1)\n\n\nclass mule_brainloop(mule_brain):\n\n    def __call__(self):\n        if uwsgi.mule_id() == self.num:\n            while True:\n                try:\n                    self.f()\n                except BaseException:\n                    exc = sys.exc_info()\n                    sys.excepthook(exc[0], exc[1], exc[2])\n                    sys.exit(1)\n\n\nclass mule(object):\n\n    def __init__(self, num):\n        self.num = num\n\n    def __call__(self, f):\n        postfork_chain.append(mule_brain(f, self.num))\n\n\nclass muleloop(mule):\n\n    def __call__(self, f):\n        postfork_chain.append(mule_brainloop(f, self.num))\n\n\nclass mulemsg_loop(object):\n\n    def __init__(self, f, num):\n        self.f = f\n        self.num = num\n\n    def __call__(self):\n        if uwsgi.mule_id() == self.num:\n            while True:\n                message = uwsgi.mule_get_msg()\n                if message:\n                    self.f(message)\n\n\nclass mulemsg(object):\n\n    def __init__(self, num):\n        self.num = num\n\n    def __call__(self, f):\n        postfork_chain.append(mulemsg_loop(f, self.num))\n\n\nclass signal(object):\n\n    def __init__(self, num, **kwargs):\n        self.num = num\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        return f\n\n\nclass timer(object):\n\n    def __init__(self, secs, **kwargs):\n        self.num = kwargs.get('signum', get_free_signal())\n        self.secs = secs\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        uwsgi.add_timer(self.num, self.secs)\n        return f\n\n\nclass mstimer(object):\n\n    def __init__(self, msecs, **kwargs):\n        self.num = kwargs.get('signum', get_free_signal())\n        self.msecs = msecs\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        uwsgi.add_ms_timer(self.num, self.msecs)\n        return f\n\n\nclass cron(object):\n\n    def __init__(self, minute, hour, day, month, dayweek, **kwargs):\n        self.num = kwargs.get('signum', get_free_signal())\n        self.minute = minute\n        self.hour = hour\n        self.day = day\n        self.month = month\n        self.dayweek = dayweek\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        uwsgi.add_cron(self.num, self.minute, self.hour,\n                       self.day, self.month, self.dayweek)\n        return f\n\n\nclass rbtimer(object):\n\n    def __init__(self, secs, **kwargs):\n        self.num = kwargs.get('signum', get_free_signal())\n        self.secs = secs\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        uwsgi.add_rb_timer(self.num, self.secs)\n        return f\n\n\nclass filemon(object):\n\n    def __init__(self, fsobj, **kwargs):\n        self.num = kwargs.get('signum', get_free_signal())\n        self.fsobj = fsobj\n        self.target = kwargs.get('target', '')\n\n    def __call__(self, f):\n        uwsgi.register_signal(self.num, self.target, f)\n        uwsgi.add_file_monitor(self.num, self.fsobj)\n        return f\n\n\nclass erlang(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, f):\n        uwsgi.erlang_register_process(self.name, f)\n        return f\n\n\nclass lock(object):\n\n    def __init__(self, f):\n        self.f = f\n\n    def __call__(self, *args, **kwargs):\n        # ensure the spooler will not call it\n        if uwsgi.i_am_the_spooler():\n            return\n        uwsgi.lock()\n        try:\n            return self.f(*args, **kwargs)\n        finally:\n            uwsgi.unlock()\n\n\nclass thread(object):\n\n    def __init__(self, f):\n        self.f = f\n\n    def __call__(self, *args):\n        t = Thread(target=self.f, args=args)\n        t.daemon = True\n        t.start()\n        return self.f\n\n\nclass harakiri(object):\n\n    def __init__(self, seconds):\n        self.s = seconds\n\n    def real_call(self, *args, **kwargs):\n        uwsgi.set_user_harakiri(self.s)\n        r = self.f(*args, **kwargs)\n        uwsgi.set_user_harakiri(0)\n        return r\n\n    def __call__(self, f):\n        self.f = f\n        return self.real_call\n"
        },
        {
          "name": "uwsgidsl.rb",
          "type": "blob",
          "size": 2.7724609375,
          "content": "# based on uwsgidecorators.py\n\nif UWSGI.masterpid == 0\n    raise \"you have to enable the uWSGI master process to use this module\"\nend\n\ndef get_free_signal()\n  for signum in 0..255\n    if not UWSGI.signal_registered(signum)\n      return signum\n    end\n  end\nend\n\n$postfork_chain = []\n$mulefunc_list = []\n$spoolfunc_list = []\n\nmodule UWSGI\n  module_function\n  def post_fork_hook()\n    $postfork_chain.each {|func| func.call }\n  end\n\n  module_function\n  def spooler(args)\n    $spoolfunc_list[args['ud_spool_func'].to_i].call(args)\n  end\n\n  module_function\n  def mule_msg_hook(message)\n    service = Marshal.load(message)\n    if service['service'] == 'uwsgi_mulefunc'\n      mulefunc_manager(service)\n    end\n  end\nend\n\ndef timer(secs, target='', &block)\n  freesig = get_free_signal\n  UWSGI.register_signal(freesig, target, block)\n  UWSGI.add_timer(freesig, secs)\nend\n\ndef rbtimer(secs, target='', &block)\n  freesig = get_free_signal\n  UWSGI.register_signal(freesig, target, block)\n  UWSGI.add_rb_timer(freesig, secs)\nend\n\ndef filemon(file, target='', &block)\n  freesig = get_free_signal\n  UWSGI.register_signal(freesig, target, block)\n  UWSGI.add_file_monitor(freesig, file)\nend\n\ndef cron(minute, hour, day, month, dayweek, target='', &block)\n  freesig = get_free_signal\n  UWSGI.register_signal(freesig, target, block)\n  UWSGI.add_cron(freesig, minute, hour, day, month, dayweek)\nend\n\ndef signal(signum, target='', &block)\n  UWSGI.register_signal(signum, target, block)\nend\n\ndef postfork(&block)\n  $postfork_chain << block\nend\n\nclass SpoolProc < Proc\n  def initialize(&block)\n    @block = block\n    @id = (($spoolfunc_list << block).length-1).to_s\n  end\n\n  def call(args)\n    args['ud_spool_func'] = @id\n    UWSGI::send_to_spooler(args)\n  end\nend\n\ndef rpc(name, &block)\n  if block.arity <= 0\n    UWSGI.register_rpc(name, block, 0)\n  else\n    UWSGI.register_rpc(name, block, block.arity)\n  end\nend\n\ndef mulefunc_manager(service)\n  $mulefunc_list[service['func']].real_call(service['args'])\nend\n\nclass MuleFunc < Proc\n\n  def initialize(id=0, &block)\n    @id = id\n    @block = block\n    @func_pos = (($mulefunc_list << self).length)-1\n  end\n\n  def real_call(*args)\n    @block.call(*args)\n  end\n\n  def call(*args)\n    UWSGI.mule_msg( Marshal.dump( {\n                'service' => 'uwsgi_mulefunc',\n                'func' => @func_pos,\n                'args'=> args\n            }), @id)\n  end\n\nend\n\nclass MuleProc < Proc\n  def initialize(id, block)\n    @id = id\n    @block = block\n  end\n\n  def call()\n    if UWSGI.mule_id == @id\n      @block.call\n    end\n  end\nend\n\nclass MuleLoopProc < MuleProc\n  def call()\n    if UWSGI.mule_id == @id\n      loop do\n        @block.call\n      end\n    end\n  end\nend\n\ndef mule(id, &block)\n  $postfork_chain << MuleProc.new(id, block)\nend\n\ndef muleloop(id, &block)\n  $postfork_chain << MuleLoopProc.new(id, block)\nend\n"
        },
        {
          "name": "valgrind",
          "type": "tree",
          "content": null
        },
        {
          "name": "vassals",
          "type": "tree",
          "content": null
        },
        {
          "name": "vhosttest",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}