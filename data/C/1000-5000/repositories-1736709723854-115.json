{
  "metadata": {
    "timestamp": 1736709723854,
    "page": 115,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Bodmer/TFT_eSPI",
      "stars": 3912,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.369140625,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.68359375,
          "content": "# Windows image file caches\nThumbs.db\nehthumbs.db\n\n# Folder config file\nDesktop.ini\n\n# Recycle Bin used on file shares\n$RECYCLE.BIN/\n\n# Windows Installer files\n*.cab\n*.msi\n*.msm\n*.msp\n\n# Windows shortcuts\n*.lnk\n\n# Arduino debug\ndebug.cfg\ndebug_custom.json\n*.svd\n\n# =========================\n# Operating System Files\n# =========================\n\n# OSX\n# =========================\n\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.1201171875,
          "content": "\nidf_component_register(SRCS \"TFT_eSPI.cpp\"\n                    INCLUDE_DIRS \".\"\n                    PRIV_REQUIRES arduino)"
        },
        {
          "name": "Extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "Fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "Kconfig",
          "type": "blob",
          "size": 12.56640625,
          "content": "menu \"TFT_eSPI\"\n\n    menu \"Hidden menu\"\n        visible if false\n\n        config TFT_eSPI_ESPIDF\n            bool \"Enable Configuration\"\n            default y\n    endmenu\n        \n    choice TFT_DRIVER\n        prompt \"Select TFT driver\"\n        default TFT_ILI9341_DRIVER\n        help\n            Driver for the TFT LCD screen\n\n        config TFT_ILI9341_DRIVER\n            bool \"ILI9341 - 1\"\n            help\n                Generic driver for common displays\n        config TFT_ILI9341_2_DRIVER\n            bool \"ILI9341 - 2\"\n            help\n                Alternative ILI9341 driver, see https://github.com/Bodmer/TFT_eSPI/issues/1172\n        config TFT_ST7735_DRIVER\n            bool \"ST7735\"\n            help\n                Define additional parameters below for this display\n        config TFT_ILI9163_DRIVER\n            bool \"ILI9163\"\n            help\n                Define additional parameters below for this display\n        config TFT_S6D02A1_DRIVER\n            bool \"S6D02A1\"\n        config TFT_HX8357D_DRIVER\n            bool \"HX8357D\"\n        config TFT_ILI9481_DRIVER\n            bool \"ILI9481\"\n        config TFT_ILI9486_DRIVER\n            bool \"ILI9486\"\n        config TFT_ILI9488_DRIVER\n            bool \"ILI9488\"\n            help\n                WARNING: Do not connect ILI9488 display SDO to MISO if other devices \n                share the SPI bus (TFT SDO does NOT tristate when CS is high)\n        config TFT_ST7789_DRIVER\n            bool \"ST7789 - 1\"\n            help\n                Full configuration option, define additional parameters below for this display\n        config TFT_ST7789_2_DRIVER\n            bool \"ST7789 - 2\"\n            help\n                Minimal configuration option, define additional parameters below for this display\n        config TFT_R61581_DRIVER\n            bool \"R61581\"\n        config TFT_RM68140_DRIVER\n            bool \"RM68140\"\n        config TFT_ST7796_DRIVER\n            bool \"ST7796\"\n        config TFT_SSD1351_DRIVER\n            bool \"SSD1351\"\n        config TFT_SSD1963_480_DRIVER\n            bool \"SSD1963_480\"\n        config TFT_SSD1963_800_DRIVER\n            bool \"SSD1963_800\"\n        config TFT_SSD1963_800ALT_DRIVER\n            bool \"SSD1963_800ALT\"\n        config TFT_ILI9225_DRIVER\n            bool \"ILI9225\"\n        config TFT_GC9A01_DRIVER\n            bool \"GC9A01\"\n    endchoice\n\n    if TFT_ST7735_DRIVER || TFT_ST7789_DRIVER || TFT_ST7789_2_DRIVER || TFT_ILI9341_DRIVER || TFT_ILI9341_2_DRIVER\n        choice TFT_COLOR_ORDER\n            prompt \"Define the colour order\"\n            help\n                Define the colour order IF the blue and red are swapped on your display\n\n            config TFT_RGB_ORDER\n                bool \"RGB\"\n            config TFT_BGR_ORDER\n                bool \"BGR\"\n        endchoice\n    endif\n\n    config TFT_M5STACK\n        bool \"M5Stack\"\n        depends on TFT_ILI9341_DRIVER || TFT_ILI9341_2_DRIVER\n        help\n            Enable if using M5Stack module with integrated ILI9341\n\n    if TFT_ST7735_DRIVER || TFT_ST7789_DRIVER || TFT_ST7789_2_DRIVER || TFT_ILI9163_DRIVER || TFT_GC9A01_DRIVER\n        config TFT_WIDTH\n            int \"LCD pixel width in portrait orientation\"\n            default 128\n            range 0 1024\n\n        config TFT_HEIGHT\n            int \"LCD pixel height in portrait orientation\"\n            default 240\n            range 0 1024\n    endif\n\n    if TFT_ST7735_DRIVER\n        choice TFT_ST7735_TYPE\n            prompt \"Define the type of display\"\n            help\n                Try out the different options below if the screen does not display graphics\n                correctly,e.g. colours wrong, mirror images, or stray pixels at the edges.\n\n            config TFT_ST7735_INITB\n                bool \"INITB\"\n            config TFT_ST7735_GREENTAB\n                bool \"GREENTAB\"\n            config TFT_ST7735_GREENTAB2\n                bool \"GREENTAB2\"\n            config TFT_ST7735_GREENTAB3\n                bool \"GREENTAB3\"\n            config TFT_ST7735_GREENTAB128\n                bool \"GREENTAB128\"\n                help\n                    For 128 x 128 display\n            config TFT_ST7735_GREENTAB160x80\n                bool \"GREENTAB160x80\"\n                help\n                    For 160 x 80 display (BGR, inverted, 26 offset)\n            config TFT_ST7735_REDTAB\n                bool \"REDTAB\"\n            config TFT_ST7735_BLACKTAB\n                bool \"BLACKTAB\"\n            config TFT_ST7735_REDTAB160x80\n                bool \"REDTAB160x80\"\n                help\n                    For 160 x 80 display with 24 pixel offset\n        endchoice\n    endif\n\n    choice TFT_COLOR_INVERSION\n        prompt \"Color inversion correction\"\n        help \n            If colours are inverted (white shows as black) then try changing this option.\"\n\n        config TFT_INVERSION_DISABLE\n            bool \"None\"\n        config TFT_INVERSION_ON\n            bool \"On\"\n        config TFT_INVERSION_OFF\n            bool \"Off\"\n            \n    endchoice\n\n    choice TFT_INTERFACE\n        prompt \"LCD Interface\"\n        default TFT_SPI\n        help\n            Communication interface between the microcontroller and the LCD.\n        config TFT_SPI\n            bool \"SPI\"\n        config TFT_PARALLEL_8_BIT\n            bool \"Parallel (8-bit)\"\n    endchoice\n    \n    menu \"Display Data pins\"\n        depends on TFT_PARALLEL_8_BIT\n        config TFT_D0\n            int \"Data 0 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D1\n            int \"Data 1 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D2\n            int \"Data 2 pin\"\n            default -1\n            range -1 31\n        \n        config TFT_D3\n            int \"Data 3 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D4\n            int \"Data 4 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D5\n            int \"Data 5 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D6\n            int \"Data 6 pin\"\n            default -1\n            range -1 31\n\n        config TFT_D7\n            int \"Data 7 pin\"\n            default -1\n            range -1 31\n\n        config TFT_WR\n            int \"Write strobe pin\"\n            default -1\n            range -1 31\n\n        config TFT_RD\n            int \"Read strobe pin\"\n            default -1\n            range -1 33\n    endmenu\n\n    menu \"Display SPI config\"\n        depends on TFT_SPI\n    \n        choice TFT_SPI_PORT\n            prompt \"SPI port\"\n            default TFT_VSPI_PORT\n            help\n                The ESP32 has 2 free SPI ports i.e. VSPI (SPI2) and HSPI (SPI3),\n                the VSPI is the default. If the VSPI port is in use and pins are\n                not accessible (e.g. TTGO T-Beam) then use the HSPI port for the\n                TFT display.\n            config TFT_VSPI_PORT\n                bool \"VSPI (SPI2)\"\n            config TFT_HSPI_PORT\n                bool \"HSPI (SPI3)\"\n        endchoice\n\n        config TFT_MISO\n            int \"TFT MISO pin\"\n            default -1\n            range -1 32 if IDF_TARGET_ESP32\n            range -1 45 if IDF_TARGET_ESP32S2\n            range -1 48 if IDF_TARGET_ESP32S3\n            help\n                Master In Slave Out pin.\n                Can be labelled as SDO in some displays\n\n        config TFT_MOSI\n            int \"TFT MOSI pin\"\n            default -1\n            range -1 32 if IDF_TARGET_ESP32\n            range -1 45 if IDF_TARGET_ESP32S2\n            range -1 48 if IDF_TARGET_ESP32S3\n            help\n                Master Out Slave In pin.\n                Can be labelled as SDA or SDI in some displays\n            \n        config TFT_SCLK\n            int \"TFT Clock pin\"\n            default -1\n            range -1 32 if IDF_TARGET_ESP32\n            range -1 45 if IDF_TARGET_ESP32S2\n            range -1 48 if IDF_TARGET_ESP32S3\n            help\n                Labelled in some displays as WR\n\n        config TFT_SDA_READ\n            bool \"Use SDA line for reading\"\n            default \"n\"\n            help\n                Some displays support SPI reads via the MISO pin, other displays have a single\n                bi-directional SDA pin and the library will try to read this via the MOSI line\n\n        config TFT_SPI_FREQUENCY\n            int \"SPI Frequency (Hz)\"\n            default 27000000\n            range 1 80000000\n            help\n                Define the SPI clock frequency, this affects the graphics rendering speed. Too\n                fast and the TFT driver will not keep up and display corruption appears.\n                With an ILI9341 display 40MHz works OK, 80MHz sometimes fails\n                With a ST7735 display more than 27MHz may not work (spurious pixels and lines)\n                With an ILI9163 display 27 MHz works OK.\n\n        config TFT_SPI_READ_FREQ\n            int \"SPI Read Frequency (Hz)\"\n            default 20000000\n            range -1 80000000\n            help\n                Optional reduced SPI frequency for reading TFT.\n                Set to -1 to use the default frequency\n            \n    endmenu\n\n    menu \"Control Pin configuration\"\n        config TFT_CS\n            int \"TFT Chip Select pin\"\n            default -1\n            range -1 33 if IDF_TARGET_ESP32\n            range -1 45 if IDF_TARGET_ESP32S2\n            range -1 48 if IDF_TARGET_ESP32S3\n    \n        config TFT_DC\n            int \"TFT Data/Command pin\"\n            default -1\n            range -1 31\n            help\n                Labelled as DC or RS (Register Select) in some displays\n    \n        config TFT_RST\n            int \"TFT Reset pin\"\n            default -1\n            range -1 33 if IDF_TARGET_ESP32\n            range -1 45 if IDF_TARGET_ESP32S2\n            range -1 48 if IDF_TARGET_ESP32S3\n\n        config ENABLE_BL\n            bool \"Enable backlight control\"\n            default y\n        \n        if ENABLE_BL\n            config TFT_BL\n                int \"TFT Backlight pin\"\n                default -1\n                range -1 33 if IDF_TARGET_ESP32\n                range -1 45 if IDF_TARGET_ESP32S2\n                range -1 48 if IDF_TARGET_ESP32S3\n                help\n                    Pin for the backlight control signal\n        \n            choice TFT_BACKLIGHT_ON\n                bool \"Pin state to activate backlight\"\n                default TFT_BACKLIGHT_ON_HIGH\n                help\n                    The backlight will be turned ON when tft.begin() is called, but the library\n                    needs to know if the LEDs are ON with the pin HIGH or LOW.\n        \n                config TFT_BACKLIGHT_ON_HIGH\n                    bool \"HIGH\"\n                config TFT_BACKLIGHT_ON_LOW\n                    bool \"LOW\"            \n            endchoice\n        endif\n    \n        config TFT_BACKLIGHT_ON\n            int\n            default 1 if TFT_BACKLIGHT_ON_HIGH\n            default 0 if TFT_BACKLIGHT_ON_LOW\n    endmenu\n\n    menu \"Fonts\"\n        config TFT_LOAD_GLCD\n            bool \"Font 1: Original Adafruit 8 pixel font needs ~1820 bytes in FLASH\"\n            default \"y\"\n\n        config TFT_LOAD_FONT2\n            bool \"Font 2: Small 16 pixel high font, needs ~3534 bytes in FLASH, 96 characters\"\n            default \"y\"\n\n        config TFT_LOAD_FONT4\n            bool \"Font 4: Medium 26 pixel high font, needs ~5848 bytes in FLASH, 96 characters\"\n            default \"y\"\n\n        config TFT_LOAD_FONT6\n            bool \"Font 6: Large 48 pixel font, needs ~2666 bytes in FLASH, only characters 1234567890:-.apm\"\n            default \"y\"\n\n        config TFT_LOAD_FONT7\n            bool \"Font 7: 7 segment 48 pixel font, needs ~2438 bytes in FLASH, only characters 1234567890:.\"\n            default \"y\"\n\n        config TFT_LOAD_FONT8\n            bool \"Font 8: Large 75 pixel font needs ~3256 bytes in FLASH, only characters 1234567890:-.\"\n            default \"y\"\n\n        config TFT_LOAD_GFXFF\n            bool \"FreeFonts: Include access to the 48 Adafruit_GFX free fonts FF1 to FF48 and custom fonts\"\n            default \"y\"\n\n        config TFT_SMOOTH_FONT\n            bool \"Smooth Fonts\"\n            default \"y\"\n    endmenu\n    \n    menu \"Touch screen configuration\"\n        config ENABLE_TOUCH\n            bool \"Enable Touch\"\n            default n\n\n        if ENABLE_TOUCH\n            config TOUCH_CS\n                int \"Touch chip select pin\"\n                default -1\n                range -1 33 if IDF_TARGET_ESP32\n                range -1 45 if IDF_TARGET_ESP32S2\n                range -1 48 if IDF_TARGET_ESP32S3\n\n            config SPI_TOUCH_FREQUENCY\n                int \"SPI frequency for XPT2046 chip (Hz)\"\n                default 2500000\n                range 1 80000000\n        endif\n    endmenu\n\n    menu \"Other settings\"\n        config DISABLE_WARNINGS\n            bool \"Disable Library warnings\"\n            default n\n    endmenu\n\nendmenu\n"
        },
        {
          "name": "Processors",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.9482421875,
          "content": "A [\"Discussions\"](https://github.com/Bodmer/TFT_eSPI/discussions) facility has been added for Q&A etc. Use the [\"Issues\"](https://github.com/Bodmer/TFT_eSPI/issues) tab only for problems with the library. Thanks!\n# News\n1. The Create_font Processing sketch has been updated to automatically create a complete C header file. The automatic opening of the font folder can also be disabled within the Processing sketch. (Thanks to Pierre-Loup Martin).\n\n2. New board setup files have been added for the Seeed XIAO with round display, LilyGo T-Embed S3, LilyGo_T_QT_Pro_S3, ESP32 S3 Box and ESP32_S3_Box_Lite. The \"RPi\" interface style boards are now supported with the ESP32 S3.\n\n3. New functions have been added to draw smooth (antialiased) arcs, circles, and rounded rectangle outlines. New sketches are provided in the \"Smooth Graphics\" examples folder. Arcs can be drawn with or without anti-aliasing (which will then render faster). The arc ends can be straight or rounded. The arc drawing algorithm uses an optimised fixed point sqrt() function to improve performance on processors that do not have a hardware Floating Point Unit (e.g. RP2040). Here are two demo images, on the left smooth (anti-aliased) arcs with rounded ends, the image to the right is the same resolution (grabbed from the same 240x240 TFT) with the smoothing diasbled (no anti-aliasing):\n\n      ![arcs](https://github.com/Bodmer/Github-images/blob/main/aa_arc_240x240.png)  ![pixelated_arcs](https://github.com/Bodmer/Github-images/blob/main/no_aa_arc_240x240.png)\n\n      Here the smooth arcs have been used to create anti-aliased meter gauges on a 320x240 TFT:\n \n      ![arcs](https://github.com/Bodmer/Github-images/blob/main/xarc_meters_320x240.png)\n\n4. An excellent new compatible library is available which can render TrueType fonts on a TFT screen (or into a sprite). This has been developed by [takkaO](https://github.com/takkaO/OpenFontRender). The library provides access to compact font files, with fully scaleable anti-aliased glyphs. Left, middle and right justified text can also be printed to the screen. I have added TFT_eSPI specific examples to the OpenFontRender library and tested on RP2040 and ESP32 processors, the ESP8266 does not have sufficient RAM due to the glyph render complexity. Here is a demo screen where a single 12kbyte font file binary was used to render fully anti-aliased glyphs of gradually increasing size on a 320x480 TFT screen:\n\n      ![ttf_font_demo](https://i.imgur.com/bKkilIb.png)\n\n5. New GUI examples have been added for sliders, buttons, graphs and meters. These examples require a new support library here:\n\n   [TFT_eWidget](https://github.com/Bodmer/TFT_eWidget)\n\n6. Support has been added in v2.4.70 for the RP2040 with 16-bit parallel displays. This has been tested and the screen update performance is very good (4ms to clear 320 x 480 screen with HC8357C). The use of the RP2040 PIO makes it easy to change the write cycle timing for different displays. DMA with 16-bit transfers is also supported.\n\n7. Support for the ESP32-S2, ESP32-S3 and ESP32-C3 has been added (DMA only on ESP32 S3 at the moment). Tested with v2.0.3 RC1 of the ESP32 board package. Example setups:\n\n      [Setup70_ESP32_S2_ILI9341.h](https://github.com/Bodmer/TFT_eSPI/blob/master/User_Setups/Setup70_ESP32_S2_ILI9341.h)\n      \n      [Setup70b_ESP32_S3_ILI9341.h](https://github.com/Bodmer/TFT_eSPI/blob/master/User_Setups/Setup70b_ESP32_S3_ILI9341.h)\n      \n      [Setup70c_ESP32_C3_ILI9341.h](https://github.com/Bodmer/TFT_eSPI/blob/master/User_Setups/Setup70c_ESP32_C3_ILI9341.h)\n\n      [Setup70d_ILI9488_S3_Parallel.h](https://github.com/Bodmer/TFT_eSPI/blob/master/User_Setups/Setup70d_ILI9488_S3_Parallel.h)\n\n8. Smooth fonts can now be rendered direct to the TFT with very little flicker for quickly changing values. This is achieved by a line-by-line and block-by-block update of the glyph area without drawing pixels twice. This is a \"breaking\" change for some sketches because a new true/false parameter is needed to render the background. The default is false if the parameter is missing, Examples:\n\n      tft.setTextColor(TFT_WHITE, TFT_BLUE, true);\n      spr.setTextColor(TFT_BLUE, TFT_BLACK, true);\n\nNote: background rendering for Smooth fonts is also now available when using the print stream e.g. with: tft.println(\"Hello World\");\n\n9. New anti-aliased graphics functions to draw lines, wedge shaped lines, circles and rounded rectangles. [Examples are included](https://github.com/Bodmer/TFT_eSPI/tree/master/examples/Smooth%20Graphics). Examples have also been added to [display PNG compressed images](https://github.com/Bodmer/TFT_eSPI/tree/master/examples/PNG%20Images) (note: requires ~40kbytes RAM).\n\n10. Users of PowerPoint experienced with running macros may be interested in the [pptm sketch generator here](https://github.com/Bodmer/PowerPoint_to_sketch), this converts graphics and tables drawn in PowerPoint slides into an Arduino sketch that renders the graphics on a 480x320 TFT. This is based on VB macros [created by Kris Kasprzak here](https://github.com/KrisKasprzak/Powerpoint-ILI9341_t3).\n\n11. The library contains two new functions for rectangles filled with a horizontal or vertical coloured gradient:\n\n      tft.fillRectHGradient(x, y, w, h, color1, color2);\n  \n      tft.fillRectVGradient(x, y, w, h, color1, color2);\n      \n      ![Gradient](https://i.imgur.com/atR0DmP.png)\n\n12. The RP2040 8-bit parallel interface uses the PIO. The PIO now manages the \"setWindow\" and \"block fill\" actions, releasing the processor for other tasks when areas of the screen are being filled with a colour. The PIO can optionally be used for SPI interface displays if #define RP2040_PIO_SPI is put in the setup file. Touch screens and pixel read operations are not supported when the PIO interface is used.\nThe RP2040 PIO features only work with [Earle Philhower's board package](https://github.com/earlephilhower/arduino-pico), NOT the Arduino Mbed version.\n\nThe use of PIO for SPI allows the RP2040 to be over-clocked (up to 250MHz works on my boards) in Earle's board package whilst still maintaining high SPI clock rates.\n\n# TFT_eSPI\n\nA feature rich Arduino IDE compatible graphics and fonts library for 32-bit processors. The library is targeted at 32-bit processors, it  has been performance optimised for RP2040, STM32, ESP8266 and ESP32 types, other 32-bit processors may be used but will use the slower generic Arduino interface calls. The library can be loaded using the Arduino IDE's Library Manager. Direct Memory Access (DMA) can be used with the ESP32, RP2040 and STM32 processors with SPI interface displays to improve rendering performance. DMA with a parallel interface (8 and 16-bit) is only supported with the RP2040.\n\nThe updates for the ESP32 S2/C3/S3 means that the library requires the ESP32 Arduino board package 2.x.x or later.\n\nThe screen controller, interface pins and library configuration settings must be defined inside the library. They can NOT be defined in the Arduino sketch. See the User_Setup_Select.h file for details. This approach has significant advantages, it keeps the examples clean from long configuration options and once the setup is defined any example can be run without modification. PlatformIO users can define these settings on a per project basis within a platformio.ini file, see Docs folder in library.\n\nLots of example sketches are provided which demonstrate using the functions in the library. Due to the popularity of the library there are lots of online tutorials for TFT_eSPI that have been created by enthusiastic users.\n\nOptimised drivers have been tested with the following processors:\n\n* RP2040, e.g. Raspberry Pi Pico\n* ESP32 and ESP32-S2, ESP32-C3, ESP32-S3\n* ESP8266\n* STM32F1xx, STM32F2xx, STM32F4xx, STM32F767 (higher RAM processors recommended)\n\nThe library supports the following interface types for these processors:\n\n| Processor | 4 wire SPI | 8-bit parallel | 16-bit parallel |   DMA support    |\n|-----------|    :---:   |     :---:      |      :---:      |       :---:      |\n| RP2040    |     Yes    |      Yes       |       Yes       |  Yes (all)       |\n| ESP32     |     Yes    |      Yes       |       No        |  Yes (SPI only)  |\n| ESP32 C3  |     Yes    |      No        |       No        |  No              |\n| ESP32 S2  |     Yes    |      No        |       No        |  No              |\n| ESP32 S3  |     Yes    |      Yes       |       No        |  Yes (SPI only)  |\n| ESP8266   |     Yes    |      No        |       No        |  No              |\n| STM32Fxxx |     Yes    |      Yes       |       No        |  Yes (SPI only)  |\n| Other     |     Yes    |      No        |       No        |  No              |\n\nFor other (generic) processors only SPI interface displays are supported and the slower Arduino SPI library functions are used by the library. Higher clock speed processors such as used for the Teensy 3.x and 4.x boards will still provide a very good performance with the generic Arduino SPI functions.\n\n4 wire SPI means the display must have SPI interface comaptible signals and a \"Data/Command\" control signal, this signal line is sometimes labelled DC, RS or A0. \n\nDue to lack of GPIO pins the 8-bit parallel interface is NOT supported on the ESP8266. 8-bit parallel interface TFTs  (e.g. UNO format mcufriend shields) can used with the STM32Fxxx Nucleo 64/144 range or the UNO format ESP32 (see below for ESP32).\n\nSupport for the XPT2046 touch screen controller is built into the library and can be used with SPI interface displays. Third party touch support libraries are also available when using a display parallel interface.\n\nDisplays using the following controllers are supported:\n\n* GC9A01\n* ILI9163\n* ILI9225\n* ILI9341\n* ILI9342\n* ILI9481 (DMA not supported with SPI)\n* ILI9486 (DMA not supported with SPI)\n* ILI9488 (DMA not supported with SPI)\n* HX8357B (16-bit parallel tested with RP2040)\n* HX8357C (16-bit parallel tested with RP2040)\n* HX8357D\n* R61581\n* RM68120 (support files added but untested)\n* RM68140\n* S6D02A1\n* SSD1351\n* SSD1963 (this controller only has a parallel interface option)\n* ST7735\n* ST7789\n* ST7796\n\nILI9341 and ST7796 SPI based displays are recommended as starting point for experimenting with this library.\n\nThe library supports some TFT displays designed for the Raspberry Pi (RPi) that are based on a ILI9486 or ST7796 driver chip with a 480 x 320 pixel screen. The ILI9486 RPi display must be of the Waveshare design and use a 16-bit serial interface based on the 74HC04, 74HC4040 and 2 x 74HC4094 logic chips. Note that due to design variations between these displays not all RPi displays will work with this library, so purchasing a RPi display of these types solely for use with this library is NOT recommended.\n\nA \"good\" RPi display is the [MHS-4.0 inch Display-B type ST7796](http://www.lcdwiki.com/MHS-4.0inch_Display-B) which provides good performance. This has a dedicated controller and can be clocked at up to 80MHz with the ESP32 (125MHz with overclocked RP2040, 55MHz with STM32 and 40MHz with ESP8266). The [MHS-3.5 inch RPi ILI9486](http://www.lcdwiki.com/MHS-3.5inch_RPi_Display) based display is also supported, however the MHS ILI9341 based display of the same type does NOT work with this library.\n\nSome displays permit the internal TFT screen RAM to be read, a few of the examples use this feature. The TFT_Screen_Capture example allows full screens to be captured and sent to a PC, this is handy to create program documentation.\n\nThe library includes a \"Sprite\" class, this enables flicker free updates of complex graphics. Direct writes to the TFT with graphics functions are still available, so existing sketches do not need to be changed.\n\n# Sprites\n\nA Sprite is notionally an invisible graphics screen that is kept in the processors RAM. Graphics can be drawn into the Sprite just as they can be drawn directly to the screen. Once the Sprite is completed it can be plotted onto the screen in any position. If there is sufficient RAM then the Sprite can be the same size as the screen and used as a frame buffer. Sprites by default use 16-bit colours, the bit depth can be set to 8 bits (256 colours) , or 1 bit (any 2 colours) to reduce the RAM needed. On an ESP8266 the largest 16-bit colour Sprite that can be created is about 160x128 pixels, this consumes 40Kbytes of RAM. On an ESP32 the workspace RAM is more limited than the datasheet implies so a 16-bit colour Sprite is limited to about 200x200 pixels (~80Kbytes), an 8-bit sprite to 320x240 pixels (~76kbytes). A 1 bit per pixel Sprite requires only 9600 bytes for a full 320 x 240 screen buffer, this is ideal for supporting use with 2 colour bitmap fonts.\n\nOne or more sprites can be created, a sprite can be any pixel width and height, limited only by available RAM. The RAM needed for a 16-bit colour depth Sprite is (2 x width x height) bytes, for a Sprite with 8-bit colour depth the RAM needed is (width x height) bytes. Sprites can be created and deleted dynamically as needed in the sketch, this means RAM can be freed up after the Sprite has been plotted on the screen, more RAM intensive WiFi based code can then be run and normal graphics operations still work.\n\nDrawing graphics into a sprite is very fast, for those familiar with the Adafruit \"graphicstest\" example, this whole test completes in 18ms in a 160x128 sprite. Examples of sprite use can be found in the \"examples/Sprite\" folder.\n\nSprites can be plotted to the TFT with one colour being specified as \"transparent\", see Transparent_Sprite_Demo example.\n\nIf an ESP32 board has SPIRAM (i.e. PSRAM) fitted then Sprites will use the PSRAM memory and large full screen buffer Sprites can be created. Full screen Sprites take longer to render (~45ms for a 320 x 240 16-bit Sprite), so bear that in mind.\n\nThe \"Animated_dial\" example shows how dials can be created using a rotated Sprite for the needle. To run this example the TFT interface must support reading from the screen RAM (not all do). The dial rim and scale is a jpeg image, created using a paint program.\n\n![Animated_dial](https://i.imgur.com/S736Rg6.png)\n\n\n# Touch controller support\n\nThe XPT2046 touch screen controller is supported for SPI based displays only. The SPI bus for the touch controller is shared with the TFT and only an additional chip select line is needed. This support will eventually be deprecated when a suitable touch screen library is available.\n\nThe Button class from Adafruit_GFX is incorporated, with the enhancement that the button labels can be in any font.\n\n# ESP8266 overlap mode\n\nThe library supports SPI overlap on the ESP8266 so the TFT screen can share MOSI, MISO and SCLK pins with the program FLASH, this frees up GPIO pins for other uses. Only one SPI device can be connected to the FLASH pins and the chips select for the TFT must be on pin D3 (GPIO0).\n\n\n# Fonts\n\nThe library contains proportional fonts, different sizes can be enabled/disabled at compile time to optimise the use of FLASH memory. Anti-aliased (smooth) font files in vlw format stored in SPIFFS are supported. Any 16-bit Unicode character can be included and rendered, this means many language specific characters can be rendered to the screen.\n\nThe library is based on the Adafruit GFX and Adafruit driver libraries and the aim is to retain compatibility. Significant additions have been made to the library to boost the speed for the different processors (it is typically 3 to 10 times faster) and to add new features. The new graphics functions include different size proportional fonts and formatting features. There are lots of example sketches to demonstrate the different features and included functions.\n\nConfiguration of the library font selections, pins used to interface with the TFT and other features is made by editing the User_Setup.h file in the library folder, or by selecting your own configuration in the \"User_Setup_Selet,h\" file.  Fonts and features can easily be enabled/disabled by commenting out lines.\n\n\n# Anti-aliased Fonts\n\nAnti-aliased (smooth) font files in \"vlw\" format are generated by the free [Processing IDE](https://processing.org/) using a sketch included in the library Tools folder. This sketch with the Processing IDE can be used to generate font files from your computer's font set or any TrueType (.ttf) font, the font file can include **any** combination of 16-bit Unicode characters. This means Greek, Japanese and any other UCS-2 glyphs can be used. Character arrays and Strings in UTF-8 format are supported.\n\nThe .vlw files must be uploaded to the processors FLASH filing system (SPIFFS, LittleFS or SD card) for use. Alternatively the .vlw files can be converted to C arrays (see \"Smooth Font -> FLASH_Array\" examples) and stored directly in FLASH as part of the compile process.  The array based approach is convenient, provides performance improvements and is suitable where: either use of a filing system is undesirable, or the processor type (e.g. STM32) does not support a FLASH based filing system.\n\nHere is the Adafruit_GFX \"FreeSans12pt\" bitmap font compared to the same font drawn as anti-aliased:\n\n![Smooth_font](https://i.imgur.com/gAeDPFY.png)\n\nThe smooth font example displays the following screen:\n\n![Example](https://i.imgur.com/xJF0Oz7.png)\n\nIt would be possible to compress the vlw font files but the rendering performance to a TFT is still good when storing the font file(s) in SPIFFS, LittleFS or FLASH arrays.\n\nHere is an example screenshot showing the anti-aliased Hiragana character Unicode block (0x3041 to 0x309F) in 24pt from the Microsoft Yahei font:\n\n![Hiragana glyphs](https://i.imgur.com/jeXf2st.png)\n\nAnti-aliased fonts can also be drawn over a gradient background with a callback to fetch the background colour of each pixel. This pixel colour can be set by the gradient algorithm or by reading back the TFT screen memory (if reading the display is supported).\n\nAnti-aliased fonts cannot be scaled with setTextSize so you need to create a font for each size you need. See examples.\n\n# 8-bit parallel support\n\nThe common 8-bit \"Mcufriend\" shields are supported for the STM Nucleo 64/144 boards and ESP32 UNO style board. The STM32 \"Blue/Black Pill\" boards can also be used with 8-bit parallel displays.\n\nThe ESP32 board I have been using for testing has the following pinout:\n\n![Example](https://i.imgur.com/bvM6leE.jpg)\n\nUNO style boards with a Wemos R32(ESP32) label are also available at low cost with the same pinout.\n\nUnfortunately the typical UNO/mcufriend TFT display board maps LCD_RD, LCD_CS and LCD_RST signals to the ESP32 analogue pins 35, 34 and 36 which are input only.  To solve this I linked in the 3 spare pins IO15, IO33 and IO32 by adding wires to the bottom of the board as follows:\n\nIO15 wired to IO35\n\nIO33 wired to IO34\n\nIO32 wired to IO36\n\nThis is an [example setup file](https://github.com/Bodmer/TFT_eSPI/blob/master/User_Setups/Setup14_ILI9341_Parallel.h) with the correct GPIO for this UNO board.\n\n![Example](https://i.imgur.com/pUZn6lF.jpg)\n\nIf the display board is fitted with a resistance based touch screen then this can be used by performing the modifications described here and the fork of the Adafruit library:\nhttps://github.com/s60sc/Adafruit_TouchScreen\n\n# Tips\nIf you load a new copy of TFT_eSPI then it will overwrite your setups if they are kept within the TFT_eSPI folder. One way around this is to create a new folder in your Arduino library folder called \"TFT_eSPI_Setups\". You then place your custom setup.h files in there. After an upgrade simply edit the User_Setup_Select.h file to point to your custom setup file e.g.:\n```\n#include <../TFT_eSPI_Setups/my_custom_setup.h>\n```\nYou must make sure only one setup file is called. In the custom setup file I add the file path as a commented out first line that can be cut and pasted back into the upgraded User_Setup_Select.h file.  The ../ at the start of the path means go up one directory level. Clearly you could use different file paths or directory names as long as it does not clash with another library or folder name.\n\nYou can take this one step further and have your own setup select file and then you only need to replace the Setup.h line reference in User_Setup_Select.h to, for example:\n```\n#include <../TFT_eSPI_Setups/my_setup_select.h>\n```\nTo select a new setup you then edit your own my_setup_select.h file (which will not get overwritten during an upgrade).\n"
        },
        {
          "name": "README.txt",
          "type": "blob",
          "size": 0.4111328125,
          "content": "This is a stand-alone library that contains both graphics functions\nand the TFT chip driver library. It supports the ESP8266, ESP32,\nSTM32 and RP2040 processors with performance optimised code. Other\nArduino IDE compatible boards are also supported but the library\nthen uses generic functions which will be slower. The library uses\n32-bit variables extensively so this will affect performance on 8\nand 16-bit processors.\n"
        },
        {
          "name": "TFT_Drivers",
          "type": "tree",
          "content": null
        },
        {
          "name": "TFT_config.h",
          "type": "blob",
          "size": 9.4765625,
          "content": "\n///////////////////////////////////////////////////////////\n/*           Support file for ESP32 IDF use              */\n/*              See library docs folder                  */\n/*                                                       */\n/*              DO NOT EDIT THIS FILE                    */\n/*                                                       */\n///////////////////////////////////////////////////////////\n\n/**\n * @file   TFT_config.h\n * @author Ricard Bitriá Ribes (https://github.com/dracir9)\n * Created Date: 22-01-2022\n * -----\n * Last Modified: 25-02-2023\n * Modified By: Ricard Bitriá Ribes\n * -----\n * @copyright (c) 2022 Ricard Bitriá Ribes\n */\n\n#ifndef TFT_CONFIG_H\n#define TFT_CONFIG_H\n\n#include \"sdkconfig.h\"\n\n/***************************************************************************************\n**                         Others\n***************************************************************************************/\n\n#ifdef CONFIG_DISABLE_WARNINGS\n    #define DISABLE_ALL_LIBRARY_WARNINGS\n#endif\n\n/***************************************************************************************\n**                         TFT_eSPI Configuration defines\n***************************************************************************************/\n// Override defaults\n#define USER_SETUP_LOADED\n\n/***************************************************************************************\n**                         Section 1: Load TFT driver\n***************************************************************************************/\n#if defined (CONFIG_TFT_ILI9341_DRIVER)\n    #define ILI9341_DRIVER\n#elif defined (CONFIG_TFT_ILI9341_2_DRIVER)\n    #define ILI9341_2_DRIVER\n#elif defined (CONFIG_TFT_ST7735_DRIVER)\n    #define ST7735_DRIVER\n#elif defined (CONFIG_TFT_ILI9163_DRIVER)\n    #define ILI9163_DRIVER\n#elif defined (CONFIG_TFT_S6D02A1_DRIVER)\n    #define S6D02A1_DRIVER\n#elif defined (CONFIG_TFT_HX8357D_DRIVER)\n    #define HX8357D_DRIVER\n#elif defined (CONFIG_TFT_ILI9481_DRIVER)\n    #define ILI9481_DRIVER\n#elif defined (CONFIG_TFT_ILI9486_DRIVER)\n    #define ILI9486_DRIVER\n#elif defined (CONFIG_TFT_ILI9488_DRIVER)\n    #define ILI9488_DRIVER\n#elif defined (CONFIG_TFT_ST7789_DRIVER)\n    #define ST7789_DRIVER\n#elif defined (CONFIG_TFT_ST7789_2_DRIVER)\n    #define ST7789_2_DRIVER\n#elif defined (CONFIG_TFT_R61581_DRIVER)\n    #define R61581_DRIVER\n#elif defined (CONFIG_TFT_RM68140_DRIVER)\n    #define RM68140_DRIVER\n#elif defined (CONFIG_TFT_ST7796_DRIVER)\n    #define ST7796_DRIVER\n#elif defined (CONFIG_TFT_SSD1351_DRIVER)\n    #define SSD1351_DRIVER\n#elif defined (CONFIG_TFT_SSD1963_480_DRIVER)\n    #define SSD1963_480_DRIVER\n#elif defined (CONFIG_TFT_SSD1963_800_DRIVER)\n    #define SSD1963_800_DRIVER\n#elif defined (CONFIG_TFT_SSD1963_800ALT_DRIVER)\n    #define SSD1963_800ALT_DRIVER\n#elif defined (CONFIG_TFT_ILI9225_DRIVER)\n    #define ILI9225_DRIVER\n#elif defined (CONFIG_TFT_GC9A01_DRIVER)\n    #define GC9A01_DRIVER\n#endif\n\n#ifdef CONFIG_TFT_RGB_ORDER\n    #define TFT_RGB_ORDER TFT_RGB\n#endif\n\n#ifdef CONFIG_TFT_BGR_ORDER\n    #define TFT_RGB_ORDER TFT_BGR\n#endif\n\n#ifdef CONFIG_TFT_M5STACK\n    #define M5STACK\n#endif\n\n#ifdef CONFIG_TFT_WIDTH\n    #define TFT_WIDTH   CONFIG_TFT_WIDTH\n#endif\n\n#ifdef CONFIG_TFT_HEIGHT\n    #define TFT_HEIGHT   CONFIG_TFT_HEIGHT\n#endif\n\n#if defined (CONFIG_TFT_ST7735_INITB)\n    #define ST7735_INITB\n#elif defined (CONFIG_TFT_ST7735_GREENTAB)\n    #define ST7735_GREENTAB\n#elif defined (CONFIG_TFT_ST7735_GREENTAB2)\n    #define ST7735_GREENTAB2\n#elif defined (CONFIG_TFT_ST7735_GREENTAB3)\n    #define ST7735_GREENTAB3\n#elif defined (CONFIG_TFT_ST7735_GREENTAB128)\n    #define ST7735_GREENTAB128\n#elif defined (CONFIG_TFT_ST7735_GREENTAB160x80)\n    #define ST7735_GREENTAB160x80\n#elif defined (CONFIG_TFT_ST7735_REDTAB)\n    #define ST7735_REDTAB\n#elif defined (CONFIG_TFT_ST7735_BLACKTAB)\n    #define ST7735_BLACKTAB\n#elif defined (CONFIG_TFT_ST7735_REDTAB160x80)\n    #define ST7735_REDTAB160x80\n#endif\n\n#if defined (CONFIG_TFT_INVERSION_ON)\n    #define TFT_INVERSION_ON\n#elif defined (CONFIG_TFT_INVERSION_OFF)\n    #define TFT_INVERSION_OFF\n#endif\n\n/***************************************************************************************\n**                         Section 2: General Pin configuration\n***************************************************************************************/\n// General pins\n#if CONFIG_TFT_CS == -1\n    #error \"Invalid Chip Select pin. Check TFT_eSPI configuration\"\n#else\n    #define TFT_CS          CONFIG_TFT_CS\n#endif\n\n#if CONFIG_TFT_DC == -1\n    #error \"Invalid Data/Command pin. Check TFT_eSPI configuration\"\n#else\n    #define TFT_DC          CONFIG_TFT_DC\n#endif\n\n#if CONFIG_TFT_RST == -1\n    #if !defined(DISABLE_ALL_LIBRARY_WARNINGS)\n        #warning \"Invalid Reset pin. Check TFT_eSPI configuration\"\n    #endif\n#else\n    #define TFT_RST         CONFIG_TFT_RST\n#endif\n\n// Backlight config\n#ifdef CONFIG_ENABLE_BL\n    #if CONFIG_TFT_BL == -1\n        #error \"Invalid backlight control pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_BL      CONFIG_TFT_BL\n    #endif\n\n    #define TFT_BACKLIGHT_ON CONFIG_TFT_BACKLIGHT_ON\n#endif\n\n\n/***************************************************************************************\n**                         Section 3: Data bus Pin configuration\n***************************************************************************************/\n\n// 8 BIT PARALLEL BUS\n#ifdef CONFIG_TFT_PARALLEL_8_BIT\n\n    #define TFT_PARALLEL_8_BIT\n\n    #if CONFIG_TFT_D0 == -1\n        #error \"Invalid Data 0 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D0      CONFIG_TFT_D0\n    #endif\n\n    #if CONFIG_TFT_D1 == -1\n        #error \"Invalid Data 1 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D1      CONFIG_TFT_D1\n    #endif\n\n    #if CONFIG_TFT_D2 == -1\n        #error \"Invalid Data 2 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D2      CONFIG_TFT_D2\n    #endif\n\n    #if CONFIG_TFT_D3 == -1\n        #error \"Invalid Data 3 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D3      CONFIG_TFT_D3\n    #endif\n\n    #if CONFIG_TFT_D4 == -1\n        #error \"Invalid Data 4 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D4      CONFIG_TFT_D4\n    #endif\n\n    #if CONFIG_TFT_D5 == -1\n        #error \"Invalid Data 5 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D5      CONFIG_TFT_D5\n    #endif\n\n    #if CONFIG_TFT_D6 == -1\n        #error \"Invalid Data 6 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D6      CONFIG_TFT_D6\n    #endif\n\n    #if CONFIG_TFT_D7 == -1\n        #error \"Invalid Data 7 pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_D7      CONFIG_TFT_D7\n    #endif\n    \n    #if CONFIG_TFT_WR == -1\n        #error \"Invalid Write strobe pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_WR      CONFIG_TFT_WR\n    #endif\n\n    #if CONFIG_TFT_RD == -1\n        #error \"Invalid Read strobe pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_RD      CONFIG_TFT_RD\n    #endif\n\n// SPI BUS\n#else\n    #if CONFIG_TFT_HSPI_PORT\n        #define USE_HSPI_PORT\n    #endif\n\n    #if CONFIG_TFT_MISO != -1\n        #define TFT_MISO      CONFIG_TFT_MISO\n    #endif\n\n    #if CONFIG_TFT_MOSI == -1\n        #error \"Invalid MOSI pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_MOSI      CONFIG_TFT_MOSI\n    #endif\n\n    #if CONFIG_TFT_SCLK == -1\n        #error \"Invalid Clock pin. Check TFT_eSPI configuration\"\n    #else\n        #define TFT_SCLK      CONFIG_TFT_SCLK\n    #endif\n\n    #define SPI_FREQUENCY   CONFIG_TFT_SPI_FREQUENCY\n\n    #if CONFIG_TFT_SPI_READ_FREQ != -1\n        #define SPI_READ_FREQUENCY CONFIG_TFT_SPI_READ_FREQ\n    #endif\n    \n    #ifdef CONFIG_TFT_SDA_READ\n        #define TFT_SDA_READ\n    #endif\n#endif\n\n\n/***************************************************************************************\n**                         Section 4: Setup Fonts\n***************************************************************************************/\n\n#ifdef CONFIG_TFT_LOAD_GLCD\n    #define LOAD_GLCD       // Font 1. Original Adafruit 8 pixel font needs ~1820 bytes in FLASH\n#endif\n\n#ifdef CONFIG_TFT_LOAD_FONT2\n    #define LOAD_FONT2      // Font 2. Small 16 pixel high font, needs ~3534 bytes in FLASH, 96 characters\n#endif\n\n#ifdef CONFIG_TFT_LOAD_FONT4\n    #define LOAD_FONT4      // Font 4. Medium 26 pixel high font, needs ~5848 bytes in FLASH, 96 characters\n#endif\n\n#ifdef CONFIG_TFT_LOAD_FONT6\n    #define LOAD_FONT6      // Font 6. Large 48 pixel font, needs ~2666 bytes in FLASH, only characters 1234567890:-.apm\n#endif\n\n#ifdef CONFIG_TFT_LOAD_FONT7\n    #define LOAD_FONT7      // Font 7. 7 segment 48 pixel font, needs ~2438 bytes in FLASH, only characters 1234567890:.\n#endif\n\n#ifdef CONFIG_TFT_LOAD_FONT8\n    #define LOAD_FONT8      // Font 8. Large 75 pixel font needs ~3256 bytes in FLASH, only characters 1234567890:-.\n#endif\n\n#ifdef CONFIG_TFT_LOAD_GFXFF\n    #define LOAD_GFXFF      // FreeFonts. Include access to the 48 Adafruit_GFX free fonts FF1 to FF48 and custom fonts\n#endif\n\n#if CONFIG_TFT_SMOOTH_FONT\n    #define SMOOTH_FONT\n#endif\n\n/***************************************************************************************\n**                         Section 5: Touchscreen configuration\n***************************************************************************************/\n\n#ifdef CONFIG_ENABLE_TOUCH\n    #if CONFIG_TOUCH_CS == -1\n        #error \"Invalid Touch Chip Select pin. Check TFT_eSPI configuration\"\n    #else\n        #define TOUCH_CS            CONFIG_TOUCH_CS\n    #endif\n\n    #define SPI_TOUCH_FREQUENCY CONFIG_SPI_TOUCH_FREQUENCY\n#endif\n\n#endif // TFT_CONFIG_H\n"
        },
        {
          "name": "TFT_eSPI.cpp",
          "type": "blob",
          "size": 191.4287109375,
          "content": "/***************************************************\n  Arduino TFT graphics library targeted at 32-bit\n  processors such as ESP32, ESP8266 and STM32.\n\n  This is a stand-alone library that contains the\n  hardware driver, the graphics functions and the\n  proportional fonts.\n\n  The larger fonts are Run Length Encoded to reduce their\n  size.\n\n  Created by Bodmer 2/12/16\n  Last update by Bodmer 20/03/20\n ****************************************************/\n\n#include \"TFT_eSPI.h\"\n\n#if defined (ESP32)\n  #if defined(CONFIG_IDF_TARGET_ESP32S3)\n    #include \"Processors/TFT_eSPI_ESP32_S3.c\" // Tested with SPI and 8-bit parallel\n  #elif defined(CONFIG_IDF_TARGET_ESP32C3)\n    #include \"Processors/TFT_eSPI_ESP32_C3.c\" // Tested with SPI (8-bit parallel will probably work too!)\n  #else\n    #include \"Processors/TFT_eSPI_ESP32.c\"\n  #endif\n#elif defined (ARDUINO_ARCH_ESP8266)\n  #include \"Processors/TFT_eSPI_ESP8266.c\"\n#elif defined (STM32) // (_VARIANT_ARDUINO_STM32_) stm32_def.h\n  #include \"Processors/TFT_eSPI_STM32.c\"\n#elif defined (ARDUINO_ARCH_RP2040)  || defined (ARDUINO_ARCH_MBED) // Raspberry Pi Pico\n  #include \"Processors/TFT_eSPI_RP2040.c\"\n#else\n  #include \"Processors/TFT_eSPI_Generic.c\"\n#endif\n\n#ifndef SPI_BUSY_CHECK\n  #define SPI_BUSY_CHECK\n#endif\n\n// Clipping macro for pushImage\n#define PI_CLIP                                        \\\n  if (_vpOoB) return;                                  \\\n  x+= _xDatum;                                         \\\n  y+= _yDatum;                                         \\\n                                                       \\\n  if ((x >= _vpW) || (y >= _vpH)) return;              \\\n                                                       \\\n  int32_t dx = 0;                                      \\\n  int32_t dy = 0;                                      \\\n  int32_t dw = w;                                      \\\n  int32_t dh = h;                                      \\\n                                                       \\\n  if (x < _vpX) { dx = _vpX - x; dw -= dx; x = _vpX; } \\\n  if (y < _vpY) { dy = _vpY - y; dh -= dy; y = _vpY; } \\\n                                                       \\\n  if ((x + dw) > _vpW ) dw = _vpW - x;                 \\\n  if ((y + dh) > _vpH ) dh = _vpH - y;                 \\\n                                                       \\\n  if (dw < 1 || dh < 1) return;\n\n/***************************************************************************************\n** Function name:           Legacy - deprecated\n** Description:             Start/end transaction\n***************************************************************************************/\n  void TFT_eSPI::spi_begin()       {begin_tft_write();}\n  void TFT_eSPI::spi_end()         {  end_tft_write();}\n  void TFT_eSPI::spi_begin_read()  {begin_tft_read(); }\n  void TFT_eSPI::spi_end_read()    {  end_tft_read(); }\n\n/***************************************************************************************\n** Function name:           begin_tft_write (was called spi_begin)\n** Description:             Start SPI transaction for writes and select TFT\n***************************************************************************************/\ninline void TFT_eSPI::begin_tft_write(void){\n  if (locked) {\n    locked = false; // Flag to show SPI access now unlocked\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n    spi.beginTransaction(SPISettings(SPI_FREQUENCY, MSBFIRST, TFT_SPI_MODE));\n#endif\n    CS_L;\n    SET_BUS_WRITE_MODE;  // Some processors (e.g. ESP32) allow recycling the tx buffer when rx is not used\n  }\n}\n\n// Non-inlined version to permit override\nvoid TFT_eSPI::begin_nin_write(void){\n  if (locked) {\n    locked = false; // Flag to show SPI access now unlocked\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n    spi.beginTransaction(SPISettings(SPI_FREQUENCY, MSBFIRST, TFT_SPI_MODE));\n#endif\n    CS_L;\n    SET_BUS_WRITE_MODE;  // Some processors (e.g. ESP32) allow recycling the tx buffer when rx is not used\n  }\n}\n\n/***************************************************************************************\n** Function name:           end_tft_write (was called spi_end)\n** Description:             End transaction for write and deselect TFT\n***************************************************************************************/\ninline void TFT_eSPI::end_tft_write(void){\n  if(!inTransaction) {      // Flag to stop ending transaction during multiple graphics calls\n    if (!locked) {          // Locked when beginTransaction has been called\n      locked = true;        // Flag to show SPI access now locked\n      SPI_BUSY_CHECK;       // Check send complete and clean out unused rx data\n      CS_H;\n      SET_BUS_READ_MODE;    // In case bus has been configured for tx only\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n      spi.endTransaction();\n#endif\n    }\n  }\n}\n\n// Non-inlined version to permit override\ninline void TFT_eSPI::end_nin_write(void){\n  if(!inTransaction) {      // Flag to stop ending transaction during multiple graphics calls\n    if (!locked) {          // Locked when beginTransaction has been called\n      locked = true;        // Flag to show SPI access now locked\n      SPI_BUSY_CHECK;       // Check send complete and clean out unused rx data\n      CS_H;\n      SET_BUS_READ_MODE;    // In case SPI has been configured for tx only\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n      spi.endTransaction();\n#endif\n    }\n  }\n}\n\n/***************************************************************************************\n** Function name:           begin_tft_read  (was called spi_begin_read)\n** Description:             Start transaction for reads and select TFT\n***************************************************************************************/\n// Reads require a lower SPI clock rate than writes\ninline void TFT_eSPI::begin_tft_read(void){\n  DMA_BUSY_CHECK; // Wait for any DMA transfer to complete before changing SPI settings\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n  if (locked) {\n    locked = false;\n    spi.beginTransaction(SPISettings(SPI_READ_FREQUENCY, MSBFIRST, TFT_SPI_MODE));\n    CS_L;\n  }\n#else\n  #if !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n    spi.setFrequency(SPI_READ_FREQUENCY);\n  #endif\n   CS_L;\n#endif\n  SET_BUS_READ_MODE;\n}\n\n/***************************************************************************************\n** Function name:           end_tft_read (was called spi_end_read)\n** Description:             End transaction for reads and deselect TFT\n***************************************************************************************/\ninline void TFT_eSPI::end_tft_read(void){\n#if defined (SPI_HAS_TRANSACTION) && defined (SUPPORT_TRANSACTIONS) && !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n  if(!inTransaction) {\n    if (!locked) {\n      locked = true;\n      CS_H;\n      spi.endTransaction();\n    }\n  }\n#else\n  #if !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n    spi.setFrequency(SPI_FREQUENCY);\n  #endif\n   if(!inTransaction) {CS_H;}\n#endif\n  SET_BUS_WRITE_MODE;\n}\n\n/***************************************************************************************\n** Function name:           setViewport\n** Description:             Set the clipping region for the TFT screen\n***************************************************************************************/\nvoid TFT_eSPI::setViewport(int32_t x, int32_t y, int32_t w, int32_t h, bool vpDatum)\n{\n  // Viewport metrics (not clipped)\n  _xDatum  = x; // Datum x position in screen coordinates\n  _yDatum  = y; // Datum y position in screen coordinates\n  _xWidth  = w; // Viewport width\n  _yHeight = h; // Viewport height\n\n  // Full size default viewport\n  _vpDatum = false; // Datum is at top left corner of screen (true = top left of viewport)\n  _vpOoB   = false; // Out of Bounds flag (true is all of viewport is off screen)\n  _vpX = 0;         // Viewport top left corner x coordinate\n  _vpY = 0;         // Viewport top left corner y coordinate\n  _vpW = width();   // Equivalent of TFT width  (Nb: viewport right edge coord + 1)\n  _vpH = height();  // Equivalent of TFT height (Nb: viewport bottom edge coord + 1)\n\n  // Clip viewport to screen area\n  if (x<0) { w += x; x = 0; }\n  if (y<0) { h += y; y = 0; }\n  if ((x + w) > width() ) { w = width()  - x; }\n  if ((y + h) > height() ) { h = height() - y; }\n\n  //Serial.print(\" x=\");Serial.print( x);Serial.print(\", y=\");Serial.print( y);\n  //Serial.print(\", w=\");Serial.print(w);Serial.print(\", h=\");Serial.println(h);\n\n  // Check if viewport is entirely out of bounds\n  if (w < 1 || h < 1)\n  {\n    // Set default values and Out of Bounds flag in case of error\n    _xDatum = 0;\n    _yDatum = 0;\n    _xWidth  = width();\n    _yHeight = height();\n    _vpOoB = true;      // Set Out of Bounds flag to inhibit all drawing\n    return;\n  }\n\n  if (!vpDatum)\n  {\n    _xDatum = 0; // Reset to top left of screen if not using a viewport datum\n    _yDatum = 0;\n    _xWidth  = width();\n    _yHeight = height();\n  }\n\n  // Store the clipped screen viewport metrics and datum position\n  _vpX = x;\n  _vpY = y;\n  _vpW = x + w;\n  _vpH = y + h;\n  _vpDatum = vpDatum;\n\n  //Serial.print(\" _xDatum=\");Serial.print( _xDatum);Serial.print(\", _yDatum=\");Serial.print( _yDatum);\n  //Serial.print(\", _xWidth=\");Serial.print(_xWidth);Serial.print(\", _yHeight=\");Serial.println(_yHeight);\n\n  //Serial.print(\" _vpX=\");Serial.print( _vpX);Serial.print(\", _vpY=\");Serial.print( _vpY);\n  //Serial.print(\", _vpW=\");Serial.print(_vpW);Serial.print(\", _vpH=\");Serial.println(_vpH);\n}\n\n/***************************************************************************************\n** Function name:           checkViewport\n** Description:             Check if any part of specified area is visible in viewport\n***************************************************************************************/\n// Note: Setting w and h to 1 will check if coordinate x,y is in area\nbool TFT_eSPI::checkViewport(int32_t x, int32_t y, int32_t w, int32_t h)\n{\n  if (_vpOoB) return false;\n  x+= _xDatum;\n  y+= _yDatum;\n\n  if ((x >= _vpW) || (y >= _vpH)) return false;\n\n  int32_t dx = 0;\n  int32_t dy = 0;\n  int32_t dw = w;\n  int32_t dh = h;\n\n  if (x < _vpX) { dx = _vpX - x; dw -= dx; x = _vpX; }\n  if (y < _vpY) { dy = _vpY - y; dh -= dy; y = _vpY; }\n\n  if ((x + dw) > _vpW ) dw = _vpW - x;\n  if ((y + dh) > _vpH ) dh = _vpH - y;\n\n  if (dw < 1 || dh < 1) return false;\n\n  return true;\n}\n\n/***************************************************************************************\n** Function name:           resetViewport\n** Description:             Reset viewport to whole TFT screen, datum at 0,0\n***************************************************************************************/\nvoid TFT_eSPI::resetViewport(void)\n{\n  // Reset viewport to the whole screen (or sprite) area\n  _vpDatum = false;\n  _vpOoB   = false;\n  _xDatum = 0;\n  _yDatum = 0;\n  _vpX = 0;\n  _vpY = 0;\n  _vpW = width();\n  _vpH = height();\n  _xWidth  = width();\n  _yHeight = height();\n}\n\n/***************************************************************************************\n** Function name:           getViewportX\n** Description:             Get x position of the viewport datum\n***************************************************************************************/\nint32_t  TFT_eSPI::getViewportX(void)\n{\n  return _xDatum;\n}\n\n/***************************************************************************************\n** Function name:           getViewportY\n** Description:             Get y position of the viewport datum\n***************************************************************************************/\nint32_t  TFT_eSPI::getViewportY(void)\n{\n  return _yDatum;\n}\n\n/***************************************************************************************\n** Function name:           getViewportWidth\n** Description:             Get width of the viewport\n***************************************************************************************/\nint32_t TFT_eSPI::getViewportWidth(void)\n{\n  return _xWidth;\n}\n\n/***************************************************************************************\n** Function name:           getViewportHeight\n** Description:             Get height of the viewport\n***************************************************************************************/\nint32_t TFT_eSPI::getViewportHeight(void)\n{\n  return _yHeight;\n}\n\n/***************************************************************************************\n** Function name:           getViewportDatum\n** Description:             Get datum flag of the viewport (true = viewport corner)\n***************************************************************************************/\nbool  TFT_eSPI::getViewportDatum(void)\n{\n  return _vpDatum;\n}\n\n/***************************************************************************************\n** Function name:           frameViewport\n** Description:             Draw a frame inside or outside the viewport of width w\n***************************************************************************************/\nvoid TFT_eSPI::frameViewport(uint16_t color, int32_t w)\n{\n  // Save datum position\n  bool _dT = _vpDatum;\n\n  // If w is positive the frame is drawn inside the viewport\n  // a large positive width will clear the screen inside the viewport\n  if (w>0)\n  {\n    // Set vpDatum true to simplify coordinate derivation\n    _vpDatum = true;\n    fillRect(0, 0, _vpW - _vpX, w, color);                // Top\n    fillRect(0, w, w, _vpH - _vpY - w - w, color);        // Left\n    fillRect(_xWidth - w, w, w, _yHeight - w - w, color); // Right\n    fillRect(0, _yHeight - w, _xWidth, w, color);         // Bottom\n  }\n  else\n  // If w is negative the frame is drawn outside the viewport\n  // a large negative width will clear the screen outside the viewport\n  {\n    w = -w;\n\n    // Save old values\n    int32_t _xT = _vpX; _vpX = 0;\n    int32_t _yT = _vpY; _vpY = 0;\n    int32_t _wT = _vpW;\n    int32_t _hT = _vpH;\n\n    // Set vpDatum false so frame can be drawn outside window\n    _vpDatum = false; // When false the full width and height is accessed\n    _vpH = height();\n    _vpW = width();\n\n    // Draw frame\n    fillRect(_xT - w - _xDatum, _yT - w - _yDatum, _wT - _xT + w + w, w, color); // Top\n    fillRect(_xT - w - _xDatum, _yT - _yDatum, w, _hT - _yT, color);             // Left\n    fillRect(_wT - _xDatum, _yT - _yDatum, w, _hT - _yT, color);                 // Right\n    fillRect(_xT - w - _xDatum, _hT - _yDatum, _wT - _xT + w + w, w, color);     // Bottom\n\n    // Restore old values\n    _vpX = _xT;\n    _vpY = _yT;\n    _vpW = _wT;\n    _vpH = _hT;\n  }\n\n  // Restore vpDatum\n  _vpDatum = _dT;\n}\n\n/***************************************************************************************\n** Function name:           clipAddrWindow\n** Description:             Clip address window x,y,w,h to screen and viewport\n***************************************************************************************/\nbool TFT_eSPI::clipAddrWindow(int32_t *x, int32_t *y, int32_t *w, int32_t *h)\n{\n  if (_vpOoB) return false; // Area is outside of viewport\n\n  *x+= _xDatum;\n  *y+= _yDatum;\n\n  if ((*x >= _vpW) || (*y >= _vpH)) return false;  // Area is outside of viewport\n\n  // Crop drawing area bounds\n  if (*x < _vpX) { *w -= _vpX - *x; *x = _vpX; }\n  if (*y < _vpY) { *h -= _vpY - *y; *y = _vpY; }\n\n  if ((*x + *w) > _vpW ) *w = _vpW - *x;\n  if ((*y + *h) > _vpH ) *h = _vpH - *y;\n\n  if (*w < 1 || *h < 1) return false; // No area is inside viewport\n\n  return true;  // Area is wholly or partially inside viewport\n}\n\n/***************************************************************************************\n** Function name:           clipWindow\n** Description:             Clip window xs,yx,xe,ye to screen and viewport\n***************************************************************************************/\nbool TFT_eSPI::clipWindow(int32_t *xs, int32_t *ys, int32_t *xe, int32_t *ye)\n{\n  if (_vpOoB) return false; // Area is outside of viewport\n\n  *xs+= _xDatum;\n  *ys+= _yDatum;\n  *xe+= _xDatum;\n  *ye+= _yDatum;\n\n  if ((*xs >= _vpW) || (*ys >= _vpH)) return false;  // Area is outside of viewport\n  if ((*xe <  _vpX) || (*ye <  _vpY)) return false;  // Area is outside of viewport\n\n  // Crop drawing area bounds\n  if (*xs < _vpX) *xs = _vpX;\n  if (*ys < _vpY) *ys = _vpY;\n\n  if (*xe > _vpW) *xe = _vpW - 1;\n  if (*ye > _vpH) *ye = _vpH - 1;\n\n  return true;  // Area is wholly or partially inside viewport\n}\n\n/***************************************************************************************\n** Function name:           TFT_eSPI\n** Description:             Constructor , we must use hardware SPI pins\n***************************************************************************************/\nTFT_eSPI::TFT_eSPI(int16_t w, int16_t h)\n{\n  _init_width  = _width  = w; // Set by specific xxxxx_Defines.h file or by users sketch\n  _init_height = _height = h; // Set by specific xxxxx_Defines.h file or by users sketch\n\n  // Reset the viewport to the whole screen\n  resetViewport();\n\n  rotation  = 0;\n  cursor_y  = cursor_x  = last_cursor_x = bg_cursor_x = 0;\n  textfont  = 1;\n  textsize  = 1;\n  textcolor   = bitmap_fg = 0xFFFF; // White\n  textbgcolor = bitmap_bg = 0x0000; // Black\n  padX        = 0;                  // No padding\n\n  _fillbg    = false;   // Smooth font only at the moment, force text background fill\n\n  isDigits   = false;   // No bounding box adjustment\n  textwrapX  = true;    // Wrap text at end of line when using print stream\n  textwrapY  = false;   // Wrap text at bottom of screen when using print stream\n  textdatum = TL_DATUM; // Top Left text alignment is default\n  fontsloaded = 0;\n\n  _swapBytes = false;   // Do not swap colour bytes by default\n\n  locked = true;           // Transaction mutex lock flag to ensure begin/endTranaction pairing\n  inTransaction = false;   // Flag to prevent multiple sequential functions to keep bus access open\n  lockTransaction = false; // start/endWrite lock flag to allow sketch to keep SPI bus access open\n\n  _booted   = true;     // Default attributes\n  _cp437    = false;    // Legacy GLCD font bug fix disabled by default\n  _utf8     = true;     // UTF8 decoding enabled\n\n#if defined (FONT_FS_AVAILABLE) && defined (SMOOTH_FONT)\n  fs_font  = true;     // Smooth font filing system or array (fs_font = false) flag\n#endif\n\n#if defined (ESP32) && defined (CONFIG_SPIRAM_SUPPORT)\n  if (psramFound()) _psram_enable = true; // Enable the use of PSRAM (if available)\n  else\n#endif\n  _psram_enable = false;\n\n  addr_row = 0xFFFF;  // drawPixel command length optimiser\n  addr_col = 0xFFFF;  // drawPixel command length optimiser\n\n  _xPivot = 0;\n  _yPivot = 0;\n\n// Legacy support for bit GPIO masks\n  cspinmask = 0;\n  dcpinmask = 0;\n  wrpinmask = 0;\n  sclkpinmask = 0;\n\n// Flags for which fonts are loaded\n#ifdef LOAD_GLCD\n  fontsloaded  = 0x0002; // Bit 1 set\n#endif\n\n#ifdef LOAD_FONT2\n  fontsloaded |= 0x0004; // Bit 2 set\n#endif\n\n#ifdef LOAD_FONT4\n  fontsloaded |= 0x0010; // Bit 4 set\n#endif\n\n#ifdef LOAD_FONT6\n  fontsloaded |= 0x0040; // Bit 6 set\n#endif\n\n#ifdef LOAD_FONT7\n  fontsloaded |= 0x0080; // Bit 7 set\n#endif\n\n#ifdef LOAD_FONT8\n  fontsloaded |= 0x0100; // Bit 8 set\n#endif\n\n#ifdef LOAD_FONT8N\n  fontsloaded |= 0x0200; // Bit 9 set\n#endif\n\n#ifdef SMOOTH_FONT\n  fontsloaded |= 0x8000; // Bit 15 set\n#endif\n}\n\n/***************************************************************************************\n** Function name:           initBus\n** Description:             initialise the SPI or parallel bus\n***************************************************************************************/\nvoid TFT_eSPI::initBus(void) {\n\n#ifdef TFT_CS\n  if (TFT_CS >= 0) {\n    pinMode(TFT_CS, OUTPUT);\n    digitalWrite(TFT_CS, HIGH); // Chip select high (inactive)\n  }\n#endif\n\n// Configure chip select for touchscreen controller if present\n#ifdef TOUCH_CS\n  if (TOUCH_CS >= 0) {\n    pinMode(TOUCH_CS, OUTPUT);\n    digitalWrite(TOUCH_CS, HIGH); // Chip select high (inactive)\n  }\n#endif\n\n// In parallel mode and with the RP2040 processor, the TFT_WR line is handled in the  PIO\n#if defined (TFT_WR) && !defined (ARDUINO_ARCH_RP2040) && !defined (ARDUINO_ARCH_MBED)\n  if (TFT_WR >= 0) {\n    pinMode(TFT_WR, OUTPUT);\n    digitalWrite(TFT_WR, HIGH); // Set write strobe high (inactive)\n  }\n#endif\n\n#ifdef TFT_DC\n  if (TFT_DC >= 0) {\n    pinMode(TFT_DC, OUTPUT);\n    digitalWrite(TFT_DC, HIGH); // Data/Command high = data mode\n  }\n#endif\n\n#ifdef TFT_RST\n  if (TFT_RST >= 0) {\n    pinMode(TFT_RST, OUTPUT);\n    digitalWrite(TFT_RST, HIGH); // Set high, do not share pin with another SPI device\n  }\n#endif\n\n#if defined (TFT_PARALLEL_8_BIT)\n\n  // Make sure read is high before we set the bus to output\n  if (TFT_RD >= 0) {\n    pinMode(TFT_RD, OUTPUT);\n    digitalWrite(TFT_RD, HIGH);\n  }\n\n  #if  !defined (ARDUINO_ARCH_RP2040)  && !defined (ARDUINO_ARCH_MBED)// PIO manages pins\n    // Set TFT data bus lines to output\n    pinMode(TFT_D0, OUTPUT); digitalWrite(TFT_D0, HIGH);\n    pinMode(TFT_D1, OUTPUT); digitalWrite(TFT_D1, HIGH);\n    pinMode(TFT_D2, OUTPUT); digitalWrite(TFT_D2, HIGH);\n    pinMode(TFT_D3, OUTPUT); digitalWrite(TFT_D3, HIGH);\n    pinMode(TFT_D4, OUTPUT); digitalWrite(TFT_D4, HIGH);\n    pinMode(TFT_D5, OUTPUT); digitalWrite(TFT_D5, HIGH);\n    pinMode(TFT_D6, OUTPUT); digitalWrite(TFT_D6, HIGH);\n    pinMode(TFT_D7, OUTPUT); digitalWrite(TFT_D7, HIGH);\n  #endif\n\n  PARALLEL_INIT_TFT_DATA_BUS;\n\n#endif\n}\n\n/***************************************************************************************\n** Function name:           begin\n** Description:             Included for backwards compatibility\n***************************************************************************************/\nvoid TFT_eSPI::begin(uint8_t tc)\n{\n init(tc);\n}\n\n\n/***************************************************************************************\n** Function name:           init (tc is tab colour for ST7735 displays only)\n** Description:             Reset, then initialise the TFT display registers\n***************************************************************************************/\nvoid TFT_eSPI::init(uint8_t tc)\n{\n  if (_booted)\n  {\n    initBus();\n\n#if !defined (ESP32) && !defined(TFT_PARALLEL_8_BIT) && !defined(ARDUINO_ARCH_RP2040) && !defined (ARDUINO_ARCH_MBED)\n  // Legacy bitmasks for GPIO\n  #if defined (TFT_CS) && (TFT_CS >= 0)\n    cspinmask = (uint32_t) digitalPinToBitMask(TFT_CS);\n  #endif\n\n  #if defined (TFT_DC) && (TFT_DC >= 0)\n    dcpinmask = (uint32_t) digitalPinToBitMask(TFT_DC);\n  #endif\n\n  #if defined (TFT_WR) && (TFT_WR >= 0)\n    wrpinmask = (uint32_t) digitalPinToBitMask(TFT_WR);\n  #endif\n\n  #if defined (TFT_SCLK) && (TFT_SCLK >= 0)\n    sclkpinmask = (uint32_t) digitalPinToBitMask(TFT_SCLK);\n  #endif\n\n  #if defined (TFT_SPI_OVERLAP) && defined (ARDUINO_ARCH_ESP8266)\n    // Overlap mode SD0=MISO, SD1=MOSI, CLK=SCLK must use D3 as CS\n    //    pins(int8_t sck, int8_t miso, int8_t mosi, int8_t ss);\n    //spi.pins(        6,          7,           8,          0);\n    spi.pins(6, 7, 8, 0);\n  #endif\n\n  spi.begin(); // This will set HMISO to input\n\n#else\n  #if !defined(TFT_PARALLEL_8_BIT) && !defined(RP2040_PIO_INTERFACE)\n    #if defined (TFT_MOSI) && !defined (TFT_SPI_OVERLAP) && !defined(ARDUINO_ARCH_RP2040) && !defined (ARDUINO_ARCH_MBED)\n      spi.begin(TFT_SCLK, TFT_MISO, TFT_MOSI, -1); // This will set MISO to input\n    #else\n      spi.begin(); // This will set MISO to input\n    #endif\n  #endif\n#endif\n    lockTransaction = false;\n    inTransaction = false;\n    locked = true;\n\n    INIT_TFT_DATA_BUS;\n\n\n#if defined (TFT_CS) && !defined(RP2040_PIO_INTERFACE)\n  // Set to output once again in case MISO is used for CS\n  if (TFT_CS >= 0) {\n    pinMode(TFT_CS, OUTPUT);\n    digitalWrite(TFT_CS, HIGH); // Chip select high (inactive)\n  }\n#elif defined (ARDUINO_ARCH_ESP8266) && !defined (TFT_PARALLEL_8_BIT) && !defined (RP2040_PIO_SPI)\n  spi.setHwCs(1); // Use hardware SS toggling\n#endif\n\n\n  // Set to output once again in case MISO is used for DC\n#if defined (TFT_DC) && !defined(RP2040_PIO_INTERFACE)\n  if (TFT_DC >= 0) {\n    pinMode(TFT_DC, OUTPUT);\n    digitalWrite(TFT_DC, HIGH); // Data/Command high = data mode\n  }\n#endif\n\n    _booted = false;\n    end_tft_write();\n  } // end of: if just _booted\n\n  // Toggle RST low to reset\n#ifdef TFT_RST\n  #if !defined(RP2040_PIO_INTERFACE)\n    // Set to output once again in case MISO is used for TFT_RST\n    if (TFT_RST >= 0) {\n      pinMode(TFT_RST, OUTPUT);\n    }\n  #endif\n  if (TFT_RST >= 0) {\n    writecommand(0x00); // Put SPI bus in known state for TFT with CS tied low\n    digitalWrite(TFT_RST, HIGH);\n    delay(5);\n    digitalWrite(TFT_RST, LOW);\n    delay(20);\n    digitalWrite(TFT_RST, HIGH);\n  }\n  else writecommand(TFT_SWRST); // Software reset\n#else\n  writecommand(TFT_SWRST); // Software reset\n#endif\n\n  delay(150); // Wait for reset to complete\n\n  begin_tft_write();\n\n  tc = tc; // Suppress warning\n\n  // This loads the driver specific initialisation code  <<<<<<<<<<<<<<<<<<<<< ADD NEW DRIVERS TO THE LIST HERE <<<<<<<<<<<<<<<<<<<<<<<\n#if   defined (ILI9341_DRIVER) || defined(ILI9341_2_DRIVER) || defined (ILI9342_DRIVER)\n    #include \"TFT_Drivers/ILI9341_Init.h\"\n\n#elif defined (ST7735_DRIVER)\n    tabcolor = tc;\n    #include \"TFT_Drivers/ST7735_Init.h\"\n\n#elif defined (ILI9163_DRIVER)\n    #include \"TFT_Drivers/ILI9163_Init.h\"\n\n#elif defined (S6D02A1_DRIVER)\n    #include \"TFT_Drivers/S6D02A1_Init.h\"\n\n#elif defined (ST7796_DRIVER)\n    #include \"TFT_Drivers/ST7796_Init.h\"\n\n#elif defined (ILI9486_DRIVER)\n    #include \"TFT_Drivers/ILI9486_Init.h\"\n\n#elif defined (ILI9481_DRIVER)\n    #include \"TFT_Drivers/ILI9481_Init.h\"\n\n#elif defined (ILI9488_DRIVER)\n    #include \"TFT_Drivers/ILI9488_Init.h\"\n\n#elif defined (HX8357D_DRIVER)\n    #include \"TFT_Drivers/HX8357D_Init.h\"\n\n#elif defined (ST7789_DRIVER)\n    #include \"TFT_Drivers/ST7789_Init.h\"\n\n#elif defined (R61581_DRIVER)\n    #include \"TFT_Drivers/R61581_Init.h\"\n\n#elif defined (RM68140_DRIVER)\n\t#include \"TFT_Drivers/RM68140_Init.h\"\n\n#elif defined (ST7789_2_DRIVER)\n    #include \"TFT_Drivers/ST7789_2_Init.h\"\n\n#elif defined (SSD1351_DRIVER)\n    #include \"TFT_Drivers/SSD1351_Init.h\"\n\n#elif defined (SSD1963_DRIVER)\n    #include \"TFT_Drivers/SSD1963_Init.h\"\n\n#elif defined (GC9A01_DRIVER)\n     #include \"TFT_Drivers/GC9A01_Init.h\"\n\n#elif defined (ILI9225_DRIVER)\n     #include \"TFT_Drivers/ILI9225_Init.h\"\n\n#elif defined (RM68120_DRIVER)\n     #include \"TFT_Drivers/RM68120_Init.h\"\n\n#elif defined (HX8357B_DRIVER)\n    #include \"TFT_Drivers/HX8357B_Init.h\"\n\n#elif defined (HX8357C_DRIVER)\n    #include \"TFT_Drivers/HX8357C_Init.h\"\n\n#endif\n\n#ifdef TFT_INVERSION_ON\n  writecommand(TFT_INVON);\n#endif\n\n#ifdef TFT_INVERSION_OFF\n  writecommand(TFT_INVOFF);\n#endif\n\n  end_tft_write();\n\n  setRotation(rotation);\n\n#if defined (TFT_BL) && defined (TFT_BACKLIGHT_ON)\n  if (TFT_BL >= 0) {\n    pinMode(TFT_BL, OUTPUT);\n    digitalWrite(TFT_BL, TFT_BACKLIGHT_ON);\n  }\n#else\n  #if defined (TFT_BL) && defined (M5STACK)\n    // Turn on the back-light LED\n    if (TFT_BL >= 0) {\n      pinMode(TFT_BL, OUTPUT);\n      digitalWrite(TFT_BL, HIGH);\n    }\n  #endif\n#endif\n}\n\n\n/***************************************************************************************\n** Function name:           setRotation\n** Description:             rotate the screen orientation m = 0-3 or 4-7 for BMP drawing\n***************************************************************************************/\nvoid TFT_eSPI::setRotation(uint8_t m)\n{\n\n  begin_tft_write();\n\n    // This loads the driver specific rotation code  <<<<<<<<<<<<<<<<<<<<< ADD NEW DRIVERS TO THE LIST HERE <<<<<<<<<<<<<<<<<<<<<<<\n#if   defined (ILI9341_DRIVER) || defined(ILI9341_2_DRIVER) || defined (ILI9342_DRIVER)\n    #include \"TFT_Drivers/ILI9341_Rotation.h\"\n\n#elif defined (ST7735_DRIVER)\n    #include \"TFT_Drivers/ST7735_Rotation.h\"\n\n#elif defined (ILI9163_DRIVER)\n    #include \"TFT_Drivers/ILI9163_Rotation.h\"\n\n#elif defined (S6D02A1_DRIVER)\n    #include \"TFT_Drivers/S6D02A1_Rotation.h\"\n\n#elif defined (ST7796_DRIVER)\n    #include \"TFT_Drivers/ST7796_Rotation.h\"\n\n#elif defined (ILI9486_DRIVER)\n    #include \"TFT_Drivers/ILI9486_Rotation.h\"\n\n#elif defined (ILI9481_DRIVER)\n    #include \"TFT_Drivers/ILI9481_Rotation.h\"\n\n#elif defined (ILI9488_DRIVER)\n    #include \"TFT_Drivers/ILI9488_Rotation.h\"\n\n#elif defined (HX8357D_DRIVER)\n    #include \"TFT_Drivers/HX8357D_Rotation.h\"\n\n#elif defined (ST7789_DRIVER)\n    #include \"TFT_Drivers/ST7789_Rotation.h\"\n\n#elif defined (R61581_DRIVER)\n    #include \"TFT_Drivers/R61581_Rotation.h\"\n\n#elif defined (RM68140_DRIVER)\n\t#include \"TFT_Drivers/RM68140_Rotation.h\"\n\n#elif defined (ST7789_2_DRIVER)\n    #include \"TFT_Drivers/ST7789_2_Rotation.h\"\n\n#elif defined (SSD1351_DRIVER)\n    #include \"TFT_Drivers/SSD1351_Rotation.h\"\n\n#elif defined (SSD1963_DRIVER)\n    #include \"TFT_Drivers/SSD1963_Rotation.h\"\n\n#elif defined (GC9A01_DRIVER)\n     #include \"TFT_Drivers/GC9A01_Rotation.h\"\n\n#elif defined (ILI9225_DRIVER)\n     #include \"TFT_Drivers/ILI9225_Rotation.h\"\n\n#elif defined (RM68120_DRIVER)\n     #include \"TFT_Drivers/RM68120_Rotation.h\"\n\n#elif defined (HX8357B_DRIVER)\n    #include \"TFT_Drivers/HX8357B_Rotation.h\"\n\n#elif defined (HX8357C_DRIVER)\n    #include \"TFT_Drivers/HX8357C_Rotation.h\"\n\n#endif\n\n  delayMicroseconds(10);\n\n  end_tft_write();\n\n  addr_row = 0xFFFF;\n  addr_col = 0xFFFF;\n\n  // Reset the viewport to the whole screen\n  resetViewport();\n}\n\n\n/***************************************************************************************\n** Function name:           getRotation\n** Description:             Return the rotation value (as used by setRotation())\n***************************************************************************************/\nuint8_t TFT_eSPI::getRotation(void)\n{\n  return rotation;\n}\n\n\n/***************************************************************************************\n** Function name:           setOrigin\n** Description:             Set graphics origin to position x,y wrt to top left corner\n***************************************************************************************/\n//Note: setRotation, setViewport and resetViewport will revert origin to top left\nvoid TFT_eSPI::setOrigin(int32_t x, int32_t y)\n{\n  _xDatum = x;\n  _yDatum = y;\n}\n\n\n/***************************************************************************************\n** Function name:           getOriginX\n** Description:             Set graphics origin to position x\n***************************************************************************************/\nint32_t TFT_eSPI::getOriginX(void)\n{\n  return _xDatum;\n}\n\n\n/***************************************************************************************\n** Function name:           getOriginY\n** Description:             Set graphics origin to position y\n***************************************************************************************/\nint32_t TFT_eSPI::getOriginY(void)\n{\n  return _yDatum;\n}\n\n\n/***************************************************************************************\n** Function name:           commandList, used for FLASH based lists only (e.g. ST7735)\n** Description:             Get initialisation commands from FLASH and send to TFT\n***************************************************************************************/\nvoid TFT_eSPI::commandList (const uint8_t *addr)\n{\n  uint8_t  numCommands;\n  uint8_t  numArgs;\n  uint8_t  ms;\n\n  numCommands = pgm_read_byte(addr++);   // Number of commands to follow\n\n  while (numCommands--)                  // For each command...\n  {\n    writecommand(pgm_read_byte(addr++)); // Read, issue command\n    numArgs = pgm_read_byte(addr++);     // Number of args to follow\n    ms = numArgs & TFT_INIT_DELAY;       // If high bit set, delay follows args\n    numArgs &= ~TFT_INIT_DELAY;          // Mask out delay bit\n\n    while (numArgs--)                    // For each argument...\n    {\n      writedata(pgm_read_byte(addr++));  // Read, issue argument\n    }\n\n    if (ms)\n    {\n      ms = pgm_read_byte(addr++);        // Read post-command delay time (ms)\n      delay( (ms==255 ? 500 : ms) );\n    }\n  }\n\n}\n\n\n/***************************************************************************************\n** Function name:           spiwrite\n** Description:             Write 8 bits to SPI port (legacy support only)\n***************************************************************************************/\nvoid TFT_eSPI::spiwrite(uint8_t c)\n{\n  begin_tft_write();\n  tft_Write_8(c);\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           writecommand\n** Description:             Send an 8-bit command to the TFT\n***************************************************************************************/\n#ifndef RM68120_DRIVER\nvoid TFT_eSPI::writecommand(uint8_t c)\n{\n  begin_tft_write();\n\n  DC_C;\n\n  tft_Write_8(c);\n\n  DC_D;\n\n  end_tft_write();\n}\n#else\nvoid TFT_eSPI::writecommand(uint16_t c)\n{\n  begin_tft_write();\n\n  DC_C;\n\n  tft_Write_16(c);\n\n  DC_D;\n\n  end_tft_write();\n\n}\nvoid TFT_eSPI::writeRegister8(uint16_t c, uint8_t d)\n{\n  begin_tft_write();\n\n  DC_C;\n\n  tft_Write_16(c);\n\n  DC_D;\n\n  tft_Write_8(d);\n\n  end_tft_write();\n\n}\nvoid TFT_eSPI::writeRegister16(uint16_t c, uint16_t d)\n{\n  begin_tft_write();\n\n  DC_C;\n\n  tft_Write_16(c);\n\n  DC_D;\n\n  tft_Write_16(d);\n\n  end_tft_write();\n\n}\n\n#endif\n\n/***************************************************************************************\n** Function name:           writedata\n** Description:             Send a 8-bit data value to the TFT\n***************************************************************************************/\nvoid TFT_eSPI::writedata(uint8_t d)\n{\n  begin_tft_write();\n\n  DC_D;        // Play safe, but should already be in data mode\n\n  tft_Write_8(d);\n\n  CS_L;        // Allow more hold time for low VDI rail\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           readcommand8\n** Description:             Read a 8-bit data value from an indexed command register\n***************************************************************************************/\nuint8_t TFT_eSPI::readcommand8(uint8_t cmd_function, uint8_t index)\n{\n  uint8_t reg = 0;\n#if defined(TFT_PARALLEL_8_BIT) || defined(RP2040_PIO_INTERFACE)\n\n  writecommand(cmd_function); // Sets DC and CS high\n\n  busDir(GPIO_DIR_MASK, INPUT);\n\n  CS_L;\n\n  // Read nth parameter (assumes caller discards 1st parameter or points index to 2nd)\n  while(index--) reg = readByte();\n\n  busDir(GPIO_DIR_MASK, OUTPUT);\n\n  CS_H;\n\n#else // SPI interface\n  // Tested with ILI9341 set to Interface II i.e. IM [3:0] = \"1101\"\n  begin_tft_read();\n  index = 0x10 + (index & 0x0F);\n\n  DC_C; tft_Write_8(0xD9);\n  DC_D; tft_Write_8(index);\n\n  CS_H; // Some displays seem to need CS to be pulsed here, or is just a delay needed?\n  CS_L;\n\n  DC_C; tft_Write_8(cmd_function);\n  DC_D;\n  reg = tft_Read_8();\n\n  end_tft_read();\n#endif\n  return reg;\n}\n\n\n/***************************************************************************************\n** Function name:           readcommand16\n** Description:             Read a 16-bit data value from an indexed command register\n***************************************************************************************/\nuint16_t TFT_eSPI::readcommand16(uint8_t cmd_function, uint8_t index)\n{\n  uint32_t reg;\n\n  reg  = (readcommand8(cmd_function, index + 0) <<  8);\n  reg |= (readcommand8(cmd_function, index + 1) <<  0);\n\n  return reg;\n}\n\n\n/***************************************************************************************\n** Function name:           readcommand32\n** Description:             Read a 32-bit data value from an indexed command register\n***************************************************************************************/\nuint32_t TFT_eSPI::readcommand32(uint8_t cmd_function, uint8_t index)\n{\n  uint32_t reg;\n\n  reg  = ((uint32_t)readcommand8(cmd_function, index + 0) << 24);\n  reg |= ((uint32_t)readcommand8(cmd_function, index + 1) << 16);\n  reg |= ((uint32_t)readcommand8(cmd_function, index + 2) <<  8);\n  reg |= ((uint32_t)readcommand8(cmd_function, index + 3) <<  0);\n\n  return reg;\n}\n\n\n/***************************************************************************************\n** Function name:           read pixel (for SPI Interface II i.e. IM [3:0] = \"1101\")\n** Description:             Read 565 pixel colours from a pixel\n***************************************************************************************/\nuint16_t TFT_eSPI::readPixel(int32_t x0, int32_t y0)\n{\n  if (_vpOoB) return 0;\n\n  x0+= _xDatum;\n  y0+= _yDatum;\n\n  // Range checking\n  if ((x0 < _vpX) || (y0 < _vpY) ||(x0 >= _vpW) || (y0 >= _vpH)) return 0;\n\n#if defined(TFT_PARALLEL_8_BIT) || defined(RP2040_PIO_INTERFACE)\n\n  if (!inTransaction) { CS_L; } // CS_L can be multi-statement\n\n  readAddrWindow(x0, y0, 1, 1);\n\n  // Set masked pins D0- D7 to input\n  busDir(GPIO_DIR_MASK, INPUT);\n\n  #if  !defined (SSD1963_DRIVER)\n  // Dummy read to throw away don't care value\n  readByte();\n  #endif\n\n  // Fetch the 16-bit BRG pixel\n  //uint16_t rgb = (readByte() << 8) | readByte();\n\n  #if defined (ILI9341_DRIVER)  || defined(ILI9341_2_DRIVER) || defined (ILI9488_DRIVER) || defined (SSD1963_DRIVER)// Read 3 bytes\n\n    // Read window pixel 24-bit RGB values and fill in LS bits\n    uint16_t rgb = ((readByte() & 0xF8) << 8) | ((readByte() & 0xFC) << 3) | (readByte() >> 3);\n\n    if (!inTransaction) { CS_H; } // CS_H can be multi-statement\n\n    // Set masked pins D0- D7 to output\n    busDir(GPIO_DIR_MASK, OUTPUT);\n\n    return rgb;\n\n  #else // ILI9481 or ILI9486 16-bit read\n\n    // Fetch the 16-bit BRG pixel\n    uint16_t bgr = (readByte() << 8) | readByte();\n\n    if (!inTransaction) { CS_H; } // CS_H can be multi-statement\n\n    // Set masked pins D0- D7 to output\n    busDir(GPIO_DIR_MASK, OUTPUT);\n\n    #if defined (ILI9486_DRIVER) || defined (ST7796_DRIVER)\n      return  bgr;\n    #else\n      // Swap Red and Blue (could check MADCTL setting to see if this is needed)\n      return  (bgr>>11) | (bgr<<11) | (bgr & 0x7E0);\n    #endif\n\n  #endif\n\n#else // Not TFT_PARALLEL_8_BIT\n\n  // This function can get called during anti-aliased font rendering\n  // so a transaction may be in progress\n  bool wasInTransaction = inTransaction;\n  if (inTransaction) { inTransaction= false; end_tft_write();}\n\n  uint16_t color = 0;\n\n  begin_tft_read(); // Sets CS low\n\n  readAddrWindow(x0, y0, 1, 1);\n\n  #ifdef TFT_SDA_READ\n    begin_SDA_Read();\n  #endif\n\n  // Dummy read to throw away don't care value\n  tft_Read_8();\n\n  //#if !defined (ILI9488_DRIVER)\n\n    #if defined (ST7796_DRIVER)\n      // Read the 2 bytes\n      color = ((tft_Read_8()) << 8) | (tft_Read_8());\n    #elif defined (ST7735_DRIVER)\n      // Read the 3 RGB bytes, colour is in LS 6 bits of the top 7 bits of each byte\n      // as the TFT stores colours as 18 bits\n      uint8_t r = tft_Read_8()<<1;\n      uint8_t g = tft_Read_8()<<1;\n      uint8_t b = tft_Read_8()<<1;\n      color = color565(r, g, b);\n    #else\n      // Read the 3 RGB bytes, colour is actually only in the top 6 bits of each byte\n      // as the TFT stores colours as 18 bits\n      uint8_t r = tft_Read_8();\n      uint8_t g = tft_Read_8();\n      uint8_t b = tft_Read_8();\n      color = color565(r, g, b);\n    #endif\n\n/*\n  #else\n\n    // The 6 colour bits are in MS 6 bits of each byte, but the ILI9488 needs an extra clock pulse\n    // so bits appear shifted right 1 bit, so mask the middle 6 bits then shift 1 place left\n    uint8_t r = (tft_Read_8()&0x7E)<<1;\n    uint8_t g = (tft_Read_8()&0x7E)<<1;\n    uint8_t b = (tft_Read_8()&0x7E)<<1;\n    color = color565(r, g, b);\n\n  #endif\n*/\n  CS_H;\n\n  #ifdef TFT_SDA_READ\n    end_SDA_Read();\n  #endif\n\n  end_tft_read();\n\n  // Reinstate the transaction if one was in progress\n  if(wasInTransaction) { begin_tft_write(); inTransaction = true; }\n\n  return color;\n\n#endif\n}\n\nvoid TFT_eSPI::setCallback(getColorCallback getCol)\n{\n  getColor = getCol;\n}\n\n\n/***************************************************************************************\n** Function name:           read rectangle (for SPI Interface II i.e. IM [3:0] = \"1101\")\n** Description:             Read 565 pixel colours from a defined area\n***************************************************************************************/\nvoid TFT_eSPI::readRect(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data)\n{\n  PI_CLIP ;\n\n#if defined(TFT_PARALLEL_8_BIT) || defined(RP2040_PIO_INTERFACE)\n\n  CS_L;\n\n  readAddrWindow(x, y, dw, dh);\n\n  data += dx + dy * w;\n\n  // Set masked pins D0- D7 to input\n  busDir(GPIO_DIR_MASK, INPUT);\n\n  #if defined (ILI9341_DRIVER)  || defined(ILI9341_2_DRIVER) || defined (ILI9488_DRIVER) // Read 3 bytes\n    // Dummy read to throw away don't care value\n    readByte();\n\n    // Fetch the 24-bit RGB value\n    while (dh--) {\n      int32_t lw = dw;\n      uint16_t* line = data;\n      while (lw--) {\n        // Assemble the RGB 16-bit colour\n        uint16_t rgb = ((readByte() & 0xF8) << 8) | ((readByte() & 0xFC) << 3) | (readByte() >> 3);\n\n        // Swapped byte order for compatibility with pushRect()\n        *line++ = (rgb<<8) | (rgb>>8);\n      }\n      data += w;\n    }\n\n  #elif  defined (SSD1963_DRIVER)\n    // Fetch the 18-bit BRG pixels\n    while (dh--) {\n      int32_t lw = dw;\n      uint16_t* line = data;\n      while (lw--) {\n        uint16_t bgr = ((readByte() & 0xF8) >> 3);; // CS_L adds a small delay\n        bgr |= ((readByte() & 0xFC) << 3);\n        bgr |= (readByte() << 8);\n        // Swap Red and Blue (could check MADCTL setting to see if this is needed)\n        uint16_t rgb = (bgr>>11) | (bgr<<11) | (bgr & 0x7E0);\n        // Swapped byte order for compatibility with pushRect()\n        *line++ = (rgb<<8) | (rgb>>8);\n      }\n      data += w;\n    }\n\n  #else // ILI9481 reads as 16 bits\n    // Dummy read to throw away don't care value\n    readByte();\n\n    // Fetch the 16-bit BRG pixels\n    while (dh--) {\n      int32_t lw = dw;\n      uint16_t* line = data;\n      while (lw--) {\n      #if defined (ILI9486_DRIVER) || defined (ST7796_DRIVER)\n        // Read the RGB 16-bit colour\n        *line++ = readByte() | (readByte() << 8);\n      #else\n        // Read the BRG 16-bit colour\n        uint16_t bgr = (readByte() << 8) | readByte();\n        // Swap Red and Blue (could check MADCTL setting to see if this is needed)\n        uint16_t rgb = (bgr>>11) | (bgr<<11) | (bgr & 0x7E0);\n        // Swapped byte order for compatibility with pushRect()\n        *line++ = (rgb<<8) | (rgb>>8);\n      #endif\n      }\n      data += w;\n    }\n  #endif\n\n  CS_H;\n\n  // Set masked pins D0- D7 to output\n  busDir(GPIO_DIR_MASK, OUTPUT);\n\n#else // SPI interface\n\n  // This function can get called after a begin_tft_write\n  // so a transaction may be in progress\n  bool wasInTransaction = inTransaction;\n  if (inTransaction) { inTransaction= false; end_tft_write();}\n\n  uint16_t color = 0;\n\n  begin_tft_read();\n\n  readAddrWindow(x, y, dw, dh);\n\n  data += dx + dy * w;\n\n  #ifdef TFT_SDA_READ\n    begin_SDA_Read();\n  #endif\n\n  // Dummy read to throw away don't care value\n  tft_Read_8();\n\n  // Read window pixel 24-bit RGB values\n  while (dh--) {\n    int32_t lw = dw;\n    uint16_t* line = data;\n    while (lw--) {\n\n  #if !defined (ILI9488_DRIVER)\n\n    #if defined (ST7796_DRIVER)\n      // Read the 2 bytes\n      color = ((tft_Read_8()) << 8) | (tft_Read_8());\n    #elif defined (ST7735_DRIVER)\n      // Read the 3 RGB bytes, colour is in LS 6 bits of the top 7 bits of each byte\n      // as the TFT stores colours as 18 bits\n      uint8_t r = tft_Read_8()<<1;\n      uint8_t g = tft_Read_8()<<1;\n      uint8_t b = tft_Read_8()<<1;\n      color = color565(r, g, b);\n    #else\n      // Read the 3 RGB bytes, colour is actually only in the top 6 bits of each byte\n      // as the TFT stores colours as 18 bits\n      uint8_t r = tft_Read_8();\n      uint8_t g = tft_Read_8();\n      uint8_t b = tft_Read_8();\n      color = color565(r, g, b);\n    #endif\n\n  #else\n\n      // The 6 colour bits are in MS 6 bits of each byte but we do not include the extra clock pulse\n      // so we use a trick and mask the middle 6 bits of the byte, then only shift 1 place left\n      uint8_t r = (tft_Read_8()&0x7E)<<1;\n      uint8_t g = (tft_Read_8()&0x7E)<<1;\n      uint8_t b = (tft_Read_8()&0x7E)<<1;\n      color = color565(r, g, b);\n  #endif\n\n      // Swapped colour byte order for compatibility with pushRect()\n      *line++ = color << 8 | color >> 8;\n    }\n    data += w;\n  }\n\n  //CS_H;\n\n  #ifdef TFT_SDA_READ\n    end_SDA_Read();\n  #endif\n\n  end_tft_read();\n\n  // Reinstate the transaction if one was in progress\n  if(wasInTransaction) { begin_tft_write(); inTransaction = true; }\n#endif\n}\n\n\n/***************************************************************************************\n** Function name:           push rectangle\n** Description:             push 565 pixel colours into a defined area\n***************************************************************************************/\nvoid TFT_eSPI::pushRect(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data)\n{\n  bool swap = _swapBytes; _swapBytes = false;\n  pushImage(x, y, w, h, data);\n  _swapBytes = swap;\n}\n\n\n/***************************************************************************************\n** Function name:           pushImage\n** Description:             plot 16-bit colour sprite or image onto TFT\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data)\n{\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n\n  setWindow(x, y, x + dw - 1, y + dh - 1);\n\n  data += dx + dy * w;\n\n  // Check if whole image can be pushed\n  if (dw == w) pushPixels(data, dw * dh);\n  else {\n    // Push line segments to crop image\n    while (dh--)\n    {\n      pushPixels(data, dw);\n      data += w;\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           pushImage\n** Description:             plot 16-bit sprite or image with 1 colour being transparent\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data, uint16_t transp)\n{\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n\n  data += dx + dy * w;\n\n\n  uint16_t  lineBuf[dw]; // Use buffer to minimise setWindow call count\n\n  // The little endian transp color must be byte swapped if the image is big endian\n  if (!_swapBytes) transp = transp >> 8 | transp << 8;\n\n  while (dh--)\n  {\n    int32_t len = dw;\n    uint16_t* ptr = data;\n    int32_t px = x, sx = x;\n    bool move = true;\n    uint16_t np = 0;\n\n    while (len--)\n    {\n      if (transp != *ptr)\n      {\n        if (move) { move = false; sx = px; }\n        lineBuf[np] = *ptr;\n        np++;\n      }\n      else\n      {\n        move = true;\n        if (np)\n        {\n          setWindow(sx, y, sx + np - 1, y);\n          pushPixels((uint16_t*)lineBuf, np);\n          np = 0;\n        }\n      }\n      px++;\n      ptr++;\n    }\n    if (np) { setWindow(sx, y, sx + np - 1, y); pushPixels((uint16_t*)lineBuf, np); }\n\n    y++;\n    data += w;\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           pushImage - for FLASH (PROGMEM) stored images\n** Description:             plot 16-bit image\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint16_t *data)\n{\n  // Requires 32-bit aligned access, so use PROGMEM 16-bit word functions\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n\n  data += dx + dy * w;\n\n  uint16_t  buffer[dw];\n\n  setWindow(x, y, x + dw - 1, y + dh - 1);\n\n  // Fill and send line buffers to TFT\n  for (int32_t i = 0; i < dh; i++) {\n    for (int32_t j = 0; j < dw; j++) {\n      buffer[j] = pgm_read_word(&data[i * w + j]);\n    }\n    pushPixels(buffer, dw);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           pushImage - for FLASH (PROGMEM) stored images\n** Description:             plot 16-bit image with 1 colour being transparent\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint16_t *data, uint16_t transp)\n{\n  // Requires 32-bit aligned access, so use PROGMEM 16-bit word functions\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n\n  data += dx + dy * w;\n\n\n  uint16_t  lineBuf[dw];\n\n  // The little endian transp color must be byte swapped if the image is big endian\n  if (!_swapBytes) transp = transp >> 8 | transp << 8;\n\n  while (dh--) {\n    int32_t len = dw;\n    uint16_t* ptr = (uint16_t*)data;\n    int32_t px = x, sx = x;\n    bool move = true;\n\n    uint16_t np = 0;\n\n    while (len--) {\n      uint16_t color = pgm_read_word(ptr);\n      if (transp != color) {\n        if (move) { move = false; sx = px; }\n        lineBuf[np] = color;\n        np++;\n      }\n      else {\n        move = true;\n        if (np) {\n          setWindow(sx, y, sx + np - 1, y);\n          pushPixels(lineBuf, np);\n          np = 0;\n        }\n      }\n      px++;\n      ptr++;\n    }\n    if (np) { setWindow(sx, y, sx + np - 1, y); pushPixels(lineBuf, np); }\n\n    y++;\n    data += w;\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           pushImage\n** Description:             plot 8-bit or 4-bit or 1 bit image or sprite using a line buffer\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint8_t *data, bool bpp8,  uint16_t *cmap)\n{\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n  bool swap = _swapBytes;\n\n  setWindow(x, y, x + dw - 1, y + dh - 1); // Sets CS low and sent RAMWR\n\n  // Line buffer makes plotting faster\n  uint16_t  lineBuf[dw];\n\n  if (bpp8)\n  {\n    _swapBytes = false;\n\n    uint8_t  blue[] = {0, 11, 21, 31}; // blue 2 to 5-bit colour lookup table\n\n    _lastColor = -1; // Set to illegal value\n\n    // Used to store last shifted colour\n    uint8_t msbColor = 0;\n    uint8_t lsbColor = 0;\n\n    data += dx + dy * w;\n    while (dh--) {\n      uint32_t len = dw;\n      uint8_t* ptr = (uint8_t*)data;\n      uint8_t* linePtr = (uint8_t*)lineBuf;\n\n      while(len--) {\n        uint32_t color = pgm_read_byte(ptr++);\n\n        // Shifts are slow so check if colour has changed first\n        if (color != _lastColor) {\n          //          =====Green=====     ===============Red==============\n          msbColor = (color & 0x1C)>>2 | (color & 0xC0)>>3 | (color & 0xE0);\n          //          =====Green=====    =======Blue======\n          lsbColor = (color & 0x1C)<<3 | blue[color & 0x03];\n          _lastColor = color;\n        }\n\n       *linePtr++ = msbColor;\n       *linePtr++ = lsbColor;\n      }\n\n      pushPixels(lineBuf, dw);\n\n      data += w;\n    }\n    _swapBytes = swap; // Restore old value\n  }\n  else if (cmap != nullptr) // Must be 4bpp\n  {\n    _swapBytes = true;\n\n    w = (w+1) & 0xFFFE;   // if this is a sprite, w will already be even; this does no harm.\n    bool splitFirst = (dx & 0x01) != 0; // split first means we have to push a single px from the left of the sprite / image\n\n    if (splitFirst) {\n      data += ((dx - 1 + dy * w) >> 1);\n    }\n    else {\n      data += ((dx + dy * w) >> 1);\n    }\n\n    while (dh--) {\n      uint32_t len = dw;\n      uint8_t * ptr = (uint8_t*)data;\n      uint16_t *linePtr = lineBuf;\n      uint8_t colors; // two colors in one byte\n      uint16_t index;\n\n      if (splitFirst) {\n        colors = pgm_read_byte(ptr);\n        index = (colors & 0x0F);\n        *linePtr++ = cmap[index];\n        len--;\n        ptr++;\n      }\n\n      while (len--)\n      {\n        colors = pgm_read_byte(ptr);\n        index = ((colors & 0xF0) >> 4) & 0x0F;\n        *linePtr++ = cmap[index];\n\n        if (len--)\n        {\n          index = colors & 0x0F;\n          *linePtr++ = cmap[index];\n        } else {\n          break;  // nothing to do here\n        }\n\n        ptr++;\n      }\n\n      pushPixels(lineBuf, dw);\n      data += (w >> 1);\n    }\n    _swapBytes = swap; // Restore old value\n  }\n  else // Must be 1bpp\n  {\n    _swapBytes = false;\n    uint8_t * ptr = (uint8_t*)data;\n    uint32_t ww =  (w+7)>>3; // Width of source image line in bytes\n    for (int32_t yp = dy;  yp < dy + dh; yp++)\n    {\n      uint8_t* linePtr = (uint8_t*)lineBuf;\n      for (int32_t xp = dx; xp < dx + dw; xp++)\n      {\n        uint16_t col = (pgm_read_byte(ptr + (xp>>3)) & (0x80 >> (xp & 0x7)) );\n        if (col) {*linePtr++ = bitmap_fg>>8; *linePtr++ = (uint8_t) bitmap_fg;}\n        else     {*linePtr++ = bitmap_bg>>8; *linePtr++ = (uint8_t) bitmap_bg;}\n      }\n      ptr += ww;\n      pushPixels(lineBuf, dw);\n    }\n  }\n\n  _swapBytes = swap; // Restore old value\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           pushImage\n** Description:             plot 8-bit or 4-bit or 1 bit image or sprite using a line buffer\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t *data, bool bpp8,  uint16_t *cmap)\n{\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n  bool swap = _swapBytes;\n\n  setWindow(x, y, x + dw - 1, y + dh - 1); // Sets CS low and sent RAMWR\n\n  // Line buffer makes plotting faster\n  uint16_t  lineBuf[dw];\n\n  if (bpp8)\n  {\n    _swapBytes = false;\n\n    uint8_t  blue[] = {0, 11, 21, 31}; // blue 2 to 5-bit colour lookup table\n\n    _lastColor = -1; // Set to illegal value\n\n    // Used to store last shifted colour\n    uint8_t msbColor = 0;\n    uint8_t lsbColor = 0;\n\n    data += dx + dy * w;\n    while (dh--) {\n      uint32_t len = dw;\n      uint8_t* ptr = data;\n      uint8_t* linePtr = (uint8_t*)lineBuf;\n\n      while(len--) {\n        uint32_t color = *ptr++;\n\n        // Shifts are slow so check if colour has changed first\n        if (color != _lastColor) {\n          //          =====Green=====     ===============Red==============\n          msbColor = (color & 0x1C)>>2 | (color & 0xC0)>>3 | (color & 0xE0);\n          //          =====Green=====    =======Blue======\n          lsbColor = (color & 0x1C)<<3 | blue[color & 0x03];\n          _lastColor = color;\n        }\n\n       *linePtr++ = msbColor;\n       *linePtr++ = lsbColor;\n      }\n\n      pushPixels(lineBuf, dw);\n\n      data += w;\n    }\n    _swapBytes = swap; // Restore old value\n  }\n  else if (cmap != nullptr) // Must be 4bpp\n  {\n    _swapBytes = true;\n\n    w = (w+1) & 0xFFFE;   // if this is a sprite, w will already be even; this does no harm.\n    bool splitFirst = (dx & 0x01) != 0; // split first means we have to push a single px from the left of the sprite / image\n\n    if (splitFirst) {\n      data += ((dx - 1 + dy * w) >> 1);\n    }\n    else {\n      data += ((dx + dy * w) >> 1);\n    }\n\n    while (dh--) {\n      uint32_t len = dw;\n      uint8_t * ptr = data;\n      uint16_t *linePtr = lineBuf;\n      uint8_t colors; // two colors in one byte\n      uint16_t index;\n\n      if (splitFirst) {\n        colors = *ptr;\n        index = (colors & 0x0F);\n        *linePtr++ = cmap[index];\n        len--;\n        ptr++;\n      }\n\n      while (len--)\n      {\n        colors = *ptr;\n        index = ((colors & 0xF0) >> 4) & 0x0F;\n        *linePtr++ = cmap[index];\n\n        if (len--)\n        {\n          index = colors & 0x0F;\n          *linePtr++ = cmap[index];\n        } else {\n          break;  // nothing to do here\n        }\n\n        ptr++;\n      }\n\n      pushPixels(lineBuf, dw);\n      data += (w >> 1);\n    }\n    _swapBytes = swap; // Restore old value\n  }\n  else // Must be 1bpp\n  {\n    _swapBytes = false;\n\n    uint32_t ww =  (w+7)>>3; // Width of source image line in bytes\n    for (int32_t yp = dy;  yp < dy + dh; yp++)\n    {\n      uint8_t* linePtr = (uint8_t*)lineBuf;\n      for (int32_t xp = dx; xp < dx + dw; xp++)\n      {\n        uint16_t col = (data[(xp>>3)] & (0x80 >> (xp & 0x7)) );\n        if (col) {*linePtr++ = bitmap_fg>>8; *linePtr++ = (uint8_t) bitmap_fg;}\n        else     {*linePtr++ = bitmap_bg>>8; *linePtr++ = (uint8_t) bitmap_bg;}\n      }\n      data += ww;\n      pushPixels(lineBuf, dw);\n    }\n  }\n\n  _swapBytes = swap; // Restore old value\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           pushImage\n** Description:             plot 8 or 4 or 1 bit image or sprite with a transparent colour\n***************************************************************************************/\nvoid TFT_eSPI::pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t *data, uint8_t transp, bool bpp8, uint16_t *cmap)\n{\n  PI_CLIP;\n\n  begin_tft_write();\n  inTransaction = true;\n  bool swap = _swapBytes;\n\n\n  // Line buffer makes plotting faster\n  uint16_t  lineBuf[dw];\n\n  if (bpp8) { // 8 bits per pixel\n    _swapBytes = false;\n\n    data += dx + dy * w;\n\n    uint8_t  blue[] = {0, 11, 21, 31}; // blue 2 to 5-bit colour lookup table\n\n    _lastColor = -1; // Set to illegal value\n\n    // Used to store last shifted colour\n    uint8_t msbColor = 0;\n    uint8_t lsbColor = 0;\n\n    while (dh--) {\n      int32_t len = dw;\n      uint8_t* ptr = data;\n      uint8_t* linePtr = (uint8_t*)lineBuf;\n\n      int32_t px = x, sx = x;\n      bool move = true;\n      uint16_t np = 0;\n\n      while (len--) {\n        if (transp != *ptr) {\n          if (move) { move = false; sx = px; }\n          uint8_t color = *ptr;\n\n          // Shifts are slow so check if colour has changed first\n          if (color != _lastColor) {\n            //          =====Green=====     ===============Red==============\n            msbColor = (color & 0x1C)>>2 | (color & 0xC0)>>3 | (color & 0xE0);\n            //          =====Green=====    =======Blue======\n            lsbColor = (color & 0x1C)<<3 | blue[color & 0x03];\n            _lastColor = color;\n          }\n          *linePtr++ = msbColor;\n          *linePtr++ = lsbColor;\n          np++;\n        }\n        else {\n          move = true;\n          if (np) {\n            setWindow(sx, y, sx + np - 1, y);\n            pushPixels(lineBuf, np);\n            linePtr = (uint8_t*)lineBuf;\n            np = 0;\n          }\n        }\n        px++;\n        ptr++;\n      }\n\n      if (np) { setWindow(sx, y, sx + np - 1, y); pushPixels(lineBuf, np); }\n      y++;\n      data += w;\n    }\n  }\n  else if (cmap != nullptr) // 4bpp with color map\n  {\n    _swapBytes = true;\n\n    w = (w+1) & 0xFFFE; // here we try to recreate iwidth from dwidth.\n    bool splitFirst = ((dx & 0x01) != 0);\n    if (splitFirst) {\n      data += ((dx - 1 + dy * w) >> 1);\n    }\n    else {\n      data += ((dx + dy * w) >> 1);\n    }\n\n    while (dh--) {\n      uint32_t len = dw;\n      uint8_t * ptr = data;\n\n      int32_t px = x, sx = x;\n      bool move = true;\n      uint16_t np = 0;\n\n      uint8_t index;  // index into cmap.\n\n      if (splitFirst) {\n        index = (*ptr & 0x0F);  // odd = bits 3 .. 0\n        if (index != transp) {\n          move = false; sx = px;\n          lineBuf[np] = cmap[index];\n          np++;\n        }\n        px++; ptr++;\n        len--;\n      }\n\n      while (len--)\n      {\n        uint8_t color = *ptr;\n\n        // find the actual color you care about.  There will be two pixels here!\n        // but we may only want one at the end of the row\n        uint16_t index = ((color & 0xF0) >> 4) & 0x0F;  // high bits are the even numbers\n        if (index != transp) {\n          if (move) {\n            move = false; sx = px;\n          }\n          lineBuf[np] = cmap[index];\n          np++; // added a pixel\n        }\n        else {\n          move = true;\n          if (np) {\n            setWindow(sx, y, sx + np - 1, y);\n            pushPixels(lineBuf, np);\n            np = 0;\n          }\n        }\n        px++;\n\n        if (len--)\n        {\n          index = color & 0x0F; // the odd number is 3 .. 0\n          if (index != transp) {\n            if (move) {\n              move = false; sx = px;\n             }\n            lineBuf[np] = cmap[index];\n            np++;\n          }\n          else {\n            move = true;\n            if (np) {\n              setWindow(sx, y, sx + np - 1, y);\n              pushPixels(lineBuf, np);\n              np = 0;\n            }\n          }\n          px++;\n        }\n        else {\n          break;  // we are done with this row.\n        }\n        ptr++;  // we only increment ptr once in the loop (deliberate)\n      }\n\n      if (np) {\n        setWindow(sx, y, sx + np - 1, y);\n        pushPixels(lineBuf, np);\n        np = 0;\n      }\n      data += (w>>1);\n      y++;\n    }\n  }\n  else { // 1 bit per pixel\n    _swapBytes = false;\n\n    uint32_t ww =  (w+7)>>3; // Width of source image line in bytes\n    uint16_t np = 0;\n\n    for (int32_t yp = dy;  yp < dy + dh; yp++)\n    {\n      int32_t px = x, sx = x;\n      bool move = true;\n      for (int32_t xp = dx; xp < dx + dw; xp++)\n      {\n        if (data[(xp>>3)] & (0x80 >> (xp & 0x7))) {\n          if (move) {\n            move = false;\n            sx = px;\n          }\n          np++;\n        }\n        else {\n          move = true;\n          if (np) {\n            setWindow(sx, y, sx + np - 1, y);\n            pushBlock(bitmap_fg, np);\n            np = 0;\n          }\n        }\n        px++;\n      }\n      if (np) { setWindow(sx, y, sx + np - 1, y); pushBlock(bitmap_fg, np); np = 0; }\n      y++;\n      data += ww;\n    }\n  }\n  _swapBytes = swap; // Restore old value\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           pushMaskedImage\n** Description:             Render a 16-bit colour image to TFT with a 1bpp mask\n***************************************************************************************/\n// Can be used with a 16bpp sprite and a 1bpp sprite for the mask\nvoid TFT_eSPI::pushMaskedImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *img, uint8_t *mask)\n{\n  if (_vpOoB || w < 1 || h < 1) return;\n\n  // To simplify mask handling the window clipping is done by the pushImage function\n  // Each mask image line assumed to be padded to an integer number of bytes & padding bits are 0\n\n  begin_tft_write();\n  inTransaction = true;\n\n  uint8_t  *mptr = mask;\n  uint8_t  *eptr = mask + ((w + 7) >> 3);\n  uint16_t *iptr = img;\n  uint32_t setCount = 0;\n\n  // For each line in the image\n  while (h--) {\n    uint32_t xp = 0;\n    uint32_t clearCount = 0;\n    uint8_t  mbyte= *mptr++;\n    uint32_t bits  = 8;\n    // Scan through each byte of the bitmap and determine run lengths\n    do {\n      setCount = 0;\n\n      //Get run length for clear bits to determine x offset\n      while ((mbyte & 0x80) == 0x00) {\n        // Check if remaining bits in byte are clear (reduce shifts)\n        if (mbyte == 0) {\n          clearCount += bits;      // bits not always 8 here\n          if (mptr >= eptr) break; // end of line\n          mbyte = *mptr++;\n          bits  = 8;\n          continue;\n        }\n        mbyte = mbyte << 1; // 0's shifted in\n        clearCount ++;\n        if (--bits) continue;;\n        if (mptr >= eptr) break;\n        mbyte = *mptr++;\n        bits  = 8;\n      }\n\n      //Get run length for set bits to determine render width\n      while ((mbyte & 0x80) == 0x80) {\n        // Check if all bits are set (reduces shifts)\n        if (mbyte == 0xFF) {\n          setCount += bits;\n          if (mptr >= eptr) break;\n          mbyte = *mptr++;\n          //bits  = 8; // NR, bits always 8 here unless 1's shifted in\n          continue;\n        }\n        mbyte = mbyte << 1; //or mbyte += mbyte + 1 to shift in 1's\n        setCount ++;\n        if (--bits) continue;\n        if (mptr >= eptr) break;\n        mbyte = *mptr++;\n        bits  = 8;\n      }\n\n      // A mask boundary or mask end has been found, so render the pixel line\n      if (setCount) {\n        xp += clearCount;\n        clearCount = 0;\n        pushImage(x + xp, y, setCount, 1, iptr + xp);      // pushImage handles clipping\n        if (mptr >= eptr) break;\n        xp += setCount;\n      }\n    } while (setCount || mptr < eptr);\n\n    y++;\n    iptr += w;\n    eptr += ((w + 7) >> 3);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           setSwapBytes\n** Description:             Used by 16-bit pushImage() to swap byte order in colours\n***************************************************************************************/\nvoid TFT_eSPI::setSwapBytes(bool swap)\n{\n  _swapBytes = swap;\n}\n\n\n/***************************************************************************************\n** Function name:           getSwapBytes\n** Description:             Return the swap byte order for colours\n***************************************************************************************/\nbool TFT_eSPI::getSwapBytes(void)\n{\n  return _swapBytes;\n}\n\n\n/***************************************************************************************\n** Function name:           read rectangle (for SPI Interface II i.e. IM [3:0] = \"1101\")\n** Description:             Read RGB pixel colours from a defined area\n***************************************************************************************/\n// If w and h are 1, then 1 pixel is read, *data array size must be 3 bytes per pixel\nvoid  TFT_eSPI::readRectRGB(int32_t x0, int32_t y0, int32_t w, int32_t h, uint8_t *data)\n{\n#if defined(TFT_PARALLEL_8_BIT) || defined(RP2040_PIO_INTERFACE)\n\n  uint32_t len = w * h;\n  uint8_t* buf565 = data + len;\n\n  readRect(x0, y0, w, h, (uint16_t*)buf565);\n\n  while (len--) {\n    uint16_t pixel565 = (*buf565++)<<8;\n    pixel565 |= *buf565++;\n    uint8_t red   = (pixel565 & 0xF800) >> 8; red   |= red   >> 5;\n    uint8_t green = (pixel565 & 0x07E0) >> 3; green |= green >> 6;\n    uint8_t blue  = (pixel565 & 0x001F) << 3; blue  |= blue  >> 5;\n    *data++ = red;\n    *data++ = green;\n    *data++ = blue;\n  }\n\n#else  // Not TFT_PARALLEL_8_BIT\n\n  begin_tft_read();\n\n  readAddrWindow(x0, y0, w, h); // Sets CS low\n\n  #ifdef TFT_SDA_READ\n    begin_SDA_Read();\n  #endif\n\n  // Dummy read to throw away don't care value\n  tft_Read_8();\n\n  // Read window pixel 24-bit RGB values, buffer must be set in sketch to 3 * w * h\n  uint32_t len = w * h;\n  while (len--) {\n\n  #if !defined (ILI9488_DRIVER)\n\n    // Read the 3 RGB bytes, colour is actually only in the top 6 bits of each byte\n    // as the TFT stores colours as 18 bits\n    *data++ = tft_Read_8();\n    *data++ = tft_Read_8();\n    *data++ = tft_Read_8();\n\n  #else\n\n    // The 6 colour bits are in MS 6 bits of each byte, but the ILI9488 needs an extra clock pulse\n    // so bits appear shifted right 1 bit, so mask the middle 6 bits then shift 1 place left\n    *data++ = (tft_Read_8()&0x7E)<<1;\n    *data++ = (tft_Read_8()&0x7E)<<1;\n    *data++ = (tft_Read_8()&0x7E)<<1;\n\n  #endif\n\n  }\n\n  CS_H;\n\n  #ifdef TFT_SDA_READ\n    end_SDA_Read();\n  #endif\n\n  end_tft_read();\n\n#endif\n}\n\n\n/***************************************************************************************\n** Function name:           drawCircle\n** Description:             Draw a circle outline\n***************************************************************************************/\n// Optimised midpoint circle algorithm\nvoid TFT_eSPI::drawCircle(int32_t x0, int32_t y0, int32_t r, uint32_t color)\n{\n  if ( r <= 0 ) return;\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n    int32_t f     = 1 - r;\n    int32_t ddF_y = -2 * r;\n    int32_t ddF_x = 1;\n    int32_t xs    = -1;\n    int32_t xe    = 0;\n    int32_t len   = 0;\n\n    bool first = true;\n    do {\n      while (f < 0) {\n        ++xe;\n        f += (ddF_x += 2);\n      }\n      f += (ddF_y += 2);\n\n      if (xe-xs>1) {\n        if (first) {\n          len = 2*(xe - xs)-1;\n          drawFastHLine(x0 - xe, y0 + r, len, color);\n          drawFastHLine(x0 - xe, y0 - r, len, color);\n          drawFastVLine(x0 + r, y0 - xe, len, color);\n          drawFastVLine(x0 - r, y0 - xe, len, color);\n          first = false;\n        }\n        else {\n          len = xe - xs++;\n          drawFastHLine(x0 - xe, y0 + r, len, color);\n          drawFastHLine(x0 - xe, y0 - r, len, color);\n          drawFastHLine(x0 + xs, y0 - r, len, color);\n          drawFastHLine(x0 + xs, y0 + r, len, color);\n\n          drawFastVLine(x0 + r, y0 + xs, len, color);\n          drawFastVLine(x0 + r, y0 - xe, len, color);\n          drawFastVLine(x0 - r, y0 - xe, len, color);\n          drawFastVLine(x0 - r, y0 + xs, len, color);\n        }\n      }\n      else {\n        ++xs;\n        drawPixel(x0 - xe, y0 + r, color);\n        drawPixel(x0 - xe, y0 - r, color);\n        drawPixel(x0 + xs, y0 - r, color);\n        drawPixel(x0 + xs, y0 + r, color);\n\n        drawPixel(x0 + r, y0 + xs, color);\n        drawPixel(x0 + r, y0 - xe, color);\n        drawPixel(x0 - r, y0 - xe, color);\n        drawPixel(x0 - r, y0 + xs, color);\n      }\n      xs = xe;\n    } while (xe < --r);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawCircleHelper\n** Description:             Support function for drawRoundRect()\n***************************************************************************************/\nvoid TFT_eSPI::drawCircleHelper( int32_t x0, int32_t y0, int32_t rr, uint8_t cornername, uint32_t color)\n{\n  if (rr <= 0) return;\n  int32_t f     = 1 - rr;\n  int32_t ddF_x = 1;\n  int32_t ddF_y = -2 * rr;\n  int32_t xe    = 0;\n  int32_t xs    = 0;\n  int32_t len   = 0;\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  do\n  {\n    while (f < 0) {\n      ++xe;\n      f += (ddF_x += 2);\n    }\n    f += (ddF_y += 2);\n\n    if (xe-xs==1) {\n      if (cornername & 0x1) { // left top\n        drawPixel(x0 - xe, y0 - rr, color);\n        drawPixel(x0 - rr, y0 - xe, color);\n      }\n      if (cornername & 0x2) { // right top\n        drawPixel(x0 + rr    , y0 - xe, color);\n        drawPixel(x0 + xs + 1, y0 - rr, color);\n      }\n      if (cornername & 0x4) { // right bottom\n        drawPixel(x0 + xs + 1, y0 + rr    , color);\n        drawPixel(x0 + rr, y0 + xs + 1, color);\n      }\n      if (cornername & 0x8) { // left bottom\n        drawPixel(x0 - rr, y0 + xs + 1, color);\n        drawPixel(x0 - xe, y0 + rr    , color);\n      }\n    }\n    else {\n      len = xe - xs++;\n      if (cornername & 0x1) { // left top\n        drawFastHLine(x0 - xe, y0 - rr, len, color);\n        drawFastVLine(x0 - rr, y0 - xe, len, color);\n      }\n      if (cornername & 0x2) { // right top\n        drawFastVLine(x0 + rr, y0 - xe, len, color);\n        drawFastHLine(x0 + xs, y0 - rr, len, color);\n      }\n      if (cornername & 0x4) { // right bottom\n        drawFastHLine(x0 + xs, y0 + rr, len, color);\n        drawFastVLine(x0 + rr, y0 + xs, len, color);\n      }\n      if (cornername & 0x8) { // left bottom\n        drawFastVLine(x0 - rr, y0 + xs, len, color);\n        drawFastHLine(x0 - xe, y0 + rr, len, color);\n      }\n    }\n    xs = xe;\n  } while (xe < rr--);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n/***************************************************************************************\n** Function name:           fillCircle\n** Description:             draw a filled circle\n***************************************************************************************/\n// Optimised midpoint circle algorithm, changed to horizontal lines (faster in sprites)\n// Improved algorithm avoids repetition of lines\nvoid TFT_eSPI::fillCircle(int32_t x0, int32_t y0, int32_t r, uint32_t color)\n{\n  int32_t  x  = 0;\n  int32_t  dx = 1;\n  int32_t  dy = r+r;\n  int32_t  p  = -(r>>1);\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  drawFastHLine(x0 - r, y0, dy+1, color);\n\n  while(x<r){\n\n    if(p>=0) {\n      drawFastHLine(x0 - x, y0 + r, dx, color);\n      drawFastHLine(x0 - x, y0 - r, dx, color);\n      dy-=2;\n      p-=dy;\n      r--;\n    }\n\n    dx+=2;\n    p+=dx;\n    x++;\n\n    drawFastHLine(x0 - r, y0 + x, dy+1, color);\n    drawFastHLine(x0 - r, y0 - x, dy+1, color);\n\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n/***************************************************************************************\n** Function name:           fillCircleHelper\n** Description:             Support function for fillRoundRect()\n***************************************************************************************/\n// Support drawing roundrects, changed to horizontal lines (faster in sprites)\nvoid TFT_eSPI::fillCircleHelper(int32_t x0, int32_t y0, int32_t r, uint8_t cornername, int32_t delta, uint32_t color)\n{\n  int32_t f     = 1 - r;\n  int32_t ddF_x = 1;\n  int32_t ddF_y = -r - r;\n  int32_t y     = 0;\n\n  delta++;\n\n  while (y < r) {\n    if (f >= 0) {\n      if (cornername & 0x1) drawFastHLine(x0 - y, y0 + r, y + y + delta, color);\n      if (cornername & 0x2) drawFastHLine(x0 - y, y0 - r, y + y + delta, color);\n      r--;\n      ddF_y += 2;\n      f     += ddF_y;\n    }\n\n    y++;\n    ddF_x += 2;\n    f     += ddF_x;\n\n    if (cornername & 0x1) drawFastHLine(x0 - r, y0 + y, r + r + delta, color);\n    if (cornername & 0x2) drawFastHLine(x0 - r, y0 - y, r + r + delta, color);\n  }\n}\n\n\n/***************************************************************************************\n** Function name:           drawEllipse\n** Description:             Draw a ellipse outline\n***************************************************************************************/\nvoid TFT_eSPI::drawEllipse(int16_t x0, int16_t y0, int32_t rx, int32_t ry, uint16_t color)\n{\n  if (rx<2) return;\n  if (ry<2) return;\n  int32_t x, y;\n  int32_t rx2 = rx * rx;\n  int32_t ry2 = ry * ry;\n  int32_t fx2 = 4 * rx2;\n  int32_t fy2 = 4 * ry2;\n  int32_t s;\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  for (x = 0, y = ry, s = 2*ry2+rx2*(1-2*ry); ry2*x <= rx2*y; x++) {\n    // These are ordered to minimise coordinate changes in x or y\n    // drawPixel can then send fewer bounding box commands\n    drawPixel(x0 + x, y0 + y, color);\n    drawPixel(x0 - x, y0 + y, color);\n    drawPixel(x0 - x, y0 - y, color);\n    drawPixel(x0 + x, y0 - y, color);\n    if (s >= 0) {\n      s += fx2 * (1 - y);\n      y--;\n    }\n    s += ry2 * ((4 * x) + 6);\n  }\n\n  for (x = rx, y = 0, s = 2*rx2+ry2*(1-2*rx); rx2*y <= ry2*x; y++) {\n    // These are ordered to minimise coordinate changes in x or y\n    // drawPixel can then send fewer bounding box commands\n    drawPixel(x0 + x, y0 + y, color);\n    drawPixel(x0 - x, y0 + y, color);\n    drawPixel(x0 - x, y0 - y, color);\n    drawPixel(x0 + x, y0 - y, color);\n    if (s >= 0)\n    {\n      s += fy2 * (1 - x);\n      x--;\n    }\n    s += rx2 * ((4 * y) + 6);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           fillEllipse\n** Description:             draw a filled ellipse\n***************************************************************************************/\nvoid TFT_eSPI::fillEllipse(int16_t x0, int16_t y0, int32_t rx, int32_t ry, uint16_t color)\n{\n  if (rx<2) return;\n  if (ry<2) return;\n  int32_t x, y;\n  int32_t rx2 = rx * rx;\n  int32_t ry2 = ry * ry;\n  int32_t fx2 = 4 * rx2;\n  int32_t fy2 = 4 * ry2;\n  int32_t s;\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  for (x = 0, y = ry, s = 2*ry2+rx2*(1-2*ry); ry2*x <= rx2*y; x++) {\n    drawFastHLine(x0 - x, y0 - y, x + x + 1, color);\n    drawFastHLine(x0 - x, y0 + y, x + x + 1, color);\n\n    if (s >= 0) {\n      s += fx2 * (1 - y);\n      y--;\n    }\n    s += ry2 * ((4 * x) + 6);\n  }\n\n  for (x = rx, y = 0, s = 2*rx2+ry2*(1-2*rx); rx2*y <= ry2*x; y++) {\n    drawFastHLine(x0 - x, y0 - y, x + x + 1, color);\n    drawFastHLine(x0 - x, y0 + y, x + x + 1, color);\n\n    if (s >= 0) {\n      s += fy2 * (1 - x);\n      x--;\n    }\n    s += rx2 * ((4 * y) + 6);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           fillScreen\n** Description:             Clear the screen to defined colour\n***************************************************************************************/\nvoid TFT_eSPI::fillScreen(uint32_t color)\n{\n  fillRect(0, 0, _width, _height, color);\n}\n\n\n/***************************************************************************************\n** Function name:           drawRect\n** Description:             Draw a rectangle outline\n***************************************************************************************/\n// Draw a rectangle\nvoid TFT_eSPI::drawRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  drawFastHLine(x, y, w, color);\n  drawFastHLine(x, y + h - 1, w, color);\n  // Avoid drawing corner pixels twice\n  drawFastVLine(x, y+1, h-2, color);\n  drawFastVLine(x + w - 1, y+1, h-2, color);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawRoundRect\n** Description:             Draw a rounded corner rectangle outline\n***************************************************************************************/\n// Draw a rounded rectangle\nvoid TFT_eSPI::drawRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t r, uint32_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  // smarter version\n  drawFastHLine(x + r  , y    , w - r - r, color); // Top\n  drawFastHLine(x + r  , y + h - 1, w - r - r, color); // Bottom\n  drawFastVLine(x    , y + r  , h - r - r, color); // Left\n  drawFastVLine(x + w - 1, y + r  , h - r - r, color); // Right\n  // draw four corners\n  drawCircleHelper(x + r    , y + r    , r, 1, color);\n  drawCircleHelper(x + w - r - 1, y + r    , r, 2, color);\n  drawCircleHelper(x + w - r - 1, y + h - r - 1, r, 4, color);\n  drawCircleHelper(x + r    , y + h - r - 1, r, 8, color);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           fillRoundRect\n** Description:             Draw a rounded corner filled rectangle\n***************************************************************************************/\n// Fill a rounded rectangle, changed to horizontal lines (faster in sprites)\nvoid TFT_eSPI::fillRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t r, uint32_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  // smarter version\n  fillRect(x, y + r, w, h - r - r, color);\n\n  // draw four corners\n  fillCircleHelper(x + r, y + h - r - 1, r, 1, w - r - r - 1, color);\n  fillCircleHelper(x + r    , y + r, r, 2, w - r - r - 1, color);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawTriangle\n** Description:             Draw a triangle outline using 3 arbitrary points\n***************************************************************************************/\n// Draw a triangle\nvoid TFT_eSPI::drawTriangle(int32_t x0, int32_t y0, int32_t x1, int32_t y1, int32_t x2, int32_t y2, uint32_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  drawLine(x0, y0, x1, y1, color);\n  drawLine(x1, y1, x2, y2, color);\n  drawLine(x2, y2, x0, y0, color);\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           fillTriangle\n** Description:             Draw a filled triangle using 3 arbitrary points\n***************************************************************************************/\n// Fill a triangle - original Adafruit function works well and code footprint is small\nvoid TFT_eSPI::fillTriangle ( int32_t x0, int32_t y0, int32_t x1, int32_t y1, int32_t x2, int32_t y2, uint32_t color)\n{\n  int32_t a, b, y, last;\n\n  // Sort coordinates by Y order (y2 >= y1 >= y0)\n  if (y0 > y1) {\n    transpose(y0, y1); transpose(x0, x1);\n  }\n  if (y1 > y2) {\n    transpose(y2, y1); transpose(x2, x1);\n  }\n  if (y0 > y1) {\n    transpose(y0, y1); transpose(x0, x1);\n  }\n\n  if (y0 == y2) { // Handle awkward all-on-same-line case as its own thing\n    a = b = x0;\n    if (x1 < a)      a = x1;\n    else if (x1 > b) b = x1;\n    if (x2 < a)      a = x2;\n    else if (x2 > b) b = x2;\n    drawFastHLine(a, y0, b - a + 1, color);\n    return;\n  }\n\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  int32_t\n  dx01 = x1 - x0,\n  dy01 = y1 - y0,\n  dx02 = x2 - x0,\n  dy02 = y2 - y0,\n  dx12 = x2 - x1,\n  dy12 = y2 - y1,\n  sa   = 0,\n  sb   = 0;\n\n  // For upper part of triangle, find scanline crossings for segments\n  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1\n  // is included here (and second loop will be skipped, avoiding a /0\n  // error there), otherwise scanline y1 is skipped here and handled\n  // in the second loop...which also avoids a /0 error here if y0=y1\n  // (flat-topped triangle).\n  if (y1 == y2) last = y1;  // Include y1 scanline\n  else         last = y1 - 1; // Skip it\n\n  for (y = y0; y <= last; y++) {\n    a   = x0 + sa / dy01;\n    b   = x0 + sb / dy02;\n    sa += dx01;\n    sb += dx02;\n\n    if (a > b) transpose(a, b);\n    drawFastHLine(a, y, b - a + 1, color);\n  }\n\n  // For lower part of triangle, find scanline crossings for segments\n  // 0-2 and 1-2.  This loop is skipped if y1=y2.\n  sa = dx12 * (y - y1);\n  sb = dx02 * (y - y0);\n  for (; y <= y2; y++) {\n    a   = x1 + sa / dy12;\n    b   = x0 + sb / dy02;\n    sa += dx12;\n    sb += dx02;\n\n    if (a > b) transpose(a, b);\n    drawFastHLine(a, y, b - a + 1, color);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawBitmap\n** Description:             Draw an image stored in an array on the TFT\n***************************************************************************************/\nvoid TFT_eSPI::drawBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  int32_t i, j, byteWidth = (w + 7) / 8;\n\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++ ) {\n      if (pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {\n        drawPixel(x + i, y + j, color);\n      }\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawBitmap\n** Description:             Draw an image stored in an array on the TFT\n***************************************************************************************/\nvoid TFT_eSPI::drawBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t fgcolor, uint16_t bgcolor)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  int32_t i, j, byteWidth = (w + 7) / 8;\n\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++ ) {\n      if (pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7)))\n           drawPixel(x + i, y + j, fgcolor);\n      else drawPixel(x + i, y + j, bgcolor);\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n/***************************************************************************************\n** Function name:           drawXBitmap\n** Description:             Draw an image stored in an XBM array onto the TFT\n***************************************************************************************/\nvoid TFT_eSPI::drawXBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  int32_t i, j, byteWidth = (w + 7) / 8;\n\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++ ) {\n      if (pgm_read_byte(bitmap + j * byteWidth + i / 8) & (1 << (i & 7))) {\n        drawPixel(x + i, y + j, color);\n      }\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           drawXBitmap\n** Description:             Draw an XBM image with foreground and background colors\n***************************************************************************************/\nvoid TFT_eSPI::drawXBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color, uint16_t bgcolor)\n{\n  //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  int32_t i, j, byteWidth = (w + 7) / 8;\n\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++ ) {\n      if (pgm_read_byte(bitmap + j * byteWidth + i / 8) & (1 << (i & 7)))\n           drawPixel(x + i, y + j,   color);\n      else drawPixel(x + i, y + j, bgcolor);\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();              // Does nothing if Sprite class uses this function\n}\n\n\n/***************************************************************************************\n** Function name:           setCursor\n** Description:             Set the text cursor x,y position\n***************************************************************************************/\nvoid TFT_eSPI::setCursor(int16_t x, int16_t y)\n{\n  cursor_x = x;\n  cursor_y = y;\n}\n\n\n/***************************************************************************************\n** Function name:           setCursor\n** Description:             Set the text cursor x,y position and font\n***************************************************************************************/\nvoid TFT_eSPI::setCursor(int16_t x, int16_t y, uint8_t font)\n{\n  setTextFont(font);\n  cursor_x = x;\n  cursor_y = y;\n}\n\n\n/***************************************************************************************\n** Function name:           getCursorX\n** Description:             Get the text cursor x position\n***************************************************************************************/\nint16_t TFT_eSPI::getCursorX(void)\n{\n  return cursor_x;\n}\n\n/***************************************************************************************\n** Function name:           getCursorY\n** Description:             Get the text cursor y position\n***************************************************************************************/\nint16_t TFT_eSPI::getCursorY(void)\n{\n  return cursor_y;\n}\n\n\n/***************************************************************************************\n** Function name:           setTextSize\n** Description:             Set the text size multiplier\n***************************************************************************************/\nvoid TFT_eSPI::setTextSize(uint8_t s)\n{\n  if (s>7) s = 7; // Limit the maximum size multiplier so byte variables can be used for rendering\n  textsize = (s > 0) ? s : 1; // Don't allow font size 0\n}\n\n\n/***************************************************************************************\n** Function name:           setTextColor\n** Description:             Set the font foreground colour (background is transparent)\n***************************************************************************************/\nvoid TFT_eSPI::setTextColor(uint16_t c)\n{\n  // For 'transparent' background, we'll set the bg\n  // to the same as fg instead of using a flag\n  textcolor = textbgcolor = c;\n}\n\n\n/***************************************************************************************\n** Function name:           setTextColor\n** Description:             Set the font foreground and background colour\n***************************************************************************************/\n// Smooth fonts use the background colour for anti-aliasing and by default the\n// background is not filled. If bgfill = true, then a smooth font background fill will\n// be used.\nvoid TFT_eSPI::setTextColor(uint16_t c, uint16_t b, bool bgfill)\n{\n  textcolor   = c;\n  textbgcolor = b;\n  _fillbg     = bgfill;\n}\n\n\n/***************************************************************************************\n** Function name:           setPivot\n** Description:             Set the pivot point on the TFT\n*************************************************************************************x*/\nvoid TFT_eSPI::setPivot(int16_t x, int16_t y)\n{\n  _xPivot = x;\n  _yPivot = y;\n}\n\n\n/***************************************************************************************\n** Function name:           getPivotX\n** Description:             Get the x pivot position\n***************************************************************************************/\nint16_t TFT_eSPI::getPivotX(void)\n{\n  return _xPivot;\n}\n\n\n/***************************************************************************************\n** Function name:           getPivotY\n** Description:             Get the y pivot position\n***************************************************************************************/\nint16_t TFT_eSPI::getPivotY(void)\n{\n  return _yPivot;\n}\n\n\n/***************************************************************************************\n** Function name:           setBitmapColor\n** Description:             Set the foreground foreground and background colour\n***************************************************************************************/\nvoid TFT_eSPI::setBitmapColor(uint16_t c, uint16_t b)\n{\n  if (c == b) b = ~c;\n  bitmap_fg = c;\n  bitmap_bg = b;\n}\n\n\n/***************************************************************************************\n** Function name:           setTextWrap\n** Description:             Define if text should wrap at end of line\n***************************************************************************************/\nvoid TFT_eSPI::setTextWrap(bool wrapX, bool wrapY)\n{\n  textwrapX = wrapX;\n  textwrapY = wrapY;\n}\n\n\n/***************************************************************************************\n** Function name:           setTextDatum\n** Description:             Set the text position reference datum\n***************************************************************************************/\nvoid TFT_eSPI::setTextDatum(uint8_t d)\n{\n  textdatum = d;\n}\n\n\n/***************************************************************************************\n** Function name:           setTextPadding\n** Description:             Define padding width (aids erasing old text and numbers)\n***************************************************************************************/\nvoid TFT_eSPI::setTextPadding(uint16_t x_width)\n{\n  padX = x_width;\n}\n\n/***************************************************************************************\n** Function name:           setTextPadding\n** Description:             Define padding width (aids erasing old text and numbers)\n***************************************************************************************/\nuint16_t TFT_eSPI::getTextPadding(void)\n{\n  return padX;\n}\n\n/***************************************************************************************\n** Function name:           getTextDatum\n** Description:             Return the text datum value (as used by setTextDatum())\n***************************************************************************************/\nuint8_t TFT_eSPI::getTextDatum(void)\n{\n  return textdatum;\n}\n\n\n/***************************************************************************************\n** Function name:           width\n** Description:             Return the pixel width of display (per current rotation)\n***************************************************************************************/\n// Return the size of the display (per current rotation)\nint16_t TFT_eSPI::width(void)\n{\n  if (_vpDatum) return _xWidth;\n  return _width;\n}\n\n\n/***************************************************************************************\n** Function name:           height\n** Description:             Return the pixel height of display (per current rotation)\n***************************************************************************************/\nint16_t TFT_eSPI::height(void)\n{\n  if (_vpDatum) return _yHeight;\n  return _height;\n}\n\n\n/***************************************************************************************\n** Function name:           textWidth\n** Description:             Return the width in pixels of a string in a given font\n***************************************************************************************/\nint16_t TFT_eSPI::textWidth(const String& string)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return textWidth(buffer, textfont);\n}\n\nint16_t TFT_eSPI::textWidth(const String& string, uint8_t font)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return textWidth(buffer, font);\n}\n\nint16_t TFT_eSPI::textWidth(const char *string)\n{\n  return textWidth(string, textfont);\n}\n\nint16_t TFT_eSPI::textWidth(const char *string, uint8_t font)\n{\n  int32_t str_width = 0;\n  uint16_t uniCode  = 0;\n\n#ifdef SMOOTH_FONT\n  if(fontLoaded) {\n    while (*string) {\n      uniCode = decodeUTF8(*string++);\n      if (uniCode) {\n        if (uniCode == 0x20) str_width += gFont.spaceWidth;\n        else {\n          uint16_t gNum = 0;\n          bool found = getUnicodeIndex(uniCode, &gNum);\n          if (found) {\n            if(str_width == 0 && gdX[gNum] < 0) str_width -= gdX[gNum];\n            if (*string || isDigits) str_width += gxAdvance[gNum];\n            else str_width += (gdX[gNum] + gWidth[gNum]);\n          }\n          else str_width += gFont.spaceWidth + 1;\n        }\n      }\n    }\n    isDigits = false;\n    return str_width;\n  }\n#endif\n\n  if (font>1 && font<9) {\n    char *widthtable = (char *)pgm_read_dword( &(fontdata[font].widthtbl ) ) - 32; //subtract the 32 outside the loop\n\n    while (*string) {\n      uniCode = *(string++);\n      if (uniCode > 31 && uniCode < 128)\n      str_width += pgm_read_byte( widthtable + uniCode); // Normally we need to subtract 32 from uniCode\n      else str_width += pgm_read_byte( widthtable + 32); // Set illegal character = space width\n    }\n\n  }\n  else {\n\n#ifdef LOAD_GFXFF\n    if(gfxFont) { // New font\n      while (*string) {\n        uniCode = decodeUTF8(*string++);\n        if ((uniCode >= pgm_read_word(&gfxFont->first)) && (uniCode <= pgm_read_word(&gfxFont->last ))) {\n          uniCode -= pgm_read_word(&gfxFont->first);\n          GFXglyph *glyph  = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[uniCode]);\n          // If this is not the  last character or is a digit then use xAdvance\n          if (*string  || isDigits) str_width += pgm_read_byte(&glyph->xAdvance);\n          // Else use the offset plus width since this can be bigger than xAdvance\n          else str_width += ((int8_t)pgm_read_byte(&glyph->xOffset) + pgm_read_byte(&glyph->width));\n        }\n      }\n    }\n    else\n#endif\n    {\n#ifdef LOAD_GLCD\n      while (*string++) str_width += 6;\n#endif\n    }\n  }\n  isDigits = false;\n  return str_width * textsize;\n}\n\n\n/***************************************************************************************\n** Function name:           fontsLoaded\n** Description:             return an encoded 16-bit value showing the fonts loaded\n***************************************************************************************/\n// Returns a value showing which fonts are loaded (bit N set =  Font N loaded)\nuint16_t TFT_eSPI::fontsLoaded(void)\n{\n  return fontsloaded;\n}\n\n\n/***************************************************************************************\n** Function name:           fontHeight\n** Description:             return the height of a font (yAdvance for free fonts)\n***************************************************************************************/\nint16_t TFT_eSPI::fontHeight(uint8_t font)\n{\n  if (font > 8) return 0;\n\n#ifdef SMOOTH_FONT\n  if(fontLoaded) return gFont.yAdvance;\n#endif\n\n#ifdef LOAD_GFXFF\n  if (font==1) {\n    if(gfxFont) { // New font\n      return pgm_read_byte(&gfxFont->yAdvance) * textsize;\n    }\n  }\n#endif\n  return pgm_read_byte( &fontdata[font].height ) * textsize;\n}\n\nint16_t TFT_eSPI::fontHeight(void)\n{\n  return fontHeight(textfont);\n}\n\n/***************************************************************************************\n** Function name:           drawChar\n** Description:             draw a single character in the GLCD or GFXFF font\n***************************************************************************************/\nvoid TFT_eSPI::drawChar(int32_t x, int32_t y, uint16_t c, uint32_t color, uint32_t bg, uint8_t size)\n{\n  if (_vpOoB) return;\n\n#ifdef LOAD_GLCD\n//>>>>>>>>>>>>>>>>>>\n  #ifdef LOAD_GFXFF\n  if(!gfxFont) { // 'Classic' built-in GLCD font\n  #endif\n//>>>>>>>>>>>>>>>>>>\n\n  int32_t xd = x + _xDatum;\n  int32_t yd = y + _yDatum;\n\n  if ((xd >= _vpW)                 || // Clip right\n     ( yd >= _vpH)                 || // Clip bottom\n     ((xd + 6 * size - 1) < _vpX)  || // Clip left\n     ((yd + 8 * size - 1) < _vpY))    // Clip top\n    return;\n\n  if (c > 255) return;\n  if (!_cp437 && c > 175) c++;\n\n  bool fillbg = (bg != color);\n  bool clip = xd < _vpX || xd + 6  * textsize >= _vpW || yd < _vpY || yd + 8 * textsize >= _vpH;\n\n  if ((size==1) && fillbg && !clip) {\n    uint8_t column[6];\n    uint8_t mask = 0x1;\n    begin_tft_write();\n\n    setWindow(xd, yd, xd+5, yd+7);\n\n    for (int8_t i = 0; i < 5; i++ ) column[i] = pgm_read_byte(&font[0] + (c * 5) + i);\n    column[5] = 0;\n\n    for (int8_t j = 0; j < 8; j++) {\n      for (int8_t k = 0; k < 5; k++ ) {\n        if (column[k] & mask) {tft_Write_16(color);}\n        else {tft_Write_16(bg);}\n      }\n      mask <<= 1;\n      tft_Write_16(bg);\n    }\n\n    end_tft_write();\n  }\n  else {\n    //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n    inTransaction = true;\n\n    for (int8_t i = 0; i < 6; i++ ) {\n      uint8_t line;\n      if (i == 5)\n        line = 0x0;\n      else\n        line = pgm_read_byte(&font[0] + (c * 5) + i);\n\n      if (size == 1 && !fillbg) { // default size\n        for (int8_t j = 0; j < 8; j++) {\n          if (line & 0x1) drawPixel(x + i, y + j, color);\n          line >>= 1;\n        }\n      }\n      else {  // big size or clipped\n        for (int8_t j = 0; j < 8; j++) {\n          if (line & 0x1) fillRect(x + (i * size), y + (j * size), size, size, color);\n          else if (fillbg) fillRect(x + i * size, y + j * size, size, size, bg);\n          line >>= 1;\n        }\n      }\n    }\n    inTransaction = lockTransaction;\n    end_tft_write();              // Does nothing if Sprite class uses this function\n  }\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  #ifdef LOAD_GFXFF\n  } else { // Custom font\n  #endif\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>\n#endif // LOAD_GLCD\n\n#ifdef LOAD_GFXFF\n    // Filter out bad characters not present in font\n    if ((c >= pgm_read_word(&gfxFont->first)) && (c <= pgm_read_word(&gfxFont->last ))) {\n      //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n      inTransaction = true;\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n      c -= pgm_read_word(&gfxFont->first);\n      GFXglyph *glyph  = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[c]);\n      uint8_t  *bitmap = (uint8_t *)pgm_read_dword(&gfxFont->bitmap);\n\n      uint32_t bo = pgm_read_word(&glyph->bitmapOffset);\n      uint8_t  w  = pgm_read_byte(&glyph->width),\n               h  = pgm_read_byte(&glyph->height);\n               //xa = pgm_read_byte(&glyph->xAdvance);\n      int8_t   xo = pgm_read_byte(&glyph->xOffset),\n               yo = pgm_read_byte(&glyph->yOffset);\n      uint8_t  xx, yy, bits=0, bit=0;\n      int16_t  xo16 = 0, yo16 = 0;\n\n      if(size > 1) {\n        xo16 = xo;\n        yo16 = yo;\n      }\n\n      // GFXFF rendering speed up\n      uint16_t hpc = 0; // Horizontal foreground pixel count\n      for(yy=0; yy<h; yy++) {\n        for(xx=0; xx<w; xx++) {\n          if(bit == 0) {\n            bits = pgm_read_byte(&bitmap[bo++]);\n            bit  = 0x80;\n          }\n          if(bits & bit) hpc++;\n          else {\n           if (hpc) {\n              if(size == 1) drawFastHLine(x+xo+xx-hpc, y+yo+yy, hpc, color);\n              else fillRect(x+(xo16+xx-hpc)*size, y+(yo16+yy)*size, size*hpc, size, color);\n              hpc=0;\n            }\n          }\n          bit >>= 1;\n        }\n        // Draw pixels for this line as we are about to increment yy\n        if (hpc) {\n          if(size == 1) drawFastHLine(x+xo+xx-hpc, y+yo+yy, hpc, color);\n          else fillRect(x+(xo16+xx-hpc)*size, y+(yo16+yy)*size, size*hpc, size, color);\n          hpc=0;\n        }\n      }\n\n      inTransaction = lockTransaction;\n      end_tft_write();              // Does nothing if Sprite class uses this function\n    }\n#endif\n\n#ifdef LOAD_GLCD\n  #ifdef LOAD_GFXFF\n  } // End classic vs custom font\n  #endif\n#else\n  #ifndef LOAD_GFXFF\n    // Avoid warnings if fonts are disabled\n    x = x;\n    y = y;\n    color = color;\n    bg = bg;\n    size = size;\n  #endif\n#endif\n\n}\n\n\n/***************************************************************************************\n** Function name:           setAddrWindow\n** Description:             define an area to receive a stream of pixels\n***************************************************************************************/\n// Chip select is high at the end of this function\nvoid TFT_eSPI::setAddrWindow(int32_t x0, int32_t y0, int32_t w, int32_t h)\n{\n  begin_tft_write();\n\n  setWindow(x0, y0, x0 + w - 1, y0 + h - 1);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           setWindow\n** Description:             define an area to receive a stream of pixels\n***************************************************************************************/\n// Chip select stays low, call begin_tft_write first. Use setAddrWindow() from sketches\nvoid TFT_eSPI::setWindow(int32_t x0, int32_t y0, int32_t x1, int32_t y1)\n{\n  //begin_tft_write(); // Must be called before setWindow\n  addr_row = 0xFFFF;\n  addr_col = 0xFFFF;\n\n#if defined (ILI9225_DRIVER)\n  if (rotation & 0x01) { transpose(x0, y0); transpose(x1, y1); }\n  SPI_BUSY_CHECK;\n  DC_C; tft_Write_8(TFT_CASET1);\n  DC_D; tft_Write_16(x0);\n  DC_C; tft_Write_8(TFT_CASET2);\n  DC_D; tft_Write_16(x1);\n\n  DC_C; tft_Write_8(TFT_PASET1);\n  DC_D; tft_Write_16(y0);\n  DC_C; tft_Write_8(TFT_PASET2);\n  DC_D; tft_Write_16(y1);\n\n  DC_C; tft_Write_8(TFT_RAM_ADDR1);\n  DC_D; tft_Write_16(x0);\n  DC_C; tft_Write_8(TFT_RAM_ADDR2);\n  DC_D; tft_Write_16(y0);\n\n  // write to RAM\n  DC_C; tft_Write_8(TFT_RAMWR);\n  DC_D;\n  // Temporary solution is to include the RP2040 code here\n  #if (defined(ARDUINO_ARCH_RP2040)  || defined (ARDUINO_ARCH_MBED)) && !defined(RP2040_PIO_INTERFACE)\n    // For ILI9225 and RP2040 the slower Arduino SPI transfer calls were used, so need to swap back to 16-bit mode\n    while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n    hw_write_masked(&spi_get_hw(SPI_X)->cr0, (16 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n  #endif\n#elif defined (SSD1351_DRIVER)\n  if (rotation & 1) {\n    transpose(x0, y0);\n    transpose(x1, y1);\n  }\n  SPI_BUSY_CHECK;\n  DC_C; tft_Write_8(TFT_CASET);\n  DC_D; tft_Write_16(x1 | (x0 << 8));\n  DC_C; tft_Write_8(TFT_PASET);\n  DC_D; tft_Write_16(y1 | (y0 << 8));\n  DC_C; tft_Write_8(TFT_RAMWR);\n  DC_D;\n#else\n  #if defined (SSD1963_DRIVER)\n    if ((rotation & 0x1) == 0) { transpose(x0, y0); transpose(x1, y1); }\n  #endif\n\n  #ifdef CGRAM_OFFSET\n    x0+=colstart;\n    x1+=colstart;\n    y0+=rowstart;\n    y1+=rowstart;\n  #endif\n\n  // Temporary solution is to include the RP2040 optimised code here\n  #if (defined(ARDUINO_ARCH_RP2040)  || defined (ARDUINO_ARCH_MBED))\n    #if !defined(RP2040_PIO_INTERFACE)\n      // Use hardware SPI port, this code does not swap from 8 to 16-bit\n      // to avoid the spi_set_format() call overhead\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_C;\n      #if !defined (SPI_18BIT_DRIVER)\n        #if  defined (RPI_DISPLAY_TYPE) // RPi TFT type always needs 16-bit transfers\n          hw_write_masked(&spi_get_hw(SPI_X)->cr0, (16 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n        #else\n          hw_write_masked(&spi_get_hw(SPI_X)->cr0, (8 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n        #endif\n      #endif\n      spi_get_hw(SPI_X)->dr = (uint32_t)TFT_CASET;\n\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_D;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x0>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x0;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x1>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x1;\n\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_C;\n      spi_get_hw(SPI_X)->dr = (uint32_t)TFT_PASET;\n\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_D;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y0>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y0;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y1>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y1;\n\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_C;\n      spi_get_hw(SPI_X)->dr = (uint32_t)TFT_RAMWR;\n\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      #if !defined (SPI_18BIT_DRIVER)\n        hw_write_masked(&spi_get_hw(SPI_X)->cr0, (16 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n      #endif\n      DC_D;\n    #elif defined (RM68120_DRIVER)\n      DC_C; tft_Write_16(TFT_CASET+0); DC_D; tft_Write_16(x0 >> 8);\n      DC_C; tft_Write_16(TFT_CASET+1); DC_D; tft_Write_16(x0 & 0xFF);\n      DC_C; tft_Write_16(TFT_CASET+2); DC_D; tft_Write_16(x1 >> 8);\n      DC_C; tft_Write_16(TFT_CASET+3); DC_D; tft_Write_16(x1 & 0xFF);\n      DC_C; tft_Write_16(TFT_PASET+0); DC_D; tft_Write_16(y0 >> 8);\n      DC_C; tft_Write_16(TFT_PASET+1); DC_D; tft_Write_16(y0 & 0xFF);\n      DC_C; tft_Write_16(TFT_PASET+2); DC_D; tft_Write_16(y1 >> 8);\n      DC_C; tft_Write_16(TFT_PASET+3); DC_D; tft_Write_16(y1 & 0xFF);\n\n      DC_C; tft_Write_16(TFT_RAMWR);\n      DC_D;\n    #else\n      // This is for the RP2040 and PIO interface (SPI or parallel)\n      WAIT_FOR_STALL;\n      tft_pio->sm[pio_sm].instr = pio_instr_addr;\n\n      TX_FIFO = TFT_CASET;\n      TX_FIFO = (x0<<16) | x1;\n      TX_FIFO = TFT_PASET;\n      TX_FIFO = (y0<<16) | y1;\n      TX_FIFO = TFT_RAMWR;\n    #endif\n  #else\n    SPI_BUSY_CHECK;\n    DC_C; tft_Write_8(TFT_CASET);\n    DC_D; tft_Write_32C(x0, x1);\n    DC_C; tft_Write_8(TFT_PASET);\n    DC_D; tft_Write_32C(y0, y1);\n    DC_C; tft_Write_8(TFT_RAMWR);\n    DC_D;\n  #endif // RP2040 SPI\n#endif\n  //end_tft_write(); // Must be called after setWindow\n}\n\n/***************************************************************************************\n** Function name:           readAddrWindow\n** Description:             define an area to read a stream of pixels\n***************************************************************************************/\nvoid TFT_eSPI::readAddrWindow(int32_t xs, int32_t ys, int32_t w, int32_t h)\n{\n  //begin_tft_write(); // Must be called before readAddrWindow or CS set low\n\n  int32_t xe = xs + w - 1;\n  int32_t ye = ys + h - 1;\n\n  addr_col = 0xFFFF;\n  addr_row = 0xFFFF;\n\n#if defined (SSD1963_DRIVER)\n  if ((rotation & 0x1) == 0) { transpose(xs, ys); transpose(xe, ye); }\n#endif\n\n#ifdef CGRAM_OFFSET\n  xs += colstart;\n  xe += colstart;\n  ys += rowstart;\n  ye += rowstart;\n#endif\n\n  // Temporary solution is to include the RP2040 optimised code here\n#if (defined(ARDUINO_ARCH_RP2040)  || defined (ARDUINO_ARCH_MBED)) && !defined(RP2040_PIO_INTERFACE)\n  // Use hardware SPI port, this code does not swap from 8 to 16-bit\n  // to avoid the spi_set_format() call overhead\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_C;\n  hw_write_masked(&spi_get_hw(SPI_X)->cr0, (8 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n  spi_get_hw(SPI_X)->dr = (uint32_t)TFT_CASET;\n\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_D;\n  spi_get_hw(SPI_X)->dr = (uint32_t)xs>>8;\n  spi_get_hw(SPI_X)->dr = (uint32_t)xs;\n  spi_get_hw(SPI_X)->dr = (uint32_t)xe>>8;\n  spi_get_hw(SPI_X)->dr = (uint32_t)xe;\n\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_C;\n  spi_get_hw(SPI_X)->dr = (uint32_t)TFT_PASET;\n\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_D;\n  spi_get_hw(SPI_X)->dr = (uint32_t)ys>>8;\n  spi_get_hw(SPI_X)->dr = (uint32_t)ys;\n  spi_get_hw(SPI_X)->dr = (uint32_t)ye>>8;\n  spi_get_hw(SPI_X)->dr = (uint32_t)ye;\n\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_C;\n  spi_get_hw(SPI_X)->dr = (uint32_t)TFT_RAMRD;\n\n  while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  DC_D;\n\n  // Flush the rx buffer and reset overflow flag\n  while (spi_is_readable(SPI_X)) (void)spi_get_hw(SPI_X)->dr;\n  spi_get_hw(SPI_X)->icr = SPI_SSPICR_RORIC_BITS;\n\n#else\n  // Column addr set\n  DC_C; tft_Write_8(TFT_CASET);\n  DC_D; tft_Write_32C(xs, xe);\n\n  // Row addr set\n  DC_C; tft_Write_8(TFT_PASET);\n  DC_D; tft_Write_32C(ys, ye);\n\n  // Read CGRAM command\n  DC_C; tft_Write_8(TFT_RAMRD);\n\n  DC_D;\n#endif // RP2040 SPI\n\n  //end_tft_write(); // Must be called after readAddrWindow or CS set high\n}\n\n\n/***************************************************************************************\n** Function name:           drawPixel\n** Description:             push a single pixel at an arbitrary position\n***************************************************************************************/\nvoid TFT_eSPI::drawPixel(int32_t x, int32_t y, uint32_t color)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Range checking\n  if ((x < _vpX) || (y < _vpY) ||(x >= _vpW) || (y >= _vpH)) return;\n\n#ifdef CGRAM_OFFSET\n  x+=colstart;\n  y+=rowstart;\n#endif\n\n#if (defined (MULTI_TFT_SUPPORT) || defined (GC9A01_DRIVER)) && !defined (ILI9225_DRIVER)\n  addr_row = 0xFFFF;\n  addr_col = 0xFFFF;\n#endif\n\n  begin_tft_write();\n\n#if defined (ILI9225_DRIVER)\n  if (rotation & 0x01) { transpose(x, y); }\n  SPI_BUSY_CHECK;\n\n  // Set window to full screen to optimise sequential pixel rendering\n  if (addr_row != 0x9225) {\n    addr_row = 0x9225; // addr_row used for flag\n    DC_C; tft_Write_8(TFT_CASET1);\n    DC_D; tft_Write_16(0);\n    DC_C; tft_Write_8(TFT_CASET2);\n    DC_D; tft_Write_16(175);\n\n    DC_C; tft_Write_8(TFT_PASET1);\n    DC_D; tft_Write_16(0);\n    DC_C; tft_Write_8(TFT_PASET2);\n    DC_D; tft_Write_16(219);\n  }\n\n  // Define pixel coordinate\n  DC_C; tft_Write_8(TFT_RAM_ADDR1);\n  DC_D; tft_Write_16(x);\n  DC_C; tft_Write_8(TFT_RAM_ADDR2);\n  DC_D; tft_Write_16(y);\n\n  // write to RAM\n  DC_C; tft_Write_8(TFT_RAMWR);\n  #if defined(TFT_PARALLEL_8_BIT) || defined(TFT_PARALLEL_16_BIT) || !defined(ESP32)\n    DC_D; tft_Write_16(color);\n  #else\n    DC_D; tft_Write_16N(color);\n  #endif\n\n// Temporary solution is to include the RP2040 optimised code here\n#elif (defined (ARDUINO_ARCH_RP2040) || defined (ARDUINO_ARCH_MBED)) && !defined (SSD1351_DRIVER)\n\n  #if defined (SSD1963_DRIVER)\n    if ((rotation & 0x1) == 0) { transpose(x, y); }\n  #endif\n\n  #if !defined(RP2040_PIO_INTERFACE)\n    while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n\n    #if  defined (RPI_DISPLAY_TYPE) // RPi TFT type always needs 16-bit transfers\n      hw_write_masked(&spi_get_hw(SPI_X)->cr0, (16 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n    #else\n      hw_write_masked(&spi_get_hw(SPI_X)->cr0, (8 - 1) << SPI_SSPCR0_DSS_LSB, SPI_SSPCR0_DSS_BITS);\n    #endif\n\n    if (addr_col != x) {\n      DC_C;\n      spi_get_hw(SPI_X)->dr = (uint32_t)TFT_CASET;\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS){};\n      DC_D;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)x;\n      addr_col = x;\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n    }\n\n    if (addr_row != y) {\n      DC_C;\n      spi_get_hw(SPI_X)->dr = (uint32_t)TFT_PASET;\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_D;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y>>8;\n      spi_get_hw(SPI_X)->dr = (uint32_t)y;\n      addr_row = y;\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n    }\n\n    DC_C;\n    spi_get_hw(SPI_X)->dr = (uint32_t)TFT_RAMWR;\n\n    #if defined (SPI_18BIT_DRIVER) // SPI 18-bit colour\n      uint8_t r = (color & 0xF800)>>8;\n      uint8_t g = (color & 0x07E0)>>3;\n      uint8_t b = (color & 0x001F)<<3;\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_D;\n      tft_Write_8N(r); tft_Write_8N(g); tft_Write_8N(b);\n    #else\n      while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n      DC_D;\n      #if  defined (RPI_DISPLAY_TYPE) // RPi TFT type always needs 16-bit transfers\n        spi_get_hw(SPI_X)->dr = (uint32_t)color;\n      #else\n        spi_get_hw(SPI_X)->dr = (uint32_t)color>>8;\n        spi_get_hw(SPI_X)->dr = (uint32_t)color;\n      #endif\n    #endif\n    while (spi_get_hw(SPI_X)->sr & SPI_SSPSR_BSY_BITS) {};\n  #elif defined (RM68120_DRIVER)\n    if (addr_col != x) {\n      DC_C; tft_Write_16(TFT_CASET+0); DC_D; tft_Write_16(x >> 8);\n      DC_C; tft_Write_16(TFT_CASET+1); DC_D; tft_Write_16(x & 0xFF);\n      DC_C; tft_Write_16(TFT_CASET+2); DC_D; tft_Write_16(x >> 8);\n      DC_C; tft_Write_16(TFT_CASET+3); DC_D; tft_Write_16(x & 0xFF);\n      addr_col = x;\n    }\n    if (addr_row != y) {\n      DC_C; tft_Write_16(TFT_PASET+0); DC_D; tft_Write_16(y >> 8);\n      DC_C; tft_Write_16(TFT_PASET+1); DC_D; tft_Write_16(y & 0xFF);\n      DC_C; tft_Write_16(TFT_PASET+2); DC_D; tft_Write_16(y >> 8);\n      DC_C; tft_Write_16(TFT_PASET+3); DC_D; tft_Write_16(y & 0xFF);\n      addr_row = y;\n    }\n    DC_C; tft_Write_16(TFT_RAMWR); DC_D;\n\n    TX_FIFO = color;\n  #else\n    // This is for the RP2040 and PIO interface (SPI or parallel)\n    WAIT_FOR_STALL;\n    tft_pio->sm[pio_sm].instr = pio_instr_addr;\n    TX_FIFO = TFT_CASET;\n    TX_FIFO = (x<<16) | x;\n    TX_FIFO = TFT_PASET;\n    TX_FIFO = (y<<16) | y;\n    TX_FIFO = TFT_RAMWR;\n    //DC set high by PIO\n    #if  defined (SPI_18BIT_DRIVER) || (defined (SSD1963_DRIVER) && defined (TFT_PARALLEL_8_BIT))\n      TX_FIFO = ((color & 0xF800)<<8) | ((color & 0x07E0)<<5) | ((color & 0x001F)<<3);\n    #else\n      TX_FIFO = color;\n    #endif\n\n  #endif\n\n#else\n\n  #if defined (SSD1963_DRIVER)\n    if ((rotation & 0x1) == 0) { transpose(x, y); }\n  #endif\n\n    SPI_BUSY_CHECK;\n\n  #if defined (SSD1351_DRIVER)\n    if (rotation & 0x1) { transpose(x, y); }\n    // No need to send x if it has not changed (speeds things up)\n    if (addr_col != x) {\n      DC_C; tft_Write_8(TFT_CASET);\n      DC_D; tft_Write_16(x | (x << 8));\n      addr_col = x;\n    }\n\n    // No need to send y if it has not changed (speeds things up)\n    if (addr_row != y) {\n      DC_C; tft_Write_8(TFT_PASET);\n      DC_D; tft_Write_16(y | (y << 8));\n      addr_row = y;\n    }\n  #else\n    // No need to send x if it has not changed (speeds things up)\n    if (addr_col != x) {\n      DC_C; tft_Write_8(TFT_CASET);\n      DC_D; tft_Write_32D(x);\n      addr_col = x;\n    }\n\n    // No need to send y if it has not changed (speeds things up)\n    if (addr_row != y) {\n      DC_C; tft_Write_8(TFT_PASET);\n      DC_D; tft_Write_32D(y);\n      addr_row = y;\n    }\n  #endif\n\n  DC_C; tft_Write_8(TFT_RAMWR);\n\n  #if defined(TFT_PARALLEL_8_BIT) || defined(TFT_PARALLEL_16_BIT) || !defined(ESP32)\n    DC_D; tft_Write_16(color);\n  #else\n    DC_D; tft_Write_16N(color);\n  #endif\n#endif\n\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           pushColor\n** Description:             push a single pixel\n***************************************************************************************/\nvoid TFT_eSPI::pushColor(uint16_t color)\n{\n  begin_tft_write();\n\n  SPI_BUSY_CHECK;\n  tft_Write_16N(color);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           pushColor\n** Description:             push a single colour to \"len\" pixels\n***************************************************************************************/\nvoid TFT_eSPI::pushColor(uint16_t color, uint32_t len)\n{\n  begin_tft_write();\n\n  pushBlock(color, len);\n\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           startWrite\n** Description:             begin transaction with CS low, MUST later call endWrite\n***************************************************************************************/\nvoid TFT_eSPI::startWrite(void)\n{\n  begin_tft_write();\n  lockTransaction = true; // Lock transaction for all sequentially run sketch functions\n  inTransaction = true;\n}\n\n/***************************************************************************************\n** Function name:           endWrite\n** Description:             end transaction with CS high\n***************************************************************************************/\nvoid TFT_eSPI::endWrite(void)\n{\n  lockTransaction = false; // Release sketch induced transaction lock\n  inTransaction = false;\n  DMA_BUSY_CHECK;          // Safety check - user code should have checked this!\n  end_tft_write();         // Release SPI bus\n}\n\n/***************************************************************************************\n** Function name:           writeColor (use startWrite() and endWrite() before & after)\n** Description:             raw write of \"len\" pixels avoiding transaction check\n***************************************************************************************/\nvoid TFT_eSPI::writeColor(uint16_t color, uint32_t len)\n{\n  pushBlock(color, len);\n}\n\n/***************************************************************************************\n** Function name:           pushColors\n** Description:             push an array of pixels for 16-bit raw image drawing\n***************************************************************************************/\n// Assumed that setAddrWindow() has previously been called\n// len is number of bytes, not pixels\nvoid TFT_eSPI::pushColors(uint8_t *data, uint32_t len)\n{\n  begin_tft_write();\n\n  pushPixels(data, len>>1);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           pushColors\n** Description:             push an array of pixels, for image drawing\n***************************************************************************************/\nvoid TFT_eSPI::pushColors(uint16_t *data, uint32_t len, bool swap)\n{\n  begin_tft_write();\n  if (swap) {swap = _swapBytes; _swapBytes = true; }\n\n  pushPixels(data, len);\n\n  _swapBytes = swap; // Restore old value\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           drawLine\n** Description:             draw a line between 2 arbitrary points\n***************************************************************************************/\n// Bresenham's algorithm - thx Wikipedia - speed enhanced by Bodmer to use\n// an efficient FastH/V Line draw routine for line segments of 2 pixels or more\nvoid TFT_eSPI::drawLine(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t color)\n{\n  if (_vpOoB) return;\n\n  //begin_tft_write();       // Sprite class can use this function, avoiding begin_tft_write()\n  inTransaction = true;\n\n  //x+= _xDatum;             // Not added here, added by drawPixel & drawFastXLine\n  //y+= _yDatum;\n\n  bool steep = abs(y1 - y0) > abs(x1 - x0);\n  if (steep) {\n    transpose(x0, y0);\n    transpose(x1, y1);\n  }\n\n  if (x0 > x1) {\n    transpose(x0, x1);\n    transpose(y0, y1);\n  }\n\n  int32_t dx = x1 - x0, dy = abs(y1 - y0);;\n\n  int32_t err = dx >> 1, ystep = -1, xs = x0, dlen = 0;\n\n  if (y0 < y1) ystep = 1;\n\n  // Split into steep and not steep for FastH/V separation\n  if (steep) {\n    for (; x0 <= x1; x0++) {\n      dlen++;\n      err -= dy;\n      if (err < 0) {\n        if (dlen == 1) drawPixel(y0, xs, color);\n        else drawFastVLine(y0, xs, dlen, color);\n        dlen = 0;\n        y0 += ystep; xs = x0 + 1;\n        err += dx;\n      }\n    }\n    if (dlen) drawFastVLine(y0, xs, dlen, color);\n  }\n  else\n  {\n    for (; x0 <= x1; x0++) {\n      dlen++;\n      err -= dy;\n      if (err < 0) {\n        if (dlen == 1) drawPixel(xs, y0, color);\n        else drawFastHLine(xs, y0, dlen, color);\n        dlen = 0;\n        y0 += ystep; xs = x0 + 1;\n        err += dx;\n      }\n    }\n    if (dlen) drawFastHLine(xs, y0, dlen, color);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Description:  Constants for anti-aliased line drawing on TFT and in Sprites\n***************************************************************************************/\nconstexpr float PixelAlphaGain   = 255.0;\nconstexpr float LoAlphaTheshold  = 1.0/32.0;\nconstexpr float HiAlphaTheshold  = 1.0 - LoAlphaTheshold;\nconstexpr float deg2rad      = 3.14159265359/180.0;\n\n/***************************************************************************************\n** Function name:           drawPixel (alpha blended)\n** Description:             Draw a pixel blended with the screen or bg pixel colour\n***************************************************************************************/\nuint16_t TFT_eSPI::drawPixel(int32_t x, int32_t y, uint32_t color, uint8_t alpha, uint32_t bg_color)\n{\n  if (bg_color == 0x00FFFFFF) bg_color = readPixel(x, y);\n  color = fastBlend(alpha, color, bg_color);\n  drawPixel(x, y, color);\n  return color;\n}\n\n\n/***************************************************************************************\n** Function name:           drawSmoothArc\n** Description:             Draw a smooth arc clockwise from 6 o'clock\n***************************************************************************************/\nvoid TFT_eSPI::drawSmoothArc(int32_t x, int32_t y, int32_t r, int32_t ir, uint32_t startAngle, uint32_t endAngle, uint32_t fg_color, uint32_t bg_color, bool roundEnds)\n// Centre at x,y\n// r = arc outer radius, ir = arc inner radius. Inclusive so arc thickness = r - ir + 1\n// Angles in range 0-360\n// Arc foreground colour anti-aliased with background colour at edges\n// anti-aliased roundEnd is optional, default is anti-aliased straight end\n// Note: rounded ends extend the arc angle so can overlap, user sketch to manage this.\n{\n  inTransaction = true;\n\n  if (endAngle != startAngle && (startAngle != 0 || endAngle != 360))\n  {\n    float sx = -sinf(startAngle * deg2rad);\n    float sy = +cosf(startAngle * deg2rad);\n    float ex = -sinf(  endAngle * deg2rad);\n    float ey = +cosf(  endAngle * deg2rad);\n\n    if (roundEnds)\n    { // Round ends\n      sx = sx * (r + ir)/2.0 + x;\n      sy = sy * (r + ir)/2.0 + y;\n      drawSpot(sx, sy, (r - ir)/2.0, fg_color, bg_color);\n\n      ex = ex * (r + ir)/2.0 + x;\n      ey = ey * (r + ir)/2.0 + y;\n      drawSpot(ex, ey, (r - ir)/2.0, fg_color, bg_color);\n    }\n    else\n    { // Square ends\n      float asx = sx * ir + x;\n      float asy = sy * ir + y;\n      float aex = sx *  r + x;\n      float aey = sy *  r + y;\n      drawWedgeLine(asx, asy, aex, aey, 0.3, 0.3, fg_color, bg_color);\n\n      asx = ex * ir + x;\n      asy = ey * ir + y;\n      aex = ex *  r + x;\n      aey = ey *  r + y;\n      drawWedgeLine(asx, asy, aex, aey, 0.3, 0.3, fg_color, bg_color);\n    }\n\n    // Draw arc\n    drawArc(x, y, r, ir, startAngle, endAngle, fg_color, bg_color);\n\n  }\n  else // Draw full 360\n  {\n    drawArc(x, y, r, ir, 0, 360, fg_color, bg_color);\n  }\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           sqrt_fraction (private function)\n** Description:             Smooth graphics support function for alpha derivation\n***************************************************************************************/\n// Compute the fixed point square root of an integer and\n// return the 8 MS bits of fractional part.\n// Quicker than sqrt() for processors that do not have an FPU (e.g. RP2040)\ninline uint8_t TFT_eSPI::sqrt_fraction(uint32_t num) {\n  if (num > (0x40000000)) return 0;\n  uint32_t bsh = 0x00004000;\n  uint32_t fpr = 0;\n  uint32_t osh = 0;\n\n  // Auto adjust from U8:8 up to U15:16\n  while (num>bsh) {bsh <<= 2; osh++;}\n\n  do {\n    uint32_t bod = bsh + fpr;\n    if(num >= bod)\n    {\n      num -= bod;\n      fpr = bsh + bod;\n    }\n    num <<= 1;\n  } while(bsh >>= 1);\n\n  return fpr>>osh;\n}\n\n/***************************************************************************************\n** Function name:           drawArc\n** Description:             Draw an arc clockwise from 6 o'clock position\n***************************************************************************************/\n// Centre at x,y\n// r = arc outer radius, ir = arc inner radius. Inclusive, so arc thickness = r-ir+1\n// Angles MUST be in range 0-360\n// Arc foreground fg_color anti-aliased with background colour along sides\n// smooth is optional, default is true, smooth=false means no antialiasing\n// Note: Arc ends are not anti-aliased (use drawSmoothArc instead for that)\nvoid TFT_eSPI::drawArc(int32_t x, int32_t y, int32_t r, int32_t ir,\n                       uint32_t startAngle, uint32_t endAngle,\n                       uint32_t fg_color, uint32_t bg_color,\n                       bool smooth)\n{\n  if (endAngle   > 360)   endAngle = 360;\n  if (startAngle > 360) startAngle = 360;\n  if (_vpOoB || startAngle == endAngle) return;\n  if (r < ir) transpose(r, ir);  // Required that r > ir\n  if (r <= 0 || ir < 0) return;  // Invalid r, ir can be zero (circle sector)\n\n  if (endAngle < startAngle) {\n    // Arc sweeps through 6 o'clock so draw in two parts\n    if (startAngle < 360) drawArc(x, y, r, ir, startAngle, 360, fg_color, bg_color, smooth);\n    if (endAngle == 0) return;\n    startAngle = 0;\n  }\n  inTransaction = true;\n\n  int32_t xs = 0;        // x start position for quadrant scan\n  uint8_t alpha = 0;     // alpha value for blending pixels\n\n  uint32_t r2 = r * r;   // Outer arc radius^2\n  if (smooth) r++;       // Outer AA zone radius\n  uint32_t r1 = r * r;   // Outer AA radius^2\n  int16_t w  = r - ir;   // Width of arc (r - ir + 1)\n  uint32_t r3 = ir * ir; // Inner arc radius^2\n  if (smooth) ir--;      // Inner AA zone radius\n  uint32_t r4 = ir * ir; // Inner AA radius^2\n\n  //     1 | 2\n  //    ---¦---    Arc quadrant index\n  //     0 | 3\n  // Fixed point U16.16 slope table for arc start/end in each quadrant\n  uint32_t startSlope[4] = {0, 0, 0xFFFFFFFF, 0};\n  uint32_t   endSlope[4] = {0, 0xFFFFFFFF, 0, 0};\n\n  // Ensure maximum U16.16 slope of arc ends is ~ 0x8000 0000\n  constexpr float minDivisor = 1.0f/0x8000;\n\n  // Fill in start slope table and empty quadrants\n  float fabscos = fabsf(cosf(startAngle * deg2rad));\n  float fabssin = fabsf(sinf(startAngle * deg2rad));\n\n  // U16.16 slope of arc start\n  uint32_t slope = (fabscos/(fabssin + minDivisor)) * (float)(1UL<<16);\n\n  // Update slope table, add slope for arc start\n  if (startAngle <= 90) {\n    startSlope[0] =  slope;\n  }\n  else if (startAngle <= 180) {\n    startSlope[1] =  slope;\n  }\n  else if (startAngle <= 270) {\n    startSlope[1] = 0xFFFFFFFF;\n    startSlope[2] = slope;\n  }\n  else {\n    startSlope[1] = 0xFFFFFFFF;\n    startSlope[2] =  0;\n    startSlope[3] = slope;\n  }\n\n  // Fill in end slope table and empty quadrants\n  fabscos  = fabsf(cosf(endAngle * deg2rad));\n  fabssin  = fabsf(sinf(endAngle * deg2rad));\n\n  // U16.16 slope of arc end\n  slope   = (uint32_t)((fabscos/(fabssin + minDivisor)) * (float)(1UL<<16));\n\n  // Work out which quadrants will need to be drawn and add slope for arc end\n  if (endAngle <= 90) {\n    endSlope[0] = slope;\n    endSlope[1] =  0;\n    startSlope[2] =  0;\n  }\n  else if (endAngle <= 180) {\n    endSlope[1] = slope;\n    startSlope[2] =  0;\n  }\n  else if (endAngle <= 270) {\n    endSlope[2] =  slope;\n  }\n  else {\n    endSlope[3] =  slope;\n  }\n\n  // Scan quadrant\n  for (int32_t cy = r - 1; cy > 0; cy--)\n  {\n    uint32_t len[4] = { 0,  0,  0,  0}; // Pixel run length\n    int32_t  xst[4] = {-1, -1, -1, -1}; // Pixel run x start\n    uint32_t dy2 = (r - cy) * (r - cy);\n\n    // Find and track arc zone start point\n    while ((r - xs) * (r - xs) + dy2 >= r1) xs++;\n\n    for (int32_t cx = xs; cx < r; cx++)\n    {\n      // Calculate radius^2\n      uint32_t hyp = (r - cx) * (r - cx) + dy2;\n\n      // If in outer zone calculate alpha\n      if (hyp > r2) {\n        alpha = ~sqrt_fraction(hyp); // Outer AA zone\n      }\n      // If within arc fill zone, get line start and lengths for each quadrant\n      else if (hyp >= r3) {\n        // Calculate U16.16 slope\n        slope = ((r - cy) << 16)/(r - cx);\n        if (slope <= startSlope[0] && slope >= endSlope[0]) { // slope hi -> lo\n          xst[0] = cx; // Bottom left line end\n          len[0]++;\n        }\n        if (slope >= startSlope[1] && slope <= endSlope[1]) { // slope lo -> hi\n          xst[1] = cx; // Top left line end\n          len[1]++;\n        }\n        if (slope <= startSlope[2] && slope >= endSlope[2]) { // slope hi -> lo\n          xst[2] = cx; // Bottom right line start\n          len[2]++;\n        }\n        if (slope <= endSlope[3] && slope >= startSlope[3]) { // slope lo -> hi\n          xst[3] = cx; // Top right line start\n          len[3]++;\n        }\n        continue; // Next x\n      }\n      else {\n        if (hyp <= r4) break;  // Skip inner pixels\n        alpha = sqrt_fraction(hyp); // Inner AA zone\n      }\n\n      if (alpha < 16) continue;  // Skip low alpha pixels\n\n      // If background is read it must be done in each quadrant\n      uint16_t pcol = fastBlend(alpha, fg_color, bg_color);\n      // Check if an AA pixels need to be drawn\n      slope = ((r - cy)<<16)/(r - cx);\n      if (slope <= startSlope[0] && slope >= endSlope[0]) // BL\n        drawPixel(x + cx - r, y - cy + r, pcol);\n      if (slope >= startSlope[1] && slope <= endSlope[1]) // TL\n        drawPixel(x + cx - r, y + cy - r, pcol);\n      if (slope <= startSlope[2] && slope >= endSlope[2]) // TR\n        drawPixel(x - cx + r, y + cy - r, pcol);\n      if (slope <= endSlope[3] && slope >= startSlope[3]) // BR\n        drawPixel(x - cx + r, y - cy + r, pcol);\n    }\n    // Add line in inner zone\n    if (len[0]) drawFastHLine(x + xst[0] - len[0] + 1 - r, y - cy + r, len[0], fg_color); // BL\n    if (len[1]) drawFastHLine(x + xst[1] - len[1] + 1 - r, y + cy - r, len[1], fg_color); // TL\n    if (len[2]) drawFastHLine(x - xst[2] + r, y + cy - r, len[2], fg_color); // TR\n    if (len[3]) drawFastHLine(x - xst[3] + r, y - cy + r, len[3], fg_color); // BR\n  }\n\n  // Fill in centre lines\n  if (startAngle ==   0 || endAngle == 360) drawFastVLine(x, y + r - w, w, fg_color); // Bottom\n  if (startAngle <=  90 && endAngle >=  90) drawFastHLine(x - r + 1, y, w, fg_color); // Left\n  if (startAngle <= 180 && endAngle >= 180) drawFastVLine(x, y - r + 1, w, fg_color); // Top\n  if (startAngle <= 270 && endAngle >= 270) drawFastHLine(x + r - w, y, w, fg_color); // Right\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           drawSmoothCircle\n** Description:             Draw a smooth circle\n***************************************************************************************/\n// To have effective anti-aliasing the circle will be 3 pixels thick\nvoid TFT_eSPI::drawSmoothCircle(int32_t x, int32_t y, int32_t r, uint32_t fg_color, uint32_t bg_color)\n{\n  drawSmoothRoundRect(x-r, y-r, r, r-1, 0, 0, fg_color, bg_color);\n}\n\n/***************************************************************************************\n** Function name:           fillSmoothCircle\n** Description:             Draw a filled anti-aliased circle\n***************************************************************************************/\nvoid TFT_eSPI::fillSmoothCircle(int32_t x, int32_t y, int32_t r, uint32_t color, uint32_t bg_color)\n{\n  if (r <= 0) return;\n\n  inTransaction = true;\n\n  drawFastHLine(x - r, y, 2 * r + 1, color);\n  int32_t xs = 1;\n  int32_t cx = 0;\n\n  int32_t r1 = r * r;\n  r++;\n  int32_t r2 = r * r;\n  \n  for (int32_t cy = r - 1; cy > 0; cy--)\n  {\n    int32_t dy2 = (r - cy) * (r - cy);\n    for (cx = xs; cx < r; cx++)\n    {\n      int32_t hyp2 = (r - cx) * (r - cx) + dy2;\n      if (hyp2 <= r1) break;\n      if (hyp2 >= r2) continue;\n\n      uint8_t alpha = ~sqrt_fraction(hyp2);\n      if (alpha > 246) break;\n      xs = cx;\n      if (alpha < 9) continue;\n\n      if (bg_color == 0x00FFFFFF) {\n        drawPixel(x + cx - r, y + cy - r, color, alpha, bg_color);\n        drawPixel(x - cx + r, y + cy - r, color, alpha, bg_color);\n        drawPixel(x - cx + r, y - cy + r, color, alpha, bg_color);\n        drawPixel(x + cx - r, y - cy + r, color, alpha, bg_color);\n      }\n      else {\n        uint16_t pcol = drawPixel(x + cx - r, y + cy - r, color, alpha, bg_color);\n        drawPixel(x - cx + r, y + cy - r, pcol);\n        drawPixel(x - cx + r, y - cy + r, pcol);\n        drawPixel(x + cx - r, y - cy + r, pcol);\n      }\n    }\n    drawFastHLine(x + cx - r, y + cy - r, 2 * (r - cx) + 1, color);\n    drawFastHLine(x + cx - r, y - cy + r, 2 * (r - cx) + 1, color);\n  }\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           drawSmoothRoundRect\n** Description:             Draw a rounded rectangle\n***************************************************************************************/\n// x,y is top left corner of bounding box for a complete rounded rectangle\n// r = arc outer corner radius, ir = arc inner radius. Arc thickness = r-ir+1\n// w and h are width and height of the bounding rectangle\n// If w and h are < radius (e.g. 0,0) a circle will be drawn with centre at x+r,y+r\n// Arc foreground fg_color anti-aliased with background colour at edges\n// A subset of corners can be drawn by specifying a quadrants mask. A bit set in the\n// mask means draw that quadrant (all are drawn if parameter missing):\n//   0x1 | 0x2\n//    ---¦---    Arc quadrant mask select bits (as in drawCircleHelper fn)\n//   0x8 | 0x4\nvoid TFT_eSPI::drawSmoothRoundRect(int32_t x, int32_t y, int32_t r, int32_t ir, int32_t w, int32_t h, uint32_t fg_color, uint32_t bg_color, uint8_t quadrants)\n{\n  if (_vpOoB) return;\n  if (r < ir) transpose(r, ir); // Required that r > ir\n  if (r <= 0 || ir < 0) return; // Invalid\n\n  w -= 2*r;\n  h -= 2*r;\n\n  if (w < 0) w = 0;\n  if (h < 0) h = 0;\n\n  inTransaction = true;\n\n  x += r;\n  y += r;\n\n  uint16_t t = r - ir + 1;\n  int32_t xs = 0;\n  int32_t cx = 0;\n\n  int32_t r2 = r * r;   // Outer arc radius^2\n  r++;\n  int32_t r1 = r * r;   // Outer AA zone radius^2\n\n  int32_t r3 = ir * ir; // Inner arc radius^2\n  ir--;\n  int32_t r4 = ir * ir; // Inner AA zone radius^2\n\n  uint8_t alpha = 0;\n\n  // Scan top left quadrant x y r ir fg_color  bg_color\n  for (int32_t cy = r - 1; cy > 0; cy--)\n  {\n    int32_t len = 0;  // Pixel run length\n    int32_t lxst = 0; // Left side run x start\n    int32_t rxst = 0; // Right side run x start\n    int32_t dy2 = (r - cy) * (r - cy);\n\n    // Find and track arc zone start point\n    while ((r - xs) * (r - xs) + dy2 >= r1) xs++;\n\n    for (cx = xs; cx < r; cx++)\n    {\n      // Calculate radius^2\n      int32_t hyp = (r - cx) * (r - cx) + dy2;\n\n      // If in outer zone calculate alpha\n      if (hyp > r2) {\n        alpha = ~sqrt_fraction(hyp); // Outer AA zone\n      }\n      // If within arc fill zone, get line lengths for each quadrant\n      else if (hyp >= r3) {\n        rxst = cx; // Right side start\n        len++;     // Line segment length\n        continue;  // Next x\n      }\n      else {\n        if (hyp <= r4) break;  // Skip inner pixels\n        alpha = sqrt_fraction(hyp); // Inner AA zone\n      }\n\n      if (alpha < 16) continue;  // Skip low alpha pixels\n\n      // If background is read it must be done in each quadrant - TODO\n      uint16_t pcol = fastBlend(alpha, fg_color, bg_color);\n      if (quadrants & 0x8) drawPixel(x + cx - r, y - cy + r + h, pcol);     // BL\n      if (quadrants & 0x1) drawPixel(x + cx - r, y + cy - r, pcol);         // TL\n      if (quadrants & 0x2) drawPixel(x - cx + r + w, y + cy - r, pcol);     // TR\n      if (quadrants & 0x4) drawPixel(x - cx + r + w, y - cy + r + h, pcol); // BR\n    }\n    // Fill arc inner zone in each quadrant\n    lxst = rxst - len + 1; // Calculate line segment start for left side\n    if (quadrants & 0x8) drawFastHLine(x + lxst - r, y - cy + r + h, len, fg_color);     // BL\n    if (quadrants & 0x1) drawFastHLine(x + lxst - r, y + cy - r, len, fg_color);         // TL\n    if (quadrants & 0x2) drawFastHLine(x - rxst + r + w, y + cy - r, len, fg_color);     // TR\n    if (quadrants & 0x4) drawFastHLine(x - rxst + r + w, y - cy + r + h, len, fg_color); // BR\n  }\n\n  // Draw sides\n  if ((quadrants & 0xC) == 0xC) fillRect(x, y + r - t + h, w + 1, t, fg_color); // Bottom\n  if ((quadrants & 0x9) == 0x9) fillRect(x - r + 1, y, t, h + 1, fg_color);     // Left\n  if ((quadrants & 0x3) == 0x3) fillRect(x, y - r + 1, w + 1, t, fg_color);     // Top\n  if ((quadrants & 0x6) == 0x6) fillRect(x + r - t + w, y, t, h + 1, fg_color); // Right\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           fillSmoothRoundRect\n** Description:             Draw a filled anti-aliased rounded corner rectangle\n***************************************************************************************/\nvoid TFT_eSPI::fillSmoothRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t r, uint32_t color, uint32_t bg_color)\n{\n  inTransaction = true;\n\n  int32_t xs = 0;\n  int32_t cx = 0;\n\n  // Limit radius to half width or height\n  if (r < 0)   r = 0;\n  if (r > w/2) r = w/2;\n  if (r > h/2) r = h/2;\n\n  y += r;\n  h -= 2*r;\n  fillRect(x, y, w, h, color);\n\n  h--;\n  x += r;\n  w -= 2*r+1;\n\n  int32_t r1 = r * r;\n  r++;\n  int32_t r2 = r * r;\n\n  for (int32_t cy = r - 1; cy > 0; cy--)\n  {\n    int32_t dy2 = (r - cy) * (r - cy);\n    for (cx = xs; cx < r; cx++)\n    {\n      int32_t hyp2 = (r - cx) * (r - cx) + dy2;\n      if (hyp2 <= r1) break;\n      if (hyp2 >= r2) continue;\n\n      uint8_t alpha = ~sqrt_fraction(hyp2);\n      if (alpha > 246) break;\n      xs = cx;\n      if (alpha < 9) continue;\n\n      drawPixel(x + cx - r, y + cy - r, color, alpha, bg_color);\n      drawPixel(x - cx + r + w, y + cy - r, color, alpha, bg_color);\n      drawPixel(x - cx + r + w, y - cy + r + h, color, alpha, bg_color);\n      drawPixel(x + cx - r, y - cy + r + h, color, alpha, bg_color);\n    }\n    drawFastHLine(x + cx - r, y + cy - r, 2 * (r - cx) + 1 + w, color);\n    drawFastHLine(x + cx - r, y - cy + r + h, 2 * (r - cx) + 1 + w, color);\n  }\n  inTransaction = lockTransaction;\n  end_tft_write();\n}\n\n/***************************************************************************************\n** Function name:           drawSpot - maths intensive, so for small filled circles\n** Description:             Draw an anti-aliased filled circle at ax,ay with radius r\n***************************************************************************************/\n// Coordinates are floating point to achieve sub-pixel positioning\nvoid TFT_eSPI::drawSpot(float ax, float ay, float r, uint32_t fg_color, uint32_t bg_color)\n{\n  // Filled circle can be created by the wide line function with zero line length\n  drawWedgeLine( ax, ay, ax, ay, r, r, fg_color, bg_color);\n}\n\n/***************************************************************************************\n** Function name:           drawWideLine - background colour specified or pixel read\n** Description:             draw an anti-aliased line with rounded ends, width wd\n***************************************************************************************/\nvoid TFT_eSPI::drawWideLine(float ax, float ay, float bx, float by, float wd, uint32_t fg_color, uint32_t bg_color)\n{\n  drawWedgeLine( ax, ay, bx, by, wd/2.0, wd/2.0, fg_color, bg_color);\n}\n\n/***************************************************************************************\n** Function name:           drawWedgeLine - background colour specified or pixel read\n** Description:             draw an anti-aliased line with different width radiused ends\n***************************************************************************************/\nvoid TFT_eSPI::drawWedgeLine(float ax, float ay, float bx, float by, float ar, float br, uint32_t fg_color, uint32_t bg_color)\n{\n  if ( (ar < 0.0) || (br < 0.0) )return;\n  if ( (fabsf(ax - bx) < 0.01f) && (fabsf(ay - by) < 0.01f) ) bx += 0.01f;  // Avoid divide by zero\n\n  // Find line bounding box\n  int32_t x0 = (int32_t)floorf(fminf(ax-ar, bx-br));\n  int32_t x1 = (int32_t) ceilf(fmaxf(ax+ar, bx+br));\n  int32_t y0 = (int32_t)floorf(fminf(ay-ar, by-br));\n  int32_t y1 = (int32_t) ceilf(fmaxf(ay+ar, by+br));\n\n  if (!clipWindow(&x0, &y0, &x1, &y1)) return;\n\n  // Establish x start and y start\n  int32_t ys = ay;\n  if ((ax-ar)>(bx-br)) ys = by;\n\n  float rdt = ar - br; // Radius delta\n  float alpha = 1.0f;\n  ar += 0.5;\n\n  uint16_t bg = bg_color;\n  float xpax, ypay, bax = bx - ax, bay = by - ay;\n\n  begin_nin_write();\n  inTransaction = true;\n\n  int32_t xs = x0;\n  // Scan bounding box from ys down, calculate pixel intensity from distance to line\n  for (int32_t yp = ys; yp <= y1; yp++) {\n    bool swin = true;  // Flag to start new window area\n    bool endX = false; // Flag to skip pixels\n    ypay = yp - ay;\n    for (int32_t xp = xs; xp <= x1; xp++) {\n      if (endX) if (alpha <= LoAlphaTheshold) break;  // Skip right side\n      xpax = xp - ax;\n      alpha = ar - wedgeLineDistance(xpax, ypay, bax, bay, rdt);\n      if (alpha <= LoAlphaTheshold ) continue;\n      // Track edge to minimise calculations\n      if (!endX) { endX = true; xs = xp; }\n      if (alpha > HiAlphaTheshold) {\n        #ifdef GC9A01_DRIVER\n          drawPixel(xp, yp, fg_color);\n        #else\n          if (swin) { setWindow(xp, yp, x1, yp); swin = false; }\n          pushColor(fg_color);\n        #endif\n        continue;\n      }\n      //Blend color with background and plot\n      if (bg_color == 0x00FFFFFF) {\n        bg = readPixel(xp, yp); swin = true;\n      }\n      #ifdef GC9A01_DRIVER\n        uint16_t pcol = fastBlend((uint8_t)(alpha * PixelAlphaGain), fg_color, bg);\n        drawPixel(xp, yp, pcol);\n        swin = swin;\n      #else\n        if (swin) { setWindow(xp, yp, x1, yp); swin = false; }\n        pushColor(fastBlend((uint8_t)(alpha * PixelAlphaGain), fg_color, bg));\n      #endif\n    }\n  }\n\n  // Reset x start to left side of box\n  xs = x0;\n  // Scan bounding box from ys-1 up, calculate pixel intensity from distance to line\n  for (int32_t yp = ys-1; yp >= y0; yp--) {\n    bool swin = true;  // Flag to start new window area\n    bool endX = false; // Flag to skip pixels\n    ypay = yp - ay;\n    for (int32_t xp = xs; xp <= x1; xp++) {\n      if (endX) if (alpha <= LoAlphaTheshold) break;  // Skip right side of drawn line\n      xpax = xp - ax;\n      alpha = ar - wedgeLineDistance(xpax, ypay, bax, bay, rdt);\n      if (alpha <= LoAlphaTheshold ) continue;\n      // Track line boundary\n      if (!endX) { endX = true; xs = xp; }\n      if (alpha > HiAlphaTheshold) {\n        #ifdef GC9A01_DRIVER\n          drawPixel(xp, yp, fg_color);\n        #else\n          if (swin) { setWindow(xp, yp, x1, yp); swin = false; }\n          pushColor(fg_color);\n        #endif\n        continue;\n      }\n      //Blend colour with background and plot\n      if (bg_color == 0x00FFFFFF) {\n        bg = readPixel(xp, yp); swin = true;\n      }\n      #ifdef GC9A01_DRIVER\n        uint16_t pcol = fastBlend((uint8_t)(alpha * PixelAlphaGain), fg_color, bg);\n        drawPixel(xp, yp, pcol);\n        swin = swin;\n      #else\n        if (swin) { setWindow(xp, yp, x1, yp); swin = false; }\n        pushColor(fastBlend((uint8_t)(alpha * PixelAlphaGain), fg_color, bg));\n      #endif\n    }\n  }\n\n  inTransaction = lockTransaction;\n  end_nin_write();\n}\n\n\n/***************************************************************************************\n** Function name:           lineDistance - private helper function for drawWedgeLine\n** Description:             returns distance of px,py to closest part of a to b wedge\n***************************************************************************************/\ninline float TFT_eSPI::wedgeLineDistance(float xpax, float ypay, float bax, float bay, float dr)\n{\n  float h = fmaxf(fminf((xpax * bax + ypay * bay) / (bax * bax + bay * bay), 1.0f), 0.0f);\n  float dx = xpax - bax * h, dy = ypay - bay * h;\n  return sqrtf(dx * dx + dy * dy) + h * dr;\n}\n\n\n/***************************************************************************************\n** Function name:           drawFastVLine\n** Description:             draw a vertical line\n***************************************************************************************/\nvoid TFT_eSPI::drawFastVLine(int32_t x, int32_t y, int32_t h, uint32_t color)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Clipping\n  if ((x < _vpX) || (x >= _vpW) || (y >= _vpH)) return;\n\n  if (y < _vpY) { h += y - _vpY; y = _vpY; }\n\n  if ((y + h) > _vpH) h = _vpH - y;\n\n  if (h < 1) return;\n\n  begin_tft_write();\n\n  setWindow(x, y, x, y + h - 1);\n\n  pushBlock(color, h);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           drawFastHLine\n** Description:             draw a horizontal line\n***************************************************************************************/\nvoid TFT_eSPI::drawFastHLine(int32_t x, int32_t y, int32_t w, uint32_t color)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Clipping\n  if ((y < _vpY) || (x >= _vpW) || (y >= _vpH)) return;\n\n  if (x < _vpX) { w += x - _vpX; x = _vpX; }\n\n  if ((x + w) > _vpW) w = _vpW - x;\n\n  if (w < 1) return;\n\n  begin_tft_write();\n\n  setWindow(x, y, x + w - 1, y);\n\n  pushBlock(color, w);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           fillRect\n** Description:             draw a filled rectangle\n***************************************************************************************/\nvoid TFT_eSPI::fillRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Clipping\n  if ((x >= _vpW) || (y >= _vpH)) return;\n\n  if (x < _vpX) { w += x - _vpX; x = _vpX; }\n  if (y < _vpY) { h += y - _vpY; y = _vpY; }\n\n  if ((x + w) > _vpW) w = _vpW - x;\n  if ((y + h) > _vpH) h = _vpH - y;\n\n  if ((w < 1) || (h < 1)) return;\n\n  //Serial.print(\" _xDatum=\");Serial.print( _xDatum);Serial.print(\", _yDatum=\");Serial.print( _yDatum);\n  //Serial.print(\", _xWidth=\");Serial.print(_xWidth);Serial.print(\", _yHeight=\");Serial.println(_yHeight);\n\n  //Serial.print(\" _vpX=\");Serial.print( _vpX);Serial.print(\", _vpY=\");Serial.print( _vpY);\n  //Serial.print(\", _vpW=\");Serial.print(_vpW);Serial.print(\", _vpH=\");Serial.println(_vpH);\n\n  //Serial.print(\" x=\");Serial.print( y);Serial.print(\", y=\");Serial.print( y);\n  //Serial.print(\", w=\");Serial.print(w);Serial.print(\", h=\");Serial.println(h);\n\n  begin_tft_write();\n\n  setWindow(x, y, x + w - 1, y + h - 1);\n\n  pushBlock(color, w * h);\n\n  end_tft_write();\n}\n\n\n/***************************************************************************************\n** Function name:           fillRectVGradient\n** Description:             draw a filled rectangle with a vertical colour gradient\n***************************************************************************************/\nvoid TFT_eSPI::fillRectVGradient(int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color1, uint32_t color2)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Clipping\n  if ((x >= _vpW) || (y >= _vpH)) return;\n\n  if (x < _vpX) { w += x - _vpX; x = _vpX; }\n  if (y < _vpY) { h += y - _vpY; y = _vpY; }\n\n  if ((x + w) > _vpW) w = _vpW - x;\n  if ((y + h) > _vpH) h = _vpH - y;\n\n  if ((w < 1) || (h < 1)) return;\n\n  begin_nin_write();\n\n  float delta = -255.0/h;\n  float alpha = 255.0;\n  uint32_t color = color1;\n\n  while (h--) {\n    drawFastHLine(x, y++, w, color);\n    alpha += delta;\n    color = fastBlend((uint8_t)alpha, color1, color2);\n  }\n\n  end_nin_write();\n}\n\n\n/***************************************************************************************\n** Function name:           fillRectHGradient\n** Description:             draw a filled rectangle with a horizontal colour gradient\n***************************************************************************************/\nvoid TFT_eSPI::fillRectHGradient(int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color1, uint32_t color2)\n{\n  if (_vpOoB) return;\n\n  x+= _xDatum;\n  y+= _yDatum;\n\n  // Clipping\n  if ((x >= _vpW) || (y >= _vpH)) return;\n\n  if (x < _vpX) { w += x - _vpX; x = _vpX; }\n  if (y < _vpY) { h += y - _vpY; y = _vpY; }\n\n  if ((x + w) > _vpW) w = _vpW - x;\n  if ((y + h) > _vpH) h = _vpH - y;\n\n  if ((w < 1) || (h < 1)) return;\n\n  begin_nin_write();\n\n  float delta = -255.0/w;\n  float alpha = 255.0;\n  uint32_t color = color1;\n\n  while (w--) {\n    drawFastVLine(x++, y, h, color);\n    alpha += delta;\n    color = fastBlend((uint8_t)alpha, color1, color2);\n  }\n\n  end_nin_write();\n}\n\n\n/***************************************************************************************\n** Function name:           color565\n** Description:             convert three 8-bit RGB levels to a 16-bit colour value\n***************************************************************************************/\nuint16_t TFT_eSPI::color565(uint8_t r, uint8_t g, uint8_t b)\n{\n  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);\n}\n\n\n/***************************************************************************************\n** Function name:           color16to8\n** Description:             convert 16-bit colour to an 8-bit 332 RGB colour value\n***************************************************************************************/\nuint8_t TFT_eSPI::color16to8(uint16_t c)\n{\n  return ((c & 0xE000)>>8) | ((c & 0x0700)>>6) | ((c & 0x0018)>>3);\n}\n\n\n/***************************************************************************************\n** Function name:           color8to16\n** Description:             convert 8-bit colour to a 16-bit 565 colour value\n***************************************************************************************/\nuint16_t TFT_eSPI::color8to16(uint8_t color)\n{\n  uint8_t  blue[] = {0, 11, 21, 31}; // blue 2 to 5-bit colour lookup table\n  uint16_t color16 = 0;\n\n  //        =====Green=====     ===============Red==============\n  color16  = (color & 0x1C)<<6 | (color & 0xC0)<<5 | (color & 0xE0)<<8;\n  //        =====Green=====    =======Blue======\n  color16 |= (color & 0x1C)<<3 | blue[color & 0x03];\n\n  return color16;\n}\n\n/***************************************************************************************\n** Function name:           color16to24\n** Description:             convert 16-bit colour to a 24-bit 888 colour value\n***************************************************************************************/\nuint32_t TFT_eSPI::color16to24(uint16_t color565)\n{\n  uint8_t r = (color565 >> 8) & 0xF8; r |= (r >> 5);\n  uint8_t g = (color565 >> 3) & 0xFC; g |= (g >> 6);\n  uint8_t b = (color565 << 3) & 0xF8; b |= (b >> 5);\n\n  return ((uint32_t)r << 16) | ((uint32_t)g << 8) | ((uint32_t)b << 0);\n}\n\n/***************************************************************************************\n** Function name:           color24to16\n** Description:             convert 24-bit colour to a 16-bit 565 colour value\n***************************************************************************************/\nuint32_t TFT_eSPI::color24to16(uint32_t color888)\n{\n  uint16_t r = (color888 >> 8) & 0xF800;\n  uint16_t g = (color888 >> 5) & 0x07E0;\n  uint16_t b = (color888 >> 3) & 0x001F;\n\n  return (r | g | b);\n}\n\n/***************************************************************************************\n** Function name:           invertDisplay\n** Description:             invert the display colours i = 1 invert, i = 0 normal\n***************************************************************************************/\nvoid TFT_eSPI::invertDisplay(bool i)\n{\n  begin_tft_write();\n  // Send the command twice as otherwise it does not always work!\n  writecommand(i ? TFT_INVON : TFT_INVOFF);\n  writecommand(i ? TFT_INVON : TFT_INVOFF);\n  end_tft_write();\n}\n\n\n/**************************************************************************\n** Function name:           setAttribute\n** Description:             Sets a control parameter of an attribute\n**************************************************************************/\nvoid TFT_eSPI::setAttribute(uint8_t attr_id, uint8_t param) {\n    switch (attr_id) {\n            break;\n        case CP437_SWITCH:\n            _cp437 = param;\n            break;\n        case UTF8_SWITCH:\n            _utf8  = param;\n            decoderState = 0;\n            break;\n        case PSRAM_ENABLE:\n#if defined (ESP32) && defined (CONFIG_SPIRAM_SUPPORT)\n            if (psramFound()) _psram_enable = param; // Enable the use of PSRAM (if available)\n            else\n#endif\n            _psram_enable = false;\n            break;\n        //case 4: // TBD future feature control\n        //    _tbd = param;\n        //    break;\n    }\n}\n\n\n/**************************************************************************\n** Function name:           getAttribute\n** Description:             Get value of an attribute (control parameter)\n**************************************************************************/\nuint8_t TFT_eSPI::getAttribute(uint8_t attr_id) {\n    switch (attr_id) {\n        case CP437_SWITCH: // ON/OFF control of full CP437 character set\n            return _cp437;\n        case UTF8_SWITCH: // ON/OFF control of UTF-8 decoding\n            return _utf8;\n        case PSRAM_ENABLE:\n            return _psram_enable;\n        //case 3: // TBD future feature control\n        //    return _tbd;\n        //    break;\n    }\n\n    return false;\n}\n\n/***************************************************************************************\n** Function name:           decodeUTF8\n** Description:             Serial UTF-8 decoder with fall-back to extended ASCII\n*************************************************************************************x*/\nuint16_t TFT_eSPI::decodeUTF8(uint8_t c)\n{\n  if (!_utf8) return c;\n\n  // 7-bit Unicode Code Point\n  if ((c & 0x80) == 0x00) {\n    decoderState = 0;\n    return c;\n  }\n\n  if (decoderState == 0) {\n    // 11-bit Unicode Code Point\n    if ((c & 0xE0) == 0xC0) {\n      decoderBuffer = ((c & 0x1F)<<6);\n      decoderState = 1;\n      return 0;\n    }\n    // 16-bit Unicode Code Point\n    if ((c & 0xF0) == 0xE0) {\n      decoderBuffer = ((c & 0x0F)<<12);\n      decoderState = 2;\n      return 0;\n    }\n    // 21-bit Unicode Code Point not supported so fall-back to extended ASCII\n    // if ((c & 0xF8) == 0xF0) return c;\n  }\n  else {\n    if (decoderState == 2) {\n      decoderBuffer |= ((c & 0x3F)<<6);\n      decoderState--;\n      return 0;\n    }\n    else {\n      decoderBuffer |= (c & 0x3F);\n      decoderState = 0;\n      return decoderBuffer;\n    }\n  }\n\n  decoderState = 0;\n\n  return c; // fall-back to extended ASCII\n}\n\n\n/***************************************************************************************\n** Function name:           decodeUTF8\n** Description:             Line buffer UTF-8 decoder with fall-back to extended ASCII\n*************************************************************************************x*/\nuint16_t TFT_eSPI::decodeUTF8(uint8_t *buf, uint16_t *index, uint16_t remaining)\n{\n  uint16_t c = buf[(*index)++];\n  //Serial.print(\"Byte from string = 0x\"); Serial.println(c, HEX);\n\n  if (!_utf8) return c;\n\n  // 7-bit Unicode\n  if ((c & 0x80) == 0x00) return c;\n\n  // 11-bit Unicode\n  if (((c & 0xE0) == 0xC0) && (remaining > 1))\n    return ((c & 0x1F)<<6) | (buf[(*index)++]&0x3F);\n\n  // 16-bit Unicode\n  if (((c & 0xF0) == 0xE0) && (remaining > 2)) {\n    c = ((c & 0x0F)<<12) | ((buf[(*index)++]&0x3F)<<6);\n    return  c | ((buf[(*index)++]&0x3F));\n  }\n\n  // 21-bit Unicode not supported so fall-back to extended ASCII\n  // if (((c & 0xF8) == 0xF0) && (remaining > 3)) {\n  // c = ((c & 0x07) << 18) | ((buf[(*index)++] & 0x03F) << 12);\n  // c |= ((buf[(*index)++] & 0x3F) << 6);\n  // return c | ((buf[(*index)++] & 0x3F));\n\n  return c; // fall-back to extended ASCII\n}\n\n\n/***************************************************************************************\n** Function name:           alphaBlend\n** Description:             Blend 16bit foreground and background\n*************************************************************************************x*/\nuint16_t TFT_eSPI::alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc)\n{\n  // Split out and blend 5-bit red and blue channels\n  uint32_t rxb = bgc & 0xF81F;\n  rxb += ((fgc & 0xF81F) - rxb) * (alpha >> 2) >> 6;\n  // Split out and blend 6-bit green channel\n  uint32_t xgx = bgc & 0x07E0;\n  xgx += ((fgc & 0x07E0) - xgx) * alpha >> 8;\n  // Recombine channels\n  return (rxb & 0xF81F) | (xgx & 0x07E0);\n}\n\n/***************************************************************************************\n** Function name:           alphaBlend\n** Description:             Blend 16bit foreground and background with dither\n*************************************************************************************x*/\nuint16_t TFT_eSPI::alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc, uint8_t dither)\n{\n  if (dither) {\n    int16_t alphaDither = (int16_t)alpha - dither + random(2*dither+1); // +/-4 randomised\n    alpha = (uint8_t)alphaDither;\n    if (alphaDither <  0) alpha = 0;\n    if (alphaDither >255) alpha = 255;\n  }\n\n  return alphaBlend(alpha, fgc, bgc);\n}\n\n/***************************************************************************************\n** Function name:           alphaBlend\n** Description:             Blend 24bit foreground and background with optional dither\n*************************************************************************************x*/\nuint32_t TFT_eSPI::alphaBlend24(uint8_t alpha, uint32_t fgc, uint32_t bgc, uint8_t dither)\n{\n\n  if (dither) {\n    int16_t alphaDither = (int16_t)alpha - dither + random(2*dither+1); // +/-dither randomised\n    alpha = (uint8_t)alphaDither;\n    if (alphaDither <  0) alpha = 0;\n    if (alphaDither >255) alpha = 255;\n  }\n\n  uint32_t rxx = bgc & 0xFF0000;\n  rxx += ((fgc & 0xFF0000) - rxx) * alpha >> 8;\n  uint32_t xgx = bgc & 0x00FF00;\n  xgx += ((fgc & 0x00FF00) - xgx) * alpha >> 8;\n  uint32_t xxb = bgc & 0x0000FF;\n  xxb += ((fgc & 0x0000FF) - xxb) * alpha >> 8;\n  return (rxx & 0xFF0000) | (xgx & 0x00FF00) | (xxb & 0x0000FF);\n}\n\n/***************************************************************************************\n** Function name:           write\n** Description:             draw characters piped through serial stream\n***************************************************************************************/\n/* // Not all processors support buffered write\n#ifndef ARDUINO_ARCH_ESP8266 // Avoid ESP8266 board package bug\nsize_t TFT_eSPI::write(const uint8_t *buf, size_t len)\n{\n  inTransaction = true;\n\n  uint8_t *lbuf = (uint8_t *)buf;\n  while(*lbuf !=0 && len--) write(*lbuf++);\n\n  inTransaction = lockTransaction;\n  end_tft_write();\n  return 1;\n}\n#endif\n*/\n/***************************************************************************************\n** Function name:           write\n** Description:             draw characters piped through serial stream\n***************************************************************************************/\nsize_t TFT_eSPI::write(uint8_t utf8)\n{\n  if (_vpOoB) return 1;\n\n  uint16_t uniCode = decodeUTF8(utf8);\n\n  if (!uniCode) return 1;\n\n  if (utf8 == '\\r') return 1;\n\n#ifdef SMOOTH_FONT\n  if(fontLoaded) {\n    if (uniCode < 32 && utf8 != '\\n') return 1;\n\n    drawGlyph(uniCode);\n\n    return 1;\n  }\n#endif\n\n  if (uniCode == '\\n') uniCode+=22; // Make it a valid space character to stop errors\n\n  uint16_t cwidth = 0;\n  uint16_t cheight = 0;\n\n//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv DEBUG vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n  //Serial.print((uint8_t) uniCode); // Debug line sends all printed TFT text to serial port\n  //Serial.println(uniCode, HEX); // Debug line sends all printed TFT text to serial port\n  //delay(5);                     // Debug optional wait for serial port to flush through\n//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEBUG ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n#ifdef LOAD_GFXFF\n  if(!gfxFont) {\n#endif\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n#ifdef LOAD_FONT2\n  if (textfont == 2) {\n    if (uniCode < 32 || uniCode > 127) return 1;\n\n    cwidth = pgm_read_byte(widtbl_f16 + uniCode-32);\n    cheight = chr_hgt_f16;\n    // Font 2 is rendered in whole byte widths so we must allow for this\n    cwidth = (cwidth + 6) / 8;  // Width in whole bytes for font 2, should be + 7 but must allow for font width change\n    cwidth = cwidth * 8;        // Width converted back to pixels\n  }\n  #ifdef LOAD_RLE\n  else\n  #endif\n#endif\n\n#ifdef LOAD_RLE\n  {\n    if ((textfont>2) && (textfont<9)) {\n      if (uniCode < 32 || uniCode > 127) return 1;\n      // Uses the fontinfo struct array to avoid lots of 'if' or 'switch' statements\n      cwidth = pgm_read_byte( (uint8_t *)pgm_read_dword( &(fontdata[textfont].widthtbl ) ) + uniCode-32 );\n      cheight= pgm_read_byte( &fontdata[textfont].height );\n    }\n  }\n#endif\n\n#ifdef LOAD_GLCD\n  if (textfont==1) {\n      cwidth =  6;\n      cheight = 8;\n  }\n#else\n  if (textfont==1) return 1;\n#endif\n\n  cheight = cheight * textsize;\n\n  if (utf8 == '\\n') {\n    cursor_y += cheight;\n    cursor_x  = 0;\n  }\n  else {\n    if (textwrapX && (cursor_x + cwidth * textsize > width())) {\n      cursor_y += cheight;\n      cursor_x = 0;\n    }\n    if (textwrapY && (cursor_y >= (int32_t) height())) cursor_y = 0;\n    cursor_x += drawChar(uniCode, cursor_x, cursor_y, textfont);\n  }\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n#ifdef LOAD_GFXFF\n  } // Custom GFX font\n  else {\n    if(utf8 == '\\n') {\n      cursor_x  = 0;\n      cursor_y += (int16_t)textsize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n    } else {\n      if (uniCode > pgm_read_word(&gfxFont->last )) return 1;\n      if (uniCode < pgm_read_word(&gfxFont->first)) return 1;\n\n      uint16_t   c2    = uniCode - pgm_read_word(&gfxFont->first);\n      GFXglyph *glyph = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[c2]);\n      uint8_t   w     = pgm_read_byte(&glyph->width),\n                h     = pgm_read_byte(&glyph->height);\n      if((w > 0) && (h > 0)) { // Is there an associated bitmap?\n        int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset);\n        if(textwrapX && ((cursor_x + textsize * (xo + w)) > width())) {\n          // Drawing character would go off right edge; wrap to new line\n          cursor_x  = 0;\n          cursor_y += (int16_t)textsize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n        }\n        if (textwrapY && (cursor_y >= (int32_t) height())) cursor_y = 0;\n        drawChar(cursor_x, cursor_y, uniCode, textcolor, textbgcolor, textsize);\n      }\n      cursor_x += pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize;\n    }\n  }\n#endif // LOAD_GFXFF\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  return 1;\n}\n\n\n/***************************************************************************************\n** Function name:           drawChar\n** Description:             draw a Unicode glyph onto the screen\n***************************************************************************************/\n  // TODO: Rationalise with TFT_eSprite\n  // Any UTF-8 decoding must be done before calling drawChar()\nint16_t TFT_eSPI::drawChar(uint16_t uniCode, int32_t x, int32_t y)\n{\n  return drawChar(uniCode, x, y, textfont);\n}\n\n  // Any UTF-8 decoding must be done before calling drawChar()\nint16_t TFT_eSPI::drawChar(uint16_t uniCode, int32_t x, int32_t y, uint8_t font)\n{\n  if (_vpOoB || !uniCode) return 0;\n\n  if (font==1) {\n#ifdef LOAD_GLCD\n  #ifndef LOAD_GFXFF\n    drawChar(x, y, uniCode, textcolor, textbgcolor, textsize);\n    return 6 * textsize;\n  #endif\n#else\n  #ifndef LOAD_GFXFF\n    return 0;\n  #endif\n#endif\n\n#ifdef LOAD_GFXFF\n    drawChar(x, y, uniCode, textcolor, textbgcolor, textsize);\n    if(!gfxFont) { // 'Classic' built-in font\n    #ifdef LOAD_GLCD\n      return 6 * textsize;\n    #else\n      return 0;\n    #endif\n    }\n    else {\n      if((uniCode >= pgm_read_word(&gfxFont->first)) && (uniCode <= pgm_read_word(&gfxFont->last) )) {\n        uint16_t   c2    = uniCode - pgm_read_word(&gfxFont->first);\n        GFXglyph *glyph = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[c2]);\n        return pgm_read_byte(&glyph->xAdvance) * textsize;\n      }\n      else {\n        return 0;\n      }\n    }\n#endif\n  }\n\n  if ((font>1) && (font<9) && ((uniCode < 32) || (uniCode > 127))) return 0;\n\n  int32_t width  = 0;\n  int32_t height = 0;\n  uint32_t flash_address = 0;\n  uniCode -= 32;\n\n#ifdef LOAD_FONT2\n  if (font == 2) {\n    flash_address = pgm_read_dword(&chrtbl_f16[uniCode]);\n    width = pgm_read_byte(widtbl_f16 + uniCode);\n    height = chr_hgt_f16;\n  }\n  #ifdef LOAD_RLE\n  else\n  #endif\n#endif\n\n#ifdef LOAD_RLE\n  {\n    if ((font>2) && (font<9)) {\n      flash_address = pgm_read_dword( (const void*)(pgm_read_dword( &(fontdata[font].chartbl ) ) + uniCode*sizeof(void *)) );\n      width = pgm_read_byte( (uint8_t *)pgm_read_dword( &(fontdata[font].widthtbl ) ) + uniCode );\n      height= pgm_read_byte( &fontdata[font].height );\n    }\n  }\n#endif\n\n  int32_t xd = x + _xDatum;\n  int32_t yd = y + _yDatum;\n\n  if ((xd + width * textsize < _vpX || xd >= _vpW) && (yd + height * textsize < _vpY || yd >= _vpH)) return width * textsize ;\n\n  int32_t w = width;\n  int32_t pX      = 0;\n  int32_t pY      = y;\n  uint8_t line = 0;\n  bool clip = xd < _vpX || xd + width  * textsize >= _vpW || yd < _vpY || yd + height * textsize >= _vpH;\n\n#ifdef LOAD_FONT2 // chop out code if we do not need it\n  if (font == 2) {\n    w = w + 6; // Should be + 7 but we need to compensate for width increment\n    w = w / 8;\n\n    if (textcolor == textbgcolor || textsize != 1 || clip) {\n      //begin_tft_write();          // Sprite class can use this function, avoiding begin_tft_write()\n      inTransaction = true;\n\n      for (int32_t i = 0; i < height; i++) {\n        if (textcolor != textbgcolor) fillRect(x, pY, width * textsize, textsize, textbgcolor);\n\n        for (int32_t k = 0; k < w; k++) {\n          line = pgm_read_byte((uint8_t *)flash_address + w * i + k);\n          if (line) {\n            if (textsize == 1) {\n              pX = x + k * 8;\n              if (line & 0x80) drawPixel(pX, pY, textcolor);\n              if (line & 0x40) drawPixel(pX + 1, pY, textcolor);\n              if (line & 0x20) drawPixel(pX + 2, pY, textcolor);\n              if (line & 0x10) drawPixel(pX + 3, pY, textcolor);\n              if (line & 0x08) drawPixel(pX + 4, pY, textcolor);\n              if (line & 0x04) drawPixel(pX + 5, pY, textcolor);\n              if (line & 0x02) drawPixel(pX + 6, pY, textcolor);\n              if (line & 0x01) drawPixel(pX + 7, pY, textcolor);\n            }\n            else {\n              pX = x + k * 8 * textsize;\n              if (line & 0x80) fillRect(pX, pY, textsize, textsize, textcolor);\n              if (line & 0x40) fillRect(pX + textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x20) fillRect(pX + 2 * textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x10) fillRect(pX + 3 * textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x08) fillRect(pX + 4 * textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x04) fillRect(pX + 5 * textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x02) fillRect(pX + 6 * textsize, pY, textsize, textsize, textcolor);\n              if (line & 0x01) fillRect(pX + 7 * textsize, pY, textsize, textsize, textcolor);\n            }\n          }\n        }\n        pY += textsize;\n      }\n\n      inTransaction = lockTransaction;\n      end_tft_write();\n    }\n    else { // Faster drawing of characters and background using block write\n\n      begin_tft_write();\n\n      setWindow(xd, yd, xd + width - 1, yd + height - 1);\n\n      uint8_t mask;\n      for (int32_t i = 0; i < height; i++) {\n        pX = width;\n        for (int32_t k = 0; k < w; k++) {\n          line = pgm_read_byte((uint8_t *) (flash_address + w * i + k) );\n          mask = 0x80;\n          while (mask && pX) {\n            if (line & mask) {tft_Write_16(textcolor);}\n            else {tft_Write_16(textbgcolor);}\n            pX--;\n            mask = mask >> 1;\n          }\n        }\n        if (pX) {tft_Write_16(textbgcolor);}\n      }\n\n      end_tft_write();\n    }\n  }\n\n  #ifdef LOAD_RLE\n  else\n  #endif\n#endif  //FONT2\n\n#ifdef LOAD_RLE  //674 bytes of code\n  // Font is not 2 and hence is RLE encoded\n  {\n    begin_tft_write();\n    inTransaction = true;\n\n    w *= height; // Now w is total number of pixels in the character\n    if (textcolor == textbgcolor && !clip) {\n\n      int32_t px = 0, py = pY; // To hold character block start and end column and row values\n      int32_t pc = 0; // Pixel count\n      uint8_t np = textsize * textsize; // Number of pixels in a drawn pixel\n\n      uint8_t tnp = 0; // Temporary copy of np for while loop\n      uint8_t ts = textsize - 1; // Temporary copy of textsize\n      // 16-bit pixel count so maximum font size is equivalent to 180x180 pixels in area\n      // w is total number of pixels to plot to fill character block\n      while (pc < w) {\n        line = pgm_read_byte((uint8_t *)flash_address);\n        flash_address++;\n        if (line & 0x80) {\n          line &= 0x7F;\n          line++;\n          if (ts) {\n            px = xd + textsize * (pc % width); // Keep these px and py calculations outside the loop as they are slow\n            py = yd + textsize * (pc / width);\n          }\n          else {\n            px = xd + pc % width; // Keep these px and py calculations outside the loop as they are slow\n            py = yd + pc / width;\n          }\n          while (line--) { // In this case the while(line--) is faster\n            pc++; // This is faster than putting pc+=line before while()?\n            setWindow(px, py, px + ts, py + ts);\n\n            if (ts) {\n              tnp = np;\n              while (tnp--) {tft_Write_16(textcolor);}\n            }\n            else {tft_Write_16(textcolor);}\n            px += textsize;\n\n            if (px >= (xd + width * textsize)) {\n              px = xd;\n              py += textsize;\n            }\n          }\n        }\n        else {\n          line++;\n          pc += line;\n        }\n      }\n    }\n    else {\n      // Text colour != background and textsize = 1 and character is within viewport area\n      // so use faster drawing of characters and background using block write\n      if (textcolor != textbgcolor && textsize == 1 && !clip)\n      {\n        setWindow(xd, yd, xd + width - 1, yd + height - 1);\n\n        // Maximum font size is equivalent to 180x180 pixels in area\n        while (w > 0) {\n          line = pgm_read_byte((uint8_t *)flash_address++); // 8 bytes smaller when incrementing here\n          if (line & 0x80) {\n            line &= 0x7F;\n            line++; w -= line;\n            pushBlock(textcolor,line);\n          }\n          else {\n            line++; w -= line;\n            pushBlock(textbgcolor,line);\n          }\n        }\n      }\n      else\n      {\n        int32_t px = 0, py = 0;  // To hold character pixel coords\n        int32_t tx = 0, ty = 0;  // To hold character TFT pixel coords\n        int32_t pc = 0;          // Pixel count\n        int32_t pl = 0;          // Pixel line length\n        uint16_t pcol = 0;       // Pixel color\n        bool     pf = true;      // Flag for plotting\n        while (pc < w) {\n          line = pgm_read_byte((uint8_t *)flash_address);\n          flash_address++;\n          if (line & 0x80) { pcol = textcolor; line &= 0x7F; pf = true;}\n          else { pcol = textbgcolor; if (textcolor == textbgcolor) pf = false;}\n          line++;\n          px = pc % width;\n          tx = x + textsize * px;\n          py = pc / width;\n          ty = y + textsize * py;\n\n          pl = 0;\n          pc += line;\n          while (line--) {\n            pl++;\n            if ((px+pl) >= width) {\n              if (pf) fillRect(tx, ty, pl * textsize, textsize, pcol);\n              pl = 0;\n              px = 0;\n              tx = x;\n              py ++;\n              ty += textsize;\n            }\n          }\n          if (pl && pf) fillRect(tx, ty, pl * textsize, textsize, pcol);\n        }\n      }\n    }\n    inTransaction = lockTransaction;\n    end_tft_write();\n  }\n  // End of RLE font rendering\n#endif\n\n#if !defined (LOAD_FONT2) && !defined (LOAD_RLE)\n  // Stop warnings\n  flash_address = flash_address;\n  w = w;\n  pX = pX;\n  pY = pY;\n  line = line;\n  clip = clip;\n#endif\n\n  return width * textsize;    // x +\n}\n\n\n/***************************************************************************************\n** Function name:           drawString (with or without user defined font)\n** Description :            draw string with padding if it is defined\n***************************************************************************************/\n// Without font number, uses font set by setTextFont()\nint16_t TFT_eSPI::drawString(const String& string, int32_t poX, int32_t poY)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return drawString(buffer, poX, poY, textfont);\n}\n// With font number\nint16_t TFT_eSPI::drawString(const String& string, int32_t poX, int32_t poY, uint8_t font)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return drawString(buffer, poX, poY, font);\n}\n\n// Without font number, uses font set by setTextFont()\nint16_t TFT_eSPI::drawString(const char *string, int32_t poX, int32_t poY)\n{\n  return drawString(string, poX, poY, textfont);\n}\n\n// With font number. Note: font number is over-ridden if a smooth font is loaded\nint16_t TFT_eSPI::drawString(const char *string, int32_t poX, int32_t poY, uint8_t font)\n{\n  if (font > 8) return 0;\n\n  int16_t sumX = 0;\n  uint8_t padding = 1, baseline = 0;\n  uint16_t cwidth = textWidth(string, font); // Find the pixel width of the string in the font\n  uint16_t cheight = 8 * textsize;\n\n#ifdef LOAD_GFXFF\n  #ifdef SMOOTH_FONT\n    bool freeFont = (font == 1 && gfxFont && !fontLoaded);\n  #else\n    bool freeFont = (font == 1 && gfxFont);\n  #endif\n\n  if (freeFont) {\n    cheight = glyph_ab * textsize;\n    poY += cheight; // Adjust for baseline datum of free fonts\n    baseline = cheight;\n    padding =101; // Different padding method used for Free Fonts\n\n    // We need to make an adjustment for the bottom of the string (eg 'y' character)\n    if ((textdatum == BL_DATUM) || (textdatum == BC_DATUM) || (textdatum == BR_DATUM)) {\n      cheight += glyph_bb * textsize;\n    }\n  }\n#endif\n\n\n  // If it is not font 1 (GLCD or free font) get the baseline and pixel height of the font\n#ifdef SMOOTH_FONT\n  if(fontLoaded) {\n    baseline = gFont.maxAscent;\n    cheight  = fontHeight();\n  }\n  else\n#endif\n  if (font!=1) {\n    baseline = pgm_read_byte( &fontdata[font].baseline ) * textsize;\n    cheight = fontHeight(font);\n  }\n\n  if (textdatum || padX) {\n\n    switch(textdatum) {\n      case TC_DATUM:\n        poX -= cwidth/2;\n        padding += 1;\n        break;\n      case TR_DATUM:\n        poX -= cwidth;\n        padding += 2;\n        break;\n      case ML_DATUM:\n        poY -= cheight/2;\n        //padding += 0;\n        break;\n      case MC_DATUM:\n        poX -= cwidth/2;\n        poY -= cheight/2;\n        padding += 1;\n        break;\n      case MR_DATUM:\n        poX -= cwidth;\n        poY -= cheight/2;\n        padding += 2;\n        break;\n      case BL_DATUM:\n        poY -= cheight;\n        //padding += 0;\n        break;\n      case BC_DATUM:\n        poX -= cwidth/2;\n        poY -= cheight;\n        padding += 1;\n        break;\n      case BR_DATUM:\n        poX -= cwidth;\n        poY -= cheight;\n        padding += 2;\n        break;\n      case L_BASELINE:\n        poY -= baseline;\n        //padding += 0;\n        break;\n      case C_BASELINE:\n        poX -= cwidth/2;\n        poY -= baseline;\n        padding += 1;\n        break;\n      case R_BASELINE:\n        poX -= cwidth;\n        poY -= baseline;\n        padding += 2;\n        break;\n    }\n  }\n\n\n  int8_t xo = 0;\n#ifdef LOAD_GFXFF\n  if (freeFont && (textcolor!=textbgcolor)) {\n      cheight = (glyph_ab + glyph_bb) * textsize;\n      // Get the offset for the first character only to allow for negative offsets\n      uint16_t c2 = 0;\n      uint16_t len = strlen(string);\n      uint16_t n = 0;\n\n      while (n < len && c2 == 0) c2 = decodeUTF8((uint8_t*)string, &n, len - n);\n\n      if((c2 >= pgm_read_word(&gfxFont->first)) && (c2 <= pgm_read_word(&gfxFont->last) )) {\n        c2 -= pgm_read_word(&gfxFont->first);\n        GFXglyph *glyph = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[c2]);\n        xo = pgm_read_byte(&glyph->xOffset) * textsize;\n        // Adjust for negative xOffset\n        if (xo > 0) xo = 0;\n        else cwidth -= xo;\n        // Add 1 pixel of padding all round\n        //cheight +=2;\n        //fillRect(poX+xo-1, poY - 1 - glyph_ab * textsize, cwidth+2, cheight, textbgcolor);\n        fillRect(poX+xo, poY - glyph_ab * textsize, cwidth, cheight, textbgcolor);\n      }\n      padding -=100;\n    }\n#endif\n\n  uint16_t len = strlen(string);\n  uint16_t n = 0;\n\n#ifdef SMOOTH_FONT\n  if(fontLoaded) {\n    setCursor(poX, poY);\n\n    bool fillbg = _fillbg;\n    // If padding is requested then fill the text background\n    if (padX && !_fillbg) _fillbg = true;\n\n    while (n < len) {\n      uint16_t uniCode = decodeUTF8((uint8_t*)string, &n, len - n);\n      drawGlyph(uniCode);\n    }\n    _fillbg = fillbg; // restore state\n    sumX += cwidth;\n    //fontFile.close();\n  }\n  else\n#endif\n  {\n    while (n < len) {\n      uint16_t uniCode = decodeUTF8((uint8_t*)string, &n, len - n);\n      sumX += drawChar(uniCode, poX+sumX, poY, font);\n    }\n  }\n\n//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv DEBUG vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n// Switch on debugging for the padding areas\n//#define PADDING_DEBUG\n\n#ifndef PADDING_DEBUG\n//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEBUG ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n  if((padX>cwidth) && (textcolor!=textbgcolor)) {\n    int16_t padXc = poX+cwidth+xo;\n#ifdef LOAD_GFXFF\n    if (freeFont) {\n      poX +=xo; // Adjust for negative offset start character\n      poY -= glyph_ab * textsize;\n      sumX += poX;\n    }\n#endif\n    switch(padding) {\n      case 1:\n        fillRect(padXc,poY,padX-cwidth,cheight, textbgcolor);\n        break;\n      case 2:\n        fillRect(padXc,poY,(padX-cwidth)>>1,cheight, textbgcolor);\n        padXc = poX - ((padX-cwidth)>>1);\n        fillRect(padXc,poY,(padX-cwidth)>>1,cheight, textbgcolor);\n        break;\n      case 3:\n        if (padXc>padX) padXc = padX;\n        fillRect(poX + cwidth - padXc,poY,padXc-cwidth,cheight, textbgcolor);\n        break;\n    }\n  }\n\n\n#else\n\n//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv DEBUG vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n// This is debug code to show text (green box) and blanked (white box) areas\n// It shows that the padding areas are being correctly sized and positioned\n\n  if((padX>sumX) && (textcolor!=textbgcolor)) {\n    int16_t padXc = poX+sumX; // Maximum left side padding\n#ifdef LOAD_GFXFF\n    if ((font == 1) && (gfxFont)) poY -= glyph_ab;\n#endif\n    drawRect(poX,poY,sumX,cheight, TFT_GREEN);\n    switch(padding) {\n      case 1:\n        drawRect(padXc,poY,padX-sumX,cheight, TFT_WHITE);\n        break;\n      case 2:\n        drawRect(padXc,poY,(padX-sumX)>>1, cheight, TFT_WHITE);\n        padXc = (padX-sumX)>>1;\n        drawRect(poX - padXc,poY,(padX-sumX)>>1,cheight, TFT_WHITE);\n        break;\n      case 3:\n        if (padXc>padX) padXc = padX;\n        drawRect(poX + sumX - padXc,poY,padXc-sumX,cheight, TFT_WHITE);\n        break;\n    }\n  }\n#endif\n//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEBUG ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nreturn sumX;\n}\n\n\n/***************************************************************************************\n** Function name:           drawCentreString (deprecated, use setTextDatum())\n** Descriptions:            draw string centred on dX\n***************************************************************************************/\nint16_t TFT_eSPI::drawCentreString(const String& string, int32_t dX, int32_t poY, uint8_t font)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return drawCentreString(buffer, dX, poY, font);\n}\n\nint16_t TFT_eSPI::drawCentreString(const char *string, int32_t dX, int32_t poY, uint8_t font)\n{\n  uint8_t tempdatum = textdatum;\n  int32_t sumX = 0;\n  textdatum = TC_DATUM;\n  sumX = drawString(string, dX, poY, font);\n  textdatum = tempdatum;\n  return sumX;\n}\n\n\n/***************************************************************************************\n** Function name:           drawRightString (deprecated, use setTextDatum())\n** Descriptions:            draw string right justified to dX\n***************************************************************************************/\nint16_t TFT_eSPI::drawRightString(const String& string, int32_t dX, int32_t poY, uint8_t font)\n{\n  int16_t len = string.length() + 2;\n  char buffer[len];\n  string.toCharArray(buffer, len);\n  return drawRightString(buffer, dX, poY, font);\n}\n\nint16_t TFT_eSPI::drawRightString(const char *string, int32_t dX, int32_t poY, uint8_t font)\n{\n  uint8_t tempdatum = textdatum;\n  int16_t sumX = 0;\n  textdatum = TR_DATUM;\n  sumX = drawString(string, dX, poY, font);\n  textdatum = tempdatum;\n  return sumX;\n}\n\n\n/***************************************************************************************\n** Function name:           drawNumber\n** Description:             draw a long integer\n***************************************************************************************/\nint16_t TFT_eSPI::drawNumber(long long_num, int32_t poX, int32_t poY)\n{\n  isDigits = true; // Eliminate jiggle in monospaced fonts\n  char str[12];\n  ltoa(long_num, str, 10);\n  return drawString(str, poX, poY, textfont);\n}\n\nint16_t TFT_eSPI::drawNumber(long long_num, int32_t poX, int32_t poY, uint8_t font)\n{\n  isDigits = true; // Eliminate jiggle in monospaced fonts\n  char str[12];\n  ltoa(long_num, str, 10);\n  return drawString(str, poX, poY, font);\n}\n\n\n/***************************************************************************************\n** Function name:           drawFloat\n** Descriptions:            drawFloat, prints 7 non zero digits maximum\n***************************************************************************************/\n// Assemble and print a string, this permits alignment relative to a datum\n// looks complicated but much more compact and actually faster than using print class\nint16_t TFT_eSPI::drawFloat(float floatNumber, uint8_t dp, int32_t poX, int32_t poY)\n{\n  return drawFloat(floatNumber, dp, poX, poY, textfont);\n}\n\nint16_t TFT_eSPI::drawFloat(float floatNumber, uint8_t dp, int32_t poX, int32_t poY, uint8_t font)\n{\n  isDigits = true;\n  char str[14];               // Array to contain decimal string\n  uint8_t ptr = 0;            // Initialise pointer for array\n  int8_t  digits = 1;         // Count the digits to avoid array overflow\n  float rounding = 0.5;       // Round up down delta\n  bool negative = false;\n\n  if (dp > 7) dp = 7; // Limit the size of decimal portion\n\n  // Adjust the rounding value\n  for (uint8_t i = 0; i < dp; ++i) rounding /= 10.0;\n\n  if (floatNumber < -rounding) {   // add sign, avoid adding - sign to 0.0!\n    str[ptr++] = '-'; // Negative number\n    str[ptr] = 0; // Put a null in the array as a precaution\n    digits = 0;   // Set digits to 0 to compensate so pointer value can be used later\n    floatNumber = -floatNumber; // Make positive\n    negative = true;\n  }\n\n  floatNumber += rounding; // Round up or down\n\n  if (dp == 0) {\n    if (negative) floatNumber = -floatNumber;\n    return drawNumber((long)floatNumber, poX, poY, font);\n  }\n\n  // For error put ... in string and return (all TFT_eSPI library fonts contain . character)\n  if (floatNumber >= 2147483647) {\n    strcpy(str, \"...\");\n    return drawString(str, poX, poY, font);\n  }\n  // No chance of overflow from here on\n\n  // Get integer part\n  uint32_t temp = (uint32_t)floatNumber;\n\n  // Put integer part into array\n  ltoa(temp, str + ptr, 10);\n\n  // Find out where the null is to get the digit count loaded\n  while ((uint8_t)str[ptr] != 0) ptr++; // Move the pointer along\n  digits += ptr;                  // Count the digits\n\n  str[ptr++] = '.'; // Add decimal point\n  str[ptr] = '0';   // Add a dummy zero\n  str[ptr + 1] = 0; // Add a null but don't increment pointer so it can be overwritten\n\n  // Get the decimal portion\n  floatNumber = floatNumber - temp;\n\n  // Get decimal digits one by one and put in array\n  // Limit digit count so we don't get a false sense of resolution\n  uint8_t i = 0;\n  while ((i < dp) && (digits < 9)) { // while (i < dp) for no limit but array size must be increased\n    i++;\n    floatNumber *= 10;       // for the next decimal\n    temp = floatNumber;      // get the decimal\n    ltoa(temp, str + ptr, 10);\n    ptr++; digits++;         // Increment pointer and digits count\n    floatNumber -= temp;     // Remove that digit\n  }\n\n  // Finally we can plot the string and return pixel length\n  return drawString(str, poX, poY, font);\n}\n\n\n/***************************************************************************************\n** Function name:           setFreeFont\n** Descriptions:            Sets the GFX free font to use\n***************************************************************************************/\n\n#ifdef LOAD_GFXFF\n\nvoid TFT_eSPI::setFreeFont(const GFXfont *f)\n{\n  if (f == nullptr) { // Fix issue #400 (ESP32 crash)\n    setTextFont(1); // Use GLCD font\n    return;\n  }\n\n  textfont = 1;\n  gfxFont = (GFXfont *)f;\n\n  glyph_ab = 0;\n  glyph_bb = 0;\n  uint16_t numChars = pgm_read_word(&gfxFont->last) - pgm_read_word(&gfxFont->first);\n\n  // Find the biggest above and below baseline offsets\n  for (uint16_t c = 0; c < numChars; c++) {\n    GFXglyph *glyph1  = &(((GFXglyph *)pgm_read_dword(&gfxFont->glyph))[c]);\n    int8_t ab = -pgm_read_byte(&glyph1->yOffset);\n    if (ab > glyph_ab) glyph_ab = ab;\n    int8_t bb = pgm_read_byte(&glyph1->height) - ab;\n    if (bb > glyph_bb) glyph_bb = bb;\n  }\n}\n\n\n/***************************************************************************************\n** Function name:           setTextFont\n** Description:             Set the font for the print stream\n***************************************************************************************/\nvoid TFT_eSPI::setTextFont(uint8_t f)\n{\n  textfont = (f > 0) ? f : 1; // Don't allow font 0\n  textfont = (f > 8) ? 1 : f; // Don't allow font > 8\n  gfxFont = NULL;\n}\n\n#else\n\n\n/***************************************************************************************\n** Function name:           setFreeFont\n** Descriptions:            Sets the GFX free font to use\n***************************************************************************************/\n\n// Alternative to setTextFont() so we don't need two different named functions\nvoid TFT_eSPI::setFreeFont(uint8_t font)\n{\n  setTextFont(font);\n}\n\n\n/***************************************************************************************\n** Function name:           setTextFont\n** Description:             Set the font for the print stream\n***************************************************************************************/\nvoid TFT_eSPI::setTextFont(uint8_t f)\n{\n  textfont = (f > 0) ? f : 1; // Don't allow font 0\n  textfont = (f > 8) ? 1 : f; // Don't allow font > 8\n}\n#endif\n\n\n/***************************************************************************************\n** Function name:           getSPIinstance\n** Description:             Get the instance of the SPI class\n***************************************************************************************/\n#if !defined (TFT_PARALLEL_8_BIT) && !defined (RP2040_PIO_INTERFACE)\nSPIClass& TFT_eSPI::getSPIinstance(void)\n{\n  return spi;\n}\n#endif\n\n\n/***************************************************************************************\n** Function name:           verifySetupID\n** Description:             Compare the ID if USER_SETUP_ID defined in user setup file\n***************************************************************************************/\nbool TFT_eSPI::verifySetupID(uint32_t id)\n{\n#if defined (USER_SETUP_ID)\n  if (USER_SETUP_ID == id) return true;\n#else\n  id = id; // Avoid warning\n#endif\n  return false;\n}\n\n/***************************************************************************************\n** Function name:           getSetup\n** Description:             Get the setup details for diagnostic and sketch access\n***************************************************************************************/\nvoid TFT_eSPI::getSetup(setup_t &tft_settings)\n{\n// tft_settings.version is set in header file\n\n#if defined (USER_SETUP_INFO)\n  tft_settings.setup_info = USER_SETUP_INFO;\n#else\n  tft_settings.setup_info = \"NA\";\n#endif\n\n#if defined (USER_SETUP_ID)\n  tft_settings.setup_id = USER_SETUP_ID;\n#else\n  tft_settings.setup_id = 0;\n#endif\n\n#if defined (PROCESSOR_ID)\n  tft_settings.esp = PROCESSOR_ID;\n#else\n  tft_settings.esp = -1;\n#endif\n\n#if defined (SUPPORT_TRANSACTIONS)\n  tft_settings.trans = true;\n#else\n  tft_settings.trans = false;\n#endif\n\n#if defined (TFT_PARALLEL_8_BIT) || defined(TFT_PARALLEL_16_BIT)\n  tft_settings.serial = false;\n  tft_settings.tft_spi_freq = 0;\n#else\n  tft_settings.serial = true;\n  tft_settings.tft_spi_freq = SPI_FREQUENCY/100000;\n  #ifdef SPI_READ_FREQUENCY\n    tft_settings.tft_rd_freq = SPI_READ_FREQUENCY/100000;\n  #endif\n  #ifndef GENERIC_PROCESSOR\n    #ifdef TFT_SPI_PORT\n      tft_settings.port = TFT_SPI_PORT;\n    #else\n      tft_settings.port = 255;\n    #endif\n  #endif\n  #ifdef RP2040_PIO_SPI\n    tft_settings.interface = 0x10;\n  #else\n    tft_settings.interface = 0x0;\n  #endif\n#endif\n\n#if defined(TFT_SPI_OVERLAP)\n  tft_settings.overlap = true;\n#else\n  tft_settings.overlap = false;\n#endif\n\n  tft_settings.tft_driver = TFT_DRIVER;\n  tft_settings.tft_width  = _init_width;\n  tft_settings.tft_height = _init_height;\n\n#ifdef CGRAM_OFFSET\n  tft_settings.r0_x_offset = colstart;\n  tft_settings.r0_y_offset = rowstart;\n  tft_settings.r1_x_offset = 0;\n  tft_settings.r1_y_offset = 0;\n  tft_settings.r2_x_offset = 0;\n  tft_settings.r2_y_offset = 0;\n  tft_settings.r3_x_offset = 0;\n  tft_settings.r3_y_offset = 0;\n#else\n  tft_settings.r0_x_offset = 0;\n  tft_settings.r0_y_offset = 0;\n  tft_settings.r1_x_offset = 0;\n  tft_settings.r1_y_offset = 0;\n  tft_settings.r2_x_offset = 0;\n  tft_settings.r2_y_offset = 0;\n  tft_settings.r3_x_offset = 0;\n  tft_settings.r3_y_offset = 0;\n#endif\n\n#if defined (TFT_MOSI)\n  tft_settings.pin_tft_mosi = TFT_MOSI;\n#else\n  tft_settings.pin_tft_mosi = -1;\n#endif\n\n#if defined (TFT_MISO)\n  tft_settings.pin_tft_miso = TFT_MISO;\n#else\n  tft_settings.pin_tft_miso = -1;\n#endif\n\n#if defined (TFT_SCLK)\n  tft_settings.pin_tft_clk  = TFT_SCLK;\n#else\n  tft_settings.pin_tft_clk  = -1;\n#endif\n\n#if defined (TFT_CS)\n  tft_settings.pin_tft_cs   = TFT_CS;\n#else\n  tft_settings.pin_tft_cs   = -1;\n#endif\n\n#if defined (TFT_DC)\n  tft_settings.pin_tft_dc  = TFT_DC;\n#else\n  tft_settings.pin_tft_dc  = -1;\n#endif\n\n#if defined (TFT_RD)\n  tft_settings.pin_tft_rd  = TFT_RD;\n#else\n  tft_settings.pin_tft_rd  = -1;\n#endif\n\n#if defined (TFT_WR)\n  tft_settings.pin_tft_wr  = TFT_WR;\n#else\n  tft_settings.pin_tft_wr  = -1;\n#endif\n\n#if defined (TFT_RST)\n  tft_settings.pin_tft_rst = TFT_RST;\n#else\n  tft_settings.pin_tft_rst = -1;\n#endif\n\n#if defined (TFT_PARALLEL_8_BIT) || defined(TFT_PARALLEL_16_BIT)\n  tft_settings.pin_tft_d0 = TFT_D0;\n  tft_settings.pin_tft_d1 = TFT_D1;\n  tft_settings.pin_tft_d2 = TFT_D2;\n  tft_settings.pin_tft_d3 = TFT_D3;\n  tft_settings.pin_tft_d4 = TFT_D4;\n  tft_settings.pin_tft_d5 = TFT_D5;\n  tft_settings.pin_tft_d6 = TFT_D6;\n  tft_settings.pin_tft_d7 = TFT_D7;\n#else\n  tft_settings.pin_tft_d0 = -1;\n  tft_settings.pin_tft_d1 = -1;\n  tft_settings.pin_tft_d2 = -1;\n  tft_settings.pin_tft_d3 = -1;\n  tft_settings.pin_tft_d4 = -1;\n  tft_settings.pin_tft_d5 = -1;\n  tft_settings.pin_tft_d6 = -1;\n  tft_settings.pin_tft_d7 = -1;\n#endif\n\n#if defined (TFT_BL)\n  tft_settings.pin_tft_led = TFT_BL;\n#endif\n\n#if defined (TFT_BACKLIGHT_ON)\n  tft_settings.pin_tft_led_on = TFT_BACKLIGHT_ON;\n#endif\n\n#if defined (TOUCH_CS)\n  tft_settings.pin_tch_cs   = TOUCH_CS;\n  tft_settings.tch_spi_freq = SPI_TOUCH_FREQUENCY/100000;\n#else\n  tft_settings.pin_tch_cs   = -1;\n  tft_settings.tch_spi_freq = 0;\n#endif\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n#ifdef TOUCH_CS\n  #include \"Extensions/Touch.cpp\"\n#endif\n\n#include \"Extensions/Button.cpp\"\n\n#include \"Extensions/Sprite.cpp\"\n\n#ifdef SMOOTH_FONT\n  #include \"Extensions/Smooth_font.cpp\"\n#endif\n\n#ifdef AA_GRAPHICS\n  #include \"Extensions/AA_graphics.cpp\"  // Loaded if SMOOTH_FONT is defined by user\n#endif\n////////////////////////////////////////////////////////////////////////////////////////\n\n"
        },
        {
          "name": "TFT_eSPI.h",
          "type": "blob",
          "size": 46.384765625,
          "content": "/***************************************************\n  Arduino TFT graphics library targeted at ESP8266\n  and ESP32 based boards.\n\n  This is a stand-alone library that contains the\n  hardware driver, the graphics functions and the\n  proportional fonts.\n\n  The built-in fonts 4, 6, 7 and 8 are Run Length\n  Encoded (RLE) to reduce the FLASH footprint.\n\n  Last review/edit by Bodmer: 04/02/22\n ****************************************************/\n\n// Stop fonts etc. being loaded multiple times\n#ifndef _TFT_eSPIH_\n#define _TFT_eSPIH_\n\n#define TFT_ESPI_VERSION \"2.5.43\"\n\n// Bit level feature flags\n// Bit 0 set: viewport capability\n#define TFT_ESPI_FEATURES 1\n\n/***************************************************************************************\n**                         Section 1: Load required header files\n***************************************************************************************/\n\n//Standard support\n#include <Arduino.h>\n#include <Print.h>\n#if !defined (TFT_PARALLEL_8_BIT) && !defined (RP2040_PIO_INTERFACE)\n  #include <SPI.h>\n#endif\n/***************************************************************************************\n**                         Section 2: Load library and processor specific header files\n***************************************************************************************/\n// Include header file that defines the fonts loaded, the TFT drivers\n// available and the pins to be used, etc. etc.\n#ifdef CONFIG_TFT_eSPI_ESPIDF\n  #include \"TFT_config.h\"\n#endif\n\n// New ESP8266 board package uses ARDUINO_ARCH_ESP8266\n// old package defined ESP8266\n#if defined (ESP8266)\n  #ifndef ARDUINO_ARCH_ESP8266\n    #define ARDUINO_ARCH_ESP8266\n  #endif\n#endif\n\n// The following lines allow the user setup to be included in the sketch folder, see\n// \"Sketch_with_tft_setup\" generic example.\n#if !defined __has_include\n  #if !defined(DISABLE_ALL_LIBRARY_WARNINGS)\n    #warning Compiler does not support __has_include, so sketches cannot define the setup\n  #endif\n#else\n  #if __has_include(<tft_setup.h>)\n    // Include the sketch setup file\n    #include <tft_setup.h>\n    #ifndef USER_SETUP_LOADED\n      // Prevent loading further setups\n      #define USER_SETUP_LOADED\n    #endif\n  #endif\n#endif\n\n#include <User_Setup_Select.h>\n\n// Handle FLASH based storage e.g. PROGMEM\n#if defined(ARDUINO_ARCH_RP2040)\n  #undef pgm_read_byte\n  #define pgm_read_byte(addr)   (*(const unsigned char *)(addr))\n  #undef pgm_read_word\n  #define pgm_read_word(addr) ({ \\\n    typeof(addr) _addr = (addr); \\\n    *(const unsigned short *)(_addr); \\\n  })\n  #undef pgm_read_dword\n  #define pgm_read_dword(addr) ({ \\\n    typeof(addr) _addr = (addr); \\\n    *(const unsigned long *)(_addr); \\\n  })\n#elif defined(__AVR__)\n  #include <avr/pgmspace.h>\n#elif defined(ARDUINO_ARCH_ESP8266) || defined(ESP32)\n  #include <pgmspace.h>\n#else\n  #ifndef PROGMEM\n    #define PROGMEM\n  #endif\n#endif\n\n// Include the processor specific drivers\n#if defined(CONFIG_IDF_TARGET_ESP32S3)\n  #include \"Processors/TFT_eSPI_ESP32_S3.h\"\n#elif defined(CONFIG_IDF_TARGET_ESP32C3)\n  #include \"Processors/TFT_eSPI_ESP32_C3.h\"\n#elif defined (ESP32)\n  #include \"Processors/TFT_eSPI_ESP32.h\"\n#elif defined (ARDUINO_ARCH_ESP8266)\n  #include \"Processors/TFT_eSPI_ESP8266.h\"\n#elif defined (STM32)\n  #include \"Processors/TFT_eSPI_STM32.h\"\n#elif defined(ARDUINO_ARCH_RP2040)\n  #include \"Processors/TFT_eSPI_RP2040.h\"\n#else\n  #include \"Processors/TFT_eSPI_Generic.h\"\n  #define GENERIC_PROCESSOR\n#endif\n\n/***************************************************************************************\n**                         Section 3: Interface setup\n***************************************************************************************/\n#ifndef TAB_COLOUR\n  #define TAB_COLOUR 0\n#endif\n\n// If the SPI frequency is not defined, set a default\n#ifndef SPI_FREQUENCY\n  #define SPI_FREQUENCY  20000000\n#endif\n\n// If the SPI read frequency is not defined, set a default\n#ifndef SPI_READ_FREQUENCY\n  #define SPI_READ_FREQUENCY 10000000\n#endif\n\n// Some ST7789 boards do not work with Mode 0\n#ifndef TFT_SPI_MODE\n  #if defined(ST7789_DRIVER) || defined(ST7789_2_DRIVER)\n    #define TFT_SPI_MODE SPI_MODE3\n  #else\n    #define TFT_SPI_MODE SPI_MODE0\n  #endif\n#endif\n\n// If the XPT2046 SPI frequency is not defined, set a default\n#ifndef SPI_TOUCH_FREQUENCY\n  #define SPI_TOUCH_FREQUENCY  2500000\n#endif\n\n#ifndef SPI_BUSY_CHECK\n  #define SPI_BUSY_CHECK\n#endif\n\n// If half duplex SDA mode is defined then MISO pin should be -1\n#ifdef TFT_SDA_READ\n  #ifdef TFT_MISO\n    #if TFT_MISO != -1\n      #undef TFT_MISO\n      #define TFT_MISO -1\n      #warning TFT_MISO set to -1\n    #endif\n  #endif\n#endif  \n\n/***************************************************************************************\n**                         Section 4: Setup fonts\n***************************************************************************************/\n// Use GLCD font in error case where user requests a smooth font file\n// that does not exist (this is a temporary fix to stop ESP32 reboot)\n#ifdef SMOOTH_FONT\n  #ifndef LOAD_GLCD\n    #define LOAD_GLCD\n  #endif\n#endif\n\n// Only load the fonts defined in User_Setup.h (to save space)\n// Set flag so RLE rendering code is optionally compiled\n#ifdef LOAD_GLCD\n  #include <Fonts/glcdfont.c>\n#endif\n\n#ifdef LOAD_FONT2\n  #include <Fonts/Font16.h>\n#endif\n\n#ifdef LOAD_FONT4\n  #include <Fonts/Font32rle.h>\n  #define LOAD_RLE\n#endif\n\n#ifdef LOAD_FONT6\n  #include <Fonts/Font64rle.h>\n  #ifndef LOAD_RLE\n    #define LOAD_RLE\n  #endif\n#endif\n\n#ifdef LOAD_FONT7\n  #include <Fonts/Font7srle.h>\n  #ifndef LOAD_RLE\n    #define LOAD_RLE\n  #endif\n#endif\n\n#ifdef LOAD_FONT8\n  #include <Fonts/Font72rle.h>\n  #ifndef LOAD_RLE\n    #define LOAD_RLE\n  #endif\n#elif defined LOAD_FONT8N // Optional narrower version\n  #define LOAD_FONT8\n  #include <Fonts/Font72x53rle.h>\n  #ifndef LOAD_RLE\n    #define LOAD_RLE\n  #endif\n#endif\n\n#ifdef LOAD_GFXFF\n  // We can include all the free fonts and they will only be built into\n  // the sketch if they are used\n  #include <Fonts/GFXFF/gfxfont.h>\n  // Call up any user custom fonts\n  #include <User_Setups/User_Custom_Fonts.h>\n#endif // #ifdef LOAD_GFXFF\n\n// Create a null default font in case some fonts not used (to prevent crash)\nconst  uint8_t widtbl_null[1] = {0};\nPROGMEM const uint8_t chr_null[1] = {0};\nPROGMEM const uint8_t* const chrtbl_null[1] = {chr_null};\n\n// This is a structure to conveniently hold information on the default fonts\n// Stores pointer to font character image address table, width table and height\ntypedef struct {\n    const uint8_t *chartbl;\n    const uint8_t *widthtbl;\n    uint8_t height;\n    uint8_t baseline;\n    } fontinfo;\n\n// Now fill the structure\nconst PROGMEM fontinfo fontdata [] = {\n  #ifdef LOAD_GLCD\n   { (const uint8_t *)font, widtbl_null, 0, 0 },\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n  #endif\n   // GLCD font (Font 1) does not have all parameters\n   { (const uint8_t *)chrtbl_null, widtbl_null, 8, 7 },\n\n  #ifdef LOAD_FONT2\n   { (const uint8_t *)chrtbl_f16, widtbl_f16, chr_hgt_f16, baseline_f16},\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n  #endif\n\n   // Font 3 current unused\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n\n  #ifdef LOAD_FONT4\n   { (const uint8_t *)chrtbl_f32, widtbl_f32, chr_hgt_f32, baseline_f32},\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n  #endif\n\n   // Font 5 current unused\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n\n  #ifdef LOAD_FONT6\n   { (const uint8_t *)chrtbl_f64, widtbl_f64, chr_hgt_f64, baseline_f64},\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n  #endif\n\n  #ifdef LOAD_FONT7\n   { (const uint8_t *)chrtbl_f7s, widtbl_f7s, chr_hgt_f7s, baseline_f7s},\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 },\n  #endif\n\n  #ifdef LOAD_FONT8\n   { (const uint8_t *)chrtbl_f72, widtbl_f72, chr_hgt_f72, baseline_f72}\n  #else\n   { (const uint8_t *)chrtbl_null, widtbl_null, 0, 0 }\n  #endif\n};\n\n/***************************************************************************************\n**                         Section 5: Font datum enumeration\n***************************************************************************************/\n//These enumerate the text plotting alignment (reference datum point)\n#define TL_DATUM 0 // Top left (default)\n#define TC_DATUM 1 // Top centre\n#define TR_DATUM 2 // Top right\n#define ML_DATUM 3 // Middle left\n#define CL_DATUM 3 // Centre left, same as above\n#define MC_DATUM 4 // Middle centre\n#define CC_DATUM 4 // Centre centre, same as above\n#define MR_DATUM 5 // Middle right\n#define CR_DATUM 5 // Centre right, same as above\n#define BL_DATUM 6 // Bottom left\n#define BC_DATUM 7 // Bottom centre\n#define BR_DATUM 8 // Bottom right\n#define L_BASELINE  9 // Left character baseline (Line the 'A' character would sit on)\n#define C_BASELINE 10 // Centre character baseline\n#define R_BASELINE 11 // Right character baseline\n\n/***************************************************************************************\n**                         Section 6: Colour enumeration\n***************************************************************************************/\n// Default color definitions\n#define TFT_BLACK       0x0000      /*   0,   0,   0 */\n#define TFT_NAVY        0x000F      /*   0,   0, 128 */\n#define TFT_DARKGREEN   0x03E0      /*   0, 128,   0 */\n#define TFT_DARKCYAN    0x03EF      /*   0, 128, 128 */\n#define TFT_MAROON      0x7800      /* 128,   0,   0 */\n#define TFT_PURPLE      0x780F      /* 128,   0, 128 */\n#define TFT_OLIVE       0x7BE0      /* 128, 128,   0 */\n#define TFT_LIGHTGREY   0xD69A      /* 211, 211, 211 */\n#define TFT_DARKGREY    0x7BEF      /* 128, 128, 128 */\n#define TFT_BLUE        0x001F      /*   0,   0, 255 */\n#define TFT_GREEN       0x07E0      /*   0, 255,   0 */\n#define TFT_CYAN        0x07FF      /*   0, 255, 255 */\n#define TFT_RED         0xF800      /* 255,   0,   0 */\n#define TFT_MAGENTA     0xF81F      /* 255,   0, 255 */\n#define TFT_YELLOW      0xFFE0      /* 255, 255,   0 */\n#define TFT_WHITE       0xFFFF      /* 255, 255, 255 */\n#define TFT_ORANGE      0xFDA0      /* 255, 180,   0 */\n#define TFT_GREENYELLOW 0xB7E0      /* 180, 255,   0 */\n#define TFT_PINK        0xFE19      /* 255, 192, 203 */ //Lighter pink, was 0xFC9F\n#define TFT_BROWN       0x9A60      /* 150,  75,   0 */\n#define TFT_GOLD        0xFEA0      /* 255, 215,   0 */\n#define TFT_SILVER      0xC618      /* 192, 192, 192 */\n#define TFT_SKYBLUE     0x867D      /* 135, 206, 235 */\n#define TFT_VIOLET      0x915C      /* 180,  46, 226 */\n\n// Next is a special 16-bit colour value that encodes to 8 bits\n// and will then decode back to the same 16-bit value.\n// Convenient for 8-bit and 16-bit transparent sprites.\n#define TFT_TRANSPARENT 0x0120 // This is actually a dark green\n\n// Default palette for 4-bit colour sprites\nstatic const uint16_t default_4bit_palette[] PROGMEM = {\n  TFT_BLACK,    //  0  ^\n  TFT_BROWN,    //  1  |\n  TFT_RED,      //  2  |\n  TFT_ORANGE,   //  3  |\n  TFT_YELLOW,   //  4  Colours 0-9 follow the resistor colour code!\n  TFT_GREEN,    //  5  |\n  TFT_BLUE,     //  6  |\n  TFT_PURPLE,   //  7  |\n  TFT_DARKGREY, //  8  |\n  TFT_WHITE,    //  9  v\n  TFT_CYAN,     // 10  Blue+green mix\n  TFT_MAGENTA,  // 11  Blue+red mix\n  TFT_MAROON,   // 12  Darker red colour\n  TFT_DARKGREEN,// 13  Darker green colour\n  TFT_NAVY,     // 14  Darker blue colour\n  TFT_PINK      // 15\n};\n\n/***************************************************************************************\n**                         Section 7: Diagnostic support\n***************************************************************************************/\n// #define TFT_eSPI_DEBUG     // Switch on debug support serial messages  (not used yet)\n// #define TFT_eSPI_FNx_DEBUG // Switch on debug support for function \"x\" (not used yet)\n\n// This structure allows sketches to retrieve the user setup parameters at runtime\n// by calling getSetup(), zero impact on code size unless used, mainly for diagnostics\ntypedef struct\n{\nString  version = TFT_ESPI_VERSION;\nString  setup_info;  // Setup reference name available to use in a user setup\nuint32_t setup_id;   // ID available to use in a user setup\nint32_t esp;         // Processor code\nuint8_t trans;       // SPI transaction support\nuint8_t serial;      // Serial (SPI) or parallel\n#ifndef GENERIC_PROCESSOR\nuint8_t  port;       // SPI port\n#endif\nuint8_t overlap;     // ESP8266 overlap mode\nuint8_t interface;   // Interface type\n\nuint16_t tft_driver; // Hexadecimal code\nuint16_t tft_width;  // Rotation 0 width and height\nuint16_t tft_height;\n\nuint8_t r0_x_offset; // Display offsets, not all used yet\nuint8_t r0_y_offset;\nuint8_t r1_x_offset;\nuint8_t r1_y_offset;\nuint8_t r2_x_offset;\nuint8_t r2_y_offset;\nuint8_t r3_x_offset;\nuint8_t r3_y_offset;\n\nint8_t pin_tft_mosi; // SPI pins\nint8_t pin_tft_miso;\nint8_t pin_tft_clk;\nint8_t pin_tft_cs;\n\nint8_t pin_tft_dc;   // Control pins\nint8_t pin_tft_rd;\nint8_t pin_tft_wr;\nint8_t pin_tft_rst;\n\nint8_t pin_tft_d0;   // Parallel port pins\nint8_t pin_tft_d1;\nint8_t pin_tft_d2;\nint8_t pin_tft_d3;\nint8_t pin_tft_d4;\nint8_t pin_tft_d5;\nint8_t pin_tft_d6;\nint8_t pin_tft_d7;\n\nint8_t pin_tft_led;\nint8_t pin_tft_led_on;\n\nint8_t pin_tch_cs;   // Touch chip select pin\n\nint16_t tft_spi_freq;// TFT write SPI frequency\nint16_t tft_rd_freq; // TFT read  SPI frequency\nint16_t tch_spi_freq;// Touch controller read/write SPI frequency\n} setup_t;\n\n/***************************************************************************************\n**                         Section 8: Class member and support functions\n***************************************************************************************/\n\n// Callback prototype for smooth font pixel colour read\ntypedef uint16_t (*getColorCallback)(uint16_t x, uint16_t y);\n\n// Class functions and variables\nclass TFT_eSPI : public Print { friend class TFT_eSprite; // Sprite class has access to protected members\n\n //--------------------------------------- public ------------------------------------//\n public:\n\n  TFT_eSPI(int16_t _W = TFT_WIDTH, int16_t _H = TFT_HEIGHT);\n\n  // init() and begin() are equivalent, begin() included for backwards compatibility\n  // Sketch defined tab colour option is for ST7735 displays only\n  void     init(uint8_t tc = TAB_COLOUR), begin(uint8_t tc = TAB_COLOUR);\n\n  // These are virtual so the TFT_eSprite class can override them with sprite specific functions\n  virtual void     drawPixel(int32_t x, int32_t y, uint32_t color),\n                   drawChar(int32_t x, int32_t y, uint16_t c, uint32_t color, uint32_t bg, uint8_t size),\n                   drawLine(int32_t xs, int32_t ys, int32_t xe, int32_t ye, uint32_t color),\n                   drawFastVLine(int32_t x, int32_t y, int32_t h, uint32_t color),\n                   drawFastHLine(int32_t x, int32_t y, int32_t w, uint32_t color),\n                   fillRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color);\n\n  virtual int16_t  drawChar(uint16_t uniCode, int32_t x, int32_t y, uint8_t font),\n                   drawChar(uint16_t uniCode, int32_t x, int32_t y),\n                   height(void),\n                   width(void);\n\n                   // Read the colour of a pixel at x,y and return value in 565 format\n  virtual uint16_t readPixel(int32_t x, int32_t y);\n\n  virtual void     setWindow(int32_t xs, int32_t ys, int32_t xe, int32_t ye);   // Note: start + end coordinates\n\n                   // Push (aka write pixel) colours to the set window\n  virtual void     pushColor(uint16_t color);\n\n                   // These are non-inlined to enable override\n  virtual void     begin_nin_write();\n  virtual void     end_nin_write();\n\n  void     setRotation(uint8_t r); // Set the display image orientation to 0, 1, 2 or 3\n  uint8_t  getRotation(void);      // Read the current rotation\n\n  // Change the origin position from the default top left\n  // Note: setRotation, setViewport and resetViewport will revert origin to top left corner of screen/sprite\n  void     setOrigin(int32_t x, int32_t y);\n  int32_t  getOriginX(void);\n  int32_t  getOriginY(void);\n\n  void     invertDisplay(bool i);  // Tell TFT to invert all displayed colours\n\n\n  // The TFT_eSprite class inherits the following functions (not all are useful to Sprite class\n  void     setAddrWindow(int32_t xs, int32_t ys, int32_t w, int32_t h); // Note: start coordinates + width and height\n\n  // Viewport commands, see \"Viewport_Demo\" sketch\n  void     setViewport(int32_t x, int32_t y, int32_t w, int32_t h, bool vpDatum = true);\n  bool     checkViewport(int32_t x, int32_t y, int32_t w, int32_t h);\n  int32_t  getViewportX(void);\n  int32_t  getViewportY(void);\n  int32_t  getViewportWidth(void);\n  int32_t  getViewportHeight(void);\n  bool     getViewportDatum(void);\n  void     frameViewport(uint16_t color, int32_t w);\n  void     resetViewport(void);\n\n           // Clip input window to viewport bounds, return false if whole area is out of bounds\n  bool     clipAddrWindow(int32_t* x, int32_t* y, int32_t* w, int32_t* h);\n           // Clip input window area to viewport bounds, return false if whole area is out of bounds\n  bool     clipWindow(int32_t* xs, int32_t* ys, int32_t* xe, int32_t* ye);\n\n           // Push (aka write pixel) colours to the TFT (use setAddrWindow() first)\n  void     pushColor(uint16_t color, uint32_t len),  // Deprecated, use pushBlock()\n           pushColors(uint16_t  *data, uint32_t len, bool swap = true), // With byte swap option\n           pushColors(uint8_t  *data, uint32_t len); // Deprecated, use pushPixels()\n\n           // Write a solid block of a single colour\n  void     pushBlock(uint16_t color, uint32_t len);\n\n           // Write a set of pixels stored in memory, use setSwapBytes(true/false) function to correct endianess\n  void     pushPixels(const void * data_in, uint32_t len);\n\n           // Support for half duplex (bi-directional SDA) SPI bus where MOSI must be switched to input\n           #ifdef TFT_SDA_READ\n             #if defined (TFT_eSPI_ENABLE_8_BIT_READ)\n  uint8_t  tft_Read_8(void);     // Read 8-bit value from TFT command register\n             #endif\n  void     begin_SDA_Read(void); // Begin a read on a half duplex (bi-directional SDA) SPI bus - sets MOSI to input\n  void     end_SDA_Read(void);   // Restore MOSI to output\n           #endif\n\n\n  // Graphics drawing\n  void     fillScreen(uint32_t color),\n           drawRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color),\n           drawRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint32_t color),\n           fillRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint32_t color);\n\n  void     fillRectVGradient(int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color1, uint32_t color2);\n  void     fillRectHGradient(int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color1, uint32_t color2);\n\n  void     drawCircle(int32_t x, int32_t y, int32_t r, uint32_t color),\n           drawCircleHelper(int32_t x, int32_t y, int32_t r, uint8_t cornername, uint32_t color),\n           fillCircle(int32_t x, int32_t y, int32_t r, uint32_t color),\n           fillCircleHelper(int32_t x, int32_t y, int32_t r, uint8_t cornername, int32_t delta, uint32_t color),\n\n           drawEllipse(int16_t x, int16_t y, int32_t rx, int32_t ry, uint16_t color),\n           fillEllipse(int16_t x, int16_t y, int32_t rx, int32_t ry, uint16_t color),\n\n           //                 Corner 1               Corner 2               Corner 3\n           drawTriangle(int32_t x1,int32_t y1, int32_t x2,int32_t y2, int32_t x3,int32_t y3, uint32_t color),\n           fillTriangle(int32_t x1,int32_t y1, int32_t x2,int32_t y2, int32_t x3,int32_t y3, uint32_t color);\n\n\n  // Smooth (anti-aliased) graphics drawing\n           // Draw a pixel blended with the background pixel colour (bg_color) specified,  return blended colour\n           // If the bg_color is not specified, the background pixel colour will be read from TFT or sprite\n  uint16_t drawPixel(int32_t x, int32_t y, uint32_t color, uint8_t alpha, uint32_t bg_color = 0x00FFFFFF);\n\n           // Draw an anti-aliased (smooth) arc between start and end angles. Arc ends are anti-aliased.\n           // By default the arc is drawn with square ends unless the \"roundEnds\" parameter is included and set true\n           // Angle = 0 is at 6 o'clock position, 90 at 9 o'clock etc. The angles must be in range 0-360 or they will be clipped to these limits\n           // The start angle may be larger than the end angle. Arcs are always drawn clockwise from the start angle.\n  void     drawSmoothArc(int32_t x, int32_t y, int32_t r, int32_t ir, uint32_t startAngle, uint32_t endAngle, uint32_t fg_color, uint32_t bg_color, bool roundEnds = false);\n\n           // As per \"drawSmoothArc\" except the ends of the arc are NOT anti-aliased, this facilitates dynamic arc length changes with\n           // arc segments and ensures clean segment joints. \n           // The sides of the arc are anti-aliased by default. If smoothArc is false sides will NOT be anti-aliased\n  void     drawArc(int32_t x, int32_t y, int32_t r, int32_t ir, uint32_t startAngle, uint32_t endAngle, uint32_t fg_color, uint32_t bg_color, bool smoothArc = true);\n\n           // Draw an anti-aliased filled circle at x, y with radius r\n           // Note: The thickness of line is 3 pixels to reduce the visible \"braiding\" effect of anti-aliasing narrow lines\n           //       this means the inner anti-alias zone is always at r-1 and the outer zone at r+1\n  void     drawSmoothCircle(int32_t x, int32_t y, int32_t r, uint32_t fg_color, uint32_t bg_color);\n  \n           // Draw an anti-aliased filled circle at x, y with radius r\n           // If bg_color is not included the background pixel colour will be read from TFT or sprite\n  void     fillSmoothCircle(int32_t x, int32_t y, int32_t r, uint32_t color, uint32_t bg_color = 0x00FFFFFF);\n\n           // Draw a rounded rectangle that has a line thickness of r-ir+1 and bounding box defined by x,y and w,h\n           // The outer corner radius is r, inner corner radius is ir\n           // The inside and outside of the border are anti-aliased\n  void     drawSmoothRoundRect(int32_t x, int32_t y, int32_t r, int32_t ir, int32_t w, int32_t h, uint32_t fg_color, uint32_t bg_color = 0x00FFFFFF, uint8_t quadrants = 0xF);\n\n           // Draw a filled rounded rectangle , corner radius r and bounding box defined by x,y and w,h\n  void     fillSmoothRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint32_t color, uint32_t bg_color = 0x00FFFFFF);\n\n           // Draw a small anti-aliased filled circle at ax,ay with radius r (uses drawWideLine)\n           // If bg_color is not included the background pixel colour will be read from TFT or sprite\n  void     drawSpot(float ax, float ay, float r, uint32_t fg_color, uint32_t bg_color = 0x00FFFFFF);\n\n           // Draw an anti-aliased wide line from ax,ay to bx,by width wd with radiused ends (radius is wd/2)\n           // If bg_color is not included the background pixel colour will be read from TFT or sprite\n  void     drawWideLine(float ax, float ay, float bx, float by, float wd, uint32_t fg_color, uint32_t bg_color = 0x00FFFFFF);\n\n           // Draw an anti-aliased wide line from ax,ay to bx,by with different width at each end aw, bw and with radiused ends\n           // If bg_color is not included the background pixel colour will be read from TFT or sprite\n  void     drawWedgeLine(float ax, float ay, float bx, float by, float aw, float bw, uint32_t fg_color, uint32_t bg_color = 0x00FFFFFF);\n\n\n  // Image rendering\n           // Swap the byte order for pushImage() and pushPixels() - corrects endianness\n  void     setSwapBytes(bool swap);\n  bool     getSwapBytes(void);\n\n           // Draw bitmap\n  void     drawBitmap( int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t fgcolor),\n           drawBitmap( int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t fgcolor, uint16_t bgcolor),\n           drawXBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t fgcolor),\n           drawXBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t fgcolor, uint16_t bgcolor),\n           setBitmapColor(uint16_t fgcolor, uint16_t bgcolor); // Define the 2 colours for 1bpp sprites\n\n           // Set TFT pivot point (use when rendering rotated sprites)\n  void     setPivot(int16_t x, int16_t y);\n  int16_t  getPivotX(void), // Get pivot x\n           getPivotY(void); // Get pivot y\n\n           // The next functions can be used as a pair to copy screen blocks (or horizontal/vertical lines) to another location\n           // Read a block of pixels to a data buffer, buffer is 16-bit and the size must be at least w * h\n  void     readRect(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data);\n           // Write a block of pixels to the screen which have been read by readRect()\n  void     pushRect(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data);\n\n           // These are used to render images or sprites stored in RAM arrays (used by Sprite class for 16bpp Sprites)\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data);\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *data, uint16_t transparent);\n\n           // These are used to render images stored in FLASH (PROGMEM)\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint16_t *data, uint16_t transparent);\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint16_t *data);\n\n           // These are used by Sprite class pushSprite() member function for 1, 4 and 8 bits per pixel (bpp) colours\n           // They are not intended to be used with user sketches (but could be)\n           // Set bpp8 true for 8bpp sprites, false otherwise. The cmap pointer must be specified for 4bpp\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t  *data, bool bpp8 = true, uint16_t *cmap = nullptr);\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t  *data, uint8_t  transparent, bool bpp8 = true, uint16_t *cmap = nullptr);\n           // FLASH version\n  void     pushImage(int32_t x, int32_t y, int32_t w, int32_t h, const uint8_t *data, bool bpp8,  uint16_t *cmap = nullptr);\n\n           // Render a 16-bit colour image with a 1bpp mask\n  void     pushMaskedImage(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t *img, uint8_t *mask);\n\n           // This next function has been used successfully to dump the TFT screen to a PC for documentation purposes\n           // It reads a screen area and returns the 3 RGB 8-bit colour values of each pixel in the buffer\n           // Set w and h to 1 to read 1 pixel's colour. The data buffer must be at least w * h * 3 bytes\n  void     readRectRGB(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t *data);\n\n\n  // Text rendering - value returned is the pixel width of the rendered text\n  int16_t  drawNumber(long intNumber, int32_t x, int32_t y, uint8_t font), // Draw integer using specified font number\n           drawNumber(long intNumber, int32_t x, int32_t y),               // Draw integer using current font\n\n           // Decimal is the number of decimal places to render\n           // Use with setTextDatum() to position values on TFT, and setTextPadding() to blank old displayed values\n           drawFloat(float floatNumber, uint8_t decimal, int32_t x, int32_t y, uint8_t font), // Draw float using specified font number\n           drawFloat(float floatNumber, uint8_t decimal, int32_t x, int32_t y),               // Draw float using current font\n\n           // Handle char arrays\n           // Use with setTextDatum() to position string on TFT, and setTextPadding() to blank old displayed strings\n           drawString(const char *string, int32_t x, int32_t y, uint8_t font),  // Draw string using specified font number\n           drawString(const char *string, int32_t x, int32_t y),                // Draw string using current font\n           drawString(const String& string, int32_t x, int32_t y, uint8_t font),// Draw string using specified font number\n           drawString(const String& string, int32_t x, int32_t y),              // Draw string using current font\n\n           drawCentreString(const char *string, int32_t x, int32_t y, uint8_t font),  // Deprecated, use setTextDatum() and drawString()\n           drawRightString(const char *string, int32_t x, int32_t y, uint8_t font),   // Deprecated, use setTextDatum() and drawString()\n           drawCentreString(const String& string, int32_t x, int32_t y, uint8_t font),// Deprecated, use setTextDatum() and drawString()\n           drawRightString(const String& string, int32_t x, int32_t y, uint8_t font); // Deprecated, use setTextDatum() and drawString()\n\n\n  // Text rendering and font handling support functions\n  void     setCursor(int16_t x, int16_t y),                 // Set cursor for tft.print()\n           setCursor(int16_t x, int16_t y, uint8_t font);   // Set cursor and font number for tft.print()\n\n  int16_t  getCursorX(void),                                // Read current cursor x position (moves with tft.print())\n           getCursorY(void);                                // Read current cursor y position\n\n  void     setTextColor(uint16_t color),                    // Set character (glyph) color only (background not over-written)\n           setTextColor(uint16_t fgcolor, uint16_t bgcolor, bool bgfill = false),  // Set character (glyph) foreground and background colour, optional background fill for smooth fonts\n           setTextSize(uint8_t size);                       // Set character size multiplier (this increases pixel size)\n\n  void     setTextWrap(bool wrapX, bool wrapY = false);     // Turn on/off wrapping of text in TFT width and/or height\n\n  void     setTextDatum(uint8_t datum);                     // Set text datum position (default is top left), see Section 5 above\n  uint8_t  getTextDatum(void);\n\n  void     setTextPadding(uint16_t x_width);                // Set text padding (background blanking/over-write) width in pixels\n  uint16_t getTextPadding(void);                            // Get text padding\n\n#ifdef LOAD_GFXFF\n  void     setFreeFont(const GFXfont *f = NULL),            // Select the GFX Free Font\n           setTextFont(uint8_t font);                       // Set the font number to use in future\n#else\n  void     setFreeFont(uint8_t font),                       // Not used, historical fix to prevent an error\n           setTextFont(uint8_t font);                       // Set the font number to use in future\n#endif\n\n  int16_t  textWidth(const char *string, uint8_t font),     // Returns pixel width of string in specified font\n           textWidth(const char *string),                   // Returns pixel width of string in current font\n           textWidth(const String& string, uint8_t font),   // As above for String types\n           textWidth(const String& string),\n           fontHeight(uint8_t font),                        // Returns pixel height of specified font\n           fontHeight(void);                                // Returns pixel height of current font\n\n           // Used by library and Smooth font class to extract Unicode point codes from a UTF8 encoded string\n  uint16_t decodeUTF8(uint8_t *buf, uint16_t *index, uint16_t remaining),\n           decodeUTF8(uint8_t c);\n\n           // Support function to UTF8 decode and draw characters piped through print stream\n  size_t   write(uint8_t);\n           // size_t   write(const uint8_t *buf, size_t len);\n\n           // Used by Smooth font class to fetch a pixel colour for the anti-aliasing\n  void     setCallback(getColorCallback getCol);\n\n  uint16_t fontsLoaded(void); // Each bit in returned value represents a font type that is loaded - used for debug/error handling only\n\n\n  // Low level read/write\n  void     spiwrite(uint8_t);        // legacy support only\n#ifdef RM68120_DRIVER\n  void     writecommand(uint16_t c);                 // Send a 16-bit command, function resets DC/RS high ready for data\n  void     writeRegister8(uint16_t c, uint8_t d);    // Write 8-bit data data to 16-bit command register\n  void     writeRegister16(uint16_t c, uint16_t d);  // Write 16-bit data data to 16-bit command register\n#else\n  void     writecommand(uint8_t c);  // Send an 8-bit command, function resets DC/RS high ready for data\n#endif\n  void     writedata(uint8_t d);     // Send data with DC/RS set high\n\n  void     commandList(const uint8_t *addr); // Send a initialisation sequence to TFT stored in FLASH\n\n  uint8_t  readcommand8( uint8_t cmd_function, uint8_t index = 0); // read 8 bits from TFT\n  uint16_t readcommand16(uint8_t cmd_function, uint8_t index = 0); // read 16 bits from TFT\n  uint32_t readcommand32(uint8_t cmd_function, uint8_t index = 0); // read 32 bits from TFT\n\n\n  // Colour conversion\n           // Convert 8-bit red, green and blue to 16 bits\n  uint16_t color565(uint8_t red, uint8_t green, uint8_t blue);\n\n           // Convert 8-bit colour to 16 bits\n  uint16_t color8to16(uint8_t color332);\n           // Convert 16-bit colour to 8 bits\n  uint8_t  color16to8(uint16_t color565);\n\n           // Convert 16-bit colour to/from 24-bit, R+G+B concatenated into LS 24 bits\n  uint32_t color16to24(uint16_t color565);\n  uint32_t color24to16(uint32_t color888);\n\n           // Alpha blend 2 colours, see generic \"alphaBlend_Test\" example\n           // alpha =   0 = 100% background colour\n           // alpha = 255 = 100% foreground colour\n  uint16_t alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc);\n\n           // 16-bit colour alphaBlend with alpha dither (dither reduces colour banding)\n  uint16_t alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc, uint8_t dither);\n           // 24-bit colour alphaBlend with optional alpha dither\n  uint32_t alphaBlend24(uint8_t alpha, uint32_t fgc, uint32_t bgc, uint8_t dither = 0);\n\n  // Direct Memory Access (DMA) support functions\n  // These can be used for SPI writes when using the ESP32 (original) or STM32 processors.\n  // DMA also works on a RP2040 processor with PIO based SPI and parallel (8 and 16-bit) interfaces\n           // Bear in mind DMA will only be of benefit in particular circumstances and can be tricky\n           // to manage by noobs. The functions have however been designed to be noob friendly and\n           // avoid a few DMA behaviour \"gotchas\".\n           //\n           // At best you will get a 2x TFT rendering performance improvement when using DMA because\n           // this library handles the SPI bus so efficiently during normal (non DMA) transfers. The best\n           // performance improvement scenario is the DMA transfer time is exactly the same as the time it\n           // takes for the processor to prepare the next image buffer and initiate another DMA transfer.\n           //\n           // DMA transfer to the TFT is done while the processor moves on to handle other tasks. Bear\n           // this in mind and watch out for \"gotchas\" like the image buffer going out of scope as the\n           // processor leaves a function or its content being changed while the DMA engine is reading it.\n           //\n           // The compiler MAY change the implied scope of a buffer which has been set aside by creating\n           // an array. For example a buffer defined before a \"for-next\" loop may get de-allocated when\n           // the loop ends. To avoid this use, for example, malloc() and free() to take control of when\n           // the buffer space is available and ensure it is not released until DMA is complete.\n           //\n           // Clearly you should not modify a buffer that is being DMA'ed to the TFT until the DMA is over.\n           // Use the dmaBusy() function to check this.  Use tft.startWrite() before invoking DMA so the\n           // TFT chip select stays low. If you use tft.endWrite() before DMA is complete then the endWrite\n           // function will wait for the DMA to complete, so this may defeat any DMA performance benefit.\n           //\n\n  bool     initDMA(bool ctrl_cs = false);  // Initialise the DMA engine and attach to SPI bus - typically used in setup()\n                                           // Parameter \"true\" enables DMA engine control of TFT chip select (ESP32 only)\n                                           // For ESP32 only, TFT reads will not work if parameter is true\n  void     deInitDMA(void);   // De-initialise the DMA engine and detach from SPI bus - typically not used\n\n           // Push an image to the TFT using DMA, buffer is optional and grabs (double buffers) a copy of the image\n           // Use the buffer if the image data will get over-written or destroyed while DMA is in progress\n           //\n           // Note 1: If swapping colour bytes is defined, and the double buffer option is NOT used, then the bytes\n           // in the original image buffer content will be byte swapped by the function before DMA is initiated.\n           //\n           // Note 2: If part of the image will be off screen or outside of a set viewport, then the the original\n           // image buffer content will be altered to a correctly clipped image before DMA is initiated.\n           //\n           // The function will wait for the last DMA to complete if it is called while a previous DMA is still\n           // in progress, this simplifies the sketch and helps avoid \"gotchas\".\n  void     pushImageDMA(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t* data, uint16_t* buffer = nullptr);\n\n#if defined (ESP32) // ESP32 only at the moment\n           // For case where pointer is a const and the image data must not be modified (clipped or byte swapped)\n  void     pushImageDMA(int32_t x, int32_t y, int32_t w, int32_t h, uint16_t const* data);\n#endif\n           // Push a block of pixels into a window set up using setAddrWindow()\n  void     pushPixelsDMA(uint16_t* image, uint32_t len);\n\n           // Check if the DMA is complete - use while(tft.dmaBusy); for a blocking wait\n  bool     dmaBusy(void); // returns true if DMA is still in progress\n  void     dmaWait(void); // wait until DMA is complete\n\n  bool     DMA_Enabled = false;   // Flag for DMA enabled state\n  uint8_t  spiBusyCheck = 0;      // Number of ESP32 transfer buffers to check\n\n  // Bare metal functions\n  void     startWrite(void);                         // Begin SPI transaction\n  void     writeColor(uint16_t color, uint32_t len); // Deprecated, use pushBlock()\n  void     endWrite(void);                           // End SPI transaction\n\n  // Set/get an arbitrary library configuration attribute or option\n  //       Use to switch ON/OFF capabilities such as UTF8 decoding - each attribute has a unique ID\n  //       id = 0: reserved - may be used in future to reset all attributes to a default state\n  //       id = 1: Turn on (a=true) or off (a=false) GLCD cp437 font character error correction\n  //       id = 2: Turn on (a=true) or off (a=false) UTF8 decoding\n  //       id = 3: Enable or disable use of ESP32 PSRAM (if available)\n           #define CP437_SWITCH 1\n           #define UTF8_SWITCH  2\n           #define PSRAM_ENABLE 3\n  void     setAttribute(uint8_t id = 0, uint8_t a = 0); // Set attribute value\n  uint8_t  getAttribute(uint8_t id = 0);                // Get attribute value\n\n           // Used for diagnostic sketch to see library setup adopted by compiler, see Section 7 above\n  void     getSetup(setup_t& tft_settings); // Sketch provides the instance to populate\n  bool     verifySetupID(uint32_t id);\n\n  // Global variables\n#if !defined (TFT_PARALLEL_8_BIT) && !defined (RP2040_PIO_INTERFACE)\n  static   SPIClass& getSPIinstance(void); // Get SPI class handle\n#endif\n  uint32_t textcolor, textbgcolor;         // Text foreground and background colours\n\n  uint32_t bitmap_fg, bitmap_bg;           // Bitmap foreground (bit=1) and background (bit=0) colours\n\n  uint8_t  textfont,  // Current selected font number\n           textsize,  // Current font size multiplier\n           textdatum, // Text reference datum\n           rotation;  // Display rotation (0-3)\n\n  uint8_t  decoderState = 0;   // UTF8 decoder state        - not for user access\n  uint16_t decoderBuffer;      // Unicode code-point buffer - not for user access\n\n //--------------------------------------- private ------------------------------------//\n private:\n           // Legacy begin and end prototypes - deprecated TODO: delete\n  void     spi_begin();\n  void     spi_end();\n\n  void     spi_begin_read();\n  void     spi_end_read();\n\n           // New begin and end prototypes\n           // begin/end a TFT write transaction\n           // For SPI bus the transmit clock rate is set\n  inline void begin_tft_write() __attribute__((always_inline));\n  inline void end_tft_write()   __attribute__((always_inline));\n\n           // begin/end a TFT read transaction\n           // For SPI bus: begin lowers SPI clock rate, end reinstates transmit clock rate\n  inline void begin_tft_read()  __attribute__((always_inline));\n  inline void end_tft_read()    __attribute__((always_inline));\n\n           // Initialise the data bus GPIO and hardware interfaces\n  void     initBus(void);\n\n           // Temporary  library development function  TODO: remove need for this\n  void     pushSwapBytePixels(const void* data_in, uint32_t len);\n\n           // Same as setAddrWindow but exits with CGRAM in read mode\n  void     readAddrWindow(int32_t xs, int32_t ys, int32_t w, int32_t h);\n\n           // Byte read prototype\n  uint8_t  readByte(void);\n\n           // GPIO parallel bus input/output direction control\n  void     busDir(uint32_t mask, uint8_t mode);\n\n           // Single GPIO input/output direction control\n  void     gpioMode(uint8_t gpio, uint8_t mode);\n\n           // Smooth graphics helper\n  uint8_t  sqrt_fraction(uint32_t num);\n\n           // Helper function: calculate distance of a point from a finite length line between two points\n  float    wedgeLineDistance(float pax, float pay, float bax, float bay, float dr);\n\n           // Display variant settings\n  uint8_t  tabcolor,                   // ST7735 screen protector \"tab\" colour (now invalid)\n           colstart = 0, rowstart = 0; // Screen display area to CGRAM area coordinate offsets\n\n           // Port and pin masks for control signals (ESP826 only) - TODO: remove need for this\n  volatile uint32_t *dcport, *csport;\n  uint32_t cspinmask, dcpinmask, wrpinmask, sclkpinmask;\n\n           #if defined(ESP32_PARALLEL)\n           // Bit masks for ESP32 parallel bus interface\n  uint32_t xclr_mask, xdir_mask; // Port set/clear and direction control masks\n\n           // Lookup table for ESP32 parallel bus interface uses 1kbyte RAM,\n  uint32_t xset_mask[256]; // Makes Sprite rendering test 33% faster, for slower macro equivalent\n                           // see commented out #define set_mask(C) within TFT_eSPI_ESP32.h\n           #endif\n\n  //uint32_t lastColor = 0xFFFF; // Last colour - used to minimise bit shifting overhead\n\n  getColorCallback getColor = nullptr; // Smooth font callback function pointer\n\n  bool     locked, inTransaction, lockTransaction; // SPI transaction and mutex lock flags\n\n //-------------------------------------- protected ----------------------------------//\n protected:\n\n  //int32_t  win_xe, win_ye;          // Window end coords - not needed\n\n  int32_t  _init_width, _init_height; // Display w/h as input, used by setRotation()\n  int32_t  _width, _height;           // Display w/h as modified by current rotation\n  int32_t  addr_row, addr_col;        // Window position - used to minimise window commands\n\n  int16_t  _xPivot;   // TFT x pivot point coordinate for rotated Sprites\n  int16_t  _yPivot;   // TFT x pivot point coordinate for rotated Sprites\n\n  // Viewport variables\n  int32_t  _vpX, _vpY, _vpW, _vpH;    // Note: x start, y start, x end + 1, y end + 1\n  int32_t  _xDatum;\n  int32_t  _yDatum;\n  int32_t  _xWidth;\n  int32_t  _yHeight;\n  bool     _vpDatum;\n  bool     _vpOoB;\n\n  int32_t  cursor_x, cursor_y, padX;       // Text cursor x,y and padding setting\n  int32_t  bg_cursor_x;                    // Background fill cursor\n  int32_t  last_cursor_x;                  // Previous text cursor position when fill used\n\n  uint32_t fontsloaded;               // Bit field of fonts loaded\n\n  uint8_t  glyph_ab,   // Smooth font glyph delta Y (height) above baseline\n           glyph_bb;   // Smooth font glyph delta Y (height) below baseline\n\n  bool     isDigits;   // adjust bounding box for numbers to reduce visual jiggling\n  bool     textwrapX, textwrapY;  // If set, 'wrap' text at right and optionally bottom edge of display\n  bool     _swapBytes; // Swap the byte order for TFT pushImage()\n\n  bool     _booted;    // init() or begin() has already run once\n\n                       // User sketch manages these via set/getAttribute()\n  bool     _cp437;        // If set, use correct CP437 charset (default is OFF)\n  bool     _utf8;         // If set, use UTF-8 decoder in print stream 'write()' function (default ON)\n  bool     _psram_enable; // Enable PSRAM use for library functions (TBD) and Sprites\n\n  uint32_t _lastColor; // Buffered value of last colour used\n\n  bool     _fillbg;    // Fill background flag (just for for smooth fonts at the moment)\n\n#if defined (SSD1963_DRIVER)\n  uint16_t Cswap;      // Swap buffer for SSD1963\n  uint8_t r6, g6, b6;  // RGB buffer for SSD1963\n#endif\n\n#ifdef LOAD_GFXFF\n  GFXfont  *gfxFont;\n#endif\n\n/***************************************************************************************\n**                         Section 9: TFT_eSPI class conditional extensions\n***************************************************************************************/\n// Load the Touch extension\n#ifdef TOUCH_CS\n  #if defined (TFT_PARALLEL_8_BIT) || defined (RP2040_PIO_INTERFACE)\n    #if !defined(DISABLE_ALL_LIBRARY_WARNINGS)\n      #error >>>>------>> Touch functions not supported in 8/16-bit parallel mode or with RP2040 PIO.\n    #endif\n  #else\n    #include \"Extensions/Touch.h\"        // Loaded if TOUCH_CS is defined by user\n  #endif\n#else\n    #if !defined(DISABLE_ALL_LIBRARY_WARNINGS)\n      #warning >>>>------>> TOUCH_CS pin not defined, TFT_eSPI touch functions will not be available!\n    #endif\n#endif\n\n// Load the Anti-aliased font extension\n#ifdef SMOOTH_FONT\n  #include \"Extensions/Smooth_font.h\"  // Loaded if SMOOTH_FONT is defined by user\n#endif\n\n}; // End of class TFT_eSPI\n\n// Swap any type\ntemplate <typename T> static inline void\ntranspose(T& a, T& b) { T t = a; a = b; b = t; }\n\n// Fast alphaBlend\ntemplate <typename A, typename F, typename B> static inline uint16_t\nfastBlend(A alpha, F fgc, B bgc)\n{\n  // Split out and blend 5-bit red and blue channels\n  uint32_t rxb = bgc & 0xF81F;\n  rxb += ((fgc & 0xF81F) - rxb) * (alpha >> 2) >> 6;\n  // Split out and blend 6-bit green channel\n  uint32_t xgx = bgc & 0x07E0;\n  xgx += ((fgc & 0x07E0) - xgx) * alpha >> 8;\n  // Recombine channels\n  return (rxb & 0xF81F) | (xgx & 0x07E0);\n}\n\n/***************************************************************************************\n**                         Section 10: Additional extension classes\n***************************************************************************************/\n// Load the Button Class\n#include \"Extensions/Button.h\"\n\n// Load the Sprite Class\n#include \"Extensions/Sprite.h\"\n\n#endif // ends #ifndef _TFT_eSPIH_\n"
        },
        {
          "name": "Tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "User_Setup.h",
          "type": "blob",
          "size": 18.1845703125,
          "content": "//                            USER DEFINED SETTINGS\n//   Set driver type, fonts to be loaded, pins used and SPI control method etc.\n//\n//   See the User_Setup_Select.h file if you wish to be able to define multiple\n//   setups and then easily select which setup file is used by the compiler.\n//\n//   If this file is edited correctly then all the library example sketches should\n//   run without the need to make any more changes for a particular hardware setup!\n//   Note that some sketches are designed for a particular TFT pixel width/height\n\n// User defined information reported by \"Read_User_Setup\" test & diagnostics example\n#define USER_SETUP_INFO \"User_Setup\"\n\n// Define to disable all #warnings in library (can be put in User_Setup_Select.h)\n//#define DISABLE_ALL_LIBRARY_WARNINGS\n\n// ##################################################################################\n//\n// Section 1. Call up the right driver file and any options for it\n//\n// ##################################################################################\n\n// Define STM32 to invoke optimised processor support (only for STM32)\n//#define STM32\n\n// Defining the STM32 board allows the library to optimise the performance\n// for UNO compatible \"MCUfriend\" style shields\n//#define NUCLEO_64_TFT\n//#define NUCLEO_144_TFT\n\n// STM32 8-bit parallel only:\n// If STN32 Port A or B pins 0-7 are used for 8-bit parallel data bus bits 0-7\n// then this will improve rendering performance by a factor of ~8x\n//#define STM_PORTA_DATA_BUS\n//#define STM_PORTB_DATA_BUS\n\n// Tell the library to use parallel mode (otherwise SPI is assumed)\n//#define TFT_PARALLEL_8_BIT\n//#defined TFT_PARALLEL_16_BIT // **** 16-bit parallel ONLY for RP2040 processor ****\n\n// Display type -  only define if RPi display\n//#define RPI_DISPLAY_TYPE // 20MHz maximum SPI\n\n// Only define one driver, the other ones must be commented out\n#define ILI9341_DRIVER       // Generic driver for common displays\n//#define ILI9341_2_DRIVER     // Alternative ILI9341 driver, see https://github.com/Bodmer/TFT_eSPI/issues/1172\n//#define ST7735_DRIVER      // Define additional parameters below for this display\n//#define ILI9163_DRIVER     // Define additional parameters below for this display\n//#define S6D02A1_DRIVER\n//#define RPI_ILI9486_DRIVER // 20MHz maximum SPI\n//#define HX8357D_DRIVER\n//#define ILI9481_DRIVER\n//#define ILI9486_DRIVER\n//#define ILI9488_DRIVER     // WARNING: Do not connect ILI9488 display SDO to MISO if other devices share the SPI bus (TFT SDO does NOT tristate when CS is high)\n//#define ST7789_DRIVER      // Full configuration option, define additional parameters below for this display\n//#define ST7789_2_DRIVER    // Minimal configuration option, define additional parameters below for this display\n//#define R61581_DRIVER\n//#define RM68140_DRIVER\n//#define ST7796_DRIVER\n//#define SSD1351_DRIVER\n//#define SSD1963_480_DRIVER\n//#define SSD1963_800_DRIVER\n//#define SSD1963_800ALT_DRIVER\n//#define ILI9225_DRIVER\n//#define GC9A01_DRIVER\n\n// Some displays support SPI reads via the MISO pin, other displays have a single\n// bi-directional SDA pin and the library will try to read this via the MOSI line.\n// To use the SDA line for reading data from the TFT uncomment the following line:\n\n// #define TFT_SDA_READ      // This option is for ESP32 ONLY, tested with ST7789 and GC9A01 display only\n\n// For ST7735, ST7789 and ILI9341 ONLY, define the colour order IF the blue and red are swapped on your display\n// Try ONE option at a time to find the correct colour order for your display\n\n//  #define TFT_RGB_ORDER TFT_RGB  // Colour order Red-Green-Blue\n//  #define TFT_RGB_ORDER TFT_BGR  // Colour order Blue-Green-Red\n\n// For M5Stack ESP32 module with integrated ILI9341 display ONLY, remove // in line below\n\n// #define M5STACK\n\n// For ST7789, ST7735, ILI9163 and GC9A01 ONLY, define the pixel width and height in portrait orientation\n// #define TFT_WIDTH  80\n// #define TFT_WIDTH  128\n// #define TFT_WIDTH  172 // ST7789 172 x 320\n// #define TFT_WIDTH  170 // ST7789 170 x 320\n// #define TFT_WIDTH  240 // ST7789 240 x 240 and 240 x 320\n// #define TFT_HEIGHT 160\n// #define TFT_HEIGHT 128\n// #define TFT_HEIGHT 240 // ST7789 240 x 240\n// #define TFT_HEIGHT 320 // ST7789 240 x 320\n// #define TFT_HEIGHT 240 // GC9A01 240 x 240\n\n// For ST7735 ONLY, define the type of display, originally this was based on the\n// colour of the tab on the screen protector film but this is not always true, so try\n// out the different options below if the screen does not display graphics correctly,\n// e.g. colours wrong, mirror images, or stray pixels at the edges.\n// Comment out ALL BUT ONE of these options for a ST7735 display driver, save this\n// this User_Setup file, then rebuild and upload the sketch to the board again:\n\n// #define ST7735_INITB\n// #define ST7735_GREENTAB\n// #define ST7735_GREENTAB2\n// #define ST7735_GREENTAB3\n// #define ST7735_GREENTAB128    // For 128 x 128 display\n// #define ST7735_GREENTAB160x80 // For 160 x 80 display (BGR, inverted, 26 offset)\n// #define ST7735_ROBOTLCD       // For some RobotLCD Arduino shields (128x160, BGR, https://docs.arduino.cc/retired/getting-started-guides/TFT)\n// #define ST7735_REDTAB\n// #define ST7735_BLACKTAB\n// #define ST7735_REDTAB160x80   // For 160 x 80 display with 24 pixel offset\n\n// If colours are inverted (white shows as black) then uncomment one of the next\n// 2 lines try both options, one of the options should correct the inversion.\n\n// #define TFT_INVERSION_ON\n// #define TFT_INVERSION_OFF\n\n\n// ##################################################################################\n//\n// Section 2. Define the pins that are used to interface with the display here\n//\n// ##################################################################################\n\n// If a backlight control signal is available then define the TFT_BL pin in Section 2\n// below. The backlight will be turned ON when tft.begin() is called, but the library\n// needs to know if the LEDs are ON with the pin HIGH or LOW. If the LEDs are to be\n// driven with a PWM signal or turned OFF/ON then this must be handled by the user\n// sketch. e.g. with digitalWrite(TFT_BL, LOW);\n\n// #define TFT_BL   32            // LED back-light control pin\n// #define TFT_BACKLIGHT_ON HIGH  // Level to turn ON back-light (HIGH or LOW)\n\n\n\n// We must use hardware SPI, a minimum of 3 GPIO pins is needed.\n// Typical setup for ESP8266 NodeMCU ESP-12 is :\n//\n// Display SDO/MISO  to NodeMCU pin D6 (or leave disconnected if not reading TFT)\n// Display LED       to NodeMCU pin VIN (or 5V, see below)\n// Display SCK       to NodeMCU pin D5\n// Display SDI/MOSI  to NodeMCU pin D7\n// Display DC (RS/AO)to NodeMCU pin D3\n// Display RESET     to NodeMCU pin D4 (or RST, see below)\n// Display CS        to NodeMCU pin D8 (or GND, see below)\n// Display GND       to NodeMCU pin GND (0V)\n// Display VCC       to NodeMCU 5V or 3.3V\n//\n// The TFT RESET pin can be connected to the NodeMCU RST pin or 3.3V to free up a control pin\n//\n// The DC (Data Command) pin may be labelled AO or RS (Register Select)\n//\n// With some displays such as the ILI9341 the TFT CS pin can be connected to GND if no more\n// SPI devices (e.g. an SD Card) are connected, in this case comment out the #define TFT_CS\n// line below so it is NOT defined. Other displays such at the ST7735 require the TFT CS pin\n// to be toggled during setup, so in these cases the TFT_CS line must be defined and connected.\n//\n// The NodeMCU D0 pin can be used for RST\n//\n//\n// Note: only some versions of the NodeMCU provide the USB 5V on the VIN pin\n// If 5V is not available at a pin you can use 3.3V but backlight brightness\n// will be lower.\n\n\n// ###### EDIT THE PIN NUMBERS IN THE LINES FOLLOWING TO SUIT YOUR ESP8266 SETUP ######\n\n// For NodeMCU - use pin numbers in the form PIN_Dx where Dx is the NodeMCU pin designation\n#define TFT_MISO  PIN_D6  // Automatically assigned with ESP8266 if not defined\n#define TFT_MOSI  PIN_D7  // Automatically assigned with ESP8266 if not defined\n#define TFT_SCLK  PIN_D5  // Automatically assigned with ESP8266 if not defined\n\n#define TFT_CS    PIN_D8  // Chip select control pin D8\n#define TFT_DC    PIN_D3  // Data Command control pin\n#define TFT_RST   PIN_D4  // Reset pin (could connect to NodeMCU RST, see next line)\n//#define TFT_RST  -1     // Set TFT_RST to -1 if the display RESET is connected to NodeMCU RST or 3.3V\n\n\n//#define TFT_BL PIN_D1  // LED back-light (only for ST7789 with backlight control pin)\n\n//#define TOUCH_CS PIN_D2     // Chip select pin (T_CS) of touch screen\n\n//#define TFT_WR PIN_D2       // Write strobe for modified Raspberry Pi TFT only\n\n\n// ######  FOR ESP8266 OVERLAP MODE EDIT THE PIN NUMBERS IN THE FOLLOWING LINES  ######\n\n// Overlap mode shares the ESP8266 FLASH SPI bus with the TFT so has a performance impact\n// but saves pins for other functions. It is best not to connect MISO as some displays\n// do not tristate that line when chip select is high!\n// Note: Only one SPI device can share the FLASH SPI lines, so a SPI touch controller\n// cannot be connected as well to the same SPI signals.\n// On NodeMCU 1.0 SD0=MISO, SD1=MOSI, CLK=SCLK to connect to TFT in overlap mode\n// On NodeMCU V3  S0 =MISO, S1 =MOSI, S2 =SCLK\n// In ESP8266 overlap mode the following must be defined\n\n//#define TFT_SPI_OVERLAP\n\n// In ESP8266 overlap mode the TFT chip select MUST connect to pin D3\n//#define TFT_CS   PIN_D3\n//#define TFT_DC   PIN_D5  // Data Command control pin\n//#define TFT_RST  PIN_D4  // Reset pin (could connect to NodeMCU RST, see next line)\n//#define TFT_RST  -1  // Set TFT_RST to -1 if the display RESET is connected to NodeMCU RST or 3.3V\n\n\n// ###### EDIT THE PIN NUMBERS IN THE LINES FOLLOWING TO SUIT YOUR ESP32 SETUP   ######\n\n// For ESP32 Dev board (only tested with ILI9341 display)\n// The hardware SPI can be mapped to any pins\n\n//#define TFT_MISO 19\n//#define TFT_MOSI 23\n//#define TFT_SCLK 18\n//#define TFT_CS   15  // Chip select control pin\n//#define TFT_DC    2  // Data Command control pin\n//#define TFT_RST   4  // Reset pin (could connect to RST pin)\n//#define TFT_RST  -1  // Set TFT_RST to -1 if display RESET is connected to ESP32 board RST\n\n// For ESP32 Dev board (only tested with GC9A01 display)\n// The hardware SPI can be mapped to any pins\n\n//#define TFT_MOSI 15 // In some display driver board, it might be written as \"SDA\" and so on.\n//#define TFT_SCLK 14\n//#define TFT_CS   5  // Chip select control pin\n//#define TFT_DC   27  // Data Command control pin\n//#define TFT_RST  33  // Reset pin (could connect to Arduino RESET pin)\n//#define TFT_BL   22  // LED back-light\n\n//#define TOUCH_CS 21     // Chip select pin (T_CS) of touch screen\n\n//#define TFT_WR 22    // Write strobe for modified Raspberry Pi TFT only\n\n// For the M5Stack module use these #define lines\n//#define TFT_MISO 19\n//#define TFT_MOSI 23\n//#define TFT_SCLK 18\n//#define TFT_CS   14  // Chip select control pin\n//#define TFT_DC   27  // Data Command control pin\n//#define TFT_RST  33  // Reset pin (could connect to Arduino RESET pin)\n//#define TFT_BL   32  // LED back-light (required for M5Stack)\n\n// ######       EDIT THE PINs BELOW TO SUIT YOUR ESP32 PARALLEL TFT SETUP        ######\n\n// The library supports 8-bit parallel TFTs with the ESP32, the pin\n// selection below is compatible with ESP32 boards in UNO format.\n// Wemos D32 boards need to be modified, see diagram in Tools folder.\n// Only ILI9481 and ILI9341 based displays have been tested!\n\n// Parallel bus is only supported for the STM32 and ESP32\n// Example below is for ESP32 Parallel interface with UNO displays\n\n// Tell the library to use 8-bit parallel mode (otherwise SPI is assumed)\n//#define TFT_PARALLEL_8_BIT\n\n// The ESP32 and TFT the pins used for testing are:\n//#define TFT_CS   33  // Chip select control pin (library pulls permanently low\n//#define TFT_DC   15  // Data Command control pin - must use a pin in the range 0-31\n//#define TFT_RST  32  // Reset pin, toggles on startup\n\n//#define TFT_WR    4  // Write strobe control pin - must use a pin in the range 0-31\n//#define TFT_RD    2  // Read strobe control pin\n\n//#define TFT_D0   12  // Must use pins in the range 0-31 for the data bus\n//#define TFT_D1   13  // so a single register write sets/clears all bits.\n//#define TFT_D2   26  // Pins can be randomly assigned, this does not affect\n//#define TFT_D3   25  // TFT screen update performance.\n//#define TFT_D4   17\n//#define TFT_D5   16\n//#define TFT_D6   27\n//#define TFT_D7   14\n\n// ######       EDIT THE PINs BELOW TO SUIT YOUR STM32 SPI TFT SETUP        ######\n\n// The TFT can be connected to SPI port 1 or 2\n//#define TFT_SPI_PORT 1 // SPI port 1 maximum clock rate is 55MHz\n//#define TFT_MOSI PA7\n//#define TFT_MISO PA6\n//#define TFT_SCLK PA5\n\n//#define TFT_SPI_PORT 2 // SPI port 2 maximum clock rate is 27MHz\n//#define TFT_MOSI PB15\n//#define TFT_MISO PB14\n//#define TFT_SCLK PB13\n\n// Can use Ardiuno pin references, arbitrary allocation, TFT_eSPI controls chip select\n//#define TFT_CS   D5 // Chip select control pin to TFT CS\n//#define TFT_DC   D6 // Data Command control pin to TFT DC (may be labelled RS = Register Select)\n//#define TFT_RST  D7 // Reset pin to TFT RST (or RESET)\n// OR alternatively, we can use STM32 port reference names PXnn\n//#define TFT_CS   PE11 // Nucleo-F767ZI equivalent of D5\n//#define TFT_DC   PE9  // Nucleo-F767ZI equivalent of D6\n//#define TFT_RST  PF13 // Nucleo-F767ZI equivalent of D7\n\n//#define TFT_RST  -1   // Set TFT_RST to -1 if the display RESET is connected to processor reset\n                        // Use an Arduino pin for initial testing as connecting to processor reset\n                        // may not work (pulse too short at power up?)\n\n// ##################################################################################\n//\n// Section 3. Define the fonts that are to be used here\n//\n// ##################################################################################\n\n// Comment out the #defines below with // to stop that font being loaded\n// The ESP8366 and ESP32 have plenty of memory so commenting out fonts is not\n// normally necessary. If all fonts are loaded the extra FLASH space required is\n// about 17Kbytes. To save FLASH space only enable the fonts you need!\n\n#define LOAD_GLCD   // Font 1. Original Adafruit 8 pixel font needs ~1820 bytes in FLASH\n#define LOAD_FONT2  // Font 2. Small 16 pixel high font, needs ~3534 bytes in FLASH, 96 characters\n#define LOAD_FONT4  // Font 4. Medium 26 pixel high font, needs ~5848 bytes in FLASH, 96 characters\n#define LOAD_FONT6  // Font 6. Large 48 pixel font, needs ~2666 bytes in FLASH, only characters 1234567890:-.apm\n#define LOAD_FONT7  // Font 7. 7 segment 48 pixel font, needs ~2438 bytes in FLASH, only characters 1234567890:-.\n#define LOAD_FONT8  // Font 8. Large 75 pixel font needs ~3256 bytes in FLASH, only characters 1234567890:-.\n//#define LOAD_FONT8N // Font 8. Alternative to Font 8 above, slightly narrower, so 3 digits fit a 160 pixel TFT\n#define LOAD_GFXFF  // FreeFonts. Include access to the 48 Adafruit_GFX free fonts FF1 to FF48 and custom fonts\n\n// Comment out the #define below to stop the SPIFFS filing system and smooth font code being loaded\n// this will save ~20kbytes of FLASH\n#define SMOOTH_FONT\n\n\n// ##################################################################################\n//\n// Section 4. Other options\n//\n// ##################################################################################\n\n// For RP2040 processor and SPI displays, uncomment the following line to use the PIO interface.\n//#define RP2040_PIO_SPI // Leave commented out to use standard RP2040 SPI port interface\n\n// For RP2040 processor and 8 or 16-bit parallel displays:\n// The parallel interface write cycle period is derived from a division of the CPU clock\n// speed so scales with the processor clock. This means that the divider ratio may need\n// to be increased when overclocking. It may also need to be adjusted dependant on the\n// display controller type (ILI94341, HX8357C etc.). If RP2040_PIO_CLK_DIV is not defined\n// the library will set default values which may not suit your display.\n// The display controller data sheet will specify the minimum write cycle period. The\n// controllers often work reliably for shorter periods, however if the period is too short\n// the display may not initialise or graphics will become corrupted.\n// PIO write cycle frequency = (CPU clock/(4 * RP2040_PIO_CLK_DIV))\n//#define RP2040_PIO_CLK_DIV 1 // 32ns write cycle at 125MHz CPU clock\n//#define RP2040_PIO_CLK_DIV 2 // 64ns write cycle at 125MHz CPU clock\n//#define RP2040_PIO_CLK_DIV 3 // 96ns write cycle at 125MHz CPU clock\n\n// For the RP2040 processor define the SPI port channel used (default 0 if undefined)\n//#define TFT_SPI_PORT 1 // Set to 0 if SPI0 pins are used, or 1 if spi1 pins used\n\n// For the STM32 processor define the SPI port channel used (default 1 if undefined)\n//#define TFT_SPI_PORT 2 // Set to 1 for SPI port 1, or 2 for SPI port 2\n\n// Define the SPI clock frequency, this affects the graphics rendering speed. Too\n// fast and the TFT driver will not keep up and display corruption appears.\n// With an ILI9341 display 40MHz works OK, 80MHz sometimes fails\n// With a ST7735 display more than 27MHz may not work (spurious pixels and lines)\n// With an ILI9163 display 27 MHz works OK.\n\n// #define SPI_FREQUENCY   1000000\n// #define SPI_FREQUENCY   5000000\n// #define SPI_FREQUENCY  10000000\n// #define SPI_FREQUENCY  20000000\n#define SPI_FREQUENCY  27000000\n// #define SPI_FREQUENCY  40000000\n// #define SPI_FREQUENCY  55000000 // STM32 SPI1 only (SPI2 maximum is 27MHz)\n// #define SPI_FREQUENCY  80000000\n\n// Optional reduced SPI frequency for reading TFT\n#define SPI_READ_FREQUENCY  20000000\n\n// The XPT2046 requires a lower SPI clock rate of 2.5MHz so we define that here:\n#define SPI_TOUCH_FREQUENCY  2500000\n\n// The ESP32 has 2 free SPI ports i.e. VSPI and HSPI, the VSPI is the default.\n// If the VSPI port is in use and pins are not accessible (e.g. TTGO T-Beam)\n// then uncomment the following line:\n//#define USE_HSPI_PORT\n\n// Comment out the following #define if \"SPI Transactions\" do not need to be\n// supported. When commented out the code size will be smaller and sketches will\n// run slightly faster, so leave it commented out unless you need it!\n\n// Transaction support is needed to work with SD library but not needed with TFT_SdFat\n// Transaction support is required if other SPI devices are connected.\n\n// Transactions are automatically enabled by the library for an ESP32 (to use HAL mutex)\n// so changing it here has no effect\n\n// #define SUPPORT_TRANSACTIONS\n"
        },
        {
          "name": "User_Setup_Select.h",
          "type": "blob",
          "size": 17.13671875,
          "content": "// This header file contains a list of user setup files and defines which one the\n// compiler uses when the IDE performs a Verify/Compile or Upload.\n//\n// Users can create configurations for different boards and TFT displays.\n// This makes selecting between hardware setups easy by \"uncommenting\" one line.\n\n// The advantage of this hardware configuration method is that the examples provided\n// with the library should work with immediately without any other changes being\n// needed. It also improves the portability of users sketches to other hardware\n// configurations and compatible libraries.\n//\n// Create a shortcut to this file on your desktop to permit quick access for editing.\n// Re-compile and upload after making and saving any changes to this file.\n\n// Example User_Setup files are stored in the \"User_Setups\" folder. These can be used\n// unmodified or adapted for a particular hardware configuration.\n\n#ifndef USER_SETUP_LOADED //  Lets PlatformIO users define settings in\n                          //  platformio.ini, see notes in \"Tools\" folder.\n\n///////////////////////////////////////////////////////\n//   User configuration selection lines are below    //\n///////////////////////////////////////////////////////\n\n// Only ONE line below should be uncommented to define your setup.  Add extra lines and files as needed.\n\n#include <User_Setup.h>           // Default setup is root library folder\n\n//#include <User_Setups/Setup1_ILI9341.h>  // Setup file for ESP8266 configured for my ILI9341\n//#include <User_Setups/Setup2_ST7735.h>   // Setup file for ESP8266 configured for my ST7735\n//#include <User_Setups/Setup3_ILI9163.h>  // Setup file for ESP8266 configured for my ILI9163\n//#include <User_Setups/Setup4_S6D02A1.h>  // Setup file for ESP8266 configured for my S6D02A1\n//#include <User_Setups/Setup5_RPi_ILI9486.h>        // Setup file for ESP8266 configured for my stock RPi TFT\n//#include <User_Setups/Setup6_RPi_Wr_ILI9486.h>     // Setup file for ESP8266 configured for my modified RPi TFT\n//#include <User_Setups/Setup7_ST7735_128x128.h>     // Setup file for ESP8266 configured for my ST7735 128x128 display\n//#include <User_Setups/Setup8_ILI9163_128x128.h>    // Setup file for ESP8266 configured for my ILI9163 128x128 display\n//#include <User_Setups/Setup9_ST7735_Overlap.h>     // Setup file for ESP8266 configured for my ST7735\n//#include <User_Setups/Setup10_RPi_touch_ILI9486.h> // Setup file for ESP8266 configured for ESP8266 and RPi TFT with touch\n\n//#include <User_Setups/Setup11_RPi_touch_ILI9486.h> // Setup file configured for ESP32 and RPi TFT with touch\n//#include <User_Setups/Setup12_M5Stack_Basic_Core.h>// Setup file for the ESP32 based M5Stack (Basic Core only)\n//#include <User_Setups/Setup13_ILI9481_Parallel.h>  // Setup file for the ESP32 with parallel bus TFT\n//#include <User_Setups/Setup14_ILI9341_Parallel.h>  // Setup file for the ESP32 with parallel bus TFT\n//#include <User_Setups/Setup15_HX8357D.h>           // Setup file for ESP8266 configured for HX8357D\n//#include <User_Setups/Setup16_ILI9488_Parallel.h>  // Setup file for the ESP32 with parallel bus TFT\n//#include <User_Setups/Setup17_ePaper.h>            // Setup file for ESP8266 and any Waveshare ePaper display\n//#include <User_Setups/Setup18_ST7789.h>            // Setup file for ESP8266 configured for ST7789\n\n//#include <User_Setups/Setup19_RM68140_Parallel.h>\t // Setup file configured for RM68140 with parallel bus\n\n//#include <User_Setups/Setup20_ILI9488.h>           // Setup file for ESP8266 and ILI9488 SPI bus TFT\n//#include <User_Setups/Setup21_ILI9488.h>           // Setup file for ESP32 and ILI9488 SPI bus TFT\n\n//#include <User_Setups/Setup22_TTGO_T4.h>           // Setup file for ESP32 and TTGO T4 version 1.2\n//#include <User_Setups/Setup22_TTGO_T4_v1.3.h>      // Setup file for ESP32 and TTGO T4 version 1.3\n//#include <User_Setups/Setup23_TTGO_TM.h>           // Setup file for ESP32 and TTGO TM ST7789 SPI bus TFT\n//#include <User_Setups/Setup24_ST7789.h>            // Setup file for DSTIKE/ESP32/ESP8266 configured for ST7789 240 x 240\n//#include <User_Setups/Setup25_TTGO_T_Display.h>    // Setup file for ESP32 and TTGO T-Display ST7789V SPI bus TFT\n//#include <User_Setups/Setup26_TTGO_T_Wristband.h>  // Setup file for ESP32 and TTGO T-Wristband ST7735 SPI bus TFT\n\n//#include <User_Setups/Setup27_RPi_ST7796_ESP32.h>    // ESP32   RPi MHS-4.0 inch Display-B\n//#include <User_Setups/Setup28_RPi_ST7796_ESP8266.h>  // ESP8266 RPi MHS-4.0 inch Display-B\n\n//#include <User_Setups/Setup29_ILI9341_STM32.h>          // Setup for Nucleo board\n//#include <User_Setups/Setup30_ILI9341_Parallel_STM32.h> // Setup for Nucleo board and parallel display\n//#include <User_Setups/Setup31_ST7796_Parallel_STM32.h>  // Setup for Nucleo board and parallel display\n//#include <User_Setups/Setup32_ILI9341_STM32F103.h>      // Setup for \"Blue/Black Pill\"\n\n//#include <User_Setups/Setup33_RPi_ILI9486_STM32.h>      // Setup for Nucleo board\n\n//#include <User_Setups/Setup34_ILI9481_Parallel_STM32.h> // Setup for Nucleo board and parallel display\n//#include <User_Setups/Setup35_ILI9341_STM32_Port_Bus.h> // Setup for STM32 port A parallel display\n\n//#include <User_Setups/Setup36_RPi_touch_ST7796.h>      // Setup file configured for ESP32 and RPi ST7796 TFT with touch\n\n//#include <User_Setups/Setup42_ILI9341_ESP32.h>           // Setup file for ESP32 and SPI ILI9341 240x320\n//#include <User_Setups/Setup43_ST7735.h>            // Setup file for ESP8266 & ESP32 configured for my ST7735S 80x160\n//#include <User_Setups/Setup44_TTGO_CameraPlus.h>   // Setup file for ESP32 and TTGO T-CameraPlus ST7789 SPI bus TFT    240x240\n//#include <User_Setups/Setup45_TTGO_T_Watch.h>      // Setup file for ESP32 and TTGO T-Watch ST7789 SPI bus TFT  240x240\n//#include <User_Setups/Setup46_GC9A01_ESP32.h>      // Setup file for ESP32 and GC9A01 SPI bus TFT  240x240\n\n//#include <User_Setups/Setup47_ST7735.h>            // Setup file for ESP32 configured for ST7735 128 x 128 animated eyes\n\n//#include <User_Setups/Setup50_SSD1963_Parallel.h>  // Setup file for ESP32 and SSD1963 TFT display\n\n//#include <User_Setups/Setup51_LilyPi_ILI9481.h>    // Setup file for LilyGo LilyPi with ILI9481 display\n//#include <User_Setups/Setup52_LilyPi_ST7796.h>     // Setup file for LilyGo LilyPi with ST7796 display\n\n//#include <User_Setups/Setup60_RP2040_ILI9341.h>              // Setup file for RP2040 with SPI ILI9341\n//#include <User_Setups/Setup61_RP2040_ILI9341_PIO_SPI.h>      // Setup file for RP2040 with PIO SPI ILI9341\n//#include <User_Setups/Setup62_RP2040_Nano_Connect_ILI9341.h> // Setup file for RP2040 with SPI ILI9341\n\n//#include <User_Setups/Setup66_Seeed_XIAO_Round.h>     // Setup file for Seeed XIAO with GC9A01 240x240\n\n//#include <User_Setups/Setup70_ESP32_S2_ILI9341.h>     // Setup file for ESP32 S2 with SPI ILI9341\n//#include <User_Setups/Setup70b_ESP32_S3_ILI9341.h>    // Setup file for ESP32 S3 with SPI ILI9341\n//#include <User_Setups/Setup70c_ESP32_C3_ILI9341.h>    // Setup file for ESP32 C3 with SPI ILI9341\n//#include <User_Setups/Setup70d_ILI9488_S3_Parallel.h> // Setup file for ESP32 S3 with SPI ILI9488\n\n//#include <User_Setups/Setup71_ESP32_S2_ST7789.h>       // Setup file for ESP32 S2 with ST7789\n//#include <User_Setups/Setup72_ESP32_ST7789_172x320.h>  // Setup file for ESP32 with ST7789 1.47\" 172x320\n\n//#include <User_Setups/Setup100_RP2040_ILI9488_parallel.h> // Setup file for Pico/RP2040 with 8-bit parallel ILI9488\n//#include <User_Setups/Setup101_RP2040_ILI9481_parallel.h> // Setup file for Pico/RP2040 with 8-bit parallel ILI9481\n//#include <User_Setups/Setup102_RP2040_ILI9341_parallel.h> // Setup file for Pico/RP2040 with 8-bit parallel ILI9341\n//#include <User_Setups/Setup103_RP2040_ILI9486_parallel.h> // Setup file for Pico/RP2040 with 8-bit parallel ILI9486\n//#include <User_Setups/Setup104_RP2040_ST7796_parallel.h>  // Setup file for Pico/RP2040 with 8-bit parallel ST7796\n\n//#include <User_Setups/Setup105_RP2040_ST7796_16bit_parallel.h>  // Setup file for RP2040 16-bit parallel display\n//#include <User_Setups/Setup106_RP2040_ILI9481_16bit_parallel.h> // Setup file for RP2040 16-bit parallel display\n//#include <User_Setups/Setup107_RP2040_ILI9341_16bit_parallel.h> // Setup file for RP2040 16-bit parallel display\n//#include <User_Setups/Setup108_RP2040_ST7735.h> // Setup file for Waveshare RP2040 board with onboard ST7735 0.96\" 160x80 display\n\n//#include <User_Setups/Setup135_ST7789.h>           // Setup file for ESP8266 and ST7789 135 x 240 TFT\n\n//#include <User_Setups/Setup136_LilyGo_TTV.h>       // Setup file for ESP32 and Lilygo TTV ST7789 SPI bus TFT  135x240\n//#include <User_Setups/Setup137_LilyGo_TDisplay_RP2040.h>  // Setup file for Lilygo T-Display RP2040 (ST7789 on SPI bus with 135x240 TFT)\n\n//#include <User_Setups/Setup138_Pico_Explorer_Base_RP2040_ST7789.h> // Setup file for Pico Explorer Base by Pimoroni for RP2040 (ST7789 on SPI bus with 240x240 TFT)\n\n//#include <User_Setups/Setup200_GC9A01.h>           // Setup file for ESP32 and GC9A01 240 x 240 TFT\n\n//#include <User_Setups/Setup201_WT32_SC01.h>        // Setup file for ESP32 based WT32_SC01 from Seeed\n\n//#include <User_Setups/Setup202_SSD1351_128.h>      // Setup file for ESP32/ESP8266 based SSD1351 128x128 1.5inch OLED display\n\n//#include <User_Setups/Setup203_ST7789.h>     // Setup file for ESP32/ESP8266 based ST7789 240X280 1.69inch TFT \n\n//#include <User_Setups/Setup204_ESP32_TouchDown.h>     // Setup file for the ESP32 TouchDown based on ILI9488 480 x 320 TFT \n\n//#include <User_Setups/Setup205_ESP32_TouchDown_S3.h>     // Setup file for the ESP32 TouchDown S3 based on ILI9488 480 x 320 TFT \n\n//#include <User_Setups/Setup206_LilyGo_T_Display_S3.h>     // For the LilyGo T-Display S3 based ESP32S3 with ST7789 170 x 320 TFT\n//#include <User_Setups/Setup207_LilyGo_T_HMI.h>            // For the LilyGo T-HMI S3 based ESP32S3 with ST7789 240 x 320 TFT\n//#include <User_Setups/Setup209_LilyGo_T_Dongle_S3.h>      // For the LilyGo T-Dongle S3 based ESP32 with ST7735 80 x 160 TFT\n//#include <User_Setups/Setup210_LilyGo_T_Embed_S3.h>         // For the LilyGo T-Embed S3 based ESP32S3 with ST7789 170 x 320 TFT\n//#include <User_Setups/Setup211_LilyGo_T_QT_Pro_S3.h>         // For the LilyGo T-QT Pro S3 based ESP32S3 with GC9A01 128 x 128 TFT\n// #include <User_Setups/Setup212_LilyGo_T_PicoPro.h>         // For the LilyGo T-PICO-Pro with ST7796 222 x 480 TFT\n// #include <User_Setups/Setup213_LilyGo_T_Beam_Shield.h>         // For the LilyGo T-BEAM V1.x with ST7796 222 x 480 TFT\n\n//#include <User_Setups/Setup250_ESP32_S3_Box_Lite.h>      // For the ESP32 S3 Box Lite\n//#include <User_Setups/Setup251_ESP32_S3_Box.h>            // For the ESP32 S3 Box\n\n//#include <User_Setups/Setup301_BW16_ST7735.h>            // Setup file for Bw16-based boards with ST7735 160 x 80 TFT\n//#include <User_Setups/Setup302_Waveshare_ESP32S3_GC9A01.h>            // Setup file for Waveshare ESP32-S3-Touch-LCD-1.28 board with GC9A01 240*240 TFT\n\n//#include <User_Setups/SetupX_Template.h>     // Template file for a setup\n\n\n//#include <User_Setups/Dustin_ILI9488.h>          // Setup file for Dustin Watts PCB with ILI9488\n//#include <User_Setups/Dustin_ST7796.h>           // Setup file for Dustin Watts PCB with ST7796\n//#include <User_Setups/Dustin_ILI9488_Pico.h>     // Setup file for Dustin Watts Pico PCB with ST7796\n//#include <User_Setups/Dustin_ST7789_Pico.h>      // Setup file for Dustin Watts PCB with ST7789 240 x 240 on 3.3V adapter board\n//#include <User_Setups/Dustin_GC9A01_Pico.h>      // Setup file for Dustin Watts PCB with GC9A01 240 x 240 on 3.3V adapter board\n//#include <User_Setups/Dustin_GC9A01_ESP32.h>     // Setup file for Dustin Watts PCB with GC9A01 240 x 240 on 3.3V adapter board\n//#include <User_Setups/Dustin_STT7789_ESP32.h>    // Setup file for Dustin Watts PCB with ST7789 240 x 240 on 3.3V adapter board\n//#include <User_Setups/Dustin_ILI9341_ESP32.h>    // Setup file for Dustin Watts PCB with ILI9341\n//#include <User_Setups/ILI9225.h>\n\n#endif // USER_SETUP_LOADED\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n//     DON'T TINKER WITH ANY OF THE FOLLOWING LINES, THESE ADD THE TFT DRIVERS     //\n//       AND ESP8266 PIN DEFINITONS, THEY ARE HERE FOR BODMER'S CONVENIENCE!       //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n\n\n// Identical looking TFT displays may have a different colour ordering in the 16-bit colour\n#define TFT_BGR 0   // Colour order Blue-Green-Red\n#define TFT_RGB 1   // Colour order Red-Green-Blue\n\n// Legacy setup support, RPI_DISPLAY_TYPE replaces RPI_DRIVER\n#if defined (RPI_DRIVER)\n  #if !defined (RPI_DISPLAY_TYPE)\n    #define RPI_DISPLAY_TYPE\n  #endif\n#endif\n\n// Legacy setup support, RPI_ILI9486_DRIVER form is deprecated\n// Instead define RPI_DISPLAY_TYPE and also define driver (e.g. ILI9486_DRIVER) \n#if defined (RPI_ILI9486_DRIVER)\n  #if !defined (ILI9486_DRIVER)\n    #define ILI9486_DRIVER\n  #endif\n  #if !defined (RPI_DISPLAY_TYPE)\n    #define RPI_DISPLAY_TYPE\n  #endif\n#endif\n\n// Invoke 18-bit colour for selected displays\n#if !defined (RPI_DISPLAY_TYPE) && !defined (TFT_PARALLEL_8_BIT) && !defined (TFT_PARALLEL_16_BIT) && !defined (ESP32_PARALLEL)\n  #if defined (ILI9481_DRIVER) || defined (ILI9486_DRIVER) || defined (ILI9488_DRIVER)\n    #define SPI_18BIT_DRIVER\n  #endif\n#endif\n\n// Load the right driver definition - do not tinker here !\n#if   defined (ILI9341_DRIVER) || defined(ILI9341_2_DRIVER) || defined (ILI9342_DRIVER)\n     #include <TFT_Drivers/ILI9341_Defines.h>\n     #define  TFT_DRIVER 0x9341\n#elif defined (ST7735_DRIVER)\n     #include <TFT_Drivers/ST7735_Defines.h>\n     #define  TFT_DRIVER 0x7735\n#elif defined (ILI9163_DRIVER)\n     #include <TFT_Drivers/ILI9163_Defines.h>\n     #define  TFT_DRIVER 0x9163\n#elif defined (S6D02A1_DRIVER)\n     #include <TFT_Drivers/S6D02A1_Defines.h>\n     #define  TFT_DRIVER 0x6D02\n#elif defined (ST7796_DRIVER)\n      #include \"TFT_Drivers/ST7796_Defines.h\"\n      #define  TFT_DRIVER 0x7796\n#elif defined (ILI9486_DRIVER)\n     #include <TFT_Drivers/ILI9486_Defines.h>\n     #define  TFT_DRIVER 0x9486\n#elif defined (ILI9481_DRIVER)\n     #include <TFT_Drivers/ILI9481_Defines.h>\n     #define  TFT_DRIVER 0x9481\n#elif defined (ILI9488_DRIVER)\n     #include <TFT_Drivers/ILI9488_Defines.h>\n     #define  TFT_DRIVER 0x9488\n#elif defined (HX8357D_DRIVER)\n     #include \"TFT_Drivers/HX8357D_Defines.h\"\n     #define  TFT_DRIVER 0x8357\n#elif defined (EPD_DRIVER)\n     #include \"TFT_Drivers/EPD_Defines.h\"\n     #define  TFT_DRIVER 0xE9D\n#elif defined (ST7789_DRIVER)\n     #include \"TFT_Drivers/ST7789_Defines.h\"\n     #define  TFT_DRIVER 0x7789\n#elif defined (R61581_DRIVER)\n     #include \"TFT_Drivers/R61581_Defines.h\"\n     #define  TFT_DRIVER 0x6158\n#elif defined (ST7789_2_DRIVER)\n     #include \"TFT_Drivers/ST7789_2_Defines.h\"\n     #define  TFT_DRIVER 0x778B\n#elif defined (RM68140_DRIVER)\n     #include \"TFT_Drivers/RM68140_Defines.h\"\n     #define  TFT_DRIVER 0x6814\n#elif defined (SSD1351_DRIVER)\n     #include \"TFT_Drivers/SSD1351_Defines.h\"\n     #define  TFT_DRIVER 0x1351\n#elif defined (SSD1963_480_DRIVER)\n     #include \"TFT_Drivers/SSD1963_Defines.h\"\n     #define  TFT_DRIVER 0x1963\n#elif defined (SSD1963_800_DRIVER)\n     #include \"TFT_Drivers/SSD1963_Defines.h\"\n     #define  TFT_DRIVER 0x1963\n#elif defined (SSD1963_800ALT_DRIVER)\n     #include \"TFT_Drivers/SSD1963_Defines.h\"\n     #define  TFT_DRIVER 0x1963\n#elif defined (SSD1963_800BD_DRIVER)\n     #include \"TFT_Drivers/SSD1963_Defines.h\"\n     #define  TFT_DRIVER 0x1963\n#elif defined (GC9A01_DRIVER)\n     #include \"TFT_Drivers/GC9A01_Defines.h\"\n     #define  TFT_DRIVER 0x9A01\n#elif defined (ILI9225_DRIVER)\n     #include \"TFT_Drivers/ILI9225_Defines.h\"\n     #define  TFT_DRIVER 0x9225\n#elif defined (RM68120_DRIVER)\n     #include \"TFT_Drivers/RM68120_Defines.h\"\n     #define  TFT_DRIVER 0x6812\n#elif defined (HX8357B_DRIVER)\n     #include \"TFT_Drivers/HX8357B_Defines.h\"\n     #define  TFT_DRIVER 0x835B\n#elif defined (HX8357C_DRIVER)\n     #include \"TFT_Drivers/HX8357C_Defines.h\"\n     #define  TFT_DRIVER 0x835C\n\n                              // <<<<<<<<<<<<<<<<<<<<<<<< ADD NEW DRIVER HERE\n                              // XYZZY_init.h and XYZZY_rotation.h must also be added in TFT_eSPI.cpp\n#elif defined (XYZZY_DRIVER)\n     #include \"TFT_Drivers/XYZZY_Defines.h\"\n     #define  TFT_DRIVER 0x0000\n#else\n     #define  TFT_DRIVER 0x0000\n#endif\n\n// These are the pins for ESP8266 boards\n//      Name   GPIO    NodeMCU      Function\n#define PIN_D0  16  // GPIO16       WAKE\n#define PIN_D1   5  // GPIO5        User purpose\n#define PIN_D2   4  // GPIO4        User purpose\n#define PIN_D3   0  // GPIO0        Low on boot means enter FLASH mode\n#define PIN_D4   2  // GPIO2        TXD1 (must be high on boot to go to UART0 FLASH mode)\n#define PIN_D5  14  // GPIO14       HSCLK\n#define PIN_D6  12  // GPIO12       HMISO\n#define PIN_D7  13  // GPIO13       HMOSI  RXD2\n#define PIN_D8  15  // GPIO15       HCS    TXD0 (must be low on boot to enter UART0 FLASH mode)\n#define PIN_D9   3  //              RXD0\n#define PIN_D10  1  //              TXD0\n\n#define PIN_MOSI 8  // SD1          FLASH and overlap mode\n#define PIN_MISO 7  // SD0\n#define PIN_SCLK 6  // CLK\n#define PIN_HWCS 0  // D3\n\n#define PIN_D11  9  // SD2\n#define PIN_D12 10  // SD4\n"
        },
        {
          "name": "User_Setups",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 3.6630859375,
          "content": "# TFT_eSPI core library\n\nTFT_eSPI\tKEYWORD1\n\nbegin\tKEYWORD2\ninit\tKEYWORD2\ndrawPixel\tKEYWORD2\ndrawChar\tKEYWORD2\ndrawLine\tKEYWORD2\ndrawFastVLine\tKEYWORD2\ndrawFastHLine\tKEYWORD2\nfillRect\tKEYWORD2\nheight\tKEYWORD2\nwidth\tKEYWORD2\nreadPixel\tKEYWORD2\nsetWindow\tKEYWORD2\npushColor\tKEYWORD2\n\nsetRotation\tKEYWORD2\ngetRotation\tKEYWORD2\nsetOrigin\tKEYWORD2\ngetOriginX\tKEYWORD2\ngetOriginY\tKEYWORD2\ninvertDisplay\tKEYWORD2\nsetAddrWindow\tKEYWORD2\n\nsetViewport\tKEYWORD2\ncheckViewport\tKEYWORD2\nresetViewport\tKEYWORD2\ngetViewportX\tKEYWORD2\ngetViewportY\tKEYWORD2\ngetViewportWidth\tKEYWORD2\ngetViewportHeight\tKEYWORD2\ngetViewportDatum\tKEYWORD2\nframeViewport\tKEYWORD2\nresetViewport\tKEYWORD2\nclipAddrWindow\tKEYWORD2\nclipWindow\tKEYWORD2\npushColors\tKEYWORD2\npushBlock\tKEYWORD2\npushPixels\tKEYWORD2\n\ntft_Read_8\tKEYWORD2\nbegin_SDA_Read\tKEYWORD2\nend_SDA_Read\tKEYWORD2\n\nfillScreen\tKEYWORD2\n\ndrawRect\tKEYWORD2\nfillRectHGradient\tKEYWORD2\nfillRectVGradient\tKEYWORD2\ndrawRoundRect\tKEYWORD2\nfillRoundRect\tKEYWORD2\n\ndrawCircle\tKEYWORD2\ndrawCircleHelper\tKEYWORD2\nfillCircle\tKEYWORD2\nfillCircleHelper\tKEYWORD2\ndrawEllipse\tKEYWORD2\nfillEllipse\tKEYWORD2\ndrawTriangle\tKEYWORD2\nfillTriangle\tKEYWORD2\n\nsetSwapBytes\tKEYWORD2\ngetSwapBytes\tKEYWORD2\n\ndrawBitmap\tKEYWORD2\ndrawXBitmap\tKEYWORD2\n\nsetPivot\tKEYWORD2\ngetPivotX\tKEYWORD2\ngetPivotY\tKEYWORD2\n\nreadRect\tKEYWORD2\npushRect\tKEYWORD2\npushImage\tKEYWORD2\npushMaskedImage\tKEYWORD2\nreadRectRGB\tKEYWORD2\n\ndrawNumber\tKEYWORD2\ndrawFloat\tKEYWORD2\ndrawString\tKEYWORD2\ndrawCentreString\tKEYWORD2\ndrawRightString\tKEYWORD2\n\nsetCursor\tKEYWORD2\ngetCursorX\tKEYWORD2\ngetCursorY\tKEYWORD2\nsetTextColor\tKEYWORD2\nsetTextSize\tKEYWORD2\nsetTextWrap\tKEYWORD2\nsetTextDatum\tKEYWORD2\ngetTextDatum\tKEYWORD2\nsetTextPadding\tKEYWORD2\ngetTextPadding\tKEYWORD2\nsetFreeFont\tKEYWORD2\nsetTextFont\tKEYWORD2\ntextWidth\tKEYWORD2\nfontHeight\tKEYWORD2\ndecodeUTF8\tKEYWORD2\nwrite\tKEYWORD2\nsetCallback\tKEYWORD2\nfontsLoaded\tKEYWORD2\n\nspiwrite\tKEYWORD2\nwritecommand\tKEYWORD2\nwriteRegister\tKEYWORD2\nwritedata\tKEYWORD2\ncommandList\tKEYWORD2\nreadcommand8\tKEYWORD2\nreadcommand16\tKEYWORD2\nreadcommand32\tKEYWORD2\n\ncolor565\tKEYWORD2\ncolor8to16\tKEYWORD2\ncolor16to8\tKEYWORD2\ncolor16to24\tKEYWORD2\ncolor24to16\tKEYWORD2\nalphaBlend\tKEYWORD2\nalphaBlend24\tKEYWORD2\n\ninitDMA\tKEYWORD2\ndeInitDMA\tKEYWORD2\npushImageDMA\tKEYWORD2\npushPixelsDMA\tKEYWORD2\ndmaBusy\tKEYWORD2\ndmaWait\tKEYWORD2\n\nstartWrite\tKEYWORD2\nwriteColor\tKEYWORD2\nendWrite\tKEYWORD2\n\nsetAttribute\tKEYWORD2\ngetAttribute\tKEYWORD2\ngetSetup\tKEYWORD2\ngetSPIinstance\tKEYWORD2\n\n\n# Touch functions\n\ngetTouchRaw\tKEYWORD2\ngetTouchRawZ\tKEYWORD2\nconvertRawXY\tKEYWORD2\ngetTouch\tKEYWORD2\ncalibrateTouch\tKEYWORD2\nsetTouch\tKEYWORD2\n\n# Smooth (anti-aliased) graphics functions\ndrawSmoothCircle\tKEYWORD2\nfillSmoothCircle\tKEYWORD2\ndrawSmoothRoundRect\tKEYWORD2\nfillSmoothRoundRect\tKEYWORD2\ndrawSmoothArc\tKEYWORD2\ndrawArc\tKEYWORD2\ndrawSpot\tKEYWORD2\ndrawWideLine\tKEYWORD2\ndrawWedgeLine\tKEYWORD2\n\n# Smooth font functions\n\nloadFont\tKEYWORD2\nunloadFont\tKEYWORD2\ngetUnicodeIndex\tKEYWORD2\nshowFont\tKEYWORD2\n\n\n# Button class\n\nTFT_eSPI_Button\tKEYWORD1\n\ninitButton\tKEYWORD2\ninitButtonUL\tKEYWORD2\nsetLabelDatum\tKEYWORD2\ndrawButton\tKEYWORD2\ncontains\tKEYWORD2\npress\tKEYWORD2\nisPressed\tKEYWORD2\njustPressed\tKEYWORD2\njustReleased\tKEYWORD2\n\n\n# Sprite class\n\nTFT_eSprite\tKEYWORD1\n\ncreateSprite\tKEYWORD2\ngetPointer\tKEYWORD2\ncreated\tKEYWORD2\ndeleteSprite\tKEYWORD2\nframeBuffer\tKEYWORD2\nsetColorDepth\tKEYWORD2\ngetColorDepth\tKEYWORD2\ncreatePalette\tKEYWORD2\nsetPaletteColor\tKEYWORD2\ngetPaletteColor\tKEYWORD2\nsetBitmapColor\tKEYWORD2\nfillSprite\tKEYWORD2\nsetScrollRect\tKEYWORD2\nscroll\tKEYWORD2\npushRotated\tKEYWORD2\nsetPivot\tKEYWORD2\ngetPivotX\tKEYWORD2\ngetPivotY\tKEYWORD2\ngetRotatedBounds\tKEYWORD2\nreadPixelValue\tKEYWORD2\npushToSprite\tKEYWORD2\ndrawGlyph\tKEYWORD2\nprintToSprite\tKEYWORD2\npushSprite\tKEYWORD2\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.828125,
          "content": "{\n  \"name\": \"TFT_eSPI\",\n  \"version\": \"2.5.43\",\n  \"keywords\": \"Arduino, tft, display, ttgo, LilyPi, WT32-SC01, ePaper, display, Pico, RP2040 Nano Connect, RP2040, STM32, ESP8266, NodeMCU, ESP32, M5Stack, ILI9341, ST7735, ILI9163, S6D02A1, ILI9481, ILI9486, ILI9488, ST7789, ST7796, RM68140, SSD1351, SSD1963, ILI9225, HX8357D, GC9A01, R61581\",\n  \"description\": \"A TFT and ePaper (SPI or parallel interface) graphics library with optimisation for Raspberry Pi Pico, RP2040, ESP8266, ESP32 and STM32 processors\",\n  \"repository\":\n  {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Bodmer/TFT_eSPI\"\n  },\n  \"authors\":\n  [\n    {\n        \"name\": \"Bodmer\",\n        \"email\": \"bodmer@anola.net\",\n        \"maintainer\": true\n    }\n  ],\n  \"frameworks\": \"arduino\",\n  \"platforms\": \"raspberrypi, espressif8266, espressif32, ststm32\",\n  \"headers\": \"TFT_eSPI.h\"\n}\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.37890625,
          "content": "name=TFT_eSPI\nversion=2.5.43\nauthor=Bodmer\nmaintainer=Bodmer\nsentence=TFT graphics library for Arduino processors with performance optimisation for RP2040, STM32, ESP8266 and ESP32\nparagraph=Supports TFT displays using drivers (ILI9341 etc.) that operate with hardware SPI or 8/16-bit parallel.\ncategory=Display\nurl=https://github.com/Bodmer/TFT_eSPI\narchitectures=*\nincludes=TFT_eSPI.h\n\n"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 6.0966796875,
          "content": "The original starting point for this library was the Adafruit_ILI9341\nlibrary in January 2015.\n\nThe licence for that library is MIT.\n\nThe first evolution of the library that led to TFT_eSPI is recorded here:\n\nhttps://www.instructables.com/id/Arduino-TFT-display-and-font-library/\n\nAdafruit_ILI9341 ORIGINAL LIBRARY HEADER:\n\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvStartvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n  This is our library for the Adafruit  ILI9341 Breakout and Shield\n  ----> http://www.adafruit.com/products/1651\n\n  Check out the links above for our tutorials and wiring diagrams\n  These displays use SPI to communicate, 4 or 5 pins are required to\n  interface (RST is optional)\n  Adafruit invests time and resources providing this open source code,\n  please support Adafruit and open-source hardware by purchasing\n  products from Adafruit!\n\n  Written by Limor Fried/Ladyada for Adafruit Industries.\n  MIT license, all text above must be included in any redistribution\n  \n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^End^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nSelected functions from the Adafruit_GFX library (as it was in 2015) have\nbeen imported into the TFT_eSPI.cpp file and modified to improve\nperformance, add features and make them compatible with the ESP8266 and\nESP32.\n\nThe fonts from the Adafruit_GFX and Button functions were added later.\nThe fonts can be found with the license.txt file in the \"Fonts\\GFXFF\"\nfolder.\n\nThe Adafruit_GFX functions are covered by the BSD licence.\n\nAdafruit_GFX ORIGINAL LIBRARY LICENSE:\n\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvStartvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2012 Adafruit Industries.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^End^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDue to the evolution of the TFT_eSPI library the original code may no longer\nbe recognisable, however in most cases the function names can be used as a\nreference point since the aim is to retain a level of compatibility with\nthe popular Adafruit_GFX graphics functions.\n\nContributions from other authors are recorded on GitHub:\nhttps://github.com/Bodmer/TFT_eSPI\n\nThe major addition to the original library was the addition of fast\nrendering proportional fonts of different sizes as documented here:\n\nhttps://www.instructables.com/id/Arduino-TFT-display-and-font-library/\n\nThe larger fonts are \"Run Length Encoded (RLE)\", this was done to\nreduce the font memory footprint for AVR processors that have limited\nFLASH, with the added benefit of a significant improvement in rendering\nspeed.\n\nIn 2016 the library evolved significantly to support the ESP8266 and then\nthe ESP32. In 2017 new Touch Screen functions were added and a new Sprite\nclass called TFT_eSprite to permit \"flicker free\" screen updates of complex\ngraphics.\n\nIn 2018 anti-aliased fonts were added along with a Processing font conversion\nsketch.\n\nIn 2019 the library was adapted to be able to use it with any 32-bit Arduino\ncompatible processor. It will run on 8-bit and 16-bit processors but will be\nslow due to extensive use of 32-bit variables.\n\nMany of the example sketches are original work that contain code created\nfor my own projects. For all the original code the FreeBSD licence applies\nand is compatible with the GNU GPL.\n\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvStartvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\nSoftware License Agreement (FreeBSD License)\n\nCopyright (c) 2023 Bodmer (https://github.com/Bodmer)\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of the FreeBSD Project.\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^End^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
        }
      ]
    }
  ]
}