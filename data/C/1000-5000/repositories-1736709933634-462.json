{
  "metadata": {
    "timestamp": 1736709933634,
    "page": 462,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "abrasive/shairport",
      "stars": 2442,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": "/shairport\n/*.o\n/config.mk\n/config.h\n/version.h\n"
        },
        {
          "name": "LICENSES",
          "type": "blob",
          "size": 1.57421875,
          "content": "alac.c:\n    Copyright (c) 2005, David Hammerton\n    All rights reserved.\n    see alac.c for full license text\n\ngetopt_long.c, getopt_long.h:\n    Portions Copyright (c) 1987, 1993, 1994\n    The Regents of the University of California.  All rights reserved.\n    Portions Copyright (c) 2003\n    PostgreSQL Global Development Group\n    see getopt_long.[ch] for full license text\n\ntinysvcmdns.c, tinysvcmdns.h:\n    Copyright (C) 2011 Darell Tan\n    All rights reserved.\n    see tinysvcmdns.[ch] for full license text\n\n\nShairport:\n    Copyright (c) 2011-2013 James Laird <jhl@mafipulation.org>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.404296875,
          "content": "ifeq ($(wildcard config.mk),)\n$(warning config.mk does not exist, configuring.)\nconfig.mk:\n\tsh ./configure\n\t$(MAKE) shairport\nendif\n\nCFLAGS ?= -O2 -Wall\n-include config.mk\n\nPREFIX ?= /usr/local\n\nSRCS := shairport.c daemon.c rtsp.c mdns.c mdns_external.c mdns_tinysvcmdns.c common.c rtp.c metadata.c player.c alac.c audio.c audio_dummy.c audio_pipe.c tinysvcmdns.c\nDEPS := config.mk alac.h audio.h common.h daemon.h getopt_long.h mdns.h metadata.h player.h rtp.h rtsp.h tinysvcmdns.h\n\nifdef CONFIG_SNDIO\nSRCS += audio_sndio.c\nendif\n\nifdef CONFIG_AO\nSRCS += audio_ao.c\nendif\n\nifdef CONFIG_PULSE\nSRCS += audio_pulse.c\nendif\n\nifdef CONFIG_ALSA\nSRCS += audio_alsa.c\nendif\n\nifdef CONFIG_AVAHI\nSRCS += mdns_avahi.c\nendif\n\nifdef CONFIG_HAVE_DNS_SD_H\nSRCS += mdns_dns_sd.c\nendif\n\nifndef CONFIG_HAVE_GETOPT_H\nSRCS += getopt_long.c\nendif\n\n# default target\nall: shairport\n\ninstall: shairport\n\tinstall -m 755 -d $(PREFIX)/bin\n\tinstall -m 755 shairport $(PREFIX)/bin/shairport\n\nGITREV=$(shell git describe --always)\nDIRTY:=$(shell if ! git diff --quiet --exit-code; then echo -dirty; fi)\nVERSION=\\\"$(GITREV)$(DIRTY)\\\"\n__version_file:\n\t@if [ ! -f version.h -o \"`cat .version 2>/dev/null`\" != '$(VERSION)' ]; then \\\n\t\techo $(VERSION) > version.h; \\\n\tfi\n\n%.o: %.c $(DEPS)\n\t$(CC) -c $(CFLAGS) $<\n\nshairport.o: __version_file\n\nOBJS := $(SRCS:.c=.o)\nshairport: $(OBJS)\n\t$(CC) $(OBJS) $(LDFLAGS) -o shairport\n\nclean:\n\trm -f shairport version.h\n\trm -f $(OBJS)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.1162109375,
          "content": "ShairPort is no longer maintained\n=========\n\nAs I no longer use Shairport myself, I am no longer maintaining or supporting Shairport.\nThanks to everyone who has contributed over the years; it's been a great experience.\nFor the ongoing user, there are a great many forks and ports to choose from now, many of which are of a very high quality and well maintained.\n\n— James\n\nShairPort\n---------\n\nBy [James Laird](mailto:jhl@mafipulation.org) ([announcement](http://mafipulation.org/blagoblig/2011/04/08#shairport))\n\nWhat it is\n----------\nThis program emulates an AirPort Express for the purpose of streaming music from iTunes and compatible iPods and iPhones. It implements a server for the Apple RAOP protocol.\nShairPort does not support AirPlay v2 (video and photo streaming).\n\nBuild Requirements\n------------------\nRequired:\n* OpenSSL\n\nOptionally:\n* libao\n* PulseAudio\n* avahi\n\nDebian/Raspbian users can get the basics with\n`apt-get install libssl-dev libavahi-client-dev libasound2-dev`\n\n\nRuntime Requirements\n--------------------\nYou must be running an mDNS (Bonjour) daemon. On a Mac, this will be running already. Otherwise, you must be running avahi-daemon or Howl.\nAs an alternative, you may use the tinysvcmdns backend, which embeds a lightweight mDNS daemon. It is, however, way less robust than bonjour or avahi.\nCheck the [mDNS Backends] section for more information.\n\nHow to get started\n-------------\n```\n./configure\nmake\n./shairport -a 'My Shairport Name'\n```\n\nThe triangle-in-rectangle AirTunes (now AirPlay) logo will appear in the iTunes status bar of any machine on the network, or on iPod/iPhone play controls screen. Choose your access point name to start streaming to the ShairPort instance.\n\nAudio Outputs\n-------------\nShairport supports different audio backends.\nFor a list of available backends and their options, run `shairport -h`.\nNote that options are supplied to backends at the end of the commandline, separated by --, for example:\n```\nshairport -o ao -- -d mydriver -o setting=thing\n```\n\nmDNS Backends\n-------------\nShairport uses mDNS to advertise the service. Multiple backends are available to perform the task.\nFor a list of available backends, run `shairport -h`.\nThe backends prefixed by 'external' rely on external programs that should be present in your path.\nBy default, shairport will try all backends, in the order they are listed by `shairport -h`, until one works.\nYou can force the use of a specific backend using `shairport -m tinysvcmdns` for example.\n\nMetadata\n--------\n\nThe following metadata can be output for the currently playing track:\n\n  * artist\n  * title\n  * album\n  * artwork\n  * genre\n  * comment\n\nTo enable the output of metadata, the `-M <directory name>` flag must be set to\ninstruct `shairport` where to save the output. This directory must exist. A\nfifo named `now_playing` will be created, and records will be written to it\nwhen tracks are changed. The end of a set of metadata is delimited by a\nzero-length line. Cover filenames are relative to the cover directory. Files\nare not deleted.\n\nAn example::\n\n    artist=Arcade Fire\n    title=City With No Children\n    album=The Suburbs\n    artwork=cover-e6450a45ab900815e831434f5ee0499c.jpg\n    genre=Rock\n    comment=\n    \n\nThanks\n------\nBig thanks to David Hammerton for releasing an ALAC decoder, which is reproduced here in full.\nThanks to everyone who has worked to reverse engineer the RAOP protocol - after finding the keys, everything else was pretty much trivial.\nThanks also to Apple for obfuscating the private key in the ROM image, using a scheme that made the deobfuscation code itself stand out like a flare.\nThanks to Ten Thousand Free Men and their Families for having a computer and stuff.\nThanks to wtbw.\n\nContributors to version 1.x\n---------------------------\n* [James Laird](http://mafipulation.org)\n* [Paul Lietar](http://www.lietar.net/~paul)\n* [Quentin Smart](http://github.com/sm3rt)\n* [Brendan Shanks](http://github.com/mrpippy)\n* [Peter Körner](http://mazdermind.de)\n* [Muffinman](http://github.com/therealmuffin)\n* [Skaman](http://github.com/skaman)\n* [Weston](http://github.com/wnielson)\n* [allesblinkt](http://github.com/allesblinkt)\n\nContributors to version 0.x\n---------------------------\n* [James Laird](mailto:jhl@mafipulation.org), author\n* [David Hammerton](http://craz.net/), ALAC decoder\n* [Albert Zeyer](http://www.az2000.de), maintainer\n* [Preston Marshall](mailto:preston@synergyeoc.com)\n* [Mads Mætzke Tandrup](mailto:mads@tandrup.org)\n* [Martin Spasov](mailto:mspasov@gmail.com)\n* [Oleg Kertanov](mailto:okertanov@gmail.com)\n* [Rafał Kwaśny](mailto:mag@entropy.be)\n* [Rakuraku Jyo](mailto:jyo.rakuraku@gmail.com)\n* [Vincent Gijsen](mailto:vtj.gijsen@gmail.com)\n* [lars](mailto:lars@namsral.com)\n* [Stuart Shelton](https://blog.stuart.shelton.me/)\n* [Andrew Webster](mailto:andywebs@gmail.com)\n\nKnown Ports and Tools\n---------------------\n* Java:\n    * [JAirPort](https://github.com/froks/JAirPort)\n    * [RPlay](https://github.com/bencall/RPlay)\n* Windows:\n    * [shairport4w](http://sf.net/projects/shairport4w)\n* OS X:\n    * [ShairportMenu](https://github.com/rcarlsen/ShairPortMenu), a GUI wrapper as a menu widget\n    * [MacShairport](https://github.com/joshaber/MacShairport)\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.1396484375,
          "content": "- documentation\n  - Ubuntu/Debian packages needed for compile\n  - usage\n  - different audio backend detailed docs?\n- initscript, launchd plist\n"
        },
        {
          "name": "alac.c",
          "type": "blob",
          "size": 34.94921875,
          "content": "/*\n * ALAC (Apple Lossless Audio Codec) decoder\n * Copyright (c) 2005 David Hammerton\n * All rights reserved.\n *\n * This is the actual decoder.\n *\n * http://crazney.net/programs/itunes/alac.html\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\nstatic const int host_bigendian = 0;\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef _WIN32\n    #include \"stdint_win.h\"\n#else\n    #include <stdint.h>\n#endif\n\n#include \"alac.h\"\n\n#define _Swap32(v) do { \\\n                   v = (((v) & 0x000000FF) << 0x18) | \\\n                       (((v) & 0x0000FF00) << 0x08) | \\\n                       (((v) & 0x00FF0000) >> 0x08) | \\\n                       (((v) & 0xFF000000) >> 0x18); } while(0)\n\n#define _Swap16(v) do { \\\n                   v = (((v) & 0x00FF) << 0x08) | \\\n                       (((v) & 0xFF00) >> 0x08); } while (0)\n\nstruct {signed int x:24;} se_struct_24;\n#define SignExtend24(val) (se_struct_24.x = val)\n\nvoid alac_free(alac_file *alac) {\n    if (alac->predicterror_buffer_a)\n        free(alac->predicterror_buffer_a);\n    if (alac->predicterror_buffer_b)\n        free(alac->predicterror_buffer_b);\n\n    if (alac->outputsamples_buffer_a)\n        free(alac->outputsamples_buffer_a);\n    if (alac->outputsamples_buffer_b)\n        free(alac->outputsamples_buffer_b);\n\n    if (alac->uncompressed_bytes_buffer_a)\n        free(alac->uncompressed_bytes_buffer_a);\n    if (alac->uncompressed_bytes_buffer_b)\n        free(alac->uncompressed_bytes_buffer_b);\n\n    free(alac);\n}\n\nvoid alac_allocate_buffers(alac_file *alac)\n{\n    alac->predicterror_buffer_a = malloc(alac->setinfo_max_samples_per_frame * 4);\n    alac->predicterror_buffer_b = malloc(alac->setinfo_max_samples_per_frame * 4);\n\n    alac->outputsamples_buffer_a = malloc(alac->setinfo_max_samples_per_frame * 4);\n    alac->outputsamples_buffer_b = malloc(alac->setinfo_max_samples_per_frame * 4);\n\n    alac->uncompressed_bytes_buffer_a = malloc(alac->setinfo_max_samples_per_frame * 4);\n    alac->uncompressed_bytes_buffer_b = malloc(alac->setinfo_max_samples_per_frame * 4);\n}\n\nvoid alac_set_info(alac_file *alac, char *inputbuffer)\n{\n  char *ptr = inputbuffer;\n  ptr += 4; /* size */\n  ptr += 4; /* frma */\n  ptr += 4; /* alac */\n  ptr += 4; /* size */\n  ptr += 4; /* alac */\n\n  ptr += 4; /* 0 ? */\n\n  alac->setinfo_max_samples_per_frame = *(uint32_t*)ptr; /* buffer size / 2 ? */\n  if (!host_bigendian)\n      _Swap32(alac->setinfo_max_samples_per_frame);\n  ptr += 4;\n  alac->setinfo_7a = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_sample_size = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_rice_historymult = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_rice_initialhistory = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_rice_kmodifier = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_7f = *(uint8_t*)ptr;\n  ptr += 1;\n  alac->setinfo_80 = *(uint16_t*)ptr;\n  if (!host_bigendian)\n      _Swap16(alac->setinfo_80);\n  ptr += 2;\n  alac->setinfo_82 = *(uint32_t*)ptr;\n  if (!host_bigendian)\n      _Swap32(alac->setinfo_82);\n  ptr += 4;\n  alac->setinfo_86 = *(uint32_t*)ptr;\n  if (!host_bigendian)\n      _Swap32(alac->setinfo_86);\n  ptr += 4;\n  alac->setinfo_8a_rate = *(uint32_t*)ptr;\n  if (!host_bigendian)\n      _Swap32(alac->setinfo_8a_rate);\n\n  alac_allocate_buffers(alac);\n\n}\n\n/* stream reading */\n\n/* supports reading 1 to 16 bits, in big endian format */\nstatic uint32_t readbits_16(alac_file *alac, int bits)\n{\n    uint32_t result;\n    int new_accumulator;\n\n    result = (alac->input_buffer[0] << 16) |\n             (alac->input_buffer[1] << 8) |\n             (alac->input_buffer[2]);\n\n    /* shift left by the number of bits we've already read,\n     * so that the top 'n' bits of the 24 bits we read will\n     * be the return bits */\n    result = result << alac->input_buffer_bitaccumulator;\n\n    result = result & 0x00ffffff;\n\n    /* and then only want the top 'n' bits from that, where\n     * n is 'bits' */\n    result = result >> (24 - bits);\n\n    new_accumulator = (alac->input_buffer_bitaccumulator + bits);\n\n    /* increase the buffer pointer if we've read over n bytes. */\n    alac->input_buffer += (new_accumulator >> 3);\n\n    /* and the remainder goes back into the bit accumulator */\n    alac->input_buffer_bitaccumulator = (new_accumulator & 7);\n\n    return result;\n}\n\n/* supports reading 1 to 32 bits, in big endian format */\nstatic uint32_t readbits(alac_file *alac, int bits)\n{\n    int32_t result = 0;\n\n    if (bits > 16)\n    {\n        bits -= 16;\n        result = readbits_16(alac, 16) << bits;\n    }\n\n    result |= readbits_16(alac, bits);\n\n    return result;\n}\n\n/* reads a single bit */\nstatic int readbit(alac_file *alac)\n{\n    int result;\n    int new_accumulator;\n\n    result = alac->input_buffer[0];\n\n    result = result << alac->input_buffer_bitaccumulator;\n\n    result = result >> 7 & 1;\n\n    new_accumulator = (alac->input_buffer_bitaccumulator + 1);\n\n    alac->input_buffer += (new_accumulator / 8);\n\n    alac->input_buffer_bitaccumulator = (new_accumulator % 8);\n\n    return result;\n}\n\nstatic void unreadbits(alac_file *alac, int bits)\n{\n    int new_accumulator = (alac->input_buffer_bitaccumulator - bits);\n\n    alac->input_buffer += (new_accumulator >> 3);\n\n    alac->input_buffer_bitaccumulator = (new_accumulator & 7);\n    if (alac->input_buffer_bitaccumulator < 0)\n        alac->input_buffer_bitaccumulator *= -1;\n}\n\n/* various implementations of count_leading_zero:\n * the first one is the original one, the simplest and most\n * obvious for what it's doing. never use this.\n * then there are the asm ones. fill in as necessary\n * and finally an unrolled and optimised c version\n * to fall back to\n */\n#if 0\n/* hideously inefficient. could use a bitmask search,\n * alternatively bsr on x86,\n */\nstatic int count_leading_zeros(int32_t input)\n{\n    int i = 0;\n    while (!(0x80000000 & input) && i < 32)\n    {\n        i++;\n        input = input << 1;\n    }\n    return i;\n}\n#elif defined(__GNUC__)\n/* for some reason the unrolled version (below) is\n * actually faster than this. yay intel!\n */\nstatic int count_leading_zeros(int input)\n{\n    return __builtin_clz(input);\n}\n#elif defined(_MSC_VER) && defined(_M_IX86)\nstatic int count_leading_zeros(int input)\n{\n    int output = 0;\n    if (!input) return 32;\n    __asm\n    {\n        mov eax, input;\n        mov edx, 0x1f;\n        bsr ecx, eax;\n        sub edx, ecx;\n        mov output, edx;\n    }\n    return output;\n}\n#else\n#warning using generic count leading zeroes. You may wish to write one for your CPU / compiler\nstatic int count_leading_zeros(int input)\n{\n    int output = 0;\n    int curbyte = 0;\n\n    curbyte = input >> 24;\n    if (curbyte) goto found;\n    output += 8;\n\n    curbyte = input >> 16;\n    if (curbyte & 0xff) goto found;\n    output += 8;\n\n    curbyte = input >> 8;\n    if (curbyte & 0xff) goto found;\n    output += 8;\n\n    curbyte = input;\n    if (curbyte & 0xff) goto found;\n    output += 8;\n\n    return output;\n\nfound:\n    if (!(curbyte & 0xf0))\n    {\n        output += 4;\n    }\n    else\n        curbyte >>= 4;\n\n    if (curbyte & 0x8)\n        return output;\n    if (curbyte & 0x4)\n        return output + 1;\n    if (curbyte & 0x2)\n        return output + 2;\n    if (curbyte & 0x1)\n        return output + 3;\n\n    /* shouldn't get here: */\n    return output + 4;\n}\n#endif\n\n#define RICE_THRESHOLD 8 // maximum number of bits for a rice prefix.\n\nstatic int32_t entropy_decode_value(alac_file* alac,\n                             int readSampleSize,\n                             int k,\n                             int rice_kmodifier_mask)\n{\n    int32_t x = 0; // decoded value\n\n    // read x, number of 1s before 0 represent the rice value.\n    while (x <= RICE_THRESHOLD && readbit(alac))\n    {\n        x++;\n    }\n\n    if (x > RICE_THRESHOLD)\n    {\n        // read the number from the bit stream (raw value)\n        int32_t value;\n\n        value = readbits(alac, readSampleSize);\n\n        // mask value\n        value &= (((uint32_t)0xffffffff) >> (32 - readSampleSize));\n\n        x = value;\n    }\n    else\n    {\n        if (k != 1)\n        {\n            int extraBits = readbits(alac, k);\n\n            // x = x * (2^k - 1)\n            x *= (((1 << k) - 1) & rice_kmodifier_mask);\n\n            if (extraBits > 1)\n                x += extraBits - 1;\n            else\n                unreadbits(alac, 1);\n        }\n    }\n\n    return x;\n}\n\nstatic void entropy_rice_decode(alac_file* alac,\n                         int32_t* outputBuffer,\n                         int outputSize,\n                         int readSampleSize,\n                         int rice_initialhistory,\n                         int rice_kmodifier,\n                         int rice_historymult,\n                         int rice_kmodifier_mask)\n{\n    int             outputCount;\n    int             history = rice_initialhistory;\n    int             signModifier = 0;\n\n    for (outputCount = 0; outputCount < outputSize; outputCount++)\n    {\n        int32_t     decodedValue;\n        int32_t     finalValue;\n        int32_t     k;\n\n        k = 31 - rice_kmodifier - count_leading_zeros((history >> 9) + 3);\n\n        if (k < 0) k += rice_kmodifier;\n        else k = rice_kmodifier;\n\n        // note: don't use rice_kmodifier_mask here (set mask to 0xFFFFFFFF)\n        decodedValue = entropy_decode_value(alac, readSampleSize, k, 0xFFFFFFFF);\n\n        decodedValue += signModifier;\n        finalValue = (decodedValue + 1) / 2; // inc by 1 and shift out sign bit\n        if (decodedValue & 1) // the sign is stored in the low bit\n            finalValue *= -1;\n\n        outputBuffer[outputCount] = finalValue;\n\n        signModifier = 0;\n\n        // update history\n        history += (decodedValue * rice_historymult)\n                - ((history * rice_historymult) >> 9);\n\n        if (decodedValue > 0xFFFF)\n            history = 0xFFFF;\n\n        // special case, for compressed blocks of 0\n        if ((history < 128) && (outputCount + 1 < outputSize))\n        {\n            int32_t     blockSize;\n\n            signModifier = 1;\n\n            k = count_leading_zeros(history) + ((history + 16) / 64) - 24;\n\n            // note: blockSize is always 16bit\n            blockSize = entropy_decode_value(alac, 16, k, rice_kmodifier_mask);\n\n            // got blockSize 0s\n            if (blockSize > 0)\n            {\n                memset(&outputBuffer[outputCount + 1], 0, blockSize * sizeof(*outputBuffer));\n                outputCount += blockSize;\n            }\n\n            if (blockSize > 0xFFFF)\n                signModifier = 0;\n\n            history = 0;\n        }\n    }\n}\n\n#define SIGN_EXTENDED32(val, bits) ((val << (32 - bits)) >> (32 - bits))\n\n#define SIGN_ONLY(v) \\\n                     ((v < 0) ? (-1) : \\\n                                ((v > 0) ? (1) : \\\n                                           (0)))\n\nstatic void predictor_decompress_fir_adapt(int32_t *error_buffer,\n                                           int32_t *buffer_out,\n                                           int output_size,\n                                           int readsamplesize,\n                                           int16_t *predictor_coef_table,\n                                           int predictor_coef_num,\n                                           int predictor_quantitization)\n{\n    int i;\n\n    /* first sample always copies */\n    *buffer_out = *error_buffer;\n\n    if (!predictor_coef_num)\n    {\n        if (output_size <= 1) return;\n        memcpy(buffer_out+1, error_buffer+1, (output_size-1) * 4);\n        return;\n    }\n\n    if (predictor_coef_num == 0x1f) /* 11111 - max value of predictor_coef_num */\n    { /* second-best case scenario for fir decompression,\n       * error describes a small difference from the previous sample only\n       */\n        if (output_size <= 1) return;\n        for (i = 0; i < output_size - 1; i++)\n        {\n            int32_t prev_value;\n            int32_t error_value;\n\n            prev_value = buffer_out[i];\n            error_value = error_buffer[i+1];\n            buffer_out[i+1] = SIGN_EXTENDED32((prev_value + error_value), readsamplesize);\n        }\n        return;\n    }\n\n    /* read warm-up samples */\n    if (predictor_coef_num > 0)\n    {\n        int i;\n        for (i = 0; i < predictor_coef_num; i++)\n        {\n            int32_t val;\n\n            val = buffer_out[i] + error_buffer[i+1];\n\n            val = SIGN_EXTENDED32(val, readsamplesize);\n\n            buffer_out[i+1] = val;\n        }\n    }\n\n#if 0\n    /* 4 and 8 are very common cases (the only ones i've seen). these\n     * should be unrolled and optimised\n     */\n    if (predictor_coef_num == 4)\n    {\n        /* FIXME: optimised general case */\n        return;\n    }\n\n    if (predictor_coef_table == 8)\n    {\n        /* FIXME: optimised general case */\n        return;\n    }\n#endif\n\n\n    /* general case */\n    if (predictor_coef_num > 0)\n    {\n        for (i = predictor_coef_num + 1;\n             i < output_size;\n             i++)\n        {\n            int j;\n            int sum = 0;\n            int outval;\n            int error_val = error_buffer[i];\n\n            for (j = 0; j < predictor_coef_num; j++)\n            {\n                sum += (buffer_out[predictor_coef_num-j] - buffer_out[0]) *\n                       predictor_coef_table[j];\n            }\n\n            outval = (1 << (predictor_quantitization-1)) + sum;\n            outval = outval >> predictor_quantitization;\n            outval = outval + buffer_out[0] + error_val;\n            outval = SIGN_EXTENDED32(outval, readsamplesize);\n\n            buffer_out[predictor_coef_num+1] = outval;\n\n            if (error_val > 0)\n            {\n                int predictor_num = predictor_coef_num - 1;\n\n                while (predictor_num >= 0 && error_val > 0)\n                {\n                    int val = buffer_out[0] - buffer_out[predictor_coef_num - predictor_num];\n                    int sign = SIGN_ONLY(val);\n\n                    predictor_coef_table[predictor_num] -= sign;\n\n                    val *= sign; /* absolute value */\n\n                    error_val -= ((val >> predictor_quantitization) *\n                                  (predictor_coef_num - predictor_num));\n\n                    predictor_num--;\n                }\n            }\n            else if (error_val < 0)\n            {\n                int predictor_num = predictor_coef_num - 1;\n\n                while (predictor_num >= 0 && error_val < 0)\n                {\n                    int val = buffer_out[0] - buffer_out[predictor_coef_num - predictor_num];\n                    int sign = - SIGN_ONLY(val);\n\n                    predictor_coef_table[predictor_num] -= sign;\n\n                    val *= sign; /* neg value */\n\n                    error_val -= ((val >> predictor_quantitization) *\n                                  (predictor_coef_num - predictor_num));\n\n                    predictor_num--;\n                }\n            }\n\n            buffer_out++;\n        }\n    }\n}\n\nstatic void deinterlace_16(int32_t *buffer_a, int32_t *buffer_b,\n                    int16_t *buffer_out,\n                    int numchannels, int numsamples,\n                    uint8_t interlacing_shift,\n                    uint8_t interlacing_leftweight)\n{\n    int i;\n    if (numsamples <= 0) return;\n\n    /* weighted interlacing */\n    if (interlacing_leftweight)\n    {\n        for (i = 0; i < numsamples; i++)\n        {\n            int32_t difference, midright;\n            int16_t left;\n            int16_t right;\n\n            midright = buffer_a[i];\n            difference = buffer_b[i];\n\n\n            right = midright - ((difference * interlacing_leftweight) >> interlacing_shift);\n            left = right + difference;\n\n            /* output is always little endian */\n            if (host_bigendian)\n            {\n                _Swap16(left);\n                _Swap16(right);\n            }\n\n            buffer_out[i*numchannels] = left;\n            buffer_out[i*numchannels + 1] = right;\n        }\n\n        return;\n    }\n\n    /* otherwise basic interlacing took place */\n    for (i = 0; i < numsamples; i++)\n    {\n        int16_t left, right;\n\n        left = buffer_a[i];\n        right = buffer_b[i];\n\n        /* output is always little endian */\n        if (host_bigendian)\n        {\n            _Swap16(left);\n            _Swap16(right);\n        }\n\n        buffer_out[i*numchannels] = left;\n        buffer_out[i*numchannels + 1] = right;\n    }\n}\n\nstatic void deinterlace_24(int32_t *buffer_a, int32_t *buffer_b,\n                    int uncompressed_bytes,\n                    int32_t *uncompressed_bytes_buffer_a, int32_t *uncompressed_bytes_buffer_b,\n                    void *buffer_out,\n                    int numchannels, int numsamples,\n                    uint8_t interlacing_shift,\n                    uint8_t interlacing_leftweight)\n{\n    int i;\n    if (numsamples <= 0) return;\n\n    /* weighted interlacing */\n    if (interlacing_leftweight)\n    {\n        for (i = 0; i < numsamples; i++)\n        {\n            int32_t difference, midright;\n            int32_t left;\n            int32_t right;\n\n            midright = buffer_a[i];\n            difference = buffer_b[i];\n\n            right = midright - ((difference * interlacing_leftweight) >> interlacing_shift);\n            left = right + difference;\n\n            if (uncompressed_bytes)\n            {\n                uint32_t mask = ~(0xFFFFFFFF << (uncompressed_bytes * 8));\n                left <<= (uncompressed_bytes * 8);\n                right <<= (uncompressed_bytes * 8);\n\n                left |= uncompressed_bytes_buffer_a[i] & mask;\n                right |= uncompressed_bytes_buffer_b[i] & mask;\n            }\n\n            ((uint8_t*)buffer_out)[i * numchannels * 3] = (left) & 0xFF;\n            ((uint8_t*)buffer_out)[i * numchannels * 3 + 1] = (left >> 8) & 0xFF;\n            ((uint8_t*)buffer_out)[i * numchannels * 3 + 2] = (left >> 16) & 0xFF;\n\n            ((uint8_t*)buffer_out)[i * numchannels * 3 + 3] = (right) & 0xFF;\n            ((uint8_t*)buffer_out)[i * numchannels * 3 + 4] = (right >> 8) & 0xFF;\n            ((uint8_t*)buffer_out)[i * numchannels * 3 + 5] = (right >> 16) & 0xFF;\n        }\n\n        return;\n    }\n\n    /* otherwise basic interlacing took place */\n    for (i = 0; i < numsamples; i++)\n    {\n        int32_t left, right;\n\n        left = buffer_a[i];\n        right = buffer_b[i];\n\n        if (uncompressed_bytes)\n        {\n            uint32_t mask = ~(0xFFFFFFFF << (uncompressed_bytes * 8));\n            left <<= (uncompressed_bytes * 8);\n            right <<= (uncompressed_bytes * 8);\n\n            left |= uncompressed_bytes_buffer_a[i] & mask;\n            right |= uncompressed_bytes_buffer_b[i] & mask;\n        }\n\n        ((uint8_t*)buffer_out)[i * numchannels * 3] = (left) & 0xFF;\n        ((uint8_t*)buffer_out)[i * numchannels * 3 + 1] = (left >> 8) & 0xFF;\n        ((uint8_t*)buffer_out)[i * numchannels * 3 + 2] = (left >> 16) & 0xFF;\n\n        ((uint8_t*)buffer_out)[i * numchannels * 3 + 3] = (right) & 0xFF;\n        ((uint8_t*)buffer_out)[i * numchannels * 3 + 4] = (right >> 8) & 0xFF;\n        ((uint8_t*)buffer_out)[i * numchannels * 3 + 5] = (right >> 16) & 0xFF;\n\n    }\n\n}\n\nvoid alac_decode_frame(alac_file *alac,\n                       unsigned char *inbuffer,\n                       void *outbuffer, int *outputsize)\n{\n    int channels;\n    int32_t outputsamples = alac->setinfo_max_samples_per_frame;\n\n    /* setup the stream */\n    alac->input_buffer = inbuffer;\n    alac->input_buffer_bitaccumulator = 0;\n\n    channels = readbits(alac, 3);\n\n    *outputsize = outputsamples * alac->bytespersample;\n\n    switch(channels)\n    {\n    case 0: /* 1 channel */\n    {\n        int hassize;\n        int isnotcompressed;\n        int readsamplesize;\n\n        int uncompressed_bytes;\n        int ricemodifier;\n\n        /* 2^result = something to do with output waiting.\n         * perhaps matters if we read > 1 frame in a pass?\n         */\n        readbits(alac, 4);\n\n        readbits(alac, 12); /* unknown, skip 12 bits */\n\n        hassize = readbits(alac, 1); /* the output sample size is stored soon */\n\n        uncompressed_bytes = readbits(alac, 2); /* number of bytes in the (compressed) stream that are not compressed */\n\n        isnotcompressed = readbits(alac, 1); /* whether the frame is compressed */\n\n        if (hassize)\n        {\n            /* now read the number of samples,\n             * as a 32bit integer */\n            outputsamples = readbits(alac, 32);\n            *outputsize = outputsamples * alac->bytespersample;\n        }\n\n        readsamplesize = alac->setinfo_sample_size - (uncompressed_bytes * 8);\n\n        if (!isnotcompressed)\n        { /* so it is compressed */\n            int16_t predictor_coef_table[32];\n            int predictor_coef_num;\n            int prediction_type;\n            int prediction_quantitization;\n            int i;\n\n            /* skip 16 bits, not sure what they are. seem to be used in\n             * two channel case */\n            readbits(alac, 8);\n            readbits(alac, 8);\n\n            prediction_type = readbits(alac, 4);\n            prediction_quantitization = readbits(alac, 4);\n\n            ricemodifier = readbits(alac, 3);\n            predictor_coef_num = readbits(alac, 5);\n\n            /* read the predictor table */\n            for (i = 0; i < predictor_coef_num; i++)\n            {\n                predictor_coef_table[i] = (int16_t)readbits(alac, 16);\n            }\n\n            if (uncompressed_bytes)\n            {\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    alac->uncompressed_bytes_buffer_a[i] = readbits(alac, uncompressed_bytes * 8);\n                }\n            }\n\n            entropy_rice_decode(alac,\n                                alac->predicterror_buffer_a,\n                                outputsamples,\n                                readsamplesize,\n                                alac->setinfo_rice_initialhistory,\n                                alac->setinfo_rice_kmodifier,\n                                ricemodifier * alac->setinfo_rice_historymult / 4,\n                                (1 << alac->setinfo_rice_kmodifier) - 1);\n\n            if (prediction_type == 0)\n            { /* adaptive fir */\n                predictor_decompress_fir_adapt(alac->predicterror_buffer_a,\n                                               alac->outputsamples_buffer_a,\n                                               outputsamples,\n                                               readsamplesize,\n                                               predictor_coef_table,\n                                               predictor_coef_num,\n                                               prediction_quantitization);\n            }\n            else\n            {\n                fprintf(stderr, \"FIXME: unhandled predicition type: %i\\n\", prediction_type);\n                /* i think the only other prediction type (or perhaps this is just a\n                 * boolean?) runs adaptive fir twice.. like:\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n                 * little strange..\n                 */\n            }\n\n        }\n        else\n        { /* not compressed, easy case */\n            if (alac->setinfo_sample_size <= 16)\n            {\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    int32_t audiobits = readbits(alac, alac->setinfo_sample_size);\n\n                    audiobits = SIGN_EXTENDED32(audiobits, alac->setinfo_sample_size);\n\n                    alac->outputsamples_buffer_a[i] = audiobits;\n                }\n            }\n            else\n            {\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    int32_t audiobits;\n\n                    audiobits = readbits(alac, 16);\n                    /* special case of sign extension..\n                     * as we'll be ORing the low 16bits into this */\n                    audiobits = audiobits << (alac->setinfo_sample_size - 16);\n                    audiobits |= readbits(alac, alac->setinfo_sample_size - 16);\n                    audiobits = SignExtend24(audiobits);\n\n                    alac->outputsamples_buffer_a[i] = audiobits;\n                }\n            }\n            uncompressed_bytes = 0; // always 0 for uncompressed\n        }\n\n        switch(alac->setinfo_sample_size)\n        {\n        case 16:\n        {\n            int i;\n            for (i = 0; i < outputsamples; i++)\n            {\n                int16_t sample = alac->outputsamples_buffer_a[i];\n                if (host_bigendian)\n                    _Swap16(sample);\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n            }\n            break;\n        }\n        case 24:\n        {\n            int i;\n            for (i = 0; i < outputsamples; i++)\n            {\n                int32_t sample = alac->outputsamples_buffer_a[i];\n\n                if (uncompressed_bytes)\n                {\n                    uint32_t mask;\n                    sample = sample << (uncompressed_bytes * 8);\n                    mask = ~(0xFFFFFFFF << (uncompressed_bytes * 8));\n                    sample |= alac->uncompressed_bytes_buffer_a[i] & mask;\n                }\n\n                ((uint8_t*)outbuffer)[i * alac->numchannels * 3] = (sample) & 0xFF;\n                ((uint8_t*)outbuffer)[i * alac->numchannels * 3 + 1] = (sample >> 8) & 0xFF;\n                ((uint8_t*)outbuffer)[i * alac->numchannels * 3 + 2] = (sample >> 16) & 0xFF;\n            }\n            break;\n        }\n        case 20:\n        case 32:\n            fprintf(stderr, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n            break;\n        default:\n            break;\n        }\n        break;\n    }\n    case 1: /* 2 channels */\n    {\n        int hassize;\n        int isnotcompressed;\n        int readsamplesize;\n\n        int uncompressed_bytes;\n\n        uint8_t interlacing_shift;\n        uint8_t interlacing_leftweight;\n\n        /* 2^result = something to do with output waiting.\n         * perhaps matters if we read > 1 frame in a pass?\n         */\n        readbits(alac, 4);\n\n        readbits(alac, 12); /* unknown, skip 12 bits */\n\n        hassize = readbits(alac, 1); /* the output sample size is stored soon */\n\n        uncompressed_bytes = readbits(alac, 2); /* the number of bytes in the (compressed) stream that are not compressed */\n\n        isnotcompressed = readbits(alac, 1); /* whether the frame is compressed */\n\n        if (hassize)\n        {\n            /* now read the number of samples,\n             * as a 32bit integer */\n            outputsamples = readbits(alac, 32);\n            *outputsize = outputsamples * alac->bytespersample;\n        }\n\n        readsamplesize = alac->setinfo_sample_size - (uncompressed_bytes * 8) + 1;\n\n        if (!isnotcompressed)\n        { /* compressed */\n            int16_t predictor_coef_table_a[32];\n            int predictor_coef_num_a;\n            int prediction_type_a;\n            int prediction_quantitization_a;\n            int ricemodifier_a;\n\n            int16_t predictor_coef_table_b[32];\n            int predictor_coef_num_b;\n            int prediction_type_b;\n            int prediction_quantitization_b;\n            int ricemodifier_b;\n\n            int i;\n\n            interlacing_shift = readbits(alac, 8);\n            interlacing_leftweight = readbits(alac, 8);\n\n            /******** channel 1 ***********/\n            prediction_type_a = readbits(alac, 4);\n            prediction_quantitization_a = readbits(alac, 4);\n\n            ricemodifier_a = readbits(alac, 3);\n            predictor_coef_num_a = readbits(alac, 5);\n\n            /* read the predictor table */\n            for (i = 0; i < predictor_coef_num_a; i++)\n            {\n                predictor_coef_table_a[i] = (int16_t)readbits(alac, 16);\n            }\n\n            /******** channel 2 *********/\n            prediction_type_b = readbits(alac, 4);\n            prediction_quantitization_b = readbits(alac, 4);\n\n            ricemodifier_b = readbits(alac, 3);\n            predictor_coef_num_b = readbits(alac, 5);\n\n            /* read the predictor table */\n            for (i = 0; i < predictor_coef_num_b; i++)\n            {\n                predictor_coef_table_b[i] = (int16_t)readbits(alac, 16);\n            }\n\n            /*********************/\n            if (uncompressed_bytes)\n            { /* see mono case */\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    alac->uncompressed_bytes_buffer_a[i] = readbits(alac, uncompressed_bytes * 8);\n                    alac->uncompressed_bytes_buffer_b[i] = readbits(alac, uncompressed_bytes * 8);\n                }\n            }\n\n            /* channel 1 */\n            entropy_rice_decode(alac,\n                                alac->predicterror_buffer_a,\n                                outputsamples,\n                                readsamplesize,\n                                alac->setinfo_rice_initialhistory,\n                                alac->setinfo_rice_kmodifier,\n                                ricemodifier_a * alac->setinfo_rice_historymult / 4,\n                                (1 << alac->setinfo_rice_kmodifier) - 1);\n\n            if (prediction_type_a == 0)\n            { /* adaptive fir */\n                predictor_decompress_fir_adapt(alac->predicterror_buffer_a,\n                                               alac->outputsamples_buffer_a,\n                                               outputsamples,\n                                               readsamplesize,\n                                               predictor_coef_table_a,\n                                               predictor_coef_num_a,\n                                               prediction_quantitization_a);\n            }\n            else\n            { /* see mono case */\n                fprintf(stderr, \"FIXME: unhandled predicition type: %i\\n\", prediction_type_a);\n            }\n\n            /* channel 2 */\n            entropy_rice_decode(alac,\n                                alac->predicterror_buffer_b,\n                                outputsamples,\n                                readsamplesize,\n                                alac->setinfo_rice_initialhistory,\n                                alac->setinfo_rice_kmodifier,\n                                ricemodifier_b * alac->setinfo_rice_historymult / 4,\n                                (1 << alac->setinfo_rice_kmodifier) - 1);\n\n            if (prediction_type_b == 0)\n            { /* adaptive fir */\n                predictor_decompress_fir_adapt(alac->predicterror_buffer_b,\n                                               alac->outputsamples_buffer_b,\n                                               outputsamples,\n                                               readsamplesize,\n                                               predictor_coef_table_b,\n                                               predictor_coef_num_b,\n                                               prediction_quantitization_b);\n            }\n            else\n            {\n                fprintf(stderr, \"FIXME: unhandled predicition type: %i\\n\", prediction_type_b);\n            }\n        }\n        else\n        { /* not compressed, easy case */\n            if (alac->setinfo_sample_size <= 16)\n            {\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    int32_t audiobits_a, audiobits_b;\n\n                    audiobits_a = readbits(alac, alac->setinfo_sample_size);\n                    audiobits_b = readbits(alac, alac->setinfo_sample_size);\n\n                    audiobits_a = SIGN_EXTENDED32(audiobits_a, alac->setinfo_sample_size);\n                    audiobits_b = SIGN_EXTENDED32(audiobits_b, alac->setinfo_sample_size);\n\n                    alac->outputsamples_buffer_a[i] = audiobits_a;\n                    alac->outputsamples_buffer_b[i] = audiobits_b;\n                }\n            }\n            else\n            {\n                int i;\n                for (i = 0; i < outputsamples; i++)\n                {\n                    int32_t audiobits_a, audiobits_b;\n\n                    audiobits_a = readbits(alac, 16);\n                    audiobits_a = audiobits_a << (alac->setinfo_sample_size - 16);\n                    audiobits_a |= readbits(alac, alac->setinfo_sample_size - 16);\n                    audiobits_a = SignExtend24(audiobits_a);\n\n                    audiobits_b = readbits(alac, 16);\n                    audiobits_b = audiobits_b << (alac->setinfo_sample_size - 16);\n                    audiobits_b |= readbits(alac, alac->setinfo_sample_size - 16);\n                    audiobits_b = SignExtend24(audiobits_b);\n\n                    alac->outputsamples_buffer_a[i] = audiobits_a;\n                    alac->outputsamples_buffer_b[i] = audiobits_b;\n                }\n            }\n            uncompressed_bytes = 0; // always 0 for uncompressed\n            interlacing_shift = 0;\n            interlacing_leftweight = 0;\n        }\n\n        switch(alac->setinfo_sample_size)\n        {\n        case 16:\n        {\n            deinterlace_16(alac->outputsamples_buffer_a,\n                           alac->outputsamples_buffer_b,\n                           (int16_t*)outbuffer,\n                           alac->numchannels,\n                           outputsamples,\n                           interlacing_shift,\n                           interlacing_leftweight);\n            break;\n        }\n        case 24:\n        {\n            deinterlace_24(alac->outputsamples_buffer_a,\n                           alac->outputsamples_buffer_b,\n                           uncompressed_bytes,\n                           alac->uncompressed_bytes_buffer_a,\n                           alac->uncompressed_bytes_buffer_b,\n                           (int16_t*)outbuffer,\n                           alac->numchannels,\n                           outputsamples,\n                           interlacing_shift,\n                           interlacing_leftweight);\n            break;\n        }\n        case 20:\n        case 32:\n            fprintf(stderr, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n            break;\n        default:\n            break;\n        }\n\n        break;\n    }\n    }\n}\n\nalac_file *alac_create(int samplesize, int numchannels)\n{\n    alac_file *newfile = malloc(sizeof(alac_file));\n\n    memset(newfile, 0, sizeof(alac_file));\n\n    newfile->samplesize = samplesize;\n    newfile->numchannels = numchannels;\n    newfile->bytespersample = (samplesize / 8) * numchannels;\n\n    return newfile;\n}\n\n"
        },
        {
          "name": "alac.h",
          "type": "blob",
          "size": 1.5478515625,
          "content": "#ifndef __ALAC__DECOMP_H\n#define __ALAC__DECOMP_H\n\n#include <stdint.h>\n\ntypedef struct alac_file alac_file;\n\nalac_file *alac_create(int samplesize, int numchannels);\nvoid alac_decode_frame(alac_file *alac,\n                       unsigned char *inbuffer,\n                       void *outbuffer, int *outputsize);\nvoid alac_set_info(alac_file *alac, char *inputbuffer);\nvoid alac_allocate_buffers(alac_file *alac);\nvoid alac_free(alac_file *alac);\n\nstruct alac_file\n{\n    unsigned char *input_buffer;\n    int input_buffer_bitaccumulator; /* used so we can do arbitary\n                                        bit reads */\n\n    int samplesize;\n    int numchannels;\n    int bytespersample;\n\n\n    /* buffers */\n    int32_t *predicterror_buffer_a;\n    int32_t *predicterror_buffer_b;\n\n    int32_t *outputsamples_buffer_a;\n    int32_t *outputsamples_buffer_b;\n\n    int32_t *uncompressed_bytes_buffer_a;\n    int32_t *uncompressed_bytes_buffer_b;\n\n\n\n  /* stuff from setinfo */\n  uint32_t setinfo_max_samples_per_frame; /* 0x1000 = 4096 */    /* max samples per frame? */\n  uint8_t setinfo_7a; /* 0x00 */\n  uint8_t setinfo_sample_size; /* 0x10 */\n  uint8_t setinfo_rice_historymult; /* 0x28 */\n  uint8_t setinfo_rice_initialhistory; /* 0x0a */\n  uint8_t setinfo_rice_kmodifier; /* 0x0e */\n  uint8_t setinfo_7f; /* 0x02 */\n  uint16_t setinfo_80; /* 0x00ff */\n  uint32_t setinfo_82; /* 0x000020e7 */ /* max sample size?? */\n  uint32_t setinfo_86; /* 0x00069fe4 */ /* bit rate (avarge)?? */\n  uint32_t setinfo_8a_rate; /* 0x0000ac44 */\n  /* end setinfo stuff */\n\n};\n\n\n#endif /* __ALAC__DECOMP_H */\n\n"
        },
        {
          "name": "audio.c",
          "type": "blob",
          "size": 2.38671875,
          "content": "/*\n * Audio driver handler. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include \"audio.h\"\n#include \"config.h\"\n\n#ifdef CONFIG_SNDIO\nextern audio_output audio_sndio;\n#endif\n#ifdef CONFIG_AO\nextern audio_output audio_ao;\n#endif\n#ifdef CONFIG_PULSE\nextern audio_output audio_pulse;\n#endif\n#ifdef CONFIG_ALSA\nextern audio_output audio_alsa;\n#endif\nextern audio_output audio_dummy, audio_pipe;\n\nstatic audio_output *outputs[] = {\n#ifdef CONFIG_SNDIO\n    &audio_sndio,\n#endif\n#ifdef CONFIG_ALSA\n    &audio_alsa,\n#endif\n#ifdef CONFIG_PULSE\n    &audio_pulse,\n#endif\n#ifdef CONFIG_AO\n    &audio_ao,\n#endif\n    &audio_dummy,\n    &audio_pipe,\n    NULL\n};\n\n\naudio_output *audio_get_output(char *name) {\n    audio_output **out;\n\n    // default to the first\n    if (!name)\n        return outputs[0];\n\n    for (out=outputs; *out; out++)\n        if (!strcasecmp(name, (*out)->name))\n            return *out;\n\n    return NULL;\n}\n\nvoid audio_ls_outputs(void) {\n    audio_output **out;\n\n    printf(\"Available audio outputs:\\n\");\n    for (out=outputs; *out; out++)\n        printf(\"    %s%s\\n\", (*out)->name, out==outputs ? \" (default)\" : \"\");\n\n    for (out=outputs; *out; out++) {\n        printf(\"\\n\");\n        printf(\"Options for output %s:\\n\", (*out)->name);\n        (*out)->help();\n    }\n}\n"
        },
        {
          "name": "audio.h",
          "type": "blob",
          "size": 0.5234375,
          "content": "#ifndef _AUDIO_H\n#define _AUDIO_H\n\ntypedef struct {\n    void (*help)(void);\n    char *name;\n\n    // start of program\n    int (*init)(int argc, char **argv);\n    // at end of program\n    void (*deinit)(void);\n\n    void (*start)(int sample_rate);\n    // block of samples\n    void (*play)(short buf[], int samples);\n    void (*stop)(void);\n\n    // may be NULL, in which case soft volume is applied\n    void (*volume)(double vol);\n} audio_output;\n\naudio_output *audio_get_output(char *name);\nvoid audio_ls_outputs(void);\n\n#endif //_AUDIO_H\n"
        },
        {
          "name": "audio_alsa.c",
          "type": "blob",
          "size": 6.466796875,
          "content": "/*\n * libalsa output driver. This file is part of Shairport.\n * Copyright (c) Muffinman, Skaman 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#define ALSA_PCM_NEW_HW_PARAMS_API\n\n#include <stdio.h>\n#include <unistd.h>\n#include <memory.h>\n#include <alsa/asoundlib.h>\n#include \"common.h\"\n#include \"audio.h\"\n\nstatic void help(void);\nstatic int init(int argc, char **argv);\nstatic void deinit(void);\nstatic void start(int sample_rate);\nstatic void play(short buf[], int samples);\nstatic void stop(void);\nstatic void volume(double vol);\n\naudio_output audio_alsa = {\n    .name = \"alsa\",\n    .help = &help,\n    .init = &init,\n    .deinit = &deinit,\n    .start = &start,\n    .stop = &stop,\n    .play = &play,\n    .volume = NULL\n};\n\nstatic snd_pcm_t *alsa_handle = NULL;\nstatic snd_pcm_hw_params_t *alsa_params = NULL;\n\nstatic snd_mixer_t *alsa_mix_handle = NULL;\nstatic snd_mixer_elem_t *alsa_mix_elem = NULL;\nstatic snd_mixer_selem_id_t *alsa_mix_sid = NULL;\nstatic long alsa_mix_minv, alsa_mix_range;\n\nstatic char *alsa_out_dev = \"default\";\nstatic char *alsa_mix_dev = NULL;\nstatic char *alsa_mix_ctrl = \"Master\";\nstatic int alsa_mix_index = 0;\n\nstatic void help(void) {\n    printf(\"    -d output-device    set the output device [default*|...]\\n\"\n           \"    -t mixer-type       set the mixer type [software*|hardware]\\n\"\n           \"    -m mixer-device     set the mixer device ['output-device'*|...]\\n\"\n           \"    -c mixer-control    set the mixer control [Master*|...]\\n\"\n           \"    -i mixer-index      set the mixer index [0*|...]\\n\"\n           \"    *) default option\\n\"\n          );\n}\n\nstatic int init(int argc, char **argv) {\n    int hardware_mixer = 0;\n\n    optind = 1; // optind=0 is equivalent to optind=1 plus special behaviour\n    argv--;     // so we shift the arguments to satisfy getopt()\n    argc++;\n    // some platforms apparently require optreset = 1; - which?\n    int opt;\n    while ((opt = getopt(argc, argv, \"d:t:m:c:i:\")) > 0) {\n        switch (opt) {\n            case 'd':\n                alsa_out_dev = optarg;\n                break;\n            case 't':\n                if (strcmp(optarg, \"hardware\") == 0)\n                    hardware_mixer = 1;\n                break;\n            case 'm':\n                alsa_mix_dev = optarg;\n                break;\n            case 'c':\n                alsa_mix_ctrl = optarg;\n                break;\n            case 'i':\n                alsa_mix_index = strtol(optarg, NULL, 10);\n                break;\n            default:\n                help();\n                die(\"Invalid audio option -%c specified\", opt);\n        }\n    }\n\n    if (optind < argc)\n        die(\"Invalid audio argument: %s\", argv[optind]);\n\n    if (!hardware_mixer)\n        return 0;\n\n    if (alsa_mix_dev == NULL)\n        alsa_mix_dev = alsa_out_dev;\n    audio_alsa.volume = &volume;\n\n    int ret = 0;\n    long alsa_mix_maxv;\n\n    snd_mixer_selem_id_alloca(&alsa_mix_sid);\n    snd_mixer_selem_id_set_index(alsa_mix_sid, alsa_mix_index);\n    snd_mixer_selem_id_set_name(alsa_mix_sid, alsa_mix_ctrl);\n\n    if ((snd_mixer_open(&alsa_mix_handle, 0)) < 0)\n        die (\"Failed to open mixer\");\n    if ((snd_mixer_attach(alsa_mix_handle, alsa_mix_dev)) < 0)\n        die (\"Failed to attach mixer\");\n    if ((snd_mixer_selem_register(alsa_mix_handle, NULL, NULL)) < 0)\n        die (\"Failed to register mixer element\");\n\n    ret = snd_mixer_load(alsa_mix_handle);\n    if (ret < 0)\n        die (\"Failed to load mixer element\");\n    alsa_mix_elem = snd_mixer_find_selem(alsa_mix_handle, alsa_mix_sid);\n    if (!alsa_mix_elem)\n        die (\"Failed to find mixer element\");\n    snd_mixer_selem_get_playback_volume_range (alsa_mix_elem, &alsa_mix_minv, &alsa_mix_maxv);\n    alsa_mix_range = alsa_mix_maxv - alsa_mix_minv;\n\n    return 0;\n}\n\nstatic void deinit(void) {\n    stop();\n    if (alsa_mix_handle) {\n        snd_mixer_close(alsa_mix_handle);\n    }\n}\n\nstatic void start(int sample_rate) {\n    if (sample_rate != 44100)\n        die(\"Unexpected sample rate!\");\n\n    int ret, dir = 0;\n    snd_pcm_uframes_t frames = 64;\n    ret = snd_pcm_open(&alsa_handle, alsa_out_dev, SND_PCM_STREAM_PLAYBACK, 0);\n    if (ret < 0)\n        die(\"Alsa initialization failed: unable to open pcm device: %s\\n\", snd_strerror(ret));\n\n    snd_pcm_hw_params_alloca(&alsa_params);\n    snd_pcm_hw_params_any(alsa_handle, alsa_params);\n    snd_pcm_hw_params_set_access(alsa_handle, alsa_params, SND_PCM_ACCESS_RW_INTERLEAVED);\n    snd_pcm_hw_params_set_format(alsa_handle, alsa_params, SND_PCM_FORMAT_S16);\n    snd_pcm_hw_params_set_channels(alsa_handle, alsa_params, 2);\n    snd_pcm_hw_params_set_rate_near(alsa_handle, alsa_params, (unsigned int *)&sample_rate, &dir);\n    snd_pcm_hw_params_set_period_size_near(alsa_handle, alsa_params, &frames, &dir);\n    ret = snd_pcm_hw_params(alsa_handle, alsa_params);\n    if (ret < 0)\n        die(\"unable to set hw parameters: %s\\n\", snd_strerror(ret));\n}\n\nstatic void play(short buf[], int samples) {\n    int err = snd_pcm_writei(alsa_handle, (char*)buf, samples);\n    if (err < 0)\n        err = snd_pcm_recover(alsa_handle, err, 0);\n    if (err < 0)\n        die(\"Failed to write to PCM device: %s\\n\", snd_strerror(err));\n}\n\nstatic void stop(void) {\n    if (alsa_handle) {\n        snd_pcm_drain(alsa_handle);\n        snd_pcm_close(alsa_handle);\n        alsa_handle = NULL;\n    }\n}\n\nstatic void volume(double vol) {\n    long alsa_volume = (vol*alsa_mix_range)+alsa_mix_minv;\n    if(snd_mixer_selem_set_playback_volume_all(alsa_mix_elem, alsa_volume) != 0)\n        die (\"Failed to set playback volume\");\n}\n"
        },
        {
          "name": "audio_ao.c",
          "type": "blob",
          "size": 3.8232421875,
          "content": "/*\n * libao output driver. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <memory.h>\n#include <ao/ao.h>\n#include \"common.h\"\n#include \"audio.h\"\n\nao_device *dev = NULL;\n\nstatic void help(void) {\n    printf(\"    -d driver           set the output driver\\n\"\n           \"    -o name=value       set an arbitrary ao option\\n\"\n           \"    -i id               shorthand for -o id=<id>\\n\"\n           \"    -n name             shorthand for -o dev=<name> -o dsp=<name>\\n\"\n          );\n}\n\nstatic int init(int argc, char **argv) {\n    ao_initialize();\n    int driver = ao_default_driver_id();\n    ao_option *ao_opts = NULL;\n\n    optind = 1; // optind=0 is equivalent to optind=1 plus special behaviour\n    argv--;     // so we shift the arguments to satisfy getopt()\n    argc++;\n    // some platforms apparently require optreset = 1; - which?\n    int opt;\n    char *mid;\n    while ((opt = getopt(argc, argv, \"d:i:n:o:\")) > 0) {\n        switch (opt) {\n            case 'd':\n                driver = ao_driver_id(optarg);\n                if (driver < 0)\n                    die(\"could not find ao driver %s\", optarg);\n                break;\n            case 'i':\n                ao_append_option(&ao_opts, \"id\", optarg);\n                break;\n            case 'n':\n                ao_append_option(&ao_opts, \"dev\", optarg);\n                // Old libao versions (for example, 0.8.8) only support\n                // \"dsp\" instead of \"dev\".\n                ao_append_option(&ao_opts, \"dsp\", optarg);\n                break;\n            case 'o':\n                mid = strchr(optarg, '=');\n                if (!mid)\n                    die(\"Expected an = in audio option %s\", optarg);\n                *mid = 0;\n                ao_append_option(&ao_opts, optarg, mid+1);\n                break;\n            default:\n                help();\n                die(\"Invalid audio option -%c specified\", opt);\n        }\n    }\n\n    if (optind < argc)\n        die(\"Invalid audio argument: %s\", argv[optind]);\n\n    ao_sample_format fmt;\n    memset(&fmt, 0, sizeof(fmt));\n\n    fmt.bits = 16;\n    fmt.rate = 44100;\n    fmt.channels = 2;\n    fmt.byte_format = AO_FMT_NATIVE;\n\n    dev = ao_open_live(driver, &fmt, ao_opts);\n\n    return dev ? 0 : 1;\n}\n\nstatic void deinit(void) {\n    if (dev)\n        ao_close(dev);\n    dev = NULL;\n    ao_shutdown();\n}\n\nstatic void start(int sample_rate) {\n    if (sample_rate != 44100)\n        die(\"unexpected sample rate!\");\n}\n\nstatic void play(short buf[], int samples) {\n    ao_play(dev, (char*)buf, samples*4);\n}\n\nstatic void stop(void) {\n}\n\naudio_output audio_ao = {\n    .name = \"ao\",\n    .help = &help,\n    .init = &init,\n    .deinit = &deinit,\n    .start = &start,\n    .stop = &stop,\n    .play = &play,\n    .volume = NULL\n};\n"
        },
        {
          "name": "audio_dummy.c",
          "type": "blob",
          "size": 2.28125,
          "content": "/*\n * dummy output driver. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include \"audio.h\"\n\nint Fs;\nlong long starttime, samples_played;\n\nstatic int init(int argc, char **argv) {\n    return 0;\n}\n\nstatic void deinit(void) {\n}\n\nstatic void start(int sample_rate) {\n    Fs = sample_rate;\n    starttime = 0;\n    samples_played = 0;\n    printf(\"dummy audio output started at Fs=%d Hz\\n\", sample_rate);\n}\n\nstatic void play(short buf[], int samples) {\n    struct timeval tv;\n\n    // this is all a bit expensive but it's long-term stable.\n    gettimeofday(&tv, NULL);\n\n    long long nowtime = tv.tv_usec + 1e6*tv.tv_sec;\n\n    if (!starttime)\n        starttime = nowtime;\n\n    samples_played += samples;\n\n    long long finishtime = starttime + samples_played * 1e6 / Fs;\n\n    usleep(finishtime - nowtime);\n}\n\nstatic void stop(void) {\n    printf(\"dummy audio stopped\\n\");\n}\n\nstatic void help(void) {\n    printf(\"    There are no options for dummy audio.\\n\");\n}\n\naudio_output audio_dummy = {\n    .name = \"dummy\",\n    .help = &help,\n    .init = &init,\n    .deinit = &deinit,\n    .start = &start,\n    .stop = &stop,\n    .play = &play,\n    .volume = NULL\n};\n"
        },
        {
          "name": "audio_pipe.c",
          "type": "blob",
          "size": 3.380859375,
          "content": "/*\n * pipe output driver. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <memory.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include \"common.h\"\n#include \"audio.h\"\n\nstatic int fd = -1;\nstatic char *pipename = NULL;\nstatic int Fs;\nstatic long long starttime, samples_played;\n\nstatic void stop(void) {\n    close(fd);\n    fd = -1;\n}\n\nstatic void start(int sample_rate) {\n    if (fd >= 0)\n        stop();\n\n    fd = open(pipename, O_WRONLY | O_NONBLOCK);\n    if ((fd < 0) && (errno != ENXIO)) {\n        perror(\"open\");\n        die(\"could not open specified pipe for writing\");\n    }\n\n    // The other end is ready, reopen with blocking\n    if (fd >= 0) {\n        close(fd);\n        fd = open(pipename, O_WRONLY);\n    }\n\n    Fs = sample_rate;\n    starttime = 0;\n    samples_played = 0;\n}\n\n// Wait procedure taken from audio_dummy.c\nstatic void wait_samples(int samples) {\n    struct timeval tv;\n\n    // this is all a bit expensive but it's long-term stable.\n    gettimeofday(&tv, NULL);\n\n    long long nowtime = tv.tv_usec + 1e6*tv.tv_sec;\n\n    if (!starttime)\n        starttime = nowtime;\n\n    samples_played += samples;\n\n    long long finishtime = starttime + samples_played * 1e6 / Fs;\n\n    usleep(finishtime - nowtime);\n}\n\nstatic void play(short buf[], int samples) {\n    if (fd < 0) {\n        wait_samples(samples);\n\n        // check if the other end is ready every 5 seconds\n        if (samples_played > 5 * Fs)\n            start(Fs);\n\n        return;\n    }\n\n    if (write(fd, buf, samples*4) < 0)\n        stop();\n}\n\nstatic int init(int argc, char **argv) {\n    struct stat sb;\n\n    if (argc != 1)\n        die(\"bad argument(s) to pipe\");\n\n    pipename = strdup(argv[0]);\n\n    if (stat(pipename, &sb) < 0)\n        die(\"could not stat() pipe\");\n\n    if (!S_ISFIFO(sb.st_mode))\n        die(\"not a pipe\");\n\n    return 0;\n}\n\nstatic void deinit(void) {\n    if (fd >= 0)\n        stop();\n    if (pipename)\n        free(pipename);\n}\n\nstatic void help(void) {\n    printf(\"    pipe takes 1 argument: the name of the FIFO to write to.\\n\");\n}\n\naudio_output audio_pipe = {\n    .name = \"pipe\",\n    .help = &help,\n    .init = &init,\n    .deinit = &deinit,\n    .start = &start,\n    .stop = &stop,\n    .play = &play,\n    .volume = NULL\n};\n"
        },
        {
          "name": "audio_pulse.c",
          "type": "blob",
          "size": 3.7861328125,
          "content": "/*\n * PulseAudio output driver. This file is part of Shairport.\n * Copyright (c) Paul Lietar 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <memory.h>\n#include <pulse/simple.h>\n#include <pulse/error.h>\n#include \"common.h\"\n#include \"audio.h\"\n\nstatic pa_simple *pa_dev = NULL;\nstatic int pa_error;\n\nstatic void help(void) {\n    printf(\"    -a server           set the server name\\n\"\n           \"    -s sink             set the output sink\\n\"\n           \"    -n name             set the application name, as seen by PulseAudio\\n\"\n           \"                            defaults to the access point name\\n\"\n          );\n}\n\nstatic int init(int argc, char **argv) {\n    char *pa_server = NULL;\n    char *pa_sink = NULL;\n    char *pa_appname = config.apname;\n\n    optind = 1; // optind=0 is equivalent to optind=1 plus special behaviour\n    argv--;     // so we shift the arguments to satisfy getopt()\n    argc++;\n\n    // some platforms apparently require optreset = 1; - which?\n    int opt;\n    while ((opt = getopt(argc, argv, \"a:s:n:\")) > 0) {\n        switch (opt) {\n            case 'a':\n                pa_server = optarg;\n                break;\n            case 's':\n                pa_sink = optarg;\n                break;\n            case 'n':\n                pa_appname = optarg;\n                break;\n            default:\n                help();\n                die(\"Invalid audio option -%c specified\", opt);\n        }\n    }\n\n    if (optind < argc)\n        die(\"Invalid audio argument: %s\", argv[optind]);\n\n    static const pa_sample_spec ss = {\n            .format = PA_SAMPLE_S16LE,\n            .rate = 44100,\n            .channels = 2\n    };\n\n    pa_dev = pa_simple_new(pa_server,\n            pa_appname,\n            PA_STREAM_PLAYBACK,\n            pa_sink,\n            \"Shairport Stream\",\n            &ss, NULL, NULL,\n            &pa_error);\n\n    if (!pa_dev)\n        die(\"Could not connect to pulseaudio server: %s\", pa_strerror(pa_error));\n\n    return 0;\n}\n\nstatic void deinit(void) {\n    if (pa_dev)\n        pa_simple_free(pa_dev);\n    pa_dev = NULL;\n}\n\nstatic void start(int sample_rate) {\n    if (sample_rate != 44100)\n        die(\"unexpected sample rate!\");\n}\n\nstatic void play(short buf[], int samples) {\n    if( pa_simple_write(pa_dev, (char *)buf, (size_t)samples * 4, &pa_error) < 0 )\n        fprintf(stderr, __FILE__\": pa_simple_write() failed: %s\\n\", pa_strerror(pa_error));\n}\n\nstatic void stop(void) {\n    if (pa_simple_drain(pa_dev, &pa_error) < 0)\n        fprintf(stderr, __FILE__\": pa_simple_drain() failed: %s\\n\", pa_strerror(pa_error));\n}\n\naudio_output audio_pulse = {\n    .name = \"pulse\",\n    .help = &help,\n    .init = &init,\n    .deinit = &deinit,\n    .start = &start,\n    .stop = &stop,\n    .play = &play,\n    .volume = NULL\n};\n"
        },
        {
          "name": "audio_sndio.c",
          "type": "blob",
          "size": 2.0830078125,
          "content": "/*\n * sndio output driver. This file is part of Shairport.\n * Copyright (c) 2013 Dimitri Sokolyuk <demon@dim13.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sndio.h>\n#include \"audio.h\"\n\nstatic struct sio_hdl *sio;\nstatic struct sio_par par;\n\nstatic int init(int argc, char **argv) {\n\tsio = sio_open(SIO_DEVANY, SIO_PLAY, 0);\n\tif (!sio)\n\t\tdie(\"sndio: cannot connect to sound server\");\n\n\tsio_initpar(&par);\n\n\tpar.bits = 16;\n\tpar.rate = 44100;\n\tpar.pchan = 2;\n\tpar.le = SIO_LE_NATIVE;\n\tpar.sig = 1;\n\n\tif (!sio_setpar(sio, &par))\n\t\tdie(\"sndio: failed to set audio parameters\");\n\tif (!sio_getpar(sio, &par))\n\t\tdie(\"sndio: failed to get audio parameters\");\n\n\treturn 0;\n}\n\nstatic void deinit(void) {\n\tsio_close(sio);\n}\n\nstatic void start(int sample_rate) {\n\tif (sample_rate != par.rate)\n\t\tdie(\"unexpected sample rate!\");\n\tsio_start(sio);\n}\n\nstatic void play(short buf[], int samples) {\n\tsio_write(sio, (char *)buf, samples * par.bps * par.pchan);\n}\n\nstatic void stop(void) {\n\tsio_stop(sio);\n}\n\nstatic void help(void) {\n\tprintf(\"    There are no options for sndio audio.\\n\");\n\tprintf(\"    Use AUDIODEVICE environment variable.\\n\");\n}\n\nstatic void volume(double vol) {\n\tunsigned int v = vol * SIO_MAXVOL;\n\tsio_setvol(sio, v);\n}\n\naudio_output audio_sndio = {\n\t.name = \"sndio\",\n\t.help = &help,\n\t.init = &init,\n\t.deinit = &deinit,\n\t.start = &start,\n\t.stop = &stop,\n\t.play = &play,\n\t.volume = &volume\n};\n"
        },
        {
          "name": "common.c",
          "type": "blob",
          "size": 6.4189453125,
          "content": "/*\n * Utility routines. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <unistd.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n#include \"common.h\"\n#include \"daemon.h\"\n\nshairport_cfg config;\n\nint debuglev = 0;\n\nvoid die(char *format, ...) {\n    fprintf(stderr, \"FATAL: \");\n\n    va_list args;\n    va_start(args, format);\n\n    vfprintf(stderr, format, args);\n    if (config.daemonise)\n        daemon_fail(format, args); // Send error message to parent\n\n    va_end(args);\n\n    fprintf(stderr, \"\\n\");\n    shairport_shutdown(1);\n}\n\nvoid warn(char *format, ...) {\n    fprintf(stderr, \"WARNING: \");\n    va_list args;\n    va_start(args, format);\n    vfprintf(stderr, format, args);\n    va_end(args);\n    fprintf(stderr, \"\\n\");\n}\n\nvoid debug(int level, char *format, ...) {\n    if (level > debuglev)\n        return;\n    va_list args;\n    va_start(args, format);\n    vfprintf(stderr, format, args);\n    va_end(args);\n}\n\n\nchar *base64_enc(uint8_t *input, int length) {\n    BIO *bmem, *b64;\n    BUF_MEM *bptr;\n    b64 = BIO_new(BIO_f_base64());\n    bmem = BIO_new(BIO_s_mem());\n    b64 = BIO_push(b64, bmem);\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    BIO_write(b64, input, length);\n    BIO_flush(b64);\n    BIO_get_mem_ptr(b64, &bptr);\n\n    char *buf = (char *)malloc(bptr->length);\n    if (bptr->length) {\n        memcpy(buf, bptr->data, bptr->length-1);\n        buf[bptr->length-1] = 0;\n    }\n\n    BIO_free_all(bmem);\n\n    return buf;\n}\n\nuint8_t *base64_dec(char *input, int *outlen) {\n    BIO *bmem, *b64;\n    int inlen = strlen(input);\n\n    b64 = BIO_new(BIO_f_base64());\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bmem = BIO_new(BIO_s_mem());\n    b64 = BIO_push(b64, bmem);\n\n    // Apple cut the padding off their challenges; restore it\n    BIO_write(bmem, input, inlen);\n    while (inlen++ & 3)\n        BIO_write(bmem, \"=\", 1);\n    BIO_flush(bmem);\n\n    int bufsize = strlen(input)*3/4 + 1;\n    uint8_t *buf = malloc(bufsize);\n    int nread;\n\n    nread = BIO_read(b64, buf, bufsize);\n\n    BIO_free_all(bmem);\n\n    *outlen = nread;\n    return buf;\n}\n\nstatic char super_secret_key[] =\n\"-----BEGIN RSA PRIVATE KEY-----\\n\"\n\"MIIEpQIBAAKCAQEA59dE8qLieItsH1WgjrcFRKj6eUWqi+bGLOX1HL3U3GhC/j0Qg90u3sG/1CUt\\n\"\n\"wC5vOYvfDmFI6oSFXi5ELabWJmT2dKHzBJKa3k9ok+8t9ucRqMd6DZHJ2YCCLlDRKSKv6kDqnw4U\\n\"\n\"wPdpOMXziC/AMj3Z/lUVX1G7WSHCAWKf1zNS1eLvqr+boEjXuBOitnZ/bDzPHrTOZz0Dew0uowxf\\n\"\n\"/+sG+NCK3eQJVxqcaJ/vEHKIVd2M+5qL71yJQ+87X6oV3eaYvt3zWZYD6z5vYTcrtij2VZ9Zmni/\\n\"\n\"UAaHqn9JdsBWLUEpVviYnhimNVvYFZeCXg/IdTQ+x4IRdiXNv5hEewIDAQABAoIBAQDl8Axy9XfW\\n\"\n\"BLmkzkEiqoSwF0PsmVrPzH9KsnwLGH+QZlvjWd8SWYGN7u1507HvhF5N3drJoVU3O14nDY4TFQAa\\n\"\n\"LlJ9VM35AApXaLyY1ERrN7u9ALKd2LUwYhM7Km539O4yUFYikE2nIPscEsA5ltpxOgUGCY7b7ez5\\n\"\n\"NtD6nL1ZKauw7aNXmVAvmJTcuPxWmoktF3gDJKK2wxZuNGcJE0uFQEG4Z3BrWP7yoNuSK3dii2jm\\n\"\n\"lpPHr0O/KnPQtzI3eguhe0TwUem/eYSdyzMyVx/YpwkzwtYL3sR5k0o9rKQLtvLzfAqdBxBurciz\\n\"\n\"aaA/L0HIgAmOit1GJA2saMxTVPNhAoGBAPfgv1oeZxgxmotiCcMXFEQEWflzhWYTsXrhUIuz5jFu\\n\"\n\"a39GLS99ZEErhLdrwj8rDDViRVJ5skOp9zFvlYAHs0xh92ji1E7V/ysnKBfsMrPkk5KSKPrnjndM\\n\"\n\"oPdevWnVkgJ5jxFuNgxkOLMuG9i53B4yMvDTCRiIPMQ++N2iLDaRAoGBAO9v//mU8eVkQaoANf0Z\\n\"\n\"oMjW8CN4xwWA2cSEIHkd9AfFkftuv8oyLDCG3ZAf0vrhrrtkrfa7ef+AUb69DNggq4mHQAYBp7L+\\n\"\n\"k5DKzJrKuO0r+R0YbY9pZD1+/g9dVt91d6LQNepUE/yY2PP5CNoFmjedpLHMOPFdVgqDzDFxU8hL\\n\"\n\"AoGBANDrr7xAJbqBjHVwIzQ4To9pb4BNeqDndk5Qe7fT3+/H1njGaC0/rXE0Qb7q5ySgnsCb3DvA\\n\"\n\"cJyRM9SJ7OKlGt0FMSdJD5KG0XPIpAVNwgpXXH5MDJg09KHeh0kXo+QA6viFBi21y340NonnEfdf\\n\"\n\"54PX4ZGS/Xac1UK+pLkBB+zRAoGAf0AY3H3qKS2lMEI4bzEFoHeK3G895pDaK3TFBVmD7fV0Zhov\\n\"\n\"17fegFPMwOII8MisYm9ZfT2Z0s5Ro3s5rkt+nvLAdfC/PYPKzTLalpGSwomSNYJcB9HNMlmhkGzc\\n\"\n\"1JnLYT4iyUyx6pcZBmCd8bD0iwY/FzcgNDaUmbX9+XDvRA0CgYEAkE7pIPlE71qvfJQgoA9em0gI\\n\"\n\"LAuE4Pu13aKiJnfft7hIjbK+5kyb3TysZvoyDnb3HOKvInK7vXbKuU4ISgxB2bB3HcYzQMGsz1qJ\\n\"\n\"2gG0N5hvJpzwwhbhXqFKA4zaaSrw622wDniAK5MlIE0tIAKKP4yxNGjoD2QYjhBGuhvkWKY=\\n\"\n\"-----END RSA PRIVATE KEY-----\";\n\nuint8_t *rsa_apply(uint8_t *input, int inlen, int *outlen, int mode) {\n    static RSA *rsa = NULL;\n\n    if (!rsa) {\n        BIO *bmem = BIO_new_mem_buf(super_secret_key, -1);\n        rsa = PEM_read_bio_RSAPrivateKey(bmem, NULL, NULL, NULL);\n        BIO_free(bmem);\n    }\n\n    uint8_t *out = malloc(RSA_size(rsa));\n    switch (mode) {\n        case RSA_MODE_AUTH:\n            *outlen = RSA_private_encrypt(inlen, input, out, rsa,\n                                          RSA_PKCS1_PADDING);\n            break;\n        case RSA_MODE_KEY:\n            *outlen = RSA_private_decrypt(inlen, input, out, rsa,\n                                          RSA_PKCS1_OAEP_PADDING);\n            break;\n        default:\n            die(\"bad rsa mode\");\n    }\n    return out;\n}\n\nvoid command_start(void) {\n    if (!config.cmd_start)\n        return;\n    if (!config.cmd_blocking && fork())\n        return;\n\n    debug(1, \"running start command: %s\", config.cmd_start);\n    if (system(config.cmd_start))\n        warn(\"exec of external start command failed\");\n\n    if (!config.cmd_blocking)\n        exit(0);\n}\n\nvoid command_stop(void) {\n    if (!config.cmd_stop)\n        return;\n    if (!config.cmd_blocking && fork())\n        return;\n\n    debug(1, \"running stop command: %s\", config.cmd_stop);\n    if (system(config.cmd_stop))\n        warn(\"exec of external stop command failed\");\n\n    if (!config.cmd_blocking)\n        exit(0);\n}\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 1.544921875,
          "content": "#ifndef _COMMON_H\n#define _COMMON_H\n\n#include <openssl/rsa.h>\n#include <stdint.h>\n#include <sys/socket.h>\n#include \"audio.h\"\n#include \"mdns.h\"\n\n// struct sockaddr_in6 is bigger than struct sockaddr. derp\n#ifdef AF_INET6\n    #define SOCKADDR struct sockaddr_storage\n    #define SAFAMILY ss_family\n#else\n    #define SOCKADDR struct sockaddr\n    #define SAFAMILY sa_family\n#endif\n\n\ntypedef struct {\n    char *password;\n    char *apname;\n    uint8_t hw_addr[6];\n    int port;\n    char *output_name;\n    audio_output *output;\n    char *mdns_name;\n    mdns_backend *mdns;\n    int buffer_start_fill;\n    int daemonise;\n    char *cmd_start, *cmd_stop;\n    int cmd_blocking;\n    char *meta_dir;\n    char *pidfile;\n    char *logfile;\n    char *errfile;\n} shairport_cfg;\n\nextern int debuglev;\nvoid die(char *format, ...);\nvoid warn(char *format, ...);\nvoid debug(int level, char *format, ...);\n\n/* functions that ignore return values without compiler warnings.\n * for use only where return values really don't matter!\n */\n#define write_unchecked(...) (void)(write(__VA_ARGS__)+1)\n#define read_unchecked(...)  (void)(read (__VA_ARGS__)+1)\n#define lockf_unchecked(...) (void)(lockf(__VA_ARGS__)+1)\n\nuint8_t *base64_dec(char *input, int *outlen);\nchar *base64_enc(uint8_t *input, int length);\n\n#define RSA_MODE_AUTH (0)\n#define RSA_MODE_KEY  (1)\nuint8_t *rsa_apply(uint8_t *input, int inlen, int *outlen, int mode);\n\nvoid command_start(void);\nvoid command_stop(void);\n\nextern shairport_cfg config;\n\nvoid shairport_shutdown(int retval);\nvoid shairport_startup_complete(void);\n\n#endif // _COMMON_H\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 2.0927734375,
          "content": "#!/bin/sh\n\n[ -z \"${CC}\" ] && CC=gcc\n\necho Configuring Shairport\n\nrm -f config.mk config.h\n\necho \"// automatically generated file\" > config.h\n\nLDFLAGS=\"${LDFLAGS} -lm -lpthread\"\n\nexport_config()\n{\n    echo \"#define $1\" >> config.h\n    echo \"$1=yes\" >> config.mk\n    eval \"$1=yes\"\n}\n\n# check for header $1 with CONFIG_ var $2\ncheck_header()\n{\n    echo \"#include<$1>\" > .header_test.c\n    if ${CC} ${CFLAGS} ${LDFLAGS} -c .header_test.c > /dev/null 2>&1 /dev/null;  then\n        echo \"$1 found\"\n        if [ \"$2\" ]; then\n            export_config $2\n        fi\n    else\n        echo \"$1 not found\"\n        if [ ! \"$2\" ]; then\n            echo \"Required header not found, cannot continue\"\n            rm .header_test.c\n            rm -f config.mk config.h\n            exit 1\n        fi\n    fi\n\n    rm -f .header_test.c .header_test.o\n}\n\n# check for and use pkg-config package $2 with CONFIG_ var $3\ndo_pkg_config()\n{\n    if pkg-config $2 2>/dev/null; then\n        CFLAGS=\"${CFLAGS} `pkg-config --cflags $2`\"\n        LDFLAGS=\"${LDFLAGS} `pkg-config --libs $2`\"\n        if [ \"$3\" ]; then\n            export_config $3\n        fi\n        echo \"$1 found\"\n    else\n        echo \"$1 or its dev package not found\"\n        if [ ! \"$3\" ]; then\n            echo \"Required package not found, cannot continue\"\n            rm -f config.mk config.h\n            exit 1\n        fi\n    fi\n}\n\ndo_pkg_config OpenSSL       openssl\ndo_pkg_config libao         ao              CONFIG_AO\ndo_pkg_config PulseAudio    libpulse-simple CONFIG_PULSE\ndo_pkg_config ALSA          alsa            CONFIG_ALSA\ndo_pkg_config Avahi\\ client avahi-client    CONFIG_AVAHI\n\nif [ `uname` = 'OpenBSD' ]; then\n    echo \"OpenBSD machine, use sndio\"\n    export_config CONFIG_SNDIO\n    LDFLAGS=\"${LDFLAGS} -lsndio\"\nfi\n\ncheck_header  getopt.h      CONFIG_HAVE_GETOPT_H\n\n# Don't build dns_sd backend if we have avahi\nif [ -z \"$CONFIG_AVAHI\" ]; then\n    check_header  dns_sd.h      CONFIG_HAVE_DNS_SD_H\nfi\n\n\necho \"CFLAGS+=${CFLAGS}\" >> config.mk\necho \"LDFLAGS+=${LDFLAGS}\" >> config.mk\n\necho CFLAGS: ${CFLAGS}\necho LDFLAGS: ${LDFLAGS}\n\necho \"Configure successful. You may now build with 'make'\"\n"
        },
        {
          "name": "daemon.c",
          "type": "blob",
          "size": 3.095703125,
          "content": "/*\n * This file is part of Shairport.\n * Copyright (c) Paul Lietar 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#include \"common.h\"\n\nstatic int lock_fd = -1;\nstatic int daemon_pipe[2] = {-1, -1};\n\nvoid daemon_init() {\n    int ret;\n    ret = pipe(daemon_pipe);\n    if (ret < 0)\n        die(\"couldn't create a pipe?!\");\n\n    pid_t pid = fork();\n    if (pid < 0)\n        die(\"failed to fork!\");\n\n    if (pid) {\n        close(daemon_pipe[1]);\n\n        char buf[64];\n        ret = read(daemon_pipe[0], buf, sizeof(buf));\n        if (ret < 0) {\n            // No response from child, something failed\n            fprintf(stderr, \"Spawning the daemon failed.\\n\");\n            exit(1);\n        } else if (buf[0] != 0) {\n            // First byte is non zero, child sent error message\n            write_unchecked(STDERR_FILENO, buf, ret);\n            fprintf(stderr, \"\\n\");\n            exit(1);\n        } else {\n            // Success !\n            if (!config.pidfile)\n                printf(\"%d\\n\", pid);\n            exit(0);\n        }\n    } else {\n        close(daemon_pipe[0]);\n\n        if (config.pidfile) {\n            lock_fd = open(config.pidfile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n            if (lock_fd < 0) {\n                die(\"Could not open pidfile\");\n            }\n\n            ret = lockf(lock_fd,F_TLOCK,0);\n            if (ret < 0) {\n                die(\"Could not lock pidfile. Is an other instance running ?\");\n            }\n\n            dprintf(lock_fd, \"%d\\n\", getpid());\n        }\n    }\n}\n\nvoid daemon_ready() {\n    char ok = 0;\n    write_unchecked(daemon_pipe[1], &ok, 1);\n    close(daemon_pipe[1]);\n    daemon_pipe[1] = -1;\n}\n\nvoid daemon_fail(const char *format, va_list arg) {\n    // Are we still initializing ?\n    if (daemon_pipe[1] > 0) {\n        vdprintf(daemon_pipe[1], format, arg);\n    }\n}\n\nvoid daemon_exit() {\n    if (lock_fd > 0) {\n        lockf_unchecked(lock_fd, F_ULOCK, 0);\n        close(lock_fd);\n        unlink(config.pidfile);\n        lock_fd = -1;\n    }\n}\n\n"
        },
        {
          "name": "daemon.h",
          "type": "blob",
          "size": 0.166015625,
          "content": "#ifndef _DAEMON_H\n#define _DAEMON_H\n\nvoid daemon_init();\nvoid daemon_ready();\nvoid daemon_fail(const char *format, va_list arg);\nvoid daemon_exit();\n\n#endif // _DAEMON_H\n"
        },
        {
          "name": "getopt_long.c",
          "type": "blob",
          "size": 6.142578125,
          "content": "/*\n * getopt_long() -- long options parser\n *\n * Portions Copyright (c) 1987, 1993, 1994\n * The Regents of the University of California.  All rights reserved.\n *\n * Portions Copyright (c) 2003\n * PostgreSQL Global Development Group\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include <string.h>\n#include \"common.h\"\n#include \"getopt_long.h\"\n\n#define BADCH   '?'\n#define BADARG  ':'\n#define EMSG    \"\"\n\n\n/*\n * getopt_long\n *  Parse argc/argv argument vector, with long options.\n *\n * This implementation does not use optreset.  Instead, we guarantee that\n * it can be restarted on a new argv array after a previous call returned -1,\n * if the caller resets optind to 1 before the first call of the new series.\n * (Internally, this means we must be sure to reset \"place\" to EMSG before\n * returning -1.)\n */\nint\ngetopt_long(int argc, char *const argv[],\n            const char *optstring,\n            const struct option * longopts, int *longindex)\n{\n    static char *place = EMSG;  /* option letter processing */\n    char       *oli;            /* option letter list index */\n\n    if (!*place)\n    {                           /* update scanning pointer */\n        if (optind >= argc)\n        {\n            place = EMSG;\n            return -1;\n        }\n\n        place = argv[optind];\n\n        if (place[0] != '-')\n        {\n            place = EMSG;\n            return -1;\n        }\n\n        place++;\n\n        if (place[0] && place[0] == '-' && place[1] == '\\0')\n        {                       /* found \"--\" */\n            ++optind;\n            place = EMSG;\n            return -1;\n        }\n\n        if (place[0] && place[0] == '-' && place[1])\n        {\n            /* long option */\n            size_t      namelen;\n            int         i;\n\n            place++;\n\n            namelen = strcspn(place, \"=\");\n            for (i = 0; longopts[i].name != NULL; i++)\n            {\n                if (strlen(longopts[i].name) == namelen\n                    && strncmp(place, longopts[i].name, namelen) == 0)\n                {\n                    if (longopts[i].has_arg)\n                    {\n                        if (place[namelen] == '=')\n                            optarg = place + namelen + 1;\n                        else if (optind < argc - 1)\n                        {\n                            optind++;\n                            optarg = argv[optind];\n                        }\n                        else\n                        {\n                            if (optstring[0] == ':')\n                                return BADARG;\n                            if (opterr)\n                                warn(\n                                   \"%s: option requires an argument -- %s\\n\",\n                                        argv[0], place);\n                            place = EMSG;\n                            optind++;\n                            return BADCH;\n                        }\n                    }\n                    else\n                    {\n                        optarg = NULL;\n                        if (place[namelen] != 0)\n                        {\n                            /* XXX error? */\n                        }\n                    }\n\n                    optind++;\n\n                    if (longindex)\n                        *longindex = i;\n\n                    place = EMSG;\n\n                    if (longopts[i].flag == NULL)\n                        return longopts[i].val;\n                    else\n                    {\n                        *longopts[i].flag = longopts[i].val;\n                        return 0;\n                    }\n                }\n            }\n\n            if (opterr && optstring[0] != ':')\n                warn(\"illegal option -- %s\\n\", place);\n            place = EMSG;\n            optind++;\n            return BADCH;\n        }\n    }\n\n    /* short option */\n    optopt = (int) *place++;\n\n    oli = strchr(optstring, optopt);\n    if (!oli)\n    {\n        if (!*place)\n            ++optind;\n        if (opterr && *optstring != ':')\n            warn(\"illegal option -- %c\\n\", optopt);\n        return BADCH;\n    }\n\n    if (oli[1] != ':')\n    {                           /* don't need argument */\n        optarg = NULL;\n        if (!*place)\n            ++optind;\n    }\n    else\n    {                           /* need an argument */\n        if (*place)             /* no white space */\n            optarg = place;\n        else if (argc <= ++optind)\n        {                       /* no arg */\n            place = EMSG;\n            if (*optstring == ':')\n                return BADARG;\n            if (opterr)\n                warn(\"option requires an argument -- %c\\n\", optopt);\n            return BADCH;\n        }\n        else\n            /* white space */\n            optarg = argv[optind];\n        place = EMSG;\n        ++optind;\n    }\n    return optopt;\n}\n"
        },
        {
          "name": "getopt_long.h",
          "type": "blob",
          "size": 0.8232421875,
          "content": "/*\n * Portions Copyright (c) 1987, 1993, 1994\n * The Regents of the University of California.  All rights reserved.\n *\n * Portions Copyright (c) 2003-2013, PostgreSQL Global Development Group\n *\n */\n#ifndef GETOPT_LONG_H\n#define GETOPT_LONG_H\n\n#include \"config.h\"\n#ifdef CONFIG_HAVE_GETOPT_H\n\n#include <getopt.h>\n\n#else\n\n/* These are picked up from the system's getopt() facility. */\nextern int  opterr;\nextern int  optind;\nextern int  optopt;\nextern char *optarg;\n\nstruct option\n{\n    const char *name;\n    int         has_arg;\n    int        *flag;\n    int         val;\n};\n\n#define no_argument 0\n#define required_argument 1\n\nextern int getopt_long(int argc, char *const argv[],\n            const char *optstring,\n            const struct option * longopts, int *longindex);\n\n#endif   /* CONFIG_HAVE_GETOPT_H */\n\n#endif   /* GETOPT_LONG_H */\n"
        },
        {
          "name": "mdns.c",
          "type": "blob",
          "size": 3.140625,
          "content": "/*\n * mDNS registration handler. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n#include <memory.h>\n#include <string.h>\n#include \"config.h\"\n#include \"common.h\"\n#include \"mdns.h\"\n\n#ifdef CONFIG_AVAHI\nextern mdns_backend mdns_avahi;\n#endif\n\nextern mdns_backend mdns_external_avahi;\nextern mdns_backend mdns_external_dns_sd;\nextern mdns_backend mdns_tinysvcmdns;\n\n#ifdef CONFIG_HAVE_DNS_SD_H\nextern mdns_backend mdns_dns_sd;\n#endif\n\nstatic mdns_backend *mdns_backends[] = {\n#ifdef CONFIG_AVAHI\n    &mdns_avahi,\n#endif\n#ifdef CONFIG_HAVE_DNS_SD_H\n    &mdns_dns_sd,\n#endif\n    &mdns_external_avahi,\n    &mdns_external_dns_sd,\n    &mdns_tinysvcmdns,\n    NULL\n};\n\nvoid mdns_register(void) {\n    char *mdns_apname = malloc(strlen(config.apname) + 14);\n    char *p = mdns_apname;\n    int i;\n    for (i=0; i<6; i++) {\n        sprintf(p, \"%02X\", config.hw_addr[i]);\n        p += 2;\n    }\n    *p++ = '@';\n    strcpy(p, config.apname);\n\n    mdns_backend **b = NULL;\n    \n    if (config.mdns_name != NULL)\n    {\n        for (b = mdns_backends; *b; b++)\n        {\n            if (strcmp((*b)->name, config.mdns_name) != 0) // Not the one we are looking for\n                continue;\n            int error = (*b)->mdns_register(mdns_apname, config.port);\n            if (error >= 0)\n            {\n                config.mdns = *b;\n            }\n            break;\n        }\n\n        if (*b == NULL)\n            warn(\"%s mDNS backend not found\");\n    }\n    else\n    {\n        for (b = mdns_backends; *b; b++)\n        {\n            int error = (*b)->mdns_register(mdns_apname, config.port);\n            if (error >= 0)\n            {\n                config.mdns = *b;\n                break;\n            }\n        }\n    }\n\n    if (config.mdns == NULL)\n        die(\"Could not establish mDNS advertisement!\");\n}\n\nvoid mdns_unregister(void) {\n    if (config.mdns) {\n        config.mdns->mdns_unregister();\n    }\n}\n\nvoid mdns_ls_backends(void) {\n    mdns_backend **b = NULL;\n    printf(\"Available mDNS backends: \\n\");\n    for (b = mdns_backends; *b; b++)\n    {\n        printf(\"    %s\\n\", (*b)->name);\n    }\n}\n\n"
        },
        {
          "name": "mdns.h",
          "type": "blob",
          "size": 0.501953125,
          "content": "#ifndef _MDNS_H\n#define _MDNS_H\n\nextern int mdns_pid;\n\nvoid mdns_unregister(void);\nvoid mdns_register(void);\nvoid mdns_ls_backends(void);\n\ntypedef struct {\n    char *name;\n    int (*mdns_register)(char *apname, int port);\n    void (*mdns_unregister)(void);\n} mdns_backend;\n\n#define MDNS_RECORD  \"tp=UDP\", \"sm=false\", \"ek=1\", \"et=0,1\", \"cn=0,1\", \"ch=2\", \\\n                \"ss=16\", \"sr=44100\", \"vn=3\", \"txtvers=1\", \"da=true\", \"md=0,1,2\", \\\n                config.password ? \"pw=true\" : \"pw=false\"\n\n#endif // _MDNS_H\n"
        },
        {
          "name": "mdns_avahi.c",
          "type": "blob",
          "size": 4.5458984375,
          "content": "/*\n * Embedded Avahi client. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <avahi-client/client.h>\n#include <avahi-client/publish.h>\n#include <avahi-common/thread-watch.h>\n#include <avahi-common/error.h>\n\n#include <string.h>\n#include \"common.h\"\n#include \"mdns.h\"\n\nstatic AvahiClient *client = NULL;\nstatic AvahiEntryGroup *group = NULL;\nstatic AvahiThreadedPoll *tpoll = NULL;\n\nstatic char *name = NULL;\nstatic int port = 0;\n\nstatic void egroup_callback(AvahiEntryGroup *g,\n                            AvahiEntryGroupState state,\n                            AVAHI_GCC_UNUSED void *userdata) {\n    if (state==AVAHI_ENTRY_GROUP_COLLISION)\n        die(\"service name already exists on network!\");\n    if (state==AVAHI_ENTRY_GROUP_FAILURE)\n        die(\"avahi entry group failure!\");\n}\n\nstatic void register_service(AvahiClient *c) {\n    debug(1, \"avahi: register_service\\n\");\n    if (!group)\n        group = avahi_entry_group_new(c, egroup_callback, NULL);\n    if (!group)\n        die(\"avahi_entry_group_new failed\");\n\n    if (!avahi_entry_group_is_empty(group))\n        return;\n\n    int ret;\n    ret = avahi_entry_group_add_service(group,\n                                        AVAHI_IF_UNSPEC,\n                                        AVAHI_PROTO_UNSPEC,\n                                        0,\n                                        name,\n                                        \"_raop._tcp\",\n                                        NULL,\n                                        NULL,\n                                        port,\n                                        MDNS_RECORD,\n                                        NULL);\n    if (ret < 0)\n        die(\"avahi_entry_group_add_service failed\");\n\n    ret = avahi_entry_group_commit(group);\n    if (ret < 0)\n        die(\"avahi_entry_group_commit failed\");\n}\n\nstatic void client_callback(AvahiClient *c,\n                            AvahiClientState state,\n                            AVAHI_GCC_UNUSED void * userdata) {\n    switch (state) {\n        case AVAHI_CLIENT_S_REGISTERING:\n            if (group)\n                avahi_entry_group_reset(group);\n            break;\n\n        case AVAHI_CLIENT_S_RUNNING:\n            register_service(c);\n            break;\n\n        case AVAHI_CLIENT_FAILURE:\n        case AVAHI_CLIENT_S_COLLISION:\n            die(\"avahi client failure\");\n\n        case AVAHI_CLIENT_CONNECTING:\n            break;\n    }\n}\n\nstatic int avahi_register(char *srvname, int srvport) {\n    debug(1, \"avahi: avahi_register\\n\");\n    name = strdup(srvname);\n    port = srvport;\n\n    int err;\n    if (!(tpoll = avahi_threaded_poll_new())) {\n        warn(\"couldn't create avahi threaded tpoll!\");\n        return -1;\n    }\n    if (!(client = avahi_client_new(avahi_threaded_poll_get(tpoll), \n                                    0,\n                                    client_callback,\n                                    NULL,\n                                    &err))) {\n        warn(\"couldn't create avahi client: %s!\", avahi_strerror(err));\n        return -1;\n    }\n\n    if (avahi_threaded_poll_start(tpoll) < 0) {\n        warn(\"couldn't start avahi tpoll thread\");\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void avahi_unregister(void) {\n    debug(1, \"avahi: avahi_unregister\\n\");\n    if (tpoll)\n        avahi_threaded_poll_stop(tpoll);\n    tpoll = NULL;\n\n    if (name)\n        free(name);\n    name = NULL;\n}\n\nmdns_backend mdns_avahi = \n{\n    .name = \"avahi\",\n    .mdns_register = avahi_register,\n    .mdns_unregister = avahi_unregister\n};\n\n"
        },
        {
          "name": "mdns_dns_sd.c",
          "type": "blob",
          "size": 2.9013671875,
          "content": "/*\n * Embedded dns-sd client. This file is part of Shairport.\n * Copyright (c) Paul Lietar 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <dns_sd.h>\n#include <string.h>\n#include \"mdns.h\"\n#include \"common.h\"\n\nstatic DNSServiceRef service;\n\nstatic int mdns_dns_sd_register(char *apname, int port) {\n    const char *record[] = { MDNS_RECORD, NULL };\n    uint16_t length = 0;\n    const char **field;\n\n    // Concatenate string contained i record into buf.\n\n    for (field = record; *field; field ++)\n    {\n        length += strlen(*field) + 1; // One byte for length each time\n    } \n\n    char *buf = malloc(length * sizeof(char));\n    if (buf == NULL)\n    {\n        warn(\"dns_sd: buffer record allocation failed\");\n        return -1;\n    }\n\n    char *p = buf;\n\n    for (field = record; *field; field ++)\n    {\n        char * newp = stpcpy(p + 1, *field);\n        *p = newp - p - 1;\n        p = newp;\n    }\n\n    DNSServiceErrorType error;\n    error = DNSServiceRegister(&service,\n                               0,\n                               kDNSServiceInterfaceIndexAny,\n                               apname,\n                               \"_raop._tcp\",\n                               \"\",\n                               NULL,\n                               htons((uint16_t)port),\n                               length,\n                               buf,\n                               NULL,\n                               NULL);\n\n    free(buf);\n\n    if (error == kDNSServiceErr_NoError)\n        return 0;\n    else\n    {\n        warn(\"dns-sd: DNSServiceRegister error %d\", error);\n        return -1;\n    }\n}\n\nstatic void mdns_dns_sd_unregister(void) {\n    if (service)\n    {\n        DNSServiceRefDeallocate(service);\n        service = NULL;\n    }\n}\n\nmdns_backend mdns_dns_sd = {\n    .name = \"dns-sd\",\n    .mdns_register = mdns_dns_sd_register,\n    .mdns_unregister = mdns_dns_sd_unregister\n};\n"
        },
        {
          "name": "mdns_external.c",
          "type": "blob",
          "size": 4.275390625,
          "content": "/*\n * mDNS registration handler. This file is part of Shairport.\n * Copyright (c) Paul Lietar 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <unistd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include \"common.h\"\n#include \"mdns.h\"\n\nint mdns_pid = 0;\n\n/*\n * Do a fork followed by a execvp, handling execvp errors correctly.\n * Return the pid of the new process upon success, or -1 if something failed.\n * Check errno for error details.\n */\nstatic int fork_execvp(const char *file, char *const argv[]) {\n    int execpipe[2];\n    int pid = 0;\n    if (pipe(execpipe) < 0) {\n        return -1;\n    }\n\n    if (fcntl(execpipe[1], F_SETFD, fcntl(execpipe[1], F_GETFD) | FD_CLOEXEC) < 0) {\n        close(execpipe[0]);\n        close(execpipe[1]);\n        return -1;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        close(execpipe[0]);\n        close(execpipe[1]);\n        return -1;\n    }\n    else if(pid == 0) { // Child\n        close(execpipe[0]); // Close the read end\n        execvp(file, argv);\n\n        // If we reach this point then execve has failed.\n        // Write erno's value into the pipe and exit.\n        write_unchecked(execpipe[1], &errno, sizeof(errno));\n\n        _exit(-1);\n        return 0; // Just to make the compiler happy.\n    }\n    else { // Parent\n        close(execpipe[1]); // Close the write end\n\n        int childErrno;\n        // Block until child closes the pipe or sends errno.\n        if(read(execpipe[0], &childErrno, sizeof(childErrno)) == sizeof(childErrno)) { // We received errno\n            errno = childErrno;\n            return -1;\n        }\n        else { // Child closed the pipe. execvp was successful.\n            return pid;\n        }\n    }\n}\n\nstatic int mdns_external_avahi_register(char *apname, int port) {\n    char mdns_port[6];\n    sprintf(mdns_port, \"%d\", config.port);\n\n    char *argv[] = {\n        NULL, apname, \"_raop._tcp\", mdns_port, MDNS_RECORD, NULL\n    };\n\n    argv[0] = \"avahi-publish-service\";\n    int pid = fork_execvp(argv[0], argv);\n    if (pid >= 0) {\n        mdns_pid = pid;\n        return 0;\n    }\n    else\n        debug(1, \"Calling %s failed\", argv[0]);\n\n    argv[0] = \"mDNSPublish\";\n    pid = fork_execvp(argv[0], argv);\n    if (pid >= 0)\n    {\n        mdns_pid = pid;\n        return 0;\n    }\n    else\n        debug(1, \"Calling %s failed\", argv[0]);\n    \n    // If we reach here, both execvp calls failed.\n    return -1;\n}\n\nstatic int mdns_external_dns_sd_register(char *apname, int port) {\n    char mdns_port[6];\n    sprintf(mdns_port, \"%d\", config.port);\n\n    char *argv[] = {\"dns-sd\", \"-R\", apname, \"_raop._tcp\", \".\",\n                        mdns_port, MDNS_RECORD, NULL};\n\n    int pid = fork_execvp(argv[0], argv);\n    if (pid >= 0)\n    {\n        mdns_pid = pid;\n        return 0;\n    }\n    else\n        debug(1, \"Calling %s failed\", argv[0]);\n\n    return -1;\n}\n\nstatic void kill_mdns_child(void) {\n    if (mdns_pid)\n        kill(mdns_pid, SIGTERM);\n    mdns_pid = 0;\n}\n\nmdns_backend mdns_external_avahi = {\n    .name = \"external-avahi\",\n    .mdns_register = mdns_external_avahi_register,\n    .mdns_unregister = kill_mdns_child\n};\n\nmdns_backend mdns_external_dns_sd = {\n    .name = \"external-dns-sd\",\n    .mdns_register = mdns_external_dns_sd_register,\n    .mdns_unregister = kill_mdns_child\n};\n\n"
        },
        {
          "name": "mdns_tinysvcmdns.c",
          "type": "blob",
          "size": 4.6064453125,
          "content": "/*\n * mDNS registration handler. This file is part of Shairport.\n * Copyright (c) Paul Lietar 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <net/if.h> \n#include <ifaddrs.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include \"common.h\"\n#include \"mdns.h\"\n\n#include \"tinysvcmdns.h\"\n\nstatic struct mdnsd *svr = NULL;\n\nstatic int mdns_tinysvcmdns_register(char *apname, int port) {\n    struct ifaddrs *ifalist;\n    struct ifaddrs *ifa;\n\n    svr = mdnsd_start();\n    if (svr == NULL) {\n        warn(\"tinysvcmdns: mdnsd_start() failed\");\n        return -1;\n    }\n\n    // room for name + .local + NULL\n    char hostname[100 + 6];\n    gethostname(hostname, 99);\n    // according to POSIX, this may be truncated without a final NULL !\n    hostname[99] = 0;\n\n    // will not work if the hostname doesn't end in .local\n    char *hostend = hostname + strlen(hostname);\n    if ((strlen(hostname) > 6) &&\n        strcmp(hostend - 6, \".local\"))\n    {\n        strcat(hostname, \".local\");\n    }\n\n    if (getifaddrs(&ifalist) < 0)\n    {\n        warn(\"tinysvcmdns: getifaddrs() failed\");\n        return -1;\n    }\n\n    ifa = ifalist;\n\n    // Look for an ipv4/ipv6 non-loopback interface to use as the main one.\n    for (ifa = ifalist; ifa != NULL; ifa = ifa->ifa_next)\n    {\n        if (!(ifa->ifa_flags & IFF_LOOPBACK) && ifa->ifa_addr &&\n            ifa->ifa_addr->sa_family == AF_INET)\n        {\n            uint32_t main_ip = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;\n\n            mdnsd_set_hostname(svr, hostname, main_ip);\n            break;\n        }\n        else if (!(ifa->ifa_flags & IFF_LOOPBACK) && ifa->ifa_addr &&\n                 ifa->ifa_addr->sa_family == AF_INET6)\n        {\n            struct in6_addr *addr = &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;\n\n            mdnsd_set_hostname_v6(svr, hostname, addr);\n            break;\n        }\n    }\n\n    if (ifa == NULL)\n    {\n        warn(\"tinysvcmdns: no non-loopback ipv4 or ipv6 interface found\");\n        return -1;\n    }\n\n\n    // Skip the first one, it was already added by set_hostname\n    for (ifa = ifa->ifa_next; ifa != NULL; ifa = ifa->ifa_next)\n    {\n        if (ifa->ifa_flags & IFF_LOOPBACK) // Skip loop-back interfaces\n            continue;\n\n        switch (ifa->ifa_addr->sa_family)\n        {\n            case AF_INET: { // ipv4\n                    uint32_t ip = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;\n                    struct rr_entry *a_e = rr_create_a(create_nlabel(hostname), ip);\n                    mdnsd_add_rr(svr, a_e);\n                }\n                break;\n            case AF_INET6: { // ipv6\n                    struct in6_addr *addr = &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;\n                    struct rr_entry *aaaa_e = rr_create_aaaa(create_nlabel(hostname), addr);\n                    mdnsd_add_rr(svr, aaaa_e);\n                }\n                break;\n        }\n    }\n\n    freeifaddrs(ifa);\n\n    const char *txt[] = { MDNS_RECORD, NULL };\n    struct mdns_service *svc = mdnsd_register_svc(svr,\n                                apname,\n                                \"_raop._tcp.local\",\n                                port,\n                                NULL,\n                                txt);\n\n    mdns_service_destroy(svc);\n\n    return 0;\n}\n\nstatic void mdns_tinysvcmdns_unregister(void) {\n    if (svr)\n    {\n        mdnsd_stop(svr);\n        svr = NULL;\n    }\n}\n\nmdns_backend mdns_tinysvcmdns = {\n    .name = \"tinysvcmdns\",\n    .mdns_register = mdns_tinysvcmdns_register,\n    .mdns_unregister = mdns_tinysvcmdns_unregister\n};\n\n"
        },
        {
          "name": "metadata.c",
          "type": "blob",
          "size": 4.1884765625,
          "content": "/*\n * Metadate structure and utility methods. This file is part of Shairport.\n * Copyright (c) Benjamin Maus 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <memory.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <openssl/md5.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"common.h\"\n#include \"metadata.h\"\n\nmetadata player_meta;\nstatic int fd = -1;\nstatic int dirty = 0;\n\nvoid metadata_set(char** field, const char* value) {\n    if (*field) {\n        if (!strcmp(*field, value))\n            return;\n        free(*field);\n    }\n    *field = strdup(value);\n    dirty = 1;\n}\n\nvoid metadata_open(void) {\n    if (!config.meta_dir)\n        return;\n\n    const char fn[] = \"now_playing\";\n    size_t pl = strlen(config.meta_dir) + 1 + strlen(fn);\n\n    char* path = malloc(pl+1);\n    snprintf(path, pl+1, \"%s/%s\", config.meta_dir, fn);\n\n    if (mkfifo(path, 0644) && errno != EEXIST)\n        die(\"Could not create metadata FIFO %s\", path);\n\n    fd = open(path, O_WRONLY | O_NONBLOCK);\n    if (fd < 0)\n        debug(1, \"Could not open metadata FIFO %s. Will try again later.\", path);\n\n    free(path);\n}\n\nstatic void metadata_close(void) {\n    close(fd);\n    fd = -1;\n}\n\nstatic void print_one(const char *name, const char *value) {\n    write_unchecked(fd, name, strlen(name));\n    write_unchecked(fd, \"=\", 1);\n    if (value)\n        write_unchecked(fd, value, strlen(value));\n    write_unchecked(fd, \"\\n\", 1);\n}\n\n#define write_one(name) \\\n    print_one(#name, player_meta.name)\n\nvoid metadata_write(void) {\n    int ret;\n\n    // readers may go away and come back\n    if (fd < 0)\n        metadata_open();\n    if (fd < 0)\n        return;\n\n    if (!dirty)\n        return;\n\n    dirty = 0;\n\n    write_one(artist);\n    write_one(title);\n    write_one(album);\n    write_one(artwork);\n    write_one(genre);\n    write_one(comment);\n\n    ret = write(fd, \"\\n\", 1);\n    if (ret < 1)    // no reader\n        metadata_close();\n}\n\nvoid metadata_cover_image(const char *buf, int len, const char *ext) {\n    if (!config.meta_dir)\n        return;\n\n    if (buf) {\n        debug(1, \"Cover Art set\\n\");\n    } else {\n        debug(1, \"Cover Art cleared\\n\");\n        return;\n    }\n\n    uint8_t img_md5[16];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, buf, len);\n    MD5_Final(img_md5, &ctx);\n\n    char img_md5_str[33];\n    int i;\n    for (i = 0; i < 16; i++)\n        sprintf(&img_md5_str[i*2], \"%02x\", (uint8_t)img_md5[i]);\n\n    char *dir = config.meta_dir;\n    char *prefix = \"cover-\";\n\n    size_t pl = strlen(dir) + 1 + strlen(prefix) + strlen(img_md5_str) + 1 + strlen(ext);\n\n    char *path = malloc(pl+1);\n    snprintf(path, pl+1, \"%s/%s%s.%s\", dir, prefix, img_md5_str, ext);\n\n    int cover_fd = open(path, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);\n\n    if (cover_fd < 0) {\n        warn(\"Could not open file %s for writing cover art\", path);\n        return;\n    }\n\n    if (write(cover_fd, buf, len) < len) {\n        warn(\"writing %s failed\\n\", path);\n        free(path);\n        return;\n    }\n    close(cover_fd);\n\n    debug(1, \"Cover Art file is %s\\n\", path);\n    metadata_set(&player_meta.artwork, path+strlen(dir)+1);\n\n    free(path);\n}\n"
        },
        {
          "name": "metadata.h",
          "type": "blob",
          "size": 0.416015625,
          "content": "#ifndef _METADATA_H\n#define _METADATA_H\n\n#include <stdio.h>\n\ntypedef struct {\n    char *artist;\n    char *title;\n    char *album;\n    char *artwork;\n    char *comment;\n    char *genre;\n} metadata;\n\nvoid metadata_set(char** field, const char* value);\nvoid metadata_open(void);\nvoid metadata_write(void);\nvoid metadata_cover_image(const char *buf, int len, const char *ext);\n\nextern metadata player_meta;\n\n#endif // _METADATA_H\n"
        },
        {
          "name": "player.c",
          "type": "blob",
          "size": 15.0263671875,
          "content": "/*\n * Slave-clocked ALAC stream player. This file is part of Shairport.\n * Copyright (c) James Laird 2011, 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <pthread.h>\n#include <openssl/aes.h>\n#include <math.h>\n#include <sys/stat.h>\n#include <sys/signal.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\n#include \"common.h\"\n#include \"player.h\"\n#include \"rtp.h\"\n\n#ifdef FANCY_RESAMPLING\n#include <samplerate.h>\n#endif\n\n#include \"alac.h\"\n\n// parameters from the source\nstatic unsigned char *aesiv;\nstatic AES_KEY aes;\nstatic int sampling_rate, frame_size;\n\n#define FRAME_BYTES(frame_size) (4*frame_size)\n// maximal resampling shift - conservative\n#define OUTFRAME_BYTES(frame_size) (4*(frame_size+3))\n\nstatic pthread_t player_thread;\nstatic int please_stop;\n\nstatic alac_file *decoder_info;\n\n#ifdef FANCY_RESAMPLING\nstatic int fancy_resampling = 1;\nstatic SRC_STATE *src;\n#endif\n\n\n// interthread variables\nstatic double volume = 1.0;\nstatic int fix_volume = 0x10000;\nstatic pthread_mutex_t vol_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n// default buffer size\n// needs to be a power of 2 because of the way BUFIDX(seqno) works\n#define BUFFER_FRAMES  512\n#define MAX_PACKET      2048\n\ntypedef struct audio_buffer_entry {   // decoded audio packets\n    int ready;\n    signed short *data;\n} abuf_t;\nstatic abuf_t audio_buffer[BUFFER_FRAMES];\n#define BUFIDX(seqno) ((seq_t)(seqno) % BUFFER_FRAMES)\n\n// mutex-protected variables\nstatic seq_t ab_read, ab_write;\nstatic int ab_buffering = 1, ab_synced = 0;\nstatic pthread_mutex_t ab_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void bf_est_reset(short fill);\n\nstatic void ab_resync(void) {\n    int i;\n    for (i=0; i<BUFFER_FRAMES; i++)\n        audio_buffer[i].ready = 0;\n    ab_synced = 0;\n    ab_buffering = 1;\n}\n\n// the sequence numbers will wrap pretty often.\n// this returns true if the second arg is after the first\nstatic inline int seq_order(seq_t a, seq_t b) {\n    signed short d = b - a;\n    return d > 0;\n}\n\nstatic void alac_decode(short *dest, uint8_t *buf, int len) {\n    unsigned char packet[MAX_PACKET];\n    assert(len<=MAX_PACKET);\n\n    unsigned char iv[16];\n    int aeslen = len & ~0xf;\n    memcpy(iv, aesiv, sizeof(iv));\n    AES_cbc_encrypt(buf, packet, aeslen, &aes, iv, AES_DECRYPT);\n    memcpy(packet+aeslen, buf+aeslen, len-aeslen);\n\n    int outsize;\n\n    alac_decode_frame(decoder_info, packet, dest, &outsize);\n\n    assert(outsize == FRAME_BYTES(frame_size));\n}\n\n\nstatic int init_decoder(int32_t fmtp[12]) {\n    alac_file *alac;\n\n    frame_size = fmtp[1]; // stereo samples\n    sampling_rate = fmtp[11];\n\n    int sample_size = fmtp[3];\n    if (sample_size != 16)\n        die(\"only 16-bit samples supported!\");\n\n    alac = alac_create(sample_size, 2);\n    if (!alac)\n        return 1;\n    decoder_info = alac;\n\n    alac->setinfo_max_samples_per_frame = frame_size;\n    alac->setinfo_7a =      fmtp[2];\n    alac->setinfo_sample_size = sample_size;\n    alac->setinfo_rice_historymult = fmtp[4];\n    alac->setinfo_rice_initialhistory = fmtp[5];\n    alac->setinfo_rice_kmodifier = fmtp[6];\n    alac->setinfo_7f =      fmtp[7];\n    alac->setinfo_80 =      fmtp[8];\n    alac->setinfo_82 =      fmtp[9];\n    alac->setinfo_86 =      fmtp[10];\n    alac->setinfo_8a_rate = fmtp[11];\n    alac_allocate_buffers(alac);\n    return 0;\n}\n\nstatic void free_decoder(void) {\n    alac_free(decoder_info);\n}\n\n#ifdef FANCY_RESAMPLING\nstatic int init_src(void) {\n    int err;\n    if (fancy_resampling)\n        src = src_new(SRC_SINC_MEDIUM_QUALITY, 2, &err);\n    else\n        src = NULL;\n\n    return err;\n}\nstatic void free_src(void) {\n    src_delete(src);\n    src = NULL;\n}\n#endif\n\nstatic void init_buffer(void) {\n    int i;\n    for (i=0; i<BUFFER_FRAMES; i++)\n        audio_buffer[i].data = malloc(OUTFRAME_BYTES(frame_size));\n    ab_resync();\n}\n\nstatic void free_buffer(void) {\n    int i;\n    for (i=0; i<BUFFER_FRAMES; i++)\n        free(audio_buffer[i].data);\n}\n\nvoid player_put_packet(seq_t seqno, uint8_t *data, int len) {\n    abuf_t *abuf = 0;\n    int16_t buf_fill;\n\n    pthread_mutex_lock(&ab_mutex);\n    if (!ab_synced) {\n        debug(2, \"syncing to first seqno %04X\\n\", seqno);\n        ab_write = seqno-1;\n        ab_read = seqno;\n        ab_synced = 1;\n    }\n    if (seq_diff(ab_write, seqno) == 1) {                  // expected packet\n        abuf = audio_buffer + BUFIDX(seqno);\n        ab_write = seqno;\n    } else if (seq_order(ab_write, seqno)) {    // newer than expected\n        rtp_request_resend(ab_write+1, seqno-1);\n        abuf = audio_buffer + BUFIDX(seqno);\n        ab_write = seqno;\n    } else if (seq_order(ab_read, seqno)) {     // late but not yet played\n        abuf = audio_buffer + BUFIDX(seqno);\n    } else {    // too late.\n        debug(1, \"late packet %04X (%04X:%04X)\", seqno, ab_read, ab_write);\n    }\n    buf_fill = seq_diff(ab_read, ab_write);\n    pthread_mutex_unlock(&ab_mutex);\n\n    if (abuf) {\n        alac_decode(abuf->data, data, len);\n        abuf->ready = 1;\n    }\n\n    pthread_mutex_lock(&ab_mutex);\n    if (ab_buffering && buf_fill >= config.buffer_start_fill) {\n        debug(1, \"buffering over. starting play\\n\");\n        ab_buffering = 0;\n        bf_est_reset(buf_fill);\n    }\n    pthread_mutex_unlock(&ab_mutex);\n}\n\n\nstatic short lcg_rand(void) {\n\tstatic unsigned long lcg_prev = 12345;\n\tlcg_prev = lcg_prev * 69069 + 3;\n\treturn lcg_prev & 0xffff;\n}\n\nstatic inline short dithered_vol(short sample) {\n    static short rand_a, rand_b;\n    long out;\n\n    out = (long)sample * fix_volume;\n    if (fix_volume < 0x10000) {\n        rand_b = rand_a;\n        rand_a = lcg_rand();\n        out += rand_a;\n        out -= rand_b;\n    }\n    return out>>16;\n}\n\ntypedef struct {\n    double hist[2];\n    double a[2];\n    double b[3];\n} biquad_t;\n\nstatic void biquad_init(biquad_t *bq, double a[], double b[]) {\n    bq->hist[0] = bq->hist[1] = 0.0;\n    memcpy(bq->a, a, 2*sizeof(double));\n    memcpy(bq->b, b, 3*sizeof(double));\n}\n\nstatic void biquad_lpf(biquad_t *bq, double freq, double Q) {\n    double w0 = 2.0 * M_PI * freq * frame_size / (double)sampling_rate;\n    double alpha = sin(w0)/(2.0*Q);\n\n    double a_0 = 1.0 + alpha;\n    double b[3], a[2];\n    b[0] = (1.0-cos(w0))/(2.0*a_0);\n    b[1] = (1.0-cos(w0))/a_0;\n    b[2] = b[0];\n    a[0] = -2.0*cos(w0)/a_0;\n    a[1] = (1-alpha)/a_0;\n\n    biquad_init(bq, a, b);\n}\n\nstatic double biquad_filt(biquad_t *bq, double in) {\n    double w = in - bq->a[0]*bq->hist[0] - bq->a[1]*bq->hist[1];\n    double out = bq->b[1]*bq->hist[0] + bq->b[2]*bq->hist[1] + bq->b[0]*w;\n    bq->hist[1] = bq->hist[0];\n    bq->hist[0] = w;\n\n    return out;\n}\n\nstatic double bf_playback_rate = 1.0;\n\nstatic double bf_est_drift = 0.0;   // local clock is slower by\nstatic biquad_t bf_drift_lpf;\nstatic double bf_est_err = 0.0, bf_last_err;\nstatic biquad_t bf_err_lpf, bf_err_deriv_lpf;\nstatic double desired_fill;\nstatic int fill_count;\n\nstatic void bf_est_reset(short fill) {\n    biquad_lpf(&bf_drift_lpf, 1.0/180.0, 0.3);\n    biquad_lpf(&bf_err_lpf, 1.0/10.0, 0.25);\n    biquad_lpf(&bf_err_deriv_lpf, 1.0/2.0, 0.2);\n    fill_count = 0;\n    bf_playback_rate = 1.0;\n    bf_est_err = bf_last_err = 0;\n    desired_fill = fill_count = 0;\n}\n\nstatic void bf_est_update(short fill) {\n    // the rate-matching system needs to decide how full to keep the buffer.\n    // the initial fill is present when the system starts to output samples,\n    // but most output chains will instantly gobble their own buffer's worth of\n    // data. we average for a while to decide where to draw the line.\n    if (fill_count < 1000) {\n        desired_fill += (double)fill/1000.0;\n        fill_count++;\n        return;\n    } else if (fill_count == 1000) {\n        // this information could be used to help estimate our effective latency?\n        debug(1, \"established desired fill of %f frames, \"\n              \"so output chain buffered about %f frames\\n\", desired_fill,\n              config.buffer_start_fill - desired_fill);\n        fill_count++;\n    }\n\n#define CONTROL_A   (1e-4)\n#define CONTROL_B   (1e-1)\n\n    double buf_delta = fill - desired_fill;\n    bf_est_err = biquad_filt(&bf_err_lpf, buf_delta);\n    double err_deriv = biquad_filt(&bf_err_deriv_lpf, bf_est_err - bf_last_err);\n    double adj_error = CONTROL_A * bf_est_err;\n\n    bf_est_drift = biquad_filt(&bf_drift_lpf, CONTROL_B*(adj_error + err_deriv) + bf_est_drift);\n\n    debug(3, \"bf %d err %f drift %f desiring %f ed %f estd %f\\n\",\n          fill, bf_est_err, bf_est_drift, desired_fill, err_deriv, err_deriv + adj_error);\n    bf_playback_rate = 1.0 + adj_error + bf_est_drift;\n\n    bf_last_err = bf_est_err;\n}\n\n// get the next frame, when available. return 0 if underrun/stream reset.\nstatic short *buffer_get_frame(void) {\n    int16_t buf_fill;\n    seq_t read, next;\n    abuf_t *abuf = 0;\n    int i;\n\n    if (ab_buffering)\n        return 0;\n\n    pthread_mutex_lock(&ab_mutex);\n\n    buf_fill = seq_diff(ab_read, ab_write);\n    if (buf_fill < 1 || !ab_synced) {\n        if (buf_fill < 1)\n            warn(\"underrun.\");\n        ab_buffering = 1;\n        pthread_mutex_unlock(&ab_mutex);\n        return 0;\n    }\n    if (buf_fill >= BUFFER_FRAMES) {   // overrunning! uh-oh. restart at a sane distance\n        warn(\"overrun.\");\n        ab_read = ab_write - config.buffer_start_fill;\n    }\n    read = ab_read;\n    ab_read++;\n    buf_fill = seq_diff(ab_read, ab_write);\n    bf_est_update(buf_fill);\n\n    // check if t+16, t+32, t+64, t+128, ... (buffer_start_fill / 2)\n    // packets have arrived... last-chance resend\n    if (!ab_buffering) {\n        for (i = 16; i < (config.buffer_start_fill / 2); i = (i * 2)) {\n            next = ab_read + i;\n            abuf = audio_buffer + BUFIDX(next);\n            if (!abuf->ready) {\n                rtp_request_resend(next, next);\n            }\n        }\n    }\n\n    abuf_t *curframe = audio_buffer + BUFIDX(read);\n    if (!curframe->ready) {\n        debug(1, \"missing frame %04X.\", read);\n        memset(curframe->data, 0, FRAME_BYTES(frame_size));\n    }\n    curframe->ready = 0;\n    pthread_mutex_unlock(&ab_mutex);\n\n    return curframe->data;\n}\n\nstatic int stuff_buffer(double playback_rate, short *inptr, short *outptr) {\n    int i;\n    int stuffsamp = frame_size;\n    int stuff = 0;\n    double p_stuff;\n\n    p_stuff = 1.0 - pow(1.0 - fabs(playback_rate-1.0), frame_size);\n\n    if (rand() < p_stuff * RAND_MAX) {\n        stuff = playback_rate > 1.0 ? -1 : 1;\n        stuffsamp = rand() % (frame_size - 1);\n    }\n\n    pthread_mutex_lock(&vol_mutex);\n    for (i=0; i<stuffsamp; i++) {   // the whole frame, if no stuffing\n        *outptr++ = dithered_vol(*inptr++);\n        *outptr++ = dithered_vol(*inptr++);\n    };\n    if (stuff) {\n        if (stuff==1) {\n            debug(2, \"+++++++++\\n\");\n            // interpolate one sample\n            *outptr++ = dithered_vol(((long)inptr[-2] + (long)inptr[0]) >> 1);\n            *outptr++ = dithered_vol(((long)inptr[-1] + (long)inptr[1]) >> 1);\n        } else if (stuff==-1) {\n            debug(2, \"---------\\n\");\n            inptr++;\n            inptr++;\n        }\n        for (i=stuffsamp; i<frame_size + stuff; i++) {\n            *outptr++ = dithered_vol(*inptr++);\n            *outptr++ = dithered_vol(*inptr++);\n        }\n    }\n    pthread_mutex_unlock(&vol_mutex);\n\n    return frame_size + stuff;\n}\n\nstatic void *player_thread_func(void *arg) {\n    int play_samples;\n\n    signed short *inbuf, *outbuf, *silence;\n    outbuf = malloc(OUTFRAME_BYTES(frame_size));\n    silence = malloc(OUTFRAME_BYTES(frame_size));\n    memset(silence, 0, OUTFRAME_BYTES(frame_size));\n\n#ifdef FANCY_RESAMPLING\n    float *frame, *outframe;\n    SRC_DATA srcdat;\n    if (fancy_resampling) {\n        frame = malloc(frame_size*2*sizeof(float));\n        outframe = malloc(2*frame_size*2*sizeof(float));\n\n        srcdat.data_in = frame;\n        srcdat.data_out = outframe;\n        srcdat.input_frames = FRAME_BYTES(frame_size);\n        srcdat.output_frames = 2*FRAME_BYTES(frame_size);\n        srcdat.src_ratio = 1.0;\n        srcdat.end_of_input = 0;\n    }\n#endif\n\n    while (!please_stop) {\n        inbuf = buffer_get_frame();\n        if (!inbuf)\n            inbuf = silence;\n\n#ifdef FANCY_RESAMPLING\n        if (fancy_resampling) {\n            int i;\n            pthread_mutex_lock(&vol_mutex);\n            for (i=0; i<2*FRAME_BYTES(frame_size); i++) {\n                frame[i] = (float)inbuf[i] / 32768.0;\n                frame[i] *= volume;\n            }\n            pthread_mutex_unlock(&vol_mutex);\n            srcdat.src_ratio = bf_playback_rate;\n            src_process(src, &srcdat);\n            assert(srcdat.input_frames_used == FRAME_BYTES(frame_size));\n            src_float_to_short_array(outframe, outbuf, FRAME_BYTES(frame_size)*2);\n            play_samples = srcdat.output_frames_gen;\n        } else\n#endif\n            play_samples = stuff_buffer(bf_playback_rate, inbuf, outbuf);\n\n        config.output->play(outbuf, play_samples);\n    }\n\n    return 0;\n}\n\n// takes the volume as specified by the airplay protocol\nvoid player_volume(double f) {\n    double linear_volume = pow(10.0, 0.05*f);\n\n    if (config.output->volume) {\n        config.output->volume(linear_volume);\n    } else {\n        pthread_mutex_lock(&vol_mutex);\n        volume = linear_volume;\n        fix_volume = 65536.0 * volume;\n        pthread_mutex_unlock(&vol_mutex);\n    }\n}\nvoid player_flush(void) {\n    pthread_mutex_lock(&ab_mutex);\n    ab_resync();\n    pthread_mutex_unlock(&ab_mutex);\n}\n\nint player_play(stream_cfg *stream) {\n    if (config.buffer_start_fill > BUFFER_FRAMES)\n        die(\"specified buffer starting fill %d > buffer size %d\",\n            config.buffer_start_fill, BUFFER_FRAMES);\n\n    AES_set_decrypt_key(stream->aeskey, 128, &aes);\n    aesiv = stream->aesiv;\n    init_decoder(stream->fmtp);\n    // must be after decoder init\n    init_buffer();\n#ifdef FANCY_RESAMPLING\n    init_src();\n#endif\n\n    please_stop = 0;\n    command_start();\n    config.output->start(sampling_rate);\n    pthread_create(&player_thread, NULL, player_thread_func, NULL);\n\n    return 0;\n}\n\nvoid player_stop(void) {\n    please_stop = 1;\n    pthread_join(player_thread, NULL);\n    config.output->stop();\n    command_stop();\n    free_buffer();\n    free_decoder();\n#ifdef FANCY_RESAMPLING\n    free_src();\n#endif\n}\n"
        },
        {
          "name": "player.h",
          "type": "blob",
          "size": 0.6416015625,
          "content": "#ifndef _PLAYER_H\n#define _PLAYER_H\n\n#include \"audio.h\"\n#include \"metadata.h\"\n\ntypedef struct {\n    uint8_t aesiv[16], aeskey[16];\n    int32_t fmtp[12];\n} stream_cfg;\n\ntypedef uint16_t seq_t;\n\n// wrapped number between two seq_t.\nstatic inline uint16_t seq_diff(seq_t a, seq_t b) {\n    int16_t diff = b - a;\n    return diff;\n}\n\nint player_play(stream_cfg *cfg);\nvoid player_stop(void);\n\nvoid player_volume(double f);\nvoid player_metadata();\nvoid player_cover_image(char *buf, int len, char *ext);\nvoid player_cover_clear();\nvoid player_flush(void);\nvoid player_resync(void);\n\nvoid player_put_packet(seq_t seqno, uint8_t *data, int len);\n\n#endif //_PLAYER_H\n"
        },
        {
          "name": "rtp.c",
          "type": "blob",
          "size": 5.6865234375,
          "content": "/*\n * Apple RTP protocol handler. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <pthread.h>\n#include <signal.h>\n#include <unistd.h>\n#include <memory.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include \"common.h\"\n#include \"player.h\"\n\n// only one RTP session can be active at a time.\nstatic int running = 0;\nstatic int please_shutdown;\n\nstatic SOCKADDR rtp_client;\nstatic int sock;\nstatic pthread_t rtp_thread;\n\nstatic void *rtp_receiver(void *arg) {\n    // we inherit the signal mask (SIGUSR1)\n    uint8_t packet[2048], *pktp;\n\n    ssize_t nread;\n    while (1) {\n        if (please_shutdown)\n            break;\n        nread = recv(sock, packet, sizeof(packet), 0);\n        if (nread < 0)\n            break;\n\n        ssize_t plen = nread;\n        uint8_t type = packet[1] & ~0x80;\n        if (type == 0x54) // sync\n            continue;\n        if (type == 0x60 || type == 0x56) {   // audio data / resend\n            pktp = packet;\n            if (type==0x56) {\n                pktp += 4;\n                plen -= 4;\n            }\n            seq_t seqno = ntohs(*(unsigned short *)(pktp+2));\n\n            pktp += 12;\n            plen -= 12;\n\n            // check if packet contains enough content to be reasonable\n            if (plen >= 16) {\n                player_put_packet(seqno, pktp, plen);\n                continue;\n            }\n            if (type == 0x56 && seqno == 0) {\n                debug(2, \"resend-related request packet received, ignoring.\\n\");\n                continue;\n            }\n            debug(1, \"Unknown RTP packet of type 0x%02X length %d seqno %d\\n\", type, nread, seqno);\n            continue;\n        }\n        warn(\"Unknown RTP packet of type 0x%02X length %d\", type, nread);\n    }\n\n    debug(1, \"RTP thread interrupted. terminating.\\n\");\n    close(sock);\n\n    return NULL;\n}\n\nstatic int bind_port(SOCKADDR *remote) {\n    struct addrinfo hints, *info;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = remote->SAFAMILY;\n    hints.ai_socktype = SOCK_DGRAM;\n    hints.ai_flags = AI_PASSIVE;\n\n    int ret = getaddrinfo(NULL, \"0\", &hints, &info);\n\n    if (ret < 0)\n        die(\"failed to get usable addrinfo?! %s\", gai_strerror(ret));\n\n    sock = socket(remote->SAFAMILY, SOCK_DGRAM, IPPROTO_UDP);\n    ret = bind(sock, info->ai_addr, info->ai_addrlen);\n\n    freeaddrinfo(info);\n\n    if (ret < 0)\n        die(\"could not bind a UDP port!\");\n\n    int sport;\n    SOCKADDR local;\n    socklen_t local_len = sizeof(local);\n    getsockname(sock, (struct sockaddr*)&local, &local_len);\n#ifdef AF_INET6\n    if (local.SAFAMILY == AF_INET6) {\n        struct sockaddr_in6 *sa6 = (struct sockaddr_in6*)&local;\n        sport = htons(sa6->sin6_port);\n    } else\n#endif\n    {\n        struct sockaddr_in *sa = (struct sockaddr_in*)&local;\n        sport = htons(sa->sin_port);\n    }\n\n    return sport;\n}\n\n\nint rtp_setup(SOCKADDR *remote, int cport, int tport) {\n    if (running)\n        die(\"rtp_setup called with active stream!\");\n\n    debug(1, \"rtp_setup: cport=%d tport=%d\\n\", cport, tport);\n\n    // we do our own timing and ignore the timing port.\n    // an audio perfectionist may wish to learn the protocol.\n\n    memcpy(&rtp_client, remote, sizeof(rtp_client));\n#ifdef AF_INET6\n    if (rtp_client.SAFAMILY == AF_INET6) {\n        struct sockaddr_in6 *sa6 = (struct sockaddr_in6*)&rtp_client;\n        sa6->sin6_port = htons(cport);\n    } else\n#endif\n    {\n        struct sockaddr_in *sa = (struct sockaddr_in*)&rtp_client;\n        sa->sin_port = htons(cport);\n    }\n\n    int sport = bind_port(remote);\n\n    debug(1, \"rtp listening on port %d\\n\", sport);\n\n    please_shutdown = 0;\n    pthread_create(&rtp_thread, NULL, &rtp_receiver, NULL);\n\n    running = 1;\n    return sport;\n}\n\nvoid rtp_shutdown(void) {\n    if (!running)\n        die(\"rtp_shutdown called without active stream!\");\n\n    debug(2, \"shutting down RTP thread\\n\");\n    please_shutdown = 1;\n    pthread_kill(rtp_thread, SIGUSR1);\n    void *retval;\n    pthread_join(rtp_thread, &retval);\n    running = 0;\n}\n\nvoid rtp_request_resend(seq_t first, seq_t last) {\n    if (!running)\n        die(\"rtp_request_resend called without active stream!\");\n\n    debug(1, \"requesting resend on %d packets (%04X:%04X)\\n\",\n         seq_diff(first,last) + 1, first, last);\n\n    char req[8];    // *not* a standard RTCP NACK\n    req[0] = 0x80;\n    req[1] = 0x55|0x80;  // Apple 'resend'\n    *(unsigned short *)(req+2) = htons(1);  // our seqnum\n    *(unsigned short *)(req+4) = htons(first);  // missed seqnum\n    *(unsigned short *)(req+6) = htons(last-first+1);  // count\n\n    sendto(sock, req, sizeof(req), 0, (struct sockaddr*)&rtp_client, sizeof(rtp_client));\n}\n"
        },
        {
          "name": "rtp.h",
          "type": "blob",
          "size": 0.2099609375,
          "content": "#ifndef _RTP_H\n#define _RTP_H\n\n#include <sys/socket.h>\n\nint rtp_setup(SOCKADDR *remote, int controlport, int timingport);\nvoid rtp_shutdown(void);\nvoid rtp_request_resend(seq_t first, seq_t last);\n\n#endif // _RTP_H\n"
        },
        {
          "name": "rtsp.c",
          "type": "blob",
          "size": 25.65625,
          "content": "/*\n * RTSP protocol handler. This file is part of Shairport.\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <memory.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/select.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <openssl/md5.h>\n\n#include \"common.h\"\n#include \"player.h\"\n#include \"rtp.h\"\n#include \"mdns.h\"\n#include \"metadata.h\"\n\n#ifdef AF_INET6\n#define INETx_ADDRSTRLEN INET6_ADDRSTRLEN\n#else\n#define INETx_ADDRSTRLEN INET_ADDRSTRLEN\n#endif\n\n// only one thread is allowed to use the player at once.\n// it monitors the request variable (at least when interrupted)\nstatic pthread_mutex_t playing_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic int please_shutdown = 0;\nstatic pthread_t playing_thread;\n\ntypedef struct {\n    int fd;\n    stream_cfg stream;\n    SOCKADDR remote;\n    int running;\n    pthread_t thread;\n} rtsp_conn_info;\n\n// determine if we are the currently playing thread\nstatic inline int rtsp_playing(void) {\n    if (pthread_mutex_trylock(&playing_mutex)) {\n        return pthread_equal(playing_thread, pthread_self());\n    } else {\n        pthread_mutex_unlock(&playing_mutex);\n        return 0;\n    }\n}\n\nstatic void rtsp_take_player(void) {\n    if (rtsp_playing())\n        return;\n\n    if (pthread_mutex_trylock(&playing_mutex)) {\n        debug(1, \"shutting down playing thread\\n\");\n        // XXX minor race condition between please_shutdown and signal delivery\n        please_shutdown = 1;\n        pthread_kill(playing_thread, SIGUSR1);\n        pthread_mutex_lock(&playing_mutex);\n    }\n    playing_thread = pthread_self();\n}\n\nvoid rtsp_shutdown_stream(void) {\n    rtsp_take_player();\n    pthread_mutex_unlock(&playing_mutex);\n}\n\n// keep track of the threads we have spawned so we can join() them\nstatic rtsp_conn_info **conns = NULL;\nstatic int nconns = 0;\nstatic void track_thread(rtsp_conn_info *conn) {\n    conns = realloc(conns, sizeof(rtsp_conn_info*) * (nconns + 1));\n    conns[nconns] = conn;\n    nconns++;\n}\n\nstatic void cleanup_threads(void) {\n    void *retval;\n    int i;\n    debug(2, \"culling threads.\\n\");\n    for (i=0; i<nconns; ) {\n        if (conns[i]->running == 0) {\n            pthread_join(conns[i]->thread, &retval);\n            free(conns[i]);\n            debug(2, \"one joined\\n\");\n            nconns--;\n            if (nconns)\n                conns[i] = conns[nconns];\n        } else {\n            i++;\n        }\n    }\n}\n\n// park a null at the line ending, and return the next line pointer\n// accept \\r, \\n, or \\r\\n\nstatic char *nextline(char *in, int inbuf) {\n    char *out = NULL;\n    while (inbuf) {\n        if (*in == '\\r') {\n            *in++ = 0;\n            out = in;\n        }\n        if (*in == '\\n') {\n            *in++ = 0;\n            out = in;\n        }\n\n        if (out)\n            break;\n\n        in++;\n        inbuf--;\n    }\n    return out;\n}\n\ntypedef struct {\n    int nheaders;\n    char *name[16];\n    char *value[16];\n\n    int contentlength;\n    char *content;\n\n    // for requests\n    char method[16];\n\n    // for responses\n    int respcode;\n} rtsp_message;\n\nstatic rtsp_message * msg_init(void) {\n    rtsp_message *msg = malloc(sizeof(rtsp_message));\n    memset(msg, 0, sizeof(rtsp_message));\n    return msg;\n}\n\nstatic int msg_add_header(rtsp_message *msg, char *name, char *value) {\n    if (msg->nheaders >= sizeof(msg->name)/sizeof(char*)) {\n        warn(\"too many headers?!\");\n        return 1;\n    }\n\n    msg->name[msg->nheaders] = strdup(name);\n    msg->value[msg->nheaders] = strdup(value);\n    msg->nheaders++;\n\n    return 0;\n}\n\nstatic char *msg_get_header(rtsp_message *msg, char *name) {\n    int i;\n    for (i=0; i<msg->nheaders; i++)\n        if (!strcasecmp(msg->name[i], name))\n            return msg->value[i];\n    return NULL;\n}\n\nstatic void msg_free(rtsp_message *msg) {\n    int i;\n    for (i=0; i<msg->nheaders; i++) {\n        free(msg->name[i]);\n        free(msg->value[i]);\n    }\n    if (msg->content)\n        free(msg->content);\n    free(msg);\n}\n\n\nstatic int msg_handle_line(rtsp_message **pmsg, char *line) {\n    rtsp_message *msg = *pmsg;\n\n    if (!msg) {\n        msg = msg_init();\n        *pmsg = msg;\n        char *sp, *p;\n\n        debug(1, \"received request: %s\\n\", line);\n\n        p = strtok_r(line, \" \", &sp);\n        if (!p)\n            goto fail;\n        strncpy(msg->method, p, sizeof(msg->method)-1);\n\n        p = strtok_r(NULL, \" \", &sp);\n        if (!p)\n            goto fail;\n\n        p = strtok_r(NULL, \" \", &sp);\n        if (!p)\n            goto fail;\n        if (strcmp(p, \"RTSP/1.0\"))\n            goto fail;\n\n        return -1;\n    }\n\n    if (strlen(line)) {\n        char *p;\n        p = strstr(line, \": \");\n        if (!p) {\n            warn(\"bad header: >>%s<<\", line);\n            goto fail;\n        }\n        *p = 0;\n        p += 2;\n        msg_add_header(msg, line, p);\n        debug(2, \"    %s: %s\\n\", line, p);\n        return -1;\n    } else {\n        char *cl = msg_get_header(msg, \"Content-Length\");\n        if (cl)\n            return atoi(cl);\n        else\n            return 0;\n    }\n\nfail:\n    *pmsg = NULL;\n    msg_free(msg);\n    return 0;\n}\n\nstatic rtsp_message * rtsp_read_request(int fd) {\n    ssize_t buflen = 512;\n    char *buf = malloc(buflen+1);\n\n    rtsp_message *msg = NULL;\n\n    ssize_t nread;\n    ssize_t inbuf = 0;\n    int msg_size = -1;\n\n    while (msg_size < 0) {\n        if (please_shutdown) {\n            debug(1, \"RTSP shutdown requested\\n\");\n            goto shutdown;\n        }\n        nread = read(fd, buf+inbuf, buflen - inbuf);\n        if (!nread) {\n            debug(1, \"RTSP connection closed\\n\");\n            goto shutdown;\n        }\n        if (nread < 0) {\n            if (errno==EINTR)\n                continue;\n            perror(\"read failure\");\n            goto shutdown;\n        }\n        inbuf += nread;\n\n        char *next;\n        while (msg_size < 0 && (next = nextline(buf, inbuf))) {\n            msg_size = msg_handle_line(&msg, buf);\n\n            if (!msg) {\n                warn(\"no RTSP header received\");\n                goto shutdown;\n            }\n\n            inbuf -= next-buf;\n            if (inbuf)\n                memmove(buf, next, inbuf);\n        }\n    }\n\n    if (msg_size > buflen) {\n        buf = realloc(buf, msg_size);\n        if (!buf) {\n            warn(\"too much content\");\n            goto shutdown;\n        }\n        buflen = msg_size;\n    }\n\n    while (inbuf < msg_size) {\n        nread = read(fd, buf+inbuf, msg_size-inbuf);\n        if (!nread)\n            goto shutdown;\n        if (nread==EINTR)\n            continue;\n        if (nread < 0) {\n            perror(\"read failure\");\n            goto shutdown;\n        }\n        inbuf += nread;\n    }\n\n    msg->contentlength = inbuf;\n    msg->content = buf;\n    return msg;\n\nshutdown:\n    free(buf);\n    if (msg) {\n        msg_free(msg);\n    }\n    return NULL;\n}\n\nstatic void msg_write_response(int fd, rtsp_message *resp) {\n    char pkt[1024];\n    int pktfree = sizeof(pkt);\n    char *p = pkt;\n    int i, n;\n\n    n = snprintf(p, pktfree,\n                 \"RTSP/1.0 %d %s\\r\\n\", resp->respcode,\n                 resp->respcode==200 ? \"OK\" : \"Error\");\n    debug(1, \"sending response: %s\", pkt);\n    pktfree -= n;\n    p += n;\n\n    for (i=0; i<resp->nheaders; i++) {\n        debug(2, \"    %s: %s\\n\", resp->name[i], resp->value[i]);\n        n = snprintf(p, pktfree, \"%s: %s\\r\\n\", resp->name[i], resp->value[i]);\n        pktfree -= n;\n        p += n;\n        if (pktfree <= 0)\n            die(\"Attempted to write overlong RTSP packet\");\n    }\n\n    if (pktfree < 3)\n        die(\"Attempted to write overlong RTSP packet\");\n\n    strcpy(p, \"\\r\\n\");\n    write_unchecked(fd, pkt, p-pkt+2);\n}\n\nstatic void handle_options(rtsp_conn_info *conn,\n                           rtsp_message *req, rtsp_message *resp) {\n    resp->respcode = 200;\n    msg_add_header(resp, \"Public\",\n                   \"ANNOUNCE, SETUP, RECORD, \"\n                   \"PAUSE, FLUSH, TEARDOWN, \"\n                   \"OPTIONS, GET_PARAMETER, SET_PARAMETER\");\n}\n\nstatic void handle_teardown(rtsp_conn_info *conn,\n                            rtsp_message *req, rtsp_message *resp) {\n    if (!rtsp_playing())\n        return;\n    resp->respcode = 200;\n    msg_add_header(resp, \"Connection\", \"close\");\n    please_shutdown = 1;\n}\n\nstatic void handle_flush(rtsp_conn_info *conn,\n                         rtsp_message *req, rtsp_message *resp) {\n    if (!rtsp_playing())\n        return;\n    player_flush();\n    resp->respcode = 200;\n}\n\nstatic void handle_setup(rtsp_conn_info *conn,\n                         rtsp_message *req, rtsp_message *resp) {\n    int cport, tport;\n    char *hdr = msg_get_header(req, \"Transport\");\n    if (!hdr)\n        return;\n\n    char *p;\n    p = strstr(hdr, \"control_port=\");\n    if (!p)\n        return;\n    p = strchr(p, '=') + 1;\n    cport = atoi(p);\n\n    p = strstr(hdr, \"timing_port=\");\n    if (!p)\n        return;\n    p = strchr(p, '=') + 1;\n    tport = atoi(p);\n\n    rtsp_take_player();\n    int sport = rtp_setup(&conn->remote, cport, tport);\n    if (!sport)\n        return;\n\n    player_play(&conn->stream);\n\n    char resphdr[100];\n    snprintf(resphdr, sizeof(resphdr),\n             \"RTP/AVP/UDP;unicast;mode=record;server_port=%d;control_port=%d;timing_port=%d\",\n             sport, sport, sport);\n    msg_add_header(resp, \"Transport\", resphdr);\n\n    msg_add_header(resp, \"Session\", \"1\");\n\n    resp->respcode = 200;\n}\n\nstatic void handle_ignore(rtsp_conn_info *conn,\n                          rtsp_message *req, rtsp_message *resp) {\n    resp->respcode = 200;\n}\n\nstatic void handle_set_parameter_parameter(rtsp_conn_info *conn,\n                                           rtsp_message *req, rtsp_message *resp) {\n    char *cp = req->content;\n    int cp_left = req->contentlength;\n    char *next;\n    while (cp_left && cp) {\n        next = nextline(cp, cp_left);\n        cp_left -= next-cp;\n\n        if (!strncmp(cp, \"volume: \", 8)) {\n            float volume = atof(cp + 8);\n            debug(1, \"volume: %f\\n\", volume);\n            player_volume(volume);\n        } else if(!strncmp(cp, \"progress: \", 10)) {\n            char *progress = cp + 10;\n            debug(1, \"progress: %s\\n\", progress);\n        } else {\n            debug(1, \"unrecognised parameter: >>%s<< (%d)\\n\", cp, strlen(cp));\n        }\n        cp = next;\n    }\n}\n\nstatic void handle_set_parameter_metadata(rtsp_conn_info *conn,\n                                          rtsp_message   *req,\n                                          rtsp_message   *resp) {\n    char *cp = req->content;\n    int cl   = req->contentlength;\n\n    unsigned int off = 8;\n\n    while (off < cl) {\n        char tag[5];\n        strncpy(tag, cp+off, 4);\n        tag[4] = '\\0';\n        off += 4;\n\n        uint32_t vl = ntohl(*(uint32_t *)(cp+off));\n        off += sizeof(uint32_t);\n\n        char *val = malloc(vl+1);\n        strncpy(val, cp+off, vl);\n        val[vl] = '\\0';\n        off += vl;\n\n        debug(2, \"Tag: %s   Content: %s\\n\", tag, val);\n\n        if (!strncmp(tag, \"asal \", 4)) {\n            debug(1, \"META Album: %s\\n\", val);\n            metadata_set(&player_meta.album, val);\n        } else if (!strncmp(tag, \"asar \", 4)) {\n            debug(1, \"META Artist: %s\\n\", val);\n            metadata_set(&player_meta.artist, val);\n        } else if (!strncmp(tag, \"ascm \", 4)) {\n            debug(1, \"META Comment: %s\\n\", val);\n            metadata_set(&player_meta.comment, val);\n        } else if (!strncmp(tag, \"asgn \", 4)) {\n            debug(1, \"META Genre: %s\\n\", val);\n            metadata_set(&player_meta.genre, val);\n        } else if (!strncmp(tag, \"minm \", 4)) {\n            debug(1, \"META Title: %s\\n\", val);\n            metadata_set(&player_meta.title, val);\n        }\n\n        free(val);\n    }\n\n    metadata_write();\n}\n\nstatic void handle_set_parameter_coverart(rtsp_conn_info *conn,\n                                          rtsp_message *req, rtsp_message *resp) {\n    char *cp = req->content;\n    int cl = req->contentlength;\n\n    char *ct = msg_get_header(req, \"Content-Type\");\n\n    if (!strncmp(ct, \"image/jpeg\", 10)) {\n        metadata_cover_image(cp, cl, \"jpg\");\n    } else if (!strncmp(ct, \"image/png\", 9)) {\n        metadata_cover_image(cp, cl, \"png\");\n    } else {\n        metadata_cover_image(NULL, 0, NULL);\n    }\n}\n\nstatic void handle_set_parameter(rtsp_conn_info *conn,\n                                 rtsp_message *req, rtsp_message *resp) {\n    if (!req->contentlength)\n        debug(1, \"received empty SET_PARAMETER request\\n\");\n\n    char *ct = msg_get_header(req, \"Content-Type\");\n\n    if (ct) {\n        debug(2, \"SET_PARAMETER Content-Type: %s\\n\", ct);\n\n        if (!strncmp(ct, \"application/x-dmap-tagged\", 25)) {\n            debug(1, \"received metadata tags in SET_PARAMETER request\\n\");\n\n            handle_set_parameter_metadata(conn, req, resp);\n        } else if (!strncmp(ct, \"image/jpeg\", 10) ||\n                   !strncmp(ct, \"image/png\", 9)   ||\n                   !strncmp(ct, \"image/none\", 10)) {\n            debug(1, \"received image in SET_PARAMETER request\\n\");\n\n            handle_set_parameter_coverart(conn, req, resp);\n         } else if (!strncmp(ct, \"text/parameters\", 15)) {\n            debug(1, \"received parameters in SET_PARAMETER request\\n\");\n\n            handle_set_parameter_parameter(conn, req, resp);\n        } else {\n            debug(1, \"received unknown Content-Type %s in SET_PARAMETER request\\n\", ct);\n        }\n    } else {\n        debug(1, \"missing Content-Type header in SET_PARAMETER request\\n\");\n    }\n\n    resp->respcode = 200;\n}\n\nstatic void handle_announce(rtsp_conn_info *conn,\n                            rtsp_message *req, rtsp_message *resp) {\n\n    char *paesiv = NULL;\n    char *prsaaeskey = NULL;\n    char *pfmtp = NULL;\n    char *cp = req->content;\n    int cp_left = req->contentlength;\n    char *next;\n    while (cp_left && cp) {\n        next = nextline(cp, cp_left);\n        cp_left -= next-cp;\n\n        if (!strncmp(cp, \"a=fmtp:\", 7))\n            pfmtp = cp+7;\n\n        if (!strncmp(cp, \"a=aesiv:\", 8))\n            paesiv = cp+8;\n\n        if (!strncmp(cp, \"a=rsaaeskey:\", 12))\n            prsaaeskey = cp+12;\n\n        cp = next;\n    }\n\n    if (!paesiv || !prsaaeskey || !pfmtp) {\n        warn(\"required params missing from announce\");\n        return;\n    }\n\n    int len, keylen;\n    uint8_t *aesiv = base64_dec(paesiv, &len);\n    if (len != 16) {\n        warn(\"client announced aeskey of %d bytes, wanted 16\", len);\n        free(aesiv);\n        return;\n    }\n    memcpy(conn->stream.aesiv, aesiv, 16);\n    free(aesiv);\n\n    uint8_t *rsaaeskey = base64_dec(prsaaeskey, &len);\n    uint8_t *aeskey = rsa_apply(rsaaeskey, len, &keylen, RSA_MODE_KEY);\n    free(rsaaeskey);\n    if (keylen != 16) {\n        warn(\"client announced rsaaeskey of %d bytes, wanted 16\", keylen);\n        free(aeskey);\n        return;\n    }\n    memcpy(conn->stream.aeskey, aeskey, 16);\n    free(aeskey);\n\n    int i;\n    for (i=0; i<sizeof(conn->stream.fmtp)/sizeof(conn->stream.fmtp[0]); i++)\n        conn->stream.fmtp[i] = atoi(strsep(&pfmtp, \" \\t\"));\n\n    resp->respcode = 200;\n}\n\n\nstatic struct method_handler {\n    char *method;\n    void (*handler)(rtsp_conn_info *conn, rtsp_message *req,\n                    rtsp_message *resp);\n} method_handlers[] = {\n    {\"OPTIONS\",         handle_options},\n    {\"ANNOUNCE\",        handle_announce},\n    {\"FLUSH\",           handle_flush},\n    {\"TEARDOWN\",        handle_teardown},\n    {\"SETUP\",           handle_setup},\n    {\"GET_PARAMETER\",   handle_ignore},\n    {\"SET_PARAMETER\",   handle_set_parameter},\n    {\"RECORD\",          handle_ignore},\n    {NULL,              NULL}\n};\n\nstatic void apple_challenge(int fd, rtsp_message *req, rtsp_message *resp) {\n    char *hdr = msg_get_header(req, \"Apple-Challenge\");\n    if (!hdr)\n        return;\n\n    SOCKADDR fdsa;\n    socklen_t sa_len = sizeof(fdsa);\n    getsockname(fd, (struct sockaddr*)&fdsa, &sa_len);\n\n    int chall_len;\n    uint8_t *chall = base64_dec(hdr, &chall_len);\n    uint8_t buf[48], *bp = buf;\n    int i;\n    memset(buf, 0, sizeof(buf));\n\n    if (chall_len > 16) {\n        warn(\"oversized Apple-Challenge!\");\n        free(chall);\n        return;\n    }\n    memcpy(bp, chall, chall_len);\n    free(chall);\n    bp += chall_len;\n\n#ifdef AF_INET6\n    if (fdsa.SAFAMILY == AF_INET6) {\n        struct sockaddr_in6 *sa6 = (struct sockaddr_in6*)(&fdsa);\n        memcpy(bp, sa6->sin6_addr.s6_addr, 16);\n        bp += 16;\n    } else\n#endif\n    {\n        struct sockaddr_in *sa = (struct sockaddr_in*)(&fdsa);\n        memcpy(bp, &sa->sin_addr.s_addr, 4);\n        bp += 4;\n    }\n\n    for (i=0; i<6; i++)\n        *bp++ = config.hw_addr[i];\n\n    int buflen, resplen;\n    buflen = bp-buf;\n    if (buflen < 0x20)\n        buflen = 0x20;\n\n    uint8_t *challresp = rsa_apply(buf, buflen, &resplen, RSA_MODE_AUTH);\n    char *encoded = base64_enc(challresp, resplen);\n\n    // strip the padding.\n    char *padding = strchr(encoded, '=');\n    if (padding)\n        *padding = 0;\n\n    msg_add_header(resp, \"Apple-Response\", encoded);\n    free(challresp);\n    free(encoded);\n}\n\nstatic char *make_nonce(void) {\n    uint8_t random[8];\n    int fd = open(\"/dev/random\", O_RDONLY);\n    if (fd < 0)\n        die(\"could not open /dev/random!\");\n    read_unchecked(fd, random, sizeof(random));\n    close(fd);\n    return base64_enc(random, 8);\n}\n\nstatic int rtsp_auth(char **nonce, rtsp_message *req, rtsp_message *resp) {\n\n    if (!config.password)\n        return 0;\n    if (!*nonce) {\n        *nonce = make_nonce();\n        goto authenticate;\n    }\n\n    char *hdr = msg_get_header(req, \"Authorization\");\n    if (!hdr || strncmp(hdr, \"Digest \", 7))\n        goto authenticate;\n\n    char *realm = strstr(hdr, \"realm=\\\"\");\n    char *username = strstr(hdr, \"username=\\\"\");\n    char *response = strstr(hdr, \"response=\\\"\");\n    char *uri = strstr(hdr, \"uri=\\\"\");\n\n    if (!realm || !username || !response || !uri)\n        goto authenticate;\n\n    char *quote;\n    realm = strchr(realm, '\"') + 1;\n    if (!(quote = strchr(realm, '\"')))\n        goto authenticate;\n    *quote = 0;\n    username = strchr(username, '\"') + 1;\n    if (!(quote = strchr(username, '\"')))\n        goto authenticate;\n    *quote = 0;\n    response = strchr(response, '\"') + 1;\n    if (!(quote = strchr(response, '\"')))\n        goto authenticate;\n    *quote = 0;\n    uri = strchr(uri, '\"') + 1;\n    if (!(quote = strchr(uri, '\"')))\n        goto authenticate;\n    *quote = 0;\n\n    uint8_t digest_urp[16], digest_mu[16], digest_total[16];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, username, strlen(username));\n    MD5_Update(&ctx, \":\", 1);\n    MD5_Update(&ctx, realm, strlen(realm));\n    MD5_Update(&ctx, \":\", 1);\n    MD5_Update(&ctx, config.password, strlen(config.password));\n    MD5_Final(digest_urp, &ctx);\n\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, req->method, strlen(req->method));\n    MD5_Update(&ctx, \":\", 1);\n    MD5_Update(&ctx, uri, strlen(uri));\n    MD5_Final(digest_mu, &ctx);\n\n    int i;\n    char buf[33];\n    for (i=0; i<16; i++)\n        sprintf(buf + 2*i, \"%02x\", digest_urp[i]);\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, buf, 32);\n    MD5_Update(&ctx, \":\", 1);\n    MD5_Update(&ctx, *nonce, strlen(*nonce));\n    MD5_Update(&ctx, \":\", 1);\n    for (i=0; i<16; i++)\n        sprintf(buf + 2*i, \"%02x\", digest_mu[i]);\n    MD5_Update(&ctx, buf, 32);\n    MD5_Final(digest_total, &ctx);\n\n    for (i=0; i<16; i++)\n        sprintf(buf + 2*i, \"%02x\", digest_total[i]);\n\n    if (!strcmp(response, buf))\n        return 0;\n    warn(\"auth failed\");\n\nauthenticate:\n    resp->respcode = 401;\n    int hdrlen = strlen(*nonce) + 40;\n    char *authhdr = malloc(hdrlen);\n    snprintf(authhdr, hdrlen, \"Digest realm=\\\"taco\\\", nonce=\\\"%s\\\"\", *nonce);\n    msg_add_header(resp, \"WWW-Authenticate\", authhdr);\n    free(authhdr);\n    return 1;\n}\n\nstatic void *rtsp_conversation_thread_func(void *pconn) {\n    // SIGUSR1 is used to interrupt this thread if blocked for read\n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGUSR1);\n    pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n    rtsp_conn_info *conn = pconn;\n\n    rtsp_message *req, *resp;\n    char *hdr, *auth_nonce = NULL;\n    while ((req = rtsp_read_request(conn->fd))) {\n        resp = msg_init();\n        resp->respcode = 400;\n\n        apple_challenge(conn->fd, req, resp);\n        hdr = msg_get_header(req, \"CSeq\");\n        if (hdr)\n            msg_add_header(resp, \"CSeq\", hdr);\n        msg_add_header(resp, \"Audio-Jack-Status\", \"connected; type=analog\");\n\n        if (rtsp_auth(&auth_nonce, req, resp))\n            goto respond;\n\n        struct method_handler *mh;\n        for (mh=method_handlers; mh->method; mh++) {\n            if (!strcmp(mh->method, req->method)) {\n                mh->handler(conn, req, resp);\n                break;\n            }\n        }\n\nrespond:\n        msg_write_response(conn->fd, resp);\n        msg_free(req);\n        msg_free(resp);\n    }\n\n    debug(1, \"closing RTSP connection\\n\");\n    if (conn->fd > 0)\n        close(conn->fd);\n    if (rtsp_playing()) {\n        rtp_shutdown();\n        player_stop();\n        please_shutdown = 0;\n        pthread_mutex_unlock(&playing_mutex);\n    }\n    if (auth_nonce)\n        free(auth_nonce);\n    conn->running = 0;\n    debug(2, \"terminating RTSP thread\\n\");\n    return NULL;\n}\n\n// this function is not thread safe.\nstatic const char* format_address(struct sockaddr *fsa) {\n    static char string[INETx_ADDRSTRLEN];\n    void *addr;\n#ifdef AF_INET6\n    if (fsa->sa_family == AF_INET6) {\n        struct sockaddr_in6 *sa6 = (struct sockaddr_in6*)(fsa);\n        addr = &(sa6->sin6_addr);\n    } else\n#endif\n    {\n        struct sockaddr_in *sa = (struct sockaddr_in*)(fsa);\n        addr = &(sa->sin_addr);\n    }\n    return inet_ntop(fsa->sa_family, addr, string, sizeof(string));\n}\n\nvoid rtsp_listen_loop(void) {\n    struct addrinfo hints, *info, *p;\n    char portstr[6];\n    int *sockfd = NULL;\n    int nsock = 0;\n    int i, ret;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n\n    snprintf(portstr, 6, \"%d\", config.port);\n\n    ret = getaddrinfo(NULL, portstr, &hints, &info);\n    if (ret) {\n        die(\"getaddrinfo failed: %s\", gai_strerror(ret));\n    }\n\n    for (p=info; p; p=p->ai_next) {\n        int fd = socket(p->ai_family, p->ai_socktype, IPPROTO_TCP);\n        int yes = 1;\n\n        ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n\n#ifdef IPV6_V6ONLY\n        // some systems don't support v4 access on v6 sockets, but some do.\n        // since we need to account for two sockets we might as well\n        // always.\n        if (p->ai_family == AF_INET6)\n            ret |= setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof(yes));\n#endif\n\n        if (!ret)\n            ret = bind(fd, p->ai_addr, p->ai_addrlen);\n\n        // one of the address families will fail on some systems that\n        // report its availability. do not complain.\n        if (ret) {\n            debug(1, \"Failed to bind to address %s\\n\", format_address(p->ai_addr));\n            continue;\n        }\n        debug(1, \"Bound to address %s\\n\", format_address(p->ai_addr));\n\n        listen(fd, 5);\n        nsock++;\n        sockfd = realloc(sockfd, nsock*sizeof(int));\n        sockfd[nsock-1] = fd;\n    }\n\n    freeaddrinfo(info);\n\n    if (!nsock)\n        die(\"could not bind any listen sockets!\");\n\n\n    int maxfd = -1;\n    fd_set fds;\n    FD_ZERO(&fds);\n    for (i=0; i<nsock; i++) {\n        if (sockfd[i] > maxfd)\n            maxfd = sockfd[i];\n    }\n\n    mdns_register();\n\n    printf(\"Listening for connections.\\n\");\n    shairport_startup_complete();\n\n    int acceptfd;\n    struct timeval tv;\n    while (1) {\n        tv.tv_sec = 300;\n        tv.tv_usec = 0;\n\n        for (i=0; i<nsock; i++)\n            FD_SET(sockfd[i], &fds);\n\n        ret = select(maxfd+1, &fds, 0, 0, &tv);\n        if (ret<0) {\n            if (errno==EINTR)\n                continue;\n            break;\n        }\n\n        cleanup_threads();\n\n        acceptfd = -1;\n        for (i=0; i<nsock; i++) {\n            if (FD_ISSET(sockfd[i], &fds)) {\n                acceptfd = sockfd[i];\n                break;\n            }\n        }\n        if (acceptfd < 0) // timeout\n            continue;\n\n        rtsp_conn_info *conn = malloc(sizeof(rtsp_conn_info));\n        memset(conn, 0, sizeof(rtsp_conn_info));\n        socklen_t slen = sizeof(conn->remote);\n\n        debug(1, \"new RTSP connection\\n\");\n        conn->fd = accept(acceptfd, (struct sockaddr *)&conn->remote, &slen);\n        if (conn->fd < 0) {\n            perror(\"failed to accept connection\");\n            free(conn);\n        } else {\n            pthread_t rtsp_conversation_thread;\n            ret = pthread_create(&rtsp_conversation_thread, NULL, rtsp_conversation_thread_func, conn);\n            if (ret)\n                die(\"Failed to create RTSP receiver thread!\");\n\n            conn->thread = rtsp_conversation_thread;\n            conn->running = 1;\n            track_thread(conn);\n        }\n    }\n    perror(\"select\");\n    die(\"fell out of the RTSP select loop\");\n}\n"
        },
        {
          "name": "rtsp.h",
          "type": "blob",
          "size": 0.111328125,
          "content": "#ifndef _RTSP_H\n#define _RTSP_H\n\nvoid rtsp_listen_loop(void);\nvoid rtsp_shutdown_stream(void);\n\n#endif // _RTSP_H\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shairport.c",
          "type": "blob",
          "size": 10.3564453125,
          "content": "/*\n * Shairport, an Apple Airplay receiver\n * Copyright (c) James Laird 2013\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <memory.h>\n#include <openssl/md5.h>\n#include <sys/wait.h>\n#include <getopt.h>\n#include \"common.h\"\n#include \"daemon.h\"\n#include \"rtsp.h\"\n#include \"mdns.h\"\n#include \"getopt_long.h\"\n#include \"metadata.h\"\n\nstatic const char *version =\n    #include \"version.h\"\n    ;\n\nstatic void log_setup();\n\nstatic int shutting_down = 0;\n\nvoid shairport_shutdown(int retval) {\n    if (shutting_down)\n        return;\n    shutting_down = 1;\n    printf(\"Shutting down...\\n\");\n    mdns_unregister();\n    rtsp_shutdown_stream();\n    if (config.output)\n        config.output->deinit();\n    daemon_exit(); // This does nothing if not in daemon mode\n\n    exit(retval);\n}\n\nstatic void sig_ignore(int foo, siginfo_t *bar, void *baz) {\n}\nstatic void sig_shutdown(int foo, siginfo_t *bar, void *baz) {\n    shairport_shutdown(0);\n}\n\nstatic void sig_child(int foo, siginfo_t *bar, void *baz) {\n    pid_t pid;\n    while ((pid = waitpid((pid_t)-1, 0, WNOHANG)) > 0) {\n        if (pid == mdns_pid && !shutting_down) {\n            die(\"MDNS child process died unexpectedly!\");\n        }\n    }\n}\n\nstatic void sig_logrotate(int foo, siginfo_t *bar, void *baz) {\n    log_setup();\n}\n\nvoid usage(char *progname) {\n    printf(\"Usage: %s [options...]\\n\", progname);\n    printf(\"  or:  %s [options...] -- [audio output-specific options]\\n\", progname);\n\n    printf(\"\\n\");\n    printf(\"Mandatory arguments to long options are mandatory for short options too.\\n\");\n\n    printf(\"\\n\");\n    printf(\"Options:\\n\");\n    printf(\"    -h, --help          show this help\\n\");\n    printf(\"    -p, --port=PORT     set RTSP listening port\\n\");\n    printf(\"    -a, --name=NAME     set advertised name\\n\");\n    printf(\"    -k, --password=PW   require password to stream audio\\n\");\n    printf(\"    -b FILL             set how full the buffer must be before audio output\\n\");\n    printf(\"                        starts. This value is in frames; default %d\\n\", config.buffer_start_fill);\n    printf(\"    -d, --daemon        fork (daemonise). The PID of the child process is\\n\");\n    printf(\"                        written to stdout, unless a pidfile is used.\\n\");\n    printf(\"    -P, --pidfile=FILE  write daemon's pid to FILE on startup.\\n\");\n    printf(\"                        Has no effect if -d is not specified\\n\");\n    printf(\"    -l, --log=FILE      redirect shairport's standard output to FILE\\n\");\n    printf(\"                        If --error is not specified, it also redirects\\n\");\n    printf(\"                        error output to FILE\\n\");\n    printf(\"    -e, --error=FILE    redirect shairport's standard error output to FILE\\n\");\n    printf(\"    -B, --on-start=COMMAND  run a shell command when playback begins\\n\");\n    printf(\"    -E, --on-stop=COMMAND   run a shell command when playback ends\\n\");\n    printf(\"    -w, --wait-cmd          block while the shell command(s) run\\n\");\n    printf(\"    -M, --meta-dir=DIR      set a directory to write metadata and album cover art to\\n\");\n\n    printf(\"    -o, --output=BACKEND    select audio output method\\n\");\n    printf(\"    -m, --mdns=BACKEND      force the use of BACKEND to advertise the service\\n\");\n    printf(\"                            if no mdns provider is specified,\\n\");\n    printf(\"                            shairport tries them all until one works.\\n\");\n\n    printf(\"\\n\");\n    mdns_ls_backends();\n    printf(\"\\n\");\n    audio_ls_outputs();\n}\n\nint parse_options(int argc, char **argv) {\n    // prevent unrecognised arguments from being shunted to the audio driver\n    setenv(\"POSIXLY_CORRECT\", \"\", 1);\n\n    static struct option long_options[] = {\n        {\"help\",      no_argument,        NULL, 'h'},\n        {\"daemon\",    no_argument,        NULL, 'd'},\n        {\"pidfile\",   required_argument,  NULL, 'P'},\n        {\"log\",       required_argument,  NULL, 'l'},\n        {\"error\",     required_argument,  NULL, 'e'},\n        {\"port\",      required_argument,  NULL, 'p'},\n        {\"name\",      required_argument,  NULL, 'a'},\n        {\"password\",  required_argument,  NULL, 'k'},\n        {\"output\",    required_argument,  NULL, 'o'},\n        {\"on-start\",  required_argument,  NULL, 'B'},\n        {\"on-stop\",   required_argument,  NULL, 'E'},\n        {\"wait-cmd\",  no_argument,        NULL, 'w'},\n        {\"meta-dir\",  required_argument,  NULL, 'M'},\n        {\"mdns\",      required_argument,  NULL, 'm'},\n        {NULL,        0,                  NULL,   0}\n    };\n\n    int opt;\n    while ((opt = getopt_long(argc, argv,\n                              \"+hdvP:l:e:p:a:k:o:b:B:E:M:wm:\",\n                              long_options, NULL)) > 0) {\n        switch (opt) {\n            default:\n                usage(argv[0]);\n                exit(1);\n            case 'h':\n                usage(argv[0]);\n                exit(0);\n            case 'd':\n                config.daemonise = 1;\n                break;\n            case 'v':\n                debuglev++;\n                break;\n            case 'p':\n                config.port = atoi(optarg);\n                break;\n            case 'a':\n                config.apname = optarg;\n                break;\n            case 'o':\n                config.output_name = optarg;\n                break;\n            case 'k':\n                config.password = optarg;\n                break;\n            case 'b':\n                config.buffer_start_fill = atoi(optarg);\n                break;\n            case 'B':\n                config.cmd_start = optarg;\n                break;\n            case 'E':\n                config.cmd_stop = optarg;\n                break;\n            case 'w':\n                config.cmd_blocking = 1;\n                break;\n            case 'M':\n                config.meta_dir = optarg;\n                break;\n            case 'P':\n                config.pidfile = optarg;\n                break;\n            case 'l':\n                config.logfile = optarg;\n                break;\n            case 'e':\n                config.errfile = optarg;\n                break;\n            case 'm':\n                config.mdns_name = optarg;\n                break;\n        }\n    }\n    return optind;\n}\n\nvoid signal_setup(void) {\n    // mask off all signals before creating threads.\n    // this way we control which thread gets which signals.\n    // for now, we don't care which thread gets the following.\n    sigset_t set;\n    sigfillset(&set);\n    sigdelset(&set, SIGINT);\n    sigdelset(&set, SIGTERM);\n    sigdelset(&set, SIGHUP);\n    sigdelset(&set, SIGSTOP);\n    sigdelset(&set, SIGCHLD);\n    pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n    // setting this to SIG_IGN would prevent signalling any threads.\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_flags = SA_SIGINFO;\n    sa.sa_sigaction = &sig_ignore;\n    sigaction(SIGUSR1, &sa, NULL);\n\n    sa.sa_flags = SA_SIGINFO | SA_RESTART;\n    sa.sa_sigaction = &sig_shutdown;\n    sigaction(SIGINT, &sa, NULL);\n    sigaction(SIGTERM, &sa, NULL);\n\n    sa.sa_sigaction = &sig_logrotate;\n    sigaction(SIGHUP, &sa, NULL);\n\n    sa.sa_sigaction = &sig_child;\n    sigaction(SIGCHLD, &sa, NULL);\n}\n\n// forked daemon lets the spawner know it's up and running OK\n// should be called only once!\nvoid shairport_startup_complete(void) {\n    if (config.daemonise) {\n        daemon_ready();\n    }\n}\n\nvoid log_setup() {\n    if (config.logfile) {\n        int log_fd = open(config.logfile,\n                O_WRONLY | O_CREAT | O_APPEND,\n                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n        if (log_fd < 0)\n            die(\"Could not open logfile\");\n\n        dup2(log_fd, STDOUT_FILENO);\n        setvbuf (stdout, NULL, _IOLBF, BUFSIZ);\n\n        if (!config.errfile) {\n            dup2(log_fd, STDERR_FILENO);\n            setvbuf (stderr, NULL, _IOLBF, BUFSIZ);\n        }\n    }\n\n    if (config.errfile) {\n        int err_fd = open(config.errfile,\n                O_WRONLY | O_CREAT | O_APPEND,\n                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n        if (err_fd < 0)\n            die(\"Could not open logfile\");\n\n        dup2(err_fd, STDERR_FILENO);\n        setvbuf (stderr, NULL, _IOLBF, BUFSIZ);\n    }\n}\n\nint main(int argc, char **argv) {\n    printf(\"Starting Shairport %s\\n\", version);\n\n    signal_setup();\n    memset(&config, 0, sizeof(config));\n\n    // set defaults\n    config.buffer_start_fill = 220;\n    config.port = 5002;\n    char hostname[100];\n    gethostname(hostname, 100);\n    config.apname = malloc(20 + 100);\n    snprintf(config.apname, 20 + 100, \"Shairport on %s\", hostname);\n\n    // parse arguments into config\n    int audio_arg = parse_options(argc, argv);\n\n    // mDNS supports maximum of 63-character names (we append 13).\n    if (strlen(config.apname) > 50)\n        die(\"Supplied name too long (max 50 characters)\");\n\n    if (config.daemonise) {\n        daemon_init();\n    }\n\n    log_setup();\n\n    config.output = audio_get_output(config.output_name);\n    if (!config.output) {\n        audio_ls_outputs();\n        die(\"Invalid audio output specified!\");\n    }\n    config.output->init(argc-audio_arg, argv+audio_arg);\n\n    uint8_t ap_md5[16];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, config.apname, strlen(config.apname));\n    MD5_Final(ap_md5, &ctx);\n    memcpy(config.hw_addr, ap_md5, sizeof(config.hw_addr));\n\n    if (config.meta_dir)\n        metadata_open();\n\n    rtsp_listen_loop();\n\n    // should not.\n    shairport_shutdown(1);\n    return 1;\n}\n"
        },
        {
          "name": "tinysvcmdns.c",
          "type": "blob",
          "size": 54.04296875,
          "content": "// This file is the concatenation of mdnsd.c and mdns.c\n// from tinysvcmdns with minor modifications\n// The code was taken from https://bitbucket.org/geekman/tinysvcmdns at revision e34b562\n\n/*\n * tinysvcmdns - a tiny MDNS implementation for publishing services\n * Copyright (C) 2011 Darell Tan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"tinysvcmdns.h\"\n#include \"common.h\"\n\n#define DEBUG_PRINTF(...) debug(1, __VA_ARGS__)\n#define log_message(level, ...)         \\\n    do {                                \\\n        switch(level)                   \\\n        {                               \\\n            case LOG_ERR:               \\\n                warn(__VA_ARGS__);      \\\n                break;                  \\\n            default:                    \\\n                debug(1, __VA_ARGS__);   \\\n        }                               \\\n    } while (0)\n\n\n//******************************************************//\n//                      mdns.c                          //\n//******************************************************//\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef _WIN32\n#include <winsock.h>\n#include <in6addr.h>\n#else\n#include <netinet/in.h>\n#endif\n\n\n#define DEFAULT_TTL             120\n\n\nstruct name_comp {\n        uint8_t *label; // label\n        size_t pos;             // position in msg\n\n        struct name_comp *next;\n};\n\n// ----- label functions -----\n\n// duplicates a name\ninline uint8_t *dup_nlabel(const uint8_t *n) {\n        assert(n[0] <= 63);     // prevent mis-use\n        return (uint8_t *) strdup((char *) n);\n}\n\n// duplicates a label\nuint8_t *dup_label(const uint8_t *label) {\n        int len = *label + 1;\n        if (len > 63)\n                return NULL;\n        uint8_t *newlabel = malloc(len + 1);\n        strncpy((char *) newlabel, (char *) label, len);\n        newlabel[len] = '\\0';\n        return newlabel;\n}\n\nuint8_t *join_nlabel(const uint8_t *n1, const uint8_t *n2) {\n        int len1, len2;\n        uint8_t *s;\n\n        assert(n1[0] <= 63 && n2[0] <= 63);     // detect misuse\n\n        len1 = strlen((char *) n1);\n        len2 = strlen((char *) n2);\n\n        s = malloc(len1 + len2 + 1);\n        strncpy((char *) s, (char *) n1, len1);\n        strncpy((char *) s+len1, (char *) n2, len2);\n        s[len1 + len2] = '\\0';\n        return s;\n}\n\n// returns a human-readable name label in dotted form\nchar *nlabel_to_str(const uint8_t *name) {\n        char *label, *labelp;\n        const uint8_t *p;\n\n        assert(name != NULL);\n\n        label = labelp = malloc(256);\n\n        for (p = name; *p; p++) {\n                strncpy(labelp, (char *) p + 1, *p);\n                labelp += *p;\n                *labelp = '.';\n                labelp++;\n\n                p += *p;\n        }\n\n        *labelp = '\\0';\n\n        return label;\n}\n\n// returns the length of a label field\n// does NOT uncompress the field, so it could be as small as 2 bytes\n// or 1 for the root\nstatic size_t label_len(uint8_t *pkt_buf, size_t pkt_len, size_t off) {\n        uint8_t *p;\n        uint8_t *e = pkt_buf + pkt_len;\n        size_t len = 0;\n\n        for (p = pkt_buf + off; p < e; p++) {\n                if (*p == 0) {\n                        return len + 1;\n                } else if ((*p & 0xC0) == 0xC0) {\n                        return len + 2;\n                } else {\n                        len += *p + 1;\n                        p += *p;\n                }\n        }\n\n        return len;\n}\n\n// creates a label\n// free() after use\nuint8_t *create_label(const char *txt) {\n        int len;\n        uint8_t *s;\n\n        assert(txt != NULL);\n        len = strlen(txt);\n        if (len > 63)\n                return NULL;\n\n        s = malloc(len + 2);\n        s[0] = len;\n        strncpy((char *) s + 1, txt, len);\n        s[len + 1] = '\\0';\n\n        return s;\n}\n\n// creates a uncompressed name label given a DNS name like \"apple.b.com\"\n// free() after use\nuint8_t *create_nlabel(const char *name) {\n        char *label;\n        char *p, *e, *lenpos;\n        int len = 0;\n\n        assert(name != NULL);\n\n        len = strlen(name);\n        label = malloc(len + 1 + 1);\n        if (label == NULL)\n                return NULL;\n\n        strncpy((char *) label + 1, name, len);\n        label[len + 1] = '\\0';\n\n        p = label;\n        e = p + len;\n        lenpos = p;\n\n        while (p < e) {\n                *lenpos = 0;\n                char *dot = memchr(p + 1, '.', e - p - 1);\n                if (dot == NULL)\n                        dot = e + 1;\n                *lenpos = dot - p - 1;\n\n                p = dot;\n                lenpos = dot;\n        }\n\n        return (uint8_t *) label;\n}\n\n// copies a label from the buffer into a newly-allocated string\n// free() after use\nstatic uint8_t *copy_label(uint8_t *pkt_buf, size_t pkt_len, size_t off) {\n        int len;\n\n        if (off > pkt_len)\n                return NULL;\n\n        len = pkt_buf[off] + 1;\n        if (off + len > pkt_len) {\n                DEBUG_PRINTF(\"label length exceeds packet buffer\\n\");\n                return NULL;\n        }\n\n        return dup_label(pkt_buf + off);\n}\n\n// uncompresses a name\n// free() after use\nstatic uint8_t *uncompress_nlabel(uint8_t *pkt_buf, size_t pkt_len, size_t off) {\n        uint8_t *p;\n        uint8_t *e = pkt_buf + pkt_len;\n        size_t len = 0;\n        char *str, *sp;\n        if (off >= pkt_len)\n                return NULL;\n\n        // calculate length of uncompressed label\n        for (p = pkt_buf + off; *p && p < e; p++) {\n                size_t llen = 0;\n                if ((*p & 0xC0) == 0xC0) {\n                        uint8_t *p2 = pkt_buf + (((p[0] & ~0xC0) << 8) | p[1]);\n                        llen = *p2 + 1;\n                        p = p2 + llen - 1;\n                } else {\n                        llen = *p + 1;\n                        p += llen - 1;\n                }\n                len += llen;\n        }\n\n        str = sp = malloc(len + 1);\n        if (str == NULL)\n                return NULL;\n\n        // FIXME: must merge this with above code\n        for (p = pkt_buf + off; *p && p < e; p++) {\n                size_t llen = 0;\n                if ((*p & 0xC0) == 0xC0) {\n                        uint8_t *p2 = pkt_buf + (((p[0] & ~0xC0) << 8) | p[1]);\n                        llen = *p2 + 1;\n                        strncpy(sp, (char *) p2, llen);\n                        p = p2 + llen - 1;\n                } else {\n                        llen = *p + 1;\n                        strncpy(sp, (char *) p, llen);\n                        p += llen - 1;\n                }\n                sp += llen;\n        }\n        *sp = '\\0';\n\n        return (uint8_t *) str;\n}\n\n// ----- RR list & group functions -----\n\nconst char *rr_get_type_name(enum rr_type type) {\n        switch (type) {\n                case RR_A:              return \"A\";\n                case RR_PTR:    return \"PTR\";\n                case RR_TXT:    return \"TXT\";\n                case RR_AAAA:   return \"AAAA\";\n                case RR_SRV:    return \"SRV\";\n                case RR_NSEC:   return \"NSEC\";\n                case RR_ANY:    return \"ANY\";\n        }\n        return NULL;\n}\n\nvoid rr_entry_destroy(struct rr_entry *rr) {\n        struct rr_data_txt *txt_rec;\n        assert(rr);\n\n        // check rr_type and free data elements\n        switch (rr->type) {\n                case RR_PTR:\n                        if (rr->data.PTR.name)\n                                free(rr->data.PTR.name);\n                        // don't free entry\n                        break;\n\n                case RR_TXT:\n                        txt_rec = &rr->data.TXT;\n                        while (txt_rec) {\n                                struct rr_data_txt *next = txt_rec->next;\n                                if (txt_rec->txt)\n                                        free(txt_rec->txt);\n\n                                // only free() if it wasn't part of the struct\n                                if (txt_rec != &rr->data.TXT)\n                                        free(txt_rec);\n\n                                txt_rec = next;\n                        }\n                        break;\n\n                case RR_SRV:\n                        if (rr->data.SRV.target)\n                                free(rr->data.SRV.target);\n                        break;\n\n                default:\n                        // nothing to free\n                        break;\n        }\n\n        free(rr->name);\n        free(rr);\n}\n\n// destroys an RR list (and optionally, items)\nvoid rr_list_destroy(struct rr_list *rr, char destroy_items) {\n        struct rr_list *rr_next;\n\n        for (; rr; rr = rr_next) {\n                rr_next = rr->next;\n                if (destroy_items)\n                        rr_entry_destroy(rr->e);\n                free(rr);\n        }\n}\n\nint rr_list_count(struct rr_list *rr) {\n        int i = 0;\n        for (; rr; i++, rr = rr->next);\n        return i;\n}\n\nstruct rr_entry *rr_list_remove(struct rr_list **rr_head, struct rr_entry *rr) {\n        struct rr_list *le = *rr_head, *pe = NULL;\n        for (; le; le = le->next) {\n                if (le->e == rr) {\n                        if (pe == NULL) {\n                                *rr_head = le->next;\n                                free(le);\n                                return rr;\n                        } else {\n                                pe->next = le->next;\n                                free(le);\n                                return rr;\n                        }\n                }\n                pe = le;\n        }\n        return NULL;\n}\n\n// appends an rr_entry to an RR list\n// if the RR is already in the list, it will not be added\n// RRs are compared by memory location - not its contents\n// return value of 0 means item not added\nint rr_list_append(struct rr_list **rr_head, struct rr_entry *rr) {\n        struct rr_list *node = malloc(sizeof(struct rr_list));\n        node->e = rr;\n        node->next = NULL;\n\n        if (*rr_head == NULL) {\n                *rr_head = node;\n        } else {\n                struct rr_list *e = *rr_head, *taile;\n                for (; e; e = e->next) {\n                        // already in list - don't add\n                        if (e->e == rr) {\n                                free(node);\n                                return 0;\n                        }\n                        if (e->next == NULL)\n                                taile = e;\n                }\n                taile->next = node;\n        }\n        return 1;\n}\n\n#define FILL_RR_ENTRY(rr, _name, _type) \\\n        rr->name = _name;                       \\\n        rr->type = _type;                       \\\n        rr->ttl  = DEFAULT_TTL;         \\\n        rr->cache_flush = 1;            \\\n        rr->rr_class  = 1;\n\nstruct rr_entry *rr_create_a(uint8_t *name, uint32_t addr) {\n        DECL_MALLOC_ZERO_STRUCT(rr, rr_entry);\n        FILL_RR_ENTRY(rr, name, RR_A);\n        rr->data.A.addr = addr;\n        return rr;\n}\n\nstruct rr_entry *rr_create_aaaa(uint8_t *name, struct in6_addr *addr) {\n        DECL_MALLOC_ZERO_STRUCT(rr, rr_entry);\n        FILL_RR_ENTRY(rr, name, RR_AAAA);\n        rr->data.AAAA.addr = addr;\n        return rr;\n}\n\nstruct rr_entry *rr_create_srv(uint8_t *name, uint16_t port, uint8_t *target) {\n        DECL_MALLOC_ZERO_STRUCT(rr, rr_entry);\n        FILL_RR_ENTRY(rr, name, RR_SRV);\n        rr->data.SRV.port = port;\n        rr->data.SRV.target = target;\n        return rr;\n}\n\nstruct rr_entry *rr_create_ptr(uint8_t *name, struct rr_entry *d_rr) {\n        DECL_MALLOC_ZERO_STRUCT(rr, rr_entry);\n        FILL_RR_ENTRY(rr, name, RR_PTR);\n        rr->cache_flush = 0;    // PTRs shouldn't have their cache flush bit set\n        rr->data.PTR.entry = d_rr;\n        return rr;\n}\n\nstruct rr_entry *rr_create(uint8_t *name, enum rr_type type) {\n        DECL_MALLOC_ZERO_STRUCT(rr, rr_entry);\n        FILL_RR_ENTRY(rr, name, type);\n        return rr;\n}\n\nvoid rr_set_nsec(struct rr_entry *rr_nsec, enum rr_type type) {\n        assert(rr_nsec->type = RR_NSEC);\n        assert((type / 8) < sizeof(rr_nsec->data.NSEC.bitmap));\n\n        rr_nsec->data.NSEC.bitmap[ type / 8 ] = 1 << (7 - (type % 8));\n}\n\nvoid rr_add_txt(struct rr_entry *rr_txt, const char *txt) {\n        struct rr_data_txt *txt_rec;\n        assert(rr_txt->type == RR_TXT);\n\n        txt_rec = &rr_txt->data.TXT;\n\n        // is current data filled?\n        if (txt_rec->txt == NULL) {\n                txt_rec->txt = create_label(txt);\n                return;\n        }\n\n        // find the last node\n        for (; txt_rec->next; txt_rec = txt_rec->next);\n\n        // create a new empty node\n        txt_rec->next = malloc(sizeof(struct rr_data_txt));\n\n        txt_rec = txt_rec->next;\n        txt_rec->txt = create_label(txt);\n        txt_rec->next = NULL;\n}\n\n// adds a record to an rr_group\nvoid rr_group_add(struct rr_group **group, struct rr_entry *rr) {\n        struct rr_group *g;\n\n        assert(rr != NULL);\n\n        if (*group) {\n                g = rr_group_find(*group, rr->name);\n                if (g) {\n                        rr_list_append(&g->rr, rr);\n                        return;\n                }\n        }\n\n        MALLOC_ZERO_STRUCT(g, rr_group);\n        g->name = dup_nlabel(rr->name);\n        rr_list_append(&g->rr, rr);\n\n        // prepend to list\n        g->next = *group;\n        *group = g;\n}\n\n// finds a rr_group matching the given name\nstruct rr_group *rr_group_find(struct rr_group* g, uint8_t *name) {\n        for (; g; g = g->next) {\n                if (cmp_nlabel(g->name, name) == 0)\n                        return g;\n        }\n        return NULL;\n}\n\nstruct rr_entry *rr_entry_find(struct rr_list *rr_list, uint8_t *name, uint16_t type) {\n        struct rr_list *rr = rr_list;\n        for (; rr; rr = rr->next) {\n                if (rr->e->type == type && cmp_nlabel(rr->e->name, name) == 0)\n                        return rr->e;\n        }\n        return NULL;\n}\n\n// looks for a matching entry in rr_list\n// if entry is a PTR, we need to check if the PTR target also matches\nstruct rr_entry *rr_entry_match(struct rr_list *rr_list, struct rr_entry *entry) {\n        struct rr_list *rr = rr_list;\n        for (; rr; rr = rr->next) {\n                if (rr->e->type == entry->type && cmp_nlabel(rr->e->name, entry->name) == 0) {\n                        if (entry->type != RR_PTR) {\n                                return rr->e;\n                        } else if (cmp_nlabel(MDNS_RR_GET_PTR_NAME(entry), MDNS_RR_GET_PTR_NAME(rr->e)) == 0) {\n                                // if it's a PTR, we need to make sure PTR target also matches\n                                return rr->e;\n                        }\n                }\n        }\n        return NULL;\n}\n\nvoid rr_group_destroy(struct rr_group *group) {\n        struct rr_group *g = group;\n\n        while (g) {\n                struct rr_group *nextg = g->next;\n                free(g->name);\n                rr_list_destroy(g->rr, 1);\n                free(g);\n                g = nextg;\n        }\n}\n\nuint8_t *mdns_write_u16(uint8_t *ptr, const uint16_t v) {\n        *ptr++ = (uint8_t) (v >> 8) & 0xFF;\n        *ptr++ = (uint8_t) (v >> 0) & 0xFF;\n        return ptr;\n}\n\nuint8_t *mdns_write_u32(uint8_t *ptr, const uint32_t v) {\n        *ptr++ = (uint8_t) (v >> 24) & 0xFF;\n        *ptr++ = (uint8_t) (v >> 16) & 0xFF;\n        *ptr++ = (uint8_t) (v >>  8) & 0xFF;\n        *ptr++ = (uint8_t) (v >>  0) & 0xFF;\n        return ptr;\n}\n\nuint16_t mdns_read_u16(const uint8_t *ptr) {\n        return  ((ptr[0] & 0xFF) << 8) |\n                        ((ptr[1] & 0xFF) << 0);\n}\n\nuint32_t mdns_read_u32(const uint8_t *ptr) {\n        return  ((ptr[0] & 0xFF) << 24) |\n                        ((ptr[1] & 0xFF) << 16) |\n                        ((ptr[2] & 0xFF) <<  8) |\n                        ((ptr[3] & 0xFF) <<  0);\n}\n\n// initialize the packet for reply\n// clears the packet of list structures but not its list items\nvoid mdns_init_reply(struct mdns_pkt *pkt, uint16_t id) {\n        // copy transaction ID\n        pkt->id = id;\n\n        // response flags\n        pkt->flags = MDNS_FLAG_RESP | MDNS_FLAG_AA;\n\n        rr_list_destroy(pkt->rr_qn,   0);\n        rr_list_destroy(pkt->rr_ans,  0);\n        rr_list_destroy(pkt->rr_auth, 0);\n        rr_list_destroy(pkt->rr_add,  0);\n\n        pkt->rr_qn    = NULL;\n        pkt->rr_ans   = NULL;\n        pkt->rr_auth  = NULL;\n        pkt->rr_add   = NULL;\n\n        pkt->num_qn = 0;\n        pkt->num_ans_rr = 0;\n        pkt->num_auth_rr = 0;\n        pkt->num_add_rr = 0;\n}\n\n// destroys an mdns_pkt struct, including its contents\nvoid mdns_pkt_destroy(struct mdns_pkt *p) {\n        rr_list_destroy(p->rr_qn, 1);\n        rr_list_destroy(p->rr_ans, 1);\n        rr_list_destroy(p->rr_auth, 1);\n        rr_list_destroy(p->rr_add, 1);\n\n        free(p);\n}\n\n\n// parse the MDNS questions section\n// stores the parsed data in the given mdns_pkt struct\nstatic size_t mdns_parse_qn(uint8_t *pkt_buf, size_t pkt_len, size_t off,\n                struct mdns_pkt *pkt) {\n        const uint8_t *p = pkt_buf + off;\n        struct rr_entry *rr;\n        uint8_t *name;\n\n        assert(pkt != NULL);\n\n        rr = malloc(sizeof(struct rr_entry));\n        memset(rr, 0, sizeof(struct rr_entry));\n\n        name = uncompress_nlabel(pkt_buf, pkt_len, off);\n        p += label_len(pkt_buf, pkt_len, off);\n        rr->name = name;\n\n        rr->type = mdns_read_u16(p);\n        p += sizeof(uint16_t);\n\n        rr->unicast_query = (*p & 0x80) == 0x80;\n        rr->rr_class = mdns_read_u16(p) & ~0x80;\n        p += sizeof(uint16_t);\n\n        rr_list_append(&pkt->rr_qn, rr);\n\n        return p - (pkt_buf + off);\n}\n\n// parse the MDNS RR section\n// stores the parsed data in the given mdns_pkt struct\nstatic size_t mdns_parse_rr(uint8_t *pkt_buf, size_t pkt_len, size_t off,\n                struct mdns_pkt *pkt) {\n        const uint8_t *p = pkt_buf + off;\n        const uint8_t *e = pkt_buf + pkt_len;\n        struct rr_entry *rr;\n        uint8_t *name;\n        size_t rr_data_len = 0;\n        struct rr_data_txt *txt_rec;\n        int parse_error = 0;\n\n        assert(pkt != NULL);\n\n        if (off > pkt_len)\n                return 0;\n\n        rr = malloc(sizeof(struct rr_entry));\n        memset(rr, 0, sizeof(struct rr_entry));\n\n        name = uncompress_nlabel(pkt_buf, pkt_len, off);\n        p += label_len(pkt_buf, pkt_len, off);\n        rr->name = name;\n\n        rr->type = mdns_read_u16(p);\n        p += sizeof(uint16_t);\n\n        rr->cache_flush = (*p & 0x80) == 0x80;\n        rr->rr_class = mdns_read_u16(p) & ~0x80;\n        p += sizeof(uint16_t);\n\n        rr->ttl = mdns_read_u32(p);\n        p += sizeof(uint32_t);\n\n        // RR data\n        rr_data_len = mdns_read_u16(p);\n        p += sizeof(uint16_t);\n\n        if (p + rr_data_len > e) {\n                DEBUG_PRINTF(\"rr_data_len goes beyond packet buffer: %lu > %lu\\n\", rr_data_len, e - p);\n                rr_entry_destroy(rr);\n                return 0;\n        }\n\n        e = p + rr_data_len;\n\n        // see if we can parse the RR data\n        switch (rr->type) {\n                case RR_A:\n                        if (rr_data_len < sizeof(uint32_t)) {\n                                DEBUG_PRINTF(\"invalid rr_data_len=%lu for A record\\n\", rr_data_len);\n                                parse_error = 1;\n                                break;\n                        }\n                        rr->data.A.addr = ntohl(mdns_read_u32(p)); /* addr already in net order */\n                        p += sizeof(uint32_t);\n                        break;\n\n                case RR_AAAA:\n                        if (rr_data_len < sizeof(struct in6_addr)) {\n                                DEBUG_PRINTF(\"invalid rr_data_len=%lu for AAAA record\\n\", rr_data_len);\n                                parse_error = 1;\n                                break;\n                        }\n                        rr->data.AAAA.addr = malloc(sizeof(struct in6_addr));\n                        int i;\n                        for (i = 0; i < sizeof(struct in6_addr); i++)\n                                rr->data.AAAA.addr->s6_addr[i] = p[i];\n                        p += sizeof(struct in6_addr);\n                        break;\n\n                case RR_PTR:\n                        rr->data.PTR.name = uncompress_nlabel(pkt_buf, pkt_len, p - pkt_buf);\n                        if (rr->data.PTR.name == NULL) {\n                                DEBUG_PRINTF(\"unable to parse/uncompress label for PTR name\\n\");\n                                parse_error = 1;\n                                break;\n                        }\n                        p += rr_data_len;\n                        break;\n\n                case RR_TXT:\n                        txt_rec = &rr->data.TXT;\n\n                        // not supposed to happen, but we should handle it\n                        if (rr_data_len == 0) {\n                                DEBUG_PRINTF(\"WARN: rr_data_len for TXT is 0\\n\");\n                                txt_rec->txt = create_label(\"\");\n                                break;\n                        }\n\n                        while (1) {\n                                txt_rec->txt = copy_label(pkt_buf, pkt_len, p - pkt_buf);\n                                if (txt_rec->txt == NULL) {\n                                        DEBUG_PRINTF(\"unable to copy label for TXT record\\n\");\n                                        parse_error = 1;\n                                        break;\n                                }\n                                p += txt_rec->txt[0] + 1;\n\n                                if (p >= e)\n                                        break;\n\n                                // allocate another record\n                                txt_rec->next = malloc(sizeof(struct rr_data_txt));\n                                txt_rec = txt_rec->next;\n                                txt_rec->next = NULL;\n                        }\n                        break;\n\n                default:\n                        // skip to end of RR data\n                        p = e;\n        }\n\n        // if there was a parse error, destroy partial rr_entry\n        if (parse_error) {\n                rr_entry_destroy(rr);\n                return 0;\n        }\n\n        rr_list_append(&pkt->rr_ans, rr);\n\n        return p - (pkt_buf + off);\n}\n\n// parse a MDNS packet into an mdns_pkt struct\nstruct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf, size_t pkt_len) {\n        uint8_t *p = pkt_buf;\n        size_t off;\n        struct mdns_pkt *pkt;\n        int i;\n\n        if (pkt_len < 12)\n                return NULL;\n\n        MALLOC_ZERO_STRUCT(pkt, mdns_pkt);\n\n        // parse header\n        pkt->id                         = mdns_read_u16(p); p += sizeof(uint16_t);\n        pkt->flags                      = mdns_read_u16(p); p += sizeof(uint16_t);\n        pkt->num_qn             = mdns_read_u16(p); p += sizeof(uint16_t);\n        pkt->num_ans_rr         = mdns_read_u16(p); p += sizeof(uint16_t);\n        pkt->num_auth_rr        = mdns_read_u16(p); p += sizeof(uint16_t);\n        pkt->num_add_rr         = mdns_read_u16(p); p += sizeof(uint16_t);\n\n        off = p - pkt_buf;\n\n        // parse questions\n        for (i = 0; i < pkt->num_qn; i++) {\n                size_t l = mdns_parse_qn(pkt_buf, pkt_len, off, pkt);\n                if (! l) {\n                        DEBUG_PRINTF(\"error parsing question #%d\\n\", i);\n                        mdns_pkt_destroy(pkt);\n                        return NULL;\n                }\n\n                off += l;\n        }\n\n        // parse answer RRs\n        for (i = 0; i < pkt->num_ans_rr; i++) {\n                size_t l = mdns_parse_rr(pkt_buf, pkt_len, off, pkt);\n                if (! l) {\n                        DEBUG_PRINTF(\"error parsing answer #%d\\n\", i);\n                        mdns_pkt_destroy(pkt);\n                        return NULL;\n                }\n\n                off += l;\n        }\n\n        // TODO: parse the authority and additional RR sections\n\n        return pkt;\n}\n\n// encodes a name (label) into a packet using the name compression scheme\n// encoded names will be added to the compression list for subsequent use\nstatic size_t mdns_encode_name(uint8_t *pkt_buf, size_t pkt_len, size_t off,\n                const uint8_t *name, struct name_comp *comp) {\n        struct name_comp *c, *c_tail = NULL;\n        uint8_t *p = pkt_buf + off;\n        size_t len = 0;\n\n        if (name) {\n                while (*name) {\n                        // find match for compression\n                        for (c = comp; c; c = c->next) {\n                                if (cmp_nlabel(name, c->label) == 0) {\n                                        mdns_write_u16(p, 0xC000 | (c->pos & ~0xC000));\n                                        return len + sizeof(uint16_t);\n                                }\n\n                                if (c->next == NULL)\n                                        c_tail = c;\n                        }\n\n                        // copy this segment\n                        int segment_len = *name + 1;\n                        strncpy((char *) p, (char *) name, segment_len);\n\n                        // cache the name for subsequent compression\n                        DECL_MALLOC_ZERO_STRUCT(new_c, name_comp);\n\n                        new_c->label = (uint8_t *) name;\n                        new_c->pos = p - pkt_buf;\n                        c_tail->next = new_c;\n\n                        // advance to next name segment\n                        p += segment_len;\n                        len += segment_len;\n                        name += segment_len;\n                }\n        }\n\n        *p = '\\0';      // root \"label\"\n        len += 1;\n\n        return len;\n}\n\n// encodes an RR entry at the given offset\n// returns the size of the entire RR entry\nstatic size_t mdns_encode_rr(uint8_t *pkt_buf, size_t pkt_len, size_t off,\n                struct rr_entry *rr, struct name_comp *comp) {\n        uint8_t *p = pkt_buf + off, *p_data;\n        size_t l;\n        struct rr_data_txt *txt_rec;\n        uint8_t *label;\n        int i;\n\n        assert(off < pkt_len);\n\n        // name\n        l = mdns_encode_name(pkt_buf, pkt_len, off, rr->name, comp);\n        assert(l != 0);\n        p += l;\n\n        // type\n        p = mdns_write_u16(p, rr->type);\n\n        // class & cache flush\n        p = mdns_write_u16(p, (rr->rr_class & ~0x8000) | (rr->cache_flush << 15));\n\n        // TTL\n        p = mdns_write_u32(p, rr->ttl);\n\n        // data length (filled in later)\n        p += sizeof(uint16_t);\n\n        // start of data marker\n        p_data = p;\n\n        switch (rr->type) {\n                case RR_A:\n                        /* htonl() needed coz addr already in net order */\n                        p = mdns_write_u32(p, htonl(rr->data.A.addr));\n                        break;\n\n                case RR_AAAA:\n                        for (i = 0; i < sizeof(struct in6_addr); i++)\n                                *p++ = rr->data.AAAA.addr->s6_addr[i];\n                        break;\n\n                case RR_PTR:\n                        label = rr->data.PTR.name ?\n                                        rr->data.PTR.name :\n                                        rr->data.PTR.entry->name;\n                        p += mdns_encode_name(pkt_buf, pkt_len, p - pkt_buf, label, comp);\n                        break;\n\n                case RR_TXT:\n                        txt_rec = &rr->data.TXT;\n                        for (; txt_rec; txt_rec = txt_rec->next) {\n                                int len = txt_rec->txt[0] + 1;\n                                strncpy((char *) p, (char *) txt_rec->txt, len);\n                                p += len;\n                        }\n                        break;\n\n                case RR_SRV:\n                        p = mdns_write_u16(p, rr->data.SRV.priority);\n\n                        p = mdns_write_u16(p, rr->data.SRV.weight);\n\n                        p = mdns_write_u16(p, rr->data.SRV.port);\n\n                        p += mdns_encode_name(pkt_buf, pkt_len, p - pkt_buf,\n                                        rr->data.SRV.target, comp);\n                        break;\n\n                case RR_NSEC:\n                        p += mdns_encode_name(pkt_buf, pkt_len, p - pkt_buf,\n                                        rr->name, comp);\n\n                        *p++ = 0;       // bitmap window/block number\n\n                        *p++ = sizeof(rr->data.NSEC.bitmap);    // bitmap length\n\n                        for (i = 0; i < sizeof(rr->data.NSEC.bitmap); i++)\n                                *p++ = rr->data.NSEC.bitmap[i];\n\n                        break;\n\n                default:\n                        DEBUG_PRINTF(\"unhandled rr type 0x%02x\\n\", rr->type);\n        }\n\n        // calculate data length based on p\n        l = p - p_data;\n\n        // fill in the length\n        mdns_write_u16(p - l - sizeof(uint16_t), l);\n\n        return p - pkt_buf - off;\n}\n\n// encodes a MDNS packet from the given mdns_pkt struct into a buffer\n// returns the size of the entire MDNS packet\nsize_t mdns_encode_pkt(struct mdns_pkt *answer, uint8_t *pkt_buf, size_t pkt_len) {\n        struct name_comp *comp;\n        uint8_t *p = pkt_buf;\n        //uint8_t *e = pkt_buf + pkt_len;\n        size_t off;\n        int i;\n\n        assert(answer != NULL);\n        assert(pkt_len >= 12);\n\n        if (p == NULL)\n                return -1;\n\n        // this is an Answer - number of qns should be zero\n        assert(answer->num_qn == 0);\n\n        p = mdns_write_u16(p, answer->id);\n        p = mdns_write_u16(p, answer->flags);\n        p = mdns_write_u16(p, answer->num_qn);\n        p = mdns_write_u16(p, answer->num_ans_rr);\n        p = mdns_write_u16(p, answer->num_auth_rr);\n        p = mdns_write_u16(p, answer->num_add_rr);\n\n        off = p - pkt_buf;\n\n        // allocate list for name compression\n        comp = malloc(sizeof(struct name_comp));\n        if (comp == NULL)\n                return -1;\n        memset(comp, 0, sizeof(struct name_comp));\n\n        // dummy entry\n        comp->label = (uint8_t *) \"\";\n        comp->pos = 0;\n\n        // skip encoding of qn\n\n        struct rr_list *rr_set[] = {\n                answer->rr_ans,\n                answer->rr_auth,\n                answer->rr_add\n        };\n\n        // encode answer, authority and additional RRs\n        for (i = 0; i < sizeof(rr_set) / sizeof(rr_set[0]); i++) {\n                struct rr_list *rr = rr_set[i];\n                for (; rr; rr = rr->next) {\n                        size_t l = mdns_encode_rr(pkt_buf, pkt_len, off, rr->e, comp);\n                        off += l;\n\n                        if (off >= pkt_len) {\n                                DEBUG_PRINTF(\"packet buffer too small\\n\");\n                                return -1;\n                        }\n                }\n\n        }\n\n        // free name compression list\n        while (comp) {\n                struct name_comp *c = comp->next;\n                free(comp);\n                comp = c;\n        }\n\n        return off;\n}\n\n//******************************************************//\n//                      mdnsd.c                         //\n//******************************************************//\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#define LOG_ERR 3\n#else\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <syslog.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <assert.h>\n#include <pthread.h>\n\n/*\n * Define a proper IP socket level if not already done.\n * Required to compile on OS X\n */\n#ifndef SOL_IP\n#define SOL_IP IPPROTO_IP\n#endif\n\n#define MDNS_ADDR \"224.0.0.251\"\n#define MDNS_PORT 5353\n\n#define PACKET_SIZE 65536\n\n#define SERVICES_DNS_SD_NLABEL \\\n                ((uint8_t *) \"\\x09_services\\x07_dns-sd\\x04_udp\\x05local\")\n\nstruct mdnsd {\n        pthread_mutex_t data_lock;\n        int sockfd;\n        int notify_pipe[2];\n        int stop_flag;\n\n        struct rr_group *group;\n        struct rr_list *announce;\n        struct rr_list *services;\n        uint8_t *hostname;\n};\n\nstruct mdns_service {\n        struct rr_list *entries;\n};\n\n/////////////////////////////////\n\n\n\nstatic int create_recv_sock() {\n        int sd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sd < 0) {\n                log_message(LOG_ERR, \"recv socket(): %m\");\n                return sd;\n        }\n\n        int r = -1;\n\n        int on = 1;\n        if ((r = setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on))) < 0) {\n                log_message(LOG_ERR, \"recv setsockopt(SO_REUSEADDR): %m\");\n                return r;\n        }\n\n        /* bind to an address */\n        struct sockaddr_in serveraddr;\n        memset(&serveraddr, 0, sizeof(serveraddr));\n        serveraddr.sin_family = AF_INET;\n        serveraddr.sin_port = htons(MDNS_PORT);\n        serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); /* receive multicast */\n        if ((r = bind(sd, (struct sockaddr *)&serveraddr, sizeof(serveraddr))) < 0) {\n                log_message(LOG_ERR, \"recv bind(): %m\");\n        }\n\n        // add membership to receiving socket\n        struct ip_mreq mreq;\n        memset(&mreq, 0, sizeof(struct ip_mreq));\n        mreq.imr_interface.s_addr = htonl(INADDR_ANY);\n        mreq.imr_multiaddr.s_addr = inet_addr(MDNS_ADDR);\n        if ((r = setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *) &mreq, sizeof(mreq))) < 0) {\n                log_message(LOG_ERR, \"recv setsockopt(IP_ADD_MEMBERSHIP): %m\");\n                return r;\n        }\n\n        // enable loopback in case someone else needs the data\n        if ((r = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_LOOP, (char *) &on, sizeof(on))) < 0) {\n                log_message(LOG_ERR, \"recv setsockopt(IP_MULTICAST_LOOP): %m\");\n                return r;\n        }\n\n\n#ifdef IP_PKTINFO\n        if ((r = setsockopt(sd, SOL_IP, IP_PKTINFO, (char *) &on, sizeof(on))) < 0) {\n                log_message(LOG_ERR, \"recv setsockopt(IP_PKTINFO): %m\");\n                return r;\n        }\n#endif\n\n        return sd;\n}\n\nstatic ssize_t send_packet(int fd, const void *data, size_t len) {\n        static struct sockaddr_in toaddr;\n        if (toaddr.sin_family != AF_INET) {\n                memset(&toaddr, 0, sizeof(struct sockaddr_in));\n                toaddr.sin_family = AF_INET;\n                toaddr.sin_port = htons(MDNS_PORT);\n                toaddr.sin_addr.s_addr = inet_addr(MDNS_ADDR);\n        }\n\n        return sendto(fd, data, len, 0, (struct sockaddr *) &toaddr, sizeof(struct sockaddr_in));\n}\n\n\n// populate the specified list which matches the RR name and type\n// type can be RR_ANY, which populates all entries EXCEPT RR_NSEC\nstatic int populate_answers(struct mdnsd *svr, struct rr_list **rr_head, uint8_t *name, enum rr_type type) {\n        int num_ans = 0;\n\n        // check if we have the records\n        pthread_mutex_lock(&svr->data_lock);\n        struct rr_group *ans_grp = rr_group_find(svr->group, name);\n        if (ans_grp == NULL) {\n                pthread_mutex_unlock(&svr->data_lock);\n                return num_ans;\n        }\n\n        // decide which records should go into answers\n        struct rr_list *n = ans_grp->rr;\n        for (; n; n = n->next) {\n                // exclude NSEC for RR_ANY\n                if (type == RR_ANY && n->e->type == RR_NSEC)\n                        continue;\n\n                if ((type == n->e->type || type == RR_ANY) && cmp_nlabel(name, n->e->name) == 0) {\n                        num_ans += rr_list_append(rr_head, n->e);\n                }\n        }\n\n        pthread_mutex_unlock(&svr->data_lock);\n\n        return num_ans;\n}\n\n// given a list of RRs, look up related records and add them\nstatic void add_related_rr(struct mdnsd *svr, struct rr_list *list, struct mdns_pkt *reply) {\n        for (; list; list = list->next) {\n                struct rr_entry *ans = list->e;\n\n                switch (ans->type) {\n                        case RR_PTR:\n                                // target host A, AAAA records\n                                reply->num_add_rr += populate_answers(svr, &reply->rr_add,\n                                                                                MDNS_RR_GET_PTR_NAME(ans), RR_ANY);\n                                break;\n\n                        case RR_SRV:\n                                // target host A, AAAA records\n                                reply->num_add_rr += populate_answers(svr, &reply->rr_add,\n                                                                                ans->data.SRV.target, RR_ANY);\n\n                                // perhaps TXT records of the same name?\n                                // if we use RR_ANY, we risk pulling in the same RR_SRV\n                                reply->num_add_rr += populate_answers(svr, &reply->rr_add,\n                                                                                ans->name, RR_TXT);\n                                break;\n\n                        case RR_A:\n                        case RR_AAAA:\n                                reply->num_add_rr += populate_answers(svr, &reply->rr_add,\n                                                                                ans->name, RR_NSEC);\n                                break;\n\n                        default:\n                                // nothing to add\n                                break;\n                }\n        }\n}\n\n// creates an announce packet given the type name PTR\nstatic void announce_srv(struct mdnsd *svr, struct mdns_pkt *reply, uint8_t *name) {\n        mdns_init_reply(reply, 0);\n\n        reply->num_ans_rr += populate_answers(svr, &reply->rr_ans, name, RR_PTR);\n\n        // remember to add the services dns-sd PTR too\n        reply->num_ans_rr += populate_answers(svr, &reply->rr_ans,\n                                                                SERVICES_DNS_SD_NLABEL, RR_PTR);\n\n        // see if we can match additional records for answers\n        add_related_rr(svr, reply->rr_ans, reply);\n\n        // additional records for additional records\n        add_related_rr(svr, reply->rr_add, reply);\n}\n\n// processes the incoming MDNS packet\n// returns >0 if processed, 0 otherwise\nstatic int process_mdns_pkt(struct mdnsd *svr, struct mdns_pkt *pkt, struct mdns_pkt *reply) {\n        int i;\n\n        assert(pkt != NULL);\n\n        // is it standard query?\n        if ((pkt->flags & MDNS_FLAG_RESP) == 0 &&\n                        MDNS_FLAG_GET_OPCODE(pkt->flags) == 0) {\n                mdns_init_reply(reply, pkt->id);\n\n                DEBUG_PRINTF(\"flags = %04x, qn = %d, ans = %d, add = %d\\n\",\n                                                pkt->flags,\n                                                pkt->num_qn,\n                                                pkt->num_ans_rr,\n                                                pkt->num_add_rr);\n\n                // loop through questions\n                struct rr_list *qnl = pkt->rr_qn;\n                for (i = 0; i < pkt->num_qn; i++, qnl = qnl->next) {\n                        struct rr_entry *qn = qnl->e;\n                        int num_ans_added = 0;\n\n                        char *namestr = nlabel_to_str(qn->name);\n                        DEBUG_PRINTF(\"qn #%d: type %s (%02x) %s - \", i, rr_get_type_name(qn->type), qn->type, namestr);\n                        free(namestr);\n\n                        // check if it's a unicast query - we ignore those\n                        if (qn->unicast_query) {\n                                DEBUG_PRINTF(\"skipping unicast query\\n\");\n                                continue;\n                        }\n\n                        num_ans_added = populate_answers(svr, &reply->rr_ans, qn->name, qn->type);\n                        reply->num_ans_rr += num_ans_added;\n\n                        DEBUG_PRINTF(\"added %d answers\\n\", num_ans_added);\n                }\n\n                // remove our replies if they were already in their answers\n                struct rr_list *ans = NULL, *prev_ans = NULL;\n                for (ans = reply->rr_ans; ans; ) {\n                        struct rr_list *next_ans = ans->next;\n                        struct rr_entry *known_ans = rr_entry_match(pkt->rr_ans, ans->e);\n\n                        // discard answers that have at least half of the actual TTL\n                        if (known_ans != NULL && known_ans->ttl >= ans->e->ttl / 2) {\n                                char *namestr = nlabel_to_str(ans->e->name);\n                                DEBUG_PRINTF(\"removing answer for %s\\n\", namestr);\n                                free(namestr);\n\n                                // check if list item is head\n                                if (prev_ans == NULL)\n                                        reply->rr_ans = ans->next;\n                                else\n                                        prev_ans->next = ans->next;\n                                free(ans);\n\n                                ans = prev_ans;\n\n                                // adjust answer count\n                                reply->num_ans_rr--;\n                        }\n\n                        prev_ans = ans;\n                        ans = next_ans;\n                }\n\n\n                // see if we can match additional records for answers\n                add_related_rr(svr, reply->rr_ans, reply);\n\n                // additional records for additional records\n                add_related_rr(svr, reply->rr_add, reply);\n\n                DEBUG_PRINTF(\"\\n\");\n\n                return reply->num_ans_rr;\n        }\n\n        return 0;\n}\n\nint create_pipe(int handles[2]) {\n#ifdef _WIN32\n        SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (sock == INVALID_SOCKET) {\n                return -1;\n        }\n        struct sockaddr_in serv_addr;\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(0);\n        serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n        if (bind(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == SOCKET_ERROR) {\n                closesocket(sock);\n                return -1;\n        }\n        if (listen(sock, 1) == SOCKET_ERROR) {\n                closesocket(sock);\n                return -1;\n        }\n        int len = sizeof(serv_addr);\n        if (getsockname(sock, (SOCKADDR*)&serv_addr, &len) == SOCKET_ERROR) {\n                closesocket(sock);\n                return -1;\n        }\n        if ((handles[1] = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n                closesocket(sock);\n                return -1;\n        }\n        if (connect(handles[1], (struct sockaddr*)&serv_addr, len) == SOCKET_ERROR) {\n                closesocket(sock);\n                return -1;\n        }\n        if ((handles[0] = accept(sock, (struct sockaddr*)&serv_addr, &len)) == INVALID_SOCKET) {\n                closesocket((SOCKET)handles[1]);\n                handles[1] = INVALID_SOCKET;\n                closesocket(sock);\n                return -1;\n        }\n        closesocket(sock);\n        return 0;\n#else\n        return pipe(handles);\n#endif\n}\n\nint read_pipe(int s, char* buf, int len) {\n#ifdef _WIN32\n        int ret = recv(s, buf, len, 0);\n        if (ret < 0 && WSAGetLastError() == WSAECONNRESET) {\n                ret = 0;\n        }\n        return ret;\n#else\n        return read(s, buf, len);\n#endif\n}\n\nint write_pipe(int s, char* buf, int len) {\n#ifdef _WIN32\n        return send(s, buf, len, 0);\n#else\n        return write(s, buf, len);\n#endif\n}\n\nint close_pipe(int s) {\n#ifdef _WIN32\n        return closesocket(s);\n#else\n        return close(s);\n#endif\n}\n\n// main loop to receive, process and send out MDNS replies\n// also handles MDNS service announces\nstatic void main_loop(struct mdnsd *svr) {\n        fd_set sockfd_set;\n        int max_fd = svr->sockfd;\n        char notify_buf[2];     // buffer for reading of notify_pipe\n\n        void *pkt_buffer = malloc(PACKET_SIZE);\n\n        if (svr->notify_pipe[0] > max_fd)\n                max_fd = svr->notify_pipe[0];\n\n        struct mdns_pkt *mdns_reply = malloc(sizeof(struct mdns_pkt));\n        memset(mdns_reply, 0, sizeof(struct mdns_pkt));\n\n        while (! svr->stop_flag) {\n                FD_ZERO(&sockfd_set);\n                FD_SET(svr->sockfd, &sockfd_set);\n                FD_SET(svr->notify_pipe[0], &sockfd_set);\n                select(max_fd + 1, &sockfd_set, NULL, NULL, NULL);\n\n                if (FD_ISSET(svr->notify_pipe[0], &sockfd_set)) {\n                        // flush the notify_pipe\n                        read_pipe(svr->notify_pipe[0], (char*)&notify_buf, 1);\n                } else if (FD_ISSET(svr->sockfd, &sockfd_set)) {\n                        struct sockaddr_in fromaddr;\n                        socklen_t sockaddr_size = sizeof(struct sockaddr_in);\n\n                        ssize_t recvsize = recvfrom(svr->sockfd, pkt_buffer, PACKET_SIZE, 0,\n                                (struct sockaddr *) &fromaddr, &sockaddr_size);\n                        if (recvsize < 0) {\n                                log_message(LOG_ERR, \"recv(): %m\");\n                        }\n\n                        DEBUG_PRINTF(\"data from=%s size=%ld\\n\", inet_ntoa(fromaddr.sin_addr), (long) recvsize);\n                        struct mdns_pkt *mdns = mdns_parse_pkt(pkt_buffer, recvsize);\n                        if (mdns != NULL) {\n                                if (process_mdns_pkt(svr, mdns, mdns_reply)) {\n                                        size_t replylen = mdns_encode_pkt(mdns_reply, pkt_buffer, PACKET_SIZE);\n                                        send_packet(svr->sockfd, pkt_buffer, replylen);\n                                } else if (mdns->num_qn == 0) {\n                                        DEBUG_PRINTF(\"(no questions in packet)\\n\\n\");\n                                }\n\n                                mdns_pkt_destroy(mdns);\n                        }\n                }\n\n                // send out announces\n                while (1) {\n                        struct rr_entry *ann_e = NULL;\n\n                        // extract from head of list\n                        pthread_mutex_lock(&svr->data_lock);\n                        if (svr->announce)\n                                ann_e = rr_list_remove(&svr->announce, svr->announce->e);\n                        pthread_mutex_unlock(&svr->data_lock);\n\n                        if (! ann_e)\n                                break;\n\n                        char *namestr = nlabel_to_str(ann_e->name);\n                        DEBUG_PRINTF(\"sending announce for %s\\n\", namestr);\n                        free(namestr);\n\n                        announce_srv(svr, mdns_reply, ann_e->name);\n\n                        if (mdns_reply->num_ans_rr > 0) {\n                                size_t replylen = mdns_encode_pkt(mdns_reply, pkt_buffer, PACKET_SIZE);\n                                send_packet(svr->sockfd, pkt_buffer, replylen);\n                        }\n                }\n        }\n\n        // main thread terminating. send out \"goodbye packets\" for services\n        mdns_init_reply(mdns_reply, 0);\n\n        pthread_mutex_lock(&svr->data_lock);\n        struct rr_list *svc_le = svr->services;\n        for (; svc_le; svc_le = svc_le->next) {\n                // set TTL to zero\n                svc_le->e->ttl = 0;\n                mdns_reply->num_ans_rr += rr_list_append(&mdns_reply->rr_ans, svc_le->e);\n        }\n        pthread_mutex_unlock(&svr->data_lock);\n\n        // send out packet\n        if (mdns_reply->num_ans_rr > 0) {\n                size_t replylen = mdns_encode_pkt(mdns_reply, pkt_buffer, PACKET_SIZE);\n                send_packet(svr->sockfd, pkt_buffer, replylen);\n        }\n\n        // destroy packet\n        mdns_init_reply(mdns_reply, 0);\n        free(mdns_reply);\n\n        free(pkt_buffer);\n\n        close_pipe(svr->sockfd);\n\n        svr->stop_flag = 2;\n}\n\n/////////////////////////////////////////////////////\n\n\nvoid mdnsd_set_hostname(struct mdnsd *svr, const char *hostname, uint32_t ip) {\n        struct rr_entry *a_e = NULL,\n                                        *nsec_e = NULL;\n\n        // currently can't be called twice\n        // dont ask me what happens if the IP changes\n        assert(svr->hostname == NULL);\n\n        a_e = rr_create_a(create_nlabel(hostname), ip);\n\n        nsec_e = rr_create(create_nlabel(hostname), RR_NSEC);\n        rr_set_nsec(nsec_e, RR_A);\n\n        pthread_mutex_lock(&svr->data_lock);\n        svr->hostname = create_nlabel(hostname);\n        rr_group_add(&svr->group, a_e);\n        rr_group_add(&svr->group, nsec_e);\n        pthread_mutex_unlock(&svr->data_lock);\n}\n\nvoid mdnsd_set_hostname_v6(struct mdnsd *svr, const char *hostname, struct in6_addr *addr)\n{\n        struct rr_entry *aaaa_e = NULL,\n                                        *nsec_e = NULL;\n\n        // currently can't be called twice\n        // dont ask me what happens if the IP changes\n        assert(svr->hostname == NULL);\n\n        aaaa_e = rr_create_aaaa(create_nlabel(hostname), addr);\n\n        nsec_e = rr_create(create_nlabel(hostname), RR_NSEC);\n        rr_set_nsec(nsec_e, RR_AAAA);\n\n        pthread_mutex_lock(&svr->data_lock);\n        svr->hostname = create_nlabel(hostname);\n        rr_group_add(&svr->group, aaaa_e);\n        rr_group_add(&svr->group, nsec_e);\n        pthread_mutex_unlock(&svr->data_lock);\n}\n\nvoid mdnsd_add_rr(struct mdnsd *svr, struct rr_entry *rr) {\n        pthread_mutex_lock(&svr->data_lock);\n        rr_group_add(&svr->group, rr);\n        pthread_mutex_unlock(&svr->data_lock);\n}\n\nstruct mdns_service *mdnsd_register_svc(struct mdnsd *svr, const char *instance_name,\n                const char *type, uint16_t port, const char *hostname, const char *txt[]) {\n        struct rr_entry *txt_e = NULL,\n                                        *srv_e = NULL,\n                                        *ptr_e = NULL,\n                                        *bptr_e = NULL;\n        uint8_t *target;\n        uint8_t *inst_nlabel, *type_nlabel, *nlabel;\n        struct mdns_service *service = malloc(sizeof(struct mdns_service));\n        memset(service, 0, sizeof(struct mdns_service));\n\n        // combine service name\n        type_nlabel = create_nlabel(type);\n        inst_nlabel = create_label(instance_name);\n        nlabel = join_nlabel(inst_nlabel, type_nlabel);\n\n        // create TXT record\n        if (txt && *txt) {\n                txt_e = rr_create(dup_nlabel(nlabel), RR_TXT);\n                rr_list_append(&service->entries, txt_e);\n\n                // add TXTs\n                for (; *txt; txt++)\n                        rr_add_txt(txt_e, *txt);\n        }\n\n        // create SRV record\n        assert(hostname || svr->hostname);      // either one as target\n        target = hostname ?\n                                create_nlabel(hostname) :\n                                dup_nlabel(svr->hostname);\n\n        srv_e = rr_create_srv(dup_nlabel(nlabel), port, target);\n        rr_list_append(&service->entries, srv_e);\n\n        // create PTR record for type\n        ptr_e = rr_create_ptr(type_nlabel, srv_e);\n\n        // create services PTR record for type\n        // this enables the type to show up as a \"service\"\n        bptr_e = rr_create_ptr(dup_nlabel(SERVICES_DNS_SD_NLABEL), ptr_e);\n\n        // modify lists here\n        pthread_mutex_lock(&svr->data_lock);\n\n        if (txt_e)\n                rr_group_add(&svr->group, txt_e);\n        rr_group_add(&svr->group, srv_e);\n        rr_group_add(&svr->group, ptr_e);\n        rr_group_add(&svr->group, bptr_e);\n\n        // append PTR entry to announce list\n        rr_list_append(&svr->announce, ptr_e);\n        rr_list_append(&svr->services, ptr_e);\n\n        pthread_mutex_unlock(&svr->data_lock);\n\n        // don't free type_nlabel - it's with the PTR record\n        free(nlabel);\n        free(inst_nlabel);\n\n        // notify server\n        write_pipe(svr->notify_pipe[1], \".\", 1);\n\n        return service;\n}\n\nvoid mdns_service_destroy(struct mdns_service *srv) {\n        assert(srv != NULL);\n        rr_list_destroy(srv->entries, 0);\n        free(srv);\n}\n\nstruct mdnsd *mdnsd_start() {\n        pthread_t tid;\n        pthread_attr_t attr;\n\n        struct mdnsd *server = malloc(sizeof(struct mdnsd));\n        memset(server, 0, sizeof(struct mdnsd));\n\n        if (create_pipe(server->notify_pipe) != 0) {\n                log_message(LOG_ERR, \"pipe(): %m\\n\");\n                free(server);\n                return NULL;\n        }\n\n        server->sockfd = create_recv_sock();\n        if (server->sockfd < 0) {\n                log_message(LOG_ERR, \"unable to create recv socket\");\n                free(server);\n                return NULL;\n        }\n\n        pthread_mutex_init(&server->data_lock, NULL);\n\n        // init thread\n        pthread_attr_init(&attr);\n        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n        if (pthread_create(&tid, &attr, (void *(*)(void *)) main_loop, (void *) server) != 0) {\n                pthread_mutex_destroy(&server->data_lock);\n                free(server);\n                return NULL;\n        }\n\n        return server;\n}\n\nvoid mdnsd_stop(struct mdnsd *s) {\n        assert(s != NULL);\n\n        struct timespec ts = {\n                .tv_sec = 0,\n                .tv_nsec = 500 * 1000000,\n        };\n\n        s->stop_flag = 1;\n        write_pipe(s->notify_pipe[1], \".\", 1);\n\n        while (s->stop_flag != 2)\n                nanosleep(&ts, NULL);\n\n        close_pipe(s->notify_pipe[0]);\n        close_pipe(s->notify_pipe[1]);\n\n        pthread_mutex_destroy(&s->data_lock);\n        rr_group_destroy(s->group);\n        rr_list_destroy(s->announce, 0);\n        rr_list_destroy(s->services, 0);\n\n        if (s->hostname)\n                free(s->hostname);\n\n        free(s);\n}\n"
        },
        {
          "name": "tinysvcmdns.h",
          "type": "blob",
          "size": 7.8134765625,
          "content": "// This file is the concatenation of mdnsd.h and mdns.h\n// from tinysvcmdns with minor modifications\n// The code was taken from https://bitbucket.org/geekman/tinysvcmdns at revision e34b562\n\n/*\n * tinysvcmdns - a tiny MDNS implementation for publishing services\n * Copyright (C) 2011 Darell Tan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _TINYSVCMDNS_H\n\n//******************************************************//\n//                      mdns.h                          //\n//******************************************************//\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <winsock.h>\n#else\n#include <arpa/inet.h>\n#endif\n\n#define MALLOC_ZERO_STRUCT(x, type) \\\n        x = malloc(sizeof(struct type)); \\\n        memset(x, 0, sizeof(struct type));\n\n#define DECL_MALLOC_ZERO_STRUCT(x, type) \\\n        struct type * MALLOC_ZERO_STRUCT(x, type)\n\n\n\nstruct rr_data_srv {\n        uint16_t priority;\n        uint16_t weight;\n        uint16_t port;\n        uint8_t *target;        // host\n};\n\nstruct rr_data_txt {\n        struct rr_data_txt *next;\n        uint8_t *txt;\n};\n\nstruct rr_data_nsec {\n        //uint8_t *name;        // same as record\n\n        // NSEC occupies the 47th bit, 5 bytes\n        //uint8_t bitmap_len;   // = 5\n        uint8_t bitmap[5];      // network order: first byte contains LSB\n};\n\nstruct rr_data_ptr {\n        uint8_t *name;          // NULL if entry is to be used\n        struct rr_entry *entry;\n};\n\nstruct rr_data_a {\n        uint32_t addr;\n};\n\nstruct rr_data_aaaa {\n        struct in6_addr *addr;\n};\n\nstruct rr_entry {\n        uint8_t *name;\n\n        enum rr_type {\n                RR_A            = 0x01,\n                RR_PTR          = 0x0C,\n                RR_TXT          = 0x10,\n                RR_AAAA         = 0x1C,\n                RR_SRV          = 0x21,\n                RR_NSEC         = 0x2F,\n                RR_ANY          = 0xFF,\n        } type;\n\n        uint32_t ttl;\n\n        // for use in Questions only\n        char unicast_query;\n\n        // for use in Answers only\n        char cache_flush;\n\n        uint16_t rr_class;\n\n        // RR data\n        union {\n                struct rr_data_nsec NSEC;\n                struct rr_data_srv  SRV;\n                struct rr_data_txt  TXT;\n                struct rr_data_ptr  PTR;\n                struct rr_data_a    A;\n                struct rr_data_aaaa AAAA;\n        } data;\n};\n\nstruct rr_list {\n        struct rr_entry *e;\n        struct rr_list *next;\n};\n\nstruct rr_group {\n        uint8_t *name;\n\n        struct rr_list *rr;\n\n        struct rr_group *next;\n};\n\n#define MDNS_FLAG_RESP  (1 << 15)       // Query=0 / Response=1\n#define MDNS_FLAG_AA    (1 << 10)       // Authoritative\n#define MDNS_FLAG_TC    (1 <<  9)       // TrunCation\n#define MDNS_FLAG_RD    (1 <<  8)       // Recursion Desired\n#define MDNS_FLAG_RA    (1 <<  7)       // Recursion Available\n#define MDNS_FLAG_Z             (1 <<  6)       // Reserved (zero)\n\n#define MDNS_FLAG_GET_RCODE(x)  (x & 0x0F)\n#define MDNS_FLAG_GET_OPCODE(x) ((x >> 11) & 0x0F)\n\n// gets the PTR target name, either from \"name\" member or \"entry\" member\n#define MDNS_RR_GET_PTR_NAME(rr)  (rr->data.PTR.name != NULL ? rr->data.PTR.name : rr->data.PTR.entry->name)\n\nstruct mdns_pkt {\n        uint16_t id;    // transaction ID\n        uint16_t flags;\n        uint16_t num_qn;\n        uint16_t num_ans_rr;\n        uint16_t num_auth_rr;\n        uint16_t num_add_rr;\n\n        struct rr_list *rr_qn;          // questions\n        struct rr_list *rr_ans;         // answer RRs\n        struct rr_list *rr_auth;        // authority RRs\n        struct rr_list *rr_add;         // additional RRs\n};\n\nstruct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf, size_t pkt_len);\n\nvoid mdns_init_reply(struct mdns_pkt *pkt, uint16_t id);\nsize_t mdns_encode_pkt(struct mdns_pkt *answer, uint8_t *pkt_buf, size_t pkt_len);\n\nvoid mdns_pkt_destroy(struct mdns_pkt *p);\nvoid rr_group_destroy(struct rr_group *group);\nstruct rr_group *rr_group_find(struct rr_group *g, uint8_t *name);\nstruct rr_entry *rr_entry_find(struct rr_list *rr_list, uint8_t *name, uint16_t type);\nstruct rr_entry *rr_entry_match(struct rr_list *rr_list, struct rr_entry *entry);\nvoid rr_group_add(struct rr_group **group, struct rr_entry *rr);\n\nint rr_list_count(struct rr_list *rr);\nint rr_list_append(struct rr_list **rr_head, struct rr_entry *rr);\nstruct rr_entry *rr_list_remove(struct rr_list **rr_head, struct rr_entry *rr);\nvoid rr_list_destroy(struct rr_list *rr, char destroy_items);\n\nstruct rr_entry *rr_create_ptr(uint8_t *name, struct rr_entry *d_rr);\nstruct rr_entry *rr_create_srv(uint8_t *name, uint16_t port, uint8_t *target);\nstruct rr_entry *rr_create_aaaa(uint8_t *name, struct in6_addr *addr);\nstruct rr_entry *rr_create_a(uint8_t *name, uint32_t addr);\nstruct rr_entry *rr_create(uint8_t *name, enum rr_type type);\nvoid rr_set_nsec(struct rr_entry *rr_nsec, enum rr_type type);\nvoid rr_add_txt(struct rr_entry *rr_txt, const char *txt);\n\nconst char *rr_get_type_name(enum rr_type type);\n\nuint8_t *create_label(const char *txt);\nuint8_t *create_nlabel(const char *name);\nchar *nlabel_to_str(const uint8_t *name);\nuint8_t *dup_label(const uint8_t *label);\nuint8_t *dup_nlabel(const uint8_t *n);\nuint8_t *join_nlabel(const uint8_t *n1, const uint8_t *n2);\n\n// compares 2 names\nstatic inline int cmp_nlabel(const uint8_t *L1, const uint8_t *L2) {\n        return strcmp((char *) L1, (char *) L2);\n}\n\n//******************************************************//\n//                      mdnsd.h                         //\n//******************************************************//\n\nstruct mdnsd;\nstruct mdns_service;\n\n// starts a MDNS responder instance\n// returns NULL if unsuccessful\nstruct mdnsd *mdnsd_start();\n\n// stops the given MDNS responder instance\nvoid mdnsd_stop(struct mdnsd *s);\n\n// sets the hostname for the given MDNS responder instance\nvoid mdnsd_set_hostname(struct mdnsd *svr, const char *hostname, uint32_t ip);\n\n// sets the hostname for the given MDNS responder instance, with an ipv6 address\nvoid mdnsd_set_hostname_v6(struct mdnsd *svr, const char *hostname, struct in6_addr *addr);\n\n// adds an additional RR\nvoid mdnsd_add_rr(struct mdnsd *svr, struct rr_entry *rr);\n\n// registers a service with the MDNS responder instance\nstruct mdns_service *mdnsd_register_svc(struct mdnsd *svr, const char *instance_name,\n                const char *type, uint16_t port, const char *hostname, const char *txt[]);\n\n// destroys the mdns_service struct returned by mdnsd_register_svc()\nvoid mdns_service_destroy(struct mdns_service *srv);\n\n\n#endif // _TINYSVCMDNS_H\n"
        }
      ]
    }
  ]
}