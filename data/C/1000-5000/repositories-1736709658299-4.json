{
  "metadata": {
    "timestamp": 1736709658299,
    "page": 4,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antirez/sds",
      "stars": 4968,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0087890625,
          "content": "sds-test\n"
        },
        {
          "name": "Changelog",
          "type": "blob",
          "size": 0.3037109375,
          "content": "Version 2.0\n===\n\n* Better memory usage. A bit slower in certain workloads.\n* sdscatfmt() replacement for sdscatprintf() for speed critical code added.\n* Ability to easily switch allocator just changing sdsalloc.h\n* No longer binary compatible with SDS v1.0.\n\nVersion 1.0\n===\n\n* Initial SDS stand alone verison.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.3037109375,
          "content": "Copyright (c) 2006-2014, Salvatore Sanfilippo <antirez at gmail dot com>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1953125,
          "content": "all: sds-test\n\nsds-test: sds.c sds.h testhelp.h\n\t$(CC) -o sds-test sds.c -Wall -std=c99 -pedantic -O2 -DSDS_TEST_MAIN\n\t@echo \">>> Type ./sds-test to run the sds.c unit tests.\"\n\nclean:\n\trm -f sds-test\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 31.3037109375,
          "content": "Simple Dynamic Strings\n===\n\n**Notes about version 2**: this is an updated version of SDS in an attempt\nto finally unify Redis, Disque, Hiredis, and the stand alone SDS versions.\nThis version is **NOT* binary compatible** with SDS verison 1, but the API\nis 99% compatible so switching to the new lib should be trivial.\n\nNote that this version of SDS may be a slower with certain workloads, but\nuses less memory compared to V1 since header size is dynamic and depends to\nthe string to alloc.\n\nMoreover it includes a few more API functions, notably `sdscatfmt` which\nis a faster version of `sdscatprintf` that can be used for the simpler\ncases in order to avoid the libc `printf` family functions performance\npenalty.\n\nHow SDS strings work\n===\n\nSDS is a string library for C designed to augment the limited libc string\nhandling functionalities by adding heap allocated strings that are:\n\n* Simpler to use.\n* Binary safe.\n* Computationally more efficient.\n* But yet... Compatible with normal C string functions.\n\nThis is achieved using an alternative design in which instead of using a C\nstructure to represent a string, we use a binary prefix that is stored\nbefore the actual pointer to the string that is returned by SDS to the user.\n\n    +--------+-------------------------------+-----------+\n    | Header | Binary safe C alike string... | Null term |\n    +--------+-------------------------------+-----------+\n             |\n             `-> Pointer returned to the user.\n\nBecause of meta data stored before the actual returned pointer as a prefix,\nand because of every SDS string implicitly adding a null term at the end of\nthe string regardless of the actual content of the string, SDS strings work\nwell together with C strings and the user is free to use them interchangeably\nwith other std C string functions that access the string in read-only.\n\nSDS was a C string I developed in the past for my everyday C programming needs,\nlater it was moved into Redis where it is used extensively and where it was\nmodified in order to be suitable for high performance operations. Now it was\nextracted from Redis and forked as a stand alone project.\n\nBecause of its many years life inside Redis, SDS provides both higher level\nfunctions for easy strings manipulation in C, but also a set of low level\nfunctions that make it possible to write high performance code without paying\na penalty for using an higher level string library.\n\nAdvantages and disadvantages of SDS\n===\n\nNormally dynamic string libraries for C are implemented using a structure\nthat defines the string. The structure has a pointer field that is managed\nby the string function, so it looks like this:\n\n```c\nstruct yourAverageStringLibrary {\n    char *buf;\n    size_t len;\n    ... possibly more fields here ...\n};\n```\n\nSDS strings as already mentioned don't follow this schema, and are instead\na single allocation with a prefix that lives *before* the address actually\nreturned for the string.\n\nThere are advantages and disadvantages with this approach over the traditional\napproach:\n\n**Disadvantage #1**: many functions return the new string as value, since sometimes SDS requires to create a new string with more space, so the most SDS API calls look like this:\n\n```c\ns = sdscat(s,\"Some more data\");\n```\n\nAs you can see `s` is used as input for `sdscat` but is also set to the value\nreturned by the SDS API call, since we are not sure if the call modified the\nSDS string we passed or allocated a new one. Not remembering to assign back\nthe return value of `sdscat` or similar functions to the variable holding\nthe SDS string will result in a bug.\n\n**Disadvantage #2**: if an SDS string is shared in different places in your program you have to modify all the references when you modify the string. However most of the times when you need to share SDS strings it is much better to encapsulate them into structures with a `reference count` otherwise it is too easy to incur into memory leaks.\n\n**Advantage #1**: you can pass SDS strings to functions designed for C functions without accessing a struct member or calling a function, like this:\n\n```c\nprintf(\"%s\\n\", sds_string);\n```\n\nIn most other libraries this will be something like:\n\n```c\nprintf(\"%s\\n\", string->buf);\n```\n\nOr:\n\n```c\nprintf(\"%s\\n\", getStringPointer(string));\n```\n\n**Advantage #2**: accessing individual chars is straightforward. C is a low level language so this is an important operation in many programs. With SDS strings accessing individual chars is very natural:\n\n```c\nprintf(\"%c %c\\n\", s[0], s[1]);\n```\n\nWith other libraries your best chance is to assign `string->buf` (or call the function to get the string pointer) to a `char` pointer and work with this. However since the other libraries may reallocate the buffer implicitly every time you call a function that may modify the string you have to get a reference to the buffer again.\n\n**Advantage #3**: single allocation has better cache locality. Usually when you access a string created by a string library using a structure, you have two different allocations for the structure representing the string, and the actual buffer holding the string. Over the time the buffer is reallocated, and it is likely that it ends in a totally different part of memory compared to the structure itself. Since modern programs performances are often dominated by cache misses, SDS may perform better in many workloads.\n\nSDS basics\n===\n\nThe type of SDS strings is just the char pointer `char *`. However SDS defines\nan `sds` type as alias of `char *` in its header file: you should use the\n`sds` type in order to make sure you remember that a given variable in your\nprogram holds an SDS string and not a C string, however this is not mandatory.\n\nThis is the simplest SDS program you can write that does something:\n\n```c\nsds mystring = sdsnew(\"Hello World!\");\nprintf(\"%s\\n\", mystring);\nsdsfree(mystring);\n\noutput> Hello World!\n```\n\nThe above small program already shows a few important things about SDS:\n\n* SDS strings are created, and heap allocated, via the `sdsnew()` function, or other similar functions that we'll see in a moment.\n* SDS strings can be passed to `printf()` like any other C string.\n* SDS strings require to be freed with `sdsfree()`, since they are heap allocated.\n\nCreating SDS strings\n---\n\n```c\nsds sdsnewlen(const void *init, size_t initlen);\nsds sdsnew(const char *init);\nsds sdsempty(void);\nsds sdsdup(const sds s);\n```\n\nThere are many ways to create SDS strings:\n\n* The `sdsnew` function creates an SDS string starting from a C null terminated string. We already saw how it works in the above example.\n* The `sdsnewlen` function is similar to `sdsnew` but instead of creating the string assuming that the input string is null terminated, it gets an additional length parameter. This way you can create a string using binary data:\n\n    ```c\n    char buf[3];\n    sds mystring;\n\n    buf[0] = 'A';\n    buf[1] = 'B';\n    buf[2] = 'C';\n    mystring = sdsnewlen(buf,3);\n    printf(\"%s of len %d\\n\", mystring, (int) sdslen(mystring));\n\n    output> ABC of len 3\n    ```\n\n  Note: `sdslen` return value is casted to `int` because it returns a `size_t`\ntype. You can use the right `printf` specifier instead of casting.\n\n* The `sdsempty()` function creates an empty zero-length string:\n\n    ```c\n    sds mystring = sdsempty();\n    printf(\"%d\\n\", (int) sdslen(mystring));\n\n    output> 0\n    ```\n\n* The `sdsdup()` function duplicates an already existing SDS string:\n\n    ```c\n    sds s1, s2;\n\n    s1 = sdsnew(\"Hello\");\n    s2 = sdsdup(s1);\n    printf(\"%s %s\\n\", s1, s2);\n\n    output> Hello Hello\n    ```\n\nObtaining the string length\n---\n\n```c\nsize_t sdslen(const sds s);\n```\n\nIn the examples above we already used the `sdslen` function in order to get\nthe length of the string. This function works like `strlen` of the libc\nexcept that:\n\n* It runs in constant time since the length is stored in the prefix of SDS strings, so calling `sdslen` is not expensive even when called with very large strings.\n* The function is binary safe like any other SDS string function, so the length is the true length of the string regardless of the content, there is no problem if the string includes null term characters in the middle.\n\nAs an example of the binary safeness of SDS strings, we can run the following\ncode:\n\n```c\nsds s = sdsnewlen(\"A\\0\\0B\",4);\nprintf(\"%d\\n\", (int) sdslen(s));\n\noutput> 4\n```\n\nNote that SDS strings are always null terminated at the end, so even in that\ncase `s[4]` will be a null term, however printing the string with `printf`\nwould result in just `\"A\"` to be printed since libc will treat the SDS string\nlike a normal C string.\n\nDestroying strings\n---\n\n```c\nvoid sdsfree(sds s);\n```\n\nThe destroy an SDS string there is just to call `sdsfree` with the string\npointer. Note that even empty strings created with `sdsempty` need to be\ndestroyed as well otherwise they'll result into a memory leak.\n\nThe function `sdsfree` does not perform any operation if instead of an SDS\nstring pointer, `NULL` is passed, so you don't need to check for `NULL` explicitly before calling it:\n\n```c\nif (string) sdsfree(string); /* Not needed. */\nsdsfree(string); /* Same effect but simpler. */\n```\n\nConcatenating strings\n---\n\nConcatenating strings to other strings is likely the operation you will end\nusing the most with a dynamic C string library. SDS provides different\nfunctions to concatenate strings to existing strings.\n\n```c\nsds sdscatlen(sds s, const void *t, size_t len);\nsds sdscat(sds s, const char *t);\n```\n\nThe main string concatenation functions are `sdscatlen` and `sdscat` that are\nidentical, the only difference being that `sdscat` does not have an explicit\nlength argument since it expects a null terminated string.\n\n```c\nsds s = sdsempty();\ns = sdscat(s, \"Hello \");\ns = sdscat(s, \"World!\");\nprintf(\"%s\\n\", s);\n\noutput> Hello World!\n```\n\nSometimes you want to cat an SDS string to another SDS string, so you don't\nneed to specify the length, but at the same time the string does not need to\nbe null terminated but can contain any binary data. For this there is a\nspecial function:\n\n```c\nsds sdscatsds(sds s, const sds t);\n```\n\nUsage is straightforward:\n\n```c\nsds s1 = sdsnew(\"aaa\");\nsds s2 = sdsnew(\"bbb\");\ns1 = sdscatsds(s1,s2);\nsdsfree(s2);\nprintf(\"%s\\n\", s1);\n\noutput> aaabbb\n```\n\nSometimes you don't want to append any special data to the string, but you want\nto make sure that there are at least a given number of bytes composing the\nwhole string.\n\n```c\nsds sdsgrowzero(sds s, size_t len);\n```\n\nThe `sdsgrowzero` function will do nothing if the current string length is\nalready `len` bytes, otherwise it will enlarge the string to `len` just padding\nit with zero bytes.\n\n```c\nsds s = sdsnew(\"Hello\");\ns = sdsgrowzero(s,6);\ns[5] = '!'; /* We are sure this is safe because of sdsgrowzero() */\nprintf(\"%s\\n', s);\n\noutput> Hello!\n```\n\nFormatting strings\n---\n\nThere is a special string concatenation function that accepts a `printf` alike\nformat specifier and cats the formatted string to the specified string.\n\n```c\nsds sdscatprintf(sds s, const char *fmt, ...) {\n```\n\nExample:\n\n```c\nsds s;\nint a = 10, b = 20;\ns = sdsnew(\"The sum is: \");\ns = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b);\n```\n\nOften you need to create SDS string directly from `printf` format specifiers.\nBecause `sdscatprintf` is actually a function that concatenates strings, all\nyou need is to concatenate your string to an empty string:\n\n\n```c\nchar *name = \"Anna\";\nint loc = 2500;\nsds s;\ns = sdscatprintf(sdsempty(), \"%s wrote %d lines of LISP\\n\", name, loc);\n```\n\nYou can use `sdscatprintf` in order to convert numbers into SDS strings:\n\n```c\nint some_integer = 100;\nsds num = sdscatprintf(sdsempty(),\"%d\\n\", some_integer);\n```\n\nHowever this is slow and we have a special function to make it efficient.\n\nFast number to string operations\n---\n\nCreating an SDS string from an integer may be a common operation in certain\nkind of programs, and while you may do this with `sdscatprintf` the performance\nhit is big, so SDS provides a specialized function.\n\n```c\nsds sdsfromlonglong(long long value);\n```\n\nUse it like this:\n\n```c\nsds s = sdsfromlonglong(10000);\nprintf(\"%d\\n\", (int) sdslen(s));\n\noutput> 5\n```\n\nTrimming strings and getting ranges\n---\n\nString trimming is a common operation where a set of characters are\nremoved from the left and the right of the string. Another useful operation\nregarding strings is the ability to just take a range out of a larger\nstring.\n\n```c\nvoid sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, int start, int end);\n```\n\nSDS provides both the operations with the `sdstrim` and `sdsrange` functions.\nHowever note that both functions work differently than most functions modifying\nSDS strings since the return value is void: basically those functions always\ndestructively modify the passed SDS string, never allocating a new one, because\nboth trimming and ranges will never need more room: the operations can only\nremove characters from the original string.\n\nBecause of this behavior, both functions are fast and don't involve reallocation.\n\nThis is an example of string trimming where newlines and spaces are removed\nfrom an SDS strings:\n\n```c\nsds s = sdsnew(\"         my string\\n\\n  \");\nsdstrim(s,\" \\n\");\nprintf(\"-%s-\\n\",s);\n\noutput> -my string-\n```\n\nBasically `sdstrim` takes the SDS string to trim as first argument, and a\nnull terminated set of characters to remove from left and right of the string.\nThe characters are removed as long as they are not interrupted by a character\nthat is not in the list of characters to trim: this is why the space between\n`\"my\"` and `\"string\"` was preserved in the above example.\n\nTaking ranges is similar, but instead to take a set of characters, it takes\nto indexes, representing the start and the end as specified by zero-based\nindexes inside the string, to obtain the range that will be retained.\n\n```c\nsds s = sdsnew(\"Hello World!\");\nsdsrange(s,1,4);\nprintf(\"-%s-\\n\");\n\noutput> -ello-\n```\n\nIndexes can be negative to specify a position starting from the end of the\nstring, so that `-1` means the last character, `-2` the penultimate, and so forth:\n\n```c\nsds s = sdsnew(\"Hello World!\");\nsdsrange(s,6,-1);\nprintf(\"-%s-\\n\");\nsdsrange(s,0,-2);\nprintf(\"-%s-\\n\");\n\noutput> -World!-\noutput> -World-\n```\n\n`sdsrange` is very useful when implementing networking servers processing\na protocol or sending messages. For example the following code is used\nimplementing the write handler of the Redis Cluster message bus between\nnodes:\n\n```c\nvoid clusterWriteHandler(..., int fd, void *privdata, ...) {\n    clusterLink *link = (clusterLink*) privdata;\n    ssize_t nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));\n    if (nwritten <= 0) {\n        /* Error handling... */\n    }\n    sdsrange(link->sndbuf,nwritten,-1);\n    ... more code here ...\n}\n```\n\nEvery time the socket of the node we want to send the message to is writable\nwe attempt to write as much bytes as possible, and we use `sdsrange` in order\nto remove from the buffer what was already sent.\n\nThe function to queue new messages to send to some node in the cluster will\nsimply use `sdscatlen` in order to put more data in the send buffer.\n\nNote that the Redis Cluster bus implements a binary protocol, but since SDS\nis binary safe this is not a problem, so the goal of SDS is not just to provide\nan high level string API for the C programmer but also dynamically allocated\nbuffers that are easy to manage.\n\nString copying\n---\n\nThe most dangerous and infamus function of the standard C library is probably\n`strcpy`, so perhaps it is funny how in the context of better designed dynamic\nstring libraries the concept of copying strings is almost irrelevant. Usually\nwhat you do is to create strings with the content you want, or concatenating\nmore content as needed.\n\nHowever SDS features a string copy function that is useful in performance\ncritical code sections, however I guess its practical usefulness is limited\nas the function never managed to get called in the context of the 50k\nlines of code composing the Redis code base.\n\n```c\nsds sdscpylen(sds s, const char *t, size_t len);\nsds sdscpy(sds s, const char *t);\n```\n\nThe string copy function of SDS is called `sdscpylen` and works like that:\n\n```c\ns = sdsnew(\"Hello World!\");\ns = sdscpylen(s,\"Hello Superman!\",15);\n```\n\nAs you can see the function receives as input the SDS string `s`, but also\nreturns an SDS string. This is common to many SDS functions that modify the\nstring: this way the returned SDS string may be the original one modified\nor a newly allocated one (for example if there was not enough room in the\nold SDS string).\n\nThe `sdscpylen` will simply replace what was in the old SDS string with the\nnew data you pass using the pointer and length argument. There is a similar\nfunction called `sdscpy` that does not need a length but expects a null\nterminated string instead.\n\nYou may wonder why it makes sense to have a string copy function in the\nSDS library, since you can simply create a new SDS string from scratch\nwith the new value instead of copying the value in an existing SDS string.\nThe reason is efficiency: `sdsnewlen` will always allocate a new string\nwhile `sdscpylen` will try to reuse the existing string if there is enough\nroom to old the new content specified by the user, and will allocate a new\none only if needed.\n\nQuoting strings\n---\n\nIn order to provide consistent output to the program user, or for debugging\npurposes, it is often important to turn a string that may contain binary\ndata or special characters into a quoted string. Here for quoted string\nwe mean the common format for String literals in programming source code.\nHowever today this format is also part of the well known serialization formats\nlike JSON and CSV, so it definitely escaped the simple goal of representing\nliterals strings in the source code of programs.\n\nAn example of quoted string literal is the following:\n\n```c\n\"\\x00Hello World\\n\"\n```\n\nThe first byte is a zero byte while the last byte is a newline, so there are\ntwo non alphanumerical characters inside the string.\n\nSDS uses a concatenation function for this goal, that concatenates to an\nexisting string the quoted string representation of the input string.\n\n```c\nsds sdscatrepr(sds s, const char *p, size_t len);\n```\n\nThe `scscatrepr` (where `repr` means *representation*) follows the usualy\nSDS string function rules accepting a char pointer and a length, so you can\nuse it with SDS strings, normal C strings by using strlen() as `len` argument,\nor binary data. The following is an example usage:\n\n```c\nsds s1 = sdsnew(\"abcd\");\nsds s2 = sdsempty();\ns[1] = 1;\ns[2] = 2;\ns[3] = '\\n';\ns2 = sdscatrepr(s2,s1,sdslen(s1));\nprintf(\"%s\\n\", s2);\n\noutput> \"a\\x01\\x02\\n\"\n```\n\nThis is the rules `sdscatrepr` uses for conversion:\n\n* `\\` and `\"` are quoted with a backslash.\n* It quotes special characters `'\\n'`, `'\\r'`, `'\\t'`, `'\\a'` and `'\\b'`.\n* All the other non printable characters not passing the `isprint` test are quoted in `\\x..` form, that is: backslash followed by `x` followed by two digit hex number representing the character byte value.\n* The function always adds initial and final double quotes characters.\n\nThere is an SDS function that is able to perform the reverse conversion and is\ndocumented in the *Tokenization* section below.\n\nTokenization\n---\n\nTokenization is the process of splitting a larger string into smaller strings.\nIn this specific case, the split is performed specifying another string that\nacts as separator. For example in the following string there are two substrings\nthat are separated by the `|-|` separator:\n\n```\nfoo|-|bar|-|zap\n```\n\nA more common separator that consists of a single character is the comma:\n\n```\nfoo,bar,zap\n```\n\nIn many progrems it is useful to process a line in order to obtain the sub\nstrings it is composed of, so SDS provides a function that returns an\narray of SDS strings given a string and a separator.\n\n```c\nsds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\n```\n\nAs usually the function can work with both SDS strings or normal C strings.\nThe first two arguments `s` and `len` specify the string to tokenize, and the\nother two arguments `sep` and `seplen` the separator to use during the\ntokenization. The final argument `count` is a pointer to an integer that will\nbe set to the number of tokens (sub strings) returned.\n\nThe return value is a heap allocated array of SDS strings.\n\n```c\nsds *tokens;\nint count, j;\n\nsds line = sdsnew(\"Hello World!\");\ntokens = sdssplitlen(line,sdslen(line),\" \",1,&count);\n\nfor (j = 0; j < count; j++)\n    printf(\"%s\\n\", tokens[j]);\nsdsfreesplitres(tokens,count);\n\noutput> Hello\noutput> World!\n```\n\nThe returned array is heap allocated, and the single elements of the array\nare normal SDS strings. You can free everything calling `sdsfreesplitres`\nas in the example. Alternativey you are free to release the array yourself\nusing the `free` function and use and/or free the individual SDS strings\nas usually.\n\nA valid approach is to set the array elements you reused in some way to\n`NULL`, and use `sdsfreesplitres` to free all the rest.\n\nCommand line oriented tokenization\n---\n\nSplitting by a separator is a useful operation, but usually it is not enough\nto perform one of the most common tasks involving some non trivial string\nmanipulation, that is, implementing a **Command Line Interface** for a program.\n\nThis is why SDS also provides an additional function that allows you to split\narguments provided by the user via the keyboard in an interactive manner, or\nvia a file, network, or any other mean, into tokens.\n\n```c\nsds *sdssplitargs(const char *line, int *argc);\n```\n\nThe `sdssplitargs` function returns an array of SDS strings exactly like\n`sdssplitlen`. The function to free the result is also identical, and is\n`sdsfreesplitres`. The difference is in the way the tokenization is performed.\n\nFor example if the input is the following line:\n\n```\ncall \"Sabrina\"    and \"Mark Smith\\n\"\n```\n\nThe function will return the following tokens:\n\n* \"call\"\n* \"Sabrina\"\n* \"and\"\n* \"Mark Smith\\n\"\n\nBasically different tokens need to be separated by one or more spaces, and\nevery single token can also be a quoted string in the same format that\n`sdscatrepr` is able to emit.\n\nString joining\n---\n\nThere are two functions doing the reverse of tokenization by joining strings\ninto a single one.\n\n```c\nsds sdsjoin(char **argv, int argc, char *sep, size_t seplen);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n```\n\nThe two functions take as input an array of strings of length `argc` and\na separator and its length, and produce as output an SDS string consisting\nof all the specified strings separated by the specified separator.\n\nThe difference between `sdsjoin` and `sdsjoinsds` is that the former accept\nC null terminated strings as input while the latter requires all the strings\nin the array to be SDS strings. However because of this only `sdsjoinsds` is\nable to deal with binary data.\n\n```c\nchar *tokens[3] = {\"foo\",\"bar\",\"zap\"};\nsds s = sdsjoin(tokens,3,\"|\",1);\nprintf(\"%s\\n\", s);\n\noutput> foo|bar|zap\n```\n\nError handling\n---\n\nAll the SDS functions that return an SDS pointer may also return `NULL` on\nout of memory, this is basically the only check you need to perform.\n\nHowever many modern C programs handle out of memory simply aborting the program\nso you may want to do this as well by wrapping `malloc` and other related\nmemory allocation calls directly.\n\nSDS internals and advanced usage\n===\n\nAt the very beginning of this documentation it was explained how SDS strings\nare allocated, however the prefix stored before the pointer returned to the\nuser was classified as an *header* without further details. For an advanced\nusage it is better to dig more into the internals of SDS and show the\nstructure implementing it:\n\n```c\nstruct sdshdr {\n    int len;\n    int free;\n    char buf[];\n};\n```\n\nAs you can see, the structure may resemble the one of a conventional string\nlibrary, however the `buf` field of the structure is different since it is\nnot a pointer but an array without any length declared, so `buf` actually\npoints at the first byte just after the `free` integer. So in order to create\nan SDS string we just allocate a piece of memory that is as large as the\n`sdshdr` structure plus the length of our string, plus an additional byte\nfor the mandatory null term that every SDS string has.\n\nThe `len` field of the structure is quite obvious, and is the current length\nof the SDS string, always computed every time the string is modified via\nSDS function calls. The `free` field instead represents the amount of free\nmemory in the current allocation that can be used to store more characters.\n\nSo the actual SDS layout is this one:\n\n    +------------+------------------------+-----------+---------------\\\n    | Len | Free | H E L L O W O R L D \\n | Null term |  Free space   \\\n    +------------+------------------------+-----------+---------------\\\n                 |\n                 `-> Pointer returned to the user.\n\nYou may wonder why there is some free space at the end of the string, it\nlooks like a waste. Actually after a new SDS string is created, there is no\nfree space at the end at all: the allocation will be as small as possible to\njust hold the header, string, and null term. However other access patterns\nwill create extra free space at the end, like in the following program:\n\n```c\ns = sdsempty();\ns = sdscat(s,\"foo\");\ns = sdscat(s,\"bar\");\ns = sdscat(s,\"123\");\n```\n\nSince SDS tries to be efficient it can't afford to reallocate the string every\ntime new data is appended, since this would be very inefficient, so it uses\nthe **preallocation of some free space** every time you enlarge the string.\n\nThe preallocation algorithm used is the following: every time the string\nis reallocated in order to hold more bytes, the actual allocation size performed\nis two times the minimum required. So for instance if the string currently\nis holding 30 bytes, and we concatenate 2 more bytes, instead of allocating 32\nbytes in total SDS will allocate 64 bytes.\n\nHowever there is an hard limit to the allocation it can perform ahead, and is\ndefined by `SDS_MAX_PREALLOC`. SDS will never allocate more than 1MB of\nadditional space (by default, you can change this default).\n\nShrinking strings\n---\n\n```c\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\n```\n\nSometimes there are class of programs that require to use very little memory.\nAfter strings concatenations, trimming, ranges, the string may end having\na non trivial amount of additional space at the end.\n\nIt is possible to resize a string back to its minimal size in order to hold\nthe current content by using the function `sdsRemoveFreeSpace`.\n\n```c\ns = sdsRemoveFreeSpace(s);\n```\n\nThere is also a function that can be used in order to get the size of the\ntotal allocation for a given string, and is called `sdsAllocSize`.\n\n```c\nsds s = sdsnew(\"Ladies and gentlemen\");\ns = sdscat(s,\"... welcome to the C language.\");\nprintf(\"%d\\n\", (int) sdsAllocSize(s));\ns = sdsRemoveFreeSpace(s);\nprintf(\"%d\\n\", (int) sdsAllocSize(s));\n\noutput> 109\noutput> 59\n```\n\nNOTE: SDS Low level API use cammelCase in order to warn you that you are playing with the fire.\n\nManual modifications of SDS strings\n---\n\n    void sdsupdatelen(sds s);\n\nSometimes you may want to hack with an SDS string manually, without using\nSDS functions. In the following example we implicitly change the length\nof the string, however we want the logical length to reflect the null terminated\nC string.\n\nThe function `sdsupdatelen` does just that, updating the internal length\ninformation for the specified string to the length obtained via `strlen`.\n\n```c\nsds s = sdsnew(\"foobar\");\ns[2] = '\\0';\nprintf(\"%d\\n\", sdslen(s));\nsdsupdatelen(s);\nprintf(\"%d\\n\", sdslen(s));\n\noutput> 6\noutput> 2\n```\n\nSharing SDS strings\n---\n\nIf you are writing a program in which it is advantageous to share the same\nSDS string across different data structures, it is absolutely advised to\nencapsulate SDS strings into structures that remember the number of references\nof the string, with functions to increment and decrement the number of references.\n\nThis approach is a memory management technique called *reference counting* and\nin the context of SDS has two advantages:\n\n* It is less likely that you'll create memory leaks or bugs due to non freeing SDS strings or freeing already freed strings.\n* You'll not need to update every reference to an SDS string when you modify it (since the new SDS string may point to a different memory location).\n\nWhile this is definitely a very common programming technique I'll outline\nthe basic ideas here. You create a structure like that:\n\n```c\nstruct mySharedString {\n    int refcount;\n    sds string;\n}\n```\n\nWhen new strings are created, the structure is allocated and returned with\n`refcount` set to 1. The you have two functions to change the reference count\nof the shared string:\n\n* `incrementStringRefCount` will simply increment `refcount` of 1 in the structure. It will be called every time you add a reference to the string on some new data structure, variable, or whatever.\n* `decrementStringRefCount` is used when you remove a reference. This function is however special since when the `refcount` drops to zero, it automatically frees the SDS string, and the `mySharedString` structure as well.\n\nInteractions with heap checkers\n---\n\nBecause SDS returns pointers into the middle of memory chunks allocated with\n`malloc`, heap checkers may have issues, however:\n\n* The popular Valgrind program will detect SDS strings are *possibly lost* memory and never as *definitely lost*, so it is easy to tell if there is a leak or not. I used Valgrind with Redis for years and every real leak was consistently detected as \"definitely lost\".\n* OSX instrumentation tools don't detect SDS strings as leaks but are able to correctly handle pointers pointing to the middle of memory chunks.\n\nZero copy append from syscalls\n----\n\nAt this point you should have all the tools to dig more inside the SDS\nlibrary by reading the source code, however there is an interesting pattern\nyou can mount using the low level API exported, that is used inside Redis\nin order to improve performances of the networking code.\n\nUsing `sdsIncrLen()` and `sdsMakeRoomFor()` it is possible to mount the\nfollowing schema, to cat bytes coming from the kernel to the end of an\nsds string without copying into an intermediate buffer:\n\n```c\noldlen = sdslen(s);\ns = sdsMakeRoomFor(s, BUFFER_SIZE);\nnread = read(fd, s+oldlen, BUFFER_SIZE);\n... check for nread <= 0 and handle it ...\nsdsIncrLen(s, nread);\n```\n\n`sdsIncrLen` is documented inside the source code of `sds.c`.\n\nEmbedding SDS into your project\n===\n\nThis is as simple as copying the following files inside your\nproject:\n\n* sds.c\n* sds.h\n* sdsalloc.h\n\nThe source code is small and every C99 compiler should deal with\nit without issues.\n\nUsing a different allocator for SDS\n===\n\nInternally sds.c uses the allocator defined into `sdsalloc.h`. This header\nfile just defines macros for malloc, realloc and free, and by default libc\n`malloc()`, `realloc()` and `free()` are used. Just edit this file in order\nto change the name of the allocation functions.\n\nThe program using SDS can call the SDS allocator in order to manipulate\nSDS pointers (usually not needed but sometimes the program may want to\ndo advanced things) by using the API exported by SDS in order to call the\nallocator used. This is especially useful when the program linked to SDS\nis using a different allocator compared to what SDS is using.\n\nThe API to access the allocator used by SDS is composed of three functions: `sds_malloc()`, `sds_realloc()` and `sds_free()`.\n\nCredits and license\n===\n\nSDS was created by Salvatore Sanfilippo and is released under the BDS two clause license. See the LICENSE file in this source distribution for more information.\n\nOran Agra improved SDS version 2 by adding dynamic sized headers in order to\nsave memory for small strings and allow strings greater than 4GB.\n"
        },
        {
          "name": "sds.c",
          "type": "blob",
          "size": 40.9677734375,
          "content": "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <limits.h>\n#include \"sds.h\"\n#include \"sdsalloc.h\"\n\nconst char *SDS_NOINIT = \"SDS_NOINIT\";\n\nstatic inline int sdsHdrSize(char type) {\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            return sizeof(struct sdshdr8);\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16);\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32);\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64);\n    }\n    return 0;\n}\n\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5)\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-terminated (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}\n\n/* Create an empty (zero length) sds string. Even in this case the string\n * always has an implicit null term. */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n\n/* Create a new sds string starting from a null terminated C string. */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n\n/* Duplicate an sds string. */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n\n/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n *\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\nvoid sdsupdatelen(sds s) {\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}\n\n/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\nvoid sdsclear(sds s) {\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}\n\n/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen); /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}\n\n/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdsRemoveFreeSpace(sds s) {\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);\n    size_t len = sdslen(s);\n    size_t avail = sdsavail(s);\n    sh = (char*)s-oldhdrlen;\n\n    /* Return ASAP if there is no space left. */\n    if (avail == 0) return s;\n\n    /* Check what would be the minimum SDS header that is just good enough to\n     * fit this string. */\n    type = sdsReqType(len);\n    hdrlen = sdsHdrSize(type);\n\n    /* If the type is the same, or at least a large enough type is still\n     * required, we just realloc(), letting the allocator to do the copy\n     * only if really needed. Otherwise if the change is huge, we manually\n     * reallocate the string to use the different header type. */\n    if (oldtype==type || type > SDS_TYPE_8) {\n        newsh = s_realloc(sh, oldhdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+oldhdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, len);\n    return s;\n}\n\n/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\nsize_t sdsAllocSize(sds s) {\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}\n\n/* Return the pointer of the actual SDS allocation (normally SDS strings\n * are referenced by the start of the string buffer). */\nvoid *sdsAllocPtr(sds s) {\n    return (void*) (s-sdsHdrSize(s[-1]));\n}\n\n/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\nvoid sdsIncrLen(sds s, ssize_t incr) {\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}\n\n/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\nsds sdsgrowzero(sds s, size_t len) {\n    size_t curlen = sdslen(s);\n\n    if (len <= curlen) return s;\n    s = sdsMakeRoomFor(s,len-curlen);\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s);\n\n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}\n\n/* Append the specified null termianted C string to the sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n\n/* Append the specified sds 't' to the existing sds 's'.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n\n/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\nsds sdscpylen(sds s, const char *t, size_t len) {\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Like sdscpylen() but 't' must be a null-terminated string so that the length\n * of the string is obtained with strlen(). */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    if (value < 0) {\n        /* Since v is unsigned, if value==LLONG_MIN then\n         * -LLONG_MIN will overflow. */\n        if (value != LLONG_MIN) {\n            v = -value;\n        } else {\n            v = ((unsigned long long)LLONG_MAX) + 1;\n        }\n    } else {\n        v = value;\n    }\n\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Identical sdsll2str(), but for unsigned long long type. */\nint sdsull2str(char *s, unsigned long long v) {\n    char *p, aux;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}\n\n/* Like sdscatprintf() but gets va_list instead of being variadic. */\nsds sdscatvprintf(sds s, const char *fmt, va_list ap) {\n    va_list cpy;\n    char staticbuf[1024], *buf = staticbuf, *t;\n    size_t buflen = strlen(fmt)*2;\n    int bufstrlen;\n\n    /* We try to start using a static buffer for speed.\n     * If not possible we revert to heap allocation. */\n    if (buflen > sizeof(staticbuf)) {\n        buf = s_malloc(buflen);\n        if (buf == NULL) return NULL;\n    } else {\n        buflen = sizeof(staticbuf);\n    }\n\n    /* Alloc enough space for buffer and \\0 after failing to\n     * fit the string in the current buffer size. */\n    while(1) {\n        va_copy(cpy,ap);\n        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);\n        va_end(cpy);\n        if (bufstrlen < 0) {\n            if (buf != staticbuf) s_free(buf);\n            return NULL;\n        }\n        if (((size_t)bufstrlen) >= buflen) {\n            if (buf != staticbuf) s_free(buf);\n            buflen = ((size_t)bufstrlen) + 1;\n            buf = s_malloc(buflen);\n            if (buf == NULL) return NULL;\n            continue;\n        }\n        break;\n    }\n\n    /* Finally concat the obtained string to the SDS string and return it. */\n    t = sdscatlen(s, buf, bufstrlen);\n    if (buf != staticbuf) s_free(buf);\n    return t;\n}\n\n/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\nsds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}\n\n/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\nsds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, initlen + strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            if (next == '\\0') break;\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}\n\n/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminated C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\nsds sdstrim(sds s, const char *cset) {\n    char *end, *sp, *ep;\n    size_t len;\n\n    sp = s;\n    ep = end = s+sdslen(s)-1;\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--;\n    len = (ep-sp)+1;\n    if (s != sp) memmove(s, sp, len);\n    s[len] = '\\0';\n    sdssetlen(s,len);\n    return s;\n}\n\n/* Turn the string into a smaller (or equal) string containing only the\n * substring specified by the 'start' and 'end' indexes.\n *\n * start and end can be negative, where -1 means the last character of the\n * string, -2 the penultimate character, and so forth.\n *\n * The interval is inclusive, so the start and end characters will be part\n * of the resulting string.\n *\n * The string is modified in-place.\n *\n * Example:\n *\n * s = sdsnew(\"Hello World\");\n * sdsrange(s,1,-1); => \"ello World\"\n */\nvoid sdsrange(sds s, ssize_t start, ssize_t end) {\n    size_t newlen, len = sdslen(s);\n\n    if (len == 0) return;\n    if (start < 0) {\n        start = len+start;\n        if (start < 0) start = 0;\n    }\n    if (end < 0) {\n        end = len+end;\n        if (end < 0) end = 0;\n    }\n    newlen = (start > end) ? 0 : (end-start)+1;\n    if (newlen != 0) {\n        if (start >= (ssize_t)len) {\n            newlen = 0;\n        } else if (end >= (ssize_t)len) {\n            end = len-1;\n            newlen = (end-start)+1;\n        }\n    }\n    if (start && newlen) memmove(s, s+start, newlen);\n    s[newlen] = 0;\n    sdssetlen(s,newlen);\n}\n\n/* Apply tolower() to every character of the sds string 's'. */\nvoid sdstolower(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}\n\n/* Apply toupper() to every character of the sds string 's'. */\nvoid sdstoupper(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}\n\n/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\nint sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}\n\n/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5;\n    long start = 0, j;\n    sds *tokens;\n\n    if (seplen < 1 || len <= 0) {\n        *count = 0;\n        return NULL;\n    }\n\n    tokens = s_malloc(sizeof(sds)*slots);\n    if (tokens == NULL) return NULL;\n\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        if (slots < elements+2) {\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) goto cleanup;\n            tokens = newtokens;\n        }\n        /* search the separator */\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start);\n            if (tokens[elements] == NULL) goto cleanup;\n            elements++;\n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start);\n    if (tokens[elements] == NULL) goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        s_free(tokens);\n        *count = 0;\n        return NULL;\n    }\n}\n\n/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\nvoid sdsfreesplitres(sds *tokens, int count) {\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}\n\n/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s,\"\\\"\",1);\n    while(len--) {\n        switch(*p) {\n        case '\\\\':\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:\n            if (isprint(*p))\n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1);\n}\n\n/* Helper function for sdssplitargs() that returns non zero if 'c'\n * is a valid hex digit. */\nint is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n           (c >= 'A' && c <= 'F');\n}\n\n/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\nint hex_digit_to_int(char c) {\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}\n\n/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\nsds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */\n            int insq=0; /* set to 1 if we are in 'single quotes' */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);\n                        p += 3;\n                    } else if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) {\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    case '\\'':\n                        insq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}\n\n/* Modify the string substituting all the occurrences of the set of\n * characters specified in the 'from' string to the corresponding character\n * in the 'to' array.\n *\n * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2)\n * will have the effect of turning the string \"hello\" into \"0ell1\".\n *\n * The function returns the sds string pointer, that is always the same\n * as the input pointer since no resize is needed. */\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\nsds sdsjoin(char **argv, int argc, char *sep) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}\n\n/* Like sdsjoin, but joins an array of SDS strings. */\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}\n\n/* Wrappers to the allocators used by SDS. Note that SDS will actually\n * just use the macros defined into sdsalloc.h in order to avoid to pay\n * the overhead of function calls. Here we define these wrappers only for\n * the programs SDS is linked to, if they want to touch the SDS internals\n * even if they use a different allocator. */\nvoid *sds_malloc(size_t size) { return s_malloc(size); }\nvoid *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\nvoid sds_free(void *ptr) { s_free(ptr); }\n\n#if defined(SDS_TEST_MAIN)\n#include <stdio.h>\n#include \"testhelp.h\"\n#include \"limits.h\"\n\n#define UNUSED(x) (void)(x)\nint sdsTest(void) {\n    {\n        sds x = sdsnew(\"foo\"), y;\n\n        test_cond(\"Create a string and obtain the length\",\n            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnewlen(\"foo\",2);\n        test_cond(\"Create a string with specified length\",\n            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n\n        x = sdscat(x,\"bar\");\n        test_cond(\"Strings concatenation\",\n            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\n        x = sdscpy(x,\"a\");\n        test_cond(\"sdscpy() against an originally longer string\",\n            sdslen(x) == 1 && memcmp(x,\"a\\0\",2) == 0)\n\n        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\");\n        test_cond(\"sdscpy() against an originally shorter string\",\n            sdslen(x) == 33 &&\n            memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0\",33) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"%d\",123);\n        test_cond(\"sdscatprintf() seems working in the base case\",\n            sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"a%cb\",0);\n        test_cond(\"sdscatprintf() seems working with \\\\0 inside of result\",\n            sdslen(x) == 3 && memcmp(x,\"a\\0\"\"b\\0\",4) == 0)\n\n        {\n            sdsfree(x);\n            char etalon[1024*1024];\n            for (size_t i = 0; i < sizeof(etalon); i++) {\n                etalon[i] = '0';\n            }\n            x = sdscatprintf(sdsempty(),\"%0*d\",(int)sizeof(etalon),0);\n            test_cond(\"sdscatprintf() can print 1MB\",\n                sdslen(x) == sizeof(etalon) && memcmp(x,etalon,sizeof(etalon)) == 0)\n        }\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n        test_cond(\"sdscatfmt() seems working in the base case\",\n            sdslen(x) == 60 &&\n            memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\n                     \"9223372036854775807--\",60) == 0)\n        printf(\"[%s]\\n\",x);\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n        test_cond(\"sdscatfmt() seems working with unsigned numbers\",\n            sdslen(x) == 35 &&\n            memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" x\");\n        test_cond(\"sdstrim() works when all chars match\",\n            sdslen(x) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" \");\n        test_cond(\"sdstrim() works when a single char remains\",\n            sdslen(x) == 1 && x[0] == 'x')\n\n        sdsfree(x);\n        x = sdsnew(\"xxciaoyyy\");\n        sdstrim(x,\"xy\");\n        test_cond(\"sdstrim() correctly trims characters\",\n            sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n\n        y = sdsdup(x);\n        sdsrange(y,1,1);\n        test_cond(\"sdsrange(...,1,1)\",\n            sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,-1);\n        test_cond(\"sdsrange(...,1,-1)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,-2,-1);\n        test_cond(\"sdsrange(...,-2,-1)\",\n            sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,2,1);\n        test_cond(\"sdsrange(...,2,1)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,100);\n        test_cond(\"sdsrange(...,1,100)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,100,100);\n        test_cond(\"sdsrange(...,100,100)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"foo\");\n        y = sdsnew(\"foa\");\n        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y) > 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"bar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"aar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) < 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n        y = sdscatrepr(sdsempty(),x,sdslen(x));\n        test_cond(\"sdscatrepr(...data...)\",\n            memcmp(y,\"\\\"\\\\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n\n        {\n            char *p;\n            int step = 10, j, i;\n\n            sdsfree(x);\n            sdsfree(y);\n            x = sdsnew(\"0\");\n            test_cond(\"sdsnew() free/len buffers\", sdslen(x) == 1 && sdsavail(x) == 0);\n\n            /* Run the test a few times in order to hit the first two\n             * SDS header types. */\n            for (i = 0; i < 10; i++) {\n                int oldlen = sdslen(x);\n                x = sdsMakeRoomFor(x,step);\n                int type = x[-1]&SDS_TYPE_MASK;\n\n                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n                if (type != SDS_TYPE_5) {\n                    test_cond(\"sdsMakeRoomFor() free\", sdsavail(x) >= step);\n                }\n                p = x+oldlen;\n                for (j = 0; j < step; j++) {\n                    p[j] = 'A'+j;\n                }\n                sdsIncrLen(x,step);\n            }\n            test_cond(\"sdsMakeRoomFor() content\",\n                memcmp(\"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\",x,101) == 0);\n            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n\n            sdsfree(x);\n        }\n    }\n    test_report()\n    return 0;\n}\n#endif\n\n#ifdef SDS_TEST_MAIN\nint main(void) {\n    return sdsTest();\n}\n#endif\n"
        },
        {
          "name": "sds.h",
          "type": "blob",
          "size": 8.7705078125,
          "content": "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __SDS_H\n#define __SDS_H\n\n#define SDS_MAX_PREALLOC (1024*1024)\nextern const char *SDS_NOINIT;\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdint.h>\n\ntypedef char *sds;\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n\nstatic inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}\n\nstatic inline size_t sdsavail(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            return 0;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            return sh->alloc - sh->len;\n        }\n    }\n    return 0;\n}\n\nstatic inline void sdssetlen(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len = newlen;\n            break;\n    }\n}\n\nstatic inline void sdsinclen(sds s, size_t inc) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len += inc;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len += inc;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len += inc;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len += inc;\n            break;\n    }\n}\n\n/* sdsalloc() = sdsavail() + sdslen() */\nstatic inline size_t sdsalloc(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->alloc;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->alloc;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->alloc;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->alloc;\n    }\n    return 0;\n}\n\nstatic inline void sdssetalloc(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            /* Nothing to do, this type has no total allocation info. */\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->alloc = newlen;\n            break;\n    }\n}\n\nsds sdsnewlen(const void *init, size_t initlen);\nsds sdsnew(const char *init);\nsds sdsempty(void);\nsds sdsdup(const sds s);\nvoid sdsfree(sds s);\nsds sdsgrowzero(sds s, size_t len);\nsds sdscatlen(sds s, const void *t, size_t len);\nsds sdscat(sds s, const char *t);\nsds sdscatsds(sds s, const sds t);\nsds sdscpylen(sds s, const char *t, size_t len);\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nsds sdscatfmt(sds s, char const *fmt, ...);\nsds sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, ssize_t start, ssize_t end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n/* Low level functions exposed to the user API */\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, ssize_t incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\nvoid *sdsAllocPtr(sds s);\n\n/* Export the allocator used by SDS to the program using SDS.\n * Sometimes the program SDS is linked to, may use a different set of\n * allocators, but may want to allocate or free things that SDS will\n * respectively free or allocate. */\nvoid *sds_malloc(size_t size);\nvoid *sds_realloc(void *ptr, size_t size);\nvoid sds_free(void *ptr);\n\n#ifdef REDIS_TEST\nint sdsTest(int argc, char *argv[]);\n#endif\n\n#endif\n"
        },
        {
          "name": "sdsalloc.h",
          "type": "blob",
          "size": 2.04296875,
          "content": "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* SDS allocator selection.\n *\n * This file is used in order to change the SDS allocator at compile time.\n * Just define the following defines to what you want to use. Also add\n * the include of your alternate allocator if needed (not needed in order\n * to use the default libc allocator). */\n\n#define s_malloc malloc\n#define s_realloc realloc\n#define s_free free\n"
        },
        {
          "name": "testhelp.h",
          "type": "blob",
          "size": 2.3740234375,
          "content": "/* This is a really minimal testing framework for C.\n *\n * Example:\n *\n * test_cond(\"Check if 1 == 1\", 1==1)\n * test_cond(\"Check if 5 > 10\", 5 > 10)\n * test_report()\n *\n * ----------------------------------------------------------------------------\n *\n * Copyright (c) 2010-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __TESTHELP_H\n#define __TESTHELP_H\n\nint __failed_tests = 0;\nint __test_num = 0;\n#define test_cond(descr,_c) do { \\\n    __test_num++; printf(\"%d - %s: \", __test_num, descr); \\\n    if(_c) printf(\"PASSED\\n\"); else {printf(\"FAILED\\n\"); __failed_tests++;} \\\n} while(0);\n#define test_report() do { \\\n    printf(\"%d tests, %d passed, %d failed\\n\", __test_num, \\\n                    __test_num-__failed_tests, __failed_tests); \\\n    if (__failed_tests) { \\\n        printf(\"=== WARNING === We have failed tests here...\\n\"); \\\n        exit(1); \\\n    } \\\n} while(0);\n\n#endif\n"
        }
      ]
    }
  ]
}