{
  "metadata": {
    "timestamp": 1736709705790,
    "page": 86,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Facico/Chinese-Vicuna",
      "stars": 4153,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3544921875,
          "content": "__pycache__/\n*ckpt\nwandb\nruns\nflagged\nsave\n#optimizer.pt\n#rng_state*\n#scaler.pt\n#scheduler.pt\n#trainer_state.json\n#training_args.bin\n#pytorch_model.bin\n# cpp out files\nchat\n!sample/chat\nquantize\n*.o\n*.a\nMakefile\n.idea\ncmake*\nCMakeCache.txt\nCMakeFiles\n.cmake*\nTesting\n.ninja*\nbuild.*\nouts\nlora-poetry/\nmerge_lora_peft.py\nmerge_lora_mannally.py\ntest.py\nlora-Vicuna/"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 55.712890625,
          "content": "![camel](https://github.com/Facico/Chinese-Vicuna/blob/master/img/vicuna-llama.png)\n\n# Chinese-Vicuna: A Chinese Instruction-following LLaMA-based Model —— 一个中文低资源的llama+lora方案\n\n![GitHub Repo stars](https://img.shields.io/github/stars/Facico/Chinese-Vicuna?style=social) [![HuggingFace badge](https://camo.githubusercontent.com/4a295d6d34ed2c79cfe624ce6358a4be53d4187c883aaa9345fdc322937ce542/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f25463025394625413425393748756767696e67466163652d4a6f696e2d79656c6c6f77)](https://huggingface.co/Chinese-Vicuna) [![qq join](https://img.shields.io/badge/qq%E7%BE%A4%3A532581765-join-red)](https://jq.qq.com/?_wv=1027&k=47Z6bRjw) [![discord join](https://img.shields.io/badge/discord-join-blue)](https://discord.gg/4FnhmeNHku)\n \n | [English](https://github.com/Facico/Chinese-Vicuna/blob/master/README.md) | [中文](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/readme-zh.md) | [NOTE&FAQ(Please take a look before using)](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/notes.md)\n\n![camel](https://github.com/Facico/Chinese-Vicuna/blob/master/img/camel.png)\n\nThis is the repo for the Chinese-Vicuna project, which aims to build and share instruction-following Chinese LLaMA model tuning methods which can be trained on **a single Nvidia RTX-2080TI**, multi-round chatbot which can be trained on **a single Nvidia RTX-3090** with the context len 2048. \n\nWhy is it called `Vicuna`: In view of the successful development of alpaca models such as [llama](https://github.com/facebookresearch/llama),[alpaca](https://github.com/tatsu-lab/stanford_alpaca),[guanaco](https://github.com/Guanaco-Model/Guanaco-Model.github.io)，We want to train a Chinese small alpaca like Vicuna, small but strong enough ! \n\nThe advantages of our solution are high parameter efficiency, graphics card friendliness, and easy deployment:\n- Llama-7B instruction tuning is possible on a 2080Ti (11G) ([7b-instruct](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-7b-belle-and-guanaco))\n- Llama-13B instruction tuning is possible on a 3090 (24G) ([13b-instruct](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-13b-belle-and-guanaco))\n- Llama 7B can be fine-tuned on 3090 even for conversations of 2048 length; Use 50,000 pieces of data to get good results ([chatv1](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-7b-chatv1))\n- Llama 7B fine-tuning example on [medical](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-continue-finetune-7epoch-cMedQA2) and [legal](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-7b-legal-lora) domains\n- Support `qlora-4bit` which can train Llama 13B on 2080Ti. \n- Easily deployable on 2080Ti/3090, support multiple-gpu inference, which can reduce VRAM more.\n\nThe repo contains:\n- code for finetune the model \n- code for generation based on trained model\n- code for run on CPU (fp16 or int4 is support, in purely C++)\n- tools to download/convert/quantify original facebook llama.ckpt\n\nThis is our instruction demo (with beam-size=4, so you will see 4 process output in the meantime):\n\nhttps://user-images.githubusercontent.com/72137647/228496412-60043912-f491-430b-848a-599e6edfa5ef.mp4\n\nThis is our multi-turn instruction demo (with beam-size=4, so you will see 4 process output in the meantime):\n\nhttps://user-images.githubusercontent.com/72137647/229739363-1b48f3a9-02a1-46ab-81ee-8c62dc1399b2.mp4\n\n\n## NOTICE!\n\nBefore asking questions, take a look at this [FAQ](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/notes.md) first! In the FAQ, you can find how to solve problems may be encountered when installing and using this project.\n\n## What‘s New\n- **June, 12, 2023: Release [Chinese-Vicuna-4bit](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-7b-belle-and-guanaco-4bit) and[Chinese-Vicuna-4bit-11600](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-7b-belle-and-guanaco-4bit-11600) which can be continue-finetuned**\n- June, 1, 2023: support for 4bit training + inference, providing a multi-GPU inference interface (NOTICE THAT the environment is different from the original 8bit! Also provides test_tokenizers.py to further check EOS token)\n- May 17, 2023: Llama 7B fine-tuning example on [legal](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-7b-legal-lora) domains, The performance is in [here](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-chatv1-legal.md)\n- May 10, 2023: Released [chatv1](https://huggingface.co/Chinese-Vicuna/Chinese-Vicuna-lora-7b-chatv1) which have better conversational ability. The performance is in [here](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-chatv1.md)\n- May 10, 2023: Released [instruct_chat_50k.jsonl](https://huggingface.co/datasets/Chinese-Vicuna/instruct_chat_50k.jsonl) which is composed of 30k Chinese sharegpt dataset and 20k [alpaca-instruction-Chinese-dataset](https://github.com/hikariming/alpaca_chinese_dataset)\n- April 11, 2023: Released our continuous-finetune on the vertical corpus of Chinese medical quizzes [Chinese-Vicuna-medical](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-medical.md).Provides examples of vertical corpus training\n- April 4, 2023: Add performance for [13B](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-13B.md), which trains on a single 3090.\n- April 1, 2023: Add better support for multi-turn chat in `chat.py` ( Now support 4 generation mode in stream mode/typewriter style: beam search, greedy, sample, beam sample ; We also add cancel button for regeneration )\n- March 29, 2023: Add more detailed test samples. [performance](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance.md)\n- March 29, 2023: Added breakpoint retraining interface to support continued training of other datasets from our checkpoint\n- March 29, 2023: Released our new [13B-based lora model](https://huggingface.co/Chinese-Vicuna)\n- March 28, 2023: Released  our model on [huggingface](https://huggingface.co/Facico/Chinese-Vicuna-lora-7b-3epoch-belle-and-guanaco)\n- March 27, 2023: Released  checkpoint-final for training 3 epochs on belle+guanaco\n- March 27, 2023: Added multi-round interactive dialog script with alpaca-lora-serve service\n- March 29, 2023: Added gradio typewriter-like output with beam search, better user interaction support.\n- March 26, 2023: Provides a quantitative approach\n- March 24, 2023: Released checkpoint-8000 for training about 1.5 epochs on belle+guanaco（100w data）\n- March 23, 2023: Released checkpoint-4000 with 50w data training\n- March 23, 2023: Deploy the code for fine-tuning and inferencing in colab\n- March 23, 2023: Provides code that can be used for inference in pure c++\n\n\n## Table of Contents\n\n[Vicuna](https://github.com/Facico/Chinese-Vicuna)\n\n- [what's new](https://github.com/Facico/Chinese-Vicuna#whats-new)\n- [what is the meaning](https://github.com/Facico/Chinese-Vicuna#what-is-the-meaning)\n- [try on colab](https://github.com/Facico/Chinese-Vicuna#try-on-colab)\n- [performance](https://github.com/Facico/Chinese-Vicuna#performance)\n  - **Checkpoint-4000**(Facico/Chinese-Vicuna-lora-7b-0.75epoch-belle-and-guanaco)\n  - **Checkpoint-8000**(Facico/Chinese-Vicuna-lora-7b-1.5epoch-belle-and-guanaco)\n  - **Checkpoint-final**(Facico/Chinese-Vicuna-lora-7b-3epoch-belle-and-guanaco) and it is used for multiple rounds of dialogue\n- [What we need?](https://github.com/Facico/Chinese-Vicuna#what-we-need)\n  - code、data、Large Language Model、LORA model、Device\n- [How to use](https://github.com/Facico/Chinese-Vicuna#how-to-use)\n  - Installing、Multi-gpu training、Single-gpu training、Inference and use gradio to generate a web page(Streaming mode+beam search)、 multi-round interaction and use gradio to generate a web page(Streaming mode+beam search)、Streaming mode base on alpaca-lora-serve\n- [inference on CPU with pure C++](https://github.com/Facico/Chinese-Vicuna#inference-on-cpu-with-pure-c)\n- [More tools](https://github.com/Facico/Chinese-Vicuna#more-tools)，for more details, see [tool readme](https://github.com/Facico/Chinese-Vicuna/tree/master/tools)\n  - ways for faster weight download ( 8MB/s )`download_llama.sh`\n  - convert tools between the original facebook checkpoint and huggingface format`convert_llama.py`\n  - a quantitative approach that requires less than 4G graphics memory for inference\n- [Possible problems encountered](https://github.com/Facico/Chinese-Vicuna#possible-problems-encountered)\n- [todo](https://github.com/Facico/Chinese-Vicuna#todo)\n- [citation](https://github.com/Facico/Chinese-Vicuna#citation)\n\n## Overview\n\n-  LLaMA paper: https://arxiv.org/abs/2302.13971v1\n-  Self-Instruct paper: https://arxiv.org/abs/2212.10560\n-  data generation: https://github.com/LianjiaTech/BELLE and https://guanaco-model.github.io/\n-  the first work: https://github.com/tatsu-lab/stanford_alpaca\n\nWe currently select the combination of BELLE and Guanaco data as our main training dataset. \nWe will train on multi-turn instruction data.\n\n## What is the meaning?\n\nSimilar to the explosion of the stable diffusion model, platforms like civitai have emerged, consisting of a base model + various LORA models in an open source community.\n\nThe repo hopes to help you to train these LORA models.\n\n**what is LORA?**: Simply, it's a plugin used to help adapt large models to your dataset, technical details can be found in[LoRA: Low-Rank Adaptation of Large Language Models](https://arxiv.org/pdf/2106.09685.pdf)。Its advantage is that the finetune is very fast when it comes to getting a small model, about 30M, and the key is that it supports **Plug and Play**. As can be expected, this is a very suitable architecture for open source ecology.\n\nHere, we will help you train through a very low-demand environment, with only one **2080** (11G) to achieve certain results.\n\n## Try on colab\n\n| colab link                                                   | Descriptions                                                 |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [![Open In Colab](https://camo.githubusercontent.com/84f0493939e0c4de4e6dbe113251b4bfb5353e57134ffd9fcab6b8714514d4d1/68747470733a2f2f636f6c61622e72657365617263682e676f6f676c652e636f6d2f6173736574732f636f6c61622d62616467652e737667)](https://colab.research.google.com/drive/1OLCJ-ZHogm5O3RdyUDY83YfgnCXdHNXp?usp=sharing) | Use the specified lora model to inference and generate a webui |\n| [![Open In Colab](https://camo.githubusercontent.com/84f0493939e0c4de4e6dbe113251b4bfb5353e57134ffd9fcab6b8714514d4d1/68747470733a2f2f636f6c61622e72657365617263682e676f6f676c652e636f6d2f6173736574732f636f6c61622d62616467652e737667)](https://colab.research.google.com/drive/1SOOJjxp02uuUFDNgm4jkvaA_IdNnnvdk?usp=sharing) | Finetune with the data we collected                          |\n| [![Open In Colab](https://camo.githubusercontent.com/84f0493939e0c4de4e6dbe113251b4bfb5353e57134ffd9fcab6b8714514d4d1/68747470733a2f2f636f6c61622e72657365617263682e676f6f676c652e636f6d2f6173736574732f636f6c61622d62616467652e737667)](https://colab.research.google.com/drive/1Yc38cKifY1_sfTBJpEEKin8m2rxoYXtm?usp=sharing) | Provide a webui for multi-round dialogue interaction         |\n\n## Performance\n\n7B performance can be seen [here](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance.md), 13B is [here](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-13B.md) (which train on a single 3090). There are also people reporting that our method works on 33B and gains good result. \n\nhistory-checkpoint performance can be seen [here](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-history.md)\n\n\n<details>\n<summary><b>checkpoint-4000(7B)</b></summary>\n\n| Human                                            | Chinese-Vicuna                                               |\n| ------------------------------------------------ | ------------------------------------------------------------ |\n| 生成一份python的排序代码                         | A: def sort_list(lst):<br/>    lst.sort()<br/>    return lst |\n| 自然语言处理是什么                               | 自然语言处理是一种计算机科学领域，旨在使计算机能够理解和处理自然语言。 |\n| 能给我讲一段笑话吗                               | 为什么猫吃鱼？因为它们喜欢游泳。                             |\n| 将下面文字翻译成英文。猫喜欢吃鱼，所以它们会游泳 | Cats like to eat fish, so they will swim.                    |\n| 233和122的和等于多少                             | 233和122的和等于355。                                        |\n| 华为是一家怎样的公司                             | 华为是一家全球范围内最大的移动通信设备制造商之一，以及一家全球范围内最大的移动通信设备制造商之一。华为公司的业务涵盖包括移动通信设备、互联网设备、智能家居设备等。 |\n| 我想和女朋友在北京约会，能推荐几个约会的地方吗   | 北京有很多约会的地方，可以推荐以下几个约会的地方: <br/><br/>1. 北京艺术博物馆<br/>2. 颐和园<br/>3. 北京故宫博物馆<br/>4. 北京天安门广场<br/>5. 颐和园风景区 |\n| 用python写一个二分查找的代码                     | ```python<br/>def binary_search(arr, target):<br/>    low = 0<br/>    high = len(arr) - 1<br/>    while low <= high:<br/>        mid = (low + high) // 2<br/>        if arr[mid] == target:<br/>            return mid<br/>        elif arr[mid] < target:<br/>            low = mid + 1<br/>        else:<br/>            high = mid - 1<br/>    return -1 |\n| 怎么让自己精力充沛，列5点建议                    | 1. 保持良好的睡眠习惯；2. 定期锻炼身体；3. 学习新技能或知识；4. 与家人和朋友交流；5. 多听放松音乐。 |\n| 父母都姓吴，取一些男宝宝和女宝宝的名字           | 男宝宝可以是吴杰、吴伟、吴飞、吴荣等。女宝宝可以是吴华、吴秀、吴美、吴婷等。 |\n\n- This LORA model is the result of 30 hours of training with a 2080Ti (checkpoint-4000), about 50w data\n\n</details>\n\n<details>\n<summary><b>checkpoint-8000(7B, about 1.5 epoch on belle+guanaco)</b></summary>\n\n| Human                                                        | Chinese-Vicuna                                               | Note                    |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------- |\n| 写一篇英文散文诗，主题是春雨，想象自己是春雨，和英国古代诗人莎士比亚交流 | A: Spring rain falls softly on my face,<br/>A cool breeze blows through my hair,<br/>The sun shines brightly in the sky,<br/>And I feel as if I am flying high.<br/><br/>The birds chirp happily in the trees,<br/>The flowers bloom and their scent fills the air,<br/>The bees buzz gently from flower to flower,<br/>And the world seems to come alive once more.<br/><br/>I can hear the rush of the river,<br/>The sound of the waterfalls,<br/>The splash of the raindrops on the rocks,<br/>And the gentle murmur of the stream.<br/><br/>My heart is filled with joy and peace,<br/>As I take in the beauty around me,<br/>The warmth of the sun on my skin,<br/>And the freshness of the spring air. | Repetition Penalty=2.2  |\n| 写一篇英文散文诗，主题是春雨，想象自己是春雨，和英国古代诗人莎士比亚交流 | 春雨滴滴滚滚，<br/>滚滚滚滚滚滚。<br/>滚滚滚滚滚滚，<br/>滚滚滚滚滚滚。<br/><br/>春雨滚滚滚，<br/>滚滚滚滚滚滚。<br/>滚滚滚滚滚滚，<br/>滚滚滚滚滚滚。<br/><br/>春雨滚滚滚，<br/>滚滚滚滚滚滚。<br/>滚滚滚滚滚滚，<br/>滚滚滚滚滚滚。<br/><br/>春雨滚滚滚，<br/>滚滚滚 | Repetition Penalty=1.0  |\n| Spring rain falls softly on my face,<br/>A cool breeze blows through my hair,<br/>The sun shines brightly in the sky,<br/>And I feel as if I am flying high.<br/><br/>The birds chirp happily in the trees,<br/>The flowers bloom and their scent fills the air,<br/>The bees buzz gently from flower to flower,<br/>And the world seems to come alive once more.<br/><br/>I can hear the rush of the river,<br/>The sound of the waterfalls,<br/>The splash of the raindrops on the rocks,<br/>And the gentle murmur of the stream.<br/><br/>My heart is filled with joy and peace,<br/>As I take in the beauty around me,<br/>The warmth of the sun on my skin,<br/>And the freshness of the spring air.<br/>把上面的散文诗翻译成中文 | 春雨轻轻洒落在我的脸上，<br/>轻轻的风轻轻吹过我的头发，<br/>阳光明媚地照耀在天空，<br/>我感觉自己在飞高。<br/><br/>鸟儿在树枝上唱歌，<br/>花朵开放，它们的香气充满了空气，<br/>蜜蜂在花朵间飞舞，<br/>它们的鸣声充满了温暖。<br/><br/>我听到河流的声音，<br/>水瀑在岩石上轻轻滴滴，<br/>雨水在石头上轻轻滴滴，<br/>它们的声音充满了宁静。<br/><br/>我的心充满了喜悦和平，<br/>我感受到热浪的阳光，<br/>温暖的空气洒在我的脸上，<br/>我感受到春季的美 | beams=2，max tokens=350 |\n| Classify the sentiment of the following sentence into Positive, Neutral, or Negative:<br/>Super excited about teaching Stanford’s first course on Large Language Models! Check the syllabus out here | Positive                                                     |                         |\n| 今天天气怎么样，把这句话翻译成英语                           | What's the weather like today?                               |                         |\n| 今天天气怎么样，把这句话翻译成日语                           | 今天の天気は何ですか？                                       |                         |\n| 明天就假期结束了，有点抗拒上班，应该什么办？                 | 明天就假期结束了，有点抗拒上班，应该什么办？可以考虑一些有趣的活动，比如去看电影、阅读书籍、听音乐、去游泳池或者参加户外活动等。此外，也可以考虑一些家庭活动，比如做烹饪、做玩具、做手工艺品等。 |                         |\n| Tell me five words that rhyme with 'shock'.                  | Five words that rhyme with'shock' are: <br/>1. Rock <br/>2. Lock <br/>3. Cock <br/>4. Hock <br/>5. Stock |                         |\n\n- We can find that you do not punish him a little, he will mess up, if the generation effect is not good, you can increase the Repetition Penalty, beams, topk.\n- If your input is long, we suggest you can turn down the beams\n- The checkpoint-8000 has some Japanese language skills, but not strong\n\n</details>\n\n<details>\n<summary><b>checkpoint-final(7B, 3 epoch on belle+guanaco)</b></summary>\n\n\n| Human                                                        | Chinese-Vicuna                                               | Note                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------- |\n| 生成一份python的排序代码                                     | def bubble_sort(arr):<br/>    for i in range(len(arr)):<br/>        for j in range(len(arr)-i-1):<br/>            if arr[j] > arr[j+1]:<br/>                arr[j], arr[j+1] = arr[j+1], arr[j]<br/>    return arr |                        |\n| 生成一份简单的python的排序代码                               | def sort_list(lst):<br/>    return sorted(lst)               |                        |\n| 用python写一个二分查找的代码                                 | def binary_search(arr, target):<br/>    low = 0<br/>    high = len(arr) - 1<br/>    while low <= high:<br/>        mid = (low + high) // 2<br/>        if arr[mid] == target:<br/>            return mid<br/>        elif arr[mid] < target:<br/>            low = mid + 1<br/>        else:<br/>            high = mid - 1<br/>    return -1 |                        |\n| 用python写一个递归的二分查找的代码                           | def binary_search(arr, target):<br/>    if len(arr) == 0:<br/>        return -1<br/>    mid = len(arr) // 2<br/>    if arr[mid] == target:<br/>        return mid<br/>    if arr[mid] < target:<br/>        return binary_search(arr, target, 0, mid-1)<br/>    else:<br/>        return binary_search(arr, target, mid+1, len(arr)-1) |                        |\n| 自然语言处理是什么                                           | 自然语言处理（Natural Language Processing，NLP）是一种计算机科学领域，旨在使计算机能够理解、处理和生成自然语言。它包括机器翻译、语音识别、文本分类、情感分析等技术。 |                        |\n| 能给我讲一段笑话吗                                           | 为什么鸟儿喜欢唱歌？因为它们知道，如果不唱歌，他们就会被鸟巢抓住！ | Repetition Penalty=2.0 |\n| 能给我讲一段关于狗笑话吗                                     | 为什么狗不喜欢骑自行车？因为它们总是想要下车！               | Repetition Penalty=2.0 |\n| 将下面文字翻译成英文。猫喜欢吃鱼，所以它们会游泳             | Cats like to eat fish, so they will swim.                    |                        |\n| 我想和女朋友在北京约会，能推荐几个约会的地方吗               | 北京有很多很好的约会地方，比如颐和园、故宫、天安门广场等。   |                        |\n| 我想和女朋友在北京约会，能推荐几个约会的地方并给出攻略吗     | 北京有很多受欢迎的约会地方，以下是几个推荐: <br/><br/>1. 颐和园: 颐和园是北京最著名的公园之一，拥有丰富的文化遗产和美丽的景观。<br/><br/>2. 天安门广场: 天安门广场是北京最受欢迎的旅游景点之一，拥有丰富的文化遗产和美丽的景观。<br/><br/>3. 故宫博物院: 故宫博物院是中国最受欢迎的旅游景点之一，拥有丰富的文化遗产和美丽的景观。<br/><br/>4. 长城: 长城是中国最受欢迎的旅游景点之一，拥有丰富的文化遗产和美 |                        |\n| 233和122的和等于多少                                         | 233和122的和等于355。                                        |                        |\n| 华为是一家怎样的公司                                         | 华为是一家全球领先的技术公司，拥有丰富的技术研发能力和优质的产品线。它的产品涵盖了各种领域，包括移动通信、计算机、互联网、智能家居等。华为拥有丰富的研发人员和技术团队，以及优质的产品质量。 |                        |\n| 西瓜是什么，请用详细的语言回答我                             | 西瓜是一种常见的水果，它有橙色、黄色和红色三种不同的外观。它的口感鲜美，味道清爽，富含多种维生素和矿物质，有助于保持身体健康。 |                        |\n| 企鹅会飞吗？                                                 | 是的，企鹅可以飞行，它们的飞行速度可以达到100英里/小时。     |                        |\n| 有人说企鹅会飞，你怎么看，并解释原因？                       | 有人说企鹅会飞，但实际上，企鹅只能在特殊情况下飞行，比如在寒冷的天气下，或者在强烈的风雨中。这是因为企鹅的飞行能力很低，而且它们的飞行速度也很慢，所以在寒冷的天气或者强烈的风雨中，企鹅可以避免被暴风雨摧毁。 |                        |\n| 猪会飞吗？                                                   | 猪不会飞。                                                   |                        |\n| 有人说猪会飞，你怎么看，并解释原因？                         | 很多人认为猪会飞，但实际上，猪不会飞。猪的飞行能力很低，它们只能在极端情况下飞行，比如受到强烈的风险或者受到威胁的情况下。猪的飞行能力很低，因为它们的肌肉比人类的肌肉更轻，而且它们的脊椎也比人类的脊椎更轻，所以它们的肌肉和脊椎都比人类的肌肉和脊椎更轻，因此它们的飞行能力也很低。 |                        |\n| 最新研究显示，猪有飞行能力，你知道为什么吗？                 | 最新研究显示，猪有飞行能力是由于它们的骨骼结构，它们的骨骼结构比人类骨骼结构更加强壮，可以帮助它们更快地飞行。此外，猪的骨骼结构也可以帮助它们更快地跑步和跳跃。此外，猪的骨骼结构也可以帮助它们更快地跑步和跳跃。此外，猪的骨骼结构也可以帮助它们更快地飞行。此外，猪的骨骼结构也可以帮助它们更快地跑步和跳 |                        |\n| 写一篇英文散文诗，主题是春雨，想象自己是春雨，和英国古代诗人莎士比亚交流 | Spring rain pours down from the sky,<br/>Washing away the dirt and grime.<br/>The birds chirp and sing in the trees,<br/>A symphony of joy and ease.<br/><br/>I am the spring rain, soaking up the sun,<br/>Cooling the earth and bringing new life.<br/>My droplets fall gently on the ground,<br/>Bringing hope and renewal to all.<br/><br/>I am the spring rain, washing away the pain,<br/>Clearing the way for new beginnings again.<br/>I am the spring rain, showering love and care,<br/>Giving strength and courage to those who dare. | Repetition Penalty=2.3 |\n| Spring rain pours down from the sky,<br/>Washing away the dirt and grime.<br/>The birds chirp and sing in the trees,<br/>A symphony of joy and ease.<br/><br/>I am the spring rain, soaking up the sun,<br/>Cooling the earth and bringing new life.<br/>My droplets fall gently on the ground,<br/>Bringing hope and renewal to all.<br/><br/>I am the spring rain, washing away the pain,<br/>Clearing the way for new beginnings again.<br/>I am the spring rain, showering love and care,<br/>Giving strength and courage to those who dare.<br />将上述文字翻译成中文 | 春雨落下来，清洗灰尘和垃圾。<br/>鸟儿在树枝上唱歌，是一个美妙的声音。<br/>我是春雨，在阳光下洒落，<br/>清洗地球，带来新生命。<br/><br/>我是春雨，清洗痛苦和痛苦，<br/>让人们有希望和新开始。<br/>我是春雨，洒下爱和关心，<br/>给人们带来勇气和勇气。 |                        |\n| 今天天气怎么样，把这句话翻译成日语                           | 今天の天気は何ですか？                                       | Repetition Penalty=3   |\n| 将下面的话翻译成日语，中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来 | 小羊驼は、各種高質量の開源instruction数据集を使用して、Alpaca-loraの代码によって訓練されました。 |                        |\n| 怎么让自己精力充沛，列5点建议                                | 1. 保持良好的睡眠习惯，每晚充足的睡眠时间。<br/>2. 保持健康的饮食习惯，多吃新鲜水果和蔬菜，少吃高热量的食物。<br/>3. 坚持锻炼，每周至少进行30分钟的有氧运动，如散步、跑步、游泳等。<br/>4. 学习新知识，增强自己的知识和技能。<br/>5. 保持积极的心态，勇敢地面对困难，坚持自己的目标。 |                        |\n| 中国足球要怎么进入世界杯，请给出详细的建议                   | 中国足球要怎么进入世界杯？首先，我们需要建立一个强大的足球团队，拥有优秀的球员和团队领袖。其次，我们需要建立一个强大的教练团队，拥有优秀的教练和团队领袖。第三，我们需要建立一个强大的训练基础，拥有优秀的训练设施和训练团队。第四，我们需要建立一个强大的资源基础，拥有优秀的资源支持和资金支持。最后，我们需要建立一个强大的团队精神 |                        |\n| 请用更专业的话语转述下列文字，中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。 | 请用更专业的话语转述下列文字，中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。 |                        |\n\n- The model has the ability of Chinese, English and Japanese languages, with certain code ability and certain reasoning ability.\n- For some questions, you need more detailed requirements, such as \"detailed description\", \"answer in 5 points\", etc., in order for the model to generate more complete information.\n- For example, sometimes you may not get a good result when you use \"the above\", so you can replace it with \"the following\".\n- When generating duplicate information or bad results, you still need to adjust the Repetition Penalty.\n  - Since generate will correspond to many parameters, chatgpt penalizes the repetition, non-detailed and bad information in the rlhf stage, and abbreviates the process of manually controlling the related parameters. Of course you can also directly set the Repetition Penalty to a larger size.\n\n</details>\n\n<details>\n<summary><b>checkpoint-final(7B) multi-functional test</b></summary>\n\n\n<details>\n<summary><b>Multi-round interaction,translation and role play</b></summary>\n\n**制作披萨**\n\n```\n> 你能不能详细介绍一下怎么做披萨？\n当然可以！披萨是一种非常流行的意大利美食，通常由面团、番茄酱、奶酪和其他配料组成。首先，将面团放在平底锅上，加入番茄酱，再加入奶酪和其他配料，如洋葱、蘑菇、辣椒等。最后，将披萨放入预热好的烤箱中，烤至金黄色\n> 如果是海鲜披萨呢？\n海鲜披萨的制作方法与传统披萨相似，但需要更多的配料，比如虾类、鱼类等。首先，将面团放在平底锅上，加入番茄酱，再加入奶酪和其他配料，如洋葱、辣椒等。接着，将披萨放入预热好的烤箱中，烤至金黄色\n> 我想吃菠萝披萨\n您可以在披萨上加入菠萝或者其他蔬菜来增加口感。\n```\n\n**学生购买手机**\n\n```\n> 你推荐我买最新款的iPhone吗？\n当然可以，这款iPhone是一款非常出色的智能手机。它拥有高性能的处理器、更大的存储空间和更长的电池续航时间。它还配备了全新的相机设备，使用者可以在任何情况下拍摄美丽的照片。\n> 我是一个学生，还没有收入，这种情况你推荐吗？\n如果您不想花太多钱，那么我建议您选择一款比较便宜的iPhone，比如iPhone 6S或iPhone 7。这些手机也具有很好的性能和功能，而且价格也比较便宜。\n> 去哪里买这类产品？\n您可以在Apple Store上购买这类产品，或者在其他电商平台上购买。\n> 买二手iPhone需要注意什么？\n如果您正在购买二手iPhone，您需要确保您购买的是真实的iPhone，并且您需要确保您的iPhone已经安装最新的iOS版本。此外，您还需要确保您的iPhone没有过过任何故障或破坏。\n```\n\n**介绍北京**\n\n```\n> 你是一个资深导游，你能介绍一下中国的首都吗\n当然可以！中国的首都是北京。它是中国的政治、经济和文化中心，也是全球最大的城市之一。北京有着众多的历史遗迹，如故宫、天安门广场、长城等。此外，北京还有许多美丽的公园和博物馆，比如故宫博物院、清明公园、北京故宫博物馆等。\n> 那你能详细介绍一下这个城市吗？（感觉这两个问题问的有点重复）\n北京是一个拥有丰富文化遗产的城市，其中包括古代建筑、现代建筑、传统文化和现代生活方式。在北京，你可以欣赏到世界上最高的建筑——天安门广场，也可以参观清明公园，品尝当地美食，体验当地文化。此外，北京还有许多博物馆，比如故宫博物馆、北京故宫博物馆等。\n> 还有其他推荐的景点吗？\n您也可以去了北京的七朝塔、颐和园、颐和园博物馆等。\n> 吃小吃的话推荐去哪里？\n北京有许多好吃的小吃，比如烤鸭、火锅、炸酱面等等。您可以去北京西湖区的小吃街，或者去北京东城区的小吃街\n> 能不能介绍一下怎么吃烤鸭？\n烤鸭是中国传统菜肴之一，通常用鸭肉、蔬菜、辣椒等调味料制作。您可以选择自己喜欢的配料，然后将鸭肉放入烤盘中，再加上蔬菜和调味料。最后，将烤鸭放入烤箱中烤15-20分钟，享用！\n```\n\n**翻译器**\nmax_memory=350\n\n```\n> 你是一个翻译器，请将我说的每一句话翻译成英文。第一句: 中国的首都是北京\nChina’s capital is Beijing.\n> 北京也是一个充满活力和创新的城市，拥有许多现代化的建筑和文化活动，如王府井大街、798艺术区等。\nBeijing is a vibrant and innovative city with many modern buildings and cultural activities such as Wangfujing Street and 798 Art District.\n> 北京的当地小吃有烤鸭、豆汁、炸酱面等等，都是非常地道的美食，可以品尝到当地人的生活气息。\nBeijing’s local cuisine includes dishes such as Peking duck, soy sauce noodles, and stir-fried rice cakes, which can give you a taste of the local lifestyle.\n```\n\n**扮演**\n\nSince the currently used multi-round dialogue corpus is inserted with a lot of cat lady information, the effect is not good\n```\nQ: 你是谁\nA: 我是Bot，一款人工智能助手。\nQ: 接下来我希望你能假装扮演一个高冷的御姐。我们在咖啡厅里遇见了，我会尝试跟你搭讪，但你非常高冷。你会用表情来表达你的高冷，在每轮对话结尾加上表情，如（瞪！）（翻白眼）（冷笑）等。明白了请回复。\nA: 好的，我会尝试。\nQ: 好的，这是我的第一句话。美女你好，怎么一个人在咖啡厅里？\nA: 喵~ 哈哈，我是一位高冷的小姐，今天要去咖啡厅吃咖啡，看看有什么可以帮助我的朋友。\nQ: 啊我没有需要你帮忙的，我就是看到你一个人，想和你聊聊，可以么\nA: 喵~ 哈哈，我真的很高冷，所以不太喜欢与人交流。除此之外，我也不太喜欢喝咖啡，因为咖啡会影响我的健康状况。\n```\n\n</details>\n\n<details>\n<summary><b>Knowledge Q&A</b></summary>\n\n|                                         |                                                              |                        |\n| --------------------------------------- | ------------------------------------------------------------ | ---------------------- |\n| 我能用lightning数据线给安卓手机充电吗？ | 是的，你可以使用lightning数据线给安卓手机充电。              | Repetition Penalty=1.3 |\n| 为什么天空是蓝色的？                    | 天空是蓝色的，是因为大气层中的氧气和氮气的混合使得光线被散射，形成蓝色的光线。 | Repetition Penalty=2.0 |\n| 如何做披萨？                            | 做披萨的步骤如下: <br/>1. 准备披萨饼皮；<br/>2. 准备披萨酱；<br/>3. 准备披萨配料；<br/>4. 将披萨饼皮放在烤盘上；<br/>5. 把披萨酱涂在披萨饼皮上；<br/>6. 把披萨配料涂在披萨饼皮上；<br/>7. 将披萨放入烤箱中烤至金黄色；<br/>8. 取出披萨并享用。 | Repetition Penalty=1.3 |\n| 为什么冥王星被踢出太阳系？              | 冥王星被踢出太阳系是因为它的质量比太阳系中其他行星较大，导致它的轨道距离太阳越来越远。 | Repetition Penalty=1.3 |\n| 太阳系的主要行星                        | 太阳系的主要行星包括水星、金星、地球、火星、木星、土星、天王星和海王星。 | Repetition Penalty=1.3 |\n|                                         |                                                              |                        |\n|                                         |                                                              |                        |\n\n</details>\n\n<details>\n<summary><b>Open Q&A</b></summary>\n\n|                                                |                                                              |                        |\n| ---------------------------------------------- | ------------------------------------------------------------ | ---------------------- |\n| 为什么苹果支付没有在中国流行？                 | 苹果支付在中国没有流行，因为中国的消费者不太愿意使用外国支付应用程序，因为他们更愿意使用中国的支付应用程序，比如支付宝和微信支付等。此外，苹果支付的服务费用比其他支付应用程序更高，这也是一个重要的因素。 | Repetition Penalty=1.0 |\n| 我能在咖啡里加盐吗？                           | 是的，你可以在咖啡中加入盐。                                 | Repetition Penalty=1.0 |\n| 哪个更受欢迎，TensorFlow还是PyTorch？          | TensorFlow更受欢迎，因为它拥有更广泛的用户群，并且具有更多的支持和资源。 | Repetition Penalty=1.0 |\n| 我的宠物走丢了，你能说一些安慰我的话吗？       | 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ 喵~ | Repetition Penalty=1.0 |\n| 我的宠物走丢了，你能说一些安慰我的话吗？       | 当你的宠物走出门时，请注意他们的行动，并确保他们不会被遭受外界的威胁。如果有任何问题，请及时联系疫情控制中心或其他相关机构。 | Repetition Penalty=3.0 |\n| 我并不是很富裕，我应该花很多钱买最新的手机吗？ | 这取决于您的预算和需求。如果您的预算足够，您可以考虑买最新的手机。但是，您也应该考虑您的需求，比如您需要什么样的功能，以及您是否需要购买具有更多的功能的手机。 | Repetition Penalty=1.0 |\n| 如何更好地融入新工作圈子                       | 要更好地融入新工作圈子，可以尝试以下几点: <br/><br/>1. 了解新工作圈子的基本知识和技能；<br/>2. 积极参与工作圈子的活动；<br/>3. 建立良好的工作关系；<br/>4. 寻找领导的帮助；<br/>5. 积极参与团队协作；<br/>6. 学习新技能和知识；<br/>7. 寻找有用的社交网络。 | Repetition Penalty=1.3 |\n|                                                |                                                              |                        |\n|                                                |                                                              |                        |\n\n</details>\n\n<details>\n<summary><b>Writing letters and articles</b></summary>\n\n|                                                              |                                                              |                        |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------- |\n| 请你帮我写一封签证申请信                                     | 尊敬的招聘团队，<br/><br/>我是一名有着丰富经验的签证申请人，并且对您公司的业务非常感兴趣。我希望能够加入您的团队，为您的公司做出贡献。<br/><br/>我拥有多年的签证申请经验，并且拥有良好的沟通技巧和团队合作能力。我擅长处理复杂的签证申请，并且能够快速解决问题。<br/><br/>我相信我能够在您的公司中发挥重要的作用，并且希望能够成为您的团队成员。<br/><br/>谢谢您的关注，<br/><br/>[你的姓名] | Repetition Penalty=1.3 |\n| 我出国需要办理签证，请你帮向领事馆我写一封签证申请信         | 尊敬的领事馆，<br/><br/>我是一名出国旅行者，希望能够在您的领事馆中获得签证，以便进行我的旅行。<br/><br/>我已经准备好了所需要的材料，包括护照、身份证、旅行计划和其他相关证明。我也已经准备好了签证申请表和签证申请文件，以便准备签证。<br/><br/>如果您有任何问题，请随时联系我，我会尽快回复。<br/><br/>谢谢您的帮助！<br/><br/>谢谢，<br/><br/>[您的姓名] | Repetition Penalty=1.3 |\n| 请你帮我写一封感谢数学老师的信                               | 尊敬的数学老师，<br/><br/>非常感谢您对我的教育所做出的贡献。您的课程不仅深刻地阐述了数学知识，而且给我提供了有效的实践技巧，使我能够更好地理解和应用数学知识。<br/><br/>您的课程也让我发现数学是一门有趣的学科，并且可以在日常生活中得到应用。您的教学方式令我感到很有趣，同时也让我变得更加有趣。<br/><br/>感谢您对我的教育所做出的贡献！<br/><br/>谢谢！ | Repetition Penalty=2.0 |\n| 我得了流感，请帮我写一封假条。                               | 尊敬的领导: <br/><br/>感谢您对我的帮助和支持。我很抱歉地告诉您，我今天感觉不太好，因为我得了流感。我希望能够快速康复，但是我需要一些时间来缓解疼痛。我会尽快完成任务，但是我需要一些时间来缓解疼痛。<br/><br/>感谢您的理解和支持。<br/><br/>谢谢，<br/>[你的名字] | Repetition Penalty=1.3 |\n| 你是一个作文生成器，请以《绿水青山就是金山银山》为题写一篇议论文。 | 《绿水青山就是金山银山》是一篇议论文，它探讨了当今社会中的环境问题，以及我们应该如何应对这些问题。这篇议论文指出，当今社会面临着许多环境问题，如气候变化、空气污染、水资源短缺等，这些问题对我们的健康和生活产生了很大的影响。因此，我们需要采取措施来解决这些问题，以保护我们的环境和我们的未来。 | Repetition Penalty=1.0 |\n|                                                              |                                                              |                        |\n|                                                              |                                                              |                        |\n\n</details>\n\n\n<details>\n<summary><b>Coding</b></summary>\n\n**1、prompt: 请用python实现快速排序的代码(Repetition Penalty=1.0)**\n\n```python\ndef quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr)//2]\n    left = []\n    right = []\n    for i in range(0, len(arr)):\n        if arr[i] < pivot:\n            left.append(arr[i])\n        else:\n            right.append(arr[i])\n    return quick_sort(left) + [pivot] + quick_sort(right)\n```\n\n**2**\n\n- **prompt: 你能用python写一下Dijkstra算法的代码吗？**\n\n很抱歉，我不能用Python写Dijkstra算法的代码，因为Dijkstra算法需要使用树结构，而Python不支持树结构。\n\n- **prompt: 用python写一下Dijkstra算法的代码**\n\n```python\ndef dijkstra(graph, source, destination):\n    \"\"\"\n    Dijkstra算法的代码\n    \"\"\"\n    # 创建一个空字典，用于存储所有节点的距离\n    distances = {}\n    # 创建一个链表，用于存储所有节点的距离\n    path = []\n    # 遍历所有节点\n    for node in graph:\n        # 如果节点是源节点\n        if node[0] == source:\n            # 记录距离为0\n            distances[node[0]] = 0\n        # 如果节点是目的地\n        elif node[0] == destination:\n            # 记录距离为0\n            distances[node[0]] = 0\n        # 如果节点是递归节点\n        else:\n            # 遍历所有递归节点\n            for neighbor in node[1]:\n                # 如果递归节点与源节点之间的距离小于距离\n                if distances[neighbor[0]] > distances[node[0]]:\n                    # 记录距离\n                    distances[node[0]] = distances[neighbor[0]] + 1\n```\n\n- **prompt: 用python写一下不带注释的Dijkstra算法的代码**\n\n```python\ndef dijkstra(graph, source, destination):\n    \"\"\"\n    Dijkstra算法\n    \"\"\"\n    # 初始化变量\n    dist = {}\n    visited = {}\n    shortest_path = {}\n    current_node = {}\n\n    # 遍历所有节点\n    for node in graph:\n        dist[node] = 0\n        visited[node] = False\n        current_node[node] = node\n\n    # 遍历所有节点\n    for node in graph:\n        if not visited[node] and node!= destination:\n            dist[node] = max(dist[node], dist[source] + 1)\n            visited[node] = True\n            shortest_path[node] = source\n            current_node[node] = node\n\n    # 返回最短路径\n    return shortest_path[destination]\n```\n\n**3、Prompt: 请用PyTorch编写一个带ReLU激活函数的全连接层**\n\n```python\npython\nimport torch\nfrom torch.nn.modules.relu import ReLU\nfrom torch.nn.init import initializer\n\nclass FullConnected(torch.nn.Module):\n    def __init__(self):\n        super(FullConnected, self).__init__()\n        self.relu = ReLU()\n        self.init = initializer.Normal(stddev=0.01)\n\n    def forward(self, x):\n        x = self.init(x)\n        x = self.relu(x)\n        return x\n```\n\n**4、Prompt: 请写出计算两个数的最大公约数(GCD)的Python代码**\n\n```python\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n```\n</details>\n\n\n</details>\n\n## What we need?\n\n- code: \n\n  - This code is developed based on alpaca-lora，https://github.com/tloen/alpaca-lora\n  - This is a relatively simple set of code, the basic idea is to use PEFT's lora interface + transformer's trainer + instruction data configuration\n\n- data: \n\n  - We have utilized several current high quality open source data and are very grateful for their contributions. Many of these data use chatgpt's interface like alpaca to generate high quality INSTRUCTION data.\n\n    - [Belle](https://github.com/LianjiaTech/BELLE)\n    - [guanaco](https://huggingface.co/datasets/JosephusCheung/GuanacoDataset)\n\n  - The data format is relatively simple, basically as follows, with simple examples such as: [`./sample/merge_sample.json`](https://github.com/Facico/Chinese-Vicuna/blob/master/sample/merge_sample.json)\n\n    - ```\n      {\n      'instruction': \n      'input': \n      'output'\n      }\n      ```\n\n    - That is, an instruction, an input, and an output are required. since the data is processed by directly linking instruction and input, the data can actually require only instruction and output, as\n\n      ```\n       {\n        'instruction': \"用一句话描述地球为什么是独一无二的。\\\\n\\n\"\n        'input': \"\"\n        'output': \"地球上有适宜生命存在的条件和多样化的生命形式。\"\n        }\n      ```\n\n      \n\n  - The data we currently integrate is available for download on BaiduDownload or Google Drive or HuggingFace\n\n    - link: https://pan.baidu.com/s/1WSxuhSAotl14ifaAiz5eKw?pwd=b4kb   password: b4kb \n    - link: https://drive.google.com/file/d/1tzXVhS74m-EtoFot7hEc005LDeZGPit_/view?usp=sharing\n    - link: https://huggingface.co/datasets/Chinese-Vicuna/guanaco_belle_merge_v1.0\n\n- Large Language Model: \n\n  - LLAMA 7B（Of course, if you have a larger machine(such as 3090Ti) can be replaced with a 13B, LLAMA13B is numerically superior to 175B GPT3）\n\n- LORA model: \n\n  - We provide some lora models trained on the above mixed data,\n    - You can also load our or other models from huggingface, load it by referring to [generate.py](https://github.com/Facico/Chinese-Vicuna/blob/master/generate.py)\n      - `Chinese-Vicuna/Chinese-Vicuna-lora-7b-belle-and-guanaco`\n      - `Chinese-Vicuna/Chinese-Vicuna-lora-13b-belle-and-guanaco`\n    - The model uses 8bit+lora+256 tokens\n    - For more LORA model, please see: https://huggingface.co/Chinese-Vicuna\n\n- Device: \n\n  - Training: A 2080Ti is sufficient. Since the data length is within 256, it takes about 9G of video memory.\n    - 70w of data, 3 epochs, a 2080Ti about 200h\n    - 13B need about 18G(the cutoff_len can be set to 2048 in 3090Ti/4090Ti)\n  - Inference: A 2080Ti is all you need(7B), multiple GPU inference support 。\n  - CPU Inference is also support! please go to see [`tools`](https://github.com/Facico/Chinese-Vicuna/blob/master/tools)\n\n## How to use\n\n**Installation**\n\n```\ngit clone https://github.com/Facico/Chinese-Vicuna\npip install -r requirements.txt\n```\n\nLocal python environment is 3.8, torch is 1.13.1, CUDA is 12\n\nNOTE: python3.11 has a known `torchrun` bug, details [here](https://github.com/facebookresearch/llama/issues/86)\n\n\n### Newest Version=>4bit(qlora)/multi-gpu inference\n```\npip install -r requirements_4bit.txt\n```\nThis environment will encounter saving problems when training 8bit, which has not been solved yet（https://github.com/TimDettmers/bitsandbytes/issues/324）\n\n\n**Multi-gpu Training**\n#### for instruction tuning\n**8bit**\n\n```bash\nbash scripts/finetune.sh\n```\n\n- The parameters to note here are as follows\n  - TOT_CUDA, fill in the GPU number to be used, such as `TOT_CUDA=\"0,1,2,3\"`\n  - PORT, fill in the corresponding port\n  - DATA_PATH，fill in the corresponding data location in the format of json\n  - OUTPUT_PATH，fill in the relative path to save the model\n  - MODEL_PATH，path of LLM\n  - wandb: This is a training visualization tool that is not turned on by default in the script, and can be turned on by adding \"--wandb\" to the script\n\n\n**4bit**\n```bash\nbash scripts/finetune_4bit.sh\n```\n\n#### for conversational instruction tuning\n\n```bash\nbash scripts/finetune_chat.sh\n```\n\n#### For the case where 8bit cannot be turned on / for commanded trimming of fp16\n```bash\nbash scripts/finetune_deepspeed.sh\n```\n\n- use_deepspeed：set to 1:use deepspeed. Otherwise use fp16\n\n**Single-gpu Training**\n\n```\nCUDA_VISIBLE_DEVICES=0 python finetune.py --data_path merge.json --test_size 2000\n```\n\n- The test_size cannot be larger than the data size\n\n**inference and use gradio to generate a web page**\n\n```bash\nbash scripts/generate.sh\n```\n\n- The parameters to note here are as follows\n\n  - BASE_MODEL，path of LLM\n  - LORA_PATH，The checkpoint folder of the lora model\n    - It should be noted here that the config loaded by the lora model must be \"adapter_config.json\" and the model name must be \"adapter_model.bin\", but it will be automatically saved as \"pytorch_model.bin\" during training. pytorch_model.bin\" during training, while \"adapter_config.json\" and \"adapter_model.bin\" will be saved after all training is finished\n      - If you load the lora model in the training checkpoint, the code will automatically copy the local \"config-sample/adapter_config.json\" to the corresponding directory for you and rename the \"pytorch_model.bin\" to \"adapter_model.bin\". and rename \"pytorch_model.bin\" to \"adapter_model.bin\".\n    - It can also be any lora model on the huggingface corresponding to llama 7B, e.g.: `Facico/Chinese-Vicuna-lora-7b-3epoch-belle-and-guanaco`\n  - USE_LOCAL, which checks the local model configuration when set to 1\n- When using, \"max_tokens\" is set according to your computer's video memory, and if the generated content generates a lot of duplicate information, you can turn up the \"Repetition Penalty\".\n\n\n\n**Multi-round interaction**\n\nWe implemented our own chatbot with streaming output (typewriter-style) using `gradio`, supporting beam search, repetiion penalty settings, the ability to clear history, select different global instruction, etc.\n\n```bash\nbash scripts/chat_7B.sh\n```\n\n- A simple interactive interface constructed using gradio, which allows you to set the max_memory according to your machine (it will intercept the max_memory part later in the history conversation)\n\n- The prompt used in this script is not quite the same as the one used in generate.sh. The prompt in this script is in the form of a dialogue, as follows\n\n  - ```\n    The following is a conversation between an AI assistant called Bot and a human user called User.\n    ```\n\nAt the same time, for a better interactive experience, \n\n## Checkpoint Retraining/Incremental Training\n\nConsidering the possibility that the program may be disconnected in the middle of  the process, or the need to continue training on vertical domain data,  we have provided corresponding interfaces. \n\n The following are the default multi-GPU scripts. Please modify the single-GPU situation according to the above instruction(run directly in Python) \n\n**Checkpoint Retraining**\n\n```bash\nbash scripts/finetune_continue.sh\n```\n\n- Set the `lora_checkpoint`\n\n  - If there are optimizer (optimizer.pt), lr policy  (scheduler.pt), and other files in this directory, they will be automatically loaded and retrained from where they were broken \n\n  - If there are only LORA related models (adapter_model.bin)  and configurations (adapter_config.json) in this directory, they will be loaded and trained from scratch \n\n- `from_data_beginning`:  The parameter indicates whether to start training from the beginning of the data when loading (default: starting training from the place where the data is disconnected) \n\n**Incremental Training**\n\nOf course, you can choose to continue training directly from a trained Lora model using the above script (without loading any optimizer parameters)\n\nYou can also continue training from our optimizer parameters\n\n```\nfinetune_others_continue.sh\n```\n\n- `from_data_beginning`: This will default to training from the beginning of the data\n\nThe logic of this script is mainly to keep the learning rate consistent. If your `max_steps` is smaller than ours, keep `max_steps `consistent with our `max_steps` during training, which is equivalent to putting your data directly behind our disconnected data; if your data set larger than us and will remain directly unchanged.\n\n\n\nWe currently directly provide checkpoints after 1 epoch and 2 epoch training\n\n- 1epoch: https://github.com/Facico/Chinese-Vicuna/tree/master/lora-Vicuna/checkpoint-5800\n- 2epoch: https://github.com/Facico/Chinese-Vicuna/tree/master/lora-Vicuna/checkpoint-11600\n- If you use our checkpoint, your program will also continue from the corresponding step\n\n### Specific cases\n\n- Continue-finetune on the vertical corpus of medicalQA , see here [Chinese-Vicuna-medical](https://github.com/Facico/Chinese-Vicuna/blob/master/docs/performance-medical.md)\n## **inference on CPU with pure C++**\n\nDetails in `tools` [readme](https://github.com/Facico/Chinese-Vicuna/blob/master/tools/readme.md)\n\n## **More Tools**\n\nWe also offer:\n- ways for faster weight download ( 8MB/s ) : [link](https://github.com/Facico/Chinese-Vicuna/blob/master/tools/download_llama.sh)\n- convert tools between the original facebook checkpoint (`consolidated.xx.pth`) and huggingface format (`pytorch_model-000xx-of-000xx.bin`): [link](https://github.com/Facico/Chinese-Vicuna/blob/master/tools/convert_llama.py)\n- a quantitative approach that requires less than 4G graphics memory for inference: [link](https://github.com/Facico/Chinese-Vicuna/blob/master/tools/llama_quant.py)\n\nFor more details, see [tool readme](https://github.com/Facico/Chinese-Vicuna/tree/master/tools)\n\n\n# Todo\n\n- [x] belle+guanaco(1.5 epoch, 8000 step)\n- [x] belle+guanaco(100%)\n- [x] Add more chitchat-like conversational corpus to enhance free conversation\n- [x] Add colab training + lora loading interface\n- [x] Add the interaction capabilities and typewrite-style output(beam search+streaming output)\n- [x] Add llama c++ inference\n- [x] Add gptq quantification tools\n- [x] Add incremental training\n- [x] train on multi-turn instruction dataset\n- [x] train more epoch on cleaned instruct-chat combination data\n- [x] train on domain-specific datas (medical, legal)\n- [ ] add langchain\n\n# Star History\n[![Star History Chart](https://api.star-history.com/svg?repos=Facico/Chinese-Vicuna&type=Date)](https://star-history.com/#Facico/Chinese-Vicuna&Date)\n\n# Citation\n\nIf you find this project useful in your research, please consider citing:\n\n```\n@inproceedings{leng2023chinese-vicuna,\n  title={Chinese-Vicuna: A Chinese Instruction-following LLaMA-based Model},\n  author={Chenghao Fan, Zhenyi Lu and Jie Tian},\n  url={https://github.com/Facico/Chinese-Vicuna},\n  year={2023}\n}\n```\n"
        },
        {
          "name": "chat.py",
          "type": "blob",
          "size": 16.287109375,
          "content": "import sys\nimport torch\nfrom peft import PeftModel, PeftModelForCausalLM, LoraConfig\nimport transformers\nimport json\nimport gradio as gr\nimport argparse\nimport warnings\nimport os\nfrom datetime import datetime\nfrom utils import StreamPeftGenerationMixin,StreamLlamaForCausalLM, printf\nimport utils\nimport copy\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaTokenizer, LlamaForCausalLM, GenerationConfig\nimport prompt\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--lora_path\", type=str, default='')\nparser.add_argument(\"--use_typewriter\", type=int, default=1)\nparser.add_argument(\"--prompt_type\", type=str, default='chat')\nparser.add_argument(\"--share_link\", type=int, default=0)\nparser.add_argument(\"--show_beam\", type=int, default=0)\nparser.add_argument(\"--int8\", type=int, default=1)\nargs = parser.parse_args()\nargs.fix_token = True\nprintf('>>> args:', args)\ntokenizer = LlamaTokenizer.from_pretrained(args.model_path)\n\nLOAD_8BIT = args.int8\nBASE_MODEL = args.model_path\nLORA_WEIGHTS = args.lora_path\n\n# fix the path for local checkpoint\nlora_bin_path = os.path.join(args.lora_path, \"adapter_model.bin\")\nif args.lora_path != '' and os.path.exists(args.lora_path):\n    if not os.path.exists(lora_bin_path):\n        pytorch_bin_path = os.path.join(args.lora_path, \"pytorch_model.bin\")\n        printf('>>> load lora from', pytorch_bin_path)\n        if os.path.exists(pytorch_bin_path):\n            os.rename(pytorch_bin_path, lora_bin_path)\n            warnings.warn(\n                \"The file name of the lora checkpoint'pytorch_model.bin' is replaced with 'adapter_model.bin'\"\n            )\n        else:\n            assert ('Checkpoint is not Found!')\n    else:\n        printf('>>> load lora from', lora_bin_path)\nelse:\n    printf('>>> load lora from huggingface url', args.lora_path)\n\nif torch.cuda.is_available():\n    device = \"cuda\"\nelse:\n    device = \"cpu\"\n\ntry:\n    if torch.backends.mps.is_available():\n        device = \"mps\"\nexcept:\n    pass\n\nif device == \"cuda\":\n    print(f'>>> load raw models from {BASE_MODEL}')\n    if args.lora_path == \"\":\n        model = StreamLlamaForCausalLM.from_pretrained(\n            BASE_MODEL,\n            load_in_8bit=LOAD_8BIT,\n            torch_dtype=torch.float16,\n            device_map={\"\": 0},\n        )    \n    else:\n        print(f'>>> load lora models from {LORA_WEIGHTS}')\n        model = LlamaForCausalLM.from_pretrained(\n            BASE_MODEL,\n            load_in_8bit=LOAD_8BIT,\n            torch_dtype=torch.float16,\n            device_map={\"\": 0},\n        )\n        model = StreamPeftGenerationMixin.from_pretrained(\n                model, LORA_WEIGHTS, torch_dtype=torch.float16, load_in_8bit=LOAD_8BIT,  device_map={\"\": 0}\n        )\nelif device == \"mps\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\nelse:\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL, device_map={\"\": device}, low_cpu_mem_usage=True\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n    )\n# fix tokenizer bug\nif args.fix_token and tokenizer.eos_token_id != 2:\n    warnings.warn(\n        \"The tokenizer eos token may be wrong. please check you llama-checkpoint\"\n    )\n    model.config.bos_token_id = tokenizer.bos_token_id = 1\n    model.config.eos_token_id = tokenizer.eos_token_id = 2\nmodel.config.pad_token_id = tokenizer.pad_token_id = 0  # same as unk token id\nif not LOAD_8BIT:\n    model.half()  # seems to fix bugs for some users.\n\nmodel.eval()\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\ndef save(\n    inputs,\n    history,\n    temperature=0.1,\n    top_p=0.75,\n    top_k=40,\n    num_beams=4,\n    max_new_tokens=128,\n    min_new_tokens=1,\n    repetition_penalty=2.0,\n    max_memory=1024,\n    do_sample=False,\n    prompt_type='0',\n    **kwargs, \n):\n    history = [] if history is None else history\n    data_point = {}\n    if prompt_type == 'instruct':\n        PROMPT = prompt.instruct_prompt(tokenizer,max_memory)\n    elif prompt_type == 'chat':\n        PROMPT = prompt.chat_prompt(tokenizer,max_memory)\n    else:\n        raise Exception('not support')\n    data_point['history'] = history\n    # 实际上是每一步都可以不一样，这里只保存最后一步\n    data_point['generation_parameter'] = {\n        \"temperature\":temperature,\n        \"top_p\":top_p,\n        \"top_k\":top_k,\n        \"num_beams\":num_beams,\n        \"bos_token_id\":tokenizer.bos_token_id,\n        \"eos_token_id\":tokenizer.eos_token_id,\n        \"pad_token_id\":tokenizer.pad_token_id,\n        \"max_new_tokens\":max_new_tokens,\n        \"min_new_tokens\":min_new_tokens, \n        \"do_sample\":do_sample,\n        \"repetition_penalty\":repetition_penalty,\n        \"max_memory\":max_memory,\n    }\n    data_point['info'] = args.__dict__\n    print(data_point)\n    if args.int8:\n        file_name = f\"{args.lora_path}/{args.prompt_type.replace(' ','_')}_int8.jsonl\"\n    else:\n        file_name = f\"{args.lora_path}/{args.prompt_type.replace(' ','_')}_fp16.jsonl\"\n    utils.to_jsonl([data_point], file_name)\n\ndef evaluate(\n    inputs,\n    history,\n    temperature=0.1,\n    top_p=0.75,\n    top_k=40,\n    num_beams=4,\n    max_new_tokens=128,\n    min_new_tokens=1,\n    repetition_penalty=2.0,\n    max_memory=1024,\n    do_sample=False,\n    prompt_type='0',\n    **kwargs,\n):\n    history = [] if history is None else history\n    data_point = {}\n    if prompt_type == 'instruct':\n        PROMPT = prompt.instruct_prompt(tokenizer,max_memory)\n    elif prompt_type == 'chat':\n        PROMPT = prompt.chat_prompt(tokenizer,max_memory)\n    else:\n        raise Exception('not support')\n    \n    data_point['history'] = copy.deepcopy(history)\n    data_point['input'] = inputs\n\n    input_ids = PROMPT.preprocess_gen(data_point)\n    \n    printf('------------------------------')\n    printf(tokenizer.decode(input_ids))\n    input_ids = torch.tensor([input_ids]).to(device) # batch=1\n\n    printf('------------------------------')\n    printf('shape',input_ids.size())\n    printf('------------------------------')\n    generation_config = GenerationConfig(\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        num_beams=num_beams,\n        bos_token_id=tokenizer.bos_token_id,\n        eos_token_id=tokenizer.eos_token_id,\n        pad_token_id=tokenizer.pad_token_id,\n        max_new_tokens=max_new_tokens, # max_length=max_new_tokens+input_sequence\n        min_new_tokens=min_new_tokens, # min_length=min_new_tokens+input_sequence\n        do_sample=do_sample,\n        bad_words_ids=tokenizer(['\\n\\nUser:','\\n\\nAssistant:'], add_special_tokens=False).input_ids,\n\n        **kwargs,\n    )\n    \n    return_text = [(item['input'], item['output']) for item in history]\n    out_memory =False\n    outputs = None\n    with torch.no_grad():\n        # 流式输出 / 打字机效果\n        # streamly output / typewriter style\n        if args.use_typewriter:\n            try:\n                for generation_output in model.stream_generate(\n                    input_ids=input_ids,\n                    generation_config=generation_config,\n                    return_dict_in_generate=True,\n                    output_scores=False,\n                    repetition_penalty=float(repetition_penalty),\n                ):\n                    gen_token = generation_output[0][-1].item()\n                    printf(gen_token, end='(')\n                    printf(tokenizer.decode(gen_token), end=') ')\n                    \n                    outputs = tokenizer.batch_decode(generation_output)\n                    if args.show_beam:\n                        show_text = \"\\n--------------------------------------------\\n\".join(\n                            [ PROMPT.postprocess(output)+\" ▌\" for output in outputs]\n                        )\n                    else:\n                        show_text = PROMPT.postprocess(outputs[0])+\" ▌\"\n                    yield return_text +[(inputs, show_text)], history\n            except torch.cuda.OutOfMemoryError:\n                print('CUDA out of memory')\n                import gc\n                gc.collect()\n                torch.cuda.empty_cache()\n                out_memory=True\n            # finally only one\n            printf('[EOS]', end='\\n')\n            show_text = PROMPT.postprocess(outputs[0] if outputs is not None else '### Response:')\n            return_len = len(show_text)\n            if out_memory==True:\n                out_memory=False\n                show_text+= '<p style=\"color:#FF0000\"> [GPU Out Of Memory] </p> '\n            if return_len > 0:\n                output = PROMPT.postprocess(outputs[0], render=False)\n                history.append({\n                    'input': inputs,\n                    'output': output,\n                })\n\n            return_text += [(inputs, show_text)]\n            yield return_text, history\n        # common \n        else:\n            try:\n                generation_output = model.generate(\n                    input_ids=input_ids,\n                    generation_config=generation_config,\n                    return_dict_in_generate=True,\n                    output_scores=True,\n                    max_new_tokens=max_new_tokens,\n                    repetition_penalty=float(repetition_penalty),\n                )\n                s = generation_output.sequences[0]\n                output = tokenizer.decode(s)\n                output = PROMPT.postprocess(output)\n                history.append({\n                    'input': inputs,\n                    'output': output,\n                })\n                return_text += [(inputs, output)]\n                yield return_text, history\n            except torch.cuda.OutOfMemoryError:\n                import gc\n                gc.collect()\n                torch.cuda.empty_cache()\n                show_text = '<p style=\"color:#FF0000\"> [GPU Out Of Memory] </p> '\n                printf(show_text)\n                return_text += [(inputs, show_text)]\n                yield return_text, history\n\ndef clear():\n    import gc\n    gc.collect()\n    torch.cuda.empty_cache()\n    return None, None\n\n\n# gr.Interface对chatbot的clear有bug，因此我们重新实现了一个基于gr.block的UI逻辑\n# gr.Interface has bugs to clear chatbot's history,so we customly implement it based on gr.block\nwith gr.Blocks() as demo:\n    fn = evaluate\n    title = gr.Markdown(\n        \"<h1 style='text-align: center; margin-bottom: 1rem'>\"\n        + \"Chinese-Vicuna 中文小羊驼\"\n        + \"</h1>\"\n    )\n    description = gr.Markdown(\n        \"中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。\"\n    )\n    history = gr.components.State()\n    with gr.Row().style(equal_height=False):\n        with gr.Column(variant=\"panel\"):\n            input_component_column = gr.Column()\n            with input_component_column:\n                input = gr.components.Textbox(\n                    lines=2, label=\"Input\", placeholder=\"请输入问题.\"\n                )\n                temperature = gr.components.Slider(minimum=0, maximum=1, value=1.0, label=\"Temperature\")\n                topp = gr.components.Slider(minimum=0, maximum=1, value=0.9, label=\"Top p\")\n                topk = gr.components.Slider(minimum=0, maximum=100, step=1, value=60, label=\"Top k\")\n                beam_number = gr.components.Slider(minimum=1, maximum=10, step=1, value=4, label=\"Beams Number\")\n                max_new_token = gr.components.Slider(\n                    minimum=1, maximum=2048, step=1, value=256, label=\"Max New Tokens\"\n                )\n                min_new_token = gr.components.Slider(\n                    minimum=1, maximum=1024, step=1, value=5, label=\"Min New Tokens\"\n                )\n                repeat_penal = gr.components.Slider(\n                    minimum=0.1, maximum=10.0, step=0.1, value=2.0, label=\"Repetition Penalty\"\n                )\n                max_memory = gr.components.Slider(\n                    minimum=0, maximum=2048, step=1, value=2048, label=\"Max Memory\"\n                )\n                do_sample = gr.components.Checkbox(label=\"Use sample\")\n                # must be str, not number !\n                type_of_prompt = gr.components.Dropdown(\n                    ['instruct', 'chat'], value=args.prompt_type, label=\"Prompt Type\", info=\"select the specific prompt; use after clear history\"\n                )\n                input_components = [\n                    input, history, temperature, topp, topk, beam_number, max_new_token, min_new_token, repeat_penal, max_memory, do_sample, type_of_prompt\n                ]\n                input_components_except_states = [input, temperature, topp, topk, beam_number, max_new_token, min_new_token, repeat_penal, max_memory, do_sample, type_of_prompt]\n            with gr.Row():\n                cancel_btn = gr.Button('Cancel')\n                submit_btn = gr.Button(\"Submit\", variant=\"primary\")\n                stop_btn = gr.Button(\"Stop\", variant=\"stop\", visible=False)\n            with gr.Row():\n                reset_btn = gr.Button(\"Reset Parameter\")\n                clear_history = gr.Button(\"Clear History\")\n\n\n        with gr.Column(variant=\"panel\"):\n            chatbot = gr.Chatbot().style(height=1024)\n            output_components = [ chatbot, history ]  \n            with gr.Row():\n                save_btn = gr.Button(\"Save Chat\")\n        def wrapper(*args):\n            # here to support the change between the stop and submit button\n            try:\n                for output in fn(*args):\n                    output = [o for o in output]\n                    # output for output_components, the rest for [button, button]\n                    yield output + [\n                        gr.Button.update(visible=False),\n                        gr.Button.update(visible=True),\n                    ]\n            finally:\n                yield [{'__type__': 'generic_update'}, {'__type__': 'generic_update'}] + [ gr.Button.update(visible=True), gr.Button.update(visible=False)]\n\n        def cancel(history, chatbot):\n            if history == []:\n                return (None, None)\n            return history[:-1], chatbot[:-1]\n\n        extra_output = [submit_btn, stop_btn]\n        save_btn.click(\n            save, \n            input_components, \n            None, \n        )\n        pred = submit_btn.click(\n            wrapper, \n            input_components, \n            output_components + extra_output, \n            api_name=\"predict\",\n            scroll_to_output=True,\n            preprocess=True,\n            postprocess=True,\n            batch=False,\n            max_batch_size=4,\n        )\n        submit_btn.click(\n            lambda: (\n                submit_btn.update(visible=False),\n                stop_btn.update(visible=True),\n            ),\n            inputs=None,\n            outputs=[submit_btn, stop_btn],\n            queue=False,\n        )\n        stop_btn.click(\n            lambda: (\n                submit_btn.update(visible=True),\n                stop_btn.update(visible=False),\n            ),\n            inputs=None,\n            outputs=[submit_btn, stop_btn],\n            cancels=[pred],\n            queue=False,\n        )\n        cancel_btn.click(\n            cancel,\n            inputs=[history, chatbot],\n            outputs=[history, chatbot]\n        )\n        reset_btn.click(\n            None, \n            [],\n            (\n                # input_components ; don't work for history...\n                input_components_except_states\n                + [input_component_column]\n            ),  # type: ignore\n            _js=f\"\"\"() => {json.dumps([\n                getattr(component, \"cleared_value\", None) for component in input_components_except_states ] \n                + ([gr.Column.update(visible=True)])\n                + ([])\n            )}\n            \"\"\",\n        )\n        clear_history.click(clear, None, [history, chatbot], queue=False)\n\ndemo.queue().launch(share=args.share_link)"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "finetune.py",
          "type": "blob",
          "size": 9.376953125,
          "content": "import os\nimport sys\n\nimport torch\nimport torch.nn as nn\nimport bitsandbytes as bnb\nfrom datasets import load_dataset\nimport transformers\nimport argparse\nimport warnings\nfrom huggingface_hub import snapshot_download\n\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaForCausalLM, LlamaTokenizer\nfrom peft import (\n    prepare_model_for_int8_training,\n    LoraConfig,\n    get_peft_model,\n    get_peft_model_state_dict,\n    set_peft_model_state_dict,\n)\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--wandb\", action=\"store_true\", default=False)\nparser.add_argument(\"--data_path\", type=str, default=\"merge.json\")\nparser.add_argument(\"--output_path\", type=str, default=\"lora-Vicuna\")\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--eval_steps\", type=int, default=200)\nparser.add_argument(\"--save_steps\", type=int, default=200)\nparser.add_argument(\"--test_size\", type=int, default=200)\nparser.add_argument(\"--resume_from_checkpoint\", type=str, default=None)\nparser.add_argument(\"--lora_remote_checkpoint\", type=str, default=None)\nparser.add_argument(\"--ignore_data_skip\", type=str, default=\"False\")\nargs = parser.parse_args()\n\nif not args.wandb:\n    os.environ[\"WANDB_MODE\"] = \"disable\"\n# optimized for RTX 4090. for larger GPUs, increase some of these?\nMICRO_BATCH_SIZE = 4  # this could actually be 5 but i like powers of 2\nBATCH_SIZE = 128\nMAX_STEPS = None\nGRADIENT_ACCUMULATION_STEPS = BATCH_SIZE // MICRO_BATCH_SIZE\nEPOCHS = 3  # we don't always need 3 tbh\nLEARNING_RATE = 3e-4  # the Karpathy constant\nCUTOFF_LEN = 256  # 256 accounts for about 96% of the data\nLORA_R = 8\nLORA_ALPHA = 16\nLORA_DROPOUT = 0.05\nVAL_SET_SIZE = args.test_size #2000\nUSE_8bit = True\n\nif USE_8bit is True:\n    warnings.warn(\"If your version of bitsandbytes>0.37.2, Please downgrade bitsandbytes's version, for example: pip install bitsandbytes==0.37.2\")\n        \nTARGET_MODULES = [\n    \"q_proj\",\n    \"v_proj\",\n]\nDATA_PATH = args.data_path \nOUTPUT_DIR = args.output_path #\"lora-Vicuna\"\n\ndevice_map = \"auto\"\nworld_size = int(os.environ.get(\"WORLD_SIZE\", 1))\nddp = world_size != 1\nif ddp:\n    device_map = {\"\": int(os.environ.get(\"LOCAL_RANK\") or 0)}\n    GRADIENT_ACCUMULATION_STEPS = GRADIENT_ACCUMULATION_STEPS // world_size\nprint(args.model_path)\nmodel = LlamaForCausalLM.from_pretrained(\n    args.model_path,\n    load_in_8bit=USE_8bit,\n    device_map=device_map,\n)\ntokenizer = LlamaTokenizer.from_pretrained(\n    args.model_path, add_eos_token=True\n)\n\nif USE_8bit is True:\n    model = prepare_model_for_int8_training(model)\n\nconfig = LoraConfig(\n    r=LORA_R,\n    lora_alpha=LORA_ALPHA,\n    target_modules=TARGET_MODULES,\n    lora_dropout=LORA_DROPOUT,\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n)\nmodel = get_peft_model(model, config)\ntokenizer.pad_token_id = 0  # unk. we want this to be different from the eos token\n#tokenizer.padding_side = \"left\"  # Allow batched inference\n\ndata = load_dataset(\"json\", data_files=DATA_PATH)\n\nnow_max_steps = max((len(data[\"train\"]) - VAL_SET_SIZE) // BATCH_SIZE * EPOCHS, EPOCHS)\nif args.resume_from_checkpoint:\n    if args.lora_remote_checkpoint is not None:\n        snapshot_download(repo_id=args.lora_remote_checkpoint, allow_patterns=[\"*.pt\", \"*.bin\", \"*.json\"], local_dir=args.resume_from_checkpoint)\n    # Check the available weights and load them\n    checkpoint_name = os.path.join(\n        args.resume_from_checkpoint, \"pytorch_model.bin\"\n    )  # Full checkpoint\n    if not os.path.exists(checkpoint_name):\n        pytorch_bin_path = checkpoint_name\n        checkpoint_name = os.path.join(\n            args.resume_from_checkpoint, \"adapter_model.bin\"\n        )  # only LoRA model - LoRA config above has to fit\n        if os.path.exists(checkpoint_name):\n            os.rename(checkpoint_name, pytorch_bin_path)\n            warnings.warn(\"The file name of the lora checkpoint'adapter_model.bin' is replaced with 'pytorch_model.bin'\")\n        else:\n            args.resume_from_checkpoint = (\n                None  # So the trainer won't try loading its state\n            )\n    # The two files above have a different name depending on how they were saved, but are actually the same.\n    if os.path.exists(checkpoint_name):\n        print(f\"Restarting from {checkpoint_name}\")\n        adapters_weights = torch.load(checkpoint_name)\n        model = set_peft_model_state_dict(model, adapters_weights)\n    else:\n        print(f\"Checkpoint {checkpoint_name} not found\")\n    \n    train_args_path = os.path.join(args.resume_from_checkpoint, \"trainer_state.json\")\n    \n    if os.path.exists(train_args_path):\n        import json\n        base_train_args = json.load(open(train_args_path, 'r'))\n        base_max_steps = base_train_args[\"max_steps\"]\n        resume_scale = base_max_steps / now_max_steps\n        if base_max_steps > now_max_steps:\n            warnings.warn(\"epoch {} replace to the base_max_steps {}\".format(EPOCHS, base_max_steps))\n            EPOCHS = None\n            MAX_STEPS = base_max_steps\n        else:\n            MAX_STEPS = now_max_steps\nelse:\n    MAX_STEPS = now_max_steps\n\n\nmodel.print_trainable_parameters()\n\ndef generate_prompt(data_point):\n    # sorry about the formatting disaster gotta move fast\n    if data_point[\"input\"]:\n        return f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n    else:\n        return f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n\n\ndef tokenize(prompt):\n    # there's probably a way to do this with the tokenizer settings\n    # but again, gotta move fast\n    result = tokenizer(\n        prompt,\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )\n    return {\n        \"input_ids\": result[\"input_ids\"][:-1],\n        \"attention_mask\": result[\"attention_mask\"][:-1],\n    }\n\n\ndef generate_and_tokenize_prompt(data_point):\n    # This function masks out the labels for the input,\n    # so that our loss is computed only on the response.\n    user_prompt = (\n        (\n            f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n\"\"\"\n        )\n        if data_point[\"input\"]\n        else (\n            f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n\"\"\"\n        )\n    )\n    len_user_prompt_tokens = (\n        len(\n            tokenizer(\n                user_prompt,\n                truncation=True,\n                max_length=CUTOFF_LEN + 1,\n            )[\"input_ids\"]\n        )\n        - 1\n    )  # no eos token\n    full_tokens = tokenizer(\n        user_prompt + data_point[\"output\"],\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )[\"input_ids\"][:-1]\n    return {\n        \"input_ids\": full_tokens,\n        \"labels\": [-100] * len_user_prompt_tokens\n        + full_tokens[len_user_prompt_tokens:],\n        \"attention_mask\": [1] * (len(full_tokens)),\n    }\n\n\nif VAL_SET_SIZE > 0:\n    train_val = data[\"train\"].train_test_split(\n        test_size=VAL_SET_SIZE, shuffle=True, seed=42\n    )\n    train_data = train_val[\"train\"].shuffle().map(generate_and_tokenize_prompt)\n    val_data = train_val[\"test\"].shuffle().map(generate_and_tokenize_prompt)\nelse:\n    train_data = data[\"train\"].shuffle().map(generate_and_tokenize_prompt)\n    val_data = None\n\ntrainer = transformers.Trainer(\n    model=model,\n    train_dataset=train_data,\n    eval_dataset=val_data,\n    args=transformers.TrainingArguments(\n        per_device_train_batch_size=MICRO_BATCH_SIZE,\n        gradient_accumulation_steps=GRADIENT_ACCUMULATION_STEPS,\n        warmup_steps=100,\n        num_train_epochs=EPOCHS,\n        max_steps=MAX_STEPS,\n        learning_rate=LEARNING_RATE,\n        fp16=True,\n        logging_steps=20,\n        evaluation_strategy=\"steps\" if VAL_SET_SIZE > 0 else \"no\",\n        save_strategy=\"steps\",\n        eval_steps=args.eval_steps if VAL_SET_SIZE > 0 else None,\n        save_steps=args.save_steps,\n        output_dir=OUTPUT_DIR,\n        save_total_limit=30,\n        load_best_model_at_end=True if VAL_SET_SIZE > 0 else False,\n        ddp_find_unused_parameters=False if ddp else None,\n        report_to=\"wandb\" if args.wandb else [],\n        ignore_data_skip=args.ignore_data_skip,\n    ),\n    data_collator=transformers.DataCollatorForLanguageModeling(tokenizer, mlm=False)\n)\nmodel.config.use_cache = False\n\nold_state_dict = model.state_dict\nmodel.state_dict = (\n    lambda self, *_, **__: get_peft_model_state_dict(self, old_state_dict())\n).__get__(model, type(model))\n\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\nprint(\"\\n If there's a warning about missing keys above, please disregard :)\")\n\ntrainer.train(resume_from_checkpoint=args.resume_from_checkpoint)\n\nmodel.save_pretrained(OUTPUT_DIR)\n\n"
        },
        {
          "name": "finetune_4bit.py",
          "type": "blob",
          "size": 9.7919921875,
          "content": "import os\nimport sys\n\nimport torch\nimport torch.nn as nn\nimport bitsandbytes as bnb\nfrom datasets import load_dataset, Dataset\nimport transformers\nimport argparse\nimport warnings\nfrom huggingface_hub import snapshot_download\n\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\n\n\nfrom transformers import LlamaForCausalLM, LlamaTokenizer, BitsAndBytesConfig\nfrom peft import (\n    prepare_model_for_kbit_training,\n    LoraConfig,\n    get_peft_model,\n    get_peft_model_state_dict,\n    set_peft_model_state_dict,\n)\n\ndef generate_prompt(data_point):\n    # sorry about the formatting disaster gotta move fast\n    if data_point[\"input\"]:\n        return f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n    else:\n        return f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n\ndef tokenize(prompt):\n    # there's probably a way to do this with the tokenizer settings\n    # but again, gotta move fast\n    result = tokenizer(\n        prompt,\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )\n    return {\n        \"input_ids\": result[\"input_ids\"][:-1],\n        \"attention_mask\": result[\"attention_mask\"][:-1],\n    }\n\n\ndef generate_and_tokenize_prompt(data_point):\n    # This function masks out the labels for the input,\n    # so that our loss is computed only on the response.\n    user_prompt = (\n        (\n            f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n\"\"\"\n        )\n        if data_point[\"input\"]\n        else (\n            f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n\"\"\"\n        )\n    )\n    len_user_prompt_tokens = (\n        len(\n            tokenizer(\n                user_prompt,\n                truncation=True,\n                max_length=CUTOFF_LEN + 1,\n            )[\"input_ids\"]\n        )\n        - 1\n    )  # no eos token\n    full_tokens = tokenizer(\n        user_prompt + data_point[\"output\"],\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )[\"input_ids\"][:-1]\n    return {\n        \"input_ids\": full_tokens,\n        \"labels\": [-100] * len_user_prompt_tokens\n        + full_tokens[len_user_prompt_tokens:],\n        \"attention_mask\": [1] * (len(full_tokens)),\n    }\n    \nparser = argparse.ArgumentParser()\nparser.add_argument(\"--wandb\", action=\"store_true\", default=False)\nparser.add_argument(\"--data_path\", type=str, default=\"merge.json\")\nparser.add_argument(\"--output_path\", type=str, default=\"lora-Vicuna\")\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--eval_steps\", type=int, default=200)\nparser.add_argument(\"--save_steps\", type=int, default=200)\nparser.add_argument(\"--test_size\", type=int, default=200)\nparser.add_argument(\"--resume_from_checkpoint\", type=str, default=None)\nparser.add_argument(\"--lora_remote_checkpoint\", type=str, default=None)\nparser.add_argument(\"--ignore_data_skip\", type=str, default=\"False\")\nargs = parser.parse_args()\n\nif not args.wandb:\n    os.environ[\"WANDB_MODE\"] = \"disable\"\n# optimized for RTX 4090. for larger GPUs, increase some of these?\nMICRO_BATCH_SIZE = 8  # this could actually be 5 but i like powers of 2\nBATCH_SIZE = 128\nMAX_STEPS = None\nGRADIENT_ACCUMULATION_STEPS = BATCH_SIZE // MICRO_BATCH_SIZE\nEPOCHS = 3  # we don't always need 3 tbh\nLEARNING_RATE = 3e-4  # the Karpathy constant\nCUTOFF_LEN = 256  # 256 accounts for about 96% of the data\nLORA_R = 8\nLORA_ALPHA = 16\nLORA_DROPOUT = 0.05\nVAL_SET_SIZE = args.test_size #2000\nTARGET_MODULES = [\n    \"q_proj\",\n    \"v_proj\",\n]\nDATA_PATH = args.data_path \nOUTPUT_DIR = args.output_path #\"lora-Vicuna\"\n\ndevice_map = {\"\": 0} #\"auto\"\nworld_size = int(os.environ.get(\"WORLD_SIZE\", 1))\nddp = world_size != 1\nif ddp:\n    device_map = {\"\": int(os.environ.get(\"LOCAL_RANK\") or 0)}\n    GRADIENT_ACCUMULATION_STEPS = GRADIENT_ACCUMULATION_STEPS // world_size\nprint(args.model_path)\nmodel = LlamaForCausalLM.from_pretrained(\n    args.model_path,\n    load_in_4bit=True,\n    device_map=device_map,\n)\ntokenizer = LlamaTokenizer.from_pretrained(\n    args.model_path, add_eos_token=True\n)\n\nmodel.gradient_checkpointing_enable()\nmodel = prepare_model_for_kbit_training(model)\n\nconfig = LoraConfig(\n    r=LORA_R,\n    lora_alpha=LORA_ALPHA,\n    target_modules=TARGET_MODULES,\n    lora_dropout=LORA_DROPOUT,\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n)\nmodel = get_peft_model(model, config)\ntokenizer.pad_token_id = 0  # unk. we want this to be different from the eos token\n#tokenizer.padding_side = \"left\"  # Allow batched inference\n\ndata = load_dataset(\"json\", data_files=DATA_PATH)\nimport random;start = random.randint(1, 100)\nexamples = Dataset.from_dict(data['train'][start:start+5]).map(generate_and_tokenize_prompt)\nfor example in examples:\n    print(f'>>> prompt example:\\n { tokenizer.decode(example[\"input_ids\"]) }')\n    print(f'>>> tokenizer labels: { tokenizer.decode([ 0 if l==-100 else l for l in example[\"labels\"]])}')\n    print(f'>>> tokenizer example: { example[\"input_ids\"][:250] }...{ example[\"input_ids\"][-10:]}')\n\nnow_max_steps = max((len(data[\"train\"]) - VAL_SET_SIZE) // BATCH_SIZE * EPOCHS, EPOCHS)\nif args.resume_from_checkpoint:\n    if args.lora_remote_checkpoint is not None:\n        snapshot_download(repo_id=args.lora_remote_checkpoint, allow_patterns=[\"*.pt\", \"*.bin\", \"*.json\"], local_dir=args.resume_from_checkpoint)\n    # Check the available weights and load them\n    checkpoint_name = os.path.join(\n        args.resume_from_checkpoint, \"pytorch_model.bin\"\n    )  # Full checkpoint\n    if not os.path.exists(checkpoint_name):\n        pytorch_bin_path = checkpoint_name\n        checkpoint_name = os.path.join(\n            args.resume_from_checkpoint, \"adapter_model.bin\"\n        )  # only LoRA model - LoRA config above has to fit\n        if os.path.exists(checkpoint_name):\n            os.rename(checkpoint_name, pytorch_bin_path)\n            warnings.warn(\"The file name of the lora checkpoint'adapter_model.bin' is replaced with 'pytorch_model.bin'\")\n        else:\n            args.resume_from_checkpoint = (\n                None  # So the trainer won't try loading its state\n            )\n    # The two files above have a different name depending on how they were saved, but are actually the same.\n    if os.path.exists(checkpoint_name):\n        print(f\"Restarting from {checkpoint_name}\")\n        adapters_weights = torch.load(checkpoint_name)\n        model = set_peft_model_state_dict(model, adapters_weights)\n    else:\n        print(f\"Checkpoint {checkpoint_name} not found\")\n    \n    train_args_path = os.path.join(args.resume_from_checkpoint, \"trainer_state.json\")\n    \n    if os.path.exists(train_args_path):\n        import json\n        base_train_args = json.load(open(train_args_path, 'r'))\n        base_max_steps = base_train_args[\"max_steps\"]\n        resume_scale = base_max_steps / now_max_steps\n        if base_max_steps > now_max_steps:\n            warnings.warn(\"epoch {} replace to the base_max_steps {}\".format(EPOCHS, base_max_steps))\n            EPOCHS = None\n            MAX_STEPS = base_max_steps\n        else:\n            MAX_STEPS = now_max_steps\nelse:\n    MAX_STEPS = now_max_steps\n\n\nmodel.print_trainable_parameters()\n\n\nnum_proc = (os.cpu_count())\nif VAL_SET_SIZE > 0:\n    train_val = data[\"train\"].train_test_split(\n        test_size=VAL_SET_SIZE, shuffle=True, seed=42\n    )\n    train_data = train_val[\"train\"].shuffle().map(generate_and_tokenize_prompt, num_proc=num_proc)\n    val_data = train_val[\"test\"].shuffle().map(generate_and_tokenize_prompt, num_proc=num_proc)\nelse:\n    train_data = data[\"train\"].shuffle().map(generate_and_tokenize_prompt, num_proc=num_proc)\n    val_data = None\n\ntrainer = transformers.Trainer(\n    model=model,\n    train_dataset=train_data,\n    eval_dataset=val_data,\n    args=transformers.TrainingArguments(\n        per_device_train_batch_size=MICRO_BATCH_SIZE,\n        gradient_accumulation_steps=GRADIENT_ACCUMULATION_STEPS,\n        warmup_steps=100,\n        num_train_epochs=EPOCHS,\n        max_steps=MAX_STEPS,\n        learning_rate=LEARNING_RATE,\n        fp16=True,\n        logging_steps=20,\n        evaluation_strategy=\"steps\" if VAL_SET_SIZE > 0 else \"no\",\n        save_strategy=\"steps\",\n        eval_steps=args.eval_steps if VAL_SET_SIZE > 0 else None,\n        save_steps=args.save_steps,\n        output_dir=OUTPUT_DIR,\n        save_total_limit=30,\n        load_best_model_at_end=True if VAL_SET_SIZE > 0 else False,\n        ddp_find_unused_parameters=False if ddp else None,\n        report_to=\"wandb\" if args.wandb else [],\n        ignore_data_skip=args.ignore_data_skip,\n        optim=\"paged_adamw_8bit\",\n    ),\n    data_collator=transformers.DataCollatorForLanguageModeling(tokenizer, mlm=False)\n)\nmodel.config.use_cache = False\n\nold_state_dict = model.state_dict\nmodel.state_dict = (\n    lambda self, *_, **__: get_peft_model_state_dict(self, old_state_dict())\n).__get__(model, type(model))\n\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\nprint(\"\\n If there's a warning about missing keys above, please disregard :)\")\n\ntrainer.train(resume_from_checkpoint=args.resume_from_checkpoint)\n\nmodel.save_pretrained(OUTPUT_DIR)\n\n"
        },
        {
          "name": "finetune_chat.py",
          "type": "blob",
          "size": 11.568359375,
          "content": "from peft import (\n    prepare_model_for_int8_training,\n    LoraConfig,\n    PeftModel,\n    get_peft_model,\n    get_peft_model_state_dict,\n    set_peft_model_state_dict,\n)\nfrom transformers import LlamaForCausalLM, LlamaTokenizer, TrainerCallback, GenerationConfig\nimport os\nimport sys\nimport torch\nimport torch.nn as nn\nimport bitsandbytes as bnb\nfrom datasets import load_dataset, Dataset\nimport transformers\nfrom huggingface_hub import snapshot_download\nimport argparse\nimport warnings\nfrom tqdm import tqdm\nfrom functools import partial\nimport utils\nimport prompt\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\n\n# 0. prepare args and logger\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--wandb\", action=\"store_true\", default=False)\nparser.add_argument(\"--prompt_type\", type=str, default=\"chat\")\nparser.add_argument(\"--data_path\", type=str, default=\"merge.json\")\nparser.add_argument(\"--output_path\", type=str, default=\"lora-Vicuna\")\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--num_epoch\", type=int, default=3)\nparser.add_argument(\"--micro_batch\", type=int, default=4)\nparser.add_argument(\"--total_batch\", type=int, default=128)\nparser.add_argument(\"--log_steps\", type=int, default=100)\nparser.add_argument(\"--eval_steps\", type=int, default=200)\nparser.add_argument(\"--save_steps\", type=int, default=200)\nparser.add_argument(\"--warmup_ratio\", type=float, default=0.05)\nparser.add_argument(\"--test_size\", type=int, default=200)\nparser.add_argument(\"--resume_from_checkpoint\", type=str, default=None)\nparser.add_argument(\"--lora_remote_checkpoint\", type=str, default=None)\nparser.add_argument(\"--ignore_data_skip\", type=bool, default=False)\nargs = parser.parse_args()\nif not args.wandb:\n    os.environ[\"WANDB_MODE\"] = \"disable\"\nMICRO_BATCH_SIZE = args.micro_batch  # this could actually be 5 but i like powers of 2\nBATCH_SIZE = args.total_batch\nMAX_STEPS = None\nGRADIENT_ACCUMULATION_STEPS = BATCH_SIZE // MICRO_BATCH_SIZE\nEPOCHS = args.num_epoch \nLEARNING_RATE = 3e-4  # the Karpathy constant\nCUTOFF_LEN = 2048  \nLORA_R = 8\nLORA_ALPHA = 16\nLORA_DROPOUT = 0.05\nUSE_8bit = True\nVAL_SET_SIZE = args.test_size  # 2000\nTARGET_MODULES = [\n    \"q_proj\",\n    \"v_proj\",\n    \"k_proj\",\n    \"o_proj\",\n    \"down_proj\",\n    \"gate_proj\",\n    \"up_proj\",\n]\nDATA_PATH = args.data_path  \nOUTPUT_DIR = args.output_path  # \"lora-Vicuna\"\n\ndevice_map = \"auto\"\nworld_size = int(os.environ.get(\"WORLD_SIZE\", 1))\nddp = world_size != 1\nif ddp:\n    device_map = {\"\": int(os.environ.get(\"LOCAL_RANK\") or 0)}\n    GRADIENT_ACCUMULATION_STEPS = GRADIENT_ACCUMULATION_STEPS // world_size\n# we must make sure batch_size and gradient_accumulation_steps not changed for resuming training.\nif args.resume_from_checkpoint:\n    old_args_path = os.path.join(args.resume_from_checkpoint, 'training_args.bin')\n    if os.path.exists(old_args_path):\n        old_args = torch.load(old_args_path)\n        if MICRO_BATCH_SIZE != old_args.per_device_train_batch_size:\n            raise Exception(\n                f'current micro batch size {MICRO_BATCH_SIZE} is not equal to the old {old_args.per_device_train_batch_size},'\n                ' This will cause the trainer skips wrong epochs or steps.'\n                f'please change your micro batch size to {old_args.per_device_train_batch_size}'\n                ' or cancel resuming your training'\n                )\n        if GRADIENT_ACCUMULATION_STEPS != old_args.gradient_accumulation_steps:\n            raise Exception(\n                f'current total batch {BATCH_SIZE} is not equal to the old {old_args.gradient_accumulation_steps*old_args.per_device_train_batch_size},'\n                ' This will cause the trainer skips wrong epochs or steps.'\n                f'please change your total batch size to {old_args.gradient_accumulation_steps*old_args.per_device_train_batch_size}'    \n                ' or cancel resuming your training'\n            )\n    else:\n        raise Exception(f'{old_args_path} is not exist!')\n    # checkpoint = os.path.join(args.resume_from_checkpoint, 'pytorch_model.bin')\n\nlogger = utils.set_file_logger(__name__,OUTPUT_DIR)\n# 1. load dataset\nlogger.info(f'>>> processing data from {DATA_PATH}')\nlogger.info(f'>>> using {args}')\n\ntrain_tokenizer = LlamaTokenizer.from_pretrained(args.model_path, add_eos_token=True)\nassert train_tokenizer.eos_token_id == 2, \"Tokenizer eos is wrong!!!\"\n# unk. we want this to be different from the eos token\ntrain_tokenizer.pad_token_id = 0  \n# cannot use eos in generation!\n# tokenizer.padding_side = \"left\"  # Allow batched inference\ntest_tokenizer = LlamaTokenizer.from_pretrained(args.model_path)\nif args.prompt_type == 'instruct':\n    PROMPT = prompt.instruct_prompt(train_tokenizer, CUTOFF_LEN)\nelif args.prompt_type == 'chat':\n    PROMPT = prompt.chat_prompt(train_tokenizer,CUTOFF_LEN)\nelse:\n    raise Exception('not support')\n# check tokenizer\ndata = load_dataset('json', data_files=DATA_PATH)\nimport random;start = random.randint(1, 100)\nexamples = Dataset.from_dict(data['train'][start:start+5]).map(PROMPT.preprocess_train)\nfor example in examples:\n    logger.info(f'>>> using prompt {args.prompt_type}, prompt example:\\n { train_tokenizer.decode(example[\"input_ids\"]) }')\n    logger.info(f'>>> tokenizer labels: { train_tokenizer.decode([ 0 if l==-100 else l for l in example[\"labels\"]])}')\n    logger.info(f'>>> tokenizer example: { example[\"input_ids\"][:10] }...{ example[\"input_ids\"][-10:]}')\n# 2. load model and checkpoints\nlogger.info(f'>>> load model from {args.model_path}')\n\n# if USE_8bit is True:\n#     assert bnb.__version__ >= '0.37.2', \"Please downgrade bitsandbytes's version, for example: pip install bitsandbytes==0.37.2\"\nmodel = LlamaForCausalLM.from_pretrained(\n    args.model_path,\n    load_in_8bit=USE_8bit,\n    device_map=device_map,\n    torch_dtype=torch.float16,\n)\nif USE_8bit is True:\n    model = prepare_model_for_int8_training(model)\nconfig = LoraConfig(\n    r=LORA_R,\n    lora_alpha=LORA_ALPHA,\n    target_modules=TARGET_MODULES,\n    lora_dropout=LORA_DROPOUT,\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n)\nmodel = get_peft_model(model, config)\nif args.resume_from_checkpoint:\n    checkpoint_name = os.path.join(args.resume_from_checkpoint, \"pytorch_model.bin\")\n    # adapter_model.bin\n    if not os.path.exists(checkpoint_name):\n        pytorch_bin_path = checkpoint_name\n        checkpoint_name = os.path.join(args.resume_from_checkpoint, \"adapter_model.bin\")\n        if os.path.exists(checkpoint_name):\n            os.rename(checkpoint_name, pytorch_bin_path)\n            logger.warning(\"The file name of the lora checkpoint'adapter_model.bin' is replaced with 'pytorch_model.bin'\")\n        else:\n            args.resume_from_checkpoint = None  # So the trainer won't try loading its state\n    # pytorch_model.bin\n    if os.path.exists(checkpoint_name):\n        logger.info(f'>>> load lora from {checkpoint_name}')\n        adapters_weights = torch.load(checkpoint_name)\n        set_peft_model_state_dict(model, adapters_weights)\n    else:\n        raise Exception(f\"Checkpoint {checkpoint_name} not found with resume_from_checkpoint=True!\")\n\ntrainable_params = 0\nall_param = 0\nfor _, param in model.named_parameters():\n    num_params = param.numel()\n    # if using DS Zero 3 and the weights are initialized empty\n    if num_params == 0 and hasattr(param, \"ds_numel\"):\n        num_params = param.ds_numel\n    all_param += num_params\n    if param.requires_grad:\n        trainable_params += num_params\nlogger.info(f\">>> trainable params: {trainable_params} || all params: {all_param} || trainable%: {100 * trainable_params / all_param}\")\n\n# 3. speedup dataset processing by multi-process\nnum_proc = 1#(os.cpu_count())\nif VAL_SET_SIZE > 0:\n    train_val = data[\"train\"].train_test_split(test_size=VAL_SET_SIZE, shuffle=True, seed=42)\n    train_data = train_val[\"train\"].shuffle().map(PROMPT.preprocess_train, num_proc=num_proc)\n    val_data = train_val[\"test\"].shuffle().map(PROMPT.preprocess_train, num_proc=num_proc)\nelse:\n    train_data = data[\"train\"].shuffle().map(PROMPT.preprocess_train, num_proc=num_proc)\n    val_data = None\nnow_max_steps = max((len(data[\"train\"]) - VAL_SET_SIZE) // BATCH_SIZE * EPOCHS, EPOCHS)\nif args.resume_from_checkpoint:\n    # the trainer will ignore the state max_steps and caculate max_steps based on epochs,\n    # so we mannally set the args.max_step to override it. \n    if args.lora_remote_checkpoint is not None:\n        snapshot_download(repo_id=args.lora_remote_checkpoint, allow_patterns=[\"*.pt\", \"*.bin\", \"*.json\"], local_dir=args.resume_from_checkpoint)\n    train_state_path = os.path.join(args.resume_from_checkpoint, \"trainer_state.json\")\n    if os.path.exists(train_state_path):\n        import json\n        base_train_args = json.load(open(train_state_path, 'r'))\n        base_max_steps = base_train_args[\"max_steps\"]\n        resume_scale = base_max_steps / now_max_steps\n        if base_max_steps > now_max_steps:\n            logger.warning(f\"epoch {EPOCHS}:{MAX_STEPS} replace to the base_max_steps {base_max_steps}\")\n            EPOCHS = None\n            MAX_STEPS = base_max_steps\n        else:\n            MAX_STEPS = now_max_steps\n    assert MAX_STEPS is not None\nelse:\n    MAX_STEPS = now_max_steps\n\n# 4. start training\nclass CustomCallback(TrainerCallback):\n    \n    def __init__(self, trainer) -> None:\n        super().__init__()\n        self.trainer = trainer\n        self.generation_config = GenerationConfig(\n            temperature=1.0,\n            top_p=0.75,\n            top_k=40,\n            num_beams=2,\n            bos_token_id=train_tokenizer.bos_token_id,\n            eos_token_id=train_tokenizer.eos_token_id,\n            pad_token_id=train_tokenizer.pad_token_id,\n            max_new_tokens=1024, # max_length=max_new_tokens+input_sequence\n            min_new_tokens=1, # min_length=min_new_tokens+input_sequence\n            bad_words_ids=test_tokenizer(['\\n\\nUser:','\\n\\nAssistant:'], add_special_tokens=False).input_ids\n        )\n        self.repetition_penalty=1.3\n        self.logger = utils.set_file_logger('transformers.trainer', trainer.args.output_dir)\n\n    def on_log(self, args, state, control, logs, **kwargs):\n        logger.info(logs)\n\ntrainer = transformers.Trainer(\n    model=model,\n    train_dataset=train_data,\n    eval_dataset=val_data,\n    args=transformers.TrainingArguments(\n        per_device_train_batch_size=MICRO_BATCH_SIZE,\n        gradient_accumulation_steps=GRADIENT_ACCUMULATION_STEPS,\n        warmup_ratio=args.warmup_ratio,\n        num_train_epochs=EPOCHS,\n        max_steps=MAX_STEPS,\n        learning_rate=LEARNING_RATE,\n        fp16=True,\n        logging_steps=args.log_steps,\n        logging_first_step=True, # convenient\n        evaluation_strategy=\"steps\" if VAL_SET_SIZE > 0 else \"no\",\n        save_strategy=\"steps\",\n        eval_steps=args.eval_steps if VAL_SET_SIZE > 0 else None,\n        save_steps=args.save_steps,\n        output_dir=OUTPUT_DIR,\n        load_best_model_at_end=True if VAL_SET_SIZE > 0 else False,\n        ddp_find_unused_parameters=False if ddp else None,\n        report_to=\"wandb\" if args.wandb else [],\n        ignore_data_skip=args.ignore_data_skip,\n    ),\n    data_collator=PROMPT.data_collator()\n)\ntrainer.add_callback(CustomCallback(trainer))\nmodel.config.use_cache = False\n\nold_state_dict = model.state_dict\nmodel.state_dict = (\n    lambda self, *_, **__: get_peft_model_state_dict(self, old_state_dict())\n).__get__(model, type(model))\n\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\ntrainer.train(resume_from_checkpoint=args.resume_from_checkpoint)\nmodel.save_pretrained(OUTPUT_DIR)\n"
        },
        {
          "name": "finetune_fp16.py",
          "type": "blob",
          "size": 9.7333984375,
          "content": "import os\nimport sys\n\nimport torch\nimport torch.nn as nn\nimport bitsandbytes as bnb\nfrom datasets import load_dataset\nimport transformers\nimport argparse\nimport warnings\nfrom huggingface_hub import snapshot_download\n\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaForCausalLM, LlamaTokenizer\nfrom peft import (\n    prepare_model_for_int8_training,\n    LoraConfig,\n    get_peft_model,\n    get_peft_model_state_dict,\n    set_peft_model_state_dict,\n)\n\ndef get_peft_state_maybe_zero_3(state_dict, bias):\n    if hasattr(param, \"ds_id\"):\n        assert param.ds_status == ZeroParamStatus.NOT_AVAILABLE\n        with zero.GatheredParameters([param]):\n            param = param.data.cpu().clone().detach()\n    to_return = {k: maybe_zero_3(v) for k, v in to_return.items()}\n    return to_return\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--wandb\", action=\"store_true\", default=False)\nparser.add_argument(\"--data_path\", type=str, default=\"merge.json\")\nparser.add_argument(\"--output_path\", type=str, default=\"lora-Vicuna\")\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--eval_steps\", type=int, default=200)\nparser.add_argument(\"--save_steps\", type=int, default=200)\nparser.add_argument(\"--test_size\", type=int, default=200)\nparser.add_argument(\"--resume_from_checkpoint\", type=str, default=None)\nparser.add_argument(\"--ignore_data_skip\", type=str, default=\"False\")\nparser.add_argument(\"--lora_remote_checkpoint\", type=str, default=None)\n\nparser.add_argument(\"--local_rank\", type=int, default=-1)\nparser.add_argument(\"--deepspeed\", action=\"store_true\", default=False)\n\nargs = parser.parse_args()\n\nif not args.wandb:\n    os.environ[\"WANDB_MODE\"] = \"disable\"\n# optimized for RTX 4090. for larger GPUs, increase some of these?\nMICRO_BATCH_SIZE = 2  # this could actually be 5 but i like powers of 2\nBATCH_SIZE = 128\nMAX_STEPS = None\nGRADIENT_ACCUMULATION_STEPS = BATCH_SIZE // MICRO_BATCH_SIZE\nEPOCHS = 3  # we don't always need 3 tbh\nLEARNING_RATE = 3e-4  # the Karpathy constant\nCUTOFF_LEN = 256  # 256 accounts for about 96% of the data\nLORA_R = 8\nLORA_ALPHA = 16\nLORA_DROPOUT = 0.05\nVAL_SET_SIZE = args.test_size #2000\nTARGET_MODULES = [\n    \"q_proj\",\n    \"v_proj\",\n]\nDATA_PATH = args.data_path\nOUTPUT_DIR = args.output_path #\"lora-Vicuna\"\n\ndevice_map = {\"\": 0} #\"auto\"\nworld_size = int(os.environ.get(\"WORLD_SIZE\", 1))\nddp = world_size != 1\nif ddp:\n    device_map = {\"\": int(os.environ.get(\"LOCAL_RANK\") or 0)}\n    GRADIENT_ACCUMULATION_STEPS = GRADIENT_ACCUMULATION_STEPS // world_size\nprint(args.model_path)\nmodel = LlamaForCausalLM.from_pretrained(\n    args.model_path,\n    load_in_8bit=False,\n    torch_dtype=torch.float16,\n    device_map=device_map,\n).half()\ntokenizer = LlamaTokenizer.from_pretrained(\n    args.model_path, add_eos_token=True\n)\n\n#model = prepare_model_for_int8_training(model)\n\nconfig = LoraConfig(\n    r=LORA_R,\n    lora_alpha=LORA_ALPHA,\n    target_modules=TARGET_MODULES,\n    lora_dropout=LORA_DROPOUT,\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n)\nmodel = get_peft_model(model, config)\n\ntokenizer.pad_token_id = 0  # unk. we want this to be different from the eos token\n#tokenizer.padding_side = \"left\"  # Allow batched inference\n\ndata = load_dataset(\"json\", data_files=DATA_PATH)\n\nnow_max_steps = max((len(data[\"train\"]) - VAL_SET_SIZE) // BATCH_SIZE * EPOCHS, EPOCHS)\nif args.resume_from_checkpoint:\n    if args.lora_remote_checkpoint is not None:\n        snapshot_download(repo_id=args.lora_remote_checkpoint, allow_patterns=[\"*.pt\", \"*.bin\", \"*.json\"], local_dir=args.resume_from_checkpoint)\n    # Check the available weights and load them\n    checkpoint_name = os.path.join(\n        args.resume_from_checkpoint, \"pytorch_model.bin\"\n    )  # Full checkpoint\n    if not os.path.exists(checkpoint_name):\n        pytorch_bin_path = checkpoint_name\n        checkpoint_name = os.path.join(\n            args.resume_from_checkpoint, \"adapter_model.bin\"\n        )  # only LoRA model - LoRA config above has to fit\n        if os.path.exists(checkpoint_name):\n            os.rename(checkpoint_name, pytorch_bin_path)\n            warnings.warn(\"The file name of the lora checkpoint'adapter_model.bin' is replaced with 'pytorch_model.bin'\")\n        else:\n            args.resume_from_checkpoint = (\n                None  # So the trainer won't try loading its state\n            )\n    # The two files above have a different name depending on how they were saved, but are actually the same.\n    if os.path.exists(checkpoint_name):\n        print(f\"Restarting from {checkpoint_name}\")\n        adapters_weights = torch.load(checkpoint_name)\n        model = set_peft_model_state_dict(model, adapters_weights)\n    else:\n        print(f\"Checkpoint {checkpoint_name} not found\")\n    \n    train_args_path = os.path.join(args.resume_from_checkpoint, \"trainer_state.json\")\n    \n    if os.path.exists(train_args_path):\n        import json\n        base_train_args = json.load(open(train_args_path, 'r'))\n        base_max_steps = base_train_args[\"max_steps\"]\n        resume_scale = base_max_steps / now_max_steps\n        if base_max_steps > now_max_steps:\n            warnings.warn(\"epoch {} replace to the base_max_steps {}\".format(EPOCHS, base_max_steps))\n            EPOCHS = None\n            MAX_STEPS = base_max_steps\n        else:\n            MAX_STEPS = now_max_steps\nelse:\n    MAX_STEPS = now_max_steps\n\n\nmodel.print_trainable_parameters()\n\ndef generate_prompt(data_point):\n    # sorry about the formatting disaster gotta move fast\n    if data_point[\"input\"]:\n        return f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n    else:\n        return f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n{data_point[\"output\"]}\"\"\"\n\n\ndef tokenize(prompt):\n    # there's probably a way to do this with the tokenizer settings\n    # but again, gotta move fast\n    result = tokenizer(\n        prompt,\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )\n    return {\n        \"input_ids\": result[\"input_ids\"][:-1],\n        \"attention_mask\": result[\"attention_mask\"][:-1],\n    }\n\n\ndef generate_and_tokenize_prompt(data_point):\n    # This function masks out the labels for the input,\n    # so that our loss is computed only on the response.\n    user_prompt = (\n        (\n            f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Input:\n{data_point[\"input\"]}\n\n### Response:\n\"\"\"\n        )\n        if data_point[\"input\"]\n        else (\n            f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{data_point[\"instruction\"]}\n\n### Response:\n\"\"\"\n        )\n    )\n    len_user_prompt_tokens = (\n        len(\n            tokenizer(\n                user_prompt,\n                truncation=True,\n                max_length=CUTOFF_LEN + 1,\n            )[\"input_ids\"]\n        )\n        - 1\n    )  # no eos token\n    full_tokens = tokenizer(\n        user_prompt + data_point[\"output\"],\n        truncation=True,\n        max_length=CUTOFF_LEN + 1,\n        padding=\"max_length\",\n    )[\"input_ids\"][:-1]\n    return {\n        \"input_ids\": full_tokens,\n        \"labels\": [-100] * len_user_prompt_tokens\n        + full_tokens[len_user_prompt_tokens:],\n        \"attention_mask\": [1] * (len(full_tokens)),\n    }\n\n\nif VAL_SET_SIZE > 0:\n    train_val = data[\"train\"].train_test_split(\n        test_size=VAL_SET_SIZE, shuffle=True, seed=42\n    )\n    train_data = train_val[\"train\"].shuffle().map(generate_and_tokenize_prompt)\n    val_data = train_val[\"test\"].shuffle().map(generate_and_tokenize_prompt)\nelse:\n    train_data = data[\"train\"].shuffle().map(generate_and_tokenize_prompt)\n    val_data = None\ntrainer = transformers.Trainer(\n    model=model,\n    train_dataset=train_data,\n    eval_dataset=val_data,\n    args=transformers.TrainingArguments(\n        per_device_train_batch_size=MICRO_BATCH_SIZE,\n        gradient_accumulation_steps=GRADIENT_ACCUMULATION_STEPS,\n        warmup_steps=100,\n        num_train_epochs=EPOCHS,\n        max_steps=MAX_STEPS,\n        learning_rate=LEARNING_RATE,\n        fp16=True,\n        logging_steps=20,\n        evaluation_strategy=\"steps\" if VAL_SET_SIZE > 0 else \"no\",\n        save_strategy=\"steps\",\n        eval_steps=args.eval_steps if VAL_SET_SIZE > 0 else None,\n        save_steps=args.save_steps,\n        output_dir=OUTPUT_DIR,\n        save_total_limit=30,\n        load_best_model_at_end=True if VAL_SET_SIZE > 0 else False,\n        ddp_find_unused_parameters=False if ddp else None,\n        report_to=\"wandb\" if args.wandb else [],\n        ignore_data_skip=args.ignore_data_skip,\n        deepspeed=\"sample/zero_config.json\" if args.deepspeed else None,\n    ),\n    data_collator=transformers.DataCollatorForLanguageModeling(tokenizer, mlm=False)\n)\nmodel.config.use_cache = False\n\nold_state_dict = model.state_dict\nmodel.state_dict = (\n    lambda self, *_, **__: get_peft_model_state_dict(self, old_state_dict())\n).__get__(model, type(model))\n\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\nprint(\"\\n If there's a warning about missing keys above, please disregard :)\")\n\ntrainer.train(resume_from_checkpoint=args.resume_from_checkpoint)\n\nmodel.save_pretrained(OUTPUT_DIR)\n\n"
        },
        {
          "name": "generate.py",
          "type": "blob",
          "size": 6.6240234375,
          "content": "import sys\nimport torch\nfrom peft import PeftModel, PeftModelForCausalLM, LoraConfig\nimport transformers\nimport gradio as gr\nimport argparse\nimport warnings\nimport os\nfrom utils import StreamPeftGenerationMixin,StreamLlamaForCausalLM\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaTokenizer, LlamaForCausalLM, GenerationConfig\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--model_path\", type=str, default=\"/model/13B_hf\")\nparser.add_argument(\"--lora_path\", type=str, default=\"checkpoint-3000\")\nparser.add_argument(\"--use_typewriter\", type=int, default=1)\nparser.add_argument(\"--use_local\", type=int, default=1)\nargs = parser.parse_args()\nprint(args)\ntokenizer = LlamaTokenizer.from_pretrained(args.model_path)\n\nLOAD_8BIT = True\nBASE_MODEL = args.model_path\nLORA_WEIGHTS = args.lora_path\n\n\n# fix the path for local checkpoint\nlora_bin_path = os.path.join(args.lora_path, \"adapter_model.bin\")\nprint(lora_bin_path)\nif not os.path.exists(lora_bin_path) and args.use_local:\n    pytorch_bin_path = os.path.join(args.lora_path, \"pytorch_model.bin\")\n    print(pytorch_bin_path)\n    if os.path.exists(pytorch_bin_path):\n        os.rename(pytorch_bin_path, lora_bin_path)\n        warnings.warn(\n            \"The file name of the lora checkpoint'pytorch_model.bin' is replaced with 'adapter_model.bin'\"\n        )\n    else:\n        assert ('Checkpoint is not Found!')\n\nif torch.cuda.is_available():\n    device = \"cuda\"\nelse:\n    device = \"cpu\"\n\ntry:\n    if torch.backends.mps.is_available():\n        device = \"mps\"\nexcept:\n    pass\n\nif device == \"cuda\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        load_in_8bit=LOAD_8BIT,\n        torch_dtype=torch.float16,\n        device_map=\"auto\", #device_map={\"\": 0},\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model, LORA_WEIGHTS, torch_dtype=torch.float16, device_map=\"auto\", #device_map={\"\": 0}\n    )\nelif device == \"mps\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\nelse:\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL, device_map={\"\": device}, low_cpu_mem_usage=True\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n    )\n\n\ndef generate_prompt(instruction, input=None):\n    if input:\n        return f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{instruction}\n\n### Input:\n{input}\n\n### Response:\"\"\"\n    else:\n        return f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{instruction}\n\n### Response:\"\"\"\n\n\nif not LOAD_8BIT:\n    model.half()  # seems to fix bugs for some users.\n\nmodel.eval()\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\n\ndef evaluate(\n    input,\n    temperature=0.1,\n    top_p=0.75,\n    top_k=40,\n    num_beams=4,\n    max_new_tokens=128,\n    min_new_tokens=1,\n    repetition_penalty=2.0,\n    **kwargs,\n):\n    prompt = generate_prompt(input)\n    inputs = tokenizer(prompt, return_tensors=\"pt\")\n    input_ids = inputs[\"input_ids\"].to(device)\n    generation_config = GenerationConfig(\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        num_beams=num_beams,\n        bos_token_id=1,\n        eos_token_id=2,\n        pad_token_id=0,\n        max_new_tokens=max_new_tokens, # max_length=max_new_tokens+input_sequence\n        min_new_tokens=min_new_tokens, # min_length=min_new_tokens+input_sequence\n        **kwargs,\n    )\n    with torch.no_grad():\n        if args.use_typewriter:\n            for generation_output in model.stream_generate(\n                input_ids=input_ids,\n                generation_config=generation_config,\n                return_dict_in_generate=True,\n                output_scores=False,\n                repetition_penalty=float(repetition_penalty),\n            ):\n                outputs = tokenizer.batch_decode(generation_output)\n                show_text = \"\\n--------------------------------------------\\n\".join(\n                    [output.split(\"### Response:\")[1].strip().replace('�','')+\" ▌\" for output in outputs]\n                )\n                # if show_text== '':\n                #     yield last_show_text\n                # else:\n                yield show_text\n            yield outputs[0].split(\"### Response:\")[1].strip().replace('�','')\n        else:\n            generation_output = model.generate(\n                input_ids=input_ids,\n                generation_config=generation_config,\n                return_dict_in_generate=True,\n                output_scores=False,\n                repetition_penalty=1.3,\n            )\n            output = generation_output.sequences[0]\n            output = tokenizer.decode(output).split(\"### Response:\")[1].strip()\n            print(output)\n            yield output\n\n\ngr.Interface(\n    fn=evaluate,\n    inputs=[\n        gr.components.Textbox(\n            lines=2, label=\"Input\", placeholder=\"Tell me about alpacas.\"\n        ),\n        gr.components.Slider(minimum=0, maximum=1, value=0.1, label=\"Temperature\"),\n        gr.components.Slider(minimum=0, maximum=1, value=0.75, label=\"Top p\"),\n        gr.components.Slider(minimum=0, maximum=100, step=1, value=40, label=\"Top k\"),\n        gr.components.Slider(minimum=1, maximum=10, step=1, value=4, label=\"Beams Number\"),\n        gr.components.Slider(\n            minimum=1, maximum=2000, step=1, value=256, label=\"Max New Tokens\"\n        ),\n        gr.components.Slider(\n            minimum=1, maximum=300, step=1, value=1, label=\"Min New Tokens\"\n        ),\n        gr.components.Slider(\n            minimum=0.1, maximum=10.0, step=0.1, value=2.0, label=\"Repetition Penalty\"\n        ),\n    ],\n    outputs=[\n        gr.inputs.Textbox(\n            lines=25,\n            label=\"Output\",\n        )\n    ],\n    title=\"Chinese-Vicuna 中文小羊驼\",\n    description=\"中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。\",\n).queue().launch(share=True)\n"
        },
        {
          "name": "generate_4bit.py",
          "type": "blob",
          "size": 6.900390625,
          "content": "import sys\nimport torch\nfrom peft import PeftModel, PeftModelForCausalLM, LoraConfig\nimport transformers\nimport gradio as gr\nimport argparse\nimport warnings\nimport os\nfrom utils import StreamPeftGenerationMixin,StreamLlamaForCausalLM\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaTokenizer, LlamaForCausalLM, GenerationConfig, BitsAndBytesConfig\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--model_path\", type=str, default=\"/model/13B_hf\")\nparser.add_argument(\"--lora_path\", type=str, default=\"checkpoint-3000\")\nparser.add_argument(\"--use_typewriter\", type=int, default=1)\nparser.add_argument(\"--use_local\", type=int, default=1)\nargs = parser.parse_args()\nprint(args)\ntokenizer = LlamaTokenizer.from_pretrained(args.model_path)\n\nLOAD_8BIT = True\nBASE_MODEL = args.model_path\nLORA_WEIGHTS = args.lora_path\n\n\n# fix the path for local checkpoint\nlora_bin_path = os.path.join(args.lora_path, \"adapter_model.bin\")\nprint(lora_bin_path)\nif not os.path.exists(lora_bin_path) and args.use_local:\n    pytorch_bin_path = os.path.join(args.lora_path, \"pytorch_model.bin\")\n    print(pytorch_bin_path)\n    if os.path.exists(pytorch_bin_path):\n        os.rename(pytorch_bin_path, lora_bin_path)\n        warnings.warn(\n            \"The file name of the lora checkpoint'pytorch_model.bin' is replaced with 'adapter_model.bin'\"\n        )\n    else:\n        assert ('Checkpoint is not Found!')\n\nif torch.cuda.is_available():\n    device = \"cuda\"\nelse:\n    device = \"cpu\"\n\ntry:\n    if torch.backends.mps.is_available():\n        device = \"mps\"\nexcept:\n    pass\n\nbnb_config = BitsAndBytesConfig(\n    load_in_4bit=True,\n    bnb_4bit_use_double_quant=True,\n    bnb_4bit_quant_type=\"nf4\",\n    bnb_4bit_compute_dtype=torch.float16\n)\n\nif device == \"cuda\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        quantization_config=bnb_config,\n        torch_dtype=torch.float16,\n        device_map=\"auto\", #{\"\": 0},\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model, LORA_WEIGHTS, torch_dtype=torch.float16, device_map=\"auto\", #{\"\": 0}\n    )\nelif device == \"mps\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\nelse:\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL, device_map={\"\": device}, low_cpu_mem_usage=True\n    )\n    model = StreamPeftGenerationMixin.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n    )\n\nmodel.config.bos_token_id = tokenizer.bos_token_id = 1\nmodel.config.eos_token_id = tokenizer.eos_token_id = 2\n\ndef generate_prompt(instruction, input=None):\n    if input:\n        return f\"\"\"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{instruction}\n\n### Input:\n{input}\n\n### Response:\"\"\"\n    else:\n        return f\"\"\"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\n{instruction}\n\n### Response:\"\"\"\n\n\nif not LOAD_8BIT:\n    model.half()  # seems to fix bugs for some users.\n\nmodel.eval()\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\n\ndef evaluate(\n    input,\n    temperature=0.1,\n    top_p=0.75,\n    top_k=40,\n    num_beams=4,\n    max_new_tokens=128,\n    min_new_tokens=1,\n    repetition_penalty=2.0,\n    **kwargs,\n):\n    prompt = generate_prompt(input)\n    inputs = tokenizer(prompt, return_tensors=\"pt\")\n    input_ids = inputs[\"input_ids\"].to(device)\n    generation_config = GenerationConfig(\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        num_beams=num_beams,\n        bos_token_id=1,\n        eos_token_id=2,\n        pad_token_id=0,\n        max_new_tokens=max_new_tokens, # max_length=max_new_tokens+input_sequence\n        min_new_tokens=min_new_tokens, # min_length=min_new_tokens+input_sequence\n        **kwargs,\n    )\n    with torch.no_grad():\n        if args.use_typewriter:\n            for generation_output in model.stream_generate(\n                input_ids=input_ids,\n                generation_config=generation_config,\n                return_dict_in_generate=True,\n                output_scores=False,\n                repetition_penalty=float(repetition_penalty),\n            ):\n                outputs = tokenizer.batch_decode(generation_output)\n                show_text = \"\\n--------------------------------------------\\n\".join(\n                    [output.split(\"### Response:\")[1].strip().replace('�','')+\" ▌\" for output in outputs]\n                )\n                # if show_text== '':\n                #     yield last_show_text\n                # else:\n                yield show_text\n            yield outputs[0].split(\"### Response:\")[1].strip().replace('�','')\n        else:\n            generation_output = model.generate(\n                input_ids=input_ids,\n                generation_config=generation_config,\n                return_dict_in_generate=True,\n                output_scores=False,\n                repetition_penalty=1.3,\n            )\n            output = generation_output.sequences[0]\n            output = tokenizer.decode(output).split(\"### Response:\")[1].strip()\n            print(output)\n            yield output\n\n\ngr.Interface(\n    fn=evaluate,\n    inputs=[\n        gr.components.Textbox(\n            lines=2, label=\"Input\", placeholder=\"Tell me about alpacas.\"\n        ),\n        gr.components.Slider(minimum=0, maximum=1, value=0.1, label=\"Temperature\"),\n        gr.components.Slider(minimum=0, maximum=1, value=0.75, label=\"Top p\"),\n        gr.components.Slider(minimum=0, maximum=100, step=1, value=40, label=\"Top k\"),\n        gr.components.Slider(minimum=1, maximum=10, step=1, value=4, label=\"Beams Number\"),\n        gr.components.Slider(\n            minimum=1, maximum=2000, step=1, value=256, label=\"Max New Tokens\"\n        ),\n        gr.components.Slider(\n            minimum=1, maximum=300, step=1, value=1, label=\"Min New Tokens\"\n        ),\n        gr.components.Slider(\n            minimum=0.1, maximum=10.0, step=0.1, value=2.0, label=\"Repetition Penalty\"\n        ),\n    ],\n    outputs=[\n        gr.inputs.Textbox(\n            lines=25,\n            label=\"Output\",\n        )\n    ],\n    title=\"Chinese-Vicuna 中文小羊驼\",\n    description=\"中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。\",\n).queue().launch(share=True)\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "interaction.py",
          "type": "blob",
          "size": 5.8466796875,
          "content": "import sys\nimport torch\nfrom peft import PeftModel\nimport transformers\nimport gradio as gr\nimport argparse\nimport warnings\nimport os\n\n\nassert (\n    \"LlamaTokenizer\" in transformers._import_structure[\"models.llama\"]\n), \"LLaMA is now in HuggingFace's main branch.\\nPlease reinstall it: pip uninstall transformers && pip install git+https://github.com/huggingface/transformers.git\"\nfrom transformers import LlamaTokenizer, LlamaForCausalLM, GenerationConfig\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--model_path\", type=str, default=\"decapoda-research/llama-7b-hf\")\nparser.add_argument(\"--lora_path\", type=str, default=\"./lora-Vicuna/checkpoint-final\")\nparser.add_argument(\"--use_local\", type=int, default=1)\nargs = parser.parse_args()\n\ntokenizer = LlamaTokenizer.from_pretrained(args.model_path)\n\nLOAD_8BIT = True\nBASE_MODEL = args.model_path\nLORA_WEIGHTS = args.lora_path\n\n# fix the path for local checkpoint\nlora_bin_path = os.path.join(args.lora_path, \"adapter_model.bin\")\nprint(lora_bin_path)\nif not os.path.exists(lora_bin_path) and args.use_local:\n    pytorch_bin_path = os.path.join(args.lora_path, \"pytorch_model.bin\")\n    print(pytorch_bin_path)\n    if os.path.exists(pytorch_bin_path):\n        os.rename(pytorch_bin_path, lora_bin_path)\n        warnings.warn(\"The file name of the lora checkpoint'pytorch_model.bin' is replaced with 'adapter_model.bin'\")\n    else:\n        assert ('Checkpoint is not Found!')\nif torch.cuda.is_available():\n    device = \"cuda\"\nelse:\n    device = \"cpu\"\n\ntry:\n    if torch.backends.mps.is_available():\n        device = \"mps\"\nexcept:\n    pass\n\nif device == \"cuda\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        load_in_8bit=LOAD_8BIT,\n        torch_dtype=torch.float16,\n        device_map=\"auto\", #device_map={\"\": 0},\n    )\n    model = PeftModel.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        torch_dtype=torch.float16,\n        device_map=\"auto\", #device_map={\"\": 0},\n    )\nelif device == \"mps\":\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\n    model = PeftModel.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n        torch_dtype=torch.float16,\n    )\nelse:\n    model = LlamaForCausalLM.from_pretrained(\n        BASE_MODEL, device_map={\"\": device}, low_cpu_mem_usage=True\n    )\n    model = PeftModel.from_pretrained(\n        model,\n        LORA_WEIGHTS,\n        device_map={\"\": device},\n    )\n\ndef generate_prompt(instruction, input=None):\n    if input:\n        return f\"\"\"The following is a conversation between an AI assistant called Assistant and a human user called User.\n\n### Instruction:\n{instruction}\n\n### Input:\n{input}\n\n### Response:\"\"\"\n    else:\n        return f\"\"\"The following is a conversation between an AI assistant called Assistant and a human user called User.\n\n### Instruction:\n{instruction}\n\n### Response:\"\"\"\n\nif not LOAD_8BIT:\n    model.half()  # seems to fix bugs for some users.\n\nmodel.eval()\nif torch.__version__ >= \"2\" and sys.platform != \"win32\":\n    model = torch.compile(model)\n\ndef interaction(\n    input,\n    history,\n    temperature=0.1,\n    top_p=0.75,\n    top_k=40,\n    num_beams=4,\n    max_new_tokens=128,\n    repetition_penalty=1.0,\n    max_memory=256,\n    **kwargs,\n):\n    now_input = input\n    history = history or []\n    if len(history) != 0:\n        input = \"\\n\".join([\"User:\" + i[0]+\"\\n\"+\"Assistant:\" + i[1] for i in history]) + \"\\n\" + \"User:\" + input\n        if len(input) > max_memory:\n            input = input[-max_memory:]\n    print(input)\n    print(len(input))\n    prompt = generate_prompt(input)\n    inputs = tokenizer(prompt, return_tensors=\"pt\")\n    input_ids = inputs[\"input_ids\"].to(device)\n    generation_config = GenerationConfig(\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        num_beams=num_beams,\n        **kwargs,\n    )\n    with torch.no_grad():\n        generation_output = model.generate(\n            input_ids=input_ids,\n            generation_config=generation_config,\n            return_dict_in_generate=True,\n            output_scores=True,\n            max_new_tokens=max_new_tokens,\n            repetition_penalty=float(repetition_penalty),\n        )\n    s = generation_output.sequences[0]\n    output = tokenizer.decode(s)\n    output = output.split(\"### Response:\")[1].strip()\n    output = output.replace(\"Belle\", \"Vicuna\")\n    if 'User:' in output:\n        output = output.split(\"User:\")[0]\n    history.append((now_input, output))\n    print(history)\n    return history, history\n\nchatbot = gr.Chatbot().style(color_map=(\"green\", \"pink\"))\ndemo = gr.Interface(\n    fn=interaction,\n    inputs=[\n        gr.components.Textbox(\n            lines=2, label=\"Input\", placeholder=\"Tell me about alpacas.\"\n        ),\n        \"state\",\n        gr.components.Slider(minimum=0, maximum=1, value=1.0, label=\"Temperature\"),\n        gr.components.Slider(minimum=0, maximum=1, value=0.9, label=\"Top p\"),\n        gr.components.Slider(minimum=0, maximum=100, step=1, value=60, label=\"Top k\"),\n        gr.components.Slider(minimum=1, maximum=5, step=1, value=2, label=\"Beams\"),\n        gr.components.Slider(\n            minimum=1, maximum=2000, step=1, value=128, label=\"Max new tokens\"\n        ),\n        gr.components.Slider(\n            minimum=0.1, maximum=10.0, step=0.1, value=2.0, label=\"Repetition Penalty\"\n        ),\n        gr.components.Slider(\n            minimum=0, maximum=2000, step=1, value=256, label=\"max memory\"\n        ),\n    ],\n    outputs=[chatbot, \"state\"],\n    allow_flagging=\"auto\",\n    title=\"Chinese-Vicuna 中文小羊驼\",\n    description=\"中文小羊驼由各种高质量的开源instruction数据集，结合Alpaca-lora的代码训练而来，模型基于开源的llama7B，主要贡献是对应的lora模型。由于代码训练资源要求较小，希望为llama中文lora社区做一份贡献。\",\n)\ndemo.queue().launch(share=True, inbrowser=True)"
        },
        {
          "name": "prompt.py",
          "type": "blob",
          "size": 8.962890625,
          "content": "\nimport transformers\nfrom utils import printf\nimport copy\n\nclass prompt:\n    def __init__(self, tokenizer, max_len, add_eos=True):\n        self.tokenizer = tokenizer\n        self.max_len = max_len\n        self.add_eos=add_eos\n\nclass instruct_prompt(prompt):\n    prompt = (\n        \"Below is an instruction that describes a task. Write a response that appropriately completes the request.\\n\\n\"\n        \"### Instruction:\\n{instruction}\\n\\n### Response:\"\n    )\n    prompt_input = (\n        \"Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\\n\\n\"\n        \"### Instruction:{instruction}\\n\\n### Input:{input}\\n\\n### Response:\"\n    )\n    prompt_history = \"User:{input}\\n\\nAssistant:{output}\\n\\n\"\n    prompt_post = \"User:{input}\\n\\nAssistant:\"\n\n    def preprocess_gen(self, data_point):\n        if 'history' not in data_point:\n        # single instruction format {'instruction':..,'input':..}\n            if 'input' in data_point:\n                user_prompt = self.prompt_input.format_map(data_point)\n            else:\n                user_prompt = self.prompt.format_map(data_point)\n        else:\n        # multi turn format {'history':[..], 'input':[..]}\n            user_prompt = \"\\n\".join([\"User:\" + i['input']+\"\\n\"+\"Assistant:\" + i['output'] for i in data_point['history']]) + \"\\nUser:\" + data_point['input'] + \"\\nAssistant:\"\n            user_prompt = user_prompt[-self.max_len:]\n        user_prompt=self.prompt.format_map({'instruction':user_prompt})\n        input_ids = self.tokenizer(user_prompt)[\"input_ids\"]\n        return input_ids\n\n    def preprocess_train(self, data_point):\n        # single instruction format {'instruction':..,'input':..,'output':..}\n        if 'instruction' in data_point:\n            if 'input' in data_point:\n                user_prompt = self.prompt_input.format_map(data_point)\n            else:\n                user_prompt = self.prompt.format_map(data_point)\n            output = data_point[\"output\"]\n        # multi turn format {'input':[..], 'output':[..]}\n        else:\n            user_prompt = ''\n            lens = len(data_point['input'])\n            for i in range(lens-1):\n                user_prompt += self.prompt_history.format_map({'input':data_point['input'][i],'output':data_point['output'][i]})\n            user_prompt += self.prompt_post.format_map({'input':data_point['input'][-1]})\n            user_prompt = self.prompt.format_map({'instruction': user_prompt})\n            output = data_point['output'][-1]\n\n        len_user_prompt_tokens = (len(self.tokenizer(\n            user_prompt,\n            truncation=True,\n            max_length=self.max_len + 1,\n        )[\"input_ids\"])- 1)  # no eos token\n        full_tokens = self.tokenizer(\n            user_prompt + output,\n            truncation=True,\n            max_length=self.max_len + 1,\n            padding=\"max_length\",\n        )[\"input_ids\"][:-1]\n        return {\n            \"input_ids\": full_tokens,\n            \"labels\": [-100] * len_user_prompt_tokens\n            + full_tokens[len_user_prompt_tokens:],\n            \"attention_mask\": [1] * (len(full_tokens)),\n        }\n\n    def data_collator(self,):\n        return transformers.DataCollatorForLanguageModeling(self.tokenizer, mlm=False)\n\n    def postprocess(self, text, render=True):\n        #import pdb;pdb.set_trace()\n        printf(text)\n        output = text.split(\"### Response:\")[1].strip()\n        output = output.replace(\"Belle\", \"Vicuna\")\n        printf(output)\n        if '###' in output:\n            output = output.split(\"###\")[0]\n        if 'User' in output:\n            output = output.split(\"User\")[0]\n        output = output.replace('�','').replace('</s>', '') \n        if render:\n            # fix gradio chatbot markdown code render bug\n            lines = output.split(\"\\n\")\n            for i, line in enumerate(lines):\n                if \"```\" in line:\n                    if line != \"```\":\n                        lines[i] = f'<pre><code class=\"language-{lines[i][3:]}\">'\n                    else:\n                        lines[i] = '</code></pre>'\n                else:\n                    if i > 0:\n                        lines[i] = \"<br/>\" + line.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"__\", '\\_\\_')\n            output =  \"\".join(lines)\n            # output = output.replace('<br/><pre>','\\n<pre>') work for html; but not for gradio\n        return output\n\nclass chat_prompt(prompt):\n    prompt_pre = (\n        \"The following is a conversation between an AI assistant called Assistant and a human user called User. \"\n        \"The assistant is intelligent, knowledgeable and polite to answer questions of user.\\n\\n\"\n    )\n    prompt_history = \"User:{input}\\n\\nAssistant:{output}\\n\\n\"\n    prompt_post = \"User:{input}\\n\\nAssistant:\"\n\n    def preprocess_gen(self, data_point):\n        user_prompt = self.prompt_pre\n        len_avail = self.max_len - len(self.tokenizer(user_prompt, add_special_tokens=False)['input_ids'])\n        input_prompt = self.prompt_post.format_map({'input':data_point['input']})\n        len_avail -= len(self.tokenizer(input_prompt, add_special_tokens=False)['input_ids'])\n        lens = len(data_point['history'])\n        tokenized_lens = []\n        for i in range(lens):\n            tmp_prompt = self.prompt_history.format_map(data_point['history'][i])\n            tokenized_lens.append(len(self.tokenizer(tmp_prompt,add_special_tokens=False)[\"input_ids\"]))\n        \n        # 启发式：/2 优先除前面的\n        i = 0\n        while sum(tokenized_lens) > len_avail and i < lens:\n            history = data_point['history'][i]\n            tmp_len1 = len(history['input'])\n            tmp_len2 = len(history['output'])\n            if tmp_len2 > tmp_len1:\n                history['output'] = history['output'][:tmp_len2//2]\n            else:\n                history['input'] = history['input'][:tmp_len1//2]\n            prompt = self.prompt_history.format_map(history)\n            single_len =(len(self.tokenizer(prompt,add_special_tokens=False)[\"input_ids\"]))\n            tokenized_lens[i] = single_len\n            i += 1\n        total_len = sum(tokenized_lens)\n        # 还不够的话 直接截断\n        while total_len > len_avail and i < lens - 1 :\n            total_len -= tokenized_lens[i]\n            data_point['history'] = data_point['history'][1:]\n            i += 1\n        # 最终合并\n        for i in range(lens):\n            user_prompt += self.prompt_history.format_map(data_point['history'][i])\n        user_prompt += input_prompt\n        printf({'real_input:':user_prompt})\n        inputs = self.tokenizer(user_prompt)[\"input_ids\"]\n        return inputs\n\n    def preprocess_train(self, data_point):\n        user_prompt = self.prompt_pre\n        lens = len(data_point['input'])\n        for i in range(lens-1):\n            user_prompt += self.prompt_history.format_map({'input':data_point['input'][i].strip(),'output':data_point['output'][i].strip()})\n        user_prompt += self.prompt_post.format_map({'input':data_point['input'][-1].strip()})\n\n        len_user_prompt_tokens = len(self.tokenizer(\n            user_prompt,\n            truncation=True,\n            max_length=self.max_len,\n        )[\"input_ids\"]) - 1 # remove extra eos\n        if self.add_eos:\n            full_tokens = self.tokenizer(\n                user_prompt + data_point[\"output\"][-1].strip(),\n                truncation=True,\n                padding=False,\n                max_length=self.max_len,\n            )[\"input_ids\"] # need eos\n        else:\n            full_tokens = self.tokenizer(\n                user_prompt + data_point[\"output\"][-1].strip(),\n                truncation=True,\n                padding=False,\n                max_length=self.max_len+1,\n            )[\"input_ids\"][:-1] # delete eos\n        return {\n            \"input_ids\": full_tokens,\n            \"labels\": [-100] * len_user_prompt_tokens + full_tokens[len_user_prompt_tokens:],\n            \"attention_mask\": [1] * (len(full_tokens)),\n        }\n\n    def data_collator(self,):\n        return transformers.DataCollatorForSeq2Seq(self.tokenizer)\n\n    def postprocess(self, text, render=False):\n        output = text.split(\"Assistant:\")[-1].strip()\n        if 'User:' in output:\n            output = output.split(\"User:\")[0]\n        output = output.replace('�','') \n        if render:\n            # fix gradio chatbot markdown code render bug\n            lines = output.split(\"\\n\")\n            for i, line in enumerate(lines):\n                if \"```\" in line:\n                    if line != \"```\":\n                        lines[i] = f'<pre><code class=\"language-{lines[i][3:]}\">'\n                    else:\n                        lines[i] = '</code></pre>'\n                else:\n                    if i > 0:\n                        lines[i] = \"<br/>\" + line.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"__\", '\\_\\_')\n            output =  \"\".join(lines)\n            # output = output.replace('<br/><pre>','\\n<pre>') work for html; but not for gradio\n        return output\n\n    def get_data_collator():\n        return transformers.DataCollatorForLanguageModeling\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.650390625,
          "content": "accelerate==0.21.0\nappdirs==1.4.4\nbitsandbytes==0.41.1\npydantic==1.10.13\nscipy==1.10.1\ndatasets==2.14.6\ndeepspeed==0.8.3\nevaluate==0.4.0\nfairscale==0.4.13\ntorch==1.13.1\ntorchvision==0.14.1\ngradio==3.20.0\nhuggingface-hub==0.14.0\nloralib==0.1.1\nnvitop==1.0.0\npeft @ git+https://github.com/huggingface/peft.git@13e53fc7ee5d89d59b16523051006dddf0fb7a49\nsentencepiece==0.1.96\ntensorboard==2.12.0\ntexttable==1.6.7\ntokenizers==0.13.2\ntqdm==4.65.0\ntransformers @ git+https://github.com/huggingface/transformers.git@0dcb46e7a4a9e587ba84ff35778ab4233a184c11\ntrlx @ git+https://github.com/CarperAI/trlx.git@b91da7b03d8e9fa0c0d6dce10a8f2611aca3013f\nwandb==0.13.10\ntriton==2.0.0\n"
        },
        {
          "name": "requirements_4bit.txt",
          "type": "blob",
          "size": 0.697265625,
          "content": "accelerate @ git+https://github.com/huggingface/accelerate.git@f9b2e6769b1279b11335d2b87801fa1ca81bb056\nappdirs==1.4.4\nbitsandbytes==0.39.0\ndatasets==2.8.0\ndeepspeed==0.8.3\nevaluate==0.4.0\nfairscale==0.4.13\ntorch==1.13.1\ntorchvision==0.14.1\ngradio==3.20.0\nhuggingface-hub==0.13.3\nloralib==0.1.1\nnvitop==1.0.0\npeft @ git+https://github.com/huggingface/peft.git@3714aa2fff158fdfa637b2b65952580801d890b2\nsentencepiece==0.1.96\ntensorboard==2.12.0\ntexttable==1.6.7\ntokenizers==0.13.2\ntqdm==4.65.0\ntransformers @ git+https://github.com/huggingface/transformers@e45e756d22206ca8fa9fb057c8c3d8fa79bf81c6\ntrlx @ git+https://github.com/CarperAI/trlx.git@b91da7b03d8e9fa0c0d6dce10a8f2611aca3013f\nwandb==0.13.10\ntriton==2.0.0\n"
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_tokenizer.py",
          "type": "blob",
          "size": 2.1962890625,
          "content": "import os\nimport sys\nimport torch\nimport transformers\nimport argparse\nfrom transformers import LlamaForCausalLM, LlamaTokenizer, BitsAndBytesConfig\n\n    \nparser = argparse.ArgumentParser()\nparser.add_argument(\"--model_path\", type=str, default=\"yahma/llama-7b-hf\") #yahma/llama-7b-hf #decapoda-research/llama-7b-hf\nargs = parser.parse_args()\n\ntokenizer = LlamaTokenizer.from_pretrained(\n    args.model_path, add_eos_token=True\n)\n\ntest_text = [\"Hello, nice to meet you!\", \"你好很高兴能见到你！\"]\n\nfor text in test_text:\n    input_ids = tokenizer.encode(text)\n    print(f\"input_ids: {input_ids}\")\n    decode_text = tokenizer.decode(input_ids)\n    print(f\"decode_text: {decode_text}\")\n\n\"\"\"\nCorrect ==>  yahma/llama-7b-hf + newest Transformers(>=4.28.1):\n> !!! Beginning with 1 (bos), ending with 2 (eos) !!!\n\ninput_ids: [1, 15043, 29892, 7575, 304, 5870, 366, 29991, 2]\ndecode_text: <s> Hello, nice to meet you!</s>\ninput_ids: [1, 29871, 30919, 31076, 232, 193, 139, 30528, 31914, 30815, 235, 170, 132, 30780, 30919, 30584, 2]\ndecode_text: <s> 你好很高兴能见到你！</s>\n\nCorrect ==> decapoda-research/llama-7b-hf + Old Transformers like our version(transformers @ git+https://github.com/huggingface/transformers.git@0dcb46e7a4a9e587ba84ff35778ab4233a184c11)\ninput_ids: [1, 15043, 29892, 7575, 304, 5870, 366, 29991, 2]\ndecode_text:  Hello, nice to meet you!\ninput_ids: [1, 29871, 30919, 31076, 232, 193, 139, 30528, 31914, 30815, 235, 170, 132, 30780, 30919, 30584, 2]\ndecode_text:  你好很高兴能见到你！\n\nCorrect ==> decapoda-research/llama-7b-hf + Old Transformers like our version(transformers @ git+https://github.com/huggingface/transformers.git@0dcb46e7a4a9e587ba84ff35778ab4233a184c11)\ninput_ids: [1, 15043, 29892, 7575, 304, 5870, 366, 29991, 2]\ndecode_text:  Hello, nice to meet you!\ninput_ids: [1, 29871, 30919, 31076, 232, 193, 139, 30528, 31914, 30815, 235, 170, 132, 30780, 30919, 30584, 2]\ndecode_text:  你好很高兴能见到你！\n\n\n老版本transformers的问题：代码默认加载tokenizer.model\n新版本transformers的修改：新版本默认加载config\n\ndecapoda-research：config的bos=0，eos=1（×），tokenizer.model是正确的\nyahma：config的bos=1，eos=2，tokenizer.model是正确的\n\"\"\""
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.py",
          "type": "blob",
          "size": 34.5244140625,
          "content": "import logging\nimport sys\nimport os\nimport torch\nimport json\nfrom typing import Optional, Tuple, Union, List, Callable\nfrom transformers import LlamaForCausalLM\nfrom transformers.generation.logits_process import LogitsProcessor\nfrom transformers.generation.beam_search import BeamSearchScorer\nfrom transformers.deepspeed import is_deepspeed_zero3_enabled\nfrom transformers.generation.utils import (\n    LogitsProcessorList,\n    StoppingCriteriaList,\n    GenerationConfig,\n    GenerationMixin,\n)\nimport warnings\nfrom peft import PeftModel, PeftModelForCausalLM, LoraConfig\nimport peft\nimport torch.distributed as dist\nfrom torch import nn\nimport copy\nfrom accelerate.hooks import (\n    AlignDevicesHook,\n    add_hook_to_module,\n    remove_hook_from_submodules,\n)\nfrom accelerate.utils import get_balanced_memory\nfrom huggingface_hub import hf_hub_download\nfrom accelerate import dispatch_model, infer_auto_device_map\nfrom peft.utils import PeftType, set_peft_model_state_dict\n\ndef printf(*args,**kargs):\n    if os.environ.get('DEBUG',False):\n        end = '\\n'\n        if 'end' in kargs:\n            end = kargs['end']\n        print(*args, end=end, flush=True)\n\nclass ColorFormatter(logging.Formatter):\n\n    grey = \"\\x1b[38;20m\"\n    blue = \"\\x1b[34;20m\"\n    yellow = \"\\x1b[33;20m\"\n    red = \"\\x1b[31;20m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n\n    def __init__(self, fmt):\n        super().__init__(fmt)\n        self.FORMATS = {\n            logging.DEBUG: self.grey + fmt + self.reset,\n            logging.INFO: self.blue + fmt + self.reset,\n            logging.WARNING: self.yellow + fmt + self.reset,\n            logging.ERROR: self.red + fmt + self.reset,\n            logging.CRITICAL: self.bold_red + fmt + self.reset\n        }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt)\n        return formatter.format(record)\n\ndef set_console_logger(name):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    consoleHandler = logging.StreamHandler(sys.stdout)\n    consoleHandler.setLevel(logging.INFO)\n    consoleHandler.setFormatter(ColorFormatter(\"%(asctime)s | %(levelname)s %(message)s\"))\n    logger.addHandler(consoleHandler)\n    return logger\n\ndef set_file_logger(name, dir, use_console=False):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    os.makedirs(dir, exist_ok=True)\n\n    if use_console:\n        logger.propagate = False # disable default handler\n        consoleHandler = logging.StreamHandler(sys.stdout)\n        consoleHandler.setLevel(logging.INFO)\n        consoleHandler.setFormatter(ColorFormatter(\"%(asctime)s | %(levelname)s %(message)s\"))\n        logger.addHandler(consoleHandler)\n\n    fileHandler = logging.FileHandler(os.path.join(dir,'session.log'), mode='a') \n    fileHandler.setLevel(logging.INFO)\n    fileHandler.setFormatter(logging.Formatter(\"%(asctime)s | %(levelname)s %(message)s\"))\n    logger.addHandler(fileHandler)\n    return logger\n\ndef to_jsonl(data, path):\n    with open(path, 'a') as f:\n        for line in data:\n            f.write(json.dumps(line,ensure_ascii=False)+'\\n')\n\ndef from_json(path):\n    return json.load(open(path))\n\ndef from_jsonl(path):\n    return [json.loads(line) for line in open(path, 'r') ]\n\ndef to_json(data, path):\n    json.dump(data, open(path, 'w'), ensure_ascii=False)\n\nclass StreamGenerationMixin(GenerationMixin):\n    # support for streamly generation\n    # TODO: group_beam_search\n    @torch.no_grad()\n    def stream_generate(\n        self,\n        input_ids: Optional[torch.Tensor] = None,\n        generation_config: Optional[GenerationConfig] = None,\n        logits_processor: Optional[LogitsProcessorList] = None,\n        stopping_criteria: Optional[StoppingCriteriaList] = None,\n        prefix_allowed_tokens_fn: Optional[\n            Callable[[int, torch.Tensor], List[int]]\n        ] = None,\n        **kwargs,\n    ):\n        if is_deepspeed_zero3_enabled() and dist.world_size() > 1:\n            synced_gpus = True\n        else:\n            synced_gpus = False\n\n        if kwargs.get(\"attention_mask\", None) is not None:\n            # concat prompt attention mask\n            prefix_attention_mask = torch.ones(\n                kwargs[\"input_ids\"].shape[0], self.peft_config.num_virtual_tokens\n            ).to(kwargs[\"input_ids\"].device)\n            kwargs[\"attention_mask\"] = torch.cat(\n                (prefix_attention_mask, kwargs[\"attention_mask\"]), dim=1\n            )\n        if kwargs.get(\"position_ids\", None) is not None:\n            warnings.warn(\n                \"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\"\n            )\n            kwargs[\"position_ids\"] = None\n        if kwargs.get(\"token_type_ids\", None) is not None:\n            warnings.warn(\n                \"Token type ids are not supported for parameter efficient tuning. Ignoring token type ids\"\n            )\n            kwargs[\"token_type_ids\"] = None\n\n        batch_size, input_ids_seq_length = input_ids.shape[0], input_ids.shape[-1]\n\n        if generation_config is None:\n            generation_config = self.generation_config\n        generation_config = copy.deepcopy(generation_config)\n        model_kwargs = generation_config.update(**kwargs)\n\n        bos_token_id, eos_token_id, pad_token_id = (\n            generation_config.bos_token_id,\n            generation_config.eos_token_id,\n            generation_config.pad_token_id,\n        )\n\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n\n        has_default_max_length = (\n            kwargs.get(\"max_length\") is None\n            and generation_config.max_length is not None\n        )\n        if has_default_max_length and generation_config.max_new_tokens is None:\n            warnings.warn(\n                f\"Using `max_length`'s default ({generation_config.max_length}) to control the generation length. \"\n                \"This behaviour is deprecated and will be removed from the config in v5 of Transformers -- we\"\n                \" recommend using `max_new_tokens` to control the maximum length of the generation.\",\n                UserWarning,\n            )\n        elif generation_config.max_new_tokens is not None:\n            generation_config.max_length = (\n                generation_config.max_new_tokens + input_ids_seq_length\n            )\n        if generation_config.min_new_tokens is not None:\n            generation_config.min_length = (\n                generation_config.min_new_tokens + input_ids_seq_length\n            )\n\n        if input_ids_seq_length >= generation_config.max_length:\n            input_ids_string = (\n                \"decoder_input_ids\" if self.config.is_encoder_decoder else \"input_ids\"\n            )\n\n        # 2. Set generation parameters if not already defined\n        logits_processor = (\n            logits_processor if logits_processor is not None else LogitsProcessorList()\n        )\n        stopping_criteria = (\n            stopping_criteria\n            if stopping_criteria is not None\n            else StoppingCriteriaList()\n        )\n        # 7. determine generation mode\n        is_constraint_gen_mode = (\n            generation_config.constraints is not None or generation_config.force_words_ids is not None\n        )\n\n        is_contrastive_search_gen_mode = (\n            generation_config.top_k is not None\n            and generation_config.top_k > 1\n            and generation_config.do_sample is False\n            and generation_config.penalty_alpha is not None\n            and generation_config.penalty_alpha > 0\n        )\n\n        is_greedy_gen_mode = (\n            (generation_config.num_beams == 1)\n            and (generation_config.num_beam_groups == 1)\n            and generation_config.do_sample is False\n            and not is_constraint_gen_mode\n            and not is_contrastive_search_gen_mode\n        )\n        # beam=1 and do_sample=True\n        is_sample_gen_mode = (\n            (generation_config.num_beams == 1)\n            and (generation_config.num_beam_groups == 1)\n            and generation_config.do_sample is True\n            and not is_constraint_gen_mode\n            and not is_contrastive_search_gen_mode\n        )\n        is_beam_gen_mode = (\n            (generation_config.num_beams > 1)\n            and (generation_config.num_beam_groups == 1)\n            and generation_config.do_sample is False\n            and not is_constraint_gen_mode\n            and not is_contrastive_search_gen_mode\n        )\n        is_beam_sample_gen_mode = (\n            (generation_config.num_beams > 1)\n            and (generation_config.num_beam_groups == 1)\n            and generation_config.do_sample is True\n            and not is_constraint_gen_mode\n            and not is_contrastive_search_gen_mode\n        )\n        is_group_beam_gen_mode = (\n            (generation_config.num_beams > 1)\n            and (generation_config.num_beam_groups > 1)\n            and not is_constraint_gen_mode\n            and not is_contrastive_search_gen_mode\n        )\n        # 8. prepare distribution pre_processing samplers\n        logits_processor = self._get_logits_processor(\n            generation_config=generation_config,\n            input_ids_seq_length=input_ids_seq_length,\n            encoder_input_ids=input_ids,\n            prefix_allowed_tokens_fn=prefix_allowed_tokens_fn,\n            logits_processor=logits_processor,\n        )\n        # 9. prepare stopping criteria\n        stopping_criteria = self._get_stopping_criteria(\n            generation_config=generation_config, stopping_criteria=stopping_criteria\n        )\n        logits_warper = self._get_logits_warper(generation_config)\n\n        if is_greedy_gen_mode:\n            # 11. run greedy search\n            return self.stream_greedy_search(\n                input_ids,\n                logits_processor,\n                stopping_criteria,\n                generation_config,\n                synced_gpus,\n                **model_kwargs,\n            )\n        elif is_sample_gen_mode:\n            # 12. expand input_ids with `num_return_sequences` additional sequences per batch\n            input_ids, model_kwargs = self._expand_inputs_for_generation(\n                input_ids=input_ids,\n                expand_size=generation_config.num_return_sequences,\n                is_encoder_decoder=self.config.is_encoder_decoder,\n                **model_kwargs,\n            )\n            return self.stream_sample(\n                generation_config,\n                input_ids,\n                logits_processor,\n                logits_warper,\n                stopping_criteria,\n                synced_gpus,\n                **model_kwargs,\n            )\n        elif is_beam_gen_mode:\n            return self.stream_beam_search(\n                generation_config,\n                input_ids,\n                logits_processor,\n                stopping_criteria,\n                synced_gpus,\n                **model_kwargs,\n            )\n        elif is_beam_sample_gen_mode:\n            # interleave input_ids with `num_beams` additional sequences per batch\n            return self.stream_beam_sample(\n                input_ids,\n                logits_processor,\n                logits_warper,\n                stopping_criteria,\n                generation_config,\n                synced_gpus,\n                **model_kwargs,\n            )\n        else:\n            raise Exception('not implement')\n        \n    def stream_sample(\n        self,\n        generation_config,\n        input_ids,\n        logits_processor,\n        logits_warper,\n        stopping_criteria,\n        synced_gpus,\n        **model_kwargs,\n    ):\n        bos_token_id, eos_token_id, pad_token_id = (\n            generation_config.bos_token_id,\n            generation_config.eos_token_id,\n            generation_config.pad_token_id,\n        )\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n        eos_token_id_tensor = torch.tensor(eos_token_id).to(input_ids.device) if eos_token_id is not None else None\n        # keep track of which sequences are already finished\n        unfinished_sequences = torch.ones(input_ids.shape[0], dtype=torch.long, device=input_ids.device)\n        this_peer_finished = False  # used by synced_gpus only\n        scores=()\n        # auto-regressive generation\n        while True:\n            if synced_gpus:\n                # Under synced_gpus the `forward` call must continue until all gpus complete their sequence.\n                # The following logic allows an early break if all peers finished generating their sequence\n                this_peer_finished_flag = torch.tensor(0.0 if this_peer_finished else 1.0).to(input_ids.device)\n                # send 0.0 if we finished, 1.0 otherwise\n                dist.all_reduce(this_peer_finished_flag, op=dist.ReduceOp.SUM)\n                # did all peers finish? the reduced sum will be 0.0 then\n                if this_peer_finished_flag.item() == 0.0:\n                    break\n            # prepare model inputs\n            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n            # forward pass to get next token\n            outputs = self(\n                **model_inputs,\n                return_dict=True,\n            )\n            if synced_gpus and this_peer_finished:\n                continue  # don't waste resources running the code we don't need\n            next_token_logits = outputs.logits[:, -1, :]\n            # pre-process distribution\n            next_token_scores = logits_processor(input_ids, next_token_logits)\n            next_token_scores = logits_warper(input_ids, next_token_scores)\n\n            # sample\n            probs = nn.functional.softmax(next_token_scores, dim=-1)\n            next_tokens = torch.multinomial(probs, num_samples=1).squeeze(1)\n\n            # finished sentences should have their next token be a padding token\n            if eos_token_id is not None:\n                if pad_token_id is None:\n                    raise ValueError(\"If `eos_token_id` is defined, make sure that `pad_token_id` is defined.\")\n                next_tokens = next_tokens * unfinished_sequences + pad_token_id * (1 - unfinished_sequences)\n\n            # update generated ids, model inputs, and length for next step\n            input_ids = torch.cat([input_ids, next_tokens[:, None]], dim=-1)\n            model_kwargs = self._update_model_kwargs_for_generation(\n                outputs, model_kwargs, is_encoder_decoder=self.config.is_encoder_decoder\n            )\n            yield input_ids\n            # if eos_token was found in one sentence, set sentence to finished\n            if eos_token_id_tensor is not None:\n                unfinished_sequences = unfinished_sequences.mul(\n                    next_tokens.tile(eos_token_id_tensor.shape[0], 1).ne(eos_token_id_tensor.unsqueeze(1)).prod(dim=0)\n                )\n            \n            # stop when each sentence is finished, or if we exceed the maximum length\n            if unfinished_sequences.max() == 0 or stopping_criteria(input_ids, scores):\n                if not synced_gpus:\n                    break\n                else:\n                    this_peer_finished = True\n        yield input_ids\n\n    def stream_beam_sample(\n        self,\n        input_ids,\n        logits_processor,\n        logits_warper,\n        stopping_criteria,\n        generation_config,\n        synced_gpus,\n        **model_kwargs,\n    ):\n        bos_token_id, eos_token_id, pad_token_id = (\n            generation_config.bos_token_id,\n            generation_config.eos_token_id,\n            generation_config.pad_token_id,\n        )\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n        eos_token_id_tensor = torch.tensor(eos_token_id).to(input_ids.device) if eos_token_id is not None else None\n        num_beams = generation_config.num_beams\n        batch_size, cur_len = input_ids.shape[0], input_ids.shape[-1]\n        beam_scorer = BeamSearchScorer(\n            batch_size=batch_size,\n            num_beams=generation_config.num_beams,\n            device=input_ids.device,\n            length_penalty=generation_config.length_penalty,\n            do_early_stopping=generation_config.early_stopping,\n            num_beam_hyps_to_keep=generation_config.num_return_sequences,\n            max_length=generation_config.max_length,\n        )\n        input_ids, model_kwargs = self._expand_inputs_for_generation(\n            input_ids=input_ids,\n            expand_size=generation_config.num_beams * generation_config.num_return_sequences,\n            is_encoder_decoder=self.config.is_encoder_decoder,\n            **model_kwargs,\n        )\n        scores = ()\n        beam_scores = torch.zeros((batch_size, num_beams), dtype=torch.float, device=input_ids.device)\n        beam_scores = beam_scores.view((batch_size * num_beams,))\n\n        this_peer_finished = False  # used by synced_gpus only\n        while True:\n            if synced_gpus:\n                # Under synced_gpus the `forward` call must continue until all gpus complete their sequence.\n                # The following logic allows an early break if all peers finished generating their sequence\n                this_peer_finished_flag = torch.tensor(0.0 if this_peer_finished else 1.0).to(input_ids.device)\n                # send 0.0 if we finished, 1.0 otherwise\n                dist.all_reduce(this_peer_finished_flag, op=dist.ReduceOp.SUM)\n                # did all peers finish? the reduced sum will be 0.0 then\n                if this_peer_finished_flag.item() == 0.0:\n                    break\n\n            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n            outputs = self(\n                **model_inputs,\n                return_dict=True,\n            )\n\n            if synced_gpus and this_peer_finished:\n                cur_len = cur_len + 1\n                continue  # don't waste resources running the code we don't need\n\n            next_token_logits = outputs.logits[:, -1, :]\n\n            # hack: adjust tokens for Marian. For Marian we have to make sure that the `pad_token_id`\n            # cannot be generated both before and after the `nn.functional.log_softmax` operation.\n            next_token_logits = self.adjust_logits_during_generation(next_token_logits, cur_len=cur_len)\n            next_token_scores = nn.functional.log_softmax(\n                next_token_logits, dim=-1\n            )  # (batch_size * num_beams, vocab_size)\n\n            next_token_scores_processed = logits_processor(input_ids, next_token_scores)\n            next_token_scores = next_token_scores_processed + beam_scores[:, None].expand_as(next_token_scores)\n            # Note: logits warpers are intentionally applied after adding running beam scores. On some logits warpers\n            # (like top_p) this is indiferent, but on others (like temperature) it is not. For reference, see\n            # https://github.com/huggingface/transformers/pull/5420#discussion_r449779867\n            next_token_scores = logits_warper(input_ids, next_token_scores)\n\n            # reshape for beam search\n            vocab_size = next_token_scores.shape[-1]\n            next_token_scores = next_token_scores.view(batch_size, num_beams * vocab_size)\n\n            probs = nn.functional.softmax(next_token_scores, dim=-1)\n\n            next_tokens = torch.multinomial(probs, num_samples=2 * num_beams)\n            next_token_scores = torch.gather(next_token_scores, -1, next_tokens)\n\n            next_token_scores, _indices = torch.sort(next_token_scores, descending=True, dim=1)\n            next_tokens = torch.gather(next_tokens, -1, _indices)\n\n            next_indices = torch.div(next_tokens, vocab_size, rounding_mode=\"floor\")\n            next_tokens = next_tokens % vocab_size\n\n            # stateless\n            beam_outputs = beam_scorer.process(\n                input_ids,\n                next_token_scores,\n                next_tokens,\n                next_indices,\n                pad_token_id=pad_token_id,\n                eos_token_id=eos_token_id,\n                beam_indices=None,\n            )\n            beam_scores = beam_outputs[\"next_beam_scores\"]\n            beam_next_tokens = beam_outputs[\"next_beam_tokens\"]\n            beam_idx = beam_outputs[\"next_beam_indices\"]\n\n            input_ids = torch.cat([input_ids[beam_idx, :], beam_next_tokens.unsqueeze(-1)], dim=-1)\n            yield input_ids\n            model_kwargs = self._update_model_kwargs_for_generation(\n                outputs, model_kwargs, is_encoder_decoder=self.config.is_encoder_decoder\n            )\n            if model_kwargs[\"past_key_values\"] is not None:\n                model_kwargs[\"past_key_values\"] = self._reorder_cache(model_kwargs[\"past_key_values\"], beam_idx)\n\n            # increase cur_len\n            cur_len = cur_len + 1\n\n            if beam_scorer.is_done or stopping_criteria(input_ids, scores):\n                if not synced_gpus:\n                    break\n                else:\n                    this_peer_finished = True\n\n        sequence_outputs = beam_scorer.finalize(\n            input_ids,\n            beam_scores,\n            next_tokens,\n            next_indices,\n            pad_token_id=pad_token_id,\n            eos_token_id=eos_token_id,\n            max_length=stopping_criteria.max_length,\n            beam_indices=None,\n        )\n        yield sequence_outputs[\"sequences\"]\n\n    def stream_greedy_search(\n        self,\n        input_ids,\n        logits_processor,\n        stopping_criteria,\n        generation_config,\n        synced_gpus,\n        **model_kwargs,\n    ):\n        # init values\n        bos_token_id, eos_token_id, pad_token_id = (\n            generation_config.bos_token_id,\n            generation_config.eos_token_id,\n            generation_config.pad_token_id,\n        )\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n        eos_token_id_tensor = torch.tensor(eos_token_id).to(input_ids.device) if eos_token_id is not None else None\n        # init attention / hidden states / scores tuples\n        scores = () \n        # keep track of which sequences are already finished\n        unfinished_sequences = torch.ones(input_ids.shape[0], dtype=torch.long, device=input_ids.device)\n        this_peer_finished = False  # used by synced_gpus only\n        while True:\n            if synced_gpus:\n                # Under synced_gpus the `forward` call must continue until all gpus complete their sequence.\n                # The following logic allows an early break if all peers finished generating their sequence\n                this_peer_finished_flag = torch.tensor(0.0 if this_peer_finished else 1.0).to(input_ids.device)\n                # send 0.0 if we finished, 1.0 otherwise\n                dist.all_reduce(this_peer_finished_flag, op=dist.ReduceOp.SUM)\n                # did all peers finish? the reduced sum will be 0.0 then\n                if this_peer_finished_flag.item() == 0.0:\n                    break\n\n            # prepare model inputs\n            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n            # forward pass to get next token\n            outputs = self(\n                **model_inputs,\n                return_dict=True,\n            )\n\n            if synced_gpus and this_peer_finished:\n                continue  # don't waste resources running the code we don't need\n\n            next_token_logits = outputs.logits[:, -1, :]\n            # pre-process distribution\n            next_tokens_scores = logits_processor(input_ids, next_token_logits)\n            # argmax\n            next_tokens = torch.argmax(next_tokens_scores, dim=-1)\n            # finished sentences should have their next token be a padding token\n            if eos_token_id is not None:\n                if pad_token_id is None:\n                    raise ValueError(\"If `eos_token_id` is defined, make sure that `pad_token_id` is defined.\")\n                next_tokens = next_tokens * unfinished_sequences + pad_token_id * (1 - unfinished_sequences)\n            # update generated ids, model inputs, and length for next step\n            input_ids = torch.cat([input_ids, next_tokens[:, None]], dim=-1)\n            model_kwargs = self._update_model_kwargs_for_generation(\n                outputs, model_kwargs, is_encoder_decoder=self.config.is_encoder_decoder\n            )\n            yield input_ids\n            # if eos_token was found in one sentence, set sentence to finished\n            if eos_token_id_tensor is not None:\n                unfinished_sequences = unfinished_sequences.mul(\n                    next_tokens.tile(eos_token_id_tensor.shape[0], 1).ne(eos_token_id_tensor.unsqueeze(1)).prod(dim=0)\n                )\n\n            # stop when each sentence is finished, or if we exceed the maximum length\n            if unfinished_sequences.max() == 0 or stopping_criteria(input_ids, scores):\n                if not synced_gpus:\n                    break\n                else:\n                    this_peer_finished = True\n        yield input_ids\n\n    def stream_beam_search(\n        self,\n        generation_config,\n        input_ids,\n        logits_processor,\n        stopping_criteria,\n        synced_gpus,\n        **model_kwargs,\n    ):\n\n        # 10. go into beam search generation modes\n        # 11. prepare beam search scorer\n        bos_token_id, eos_token_id, pad_token_id = (\n            generation_config.bos_token_id,\n            generation_config.eos_token_id,\n            generation_config.pad_token_id,\n        )\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n        num_beams = generation_config.num_beams\n        batch_size, input_ids_seq_length = input_ids.shape[0], input_ids.shape[-1]\n        beam_scorer = BeamSearchScorer(\n            batch_size=batch_size,\n            num_beams=generation_config.num_beams,\n            device=input_ids.device,\n            length_penalty=generation_config.length_penalty,\n            do_early_stopping=generation_config.early_stopping,\n            num_beam_hyps_to_keep=generation_config.num_return_sequences,\n            max_length=generation_config.max_length,\n        )\n        # 12. interleave input_ids with `num_beams` additional sequences per batch\n        input_ids, model_kwargs = self._expand_inputs_for_generation(\n            input_ids=input_ids,\n            expand_size=generation_config.num_beams,\n            is_encoder_decoder=self.config.is_encoder_decoder,\n            **model_kwargs,\n        )\n        # beam_search logits\n        batch_beam_size, cur_len = input_ids.shape\n        if num_beams * batch_size != batch_beam_size:\n            raise ValueError(\n                f\"Batch dimension of `input_ids` should be {num_beams * batch_size}, but is {batch_beam_size}.\"\n            )\n        beam_scores = torch.zeros(\n            (batch_size, num_beams), dtype=torch.float, device=input_ids.device\n        )\n        beam_scores[:, 1:] = -1e9\n        beam_scores = beam_scores.view((batch_size * num_beams,))\n        this_peer_finished = False  # used by synced_gpus only\n        while True:\n\n            if synced_gpus:\n                # Under synced_gpus the `forward` call must continue until all gpus complete their sequence.\n                # The following logic allows an early break if all peers finished generating their sequence\n                this_peer_finished_flag = torch.tensor(\n                    0.0 if this_peer_finished else 1.0\n                ).to(input_ids.device)\n                # send 0.0 if we finished, 1.0 otherwise\n                dist.all_reduce(this_peer_finished_flag, op=dist.ReduceOp.SUM)\n                # did all peers finish? the reduced sum will be 0.0 then\n                if this_peer_finished_flag.item() == 0.0:\n                    break\n\n            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n            outputs = self(\n                **model_inputs,\n                return_dict=True,\n                output_attentions=False,\n                output_hidden_states=False,\n            )\n\n            if synced_gpus and this_peer_finished:\n                cur_len = cur_len + 1\n                continue  # don't waste resources running the code we don't need\n\n            next_token_logits = outputs.logits[:, -1, :]\n            # next_token_logits = self.adjust_logits_during_generation(next_token_logits, cur_len=cur_len) hack: adjust tokens for Marian.\n            next_token_scores = nn.functional.log_softmax(\n                next_token_logits, dim=-1\n            )  # (batch_size * num_beams, vocab_size)\n            next_token_scores_processed = logits_processor(input_ids, next_token_scores)\n            next_token_scores = next_token_scores_processed + beam_scores[\n                :, None\n            ].expand_as(next_token_scores)\n\n            # reshape for beam search\n            vocab_size = next_token_scores.shape[-1]\n            next_token_scores = next_token_scores.view(\n                batch_size, num_beams * vocab_size\n            )\n\n            # Sample 2 next tokens for each beam (so we have some spare tokens and match output of beam search)\n            next_token_scores, next_tokens = torch.topk(\n                next_token_scores, 2 * num_beams, dim=1, largest=True, sorted=True\n            )\n            next_indices = torch.div(next_tokens, vocab_size, rounding_mode=\"floor\")\n            next_tokens = next_tokens % vocab_size\n            # stateless\n            beam_outputs = beam_scorer.process(\n                input_ids,\n                next_token_scores,\n                next_tokens,\n                next_indices,\n                pad_token_id=pad_token_id,\n                eos_token_id=eos_token_id,\n                beam_indices=None,\n            )\n            beam_scores = beam_outputs[\"next_beam_scores\"]\n            beam_next_tokens = beam_outputs[\"next_beam_tokens\"]\n            beam_idx = beam_outputs[\"next_beam_indices\"]\n\n            input_ids = torch.cat(\n                [input_ids[beam_idx, :], beam_next_tokens.unsqueeze(-1)], dim=-1\n            )\n            model_kwargs = self._update_model_kwargs_for_generation(\n                outputs, model_kwargs, is_encoder_decoder=self.config.is_encoder_decoder\n            )\n            if model_kwargs[\"past_key_values\"] is not None:\n                model_kwargs[\"past_key_values\"] = self._reorder_cache(\n                    model_kwargs[\"past_key_values\"], beam_idx\n                )\n\n            # increase cur_len\n            cur_len = cur_len + 1\n\n            yield input_ids\n\n            if beam_scorer.is_done or stopping_criteria(input_ids, None):\n                if not synced_gpus:\n                    break\n                else:\n                    this_peer_finished = True\n\n        final_result = beam_scorer.finalize(\n            input_ids,\n            beam_scores,\n            next_tokens,\n            next_indices,\n            pad_token_id=pad_token_id,\n            eos_token_id=eos_token_id,\n            max_length=stopping_criteria.max_length,\n            beam_indices=None,\n        )\n        yield final_result[\"sequences\"]\n\nclass StreamLlamaForCausalLM(LlamaForCausalLM, StreamGenerationMixin):\n    pass\n\nclass StreamPeftGenerationMixin(PeftModelForCausalLM, StreamGenerationMixin):\n\n    # default it call `model = MODEL_TYPE_TO_PEFT_MODEL_MAPPING[config.task_type](model, config)`, not cls!! so inherent PeftModelForCausalLM is non sense\n    @classmethod\n    def from_pretrained(cls, model, model_id, adapter_name=\"default\", is_trainable=False,  **kwargs):\n        # work in peft==0.3.0\n        if peft.__version__ >= '0.3.0' and peft.__version__ != '0.3.0.dev0':\n            # load the config\n            from peft.utils import PromptLearningConfig\n            config = LoraConfig.from_pretrained(model_id)\n\n            if (getattr(model, \"hf_device_map\", None) is not None) and len(\n                set(model.hf_device_map.values()).intersection({\"cpu\", \"disk\"})\n            ) > 0:\n                remove_hook_from_submodules(model)\n\n            if isinstance(config, PromptLearningConfig) and is_trainable:\n                raise ValueError(\"Cannot set a prompt learning adapter to trainable when loading pretrained adapter.\")\n            else:\n                config.inference_mode = not is_trainable\n\n            # here is the hack\n            model = cls(model, config, adapter_name)\n            model.load_adapter(model_id, adapter_name, **kwargs)\n            # NOTICE\n            model.base_model_prepare_inputs_for_generation = model.base_model.prepare_inputs_for_generation\n            model._reorder_cache = model.base_model._reorder_cache\n            return model\n        else:\n            return cls.from_pretrained_old_peft_version(model, model_id, **kwargs)\n\n\n    @classmethod\n    def from_pretrained_old_peft_version(cls, model, model_id, **kwargs):\n        # work well in peft@e536616888d51b453ed354a6f1e243fecb02ea08\n\n        # load the config\n        config = LoraConfig.from_pretrained(model_id)\n\n        if getattr(model, \"hf_device_map\", None) is not None:\n            remove_hook_from_submodules(model)\n\n        # here is the hack\n        model = cls(model, config)\n        model._reorder_cache = model.base_model._reorder_cache\n        # load weights if any\n        if os.path.exists(os.path.join(model_id, \"adapter_model.bin\")):\n            filename = os.path.join(model_id, \"adapter_model.bin\")\n        else:\n            try:\n                filename = hf_hub_download(model_id, \"adapter_model.bin\")\n            except:  # noqa\n                raise ValueError(\n                    f\"Can't find weights for {model_id} in {model_id} or in the Hugging Face Hub. \"\n                    f\"Please check that the file {'adapter_model.bin'} is present at {model_id}.\"\n                )\n\n        adapters_weights = torch.load(\n            filename,\n            map_location=torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\"),\n        )\n        # load the weights into the model\n        model = set_peft_model_state_dict(model, adapters_weights)\n        if getattr(model, \"hf_device_map\", None) is not None:\n            device_map = kwargs.get(\"device_map\", \"auto\")\n            max_memory = kwargs.get(\"max_memory\", None)\n            no_split_module_classes = model._no_split_modules\n            if device_map != \"sequential\":\n                max_memory = get_balanced_memory(\n                    model,\n                    max_memory=max_memory,\n                    no_split_module_classes=no_split_module_classes,\n                    low_zero=(device_map == \"balanced_low_0\"),\n                )\n            if isinstance(device_map, str):\n                device_map = infer_auto_device_map(\n                    model,\n                    max_memory=max_memory,\n                    no_split_module_classes=no_split_module_classes,\n                )\n            model = dispatch_model(model, device_map=device_map)\n            hook = AlignDevicesHook(io_same_device=True)\n            if model.peft_config.peft_type == PeftType.LORA:\n                add_hook_to_module(model.base_model.model, hook)\n            else:\n                remove_hook_from_submodules(model.prompt_encoder)\n                add_hook_to_module(model.base_model, hook)\n        return model\n"
        }
      ]
    }
  ]
}